head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.45;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.03.43;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.38;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.34;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.40;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.46;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

/**
 * \file glxcurrent.c
 * Client-side GLX interface for current context management.
 */

#ifdef HAVE_PTHREAD
#include <pthread.h>
#endif

#include "glxclient.h"
#ifdef GLX_USE_APPLEGL
#include <stdlib.h>

#include "apple_glx.h"
#include "apple_glx_context.h"
#endif

#include "glapi.h"

/*
** We setup some dummy structures here so that the API can be used
** even if no context is current.
*/

static GLubyte dummyBuffer[__GLX_BUFFER_LIMIT_SIZE];
static struct glx_context_vtable dummyVtable;
/*
** Dummy context used by small commands when there is no current context.
** All the
** gl and glx entry points are designed to operate as nop's when using
** the dummy context structure.
*/
struct glx_context dummyContext = {
   &dummyBuffer[0],
   &dummyBuffer[0],
   &dummyBuffer[0],
   &dummyBuffer[__GLX_BUFFER_LIMIT_SIZE],
   sizeof(dummyBuffer),
   &dummyVtable
};

/*
 * Current context management and locking
 */

#if defined( HAVE_PTHREAD )

_X_HIDDEN pthread_mutex_t __glXmutex = PTHREAD_MUTEX_INITIALIZER;

# if defined( GLX_USE_TLS )

/**
 * Per-thread GLX context pointer.
 *
 * \c __glXSetCurrentContext is written is such a way that this pointer can
 * \b never be \c NULL.  This is important!  Because of this
 * \c __glXGetCurrentContext can be implemented as trivial macro.
 */
__thread void *__glX_tls_Context __attribute__ ((tls_model("initial-exec")))
   = &dummyContext;

_X_HIDDEN void
__glXSetCurrentContext(struct glx_context * c)
{
   __glX_tls_Context = (c != NULL) ? c : &dummyContext;
}

# else

static pthread_once_t once_control = PTHREAD_ONCE_INIT;

/**
 * Per-thread data key.
 *
 * Once \c init_thread_data has been called, the per-thread data key will
 * take a value of \c NULL.  As each new thread is created the default
 * value, in that thread, will be \c NULL.
 */
static pthread_key_t ContextTSD;

/**
 * Initialize the per-thread data key.
 *
 * This function is called \b exactly once per-process (not per-thread!) to
 * initialize the per-thread data key.  This is ideally done using the
 * \c pthread_once mechanism.
 */
static void
init_thread_data(void)
{
   if (pthread_key_create(&ContextTSD, NULL) != 0) {
      perror("pthread_key_create");
      exit(-1);
   }
}

_X_HIDDEN void
__glXSetCurrentContext(struct glx_context * c)
{
   pthread_once(&once_control, init_thread_data);
   pthread_setspecific(ContextTSD, c);
}

_X_HIDDEN struct glx_context *
__glXGetCurrentContext(void)
{
   void *v;

   pthread_once(&once_control, init_thread_data);

   v = pthread_getspecific(ContextTSD);
   return (v == NULL) ? &dummyContext : (struct glx_context *) v;
}

# endif /* defined( GLX_USE_TLS ) */

#elif defined( THREADS )

#error Unknown threading method specified.

#else

/* not thread safe */
_X_HIDDEN struct glx_context *__glXcurrentContext = &dummyContext;

#endif


_X_HIDDEN void
__glXSetCurrentContextNull(void)
{
   __glXSetCurrentContext(&dummyContext);
#if defined(GLX_DIRECT_RENDERING)
   _glapi_set_dispatch(NULL);   /* no-op functions */
   _glapi_set_context(NULL);
#endif
}

_X_EXPORT GLXContext
glXGetCurrentContext(void)
{
   struct glx_context *cx = __glXGetCurrentContext();

   if (cx == &dummyContext) {
      return NULL;
   }
   else {
      return (GLXContext) cx;
   }
}

_X_EXPORT GLXDrawable
glXGetCurrentDrawable(void)
{
   struct glx_context *gc = __glXGetCurrentContext();
   return gc->currentDrawable;
}

static void
__glXGenerateError(Display * dpy, XID resource,
                   BYTE errorCode, CARD16 minorCode)
{
   xError error;

   error.errorCode = errorCode;
   error.resourceID = resource;
   error.sequenceNumber = dpy->request;
   error.type = X_Error;
   error.majorCode = __glXSetupForCommand(dpy);
   error.minorCode = minorCode;
   _XError(dpy, &error);
}

/**
 * Make a particular context current.
 *
 * \note This is in this file so that it can access dummyContext.
 */
static Bool
MakeContextCurrent(Display * dpy, GLXDrawable draw,
                   GLXDrawable read, GLXContext gc_user)
{
   struct glx_context *gc = (struct glx_context *) gc_user;
   struct glx_context *oldGC = __glXGetCurrentContext();

   /* Make sure that the new context has a nonzero ID.  In the request,
    * a zero context ID is used only to mean that we bind to no current
    * context.
    */
   if ((gc != NULL) && (gc->xid == None)) {
      return GL_FALSE;
   }

   _glapi_check_multithread();

   __glXLock();
   if (oldGC == gc &&
       gc->currentDrawable == draw && gc->currentReadable == read) {
      __glXUnlock();
      return True;
   }

   if (oldGC != &dummyContext) {
      if (--oldGC->thread_refcount == 0) {
	 oldGC->vtable->unbind(oldGC, gc);
	 oldGC->currentDpy = 0;
      }
   }

   if (gc) {
      /* Attempt to bind the context.  We do this before mucking with
       * gc and __glXSetCurrentContext to properly handle our state in
       * case of an error.
       *
       * If an error occurs, set the Null context since we've already
       * blown away our old context.  The caller is responsible for
       * figuring out how to handle setting a valid context.
       */
      if (gc->vtable->bind(gc, oldGC, draw, read) != Success) {
         __glXSetCurrentContextNull();
         __glXUnlock();
         __glXGenerateError(dpy, None, GLXBadContext, X_GLXMakeContextCurrent);
         return GL_FALSE;
      }

      if (gc->thread_refcount == 0) {
         gc->currentDpy = dpy;
         gc->currentDrawable = draw;
         gc->currentReadable = read;
      }
      gc->thread_refcount++;
      __glXSetCurrentContext(gc);
   } else {
      __glXSetCurrentContextNull();
   }

   if (oldGC->thread_refcount == 0 && oldGC != &dummyContext && oldGC->xid == None) {
      /* We are switching away from a context that was
       * previously destroyed, so we need to free the memory
       * for the old handle. */
      oldGC->vtable->destroy(oldGC);
   }

   __glXUnlock();

   return GL_TRUE;
}


_X_EXPORT Bool
glXMakeCurrent(Display * dpy, GLXDrawable draw, GLXContext gc)
{
   return MakeContextCurrent(dpy, draw, draw, gc);
}

_X_EXPORT
GLX_ALIAS(Bool, glXMakeCurrentReadSGI,
          (Display * dpy, GLXDrawable d, GLXDrawable r, GLXContext ctx),
          (dpy, d, r, ctx), MakeContextCurrent)

_X_EXPORT
GLX_ALIAS(Bool, glXMakeContextCurrent,
          (Display * dpy, GLXDrawable d, GLXDrawable r,
           GLXContext ctx), (dpy, d, r, ctx), MakeContextCurrent)
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d41 6
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a40 6
#ifdef GLX_USE_APPLEGL
#include <stdlib.h>

#include "apple_glx.h"
#include "apple_glx_context.h"
#endif
@


1.4
log
@Merge Mesa 9.2.0
@
text
@a215 10
   /* XXX: If this is left out, then libGL ends up not having this
    * symbol, and drivers using it fail to load.  Compare the
    * implementation of this symbol to _glapi_noop_enable_warnings(),
    * though, which gets into the library despite no callers, the same
    * prototypes, and the same compile flags to the files containing
    * them.  Moving the definition to glapi_nop.c gets it into the
    * library, though.
    */
   (void)_glthread_GetID();

a221 10
   }

   if (gc == NULL && (draw != None || read != None)) {
      __glXGenerateError(dpy, (draw != None) ? draw : read,
                         BadMatch, X_GLXMakeContextCurrent);
      return False;
   }
   if (gc != NULL && (draw == None || read == None)) {
      __glXGenerateError(dpy, None, BadMatch, X_GLXMakeContextCurrent);
      return False;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d36 1
a36 1
#ifdef PTHREADS
d76 1
a76 1
#if defined( PTHREADS )
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d46 2
a47 1
#else
a48 1
#endif
d163 1
a163 1
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
d190 1
a190 1
__glXGenerateError(Display * dpy, struct glx_context *gc, XID resource,
d199 1
a199 1
   error.majorCode = gc->majorOpcode;
d215 10
a224 1
   int ret = Success;
d235 1
a235 1
      __glXGenerateError(dpy, gc, (draw != None) ? draw : read,
d240 1
a240 1
      __glXGenerateError(dpy, gc, None, BadMatch, X_GLXMakeContextCurrent);
a243 1
#ifndef GLX_USE_APPLEGL
d246 1
a246 7
   if (gc != NULL && gc->thread_id != 0 && gc->thread_id != _glthread_GetID()) {
      __glXGenerateError(dpy, gc, gc->xid,
                         BadAccess, X_GLXMakeContextCurrent);
      return False;
   }
#endif

d248 2
a249 1
       gc->currentDrawable == draw && gc->currentReadable == read)
d251 1
d254 4
a257 5
      oldGC->vtable->unbind(oldGC, gc);
      oldGC->currentDpy = 0;
      oldGC->currentDrawable = None;
      oldGC->currentReadable = None;
      oldGC->thread_id = 0;
d261 21
a281 6
      gc->currentDpy = dpy;
      gc->currentDrawable = draw;
      gc->currentReadable = read;
#ifndef GLX_USE_APPLEGL
      gc->thread_id = _glthread_GetID();
#endif
a282 1
      ret = gc->vtable->bind(gc, oldGC, draw, read);
d287 1
a287 1
   if (oldGC != &dummyContext && oldGC->xid == None && oldGC != gc) {
d294 1
a294 4
   if (ret) {
      __glXGenerateError(dpy, gc, None, ret, X_GLXMakeContextCurrent);
      return GL_FALSE;
   }
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a47 1
#include "indirect_init.h"
d56 1
a56 1

d63 1
a63 1
static __GLXcontext dummyContext = {
d69 1
a71 8

#ifndef GLX_USE_APPLEGL
/*
** All indirect rendering contexts will share the same indirect dispatch table.
*/
static __GLapi *IndirectAPI = NULL;
#endif

d93 1
a93 1
__glXSetCurrentContext(__GLXcontext * c)
d128 1
a128 1
__glXSetCurrentContext(__GLXcontext * c)
d134 1
a134 1
_X_HIDDEN __GLXcontext *
d142 1
a142 1
   return (v == NULL) ? &dummyContext : (__GLXcontext *) v;
d154 1
a154 1
_X_HIDDEN __GLXcontext *__glXcurrentContext = &dummyContext;
a162 1
#ifndef GLX_USE_APPLEGL
a166 1
#endif
d169 1
a169 4

/************************************************************************/

PUBLIC GLXContext
d172 1
a172 1
   GLXContext cx = __glXGetCurrentContext();
d178 1
a178 1
      return cx;
d182 1
a182 1
PUBLIC GLXDrawable
d185 1
a185 1
   GLXContext gc = __glXGetCurrentContext();
a188 114

#ifndef GLX_USE_APPLEGL
/************************************************************************/

/**
 * Sends a GLX protocol message to the specified display to make the context
 * and the drawables current.
 *
 * \param dpy     Display to send the message to.
 * \param opcode  Major opcode value for the display.
 * \param gc_id   Context tag for the context to be made current.
 * \param draw    Drawable ID for the "draw" drawable.
 * \param read    Drawable ID for the "read" drawable.
 * \param reply   Space to store the X-server's reply.
 *
 * \warning
 * This function assumes that \c dpy is locked with \c LockDisplay on entry.
 */
static Bool
SendMakeCurrentRequest(Display * dpy, CARD8 opcode,
                       GLXContextID gc_id, GLXContextTag gc_tag,
                       GLXDrawable draw, GLXDrawable read,
                       xGLXMakeCurrentReply * reply)
{
   Bool ret;


   LockDisplay(dpy);

   if (draw == read) {
      xGLXMakeCurrentReq *req;

      GetReq(GLXMakeCurrent, req);
      req->reqType = opcode;
      req->glxCode = X_GLXMakeCurrent;
      req->drawable = draw;
      req->context = gc_id;
      req->oldContextTag = gc_tag;
   }
   else {
      __GLXdisplayPrivate *priv = __glXInitialize(dpy);

      /* If the server can support the GLX 1.3 version, we should
       * perfer that.  Not only that, some servers support GLX 1.3 but
       * not the SGI extension.
       */

      if ((priv->majorVersion > 1) || (priv->minorVersion >= 3)) {
         xGLXMakeContextCurrentReq *req;

         GetReq(GLXMakeContextCurrent, req);
         req->reqType = opcode;
         req->glxCode = X_GLXMakeContextCurrent;
         req->drawable = draw;
         req->readdrawable = read;
         req->context = gc_id;
         req->oldContextTag = gc_tag;
      }
      else {
         xGLXVendorPrivateWithReplyReq *vpreq;
         xGLXMakeCurrentReadSGIReq *req;

         GetReqExtra(GLXVendorPrivateWithReply,
                     sz_xGLXMakeCurrentReadSGIReq -
                     sz_xGLXVendorPrivateWithReplyReq, vpreq);
         req = (xGLXMakeCurrentReadSGIReq *) vpreq;
         req->reqType = opcode;
         req->glxCode = X_GLXVendorPrivateWithReply;
         req->vendorCode = X_GLXvop_MakeCurrentReadSGI;
         req->drawable = draw;
         req->readable = read;
         req->context = gc_id;
         req->oldContextTag = gc_tag;
      }
   }

   ret = _XReply(dpy, (xReply *) reply, 0, False);

   UnlockDisplay(dpy);
   SyncHandle();

   return ret;
}


#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
static __GLXDRIdrawable *
FetchDRIDrawable(Display * dpy, GLXDrawable glxDrawable, GLXContext gc)
{
   __GLXdisplayPrivate *const priv = __glXInitialize(dpy);
   __GLXDRIdrawable *pdraw;
   __GLXscreenConfigs *psc;

   if (priv == NULL)
      return NULL;

   psc = &priv->screenConfigs[gc->screen];
   if (psc->drawHash == NULL)
      return NULL;

   if (__glxHashLookup(psc->drawHash, glxDrawable, (void *) &pdraw) == 0)
      return pdraw;

   pdraw = psc->driScreen->createDrawable(psc, glxDrawable,
                                          glxDrawable, gc->mode);
   if (__glxHashInsert(psc->drawHash, glxDrawable, pdraw)) {
      (*pdraw->destroyDrawable) (pdraw);
      return NULL;
   }

   return pdraw;
}
#endif /* GLX_DIRECT_RENDERING */

d190 1
a190 1
__glXGenerateError(Display * dpy, GLXContext gc, XID resource,
a203 2
#endif /* GLX_USE_APPLEGL */

d211 1
a211 1
                   GLXDrawable read, GLXContext gc)
d213 3
a215 20
   const GLXContext oldGC = __glXGetCurrentContext();
#ifdef GLX_USE_APPLEGL
   bool error = apple_glx_make_current_context(dpy, 
                   (oldGC && oldGC != &dummyContext) ? oldGC->driContext : NULL, 
                   gc ? gc->driContext : NULL, draw);
   
   apple_glx_diagnostic("%s: error %s\n", __func__, error ? "YES" : "NO");
   if(error)
      return GL_FALSE;
#else
   xGLXMakeCurrentReply reply;
   const CARD8 opcode = __glXSetupForCommand(dpy);
   const CARD8 oldOpcode = ((gc == oldGC) || (oldGC == &dummyContext))
      ? opcode : __glXSetupForCommand(oldGC->currentDpy);
   Bool bindReturnValue;
   __GLXattribute *state;

   if (!opcode || !oldOpcode) {
      return GL_FALSE;
   }
d235 1
d243 1
d245 18
a262 19
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   /* Bind the direct rendering context to the drawable */
   if (gc && gc->driContext) {
      __GLXDRIdrawable *pdraw = FetchDRIDrawable(dpy, draw, gc);
      __GLXDRIdrawable *pread = FetchDRIDrawable(dpy, read, gc);

      if ((pdraw == NULL) || (pread == NULL)) {
         __glXGenerateError(dpy, gc, (pdraw == NULL) ? draw : read,
                            GLXBadDrawable, X_GLXMakeContextCurrent);
         return False;
      }

      bindReturnValue =
         (gc->driContext->bindContext) (gc->driContext, pdraw, pread);
   }
   else if (!gc && oldGC && oldGC->driContext) {
      bindReturnValue = True;
   }
   else
d264 4
a267 8
   {
      /* Send a glXMakeCurrent request to bind the new context. */
      bindReturnValue =
         SendMakeCurrentRequest(dpy, opcode, gc ? gc->xid : None,
                                ((dpy != oldGC->currentDpy)
                                 || oldGC->isDirect)
                                ? None : oldGC->currentContextTag, draw, read,
                                &reply);
d270 5
a274 3

   if (!bindReturnValue) {
      return False;
d277 3
a279 38
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   if ((dpy != oldGC->currentDpy || (gc && gc->driContext)) &&
       !oldGC->isDirect && oldGC != &dummyContext) {
#else
   if ((dpy != oldGC->currentDpy) && oldGC != &dummyContext) {
#endif
      xGLXMakeCurrentReply dummy_reply;

      /* We are either switching from one dpy to another and have to
       * send a request to the previous dpy to unbind the previous
       * context, or we are switching away from a indirect context to
       * a direct context and have to send a request to the dpy to
       * unbind the previous context.
       */
      (void) SendMakeCurrentRequest(oldGC->currentDpy, oldOpcode, None,
                                    oldGC->currentContextTag, None, None,
                                    &dummy_reply);
   }
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   else if (oldGC->driContext && oldGC != gc) {
      oldGC->driContext->unbindContext(oldGC->driContext);
   }
#endif

#endif /* GLX_USE_APPLEGL */

   /* Update our notion of what is current */
   __glXLock();
   if (gc == oldGC) {
      /* Even though the contexts are the same the drawable might have
       * changed.  Note that gc cannot be the dummy, and that oldGC
       * cannot be NULL, therefore if they are the same, gc is not
       * NULL and not the dummy.
       */
      if(gc) {
        gc->currentDrawable = draw;
        gc->currentReadable = read;
      }
a280 46
   else {
      if (oldGC != &dummyContext) {
         /* Old current context is no longer current to anybody */
         oldGC->currentDpy = 0;
         oldGC->currentDrawable = None;
         oldGC->currentReadable = None;
         oldGC->currentContextTag = 0;
         oldGC->thread_id = 0;
#ifdef GLX_USE_APPLEGL
         
         /*
          * At this point we should check if the context has been
          * through glXDestroyContext, and redestroy it if so.
          */
         if(oldGC->do_destroy) {
            __glXUnlock();
            /* glXDestroyContext uses the same global lock. */
            glXDestroyContext(dpy, oldGC);
            __glXLock();
#else
         if (oldGC->xid == None) {
            /* We are switching away from a context that was
             * previously destroyed, so we need to free the memory
             * for the old handle.
             */
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
            /* Destroy the old direct rendering context */
            if (oldGC->driContext) {
               oldGC->driContext->destroyContext(oldGC->driContext,
                                                 oldGC->psc,
                                                 oldGC->createDpy);
               oldGC->driContext = NULL;
            }
#endif
            __glXFreeContext(oldGC);
#endif /* GLX_USE_APPLEGL */
         }
      }
      if (gc) {
         __glXSetCurrentContext(gc);

         gc->currentDpy = dpy;
         gc->currentDrawable = draw;
         gc->currentReadable = read;
#ifndef GLX_USE_APPLEGL
         gc->thread_id = _glthread_GetID();
a281 28
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
         if (!gc->driContext) {
#endif
            if (!IndirectAPI)
               IndirectAPI = __glXNewIndirectAPI();
            _glapi_set_dispatch(IndirectAPI);

            state = (__GLXattribute *) (gc->client_state_private);

            gc->currentContextTag = reply.contextTag;
            if (state->array_state == NULL) {
               (void) glGetString(GL_EXTENSIONS);
               (void) glGetString(GL_VERSION);
               __glXInitVertexArrayState(gc);
            }
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
         }
         else {
            gc->currentContextTag = -1;
         }
#endif
#endif /* GLX_USE_APPLEGL */
      }
      else {
         __glXSetCurrentContextNull();
      }
   }
   __glXUnlock();
d286 1
a286 1
PUBLIC Bool
d292 1
a292 1
PUBLIC
d297 1
a297 1
PUBLIC
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d48 1
d57 1
a57 1
static struct glx_context_vtable dummyVtable;
d64 1
a64 1
struct glx_context dummyContext = {
a69 1
   &dummyVtable
d72 8
d101 1
a101 1
__glXSetCurrentContext(struct glx_context * c)
d136 1
a136 1
__glXSetCurrentContext(struct glx_context * c)
d142 1
a142 1
_X_HIDDEN struct glx_context *
d150 1
a150 1
   return (v == NULL) ? &dummyContext : (struct glx_context *) v;
d162 1
a162 1
_X_HIDDEN struct glx_context *__glXcurrentContext = &dummyContext;
d171 1
d176 1
d179 4
a182 1
_X_EXPORT GLXContext
d185 1
a185 1
   struct glx_context *cx = __glXGetCurrentContext();
d191 1
a191 1
      return (GLXContext) cx;
d195 1
a195 1
_X_EXPORT GLXDrawable
d198 1
a198 1
   struct glx_context *gc = __glXGetCurrentContext();
d202 114
d317 1
a317 1
__glXGenerateError(Display * dpy, struct glx_context *gc, XID resource,
d331 2
d340 1
a340 1
                   GLXDrawable read, GLXContext gc_user)
d342 20
a361 3
   struct glx_context *gc = (struct glx_context *) gc_user;
   struct glx_context *oldGC = __glXGetCurrentContext();
   int ret = Success;
a380 1
#ifndef GLX_USE_APPLEGL
d388 20
d409 10
d420 9
a428 18
   if (oldGC == gc &&
       gc->currentDrawable == draw && gc->currentReadable == read)
      return True;

   if (oldGC != &dummyContext) {
      oldGC->vtable->unbind(oldGC, gc);
      oldGC->currentDpy = 0;
      oldGC->currentDrawable = None;
      oldGC->currentReadable = None;
      oldGC->thread_id = 0;
   }

   if (gc) {
      gc->currentDpy = dpy;
      gc->currentDrawable = draw;
      gc->currentReadable = read;
#ifndef GLX_USE_APPLEGL
      gc->thread_id = _glthread_GetID();
d430 11
a440 4
      __glXSetCurrentContext(gc);
      ret = gc->vtable->bind(gc, oldGC, draw, read);
   } else {
      __glXSetCurrentContextNull();
d442 5
d448 14
a461 5
   if (oldGC != &dummyContext && oldGC->xid == None && oldGC != gc) {
      /* We are switching away from a context that was
       * previously destroyed, so we need to free the memory
       * for the old handle. */
      oldGC->vtable->destroy(oldGC);
d463 46
d510 26
a535 3
   if (ret) {
      __glXGenerateError(dpy, gc, None, ret, X_GLXMakeContextCurrent);
      return GL_FALSE;
d537 1
a537 1

d542 1
a542 1
_X_EXPORT Bool
d548 1
a548 1
_X_EXPORT
d553 1
a553 1
_X_EXPORT
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d36 1
a36 1
#ifdef HAVE_PTHREAD
d46 2
a49 2
#include "glapi.h"

d76 1
a76 1
#if defined( HAVE_PTHREAD )
d163 1
a163 1
#if defined(GLX_DIRECT_RENDERING)
d190 1
a190 1
__glXGenerateError(Display * dpy, XID resource,
d199 1
a199 1
   error.majorCode = __glXSetupForCommand(dpy);
d215 1
a215 10

   /* XXX: If this is left out, then libGL ends up not having this
    * symbol, and drivers using it fail to load.  Compare the
    * implementation of this symbol to _glapi_noop_enable_warnings(),
    * though, which gets into the library despite no callers, the same
    * prototypes, and the same compile flags to the files containing
    * them.  Moving the definition to glapi_nop.c gets it into the
    * library, though.
    */
   (void)_glthread_GetID();
d226 1
a226 1
      __glXGenerateError(dpy, (draw != None) ? draw : read,
d231 1
a231 1
      __glXGenerateError(dpy, None, BadMatch, X_GLXMakeContextCurrent);
d235 1
d238 7
a244 1
   __glXLock();
d246 1
a246 2
       gc->currentDrawable == draw && gc->currentReadable == read) {
      __glXUnlock();
a247 1
   }
d250 5
a254 4
      if (--oldGC->thread_refcount == 0) {
	 oldGC->vtable->unbind(oldGC, gc);
	 oldGC->currentDpy = 0;
      }
d258 6
a263 21
      /* Attempt to bind the context.  We do this before mucking with
       * gc and __glXSetCurrentContext to properly handle our state in
       * case of an error.
       *
       * If an error occurs, set the Null context since we've already
       * blown away our old context.  The caller is responsible for
       * figuring out how to handle setting a valid context.
       */
      if (gc->vtable->bind(gc, oldGC, draw, read) != Success) {
         __glXSetCurrentContextNull();
         __glXUnlock();
         __glXGenerateError(dpy, None, GLXBadContext, X_GLXMakeContextCurrent);
         return GL_FALSE;
      }

      if (gc->thread_refcount == 0) {
         gc->currentDpy = dpy;
         gc->currentDrawable = draw;
         gc->currentReadable = read;
      }
      gc->thread_refcount++;
d265 1
d270 1
a270 1
   if (oldGC->thread_refcount == 0 && oldGC != &dummyContext && oldGC->xid == None) {
d277 4
a280 1
   __glXUnlock();
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d216 10
d232 10
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d41 6
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a40 6
#ifdef GLX_USE_APPLEGL
#include <stdlib.h>

#include "apple_glx.h"
#include "apple_glx_context.h"
#endif
@


