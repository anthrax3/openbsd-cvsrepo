head	1.4;
access;
symbols
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2010.05.22.20.06.15;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.54.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.54.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.44;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.27.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@/* DO NOT EDIT - This file generated automatically by glX_proto_send.py (from Mesa) script */

/*
 * (C) Copyright IBM Corporation 2004, 2005
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * IBM,
 * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


#include <GL/gl.h>
#include "indirect.h"
#include "glxclient.h"
#include "indirect_size.h"
#include "dispatch.h"
#include "glapi.h"
#include "glthread.h"
#include <GL/glxproto.h>
#ifdef USE_XCB
#include <X11/Xlib-xcb.h>
#include <xcb/xcb.h>
#include <xcb/glx.h>
#endif /* USE_XCB */

#define __GLX_PAD(n) (((n) + 3) & ~3)

#  if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
#    define FASTCALL __attribute__((fastcall))
#  else
#    define FASTCALL
#  endif
#  if defined(__GNUC__)
#    define NOINLINE __attribute__((noinline))
#  else
#    define NOINLINE
#  endif

#if !defined __GNUC__ || __GNUC__ < 3
#  define __builtin_expect(x, y) x
#endif

/* If the size and opcode values are known at compile-time, this will, on
 * x86 at least, emit them with a single instruction.
 */
#define emit_header(dest, op, size)            \
    do { union { short s[2]; int i; } temp;    \
         temp.s[0] = (size); temp.s[1] = (op); \
         *((int *)(dest)) = temp.i; } while(0)

NOINLINE CARD32
__glXReadReply(Display * dpy, size_t size, void *dest,
               GLboolean reply_is_always_array)
{
    xGLXSingleReply reply;

    (void) _XReply(dpy, (xReply *) & reply, 0, False);
    if (size != 0) {
        if ((reply.length > 0) || reply_is_always_array) {
            const GLint bytes = (reply_is_always_array)
                ? (4 * reply.length) : (reply.size * size);
            const GLint extra = 4 - (bytes & 3);

            _XRead(dpy, dest, bytes);
            if (extra < 4) {
                _XEatData(dpy, extra);
            }
        } else {
            (void) memcpy(dest, &(reply.pad3), size);
        }
    }

    return reply.retval;
}

NOINLINE void
__glXReadPixelReply(Display * dpy, __GLXcontext * gc, unsigned max_dim,
                    GLint width, GLint height, GLint depth, GLenum format,
                    GLenum type, void *dest, GLboolean dimensions_in_reply)
{
    xGLXSingleReply reply;
    GLint size;

    (void) _XReply(dpy, (xReply *) & reply, 0, False);

    if (dimensions_in_reply) {
        width = reply.pad3;
        height = reply.pad4;
        depth = reply.pad5;

        if ((height == 0) || (max_dim < 2)) {
            height = 1;
        }
        if ((depth == 0) || (max_dim < 3)) {
            depth = 1;
        }
    }

    size = reply.length * 4;
    if (size != 0) {
        void *buf = Xmalloc(size);

        if (buf == NULL) {
            _XEatData(dpy, size);
            __glXSetError(gc, GL_OUT_OF_MEMORY);
        } else {
            const GLint extra = 4 - (size & 3);

            _XRead(dpy, buf, size);
            if (extra < 4) {
                _XEatData(dpy, extra);
            }

            __glEmptyImage(gc, 3, width, height, depth, format, type,
                           buf, dest);
            Xfree(buf);
        }
    }
}

#define X_GLXSingle 0

NOINLINE FASTCALL GLubyte *
__glXSetupSingleRequest(__GLXcontext * gc, GLint sop, GLint cmdlen)
{
    xGLXSingleReq *req;
    Display *const dpy = gc->currentDpy;

    (void) __glXFlushRenderBuffer(gc, gc->pc);
    LockDisplay(dpy);
    GetReqExtra(GLXSingle, cmdlen, req);
    req->reqType = gc->majorOpcode;
    req->contextTag = gc->currentContextTag;
    req->glxCode = sop;
    return (GLubyte *) (req) + sz_xGLXSingleReq;
}

NOINLINE FASTCALL GLubyte *
__glXSetupVendorRequest(__GLXcontext * gc, GLint code, GLint vop,
                        GLint cmdlen)
{
    xGLXVendorPrivateReq *req;
    Display *const dpy = gc->currentDpy;

    (void) __glXFlushRenderBuffer(gc, gc->pc);
    LockDisplay(dpy);
    GetReqExtra(GLXVendorPrivate, cmdlen, req);
    req->reqType = gc->majorOpcode;
    req->glxCode = code;
    req->vendorCode = vop;
    req->contextTag = gc->currentContextTag;
    return (GLubyte *) (req) + sz_xGLXVendorPrivateReq;
}

const GLuint __glXDefaultPixelStore[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 1 };

#define zero                        (__glXDefaultPixelStore+0)
#define one                         (__glXDefaultPixelStore+8)
#define default_pixel_store_1D      (__glXDefaultPixelStore+4)
#define default_pixel_store_1D_size 20
#define default_pixel_store_2D      (__glXDefaultPixelStore+4)
#define default_pixel_store_2D_size 20
#define default_pixel_store_3D      (__glXDefaultPixelStore+0)
#define default_pixel_store_3D_size 36
#define default_pixel_store_4D      (__glXDefaultPixelStore+0)
#define default_pixel_store_4D_size 36

static FASTCALL NOINLINE void
generic_3_byte(GLint rop, const void *ptr)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;

    emit_header(gc->pc, rop, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), ptr, 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static FASTCALL NOINLINE void
generic_4_byte(GLint rop, const void *ptr)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;

    emit_header(gc->pc, rop, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), ptr, 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static FASTCALL NOINLINE void
generic_6_byte(GLint rop, const void *ptr)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;

    emit_header(gc->pc, rop, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), ptr, 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static FASTCALL NOINLINE void
generic_8_byte(GLint rop, const void *ptr)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;

    emit_header(gc->pc, rop, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), ptr, 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static FASTCALL NOINLINE void
generic_12_byte(GLint rop, const void *ptr)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;

    emit_header(gc->pc, rop, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), ptr, 12);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static FASTCALL NOINLINE void
generic_16_byte(GLint rop, const void *ptr)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;

    emit_header(gc->pc, rop, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), ptr, 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static FASTCALL NOINLINE void
generic_24_byte(GLint rop, const void *ptr)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;

    emit_header(gc->pc, rop, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), ptr, 24);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static FASTCALL NOINLINE void
generic_32_byte(GLint rop, const void *ptr)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;

    emit_header(gc->pc, rop, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), ptr, 32);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLsop_NewList 101
void
__indirect_glNewList(GLuint list, GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_new_list(c, gc->currentContextTag, list, mode);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_NewList, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&list), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&mode), 4);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_EndList 102
void
__indirect_glEndList(void)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 0;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_end_list(c, gc->currentContextTag);
#else
        (void) __glXSetupSingleRequest(gc, X_GLsop_EndList, cmdlen);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLrop_CallList 1
void
__indirect_glCallList(GLuint list)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_CallList, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&list), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CallLists 2
void
__indirect_glCallLists(GLsizei n, GLenum type, const GLvoid * lists)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glCallLists_size(type);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * n));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (gc->currentDpy != NULL), 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_CallLists, cmdlen);
            (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&type), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (lists),
                          (compsize * n));
            gc->pc += cmdlen;
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_CallLists;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&n), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&type), 4);
            __glXSendLargeCommand(gc, pc, 16, lists, (compsize * n));
        }
    }
}

#define X_GLsop_DeleteLists 103
void
__indirect_glDeleteLists(GLuint list, GLsizei range)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_delete_lists(c, gc->currentContextTag, list, range);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_DeleteLists, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&list), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&range), 4);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GenLists 104
GLuint
__indirect_glGenLists(GLsizei range)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLuint retval = (GLuint) 0;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_gen_lists_reply_t *reply =
            xcb_glx_gen_lists_reply(c,
                                    xcb_glx_gen_lists(c,
                                                      gc->currentContextTag,
                                                      range), NULL);
        retval = reply->ret_val;
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GenLists, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&range), 4);
        retval = (GLuint) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return retval;
}

#define X_GLrop_ListBase 3
void
__indirect_glListBase(GLuint base)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ListBase, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&base), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Begin 4
void
__indirect_glBegin(GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Begin, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Bitmap 5
void
__indirect_glBitmap(GLsizei width, GLsizei height, GLfloat xorig,
                    GLfloat yorig, GLfloat xmove, GLfloat ymove,
                    const GLubyte *bitmap)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (bitmap != NULL) ? __glImageSize(width, height, 1, GL_COLOR_INDEX,
                                         GL_BITMAP, 0) : 0;
    const GLuint cmdlen = 48 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_Bitmap, cmdlen);
            (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&xorig), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&yorig), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&xmove), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&ymove), 4);
            if (compsize > 0) {
                (*gc->fillImage) (gc, 2, width, height, 1, GL_COLOR_INDEX,
                                  GL_BITMAP, bitmap, gc->pc + 48, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_Bitmap;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&xorig), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&yorig), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&xmove), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&ymove), 4);
            __glXSendLargeImage(gc, compsize, 2, width, height, 1,
                                GL_COLOR_INDEX, GL_BITMAP, bitmap, pc + 52,
                                pc + 8);
        }
    }
}

#define X_GLrop_Color3bv 6
void
__indirect_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Color3bv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color3bv 6
void
__indirect_glColor3bv(const GLbyte *v)
{
    generic_3_byte(X_GLrop_Color3bv, v);
}

#define X_GLrop_Color3dv 7
void
__indirect_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_Color3dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&green), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&blue), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color3dv 7
void
__indirect_glColor3dv(const GLdouble * v)
{
    generic_24_byte(X_GLrop_Color3dv, v);
}

#define X_GLrop_Color3fv 8
void
__indirect_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Color3fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color3fv 8
void
__indirect_glColor3fv(const GLfloat * v)
{
    generic_12_byte(X_GLrop_Color3fv, v);
}

#define X_GLrop_Color3iv 9
void
__indirect_glColor3i(GLint red, GLint green, GLint blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Color3iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color3iv 9
void
__indirect_glColor3iv(const GLint * v)
{
    generic_12_byte(X_GLrop_Color3iv, v);
}

#define X_GLrop_Color3sv 10
void
__indirect_glColor3s(GLshort red, GLshort green, GLshort blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Color3sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color3sv 10
void
__indirect_glColor3sv(const GLshort * v)
{
    generic_6_byte(X_GLrop_Color3sv, v);
}

#define X_GLrop_Color3ubv 11
void
__indirect_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Color3ubv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color3ubv 11
void
__indirect_glColor3ubv(const GLubyte *v)
{
    generic_3_byte(X_GLrop_Color3ubv, v);
}

#define X_GLrop_Color3uiv 12
void
__indirect_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Color3uiv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color3uiv 12
void
__indirect_glColor3uiv(const GLuint * v)
{
    generic_12_byte(X_GLrop_Color3uiv, v);
}

#define X_GLrop_Color3usv 13
void
__indirect_glColor3us(GLushort red, GLushort green, GLushort blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Color3usv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color3usv 13
void
__indirect_glColor3usv(const GLushort * v)
{
    generic_6_byte(X_GLrop_Color3usv, v);
}

#define X_GLrop_Color4bv 14
void
__indirect_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Color4bv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    (void) memcpy((void *) (gc->pc + 7), (void *) (&alpha), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color4bv 14
void
__indirect_glColor4bv(const GLbyte *v)
{
    generic_4_byte(X_GLrop_Color4bv, v);
}

#define X_GLrop_Color4dv 15
void
__indirect_glColor4d(GLdouble red, GLdouble green, GLdouble blue,
                     GLdouble alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_Color4dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&green), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&blue), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&alpha), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color4dv 15
void
__indirect_glColor4dv(const GLdouble * v)
{
    generic_32_byte(X_GLrop_Color4dv, v);
}

#define X_GLrop_Color4fv 16
void
__indirect_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Color4fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color4fv 16
void
__indirect_glColor4fv(const GLfloat * v)
{
    generic_16_byte(X_GLrop_Color4fv, v);
}

#define X_GLrop_Color4iv 17
void
__indirect_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Color4iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color4iv 17
void
__indirect_glColor4iv(const GLint * v)
{
    generic_16_byte(X_GLrop_Color4iv, v);
}

#define X_GLrop_Color4sv 18
void
__indirect_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Color4sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&alpha), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color4sv 18
void
__indirect_glColor4sv(const GLshort * v)
{
    generic_8_byte(X_GLrop_Color4sv, v);
}

#define X_GLrop_Color4ubv 19
void
__indirect_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Color4ubv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    (void) memcpy((void *) (gc->pc + 7), (void *) (&alpha), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color4ubv 19
void
__indirect_glColor4ubv(const GLubyte *v)
{
    generic_4_byte(X_GLrop_Color4ubv, v);
}

#define X_GLrop_Color4uiv 20
void
__indirect_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Color4uiv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color4uiv 20
void
__indirect_glColor4uiv(const GLuint * v)
{
    generic_16_byte(X_GLrop_Color4uiv, v);
}

#define X_GLrop_Color4usv 21
void
__indirect_glColor4us(GLushort red, GLushort green, GLushort blue,
                      GLushort alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Color4usv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&alpha), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Color4usv 21
void
__indirect_glColor4usv(const GLushort * v)
{
    generic_8_byte(X_GLrop_Color4usv, v);
}

#define X_GLrop_EdgeFlagv 22
void
__indirect_glEdgeFlag(GLboolean flag)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_EdgeFlagv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&flag), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EdgeFlagv 22
void
__indirect_glEdgeFlagv(const GLboolean * flag)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_EdgeFlagv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (flag), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_End 23
void
__indirect_glEnd(void)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 4;
    emit_header(gc->pc, X_GLrop_End, cmdlen);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Indexdv 24
void
__indirect_glIndexd(GLdouble c)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Indexdv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Indexdv 24
void
__indirect_glIndexdv(const GLdouble * c)
{
    generic_8_byte(X_GLrop_Indexdv, c);
}

#define X_GLrop_Indexfv 25
void
__indirect_glIndexf(GLfloat c)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Indexfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Indexfv 25
void
__indirect_glIndexfv(const GLfloat * c)
{
    generic_4_byte(X_GLrop_Indexfv, c);
}

#define X_GLrop_Indexiv 26
void
__indirect_glIndexi(GLint c)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Indexiv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Indexiv 26
void
__indirect_glIndexiv(const GLint * c)
{
    generic_4_byte(X_GLrop_Indexiv, c);
}

#define X_GLrop_Indexsv 27
void
__indirect_glIndexs(GLshort c)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Indexsv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Indexsv 27
void
__indirect_glIndexsv(const GLshort * c)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Indexsv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (c), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Normal3bv 28
void
__indirect_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Normal3bv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&ny), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&nz), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Normal3bv 28
void
__indirect_glNormal3bv(const GLbyte *v)
{
    generic_3_byte(X_GLrop_Normal3bv, v);
}

#define X_GLrop_Normal3dv 29
void
__indirect_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_Normal3dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&ny), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&nz), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Normal3dv 29
void
__indirect_glNormal3dv(const GLdouble * v)
{
    generic_24_byte(X_GLrop_Normal3dv, v);
}

#define X_GLrop_Normal3fv 30
void
__indirect_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Normal3fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&ny), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&nz), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Normal3fv 30
void
__indirect_glNormal3fv(const GLfloat * v)
{
    generic_12_byte(X_GLrop_Normal3fv, v);
}

#define X_GLrop_Normal3iv 31
void
__indirect_glNormal3i(GLint nx, GLint ny, GLint nz)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Normal3iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&ny), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&nz), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Normal3iv 31
void
__indirect_glNormal3iv(const GLint * v)
{
    generic_12_byte(X_GLrop_Normal3iv, v);
}

#define X_GLrop_Normal3sv 32
void
__indirect_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Normal3sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&ny), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&nz), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Normal3sv 32
void
__indirect_glNormal3sv(const GLshort * v)
{
    generic_6_byte(X_GLrop_Normal3sv, v);
}

#define X_GLrop_RasterPos2dv 33
void
__indirect_glRasterPos2d(GLdouble x, GLdouble y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_RasterPos2dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos2dv 33
void
__indirect_glRasterPos2dv(const GLdouble * v)
{
    generic_16_byte(X_GLrop_RasterPos2dv, v);
}

#define X_GLrop_RasterPos2fv 34
void
__indirect_glRasterPos2f(GLfloat x, GLfloat y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_RasterPos2fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos2fv 34
void
__indirect_glRasterPos2fv(const GLfloat * v)
{
    generic_8_byte(X_GLrop_RasterPos2fv, v);
}

#define X_GLrop_RasterPos2iv 35
void
__indirect_glRasterPos2i(GLint x, GLint y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_RasterPos2iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos2iv 35
void
__indirect_glRasterPos2iv(const GLint * v)
{
    generic_8_byte(X_GLrop_RasterPos2iv, v);
}

#define X_GLrop_RasterPos2sv 36
void
__indirect_glRasterPos2s(GLshort x, GLshort y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_RasterPos2sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos2sv 36
void
__indirect_glRasterPos2sv(const GLshort * v)
{
    generic_4_byte(X_GLrop_RasterPos2sv, v);
}

#define X_GLrop_RasterPos3dv 37
void
__indirect_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_RasterPos3dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos3dv 37
void
__indirect_glRasterPos3dv(const GLdouble * v)
{
    generic_24_byte(X_GLrop_RasterPos3dv, v);
}

#define X_GLrop_RasterPos3fv 38
void
__indirect_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_RasterPos3fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos3fv 38
void
__indirect_glRasterPos3fv(const GLfloat * v)
{
    generic_12_byte(X_GLrop_RasterPos3fv, v);
}

#define X_GLrop_RasterPos3iv 39
void
__indirect_glRasterPos3i(GLint x, GLint y, GLint z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_RasterPos3iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos3iv 39
void
__indirect_glRasterPos3iv(const GLint * v)
{
    generic_12_byte(X_GLrop_RasterPos3iv, v);
}

#define X_GLrop_RasterPos3sv 40
void
__indirect_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_RasterPos3sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&z), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos3sv 40
void
__indirect_glRasterPos3sv(const GLshort * v)
{
    generic_6_byte(X_GLrop_RasterPos3sv, v);
}

#define X_GLrop_RasterPos4dv 41
void
__indirect_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_RasterPos4dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&w), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos4dv 41
void
__indirect_glRasterPos4dv(const GLdouble * v)
{
    generic_32_byte(X_GLrop_RasterPos4dv, v);
}

#define X_GLrop_RasterPos4fv 42
void
__indirect_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_RasterPos4fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos4fv 42
void
__indirect_glRasterPos4fv(const GLfloat * v)
{
    generic_16_byte(X_GLrop_RasterPos4fv, v);
}

#define X_GLrop_RasterPos4iv 43
void
__indirect_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_RasterPos4iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos4iv 43
void
__indirect_glRasterPos4iv(const GLint * v)
{
    generic_16_byte(X_GLrop_RasterPos4iv, v);
}

#define X_GLrop_RasterPos4sv 44
void
__indirect_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_RasterPos4sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&z), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&w), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_RasterPos4sv 44
void
__indirect_glRasterPos4sv(const GLshort * v)
{
    generic_8_byte(X_GLrop_RasterPos4sv, v);
}

#define X_GLrop_Rectdv 45
void
__indirect_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_Rectdv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y1), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&x2), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&y2), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rectdv 45
void
__indirect_glRectdv(const GLdouble * v1, const GLdouble * v2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_Rectdv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v1), 16);
    (void) memcpy((void *) (gc->pc + 20), (void *) (v2), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rectfv 46
void
__indirect_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Rectfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x1), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x2), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y2), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rectfv 46
void
__indirect_glRectfv(const GLfloat * v1, const GLfloat * v2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Rectfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (v2), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rectiv 47
void
__indirect_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Rectiv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x1), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x2), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y2), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rectiv 47
void
__indirect_glRectiv(const GLint * v1, const GLint * v2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Rectiv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (v2), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rectsv 48
void
__indirect_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Rectsv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x1), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y1), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x2), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y2), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rectsv 48
void
__indirect_glRectsv(const GLshort * v1, const GLshort * v2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Rectsv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v1), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v2), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord1dv 49
void
__indirect_glTexCoord1d(GLdouble s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_TexCoord1dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord1dv 49
void
__indirect_glTexCoord1dv(const GLdouble * v)
{
    generic_8_byte(X_GLrop_TexCoord1dv, v);
}

#define X_GLrop_TexCoord1fv 50
void
__indirect_glTexCoord1f(GLfloat s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_TexCoord1fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord1fv 50
void
__indirect_glTexCoord1fv(const GLfloat * v)
{
    generic_4_byte(X_GLrop_TexCoord1fv, v);
}

#define X_GLrop_TexCoord1iv 51
void
__indirect_glTexCoord1i(GLint s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_TexCoord1iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord1iv 51
void
__indirect_glTexCoord1iv(const GLint * v)
{
    generic_4_byte(X_GLrop_TexCoord1iv, v);
}

#define X_GLrop_TexCoord1sv 52
void
__indirect_glTexCoord1s(GLshort s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_TexCoord1sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord1sv 52
void
__indirect_glTexCoord1sv(const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_TexCoord1sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord2dv 53
void
__indirect_glTexCoord2d(GLdouble s, GLdouble t)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_TexCoord2dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord2dv 53
void
__indirect_glTexCoord2dv(const GLdouble * v)
{
    generic_16_byte(X_GLrop_TexCoord2dv, v);
}

#define X_GLrop_TexCoord2fv 54
void
__indirect_glTexCoord2f(GLfloat s, GLfloat t)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_TexCoord2fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord2fv 54
void
__indirect_glTexCoord2fv(const GLfloat * v)
{
    generic_8_byte(X_GLrop_TexCoord2fv, v);
}

#define X_GLrop_TexCoord2iv 55
void
__indirect_glTexCoord2i(GLint s, GLint t)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_TexCoord2iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord2iv 55
void
__indirect_glTexCoord2iv(const GLint * v)
{
    generic_8_byte(X_GLrop_TexCoord2iv, v);
}

#define X_GLrop_TexCoord2sv 56
void
__indirect_glTexCoord2s(GLshort s, GLshort t)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_TexCoord2sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&t), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord2sv 56
void
__indirect_glTexCoord2sv(const GLshort * v)
{
    generic_4_byte(X_GLrop_TexCoord2sv, v);
}

#define X_GLrop_TexCoord3dv 57
void
__indirect_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_TexCoord3dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&r), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord3dv 57
void
__indirect_glTexCoord3dv(const GLdouble * v)
{
    generic_24_byte(X_GLrop_TexCoord3dv, v);
}

#define X_GLrop_TexCoord3fv 58
void
__indirect_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_TexCoord3fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord3fv 58
void
__indirect_glTexCoord3fv(const GLfloat * v)
{
    generic_12_byte(X_GLrop_TexCoord3fv, v);
}

#define X_GLrop_TexCoord3iv 59
void
__indirect_glTexCoord3i(GLint s, GLint t, GLint r)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_TexCoord3iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord3iv 59
void
__indirect_glTexCoord3iv(const GLint * v)
{
    generic_12_byte(X_GLrop_TexCoord3iv, v);
}

#define X_GLrop_TexCoord3sv 60
void
__indirect_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_TexCoord3sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&t), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&r), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord3sv 60
void
__indirect_glTexCoord3sv(const GLshort * v)
{
    generic_6_byte(X_GLrop_TexCoord3sv, v);
}

#define X_GLrop_TexCoord4dv 61
void
__indirect_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_TexCoord4dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&r), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&q), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord4dv 61
void
__indirect_glTexCoord4dv(const GLdouble * v)
{
    generic_32_byte(X_GLrop_TexCoord4dv, v);
}

#define X_GLrop_TexCoord4fv 62
void
__indirect_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_TexCoord4fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&q), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord4fv 62
void
__indirect_glTexCoord4fv(const GLfloat * v)
{
    generic_16_byte(X_GLrop_TexCoord4fv, v);
}

#define X_GLrop_TexCoord4iv 63
void
__indirect_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_TexCoord4iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&q), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord4iv 63
void
__indirect_glTexCoord4iv(const GLint * v)
{
    generic_16_byte(X_GLrop_TexCoord4iv, v);
}

#define X_GLrop_TexCoord4sv 64
void
__indirect_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_TexCoord4sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&t), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&r), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&q), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexCoord4sv 64
void
__indirect_glTexCoord4sv(const GLshort * v)
{
    generic_8_byte(X_GLrop_TexCoord4sv, v);
}

#define X_GLrop_Vertex2dv 65
void
__indirect_glVertex2d(GLdouble x, GLdouble y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Vertex2dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex2dv 65
void
__indirect_glVertex2dv(const GLdouble * v)
{
    generic_16_byte(X_GLrop_Vertex2dv, v);
}

#define X_GLrop_Vertex2fv 66
void
__indirect_glVertex2f(GLfloat x, GLfloat y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Vertex2fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex2fv 66
void
__indirect_glVertex2fv(const GLfloat * v)
{
    generic_8_byte(X_GLrop_Vertex2fv, v);
}

#define X_GLrop_Vertex2iv 67
void
__indirect_glVertex2i(GLint x, GLint y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Vertex2iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex2iv 67
void
__indirect_glVertex2iv(const GLint * v)
{
    generic_8_byte(X_GLrop_Vertex2iv, v);
}

#define X_GLrop_Vertex2sv 68
void
__indirect_glVertex2s(GLshort x, GLshort y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Vertex2sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex2sv 68
void
__indirect_glVertex2sv(const GLshort * v)
{
    generic_4_byte(X_GLrop_Vertex2sv, v);
}

#define X_GLrop_Vertex3dv 69
void
__indirect_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_Vertex3dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex3dv 69
void
__indirect_glVertex3dv(const GLdouble * v)
{
    generic_24_byte(X_GLrop_Vertex3dv, v);
}

#define X_GLrop_Vertex3fv 70
void
__indirect_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Vertex3fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex3fv 70
void
__indirect_glVertex3fv(const GLfloat * v)
{
    generic_12_byte(X_GLrop_Vertex3fv, v);
}

#define X_GLrop_Vertex3iv 71
void
__indirect_glVertex3i(GLint x, GLint y, GLint z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Vertex3iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex3iv 71
void
__indirect_glVertex3iv(const GLint * v)
{
    generic_12_byte(X_GLrop_Vertex3iv, v);
}

#define X_GLrop_Vertex3sv 72
void
__indirect_glVertex3s(GLshort x, GLshort y, GLshort z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Vertex3sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&z), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex3sv 72
void
__indirect_glVertex3sv(const GLshort * v)
{
    generic_6_byte(X_GLrop_Vertex3sv, v);
}

#define X_GLrop_Vertex4dv 73
void
__indirect_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_Vertex4dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&w), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex4dv 73
void
__indirect_glVertex4dv(const GLdouble * v)
{
    generic_32_byte(X_GLrop_Vertex4dv, v);
}

#define X_GLrop_Vertex4fv 74
void
__indirect_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Vertex4fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex4fv 74
void
__indirect_glVertex4fv(const GLfloat * v)
{
    generic_16_byte(X_GLrop_Vertex4fv, v);
}

#define X_GLrop_Vertex4iv 75
void
__indirect_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Vertex4iv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex4iv 75
void
__indirect_glVertex4iv(const GLint * v)
{
    generic_16_byte(X_GLrop_Vertex4iv, v);
}

#define X_GLrop_Vertex4sv 76
void
__indirect_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Vertex4sv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&z), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&w), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Vertex4sv 76
void
__indirect_glVertex4sv(const GLshort * v)
{
    generic_8_byte(X_GLrop_Vertex4sv, v);
}

#define X_GLrop_ClipPlane 77
void
__indirect_glClipPlane(GLenum plane, const GLdouble * equation)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 40;
    emit_header(gc->pc, X_GLrop_ClipPlane, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (equation), 32);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&plane), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ColorMaterial 78
void
__indirect_glColorMaterial(GLenum face, GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_ColorMaterial, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CullFace 79
void
__indirect_glCullFace(GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_CullFace, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Fogf 80
void
__indirect_glFogf(GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Fogf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Fogfv 81
void
__indirect_glFogfv(GLenum pname, const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glFogfv_size(pname);
    const GLuint cmdlen = 8 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_Fogfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Fogi 82
void
__indirect_glFogi(GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Fogi, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Fogiv 83
void
__indirect_glFogiv(GLenum pname, const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glFogiv_size(pname);
    const GLuint cmdlen = 8 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_Fogiv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_FrontFace 84
void
__indirect_glFrontFace(GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_FrontFace, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Hint 85
void
__indirect_glHint(GLenum target, GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Hint, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Lightf 86
void
__indirect_glLightf(GLenum light, GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Lightf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&light), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Lightfv 87
void
__indirect_glLightfv(GLenum light, GLenum pname, const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glLightfv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_Lightfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&light), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Lighti 88
void
__indirect_glLighti(GLenum light, GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Lighti, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&light), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Lightiv 89
void
__indirect_glLightiv(GLenum light, GLenum pname, const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glLightiv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_Lightiv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&light), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LightModelf 90
void
__indirect_glLightModelf(GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_LightModelf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LightModelfv 91
void
__indirect_glLightModelfv(GLenum pname, const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glLightModelfv_size(pname);
    const GLuint cmdlen = 8 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_LightModelfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LightModeli 92
void
__indirect_glLightModeli(GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_LightModeli, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LightModeliv 93
void
__indirect_glLightModeliv(GLenum pname, const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glLightModeliv_size(pname);
    const GLuint cmdlen = 8 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_LightModeliv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LineStipple 94
void
__indirect_glLineStipple(GLint factor, GLushort pattern)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_LineStipple, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&factor), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pattern), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LineWidth 95
void
__indirect_glLineWidth(GLfloat width)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_LineWidth, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&width), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Materialf 96
void
__indirect_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Materialf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Materialfv 97
void
__indirect_glMaterialfv(GLenum face, GLenum pname, const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glMaterialfv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_Materialfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Materiali 98
void
__indirect_glMateriali(GLenum face, GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Materiali, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Materialiv 99
void
__indirect_glMaterialiv(GLenum face, GLenum pname, const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glMaterialiv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_Materialiv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PointSize 100
void
__indirect_glPointSize(GLfloat size)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_PointSize, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&size), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PolygonMode 101
void
__indirect_glPolygonMode(GLenum face, GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_PolygonMode, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PolygonStipple 102
void
__indirect_glPolygonStipple(const GLubyte *mask)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (mask != NULL) ? __glImageSize(32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                                       0) : 0;
    const GLuint cmdlen = 24 + __GLX_PAD(compsize);
    emit_header(gc->pc, X_GLrop_PolygonStipple, cmdlen);
    if (compsize > 0) {
        (*gc->fillImage) (gc, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP, mask,
                          gc->pc + 24, gc->pc + 4);
    } else {
        (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                      default_pixel_store_2D_size);
    }
    gc->pc += cmdlen;
    if (gc->pc > gc->limit) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Scissor 103
void
__indirect_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Scissor, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&height), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ShadeModel 104
void
__indirect_glShadeModel(GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ShadeModel, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexParameterf 105
void
__indirect_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_TexParameterf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexParameterfv 106
void
__indirect_glTexParameterfv(GLenum target, GLenum pname,
                            const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glTexParameterfv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_TexParameterfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexParameteri 107
void
__indirect_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_TexParameteri, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexParameteriv 108
void
__indirect_glTexParameteriv(GLenum target, GLenum pname, const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glTexParameteriv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_TexParameteriv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static void
__glx_TexImage_1D2D(unsigned opcode, unsigned dim, GLenum target, GLint level,
                    GLint internalformat, GLsizei width, GLsizei height,
                    GLint border, GLenum format, GLenum type,
                    const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        __glImageSize(width, height, 1, format, type, target);
    const GLuint cmdlen = 56 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, opcode, cmdlen);
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&level), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&internalformat),
                          4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&border), 4);
            (void) memcpy((void *) (gc->pc + 48), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 52), (void *) (&type), 4);
            if ((compsize > 0) && (pixels != NULL)) {
                (*gc->fillImage) (gc, dim, width, height, 1, format, type,
                                  pixels, gc->pc + 56, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = opcode;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&level), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&internalformat), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&border), 4);
            (void) memcpy((void *) (pc + 52), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 56), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format,
                                type, pixels, pc + 60, pc + 8);
        }
    }
}

#define X_GLrop_TexImage1D 109
void
__indirect_glTexImage1D(GLenum target, GLint level, GLint internalformat,
                        GLsizei width, GLint border, GLenum format,
                        GLenum type, const GLvoid * pixels)
{
    __glx_TexImage_1D2D(X_GLrop_TexImage1D, 1, target, level, internalformat,
                        width, 1, border, format, type, pixels);
}

#define X_GLrop_TexImage2D 110
void
__indirect_glTexImage2D(GLenum target, GLint level, GLint internalformat,
                        GLsizei width, GLsizei height, GLint border,
                        GLenum format, GLenum type, const GLvoid * pixels)
{
    __glx_TexImage_1D2D(X_GLrop_TexImage2D, 2, target, level, internalformat,
                        width, height, border, format, type, pixels);
}

#define X_GLrop_TexEnvf 111
void
__indirect_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_TexEnvf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexEnvfv 112
void
__indirect_glTexEnvfv(GLenum target, GLenum pname, const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glTexEnvfv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_TexEnvfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexEnvi 113
void
__indirect_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_TexEnvi, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexEnviv 114
void
__indirect_glTexEnviv(GLenum target, GLenum pname, const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glTexEnviv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_TexEnviv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexGend 115
void
__indirect_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_TexGend, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&param), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&pname), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexGendv 116
void
__indirect_glTexGendv(GLenum coord, GLenum pname, const GLdouble * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glTexGendv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 8));
    emit_header(gc->pc, X_GLrop_TexGendv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 8));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexGenf 117
void
__indirect_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_TexGenf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexGenfv 118
void
__indirect_glTexGenfv(GLenum coord, GLenum pname, const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glTexGenfv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_TexGenfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexGeni 119
void
__indirect_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_TexGeni, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_TexGeniv 120
void
__indirect_glTexGeniv(GLenum coord, GLenum pname, const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glTexGeniv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_TexGeniv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_InitNames 121
void
__indirect_glInitNames(void)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 4;
    emit_header(gc->pc, X_GLrop_InitNames, cmdlen);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LoadName 122
void
__indirect_glLoadName(GLuint name)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_LoadName, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&name), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PassThrough 123
void
__indirect_glPassThrough(GLfloat token)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_PassThrough, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&token), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PopName 124
void
__indirect_glPopName(void)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 4;
    emit_header(gc->pc, X_GLrop_PopName, cmdlen);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PushName 125
void
__indirect_glPushName(GLuint name)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_PushName, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&name), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_DrawBuffer 126
void
__indirect_glDrawBuffer(GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_DrawBuffer, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Clear 127
void
__indirect_glClear(GLbitfield mask)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Clear, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mask), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ClearAccum 128
void
__indirect_glClearAccum(GLfloat red, GLfloat green, GLfloat blue,
                        GLfloat alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_ClearAccum, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ClearIndex 129
void
__indirect_glClearIndex(GLfloat c)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ClearIndex, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ClearColor 130
void
__indirect_glClearColor(GLclampf red, GLclampf green, GLclampf blue,
                        GLclampf alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_ClearColor, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ClearStencil 131
void
__indirect_glClearStencil(GLint s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ClearStencil, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ClearDepth 132
void
__indirect_glClearDepth(GLclampd depth)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_ClearDepth, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&depth), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_StencilMask 133
void
__indirect_glStencilMask(GLuint mask)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_StencilMask, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mask), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ColorMask 134
void
__indirect_glColorMask(GLboolean red, GLboolean green, GLboolean blue,
                       GLboolean alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ColorMask, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    (void) memcpy((void *) (gc->pc + 7), (void *) (&alpha), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_DepthMask 135
void
__indirect_glDepthMask(GLboolean flag)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_DepthMask, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&flag), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_IndexMask 136
void
__indirect_glIndexMask(GLuint mask)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_IndexMask, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mask), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Accum 137
void
__indirect_glAccum(GLenum op, GLfloat value)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_Accum, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&op), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&value), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PopAttrib 141
void
__indirect_glPopAttrib(void)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 4;
    emit_header(gc->pc, X_GLrop_PopAttrib, cmdlen);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PushAttrib 142
void
__indirect_glPushAttrib(GLbitfield mask)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_PushAttrib, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mask), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MapGrid1d 147
void
__indirect_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_MapGrid1d, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&u2), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&un), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MapGrid1f 148
void
__indirect_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MapGrid1f, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&un), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&u1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&u2), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MapGrid2d 149
void
__indirect_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn,
                       GLdouble v1, GLdouble v2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44;
    emit_header(gc->pc, X_GLrop_MapGrid2d, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&u2), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&v1), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&v2), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&un), 4);
    (void) memcpy((void *) (gc->pc + 40), (void *) (&vn), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MapGrid2f 150
void
__indirect_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1,
                       GLfloat v2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_MapGrid2f, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&un), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&u1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&u2), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&vn), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&v1), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&v2), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EvalCoord1dv 151
void
__indirect_glEvalCoord1d(GLdouble u)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_EvalCoord1dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EvalCoord1dv 151
void
__indirect_glEvalCoord1dv(const GLdouble * u)
{
    generic_8_byte(X_GLrop_EvalCoord1dv, u);
}

#define X_GLrop_EvalCoord1fv 152
void
__indirect_glEvalCoord1f(GLfloat u)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_EvalCoord1fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EvalCoord1fv 152
void
__indirect_glEvalCoord1fv(const GLfloat * u)
{
    generic_4_byte(X_GLrop_EvalCoord1fv, u);
}

#define X_GLrop_EvalCoord2dv 153
void
__indirect_glEvalCoord2d(GLdouble u, GLdouble v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_EvalCoord2dv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EvalCoord2dv 153
void
__indirect_glEvalCoord2dv(const GLdouble * u)
{
    generic_16_byte(X_GLrop_EvalCoord2dv, u);
}

#define X_GLrop_EvalCoord2fv 154
void
__indirect_glEvalCoord2f(GLfloat u, GLfloat v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_EvalCoord2fv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EvalCoord2fv 154
void
__indirect_glEvalCoord2fv(const GLfloat * u)
{
    generic_8_byte(X_GLrop_EvalCoord2fv, u);
}

#define X_GLrop_EvalMesh1 155
void
__indirect_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_EvalMesh1, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&i1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&i2), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EvalPoint1 156
void
__indirect_glEvalPoint1(GLint i)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_EvalPoint1, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&i), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EvalMesh2 157
void
__indirect_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_EvalMesh2, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&i1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&i2), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&j1), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&j2), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_EvalPoint2 158
void
__indirect_glEvalPoint2(GLint i, GLint j)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_EvalPoint2, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&i), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&j), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_AlphaFunc 159
void
__indirect_glAlphaFunc(GLenum func, GLclampf ref)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_AlphaFunc, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&func), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&ref), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_BlendFunc 160
void
__indirect_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_BlendFunc, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&sfactor), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&dfactor), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LogicOp 161
void
__indirect_glLogicOp(GLenum opcode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_LogicOp, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&opcode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_StencilFunc 162
void
__indirect_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_StencilFunc, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&func), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&ref), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&mask), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_StencilOp 163
void
__indirect_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_StencilOp, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&fail), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&zfail), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&zpass), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_DepthFunc 164
void
__indirect_glDepthFunc(GLenum func)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_DepthFunc, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&func), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PixelZoom 165
void
__indirect_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_PixelZoom, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&xfactor), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&yfactor), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PixelTransferf 166
void
__indirect_glPixelTransferf(GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_PixelTransferf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PixelTransferi 167
void
__indirect_glPixelTransferi(GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_PixelTransferi, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PixelMapfv 168
void
__indirect_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((mapsize * 4));
    if (mapsize < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((mapsize >= 0) && (gc->currentDpy != NULL), 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_PixelMapfv, cmdlen);
            (void) memcpy((void *) (gc->pc + 4), (void *) (&map), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&mapsize), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (values),
                          (mapsize * 4));
            gc->pc += cmdlen;
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_PixelMapfv;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&map), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&mapsize), 4);
            __glXSendLargeCommand(gc, pc, 16, values, (mapsize * 4));
        }
    }
}

#define X_GLrop_PixelMapuiv 169
void
__indirect_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((mapsize * 4));
    if (mapsize < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((mapsize >= 0) && (gc->currentDpy != NULL), 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_PixelMapuiv, cmdlen);
            (void) memcpy((void *) (gc->pc + 4), (void *) (&map), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&mapsize), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (values),
                          (mapsize * 4));
            gc->pc += cmdlen;
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_PixelMapuiv;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&map), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&mapsize), 4);
            __glXSendLargeCommand(gc, pc, 16, values, (mapsize * 4));
        }
    }
}

#define X_GLrop_PixelMapusv 170
void
__indirect_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((mapsize * 2));
    if (mapsize < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((mapsize >= 0) && (gc->currentDpy != NULL), 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_PixelMapusv, cmdlen);
            (void) memcpy((void *) (gc->pc + 4), (void *) (&map), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&mapsize), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (values),
                          (mapsize * 2));
            gc->pc += cmdlen;
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_PixelMapusv;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&map), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&mapsize), 4);
            __glXSendLargeCommand(gc, pc, 16, values, (mapsize * 2));
        }
    }
}

#define X_GLrop_ReadBuffer 171
void
__indirect_glReadBuffer(GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ReadBuffer, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CopyPixels 172
void
__indirect_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                        GLenum type)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_CopyPixels, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&height), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&type), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLsop_ReadPixels 111
void
__indirect_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                        GLenum format, GLenum type, GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 28;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_read_pixels_reply_t *reply =
            xcb_glx_read_pixels_reply(c,
                                      xcb_glx_read_pixels(c,
                                                          gc->
                                                          currentContextTag,
                                                          x, y, width, height,
                                                          format, type,
                                                          state->storePack.
                                                          swapEndian, 0),
                                      NULL);
        (void) memcpy(pixels, xcb_glx_read_pixels_data(reply),
                      xcb_glx_read_pixels_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_ReadPixels, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&x), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&y), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&width), 4);
        (void) memcpy((void *) (pc + 12), (void *) (&height), 4);
        (void) memcpy((void *) (pc + 16), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 20), (void *) (&type), 4);
        *(int32_t *) (pc + 24) = 0;
        *(int8_t *) (pc + 24) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 2, width, height, 1, format, type,
                            pixels, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLrop_DrawPixels 173
void
__indirect_glDrawPixels(GLsizei width, GLsizei height, GLenum format,
                        GLenum type, const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (pixels != NULL) ? __glImageSize(width, height, 1, format, type,
                                         0) : 0;
    const GLuint cmdlen = 40 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_DrawPixels, cmdlen);
            (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&type), 4);
            if (compsize > 0) {
                (*gc->fillImage) (gc, 2, width, height, 1, format, type,
                                  pixels, gc->pc + 40, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_DrawPixels;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, 2, width, height, 1, format,
                                type, pixels, pc + 44, pc + 8);
        }
    }
}

#define X_GLsop_GetClipPlane 113
void
__indirect_glGetClipPlane(GLenum plane, GLdouble * equation)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_clip_plane_reply_t *reply =
            xcb_glx_get_clip_plane_reply(c,
                                         xcb_glx_get_clip_plane(c,
                                                                gc->
                                                                currentContextTag,
                                                                plane), NULL);
        (void) memcpy(equation, xcb_glx_get_clip_plane_data(reply),
                      xcb_glx_get_clip_plane_data_length(reply) *
                      sizeof(GLdouble));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetClipPlane, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&plane), 4);
        (void) __glXReadReply(dpy, 8, equation, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetLightfv 118
void
__indirect_glGetLightfv(GLenum light, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_lightfv_reply_t *reply =
            xcb_glx_get_lightfv_reply(c,
                                      xcb_glx_get_lightfv(c,
                                                          gc->
                                                          currentContextTag,
                                                          light, pname),
                                      NULL);
        if (xcb_glx_get_lightfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_lightfv_data(reply),
                          xcb_glx_get_lightfv_data_length(reply) *
                          sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetLightfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&light), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetLightiv 119
void
__indirect_glGetLightiv(GLenum light, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_lightiv_reply_t *reply =
            xcb_glx_get_lightiv_reply(c,
                                      xcb_glx_get_lightiv(c,
                                                          gc->
                                                          currentContextTag,
                                                          light, pname),
                                      NULL);
        if (xcb_glx_get_lightiv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_lightiv_data(reply),
                          xcb_glx_get_lightiv_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetLightiv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&light), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetMapdv 120
void
__indirect_glGetMapdv(GLenum target, GLenum query, GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_mapdv_reply_t *reply =
            xcb_glx_get_mapdv_reply(c,
                                    xcb_glx_get_mapdv(c,
                                                      gc->currentContextTag,
                                                      target, query), NULL);
        if (xcb_glx_get_mapdv_data_length(reply) == 0)
            (void) memcpy(v, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(v, xcb_glx_get_mapdv_data(reply),
                          xcb_glx_get_mapdv_data_length(reply) *
                          sizeof(GLdouble));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMapdv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&query), 4);
        (void) __glXReadReply(dpy, 8, v, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetMapfv 121
void
__indirect_glGetMapfv(GLenum target, GLenum query, GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_mapfv_reply_t *reply =
            xcb_glx_get_mapfv_reply(c,
                                    xcb_glx_get_mapfv(c,
                                                      gc->currentContextTag,
                                                      target, query), NULL);
        if (xcb_glx_get_mapfv_data_length(reply) == 0)
            (void) memcpy(v, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(v, xcb_glx_get_mapfv_data(reply),
                          xcb_glx_get_mapfv_data_length(reply) *
                          sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMapfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&query), 4);
        (void) __glXReadReply(dpy, 4, v, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetMapiv 122
void
__indirect_glGetMapiv(GLenum target, GLenum query, GLint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_mapiv_reply_t *reply =
            xcb_glx_get_mapiv_reply(c,
                                    xcb_glx_get_mapiv(c,
                                                      gc->currentContextTag,
                                                      target, query), NULL);
        if (xcb_glx_get_mapiv_data_length(reply) == 0)
            (void) memcpy(v, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(v, xcb_glx_get_mapiv_data(reply),
                          xcb_glx_get_mapiv_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMapiv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&query), 4);
        (void) __glXReadReply(dpy, 4, v, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetMaterialfv 123
void
__indirect_glGetMaterialfv(GLenum face, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_materialfv_reply_t *reply =
            xcb_glx_get_materialfv_reply(c,
                                         xcb_glx_get_materialfv(c,
                                                                gc->
                                                                currentContextTag,
                                                                face, pname),
                                         NULL);
        if (xcb_glx_get_materialfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_materialfv_data(reply),
                          xcb_glx_get_materialfv_data_length(reply) *
                          sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMaterialfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&face), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetMaterialiv 124
void
__indirect_glGetMaterialiv(GLenum face, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_materialiv_reply_t *reply =
            xcb_glx_get_materialiv_reply(c,
                                         xcb_glx_get_materialiv(c,
                                                                gc->
                                                                currentContextTag,
                                                                face, pname),
                                         NULL);
        if (xcb_glx_get_materialiv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_materialiv_data(reply),
                          xcb_glx_get_materialiv_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMaterialiv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&face), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetPixelMapfv 125
void
__indirect_glGetPixelMapfv(GLenum map, GLfloat * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_pixel_mapfv_reply_t *reply =
            xcb_glx_get_pixel_mapfv_reply(c,
                                          xcb_glx_get_pixel_mapfv(c,
                                                                  gc->
                                                                  currentContextTag,
                                                                  map), NULL);
        if (xcb_glx_get_pixel_mapfv_data_length(reply) == 0)
            (void) memcpy(values, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(values, xcb_glx_get_pixel_mapfv_data(reply),
                          xcb_glx_get_pixel_mapfv_data_length(reply) *
                          sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&map), 4);
        (void) __glXReadReply(dpy, 4, values, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetPixelMapuiv 126
void
__indirect_glGetPixelMapuiv(GLenum map, GLuint * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_pixel_mapuiv_reply_t *reply =
            xcb_glx_get_pixel_mapuiv_reply(c,
                                           xcb_glx_get_pixel_mapuiv(c,
                                                                    gc->
                                                                    currentContextTag,
                                                                    map),
                                           NULL);
        if (xcb_glx_get_pixel_mapuiv_data_length(reply) == 0)
            (void) memcpy(values, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(values, xcb_glx_get_pixel_mapuiv_data(reply),
                          xcb_glx_get_pixel_mapuiv_data_length(reply) *
                          sizeof(GLuint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapuiv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&map), 4);
        (void) __glXReadReply(dpy, 4, values, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetPixelMapusv 127
void
__indirect_glGetPixelMapusv(GLenum map, GLushort * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_pixel_mapusv_reply_t *reply =
            xcb_glx_get_pixel_mapusv_reply(c,
                                           xcb_glx_get_pixel_mapusv(c,
                                                                    gc->
                                                                    currentContextTag,
                                                                    map),
                                           NULL);
        if (xcb_glx_get_pixel_mapusv_data_length(reply) == 0)
            (void) memcpy(values, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(values, xcb_glx_get_pixel_mapusv_data(reply),
                          xcb_glx_get_pixel_mapusv_data_length(reply) *
                          sizeof(GLushort));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapusv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&map), 4);
        (void) __glXReadReply(dpy, 2, values, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetPolygonStipple 128
void
__indirect_glGetPolygonStipple(GLubyte *mask)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_polygon_stipple_reply_t *reply =
            xcb_glx_get_polygon_stipple_reply(c,
                                              xcb_glx_get_polygon_stipple(c,
                                                                          gc->
                                                                          currentContextTag,
                                                                          0),
                                              NULL);
        (void) memcpy(mask, xcb_glx_get_polygon_stipple_data(reply),
                      xcb_glx_get_polygon_stipple_data_length(reply) *
                      sizeof(GLubyte));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetPolygonStipple, cmdlen);
        *(int32_t *) (pc + 0) = 0;
        __glXReadPixelReply(dpy, gc, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                            mask, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexEnvfv 130
void
__indirect_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_envfv_reply_t *reply =
            xcb_glx_get_tex_envfv_reply(c,
                                        xcb_glx_get_tex_envfv(c,
                                                              gc->
                                                              currentContextTag,
                                                              target, pname),
                                        NULL);
        if (xcb_glx_get_tex_envfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_tex_envfv_data(reply),
                          xcb_glx_get_tex_envfv_data_length(reply) *
                          sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexEnvfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexEnviv 131
void
__indirect_glGetTexEnviv(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_enviv_reply_t *reply =
            xcb_glx_get_tex_enviv_reply(c,
                                        xcb_glx_get_tex_enviv(c,
                                                              gc->
                                                              currentContextTag,
                                                              target, pname),
                                        NULL);
        if (xcb_glx_get_tex_enviv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_tex_enviv_data(reply),
                          xcb_glx_get_tex_enviv_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexEnviv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexGendv 132
void
__indirect_glGetTexGendv(GLenum coord, GLenum pname, GLdouble * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_gendv_reply_t *reply =
            xcb_glx_get_tex_gendv_reply(c,
                                        xcb_glx_get_tex_gendv(c,
                                                              gc->
                                                              currentContextTag,
                                                              coord, pname),
                                        NULL);
        if (xcb_glx_get_tex_gendv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_tex_gendv_data(reply),
                          xcb_glx_get_tex_gendv_data_length(reply) *
                          sizeof(GLdouble));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexGendv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&coord), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 8, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexGenfv 133
void
__indirect_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_genfv_reply_t *reply =
            xcb_glx_get_tex_genfv_reply(c,
                                        xcb_glx_get_tex_genfv(c,
                                                              gc->
                                                              currentContextTag,
                                                              coord, pname),
                                        NULL);
        if (xcb_glx_get_tex_genfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_tex_genfv_data(reply),
                          xcb_glx_get_tex_genfv_data_length(reply) *
                          sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexGenfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&coord), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexGeniv 134
void
__indirect_glGetTexGeniv(GLenum coord, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_geniv_reply_t *reply =
            xcb_glx_get_tex_geniv_reply(c,
                                        xcb_glx_get_tex_geniv(c,
                                                              gc->
                                                              currentContextTag,
                                                              coord, pname),
                                        NULL);
        if (xcb_glx_get_tex_geniv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_tex_geniv_data(reply),
                          xcb_glx_get_tex_geniv_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexGeniv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&coord), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexImage 135
void
__indirect_glGetTexImage(GLenum target, GLint level, GLenum format,
                         GLenum type, GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 20;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_image_reply_t *reply =
            xcb_glx_get_tex_image_reply(c,
                                        xcb_glx_get_tex_image(c,
                                                              gc->
                                                              currentContextTag,
                                                              target, level,
                                                              format, type,
                                                              state->
                                                              storePack.
                                                              swapEndian),
                                        NULL);
        (void) memcpy(pixels, xcb_glx_get_tex_image_data(reply),
                      xcb_glx_get_tex_image_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexImage, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&level), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 12), (void *) (&type), 4);
        *(int32_t *) (pc + 16) = 0;
        *(int8_t *) (pc + 16) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 3, 0, 0, 0, format, type, pixels,
                            GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexParameterfv 136
void
__indirect_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_parameterfv_reply_t *reply =
            xcb_glx_get_tex_parameterfv_reply(c,
                                              xcb_glx_get_tex_parameterfv(c,
                                                                          gc->
                                                                          currentContextTag,
                                                                          target,
                                                                          pname),
                                              NULL);
        if (xcb_glx_get_tex_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_tex_parameterfv_data(reply),
                          xcb_glx_get_tex_parameterfv_data_length(reply) *
                          sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexParameterfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexParameteriv 137
void
__indirect_glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_parameteriv_reply_t *reply =
            xcb_glx_get_tex_parameteriv_reply(c,
                                              xcb_glx_get_tex_parameteriv(c,
                                                                          gc->
                                                                          currentContextTag,
                                                                          target,
                                                                          pname),
                                              NULL);
        if (xcb_glx_get_tex_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_tex_parameteriv_data(reply),
                          xcb_glx_get_tex_parameteriv_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexParameteriv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexLevelParameterfv 138
void
__indirect_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname,
                                    GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 12;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_level_parameterfv_reply_t *reply =
            xcb_glx_get_tex_level_parameterfv_reply(c,
                                                    xcb_glx_get_tex_level_parameterfv
                                                    (c, gc->currentContextTag,
                                                     target, level, pname),
                                                    NULL);
        if (xcb_glx_get_tex_level_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params,
                          xcb_glx_get_tex_level_parameterfv_data(reply),
                          xcb_glx_get_tex_level_parameterfv_data_length(reply)
                          * sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexLevelParameterfv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&level), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetTexLevelParameteriv 139
void
__indirect_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname,
                                    GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 12;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_tex_level_parameteriv_reply_t *reply =
            xcb_glx_get_tex_level_parameteriv_reply(c,
                                                    xcb_glx_get_tex_level_parameteriv
                                                    (c, gc->currentContextTag,
                                                     target, level, pname),
                                                    NULL);
        if (xcb_glx_get_tex_level_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params,
                          xcb_glx_get_tex_level_parameteriv_data(reply),
                          xcb_glx_get_tex_level_parameteriv_data_length(reply)
                          * sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexLevelParameteriv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&level), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_IsList 141
GLboolean
__indirect_glIsList(GLuint list)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_is_list_reply_t *reply =
            xcb_glx_is_list_reply(c,
                                  xcb_glx_is_list(c, gc->currentContextTag,
                                                  list), NULL);
        retval = reply->ret_val;
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_IsList, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&list), 4);
        retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return retval;
}

#define X_GLrop_DepthRange 174
void
__indirect_glDepthRange(GLclampd zNear, GLclampd zFar)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_DepthRange, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&zNear), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&zFar), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Frustum 175
void
__indirect_glFrustum(GLdouble left, GLdouble right, GLdouble bottom,
                     GLdouble top, GLdouble zNear, GLdouble zFar)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 52;
    emit_header(gc->pc, X_GLrop_Frustum, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&left), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&right), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&bottom), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&top), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&zNear), 8);
    (void) memcpy((void *) (gc->pc + 44), (void *) (&zFar), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LoadIdentity 176
void
__indirect_glLoadIdentity(void)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 4;
    emit_header(gc->pc, X_GLrop_LoadIdentity, cmdlen);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LoadMatrixf 177
void
__indirect_glLoadMatrixf(const GLfloat * m)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 68;
    emit_header(gc->pc, X_GLrop_LoadMatrixf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (m), 64);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_LoadMatrixd 178
void
__indirect_glLoadMatrixd(const GLdouble * m)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 132;
    emit_header(gc->pc, X_GLrop_LoadMatrixd, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (m), 128);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MatrixMode 179
void
__indirect_glMatrixMode(GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_MatrixMode, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultMatrixf 180
void
__indirect_glMultMatrixf(const GLfloat * m)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 68;
    emit_header(gc->pc, X_GLrop_MultMatrixf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (m), 64);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultMatrixd 181
void
__indirect_glMultMatrixd(const GLdouble * m)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 132;
    emit_header(gc->pc, X_GLrop_MultMatrixd, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (m), 128);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Ortho 182
void
__indirect_glOrtho(GLdouble left, GLdouble right, GLdouble bottom,
                   GLdouble top, GLdouble zNear, GLdouble zFar)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 52;
    emit_header(gc->pc, X_GLrop_Ortho, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&left), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&right), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&bottom), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&top), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&zNear), 8);
    (void) memcpy((void *) (gc->pc + 44), (void *) (&zFar), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PopMatrix 183
void
__indirect_glPopMatrix(void)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 4;
    emit_header(gc->pc, X_GLrop_PopMatrix, cmdlen);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PushMatrix 184
void
__indirect_glPushMatrix(void)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 4;
    emit_header(gc->pc, X_GLrop_PushMatrix, cmdlen);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rotated 185
void
__indirect_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_Rotated, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&angle), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&z), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Rotatef 186
void
__indirect_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Rotatef, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&angle), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Scaled 187
void
__indirect_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_Scaled, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Scalef 188
void
__indirect_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Scalef, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Translated 189
void
__indirect_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_Translated, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Translatef 190
void
__indirect_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Translatef, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Viewport 191
void
__indirect_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Viewport, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&height), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_BindTexture 4117
void
__indirect_glBindTexture(GLenum target, GLuint texture)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_BindTexture, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&texture), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Indexubv 194
void
__indirect_glIndexub(GLubyte c)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Indexubv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Indexubv 194
void
__indirect_glIndexubv(const GLubyte *c)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_Indexubv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (c), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PolygonOffset 192
void
__indirect_glPolygonOffset(GLfloat factor, GLfloat units)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_PolygonOffset, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&factor), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&units), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CopyTexImage1D 4119
void
__indirect_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat,
                            GLint x, GLint y, GLsizei width, GLint border)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 32;
    emit_header(gc->pc, X_GLrop_CopyTexImage1D, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&border), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CopyTexImage2D 4120
void
__indirect_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat,
                            GLint x, GLint y, GLsizei width, GLsizei height,
                            GLint border)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_CopyTexImage2D, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&height), 4);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&border), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CopyTexSubImage1D 4121
void
__indirect_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                               GLint x, GLint y, GLsizei width)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_CopyTexSubImage1D, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&xoffset), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CopyTexSubImage2D 4122
void
__indirect_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                               GLint yoffset, GLint x, GLint y, GLsizei width,
                               GLsizei height)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 36;
    emit_header(gc->pc, X_GLrop_CopyTexSubImage2D, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&xoffset), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&yoffset), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&height), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLsop_DeleteTextures 144
void
__indirect_glDeleteTextures(GLsizei n, const GLuint * textures)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
#endif
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_delete_textures(c, gc->currentContextTag, n, textures);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_DeleteTextures, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (textures), (n * 4));
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_DeleteTexturesEXT 12
void
glDeleteTexturesEXT(GLsizei n, const GLuint * textures)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING
    if (gc->driContext) {
        CALL_DeleteTextures(GET_DISPATCH(), (n, textures));
    } else {
#else
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
        if (n < 0) {
            __glXSetError(gc, GL_INVALID_VALUE);
            return;
        }
        if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivate,
                                        X_GLvop_DeleteTexturesEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
            (void) memcpy((void *) (pc + 4), (void *) (textures), (n * 4));
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GenTextures 145
void
__indirect_glGenTextures(GLsizei n, GLuint * textures)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_gen_textures_reply_t *reply =
            xcb_glx_gen_textures_reply(c,
                                       xcb_glx_gen_textures(c,
                                                            gc->
                                                            currentContextTag,
                                                            n), NULL);
        (void) memcpy(textures, xcb_glx_gen_textures_data(reply),
                      xcb_glx_gen_textures_data_length(reply) *
                      sizeof(GLuint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GenTextures, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) __glXReadReply(dpy, 4, textures, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GenTexturesEXT 13
void
glGenTexturesEXT(GLsizei n, GLuint * textures)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GenTextures(GET_DISPATCH(), (n, textures));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 4;
        if (n < 0) {
            __glXSetError(gc, GL_INVALID_VALUE);
            return;
        }
        if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GenTexturesEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
            (void) __glXReadReply(dpy, 4, textures, GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_IsTexture 146
GLboolean
__indirect_glIsTexture(GLuint texture)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_is_texture_reply_t *reply =
            xcb_glx_is_texture_reply(c,
                                     xcb_glx_is_texture(c,
                                                        gc->currentContextTag,
                                                        texture), NULL);
        retval = reply->ret_val;
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_IsTexture, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&texture), 4);
        retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return retval;
}

#define X_GLvop_IsTextureEXT 14
GLboolean
glIsTextureEXT(GLuint texture)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        return CALL_IsTexture(GET_DISPATCH(), (texture));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        GLboolean retval = (GLboolean) 0;
        const GLuint cmdlen = 4;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_IsTextureEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&texture), 4);
            retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return retval;
    }
}

#define X_GLrop_PrioritizeTextures 4118
void
__indirect_glPrioritizeTextures(GLsizei n, const GLuint * textures,
                                const GLclampf * priorities)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8 + __GLX_PAD((n * 4)) + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_PrioritizeTextures, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (textures), (n * 4));
        (void) memcpy((void *) (gc->pc + 8 + (n * 4)), (void *) (priorities),
                      (n * 4));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

static void
__glx_TexSubImage_1D2D(unsigned opcode, unsigned dim, GLenum target,
                       GLint level, GLint xoffset, GLint yoffset,
                       GLsizei width, GLsizei height, GLenum format,
                       GLenum type, const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (pixels != NULL) ? __glImageSize(width, height, 1, format, type,
                                         target) : 0;
    const GLuint cmdlen = 60 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, opcode, cmdlen);
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&level), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&xoffset), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&yoffset), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 48), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 52), (void *) (&type), 4);
            (void) memset((void *) (gc->pc + 56), 0, 4);
            if (compsize > 0) {
                (*gc->fillImage) (gc, dim, width, height, 1, format, type,
                                  pixels, gc->pc + 60, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = opcode;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&level), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&xoffset), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&yoffset), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 52), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 56), (void *) (&type), 4);
            (void) memset((void *) (pc + 60), 0, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format,
                                type, pixels, pc + 64, pc + 8);
        }
    }
}

#define X_GLrop_TexSubImage1D 4099
void
__indirect_glTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                           GLsizei width, GLenum format, GLenum type,
                           const GLvoid * pixels)
{
    __glx_TexSubImage_1D2D(X_GLrop_TexSubImage1D, 1, target, level, xoffset,
                           1, width, 1, format, type, pixels);
}

#define X_GLrop_TexSubImage2D 4100
void
__indirect_glTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                           GLint yoffset, GLsizei width, GLsizei height,
                           GLenum format, GLenum type, const GLvoid * pixels)
{
    __glx_TexSubImage_1D2D(X_GLrop_TexSubImage2D, 2, target, level, xoffset,
                           yoffset, width, height, format, type, pixels);
}

#define X_GLrop_BlendColor 4096
void
__indirect_glBlendColor(GLclampf red, GLclampf green, GLclampf blue,
                        GLclampf alpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_BlendColor, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_BlendEquation 4097
void
__indirect_glBlendEquation(GLenum mode)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_BlendEquation, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ColorTable 2053
void
__indirect_glColorTable(GLenum target, GLenum internalformat, GLsizei width,
                        GLenum format, GLenum type, const GLvoid * table)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (table != NULL) ? __glImageSize(width, 1, 1, format, type,
                                        target) : 0;
    const GLuint cmdlen = 44 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_ColorTable, cmdlen);
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&internalformat),
                          4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&type), 4);
            if (compsize > 0) {
                (*gc->fillImage) (gc, 1, width, 1, 1, format, type, table,
                                  gc->pc + 44, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_1D,
                              default_pixel_store_1D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_ColorTable;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&internalformat), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, 1, width, 1, 1, format, type,
                                table, pc + 48, pc + 8);
        }
    }
}

#define X_GLrop_ColorTableParameterfv 2054
void
__indirect_glColorTableParameterfv(GLenum target, GLenum pname,
                                   const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glColorTableParameterfv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_ColorTableParameterfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ColorTableParameteriv 2055
void
__indirect_glColorTableParameteriv(GLenum target, GLenum pname,
                                   const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glColorTableParameteriv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_ColorTableParameteriv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CopyColorTable 2056
void
__indirect_glCopyColorTable(GLenum target, GLenum internalformat, GLint x,
                            GLint y, GLsizei width)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_CopyColorTable, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&width), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLsop_GetColorTable 147
void
__indirect_glGetColorTable(GLenum target, GLenum format, GLenum type,
                           GLvoid * table)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 16;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_color_table_reply_t *reply =
            xcb_glx_get_color_table_reply(c,
                                          xcb_glx_get_color_table(c,
                                                                  gc->
                                                                  currentContextTag,
                                                                  target,
                                                                  format,
                                                                  type,
                                                                  state->
                                                                  storePack.
                                                                  swapEndian),
                                          NULL);
        (void) memcpy(table, xcb_glx_get_color_table_data(reply),
                      xcb_glx_get_color_table_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetColorTable, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
        *(int32_t *) (pc + 12) = 0;
        *(int8_t *) (pc + 12) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, table,
                            GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetColorTableSGI 4098
void
glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid * table)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetColorTable(GET_DISPATCH(), (target, format, type, table));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        const __GLXattribute *const state = gc->client_state_private;
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 16;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetColorTableSGI, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
            *(int32_t *) (pc + 12) = 0;
            *(int8_t *) (pc + 12) = state->storePack.swapEndian;
            __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, table,
                                GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetColorTableParameterfv 148
void
__indirect_glGetColorTableParameterfv(GLenum target, GLenum pname,
                                      GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_color_table_parameterfv_reply_t *reply =
            xcb_glx_get_color_table_parameterfv_reply(c,
                                                      xcb_glx_get_color_table_parameterfv
                                                      (c,
                                                       gc->currentContextTag,
                                                       target, pname), NULL);
        if (xcb_glx_get_color_table_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params,
                          xcb_glx_get_color_table_parameterfv_data(reply),
                          xcb_glx_get_color_table_parameterfv_data_length
                          (reply) * sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetColorTableParameterfv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetColorTableParameterfvSGI 4099
void
glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetColorTableParameterfv(GET_DISPATCH(),
                                      (target, pname, params));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetColorTableParameterfvSGI,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetColorTableParameteriv 149
void
__indirect_glGetColorTableParameteriv(GLenum target, GLenum pname,
                                      GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_color_table_parameteriv_reply_t *reply =
            xcb_glx_get_color_table_parameteriv_reply(c,
                                                      xcb_glx_get_color_table_parameteriv
                                                      (c,
                                                       gc->currentContextTag,
                                                       target, pname), NULL);
        if (xcb_glx_get_color_table_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params,
                          xcb_glx_get_color_table_parameteriv_data(reply),
                          xcb_glx_get_color_table_parameteriv_data_length
                          (reply) * sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetColorTableParameteriv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetColorTableParameterivSGI 4100
void
glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetColorTableParameteriv(GET_DISPATCH(),
                                      (target, pname, params));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetColorTableParameterivSGI,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLrop_ColorSubTable 195
void
__indirect_glColorSubTable(GLenum target, GLsizei start, GLsizei count,
                           GLenum format, GLenum type, const GLvoid * data)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (data != NULL) ? __glImageSize(count, 1, 1, format, type, target) : 0;
    const GLuint cmdlen = 44 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_ColorSubTable, cmdlen);
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&start), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&count), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&type), 4);
            if (compsize > 0) {
                (*gc->fillImage) (gc, 1, count, 1, 1, format, type, data,
                                  gc->pc + 44, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_1D,
                              default_pixel_store_1D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_ColorSubTable;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&start), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&count), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, 1, count, 1, 1, format, type,
                                data, pc + 48, pc + 8);
        }
    }
}

#define X_GLrop_CopyColorSubTable 196
void
__indirect_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y,
                               GLsizei width)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_CopyColorSubTable, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&start), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&width), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static void
__glx_ConvolutionFilter_1D2D(unsigned opcode, unsigned dim, GLenum target,
                             GLenum internalformat, GLsizei width,
                             GLsizei height, GLenum format, GLenum type,
                             const GLvoid * image)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (image != NULL) ? __glImageSize(width, height, 1, format, type,
                                        target) : 0;
    const GLuint cmdlen = 48 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, opcode, cmdlen);
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&internalformat),
                          4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&type), 4);
            if (compsize > 0) {
                (*gc->fillImage) (gc, dim, width, height, 1, format, type,
                                  image, gc->pc + 48, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = opcode;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&internalformat), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format,
                                type, image, pc + 52, pc + 8);
        }
    }
}

#define X_GLrop_ConvolutionFilter1D 4101
void
__indirect_glConvolutionFilter1D(GLenum target, GLenum internalformat,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid * image)
{
    __glx_ConvolutionFilter_1D2D(X_GLrop_ConvolutionFilter1D, 1, target,
                                 internalformat, width, 1, format, type,
                                 image);
}

#define X_GLrop_ConvolutionFilter2D 4102
void
__indirect_glConvolutionFilter2D(GLenum target, GLenum internalformat,
                                 GLsizei width, GLsizei height, GLenum format,
                                 GLenum type, const GLvoid * image)
{
    __glx_ConvolutionFilter_1D2D(X_GLrop_ConvolutionFilter2D, 2, target,
                                 internalformat, width, height, format, type,
                                 image);
}

#define X_GLrop_ConvolutionParameterf 4103
void
__indirect_glConvolutionParameterf(GLenum target, GLenum pname,
                                   GLfloat params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_ConvolutionParameterf, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&params), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ConvolutionParameterfv 4104
void
__indirect_glConvolutionParameterfv(GLenum target, GLenum pname,
                                    const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glConvolutionParameterfv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_ConvolutionParameterfv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ConvolutionParameteri 4105
void
__indirect_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_ConvolutionParameteri, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&params), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ConvolutionParameteriv 4106
void
__indirect_glConvolutionParameteriv(GLenum target, GLenum pname,
                                    const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glConvolutionParameteriv_size(pname);
    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_ConvolutionParameteriv, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CopyConvolutionFilter1D 4107
void
__indirect_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat,
                                     GLint x, GLint y, GLsizei width)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_CopyConvolutionFilter1D, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&width), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_CopyConvolutionFilter2D 4108
void
__indirect_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat,
                                     GLint x, GLint y, GLsizei width,
                                     GLsizei height)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_CopyConvolutionFilter2D, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&height), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLsop_GetConvolutionFilter 150
void
__indirect_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type,
                                  GLvoid * image)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 16;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_convolution_filter_reply_t *reply =
            xcb_glx_get_convolution_filter_reply(c,
                                                 xcb_glx_get_convolution_filter
                                                 (c, gc->currentContextTag,
                                                  target, format, type,
                                                  state->storePack.
                                                  swapEndian), NULL);
        (void) memcpy(image, xcb_glx_get_convolution_filter_data(reply),
                      xcb_glx_get_convolution_filter_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionFilter, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
        *(int32_t *) (pc + 12) = 0;
        *(int8_t *) (pc + 12) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 2, 0, 0, 0, format, type, image,
                            GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetConvolutionFilterEXT 1
void
gl_dispatch_stub_356(GLenum target, GLenum format, GLenum type,
                     GLvoid * image)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetConvolutionFilter(GET_DISPATCH(),
                                  (target, format, type, image));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        const __GLXattribute *const state = gc->client_state_private;
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 16;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetConvolutionFilterEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
            *(int32_t *) (pc + 12) = 0;
            *(int8_t *) (pc + 12) = state->storePack.swapEndian;
            __glXReadPixelReply(dpy, gc, 2, 0, 0, 0, format, type, image,
                                GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetConvolutionParameterfv 151
void
__indirect_glGetConvolutionParameterfv(GLenum target, GLenum pname,
                                       GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_convolution_parameterfv_reply_t *reply =
            xcb_glx_get_convolution_parameterfv_reply(c,
                                                      xcb_glx_get_convolution_parameterfv
                                                      (c,
                                                       gc->currentContextTag,
                                                       target, pname), NULL);
        if (xcb_glx_get_convolution_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params,
                          xcb_glx_get_convolution_parameterfv_data(reply),
                          xcb_glx_get_convolution_parameterfv_data_length
                          (reply) * sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionParameterfv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetConvolutionParameterfvEXT 2
void
gl_dispatch_stub_357(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetConvolutionParameterfv(GET_DISPATCH(),
                                       (target, pname, params));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetConvolutionParameterfvEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetConvolutionParameteriv 152
void
__indirect_glGetConvolutionParameteriv(GLenum target, GLenum pname,
                                       GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_convolution_parameteriv_reply_t *reply =
            xcb_glx_get_convolution_parameteriv_reply(c,
                                                      xcb_glx_get_convolution_parameteriv
                                                      (c,
                                                       gc->currentContextTag,
                                                       target, pname), NULL);
        if (xcb_glx_get_convolution_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params,
                          xcb_glx_get_convolution_parameteriv_data(reply),
                          xcb_glx_get_convolution_parameteriv_data_length
                          (reply) * sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionParameteriv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetConvolutionParameterivEXT 3
void
gl_dispatch_stub_358(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetConvolutionParameteriv(GET_DISPATCH(),
                                       (target, pname, params));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetConvolutionParameterivEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetHistogram 154
void
__indirect_glGetHistogram(GLenum target, GLboolean reset, GLenum format,
                          GLenum type, GLvoid * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 16;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_histogram_reply_t *reply =
            xcb_glx_get_histogram_reply(c,
                                        xcb_glx_get_histogram(c,
                                                              gc->
                                                              currentContextTag,
                                                              target, reset,
                                                              format, type,
                                                              state->
                                                              storePack.
                                                              swapEndian),
                                        NULL);
        (void) memcpy(values, xcb_glx_get_histogram_data(reply),
                      xcb_glx_get_histogram_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetHistogram, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
        *(int32_t *) (pc + 12) = 0;
        *(int8_t *) (pc + 12) = state->storePack.swapEndian;
        *(int8_t *) (pc + 13) = reset;
        __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, values,
                            GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetHistogramEXT 5
void
gl_dispatch_stub_361(GLenum target, GLboolean reset, GLenum format,
                     GLenum type, GLvoid * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetHistogram(GET_DISPATCH(),
                          (target, reset, format, type, values));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        const __GLXattribute *const state = gc->client_state_private;
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 16;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetHistogramEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
            *(int32_t *) (pc + 12) = 0;
            *(int8_t *) (pc + 12) = state->storePack.swapEndian;
            *(int8_t *) (pc + 13) = reset;
            __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, values,
                                GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetHistogramParameterfv 155
void
__indirect_glGetHistogramParameterfv(GLenum target, GLenum pname,
                                     GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_histogram_parameterfv_reply_t *reply =
            xcb_glx_get_histogram_parameterfv_reply(c,
                                                    xcb_glx_get_histogram_parameterfv
                                                    (c, gc->currentContextTag,
                                                     target, pname), NULL);
        if (xcb_glx_get_histogram_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params,
                          xcb_glx_get_histogram_parameterfv_data(reply),
                          xcb_glx_get_histogram_parameterfv_data_length(reply)
                          * sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetHistogramParameterfv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetHistogramParameterfvEXT 6
void
gl_dispatch_stub_362(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetHistogramParameterfv(GET_DISPATCH(), (target, pname, params));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetHistogramParameterfvEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetHistogramParameteriv 156
void
__indirect_glGetHistogramParameteriv(GLenum target, GLenum pname,
                                     GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_histogram_parameteriv_reply_t *reply =
            xcb_glx_get_histogram_parameteriv_reply(c,
                                                    xcb_glx_get_histogram_parameteriv
                                                    (c, gc->currentContextTag,
                                                     target, pname), NULL);
        if (xcb_glx_get_histogram_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params,
                          xcb_glx_get_histogram_parameteriv_data(reply),
                          xcb_glx_get_histogram_parameteriv_data_length(reply)
                          * sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetHistogramParameteriv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetHistogramParameterivEXT 7
void
gl_dispatch_stub_363(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetHistogramParameteriv(GET_DISPATCH(), (target, pname, params));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetHistogramParameterivEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetMinmax 157
void
__indirect_glGetMinmax(GLenum target, GLboolean reset, GLenum format,
                       GLenum type, GLvoid * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 16;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_minmax_reply_t *reply =
            xcb_glx_get_minmax_reply(c,
                                     xcb_glx_get_minmax(c,
                                                        gc->currentContextTag,
                                                        target, reset, format,
                                                        type,
                                                        state->storePack.
                                                        swapEndian), NULL);
        (void) memcpy(values, xcb_glx_get_minmax_data(reply),
                      xcb_glx_get_minmax_data_length(reply) * sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMinmax, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
        *(int32_t *) (pc + 12) = 0;
        *(int8_t *) (pc + 12) = state->storePack.swapEndian;
        *(int8_t *) (pc + 13) = reset;
        __glXReadPixelReply(dpy, gc, 1, 2, 1, 1, format, type, values,
                            GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetMinmaxEXT 8
void
gl_dispatch_stub_364(GLenum target, GLboolean reset, GLenum format,
                     GLenum type, GLvoid * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetMinmax(GET_DISPATCH(), (target, reset, format, type, values));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        const __GLXattribute *const state = gc->client_state_private;
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 16;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetMinmaxEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
            *(int32_t *) (pc + 12) = 0;
            *(int8_t *) (pc + 12) = state->storePack.swapEndian;
            *(int8_t *) (pc + 13) = reset;
            __glXReadPixelReply(dpy, gc, 1, 2, 1, 1, format, type, values,
                                GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetMinmaxParameterfv 158
void
__indirect_glGetMinmaxParameterfv(GLenum target, GLenum pname,
                                  GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_minmax_parameterfv_reply_t *reply =
            xcb_glx_get_minmax_parameterfv_reply(c,
                                                 xcb_glx_get_minmax_parameterfv
                                                 (c, gc->currentContextTag,
                                                  target, pname), NULL);
        if (xcb_glx_get_minmax_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_minmax_parameterfv_data(reply),
                          xcb_glx_get_minmax_parameterfv_data_length(reply) *
                          sizeof(GLfloat));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMinmaxParameterfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetMinmaxParameterfvEXT 9
void
gl_dispatch_stub_365(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetMinmaxParameterfv(GET_DISPATCH(), (target, pname, params));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetMinmaxParameterfvEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetMinmaxParameteriv 159
void
__indirect_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_minmax_parameteriv_reply_t *reply =
            xcb_glx_get_minmax_parameteriv_reply(c,
                                                 xcb_glx_get_minmax_parameteriv
                                                 (c, gc->currentContextTag,
                                                  target, pname), NULL);
        if (xcb_glx_get_minmax_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_minmax_parameteriv_data(reply),
                          xcb_glx_get_minmax_parameteriv_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMinmaxParameteriv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLvop_GetMinmaxParameterivEXT 10
void
gl_dispatch_stub_366(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING    
    if (gc->driContext) {
        CALL_GetMinmaxParameteriv(GET_DISPATCH(), (target, pname, params));
    } else {
#else 
    {
#endif
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetMinmaxParameterivEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLrop_Histogram 4110
void
__indirect_glHistogram(GLenum target, GLsizei width, GLenum internalformat,
                       GLboolean sink)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_Histogram, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&sink), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_Minmax 4111
void
__indirect_glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_Minmax, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&sink), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ResetHistogram 4112
void
__indirect_glResetHistogram(GLenum target)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ResetHistogram, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ResetMinmax 4113
void
__indirect_glResetMinmax(GLenum target)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ResetMinmax, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

static void
__glx_TexImage_3D4D(unsigned opcode, unsigned dim, GLenum target, GLint level,
                    GLint internalformat, GLsizei width, GLsizei height,
                    GLsizei depth, GLsizei extent, GLint border,
                    GLenum format, GLenum type, const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (pixels != NULL) ? __glImageSize(width, height, depth, format, type,
                                         target) : 0;
    const GLuint cmdlen = 84 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, opcode, cmdlen);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&level), 4);
            (void) memcpy((void *) (gc->pc + 48), (void *) (&internalformat),
                          4);
            (void) memcpy((void *) (gc->pc + 52), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 56), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 60), (void *) (&depth), 4);
            (void) memcpy((void *) (gc->pc + 64), (void *) (&extent), 4);
            (void) memcpy((void *) (gc->pc + 68), (void *) (&border), 4);
            (void) memcpy((void *) (gc->pc + 72), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 76), (void *) (&type), 4);
            (void) memcpy((void *) (gc->pc + 80),
                          (void *) ((pixels == NULL) ? one : zero), 4);
            if (compsize > 0) {
                (*gc->fillImage) (gc, dim, width, height, depth, format, type,
                                  pixels, gc->pc + 84, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_4D,
                              default_pixel_store_4D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = opcode;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&level), 4);
            (void) memcpy((void *) (pc + 52), (void *) (&internalformat), 4);
            (void) memcpy((void *) (pc + 56), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 60), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 64), (void *) (&depth), 4);
            (void) memcpy((void *) (pc + 68), (void *) (&extent), 4);
            (void) memcpy((void *) (pc + 72), (void *) (&border), 4);
            (void) memcpy((void *) (pc + 76), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 80), (void *) (&type), 4);
            (void) memcpy((void *) (pc + 84), zero, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, depth,
                                format, type, pixels, pc + 88, pc + 8);
        }
    }
}

#define X_GLrop_TexImage3D 4114
void
__indirect_glTexImage3D(GLenum target, GLint level, GLint internalformat,
                        GLsizei width, GLsizei height, GLsizei depth,
                        GLint border, GLenum format, GLenum type,
                        const GLvoid * pixels)
{
    __glx_TexImage_3D4D(X_GLrop_TexImage3D, 3, target, level, internalformat,
                        width, height, depth, 1, border, format, type,
                        pixels);
}

static void
__glx_TexSubImage_3D4D(unsigned opcode, unsigned dim, GLenum target,
                       GLint level, GLint xoffset, GLint yoffset,
                       GLint zoffset, GLint woffset, GLsizei width,
                       GLsizei height, GLsizei depth, GLsizei extent,
                       GLenum format, GLenum type, const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (pixels != NULL) ? __glImageSize(width, height, depth, format, type,
                                         target) : 0;
    const GLuint cmdlen = 92 + __GLX_PAD(compsize);
    if (__builtin_expect(gc->currentDpy != NULL, 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, opcode, cmdlen);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&level), 4);
            (void) memcpy((void *) (gc->pc + 48), (void *) (&xoffset), 4);
            (void) memcpy((void *) (gc->pc + 52), (void *) (&yoffset), 4);
            (void) memcpy((void *) (gc->pc + 56), (void *) (&zoffset), 4);
            (void) memcpy((void *) (gc->pc + 60), (void *) (&woffset), 4);
            (void) memcpy((void *) (gc->pc + 64), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 68), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 72), (void *) (&depth), 4);
            (void) memcpy((void *) (gc->pc + 76), (void *) (&extent), 4);
            (void) memcpy((void *) (gc->pc + 80), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 84), (void *) (&type), 4);
            (void) memset((void *) (gc->pc + 88), 0, 4);
            if (compsize > 0) {
                (*gc->fillImage) (gc, dim, width, height, depth, format, type,
                                  pixels, gc->pc + 92, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_4D,
                              default_pixel_store_4D_size);
            }
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = opcode;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&level), 4);
            (void) memcpy((void *) (pc + 52), (void *) (&xoffset), 4);
            (void) memcpy((void *) (pc + 56), (void *) (&yoffset), 4);
            (void) memcpy((void *) (pc + 60), (void *) (&zoffset), 4);
            (void) memcpy((void *) (pc + 64), (void *) (&woffset), 4);
            (void) memcpy((void *) (pc + 68), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 72), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 76), (void *) (&depth), 4);
            (void) memcpy((void *) (pc + 80), (void *) (&extent), 4);
            (void) memcpy((void *) (pc + 84), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 88), (void *) (&type), 4);
            (void) memset((void *) (pc + 92), 0, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, depth,
                                format, type, pixels, pc + 96, pc + 8);
        }
    }
}

#define X_GLrop_TexSubImage3D 4115
void
__indirect_glTexSubImage3D(GLenum target, GLint level, GLint xoffset,
                           GLint yoffset, GLint zoffset, GLsizei width,
                           GLsizei height, GLsizei depth, GLenum format,
                           GLenum type, const GLvoid * pixels)
{
    __glx_TexSubImage_3D4D(X_GLrop_TexSubImage3D, 3, target, level, xoffset,
                           yoffset, zoffset, 1, width, height, depth, 1,
                           format, type, pixels);
}

#define X_GLrop_CopyTexSubImage3D 4123
void
__indirect_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset,
                               GLint yoffset, GLint zoffset, GLint x, GLint y,
                               GLsizei width, GLsizei height)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 40;
    emit_header(gc->pc, X_GLrop_CopyTexSubImage3D, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&xoffset), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&yoffset), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&zoffset), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&height), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ActiveTextureARB 197
void
__indirect_glActiveTextureARB(GLenum texture)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ActiveTextureARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&texture), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord1dvARB 198
void
__indirect_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord1dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord1dvARB 198
void
__indirect_glMultiTexCoord1dvARB(GLenum target, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord1dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord1fvARB 199
void
__indirect_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_MultiTexCoord1fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord1fvARB 199
void
__indirect_glMultiTexCoord1fvARB(GLenum target, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_MultiTexCoord1fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord1ivARB 200
void
__indirect_glMultiTexCoord1iARB(GLenum target, GLint s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_MultiTexCoord1ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord1ivARB 200
void
__indirect_glMultiTexCoord1ivARB(GLenum target, const GLint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_MultiTexCoord1ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord1svARB 201
void
__indirect_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_MultiTexCoord1svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord1svARB 201
void
__indirect_glMultiTexCoord1svARB(GLenum target, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_MultiTexCoord1svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord2dvARB 202
void
__indirect_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_MultiTexCoord2dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord2dvARB 202
void
__indirect_glMultiTexCoord2dvARB(GLenum target, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_MultiTexCoord2dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 16);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord2fvARB 203
void
__indirect_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord2fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord2fvARB 203
void
__indirect_glMultiTexCoord2fvARB(GLenum target, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord2fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord2ivARB 204
void
__indirect_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord2ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord2ivARB 204
void
__indirect_glMultiTexCoord2ivARB(GLenum target, const GLint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord2ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord2svARB 205
void
__indirect_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_MultiTexCoord2svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&t), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord2svARB 205
void
__indirect_glMultiTexCoord2svARB(GLenum target, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_MultiTexCoord2svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord3dvARB 206
void
__indirect_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t,
                                GLdouble r)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 32;
    emit_header(gc->pc, X_GLrop_MultiTexCoord3dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&r), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord3dvARB 206
void
__indirect_glMultiTexCoord3dvARB(GLenum target, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 32;
    emit_header(gc->pc, X_GLrop_MultiTexCoord3dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 24);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord3fvARB 207
void
__indirect_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t,
                                GLfloat r)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_MultiTexCoord3fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&r), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord3fvARB 207
void
__indirect_glMultiTexCoord3fvARB(GLenum target, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_MultiTexCoord3fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 12);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord3ivARB 208
void
__indirect_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_MultiTexCoord3ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&r), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord3ivARB 208
void
__indirect_glMultiTexCoord3ivARB(GLenum target, const GLint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_MultiTexCoord3ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 12);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord3svARB 209
void
__indirect_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t,
                                GLshort r)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord3svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&t), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord3svARB 209
void
__indirect_glMultiTexCoord3svARB(GLenum target, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord3svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 6);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord4dvARB 210
void
__indirect_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t,
                                GLdouble r, GLdouble q)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 40;
    emit_header(gc->pc, X_GLrop_MultiTexCoord4dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&r), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&q), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord4dvARB 210
void
__indirect_glMultiTexCoord4dvARB(GLenum target, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 40;
    emit_header(gc->pc, X_GLrop_MultiTexCoord4dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 32);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord4fvARB 211
void
__indirect_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t,
                                GLfloat r, GLfloat q)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_MultiTexCoord4fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&r), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&q), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord4fvARB 211
void
__indirect_glMultiTexCoord4fvARB(GLenum target, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_MultiTexCoord4fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord4ivARB 212
void
__indirect_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r,
                                GLint q)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_MultiTexCoord4ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&r), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&q), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord4ivARB 212
void
__indirect_glMultiTexCoord4ivARB(GLenum target, const GLint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_MultiTexCoord4ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord4svARB 213
void
__indirect_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t,
                                GLshort r, GLshort q)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord4svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&t), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 2);
    (void) memcpy((void *) (gc->pc + 14), (void *) (&q), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_MultiTexCoord4svARB 213
void
__indirect_glMultiTexCoord4svARB(GLenum target, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_MultiTexCoord4svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SampleCoverageARB 229
void
__indirect_glSampleCoverageARB(GLclampf value, GLboolean invert)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_SampleCoverageARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&value), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&invert), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLvop_GetProgramStringARB 1308
void
__indirect_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid * string)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramStringARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 1, string, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetProgramivARB 1307
void
__indirect_glGetProgramivARB(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramivARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLrop_ProgramEnvParameter4dvARB 4185
void
__indirect_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x,
                                      GLdouble y, GLdouble z, GLdouble w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44;
    emit_header(gc->pc, X_GLrop_ProgramEnvParameter4dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&w), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ProgramEnvParameter4dvARB 4185
void
__indirect_glProgramEnvParameter4dvARB(GLenum target, GLuint index,
                                       const GLdouble * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44;
    emit_header(gc->pc, X_GLrop_ProgramEnvParameter4dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 32);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ProgramEnvParameter4fvARB 4184
void
__indirect_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x,
                                      GLfloat y, GLfloat z, GLfloat w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_ProgramEnvParameter4fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ProgramEnvParameter4fvARB 4184
void
__indirect_glProgramEnvParameter4fvARB(GLenum target, GLuint index,
                                       const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_ProgramEnvParameter4fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ProgramLocalParameter4dvARB 4216
void
__indirect_glProgramLocalParameter4dARB(GLenum target, GLuint index,
                                        GLdouble x, GLdouble y, GLdouble z,
                                        GLdouble w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44;
    emit_header(gc->pc, X_GLrop_ProgramLocalParameter4dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&w), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ProgramLocalParameter4dvARB 4216
void
__indirect_glProgramLocalParameter4dvARB(GLenum target, GLuint index,
                                         const GLdouble * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44;
    emit_header(gc->pc, X_GLrop_ProgramLocalParameter4dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 32);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ProgramLocalParameter4fvARB 4215
void
__indirect_glProgramLocalParameter4fARB(GLenum target, GLuint index,
                                        GLfloat x, GLfloat y, GLfloat z,
                                        GLfloat w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_ProgramLocalParameter4fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ProgramLocalParameter4fvARB 4215
void
__indirect_glProgramLocalParameter4fvARB(GLenum target, GLuint index,
                                         const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_ProgramLocalParameter4fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ProgramStringARB 4217
void
__indirect_glProgramStringARB(GLenum target, GLenum format, GLsizei len,
                              const GLvoid * string)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16 + __GLX_PAD(len);
    if (len < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((len >= 0) && (gc->currentDpy != NULL), 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_ProgramStringARB, cmdlen);
            (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (&len), 4);
            (void) memcpy((void *) (gc->pc + 16), (void *) (string), len);
            gc->pc += cmdlen;
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_ProgramStringARB;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 16), (void *) (&len), 4);
            __glXSendLargeCommand(gc, pc, 20, string, len);
        }
    }
}

#define X_GLrop_VertexAttrib1dvARB 4197
void
__indirect_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib1dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1dvARB 4197
void
__indirect_glVertexAttrib1dvARB(GLuint index, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib1dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1fvARB 4193
void
__indirect_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib1fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1fvARB 4193
void
__indirect_glVertexAttrib1fvARB(GLuint index, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib1fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1svARB 4189
void
__indirect_glVertexAttrib1sARB(GLuint index, GLshort x)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib1svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1svARB 4189
void
__indirect_glVertexAttrib1svARB(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib1svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2dvARB 4198
void
__indirect_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib2dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2dvARB 4198
void
__indirect_glVertexAttrib2dvARB(GLuint index, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib2dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2fvARB 4194
void
__indirect_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib2fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2fvARB 4194
void
__indirect_glVertexAttrib2fvARB(GLuint index, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib2fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2svARB 4190
void
__indirect_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib2svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2svARB 4190
void
__indirect_glVertexAttrib2svARB(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib2svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3dvARB 4199
void
__indirect_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y,
                               GLdouble z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 32;
    emit_header(gc->pc, X_GLrop_VertexAttrib3dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&z), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3dvARB 4199
void
__indirect_glVertexAttrib3dvARB(GLuint index, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 32;
    emit_header(gc->pc, X_GLrop_VertexAttrib3dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 24);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3fvARB 4195
void
__indirect_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_VertexAttrib3fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3fvARB 4195
void
__indirect_glVertexAttrib3fvARB(GLuint index, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_VertexAttrib3fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 12);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3svARB 4191
void
__indirect_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib3svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3svARB 4191
void
__indirect_glVertexAttrib3svARB(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib3svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 6);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4NbvARB 4235
void
__indirect_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib4NbvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4NivARB 4237
void
__indirect_glVertexAttrib4NivARB(GLuint index, const GLint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib4NivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4NsvARB 4236
void
__indirect_glVertexAttrib4NsvARB(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib4NsvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4NubvARB 4201
void
__indirect_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y,
                                 GLubyte z, GLubyte w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib4NubvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 1);
    (void) memcpy((void *) (gc->pc + 9), (void *) (&y), 1);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&z), 1);
    (void) memcpy((void *) (gc->pc + 11), (void *) (&w), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4NubvARB 4201
void
__indirect_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib4NubvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4NuivARB 4239
void
__indirect_glVertexAttrib4NuivARB(GLuint index, const GLuint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib4NuivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4NusvARB 4238
void
__indirect_glVertexAttrib4NusvARB(GLuint index, const GLushort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib4NusvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4bvARB 4230
void
__indirect_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib4bvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4dvARB 4200
void
__indirect_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y,
                               GLdouble z, GLdouble w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 40;
    emit_header(gc->pc, X_GLrop_VertexAttrib4dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&w), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4dvARB 4200
void
__indirect_glVertexAttrib4dvARB(GLuint index, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 40;
    emit_header(gc->pc, X_GLrop_VertexAttrib4dvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 32);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4fvARB 4196
void
__indirect_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z,
                               GLfloat w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib4fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4fvARB 4196
void
__indirect_glVertexAttrib4fvARB(GLuint index, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib4fvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4ivARB 4231
void
__indirect_glVertexAttrib4ivARB(GLuint index, const GLint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib4ivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4svARB 4192
void
__indirect_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z,
                               GLshort w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib4svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 2);
    (void) memcpy((void *) (gc->pc + 14), (void *) (&w), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4svARB 4192
void
__indirect_glVertexAttrib4svARB(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib4svARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4ubvARB 4232
void
__indirect_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib4ubvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4uivARB 4234
void
__indirect_glVertexAttrib4uivARB(GLuint index, const GLuint * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib4uivARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4usvARB 4233
void
__indirect_glVertexAttrib4usvARB(GLuint index, const GLushort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib4usvARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_BeginQueryARB 231
void
__indirect_glBeginQueryARB(GLenum target, GLuint id)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_BeginQueryARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&id), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLsop_DeleteQueriesARB 161
void
__indirect_glDeleteQueriesARB(GLsizei n, const GLuint * ids)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
#endif
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_delete_queries_arb(c, gc->currentContextTag, n, ids);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_DeleteQueriesARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (ids), (n * 4));
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLrop_EndQueryARB 232
void
__indirect_glEndQueryARB(GLenum target)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_EndQueryARB, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLsop_GenQueriesARB 162
void
__indirect_glGenQueriesARB(GLsizei n, GLuint * ids)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_gen_queries_arb_reply_t *reply =
            xcb_glx_gen_queries_arb_reply(c,
                                          xcb_glx_gen_queries_arb(c,
                                                                  gc->
                                                                  currentContextTag,
                                                                  n), NULL);
        (void) memcpy(ids, xcb_glx_gen_queries_arb_data(reply),
                      xcb_glx_gen_queries_arb_data_length(reply) *
                      sizeof(GLuint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GenQueriesARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) __glXReadReply(dpy, 4, ids, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetQueryObjectivARB 165
void
__indirect_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_query_objectiv_arb_reply_t *reply =
            xcb_glx_get_query_objectiv_arb_reply(c,
                                                 xcb_glx_get_query_objectiv_arb
                                                 (c, gc->currentContextTag,
                                                  id, pname), NULL);
        if (xcb_glx_get_query_objectiv_arb_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_query_objectiv_arb_data(reply),
                          xcb_glx_get_query_objectiv_arb_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetQueryObjectivARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetQueryObjectuivARB 166
void
__indirect_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_query_objectuiv_arb_reply_t *reply =
            xcb_glx_get_query_objectuiv_arb_reply(c,
                                                  xcb_glx_get_query_objectuiv_arb
                                                  (c, gc->currentContextTag,
                                                   id, pname), NULL);
        if (xcb_glx_get_query_objectuiv_arb_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_query_objectuiv_arb_data(reply),
                          xcb_glx_get_query_objectuiv_arb_data_length(reply) *
                          sizeof(GLuint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetQueryObjectuivARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetQueryivARB 164
void
__indirect_glGetQueryivARB(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
#ifndef USE_XCB
    const GLuint cmdlen = 8;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_queryiv_arb_reply_t *reply =
            xcb_glx_get_queryiv_arb_reply(c,
                                          xcb_glx_get_queryiv_arb(c,
                                                                  gc->
                                                                  currentContextTag,
                                                                  target,
                                                                  pname),
                                          NULL);
        if (xcb_glx_get_queryiv_arb_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
        else
            (void) memcpy(params, xcb_glx_get_queryiv_arb_data(reply),
                          xcb_glx_get_queryiv_arb_data_length(reply) *
                          sizeof(GLint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetQueryivARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_IsQueryARB 163
GLboolean
__indirect_glIsQueryARB(GLuint id)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
#ifndef USE_XCB
    const GLuint cmdlen = 4;
#endif
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_is_query_arb_reply_t *reply =
            xcb_glx_is_query_arb_reply(c,
                                       xcb_glx_is_query_arb(c,
                                                            gc->
                                                            currentContextTag,
                                                            id), NULL);
        retval = reply->ret_val;
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_IsQueryARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return retval;
}

#define X_GLrop_DrawBuffersARB 233
void
__indirect_glDrawBuffersARB(GLsizei n, const GLenum * bufs)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (gc->currentDpy != NULL), 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ((gc->pc + cmdlen) > gc->bufEnd) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_DrawBuffersARB, cmdlen);
            (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (bufs), (n * 4));
            gc->pc += cmdlen;
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
            const GLint op = X_GLrop_DrawBuffersARB;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&n), 4);
            __glXSendLargeCommand(gc, pc, 12, bufs, (n * 4));
        }
    }
}

#define X_GLrop_SampleMaskSGIS 2048
void
__indirect_glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_SampleMaskSGIS, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&value), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&invert), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SamplePatternSGIS 2049
void
__indirect_glSamplePatternSGIS(GLenum pattern)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_SamplePatternSGIS, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pattern), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PointParameterfEXT 2065
void
__indirect_glPointParameterfEXT(GLenum pname, GLfloat param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_PointParameterfEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PointParameterfvEXT 2066
void
__indirect_glPointParameterfvEXT(GLenum pname, const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glPointParameterfvEXT_size(pname);
    const GLuint cmdlen = 8 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_PointParameterfvEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3bvEXT 4126
void
__indirect_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_SecondaryColor3bvEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3bvEXT 4126
void
__indirect_glSecondaryColor3bvEXT(const GLbyte *v)
{
    generic_3_byte(X_GLrop_SecondaryColor3bvEXT, v);
}

#define X_GLrop_SecondaryColor3dvEXT 4130
void
__indirect_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_SecondaryColor3dvEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&green), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&blue), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3dvEXT 4130
void
__indirect_glSecondaryColor3dvEXT(const GLdouble * v)
{
    generic_24_byte(X_GLrop_SecondaryColor3dvEXT, v);
}

#define X_GLrop_SecondaryColor3fvEXT 4129
void
__indirect_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_SecondaryColor3fvEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3fvEXT 4129
void
__indirect_glSecondaryColor3fvEXT(const GLfloat * v)
{
    generic_12_byte(X_GLrop_SecondaryColor3fvEXT, v);
}

#define X_GLrop_SecondaryColor3ivEXT 4128
void
__indirect_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_SecondaryColor3ivEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3ivEXT 4128
void
__indirect_glSecondaryColor3ivEXT(const GLint * v)
{
    generic_12_byte(X_GLrop_SecondaryColor3ivEXT, v);
}

#define X_GLrop_SecondaryColor3svEXT 4127
void
__indirect_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_SecondaryColor3svEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3svEXT 4127
void
__indirect_glSecondaryColor3svEXT(const GLshort * v)
{
    generic_6_byte(X_GLrop_SecondaryColor3svEXT, v);
}

#define X_GLrop_SecondaryColor3ubvEXT 4131
void
__indirect_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_SecondaryColor3ubvEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3ubvEXT 4131
void
__indirect_glSecondaryColor3ubvEXT(const GLubyte *v)
{
    generic_3_byte(X_GLrop_SecondaryColor3ubvEXT, v);
}

#define X_GLrop_SecondaryColor3uivEXT 4133
void
__indirect_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_SecondaryColor3uivEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3uivEXT 4133
void
__indirect_glSecondaryColor3uivEXT(const GLuint * v)
{
    generic_12_byte(X_GLrop_SecondaryColor3uivEXT, v);
}

#define X_GLrop_SecondaryColor3usvEXT 4132
void
__indirect_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_SecondaryColor3usvEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_SecondaryColor3usvEXT 4132
void
__indirect_glSecondaryColor3usvEXT(const GLushort * v)
{
    generic_6_byte(X_GLrop_SecondaryColor3usvEXT, v);
}

#define X_GLrop_FogCoorddvEXT 4125
void
__indirect_glFogCoorddEXT(GLdouble coord)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_FogCoorddvEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_FogCoorddvEXT 4125
void
__indirect_glFogCoorddvEXT(const GLdouble * coord)
{
    generic_8_byte(X_GLrop_FogCoorddvEXT, coord);
}

#define X_GLrop_FogCoordfvEXT 4124
void
__indirect_glFogCoordfEXT(GLfloat coord)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_FogCoordfvEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_FogCoordfvEXT 4124
void
__indirect_glFogCoordfvEXT(const GLfloat * coord)
{
    generic_4_byte(X_GLrop_FogCoordfvEXT, coord);
}

#define X_GLrop_BlendFuncSeparateEXT 4134
void
__indirect_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB,
                                  GLenum sfactorAlpha, GLenum dfactorAlpha)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_BlendFuncSeparateEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&sfactorRGB), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&dfactorRGB), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&sfactorAlpha), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&dfactorAlpha), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_WindowPos3fvMESA 230
void
__indirect_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_WindowPos3fvMESA, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_WindowPos3fvMESA 230
void
__indirect_glWindowPos3fvMESA(const GLfloat * v)
{
    generic_12_byte(X_GLrop_WindowPos3fvMESA, v);
}

#define X_GLvop_AreProgramsResidentNV 1293
GLboolean
__indirect_glAreProgramsResidentNV(GLsizei n, const GLuint * ids,
                                   GLboolean * residences)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
    const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return 0;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_AreProgramsResidentNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (ids), (n * 4));
        retval = (GLboolean) __glXReadReply(dpy, 1, residences, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return retval;
}

#define X_GLrop_BindProgramNV 4180
void
__indirect_glBindProgramNV(GLenum target, GLuint program)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_BindProgramNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&program), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLvop_DeleteProgramsNV 1294
void
__indirect_glDeleteProgramsNV(GLsizei n, const GLuint * programs)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivate,
                                    X_GLvop_DeleteProgramsNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (programs), (n * 4));
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLrop_ExecuteProgramNV 4181
void
__indirect_glExecuteProgramNV(GLenum target, GLuint id,
                              const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_ExecuteProgramNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&id), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLvop_GenProgramsNV 1295
void
__indirect_glGenProgramsNV(GLsizei n, GLuint * programs)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 4;
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GenProgramsNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) __glXReadReply(dpy, 4, programs, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetProgramParameterdvNV 1297
void
__indirect_glGetProgramParameterdvNV(GLenum target, GLuint index,
                                     GLenum pname, GLdouble * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 12;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramParameterdvNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 8, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetProgramParameterfvNV 1296
void
__indirect_glGetProgramParameterfvNV(GLenum target, GLuint index,
                                     GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 12;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramParameterfvNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetProgramStringNV 1299
void
__indirect_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramStringNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 1, program, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetProgramivNV 1298
void
__indirect_glGetProgramivNV(GLuint id, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramivNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetTrackMatrixivNV 1300
void
__indirect_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname,
                                GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 12;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetTrackMatrixivNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&address), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetVertexAttribdvNV 1301
void
__indirect_glGetVertexAttribdvNV(GLuint index, GLenum pname,
                                 GLdouble * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetVertexAttribdvNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 8, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetVertexAttribfvNV 1302
void
__indirect_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetVertexAttribfvNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetVertexAttribivNV 1303
void
__indirect_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetVertexAttribivNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_IsProgramNV 1304
GLboolean
__indirect_glIsProgramNV(GLuint program)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
    const GLuint cmdlen = 4;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_IsProgramNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&program), 4);
        retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return retval;
}

#define X_GLrop_LoadProgramNV 4183
void
__indirect_glLoadProgramNV(GLenum target, GLuint id, GLsizei len,
                           const GLubyte *program)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16 + __GLX_PAD(len);
    if (len < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(len >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_LoadProgramNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 16), (void *) (program), len);
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_ProgramParameters4dvNV 4187
void
__indirect_glProgramParameters4dvNV(GLenum target, GLuint index, GLuint num,
                                    const GLdouble * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16 + __GLX_PAD((num * 32));
    if (num < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(num >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_ProgramParameters4dvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&num), 4);
        (void) memcpy((void *) (gc->pc + 16), (void *) (params), (num * 32));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_ProgramParameters4fvNV 4186
void
__indirect_glProgramParameters4fvNV(GLenum target, GLuint index, GLuint num,
                                    const GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16 + __GLX_PAD((num * 16));
    if (num < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(num >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_ProgramParameters4fvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&num), 4);
        (void) memcpy((void *) (gc->pc + 16), (void *) (params), (num * 16));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_RequestResidentProgramsNV 4182
void
__indirect_glRequestResidentProgramsNV(GLsizei n, const GLuint * ids)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_RequestResidentProgramsNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (ids), (n * 4));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_TrackMatrixNV 4188
void
__indirect_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix,
                           GLenum transform)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_TrackMatrixNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&address), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&matrix), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&transform), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1dvNV 4273
void
__indirect_glVertexAttrib1dNV(GLuint index, GLdouble x)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib1dvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1dvNV 4273
void
__indirect_glVertexAttrib1dvNV(GLuint index, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib1dvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1fvNV 4269
void
__indirect_glVertexAttrib1fNV(GLuint index, GLfloat x)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib1fvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1fvNV 4269
void
__indirect_glVertexAttrib1fvNV(GLuint index, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib1fvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1svNV 4265
void
__indirect_glVertexAttrib1sNV(GLuint index, GLshort x)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib1svNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib1svNV 4265
void
__indirect_glVertexAttrib1svNV(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib1svNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2dvNV 4274
void
__indirect_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib2dvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2dvNV 4274
void
__indirect_glVertexAttrib2dvNV(GLuint index, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib2dvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2fvNV 4270
void
__indirect_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib2fvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2fvNV 4270
void
__indirect_glVertexAttrib2fvNV(GLuint index, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib2fvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2svNV 4266
void
__indirect_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib2svNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib2svNV 4266
void
__indirect_glVertexAttrib2svNV(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib2svNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3dvNV 4275
void
__indirect_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y,
                              GLdouble z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 32;
    emit_header(gc->pc, X_GLrop_VertexAttrib3dvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&z), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3dvNV 4275
void
__indirect_glVertexAttrib3dvNV(GLuint index, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 32;
    emit_header(gc->pc, X_GLrop_VertexAttrib3dvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 24);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3fvNV 4271
void
__indirect_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_VertexAttrib3fvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3fvNV 4271
void
__indirect_glVertexAttrib3fvNV(GLuint index, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_VertexAttrib3fvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 12);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3svNV 4267
void
__indirect_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib3svNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib3svNV 4267
void
__indirect_glVertexAttrib3svNV(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib3svNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 6);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4dvNV 4276
void
__indirect_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y,
                              GLdouble z, GLdouble w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 40;
    emit_header(gc->pc, X_GLrop_VertexAttrib4dvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&w), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4dvNV 4276
void
__indirect_glVertexAttrib4dvNV(GLuint index, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 40;
    emit_header(gc->pc, X_GLrop_VertexAttrib4dvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 32);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4fvNV 4272
void
__indirect_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z,
                              GLfloat w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib4fvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4fvNV 4272
void
__indirect_glVertexAttrib4fvNV(GLuint index, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_VertexAttrib4fvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4svNV 4268
void
__indirect_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z,
                              GLshort w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib4svNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 2);
    (void) memcpy((void *) (gc->pc + 14), (void *) (&w), 2);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4svNV 4268
void
__indirect_glVertexAttrib4svNV(GLuint index, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 16;
    emit_header(gc->pc, X_GLrop_VertexAttrib4svNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4ubvNV 4277
void
__indirect_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z,
                               GLubyte w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib4ubvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 1);
    (void) memcpy((void *) (gc->pc + 9), (void *) (&y), 1);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&z), 1);
    (void) memcpy((void *) (gc->pc + 11), (void *) (&w), 1);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttrib4ubvNV 4277
void
__indirect_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_VertexAttrib4ubvNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_VertexAttribs1dvNV 4210
void
__indirect_glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 8));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs1dvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 8));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs1fvNV 4206
void
__indirect_glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs1fvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 4));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs1svNV 4202
void
__indirect_glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 2));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs1svNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 2));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs2dvNV 4211
void
__indirect_glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 16));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs2dvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 16));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs2fvNV 4207
void
__indirect_glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 8));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs2fvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 8));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs2svNV 4203
void
__indirect_glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs2svNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 4));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs3dvNV 4212
void
__indirect_glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 24));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs3dvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 24));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs3fvNV 4208
void
__indirect_glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 12));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs3fvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 12));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs3svNV 4204
void
__indirect_glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 6));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs3svNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 6));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs4dvNV 4213
void
__indirect_glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 32));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs4dvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 32));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs4fvNV 4209
void
__indirect_glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 16));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs4fvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 16));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs4svNV 4205
void
__indirect_glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 8));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs4svNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 8));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_VertexAttribs4ubvNV 4214
void
__indirect_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_VertexAttribs4ubvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 4));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_PointParameteriNV 4221
void
__indirect_glPointParameteriNV(GLenum pname, GLint param)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_PointParameteriNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_PointParameterivNV 4222
void
__indirect_glPointParameterivNV(GLenum pname, const GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize = __glPointParameterivNV_size(pname);
    const GLuint cmdlen = 8 + __GLX_PAD((compsize * 4));
    emit_header(gc->pc, X_GLrop_PointParameterivNV, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_ActiveStencilFaceEXT 4220
void
__indirect_glActiveStencilFaceEXT(GLenum face)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_ActiveStencilFaceEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLvop_GetProgramNamedParameterdvNV 1311
void
__indirect_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len,
                                          const GLubyte *name,
                                          GLdouble * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8 + __GLX_PAD(len);
    if (len < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((len >= 0) && (dpy != NULL), 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramNamedParameterdvNV,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&len), 4);
        (void) memcpy((void *) (pc + 8), (void *) (name), len);
        (void) __glXReadReply(dpy, 8, params, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetProgramNamedParameterfvNV 1310
void
__indirect_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len,
                                          const GLubyte *name,
                                          GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8 + __GLX_PAD(len);
    if (len < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((len >= 0) && (dpy != NULL), 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramNamedParameterfvNV,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&len), 4);
        (void) memcpy((void *) (pc + 8), (void *) (name), len);
        (void) __glXReadReply(dpy, 4, params, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLrop_ProgramNamedParameter4dvNV 4219
void
__indirect_glProgramNamedParameter4dNV(GLuint id, GLsizei len,
                                       const GLubyte *name, GLdouble x,
                                       GLdouble y, GLdouble z, GLdouble w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44 + __GLX_PAD(len);
    if (len < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(len >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_ProgramNamedParameter4dvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
        (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
        (void) memcpy((void *) (gc->pc + 28), (void *) (&w), 8);
        (void) memcpy((void *) (gc->pc + 36), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 40), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 44), (void *) (name), len);
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_ProgramNamedParameter4dvNV 4219
void
__indirect_glProgramNamedParameter4dvNV(GLuint id, GLsizei len,
                                        const GLubyte *name,
                                        const GLdouble * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44 + __GLX_PAD(len);
    if (len < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(len >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_ProgramNamedParameter4dvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (v), 32);
        (void) memcpy((void *) (gc->pc + 36), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 40), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 44), (void *) (name), len);
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_ProgramNamedParameter4fvNV 4218
void
__indirect_glProgramNamedParameter4fNV(GLuint id, GLsizei len,
                                       const GLubyte *name, GLfloat x,
                                       GLfloat y, GLfloat z, GLfloat w)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28 + __GLX_PAD(len);
    if (len < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(len >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_ProgramNamedParameter4fvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
        (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
        (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 4);
        (void) memcpy((void *) (gc->pc + 24), (void *) (&w), 4);
        (void) memcpy((void *) (gc->pc + 28), (void *) (name), len);
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_ProgramNamedParameter4fvNV 4218
void
__indirect_glProgramNamedParameter4fvNV(GLuint id, GLsizei len,
                                        const GLubyte *name,
                                        const GLfloat * v)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28 + __GLX_PAD(len);
    if (len < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(len >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_ProgramNamedParameter4fvNV, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), 16);
        (void) memcpy((void *) (gc->pc + 28), (void *) (name), len);
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_BlendEquationSeparateEXT 4228
void
__indirect_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeA)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_BlendEquationSeparateEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&modeRGB), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&modeA), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_BindFramebufferEXT 4319
void
__indirect_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_BindFramebufferEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&framebuffer), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_BindRenderbufferEXT 4316
void
__indirect_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 12;
    emit_header(gc->pc, X_GLrop_BindRenderbufferEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&renderbuffer), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLvop_CheckFramebufferStatusEXT 1427
GLenum
__indirect_glCheckFramebufferStatusEXT(GLenum target)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLenum retval = (GLenum) 0;
    const GLuint cmdlen = 4;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_CheckFramebufferStatusEXT,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        retval = (GLenum) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return retval;
}

#define X_GLrop_DeleteFramebuffersEXT 4320
void
__indirect_glDeleteFramebuffersEXT(GLsizei n, const GLuint * framebuffers)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_DeleteFramebuffersEXT, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (framebuffers),
                      (n * 4));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_DeleteRenderbuffersEXT 4317
void
__indirect_glDeleteRenderbuffersEXT(GLsizei n, const GLuint * renderbuffers)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8 + __GLX_PAD((n * 4));
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect(n >= 0, 1)) {
        emit_header(gc->pc, X_GLrop_DeleteRenderbuffersEXT, cmdlen);
        (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (renderbuffers),
                      (n * 4));
        gc->pc += cmdlen;
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
    }
}

#define X_GLrop_FramebufferRenderbufferEXT 4324
void
__indirect_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment,
                                        GLenum renderbuffertarget,
                                        GLuint renderbuffer)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_FramebufferRenderbufferEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&attachment), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&renderbuffertarget), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&renderbuffer), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_FramebufferTexture1DEXT 4321
void
__indirect_glFramebufferTexture1DEXT(GLenum target, GLenum attachment,
                                     GLenum textarget, GLuint texture,
                                     GLint level)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_FramebufferTexture1DEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&attachment), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&textarget), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&texture), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&level), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_FramebufferTexture2DEXT 4322
void
__indirect_glFramebufferTexture2DEXT(GLenum target, GLenum attachment,
                                     GLenum textarget, GLuint texture,
                                     GLint level)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 24;
    emit_header(gc->pc, X_GLrop_FramebufferTexture2DEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&attachment), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&textarget), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&texture), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&level), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLrop_FramebufferTexture3DEXT 4323
void
__indirect_glFramebufferTexture3DEXT(GLenum target, GLenum attachment,
                                     GLenum textarget, GLuint texture,
                                     GLint level, GLint zoffset)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_FramebufferTexture3DEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&attachment), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&textarget), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&texture), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&zoffset), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLvop_GenFramebuffersEXT 1426
void
__indirect_glGenFramebuffersEXT(GLsizei n, GLuint * framebuffers)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 4;
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GenFramebuffersEXT, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) __glXReadReply(dpy, 4, framebuffers, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GenRenderbuffersEXT 1423
void
__indirect_glGenRenderbuffersEXT(GLsizei n, GLuint * renderbuffers)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 4;
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GenRenderbuffersEXT, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) __glXReadReply(dpy, 4, renderbuffers, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLrop_GenerateMipmapEXT 4325
void
__indirect_glGenerateMipmapEXT(GLenum target)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8;
    emit_header(gc->pc, X_GLrop_GenerateMipmapEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}

#define X_GLvop_GetFramebufferAttachmentParameterivEXT 1428
void
__indirect_glGetFramebufferAttachmentParameterivEXT(GLenum target,
                                                    GLenum attachment,
                                                    GLenum pname,
                                                    GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 12;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetFramebufferAttachmentParameterivEXT,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&attachment), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_GetRenderbufferParameterivEXT 1424
void
__indirect_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname,
                                           GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetRenderbufferParameterivEXT,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return;
}

#define X_GLvop_IsFramebufferEXT 1425
GLboolean
__indirect_glIsFramebufferEXT(GLuint framebuffer)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
    const GLuint cmdlen = 4;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_IsFramebufferEXT, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&framebuffer), 4);
        retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return retval;
}

#define X_GLvop_IsRenderbufferEXT 1422
GLboolean
__indirect_glIsRenderbufferEXT(GLuint renderbuffer)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
    const GLuint cmdlen = 4;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_IsRenderbufferEXT, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&renderbuffer), 4);
        retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
    }
    return retval;
}

#define X_GLrop_RenderbufferStorageEXT 4318
void
__indirect_glRenderbufferStorageEXT(GLenum target, GLenum internalformat,
                                    GLsizei width, GLsizei height)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 20;
    emit_header(gc->pc, X_GLrop_RenderbufferStorageEXT, cmdlen);
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&height), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
}


#  undef FASTCALL
#  undef NOINLINE
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a5077 79
#define X_GLsop_AreTexturesResident 143
GLboolean
__indirect_glAreTexturesResident(GLsizei n, const GLuint * textures,
                                 GLboolean * residences)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
#ifndef USE_XCB
    const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
#endif
    if (n < 0) {
        __glXSetError(gc, GL_INVALID_VALUE);
        return 0;
    }
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_are_textures_resident_reply_t *reply =
            xcb_glx_are_textures_resident_reply(c,
                                                xcb_glx_are_textures_resident
                                                (c, gc->currentContextTag, n,
                                                 textures), NULL);
        (void) memcpy(residences, xcb_glx_are_textures_resident_data(reply),
                      xcb_glx_are_textures_resident_data_length(reply) *
                      sizeof(GLboolean));
        retval = reply->ret_val;
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_AreTexturesResident, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (textures), (n * 4));
        retval = (GLboolean) __glXReadReply(dpy, 1, residences, GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
    }
    return retval;
}

#define X_GLvop_AreTexturesResidentEXT 11
GLboolean
glAreTexturesResidentEXT(GLsizei n, const GLuint * textures,
                         GLboolean * residences)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

#ifdef GLX_DIRECT_RENDERING
    if (gc->driContext) {
        return CALL_AreTexturesResident(GET_DISPATCH(),
                                        (n, textures, residences));
    } else
#endif
    {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        GLboolean retval = (GLboolean) 0;
        const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
        if (n < 0) {
            __glXSetError(gc, GL_INVALID_VALUE);
            return 0;
        }
        if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_AreTexturesResidentEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
            (void) memcpy((void *) (pc + 4), (void *) (textures), (n * 4));
            retval = (GLboolean) __glXReadReply(dpy, 1, residences, GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return retval;
    }
}

d5204 3
a5206 1
    } else
a5207 1
    {
d5273 1
a5273 1
#ifdef GLX_DIRECT_RENDERING
d5276 3
a5278 1
    } else
a5279 1
    {
d5339 1
a5339 1
#ifdef GLX_DIRECT_RENDERING
d5342 3
a5344 1
    } else
a5345 1
    {
d5412 1
a5412 2
            (void) memcpy((void *) (gc->pc + 56),
                          (void *) ((pixels == NULL) ? one : zero), 4);
d5438 1
a5438 1
            (void) memcpy((void *) (pc + 60), zero, 4);
d5656 1
a5656 1
#ifdef GLX_DIRECT_RENDERING
d5659 3
a5661 1
    } else
a5662 1
    {
d5733 1
a5733 1
#ifdef GLX_DIRECT_RENDERING
d5737 3
a5739 1
    } else
a5740 1
    {
d5807 1
a5807 1
#ifdef GLX_DIRECT_RENDERING
d5811 3
a5813 1
    } else
a5814 1
    {
d6134 1
a6134 1
#ifdef GLX_DIRECT_RENDERING
d6138 3
a6140 1
    } else
a6141 1
    {
d6213 1
a6213 1
#ifdef GLX_DIRECT_RENDERING
d6217 3
a6219 1
    } else
a6220 1
    {
d6287 1
a6287 1
#ifdef GLX_DIRECT_RENDERING
d6291 3
a6293 1
    } else
a6294 1
    {
d6368 1
a6368 1
#ifdef GLX_DIRECT_RENDERING
d6372 3
a6374 1
    } else
a6375 1
    {
d6446 1
a6446 1
#ifdef GLX_DIRECT_RENDERING
d6449 3
a6451 1
    } else
a6452 1
    {
d6518 1
a6518 1
#ifdef GLX_DIRECT_RENDERING
d6521 3
a6523 1
    } else
a6524 1
    {
d6594 1
a6594 1
#ifdef GLX_DIRECT_RENDERING
d6597 3
a6599 1
    } else
a6600 1
    {
d6669 1
a6669 1
#ifdef GLX_DIRECT_RENDERING
d6672 3
a6674 1
    } else
a6675 1
    {
d6738 1
a6738 1
#ifdef GLX_DIRECT_RENDERING
d6741 3
a6743 1
    } else
a6744 1
    {
d6931 1
a6931 2
            (void) memcpy((void *) (gc->pc + 88),
                          (void *) ((pixels == NULL) ? one : zero), 4);
d6961 1
a6961 1
            (void) memcpy((void *) (pc + 92), zero, 4);
@


1.1
log
@Initial revision
@
text
@d33 3
d38 3
a40 3
#include <X11/xcl.h>
#include <X11/XCB/xcb.h>
#include <X11/XCB/glx.h>
d69 2
a70 1
__glXReadReply( Display *dpy, size_t size, void * dest, GLboolean reply_is_always_array )
d73 1
a73 1
    
d77 2
a78 2
            const GLint bytes = (reply_is_always_array) 
              ? (4 * reply.length) : (reply.size * size);
d82 1
a82 1
            if ( extra < 4 ) {
d85 2
a86 3
        }
        else {
            (void) memcpy( dest, &(reply.pad3), size);
d94 3
a96 3
__glXReadPixelReply( Display *dpy, __GLXcontext * gc, unsigned max_dim,
    GLint width, GLint height, GLint depth, GLenum format, GLenum type,
    void * dest, GLboolean dimensions_in_reply )
d100 1
a100 1
    
d103 2
a104 2
    if ( dimensions_in_reply ) {
        width  = reply.pad3;
d106 8
a113 4
        depth  = reply.pad5;
	
	if ((height == 0) || (max_dim < 2)) { height = 1; }
	if ((depth  == 0) || (max_dim < 3)) { depth  = 1; }
d118 1
a118 1
        void * buf = Xmalloc( size );
d120 1
a120 1
        if ( buf == NULL ) {
d123 1
a123 2
        }
        else {
d127 1
a127 1
            if ( extra < 4 ) {
d141 1
a141 1
__glXSetupSingleRequest( __GLXcontext * gc, GLint sop, GLint cmdlen )
d143 2
a144 2
    xGLXSingleReq * req;
    Display * const dpy = gc->currentDpy;
d152 1
a152 1
    return (GLubyte *)(req) + sz_xGLXSingleReq;
d156 2
a157 1
__glXSetupVendorRequest( __GLXcontext * gc, GLint code, GLint vop, GLint cmdlen )
d159 2
a160 2
    xGLXVendorPrivateReq * req;
    Display * const dpy = gc->currentDpy;
d169 1
a169 1
    return (GLubyte *)(req) + sz_xGLXVendorPrivateReq;
d186 1
a186 1
generic_3_byte( GLint rop, const void * ptr )
d188 1
a188 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d192 1
a192 1
    (void) memcpy((void *)(gc->pc + 4), ptr, 4);
d194 3
a196 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d200 1
a200 1
generic_4_byte( GLint rop, const void * ptr )
d202 1
a202 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d206 1
a206 1
    (void) memcpy((void *)(gc->pc + 4), ptr, 4);
d208 3
a210 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d214 1
a214 1
generic_6_byte( GLint rop, const void * ptr )
d216 1
a216 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d220 1
a220 1
    (void) memcpy((void *)(gc->pc + 4), ptr, 8);
d222 3
a224 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d228 1
a228 1
generic_8_byte( GLint rop, const void * ptr )
d230 1
a230 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d234 1
a234 1
    (void) memcpy((void *)(gc->pc + 4), ptr, 8);
d236 3
a238 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d242 1
a242 1
generic_12_byte( GLint rop, const void * ptr )
d244 1
a244 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d248 1
a248 1
    (void) memcpy((void *)(gc->pc + 4), ptr, 12);
d250 3
a252 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d256 1
a256 1
generic_16_byte( GLint rop, const void * ptr )
d258 1
a258 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d262 1
a262 1
    (void) memcpy((void *)(gc->pc + 4), ptr, 16);
d264 3
a266 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d270 1
a270 1
generic_24_byte( GLint rop, const void * ptr )
d272 1
a272 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d276 1
a276 1
    (void) memcpy((void *)(gc->pc + 4), ptr, 24);
d278 3
a280 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d284 1
a284 1
generic_32_byte( GLint rop, const void * ptr )
d286 1
a286 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d290 1
a290 1
    (void) memcpy((void *)(gc->pc + 4), ptr, 32);
d292 3
a294 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d301 3
a303 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d305 1
d308 1
a308 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d310 1
a310 1
        XCBGlxNewList(c, gc->currentContextTag, list, mode);
d312 6
a317 4
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_NewList, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&list), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&mode), 4);
        UnlockDisplay(dpy); SyncHandle();
d327 3
a329 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d331 1
d334 1
a334 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d336 1
a336 1
        XCBGlxEndList(c, gc->currentContextTag);
d339 2
a340 1
        UnlockDisplay(dpy); SyncHandle();
d350 1
a350 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d353 1
a353 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&list), 4);
d355 3
a357 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d364 1
a364 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d367 4
d373 1
a373 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d377 4
a380 3
            (void) memcpy((void *)(gc->pc + 4), (void *)(&n), 4);
            (void) memcpy((void *)(gc->pc + 8), (void *)(&type), 4);
            (void) memcpy((void *)(gc->pc + 12), (void *)(lists), (compsize * n));
d382 4
a385 3
            if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d388 5
a392 5
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 8), (void *)(&n), 4);
            (void) memcpy((void *)(pc + 12), (void *)(&type), 4);
d402 3
a404 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d406 1
d409 1
a409 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d411 1
a411 1
        XCBGlxDeleteLists(c, gc->currentContextTag, list, range);
d413 6
a418 4
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_DeleteLists, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&list), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&range), 4);
        UnlockDisplay(dpy); SyncHandle();
d428 2
a429 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d431 1
d433 1
d436 1
a436 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d438 5
a442 1
        XCBGlxGenListsRep *reply = XCBGlxGenListsReply(c, XCBGlxGenLists(c, gc->currentContextTag, range), NULL);
d446 3
a448 2
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GenLists, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&range), 4);
d450 2
a451 1
        UnlockDisplay(dpy); SyncHandle();
d461 1
a461 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d464 1
a464 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&base), 4);
d466 3
a468 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d475 1
a475 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d478 1
a478 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
d480 3
a482 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d487 8
a494 4
__indirect_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (bitmap != NULL) ? __glImageSize(width, height, 1, GL_COLOR_INDEX, GL_BITMAP, 0) : 0;
d498 1
a498 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d502 6
a507 6
            (void) memcpy((void *)(gc->pc + 24), (void *)(&width), 4);
            (void) memcpy((void *)(gc->pc + 28), (void *)(&height), 4);
            (void) memcpy((void *)(gc->pc + 32), (void *)(&xorig), 4);
            (void) memcpy((void *)(gc->pc + 36), (void *)(&yorig), 4);
            (void) memcpy((void *)(gc->pc + 40), (void *)(&xmove), 4);
            (void) memcpy((void *)(gc->pc + 44), (void *)(&ymove), 4);
d509 5
a513 1
                (*gc->fillImage)(gc, 2, width, height, 1, GL_COLOR_INDEX, GL_BITMAP, bitmap, gc->pc + 48, gc->pc + 4);
d515 3
a517 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_2D, default_pixel_store_2D_size );
d519 1
a519 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d522 12
a533 10
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 28), (void *)(&width), 4);
            (void) memcpy((void *)(pc + 32), (void *)(&height), 4);
            (void) memcpy((void *)(pc + 36), (void *)(&xorig), 4);
            (void) memcpy((void *)(pc + 40), (void *)(&yorig), 4);
            (void) memcpy((void *)(pc + 44), (void *)(&xmove), 4);
            (void) memcpy((void *)(pc + 48), (void *)(&ymove), 4);
            __glXSendLargeImage(gc, compsize, 2, width, height, 1, GL_COLOR_INDEX, GL_BITMAP, bitmap, pc + 52, pc + 8);
d542 1
a542 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d545 3
a547 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 1);
    (void) memcpy((void *)(gc->pc + 5), (void *)(&green), 1);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&blue), 1);
d549 3
a551 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d556 1
a556 1
__indirect_glColor3bv(const GLbyte * v)
d558 1
a558 1
    generic_3_byte( X_GLrop_Color3bv, v );
d565 1
a565 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d568 3
a570 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&green), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&blue), 8);
d572 3
a574 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d581 1
a581 1
    generic_24_byte( X_GLrop_Color3dv, v );
d588 1
a588 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d591 3
a593 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
d595 3
a597 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d604 1
a604 1
    generic_12_byte( X_GLrop_Color3fv, v );
d611 1
a611 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d614 3
a616 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
d618 3
a620 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d627 1
a627 1
    generic_12_byte( X_GLrop_Color3iv, v );
d634 1
a634 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d637 3
a639 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&green), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&blue), 2);
d641 3
a643 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d650 1
a650 1
    generic_6_byte( X_GLrop_Color3sv, v );
d657 1
a657 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d660 3
a662 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 1);
    (void) memcpy((void *)(gc->pc + 5), (void *)(&green), 1);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&blue), 1);
d664 3
a666 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d671 1
a671 1
__indirect_glColor3ubv(const GLubyte * v)
d673 1
a673 1
    generic_3_byte( X_GLrop_Color3ubv, v );
d680 1
a680 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d683 3
a685 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
d687 3
a689 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d696 1
a696 1
    generic_12_byte( X_GLrop_Color3uiv, v );
d703 1
a703 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d706 3
a708 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&green), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&blue), 2);
d710 3
a712 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d719 1
a719 1
    generic_6_byte( X_GLrop_Color3usv, v );
d726 1
a726 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d729 4
a732 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 1);
    (void) memcpy((void *)(gc->pc + 5), (void *)(&green), 1);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&blue), 1);
    (void) memcpy((void *)(gc->pc + 7), (void *)(&alpha), 1);
d734 3
a736 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d741 1
a741 1
__indirect_glColor4bv(const GLbyte * v)
d743 1
a743 1
    generic_4_byte( X_GLrop_Color4bv, v );
d748 2
a749 1
__indirect_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
d751 1
a751 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d754 4
a757 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&green), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&blue), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&alpha), 8);
d759 3
a761 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d768 1
a768 1
    generic_32_byte( X_GLrop_Color4dv, v );
d775 1
a775 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d778 4
a781 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&alpha), 4);
d783 3
a785 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d792 1
a792 1
    generic_16_byte( X_GLrop_Color4fv, v );
d799 1
a799 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d802 4
a805 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&alpha), 4);
d807 3
a809 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d816 1
a816 1
    generic_16_byte( X_GLrop_Color4iv, v );
d823 1
a823 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d826 4
a829 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&green), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&blue), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&alpha), 2);
d831 3
a833 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d840 1
a840 1
    generic_8_byte( X_GLrop_Color4sv, v );
d847 1
a847 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d850 4
a853 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 1);
    (void) memcpy((void *)(gc->pc + 5), (void *)(&green), 1);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&blue), 1);
    (void) memcpy((void *)(gc->pc + 7), (void *)(&alpha), 1);
d855 3
a857 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d862 1
a862 1
__indirect_glColor4ubv(const GLubyte * v)
d864 1
a864 1
    generic_4_byte( X_GLrop_Color4ubv, v );
d871 1
a871 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d874 4
a877 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&alpha), 4);
d879 3
a881 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d888 1
a888 1
    generic_16_byte( X_GLrop_Color4uiv, v );
d893 2
a894 1
__indirect_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
d896 1
a896 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d899 4
a902 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&green), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&blue), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&alpha), 2);
d904 3
a906 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d913 1
a913 1
    generic_8_byte( X_GLrop_Color4usv, v );
d920 1
a920 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d923 1
a923 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&flag), 1);
d925 3
a927 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d934 1
a934 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d937 1
a937 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(flag), 1);
d939 3
a941 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d948 1
a948 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d952 3
a954 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d961 1
a961 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d964 1
a964 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&c), 8);
d966 3
a968 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d975 1
a975 1
    generic_8_byte( X_GLrop_Indexdv, c );
d982 1
a982 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d985 1
a985 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&c), 4);
d987 3
a989 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d996 1
a996 1
    generic_4_byte( X_GLrop_Indexfv, c );
d1003 1
a1003 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1006 1
a1006 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&c), 4);
d1008 3
a1010 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1017 1
a1017 1
    generic_4_byte( X_GLrop_Indexiv, c );
d1024 1
a1024 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1027 1
a1027 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&c), 2);
d1029 3
a1031 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1038 1
a1038 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1041 1
a1041 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(c), 2);
d1043 3
a1045 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1052 1
a1052 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1055 3
a1057 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&nx), 1);
    (void) memcpy((void *)(gc->pc + 5), (void *)(&ny), 1);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&nz), 1);
d1059 3
a1061 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1066 1
a1066 1
__indirect_glNormal3bv(const GLbyte * v)
d1068 1
a1068 1
    generic_3_byte( X_GLrop_Normal3bv, v );
d1075 1
a1075 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1078 3
a1080 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&nx), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&ny), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&nz), 8);
d1082 3
a1084 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1091 1
a1091 1
    generic_24_byte( X_GLrop_Normal3dv, v );
d1098 1
a1098 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1101 3
a1103 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&nx), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&ny), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&nz), 4);
d1105 3
a1107 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1114 1
a1114 1
    generic_12_byte( X_GLrop_Normal3fv, v );
d1121 1
a1121 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1124 3
a1126 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&nx), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&ny), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&nz), 4);
d1128 3
a1130 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1137 1
a1137 1
    generic_12_byte( X_GLrop_Normal3iv, v );
d1144 1
a1144 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1147 3
a1149 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&nx), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&ny), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&nz), 2);
d1151 3
a1153 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1160 1
a1160 1
    generic_6_byte( X_GLrop_Normal3sv, v );
d1167 1
a1167 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1170 2
a1171 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
d1173 3
a1175 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1182 1
a1182 1
    generic_16_byte( X_GLrop_RasterPos2dv, v );
d1189 1
a1189 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1192 2
a1193 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
d1195 3
a1197 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1204 1
a1204 1
    generic_8_byte( X_GLrop_RasterPos2fv, v );
d1211 1
a1211 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1214 2
a1215 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
d1217 3
a1219 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1226 1
a1226 1
    generic_8_byte( X_GLrop_RasterPos2iv, v );
d1233 1
a1233 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1236 2
a1237 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&y), 2);
d1239 3
a1241 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1248 1
a1248 1
    generic_4_byte( X_GLrop_RasterPos2sv, v );
d1255 1
a1255 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1258 3
a1260 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 8);
d1262 3
a1264 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1271 1
a1271 1
    generic_24_byte( X_GLrop_RasterPos3dv, v );
d1278 1
a1278 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1281 3
a1283 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
d1285 3
a1287 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1294 1
a1294 1
    generic_12_byte( X_GLrop_RasterPos3fv, v );
d1301 1
a1301 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1304 3
a1306 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
d1308 3
a1310 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1317 1
a1317 1
    generic_12_byte( X_GLrop_RasterPos3iv, v );
d1324 1
a1324 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1327 3
a1329 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&y), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&z), 2);
d1331 3
a1333 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1340 1
a1340 1
    generic_6_byte( X_GLrop_RasterPos3sv, v );
d1347 1
a1347 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1350 4
a1353 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&w), 8);
d1355 3
a1357 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1364 1
a1364 1
    generic_32_byte( X_GLrop_RasterPos4dv, v );
d1371 1
a1371 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1374 4
a1377 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&w), 4);
d1379 3
a1381 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1388 1
a1388 1
    generic_16_byte( X_GLrop_RasterPos4fv, v );
d1395 1
a1395 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1398 4
a1401 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&w), 4);
d1403 3
a1405 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1412 1
a1412 1
    generic_16_byte( X_GLrop_RasterPos4iv, v );
d1419 1
a1419 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1422 4
a1425 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&y), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&z), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&w), 2);
d1427 3
a1429 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1436 1
a1436 1
    generic_8_byte( X_GLrop_RasterPos4sv, v );
d1443 1
a1443 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1446 4
a1449 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x1), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y1), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&x2), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&y2), 8);
d1451 3
a1453 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1460 1
a1460 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1463 2
a1464 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(v1), 16);
    (void) memcpy((void *)(gc->pc + 20), (void *)(v2), 16);
d1466 3
a1468 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1475 1
a1475 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1478 4
a1481 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x1), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y1), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x2), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y2), 4);
d1483 3
a1485 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1492 1
a1492 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1495 2
a1496 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(v1), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(v2), 8);
d1498 3
a1500 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1507 1
a1507 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1510 4
a1513 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x1), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y1), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x2), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y2), 4);
d1515 3
a1517 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1524 1
a1524 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1527 2
a1528 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(v1), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(v2), 8);
d1530 3
a1532 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1539 1
a1539 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1542 4
a1545 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x1), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&y1), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x2), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&y2), 2);
d1547 3
a1549 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1556 1
a1556 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1559 2
a1560 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(v1), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v2), 4);
d1562 3
a1564 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1571 1
a1571 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1574 1
a1574 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 8);
d1576 3
a1578 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1585 1
a1585 1
    generic_8_byte( X_GLrop_TexCoord1dv, v );
d1592 1
a1592 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1595 1
a1595 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
d1597 3
a1599 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1606 1
a1606 1
    generic_4_byte( X_GLrop_TexCoord1fv, v );
d1613 1
a1613 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1616 1
a1616 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
d1618 3
a1620 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1627 1
a1627 1
    generic_4_byte( X_GLrop_TexCoord1iv, v );
d1634 1
a1634 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1637 1
a1637 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 2);
d1639 3
a1641 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1648 1
a1648 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1651 1
a1651 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(v), 2);
d1653 3
a1655 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1662 1
a1662 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1665 2
a1666 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 8);
d1668 3
a1670 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1677 1
a1677 1
    generic_16_byte( X_GLrop_TexCoord2dv, v );
d1684 1
a1684 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1687 2
a1688 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&t), 4);
d1690 3
a1692 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1699 1
a1699 1
    generic_8_byte( X_GLrop_TexCoord2fv, v );
d1706 1
a1706 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1709 2
a1710 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&t), 4);
d1712 3
a1714 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1721 1
a1721 1
    generic_8_byte( X_GLrop_TexCoord2iv, v );
d1728 1
a1728 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1731 2
a1732 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&t), 2);
d1734 3
a1736 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1743 1
a1743 1
    generic_4_byte( X_GLrop_TexCoord2sv, v );
d1750 1
a1750 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1753 3
a1755 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&r), 8);
d1757 3
a1759 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1766 1
a1766 1
    generic_24_byte( X_GLrop_TexCoord3dv, v );
d1773 1
a1773 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1776 3
a1778 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&t), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&r), 4);
d1780 3
a1782 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1789 1
a1789 1
    generic_12_byte( X_GLrop_TexCoord3fv, v );
d1796 1
a1796 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1799 3
a1801 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&t), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&r), 4);
d1803 3
a1805 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1812 1
a1812 1
    generic_12_byte( X_GLrop_TexCoord3iv, v );
d1819 1
a1819 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1822 3
a1824 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&t), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&r), 2);
d1826 3
a1828 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1835 1
a1835 1
    generic_6_byte( X_GLrop_TexCoord3sv, v );
d1842 1
a1842 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1845 4
a1848 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&r), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&q), 8);
d1850 3
a1852 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1859 1
a1859 1
    generic_32_byte( X_GLrop_TexCoord4dv, v );
d1866 1
a1866 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1869 4
a1872 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&t), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&r), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&q), 4);
d1874 3
a1876 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1883 1
a1883 1
    generic_16_byte( X_GLrop_TexCoord4fv, v );
d1890 1
a1890 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1893 4
a1896 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&t), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&r), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&q), 4);
d1898 3
a1900 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1907 1
a1907 1
    generic_16_byte( X_GLrop_TexCoord4iv, v );
d1914 1
a1914 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1917 4
a1920 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&t), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&r), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&q), 2);
d1922 3
a1924 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1931 1
a1931 1
    generic_8_byte( X_GLrop_TexCoord4sv, v );
d1938 1
a1938 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1941 2
a1942 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
d1944 3
a1946 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1953 1
a1953 1
    generic_16_byte( X_GLrop_Vertex2dv, v );
d1960 1
a1960 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1963 2
a1964 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
d1966 3
a1968 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1975 1
a1975 1
    generic_8_byte( X_GLrop_Vertex2fv, v );
d1982 1
a1982 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d1985 2
a1986 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
d1988 3
a1990 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d1997 1
a1997 1
    generic_8_byte( X_GLrop_Vertex2iv, v );
d2004 1
a2004 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2007 2
a2008 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&y), 2);
d2010 3
a2012 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2019 1
a2019 1
    generic_4_byte( X_GLrop_Vertex2sv, v );
d2026 1
a2026 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2029 3
a2031 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 8);
d2033 3
a2035 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2042 1
a2042 1
    generic_24_byte( X_GLrop_Vertex3dv, v );
d2049 1
a2049 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2052 3
a2054 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
d2056 3
a2058 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2065 1
a2065 1
    generic_12_byte( X_GLrop_Vertex3fv, v );
d2072 1
a2072 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2075 3
a2077 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
d2079 3
a2081 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2088 1
a2088 1
    generic_12_byte( X_GLrop_Vertex3iv, v );
d2095 1
a2095 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2098 3
a2100 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&y), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&z), 2);
d2102 3
a2104 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2111 1
a2111 1
    generic_6_byte( X_GLrop_Vertex3sv, v );
d2118 1
a2118 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2121 4
a2124 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&w), 8);
d2126 3
a2128 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2135 1
a2135 1
    generic_32_byte( X_GLrop_Vertex4dv, v );
d2142 1
a2142 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2145 4
a2148 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&w), 4);
d2150 3
a2152 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2159 1
a2159 1
    generic_16_byte( X_GLrop_Vertex4fv, v );
d2166 1
a2166 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2169 4
a2172 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&w), 4);
d2174 3
a2176 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2183 1
a2183 1
    generic_16_byte( X_GLrop_Vertex4iv, v );
d2190 1
a2190 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2193 4
a2196 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&y), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&z), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&w), 2);
d2198 3
a2200 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2207 1
a2207 1
    generic_8_byte( X_GLrop_Vertex4sv, v );
d2214 1
a2214 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2217 2
a2218 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(equation), 32);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&plane), 4);
d2220 3
a2222 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2229 1
a2229 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2232 2
a2233 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&face), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&mode), 4);
d2235 3
a2237 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2244 1
a2244 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2247 1
a2247 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
d2249 3
a2251 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2258 1
a2258 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2261 2
a2262 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&param), 4);
d2264 3
a2266 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2273 1
a2273 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2277 2
a2278 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(params), (compsize * 4));
d2280 3
a2282 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2289 1
a2289 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2292 2
a2293 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&param), 4);
d2295 3
a2297 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2304 1
a2304 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2308 2
a2309 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(params), (compsize * 4));
d2311 3
a2313 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2320 1
a2320 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2323 1
a2323 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
d2325 3
a2327 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2334 1
a2334 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2337 2
a2338 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&mode), 4);
d2340 3
a2342 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2349 1
a2349 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2352 3
a2354 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&light), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2356 3
a2358 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2365 1
a2365 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2369 3
a2371 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&light), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2373 3
a2375 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2382 1
a2382 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2385 3
a2387 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&light), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2389 3
a2391 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2398 1
a2398 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2402 3
a2404 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&light), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2406 3
a2408 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2415 1
a2415 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2418 2
a2419 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&param), 4);
d2421 3
a2423 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2430 1
a2430 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2434 2
a2435 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(params), (compsize * 4));
d2437 3
a2439 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2446 1
a2446 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2449 2
a2450 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&param), 4);
d2452 3
a2454 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2461 1
a2461 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2465 2
a2466 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(params), (compsize * 4));
d2468 3
a2470 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2477 1
a2477 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2480 2
a2481 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&factor), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pattern), 2);
d2483 3
a2485 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2492 1
a2492 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2495 1
a2495 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&width), 4);
d2497 3
a2499 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2506 1
a2506 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2509 3
a2511 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&face), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2513 3
a2515 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2522 1
a2522 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2526 3
a2528 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&face), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2530 3
a2532 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2539 1
a2539 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2542 3
a2544 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&face), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2546 3
a2548 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2555 1
a2555 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2559 3
a2561 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&face), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2563 3
a2565 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2572 1
a2572 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2575 1
a2575 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&size), 4);
d2577 3
a2579 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2586 1
a2586 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2589 2
a2590 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&face), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&mode), 4);
d2592 3
a2594 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2599 1
a2599 1
__indirect_glPolygonStipple(const GLubyte * mask)
d2601 4
a2604 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (mask != NULL) ? __glImageSize(32, 32, 1, GL_COLOR_INDEX, GL_BITMAP, 0) : 0;
d2608 5
a2612 1
        (*gc->fillImage)(gc, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP, mask, gc->pc + 24, gc->pc + 4);
d2614 3
a2616 2
    else {
        (void) memcpy( gc->pc + 4, default_pixel_store_2D, default_pixel_store_2D_size );
a2617 2
    gc->pc += cmdlen;
    if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2624 1
a2624 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2627 4
a2630 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&height), 4);
d2632 3
a2634 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2641 1
a2641 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2644 1
a2644 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
d2646 3
a2648 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2655 1
a2655 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2658 3
a2660 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2662 3
a2664 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2669 2
a2670 1
__indirect_glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)
d2672 1
a2672 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2676 3
a2678 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2680 3
a2682 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2689 1
a2689 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2692 3
a2694 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2696 3
a2698 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2705 1
a2705 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2709 3
a2711 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2713 3
a2715 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2719 8
a2726 4
__glx_TexImage_1D2D( unsigned opcode, unsigned dim, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = __glImageSize(width, height, 1, format, type, target);
d2730 1
a2730 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d2734 9
a2742 8
            (void) memcpy((void *)(gc->pc + 24), (void *)(&target), 4);
            (void) memcpy((void *)(gc->pc + 28), (void *)(&level), 4);
            (void) memcpy((void *)(gc->pc + 32), (void *)(&internalformat), 4);
            (void) memcpy((void *)(gc->pc + 36), (void *)(&width), 4);
            (void) memcpy((void *)(gc->pc + 40), (void *)(&height), 4);
            (void) memcpy((void *)(gc->pc + 44), (void *)(&border), 4);
            (void) memcpy((void *)(gc->pc + 48), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 52), (void *)(&type), 4);
d2744 5
a2748 1
                (*gc->fillImage)(gc, dim, width, height, 1, format, type, pixels, gc->pc + 56, gc->pc + 4);
d2750 3
a2752 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_2D, default_pixel_store_2D_size );
d2754 1
a2754 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d2757 13
a2769 12
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 28), (void *)(&target), 4);
            (void) memcpy((void *)(pc + 32), (void *)(&level), 4);
            (void) memcpy((void *)(pc + 36), (void *)(&internalformat), 4);
            (void) memcpy((void *)(pc + 40), (void *)(&width), 4);
            (void) memcpy((void *)(pc + 44), (void *)(&height), 4);
            (void) memcpy((void *)(pc + 48), (void *)(&border), 4);
            (void) memcpy((void *)(pc + 52), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 56), (void *)(&type), 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format, type, pixels, pc + 60, pc + 8);
d2776 3
a2778 1
__indirect_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
d2780 2
a2781 1
    __glx_TexImage_1D2D(X_GLrop_TexImage1D, 1, target, level, internalformat, width, 1, border, format, type, pixels );
d2786 3
a2788 1
__indirect_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
d2790 2
a2791 1
    __glx_TexImage_1D2D(X_GLrop_TexImage2D, 2, target, level, internalformat, width, height, border, format, type, pixels );
d2798 1
a2798 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2801 3
a2803 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2805 3
a2807 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2814 1
a2814 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2818 3
a2820 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2822 3
a2824 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2831 1
a2831 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2834 3
a2836 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2838 3
a2840 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2847 1
a2847 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2851 3
a2853 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2855 3
a2857 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2864 1
a2864 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2867 3
a2869 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&param), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&coord), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&pname), 4);
d2871 3
a2873 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2880 1
a2880 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2884 3
a2886 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&coord), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 8));
d2888 3
a2890 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2897 1
a2897 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2900 3
a2902 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&coord), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2904 3
a2906 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2913 1
a2913 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2917 3
a2919 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&coord), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2921 3
a2923 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2930 1
a2930 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2933 3
a2935 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&coord), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&param), 4);
d2937 3
a2939 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2946 1
a2946 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2950 3
a2952 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&coord), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d2954 3
a2956 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2963 1
a2963 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2967 3
a2969 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2976 1
a2976 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2979 1
a2979 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&name), 4);
d2981 3
a2983 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d2990 1
a2990 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d2993 1
a2993 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&token), 4);
d2995 3
a2997 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3004 1
a3004 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3008 3
a3010 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3017 1
a3017 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3020 1
a3020 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&name), 4);
d3022 3
a3024 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3031 1
a3031 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3034 1
a3034 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
d3036 3
a3038 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3045 1
a3045 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3048 1
a3048 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mask), 4);
d3050 3
a3052 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3057 2
a3058 1
__indirect_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
d3060 1
a3060 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3063 4
a3066 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&alpha), 4);
d3068 3
a3070 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3077 1
a3077 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3080 1
a3080 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&c), 4);
d3082 3
a3084 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3089 2
a3090 1
__indirect_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
d3092 1
a3092 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3095 4
a3098 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&alpha), 4);
d3100 3
a3102 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3109 1
a3109 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3112 1
a3112 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 4);
d3114 3
a3116 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3123 1
a3123 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3126 1
a3126 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&depth), 8);
d3128 3
a3130 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3137 1
a3137 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3140 1
a3140 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mask), 4);
d3142 3
a3144 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3149 2
a3150 1
__indirect_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
d3152 1
a3152 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3155 4
a3158 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 1);
    (void) memcpy((void *)(gc->pc + 5), (void *)(&green), 1);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&blue), 1);
    (void) memcpy((void *)(gc->pc + 7), (void *)(&alpha), 1);
d3160 3
a3162 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3169 1
a3169 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3172 1
a3172 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&flag), 1);
d3174 3
a3176 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3183 1
a3183 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3186 1
a3186 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mask), 4);
d3188 3
a3190 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3197 1
a3197 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3200 2
a3201 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&op), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&value), 4);
d3203 3
a3205 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3212 1
a3212 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3216 3
a3218 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3225 1
a3225 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3228 1
a3228 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mask), 4);
d3230 3
a3232 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3239 1
a3239 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3242 3
a3244 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&u1), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&u2), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&un), 4);
d3246 3
a3248 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3255 1
a3255 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3258 3
a3260 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&un), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&u1), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&u2), 4);
d3262 3
a3264 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3269 2
a3270 1
__indirect_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
d3272 1
a3272 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3275 6
a3280 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&u1), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&u2), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&v1), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&v2), 8);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&un), 4);
    (void) memcpy((void *)(gc->pc + 40), (void *)(&vn), 4);
d3282 3
a3284 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3289 2
a3290 1
__indirect_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
d3292 1
a3292 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3295 6
a3300 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&un), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&u1), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&u2), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&vn), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&v1), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&v2), 4);
d3302 3
a3304 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3311 1
a3311 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3314 1
a3314 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&u), 8);
d3316 3
a3318 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3325 1
a3325 1
    generic_8_byte( X_GLrop_EvalCoord1dv, u );
d3332 1
a3332 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3335 1
a3335 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&u), 4);
d3337 3
a3339 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3346 1
a3346 1
    generic_4_byte( X_GLrop_EvalCoord1fv, u );
d3353 1
a3353 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3356 2
a3357 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&u), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&v), 8);
d3359 3
a3361 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3368 1
a3368 1
    generic_16_byte( X_GLrop_EvalCoord2dv, u );
d3375 1
a3375 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3378 2
a3379 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&u), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&v), 4);
d3381 3
a3383 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3390 1
a3390 1
    generic_8_byte( X_GLrop_EvalCoord2fv, u );
d3397 1
a3397 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3400 3
a3402 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&i1), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&i2), 4);
d3404 3
a3406 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3413 1
a3413 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3416 1
a3416 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&i), 4);
d3418 3
a3420 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3427 1
a3427 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3430 5
a3434 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&i1), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&i2), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&j1), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&j2), 4);
d3436 3
a3438 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3445 1
a3445 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3448 2
a3449 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&i), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&j), 4);
d3451 3
a3453 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3460 1
a3460 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3463 2
a3464 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&func), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&ref), 4);
d3466 3
a3468 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3475 1
a3475 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3478 2
a3479 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&sfactor), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&dfactor), 4);
d3481 3
a3483 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3490 1
a3490 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3493 1
a3493 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&opcode), 4);
d3495 3
a3497 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3504 1
a3504 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3507 3
a3509 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&func), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&ref), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&mask), 4);
d3511 3
a3513 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3520 1
a3520 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3523 3
a3525 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&fail), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&zfail), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&zpass), 4);
d3527 3
a3529 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3536 1
a3536 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3539 1
a3539 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&func), 4);
d3541 3
a3543 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3550 1
a3550 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3553 2
a3554 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&xfactor), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&yfactor), 4);
d3556 3
a3558 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3565 1
a3565 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3568 2
a3569 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&param), 4);
d3571 3
a3573 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3580 1
a3580 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3583 2
a3584 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&param), 4);
d3586 3
a3588 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3595 1
a3595 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3597 4
d3603 1
a3603 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d3607 4
a3610 3
            (void) memcpy((void *)(gc->pc + 4), (void *)(&map), 4);
            (void) memcpy((void *)(gc->pc + 8), (void *)(&mapsize), 4);
            (void) memcpy((void *)(gc->pc + 12), (void *)(values), (mapsize * 4));
d3612 4
a3615 3
            if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d3618 5
a3622 5
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 8), (void *)(&map), 4);
            (void) memcpy((void *)(pc + 12), (void *)(&mapsize), 4);
d3632 1
a3632 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3634 4
d3640 1
a3640 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d3644 4
a3647 3
            (void) memcpy((void *)(gc->pc + 4), (void *)(&map), 4);
            (void) memcpy((void *)(gc->pc + 8), (void *)(&mapsize), 4);
            (void) memcpy((void *)(gc->pc + 12), (void *)(values), (mapsize * 4));
d3649 4
a3652 3
            if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d3655 5
a3659 5
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 8), (void *)(&map), 4);
            (void) memcpy((void *)(pc + 12), (void *)(&mapsize), 4);
d3669 1
a3669 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3671 4
d3677 1
a3677 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d3681 4
a3684 3
            (void) memcpy((void *)(gc->pc + 4), (void *)(&map), 4);
            (void) memcpy((void *)(gc->pc + 8), (void *)(&mapsize), 4);
            (void) memcpy((void *)(gc->pc + 12), (void *)(values), (mapsize * 2));
d3686 4
a3689 3
            if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d3692 5
a3696 5
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 8), (void *)(&map), 4);
            (void) memcpy((void *)(pc + 12), (void *)(&mapsize), 4);
d3706 1
a3706 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3709 1
a3709 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
d3711 3
a3713 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3718 2
a3719 1
__indirect_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
d3721 1
a3721 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d3724 5
a3728 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&height), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&type), 4);
d3730 3
a3732 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d3737 2
a3738 1
__indirect_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels)
d3740 4
a3743 3
    __GLXcontext * const gc = __glXGetCurrentContext();
    const __GLXattribute * const state = gc->client_state_private;
    Display * const dpy = gc->currentDpy;
d3745 1
d3748 1
a3748 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d3750 29
a3778 15
        XCBGlxReadPixelsRep *reply = XCBGlxReadPixelsReply(c, XCBGlxReadPixels(c, gc->currentContextTag, x, y, width, height, format, type, state->storePack.swapEndian, 0), NULL);
        (void)memcpy(pixels, XCBGlxReadPixelsData(reply), XCBGlxReadPixelsDataLength(reply) * sizeof(GLvoid));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_ReadPixels, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&x), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&y), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&width), 4);
        (void) memcpy((void *)(pc + 12), (void *)(&height), 4);
        (void) memcpy((void *)(pc + 16), (void *)(&format), 4);
        (void) memcpy((void *)(pc + 20), (void *)(&type), 4);
        *(int32_t *)(pc + 24) = 0;
        * (int8_t *)(pc + 24) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 2, width, height, 1, format, type, pixels, GL_FALSE);
        UnlockDisplay(dpy); SyncHandle();
d3786 2
a3787 1
__indirect_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels)
d3789 4
a3792 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (pixels != NULL) ? __glImageSize(width, height, 1, format, type, 0) : 0;
d3796 1
a3796 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d3800 4
a3803 4
            (void) memcpy((void *)(gc->pc + 24), (void *)(&width), 4);
            (void) memcpy((void *)(gc->pc + 28), (void *)(&height), 4);
            (void) memcpy((void *)(gc->pc + 32), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 36), (void *)(&type), 4);
d3805 5
a3809 1
                (*gc->fillImage)(gc, 2, width, height, 1, format, type, pixels, gc->pc + 40, gc->pc + 4);
d3811 3
a3813 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_2D, default_pixel_store_2D_size );
d3815 1
a3815 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d3818 9
a3826 8
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 28), (void *)(&width), 4);
            (void) memcpy((void *)(pc + 32), (void *)(&height), 4);
            (void) memcpy((void *)(pc + 36), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 40), (void *)(&type), 4);
            __glXSendLargeImage(gc, compsize, 2, width, height, 1, format, type, pixels, pc + 44, pc + 8);
d3835 3
a3837 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d3839 1
d3842 1
a3842 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d3844 14
a3857 6
        XCBGlxGetClipPlaneRep *reply = XCBGlxGetClipPlaneReply(c, XCBGlxGetClipPlane(c, gc->currentContextTag, plane), NULL);
        (void)memcpy(equation, XCBGlxGetClipPlaneData(reply), XCBGlxGetClipPlaneDataLength(reply) * sizeof(GLdouble));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetClipPlane, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&plane), 4);
d3859 2
a3860 1
        UnlockDisplay(dpy); SyncHandle();
d3870 3
a3872 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d3874 1
d3877 1
a3877 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d3879 9
a3887 3
        XCBGlxGetLightfvRep *reply = XCBGlxGetLightfvReply(c, XCBGlxGetLightfv(c, gc->currentContextTag, light, pname), NULL);
        if (XCBGlxGetLightfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d3889 3
a3891 1
        (void)memcpy(params, XCBGlxGetLightfvData(reply), XCBGlxGetLightfvDataLength(reply) * sizeof(GLfloat));
d3894 4
a3897 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetLightfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&light), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d3899 2
a3900 1
        UnlockDisplay(dpy); SyncHandle();
d3910 3
a3912 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d3914 1
d3917 1
a3917 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d3919 9
a3927 3
        XCBGlxGetLightivRep *reply = XCBGlxGetLightivReply(c, XCBGlxGetLightiv(c, gc->currentContextTag, light, pname), NULL);
        if (XCBGlxGetLightivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d3929 3
a3931 1
        (void)memcpy(params, XCBGlxGetLightivData(reply), XCBGlxGetLightivDataLength(reply) * sizeof(GLint));
d3934 4
a3937 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetLightiv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&light), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d3939 2
a3940 1
        UnlockDisplay(dpy); SyncHandle();
d3950 3
a3952 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d3954 1
d3957 1
a3957 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d3959 7
a3965 3
        XCBGlxGetMapdvRep *reply = XCBGlxGetMapdvReply(c, XCBGlxGetMapdv(c, gc->currentContextTag, target, query), NULL);
        if (XCBGlxGetMapdvDataLength(reply) == 0)
            (void)memcpy(v, &reply->datum, sizeof(reply->datum));
d3967 3
a3969 1
        (void)memcpy(v, XCBGlxGetMapdvData(reply), XCBGlxGetMapdvDataLength(reply) * sizeof(GLdouble));
d3972 4
a3975 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetMapdv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&query), 4);
d3977 2
a3978 1
        UnlockDisplay(dpy); SyncHandle();
d3988 3
a3990 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d3992 1
d3995 1
a3995 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d3997 7
a4003 3
        XCBGlxGetMapfvRep *reply = XCBGlxGetMapfvReply(c, XCBGlxGetMapfv(c, gc->currentContextTag, target, query), NULL);
        if (XCBGlxGetMapfvDataLength(reply) == 0)
            (void)memcpy(v, &reply->datum, sizeof(reply->datum));
d4005 3
a4007 1
        (void)memcpy(v, XCBGlxGetMapfvData(reply), XCBGlxGetMapfvDataLength(reply) * sizeof(GLfloat));
d4010 4
a4013 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetMapfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&query), 4);
d4015 2
a4016 1
        UnlockDisplay(dpy); SyncHandle();
d4026 3
a4028 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4030 1
d4033 1
a4033 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4035 7
a4041 3
        XCBGlxGetMapivRep *reply = XCBGlxGetMapivReply(c, XCBGlxGetMapiv(c, gc->currentContextTag, target, query), NULL);
        if (XCBGlxGetMapivDataLength(reply) == 0)
            (void)memcpy(v, &reply->datum, sizeof(reply->datum));
d4043 3
a4045 1
        (void)memcpy(v, XCBGlxGetMapivData(reply), XCBGlxGetMapivDataLength(reply) * sizeof(GLint));
d4048 4
a4051 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetMapiv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&query), 4);
d4053 2
a4054 1
        UnlockDisplay(dpy); SyncHandle();
d4064 3
a4066 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4068 1
d4071 1
a4071 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4073 9
a4081 3
        XCBGlxGetMaterialfvRep *reply = XCBGlxGetMaterialfvReply(c, XCBGlxGetMaterialfv(c, gc->currentContextTag, face, pname), NULL);
        if (XCBGlxGetMaterialfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4083 3
a4085 1
        (void)memcpy(params, XCBGlxGetMaterialfvData(reply), XCBGlxGetMaterialfvDataLength(reply) * sizeof(GLfloat));
d4088 4
a4091 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetMaterialfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&face), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4093 2
a4094 1
        UnlockDisplay(dpy); SyncHandle();
d4104 3
a4106 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4108 1
d4111 1
a4111 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4113 9
a4121 3
        XCBGlxGetMaterialivRep *reply = XCBGlxGetMaterialivReply(c, XCBGlxGetMaterialiv(c, gc->currentContextTag, face, pname), NULL);
        if (XCBGlxGetMaterialivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4123 3
a4125 1
        (void)memcpy(params, XCBGlxGetMaterialivData(reply), XCBGlxGetMaterialivDataLength(reply) * sizeof(GLint));
d4128 4
a4131 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetMaterialiv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&face), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4133 2
a4134 1
        UnlockDisplay(dpy); SyncHandle();
d4144 3
a4146 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4148 1
d4151 1
a4151 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4153 8
a4160 3
        XCBGlxGetPixelMapfvRep *reply = XCBGlxGetPixelMapfvReply(c, XCBGlxGetPixelMapfv(c, gc->currentContextTag, map), NULL);
        if (XCBGlxGetPixelMapfvDataLength(reply) == 0)
            (void)memcpy(values, &reply->datum, sizeof(reply->datum));
d4162 3
a4164 1
        (void)memcpy(values, XCBGlxGetPixelMapfvData(reply), XCBGlxGetPixelMapfvDataLength(reply) * sizeof(GLfloat));
d4167 3
a4169 2
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&map), 4);
d4171 2
a4172 1
        UnlockDisplay(dpy); SyncHandle();
d4182 3
a4184 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4186 1
d4189 1
a4189 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4191 9
a4199 3
        XCBGlxGetPixelMapuivRep *reply = XCBGlxGetPixelMapuivReply(c, XCBGlxGetPixelMapuiv(c, gc->currentContextTag, map), NULL);
        if (XCBGlxGetPixelMapuivDataLength(reply) == 0)
            (void)memcpy(values, &reply->datum, sizeof(reply->datum));
d4201 3
a4203 1
        (void)memcpy(values, XCBGlxGetPixelMapuivData(reply), XCBGlxGetPixelMapuivDataLength(reply) * sizeof(GLuint));
d4206 3
a4208 2
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapuiv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&map), 4);
d4210 2
a4211 1
        UnlockDisplay(dpy); SyncHandle();
d4221 3
a4223 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4225 1
d4228 1
a4228 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4230 9
a4238 3
        XCBGlxGetPixelMapusvRep *reply = XCBGlxGetPixelMapusvReply(c, XCBGlxGetPixelMapusv(c, gc->currentContextTag, map), NULL);
        if (XCBGlxGetPixelMapusvDataLength(reply) == 0)
            (void)memcpy(values, &reply->datum, sizeof(reply->datum));
d4240 3
a4242 1
        (void)memcpy(values, XCBGlxGetPixelMapusvData(reply), XCBGlxGetPixelMapusvDataLength(reply) * sizeof(GLushort));
d4245 3
a4247 2
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapusv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&map), 4);
d4249 2
a4250 1
        UnlockDisplay(dpy); SyncHandle();
d4258 1
a4258 1
__indirect_glGetPolygonStipple(GLubyte * mask)
d4260 3
a4262 3
    __GLXcontext * const gc = __glXGetCurrentContext();
    const __GLXattribute * const state = gc->client_state_private;
    Display * const dpy = gc->currentDpy;
d4264 1
d4267 1
a4267 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4269 19
a4287 8
        XCBGlxGetPolygonStippleRep *reply = XCBGlxGetPolygonStippleReply(c, XCBGlxGetPolygonStipple(c, gc->currentContextTag, 0), NULL);
        (void)memcpy(mask, XCBGlxGetPolygonStippleData(reply), XCBGlxGetPolygonStippleDataLength(reply) * sizeof(GLubyte));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetPolygonStipple, cmdlen);
        *(int32_t *)(pc + 0) = 0;
        __glXReadPixelReply(dpy, gc, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP, mask, GL_FALSE);
        UnlockDisplay(dpy); SyncHandle();
d4297 3
a4299 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4301 1
d4304 1
a4304 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4306 9
a4314 3
        XCBGlxGetTexEnvfvRep *reply = XCBGlxGetTexEnvfvReply(c, XCBGlxGetTexEnvfv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetTexEnvfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4316 3
a4318 1
        (void)memcpy(params, XCBGlxGetTexEnvfvData(reply), XCBGlxGetTexEnvfvDataLength(reply) * sizeof(GLfloat));
d4321 4
a4324 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexEnvfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4326 2
a4327 1
        UnlockDisplay(dpy); SyncHandle();
d4337 3
a4339 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4341 1
d4344 1
a4344 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4346 9
a4354 3
        XCBGlxGetTexEnvivRep *reply = XCBGlxGetTexEnvivReply(c, XCBGlxGetTexEnviv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetTexEnvivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4356 3
a4358 1
        (void)memcpy(params, XCBGlxGetTexEnvivData(reply), XCBGlxGetTexEnvivDataLength(reply) * sizeof(GLint));
d4361 4
a4364 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexEnviv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4366 2
a4367 1
        UnlockDisplay(dpy); SyncHandle();
d4377 3
a4379 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4381 1
d4384 1
a4384 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4386 9
a4394 3
        XCBGlxGetTexGendvRep *reply = XCBGlxGetTexGendvReply(c, XCBGlxGetTexGendv(c, gc->currentContextTag, coord, pname), NULL);
        if (XCBGlxGetTexGendvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4396 3
a4398 1
        (void)memcpy(params, XCBGlxGetTexGendvData(reply), XCBGlxGetTexGendvDataLength(reply) * sizeof(GLdouble));
d4401 4
a4404 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexGendv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&coord), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4406 2
a4407 1
        UnlockDisplay(dpy); SyncHandle();
d4417 3
a4419 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4421 1
d4424 1
a4424 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4426 9
a4434 3
        XCBGlxGetTexGenfvRep *reply = XCBGlxGetTexGenfvReply(c, XCBGlxGetTexGenfv(c, gc->currentContextTag, coord, pname), NULL);
        if (XCBGlxGetTexGenfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4436 3
a4438 1
        (void)memcpy(params, XCBGlxGetTexGenfvData(reply), XCBGlxGetTexGenfvDataLength(reply) * sizeof(GLfloat));
d4441 4
a4444 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexGenfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&coord), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4446 2
a4447 1
        UnlockDisplay(dpy); SyncHandle();
d4457 3
a4459 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4461 1
d4464 1
a4464 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4466 9
a4474 3
        XCBGlxGetTexGenivRep *reply = XCBGlxGetTexGenivReply(c, XCBGlxGetTexGeniv(c, gc->currentContextTag, coord, pname), NULL);
        if (XCBGlxGetTexGenivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4476 3
a4478 1
        (void)memcpy(params, XCBGlxGetTexGenivData(reply), XCBGlxGetTexGenivDataLength(reply) * sizeof(GLint));
d4481 4
a4484 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexGeniv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&coord), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4486 2
a4487 1
        UnlockDisplay(dpy); SyncHandle();
d4495 2
a4496 1
__indirect_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels)
d4498 4
a4501 3
    __GLXcontext * const gc = __glXGetCurrentContext();
    const __GLXattribute * const state = gc->client_state_private;
    Display * const dpy = gc->currentDpy;
d4503 1
d4506 1
a4506 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4508 28
a4535 13
        XCBGlxGetTexImageRep *reply = XCBGlxGetTexImageReply(c, XCBGlxGetTexImage(c, gc->currentContextTag, target, level, format, type, state->storePack.swapEndian), NULL);
        (void)memcpy(pixels, XCBGlxGetTexImageData(reply), XCBGlxGetTexImageDataLength(reply) * sizeof(GLvoid));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexImage, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&level), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&format), 4);
        (void) memcpy((void *)(pc + 12), (void *)(&type), 4);
        *(int32_t *)(pc + 16) = 0;
        * (int8_t *)(pc + 16) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 3, 0, 0, 0, format, type, pixels, GL_TRUE);
        UnlockDisplay(dpy); SyncHandle();
d4545 3
a4547 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4549 1
d4552 1
a4552 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4554 10
a4563 3
        XCBGlxGetTexParameterfvRep *reply = XCBGlxGetTexParameterfvReply(c, XCBGlxGetTexParameterfv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetTexParameterfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4565 3
a4567 1
        (void)memcpy(params, XCBGlxGetTexParameterfvData(reply), XCBGlxGetTexParameterfvDataLength(reply) * sizeof(GLfloat));
d4570 4
a4573 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexParameterfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4575 2
a4576 1
        UnlockDisplay(dpy); SyncHandle();
d4586 3
a4588 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4590 1
d4593 1
a4593 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4595 10
a4604 3
        XCBGlxGetTexParameterivRep *reply = XCBGlxGetTexParameterivReply(c, XCBGlxGetTexParameteriv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetTexParameterivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4606 3
a4608 1
        (void)memcpy(params, XCBGlxGetTexParameterivData(reply), XCBGlxGetTexParameterivDataLength(reply) * sizeof(GLint));
d4611 4
a4614 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexParameteriv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d4616 2
a4617 1
        UnlockDisplay(dpy); SyncHandle();
d4625 2
a4626 1
__indirect_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)
d4628 3
a4630 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4632 1
d4635 1
a4635 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4637 8
a4644 3
        XCBGlxGetTexLevelParameterfvRep *reply = XCBGlxGetTexLevelParameterfvReply(c, XCBGlxGetTexLevelParameterfv(c, gc->currentContextTag, target, level, pname), NULL);
        if (XCBGlxGetTexLevelParameterfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4646 4
a4649 1
        (void)memcpy(params, XCBGlxGetTexLevelParameterfvData(reply), XCBGlxGetTexLevelParameterfvDataLength(reply) * sizeof(GLfloat));
d4652 6
a4657 4
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexLevelParameterfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&level), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&pname), 4);
d4659 2
a4660 1
        UnlockDisplay(dpy); SyncHandle();
d4668 2
a4669 1
__indirect_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params)
d4671 3
a4673 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4675 1
d4678 1
a4678 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4680 8
a4687 3
        XCBGlxGetTexLevelParameterivRep *reply = XCBGlxGetTexLevelParameterivReply(c, XCBGlxGetTexLevelParameteriv(c, gc->currentContextTag, target, level, pname), NULL);
        if (XCBGlxGetTexLevelParameterivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d4689 4
a4692 1
        (void)memcpy(params, XCBGlxGetTexLevelParameterivData(reply), XCBGlxGetTexLevelParameterivDataLength(reply) * sizeof(GLint));
d4695 6
a4700 4
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetTexLevelParameteriv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&level), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&pname), 4);
d4702 2
a4703 1
        UnlockDisplay(dpy); SyncHandle();
d4713 2
a4714 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d4716 1
d4718 1
d4721 1
a4721 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d4723 4
a4726 1
        XCBGlxIsListRep *reply = XCBGlxIsListReply(c, XCBGlxIsList(c, gc->currentContextTag, list), NULL);
d4730 3
a4732 2
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_IsList, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&list), 4);
d4734 2
a4735 1
        UnlockDisplay(dpy); SyncHandle();
d4745 1
a4745 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4748 2
a4749 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&zNear), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&zFar), 8);
d4751 3
a4753 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4758 2
a4759 1
__indirect_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
d4761 1
a4761 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4764 6
a4769 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&left), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&right), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&bottom), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&top), 8);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&zNear), 8);
    (void) memcpy((void *)(gc->pc + 44), (void *)(&zFar), 8);
d4771 3
a4773 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4780 1
a4780 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4784 3
a4786 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4793 1
a4793 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4796 1
a4796 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(m), 64);
d4798 3
a4800 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4807 1
a4807 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4810 1
a4810 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(m), 128);
d4812 3
a4814 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4821 1
a4821 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4824 1
a4824 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
d4826 3
a4828 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4835 1
a4835 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4838 1
a4838 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(m), 64);
d4840 3
a4842 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4849 1
a4849 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4852 1
a4852 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(m), 128);
d4854 3
a4856 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4861 2
a4862 1
__indirect_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
d4864 1
a4864 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4867 6
a4872 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&left), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&right), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&bottom), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&top), 8);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&zNear), 8);
    (void) memcpy((void *)(gc->pc + 44), (void *)(&zFar), 8);
d4874 3
a4876 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4883 1
a4883 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4887 3
a4889 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4896 1
a4896 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4900 3
a4902 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4909 1
a4909 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4912 4
a4915 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&angle), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&z), 8);
d4917 3
a4919 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4926 1
a4926 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4929 4
a4932 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&angle), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&z), 4);
d4934 3
a4936 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4943 1
a4943 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4946 3
a4948 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 8);
d4950 3
a4952 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4959 1
a4959 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4962 3
a4964 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
d4966 3
a4968 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4975 1
a4975 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4978 3
a4980 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 8);
d4982 3
a4984 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d4991 1
a4991 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d4994 3
a4996 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
d4998 3
a5000 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5007 1
a5007 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5010 4
a5013 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&height), 4);
d5015 3
a5017 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5024 1
a5024 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5027 2
a5028 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&texture), 4);
d5030 3
a5032 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5039 1
a5039 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5042 1
a5042 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&c), 1);
d5044 3
a5046 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5051 1
a5051 1
__indirect_glIndexubv(const GLubyte * c)
d5053 1
a5053 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5056 1
a5056 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(c), 1);
d5058 3
a5060 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5067 1
a5067 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5070 2
a5071 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&factor), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&units), 4);
d5073 3
a5075 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5080 2
a5081 1
__indirect_glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences)
d5083 2
a5084 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d5086 1
d5088 5
d5095 1
a5095 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d5097 8
a5104 2
        XCBGlxAreTexturesResidentRep *reply = XCBGlxAreTexturesResidentReply(c, XCBGlxAreTexturesResident(c, gc->currentContextTag, n, textures), NULL);
        (void)memcpy(residences, XCBGlxAreTexturesResidentData(reply), XCBGlxAreTexturesResidentDataLength(reply) * sizeof(GLboolean));
d5108 4
a5111 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_AreTexturesResident, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
        (void) memcpy((void *)(pc + 4), (void *)(textures), (n * 4));
d5113 2
a5114 1
        UnlockDisplay(dpy); SyncHandle();
d5120 37
d5159 2
a5160 1
__indirect_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
d5162 1
a5162 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5165 7
a5171 7
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&level), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&internalformat), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&border), 4);
d5173 3
a5175 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5180 3
a5182 1
__indirect_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
d5184 1
a5184 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5187 8
a5194 8
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&level), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&internalformat), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&height), 4);
    (void) memcpy((void *)(gc->pc + 32), (void *)(&border), 4);
d5196 3
a5198 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5203 2
a5204 1
__indirect_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
d5206 1
a5206 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5209 6
a5214 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&level), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&xoffset), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&width), 4);
d5216 3
a5218 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5223 3
a5225 1
__indirect_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
d5227 1
a5227 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5230 8
a5237 8
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&level), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&xoffset), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&yoffset), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 32), (void *)(&height), 4);
d5239 3
a5241 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5244 1
a5244 1
#define X_GLvop_DeleteTextures 12
d5248 3
a5250 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d5252 5
d5258 12
a5269 4
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivate, X_GLvop_DeleteTextures, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
        (void) memcpy((void *)(pc + 4), (void *)(textures), (n * 4));
        UnlockDisplay(dpy); SyncHandle();
d5274 32
d5310 3
a5312 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d5314 5
d5321 1
a5321 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d5323 14
a5336 6
        XCBGlxGenTexturesRep *reply = XCBGlxGenTexturesReply(c, XCBGlxGenTextures(c, gc->currentContextTag, n), NULL);
        (void)memcpy(textures, XCBGlxGenTexturesData(reply), XCBGlxGenTexturesDataLength(reply) * sizeof(GLuint));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GenTextures, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
d5338 2
a5339 1
        UnlockDisplay(dpy); SyncHandle();
d5345 3
a5347 3
#define X_GLsop_IsTexture 146
GLboolean
__indirect_glIsTexture(GLuint texture)
d5349 34
a5382 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d5384 1
d5386 1
d5389 1
a5389 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d5391 5
a5395 1
        XCBGlxIsTextureRep *reply = XCBGlxIsTextureReply(c, XCBGlxIsTexture(c, gc->currentContextTag, texture), NULL);
d5399 3
a5401 2
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_IsTexture, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&texture), 4);
d5403 2
a5404 1
        UnlockDisplay(dpy); SyncHandle();
d5410 29
d5441 2
a5442 1
__indirect_glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities)
d5444 1
a5444 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5446 4
d5452 4
a5455 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(textures), (n * 4));
        (void) memcpy((void *)(gc->pc + 8 + (n * 4)), (void *)(priorities), (n * 4));
d5457 3
a5459 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5464 9
a5472 4
__glx_TexSubImage_1D2D( unsigned opcode, unsigned dim, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels )
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (pixels != NULL) ? __glImageSize(width, height, 1, format, type, target) : 0;
d5476 1
a5476 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d5480 10
a5489 9
            (void) memcpy((void *)(gc->pc + 24), (void *)(&target), 4);
            (void) memcpy((void *)(gc->pc + 28), (void *)(&level), 4);
            (void) memcpy((void *)(gc->pc + 32), (void *)(&xoffset), 4);
            (void) memcpy((void *)(gc->pc + 36), (void *)(&yoffset), 4);
            (void) memcpy((void *)(gc->pc + 40), (void *)(&width), 4);
            (void) memcpy((void *)(gc->pc + 44), (void *)(&height), 4);
            (void) memcpy((void *)(gc->pc + 48), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 52), (void *)(&type), 4);
            (void) memcpy((void *)(gc->pc + 56), (void *)((pixels == NULL) ? one : zero), 4);
d5491 5
a5495 1
                (*gc->fillImage)(gc, dim, width, height, 1, format, type, pixels, gc->pc + 60, gc->pc + 4);
d5497 3
a5499 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_2D, default_pixel_store_2D_size );
d5501 1
a5501 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d5504 14
a5517 13
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 28), (void *)(&target), 4);
            (void) memcpy((void *)(pc + 32), (void *)(&level), 4);
            (void) memcpy((void *)(pc + 36), (void *)(&xoffset), 4);
            (void) memcpy((void *)(pc + 40), (void *)(&yoffset), 4);
            (void) memcpy((void *)(pc + 44), (void *)(&width), 4);
            (void) memcpy((void *)(pc + 48), (void *)(&height), 4);
            (void) memcpy((void *)(pc + 52), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 56), (void *)(&type), 4);
            (void) memcpy((void *)(pc + 60), zero, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format, type, pixels, pc + 64, pc + 8);
d5524 3
a5526 1
__indirect_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels)
d5528 2
a5529 1
    __glx_TexSubImage_1D2D(X_GLrop_TexSubImage1D, 1, target, level, xoffset, 1, width, 1, format, type, pixels );
d5534 3
a5536 1
__indirect_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels)
d5538 2
a5539 1
    __glx_TexSubImage_1D2D(X_GLrop_TexSubImage2D, 2, target, level, xoffset, yoffset, width, height, format, type, pixels );
d5544 2
a5545 1
__indirect_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
d5547 1
a5547 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5550 4
a5553 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&alpha), 4);
d5555 3
a5557 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5564 1
a5564 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5567 1
a5567 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&mode), 4);
d5569 3
a5571 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5576 2
a5577 1
__indirect_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table)
d5579 4
a5582 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (table != NULL) ? __glImageSize(width, 1, 1, format, type, target) : 0;
d5586 1
a5586 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d5590 6
a5595 5
            (void) memcpy((void *)(gc->pc + 24), (void *)(&target), 4);
            (void) memcpy((void *)(gc->pc + 28), (void *)(&internalformat), 4);
            (void) memcpy((void *)(gc->pc + 32), (void *)(&width), 4);
            (void) memcpy((void *)(gc->pc + 36), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 40), (void *)(&type), 4);
d5597 5
a5601 1
                (*gc->fillImage)(gc, 1, width, 1, 1, format, type, table, gc->pc + 44, gc->pc + 4);
d5603 3
a5605 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_1D, default_pixel_store_1D_size );
d5607 1
a5607 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d5610 10
a5619 9
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 28), (void *)(&target), 4);
            (void) memcpy((void *)(pc + 32), (void *)(&internalformat), 4);
            (void) memcpy((void *)(pc + 36), (void *)(&width), 4);
            (void) memcpy((void *)(pc + 40), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 44), (void *)(&type), 4);
            __glXSendLargeImage(gc, compsize, 1, width, 1, 1, format, type, table, pc + 48, pc + 8);
d5626 2
a5627 1
__indirect_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat * params)
d5629 1
a5629 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5633 3
a5635 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d5637 3
a5639 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5644 2
a5645 1
__indirect_glColorTableParameteriv(GLenum target, GLenum pname, const GLint * params)
d5647 1
a5647 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5651 3
a5653 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d5655 3
a5657 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5662 2
a5663 1
__indirect_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
d5665 1
a5665 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5668 5
a5672 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&internalformat), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&width), 4);
d5674 3
a5676 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5681 2
a5682 1
__indirect_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid * table)
d5684 4
a5687 3
    __GLXcontext * const gc = __glXGetCurrentContext();
    const __GLXattribute * const state = gc->client_state_private;
    Display * const dpy = gc->currentDpy;
d5689 1
d5692 1
a5692 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d5694 28
a5721 12
        XCBGlxGetColorTableRep *reply = XCBGlxGetColorTableReply(c, XCBGlxGetColorTable(c, gc->currentContextTag, target, format, type, state->storePack.swapEndian), NULL);
        (void)memcpy(table, XCBGlxGetColorTableData(reply), XCBGlxGetColorTableDataLength(reply) * sizeof(GLvoid));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetColorTable, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&format), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&type), 4);
        *(int32_t *)(pc + 12) = 0;
        * (int8_t *)(pc + 12) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, table, GL_TRUE);
        UnlockDisplay(dpy); SyncHandle();
d5727 34
d5763 2
a5764 1
__indirect_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat * params)
d5766 3
a5768 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d5770 1
d5773 1
a5773 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d5775 8
a5782 3
        XCBGlxGetColorTableParameterfvRep *reply = XCBGlxGetColorTableParameterfvReply(c, XCBGlxGetColorTableParameterfv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetColorTableParameterfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d5784 4
a5787 1
        (void)memcpy(params, XCBGlxGetColorTableParameterfvData(reply), XCBGlxGetColorTableParameterfvDataLength(reply) * sizeof(GLfloat));
d5790 5
a5794 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetColorTableParameterfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d5796 2
a5797 1
        UnlockDisplay(dpy); SyncHandle();
d5803 31
d5836 2
a5837 1
__indirect_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint * params)
d5839 3
a5841 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d5843 1
d5846 1
a5846 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d5848 8
a5855 3
        XCBGlxGetColorTableParameterivRep *reply = XCBGlxGetColorTableParameterivReply(c, XCBGlxGetColorTableParameteriv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetColorTableParameterivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d5857 4
a5860 1
        (void)memcpy(params, XCBGlxGetColorTableParameterivData(reply), XCBGlxGetColorTableParameterivDataLength(reply) * sizeof(GLint));
d5863 5
a5867 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetColorTableParameteriv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d5869 2
a5870 1
        UnlockDisplay(dpy); SyncHandle();
d5876 31
d5909 2
a5910 1
__indirect_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data)
d5912 3
a5914 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (data != NULL) ? __glImageSize(count, 1, 1, format, type, target) : 0;
d5918 1
a5918 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d5922 5
a5926 5
            (void) memcpy((void *)(gc->pc + 24), (void *)(&target), 4);
            (void) memcpy((void *)(gc->pc + 28), (void *)(&start), 4);
            (void) memcpy((void *)(gc->pc + 32), (void *)(&count), 4);
            (void) memcpy((void *)(gc->pc + 36), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 40), (void *)(&type), 4);
d5928 5
a5932 1
                (*gc->fillImage)(gc, 1, count, 1, 1, format, type, data, gc->pc + 44, gc->pc + 4);
d5934 3
a5936 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_1D, default_pixel_store_1D_size );
d5938 1
a5938 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d5941 10
a5950 9
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 28), (void *)(&target), 4);
            (void) memcpy((void *)(pc + 32), (void *)(&start), 4);
            (void) memcpy((void *)(pc + 36), (void *)(&count), 4);
            (void) memcpy((void *)(pc + 40), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 44), (void *)(&type), 4);
            __glXSendLargeImage(gc, compsize, 1, count, 1, 1, format, type, data, pc + 48, pc + 8);
d5957 2
a5958 1
__indirect_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
d5960 1
a5960 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d5963 5
a5967 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&start), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&width), 4);
d5969 3
a5971 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d5975 9
a5983 4
__glx_ConvolutionFilter_1D2D( unsigned opcode, unsigned dim, GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image )
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (image != NULL) ? __glImageSize(width, height, 1, format, type, target) : 0;
d5987 1
a5987 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d5991 7
a5997 6
            (void) memcpy((void *)(gc->pc + 24), (void *)(&target), 4);
            (void) memcpy((void *)(gc->pc + 28), (void *)(&internalformat), 4);
            (void) memcpy((void *)(gc->pc + 32), (void *)(&width), 4);
            (void) memcpy((void *)(gc->pc + 36), (void *)(&height), 4);
            (void) memcpy((void *)(gc->pc + 40), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 44), (void *)(&type), 4);
d5999 5
a6003 1
                (*gc->fillImage)(gc, dim, width, height, 1, format, type, image, gc->pc + 48, gc->pc + 4);
d6005 3
a6007 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_2D, default_pixel_store_2D_size );
d6009 1
a6009 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d6012 11
a6022 10
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 28), (void *)(&target), 4);
            (void) memcpy((void *)(pc + 32), (void *)(&internalformat), 4);
            (void) memcpy((void *)(pc + 36), (void *)(&width), 4);
            (void) memcpy((void *)(pc + 40), (void *)(&height), 4);
            (void) memcpy((void *)(pc + 44), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 48), (void *)(&type), 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format, type, image, pc + 52, pc + 8);
d6029 7
a6035 3
__indirect_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image)
{
    __glx_ConvolutionFilter_1D2D(X_GLrop_ConvolutionFilter1D, 1, target, internalformat, width, 1, format, type, image );
d6040 7
a6046 3
__indirect_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image)
{
    __glx_ConvolutionFilter_1D2D(X_GLrop_ConvolutionFilter2D, 2, target, internalformat, width, height, format, type, image );
d6051 2
a6052 1
__indirect_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
d6054 1
a6054 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6057 3
a6059 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&params), 4);
d6061 3
a6063 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6068 2
a6069 1
__indirect_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat * params)
d6071 1
a6071 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6075 3
a6077 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d6079 3
a6081 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6088 1
a6088 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6091 3
a6093 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&params), 4);
d6095 3
a6097 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6102 2
a6103 1
__indirect_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint * params)
d6105 1
a6105 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6109 3
a6111 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), (compsize * 4));
d6113 3
a6115 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6120 2
a6121 1
__indirect_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
d6123 1
a6123 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6126 5
a6130 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&internalformat), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&width), 4);
d6132 3
a6134 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6139 3
a6141 1
__indirect_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
d6143 1
a6143 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6146 6
a6151 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&internalformat), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&height), 4);
d6153 3
a6155 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6160 2
a6161 1
__indirect_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid * image)
d6163 4
a6166 3
    __GLXcontext * const gc = __glXGetCurrentContext();
    const __GLXattribute * const state = gc->client_state_private;
    Display * const dpy = gc->currentDpy;
d6168 1
d6171 1
a6171 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6173 10
a6182 2
        XCBGlxGetConvolutionFilterRep *reply = XCBGlxGetConvolutionFilterReply(c, XCBGlxGetConvolutionFilter(c, gc->currentContextTag, target, format, type, state->storePack.swapEndian), NULL);
        (void)memcpy(image, XCBGlxGetConvolutionFilterData(reply), XCBGlxGetConvolutionFilterDataLength(reply) * sizeof(GLvoid));
d6185 11
a6195 8
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionFilter, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&format), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&type), 4);
        *(int32_t *)(pc + 12) = 0;
        * (int8_t *)(pc + 12) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 2, 0, 0, 0, format, type, image, GL_TRUE);
        UnlockDisplay(dpy); SyncHandle();
d6201 37
d6240 2
a6241 1
__indirect_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat * params)
d6243 3
a6245 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d6247 1
d6250 1
a6250 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6252 8
a6259 3
        XCBGlxGetConvolutionParameterfvRep *reply = XCBGlxGetConvolutionParameterfvReply(c, XCBGlxGetConvolutionParameterfv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetConvolutionParameterfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d6261 4
a6264 1
        (void)memcpy(params, XCBGlxGetConvolutionParameterfvData(reply), XCBGlxGetConvolutionParameterfvDataLength(reply) * sizeof(GLfloat));
d6267 5
a6271 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionParameterfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d6273 2
a6274 1
        UnlockDisplay(dpy); SyncHandle();
d6280 31
d6313 2
a6314 1
__indirect_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint * params)
d6316 3
a6318 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d6320 1
d6323 1
a6323 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6325 8
a6332 3
        XCBGlxGetConvolutionParameterivRep *reply = XCBGlxGetConvolutionParameterivReply(c, XCBGlxGetConvolutionParameteriv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetConvolutionParameterivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d6334 4
a6337 1
        (void)memcpy(params, XCBGlxGetConvolutionParameterivData(reply), XCBGlxGetConvolutionParameterivDataLength(reply) * sizeof(GLint));
d6340 5
a6344 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionParameteriv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d6346 2
a6347 1
        UnlockDisplay(dpy); SyncHandle();
d6353 31
d6386 2
a6387 1
__indirect_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values)
d6389 4
a6392 3
    __GLXcontext * const gc = __glXGetCurrentContext();
    const __GLXattribute * const state = gc->client_state_private;
    Display * const dpy = gc->currentDpy;
d6394 1
d6397 1
a6397 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6399 28
a6426 13
        XCBGlxGetHistogramRep *reply = XCBGlxGetHistogramReply(c, XCBGlxGetHistogram(c, gc->currentContextTag, target, reset, format, type, state->storePack.swapEndian), NULL);
        (void)memcpy(values, XCBGlxGetHistogramData(reply), XCBGlxGetHistogramDataLength(reply) * sizeof(GLvoid));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetHistogram, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&format), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&type), 4);
        *(int32_t *)(pc + 12) = 0;
        * (int8_t *)(pc + 12) = state->storePack.swapEndian;
        * (int8_t *)(pc + 13) = reset;
        __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, values, GL_TRUE);
        UnlockDisplay(dpy); SyncHandle();
d6432 37
d6471 2
a6472 1
__indirect_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat * params)
d6474 3
a6476 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d6478 1
d6481 1
a6481 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6483 7
a6489 3
        XCBGlxGetHistogramParameterfvRep *reply = XCBGlxGetHistogramParameterfvReply(c, XCBGlxGetHistogramParameterfv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetHistogramParameterfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d6491 4
a6494 1
        (void)memcpy(params, XCBGlxGetHistogramParameterfvData(reply), XCBGlxGetHistogramParameterfvDataLength(reply) * sizeof(GLfloat));
d6497 5
a6501 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetHistogramParameterfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d6503 2
a6504 1
        UnlockDisplay(dpy); SyncHandle();
d6510 30
d6542 2
a6543 1
__indirect_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint * params)
d6545 3
a6547 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d6549 1
d6552 1
a6552 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6554 7
a6560 3
        XCBGlxGetHistogramParameterivRep *reply = XCBGlxGetHistogramParameterivReply(c, XCBGlxGetHistogramParameteriv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetHistogramParameterivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d6562 4
a6565 1
        (void)memcpy(params, XCBGlxGetHistogramParameterivData(reply), XCBGlxGetHistogramParameterivDataLength(reply) * sizeof(GLint));
d6568 5
a6572 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetHistogramParameteriv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d6574 2
a6575 1
        UnlockDisplay(dpy); SyncHandle();
d6581 30
d6613 2
a6614 1
__indirect_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values)
d6616 4
a6619 3
    __GLXcontext * const gc = __glXGetCurrentContext();
    const __GLXattribute * const state = gc->client_state_private;
    Display * const dpy = gc->currentDpy;
d6621 1
d6624 1
a6624 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6626 10
a6635 2
        XCBGlxGetMinmaxRep *reply = XCBGlxGetMinmaxReply(c, XCBGlxGetMinmax(c, gc->currentContextTag, target, reset, format, type, state->storePack.swapEndian), NULL);
        (void)memcpy(values, XCBGlxGetMinmaxData(reply), XCBGlxGetMinmaxDataLength(reply) * sizeof(GLvoid));
d6638 12
a6649 9
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetMinmax, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&format), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&type), 4);
        *(int32_t *)(pc + 12) = 0;
        * (int8_t *)(pc + 12) = state->storePack.swapEndian;
        * (int8_t *)(pc + 13) = reset;
        __glXReadPixelReply(dpy, gc, 1, 2, 1, 1, format, type, values, GL_FALSE);
        UnlockDisplay(dpy); SyncHandle();
d6655 36
d6693 2
a6694 1
__indirect_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat * params)
d6696 3
a6698 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d6700 1
d6703 1
a6703 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6705 7
a6711 3
        XCBGlxGetMinmaxParameterfvRep *reply = XCBGlxGetMinmaxParameterfvReply(c, XCBGlxGetMinmaxParameterfv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetMinmaxParameterfvDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d6713 3
a6715 1
        (void)memcpy(params, XCBGlxGetMinmaxParameterfvData(reply), XCBGlxGetMinmaxParameterfvDataLength(reply) * sizeof(GLfloat));
d6718 4
a6721 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetMinmaxParameterfv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d6723 2
a6724 1
        UnlockDisplay(dpy); SyncHandle();
d6730 30
d6764 3
a6766 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d6768 1
d6771 1
a6771 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d6773 7
a6779 3
        XCBGlxGetMinmaxParameterivRep *reply = XCBGlxGetMinmaxParameterivReply(c, XCBGlxGetMinmaxParameteriv(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetMinmaxParameterivDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d6781 3
a6783 1
        (void)memcpy(params, XCBGlxGetMinmaxParameterivData(reply), XCBGlxGetMinmaxParameterivDataLength(reply) * sizeof(GLint));
d6786 4
a6789 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetMinmaxParameteriv, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d6791 2
a6792 1
        UnlockDisplay(dpy); SyncHandle();
d6798 30
d6830 2
a6831 1
__indirect_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
d6833 1
a6833 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6836 4
a6839 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&internalformat), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&sink), 1);
d6841 3
a6843 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6850 1
a6850 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6853 3
a6855 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&internalformat), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&sink), 1);
d6857 3
a6859 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6866 1
a6866 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6869 1
a6869 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
d6871 3
a6873 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6880 1
a6880 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d6883 1
a6883 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
d6885 3
a6887 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d6891 9
a6899 4
__glx_TexImage_3D4D( unsigned opcode, unsigned dim, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (pixels != NULL) ? __glImageSize(width, height, depth, format, type, target) : 0;
d6903 1
a6903 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d6907 13
a6919 11
            (void) memcpy((void *)(gc->pc + 40), (void *)(&target), 4);
            (void) memcpy((void *)(gc->pc + 44), (void *)(&level), 4);
            (void) memcpy((void *)(gc->pc + 48), (void *)(&internalformat), 4);
            (void) memcpy((void *)(gc->pc + 52), (void *)(&width), 4);
            (void) memcpy((void *)(gc->pc + 56), (void *)(&height), 4);
            (void) memcpy((void *)(gc->pc + 60), (void *)(&depth), 4);
            (void) memcpy((void *)(gc->pc + 64), (void *)(&extent), 4);
            (void) memcpy((void *)(gc->pc + 68), (void *)(&border), 4);
            (void) memcpy((void *)(gc->pc + 72), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 76), (void *)(&type), 4);
            (void) memcpy((void *)(gc->pc + 80), (void *)((pixels == NULL) ? one : zero), 4);
d6921 5
a6925 1
                (*gc->fillImage)(gc, dim, width, height, depth, format, type, pixels, gc->pc + 84, gc->pc + 4);
d6927 3
a6929 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_4D, default_pixel_store_4D_size );
d6931 1
a6931 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d6934 16
a6949 15
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 44), (void *)(&target), 4);
            (void) memcpy((void *)(pc + 48), (void *)(&level), 4);
            (void) memcpy((void *)(pc + 52), (void *)(&internalformat), 4);
            (void) memcpy((void *)(pc + 56), (void *)(&width), 4);
            (void) memcpy((void *)(pc + 60), (void *)(&height), 4);
            (void) memcpy((void *)(pc + 64), (void *)(&depth), 4);
            (void) memcpy((void *)(pc + 68), (void *)(&extent), 4);
            (void) memcpy((void *)(pc + 72), (void *)(&border), 4);
            (void) memcpy((void *)(pc + 76), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 80), (void *)(&type), 4);
            (void) memcpy((void *)(pc + 84), zero, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, depth, format, type, pixels, pc + 88, pc + 8);
d6956 8
a6963 3
__indirect_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
{
    __glx_TexImage_3D4D(X_GLrop_TexImage3D, 3, target, level, internalformat, width, height, depth, 1, border, format, type, pixels );
d6967 10
a6976 4
__glx_TexSubImage_3D4D( unsigned opcode, unsigned dim, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const GLvoid * pixels )
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint compsize = (pixels != NULL) ? __glImageSize(width, height, depth, format, type, target) : 0;
d6980 1
a6980 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d6984 14
a6997 13
            (void) memcpy((void *)(gc->pc + 40), (void *)(&target), 4);
            (void) memcpy((void *)(gc->pc + 44), (void *)(&level), 4);
            (void) memcpy((void *)(gc->pc + 48), (void *)(&xoffset), 4);
            (void) memcpy((void *)(gc->pc + 52), (void *)(&yoffset), 4);
            (void) memcpy((void *)(gc->pc + 56), (void *)(&zoffset), 4);
            (void) memcpy((void *)(gc->pc + 60), (void *)(&woffset), 4);
            (void) memcpy((void *)(gc->pc + 64), (void *)(&width), 4);
            (void) memcpy((void *)(gc->pc + 68), (void *)(&height), 4);
            (void) memcpy((void *)(gc->pc + 72), (void *)(&depth), 4);
            (void) memcpy((void *)(gc->pc + 76), (void *)(&extent), 4);
            (void) memcpy((void *)(gc->pc + 80), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 84), (void *)(&type), 4);
            (void) memcpy((void *)(gc->pc + 88), (void *)((pixels == NULL) ? one : zero), 4);
d6999 5
a7003 1
                (*gc->fillImage)(gc, dim, width, height, depth, format, type, pixels, gc->pc + 92, gc->pc + 4);
d7005 3
a7007 2
            else {
                (void) memcpy( gc->pc + 4, default_pixel_store_4D, default_pixel_store_4D_size );
d7009 1
a7009 4
            gc->pc += cmdlen;
            if (gc->pc > gc->limit) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d7012 18
a7029 17
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 44), (void *)(&target), 4);
            (void) memcpy((void *)(pc + 48), (void *)(&level), 4);
            (void) memcpy((void *)(pc + 52), (void *)(&xoffset), 4);
            (void) memcpy((void *)(pc + 56), (void *)(&yoffset), 4);
            (void) memcpy((void *)(pc + 60), (void *)(&zoffset), 4);
            (void) memcpy((void *)(pc + 64), (void *)(&woffset), 4);
            (void) memcpy((void *)(pc + 68), (void *)(&width), 4);
            (void) memcpy((void *)(pc + 72), (void *)(&height), 4);
            (void) memcpy((void *)(pc + 76), (void *)(&depth), 4);
            (void) memcpy((void *)(pc + 80), (void *)(&extent), 4);
            (void) memcpy((void *)(pc + 84), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 88), (void *)(&type), 4);
            (void) memcpy((void *)(pc + 92), zero, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, depth, format, type, pixels, pc + 96, pc + 8);
d7036 8
a7043 3
__indirect_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels)
{
    __glx_TexSubImage_3D4D(X_GLrop_TexSubImage3D, 3, target, level, xoffset, yoffset, zoffset, 1, width, height, depth, 1, format, type, pixels );
d7048 3
a7050 1
__indirect_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
d7052 1
a7052 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7055 9
a7063 9
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&level), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&xoffset), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&yoffset), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&zoffset), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 32), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&height), 4);
d7065 3
a7067 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7074 1
a7074 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7077 1
a7077 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&texture), 4);
d7079 3
a7081 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7088 1
a7088 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7091 2
a7092 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&target), 4);
d7094 3
a7096 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7103 1
a7103 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7106 2
a7107 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(v), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&target), 4);
d7109 3
a7111 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7118 1
a7118 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7121 2
a7122 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 4);
d7124 3
a7126 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7133 1
a7133 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7136 2
a7137 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d7139 3
a7141 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7148 1
a7148 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7151 2
a7152 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 4);
d7154 3
a7156 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7163 1
a7163 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7166 2
a7167 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d7169 3
a7171 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7178 1
a7178 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7181 2
a7182 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 2);
d7184 3
a7186 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7193 1
a7193 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7196 2
a7197 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 2);
d7199 3
a7201 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7208 1
a7208 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7211 3
a7213 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&target), 4);
d7215 3
a7217 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7224 1
a7224 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7227 2
a7228 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(v), 16);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&target), 4);
d7230 3
a7232 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7239 1
a7239 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7242 3
a7244 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 4);
d7246 3
a7248 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7255 1
a7255 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7258 2
a7259 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d7261 3
a7263 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7270 1
a7270 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7273 3
a7275 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 4);
d7277 3
a7279 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7286 1
a7286 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7289 2
a7290 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d7292 3
a7294 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7301 1
a7301 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7304 3
a7306 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&t), 2);
d7308 3
a7310 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7317 1
a7317 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7320 2
a7321 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d7323 3
a7325 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7330 2
a7331 1
__indirect_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
d7333 1
a7333 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7336 4
a7339 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&r), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&target), 4);
d7341 3
a7343 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7350 1
a7350 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7353 2
a7354 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(v), 24);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&target), 4);
d7356 3
a7358 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7363 2
a7364 1
__indirect_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
d7366 1
a7366 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7369 4
a7372 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&r), 4);
d7374 3
a7376 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7383 1
a7383 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7386 2
a7387 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 12);
d7389 3
a7391 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7398 1
a7398 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7401 4
a7404 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&r), 4);
d7406 3
a7408 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7415 1
a7415 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7418 2
a7419 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 12);
d7421 3
a7423 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7428 2
a7429 1
__indirect_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
d7431 1
a7431 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7434 4
a7437 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&t), 2);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&r), 2);
d7439 3
a7441 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7448 1
a7448 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7451 2
a7452 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 6);
d7454 3
a7456 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7461 2
a7462 1
__indirect_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
d7464 1
a7464 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7467 5
a7471 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&s), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&r), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&q), 8);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&target), 4);
d7473 3
a7475 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7482 1
a7482 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7485 2
a7486 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(v), 32);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&target), 4);
d7488 3
a7490 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7495 2
a7496 1
__indirect_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
d7498 1
a7498 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7501 5
a7505 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&r), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&q), 4);
d7507 3
a7509 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7516 1
a7516 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7519 2
a7520 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d7522 3
a7524 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7529 2
a7530 1
__indirect_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
d7532 1
a7532 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7535 5
a7539 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&t), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&r), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&q), 4);
d7541 3
a7543 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7550 1
a7550 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7553 2
a7554 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d7556 3
a7558 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7563 2
a7564 1
__indirect_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
d7566 1
a7566 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7569 5
a7573 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&s), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&t), 2);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&r), 2);
    (void) memcpy((void *)(gc->pc + 14), (void *)(&q), 2);
d7575 3
a7577 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7584 1
a7584 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7587 2
a7588 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d7590 3
a7592 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7599 1
a7599 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7602 2
a7603 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&value), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&invert), 1);
d7605 3
a7607 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7614 2
a7615 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d7618 5
a7622 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetProgramStringARB, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d7624 2
a7625 1
        UnlockDisplay(dpy); SyncHandle();
d7634 2
a7635 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d7638 5
a7642 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetProgramivARB, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d7644 2
a7645 1
        UnlockDisplay(dpy); SyncHandle();
d7652 2
a7653 1
__indirect_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
d7655 1
a7655 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7658 6
a7663 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&z), 8);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&w), 8);
d7665 3
a7667 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7672 2
a7673 1
__indirect_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble * params)
d7675 1
a7675 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7678 3
a7680 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), 32);
d7682 3
a7684 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7689 2
a7690 1
__indirect_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d7692 1
a7692 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7695 6
a7700 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&w), 4);
d7702 3
a7704 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7709 2
a7710 1
__indirect_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat * params)
d7712 1
a7712 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7715 3
a7717 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), 16);
d7719 3
a7721 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7726 3
a7728 1
__indirect_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
d7730 1
a7730 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7733 6
a7738 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&z), 8);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&w), 8);
d7740 3
a7742 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7747 2
a7748 1
__indirect_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble * params)
d7750 1
a7750 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7753 3
a7755 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), 32);
d7757 3
a7759 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7764 3
a7766 1
__indirect_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d7768 1
a7768 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7771 6
a7776 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&w), 4);
d7778 3
a7780 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7785 2
a7786 1
__indirect_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat * params)
d7788 1
a7788 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7791 3
a7793 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), 16);
d7795 3
a7797 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7802 2
a7803 1
__indirect_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid * string)
d7805 1
a7805 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7807 4
d7813 1
a7813 1
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
d7817 4
a7820 4
            (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
            (void) memcpy((void *)(gc->pc + 8), (void *)(&format), 4);
            (void) memcpy((void *)(gc->pc + 12), (void *)(&len), 4);
            (void) memcpy((void *)(gc->pc + 16), (void *)(string), len);
d7822 4
a7825 3
            if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
d7828 6
a7833 6
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 8), (void *)(&target), 4);
            (void) memcpy((void *)(pc + 12), (void *)(&format), 4);
            (void) memcpy((void *)(pc + 16), (void *)(&len), 4);
d7843 1
a7843 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7846 2
a7847 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 8);
d7849 3
a7851 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7858 1
a7858 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7861 2
a7862 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d7864 3
a7866 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7873 1
a7873 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7876 2
a7877 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
d7879 3
a7881 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7888 1
a7888 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7891 2
a7892 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d7894 3
a7896 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7903 1
a7903 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7906 2
a7907 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 2);
d7909 3
a7911 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7918 1
a7918 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7921 2
a7922 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 2);
d7924 3
a7926 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7933 1
a7933 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7936 3
a7938 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 8);
d7940 3
a7942 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7949 1
a7949 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7952 2
a7953 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d7955 3
a7957 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7964 1
a7964 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7967 3
a7969 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 4);
d7971 3
a7973 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7980 1
a7980 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7983 2
a7984 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d7986 3
a7988 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d7995 1
a7995 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d7998 3
a8000 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&y), 2);
d8002 3
a8004 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8011 1
a8011 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8014 2
a8015 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d8017 3
a8019 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8024 2
a8025 1
__indirect_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
d8027 1
a8027 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8030 4
a8033 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&z), 8);
d8035 3
a8037 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8044 1
a8044 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8047 2
a8048 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 24);
d8050 3
a8052 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8059 1
a8059 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8062 4
a8065 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&z), 4);
d8067 3
a8069 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8076 1
a8076 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8079 2
a8080 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 12);
d8082 3
a8084 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8091 1
a8091 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8094 4
a8097 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&y), 2);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 2);
d8099 3
a8101 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8108 1
a8108 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8111 2
a8112 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 6);
d8114 3
a8116 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8121 1
a8121 1
__indirect_glVertexAttrib4NbvARB(GLuint index, const GLbyte * v)
d8123 1
a8123 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8126 2
a8127 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d8129 3
a8131 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8138 1
a8138 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8141 2
a8142 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d8144 3
a8146 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8153 1
a8153 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8156 2
a8157 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d8159 3
a8161 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8166 2
a8167 1
__indirect_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
d8169 1
a8169 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8172 5
a8176 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 1);
    (void) memcpy((void *)(gc->pc + 9), (void *)(&y), 1);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&z), 1);
    (void) memcpy((void *)(gc->pc + 11), (void *)(&w), 1);
d8178 3
a8180 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8185 1
a8185 1
__indirect_glVertexAttrib4NubvARB(GLuint index, const GLubyte * v)
d8187 1
a8187 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8190 2
a8191 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d8193 3
a8195 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8202 1
a8202 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8205 2
a8206 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d8208 3
a8210 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8217 1
a8217 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8220 2
a8221 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d8223 3
a8225 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8230 1
a8230 1
__indirect_glVertexAttrib4bvARB(GLuint index, const GLbyte * v)
d8232 1
a8232 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8235 2
a8236 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d8238 3
a8240 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8245 2
a8246 1
__indirect_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
d8248 1
a8248 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8251 5
a8255 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&z), 8);
    (void) memcpy((void *)(gc->pc + 32), (void *)(&w), 8);
d8257 3
a8259 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8266 1
a8266 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8269 2
a8270 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 32);
d8272 3
a8274 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8279 2
a8280 1
__indirect_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d8282 1
a8282 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8285 5
a8289 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&w), 4);
d8291 3
a8293 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8300 1
a8300 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8303 2
a8304 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d8306 3
a8308 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8315 1
a8315 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8318 2
a8319 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d8321 3
a8323 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8328 2
a8329 1
__indirect_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
d8331 1
a8331 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8334 5
a8338 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&y), 2);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 2);
    (void) memcpy((void *)(gc->pc + 14), (void *)(&w), 2);
d8340 3
a8342 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8349 1
a8349 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8352 2
a8353 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d8355 3
a8357 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8362 1
a8362 1
__indirect_glVertexAttrib4ubvARB(GLuint index, const GLubyte * v)
d8364 1
a8364 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8367 2
a8368 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d8370 3
a8372 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8379 1
a8379 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8382 2
a8383 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d8385 3
a8387 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8394 1
a8394 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8397 2
a8398 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d8400 3
a8402 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8409 1
a8409 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8412 2
a8413 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&id), 4);
d8415 3
a8417 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8424 3
a8426 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d8428 5
d8435 1
a8435 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d8437 1
a8437 1
        XCBGlxDeleteQueriesARB(c, gc->currentContextTag, n, ids);
d8439 6
a8444 4
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_DeleteQueriesARB, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
        (void) memcpy((void *)(pc + 4), (void *)(ids), (n * 4));
        UnlockDisplay(dpy); SyncHandle();
d8454 1
a8454 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8457 1
a8457 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
d8459 3
a8461 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8468 3
a8470 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d8472 5
d8479 1
a8479 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d8481 14
a8494 6
        XCBGlxGenQueriesARBRep *reply = XCBGlxGenQueriesARBReply(c, XCBGlxGenQueriesARB(c, gc->currentContextTag, n), NULL);
        (void)memcpy(ids, XCBGlxGenQueriesARBData(reply), XCBGlxGenQueriesARBDataLength(reply) * sizeof(GLuint));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GenQueriesARB, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
d8496 2
a8497 1
        UnlockDisplay(dpy); SyncHandle();
d8507 3
a8509 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d8511 1
d8514 1
a8514 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d8516 7
a8522 3
        XCBGlxGetQueryObjectivARBRep *reply = XCBGlxGetQueryObjectivARBReply(c, XCBGlxGetQueryObjectivARB(c, gc->currentContextTag, id, pname), NULL);
        if (XCBGlxGetQueryObjectivARBDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d8524 3
a8526 1
        (void)memcpy(params, XCBGlxGetQueryObjectivARBData(reply), XCBGlxGetQueryObjectivARBDataLength(reply) * sizeof(GLint));
d8529 4
a8532 3
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetQueryObjectivARB, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&id), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d8534 2
a8535 1
        UnlockDisplay(dpy); SyncHandle();
d8545 3
a8547 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d8549 1
d8552 1
a8552 1
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
d8554 7
a8560 3
        XCBGlxGetQueryObjectuivARBRep *reply = XCBGlxGetQueryObjectuivARBReply(c, XCBGlxGetQueryObjectuivARB(c, gc->currentContextTag, id, pname), NULL);
        if (XCBGlxGetQueryObjectuivARBDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
d8562 3
a8564 55
        (void)memcpy(params, XCBGlxGetQueryObjectuivARBData(reply), XCBGlxGetQueryObjectuivARBDataLength(reply) * sizeof(GLuint));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetQueryObjectuivARB, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&id), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy); SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_GetQueryivARB 164
void
__indirect_glGetQueryivARB(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        XCBGlxGetQueryivARBRep *reply = XCBGlxGetQueryivARBReply(c, XCBGlxGetQueryivARB(c, gc->currentContextTag, target, pname), NULL);
        if (XCBGlxGetQueryivARBDataLength(reply) == 0)
            (void)memcpy(params, &reply->datum, sizeof(reply->datum));
        else
        (void)memcpy(params, XCBGlxGetQueryivARBData(reply), XCBGlxGetQueryivARBDataLength(reply) * sizeof(GLint));
        free(reply);
#else
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_GetQueryivARB, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy); SyncHandle();
#endif /* USE_XCB */
    }
    return;
}

#define X_GLsop_IsQueryARB 163
GLboolean
__indirect_glIsQueryARB(GLuint id)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
    const GLuint cmdlen = 4;
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        XCBConnection *c = XCBConnectionOfDisplay(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        XCBGlxIsQueryARBRep *reply = XCBGlxIsQueryARBReply(c, XCBGlxIsQueryARB(c, gc->currentContextTag, id), NULL);
        retval = reply->ret_val;
d8567 4
a8570 66
        GLubyte const * pc = __glXSetupSingleRequest(gc, X_GLsop_IsQueryARB, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&id), 4);
        retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy); SyncHandle();
#endif /* USE_XCB */
    }
    return retval;
}

#define X_GLrop_DrawBuffersARB 233
void
__indirect_glDrawBuffersARB(GLsizei n, const GLenum * bufs)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 8 + __GLX_PAD((n * 4));
    if (__builtin_expect((n >= 0) && (gc->currentDpy != NULL), 1)) {
        if (cmdlen <= gc->maxSmallRenderCommandSize) {
            if ( (gc->pc + cmdlen) > gc->bufEnd ) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
            emit_header(gc->pc, X_GLrop_DrawBuffersARB, cmdlen);
            (void) memcpy((void *)(gc->pc + 4), (void *)(&n), 4);
            (void) memcpy((void *)(gc->pc + 8), (void *)(bufs), (n * 4));
            gc->pc += cmdlen;
            if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
        }
        else {
            const GLint op = X_GLrop_DrawBuffersARB;
            const GLuint cmdlenLarge = cmdlen + 4;
            GLubyte * const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *)(pc + 0), (void *)(&cmdlenLarge), 4);
            (void) memcpy((void *)(pc + 4), (void *)(&op), 4);
            (void) memcpy((void *)(pc + 8), (void *)(&n), 4);
            __glXSendLargeCommand(gc, pc, 12, bufs, (n * 4));
        }
    }
}

#define X_GLvop_GetColorTableParameterfvSGI 4099
void
__indirect_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetColorTableParameterfvSGI, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
        (void) __glXReadReply(dpy, 4, params, GL_FALSE);
        UnlockDisplay(dpy); SyncHandle();
    }
    return;
}

#define X_GLvop_GetColorTableParameterivSGI 4100
void
__indirect_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetColorTableParameterivSGI, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d8572 3
a8574 1
        UnlockDisplay(dpy); SyncHandle();
d8579 1
a8579 1
#define X_GLvop_GetColorTableSGI 4098
d8581 1
a8581 1
__indirect_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid * table)
d8583 5
a8587 4
    __GLXcontext * const gc = __glXGetCurrentContext();
    const __GLXattribute * const state = gc->client_state_private;
    Display * const dpy = gc->currentDpy;
    const GLuint cmdlen = 16;
d8589 27
a8615 8
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetColorTableSGI, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&format), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&type), 4);
        *(int32_t *)(pc + 12) = 0;
        * (int8_t *)(pc + 12) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, table, GL_TRUE);
        UnlockDisplay(dpy); SyncHandle();
d8620 1
a8620 1
#define X_GLvop_AreTexturesResidentEXT 11
d8622 1
a8622 1
__indirect_glAreTexturesResidentEXT(GLsizei n, const GLuint * textures, GLboolean * residences)
d8624 2
a8625 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d8627 23
a8649 7
    const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_AreTexturesResidentEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
        (void) memcpy((void *)(pc + 4), (void *)(textures), (n * 4));
        retval = (GLboolean) __glXReadReply(dpy, 1, residences, GL_TRUE);
        UnlockDisplay(dpy); SyncHandle();
d8654 1
a8654 1
#define X_GLvop_GenTexturesEXT 13
d8656 1
a8656 1
__indirect_glGenTexturesEXT(GLsizei n, GLuint * textures)
d8658 5
a8662 8
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
    const GLuint cmdlen = 4;
    if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GenTexturesEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
        (void) __glXReadReply(dpy, 4, textures, GL_TRUE);
        UnlockDisplay(dpy); SyncHandle();
d8664 21
a8684 16
    return;
}

#define X_GLvop_IsTextureEXT 14
GLboolean
__indirect_glIsTextureEXT(GLuint texture)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
    GLboolean retval = (GLboolean) 0;
    const GLuint cmdlen = 4;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_IsTextureEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&texture), 4);
        retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
        UnlockDisplay(dpy); SyncHandle();
a8685 1
    return retval;
d8692 1
a8692 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8695 2
a8696 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&value), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&invert), 1);
d8698 3
a8700 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8707 1
a8707 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8710 1
a8710 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pattern), 4);
d8712 3
a8714 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8721 1
a8721 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8724 2
a8725 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&param), 4);
d8727 3
a8729 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8736 1
a8736 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8740 2
a8741 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(params), (compsize * 4));
d8743 3
a8745 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8752 1
a8752 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8755 3
a8757 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 1);
    (void) memcpy((void *)(gc->pc + 5), (void *)(&green), 1);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&blue), 1);
d8759 3
a8761 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8766 1
a8766 1
__indirect_glSecondaryColor3bvEXT(const GLbyte * v)
d8768 1
a8768 1
    generic_3_byte( X_GLrop_SecondaryColor3bvEXT, v );
d8775 1
a8775 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8778 3
a8780 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 8);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&green), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&blue), 8);
d8782 3
a8784 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8791 1
a8791 1
    generic_24_byte( X_GLrop_SecondaryColor3dvEXT, v );
d8798 1
a8798 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8801 3
a8803 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
d8805 3
a8807 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8814 1
a8814 1
    generic_12_byte( X_GLrop_SecondaryColor3fvEXT, v );
d8821 1
a8821 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8824 3
a8826 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
d8828 3
a8830 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8837 1
a8837 1
    generic_12_byte( X_GLrop_SecondaryColor3ivEXT, v );
d8844 1
a8844 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8847 3
a8849 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&green), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&blue), 2);
d8851 3
a8853 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8860 1
a8860 1
    generic_6_byte( X_GLrop_SecondaryColor3svEXT, v );
d8867 1
a8867 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8870 3
a8872 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 1);
    (void) memcpy((void *)(gc->pc + 5), (void *)(&green), 1);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&blue), 1);
d8874 3
a8876 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8881 1
a8881 1
__indirect_glSecondaryColor3ubvEXT(const GLubyte * v)
d8883 1
a8883 1
    generic_3_byte( X_GLrop_SecondaryColor3ubvEXT, v );
d8890 1
a8890 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8893 3
a8895 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&green), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&blue), 4);
d8897 3
a8899 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8906 1
a8906 1
    generic_12_byte( X_GLrop_SecondaryColor3uivEXT, v );
d8913 1
a8913 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8916 3
a8918 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&red), 2);
    (void) memcpy((void *)(gc->pc + 6), (void *)(&green), 2);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&blue), 2);
d8920 3
a8922 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8929 1
a8929 1
    generic_6_byte( X_GLrop_SecondaryColor3usvEXT, v );
d8936 1
a8936 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8939 1
a8939 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&coord), 8);
d8941 3
a8943 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8950 1
a8950 1
    generic_8_byte( X_GLrop_FogCoorddvEXT, coord );
d8957 1
a8957 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8960 1
a8960 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&coord), 4);
d8962 3
a8964 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8971 1
a8971 1
    generic_4_byte( X_GLrop_FogCoordfvEXT, coord );
d8976 2
a8977 1
__indirect_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
d8979 1
a8979 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8982 4
a8985 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&sfactorRGB), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&dfactorRGB), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&sfactorAlpha), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&dfactorAlpha), 4);
d8987 3
a8989 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d8996 1
a8996 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d8999 3
a9001 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 4);
d9003 3
a9005 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9012 1
a9012 1
    generic_12_byte( X_GLrop_WindowPos3fvMESA, v );
d9017 2
a9018 1
__indirect_glAreProgramsResidentNV(GLsizei n, const GLuint * ids, GLboolean * residences)
d9020 2
a9021 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9024 4
d9029 5
a9033 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_AreProgramsResidentNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
        (void) memcpy((void *)(pc + 4), (void *)(ids), (n * 4));
d9035 2
a9036 1
        UnlockDisplay(dpy); SyncHandle();
d9045 1
a9045 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9048 2
a9049 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&program), 4);
d9051 3
a9053 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9060 2
a9061 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9063 4
d9068 7
a9074 4
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivate, X_GLvop_DeleteProgramsNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
        (void) memcpy((void *)(pc + 4), (void *)(programs), (n * 4));
        UnlockDisplay(dpy); SyncHandle();
d9081 2
a9082 1
__indirect_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat * params)
d9084 1
a9084 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9087 3
a9089 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&id), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), 16);
d9091 3
a9093 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9100 2
a9101 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9103 4
d9108 4
a9111 2
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GenProgramsNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
d9113 2
a9114 1
        UnlockDisplay(dpy); SyncHandle();
d9121 2
a9122 1
__indirect_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble * params)
d9124 2
a9125 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9128 6
a9133 4
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetProgramParameterdvNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&pname), 4);
d9135 2
a9136 1
        UnlockDisplay(dpy); SyncHandle();
d9143 2
a9144 1
__indirect_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params)
d9146 2
a9147 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9150 6
a9155 4
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetProgramParameterfvNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&pname), 4);
d9157 2
a9158 1
        UnlockDisplay(dpy); SyncHandle();
d9165 1
a9165 1
__indirect_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte * program)
d9167 2
a9168 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9171 5
a9175 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetProgramStringNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&id), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d9177 2
a9178 1
        UnlockDisplay(dpy); SyncHandle();
d9187 2
a9188 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9191 5
a9195 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetProgramivNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&id), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d9197 2
a9198 1
        UnlockDisplay(dpy); SyncHandle();
d9205 2
a9206 1
__indirect_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint * params)
d9208 2
a9209 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9212 6
a9217 4
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetTrackMatrixivNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&address), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&pname), 4);
d9219 2
a9220 1
        UnlockDisplay(dpy); SyncHandle();
d9227 2
a9228 1
__indirect_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble * params)
d9230 2
a9231 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9234 5
a9238 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetVertexAttribdvNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&index), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d9240 2
a9241 1
        UnlockDisplay(dpy); SyncHandle();
d9250 2
a9251 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9254 5
a9258 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetVertexAttribfvNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&index), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d9260 2
a9261 1
        UnlockDisplay(dpy); SyncHandle();
d9270 2
a9271 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9274 5
a9278 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetVertexAttribivNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&index), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d9280 2
a9281 1
        UnlockDisplay(dpy); SyncHandle();
d9290 2
a9291 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d9295 4
a9298 2
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_IsProgramNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&program), 4);
d9300 2
a9301 1
        UnlockDisplay(dpy); SyncHandle();
d9308 2
a9309 1
__indirect_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte * program)
d9311 1
a9311 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9313 4
d9319 4
a9322 4
        (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&id), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(&len), 4);
        (void) memcpy((void *)(gc->pc + 16), (void *)(program), len);
d9324 3
a9326 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
a9329 62
#define X_GLrop_ProgramParameter4dvNV 4185
void
__indirect_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44;
    emit_header(gc->pc, X_GLrop_ProgramParameter4dvNV, cmdlen);
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 28), (void *)(&z), 8);
    (void) memcpy((void *)(gc->pc + 36), (void *)(&w), 8);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
}

#define X_GLrop_ProgramParameter4dvNV 4185
void
__indirect_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble * params)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 44;
    emit_header(gc->pc, X_GLrop_ProgramParameter4dvNV, cmdlen);
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), 32);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
}

#define X_GLrop_ProgramParameter4fvNV 4184
void
__indirect_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_ProgramParameter4fvNV, cmdlen);
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&w), 4);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
}

#define X_GLrop_ProgramParameter4fvNV 4184
void
__indirect_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat * params)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    const GLuint cmdlen = 28;
    emit_header(gc->pc, X_GLrop_ProgramParameter4fvNV, cmdlen);
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(params), 16);
    gc->pc += cmdlen;
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
}

d9332 2
a9333 1
__indirect_glProgramParameters4dvNV(GLenum target, GLuint index, GLuint num, const GLdouble * params)
d9335 1
a9335 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9337 4
d9343 4
a9346 4
        (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(&num), 4);
        (void) memcpy((void *)(gc->pc + 16), (void *)(params), (num * 32));
d9348 3
a9350 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9356 2
a9357 1
__indirect_glProgramParameters4fvNV(GLenum target, GLuint index, GLuint num, const GLfloat * params)
d9359 1
a9359 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9361 4
d9367 4
a9370 4
        (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(&num), 4);
        (void) memcpy((void *)(gc->pc + 16), (void *)(params), (num * 16));
d9372 3
a9374 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9382 1
a9382 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9384 4
d9390 2
a9391 2
        (void) memcpy((void *)(gc->pc + 4), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(ids), (n * 4));
d9393 3
a9395 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9401 2
a9402 1
__indirect_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
d9404 1
a9404 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9407 4
a9410 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&address), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&matrix), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&transform), 4);
d9412 3
a9414 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9421 1
a9421 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9424 2
a9425 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 8);
d9427 3
a9429 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9436 1
a9436 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9439 2
a9440 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d9442 3
a9444 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9451 1
a9451 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9454 2
a9455 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
d9457 3
a9459 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9466 1
a9466 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9469 2
a9470 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d9472 3
a9474 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9481 1
a9481 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9484 2
a9485 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 2);
d9487 3
a9489 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9496 1
a9496 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9499 2
a9500 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 2);
d9502 3
a9504 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9511 1
a9511 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9514 3
a9516 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 8);
d9518 3
a9520 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9527 1
a9527 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9530 2
a9531 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d9533 3
a9535 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9542 1
a9542 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9545 3
a9547 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 4);
d9549 3
a9551 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9558 1
a9558 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9561 2
a9562 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d9564 3
a9566 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9573 1
a9573 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9576 3
a9578 3
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&y), 2);
d9580 3
a9582 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9589 1
a9589 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9592 2
a9593 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d9595 3
a9597 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9602 2
a9603 1
__indirect_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
d9605 1
a9605 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9608 4
a9611 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&z), 8);
d9613 3
a9615 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9622 1
a9622 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9625 2
a9626 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 24);
d9628 3
a9630 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9637 1
a9637 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9640 4
a9643 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&z), 4);
d9645 3
a9647 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9654 1
a9654 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9657 2
a9658 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 12);
d9660 3
a9662 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9669 1
a9669 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9672 4
a9675 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&y), 2);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 2);
d9677 3
a9679 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9686 1
a9686 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9689 2
a9690 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 6);
d9692 3
a9694 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9699 2
a9700 1
__indirect_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
d9702 1
a9702 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9705 5
a9709 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 8);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 8);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&z), 8);
    (void) memcpy((void *)(gc->pc + 32), (void *)(&w), 8);
d9711 3
a9713 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9720 1
a9720 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9723 2
a9724 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 32);
d9726 3
a9728 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9733 2
a9734 1
__indirect_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d9736 1
a9736 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9739 5
a9743 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&z), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&w), 4);
d9745 3
a9747 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9754 1
a9754 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9757 2
a9758 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 16);
d9760 3
a9762 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9767 2
a9768 1
__indirect_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
d9770 1
a9770 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9773 5
a9777 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 2);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&y), 2);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&z), 2);
    (void) memcpy((void *)(gc->pc + 14), (void *)(&w), 2);
d9779 3
a9781 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9788 1
a9788 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9791 2
a9792 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 8);
d9794 3
a9796 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9801 2
a9802 1
__indirect_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
d9804 1
a9804 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9807 5
a9811 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&x), 1);
    (void) memcpy((void *)(gc->pc + 9), (void *)(&y), 1);
    (void) memcpy((void *)(gc->pc + 10), (void *)(&z), 1);
    (void) memcpy((void *)(gc->pc + 11), (void *)(&w), 1);
d9813 3
a9815 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9820 1
a9820 1
__indirect_glVertexAttrib4ubvNV(GLuint index, const GLubyte * v)
d9822 1
a9822 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9825 2
a9826 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(v), 4);
d9828 3
a9830 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9837 1
a9837 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9839 4
d9845 3
a9847 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 8));
d9849 3
a9851 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9859 1
a9859 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9861 4
d9867 3
a9869 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 4));
d9871 3
a9873 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9881 1
a9881 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9883 4
d9889 3
a9891 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 2));
d9893 3
a9895 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9903 1
a9903 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9905 4
d9911 3
a9913 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 16));
d9915 3
a9917 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9925 1
a9925 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9927 4
d9933 3
a9935 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 8));
d9937 3
a9939 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9947 1
a9947 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9949 4
d9955 3
a9957 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 4));
d9959 3
a9961 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9969 1
a9969 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9971 4
d9977 3
a9979 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 24));
d9981 3
a9983 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d9991 1
a9991 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d9993 4
d9999 3
a10001 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 12));
d10003 3
a10005 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10013 1
a10013 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10015 4
d10021 3
a10023 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 6));
d10025 3
a10027 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10035 1
a10035 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10037 4
d10043 3
a10045 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 32));
d10047 3
a10049 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10057 1
a10057 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10059 4
d10065 3
a10067 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 16));
d10069 3
a10071 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10079 1
a10079 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10081 4
d10087 3
a10089 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 8));
d10091 3
a10093 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10099 1
a10099 1
__indirect_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte * v)
d10101 1
a10101 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10103 4
d10109 3
a10111 3
        (void) memcpy((void *)(gc->pc + 4), (void *)(&index), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), (n * 4));
d10113 3
a10115 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10123 1
a10123 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10126 2
a10127 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&param), 4);
d10129 3
a10131 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10138 1
a10138 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10142 2
a10143 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&pname), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(params), (compsize * 4));
d10145 3
a10147 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10154 1
a10154 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10157 1
a10157 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&face), 4);
d10159 3
a10161 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10166 3
a10168 1
__indirect_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params)
d10170 2
a10171 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d10173 4
d10178 7
a10184 4
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetProgramNamedParameterdvNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&id), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&len), 4);
        (void) memcpy((void *)(pc + 8), (void *)(name), len);
d10186 2
a10187 1
        UnlockDisplay(dpy); SyncHandle();
d10194 3
a10196 1
__indirect_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params)
d10198 2
a10199 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d10201 4
d10206 7
a10212 4
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetProgramNamedParameterfvNV, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&id), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&len), 4);
        (void) memcpy((void *)(pc + 8), (void *)(name), len);
d10214 2
a10215 1
        UnlockDisplay(dpy); SyncHandle();
d10222 3
a10224 1
__indirect_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
d10226 1
a10226 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10228 4
d10234 7
a10240 7
        (void) memcpy((void *)(gc->pc + 4), (void *)(&x), 8);
        (void) memcpy((void *)(gc->pc + 12), (void *)(&y), 8);
        (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 8);
        (void) memcpy((void *)(gc->pc + 28), (void *)(&w), 8);
        (void) memcpy((void *)(gc->pc + 36), (void *)(&id), 4);
        (void) memcpy((void *)(gc->pc + 40), (void *)(&len), 4);
        (void) memcpy((void *)(gc->pc + 44), (void *)(name), len);
d10242 3
a10244 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10250 3
a10252 1
__indirect_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v)
d10254 1
a10254 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10256 4
d10262 4
a10265 4
        (void) memcpy((void *)(gc->pc + 4), (void *)(v), 32);
        (void) memcpy((void *)(gc->pc + 36), (void *)(&id), 4);
        (void) memcpy((void *)(gc->pc + 40), (void *)(&len), 4);
        (void) memcpy((void *)(gc->pc + 44), (void *)(name), len);
d10267 3
a10269 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10275 3
a10277 1
__indirect_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d10279 1
a10279 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10281 4
d10287 7
a10293 7
        (void) memcpy((void *)(gc->pc + 4), (void *)(&id), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&len), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(&x), 4);
        (void) memcpy((void *)(gc->pc + 16), (void *)(&y), 4);
        (void) memcpy((void *)(gc->pc + 20), (void *)(&z), 4);
        (void) memcpy((void *)(gc->pc + 24), (void *)(&w), 4);
        (void) memcpy((void *)(gc->pc + 28), (void *)(name), len);
d10295 3
a10297 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10303 3
a10305 1
__indirect_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v)
d10307 1
a10307 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10309 4
d10315 4
a10318 4
        (void) memcpy((void *)(gc->pc + 4), (void *)(&id), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(&len), 4);
        (void) memcpy((void *)(gc->pc + 12), (void *)(v), 16);
        (void) memcpy((void *)(gc->pc + 28), (void *)(name), len);
d10320 3
a10322 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10330 1
a10330 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10333 2
a10334 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&modeRGB), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&modeA), 4);
d10336 3
a10338 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10345 1
a10345 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10348 2
a10349 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&framebuffer), 4);
d10351 3
a10353 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10360 1
a10360 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10363 2
a10364 2
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&renderbuffer), 4);
d10366 3
a10368 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10375 2
a10376 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d10380 5
a10384 2
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_CheckFramebufferStatusEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
d10386 2
a10387 1
        UnlockDisplay(dpy); SyncHandle();
d10396 1
a10396 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10398 4
d10404 3
a10406 2
        (void) memcpy((void *)(gc->pc + 4), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(framebuffers), (n * 4));
d10408 3
a10410 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10418 1
a10418 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10420 4
d10426 3
a10428 2
        (void) memcpy((void *)(gc->pc + 4), (void *)(&n), 4);
        (void) memcpy((void *)(gc->pc + 8), (void *)(renderbuffers), (n * 4));
d10430 3
a10432 1
        if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10438 3
a10440 1
__indirect_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
d10442 1
a10442 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10445 4
a10448 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&attachment), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&renderbuffertarget), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&renderbuffer), 4);
d10450 3
a10452 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10457 3
a10459 1
__indirect_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
d10461 1
a10461 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10464 5
a10468 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&attachment), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&textarget), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&texture), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&level), 4);
d10470 3
a10472 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10477 3
a10479 1
__indirect_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
d10481 1
a10481 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10484 5
a10488 5
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&attachment), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&textarget), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&texture), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&level), 4);
d10490 3
a10492 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10497 3
a10499 1
__indirect_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
d10501 1
a10501 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10504 6
a10509 6
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&attachment), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&textarget), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&texture), 4);
    (void) memcpy((void *)(gc->pc + 20), (void *)(&level), 4);
    (void) memcpy((void *)(gc->pc + 24), (void *)(&zoffset), 4);
d10511 3
a10513 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10520 2
a10521 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d10523 4
d10528 4
a10531 2
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GenFramebuffersEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
d10533 2
a10534 1
        UnlockDisplay(dpy); SyncHandle();
d10543 2
a10544 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d10546 4
d10551 4
a10554 2
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GenRenderbuffersEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&n), 4);
d10556 2
a10557 1
        UnlockDisplay(dpy); SyncHandle();
d10566 1
a10566 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10569 1
a10569 1
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
d10571 3
a10573 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
d10578 16
a10593 10
__indirect_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint * params)
{
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
    const GLuint cmdlen = 12;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetFramebufferAttachmentParameterivEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&attachment), 4);
        (void) memcpy((void *)(pc + 8), (void *)(&pname), 4);
d10595 2
a10596 1
        UnlockDisplay(dpy); SyncHandle();
d10603 2
a10604 1
__indirect_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint * params)
d10606 2
a10607 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d10610 6
a10615 3
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_GetRenderbufferParameterivEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&target), 4);
        (void) memcpy((void *)(pc + 4), (void *)(&pname), 4);
d10617 2
a10618 1
        UnlockDisplay(dpy); SyncHandle();
d10627 2
a10628 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d10632 4
a10635 2
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_IsFramebufferEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&framebuffer), 4);
d10637 2
a10638 1
        UnlockDisplay(dpy); SyncHandle();
d10647 2
a10648 2
    __GLXcontext * const gc = __glXGetCurrentContext();
    Display * const dpy = gc->currentDpy;
d10652 4
a10655 2
        GLubyte const * pc = __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply, X_GLvop_IsRenderbufferEXT, cmdlen);
        (void) memcpy((void *)(pc + 0), (void *)(&renderbuffer), 4);
d10657 2
a10658 1
        UnlockDisplay(dpy); SyncHandle();
d10665 2
a10666 1
__indirect_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
d10668 1
a10668 1
    __GLXcontext * const gc = __glXGetCurrentContext();
d10671 4
a10674 4
    (void) memcpy((void *)(gc->pc + 4), (void *)(&target), 4);
    (void) memcpy((void *)(gc->pc + 8), (void *)(&internalformat), 4);
    (void) memcpy((void *)(gc->pc + 12), (void *)(&width), 4);
    (void) memcpy((void *)(gc->pc + 16), (void *)(&height), 4);
d10676 3
a10678 1
    if (__builtin_expect(gc->pc > gc->limit, 0)) { (void) __glXFlushRenderBuffer(gc, gc->pc); }
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a32 3
#include "dispatch.h"
#include "glapi.h"
#include "glthread.h"
d35 3
a37 3
#include <X11/Xlib-xcb.h>
#include <xcb/xcb.h>
#include <xcb/glx.h>
d66 1
a66 2
__glXReadReply(Display * dpy, size_t size, void *dest,
               GLboolean reply_is_always_array)
d69 1
a69 1

d73 2
a74 2
            const GLint bytes = (reply_is_always_array)
                ? (4 * reply.length) : (reply.size * size);
d78 1
a78 1
            if (extra < 4) {
d81 3
a83 2
        } else {
            (void) memcpy(dest, &(reply.pad3), size);
d91 3
a93 3
__glXReadPixelReply(Display * dpy, __GLXcontext * gc, unsigned max_dim,
                    GLint width, GLint height, GLint depth, GLenum format,
                    GLenum type, void *dest, GLboolean dimensions_in_reply)
d97 1
a97 1

d100 2
a101 2
    if (dimensions_in_reply) {
        width = reply.pad3;
d103 4
a106 8
        depth = reply.pad5;

        if ((height == 0) || (max_dim < 2)) {
            height = 1;
        }
        if ((depth == 0) || (max_dim < 3)) {
            depth = 1;
        }
d111 1
a111 1
        void *buf = Xmalloc(size);
d113 1
a113 1
        if (buf == NULL) {
d116 2
a117 1
        } else {
d121 1
a121 1
            if (extra < 4) {
d135 1
a135 1
__glXSetupSingleRequest(__GLXcontext * gc, GLint sop, GLint cmdlen)
d137 2
a138 2
    xGLXSingleReq *req;
    Display *const dpy = gc->currentDpy;
d146 1
a146 1
    return (GLubyte *) (req) + sz_xGLXSingleReq;
d150 1
a150 2
__glXSetupVendorRequest(__GLXcontext * gc, GLint code, GLint vop,
                        GLint cmdlen)
d152 2
a153 2
    xGLXVendorPrivateReq *req;
    Display *const dpy = gc->currentDpy;
d162 1
a162 1
    return (GLubyte *) (req) + sz_xGLXVendorPrivateReq;
d179 1
a179 1
generic_3_byte(GLint rop, const void *ptr)
d181 1
a181 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d185 1
a185 1
    (void) memcpy((void *) (gc->pc + 4), ptr, 4);
d187 1
a187 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d191 1
a191 1
generic_4_byte(GLint rop, const void *ptr)
d193 1
a193 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d197 1
a197 1
    (void) memcpy((void *) (gc->pc + 4), ptr, 4);
d199 1
a199 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d203 1
a203 1
generic_6_byte(GLint rop, const void *ptr)
d205 1
a205 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d209 1
a209 1
    (void) memcpy((void *) (gc->pc + 4), ptr, 8);
d211 1
a211 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d215 1
a215 1
generic_8_byte(GLint rop, const void *ptr)
d217 1
a217 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d221 1
a221 1
    (void) memcpy((void *) (gc->pc + 4), ptr, 8);
d223 1
a223 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d227 1
a227 1
generic_12_byte(GLint rop, const void *ptr)
d229 1
a229 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d233 1
a233 1
    (void) memcpy((void *) (gc->pc + 4), ptr, 12);
d235 1
a235 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d239 1
a239 1
generic_16_byte(GLint rop, const void *ptr)
d241 1
a241 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d245 1
a245 1
    (void) memcpy((void *) (gc->pc + 4), ptr, 16);
d247 1
a247 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d251 1
a251 1
generic_24_byte(GLint rop, const void *ptr)
d253 1
a253 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d257 1
a257 1
    (void) memcpy((void *) (gc->pc + 4), ptr, 24);
d259 1
a259 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d263 1
a263 1
generic_32_byte(GLint rop, const void *ptr)
d265 1
a265 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d269 1
a269 1
    (void) memcpy((void *) (gc->pc + 4), ptr, 32);
d271 1
a271 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d278 2
a279 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d283 1
a283 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d285 1
a285 1
        xcb_glx_new_list(c, gc->currentContextTag, list, mode);
d287 4
a290 6
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_NewList, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&list), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&mode), 4);
        UnlockDisplay(dpy);
        SyncHandle();
d300 2
a301 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d305 1
a305 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d307 1
a307 1
        xcb_glx_end_list(c, gc->currentContextTag);
d310 1
a310 2
        UnlockDisplay(dpy);
        SyncHandle();
d320 1
a320 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d323 1
a323 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&list), 4);
d325 1
a325 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d332 1
a332 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d337 1
a337 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d341 3
a343 4
            (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&type), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (lists),
                          (compsize * n));
d345 3
a347 4
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d350 5
a354 5
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&n), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&type), 4);
d364 2
a365 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d369 1
a369 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d371 1
a371 1
        xcb_glx_delete_lists(c, gc->currentContextTag, list, range);
d373 4
a376 6
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_DeleteLists, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&list), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&range), 4);
        UnlockDisplay(dpy);
        SyncHandle();
d386 2
a387 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d392 1
a392 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d394 1
a394 5
        xcb_glx_gen_lists_reply_t *reply =
            xcb_glx_gen_lists_reply(c,
                                    xcb_glx_gen_lists(c,
                                                      gc->currentContextTag,
                                                      range), NULL);
d398 2
a399 3
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GenLists, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&range), 4);
d401 1
a401 2
        UnlockDisplay(dpy);
        SyncHandle();
d411 1
a411 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d414 1
a414 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&base), 4);
d416 1
a416 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d423 1
a423 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d426 1
a426 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
d428 1
a428 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d433 4
a436 8
__indirect_glBitmap(GLsizei width, GLsizei height, GLfloat xorig,
                    GLfloat yorig, GLfloat xmove, GLfloat ymove,
                    const GLubyte * bitmap)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (bitmap != NULL) ? __glImageSize(width, height, 1, GL_COLOR_INDEX,
                                         GL_BITMAP, 0) : 0;
d440 1
a440 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d444 6
a449 6
            (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&xorig), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&yorig), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&xmove), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&ymove), 4);
d451 4
a454 5
                (*gc->fillImage) (gc, 2, width, height, 1, GL_COLOR_INDEX,
                                  GL_BITMAP, bitmap, gc->pc + 48, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
d457 3
a459 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d462 10
a471 12
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&xorig), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&yorig), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&xmove), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&ymove), 4);
            __glXSendLargeImage(gc, compsize, 2, width, height, 1,
                                GL_COLOR_INDEX, GL_BITMAP, bitmap, pc + 52,
                                pc + 8);
d480 1
a480 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d483 3
a485 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
d487 1
a487 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d494 1
a494 1
    generic_3_byte(X_GLrop_Color3bv, v);
d501 1
a501 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d504 3
a506 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&green), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&blue), 8);
d508 1
a508 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d515 1
a515 1
    generic_24_byte(X_GLrop_Color3dv, v);
d522 1
a522 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d525 3
a527 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
d529 1
a529 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d536 1
a536 1
    generic_12_byte(X_GLrop_Color3fv, v);
d543 1
a543 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d546 3
a548 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
d550 1
a550 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d557 1
a557 1
    generic_12_byte(X_GLrop_Color3iv, v);
d564 1
a564 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d567 3
a569 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
d571 1
a571 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d578 1
a578 1
    generic_6_byte(X_GLrop_Color3sv, v);
d585 1
a585 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d588 3
a590 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
d592 1
a592 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d599 1
a599 1
    generic_3_byte(X_GLrop_Color3ubv, v);
d606 1
a606 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d609 3
a611 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
d613 1
a613 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d620 1
a620 1
    generic_12_byte(X_GLrop_Color3uiv, v);
d627 1
a627 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d630 3
a632 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
d634 1
a634 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d641 1
a641 1
    generic_6_byte(X_GLrop_Color3usv, v);
d648 1
a648 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d651 4
a654 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    (void) memcpy((void *) (gc->pc + 7), (void *) (&alpha), 1);
d656 1
a656 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d663 1
a663 1
    generic_4_byte(X_GLrop_Color4bv, v);
d668 1
a668 2
__indirect_glColor4d(GLdouble red, GLdouble green, GLdouble blue,
                     GLdouble alpha)
d670 1
a670 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d673 4
a676 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&green), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&blue), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&alpha), 8);
d678 1
a678 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d685 1
a685 1
    generic_32_byte(X_GLrop_Color4dv, v);
d692 1
a692 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d695 4
a698 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
d700 1
a700 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d707 1
a707 1
    generic_16_byte(X_GLrop_Color4fv, v);
d714 1
a714 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d717 4
a720 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
d722 1
a722 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d729 1
a729 1
    generic_16_byte(X_GLrop_Color4iv, v);
d736 1
a736 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d739 4
a742 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&alpha), 2);
d744 1
a744 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d751 1
a751 1
    generic_8_byte(X_GLrop_Color4sv, v);
d758 1
a758 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d761 4
a764 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    (void) memcpy((void *) (gc->pc + 7), (void *) (&alpha), 1);
d766 1
a766 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d773 1
a773 1
    generic_4_byte(X_GLrop_Color4ubv, v);
d780 1
a780 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d783 4
a786 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
d788 1
a788 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d795 1
a795 1
    generic_16_byte(X_GLrop_Color4uiv, v);
d800 1
a800 2
__indirect_glColor4us(GLushort red, GLushort green, GLushort blue,
                      GLushort alpha)
d802 1
a802 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d805 4
a808 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&alpha), 2);
d810 1
a810 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d817 1
a817 1
    generic_8_byte(X_GLrop_Color4usv, v);
d824 1
a824 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d827 1
a827 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&flag), 1);
d829 1
a829 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d836 1
a836 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d839 1
a839 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (flag), 1);
d841 1
a841 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d848 1
a848 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d852 1
a852 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d859 1
a859 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d862 1
a862 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 8);
d864 1
a864 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d871 1
a871 1
    generic_8_byte(X_GLrop_Indexdv, c);
d878 1
a878 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d881 1
a881 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 4);
d883 1
a883 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d890 1
a890 1
    generic_4_byte(X_GLrop_Indexfv, c);
d897 1
a897 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d900 1
a900 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 4);
d902 1
a902 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d909 1
a909 1
    generic_4_byte(X_GLrop_Indexiv, c);
d916 1
a916 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d919 1
a919 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 2);
d921 1
a921 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d928 1
a928 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d931 1
a931 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (c), 2);
d933 1
a933 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d940 1
a940 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d943 3
a945 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&ny), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&nz), 1);
d947 1
a947 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d954 1
a954 1
    generic_3_byte(X_GLrop_Normal3bv, v);
d961 1
a961 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d964 3
a966 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&ny), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&nz), 8);
d968 1
a968 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d975 1
a975 1
    generic_24_byte(X_GLrop_Normal3dv, v);
d982 1
a982 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d985 3
a987 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&ny), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&nz), 4);
d989 1
a989 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d996 1
a996 1
    generic_12_byte(X_GLrop_Normal3fv, v);
d1003 1
a1003 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1006 3
a1008 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&ny), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&nz), 4);
d1010 1
a1010 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1017 1
a1017 1
    generic_12_byte(X_GLrop_Normal3iv, v);
d1024 1
a1024 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1027 3
a1029 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&nx), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&ny), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&nz), 2);
d1031 1
a1031 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1038 1
a1038 1
    generic_6_byte(X_GLrop_Normal3sv, v);
d1045 1
a1045 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1048 2
a1049 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
d1051 1
a1051 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1058 1
a1058 1
    generic_16_byte(X_GLrop_RasterPos2dv, v);
d1065 1
a1065 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1068 2
a1069 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
d1071 1
a1071 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1078 1
a1078 1
    generic_8_byte(X_GLrop_RasterPos2fv, v);
d1085 1
a1085 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1088 2
a1089 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
d1091 1
a1091 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1098 1
a1098 1
    generic_8_byte(X_GLrop_RasterPos2iv, v);
d1105 1
a1105 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1108 2
a1109 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
d1111 1
a1111 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1118 1
a1118 1
    generic_4_byte(X_GLrop_RasterPos2sv, v);
d1125 1
a1125 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1128 3
a1130 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
d1132 1
a1132 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1139 1
a1139 1
    generic_24_byte(X_GLrop_RasterPos3dv, v);
d1146 1
a1146 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1149 3
a1151 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
d1153 1
a1153 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1160 1
a1160 1
    generic_12_byte(X_GLrop_RasterPos3fv, v);
d1167 1
a1167 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1170 3
a1172 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
d1174 1
a1174 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1181 1
a1181 1
    generic_12_byte(X_GLrop_RasterPos3iv, v);
d1188 1
a1188 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1191 3
a1193 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&z), 2);
d1195 1
a1195 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1202 1
a1202 1
    generic_6_byte(X_GLrop_RasterPos3sv, v);
d1209 1
a1209 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1212 4
a1215 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&w), 8);
d1217 1
a1217 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1224 1
a1224 1
    generic_32_byte(X_GLrop_RasterPos4dv, v);
d1231 1
a1231 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1234 4
a1237 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&w), 4);
d1239 1
a1239 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1246 1
a1246 1
    generic_16_byte(X_GLrop_RasterPos4fv, v);
d1253 1
a1253 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1256 4
a1259 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&w), 4);
d1261 1
a1261 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1268 1
a1268 1
    generic_16_byte(X_GLrop_RasterPos4iv, v);
d1275 1
a1275 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1278 4
a1281 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&z), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&w), 2);
d1283 1
a1283 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1290 1
a1290 1
    generic_8_byte(X_GLrop_RasterPos4sv, v);
d1297 1
a1297 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1300 4
a1303 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y1), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&x2), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&y2), 8);
d1305 1
a1305 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1312 1
a1312 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1315 2
a1316 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (v1), 16);
    (void) memcpy((void *) (gc->pc + 20), (void *) (v2), 16);
d1318 1
a1318 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1325 1
a1325 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1328 4
a1331 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x1), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x2), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y2), 4);
d1333 1
a1333 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1340 1
a1340 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1343 2
a1344 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (v1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (v2), 8);
d1346 1
a1346 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1353 1
a1353 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1356 4
a1359 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x1), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x2), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y2), 4);
d1361 1
a1361 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1368 1
a1368 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1371 2
a1372 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (v1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (v2), 8);
d1374 1
a1374 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1381 1
a1381 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1384 4
a1387 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x1), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y1), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x2), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y2), 2);
d1389 1
a1389 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1396 1
a1396 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1399 2
a1400 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (v1), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v2), 4);
d1402 1
a1402 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1409 1
a1409 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1412 1
a1412 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
d1414 1
a1414 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1421 1
a1421 1
    generic_8_byte(X_GLrop_TexCoord1dv, v);
d1428 1
a1428 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1431 1
a1431 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
d1433 1
a1433 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1440 1
a1440 1
    generic_4_byte(X_GLrop_TexCoord1fv, v);
d1447 1
a1447 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1450 1
a1450 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
d1452 1
a1452 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1459 1
a1459 1
    generic_4_byte(X_GLrop_TexCoord1iv, v);
d1466 1
a1466 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1469 1
a1469 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 2);
d1471 1
a1471 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1478 1
a1478 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1481 1
a1481 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 2);
d1483 1
a1483 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1490 1
a1490 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1493 2
a1494 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
d1496 1
a1496 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1503 1
a1503 1
    generic_16_byte(X_GLrop_TexCoord2dv, v);
d1510 1
a1510 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1513 2
a1514 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
d1516 1
a1516 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1523 1
a1523 1
    generic_8_byte(X_GLrop_TexCoord2fv, v);
d1530 1
a1530 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1533 2
a1534 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
d1536 1
a1536 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1543 1
a1543 1
    generic_8_byte(X_GLrop_TexCoord2iv, v);
d1550 1
a1550 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1553 2
a1554 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&t), 2);
d1556 1
a1556 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1563 1
a1563 1
    generic_4_byte(X_GLrop_TexCoord2sv, v);
d1570 1
a1570 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1573 3
a1575 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&r), 8);
d1577 1
a1577 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1584 1
a1584 1
    generic_24_byte(X_GLrop_TexCoord3dv, v);
d1591 1
a1591 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1594 3
a1596 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 4);
d1598 1
a1598 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1605 1
a1605 1
    generic_12_byte(X_GLrop_TexCoord3fv, v);
d1612 1
a1612 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1615 3
a1617 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 4);
d1619 1
a1619 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1626 1
a1626 1
    generic_12_byte(X_GLrop_TexCoord3iv, v);
d1633 1
a1633 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1636 3
a1638 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&t), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&r), 2);
d1640 1
a1640 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1647 1
a1647 1
    generic_6_byte(X_GLrop_TexCoord3sv, v);
d1654 1
a1654 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1657 4
a1660 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&r), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&q), 8);
d1662 1
a1662 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1669 1
a1669 1
    generic_32_byte(X_GLrop_TexCoord4dv, v);
d1676 1
a1676 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1679 4
a1682 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&q), 4);
d1684 1
a1684 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1691 1
a1691 1
    generic_16_byte(X_GLrop_TexCoord4fv, v);
d1698 1
a1698 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1701 4
a1704 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&q), 4);
d1706 1
a1706 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1713 1
a1713 1
    generic_16_byte(X_GLrop_TexCoord4iv, v);
d1720 1
a1720 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1723 4
a1726 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&t), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&r), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&q), 2);
d1728 1
a1728 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1735 1
a1735 1
    generic_8_byte(X_GLrop_TexCoord4sv, v);
d1742 1
a1742 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1745 2
a1746 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
d1748 1
a1748 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1755 1
a1755 1
    generic_16_byte(X_GLrop_Vertex2dv, v);
d1762 1
a1762 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1765 2
a1766 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
d1768 1
a1768 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1775 1
a1775 1
    generic_8_byte(X_GLrop_Vertex2fv, v);
d1782 1
a1782 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1785 2
a1786 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
d1788 1
a1788 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1795 1
a1795 1
    generic_8_byte(X_GLrop_Vertex2iv, v);
d1802 1
a1802 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1805 2
a1806 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
d1808 1
a1808 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1815 1
a1815 1
    generic_4_byte(X_GLrop_Vertex2sv, v);
d1822 1
a1822 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1825 3
a1827 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
d1829 1
a1829 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1836 1
a1836 1
    generic_24_byte(X_GLrop_Vertex3dv, v);
d1843 1
a1843 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1846 3
a1848 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
d1850 1
a1850 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1857 1
a1857 1
    generic_12_byte(X_GLrop_Vertex3fv, v);
d1864 1
a1864 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1867 3
a1869 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
d1871 1
a1871 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1878 1
a1878 1
    generic_12_byte(X_GLrop_Vertex3iv, v);
d1885 1
a1885 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1888 3
a1890 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&z), 2);
d1892 1
a1892 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1899 1
a1899 1
    generic_6_byte(X_GLrop_Vertex3sv, v);
d1906 1
a1906 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1909 4
a1912 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&w), 8);
d1914 1
a1914 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1921 1
a1921 1
    generic_32_byte(X_GLrop_Vertex4dv, v);
d1928 1
a1928 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1931 4
a1934 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&w), 4);
d1936 1
a1936 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1943 1
a1943 1
    generic_16_byte(X_GLrop_Vertex4fv, v);
d1950 1
a1950 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1953 4
a1956 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&w), 4);
d1958 1
a1958 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1965 1
a1965 1
    generic_16_byte(X_GLrop_Vertex4iv, v);
d1972 1
a1972 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1975 4
a1978 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&z), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&w), 2);
d1980 1
a1980 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d1987 1
a1987 1
    generic_8_byte(X_GLrop_Vertex4sv, v);
d1994 1
a1994 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d1997 2
a1998 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (equation), 32);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&plane), 4);
d2000 1
a2000 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2007 1
a2007 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2010 2
a2011 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&mode), 4);
d2013 1
a2013 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2020 1
a2020 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2023 1
a2023 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
d2025 1
a2025 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2032 1
a2032 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2035 2
a2036 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
d2038 1
a2038 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2045 1
a2045 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2049 2
a2050 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
d2052 1
a2052 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2059 1
a2059 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2062 2
a2063 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
d2065 1
a2065 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2072 1
a2072 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2076 2
a2077 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
d2079 1
a2079 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2086 1
a2086 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2089 1
a2089 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
d2091 1
a2091 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2098 1
a2098 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2101 2
a2102 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&mode), 4);
d2104 1
a2104 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2111 1
a2111 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2114 3
a2116 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&light), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2118 1
a2118 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2125 1
a2125 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2129 3
a2131 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&light), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2133 1
a2133 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2140 1
a2140 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2143 3
a2145 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&light), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2147 1
a2147 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2154 1
a2154 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2158 3
a2160 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&light), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2162 1
a2162 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2169 1
a2169 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2172 2
a2173 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
d2175 1
a2175 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2182 1
a2182 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2186 2
a2187 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
d2189 1
a2189 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2196 1
a2196 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2199 2
a2200 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
d2202 1
a2202 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2209 1
a2209 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2213 2
a2214 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
d2216 1
a2216 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2223 1
a2223 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2226 2
a2227 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&factor), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pattern), 2);
d2229 1
a2229 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2236 1
a2236 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2239 1
a2239 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&width), 4);
d2241 1
a2241 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2248 1
a2248 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2251 3
a2253 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2255 1
a2255 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2262 1
a2262 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2266 3
a2268 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2270 1
a2270 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2277 1
a2277 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2280 3
a2282 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2284 1
a2284 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2291 1
a2291 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2295 3
a2297 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2299 1
a2299 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2306 1
a2306 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2309 1
a2309 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&size), 4);
d2311 1
a2311 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2318 1
a2318 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2321 2
a2322 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&mode), 4);
d2324 1
a2324 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2331 2
a2332 4
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (mask != NULL) ? __glImageSize(32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                                       0) : 0;
d2336 4
a2339 5
        (*gc->fillImage) (gc, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP, mask,
                          gc->pc + 24, gc->pc + 4);
    } else {
        (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                      default_pixel_store_2D_size);
d2342 1
a2342 3
    if (gc->pc > gc->limit) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2349 1
a2349 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2352 4
a2355 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&height), 4);
d2357 1
a2357 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2364 1
a2364 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2367 1
a2367 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
d2369 1
a2369 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2376 1
a2376 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2379 3
a2381 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2383 1
a2383 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2388 1
a2388 2
__indirect_glTexParameterfv(GLenum target, GLenum pname,
                            const GLfloat * params)
d2390 1
a2390 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2394 3
a2396 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2398 1
a2398 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2405 1
a2405 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2408 3
a2410 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2412 1
a2412 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2419 1
a2419 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2423 3
a2425 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2427 1
a2427 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2431 4
a2434 8
__glx_TexImage_1D2D(unsigned opcode, unsigned dim, GLenum target, GLint level,
                    GLint internalformat, GLsizei width, GLsizei height,
                    GLint border, GLenum format, GLenum type,
                    const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        __glImageSize(width, height, 1, format, type, target);
d2438 1
a2438 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d2442 8
a2449 9
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&level), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&internalformat),
                          4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&border), 4);
            (void) memcpy((void *) (gc->pc + 48), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 52), (void *) (&type), 4);
d2451 4
a2454 5
                (*gc->fillImage) (gc, dim, width, height, 1, format, type,
                                  pixels, gc->pc + 56, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
d2457 3
a2459 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d2462 12
a2473 13
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&level), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&internalformat), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&border), 4);
            (void) memcpy((void *) (pc + 52), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 56), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format,
                                type, pixels, pc + 60, pc + 8);
d2480 1
a2480 3
__indirect_glTexImage1D(GLenum target, GLint level, GLint internalformat,
                        GLsizei width, GLint border, GLenum format,
                        GLenum type, const GLvoid * pixels)
d2482 1
a2482 2
    __glx_TexImage_1D2D(X_GLrop_TexImage1D, 1, target, level, internalformat,
                        width, 1, border, format, type, pixels);
d2487 1
a2487 3
__indirect_glTexImage2D(GLenum target, GLint level, GLint internalformat,
                        GLsizei width, GLsizei height, GLint border,
                        GLenum format, GLenum type, const GLvoid * pixels)
d2489 1
a2489 2
    __glx_TexImage_1D2D(X_GLrop_TexImage2D, 2, target, level, internalformat,
                        width, height, border, format, type, pixels);
d2496 1
a2496 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2499 3
a2501 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2503 1
a2503 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2510 1
a2510 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2514 3
a2516 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2518 1
a2518 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2525 1
a2525 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2528 3
a2530 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2532 1
a2532 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2539 1
a2539 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2543 3
a2545 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2547 1
a2547 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2554 1
a2554 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2557 3
a2559 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&param), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&pname), 4);
d2561 1
a2561 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2568 1
a2568 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2572 3
a2574 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 8));
d2576 1
a2576 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2583 1
a2583 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2586 3
a2588 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2590 1
a2590 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2597 1
a2597 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2601 3
a2603 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2605 1
a2605 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2612 1
a2612 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2615 3
a2617 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&param), 4);
d2619 1
a2619 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2626 1
a2626 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2630 3
a2632 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d2634 1
a2634 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2641 1
a2641 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2645 1
a2645 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2652 1
a2652 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2655 1
a2655 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&name), 4);
d2657 1
a2657 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2664 1
a2664 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2667 1
a2667 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&token), 4);
d2669 1
a2669 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2676 1
a2676 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2680 1
a2680 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2687 1
a2687 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2690 1
a2690 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&name), 4);
d2692 1
a2692 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2699 1
a2699 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2702 1
a2702 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
d2704 1
a2704 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2711 1
a2711 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2714 1
a2714 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mask), 4);
d2716 1
a2716 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2721 1
a2721 2
__indirect_glClearAccum(GLfloat red, GLfloat green, GLfloat blue,
                        GLfloat alpha)
d2723 1
a2723 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2726 4
a2729 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
d2731 1
a2731 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2738 1
a2738 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2741 1
a2741 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 4);
d2743 1
a2743 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2748 1
a2748 2
__indirect_glClearColor(GLclampf red, GLclampf green, GLclampf blue,
                        GLclampf alpha)
d2750 1
a2750 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2753 4
a2756 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
d2758 1
a2758 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2765 1
a2765 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2768 1
a2768 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 4);
d2770 1
a2770 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2777 1
a2777 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2780 1
a2780 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&depth), 8);
d2782 1
a2782 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2789 1
a2789 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2792 1
a2792 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mask), 4);
d2794 1
a2794 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2799 1
a2799 2
__indirect_glColorMask(GLboolean red, GLboolean green, GLboolean blue,
                       GLboolean alpha)
d2801 1
a2801 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2804 4
a2807 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
    (void) memcpy((void *) (gc->pc + 7), (void *) (&alpha), 1);
d2809 1
a2809 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2816 1
a2816 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2819 1
a2819 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&flag), 1);
d2821 1
a2821 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2828 1
a2828 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2831 1
a2831 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mask), 4);
d2833 1
a2833 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2840 1
a2840 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2843 2
a2844 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&op), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&value), 4);
d2846 1
a2846 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2853 1
a2853 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2857 1
a2857 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2864 1
a2864 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2867 1
a2867 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mask), 4);
d2869 1
a2869 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2876 1
a2876 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2879 3
a2881 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&u2), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&un), 4);
d2883 1
a2883 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2890 1
a2890 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2893 3
a2895 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&un), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&u1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&u2), 4);
d2897 1
a2897 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2902 1
a2902 2
__indirect_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn,
                       GLdouble v1, GLdouble v2)
d2904 1
a2904 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2907 6
a2912 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u1), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&u2), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&v1), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&v2), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&un), 4);
    (void) memcpy((void *) (gc->pc + 40), (void *) (&vn), 4);
d2914 1
a2914 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2919 1
a2919 2
__indirect_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1,
                       GLfloat v2)
d2921 1
a2921 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2924 6
a2929 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&un), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&u1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&u2), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&vn), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&v1), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&v2), 4);
d2931 1
a2931 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2938 1
a2938 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2941 1
a2941 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u), 8);
d2943 1
a2943 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2950 1
a2950 1
    generic_8_byte(X_GLrop_EvalCoord1dv, u);
d2957 1
a2957 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2960 1
a2960 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u), 4);
d2962 1
a2962 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2969 1
a2969 1
    generic_4_byte(X_GLrop_EvalCoord1fv, u);
d2976 1
a2976 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2979 2
a2980 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&v), 8);
d2982 1
a2982 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d2989 1
a2989 1
    generic_16_byte(X_GLrop_EvalCoord2dv, u);
d2996 1
a2996 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d2999 2
a3000 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&u), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&v), 4);
d3002 1
a3002 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3009 1
a3009 1
    generic_8_byte(X_GLrop_EvalCoord2fv, u);
d3016 1
a3016 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3019 3
a3021 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&i1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&i2), 4);
d3023 1
a3023 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3030 1
a3030 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3033 1
a3033 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&i), 4);
d3035 1
a3035 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3042 1
a3042 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3045 5
a3049 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&i1), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&i2), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&j1), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&j2), 4);
d3051 1
a3051 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3058 1
a3058 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3061 2
a3062 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&i), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&j), 4);
d3064 1
a3064 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3071 1
a3071 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3074 2
a3075 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&func), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&ref), 4);
d3077 1
a3077 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3084 1
a3084 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3087 2
a3088 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&sfactor), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&dfactor), 4);
d3090 1
a3090 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3097 1
a3097 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3100 1
a3100 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&opcode), 4);
d3102 1
a3102 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3109 1
a3109 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3112 3
a3114 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&func), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&ref), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&mask), 4);
d3116 1
a3116 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3123 1
a3123 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3126 3
a3128 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&fail), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&zfail), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&zpass), 4);
d3130 1
a3130 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3137 1
a3137 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3140 1
a3140 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&func), 4);
d3142 1
a3142 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3149 1
a3149 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3152 2
a3153 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&xfactor), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&yfactor), 4);
d3155 1
a3155 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3162 1
a3162 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3165 2
a3166 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
d3168 1
a3168 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3175 1
a3175 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3178 2
a3179 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
d3181 1
a3181 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3188 1
a3188 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3192 1
a3192 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d3196 3
a3198 4
            (void) memcpy((void *) (gc->pc + 4), (void *) (&map), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&mapsize), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (values),
                          (mapsize * 4));
d3200 3
a3202 4
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d3205 5
a3209 5
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&map), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&mapsize), 4);
d3219 1
a3219 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3223 1
a3223 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d3227 3
a3229 4
            (void) memcpy((void *) (gc->pc + 4), (void *) (&map), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&mapsize), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (values),
                          (mapsize * 4));
d3231 3
a3233 4
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d3236 5
a3240 5
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&map), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&mapsize), 4);
d3250 1
a3250 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3254 1
a3254 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d3258 3
a3260 4
            (void) memcpy((void *) (gc->pc + 4), (void *) (&map), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&mapsize), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (values),
                          (mapsize * 2));
d3262 3
a3264 4
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d3267 5
a3271 5
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&map), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&mapsize), 4);
d3281 1
a3281 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3284 1
a3284 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
d3286 1
a3286 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3291 1
a3291 2
__indirect_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                        GLenum type)
d3293 1
a3293 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d3296 5
a3300 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&height), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&type), 4);
d3302 1
a3302 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d3307 1
a3307 2
__indirect_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                        GLenum format, GLenum type, GLvoid * pixels)
d3309 3
a3311 3
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
d3315 1
a3315 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3317 15
a3331 29
        xcb_glx_read_pixels_reply_t *reply =
            xcb_glx_read_pixels_reply(c,
                                      xcb_glx_read_pixels(c,
                                                          gc->
                                                          currentContextTag,
                                                          x, y, width, height,
                                                          format, type,
                                                          state->storePack.
                                                          swapEndian, 0),
                                      NULL);
        (void) memcpy(pixels, xcb_glx_read_pixels_data(reply),
                      xcb_glx_read_pixels_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_ReadPixels, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&x), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&y), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&width), 4);
        (void) memcpy((void *) (pc + 12), (void *) (&height), 4);
        (void) memcpy((void *) (pc + 16), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 20), (void *) (&type), 4);
        *(int32_t *) (pc + 24) = 0;
        *(int8_t *) (pc + 24) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 2, width, height, 1, format, type,
                            pixels, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
d3339 1
a3339 2
__indirect_glDrawPixels(GLsizei width, GLsizei height, GLenum format,
                        GLenum type, const GLvoid * pixels)
d3341 2
a3342 4
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (pixels != NULL) ? __glImageSize(width, height, 1, format, type,
                                         0) : 0;
d3346 1
a3346 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d3350 4
a3353 4
            (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&type), 4);
d3355 4
a3358 5
                (*gc->fillImage) (gc, 2, width, height, 1, format, type,
                                  pixels, gc->pc + 40, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
d3361 3
a3363 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d3366 8
a3373 9
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, 2, width, height, 1, format,
                                type, pixels, pc + 44, pc + 8);
d3382 2
a3383 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3387 1
a3387 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3389 6
a3394 14
        xcb_glx_get_clip_plane_reply_t *reply =
            xcb_glx_get_clip_plane_reply(c,
                                         xcb_glx_get_clip_plane(c,
                                                                gc->
                                                                currentContextTag,
                                                                plane), NULL);
        (void) memcpy(equation, xcb_glx_get_clip_plane_data(reply),
                      xcb_glx_get_clip_plane_data_length(reply) *
                      sizeof(GLdouble));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetClipPlane, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&plane), 4);
d3396 1
a3396 2
        UnlockDisplay(dpy);
        SyncHandle();
d3406 2
a3407 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3411 1
a3411 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3413 3
a3415 9
        xcb_glx_get_lightfv_reply_t *reply =
            xcb_glx_get_lightfv_reply(c,
                                      xcb_glx_get_lightfv(c,
                                                          gc->
                                                          currentContextTag,
                                                          light, pname),
                                      NULL);
        if (xcb_glx_get_lightfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3417 1
a3417 3
            (void) memcpy(params, xcb_glx_get_lightfv_data(reply),
                          xcb_glx_get_lightfv_data_length(reply) *
                          sizeof(GLfloat));
d3420 3
a3422 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetLightfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&light), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3424 1
a3424 2
        UnlockDisplay(dpy);
        SyncHandle();
d3434 2
a3435 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3439 1
a3439 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3441 3
a3443 9
        xcb_glx_get_lightiv_reply_t *reply =
            xcb_glx_get_lightiv_reply(c,
                                      xcb_glx_get_lightiv(c,
                                                          gc->
                                                          currentContextTag,
                                                          light, pname),
                                      NULL);
        if (xcb_glx_get_lightiv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3445 1
a3445 3
            (void) memcpy(params, xcb_glx_get_lightiv_data(reply),
                          xcb_glx_get_lightiv_data_length(reply) *
                          sizeof(GLint));
d3448 3
a3450 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetLightiv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&light), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3452 1
a3452 2
        UnlockDisplay(dpy);
        SyncHandle();
d3462 2
a3463 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3467 1
a3467 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3469 3
a3471 7
        xcb_glx_get_mapdv_reply_t *reply =
            xcb_glx_get_mapdv_reply(c,
                                    xcb_glx_get_mapdv(c,
                                                      gc->currentContextTag,
                                                      target, query), NULL);
        if (xcb_glx_get_mapdv_data_length(reply) == 0)
            (void) memcpy(v, &reply->datum, sizeof(reply->datum));
d3473 1
a3473 3
            (void) memcpy(v, xcb_glx_get_mapdv_data(reply),
                          xcb_glx_get_mapdv_data_length(reply) *
                          sizeof(GLdouble));
d3476 3
a3478 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMapdv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&query), 4);
d3480 1
a3480 2
        UnlockDisplay(dpy);
        SyncHandle();
d3490 2
a3491 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3495 1
a3495 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3497 3
a3499 7
        xcb_glx_get_mapfv_reply_t *reply =
            xcb_glx_get_mapfv_reply(c,
                                    xcb_glx_get_mapfv(c,
                                                      gc->currentContextTag,
                                                      target, query), NULL);
        if (xcb_glx_get_mapfv_data_length(reply) == 0)
            (void) memcpy(v, &reply->datum, sizeof(reply->datum));
d3501 1
a3501 3
            (void) memcpy(v, xcb_glx_get_mapfv_data(reply),
                          xcb_glx_get_mapfv_data_length(reply) *
                          sizeof(GLfloat));
d3504 3
a3506 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMapfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&query), 4);
d3508 1
a3508 2
        UnlockDisplay(dpy);
        SyncHandle();
d3518 2
a3519 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3523 1
a3523 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3525 3
a3527 7
        xcb_glx_get_mapiv_reply_t *reply =
            xcb_glx_get_mapiv_reply(c,
                                    xcb_glx_get_mapiv(c,
                                                      gc->currentContextTag,
                                                      target, query), NULL);
        if (xcb_glx_get_mapiv_data_length(reply) == 0)
            (void) memcpy(v, &reply->datum, sizeof(reply->datum));
d3529 1
a3529 3
            (void) memcpy(v, xcb_glx_get_mapiv_data(reply),
                          xcb_glx_get_mapiv_data_length(reply) *
                          sizeof(GLint));
d3532 3
a3534 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMapiv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&query), 4);
d3536 1
a3536 2
        UnlockDisplay(dpy);
        SyncHandle();
d3546 2
a3547 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3551 1
a3551 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3553 3
a3555 9
        xcb_glx_get_materialfv_reply_t *reply =
            xcb_glx_get_materialfv_reply(c,
                                         xcb_glx_get_materialfv(c,
                                                                gc->
                                                                currentContextTag,
                                                                face, pname),
                                         NULL);
        if (xcb_glx_get_materialfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3557 1
a3557 3
            (void) memcpy(params, xcb_glx_get_materialfv_data(reply),
                          xcb_glx_get_materialfv_data_length(reply) *
                          sizeof(GLfloat));
d3560 3
a3562 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMaterialfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&face), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3564 1
a3564 2
        UnlockDisplay(dpy);
        SyncHandle();
d3574 2
a3575 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3579 1
a3579 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3581 3
a3583 9
        xcb_glx_get_materialiv_reply_t *reply =
            xcb_glx_get_materialiv_reply(c,
                                         xcb_glx_get_materialiv(c,
                                                                gc->
                                                                currentContextTag,
                                                                face, pname),
                                         NULL);
        if (xcb_glx_get_materialiv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3585 1
a3585 3
            (void) memcpy(params, xcb_glx_get_materialiv_data(reply),
                          xcb_glx_get_materialiv_data_length(reply) *
                          sizeof(GLint));
d3588 3
a3590 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMaterialiv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&face), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3592 1
a3592 2
        UnlockDisplay(dpy);
        SyncHandle();
d3602 2
a3603 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3607 1
a3607 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3609 3
a3611 8
        xcb_glx_get_pixel_mapfv_reply_t *reply =
            xcb_glx_get_pixel_mapfv_reply(c,
                                          xcb_glx_get_pixel_mapfv(c,
                                                                  gc->
                                                                  currentContextTag,
                                                                  map), NULL);
        if (xcb_glx_get_pixel_mapfv_data_length(reply) == 0)
            (void) memcpy(values, &reply->datum, sizeof(reply->datum));
d3613 1
a3613 3
            (void) memcpy(values, xcb_glx_get_pixel_mapfv_data(reply),
                          xcb_glx_get_pixel_mapfv_data_length(reply) *
                          sizeof(GLfloat));
d3616 2
a3617 3
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&map), 4);
d3619 1
a3619 2
        UnlockDisplay(dpy);
        SyncHandle();
d3629 2
a3630 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3634 1
a3634 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3636 3
a3638 9
        xcb_glx_get_pixel_mapuiv_reply_t *reply =
            xcb_glx_get_pixel_mapuiv_reply(c,
                                           xcb_glx_get_pixel_mapuiv(c,
                                                                    gc->
                                                                    currentContextTag,
                                                                    map),
                                           NULL);
        if (xcb_glx_get_pixel_mapuiv_data_length(reply) == 0)
            (void) memcpy(values, &reply->datum, sizeof(reply->datum));
d3640 1
a3640 3
            (void) memcpy(values, xcb_glx_get_pixel_mapuiv_data(reply),
                          xcb_glx_get_pixel_mapuiv_data_length(reply) *
                          sizeof(GLuint));
d3643 2
a3644 3
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapuiv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&map), 4);
d3646 1
a3646 2
        UnlockDisplay(dpy);
        SyncHandle();
d3656 2
a3657 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3661 1
a3661 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3663 3
a3665 9
        xcb_glx_get_pixel_mapusv_reply_t *reply =
            xcb_glx_get_pixel_mapusv_reply(c,
                                           xcb_glx_get_pixel_mapusv(c,
                                                                    gc->
                                                                    currentContextTag,
                                                                    map),
                                           NULL);
        if (xcb_glx_get_pixel_mapusv_data_length(reply) == 0)
            (void) memcpy(values, &reply->datum, sizeof(reply->datum));
d3667 1
a3667 3
            (void) memcpy(values, xcb_glx_get_pixel_mapusv_data(reply),
                          xcb_glx_get_pixel_mapusv_data_length(reply) *
                          sizeof(GLushort));
d3670 2
a3671 3
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetPixelMapusv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&map), 4);
d3673 1
a3673 2
        UnlockDisplay(dpy);
        SyncHandle();
d3683 3
a3685 3
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
d3689 1
a3689 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3691 8
a3698 19
        xcb_glx_get_polygon_stipple_reply_t *reply =
            xcb_glx_get_polygon_stipple_reply(c,
                                              xcb_glx_get_polygon_stipple(c,
                                                                          gc->
                                                                          currentContextTag,
                                                                          0),
                                              NULL);
        (void) memcpy(mask, xcb_glx_get_polygon_stipple_data(reply),
                      xcb_glx_get_polygon_stipple_data_length(reply) *
                      sizeof(GLubyte));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetPolygonStipple, cmdlen);
        *(int32_t *) (pc + 0) = 0;
        __glXReadPixelReply(dpy, gc, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                            mask, GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
d3708 2
a3709 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3713 1
a3713 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3715 3
a3717 9
        xcb_glx_get_tex_envfv_reply_t *reply =
            xcb_glx_get_tex_envfv_reply(c,
                                        xcb_glx_get_tex_envfv(c,
                                                              gc->
                                                              currentContextTag,
                                                              target, pname),
                                        NULL);
        if (xcb_glx_get_tex_envfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3719 1
a3719 3
            (void) memcpy(params, xcb_glx_get_tex_envfv_data(reply),
                          xcb_glx_get_tex_envfv_data_length(reply) *
                          sizeof(GLfloat));
d3722 3
a3724 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexEnvfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3726 1
a3726 2
        UnlockDisplay(dpy);
        SyncHandle();
d3736 2
a3737 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3741 1
a3741 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3743 3
a3745 9
        xcb_glx_get_tex_enviv_reply_t *reply =
            xcb_glx_get_tex_enviv_reply(c,
                                        xcb_glx_get_tex_enviv(c,
                                                              gc->
                                                              currentContextTag,
                                                              target, pname),
                                        NULL);
        if (xcb_glx_get_tex_enviv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3747 1
a3747 3
            (void) memcpy(params, xcb_glx_get_tex_enviv_data(reply),
                          xcb_glx_get_tex_enviv_data_length(reply) *
                          sizeof(GLint));
d3750 3
a3752 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexEnviv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3754 1
a3754 2
        UnlockDisplay(dpy);
        SyncHandle();
d3764 2
a3765 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3769 1
a3769 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3771 3
a3773 9
        xcb_glx_get_tex_gendv_reply_t *reply =
            xcb_glx_get_tex_gendv_reply(c,
                                        xcb_glx_get_tex_gendv(c,
                                                              gc->
                                                              currentContextTag,
                                                              coord, pname),
                                        NULL);
        if (xcb_glx_get_tex_gendv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3775 1
a3775 3
            (void) memcpy(params, xcb_glx_get_tex_gendv_data(reply),
                          xcb_glx_get_tex_gendv_data_length(reply) *
                          sizeof(GLdouble));
d3778 3
a3780 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexGendv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&coord), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3782 1
a3782 2
        UnlockDisplay(dpy);
        SyncHandle();
d3792 2
a3793 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3797 1
a3797 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3799 3
a3801 9
        xcb_glx_get_tex_genfv_reply_t *reply =
            xcb_glx_get_tex_genfv_reply(c,
                                        xcb_glx_get_tex_genfv(c,
                                                              gc->
                                                              currentContextTag,
                                                              coord, pname),
                                        NULL);
        if (xcb_glx_get_tex_genfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3803 1
a3803 3
            (void) memcpy(params, xcb_glx_get_tex_genfv_data(reply),
                          xcb_glx_get_tex_genfv_data_length(reply) *
                          sizeof(GLfloat));
d3806 3
a3808 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexGenfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&coord), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3810 1
a3810 2
        UnlockDisplay(dpy);
        SyncHandle();
d3820 2
a3821 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3825 1
a3825 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3827 3
a3829 9
        xcb_glx_get_tex_geniv_reply_t *reply =
            xcb_glx_get_tex_geniv_reply(c,
                                        xcb_glx_get_tex_geniv(c,
                                                              gc->
                                                              currentContextTag,
                                                              coord, pname),
                                        NULL);
        if (xcb_glx_get_tex_geniv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3831 1
a3831 3
            (void) memcpy(params, xcb_glx_get_tex_geniv_data(reply),
                          xcb_glx_get_tex_geniv_data_length(reply) *
                          sizeof(GLint));
d3834 3
a3836 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexGeniv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&coord), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3838 1
a3838 2
        UnlockDisplay(dpy);
        SyncHandle();
d3846 1
a3846 2
__indirect_glGetTexImage(GLenum target, GLint level, GLenum format,
                         GLenum type, GLvoid * pixels)
d3848 3
a3850 3
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
d3854 1
a3854 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3856 13
a3868 28
        xcb_glx_get_tex_image_reply_t *reply =
            xcb_glx_get_tex_image_reply(c,
                                        xcb_glx_get_tex_image(c,
                                                              gc->
                                                              currentContextTag,
                                                              target, level,
                                                              format, type,
                                                              state->
                                                              storePack.
                                                              swapEndian),
                                        NULL);
        (void) memcpy(pixels, xcb_glx_get_tex_image_data(reply),
                      xcb_glx_get_tex_image_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexImage, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&level), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 12), (void *) (&type), 4);
        *(int32_t *) (pc + 16) = 0;
        *(int8_t *) (pc + 16) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 3, 0, 0, 0, format, type, pixels,
                            GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
d3878 2
a3879 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3883 1
a3883 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3885 3
a3887 10
        xcb_glx_get_tex_parameterfv_reply_t *reply =
            xcb_glx_get_tex_parameterfv_reply(c,
                                              xcb_glx_get_tex_parameterfv(c,
                                                                          gc->
                                                                          currentContextTag,
                                                                          target,
                                                                          pname),
                                              NULL);
        if (xcb_glx_get_tex_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3889 1
a3889 3
            (void) memcpy(params, xcb_glx_get_tex_parameterfv_data(reply),
                          xcb_glx_get_tex_parameterfv_data_length(reply) *
                          sizeof(GLfloat));
d3892 3
a3894 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexParameterfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3896 1
a3896 2
        UnlockDisplay(dpy);
        SyncHandle();
d3906 2
a3907 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3911 1
a3911 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3913 3
a3915 10
        xcb_glx_get_tex_parameteriv_reply_t *reply =
            xcb_glx_get_tex_parameteriv_reply(c,
                                              xcb_glx_get_tex_parameteriv(c,
                                                                          gc->
                                                                          currentContextTag,
                                                                          target,
                                                                          pname),
                                              NULL);
        if (xcb_glx_get_tex_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3917 1
a3917 3
            (void) memcpy(params, xcb_glx_get_tex_parameteriv_data(reply),
                          xcb_glx_get_tex_parameteriv_data_length(reply) *
                          sizeof(GLint));
d3920 3
a3922 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexParameteriv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d3924 1
a3924 2
        UnlockDisplay(dpy);
        SyncHandle();
d3932 1
a3932 2
__indirect_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname,
                                    GLfloat * params)
d3934 2
a3935 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3939 1
a3939 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3941 3
a3943 8
        xcb_glx_get_tex_level_parameterfv_reply_t *reply =
            xcb_glx_get_tex_level_parameterfv_reply(c,
                                                    xcb_glx_get_tex_level_parameterfv
                                                    (c, gc->currentContextTag,
                                                     target, level, pname),
                                                    NULL);
        if (xcb_glx_get_tex_level_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3945 1
a3945 4
            (void) memcpy(params,
                          xcb_glx_get_tex_level_parameterfv_data(reply),
                          xcb_glx_get_tex_level_parameterfv_data_length(reply)
                          * sizeof(GLfloat));
d3948 4
a3951 6
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexLevelParameterfv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&level), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
d3953 1
a3953 2
        UnlockDisplay(dpy);
        SyncHandle();
d3961 1
a3961 2
__indirect_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname,
                                    GLint * params)
d3963 2
a3964 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3968 1
a3968 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d3970 3
a3972 8
        xcb_glx_get_tex_level_parameteriv_reply_t *reply =
            xcb_glx_get_tex_level_parameteriv_reply(c,
                                                    xcb_glx_get_tex_level_parameteriv
                                                    (c, gc->currentContextTag,
                                                     target, level, pname),
                                                    NULL);
        if (xcb_glx_get_tex_level_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d3974 1
a3974 4
            (void) memcpy(params,
                          xcb_glx_get_tex_level_parameteriv_data(reply),
                          xcb_glx_get_tex_level_parameteriv_data_length(reply)
                          * sizeof(GLint));
d3977 4
a3980 6
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetTexLevelParameteriv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&level), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
d3982 1
a3982 2
        UnlockDisplay(dpy);
        SyncHandle();
d3992 2
a3993 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d3998 1
a3998 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d4000 1
a4000 4
        xcb_glx_is_list_reply_t *reply =
            xcb_glx_is_list_reply(c,
                                  xcb_glx_is_list(c, gc->currentContextTag,
                                                  list), NULL);
d4004 2
a4005 3
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_IsList, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&list), 4);
d4007 1
a4007 2
        UnlockDisplay(dpy);
        SyncHandle();
d4017 1
a4017 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4020 2
a4021 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&zNear), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&zFar), 8);
d4023 1
a4023 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4028 1
a4028 2
__indirect_glFrustum(GLdouble left, GLdouble right, GLdouble bottom,
                     GLdouble top, GLdouble zNear, GLdouble zFar)
d4030 1
a4030 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4033 6
a4038 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&left), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&right), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&bottom), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&top), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&zNear), 8);
    (void) memcpy((void *) (gc->pc + 44), (void *) (&zFar), 8);
d4040 1
a4040 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4047 1
a4047 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4051 1
a4051 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4058 1
a4058 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4061 1
a4061 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (m), 64);
d4063 1
a4063 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4070 1
a4070 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4073 1
a4073 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (m), 128);
d4075 1
a4075 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4082 1
a4082 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4085 1
a4085 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
d4087 1
a4087 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4094 1
a4094 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4097 1
a4097 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (m), 64);
d4099 1
a4099 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4106 1
a4106 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4109 1
a4109 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (m), 128);
d4111 1
a4111 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4116 1
a4116 2
__indirect_glOrtho(GLdouble left, GLdouble right, GLdouble bottom,
                   GLdouble top, GLdouble zNear, GLdouble zFar)
d4118 1
a4118 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4121 6
a4126 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&left), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&right), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&bottom), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&top), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&zNear), 8);
    (void) memcpy((void *) (gc->pc + 44), (void *) (&zFar), 8);
d4128 1
a4128 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4135 1
a4135 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4139 1
a4139 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4146 1
a4146 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4150 1
a4150 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4157 1
a4157 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4160 4
a4163 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&angle), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&z), 8);
d4165 1
a4165 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4172 1
a4172 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4175 4
a4178 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&angle), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
d4180 1
a4180 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4187 1
a4187 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4190 3
a4192 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
d4194 1
a4194 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4201 1
a4201 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4204 3
a4206 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
d4208 1
a4208 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4215 1
a4215 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4218 3
a4220 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
d4222 1
a4222 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4229 1
a4229 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4232 3
a4234 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
d4236 1
a4236 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4243 1
a4243 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4246 4
a4249 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&height), 4);
d4251 1
a4251 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4258 1
a4258 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4261 2
a4262 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&texture), 4);
d4264 1
a4264 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4271 1
a4271 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4274 1
a4274 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&c), 1);
d4276 1
a4276 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4283 1
a4283 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4286 1
a4286 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (c), 1);
d4288 1
a4288 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4295 1
a4295 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4298 2
a4299 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&factor), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&units), 4);
d4301 1
a4301 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4306 1
a4306 2
__indirect_glAreTexturesResident(GLsizei n, const GLuint * textures,
                                 GLboolean * residences)
d4308 2
a4309 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d4314 1
a4314 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d4316 2
a4317 8
        xcb_glx_are_textures_resident_reply_t *reply =
            xcb_glx_are_textures_resident_reply(c,
                                                xcb_glx_are_textures_resident
                                                (c, gc->currentContextTag, n,
                                                 textures), NULL);
        (void) memcpy(residences, xcb_glx_are_textures_resident_data(reply),
                      xcb_glx_are_textures_resident_data_length(reply) *
                      sizeof(GLboolean));
d4321 3
a4323 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_AreTexturesResident, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (textures), (n * 4));
d4325 1
a4325 2
        UnlockDisplay(dpy);
        SyncHandle();
a4330 30
#define X_GLvop_AreTexturesResidentEXT 11
GLboolean
glAreTexturesResidentEXT(GLsizei n, const GLuint * textures,
                         GLboolean * residences)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        return CALL_AreTexturesResident(GET_DISPATCH(),
                                        (n, textures, residences));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        GLboolean retval = (GLboolean) 0;
        const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
        if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_AreTexturesResidentEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
            (void) memcpy((void *) (pc + 4), (void *) (textures), (n * 4));
            retval = (GLboolean) __glXReadReply(dpy, 1, residences, GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return retval;
    }
}

d4333 1
a4333 2
__indirect_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat,
                            GLint x, GLint y, GLsizei width, GLint border)
d4335 1
a4335 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4338 7
a4344 7
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&border), 4);
d4346 1
a4346 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4351 1
a4351 3
__indirect_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat,
                            GLint x, GLint y, GLsizei width, GLsizei height,
                            GLint border)
d4353 1
a4353 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4356 8
a4363 8
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&height), 4);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&border), 4);
d4365 1
a4365 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4370 1
a4370 2
__indirect_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                               GLint x, GLint y, GLsizei width)
d4372 1
a4372 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4375 6
a4380 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&xoffset), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&width), 4);
d4382 1
a4382 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4387 1
a4387 3
__indirect_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                               GLint yoffset, GLint x, GLint y, GLsizei width,
                               GLsizei height)
d4389 1
a4389 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4392 8
a4399 8
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&xoffset), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&yoffset), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&height), 4);
d4401 1
a4401 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4404 1
a4404 1
#define X_GLsop_DeleteTextures 144
d4408 2
a4409 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d4412 4
a4415 12
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_delete_textures(c, gc->currentContextTag, n, textures);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_DeleteTextures, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (textures), (n * 4));
        UnlockDisplay(dpy);
        SyncHandle();
#endif /* USE_XCB */
a4419 25
#define X_GLvop_DeleteTexturesEXT 12
void
glDeleteTexturesEXT(GLsizei n, const GLuint * textures)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_DeleteTextures(GET_DISPATCH(), (n, textures));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
        if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivate,
                                        X_GLvop_DeleteTexturesEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
            (void) memcpy((void *) (pc + 4), (void *) (textures), (n * 4));
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d4424 2
a4425 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d4429 1
a4429 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d4431 6
a4436 14
        xcb_glx_gen_textures_reply_t *reply =
            xcb_glx_gen_textures_reply(c,
                                       xcb_glx_gen_textures(c,
                                                            gc->
                                                            currentContextTag,
                                                            n), NULL);
        (void) memcpy(textures, xcb_glx_gen_textures_data(reply),
                      xcb_glx_gen_textures_data_length(reply) *
                      sizeof(GLuint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GenTextures, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
d4438 1
a4438 2
        UnlockDisplay(dpy);
        SyncHandle();
a4443 25
#define X_GLvop_GenTexturesEXT 13
void
glGenTexturesEXT(GLsizei n, GLuint * textures)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GenTextures(GET_DISPATCH(), (n, textures));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 4;
        if (__builtin_expect((n >= 0) && (dpy != NULL), 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GenTexturesEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
            (void) __glXReadReply(dpy, 4, textures, GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d4448 2
a4449 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d4454 1
a4454 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d4456 1
a4456 5
        xcb_glx_is_texture_reply_t *reply =
            xcb_glx_is_texture_reply(c,
                                     xcb_glx_is_texture(c,
                                                        gc->currentContextTag,
                                                        texture), NULL);
d4460 2
a4461 3
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_IsTexture, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&texture), 4);
d4463 1
a4463 2
        UnlockDisplay(dpy);
        SyncHandle();
a4468 26
#define X_GLvop_IsTextureEXT 14
GLboolean
glIsTextureEXT(GLuint texture)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        return CALL_IsTexture(GET_DISPATCH(), (texture));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        GLboolean retval = (GLboolean) 0;
        const GLuint cmdlen = 4;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_IsTextureEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&texture), 4);
            retval = (GLboolean) __glXReadReply(dpy, 0, NULL, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return retval;
    }
}

d4471 1
a4471 2
__indirect_glPrioritizeTextures(GLsizei n, const GLuint * textures,
                                const GLclampf * priorities)
d4473 1
a4473 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4477 3
a4479 4
        (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (textures), (n * 4));
        (void) memcpy((void *) (gc->pc + 8 + (n * 4)), (void *) (priorities),
                      (n * 4));
d4481 1
a4481 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d4486 4
a4489 9
__glx_TexSubImage_1D2D(unsigned opcode, unsigned dim, GLenum target,
                       GLint level, GLint xoffset, GLint yoffset,
                       GLsizei width, GLsizei height, GLenum format,
                       GLenum type, const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (pixels != NULL) ? __glImageSize(width, height, 1, format, type,
                                         target) : 0;
d4493 1
a4493 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d4497 9
a4505 10
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&level), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&xoffset), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&yoffset), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 48), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 52), (void *) (&type), 4);
            (void) memcpy((void *) (gc->pc + 56),
                          (void *) ((pixels == NULL) ? one : zero), 4);
d4507 4
a4510 5
                (*gc->fillImage) (gc, dim, width, height, 1, format, type,
                                  pixels, gc->pc + 60, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
d4513 3
a4515 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d4518 13
a4530 14
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&level), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&xoffset), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&yoffset), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 52), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 56), (void *) (&type), 4);
            (void) memcpy((void *) (pc + 60), zero, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format,
                                type, pixels, pc + 64, pc + 8);
d4537 1
a4537 3
__indirect_glTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                           GLsizei width, GLenum format, GLenum type,
                           const GLvoid * pixels)
d4539 1
a4539 2
    __glx_TexSubImage_1D2D(X_GLrop_TexSubImage1D, 1, target, level, xoffset,
                           1, width, 1, format, type, pixels);
d4544 1
a4544 3
__indirect_glTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                           GLint yoffset, GLsizei width, GLsizei height,
                           GLenum format, GLenum type, const GLvoid * pixels)
d4546 1
a4546 2
    __glx_TexSubImage_1D2D(X_GLrop_TexSubImage2D, 2, target, level, xoffset,
                           yoffset, width, height, format, type, pixels);
d4551 1
a4551 2
__indirect_glBlendColor(GLclampf red, GLclampf green, GLclampf blue,
                        GLclampf alpha)
d4553 1
a4553 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4556 4
a4559 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&alpha), 4);
d4561 1
a4561 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4568 1
a4568 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4571 1
a4571 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&mode), 4);
d4573 1
a4573 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4578 1
a4578 2
__indirect_glColorTable(GLenum target, GLenum internalformat, GLsizei width,
                        GLenum format, GLenum type, const GLvoid * table)
d4580 2
a4581 4
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (table != NULL) ? __glImageSize(width, 1, 1, format, type,
                                        target) : 0;
d4585 1
a4585 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d4589 5
a4593 6
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&internalformat),
                          4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&type), 4);
d4595 4
a4598 5
                (*gc->fillImage) (gc, 1, width, 1, 1, format, type, table,
                                  gc->pc + 44, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_1D,
                              default_pixel_store_1D_size);
d4601 3
a4603 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d4606 9
a4614 10
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&internalformat), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, 1, width, 1, 1, format, type,
                                table, pc + 48, pc + 8);
d4621 1
a4621 2
__indirect_glColorTableParameterfv(GLenum target, GLenum pname,
                                   const GLfloat * params)
d4623 1
a4623 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4627 3
a4629 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d4631 1
a4631 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4636 1
a4636 2
__indirect_glColorTableParameteriv(GLenum target, GLenum pname,
                                   const GLint * params)
d4638 1
a4638 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4642 3
a4644 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d4646 1
a4646 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4651 1
a4651 2
__indirect_glCopyColorTable(GLenum target, GLenum internalformat, GLint x,
                            GLint y, GLsizei width)
d4653 1
a4653 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4656 5
a4660 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&width), 4);
d4662 1
a4662 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4667 1
a4667 2
__indirect_glGetColorTable(GLenum target, GLenum format, GLenum type,
                           GLvoid * table)
d4669 3
a4671 3
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
d4675 14
a4688 30
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_color_table_reply_t *reply =
            xcb_glx_get_color_table_reply(c,
                                          xcb_glx_get_color_table(c,
                                                                  gc->
                                                                  currentContextTag,
                                                                  target,
                                                                  format,
                                                                  type,
                                                                  state->
                                                                  storePack.
                                                                  swapEndian),
                                          NULL);
        (void) memcpy(table, xcb_glx_get_color_table_data(reply),
                      xcb_glx_get_color_table_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetColorTable, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
        *(int32_t *) (pc + 12) = 0;
        *(int8_t *) (pc + 12) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, table,
                            GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
a4693 31
#define X_GLvop_GetColorTableSGI 4098
void
glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid * table)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetColorTable(GET_DISPATCH(), (target, format, type, table));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        const __GLXattribute *const state = gc->client_state_private;
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 16;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetColorTableSGI, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
            *(int32_t *) (pc + 12) = 0;
            *(int8_t *) (pc + 12) = state->storePack.swapEndian;
            __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, table,
                                GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d4696 1
a4696 2
__indirect_glGetColorTableParameterfv(GLenum target, GLenum pname,
                                      GLfloat * params)
d4698 2
a4699 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d4703 1
a4703 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d4705 3
a4707 8
        xcb_glx_get_color_table_parameterfv_reply_t *reply =
            xcb_glx_get_color_table_parameterfv_reply(c,
                                                      xcb_glx_get_color_table_parameterfv
                                                      (c,
                                                       gc->currentContextTag,
                                                       target, pname), NULL);
        if (xcb_glx_get_color_table_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d4709 1
a4709 4
            (void) memcpy(params,
                          xcb_glx_get_color_table_parameterfv_data(reply),
                          xcb_glx_get_color_table_parameterfv_data_length
                          (reply) * sizeof(GLfloat));
d4712 3
a4714 5
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetColorTableParameterfv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d4716 1
a4716 2
        UnlockDisplay(dpy);
        SyncHandle();
d4722 1
a4722 1
#define X_GLvop_GetColorTableParameterfvSGI 4099
d4724 1
a4724 1
glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat * params)
d4726 4
a4729 33
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetColorTableParameterfv(GET_DISPATCH(),
                                      (target, pname, params));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetColorTableParameterfvSGI,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

#define X_GLsop_GetColorTableParameteriv 149
void
__indirect_glGetColorTableParameteriv(GLenum target, GLenum pname,
                                      GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 8;
    if (__builtin_expect(dpy != NULL, 1)) {
d4731 1
a4731 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d4733 3
a4735 8
        xcb_glx_get_color_table_parameteriv_reply_t *reply =
            xcb_glx_get_color_table_parameteriv_reply(c,
                                                      xcb_glx_get_color_table_parameteriv
                                                      (c,
                                                       gc->currentContextTag,
                                                       target, pname), NULL);
        if (xcb_glx_get_color_table_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d4737 1
a4737 4
            (void) memcpy(params,
                          xcb_glx_get_color_table_parameteriv_data(reply),
                          xcb_glx_get_color_table_parameteriv_data_length
                          (reply) * sizeof(GLint));
d4740 3
a4742 5
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetColorTableParameteriv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d4744 1
a4744 2
        UnlockDisplay(dpy);
        SyncHandle();
a4749 28
#define X_GLvop_GetColorTableParameterivSGI 4100
void
glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetColorTableParameteriv(GET_DISPATCH(),
                                      (target, pname, params));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetColorTableParameterivSGI,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d4752 1
a4752 2
__indirect_glColorSubTable(GLenum target, GLsizei start, GLsizei count,
                           GLenum format, GLenum type, const GLvoid * data)
d4754 2
a4755 3
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (data != NULL) ? __glImageSize(count, 1, 1, format, type, target) : 0;
d4759 1
a4759 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d4763 5
a4767 5
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&start), 4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&count), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&type), 4);
d4769 4
a4772 5
                (*gc->fillImage) (gc, 1, count, 1, 1, format, type, data,
                                  gc->pc + 44, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_1D,
                              default_pixel_store_1D_size);
d4775 3
a4777 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d4780 9
a4788 10
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&start), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&count), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, 1, count, 1, 1, format, type,
                                data, pc + 48, pc + 8);
d4795 1
a4795 2
__indirect_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y,
                               GLsizei width)
d4797 1
a4797 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4800 5
a4804 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&start), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&width), 4);
d4806 1
a4806 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4810 4
a4813 9
__glx_ConvolutionFilter_1D2D(unsigned opcode, unsigned dim, GLenum target,
                             GLenum internalformat, GLsizei width,
                             GLsizei height, GLenum format, GLenum type,
                             const GLvoid * image)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (image != NULL) ? __glImageSize(width, height, 1, format, type,
                                        target) : 0;
d4817 1
a4817 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d4821 6
a4826 7
            (void) memcpy((void *) (gc->pc + 24), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 28), (void *) (&internalformat),
                          4);
            (void) memcpy((void *) (gc->pc + 32), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 36), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 40), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&type), 4);
d4828 4
a4831 5
                (*gc->fillImage) (gc, dim, width, height, 1, format, type,
                                  image, gc->pc + 48, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_2D,
                              default_pixel_store_2D_size);
d4834 3
a4836 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d4839 10
a4848 11
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 28), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 32), (void *) (&internalformat), 4);
            (void) memcpy((void *) (pc + 36), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 40), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&type), 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, 1, format,
                                type, image, pc + 52, pc + 8);
d4855 3
a4857 7
__indirect_glConvolutionFilter1D(GLenum target, GLenum internalformat,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid * image)
{
    __glx_ConvolutionFilter_1D2D(X_GLrop_ConvolutionFilter1D, 1, target,
                                 internalformat, width, 1, format, type,
                                 image);
d4862 3
a4864 7
__indirect_glConvolutionFilter2D(GLenum target, GLenum internalformat,
                                 GLsizei width, GLsizei height, GLenum format,
                                 GLenum type, const GLvoid * image)
{
    __glx_ConvolutionFilter_1D2D(X_GLrop_ConvolutionFilter2D, 2, target,
                                 internalformat, width, height, format, type,
                                 image);
d4869 1
a4869 2
__indirect_glConvolutionParameterf(GLenum target, GLenum pname,
                                   GLfloat params)
d4871 1
a4871 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4874 3
a4876 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&params), 4);
d4878 1
a4878 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4883 1
a4883 2
__indirect_glConvolutionParameterfv(GLenum target, GLenum pname,
                                    const GLfloat * params)
d4885 1
a4885 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4889 3
a4891 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d4893 1
a4893 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4900 1
a4900 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4903 3
a4905 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&params), 4);
d4907 1
a4907 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4912 1
a4912 2
__indirect_glConvolutionParameteriv(GLenum target, GLenum pname,
                                    const GLint * params)
d4914 1
a4914 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4918 3
a4920 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), (compsize * 4));
d4922 1
a4922 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4927 1
a4927 2
__indirect_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat,
                                     GLint x, GLint y, GLsizei width)
d4929 1
a4929 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4932 5
a4936 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&width), 4);
d4938 1
a4938 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4943 1
a4943 3
__indirect_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat,
                                     GLint x, GLint y, GLsizei width,
                                     GLsizei height)
d4945 1
a4945 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d4948 6
a4953 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&height), 4);
d4955 1
a4955 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d4960 1
a4960 2
__indirect_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type,
                                  GLvoid * image)
d4962 20
a4981 31
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 16;
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_convolution_filter_reply_t *reply =
            xcb_glx_get_convolution_filter_reply(c,
                                                 xcb_glx_get_convolution_filter
                                                 (c, gc->currentContextTag,
                                                  target, format, type,
                                                  state->storePack.
                                                  swapEndian), NULL);
        (void) memcpy(image, xcb_glx_get_convolution_filter_data(reply),
                      xcb_glx_get_convolution_filter_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionFilter, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
        *(int32_t *) (pc + 12) = 0;
        *(int8_t *) (pc + 12) = state->storePack.swapEndian;
        __glXReadPixelReply(dpy, gc, 2, 0, 0, 0, format, type, image,
                            GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
a4986 34
#define X_GLvop_GetConvolutionFilterEXT 1
void
gl_dispatch_stub_356(GLenum target, GLenum format, GLenum type,
                     GLvoid * image)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetConvolutionFilter(GET_DISPATCH(),
                                  (target, format, type, image));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        const __GLXattribute *const state = gc->client_state_private;
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 16;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetConvolutionFilterEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
            *(int32_t *) (pc + 12) = 0;
            *(int8_t *) (pc + 12) = state->storePack.swapEndian;
            __glXReadPixelReply(dpy, gc, 2, 0, 0, 0, format, type, image,
                                GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d4989 1
a4989 2
__indirect_glGetConvolutionParameterfv(GLenum target, GLenum pname,
                                       GLfloat * params)
d4991 2
a4992 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d4996 1
a4996 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d4998 3
a5000 8
        xcb_glx_get_convolution_parameterfv_reply_t *reply =
            xcb_glx_get_convolution_parameterfv_reply(c,
                                                      xcb_glx_get_convolution_parameterfv
                                                      (c,
                                                       gc->currentContextTag,
                                                       target, pname), NULL);
        if (xcb_glx_get_convolution_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d5002 1
a5002 4
            (void) memcpy(params,
                          xcb_glx_get_convolution_parameterfv_data(reply),
                          xcb_glx_get_convolution_parameterfv_data_length
                          (reply) * sizeof(GLfloat));
d5005 3
a5007 5
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionParameterfv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d5009 1
a5009 2
        UnlockDisplay(dpy);
        SyncHandle();
a5014 28
#define X_GLvop_GetConvolutionParameterfvEXT 2
void
gl_dispatch_stub_357(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetConvolutionParameterfv(GET_DISPATCH(),
                                       (target, pname, params));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetConvolutionParameterfvEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d5017 1
a5017 2
__indirect_glGetConvolutionParameteriv(GLenum target, GLenum pname,
                                       GLint * params)
d5019 2
a5020 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d5024 1
a5024 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d5026 3
a5028 8
        xcb_glx_get_convolution_parameteriv_reply_t *reply =
            xcb_glx_get_convolution_parameteriv_reply(c,
                                                      xcb_glx_get_convolution_parameteriv
                                                      (c,
                                                       gc->currentContextTag,
                                                       target, pname), NULL);
        if (xcb_glx_get_convolution_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d5030 1
a5030 4
            (void) memcpy(params,
                          xcb_glx_get_convolution_parameteriv_data(reply),
                          xcb_glx_get_convolution_parameteriv_data_length
                          (reply) * sizeof(GLint));
d5033 3
a5035 5
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetConvolutionParameteriv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d5037 1
a5037 2
        UnlockDisplay(dpy);
        SyncHandle();
a5042 28
#define X_GLvop_GetConvolutionParameterivEXT 3
void
gl_dispatch_stub_358(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetConvolutionParameteriv(GET_DISPATCH(),
                                       (target, pname, params));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetConvolutionParameterivEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d5045 1
a5045 2
__indirect_glGetHistogram(GLenum target, GLboolean reset, GLenum format,
                          GLenum type, GLvoid * values)
d5047 21
a5067 36
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 16;
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_histogram_reply_t *reply =
            xcb_glx_get_histogram_reply(c,
                                        xcb_glx_get_histogram(c,
                                                              gc->
                                                              currentContextTag,
                                                              target, reset,
                                                              format, type,
                                                              state->
                                                              storePack.
                                                              swapEndian),
                                        NULL);
        (void) memcpy(values, xcb_glx_get_histogram_data(reply),
                      xcb_glx_get_histogram_data_length(reply) *
                      sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetHistogram, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
        *(int32_t *) (pc + 12) = 0;
        *(int8_t *) (pc + 12) = state->storePack.swapEndian;
        *(int8_t *) (pc + 13) = reset;
        __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, values,
                            GL_TRUE);
        UnlockDisplay(dpy);
        SyncHandle();
a5072 34
#define X_GLvop_GetHistogramEXT 5
void
gl_dispatch_stub_361(GLenum target, GLboolean reset, GLenum format,
                     GLenum type, GLvoid * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetHistogram(GET_DISPATCH(),
                          (target, reset, format, type, values));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        const __GLXattribute *const state = gc->client_state_private;
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 16;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetHistogramEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
            *(int32_t *) (pc + 12) = 0;
            *(int8_t *) (pc + 12) = state->storePack.swapEndian;
            *(int8_t *) (pc + 13) = reset;
            __glXReadPixelReply(dpy, gc, 1, 0, 0, 0, format, type, values,
                                GL_TRUE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d5075 1
a5075 2
__indirect_glGetHistogramParameterfv(GLenum target, GLenum pname,
                                     GLfloat * params)
d5077 2
a5078 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d5082 1
a5082 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d5084 3
a5086 7
        xcb_glx_get_histogram_parameterfv_reply_t *reply =
            xcb_glx_get_histogram_parameterfv_reply(c,
                                                    xcb_glx_get_histogram_parameterfv
                                                    (c, gc->currentContextTag,
                                                     target, pname), NULL);
        if (xcb_glx_get_histogram_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d5088 1
a5088 4
            (void) memcpy(params,
                          xcb_glx_get_histogram_parameterfv_data(reply),
                          xcb_glx_get_histogram_parameterfv_data_length(reply)
                          * sizeof(GLfloat));
d5091 3
a5093 5
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetHistogramParameterfv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d5095 1
a5095 2
        UnlockDisplay(dpy);
        SyncHandle();
a5100 27
#define X_GLvop_GetHistogramParameterfvEXT 6
void
gl_dispatch_stub_362(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetHistogramParameterfv(GET_DISPATCH(), (target, pname, params));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetHistogramParameterfvEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d5103 1
a5103 2
__indirect_glGetHistogramParameteriv(GLenum target, GLenum pname,
                                     GLint * params)
d5105 2
a5106 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d5110 1
a5110 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d5112 3
a5114 7
        xcb_glx_get_histogram_parameteriv_reply_t *reply =
            xcb_glx_get_histogram_parameteriv_reply(c,
                                                    xcb_glx_get_histogram_parameteriv
                                                    (c, gc->currentContextTag,
                                                     target, pname), NULL);
        if (xcb_glx_get_histogram_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d5116 1
a5116 4
            (void) memcpy(params,
                          xcb_glx_get_histogram_parameteriv_data(reply),
                          xcb_glx_get_histogram_parameteriv_data_length(reply)
                          * sizeof(GLint));
d5119 3
a5121 5
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetHistogramParameteriv,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d5123 1
a5123 2
        UnlockDisplay(dpy);
        SyncHandle();
a5128 27
#define X_GLvop_GetHistogramParameterivEXT 7
void
gl_dispatch_stub_363(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetHistogramParameteriv(GET_DISPATCH(), (target, pname, params));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetHistogramParameterivEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d5131 1
a5131 2
__indirect_glGetMinmax(GLenum target, GLboolean reset, GLenum format,
                       GLenum type, GLvoid * values)
d5133 21
a5153 32
    __GLXcontext *const gc = __glXGetCurrentContext();
    const __GLXattribute *const state = gc->client_state_private;
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 16;
    if (__builtin_expect(dpy != NULL, 1)) {
#ifdef USE_XCB
        xcb_connection_t *c = XGetXCBConnection(dpy);
        (void) __glXFlushRenderBuffer(gc, gc->pc);
        xcb_glx_get_minmax_reply_t *reply =
            xcb_glx_get_minmax_reply(c,
                                     xcb_glx_get_minmax(c,
                                                        gc->currentContextTag,
                                                        target, reset, format,
                                                        type,
                                                        state->storePack.
                                                        swapEndian), NULL);
        (void) memcpy(values, xcb_glx_get_minmax_data(reply),
                      xcb_glx_get_minmax_data_length(reply) * sizeof(GLvoid));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMinmax, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
        *(int32_t *) (pc + 12) = 0;
        *(int8_t *) (pc + 12) = state->storePack.swapEndian;
        *(int8_t *) (pc + 13) = reset;
        __glXReadPixelReply(dpy, gc, 1, 2, 1, 1, format, type, values,
                            GL_FALSE);
        UnlockDisplay(dpy);
        SyncHandle();
a5158 33
#define X_GLvop_GetMinmaxEXT 8
void
gl_dispatch_stub_364(GLenum target, GLboolean reset, GLenum format,
                     GLenum type, GLvoid * values)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetMinmax(GET_DISPATCH(), (target, reset, format, type, values));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        const __GLXattribute *const state = gc->client_state_private;
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 16;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetMinmaxEXT, cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&type), 4);
            *(int32_t *) (pc + 12) = 0;
            *(int8_t *) (pc + 12) = state->storePack.swapEndian;
            *(int8_t *) (pc + 13) = reset;
            __glXReadPixelReply(dpy, gc, 1, 2, 1, 1, format, type, values,
                                GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d5161 1
a5161 2
__indirect_glGetMinmaxParameterfv(GLenum target, GLenum pname,
                                  GLfloat * params)
d5163 2
a5164 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d5168 1
a5168 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d5170 3
a5172 7
        xcb_glx_get_minmax_parameterfv_reply_t *reply =
            xcb_glx_get_minmax_parameterfv_reply(c,
                                                 xcb_glx_get_minmax_parameterfv
                                                 (c, gc->currentContextTag,
                                                  target, pname), NULL);
        if (xcb_glx_get_minmax_parameterfv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d5174 1
a5174 3
            (void) memcpy(params, xcb_glx_get_minmax_parameterfv_data(reply),
                          xcb_glx_get_minmax_parameterfv_data_length(reply) *
                          sizeof(GLfloat));
d5177 3
a5179 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMinmaxParameterfv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d5181 1
a5181 2
        UnlockDisplay(dpy);
        SyncHandle();
a5186 27
#define X_GLvop_GetMinmaxParameterfvEXT 9
void
gl_dispatch_stub_365(GLenum target, GLenum pname, GLfloat * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetMinmaxParameterfv(GET_DISPATCH(), (target, pname, params));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetMinmaxParameterfvEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d5191 2
a5192 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d5196 1
a5196 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d5198 3
a5200 7
        xcb_glx_get_minmax_parameteriv_reply_t *reply =
            xcb_glx_get_minmax_parameteriv_reply(c,
                                                 xcb_glx_get_minmax_parameteriv
                                                 (c, gc->currentContextTag,
                                                  target, pname), NULL);
        if (xcb_glx_get_minmax_parameteriv_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d5202 1
a5202 3
            (void) memcpy(params, xcb_glx_get_minmax_parameteriv_data(reply),
                          xcb_glx_get_minmax_parameteriv_data_length(reply) *
                          sizeof(GLint));
d5205 3
a5207 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetMinmaxParameteriv, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d5209 1
a5209 2
        UnlockDisplay(dpy);
        SyncHandle();
a5214 27
#define X_GLvop_GetMinmaxParameterivEXT 10
void
gl_dispatch_stub_366(GLenum target, GLenum pname, GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();

    if (gc->isDirect) {
        CALL_GetMinmaxParameteriv(GET_DISPATCH(), (target, pname, params));
    } else {
        __GLXcontext *const gc = __glXGetCurrentContext();
        Display *const dpy = gc->currentDpy;
        const GLuint cmdlen = 8;
        if (__builtin_expect(dpy != NULL, 1)) {
            GLubyte const *pc =
                __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                        X_GLvop_GetMinmaxParameterivEXT,
                                        cmdlen);
            (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
            (void) __glXReadReply(dpy, 4, params, GL_FALSE);
            UnlockDisplay(dpy);
            SyncHandle();
        }
        return;
    }
}

d5217 1
a5217 2
__indirect_glHistogram(GLenum target, GLsizei width, GLenum internalformat,
                       GLboolean sink)
d5219 1
a5219 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5222 4
a5225 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&sink), 1);
d5227 1
a5227 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5234 1
a5234 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5237 3
a5239 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&sink), 1);
d5241 1
a5241 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5248 1
a5248 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5251 1
a5251 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
d5253 1
a5253 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5260 1
a5260 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5263 1
a5263 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
d5265 1
a5265 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5269 4
a5272 9
__glx_TexImage_3D4D(unsigned opcode, unsigned dim, GLenum target, GLint level,
                    GLint internalformat, GLsizei width, GLsizei height,
                    GLsizei depth, GLsizei extent, GLint border,
                    GLenum format, GLenum type, const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (pixels != NULL) ? __glImageSize(width, height, depth, format, type,
                                         target) : 0;
d5276 1
a5276 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d5280 11
a5290 13
            (void) memcpy((void *) (gc->pc + 40), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&level), 4);
            (void) memcpy((void *) (gc->pc + 48), (void *) (&internalformat),
                          4);
            (void) memcpy((void *) (gc->pc + 52), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 56), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 60), (void *) (&depth), 4);
            (void) memcpy((void *) (gc->pc + 64), (void *) (&extent), 4);
            (void) memcpy((void *) (gc->pc + 68), (void *) (&border), 4);
            (void) memcpy((void *) (gc->pc + 72), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 76), (void *) (&type), 4);
            (void) memcpy((void *) (gc->pc + 80),
                          (void *) ((pixels == NULL) ? one : zero), 4);
d5292 4
a5295 5
                (*gc->fillImage) (gc, dim, width, height, depth, format, type,
                                  pixels, gc->pc + 84, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_4D,
                              default_pixel_store_4D_size);
d5298 3
a5300 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d5303 15
a5317 16
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&level), 4);
            (void) memcpy((void *) (pc + 52), (void *) (&internalformat), 4);
            (void) memcpy((void *) (pc + 56), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 60), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 64), (void *) (&depth), 4);
            (void) memcpy((void *) (pc + 68), (void *) (&extent), 4);
            (void) memcpy((void *) (pc + 72), (void *) (&border), 4);
            (void) memcpy((void *) (pc + 76), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 80), (void *) (&type), 4);
            (void) memcpy((void *) (pc + 84), zero, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, depth,
                                format, type, pixels, pc + 88, pc + 8);
d5324 3
a5326 8
__indirect_glTexImage3D(GLenum target, GLint level, GLint internalformat,
                        GLsizei width, GLsizei height, GLsizei depth,
                        GLint border, GLenum format, GLenum type,
                        const GLvoid * pixels)
{
    __glx_TexImage_3D4D(X_GLrop_TexImage3D, 3, target, level, internalformat,
                        width, height, depth, 1, border, format, type,
                        pixels);
d5330 4
a5333 10
__glx_TexSubImage_3D4D(unsigned opcode, unsigned dim, GLenum target,
                       GLint level, GLint xoffset, GLint yoffset,
                       GLint zoffset, GLint woffset, GLsizei width,
                       GLsizei height, GLsizei depth, GLsizei extent,
                       GLenum format, GLenum type, const GLvoid * pixels)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    const GLuint compsize =
        (pixels != NULL) ? __glImageSize(width, height, depth, format, type,
                                         target) : 0;
d5337 1
a5337 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d5341 13
a5353 14
            (void) memcpy((void *) (gc->pc + 40), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 44), (void *) (&level), 4);
            (void) memcpy((void *) (gc->pc + 48), (void *) (&xoffset), 4);
            (void) memcpy((void *) (gc->pc + 52), (void *) (&yoffset), 4);
            (void) memcpy((void *) (gc->pc + 56), (void *) (&zoffset), 4);
            (void) memcpy((void *) (gc->pc + 60), (void *) (&woffset), 4);
            (void) memcpy((void *) (gc->pc + 64), (void *) (&width), 4);
            (void) memcpy((void *) (gc->pc + 68), (void *) (&height), 4);
            (void) memcpy((void *) (gc->pc + 72), (void *) (&depth), 4);
            (void) memcpy((void *) (gc->pc + 76), (void *) (&extent), 4);
            (void) memcpy((void *) (gc->pc + 80), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 84), (void *) (&type), 4);
            (void) memcpy((void *) (gc->pc + 88),
                          (void *) ((pixels == NULL) ? one : zero), 4);
d5355 4
a5358 5
                (*gc->fillImage) (gc, dim, width, height, depth, format, type,
                                  pixels, gc->pc + 92, gc->pc + 4);
            } else {
                (void) memcpy(gc->pc + 4, default_pixel_store_4D,
                              default_pixel_store_4D_size);
d5361 3
a5363 4
            if (gc->pc > gc->limit) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d5366 17
a5382 18
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 44), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 48), (void *) (&level), 4);
            (void) memcpy((void *) (pc + 52), (void *) (&xoffset), 4);
            (void) memcpy((void *) (pc + 56), (void *) (&yoffset), 4);
            (void) memcpy((void *) (pc + 60), (void *) (&zoffset), 4);
            (void) memcpy((void *) (pc + 64), (void *) (&woffset), 4);
            (void) memcpy((void *) (pc + 68), (void *) (&width), 4);
            (void) memcpy((void *) (pc + 72), (void *) (&height), 4);
            (void) memcpy((void *) (pc + 76), (void *) (&depth), 4);
            (void) memcpy((void *) (pc + 80), (void *) (&extent), 4);
            (void) memcpy((void *) (pc + 84), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 88), (void *) (&type), 4);
            (void) memcpy((void *) (pc + 92), zero, 4);
            __glXSendLargeImage(gc, compsize, dim, width, height, depth,
                                format, type, pixels, pc + 96, pc + 8);
d5389 3
a5391 8
__indirect_glTexSubImage3D(GLenum target, GLint level, GLint xoffset,
                           GLint yoffset, GLint zoffset, GLsizei width,
                           GLsizei height, GLsizei depth, GLenum format,
                           GLenum type, const GLvoid * pixels)
{
    __glx_TexSubImage_3D4D(X_GLrop_TexSubImage3D, 3, target, level, xoffset,
                           yoffset, zoffset, 1, width, height, depth, 1,
                           format, type, pixels);
d5396 1
a5396 3
__indirect_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset,
                               GLint yoffset, GLint zoffset, GLint x, GLint y,
                               GLsizei width, GLsizei height)
d5398 1
a5398 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5401 9
a5409 9
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&xoffset), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&yoffset), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&zoffset), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&height), 4);
d5411 1
a5411 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5418 1
a5418 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5421 1
a5421 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&texture), 4);
d5423 1
a5423 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5430 1
a5430 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5433 2
a5434 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&target), 4);
d5436 1
a5436 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5443 1
a5443 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5446 2
a5447 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&target), 4);
d5449 1
a5449 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5456 1
a5456 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5459 2
a5460 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
d5462 1
a5462 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5469 1
a5469 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5472 2
a5473 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d5475 1
a5475 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5482 1
a5482 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5485 2
a5486 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
d5488 1
a5488 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5495 1
a5495 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5498 2
a5499 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d5501 1
a5501 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5508 1
a5508 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5511 2
a5512 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 2);
d5514 1
a5514 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5521 1
a5521 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5524 2
a5525 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 2);
d5527 1
a5527 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5534 1
a5534 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5537 3
a5539 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&target), 4);
d5541 1
a5541 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5548 1
a5548 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5551 2
a5552 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 16);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&target), 4);
d5554 1
a5554 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5561 1
a5561 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5564 3
a5566 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
d5568 1
a5568 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5575 1
a5575 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5578 2
a5579 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d5581 1
a5581 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5588 1
a5588 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5591 3
a5593 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
d5595 1
a5595 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5602 1
a5602 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5605 2
a5606 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d5608 1
a5608 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5615 1
a5615 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5618 3
a5620 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&t), 2);
d5622 1
a5622 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5629 1
a5629 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5632 2
a5633 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d5635 1
a5635 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5640 1
a5640 2
__indirect_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t,
                                GLdouble r)
d5642 1
a5642 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5645 4
a5648 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&r), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&target), 4);
d5650 1
a5650 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5657 1
a5657 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5660 2
a5661 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 24);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&target), 4);
d5663 1
a5663 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5668 1
a5668 2
__indirect_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t,
                                GLfloat r)
d5670 1
a5670 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5673 4
a5676 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&r), 4);
d5678 1
a5678 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5685 1
a5685 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5688 2
a5689 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 12);
d5691 1
a5691 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5698 1
a5698 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5701 4
a5704 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&r), 4);
d5706 1
a5706 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5713 1
a5713 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5716 2
a5717 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 12);
d5719 1
a5719 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5724 1
a5724 2
__indirect_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t,
                                GLshort r)
d5726 1
a5726 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5729 4
a5732 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&t), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 2);
d5734 1
a5734 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5741 1
a5741 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5744 2
a5745 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 6);
d5747 1
a5747 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5752 1
a5752 2
__indirect_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t,
                                GLdouble r, GLdouble q)
d5754 1
a5754 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5757 5
a5761 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&s), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&r), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&q), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&target), 4);
d5763 1
a5763 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5770 1
a5770 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5773 2
a5774 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (v), 32);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&target), 4);
d5776 1
a5776 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5781 1
a5781 2
__indirect_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t,
                                GLfloat r, GLfloat q)
d5783 1
a5783 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5786 5
a5790 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&r), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&q), 4);
d5792 1
a5792 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5799 1
a5799 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5802 2
a5803 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d5805 1
a5805 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5810 1
a5810 2
__indirect_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r,
                                GLint q)
d5812 1
a5812 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5815 5
a5819 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&t), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&r), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&q), 4);
d5821 1
a5821 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5828 1
a5828 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5831 2
a5832 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d5834 1
a5834 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5839 1
a5839 2
__indirect_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t,
                                GLshort r, GLshort q)
d5841 1
a5841 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5844 5
a5848 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&s), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&t), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&r), 2);
    (void) memcpy((void *) (gc->pc + 14), (void *) (&q), 2);
d5850 1
a5850 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5857 1
a5857 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5860 2
a5861 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d5863 1
a5863 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5870 1
a5870 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5873 2
a5874 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&value), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&invert), 1);
d5876 1
a5876 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5883 2
a5884 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d5887 3
a5889 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramStringARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d5891 1
a5891 2
        UnlockDisplay(dpy);
        SyncHandle();
d5900 2
a5901 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d5904 3
a5906 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramivARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d5908 1
a5908 2
        UnlockDisplay(dpy);
        SyncHandle();
d5915 1
a5915 2
__indirect_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x,
                                      GLdouble y, GLdouble z, GLdouble w)
d5917 1
a5917 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5920 6
a5925 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&w), 8);
d5927 1
a5927 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5932 1
a5932 2
__indirect_glProgramEnvParameter4dvARB(GLenum target, GLuint index,
                                       const GLdouble * params)
d5934 1
a5934 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5937 3
a5939 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 32);
d5941 1
a5941 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5946 1
a5946 2
__indirect_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x,
                                      GLfloat y, GLfloat z, GLfloat w)
d5948 1
a5948 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5951 6
a5956 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&w), 4);
d5958 1
a5958 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5963 1
a5963 2
__indirect_glProgramEnvParameter4fvARB(GLenum target, GLuint index,
                                       const GLfloat * params)
d5965 1
a5965 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5968 3
a5970 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 16);
d5972 1
a5972 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5977 1
a5977 3
__indirect_glProgramLocalParameter4dARB(GLenum target, GLuint index,
                                        GLdouble x, GLdouble y, GLdouble z,
                                        GLdouble w)
d5979 1
a5979 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5982 6
a5987 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&w), 8);
d5989 1
a5989 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d5994 1
a5994 2
__indirect_glProgramLocalParameter4dvARB(GLenum target, GLuint index,
                                         const GLdouble * params)
d5996 1
a5996 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d5999 3
a6001 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 32);
d6003 1
a6003 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6008 1
a6008 3
__indirect_glProgramLocalParameter4fARB(GLenum target, GLuint index,
                                        GLfloat x, GLfloat y, GLfloat z,
                                        GLfloat w)
d6010 1
a6010 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6013 6
a6018 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&w), 4);
d6020 1
a6020 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6025 1
a6025 2
__indirect_glProgramLocalParameter4fvARB(GLenum target, GLuint index,
                                         const GLfloat * params)
d6027 1
a6027 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6030 3
a6032 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 16);
d6034 1
a6034 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6039 1
a6039 2
__indirect_glProgramStringARB(GLenum target, GLenum format, GLsizei len,
                              const GLvoid * string)
d6041 1
a6041 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6045 1
a6045 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d6049 4
a6052 4
            (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (&format), 4);
            (void) memcpy((void *) (gc->pc + 12), (void *) (&len), 4);
            (void) memcpy((void *) (gc->pc + 16), (void *) (string), len);
d6054 3
a6056 4
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d6059 6
a6064 6
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&target), 4);
            (void) memcpy((void *) (pc + 12), (void *) (&format), 4);
            (void) memcpy((void *) (pc + 16), (void *) (&len), 4);
d6074 1
a6074 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6077 2
a6078 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
d6080 1
a6080 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6087 1
a6087 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6090 2
a6091 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d6093 1
a6093 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6100 1
a6100 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6103 2
a6104 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
d6106 1
a6106 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6113 1
a6113 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6116 2
a6117 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d6119 1
a6119 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6126 1
a6126 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6129 2
a6130 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
d6132 1
a6132 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6139 1
a6139 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6142 2
a6143 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 2);
d6145 1
a6145 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6152 1
a6152 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6155 3
a6157 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
d6159 1
a6159 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6166 1
a6166 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6169 2
a6170 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d6172 1
a6172 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6179 1
a6179 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6182 3
a6184 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
d6186 1
a6186 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6193 1
a6193 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6196 2
a6197 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d6199 1
a6199 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6206 1
a6206 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6209 3
a6211 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
d6213 1
a6213 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6220 1
a6220 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6223 2
a6224 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d6226 1
a6226 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6231 1
a6231 2
__indirect_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y,
                               GLdouble z)
d6233 1
a6233 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6236 4
a6239 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&z), 8);
d6241 1
a6241 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6248 1
a6248 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6251 2
a6252 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 24);
d6254 1
a6254 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6261 1
a6261 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6264 4
a6267 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
d6269 1
a6269 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6276 1
a6276 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6279 2
a6280 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 12);
d6282 1
a6282 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6289 1
a6289 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6292 4
a6295 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 2);
d6297 1
a6297 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6304 1
a6304 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6307 2
a6308 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 6);
d6310 1
a6310 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6317 1
a6317 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6320 2
a6321 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d6323 1
a6323 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6330 1
a6330 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6333 2
a6334 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d6336 1
a6336 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6343 1
a6343 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6346 2
a6347 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d6349 1
a6349 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6354 1
a6354 2
__indirect_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y,
                                 GLubyte z, GLubyte w)
d6356 1
a6356 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6359 5
a6363 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 1);
    (void) memcpy((void *) (gc->pc + 9), (void *) (&y), 1);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&z), 1);
    (void) memcpy((void *) (gc->pc + 11), (void *) (&w), 1);
d6365 1
a6365 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6372 1
a6372 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6375 2
a6376 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d6378 1
a6378 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6385 1
a6385 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6388 2
a6389 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d6391 1
a6391 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6398 1
a6398 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6401 2
a6402 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d6404 1
a6404 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6411 1
a6411 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6414 2
a6415 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d6417 1
a6417 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6422 1
a6422 2
__indirect_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y,
                               GLdouble z, GLdouble w)
d6424 1
a6424 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6427 5
a6431 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&w), 8);
d6433 1
a6433 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6440 1
a6440 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6443 2
a6444 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 32);
d6446 1
a6446 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6451 1
a6451 2
__indirect_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z,
                               GLfloat w)
d6453 1
a6453 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6456 5
a6460 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&w), 4);
d6462 1
a6462 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6469 1
a6469 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6472 2
a6473 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d6475 1
a6475 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6482 1
a6482 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6485 2
a6486 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d6488 1
a6488 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6493 1
a6493 2
__indirect_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z,
                               GLshort w)
d6495 1
a6495 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6498 5
a6502 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 2);
    (void) memcpy((void *) (gc->pc + 14), (void *) (&w), 2);
d6504 1
a6504 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6511 1
a6511 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6514 2
a6515 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d6517 1
a6517 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6524 1
a6524 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6527 2
a6528 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d6530 1
a6530 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6537 1
a6537 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6540 2
a6541 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d6543 1
a6543 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6550 1
a6550 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6553 2
a6554 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d6556 1
a6556 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6563 1
a6563 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6566 2
a6567 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&id), 4);
d6569 1
a6569 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6576 2
a6577 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d6581 1
a6581 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d6583 1
a6583 1
        xcb_glx_delete_queries_arb(c, gc->currentContextTag, n, ids);
d6585 4
a6588 6
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_DeleteQueriesARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (ids), (n * 4));
        UnlockDisplay(dpy);
        SyncHandle();
d6598 1
a6598 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6601 1
a6601 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
d6603 1
a6603 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6610 2
a6611 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d6615 1
a6615 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d6617 6
a6622 14
        xcb_glx_gen_queries_arb_reply_t *reply =
            xcb_glx_gen_queries_arb_reply(c,
                                          xcb_glx_gen_queries_arb(c,
                                                                  gc->
                                                                  currentContextTag,
                                                                  n), NULL);
        (void) memcpy(ids, xcb_glx_gen_queries_arb_data(reply),
                      xcb_glx_gen_queries_arb_data_length(reply) *
                      sizeof(GLuint));
        free(reply);
#else
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GenQueriesARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
d6624 1
a6624 2
        UnlockDisplay(dpy);
        SyncHandle();
d6634 2
a6635 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d6639 1
a6639 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d6641 3
a6643 7
        xcb_glx_get_query_objectiv_arb_reply_t *reply =
            xcb_glx_get_query_objectiv_arb_reply(c,
                                                 xcb_glx_get_query_objectiv_arb
                                                 (c, gc->currentContextTag,
                                                  id, pname), NULL);
        if (xcb_glx_get_query_objectiv_arb_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d6645 1
a6645 3
            (void) memcpy(params, xcb_glx_get_query_objectiv_arb_data(reply),
                          xcb_glx_get_query_objectiv_arb_data_length(reply) *
                          sizeof(GLint));
d6648 3
a6650 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetQueryObjectivARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d6652 1
a6652 2
        UnlockDisplay(dpy);
        SyncHandle();
d6662 2
a6663 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d6667 1
a6667 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d6669 3
a6671 7
        xcb_glx_get_query_objectuiv_arb_reply_t *reply =
            xcb_glx_get_query_objectuiv_arb_reply(c,
                                                  xcb_glx_get_query_objectuiv_arb
                                                  (c, gc->currentContextTag,
                                                   id, pname), NULL);
        if (xcb_glx_get_query_objectuiv_arb_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d6673 1
a6673 3
            (void) memcpy(params, xcb_glx_get_query_objectuiv_arb_data(reply),
                          xcb_glx_get_query_objectuiv_arb_data_length(reply) *
                          sizeof(GLuint));
d6676 3
a6678 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetQueryObjectuivARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d6680 1
a6680 2
        UnlockDisplay(dpy);
        SyncHandle();
d6690 2
a6691 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d6695 1
a6695 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d6697 3
a6699 10
        xcb_glx_get_queryiv_arb_reply_t *reply =
            xcb_glx_get_queryiv_arb_reply(c,
                                          xcb_glx_get_queryiv_arb(c,
                                                                  gc->
                                                                  currentContextTag,
                                                                  target,
                                                                  pname),
                                          NULL);
        if (xcb_glx_get_queryiv_arb_data_length(reply) == 0)
            (void) memcpy(params, &reply->datum, sizeof(reply->datum));
d6701 1
a6701 3
            (void) memcpy(params, xcb_glx_get_queryiv_arb_data(reply),
                          xcb_glx_get_queryiv_arb_data_length(reply) *
                          sizeof(GLint));
d6704 3
a6706 4
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_GetQueryivARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d6708 1
a6708 2
        UnlockDisplay(dpy);
        SyncHandle();
d6718 2
a6719 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d6724 1
a6724 1
        xcb_connection_t *c = XGetXCBConnection(dpy);
d6726 1
a6726 6
        xcb_glx_is_query_arb_reply_t *reply =
            xcb_glx_is_query_arb_reply(c,
                                       xcb_glx_is_query_arb(c,
                                                            gc->
                                                            currentContextTag,
                                                            id), NULL);
d6730 2
a6731 3
        GLubyte const *pc =
            __glXSetupSingleRequest(gc, X_GLsop_IsQueryARB, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
d6733 1
a6733 2
        UnlockDisplay(dpy);
        SyncHandle();
d6743 1
a6743 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6747 1
a6747 1
            if ((gc->pc + cmdlen) > gc->bufEnd) {
d6751 2
a6752 2
            (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
            (void) memcpy((void *) (gc->pc + 8), (void *) (bufs), (n * 4));
d6754 3
a6756 4
            if (__builtin_expect(gc->pc > gc->limit, 0)) {
                (void) __glXFlushRenderBuffer(gc, gc->pc);
            }
        } else {
d6759 4
a6762 4
            GLubyte *const pc = __glXFlushRenderBuffer(gc, gc->pc);
            (void) memcpy((void *) (pc + 0), (void *) (&cmdlenLarge), 4);
            (void) memcpy((void *) (pc + 4), (void *) (&op), 4);
            (void) memcpy((void *) (pc + 8), (void *) (&n), 4);
d6768 106
d6878 1
a6878 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6881 2
a6882 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&value), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&invert), 1);
d6884 1
a6884 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6891 1
a6891 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6894 1
a6894 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pattern), 4);
d6896 1
a6896 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6903 1
a6903 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6906 2
a6907 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
d6909 1
a6909 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6916 1
a6916 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6920 2
a6921 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
d6923 1
a6923 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6930 1
a6930 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6933 3
a6935 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
d6937 1
a6937 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6944 1
a6944 1
    generic_3_byte(X_GLrop_SecondaryColor3bvEXT, v);
d6951 1
a6951 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6954 3
a6956 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 8);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&green), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&blue), 8);
d6958 1
a6958 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6965 1
a6965 1
    generic_24_byte(X_GLrop_SecondaryColor3dvEXT, v);
d6972 1
a6972 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6975 3
a6977 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
d6979 1
a6979 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d6986 1
a6986 1
    generic_12_byte(X_GLrop_SecondaryColor3fvEXT, v);
d6993 1
a6993 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d6996 3
a6998 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
d7000 1
a7000 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7007 1
a7007 1
    generic_12_byte(X_GLrop_SecondaryColor3ivEXT, v);
d7014 1
a7014 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7017 3
a7019 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
d7021 1
a7021 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7028 1
a7028 1
    generic_6_byte(X_GLrop_SecondaryColor3svEXT, v);
d7035 1
a7035 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7038 3
a7040 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 1);
    (void) memcpy((void *) (gc->pc + 5), (void *) (&green), 1);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&blue), 1);
d7042 1
a7042 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7049 1
a7049 1
    generic_3_byte(X_GLrop_SecondaryColor3ubvEXT, v);
d7056 1
a7056 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7059 3
a7061 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&green), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&blue), 4);
d7063 1
a7063 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7070 1
a7070 1
    generic_12_byte(X_GLrop_SecondaryColor3uivEXT, v);
d7077 1
a7077 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7080 3
a7082 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&red), 2);
    (void) memcpy((void *) (gc->pc + 6), (void *) (&green), 2);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&blue), 2);
d7084 1
a7084 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7091 1
a7091 1
    generic_6_byte(X_GLrop_SecondaryColor3usvEXT, v);
d7098 1
a7098 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7101 1
a7101 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 8);
d7103 1
a7103 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7110 1
a7110 1
    generic_8_byte(X_GLrop_FogCoorddvEXT, coord);
d7117 1
a7117 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7120 1
a7120 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&coord), 4);
d7122 1
a7122 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7129 1
a7129 1
    generic_4_byte(X_GLrop_FogCoordfvEXT, coord);
d7134 1
a7134 2
__indirect_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB,
                                  GLenum sfactorAlpha, GLenum dfactorAlpha)
d7136 1
a7136 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7139 4
a7142 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&sfactorRGB), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&dfactorRGB), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&sfactorAlpha), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&dfactorAlpha), 4);
d7144 1
a7144 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7151 1
a7151 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7154 3
a7156 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 4);
d7158 1
a7158 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7165 1
a7165 1
    generic_12_byte(X_GLrop_WindowPos3fvMESA, v);
d7170 1
a7170 2
__indirect_glAreProgramsResidentNV(GLsizei n, const GLuint * ids,
                                   GLboolean * residences)
d7172 2
a7173 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7177 3
a7179 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_AreProgramsResidentNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (ids), (n * 4));
d7181 1
a7181 2
        UnlockDisplay(dpy);
        SyncHandle();
d7190 1
a7190 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7193 2
a7194 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&program), 4);
d7196 1
a7196 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7203 2
a7204 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7207 4
a7210 7
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivate,
                                    X_GLvop_DeleteProgramsNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
        (void) memcpy((void *) (pc + 4), (void *) (programs), (n * 4));
        UnlockDisplay(dpy);
        SyncHandle();
d7217 1
a7217 2
__indirect_glExecuteProgramNV(GLenum target, GLuint id,
                              const GLfloat * params)
d7219 1
a7219 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7222 3
a7224 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&id), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 16);
d7226 1
a7226 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7233 2
a7234 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7237 2
a7238 4
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GenProgramsNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
d7240 1
a7240 2
        UnlockDisplay(dpy);
        SyncHandle();
d7247 1
a7247 2
__indirect_glGetProgramParameterdvNV(GLenum target, GLuint index,
                                     GLenum pname, GLdouble * params)
d7249 2
a7250 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7253 4
a7256 6
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramParameterdvNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
d7258 1
a7258 2
        UnlockDisplay(dpy);
        SyncHandle();
d7265 1
a7265 2
__indirect_glGetProgramParameterfvNV(GLenum target, GLuint index,
                                     GLenum pname, GLfloat * params)
d7267 2
a7268 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7271 4
a7274 6
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramParameterfvNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
d7276 1
a7276 2
        UnlockDisplay(dpy);
        SyncHandle();
d7285 2
a7286 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7289 3
a7291 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramStringNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d7293 1
a7293 2
        UnlockDisplay(dpy);
        SyncHandle();
d7302 2
a7303 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7306 3
a7308 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramivNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d7310 1
a7310 2
        UnlockDisplay(dpy);
        SyncHandle();
d7317 1
a7317 2
__indirect_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname,
                                GLint * params)
d7319 2
a7320 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7323 4
a7326 6
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetTrackMatrixivNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&address), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
d7328 1
a7328 2
        UnlockDisplay(dpy);
        SyncHandle();
d7335 1
a7335 2
__indirect_glGetVertexAttribdvNV(GLuint index, GLenum pname,
                                 GLdouble * params)
d7337 2
a7338 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7341 3
a7343 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetVertexAttribdvNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d7345 1
a7345 2
        UnlockDisplay(dpy);
        SyncHandle();
d7354 2
a7355 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7358 3
a7360 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetVertexAttribfvNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d7362 1
a7362 2
        UnlockDisplay(dpy);
        SyncHandle();
d7371 2
a7372 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7375 3
a7377 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetVertexAttribivNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&index), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d7379 1
a7379 2
        UnlockDisplay(dpy);
        SyncHandle();
d7388 2
a7389 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d7393 2
a7394 4
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_IsProgramNV, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&program), 4);
d7396 1
a7396 2
        UnlockDisplay(dpy);
        SyncHandle();
d7403 1
a7403 2
__indirect_glLoadProgramNV(GLenum target, GLuint id, GLsizei len,
                           const GLubyte * program)
d7405 1
a7405 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7409 4
a7412 4
        (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 16), (void *) (program), len);
d7414 1
a7414 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7420 1
a7420 2
__indirect_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x,
                                  GLdouble y, GLdouble z, GLdouble w)
d7422 1
a7422 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7425 6
a7430 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 28), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 36), (void *) (&w), 8);
d7432 1
a7432 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7437 1
a7437 2
__indirect_glProgramParameter4dvNV(GLenum target, GLuint index,
                                   const GLdouble * params)
d7439 1
a7439 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7442 3
a7444 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 32);
d7446 1
a7446 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7451 1
a7451 2
__indirect_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x,
                                  GLfloat y, GLfloat z, GLfloat w)
d7453 1
a7453 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7456 6
a7461 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&w), 4);
d7463 1
a7463 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7468 1
a7468 2
__indirect_glProgramParameter4fvNV(GLenum target, GLuint index,
                                   const GLfloat * params)
d7470 1
a7470 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7473 3
a7475 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (params), 16);
d7477 1
a7477 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7482 1
a7482 2
__indirect_glProgramParameters4dvNV(GLenum target, GLuint index, GLuint num,
                                    const GLdouble * params)
d7484 1
a7484 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7488 4
a7491 4
        (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&num), 4);
        (void) memcpy((void *) (gc->pc + 16), (void *) (params), (num * 32));
d7493 1
a7493 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7499 1
a7499 2
__indirect_glProgramParameters4fvNV(GLenum target, GLuint index, GLuint num,
                                    const GLfloat * params)
d7501 1
a7501 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7505 4
a7508 4
        (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&num), 4);
        (void) memcpy((void *) (gc->pc + 16), (void *) (params), (num * 16));
d7510 1
a7510 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7518 1
a7518 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7522 2
a7523 2
        (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (ids), (n * 4));
d7525 1
a7525 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7531 1
a7531 2
__indirect_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix,
                           GLenum transform)
d7533 1
a7533 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7536 4
a7539 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&address), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&matrix), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&transform), 4);
d7541 1
a7541 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7548 1
a7548 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7551 2
a7552 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
d7554 1
a7554 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7561 1
a7561 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7564 2
a7565 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d7567 1
a7567 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7574 1
a7574 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7577 2
a7578 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
d7580 1
a7580 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7587 1
a7587 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7590 2
a7591 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d7593 1
a7593 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7600 1
a7600 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7603 2
a7604 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
d7606 1
a7606 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7613 1
a7613 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7616 2
a7617 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 2);
d7619 1
a7619 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7626 1
a7626 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7629 3
a7631 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
d7633 1
a7633 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7640 1
a7640 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7643 2
a7644 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d7646 1
a7646 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7653 1
a7653 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7656 3
a7658 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
d7660 1
a7660 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7667 1
a7667 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7670 2
a7671 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d7673 1
a7673 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7680 1
a7680 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7683 3
a7685 3
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
d7687 1
a7687 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7694 1
a7694 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7697 2
a7698 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d7700 1
a7700 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7705 1
a7705 2
__indirect_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y,
                              GLdouble z)
d7707 1
a7707 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7710 4
a7713 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&z), 8);
d7715 1
a7715 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7722 1
a7722 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7725 2
a7726 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 24);
d7728 1
a7728 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7735 1
a7735 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7738 4
a7741 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
d7743 1
a7743 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7750 1
a7750 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7753 2
a7754 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 12);
d7756 1
a7756 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7763 1
a7763 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7766 4
a7769 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 2);
d7771 1
a7771 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7778 1
a7778 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7781 2
a7782 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 6);
d7784 1
a7784 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7789 1
a7789 2
__indirect_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y,
                              GLdouble z, GLdouble w)
d7791 1
a7791 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7794 5
a7798 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 8);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 8);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&z), 8);
    (void) memcpy((void *) (gc->pc + 32), (void *) (&w), 8);
d7800 1
a7800 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7807 1
a7807 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7810 2
a7811 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 32);
d7813 1
a7813 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7818 1
a7818 2
__indirect_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z,
                              GLfloat w)
d7820 1
a7820 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7823 5
a7827 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&z), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&w), 4);
d7829 1
a7829 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7836 1
a7836 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7839 2
a7840 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 16);
d7842 1
a7842 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7847 1
a7847 2
__indirect_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z,
                              GLshort w)
d7849 1
a7849 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7852 5
a7856 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 2);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&y), 2);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&z), 2);
    (void) memcpy((void *) (gc->pc + 14), (void *) (&w), 2);
d7858 1
a7858 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7865 1
a7865 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7868 2
a7869 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 8);
d7871 1
a7871 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7876 1
a7876 2
__indirect_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z,
                               GLubyte w)
d7878 1
a7878 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7881 5
a7885 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&x), 1);
    (void) memcpy((void *) (gc->pc + 9), (void *) (&y), 1);
    (void) memcpy((void *) (gc->pc + 10), (void *) (&z), 1);
    (void) memcpy((void *) (gc->pc + 11), (void *) (&w), 1);
d7887 1
a7887 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7894 1
a7894 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7897 2
a7898 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (v), 4);
d7900 1
a7900 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d7907 1
a7907 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7911 3
a7913 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 8));
d7915 1
a7915 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7923 1
a7923 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7927 3
a7929 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 4));
d7931 1
a7931 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7939 1
a7939 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7943 3
a7945 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 2));
d7947 1
a7947 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7955 1
a7955 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7959 3
a7961 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 16));
d7963 1
a7963 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7971 1
a7971 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7975 3
a7977 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 8));
d7979 1
a7979 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d7987 1
a7987 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d7991 3
a7993 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 4));
d7995 1
a7995 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8003 1
a8003 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8007 3
a8009 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 24));
d8011 1
a8011 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8019 1
a8019 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8023 3
a8025 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 12));
d8027 1
a8027 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8035 1
a8035 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8039 3
a8041 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 6));
d8043 1
a8043 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8051 1
a8051 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8055 3
a8057 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 32));
d8059 1
a8059 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8067 1
a8067 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8071 3
a8073 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 16));
d8075 1
a8075 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8083 1
a8083 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8087 3
a8089 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 8));
d8091 1
a8091 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8099 1
a8099 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8103 3
a8105 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&index), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), (n * 4));
d8107 1
a8107 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8115 1
a8115 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8118 2
a8119 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&param), 4);
d8121 1
a8121 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8128 1
a8128 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8132 2
a8133 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&pname), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (params), (compsize * 4));
d8135 1
a8135 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8142 1
a8142 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8145 1
a8145 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&face), 4);
d8147 1
a8147 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8152 1
a8152 3
__indirect_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len,
                                          const GLubyte * name,
                                          GLdouble * params)
d8154 2
a8155 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d8158 4
a8161 7
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramNamedParameterdvNV,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&len), 4);
        (void) memcpy((void *) (pc + 8), (void *) (name), len);
d8163 1
a8163 2
        UnlockDisplay(dpy);
        SyncHandle();
d8170 1
a8170 3
__indirect_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len,
                                          const GLubyte * name,
                                          GLfloat * params)
d8172 2
a8173 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d8176 4
a8179 7
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetProgramNamedParameterfvNV,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&id), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&len), 4);
        (void) memcpy((void *) (pc + 8), (void *) (name), len);
d8181 1
a8181 2
        UnlockDisplay(dpy);
        SyncHandle();
d8188 1
a8188 3
__indirect_glProgramNamedParameter4dNV(GLuint id, GLsizei len,
                                       const GLubyte * name, GLdouble x,
                                       GLdouble y, GLdouble z, GLdouble w)
d8190 1
a8190 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8194 7
a8200 7
        (void) memcpy((void *) (gc->pc + 4), (void *) (&x), 8);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&y), 8);
        (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 8);
        (void) memcpy((void *) (gc->pc + 28), (void *) (&w), 8);
        (void) memcpy((void *) (gc->pc + 36), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 40), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 44), (void *) (name), len);
d8202 1
a8202 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8208 1
a8208 3
__indirect_glProgramNamedParameter4dvNV(GLuint id, GLsizei len,
                                        const GLubyte * name,
                                        const GLdouble * v)
d8210 1
a8210 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8214 4
a8217 4
        (void) memcpy((void *) (gc->pc + 4), (void *) (v), 32);
        (void) memcpy((void *) (gc->pc + 36), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 40), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 44), (void *) (name), len);
d8219 1
a8219 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8225 1
a8225 3
__indirect_glProgramNamedParameter4fNV(GLuint id, GLsizei len,
                                       const GLubyte * name, GLfloat x,
                                       GLfloat y, GLfloat z, GLfloat w)
d8227 1
a8227 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8231 7
a8237 7
        (void) memcpy((void *) (gc->pc + 4), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (&x), 4);
        (void) memcpy((void *) (gc->pc + 16), (void *) (&y), 4);
        (void) memcpy((void *) (gc->pc + 20), (void *) (&z), 4);
        (void) memcpy((void *) (gc->pc + 24), (void *) (&w), 4);
        (void) memcpy((void *) (gc->pc + 28), (void *) (name), len);
d8239 1
a8239 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8245 1
a8245 3
__indirect_glProgramNamedParameter4fvNV(GLuint id, GLsizei len,
                                        const GLubyte * name,
                                        const GLfloat * v)
d8247 1
a8247 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8251 4
a8254 4
        (void) memcpy((void *) (gc->pc + 4), (void *) (&id), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (&len), 4);
        (void) memcpy((void *) (gc->pc + 12), (void *) (v), 16);
        (void) memcpy((void *) (gc->pc + 28), (void *) (name), len);
d8256 1
a8256 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8264 1
a8264 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8267 2
a8268 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&modeRGB), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&modeA), 4);
d8270 1
a8270 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8277 1
a8277 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8280 2
a8281 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&framebuffer), 4);
d8283 1
a8283 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8290 1
a8290 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8293 2
a8294 2
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&renderbuffer), 4);
d8296 1
a8296 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8303 2
a8304 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d8308 2
a8309 5
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_CheckFramebufferStatusEXT,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
d8311 1
a8311 2
        UnlockDisplay(dpy);
        SyncHandle();
d8320 1
a8320 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8324 2
a8325 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (framebuffers),
                      (n * 4));
d8327 1
a8327 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8335 1
a8335 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8339 2
a8340 3
        (void) memcpy((void *) (gc->pc + 4), (void *) (&n), 4);
        (void) memcpy((void *) (gc->pc + 8), (void *) (renderbuffers),
                      (n * 4));
d8342 1
a8342 3
        if (__builtin_expect(gc->pc > gc->limit, 0)) {
            (void) __glXFlushRenderBuffer(gc, gc->pc);
        }
d8348 1
a8348 3
__indirect_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment,
                                        GLenum renderbuffertarget,
                                        GLuint renderbuffer)
d8350 1
a8350 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8353 4
a8356 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&attachment), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&renderbuffertarget), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&renderbuffer), 4);
d8358 1
a8358 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8363 1
a8363 3
__indirect_glFramebufferTexture1DEXT(GLenum target, GLenum attachment,
                                     GLenum textarget, GLuint texture,
                                     GLint level)
d8365 1
a8365 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8368 5
a8372 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&attachment), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&textarget), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&texture), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&level), 4);
d8374 1
a8374 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8379 1
a8379 3
__indirect_glFramebufferTexture2DEXT(GLenum target, GLenum attachment,
                                     GLenum textarget, GLuint texture,
                                     GLint level)
d8381 1
a8381 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8384 5
a8388 5
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&attachment), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&textarget), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&texture), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&level), 4);
d8390 1
a8390 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8395 1
a8395 3
__indirect_glFramebufferTexture3DEXT(GLenum target, GLenum attachment,
                                     GLenum textarget, GLuint texture,
                                     GLint level, GLint zoffset)
d8397 1
a8397 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8400 6
a8405 6
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&attachment), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&textarget), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&texture), 4);
    (void) memcpy((void *) (gc->pc + 20), (void *) (&level), 4);
    (void) memcpy((void *) (gc->pc + 24), (void *) (&zoffset), 4);
d8407 1
a8407 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8414 2
a8415 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d8418 2
a8419 4
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GenFramebuffersEXT, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
d8421 1
a8421 2
        UnlockDisplay(dpy);
        SyncHandle();
d8430 2
a8431 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d8434 2
a8435 4
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GenRenderbuffersEXT, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&n), 4);
d8437 1
a8437 2
        UnlockDisplay(dpy);
        SyncHandle();
d8446 1
a8446 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8449 1
a8449 1
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
d8451 1
a8451 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
d8456 10
a8465 16
__indirect_glGetFramebufferAttachmentParameterivEXT(GLenum target,
                                                    GLenum attachment,
                                                    GLenum pname,
                                                    GLint * params)
{
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
    const GLuint cmdlen = 12;
    if (__builtin_expect(dpy != NULL, 1)) {
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetFramebufferAttachmentParameterivEXT,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&attachment), 4);
        (void) memcpy((void *) (pc + 8), (void *) (&pname), 4);
d8467 1
a8467 2
        UnlockDisplay(dpy);
        SyncHandle();
d8474 1
a8474 2
__indirect_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname,
                                           GLint * params)
d8476 2
a8477 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d8480 3
a8482 6
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_GetRenderbufferParameterivEXT,
                                    cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&target), 4);
        (void) memcpy((void *) (pc + 4), (void *) (&pname), 4);
d8484 1
a8484 2
        UnlockDisplay(dpy);
        SyncHandle();
d8493 2
a8494 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d8498 2
a8499 4
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_IsFramebufferEXT, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&framebuffer), 4);
d8501 1
a8501 2
        UnlockDisplay(dpy);
        SyncHandle();
d8510 2
a8511 2
    __GLXcontext *const gc = __glXGetCurrentContext();
    Display *const dpy = gc->currentDpy;
d8515 2
a8516 4
        GLubyte const *pc =
            __glXSetupVendorRequest(gc, X_GLXVendorPrivateWithReply,
                                    X_GLvop_IsRenderbufferEXT, cmdlen);
        (void) memcpy((void *) (pc + 0), (void *) (&renderbuffer), 4);
d8518 1
a8518 2
        UnlockDisplay(dpy);
        SyncHandle();
d8525 1
a8525 2
__indirect_glRenderbufferStorageEXT(GLenum target, GLenum internalformat,
                                    GLsizei width, GLsizei height)
d8527 1
a8527 1
    __GLXcontext *const gc = __glXGetCurrentContext();
d8530 4
a8533 4
    (void) memcpy((void *) (gc->pc + 4), (void *) (&target), 4);
    (void) memcpy((void *) (gc->pc + 8), (void *) (&internalformat), 4);
    (void) memcpy((void *) (gc->pc + 12), (void *) (&width), 4);
    (void) memcpy((void *) (gc->pc + 16), (void *) (&height), 4);
d8535 1
a8535 3
    if (__builtin_expect(gc->pc > gc->limit, 0)) {
        (void) __glXFlushRenderBuffer(gc, gc->pc);
    }
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d477 1
a477 1
                    const GLubyte *bitmap)
d544 1
a544 1
__indirect_glColor3bv(const GLbyte *v)
d659 1
a659 1
__indirect_glColor3ubv(const GLubyte *v)
d729 1
a729 1
__indirect_glColor4bv(const GLbyte *v)
d850 1
a850 1
__indirect_glColor4ubv(const GLubyte *v)
d1054 1
a1054 1
__indirect_glNormal3bv(const GLbyte *v)
d2587 1
a2587 1
__indirect_glPolygonStipple(const GLubyte *mask)
d4210 1
a4210 1
__indirect_glGetPolygonStipple(GLubyte *mask)
d4980 1
a4980 1
__indirect_glIndexubv(const GLubyte *c)
d7938 1
a7938 1
__indirect_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
d8002 1
a8002 1
__indirect_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
d8047 1
a8047 1
__indirect_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
d8179 1
a8179 1
__indirect_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
d8559 1
a8559 1
__indirect_glSecondaryColor3bvEXT(const GLbyte *v)
d8674 1
a8674 1
__indirect_glSecondaryColor3ubvEXT(const GLubyte *v)
d8946 1
a8946 1
__indirect_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
d9090 1
a9090 1
                           const GLubyte *program)
d9659 1
a9659 1
__indirect_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
d9890 1
a9890 1
__indirect_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
d9954 1
a9954 1
                                          const GLubyte *name,
d9978 1
a9978 1
                                          const GLubyte *name,
d10002 1
a10002 1
                                       const GLubyte *name, GLdouble x,
d10026 1
a10026 1
                                        const GLubyte *name,
d10047 1
a10047 1
                                       const GLubyte *name, GLfloat x,
d10071 1
a10071 1
                                        const GLubyte *name,
@


