head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.39;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.56;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.01;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.08;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.48;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.23;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@#include "pipe/p_compiler.h"
#include "pipe/p_context.h"
#include "pipe/p_screen.h"
#include "util/u_debug.h"
#include "util/u_memory.h"
#include "target-helpers/inline_sw_helper.h"
#include "target-helpers/inline_debug_helper.h"
#include "state_tracker/xlibsw_api.h"
#include "state_tracker/graw.h"
#include "sw/xlib/xlib_sw_winsys.h"

#include <X11/Xlib.h>
#include <X11/Xlibint.h>
#include <X11/Xutil.h>
#include <stdio.h>

static struct {
   Display *display;
   void (*draw)(void);
} graw;


static struct pipe_screen *
graw_create_screen( void )
{
   struct pipe_screen *screen = NULL;
   struct sw_winsys *winsys = NULL;

   /* Create the underlying winsys, which performs presents to Xlib
    * drawables:
    */
   winsys = xlib_create_sw_winsys( graw.display );
   if (winsys == NULL)
      return NULL;

   screen = sw_screen_create( winsys );

   /* Inject any wrapping layers we want to here:
    */
   return debug_screen_wrap( screen );
}


struct pipe_screen *
graw_create_window_and_screen( int x,
                               int y,
                               unsigned width,
                               unsigned height,
                               enum pipe_format format,
                               void **handle)
{
   struct pipe_screen *screen = NULL;
   struct xlib_drawable *xlib_handle = NULL;
   XSetWindowAttributes attr;
   Window root;
   Window win = 0;
   XVisualInfo templat, *visinfo = NULL;
   unsigned mask;
   int n;
   int scrnum;

   graw.display = XOpenDisplay(NULL);
   if (graw.display == NULL)
      return NULL;

   scrnum = DefaultScreen( graw.display );
   root = RootWindow( graw.display, scrnum );


   if (graw.display == NULL)
      goto fail;

   xlib_handle = CALLOC_STRUCT(xlib_drawable);
   if (xlib_handle == NULL)
      goto fail;


   mask = VisualScreenMask | VisualDepthMask | VisualClassMask;
   templat.screen = DefaultScreen(graw.display);
   templat.depth = 32;
   templat.class = TrueColor;

   visinfo = XGetVisualInfo(graw.display, mask, &templat, &n);
   if (!visinfo) {
      printf("Error: couldn't get an RGB, Double-buffered visual\n");
      exit(1);
   }

   /* See if the requirested pixel format matches the visual */
   if (visinfo->red_mask == 0xff0000 &&
       visinfo->green_mask == 0xff00 &&
       visinfo->blue_mask == 0xff) {
      if (format != PIPE_FORMAT_BGRA8888_UNORM)
         goto fail;
   }
   else if (visinfo->red_mask == 0xff &&
            visinfo->green_mask == 0xff00 &&
            visinfo->blue_mask == 0xff0000) {
      if (format != PIPE_FORMAT_RGBA8888_UNORM)
         goto fail;
   }
   else {
      goto fail;
   }

   /* window attributes */
   attr.background_pixel = 0;
   attr.border_pixel = 0;
   attr.colormap = XCreateColormap( graw.display, root, visinfo->visual, AllocNone);
   attr.event_mask = StructureNotifyMask | ExposureMask | KeyPressMask;
   /* XXX this is a bad way to get a borderless window! */
   mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;

   win = XCreateWindow( graw.display, root, x, y, width, height,
		        0, visinfo->depth, InputOutput,
		        visinfo->visual, mask, &attr );


   /* set hints and properties */
   {
      char *name = NULL;
      XSizeHints sizehints;
      sizehints.x = x;
      sizehints.y = y;
      sizehints.width  = width;
      sizehints.height = height;
      sizehints.flags = USSize | USPosition;
      XSetNormalHints(graw.display, win, &sizehints);
      XSetStandardProperties(graw.display, win, name, name,
                              None, (char **)NULL, 0, &sizehints);
   }

   XMapWindow(graw.display, win);
   while (1) {
      XEvent e;
      XNextEvent( graw.display, &e );
      if (e.type == MapNotify && e.xmap.window == win) {
	 break;
      }
   }
   
   xlib_handle->visual = visinfo->visual;
   xlib_handle->drawable = (Drawable)win;
   xlib_handle->depth = visinfo->depth;
   *handle = (void *)xlib_handle;

   screen = graw_create_screen();
   if (screen == NULL)
      goto fail;

   free(visinfo);
   return screen;

fail:
   if (screen)
      screen->destroy(screen);

   FREE(xlib_handle);

   free(visinfo);

   if (win)
      XDestroyWindow(graw.display, win);

   return NULL;
}


void 
graw_set_display_func( void (*draw)( void ) )
{
   graw.draw = draw;
}

void
graw_main_loop( void )
{
   int i;
   for (i = 0; i < 10; i++) {
      graw.draw();
      sleep(1);
   }
}

@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d8 1
a8 1
#include "state_tracker/xlib_sw_winsys.h"
d10 1
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d92 1
a92 1
      if (format != PIPE_FORMAT_B8G8R8A8_UNORM)
d98 1
a98 1
      if (format != PIPE_FORMAT_R8G8B8A8_UNORM)
d150 1
a150 1
   XFree(visinfo);
d157 1
a157 2
   if (xlib_handle)
      FREE(xlib_handle);
d159 1
a159 2
   if (visinfo)
      XFree(visinfo);
@


1.1
log
@Initial revision
@
text
@a68 3
   if (format != PIPE_FORMAT_R8G8B8A8_UNORM)
      goto fail;

d86 17
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d69 3
a90 17
   /* See if the requirested pixel format matches the visual */
   if (visinfo->red_mask == 0xff0000 &&
       visinfo->green_mask == 0xff00 &&
       visinfo->blue_mask == 0xff) {
      if (format != PIPE_FORMAT_BGRA8888_UNORM)
         goto fail;
   }
   else if (visinfo->red_mask == 0xff &&
            visinfo->green_mask == 0xff00 &&
            visinfo->blue_mask == 0xff0000) {
      if (format != PIPE_FORMAT_RGBA8888_UNORM)
         goto fail;
   }
   else {
      goto fail;
   }

d136 1
a136 1
   free(visinfo);
d143 2
a144 1
   FREE(xlib_handle);
d146 2
a147 1
   free(visinfo);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d8 1
a8 1
#include "state_tracker/xlibsw_api.h"
a9 1
#include "sw/xlib/xlib_sw_winsys.h"
@


