head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.39;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.17;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2014.07.09.21.08.56;	author jsg;	state Exp;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.01.58;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.08;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.13.40;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.22;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.09.43;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.46.47;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2010-2011 LunarG Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#include "common/egl_g3d_loader.h"
#include "egldriver.h"
#include "egllog.h"
#include "loader.h"

#include "egl_pipe.h"
#include "egl_st.h"

static struct egl_g3d_loader egl_g3d_loader;

static struct st_module {
   boolean initialized;
   struct st_api *stapi;
} st_modules[ST_API_COUNT];

static struct st_api *
get_st_api(enum st_api_type api)
{
   struct st_module *stmod = &st_modules[api];

   if (!stmod->initialized) {
      stmod->stapi = egl_st_create_api(api);
      stmod->initialized = TRUE;
   }

   return stmod->stapi;
}


static struct pipe_screen *
create_drm_screen(const char *constname, int fd)
{
   struct pipe_screen *screen;
   char *name = (char *)constname;

   if (!name) {
      name = loader_get_driver_for_fd(fd, _LOADER_GALLIUM);
      if (!name)
         return NULL;
   }

   screen = egl_pipe_create_drm_screen(name, fd);
   if (screen)
      _eglLog(_EGL_INFO, "created a pipe screen for %s", name);
   else
      _eglLog(_EGL_WARNING, "failed to create a pipe screen for %s", name);

   if (name != constname)
      free(name);

   return screen;
}

static struct pipe_screen *
create_sw_screen(struct sw_winsys *ws)
{
   return egl_pipe_create_swrast_screen(ws);
}

static const struct egl_g3d_loader *
loader_init(void)
{
   int i;

   for (i = 0; i < ST_API_COUNT; i++)
      egl_g3d_loader.profile_masks[i] = egl_st_get_profile_mask(i);

   egl_g3d_loader.get_st_api = get_st_api;
   egl_g3d_loader.create_drm_screen = create_drm_screen;
   egl_g3d_loader.create_sw_screen = create_sw_screen;

   loader_set_logger(_eglLog);

   return &egl_g3d_loader;
}

static void
loader_fini(void)
{
   int i;

   for (i = 0; i < ST_API_COUNT; i++) {
      struct st_module *stmod = &st_modules[i];

      if (stmod->stapi) {
         egl_st_destroy_api(stmod->stapi);
         stmod->stapi = NULL;
      }
      stmod->initialized = FALSE;
   }
}

static void
egl_g3d_unload(_EGLDriver *drv)
{
   egl_g3d_destroy_driver(drv);
   loader_fini();
}

_EGLDriver *
_EGL_MAIN(const char *args)
{
   const struct egl_g3d_loader *loader;
   _EGLDriver *drv;

   loader = loader_init();
   drv = egl_g3d_create_driver(loader);
   if (!drv) {
      loader_fini();
      return NULL;
   }

   drv->Name = "Gallium";
   drv->Unload = egl_g3d_unload;

   return drv;
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a34 1
#include "target-helpers/inline_drm_helper.h"
d60 19
a78 1
   return dd_create_screen(fd);
d90 5
@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d35 1
d61 1
a61 19
   struct pipe_screen *screen;
   char *name = (char *)constname;

   if (!name) {
      name = loader_get_driver_for_fd(fd, _LOADER_GALLIUM);
      if (!name)
         return NULL;
   }

   screen = egl_pipe_create_drm_screen(name, fd);
   if (screen)
      _eglLog(_EGL_INFO, "created a pipe screen for %s", name);
   else
      _eglLog(_EGL_WARNING, "failed to create a pipe screen for %s", name);

   if (name != constname)
      free(name);

   return screen;
a72 5
   int i;

   for (i = 0; i < ST_API_COUNT; i++)
      egl_g3d_loader.profile_masks[i] = egl_st_get_profile_mask(i);

@


1.2
log
@Merge Mesa 9.2.0
@
text
@d31 1
a31 8

#ifdef HAVE_LIBUDEV
#include <stdio.h> /* for sscanf */
#include <libudev.h>
#endif

#define DRIVER_MAP_GALLIUM_ONLY
#include "pci_ids/pci_id_driver_map.h"
a55 166
#ifdef HAVE_LIBUDEV

static boolean
drm_fd_get_pci_id(int fd, int *vendor_id, int *chip_id)
{
   struct udev *udev = NULL;
   struct udev_device *device = NULL, *parent;
   struct stat buf;
   const char *pci_id;

   *chip_id = -1;

   udev = udev_new();
   if (fstat(fd, &buf) < 0) {
      _eglLog(_EGL_WARNING, "failed to stat fd %d", fd);
      goto out;
   }

   device = udev_device_new_from_devnum(udev, 'c', buf.st_rdev);
   if (device == NULL) {
      _eglLog(_EGL_WARNING,
              "could not create udev device for fd %d", fd);
      goto out;
   }

   parent = udev_device_get_parent(device);
   if (parent == NULL) {
      _eglLog(_EGL_WARNING, "could not get parent device");
      goto out;
   }

   pci_id = udev_device_get_property_value(parent, "PCI_ID");
   if (pci_id == NULL ||
       sscanf(pci_id, "%x:%x", vendor_id, chip_id) != 2) {
      _eglLog(_EGL_WARNING, "malformed or no PCI ID");
      *chip_id = -1;
      goto out;
   }

out:
   if (device)
      udev_device_unref(device);
   if (udev)
      udev_unref(udev);

   return (*chip_id >= 0);
}

#elif defined(PIPE_OS_ANDROID) && !defined(_EGL_NO_DRM)

#include <xf86drm.h>
/* for i915 */
#include <i915_drm.h>
/* for radeon */
#include <radeon_drm.h>
/* for util_strcmp */
#include "util/u_string.h"

static boolean
drm_fd_get_pci_id(int fd, int *vendor_id, int *chip_id)
{
   drmVersionPtr version;

   *chip_id = -1;

   version = drmGetVersion(fd);
   if (!version) {
      _eglLog(_EGL_WARNING, "invalid drm fd");
      return FALSE;
   }
   if (!version->name) {
      _eglLog(_EGL_WARNING, "unable to determine the driver name");
      drmFreeVersion(version);
      return FALSE;
   }

   if (util_strcmp(version->name, "i915") == 0) {
      struct drm_i915_getparam gp;
      int ret;

      *vendor_id = 0x8086;

      memset(&gp, 0, sizeof(gp));
      gp.param = I915_PARAM_CHIPSET_ID;
      gp.value = chip_id;
      ret = drmCommandWriteRead(fd, DRM_I915_GETPARAM, &gp, sizeof(gp));
      if (ret) {
         _eglLog(_EGL_WARNING, "failed to get param for i915");
	 *chip_id = -1;
      }
   }
   else if (util_strcmp(version->name, "radeon") == 0) {
      struct drm_radeon_info info;
      int ret;

      *vendor_id = 0x1002;

      memset(&info, 0, sizeof(info));
      info.request = RADEON_INFO_DEVICE_ID;
      info.value = (unsigned long) chip_id;
      ret = drmCommandWriteRead(fd, DRM_RADEON_INFO, &info, sizeof(info));
      if (ret) {
         _eglLog(_EGL_WARNING, "failed to get info for radeon");
	 *chip_id = -1;
      }
   }
   else if (util_strcmp(version->name, "nouveau") == 0) {
      *vendor_id = 0x10de;
      /* not used */
      *chip_id = 0;
   }
   else if (util_strcmp(version->name, "vmwgfx") == 0) {
      *vendor_id = 0x15ad;
      /* assume SVGA II */
      *chip_id = 0x0405;
   }

   drmFreeVersion(version);

   return (*chip_id >= 0);
}

#else

static boolean
drm_fd_get_pci_id(int fd, int *vendor_id, int *chip_id)
{
   return FALSE;
}

#endif /* HAVE_LIBUDEV */

static const char *
drm_fd_get_screen_name(int fd)
{
   int vendor_id, chip_id;
   int idx, i;

   if (!drm_fd_get_pci_id(fd, &vendor_id, &chip_id)) {
      _eglLog(_EGL_WARNING, "failed to get driver name for fd %d", fd);
      return NULL;
   }

   for (idx = 0; driver_map[idx].driver; idx++) {
      if (vendor_id != driver_map[idx].vendor_id)
         continue;

      /* done if no chip id */
      if (driver_map[idx].num_chips_ids == -1)
         break;

      for (i = 0; i < driver_map[idx].num_chips_ids; i++) {
         if (driver_map[idx].chip_ids[i] == chip_id)
            break;
      }
      /* matched! */
      if (i < driver_map[idx].num_chips_ids)
         break;
   }

   _eglLog((driver_map[idx].driver) ? _EGL_INFO : _EGL_WARNING,
         "pci id for fd %d: %04x:%04x, driver %s",
         fd, vendor_id, chip_id, driver_map[idx].driver);

   return driver_map[idx].driver;
}
d58 1
a58 1
create_drm_screen(const char *name, int fd)
d61 1
d64 1
a64 1
      name = drm_fd_get_screen_name(fd);
d75 3
d98 2
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.10
d33 1
a33 1
#include <stdio.h>
d35 2
a38 1
#endif
d63 4
a66 2
static const char *
drm_fd_get_screen_name(int fd)
d68 2
a69 3
#ifdef HAVE_LIBUDEV
   struct udev *udev;
   struct udev_device *device, *parent;
d72 2
a73 1
   int vendor_id, chip_id, idx = -1, i;
d78 1
a78 1
      return NULL;
d85 1
a85 1
      return NULL;
d96 1
a96 1
       sscanf(pci_id, "%x:%x", &vendor_id, &chip_id) != 2) {
d98 1
d102 104
a205 1
   /* find the driver index */
d210 1
d212 1
a212 1
         goto out;
d216 1
a216 1
            goto out;
d218 3
d223 3
a225 8
out:
   udev_device_unref(device);
   udev_unref(udev);

   if (idx >= 0) {
      _eglLog((driver_map[idx].driver) ? _EGL_INFO : _EGL_WARNING,
            "pci id for fd %d: %04x:%04x, driver %s",
            fd, vendor_id, chip_id, driver_map[idx].driver);
d227 1
a227 7
      return driver_map[idx].driver;
   }
#endif

   _eglLog(_EGL_WARNING, "failed to get driver name for fd %d", fd);

   return NULL;
d233 2
d241 7
a247 1
   return egl_pipe_create_drm_screen(name, fd);
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d3 1
d34 1
a34 1
#include <stdio.h> /* for sscanf */
a35 2
#endif

d38 1
d63 3
d67 2
a68 6

static boolean
drm_fd_get_pci_id(int fd, int *vendor_id, int *chip_id)
{
   struct udev *udev = NULL;
   struct udev_device *device = NULL, *parent;
d71 1
a71 2

   *chip_id = -1;
d76 1
a76 1
      goto out;
d83 1
a83 1
      goto out;
d94 1
a94 1
       sscanf(pci_id, "%x:%x", vendor_id, chip_id) != 2) {
a95 1
      *chip_id = -1;
d99 1
a99 104
out:
   if (device)
      udev_device_unref(device);
   if (udev)
      udev_unref(udev);

   return (*chip_id >= 0);
}

#elif defined(PIPE_OS_ANDROID) && !defined(_EGL_NO_DRM)

#include <xf86drm.h>
/* for i915 */
#include <i915_drm.h>
/* for radeon */
#include <radeon_drm.h>
/* for util_strcmp */
#include "util/u_string.h"

static boolean
drm_fd_get_pci_id(int fd, int *vendor_id, int *chip_id)
{
   drmVersionPtr version;

   *chip_id = -1;

   version = drmGetVersion(fd);
   if (!version) {
      _eglLog(_EGL_WARNING, "invalid drm fd");
      return FALSE;
   }
   if (!version->name) {
      _eglLog(_EGL_WARNING, "unable to determine the driver name");
      drmFreeVersion(version);
      return FALSE;
   }

   if (util_strcmp(version->name, "i915") == 0) {
      struct drm_i915_getparam gp;
      int ret;

      *vendor_id = 0x8086;

      memset(&gp, 0, sizeof(gp));
      gp.param = I915_PARAM_CHIPSET_ID;
      gp.value = chip_id;
      ret = drmCommandWriteRead(fd, DRM_I915_GETPARAM, &gp, sizeof(gp));
      if (ret) {
         _eglLog(_EGL_WARNING, "failed to get param for i915");
	 *chip_id = -1;
      }
   }
   else if (util_strcmp(version->name, "radeon") == 0) {
      struct drm_radeon_info info;
      int ret;

      *vendor_id = 0x1002;

      memset(&info, 0, sizeof(info));
      info.request = RADEON_INFO_DEVICE_ID;
      info.value = (unsigned long) chip_id;
      ret = drmCommandWriteRead(fd, DRM_RADEON_INFO, &info, sizeof(info));
      if (ret) {
         _eglLog(_EGL_WARNING, "failed to get info for radeon");
	 *chip_id = -1;
      }
   }
   else if (util_strcmp(version->name, "nouveau") == 0) {
      *vendor_id = 0x10de;
      /* not used */
      *chip_id = 0;
   }
   else if (util_strcmp(version->name, "vmwgfx") == 0) {
      *vendor_id = 0x15ad;
      /* assume SVGA II */
      *chip_id = 0x0405;
   }

   drmFreeVersion(version);

   return (*chip_id >= 0);
}

#else

static boolean
drm_fd_get_pci_id(int fd, int *vendor_id, int *chip_id)
{
   return FALSE;
}

#endif /* HAVE_LIBUDEV */

static const char *
drm_fd_get_screen_name(int fd)
{
   int vendor_id, chip_id;
   int idx, i;

   if (!drm_fd_get_pci_id(fd, &vendor_id, &chip_id)) {
      _eglLog(_EGL_WARNING, "failed to get driver name for fd %d", fd);
      return NULL;
   }

a103 1
      /* done if no chip id */
d105 1
a105 1
         break;
d109 1
a109 1
            break;
a110 3
      /* matched! */
      if (i < driver_map[idx].num_chips_ids)
         break;
d113 8
a120 3
   _eglLog((driver_map[idx].driver) ? _EGL_INFO : _EGL_WARNING,
         "pci id for fd %d: %04x:%04x, driver %s",
         fd, vendor_id, chip_id, driver_map[idx].driver);
d122 7
a128 1
   return driver_map[idx].driver;
a133 2
   struct pipe_screen *screen;

d140 1
a140 7
   screen = egl_pipe_create_drm_screen(name, fd);
   if (screen)
      _eglLog(_EGL_INFO, "created a pipe screen for %s", name);
   else
      _eglLog(_EGL_WARNING, "failed to create a pipe screen for %s", name);

   return screen;
@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d31 8
a38 1
#include "loader.h"
d63 166
d231 1
a231 1
create_drm_screen(const char *constname, int fd)
a233 1
   char *name = (char *)constname;
d236 1
a236 1
      name = loader_get_driver_for_fd(fd, _LOADER_GALLIUM);
a246 3
   if (name != constname)
      free(name);

a266 2

   loader_set_logger(_eglLog);
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a34 1
#include "target-helpers/inline_drm_helper.h"
d60 19
a78 1
   return dd_create_screen(fd);
d90 5
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d35 1
d61 1
a61 19
   struct pipe_screen *screen;
   char *name = (char *)constname;

   if (!name) {
      name = loader_get_driver_for_fd(fd, _LOADER_GALLIUM);
      if (!name)
         return NULL;
   }

   screen = egl_pipe_create_drm_screen(name, fd);
   if (screen)
      _eglLog(_EGL_INFO, "created a pipe screen for %s", name);
   else
      _eglLog(_EGL_WARNING, "failed to create a pipe screen for %s", name);

   if (name != constname)
      free(name);

   return screen;
a72 5
   int i;

   for (i = 0; i < ST_API_COUNT; i++)
      egl_g3d_loader.profile_masks[i] = egl_st_get_profile_mask(i);

@


