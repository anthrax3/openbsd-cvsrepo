head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.07.09.21.08.56;	author jsg;	state dead;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.54;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.30;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 * Author: Alan Hourihane <alanh@@tungstengraphics.com>
 * Author: Jakob Bornecrantz <wallbraker@@gmail.com>
 *
 */

#include "xorg_exa.h"
#include "xorg_tracker.h"
#include "xorg_composite.h"
#include "xorg_exa_tgsi.h"

#include <xorg-server.h>
#include <xf86.h>
#include <picturestr.h>
#include <picture.h>

#include "pipe/p_format.h"
#include "pipe/p_context.h"
#include "pipe/p_state.h"

#include "util/u_rect.h"
#include "util/u_math.h"
#include "util/u_debug.h"
#include "util/u_format.h"
#include "util/u_box.h"
#include "util/u_surface.h"

#define ROUND_UP_TEXTURES 1

static INLINE void
exa_debug_printf(const char *format, ...) _util_printf_format(1,2);

static INLINE void
exa_debug_printf(const char *format, ...)
{
#if 0
   va_list ap;
   va_start(ap, format);
   _debug_vprintf(format, ap);
   va_end(ap);
#else
   (void) format; /* silence warning */
#endif
}

/*
 * Helper functions
 */
struct render_format_str {
   int format;
   const char *name;
};
static const struct render_format_str formats_info[] =
{
   {PICT_a8r8g8b8, "PICT_a8r8g8b8"},
   {PICT_x8r8g8b8, "PICT_x8r8g8b8"},
   {PICT_a8b8g8r8, "PICT_a8b8g8r8"},
   {PICT_x8b8g8r8, "PICT_x8b8g8r8"},
#ifdef PICT_TYPE_BGRA
   {PICT_b8g8r8a8, "PICT_b8g8r8a8"},
   {PICT_b8g8r8x8, "PICT_b8g8r8x8"},
   {PICT_a2r10g10b10, "PICT_a2r10g10b10"},
   {PICT_x2r10g10b10, "PICT_x2r10g10b10"},
   {PICT_a2b10g10r10, "PICT_a2b10g10r10"},
   {PICT_x2b10g10r10, "PICT_x2b10g10r10"},
#endif
   {PICT_r8g8b8, "PICT_r8g8b8"},
   {PICT_b8g8r8, "PICT_b8g8r8"},
   {PICT_r5g6b5, "PICT_r5g6b5"},
   {PICT_b5g6r5, "PICT_b5g6r5"},
   {PICT_a1r5g5b5, "PICT_a1r5g5b5"},
   {PICT_x1r5g5b5, "PICT_x1r5g5b5"},
   {PICT_a1b5g5r5, "PICT_a1b5g5r5"},
   {PICT_x1b5g5r5, "PICT_x1b5g5r5"},
   {PICT_a4r4g4b4, "PICT_a4r4g4b4"},
   {PICT_x4r4g4b4, "PICT_x4r4g4b4"},
   {PICT_a4b4g4r4, "PICT_a4b4g4r4"},
   {PICT_x4b4g4r4, "PICT_x4b4g4r4"},
   {PICT_a8, "PICT_a8"},
   {PICT_r3g3b2, "PICT_r3g3b2"},
   {PICT_b2g3r3, "PICT_b2g3r3"},
   {PICT_a2r2g2b2, "PICT_a2r2g2b2"},
   {PICT_a2b2g2r2, "PICT_a2b2g2r2"},
   {PICT_c8, "PICT_c8"},
   {PICT_g8, "PICT_g8"},
   {PICT_x4a4, "PICT_x4a4"},
   {PICT_x4c4, "PICT_x4c4"},
   {PICT_x4g4, "PICT_x4g4"},
   {PICT_a4, "PICT_a4"},
   {PICT_r1g2b1, "PICT_r1g2b1"},
   {PICT_b1g2r1, "PICT_b1g2r1"},
   {PICT_a1r1g1b1, "PICT_a1r1g1b1"},
   {PICT_a1b1g1r1, "PICT_a1b1g1r1"},
   {PICT_c4, "PICT_c4"},
   {PICT_g4, "PICT_g4"},
   {PICT_a1, "PICT_a1"},
   {PICT_g1, "PICT_g1"}
};
static const char *render_format_name(int format)
{
   int i = 0;
   for (i = 0; i < sizeof(formats_info)/sizeof(formats_info[0]); ++i) {
      if (formats_info[i].format == format)
         return formats_info[i].name;
   }
   return NULL;
}

static void
exa_get_pipe_format(int depth, enum pipe_format *format, int *bbp, int *picture_format)
{
    switch (depth) {
    case 32:
	*format = PIPE_FORMAT_B8G8R8A8_UNORM;
	*picture_format = PICT_a8r8g8b8;
	assert(*bbp == 32);
	break;
    case 24:
	*format = PIPE_FORMAT_B8G8R8X8_UNORM;
	*picture_format = PICT_x8r8g8b8;
	assert(*bbp == 32);
	break;
    case 16:
	*format = PIPE_FORMAT_B5G6R5_UNORM;
	*picture_format = PICT_r5g6b5;
	assert(*bbp == 16);
	break;
    case 15:
	*format = PIPE_FORMAT_B5G5R5A1_UNORM;
	*picture_format = PICT_x1r5g5b5;
	assert(*bbp == 16);
	break;
    case 8:
	*format = PIPE_FORMAT_L8_UNORM;
	*picture_format = PICT_a8;
	assert(*bbp == 8);
	break;
    case 4:
    case 1:
	*format = PIPE_FORMAT_B8G8R8A8_UNORM; /* bad bad bad */
	break;
    default:
	assert(0);
	break;
    }
}


/*
 * Static exported EXA functions
 */

static void
ExaWaitMarker(ScreenPtr pScreen, int marker)
{
   /* Nothing to do, handled in the PrepareAccess hook */
}

static int
ExaMarkSync(ScreenPtr pScreen)
{
   return 1;
}


/***********************************************************************
 * Screen upload/download
 */

static Bool
ExaDownloadFromScreen(PixmapPtr pPix, int x,  int y, int w,  int h, char *dst,
		      int dst_pitch)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_context *exa = ms->exa;
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPix);
    struct pipe_transfer *transfer;
    void *map;

    if (!priv || !priv->tex)
	return FALSE;

    map = pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
                            PIPE_TRANSFER_READ, x, y, w, h, &transfer);
    if (!map)
	return FALSE;

    exa_debug_printf("------ ExaDownloadFromScreen(%d, %d, %d, %d, %d)\n",
                 x, y, w, h, dst_pitch);

    util_copy_rect((unsigned char*)dst, priv->tex->format, dst_pitch, 0, 0,
		   w, h, map, transfer->stride, 0, 0);

    exa->pipe->transfer_unmap(exa->pipe, transfer);

    return TRUE;
}

static Bool
ExaUploadToScreen(PixmapPtr pPix, int x, int y, int w, int h, char *src,
		  int src_pitch)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_context *exa = ms->exa;
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPix);
    struct pipe_transfer *transfer;
    void *map;

    if (!priv || !priv->tex)
	return FALSE;

    map = pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
                            PIPE_TRANSFER_WRITE, x, y, w, h, &transfer);
    if (!map)
	return FALSE;

    exa_debug_printf("++++++ ExaUploadToScreen(%d, %d, %d, %d, %d)\n",
                 x, y, w, h, src_pitch);

    util_copy_rect(map,
		   priv->tex->format, transfer->stride, 0, 0, w, h,
		   (unsigned char*)src, src_pitch, 0, 0);

    exa->pipe->transfer_unmap(exa->pipe, transfer);

    return TRUE;
}

static Bool
ExaPrepareAccess(PixmapPtr pPix, int index)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_context *exa = ms->exa;
    struct exa_pixmap_priv *priv;

    priv = exaGetPixmapDriverPrivate(pPix);

    if (!priv)
	return FALSE;

    if (!priv->tex)
	return FALSE;

    exa_debug_printf("ExaPrepareAccess %d\n", index);

    if (priv->map_count == 0)
    {
        assert(pPix->drawable.width <= priv->tex->width0);
        assert(pPix->drawable.height <= priv->tex->height0);

	pPix->devPrivate.ptr =
	   pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
#ifdef EXA_MIXED_PIXMAPS
                             PIPE_TRANSFER_MAP_DIRECTLY |
#endif
                             PIPE_TRANSFER_READ_WRITE,
                             0, 0,
                             pPix->drawable.width,
                             pPix->drawable.height,
                             &priv->map_transfer);
        if (!pPix->devPrivate.ptr)
#ifdef EXA_MIXED_PIXMAPS
	    return FALSE;
#else
	    FatalError("failed to create transfer\n");
#endif

	pPix->devKind = priv->map_transfer->stride;
    }

    priv->map_count++;

    exa_debug_printf("ExaPrepareAccess %d prepared\n", index);

    return TRUE;
}

static void
ExaFinishAccess(PixmapPtr pPix, int index)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_context *exa = ms->exa;
    struct exa_pixmap_priv *priv;
    priv = exaGetPixmapDriverPrivate(pPix);

    if (!priv)
	return;

    if (!priv->map_transfer)
	return;

    exa_debug_printf("ExaFinishAccess %d\n", index);

    if (--priv->map_count == 0) {
	assert(priv->map_transfer);
	exa->pipe->transfer_unmap(exa->pipe, priv->map_transfer);
	priv->map_transfer = NULL;
	pPix->devPrivate.ptr = NULL;
    }

    exa_debug_printf("ExaFinishAccess %d finished\n", index);
}

/***********************************************************************
 * Solid Fills
 */

static Bool
ExaPrepareSolid(PixmapPtr pPixmap, int alu, Pixel planeMask, Pixel fg)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
    struct exa_context *exa = ms->exa;

    exa_debug_printf("ExaPrepareSolid(0x%x)\n", fg);

    if (!exa->accel)
	return FALSE;

    if (!exa->pipe)
	XORG_FALLBACK("accel not enabled");

    if (!priv || !priv->tex)
	XORG_FALLBACK("%s", !priv ? "!priv" : "!priv->tex");

    if (!EXA_PM_IS_SOLID(&pPixmap->drawable, planeMask))
	XORG_FALLBACK("planeMask is not solid");

    if (alu != GXcopy)
	XORG_FALLBACK("not GXcopy");

    if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
                                        priv->tex->target, 0,
                                        PIPE_BIND_RENDER_TARGET)) {
	XORG_FALLBACK("format %s", util_format_name(priv->tex->format));
    }

    return xorg_solid_bind_state(exa, priv, fg);
}

static void
ExaSolid(PixmapPtr pPixmap, int x0, int y0, int x1, int y1)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_context *exa = ms->exa;
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);

    exa_debug_printf("\tExaSolid(%d, %d, %d, %d)\n", x0, y0, x1, y1);

    if (x0 == 0 && y0 == 0 &&
        x1 == pPixmap->drawable.width && y1 == pPixmap->drawable.height) {
       union pipe_color_union solid_color;
       solid_color.f[0] = exa->solid_color[0];
       solid_color.f[1] = exa->solid_color[1];
       solid_color.f[2] = exa->solid_color[2];
       solid_color.f[3] = exa->solid_color[3];
       exa->pipe->clear(exa->pipe, PIPE_CLEAR_COLOR, &solid_color, 0.0, 0);
       return;
    }

    xorg_solid(exa, priv, x0, y0, x1, y1) ;
}


static void
ExaDoneSolid(PixmapPtr pPixmap)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
    struct exa_context *exa = ms->exa;

    if (!priv)
	return;

    exa_debug_printf("ExaDoneSolid\n");
    xorg_composite_done(exa);
    exa_debug_printf("ExaDoneSolid done\n");
}

/***********************************************************************
 * Copy Blits
 */

static Bool
ExaPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir,
	       int ydir, int alu, Pixel planeMask)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPixmap->drawable.pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_context *exa = ms->exa;
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pDstPixmap);
    struct exa_pixmap_priv *src_priv = exaGetPixmapDriverPrivate(pSrcPixmap);

    exa_debug_printf("ExaPrepareCopy\n");

    if (!exa->accel)
	return FALSE;

    if (!exa->pipe)
	XORG_FALLBACK("accel not enabled");

    if (!priv || !priv->tex)
	XORG_FALLBACK("pDst %s", !priv ? "!priv" : "!priv->tex");

    if (!src_priv || !src_priv->tex)
	XORG_FALLBACK("pSrc %s", !src_priv ? "!priv" : "!priv->tex");

    if (!EXA_PM_IS_SOLID(&pSrcPixmap->drawable, planeMask))
	XORG_FALLBACK("planeMask is not solid");

    if (alu != GXcopy)
	XORG_FALLBACK("alu not GXcopy");

    if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
                                        priv->tex->target, 0,
                                        PIPE_BIND_RENDER_TARGET))
	XORG_FALLBACK("pDst format %s", util_format_name(priv->tex->format));

    if (!exa->scrn->is_format_supported(exa->scrn, src_priv->tex->format,
                                        src_priv->tex->target, 0,
                                        PIPE_BIND_SAMPLER_VIEW))
	XORG_FALLBACK("pSrc format %s", util_format_name(src_priv->tex->format));

    exa->copy.src = src_priv;
    exa->copy.dst = priv;

    return TRUE;
}

static void
ExaCopy(PixmapPtr pDstPixmap, int srcX, int srcY, int dstX, int dstY,
	int width, int height)
{
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPixmap->drawable.pScreen);
   modesettingPtr ms = modesettingPTR(pScrn);
   struct exa_context *exa = ms->exa;
   struct pipe_box src_box;

   exa_debug_printf("\tExaCopy(srcx=%d, srcy=%d, dstX=%d, dstY=%d, w=%d, h=%d)\n",
                srcX, srcY, dstX, dstY, width, height);

   debug_assert(exaGetPixmapDriverPrivate(pDstPixmap) == exa->copy.dst);

   u_box_2d(srcX, srcY, width, height, &src_box);

   /* If source and destination overlap, we have to copy to/from a scratch
    * pixmap.
    */
   if (exa->copy.dst == exa->copy.src &&
       !((dstX + width) < srcX || dstX > (srcX + width) ||
	 (dstY + height) < srcY || dstY > (srcY + height))) {
      struct exa_pixmap_priv *tmp_priv;

      if (!exa->copy.tmp_pix) {
         exa->copy.tmp_pix = pScrn->pScreen->CreatePixmap(pScrn->pScreen,
                                                         pDstPixmap->drawable.width,
                                                         pDstPixmap->drawable.height,
                                                         pDstPixmap->drawable.depth,
                                                         pDstPixmap->drawable.width);
         exaMoveInPixmap(exa->copy.tmp_pix);
      }

      tmp_priv = exaGetPixmapDriverPrivate(exa->copy.tmp_pix);

      exa->pipe->resource_copy_region( exa->pipe,
                                       tmp_priv->tex,
                                       0,
                                       srcX, srcY, 0,
                                       exa->copy.src->tex,
                                       0, &src_box);
      exa->pipe->resource_copy_region( exa->pipe,
                                       exa->copy.dst->tex,
                                       0,
                                       dstX, dstY, 0,
                                       tmp_priv->tex,
                                       0, &src_box);
   } else
      exa->pipe->resource_copy_region( exa->pipe,
                                       exa->copy.dst->tex,
                                       0,
                                       dstX, dstY, 0,
                                       exa->copy.src->tex,
                                       0, &src_box);
}

static void
ExaDoneCopy(PixmapPtr pPixmap)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
    struct exa_context *exa = ms->exa;

    if (!priv)
	return;

   exa_debug_printf("ExaDoneCopy\n");

   if (exa->copy.tmp_pix) {
      pScrn->pScreen->DestroyPixmap(exa->copy.tmp_pix);
      exa->copy.tmp_pix = NULL;
   }
   exa->copy.src = NULL;
   exa->copy.dst = NULL;

   exa_debug_printf("ExaDoneCopy done\n");
}



static Bool
picture_check_formats(struct exa_pixmap_priv *pSrc, PicturePtr pSrcPicture)
{
   if (pSrc->picture_format == pSrcPicture->format)
      return TRUE;

   if (pSrc->picture_format != PICT_a8r8g8b8)
      return FALSE;

   /* pSrc->picture_format == PICT_a8r8g8b8 */
   switch (pSrcPicture->format) {
   case PICT_a8r8g8b8:
   case PICT_x8r8g8b8:
   case PICT_a8b8g8r8:
   case PICT_x8b8g8r8:
   /* just treat these two as x8... */
   case PICT_r8g8b8:
   case PICT_b8g8r8:
      return TRUE;
#ifdef PICT_TYPE_BGRA
   case PICT_b8g8r8a8:
   case PICT_b8g8r8x8:
      return FALSE; /* does not support swizzleing the alpha channel yet */
   case PICT_a2r10g10b10:
   case PICT_x2r10g10b10:
   case PICT_a2b10g10r10:
   case PICT_x2b10g10r10:
      return FALSE;
#endif
   default:
      return FALSE;
   }
   return FALSE;
}

/***********************************************************************
 * Composite entrypoints
 */

static Bool
ExaCheckComposite(int op,
		  PicturePtr pSrcPicture, PicturePtr pMaskPicture,
		  PicturePtr pDstPicture)
{
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPicture->pDrawable->pScreen);
   modesettingPtr ms = modesettingPTR(pScrn);
   struct exa_context *exa = ms->exa;
   Bool accelerated = exa->accel && xorg_composite_accelerated(op,
				     pSrcPicture,
				     pMaskPicture,
				     pDstPicture);

   exa_debug_printf("ExaCheckComposite(%d, %p, %p, %p) = %d\n",
                op, pSrcPicture, pMaskPicture, pDstPicture, accelerated);

   return accelerated;
}


static Bool
ExaPrepareComposite(int op, PicturePtr pSrcPicture,
		    PicturePtr pMaskPicture, PicturePtr pDstPicture,
		    PixmapPtr pSrc, PixmapPtr pMask, PixmapPtr pDst)
{
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDst->drawable.pScreen);
   modesettingPtr ms = modesettingPTR(pScrn);
   struct exa_context *exa = ms->exa;
   struct exa_pixmap_priv *priv;

   if (!exa->accel)
       return FALSE;

   exa_debug_printf("ExaPrepareComposite(%d, src=0x%p, mask=0x%p, dst=0x%p)\n",
                op, pSrcPicture, pMaskPicture, pDstPicture);
   exa_debug_printf("\tFormats: src(%s), mask(%s), dst(%s)\n",
                pSrcPicture ? render_format_name(pSrcPicture->format) : "none",
                pMaskPicture ? render_format_name(pMaskPicture->format) : "none",
                pDstPicture ? render_format_name(pDstPicture->format) : "none");

   if (!exa->pipe)
      XORG_FALLBACK("accel not enabled");

   priv = exaGetPixmapDriverPrivate(pDst);
   if (!priv || !priv->tex)
      XORG_FALLBACK("pDst %s", !priv ? "!priv" : "!priv->tex");

   if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
                                       priv->tex->target, 0,
                                       PIPE_BIND_RENDER_TARGET))
      XORG_FALLBACK("pDst format: %s", util_format_name(priv->tex->format));

   if (priv->picture_format != pDstPicture->format)
      XORG_FALLBACK("pDst pic_format: %s != %s",
                    render_format_name(priv->picture_format),
                    render_format_name(pDstPicture->format));

   if (pSrc) {
      priv = exaGetPixmapDriverPrivate(pSrc);
      if (!priv || !priv->tex)
         XORG_FALLBACK("pSrc %s", !priv ? "!priv" : "!priv->tex");

      if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
                                          priv->tex->target, 0,
                                          PIPE_BIND_SAMPLER_VIEW))
         XORG_FALLBACK("pSrc format: %s", util_format_name(priv->tex->format));

      if (!picture_check_formats(priv, pSrcPicture))
         XORG_FALLBACK("pSrc pic_format: %s != %s",
                       render_format_name(priv->picture_format),
                       render_format_name(pSrcPicture->format));

   }

   if (pMask) {
      priv = exaGetPixmapDriverPrivate(pMask);
      if (!priv || !priv->tex)
         XORG_FALLBACK("pMask %s", !priv ? "!priv" : "!priv->tex");

      if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
                                          priv->tex->target, 0,
                                          PIPE_BIND_SAMPLER_VIEW))
         XORG_FALLBACK("pMask format: %s", util_format_name(priv->tex->format));

      if (!picture_check_formats(priv, pMaskPicture))
         XORG_FALLBACK("pMask pic_format: %s != %s",
                       render_format_name(priv->picture_format),
                       render_format_name(pMaskPicture->format));
   }

   return xorg_composite_bind_state(exa, op, pSrcPicture, pMaskPicture,
                                    pDstPicture,
                                    pSrc ? exaGetPixmapDriverPrivate(pSrc) : NULL,
                                    pMask ? exaGetPixmapDriverPrivate(pMask) : NULL,
                                    exaGetPixmapDriverPrivate(pDst));
}

static void
ExaComposite(PixmapPtr pDst, int srcX, int srcY, int maskX, int maskY,
	     int dstX, int dstY, int width, int height)
{
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDst->drawable.pScreen);
   modesettingPtr ms = modesettingPTR(pScrn);
   struct exa_context *exa = ms->exa;
   struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pDst);

   exa_debug_printf("\tExaComposite(src[%d,%d], mask=[%d, %d], dst=[%d, %d], dim=[%d, %d])\n",
                srcX, srcY, maskX, maskY, dstX, dstY, width, height);
   exa_debug_printf("\t   Num bound samplers = %d\n",
                exa->num_bound_samplers);

   xorg_composite(exa, priv, srcX, srcY, maskX, maskY,
                  dstX, dstY, width, height);
}



static void
ExaDoneComposite(PixmapPtr pPixmap)
{
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
   modesettingPtr ms = modesettingPTR(pScrn);
   struct exa_context *exa = ms->exa;

   xorg_composite_done(exa);
}


/***********************************************************************
 * Pixmaps
 */

static void *
ExaCreatePixmap(ScreenPtr pScreen, int size, int align)
{
    struct exa_pixmap_priv *priv;

    priv = calloc(1, sizeof(struct exa_pixmap_priv));
    if (!priv)
	return NULL;

    return priv;
}

static void
ExaDestroyPixmap(ScreenPtr pScreen, void *dPriv)
{
    struct exa_pixmap_priv *priv = (struct exa_pixmap_priv *)dPriv;

    if (!priv)
	return;

    pipe_resource_reference(&priv->tex, NULL);

    free(priv);
}

static Bool
ExaPixmapIsOffscreen(PixmapPtr pPixmap)
{
    struct exa_pixmap_priv *priv;

    priv = exaGetPixmapDriverPrivate(pPixmap);

    if (!priv)
	return FALSE;

    if (priv->tex)
	return TRUE;

    return FALSE;
}

int
xorg_exa_set_displayed_usage(PixmapPtr pPixmap)
{
    struct exa_pixmap_priv *priv;
    priv = exaGetPixmapDriverPrivate(pPixmap);

    if (!priv) {
	FatalError("NO PIXMAP PRIVATE\n");
	return 0;
    }

    priv->flags |= PIPE_BIND_SCANOUT;

    return 0;
}

int
xorg_exa_set_shared_usage(PixmapPtr pPixmap)
{
    struct exa_pixmap_priv *priv;
    priv = exaGetPixmapDriverPrivate(pPixmap);

    if (!priv) {
	FatalError("NO PIXMAP PRIVATE\n");
	return 0;
    }

    priv->flags |= PIPE_BIND_SHARED;

    return 0;
}



static Bool
size_match( int width, int tex_width )
{
#if ROUND_UP_TEXTURES
   if (width > tex_width)
      return FALSE;

   if (width * 2 < tex_width)
      return FALSE;

   return TRUE;
#else
   return width == tex_width;
#endif
}

static Bool
ExaModifyPixmapHeader(PixmapPtr pPixmap, int width, int height,
		      int depth, int bitsPerPixel, int devKind,
		      pointer pPixData)
{
    ScreenPtr pScreen = pPixmap->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_context *exa = ms->exa;

    if (!priv || pPixData)
	return FALSE;

    if (0) {
       debug_printf("%s pixmap %p sz %dx%dx%d devKind %d\n",
                    __FUNCTION__, pPixmap, width, height, bitsPerPixel, devKind);
       
       if (priv->tex)
          debug_printf("  ==> old texture %dx%d\n",
                       priv->tex->width0, 
                       priv->tex->height0);
    }


    if (depth <= 0)
	depth = pPixmap->drawable.depth;

    if (bitsPerPixel <= 0)
	bitsPerPixel = pPixmap->drawable.bitsPerPixel;

    if (width <= 0)
	width = pPixmap->drawable.width;

    if (height <= 0)
	height = pPixmap->drawable.height;

    if (width <= 0 || height <= 0 || depth <= 0)
	return FALSE;

    miModifyPixmapHeader(pPixmap, width, height, depth,
			     bitsPerPixel, devKind, NULL);

    priv->width = width;
    priv->height = height;

    /* Deal with screen resize */
    if ((exa->accel || priv->flags) &&
        (!priv->tex ||
         !size_match(width, priv->tex->width0) ||
         !size_match(height, priv->tex->height0) ||
         priv->tex_flags != priv->flags)) {
	struct pipe_resource *texture = NULL;
	struct pipe_resource template;

	memset(&template, 0, sizeof(template));
	template.target = PIPE_TEXTURE_2D;
	exa_get_pipe_format(depth, &template.format, &bitsPerPixel, &priv->picture_format);
        if (ROUND_UP_TEXTURES && priv->flags == 0) {
           template.width0 = util_next_power_of_two(width);
           template.height0 = util_next_power_of_two(height);
        }
        else {
           template.width0 = width;
           template.height0 = height;
        }

	template.depth0 = 1;
	template.array_size = 1;
	template.last_level = 0;
	template.bind = PIPE_BIND_RENDER_TARGET | priv->flags;
	priv->tex_flags = priv->flags;
	texture = exa->scrn->resource_create(exa->scrn, &template);

	if (priv->tex) {
            struct pipe_box src_box;
            u_box_origin_2d(min(width, texture->width0),
                            min(height, texture->height0),
                            &src_box);
            exa->pipe->resource_copy_region(exa->pipe, texture,
                                            0, 0, 0, 0,
                                            priv->tex,
                                            0, &src_box);
	}

	pipe_resource_reference(&priv->tex, texture);
	/* the texture we create has one reference */
	pipe_resource_reference(&texture, NULL);
    }

    return TRUE;
}

struct pipe_resource *
xorg_exa_get_texture(PixmapPtr pPixmap)
{
   struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
   struct pipe_resource *tex = NULL;
   pipe_resource_reference(&tex, priv->tex);
   return tex;
}

Bool
xorg_exa_set_texture(PixmapPtr pPixmap, struct  pipe_resource *tex)
{
    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);

    int mask = PIPE_BIND_SHARED | PIPE_BIND_SCANOUT;

    if (!priv)
	return FALSE;

    if (pPixmap->drawable.width != tex->width0 ||
	pPixmap->drawable.height != tex->height0)
	return FALSE;

    pipe_resource_reference(&priv->tex, tex);
    priv->tex_flags = tex->bind & mask;

    return TRUE;
}

struct pipe_resource *
xorg_exa_create_root_texture(ScrnInfoPtr pScrn,
			     int width, int height,
			     int depth, int bitsPerPixel)
{
    modesettingPtr ms = modesettingPTR(pScrn);
    struct exa_context *exa = ms->exa;
    struct pipe_resource template;
    int dummy;

    memset(&template, 0, sizeof(template));
    template.target = PIPE_TEXTURE_2D;
    exa_get_pipe_format(depth, &template.format, &bitsPerPixel, &dummy);
    template.width0 = width;
    template.height0 = height;
    template.depth0 = 1;
    template.array_size = 1;
    template.last_level = 0;
    template.bind |= PIPE_BIND_RENDER_TARGET;
    template.bind |= PIPE_BIND_SCANOUT;
    template.bind |= PIPE_BIND_SHARED;

    return exa->scrn->resource_create(exa->scrn, &template);
}

void
xorg_exa_close(ScrnInfoPtr pScrn)
{
   modesettingPtr ms = modesettingPTR(pScrn);
   struct exa_context *exa = ms->exa;

   pipe_sampler_view_reference(&exa->bound_sampler_views[0], NULL);
   pipe_sampler_view_reference(&exa->bound_sampler_views[1], NULL);

   renderer_destroy(exa->renderer);

   xorg_exa_finish(exa);

   if (exa->pipe)
      exa->pipe->destroy(exa->pipe);
   exa->pipe = NULL;
   /* Since this was shared be proper with the pointer */
   ms->ctx = NULL;

   exaDriverFini(pScrn->pScreen);
   free(exa);
   ms->exa = NULL;
}

void *
xorg_exa_init(ScrnInfoPtr pScrn, Bool accel)
{
   modesettingPtr ms = modesettingPTR(pScrn);
   struct exa_context *exa;
   ExaDriverPtr pExa;
   CustomizerPtr cust = ms->cust;

   exa = calloc(1, sizeof(struct exa_context));
   if (!exa)
      return NULL;

   exa->scrn = ms->screen;
   exa->pipe = exa->scrn->context_create(exa->scrn, NULL);
   if (exa->pipe == NULL)
      goto out_err;

   pExa = exaDriverAlloc();
   if (!pExa) {
      goto out_err;
   }

   pExa->exa_major         = 2;
   pExa->exa_minor         = 2;
   pExa->memoryBase        = 0;
   pExa->memorySize        = 0;
   pExa->offScreenBase     = 0;
   pExa->pixmapOffsetAlign = 0;
   pExa->pixmapPitchAlign  = 1;
   pExa->flags             = EXA_OFFSCREEN_PIXMAPS | EXA_HANDLES_PIXMAPS;
#ifdef EXA_SUPPORTS_PREPARE_AUX
   pExa->flags            |= EXA_SUPPORTS_PREPARE_AUX;
#endif
#ifdef EXA_MIXED_PIXMAPS
   pExa->flags            |= EXA_MIXED_PIXMAPS;
#endif

   pExa->maxX = pExa->maxY =
   1 << (exa->scrn->get_param(exa->scrn, PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);

   pExa->WaitMarker         = ExaWaitMarker;
   pExa->MarkSync           = ExaMarkSync;
   pExa->PrepareSolid       = ExaPrepareSolid;
   pExa->Solid              = ExaSolid;
   pExa->DoneSolid          = ExaDoneSolid;
   pExa->PrepareCopy        = ExaPrepareCopy;
   pExa->Copy               = ExaCopy;
   pExa->DoneCopy           = ExaDoneCopy;
   pExa->CheckComposite     = ExaCheckComposite;
   pExa->PrepareComposite   = ExaPrepareComposite;
   pExa->Composite          = ExaComposite;
   pExa->DoneComposite      = ExaDoneComposite;
   pExa->PixmapIsOffscreen  = ExaPixmapIsOffscreen;
   pExa->DownloadFromScreen = ExaDownloadFromScreen;
   pExa->UploadToScreen     = ExaUploadToScreen;
   pExa->PrepareAccess      = ExaPrepareAccess;
   pExa->FinishAccess       = ExaFinishAccess;
   pExa->CreatePixmap       = ExaCreatePixmap;
   pExa->DestroyPixmap      = ExaDestroyPixmap;
   pExa->ModifyPixmapHeader = ExaModifyPixmapHeader;

   if (!exaDriverInit(pScrn->pScreen, pExa)) {
      goto out_err;
   }

   /* Share context with DRI */
   ms->ctx = exa->pipe;
   if (cust && cust->winsys_context_throttle)
       cust->winsys_context_throttle(cust, ms->ctx, THROTTLE_RENDER);

   exa->renderer = renderer_create(exa->pipe);
   exa->accel = accel;

   return (void *)exa;

out_err:
   xorg_exa_close(pScrn);
   free(exa);

   return NULL;
}

struct pipe_surface *
xorg_gpu_surface(struct pipe_context *pipe, struct exa_pixmap_priv *priv)
{
   struct pipe_surface surf_tmpl;
   u_surface_default_template(&surf_tmpl, priv->tex);

   return pipe->create_surface(pipe, priv->tex, &surf_tmpl);

}

void xorg_exa_flush(struct exa_context *exa,
                    struct pipe_fence_handle **fence)
{
   exa->pipe->flush(exa->pipe, fence, 0);
}

void xorg_exa_finish(struct exa_context *exa)
{
   struct pipe_fence_handle *fence = NULL;

   xorg_exa_flush(exa, &fence);

   exa->pipe->screen->fence_finish(exa->pipe->screen, fence,
                                   PIPE_TIMEOUT_INFINITE);
   exa->pipe->screen->fence_reference(exa->pipe->screen, &fence, NULL);
}

@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d199 1
a199 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d204 1
d209 3
a211 3
    transfer = pipe_get_transfer(exa->pipe, priv->tex, 0, 0,
                                 PIPE_TRANSFER_READ, x, y, w, h);
    if (!transfer)
d218 1
a218 2
		   w, h, exa->pipe->transfer_map(exa->pipe, transfer),
		   transfer->stride, 0, 0);
a220 1
    exa->pipe->transfer_destroy(exa->pipe, transfer);
d230 1
a230 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d235 1
d240 3
a242 3
    transfer = pipe_get_transfer(exa->pipe, priv->tex, 0, 0,
                                 PIPE_TRANSFER_WRITE, x, y, w, h);
    if (!transfer)
d248 1
a248 1
    util_copy_rect(exa->pipe->transfer_map(exa->pipe, transfer),
a252 1
    exa->pipe->transfer_destroy(exa->pipe, transfer);
d261 1
a261 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d281 2
a282 2
	priv->map_transfer =
	   pipe_get_transfer(exa->pipe, priv->tex, 0, 0,
d284 1
a284 1
					PIPE_TRANSFER_MAP_DIRECTLY |
d286 6
a291 5
					PIPE_TRANSFER_READ_WRITE,
					0, 0, 
                                        pPix->drawable.width,
                                        pPix->drawable.height );
	if (!priv->map_transfer)
a297 2
	pPix->devPrivate.ptr =
	    exa->pipe->transfer_map(exa->pipe, priv->map_transfer);
d312 1
a312 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
a328 1
	exa->pipe->transfer_destroy(exa->pipe, priv->map_transfer);
d343 1
a343 1
    ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
d377 1
a377 1
    ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
d386 6
a391 1
       exa->pipe->clear(exa->pipe, PIPE_CLEAR_COLOR, exa->solid_color, 0.0, 0);
d402 1
a402 1
    ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
d423 1
a423 1
    ScrnInfoPtr pScrn = xf86Screens[pDstPixmap->drawable.pScreen->myNum];
a461 35
    /* XXX this used to use resource_copy_region for same-surface copies,
     * but they were redefined to not allow overlaps (some of the util code
     * always assumed this anyway).
     * Drivers should implement accelerated resource_copy_region or it will
     * be slow - disable for now.
     */
    if (0 && exa->copy.src != exa->copy.dst) {
       exa->copy.use_surface_copy = TRUE;
    }
    else {
       struct pipe_surface surf_tmpl;
       exa->copy.use_surface_copy = FALSE;

       if (exa->copy.dst == exa->copy.src)
          exa->copy.src_texture = renderer_clone_texture( exa->renderer,
                                                          exa->copy.src->tex );
       else
          pipe_resource_reference(&exa->copy.src_texture,
                                 exa->copy.src->tex);

       memset(&surf_tmpl, 0, sizeof(surf_tmpl));
       u_surface_default_template(&surf_tmpl, exa->copy.dst->tex,
                                  PIPE_BIND_RENDER_TARGET);
       exa->copy.dst_surface =
          exa->pipe->create_surface(exa->pipe,
                                    exa->copy.dst->tex,
                                    &surf_tmpl);


       renderer_copy_prepare(exa->renderer, 
                             exa->copy.dst_surface,
                             exa->copy.src_texture );
    }


d469 1
a469 1
   ScrnInfoPtr pScrn = xf86Screens[pDstPixmap->drawable.pScreen->myNum];
d472 1
a472 1
   struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pDstPixmap);
d477 22
a498 2
   debug_assert(priv == exa->copy.dst);
   (void) priv;
d500 13
a512 3
   if (exa->copy.use_surface_copy) {
      struct pipe_box src_box;
      u_box_2d(srcX, srcY, width, height, &src_box);
a518 9
   }
   else {
      renderer_copy_pixmap(exa->renderer, 
                           dstX, dstY,
                           srcX, srcY,
                           width, height,
                           exa->copy.src_texture->width0,
                           exa->copy.src_texture->height0);
   }
d524 1
a524 1
    ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
d534 4
a537 2
   renderer_draw_flush(exa->renderer);

a539 2
   pipe_surface_reference(&exa->copy.dst_surface, NULL);
   pipe_resource_reference(&exa->copy.src_texture, NULL);
d590 1
a590 1
   ScrnInfoPtr pScrn = xf86Screens[pDstPicture->pDrawable->pScreen->myNum];
d610 1
a610 1
   ScrnInfoPtr pScrn = xf86Screens[pDst->drawable.pScreen->myNum];
d686 1
a686 1
   ScrnInfoPtr pScrn = xf86Screens[pDst->drawable.pScreen->myNum];
d705 1
a705 1
   ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
d814 1
a814 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d991 5
a1000 2
   memset(pExa, 0, sizeof(*pExa));

d1015 3
a1017 2
   pExa->maxX              = 8191; /* FIXME */
   pExa->maxY              = 8191; /* FIXME */
a1043 5
   exa->scrn = ms->screen;
   exa->pipe = exa->scrn->context_create(exa->scrn, NULL);
   if (exa->pipe == NULL)
      goto out_err;

d1065 1
a1065 3
   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   u_surface_default_template(&surf_tmpl, priv->tex,
                              PIPE_BIND_RENDER_TARGET);
d1074 1
a1074 1
   exa->pipe->flush(exa->pipe, fence);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a51 1
#define DEBUG_PRINT 0
d54 16
d213 1
a213 2
#if DEBUG_PRINT
    debug_printf("------ ExaDownloadFromScreen(%d, %d, %d, %d, %d)\n",
a214 1
#endif
d245 1
a245 2
#if DEBUG_PRINT
    debug_printf("++++++ ExaUploadToScreen(%d, %d, %d, %d, %d)\n",
a246 1
#endif
d275 2
d305 2
d326 2
d335 2
d351 2
a352 3
#if DEBUG_PRINT
    debug_printf("ExaPrepareSolid(0x%x)\n", fg);
#endif
d357 1
a357 1
	XORG_FALLBACK("accle not enabled");
d370 1
a370 1
                                        PIPE_BIND_RENDER_TARGET, 0)) {
d385 1
a385 3
#if DEBUG_PRINT
    debug_printf("\tExaSolid(%d, %d, %d, %d)\n", x0, y0, x1, y1);
#endif
d407 2
a408 1
   
d410 1
d427 1
a427 3
#if DEBUG_PRINT
    debug_printf("ExaPrepareCopy\n");
#endif
d433 1
a433 1
	XORG_FALLBACK("accle not enabled");
d449 1
a449 1
                                        PIPE_BIND_RENDER_TARGET, 0))
d454 1
a454 1
                                        PIPE_BIND_SAMPLER_VIEW, 0))
d507 1
a507 2
#if DEBUG_PRINT
   debug_printf("\tExaCopy(srcx=%d, srcy=%d, dstX=%d, dstY=%d, w=%d, h=%d)\n",
a508 1
#endif
d544 2
d552 2
d605 4
d610 1
a610 2
#if DEBUG_PRINT
   debug_printf("ExaCheckComposite(%d, %p, %p, %p) = %d\n",
a611 4
#endif

   if (!exa->accel)
       return FALSE;
d613 1
a613 4
   return xorg_composite_accelerated(op,
				     pSrcPicture,
				     pMaskPicture,
				     pDstPicture);
d630 1
a630 2
#if DEBUG_PRINT
   debug_printf("ExaPrepareComposite(%d, src=0x%p, mask=0x%p, dst=0x%p)\n",
d632 1
a632 1
   debug_printf("\tFormats: src(%s), mask(%s), dst(%s)\n",
d636 1
a636 1
#endif
d638 1
a638 1
      XORG_FALLBACK("accle not enabled");
d646 1
a646 1
                                       PIPE_BIND_RENDER_TARGET, 0))
d661 1
a661 1
                                          PIPE_BIND_SAMPLER_VIEW, 0))
d678 1
a678 1
                                          PIPE_BIND_SAMPLER_VIEW, 0))
d703 1
a703 2
#if DEBUG_PRINT
   debug_printf("\tExaComposite(src[%d,%d], mask=[%d, %d], dst=[%d, %d], dim=[%d, %d])\n",
d705 1
a705 1
   debug_printf("\t   Num bound samplers = %d\n",
a706 1
#endif
d1086 1
a1086 1
void xorg_exa_flush(struct exa_context *exa, uint pipeFlushFlags,
d1089 1
a1089 1
   exa->pipe->flush(exa->pipe, pipeFlushFlags, fence);
d1096 1
a1096 1
   xorg_exa_flush(exa, PIPE_FLUSH_RENDER_CACHE, &fence);
d1098 2
a1099 1
   exa->pipe->screen->fence_finish(exa->pipe->screen, fence, 0);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d49 2
d193 2
a194 6
    if (exa->pipe->is_texture_referenced(exa->pipe, priv->tex, 0, 0) &
	PIPE_REFERENCED_FOR_WRITE)
	exa->pipe->flush(exa->pipe, 0, NULL);

    transfer = exa->scrn->get_tex_transfer(exa->scrn, priv->tex, 0, 0, 0,
					   PIPE_TRANSFER_READ, x, y, w, h);
d204 1
a204 1
		   w, h, exa->scrn->transfer_map(exa->scrn, transfer),
d207 2
a208 2
    exa->scrn->transfer_unmap(exa->scrn, transfer);
    exa->scrn->tex_transfer_destroy(transfer);
d227 2
a228 7
    /* make sure that any pending operations are flushed to hardware */
    if (exa->pipe->is_texture_referenced(exa->pipe, priv->tex, 0, 0) &
	(PIPE_REFERENCED_FOR_READ | PIPE_REFERENCED_FOR_WRITE))
	xorg_exa_flush(exa, 0, NULL);

    transfer = exa->scrn->get_tex_transfer(exa->scrn, priv->tex, 0, 0, 0,
					   PIPE_TRANSFER_WRITE, x, y, w, h);
d237 1
a237 1
    util_copy_rect(exa->scrn->transfer_map(exa->scrn, transfer),
d241 2
a242 2
    exa->scrn->transfer_unmap(exa->scrn, transfer);
    exa->scrn->tex_transfer_destroy(transfer);
a265 4
	if (exa->pipe->is_texture_referenced(exa->pipe, priv->tex, 0, 0) &
	    PIPE_REFERENCED_FOR_WRITE)
	    exa->pipe->flush(exa->pipe, 0, NULL);

d270 1
a270 1
	    exa->scrn->get_tex_transfer(exa->scrn, priv->tex, 0, 0, 0,
d286 1
a286 1
	    exa->scrn->transfer_map(exa->scrn, priv->map_transfer);
d313 2
a314 2
	exa->scrn->transfer_unmap(exa->scrn, priv->map_transfer);
	exa->scrn->tex_transfer_destroy(priv->map_transfer);
d351 2
a352 2
                                        priv->tex->target,
                                        PIPE_TEXTURE_USAGE_RENDER_TARGET, 0)) {
d432 2
a433 2
                                        priv->tex->target,
                                        PIPE_TEXTURE_USAGE_RENDER_TARGET, 0))
d437 2
a438 2
                                        src_priv->tex->target,
                                        PIPE_TEXTURE_USAGE_SAMPLER, 0))
d444 5
a448 4
    /* For same-surface copies, the pipe->surface_copy path is clearly
     * superior, providing it is implemented.  In other cases it's not
     * clear what the better path would be, and eventually we'd
     * probably want to gather timings and choose dynamically.
d450 1
a450 3
    if (exa->pipe->surface_copy &&
        exa->copy.src == exa->copy.dst) {

a451 12
       
       exa->copy.src_surface =
          exa->scrn->get_tex_surface( exa->scrn,
                                      exa->copy.src->tex,
                                      0, 0, 0,
                                      PIPE_BUFFER_USAGE_GPU_READ);

       exa->copy.dst_surface =
          exa->scrn->get_tex_surface( exa->scrn, 
                                      exa->copy.dst->tex,
                                      0, 0, 0, 
                                      PIPE_BUFFER_USAGE_GPU_WRITE );
d454 1
d461 1
a461 1
          pipe_texture_reference(&exa->copy.src_texture,
d464 3
d468 3
a470 4
          exa->scrn->get_tex_surface(exa->scrn,
                                     exa->copy.dst->tex,
                                     0, 0, 0,
                                     PIPE_BUFFER_USAGE_GPU_WRITE);
d500 8
a507 8
      /* XXX: consider exposing >1 box in surface_copy interface.
       */
      exa->pipe->surface_copy( exa->pipe,
                             exa->copy.dst_surface,
                             dstX, dstY,
                             exa->copy.src_surface,
                             srcX, srcY,
                             width, height );
a533 1
   pipe_surface_reference(&exa->copy.src_surface, NULL);
d535 1
a535 1
   pipe_texture_reference(&exa->copy.src_texture, NULL);
d632 2
a633 2
                                       priv->tex->target,
                                       PIPE_TEXTURE_USAGE_RENDER_TARGET, 0))
d647 2
a648 2
                                          priv->tex->target,
                                          PIPE_TEXTURE_USAGE_SAMPLER, 0))
d664 2
a665 2
                                          priv->tex->target,
                                          PIPE_TEXTURE_USAGE_SAMPLER, 0))
d723 1
a723 1
    priv = xcalloc(1, sizeof(struct exa_pixmap_priv));
d738 1
a738 1
    pipe_texture_reference(&priv->tex, NULL);
d740 1
a740 1
    xfree(priv);
d770 1
a770 1
    priv->flags |= PIPE_TEXTURE_USAGE_PRIMARY;
d786 1
a786 1
    priv->flags |= PIPE_TEXTURE_USAGE_DISPLAY_TARGET;
d861 2
a862 2
	struct pipe_texture *texture = NULL;
	struct pipe_texture template;
d877 1
d879 1
a879 1
	template.tex_usage = PIPE_TEXTURE_USAGE_RENDER_TARGET | priv->flags;
d881 1
a881 1
	texture = exa->scrn->texture_create(exa->scrn, &template);
d884 8
a891 17
	    struct pipe_surface *dst_surf;
	    struct pipe_surface *src_surf;

	    dst_surf = exa->scrn->get_tex_surface(
		exa->scrn, texture, 0, 0, 0, PIPE_BUFFER_USAGE_GPU_WRITE);
	    src_surf = xorg_gpu_surface(exa->pipe->screen, priv);
            if (exa->pipe->surface_copy) {
               exa->pipe->surface_copy(exa->pipe, dst_surf, 0, 0, src_surf,
                                       0, 0, min(width, texture->width0),
                                       min(height, texture->height0));
            } else {
               util_surface_copy(exa->pipe, FALSE, dst_surf, 0, 0, src_surf,
                                 0, 0, min(width, texture->width0),
                                 min(height, texture->height0));
            }
	    exa->scrn->tex_surface_destroy(dst_surf);
	    exa->scrn->tex_surface_destroy(src_surf);
d894 1
a894 1
	pipe_texture_reference(&priv->tex, texture);
d896 1
a896 1
	pipe_texture_reference(&texture, NULL);
d902 1
a902 1
struct pipe_texture *
d906 2
a907 2
   struct pipe_texture *tex = NULL;
   pipe_texture_reference(&tex, priv->tex);
d912 1
a912 1
xorg_exa_set_texture(PixmapPtr pPixmap, struct  pipe_texture *tex)
d916 1
a916 1
    int mask = PIPE_TEXTURE_USAGE_PRIMARY | PIPE_TEXTURE_USAGE_DISPLAY_TARGET;
d925 2
a926 2
    pipe_texture_reference(&priv->tex, tex);
    priv->tex_flags = tex->tex_usage & mask;
d931 1
a931 1
struct pipe_texture *
d938 1
a938 1
    struct pipe_texture template;
d947 1
d949 3
a951 3
    template.tex_usage |= PIPE_TEXTURE_USAGE_RENDER_TARGET;
    template.tex_usage |= PIPE_TEXTURE_USAGE_PRIMARY;
    template.tex_usage |= PIPE_TEXTURE_USAGE_DISPLAY_TARGET;
d953 1
a953 1
    return exa->scrn->texture_create(exa->scrn, &template);
d962 3
d967 2
d976 1
a976 1
   xfree(exa);
d986 1
d988 1
a988 1
   exa = xcalloc(1, sizeof(struct exa_context));
d1048 2
d1058 1
d1064 1
a1064 1
xorg_gpu_surface(struct pipe_screen *scrn, struct exa_pixmap_priv *priv)
d1066 6
a1071 3
   return scrn->get_tex_surface(scrn, priv->tex, 0, 0, 0,
                                PIPE_BUFFER_USAGE_GPU_READ |
                                PIPE_BUFFER_USAGE_GPU_WRITE);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a48 2
#include "util/u_box.h"
#include "util/u_surface.h"
d191 6
a196 2
    transfer = pipe_get_transfer(exa->pipe, priv->tex, 0, 0,
                                 PIPE_TRANSFER_READ, x, y, w, h);
d206 1
a206 1
		   w, h, exa->pipe->transfer_map(exa->pipe, transfer),
d209 2
a210 2
    exa->pipe->transfer_unmap(exa->pipe, transfer);
    exa->pipe->transfer_destroy(exa->pipe, transfer);
d229 7
a235 2
    transfer = pipe_get_transfer(exa->pipe, priv->tex, 0, 0,
                                 PIPE_TRANSFER_WRITE, x, y, w, h);
d244 1
a244 1
    util_copy_rect(exa->pipe->transfer_map(exa->pipe, transfer),
d248 2
a249 2
    exa->pipe->transfer_unmap(exa->pipe, transfer);
    exa->pipe->transfer_destroy(exa->pipe, transfer);
d273 4
d281 1
a281 1
	   pipe_get_transfer(exa->pipe, priv->tex, 0, 0,
d297 1
a297 1
	    exa->pipe->transfer_map(exa->pipe, priv->map_transfer);
d324 2
a325 2
	exa->pipe->transfer_unmap(exa->pipe, priv->map_transfer);
	exa->pipe->transfer_destroy(exa->pipe, priv->map_transfer);
d362 2
a363 2
                                        priv->tex->target, 0,
                                        PIPE_BIND_RENDER_TARGET, 0)) {
d443 2
a444 2
                                        priv->tex->target, 0,
                                        PIPE_BIND_RENDER_TARGET, 0))
d448 2
a449 2
                                        src_priv->tex->target, 0,
                                        PIPE_BIND_SAMPLER_VIEW, 0))
d455 4
a458 5
    /* XXX this used to use resource_copy_region for same-surface copies,
     * but they were redefined to not allow overlaps (some of the util code
     * always assumed this anyway).
     * Drivers should implement accelerated resource_copy_region or it will
     * be slow - disable for now.
d460 3
a462 1
    if (0 && exa->copy.src != exa->copy.dst) {
d464 12
a477 1
       struct pipe_surface surf_tmpl;
d484 1
a484 1
          pipe_resource_reference(&exa->copy.src_texture,
a486 3
       memset(&surf_tmpl, 0, sizeof(surf_tmpl));
       u_surface_default_template(&surf_tmpl, exa->copy.dst->tex,
                                  PIPE_BIND_RENDER_TARGET);
d488 4
a491 3
          exa->pipe->create_surface(exa->pipe,
                                    exa->copy.dst->tex,
                                    &surf_tmpl);
d521 8
a528 8
      struct pipe_box src_box;
      u_box_2d(srcX, srcY, width, height, &src_box);
      exa->pipe->resource_copy_region( exa->pipe,
                                       exa->copy.dst->tex,
                                       0,
                                       dstX, dstY, 0,
                                       exa->copy.src->tex,
                                       0, &src_box);
d555 1
d557 1
a557 1
   pipe_resource_reference(&exa->copy.src_texture, NULL);
d654 2
a655 2
                                       priv->tex->target, 0,
                                       PIPE_BIND_RENDER_TARGET, 0))
d669 2
a670 2
                                          priv->tex->target, 0,
                                          PIPE_BIND_SAMPLER_VIEW, 0))
d686 2
a687 2
                                          priv->tex->target, 0,
                                          PIPE_BIND_SAMPLER_VIEW, 0))
d745 1
a745 1
    priv = calloc(1, sizeof(struct exa_pixmap_priv));
d760 1
a760 1
    pipe_resource_reference(&priv->tex, NULL);
d762 1
a762 1
    free(priv);
d792 1
a792 1
    priv->flags |= PIPE_BIND_SCANOUT;
d808 1
a808 1
    priv->flags |= PIPE_BIND_SHARED;
d883 2
a884 2
	struct pipe_resource *texture = NULL;
	struct pipe_resource template;
a898 1
	template.array_size = 1;
d900 1
a900 1
	template.bind = PIPE_BIND_RENDER_TARGET | priv->flags;
d902 1
a902 1
	texture = exa->scrn->resource_create(exa->scrn, &template);
d905 17
a921 8
            struct pipe_box src_box;
            u_box_origin_2d(min(width, texture->width0),
                            min(height, texture->height0),
                            &src_box);
            exa->pipe->resource_copy_region(exa->pipe, texture,
                                            0, 0, 0, 0,
                                            priv->tex,
                                            0, &src_box);
d924 1
a924 1
	pipe_resource_reference(&priv->tex, texture);
d926 1
a926 1
	pipe_resource_reference(&texture, NULL);
d932 1
a932 1
struct pipe_resource *
d936 2
a937 2
   struct pipe_resource *tex = NULL;
   pipe_resource_reference(&tex, priv->tex);
d942 1
a942 1
xorg_exa_set_texture(PixmapPtr pPixmap, struct  pipe_resource *tex)
d946 1
a946 1
    int mask = PIPE_BIND_SHARED | PIPE_BIND_SCANOUT;
d955 2
a956 2
    pipe_resource_reference(&priv->tex, tex);
    priv->tex_flags = tex->bind & mask;
d961 1
a961 1
struct pipe_resource *
d968 1
a968 1
    struct pipe_resource template;
a976 1
    template.array_size = 1;
d978 3
a980 3
    template.bind |= PIPE_BIND_RENDER_TARGET;
    template.bind |= PIPE_BIND_SCANOUT;
    template.bind |= PIPE_BIND_SHARED;
d982 1
a982 1
    return exa->scrn->resource_create(exa->scrn, &template);
a990 3
   pipe_sampler_view_reference(&exa->bound_sampler_views[0], NULL);
   pipe_sampler_view_reference(&exa->bound_sampler_views[1], NULL);

a992 2
   xorg_exa_finish(exa);

d1000 1
a1000 1
   free(exa);
a1009 1
   CustomizerPtr cust = ms->cust;
d1011 1
a1011 1
   exa = calloc(1, sizeof(struct exa_context));
a1070 2
   if (cust && cust->winsys_context_throttle)
       cust->winsys_context_throttle(cust, ms->ctx, THROTTLE_RENDER);
a1078 1
   free(exa);
d1084 1
a1084 1
xorg_gpu_surface(struct pipe_context *pipe, struct exa_pixmap_priv *priv)
d1086 3
a1088 6
   struct pipe_surface surf_tmpl;
   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   u_surface_default_template(&surf_tmpl, priv->tex,
                              PIPE_BIND_RENDER_TARGET);

   return pipe->create_surface(pipe, priv->tex, &surf_tmpl);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d52 1
a54 16
static INLINE void
exa_debug_printf(const char *format, ...) _util_printf_format(1,2);

static INLINE void
exa_debug_printf(const char *format, ...)
{
#if 0
   va_list ap;
   va_start(ap, format);
   _debug_vprintf(format, ap);
   va_end(ap);
#else
   (void) format; /* silence warning */
#endif
}

d184 1
a184 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
a188 1
    void *map;
d193 3
a195 3
    map = pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
                            PIPE_TRANSFER_READ, x, y, w, h, &transfer);
    if (!map)
d198 2
a199 1
    exa_debug_printf("------ ExaDownloadFromScreen(%d, %d, %d, %d, %d)\n",
d201 1
d204 2
a205 1
		   w, h, map, transfer->stride, 0, 0);
d208 1
d218 1
a218 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
a222 1
    void *map;
d227 3
a229 3
    map = pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
                            PIPE_TRANSFER_WRITE, x, y, w, h, &transfer);
    if (!map)
d232 2
a233 1
    exa_debug_printf("++++++ ExaUploadToScreen(%d, %d, %d, %d, %d)\n",
d235 1
d237 1
a237 1
    util_copy_rect(map,
d242 1
d251 1
a251 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
a263 2
    exa_debug_printf("ExaPrepareAccess %d\n", index);

d269 2
a270 2
	pPix->devPrivate.ptr =
	   pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
d272 1
a272 1
                             PIPE_TRANSFER_MAP_DIRECTLY |
d274 5
a278 6
                             PIPE_TRANSFER_READ_WRITE,
                             0, 0,
                             pPix->drawable.width,
                             pPix->drawable.height,
                             &priv->map_transfer);
        if (!pPix->devPrivate.ptr)
d285 2
a291 2
    exa_debug_printf("ExaPrepareAccess %d prepared\n", index);

d299 1
a299 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
a310 2
    exa_debug_printf("ExaFinishAccess %d\n", index);

d314 1
a317 2

    exa_debug_printf("ExaFinishAccess %d finished\n", index);
d327 1
a327 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
d332 3
a334 2
    exa_debug_printf("ExaPrepareSolid(0x%x)\n", fg);

d339 1
a339 1
	XORG_FALLBACK("accel not enabled");
d352 1
a352 1
                                        PIPE_BIND_RENDER_TARGET)) {
d362 1
a362 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
d367 3
a369 1
    exa_debug_printf("\tExaSolid(%d, %d, %d, %d)\n", x0, y0, x1, y1);
d373 1
a373 6
       union pipe_color_union solid_color;
       solid_color.f[0] = exa->solid_color[0];
       solid_color.f[1] = exa->solid_color[1];
       solid_color.f[2] = exa->solid_color[2];
       solid_color.f[3] = exa->solid_color[3];
       exa->pipe->clear(exa->pipe, PIPE_CLEAR_COLOR, &solid_color, 0.0, 0);
d384 1
a384 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
d391 1
a391 2

    exa_debug_printf("ExaDoneSolid\n");
a392 1
    exa_debug_printf("ExaDoneSolid done\n");
d403 1
a403 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPixmap->drawable.pScreen);
d409 3
a411 1
    exa_debug_printf("ExaPrepareCopy\n");
d417 1
a417 1
	XORG_FALLBACK("accel not enabled");
d433 1
a433 1
                                        PIPE_BIND_RENDER_TARGET))
d438 1
a438 1
                                        PIPE_BIND_SAMPLER_VIEW))
d444 35
d486 1
a486 1
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPixmap->drawable.pScreen);
d489 1
a489 1
   struct pipe_box src_box;
d491 2
a492 1
   exa_debug_printf("\tExaCopy(srcx=%d, srcy=%d, dstX=%d, dstY=%d, w=%d, h=%d)\n",
d494 1
d496 2
a497 3
   debug_assert(exaGetPixmapDriverPrivate(pDstPixmap) == exa->copy.dst);

   u_box_2d(srcX, srcY, width, height, &src_box);
d499 3
a501 32
   /* If source and destination overlap, we have to copy to/from a scratch
    * pixmap.
    */
   if (exa->copy.dst == exa->copy.src &&
       !((dstX + width) < srcX || dstX > (srcX + width) ||
	 (dstY + height) < srcY || dstY > (srcY + height))) {
      struct exa_pixmap_priv *tmp_priv;

      if (!exa->copy.tmp_pix) {
         exa->copy.tmp_pix = pScrn->pScreen->CreatePixmap(pScrn->pScreen,
                                                         pDstPixmap->drawable.width,
                                                         pDstPixmap->drawable.height,
                                                         pDstPixmap->drawable.depth,
                                                         pDstPixmap->drawable.width);
         exaMoveInPixmap(exa->copy.tmp_pix);
      }

      tmp_priv = exaGetPixmapDriverPrivate(exa->copy.tmp_pix);

      exa->pipe->resource_copy_region( exa->pipe,
                                       tmp_priv->tex,
                                       0,
                                       srcX, srcY, 0,
                                       exa->copy.src->tex,
                                       0, &src_box);
      exa->pipe->resource_copy_region( exa->pipe,
                                       exa->copy.dst->tex,
                                       0,
                                       dstX, dstY, 0,
                                       tmp_priv->tex,
                                       0, &src_box);
   } else
d508 9
d522 1
a522 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
d530 1
a530 1
   exa_debug_printf("ExaDoneCopy\n");
a531 4
   if (exa->copy.tmp_pix) {
      pScrn->pScreen->DestroyPixmap(exa->copy.tmp_pix);
      exa->copy.tmp_pix = NULL;
   }
d534 2
a535 2

   exa_debug_printf("ExaDoneCopy done\n");
d584 1
a584 1
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPicture->pDrawable->pScreen);
d587 10
a596 1
   Bool accelerated = exa->accel && xorg_composite_accelerated(op,
a599 5

   exa_debug_printf("ExaCheckComposite(%d, %p, %p, %p) = %d\n",
                op, pSrcPicture, pMaskPicture, pDstPicture, accelerated);

   return accelerated;
d608 1
a608 1
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDst->drawable.pScreen);
d616 2
a617 1
   exa_debug_printf("ExaPrepareComposite(%d, src=0x%p, mask=0x%p, dst=0x%p)\n",
d619 1
a619 1
   exa_debug_printf("\tFormats: src(%s), mask(%s), dst(%s)\n",
d623 1
a623 1

d625 1
a625 1
      XORG_FALLBACK("accel not enabled");
d633 1
a633 1
                                       PIPE_BIND_RENDER_TARGET))
d648 1
a648 1
                                          PIPE_BIND_SAMPLER_VIEW))
d665 1
a665 1
                                          PIPE_BIND_SAMPLER_VIEW))
d685 1
a685 1
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDst->drawable.pScreen);
d690 2
a691 1
   exa_debug_printf("\tExaComposite(src[%d,%d], mask=[%d, %d], dst=[%d, %d], dim=[%d, %d])\n",
d693 1
a693 1
   exa_debug_printf("\t   Num bound samplers = %d\n",
d695 1
d706 1
a706 1
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
d815 1
a815 1
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
a991 5
   exa->scrn = ms->screen;
   exa->pipe = exa->scrn->context_create(exa->scrn, NULL);
   if (exa->pipe == NULL)
      goto out_err;

d997 2
d1013 2
a1014 3

   pExa->maxX = pExa->maxY =
   1 << (exa->scrn->get_param(exa->scrn, PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
d1041 5
d1067 3
a1069 1
   u_surface_default_template(&surf_tmpl, priv->tex);
d1075 1
a1075 1
void xorg_exa_flush(struct exa_context *exa,
d1078 1
a1078 1
   exa->pipe->flush(exa->pipe, fence, 0);
d1085 1
a1085 1
   xorg_exa_flush(exa, &fence);
d1087 1
a1087 2
   exa->pipe->screen->fence_finish(exa->pipe->screen, fence,
                                   PIPE_TIMEOUT_INFINITE);
@


