head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.07.09.21.08.56;	author jsg;	state dead;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.01.54;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.31;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 * Author: Alan Hourihane <alanh@@tungstengraphics.com>
 * Author: Jakob Bornecrantz <wallbraker@@gmail.com>
 *
 */

#include "xorg-server.h"
#include <xf86.h>
#include <xf86i2c.h>
#include <xf86Crtc.h>
#include <xf86DDC.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#ifdef HAVE_XEXTPROTO_71
#include <X11/extensions/dpmsconst.h>
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif

#include "xorg_tracker.h"

struct output_private
{
    drmModeConnectorPtr drm_connector;
    drmModePropertyBlobPtr edid_blob;
    int fd;
    int c;
};

static char *output_enum_list[] = {
    "Unknown",
    "VGA",
    "DVI",
    "DVI",
    "DVI",
    "Composite",
    "SVIDEO",
    "LVDS",
    "CTV",
    "DIN",
    "DP",
    "HDMI",
    "HDMI",
};

static void
output_create_resources(xf86OutputPtr output)
{
#ifdef RANDR_12_INTERFACE
#endif /* RANDR_12_INTERFACE */
}

static void
output_dpms(xf86OutputPtr output, int mode)
{
}

static xf86OutputStatus
output_detect(xf86OutputPtr output)
{
    modesettingPtr ms = modesettingPTR(output->scrn);
    struct output_private *priv = output->driver_private;
    drmModeConnectorPtr drm_connector;
    xf86OutputStatus status;

    drm_connector = drmModeGetConnector(ms->fd, priv->drm_connector->connector_id);
    if (drm_connector) {
	drmModeFreeConnector(priv->drm_connector);
	priv->drm_connector = drm_connector;
    } else {
	drm_connector = priv->drm_connector;
    }

    switch (drm_connector->connection) {
    case DRM_MODE_CONNECTED:
	status = XF86OutputStatusConnected;
	break;
    case DRM_MODE_DISCONNECTED:
	status = XF86OutputStatusDisconnected;
	break;
    default:
	status = XF86OutputStatusUnknown;
    }

    return status;
}

static DisplayModePtr
output_get_modes(xf86OutputPtr output)
{
    struct output_private *priv = output->driver_private;
    drmModeConnectorPtr drm_connector = priv->drm_connector;
    drmModeModeInfoPtr drm_mode = NULL;
    drmModePropertyPtr props = NULL;
    xf86MonPtr ddc_mon = NULL;
    DisplayModePtr modes = NULL, mode = NULL;
    int i;

	for (i = 0; i < drm_connector->count_props; i++) {
		props = drmModeGetProperty(priv->fd, drm_connector->props[i]);
		if (!props)
			continue;

		if (!(props->flags & DRM_MODE_PROP_BLOB))
			goto out_free;

		if (!strcmp(props->name, "EDID")) {
			if (priv->edid_blob)
				drmModeFreePropertyBlob(priv->edid_blob);
			priv->edid_blob = drmModeGetPropertyBlob(priv->fd,
							  drm_connector->prop_values[i]);
		}

		out_free:
		drmModeFreeProperty(props);
	}

	if (priv->edid_blob) {
		ddc_mon = xf86InterpretEDID(output->scrn->scrnIndex,
									priv->edid_blob->data);

		if (ddc_mon && priv->edid_blob->length > 128)
			ddc_mon->flags |= MONITOR_EDID_COMPLETE_RAWDATA;
	}
	xf86OutputSetEDID(output, ddc_mon);

    for (i = 0; i < drm_connector->count_modes; i++) {
	drm_mode = &drm_connector->modes[i];
	if (drm_mode) {
	    mode = calloc(1, sizeof(DisplayModeRec));
	    if (!mode)
		continue;
	    mode->Clock = drm_mode->clock;
	    mode->HDisplay = drm_mode->hdisplay;
	    mode->HSyncStart = drm_mode->hsync_start;
	    mode->HSyncEnd = drm_mode->hsync_end;
	    mode->HTotal = drm_mode->htotal;
	    mode->VDisplay = drm_mode->vdisplay;
	    mode->VSyncStart = drm_mode->vsync_start;
	    mode->VSyncEnd = drm_mode->vsync_end;
	    mode->VTotal = drm_mode->vtotal;
	    mode->Flags = drm_mode->flags;
	    mode->HSkew = drm_mode->hskew;
	    mode->VScan = drm_mode->vscan;
	    mode->VRefresh = xf86ModeVRefresh(mode);
	    mode->Private = (void *)drm_mode;
	    mode->type = 0;
	    if (drm_mode->type & DRM_MODE_TYPE_PREFERRED)
		mode->type |= M_T_PREFERRED;
	    if (drm_mode->type & DRM_MODE_TYPE_DRIVER)
		mode->type |= M_T_DRIVER;
	    xf86SetModeDefaultName(mode);
	    modes = xf86ModesAdd(modes, mode);
	    xf86PrintModeline(0, mode);
	}
    }

    return modes;
}

static int
output_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
{
    modesettingPtr ms = modesettingPTR(output->scrn);
    CustomizerPtr cust = ms->cust;

    if (cust && cust->winsys_check_fb_size &&
	!cust->winsys_check_fb_size(cust, pMode->HDisplay *
				    output->scrn->bitsPerPixel / 8,
				    pMode->VDisplay))
	return MODE_BAD;

    return MODE_OK;
}

#ifdef RANDR_12_INTERFACE
static Bool
output_set_property(xf86OutputPtr output, Atom property, RRPropertyValuePtr value)
{
    return TRUE;
}
#endif /* RANDR_12_INTERFACE */

#ifdef RANDR_13_INTERFACE
static Bool
output_get_property(xf86OutputPtr output, Atom property)
{
    return TRUE;
}
#endif /* RANDR_13_INTERFACE */

static void
output_destroy(xf86OutputPtr output)
{
    struct output_private *priv = output->driver_private;
    if (priv->edid_blob)
		drmModeFreePropertyBlob(priv->edid_blob);
    drmModeFreeConnector(priv->drm_connector);
    free(priv);
    output->driver_private = NULL;
}

static const xf86OutputFuncsRec output_funcs = {
    .create_resources = output_create_resources,
#ifdef RANDR_12_INTERFACE
    .set_property = output_set_property,
#endif
#ifdef RANDR_13_INTERFACE
    .get_property = output_get_property,
#endif
    .dpms = output_dpms,
    .detect = output_detect,

    .get_modes = output_get_modes,
    .mode_valid = output_mode_valid,
    .destroy = output_destroy,
};

void
xorg_output_init(ScrnInfoPtr pScrn)
{
    modesettingPtr ms = modesettingPTR(pScrn);
    xf86OutputPtr output;
    drmModeResPtr res;
    drmModeConnectorPtr drm_connector = NULL;
    drmModeEncoderPtr drm_encoder = NULL;
    struct output_private *priv;
    char name[32];
    int c, v, p;

    res = drmModeGetResources(ms->fd);
    if (res == 0) {
	DRV_ERROR("Failed drmModeGetResources\n");
	return;
    }

    for (c = 0; c < res->count_connectors; c++) {
	drm_connector = drmModeGetConnector(ms->fd, res->connectors[c]);
	if (!drm_connector)
	    goto out;

#if 0
	for (p = 0; p < drm_connector->count_props; p++) {
	    drmModePropertyPtr prop;

	    prop = drmModeGetProperty(ms->fd, drm_connector->props[p]);

	    name = NULL;
	    if (prop) {
		ErrorF("VALUES %d\n", prop->count_values);

		for (v = 0; v < prop->count_values; v++)
		    ErrorF("%s %lld\n", prop->name, prop->values[v]);
	    }
	}
#else
	(void)p;
	(void)v;
#endif

	snprintf(name, 32, "%s%d",
		 output_enum_list[drm_connector->connector_type],
		 drm_connector->connector_type_id);


	priv = calloc(sizeof(*priv), 1);
	if (!priv) {
	    continue;
	}

	output = xf86OutputCreate(pScrn, &output_funcs, name);
	if (!output) {
	    free(priv);
	    continue;
	}

	drm_encoder = drmModeGetEncoder(ms->fd, drm_connector->encoders[0]);
	if (drm_encoder) {
	    output->possible_crtcs = drm_encoder->possible_crtcs;
	    output->possible_clones = drm_encoder->possible_clones;
	} else {
	    output->possible_crtcs = 0;
	    output->possible_clones = 0;
	}
	priv->c = c;
	priv->drm_connector = drm_connector;
	priv->fd = ms->fd;
	output->driver_private = priv;
	output->subpixel_order = SubPixelHorizontalRGB;
	output->interlaceAllowed = FALSE;
	output->doubleScanAllowed = FALSE;
    }

  out:
    drmModeFreeResources(res);
}

unsigned
xorg_output_get_id(xf86OutputPtr output)
{
    struct output_private *priv = output->driver_private;
    return priv->drm_connector->connector_id;
}

/* vim: set sw=4 ts=8 sts=4: */
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@d35 1
d58 2
a59 1

d127 2
d132 28
d229 2
d320 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d54 7
d92 12
a103 1
    drmModeConnectorPtr drm_connector = output->driver_private;
d107 2
a108 1
	return XF86OutputStatusConnected;
d110 2
a111 1
	return XF86OutputStatusDisconnected;
d113 1
a113 1
	return XF86OutputStatusUnknown;
d115 2
d122 2
a123 1
    drmModeConnectorPtr drm_connector = output->driver_private;
d131 1
a131 1
	    mode = xcalloc(1, sizeof(DisplayModeRec));
d165 9
d196 4
a199 1
    drmModeFreeConnector(output->driver_private);
d226 1
d265 5
d271 2
a272 1
	if (!output)
d274 1
d284 3
a286 1
	output->driver_private = drm_connector;
d294 7
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a53 7
struct output_private
{
    drmModeConnectorPtr drm_connector;

    int c;
};

d85 1
a85 12
    modesettingPtr ms = modesettingPTR(output->scrn);
    struct output_private *priv = output->driver_private;
    drmModeConnectorPtr drm_connector;
    xf86OutputStatus status;

    drm_connector = drmModeGetConnector(ms->fd, priv->drm_connector->connector_id);
    if (drm_connector) {
	drmModeFreeConnector(priv->drm_connector);
	priv->drm_connector = drm_connector;
    } else {
	drm_connector = priv->drm_connector;
    }
d89 1
a89 2
	status = XF86OutputStatusConnected;
	break;
d91 1
a91 2
	status = XF86OutputStatusDisconnected;
	break;
d93 1
a93 1
	status = XF86OutputStatusUnknown;
a94 2

    return status;
d100 1
a100 2
    struct output_private *priv = output->driver_private;
    drmModeConnectorPtr drm_connector = priv->drm_connector;
d108 1
a108 1
	    mode = calloc(1, sizeof(DisplayModeRec));
a141 9
    modesettingPtr ms = modesettingPTR(output->scrn);
    CustomizerPtr cust = ms->cust;

    if (cust && cust->winsys_check_fb_size &&
	!cust->winsys_check_fb_size(cust, pMode->HDisplay *
				    output->scrn->bitsPerPixel / 8,
				    pMode->VDisplay))
	return MODE_BAD;

d164 1
a164 4
    struct output_private *priv = output->driver_private;
    drmModeFreeConnector(priv->drm_connector);
    free(priv);
    output->driver_private = NULL;
a190 1
    struct output_private *priv;
a228 5
	priv = calloc(sizeof(*priv), 1);
	if (!priv) {
	    continue;
	}

d230 1
a230 2
	if (!output) {
	    free(priv);
a231 1
	}
d241 1
a241 3
	priv->c = c;
	priv->drm_connector = drm_connector;
	output->driver_private = priv;
a248 7
}

unsigned
xorg_output_get_id(xf86OutputPtr output)
{
    struct output_private *priv = output->driver_private;
    return priv->drm_connector->connector_id;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a34 1
#include <xf86DDC.h>
d57 1
a57 2
    drmModePropertyBlobPtr edid_blob;
    int fd;
a124 2
    drmModePropertyPtr props = NULL;
    xf86MonPtr ddc_mon = NULL;
a127 28
	for (i = 0; i < drm_connector->count_props; i++) {
		props = drmModeGetProperty(priv->fd, drm_connector->props[i]);
		if (!props)
			continue;

		if (!(props->flags & DRM_MODE_PROP_BLOB))
			goto out_free;

		if (!strcmp(props->name, "EDID")) {
			if (priv->edid_blob)
				drmModeFreePropertyBlob(priv->edid_blob);
			priv->edid_blob = drmModeGetPropertyBlob(priv->fd,
							  drm_connector->prop_values[i]);
		}

		out_free:
		drmModeFreeProperty(props);
	}

	if (priv->edid_blob) {
		ddc_mon = xf86InterpretEDID(output->scrn->scrnIndex,
									priv->edid_blob->data);

		if (ddc_mon && priv->edid_blob->length > 128)
			ddc_mon->flags |= MONITOR_EDID_COMPLETE_RAWDATA;
	}
	xf86OutputSetEDID(output, ddc_mon);

a196 2
    if (priv->edid_blob)
		drmModeFreePropertyBlob(priv->edid_blob);
a285 1
	priv->fd = ms->fd;
@


