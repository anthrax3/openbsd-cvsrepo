head	1.4;
access;
symbols
	v10_4_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.02.20.23.09.53;	author jsg;	state dead;
branches;
next	1.3;
commitid	4ry2gvZGMXkCUD2n;

1.3
date	2015.01.25.14.41.17;	author jsg;	state Exp;
branches;
next	1.2;
commitid	mcxB0JvoI9gTDYXU;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2015.01.25.14.09.12;	author jsg;	state Exp;
branches;
next	;
commitid	ce2W5rH5aF7VS9gi;


desc
@@


1.4
log
@Merge Mesa 10.2.9
@
text
@/**************************************************************************
 *
 * Copyright 2009, VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/
/*
 * Author: Keith Whitwell <keithw@@vmware.com>
 * Author: Jakob Bornecrantz <wallbraker@@gmail.com>
 */

#include "dri_screen.h"
#include "dri_context.h"
#include "dri_drawable.h"

#include "pipe/p_screen.h"
#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"

static void
swap_fences_unref(struct dri_drawable *draw);

static boolean
dri_st_framebuffer_validate(struct st_context_iface *stctx,
                            struct st_framebuffer_iface *stfbi,
                            const enum st_attachment_type *statts,
                            unsigned count,
                            struct pipe_resource **out)
{
   struct dri_context *ctx = (struct dri_context *)stctx->st_manager_private;
   struct dri_drawable *drawable =
      (struct dri_drawable *) stfbi->st_manager_private;
   struct dri_screen *screen = dri_screen(drawable->sPriv);
   unsigned statt_mask, new_mask;
   boolean new_stamp;
   int i;
   unsigned int lastStamp;
   struct pipe_resource **textures =
      drawable->stvis.samples > 1 ? drawable->msaa_textures
                                  : drawable->textures;

   statt_mask = 0x0;
   for (i = 0; i < count; i++)
      statt_mask |= (1 << statts[i]);

   /* record newly allocated textures */
   new_mask = (statt_mask & ~drawable->texture_mask);

   /*
    * dPriv->dri2.stamp is the server stamp.  dPriv->lastStamp is the
    * client stamp.  It has the value of the server stamp when last
    * checked.
    */
   do {
      lastStamp = drawable->dPriv->lastStamp;
      new_stamp = (drawable->texture_stamp != lastStamp);

      if (new_stamp || new_mask || screen->broken_invalidate) {
         if (new_stamp && drawable->update_drawable_info)
            drawable->update_drawable_info(drawable);

         drawable->allocate_textures(ctx, drawable, statts, count);

         /* add existing textures */
         for (i = 0; i < ST_ATTACHMENT_COUNT; i++) {
            if (textures[i])
               statt_mask |= (1 << i);
         }

         drawable->texture_stamp = lastStamp;
         drawable->texture_mask = statt_mask;
      }
   } while (lastStamp != drawable->dPriv->lastStamp);

   if (!out)
      return TRUE;

   /* Set the window-system buffers for the state tracker. */
   for (i = 0; i < count; i++) {
      out[i] = NULL;
      pipe_resource_reference(&out[i], textures[statts[i]]);
   }

   return TRUE;
}

static boolean
dri_st_framebuffer_flush_front(struct st_context_iface *stctx,
                               struct st_framebuffer_iface *stfbi,
                               enum st_attachment_type statt)
{
   struct dri_context *ctx = (struct dri_context *)stctx->st_manager_private;
   struct dri_drawable *drawable =
      (struct dri_drawable *) stfbi->st_manager_private;

   /* XXX remove this and just set the correct one on the framebuffer */
   drawable->flush_frontbuffer(ctx, drawable, statt);

   return TRUE;
}

/**
 * This is called when we need to set up GL rendering to a new X window.
 */
boolean
dri_create_buffer(__DRIscreen * sPriv,
		  __DRIdrawable * dPriv,
		  const struct gl_config * visual, boolean isPixmap)
{
   struct dri_screen *screen = sPriv->driverPrivate;
   struct dri_drawable *drawable = NULL;

   if (isPixmap)
      goto fail;		       /* not implemented */

   drawable = CALLOC_STRUCT(dri_drawable);
   if (drawable == NULL)
      goto fail;

   dri_fill_st_visual(&drawable->stvis, screen, visual);

   /* setup the st_framebuffer_iface */
   drawable->base.visual = &drawable->stvis;
   drawable->base.flush_front = dri_st_framebuffer_flush_front;
   drawable->base.validate = dri_st_framebuffer_validate;
   drawable->base.st_manager_private = (void *) drawable;

   drawable->screen = screen;
   drawable->sPriv = sPriv;
   drawable->dPriv = dPriv;
   drawable->desired_fences = screen->default_throttle_frames;
   if (drawable->desired_fences > DRI_SWAP_FENCES_MAX)
      drawable->desired_fences = DRI_SWAP_FENCES_MAX;

   dPriv->driverPrivate = (void *)drawable;
   p_atomic_set(&drawable->base.stamp, 1);

   return GL_TRUE;
fail:
   FREE(drawable);
   return GL_FALSE;
}

void
dri_destroy_buffer(__DRIdrawable * dPriv)
{
   struct dri_drawable *drawable = dri_drawable(dPriv);
   int i;

   pipe_surface_reference(&drawable->drisw_surface, NULL);

   for (i = 0; i < ST_ATTACHMENT_COUNT; i++)
      pipe_resource_reference(&drawable->textures[i], NULL);
   for (i = 0; i < ST_ATTACHMENT_COUNT; i++)
      pipe_resource_reference(&drawable->msaa_textures[i], NULL);

   swap_fences_unref(drawable);

   FREE(drawable);
}

/**
 * Validate the texture at an attachment.  Allocate the texture if it does not
 * exist.  Used by the TFP extension.
 */
static void
dri_drawable_validate_att(struct dri_context *ctx,
                          struct dri_drawable *drawable,
                          enum st_attachment_type statt)
{
   enum st_attachment_type statts[ST_ATTACHMENT_COUNT];
   unsigned i, count = 0;

   /* check if buffer already exists */
   if (drawable->texture_mask & (1 << statt))
      return;

   /* make sure DRI2 does not destroy existing buffers */
   for (i = 0; i < ST_ATTACHMENT_COUNT; i++) {
      if (drawable->texture_mask & (1 << i)) {
         statts[count++] = i;
      }
   }
   statts[count++] = statt;

   drawable->texture_stamp = drawable->dPriv->lastStamp - 1;

   drawable->base.validate(ctx->st, &drawable->base, statts, count, NULL);
}

/**
 * These are used for GLX_EXT_texture_from_pixmap
 */
static void
dri_set_tex_buffer2(__DRIcontext *pDRICtx, GLint target,
                    GLint format, __DRIdrawable *dPriv)
{
   struct dri_context *ctx = dri_context(pDRICtx);
   struct dri_drawable *drawable = dri_drawable(dPriv);
   struct pipe_resource *pt;

   dri_drawable_validate_att(ctx, drawable, ST_ATTACHMENT_FRONT_LEFT);

   /* Use the pipe resource associated with the X drawable */
   pt = drawable->textures[ST_ATTACHMENT_FRONT_LEFT];

   if (pt) {
      enum pipe_format internal_format = pt->format;

      if (format == __DRI_TEXTURE_FORMAT_RGB)  {
         /* only need to cover the formats recognized by dri_fill_st_visual */
         switch (internal_format) {
         case PIPE_FORMAT_B8G8R8A8_UNORM:
            internal_format = PIPE_FORMAT_B8G8R8X8_UNORM;
            break;
         case PIPE_FORMAT_A8R8G8B8_UNORM:
            internal_format = PIPE_FORMAT_X8R8G8B8_UNORM;
            break;
         default:
            break;
         }
      }

      drawable->update_tex_buffer(drawable, ctx, pt);

      ctx->st->teximage(ctx->st,
            (target == GL_TEXTURE_2D) ? ST_TEXTURE_2D : ST_TEXTURE_RECT,
            0, internal_format, pt, FALSE);
   }
}

static void
dri_set_tex_buffer(__DRIcontext *pDRICtx, GLint target,
                   __DRIdrawable *dPriv)
{
   dri_set_tex_buffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
}

const __DRItexBufferExtension driTexBufferExtension = {
   .base = { __DRI_TEX_BUFFER, 2 },

   .setTexBuffer       = dri_set_tex_buffer,
   .setTexBuffer2      = dri_set_tex_buffer2,
   .releaseTexBuffer   = NULL,
};

/**
 * Get the format and binding of an attachment.
 */
void
dri_drawable_get_format(struct dri_drawable *drawable,
                        enum st_attachment_type statt,
                        enum pipe_format *format,
                        unsigned *bind)
{
   switch (statt) {
   case ST_ATTACHMENT_FRONT_LEFT:
   case ST_ATTACHMENT_BACK_LEFT:
   case ST_ATTACHMENT_FRONT_RIGHT:
   case ST_ATTACHMENT_BACK_RIGHT:
      *format = drawable->stvis.color_format;
      *bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
      break;
   case ST_ATTACHMENT_DEPTH_STENCIL:
      *format = drawable->stvis.depth_stencil_format;
      *bind = PIPE_BIND_DEPTH_STENCIL; /* XXX sampler? */
      break;
   default:
      *format = PIPE_FORMAT_NONE;
      *bind = 0;
      break;
   }
}


/**
 * swap_fences_pop_front - pull a fence from the throttle queue
 *
 * If the throttle queue is filled to the desired number of fences,
 * pull fences off the queue until the number is less than the desired
 * number of fences, and return the last fence pulled.
 */
static struct pipe_fence_handle *
swap_fences_pop_front(struct dri_drawable *draw)
{
   struct pipe_screen *screen = draw->screen->base.screen;
   struct pipe_fence_handle *fence = NULL;

   if (draw->desired_fences == 0)
      return NULL;

   if (draw->cur_fences >= draw->desired_fences) {
      screen->fence_reference(screen, &fence, draw->swap_fences[draw->tail]);
      screen->fence_reference(screen, &draw->swap_fences[draw->tail++], NULL);
      draw->tail &= DRI_SWAP_FENCES_MASK;
      --draw->cur_fences;
   }
   return fence;
}


/**
 * swap_fences_push_back - push a fence onto the throttle queue
 *
 * push a fence onto the throttle queue and pull fences of the queue
 * so that the desired number of fences are on the queue.
 */
static void
swap_fences_push_back(struct dri_drawable *draw,
		      struct pipe_fence_handle *fence)
{
   struct pipe_screen *screen = draw->screen->base.screen;

   if (!fence || draw->desired_fences == 0)
      return;

   while(draw->cur_fences == draw->desired_fences)
      swap_fences_pop_front(draw);

   draw->cur_fences++;
   screen->fence_reference(screen, &draw->swap_fences[draw->head++],
			   fence);
   draw->head &= DRI_SWAP_FENCES_MASK;
}


/**
 * swap_fences_unref - empty the throttle queue
 *
 * pulls fences of the throttle queue until it is empty.
 */
static void
swap_fences_unref(struct dri_drawable *draw)
{
   struct pipe_screen *screen = draw->screen->base.screen;

   while(draw->cur_fences) {
      screen->fence_reference(screen, &draw->swap_fences[draw->tail++], NULL);
      draw->tail &= DRI_SWAP_FENCES_MASK;
      --draw->cur_fences;
   }
}

void
dri_pipe_blit(struct pipe_context *pipe,
              struct pipe_resource *dst,
              struct pipe_resource *src)
{
   struct pipe_blit_info blit;

   if (!dst || !src)
      return;

   /* From the GL spec, version 4.2, section 4.1.11 (Additional Multisample
    *  Fragment Operations):
    *
    *      If a framebuffer object is not bound, after all operations have
    *      been completed on the multisample buffer, the sample values for
    *      each color in the multisample buffer are combined to produce a
    *      single color value, and that value is written into the
    *      corresponding color buffers selected by DrawBuffer or
    *      DrawBuffers. An implementation may defer the writing of the color
    *      buffers until a later time, but the state of the framebuffer must
    *      behave as if the color buffers were updated as each fragment was
    *      processed. The method of combination is not specified. If the
    *      framebuffer contains sRGB values, then it is recommended that the
    *      an average of sample values is computed in a linearized space, as
    *      for blending (see section 4.1.7).
    *
    * In other words, to do a resolve operation in a linear space, we have
    * to set sRGB formats if the original resources were sRGB, so don't use
    * util_format_linear.
    */

   memset(&blit, 0, sizeof(blit));
   blit.dst.resource = dst;
   blit.dst.box.width = dst->width0;
   blit.dst.box.height = dst->height0;
   blit.dst.box.depth = 1;
   blit.dst.format = dst->format;
   blit.src.resource = src;
   blit.src.box.width = src->width0;
   blit.src.box.height = src->height0;
   blit.src.box.depth = 1;
   blit.src.format = src->format;
   blit.mask = PIPE_MASK_RGBA;
   blit.filter = PIPE_TEX_FILTER_NEAREST;

   pipe->blit(pipe, &blit);
}

static void
dri_postprocessing(struct dri_context *ctx,
                   struct dri_drawable *drawable,
                   enum st_attachment_type att)
{
   struct pipe_resource *src = drawable->textures[att];
   struct pipe_resource *zsbuf = drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL];

   if (ctx->pp && src && zsbuf)
      pp_run(ctx->pp, src, src, zsbuf);
}

/**
 * DRI2 flush extension, the flush_with_flags function.
 *
 * \param context           the context
 * \param drawable          the drawable to flush
 * \param flags             a combination of _DRI2_FLUSH_xxx flags
 * \param throttle_reason   the reason for throttling, 0 = no throttling
 */
void
dri_flush(__DRIcontext *cPriv,
          __DRIdrawable *dPriv,
          unsigned flags,
          enum __DRI2throttleReason reason)
{
   struct dri_context *ctx = dri_context(cPriv);
   struct dri_drawable *drawable = dri_drawable(dPriv);
   unsigned flush_flags;
   boolean swap_msaa_buffers = FALSE;

   if (!ctx) {
      assert(0);
      return;
   }

   if (drawable) {
      /* prevent recursion */
      if (drawable->flushing)
         return;

      drawable->flushing = TRUE;
   }
   else {
      flags &= ~__DRI2_FLUSH_DRAWABLE;
   }

   /* Flush the drawable. */
   if ((flags & __DRI2_FLUSH_DRAWABLE) &&
       drawable->textures[ST_ATTACHMENT_BACK_LEFT]) {
      struct pipe_context *pipe = ctx->st->pipe;

      if (drawable->stvis.samples > 1 &&
          reason == __DRI2_THROTTLE_SWAPBUFFER) {
         /* Resolve the MSAA back buffer. */
         dri_pipe_blit(ctx->st->pipe,
                       drawable->textures[ST_ATTACHMENT_BACK_LEFT],
                       drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT]);

         if (drawable->msaa_textures[ST_ATTACHMENT_FRONT_LEFT] &&
             drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT]) {
            swap_msaa_buffers = TRUE;
         }

         /* FRONT_LEFT is resolved in drawable->flush_frontbuffer. */
      }

      dri_postprocessing(ctx, drawable, ST_ATTACHMENT_BACK_LEFT);

      if (ctx->hud) {
         hud_draw(ctx->hud, drawable->textures[ST_ATTACHMENT_BACK_LEFT]);
      }

      pipe->flush_resource(pipe, drawable->textures[ST_ATTACHMENT_BACK_LEFT]);
   }

   flush_flags = 0;
   if (flags & __DRI2_FLUSH_CONTEXT)
      flush_flags |= ST_FLUSH_FRONT;
   if (reason == __DRI2_THROTTLE_SWAPBUFFER)
      flush_flags |= ST_FLUSH_END_OF_FRAME;

   /* Flush the context and throttle if needed. */
   if (dri_screen(ctx->sPriv)->throttling_enabled &&
       drawable &&
       (reason == __DRI2_THROTTLE_SWAPBUFFER ||
        reason == __DRI2_THROTTLE_FLUSHFRONT)) {
      /* Throttle.
       *
       * This pulls a fence off the throttling queue and waits for it if the
       * number of fences on the throttling queue has reached the desired
       * number.
       *
       * Then flushes to insert a fence at the current rendering position, and
       * pushes that fence on the queue. This requires that the st_context_iface
       * flush method returns a fence even if there are no commands to flush.
       */
      struct pipe_screen *screen = drawable->screen->base.screen;
      struct pipe_fence_handle *fence;

      fence = swap_fences_pop_front(drawable);
      if (fence) {
         (void) screen->fence_finish(screen, fence, PIPE_TIMEOUT_INFINITE);
         screen->fence_reference(screen, &fence, NULL);
      }

      ctx->st->flush(ctx->st, flush_flags, &fence);

      if (fence) {
         swap_fences_push_back(drawable, fence);
         screen->fence_reference(screen, &fence, NULL);
      }
   }
   else if (flags & (__DRI2_FLUSH_DRAWABLE | __DRI2_FLUSH_CONTEXT)) {
      ctx->st->flush(ctx->st, flush_flags, NULL);
   }

   if (drawable) {
      drawable->flushing = FALSE;
   }

   /* Swap the MSAA front and back buffers, so that reading
    * from the front buffer after SwapBuffers returns what was
    * in the back buffer.
    */
   if (swap_msaa_buffers) {
      struct pipe_resource *tmp =
         drawable->msaa_textures[ST_ATTACHMENT_FRONT_LEFT];

      drawable->msaa_textures[ST_ATTACHMENT_FRONT_LEFT] =
         drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT];
      drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT] = tmp;

      /* Now that we have swapped the buffers, this tells the state
       * tracker to revalidate the framebuffer.
       */
      p_atomic_inc(&drawable->base.stamp);
   }
}

/**
 * dri_throttle - A DRI2ThrottleExtension throttling function.
 */
static void
dri_throttle(__DRIcontext *cPriv, __DRIdrawable *dPriv,
             enum __DRI2throttleReason reason)
{
   dri_flush(cPriv, dPriv, 0, reason);
}


const __DRI2throttleExtension dri2ThrottleExtension = {
    .base = { __DRI2_THROTTLE, 1 },

    .throttle          = dri_throttle,
};


/* vim: set sw=3 ts=8 sts=3 expandtab: */
@


1.3
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@a35 1
#include "pipe/p_context.h"
a36 8
#include "main/mtypes.h"
#include "main/renderbuffer.h"
#include "state_tracker/drm_api.h"
#include "state_tracker/dri1_api.h"
#include "state_tracker/st_public.h"
#include "state_tracker/st_context.h"
#include "state_tracker/st_cb_fbo.h"

a38 1
#include "util/u_rect.h"
a39 20
 
static struct pipe_surface *
dri_surface_from_handle(struct drm_api *api,
			struct pipe_screen *screen,
			unsigned handle,
			enum pipe_format format,
			unsigned width, unsigned height, unsigned pitch)
{
   struct pipe_surface *surface = NULL;
   struct pipe_texture *texture = NULL;
   struct pipe_texture templat;

   memset(&templat, 0, sizeof(templat));
   templat.tex_usage |= PIPE_TEXTURE_USAGE_RENDER_TARGET;
   templat.target = PIPE_TEXTURE_2D;
   templat.last_level = 0;
   templat.depth0 = 1;
   templat.format = format;
   templat.width0 = width;
   templat.height0 = height;
d41 49
a89 2
   texture = api->texture_from_shared_handle(api, screen, &templat,
                                             "dri2 buffer", pitch, handle);
d91 12
a102 3
   if (!texture) {
      debug_printf("%s: Failed to blanket the buffer with a texture\n", __func__);
      return NULL;
d105 1
a105 7
   surface = screen->get_tex_surface(screen, texture, 0, 0, 0,
				     PIPE_BUFFER_USAGE_GPU_READ |
				     PIPE_BUFFER_USAGE_GPU_WRITE);

   /* we don't need the texture from this point on */
   pipe_texture_reference(&texture, NULL);
   return surface;
a107 3
/**
 * Pixmaps have will have the same name of fake front and front.
 */
d109 7
a115 6
dri2_check_if_pixmap(__DRIbuffer *buffers, int count)
{
   boolean found = FALSE;
   boolean is_pixmap = FALSE;
   unsigned name;
   int i;
d117 2
a118 14
   for (i = 0; i < count; i++) {
      switch (buffers[i].attachment) {
      case __DRI_BUFFER_FRONT_LEFT:
      case __DRI_BUFFER_FAKE_FRONT_LEFT:
         if (found) {
            is_pixmap = buffers[i].name == name;
         } else {
            name = buffers[i].name;
            found = TRUE;
         }
      default:
	 continue;
      }
   }
d120 1
a120 1
   return is_pixmap;
d124 1
a124 1
 * This will be called a drawable is known to have been resized.
d126 4
a129 2
void
dri_get_buffers(__DRIdrawable * dPriv)
d131 2
d134 2
a135 29
   struct dri_drawable *drawable = dri_drawable(dPriv);
   struct pipe_surface *surface = NULL;
   struct dri_screen *st_screen = dri_screen(drawable->sPriv);
   struct pipe_screen *screen = st_screen->pipe_screen;
   __DRIbuffer *buffers = NULL;
   __DRIscreen *dri_screen = drawable->sPriv;
   __DRIdrawable *dri_drawable = drawable->dPriv;
   struct drm_api *api = st_screen->api;
   boolean have_depth = FALSE;
   int i, count;

   if ((dri_screen->dri2.loader
        && (dri_screen->dri2.loader->base.version > 2)
        && (dri_screen->dri2.loader->getBuffersWithFormat != NULL))) {
      buffers = (*dri_screen->dri2.loader->getBuffersWithFormat)
                (dri_drawable, &dri_drawable->w, &dri_drawable->h,
                 drawable->attachments, drawable->num_attachments,
                 &count, dri_drawable->loaderPrivate);
   } else {
      assert(dri_screen->dri2.loader);
      buffers = (*dri_screen->dri2.loader->getBuffers) (dri_drawable,
                                                        &dri_drawable->w,
                                                        &dri_drawable->h,
                                                        drawable->attachments,
                                                        drawable->
                                                        num_attachments, &count,
                                                        dri_drawable->
                                                        loaderPrivate);
   }
d137 3
a139 3
   if (buffers == NULL) {
      return;
   }
d141 1
a141 27
   /* set one cliprect to cover the whole dri_drawable */
   dri_drawable->x = 0;
   dri_drawable->y = 0;
   dri_drawable->backX = 0;
   dri_drawable->backY = 0;
   dri_drawable->numClipRects = 1;
   dri_drawable->pClipRects[0].x1 = 0;
   dri_drawable->pClipRects[0].y1 = 0;
   dri_drawable->pClipRects[0].x2 = dri_drawable->w;
   dri_drawable->pClipRects[0].y2 = dri_drawable->h;
   dri_drawable->numBackClipRects = 1;
   dri_drawable->pBackClipRects[0].x1 = 0;
   dri_drawable->pBackClipRects[0].y1 = 0;
   dri_drawable->pBackClipRects[0].x2 = dri_drawable->w;
   dri_drawable->pBackClipRects[0].y2 = dri_drawable->h;

   if (drawable->old_num == count &&
       drawable->old_w == dri_drawable->w &&
       drawable->old_h == dri_drawable->h &&
       memcmp(drawable->old, buffers, sizeof(__DRIbuffer) * count) == 0) {
       return;
   } else {
      drawable->old_num = count;
      drawable->old_w = dri_drawable->w;
      drawable->old_h = dri_drawable->h;
      memcpy(drawable->old, buffers, sizeof(__DRIbuffer) * count);
   }
d143 5
a147 1
   drawable->is_pixmap = dri2_check_if_pixmap(buffers, count);
d149 6
a154 3
   for (i = 0; i < count; i++) {
      enum pipe_format format = 0;
      int index = 0;
d156 2
a157 23
      switch (buffers[i].attachment) {
      case __DRI_BUFFER_FRONT_LEFT:
	 if (!st_screen->auto_fake_front)
	    continue;
	 /* fallthrough */
      case __DRI_BUFFER_FAKE_FRONT_LEFT:
	 index = ST_SURFACE_FRONT_LEFT;
	 format = drawable->color_format;
	 break;
      case __DRI_BUFFER_BACK_LEFT:
	 index = ST_SURFACE_BACK_LEFT;
	 format = drawable->color_format;
	 break;
      case __DRI_BUFFER_DEPTH:
      case __DRI_BUFFER_DEPTH_STENCIL:
      case __DRI_BUFFER_STENCIL:
	 index = ST_SURFACE_DEPTH;
	 format = drawable->depth_stencil_format;
	 break;
      case __DRI_BUFFER_ACCUM:
      default:
	 assert(0);
      }
d159 4
a162 35
      if (index == ST_SURFACE_DEPTH) {
	 if (have_depth)
	    continue;
	 else
	    have_depth = TRUE;
      }

      surface = dri_surface_from_handle(api,
					screen,
					buffers[i].name,
					format,
					dri_drawable->w,
					dri_drawable->h, buffers[i].pitch);

      switch (buffers[i].attachment) {
      case __DRI_BUFFER_FRONT_LEFT:
      case __DRI_BUFFER_FAKE_FRONT_LEFT:
      case __DRI_BUFFER_BACK_LEFT:
	 drawable->color_format = surface->format;
	 break;
      case __DRI_BUFFER_DEPTH:
      case __DRI_BUFFER_DEPTH_STENCIL:
      case __DRI_BUFFER_STENCIL:
	 drawable->depth_stencil_format = surface->format;
	 break;
      case __DRI_BUFFER_ACCUM:
      default:
	 assert(0);
      }

      st_set_framebuffer_surface(drawable->stfb, index, surface);
      pipe_surface_reference(&surface, NULL);
   }
   /* this needed, or else the state tracker fails to pick the new buffers */
   st_resize_framebuffer(drawable->stfb, dri_drawable->w, dri_drawable->h);
d165 2
a166 5
/**
 * These are used for GLX_EXT_texture_from_pixmap
 */
void dri2_set_tex_buffer2(__DRIcontext *pDRICtx, GLint target,
                          GLint format, __DRIdrawable *dPriv)
d169 1
a169 1
   struct pipe_surface *ps;
d171 1
a171 5
   if (!drawable->stfb->Base.Attachment[BUFFER_FRONT_LEFT].Renderbuffer) {
      struct gl_renderbuffer *rb =
         st_new_renderbuffer_fb(drawable->color_format, 0 /*XXX*/, FALSE);
      _mesa_add_renderbuffer(&drawable->stfb->Base, BUFFER_FRONT_LEFT, rb);
   }
d173 4
a176 2
   dri_get_buffers(drawable->dPriv);
   st_get_framebuffer_surface(drawable->stfb, ST_SURFACE_FRONT_LEFT, &ps);
d178 1
a178 2
   if (!ps)
      return;
d180 1
a180 2
   st_bind_texture_surface(ps, target == GL_TEXTURE_2D ? ST_TEXTURE_2D :
                           ST_TEXTURE_RECT, 0, drawable->color_format);
d183 8
a190 8
void dri2_set_tex_buffer(__DRIcontext *pDRICtx, GLint target,
                         __DRIdrawable *dPriv)
{
   dri2_set_tex_buffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
}

void
dri_update_buffer(struct pipe_screen *screen, void *context_private)
d192 2
a193 1
   struct dri_context *ctx = (struct dri_context *)context_private;
d195 2
a196 2
   if (ctx->d_stamp == *ctx->dPriv->pStamp &&
       ctx->r_stamp == *ctx->rPriv->pStamp)
d199 7
a205 2
   ctx->d_stamp = *ctx->dPriv->pStamp;
   ctx->r_stamp = *ctx->rPriv->pStamp;
d207 1
a207 4
   /* Ask the X server for new renderbuffers. */
   dri_get_buffers(ctx->dPriv);
   if (ctx->dPriv != ctx->rPriv)
      dri_get_buffers(ctx->rPriv);
d209 1
d212 6
a217 3
void
dri_flush_frontbuffer(struct pipe_screen *screen,
		      struct pipe_surface *surf, void *context_private)
d219 5
a223 4
   struct dri_context *ctx = (struct dri_context *)context_private;
   struct dri_drawable *drawable = dri_drawable(ctx->dPriv);
   __DRIdrawable *dri_drawable = ctx->dPriv;
   __DRIscreen *dri_screen = ctx->sPriv;
d225 2
a226 1
   /* XXX Does this function get called with DRI1? */
d228 16
a243 4
   if (ctx->dPriv == NULL) {
      debug_printf("%s: no drawable bound to context\n", __func__);
      return;
   }
d245 1
a245 7
#if 0
   /* TODO if rendering to pixmaps is slow enable this code. */
   if (drawable->is_pixmap)
      return;
#else
   (void)drawable;
#endif
d247 4
a250 2
   (*dri_screen->dri2.loader->flushFrontBuffer)(dri_drawable,
						dri_drawable->loaderPrivate);
d253 3
a255 7
/**
 * This is called when we need to set up GL rendering to a new X window.
 */
boolean
dri_create_buffer(__DRIscreen * sPriv,
		  __DRIdrawable * dPriv,
		  const __GLcontextModes * visual, boolean isPixmap)
d257 2
a258 3
   struct dri_screen *screen = sPriv->private;
   struct dri_drawable *drawable = NULL;
   int i;
d260 2
a261 2
   if (isPixmap)
      goto fail;		       /* not implemented */
d263 4
a266 3
   drawable = CALLOC_STRUCT(dri_drawable);
   if (drawable == NULL)
      goto fail;
d268 16
a283 13
   if (visual->redBits == 8) {
      if (visual->alphaBits == 8)
         drawable->color_format = PIPE_FORMAT_B8G8R8A8_UNORM;
      else
         drawable->color_format = PIPE_FORMAT_B8G8R8X8_UNORM;
   } else {
      drawable->color_format = PIPE_FORMAT_B5G6R5_UNORM;
   }

   switch(visual->depthBits) {
   default:
   case 0:
      drawable->depth_stencil_format = PIPE_FORMAT_NONE;
d285 3
a287 2
   case 16:
      drawable->depth_stencil_format = PIPE_FORMAT_Z16_UNORM;
d289 3
a291 13
   case 24:
      if (visual->stencilBits == 0) {
	 drawable->depth_stencil_format = (screen->d_depth_bits_last) ?
                                          PIPE_FORMAT_Z24X8_UNORM:
                                          PIPE_FORMAT_X8Z24_UNORM;
      } else {
	 drawable->depth_stencil_format = (screen->sd_depth_bits_last) ?
                                          PIPE_FORMAT_Z24S8_UNORM:
                                          PIPE_FORMAT_S8Z24_UNORM;
      }
      break;
   case 32:
      drawable->depth_stencil_format = PIPE_FORMAT_Z32_UNORM;
d294 1
a295 62
   drawable->stfb = st_create_framebuffer(visual,
					  drawable->color_format,
					  drawable->depth_stencil_format,
					  drawable->depth_stencil_format,
					  dPriv->w,
					  dPriv->h, (void *)drawable);
   if (drawable->stfb == NULL)
      goto fail;

   drawable->sPriv = sPriv;
   drawable->dPriv = dPriv;
   dPriv->driverPrivate = (void *)drawable;

   /* setup dri2 buffers information */
   /* TODO incase of double buffer visual, delay fake creation */
   i = 0;
   if (sPriv->dri2.loader
       && (sPriv->dri2.loader->base.version > 2)
       && (sPriv->dri2.loader->getBuffersWithFormat != NULL)) {
      drawable->attachments[i++] = __DRI_BUFFER_FRONT_LEFT;
      drawable->attachments[i++] = visual->rgbBits;
      if (!screen->auto_fake_front)  {
         drawable->attachments[i++] = __DRI_BUFFER_FAKE_FRONT_LEFT;
         drawable->attachments[i++] = visual->rgbBits;
      }
      if (visual->doubleBufferMode) {
         drawable->attachments[i++] = __DRI_BUFFER_BACK_LEFT;
         drawable->attachments[i++] = visual->rgbBits;
      }
      if (visual->depthBits && visual->stencilBits) {
         drawable->attachments[i++] = __DRI_BUFFER_DEPTH_STENCIL;
         drawable->attachments[i++] = visual->depthBits + visual->stencilBits;
      } else if (visual->depthBits) {
         drawable->attachments[i++] = __DRI_BUFFER_DEPTH;
         drawable->attachments[i++] = visual->depthBits;
      } else if (visual->stencilBits) {
         drawable->attachments[i++] = __DRI_BUFFER_STENCIL;
         drawable->attachments[i++] = visual->stencilBits;
      }
      drawable->num_attachments = i / 2;
   } else {
      drawable->attachments[i++] = __DRI_BUFFER_FRONT_LEFT;
      if (!screen->auto_fake_front)
         drawable->attachments[i++] = __DRI_BUFFER_FAKE_FRONT_LEFT;
      if (visual->doubleBufferMode)
         drawable->attachments[i++] = __DRI_BUFFER_BACK_LEFT;
      if (visual->depthBits && visual->stencilBits)
         drawable->attachments[i++] = __DRI_BUFFER_DEPTH_STENCIL;
      else if (visual->depthBits)
         drawable->attachments[i++] = __DRI_BUFFER_DEPTH;
      else if (visual->stencilBits)
         drawable->attachments[i++] = __DRI_BUFFER_STENCIL;
      drawable->num_attachments = i;
   }

   drawable->desired_fences = 2;

   return GL_TRUE;
fail:
   FREE(drawable);
   return GL_FALSE;
}
d297 7
d305 1
a305 1
dri_swap_fences_pop_front(struct dri_drawable *draw)
d307 1
a307 1
   struct pipe_screen *screen = dri_screen(draw->sPriv)->pipe_screen;
d310 3
d316 1
a317 1
      draw->tail &= DRI_SWAP_FENCES_MASK;
d322 7
d330 2
a331 2
dri_swap_fences_push_back(struct dri_drawable *draw,
			  struct pipe_fence_handle *fence)
d333 1
a333 1
   struct pipe_screen *screen = dri_screen(draw->sPriv)->pipe_screen;
d335 1
a335 1
   if (!fence)
d338 2
a339 21
   if (draw->cur_fences < DRI_SWAP_FENCES_MAX) {
      draw->cur_fences++;
      screen->fence_reference(screen, &draw->swap_fences[draw->head++],
			      fence);
      draw->head &= DRI_SWAP_FENCES_MASK;
   }
}

void
dri_destroy_buffer(__DRIdrawable * dPriv)
{
   struct dri_drawable *drawable = dri_drawable(dPriv);
   struct pipe_fence_handle *fence;
   struct pipe_screen *screen = dri_screen(drawable->sPriv)->pipe_screen;

   st_unreference_framebuffer(drawable->stfb);
   drawable->desired_fences = 0;
   while (drawable->cur_fences) {
      fence = dri_swap_fences_pop_front(drawable);
      screen->fence_reference(screen, &fence, NULL);
   }
d341 4
a344 1
   FREE(drawable);
a346 14
static void
dri1_update_drawables_locked(struct dri_context *ctx,
			     __DRIdrawable * driDrawPriv,
			     __DRIdrawable * driReadPriv)
{
   if (ctx->stLostLock) {
      ctx->stLostLock = FALSE;
      if (driDrawPriv == driReadPriv)
	 DRI_VALIDATE_DRAWABLE_INFO(ctx->sPriv, driDrawPriv);
      else
	 DRI_VALIDATE_TWO_DRAWABLES_INFO(ctx->sPriv, driDrawPriv,
					 driReadPriv);
   }
}
d349 3
a351 5
 * This ensures all contexts which bind to a drawable pick up the
 * drawable change and signal new buffer state.
 * Calling st_resize_framebuffer for each context may seem like overkill,
 * but no new buffers will actually be allocated if the dimensions don't
 * change.
a352 1

d354 1
a354 1
dri1_propagate_drawable_change(struct dri_context *ctx)
d356 1
a356 23
   __DRIdrawable *dPriv = ctx->dPriv;
   __DRIdrawable *rPriv = ctx->rPriv;
   boolean flushed = FALSE;

   if (dPriv && ctx->d_stamp != dPriv->lastStamp) {

      st_flush(ctx->st, PIPE_FLUSH_RENDER_CACHE, NULL);
      flushed = TRUE;
      ctx->d_stamp = dPriv->lastStamp;
      st_resize_framebuffer(dri_drawable(dPriv)->stfb, dPriv->w, dPriv->h);

   }

   if (rPriv && dPriv != rPriv && ctx->r_stamp != rPriv->lastStamp) {

      if (!flushed)
	 st_flush(ctx->st, PIPE_FLUSH_RENDER_CACHE, NULL);
      ctx->r_stamp = rPriv->lastStamp;
      st_resize_framebuffer(dri_drawable(rPriv)->stfb, rPriv->w, rPriv->h);

   } else if (rPriv && dPriv == rPriv) {

      ctx->r_stamp = ctx->d_stamp;
d358 4
d366 3
a368 2
dri1_update_drawables(struct dri_context *ctx,
		      struct dri_drawable *draw, struct dri_drawable *read)
d370 1
a370 33
   dri_lock(ctx);
   dri1_update_drawables_locked(ctx, draw->dPriv, read->dPriv);
   dri_unlock(ctx);

   dri1_propagate_drawable_change(ctx);
}

static INLINE boolean
dri1_intersect_src_bbox(struct drm_clip_rect *dst,
			int dst_x,
			int dst_y,
			const struct drm_clip_rect *src,
			const struct drm_clip_rect *bbox)
{
   int xy1;
   int xy2;

   xy1 = ((int)src->x1 > (int)bbox->x1 + dst_x) ? src->x1 :
      (int)bbox->x1 + dst_x;
   xy2 = ((int)src->x2 < (int)bbox->x2 + dst_x) ? src->x2 :
      (int)bbox->x2 + dst_x;
   if (xy1 >= xy2 || xy1 < 0)
      return FALSE;

   dst->x1 = xy1;
   dst->x2 = xy2;

   xy1 = ((int)src->y1 > (int)bbox->y1 + dst_y) ? src->y1 :
      (int)bbox->y1 + dst_y;
   xy2 = ((int)src->y2 < (int)bbox->y2 + dst_y) ? src->y2 :
      (int)bbox->y2 + dst_y;
   if (xy1 >= xy2 || xy1 < 0)
      return FALSE;
d372 2
a373 4
   dst->y1 = xy1;
   dst->y2 = xy2;
   return TRUE;
}
d375 20
a394 10
static void
dri1_swap_copy(struct dri_context *ctx,
	       struct pipe_surface *dst,
	       struct pipe_surface *src,
	       __DRIdrawable * dPriv, const struct drm_clip_rect *bbox)
{
   struct pipe_context *pipe = ctx->pipe;
   struct drm_clip_rect clip;
   struct drm_clip_rect *cur;
   int i;
d396 13
a408 1
   cur = dPriv->pClipRects;
d410 1
a410 17
   for (i = 0; i < dPriv->numClipRects; ++i) {
      if (dri1_intersect_src_bbox(&clip, dPriv->x, dPriv->y, cur++, bbox)) {
         if (pipe->surface_copy) {
            pipe->surface_copy(pipe, dst, clip.x1, clip.y1,
                               src,
                               (int)clip.x1 - dPriv->x,
                               (int)clip.y1 - dPriv->y,
                               clip.x2 - clip.x1, clip.y2 - clip.y1);
         } else {
            util_surface_copy(pipe, FALSE, dst, clip.x1, clip.y1,
                              src,
                              (int)clip.x1 - dPriv->x,
                              (int)clip.y1 - dPriv->y,
                              clip.x2 - clip.x1, clip.y2 - clip.y1);
         }
      }
   }
d414 3
a416 5
dri1_copy_to_front(struct dri_context *ctx,
		   struct pipe_surface *surf,
		   __DRIdrawable * dPriv,
		   const struct drm_clip_rect *sub_box,
		   struct pipe_fence_handle **fence)
d418 2
a419 6
   struct pipe_context *pipe = ctx->pipe;
   boolean save_lost_lock;
   uint cur_w;
   uint cur_h;
   struct drm_clip_rect bbox;
   boolean visible = TRUE;
d421 3
a423 1
   *fence = NULL;
d425 18
a442 4
   dri_lock(ctx);
   save_lost_lock = ctx->stLostLock;
   dri1_update_drawables_locked(ctx, dPriv, dPriv);
   st_get_framebuffer_dimensions(dri_drawable(dPriv)->stfb, &cur_w, &cur_h);
d444 4
a447 4
   bbox.x1 = 0;
   bbox.x2 = cur_w;
   bbox.y1 = 0;
   bbox.y2 = cur_h;
d449 27
a475 2
   if (sub_box)
      visible = dri1_intersect_src_bbox(&bbox, 0, 0, &bbox, sub_box);
d477 2
a478 1
   if (visible && __dri1_api_hooks->present_locked) {
d480 1
a480 5
      __dri1_api_hooks->present_locked(pipe,
				       surf,
				       dPriv->pClipRects,
				       dPriv->numClipRects,
				       dPriv->x, dPriv->y, &bbox, fence);
d482 3
a484 1
   } else if (visible && __dri1_api_hooks->front_srf_locked) {
d486 1
a486 6
      struct pipe_surface *front = __dri1_api_hooks->front_srf_locked(pipe);

      if (front)
	 dri1_swap_copy(ctx, front, surf, dPriv, &bbox);

      st_flush(ctx->st, PIPE_FLUSH_RENDER_CACHE, fence);
d489 23
a511 1
   ctx->stLostLock = save_lost_lock;
d513 5
a517 3
   /**
    * FIXME: Revisit this: Update drawables on copy_sub_buffer ?
    */
d519 1
a519 2
   if (!sub_box)
      dri1_update_drawables_locked(ctx, ctx->dPriv, ctx->rPriv);
d521 8
a528 3
   dri_unlock(ctx);
   dri1_propagate_drawable_change(ctx);
}
d530 3
a532 6
void
dri1_flush_frontbuffer(struct pipe_screen *screen,
		       struct pipe_surface *surf, void *context_private)
{
   struct dri_context *ctx = (struct dri_context *)context_private;
   struct pipe_fence_handle *dummy_fence;
d534 3
a536 5
   dri1_copy_to_front(ctx, surf, ctx->dPriv, NULL, &dummy_fence);
   screen->fence_reference(screen, &dummy_fence, NULL);

   /**
    * FIXME: Do we need swap throttling here?
d538 13
d553 6
a558 2
void
dri_swap_buffers(__DRIdrawable * dPriv)
d560 1
a560 27
   struct dri_context *ctx;
   struct pipe_surface *back_surf;
   struct dri_drawable *draw = dri_drawable(dPriv);
   struct pipe_screen *screen = dri_screen(draw->sPriv)->pipe_screen;
   struct pipe_fence_handle *fence;
   struct st_context *st = st_get_current();

   assert(__dri1_api_hooks != NULL);

   if (!st)
      return;			       /* For now */

   ctx = (struct dri_context *)st->pipe->priv;

   st_get_framebuffer_surface(draw->stfb, ST_SURFACE_BACK_LEFT, &back_surf);
   if (back_surf) {
      st_notify_swapbuffers(draw->stfb);
      st_flush(ctx->st, PIPE_FLUSH_RENDER_CACHE, NULL);
      fence = dri_swap_fences_pop_front(draw);
      if (fence) {
	 (void)screen->fence_finish(screen, fence, 0);
	 screen->fence_reference(screen, &fence, NULL);
      }
      dri1_copy_to_front(ctx, back_surf, dPriv, NULL, &fence);
      dri_swap_fences_push_back(draw, fence);
      screen->fence_reference(screen, &fence, NULL);
   }
a562 12
void
dri_copy_sub_buffer(__DRIdrawable * dPriv, int x, int y, int w, int h)
{
   struct pipe_screen *screen = dri_screen(dPriv->driScreenPriv)->pipe_screen;
   struct drm_clip_rect sub_bbox;
   struct dri_context *ctx;
   struct pipe_surface *back_surf;
   struct dri_drawable *draw = dri_drawable(dPriv);
   struct pipe_fence_handle *dummy_fence;
   struct st_context *st = st_get_current();

   assert(__dri1_api_hooks != NULL);
d564 2
a565 2
   if (!st)
      return;
d567 2
a568 1
   ctx = (struct dri_context *)st->pipe->priv;
a569 12
   sub_bbox.x1 = x;
   sub_bbox.x2 = x + w;
   sub_bbox.y1 = y;
   sub_bbox.y2 = y + h;

   st_get_framebuffer_surface(draw->stfb, ST_SURFACE_BACK_LEFT, &back_surf);
   if (back_surf) {
      st_flush(ctx->st, PIPE_FLUSH_RENDER_CACHE, NULL);
      dri1_copy_to_front(ctx, back_surf, dPriv, &sub_bbox, &dummy_fence);
      screen->fence_reference(screen, &dummy_fence, NULL);
   }
}
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.1.1.1
log
@Import Mesa 10.4.3
@
text
@d36 1
d38 8
d48 1
d50 20
d71 2
a72 2
static void
swap_fences_unref(struct dri_drawable *draw);
d74 3
a76 59
static boolean
dri_st_framebuffer_validate(struct st_context_iface *stctx,
                            struct st_framebuffer_iface *stfbi,
                            const enum st_attachment_type *statts,
                            unsigned count,
                            struct pipe_resource **out)
{
   struct dri_context *ctx = (struct dri_context *)stctx->st_manager_private;
   struct dri_drawable *drawable =
      (struct dri_drawable *) stfbi->st_manager_private;
   struct dri_screen *screen = dri_screen(drawable->sPriv);
   unsigned statt_mask, new_mask;
   boolean new_stamp;
   int i;
   unsigned int lastStamp;
   struct pipe_resource **textures =
      drawable->stvis.samples > 1 ? drawable->msaa_textures
                                  : drawable->textures;

   statt_mask = 0x0;
   for (i = 0; i < count; i++)
      statt_mask |= (1 << statts[i]);

   /* record newly allocated textures */
   new_mask = (statt_mask & ~drawable->texture_mask);

   /*
    * dPriv->dri2.stamp is the server stamp.  dPriv->lastStamp is the
    * client stamp.  It has the value of the server stamp when last
    * checked.
    */
   do {
      lastStamp = drawable->dPriv->lastStamp;
      new_stamp = (drawable->texture_stamp != lastStamp);

      if (new_stamp || new_mask || screen->broken_invalidate) {
         if (new_stamp && drawable->update_drawable_info)
            drawable->update_drawable_info(drawable);

         drawable->allocate_textures(ctx, drawable, statts, count);

         /* add existing textures */
         for (i = 0; i < ST_ATTACHMENT_COUNT; i++) {
            if (textures[i])
               statt_mask |= (1 << i);
         }

         drawable->texture_stamp = lastStamp;
         drawable->texture_mask = statt_mask;
      }
   } while (lastStamp != drawable->dPriv->lastStamp);

   if (!out)
      return TRUE;

   /* Set the window-system buffers for the state tracker. */
   for (i = 0; i < count; i++) {
      out[i] = NULL;
      pipe_resource_reference(&out[i], textures[statts[i]]);
d79 7
a85 1
   return TRUE;
d88 3
d92 6
a97 7
dri_st_framebuffer_flush_front(struct st_context_iface *stctx,
                               struct st_framebuffer_iface *stfbi,
                               enum st_attachment_type statt)
{
   struct dri_context *ctx = (struct dri_context *)stctx->st_manager_private;
   struct dri_drawable *drawable =
      (struct dri_drawable *) stfbi->st_manager_private;
d99 14
a112 2
   /* XXX remove this and just set the correct one on the framebuffer */
   drawable->flush_frontbuffer(ctx, drawable, statt);
d114 1
a114 1
   return TRUE;
d118 1
a118 1
 * This is called when we need to set up GL rendering to a new X window.
d120 2
a121 4
boolean
dri_create_buffer(__DRIscreen * sPriv,
		  __DRIdrawable * dPriv,
		  const struct gl_config * visual, boolean isPixmap)
a122 2
   struct dri_screen *screen = sPriv->driverPrivate;
   struct dri_drawable *drawable = NULL;
d124 61
a184 2
   if (isPixmap)
      goto fail;		       /* not implemented */
d186 1
a186 3
   drawable = CALLOC_STRUCT(dri_drawable);
   if (drawable == NULL)
      goto fail;
d188 3
a190 1
   dri_fill_st_visual(&drawable->stvis, screen, visual);
d192 23
a214 5
   /* setup the st_framebuffer_iface */
   drawable->base.visual = &drawable->stvis;
   drawable->base.flush_front = dri_st_framebuffer_flush_front;
   drawable->base.validate = dri_st_framebuffer_validate;
   drawable->base.st_manager_private = (void *) drawable;
d216 6
a221 6
   drawable->screen = screen;
   drawable->sPriv = sPriv;
   drawable->dPriv = dPriv;
   drawable->desired_fences = screen->default_throttle_frames;
   if (drawable->desired_fences > DRI_SWAP_FENCES_MAX)
      drawable->desired_fences = DRI_SWAP_FENCES_MAX;
d223 22
a244 2
   dPriv->driverPrivate = (void *)drawable;
   p_atomic_set(&drawable->base.stamp, 1);
d246 5
a250 4
   return GL_TRUE;
fail:
   FREE(drawable);
   return GL_FALSE;
d253 5
a257 2
void
dri_destroy_buffer(__DRIdrawable * dPriv)
d260 7
a266 1
   int i;
d268 2
a269 1
   pipe_surface_reference(&drawable->drisw_surface, NULL);
d271 2
a272 4
   for (i = 0; i < ST_ATTACHMENT_COUNT; i++)
      pipe_resource_reference(&drawable->textures[i], NULL);
   for (i = 0; i < ST_ATTACHMENT_COUNT; i++)
      pipe_resource_reference(&drawable->msaa_textures[i], NULL);
d274 3
a276 1
   swap_fences_unref(drawable);
d278 4
a281 1
   FREE(drawable);
d284 2
a285 8
/**
 * Validate the texture at an attachment.  Allocate the texture if it does not
 * exist.  Used by the TFP extension.
 */
static void
dri_drawable_validate_att(struct dri_context *ctx,
                          struct dri_drawable *drawable,
                          enum st_attachment_type statt)
d287 1
a287 2
   enum st_attachment_type statts[ST_ATTACHMENT_COUNT];
   unsigned i, count = 0;
d289 2
a290 2
   /* check if buffer already exists */
   if (drawable->texture_mask & (1 << statt))
d293 2
a294 7
   /* make sure DRI2 does not destroy existing buffers */
   for (i = 0; i < ST_ATTACHMENT_COUNT; i++) {
      if (drawable->texture_mask & (1 << i)) {
         statts[count++] = i;
      }
   }
   statts[count++] = statt;
d296 4
a299 1
   drawable->texture_stamp = drawable->dPriv->lastStamp - 1;
a300 1
   drawable->base.validate(ctx->st, &drawable->base, statts, count, NULL);
d303 3
a305 6
/**
 * These are used for GLX_EXT_texture_from_pixmap
 */
static void
dri_set_tex_buffer2(__DRIcontext *pDRICtx, GLint target,
                    GLint format, __DRIdrawable *dPriv)
d307 4
a310 3
   struct dri_context *ctx = dri_context(pDRICtx);
   struct dri_drawable *drawable = dri_drawable(dPriv);
   struct pipe_resource *pt;
d312 1
a312 1
   dri_drawable_validate_att(ctx, drawable, ST_ATTACHMENT_FRONT_LEFT);
d314 4
a317 2
   /* Use the pipe resource associated with the X drawable */
   pt = drawable->textures[ST_ATTACHMENT_FRONT_LEFT];
d319 7
a325 18
   if (pt) {
      enum pipe_format internal_format = pt->format;

      if (format == __DRI_TEXTURE_FORMAT_RGB)  {
         /* only need to cover the formats recognized by dri_fill_st_visual */
         switch (internal_format) {
         case PIPE_FORMAT_B8G8R8A8_UNORM:
            internal_format = PIPE_FORMAT_B8G8R8X8_UNORM;
            break;
         case PIPE_FORMAT_A8R8G8B8_UNORM:
            internal_format = PIPE_FORMAT_X8R8G8B8_UNORM;
            break;
         default:
            break;
         }
      }

      drawable->update_tex_buffer(drawable, ctx, pt);
d327 2
a328 4
      ctx->st->teximage(ctx->st,
            (target == GL_TEXTURE_2D) ? ST_TEXTURE_2D : ST_TEXTURE_RECT,
            0, internal_format, pt, FALSE);
   }
d331 7
a337 3
static void
dri_set_tex_buffer(__DRIcontext *pDRICtx, GLint target,
                   __DRIdrawable *dPriv)
d339 3
a341 2
   dri_set_tex_buffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
}
d343 2
a344 2
const __DRItexBufferExtension driTexBufferExtension = {
   .base = { __DRI_TEX_BUFFER, 2 },
d346 3
a348 4
   .setTexBuffer       = dri_set_tex_buffer,
   .setTexBuffer2      = dri_set_tex_buffer2,
   .releaseTexBuffer   = NULL,
};
d350 16
a365 16
/**
 * Get the format and binding of an attachment.
 */
void
dri_drawable_get_format(struct dri_drawable *drawable,
                        enum st_attachment_type statt,
                        enum pipe_format *format,
                        unsigned *bind)
{
   switch (statt) {
   case ST_ATTACHMENT_FRONT_LEFT:
   case ST_ATTACHMENT_BACK_LEFT:
   case ST_ATTACHMENT_FRONT_RIGHT:
   case ST_ATTACHMENT_BACK_RIGHT:
      *format = drawable->stvis.color_format;
      *bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
d367 10
a376 3
   case ST_ATTACHMENT_DEPTH_STENCIL:
      *format = drawable->stvis.depth_stencil_format;
      *bind = PIPE_BIND_DEPTH_STENCIL; /* XXX sampler? */
d378 2
a379 3
   default:
      *format = PIPE_FORMAT_NONE;
      *bind = 0;
d382 62
a445 8

/**
 * swap_fences_pop_front - pull a fence from the throttle queue
 *
 * If the throttle queue is filled to the desired number of fences,
 * pull fences off the queue until the number is less than the desired
 * number of fences, and return the last fence pulled.
 */
d447 1
a447 1
swap_fences_pop_front(struct dri_drawable *draw)
d449 1
a449 1
   struct pipe_screen *screen = draw->screen->base.screen;
a451 3
   if (draw->desired_fences == 0)
      return NULL;

d455 1
a456 1
      --draw->cur_fences;
a460 7

/**
 * swap_fences_push_back - push a fence onto the throttle queue
 *
 * push a fence onto the throttle queue and pull fences of the queue
 * so that the desired number of fences are on the queue.
 */
d462 2
a463 2
swap_fences_push_back(struct dri_drawable *draw,
		      struct pipe_fence_handle *fence)
d465 1
a465 1
   struct pipe_screen *screen = draw->screen->base.screen;
d467 1
a467 1
   if (!fence || draw->desired_fences == 0)
d470 21
a490 2
   while(draw->cur_fences == draw->desired_fences)
      swap_fences_pop_front(draw);
d492 1
a492 4
   draw->cur_fences++;
   screen->fence_reference(screen, &draw->swap_fences[draw->head++],
			   fence);
   draw->head &= DRI_SWAP_FENCES_MASK;
d495 14
d511 5
a515 3
 * swap_fences_unref - empty the throttle queue
 *
 * pulls fences of the throttle queue until it is empty.
d517 1
d519 1
a519 1
swap_fences_unref(struct dri_drawable *draw)
d521 23
a543 1
   struct pipe_screen *screen = draw->screen->base.screen;
a544 4
   while(draw->cur_fences) {
      screen->fence_reference(screen, &draw->swap_fences[draw->tail++], NULL);
      draw->tail &= DRI_SWAP_FENCES_MASK;
      --draw->cur_fences;
d549 2
a550 3
dri_pipe_blit(struct pipe_context *pipe,
              struct pipe_resource *dst,
              struct pipe_resource *src)
d552 33
a584 1
   struct pipe_blit_info blit;
d586 4
a589 2
   if (!dst || !src)
      return;
d591 10
a600 20
   /* From the GL spec, version 4.2, section 4.1.11 (Additional Multisample
    *  Fragment Operations):
    *
    *      If a framebuffer object is not bound, after all operations have
    *      been completed on the multisample buffer, the sample values for
    *      each color in the multisample buffer are combined to produce a
    *      single color value, and that value is written into the
    *      corresponding color buffers selected by DrawBuffer or
    *      DrawBuffers. An implementation may defer the writing of the color
    *      buffers until a later time, but the state of the framebuffer must
    *      behave as if the color buffers were updated as each fragment was
    *      processed. The method of combination is not specified. If the
    *      framebuffer contains sRGB values, then it is recommended that the
    *      an average of sample values is computed in a linearized space, as
    *      for blending (see section 4.1.7).
    *
    * In other words, to do a resolve operation in a linear space, we have
    * to set sRGB formats if the original resources were sRGB, so don't use
    * util_format_linear.
    */
d602 1
a602 13
   memset(&blit, 0, sizeof(blit));
   blit.dst.resource = dst;
   blit.dst.box.width = dst->width0;
   blit.dst.box.height = dst->height0;
   blit.dst.box.depth = 1;
   blit.dst.format = dst->format;
   blit.src.resource = src;
   blit.src.box.width = src->width0;
   blit.src.box.height = src->height0;
   blit.src.box.depth = 1;
   blit.src.format = src->format;
   blit.mask = PIPE_MASK_RGBA;
   blit.filter = PIPE_TEX_FILTER_NEAREST;
d604 17
a620 1
   pipe->blit(pipe, &blit);
d624 5
a628 3
dri_postprocessing(struct dri_context *ctx,
                   struct dri_drawable *drawable,
                   enum st_attachment_type att)
d630 8
a637 2
   struct pipe_resource *src = drawable->textures[att];
   struct pipe_resource *zsbuf = drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL];
d639 9
a647 3
   if (ctx->pp && src && zsbuf)
      pp_run(ctx->pp, src, src, zsbuf);
}
d649 2
a650 18
/**
 * DRI2 flush extension, the flush_with_flags function.
 *
 * \param context           the context
 * \param drawable          the drawable to flush
 * \param flags             a combination of _DRI2_FLUSH_xxx flags
 * \param throttle_reason   the reason for throttling, 0 = no throttling
 */
void
dri_flush(__DRIcontext *cPriv,
          __DRIdrawable *dPriv,
          unsigned flags,
          enum __DRI2throttleReason reason)
{
   struct dri_context *ctx = dri_context(cPriv);
   struct dri_drawable *drawable = dri_drawable(dPriv);
   unsigned flush_flags;
   boolean swap_msaa_buffers = FALSE;
d652 1
a652 4
   if (!ctx) {
      assert(0);
      return;
   }
d654 5
a658 27
   if (drawable) {
      /* prevent recursion */
      if (drawable->flushing)
         return;

      drawable->flushing = TRUE;
   }
   else {
      flags &= ~__DRI2_FLUSH_DRAWABLE;
   }

   /* Flush the drawable. */
   if ((flags & __DRI2_FLUSH_DRAWABLE) &&
       drawable->textures[ST_ATTACHMENT_BACK_LEFT]) {
      struct pipe_context *pipe = ctx->st->pipe;

      if (drawable->stvis.samples > 1 &&
          reason == __DRI2_THROTTLE_SWAPBUFFER) {
         /* Resolve the MSAA back buffer. */
         dri_pipe_blit(ctx->st->pipe,
                       drawable->textures[ST_ATTACHMENT_BACK_LEFT],
                       drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT]);

         if (drawable->msaa_textures[ST_ATTACHMENT_FRONT_LEFT] &&
             drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT]) {
            swap_msaa_buffers = TRUE;
         }
d660 1
a660 2
         /* FRONT_LEFT is resolved in drawable->flush_frontbuffer. */
      }
d662 1
a662 1
      dri_postprocessing(ctx, drawable, ST_ATTACHMENT_BACK_LEFT);
d664 2
a665 3
      if (ctx->hud) {
         hud_draw(ctx->hud, drawable->textures[ST_ATTACHMENT_BACK_LEFT]);
      }
d667 1
a667 1
      pipe->flush_resource(pipe, drawable->textures[ST_ATTACHMENT_BACK_LEFT]);
d670 1
a670 23
   flush_flags = 0;
   if (flags & __DRI2_FLUSH_CONTEXT)
      flush_flags |= ST_FLUSH_FRONT;
   if (reason == __DRI2_THROTTLE_SWAPBUFFER)
      flush_flags |= ST_FLUSH_END_OF_FRAME;

   /* Flush the context and throttle if needed. */
   if (dri_screen(ctx->sPriv)->throttling_enabled &&
       drawable &&
       (reason == __DRI2_THROTTLE_SWAPBUFFER ||
        reason == __DRI2_THROTTLE_FLUSHFRONT)) {
      /* Throttle.
       *
       * This pulls a fence off the throttling queue and waits for it if the
       * number of fences on the throttling queue has reached the desired
       * number.
       *
       * Then flushes to insert a fence at the current rendering position, and
       * pushes that fence on the queue. This requires that the st_context_iface
       * flush method returns a fence even if there are no commands to flush.
       */
      struct pipe_screen *screen = drawable->screen->base.screen;
      struct pipe_fence_handle *fence;
d672 6
a677 5
      fence = swap_fences_pop_front(drawable);
      if (fence) {
         (void) screen->fence_finish(screen, fence, PIPE_TIMEOUT_INFINITE);
         screen->fence_reference(screen, &fence, NULL);
      }
d679 3
a681 1
      ctx->st->flush(ctx->st, flush_flags, &fence);
d683 6
a688 8
      if (fence) {
         swap_fences_push_back(drawable, fence);
         screen->fence_reference(screen, &fence, NULL);
      }
   }
   else if (flags & (__DRI2_FLUSH_DRAWABLE | __DRI2_FLUSH_CONTEXT)) {
      ctx->st->flush(ctx->st, flush_flags, NULL);
   }
d690 2
a691 3
   if (drawable) {
      drawable->flushing = FALSE;
   }
d693 2
a694 3
   /* Swap the MSAA front and back buffers, so that reading
    * from the front buffer after SwapBuffers returns what was
    * in the back buffer.
d696 31
a726 12
   if (swap_msaa_buffers) {
      struct pipe_resource *tmp =
         drawable->msaa_textures[ST_ATTACHMENT_FRONT_LEFT];

      drawable->msaa_textures[ST_ATTACHMENT_FRONT_LEFT] =
         drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT];
      drawable->msaa_textures[ST_ATTACHMENT_BACK_LEFT] = tmp;

      /* Now that we have swapped the buffers, this tells the state
       * tracker to revalidate the framebuffer.
       */
      p_atomic_inc(&drawable->base.stamp);
d730 2
a731 6
/**
 * dri_throttle - A DRI2ThrottleExtension throttling function.
 */
static void
dri_throttle(__DRIcontext *cPriv, __DRIdrawable *dPriv,
             enum __DRI2throttleReason reason)
d733 7
a739 2
   dri_flush(cPriv, dPriv, 0, reason);
}
d741 1
d743 2
a744 2
const __DRI2throttleExtension dri2ThrottleExtension = {
    .base = { __DRI2_THROTTLE, 1 },
d746 1
a746 2
    .throttle          = dri_throttle,
};
d748 12
@


