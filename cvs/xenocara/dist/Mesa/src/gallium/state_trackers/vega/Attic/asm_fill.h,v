head	1.3;
access;
symbols
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.14
	OPENBSD_5_7_BASE:1.2
	v10_2_9:1.1.1.1
	v10_4_3:1.1.1.1
	v10_2_7:1.1.1.1
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	v10_2_3:1.1.1.1
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.2;
commitid	TnlogFl9nOv2eaRf;

1.2
date	2011.10.23.13.37.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#ifndef ASM_FILL_H
#define ASM_FILL_H

#include "tgsi/tgsi_ureg.h"

typedef void (* ureg_func)( struct ureg_program *ureg,
                            struct ureg_dst *out,
                            struct ureg_src *in,
                            struct ureg_src *sampler,
                            struct ureg_dst *temp,
                            struct ureg_src *constant);

static INLINE void
solid_fill( struct ureg_program *ureg,
            struct ureg_dst *out,
            struct ureg_src *in,
            struct ureg_src *sampler,
            struct ureg_dst *temp,
            struct ureg_src *constant)
{
   ureg_MOV(ureg, *out, constant[2]);
}

/**
 * Perform frag-coord-to-paint-coord transform.  The transformation is in
 * CONST[4..6].
 */
#define PAINT_TRANSFORM                                                 \
   ureg_MOV(ureg, ureg_writemask(temp[0], TGSI_WRITEMASK_XY), in[0]);   \
   ureg_MOV(ureg,                                                       \
            ureg_writemask(temp[0], TGSI_WRITEMASK_Z),                  \
            ureg_scalar(constant[3], TGSI_SWIZZLE_Y));                  \
   ureg_DP3(ureg, temp[1], constant[4], ureg_src(temp[0]));             \
   ureg_DP3(ureg, temp[2], constant[5], ureg_src(temp[0]));             \
   ureg_DP3(ureg, temp[3], constant[6], ureg_src(temp[0]));             \
   ureg_RCP(ureg, temp[3], ureg_src(temp[3]));                          \
   ureg_MUL(ureg, temp[1], ureg_src(temp[1]), ureg_src(temp[3]));       \
   ureg_MUL(ureg, temp[2], ureg_src(temp[2]), ureg_src(temp[3]));       \
   ureg_MOV(ureg,                                                       \
            ureg_writemask(temp[4], TGSI_WRITEMASK_X),                  \
            ureg_src(temp[1]));                                         \
   ureg_MOV(ureg,                                                       \
            ureg_writemask(temp[4], TGSI_WRITEMASK_Y),                  \
            ureg_src(temp[2]));

static INLINE void
linear_grad( struct ureg_program *ureg,
             struct ureg_dst *out,
             struct ureg_src *in,
             struct ureg_src *sampler,
             struct ureg_dst *temp,
             struct ureg_src *constant)
{
   PAINT_TRANSFORM

   /* grad = DP2((x, y), CONST[2].xy) * CONST[2].z */
   ureg_MUL(ureg, temp[0],
            ureg_scalar(constant[2], TGSI_SWIZZLE_Y),
            ureg_scalar(ureg_src(temp[4]), TGSI_SWIZZLE_Y));
   ureg_MAD(ureg, temp[1],
            ureg_scalar(constant[2], TGSI_SWIZZLE_X),
            ureg_scalar(ureg_src(temp[4]), TGSI_SWIZZLE_X),
            ureg_src(temp[0]));
   ureg_MUL(ureg, temp[2], ureg_src(temp[1]),
            ureg_scalar(constant[2], TGSI_SWIZZLE_Z));

   ureg_TEX(ureg, *out, TGSI_TEXTURE_1D, ureg_src(temp[2]), sampler[0]);
}

static INLINE void
radial_grad( struct ureg_program *ureg,
             struct ureg_dst *out,
             struct ureg_src *in,
             struct ureg_src *sampler,
             struct ureg_dst *temp,
             struct ureg_src *constant)
{
   PAINT_TRANSFORM

   /*
    * Calculate (sqrt(B^2 + AC) - B) / A, where
    *
    *   A is CONST[2].z,
    *   B is DP2((x, y), CONST[2].xy), and
    *   C is DP2((x, y), (x, y)).
    */

   /* B and C */
   ureg_DP2(ureg, temp[0], ureg_src(temp[4]), constant[2]);
   ureg_DP2(ureg, temp[1], ureg_src(temp[4]), ureg_src(temp[4]));

   /* the square root */
   ureg_MUL(ureg, temp[2], ureg_src(temp[0]), ureg_src(temp[0]));
   ureg_MAD(ureg, temp[3], ureg_src(temp[1]),
         ureg_scalar(constant[2], TGSI_SWIZZLE_Z), ureg_src(temp[2]));
   ureg_RSQ(ureg, temp[3], ureg_src(temp[3]));
   ureg_RCP(ureg, temp[3], ureg_src(temp[3]));

   ureg_SUB(ureg, temp[3], ureg_src(temp[3]), ureg_src(temp[0]));
   ureg_RCP(ureg, temp[0], ureg_scalar(constant[2], TGSI_SWIZZLE_Z));
   ureg_MUL(ureg, temp[0], ureg_src(temp[0]), ureg_src(temp[3]));

   ureg_TEX(ureg, *out, TGSI_TEXTURE_1D, ureg_src(temp[0]), sampler[0]);
}


static INLINE void
pattern( struct ureg_program *ureg,
         struct ureg_dst     *out,
         struct ureg_src     *in,
         struct ureg_src     *sampler,
         struct ureg_dst     *temp,
         struct ureg_src     *constant)
{
   PAINT_TRANSFORM

   /* (s, t) = (x / tex_width, y / tex_height) */
   ureg_RCP(ureg, temp[0],
            ureg_swizzle(constant[3],
                         TGSI_SWIZZLE_Z,
                         TGSI_SWIZZLE_W,
                         TGSI_SWIZZLE_Z,
                         TGSI_SWIZZLE_W));
   ureg_MOV(ureg, temp[1], ureg_src(temp[4]));
   ureg_MUL(ureg,
            ureg_writemask(temp[1], TGSI_WRITEMASK_X),
            ureg_src(temp[1]),
            ureg_src(temp[0]));
   ureg_MUL(ureg,
            ureg_writemask(temp[1], TGSI_WRITEMASK_Y),
            ureg_src(temp[1]),
            ureg_src(temp[0]));

   ureg_TEX(ureg, *out, TGSI_TEXTURE_2D, ureg_src(temp[1]), sampler[0]);
}

static INLINE void
paint_degenerate( struct ureg_program *ureg,
                  struct ureg_dst *out,
                  struct ureg_src *in,
                  struct ureg_src *sampler,
                  struct ureg_dst *temp,
                  struct ureg_src *constant)
{
   /* CONST[3].y is 1.0f */
   ureg_MOV(ureg, temp[1], ureg_scalar(constant[3], TGSI_SWIZZLE_Y));
   ureg_TEX(ureg, *out, TGSI_TEXTURE_1D, ureg_src(temp[1]), sampler[0]);
}

static INLINE void
image_normal( struct ureg_program *ureg,
              struct ureg_dst *out,
              struct ureg_src *in,
              struct ureg_src *sampler,
              struct ureg_dst *temp,
              struct ureg_src *constant)
{
   /* store and pass image color in TEMP[1] */
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[1], sampler[3]);
   ureg_MOV(ureg, *out, ureg_src(temp[1]));
}


static INLINE void
image_multiply( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   /* store and pass image color in TEMP[1] */
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[1], sampler[3]);
   ureg_MUL(ureg, *out, ureg_src(temp[0]), ureg_src(temp[1]));
}


static INLINE void
image_stencil( struct ureg_program *ureg,
               struct ureg_dst *out,
               struct ureg_src *in,
               struct ureg_src *sampler,
               struct ureg_dst *temp,
               struct ureg_src *constant)
{
   /* store and pass image color in TEMP[1] */
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[1], sampler[3]);
   ureg_MOV(ureg, *out, ureg_src(temp[0]));
}

static INLINE void
color_transform( struct ureg_program *ureg,
                 struct ureg_dst *out,
                 struct ureg_src *in,
                 struct ureg_src *sampler,
                 struct ureg_dst *temp,
                 struct ureg_src *constant)
{
   /* note that TEMP[1] may already be used for image color */

   ureg_MAD(ureg, temp[2], ureg_src(temp[0]), constant[0], constant[1]);
   /* clamp to [0.0f, 1.0f] */
   ureg_CLAMP(ureg, temp[2],
              ureg_src(temp[2]),
              ureg_scalar(constant[3], TGSI_SWIZZLE_X),
              ureg_scalar(constant[3], TGSI_SWIZZLE_Y));
   ureg_MOV(ureg, *out, ureg_src(temp[2]));
}

static INLINE void
alpha_normal( struct ureg_program *ureg,
              struct ureg_dst *out,
              struct ureg_src *in,
              struct ureg_src *sampler,
              struct ureg_dst *temp,
              struct ureg_src *constant)
{
   /* save per-channel alpha in TEMP[1] */
   ureg_MOV(ureg, temp[1], ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W));

   ureg_MOV(ureg, *out, ureg_src(temp[0]));
}

static INLINE void
alpha_per_channel( struct ureg_program *ureg,
                   struct ureg_dst *out,
                   struct ureg_src *in,
                   struct ureg_src *sampler,
                   struct ureg_dst *temp,
                   struct ureg_src *constant)
{
   /* save per-channel alpha in TEMP[1] */
   ureg_MUL(ureg,
            ureg_writemask(temp[1], TGSI_WRITEMASK_W),
            ureg_src(temp[0]),
            ureg_src(temp[1]));
   ureg_MUL(ureg,
            ureg_writemask(temp[1], TGSI_WRITEMASK_XYZ),
            ureg_src(temp[1]),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));

   /* update alpha */
   ureg_MOV(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_W),
            ureg_src(temp[1]));
   ureg_MOV(ureg, *out, ureg_src(temp[0]));
}

/**
 * Premultiply src and dst.
 */
static INLINE void
blend_premultiply( struct ureg_program *ureg,
                   struct ureg_src src,
                   struct ureg_src src_channel_alpha,
                   struct ureg_src dst)
{
   /* premultiply src */
   ureg_MUL(ureg,
            ureg_writemask(ureg_dst(src), TGSI_WRITEMASK_XYZ),
            src,
            src_channel_alpha);
   /* premultiply dst */
   ureg_MUL(ureg,
            ureg_writemask(ureg_dst(dst), TGSI_WRITEMASK_XYZ),
            dst,
            ureg_scalar(dst, TGSI_SWIZZLE_W));
}

/**
 * Unpremultiply src.
 */
static INLINE void
blend_unpremultiply( struct ureg_program *ureg,
                     struct ureg_src src,
                     struct ureg_src one,
                     struct ureg_dst temp[1])
{
   /* replace 0.0f by 1.0f before calculating reciprocal */
   ureg_CMP(ureg,
            temp[0],
            ureg_negate(ureg_scalar(src, TGSI_SWIZZLE_W)),
            ureg_scalar(src, TGSI_SWIZZLE_W),
            one);
   ureg_RCP(ureg, temp[0], ureg_src(temp[0]));

   ureg_MUL(ureg,
            ureg_writemask(ureg_dst(src), TGSI_WRITEMASK_XYZ),
            src,
            ureg_src(temp[0]));
}

/**
 * Emit instructions for the specified blend mode.  Colors will be
 * unpremultiplied.  Two temporary registers are required.
 *
 * The output is written back to src.
 */
static INLINE void
blend_generic(struct ureg_program *ureg,
              VGBlendMode mode,
              struct ureg_src src,
              struct ureg_src src_channel_alpha,
              struct ureg_src dst,
              struct ureg_src one,
              struct ureg_dst temp[2])
{
   struct ureg_dst out;

   blend_premultiply(ureg, src, src_channel_alpha, dst);

   /* blend in-place */
   out = ureg_dst(src);

   switch (mode) {
   case VG_BLEND_SRC:
      ureg_MOV(ureg, out, src);
      break;
   case VG_BLEND_SRC_OVER:
      /* RGBA_out = RGBA_src + (1 - A_src) * RGBA_dst */
      ureg_SUB(ureg, temp[0], one, src_channel_alpha);
      ureg_MAD(ureg, out, ureg_src(temp[0]), dst, src);
      break;
   case VG_BLEND_DST_OVER:
      /* RGBA_out = RGBA_dst + (1 - A_dst) * RGBA_src */
      ureg_SUB(ureg, temp[0], one, ureg_scalar(dst, TGSI_SWIZZLE_W));
      ureg_MAD(ureg, out, ureg_src(temp[0]), src, dst);
      break;
   case VG_BLEND_SRC_IN:
      ureg_MUL(ureg, out, src, ureg_scalar(dst, TGSI_SWIZZLE_W));
      break;
   case VG_BLEND_DST_IN:
      ureg_MUL(ureg, out, dst, src_channel_alpha);
      break;
   case VG_BLEND_MULTIPLY:
      /*
       * RGB_out = (1 - A_dst) * RGB_src + (1 - A_src) * RGB_dst +
       *           RGB_src * RGB_dst
       */
      ureg_MAD(ureg, temp[0],
            ureg_scalar(dst, TGSI_SWIZZLE_W), ureg_negate(src), src);
      ureg_MAD(ureg, temp[1],
            src_channel_alpha, ureg_negate(dst), dst);
      ureg_MAD(ureg, temp[0], src, dst, ureg_src(temp[0]));
      ureg_ADD(ureg, out, ureg_src(temp[0]), ureg_src(temp[1]));
      /* alpha is src over */
      ureg_ADD(ureg, ureg_writemask(out, TGSI_WRITEMASK_W),
            src, ureg_src(temp[1]));
      break;
   case VG_BLEND_SCREEN:
      /* RGBA_out = RGBA_src + (1 - RGBA_src) * RGBA_dst */
      ureg_SUB(ureg, temp[0], one, src);
      ureg_MAD(ureg, out, ureg_src(temp[0]), dst, src);
      break;
   case VG_BLEND_DARKEN:
   case VG_BLEND_LIGHTEN:
      /* src over */
      ureg_SUB(ureg, temp[0], one, src_channel_alpha);
      ureg_MAD(ureg, temp[0], ureg_src(temp[0]), dst, src);
      /* dst over */
      ureg_SUB(ureg, temp[1], one, ureg_scalar(dst, TGSI_SWIZZLE_W));
      ureg_MAD(ureg, temp[1], ureg_src(temp[1]), src, dst);
      /* take min/max for colors */
      if (mode == VG_BLEND_DARKEN) {
         ureg_MIN(ureg, ureg_writemask(out, TGSI_WRITEMASK_XYZ),
               ureg_src(temp[0]), ureg_src(temp[1]));
      }
      else {
         ureg_MAX(ureg, ureg_writemask(out, TGSI_WRITEMASK_XYZ),
               ureg_src(temp[0]), ureg_src(temp[1]));
      }
      break;
   case VG_BLEND_ADDITIVE:
      /* RGBA_out = RGBA_src + RGBA_dst */
      ureg_ADD(ureg, temp[0], src, dst);
      ureg_MIN(ureg, out, ureg_src(temp[0]), one);
      break;
   default:
      assert(0);
      break;
   }

   blend_unpremultiply(ureg, src, one, temp);
}

#define BLEND_GENERIC(mode) \
   do { \
      ureg_TEX(ureg, temp[2], TGSI_TEXTURE_2D, in[0], sampler[2]);         \
      blend_generic(ureg, (mode), ureg_src(temp[0]), ureg_src(temp[1]),    \
                    ureg_src(temp[2]),                                     \
                    ureg_scalar(constant[3], TGSI_SWIZZLE_Y), temp + 3);   \
      ureg_MOV(ureg, *out, ureg_src(temp[0]));                             \
   } while (0)

static INLINE void
blend_src( struct ureg_program *ureg,
           struct ureg_dst *out,
           struct ureg_src *in,
           struct ureg_src *sampler,
           struct ureg_dst *temp,
           struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_SRC);
}

static INLINE void
blend_src_over( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_SRC_OVER);
}

static INLINE void
blend_dst_over( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_DST_OVER);
}

static INLINE void
blend_src_in( struct ureg_program *ureg,
              struct ureg_dst *out,
              struct ureg_src *in,
              struct ureg_src *sampler,
              struct ureg_dst *temp,
              struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_SRC_IN);
}

static INLINE void
blend_dst_in( struct ureg_program *ureg,
              struct ureg_dst *out,
              struct ureg_src *in,
              struct ureg_src *sampler,
              struct ureg_dst *temp,
              struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_DST_IN);
}

static INLINE void
blend_multiply( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_MULTIPLY);
}

static INLINE void
blend_screen( struct ureg_program *ureg,
              struct ureg_dst     *out,
              struct ureg_src     *in,
              struct ureg_src     *sampler,
              struct ureg_dst     *temp,
              struct ureg_src     *constant)
{
   BLEND_GENERIC(VG_BLEND_SCREEN);
}

static INLINE void
blend_darken( struct ureg_program *ureg,
              struct ureg_dst     *out,
              struct ureg_src     *in,
              struct ureg_src     *sampler,
              struct ureg_dst     *temp,
              struct ureg_src     *constant)
{
   BLEND_GENERIC(VG_BLEND_DARKEN);
}

static INLINE void
blend_lighten( struct ureg_program *ureg,
               struct ureg_dst     *out,
               struct ureg_src     *in,
               struct ureg_src     *sampler,
               struct ureg_dst *temp,
               struct ureg_src     *constant)
{
   BLEND_GENERIC(VG_BLEND_LIGHTEN);
}

static INLINE void
blend_additive( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_ADDITIVE);
}

static INLINE void
mask( struct ureg_program *ureg,
      struct ureg_dst *out,
      struct ureg_src *in,
      struct ureg_src *sampler,
      struct ureg_dst *temp,
      struct ureg_src *constant)
{
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[0], sampler[1]);
   ureg_MUL(ureg, ureg_writemask(temp[0], TGSI_WRITEMASK_W),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_MOV(ureg, *out, ureg_src(temp[0]));
}

static INLINE void
premultiply( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   ureg_MUL(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_XYZ),
            ureg_src(temp[0]),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W));
}

static INLINE void
unpremultiply( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   ureg_TEX(ureg, temp[0], TGSI_TEXTURE_2D, in[0], sampler[1]);
}


static INLINE void
color_bw( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   ureg_ADD(ureg, temp[1],
            ureg_scalar(constant[3], TGSI_SWIZZLE_Y),
            ureg_scalar(constant[3], TGSI_SWIZZLE_Y));
   ureg_RCP(ureg, temp[2], ureg_src(temp[1]));
   ureg_ADD(ureg, temp[1],
            ureg_scalar(constant[3], TGSI_SWIZZLE_Y),
            ureg_src(temp[2]));
   ureg_ADD(ureg, ureg_writemask(temp[2], TGSI_WRITEMASK_X),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_X),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_Y));
   ureg_ADD(ureg, ureg_writemask(temp[2], TGSI_WRITEMASK_X),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_Z),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_X));
   ureg_SGE(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_XYZ),
            ureg_scalar(ureg_src(temp[2]), TGSI_SWIZZLE_X),
            ureg_src(temp[1]));
  ureg_SGE(ureg,
           ureg_writemask(temp[0], TGSI_WRITEMASK_W),
           ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
           ureg_scalar(ureg_src(temp[2]), TGSI_SWIZZLE_Y));
  ureg_MOV(ureg, *out, ureg_src(temp[0]));
}


struct shader_asm_info {
   VGint id;
   ureg_func func;

   VGboolean needs_position;

   VGint start_const;
   VGint num_consts;

   VGint start_sampler;
   VGint num_samplers;

   VGint start_temp;
   VGint num_temps;
};


/* paint types */
static const struct shader_asm_info shaders_paint_asm[] = {
   {VEGA_SOLID_FILL_SHADER, solid_fill,
    VG_FALSE, 2, 1, 0, 0, 0, 0},
   {VEGA_LINEAR_GRADIENT_SHADER, linear_grad,
    VG_TRUE,  2, 5, 0, 1, 0, 5},
   {VEGA_RADIAL_GRADIENT_SHADER, radial_grad,
    VG_TRUE,  2, 5, 0, 1, 0, 5},
   {VEGA_PATTERN_SHADER, pattern,
    VG_TRUE,  3, 4, 0, 1, 0, 5},
   {VEGA_PAINT_DEGENERATE_SHADER, paint_degenerate,
    VG_FALSE,  3, 1, 0, 1, 0, 2}
};

/* image draw modes */
static const struct shader_asm_info shaders_image_asm[] = {
   {VEGA_IMAGE_NORMAL_SHADER, image_normal,
    VG_TRUE,  0, 0, 3, 1, 0, 2},
   {VEGA_IMAGE_MULTIPLY_SHADER, image_multiply,
    VG_TRUE,  0, 0, 3, 1, 0, 2},
   {VEGA_IMAGE_STENCIL_SHADER, image_stencil,
    VG_TRUE,  0, 0, 3, 1, 0, 2}
};

static const struct shader_asm_info shaders_color_transform_asm[] = {
   {VEGA_COLOR_TRANSFORM_SHADER, color_transform,
    VG_FALSE, 0, 4, 0, 0, 0, 3}
};

static const struct shader_asm_info shaders_alpha_asm[] = {
   {VEGA_ALPHA_NORMAL_SHADER, alpha_normal,
    VG_FALSE, 0, 0, 0, 0, 0, 2},
   {VEGA_ALPHA_PER_CHANNEL_SHADER, alpha_per_channel,
    VG_FALSE, 0, 0, 0, 0, 0, 2}
};

/* extra blend modes */
static const struct shader_asm_info shaders_blend_asm[] = {
#define BLEND_ASM_INFO(id, func) { (id), (func), VG_TRUE, 3, 1, 2, 1, 0, 5 }
   BLEND_ASM_INFO(VEGA_BLEND_SRC_SHADER, blend_src),
   BLEND_ASM_INFO(VEGA_BLEND_SRC_OVER_SHADER, blend_src_over),
   BLEND_ASM_INFO(VEGA_BLEND_DST_OVER_SHADER, blend_dst_over),
   BLEND_ASM_INFO(VEGA_BLEND_SRC_IN_SHADER, blend_src_in),
   BLEND_ASM_INFO(VEGA_BLEND_DST_IN_SHADER, blend_dst_in),
   BLEND_ASM_INFO(VEGA_BLEND_MULTIPLY_SHADER, blend_multiply),
   BLEND_ASM_INFO(VEGA_BLEND_SCREEN_SHADER, blend_screen),
   BLEND_ASM_INFO(VEGA_BLEND_DARKEN_SHADER, blend_darken),
   BLEND_ASM_INFO(VEGA_BLEND_LIGHTEN_SHADER, blend_lighten),
   BLEND_ASM_INFO(VEGA_BLEND_ADDITIVE_SHADER, blend_additive)
#undef BLEND_ASM_INFO
};

static const struct shader_asm_info shaders_mask_asm[] = {
   {VEGA_MASK_SHADER, mask,
    VG_TRUE,  0, 0, 1, 1, 0, 2}
};

/* premultiply */
static const struct shader_asm_info shaders_premultiply_asm[] = {
   {VEGA_PREMULTIPLY_SHADER, premultiply,
    VG_FALSE,  0, 0, 0, 0, 0, 1},
   {VEGA_UNPREMULTIPLY_SHADER, unpremultiply,
    VG_FALSE,  0, 0, 0, 0, 0, 1},
};

/* color transform to black and white */
static const struct shader_asm_info shaders_bw_asm[] = {
   {VEGA_BW_SHADER, color_bw,
    VG_FALSE,  3, 1, 0, 0, 0, 3},
};

#endif
@


1.2
log
@Merge Mesa 7.10.3
@
text
@@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d47 1
a47 1
   ureg_MOV(ureg, *out, constant[0]);
d50 22
d80 1
d82 1
a82 14
   ureg_MOV(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_XY),
            in[0]);
   ureg_MOV(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_Z),
            ureg_scalar(constant[1], TGSI_SWIZZLE_Y));
   ureg_DP3(ureg, temp[1], constant[2], ureg_src(temp[0]));
   ureg_DP3(ureg, temp[2], constant[3], ureg_src(temp[0]));
   ureg_DP3(ureg, temp[3], constant[4], ureg_src(temp[0]));
   ureg_RCP(ureg, temp[3], ureg_src(temp[3]));
   ureg_MUL(ureg, temp[1], ureg_src(temp[1]), ureg_src(temp[3]));
   ureg_MUL(ureg, temp[2], ureg_src(temp[2]), ureg_src(temp[3]));
   ureg_MOV(ureg, ureg_writemask(temp[4], TGSI_WRITEMASK_X), ureg_src(temp[1]));
   ureg_MOV(ureg, ureg_writemask(temp[4], TGSI_WRITEMASK_Y), ureg_src(temp[2]));
d84 1
a84 1
            ureg_scalar(constant[0], TGSI_SWIZZLE_Y),
d87 1
a87 1
            ureg_scalar(constant[0], TGSI_SWIZZLE_X),
d91 2
a92 1
            ureg_scalar(constant[0], TGSI_SWIZZLE_Z));
d104 1
d106 17
a122 7
   ureg_MOV(ureg, ureg_writemask(temp[0], TGSI_WRITEMASK_XY), in[0]);
   ureg_MOV(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_Z),
            ureg_scalar(constant[1], TGSI_SWIZZLE_Y));
   ureg_DP3(ureg, temp[1], constant[2], ureg_src(temp[0]));
   ureg_DP3(ureg, temp[2], constant[3], ureg_src(temp[0]));
   ureg_DP3(ureg, temp[3], constant[4], ureg_src(temp[0]));
a123 25
   ureg_MUL(ureg, temp[1], ureg_src(temp[1]), ureg_src(temp[3]));
   ureg_MUL(ureg, temp[2], ureg_src(temp[2]), ureg_src(temp[3]));
   ureg_MOV(ureg, ureg_writemask(temp[5], TGSI_WRITEMASK_X), ureg_src(temp[1]));
   ureg_MOV(ureg, ureg_writemask(temp[5], TGSI_WRITEMASK_Y), ureg_src(temp[2]));
   ureg_MUL(ureg, temp[0], ureg_scalar(constant[0], TGSI_SWIZZLE_Y),
            ureg_scalar(ureg_src(temp[5]), TGSI_SWIZZLE_Y));
   ureg_MAD(ureg, temp[1],
            ureg_scalar(constant[0], TGSI_SWIZZLE_X),
            ureg_scalar(ureg_src(temp[5]), TGSI_SWIZZLE_X), ureg_src(temp[0]));
   ureg_ADD(ureg, temp[1], ureg_src(temp[1]), ureg_src(temp[1]));
   ureg_MUL(ureg, temp[3],
            ureg_scalar(ureg_src(temp[5]), TGSI_SWIZZLE_Y),
            ureg_scalar(ureg_src(temp[5]), TGSI_SWIZZLE_Y));
   ureg_MAD(ureg, temp[4],
            ureg_scalar(ureg_src(temp[5]), TGSI_SWIZZLE_X),
            ureg_scalar(ureg_src(temp[5]), TGSI_SWIZZLE_X),
            ureg_src(temp[3]));
   ureg_MOV(ureg, temp[4], ureg_negate(ureg_src(temp[4])));
   ureg_MUL(ureg, temp[2],
            ureg_scalar(constant[0], TGSI_SWIZZLE_Z),
            ureg_src(temp[4]));
   ureg_MUL(ureg, temp[0],
            ureg_scalar(constant[1], TGSI_SWIZZLE_W),
            ureg_src(temp[2]));
   ureg_MUL(ureg, temp[3], ureg_src(temp[1]), ureg_src(temp[1]));
d125 3
a127 10
   ureg_SUB(ureg, temp[2], ureg_src(temp[3]), ureg_src(temp[0]));
   ureg_RSQ(ureg, temp[2], ureg_abs(ureg_src(temp[2])));
   ureg_RCP(ureg, temp[2], ureg_src(temp[2]));
   ureg_SUB(ureg, temp[1], ureg_src(temp[2]), ureg_src(temp[1]));
   ureg_ADD(ureg, temp[0],
            ureg_scalar(constant[0], TGSI_SWIZZLE_Z),
            ureg_scalar(constant[0], TGSI_SWIZZLE_Z));
   ureg_RCP(ureg, temp[0], ureg_src(temp[0]));
   ureg_MUL(ureg, temp[2], ureg_src(temp[1]), ureg_src(temp[0]));
   ureg_TEX(ureg, *out, TGSI_TEXTURE_1D, ureg_src(temp[2]), sampler[0]);
d129 1
d141 3
a143 14
   ureg_MOV(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_XY),
            in[0]);
   ureg_MOV(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_Z),
            ureg_scalar(constant[1], TGSI_SWIZZLE_Y));
   ureg_DP3(ureg, temp[1], constant[2], ureg_src(temp[0]));
   ureg_DP3(ureg, temp[2], constant[3], ureg_src(temp[0]));
   ureg_DP3(ureg, temp[3], constant[4], ureg_src(temp[0]));
   ureg_RCP(ureg, temp[3], ureg_src(temp[3]));
   ureg_MUL(ureg, temp[1], ureg_src(temp[1]), ureg_src(temp[3]));
   ureg_MUL(ureg, temp[2], ureg_src(temp[2]), ureg_src(temp[3]));
   ureg_MOV(ureg, ureg_writemask(temp[4], TGSI_WRITEMASK_X), ureg_src(temp[1]));
   ureg_MOV(ureg, ureg_writemask(temp[4], TGSI_WRITEMASK_Y), ureg_src(temp[2]));
d145 1
a145 1
            ureg_swizzle(constant[1],
d159 1
d164 10
a173 12
mask( struct ureg_program *ureg,
      struct ureg_dst *out,
      struct ureg_src *in,
      struct ureg_src *sampler,
      struct ureg_dst *temp,
      struct ureg_src *constant)
{
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[0], sampler[1]);
   ureg_MUL(ureg, ureg_writemask(temp[0], TGSI_WRITEMASK_W),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_MOV(ureg, *out, ureg_src(temp[0]));
d184 3
a186 1
   ureg_TEX(ureg, *out, TGSI_TEXTURE_2D, in[1], sampler[3]);
d198 1
d212 1
d214 59
a272 1
   ureg_MUL(ureg, *out, ureg_src(temp[0]), ureg_src(temp[1]));
d275 43
a317 10
#define EXTENDED_BLENDER_OVER_FUNC                                      \
   ureg_SUB(ureg, temp[3],                                              \
            ureg_scalar(constant[1], TGSI_SWIZZLE_Y),                   \
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));            \
   ureg_SUB(ureg, temp[3],                                              \
            ureg_scalar(constant[1], TGSI_SWIZZLE_Y),                   \
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W));            \
   ureg_MUL(ureg, temp[3], ureg_src(temp[0]), ureg_src(temp[3]));       \
   ureg_MUL(ureg, temp[4], ureg_src(temp[1]), ureg_src(temp[4]));       \
   ureg_ADD(ureg, temp[3], ureg_src(temp[3]), ureg_src(temp[4]));
d319 123
d444 1
a444 1
blend_multiply( struct ureg_program *ureg,
d451 13
a463 4
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[0], sampler[2]);
   EXTENDED_BLENDER_OVER_FUNC
   ureg_MUL(ureg, temp[4], ureg_src(temp[0]), ureg_src(temp[1]));
   ureg_ADD(ureg, temp[1], ureg_src(temp[4]), ureg_src(temp[3]));
d465 10
a474 6
   ureg_MUL(ureg, temp[2], ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_ADD(ureg, temp[3], ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_SUB(ureg, ureg_writemask(temp[1], TGSI_WRITEMASK_W),
            ureg_src(temp[3]), ureg_src(temp[2]));
d476 9
a484 1
   ureg_MOV(ureg, *out, ureg_src(temp[1]));
d495 1
a495 4
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[0], sampler[2]);
   ureg_ADD(ureg, temp[3], ureg_src(temp[0]), ureg_src(temp[1]));
   ureg_MUL(ureg, temp[2], ureg_src(temp[0]), ureg_src(temp[1]));
   ureg_SUB(ureg, *out, ureg_src(temp[3]), ureg_src(temp[2]));
d506 1
a506 17
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[0], sampler[2]);
   EXTENDED_BLENDER_OVER_FUNC
   ureg_MUL(ureg, temp[4], ureg_src(temp[0]),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_MUL(ureg, temp[5], ureg_src(temp[1]),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W));
   ureg_MIN(ureg, temp[4], ureg_src(temp[4]), ureg_src(temp[5]));
   ureg_ADD(ureg, temp[1], ureg_src(temp[3]), ureg_src(temp[4]));

   ureg_MUL(ureg, temp[2], ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_ADD(ureg, temp[3], ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_SUB(ureg, ureg_writemask(temp[1], TGSI_WRITEMASK_W),
            ureg_src(temp[3]), ureg_src(temp[2]));

   ureg_MOV(ureg, *out, ureg_src(temp[1]));
d517 13
a529 8
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[0], sampler[2]);
   EXTENDED_BLENDER_OVER_FUNC
   ureg_MUL(ureg, temp[4], ureg_src(temp[0]),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_MUL(ureg, temp[5], ureg_src(temp[1]),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W));
   ureg_MAX(ureg, temp[4], ureg_src(temp[4]), ureg_src(temp[5]));
   ureg_ADD(ureg, temp[1], ureg_src(temp[3]), ureg_src(temp[4]));
d531 11
a541 1
   ureg_MUL(ureg, temp[2], ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
d543 1
a543 6
   ureg_ADD(ureg, temp[3], ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_SUB(ureg, ureg_writemask(temp[1], TGSI_WRITEMASK_W),
            ureg_src(temp[3]), ureg_src(temp[2]));

   ureg_MOV(ureg, *out, ureg_src(temp[1]));
d581 2
a582 2
            ureg_scalar(constant[1], TGSI_SWIZZLE_Y),
            ureg_scalar(constant[1], TGSI_SWIZZLE_Y));
d585 1
a585 1
            ureg_scalar(constant[1], TGSI_SWIZZLE_Y),
d622 2
a623 2
static const struct shader_asm_info shaders_asm[] = {
   /* fills */
d625 1
a625 1
    VG_FALSE, 0, 1, 0, 0, 0, 0},
d627 1
a627 1
    VG_TRUE,  0, 5, 0, 1, 0, 5},
d629 1
a629 1
    VG_TRUE,  0, 5, 0, 1, 0, 6},
d631 4
a634 1
    VG_TRUE,  1, 4, 0, 1, 0, 5},
d636 2
a637 1
   /* image draw modes */
d639 1
a639 1
    VG_TRUE,  0, 0, 3, 1, 0, 0},
d643 30
a672 1
    VG_TRUE,  0, 0, 3, 1, 0, 2},
d674 1
d676 2
a677 11
    VG_TRUE,  0, 0, 1, 1, 0, 2},

   /* extra blend modes */
   {VEGA_BLEND_MULTIPLY_SHADER, blend_multiply,
    VG_TRUE,  1, 1, 2, 1, 0, 5},
   {VEGA_BLEND_SCREEN_SHADER, blend_screen,
    VG_TRUE,  0, 0, 2, 1, 0, 4},
   {VEGA_BLEND_DARKEN_SHADER, blend_darken,
    VG_TRUE,  1, 1, 2, 1, 0, 6},
   {VEGA_BLEND_LIGHTEN_SHADER, blend_lighten,
    VG_TRUE,  1, 1, 2, 1, 0, 6},
d679 2
a680 1
   /* premultiply */
d685 1
d687 2
a688 1
   /* color transform to black and white */
d690 1
a690 1
    VG_FALSE,  1, 1, 0, 0, 0, 3},
d692 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d47 1
a47 1
   ureg_MOV(ureg, *out, constant[2]);
a49 22
/**
 * Perform frag-coord-to-paint-coord transform.  The transformation is in
 * CONST[4..6].
 */
#define PAINT_TRANSFORM                                                 \
   ureg_MOV(ureg, ureg_writemask(temp[0], TGSI_WRITEMASK_XY), in[0]);   \
   ureg_MOV(ureg,                                                       \
            ureg_writemask(temp[0], TGSI_WRITEMASK_Z),                  \
            ureg_scalar(constant[3], TGSI_SWIZZLE_Y));                  \
   ureg_DP3(ureg, temp[1], constant[4], ureg_src(temp[0]));             \
   ureg_DP3(ureg, temp[2], constant[5], ureg_src(temp[0]));             \
   ureg_DP3(ureg, temp[3], constant[6], ureg_src(temp[0]));             \
   ureg_RCP(ureg, temp[3], ureg_src(temp[3]));                          \
   ureg_MUL(ureg, temp[1], ureg_src(temp[1]), ureg_src(temp[3]));       \
   ureg_MUL(ureg, temp[2], ureg_src(temp[2]), ureg_src(temp[3]));       \
   ureg_MOV(ureg,                                                       \
            ureg_writemask(temp[4], TGSI_WRITEMASK_X),                  \
            ureg_src(temp[1]));                                         \
   ureg_MOV(ureg,                                                       \
            ureg_writemask(temp[4], TGSI_WRITEMASK_Y),                  \
            ureg_src(temp[2]));

a57 1
   PAINT_TRANSFORM
d59 14
a72 1
   /* grad = DP2((x, y), CONST[2].xy) * CONST[2].z */
d74 1
a74 1
            ureg_scalar(constant[2], TGSI_SWIZZLE_Y),
d77 1
a77 1
            ureg_scalar(constant[2], TGSI_SWIZZLE_X),
d81 1
a81 2
            ureg_scalar(constant[2], TGSI_SWIZZLE_Z));

a92 1
   PAINT_TRANSFORM
d94 7
a100 17
   /*
    * Calculate (sqrt(B^2 + AC) - B) / A, where
    *
    *   A is CONST[2].z,
    *   B is DP2((x, y), CONST[2].xy), and
    *   C is DP2((x, y), (x, y)).
    */

   /* B and C */
   ureg_DP2(ureg, temp[0], ureg_src(temp[4]), constant[2]);
   ureg_DP2(ureg, temp[1], ureg_src(temp[4]), ureg_src(temp[4]));

   /* the square root */
   ureg_MUL(ureg, temp[2], ureg_src(temp[0]), ureg_src(temp[0]));
   ureg_MAD(ureg, temp[3], ureg_src(temp[1]),
         ureg_scalar(constant[2], TGSI_SWIZZLE_Z), ureg_src(temp[2]));
   ureg_RSQ(ureg, temp[3], ureg_src(temp[3]));
d102 25
d128 10
a137 3
   ureg_SUB(ureg, temp[3], ureg_src(temp[3]), ureg_src(temp[0]));
   ureg_RCP(ureg, temp[0], ureg_scalar(constant[2], TGSI_SWIZZLE_Z));
   ureg_MUL(ureg, temp[0], ureg_src(temp[0]), ureg_src(temp[3]));
a138 1
   ureg_TEX(ureg, *out, TGSI_TEXTURE_1D, ureg_src(temp[0]), sampler[0]);
d150 14
a163 3
   PAINT_TRANSFORM

   /* (s, t) = (x / tex_width, y / tex_height) */
d165 1
a165 1
            ureg_swizzle(constant[3],
a178 1

d183 12
a194 10
paint_degenerate( struct ureg_program *ureg,
                  struct ureg_dst *out,
                  struct ureg_src *in,
                  struct ureg_src *sampler,
                  struct ureg_dst *temp,
                  struct ureg_src *constant)
{
   /* CONST[3].y is 1.0f */
   ureg_MOV(ureg, temp[1], ureg_scalar(constant[3], TGSI_SWIZZLE_Y));
   ureg_TEX(ureg, *out, TGSI_TEXTURE_1D, ureg_src(temp[1]), sampler[0]);
d205 1
a205 3
   /* store and pass image color in TEMP[1] */
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[1], sampler[3]);
   ureg_MOV(ureg, *out, ureg_src(temp[1]));
a216 1
   /* store and pass image color in TEMP[1] */
a229 1
   /* store and pass image color in TEMP[1] */
d231 1
a231 1
   ureg_MOV(ureg, *out, ureg_src(temp[0]));
d234 10
a243 18
static INLINE void
color_transform( struct ureg_program *ureg,
                 struct ureg_dst *out,
                 struct ureg_src *in,
                 struct ureg_src *sampler,
                 struct ureg_dst *temp,
                 struct ureg_src *constant)
{
   /* note that TEMP[1] may already be used for image color */

   ureg_MAD(ureg, temp[2], ureg_src(temp[0]), constant[0], constant[1]);
   /* clamp to [0.0f, 1.0f] */
   ureg_CLAMP(ureg, temp[2],
              ureg_src(temp[2]),
              ureg_scalar(constant[3], TGSI_SWIZZLE_X),
              ureg_scalar(constant[3], TGSI_SWIZZLE_Y));
   ureg_MOV(ureg, *out, ureg_src(temp[2]));
}
a244 13
static INLINE void
alpha_normal( struct ureg_program *ureg,
              struct ureg_dst *out,
              struct ureg_src *in,
              struct ureg_src *sampler,
              struct ureg_dst *temp,
              struct ureg_src *constant)
{
   /* save per-channel alpha in TEMP[1] */
   ureg_MOV(ureg, temp[1], ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W));

   ureg_MOV(ureg, *out, ureg_src(temp[0]));
}
d247 1
a247 183
alpha_per_channel( struct ureg_program *ureg,
                   struct ureg_dst *out,
                   struct ureg_src *in,
                   struct ureg_src *sampler,
                   struct ureg_dst *temp,
                   struct ureg_src *constant)
{
   /* save per-channel alpha in TEMP[1] */
   ureg_MUL(ureg,
            ureg_writemask(temp[1], TGSI_WRITEMASK_W),
            ureg_src(temp[0]),
            ureg_src(temp[1]));
   ureg_MUL(ureg,
            ureg_writemask(temp[1], TGSI_WRITEMASK_XYZ),
            ureg_src(temp[1]),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));

   /* update alpha */
   ureg_MOV(ureg,
            ureg_writemask(temp[0], TGSI_WRITEMASK_W),
            ureg_src(temp[1]));
   ureg_MOV(ureg, *out, ureg_src(temp[0]));
}

/**
 * Premultiply src and dst.
 */
static INLINE void
blend_premultiply( struct ureg_program *ureg,
                   struct ureg_src src,
                   struct ureg_src src_channel_alpha,
                   struct ureg_src dst)
{
   /* premultiply src */
   ureg_MUL(ureg,
            ureg_writemask(ureg_dst(src), TGSI_WRITEMASK_XYZ),
            src,
            src_channel_alpha);
   /* premultiply dst */
   ureg_MUL(ureg,
            ureg_writemask(ureg_dst(dst), TGSI_WRITEMASK_XYZ),
            dst,
            ureg_scalar(dst, TGSI_SWIZZLE_W));
}

/**
 * Unpremultiply src.
 */
static INLINE void
blend_unpremultiply( struct ureg_program *ureg,
                     struct ureg_src src,
                     struct ureg_src one,
                     struct ureg_dst temp[1])
{
   /* replace 0.0f by 1.0f before calculating reciprocal */
   ureg_CMP(ureg,
            temp[0],
            ureg_negate(ureg_scalar(src, TGSI_SWIZZLE_W)),
            ureg_scalar(src, TGSI_SWIZZLE_W),
            one);
   ureg_RCP(ureg, temp[0], ureg_src(temp[0]));

   ureg_MUL(ureg,
            ureg_writemask(ureg_dst(src), TGSI_WRITEMASK_XYZ),
            src,
            ureg_src(temp[0]));
}

/**
 * Emit instructions for the specified blend mode.  Colors will be
 * unpremultiplied.  Two temporary registers are required.
 *
 * The output is written back to src.
 */
static INLINE void
blend_generic(struct ureg_program *ureg,
              VGBlendMode mode,
              struct ureg_src src,
              struct ureg_src src_channel_alpha,
              struct ureg_src dst,
              struct ureg_src one,
              struct ureg_dst temp[2])
{
   struct ureg_dst out;

   blend_premultiply(ureg, src, src_channel_alpha, dst);

   /* blend in-place */
   out = ureg_dst(src);

   switch (mode) {
   case VG_BLEND_SRC:
      ureg_MOV(ureg, out, src);
      break;
   case VG_BLEND_SRC_OVER:
      /* RGBA_out = RGBA_src + (1 - A_src) * RGBA_dst */
      ureg_SUB(ureg, temp[0], one, src_channel_alpha);
      ureg_MAD(ureg, out, ureg_src(temp[0]), dst, src);
      break;
   case VG_BLEND_DST_OVER:
      /* RGBA_out = RGBA_dst + (1 - A_dst) * RGBA_src */
      ureg_SUB(ureg, temp[0], one, ureg_scalar(dst, TGSI_SWIZZLE_W));
      ureg_MAD(ureg, out, ureg_src(temp[0]), src, dst);
      break;
   case VG_BLEND_SRC_IN:
      ureg_MUL(ureg, out, src, ureg_scalar(dst, TGSI_SWIZZLE_W));
      break;
   case VG_BLEND_DST_IN:
      ureg_MUL(ureg, out, dst, src_channel_alpha);
      break;
   case VG_BLEND_MULTIPLY:
      /*
       * RGB_out = (1 - A_dst) * RGB_src + (1 - A_src) * RGB_dst +
       *           RGB_src * RGB_dst
       */
      ureg_MAD(ureg, temp[0],
            ureg_scalar(dst, TGSI_SWIZZLE_W), ureg_negate(src), src);
      ureg_MAD(ureg, temp[1],
            src_channel_alpha, ureg_negate(dst), dst);
      ureg_MAD(ureg, temp[0], src, dst, ureg_src(temp[0]));
      ureg_ADD(ureg, out, ureg_src(temp[0]), ureg_src(temp[1]));
      /* alpha is src over */
      ureg_ADD(ureg, ureg_writemask(out, TGSI_WRITEMASK_W),
            src, ureg_src(temp[1]));
      break;
   case VG_BLEND_SCREEN:
      /* RGBA_out = RGBA_src + (1 - RGBA_src) * RGBA_dst */
      ureg_SUB(ureg, temp[0], one, src);
      ureg_MAD(ureg, out, ureg_src(temp[0]), dst, src);
      break;
   case VG_BLEND_DARKEN:
   case VG_BLEND_LIGHTEN:
      /* src over */
      ureg_SUB(ureg, temp[0], one, src_channel_alpha);
      ureg_MAD(ureg, temp[0], ureg_src(temp[0]), dst, src);
      /* dst over */
      ureg_SUB(ureg, temp[1], one, ureg_scalar(dst, TGSI_SWIZZLE_W));
      ureg_MAD(ureg, temp[1], ureg_src(temp[1]), src, dst);
      /* take min/max for colors */
      if (mode == VG_BLEND_DARKEN) {
         ureg_MIN(ureg, ureg_writemask(out, TGSI_WRITEMASK_XYZ),
               ureg_src(temp[0]), ureg_src(temp[1]));
      }
      else {
         ureg_MAX(ureg, ureg_writemask(out, TGSI_WRITEMASK_XYZ),
               ureg_src(temp[0]), ureg_src(temp[1]));
      }
      break;
   case VG_BLEND_ADDITIVE:
      /* RGBA_out = RGBA_src + RGBA_dst */
      ureg_ADD(ureg, temp[0], src, dst);
      ureg_MIN(ureg, out, ureg_src(temp[0]), one);
      break;
   default:
      assert(0);
      break;
   }

   blend_unpremultiply(ureg, src, one, temp);
}

#define BLEND_GENERIC(mode) \
   do { \
      ureg_TEX(ureg, temp[2], TGSI_TEXTURE_2D, in[0], sampler[2]);         \
      blend_generic(ureg, (mode), ureg_src(temp[0]), ureg_src(temp[1]),    \
                    ureg_src(temp[2]),                                     \
                    ureg_scalar(constant[3], TGSI_SWIZZLE_Y), temp + 3);   \
      ureg_MOV(ureg, *out, ureg_src(temp[0]));                             \
   } while (0)

static INLINE void
blend_src( struct ureg_program *ureg,
           struct ureg_dst *out,
           struct ureg_src *in,
           struct ureg_src *sampler,
           struct ureg_dst *temp,
           struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_SRC);
}

static INLINE void
blend_src_over( struct ureg_program *ureg,
d254 4
a257 2
   BLEND_GENERIC(VG_BLEND_SRC_OVER);
}
d259 6
a264 10
static INLINE void
blend_dst_over( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_DST_OVER);
}
d266 1
a266 31
static INLINE void
blend_src_in( struct ureg_program *ureg,
              struct ureg_dst *out,
              struct ureg_src *in,
              struct ureg_src *sampler,
              struct ureg_dst *temp,
              struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_SRC_IN);
}

static INLINE void
blend_dst_in( struct ureg_program *ureg,
              struct ureg_dst *out,
              struct ureg_src *in,
              struct ureg_src *sampler,
              struct ureg_dst *temp,
              struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_DST_IN);
}

static INLINE void
blend_multiply( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_MULTIPLY);
d277 4
a280 1
   BLEND_GENERIC(VG_BLEND_SCREEN);
d291 17
a307 1
   BLEND_GENERIC(VG_BLEND_DARKEN);
d318 8
a325 2
   BLEND_GENERIC(VG_BLEND_LIGHTEN);
}
d327 6
a332 10
static INLINE void
blend_additive( struct ureg_program *ureg,
                struct ureg_dst *out,
                struct ureg_src *in,
                struct ureg_src *sampler,
                struct ureg_dst *temp,
                struct ureg_src *constant)
{
   BLEND_GENERIC(VG_BLEND_ADDITIVE);
}
d334 1
a334 13
static INLINE void
mask( struct ureg_program *ureg,
      struct ureg_dst *out,
      struct ureg_src *in,
      struct ureg_src *sampler,
      struct ureg_dst *temp,
      struct ureg_src *constant)
{
   ureg_TEX(ureg, temp[1], TGSI_TEXTURE_2D, in[0], sampler[1]);
   ureg_MUL(ureg, ureg_writemask(temp[0], TGSI_WRITEMASK_W),
            ureg_scalar(ureg_src(temp[0]), TGSI_SWIZZLE_W),
            ureg_scalar(ureg_src(temp[1]), TGSI_SWIZZLE_W));
   ureg_MOV(ureg, *out, ureg_src(temp[0]));
d372 2
a373 2
            ureg_scalar(constant[3], TGSI_SWIZZLE_Y),
            ureg_scalar(constant[3], TGSI_SWIZZLE_Y));
d376 1
a376 1
            ureg_scalar(constant[3], TGSI_SWIZZLE_Y),
d413 2
a414 2
/* paint types */
static const struct shader_asm_info shaders_paint_asm[] = {
d416 1
a416 1
    VG_FALSE, 2, 1, 0, 0, 0, 0},
d418 1
a418 1
    VG_TRUE,  2, 5, 0, 1, 0, 5},
d420 1
a420 1
    VG_TRUE,  2, 5, 0, 1, 0, 5},
d422 1
a422 4
    VG_TRUE,  3, 4, 0, 1, 0, 5},
   {VEGA_PAINT_DEGENERATE_SHADER, paint_degenerate,
    VG_FALSE,  3, 1, 0, 1, 0, 2}
};
d424 1
a424 2
/* image draw modes */
static const struct shader_asm_info shaders_image_asm[] = {
d426 1
a426 1
    VG_TRUE,  0, 0, 3, 1, 0, 2},
d430 1
a430 2
    VG_TRUE,  0, 0, 3, 1, 0, 2}
};
d432 2
a433 4
static const struct shader_asm_info shaders_color_transform_asm[] = {
   {VEGA_COLOR_TRANSFORM_SHADER, color_transform,
    VG_FALSE, 0, 4, 0, 0, 0, 3}
};
d435 9
a443 6
static const struct shader_asm_info shaders_alpha_asm[] = {
   {VEGA_ALPHA_NORMAL_SHADER, alpha_normal,
    VG_FALSE, 0, 0, 0, 0, 0, 2},
   {VEGA_ALPHA_PER_CHANNEL_SHADER, alpha_per_channel,
    VG_FALSE, 0, 0, 0, 0, 0, 2}
};
d445 1
a445 23
/* extra blend modes */
static const struct shader_asm_info shaders_blend_asm[] = {
#define BLEND_ASM_INFO(id, func) { (id), (func), VG_TRUE, 3, 1, 2, 1, 0, 5 }
   BLEND_ASM_INFO(VEGA_BLEND_SRC_SHADER, blend_src),
   BLEND_ASM_INFO(VEGA_BLEND_SRC_OVER_SHADER, blend_src_over),
   BLEND_ASM_INFO(VEGA_BLEND_DST_OVER_SHADER, blend_dst_over),
   BLEND_ASM_INFO(VEGA_BLEND_SRC_IN_SHADER, blend_src_in),
   BLEND_ASM_INFO(VEGA_BLEND_DST_IN_SHADER, blend_dst_in),
   BLEND_ASM_INFO(VEGA_BLEND_MULTIPLY_SHADER, blend_multiply),
   BLEND_ASM_INFO(VEGA_BLEND_SCREEN_SHADER, blend_screen),
   BLEND_ASM_INFO(VEGA_BLEND_DARKEN_SHADER, blend_darken),
   BLEND_ASM_INFO(VEGA_BLEND_LIGHTEN_SHADER, blend_lighten),
   BLEND_ASM_INFO(VEGA_BLEND_ADDITIVE_SHADER, blend_additive)
#undef BLEND_ASM_INFO
};

static const struct shader_asm_info shaders_mask_asm[] = {
   {VEGA_MASK_SHADER, mask,
    VG_TRUE,  0, 0, 1, 1, 0, 2}
};

/* premultiply */
static const struct shader_asm_info shaders_premultiply_asm[] = {
a449 1
};
d451 1
a451 2
/* color transform to black and white */
static const struct shader_asm_info shaders_bw_asm[] = {
d453 1
a453 1
    VG_FALSE,  3, 1, 0, 0, 0, 3},
a454 1

@

