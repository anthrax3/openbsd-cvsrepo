head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.38;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.54;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.17;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2013.10.05.09.53.54;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.05.14.01.51;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.10.05.09.23.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2015.01.25.14.09.34;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.39;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 * Copyright (C) 2010 LunarG Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#include "state_tracker/st_api.h"

#include "pipe/p_context.h"
#include "pipe/p_screen.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_box.h"
#include "util/u_surface.h"

#include "vg_api.h"
#include "vg_manager.h"
#include "vg_context.h"
#include "api.h"
#include "handle.h"

static boolean
vg_context_update_color_rb(struct vg_context *ctx, struct pipe_resource *pt)
{
   struct st_renderbuffer *strb = ctx->draw_buffer->strb;
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_surface surf_tmpl;

   if (strb->texture == pt) {
      pipe_resource_reference(&pt, NULL);
      return FALSE;
   }

   /* unreference existing ones */
   pipe_surface_reference(&strb->surface, NULL);
   pipe_resource_reference(&strb->texture, NULL);
   strb->width = strb->height = 0;

   strb->texture = pt;

   u_surface_default_template(&surf_tmpl, strb->texture);
   strb->surface = pipe->create_surface(pipe, strb->texture, &surf_tmpl);

   if (!strb->surface) {
      pipe_resource_reference(&strb->texture, NULL);
      return TRUE;
   }

   strb->width = pt->width0;
   strb->height = pt->height0;

   return TRUE;
}

/**
 * Flush the front buffer if the current context renders to the front buffer.
 */
void
vg_manager_flush_frontbuffer(struct vg_context *ctx)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;

   if (!stfb)
      return;

   switch (stfb->strb_att) {
   case ST_ATTACHMENT_FRONT_LEFT:
   case ST_ATTACHMENT_FRONT_RIGHT:
      stfb->iface->flush_front(&ctx->iface, stfb->iface, stfb->strb_att);
      break;
   default:
      break;
   }
}

/**
 * Re-validate the framebuffer.
 */
void
vg_manager_validate_framebuffer(struct vg_context *ctx)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct pipe_resource *pt;
   int32_t new_stamp;

   /* no binding surface */
   if (!stfb)
      return;

   new_stamp = p_atomic_read(&stfb->iface->stamp);
   if (stfb->iface_stamp != new_stamp) {
      do {
	 /* validate the fb */
	 if (!stfb->iface->validate((struct st_context_iface *)ctx,
				    stfb->iface, &stfb->strb_att,
				    1, &pt) || !pt)
	    return;

	 stfb->iface_stamp = new_stamp;
	 new_stamp = p_atomic_read(&stfb->iface->stamp);

      } while (stfb->iface_stamp != new_stamp);

      if (vg_context_update_color_rb(ctx, pt) ||
          stfb->width != pt->width0 ||
          stfb->height != pt->height0)
         ++stfb->stamp;

      stfb->width = pt->width0;
      stfb->height = pt->height0;
   }

   if (ctx->draw_stamp != stfb->stamp) {
      ctx->state.dirty |= FRAMEBUFFER_DIRTY;
      ctx->draw_stamp = stfb->stamp;
   }
}

static void
vg_context_flush(struct st_context_iface *stctxi, unsigned flags,
                 struct pipe_fence_handle **fence)
{
   struct vg_context *ctx = (struct vg_context *) stctxi;
   unsigned pipe_flags = 0;

   if (flags & ST_FLUSH_END_OF_FRAME) {
      pipe_flags |= PIPE_FLUSH_END_OF_FRAME;
   }

   ctx->pipe->flush(ctx->pipe, fence, pipe_flags);
   if (flags & ST_FLUSH_FRONT)
      vg_manager_flush_frontbuffer(ctx);
}

static void
vg_context_destroy(struct st_context_iface *stctxi)
{
   struct vg_context *ctx = (struct vg_context *) stctxi;
   struct pipe_context *pipe = ctx->pipe;

   vg_destroy_context(ctx);
   pipe->destroy(pipe);
}

static struct st_context_iface *
vg_api_create_context(struct st_api *stapi, struct st_manager *smapi,
                      const struct st_context_attribs *attribs,
                      enum st_context_error *error,
                      struct st_context_iface *shared_stctxi)
{
   struct vg_context *shared_ctx = (struct vg_context *) shared_stctxi;
   struct vg_context *ctx;
   struct pipe_context *pipe;

   if (!(stapi->profile_mask & (1 << attribs->profile))) {
      *error = ST_CONTEXT_ERROR_BAD_API;
      return NULL;
   }

   /* only 1.0 is supported */
   if (attribs->major > 1 || (attribs->major == 1 && attribs->minor > 0)) {
      *error = ST_CONTEXT_ERROR_BAD_VERSION;
      return NULL;
   }

   /* for VGHandle / pointer lookups */
   init_handles();

   pipe = smapi->screen->context_create(smapi->screen, NULL);
   if (!pipe) {
      *error = ST_CONTEXT_ERROR_NO_MEMORY;
      return NULL;
   }
   ctx = vg_create_context(pipe, NULL, shared_ctx);
   if (!ctx) {
      pipe->destroy(pipe);
      *error = ST_CONTEXT_ERROR_NO_MEMORY;
      return NULL;
   }

   ctx->iface.destroy = vg_context_destroy;

   ctx->iface.flush = vg_context_flush;

   ctx->iface.teximage = NULL;
   ctx->iface.copy = NULL;

   ctx->iface.st_context_private = (void *) smapi;

   return &ctx->iface;
}

static struct st_renderbuffer *
create_renderbuffer(enum pipe_format format)
{
   struct st_renderbuffer *strb;

   strb = CALLOC_STRUCT(st_renderbuffer);
   if (strb)
      strb->format = format;

   return strb;
}

static void
destroy_renderbuffer(struct st_renderbuffer *strb)
{
   pipe_surface_reference(&strb->surface, NULL);
   pipe_resource_reference(&strb->texture, NULL);
   FREE(strb);
}

/**
 * Decide the buffer to render to.
 */
static enum st_attachment_type
choose_attachment(struct st_framebuffer_iface *stfbi)
{
   enum st_attachment_type statt;

   statt = stfbi->visual->render_buffer;
   if (statt != ST_ATTACHMENT_INVALID) {
      /* use the buffer given by the visual, unless it is unavailable */
      if (!st_visual_have_buffers(stfbi->visual, 1 << statt)) {
         switch (statt) {
         case ST_ATTACHMENT_BACK_LEFT:
            statt = ST_ATTACHMENT_FRONT_LEFT;
            break;
         case ST_ATTACHMENT_BACK_RIGHT:
            statt = ST_ATTACHMENT_FRONT_RIGHT;
            break;
         default:
            break;
         }

         if (!st_visual_have_buffers(stfbi->visual, 1 << statt))
            statt = ST_ATTACHMENT_INVALID;
      }
   }

   return statt;
}

/**
 * Bind the context to the given framebuffers.
 */
static boolean
vg_context_bind_framebuffers(struct st_context_iface *stctxi,
                             struct st_framebuffer_iface *stdrawi,
                             struct st_framebuffer_iface *streadi)
{
   struct vg_context *ctx = (struct vg_context *) stctxi;
   struct st_framebuffer *stfb;
   enum st_attachment_type strb_att;

   /* the draw and read framebuffers must be the same */
   if (stdrawi != streadi)
      return FALSE;

   strb_att = (stdrawi) ? choose_attachment(stdrawi) : ST_ATTACHMENT_INVALID;

   if (ctx->draw_buffer) {
      stfb = ctx->draw_buffer;

      /* free the existing fb */
      if (!stdrawi ||
          stfb->strb_att != strb_att ||
          stfb->strb->format != stdrawi->visual->color_format) {
         destroy_renderbuffer(stfb->strb);
         destroy_renderbuffer(stfb->dsrb);
         FREE(stfb);

         ctx->draw_buffer = NULL;
      }
   }

   if (!stdrawi)
      return TRUE;

   if (strb_att == ST_ATTACHMENT_INVALID)
      return FALSE;

   /* create a new fb */
   if (!ctx->draw_buffer) {
      stfb = CALLOC_STRUCT(st_framebuffer);
      if (!stfb)
         return FALSE;

      stfb->strb = create_renderbuffer(stdrawi->visual->color_format);
      if (!stfb->strb) {
         FREE(stfb);
         return FALSE;
      }

      stfb->dsrb = create_renderbuffer(ctx->ds_format);
      if (!stfb->dsrb) {
         FREE(stfb->strb);
         FREE(stfb);
         return FALSE;
      }

      stfb->width = 0;
      stfb->height = 0;
      stfb->strb_att = strb_att;
      stfb->stamp = 1;
      stfb->iface_stamp = p_atomic_read(&stdrawi->stamp) - 1;

      ctx->draw_buffer = stfb;
   }

   ctx->draw_buffer->iface = stdrawi;
   ctx->draw_stamp = ctx->draw_buffer->stamp - 1;

   return TRUE;
}

static boolean
vg_api_make_current(struct st_api *stapi, struct st_context_iface *stctxi,
                    struct st_framebuffer_iface *stdrawi,
                    struct st_framebuffer_iface *streadi)
{
   struct vg_context *ctx = (struct vg_context *) stctxi;

   if (stctxi)
      vg_context_bind_framebuffers(stctxi, stdrawi, streadi);
   vg_set_current_context(ctx);

   return TRUE;
}

static struct st_context_iface *
vg_api_get_current(struct st_api *stapi)
{
   struct vg_context *ctx = vg_current_context();

   return (ctx) ? &ctx->iface : NULL;
}

static st_proc_t
vg_api_get_proc_address(struct st_api *stapi, const char *procname)
{
   return api_get_proc_address(procname);
}

static void
vg_api_destroy(struct st_api *stapi)
{
}

static const struct st_api vg_api = {
   "Vega " PACKAGE_VERSION,
   ST_API_OPENVG,
   ST_PROFILE_DEFAULT_MASK,
   0,
   vg_api_destroy,
   vg_api_get_proc_address,
   vg_api_create_context,
   vg_api_make_current,
   vg_api_get_current,
};

const struct st_api *
vg_api_get(void)
{
   return &vg_api;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a371 10
static void
vg_api_query_versions(struct st_api *stapi, struct st_manager *sm,
                      struct st_config_options *options,
                      int *gl_core_version,
                      int *gl_compat_version,
                      int *gl_es1_version,
                      int *gl_es2_version)
{
}

a377 1
   vg_api_query_versions,
@


1.4
log
@Merge Mesa 9.2.1
@
text
@d372 10
d388 1
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d116 2
a117 1
	 if (!stfb->iface->validate(stfb->iface, &stfb->strb_att,
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.9
d63 1
a63 3
   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   u_surface_default_template(&surf_tmpl, strb->texture,
                              PIPE_BIND_RENDER_TARGET);
d91 1
a91 1
      stfb->iface->flush_front(stfb->iface, stfb->strb_att);
d106 1
d112 17
a128 2
   if (!p_atomic_read(&ctx->draw_buffer_invalid))
      return;
d130 3
a132 3
   /* validate the fb */
   if (!stfb->iface->validate(stfb->iface, &stfb->strb_att, 1, &pt) || !pt)
      return;
d134 1
a134 5
   p_atomic_set(&ctx->draw_buffer_invalid, FALSE);

   if (vg_context_update_color_rb(ctx, pt) ||
       stfb->width != pt->width0 ||
       stfb->height != pt->height0)
d136 2
a137 11

   stfb->width = pt->width0;
   stfb->height = pt->height0;
}

static void
vg_context_notify_invalid_framebuffer(struct st_context_iface *stctxi,
                                      struct st_framebuffer_iface *stfbi)
{
   struct vg_context *ctx = (struct vg_context *) stctxi;
   p_atomic_set(&ctx->draw_buffer_invalid, TRUE);
d145 7
a151 1
   ctx->pipe->flush(ctx->pipe, fence);
d169 1
d176 2
a177 1
   if (!(stapi->profile_mask & (1 << attribs->profile)))
d179 1
d182 2
a183 1
   if (attribs->major > 1 || (attribs->major == 1 && attribs->minor > 0))
d185 1
d191 2
a192 1
   if (!pipe)
d194 1
d198 1
a203 2
   ctx->iface.notify_invalid_framebuffer =
      vg_context_notify_invalid_framebuffer;
a280 2
   p_atomic_set(&ctx->draw_buffer_invalid, TRUE);

d326 2
d333 1
d372 1
a372 1
   "Vega " VEGA_VERSION_STRING,
d375 1
@


1.1
log
@Initial revision
@
text
@a35 1
#include "util/u_sampler.h"
a41 1
#include "image.h"
d43 1
d145 2
a146 2
   ctx->pipe->flush(ctx->pipe, flags, fence);
   if (flags & PIPE_FLUSH_RENDER_CACHE)
d175 3
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d36 1
d43 1
a44 1
#include "handle.h"
d65 3
a67 1
   u_surface_default_template(&surf_tmpl, strb->texture);
d95 1
a95 1
      stfb->iface->flush_front(&ctx->iface, stfb->iface, stfb->strb_att);
a109 1
   int32_t new_stamp;
d115 6
a120 17
   new_stamp = p_atomic_read(&stfb->iface->stamp);
   if (stfb->iface_stamp != new_stamp) {
      do {
	 /* validate the fb */
	 if (!stfb->iface->validate(stfb->iface, &stfb->strb_att,
				    1, &pt) || !pt)
	    return;

	 stfb->iface_stamp = new_stamp;
	 new_stamp = p_atomic_read(&stfb->iface->stamp);

      } while (stfb->iface_stamp != new_stamp);

      if (vg_context_update_color_rb(ctx, pt) ||
          stfb->width != pt->width0 ||
          stfb->height != pt->height0)
         ++stfb->stamp;
d122 1
a122 3
      stfb->width = pt->width0;
      stfb->height = pt->height0;
   }
d124 3
a126 1
   if (ctx->draw_stamp != stfb->stamp) {
d128 11
a138 2
      ctx->draw_stamp = stfb->stamp;
   }
d146 2
a147 8
   unsigned pipe_flags = 0;

   if (flags & ST_FLUSH_END_OF_FRAME) {
      pipe_flags |= PIPE_FLUSH_END_OF_FRAME;
   }

   ctx->pipe->flush(ctx->pipe, fence, pipe_flags);
   if (flags & ST_FLUSH_FRONT)
a163 1
                      enum st_context_error *error,
d170 1
a170 2
   if (!(stapi->profile_mask & (1 << attribs->profile))) {
      *error = ST_CONTEXT_ERROR_BAD_API;
a171 1
   }
d174 1
a174 2
   if (attribs->major > 1 || (attribs->major == 1 && attribs->minor > 0)) {
      *error = ST_CONTEXT_ERROR_BAD_VERSION;
a175 4
   }

   /* for VGHandle / pointer lookups */
   init_handles();
d178 1
a178 2
   if (!pipe) {
      *error = ST_CONTEXT_ERROR_NO_MEMORY;
a179 1
   }
a182 1
      *error = ST_CONTEXT_ERROR_NO_MEMORY;
d188 2
d267 2
a313 2
      stfb->stamp = 1;
      stfb->iface_stamp = p_atomic_read(&stdrawi->stamp) - 1;
a318 1
   ctx->draw_stamp = ctx->draw_buffer->stamp - 1;
d357 1
a357 1
   "Vega " PACKAGE_VERSION,
a359 1
   0,
@


1.1.1.3
log
@Import Mesa 9.2.1
@
text
@d116 1
a116 2
	 if (!stfb->iface->validate((struct st_context_iface *)ctx,
				    stfb->iface, &stfb->strb_att,
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a371 10
static void
vg_api_query_versions(struct st_api *stapi, struct st_manager *sm,
                      struct st_config_options *options,
                      int *gl_core_version,
                      int *gl_compat_version,
                      int *gl_es1_version,
                      int *gl_es2_version)
{
}

a377 1
   vg_api_query_versions,
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d372 10
d388 1
@


