head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.56;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.51;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.20;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "vg_context.h"

#include "paint.h"
#include "renderer.h"
#include "shaders_cache.h"
#include "shader.h"
#include "vg_manager.h"
#include "api.h"
#include "mask.h"
#include "handle.h"

#include "pipe/p_context.h"
#include "util/u_inlines.h"

#include "cso_cache/cso_context.h"

#include "util/u_memory.h"
#include "util/u_sampler.h"
#include "util/u_surface.h"
#include "util/u_format.h"

struct vg_context *_vg_context = 0;

struct vg_context * vg_current_context(void)
{
   return _vg_context;
}

/**
 * A depth/stencil rb will be needed regardless of what the visual says.
 */
static boolean
choose_depth_stencil_format(struct vg_context *ctx)
{
   struct pipe_screen *screen = ctx->pipe->screen;
   enum pipe_format formats[] = {
      PIPE_FORMAT_Z24_UNORM_S8_UINT,
      PIPE_FORMAT_S8_UINT_Z24_UNORM,
      PIPE_FORMAT_NONE
   };
   enum pipe_format *fmt;

   for (fmt = formats; *fmt != PIPE_FORMAT_NONE; fmt++) {
      if (screen->is_format_supported(screen, *fmt,
               PIPE_TEXTURE_2D, 0, PIPE_BIND_DEPTH_STENCIL))
         break;
   }

   ctx->ds_format = *fmt;

   return (ctx->ds_format != PIPE_FORMAT_NONE);
}

void vg_set_current_context(struct vg_context *ctx)
{
   _vg_context = ctx;
   api_make_dispatch_current((ctx) ? ctx->dispatch : NULL);
}

struct vg_context * vg_create_context(struct pipe_context *pipe,
                                      const void *visual,
                                      struct vg_context *share)
{
   struct vg_context *ctx;

   ctx = CALLOC_STRUCT(vg_context);

   ctx->pipe = pipe;
   if (!choose_depth_stencil_format(ctx)) {
      FREE(ctx);
      return NULL;
   }

   ctx->dispatch = api_create_dispatch();

   vg_init_state(&ctx->state.vg);
   ctx->state.dirty = ALL_DIRTY;

   ctx->cso_context = cso_create_context(pipe);

   ctx->default_paint = paint_create(ctx);
   ctx->state.vg.stroke_paint = ctx->default_paint;
   ctx->state.vg.fill_paint = ctx->default_paint;


   ctx->mask.sampler.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->mask.sampler.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->mask.sampler.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->mask.sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
   ctx->mask.sampler.min_img_filter = PIPE_TEX_FILTER_NEAREST;
   ctx->mask.sampler.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
   ctx->mask.sampler.normalized_coords = 0;

   ctx->blend_sampler.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->blend_sampler.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->blend_sampler.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->blend_sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
   ctx->blend_sampler.min_img_filter = PIPE_TEX_FILTER_NEAREST;
   ctx->blend_sampler.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
   ctx->blend_sampler.normalized_coords = 0;

   vg_set_error(ctx, VG_NO_ERROR);

   ctx->owned_objects[VG_OBJECT_PAINT] = cso_hash_create();
   ctx->owned_objects[VG_OBJECT_IMAGE] = cso_hash_create();
   ctx->owned_objects[VG_OBJECT_MASK] = cso_hash_create();
   ctx->owned_objects[VG_OBJECT_FONT] = cso_hash_create();
   ctx->owned_objects[VG_OBJECT_PATH] = cso_hash_create();

   ctx->renderer = renderer_create(ctx);
   ctx->sc = shaders_cache_create(ctx);
   ctx->shader = shader_create(ctx);

   return ctx;
}

void vg_destroy_context(struct vg_context *ctx)
{
   struct pipe_resource **cbuf = &ctx->mask.cbuf;

   renderer_destroy(ctx->renderer);
   shaders_cache_destroy(ctx->sc);
   shader_destroy(ctx->shader);
   paint_destroy(ctx->default_paint);

   if (*cbuf)
      pipe_resource_reference(cbuf, NULL);

   if (ctx->mask.union_fs)
      vg_shader_destroy(ctx, ctx->mask.union_fs);
   if (ctx->mask.intersect_fs)
      vg_shader_destroy(ctx, ctx->mask.intersect_fs);
   if (ctx->mask.subtract_fs)
      vg_shader_destroy(ctx, ctx->mask.subtract_fs);
   if (ctx->mask.set_fs)
      vg_shader_destroy(ctx, ctx->mask.set_fs);

   cso_release_all(ctx->cso_context);
   cso_destroy_context(ctx->cso_context);

   cso_hash_delete(ctx->owned_objects[VG_OBJECT_PAINT]);
   cso_hash_delete(ctx->owned_objects[VG_OBJECT_IMAGE]);
   cso_hash_delete(ctx->owned_objects[VG_OBJECT_MASK]);
   cso_hash_delete(ctx->owned_objects[VG_OBJECT_FONT]);
   cso_hash_delete(ctx->owned_objects[VG_OBJECT_PATH]);

   api_destroy_dispatch(ctx->dispatch);

   FREE(ctx);
}

void vg_init_object(struct vg_object *obj, struct vg_context *ctx, enum vg_object_type type)
{
   obj->type = type;
   obj->ctx = ctx;
   obj->handle = create_handle(obj);
}

/** free object resources, but not the object itself */
void vg_free_object(struct vg_object *obj)
{
   obj->type = 0;
   obj->ctx = NULL;
   destroy_handle(obj->handle);
}

VGboolean vg_context_is_object_valid(struct vg_context *ctx,
                                enum vg_object_type type,
                                VGHandle handle)
{
    if (ctx) {
       struct cso_hash *hash = ctx->owned_objects[type];
       if (!hash)
          return VG_FALSE;
       return cso_hash_contains(hash, (unsigned) handle);
    }
    return VG_FALSE;
}

void vg_context_add_object(struct vg_context *ctx,
                           struct vg_object *obj)
{
    if (ctx) {
       struct cso_hash *hash = ctx->owned_objects[obj->type];
       if (!hash)
          return;
       cso_hash_insert(hash, (unsigned) obj->handle, obj);
    }
}

void vg_context_remove_object(struct vg_context *ctx,
                              struct vg_object *obj)
{
   if (ctx) {
      struct cso_hash *hash = ctx->owned_objects[obj->type];
      if (!hash)
         return;
      cso_hash_take(hash, (unsigned) obj->handle);
   }
}

static struct pipe_resource *
create_texture(struct pipe_context *pipe, enum pipe_format format,
                    VGint width, VGint height)
{
   struct pipe_resource templ;

   memset(&templ, 0, sizeof(templ));

   if (format != PIPE_FORMAT_NONE) {
      templ.format = format;
   }
   else {
      templ.format = PIPE_FORMAT_B8G8R8A8_UNORM;
   }

   templ.target = PIPE_TEXTURE_2D;
   templ.width0 = width;
   templ.height0 = height;
   templ.depth0 = 1;
   templ.array_size = 1;
   templ.last_level = 0;

   if (util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_ZS, 1)) {
      templ.bind = PIPE_BIND_DEPTH_STENCIL;
   } else {
      templ.bind = (PIPE_BIND_DISPLAY_TARGET |
                    PIPE_BIND_RENDER_TARGET |
                    PIPE_BIND_SAMPLER_VIEW);
   }

   return pipe->screen->resource_create(pipe->screen, &templ);
}

static struct pipe_sampler_view *
create_tex_and_view(struct pipe_context *pipe, enum pipe_format format,
                    VGint width, VGint height)
{
   struct pipe_resource *texture;
   struct pipe_sampler_view view_templ;
   struct pipe_sampler_view *view;

   texture = create_texture(pipe, format, width, height);

   if (!texture)
      return NULL;

   u_sampler_view_default_template(&view_templ, texture, texture->format);
   view = pipe->create_sampler_view(pipe, texture, &view_templ);
   /* want the texture to go away if the view is freed */
   pipe_resource_reference(&texture, NULL);

   return view;
}

static void
vg_context_update_surface_mask_view(struct vg_context *ctx,
                                    uint width, uint height)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct pipe_sampler_view *old_sampler_view = stfb->surface_mask_view;
   struct pipe_context *pipe = ctx->pipe;

   if (old_sampler_view &&
       old_sampler_view->texture->width0 == width &&
       old_sampler_view->texture->height0 == height)
      return;

   /*
     we use PIPE_FORMAT_B8G8R8A8_UNORM because we want to render to
     this texture and use it as a sampler, so while this wastes some
     space it makes both of those a lot simpler
   */
   stfb->surface_mask_view = create_tex_and_view(pipe,
         PIPE_FORMAT_B8G8R8A8_UNORM, width, height);

   if (!stfb->surface_mask_view) {
      if (old_sampler_view)
         pipe_sampler_view_reference(&old_sampler_view, NULL);
      return;
   }

   /* XXX could this call be avoided? */
   vg_validate_state(ctx);

   /* alpha mask starts with 1.f alpha */
   mask_fill(0, 0, width, height, 1.f);

   /* if we had an old surface copy it over */
   if (old_sampler_view) {
      struct pipe_box src_box;
      u_box_origin_2d(MIN2(old_sampler_view->texture->width0,
                           stfb->surface_mask_view->texture->width0),
                      MIN2(old_sampler_view->texture->height0,
                           stfb->surface_mask_view->texture->height0),
                      &src_box);

      pipe->resource_copy_region(pipe,
                                 stfb->surface_mask_view->texture,
                                 0, 0, 0, 0,
                                 old_sampler_view->texture,
                                 0, &src_box);
   }

   /* Free the old texture
    */
   if (old_sampler_view)
      pipe_sampler_view_reference(&old_sampler_view, NULL);
}

static void
vg_context_update_blend_texture_view(struct vg_context *ctx,
                                     uint width, uint height)
{
   struct pipe_context *pipe = ctx->pipe;
   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct pipe_sampler_view *old = stfb->blend_texture_view;

   if (old &&
       old->texture->width0 == width &&
       old->texture->height0 == height)
      return;

   stfb->blend_texture_view = create_tex_and_view(pipe,
         PIPE_FORMAT_B8G8R8A8_UNORM, width, height);

   pipe_sampler_view_reference(&old, NULL);
}

static boolean
vg_context_update_depth_stencil_rb(struct vg_context * ctx,
                                   uint width, uint height)
{
   struct st_renderbuffer *dsrb = ctx->draw_buffer->dsrb;
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_surface surf_tmpl;

   if ((dsrb->width == width && dsrb->height == height) && dsrb->texture)
      return FALSE;

   /* unreference existing ones */
   pipe_surface_reference(&dsrb->surface, NULL);
   pipe_resource_reference(&dsrb->texture, NULL);
   dsrb->width = dsrb->height = 0;

   dsrb->texture = create_texture(pipe, dsrb->format, width, height);
   if (!dsrb->texture)
      return TRUE;

   u_surface_default_template(&surf_tmpl, dsrb->texture);
   dsrb->surface = pipe->create_surface(pipe,
                                        dsrb->texture,
                                        &surf_tmpl);
   if (!dsrb->surface) {
      pipe_resource_reference(&dsrb->texture, NULL);
      return TRUE;
   }

   dsrb->width = width;
   dsrb->height = height;

   assert(dsrb->surface->width == width);
   assert(dsrb->surface->height == height);

   return TRUE;
}

void vg_validate_state(struct vg_context *ctx)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;

   vg_manager_validate_framebuffer(ctx);

   if (vg_context_update_depth_stencil_rb(ctx, stfb->width, stfb->height))
      ctx->state.dirty |= DEPTH_STENCIL_DIRTY;

   /* blend state depends on fb format and paint color */
   if ((ctx->state.dirty & FRAMEBUFFER_DIRTY) ||
       (ctx->state.dirty & PAINT_DIRTY))
      ctx->state.dirty |= BLEND_DIRTY;

   renderer_validate(ctx->renderer, ctx->state.dirty,
         ctx->draw_buffer, &ctx->state.vg);

   ctx->state.dirty = 0;

   shader_set_masking(ctx->shader, ctx->state.vg.masking);
   shader_set_image_mode(ctx->shader, ctx->state.vg.image_mode);
   shader_set_color_transform(ctx->shader, ctx->state.vg.color_transform);
}

VGboolean vg_object_is_valid(VGHandle object, enum vg_object_type type)
{
   struct vg_object *obj = handle_to_object(object);
   if (obj && is_aligned(obj) && obj->type == type)
      return VG_TRUE;
   else
      return VG_FALSE;
}

void vg_set_error(struct vg_context *ctx,
                  VGErrorCode code)
{
   /*vgGetError returns the oldest error code provided by
    * an API call on the current context since the previous
    * call to vgGetError on that context (or since the creation
    of the context).*/
   if (ctx->_error == VG_NO_ERROR)
      ctx->_error = code;
}

static void vg_prepare_blend_texture(struct vg_context *ctx,
                                     struct pipe_sampler_view *src)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_blit_info info;

   vg_context_update_blend_texture_view(ctx, stfb->width, stfb->height);

   memset(&info, 0, sizeof info);
   info.dst.resource = stfb->blend_texture_view->texture;
   info.dst.level = 0;
   info.dst.box.x = 0;
   info.dst.box.y = 0;
   info.dst.box.z = 0;
   info.dst.box.width = stfb->width;
   info.dst.box.height = stfb->height;
   info.dst.box.depth = 1;
   info.dst.format = stfb->blend_texture_view->format;
   info.src.resource = src->texture;
   info.src.level = src->u.tex.first_level;
   info.src.box.x = 0;
   info.src.box.y = 0;
   info.src.box.z = src->u.tex.first_layer;
   info.src.box.width = stfb->width;
   info.src.box.height = stfb->height;
   info.src.box.depth = 1;
   info.src.format = src->format;
   info.mask = PIPE_MASK_RGBA;
   info.filter = PIPE_TEX_MIPFILTER_NEAREST;
   info.scissor_enable = 0;

   pipe->blit(pipe, &info);
}

struct pipe_sampler_view *vg_prepare_blend_surface(struct vg_context *ctx)
{
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_sampler_view *view;
   struct pipe_sampler_view view_templ;
   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct st_renderbuffer *strb = stfb->strb;

   vg_validate_state(ctx);

   u_sampler_view_default_template(&view_templ, strb->texture, strb->texture->format);
   view = pipe->create_sampler_view(pipe, strb->texture, &view_templ);

   vg_prepare_blend_texture(ctx, view);

   pipe_sampler_view_reference(&view, NULL);

   return stfb->blend_texture_view;
}


struct pipe_sampler_view *vg_prepare_blend_surface_from_mask(struct vg_context *ctx)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;

   vg_validate_state(ctx);

   vg_context_update_surface_mask_view(ctx, stfb->width, stfb->height);
   vg_prepare_blend_texture(ctx, stfb->surface_mask_view);

   return stfb->blend_texture_view;
}

struct pipe_sampler_view *vg_get_surface_mask(struct vg_context *ctx)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;

   vg_context_update_surface_mask_view(ctx, stfb->width, stfb->height);

   return stfb->surface_mask_view;
}

/**
 * A transformation from window coordinates to paint coordinates.
 */
VGboolean vg_get_paint_matrix(struct vg_context *ctx,
                              const struct matrix *paint_to_user,
                              const struct matrix *user_to_surface,
                              struct matrix *mat)
{
   struct matrix tmp;

   /* get user-to-paint matrix */
   memcpy(mat, paint_to_user, sizeof(*paint_to_user));
   if (!matrix_invert(mat))
      return VG_FALSE;

   /* get surface-to-user matrix */
   memcpy(&tmp, user_to_surface, sizeof(*user_to_surface));
   if (!matrix_invert(&tmp))
      return VG_FALSE;

   matrix_mult(mat, &tmp);

   return VG_TRUE;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@a43 1
#include "util/u_blit.h"
a139 2
   ctx->blit = util_create_blit(ctx->pipe, ctx->cso_context);

a146 1
   util_destroy_blit(ctx->blit);
d442 2
a443 2
   struct pipe_surface *surf;
   struct pipe_surface surf_tmpl;
d447 22
a468 9
   u_surface_default_template(&surf_tmpl, stfb->blend_texture_view->texture);
   surf = ctx->pipe->create_surface(ctx->pipe,
                                    stfb->blend_texture_view->texture,
                                    &surf_tmpl);
   if (surf) {
      util_blit_pixels_tex(ctx->blit,
                           src, 0, 0, stfb->width, stfb->height,
                           surf, 0, 0, stfb->width, stfb->height,
                           0.0, PIPE_TEX_MIPFILTER_NEAREST);
d470 1
a470 2
      pipe_surface_reference(&surf, NULL);
   }
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d64 2
a65 2
      PIPE_FORMAT_Z24_UNORM_S8_USCALED,
      PIPE_FORMAT_S8_USCALED_Z24_UNORM,
d199 1
a199 1
                                VGHandle object)
d205 1
a205 1
       return cso_hash_contains(hash, (unsigned)(long)object);
d211 1
a211 2
                           enum vg_object_type type,
                           void *ptr)
d214 1
a214 1
       struct cso_hash *hash = ctx->owned_objects[type];
d217 1
a217 1
       cso_hash_insert(hash, (unsigned)(long)ptr, ptr);
d222 1
a222 2
                              enum vg_object_type type,
                              void *ptr)
d225 1
a225 1
      struct cso_hash *hash = ctx->owned_objects[type];
d228 1
a228 1
      cso_hash_take(hash, (unsigned)(long)ptr);
d380 1
a380 3
   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   u_surface_default_template(&surf_tmpl, dsrb->texture,
                              PIPE_BIND_DEPTH_STENCIL);
d451 1
a451 3
   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   u_surface_default_template(&surf_tmpl, stfb->blend_texture_view->texture,
                              PIPE_BIND_RENDER_TARGET);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a32 1
#include "asm_util.h"
d36 1
a42 1
#include "util/u_simple_shaders.h"
d72 1
a72 1
               PIPE_TEXTURE_2D, 0, PIPE_BIND_DEPTH_STENCIL, 0))
d186 9
d199 1
a199 1
                                void *ptr)
d205 1
a205 1
       return cso_hash_contains(hash, (unsigned)(long)ptr);
d411 3
a413 2
   /* blend state depends on fb format */
   if (ctx->state.dirty & FRAMEBUFFER_DIRTY)
d426 1
a426 1
VGboolean vg_object_is_valid(void *ptr, enum vg_object_type type)
d428 2
a429 2
   struct vg_object *obj = ptr;
   if (ptr && is_aligned(obj) && obj->type == type)
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 3
a36 1
#include "st_inlines.h"
a39 1
#include "pipe/p_shader_tokens.h"
d46 3
d57 19
a75 3
static void init_clear(struct vg_context *st)
{
   struct pipe_context *pipe = st->pipe;
d77 1
a77 3
   /* rasterizer state: bypass clipping */
   memset(&st->clear.raster, 0, sizeof(st->clear.raster));
   st->clear.raster.gl_rasterization_rules = 1;
d79 1
a79 3
   /* fragment shader state: color pass-through program */
   st->clear.fs =
      util_make_fragment_passthrough_shader(pipe);
d81 1
d85 1
d97 6
a108 2
   init_clear(ctx);

d116 1
d124 1
d149 1
a149 2
   struct pipe_buffer **cbuf = &ctx->mask.cbuf;
   struct pipe_buffer **vsbuf = &ctx->vs_const_buffer;
d158 1
a158 22
      pipe_buffer_reference(cbuf, NULL);

   if (*vsbuf)
      pipe_buffer_reference(vsbuf, NULL);

   if (ctx->clear.fs) {
      cso_delete_fragment_shader(ctx->cso_context, ctx->clear.fs);
      ctx->clear.fs = NULL;
   }

   if (ctx->plain_vs) {
      vg_shader_destroy(ctx, ctx->plain_vs);
      ctx->plain_vs = NULL;
   }
   if (ctx->clear_vs) {
      vg_shader_destroy(ctx, ctx->clear_vs);
      ctx->clear_vs = NULL;
   }
   if (ctx->texture_vs) {
      vg_shader_destroy(ctx, ctx->texture_vs);
      ctx->texture_vs = NULL;
   }
a159 2
   if (ctx->pass_through_depth_fs)
      vg_shader_destroy(ctx, ctx->pass_through_depth_fs);
d178 3
a180 1
   free(ctx);
d226 3
a228 1
static void update_clip_state(struct vg_context *ctx)
d230 1
a230 2
   struct pipe_depth_stencil_alpha_state *dsa = &ctx->state.g3d.dsa;
   struct vg_state *state =  &ctx->state.vg;
d232 1
a232 1
   memset(dsa, 0, sizeof(struct pipe_depth_stencil_alpha_state));
d234 5
a238 64
   if (state->scissoring) {
      struct pipe_blend_state *blend = &ctx->state.g3d.blend;
      struct pipe_framebuffer_state *fb = &ctx->state.g3d.fb;
      int i;

      dsa->depth.writemask = 1;/*glDepthMask(TRUE);*/
      dsa->depth.func = PIPE_FUNC_ALWAYS;
      dsa->depth.enabled = 1;

      cso_save_blend(ctx->cso_context);
      cso_save_fragment_shader(ctx->cso_context);
      /* set a passthrough shader */
      if (!ctx->pass_through_depth_fs)
         ctx->pass_through_depth_fs = shader_create_from_text(ctx->pipe,
                                                              pass_through_depth_asm,
                                                              40,
                                                              PIPE_SHADER_FRAGMENT);
      cso_set_fragment_shader_handle(ctx->cso_context,
                                     ctx->pass_through_depth_fs->driver);
      cso_set_depth_stencil_alpha(ctx->cso_context, dsa);

      ctx->pipe->clear(ctx->pipe, PIPE_CLEAR_DEPTHSTENCIL, NULL, 1.0, 0);

      /* disable color writes */
      blend->rt[0].colormask = 0; /*disable colorwrites*/
      cso_set_blend(ctx->cso_context, blend);

      /* enable scissoring */
      for (i = 0; i < state->scissor_rects_num; ++i) {
         const float x      = state->scissor_rects[i * 4 + 0].f;
         const float y      = state->scissor_rects[i * 4 + 1].f;
         const float width  = state->scissor_rects[i * 4 + 2].f;
         const float height = state->scissor_rects[i * 4 + 3].f;
         VGfloat minx, miny, maxx, maxy;

         minx = 0;
         miny = 0;
         maxx = fb->width;
         maxy = fb->height;

         if (x > minx)
            minx = x;
         if (y > miny)
            miny = y;

         if (x + width < maxx)
            maxx = x + width;
         if (y + height < maxy)
            maxy = y + height;

         /* check for null space */
         if (minx >= maxx || miny >= maxy)
            minx = miny = maxx = maxy = 0;

         /*glClear(GL_DEPTH_BUFFER_BIT);*/
         renderer_draw_quad(ctx->renderer, minx, miny, maxx, maxy, 0.0f);
      }

      cso_restore_blend(ctx->cso_context);
      cso_restore_fragment_shader(ctx->cso_context);

      dsa->depth.enabled = 1; /* glEnable(GL_DEPTH_TEST); */
      dsa->depth.writemask = 0;/*glDepthMask(FALSE);*/
      dsa->depth.func = PIPE_FUNC_GEQUAL;
d240 38
d280 3
a282 1
void vg_validate_state(struct vg_context *ctx)
d284 21
a304 58
   if ((ctx->state.dirty & BLEND_DIRTY)) {
      struct pipe_blend_state *blend = &ctx->state.g3d.blend;
      memset(blend, 0, sizeof(struct pipe_blend_state));
      blend->rt[0].blend_enable = 1;
      blend->rt[0].colormask = PIPE_MASK_RGBA;

      switch (ctx->state.vg.blend_mode) {
      case VG_BLEND_SRC:
         blend->rt[0].rgb_src_factor   = PIPE_BLENDFACTOR_ONE;
         blend->rt[0].alpha_src_factor = PIPE_BLENDFACTOR_ONE;
         blend->rt[0].rgb_dst_factor   = PIPE_BLENDFACTOR_ZERO;
         blend->rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_ZERO;
         blend->rt[0].blend_enable = 0;
         break;
      case VG_BLEND_SRC_OVER:
         blend->rt[0].rgb_src_factor   = PIPE_BLENDFACTOR_SRC_ALPHA;
         blend->rt[0].alpha_src_factor = PIPE_BLENDFACTOR_ONE;
         blend->rt[0].rgb_dst_factor   = PIPE_BLENDFACTOR_INV_SRC_ALPHA;
         blend->rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_INV_SRC_ALPHA;
         break;
      case VG_BLEND_DST_OVER:
         blend->rt[0].rgb_src_factor   = PIPE_BLENDFACTOR_INV_DST_ALPHA;
         blend->rt[0].alpha_src_factor = PIPE_BLENDFACTOR_INV_DST_ALPHA;
         blend->rt[0].rgb_dst_factor   = PIPE_BLENDFACTOR_DST_ALPHA;
         blend->rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_DST_ALPHA;
         break;
      case VG_BLEND_SRC_IN:
         blend->rt[0].rgb_src_factor   = PIPE_BLENDFACTOR_DST_ALPHA;
         blend->rt[0].alpha_src_factor = PIPE_BLENDFACTOR_DST_ALPHA;
         blend->rt[0].rgb_dst_factor   = PIPE_BLENDFACTOR_ZERO;
         blend->rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_ZERO;
         break;
      case VG_BLEND_DST_IN:
         blend->rt[0].rgb_src_factor   = PIPE_BLENDFACTOR_ZERO;
         blend->rt[0].alpha_src_factor = PIPE_BLENDFACTOR_ZERO;
         blend->rt[0].rgb_dst_factor   = PIPE_BLENDFACTOR_SRC_ALPHA;
         blend->rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_SRC_ALPHA;
         break;
      case VG_BLEND_MULTIPLY:
      case VG_BLEND_SCREEN:
      case VG_BLEND_DARKEN:
      case VG_BLEND_LIGHTEN:
         blend->rt[0].rgb_src_factor   = PIPE_BLENDFACTOR_ONE;
         blend->rt[0].alpha_src_factor = PIPE_BLENDFACTOR_ONE;
         blend->rt[0].rgb_dst_factor   = PIPE_BLENDFACTOR_ZERO;
         blend->rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_ZERO;
         blend->rt[0].blend_enable = 0;
         break;
      case VG_BLEND_ADDITIVE:
         blend->rt[0].rgb_src_factor   = PIPE_BLENDFACTOR_ONE;
         blend->rt[0].alpha_src_factor = PIPE_BLENDFACTOR_ONE;
         blend->rt[0].rgb_dst_factor   = PIPE_BLENDFACTOR_ONE;
         blend->rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_ONE;
         break;
      default:
         assert(!"not implemented blend mode");
      }
      cso_set_blend(ctx->cso_context, &ctx->state.g3d.blend);
d306 77
a382 31
   if ((ctx->state.dirty & RASTERIZER_DIRTY)) {
      struct pipe_rasterizer_state *raster = &ctx->state.g3d.rasterizer;
      memset(raster, 0, sizeof(struct pipe_rasterizer_state));
      raster->gl_rasterization_rules = 1;
      cso_set_rasterizer(ctx->cso_context, &ctx->state.g3d.rasterizer);
   }
   if ((ctx->state.dirty & VIEWPORT_DIRTY)) {
      struct pipe_framebuffer_state *fb = &ctx->state.g3d.fb;
      const VGint param_bytes = 8 * sizeof(VGfloat);
      VGfloat vs_consts[8] = {
         2.f/fb->width, 2.f/fb->height, 1, 1,
         -1, -1, 0, 0
      };
      struct pipe_buffer **cbuf = &ctx->vs_const_buffer;

      vg_set_viewport(ctx, VEGA_Y0_BOTTOM);

      pipe_buffer_reference(cbuf, NULL);
      *cbuf = pipe_buffer_create(ctx->pipe->screen, 16,
                                        PIPE_BUFFER_USAGE_CONSTANT,
                                        param_bytes);

      if (*cbuf) {
         st_no_flush_pipe_buffer_write(ctx, *cbuf,
                                       0, param_bytes, vs_consts);
      }
      ctx->pipe->set_constant_buffer(ctx->pipe, PIPE_SHADER_VERTEX, 0, *cbuf);
   }
   if ((ctx->state.dirty & VS_DIRTY)) {
      cso_set_vertex_shader_handle(ctx->cso_context,
                                   vg_plain_vs(ctx));
d385 26
a410 5
   /* must be last because it renders to the depth buffer*/
   if ((ctx->state.dirty & DEPTH_STENCIL_DIRTY)) {
      update_clip_state(ctx);
      cso_set_depth_stencil_alpha(ctx->cso_context, &ctx->state.g3d.dsa);
   }
d414 1
a414 2

   ctx->state.dirty = NONE_DIRTY;
d437 2
a438 1
void vg_prepare_blend_surface(struct vg_context *ctx)
a439 2
   struct pipe_surface *dest_surface = NULL;
   struct pipe_context *pipe = ctx->pipe;
d441 2
a442 1
   struct st_renderbuffer *strb = stfb->strb;
d444 1
a444 2
   /* first finish all pending rendering */
   vgFinish();
d446 11
a456 16
   dest_surface = pipe->screen->get_tex_surface(pipe->screen,
                                                stfb->blend_texture,
                                                0, 0, 0,
                                                PIPE_BUFFER_USAGE_GPU_WRITE);
   /* flip it, because we want to use it as a sampler */
   util_blit_pixels_tex(ctx->blit,
                        strb->texture,
                        0, strb->height,
                        strb->width, 0,
                        dest_surface,
                        0, 0,
                        strb->width, strb->height,
                        0.0, PIPE_TEX_MIPFILTER_NEAREST);

   if (dest_surface)
      pipe_surface_reference(&dest_surface, NULL);
d458 2
a459 2
   /* make sure it's complete */
   vgFinish();
d462 1
a462 2

void vg_prepare_blend_surface_from_mask(struct vg_context *ctx)
a463 1
   struct pipe_surface *dest_surface = NULL;
d465 2
d472 4
a475 2
   /* first finish all pending rendering */
   vgFinish();
d477 1
a477 30
   dest_surface = pipe->screen->get_tex_surface(pipe->screen,
                                                stfb->blend_texture,
                                                0, 0, 0,
                                                PIPE_BUFFER_USAGE_GPU_WRITE);

   /* flip it, because we want to use it as a sampler */
   util_blit_pixels_tex(ctx->blit,
                        stfb->alpha_mask,
                        0, strb->height,
                        strb->width, 0,
                        dest_surface,
                        0, 0,
                        strb->width, strb->height,
                        0.0, PIPE_TEX_MIPFILTER_NEAREST);

   /* make sure it's complete */
   vgFinish();

   if (dest_surface)
      pipe_surface_reference(&dest_surface, NULL);
}

void * vg_plain_vs(struct vg_context *ctx)
{
   if (!ctx->plain_vs) {
      ctx->plain_vs = shader_create_from_text(ctx->pipe,
                                              vs_plain_asm,
                                              200,
                                              PIPE_SHADER_VERTEX);
   }
d479 1
a479 1
   return ctx->plain_vs->driver;
d483 1
a483 1
void * vg_clear_vs(struct vg_context *ctx)
d485 6
a490 6
   if (!ctx->clear_vs) {
      ctx->clear_vs = shader_create_from_text(ctx->pipe,
                                              vs_clear_asm,
                                              200,
                                              PIPE_SHADER_VERTEX);
   }
d492 1
a492 1
   return ctx->clear_vs->driver;
d495 1
a495 1
void * vg_texture_vs(struct vg_context *ctx)
d497 3
a499 6
   if (!ctx->texture_vs) {
      ctx->texture_vs = shader_create_from_text(ctx->pipe,
                                                vs_texture_asm,
                                                200,
                                                PIPE_SHADER_VERTEX);
   }
d501 1
a501 1
   return ctx->texture_vs->driver;
d504 7
a510 1
void vg_set_viewport(struct vg_context *ctx, VegaOrientation orientation)
d512 11
a522 3
   struct pipe_viewport_state viewport;
   struct pipe_framebuffer_state *fb = &ctx->state.g3d.fb;
   VGfloat y_scale = (orientation == VEGA_Y0_BOTTOM) ? -2.f : 2.f;
d524 1
a524 8
   viewport.scale[0] =  fb->width / 2.f;
   viewport.scale[1] =  fb->height / y_scale;
   viewport.scale[2] =  1.0;
   viewport.scale[3] =  1.0;
   viewport.translate[0] = fb->width / 2.f;
   viewport.translate[1] = fb->height / 2.f;
   viewport.translate[2] = 0.0;
   viewport.translate[3] = 0.0;
d526 1
a526 1
   cso_set_viewport(ctx->cso_context, &viewport);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 1
a34 3
#include "vg_manager.h"
#include "api.h"
#include "mask.h"
d38 1
a44 3
#include "util/u_sampler.h"
#include "util/u_surface.h"
#include "util/u_format.h"
d53 3
a55 19
/**
 * A depth/stencil rb will be needed regardless of what the visual says.
 */
static boolean
choose_depth_stencil_format(struct vg_context *ctx)
{
   struct pipe_screen *screen = ctx->pipe->screen;
   enum pipe_format formats[] = {
      PIPE_FORMAT_Z24_UNORM_S8_USCALED,
      PIPE_FORMAT_S8_USCALED_Z24_UNORM,
      PIPE_FORMAT_NONE
   };
   enum pipe_format *fmt;

   for (fmt = formats; *fmt != PIPE_FORMAT_NONE; fmt++) {
      if (screen->is_format_supported(screen, *fmt,
               PIPE_TEXTURE_2D, 0, PIPE_BIND_DEPTH_STENCIL, 0))
         break;
   }
d57 3
a59 1
   ctx->ds_format = *fmt;
d61 3
a63 1
   return (ctx->ds_format != PIPE_FORMAT_NONE);
a64 1

a67 1
   api_make_dispatch_current((ctx) ? ctx->dispatch : NULL);
a78 6
   if (!choose_depth_stencil_format(ctx)) {
      FREE(ctx);
      return NULL;
   }

   ctx->dispatch = api_create_dispatch();
d85 2
a93 1
   ctx->mask.sampler.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
a100 1
   ctx->blend_sampler.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
d125 2
a126 1
   struct pipe_resource **cbuf = &ctx->mask.cbuf;
d135 22
a156 1
      pipe_resource_reference(cbuf, NULL);
d158 2
d178 1
a178 3
   api_destroy_dispatch(ctx->dispatch);

   FREE(ctx);
d224 1
a224 3
static struct pipe_resource *
create_texture(struct pipe_context *pipe, enum pipe_format format,
                    VGint width, VGint height)
d226 2
a227 1
   struct pipe_resource templ;
d229 1
a229 1
   memset(&templ, 0, sizeof(templ));
d231 64
a294 5
   if (format != PIPE_FORMAT_NONE) {
      templ.format = format;
   }
   else {
      templ.format = PIPE_FORMAT_B8G8R8A8_UNORM;
a295 17

   templ.target = PIPE_TEXTURE_2D;
   templ.width0 = width;
   templ.height0 = height;
   templ.depth0 = 1;
   templ.array_size = 1;
   templ.last_level = 0;

   if (util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_ZS, 1)) {
      templ.bind = PIPE_BIND_DEPTH_STENCIL;
   } else {
      templ.bind = (PIPE_BIND_DISPLAY_TARGET |
                    PIPE_BIND_RENDER_TARGET |
                    PIPE_BIND_SAMPLER_VIEW);
   }

   return pipe->screen->resource_create(pipe->screen, &templ);
d298 1
a298 3
static struct pipe_sampler_view *
create_tex_and_view(struct pipe_context *pipe, enum pipe_format format,
                    VGint width, VGint height)
d300 90
a389 42
   struct pipe_resource *texture;
   struct pipe_sampler_view view_templ;
   struct pipe_sampler_view *view;

   texture = create_texture(pipe, format, width, height);

   if (!texture)
      return NULL;

   u_sampler_view_default_template(&view_templ, texture, texture->format);
   view = pipe->create_sampler_view(pipe, texture, &view_templ);
   /* want the texture to go away if the view is freed */
   pipe_resource_reference(&texture, NULL);

   return view;
}

static void
vg_context_update_surface_mask_view(struct vg_context *ctx,
                                    uint width, uint height)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct pipe_sampler_view *old_sampler_view = stfb->surface_mask_view;
   struct pipe_context *pipe = ctx->pipe;

   if (old_sampler_view &&
       old_sampler_view->texture->width0 == width &&
       old_sampler_view->texture->height0 == height)
      return;

   /*
     we use PIPE_FORMAT_B8G8R8A8_UNORM because we want to render to
     this texture and use it as a sampler, so while this wastes some
     space it makes both of those a lot simpler
   */
   stfb->surface_mask_view = create_tex_and_view(pipe,
         PIPE_FORMAT_B8G8R8A8_UNORM, width, height);

   if (!stfb->surface_mask_view) {
      if (old_sampler_view)
         pipe_sampler_view_reference(&old_sampler_view, NULL);
      return;
d392 4
a395 76
   /* XXX could this call be avoided? */
   vg_validate_state(ctx);

   /* alpha mask starts with 1.f alpha */
   mask_fill(0, 0, width, height, 1.f);

   /* if we had an old surface copy it over */
   if (old_sampler_view) {
      struct pipe_box src_box;
      u_box_origin_2d(MIN2(old_sampler_view->texture->width0,
                           stfb->surface_mask_view->texture->width0),
                      MIN2(old_sampler_view->texture->height0,
                           stfb->surface_mask_view->texture->height0),
                      &src_box);

      pipe->resource_copy_region(pipe,
                                 stfb->surface_mask_view->texture,
                                 0, 0, 0, 0,
                                 old_sampler_view->texture,
                                 0, &src_box);
   }

   /* Free the old texture
    */
   if (old_sampler_view)
      pipe_sampler_view_reference(&old_sampler_view, NULL);
}

static void
vg_context_update_blend_texture_view(struct vg_context *ctx,
                                     uint width, uint height)
{
   struct pipe_context *pipe = ctx->pipe;
   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct pipe_sampler_view *old = stfb->blend_texture_view;

   if (old &&
       old->texture->width0 == width &&
       old->texture->height0 == height)
      return;

   stfb->blend_texture_view = create_tex_and_view(pipe,
         PIPE_FORMAT_B8G8R8A8_UNORM, width, height);

   pipe_sampler_view_reference(&old, NULL);
}

static boolean
vg_context_update_depth_stencil_rb(struct vg_context * ctx,
                                   uint width, uint height)
{
   struct st_renderbuffer *dsrb = ctx->draw_buffer->dsrb;
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_surface surf_tmpl;

   if ((dsrb->width == width && dsrb->height == height) && dsrb->texture)
      return FALSE;

   /* unreference existing ones */
   pipe_surface_reference(&dsrb->surface, NULL);
   pipe_resource_reference(&dsrb->texture, NULL);
   dsrb->width = dsrb->height = 0;

   dsrb->texture = create_texture(pipe, dsrb->format, width, height);
   if (!dsrb->texture)
      return TRUE;

   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   u_surface_default_template(&surf_tmpl, dsrb->texture,
                              PIPE_BIND_DEPTH_STENCIL);
   dsrb->surface = pipe->create_surface(pipe,
                                        dsrb->texture,
                                        &surf_tmpl);
   if (!dsrb->surface) {
      pipe_resource_reference(&dsrb->texture, NULL);
      return TRUE;
a397 27
   dsrb->width = width;
   dsrb->height = height;

   assert(dsrb->surface->width == width);
   assert(dsrb->surface->height == height);

   return TRUE;
}

void vg_validate_state(struct vg_context *ctx)
{
   struct st_framebuffer *stfb = ctx->draw_buffer;

   vg_manager_validate_framebuffer(ctx);

   if (vg_context_update_depth_stencil_rb(ctx, stfb->width, stfb->height))
      ctx->state.dirty |= DEPTH_STENCIL_DIRTY;

   /* blend state depends on fb format */
   if (ctx->state.dirty & FRAMEBUFFER_DIRTY)
      ctx->state.dirty |= BLEND_DIRTY;

   renderer_validate(ctx->renderer, ctx->state.dirty,
         ctx->draw_buffer, &ctx->state.vg);

   ctx->state.dirty = 0;

d400 2
a401 1
   shader_set_color_transform(ctx->shader, ctx->state.vg.color_transform);
d424 1
a424 2
static void vg_prepare_blend_texture(struct vg_context *ctx,
                                     struct pipe_sampler_view *src)
d426 2
d429 1
a429 2
   struct pipe_surface *surf;
   struct pipe_surface surf_tmpl;
d431 2
a432 1
   vg_context_update_blend_texture_view(ctx, stfb->width, stfb->height);
d434 16
a449 11
   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   u_surface_default_template(&surf_tmpl, stfb->blend_texture_view->texture,
                              PIPE_BIND_RENDER_TARGET);
   surf = ctx->pipe->create_surface(ctx->pipe,
                                    stfb->blend_texture_view->texture,
                                    &surf_tmpl);
   if (surf) {
      util_blit_pixels_tex(ctx->blit,
                           src, 0, 0, stfb->width, stfb->height,
                           surf, 0, 0, stfb->width, stfb->height,
                           0.0, PIPE_TEX_MIPFILTER_NEAREST);
d451 2
a452 2
      pipe_surface_reference(&surf, NULL);
   }
d455 2
a456 1
struct pipe_sampler_view *vg_prepare_blend_surface(struct vg_context *ctx)
d458 1
a459 2
   struct pipe_sampler_view *view;
   struct pipe_sampler_view view_templ;
d465 2
a466 2
   u_sampler_view_default_template(&view_templ, strb->texture, strb->texture->format);
   view = pipe->create_sampler_view(pipe, strb->texture, &view_templ);
d468 30
a497 1
   vg_prepare_blend_texture(ctx, view);
d499 1
a499 3
   pipe_sampler_view_reference(&view, NULL);

   return stfb->blend_texture_view;
d503 1
a503 1
struct pipe_sampler_view *vg_prepare_blend_surface_from_mask(struct vg_context *ctx)
d505 6
a510 3
   struct st_framebuffer *stfb = ctx->draw_buffer;

   vg_validate_state(ctx);
d512 1
a512 4
   vg_context_update_surface_mask_view(ctx, stfb->width, stfb->height);
   vg_prepare_blend_texture(ctx, stfb->surface_mask_view);

   return stfb->blend_texture_view;
d515 1
a515 1
struct pipe_sampler_view *vg_get_surface_mask(struct vg_context *ctx)
d517 6
a522 1
   struct st_framebuffer *stfb = ctx->draw_buffer;
d524 1
a524 3
   vg_context_update_surface_mask_view(ctx, stfb->width, stfb->height);

   return stfb->surface_mask_view;
d527 1
a527 7
/**
 * A transformation from window coordinates to paint coordinates.
 */
VGboolean vg_get_paint_matrix(struct vg_context *ctx,
                              const struct matrix *paint_to_user,
                              const struct matrix *user_to_surface,
                              struct matrix *mat)
d529 3
a531 11
   struct matrix tmp;

   /* get user-to-paint matrix */
   memcpy(mat, paint_to_user, sizeof(*paint_to_user));
   if (!matrix_invert(mat))
      return VG_FALSE;

   /* get surface-to-user matrix */
   memcpy(&tmp, user_to_surface, sizeof(*user_to_surface));
   if (!matrix_invert(&tmp))
      return VG_FALSE;
d533 8
a540 1
   matrix_mult(mat, &tmp);
d542 1
a542 1
   return VG_TRUE;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d33 1
a36 1
#include "handle.h"
d43 1
d65 2
a66 2
      PIPE_FORMAT_Z24_UNORM_S8_UINT,
      PIPE_FORMAT_S8_UINT_Z24_UNORM,
d73 1
a73 1
               PIPE_TEXTURE_2D, 0, PIPE_BIND_DEPTH_STENCIL))
a186 9
   obj->handle = create_handle(obj);
}

/** free object resources, but not the object itself */
void vg_free_object(struct vg_object *obj)
{
   obj->type = 0;
   obj->ctx = NULL;
   destroy_handle(obj->handle);
d191 1
a191 1
                                VGHandle handle)
d197 1
a197 1
       return cso_hash_contains(hash, (unsigned) handle);
d203 2
a204 1
                           struct vg_object *obj)
d207 1
a207 1
       struct cso_hash *hash = ctx->owned_objects[obj->type];
d210 1
a210 1
       cso_hash_insert(hash, (unsigned) obj->handle, obj);
d215 2
a216 1
                              struct vg_object *obj)
d219 1
a219 1
      struct cso_hash *hash = ctx->owned_objects[obj->type];
d222 1
a222 1
      cso_hash_take(hash, (unsigned) obj->handle);
d374 3
a376 1
   u_surface_default_template(&surf_tmpl, dsrb->texture);
d403 2
a404 3
   /* blend state depends on fb format and paint color */
   if ((ctx->state.dirty & FRAMEBUFFER_DIRTY) ||
       (ctx->state.dirty & PAINT_DIRTY))
d417 1
a417 1
VGboolean vg_object_is_valid(VGHandle object, enum vg_object_type type)
d419 2
a420 2
   struct vg_object *obj = handle_to_object(object);
   if (obj && is_aligned(obj) && obj->type == type)
d446 3
a448 1
   u_surface_default_template(&surf_tmpl, stfb->blend_texture_view->texture);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d44 1
d141 2
d150 1
d446 2
a447 2
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_blit_info info;
d451 9
a459 22
   memset(&info, 0, sizeof info);
   info.dst.resource = stfb->blend_texture_view->texture;
   info.dst.level = 0;
   info.dst.box.x = 0;
   info.dst.box.y = 0;
   info.dst.box.z = 0;
   info.dst.box.width = stfb->width;
   info.dst.box.height = stfb->height;
   info.dst.box.depth = 1;
   info.dst.format = stfb->blend_texture_view->format;
   info.src.resource = src->texture;
   info.src.level = src->u.tex.first_level;
   info.src.box.x = 0;
   info.src.box.y = 0;
   info.src.box.z = src->u.tex.first_layer;
   info.src.box.width = stfb->width;
   info.src.box.height = stfb->height;
   info.src.box.depth = 1;
   info.src.format = src->format;
   info.mask = PIPE_MASK_RGBA;
   info.filter = PIPE_TEX_MIPFILTER_NEAREST;
   info.scissor_enable = 0;
d461 2
a462 1
   pipe->blit(pipe, &info);
@


