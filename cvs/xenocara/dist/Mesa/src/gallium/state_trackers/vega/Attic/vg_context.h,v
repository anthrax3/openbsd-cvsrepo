head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.38;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.56;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.51;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.20;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#ifndef VG_CONTEXT_H
#define VG_CONTEXT_H

#include "vg_state.h"

#include "pipe/p_format.h"
#include "pipe/p_state.h"
#include "util/u_pointer.h"
#include "util/u_math.h"
#include "state_tracker/st_api.h"

#include "cso_cache/cso_hash.h"
#include "cso_cache/cso_context.h"

struct renderer;
struct shaders_cache;
struct shader;
struct vg_shader;
struct mapi_table;

struct st_renderbuffer {
   enum pipe_format   format;
   struct pipe_surface *surface;
   struct pipe_resource *texture;
   VGint width, height;
};

struct st_framebuffer {
   VGint width, height;
   struct st_renderbuffer *strb;
   struct st_renderbuffer *dsrb;

   struct pipe_sampler_view *surface_mask_view;

   struct pipe_sampler_view *blend_texture_view;


   struct st_framebuffer_iface *iface;
   enum st_attachment_type strb_att;

   void *privateData;
   int32_t stamp;
   int32_t iface_stamp;
};

enum vg_object_type {
   VG_OBJECT_UNKNOWN = 0,
   VG_OBJECT_PAINT,
   VG_OBJECT_IMAGE,
   VG_OBJECT_MASK,
   VG_OBJECT_FONT,
   VG_OBJECT_PATH,

   VG_OBJECT_LAST
};
enum dirty_state {
   BLEND_DIRTY         = 1 << 0,
   FRAMEBUFFER_DIRTY   = 1 << 1,
   DEPTH_STENCIL_DIRTY = 1 << 2,
   PAINT_DIRTY         = 1 << 3,

   ALL_DIRTY           = BLEND_DIRTY |
                         FRAMEBUFFER_DIRTY |
                         DEPTH_STENCIL_DIRTY |
                         PAINT_DIRTY
};

struct vg_context
{
   struct st_context_iface iface;
   struct mapi_table *dispatch;

   struct pipe_context *pipe;
   enum pipe_format ds_format;

   struct {
      struct vg_state vg;
      VGbitfield dirty;
   } state;

   VGErrorCode _error;

   struct st_framebuffer *draw_buffer;

   struct cso_hash *owned_objects[VG_OBJECT_LAST];

   struct {
      struct pipe_resource *cbuf;
      struct pipe_sampler_state sampler;

      struct vg_shader *union_fs;
      struct vg_shader *intersect_fs;
      struct vg_shader *subtract_fs;
      struct vg_shader *set_fs;
   } mask;

   struct cso_context *cso_context;

   struct renderer *renderer;
   struct shaders_cache *sc;
   struct shader *shader;

   struct pipe_sampler_state blend_sampler;
   struct vg_paint *default_paint;

   int32_t draw_stamp;
};


/**
 *  Base class for VG objects like paths, images, fonts.
 */
struct vg_object {
   enum vg_object_type type;
   VGHandle handle;
   struct vg_context *ctx;
};


void vg_init_object(struct vg_object *obj, struct vg_context *ctx, enum vg_object_type type);
void vg_free_object(struct vg_object *obj);

VGboolean vg_object_is_valid(VGHandle object, enum vg_object_type type);

struct vg_context *vg_create_context(struct pipe_context *pipe,
                                     const void *visual,
                                     struct vg_context *share);
void vg_destroy_context(struct vg_context *ctx);
struct vg_context *vg_current_context(void);
void vg_set_current_context(struct vg_context *ctx);

VGboolean vg_context_is_object_valid(struct vg_context *ctx,
                                     enum vg_object_type type,
                                     VGHandle object);
void vg_context_add_object(struct vg_context *ctx,
                           struct vg_object *obj);
void vg_context_remove_object(struct vg_context *ctx,
                              struct vg_object *obj);

void vg_validate_state(struct vg_context *ctx);

void vg_set_error(struct vg_context *ctx,
                  VGErrorCode code);

struct pipe_sampler_view *vg_prepare_blend_surface(struct vg_context *ctx);
struct pipe_sampler_view *vg_prepare_blend_surface_from_mask(struct vg_context *ctx);

struct pipe_sampler_view *vg_get_surface_mask(struct vg_context *ctx);

VGboolean vg_get_paint_matrix(struct vg_context *ctx,
                              const struct matrix *paint_to_user,
                              const struct matrix *user_to_surface,
                              struct matrix *mat);

static INLINE VGboolean is_aligned_to(const void *ptr, VGbyte alignment)
{
   void *aligned = align_pointer(ptr, alignment);
   return (ptr == aligned) ? VG_TRUE : VG_FALSE;
}

static INLINE VGboolean is_aligned(const void *ptr)
{
   return is_aligned_to(ptr, 4);
}

static INLINE void vg_shift_rectx(VGfloat coords[4],
                                 const VGfloat *bounds,
                                 const VGfloat shift)
{
   coords[0] += shift;
   coords[2] -= shift;
   if (bounds) {
      coords[2] = MIN2(coords[2], bounds[2]);
      /* bound x/y + width/height */
      if ((coords[0] + coords[2]) > (bounds[0] + bounds[2])) {
         coords[2] = (bounds[0] + bounds[2]) - coords[0];
      }
   }
}

static INLINE void vg_shift_recty(VGfloat coords[4],
                                 const VGfloat *bounds,
                                 const VGfloat shift)
{
   coords[1] += shift;
   coords[3] -= shift;
   if (bounds) {
      coords[3] = MIN2(coords[3], bounds[3]);
      if ((coords[1] + coords[3]) > (bounds[1] + bounds[3])) {
         coords[3] = (bounds[1] + bounds[3]) - coords[1];
      }
   }
}

static INLINE void vg_bound_rect(VGfloat coords[4],
                                 const VGfloat bounds[4],
                                 VGfloat shift[4])
{
   /* if outside the bounds */
   if (coords[0] > (bounds[0] + bounds[2]) ||
       coords[1] > (bounds[1] + bounds[3]) ||
       (coords[0] + coords[2]) < bounds[0] ||
       (coords[1] + coords[3]) < bounds[1]) {
      coords[0] = 0.f;
      coords[1] = 0.f;
      coords[2] = 0.f;
      coords[3] = 0.f;
      shift[0] = 0.f;
      shift[1] = 0.f;
      return;
   }

   /* bound x */
   if (coords[0] < bounds[0]) {
      shift[0] = bounds[0] - coords[0];
      coords[2] -= shift[0];
      coords[0] = bounds[0];
   } else
      shift[0] = 0.f;

   /* bound y */
   if (coords[1] < bounds[1]) {
      shift[1] = bounds[1] - coords[1];
      coords[3] -= shift[1];
      coords[1] = bounds[1];
   } else
      shift[1] = 0.f;

   shift[2] = bounds[2] - coords[2];
   shift[3] = bounds[3] - coords[3];
   /* bound width/height */
   coords[2] = MIN2(coords[2], bounds[2]);
   coords[3] = MIN2(coords[3], bounds[3]);

   /* bound x/y + width/height */
   if ((coords[0] + coords[2]) > (bounds[0] + bounds[2])) {
      coords[2] = (bounds[0] + bounds[2]) - coords[0];
   }
   if ((coords[1] + coords[3]) > (bounds[1] + bounds[3])) {
      coords[3] = (bounds[1] + bounds[3]) - coords[1];
   }

   /* if outside the bounds */
   if ((coords[0] + coords[2]) < bounds[0] ||
       (coords[1] + coords[3]) < bounds[1]) {
      coords[0] = 0.f;
      coords[1] = 0.f;
      coords[2] = 0.f;
      coords[3] = 0.f;
      return;
   }
}

#endif
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@a131 2
   struct blit_state *blit;

@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d68 2
a109 1
   int32_t draw_buffer_invalid;
d133 2
d164 1
a164 2
                           enum vg_object_type type,
                           void *ptr);
d166 1
a166 2
                              enum vg_object_type type,
                              void *ptr);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d84 1
d88 2
a89 1
                         DEPTH_STENCIL_DIRTY
d134 4
d140 1
d143 2
d146 3
a148 1
VGboolean vg_object_is_valid(void *ptr, enum vg_object_type type);
d159 1
a159 1
                                     void *ptr);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d36 1
d45 1
d50 1
a50 1
   struct pipe_texture *texture;
d59 1
a59 1
   struct pipe_texture *alpha_mask;
d61 5
a65 1
   struct pipe_texture *blend_texture;
d81 7
a87 8
   NONE_DIRTY          = 0<<0,
   BLEND_DIRTY         = 1<<1,
   RASTERIZER_DIRTY    = 1<<2,
   VIEWPORT_DIRTY      = 1<<3,
   VS_DIRTY            = 1<<4,
   DEPTH_STENCIL_DIRTY = 1<<5,
   ALL_DIRTY           = BLEND_DIRTY | RASTERIZER_DIRTY |
   VIEWPORT_DIRTY | VS_DIRTY | DEPTH_STENCIL_DIRTY
d92 3
d96 1
a99 7
      struct {
         struct pipe_blend_state blend;
         struct pipe_rasterizer_state rasterizer;
         struct pipe_shader_state vs_state;
         struct pipe_depth_stencil_alpha_state dsa;
         struct pipe_framebuffer_state fb;
      } g3d;
d106 1
d111 1
a111 9
      struct pipe_shader_state vert_shader;
      struct pipe_shader_state frag_shader;
      struct pipe_rasterizer_state raster;
      void *fs;
      float vertices[4][2][4];  /**< vertex pos + color */
   } clear;

   struct {
      struct pipe_buffer *cbuf;
a119 2
   struct vg_shader *pass_through_depth_fs;

a121 3
   struct pipe_buffer *stencil_quad;
   VGfloat stencil_vertices[4][2][4];

a126 4
   struct {
      struct pipe_buffer *buffer;
      void *color_matrix_fs;
   } filter;
a129 5

   struct vg_shader *plain_vs;
   struct vg_shader *clear_vs;
   struct vg_shader *texture_vs;
   struct pipe_buffer *vs_const_buffer;
d161 2
a162 2
void vg_prepare_blend_surface(struct vg_context *ctx);
void vg_prepare_blend_surface_from_mask(struct vg_context *ctx);
d164 6
a268 9

void *vg_plain_vs(struct vg_context *ctx);
void *vg_clear_vs(struct vg_context *ctx);
void *vg_texture_vs(struct vg_context *ctx);
typedef enum {
   VEGA_Y0_TOP,
   VEGA_Y0_BOTTOM
} VegaOrientation;
void vg_set_viewport(struct vg_context *ctx, VegaOrientation orientation);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a35 1
#include "state_tracker/st_api.h"
a43 1
struct mapi_table;
d48 1
a48 1
   struct pipe_resource *texture;
d57 1
a57 1
   struct pipe_sampler_view *surface_mask_view;
d59 1
a59 5
   struct pipe_sampler_view *blend_texture_view;


   struct st_framebuffer_iface *iface;
   enum st_attachment_type strb_att;
d75 8
a82 7
   BLEND_DIRTY         = 1 << 0,
   FRAMEBUFFER_DIRTY   = 1 << 1,
   DEPTH_STENCIL_DIRTY = 1 << 2,

   ALL_DIRTY           = BLEND_DIRTY |
                         FRAMEBUFFER_DIRTY |
                         DEPTH_STENCIL_DIRTY
a86 3
   struct st_context_iface iface;
   struct mapi_table *dispatch;

a87 1
   enum pipe_format ds_format;
d91 7
a103 1
   int32_t draw_buffer_invalid;
d108 9
a116 1
      struct pipe_resource *cbuf;
d125 2
d129 3
d137 4
d144 5
d180 2
a181 2
struct pipe_sampler_view *vg_prepare_blend_surface(struct vg_context *ctx);
struct pipe_sampler_view *vg_prepare_blend_surface_from_mask(struct vg_context *ctx);
a182 6
struct pipe_sampler_view *vg_get_surface_mask(struct vg_context *ctx);

VGboolean vg_get_paint_matrix(struct vg_context *ctx,
                              const struct matrix *paint_to_user,
                              const struct matrix *user_to_surface,
                              struct matrix *mat);
d282 9
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a67 2
   int32_t stamp;
   int32_t iface_stamp;
a83 1
   PAINT_DIRTY         = 1 << 3,
d87 1
a87 2
                         DEPTH_STENCIL_DIRTY |
                         PAINT_DIRTY
d106 1
a129 2

   int32_t draw_stamp;
a131 4

/**
 *  Base class for VG objects like paths, images, fonts.
 */
a133 1
   VGHandle handle;
a135 2


d137 1
a137 3
void vg_free_object(struct vg_object *obj);

VGboolean vg_object_is_valid(VGHandle object, enum vg_object_type type);
d148 1
a148 1
                                     VGHandle object);
d150 2
a151 1
                           struct vg_object *obj);
d153 2
a154 1
                              struct vg_object *obj);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d132 2
@


