head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.14.01.50;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.22;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "VG/openvg.h"

#include "vg_context.h"
#include "image.h"
#include "api.h"
#include "handle.h"
#include "renderer.h"
#include "shaders_cache.h"

#include "pipe/p_context.h"
#include "pipe/p_state.h"
#include "util/u_inlines.h"
#include "pipe/p_screen.h"

#include "util/u_format.h"
#include "util/u_sampler.h"
#include "util/u_string.h"

#include "asm_filters.h"


struct filter_info {
   struct vg_image *dst;
   struct vg_image *src;
   struct vg_shader * (*setup_shader)(struct vg_context *, void *);
   void *user_data;
   const void *const_buffer;
   VGint const_buffer_len;
   VGTilingMode tiling_mode;
   struct pipe_sampler_view *extra_texture_view;
};

static INLINE struct pipe_resource *create_texture_1d(struct vg_context *ctx,
                                                     const VGuint *color_data,
                                                     const VGint color_data_len)
{
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_screen *screen = pipe->screen;
   struct pipe_resource *tex = 0;
   struct pipe_resource templ;

   memset(&templ, 0, sizeof(templ));
   templ.target = PIPE_TEXTURE_1D;
   templ.format = PIPE_FORMAT_B8G8R8A8_UNORM;
   templ.last_level = 0;
   templ.width0 = color_data_len;
   templ.height0 = 1;
   templ.depth0 = 1;
   templ.array_size = 1;
   templ.bind = PIPE_BIND_SAMPLER_VIEW;

   tex = screen->resource_create(screen, &templ);

   { /* upload color_data */
      struct pipe_transfer *transfer;
      void *map =
         pipe_transfer_map(pipe, tex,
                           0, 0,
                           PIPE_TRANSFER_READ_WRITE ,
                           0, 0, tex->width0, tex->height0,
                           &transfer);
      memcpy(map, color_data, sizeof(VGint)*color_data_len);
      pipe->transfer_unmap(pipe, transfer);
   }

   return tex;
}

static INLINE struct pipe_sampler_view *create_texture_1d_view(struct vg_context *ctx,
                                                               const VGuint *color_data,
                                                               const VGint color_data_len)
{
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_resource *texture;
   struct pipe_sampler_view view_templ;
   struct pipe_sampler_view *view;

   texture = create_texture_1d(ctx, color_data, color_data_len);

   if (!texture)
      return NULL;

   u_sampler_view_default_template(&view_templ, texture, texture->format);
   view = pipe->create_sampler_view(pipe, texture, &view_templ);
   /* want the texture to go away if the view is freed */
   pipe_resource_reference(&texture, NULL);

   return view;
}

static struct vg_shader * setup_color_matrix(struct vg_context *ctx, void *user_data)
{
   struct vg_shader *shader =
      shader_create_from_text(ctx->pipe, color_matrix_asm, 200,
         PIPE_SHADER_FRAGMENT);
   return shader;
}

static struct vg_shader * setup_convolution(struct vg_context *ctx, void *user_data)
{
   char buffer[1024];
   VGint num_consts = (VGint)(long)(user_data);
   struct vg_shader *shader;

   util_snprintf(buffer, 1023, convolution_asm, num_consts, num_consts / 2 + 1);

   shader = shader_create_from_text(ctx->pipe, buffer, 200,
                                    PIPE_SHADER_FRAGMENT);

   return shader;
}

static struct vg_shader * setup_lookup(struct vg_context *ctx, void *user_data)
{
   struct vg_shader *shader =
      shader_create_from_text(ctx->pipe, lookup_asm,
                              200, PIPE_SHADER_FRAGMENT);

   return shader;
}


static struct vg_shader * setup_lookup_single(struct vg_context *ctx, void *user_data)
{
   char buffer[1024];
   VGImageChannel channel = (VGImageChannel)(user_data);
   struct vg_shader *shader;

   switch(channel) {
   case VG_RED:
      util_snprintf(buffer, 1023, lookup_single_asm, "xxxx");
      break;
   case VG_GREEN:
      util_snprintf(buffer, 1023, lookup_single_asm, "yyyy");
      break;
   case VG_BLUE:
      util_snprintf(buffer, 1023, lookup_single_asm, "zzzz");
      break;
   case VG_ALPHA:
      util_snprintf(buffer, 1023, lookup_single_asm, "wwww");
      break;
   default:
      debug_assert(!"Unknown color channel");
   }

   shader = shader_create_from_text(ctx->pipe, buffer, 200,
                                    PIPE_SHADER_FRAGMENT);

   return shader;
}

static void execute_filter(struct vg_context *ctx,
                           struct filter_info *info)
{
   struct vg_shader *shader;
   const struct pipe_sampler_state *samplers[2];
   struct pipe_sampler_view *views[2];
   struct pipe_sampler_state sampler;
   uint tex_wrap;

   memset(&sampler, 0, sizeof(sampler));
   sampler.min_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler.mag_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
   sampler.normalized_coords = 1;

   switch (info->tiling_mode) {
   case VG_TILE_FILL:
      tex_wrap = PIPE_TEX_WRAP_CLAMP_TO_BORDER;
      /* copy border color */
      memcpy(sampler.border_color.f, ctx->state.vg.tile_fill_color,
            sizeof(sampler.border_color));
      break;
   case VG_TILE_PAD:
      tex_wrap = PIPE_TEX_WRAP_CLAMP_TO_EDGE;;
      break;
   case VG_TILE_REPEAT:
      tex_wrap = PIPE_TEX_WRAP_REPEAT;;
      break;
   case VG_TILE_REFLECT:
      tex_wrap = PIPE_TEX_WRAP_MIRROR_REPEAT;
      break;
   default:
      debug_assert(!"Unknown tiling mode");
      tex_wrap = 0;
      break;
   }

   sampler.wrap_s = tex_wrap;
   sampler.wrap_t = tex_wrap;
   sampler.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;

   samplers[0] = samplers[1] = &sampler;
   views[0] = info->src->sampler_view;
   views[1] = info->extra_texture_view;

   shader = info->setup_shader(ctx, info->user_data);

   if (renderer_filter_begin(ctx->renderer,
            info->dst->sampler_view->texture, VG_TRUE,
            ctx->state.vg.filter_channel_mask,
            samplers, views, (info->extra_texture_view) ? 2 : 1,
            shader->driver, info->const_buffer, info->const_buffer_len)) {
      renderer_filter(ctx->renderer,
            info->dst->x, info->dst->y, info->dst->width, info->dst->height,
            info->src->x, info->src->y, info->src->width, info->src->height);
      renderer_filter_end(ctx->renderer);
   }

   vg_shader_destroy(ctx, shader);
}

void vegaColorMatrix(VGImage dst, VGImage src,
                     const VGfloat * matrix)
{
   struct vg_context *ctx = vg_current_context();
   struct vg_image *d, *s;
   struct filter_info info;

   if (dst == VG_INVALID_HANDLE || src == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (!matrix || !is_aligned(matrix)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   d = handle_to_image(dst);
   s = handle_to_image(src);

   if (vg_image_overlaps(d, s)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   info.dst = d;
   info.src = s;
   info.setup_shader = &setup_color_matrix;
   info.user_data = NULL;
   info.const_buffer = matrix;
   info.const_buffer_len = 20 * sizeof(VGfloat);
   info.tiling_mode = VG_TILE_PAD;
   info.extra_texture_view = NULL;
   execute_filter(ctx, &info);
}

static VGfloat texture_offset(VGfloat width, VGint kernelSize, VGint current, VGint shift)
{
   VGfloat diff = (VGfloat) (current - shift);

   return diff / width;
}

void vegaConvolve(VGImage dst, VGImage src,
                  VGint kernelWidth, VGint kernelHeight,
                  VGint shiftX, VGint shiftY,
                  const VGshort * kernel,
                  VGfloat scale,
                  VGfloat bias,
                  VGTilingMode tilingMode)
{
   struct vg_context *ctx = vg_current_context();
   VGfloat *buffer;
   VGint buffer_len;
   VGint i, j;
   VGint idx = 0;
   struct vg_image *d, *s;
   VGint kernel_size = kernelWidth * kernelHeight;
   struct filter_info info;
   const VGint max_kernel_size = vegaGeti(VG_MAX_KERNEL_SIZE);

   if (dst == VG_INVALID_HANDLE || src == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   if (kernelWidth <= 0 || kernelHeight <= 0 ||
      kernelWidth > max_kernel_size || kernelHeight > max_kernel_size) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (!kernel || !is_aligned_to(kernel, 2)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (tilingMode < VG_TILE_FILL ||
       tilingMode > VG_TILE_REFLECT) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   d = handle_to_image(dst);
   s = handle_to_image(src);

   if (vg_image_overlaps(d, s)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   vg_validate_state(ctx);

   buffer_len = 8 + 2 * 4 * kernel_size;
   buffer = malloc(buffer_len * sizeof(VGfloat));

   buffer[0] = 0.f;
   buffer[1] = 1.f;
   buffer[2] = 2.f; /*unused*/
   buffer[3] = 4.f; /*unused*/

   buffer[4] = (VGfloat) (kernelWidth * kernelHeight);
   buffer[5] = scale;
   buffer[6] = bias;
   buffer[7] = 0.f;

   idx = 8;
   for (j = 0; j < kernelHeight; ++j) {
      for (i = 0; i < kernelWidth; ++i) {
         VGint index = j * kernelWidth + i;
         VGfloat x, y;

         x = (VGfloat) texture_offset(s->width, kernelWidth, i, shiftX);
         y = (VGfloat) texture_offset(s->height, kernelHeight, j, shiftY);

         buffer[idx + index*4 + 0] = x;
         buffer[idx + index*4 + 1] = y;
         buffer[idx + index*4 + 2] = 0.f;
         buffer[idx + index*4 + 3] = 0.f;
      }
   }
   idx += kernel_size * 4;

   for (j = 0; j < kernelHeight; ++j) {
      for (i = 0; i < kernelWidth; ++i) {
         /* transpose the kernel */
         VGint index = j * kernelWidth + i;
         VGint kindex = (kernelWidth - i - 1) * kernelHeight + (kernelHeight - j - 1);
         buffer[idx + index*4 + 0] = kernel[kindex];
         buffer[idx + index*4 + 1] = kernel[kindex];
         buffer[idx + index*4 + 2] = kernel[kindex];
         buffer[idx + index*4 + 3] = kernel[kindex];
      }
   }

   info.dst = d;
   info.src = s;
   info.setup_shader = &setup_convolution;
   info.user_data = (void*)(long)(buffer_len/4);
   info.const_buffer = buffer;
   info.const_buffer_len = buffer_len * sizeof(VGfloat);
   info.tiling_mode = tilingMode;
   info.extra_texture_view = NULL;
   execute_filter(ctx, &info);

   free(buffer);
}

void vegaSeparableConvolve(VGImage dst, VGImage src,
                           VGint kernelWidth,
                           VGint kernelHeight,
                           VGint shiftX, VGint shiftY,
                           const VGshort * kernelX,
                           const VGshort * kernelY,
                           VGfloat scale,
                           VGfloat bias,
                           VGTilingMode tilingMode)
{
   struct vg_context *ctx = vg_current_context();
   VGshort *kernel;
   VGint i, j, idx = 0;
   const VGint max_kernel_size = vegaGeti(VG_MAX_SEPARABLE_KERNEL_SIZE);

   if (dst == VG_INVALID_HANDLE || src == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   if (kernelWidth <= 0 || kernelHeight <= 0 ||
       kernelWidth > max_kernel_size || kernelHeight > max_kernel_size) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (!kernelX || !kernelY ||
       !is_aligned_to(kernelX, 2) || !is_aligned_to(kernelY, 2)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if (tilingMode < VG_TILE_FILL ||
       tilingMode > VG_TILE_REFLECT) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   kernel = malloc(sizeof(VGshort)*kernelWidth*kernelHeight);
   for (i = 0; i < kernelWidth; ++i) {
      for (j = 0; j < kernelHeight; ++j) {
         kernel[idx] = kernelX[i] * kernelY[j];
         ++idx;
      }
   }
   vegaConvolve(dst, src, kernelWidth, kernelHeight, shiftX, shiftY,
                kernel, scale, bias, tilingMode);
   free(kernel);
}

static INLINE VGfloat compute_gaussian_componenet(VGfloat x, VGfloat y,
                                                  VGfloat stdDeviationX,
                                                  VGfloat stdDeviationY)
{
   VGfloat mult = 1 / ( 2 * M_PI * stdDeviationX * stdDeviationY);
   VGfloat e = exp( - ( pow(x, 2)/(2*pow(stdDeviationX, 2)) +
                        pow(y, 2)/(2*pow(stdDeviationY, 2)) ) );
   return mult * e;
}

static INLINE VGint compute_kernel_size(VGfloat deviation)
{
   VGint size = ceil(2.146 * deviation);
   if (size > 11)
      return 11;
   return size;
}

static void compute_gaussian_kernel(VGfloat *kernel,
                                    VGint width, VGint height,
                                    VGfloat stdDeviationX,
                                    VGfloat stdDeviationY)
{
   VGint i, j;
   VGfloat scale = 0.0f;

   for (j = 0; j < height; ++j) {
      for (i = 0; i < width; ++i) {
         VGint idx =  (height - j -1) * width + (width - i -1);
         kernel[idx] = compute_gaussian_componenet(i-(ceil(width/2))-1,
                                                   j-ceil(height/2)-1,
                                                   stdDeviationX, stdDeviationY);
         scale += kernel[idx];
      }
   }

   for (j = 0; j < height; ++j) {
      for (i = 0; i < width; ++i) {
         VGint idx = j * width + i;
         kernel[idx] /= scale;
      }
   }
}

void vegaGaussianBlur(VGImage dst, VGImage src,
                      VGfloat stdDeviationX,
                      VGfloat stdDeviationY,
                      VGTilingMode tilingMode)
{
   struct vg_context *ctx = vg_current_context();
   struct vg_image *d, *s;
   VGfloat *buffer, *kernel;
   VGint kernel_width, kernel_height, kernel_size;
   VGint buffer_len;
   VGint idx, i, j;
   struct filter_info info;

   if (dst == VG_INVALID_HANDLE || src == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (stdDeviationX <= 0 || stdDeviationY <= 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (tilingMode < VG_TILE_FILL ||
       tilingMode > VG_TILE_REFLECT) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   d = handle_to_image(dst);
   s = handle_to_image(src);

   if (vg_image_overlaps(d, s)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   kernel_width = compute_kernel_size(stdDeviationX);
   kernel_height = compute_kernel_size(stdDeviationY);
   kernel_size = kernel_width * kernel_height;
   kernel = malloc(sizeof(VGfloat)*kernel_size);
   compute_gaussian_kernel(kernel, kernel_width, kernel_height,
                           stdDeviationX, stdDeviationY);

   buffer_len = 8 + 2 * 4 * kernel_size;
   buffer = malloc(buffer_len * sizeof(VGfloat));

   buffer[0] = 0.f;
   buffer[1] = 1.f;
   buffer[2] = 2.f; /*unused*/
   buffer[3] = 4.f; /*unused*/

   buffer[4] = kernel_width * kernel_height;
   buffer[5] = 1.f;/*scale*/
   buffer[6] = 0.f;/*bias*/
   buffer[7] = 0.f;

   idx = 8;
   for (j = 0; j < kernel_height; ++j) {
      for (i = 0; i < kernel_width; ++i) {
         VGint index = j * kernel_width + i;
         VGfloat x, y;

         x = texture_offset(s->width, kernel_width, i, kernel_width/2);
         y = texture_offset(s->height, kernel_height, j, kernel_height/2);

         buffer[idx + index*4 + 0] = x;
         buffer[idx + index*4 + 1] = y;
         buffer[idx + index*4 + 2] = 0.f;
         buffer[idx + index*4 + 3] = 0.f;
      }
   }
   idx += kernel_size * 4;

   for (j = 0; j < kernel_height; ++j) {
      for (i = 0; i < kernel_width; ++i) {
         /* transpose the kernel */
         VGint index = j * kernel_width + i;
         VGint kindex = (kernel_width - i - 1) * kernel_height + (kernel_height - j - 1);
         buffer[idx + index*4 + 0] = kernel[kindex];
         buffer[idx + index*4 + 1] = kernel[kindex];
         buffer[idx + index*4 + 2] = kernel[kindex];
         buffer[idx + index*4 + 3] = kernel[kindex];
      }
   }

   info.dst = d;
   info.src = s;
   info.setup_shader = &setup_convolution;
   info.user_data = (void*)(long)(buffer_len/4);
   info.const_buffer = buffer;
   info.const_buffer_len = buffer_len * sizeof(VGfloat);
   info.tiling_mode = tilingMode;
   info.extra_texture_view = NULL;
   execute_filter(ctx, &info);

   free(buffer);
   free(kernel);
}

void vegaLookup(VGImage dst, VGImage src,
                const VGubyte * redLUT,
                const VGubyte * greenLUT,
                const VGubyte * blueLUT,
                const VGubyte * alphaLUT,
                VGboolean outputLinear,
                VGboolean outputPremultiplied)
{
   struct vg_context *ctx = vg_current_context();
   struct vg_image *d, *s;
   VGuint color_data[256];
   VGint i;
   struct pipe_sampler_view *lut_texture_view;
   VGfloat buffer[4];
   struct filter_info info;

   if (dst == VG_INVALID_HANDLE || src == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   if (!redLUT || !greenLUT || !blueLUT || !alphaLUT) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   d = handle_to_image(dst);
   s = handle_to_image(src);

   if (vg_image_overlaps(d, s)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   for (i = 0; i < 256; ++i) {
      color_data[i] = blueLUT[i] << 24 | greenLUT[i] << 16 |
                      redLUT[i]  <<  8 | alphaLUT[i];
   }
   lut_texture_view = create_texture_1d_view(ctx, color_data, 255);

   buffer[0] = 0.f;
   buffer[1] = 0.f;
   buffer[2] = 1.f;
   buffer[3] = 1.f;

   info.dst = d;
   info.src = s;
   info.setup_shader = &setup_lookup;
   info.user_data = NULL;
   info.const_buffer = buffer;
   info.const_buffer_len = 4 * sizeof(VGfloat);
   info.tiling_mode = VG_TILE_PAD;
   info.extra_texture_view = lut_texture_view;

   execute_filter(ctx, &info);

   pipe_sampler_view_reference(&lut_texture_view, NULL);
}

void vegaLookupSingle(VGImage dst, VGImage src,
                      const VGuint * lookupTable,
                      VGImageChannel sourceChannel,
                      VGboolean outputLinear,
                      VGboolean outputPremultiplied)
{
   struct vg_context *ctx = vg_current_context();
   struct vg_image *d, *s;
   struct pipe_sampler_view *lut_texture_view;
   VGfloat buffer[4];
   struct filter_info info;
   VGuint color_data[256];
   VGint i;

   if (dst == VG_INVALID_HANDLE || src == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   if (!lookupTable || !is_aligned(lookupTable)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (sourceChannel != VG_RED && sourceChannel != VG_GREEN &&
       sourceChannel != VG_BLUE && sourceChannel != VG_ALPHA) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   d = handle_to_image(dst);
   s = handle_to_image(src);

   if (vg_image_overlaps(d, s)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   vg_validate_state(ctx);

   for (i = 0; i < 256; ++i) {
      VGuint rgba = lookupTable[i];
      VGubyte blue, green, red, alpha;
      red   = (rgba & 0xff000000)>>24;
      green = (rgba & 0x00ff0000)>>16;
      blue  = (rgba & 0x0000ff00)>> 8;
      alpha = (rgba & 0x000000ff)>> 0;
      color_data[i] = blue << 24 | green << 16 |
                      red  <<  8 | alpha;
   }
   lut_texture_view = create_texture_1d_view(ctx, color_data, 256);

   buffer[0] = 0.f;
   buffer[1] = 0.f;
   buffer[2] = 1.f;
   buffer[3] = 1.f;

   info.dst = d;
   info.src = s;
   info.setup_shader = &setup_lookup_single;
   info.user_data = (void*)sourceChannel;
   info.const_buffer = buffer;
   info.const_buffer_len = 4 * sizeof(VGfloat);
   info.tiling_mode = VG_TILE_PAD;
   info.extra_texture_view = lut_texture_view;

   execute_filter(ctx, &info);

   pipe_sampler_view_reference(&lut_texture_view, NULL);
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d81 3
a83 2
      struct pipe_transfer *transfer =
         pipe_get_transfer(pipe, tex,
d86 2
a87 2
                           0, 0, tex->width0, tex->height0);
      void *map = pipe->transfer_map(pipe, transfer);
a89 1
      pipe->transfer_destroy(pipe, transfer);
d197 1
a197 1
      memcpy(sampler.border_color, ctx->state.vg.tile_fill_color,
d276 1
a276 1
   VGfloat diff = current - shift;
d332 1
a332 1
   buffer = (VGfloat*)malloc(buffer_len * sizeof(VGfloat));
d339 1
a339 1
   buffer[4] = kernelWidth * kernelHeight;
d350 2
a351 2
         x = texture_offset(s->width, kernelWidth, i, shiftX);
         y = texture_offset(s->height, kernelHeight, j, shiftY);
d522 1
a522 1
   buffer = (VGfloat*)malloc(buffer_len * sizeof(VGfloat));
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d32 1
d255 2
a256 2
   d = (struct vg_image*)dst;
   s = (struct vg_image*)src;
d297 1
a297 1
   const VGint max_kernel_size = vgGeti(VG_MAX_KERNEL_SIZE);
d321 2
a322 2
   d = (struct vg_image*)dst;
   s = (struct vg_image*)src;
d399 1
a399 1
   const VGint max_kernel_size = vgGeti(VG_MAX_SEPARABLE_KERNEL_SIZE);
d429 2
a430 2
   vgConvolve(dst, src, kernelWidth, kernelHeight, shiftX, shiftY,
              kernel, scale, bias, tilingMode);
d506 2
a507 2
   d = (struct vg_image*)dst;
   s = (struct vg_image*)src;
d603 2
a604 2
   d = (struct vg_image*)dst;
   s = (struct vg_image*)src;
d666 2
a667 2
   d = (struct vg_image*)dst;
   s = (struct vg_image*)src;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a33 1
#include "st_inlines.h"
a38 1
#include "pipe/p_shader_tokens.h"
d41 2
a42 2
#include "util/u_memory.h"

d55 1
a55 1
   struct pipe_texture *extra_texture;
d58 1
a58 1
static INLINE struct pipe_texture *create_texture_1d(struct vg_context *ctx,
d64 2
a65 2
   struct pipe_texture *tex = 0;
   struct pipe_texture templ;
d74 2
a75 1
   templ.tex_usage = PIPE_TEXTURE_USAGE_SAMPLER;
d77 1
a77 1
   tex = screen->texture_create(screen, &templ);
d81 5
a85 5
         screen->get_tex_transfer(screen, tex,
                                  0, 0, 0,
                                  PIPE_TRANSFER_READ_WRITE ,
                                  0, 0, tex->width0, tex->height0);
      void *map = screen->transfer_map(screen, transfer);
d87 2
a88 2
      screen->transfer_unmap(screen, transfer);
      screen->tex_transfer_destroy(transfer);
d94 3
a96 1
static INLINE struct pipe_surface * setup_framebuffer(struct vg_image *dst)
a97 1
   struct vg_context *ctx = vg_current_context();
d99 3
a101 26
   struct pipe_framebuffer_state fb;
   struct pipe_surface *dst_surf = pipe->screen->get_tex_surface(
      pipe->screen, dst->texture, 0, 0, 0,
      PIPE_BUFFER_USAGE_GPU_WRITE);

   /* drawing dest */
   memset(&fb, 0, sizeof(fb));
   fb.width  = dst->x + dst_surf->width;
   fb.height = dst->y + dst_surf->height;
   fb.nr_cbufs = 1;
   fb.cbufs[0] = dst_surf;
   {
      VGint i;
      for (i = 1; i < PIPE_MAX_COLOR_BUFS; ++i)
         fb.cbufs[i] = 0;
   }
   cso_set_framebuffer(ctx->cso_context, &fb);

   return dst_surf;
}

static void setup_viewport(struct vg_image *dst)
{
   struct vg_context *ctx = vg_current_context();
   vg_set_viewport(ctx, VEGA_Y0_TOP);
}
d103 1
a103 20
static void setup_blend()
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_blend_state blend;
   memset(&blend, 0, sizeof(blend));
   blend.rt[0].rgb_src_factor = PIPE_BLENDFACTOR_ONE;
   blend.rt[0].alpha_src_factor = PIPE_BLENDFACTOR_ONE;
   blend.rt[0].rgb_dst_factor = PIPE_BLENDFACTOR_ZERO;
   blend.rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_ZERO;
   if (ctx->state.vg.filter_channel_mask & VG_RED)
      blend.rt[0].colormask |= PIPE_MASK_R;
   if (ctx->state.vg.filter_channel_mask & VG_GREEN)
      blend.rt[0].colormask |= PIPE_MASK_G;
   if (ctx->state.vg.filter_channel_mask & VG_BLUE)
      blend.rt[0].colormask |= PIPE_MASK_B;
   if (ctx->state.vg.filter_channel_mask & VG_ALPHA)
      blend.rt[0].colormask |= PIPE_MASK_A;
   blend.rt[0].blend_enable = 0;
   cso_set_blend(ctx->cso_context, &blend);
}
d105 2
a106 5
static void setup_constant_buffer(struct vg_context *ctx, const void *buffer,
                                  VGint param_bytes)
{
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_buffer **cbuf = &ctx->filter.buffer;
d108 4
a111 40
   /* We always need to get a new buffer, to keep the drivers simple and
    * avoid gratuitous rendering synchronization. */
   pipe_buffer_reference(cbuf, NULL);

   *cbuf = pipe_buffer_create(pipe->screen, 16,
                              PIPE_BUFFER_USAGE_CONSTANT,
                              param_bytes);

   if (*cbuf) {
      st_no_flush_pipe_buffer_write(ctx, *cbuf,
                                    0, param_bytes, buffer);
   }

   ctx->pipe->set_constant_buffer(ctx->pipe, PIPE_SHADER_FRAGMENT, 0, *cbuf);
}

static void setup_samplers(struct vg_context *ctx, struct filter_info *info)
{
   struct pipe_sampler_state *samplers[PIPE_MAX_SAMPLERS];
   struct pipe_texture *textures[PIPE_MAX_SAMPLERS];
   struct pipe_sampler_state sampler[3];
   int num_samplers = 0;
   int num_textures = 0;

   samplers[0] = NULL;
   samplers[1] = NULL;
   samplers[2] = NULL;
   samplers[3] = NULL;
   textures[0] = NULL;
   textures[1] = NULL;
   textures[2] = NULL;
   textures[3] = NULL;

   memset(&sampler[0], 0, sizeof(struct pipe_sampler_state));
   sampler[0].wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler[0].wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler[0].wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler[0].min_img_filter = PIPE_TEX_MIPFILTER_LINEAR;
   sampler[0].mag_img_filter = PIPE_TEX_MIPFILTER_LINEAR;
   sampler[0].normalized_coords = 1;
d113 1
a113 40
   switch(info->tiling_mode) {
   case VG_TILE_FILL:
      sampler[0].wrap_s = PIPE_TEX_WRAP_CLAMP_TO_BORDER;
      sampler[0].wrap_t = PIPE_TEX_WRAP_CLAMP_TO_BORDER;
      memcpy(sampler[0].border_color,
             ctx->state.vg.tile_fill_color,
             sizeof(VGfloat) * 4);
      break;
   case VG_TILE_PAD:
      sampler[0].wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
      sampler[0].wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
      break;
   case VG_TILE_REPEAT:
      sampler[0].wrap_s = PIPE_TEX_WRAP_REPEAT;
      sampler[0].wrap_t = PIPE_TEX_WRAP_REPEAT;
      break;
   case VG_TILE_REFLECT:
      sampler[0].wrap_s = PIPE_TEX_WRAP_MIRROR_REPEAT;
      sampler[0].wrap_t = PIPE_TEX_WRAP_MIRROR_REPEAT;
      break;
   default:
      debug_assert(!"Unknown tiling mode");
   }

   samplers[0] = &sampler[0];
   textures[0] = info->src->texture;
   ++num_samplers;
   ++num_textures;

   if (info->extra_texture) {
      memcpy(&sampler[1], &sampler[0], sizeof(struct pipe_sampler_state));
      samplers[1] = &sampler[1];
      textures[1] = info->extra_texture;
      ++num_samplers;
      ++num_textures;
   }


   cso_set_samplers(ctx->cso_context, num_samplers, (const struct pipe_sampler_state **)samplers);
   cso_set_sampler_textures(ctx->cso_context, num_textures, textures);
a120 1
   cso_set_fragment_shader_handle(ctx->cso_context, shader->driver);
d130 1
a130 1
   snprintf(buffer, 1023, convolution_asm, num_consts, num_consts / 2 + 1);
a134 1
   cso_set_fragment_shader_handle(ctx->cso_context, shader->driver);
a143 1
   cso_set_fragment_shader_handle(ctx->cso_context, shader->driver);
d156 1
a156 1
      snprintf(buffer, 1023, lookup_single_asm, "xxxx");
d159 1
a159 1
      snprintf(buffer, 1023, lookup_single_asm, "yyyy");
d162 1
a162 1
      snprintf(buffer, 1023, lookup_single_asm, "zzzz");
d165 1
a165 1
      snprintf(buffer, 1023, lookup_single_asm, "wwww");
a173 1
   cso_set_fragment_shader_handle(ctx->cso_context, shader->driver);
a179 1
   struct pipe_surface *dst_surf;
d181 40
a221 11
   cso_save_framebuffer(ctx->cso_context);
   cso_save_fragment_shader(ctx->cso_context);
   cso_save_viewport(ctx->cso_context);
   cso_save_blend(ctx->cso_context);
   cso_save_samplers(ctx->cso_context);
   cso_save_sampler_textures(ctx->cso_context);

   dst_surf = setup_framebuffer(info->dst);
   setup_viewport(info->dst);
   setup_blend();
   setup_constant_buffer(ctx, info->const_buffer, info->const_buffer_len);
a222 1
   setup_samplers(ctx, info);
d224 10
a233 15
   renderer_draw_texture(ctx->renderer,
                         info->src->texture,
                         info->dst->x, info->dst->y,
                         info->dst->x + info->dst->width,
                         info->dst->y + info->dst->height,
                         info->dst->x, info->dst->y,
                         info->dst->x + info->dst->width,
                         info->dst->y + info->dst->height);

   cso_restore_framebuffer(ctx->cso_context);
   cso_restore_fragment_shader(ctx->cso_context);
   cso_restore_viewport(ctx->cso_context);
   cso_restore_blend(ctx->cso_context);
   cso_restore_samplers(ctx->cso_context);
   cso_restore_sampler_textures(ctx->cso_context);
a235 2

   pipe_surface_reference(&dst_surf, NULL);
d238 2
a239 2
void vgColorMatrix(VGImage dst, VGImage src,
                   const VGfloat * matrix)
d269 1
a269 1
   info.extra_texture = 0;
d280 7
a286 7
void vgConvolve(VGImage dst, VGImage src,
                VGint kernelWidth, VGint kernelHeight,
                VGint shiftX, VGint shiftY,
                const VGshort * kernel,
                VGfloat scale,
                VGfloat bias,
                VGTilingMode tilingMode)
d379 1
a379 1
   info.extra_texture = 0;
d385 9
a393 9
void vgSeparableConvolve(VGImage dst, VGImage src,
                         VGint kernelWidth,
                         VGint kernelHeight,
                         VGint shiftX, VGint shiftY,
                         const VGshort * kernelX,
                         const VGshort * kernelY,
                         VGfloat scale,
                         VGfloat bias,
                         VGTilingMode tilingMode)
d477 4
a480 4
void vgGaussianBlur(VGImage dst, VGImage src,
                    VGfloat stdDeviationX,
                    VGfloat stdDeviationY,
                    VGTilingMode tilingMode)
d569 1
a569 1
   info.extra_texture = 0;
d576 7
a582 7
void vgLookup(VGImage dst, VGImage src,
              const VGubyte * redLUT,
              const VGubyte * greenLUT,
              const VGubyte * blueLUT,
              const VGubyte * alphaLUT,
              VGboolean outputLinear,
              VGboolean outputPremultiplied)
d588 1
a588 1
   struct pipe_texture *lut_texture;
d614 1
a614 1
   lut_texture = create_texture_1d(ctx, color_data, 255);
d628 1
a628 1
   info.extra_texture = lut_texture;
d632 1
a632 1
   pipe_texture_reference(&lut_texture, NULL);
d635 5
a639 5
void vgLookupSingle(VGImage dst, VGImage src,
                    const VGuint * lookupTable,
                    VGImageChannel sourceChannel,
                    VGboolean outputLinear,
                    VGboolean outputPremultiplied)
d643 1
a643 1
   struct pipe_texture *lut_texture;
d673 2
d685 1
a685 1
   lut_texture = create_texture_1d(ctx, color_data, 256);
d699 1
a699 1
   info.extra_texture = lut_texture;
d703 1
a703 1
   pipe_texture_reference(&lut_texture, NULL);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a30 1
#include "api.h"
d33 1
d39 1
d42 2
a43 2
#include "util/u_sampler.h"
#include "util/u_string.h"
d56 1
a56 1
   struct pipe_sampler_view *extra_texture_view;
d59 1
a59 1
static INLINE struct pipe_resource *create_texture_1d(struct vg_context *ctx,
d65 2
a66 2
   struct pipe_resource *tex = 0;
   struct pipe_resource templ;
d75 1
a75 2
   templ.array_size = 1;
   templ.bind = PIPE_BIND_SAMPLER_VIEW;
d77 1
a77 1
   tex = screen->resource_create(screen, &templ);
d81 5
a85 5
         pipe_get_transfer(pipe, tex,
                           0, 0,
                           PIPE_TRANSFER_READ_WRITE ,
                           0, 0, tex->width0, tex->height0);
      void *map = pipe->transfer_map(pipe, transfer);
d87 2
a88 2
      pipe->transfer_unmap(pipe, transfer);
      pipe->transfer_destroy(pipe, transfer);
d94 1
a94 3
static INLINE struct pipe_sampler_view *create_texture_1d_view(struct vg_context *ctx,
                                                               const VGuint *color_data,
                                                               const VGint color_data_len)
d96 1
d98 26
a123 3
   struct pipe_resource *texture;
   struct pipe_sampler_view view_templ;
   struct pipe_sampler_view *view;
d125 20
a144 1
   texture = create_texture_1d(ctx, color_data, color_data_len);
d146 5
a150 2
   if (!texture)
      return NULL;
d152 40
a191 4
   u_sampler_view_default_template(&view_templ, texture, texture->format);
   view = pipe->create_sampler_view(pipe, texture, &view_templ);
   /* want the texture to go away if the view is freed */
   pipe_resource_reference(&texture, NULL);
d193 40
a232 1
   return view;
d240 1
d250 1
a250 1
   util_snprintf(buffer, 1023, convolution_asm, num_consts, num_consts / 2 + 1);
d255 1
d265 1
d278 1
a278 1
      util_snprintf(buffer, 1023, lookup_single_asm, "xxxx");
d281 1
a281 1
      util_snprintf(buffer, 1023, lookup_single_asm, "yyyy");
d284 1
a284 1
      util_snprintf(buffer, 1023, lookup_single_asm, "zzzz");
d287 1
a287 1
      util_snprintf(buffer, 1023, lookup_single_asm, "wwww");
d296 1
d303 1
a304 40
   const struct pipe_sampler_state *samplers[2];
   struct pipe_sampler_view *views[2];
   struct pipe_sampler_state sampler;
   uint tex_wrap;

   memset(&sampler, 0, sizeof(sampler));
   sampler.min_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler.mag_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
   sampler.normalized_coords = 1;

   switch (info->tiling_mode) {
   case VG_TILE_FILL:
      tex_wrap = PIPE_TEX_WRAP_CLAMP_TO_BORDER;
      /* copy border color */
      memcpy(sampler.border_color, ctx->state.vg.tile_fill_color,
            sizeof(sampler.border_color));
      break;
   case VG_TILE_PAD:
      tex_wrap = PIPE_TEX_WRAP_CLAMP_TO_EDGE;;
      break;
   case VG_TILE_REPEAT:
      tex_wrap = PIPE_TEX_WRAP_REPEAT;;
      break;
   case VG_TILE_REFLECT:
      tex_wrap = PIPE_TEX_WRAP_MIRROR_REPEAT;
      break;
   default:
      debug_assert(!"Unknown tiling mode");
      tex_wrap = 0;
      break;
   }

   sampler.wrap_s = tex_wrap;
   sampler.wrap_t = tex_wrap;
   sampler.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;

   samplers[0] = samplers[1] = &sampler;
   views[0] = info->src->sampler_view;
   views[1] = info->extra_texture_view;
d306 11
d318 1
d320 15
a334 10
   if (renderer_filter_begin(ctx->renderer,
            info->dst->sampler_view->texture, VG_TRUE,
            ctx->state.vg.filter_channel_mask,
            samplers, views, (info->extra_texture_view) ? 2 : 1,
            shader->driver, info->const_buffer, info->const_buffer_len)) {
      renderer_filter(ctx->renderer,
            info->dst->x, info->dst->y, info->dst->width, info->dst->height,
            info->src->x, info->src->y, info->src->width, info->src->height);
      renderer_filter_end(ctx->renderer);
   }
d337 2
d341 2
a342 2
void vegaColorMatrix(VGImage dst, VGImage src,
                     const VGfloat * matrix)
d372 1
a372 1
   info.extra_texture_view = NULL;
d383 7
a389 7
void vegaConvolve(VGImage dst, VGImage src,
                  VGint kernelWidth, VGint kernelHeight,
                  VGint shiftX, VGint shiftY,
                  const VGshort * kernel,
                  VGfloat scale,
                  VGfloat bias,
                  VGTilingMode tilingMode)
d482 1
a482 1
   info.extra_texture_view = NULL;
d488 9
a496 9
void vegaSeparableConvolve(VGImage dst, VGImage src,
                           VGint kernelWidth,
                           VGint kernelHeight,
                           VGint shiftX, VGint shiftY,
                           const VGshort * kernelX,
                           const VGshort * kernelY,
                           VGfloat scale,
                           VGfloat bias,
                           VGTilingMode tilingMode)
d580 4
a583 4
void vegaGaussianBlur(VGImage dst, VGImage src,
                      VGfloat stdDeviationX,
                      VGfloat stdDeviationY,
                      VGTilingMode tilingMode)
d672 1
a672 1
   info.extra_texture_view = NULL;
d679 7
a685 7
void vegaLookup(VGImage dst, VGImage src,
                const VGubyte * redLUT,
                const VGubyte * greenLUT,
                const VGubyte * blueLUT,
                const VGubyte * alphaLUT,
                VGboolean outputLinear,
                VGboolean outputPremultiplied)
d691 1
a691 1
   struct pipe_sampler_view *lut_texture_view;
d717 1
a717 1
   lut_texture_view = create_texture_1d_view(ctx, color_data, 255);
d731 1
a731 1
   info.extra_texture_view = lut_texture_view;
d735 1
a735 1
   pipe_sampler_view_reference(&lut_texture_view, NULL);
d738 5
a742 5
void vegaLookupSingle(VGImage dst, VGImage src,
                      const VGuint * lookupTable,
                      VGImageChannel sourceChannel,
                      VGboolean outputLinear,
                      VGboolean outputPremultiplied)
d746 1
a746 1
   struct pipe_sampler_view *lut_texture_view;
a775 2
   vg_validate_state(ctx);

d786 1
a786 1
   lut_texture_view = create_texture_1d_view(ctx, color_data, 256);
d800 1
a800 1
   info.extra_texture_view = lut_texture_view;
d804 1
a804 1
   pipe_sampler_view_reference(&lut_texture_view, NULL);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a31 1
#include "handle.h"
d80 2
a81 3
      struct pipe_transfer *transfer;
      void *map =
         pipe_transfer_map(pipe, tex,
d84 2
a85 2
                           0, 0, tex->width0, tex->height0,
                           &transfer);
d88 1
d196 1
a196 1
      memcpy(sampler.border_color.f, ctx->state.vg.tile_fill_color,
d254 2
a255 2
   d = handle_to_image(dst);
   s = handle_to_image(src);
d275 1
a275 1
   VGfloat diff = (VGfloat) (current - shift);
d296 1
a296 1
   const VGint max_kernel_size = vegaGeti(VG_MAX_KERNEL_SIZE);
d320 2
a321 2
   d = handle_to_image(dst);
   s = handle_to_image(src);
d331 1
a331 1
   buffer = malloc(buffer_len * sizeof(VGfloat));
d338 1
a338 1
   buffer[4] = (VGfloat) (kernelWidth * kernelHeight);
d349 2
a350 2
         x = (VGfloat) texture_offset(s->width, kernelWidth, i, shiftX);
         y = (VGfloat) texture_offset(s->height, kernelHeight, j, shiftY);
d398 1
a398 1
   const VGint max_kernel_size = vegaGeti(VG_MAX_SEPARABLE_KERNEL_SIZE);
d428 2
a429 2
   vegaConvolve(dst, src, kernelWidth, kernelHeight, shiftX, shiftY,
                kernel, scale, bias, tilingMode);
d505 2
a506 2
   d = handle_to_image(dst);
   s = handle_to_image(src);
d521 1
a521 1
   buffer = malloc(buffer_len * sizeof(VGfloat));
d602 2
a603 2
   d = handle_to_image(dst);
   s = handle_to_image(src);
d665 2
a666 2
   d = handle_to_image(dst);
   s = handle_to_image(src);
@


