head	1.4;
access;
symbols
	OPENBSD_5_8:1.3.0.12
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.10
	OPENBSD_5_7_BASE:1.3
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.3;
commitid	TnlogFl9nOv2eaRf;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.23;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "VG/openvg.h"

#include "vg_context.h"
#include "handle.h"
#include "path.h"
#include "api.h"

#include "pipe/p_context.h"

VGPath vegaCreatePath(VGint pathFormat,
                      VGPathDatatype datatype,
                      VGfloat scale, VGfloat bias,
                      VGint segmentCapacityHint,
                      VGint coordCapacityHint,
                      VGbitfield capabilities)
{
   struct vg_context *ctx = vg_current_context();

   if (pathFormat != VG_PATH_FORMAT_STANDARD) {
      vg_set_error(ctx, VG_UNSUPPORTED_PATH_FORMAT_ERROR);
      return VG_INVALID_HANDLE;
   }
   if (datatype < VG_PATH_DATATYPE_S_8 ||
       datatype > VG_PATH_DATATYPE_F) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return VG_INVALID_HANDLE;
   }
   if (!scale) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return VG_INVALID_HANDLE;
   }

   return path_to_handle(path_create(datatype, scale, bias,
                                     segmentCapacityHint, coordCapacityHint,
                                     capabilities));
}

void vegaClearPath(VGPath path, VGbitfield capabilities)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = 0;

   if (path == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   p = handle_to_path(path);
   path_clear(p, capabilities);
}

void vegaDestroyPath(VGPath p)
{
   struct path *path = 0;
   struct vg_context *ctx = vg_current_context();

   if (p == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   path = handle_to_path(p);
   path_destroy(path);
}

void vegaRemovePathCapabilities(VGPath path,
                                VGbitfield capabilities)
{
   struct vg_context *ctx = vg_current_context();
   VGbitfield current;
   struct path *p;

   if (path == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   p = handle_to_path(path);
   current = path_capabilities(p);
   path_set_capabilities(p, (current &
                             (~(capabilities & VG_PATH_CAPABILITY_ALL))));
}

VGbitfield vegaGetPathCapabilities(VGPath path)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = 0;

   if (path == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return 0;
   }
   p = handle_to_path(path);
   return path_capabilities(p);
}

void vegaAppendPath(VGPath dstPath, VGPath srcPath)
{
   struct vg_context *ctx = vg_current_context();
   struct path *src, *dst;

   if (dstPath == VG_INVALID_HANDLE || srcPath == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   src = handle_to_path(srcPath);
   dst = handle_to_path(dstPath);

   if (!(path_capabilities(src) & VG_PATH_CAPABILITY_APPEND_FROM) ||
       !(path_capabilities(dst) & VG_PATH_CAPABILITY_APPEND_TO)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return;
   }
   path_append_path(dst, src);
}

void vegaAppendPathData(VGPath dstPath,
                        VGint numSegments,
                        const VGubyte * pathSegments,
                        const void * pathData)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = 0;
   VGint i;

   if (dstPath == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (!pathSegments) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if (numSegments <= 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   for (i = 0; i < numSegments; ++i) {
      if (pathSegments[i] > VG_LCWARC_TO_REL) {
         vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
         return;
      }
   }

   p = handle_to_path(dstPath);

   if (!p || !is_aligned_to(p, path_datatype_size(p))) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (!(path_capabilities(p)&VG_PATH_CAPABILITY_APPEND_TO)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return;
   }

   path_append_data(p, numSegments, pathSegments, pathData);
}

void vegaModifyPathCoords(VGPath dstPath,
                          VGint startIndex,
                          VGint numSegments,
                          const void * pathData)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = 0;

   if (dstPath == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (startIndex < 0 || numSegments <= 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   p = handle_to_path(dstPath);

   if (!pathData || !is_aligned_to(pathData, path_datatype_size(p))) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (startIndex + numSegments > path_num_segments(p)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if (!(path_capabilities(p)&VG_PATH_CAPABILITY_MODIFY)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return;
   }
   path_modify_coords(p, startIndex, numSegments, pathData);
}

void vegaTransformPath(VGPath dstPath, VGPath srcPath)
{
   struct vg_context *ctx = vg_current_context();
   struct path *src = 0, *dst = 0;

   if (dstPath == VG_INVALID_HANDLE || srcPath == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   src = handle_to_path(srcPath);
   dst = handle_to_path(dstPath);

   if (!(path_capabilities(src) & VG_PATH_CAPABILITY_TRANSFORM_FROM) ||
       !(path_capabilities(dst) & VG_PATH_CAPABILITY_TRANSFORM_TO)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return;
   }
   path_transform(dst, src);
}

VGboolean vegaInterpolatePath(VGPath dstPath,
                              VGPath startPath,
                              VGPath endPath,
                              VGfloat amount)
{
   struct vg_context *ctx = vg_current_context();
   struct path *start = 0, *dst = 0, *end = 0;

   if (dstPath == VG_INVALID_HANDLE ||
       startPath == VG_INVALID_HANDLE ||
       endPath == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return VG_FALSE;
   }
   dst = handle_to_path(dstPath);
   start = handle_to_path(startPath);
   end = handle_to_path(endPath);

   if (!(path_capabilities(dst) & VG_PATH_CAPABILITY_INTERPOLATE_TO) ||
       !(path_capabilities(start) & VG_PATH_CAPABILITY_INTERPOLATE_FROM) ||
       !(path_capabilities(end) & VG_PATH_CAPABILITY_INTERPOLATE_FROM)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return VG_FALSE;
   }

   return path_interpolate(dst,
                           start, end, amount);
}

VGfloat vegaPathLength(VGPath path,
                       VGint startSegment,
                       VGint numSegments)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = 0;

   if (path == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return -1;
   }
   if (startSegment < 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return -1;
   }
   if (numSegments <= 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return -1;
   }
   p = handle_to_path(path);

   if (!(path_capabilities(p) & VG_PATH_CAPABILITY_PATH_LENGTH)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return -1;
   }
   if (startSegment + numSegments > path_num_segments(p)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return -1;
   }

   return path_length(p, startSegment, numSegments);
}

void vegaPointAlongPath(VGPath path,
                        VGint startSegment,
                        VGint numSegments,
                        VGfloat distance,
                        VGfloat * x, VGfloat * y,
                        VGfloat * tangentX,
                        VGfloat * tangentY)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = 0;
   VGbitfield caps;

   if (path == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (startSegment < 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if (numSegments <= 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (!is_aligned(x) || !is_aligned(y) ||
       !is_aligned(tangentX) || !is_aligned(tangentY)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   p = handle_to_path(path);

   caps = path_capabilities(p);
   if (!(caps & VG_PATH_CAPABILITY_POINT_ALONG_PATH) ||
       !(caps & VG_PATH_CAPABILITY_TANGENT_ALONG_PATH)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return;
   }

   if (startSegment + numSegments > path_num_segments(p)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   {
      VGfloat point[2], normal[2];
      path_point(p, startSegment, numSegments, distance,
                 point, normal);
      if (x)
         *x = point[0];
      if (y)
         *y = point[1];
      if (tangentX)
         *tangentX = -normal[1];
      if (tangentY)
         *tangentY = normal[0];
   }
}

void vegaPathBounds(VGPath path,
                    VGfloat * minX,
                    VGfloat * minY,
                    VGfloat * width,
                    VGfloat * height)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = 0;
   VGbitfield caps;

   if (path == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   if (!minX || !minY || !width || !height) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (!is_aligned(minX) || !is_aligned(minY) ||
       !is_aligned(width) || !is_aligned(height)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   p = handle_to_path(path);

   caps = path_capabilities(p);
   if (!(caps & VG_PATH_CAPABILITY_PATH_BOUNDS)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return;
   }

   path_bounding_rect(p, minX, minY, width, height);
}

void vegaPathTransformedBounds(VGPath path,
                               VGfloat * minX,
                               VGfloat * minY,
                               VGfloat * width,
                               VGfloat * height)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = 0;
   VGbitfield caps;

   if (path == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   if (!minX || !minY || !width || !height) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (!is_aligned(minX) || !is_aligned(minY) ||
       !is_aligned(width) || !is_aligned(height)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   p = handle_to_path(path);

   caps = path_capabilities(p);
   if (!(caps & VG_PATH_CAPABILITY_PATH_TRANSFORMED_BOUNDS)) {
      vg_set_error(ctx, VG_PATH_CAPABILITY_ERROR);
      return;
   }

#if 0
   /* faster, but seems to have precision problems... */
   path_bounding_rect(p, minX, minY, width, height);
   if (*width > 0 && *height > 0) {
      VGfloat pts[] = {*minX,          *minY,
                       *minX + *width, *minY,
                       *minX + *width, *minY + *height,
                       *minX,          *minY + *height};
      struct matrix *matrix = &ctx->state.vg.path_user_to_surface_matrix;
      VGfloat maxX, maxY;
      matrix_map_point(matrix, pts[0], pts[1], pts + 0, pts + 1);
      matrix_map_point(matrix, pts[2], pts[3], pts + 2, pts + 3);
      matrix_map_point(matrix, pts[4], pts[5], pts + 4, pts + 5);
      matrix_map_point(matrix, pts[6], pts[7], pts + 6, pts + 7);
      *minX = MIN2(pts[0], MIN2(pts[2], MIN2(pts[4], pts[6])));
      *minY = MIN2(pts[1], MIN2(pts[3], MIN2(pts[5], pts[7])));
      maxX = MAX2(pts[0], MAX2(pts[2], MAX2(pts[4], pts[6])));
      maxY = MAX2(pts[1], MAX2(pts[3], MAX2(pts[5], pts[7])));
      *width  = maxX - *minX;
      *height = maxY - *minY;
   }
#else
   {
      struct path *dst = path_create(VG_PATH_DATATYPE_F, 1.0, 0,
                                     0, 0, VG_PATH_CAPABILITY_ALL);
      path_transform(dst, p);
      path_bounding_rect(dst, minX, minY, width, height);
      path_destroy(dst);
   }
#endif
}


void vegaDrawPath(VGPath path, VGbitfield paintModes)
{
   struct vg_context *ctx = vg_current_context();
   struct path *p = handle_to_path(path);

   if (path == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   if (!(paintModes & (VG_STROKE_PATH | VG_FILL_PATH))) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   if (path_is_empty(p))
      return;
   path_render(p, paintModes,
         &ctx->state.vg.path_user_to_surface_matrix);
}

@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@d30 1
d59 3
a61 3
   return (VGPath)path_create(datatype, scale, bias,
                              segmentCapacityHint, coordCapacityHint,
                              capabilities);
d74 1
a74 1
   p = (struct path *)path;
d88 1
a88 1
   path = (struct path *)p;
d104 1
a104 1
   p = (struct path*)path;
d119 1
a119 1
   p = (struct path*)path;
d132 2
a133 2
   src = (struct path *)srcPath;
   dst = (struct path *)dstPath;
d171 1
a171 1
   p = (struct path*)dstPath;
d173 1
a173 1
   if (!pathData || !is_aligned_to(pathData, path_datatype_size(p))) {
d203 1
a203 1
   p = (struct path *)dstPath;
d230 2
a231 2
   src = (struct path *)srcPath;
   dst = (struct path *)dstPath;
d255 3
a257 3
   dst = (struct path *)dstPath;
   start = (struct path *)startPath;
   end = (struct path *)endPath;
d289 1
a289 1
   p = (struct path*)path;
d334 1
a334 1
   p = (struct path*)path;
d389 1
a389 1
   p = (struct path*)path;
d426 1
a426 1
   p = (struct path*)path;
d470 1
d482 1
a482 1
   if (path_is_empty((struct path*)path))
d484 1
a484 1
   path_render((struct path*)path, paintModes,
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a31 2
#include "polygon.h"
#include "paint.h"
a33 2
#include "util/u_inlines.h"
#include "util/u_draw_quad.h"
d35 6
a40 6
VGPath vgCreatePath(VGint pathFormat,
                    VGPathDatatype datatype,
                    VGfloat scale, VGfloat bias,
                    VGint segmentCapacityHint,
                    VGint coordCapacityHint,
                    VGbitfield capabilities)
d63 1
a63 1
void vgClearPath(VGPath path, VGbitfield capabilities)
d77 1
a77 1
void vgDestroyPath(VGPath p)
d91 2
a92 2
void vgRemovePathCapabilities(VGPath path,
                              VGbitfield capabilities)
d109 1
a109 1
VGbitfield vgGetPathCapabilities(VGPath path)
d122 1
a122 1
void vgAppendPath(VGPath dstPath, VGPath srcPath)
d142 4
a145 4
void vgAppendPathData(VGPath dstPath,
                      VGint numSegments,
                      const VGubyte * pathSegments,
                      const void * pathData)
d185 4
a188 4
void vgModifyPathCoords(VGPath dstPath,
                        VGint startIndex,
                        VGint numSegments,
                        const void * pathData)
d220 1
a220 1
void vgTransformPath(VGPath dstPath, VGPath srcPath)
d240 4
a243 4
VGboolean vgInterpolatePath(VGPath dstPath,
                            VGPath startPath,
                            VGPath endPath,
                            VGfloat amount)
d269 3
a271 3
VGfloat vgPathLength(VGPath path,
                     VGint startSegment,
                     VGint numSegments)
d302 7
a308 7
void vgPointAlongPath(VGPath path,
                      VGint startSegment,
                      VGint numSegments,
                      VGfloat distance,
                      VGfloat * x, VGfloat * y,
                      VGfloat * tangentX,
                      VGfloat * tangentY)
d362 5
a366 5
void vgPathBounds(VGPath path,
                  VGfloat * minX,
                  VGfloat * minY,
                  VGfloat * width,
                  VGfloat * height)
d399 5
a403 5
void vgPathTransformedBounds(VGPath path,
                             VGfloat * minX,
                             VGfloat * minY,
                             VGfloat * width,
                             VGfloat * height)
d466 1
a466 1
void vgDrawPath(VGPath path, VGbitfield paintModes)
d482 2
a483 1
   path_render((struct path*)path, paintModes);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d31 2
a32 1
#include "api.h"
d35 2
d38 6
a43 6
VGPath vegaCreatePath(VGint pathFormat,
                      VGPathDatatype datatype,
                      VGfloat scale, VGfloat bias,
                      VGint segmentCapacityHint,
                      VGint coordCapacityHint,
                      VGbitfield capabilities)
d66 1
a66 1
void vegaClearPath(VGPath path, VGbitfield capabilities)
d80 1
a80 1
void vegaDestroyPath(VGPath p)
d94 2
a95 2
void vegaRemovePathCapabilities(VGPath path,
                                VGbitfield capabilities)
d112 1
a112 1
VGbitfield vegaGetPathCapabilities(VGPath path)
d125 1
a125 1
void vegaAppendPath(VGPath dstPath, VGPath srcPath)
d145 4
a148 4
void vegaAppendPathData(VGPath dstPath,
                        VGint numSegments,
                        const VGubyte * pathSegments,
                        const void * pathData)
d188 4
a191 4
void vegaModifyPathCoords(VGPath dstPath,
                          VGint startIndex,
                          VGint numSegments,
                          const void * pathData)
d223 1
a223 1
void vegaTransformPath(VGPath dstPath, VGPath srcPath)
d243 4
a246 4
VGboolean vegaInterpolatePath(VGPath dstPath,
                              VGPath startPath,
                              VGPath endPath,
                              VGfloat amount)
d272 3
a274 3
VGfloat vegaPathLength(VGPath path,
                       VGint startSegment,
                       VGint numSegments)
d305 7
a311 7
void vegaPointAlongPath(VGPath path,
                        VGint startSegment,
                        VGint numSegments,
                        VGfloat distance,
                        VGfloat * x, VGfloat * y,
                        VGfloat * tangentX,
                        VGfloat * tangentY)
d365 5
a369 5
void vegaPathBounds(VGPath path,
                    VGfloat * minX,
                    VGfloat * minY,
                    VGfloat * width,
                    VGfloat * height)
d402 5
a406 5
void vegaPathTransformedBounds(VGPath path,
                               VGfloat * minX,
                               VGfloat * minY,
                               VGfloat * width,
                               VGfloat * height)
d469 1
a469 1
void vegaDrawPath(VGPath path, VGbitfield paintModes)
d485 1
a485 2
   path_render((struct path*)path, paintModes,
         &ctx->state.vg.path_user_to_surface_matrix);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a29 1
#include "handle.h"
d58 3
a60 3
   return path_to_handle(path_create(datatype, scale, bias,
                                     segmentCapacityHint, coordCapacityHint,
                                     capabilities));
d73 1
a73 1
   p = handle_to_path(path);
d87 1
a87 1
   path = handle_to_path(p);
d103 1
a103 1
   p = handle_to_path(path);
d118 1
a118 1
   p = handle_to_path(path);
d131 2
a132 2
   src = handle_to_path(srcPath);
   dst = handle_to_path(dstPath);
d170 1
a170 1
   p = handle_to_path(dstPath);
d172 1
a172 1
   if (!p || !is_aligned_to(p, path_datatype_size(p))) {
d202 1
a202 1
   p = handle_to_path(dstPath);
d229 2
a230 2
   src = handle_to_path(srcPath);
   dst = handle_to_path(dstPath);
d254 3
a256 3
   dst = handle_to_path(dstPath);
   start = handle_to_path(startPath);
   end = handle_to_path(endPath);
d288 1
a288 1
   p = handle_to_path(path);
d333 1
a333 1
   p = handle_to_path(path);
d388 1
a388 1
   p = handle_to_path(path);
d425 1
a425 1
   p = handle_to_path(path);
a468 1
   struct path *p = handle_to_path(path);
d480 1
a480 1
   if (path_is_empty(p))
d482 1
a482 1
   path_render(p, paintModes,
@


