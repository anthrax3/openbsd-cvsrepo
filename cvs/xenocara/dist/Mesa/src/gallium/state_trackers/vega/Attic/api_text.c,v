head	1.4;
access;
symbols
	OPENBSD_5_8:1.3.0.12
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.10
	OPENBSD_5_7_BASE:1.3
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.3;
commitid	TnlogFl9nOv2eaRf;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.23;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "VG/openvg.h"

#include "vg_context.h"
#include "text.h"
#include "api.h"
#include "handle.h"

#include "util/u_memory.h"

#ifdef OPENVG_VERSION_1_1

VGFont vegaCreateFont(VGint glyphCapacityHint)
{
   struct vg_context *ctx = vg_current_context();

   if (glyphCapacityHint < 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return VG_INVALID_HANDLE;
   }

   return font_to_handle(font_create(glyphCapacityHint));
}

void vegaDestroyFont(VGFont f)
{
   struct vg_font *font = handle_to_font(f);
   struct vg_context *ctx = vg_current_context();

   if (f == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (!vg_object_is_valid(f, VG_OBJECT_FONT)) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   font_destroy(font);
}

void vegaSetGlyphToPath(VGFont font,
                        VGuint glyphIndex,
                        VGPath path,
                        VGboolean isHinted,
                        const VGfloat glyphOrigin[2],
                        const VGfloat escapement[2])
{
   struct vg_context *ctx = vg_current_context();
   struct path *pathObj;
   struct vg_font *f;

   if (font == VG_INVALID_HANDLE ||
       !vg_context_is_object_valid(ctx, VG_OBJECT_FONT, font)) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (!glyphOrigin || !escapement ||
       !is_aligned(glyphOrigin) || !is_aligned(escapement)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if (path != VG_INVALID_HANDLE &&
       !vg_context_is_object_valid(ctx, VG_OBJECT_PATH, path)) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   pathObj = handle_to_path(path);
   f = handle_to_font(font);

   font_set_glyph_to_path(f, glyphIndex, pathObj,
         isHinted, glyphOrigin, escapement);
}

void vegaSetGlyphToImage(VGFont font,
                         VGuint glyphIndex,
                         VGImage image,
                         const VGfloat glyphOrigin[2],
                         const VGfloat escapement[2])
{
   struct vg_context *ctx = vg_current_context();
   struct vg_image *img_obj;
   struct vg_font *f;

   if (font == VG_INVALID_HANDLE ||
       !vg_context_is_object_valid(ctx, VG_OBJECT_FONT, font)) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (!glyphOrigin || !escapement ||
       !is_aligned(glyphOrigin) || !is_aligned(escapement)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if (image != VG_INVALID_HANDLE &&
       !vg_context_is_object_valid(ctx, VG_OBJECT_IMAGE, image)) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   img_obj = handle_to_image(image);
   f = handle_to_font(font);

   font_set_glyph_to_image(f, glyphIndex, img_obj, glyphOrigin, escapement);
}

void vegaClearGlyph(VGFont font,
                    VGuint glyphIndex)
{
   struct vg_context *ctx = vg_current_context();
   struct vg_font *f;

   if (font == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }

   f = handle_to_font(font);

   font_clear_glyph(f, glyphIndex);
}

void vegaDrawGlyph(VGFont font,
                   VGuint glyphIndex,
                   VGbitfield paintModes,
                   VGboolean allowAutoHinting)
{
   struct vg_context *ctx = vg_current_context();
   struct vg_font *f;

   if (font == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (paintModes & (~(VG_STROKE_PATH|VG_FILL_PATH))) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   f = handle_to_font(font);

   font_draw_glyph(f, glyphIndex, paintModes, allowAutoHinting);
}

void vegaDrawGlyphs(VGFont font,
                    VGint glyphCount,
                    const VGuint *glyphIndices,
                    const VGfloat *adjustments_x,
                    const VGfloat *adjustments_y,
                    VGbitfield paintModes,
                    VGboolean allowAutoHinting)
{
   struct vg_context *ctx = vg_current_context();
   struct vg_font *f;

   if (font == VG_INVALID_HANDLE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
   if (glyphCount <= 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if (!glyphIndices || !is_aligned(glyphIndices)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if ((adjustments_x && !is_aligned(adjustments_x)) ||
       (adjustments_y && !is_aligned(adjustments_y))) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   if (paintModes & (~(VG_STROKE_PATH|VG_FILL_PATH))) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   f = handle_to_font(font);

   font_draw_glyphs(f, glyphCount, glyphIndices,
         adjustments_x, adjustments_y, paintModes, allowAutoHinting);
}

#endif /* OPENVG_VERSION_1_1 */
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@d32 1
d47 1
a47 1
   return (VGFont) font_create(glyphCapacityHint);
d52 1
a52 1
   struct vg_font *font = (struct vg_font *)f;
d59 1
a59 1
   if (!vg_object_is_valid((void *) font, VG_OBJECT_FONT)) {
d79 1
a79 1
       !vg_context_is_object_valid(ctx, VG_OBJECT_FONT, (void *)font)) {
d89 1
a89 1
       !vg_context_is_object_valid(ctx, VG_OBJECT_PATH, (void *)path)) {
d94 2
a95 2
   pathObj = (struct path*) path;
   f = (struct vg_font*) font;
d112 1
a112 1
       !vg_context_is_object_valid(ctx, VG_OBJECT_FONT, (void *)font)) {
d122 1
a122 1
       !vg_context_is_object_valid(ctx, VG_OBJECT_IMAGE, (void *)image)) {
d127 2
a128 2
   img_obj = (struct vg_image*)image;
   f = (struct vg_font*)font;
d144 1
a144 1
   f = (struct vg_font*) font;
d165 1
a165 1
   f = (struct vg_font*)font;
d203 1
a203 1
   f = (struct vg_font*)font;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d30 2
d37 1
a37 8
struct vg_font {
   struct vg_object base;

   VGint glyph_indices[200];
   VGint num_glyphs;
};

VGFont vgCreateFont(VGint glyphCapacityHint)
a38 1
   struct vg_font *font = 0;
d46 1
a46 4
   font = CALLOC_STRUCT(vg_font);
   vg_init_object(&font->base, ctx, VG_OBJECT_FONT);
   vg_context_add_object(ctx, VG_OBJECT_FONT, font);
   return (VGFont)font;
d49 1
a49 1
void vgDestroyFont(VGFont f)
d58 4
d63 1
a63 2
   vg_context_remove_object(ctx, VG_OBJECT_FONT, font);
   /*free(font);*/
d66 6
a71 6
void vgSetGlyphToPath(VGFont font,
                      VGuint glyphIndex,
                      VGPath path,
                      VGboolean isHinted,
                      VGfloat glyphOrigin [2],
                      VGfloat escapement[2])
d74 1
a74 1
   struct vg_object *pathObj;
a91 5
   pathObj = (struct vg_object*)path;
   if (pathObj && pathObj->type != VG_OBJECT_PATH) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
d93 5
a97 3
   f = (struct vg_font*)font;
   f->glyph_indices[f->num_glyphs] = glyphIndex;
   ++f->num_glyphs;
d100 5
a104 5
void vgSetGlyphToImage(VGFont font,
                       VGuint glyphIndex,
                       VGImage image,
                       VGfloat glyphOrigin [2],
                       VGfloat escapement[2])
d107 1
a107 1
   struct vg_object *img_obj;
d125 2
a126 5
   img_obj = (struct vg_object*)image;
   if (img_obj && img_obj->type != VG_OBJECT_IMAGE) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
a127 3
   f->glyph_indices[f->num_glyphs] = glyphIndex;
   ++f->num_glyphs;
}
d129 1
a129 10
static INLINE VGboolean font_contains_glyph(struct vg_font *font,
                                            VGuint glyph_index)
{
   VGint i;
   for (i = 0; i < font->num_glyphs; ++i) {
      if (font->glyph_indices[i] == glyph_index) {
         return VG_TRUE;
      }
   }
   return VG_FALSE;
d132 2
a133 2
void vgClearGlyph(VGFont font,
                  VGuint glyphIndex)
a136 1
   VGint i;
a141 9
   if (glyphIndex <= 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
   f = (struct vg_font*)font;
   if (!font_contains_glyph(f, glyphIndex)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
d143 3
a145 8
   for (i = 0; i < f->num_glyphs; ++i) {
      if (f->glyph_indices[i] == glyphIndex) {
         /*FIXME*/
         f->glyph_indices[f->num_glyphs] = 0;
         --f->num_glyphs;
         return;
      }
   }
d148 4
a151 4
void vgDrawGlyph(VGFont font,
                 VGuint glyphIndex,
                 VGbitfield paintModes,
                 VGboolean allowAutoHinting)
a159 4
   if (glyphIndex <= 0) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
d165 2
a166 4
   if (!font_contains_glyph(f, glyphIndex)) {
      vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }
d169 7
a175 7
void vgDrawGlyphs(VGFont font,
                  VGint glyphCount,
                  VGuint *glyphIndices,
                  VGfloat *adjustments_x,
                  VGfloat *adjustments_y,
                  VGbitfield paintModes,
                  VGboolean allowAutoHinting)
a177 1
   VGint i;
d192 2
a193 2
   if (!adjustments_x || !is_aligned(adjustments_x) ||
       !adjustments_y || !is_aligned(adjustments_y)) {
d203 3
a205 7
   for (i = 0; i < glyphCount; ++i) {
      VGuint glyph_index = glyphIndices[i];
      if (!font_contains_glyph(f, glyph_index)) {
         vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
         return;
      }
   }
d208 1
a208 1
#endif
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a29 2
#include "text.h"
#include "api.h"
d35 8
a42 1
VGFont vegaCreateFont(VGint glyphCapacityHint)
d44 1
d52 4
a55 1
   return (VGFont) font_create(glyphCapacityHint);
d58 1
a58 1
void vegaDestroyFont(VGFont f)
a66 4
   if (!vg_object_is_valid((void *) font, VG_OBJECT_FONT)) {
      vg_set_error(ctx, VG_BAD_HANDLE_ERROR);
      return;
   }
d68 2
a69 1
   font_destroy(font);
d72 6
a77 6
void vegaSetGlyphToPath(VGFont font,
                        VGuint glyphIndex,
                        VGPath path,
                        VGboolean isHinted,
                        const VGfloat glyphOrigin[2],
                        const VGfloat escapement[2])
d80 1
a80 1
   struct path *pathObj;
d98 5
d104 3
a106 5
   pathObj = (struct path*) path;
   f = (struct vg_font*) font;

   font_set_glyph_to_path(f, glyphIndex, pathObj,
         isHinted, glyphOrigin, escapement);
d109 5
a113 5
void vegaSetGlyphToImage(VGFont font,
                         VGuint glyphIndex,
                         VGImage image,
                         const VGfloat glyphOrigin[2],
                         const VGfloat escapement[2])
d116 1
a116 1
   struct vg_image *img_obj;
d134 5
a138 2

   img_obj = (struct vg_image*)image;
d140 3
d144 10
a153 1
   font_set_glyph_to_image(f, glyphIndex, img_obj, glyphOrigin, escapement);
d156 2
a157 2
void vegaClearGlyph(VGFont font,
                    VGuint glyphIndex)
d161 1
d167 9
d177 8
a184 3
   f = (struct vg_font*) font;

   font_clear_glyph(f, glyphIndex);
d187 4
a190 4
void vegaDrawGlyph(VGFont font,
                   VGuint glyphIndex,
                   VGbitfield paintModes,
                   VGboolean allowAutoHinting)
d199 4
d208 4
a211 2

   font_draw_glyph(f, glyphIndex, paintModes, allowAutoHinting);
d214 7
a220 7
void vegaDrawGlyphs(VGFont font,
                    VGint glyphCount,
                    const VGuint *glyphIndices,
                    const VGfloat *adjustments_x,
                    const VGfloat *adjustments_y,
                    VGbitfield paintModes,
                    VGboolean allowAutoHinting)
d223 1
d238 2
a239 2
   if ((adjustments_x && !is_aligned(adjustments_x)) ||
       (adjustments_y && !is_aligned(adjustments_y))) {
d249 7
a255 3

   font_draw_glyphs(f, glyphCount, glyphIndices,
         adjustments_x, adjustments_y, paintModes, allowAutoHinting);
d258 1
a258 1
#endif /* OPENVG_VERSION_1_1 */
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a31 1
#include "handle.h"
d46 1
a46 1
   return font_to_handle(font_create(glyphCapacityHint));
d51 1
a51 1
   struct vg_font *font = handle_to_font(f);
d58 1
a58 1
   if (!vg_object_is_valid(f, VG_OBJECT_FONT)) {
d78 1
a78 1
       !vg_context_is_object_valid(ctx, VG_OBJECT_FONT, font)) {
d88 1
a88 1
       !vg_context_is_object_valid(ctx, VG_OBJECT_PATH, path)) {
d93 2
a94 2
   pathObj = handle_to_path(path);
   f = handle_to_font(font);
d111 1
a111 1
       !vg_context_is_object_valid(ctx, VG_OBJECT_FONT, font)) {
d121 1
a121 1
       !vg_context_is_object_valid(ctx, VG_OBJECT_IMAGE, image)) {
d126 2
a127 2
   img_obj = handle_to_image(image);
   f = handle_to_font(font);
d143 1
a143 1
   f = handle_to_font(font);
d164 1
a164 1
   f = handle_to_font(font);
d202 1
a202 1
   f = handle_to_font(font);
@


