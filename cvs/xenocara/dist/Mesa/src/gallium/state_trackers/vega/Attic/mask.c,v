head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.14.01.50;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.24;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "mask.h"

#include "path.h"
#include "image.h"
#include "shaders_cache.h"
#include "renderer.h"
#include "asm_util.h"

#include "pipe/p_context.h"
#include "pipe/p_screen.h"
#include "util/u_inlines.h"
#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_surface.h"
#include "util/u_sampler.h"

struct vg_mask_layer {
   struct vg_object base;

   VGint width;
   VGint height;

   struct pipe_sampler_view *sampler_view;
};

static INLINE VGboolean
intersect_rectangles(VGint dwidth, VGint dheight,
                     VGint swidth, VGint sheight,
                     VGint tx, VGint ty,
                     VGint twidth, VGint theight,
                     VGint *offsets,
                     VGint *location)
{
   if (tx + twidth <= 0 || tx >= dwidth)
      return VG_FALSE;
   if (ty + theight <= 0 || ty >= dheight)
      return VG_FALSE;

   offsets[0] = 0;
   offsets[1] = 0;
   location[0] = tx;
   location[1] = ty;

   if (tx < 0) {
      offsets[0] -= tx;
      location[0] = 0;

      location[2] = MIN2(tx + swidth, MIN2(dwidth, tx + twidth));
      offsets[2] = location[2];
   } else {
      offsets[2] = MIN2(twidth, MIN2(dwidth - tx, swidth ));
      location[2] = offsets[2];
   }

   if (ty < 0) {
      offsets[1] -= ty;
      location[1] = 0;

      location[3] = MIN2(ty + sheight, MIN2(dheight, ty + theight));
      offsets[3] = location[3];
   } else {
      offsets[3] = MIN2(theight, MIN2(dheight - ty, sheight));
      location[3] = offsets[3];
   }

   return VG_TRUE;
}

#if DEBUG_MASKS
static void read_alpha_mask(void * data, VGint dataStride,
                            VGImageFormat dataFormat,
                            VGint sx, VGint sy,
                            VGint width, VGint height)
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_context *pipe = ctx->pipe;

   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct st_renderbuffer *strb = stfb->alpha_mask;

   VGfloat temp[VEGA_MAX_IMAGE_WIDTH][4];
   VGfloat *df = (VGfloat*)temp;
   VGint y = (stfb->height - sy) - 1, yStep = -1;
   VGint i;
   VGubyte *dst = (VGubyte *)data;
   VGint xoffset = 0, yoffset = 0;

   if (sx < 0) {
      xoffset = -sx;
      xoffset *= _vega_size_for_format(dataFormat);
      width += sx;
      sx = 0;
   }
   if (sy < 0) {
      yoffset = -sy;
      height += sy;
      sy = 0;
      y = (stfb->height - sy) - 1;
      yoffset *= dataStride;
   }

   {
      struct pipe_surface *surf;

      surf = pipe->create_surface(pipe, strb->texture,  0, 0, 0,
                                  PIPE_BIND_TRANSFER_READ);

      /* Do a row at a time to flip image data vertically */
      for (i = 0; i < height; i++) {
#if 0
         debug_printf("%d-%d  == %d\n", sy, height, y);
#endif
         pipe_get_tile_rgba(surf, sx, y, width, 1, df);
         y += yStep;
         _vega_pack_rgba_span_float(ctx, width, temp, dataFormat,
                                    dst + yoffset + xoffset);
         dst += dataStride;
      }

      pipe_surface_reference(&surf, NULL);
   }
}

void save_alpha_to_file(const char *filename)
{
   struct vg_context *ctx = vg_current_context();
   struct st_framebuffer *stfb = ctx->draw_buffer;
   VGint *data;
   int i, j;

   data = malloc(sizeof(int) * stfb->width * stfb->height);
   read_alpha_mask(data, stfb->width * sizeof(int),
                   VG_sRGBA_8888,
                   0, 0, stfb->width, stfb->height);
   fprintf(stderr, "/*---------- start */\n");
   fprintf(stderr, "const int image_width = %d;\n",
           stfb->width);
   fprintf(stderr, "const int image_height = %d;\n",
           stfb->height);
   fprintf(stderr, "const int image_data = {\n");
   for (i = 0; i < stfb->height; ++i) {
      for (j = 0; j < stfb->width; ++j) {
         int rgba = data[i * stfb->height + j];
         int argb = 0;
         argb = (rgba >> 8);
         argb |= ((rgba & 0xff) << 24);
         fprintf(stderr, "0x%x, ", argb);
      }
      fprintf(stderr, "\n");
   }
   fprintf(stderr, "};\n");
   fprintf(stderr, "/*---------- end */\n");
}
#endif

/* setup mask shader */
static void *setup_mask_operation(VGMaskOperation operation)
{
   struct vg_context *ctx = vg_current_context();
   void *shader = 0;

   switch (operation) {
   case VG_UNION_MASK: {
      if (!ctx->mask.union_fs) {
         ctx->mask.union_fs = shader_create_from_text(ctx->pipe,
                                                      union_mask_asm,
                                                      200,
                                                      PIPE_SHADER_FRAGMENT);
      }
      shader = ctx->mask.union_fs->driver;
   }
      break;
   case VG_INTERSECT_MASK: {
      if (!ctx->mask.intersect_fs) {
         ctx->mask.intersect_fs = shader_create_from_text(ctx->pipe,
                                                          intersect_mask_asm,
                                                          200,
                                                          PIPE_SHADER_FRAGMENT);
      }
      shader = ctx->mask.intersect_fs->driver;
   }
      break;
   case VG_SUBTRACT_MASK: {
      if (!ctx->mask.subtract_fs) {
         ctx->mask.subtract_fs = shader_create_from_text(ctx->pipe,
                                                         subtract_mask_asm,
                                                         200,
                                                         PIPE_SHADER_FRAGMENT);
      }
      shader = ctx->mask.subtract_fs->driver;
   }
      break;
   case VG_SET_MASK: {
      if (!ctx->mask.set_fs) {
         ctx->mask.set_fs = shader_create_from_text(ctx->pipe,
                                                    set_mask_asm,
                                                    200,
                                                    PIPE_SHADER_FRAGMENT);
      }
      shader = ctx->mask.set_fs->driver;
   }
      break;
   default:
         assert(0);
      break;
   }

   return shader;
}

static void mask_resource_fill(struct pipe_resource *dst,
                               int x, int y, int width, int height,
                               VGfloat coverage)
{
   struct vg_context *ctx = vg_current_context();
   VGfloat fs_consts[12] = {
      0.0f, 0.0f, 0.0f, 0.0f, /* not used */
      0.0f, 0.0f, 0.0f, 0.0f, /* not used */
      0.0f, 0.0f, 0.0f, coverage /* color */
   };
   void *fs;

   if (x < 0) {
      width += x;
      x = 0;
   }
   if (y < 0) {
      height += y;
      y = 0;
   }

   fs = shaders_cache_fill(ctx->sc, VEGA_SOLID_FILL_SHADER);

   if (renderer_filter_begin(ctx->renderer, dst, VG_FALSE, ~0,
            NULL, NULL, 0, fs, (const void *) fs_consts, sizeof(fs_consts))) {
      renderer_filter(ctx->renderer, x, y, width, height, 0, 0, 0, 0);
      renderer_filter_end(ctx->renderer);
   }

#if DEBUG_MASKS
   save_alpha_to_file(0);
#endif
}


static void mask_using_texture(struct pipe_sampler_view *sampler_view,
                               VGboolean is_layer,
                               VGMaskOperation operation,
                               VGint x, VGint y,
                               VGint width, VGint height)
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_sampler_view *dst_view = vg_get_surface_mask(ctx);
   struct pipe_resource *dst = dst_view->texture;
   struct pipe_resource *texture = sampler_view->texture;
   const struct pipe_sampler_state *samplers[2];
   struct pipe_sampler_view *views[2];
   struct pipe_sampler_state sampler;
   VGint offsets[4], loc[4];
   const VGfloat ones[4] = {1.f, 1.f, 1.f, 1.f};
   void *fs;

   if (!intersect_rectangles(dst->width0, dst->height0,
                             texture->width0, texture->height0,
                             x, y, width, height,
                             offsets, loc))
      return;
#if 0
   debug_printf("Offset = [%d, %d, %d, %d]\n", offsets[0],
                offsets[1], offsets[2], offsets[3]);
   debug_printf("Locati = [%d, %d, %d, %d]\n", loc[0],
                loc[1], loc[2], loc[3]);
#endif


   sampler = ctx->mask.sampler;
   sampler.normalized_coords = 1;
   samplers[0] = &sampler;
   views[0] = sampler_view;

   /* prepare our blend surface */
   samplers[1] = &ctx->mask.sampler;
   views[1] = vg_prepare_blend_surface_from_mask(ctx);

   fs = setup_mask_operation(operation);

   if (renderer_filter_begin(ctx->renderer, dst, VG_FALSE,
            ~0, samplers, views, 2, fs, (const void *) ones, sizeof(ones))) {
      /* layer should be flipped when used as a texture */
      if (is_layer) {
         offsets[1] += offsets[3];
         offsets[3] = -offsets[3];
      }
      renderer_filter(ctx->renderer,
            loc[0], loc[1], loc[2], loc[3],
            offsets[0], offsets[1], offsets[2], offsets[3]);
      renderer_filter_end(ctx->renderer);
   }
}


#ifdef OPENVG_VERSION_1_1

struct vg_mask_layer * mask_layer_create(VGint width, VGint height)
{
   struct vg_context *ctx = vg_current_context();
   struct vg_mask_layer *mask = 0;

   mask = CALLOC_STRUCT(vg_mask_layer);
   vg_init_object(&mask->base, ctx, VG_OBJECT_MASK);
   mask->width = width;
   mask->height = height;

   {
      struct pipe_resource pt;
      struct pipe_context *pipe = ctx->pipe;
      struct pipe_screen *screen = ctx->pipe->screen;
      struct pipe_sampler_view view_templ;
      struct pipe_sampler_view *view = NULL;
      struct pipe_resource *texture;

      memset(&pt, 0, sizeof(pt));
      pt.target = PIPE_TEXTURE_2D;
      pt.format = PIPE_FORMAT_B8G8R8A8_UNORM;
      pt.last_level = 0;
      pt.width0 = width;
      pt.height0 = height;
      pt.depth0 = 1;
      pt.array_size = 1;
      pt.bind = PIPE_BIND_SAMPLER_VIEW;

      texture = screen->resource_create(screen, &pt);

      if (texture) {
         u_sampler_view_default_template(&view_templ, texture, texture->format);
         view = pipe->create_sampler_view(pipe, texture, &view_templ);
      }
      pipe_resource_reference(&texture, NULL);
      mask->sampler_view = view;
   }

   vg_context_add_object(ctx, &mask->base);

   return mask;
}

void mask_layer_destroy(struct vg_mask_layer *layer)
{
   struct vg_context *ctx = vg_current_context();

   vg_context_remove_object(ctx, &layer->base);
   pipe_sampler_view_reference(&layer->sampler_view, NULL);
   vg_free_object(&layer->base);
   FREE(layer);
}

void mask_layer_fill(struct vg_mask_layer *layer,
                     VGint x, VGint y,
                     VGint width, VGint height,
                     VGfloat value)
{
   mask_resource_fill(layer->sampler_view->texture,
                      x, y, width, height, value);
}

void mask_copy(struct vg_mask_layer *layer,
               VGint sx, VGint sy,
               VGint dx, VGint dy,
               VGint width, VGint height)
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_sampler_view *src = vg_get_surface_mask(ctx);
   struct pipe_surface *surf, surf_tmpl;

   /* get the destination surface */
   u_surface_default_template(&surf_tmpl, layer->sampler_view->texture);
   surf = ctx->pipe->create_surface(ctx->pipe, layer->sampler_view->texture,
                                    &surf_tmpl);
   if (surf && renderer_copy_begin(ctx->renderer, surf, VG_FALSE, src)) {
      /* layer should be flipped when used as a texture */
      sy += height;
      height = -height;

      renderer_copy(ctx->renderer,
            dx, dy, width, height,
            sx, sy, width, height);
      renderer_copy_end(ctx->renderer);
   }

   pipe_surface_reference(&surf, NULL);
}

static void mask_layer_render_to(struct vg_mask_layer *layer,
                                 struct path *path,
                                 VGbitfield paint_modes)
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_sampler_view *view = vg_get_surface_mask(ctx);
   struct matrix *mat = &ctx->state.vg.path_user_to_surface_matrix;
   struct pipe_surface *surf, surf_tmpl;
   u_surface_default_template(&surf_tmpl, view->texture);
   surf = pipe->create_surface(pipe, view->texture, &surf_tmpl);

   renderer_validate_for_mask_rendering(ctx->renderer, surf, mat);

   if (paint_modes & VG_FILL_PATH) {
      path_fill(path);
   }

   if (paint_modes & VG_STROKE_PATH){
      path_stroke(path);
   }

   pipe_surface_reference(&surf, NULL);
}

void mask_render_to(struct path *path,
                    VGbitfield paint_modes,
                    VGMaskOperation operation)
{
   struct vg_context *ctx = vg_current_context();
   struct st_framebuffer *stfb = ctx->draw_buffer;
   struct vg_mask_layer *temp_layer;
   VGint width, height;

   width = stfb->width;
   height = stfb->height;

   temp_layer = mask_layer_create(width, height);
   mask_layer_fill(temp_layer, 0, 0, width, height, 0.0f);

   mask_layer_render_to(temp_layer, path, paint_modes);

   mask_using_layer(temp_layer, operation, 0, 0, width, height);

   mask_layer_destroy(temp_layer);
}

void mask_using_layer(struct vg_mask_layer *layer,
                      VGMaskOperation operation,
                      VGint x, VGint y,
                      VGint width, VGint height)
{
   mask_using_texture(layer->sampler_view, VG_TRUE, operation,
                      x, y, width, height);
}

VGint mask_layer_width(struct vg_mask_layer *layer)
{
   return layer->width;
}

VGint mask_layer_height(struct vg_mask_layer *layer)
{
   return layer->height;
}


#endif

void mask_using_image(struct vg_image *image,
                      VGMaskOperation operation,
                      VGint x, VGint y,
                      VGint width, VGint height)
{
   mask_using_texture(image->sampler_view, VG_FALSE, operation,
                      x, y, width, height);
}

void mask_fill(VGint x, VGint y, VGint width, VGint height,
               VGfloat value)
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_sampler_view *view = vg_get_surface_mask(ctx);

#if DEBUG_MASKS
   debug_printf("mask_fill(%d, %d, %d, %d) with  rgba(%f, %f, %f, %f)\n",
                x, y, width, height,
                0.0f, 0.0f, 0.0f, value);
#endif

   mask_resource_fill(view->texture, x, y, width, height, value);
}

VGint mask_bind_samplers(struct pipe_sampler_state **samplers,
                         struct pipe_sampler_view **sampler_views)
{
   struct vg_context *ctx = vg_current_context();

   if (ctx->state.vg.masking) {
      samplers[1] = &ctx->mask.sampler;
      sampler_views[1] = vg_get_surface_mask(ctx);
      return 1;
   } else
      return 0;
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d368 1
a368 1
   vg_context_add_object(ctx, VG_OBJECT_MASK, mask);
d377 1
a377 1
   vg_context_remove_object(ctx, VG_OBJECT_MASK, layer);
d379 1
a387 4
   VGfloat alpha_color[4] = {0, 0, 0, 0};

   alpha_color[3] = value;

d402 1
a402 2
   u_surface_default_template(&surf_tmpl, layer->sampler_view->texture,
                              PIPE_BIND_RENDER_TARGET);
d428 1
a428 2
   u_surface_default_template(&surf_tmpl, view->texture,
                              PIPE_BIND_RENDER_TARGET);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a113 2
   /* make sure rendering has completed */
   pipe->flush(pipe, PIPE_FLUSH_RENDER_CACHE, NULL);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a33 1
#include "st_inlines.h"
d40 2
d49 1
a49 1
   struct pipe_texture *texture;
a51 11
static INLINE struct pipe_surface *
alpha_mask_surface(struct vg_context *ctx, int usage)
{
   struct pipe_screen *screen = ctx->pipe->screen;
   struct st_framebuffer *stfb = ctx->draw_buffer;
   return screen->get_tex_surface(screen,
                                  stfb->alpha_mask,
                                  0, 0, 0,
                                  usage);
}

a102 1
   struct pipe_screen *screen = pipe->screen;
a105 1
   struct pipe_framebuffer_state *fb = &ctx->state.g3d.fb;
d109 1
a109 1
   VGint y = (fb->height - sy) - 1, yStep = -1;
d126 1
a126 1
      y = (fb->height - sy) - 1;
d133 2
a134 2
      surf = screen->get_tex_surface(screen, strb->texture,  0, 0, 0,
                                     PIPE_BUFFER_USAGE_CPU_READ);
d155 1
a155 1
   struct pipe_framebuffer_state *fb = &ctx->state.g3d.fb;
d159 2
a160 2
   data = malloc(sizeof(int) * fb->width * fb->height);
   read_alpha_mask(data, fb->width * sizeof(int),
d162 1
a162 1
                   0, 0, fb->width, fb->height);
d165 1
a165 1
           fb->width);
d167 1
a167 1
           fb->height);
d169 3
a171 3
   for (i = 0; i < fb->height; ++i) {
      for (j = 0; j < fb->width; ++j) {
         int rgba = data[i * fb->height + j];
d184 2
a185 22
static void setup_mask_framebuffer(struct pipe_surface *surf,
                                   VGint surf_width, VGint surf_height)
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_framebuffer_state fb;

   memset(&fb, 0, sizeof(fb));
   fb.width = surf_width;
   fb.height = surf_height;
   fb.nr_cbufs = 1;
   fb.cbufs[0] = surf;
   {
      VGint i;
      for (i = 1; i < PIPE_MAX_COLOR_BUFS; ++i)
         fb.cbufs[i] = 0;
   }
   cso_set_framebuffer(ctx->cso_context, &fb);
}


/* setup shader constants */
static void setup_mask_operation(VGMaskOperation operation)
a187 3
   struct pipe_buffer **cbuf = &ctx->mask.cbuf;
   const VGint param_bytes = 4 * sizeof(VGfloat);
   const VGfloat ones[4] = {1.f, 1.f, 1.f, 1.f};
a189 14
   /* We always need to get a new buffer, to keep the drivers simple and
    * avoid gratuitous rendering synchronization.
    */
   pipe_buffer_reference(cbuf, NULL);

   *cbuf = pipe_buffer_create(ctx->pipe->screen, 1,
                              PIPE_BUFFER_USAGE_CONSTANT,
                              param_bytes);
   if (*cbuf) {
      st_no_flush_pipe_buffer_write(ctx, *cbuf,
                                    0, param_bytes, ones);
   }

   ctx->pipe->set_constant_buffer(ctx->pipe, PIPE_SHADER_FRAGMENT, 0, *cbuf);
a234 53
   cso_set_fragment_shader_handle(ctx->cso_context, shader);
}

static void setup_mask_samplers(struct pipe_texture *umask)
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_sampler_state *samplers[PIPE_MAX_SAMPLERS];
   struct pipe_texture *textures[PIPE_MAX_SAMPLERS];
   struct st_framebuffer *fb_buffers = ctx->draw_buffer;
   struct pipe_texture *uprev = NULL;
   struct pipe_sampler_state sampler;

   uprev = fb_buffers->blend_texture;
   sampler = ctx->mask.sampler;
   sampler.normalized_coords = 1;

   samplers[0] = NULL;
   samplers[1] = NULL;
   samplers[2] = NULL;
   textures[0] = NULL;
   textures[1] = NULL;
   textures[2] = NULL;

   samplers[0] = &sampler;
   samplers[1] = &ctx->mask.sampler;

   textures[0] = umask;
   textures[1] = uprev;

   cso_set_samplers(ctx->cso_context, 2,
                    (const struct pipe_sampler_state **)samplers);
   cso_set_sampler_textures(ctx->cso_context, 2, textures);
}


/* setup shader constants */
static void setup_mask_fill(const VGfloat color[4])
{
   struct vg_context *ctx = vg_current_context();
   struct pipe_buffer **cbuf = &ctx->mask.cbuf;
   const VGint param_bytes = 4 * sizeof(VGfloat);

   /* We always need to get a new buffer, to keep the drivers simple and
    * avoid gratuitous rendering synchronization.
    */
   pipe_buffer_reference(cbuf, NULL);

   *cbuf = pipe_buffer_create(ctx->pipe->screen, 1,
                              PIPE_BUFFER_USAGE_CONSTANT,
                              param_bytes);
   if (*cbuf) {
      st_no_flush_pipe_buffer_write(ctx, *cbuf, 0, param_bytes, color);
   }
d236 1
a236 4
   ctx->pipe->set_constant_buffer(ctx->pipe, PIPE_SHADER_FRAGMENT, 0, *cbuf);
   cso_set_fragment_shader_handle(ctx->cso_context,
                                  shaders_cache_fill(ctx->sc,
                                                     VEGA_SOLID_FILL_SHADER));
d239 3
a241 28
static void setup_mask_viewport()
{
   struct vg_context *ctx = vg_current_context();
   vg_set_viewport(ctx, VEGA_Y0_TOP);
}

static void setup_mask_blend()
{
   struct vg_context *ctx = vg_current_context();

   struct pipe_blend_state blend;

   memset(&blend, 0, sizeof(struct pipe_blend_state));
   blend.rt[0].blend_enable = 0;
   blend.rt[0].colormask = PIPE_MASK_RGBA;
   blend.rt[0].rgb_src_factor = PIPE_BLENDFACTOR_ONE;
   blend.rt[0].alpha_src_factor = PIPE_BLENDFACTOR_ONE;
   blend.rt[0].rgb_dst_factor = PIPE_BLENDFACTOR_ZERO;
   blend.rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_ZERO;

   cso_set_blend(ctx->cso_context, &blend);
}


static void surface_fill(struct pipe_surface *surf,
                         int surf_width, int surf_height,
                         int x, int y, int width, int height,
                         const VGfloat color[4])
d244 6
d260 1
a260 12
   cso_save_framebuffer(ctx->cso_context);
   cso_save_blend(ctx->cso_context);
   cso_save_fragment_shader(ctx->cso_context);
   cso_save_viewport(ctx->cso_context);

   setup_mask_blend();
   setup_mask_fill(color);
   setup_mask_framebuffer(surf, surf_width, surf_height);
   setup_mask_viewport();

   renderer_draw_quad(ctx->renderer, x, y,
                      x + width, y + height, 0.0f/*depth should be disabled*/);
d262 5
a266 5

   /* make sure rendering has completed */
   ctx->pipe->flush(ctx->pipe,
                    PIPE_FLUSH_RENDER_CACHE | PIPE_FLUSH_FRAME,
                    NULL);
a270 5

   cso_restore_blend(ctx->cso_context);
   cso_restore_framebuffer(ctx->cso_context);
   cso_restore_fragment_shader(ctx->cso_context);
   cso_restore_viewport(ctx->cso_context);
d274 2
a275 1
static void mask_using_texture(struct pipe_texture *texture,
d281 6
a286 2
   struct pipe_surface *surface =
      alpha_mask_surface(ctx, PIPE_BUFFER_USAGE_GPU_WRITE);
d288 2
d291 1
a291 3
   if (!surface)
      return;
   if (!intersect_rectangles(surface->width, surface->height,
d303 6
d310 2
a311 1
   vg_prepare_blend_surface_from_mask(ctx);
d313 1
a313 18
   cso_save_samplers(ctx->cso_context);
   cso_save_sampler_textures(ctx->cso_context);
   cso_save_framebuffer(ctx->cso_context);
   cso_save_blend(ctx->cso_context);
   cso_save_fragment_shader(ctx->cso_context);
   cso_save_viewport(ctx->cso_context);

   setup_mask_samplers(texture);
   setup_mask_blend();
   setup_mask_operation(operation);
   setup_mask_framebuffer(surface, surface->width, surface->height);
   setup_mask_viewport();

   /* render the quad to propagate the rendering from stencil */
   renderer_draw_texture(ctx->renderer, texture,
                         offsets[0], offsets[1],
                         offsets[0] + offsets[2], offsets[1] + offsets[3],
                         loc[0], loc[1], loc[0] + loc[2], loc[1] + loc[3]);
d315 12
a326 10
   /* make sure rendering has completed */
   ctx->pipe->flush(ctx->pipe, PIPE_FLUSH_RENDER_CACHE, NULL);
   cso_restore_blend(ctx->cso_context);
   cso_restore_framebuffer(ctx->cso_context);
   cso_restore_fragment_shader(ctx->cso_context);
   cso_restore_samplers(ctx->cso_context);
   cso_restore_sampler_textures(ctx->cso_context);
   cso_restore_viewport(ctx->cso_context);

   pipe_surface_reference(&surface, NULL);
d343 2
a344 1
      struct pipe_texture pt;
d346 3
d357 4
a360 2
      pt.tex_usage = PIPE_TEXTURE_USAGE_SAMPLER;
      pt.compressed = 0;
d362 6
a367 1
      mask->texture = screen->texture_create(screen, &pt);
d380 2
a381 2
   pipe_texture_release(&layer->texture);
   free(layer);
a388 1
   struct vg_context *ctx = vg_current_context();
a389 1
   struct pipe_surface *surface;
d393 2
a394 10
   surface = ctx->pipe->screen->get_tex_surface(
      ctx->pipe->screen, layer->texture,
      0, 0, 0,
      PIPE_BUFFER_USAGE_GPU_WRITE);

   surface_fill(surface,
                layer->width, layer->height,
                x, y, width, height, alpha_color);

   ctx->pipe->screen->tex_surface_release(ctx->pipe->screen, &surface);
d402 19
a420 2
    struct vg_context *ctx = vg_current_context();
    struct st_framebuffer *fb_buffers = ctx->draw_buffer;
d422 1
a422 7
    renderer_copy_texture(ctx->renderer,
                          layer->texture,
                          sx, sy,
                          sx + width, sy + height,
                          fb_buffers->alpha_mask,
                          dx, dy,
                          dx + width, dy + height);
d430 9
a438 15
   const VGfloat fill_color[4] = {1.f, 1.f, 1.f, 1.f};
   struct pipe_screen *screen = ctx->pipe->screen;
   struct pipe_surface *surface;

   surface = screen->get_tex_surface(screen, layer->texture,  0, 0, 0,
                                     PIPE_BUFFER_USAGE_GPU_WRITE);

   cso_save_framebuffer(ctx->cso_context);
   cso_save_fragment_shader(ctx->cso_context);
   cso_save_viewport(ctx->cso_context);

   setup_mask_blend();
   setup_mask_fill(fill_color);
   setup_mask_framebuffer(surface, layer->width, layer->height);
   setup_mask_viewport();
d441 1
a441 2
      struct matrix *mat = &ctx->state.vg.path_user_to_surface_matrix;
      path_fill(path, mat);
d448 1
a448 10

   /* make sure rendering has completed */
   ctx->pipe->flush(ctx->pipe, PIPE_FLUSH_RENDER_CACHE, NULL);

   cso_restore_framebuffer(ctx->cso_context);
   cso_restore_fragment_shader(ctx->cso_context);
   cso_restore_viewport(ctx->cso_context);
   ctx->state.dirty |= BLEND_DIRTY;

   screen->tex_surface_release(ctx->pipe->screen, &surface);
d456 1
a456 1
   struct st_framebuffer *fb_buffers = ctx->draw_buffer;
d460 2
a461 2
   width = fb_buffers->alpha_mask->width0;
   height = fb_buffers->alpha_mask->width0;
d464 1
d468 1
a468 2
   mask_using_layer(temp_layer, 0, 0, width, height,
                    operation);
d478 1
a478 1
   mask_using_texture(layer->texture, operation,
d500 1
a500 1
   mask_using_texture(image->texture, operation,
d508 1
a508 3
   VGfloat alpha_color[4] = {.0f, .0f, .0f, value};
   struct pipe_surface *surf = alpha_mask_surface(
      ctx, PIPE_BUFFER_USAGE_GPU_WRITE);
d513 1
a513 4
                alpha_color[0], alpha_color[1],
                alpha_color[2], alpha_color[3]);
   debug_printf("XXX %f  === %f \n",
                alpha_color[3], value);
d516 1
a516 4
   surface_fill(surf, surf->width, surf->height,
                x, y, width, height, alpha_color);

   pipe_surface_reference(&surf, NULL);
d520 1
a520 1
                         struct pipe_texture **textures)
a524 2
      struct st_framebuffer *fb_buffers = ctx->draw_buffer;

d526 1
a526 1
      textures[1] = fb_buffers->alpha_mask;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 1
a40 2
#include "util/u_surface.h"
#include "util/u_sampler.h"
d48 1
a48 1
   struct pipe_sampler_view *sampler_view;
d51 11
d113 1
d117 1
d121 1
a121 1
   VGint y = (stfb->height - sy) - 1, yStep = -1;
d138 1
a138 1
      y = (stfb->height - sy) - 1;
d145 2
a146 2
      surf = pipe->create_surface(pipe, strb->texture,  0, 0, 0,
                                  PIPE_BIND_TRANSFER_READ);
d167 1
a167 1
   struct st_framebuffer *stfb = ctx->draw_buffer;
d171 2
a172 2
   data = malloc(sizeof(int) * stfb->width * stfb->height);
   read_alpha_mask(data, stfb->width * sizeof(int),
d174 1
a174 1
                   0, 0, stfb->width, stfb->height);
d177 1
a177 1
           stfb->width);
d179 1
a179 1
           stfb->height);
d181 3
a183 3
   for (i = 0; i < stfb->height; ++i) {
      for (j = 0; j < stfb->width; ++j) {
         int rgba = data[i * stfb->height + j];
d196 22
a217 2
/* setup mask shader */
static void *setup_mask_operation(VGMaskOperation operation)
d220 3
d225 14
d284 53
d338 4
a341 1
   return shader;
d344 28
a371 3
static void mask_resource_fill(struct pipe_resource *dst,
                               int x, int y, int width, int height,
                               VGfloat coverage)
a373 6
   VGfloat fs_consts[12] = {
      0.0f, 0.0f, 0.0f, 0.0f, /* not used */
      0.0f, 0.0f, 0.0f, 0.0f, /* not used */
      0.0f, 0.0f, 0.0f, coverage /* color */
   };
   void *fs;
d384 9
a392 1
   fs = shaders_cache_fill(ctx->sc, VEGA_SOLID_FILL_SHADER);
d394 8
a401 5
   if (renderer_filter_begin(ctx->renderer, dst, VG_FALSE, ~0,
            NULL, NULL, 0, fs, (const void *) fs_consts, sizeof(fs_consts))) {
      renderer_filter(ctx->renderer, x, y, width, height, 0, 0, 0, 0);
      renderer_filter_end(ctx->renderer);
   }
d406 5
d414 1
a414 2
static void mask_using_texture(struct pipe_sampler_view *sampler_view,
                               VGboolean is_layer,
d420 2
a421 6
   struct pipe_sampler_view *dst_view = vg_get_surface_mask(ctx);
   struct pipe_resource *dst = dst_view->texture;
   struct pipe_resource *texture = sampler_view->texture;
   const struct pipe_sampler_state *samplers[2];
   struct pipe_sampler_view *views[2];
   struct pipe_sampler_state sampler;
a422 2
   const VGfloat ones[4] = {1.f, 1.f, 1.f, 1.f};
   void *fs;
d424 3
a426 1
   if (!intersect_rectangles(dst->width0, dst->height0,
d438 2
d441 18
a458 4
   sampler = ctx->mask.sampler;
   sampler.normalized_coords = 1;
   samplers[0] = &sampler;
   views[0] = sampler_view;
d460 8
a467 5
   /* prepare our blend surface */
   samplers[1] = &ctx->mask.sampler;
   views[1] = vg_prepare_blend_surface_from_mask(ctx);

   fs = setup_mask_operation(operation);
d469 1
a469 12
   if (renderer_filter_begin(ctx->renderer, dst, VG_FALSE,
            ~0, samplers, views, 2, fs, (const void *) ones, sizeof(ones))) {
      /* layer should be flipped when used as a texture */
      if (is_layer) {
         offsets[1] += offsets[3];
         offsets[3] = -offsets[3];
      }
      renderer_filter(ctx->renderer,
            loc[0], loc[1], loc[2], loc[3],
            offsets[0], offsets[1], offsets[2], offsets[3]);
      renderer_filter_end(ctx->renderer);
   }
d486 1
a486 2
      struct pipe_resource pt;
      struct pipe_context *pipe = ctx->pipe;
a487 3
      struct pipe_sampler_view view_templ;
      struct pipe_sampler_view *view = NULL;
      struct pipe_resource *texture;
d496 2
a497 4
      pt.array_size = 1;
      pt.bind = PIPE_BIND_SAMPLER_VIEW;

      texture = screen->resource_create(screen, &pt);
d499 1
a499 6
      if (texture) {
         u_sampler_view_default_template(&view_templ, texture, texture->format);
         view = pipe->create_sampler_view(pipe, texture, &view_templ);
      }
      pipe_resource_reference(&texture, NULL);
      mask->sampler_view = view;
d512 2
a513 2
   pipe_sampler_view_reference(&layer->sampler_view, NULL);
   FREE(layer);
d521 1
d523 1
d527 10
a536 2
   mask_resource_fill(layer->sampler_view->texture,
                      x, y, width, height, value);
d544 2
a545 19
   struct vg_context *ctx = vg_current_context();
   struct pipe_sampler_view *src = vg_get_surface_mask(ctx);
   struct pipe_surface *surf, surf_tmpl;

   /* get the destination surface */
   u_surface_default_template(&surf_tmpl, layer->sampler_view->texture,
                              PIPE_BIND_RENDER_TARGET);
   surf = ctx->pipe->create_surface(ctx->pipe, layer->sampler_view->texture,
                                    &surf_tmpl);
   if (surf && renderer_copy_begin(ctx->renderer, surf, VG_FALSE, src)) {
      /* layer should be flipped when used as a texture */
      sy += height;
      height = -height;

      renderer_copy(ctx->renderer,
            dx, dy, width, height,
            sx, sy, width, height);
      renderer_copy_end(ctx->renderer);
   }
d547 7
a553 1
   pipe_surface_reference(&surf, NULL);
d561 15
a575 9
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_sampler_view *view = vg_get_surface_mask(ctx);
   struct matrix *mat = &ctx->state.vg.path_user_to_surface_matrix;
   struct pipe_surface *surf, surf_tmpl;
   u_surface_default_template(&surf_tmpl, view->texture,
                              PIPE_BIND_RENDER_TARGET);
   surf = pipe->create_surface(pipe, view->texture, &surf_tmpl);

   renderer_validate_for_mask_rendering(ctx->renderer, surf, mat);
d578 2
a579 1
      path_fill(path);
d586 10
a595 1
   pipe_surface_reference(&surf, NULL);
d603 1
a603 1
   struct st_framebuffer *stfb = ctx->draw_buffer;
d607 2
a608 2
   width = stfb->width;
   height = stfb->height;
a610 1
   mask_layer_fill(temp_layer, 0, 0, width, height, 0.0f);
d614 2
a615 1
   mask_using_layer(temp_layer, operation, 0, 0, width, height);
d625 1
a625 1
   mask_using_texture(layer->sampler_view, VG_TRUE, operation,
d647 1
a647 1
   mask_using_texture(image->sampler_view, VG_FALSE, operation,
d655 3
a657 1
   struct pipe_sampler_view *view = vg_get_surface_mask(ctx);
d662 4
a665 1
                0.0f, 0.0f, 0.0f, value);
d668 4
a671 1
   mask_resource_fill(view->texture, x, y, width, height, value);
d675 1
a675 1
                         struct pipe_sampler_view **sampler_views)
d680 2
d683 1
a683 1
      sampler_views[1] = vg_get_surface_mask(ctx);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d114 2
d370 1
a370 1
   vg_context_add_object(ctx, &mask->base);
d379 1
a379 1
   vg_context_remove_object(ctx, &layer->base);
a380 1
   vg_free_object(&layer->base);
d389 4
d407 2
a408 1
   u_surface_default_template(&surf_tmpl, layer->sampler_view->texture);
d434 2
a435 1
   u_surface_default_template(&surf_tmpl, view->texture);
@


