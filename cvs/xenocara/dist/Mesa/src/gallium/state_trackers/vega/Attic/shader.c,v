head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.14.01.51;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.26;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "shader.h"

#include "vg_context.h"
#include "shaders_cache.h"
#include "paint.h"
#include "mask.h"
#include "image.h"
#include "renderer.h"

#include "pipe/p_context.h"
#include "pipe/p_state.h"
#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_format.h"

#define MAX_CONSTANTS 28

struct shader {
   struct vg_context *context;

   VGboolean color_transform;
   VGboolean masking;
   struct vg_paint *paint;
   struct vg_image *image;

   struct matrix modelview;
   struct matrix paint_matrix;

   VGboolean drawing_image;
   VGImageMode image_mode;

   float constants[MAX_CONSTANTS];
   struct pipe_resource *cbuf;
   struct pipe_shader_state fs_state;
   void *fs;
};

struct shader * shader_create(struct vg_context *ctx)
{
   struct shader *shader = 0;

   shader = CALLOC_STRUCT(shader);
   shader->context = ctx;

   return shader;
}

void shader_destroy(struct shader *shader)
{
   FREE(shader);
}

void shader_set_color_transform(struct shader *shader, VGboolean set)
{
   shader->color_transform = set;
}

void shader_set_masking(struct shader *shader, VGboolean set)
{
   shader->masking = set;
}

VGboolean shader_is_masking(struct shader *shader)
{
   return shader->masking;
}

void shader_set_paint(struct shader *shader, struct vg_paint *paint)
{
   shader->paint = paint;
}

struct vg_paint * shader_paint(struct shader *shader)
{
   return shader->paint;
}

static VGint setup_constant_buffer(struct shader *shader)
{
   const struct vg_state *state = &shader->context->state.vg;
   VGint param_bytes = paint_constant_buffer_size(shader->paint);
   VGint i;

   param_bytes += sizeof(VGfloat) * 8;
   assert(param_bytes <= sizeof(shader->constants));

   if (state->color_transform) {
      for (i = 0; i < 8; i++) {
         VGfloat val = (i < 4) ? 127.0f : 1.0f;
         shader->constants[i] =
            CLAMP(state->color_transform_values[i], -val, val);
      }
   }
   else {
      memset(shader->constants, 0, sizeof(VGfloat) * 8);
   }

   paint_fill_constant_buffer(shader->paint,
         &shader->paint_matrix, shader->constants + 8);

   return param_bytes;
}

static VGboolean blend_use_shader(struct shader *shader)
{
   struct vg_context *ctx = shader->context;
   VGboolean advanced_blending;

   switch (ctx->state.vg.blend_mode) {
   case VG_BLEND_DST_OVER:
   case VG_BLEND_MULTIPLY:
   case VG_BLEND_SCREEN:
   case VG_BLEND_DARKEN:
   case VG_BLEND_LIGHTEN:
   case VG_BLEND_ADDITIVE:
      advanced_blending = VG_TRUE;
      break;
   case VG_BLEND_SRC_OVER:
      if (util_format_has_alpha(ctx->draw_buffer->strb->format)) {
         /* no blending is required if the paints and the image are opaque */
         advanced_blending = !paint_is_opaque(ctx->state.vg.fill_paint) ||
                             !paint_is_opaque(ctx->state.vg.stroke_paint);
         if (!advanced_blending && shader->drawing_image) {
            advanced_blending =
               util_format_has_alpha(shader->image->sampler_view->format);
         }
         break;
      }
      /* fall through */
   default:
      advanced_blending = VG_FALSE;
      break;
   }

   return advanced_blending;
}

static VGint blend_bind_samplers(struct shader *shader,
                                 struct pipe_sampler_state **samplers,
                                 struct pipe_sampler_view **sampler_views)
{
   if (blend_use_shader(shader)) {
      struct vg_context *ctx = shader->context;

      samplers[2] = &ctx->blend_sampler;
      sampler_views[2] = vg_prepare_blend_surface(ctx);

      if (!samplers[0] || !sampler_views[0]) {
         samplers[0] = samplers[2];
         sampler_views[0] = sampler_views[2];
      }
      if (!samplers[1] || !sampler_views[1]) {
         samplers[1] = samplers[0];
         sampler_views[1] = sampler_views[0];
      }

      return 1;
   }
   return 0;
}

static VGint setup_samplers(struct shader *shader,
                            struct pipe_sampler_state **samplers,
                            struct pipe_sampler_view **sampler_views)
{
   /* a little wonky: we use the num as a boolean that just says
    * whether any sampler/textures have been set. the actual numbering
    * for samplers is always the same:
    * 0 - paint sampler/texture for gradient/pattern
    * 1 - mask sampler/texture
    * 2 - blend sampler/texture
    * 3 - image sampler/texture
    * */
   VGint num = 0;

   samplers[0] = NULL;
   samplers[1] = NULL;
   samplers[2] = NULL;
   samplers[3] = NULL;
   sampler_views[0] = NULL;
   sampler_views[1] = NULL;
   sampler_views[2] = NULL;
   sampler_views[3] = NULL;

   num += paint_bind_samplers(shader->paint, samplers, sampler_views);
   num += mask_bind_samplers(samplers, sampler_views);
   num += blend_bind_samplers(shader, samplers, sampler_views);
   if (shader->drawing_image && shader->image)
      num += image_bind_samplers(shader->image, samplers, sampler_views);

   return (num) ? 4 : 0;
}

static INLINE VGboolean is_format_bw(struct shader *shader)
{
#if 0
   struct vg_context *ctx = shader->context;
   struct st_framebuffer *stfb = ctx->draw_buffer;
#endif

   if (shader->drawing_image && shader->image) {
      if (shader->image->format == VG_BW_1)
         return VG_TRUE;
   }

   return VG_FALSE;
}

static void setup_shader_program(struct shader *shader)
{
   struct vg_context *ctx = shader->context;
   VGint shader_id = 0;
   VGBlendMode blend_mode = ctx->state.vg.blend_mode;
   VGboolean black_white = is_format_bw(shader);

   /* 1st stage: fill */
   if (!shader->drawing_image ||
       (shader->image_mode == VG_DRAW_IMAGE_MULTIPLY || shader->image_mode == VG_DRAW_IMAGE_STENCIL)) {
      switch(paint_type(shader->paint)) {
      case VG_PAINT_TYPE_COLOR:
         shader_id |= VEGA_SOLID_FILL_SHADER;
         break;
      case VG_PAINT_TYPE_LINEAR_GRADIENT:
         shader_id |= VEGA_LINEAR_GRADIENT_SHADER;
         break;
      case VG_PAINT_TYPE_RADIAL_GRADIENT:
         shader_id |= VEGA_RADIAL_GRADIENT_SHADER;
         break;
      case VG_PAINT_TYPE_PATTERN:
         shader_id |= VEGA_PATTERN_SHADER;
         break;

      default:
         abort();
      }

      if (paint_is_degenerate(shader->paint))
         shader_id = VEGA_PAINT_DEGENERATE_SHADER;
   }

   /* second stage image */
   if (shader->drawing_image) {
      switch(shader->image_mode) {
      case VG_DRAW_IMAGE_NORMAL:
         shader_id |= VEGA_IMAGE_NORMAL_SHADER;
         break;
      case VG_DRAW_IMAGE_MULTIPLY:
         shader_id |= VEGA_IMAGE_MULTIPLY_SHADER;
         break;
      case VG_DRAW_IMAGE_STENCIL:
         shader_id |= VEGA_IMAGE_STENCIL_SHADER;
         break;
      default:
         debug_printf("Unknown image mode!");
      }
   }

   if (shader->color_transform)
      shader_id |= VEGA_COLOR_TRANSFORM_SHADER;

   if (blend_use_shader(shader)) {
      if (shader->drawing_image && shader->image_mode == VG_DRAW_IMAGE_STENCIL)
         shader_id |= VEGA_ALPHA_PER_CHANNEL_SHADER;
      else
         shader_id |= VEGA_ALPHA_NORMAL_SHADER;

      switch(blend_mode) {
      case VG_BLEND_SRC:
         shader_id |= VEGA_BLEND_SRC_SHADER;
         break;
      case VG_BLEND_SRC_OVER:
         shader_id |= VEGA_BLEND_SRC_OVER_SHADER;
         break;
      case VG_BLEND_DST_OVER:
         shader_id |= VEGA_BLEND_DST_OVER_SHADER;
         break;
      case VG_BLEND_SRC_IN:
         shader_id |= VEGA_BLEND_SRC_IN_SHADER;
         break;
      case VG_BLEND_DST_IN:
         shader_id |= VEGA_BLEND_DST_IN_SHADER;
         break;
      case VG_BLEND_MULTIPLY:
         shader_id |= VEGA_BLEND_MULTIPLY_SHADER;
         break;
      case VG_BLEND_SCREEN:
         shader_id |= VEGA_BLEND_SCREEN_SHADER;
         break;
      case VG_BLEND_DARKEN:
         shader_id |= VEGA_BLEND_DARKEN_SHADER;
         break;
      case VG_BLEND_LIGHTEN:
         shader_id |= VEGA_BLEND_LIGHTEN_SHADER;
         break;
      case VG_BLEND_ADDITIVE:
         shader_id |= VEGA_BLEND_ADDITIVE_SHADER;
         break;
      default:
         assert(0);
         break;
      }
   }
   else {
      /* update alpha of the source */
      if (shader->drawing_image && shader->image_mode == VG_DRAW_IMAGE_STENCIL)
         shader_id |= VEGA_ALPHA_PER_CHANNEL_SHADER;
   }

   if (shader->masking)
      shader_id |= VEGA_MASK_SHADER;

   if (black_white)
      shader_id |= VEGA_BW_SHADER;

   shader->fs = shaders_cache_fill(ctx->sc, shader_id);
}


void shader_bind(struct shader *shader)
{
   struct vg_context *ctx = shader->context;
   struct pipe_sampler_state *samplers[PIPE_MAX_SAMPLERS];
   struct pipe_sampler_view *sampler_views[PIPE_MAX_SAMPLERS];
   VGint num_samplers, param_bytes;

   /* first resolve the real paint type */
   paint_resolve_type(shader->paint);

   num_samplers = setup_samplers(shader, samplers, sampler_views);
   param_bytes = setup_constant_buffer(shader);
   setup_shader_program(shader);

   renderer_validate_for_shader(ctx->renderer,
         (const struct pipe_sampler_state **) samplers,
         sampler_views, num_samplers,
         &shader->modelview,
         shader->fs, (const void *) shader->constants, param_bytes);
}

void shader_set_image_mode(struct shader *shader, VGImageMode image_mode)
{
   shader->image_mode = image_mode;
}

VGImageMode shader_image_mode(struct shader *shader)
{
   return shader->image_mode;
}

void shader_set_drawing_image(struct shader *shader, VGboolean drawing_image)
{
   shader->drawing_image = drawing_image;
}

VGboolean shader_drawing_image(struct shader *shader)
{
   return shader->drawing_image;
}

void shader_set_image(struct shader *shader, struct vg_image *img)
{
   shader->image = img;
}

/**
 * Set the transformation to map a vertex to the surface coordinates.
 */
void shader_set_surface_matrix(struct shader *shader,
                               const struct matrix *mat)
{
   shader->modelview = *mat;
}

/**
 * Set the transformation to map a pixel to the paint coordinates.
 */
void shader_set_paint_matrix(struct shader *shader, const struct matrix *mat)
{
   const struct st_framebuffer *stfb = shader->context->draw_buffer;
   const VGfloat px_center_offset = 0.5f;

   memcpy(&shader->paint_matrix, mat, sizeof(*mat));

   /* make it window-to-paint for the shaders */
   matrix_translate(&shader->paint_matrix, px_center_offset,
         stfb->height - 1.0f + px_center_offset);
   matrix_scale(&shader->paint_matrix, 1.0f, -1.0f);
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d130 1
a130 1
static VGboolean blend_use_shader(struct vg_context *ctx)
d132 1
a135 6
   case VG_BLEND_SRC_OVER:
      advanced_blending =
         (!paint_is_opaque(ctx->state.vg.fill_paint) ||
          !paint_is_opaque(ctx->state.vg.stroke_paint)) &&
         util_format_has_alpha(ctx->draw_buffer->strb->format);
      break;
d144 12
d164 1
a164 1
static VGint blend_bind_samplers(struct vg_context *ctx,
d168 3
a170 1
   if (blend_use_shader(ctx)) {
a191 1
   struct vg_context *ctx = shader->context;
d213 1
a213 1
   num += blend_bind_samplers(ctx, samplers, sampler_views);
d287 1
a287 1
   if (blend_use_shader(ctx)) {
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a36 1
#include "pipe/p_screen.h"
a37 1
#include "util/u_inlines.h"
d137 2
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 1
d41 2
d44 1
a44 1
#define MAX_CONSTANTS 20
d49 1
d54 3
d61 1
a61 1
   struct pipe_buffer *cbuf;
d78 6
a83 1
   free(shader);
d106 1
a106 2

static void setup_constant_buffer(struct shader *shader)
d108 1
a108 3
   struct vg_context *ctx = shader->context;
   struct pipe_context *pipe = shader->context->pipe;
   struct pipe_buffer **cbuf = &shader->cbuf;
d110 1
a110 1
   float temp_buf[MAX_CONSTANTS];
d112 2
a113 2
   assert(param_bytes <= sizeof(temp_buf));
   paint_fill_constant_buffer(shader->paint, temp_buf);
d115 6
a120 9
   if (*cbuf == NULL ||
       memcmp(temp_buf, shader->constants, param_bytes) != 0)
   {
      pipe_buffer_reference(cbuf, NULL);

      memcpy(shader->constants, temp_buf, param_bytes);
      *cbuf = pipe_user_buffer_create(pipe->screen,
                                      &shader->constants,
                                      sizeof(shader->constants));
d122 6
d129 1
a129 1
   ctx->pipe->set_constant_buffer(ctx->pipe, PIPE_SHADER_FRAGMENT, 0, *cbuf);
d132 1
a132 3
static VGint blend_bind_samplers(struct vg_context *ctx,
                                 struct pipe_sampler_state **samplers,
                                 struct pipe_texture **textures)
d134 1
a134 1
   VGBlendMode bmode = ctx->state.vg.blend_mode;
d136 17
a152 5
   if (bmode == VG_BLEND_MULTIPLY ||
       bmode == VG_BLEND_SCREEN ||
       bmode == VG_BLEND_DARKEN ||
       bmode == VG_BLEND_LIGHTEN) {
      struct st_framebuffer *stfb = ctx->draw_buffer;
d154 2
a155 1
      vg_prepare_blend_surface(ctx);
d157 5
d163 1
a163 1
      textures[2] = stfb->blend_texture;
d165 1
a165 1
      if (!samplers[0] || !textures[0]) {
d167 1
a167 1
         textures[0] = textures[2];
d169 1
a169 1
      if (!samplers[1] || !textures[1]) {
d171 1
a171 1
         textures[1] = textures[0];
d179 3
a181 1
static void setup_samplers(struct shader *shader)
a182 2
   struct pipe_sampler_state *samplers[PIPE_MAX_SAMPLERS];
   struct pipe_texture *textures[PIPE_MAX_SAMPLERS];
d198 8
a205 8
   textures[0] = NULL;
   textures[1] = NULL;
   textures[2] = NULL;
   textures[3] = NULL;

   num += paint_bind_samplers(shader->paint, samplers, textures);
   num += mask_bind_samplers(samplers, textures);
   num += blend_bind_samplers(ctx, samplers, textures);
d207 1
a207 1
      num += image_bind_samplers(shader->image, samplers, textures);
d209 1
a209 4
   if (num) {
      cso_set_samplers(ctx->cso_context, 4, (const struct pipe_sampler_state **)samplers);
      cso_set_sampler_textures(ctx->cso_context, 4, textures);
   }
d254 3
d276 51
a329 18
   switch(blend_mode) {
   case VG_BLEND_MULTIPLY:
      shader_id |= VEGA_BLEND_MULTIPLY_SHADER;
      break;
   case VG_BLEND_SCREEN:
      shader_id |= VEGA_BLEND_SCREEN_SHADER;
      break;
   case VG_BLEND_DARKEN:
      shader_id |= VEGA_BLEND_DARKEN_SHADER;
      break;
   case VG_BLEND_LIGHTEN:
      shader_id |= VEGA_BLEND_LIGHTEN_SHADER;
      break;
   default:
      /* handled by pipe_blend_state */
      break;
   }

a333 1
   cso_set_fragment_shader_handle(ctx->cso_context, shader->fs);
d339 5
d347 2
a348 2
   setup_constant_buffer(shader);
   setup_samplers(shader);
d350 6
d381 25
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a33 1
#include "renderer.h"
a39 2
#include "util/u_math.h"
#include "util/u_format.h"
d41 1
a41 1
#define MAX_CONSTANTS 28
a45 1
   VGboolean color_transform;
a49 3
   struct matrix modelview;
   struct matrix paint_matrix;

d54 1
a54 1
   struct pipe_resource *cbuf;
d71 1
a71 6
   FREE(shader);
}

void shader_set_color_transform(struct shader *shader, VGboolean set)
{
   shader->color_transform = set;
d94 2
a95 1
static VGint setup_constant_buffer(struct shader *shader)
d97 3
a99 1
   const struct vg_state *state = &shader->context->state.vg;
d101 1
a101 1
   VGint i;
d103 2
a104 2
   param_bytes += sizeof(VGfloat) * 8;
   assert(param_bytes <= sizeof(shader->constants));
d106 9
a114 6
   if (state->color_transform) {
      for (i = 0; i < 8; i++) {
         VGfloat val = (i < 4) ? 127.0f : 1.0f;
         shader->constants[i] =
            CLAMP(state->color_transform_values[i], -val, val);
      }
a115 6
   else {
      memset(shader->constants, 0, sizeof(VGfloat) * 8);
   }

   paint_fill_constant_buffer(shader->paint,
         &shader->paint_matrix, shader->constants + 8);
d117 1
a117 1
   return param_bytes;
d120 3
a122 1
static VGboolean blend_use_shader(struct vg_context *ctx)
d124 1
a124 1
   VGboolean advanced_blending;
d126 5
a130 17
   switch (ctx->state.vg.blend_mode) {
   case VG_BLEND_SRC_OVER:
      advanced_blending =
         util_format_has_alpha(ctx->draw_buffer->strb->format);
      break;
   case VG_BLEND_DST_OVER:
   case VG_BLEND_MULTIPLY:
   case VG_BLEND_SCREEN:
   case VG_BLEND_DARKEN:
   case VG_BLEND_LIGHTEN:
   case VG_BLEND_ADDITIVE:
      advanced_blending = VG_TRUE;
      break;
   default:
      advanced_blending = VG_FALSE;
      break;
   }
d132 1
a132 2
   return advanced_blending;
}
a133 5
static VGint blend_bind_samplers(struct vg_context *ctx,
                                 struct pipe_sampler_state **samplers,
                                 struct pipe_sampler_view **sampler_views)
{
   if (blend_use_shader(ctx)) {
d135 1
a135 1
      sampler_views[2] = vg_prepare_blend_surface(ctx);
d137 1
a137 1
      if (!samplers[0] || !sampler_views[0]) {
d139 1
a139 1
         sampler_views[0] = sampler_views[2];
d141 1
a141 1
      if (!samplers[1] || !sampler_views[1]) {
d143 1
a143 1
         sampler_views[1] = sampler_views[0];
d151 1
a151 3
static VGint setup_samplers(struct shader *shader,
                            struct pipe_sampler_state **samplers,
                            struct pipe_sampler_view **sampler_views)
d153 2
d170 8
a177 8
   sampler_views[0] = NULL;
   sampler_views[1] = NULL;
   sampler_views[2] = NULL;
   sampler_views[3] = NULL;

   num += paint_bind_samplers(shader->paint, samplers, sampler_views);
   num += mask_bind_samplers(samplers, sampler_views);
   num += blend_bind_samplers(ctx, samplers, sampler_views);
d179 1
a179 1
      num += image_bind_samplers(shader->image, samplers, sampler_views);
d181 4
a184 1
   return (num) ? 4 : 0;
a228 3

      if (paint_is_degenerate(shader->paint))
         shader_id = VEGA_PAINT_DEGENERATE_SHADER;
d248 2
a249 2
   if (shader->color_transform)
      shader_id |= VEGA_COLOR_TRANSFORM_SHADER;
d251 16
a266 46
   if (blend_use_shader(ctx)) {
      if (shader->drawing_image && shader->image_mode == VG_DRAW_IMAGE_STENCIL)
         shader_id |= VEGA_ALPHA_PER_CHANNEL_SHADER;
      else
         shader_id |= VEGA_ALPHA_NORMAL_SHADER;

      switch(blend_mode) {
      case VG_BLEND_SRC:
         shader_id |= VEGA_BLEND_SRC_SHADER;
         break;
      case VG_BLEND_SRC_OVER:
         shader_id |= VEGA_BLEND_SRC_OVER_SHADER;
         break;
      case VG_BLEND_DST_OVER:
         shader_id |= VEGA_BLEND_DST_OVER_SHADER;
         break;
      case VG_BLEND_SRC_IN:
         shader_id |= VEGA_BLEND_SRC_IN_SHADER;
         break;
      case VG_BLEND_DST_IN:
         shader_id |= VEGA_BLEND_DST_IN_SHADER;
         break;
      case VG_BLEND_MULTIPLY:
         shader_id |= VEGA_BLEND_MULTIPLY_SHADER;
         break;
      case VG_BLEND_SCREEN:
         shader_id |= VEGA_BLEND_SCREEN_SHADER;
         break;
      case VG_BLEND_DARKEN:
         shader_id |= VEGA_BLEND_DARKEN_SHADER;
         break;
      case VG_BLEND_LIGHTEN:
         shader_id |= VEGA_BLEND_LIGHTEN_SHADER;
         break;
      case VG_BLEND_ADDITIVE:
         shader_id |= VEGA_BLEND_ADDITIVE_SHADER;
         break;
      default:
         assert(0);
         break;
      }
   }
   else {
      /* update alpha of the source */
      if (shader->drawing_image && shader->image_mode == VG_DRAW_IMAGE_STENCIL)
         shader_id |= VEGA_ALPHA_PER_CHANNEL_SHADER;
a268 3
   if (shader->masking)
      shader_id |= VEGA_MASK_SHADER;

d273 1
a278 5
   struct vg_context *ctx = shader->context;
   struct pipe_sampler_state *samplers[PIPE_MAX_SAMPLERS];
   struct pipe_sampler_view *sampler_views[PIPE_MAX_SAMPLERS];
   VGint num_samplers, param_bytes;

d282 2
a283 2
   num_samplers = setup_samplers(shader, samplers, sampler_views);
   param_bytes = setup_constant_buffer(shader);
a284 6

   renderer_validate_for_shader(ctx->renderer,
         (const struct pipe_sampler_state **) samplers,
         sampler_views, num_samplers,
         &shader->modelview,
         shader->fs, (const void *) shader->constants, param_bytes);
a309 25
}

/**
 * Set the transformation to map a vertex to the surface coordinates.
 */
void shader_set_surface_matrix(struct shader *shader,
                               const struct matrix *mat)
{
   shader->modelview = *mat;
}

/**
 * Set the transformation to map a pixel to the paint coordinates.
 */
void shader_set_paint_matrix(struct shader *shader, const struct matrix *mat)
{
   const struct st_framebuffer *stfb = shader->context->draw_buffer;
   const VGfloat px_center_offset = 0.5f;

   memcpy(&shader->paint_matrix, mat, sizeof(*mat));

   /* make it window-to-paint for the shaders */
   matrix_translate(&shader->paint_matrix, px_center_offset,
         stfb->height - 1.0f + px_center_offset);
   matrix_scale(&shader->paint_matrix, 1.0f, -1.0f);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d37 1
d39 1
d132 1
a132 1
static VGboolean blend_use_shader(struct shader *shader)
a133 1
   struct vg_context *ctx = shader->context;
d137 4
a148 12
   case VG_BLEND_SRC_OVER:
      if (util_format_has_alpha(ctx->draw_buffer->strb->format)) {
         /* no blending is required if the paints and the image are opaque */
         advanced_blending = !paint_is_opaque(ctx->state.vg.fill_paint) ||
                             !paint_is_opaque(ctx->state.vg.stroke_paint);
         if (!advanced_blending && shader->drawing_image) {
            advanced_blending =
               util_format_has_alpha(shader->image->sampler_view->format);
         }
         break;
      }
      /* fall through */
d157 1
a157 1
static VGint blend_bind_samplers(struct shader *shader,
d161 1
a161 3
   if (blend_use_shader(shader)) {
      struct vg_context *ctx = shader->context;

d183 1
d205 1
a205 1
   num += blend_bind_samplers(shader, samplers, sampler_views);
d279 1
a279 1
   if (blend_use_shader(shader)) {
@


