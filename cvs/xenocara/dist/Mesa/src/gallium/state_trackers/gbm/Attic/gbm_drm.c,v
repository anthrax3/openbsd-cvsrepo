head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.1
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	v10_2_3:1.1.1.1
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2015.02.20.23.09.54;	author jsg;	state Exp;
branches;
next	1.3;
commitid	4ry2gvZGMXkCUD2n;

1.3
date	2015.01.25.14.41.17;	author jsg;	state Exp;
branches;
next	1.2;
commitid	mcxB0JvoI9gTDYXU;

1.2
date	2013.09.05.14.01.48;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.13.17;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2015.01.25.14.09.40;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.3
date	2015.02.20.22.46.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Benjamin Franzke <benjaminfranzke@@googlemail.com>
 */

#include "util/u_memory.h"
#include "util/u_inlines.h"

#include "state_tracker/drm_driver.h"

#include <unistd.h>
#include <sys/types.h>

#include "gbm_gallium_drmint.h"

/* For importing wl_buffer */
#if HAVE_WAYLAND_PLATFORM
#include "../../../egl/wayland/wayland-drm/wayland-drm.h"
#endif

static INLINE enum pipe_format
gbm_format_to_gallium(enum gbm_bo_format format)
{
   switch (format) {
   case GBM_BO_FORMAT_XRGB8888:
      return PIPE_FORMAT_BGRX8888_UNORM;
   case GBM_BO_FORMAT_ARGB8888:
      return PIPE_FORMAT_BGRA8888_UNORM;
   default:
      return PIPE_FORMAT_NONE;
   }

   return PIPE_FORMAT_NONE;
}

static INLINE uint
gbm_usage_to_gallium(uint usage)
{
   uint resource_usage = 0;

   if (usage & GBM_BO_USE_SCANOUT)
      resource_usage |= PIPE_BIND_SCANOUT;

   if (usage & GBM_BO_USE_RENDERING)
      resource_usage |= PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;

   if (usage & GBM_BO_USE_CURSOR_64X64)
      resource_usage |= PIPE_BIND_CURSOR;

   return resource_usage;
}

static int
gbm_gallium_drm_is_format_supported(struct gbm_device *gbm,
                                    enum gbm_bo_format format,
                                    uint32_t usage)
{
   struct gbm_gallium_drm_device *gdrm = gbm_gallium_drm_device(gbm);
   enum pipe_format pf;

   pf = gbm_format_to_gallium(format);
   if (pf == PIPE_FORMAT_NONE)
      return 0;

   if (!gdrm->screen->is_format_supported(gdrm->screen, PIPE_TEXTURE_2D, pf, 0,
                                          gbm_usage_to_gallium(usage)))
      return 0;

   if (usage & GBM_BO_USE_SCANOUT && format != GBM_BO_FORMAT_XRGB8888)
      return 0;

   return 1;
}

static void
gbm_gallium_drm_bo_destroy(struct gbm_bo *_bo)
{
   struct gbm_gallium_drm_bo *bo = gbm_gallium_drm_bo(_bo);

   pipe_resource_reference(&bo->resource, NULL);
   free(bo);
}

static struct gbm_bo *
gbm_gallium_drm_bo_import(struct gbm_device *gbm,
                          uint32_t type, void *buffer, uint32_t usage)
{
   struct gbm_gallium_drm_device *gdrm = gbm_gallium_drm_device(gbm);
   struct gbm_gallium_drm_bo *bo;
   struct winsys_handle whandle;
   struct pipe_resource *resource;

   switch (type) {
#if HAVE_WAYLAND_PLATFORM
   case GBM_BO_IMPORT_WL_BUFFER:
   {
      struct wl_drm_buffer *wb = (struct wl_drm_buffer *) buffer;

      resource = wb->driver_buffer;
      break;
   }
#endif

   case GBM_BO_IMPORT_EGL_IMAGE:
      if (!gdrm->lookup_egl_image)
         return NULL;

      resource = gdrm->lookup_egl_image(gdrm->lookup_egl_image_data, buffer);
      if (resource == NULL)
         return NULL;
      break;

   default:
      return NULL;
   }

   bo = CALLOC_STRUCT(gbm_gallium_drm_bo);
   if (bo == NULL)
      return NULL;

   bo->base.base.gbm = gbm;
   bo->base.base.width = resource->width0;
   bo->base.base.height = resource->height0;

   switch (resource->format) {
   case PIPE_FORMAT_BGRX8888_UNORM:
      bo->base.base.format = GBM_BO_FORMAT_XRGB8888;
      break;
   case PIPE_FORMAT_BGRA8888_UNORM:
      bo->base.base.format = GBM_BO_FORMAT_ARGB8888;
      break;
   default:
      FREE(bo);
      return NULL;
   }

   pipe_resource_reference(&bo->resource, resource);

   memset(&whandle, 0, sizeof(whandle));
   whandle.type = DRM_API_HANDLE_TYPE_KMS;
   gdrm->screen->resource_get_handle(gdrm->screen, bo->resource, &whandle);

   bo->base.base.handle.u32 = whandle.handle;
   bo->base.base.stride      = whandle.stride;

   return &bo->base.base;
}

static struct gbm_bo *
gbm_gallium_drm_bo_create(struct gbm_device *gbm,
                          uint32_t width, uint32_t height,
                          enum gbm_bo_format format, uint32_t usage)
{
   struct gbm_gallium_drm_device *gdrm = gbm_gallium_drm_device(gbm);
   struct gbm_gallium_drm_bo *bo;
   struct pipe_resource templ;
   struct winsys_handle whandle;
   enum pipe_format pf;

   bo = CALLOC_STRUCT(gbm_gallium_drm_bo);
   if (bo == NULL)
      return NULL;

   bo->base.base.gbm = gbm;
   bo->base.base.width = width;
   bo->base.base.height = height;
   bo->base.base.format = format;

   pf = gbm_format_to_gallium(format);
   if (pf == PIPE_FORMAT_NONE)
      return NULL;

   memset(&templ, 0, sizeof(templ));
   templ.bind = gbm_usage_to_gallium(usage);
   templ.format = pf;
   templ.target = PIPE_TEXTURE_2D;
   templ.last_level = 0;
   templ.width0 = width;
   templ.height0 = height;
   templ.depth0 = 1;
   templ.array_size = 1;

   bo->resource = gdrm->screen->resource_create(gdrm->screen, &templ);
   if (bo->resource == NULL) {
      FREE(bo);
      return NULL;
   }

   memset(&whandle, 0, sizeof(whandle));
   whandle.type = DRM_API_HANDLE_TYPE_KMS;
   gdrm->screen->resource_get_handle(gdrm->screen, bo->resource, &whandle);

   bo->base.base.handle.u32 = whandle.handle;
   bo->base.base.stride      = whandle.stride;

   return &bo->base.base;
}

static void
gbm_gallium_drm_destroy(struct gbm_device *gbm)
{
   struct gbm_gallium_drm_device *gdrm = gbm_gallium_drm_device(gbm);

   gallium_screen_destroy(gdrm);
   FREE(gdrm);
}

struct gbm_device *
gbm_gallium_drm_device_create(int fd)
{
   struct gbm_gallium_drm_device *gdrm;
   int ret;

   gdrm = calloc(1, sizeof *gdrm);

   gdrm->base.base.fd = fd;
   gdrm->base.base.bo_create = gbm_gallium_drm_bo_create;
   gdrm->base.base.bo_import = gbm_gallium_drm_bo_import;
   gdrm->base.base.bo_destroy = gbm_gallium_drm_bo_destroy;
   gdrm->base.base.is_format_supported = gbm_gallium_drm_is_format_supported;
   gdrm->base.base.destroy = gbm_gallium_drm_destroy;

   gdrm->base.type = GBM_DRM_DRIVER_TYPE_GALLIUM;
   gdrm->base.base.name = "drm";

   ret = gallium_screen_create(gdrm);
   if (ret) {
      free(gdrm);
      return NULL;
   }

   return &gdrm->base.base;
}
@


1.4
log
@Merge Mesa 10.2.9
@
text
@@


1.3
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a30 1
#include "pipe-loader/pipe_loader.h"
d69 1
a69 1
   if (usage & GBM_BO_USE_CURSOR)
d87 1
a87 1
   if (!gdrm->screen->is_format_supported(gdrm->screen, pf, PIPE_TEXTURE_2D, 0,
d226 2
a227 6
   free(gdrm->base.driver_name);
   gdrm->screen->destroy(gdrm->screen);
#if !GALLIUM_STATIC_TARGETS
   pipe_loader_release(&gdrm->dev, 1);
#endif
   free(gdrm);
d230 1
a230 19
#if !GALLIUM_STATIC_TARGETS
#ifdef HAVE_PIPE_LOADER_DRM
static const char *
get_library_search_path(void)
{
   const char *search_path = NULL;

   /* don't allow setuid apps to use GBM_BACKENDS_PATH */
   if (geteuid() == getuid())
      search_path = getenv("GBM_BACKENDS_PATH");
   if (search_path == NULL)
      search_path = PIPE_SEARCH_DIR;

   return search_path;
}
#endif
#endif

static struct gbm_device *
d234 1
a236 2
   if (!gdrm)
      return NULL;
d248 5
a252 9
#if GALLIUM_STATIC_TARGETS
   gdrm->screen = dd_create_screen(gdrm->base.base.fd);
#else
#ifdef HAVE_PIPE_LOADER_DRM
   if (pipe_loader_drm_probe_fd(&gdrm->dev, gdrm->base.base.fd, false))
      gdrm->screen = pipe_loader_create_screen(gdrm->dev,
                                               get_library_search_path());
#endif /* HAVE_PIPE_LOADER_DRM */
#endif
a253 10
   if (gdrm->screen == NULL)
      goto out_no_screen;

#if GALLIUM_STATIC_TARGETS
   gdrm->base.driver_name = strdup(dd_driver_name());
#else
#ifdef HAVE_PIPE_LOADER_DRM
   gdrm->base.driver_name = strdup(gdrm->dev->driver_name);
#endif /* HAVE_PIPE_LOADER_DRM */
#endif
a254 9

out_no_screen:
   debug_printf("failed to load gallium_gbm\n");
#if !GALLIUM_STATIC_TARGETS
   if (gdrm->dev)
      pipe_loader_release(&gdrm->dev, 1);
#endif
   free(gdrm);
   return NULL;
a255 6


GBM_EXPORT struct gbm_backend gbm_backend = {
   .backend_name = "gallium_drm",
   .create_device = gbm_gallium_drm_device_create,
};
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d31 1
d70 1
a70 1
   if (usage & GBM_BO_USE_CURSOR_64X64)
d88 1
a88 1
   if (!gdrm->screen->is_format_supported(gdrm->screen, PIPE_TEXTURE_2D, pf, 0,
d227 6
a232 2
   gallium_screen_destroy(gdrm);
   FREE(gdrm);
d235 19
a253 1
struct gbm_device *
a256 1
   int ret;
d259 2
d272 12
a283 5
   ret = gallium_screen_create(gdrm);
   if (ret) {
      free(gdrm);
      return NULL;
   }
d285 7
d293 9
d303 6
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d38 5
d48 1
a48 1
      return PIPE_FORMAT_B8G8R8X8_UNORM;
d50 1
a50 1
      return PIPE_FORMAT_B8G8R8A8_UNORM;
d107 2
a108 4
gbm_gallium_drm_bo_create_from_egl_image(struct gbm_device *gbm,
                                         void *egl_dpy, void *egl_image,
                                         uint32_t width, uint32_t height,
                                         uint32_t usage)
d113 12
d126 10
a135 1
   if (!gdrm->lookup_egl_image)
d137 1
d143 12
a154 3
   bo->resource = gdrm->lookup_egl_image(gdrm->lookup_egl_image_data,
                                         egl_image);
   if (bo->resource == NULL) {
d159 1
a159 3
   bo->base.base.gbm = gbm;
   bo->base.base.width = width;
   bo->base.base.height = height;
d166 1
a166 1
   bo->base.base.pitch      = whandle.stride;
d189 1
d216 1
a216 1
   bo->base.base.pitch      = whandle.stride;
d226 1
a226 4
   gdrm->screen->destroy(gdrm->screen);

   FREE(gdrm->base.driver_name);

d240 1
a240 2
   gdrm->base.base.bo_create_from_egl_image =
      gbm_gallium_drm_bo_create_from_egl_image;
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@a37 5
/* For importing wl_buffer */
#if HAVE_WAYLAND_PLATFORM
#include "../../../egl/wayland/wayland-drm/wayland-drm.h"
#endif

d43 1
a43 1
      return PIPE_FORMAT_BGRX8888_UNORM;
d45 1
a45 1
      return PIPE_FORMAT_BGRA8888_UNORM;
d102 4
a105 2
gbm_gallium_drm_bo_import(struct gbm_device *gbm,
                          uint32_t type, void *buffer, uint32_t usage)
a109 12
   struct pipe_resource *resource;

   switch (type) {
#if HAVE_WAYLAND_PLATFORM
   case GBM_BO_IMPORT_WL_BUFFER:
   {
      struct wl_drm_buffer *wb = (struct wl_drm_buffer *) buffer;

      resource = wb->driver_buffer;
      break;
   }
#endif
d111 1
a111 10
   case GBM_BO_IMPORT_EGL_IMAGE:
      if (!gdrm->lookup_egl_image)
         return NULL;

      resource = gdrm->lookup_egl_image(gdrm->lookup_egl_image_data, buffer);
      if (resource == NULL)
         return NULL;
      break;

   default:
a112 1
   }
d118 3
a120 12
   bo->base.base.gbm = gbm;
   bo->base.base.width = resource->width0;
   bo->base.base.height = resource->height0;

   switch (resource->format) {
   case PIPE_FORMAT_BGRX8888_UNORM:
      bo->base.base.format = GBM_BO_FORMAT_XRGB8888;
      break;
   case PIPE_FORMAT_BGRA8888_UNORM:
      bo->base.base.format = GBM_BO_FORMAT_ARGB8888;
      break;
   default:
d125 3
a127 1
   pipe_resource_reference(&bo->resource, resource);
d134 1
a134 1
   bo->base.base.stride      = whandle.stride;
a156 1
   bo->base.base.format = format;
d183 1
a183 1
   bo->base.base.stride      = whandle.stride;
d193 4
a196 1
   gallium_screen_destroy(gdrm);
d210 2
a211 1
   gdrm->base.base.bo_import = gbm_gallium_drm_bo_import;
@


1.1.1.2
log
@Import Mesa 10.4.3
@
text
@a30 1
#include "pipe-loader/pipe_loader.h"
d69 1
a69 1
   if (usage & GBM_BO_USE_CURSOR)
d87 1
a87 1
   if (!gdrm->screen->is_format_supported(gdrm->screen, pf, PIPE_TEXTURE_2D, 0,
d226 2
a227 6
   free(gdrm->base.driver_name);
   gdrm->screen->destroy(gdrm->screen);
#if !GALLIUM_STATIC_TARGETS
   pipe_loader_release(&gdrm->dev, 1);
#endif
   free(gdrm);
d230 1
a230 19
#if !GALLIUM_STATIC_TARGETS
#ifdef HAVE_PIPE_LOADER_DRM
static const char *
get_library_search_path(void)
{
   const char *search_path = NULL;

   /* don't allow setuid apps to use GBM_BACKENDS_PATH */
   if (geteuid() == getuid())
      search_path = getenv("GBM_BACKENDS_PATH");
   if (search_path == NULL)
      search_path = PIPE_SEARCH_DIR;

   return search_path;
}
#endif
#endif

static struct gbm_device *
d234 1
a236 2
   if (!gdrm)
      return NULL;
d248 5
a252 9
#if GALLIUM_STATIC_TARGETS
   gdrm->screen = dd_create_screen(gdrm->base.base.fd);
#else
#ifdef HAVE_PIPE_LOADER_DRM
   if (pipe_loader_drm_probe_fd(&gdrm->dev, gdrm->base.base.fd, false))
      gdrm->screen = pipe_loader_create_screen(gdrm->dev,
                                               get_library_search_path());
#endif /* HAVE_PIPE_LOADER_DRM */
#endif
a253 10
   if (gdrm->screen == NULL)
      goto out_no_screen;

#if GALLIUM_STATIC_TARGETS
   gdrm->base.driver_name = strdup(dd_driver_name());
#else
#ifdef HAVE_PIPE_LOADER_DRM
   gdrm->base.driver_name = strdup(gdrm->dev->driver_name);
#endif /* HAVE_PIPE_LOADER_DRM */
#endif
a254 9

out_no_screen:
   debug_printf("failed to load gallium_gbm\n");
#if !GALLIUM_STATIC_TARGETS
   if (gdrm->dev)
      pipe_loader_release(&gdrm->dev, 1);
#endif
   free(gdrm);
   return NULL;
a255 6


GBM_EXPORT struct gbm_backend gbm_backend = {
   .backend_name = "gallium_drm",
   .create_device = gbm_gallium_drm_device_create,
};
@


1.1.1.3
log
@Import Mesa 10.2.9
@
text
@d31 1
d70 1
a70 1
   if (usage & GBM_BO_USE_CURSOR_64X64)
d88 1
a88 1
   if (!gdrm->screen->is_format_supported(gdrm->screen, PIPE_TEXTURE_2D, pf, 0,
d227 6
a232 2
   gallium_screen_destroy(gdrm);
   FREE(gdrm);
d235 19
a253 1
struct gbm_device *
a256 1
   int ret;
d259 2
d272 12
a283 5
   ret = gallium_screen_create(gdrm);
   if (ret) {
      free(gdrm);
      return NULL;
   }
d285 7
d293 9
d303 6
@


