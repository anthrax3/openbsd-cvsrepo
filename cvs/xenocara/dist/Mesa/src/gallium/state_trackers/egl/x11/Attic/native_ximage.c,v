head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.48;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.17;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.19;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2009-2010 Chia-I Wu <olv@@0xlab.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_format.h"
#include "pipe/p_compiler.h"
#include "util/u_inlines.h"
#include "state_tracker/xlibsw_api.h"
#include "sw/xlib/xlib_sw_winsys.h"
#include "util/u_debug.h"
#include "egllog.h"

#include "common/native_helper.h"
#include "native_x11.h"
#include "x11_screen.h"

struct ximage_display {
   struct native_display base;
   Display *dpy;
   boolean own_dpy;

   const struct native_event_handler *event_handler;

   struct x11_screen *xscr;
   int xscr_number;

   struct ximage_config *configs;
   int num_configs;
};

struct ximage_surface {
   struct native_surface base;
   Drawable drawable;
   enum pipe_format color_format;
   XVisualInfo visual;
   struct ximage_display *xdpy;

   unsigned int server_stamp;
   unsigned int client_stamp;

   struct resource_surface *rsurf;
   struct xlib_drawable xdraw;
};

struct ximage_config {
   struct native_config base;
   const XVisualInfo *visual;
};

static INLINE struct ximage_display *
ximage_display(const struct native_display *ndpy)
{
   return (struct ximage_display *) ndpy;
}

static INLINE struct ximage_surface *
ximage_surface(const struct native_surface *nsurf)
{
   return (struct ximage_surface *) nsurf;
}

static INLINE struct ximage_config *
ximage_config(const struct native_config *nconf)
{
   return (struct ximage_config *) nconf;
}

/**
 * Update the geometry of the surface.  This is a slow functions.
 */
static void
ximage_surface_update_geometry(struct native_surface *nsurf)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   Status ok;
   Window root;
   int x, y;
   unsigned int w, h, border, depth;

   ok = XGetGeometry(xsurf->xdpy->dpy, xsurf->drawable,
         &root, &x, &y, &w, &h, &border, &depth);
   if (ok && resource_surface_set_size(xsurf->rsurf, w, h))
      xsurf->server_stamp++;
}

/**
 * Update the buffers of the surface.
 */
static boolean
ximage_surface_update_buffers(struct native_surface *nsurf, uint buffer_mask)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);

   if (xsurf->client_stamp != xsurf->server_stamp) {
      ximage_surface_update_geometry(&xsurf->base);
      xsurf->client_stamp = xsurf->server_stamp;
   }

   return resource_surface_add_resources(xsurf->rsurf, buffer_mask);
}

/**
 * Emulate an invalidate event.
 */
static void
ximage_surface_invalidate(struct native_surface *nsurf)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   struct ximage_display *xdpy = xsurf->xdpy;

   xsurf->server_stamp++;
   xdpy->event_handler->invalid_surface(&xdpy->base,
         &xsurf->base, xsurf->server_stamp);
}

static boolean
ximage_surface_flush_frontbuffer(struct native_surface *nsurf)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   boolean ret;

   ret = resource_surface_present(xsurf->rsurf,
         NATIVE_ATTACHMENT_FRONT_LEFT, (void *) &xsurf->xdraw);
   /* force buffers to be updated in next validation call */
   ximage_surface_invalidate(&xsurf->base);

   return ret;
}

static boolean
ximage_surface_swap_buffers(struct native_surface *nsurf)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   boolean ret;

   ret = resource_surface_present(xsurf->rsurf,
         NATIVE_ATTACHMENT_BACK_LEFT, (void *) &xsurf->xdraw);

   resource_surface_swap_buffers(xsurf->rsurf,
         NATIVE_ATTACHMENT_FRONT_LEFT, NATIVE_ATTACHMENT_BACK_LEFT, TRUE);
   /* the front/back buffers have been swapped */
   ximage_surface_invalidate(&xsurf->base);

   return ret;
}

static boolean
ximage_surface_present(struct native_surface *nsurf,
                       const struct native_present_control *ctrl)
{
   boolean ret;

   if (ctrl->preserve || ctrl->swap_interval)
      return FALSE;

   switch (ctrl->natt) {
   case NATIVE_ATTACHMENT_FRONT_LEFT:
      ret = ximage_surface_flush_frontbuffer(nsurf);
      break;
   case NATIVE_ATTACHMENT_BACK_LEFT:
      ret = ximage_surface_swap_buffers(nsurf);
      break;
   default:
      ret = FALSE;
      break;
   }

   return ret;
}

static boolean
ximage_surface_validate(struct native_surface *nsurf, uint attachment_mask,
                        unsigned int *seq_num, struct pipe_resource **textures,
                        int *width, int *height)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   uint w, h;

   if (!ximage_surface_update_buffers(&xsurf->base, attachment_mask))
      return FALSE;

   if (seq_num)
      *seq_num = xsurf->client_stamp;

   if (textures)
      resource_surface_get_resources(xsurf->rsurf, textures, attachment_mask);

   resource_surface_get_size(xsurf->rsurf, &w, &h);
   if (width)
      *width = w;
   if (height)
      *height = h;

   return TRUE;
}

static void
ximage_surface_wait(struct native_surface *nsurf)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   XSync(xsurf->xdpy->dpy, FALSE);
   /* TODO XGetImage and update the front texture */
}

static void
ximage_surface_destroy(struct native_surface *nsurf)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);

   resource_surface_destroy(xsurf->rsurf);
   FREE(xsurf);
}

static struct ximage_surface *
ximage_display_create_surface(struct native_display *ndpy,
                              Drawable drawable,
                              const struct native_config *nconf)
{
   struct ximage_display *xdpy = ximage_display(ndpy);
   struct ximage_config *xconf = ximage_config(nconf);
   struct ximage_surface *xsurf;

   xsurf = CALLOC_STRUCT(ximage_surface);
   if (!xsurf)
      return NULL;

   xsurf->xdpy = xdpy;
   xsurf->color_format = xconf->base.color_format;
   xsurf->drawable = drawable;

   xsurf->rsurf = resource_surface_create(xdpy->base.screen,
         xsurf->color_format,
         PIPE_BIND_RENDER_TARGET |
         PIPE_BIND_SAMPLER_VIEW |
         PIPE_BIND_DISPLAY_TARGET |
         PIPE_BIND_SCANOUT);
   if (!xsurf->rsurf) {
      FREE(xsurf);
      return NULL;
   }

   xsurf->drawable = drawable;
   xsurf->visual = *xconf->visual;
   /* initialize the geometry */
   ximage_surface_update_geometry(&xsurf->base);

   xsurf->xdraw.visual = xsurf->visual.visual;
   xsurf->xdraw.depth = xsurf->visual.depth;
   xsurf->xdraw.drawable = xsurf->drawable;

   xsurf->base.destroy = ximage_surface_destroy;
   xsurf->base.present = ximage_surface_present;
   xsurf->base.validate = ximage_surface_validate;
   xsurf->base.wait = ximage_surface_wait;

   return xsurf;
}

static struct native_surface *
ximage_display_create_window_surface(struct native_display *ndpy,
                                     EGLNativeWindowType win,
                                     const struct native_config *nconf)
{
   struct ximage_surface *xsurf;

   xsurf = ximage_display_create_surface(ndpy, (Drawable) win, nconf);
   return (xsurf) ? &xsurf->base : NULL;
}

static enum pipe_format
get_pixmap_format(struct native_display *ndpy, EGLNativePixmapType pix)
{
   struct ximage_display *xdpy = ximage_display(ndpy);
   enum pipe_format fmt;
   uint depth;

   depth = x11_drawable_get_depth(xdpy->xscr, (Drawable) pix);

   switch (depth) {
   case 32:
      fmt = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   case 24:
      fmt = PIPE_FORMAT_B8G8R8X8_UNORM;
      break;
   case 16:
      fmt = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      fmt = PIPE_FORMAT_NONE;
      break;
   }

   return fmt;
}

static struct native_surface *
ximage_display_create_pixmap_surface(struct native_display *ndpy,
                                     EGLNativePixmapType pix,
                                     const struct native_config *nconf)
{
   struct ximage_surface *xsurf;

   /* find the config */
   if (!nconf) {
      struct ximage_display *xdpy = ximage_display(ndpy);
      enum pipe_format fmt = get_pixmap_format(&xdpy->base, pix);
      int i;

      if (fmt != PIPE_FORMAT_NONE) {
         for (i = 0; i < xdpy->num_configs; i++) {
            if (xdpy->configs[i].base.color_format == fmt) {
               nconf = &xdpy->configs[i].base;
               break;
            }
         }
      }

      if (!nconf)
         return NULL;
   }

   xsurf = ximage_display_create_surface(ndpy, (Drawable) pix, nconf);
   return (xsurf) ? &xsurf->base : NULL;
}

static enum pipe_format
choose_format(const XVisualInfo *vinfo)
{
   enum pipe_format fmt;
   /* TODO elaborate the formats */
   switch (vinfo->depth) {
   case 32:
      fmt = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   case 24:
      fmt = PIPE_FORMAT_B8G8R8X8_UNORM;
      break;
   case 16:
      fmt = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      fmt = PIPE_FORMAT_NONE;
      break;
   }

   return fmt;
}

static const struct native_config **
ximage_display_get_configs(struct native_display *ndpy, int *num_configs)
{
   struct ximage_display *xdpy = ximage_display(ndpy);
   const struct native_config **configs;
   int i;

   /* first time */
   if (!xdpy->configs) {
      const XVisualInfo *visuals;
      int num_visuals, count;

      visuals = x11_screen_get_visuals(xdpy->xscr, &num_visuals);
      if (!visuals)
         return NULL;

      /*
       * Create two configs for each visual.
       * One with depth/stencil buffer; one without
       */
      xdpy->configs = CALLOC(num_visuals * 2, sizeof(*xdpy->configs));
      if (!xdpy->configs)
         return NULL;

      count = 0;
      for (i = 0; i < num_visuals; i++) {
         struct ximage_config *xconf = &xdpy->configs[count];

         xconf->visual = &visuals[i];
         xconf->base.color_format = choose_format(xconf->visual);
         if (xconf->base.color_format == PIPE_FORMAT_NONE)
            continue;

         xconf->base.buffer_mask =
            (1 << NATIVE_ATTACHMENT_FRONT_LEFT) |
            (1 << NATIVE_ATTACHMENT_BACK_LEFT);

         xconf->base.window_bit = TRUE;
         xconf->base.pixmap_bit = TRUE;

         xconf->base.native_visual_id = xconf->visual->visualid;
#if defined(__cplusplus) || defined(c_plusplus)
         xconf->base.native_visual_type = xconf->visual->c_class;
#else
         xconf->base.native_visual_type = xconf->visual->class;
#endif

         count++;
      }

      xdpy->num_configs = count;
   }

   configs = MALLOC(xdpy->num_configs * sizeof(*configs));
   if (configs) {
      for (i = 0; i < xdpy->num_configs; i++)
         configs[i] = (const struct native_config *) &xdpy->configs[i];
      if (num_configs)
         *num_configs = xdpy->num_configs;
   }
   return configs;
}

static boolean
ximage_display_get_pixmap_format(struct native_display *ndpy,
                                 EGLNativePixmapType pix,
                                 enum pipe_format *format)
{
   struct ximage_display *xdpy = ximage_display(ndpy);

   *format = get_pixmap_format(&xdpy->base, pix);

   return (*format != PIPE_FORMAT_NONE);
}

static boolean
ximage_display_copy_to_pixmap(struct native_display *ndpy,
                              EGLNativePixmapType pix,
                              struct pipe_resource *src)
{
   /* fast path to avoid unnecessary allocation and resource_copy_region */
   if (src->bind & PIPE_BIND_DISPLAY_TARGET) {
      struct ximage_display *xdpy = ximage_display(ndpy);
      enum pipe_format fmt = get_pixmap_format(&xdpy->base, pix);
      const struct ximage_config *xconf = NULL;
      struct xlib_drawable xdraw;
      int i;

      if (fmt == PIPE_FORMAT_NONE || src->format != fmt)
         return FALSE;

      for (i = 0; i < xdpy->num_configs; i++) {
         if (xdpy->configs[i].base.color_format == fmt) {
            xconf = &xdpy->configs[i];
            break;
         }
      }
      if (!xconf)
         return FALSE;

      memset(&xdraw, 0, sizeof(xdraw));
      xdraw.visual = xconf->visual->visual;
      xdraw.depth = xconf->visual->depth;
      xdraw.drawable = (Drawable) pix;

      xdpy->base.screen->flush_frontbuffer(xdpy->base.screen,
            src, 0, 0, &xdraw, NULL);

      return TRUE;
   }

   return native_display_copy_to_pixmap(ndpy, pix, src);
}

static int
ximage_display_get_param(struct native_display *ndpy,
                         enum native_param_type param)
{
   int val;

   switch (param) {
   case NATIVE_PARAM_USE_NATIVE_BUFFER:
      /* private buffers are allocated */
      val = FALSE;
      break;
   case NATIVE_PARAM_PRESERVE_BUFFER:
   case NATIVE_PARAM_MAX_SWAP_INTERVAL:
   default:
      val = 0;
      break;
   }

   return val;
}

static void
ximage_display_destroy(struct native_display *ndpy)
{
   struct ximage_display *xdpy = ximage_display(ndpy);

   FREE(xdpy->configs);

   ndpy_uninit(ndpy);

   x11_screen_destroy(xdpy->xscr);
   if (xdpy->own_dpy)
      XCloseDisplay(xdpy->dpy);
   FREE(xdpy);
}

static boolean
ximage_display_init_screen(struct native_display *ndpy)
{
   struct ximage_display *xdpy = ximage_display(ndpy);
   struct sw_winsys *winsys;

   winsys = xlib_create_sw_winsys(xdpy->dpy);
   if (!winsys)
      return FALSE;

   xdpy->base.screen =
      xdpy->event_handler->new_sw_screen(&xdpy->base, winsys);
   if (!xdpy->base.screen) {
      if (winsys->destroy)
         winsys->destroy(winsys);
      return FALSE;
   }

   return TRUE;
}

struct native_display *
x11_create_ximage_display(Display *dpy,
                          const struct native_event_handler *event_handler)
{
   struct ximage_display *xdpy;

   xdpy = CALLOC_STRUCT(ximage_display);
   if (!xdpy)
      return NULL;

   xdpy->dpy = dpy;
   if (!xdpy->dpy) {
      xdpy->dpy = XOpenDisplay(NULL);
      if (!xdpy->dpy) {
         FREE(xdpy);
         return NULL;
      }
      xdpy->own_dpy = TRUE;
   }

   xdpy->event_handler = event_handler;

   xdpy->xscr_number = DefaultScreen(xdpy->dpy);
   xdpy->xscr = x11_screen_create(xdpy->dpy, xdpy->xscr_number);
   if (!xdpy->xscr) {
      if (xdpy->own_dpy)
         XCloseDisplay(xdpy->dpy);
      FREE(xdpy);
      return NULL;
   }

   xdpy->base.init_screen = ximage_display_init_screen;
   xdpy->base.destroy = ximage_display_destroy;
   xdpy->base.get_param = ximage_display_get_param;

   xdpy->base.get_configs = ximage_display_get_configs;
   xdpy->base.get_pixmap_format = ximage_display_get_pixmap_format;
   xdpy->base.copy_to_pixmap = ximage_display_copy_to_pixmap;
   xdpy->base.create_window_surface = ximage_display_create_window_surface;
   xdpy->base.create_pixmap_surface = ximage_display_create_pixmap_surface;

   return &xdpy->base;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d32 2
a33 1
#include "state_tracker/xlib_sw_winsys.h"
d480 1
a480 1
            src, 0, 0, &xdraw);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.8
d172 1
a172 3
                       enum native_attachment natt,
                       boolean preserve,
                       uint swap_interval)
d176 1
a176 1
   if (preserve || swap_interval)
d179 1
a179 1
   switch (natt) {
d437 3
a439 3
ximage_display_is_pixmap_supported(struct native_display *ndpy,
                                   EGLNativePixmapType pix,
                                   const struct native_config *nconf)
a441 1
   enum pipe_format fmt = get_pixmap_format(&xdpy->base, pix);
d443 42
a484 1
   return (fmt == nconf->color_format);
d513 1
a513 2
   if (xdpy->configs)
      FREE(xdpy->configs);
d580 2
a581 1
   xdpy->base.is_pixmap_supported = ximage_display_is_pixmap_supported;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a40 5
enum ximage_surface_type {
   XIMAGE_SURFACE_TYPE_WINDOW,
   XIMAGE_SURFACE_TYPE_PIXMAP,
};

d46 1
a46 1
   struct native_event_handler *event_handler;
a57 1
   enum ximage_surface_type type;
a241 1
                              enum ximage_surface_type type,
a253 1
   xsurf->type = type;
d292 1
a292 2
   xsurf = ximage_display_create_surface(ndpy, XIMAGE_SURFACE_TYPE_WINDOW,
         (Drawable) win, nconf);
d296 27
d330 20
a349 2
   xsurf = ximage_display_create_surface(ndpy, XIMAGE_SURFACE_TYPE_PIXMAP,
         (Drawable) pix, nconf);
a422 2
         xconf->base.slow_config = TRUE;

d445 1
a445 18
   enum pipe_format fmt;
   uint depth;

   depth = x11_drawable_get_depth(xdpy->xscr, (Drawable) pix);
   switch (depth) {
   case 32:
      fmt = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   case 24:
      fmt = PIPE_FORMAT_B8G8R8X8_UNORM;
      break;
   case 16:
      fmt = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      fmt = PIPE_FORMAT_NONE;
      break;
   }
d479 1
a479 1
   xdpy->base.screen->destroy(xdpy->base.screen);
d487 21
d510 1
a510 2
                          struct native_event_handler *event_handler,
                          void *user_data)
a512 1
   struct sw_winsys *winsys = NULL;
a528 1
   xdpy->base.user_data = user_data;
d532 6
a537 11
   if (!xdpy->xscr)
      goto fail;

   winsys = xlib_create_sw_winsys(xdpy->dpy);
   if (!winsys)
      goto fail;

   xdpy->base.screen =
      xdpy->event_handler->new_sw_screen(&xdpy->base, winsys);
   if (!xdpy->base.screen)
      goto fail;
d539 1
a548 10

fail:
   if (winsys && winsys->destroy)
      winsys->destroy(winsys);
   if (xdpy->xscr)
      x11_screen_destroy(xdpy->xscr);
   if (xdpy->dpy && xdpy->own_dpy)
      XCloseDisplay(xdpy->dpy);
   FREE(xdpy);
   return NULL;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a25 4
#include <assert.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/shm.h>
a27 1
#include <X11/extensions/XShm.h>
a31 1
#include "util/u_simple_screen.h"
d33 2
a34 1
#include "softpipe/sp_winsys.h"
d37 1
a37 1
#include "sw_winsys.h"
a43 1
   XIMAGE_SURFACE_TYPE_PBUFFER
d51 2
a55 5
   struct native_event_handler *event_handler;

   boolean use_xshm;

   struct pipe_winsys *winsys;
a59 8
struct ximage_buffer {
   XImage *ximage;

   struct pipe_texture *texture;
   XShmSegmentInfo *shm_info;
   boolean xshm_attached;
};

a67 2
   GC gc;

d70 3
a72 3
   int width, height;
   struct ximage_buffer buffers[NUM_NATIVE_ATTACHMENTS];
   uint valid_mask;
a97 86
static void
ximage_surface_free_buffer(struct native_surface *nsurf,
                           enum native_attachment which)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   struct ximage_buffer *xbuf = &xsurf->buffers[which];

   pipe_texture_reference(&xbuf->texture, NULL);

   if (xbuf->shm_info) {
      if (xbuf->xshm_attached)
         XShmDetach(xsurf->xdpy->dpy, xbuf->shm_info);
      if (xbuf->shm_info->shmaddr != (void *) -1)
         shmdt(xbuf->shm_info->shmaddr);
      if (xbuf->shm_info->shmid != -1)
         shmctl(xbuf->shm_info->shmid, IPC_RMID, 0);

      xbuf->shm_info->shmaddr = (void *) -1;
      xbuf->shm_info->shmid = -1;
   }
}

static boolean
ximage_surface_alloc_buffer(struct native_surface *nsurf,
                            enum native_attachment which)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   struct ximage_buffer *xbuf = &xsurf->buffers[which];
   struct pipe_screen *screen = xsurf->xdpy->base.screen;
   struct pipe_texture templ;

   /* free old data */
   if (xbuf->texture)
      ximage_surface_free_buffer(&xsurf->base, which);

   memset(&templ, 0, sizeof(templ));
   templ.target = PIPE_TEXTURE_2D;
   templ.format = xsurf->color_format;
   templ.width0 = xsurf->width;
   templ.height0 = xsurf->height;
   templ.depth0 = 1;
   templ.tex_usage = PIPE_TEXTURE_USAGE_RENDER_TARGET;

   if (xbuf->shm_info) {
      struct pipe_buffer *pbuf;
      unsigned stride, size;
      void *addr = NULL;

      stride = util_format_get_stride(xsurf->color_format, xsurf->width);
      /* alignment should depend on visual? */
      stride = align(stride, 4);
      size = stride * xsurf->height;

      /* create and attach shm object */
      xbuf->shm_info->shmid = shmget(IPC_PRIVATE, size, 0755);
      if (xbuf->shm_info->shmid != -1) {
         xbuf->shm_info->shmaddr =
            shmat(xbuf->shm_info->shmid, NULL, 0);
         if (xbuf->shm_info->shmaddr != (void *) -1) {
            if (XShmAttach(xsurf->xdpy->dpy, xbuf->shm_info)) {
               addr = xbuf->shm_info->shmaddr;
               xbuf->xshm_attached = TRUE;
            }
         }
      }

      if (addr) {
         pbuf = screen->user_buffer_create(screen, addr, size);
         if (pbuf) {
            xbuf->texture =
               screen->texture_blanket(screen, &templ, &stride, pbuf);
            pipe_buffer_reference(&pbuf, NULL);
         }
      }
   }
   else {
      xbuf->texture = screen->texture_create(screen, &templ);
   }

   /* clean up the buffer if allocation failed */
   if (!xbuf->texture)
      ximage_surface_free_buffer(&xsurf->base, which);

   return (xbuf->texture != NULL);
}

d99 1
a99 2
 * Update the geometry of the surface.  Return TRUE if the geometry has changed
 * since last call.
d101 1
a101 1
static boolean
a108 5
   boolean updated = FALSE;

   /* pbuffer has fixed geometry */
   if (xsurf->type == XIMAGE_SURFACE_TYPE_PBUFFER)
      return FALSE;
d112 1
a112 4
   if (ok && (xsurf->width != w || xsurf->height != h)) {
      xsurf->width = w;
      xsurf->height = h;

a113 14
      updated = TRUE;
   }

   return updated;
}

static void
ximage_surface_notify_invalid(struct native_surface *nsurf)
{
   struct ximage_surface *xsurf = ximage_surface(nsurf);
   struct ximage_display *xdpy = xsurf->xdpy;

   xdpy->event_handler->invalid_surface(&xdpy->base,
         &xsurf->base, xsurf->server_stamp);
d117 1
a117 2
 * Update the buffers of the surface.  It is a slow function due to the
 * round-trip to the server.
a122 17
   boolean updated;
   uint new_valid;
   int att;

   updated = ximage_surface_update_geometry(&xsurf->base);
   if (updated) {
      /* all buffers become invalid */
      xsurf->valid_mask = 0x0;
   }
   else {
      buffer_mask &= ~xsurf->valid_mask;
      /* all requested buffers are valid */
      if (!buffer_mask) {
         xsurf->client_stamp = xsurf->server_stamp;
         return TRUE;
      }
   }
d124 3
a126 19
   new_valid = 0x0;
   for (att = 0; att < NUM_NATIVE_ATTACHMENTS; att++) {
      if (native_attachment_mask_test(buffer_mask, att)) {
         struct ximage_buffer *xbuf = &xsurf->buffers[att];

         /* reallocate the texture */
         if (!ximage_surface_alloc_buffer(&xsurf->base, att))
            break;

         /* update ximage */
         if (xbuf->ximage) {
            xbuf->ximage->width = xsurf->width;
            xbuf->ximage->height = xsurf->height;
         }

         new_valid |= (1 << att);
         if (buffer_mask == new_valid)
            break;
      }
d129 1
a129 4
   xsurf->valid_mask |= new_valid;
   xsurf->client_stamp = xsurf->server_stamp;

   return (new_valid == buffer_mask);
d132 5
a136 3
static boolean
ximage_surface_draw_buffer(struct native_surface *nsurf,
                           enum native_attachment which)
d139 1
a139 13
   struct ximage_buffer *xbuf = &xsurf->buffers[which];
   struct pipe_screen *screen = xsurf->xdpy->base.screen;
   struct pipe_transfer *transfer;

   if (xsurf->type == XIMAGE_SURFACE_TYPE_PBUFFER)
      return TRUE;

   assert(xsurf->drawable && xbuf->ximage && xbuf->texture);

   transfer = screen->get_tex_transfer(screen, xbuf->texture,
         0, 0, 0, PIPE_TRANSFER_READ, 0, 0, xsurf->width, xsurf->height);
   if (!transfer)
      return FALSE;
d141 3
a143 27
   xbuf->ximage->bytes_per_line = transfer->stride;
   xbuf->ximage->data = screen->transfer_map(screen, transfer);
   if (!xbuf->ximage->data) {
      screen->tex_transfer_destroy(transfer);
      return FALSE;
   }


   if (xbuf->shm_info)
      XShmPutImage(xsurf->xdpy->dpy, xsurf->drawable, xsurf->gc,
            xbuf->ximage, 0, 0, 0, 0, xsurf->width, xsurf->height, False);
   else
      XPutImage(xsurf->xdpy->dpy, xsurf->drawable, xsurf->gc,
            xbuf->ximage, 0, 0, 0, 0, xsurf->width, xsurf->height);

   xbuf->ximage->data = NULL;
   screen->transfer_unmap(screen, transfer);

   /*
    * softpipe allows the pipe transfer to be re-used, but we don't want to
    * rely on that behavior.
    */
   screen->tex_transfer_destroy(transfer);

   XSync(xsurf->xdpy->dpy, FALSE);

   return TRUE;
d152 2
a153 2
   ret = ximage_surface_draw_buffer(&xsurf->base,
         NATIVE_ATTACHMENT_FRONT_LEFT);
d155 1
a155 2
   xsurf->server_stamp++;
   ximage_surface_notify_invalid(&xsurf->base);
a163 1
   struct ximage_buffer *xfront, *xback, xtmp;
d166 18
a183 5
   /* display the back buffer first */
   ret = ximage_surface_draw_buffer(nsurf, NATIVE_ATTACHMENT_BACK_LEFT);
   /* force buffers to be updated in next validation call */
   xsurf->server_stamp++;
   ximage_surface_notify_invalid(&xsurf->base);
d185 2
a186 2
   xfront = &xsurf->buffers[NATIVE_ATTACHMENT_FRONT_LEFT];
   xback = &xsurf->buffers[NATIVE_ATTACHMENT_BACK_LEFT];
d188 11
a198 7
   /* skip swapping so that the front buffer is allocated only when needed */
   if (!xfront->texture)
      return ret;

   xtmp = *xfront;
   *xfront = *xback;
   *xback = xtmp;
d205 1
a205 1
                        unsigned int *seq_num, struct pipe_texture **textures,
d209 1
d211 2
a212 5
   if (xsurf->client_stamp != xsurf->server_stamp ||
       (xsurf->valid_mask & attachment_mask) != attachment_mask) {
      if (!ximage_surface_update_buffers(&xsurf->base, attachment_mask))
         return FALSE;
   }
d217 2
a218 11
   if (textures) {
      int att;
      for (att = 0; att < NUM_NATIVE_ATTACHMENTS; att++) {
         if (native_attachment_mask_test(attachment_mask, att)) {
            struct ximage_buffer *xbuf = &xsurf->buffers[att];

            textures[att] = NULL;
            pipe_texture_reference(&textures[att], xbuf->texture);
         }
      }
   }
d220 1
d222 1
a222 1
      *width = xsurf->width;
d224 1
a224 1
      *height = xsurf->height;
a240 1
   int i;
d242 2
a243 13
   for (i = 0; i < NUM_NATIVE_ATTACHMENTS; i++) {
      struct ximage_buffer *xbuf = &xsurf->buffers[i];
      ximage_surface_free_buffer(&xsurf->base, i);
      /* xbuf->shm_info is owned by xbuf->ximage? */
      if (xbuf->ximage) {
         XDestroyImage(xbuf->ximage);
         xbuf->ximage = NULL;
      }
   }

   if (xsurf->type != XIMAGE_SURFACE_TYPE_PBUFFER)
      XFreeGC(xsurf->xdpy->dpy, xsurf->gc);
   free(xsurf);
a254 1
   int i;
d265 10
a274 9
   if (xsurf->type != XIMAGE_SURFACE_TYPE_PBUFFER) {
      xsurf->drawable = drawable;
      xsurf->visual = *xconf->visual;

      xsurf->gc = XCreateGC(xdpy->dpy, xsurf->drawable, 0, NULL);
      if (!xsurf->gc) {
         free(xsurf);
         return NULL;
      }
d276 8
a283 40
      /* initialize the geometry */
      ximage_surface_update_buffers(&xsurf->base, 0x0);

      for (i = 0; i < NUM_NATIVE_ATTACHMENTS; i++) {
         struct ximage_buffer *xbuf = &xsurf->buffers[i];

         if (xdpy->use_xshm) {
            xbuf->shm_info = calloc(1, sizeof(*xbuf->shm_info));
            if (xbuf->shm_info) {
               /* initialize shm info */
               xbuf->shm_info->shmid = -1;
               xbuf->shm_info->shmaddr = (void *) -1;
               xbuf->shm_info->readOnly = TRUE;

               xbuf->ximage = XShmCreateImage(xsurf->xdpy->dpy,
                     xsurf->visual.visual,
                     xsurf->visual.depth,
                     ZPixmap, NULL,
                     xbuf->shm_info,
                     0, 0);
            }
         }
         else {
            xbuf->ximage = XCreateImage(xsurf->xdpy->dpy,
                  xsurf->visual.visual,
                  xsurf->visual.depth,
                  ZPixmap, 0,   /* format, offset */
                  NULL,         /* data */
                  0, 0,         /* size */
                  8,            /* bitmap_pad */
                  0);           /* bytes_per_line */
         }

         if (!xbuf->ximage) {
            XFreeGC(xdpy->dpy, xsurf->gc);
            free(xsurf);
            return NULL;
         }
      }
   }
d286 1
a286 2
   xsurf->base.swap_buffers = ximage_surface_swap_buffers;
   xsurf->base.flush_frontbuffer = ximage_surface_flush_frontbuffer;
a316 16
static struct native_surface *
ximage_display_create_pbuffer_surface(struct native_display *ndpy,
                                      const struct native_config *nconf,
                                      uint width, uint height)
{
   struct ximage_surface *xsurf;

   xsurf = ximage_display_create_surface(ndpy, XIMAGE_SURFACE_TYPE_PBUFFER,
         (Drawable) None, nconf);
   if (xsurf) {
      xsurf->width = width;
      xsurf->height = height;
   }
   return (xsurf) ? &xsurf->base : NULL;
}

d350 1
a350 1
      int num_visuals, count, j;
d360 1
a360 1
      xdpy->configs = calloc(num_visuals * 2, sizeof(*xdpy->configs));
d366 1
a366 36
         for (j = 0; j < 2; j++) {
            struct ximage_config *xconf = &xdpy->configs[count];
            __GLcontextModes *mode = &xconf->base.mode;

            xconf->visual = &visuals[i];
            xconf->base.color_format = choose_format(xconf->visual);
            if (xconf->base.color_format == PIPE_FORMAT_NONE)
               continue;

            x11_screen_convert_visual(xdpy->xscr, xconf->visual, mode);
            /* support double buffer mode */
            mode->doubleBufferMode = TRUE;

            xconf->base.depth_format = PIPE_FORMAT_NONE;
            xconf->base.stencil_format = PIPE_FORMAT_NONE;
            /* create the second config with depth/stencil buffer */
            if (j == 1) {
               xconf->base.depth_format = PIPE_FORMAT_Z24S8_UNORM;
               xconf->base.stencil_format = PIPE_FORMAT_Z24S8_UNORM;
               mode->depthBits = 24;
               mode->stencilBits = 8;
               mode->haveDepthBuffer = TRUE;
               mode->haveStencilBuffer = TRUE;
            }

            mode->maxPbufferWidth = 4096;
            mode->maxPbufferHeight = 4096;
            mode->maxPbufferPixels = 4096 * 4096;
            mode->drawableType =
               GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT;
            mode->swapMethod = GLX_SWAP_EXCHANGE_OML;

            if (mode->alphaBits)
               mode->bindToTextureRgba = TRUE;
            else
               mode->bindToTextureRgb = TRUE;
d368 22
a389 2
            count++;
         }
d395 1
a395 1
   configs = malloc(xdpy->num_configs * sizeof(*configs));
d444 2
d460 1
a460 1
      free(xdpy->configs);
a462 1
   free(xdpy->winsys);
d467 1
a467 1
   free(xdpy);
d471 1
a471 1
x11_create_ximage_display(EGLNativeDisplayType dpy,
d473 1
a473 1
                          boolean use_xshm)
d476 1
d486 1
a486 1
         free(xdpy);
d492 3
d497 2
a498 6
   if (!xdpy->xscr) {
      free(xdpy);
      return NULL;
   }

   xdpy->event_handler = event_handler;
d500 8
a507 5
   xdpy->use_xshm =
      (use_xshm && x11_screen_support(xdpy->xscr, X11_SCREEN_EXTENSION_XSHM));

   xdpy->winsys = create_sw_winsys();
   xdpy->base.screen = softpipe_create_screen(xdpy->winsys);
a515 1
   xdpy->base.create_pbuffer_surface = ximage_display_create_pbuffer_surface;
d518 10
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
d25 4
d31 1
d36 1
d38 1
a38 2
#include "state_tracker/xlib_sw_winsys.h"
#include "util/u_debug.h"
d41 1
a41 1
#include "common/native_helper.h"
d48 1
d56 3
d61 1
a61 2
   struct x11_screen *xscr;
   int xscr_number;
d63 1
d68 8
d84 2
d88 3
a90 3

   struct resource_surface *rsurf;
   struct xlib_drawable xdraw;
d116 86
d203 2
a204 1
 * Update the geometry of the surface.  This is a slow functions.
d206 1
a206 1
static void
d214 5
d222 4
a225 1
   if (ok && resource_surface_set_size(xsurf->rsurf, w, h))
d227 14
d244 2
a245 1
 * Update the buffers of the surface.
d251 17
d269 19
a287 3
   if (xsurf->client_stamp != xsurf->server_stamp) {
      ximage_surface_update_geometry(&xsurf->base);
      xsurf->client_stamp = xsurf->server_stamp;
d290 4
a293 1
   return resource_surface_add_resources(xsurf->rsurf, buffer_mask);
d296 3
a298 5
/**
 * Emulate an invalidate event.
 */
static void
ximage_surface_invalidate(struct native_surface *nsurf)
d301 39
a339 1
   struct ximage_display *xdpy = xsurf->xdpy;
d341 1
a341 3
   xsurf->server_stamp++;
   xdpy->event_handler->invalid_surface(&xdpy->base,
         &xsurf->base, xsurf->server_stamp);
d350 2
a351 2
   ret = resource_surface_present(xsurf->rsurf,
         NATIVE_ATTACHMENT_FRONT_LEFT, (void *) &xsurf->xdraw);
d353 2
a354 1
   ximage_surface_invalidate(&xsurf->base);
d363 1
d366 5
a370 2
   ret = resource_surface_present(xsurf->rsurf,
         NATIVE_ATTACHMENT_BACK_LEFT, (void *) &xsurf->xdraw);
d372 2
a373 7
   resource_surface_swap_buffers(xsurf->rsurf,
         NATIVE_ATTACHMENT_FRONT_LEFT, NATIVE_ATTACHMENT_BACK_LEFT, TRUE);
   /* the front/back buffers have been swapped */
   ximage_surface_invalidate(&xsurf->base);

   return ret;
}
d375 7
a381 22
static boolean
ximage_surface_present(struct native_surface *nsurf,
                       enum native_attachment natt,
                       boolean preserve,
                       uint swap_interval)
{
   boolean ret;

   if (preserve || swap_interval)
      return FALSE;

   switch (natt) {
   case NATIVE_ATTACHMENT_FRONT_LEFT:
      ret = ximage_surface_flush_frontbuffer(nsurf);
      break;
   case NATIVE_ATTACHMENT_BACK_LEFT:
      ret = ximage_surface_swap_buffers(nsurf);
      break;
   default:
      ret = FALSE;
      break;
   }
d388 1
a388 1
                        unsigned int *seq_num, struct pipe_resource **textures,
a391 1
   uint w, h;
d393 5
a397 2
   if (!ximage_surface_update_buffers(&xsurf->base, attachment_mask))
      return FALSE;
d402 11
a412 2
   if (textures)
      resource_surface_get_resources(xsurf->rsurf, textures, attachment_mask);
a413 1
   resource_surface_get_size(xsurf->rsurf, &w, &h);
d415 1
a415 1
      *width = w;
d417 1
a417 1
      *height = h;
d434 1
d436 13
a448 2
   resource_surface_destroy(xsurf->rsurf);
   FREE(xsurf);
d460 1
d471 49
a519 9
   xsurf->rsurf = resource_surface_create(xdpy->base.screen,
         xsurf->color_format,
         PIPE_BIND_RENDER_TARGET |
         PIPE_BIND_SAMPLER_VIEW |
         PIPE_BIND_DISPLAY_TARGET |
         PIPE_BIND_SCANOUT);
   if (!xsurf->rsurf) {
      FREE(xsurf);
      return NULL;
a521 9
   xsurf->drawable = drawable;
   xsurf->visual = *xconf->visual;
   /* initialize the geometry */
   ximage_surface_update_geometry(&xsurf->base);

   xsurf->xdraw.visual = xsurf->visual.visual;
   xsurf->xdraw.depth = xsurf->visual.depth;
   xsurf->xdraw.drawable = xsurf->drawable;

d523 2
a524 1
   xsurf->base.present = ximage_surface_present;
d555 16
d604 1
a604 1
      int num_visuals, count;
d614 1
a614 1
      xdpy->configs = CALLOC(num_visuals * 2, sizeof(*xdpy->configs));
d620 36
a655 1
         struct ximage_config *xconf = &xdpy->configs[count];
d657 2
a658 22
         xconf->visual = &visuals[i];
         xconf->base.color_format = choose_format(xconf->visual);
         if (xconf->base.color_format == PIPE_FORMAT_NONE)
            continue;

         xconf->base.buffer_mask =
            (1 << NATIVE_ATTACHMENT_FRONT_LEFT) |
            (1 << NATIVE_ATTACHMENT_BACK_LEFT);

         xconf->base.window_bit = TRUE;
         xconf->base.pixmap_bit = TRUE;

         xconf->base.native_visual_id = xconf->visual->visualid;
#if defined(__cplusplus) || defined(c_plusplus)
         xconf->base.native_visual_type = xconf->visual->c_class;
#else
         xconf->base.native_visual_type = xconf->visual->class;
#endif

         xconf->base.slow_config = TRUE;

         count++;
d664 1
a664 1
   configs = MALLOC(xdpy->num_configs * sizeof(*configs));
a712 2
   case NATIVE_PARAM_PRESERVE_BUFFER:
   case NATIVE_PARAM_MAX_SWAP_INTERVAL:
d727 1
a727 1
      FREE(xdpy->configs);
d730 1
d735 1
a735 1
   FREE(xdpy);
d739 1
a739 1
x11_create_ximage_display(Display *dpy,
d741 1
a741 1
                          void *user_data)
a743 1
   struct sw_winsys *winsys = NULL;
d753 1
a753 1
         FREE(xdpy);
d759 7
a766 1
   xdpy->base.user_data = user_data;
d768 2
a769 4
   xdpy->xscr_number = DefaultScreen(xdpy->dpy);
   xdpy->xscr = x11_screen_create(xdpy->dpy, xdpy->xscr_number);
   if (!xdpy->xscr)
      goto fail;
d771 2
a772 8
   winsys = xlib_create_sw_winsys(xdpy->dpy);
   if (!winsys)
      goto fail;

   xdpy->base.screen =
      xdpy->event_handler->new_sw_screen(&xdpy->base, winsys);
   if (!xdpy->base.screen)
      goto fail;
d781 1
a783 10

fail:
   if (winsys && winsys->destroy)
      winsys->destroy(winsys);
   if (xdpy->xscr)
      x11_screen_destroy(xdpy->xscr);
   if (xdpy->dpy && xdpy->own_dpy)
      XCloseDisplay(xdpy->dpy);
   FREE(xdpy);
   return NULL;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d41 5
d51 1
a51 1
   const struct native_event_handler *event_handler;
d63 1
d179 3
a181 1
                       const struct native_present_control *ctrl)
d185 1
a185 1
   if (ctrl->preserve || ctrl->swap_interval)
d188 1
a188 1
   switch (ctrl->natt) {
d248 1
d261 1
d300 2
a301 1
   xsurf = ximage_display_create_surface(ndpy, (Drawable) win, nconf);
a304 27
static enum pipe_format
get_pixmap_format(struct native_display *ndpy, EGLNativePixmapType pix)
{
   struct ximage_display *xdpy = ximage_display(ndpy);
   enum pipe_format fmt;
   uint depth;

   depth = x11_drawable_get_depth(xdpy->xscr, (Drawable) pix);

   switch (depth) {
   case 32:
      fmt = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   case 24:
      fmt = PIPE_FORMAT_B8G8R8X8_UNORM;
      break;
   case 16:
      fmt = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      fmt = PIPE_FORMAT_NONE;
      break;
   }

   return fmt;
}

d312 2
a313 20
   /* find the config */
   if (!nconf) {
      struct ximage_display *xdpy = ximage_display(ndpy);
      enum pipe_format fmt = get_pixmap_format(&xdpy->base, pix);
      int i;

      if (fmt != PIPE_FORMAT_NONE) {
         for (i = 0; i < xdpy->num_configs; i++) {
            if (xdpy->configs[i].base.color_format == fmt) {
               nconf = &xdpy->configs[i].base;
               break;
            }
         }
      }

      if (!nconf)
         return NULL;
   }

   xsurf = ximage_display_create_surface(ndpy, (Drawable) pix, nconf);
d387 2
d406 3
a408 3
ximage_display_get_pixmap_format(struct native_display *ndpy,
                                 EGLNativePixmapType pix,
                                 enum pipe_format *format)
d411 2
d414 14
a427 39
   *format = get_pixmap_format(&xdpy->base, pix);

   return (*format != PIPE_FORMAT_NONE);
}

static boolean
ximage_display_copy_to_pixmap(struct native_display *ndpy,
                              EGLNativePixmapType pix,
                              struct pipe_resource *src)
{
   /* fast path to avoid unnecessary allocation and resource_copy_region */
   if (src->bind & PIPE_BIND_DISPLAY_TARGET) {
      struct ximage_display *xdpy = ximage_display(ndpy);
      enum pipe_format fmt = get_pixmap_format(&xdpy->base, pix);
      const struct ximage_config *xconf = NULL;
      struct xlib_drawable xdraw;
      int i;

      if (fmt == PIPE_FORMAT_NONE || src->format != fmt)
         return FALSE;

      for (i = 0; i < xdpy->num_configs; i++) {
         if (xdpy->configs[i].base.color_format == fmt) {
            xconf = &xdpy->configs[i];
            break;
         }
      }
      if (!xconf)
         return FALSE;

      memset(&xdraw, 0, sizeof(xdraw));
      xdraw.visual = xconf->visual->visual;
      xdraw.depth = xconf->visual->depth;
      xdraw.drawable = (Drawable) pix;

      xdpy->base.screen->flush_frontbuffer(xdpy->base.screen,
            src, 0, 0, &xdraw);

      return TRUE;
d430 1
a430 1
   return native_display_copy_to_pixmap(ndpy, pix, src);
d459 2
a460 1
   FREE(xdpy->configs);
d462 1
a462 1
   ndpy_uninit(ndpy);
a469 21
static boolean
ximage_display_init_screen(struct native_display *ndpy)
{
   struct ximage_display *xdpy = ximage_display(ndpy);
   struct sw_winsys *winsys;

   winsys = xlib_create_sw_winsys(xdpy->dpy);
   if (!winsys)
      return FALSE;

   xdpy->base.screen =
      xdpy->event_handler->new_sw_screen(&xdpy->base, winsys);
   if (!xdpy->base.screen) {
      if (winsys->destroy)
         winsys->destroy(winsys);
      return FALSE;
   }

   return TRUE;
}

d472 2
a473 1
                          const struct native_event_handler *event_handler)
d476 1
d493 1
d497 11
a507 6
   if (!xdpy->xscr) {
      if (xdpy->own_dpy)
         XCloseDisplay(xdpy->dpy);
      FREE(xdpy);
      return NULL;
   }
a508 1
   xdpy->base.init_screen = ximage_display_init_screen;
d513 1
a513 2
   xdpy->base.get_pixmap_format = ximage_display_get_pixmap_format;
   xdpy->base.copy_to_pixmap = ximage_display_copy_to_pixmap;
d518 10
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d32 1
a32 2
#include "state_tracker/xlibsw_api.h"
#include "sw/xlib/xlib_sw_winsys.h"
d479 1
a479 1
            src, 0, 0, &xdraw, NULL);
@


