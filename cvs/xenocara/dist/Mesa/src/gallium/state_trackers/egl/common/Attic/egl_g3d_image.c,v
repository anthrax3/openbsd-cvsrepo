head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.36;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.45;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.15;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.18;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2010 LunarG Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#include "pipe/p_screen.h"
#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_rect.h"
#include "util/u_inlines.h"
#include "eglcurrent.h"
#include "egllog.h"

#include "native.h"
#include "egl_g3d.h"
#include "egl_g3d_image.h"

/**
 * Reference and return the front left buffer of the native pixmap.
 */
static struct pipe_resource *
egl_g3d_reference_native_pixmap(_EGLDisplay *dpy, EGLNativePixmapType pix)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct native_surface *nsurf;
   struct pipe_resource *textures[NUM_NATIVE_ATTACHMENTS];
   enum native_attachment natt;

   nsurf = gdpy->native->create_pixmap_surface(gdpy->native, pix, NULL);
   if (!nsurf)
      return NULL;

   natt = NATIVE_ATTACHMENT_FRONT_LEFT;
   if (!nsurf->validate(nsurf, 1 << natt, NULL, textures, NULL, NULL))
      textures[natt] = NULL;

   nsurf->destroy(nsurf);

   return textures[natt];
}

#ifdef EGL_MESA_drm_image

static struct pipe_resource *
egl_g3d_create_drm_buffer(_EGLDisplay *dpy, _EGLImage *img,
                          const EGLint *attribs)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct pipe_screen *screen = gdpy->native->screen;
   struct pipe_resource templ;
   _EGLImageAttribs attrs;
   EGLint format, valid_use;

   if (_eglParseImageAttribList(&attrs, dpy, attribs) != EGL_SUCCESS)
      return NULL;

   if (attrs.Width <= 0 || attrs.Height <= 0) {
      _eglLog(_EGL_DEBUG, "bad width or height (%dx%d)",
            attrs.Width, attrs.Height);
      return NULL;
   }

   switch (attrs.DRMBufferFormatMESA) {
   case EGL_DRM_BUFFER_FORMAT_ARGB32_MESA:
      format = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   default:
      _eglLog(_EGL_DEBUG, "bad image format value 0x%04x",
            attrs.DRMBufferFormatMESA);
      return NULL;
      break;
   }

   valid_use = EGL_DRM_BUFFER_USE_SCANOUT_MESA |
               EGL_DRM_BUFFER_USE_SHARE_MESA |
               EGL_DRM_BUFFER_USE_CURSOR_MESA;
   if (attrs.DRMBufferUseMESA & ~valid_use) {
      _eglLog(_EGL_DEBUG, "bad image use bit 0x%04x",
            attrs.DRMBufferUseMESA);
      return NULL;
   }

   memset(&templ, 0, sizeof(templ));
   templ.target = PIPE_TEXTURE_2D;
   templ.format = format;
   templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
   templ.width0 = attrs.Width;
   templ.height0 = attrs.Height;
   templ.depth0 = 1;
   templ.array_size = 1;

   /*
    * XXX fix apps (e.g. wayland) and pipe drivers (e.g. i915) and remove the
    * size check
    */
   if ((attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_SCANOUT_MESA) &&
       attrs.Width >= 640 && attrs.Height >= 480)
      templ.bind |= PIPE_BIND_SCANOUT;
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_SHARE_MESA)
      templ.bind |= PIPE_BIND_SHARED;
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_CURSOR_MESA) {
      if (attrs.Width != 64 || attrs.Height != 64)
         return NULL;
      templ.bind |= PIPE_BIND_CURSOR;
   }

   return screen->resource_create(screen, &templ);
}

static struct pipe_resource *
egl_g3d_reference_drm_buffer(_EGLDisplay *dpy, EGLint name,
                             _EGLImage *img, const EGLint *attribs)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   _EGLImageAttribs attrs;
   EGLint format;
   struct native_buffer nbuf;

   if (!dpy->Extensions.MESA_drm_image)
      return NULL;

   if (_eglParseImageAttribList(&attrs, dpy, attribs) != EGL_SUCCESS)
      return NULL;

   if (attrs.Width <= 0 || attrs.Height <= 0 ||
       attrs.DRMBufferStrideMESA <= 0) {
      _eglLog(_EGL_DEBUG, "bad width, height, or stride (%dx%dx%d)",
            attrs.Width, attrs.Height, attrs.DRMBufferStrideMESA);
      return NULL;
   }

   switch (attrs.DRMBufferFormatMESA) {
   case EGL_DRM_BUFFER_FORMAT_ARGB32_MESA:
      format = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   default:
      _eglLog(_EGL_DEBUG, "bad image format value 0x%04x",
            attrs.DRMBufferFormatMESA);
      return NULL;
      break;
   }

   memset(&nbuf, 0, sizeof(nbuf));
   nbuf.type = NATIVE_BUFFER_DRM;
   nbuf.u.drm.templ.target = PIPE_TEXTURE_2D;
   nbuf.u.drm.templ.format = format;
   nbuf.u.drm.templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
   nbuf.u.drm.templ.width0 = attrs.Width;
   nbuf.u.drm.templ.height0 = attrs.Height;
   nbuf.u.drm.templ.depth0 = 1;
   nbuf.u.drm.templ.array_size = 1;

   nbuf.u.drm.name = name;
   nbuf.u.drm.stride =
      attrs.DRMBufferStrideMESA * util_format_get_blocksize(format);

   return gdpy->native->buffer->import_buffer(gdpy->native, &nbuf);
}

#endif /* EGL_MESA_drm_image */

#ifdef EGL_WL_bind_wayland_display

static struct pipe_resource *
egl_g3d_reference_wl_buffer(_EGLDisplay *dpy, struct wl_resource *buffer,
                            _EGLImage *img, const EGLint *attribs)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct pipe_resource *resource = NULL, *tmp = NULL;

   if (!gdpy->native->wayland_bufmgr)
      return NULL;

   tmp = gdpy->native->wayland_bufmgr->buffer_get_resource(gdpy->native, buffer);

   pipe_resource_reference(&resource, tmp);

   return resource;
}

#endif /* EGL_WL_bind_wayland_display */

#ifdef EGL_ANDROID_image_native_buffer

static struct pipe_resource *
egl_g3d_reference_android_native_buffer(_EGLDisplay *dpy,
                                        struct ANativeWindowBuffer *buf)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct native_buffer nbuf;

   memset(&nbuf, 0, sizeof(nbuf));
   nbuf.type = NATIVE_BUFFER_ANDROID;
   nbuf.u.android = buf;
    
   return gdpy->native->buffer->import_buffer(gdpy->native, &nbuf);
}

#endif /* EGL_ANDROID_image_native_buffer */

_EGLImage *
egl_g3d_create_image(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *ctx,
                     EGLenum target, EGLClientBuffer buffer,
                     const EGLint *attribs)
{
   struct pipe_resource *ptex;
   struct egl_g3d_image *gimg;
   unsigned level = 0, layer = 0;

   gimg = CALLOC_STRUCT(egl_g3d_image);
   if (!gimg) {
      _eglError(EGL_BAD_ALLOC, "eglCreateEGLImageKHR");
      return NULL;
   }

   if (!_eglInitImage(&gimg->base, dpy)) {
      FREE(gimg);
      return NULL;
   }

   switch (target) {
   case EGL_NATIVE_PIXMAP_KHR:
      ptex = egl_g3d_reference_native_pixmap(dpy,
            (EGLNativePixmapType) buffer);
      break;
#ifdef EGL_MESA_drm_image
   case EGL_DRM_BUFFER_MESA:
      ptex = egl_g3d_reference_drm_buffer(dpy,
            (EGLint) pointer_to_intptr(buffer), &gimg->base, attribs);
      break;
#endif
#ifdef EGL_WL_bind_wayland_display
   case EGL_WAYLAND_BUFFER_WL:
      ptex = egl_g3d_reference_wl_buffer(dpy,
            (struct wl_resource *) buffer, &gimg->base, attribs);
      break;
#endif
#ifdef EGL_ANDROID_image_native_buffer
   case EGL_NATIVE_BUFFER_ANDROID:
      ptex = egl_g3d_reference_android_native_buffer(dpy,
            (struct ANativeWindowBuffer *) buffer);
      break;
#endif
   default:
      ptex = NULL;
      break;
   }

   if (!ptex) {
      FREE(gimg);
      return NULL;
   }

   if (level > ptex->last_level) {
      _eglError(EGL_BAD_MATCH, "eglCreateEGLImageKHR");
      pipe_resource_reference(&gimg->texture, NULL);
      FREE(gimg);
      return NULL;
   }
   if (layer >= (u_minify(ptex->depth0, level) + ptex->array_size - 1)) {
      _eglError(EGL_BAD_PARAMETER, "eglCreateEGLImageKHR");
      pipe_resource_reference(&gimg->texture, NULL);
      FREE(gimg);
      return NULL;
   }

   /* transfer the ownership to the image */
   gimg->texture = ptex;
   gimg->level = level;
   gimg->layer = layer;

   return &gimg->base;
}

EGLBoolean
egl_g3d_destroy_image(_EGLDriver *drv, _EGLDisplay *dpy, _EGLImage *img)
{
   struct egl_g3d_image *gimg = egl_g3d_image(img);

   pipe_resource_reference(&gimg->texture, NULL);
   FREE(gimg);

   return EGL_TRUE;
}

_EGLImage *
egl_g3d_create_drm_image(_EGLDriver *drv, _EGLDisplay *dpy,
                         const EGLint *attribs)
{
   struct egl_g3d_image *gimg;
   struct pipe_resource *ptex;

   gimg = CALLOC_STRUCT(egl_g3d_image);
   if (!gimg) {
      _eglError(EGL_BAD_ALLOC, "eglCreateDRMImageKHR");
      return NULL;
   }

   if (!_eglInitImage(&gimg->base, dpy)) {
      FREE(gimg);
      return NULL;
   }

#ifdef EGL_MESA_drm_image
   ptex = egl_g3d_create_drm_buffer(dpy, &gimg->base, attribs);
#else
   ptex = NULL;
#endif
   if (!ptex) {
      FREE(gimg);
      return NULL;
   }

   /* transfer the ownership to the image */
   gimg->texture = ptex;
   gimg->level = 0;
   gimg->layer = 0;

   return &gimg->base;
}

EGLBoolean
egl_g3d_export_drm_image(_EGLDriver *drv, _EGLDisplay *dpy, _EGLImage *img,
			 EGLint *name, EGLint *handle, EGLint *stride)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct egl_g3d_image *gimg = egl_g3d_image(img);
   struct native_buffer nbuf;

   if (!dpy->Extensions.MESA_drm_image)
      return EGL_FALSE;

   memset(&nbuf, 0, sizeof(nbuf));
   nbuf.type = NATIVE_BUFFER_DRM;
   if (name)
      nbuf.u.drm.templ.bind |= PIPE_BIND_SHARED;

   if (!gdpy->native->buffer->export_buffer(gdpy->native,
                                            gimg->texture, &nbuf))
      return EGL_FALSE;

   if (name)
      *name = nbuf.u.drm.name;
   if (handle)
      *handle = nbuf.u.drm.handle;
   if (stride)
      *stride = nbuf.u.drm.stride;

   return EGL_TRUE;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d29 1
d187 1
a187 1
egl_g3d_reference_wl_buffer(_EGLDisplay *dpy, struct wl_buffer *buffer,
d257 1
a257 1
            (struct wl_buffer *) buffer, &gimg->base, attribs);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.8
a38 3
/* for struct winsys_handle */
#include "state_tracker/drm_driver.h"

d204 18
d250 1
a250 1
            (EGLint) buffer, &gimg->base, attribs);
d257 6
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a37 1
#include "egl_g3d_api.h"
a49 1
   struct egl_g3d_config *gconf;
d54 1
a54 6
   gconf = egl_g3d_config(egl_g3d_find_pixmap_config(dpy, pix));
   if (!gconf)
      return NULL;

   nsurf = gdpy->native->create_pixmap_surface(gdpy->native,
         pix, gconf->native);
d100 2
a101 1
               EGL_DRM_BUFFER_USE_SHARE_MESA;
d115 1
d126 5
a139 2
   struct pipe_resource templ;
   struct winsys_handle wsh;
d142 1
d144 1
a144 1
   if (dpy->Platform != _EGL_PLATFORM_DRM)
d168 32
a199 8
   memset(&templ, 0, sizeof(templ));
   templ.target = PIPE_TEXTURE_2D;
   templ.format = format;
   templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
   templ.width0 = attrs.Width;
   templ.height0 = attrs.Height;
   templ.depth0 = 1;
   templ.array_size = 1;
d201 1
a201 4
   memset(&wsh, 0, sizeof(wsh));
   wsh.handle = (unsigned) name;
   wsh.stride =
      attrs.DRMBufferStrideMESA * util_format_get_blocksize(templ.format);
d203 1
a203 1
   return gdpy->native->buffer->import_buffer(gdpy->native, &templ, &wsh);
d206 1
a206 1
#endif /* EGL_MESA_drm_image */
d239 6
d329 1
a329 1
   struct winsys_handle wsh;
d331 1
a331 1
   if (dpy->Platform != _EGL_PLATFORM_DRM)
d334 15
a348 24
   /* get shared handle */
   if (name) {
      memset(&handle, 0, sizeof(handle));
      wsh.type = DRM_API_HANDLE_TYPE_SHARED;
      if (!gdpy->native->buffer->export_buffer(gdpy->native,
                                               gimg->texture, &wsh))
         return EGL_FALSE;

      *name = wsh.handle;
   }

   /* get KMS handle */
   if (handle || stride) {
      memset(&wsh, 0, sizeof(wsh));
      wsh.type = DRM_API_HANDLE_TYPE_KMS;
      if (!gdpy->native->buffer->export_buffer(gdpy->native,
                                               gimg->texture, &wsh))
         return EGL_FALSE;

      if (handle)
         *handle = wsh.handle;
      if (stride)
         *stride = wsh.stride;
   }
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a28 1
#include <assert.h>
d38 1
d41 3
d47 1
a47 1
static struct pipe_texture *
d53 1
a53 1
   struct pipe_texture *textures[NUM_NATIVE_ATTACHMENTS];
d74 114
d193 1
a193 1
   struct pipe_texture *ptex;
d195 1
a195 1
   unsigned face = 0, level = 0, zslice = 0;
d199 1
a199 1
      _eglError(EGL_BAD_ALLOC, "eglCreatePbufferSurface");
d203 2
a204 2
   if (!_eglInitImage(&gimg->base, dpy, attribs)) {
      free(gimg);
d213 6
d225 1
a225 1
      free(gimg);
d231 2
a232 2
      pipe_texture_reference(&gimg->texture, NULL);
      free(gimg);
d235 1
a235 1
   if (zslice > ptex->depth0) {
d237 2
a238 2
      pipe_texture_reference(&gimg->texture, NULL);
      free(gimg);
a243 1
   gimg->face = face;
d245 1
a245 1
   gimg->zslice = zslice;
d255 77
a331 2
   pipe_texture_reference(&gimg->texture, NULL);
   free(gimg);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
d28 1
a37 1
#include "egl_g3d_api.h"
a39 3
/* for struct winsys_handle */
#include "state_tracker/drm_driver.h"

d43 1
a43 1
static struct pipe_resource *
d49 1
a49 1
   struct pipe_resource *textures[NUM_NATIVE_ATTACHMENTS];
a69 114
#ifdef EGL_MESA_drm_image

static struct pipe_resource *
egl_g3d_create_drm_buffer(_EGLDisplay *dpy, _EGLImage *img,
                          const EGLint *attribs)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct pipe_screen *screen = gdpy->native->screen;
   struct pipe_resource templ;
   _EGLImageAttribs attrs;
   EGLint format, valid_use;

   if (_eglParseImageAttribList(&attrs, dpy, attribs) != EGL_SUCCESS)
      return NULL;

   if (attrs.Width <= 0 || attrs.Height <= 0) {
      _eglLog(_EGL_DEBUG, "bad width or height (%dx%d)",
            attrs.Width, attrs.Height);
      return NULL;
   }

   switch (attrs.DRMBufferFormatMESA) {
   case EGL_DRM_BUFFER_FORMAT_ARGB32_MESA:
      format = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   default:
      _eglLog(_EGL_DEBUG, "bad image format value 0x%04x",
            attrs.DRMBufferFormatMESA);
      return NULL;
      break;
   }

   valid_use = EGL_DRM_BUFFER_USE_SCANOUT_MESA |
               EGL_DRM_BUFFER_USE_SHARE_MESA;
   if (attrs.DRMBufferUseMESA & ~valid_use) {
      _eglLog(_EGL_DEBUG, "bad image use bit 0x%04x",
            attrs.DRMBufferUseMESA);
      return NULL;
   }

   memset(&templ, 0, sizeof(templ));
   templ.target = PIPE_TEXTURE_2D;
   templ.format = format;
   templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
   templ.width0 = attrs.Width;
   templ.height0 = attrs.Height;
   templ.depth0 = 1;

   /*
    * XXX fix apps (e.g. wayland) and pipe drivers (e.g. i915) and remove the
    * size check
    */
   if ((attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_SCANOUT_MESA) &&
       attrs.Width >= 640 && attrs.Height >= 480)
      templ.bind |= PIPE_BIND_SCANOUT;
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_SHARE_MESA)
      templ.bind |= PIPE_BIND_SHARED;

   return screen->resource_create(screen, &templ);
}

static struct pipe_resource *
egl_g3d_reference_drm_buffer(_EGLDisplay *dpy, EGLint name,
                             _EGLImage *img, const EGLint *attribs)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct pipe_resource templ;
   struct winsys_handle wsh;
   _EGLImageAttribs attrs;
   EGLint format;

   if (dpy->Platform != _EGL_PLATFORM_DRM)
      return NULL;

   if (_eglParseImageAttribList(&attrs, dpy, attribs) != EGL_SUCCESS)
      return NULL;

   if (attrs.Width <= 0 || attrs.Height <= 0 ||
       attrs.DRMBufferStrideMESA <= 0) {
      _eglLog(_EGL_DEBUG, "bad width, height, or stride (%dx%dx%d)",
            attrs.Width, attrs.Height, attrs.DRMBufferStrideMESA);
      return NULL;
   }

   switch (attrs.DRMBufferFormatMESA) {
   case EGL_DRM_BUFFER_FORMAT_ARGB32_MESA:
      format = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   default:
      _eglLog(_EGL_DEBUG, "bad image format value 0x%04x",
            attrs.DRMBufferFormatMESA);
      return NULL;
      break;
   }

   memset(&templ, 0, sizeof(templ));
   templ.target = PIPE_TEXTURE_2D;
   templ.format = format;
   templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
   templ.width0 = attrs.Width;
   templ.height0 = attrs.Height;
   templ.depth0 = 1;
   templ.array_size = 1;

   memset(&wsh, 0, sizeof(wsh));
   wsh.handle = (unsigned) name;
   wsh.stride =
      attrs.DRMBufferStrideMESA * util_format_get_blocksize(templ.format);

   return gdpy->native->buffer->import_buffer(gdpy->native, &templ, &wsh);
}

#endif /* EGL_MESA_drm_image */

d75 1
a75 1
   struct pipe_resource *ptex;
d77 1
a77 1
   unsigned level = 0, layer = 0;
d81 1
a81 1
      _eglError(EGL_BAD_ALLOC, "eglCreateEGLImageKHR");
d85 2
a86 2
   if (!_eglInitImage(&gimg->base, dpy)) {
      FREE(gimg);
a94 6
#ifdef EGL_MESA_drm_image
   case EGL_DRM_BUFFER_MESA:
      ptex = egl_g3d_reference_drm_buffer(dpy,
            (EGLint) buffer, &gimg->base, attribs);
      break;
#endif
d101 1
a101 1
      FREE(gimg);
d107 2
a108 2
      pipe_resource_reference(&gimg->texture, NULL);
      FREE(gimg);
d111 1
a111 1
   if (layer >= (u_minify(ptex->depth0, level) + ptex->array_size - 1)) {
d113 2
a114 2
      pipe_resource_reference(&gimg->texture, NULL);
      FREE(gimg);
d120 1
d122 1
a122 1
   gimg->layer = layer;
d132 2
a133 77
   pipe_resource_reference(&gimg->texture, NULL);
   FREE(gimg);

   return EGL_TRUE;
}

_EGLImage *
egl_g3d_create_drm_image(_EGLDriver *drv, _EGLDisplay *dpy,
                         const EGLint *attribs)
{
   struct egl_g3d_image *gimg;
   struct pipe_resource *ptex;

   gimg = CALLOC_STRUCT(egl_g3d_image);
   if (!gimg) {
      _eglError(EGL_BAD_ALLOC, "eglCreateDRMImageKHR");
      return NULL;
   }

   if (!_eglInitImage(&gimg->base, dpy)) {
      FREE(gimg);
      return NULL;
   }

#ifdef EGL_MESA_drm_image
   ptex = egl_g3d_create_drm_buffer(dpy, &gimg->base, attribs);
#else
   ptex = NULL;
#endif
   if (!ptex) {
      FREE(gimg);
      return NULL;
   }

   /* transfer the ownership to the image */
   gimg->texture = ptex;
   gimg->level = 0;
   gimg->layer = 0;

   return &gimg->base;
}

EGLBoolean
egl_g3d_export_drm_image(_EGLDriver *drv, _EGLDisplay *dpy, _EGLImage *img,
			 EGLint *name, EGLint *handle, EGLint *stride)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct egl_g3d_image *gimg = egl_g3d_image(img);
   struct winsys_handle wsh;

   if (dpy->Platform != _EGL_PLATFORM_DRM)
      return EGL_FALSE;

   /* get shared handle */
   if (name) {
      memset(&handle, 0, sizeof(handle));
      wsh.type = DRM_API_HANDLE_TYPE_SHARED;
      if (!gdpy->native->buffer->export_buffer(gdpy->native,
                                               gimg->texture, &wsh))
         return EGL_FALSE;

      *name = wsh.handle;
   }

   /* get KMS handle */
   if (handle || stride) {
      memset(&wsh, 0, sizeof(wsh));
      wsh.type = DRM_API_HANDLE_TYPE_KMS;
      if (!gdpy->native->buffer->export_buffer(gdpy->native,
                                               gimg->texture, &wsh))
         return EGL_FALSE;

      if (handle)
         *handle = wsh.handle;
      if (stride)
         *stride = wsh.stride;
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d38 1
d41 3
d51 1
d56 6
a61 1
   nsurf = gdpy->native->create_pixmap_surface(gdpy->native, pix, NULL);
d107 1
a107 2
               EGL_DRM_BUFFER_USE_SHARE_MESA |
               EGL_DRM_BUFFER_USE_CURSOR_MESA;
a120 1
   templ.array_size = 1;
a130 5
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_CURSOR_MESA) {
      if (attrs.Width != 64 || attrs.Height != 64)
         return NULL;
      templ.bind |= PIPE_BIND_CURSOR;
   }
d140 2
a143 1
   struct native_buffer nbuf;
d145 1
a145 1
   if (!dpy->Extensions.MESA_drm_image)
d169 13
a181 13
   memset(&nbuf, 0, sizeof(nbuf));
   nbuf.type = NATIVE_BUFFER_DRM;
   nbuf.u.drm.templ.target = PIPE_TEXTURE_2D;
   nbuf.u.drm.templ.format = format;
   nbuf.u.drm.templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
   nbuf.u.drm.templ.width0 = attrs.Width;
   nbuf.u.drm.templ.height0 = attrs.Height;
   nbuf.u.drm.templ.depth0 = 1;
   nbuf.u.drm.templ.array_size = 1;

   nbuf.u.drm.name = name;
   nbuf.u.drm.stride =
      attrs.DRMBufferStrideMESA * util_format_get_blocksize(format);
d183 1
a183 1
   return gdpy->native->buffer->import_buffer(gdpy->native, &nbuf);
a187 39
#ifdef EGL_WL_bind_wayland_display

static struct pipe_resource *
egl_g3d_reference_wl_buffer(_EGLDisplay *dpy, struct wl_buffer *buffer,
                            _EGLImage *img, const EGLint *attribs)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct pipe_resource *resource = NULL, *tmp = NULL;

   if (!gdpy->native->wayland_bufmgr)
      return NULL;

   tmp = gdpy->native->wayland_bufmgr->buffer_get_resource(gdpy->native, buffer);

   pipe_resource_reference(&resource, tmp);

   return resource;
}

#endif /* EGL_WL_bind_wayland_display */

#ifdef EGL_ANDROID_image_native_buffer

static struct pipe_resource *
egl_g3d_reference_android_native_buffer(_EGLDisplay *dpy,
                                        struct ANativeWindowBuffer *buf)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct native_buffer nbuf;

   memset(&nbuf, 0, sizeof(nbuf));
   nbuf.type = NATIVE_BUFFER_ANDROID;
   nbuf.u.android = buf;
    
   return gdpy->native->buffer->import_buffer(gdpy->native, &nbuf);
}

#endif /* EGL_ANDROID_image_native_buffer */

d216 1
a216 13
            (EGLint) pointer_to_intptr(buffer), &gimg->base, attribs);
      break;
#endif
#ifdef EGL_WL_bind_wayland_display
   case EGL_WAYLAND_BUFFER_WL:
      ptex = egl_g3d_reference_wl_buffer(dpy,
            (struct wl_buffer *) buffer, &gimg->base, attribs);
      break;
#endif
#ifdef EGL_ANDROID_image_native_buffer
   case EGL_NATIVE_BUFFER_ANDROID:
      ptex = egl_g3d_reference_android_native_buffer(dpy,
            (struct ANativeWindowBuffer *) buffer);
d303 1
a303 1
   struct native_buffer nbuf;
d305 1
a305 1
   if (!dpy->Extensions.MESA_drm_image)
d308 24
a331 15
   memset(&nbuf, 0, sizeof(nbuf));
   nbuf.type = NATIVE_BUFFER_DRM;
   if (name)
      nbuf.u.drm.templ.bind |= PIPE_BIND_SHARED;

   if (!gdpy->native->buffer->export_buffer(gdpy->native,
                                            gimg->texture, &nbuf))
      return EGL_FALSE;

   if (name)
      *name = nbuf.u.drm.name;
   if (handle)
      *handle = nbuf.u.drm.handle;
   if (stride)
      *stride = nbuf.u.drm.stride;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a28 1
#include "util/u_format.h"
d186 1
a186 1
egl_g3d_reference_wl_buffer(_EGLDisplay *dpy, struct wl_resource *buffer,
d256 1
a256 1
            (struct wl_resource *) buffer, &gimg->base, attribs);
@


