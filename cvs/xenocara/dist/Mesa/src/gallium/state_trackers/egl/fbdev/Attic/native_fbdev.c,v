head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.17;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2013.09.05.14.01.46;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.16;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.09.39;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.46.27;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2010 LunarG Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

/**
 * Considering fbdev as an in-kernel window system,
 *
 *  - opening a device opens a connection
 *  - there is only one window: the framebuffer
 *  - fb_var_screeninfo decides window position, size, and even color format
 *  - there is no pixmap
 *
 * Now EGL is built on top of this window system.  So we should have
 *
 *  - the fd as the handle of the native display
 *  - reject all but one native window: NULL
 *  - no pixmap support
 */

#include <errno.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/fb.h>

#include "pipe/p_screen.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_pointer.h"

#include "common/native.h"
#include "common/native_helper.h"
#include "fbdev/fbdev_sw_winsys.h"

struct fbdev_display {
   struct native_display base;

   int fd;
   const struct native_event_handler *event_handler;

   struct fb_fix_screeninfo finfo;
   struct fb_var_screeninfo config_vinfo;
   struct native_config config;

   boolean assume_fixed_vinfo;
};

struct fbdev_surface {
   struct native_surface base;

   struct fbdev_display *fbdpy;
   struct resource_surface *rsurf;
   int width, height;

   unsigned int sequence_number;

   struct fbdev_sw_drawable drawable;
};

static INLINE struct fbdev_display *
fbdev_display(const struct native_display *ndpy)
{
   return (struct fbdev_display *) ndpy;
}

static INLINE struct fbdev_surface *
fbdev_surface(const struct native_surface *nsurf)
{
   return (struct fbdev_surface *) nsurf;
}

static boolean
fbdev_surface_validate(struct native_surface *nsurf, uint attachment_mask,
                     unsigned int *seq_num, struct pipe_resource **textures,
                     int *width, int *height)
{
   struct fbdev_surface *fbsurf = fbdev_surface(nsurf);

   if (!resource_surface_add_resources(fbsurf->rsurf, attachment_mask))
      return FALSE;
   if (textures)
      resource_surface_get_resources(fbsurf->rsurf, textures, attachment_mask);

   if (seq_num)
      *seq_num = fbsurf->sequence_number;
   if (width)
      *width = fbsurf->width;
   if (height)
      *height = fbsurf->height;

   return TRUE;
}

static enum pipe_format
vinfo_to_format(const struct fb_var_screeninfo *vinfo)
{
   enum pipe_format format = PIPE_FORMAT_NONE;

   /* should also check channel offsets... */
   switch (vinfo->bits_per_pixel) {
   case 32:
      if (vinfo->red.length == 8 &&
          vinfo->green.length == 8 &&
          vinfo->blue.length == 8) {
         format = (vinfo->transp.length == 8) ?
            PIPE_FORMAT_B8G8R8A8_UNORM : PIPE_FORMAT_B8G8R8X8_UNORM;
      }
      break;
   case 16:
      if (vinfo->red.length == 5 &&
          vinfo->green.length == 6 &&
          vinfo->blue.length == 5 &&
          vinfo->transp.length == 0)
         format = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      break;
   }

   return format;
}

static boolean
fbdev_surface_update_drawable(struct native_surface *nsurf,
                              const struct fb_var_screeninfo *vinfo)
{
   struct fbdev_surface *fbsurf = fbdev_surface(nsurf);
   unsigned x, y, width, height;

   x = vinfo->xoffset;
   y = vinfo->yoffset;
   width = MIN2(vinfo->xres, fbsurf->width);
   height = MIN2(vinfo->yres, fbsurf->height);

   /* sanitize the values */
   if (x + width > vinfo->xres_virtual) {
      if (x > vinfo->xres_virtual)
         width = 0;
      else
         width = vinfo->xres_virtual - x;
   }
   if (y + height > vinfo->yres_virtual) {
      if (y > vinfo->yres_virtual)
         height = 0;
      else
         height = vinfo->yres_virtual - y;
   }

   fbsurf->drawable.format = vinfo_to_format(vinfo);
   fbsurf->drawable.x = vinfo->xoffset;
   fbsurf->drawable.y = vinfo->yoffset;
   fbsurf->drawable.width = vinfo->xres;
   fbsurf->drawable.height = vinfo->yres;

   return (fbsurf->drawable.format != PIPE_FORMAT_NONE &&
           fbsurf->drawable.width &&
           fbsurf->drawable.height);
}

static boolean
fbdev_surface_present(struct native_surface *nsurf,
                      const struct native_present_control *ctrl)
{
   struct fbdev_surface *fbsurf = fbdev_surface(nsurf);
   struct fbdev_display *fbdpy = fbsurf->fbdpy;
   boolean ret = FALSE;

   if (ctrl->swap_interval)
      return FALSE;
   if (ctrl->natt != NATIVE_ATTACHMENT_BACK_LEFT)
      return FALSE;

   if (!fbdpy->assume_fixed_vinfo) {
      struct fb_var_screeninfo vinfo;

      memset(&vinfo, 0, sizeof(vinfo));
      if (ioctl(fbdpy->fd, FBIOGET_VSCREENINFO, &vinfo))
         return FALSE;

      /* present the surface */
      if (fbdev_surface_update_drawable(&fbsurf->base, &vinfo)) {
         ret = resource_surface_present(fbsurf->rsurf,
               ctrl->natt, (void *) &fbsurf->drawable);
      }

      fbsurf->width = vinfo.xres;
      fbsurf->height = vinfo.yres;

      if (resource_surface_set_size(fbsurf->rsurf,
               fbsurf->width, fbsurf->height)) {
         /* surface resized */
         fbsurf->sequence_number++;
         fbdpy->event_handler->invalid_surface(&fbdpy->base,
               &fbsurf->base, fbsurf->sequence_number);
      }
   }
   else {
      /* the drawable never changes */
      ret = resource_surface_present(fbsurf->rsurf,
            ctrl->natt, (void *) &fbsurf->drawable);
   }

   return ret;
}

static void
fbdev_surface_wait(struct native_surface *nsurf)
{
   /* no-op */
}

static void
fbdev_surface_destroy(struct native_surface *nsurf)
{
   struct fbdev_surface *fbsurf = fbdev_surface(nsurf);

   resource_surface_destroy(fbsurf->rsurf);
   FREE(fbsurf);
}

static struct native_surface *
fbdev_display_create_window_surface(struct native_display *ndpy,
                                    EGLNativeWindowType win,
                                    const struct native_config *nconf)
{
   struct fbdev_display *fbdpy = fbdev_display(ndpy);
   struct fbdev_surface *fbsurf;
   struct fb_var_screeninfo vinfo;

   /* there is only one native window: NULL */
   if (win)
      return NULL;

   fbsurf = CALLOC_STRUCT(fbdev_surface);
   if (!fbsurf)
      return NULL;

   fbsurf->fbdpy = fbdpy;

   /* get current vinfo */
   if (fbdpy->assume_fixed_vinfo) {
      vinfo = fbdpy->config_vinfo;
   }
   else {
      memset(&vinfo, 0, sizeof(vinfo));
      if (ioctl(fbdpy->fd, FBIOGET_VSCREENINFO, &vinfo)) {
         FREE(fbsurf);
         return NULL;
      }
   }

   fbsurf->width = vinfo.xres;
   fbsurf->height = vinfo.yres;

   if (!fbdev_surface_update_drawable(&fbsurf->base, &vinfo)) {
      FREE(fbsurf);
      return NULL;
   }

   fbsurf->rsurf = resource_surface_create(fbdpy->base.screen,
         nconf->color_format,
         PIPE_BIND_RENDER_TARGET |
         PIPE_BIND_DISPLAY_TARGET);
   if (!fbsurf->rsurf) {
      FREE(fbsurf);
      return NULL;
   }

   resource_surface_set_size(fbsurf->rsurf, fbsurf->width, fbsurf->height);

   fbsurf->base.destroy = fbdev_surface_destroy;
   fbsurf->base.present = fbdev_surface_present;
   fbsurf->base.validate = fbdev_surface_validate;
   fbsurf->base.wait = fbdev_surface_wait;

   return &fbsurf->base;
}

static struct native_surface *
fbdev_display_create_scanout_surface(struct native_display *ndpy,
                                     const struct native_config *nconf,
                                     uint width, uint height)
{
   return fbdev_display_create_window_surface(ndpy,
         (EGLNativeWindowType) NULL, nconf);
}

static boolean
fbdev_display_program(struct native_display *ndpy, int crtc_idx,
                      struct native_surface *nsurf, uint x, uint y,
                      const struct native_connector **nconns, int num_nconns,
                      const struct native_mode *nmode)
{
   return TRUE;
}

static const struct native_mode **
fbdev_display_get_modes(struct native_display *ndpy,
                        const struct native_connector *nconn,
                        int *num_modes)
{
   static struct native_mode mode;
   const struct native_mode **modes;

   if (!mode.desc) {
      struct fbdev_display *fbdpy = fbdev_display(ndpy);
      mode.desc = "Current Mode";
      mode.width = fbdpy->config_vinfo.xres;
      mode.height = fbdpy->config_vinfo.yres;
      mode.refresh_rate = 60 * 1000; /* dummy */
   }

   modes = MALLOC(sizeof(*modes));
   if (modes) {
      modes[0] = &mode;
      if (num_modes)
         *num_modes = 1;
   }

   return modes;
}

static const struct native_connector **
fbdev_display_get_connectors(struct native_display *ndpy, int *num_connectors,
                           int *num_crtc)
{
   static struct native_connector connector;
   const struct native_connector **connectors;

   connectors = MALLOC(sizeof(*connectors));
   if (connectors) {
      connectors[0] = &connector;
      if (num_connectors)
         *num_connectors = 1;
   }

   return connectors;
}

/* remove modeset support one day! */
static const struct native_display_modeset fbdev_display_modeset = {
   .get_connectors = fbdev_display_get_connectors,
   .get_modes = fbdev_display_get_modes,
   .create_scanout_surface = fbdev_display_create_scanout_surface,
   .program = fbdev_display_program
};

static const struct native_config **
fbdev_display_get_configs(struct native_display *ndpy, int *num_configs)
{
   struct fbdev_display *fbdpy = fbdev_display(ndpy);
   const struct native_config **configs;

   configs = MALLOC(sizeof(*configs));
   if (configs) {
      configs[0] = &fbdpy->config;
      if (num_configs)
         *num_configs = 1;
   }

   return configs;
}

static int
fbdev_display_get_param(struct native_display *ndpy,
                      enum native_param_type param)
{
   int val;

   switch (param) {
   case NATIVE_PARAM_PRESERVE_BUFFER:
      val = 1;
      break;
   case NATIVE_PARAM_USE_NATIVE_BUFFER:
   case NATIVE_PARAM_MAX_SWAP_INTERVAL:
   default:
      val = 0;
      break;
   }

   return val;
}

static void
fbdev_display_destroy(struct native_display *ndpy)
{
   struct fbdev_display *fbdpy = fbdev_display(ndpy);

   ndpy_uninit(&fbdpy->base);
   close(fbdpy->fd);
   FREE(fbdpy);
}

static boolean
fbdev_display_init_screen(struct native_display *ndpy)
{
   struct fbdev_display *fbdpy = fbdev_display(ndpy);
   struct sw_winsys *ws;

   ws = fbdev_create_sw_winsys(fbdpy->fd);
   if (!ws)
      return FALSE;

   fbdpy->base.screen = fbdpy->event_handler->new_sw_screen(&fbdpy->base, ws);
   if (!fbdpy->base.screen) {
      if (ws->destroy)
         ws->destroy(ws);
      return FALSE;
   }

   if (!fbdpy->base.screen->is_format_supported(fbdpy->base.screen,
            fbdpy->config.color_format, PIPE_TEXTURE_2D, 0,
            PIPE_BIND_RENDER_TARGET)) {
      fbdpy->base.screen->destroy(fbdpy->base.screen);
      fbdpy->base.screen = NULL;
      return FALSE;
   }

   return TRUE;
}

static boolean
fbdev_display_init_config(struct native_display *ndpy)
{
   struct fbdev_display *fbdpy = fbdev_display(ndpy);
   struct native_config *nconf = &fbdpy->config;

   if (ioctl(fbdpy->fd, FBIOGET_VSCREENINFO, &fbdpy->config_vinfo))
      return FALSE;

   nconf->color_format = vinfo_to_format(&fbdpy->config_vinfo);
   if (nconf->color_format == PIPE_FORMAT_NONE)
      return FALSE;

   nconf->buffer_mask = (1 << NATIVE_ATTACHMENT_BACK_LEFT);

   nconf->window_bit = TRUE;

   return TRUE;
}

static struct native_display *
fbdev_display_create(int fd, const struct native_event_handler *event_handler)
{
   struct fbdev_display *fbdpy;

   fbdpy = CALLOC_STRUCT(fbdev_display);
   if (!fbdpy)
      return NULL;

   fbdpy->fd = fd;
   fbdpy->event_handler = event_handler;

   if (ioctl(fbdpy->fd, FBIOGET_FSCREENINFO, &fbdpy->finfo))
      goto fail;

   if (fbdpy->finfo.visual != FB_VISUAL_TRUECOLOR ||
       fbdpy->finfo.type != FB_TYPE_PACKED_PIXELS)
      goto fail;

   if (!fbdev_display_init_config(&fbdpy->base))
      goto fail;

   fbdpy->assume_fixed_vinfo = TRUE;

   fbdpy->base.init_screen = fbdev_display_init_screen;
   fbdpy->base.destroy = fbdev_display_destroy;
   fbdpy->base.get_param = fbdev_display_get_param;
   fbdpy->base.get_configs = fbdev_display_get_configs;

   fbdpy->base.create_window_surface = fbdev_display_create_window_surface;

   /* we'd like to remove modeset support one day */
   fbdpy->config.scanout_bit = TRUE;
   fbdpy->base.modeset = &fbdev_display_modeset;

   return &fbdpy->base;

fail:
   FREE(fbdpy);
   return NULL;
}

static const struct native_event_handler *fbdev_event_handler;

static struct native_display *
native_create_display(void *dpy, boolean use_sw)
{
   struct native_display *ndpy;
   int fd;

   /* well, this makes fd 0 being ignored */
   if (!dpy) {
      const char *device_name="/dev/fb0";
#ifdef O_CLOEXEC
      fd = open(device_name, O_RDWR | O_CLOEXEC);
      if (fd == -1 && errno == EINVAL)
#endif
      {
         fd = open(device_name, O_RDWR);
         if (fd != -1)
            fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
      }
   }
   else {
      fd = dup((int) pointer_to_intptr(dpy));
   }
   if (fd < 0)
      return NULL;

   ndpy = fbdev_display_create(fd, fbdev_event_handler);
   if (!ndpy)
      close(fd);

   return ndpy;
}

static const struct native_platform fbdev_platform = {
   "FBDEV", /* name */
   native_create_display
};

const struct native_platform *
native_get_fbdev_platform(const struct native_event_handler *event_handler)
{
   fbdev_event_handler = event_handler;
   return &fbdev_platform;
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d57 1
a57 1
#include "sw/fbdev/fbdev_sw_winsys.h"
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d57 1
a57 1
#include "fbdev/fbdev_sw_winsys.h"
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.9
d43 1
d186 1
a186 3
                      enum native_attachment natt,
                      boolean preserve,
                      uint swap_interval)
d192 1
a192 1
   if (swap_interval)
d194 1
a194 1
   if (natt != NATIVE_ATTACHMENT_BACK_LEFT)
d207 1
a207 1
               natt, (void *) &fbsurf->drawable);
d224 1
a224 1
            natt, (void *) &fbsurf->drawable);
d518 10
a527 1
      fd = open("/dev/fb0", O_RDWR);
@


1.1
log
@Initial revision
@
text
@d29 15
d63 1
a63 1
   struct native_event_handler *event_handler;
d66 1
a66 2
   struct fb_var_screeninfo vinfo;

a67 2
   struct native_connector connector;
   struct native_mode mode;
d69 1
a69 1
   struct fbdev_surface *current_surface;
d81 1
a81 1
   boolean is_current;
d118 2
a119 2
static boolean
fbdev_surface_flush_frontbuffer(struct native_surface *nsurf)
d121 1
a121 1
   struct fbdev_surface *fbsurf = fbdev_surface(nsurf);
d123 20
a142 2
   if (!fbsurf->is_current)
      return TRUE;
d144 1
a144 2
   return resource_surface_present(fbsurf->rsurf,
         NATIVE_ATTACHMENT_FRONT_LEFT, NULL);
d148 2
a149 1
fbdev_surface_swap_buffers(struct native_surface *nsurf)
d152 1
a152 2
   struct fbdev_display *fbdpy = fbsurf->fbdpy;
   boolean ret = TRUE;
d154 28
a181 13
   if (fbsurf->is_current) {
      ret = resource_surface_present(fbsurf->rsurf,
            NATIVE_ATTACHMENT_BACK_LEFT, NULL);
   }

   resource_surface_swap_buffers(fbsurf->rsurf,
         NATIVE_ATTACHMENT_FRONT_LEFT, NATIVE_ATTACHMENT_BACK_LEFT, TRUE);
   /* the front/back textures are swapped */
   fbsurf->sequence_number++;
   fbdpy->event_handler->invalid_surface(&fbdpy->base,
         &fbsurf->base, fbsurf->sequence_number);

   return ret;
d190 3
a192 1
   boolean ret;
d194 3
a196 1
   if (preserve || swap_interval)
d199 28
a226 10
   switch (natt) {
   case NATIVE_ATTACHMENT_FRONT_LEFT:
      ret = fbdev_surface_flush_frontbuffer(nsurf);
      break;
   case NATIVE_ATTACHMENT_BACK_LEFT:
      ret = fbdev_surface_swap_buffers(nsurf);
      break;
   default:
      ret = FALSE;
      break;
d248 3
a250 3
fbdev_display_create_scanout_surface(struct native_display *ndpy,
                                   const struct native_config *nconf,
                                   uint width, uint height)
d254 5
d265 20
a284 2
   fbsurf->width = width;
   fbsurf->height = height;
d289 1
a289 2
         PIPE_BIND_DISPLAY_TARGET |
         PIPE_BIND_SCANOUT);
d305 9
a319 16
   struct fbdev_display *fbdpy = fbdev_display(ndpy);
   struct fbdev_surface *fbsurf = fbdev_surface(nsurf);

   if (x || y)
      return FALSE;

   if (fbdpy->current_surface) {
      if (fbdpy->current_surface == fbsurf)
         return TRUE;
      fbdpy->current_surface->is_current = FALSE;
   }

   if (fbsurf)
      fbsurf->is_current = TRUE;
   fbdpy->current_surface = fbsurf;

d325 2
a326 2
                      const struct native_connector *nconn,
                      int *num_modes)
d328 1
a328 1
   struct fbdev_display *fbdpy = fbdev_display(ndpy);
d331 8
d341 1
a341 1
      modes[0] = &fbdpy->mode;
d353 1
a353 1
   struct fbdev_display *fbdpy = fbdev_display(ndpy);
d358 1
a358 1
      connectors[0] = &fbdpy->connector;
d366 2
a367 1
static struct native_display_modeset fbdev_display_modeset = {
d397 3
a400 1
   case NATIVE_PARAM_PRESERVE_BUFFER:
d415 1
a415 1
   fbdpy->base.screen->destroy(fbdpy->base.screen);
d421 1
a421 1
fbdev_display_init_modes(struct native_display *ndpy)
d424 1
a424 1
   struct native_mode *nmode = &fbdpy->mode;
d426 3
a428 4
   nmode->desc = "Current Mode";
   nmode->width = fbdpy->vinfo.xres;
   nmode->height = fbdpy->vinfo.yres;
   nmode->refresh_rate = 60 * 1000; /* dummy */
d430 5
a434 32
   return TRUE;
}

static boolean
fbdev_display_init_connectors(struct native_display *ndpy)
{
   return TRUE;
}

static enum pipe_format
vinfo_to_format(const struct fb_var_screeninfo *vinfo)
{
   enum pipe_format format = PIPE_FORMAT_NONE;

   switch (vinfo->bits_per_pixel) {
   case 32:
      if (vinfo->red.length == 8 &&
          vinfo->green.length == 8 &&
          vinfo->blue.length == 8) {
         format = (vinfo->transp.length == 8) ?
            PIPE_FORMAT_B8G8R8A8_UNORM : PIPE_FORMAT_B8G8R8X8_UNORM;
      }
      break;
   case 16:
      if (vinfo->red.length == 5 &&
          vinfo->green.length == 6 &&
          vinfo->blue.length == 5 &&
          vinfo->transp.length == 0)
         format = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      break;
d437 5
a441 11
   return format;
}

static boolean
fbdev_display_init_configs(struct native_display *ndpy)
{
   struct fbdev_display *fbdpy = fbdev_display(ndpy);
   struct native_config *nconf = &fbdpy->config;

   nconf->color_format = vinfo_to_format(&fbdpy->vinfo);
   if (nconf->color_format == PIPE_FORMAT_NONE)
d443 1
a443 6

   nconf->buffer_mask =
      (1 << NATIVE_ATTACHMENT_FRONT_LEFT) |
      (1 << NATIVE_ATTACHMENT_BACK_LEFT);

   nconf->scanout_bit = TRUE;
d449 1
a449 1
fbdev_display_init(struct native_display *ndpy)
d452 1
a452 1
   struct sw_winsys *ws;
d454 1
a454 1
   if (ioctl(fbdpy->fd, FBIOGET_FSCREENINFO, &fbdpy->finfo))
d457 2
a458 5
   if (ioctl(fbdpy->fd, FBIOGET_VSCREENINFO, &fbdpy->vinfo))
      return FALSE;

   if (fbdpy->finfo.visual != FB_VISUAL_TRUECOLOR ||
       fbdpy->finfo.type != FB_TYPE_PACKED_PIXELS)
d461 1
a461 4
   if (!fbdev_display_init_configs(&fbdpy->base) ||
       !fbdev_display_init_connectors(&fbdpy->base) ||
       !fbdev_display_init_modes(&fbdpy->base))
      return FALSE;
d463 1
a463 5
   ws = fbdev_create_sw_winsys(fbdpy->fd, fbdpy->config.color_format);
   if (ws) {
      fbdpy->base.screen =
         fbdpy->event_handler->new_sw_screen(&fbdpy->base, ws);
   }
d465 1
a465 10
   if (fbdpy->base.screen) {
      if (!fbdpy->base.screen->is_format_supported(fbdpy->base.screen,
               fbdpy->config.color_format, PIPE_TEXTURE_2D, 0,
               PIPE_BIND_RENDER_TARGET, 0)) {
         fbdpy->base.screen->destroy(fbdpy->base.screen);
         fbdpy->base.screen = NULL;
      }
   }

   return (fbdpy->base.screen != NULL);
d469 1
a469 2
fbdev_display_create(int fd, struct native_event_handler *event_handler,
                     void *user_data)
a478 1
   fbdpy->base.user_data = user_data;
d480 11
a490 4
   if (!fbdev_display_init(&fbdpy->base)) {
      FREE(fbdpy);
      return NULL;
   }
d492 1
d497 4
d504 4
d510 2
d513 1
a513 2
native_create_display(void *dpy, struct native_event_handler *event_handler,
                      void *user_data)
d528 1
a528 1
   ndpy = fbdev_display_create(fd, event_handler, user_data);
d541 1
a541 1
native_get_fbdev_platform(void)
d543 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
a28 16
/**
 * Considering fbdev as an in-kernel window system,
 *
 *  - opening a device opens a connection
 *  - there is only one window: the framebuffer
 *  - fb_var_screeninfo decides window position, size, and even color format
 *  - there is no pixmap
 *
 * Now EGL is built on top of this window system.  So we should have
 *
 *  - the fd as the handle of the native display
 *  - reject all but one native window: NULL
 *  - no pixmap support
 */

#include <errno.h>
d48 1
a48 1
   const struct native_event_handler *event_handler;
d51 2
a52 1
   struct fb_var_screeninfo config_vinfo;
d54 2
d57 1
a57 1
   boolean assume_fixed_vinfo;
d69 1
a69 1
   struct fbdev_sw_drawable drawable;
d106 2
a107 2
static enum pipe_format
vinfo_to_format(const struct fb_var_screeninfo *vinfo)
d109 1
a109 1
   enum pipe_format format = PIPE_FORMAT_NONE;
d111 2
a112 20
   /* should also check channel offsets... */
   switch (vinfo->bits_per_pixel) {
   case 32:
      if (vinfo->red.length == 8 &&
          vinfo->green.length == 8 &&
          vinfo->blue.length == 8) {
         format = (vinfo->transp.length == 8) ?
            PIPE_FORMAT_B8G8R8A8_UNORM : PIPE_FORMAT_B8G8R8X8_UNORM;
      }
      break;
   case 16:
      if (vinfo->red.length == 5 &&
          vinfo->green.length == 6 &&
          vinfo->blue.length == 5 &&
          vinfo->transp.length == 0)
         format = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      break;
   }
d114 2
a115 1
   return format;
d119 1
a119 2
fbdev_surface_update_drawable(struct native_surface *nsurf,
                              const struct fb_var_screeninfo *vinfo)
d122 14
a135 1
   unsigned x, y, width, height;
d137 1
a137 28
   x = vinfo->xoffset;
   y = vinfo->yoffset;
   width = MIN2(vinfo->xres, fbsurf->width);
   height = MIN2(vinfo->yres, fbsurf->height);

   /* sanitize the values */
   if (x + width > vinfo->xres_virtual) {
      if (x > vinfo->xres_virtual)
         width = 0;
      else
         width = vinfo->xres_virtual - x;
   }
   if (y + height > vinfo->yres_virtual) {
      if (y > vinfo->yres_virtual)
         height = 0;
      else
         height = vinfo->yres_virtual - y;
   }

   fbsurf->drawable.format = vinfo_to_format(vinfo);
   fbsurf->drawable.x = vinfo->xoffset;
   fbsurf->drawable.y = vinfo->yoffset;
   fbsurf->drawable.width = vinfo->xres;
   fbsurf->drawable.height = vinfo->yres;

   return (fbsurf->drawable.format != PIPE_FORMAT_NONE &&
           fbsurf->drawable.width &&
           fbsurf->drawable.height);
d142 3
a144 1
                      const struct native_present_control *ctrl)
d146 1
a146 3
   struct fbdev_surface *fbsurf = fbdev_surface(nsurf);
   struct fbdev_display *fbdpy = fbsurf->fbdpy;
   boolean ret = FALSE;
d148 1
a148 3
   if (ctrl->swap_interval)
      return FALSE;
   if (ctrl->natt != NATIVE_ATTACHMENT_BACK_LEFT)
d151 10
a160 28
   if (!fbdpy->assume_fixed_vinfo) {
      struct fb_var_screeninfo vinfo;

      memset(&vinfo, 0, sizeof(vinfo));
      if (ioctl(fbdpy->fd, FBIOGET_VSCREENINFO, &vinfo))
         return FALSE;

      /* present the surface */
      if (fbdev_surface_update_drawable(&fbsurf->base, &vinfo)) {
         ret = resource_surface_present(fbsurf->rsurf,
               ctrl->natt, (void *) &fbsurf->drawable);
      }

      fbsurf->width = vinfo.xres;
      fbsurf->height = vinfo.yres;

      if (resource_surface_set_size(fbsurf->rsurf,
               fbsurf->width, fbsurf->height)) {
         /* surface resized */
         fbsurf->sequence_number++;
         fbdpy->event_handler->invalid_surface(&fbdpy->base,
               &fbsurf->base, fbsurf->sequence_number);
      }
   }
   else {
      /* the drawable never changes */
      ret = resource_surface_present(fbsurf->rsurf,
            ctrl->natt, (void *) &fbsurf->drawable);
d182 3
a184 3
fbdev_display_create_window_surface(struct native_display *ndpy,
                                    EGLNativeWindowType win,
                                    const struct native_config *nconf)
a187 5
   struct fb_var_screeninfo vinfo;

   /* there is only one native window: NULL */
   if (win)
      return NULL;
d194 2
a195 20

   /* get current vinfo */
   if (fbdpy->assume_fixed_vinfo) {
      vinfo = fbdpy->config_vinfo;
   }
   else {
      memset(&vinfo, 0, sizeof(vinfo));
      if (ioctl(fbdpy->fd, FBIOGET_VSCREENINFO, &vinfo)) {
         FREE(fbsurf);
         return NULL;
      }
   }

   fbsurf->width = vinfo.xres;
   fbsurf->height = vinfo.yres;

   if (!fbdev_surface_update_drawable(&fbsurf->base, &vinfo)) {
      FREE(fbsurf);
      return NULL;
   }
d200 2
a201 1
         PIPE_BIND_DISPLAY_TARGET);
a216 9
static struct native_surface *
fbdev_display_create_scanout_surface(struct native_display *ndpy,
                                     const struct native_config *nconf,
                                     uint width, uint height)
{
   return fbdev_display_create_window_surface(ndpy,
         (EGLNativeWindowType) NULL, nconf);
}

d223 16
d244 2
a245 2
                        const struct native_connector *nconn,
                        int *num_modes)
d247 1
a247 1
   static struct native_mode mode;
a249 8
   if (!mode.desc) {
      struct fbdev_display *fbdpy = fbdev_display(ndpy);
      mode.desc = "Current Mode";
      mode.width = fbdpy->config_vinfo.xres;
      mode.height = fbdpy->config_vinfo.yres;
      mode.refresh_rate = 60 * 1000; /* dummy */
   }

d252 1
a252 1
      modes[0] = &mode;
d264 1
a264 1
   static struct native_connector connector;
d269 1
a269 1
      connectors[0] = &connector;
d277 1
a277 2
/* remove modeset support one day! */
static const struct native_display_modeset fbdev_display_modeset = {
d307 1
a308 3
      val = 1;
      break;
   case NATIVE_PARAM_USE_NATIVE_BUFFER:
d323 1
a323 1
   ndpy_uninit(&fbdpy->base);
d329 1
a329 1
fbdev_display_init_screen(struct native_display *ndpy)
d332 15
a346 1
   struct sw_winsys *ws;
d348 4
a351 3
   ws = fbdev_create_sw_winsys(fbdpy->fd);
   if (!ws)
      return FALSE;
d353 18
a370 5
   fbdpy->base.screen = fbdpy->event_handler->new_sw_screen(&fbdpy->base, ws);
   if (!fbdpy->base.screen) {
      if (ws->destroy)
         ws->destroy(ws);
      return FALSE;
d373 11
a383 5
   if (!fbdpy->base.screen->is_format_supported(fbdpy->base.screen,
            fbdpy->config.color_format, PIPE_TEXTURE_2D, 0,
            PIPE_BIND_RENDER_TARGET)) {
      fbdpy->base.screen->destroy(fbdpy->base.screen);
      fbdpy->base.screen = NULL;
d385 6
a390 1
   }
d396 1
a396 1
fbdev_display_init_config(struct native_display *ndpy)
d399 7
a405 1
   struct native_config *nconf = &fbdpy->config;
d407 2
a408 1
   if (ioctl(fbdpy->fd, FBIOGET_VSCREENINFO, &fbdpy->config_vinfo))
d411 3
a413 2
   nconf->color_format = vinfo_to_format(&fbdpy->config_vinfo);
   if (nconf->color_format == PIPE_FORMAT_NONE)
d416 5
a420 1
   nconf->buffer_mask = (1 << NATIVE_ATTACHMENT_BACK_LEFT);
d422 8
a429 1
   nconf->window_bit = TRUE;
d431 1
a431 1
   return TRUE;
d435 2
a436 1
fbdev_display_create(int fd, const struct native_event_handler *event_handler)
d446 1
d448 4
a451 2
   if (ioctl(fbdpy->fd, FBIOGET_FSCREENINFO, &fbdpy->finfo))
      goto fail;
a452 10
   if (fbdpy->finfo.visual != FB_VISUAL_TRUECOLOR ||
       fbdpy->finfo.type != FB_TYPE_PACKED_PIXELS)
      goto fail;

   if (!fbdev_display_init_config(&fbdpy->base))
      goto fail;

   fbdpy->assume_fixed_vinfo = TRUE;

   fbdpy->base.init_screen = fbdev_display_init_screen;
a456 4
   fbdpy->base.create_window_surface = fbdev_display_create_window_surface;

   /* we'd like to remove modeset support one day */
   fbdpy->config.scanout_bit = TRUE;
a459 4

fail:
   FREE(fbdpy);
   return NULL;
a461 2
static const struct native_event_handler *fbdev_event_handler;

d463 2
a464 1
native_create_display(void *dpy, boolean use_sw)
d471 1
a471 10
      const char *device_name="/dev/fb0";
#ifdef O_CLOEXEC
      fd = open(device_name, O_RDWR | O_CLOEXEC);
      if (fd == -1 && errno == EINVAL)
#endif
      {
         fd = open(device_name, O_RDWR);
         if (fd != -1)
            fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
      }
d479 1
a479 1
   ndpy = fbdev_display_create(fd, fbdev_event_handler);
d492 1
a492 1
native_get_fbdev_platform(const struct native_event_handler *event_handler)
a493 1
   fbdev_event_handler = event_handler;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d57 1
a57 1
#include "sw/fbdev/fbdev_sw_winsys.h"
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d57 1
a57 1
#include "fbdev/fbdev_sw_winsys.h"
@


