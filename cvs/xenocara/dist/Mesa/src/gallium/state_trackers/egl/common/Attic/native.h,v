head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.36;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.14.01.45;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.15;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.11.24.05.57.08;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.18;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2009-2010 Chia-I Wu <olv@@0xlab.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef _NATIVE_H_
#define _NATIVE_H_

#include "EGL/egl.h"  /* for EGL native types */

#include "pipe/p_compiler.h"
#include "pipe/p_screen.h"
#include "pipe/p_context.h"
#include "pipe/p_state.h"
#include "state_tracker/sw_winsys.h"

#ifdef __cplusplus
extern "C" {
#endif

#include "native_buffer.h"
#include "native_modeset.h"
#include "native_wayland_bufmgr.h"

/**
 * Only color buffers are listed.  The others are allocated privately through,
 * for example, st_renderbuffer_alloc_storage().
 */
enum native_attachment {
   NATIVE_ATTACHMENT_FRONT_LEFT,
   NATIVE_ATTACHMENT_BACK_LEFT,
   NATIVE_ATTACHMENT_FRONT_RIGHT,
   NATIVE_ATTACHMENT_BACK_RIGHT,

   NUM_NATIVE_ATTACHMENTS
};

enum native_param_type {
   /*
    * Return TRUE if window/pixmap surfaces use the buffers of the native
    * types.
    */
   NATIVE_PARAM_USE_NATIVE_BUFFER,

   /**
    * Return TRUE if native_surface::present can preserve the buffer.
    */
   NATIVE_PARAM_PRESERVE_BUFFER,

   /**
    * Return the maximum supported swap interval.
    */
   NATIVE_PARAM_MAX_SWAP_INTERVAL,

   /**
    * Return TRUE if the display supports premultiplied alpha, regardless of
    * the surface color format.
    *
    * Note that returning TRUE for this parameter will make
    * EGL_VG_ALPHA_FORMAT_PRE_BIT to be set for all EGLConfig's with non-zero
    * EGL_ALPHA_SIZE.  EGL_VG_ALPHA_FORMAT attribute of a surface will affect
    * how the surface is presented.
    */
   NATIVE_PARAM_PREMULTIPLIED_ALPHA,

   /**
    * Return TRUE if native_surface::present supports presenting a partial
    * surface.
    */
   NATIVE_PARAM_PRESENT_REGION
};

/**
 * Control how a surface presentation should happen.
 */
struct native_present_control {
   /**< the attachment to present */
   enum native_attachment natt;

   /**< the contents of the presented attachment should be preserved */
   boolean preserve;

   /**< wait until the given vsyncs has passed since the last presentation */
   uint swap_interval;

   /**< pixels use premultiplied alpha */
   boolean premultiplied_alpha;

   /**< The region to present. y=0=top.
        If num_rects is 0, the whole surface is to be presented */
   int num_rects;
   const int *rects; /* x, y, width, height */
};

struct native_surface {
   /**
    * Available for caller's use.
    */
   void *user_data;

   void (*destroy)(struct native_surface *nsurf);

   /**
    * Present the given buffer to the native engine.
    */
   boolean (*present)(struct native_surface *nsurf,
                      const struct native_present_control *ctrl);

   /**
    * Validate the buffers of the surface.  textures, if not NULL, points to an
    * array of size NUM_NATIVE_ATTACHMENTS and the returned textures are owned
    * by the caller.  A sequence number is also returned.  The caller can use
    * it to check if anything has changed since the last call. Any of the
    * pointers may be NULL and it indicates the caller has no interest in those
    * values.
    *
    * If this function is called multiple times with different attachment
    * masks, those not listed in the latest call might be destroyed.  This
    * behavior might change in the future.
    */
   boolean (*validate)(struct native_surface *nsurf, uint attachment_mask,
                       unsigned int *seq_num, struct pipe_resource **textures,
                       int *width, int *height);

   /**
    * Wait until all native commands affecting the surface has been executed.
    */
   void (*wait)(struct native_surface *nsurf);
};

/**
 * Describe a native display config.
 */
struct native_config {
   /* available buffers and their format */
   uint buffer_mask;
   enum pipe_format color_format;

   /* supported surface types */
   boolean window_bit;
   boolean pixmap_bit;
   boolean scanout_bit;

   int native_visual_id;
   int native_visual_type;
   int level;
   boolean transparent_rgb;
   int transparent_rgb_values[3];
};

/**
 * A pipe winsys abstracts the OS.  A pipe screen abstracts the graphcis
 * hardware.  A native display consists of a pipe winsys, a pipe screen, and
 * the native display server.
 */
struct native_display {
   /**
    * The pipe screen of the native display.
    */
   struct pipe_screen *screen;

   /**
    * Context used for copy operations.
    */
   struct pipe_context *pipe;

   /**
    * Available for caller's use.
    */
   void *user_data;

   /**
    * Initialize and create the pipe screen.
    */
   boolean (*init_screen)(struct native_display *ndpy);

   void (*destroy)(struct native_display *ndpy);

   /**
    * Query the parameters of the native display.
    *
    * The return value is defined by the parameter.
    */
   int (*get_param)(struct native_display *ndpy,
                    enum native_param_type param);

   /**
    * Get the supported configs.  The configs are owned by the display, but
    * the returned array should be FREE()ed.
    */
   const struct native_config **(*get_configs)(struct native_display *ndpy,
                                               int *num_configs);

   /**
    * Get the color format of the pixmap.  Required unless no config has
    * pixmap_bit set.
    */
   boolean (*get_pixmap_format)(struct native_display *ndpy,
                                EGLNativePixmapType pix,
                                enum pipe_format *format);

   /**
    * Copy the contents of the resource to the pixmap's front-left attachment.
    * This is used to implement eglCopyBuffers.  Required unless no config has
    * pixmap_bit set.
    */
   boolean (*copy_to_pixmap)(struct native_display *ndpy,
                             EGLNativePixmapType pix,
                             struct pipe_resource *src);

   /**
    * Create a window surface.  Required unless no config has window_bit set.
    */
   struct native_surface *(*create_window_surface)(struct native_display *ndpy,
                                                   EGLNativeWindowType win,
                                                   const struct native_config *nconf);

   /**
    * Create a pixmap surface.  The native config may be NULL.  In that case, a
    * "best config" will be picked.  Required unless no config has pixmap_bit
    * set.
    */
   struct native_surface *(*create_pixmap_surface)(struct native_display *ndpy,
                                                   EGLNativePixmapType pix,
                                                   const struct native_config *nconf);

   const struct native_display_buffer *buffer;
   const struct native_display_modeset *modeset;
   struct native_display_wayland_bufmgr *wayland_bufmgr;
};

/**
 * The handler for events that a native display may generate.  The events are
 * generated asynchronously and the handler may be called by any thread at any
 * time.
 */
struct native_event_handler {
   /**
    * This function is called when a surface needs to be validated.
    */
   void (*invalid_surface)(struct native_display *ndpy,
                           struct native_surface *nsurf,
                           unsigned int seq_num);

   struct pipe_screen *(*new_drm_screen)(struct native_display *ndpy,
                                         const char *name, int fd);
   struct pipe_screen *(*new_sw_screen)(struct native_display *ndpy,
                                        struct sw_winsys *ws);

   struct pipe_resource *(*lookup_egl_image)(struct native_display *ndpy,
                                             void *egl_image);
};

/**
 * Test whether an attachment is set in the mask.
 */
static INLINE boolean
native_attachment_mask_test(uint mask, enum native_attachment att)
{
   return !!(mask & (1 << att));
}

/**
 * Get the display copy context
 */
static INLINE struct pipe_context *
ndpy_get_copy_context(struct native_display *ndpy)
{
   if (!ndpy->pipe)
      ndpy->pipe = ndpy->screen->context_create(ndpy->screen, NULL);
   return ndpy->pipe;
}

/**
 * Free display screen and context resources
 */
static INLINE void
ndpy_uninit(struct native_display *ndpy)
{
   if (ndpy->pipe)
      ndpy->pipe->destroy(ndpy->pipe);
   if (ndpy->screen)
      ndpy->screen->destroy(ndpy->screen);
}

struct native_platform {
   const char *name;

   /**
    * Create the native display and usually establish a connection to the
    * display server.
    *
    * No event should be generated at this stage.
    */
   struct native_display *(*create_display)(void *dpy, boolean use_sw);
};

const struct native_platform *
native_get_gdi_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_x11_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_wayland_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_drm_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_fbdev_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_null_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_android_platform(const struct native_event_handler *event_handler);

#ifdef __cplusplus
}
#endif

#endif /* _NATIVE_H_ */
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d248 1
a248 5
   const struct native_display_wayland_bufmgr *wayland_bufmgr;

#ifdef HAVE_WAYLAND_BACKEND
   struct wl_drm *wl_server_drm; /* for EGL_WL_bind_wayland_display */
#endif
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d249 4
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.8
d72 40
a111 1
   NATIVE_PARAM_MAX_SWAP_INTERVAL
d126 1
a126 3
                      enum native_attachment natt,
                      boolean preserve,
                      uint swap_interval);
d214 2
a215 5
    * Test if a pixmap is supported by the given config.  Required unless no
    * config has pixmap_bit set.
    *
    * This function is usually called to find a config that supports a given
    * pixmap.  Thus, it is usually called with the same pixmap in a row.
d217 3
a219 3
   boolean (*is_pixmap_supported)(struct native_display *ndpy,
                                  EGLNativePixmapType pix,
                                  const struct native_config *nconf);
d221 8
d331 6
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d43 1
a129 2
   int samples;
   boolean slow_config;
d146 5
d155 5
d197 3
a199 1
    * Create a pixmap surface.  Required unless no config has pixmap_bit set.
d207 1
d227 3
d241 23
d267 7
a273 3
   struct native_display *(*create_display)(void *dpy,
                                            struct native_event_handler *handler,
                                            void *user_data);
d277 4
a280 1
native_get_gdi_platform(void);
d283 1
a283 1
native_get_x11_platform(void);
d286 1
a286 1
native_get_drm_platform(void);
d289 1
a289 1
native_get_fbdev_platform(void);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a29 2
#include "GL/gl.h" /* for GL types needed by __GLcontextModes */
#include "GL/internal/glcore.h"  /* for __GLcontextModes */
d35 1
d37 5
d62 1
a62 2
   NATIVE_PARAM_USE_NATIVE_BUFFER
};
d64 4
a67 9
/**
 * Enumerations for probe results.
 */
enum native_probe_result {
   NATIVE_PROBE_UNKNOWN,
   NATIVE_PROBE_FALLBACK,
   NATIVE_PROBE_SUPPORTED,
   NATIVE_PROBE_EXACT,
};
d69 4
a72 9
/**
 * A probe object for display probe.
 */
struct native_probe {
   int magic;
   EGLNativeDisplayType display;
   void *data;

   void (*destroy)(struct native_probe *nprobe);
d84 1
a84 9
    * Swap the front and back buffers so that the back buffer is visible.  It
    * is no-op if the surface is single-buffered.  The contents of the back
    * buffer after swapping may or may not be preserved.
    */
   boolean (*swap_buffers)(struct native_surface *nsurf);

   /**
    * Make the front buffer visible.  In some native displays, changes to the
    * front buffer might not be visible immediately and require manual flush.
d86 4
a89 1
   boolean (*flush_frontbuffer)(struct native_surface *nsurf);
d104 1
a104 1
                       unsigned int *seq_num, struct pipe_texture **textures,
d113 3
d117 2
a118 2
   /* __GLcontextModes should go away some day */
   __GLcontextModes mode;
a119 2
   enum pipe_format depth_format;
   enum pipe_format stencil_format;
d121 3
a123 1
   /* treat it as an additional flag to mode.drawableType */
d125 8
a142 3
    *
    * Note that the "flush_frontbuffer" and "update_buffer" callbacks will be
    * overridden.
d163 1
a163 5
    * the returned array should be free()ed.
    *
    * The configs will be converted to EGL config by
    * _eglConfigFromContextModesRec and validated by _eglValidateConfig.
    * Those failing to pass the test will be skipped.
d170 1
a170 1
    * config has GLX_PIXMAP_BIT set.
d181 1
a181 2
    * Create a window surface.  Required unless no config has GLX_WINDOW_BIT
    * set.
d188 1
a188 2
    * Create a pixmap surface.  Required unless no config has GLX_PIXMAP_BIT
    * set.
d194 1
a194 8
   /**
    * Create a pbuffer surface.  Required unless no config has GLX_PBUFFER_BIT
    * set.
    */
   struct native_surface *(*create_pbuffer_surface)(struct native_display *ndpy,
                                                    const struct native_config *nconf,
                                                    uint width, uint height);

d210 5
d226 13
a238 9
/**
 * Return a probe object for the given display.
 *
 * Note that the returned object may be cached and used by different native
 * display modules.  It allows fast probing when multiple modules probe the
 * same display.
 */
struct native_probe *
native_create_probe(EGLNativeDisplayType dpy);
d240 2
a241 5
/**
 * Probe the probe object.
 */
enum native_probe_result
native_get_probe_result(struct native_probe *nprobe);
d243 2
a244 2
const char *
native_get_name(void);
d246 3
a248 3
struct native_display *
native_create_display(EGLNativeDisplayType dpy,
                      struct native_event_handler *handler);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
d29 2
a35 1
#include "state_tracker/sw_winsys.h"
a36 5
#ifdef __cplusplus
extern "C" {
#endif

#include "native_buffer.h"
d57 2
a58 1
   NATIVE_PARAM_USE_NATIVE_BUFFER,
d60 17
a76 4
   /**
    * Return TRUE if native_surface::present can preserve the buffer.
    */
   NATIVE_PARAM_PRESERVE_BUFFER,
d78 1
a78 4
   /**
    * Return the maximum supported swap interval.
    */
   NATIVE_PARAM_MAX_SWAP_INTERVAL
d90 9
a98 1
    * Present the given buffer to the native engine.
d100 1
a100 4
   boolean (*present)(struct native_surface *nsurf,
                      enum native_attachment natt,
                      boolean preserve,
                      uint swap_interval);
d115 1
a115 1
                       unsigned int *seq_num, struct pipe_resource **textures,
a123 3
/**
 * Describe a native display config.
 */
d125 2
a126 2
   /* available buffers and their format */
   uint buffer_mask;
d128 2
d131 1
a131 3
   /* supported surface types */
   boolean window_bit;
   boolean pixmap_bit;
a132 8

   int native_visual_id;
   int native_visual_type;
   int level;
   int samples;
   boolean slow_config;
   boolean transparent_rgb;
   int transparent_rgb_values[3];
d143 3
d166 5
a170 1
    * the returned array should be FREE()ed.
d177 1
a177 1
    * config has pixmap_bit set.
d188 2
a189 1
    * Create a window surface.  Required unless no config has window_bit set.
d196 2
a197 1
    * Create a pixmap surface.  Required unless no config has pixmap_bit set.
d203 8
a210 1
   const struct native_display_buffer *buffer;
a225 5

   struct pipe_screen *(*new_drm_screen)(struct native_display *ndpy,
                                         const char *name, int fd);
   struct pipe_screen *(*new_sw_screen)(struct native_display *ndpy,
                                        struct sw_winsys *ws);
d237 9
a245 2
struct native_platform {
   const char *name;
d247 5
a251 4
   struct native_display *(*create_display)(void *dpy,
                                            struct native_event_handler *handler,
                                            void *user_data);
};
d253 2
a254 2
const struct native_platform *
native_get_gdi_platform(void);
d256 3
a258 12
const struct native_platform *
native_get_x11_platform(void);

const struct native_platform *
native_get_drm_platform(void);

const struct native_platform *
native_get_fbdev_platform(void);

#ifdef __cplusplus
}
#endif
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
a42 1
#include "native_wayland_bufmgr.h"
d72 1
a72 40
   NATIVE_PARAM_MAX_SWAP_INTERVAL,

   /**
    * Return TRUE if the display supports premultiplied alpha, regardless of
    * the surface color format.
    *
    * Note that returning TRUE for this parameter will make
    * EGL_VG_ALPHA_FORMAT_PRE_BIT to be set for all EGLConfig's with non-zero
    * EGL_ALPHA_SIZE.  EGL_VG_ALPHA_FORMAT attribute of a surface will affect
    * how the surface is presented.
    */
   NATIVE_PARAM_PREMULTIPLIED_ALPHA,

   /**
    * Return TRUE if native_surface::present supports presenting a partial
    * surface.
    */
   NATIVE_PARAM_PRESENT_REGION
};

/**
 * Control how a surface presentation should happen.
 */
struct native_present_control {
   /**< the attachment to present */
   enum native_attachment natt;

   /**< the contents of the presented attachment should be preserved */
   boolean preserve;

   /**< wait until the given vsyncs has passed since the last presentation */
   uint swap_interval;

   /**< pixels use premultiplied alpha */
   boolean premultiplied_alpha;

   /**< The region to present. y=0=top.
        If num_rects is 0, the whole surface is to be presented */
   int num_rects;
   const int *rects; /* x, y, width, height */
d87 3
a89 1
                      const struct native_present_control *ctrl);
d129 2
a146 5
    * Context used for copy operations.
    */
   struct pipe_context *pipe;

   /**
a150 5
   /**
    * Initialize and create the pipe screen.
    */
   boolean (*init_screen)(struct native_display *ndpy);

d169 5
a173 2
    * Get the color format of the pixmap.  Required unless no config has
    * pixmap_bit set.
d175 3
a177 3
   boolean (*get_pixmap_format)(struct native_display *ndpy,
                                EGLNativePixmapType pix,
                                enum pipe_format *format);
a178 8
   /**
    * Copy the contents of the resource to the pixmap's front-left attachment.
    * This is used to implement eglCopyBuffers.  Required unless no config has
    * pixmap_bit set.
    */
   boolean (*copy_to_pixmap)(struct native_display *ndpy,
                             EGLNativePixmapType pix,
                             struct pipe_resource *src);
d188 1
a188 3
    * Create a pixmap surface.  The native config may be NULL.  In that case, a
    * "best config" will be picked.  Required unless no config has pixmap_bit
    * set.
a195 1
   const struct native_display_wayland_bufmgr *wayland_bufmgr;
a214 3

   struct pipe_resource *(*lookup_egl_image)(struct native_display *ndpy,
                                             void *egl_image);
a225 23
/**
 * Get the display copy context
 */
static INLINE struct pipe_context *
ndpy_get_copy_context(struct native_display *ndpy)
{
   if (!ndpy->pipe)
      ndpy->pipe = ndpy->screen->context_create(ndpy->screen, NULL);
   return ndpy->pipe;
}

/**
 * Free display screen and context resources
 */
static INLINE void
ndpy_uninit(struct native_display *ndpy)
{
   if (ndpy->pipe)
      ndpy->pipe->destroy(ndpy->pipe);
   if (ndpy->screen)
      ndpy->screen->destroy(ndpy->screen);
}

d229 3
a231 7
   /**
    * Create the native display and usually establish a connection to the
    * display server.
    *
    * No event should be generated at this stage.
    */
   struct native_display *(*create_display)(void *dpy, boolean use_sw);
d235 1
a235 10
native_get_gdi_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_x11_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_wayland_platform(const struct native_event_handler *event_handler);

const struct native_platform *
native_get_drm_platform(const struct native_event_handler *event_handler);
d238 1
a238 1
native_get_fbdev_platform(const struct native_event_handler *event_handler);
d241 1
a241 1
native_get_null_platform(const struct native_event_handler *event_handler);
d244 1
a244 1
native_get_android_platform(const struct native_event_handler *event_handler);
@


1.1.1.3
log
@Import Mesa 9.2.3
@
text
@a248 4

#ifdef HAVE_WAYLAND_BACKEND
   struct wl_drm *wl_server_drm; /* for EGL_WL_bind_wayland_display */
#endif
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d248 5
a252 1
   struct native_display_wayland_bufmgr *wayland_bufmgr;
@


