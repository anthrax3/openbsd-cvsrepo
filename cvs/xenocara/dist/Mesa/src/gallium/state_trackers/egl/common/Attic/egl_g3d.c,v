head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.36;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.54;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.17;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2013.09.05.14.01.45;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.14;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.09.37;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.46.25;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2009-2010 Chia-I Wu <olv@@0xlab.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "egldriver.h"
#include "eglcurrent.h"
#include "egllog.h"

#include "pipe/p_screen.h"
#include "util/u_memory.h"
#include "util/u_format.h"
#include "util/u_string.h"
#include "util/u_atomic.h"

#include "egl_g3d.h"
#include "egl_g3d_api.h"
#include "egl_g3d_st.h"
#include "egl_g3d_loader.h"
#include "native.h"

static void
egl_g3d_invalid_surface(struct native_display *ndpy,
                        struct native_surface *nsurf,
                        unsigned int seq_num)
{
   /* XXX not thread safe? */
   struct egl_g3d_surface *gsurf = egl_g3d_surface(nsurf->user_data);

   if (gsurf && gsurf->stfbi)
      p_atomic_inc(&gsurf->stfbi->stamp);
}

static struct pipe_screen *
egl_g3d_new_drm_screen(struct native_display *ndpy, const char *name, int fd)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   return gdpy->loader->create_drm_screen(name, fd);
}

static struct pipe_screen *
egl_g3d_new_sw_screen(struct native_display *ndpy, struct sw_winsys *ws)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   return gdpy->loader->create_sw_screen(ws);
}

static struct pipe_resource *
egl_g3d_lookup_egl_image(struct native_display *ndpy, void *egl_image)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct st_egl_image img;
   struct pipe_resource *resource = NULL;

   memset(&img, 0, sizeof(img));
   if (gdpy->smapi->get_egl_image(gdpy->smapi, egl_image, &img))
      resource = img.texture;

   return resource;
}

static const struct native_event_handler egl_g3d_native_event_handler = {
   egl_g3d_invalid_surface,
   egl_g3d_new_drm_screen,
   egl_g3d_new_sw_screen,
   egl_g3d_lookup_egl_image
};

/**
 * Get the native platform.
 */
static const struct native_platform *
egl_g3d_get_platform(_EGLDriver *drv, _EGLPlatformType plat)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);

   if (!gdrv->platforms[plat]) {
      const char *plat_name = NULL;
      const struct native_platform *nplat = NULL;

      switch (plat) {
      case _EGL_PLATFORM_WINDOWS:
         plat_name = "Windows";
#ifdef HAVE_GDI_BACKEND
         nplat = native_get_gdi_platform(&egl_g3d_native_event_handler);
#endif
         break;
      case _EGL_PLATFORM_X11:
         plat_name = "X11";
#ifdef HAVE_X11_BACKEND
         nplat = native_get_x11_platform(&egl_g3d_native_event_handler);
#endif
	 break;
      case _EGL_PLATFORM_WAYLAND:
         plat_name = "wayland";
#ifdef HAVE_WAYLAND_BACKEND
         nplat = native_get_wayland_platform(&egl_g3d_native_event_handler);
#endif
         break;
      case _EGL_PLATFORM_DRM:
         plat_name = "DRM";
#ifdef HAVE_DRM_BACKEND
         nplat = native_get_drm_platform(&egl_g3d_native_event_handler);
#endif
         break;
      case _EGL_PLATFORM_FBDEV:
         plat_name = "FBDEV";
#ifdef HAVE_FBDEV_BACKEND
         nplat = native_get_fbdev_platform(&egl_g3d_native_event_handler);
#endif
         break;
      case _EGL_PLATFORM_NULL:
         plat_name = "NULL";
#ifdef HAVE_NULL_BACKEND
         nplat = native_get_null_platform(&egl_g3d_native_event_handler);
#endif
         break;
      case _EGL_PLATFORM_ANDROID:
         plat_name = "Android";
#ifdef HAVE_ANDROID_BACKEND
         nplat = native_get_android_platform(&egl_g3d_native_event_handler);
#endif
         break;
      default:
         break;
      }

      if (!nplat)
         _eglLog(_EGL_WARNING, "unsupported platform %s", plat_name);

      gdrv->platforms[plat] = nplat;
   }

   return gdrv->platforms[plat];
}

#ifdef EGL_MESA_screen_surface

static void
egl_g3d_add_screens(_EGLDriver *drv, _EGLDisplay *dpy)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   const struct native_connector **native_connectors;
   EGLint num_connectors, i;

   native_connectors =
      gdpy->native->modeset->get_connectors(gdpy->native, &num_connectors, NULL);
   if (!num_connectors) {
      FREE(native_connectors);
      return;
   }

   for (i = 0; i < num_connectors; i++) {
      const struct native_connector *nconn = native_connectors[i];
      struct egl_g3d_screen *gscr;
      const struct native_mode **native_modes;
      EGLint num_modes, j;

      /* TODO support for hotplug */
      native_modes =
         gdpy->native->modeset->get_modes(gdpy->native, nconn, &num_modes);
      if (!num_modes) {
         FREE(native_modes);
         continue;
      }

      gscr = CALLOC_STRUCT(egl_g3d_screen);
      if (!gscr) {
         FREE(native_modes);
         continue;
      }

      _eglInitScreen(&gscr->base, dpy, num_modes);
      for (j = 0; j < gscr->base.NumModes; j++) {
         const struct native_mode *nmode = native_modes[j];
         _EGLMode *mode = &gscr->base.Modes[j];

         mode->Width = nmode->width;
         mode->Height = nmode->height;
         mode->RefreshRate = nmode->refresh_rate;
         mode->Optimal = EGL_FALSE;
         mode->Interlaced = EGL_FALSE;
         /* no need to strdup() */
         mode->Name = nmode->desc;
      }

      gscr->native = nconn;
      gscr->native_modes = native_modes;

      _eglLinkScreen(&gscr->base);
   }

   FREE(native_connectors);
}

#endif /* EGL_MESA_screen_surface */

/**
 * Initialize and validate the EGL config attributes.
 */
static EGLBoolean
init_config_attributes(_EGLConfig *conf, const struct native_config *nconf,
                       EGLint api_mask, enum pipe_format depth_stencil_format,
                       EGLint preserve_buffer, EGLint max_swap_interval,
                       EGLBoolean pre_alpha)
{
   uint rgba[4], depth_stencil[2], buffer_size;
   EGLint surface_type;
   EGLint i;

   /* get the color and depth/stencil component sizes */
   assert(nconf->color_format != PIPE_FORMAT_NONE);
   buffer_size = 0;
   for (i = 0; i < 4; i++) {
      rgba[i] = util_format_get_component_bits(nconf->color_format,
            UTIL_FORMAT_COLORSPACE_RGB, i);
      buffer_size += rgba[i];
   }
   for (i = 0; i < 2; i++) {
      if (depth_stencil_format != PIPE_FORMAT_NONE) {
         depth_stencil[i] =
            util_format_get_component_bits(depth_stencil_format,
               UTIL_FORMAT_COLORSPACE_ZS, i);
      }
      else {
         depth_stencil[i] = 0;
      }
   }

   surface_type = 0x0;
   /* pixmap surfaces should be EGL_SINGLE_BUFFER */
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_FRONT_LEFT)) {
      if (nconf->pixmap_bit)
         surface_type |= EGL_PIXMAP_BIT;
   }
   /* the others surfaces should be EGL_BACK_BUFFER (or settable) */
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_LEFT)) {
      if (nconf->window_bit)
         surface_type |= EGL_WINDOW_BIT;
#ifdef EGL_MESA_screen_surface
      if (nconf->scanout_bit)
         surface_type |= EGL_SCREEN_BIT_MESA;
#endif
      surface_type |= EGL_PBUFFER_BIT;
   }

   if (preserve_buffer)
      surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT;

   if (pre_alpha && rgba[3]) {
      surface_type |= EGL_VG_ALPHA_FORMAT_PRE_BIT;
      /* st/vega does not support premultiplied alpha yet */
      api_mask &= ~EGL_OPENVG_BIT;
   }

   conf->Conformant = api_mask;
   conf->RenderableType = api_mask;

   conf->RedSize = rgba[0];
   conf->GreenSize = rgba[1];
   conf->BlueSize = rgba[2];
   conf->AlphaSize = rgba[3];
   conf->BufferSize = buffer_size;

   conf->DepthSize = depth_stencil[0];
   conf->StencilSize = depth_stencil[1];

   /* st/vega will allocate the mask on demand */
   if (api_mask & EGL_OPENVG_BIT)
      conf->AlphaMaskSize = 8;

   conf->SurfaceType = surface_type;

   conf->NativeRenderable = EGL_TRUE;
   if (surface_type & EGL_WINDOW_BIT) {
      conf->NativeVisualID = nconf->native_visual_id;
      conf->NativeVisualType = nconf->native_visual_type;
   }

   if (surface_type & EGL_PBUFFER_BIT) {
      conf->BindToTextureRGB = EGL_TRUE;
      if (rgba[3])
         conf->BindToTextureRGBA = EGL_TRUE;

      conf->MaxPbufferWidth = 4096;
      conf->MaxPbufferHeight = 4096;
      conf->MaxPbufferPixels = 4096 * 4096;
   }

   conf->Level = nconf->level;

   if (nconf->transparent_rgb) {
      conf->TransparentType = EGL_TRANSPARENT_RGB;
      conf->TransparentRedValue = nconf->transparent_rgb_values[0];
      conf->TransparentGreenValue = nconf->transparent_rgb_values[1];
      conf->TransparentBlueValue = nconf->transparent_rgb_values[2];
   }

   conf->MinSwapInterval = 0;
   conf->MaxSwapInterval = max_swap_interval;

   return _eglValidateConfig(conf, EGL_FALSE);
}

/**
 * Initialize an EGL config from the native config.
 */
static EGLBoolean
egl_g3d_init_config(_EGLDriver *drv, _EGLDisplay *dpy,
                    _EGLConfig *conf, const struct native_config *nconf,
                    enum pipe_format depth_stencil_format,
                    int preserve_buffer, int max_swap_interval,
                    int pre_alpha)
{
   struct egl_g3d_config *gconf = egl_g3d_config(conf);
   EGLint buffer_mask;
   EGLBoolean valid;

   buffer_mask = 0x0;
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_FRONT_LEFT))
      buffer_mask |= ST_ATTACHMENT_FRONT_LEFT_MASK;
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_LEFT))
      buffer_mask |= ST_ATTACHMENT_BACK_LEFT_MASK;
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_FRONT_RIGHT))
      buffer_mask |= ST_ATTACHMENT_FRONT_RIGHT_MASK;
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_RIGHT))
      buffer_mask |= ST_ATTACHMENT_BACK_RIGHT_MASK;

   gconf->stvis.buffer_mask = buffer_mask;
   gconf->stvis.color_format = nconf->color_format;
   gconf->stvis.depth_stencil_format = depth_stencil_format;
   gconf->stvis.accum_format = PIPE_FORMAT_NONE;
   gconf->stvis.samples = 0;

   /* will be overridden per surface */
   gconf->stvis.render_buffer = (buffer_mask & ST_ATTACHMENT_BACK_LEFT_MASK) ?
      ST_ATTACHMENT_BACK_LEFT : ST_ATTACHMENT_FRONT_LEFT;

   valid = init_config_attributes(&gconf->base,
         nconf, dpy->ClientAPIs, depth_stencil_format,
         preserve_buffer, max_swap_interval, pre_alpha);
   if (!valid) {
      _eglLog(_EGL_DEBUG, "skip invalid config 0x%x", nconf->native_visual_id);
      return EGL_FALSE;
   }

   gconf->native = nconf;

   return EGL_TRUE;
}

/**
 * Get all interested depth/stencil formats of a display.
 */
static EGLint
egl_g3d_fill_depth_stencil_formats(_EGLDisplay *dpy,
                                   enum pipe_format formats[8])
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct pipe_screen *screen = gdpy->native->screen;
   const EGLint candidates[] = {
      1, PIPE_FORMAT_Z16_UNORM,
      1, PIPE_FORMAT_Z32_UNORM,
      2, PIPE_FORMAT_Z24_UNORM_S8_UINT, PIPE_FORMAT_S8_UINT_Z24_UNORM,
      2, PIPE_FORMAT_Z24X8_UNORM, PIPE_FORMAT_X8Z24_UNORM,
      0
   };
   const EGLint *fmt = candidates;
   EGLint count;

   count = 0;
   formats[count++] = PIPE_FORMAT_NONE;

   while (*fmt) {
      EGLint i, n = *fmt++;

      /* pick the first supported format */
      for (i = 0; i < n; i++) {
         if (screen->is_format_supported(screen, fmt[i],
                  PIPE_TEXTURE_2D, 0, PIPE_BIND_DEPTH_STENCIL)) {
            formats[count++] = fmt[i];
            break;
         }
      }

      fmt += n;
   }

   return count;
}

/**
 * Add configs to display and return the next config ID.
 */
static EGLint
egl_g3d_add_configs(_EGLDriver *drv, _EGLDisplay *dpy, EGLint id)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   const struct native_config **native_configs;
   enum pipe_format depth_stencil_formats[8];
   int num_formats, num_configs, i, j;
   int preserve_buffer, max_swap_interval, premultiplied_alpha;

   native_configs = gdpy->native->get_configs(gdpy->native, &num_configs);
   if (!num_configs) {
      FREE(native_configs);
      return id;
   }

   preserve_buffer =
      gdpy->native->get_param(gdpy->native, NATIVE_PARAM_PRESERVE_BUFFER);
   max_swap_interval =
      gdpy->native->get_param(gdpy->native, NATIVE_PARAM_MAX_SWAP_INTERVAL);
   premultiplied_alpha =
      gdpy->native->get_param(gdpy->native, NATIVE_PARAM_PREMULTIPLIED_ALPHA);

   num_formats = egl_g3d_fill_depth_stencil_formats(dpy,
         depth_stencil_formats);

   for (i = 0; i < num_configs; i++) {
      for (j = 0; j < num_formats; j++) {
         struct egl_g3d_config *gconf;

         gconf = CALLOC_STRUCT(egl_g3d_config);
         if (gconf) {
            _eglInitConfig(&gconf->base, dpy, id);
            if (!egl_g3d_init_config(drv, dpy, &gconf->base,
                     native_configs[i], depth_stencil_formats[j],
                     preserve_buffer, max_swap_interval,
                     premultiplied_alpha)) {
               FREE(gconf);
               break;
            }

            _eglLinkConfig(&gconf->base);
            id++;
         }
      }
   }

   FREE(native_configs);
   return id;
}

static void
egl_g3d_free_config(void *conf)
{
   struct egl_g3d_config *gconf = egl_g3d_config((_EGLConfig *) conf);
   FREE(gconf);
}

static void
egl_g3d_free_screen(void *scr)
{
#ifdef EGL_MESA_screen_surface
   struct egl_g3d_screen *gscr = egl_g3d_screen((_EGLScreen *) scr);
   FREE(gscr->native_modes);
   FREE(gscr);
#endif
}

static EGLBoolean
egl_g3d_terminate(_EGLDriver *drv, _EGLDisplay *dpy)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);

   _eglReleaseDisplayResources(drv, dpy);

   if (dpy->Configs) {
      _eglDestroyArray(dpy->Configs, egl_g3d_free_config);
      dpy->Configs = NULL;
   }
   if (dpy->Screens) {
      _eglDestroyArray(dpy->Screens, egl_g3d_free_screen);
      dpy->Screens = NULL;
   }

   _eglCleanupDisplay(dpy);

   if (gdpy->smapi)
      egl_g3d_destroy_st_manager(gdpy->smapi);

   if (gdpy->native)
      gdpy->native->destroy(gdpy->native);

   FREE(gdpy);
   dpy->DriverData = NULL;

   return EGL_TRUE;
}

static EGLBoolean
egl_g3d_initialize(_EGLDriver *drv, _EGLDisplay *dpy)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
   struct egl_g3d_display *gdpy;
   const struct native_platform *nplat;

   nplat = egl_g3d_get_platform(drv, dpy->Platform);
   if (!nplat)
      return EGL_FALSE;

   if (dpy->Options.TestOnly)
      return EGL_TRUE;

   gdpy = CALLOC_STRUCT(egl_g3d_display);
   if (!gdpy) {
      _eglError(EGL_BAD_ALLOC, "eglInitialize");
      goto fail;
   }
   gdpy->loader = gdrv->loader;
   dpy->DriverData = gdpy;

   _eglLog(_EGL_INFO, "use %s for display %p",
         nplat->name, dpy->PlatformDisplay);
   gdpy->native =
      nplat->create_display(dpy->PlatformDisplay, dpy->Options.UseFallback);
   if (!gdpy->native) {
      _eglError(EGL_NOT_INITIALIZED, "eglInitialize(no usable display)");
      goto fail;
   }
   gdpy->native->user_data = (void *) dpy;
   if (!gdpy->native->init_screen(gdpy->native)) {
      _eglError(EGL_NOT_INITIALIZED,
            "eglInitialize(failed to initialize screen)");
      goto fail;
   }

   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_DEFAULT_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_OPENGL_ES1_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_ES_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_OPENGL_ES2_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_ES2_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENVG] & ST_PROFILE_DEFAULT_MASK)
      dpy->ClientAPIs |= EGL_OPENVG_BIT;

   gdpy->smapi = egl_g3d_create_st_manager(dpy);
   if (!gdpy->smapi) {
      _eglError(EGL_NOT_INITIALIZED,
            "eglInitialize(failed to create st manager)");
      goto fail;
   }

#ifdef EGL_MESA_screen_surface
   /* enable MESA_screen_surface before adding (and validating) configs */
   if (gdpy->native->modeset) {
      dpy->Extensions.MESA_screen_surface = EGL_TRUE;
      egl_g3d_add_screens(drv, dpy);
   }
#endif

   dpy->Extensions.KHR_image_base = EGL_TRUE;
   if (gdpy->native->get_param(gdpy->native, NATIVE_PARAM_USE_NATIVE_BUFFER))
      dpy->Extensions.KHR_image_pixmap = EGL_TRUE;

   dpy->Extensions.KHR_reusable_sync = EGL_TRUE;
   dpy->Extensions.KHR_fence_sync = EGL_TRUE;

   dpy->Extensions.KHR_surfaceless_context = EGL_TRUE;

   if (dpy->Platform == _EGL_PLATFORM_DRM) {
      dpy->Extensions.MESA_drm_display = EGL_TRUE;
      if (gdpy->native->buffer)
         dpy->Extensions.MESA_drm_image = EGL_TRUE;
   }

   if (dpy->Platform == _EGL_PLATFORM_WAYLAND && gdpy->native->buffer)
      dpy->Extensions.MESA_drm_image = EGL_TRUE;

#ifdef EGL_ANDROID_image_native_buffer
   if (dpy->Platform == _EGL_PLATFORM_ANDROID && gdpy->native->buffer)
      dpy->Extensions.ANDROID_image_native_buffer = EGL_TRUE;
#endif

#ifdef EGL_WL_bind_wayland_display
   if (gdpy->native->wayland_bufmgr)
      dpy->Extensions.WL_bind_wayland_display = EGL_TRUE;
#endif

   if (gdpy->native->get_param(gdpy->native, NATIVE_PARAM_PRESENT_REGION) &&
       gdpy->native->get_param(gdpy->native, NATIVE_PARAM_PRESERVE_BUFFER)) {
#ifdef EGL_NOK_swap_region
      dpy->Extensions.NOK_swap_region = EGL_TRUE;
#endif
      dpy->Extensions.NV_post_sub_buffer = EGL_TRUE;
   }

   if (egl_g3d_add_configs(drv, dpy, 1) == 1) {
      _eglError(EGL_NOT_INITIALIZED, "eglInitialize(unable to add configs)");
      goto fail;
   }

   dpy->VersionMajor = 1;
   dpy->VersionMinor = 4;

   return EGL_TRUE;

fail:
   if (gdpy)
      egl_g3d_terminate(drv, dpy);
   return EGL_FALSE;
}

static _EGLProc
egl_g3d_get_proc_address(_EGLDriver *drv, const char *procname)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
   struct st_api *stapi = NULL;

   if (procname && procname[0] == 'v' && procname[1] == 'g')
      stapi = gdrv->loader->get_st_api(ST_API_OPENVG);
   else if (procname && procname[0] == 'g' && procname[1] == 'l')
      stapi = gdrv->loader->get_st_api(ST_API_OPENGL);

   return (_EGLProc) ((stapi) ?
         stapi->get_proc_address(stapi, procname) : NULL);
}

_EGLDriver *
egl_g3d_create_driver(const struct egl_g3d_loader *loader)
{
   struct egl_g3d_driver *gdrv;

   gdrv = CALLOC_STRUCT(egl_g3d_driver);
   if (!gdrv)
      return NULL;

   gdrv->loader = loader;

   egl_g3d_init_driver_api(&gdrv->base);
   gdrv->base.API.Initialize = egl_g3d_initialize;
   gdrv->base.API.Terminate = egl_g3d_terminate;
   gdrv->base.API.GetProcAddress = egl_g3d_get_proc_address;

   /* to be filled by the caller */
   gdrv->base.Name = NULL;
   gdrv->base.Unload = NULL;

   return &gdrv->base;
}

void
egl_g3d_destroy_driver(_EGLDriver *drv)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
   FREE(gdrv);
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d551 8
a558 12
#if FEATURE_GL
   dpy->ClientAPIs |= EGL_OPENGL_BIT;
#endif
#if FEATURE_ES1
   dpy->ClientAPIs |= EGL_OPENGL_ES_BIT;
#endif
#if FEATURE_ES2
   dpy->ClientAPIs |= EGL_OPENGL_ES2_BIT;
#endif
#if FEATURE_VG
   dpy->ClientAPIs |= EGL_OPENVG_BIT;
#endif
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d551 12
a562 8
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_DEFAULT_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_OPENGL_ES1_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_ES_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_OPENGL_ES2_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_ES2_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENVG] & ST_PROFILE_DEFAULT_MASK)
      dpy->ClientAPIs |= EGL_OPENVG_BIT;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.8
d33 1
d48 3
a50 9
   struct egl_g3d_context *gctx;
   
   /*
    * Some functions such as egl_g3d_copy_buffers create a temporary native
    * surface.  There is no gsurf associated with it.
    */
   gctx = (gsurf) ? egl_g3d_context(gsurf->base.CurrentContext) : NULL;
   if (gctx)
      gctx->stctxi->notify_invalid_framebuffer(gctx->stctxi, gsurf->stfbi);
d134 12
d171 1
a171 2
      if (native_connectors)
         FREE(native_connectors);
d185 1
a185 2
         if (native_modes)
            FREE(native_modes);
d226 2
a227 1
                       EGLBoolean preserve_buffer, EGLint max_swap_interval)
d269 9
a322 2
   if (preserve_buffer)
      conf->SurfaceType |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT;
d334 2
a335 1
                    int preserve_buffer, int max_swap_interval)
d363 1
a363 1
         preserve_buffer, max_swap_interval);
d386 1
a386 1
      2, PIPE_FORMAT_Z24_UNORM_S8_USCALED, PIPE_FORMAT_S8_USCALED_Z24_UNORM,
d424 1
a424 1
   int preserve_buffer, max_swap_interval;
d428 1
a428 2
      if (native_configs)
         FREE(native_configs);
d436 2
d451 2
a452 1
                     preserve_buffer, max_swap_interval)) {
d582 1
a582 3
   dpy->Extensions.KHR_surfaceless_gles1 = EGL_TRUE;
   dpy->Extensions.KHR_surfaceless_gles2 = EGL_TRUE;
   dpy->Extensions.KHR_surfaceless_opengl = EGL_TRUE;
d593 5
d602 8
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d41 56
d113 1
a113 1
         nplat = native_get_gdi_platform();
d119 7
a125 1
         nplat = native_get_x11_platform();
d131 1
a131 1
         nplat = native_get_drm_platform();
d137 1
a137 1
         nplat = native_get_fbdev_platform();
d248 9
a256 4
   if (nconf->window_bit)
      surface_type |= EGL_WINDOW_BIT;
   if (nconf->pixmap_bit)
      surface_type |= EGL_PIXMAP_BIT;
d258 2
a259 2
   if (nconf->scanout_bit)
      surface_type |= EGL_SCREEN_BIT_MESA;
a260 2

   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_LEFT))
d262 1
d276 4
a298 5
   conf->Samples = nconf->samples;
   conf->SampleBuffers = 0;

   if (nconf->slow_config)
      conf->ConfigCaveat = EGL_SLOW_CONFIG;
d325 1
a325 1
   EGLint buffer_mask, api_mask;
a327 4
   /* skip single-buffered configs */
   if (!(nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_LEFT)))
      return EGL_FALSE;

d342 1
a342 1
   gconf->stvis.samples = nconf->samples;
d344 1
a347 11
   api_mask = dpy->ClientAPIsMask;
   /* this is required by EGL, not by OpenGL ES */
   if (nconf->window_bit &&
       gconf->stvis.render_buffer != ST_ATTACHMENT_BACK_LEFT)
      api_mask &= ~(EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT);

   if (!api_mask) {
      _eglLog(_EGL_DEBUG, "no state tracker supports config 0x%x",
            nconf->native_visual_id);
   }

d349 1
a349 1
         nconf, api_mask, depth_stencil_format,
d389 1
a389 1
                  PIPE_TEXTURE_2D, 0, PIPE_BIND_DEPTH_STENCIL, 0)) {
a452 40
egl_g3d_invalid_surface(struct native_display *ndpy,
                        struct native_surface *nsurf,
                        unsigned int seq_num)
{
   /* XXX not thread safe? */
   struct egl_g3d_surface *gsurf = egl_g3d_surface(nsurf->user_data);
   struct egl_g3d_context *gctx;
   
   /*
    * Some functions such as egl_g3d_copy_buffers create a temporary native
    * surface.  There is no gsurf associated with it.
    */
   gctx = (gsurf) ? egl_g3d_context(gsurf->base.CurrentContext) : NULL;
   if (gctx)
      gctx->stctxi->notify_invalid_framebuffer(gctx->stctxi, gsurf->stfbi);
}

static struct pipe_screen *
egl_g3d_new_drm_screen(struct native_display *ndpy, const char *name, int fd)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   return gdpy->loader->create_drm_screen(name, fd);
}

static struct pipe_screen *
egl_g3d_new_sw_screen(struct native_display *ndpy, struct sw_winsys *ws)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   return gdpy->loader->create_sw_screen(ws);
}

static struct native_event_handler egl_g3d_native_event_handler = {
   egl_g3d_invalid_surface,
   egl_g3d_new_drm_screen,
   egl_g3d_new_sw_screen
};

static void
a475 3
   if (gdpy->pipe)
      gdpy->pipe->destroy(gdpy->pipe);

d500 1
a500 2
egl_g3d_initialize(_EGLDriver *drv, _EGLDisplay *dpy,
                   EGLint *major, EGLint *minor)
d510 3
d521 4
a524 3
   _eglLog(_EGL_INFO, "use %s for display %p", nplat->name, dpy->PlatformDisplay);
   gdpy->native = nplat->create_display(dpy->PlatformDisplay,
         &egl_g3d_native_event_handler, (void *) dpy);
d529 6
d537 1
a537 1
      dpy->ClientAPIsMask |= EGL_OPENGL_BIT;
d539 1
a539 1
      dpy->ClientAPIsMask |= EGL_OPENGL_ES_BIT;
d541 1
a541 1
      dpy->ClientAPIsMask |= EGL_OPENGL_ES2_BIT;
d543 1
a543 1
      dpy->ClientAPIsMask |= EGL_OPENVG_BIT;
d577 8
d590 2
a591 2
   *major = 1;
   *minor = 4;
a615 6
static EGLint
egl_g3d_probe(_EGLDriver *drv, _EGLDisplay *dpy)
{
   return (egl_g3d_get_platform(drv, dpy->Platform)) ? 90 : 0;
}

a630 2

   gdrv->base.Probe = egl_g3d_probe;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a25 7
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include "pipe/p_screen.h"
#include "util/u_memory.h"
#include "util/u_rect.h"
#include "util/u_inlines.h"
a27 1
#include "eglconfigutil.h"
d30 9
a39 3
#include "egl_g3d.h"
#include "egl_g3d_image.h"
#include "egl_st.h"
d42 1
a42 1
 * Validate the draw/read surfaces of the context.
d44 2
a45 2
static void
egl_g3d_validate_context(_EGLDisplay *dpy, _EGLContext *ctx)
d47 1
a47 10
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct pipe_screen *screen = gdpy->native->screen;
   struct egl_g3d_context *gctx = egl_g3d_context(ctx);
   const uint st_att_map[NUM_NATIVE_ATTACHMENTS] = {
      ST_SURFACE_FRONT_LEFT,
      ST_SURFACE_BACK_LEFT,
      ST_SURFACE_FRONT_RIGHT,
      ST_SURFACE_BACK_RIGHT,
   };
   EGLint num_surfaces, s;
d49 31
a79 15
   /* validate draw and/or read buffers */
   num_surfaces = (gctx->base.ReadSurface == gctx->base.DrawSurface) ? 1 : 2;
   for (s = 0; s < num_surfaces; s++) {
      struct pipe_texture *textures[NUM_NATIVE_ATTACHMENTS];
      struct egl_g3d_surface *gsurf;
      struct egl_g3d_buffer *gbuf;
      EGLint att;

      if (s == 0) {
         gsurf = egl_g3d_surface(gctx->base.DrawSurface);
         gbuf = &gctx->draw;
      }
      else {
         gsurf = egl_g3d_surface(gctx->base.ReadSurface);
         gbuf = &gctx->read;
d82 2
a83 2
      if (!gctx->force_validate) {
         unsigned int seq_num;
d85 2
a86 6
         gsurf->native->validate(gsurf->native, gbuf->attachment_mask,
               &seq_num, NULL, NULL, NULL);
         /* skip validation */
         if (gsurf->sequence_number == seq_num)
            continue;
      }
d88 2
a89 2
      pipe_surface_reference(&gsurf->render_surface, NULL);
      memset(textures, 0, sizeof(textures));
d91 1
a91 13
      gsurf->native->validate(gsurf->native, gbuf->attachment_mask,
            &gsurf->sequence_number, textures,
            &gsurf->base.Width, &gsurf->base.Height);
      for (att = 0; att < NUM_NATIVE_ATTACHMENTS; att++) {
         struct pipe_texture *pt = textures[att];
         struct pipe_surface *ps;

         if (native_attachment_mask_test(gbuf->attachment_mask, att) && pt) {
            ps = screen->get_tex_surface(screen, pt, 0, 0, 0,
                  PIPE_BUFFER_USAGE_GPU_READ |
                  PIPE_BUFFER_USAGE_GPU_WRITE);
            gctx->stapi->st_set_framebuffer_surface(gbuf->st_fb,
                  st_att_map[att], ps);
d93 6
a98 2
            if (gsurf->render_att == att)
               pipe_surface_reference(&gsurf->render_surface, ps);
d100 6
a105 7
            pipe_surface_reference(&ps, NULL);
            pipe_texture_reference(&pt, NULL);
         }
      }

      gctx->stapi->st_resize_framebuffer(gbuf->st_fb,
            gsurf->base.Width, gsurf->base.Height);
d108 5
a112 1
   gctx->force_validate = EGL_FALSE;
d114 8
a121 1
}
d123 5
a127 15
/**
 * Create a st_framebuffer.
 */
static struct st_framebuffer *
create_framebuffer(_EGLContext *ctx, _EGLSurface *surf)
{
   struct egl_g3d_context *gctx = egl_g3d_context(ctx);
   struct egl_g3d_surface *gsurf = egl_g3d_surface(surf);
   struct egl_g3d_config *gconf = egl_g3d_config(gsurf->base.Config);

   return gctx->stapi->st_create_framebuffer(&gconf->native->mode,
         gconf->native->color_format, gconf->native->depth_format,
         gconf->native->stencil_format,
         gsurf->base.Width, gsurf->base.Height, &gsurf->base);
}
d129 4
a132 8
/**
 * Update the attachments of draw/read surfaces.
 */
static void
egl_g3d_route_context(_EGLDisplay *dpy, _EGLContext *ctx)
{
   struct egl_g3d_context *gctx = egl_g3d_context(ctx);
   EGLint s;
d134 7
a140 12
   /* route draw and read buffers' attachments */
   for (s = 0; s < 2; s++) {
      struct egl_g3d_surface *gsurf;
      struct egl_g3d_buffer *gbuf;

      if (s == 0) {
         gsurf = egl_g3d_surface(gctx->base.DrawSurface);
         gbuf = &gctx->draw;
      }
      else {
         gsurf = egl_g3d_surface(gctx->base.ReadSurface);
         gbuf = &gctx->read;
d143 2
a144 1
      gbuf->attachment_mask = (1 << gsurf->render_att);
d146 1
a146 18
      /* FIXME OpenGL defaults to draw the front or back buffer when the
       * context is single-buffered or double-buffered respectively.  In EGL,
       * however, the buffer to be drawn is determined by the surface, instead
       * of the context.  As a result, rendering to a pixmap surface with a
       * double-buffered context does not work as expected.
       *
       * gctx->stapi->st_draw_front_buffer(gctx->st_ctx, natt ==
       *    NATIVE_ATTACHMENT_FRONT_LEFT);
       */

      /*
       * FIXME If the back buffer is asked for here, and the front buffer is
       * later needed by the client API (e.g. glDrawBuffer is called to draw
       * the front buffer), it will create a new pipe texture and draw there.
       * One fix is to ask for both buffers here, but it would be a waste if
       * the front buffer is never used.  A better fix is to add a callback to
       * the pipe screen with context private (just like flush_frontbuffer).
       */
d148 2
d152 2
d155 1
a155 1
 * Reallocate the context's framebuffers after draw/read surfaces change.
d158 3
a160 1
egl_g3d_realloc_context(_EGLDisplay *dpy, _EGLContext *ctx)
d162 3
a164 15
   struct egl_g3d_context *gctx = egl_g3d_context(ctx);
   struct egl_g3d_surface *gdraw = egl_g3d_surface(gctx->base.DrawSurface);
   struct egl_g3d_surface *gread = egl_g3d_surface(gctx->base.ReadSurface);

   /* unreference the old framebuffers */
   if (gctx->draw.st_fb) {
      EGLBoolean is_equal = (gctx->draw.st_fb == gctx->read.st_fb);
      void *priv;

      priv = gctx->stapi->st_framebuffer_private(gctx->draw.st_fb);
      if (!gdraw || priv != (void *) &gdraw->base) {
         gctx->stapi->st_unreference_framebuffer(gctx->draw.st_fb);
         gctx->draw.st_fb = NULL;
         gctx->draw.attachment_mask = 0x0;
      }
d166 13
a178 3
      if (is_equal) {
         gctx->read.st_fb = NULL;
         gctx->draw.attachment_mask = 0x0;
d181 1
a181 6
         priv = gctx->stapi->st_framebuffer_private(gctx->read.st_fb);
         if (!gread || priv != (void *) &gread->base) {
            gctx->stapi->st_unreference_framebuffer(gctx->read.st_fb);
            gctx->read.st_fb = NULL;
            gctx->draw.attachment_mask = 0x0;
         }
d185 12
a196 2
   if (!gdraw)
      return EGL_TRUE;
d198 2
a199 22
   /* create the draw fb */
   if (!gctx->draw.st_fb) {
      gctx->draw.st_fb = create_framebuffer(&gctx->base, &gdraw->base);
      if (!gctx->draw.st_fb)
         return EGL_FALSE;
   }

   /* create the read fb */
   if (!gctx->read.st_fb) {
      if (gread != gdraw) {
         gctx->read.st_fb = create_framebuffer(&gctx->base, &gread->base);
         if (!gctx->read.st_fb) {
            gctx->stapi->st_unreference_framebuffer(gctx->draw.st_fb);
            gctx->draw.st_fb = NULL;
            return EGL_FALSE;
         }
      }
      else {
         /* there is no st_reference_framebuffer... */
         gctx->read.st_fb = gctx->draw.st_fb;
      }
   }
d201 5
a205 2
   egl_g3d_route_context(dpy, &gctx->base);
   gctx->force_validate = EGL_TRUE;
d207 2
a208 2
   return EGL_TRUE;
}
d210 1
a210 9
/**
 * Return the state tracker for the given context.
 */
static const struct egl_g3d_st *
egl_g3d_choose_st(_EGLDriver *drv, _EGLContext *ctx)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
   const struct egl_g3d_st *stapi;
   EGLint idx = -1;
d212 4
a215 24
   switch (ctx->ClientAPI) {
   case EGL_OPENGL_ES_API:
      switch (ctx->ClientVersion) {
      case 1:
         idx = EGL_G3D_ST_OPENGL_ES;
         break;
      case 2:
         idx = EGL_G3D_ST_OPENGL_ES2;
         break;
      default:
         _eglLog(_EGL_WARNING, "unknown client version %d",
               ctx->ClientVersion);
         break;
      }
      break;
   case EGL_OPENVG_API:
      idx = EGL_G3D_ST_OPENVG;
      break;
   case EGL_OPENGL_API:
      idx = EGL_G3D_ST_OPENGL;
      break;
   default:
      _eglLog(_EGL_WARNING, "unknown client API 0x%04x", ctx->ClientAPI);
      break;
d218 9
a226 3
   stapi = (idx >= 0) ? gdrv->stapis[idx] : NULL;
   return stapi;
}
d228 3
a230 8
/**
 * Initialize the state trackers.
 */
static void
egl_g3d_init_st(_EGLDriver *drv)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
   EGLint i;
d232 2
a233 3
   /* already initialized */
   if (gdrv->api_mask)
      return;
d235 5
a239 4
   for (i = 0; i < NUM_EGL_G3D_STS; i++) {
      gdrv->stapis[i] = egl_g3d_get_st(i);
      if (gdrv->stapis[i])
         gdrv->api_mask |= gdrv->stapis[i]->api_bit;
d242 6
a247 4
   if (gdrv->api_mask)
      _eglLog(_EGL_DEBUG, "Driver API mask: 0x%x", gdrv->api_mask);
   else
      _eglLog(_EGL_WARNING, "No supported client API");
d251 1
a251 3
 * Get the probe object of the display.
 *
 * Note that this function may be called before the display is initialized.
d253 5
a257 2
static struct native_probe *
egl_g3d_get_probe(_EGLDriver *drv, _EGLDisplay *dpy)
d259 7
a265 2
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
   struct native_probe *nprobe;
d267 36
a302 6
   nprobe = (struct native_probe *) _eglGetProbeCache(gdrv->probe_key);
   if (!nprobe || nprobe->display != dpy->NativeDisplay) {
      if (nprobe)
         nprobe->destroy(nprobe);
      nprobe = native_create_probe(dpy->NativeDisplay);
      _eglSetProbeCache(gdrv->probe_key, (void *) nprobe);
d305 1
a305 2
   return nprobe;
}
d307 1
a307 16
/**
 * Destroy the probe object of the display.  The display may be NULL.
 *
 * Note that this function may be called before the display is initialized.
 */
static void
egl_g3d_destroy_probe(_EGLDriver *drv, _EGLDisplay *dpy)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
   struct native_probe *nprobe;

   nprobe = (struct native_probe *) _eglGetProbeCache(gdrv->probe_key);
   if (nprobe && (!dpy || nprobe->display == dpy->NativeDisplay)) {
      nprobe->destroy(nprobe);
      _eglSetProbeCache(gdrv->probe_key, NULL);
   }
d311 1
a311 4
 * Return an API mask that consists of the state trackers that supports the
 * given mode.
 *
 * FIXME add st_is_mode_supported()?
d314 2
a315 26
get_mode_api_mask(const __GLcontextModes *mode, EGLint api_mask)
{
   EGLint check;

   /* OpenGL ES 1.x and 2.x are checked together */
   check = EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT;
   if (api_mask & check) {
      /* this is required by EGL, not by OpenGL ES */
      if (mode->drawableType & GLX_WINDOW_BIT && !mode->doubleBufferMode)
         api_mask &= ~check;
   }

   check = EGL_OPENVG_BIT;
   if (api_mask & check) {
      /* vega st needs the depth/stencil rb */
      if (!mode->depthBits && !mode->stencilBits)
         api_mask &= ~check;
   }

   return api_mask;
}

#ifdef EGL_MESA_screen_surface

static void
egl_g3d_add_screens(_EGLDriver *drv, _EGLDisplay *dpy)
d318 10
a327 2
   const struct native_connector **native_connectors;
   EGLint num_connectors, i;
d329 2
a330 7
   native_connectors =
      gdpy->native->modeset->get_connectors(gdpy->native, &num_connectors, NULL);
   if (!num_connectors) {
      if (native_connectors)
         free(native_connectors);
      return;
   }
d332 2
a333 5
   for (i = 0; i < num_connectors; i++) {
      const struct native_connector *nconn = native_connectors[i];
      struct egl_g3d_screen *gscr;
      const struct native_mode **native_modes;
      EGLint num_modes, j;
d335 5
a339 24
      /* TODO support for hotplug */
      native_modes =
         gdpy->native->modeset->get_modes(gdpy->native, nconn, &num_modes);
      if (!num_modes) {
         if (native_modes)
            free(native_modes);
         continue;
      }

      gscr = CALLOC_STRUCT(egl_g3d_screen);
      if (!gscr) {
         free(native_modes);
         continue;
      }

      _eglInitScreen(&gscr->base);

      for (j = 0; j < num_modes; j++) {
         const struct native_mode *nmode = native_modes[j];
         _EGLMode *mode;

         mode = _eglAddNewMode(&gscr->base, nmode->width, nmode->height,
               nmode->refresh_rate, nmode->desc);
         if (!mode)
d341 1
a341 2
         /* gscr->native_modes and gscr->base.Modes should be consistent */
         assert(mode == &gscr->base.Modes[j]);
d344 1
a344 4
      gscr->native = nconn;
      gscr->native_modes = native_modes;

      _eglAddScreen(dpy, &gscr->base);
d347 1
a347 1
   free(native_connectors);
a349 2
#endif /* EGL_MESA_screen_surface */

a355 1
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
d358 3
a360 1
   int num_configs, i;
d362 1
a362 2
   native_configs = gdpy->native->get_configs(gdpy->native,
         &num_configs);
d365 1
a365 1
         free(native_configs);
d369 4
a372 4
   for (i = 0; i < num_configs; i++) {
      EGLint api_mask;
      struct egl_g3d_config *gconf;
      EGLBoolean valid;
d374 2
a375 3
      gconf = CALLOC_STRUCT(egl_g3d_config);
      if (!gconf)
         continue;
d377 3
a379 1
      _eglInitConfig(&gconf->base, dpy, id);
d381 9
a389 5
      api_mask = get_mode_api_mask(&native_configs[i]->mode, gdrv->api_mask);
      if (!api_mask) {
         _eglLog(_EGL_DEBUG, "no state tracker supports config 0x%x",
               native_configs[i]->mode.visualID);
      }
d391 2
a392 9
      valid = _eglConfigFromContextModesRec(&gconf->base,
            &native_configs[i]->mode, api_mask, api_mask);
      if (valid) {
#ifdef EGL_MESA_screen_surface
         /* check if scanout surface bit is set */
         if (native_configs[i]->scanout_bit) {
            EGLint val = GET_CONFIG_ATTRIB(&gconf->base, EGL_SURFACE_TYPE);
            val |= EGL_SCREEN_BIT_MESA;
            SET_CONFIG_ATTRIB(&gconf->base, EGL_SURFACE_TYPE, val);
a393 2
#endif
         valid = _eglValidateConfig(&gconf->base, EGL_FALSE);
a394 10
      if (!valid) {
         _eglLog(_EGL_DEBUG, "skip invalid config 0x%x",
               native_configs[i]->mode.visualID);
         free(gconf);
         continue;
      }

      gconf->native = native_configs[i];
      _eglAddConfig(dpy, &gconf->base);
      id++;
d397 1
a397 1
   free(native_configs);
a400 3
/**
 * Flush the front buffer of the context's draw surface.
 */
d402 3
a404 2
egl_g3d_flush_frontbuffer(struct pipe_screen *screen,
                          struct pipe_surface *surf, void *context_private)
d406 12
a417 2
   struct egl_g3d_context *gctx = egl_g3d_context(context_private);
   struct egl_g3d_surface *gsurf = egl_g3d_surface(gctx->base.DrawSurface);
d419 14
a432 2
   if (gsurf)
      gsurf->native->flush_frontbuffer(gsurf->native);
d435 6
a440 3
/**
 * Re-validate the context.
 */
d442 1
a442 1
egl_g3d_update_buffer(struct pipe_screen *screen, void *context_private)
d444 2
a445 2
   struct egl_g3d_context *gctx = egl_g3d_context(context_private);
   egl_g3d_validate_context(gctx->base.Resource.Display, &gctx->base);
d449 1
a449 3
egl_g3d_invalid_surface(struct native_display *ndpy,
                        struct native_surface *nsurf,
                        unsigned int seq_num)
d451 5
a455 7
   /* XXX not thread safe? */
   struct egl_g3d_surface *gsurf = egl_g3d_surface(nsurf->user_data);
   struct egl_g3d_context *gctx = egl_g3d_context(gsurf->base.CurrentContext);

   /* set force_validate to skip an unnecessary check */
   if (gctx)
      gctx->force_validate = TRUE;
a457 4
static struct native_event_handler egl_g3d_native_event_handler = {
   .invalid_surface = egl_g3d_invalid_surface
};

a461 1
   EGLint i;
a463 1
   _eglCleanupDisplay(dpy);
d465 7
d473 2
a474 6
      for (i = 0; i < dpy->NumScreens; i++) {
         struct egl_g3d_screen *gscr = egl_g3d_screen(dpy->Screens[i]);
         free(gscr->native_modes);
         free(gscr);
      }
      free(dpy->Screens);
d477 5
d485 1
a485 1
   free(gdpy);
d497 1
d499 3
a501 2
   /* the probe object is unlikely to be needed again */
   egl_g3d_destroy_probe(drv, dpy);
d508 1
d511 3
a513 2
   gdpy->native = native_create_display(dpy->NativeDisplay,
         &egl_g3d_native_event_handler);
d519 15
a533 6
   gdpy->native->user_data = (void *) dpy;
   gdpy->native->screen->flush_frontbuffer = egl_g3d_flush_frontbuffer;
   gdpy->native->screen->update_buffer = egl_g3d_update_buffer;

   egl_g3d_init_st(&gdrv->base);
   dpy->ClientAPIsMask = gdrv->api_mask;
d547 13
a575 443
static _EGLContext *
egl_g3d_create_context(_EGLDriver *drv, _EGLDisplay *dpy, _EGLConfig *conf,
                       _EGLContext *share, const EGLint *attribs)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct egl_g3d_context *gshare = egl_g3d_context(share);
   struct egl_g3d_config *gconf = egl_g3d_config(conf);
   struct egl_g3d_context *gctx;
   const __GLcontextModes *mode;

   gctx = CALLOC_STRUCT(egl_g3d_context);
   if (!gctx) {
      _eglError(EGL_BAD_ALLOC, "eglCreateContext");
      return NULL;
   }

   if (!_eglInitContext(&gctx->base, dpy, conf, attribs)) {
      free(gctx);
      return NULL;
   }

   gctx->stapi = egl_g3d_choose_st(drv, &gctx->base);
   if (!gctx->stapi) {
      free(gctx);
      return NULL;
   }

   mode = &gconf->native->mode;

   gctx->pipe = gdpy->native->screen->context_create(
      gdpy->native->screen,
      (void *) &gctx->base);

   if (!gctx->pipe) {
      free(gctx);
      return NULL;
   }

   gctx->st_ctx = gctx->stapi->st_create_context(gctx->pipe, mode,
                        (gshare) ? gshare->st_ctx : NULL);
   if (!gctx->st_ctx) {
      gctx->pipe->destroy(gctx->pipe);
      free(gctx);
      return NULL;
   }

   return &gctx->base;
}

/**
 * Destroy a context.
 */
static void
destroy_context(_EGLDisplay *dpy, _EGLContext *ctx)
{
   struct egl_g3d_context *gctx = egl_g3d_context(ctx);

   /* FIXME a context might live longer than its display */
   if (!dpy->Initialized)
      _eglLog(_EGL_FATAL, "destroy a context with an unitialized display");

   egl_g3d_realloc_context(dpy, &gctx->base);
   /* it will destroy the associated pipe context */
   gctx->stapi->st_destroy_context(gctx->st_ctx);

   free(gctx);
}

static EGLBoolean
egl_g3d_destroy_context(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *ctx)
{
   if (!_eglIsContextBound(ctx))
      destroy_context(dpy, ctx);
   return EGL_TRUE;
}

struct egl_g3d_create_surface_arg {
   EGLint type;
   union {
      EGLNativeWindowType win;
      EGLNativePixmapType pix;
   } u;
};

static _EGLSurface *
egl_g3d_create_surface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLConfig *conf,
                       struct egl_g3d_create_surface_arg *arg,
                       const EGLint *attribs)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct egl_g3d_config *gconf = egl_g3d_config(conf);
   struct egl_g3d_surface *gsurf;
   struct native_surface *nsurf;
   const char *err;

   switch (arg->type) {
   case EGL_WINDOW_BIT:
      err = "eglCreateWindowSurface";
      break;
   case EGL_PIXMAP_BIT:
      err = "eglCreatePixmapSurface";
      break;
   case EGL_PBUFFER_BIT:
      err = "eglCreatePBufferSurface";
      break;
#ifdef EGL_MESA_screen_surface
   case EGL_SCREEN_BIT_MESA:
      err = "eglCreateScreenSurface";
      break;
#endif
   default:
      err = "eglCreateUnknownSurface";
      break;
   }

   gsurf = CALLOC_STRUCT(egl_g3d_surface);
   if (!gsurf) {
      _eglError(EGL_BAD_ALLOC, err);
      return NULL;
   }

   if (!_eglInitSurface(&gsurf->base, dpy, arg->type, conf, attribs)) {
      free(gsurf);
      return NULL;
   }

   /* create the native surface */
   switch (arg->type) {
   case EGL_WINDOW_BIT:
      nsurf = gdpy->native->create_window_surface(gdpy->native,
            arg->u.win, gconf->native);
      break;
   case EGL_PIXMAP_BIT:
      nsurf = gdpy->native->create_pixmap_surface(gdpy->native,
            arg->u.pix, gconf->native);
      break;
   case EGL_PBUFFER_BIT:
      nsurf = gdpy->native->create_pbuffer_surface(gdpy->native,
            gconf->native, gsurf->base.Width, gsurf->base.Height);
      break;
#ifdef EGL_MESA_screen_surface
   case EGL_SCREEN_BIT_MESA:
      /* prefer back buffer (move to _eglInitSurface?) */
      gsurf->base.RenderBuffer = EGL_BACK_BUFFER;
      nsurf = gdpy->native->modeset->create_scanout_surface(gdpy->native,
            gconf->native, gsurf->base.Width, gsurf->base.Height);
      break;
#endif
   default:
      nsurf = NULL;
      break;
   }

   if (!nsurf) {
      free(gsurf);
      return NULL;
   }
   /* initialize the geometry */
   if (!nsurf->validate(nsurf, 0x0, &gsurf->sequence_number, NULL,
            &gsurf->base.Width, &gsurf->base.Height)) {
      nsurf->destroy(nsurf);
      free(gsurf);
      return NULL;
   }

   nsurf->user_data = &gsurf->base;
   gsurf->native = nsurf;

   gsurf->render_att = (gsurf->base.RenderBuffer == EGL_SINGLE_BUFFER) ?
      NATIVE_ATTACHMENT_FRONT_LEFT : NATIVE_ATTACHMENT_BACK_LEFT;
   if (!gconf->native->mode.doubleBufferMode)
      gsurf->render_att = NATIVE_ATTACHMENT_FRONT_LEFT;

   return &gsurf->base;
}

static _EGLSurface *
egl_g3d_create_window_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                              _EGLConfig *conf, EGLNativeWindowType win,
                              const EGLint *attribs)
{
   struct egl_g3d_create_surface_arg arg;

   memset(&arg, 0, sizeof(arg));
   arg.type = EGL_WINDOW_BIT;
   arg.u.win = win;

   return egl_g3d_create_surface(drv, dpy, conf, &arg, attribs);
}

static _EGLSurface *
egl_g3d_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                              _EGLConfig *conf, EGLNativePixmapType pix,
                              const EGLint *attribs)
{
   struct egl_g3d_create_surface_arg arg;

   memset(&arg, 0, sizeof(arg));
   arg.type = EGL_PIXMAP_BIT;
   arg.u.pix = pix;

   return egl_g3d_create_surface(drv, dpy, conf, &arg, attribs);
}

static _EGLSurface *
egl_g3d_create_pbuffer_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                               _EGLConfig *conf, const EGLint *attribs)
{
   struct egl_g3d_create_surface_arg arg;

   memset(&arg, 0, sizeof(arg));
   arg.type = EGL_PBUFFER_BIT;

   return egl_g3d_create_surface(drv, dpy, conf, &arg, attribs);
}

/**
 * Destroy a surface.
 */
static void
destroy_surface(_EGLDisplay *dpy, _EGLSurface *surf)
{
   struct egl_g3d_surface *gsurf = egl_g3d_surface(surf);

   /* FIXME a surface might live longer than its display */
   if (!dpy->Initialized)
      _eglLog(_EGL_FATAL, "destroy a surface with an unitialized display");

   pipe_surface_reference(&gsurf->render_surface, NULL);
   gsurf->native->destroy(gsurf->native);
   free(gsurf);
}

static EGLBoolean
egl_g3d_destroy_surface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   if (!_eglIsSurfaceBound(surf))
      destroy_surface(dpy, surf);
   return EGL_TRUE;
}

static EGLBoolean
egl_g3d_make_current(_EGLDriver *drv, _EGLDisplay *dpy,
                     _EGLSurface *draw, _EGLSurface *read, _EGLContext *ctx)
{
   struct egl_g3d_context *gctx = egl_g3d_context(ctx);
   struct egl_g3d_surface *gdraw = egl_g3d_surface(draw);
   struct egl_g3d_context *old_gctx;
   EGLBoolean ok = EGL_TRUE;

   /* bind the new context and return the "orphaned" one */
   if (!_eglBindContext(&ctx, &draw, &read))
      return EGL_FALSE;
   old_gctx = egl_g3d_context(ctx);

   if (old_gctx) {
      /* flush old context */
      old_gctx->stapi->st_flush(old_gctx->st_ctx,
            PIPE_FLUSH_RENDER_CACHE | PIPE_FLUSH_FRAME, NULL);

      /*
       * The old context is no longer current, and egl_g3d_realloc_context()
       * should be called to destroy the framebuffers.  However, it is possible
       * that it will be made current again with the same draw/read surfaces.
       * It might be better to keep it around.
       */
   }

   if (gctx) {
      ok = egl_g3d_realloc_context(dpy, &gctx->base);
      if (ok) {
         ok = gctx->stapi->st_make_current(gctx->st_ctx,
               gctx->draw.st_fb, gctx->read.st_fb);
         if (ok) {
            egl_g3d_validate_context(dpy, &gctx->base);
            if (gdraw->base.Type == EGL_WINDOW_BIT) {
               gctx->base.WindowRenderBuffer =
                  (gdraw->render_att == NATIVE_ATTACHMENT_FRONT_LEFT) ?
                  EGL_SINGLE_BUFFER : EGL_BACK_BUFFER;
            }
         }
      }
   }
   else if (old_gctx) {
      ok = old_gctx->stapi->st_make_current(NULL, NULL, NULL);
      old_gctx->base.WindowRenderBuffer = EGL_NONE;
   }

   if (ctx && !_eglIsContextLinked(ctx))
      destroy_context(dpy, ctx);
   if (draw && !_eglIsSurfaceLinked(draw))
      destroy_surface(dpy, draw);
   if (read && read != draw && !_eglIsSurfaceLinked(read))
      destroy_surface(dpy, read);

   return ok;
}

static EGLBoolean
egl_g3d_swap_buffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   struct egl_g3d_surface *gsurf = egl_g3d_surface(surf);
   _EGLContext *ctx = _eglGetCurrentContext();
   struct egl_g3d_context *gctx = NULL;

   /* no-op for pixmap or pbuffer surface */
   if (gsurf->base.Type == EGL_PIXMAP_BIT ||
       gsurf->base.Type == EGL_PBUFFER_BIT)
      return EGL_TRUE;

   /* or when the surface is single-buffered */
   if (gsurf->render_att == NATIVE_ATTACHMENT_FRONT_LEFT)
      return EGL_TRUE;

   if (ctx && ctx->DrawSurface == surf)
      gctx = egl_g3d_context(ctx);

   /* flush if the surface is current */
   if (gctx)
      gctx->stapi->st_notify_swapbuffers(gctx->draw.st_fb);

   return gsurf->native->swap_buffers(gsurf->native);
}

/**
 * Find a config that supports the pixmap.
 */
_EGLConfig *
egl_g3d_find_pixmap_config(_EGLDisplay *dpy, EGLNativePixmapType pix)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct egl_g3d_config *gconf;
   EGLint i;

   for (i = 0; i < dpy->NumConfigs; i++) {
      gconf = egl_g3d_config(dpy->Configs[i]);
      if (gdpy->native->is_pixmap_supported(gdpy->native, pix, gconf->native))
         break;
   }

   return (i < dpy->NumConfigs) ? &gconf->base : NULL;
}

/**
 * Get the pipe surface of the given attachment of the native surface.
 */
static struct pipe_surface *
get_pipe_surface(struct native_display *ndpy, struct native_surface *nsurf,
                 enum native_attachment natt)
{
   struct pipe_texture *textures[NUM_NATIVE_ATTACHMENTS];
   struct pipe_surface *psurf;

   textures[natt] = NULL;
   nsurf->validate(nsurf, 1 << natt, NULL, textures, NULL, NULL);
   if (!textures[natt])
      return NULL;

   psurf = ndpy->screen->get_tex_surface(ndpy->screen, textures[natt],
         0, 0, 0, PIPE_BUFFER_USAGE_CPU_WRITE);
   pipe_texture_reference(&textures[natt], NULL);

   return psurf;
}

static EGLBoolean
egl_g3d_copy_buffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                     EGLNativePixmapType target)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct egl_g3d_surface *gsurf = egl_g3d_surface(surf);
   _EGLContext *ctx = _eglGetCurrentContext();
   struct egl_g3d_config *gconf;
   struct native_surface *nsurf;
   struct pipe_screen *screen = gdpy->native->screen;
   struct pipe_surface *psurf;

   if (!gsurf->render_surface)
      return EGL_TRUE;

   gconf = egl_g3d_config(egl_g3d_find_pixmap_config(dpy, target));
   if (!gconf)
      return _eglError(EGL_BAD_NATIVE_PIXMAP, "eglCopyBuffers");

   nsurf = gdpy->native->create_pixmap_surface(gdpy->native,
         target, gconf->native);
   if (!nsurf)
      return _eglError(EGL_BAD_NATIVE_PIXMAP, "eglCopyBuffers");

   /* flush if the surface is current */
   if (ctx && ctx->DrawSurface == &gsurf->base) {
      struct egl_g3d_context *gctx = egl_g3d_context(ctx);
      gctx->stapi->st_flush(gctx->st_ctx,
            PIPE_FLUSH_RENDER_CACHE | PIPE_FLUSH_FRAME, NULL);
   }

   psurf = get_pipe_surface(gdpy->native, nsurf, NATIVE_ATTACHMENT_FRONT_LEFT);
   if (psurf) {
      struct pipe_context pipe;

      /**
       * XXX This is hacky.  If we might allow the EGLDisplay to create a pipe
       * context of its own and use the blitter context for this.
       */
      memset(&pipe, 0, sizeof(pipe));
      pipe.screen = screen;

      util_surface_copy(&pipe, FALSE, psurf, 0, 0,
            gsurf->render_surface, 0, 0, psurf->width, psurf->height);

      pipe_surface_reference(&psurf, NULL);
      nsurf->flush_frontbuffer(nsurf);
   }

   nsurf->destroy(nsurf);

   return EGL_TRUE;
}

static EGLBoolean
egl_g3d_wait_client(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *ctx)
{
   struct egl_g3d_context *gctx = egl_g3d_context(ctx);
   gctx->stapi->st_finish(gctx->st_ctx);
   return EGL_TRUE;
}

static EGLBoolean
egl_g3d_wait_native(_EGLDriver *drv, _EGLDisplay *dpy, EGLint engine)
{
   _EGLContext *ctx = _eglGetCurrentContext();

   if (engine != EGL_CORE_NATIVE_ENGINE)
      return _eglError(EGL_BAD_PARAMETER, "eglWaitNative");

   if (ctx && ctx->DrawSurface) {
      struct egl_g3d_surface *gsurf = egl_g3d_surface(ctx->DrawSurface);
      gsurf->native->wait(gsurf->native);
   }

   return EGL_TRUE;
}

d580 1
a580 2
   _EGLProc proc;
   EGLint i;
d582 4
a585 11
   /* in case this is called before a display is initialized */
   egl_g3d_init_st(&gdrv->base);

   for (i = 0; i < NUM_EGL_G3D_STS; i++) {
      const struct egl_g3d_st *stapi = gdrv->stapis[i];
      if (stapi) {
         proc = (_EGLProc) stapi->st_get_proc_address(procname);
         if (proc)
            return proc;
      }
   }
d587 2
a588 1
   return (_EGLProc) NULL;
a590 155
static EGLBoolean
egl_g3d_bind_tex_image(_EGLDriver *drv, _EGLDisplay *dpy,
                       _EGLSurface *surf, EGLint buffer)
{
   struct egl_g3d_surface *gsurf = egl_g3d_surface(surf);
   _EGLContext *es1 = _eglGetAPIContext(EGL_OPENGL_ES_API);
   struct egl_g3d_context *gctx;
   enum pipe_format target_format;
   int target;

   if (!gsurf || gsurf->base.Type != EGL_PBUFFER_BIT)
      return _eglError(EGL_BAD_SURFACE, "eglBindTexImage");
   if (buffer != EGL_BACK_BUFFER)
      return _eglError(EGL_BAD_PARAMETER, "eglBindTexImage");
   if (gsurf->base.BoundToTexture)
      return _eglError(EGL_BAD_ACCESS, "eglBindTexImage");

   switch (gsurf->base.TextureFormat) {
   case EGL_TEXTURE_RGB:
      target_format = PIPE_FORMAT_R8G8B8_UNORM;
      break;
   case EGL_TEXTURE_RGBA:
      target_format = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   default:
      return _eglError(EGL_BAD_MATCH, "eglBindTexImage");
   }

   switch (gsurf->base.TextureTarget) {
   case EGL_TEXTURE_2D:
      target = ST_TEXTURE_2D;
      break;
   default:
      return _eglError(EGL_BAD_MATCH, "eglBindTexImage");
   }

   if (!es1)
      return EGL_TRUE;
   if (!gsurf->render_surface)
      return EGL_FALSE;

   /* flush properly if the surface is bound */
   if (gsurf->base.CurrentContext) {
      gctx = egl_g3d_context(gsurf->base.CurrentContext);
      gctx->stapi->st_flush(gctx->st_ctx,
            PIPE_FLUSH_RENDER_CACHE | PIPE_FLUSH_FRAME, NULL);
   }

   gctx = egl_g3d_context(es1);
   gctx->stapi->st_bind_texture_surface(gsurf->render_surface,
         target, gsurf->base.MipmapLevel, target_format);

   gsurf->base.BoundToTexture = EGL_TRUE;

   return EGL_TRUE;
}

static EGLBoolean
egl_g3d_release_tex_image(_EGLDriver *drv, _EGLDisplay *dpy,
                          _EGLSurface *surf, EGLint buffer)
{
   struct egl_g3d_surface *gsurf = egl_g3d_surface(surf);

   if (!gsurf || gsurf->base.Type != EGL_PBUFFER_BIT ||
       !gsurf->base.BoundToTexture)
      return _eglError(EGL_BAD_SURFACE, "eglReleaseTexImage");
   if (buffer != EGL_BACK_BUFFER)
      return _eglError(EGL_BAD_PARAMETER, "eglReleaseTexImage");

   if (gsurf->render_surface) {
      _EGLContext *ctx = _eglGetAPIContext(EGL_OPENGL_ES_API);
      struct egl_g3d_context *gctx = egl_g3d_context(ctx);

      /* what if the context the surface binds to is no longer current? */
      if (gctx)
         gctx->stapi->st_unbind_texture_surface(gsurf->render_surface,
               ST_TEXTURE_2D, gsurf->base.MipmapLevel);
   }

   gsurf->base.BoundToTexture = EGL_FALSE;

   return EGL_TRUE;
}

#ifdef EGL_MESA_screen_surface

static _EGLSurface *
egl_g3d_create_screen_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                              _EGLConfig *conf, const EGLint *attribs)
{
   struct egl_g3d_create_surface_arg arg;

   memset(&arg, 0, sizeof(arg));
   arg.type = EGL_SCREEN_BIT_MESA;

   return egl_g3d_create_surface(drv, dpy, conf, &arg, attribs);
}

static EGLBoolean
egl_g3d_show_screen_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                            _EGLScreen *scr, _EGLSurface *surf,
                            _EGLMode *mode)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct egl_g3d_screen *gscr = egl_g3d_screen(scr);
   struct egl_g3d_surface *gsurf = egl_g3d_surface(surf);
   struct native_surface *nsurf;
   const struct native_mode *nmode;
   EGLBoolean changed;

   if (gsurf) {
      EGLint idx;

      if (!mode)
         return _eglError(EGL_BAD_MATCH, "eglShowSurfaceMESA");
      if (gsurf->base.Type != EGL_SCREEN_BIT_MESA)
         return _eglError(EGL_BAD_SURFACE, "eglShowScreenSurfaceMESA");
      if (gsurf->base.Width < mode->Width || gsurf->base.Height < mode->Height)
         return _eglError(EGL_BAD_MATCH,
               "eglShowSurfaceMESA(surface smaller than mode size)");

      /* find the index of the mode */
      for (idx = 0; idx < gscr->base.NumModes; idx++)
         if (mode == &gscr->base.Modes[idx])
            break;
      if (idx >= gscr->base.NumModes) {
         return _eglError(EGL_BAD_MODE_MESA,
               "eglShowSurfaceMESA(unknown mode)");
      }

      nsurf = gsurf->native;
      nmode = gscr->native_modes[idx];
   }
   else {
      if (mode)
         return _eglError(EGL_BAD_MATCH, "eglShowSurfaceMESA");

      /* disable the screen */
      nsurf = NULL;
      nmode = NULL;
   }

   /* TODO surface panning by CRTC choosing */
   changed = gdpy->native->modeset->program(gdpy->native, 0, nsurf,
         gscr->base.OriginX, gscr->base.OriginY, &gscr->native, 1, nmode);
   if (changed) {
      gscr->base.CurrentSurface = &gsurf->base;
      gscr->base.CurrentMode = mode;
   }

   return changed;
}

#endif /* EGL_MESA_screen_surface */

d594 1
a594 33
   struct native_probe *nprobe;
   enum native_probe_result res;
   EGLint score;

   nprobe = egl_g3d_get_probe(drv, dpy);
   res = native_get_probe_result(nprobe);

   switch (res) {
   case NATIVE_PROBE_UNKNOWN:
   default:
      score = 0;
      break;
   case NATIVE_PROBE_FALLBACK:
      score = 40;
      break;
   case NATIVE_PROBE_SUPPORTED:
      score = 50;
      break;
   case NATIVE_PROBE_EXACT:
      score = 100;
      break;
   }

   return score;
}

static void
egl_g3d_unload(_EGLDriver *drv)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);

   egl_g3d_destroy_probe(drv, NULL);
   free(gdrv);
d598 1
a598 1
_eglMain(const char *args)
a599 1
   static char driver_name[64];
a601 3
   snprintf(driver_name, sizeof(driver_name),
         "Gallium/%s", native_get_name());

d606 1
a606 1
   _eglInitDriverFallbacks(&gdrv->base);
d608 1
a610 11
   gdrv->base.API.CreateContext = egl_g3d_create_context;
   gdrv->base.API.DestroyContext = egl_g3d_destroy_context;
   gdrv->base.API.CreateWindowSurface = egl_g3d_create_window_surface;
   gdrv->base.API.CreatePixmapSurface = egl_g3d_create_pixmap_surface;
   gdrv->base.API.CreatePbufferSurface = egl_g3d_create_pbuffer_surface;
   gdrv->base.API.DestroySurface = egl_g3d_destroy_surface;
   gdrv->base.API.MakeCurrent = egl_g3d_make_current;
   gdrv->base.API.SwapBuffers = egl_g3d_swap_buffers;
   gdrv->base.API.CopyBuffers = egl_g3d_copy_buffers;
   gdrv->base.API.WaitClient = egl_g3d_wait_client;
   gdrv->base.API.WaitNative = egl_g3d_wait_native;
a612 12
   gdrv->base.API.BindTexImage = egl_g3d_bind_tex_image;
   gdrv->base.API.ReleaseTexImage = egl_g3d_release_tex_image;

   gdrv->base.API.CreateImageKHR = egl_g3d_create_image;
   gdrv->base.API.DestroyImageKHR = egl_g3d_destroy_image;

#ifdef EGL_MESA_screen_surface
   gdrv->base.API.CreateScreenSurfaceMESA = egl_g3d_create_screen_surface;
   gdrv->base.API.ShowScreenSurfaceMESA = egl_g3d_show_screen_surface;
#endif

   gdrv->base.Name = driver_name;
a613 1
   gdrv->base.Unload = egl_g3d_unload;
d615 3
a617 2
   /* the key is " EGL G3D" */
   gdrv->probe_key = 0x0E61063D;
d620 7
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
d25 7
d34 1
d37 1
a37 5
#include "pipe/p_screen.h"
#include "util/u_memory.h"
#include "util/u_format.h"
#include "util/u_string.h"

d39 2
a40 4
#include "egl_g3d_api.h"
#include "egl_g3d_st.h"
#include "egl_g3d_loader.h"
#include "native.h"
d43 1
a43 1
 * Get the native platform.
d45 2
a46 2
static const struct native_platform *
egl_g3d_get_platform(_EGLDriver *drv, _EGLPlatformType plat)
d48 10
a57 1
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
d59 15
a73 31
   if (!gdrv->platforms[plat]) {
      const char *plat_name = NULL;
      const struct native_platform *nplat = NULL;

      switch (plat) {
      case _EGL_PLATFORM_WINDOWS:
         plat_name = "Windows";
#ifdef HAVE_GDI_BACKEND
         nplat = native_get_gdi_platform();
#endif
         break;
      case _EGL_PLATFORM_X11:
         plat_name = "X11";
#ifdef HAVE_X11_BACKEND
         nplat = native_get_x11_platform();
#endif
         break;
      case _EGL_PLATFORM_DRM:
         plat_name = "DRM";
#ifdef HAVE_DRM_BACKEND
         nplat = native_get_drm_platform();
#endif
         break;
      case _EGL_PLATFORM_FBDEV:
         plat_name = "FBDEV";
#ifdef HAVE_FBDEV_BACKEND
         nplat = native_get_fbdev_platform();
#endif
         break;
      default:
         break;
d76 9
a84 2
      if (!nplat)
         _eglLog(_EGL_WARNING, "unsupported platform %s", plat_name);
d86 2
a87 2
      gdrv->platforms[plat] = nplat;
   }
d89 13
a101 2
   return gdrv->platforms[plat];
}
d103 2
a104 1
#ifdef EGL_MESA_screen_surface
d106 4
a109 6
static void
egl_g3d_add_screens(_EGLDriver *drv, _EGLDisplay *dpy)
{
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   const struct native_connector **native_connectors;
   EGLint num_connectors, i;
d111 2
a112 6
   native_connectors =
      gdpy->native->modeset->get_connectors(gdpy->native, &num_connectors, NULL);
   if (!num_connectors) {
      if (native_connectors)
         FREE(native_connectors);
      return;
d115 1
a115 5
   for (i = 0; i < num_connectors; i++) {
      const struct native_connector *nconn = native_connectors[i];
      struct egl_g3d_screen *gscr;
      const struct native_mode **native_modes;
      EGLint num_modes, j;
d117 1
a117 8
      /* TODO support for hotplug */
      native_modes =
         gdpy->native->modeset->get_modes(gdpy->native, nconn, &num_modes);
      if (!num_modes) {
         if (native_modes)
            FREE(native_modes);
         continue;
      }
d119 15
a133 5
      gscr = CALLOC_STRUCT(egl_g3d_screen);
      if (!gscr) {
         FREE(native_modes);
         continue;
      }
d135 8
a142 4
      _eglInitScreen(&gscr->base, dpy, num_modes);
      for (j = 0; j < gscr->base.NumModes; j++) {
         const struct native_mode *nmode = native_modes[j];
         _EGLMode *mode = &gscr->base.Modes[j];
d144 12
a155 7
         mode->Width = nmode->width;
         mode->Height = nmode->height;
         mode->RefreshRate = nmode->refresh_rate;
         mode->Optimal = EGL_FALSE;
         mode->Interlaced = EGL_FALSE;
         /* no need to strdup() */
         mode->Name = nmode->desc;
d158 1
a158 2
      gscr->native = nconn;
      gscr->native_modes = native_modes;
d160 18
a177 1
      _eglLinkScreen(&gscr->base);
a178 2

   FREE(native_connectors);
a180 2
#endif /* EGL_MESA_screen_surface */

d182 1
a182 1
 * Initialize and validate the EGL config attributes.
d185 1
a185 3
init_config_attributes(_EGLConfig *conf, const struct native_config *nconf,
                       EGLint api_mask, enum pipe_format depth_stencil_format,
                       EGLBoolean preserve_buffer, EGLint max_swap_interval)
d187 15
a201 3
   uint rgba[4], depth_stencil[2], buffer_size;
   EGLint surface_type;
   EGLint i;
d203 3
a205 13
   /* get the color and depth/stencil component sizes */
   assert(nconf->color_format != PIPE_FORMAT_NONE);
   buffer_size = 0;
   for (i = 0; i < 4; i++) {
      rgba[i] = util_format_get_component_bits(nconf->color_format,
            UTIL_FORMAT_COLORSPACE_RGB, i);
      buffer_size += rgba[i];
   }
   for (i = 0; i < 2; i++) {
      if (depth_stencil_format != PIPE_FORMAT_NONE) {
         depth_stencil[i] =
            util_format_get_component_bits(depth_stencil_format,
               UTIL_FORMAT_COLORSPACE_ZS, i);
d208 6
a213 1
         depth_stencil[i] = 0;
d217 25
a241 9
   surface_type = 0x0;
   if (nconf->window_bit)
      surface_type |= EGL_WINDOW_BIT;
   if (nconf->pixmap_bit)
      surface_type |= EGL_PIXMAP_BIT;
#ifdef EGL_MESA_screen_surface
   if (nconf->scanout_bit)
      surface_type |= EGL_SCREEN_BIT_MESA;
#endif
d243 2
a244 2
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_LEFT))
      surface_type |= EGL_PBUFFER_BIT;
d246 2
a247 2
   conf->Conformant = api_mask;
   conf->RenderableType = api_mask;
d249 9
a257 5
   conf->RedSize = rgba[0];
   conf->GreenSize = rgba[1];
   conf->BlueSize = rgba[2];
   conf->AlphaSize = rgba[3];
   conf->BufferSize = buffer_size;
d259 25
a283 2
   conf->DepthSize = depth_stencil[0];
   conf->StencilSize = depth_stencil[1];
d285 3
a287 1
   conf->SurfaceType = surface_type;
d289 8
a296 5
   conf->NativeRenderable = EGL_TRUE;
   if (surface_type & EGL_WINDOW_BIT) {
      conf->NativeVisualID = nconf->native_visual_id;
      conf->NativeVisualType = nconf->native_visual_type;
   }
d298 3
a300 4
   if (surface_type & EGL_PBUFFER_BIT) {
      conf->BindToTextureRGB = EGL_TRUE;
      if (rgba[3])
         conf->BindToTextureRGBA = EGL_TRUE;
d302 4
a305 3
      conf->MaxPbufferWidth = 4096;
      conf->MaxPbufferHeight = 4096;
      conf->MaxPbufferPixels = 4096 * 4096;
d308 5
a312 3
   conf->Level = nconf->level;
   conf->Samples = nconf->samples;
   conf->SampleBuffers = 0;
d314 10
a323 2
   if (nconf->slow_config)
      conf->ConfigCaveat = EGL_SLOW_CONFIG;
d325 6
a330 5
   if (nconf->transparent_rgb) {
      conf->TransparentType = EGL_TRANSPARENT_RGB;
      conf->TransparentRedValue = nconf->transparent_rgb_values[0];
      conf->TransparentGreenValue = nconf->transparent_rgb_values[1];
      conf->TransparentBlueValue = nconf->transparent_rgb_values[2];
d333 13
a345 4
   conf->MinSwapInterval = 0;
   conf->MaxSwapInterval = max_swap_interval;
   if (preserve_buffer)
      conf->SurfaceType |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT;
d347 5
a351 1
   return _eglValidateConfig(conf, EGL_FALSE);
d355 4
a358 1
 * Initialize an EGL config from the native config.
d360 2
a361 5
static EGLBoolean
egl_g3d_init_config(_EGLDriver *drv, _EGLDisplay *dpy,
                    _EGLConfig *conf, const struct native_config *nconf,
                    enum pipe_format depth_stencil_format,
                    int preserve_buffer, int max_swap_interval)
d363 1
a363 3
   struct egl_g3d_config *gconf = egl_g3d_config(conf);
   EGLint buffer_mask, api_mask;
   EGLBoolean valid;
d365 7
a371 3
   /* skip single-buffered configs */
   if (!(nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_LEFT)))
      return EGL_FALSE;
d373 5
a377 36
   buffer_mask = 0x0;
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_FRONT_LEFT))
      buffer_mask |= ST_ATTACHMENT_FRONT_LEFT_MASK;
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_LEFT))
      buffer_mask |= ST_ATTACHMENT_BACK_LEFT_MASK;
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_FRONT_RIGHT))
      buffer_mask |= ST_ATTACHMENT_FRONT_RIGHT_MASK;
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_RIGHT))
      buffer_mask |= ST_ATTACHMENT_BACK_RIGHT_MASK;

   gconf->stvis.buffer_mask = buffer_mask;
   gconf->stvis.color_format = nconf->color_format;
   gconf->stvis.depth_stencil_format = depth_stencil_format;
   gconf->stvis.accum_format = PIPE_FORMAT_NONE;
   gconf->stvis.samples = nconf->samples;

   gconf->stvis.render_buffer = (buffer_mask & ST_ATTACHMENT_BACK_LEFT_MASK) ?
      ST_ATTACHMENT_BACK_LEFT : ST_ATTACHMENT_FRONT_LEFT;

   api_mask = dpy->ClientAPIsMask;
   /* this is required by EGL, not by OpenGL ES */
   if (nconf->window_bit &&
       gconf->stvis.render_buffer != ST_ATTACHMENT_BACK_LEFT)
      api_mask &= ~(EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT);

   if (!api_mask) {
      _eglLog(_EGL_DEBUG, "no state tracker supports config 0x%x",
            nconf->native_visual_id);
   }

   valid = init_config_attributes(&gconf->base,
         nconf, api_mask, depth_stencil_format,
         preserve_buffer, max_swap_interval);
   if (!valid) {
      _eglLog(_EGL_DEBUG, "skip invalid config 0x%x", nconf->native_visual_id);
      return EGL_FALSE;
d380 2
a381 1
   gconf->native = nconf;
d383 1
a383 2
   return EGL_TRUE;
}
d385 2
a386 6
/**
 * Get all interested depth/stencil formats of a display.
 */
static EGLint
egl_g3d_fill_depth_stencil_formats(_EGLDisplay *dpy,
                                   enum pipe_format formats[8])
d389 31
a419 10
   struct pipe_screen *screen = gdpy->native->screen;
   const EGLint candidates[] = {
      1, PIPE_FORMAT_Z16_UNORM,
      1, PIPE_FORMAT_Z32_UNORM,
      2, PIPE_FORMAT_Z24_UNORM_S8_USCALED, PIPE_FORMAT_S8_USCALED_Z24_UNORM,
      2, PIPE_FORMAT_Z24X8_UNORM, PIPE_FORMAT_X8Z24_UNORM,
      0
   };
   const EGLint *fmt = candidates;
   EGLint count;
d421 1
a421 2
   count = 0;
   formats[count++] = PIPE_FORMAT_NONE;
d423 3
a425 2
   while (*fmt) {
      EGLint i, n = *fmt++;
d427 3
a429 5
      /* pick the first supported format */
      for (i = 0; i < n; i++) {
         if (screen->is_format_supported(screen, fmt[i],
                  PIPE_TEXTURE_2D, 0, PIPE_BIND_DEPTH_STENCIL, 0)) {
            formats[count++] = fmt[i];
d431 2
a432 1
         }
d435 4
a438 1
      fmt += n;
d441 1
a441 1
   return count;
d444 2
d452 1
d455 1
a455 3
   enum pipe_format depth_stencil_formats[8];
   int num_formats, num_configs, i, j;
   int preserve_buffer, max_swap_interval;
d457 2
a458 1
   native_configs = gdpy->native->get_configs(gdpy->native, &num_configs);
d461 1
a461 1
         FREE(native_configs);
d465 4
a468 4
   preserve_buffer =
      gdpy->native->get_param(gdpy->native, NATIVE_PARAM_PRESERVE_BUFFER);
   max_swap_interval =
      gdpy->native->get_param(gdpy->native, NATIVE_PARAM_MAX_SWAP_INTERVAL);
d470 3
a472 2
   num_formats = egl_g3d_fill_depth_stencil_formats(dpy,
         depth_stencil_formats);
d474 1
a474 3
   for (i = 0; i < num_configs; i++) {
      for (j = 0; j < num_formats; j++) {
         struct egl_g3d_config *gconf;
d476 5
a480 9
         gconf = CALLOC_STRUCT(egl_g3d_config);
         if (gconf) {
            _eglInitConfig(&gconf->base, dpy, id);
            if (!egl_g3d_init_config(drv, dpy, &gconf->base,
                     native_configs[i], depth_stencil_formats[j],
                     preserve_buffer, max_swap_interval)) {
               FREE(gconf);
               break;
            }
d482 9
a490 2
            _eglLinkConfig(&gconf->base);
            id++;
d492 2
d495 10
d507 1
a507 1
   FREE(native_configs);
d511 24
d542 3
a544 7
   struct egl_g3d_context *gctx;
   
   /*
    * Some functions such as egl_g3d_copy_buffers create a temporary native
    * surface.  There is no gsurf associated with it.
    */
   gctx = (gsurf) ? egl_g3d_context(gsurf->base.CurrentContext) : NULL;
d546 1
a546 17
      gctx->stctxi->notify_invalid_framebuffer(gctx->stctxi, gsurf->stfbi);
}

static struct pipe_screen *
egl_g3d_new_drm_screen(struct native_display *ndpy, const char *name, int fd)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   return gdpy->loader->create_drm_screen(name, fd);
}

static struct pipe_screen *
egl_g3d_new_sw_screen(struct native_display *ndpy, struct sw_winsys *ws)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   return gdpy->loader->create_sw_screen(ws);
d550 1
a550 3
   egl_g3d_invalid_surface,
   egl_g3d_new_drm_screen,
   egl_g3d_new_sw_screen
a552 17
static void
egl_g3d_free_config(void *conf)
{
   struct egl_g3d_config *gconf = egl_g3d_config((_EGLConfig *) conf);
   FREE(gconf);
}

static void
egl_g3d_free_screen(void *scr)
{
#ifdef EGL_MESA_screen_surface
   struct egl_g3d_screen *gscr = egl_g3d_screen((_EGLScreen *) scr);
   FREE(gscr->native_modes);
   FREE(gscr);
#endif
}

d557 1
d560 1
a561 7
   if (gdpy->pipe)
      gdpy->pipe->destroy(gdpy->pipe);

   if (dpy->Configs) {
      _eglDestroyArray(dpy->Configs, egl_g3d_free_config);
      dpy->Configs = NULL;
   }
d563 6
a568 2
      _eglDestroyArray(dpy->Screens, egl_g3d_free_screen);
      dpy->Screens = NULL;
a570 5
   _eglCleanupDisplay(dpy);

   if (gdpy->smapi)
      egl_g3d_destroy_st_manager(gdpy->smapi);

d574 1
a574 1
   FREE(gdpy);
a585 1
   const struct native_platform *nplat;
d587 2
a588 3
   nplat = egl_g3d_get_platform(drv, dpy->Platform);
   if (!nplat)
      return EGL_FALSE;
a594 1
   gdpy->loader = gdrv->loader;
d597 2
a598 3
   _eglLog(_EGL_INFO, "use %s for display %p", nplat->name, dpy->PlatformDisplay);
   gdpy->native = nplat->create_display(dpy->PlatformDisplay,
         &egl_g3d_native_event_handler, (void *) dpy);
d604 6
a609 15
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_DEFAULT_MASK)
      dpy->ClientAPIsMask |= EGL_OPENGL_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_OPENGL_ES1_MASK)
      dpy->ClientAPIsMask |= EGL_OPENGL_ES_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_OPENGL_ES2_MASK)
      dpy->ClientAPIsMask |= EGL_OPENGL_ES2_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENVG] & ST_PROFILE_DEFAULT_MASK)
      dpy->ClientAPIsMask |= EGL_OPENVG_BIT;

   gdpy->smapi = egl_g3d_create_st_manager(dpy);
   if (!gdpy->smapi) {
      _eglError(EGL_NOT_INITIALIZED,
            "eglInitialize(failed to create st manager)");
      goto fail;
   }
a622 13
   dpy->Extensions.KHR_reusable_sync = EGL_TRUE;
   dpy->Extensions.KHR_fence_sync = EGL_TRUE;

   dpy->Extensions.KHR_surfaceless_gles1 = EGL_TRUE;
   dpy->Extensions.KHR_surfaceless_gles2 = EGL_TRUE;
   dpy->Extensions.KHR_surfaceless_opengl = EGL_TRUE;

   if (dpy->Platform == _EGL_PLATFORM_DRM) {
      dpy->Extensions.MESA_drm_display = EGL_TRUE;
      if (gdpy->native->buffer)
         dpy->Extensions.MESA_drm_image = EGL_TRUE;
   }

d639 443
d1086 2
a1087 1
   struct st_api *stapi = NULL;
d1089 11
a1099 4
   if (procname && procname[0] == 'v' && procname[1] == 'g')
      stapi = gdrv->loader->get_st_api(ST_API_OPENVG);
   else if (procname && procname[0] == 'g' && procname[1] == 'l')
      stapi = gdrv->loader->get_st_api(ST_API_OPENGL);
d1101 1
a1101 2
   return (_EGLProc) ((stapi) ?
         stapi->get_proc_address(stapi, procname) : NULL);
d1104 155
d1262 33
a1294 1
   return (egl_g3d_get_platform(drv, dpy->Platform)) ? 90 : 0;
d1298 1
a1298 1
egl_g3d_create_driver(const struct egl_g3d_loader *loader)
d1300 1
d1303 3
d1310 1
a1310 1
   gdrv->loader = loader;
a1311 1
   egl_g3d_init_driver_api(&gdrv->base);
d1314 11
d1327 12
d1340 1
d1342 2
a1343 3
   /* to be filled by the caller */
   gdrv->base.Name = NULL;
   gdrv->base.Unload = NULL;
a1345 7
}

void
egl_g3d_destroy_driver(_EGLDriver *drv)
{
   struct egl_g3d_driver *gdrv = egl_g3d_driver(drv);
   FREE(gdrv);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
a33 1
#include "util/u_atomic.h"
a40 50
static void
egl_g3d_invalid_surface(struct native_display *ndpy,
                        struct native_surface *nsurf,
                        unsigned int seq_num)
{
   /* XXX not thread safe? */
   struct egl_g3d_surface *gsurf = egl_g3d_surface(nsurf->user_data);

   if (gsurf && gsurf->stfbi)
      p_atomic_inc(&gsurf->stfbi->stamp);
}

static struct pipe_screen *
egl_g3d_new_drm_screen(struct native_display *ndpy, const char *name, int fd)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   return gdpy->loader->create_drm_screen(name, fd);
}

static struct pipe_screen *
egl_g3d_new_sw_screen(struct native_display *ndpy, struct sw_winsys *ws)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   return gdpy->loader->create_sw_screen(ws);
}

static struct pipe_resource *
egl_g3d_lookup_egl_image(struct native_display *ndpy, void *egl_image)
{
   _EGLDisplay *dpy = (_EGLDisplay *) ndpy->user_data;
   struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
   struct st_egl_image img;
   struct pipe_resource *resource = NULL;

   memset(&img, 0, sizeof(img));
   if (gdpy->smapi->get_egl_image(gdpy->smapi, egl_image, &img))
      resource = img.texture;

   return resource;
}

static const struct native_event_handler egl_g3d_native_event_handler = {
   egl_g3d_invalid_surface,
   egl_g3d_new_drm_screen,
   egl_g3d_new_sw_screen,
   egl_g3d_lookup_egl_image
};

d57 1
a57 1
         nplat = native_get_gdi_platform(&egl_g3d_native_event_handler);
d63 1
a63 7
         nplat = native_get_x11_platform(&egl_g3d_native_event_handler);
#endif
	 break;
      case _EGL_PLATFORM_WAYLAND:
         plat_name = "wayland";
#ifdef HAVE_WAYLAND_BACKEND
         nplat = native_get_wayland_platform(&egl_g3d_native_event_handler);
d69 1
a69 1
         nplat = native_get_drm_platform(&egl_g3d_native_event_handler);
d75 1
a75 13
         nplat = native_get_fbdev_platform(&egl_g3d_native_event_handler);
#endif
         break;
      case _EGL_PLATFORM_NULL:
         plat_name = "NULL";
#ifdef HAVE_NULL_BACKEND
         nplat = native_get_null_platform(&egl_g3d_native_event_handler);
#endif
         break;
      case _EGL_PLATFORM_ANDROID:
         plat_name = "Android";
#ifdef HAVE_ANDROID_BACKEND
         nplat = native_get_android_platform(&egl_g3d_native_event_handler);
d103 2
a104 1
      FREE(native_connectors);
d118 2
a119 1
         FREE(native_modes);
d160 1
a160 2
                       EGLint preserve_buffer, EGLint max_swap_interval,
                       EGLBoolean pre_alpha)
d186 4
a189 9
   /* pixmap surfaces should be EGL_SINGLE_BUFFER */
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_FRONT_LEFT)) {
      if (nconf->pixmap_bit)
         surface_type |= EGL_PIXMAP_BIT;
   }
   /* the others surfaces should be EGL_BACK_BUFFER (or settable) */
   if (nconf->buffer_mask & (1 << NATIVE_ATTACHMENT_BACK_LEFT)) {
      if (nconf->window_bit)
         surface_type |= EGL_WINDOW_BIT;
d191 2
a192 2
      if (nconf->scanout_bit)
         surface_type |= EGL_SCREEN_BIT_MESA;
d194 2
a196 10
   }

   if (preserve_buffer)
      surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT;

   if (pre_alpha && rgba[3]) {
      surface_type |= EGL_VG_ALPHA_FORMAT_PRE_BIT;
      /* st/vega does not support premultiplied alpha yet */
      api_mask &= ~EGL_OPENVG_BIT;
   }
a209 4
   /* st/vega will allocate the mask on demand */
   if (api_mask & EGL_OPENVG_BIT)
      conf->AlphaMaskSize = 8;

d229 5
d244 2
d257 1
a257 2
                    int preserve_buffer, int max_swap_interval,
                    int pre_alpha)
d260 1
a260 1
   EGLint buffer_mask;
d263 4
d281 1
a281 1
   gconf->stvis.samples = 0;
a282 1
   /* will be overridden per surface */
d286 11
d298 2
a299 2
         nconf, dpy->ClientAPIs, depth_stencil_format,
         preserve_buffer, max_swap_interval, pre_alpha);
d322 1
a322 1
      2, PIPE_FORMAT_Z24_UNORM_S8_UINT, PIPE_FORMAT_S8_UINT_Z24_UNORM,
d338 1
a338 1
                  PIPE_TEXTURE_2D, 0, PIPE_BIND_DEPTH_STENCIL)) {
d360 1
a360 1
   int preserve_buffer, max_swap_interval, premultiplied_alpha;
d364 2
a365 1
      FREE(native_configs);
a372 2
   premultiplied_alpha =
      gdpy->native->get_param(gdpy->native, NATIVE_PARAM_PREMULTIPLIED_ALPHA);
d386 1
a386 2
                     preserve_buffer, max_swap_interval,
                     premultiplied_alpha)) {
d402 40
d465 3
d492 2
a493 1
egl_g3d_initialize(_EGLDriver *drv, _EGLDisplay *dpy)
a502 3
   if (dpy->Options.TestOnly)
      return EGL_TRUE;

d511 3
a513 4
   _eglLog(_EGL_INFO, "use %s for display %p",
         nplat->name, dpy->PlatformDisplay);
   gdpy->native =
      nplat->create_display(dpy->PlatformDisplay, dpy->Options.UseFallback);
a517 6
   gdpy->native->user_data = (void *) dpy;
   if (!gdpy->native->init_screen(gdpy->native)) {
      _eglError(EGL_NOT_INITIALIZED,
            "eglInitialize(failed to initialize screen)");
      goto fail;
   }
d520 1
a520 1
      dpy->ClientAPIs |= EGL_OPENGL_BIT;
d522 1
a522 1
      dpy->ClientAPIs |= EGL_OPENGL_ES_BIT;
d524 1
a524 1
      dpy->ClientAPIs |= EGL_OPENGL_ES2_BIT;
d526 1
a526 1
      dpy->ClientAPIs |= EGL_OPENVG_BIT;
d550 3
a552 1
   dpy->Extensions.KHR_surfaceless_context = EGL_TRUE;
a559 21
   if (dpy->Platform == _EGL_PLATFORM_WAYLAND && gdpy->native->buffer)
      dpy->Extensions.MESA_drm_image = EGL_TRUE;

#ifdef EGL_ANDROID_image_native_buffer
   if (dpy->Platform == _EGL_PLATFORM_ANDROID && gdpy->native->buffer)
      dpy->Extensions.ANDROID_image_native_buffer = EGL_TRUE;
#endif

#ifdef EGL_WL_bind_wayland_display
   if (gdpy->native->wayland_bufmgr)
      dpy->Extensions.WL_bind_wayland_display = EGL_TRUE;
#endif

   if (gdpy->native->get_param(gdpy->native, NATIVE_PARAM_PRESENT_REGION) &&
       gdpy->native->get_param(gdpy->native, NATIVE_PARAM_PRESERVE_BUFFER)) {
#ifdef EGL_NOK_swap_region
      dpy->Extensions.NOK_swap_region = EGL_TRUE;
#endif
      dpy->Extensions.NV_post_sub_buffer = EGL_TRUE;
   }

d565 2
a566 2
   dpy->VersionMajor = 1;
   dpy->VersionMinor = 4;
d591 6
d612 2
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d551 8
a558 12
#if FEATURE_GL
   dpy->ClientAPIs |= EGL_OPENGL_BIT;
#endif
#if FEATURE_ES1
   dpy->ClientAPIs |= EGL_OPENGL_ES_BIT;
#endif
#if FEATURE_ES2
   dpy->ClientAPIs |= EGL_OPENGL_ES2_BIT;
#endif
#if FEATURE_VG
   dpy->ClientAPIs |= EGL_OPENVG_BIT;
#endif
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d551 12
a562 8
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_DEFAULT_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_OPENGL_ES1_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_ES_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENGL] & ST_PROFILE_OPENGL_ES2_MASK)
      dpy->ClientAPIs |= EGL_OPENGL_ES2_BIT;
   if (gdpy->loader->profile_masks[ST_API_OPENVG] & ST_PROFILE_DEFAULT_MASK)
      dpy->ClientAPIs |= EGL_OPENVG_BIT;
@


