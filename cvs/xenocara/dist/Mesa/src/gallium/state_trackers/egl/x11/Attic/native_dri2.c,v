head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.37;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.14.01.47;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.16;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.11.24.05.57.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.19;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2009-2010 Chia-I Wu <olv@@0xlab.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_format.h"
#include "util/u_inlines.h"
#include "util/u_hash_table.h"
#include "pipe/p_compiler.h"
#include "pipe/p_screen.h"
#include "pipe/p_context.h"
#include "pipe/p_state.h"
#include "state_tracker/drm_driver.h"
#include "egllog.h"

#include "native_x11.h"
#include "x11_screen.h"

#include "common/native_helper.h"
#ifdef HAVE_WAYLAND_BACKEND
#include "common/native_wayland_drm_bufmgr.h"
#endif

#ifdef GLX_DIRECT_RENDERING

struct dri2_display {
   struct native_display base;
   Display *dpy;
   boolean own_dpy;

   const struct native_event_handler *event_handler;

   struct x11_screen *xscr;
   int xscr_number;
   const char *dri_driver;
   int dri_major, dri_minor;

   struct dri2_config *configs;
   int num_configs;

   struct util_hash_table *surfaces;
};

struct dri2_surface {
   struct native_surface base;
   Drawable drawable;
   enum pipe_format color_format;
   struct dri2_display *dri2dpy;

   unsigned int server_stamp;
   unsigned int client_stamp;
   int width, height;
   struct pipe_resource *textures[NUM_NATIVE_ATTACHMENTS];
   uint valid_mask;

   boolean have_back, have_fake;

   struct x11_drawable_buffer *last_xbufs;
   int last_num_xbufs;
};

struct dri2_config {
   struct native_config base;
};

static INLINE struct dri2_display *
dri2_display(const struct native_display *ndpy)
{
   return (struct dri2_display *) ndpy;
}

static INLINE struct dri2_surface *
dri2_surface(const struct native_surface *nsurf)
{
   return (struct dri2_surface *) nsurf;
}

static INLINE struct dri2_config *
dri2_config(const struct native_config *nconf)
{
   return (struct dri2_config *) nconf;
}

/**
 * Process the buffers returned by the server.
 */
static void
dri2_surface_process_drawable_buffers(struct native_surface *nsurf,
                                      struct x11_drawable_buffer *xbufs,
                                      int num_xbufs)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);
   struct dri2_display *dri2dpy = dri2surf->dri2dpy;
   struct pipe_resource templ;
   struct winsys_handle whandle;
   uint valid_mask;
   int i;

   /* free the old textures */
   for (i = 0; i < NUM_NATIVE_ATTACHMENTS; i++)
      pipe_resource_reference(&dri2surf->textures[i], NULL);
   dri2surf->valid_mask = 0x0;

   dri2surf->have_back = FALSE;
   dri2surf->have_fake = FALSE;

   if (!xbufs)
      return;

   memset(&templ, 0, sizeof(templ));
   templ.target = PIPE_TEXTURE_2D;
   templ.last_level = 0;
   templ.width0 = dri2surf->width;
   templ.height0 = dri2surf->height;
   templ.depth0 = 1;
   templ.array_size = 1;
   templ.format = dri2surf->color_format;
   templ.bind = PIPE_BIND_RENDER_TARGET;

   valid_mask = 0x0;
   for (i = 0; i < num_xbufs; i++) {
      struct x11_drawable_buffer *xbuf = &xbufs[i];
      const char *desc;
      enum native_attachment natt;

      switch (xbuf->attachment) {
      case DRI2BufferFrontLeft:
         natt = NATIVE_ATTACHMENT_FRONT_LEFT;
         desc = "DRI2 Front Buffer";
         break;
      case DRI2BufferFakeFrontLeft:
         natt = NATIVE_ATTACHMENT_FRONT_LEFT;
         desc = "DRI2 Fake Front Buffer";
         dri2surf->have_fake = TRUE;
         break;
      case DRI2BufferBackLeft:
         natt = NATIVE_ATTACHMENT_BACK_LEFT;
         desc = "DRI2 Back Buffer";
         dri2surf->have_back = TRUE;
         break;
      default:
         desc = NULL;
         break;
      }

      if (!desc || dri2surf->textures[natt]) {
         if (!desc)
            _eglLog(_EGL_WARNING, "unknown buffer %d", xbuf->attachment);
         else
            _eglLog(_EGL_WARNING, "both real and fake front buffers are listed");
         continue;
      }

      memset(&whandle, 0, sizeof(whandle));
      whandle.type = DRM_API_HANDLE_TYPE_SHARED;
      whandle.stride = xbuf->pitch;
      whandle.handle = xbuf->name;
      dri2surf->textures[natt] = dri2dpy->base.screen->resource_from_handle(
         dri2dpy->base.screen, &templ, &whandle);
      if (dri2surf->textures[natt])
         valid_mask |= 1 << natt;
   }

   dri2surf->valid_mask = valid_mask;
}

/**
 * Get the buffers from the server.
 */
static void
dri2_surface_get_buffers(struct native_surface *nsurf, uint buffer_mask)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);
   struct dri2_display *dri2dpy = dri2surf->dri2dpy;
   unsigned int dri2atts[NUM_NATIVE_ATTACHMENTS * 2];
   int num_ins, num_outs, att;
   struct x11_drawable_buffer *xbufs;
   uint bpp = util_format_get_blocksizebits(dri2surf->color_format);
   boolean with_format = FALSE; /* never ask for depth/stencil */

   /* We must get the front on servers which doesn't support with format
    * due to a silly bug in core dri2. You can't copy to/from a buffer
    * that you haven't requested and you recive BadValue errors */
   if (dri2surf->dri2dpy->dri_minor < 1) {
      with_format = FALSE;
      buffer_mask |= (1 << NATIVE_ATTACHMENT_FRONT_LEFT);
   }

   /* prepare the attachments */
   num_ins = 0;
   for (att = 0; att < NUM_NATIVE_ATTACHMENTS; att++) {
      if (native_attachment_mask_test(buffer_mask, att)) {
         unsigned int dri2att;

         switch (att) {
         case NATIVE_ATTACHMENT_FRONT_LEFT:
            dri2att = DRI2BufferFrontLeft;
            break;
         case NATIVE_ATTACHMENT_BACK_LEFT:
            dri2att = DRI2BufferBackLeft;
            break;
         case NATIVE_ATTACHMENT_FRONT_RIGHT:
            dri2att = DRI2BufferFrontRight;
            break;
         case NATIVE_ATTACHMENT_BACK_RIGHT:
            dri2att = DRI2BufferBackRight;
            break;
         default:
            assert(0);
            dri2att = 0;
            break;
         }

         dri2atts[num_ins++] = dri2att;
         if (with_format)
            dri2atts[num_ins++] = bpp;
      }
   }
   if (with_format)
      num_ins /= 2;

   xbufs = x11_drawable_get_buffers(dri2dpy->xscr, dri2surf->drawable,
                                    &dri2surf->width, &dri2surf->height,
                                    dri2atts, with_format, num_ins, &num_outs);

   /* we should be able to do better... */
   if (xbufs && dri2surf->last_num_xbufs == num_outs &&
       memcmp(dri2surf->last_xbufs, xbufs, sizeof(*xbufs) * num_outs) == 0) {
      FREE(xbufs);
      dri2surf->client_stamp = dri2surf->server_stamp;
      return;
   }

   dri2_surface_process_drawable_buffers(&dri2surf->base, xbufs, num_outs);

   dri2surf->server_stamp++;
   dri2surf->client_stamp = dri2surf->server_stamp;

   FREE(dri2surf->last_xbufs);
   dri2surf->last_xbufs = xbufs;
   dri2surf->last_num_xbufs = num_outs;
}

/**
 * Update the buffers of the surface.  This is a slow function due to the
 * round-trip to the server.
 */
static boolean
dri2_surface_update_buffers(struct native_surface *nsurf, uint buffer_mask)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);

   dri2_surface_get_buffers(&dri2surf->base, buffer_mask);

   return ((dri2surf->valid_mask & buffer_mask) == buffer_mask);
}

/**
 * Return TRUE if the surface receives DRI2_InvalidateBuffers events.
 */
static INLINE boolean
dri2_surface_receive_events(struct native_surface *nsurf)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);
   return (dri2surf->dri2dpy->dri_minor >= 3);
}

static boolean
dri2_surface_flush_frontbuffer(struct native_surface *nsurf)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);
   struct dri2_display *dri2dpy = dri2surf->dri2dpy;
   struct native_display *ndpy = &dri2dpy->base;
   struct pipe_context *pipe = ndpy_get_copy_context(ndpy);

   /* flush buffer */
   pipe->flush_resource(pipe, dri2surf->textures[NATIVE_ATTACHMENT_FRONT_LEFT]);
   pipe->flush(pipe, NULL, 0);

   /* copy to real front buffer */
   if (dri2surf->have_fake)
      x11_drawable_copy_buffers(dri2dpy->xscr, dri2surf->drawable,
            0, 0, dri2surf->width, dri2surf->height,
            DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft);

   /* force buffers to be updated in next validation call */
   if (!dri2_surface_receive_events(&dri2surf->base)) {
      dri2surf->server_stamp++;
      dri2dpy->event_handler->invalid_surface(&dri2dpy->base,
            &dri2surf->base, dri2surf->server_stamp);
   }

   return TRUE;
}

static boolean
dri2_surface_swap_buffers(struct native_surface *nsurf, int num_rects,
                          const int *rects)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);
   struct dri2_display *dri2dpy = dri2surf->dri2dpy;
   struct native_display *ndpy = &dri2dpy->base;
   struct pipe_context *pipe = ndpy_get_copy_context(ndpy);

   /* copy to front buffer */
   if (dri2surf->have_back) {
      pipe->flush_resource(pipe, dri2surf->textures[NATIVE_ATTACHMENT_BACK_LEFT]);
      pipe->flush(pipe, NULL, 0);

      if (num_rects > 0)
         x11_drawable_copy_buffers_region(dri2dpy->xscr, dri2surf->drawable,
               num_rects, rects,
               DRI2BufferBackLeft, DRI2BufferFrontLeft);
      else
         x11_drawable_copy_buffers(dri2dpy->xscr, dri2surf->drawable,
               0, 0, dri2surf->width, dri2surf->height,
               DRI2BufferBackLeft, DRI2BufferFrontLeft);
   }

   /* and update fake front buffer */
   if (dri2surf->have_fake) {
      if (num_rects > 0)
         x11_drawable_copy_buffers_region(dri2dpy->xscr, dri2surf->drawable,
               num_rects, rects,
               DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
      else
         x11_drawable_copy_buffers(dri2dpy->xscr, dri2surf->drawable,
               0, 0, dri2surf->width, dri2surf->height,
               DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
   }

   /* force buffers to be updated in next validation call */
   if (!dri2_surface_receive_events(&dri2surf->base)) {
      dri2surf->server_stamp++;
      dri2dpy->event_handler->invalid_surface(&dri2dpy->base,
            &dri2surf->base, dri2surf->server_stamp);
   }

   return TRUE;
}

static boolean
dri2_surface_present(struct native_surface *nsurf,
                     const struct native_present_control *ctrl)
{
   boolean ret;

   if (ctrl->swap_interval)
      return FALSE;

   switch (ctrl->natt) {
   case NATIVE_ATTACHMENT_FRONT_LEFT:
      ret = dri2_surface_flush_frontbuffer(nsurf);
      break;
   case NATIVE_ATTACHMENT_BACK_LEFT:
      ret = dri2_surface_swap_buffers(nsurf, ctrl->num_rects, ctrl->rects);
      break;
   default:
      ret = FALSE;
      break;
   }

   return ret;
}

static boolean
dri2_surface_validate(struct native_surface *nsurf, uint attachment_mask,
                      unsigned int *seq_num, struct pipe_resource **textures,
                      int *width, int *height)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);

   if (dri2surf->server_stamp != dri2surf->client_stamp ||
       (dri2surf->valid_mask & attachment_mask) != attachment_mask) {
      if (!dri2_surface_update_buffers(&dri2surf->base, attachment_mask))
         return FALSE;
   }

   if (seq_num)
      *seq_num = dri2surf->client_stamp;

   if (textures) {
      int att;
      for (att = 0; att < NUM_NATIVE_ATTACHMENTS; att++) {
         if (native_attachment_mask_test(attachment_mask, att)) {
            struct pipe_resource *ptex = dri2surf->textures[att];

            textures[att] = NULL;
            pipe_resource_reference(&textures[att], ptex);
         }
      }
   }

   if (width)
      *width = dri2surf->width;
   if (height)
      *height = dri2surf->height;

   return TRUE;
}

static void
dri2_surface_wait(struct native_surface *nsurf)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);
   struct dri2_display *dri2dpy = dri2surf->dri2dpy;

   if (dri2surf->have_fake) {
      x11_drawable_copy_buffers(dri2dpy->xscr, dri2surf->drawable,
            0, 0, dri2surf->width, dri2surf->height,
            DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
   }
}

static void
dri2_surface_destroy(struct native_surface *nsurf)
{
   struct dri2_surface *dri2surf = dri2_surface(nsurf);
   int i;

   FREE(dri2surf->last_xbufs);

   for (i = 0; i < NUM_NATIVE_ATTACHMENTS; i++) {
      struct pipe_resource *ptex = dri2surf->textures[i];
      pipe_resource_reference(&ptex, NULL);
   }

   if (dri2surf->drawable) {
      x11_drawable_enable_dri2(dri2surf->dri2dpy->xscr,
            dri2surf->drawable, FALSE);

      util_hash_table_remove(dri2surf->dri2dpy->surfaces,
            (void *) dri2surf->drawable);
   }
   FREE(dri2surf);
}

static struct dri2_surface *
dri2_display_create_surface(struct native_display *ndpy,
                            Drawable drawable,
                            enum pipe_format color_format)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);
   struct dri2_surface *dri2surf;

   dri2surf = CALLOC_STRUCT(dri2_surface);
   if (!dri2surf)
      return NULL;

   dri2surf->dri2dpy = dri2dpy;
   dri2surf->drawable = drawable;
   dri2surf->color_format = color_format;

   dri2surf->base.destroy = dri2_surface_destroy;
   dri2surf->base.present = dri2_surface_present;
   dri2surf->base.validate = dri2_surface_validate;
   dri2surf->base.wait = dri2_surface_wait;

   if (drawable) {
      x11_drawable_enable_dri2(dri2dpy->xscr, drawable, TRUE);
      /* initialize the geometry */
      dri2_surface_update_buffers(&dri2surf->base, 0x0);

      util_hash_table_set(dri2surf->dri2dpy->surfaces,
            (void *) dri2surf->drawable, (void *) &dri2surf->base);
   }

   return dri2surf;
}

static struct native_surface *
dri2_display_create_window_surface(struct native_display *ndpy,
                                   EGLNativeWindowType win,
                                   const struct native_config *nconf)
{
   struct dri2_surface *dri2surf;

   dri2surf = dri2_display_create_surface(ndpy,
         (Drawable) win, nconf->color_format);
   return (dri2surf) ? &dri2surf->base : NULL;
}

static struct native_surface *
dri2_display_create_pixmap_surface(struct native_display *ndpy,
                                   EGLNativePixmapType pix,
                                   const struct native_config *nconf)
{
   struct dri2_surface *dri2surf;

   if (!nconf) {
      struct dri2_display *dri2dpy = dri2_display(ndpy);
      uint depth, nconf_depth;
      int i;

      depth = x11_drawable_get_depth(dri2dpy->xscr, (Drawable) pix);
      for (i = 0; i < dri2dpy->num_configs; i++) {
         nconf_depth = util_format_get_blocksizebits(
               dri2dpy->configs[i].base.color_format);
         /* simple depth match for now */
         if (depth == nconf_depth ||
             (depth == 24 && depth + 8 == nconf_depth)) {
            nconf = &dri2dpy->configs[i].base;
            break;
         }
      }

      if (!nconf)
         return NULL;
   }

   dri2surf = dri2_display_create_surface(ndpy,
         (Drawable) pix, nconf->color_format);
   return (dri2surf) ? &dri2surf->base : NULL;
}

static int
choose_color_format(const __GLcontextModes *mode, enum pipe_format formats[32])
{
   int count = 0;

   switch (mode->rgbBits) {
   case 32:
      formats[count++] = PIPE_FORMAT_B8G8R8A8_UNORM;
      formats[count++] = PIPE_FORMAT_A8R8G8B8_UNORM;
      break;
   case 24:
      formats[count++] = PIPE_FORMAT_B8G8R8X8_UNORM;
      formats[count++] = PIPE_FORMAT_X8R8G8B8_UNORM;
      formats[count++] = PIPE_FORMAT_B8G8R8A8_UNORM;
      formats[count++] = PIPE_FORMAT_A8R8G8B8_UNORM;
      break;
   case 16:
      formats[count++] = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      break;
   }

   return count;
}

static boolean
is_format_supported(struct pipe_screen *screen,
                    enum pipe_format fmt, unsigned sample_count, boolean is_color)
{
   return screen->is_format_supported(screen, fmt, PIPE_TEXTURE_2D, sample_count,
         (is_color) ? PIPE_BIND_RENDER_TARGET :
         PIPE_BIND_DEPTH_STENCIL);
}

static boolean
dri2_display_convert_config(struct native_display *ndpy,
                            const __GLcontextModes *mode,
                            struct native_config *nconf)
{
   enum pipe_format formats[32];
   int num_formats, i;
   int sample_count = 0;

   if (!(mode->renderType & GLX_RGBA_BIT) || !mode->rgbMode)
      return FALSE;

   /* only interested in native renderable configs */
   if (!mode->xRenderable || !mode->drawableType)
      return FALSE;

   /* fast/slow configs are probably not relevant */
   if (mode->visualRating == GLX_SLOW_CONFIG)
      return FALSE;

   nconf->buffer_mask = 1 << NATIVE_ATTACHMENT_FRONT_LEFT;
   if (mode->doubleBufferMode)
      nconf->buffer_mask |= 1 << NATIVE_ATTACHMENT_BACK_LEFT;
   if (mode->stereoMode) {
      nconf->buffer_mask |= 1 << NATIVE_ATTACHMENT_FRONT_RIGHT;
      if (mode->doubleBufferMode)
         nconf->buffer_mask |= 1 << NATIVE_ATTACHMENT_BACK_RIGHT;
   }

   /* choose color format */
   num_formats = choose_color_format(mode, formats);
   for (i = 0; i < num_formats; i++) {
      if (is_format_supported(ndpy->screen, formats[i], sample_count, TRUE)) {
         nconf->color_format = formats[i];
         break;
      }
   }
   if (nconf->color_format == PIPE_FORMAT_NONE)
      return FALSE;

   if ((mode->drawableType & GLX_WINDOW_BIT) && mode->visualID)
      nconf->window_bit = TRUE;
   if (mode->drawableType & GLX_PIXMAP_BIT)
      nconf->pixmap_bit = TRUE;

   nconf->native_visual_id = mode->visualID;
   switch (mode->visualType) {
   case GLX_TRUE_COLOR:
      nconf->native_visual_type = TrueColor;
      break;
   case GLX_DIRECT_COLOR:
      nconf->native_visual_type = DirectColor;
      break;
   case GLX_PSEUDO_COLOR:
      nconf->native_visual_type = PseudoColor;
      break;
   case GLX_STATIC_COLOR:
      nconf->native_visual_type = StaticColor;
      break;
   case GLX_GRAY_SCALE:
      nconf->native_visual_type = GrayScale;
      break;
   case GLX_STATIC_GRAY:
      nconf->native_visual_type = StaticGray;
      break;
   }
   nconf->level = mode->level;

   if (mode->transparentPixel == GLX_TRANSPARENT_RGB) {
      nconf->transparent_rgb = TRUE;
      nconf->transparent_rgb_values[0] = mode->transparentRed;
      nconf->transparent_rgb_values[1] = mode->transparentGreen;
      nconf->transparent_rgb_values[2] = mode->transparentBlue;
   }

   return TRUE;
}

static const struct native_config **
dri2_display_get_configs(struct native_display *ndpy, int *num_configs)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);
   const struct native_config **configs;
   int i;

   /* first time */
   if (!dri2dpy->configs) {
      const __GLcontextModes *modes;
      int num_modes, count;

      modes = x11_screen_get_glx_configs(dri2dpy->xscr);
      if (!modes)
         return NULL;
      num_modes = x11_context_modes_count(modes);

      dri2dpy->configs = CALLOC(num_modes, sizeof(*dri2dpy->configs));
      if (!dri2dpy->configs)
         return NULL;

      count = 0;
      for (i = 0; i < num_modes; i++) {
         struct native_config *nconf = &dri2dpy->configs[count].base;

         if (dri2_display_convert_config(&dri2dpy->base, modes, nconf)) {
            int j;
            /* look for duplicates */
            for (j = 0; j < count; j++) {
               if (memcmp(&dri2dpy->configs[j], nconf, sizeof(*nconf)) == 0)
                  break;
            }
            if (j == count)
               count++;
         }
         modes = modes->next;
      }

      dri2dpy->num_configs = count;
   }

   configs = MALLOC(dri2dpy->num_configs * sizeof(*configs));
   if (configs) {
      for (i = 0; i < dri2dpy->num_configs; i++)
         configs[i] = (const struct native_config *) &dri2dpy->configs[i];
      if (num_configs)
         *num_configs = dri2dpy->num_configs;
   }

   return configs;
}

static boolean
dri2_display_get_pixmap_format(struct native_display *ndpy,
                               EGLNativePixmapType pix,
                               enum pipe_format *format)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);
   boolean ret = EGL_TRUE;
   uint depth;

   depth = x11_drawable_get_depth(dri2dpy->xscr, (Drawable) pix);
   switch (depth) {
   case 32:
   case 24:
      *format = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   case 16:
      *format = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      *format = PIPE_FORMAT_NONE;
      ret = EGL_FALSE;
      break;
   }

   return ret;
}

static int
dri2_display_get_param(struct native_display *ndpy,
                       enum native_param_type param)
{
   int val;

   switch (param) {
   case NATIVE_PARAM_USE_NATIVE_BUFFER:
      /* DRI2GetBuffers uses the native buffers */
      val = TRUE;
      break;
   case NATIVE_PARAM_PRESERVE_BUFFER:
      /* DRI2CopyRegion is used */
      val = TRUE;
      break;
   case NATIVE_PARAM_PRESENT_REGION:
      val = TRUE;
      break;
   case NATIVE_PARAM_MAX_SWAP_INTERVAL:
   default:
      val = 0;
      break;
   }

   return val;
}

static void
dri2_display_destroy(struct native_display *ndpy)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   FREE(dri2dpy->configs);

   if (dri2dpy->base.screen)
      dri2dpy->base.screen->destroy(dri2dpy->base.screen);

   if (dri2dpy->surfaces)
      util_hash_table_destroy(dri2dpy->surfaces);

#ifdef HAVE_WAYLAND_BACKEND
   wayland_drm_bufmgr_destroy(ndpy->wayland_bufmgr);
#endif

   if (dri2dpy->xscr)
      x11_screen_destroy(dri2dpy->xscr);
   if (dri2dpy->own_dpy)
      XCloseDisplay(dri2dpy->dpy);
   FREE(dri2dpy);
}

static void
dri2_display_invalidate_buffers(struct x11_screen *xscr, Drawable drawable,
                                void *user_data)
{
   struct native_display *ndpy = (struct native_display* ) user_data;
   struct dri2_display *dri2dpy = dri2_display(ndpy);
   struct native_surface *nsurf;
   struct dri2_surface *dri2surf;

   nsurf = (struct native_surface *)
      util_hash_table_get(dri2dpy->surfaces, (void *) drawable);
   if (!nsurf)
      return;

   dri2surf = dri2_surface(nsurf);

   dri2surf->server_stamp++;
   dri2dpy->event_handler->invalid_surface(&dri2dpy->base,
         &dri2surf->base, dri2surf->server_stamp);
}

#ifdef HAVE_WAYLAND_BACKEND

static int
dri2_display_authenticate(void *user_data, uint32_t magic)
{
   struct native_display *ndpy = user_data;
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   return x11_screen_authenticate(dri2dpy->xscr, magic);
}

#endif /* HAVE_WAYLAND_BACKEND */

/**
 * Initialize DRI2 and pipe screen.
 */
static boolean
dri2_display_init_screen(struct native_display *ndpy)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);
   int fd;

   if (!x11_screen_support(dri2dpy->xscr, X11_SCREEN_EXTENSION_DRI2) ||
       !x11_screen_support(dri2dpy->xscr, X11_SCREEN_EXTENSION_GLX)) {
      _eglLog(_EGL_WARNING, "GLX/DRI2 is not supported");
      return FALSE;
   }

   dri2dpy->dri_driver = x11_screen_probe_dri2(dri2dpy->xscr,
         &dri2dpy->dri_major, &dri2dpy->dri_minor);

   fd = x11_screen_enable_dri2(dri2dpy->xscr,
         dri2_display_invalidate_buffers, &dri2dpy->base);
   if (fd < 0)
      return FALSE;

   dri2dpy->base.screen =
      dri2dpy->event_handler->new_drm_screen(&dri2dpy->base,
            dri2dpy->dri_driver, fd);
   if (!dri2dpy->base.screen) {
      _eglLog(_EGL_DEBUG, "failed to create DRM screen");
      return FALSE;
   }

#ifdef HAVE_WAYLAND_BACKEND
   dri2dpy->base.wayland_bufmgr = wayland_drm_bufmgr_create(
         dri2_display_authenticate, dri2dpy,
         x11_screen_get_device_name(dri2dpy->xscr));

#endif

   return TRUE;
}

static unsigned
dri2_display_hash_table_hash(void *key)
{
   XID drawable = pointer_to_uintptr(key);
   return (unsigned) drawable;
}

static int
dri2_display_hash_table_compare(void *key1, void *key2)
{
   return ((char *) key1 - (char *) key2);
}

struct native_display *
x11_create_dri2_display(Display *dpy,
                        const struct native_event_handler *event_handler)
{
   struct dri2_display *dri2dpy;

   dri2dpy = CALLOC_STRUCT(dri2_display);
   if (!dri2dpy)
      return NULL;

   dri2dpy->event_handler = event_handler;

   dri2dpy->dpy = dpy;
   if (!dri2dpy->dpy) {
      dri2dpy->dpy = XOpenDisplay(NULL);
      if (!dri2dpy->dpy) {
         dri2_display_destroy(&dri2dpy->base);
         return NULL;
      }
      dri2dpy->own_dpy = TRUE;
   }

   dri2dpy->xscr_number = DefaultScreen(dri2dpy->dpy);
   dri2dpy->xscr = x11_screen_create(dri2dpy->dpy, dri2dpy->xscr_number);
   if (!dri2dpy->xscr) {
      dri2_display_destroy(&dri2dpy->base);
      return NULL;
   }

   dri2dpy->surfaces = util_hash_table_create(dri2_display_hash_table_hash,
         dri2_display_hash_table_compare);
   if (!dri2dpy->surfaces) {
      dri2_display_destroy(&dri2dpy->base);
      return NULL;
   }

   dri2dpy->base.init_screen = dri2_display_init_screen;
   dri2dpy->base.destroy = dri2_display_destroy;
   dri2dpy->base.get_param = dri2_display_get_param;
   dri2dpy->base.get_configs = dri2_display_get_configs;
   dri2dpy->base.get_pixmap_format = dri2_display_get_pixmap_format;
   dri2dpy->base.copy_to_pixmap = native_display_copy_to_pixmap;
   dri2dpy->base.create_window_surface = dri2_display_create_window_surface;
   dri2dpy->base.create_pixmap_surface = dri2_display_create_pixmap_surface;

   return &dri2dpy->base;
}

#else /* GLX_DIRECT_RENDERING */

struct native_display *
x11_create_dri2_display(Display *dpy,
                        const struct native_event_handler *event_handler)
{
   return NULL;
}

#endif /* GLX_DIRECT_RENDERING */
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d42 1
a42 1
#include "common/native_wayland_drm_bufmgr_helper.h"
a62 3
#ifdef HAVE_WAYLAND_BACKEND
   struct wl_drm *wl_server_drm; /* for EGL_WL_bind_wayland_display */
#endif
d176 1
d294 6
d323 2
d328 3
d769 4
d801 13
d845 7
a867 60
#ifdef HAVE_WAYLAND_BACKEND

static int
dri2_display_authenticate(void *user_data, uint32_t magic)
{
   struct native_display *ndpy = user_data;
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   return x11_screen_authenticate(dri2dpy->xscr, magic);
}

static struct wayland_drm_callbacks wl_drm_callbacks = {
   dri2_display_authenticate,
   egl_g3d_wl_drm_helper_reference_buffer,
   egl_g3d_wl_drm_helper_unreference_buffer
};

static boolean
dri2_display_bind_wayland_display(struct native_display *ndpy,
                                  struct wl_display *wl_dpy)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   if (dri2dpy->wl_server_drm)
      return FALSE;

   ndpy->wl_server_drm = wayland_drm_init(wl_dpy,
         x11_screen_get_device_name(dri2dpy->xscr),
         &wl_drm_callbacks, ndpy, 0);

   if (!dri2dpy->wl_server_drm)
      return FALSE;
   
   return TRUE;
}

static boolean
dri2_display_unbind_wayland_display(struct native_display *ndpy,
                                    struct wl_display *wl_dpy)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   if (!dri2dpy->wl_server_drm)
      return FALSE;

   wayland_drm_uninit(dri2dpy->wl_server_drm);
   dri2dpy->wl_server_drm = NULL;

   return TRUE;
}

static struct native_display_wayland_bufmgr dri2_display_wayland_bufmgr = {
   dri2_display_bind_wayland_display,
   dri2_display_unbind_wayland_display,
   egl_g3d_wl_drm_common_wl_buffer_get_resource,
   egl_g3d_wl_drm_common_query_buffer
};

#endif /* HAVE_WAYLAND_BACKEND */

a911 3
#ifdef HAVE_WAYLAND_BACKEND
   dri2dpy->base.wayland_bufmgr = &dri2_display_wayland_bufmgr;
#endif
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d861 1
a861 1
   dri2dpy->wl_server_drm = wayland_drm_init(wl_dpy,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.8
d40 1
d262 1
a262 2
   if (dri2surf->last_xbufs)
      FREE(dri2surf->last_xbufs);
d314 2
a315 1
dri2_surface_swap_buffers(struct native_surface *nsurf)
d321 10
a330 4
   if (dri2surf->have_back)
      x11_drawable_copy_buffers(dri2dpy->xscr, dri2surf->drawable,
            0, 0, dri2surf->width, dri2surf->height,
            DRI2BufferBackLeft, DRI2BufferFrontLeft);
d333 10
a342 4
   if (dri2surf->have_fake)
      x11_drawable_copy_buffers(dri2dpy->xscr, dri2surf->drawable,
            0, 0, dri2surf->width, dri2surf->height,
            DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
d356 1
a356 3
                     enum native_attachment natt,
                     boolean preserve,
                     uint swap_interval)
d360 1
a360 1
   if (swap_interval)
d363 1
a363 1
   switch (natt) {
d368 1
a368 1
      ret = dri2_surface_swap_buffers(nsurf);
d433 1
a433 2
   if (dri2surf->last_xbufs)
      FREE(dri2surf->last_xbufs);
d694 3
a696 3
dri2_display_is_pixmap_supported(struct native_display *ndpy,
                                 EGLNativePixmapType pix,
                                 const struct native_config *nconf)
d699 2
a700 1
   uint depth, nconf_depth;
d703 13
a715 1
   nconf_depth = util_format_get_blocksizebits(nconf->color_format);
d717 1
a717 2
   /* simple depth match for now */
   return (depth == nconf_depth || (depth == 24 && depth + 8 == nconf_depth));
d735 3
d752 1
a752 2
   if (dri2dpy->configs)
      FREE(dri2dpy->configs);
d835 2
a845 2
#ifdef HAVE_WAYLAND_BACKEND

d863 1
a863 1
         &wl_drm_callbacks, ndpy);
d889 2
a890 1
   egl_g3d_wl_drm_common_wl_buffer_get_resource
d935 2
a936 1
   dri2dpy->base.is_pixmap_supported = dri2_display_is_pixmap_supported;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d41 4
a46 5
enum dri2_surface_type {
   DRI2_SURFACE_TYPE_WINDOW,
   DRI2_SURFACE_TYPE_PIXMAP,
};

d52 1
a52 1
   struct native_event_handler *event_handler;
d63 3
a70 1
   enum dri2_surface_type type;
a442 1
                            enum dri2_surface_type type,
d444 1
a444 1
                            const struct native_config *nconf)
a446 1
   struct dri2_config *dri2conf = dri2_config(nconf);
a453 1
   dri2surf->type = type;
d455 1
a455 1
   dri2surf->color_format = dri2conf->base.color_format;
d481 2
a482 2
   dri2surf = dri2_display_create_surface(ndpy, DRI2_SURFACE_TYPE_WINDOW,
         (Drawable) win, nconf);
d493 23
a515 2
   dri2surf = dri2_display_create_surface(ndpy, DRI2_SURFACE_TYPE_PIXMAP,
         (Drawable) pix, nconf);
d551 1
a551 1
         PIPE_BIND_DEPTH_STENCIL, 0);
a620 3
   nconf->samples = mode->samples;

   nconf->slow_config = (mode->visualRating == GLX_SLOW_CONFIG);
d792 1
a792 1
      _eglLog(_EGL_WARNING, "failed to create DRM screen");
d809 52
a860 1
   return (key1 - key2);
d863 8
d873 1
a873 2
                        struct native_event_handler *event_handler,
                        void *user_data)
a881 1
   dri2dpy->base.user_data = user_data;
a899 5
   if (!dri2_display_init_screen(&dri2dpy->base)) {
      dri2_display_destroy(&dri2dpy->base);
      return NULL;
   }

d907 1
d914 3
d925 1
a925 2
                        struct native_event_handler *event_handler,
                        void *user_data)
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d35 1
a35 1
#include "state_tracker/drm_api.h"
d41 2
a45 1
   DRI2_SURFACE_TYPE_PBUFFER
a54 1
   struct drm_api *api;
d76 1
a76 1
   struct pipe_texture *textures[NUM_NATIVE_ATTACHMENTS];
d117 2
a118 1
   struct pipe_texture templ;
d124 1
a124 1
      pipe_texture_reference(&dri2surf->textures[i], NULL);
d139 1
d141 1
a141 1
   templ.tex_usage = PIPE_TEXTURE_USAGE_RENDER_TARGET;
d177 5
a181 3
      dri2surf->textures[natt] =
         dri2dpy->api->texture_from_shared_handle(dri2dpy->api,
               dri2dpy->base.screen, &templ, desc, xbuf->pitch, xbuf->name);
d197 1
a197 1
   unsigned int dri2atts[NUM_NATIVE_ATTACHMENTS];
d200 10
d236 3
a238 2
         dri2atts[num_ins] = dri2att;
         num_ins++;
d241 2
d246 1
a246 1
                                    dri2atts, FALSE, num_ins, &num_outs);
d251 1
a251 1
      free(xbufs);
d262 1
a262 1
      free(dri2surf->last_xbufs);
a274 8
   struct dri2_display *dri2dpy = dri2surf->dri2dpy;

   /* create textures for pbuffer */
   if (dri2surf->type == DRI2_SURFACE_TYPE_PBUFFER) {
      struct pipe_screen *screen = dri2dpy->base.screen;
      struct pipe_texture templ;
      uint new_valid = 0x0;
      int att;
d276 1
a276 32
      buffer_mask &= ~dri2surf->valid_mask;
      if (!buffer_mask)
         return TRUE;

      memset(&templ, 0, sizeof(templ));
      templ.target = PIPE_TEXTURE_2D;
      templ.last_level = 0;
      templ.width0 = dri2surf->width;
      templ.height0 = dri2surf->height;
      templ.depth0 = 1;
      templ.format = dri2surf->color_format;
      templ.tex_usage = PIPE_TEXTURE_USAGE_RENDER_TARGET;

      for (att = 0; att < NUM_NATIVE_ATTACHMENTS; att++) {
         if (native_attachment_mask_test(buffer_mask, att)) {
            assert(!dri2surf->textures[att]);

            dri2surf->textures[att] = screen->texture_create(screen, &templ);
            if (!dri2surf->textures[att])
               break;

            new_valid |= 1 << att;
            if (new_valid == buffer_mask)
               break;
         }
      }
      dri2surf->valid_mask |= new_valid;
      /* no need to update the stamps */
   }
   else {
      dri2_surface_get_buffers(&dri2surf->base, buffer_mask);
   }
a296 4
   /* pbuffer is private */
   if (dri2surf->type == DRI2_SURFACE_TYPE_PBUFFER)
      return TRUE;

a318 4
   /* pbuffer is private */
   if (dri2surf->type == DRI2_SURFACE_TYPE_PBUFFER)
      return TRUE;

d342 26
d369 1
a369 1
                      unsigned int *seq_num, struct pipe_texture **textures,
d387 1
a387 1
            struct pipe_texture *ptex = dri2surf->textures[att];
d390 1
a390 1
            pipe_texture_reference(&textures[att], ptex);
d423 1
a423 1
      free(dri2surf->last_xbufs);
d426 2
a427 2
      struct pipe_texture *ptex = dri2surf->textures[i];
      pipe_texture_reference(&ptex, NULL);
d437 1
a437 1
   free(dri2surf);
d460 1
a460 2
   dri2surf->base.swap_buffers = dri2_surface_swap_buffers;
   dri2surf->base.flush_frontbuffer = dri2_surface_flush_frontbuffer;
a499 16
static struct native_surface *
dri2_display_create_pbuffer_surface(struct native_display *ndpy,
                                    const struct native_config *nconf,
                                    uint width, uint height)
{
   struct dri2_surface *dri2surf;

   dri2surf = dri2_display_create_surface(ndpy, DRI2_SURFACE_TYPE_PBUFFER,
         (Drawable) None, nconf);
   if (dri2surf) {
      dri2surf->width = width;
      dri2surf->height = height;
   }
   return (dri2surf) ? &dri2surf->base : NULL;
}

a525 30
static int
choose_depth_stencil_format(const __GLcontextModes *mode,
                            enum pipe_format formats[32])
{
   int count = 0;

   switch (mode->depthBits) {
   case 32:
      formats[count++] = PIPE_FORMAT_Z32_UNORM;
      break;
   case 24:
      if (mode->stencilBits) {
         formats[count++] = PIPE_FORMAT_Z24S8_UNORM;
         formats[count++] = PIPE_FORMAT_S8Z24_UNORM;
      }
      else {
         formats[count++] = PIPE_FORMAT_Z24X8_UNORM;
         formats[count++] = PIPE_FORMAT_X8Z24_UNORM;
      }
      break;
   case 16:
      formats[count++] = PIPE_FORMAT_Z16_UNORM;
      break;
   default:
      break;
   }

   return count;
}

d528 1
a528 1
                    enum pipe_format fmt, boolean is_color)
d530 3
a532 3
   return screen->is_format_supported(screen, fmt, PIPE_TEXTURE_2D,
         (is_color) ? PIPE_TEXTURE_USAGE_RENDER_TARGET :
         PIPE_TEXTURE_USAGE_DEPTH_STENCIL, 0);
d542 1
d547 2
a548 2
   /* skip single-buffered configs */
   if (!mode->doubleBufferMode)
d551 12
a562 24
   nconf->mode = *mode;
   nconf->mode.renderType = GLX_RGBA_BIT;
   nconf->mode.rgbMode = TRUE;
   /* pbuffer is allocated locally and is always supported */
   nconf->mode.drawableType |= GLX_PBUFFER_BIT;
   /* the swap method is always copy */
   nconf->mode.swapMethod = GLX_SWAP_COPY_OML;

   /* fix up */
   nconf->mode.rgbBits =
      nconf->mode.redBits + nconf->mode.greenBits +
      nconf->mode.blueBits + nconf->mode.alphaBits;
   if (!(nconf->mode.drawableType & GLX_WINDOW_BIT)) {
      nconf->mode.visualID = 0;
      nconf->mode.visualType = GLX_NONE;
   }
   if (!(nconf->mode.drawableType & GLX_PBUFFER_BIT)) {
      nconf->mode.bindToTextureRgb = FALSE;
      nconf->mode.bindToTextureRgba = FALSE;
   }

   nconf->color_format = PIPE_FORMAT_NONE;
   nconf->depth_format = PIPE_FORMAT_NONE;
   nconf->stencil_format = PIPE_FORMAT_NONE;
d567 1
a567 1
      if (is_format_supported(ndpy->screen, formats[i], TRUE)) {
d575 36
a610 8
   /* choose depth/stencil format */
   num_formats = choose_depth_stencil_format(mode, formats);
   for (i = 0; i < num_formats; i++) {
      if (is_format_supported(ndpy->screen, formats[i], FALSE)) {
         nconf->depth_format = formats[i];
         nconf->stencil_format = formats[i];
         break;
      }
a611 3
   if ((nconf->mode.depthBits && nconf->depth_format == PIPE_FORMAT_NONE) ||
       (nconf->mode.stencilBits && nconf->stencil_format == PIPE_FORMAT_NONE))
      return FALSE;
d633 1
a633 1
      dri2dpy->configs = calloc(num_modes, sizeof(*dri2dpy->configs));
d640 11
a650 2
         if (dri2_display_convert_config(&dri2dpy->base, modes, nconf))
            count++;
d657 1
a657 1
   configs = malloc(dri2dpy->num_configs * sizeof(*configs));
d691 1
a691 1
      /* DRI2GetBuffers use the native buffers */
d694 5
d713 1
a713 1
      free(dri2dpy->configs);
d725 1
a725 3
   if (dri2dpy->api && dri2dpy->api->destroy)
      dri2dpy->api->destroy(dri2dpy->api);
   free(dri2dpy);
a755 2
   const char *driver = dri2dpy->api->name;
   struct drm_create_screen_arg arg;
a765 6
   if (!dri2dpy->dri_driver || !driver ||
       strcmp(dri2dpy->dri_driver, driver) != 0) {
      _eglLog(_EGL_WARNING, "Driver mismatch: %s != %s",
            dri2dpy->dri_driver, dri2dpy->api->name);
      return FALSE;
   }
d772 3
a774 3
   memset(&arg, 0, sizeof(arg));
   arg.mode = DRM_CREATE_NORMAL;
   dri2dpy->base.screen = dri2dpy->api->create_screen(dri2dpy->api, fd, &arg);
d797 1
a797 1
x11_create_dri2_display(EGLNativeDisplayType dpy,
d799 1
a799 1
                        struct drm_api *api)
d808 1
a808 1
   dri2dpy->api = api;
a844 1
   dri2dpy->base.create_pbuffer_surface = dri2_display_create_pbuffer_surface;
d848 12
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d17 2
a18 2
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
d34 1
a34 1
#include "state_tracker/drm_driver.h"
a39 2
#ifdef GLX_DIRECT_RENDERING

d43 1
d53 1
d75 1
a75 1
   struct pipe_resource *textures[NUM_NATIVE_ATTACHMENTS];
d116 1
a116 2
   struct pipe_resource templ;
   struct winsys_handle whandle;
d122 1
a122 1
      pipe_resource_reference(&dri2surf->textures[i], NULL);
a136 1
   templ.array_size = 1;
d138 1
a138 1
   templ.bind = PIPE_BIND_RENDER_TARGET;
d174 3
a176 5
      memset(&whandle, 0, sizeof(whandle));
      whandle.stride = xbuf->pitch;
      whandle.handle = xbuf->name;
      dri2surf->textures[natt] = dri2dpy->base.screen->resource_from_handle(
         dri2dpy->base.screen, &templ, &whandle);
d192 1
a192 1
   unsigned int dri2atts[NUM_NATIVE_ATTACHMENTS * 2];
a194 10
   uint bpp = util_format_get_blocksizebits(dri2surf->color_format);
   boolean with_format = FALSE; /* never ask for depth/stencil */

   /* We must get the front on servers which doesn't support with format
    * due to a silly bug in core dri2. You can't copy to/from a buffer
    * that you haven't requested and you recive BadValue errors */
   if (dri2surf->dri2dpy->dri_minor < 1) {
      with_format = FALSE;
      buffer_mask |= (1 << NATIVE_ATTACHMENT_FRONT_LEFT);
   }
d221 2
a222 3
         dri2atts[num_ins++] = dri2att;
         if (with_format)
            dri2atts[num_ins++] = bpp;
a224 2
   if (with_format)
      num_ins /= 2;
d228 1
a228 1
                                    dri2atts, with_format, num_ins, &num_outs);
d233 1
a233 1
      FREE(xbufs);
d244 1
a244 1
      FREE(dri2surf->last_xbufs);
d257 8
d266 32
a297 1
   dri2_surface_get_buffers(&dri2surf->base, buffer_mask);
d318 4
d344 4
a370 26
dri2_surface_present(struct native_surface *nsurf,
                     enum native_attachment natt,
                     boolean preserve,
                     uint swap_interval)
{
   boolean ret;

   if (swap_interval)
      return FALSE;

   switch (natt) {
   case NATIVE_ATTACHMENT_FRONT_LEFT:
      ret = dri2_surface_flush_frontbuffer(nsurf);
      break;
   case NATIVE_ATTACHMENT_BACK_LEFT:
      ret = dri2_surface_swap_buffers(nsurf);
      break;
   default:
      ret = FALSE;
      break;
   }

   return ret;
}

static boolean
d372 1
a372 1
                      unsigned int *seq_num, struct pipe_resource **textures,
d390 1
a390 1
            struct pipe_resource *ptex = dri2surf->textures[att];
d393 1
a393 1
            pipe_resource_reference(&textures[att], ptex);
d426 1
a426 1
      FREE(dri2surf->last_xbufs);
d429 2
a430 2
      struct pipe_resource *ptex = dri2surf->textures[i];
      pipe_resource_reference(&ptex, NULL);
d440 1
a440 1
   FREE(dri2surf);
d463 2
a464 1
   dri2surf->base.present = dri2_surface_present;
d504 16
d546 30
d578 1
a578 1
                    enum pipe_format fmt, unsigned sample_count, boolean is_color)
d580 3
a582 3
   return screen->is_format_supported(screen, fmt, PIPE_TEXTURE_2D, sample_count,
         (is_color) ? PIPE_BIND_RENDER_TARGET :
         PIPE_BIND_DEPTH_STENCIL, 0);
a591 1
   int sample_count = 0;
d596 2
a597 2
   /* only interested in native renderable configs */
   if (!mode->xRenderable || !mode->drawableType)
d600 24
a623 12
   /* fast/slow configs are probably not relevant */
   if (mode->visualRating == GLX_SLOW_CONFIG)
      return FALSE;

   nconf->buffer_mask = 1 << NATIVE_ATTACHMENT_FRONT_LEFT;
   if (mode->doubleBufferMode)
      nconf->buffer_mask |= 1 << NATIVE_ATTACHMENT_BACK_LEFT;
   if (mode->stereoMode) {
      nconf->buffer_mask |= 1 << NATIVE_ATTACHMENT_FRONT_RIGHT;
      if (mode->doubleBufferMode)
         nconf->buffer_mask |= 1 << NATIVE_ATTACHMENT_BACK_RIGHT;
   }
d628 1
a628 1
      if (is_format_supported(ndpy->screen, formats[i], sample_count, TRUE)) {
d636 8
a643 36
   if ((mode->drawableType & GLX_WINDOW_BIT) && mode->visualID)
      nconf->window_bit = TRUE;
   if (mode->drawableType & GLX_PIXMAP_BIT)
      nconf->pixmap_bit = TRUE;

   nconf->native_visual_id = mode->visualID;
   switch (mode->visualType) {
   case GLX_TRUE_COLOR:
      nconf->native_visual_type = TrueColor;
      break;
   case GLX_DIRECT_COLOR:
      nconf->native_visual_type = DirectColor;
      break;
   case GLX_PSEUDO_COLOR:
      nconf->native_visual_type = PseudoColor;
      break;
   case GLX_STATIC_COLOR:
      nconf->native_visual_type = StaticColor;
      break;
   case GLX_GRAY_SCALE:
      nconf->native_visual_type = GrayScale;
      break;
   case GLX_STATIC_GRAY:
      nconf->native_visual_type = StaticGray;
      break;
   }
   nconf->level = mode->level;
   nconf->samples = mode->samples;

   nconf->slow_config = (mode->visualRating == GLX_SLOW_CONFIG);

   if (mode->transparentPixel == GLX_TRANSPARENT_RGB) {
      nconf->transparent_rgb = TRUE;
      nconf->transparent_rgb_values[0] = mode->transparentRed;
      nconf->transparent_rgb_values[1] = mode->transparentGreen;
      nconf->transparent_rgb_values[2] = mode->transparentBlue;
d645 3
d669 1
a669 1
      dri2dpy->configs = CALLOC(num_modes, sizeof(*dri2dpy->configs));
d676 2
a677 11

         if (dri2_display_convert_config(&dri2dpy->base, modes, nconf)) {
            int j;
            /* look for duplicates */
            for (j = 0; j < count; j++) {
               if (memcmp(&dri2dpy->configs[j], nconf, sizeof(*nconf)) == 0)
                  break;
            }
            if (j == count)
               count++;
         }
d684 1
a684 1
   configs = MALLOC(dri2dpy->num_configs * sizeof(*configs));
d718 1
a718 1
      /* DRI2GetBuffers uses the native buffers */
a720 5
   case NATIVE_PARAM_PRESERVE_BUFFER:
      /* DRI2CopyRegion is used */
      val = TRUE;
      break;
   case NATIVE_PARAM_MAX_SWAP_INTERVAL:
d735 1
a735 1
      FREE(dri2dpy->configs);
d747 3
a749 1
   FREE(dri2dpy);
d780 2
d792 6
d804 3
a806 3
   dri2dpy->base.screen =
      dri2dpy->event_handler->new_drm_screen(&dri2dpy->base,
            dri2dpy->dri_driver, fd);
d829 1
a829 1
x11_create_dri2_display(Display *dpy,
d831 1
a831 1
                        void *user_data)
d840 1
a840 1
   dri2dpy->base.user_data = user_data;
d877 1
a880 12

#else /* GLX_DIRECT_RENDERING */

struct native_display *
x11_create_dri2_display(Display *dpy,
                        struct native_event_handler *event_handler,
                        void *user_data)
{
   return NULL;
}

#endif /* GLX_DIRECT_RENDERING */
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d41 1
a41 4
#include "common/native_helper.h"
#ifdef HAVE_WAYLAND_BACKEND
#include "common/native_wayland_drm_bufmgr_helper.h"
#endif
d43 4
a46 1
#ifdef GLX_DIRECT_RENDERING
d53 1
a53 1
   const struct native_event_handler *event_handler;
a63 3
#ifdef HAVE_WAYLAND_BACKEND
   struct wl_drm *wl_server_drm; /* for EGL_WL_bind_wayland_display */
#endif
d69 1
d261 2
a262 1
   FREE(dri2surf->last_xbufs);
d314 1
a314 2
dri2_surface_swap_buffers(struct native_surface *nsurf, int num_rects,
                          const int *rects)
d320 4
a323 10
   if (dri2surf->have_back) {
      if (num_rects > 0)
         x11_drawable_copy_buffers_region(dri2dpy->xscr, dri2surf->drawable,
               num_rects, rects,
               DRI2BufferBackLeft, DRI2BufferFrontLeft);
      else
         x11_drawable_copy_buffers(dri2dpy->xscr, dri2surf->drawable,
               0, 0, dri2surf->width, dri2surf->height,
               DRI2BufferBackLeft, DRI2BufferFrontLeft);
   }
d326 4
a329 10
   if (dri2surf->have_fake) {
      if (num_rects > 0)
         x11_drawable_copy_buffers_region(dri2dpy->xscr, dri2surf->drawable,
               num_rects, rects,
               DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
      else
         x11_drawable_copy_buffers(dri2dpy->xscr, dri2surf->drawable,
               0, 0, dri2surf->width, dri2surf->height,
               DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
   }
d343 3
a345 1
                     const struct native_present_control *ctrl)
d349 1
a349 1
   if (ctrl->swap_interval)
d352 1
a352 1
   switch (ctrl->natt) {
d357 1
a357 1
      ret = dri2_surface_swap_buffers(nsurf, ctrl->num_rects, ctrl->rects);
d422 2
a423 1
   FREE(dri2surf->last_xbufs);
d442 1
d444 1
a444 1
                            enum pipe_format color_format)
d447 1
d455 1
d457 1
a457 1
   dri2surf->color_format = color_format;
d483 2
a484 2
   dri2surf = dri2_display_create_surface(ndpy,
         (Drawable) win, nconf->color_format);
d495 2
a496 23
   if (!nconf) {
      struct dri2_display *dri2dpy = dri2_display(ndpy);
      uint depth, nconf_depth;
      int i;

      depth = x11_drawable_get_depth(dri2dpy->xscr, (Drawable) pix);
      for (i = 0; i < dri2dpy->num_configs; i++) {
         nconf_depth = util_format_get_blocksizebits(
               dri2dpy->configs[i].base.color_format);
         /* simple depth match for now */
         if (depth == nconf_depth ||
             (depth == 24 && depth + 8 == nconf_depth)) {
            nconf = &dri2dpy->configs[i].base;
            break;
         }
      }

      if (!nconf)
         return NULL;
   }

   dri2surf = dri2_display_create_surface(ndpy,
         (Drawable) pix, nconf->color_format);
d532 1
a532 1
         PIPE_BIND_DEPTH_STENCIL);
d602 3
d669 3
a671 3
dri2_display_get_pixmap_format(struct native_display *ndpy,
                               EGLNativePixmapType pix,
                               enum pipe_format *format)
d674 1
a674 2
   boolean ret = EGL_TRUE;
   uint depth;
d677 1
a677 13
   switch (depth) {
   case 32:
   case 24:
      *format = PIPE_FORMAT_B8G8R8A8_UNORM;
      break;
   case 16:
      *format = PIPE_FORMAT_B5G6R5_UNORM;
      break;
   default:
      *format = PIPE_FORMAT_NONE;
      ret = EGL_FALSE;
      break;
   }
d679 2
a680 1
   return ret;
a697 3
   case NATIVE_PARAM_PRESENT_REGION:
      val = TRUE;
      break;
d712 2
a713 1
   FREE(dri2dpy->configs);
d776 1
a776 1
      _eglLog(_EGL_DEBUG, "failed to create DRM screen");
d793 1
a793 52
   return ((char *) key1 - (char *) key2);
}

#ifdef HAVE_WAYLAND_BACKEND

static int
dri2_display_authenticate(void *user_data, uint32_t magic)
{
   struct native_display *ndpy = user_data;
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   return x11_screen_authenticate(dri2dpy->xscr, magic);
}

static struct wayland_drm_callbacks wl_drm_callbacks = {
   dri2_display_authenticate,
   egl_g3d_wl_drm_helper_reference_buffer,
   egl_g3d_wl_drm_helper_unreference_buffer
};

static boolean
dri2_display_bind_wayland_display(struct native_display *ndpy,
                                  struct wl_display *wl_dpy)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   if (dri2dpy->wl_server_drm)
      return FALSE;

   dri2dpy->wl_server_drm = wayland_drm_init(wl_dpy,
         x11_screen_get_device_name(dri2dpy->xscr),
         &wl_drm_callbacks, ndpy, 0);

   if (!dri2dpy->wl_server_drm)
      return FALSE;
   
   return TRUE;
}

static boolean
dri2_display_unbind_wayland_display(struct native_display *ndpy,
                                    struct wl_display *wl_dpy)
{
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   if (!dri2dpy->wl_server_drm)
      return FALSE;

   wayland_drm_uninit(dri2dpy->wl_server_drm);
   dri2dpy->wl_server_drm = NULL;

   return TRUE;
a795 9
static struct native_display_wayland_bufmgr dri2_display_wayland_bufmgr = {
   dri2_display_bind_wayland_display,
   dri2_display_unbind_wayland_display,
   egl_g3d_wl_drm_common_wl_buffer_get_resource,
   egl_g3d_wl_drm_common_query_buffer
};

#endif /* HAVE_WAYLAND_BACKEND */

d798 2
a799 1
                        const struct native_event_handler *event_handler)
d808 1
d827 5
a838 1
   dri2dpy->base.init_screen = dri2_display_init_screen;
d842 1
a842 2
   dri2dpy->base.get_pixmap_format = dri2_display_get_pixmap_format;
   dri2dpy->base.copy_to_pixmap = native_display_copy_to_pixmap;
a844 3
#ifdef HAVE_WAYLAND_BACKEND
   dri2dpy->base.wayland_bufmgr = &dri2_display_wayland_bufmgr;
#endif
d853 2
a854 1
                        const struct native_event_handler *event_handler)
@


1.1.1.3
log
@Import Mesa 9.2.3
@
text
@d861 1
a861 1
   ndpy->wl_server_drm = wayland_drm_init(wl_dpy,
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d42 1
a42 1
#include "common/native_wayland_drm_bufmgr.h"
d63 3
a178 1
      whandle.type = DRM_API_HANDLE_TYPE_SHARED;
a295 6
   struct native_display *ndpy = &dri2dpy->base;
   struct pipe_context *pipe = ndpy_get_copy_context(ndpy);

   /* flush buffer */
   pipe->flush_resource(pipe, dri2surf->textures[NATIVE_ATTACHMENT_FRONT_LEFT]);
   pipe->flush(pipe, NULL, 0);
a318 2
   struct native_display *ndpy = &dri2dpy->base;
   struct pipe_context *pipe = ndpy_get_copy_context(ndpy);
a321 3
      pipe->flush_resource(pipe, dri2surf->textures[NATIVE_ATTACHMENT_BACK_LEFT]);
      pipe->flush(pipe, NULL, 0);

a759 4
#ifdef HAVE_WAYLAND_BACKEND
   wayland_drm_bufmgr_destroy(ndpy->wayland_bufmgr);
#endif

a787 13
#ifdef HAVE_WAYLAND_BACKEND

static int
dri2_display_authenticate(void *user_data, uint32_t magic)
{
   struct native_display *ndpy = user_data;
   struct dri2_display *dri2dpy = dri2_display(ndpy);

   return x11_screen_authenticate(dri2dpy->xscr, magic);
}

#endif /* HAVE_WAYLAND_BACKEND */

a818 7
#ifdef HAVE_WAYLAND_BACKEND
   dri2dpy->base.wayland_bufmgr = wayland_drm_bufmgr_create(
         dri2_display_authenticate, dri2dpy,
         x11_screen_get_device_name(dri2dpy->xscr));

#endif

d835 60
d939 3
@


