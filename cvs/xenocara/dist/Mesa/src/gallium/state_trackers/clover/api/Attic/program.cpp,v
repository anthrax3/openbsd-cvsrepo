head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2015.12.23.05.17.36;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.13.10;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.13.10;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.18;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.09.08;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.46.20;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@//
// Copyright 2012 Francisco Jerez
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//

#include "api/util.hpp"
#include "core/program.hpp"

using namespace clover;

PUBLIC cl_program
clCreateProgramWithSource(cl_context ctx, cl_uint count,
                          const char **strings, const size_t *lengths,
                          cl_int *errcode_ret) try {
   std::string source;

   if (!ctx)
      throw error(CL_INVALID_CONTEXT);

   if (!count || !strings ||
       any_of(is_zero<const char *>, strings, strings + count))
      throw error(CL_INVALID_VALUE);

   // Concatenate all the provided fragments together
   for (unsigned i = 0; i < count; ++i)
         source += (lengths && lengths[i] ?
                    std::string(strings[i], strings[i] + lengths[i]) :
                    std::string(strings[i]));

   // ...and create a program object for them.
   ret_error(errcode_ret, CL_SUCCESS);
   return new program(*ctx, source);

} catch (error &e) {
   ret_error(errcode_ret, e);
   return NULL;
}

PUBLIC cl_program
clCreateProgramWithBinary(cl_context ctx, cl_uint count,
                          const cl_device_id *devs, const size_t *lengths,
                          const unsigned char **binaries, cl_int *status_ret,
                          cl_int *errcode_ret) try {
   if (!ctx)
      throw error(CL_INVALID_CONTEXT);

   if (!count || !devs || !lengths || !binaries)
      throw error(CL_INVALID_VALUE);

   if (any_of([&](const cl_device_id dev) {
            return !ctx->has_device(dev);
         }, devs, devs + count))
      throw error(CL_INVALID_DEVICE);

   // Deserialize the provided binaries,
   auto modules = map(
      [](const unsigned char *p, size_t l) -> std::pair<cl_int, module> {
         if (!p || !l)
            return { CL_INVALID_VALUE, {} };

         try {
            compat::istream::buffer_t bin(p, l);
            compat::istream s(bin);

            return { CL_SUCCESS, module::deserialize(s) };

         } catch (compat::istream::error &e) {
            return { CL_INVALID_BINARY, {} };
         }
      },
      binaries, binaries + count, lengths);

   // update the status array,
   if (status_ret)
      std::transform(modules.begin(), modules.end(), status_ret,
                     keys<cl_int, module>);

   if (any_of(key_equals<cl_int, module>(CL_INVALID_VALUE),
              modules.begin(), modules.end()))
      throw error(CL_INVALID_VALUE);

   if (any_of(key_equals<cl_int, module>(CL_INVALID_BINARY),
              modules.begin(), modules.end()))
      throw error(CL_INVALID_BINARY);

   // initialize a program object with them.
   ret_error(errcode_ret, CL_SUCCESS);
   return new program(*ctx, { devs, devs + count },
                      map(values<cl_int, module>,
                          modules.begin(), modules.end()));

} catch (error &e) {
   ret_error(errcode_ret, e);
   return NULL;
}

PUBLIC cl_int
clRetainProgram(cl_program prog) {
   if (!prog)
      return CL_INVALID_PROGRAM;

   prog->retain();
   return CL_SUCCESS;
}

PUBLIC cl_int
clReleaseProgram(cl_program prog) {
   if (!prog)
      return CL_INVALID_PROGRAM;

   if (prog->release())
      delete prog;

   return CL_SUCCESS;
}

PUBLIC cl_int
clBuildProgram(cl_program prog, cl_uint count, const cl_device_id *devs,
               const char *opts, void (*pfn_notify)(cl_program, void *),
               void *user_data) try {
   if (!prog)
      throw error(CL_INVALID_PROGRAM);

   if (bool(count) != bool(devs) ||
       (!pfn_notify && user_data))
      throw error(CL_INVALID_VALUE);

   if (!opts)
      opts = "";

   if (devs) {
      if (any_of([&](const cl_device_id dev) {
               return !prog->ctx.has_device(dev);
            }, devs, devs + count))
         throw error(CL_INVALID_DEVICE);

      prog->build({ devs, devs + count }, opts);
   } else {
      prog->build(prog->ctx.devs, opts);
   }

   return CL_SUCCESS;

} catch (error &e) {
   return e.get();
}

PUBLIC cl_int
clUnloadCompiler() {
   return CL_SUCCESS;
}

PUBLIC cl_int
clGetProgramInfo(cl_program prog, cl_program_info param,
                 size_t size, void *buf, size_t *size_ret) {
   if (!prog)
      return CL_INVALID_PROGRAM;

   switch (param) {
   case CL_PROGRAM_REFERENCE_COUNT:
      return scalar_property<cl_uint>(buf, size, size_ret,
                                      prog->ref_count());

   case CL_PROGRAM_CONTEXT:
      return scalar_property<cl_context>(buf, size, size_ret,
                                         &prog->ctx);

   case CL_PROGRAM_NUM_DEVICES:
      return scalar_property<cl_uint>(buf, size, size_ret,
                                      prog->binaries().size());

   case CL_PROGRAM_DEVICES:
      return vector_property<cl_device_id>(
         buf, size, size_ret,
         map(keys<device *, module>,
             prog->binaries().begin(), prog->binaries().end()));

   case CL_PROGRAM_SOURCE:
      return string_property(buf, size, size_ret, prog->source());

   case CL_PROGRAM_BINARY_SIZES:
      return vector_property<size_t>(
         buf, size, size_ret,
         map([](const std::pair<device *, module> &ent) {
               compat::ostream::buffer_t bin;
               compat::ostream s(bin);
               ent.second.serialize(s);
               return bin.size();
            },
            prog->binaries().begin(), prog->binaries().end()));

   case CL_PROGRAM_BINARIES:
      return matrix_property<unsigned char>(
         buf, size, size_ret,
         map([](const std::pair<device *, module> &ent) {
               compat::ostream::buffer_t bin;
               compat::ostream s(bin);
               ent.second.serialize(s);
               return bin;
            },
            prog->binaries().begin(), prog->binaries().end()));

   default:
      return CL_INVALID_VALUE;
   }
}

PUBLIC cl_int
clGetProgramBuildInfo(cl_program prog, cl_device_id dev,
                      cl_program_build_info param,
                      size_t size, void *buf, size_t *size_ret) {
   if (!prog)
      return CL_INVALID_PROGRAM;

   if (!prog->ctx.has_device(dev))
      return CL_INVALID_DEVICE;

   switch (param) {
   case CL_PROGRAM_BUILD_STATUS:
      return scalar_property<cl_build_status>(buf, size, size_ret,
                                              prog->build_status(dev));

   case CL_PROGRAM_BUILD_OPTIONS:
      return string_property(buf, size, size_ret, prog->build_opts(dev));

   case CL_PROGRAM_BUILD_LOG:
      return string_property(buf, size, size_ret, prog->build_log(dev));

   default:
      return CL_INVALID_VALUE;
   }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d28 2
a29 2
CLOVER_API cl_program
clCreateProgramWithSource(cl_context d_ctx, cl_uint count,
d31 1
a31 2
                          cl_int *r_errcode) try {
   auto &ctx = obj(d_ctx);
d34 3
d38 1
a38 1
       any_of(is_zero(), range(strings, count)))
d48 2
a49 2
   ret_error(r_errcode, CL_SUCCESS);
   return new program(ctx, source);
d52 1
a52 1
   ret_error(r_errcode, e);
d56 9
a64 10
CLOVER_API cl_program
clCreateProgramWithBinary(cl_context d_ctx, cl_uint n,
                          const cl_device_id *d_devs,
                          const size_t *lengths,
                          const unsigned char **binaries,
                          cl_int *r_status, cl_int *r_errcode) try {
   auto &ctx = obj(d_ctx);
   auto devs = objs(d_devs, n);

   if (!lengths || !binaries)
d67 3
a69 3
   if (any_of([&](const device &dev) {
            return !count(dev, ctx.devices());
         }, devs))
d73 1
a73 1
   std::vector<std::pair<cl_int, module>> result = map(
d88 1
a88 2
      range(binaries, n),
      range(lengths, n));
d91 3
a93 2
   if (r_status)
      copy(map(keys(), result), r_status);
d95 2
a96 1
   if (any_of(key_equals(CL_INVALID_VALUE), result))
d99 2
a100 1
   if (any_of(key_equals(CL_INVALID_BINARY), result))
d104 4
a107 2
   ret_error(r_errcode, CL_SUCCESS);
   return new program(ctx, devs, map(values(), result));
d110 1
a110 1
   ret_error(r_errcode, e);
d114 6
a119 3
CLOVER_API cl_int
clRetainProgram(cl_program d_prog) try {
   obj(d_prog).retain();
d121 1
d123 4
a126 3
} catch (error &e) {
   return e.get();
}
d128 2
a129 4
CLOVER_API cl_int
clReleaseProgram(cl_program d_prog) try {
   if (obj(d_prog).release())
      delete pobj(d_prog);
a131 3

} catch (error &e) {
   return e.get();
d134 3
a136 4
CLOVER_API cl_int
clBuildProgram(cl_program d_prog, cl_uint num_devs,
               const cl_device_id *d_devs, const char *p_opts,
               void (*pfn_notify)(cl_program, void *),
d138 2
a139 4
   auto &prog = obj(d_prog);
   auto devs = (d_devs ? objs(d_devs, num_devs) :
                ref_vector<device>(prog.context().devices()));
   auto opts = (p_opts ? p_opts : "");
d141 1
a141 1
   if (bool(num_devs) != bool(d_devs) ||
d145 13
a157 4
   if (any_of([&](const device &dev) {
            return !count(dev, prog.context().devices());
         }, devs))
      throw error(CL_INVALID_DEVICE);
a158 1
   prog.build(devs, opts);
d165 1
a165 1
CLOVER_API cl_int
d170 5
a174 5
CLOVER_API cl_int
clGetProgramInfo(cl_program d_prog, cl_program_info param,
                 size_t size, void *r_buf, size_t *r_size) try {
   property_buffer buf { r_buf, size, r_size };
   auto &prog = obj(d_prog);
d178 2
a179 2
      buf.as_scalar<cl_uint>() = prog.ref_count();
      break;
d182 2
a183 2
      buf.as_scalar<cl_context>() = desc(prog.context());
      break;
d186 2
a187 4
      buf.as_scalar<cl_uint>() = (prog.devices().size() ?
                                  prog.devices().size() :
                                  prog.context().devices().size());
      break;
d190 4
a193 4
      buf.as_vector<cl_device_id>() = (prog.devices().size() ?
                                       descs(prog.devices()) :
                                       descs(prog.context().devices()));
      break;
d196 1
a196 2
      buf.as_string() = prog.source();
      break;
d199 9
a207 8
      buf.as_vector<size_t>() = map([&](const device &dev) {
            compat::ostream::buffer_t bin;
            compat::ostream s(bin);
            prog.binary(dev).serialize(s);
            return bin.size();
         },
         prog.devices());
      break;
d210 9
a218 8
      buf.as_matrix<unsigned char>() = map([&](const device &dev) {
            compat::ostream::buffer_t bin;
            compat::ostream s(bin);
            prog.binary(dev).serialize(s);
            return bin;
         },
         prog.devices());
      break;
d221 1
a221 1
      throw error(CL_INVALID_VALUE);
a222 5

   return CL_SUCCESS;

} catch (error &e) {
   return e.get();
d225 2
a226 2
CLOVER_API cl_int
clGetProgramBuildInfo(cl_program d_prog, cl_device_id d_dev,
d228 3
a230 4
                      size_t size, void *r_buf, size_t *r_size) try {
   property_buffer buf { r_buf, size, r_size };
   auto &prog = obj(d_prog);
   auto &dev = obj(d_dev);
d232 1
a232 1
   if (!count(dev, prog.context().devices()))
d237 2
a238 2
      buf.as_scalar<cl_build_status>() = prog.build_status(dev);
      break;
d241 1
a241 2
      buf.as_string() = prog.build_opts(dev);
      break;
d244 1
a244 2
      buf.as_string() = prog.build_log(dev);
      break;
d247 1
a247 1
      throw error(CL_INVALID_VALUE);
a248 5

   return CL_SUCCESS;

} catch (error &e) {
   return e.get();
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a27 19
namespace {
   void validate_build_program_common(const program &prog, cl_uint num_devs,
                                      const cl_device_id *d_devs,
                                      void (*pfn_notify)(cl_program, void *),
                                      void *user_data) {

      if ((!pfn_notify && user_data))
         throw error(CL_INVALID_VALUE);

      if (prog.kernel_ref_count())
         throw error(CL_INVALID_OPERATION);

      if (any_of([&](const device &dev) {
               return !count(dev, prog.context().devices());
            }, objs<allow_empty_tag>(d_devs, num_devs)))
         throw error(CL_INVALID_DEVICE);
   }
}

a108 22
CLOVER_API cl_program
clCreateProgramWithBuiltInKernels(cl_context d_ctx, cl_uint n,
                                  const cl_device_id *d_devs,
                                  const char *kernel_names,
                                  cl_int *r_errcode) try {
   auto &ctx = obj(d_ctx);
   auto devs = objs(d_devs, n);

   if (any_of([&](const device &dev) {
            return !count(dev, ctx.devices());
         }, devs))
      throw error(CL_INVALID_DEVICE);

   // No currently supported built-in kernels.
   throw error(CL_INVALID_VALUE);

} catch (error &e) {
   ret_error(r_errcode, e);
   return NULL;
}


d139 2
a140 26
   validate_build_program_common(prog, num_devs, d_devs, pfn_notify, user_data);

   prog.build(devs, opts);
   return CL_SUCCESS;
} catch (error &e) {
   if (e.get() == CL_COMPILE_PROGRAM_FAILURE)
      return CL_BUILD_PROGRAM_FAILURE;
   return e.get();
}

CLOVER_API cl_int
clCompileProgram(cl_program d_prog, cl_uint num_devs,
                 const cl_device_id *d_devs, const char *p_opts,
                 cl_uint num_headers, const cl_program *d_header_progs,
                 const char **header_names,
                 void (*pfn_notify)(cl_program, void *),
                 void *user_data) try {
   auto &prog = obj(d_prog);
   auto devs = (d_devs ? objs(d_devs, num_devs) :
                ref_vector<device>(prog.context().devices()));
   auto opts = (p_opts ? p_opts : "");
   header_map headers;

   validate_build_program_common(prog, num_devs, d_devs, pfn_notify, user_data);

   if (bool(num_headers) != bool(header_names))
d143 4
a146 2
   if (!prog.has_source)
      throw error(CL_INVALID_OPERATION);
d148 1
a148 13

   for_each([&](const char *name, const program &header) {
         if (!header.has_source)
            throw error(CL_INVALID_OPERATION);

         if (!any_of(key_equals(name), headers))
            headers.push_back(compat::pair<compat::string, compat::string>(
                                 name, header.source()));
      },
      range(header_names, num_headers),
      objs<allow_empty_tag>(d_header_progs, num_headers));

   prog.build(devs, opts, headers);
a160 5
clUnloadPlatformCompiler(cl_platform_id d_platform) {
   return CL_SUCCESS;
}

CLOVER_API cl_int
d193 4
a196 1
            return prog.binary(dev).size();
a208 11
      break;

   case CL_PROGRAM_NUM_KERNELS:
      buf.as_scalar<cl_uint>() = prog.symbols().size();
      break;

   case CL_PROGRAM_KERNEL_NAMES:
      buf.as_string() = fold([](const std::string &a, const module::symbol &s) {
            return ((a.empty() ? "" : a + ";") +
                    std::string(s.name.begin(), s.name.size()));
         }, std::string(), prog.symbols());
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d28 19
d128 22
d180 26
a205 2
   if (bool(num_devs) != bool(d_devs) ||
       (!pfn_notify && user_data))
d208 14
a221 4
   if (any_of([&](const device &dev) {
            return !count(dev, prog.context().devices());
         }, devs))
      throw error(CL_INVALID_DEVICE);
d223 1
a223 1
   prog.build(devs, opts);
d236 5
d273 1
a273 4
            compat::ostream::buffer_t bin;
            compat::ostream s(bin);
            prog.binary(dev).serialize(s);
            return bin.size();
d286 11
@


