head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2015.12.23.05.17.36;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.13.11;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.13.11;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.18;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.09.09;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.46.21;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@//
// Copyright 2012 Francisco Jerez
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//

#ifndef __CORE_KERNEL_HPP__
#define __CORE_KERNEL_HPP__

#include <memory>

#include "core/base.hpp"
#include "core/program.hpp"
#include "core/memory.hpp"
#include "core/sampler.hpp"
#include "pipe/p_state.h"

namespace clover {
   typedef struct _cl_kernel kernel;
   class argument;
}

struct _cl_kernel : public clover::ref_counter {
private:
   ///
   /// Class containing all the state required to execute a compute
   /// kernel.
   ///
   struct exec_context {
      exec_context(clover::kernel &kern);
      ~exec_context();

      void *bind(clover::command_queue *q);
      void unbind();

      clover::kernel &kern;
      clover::command_queue *q;

      std::vector<uint8_t> input;
      std::vector<void *> samplers;
      std::vector<pipe_sampler_view *> sviews;
      std::vector<pipe_surface *> resources;
      std::vector<pipe_resource *> g_buffers;
      std::vector<size_t> g_handles;
      size_t mem_local;

   private:
      void *st;
      pipe_compute_state cs;
   };

public:
   class argument {
   public:
      argument();

      /// \a true if the argument has been set.
      bool set() const;

      /// Storage space required for the referenced object.
      virtual size_t storage() const;

      /// Set this argument to some object.
      virtual void set(size_t size, const void *value) = 0;

      /// Allocate the necessary resources to bind the specified
      /// object to this argument, and update \a ctx accordingly.
      virtual void bind(exec_context &ctx,
                        const clover::module::argument &marg) = 0;

      /// Free any resources that were allocated in bind().
      virtual void unbind(exec_context &ctx) = 0;

   protected:
      bool __set;
   };

   _cl_kernel(clover::program &prog,
              const std::string &name,
              const std::vector<clover::module::argument> &margs);

   void launch(clover::command_queue &q,
               const std::vector<size_t> &grid_offset,
               const std::vector<size_t> &grid_size,
               const std::vector<size_t> &block_size);

   size_t mem_local() const;
   size_t mem_private() const;
   size_t max_block_size() const;

   const std::string &name() const;
   std::vector<size_t> block_size() const;

   clover::program &prog;
   std::vector<std::unique_ptr<argument>> args;

private:
   const clover::module &
   module(const clover::command_queue &q) const;

   class scalar_argument : public argument {
   public:
      scalar_argument(size_t size);

      virtual void set(size_t size, const void *value);
      virtual void bind(exec_context &ctx,
                        const clover::module::argument &marg);
      virtual void unbind(exec_context &ctx);

   private:
      size_t size;
      std::vector<uint8_t> v;
   };

   class global_argument : public argument {
   public:
      virtual void set(size_t size, const void *value);
      virtual void bind(exec_context &ctx,
                        const clover::module::argument &marg);
      virtual void unbind(exec_context &ctx);

   private:
      clover::buffer *obj;
   };

   class local_argument : public argument {
   public:
      virtual size_t storage() const;

      virtual void set(size_t size, const void *value);
      virtual void bind(exec_context &ctx,
                        const clover::module::argument &marg);
      virtual void unbind(exec_context &ctx);

   private:
      size_t __storage;
   };

   class constant_argument : public argument {
   public:
      virtual void set(size_t size, const void *value);
      virtual void bind(exec_context &ctx,
                        const clover::module::argument &marg);
      virtual void unbind(exec_context &ctx);

   private:
      clover::buffer *obj;
      pipe_surface *st;
   };

   class image_rd_argument : public argument {
   public:
      virtual void set(size_t size, const void *value);
      virtual void bind(exec_context &ctx,
                        const clover::module::argument &marg);
      virtual void unbind(exec_context &ctx);

   private:
      clover::image *obj;
      pipe_sampler_view *st;
   };

   class image_wr_argument : public argument {
   public:
      virtual void set(size_t size, const void *value);
      virtual void bind(exec_context &ctx,
                        const clover::module::argument &marg);
      virtual void unbind(exec_context &ctx);

   private:
      clover::image *obj;
      pipe_surface *st;
   };

   class sampler_argument : public argument {
   public:
      virtual void set(size_t size, const void *value);
      virtual void bind(exec_context &ctx,
                        const clover::module::argument &marg);
      virtual void unbind(exec_context &ctx);

   private:
      clover::sampler *obj;
      void *st;
   };

   std::string __name;
   exec_context exec;
};

#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d23 2
a24 2
#ifndef CLOVER_CORE_KERNEL_HPP
#define CLOVER_CORE_KERNEL_HPP
d28 1
a28 1
#include "core/object.hpp"
d35 139
a173 1
   class kernel : public ref_counter, public _cl_kernel {
d175 2
a176 191
      ///
      /// Class containing all the state required to execute a compute
      /// kernel.
      ///
      struct exec_context {
         exec_context(kernel &kern);
         ~exec_context();

         exec_context(const exec_context &) = delete;
         exec_context &
         operator=(const exec_context &) = delete;

         void *bind(intrusive_ptr<command_queue> _q);
         void unbind();

         kernel &kern;
         intrusive_ptr<command_queue> q;

         std::vector<uint8_t> input;
         std::vector<void *> samplers;
         std::vector<pipe_sampler_view *> sviews;
         std::vector<pipe_surface *> resources;
         std::vector<pipe_resource *> g_buffers;
         std::vector<size_t> g_handles;
         size_t mem_local;

      private:
         void *st;
         pipe_compute_state cs;
      };

   public:
      class argument {
      public:
         argument();

         argument(const argument &arg) = delete;
         argument &
         operator=(const argument &arg) = delete;

         /// \a true if the argument has been set.
         bool set() const;

         /// Storage space required for the referenced object.
         virtual size_t storage() const;

         /// Set this argument to some object.
         virtual void set(size_t size, const void *value) = 0;

         /// Allocate the necessary resources to bind the specified
         /// object to this argument, and update \a ctx accordingly.
         virtual void bind(exec_context &ctx,
                           const module::argument &marg) = 0;

         /// Free any resources that were allocated in bind().
         virtual void unbind(exec_context &ctx) = 0;

      protected:
         bool _set;
      };

   private:
      typedef adaptor_range<
            derefs, std::vector<std::unique_ptr<argument>> &
         > argument_range;

      typedef adaptor_range<
            derefs, const std::vector<std::unique_ptr<argument>> &
         > const_argument_range;

   public:
      kernel(clover::program &prog, const std::string &name,
             const std::vector<clover::module::argument> &margs);

      kernel(const kernel &kern) = delete;
      kernel &
      operator=(const kernel &kern) = delete;

      void launch(command_queue &q,
                  const std::vector<size_t> &grid_offset,
                  const std::vector<size_t> &grid_size,
                  const std::vector<size_t> &block_size);

      size_t mem_local() const;
      size_t mem_private() const;

      const std::string &name() const;

      std::vector<size_t>
      optimal_block_size(const command_queue &q,
                         const std::vector<size_t> &grid_size) const;
      std::vector<size_t>
      required_block_size() const;

      argument_range args();
      const_argument_range args() const;

      const intrusive_ref<clover::program> program;

   private:
      const clover::module &module(const command_queue &q) const;

      class scalar_argument : public argument {
      public:
         scalar_argument(size_t size);

         virtual void set(size_t size, const void *value);
         virtual void bind(exec_context &ctx,
                           const module::argument &marg);
         virtual void unbind(exec_context &ctx);

      private:
         size_t size;
         std::vector<uint8_t> v;
      };

      class global_argument : public argument {
      public:
         virtual void set(size_t size, const void *value);
         virtual void bind(exec_context &ctx,
                           const module::argument &marg);
         virtual void unbind(exec_context &ctx);

      private:
         buffer *buf;
      };

      class local_argument : public argument {
      public:
         virtual size_t storage() const;

         virtual void set(size_t size, const void *value);
         virtual void bind(exec_context &ctx,
                           const module::argument &marg);
         virtual void unbind(exec_context &ctx);

      private:
         size_t _storage;
      };

      class constant_argument : public argument {
      public:
         virtual void set(size_t size, const void *value);
         virtual void bind(exec_context &ctx,
                           const module::argument &marg);
         virtual void unbind(exec_context &ctx);

      private:
         buffer *buf;
         pipe_surface *st;
      };

      class image_rd_argument : public argument {
      public:
         virtual void set(size_t size, const void *value);
         virtual void bind(exec_context &ctx,
                           const module::argument &marg);
         virtual void unbind(exec_context &ctx);

      private:
         image *img;
         pipe_sampler_view *st;
      };

      class image_wr_argument : public argument {
      public:
         virtual void set(size_t size, const void *value);
         virtual void bind(exec_context &ctx,
                           const module::argument &marg);
         virtual void unbind(exec_context &ctx);

      private:
         image *img;
         pipe_surface *st;
      };

      class sampler_argument : public argument {
      public:
         virtual void set(size_t size, const void *value);
         virtual void bind(exec_context &ctx,
                           const module::argument &marg);
         virtual void unbind(exec_context &ctx);

      private:
         sampler *s;
         void *st;
      };

      std::vector<std::unique_ptr<argument>> _args;
      std::string _name;
      exec_context exec;
d178 28
a205 1
}
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d49 1
a49 2
         void *bind(intrusive_ptr<command_queue> _q,
                    const std::vector<size_t> &grid_offset);
d71 1
a71 2
         static std::unique_ptr<argument>
         create(const module::argument &marg);
a94 2
         argument();

a227 1
      const ref_holder program_ref;
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d49 2
a50 1
         void *bind(intrusive_ptr<command_queue> _q);
d72 2
a73 1
         argument();
d97 2
d232 1
@


