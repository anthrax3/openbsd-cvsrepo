head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.2.0.6
	OPENBSD_5_8_BASE:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.4
	OPENBSD_5_7_BASE:1.1.1.2
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.13.09;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.13.09;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.18;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@//
// Copyright 2012 Francisco Jerez
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//

#include "api/util.hpp"
#include "core/context.hpp"

using namespace clover;

PUBLIC cl_context
clCreateContext(const cl_context_properties *props, cl_uint num_devs,
                const cl_device_id *devs,
                void (CL_CALLBACK *pfn_notify)(const char *, const void *,
                                               size_t, void *),
                void *user_data, cl_int *errcode_ret) try {
   auto mprops = property_map(props);

   if (!devs || !num_devs ||
       (!pfn_notify && user_data))
      throw error(CL_INVALID_VALUE);

   if (any_of(is_zero<cl_device_id>, devs, devs + num_devs))
      throw error(CL_INVALID_DEVICE);

   for (auto p : mprops) {
      if (p.first != CL_CONTEXT_PLATFORM)
         throw error(CL_INVALID_PROPERTY);
   }

   ret_error(errcode_ret, CL_SUCCESS);
   return new context(
      property_vector(mprops),
      std::vector<cl_device_id>(devs, devs + num_devs));

} catch(error &e) {
   ret_error(errcode_ret, e);
   return NULL;
}

PUBLIC cl_context
clCreateContextFromType(const cl_context_properties *props,
                        cl_device_type type,
                        void (CL_CALLBACK *pfn_notify)(
                           const char *, const void *, size_t, void *),
                        void *user_data, cl_int *errcode_ret) try {
   cl_platform_id platform;
   cl_uint num_platforms;
   cl_device_id dev;
   cl_int ret;

   ret = clGetPlatformIDs(1, &platform, &num_platforms);
   if (ret || !num_platforms)
      throw error(CL_INVALID_PLATFORM);

   ret = clGetDeviceIDs(platform, type, 1, &dev, 0);
   if (ret)
      throw error(CL_DEVICE_NOT_FOUND);

   return clCreateContext(props, 1, &dev, pfn_notify, user_data, errcode_ret);

} catch(error &e) {
   ret_error(errcode_ret, e);
   return NULL;
}

PUBLIC cl_int
clRetainContext(cl_context ctx) {
   if (!ctx)
      return CL_INVALID_CONTEXT;

   ctx->retain();
   return CL_SUCCESS;
}

PUBLIC cl_int
clReleaseContext(cl_context ctx) {
   if (!ctx)
      return CL_INVALID_CONTEXT;

   if (ctx->release())
      delete ctx;

   return CL_SUCCESS;
}

PUBLIC cl_int
clGetContextInfo(cl_context ctx, cl_context_info param,
                 size_t size, void *buf, size_t *size_ret) {
   if (!ctx)
      return CL_INVALID_CONTEXT;

   switch (param) {
   case CL_CONTEXT_REFERENCE_COUNT:
      return scalar_property<cl_uint>(buf, size, size_ret, ctx->ref_count());

   case CL_CONTEXT_NUM_DEVICES:
      return scalar_property<cl_uint>(buf, size, size_ret, ctx->devs.size());

   case CL_CONTEXT_DEVICES:
      return vector_property<cl_device_id>(buf, size, size_ret, ctx->devs);

   case CL_CONTEXT_PROPERTIES:
      return vector_property<cl_context_properties>(buf, size, size_ret,
                                                    ctx->props());

   default:
      return CL_INVALID_VALUE;
   }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a24 1
#include "core/platform.hpp"
d28 3
a30 3
CLOVER_API cl_context
clCreateContext(const cl_context_properties *d_props, cl_uint num_devs,
                const cl_device_id *d_devs,
d33 2
a34 3
                void *user_data, cl_int *r_errcode) try {
   auto props = obj<property_list_tag>(d_props);
   auto devs = objs(d_devs, num_devs);
d36 2
a37 1
   if (!pfn_notify && user_data)
d40 5
a44 4
   for (auto &prop : props) {
      if (prop.first == CL_CONTEXT_PLATFORM)
         obj(prop.second.as<cl_platform_id>());
      else
d48 4
a51 2
   ret_error(r_errcode, CL_SUCCESS);
   return desc(new context(props, devs));
d53 2
a54 2
} catch (error &e) {
   ret_error(r_errcode, e);
d58 2
a59 2
CLOVER_API cl_context
clCreateContextFromType(const cl_context_properties *d_props,
d63 2
a64 2
                        void *user_data, cl_int *r_errcode) try {
   cl_platform_id d_platform;
d66 1
a67 2
   std::vector<cl_device_id> devs;
   cl_uint num_devices;
d69 1
a69 1
   ret = clGetPlatformIDs(1, &d_platform, &num_platforms);
d73 1
a73 5
   ret = clGetDeviceIDs(d_platform, type, 0, NULL, &num_devices);
   if (ret)
      throw error(CL_DEVICE_NOT_FOUND);
   devs.resize(num_devices);
   ret = clGetDeviceIDs(d_platform, type, num_devices, devs.data(), 0);
d77 1
a77 2
   return clCreateContext(d_props, num_devices, devs.data(), pfn_notify,
                          user_data, r_errcode);
d79 2
a80 2
} catch (error &e) {
   ret_error(r_errcode, e);
d84 6
a89 3
CLOVER_API cl_int
clRetainContext(cl_context d_ctx) try {
   obj(d_ctx).retain();
d91 1
d93 4
a96 3
} catch (error &e) {
   return e.get();
}
d98 2
a99 4
CLOVER_API cl_int
clReleaseContext(cl_context d_ctx) try {
   if (obj(d_ctx).release())
      delete pobj(d_ctx);
a101 3

} catch (error &e) {
   return e.get();
d104 5
a108 5
CLOVER_API cl_int
clGetContextInfo(cl_context d_ctx, cl_context_info param,
                 size_t size, void *r_buf, size_t *r_size) try {
   property_buffer buf { r_buf, size, r_size };
   auto &ctx = obj(d_ctx);
d112 1
a112 2
      buf.as_scalar<cl_uint>() = ctx.ref_count();
      break;
d115 1
a115 2
      buf.as_scalar<cl_uint>() = ctx.devices().size();
      break;
d118 1
a118 2
      buf.as_vector<cl_device_id>() = descs(ctx.devices());
      break;
d121 2
a122 2
      buf.as_vector<cl_context_properties>() = desc(ctx.properties());
      break;
d125 1
a125 1
      throw error(CL_INVALID_VALUE);
a126 5

   return CL_SUCCESS;

} catch (error &e) {
   return e.get();
@

