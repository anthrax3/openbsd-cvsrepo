head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2015.12.23.05.17.36;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.13.11;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.13.11;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.18;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.09.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.46.21;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@//
// Copyright 2012 Francisco Jerez
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//

#include "core/program.hpp"
#include "core/compiler.hpp"

using namespace clover;

_cl_program::_cl_program(clover::context &ctx,
                         const std::string &source) :
   ctx(ctx), __source(source) {
}

_cl_program::_cl_program(clover::context &ctx,
                         const std::vector<clover::device *> &devs,
                         const std::vector<clover::module> &binaries) :
   ctx(ctx) {
   for_each([&](clover::device *dev, const clover::module &bin) {
         __binaries.insert({ dev, bin });
      },
      devs.begin(), devs.end(), binaries.begin());
}

void
_cl_program::build(const std::vector<clover::device *> &devs,
                   const char *opts) {

   for (auto dev : devs) {
      __binaries.erase(dev);
      __logs.erase(dev);
      __opts.erase(dev);

      __opts.insert({ dev, opts });
      try {
         auto module = (dev->ir_format() == PIPE_SHADER_IR_TGSI ?
                        compile_program_tgsi(__source) :
                        compile_program_llvm(__source, dev->ir_format(),
                        dev->ir_target(), build_opts(dev)));
         __binaries.insert({ dev, module });

      } catch (build_error &e) {
         __logs.insert({ dev, e.what() });
         throw error(CL_BUILD_PROGRAM_FAILURE);
      } catch (invalid_option_error &e) {
         throw error(CL_INVALID_BUILD_OPTIONS);
      }
   }
}

const std::string &
_cl_program::source() const {
   return __source;
}

const std::map<clover::device *, clover::module> &
_cl_program::binaries() const {
   return __binaries;
}

cl_build_status
_cl_program::build_status(clover::device *dev) const {
   return __binaries.count(dev) ? CL_BUILD_SUCCESS : CL_BUILD_NONE;
}

std::string
_cl_program::build_opts(clover::device *dev) const {
   return __opts.count(dev) ? __opts.find(dev)->second : "";
}

std::string
_cl_program::build_log(clover::device *dev) const {
   return __logs.count(dev) ? __logs.find(dev)->second : "";
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d28 3
a30 2
program::program(clover::context &ctx, const std::string &source) :
   has_source(true), context(ctx), _source(source) {
d33 6
a38 7
program::program(clover::context &ctx,
                 const ref_vector<device> &devs,
                 const std::vector<module> &binaries) :
   has_source(false), context(ctx),
   _devices(devs) {
   for_each([&](device &dev, const module &bin) {
         _binaries.insert({ &dev, bin });
d40 1
a40 1
      devs, binaries);
d44 21
a64 22
program::build(const ref_vector<device> &devs, const char *opts) {
   if (has_source) {
      _devices = devs;

      for (auto &dev : devs) {
         _binaries.erase(&dev);
         _logs.erase(&dev);
         _opts.erase(&dev);

         _opts.insert({ &dev, opts });

         try {
            auto module = (dev.ir_format() == PIPE_SHADER_IR_TGSI ?
                           compile_program_tgsi(_source) :
                           compile_program_llvm(_source, dev.ir_format(),
                                                dev.ir_target(), build_opts(dev)));
            _binaries.insert({ &dev, module });

         } catch (build_error &e) {
            _logs.insert({ &dev, e.what() });
            throw;
         }
d70 2
a71 7
program::source() const {
   return _source;
}

program::device_range
program::devices() const {
   return map(evals(), _devices);
d74 3
a76 3
const module &
program::binary(const device &dev) const {
   return _binaries.find(&dev)->second;
d80 2
a81 5
program::build_status(const device &dev) const {
   if (_binaries.count(&dev))
      return CL_BUILD_SUCCESS;
   else
      return CL_BUILD_NONE;
d85 2
a86 2
program::build_opts(const device &dev) const {
   return _opts.count(&dev) ? _opts.find(&dev)->second : "";
d90 2
a91 10
program::build_log(const device &dev) const {
   return _logs.count(&dev) ? _logs.find(&dev)->second : "";
}

const compat::vector<module::symbol> &
program::symbols() const {
   if (_binaries.empty())
      throw error(CL_INVALID_PROGRAM_EXECUTABLE);

   return _binaries.begin()->second.syms;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d24 1
d29 1
a29 1
   has_source(true), context(ctx), _source(source), _kernel_ref_counter(0) {
d36 1
a36 1
   _devices(devs), _kernel_ref_counter(0) {
d44 1
a44 2
program::build(const ref_vector<device> &devs, const char *opts,
               const header_map &headers) {
a54 2
         compat::string log;

d58 2
a59 4
                           compile_program_llvm(_source, headers,
                                                dev.ir_format(),
                                                dev.ir_target(), build_opts(dev),
                                                log));
d61 3
a63 3
            _logs.insert({ &dev, log });
         } catch (const build_error &) {
            _logs.insert({ &dev, log });
a108 5
}

unsigned
program::kernel_ref_count() const {
   return _kernel_ref_counter.ref_count();
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@a23 1
#include "core/compiler.hpp"
d28 1
a28 1
   has_source(true), context(ctx), _source(source) {
d35 1
a35 1
   _devices(devs) {
d43 2
a44 1
program::build(const ref_vector<device> &devs, const char *opts) {
d55 2
d60 4
a63 2
                           compile_program_llvm(_source, dev.ir_format(),
                                                dev.ir_target(), build_opts(dev)));
d65 3
a67 3

         } catch (build_error &e) {
            _logs.insert({ &dev, e.what() });
d113 5
@


