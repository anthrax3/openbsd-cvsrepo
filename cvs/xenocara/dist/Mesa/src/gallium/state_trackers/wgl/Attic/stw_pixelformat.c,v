head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.38;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.54;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.17;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.56;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.52;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.07;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.34;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.21;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.09.42;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "pipe/p_format.h"
#include "pipe/p_defines.h"
#include "pipe/p_screen.h"

#include "util/u_format.h"
#include "util/u_debug.h"
#include "util/u_memory.h"

#include "stw_icd.h"
#include "stw_device.h"
#include "stw_pixelformat.h"
#include "stw_tls.h"


struct stw_pf_color_info
{
   enum pipe_format format;
   struct {
      unsigned char red;
      unsigned char green;
      unsigned char blue;
      unsigned char alpha;
   } bits;
   struct {
      unsigned char red;
      unsigned char green;
      unsigned char blue;
      unsigned char alpha;
   } shift;
};

struct stw_pf_depth_info
{
   enum pipe_format format;
   struct {
      unsigned char depth;
      unsigned char stencil;
   } bits;
};


/* NOTE: order matters, since in otherwise equal circumstances the first
 * format listed will get chosen */

static const struct stw_pf_color_info
stw_pf_color[] = {
   /* no-alpha */
   { PIPE_FORMAT_B8G8R8X8_UNORM,    { 8,  8,  8,  0}, {16,  8,  0,  0} },
   { PIPE_FORMAT_X8R8G8B8_UNORM,    { 8,  8,  8,  0}, { 8, 16, 24,  0} },
   { PIPE_FORMAT_B5G6R5_UNORM,      { 5,  6,  5,  0}, {11,  5,  0,  0} },
   /* alpha */
   { PIPE_FORMAT_B8G8R8A8_UNORM,    { 8,  8,  8,  8}, {16,  8,  0, 24} },
   { PIPE_FORMAT_A8R8G8B8_UNORM,    { 8,  8,  8,  8}, { 8, 16, 24,  0} },
#if 0
   { PIPE_FORMAT_R10G10B10A2_UNORM, {10, 10, 10,  2}, { 0, 10, 20, 30} },
#endif
   { PIPE_FORMAT_B5G5R5A1_UNORM,    { 5,  5,  5,  1}, {10,  5,  0, 15} },
   { PIPE_FORMAT_B4G4R4A4_UNORM,    { 4,  4,  4,  4}, {16,  4,  0, 12} }
};

static const struct stw_pf_color_info
stw_pf_color_extended[] = {
    { PIPE_FORMAT_R32G32B32A32_FLOAT, { 32,  32, 32,  32}, { 0,  32, 64, 96} }
};

static const struct stw_pf_depth_info 
stw_pf_depth_stencil[] = {
   /* pure depth */
   { PIPE_FORMAT_Z32_UNORM,   {32, 0} },
   { PIPE_FORMAT_X8Z24_UNORM, {24, 0} },
   { PIPE_FORMAT_Z24X8_UNORM, {24, 0} },
   { PIPE_FORMAT_Z16_UNORM,   {16, 0} },
   /* combined depth-stencil */
   { PIPE_FORMAT_Z24_UNORM_S8_UINT, {24, 8} },
   { PIPE_FORMAT_S8_UINT_Z24_UNORM, {24, 8} }
};


static const boolean 
stw_pf_doublebuffer[] = {
   FALSE,
   TRUE,
};


const unsigned 
stw_pf_multisample[] = {
   0,
   4
};


static void
stw_pixelformat_add(
   struct stw_device *stw_dev,
   boolean extended,
   const struct stw_pf_color_info *color,
   const struct stw_pf_depth_info *depth,
   unsigned accum,
   boolean doublebuffer,
   unsigned samples )
{
   struct stw_pixelformat_info *pfi;
   
   assert(stw_dev->pixelformat_extended_count < STW_MAX_PIXELFORMATS);
   if(stw_dev->pixelformat_extended_count >= STW_MAX_PIXELFORMATS)
      return;

   assert(util_format_get_component_bits(color->format, UTIL_FORMAT_COLORSPACE_RGB, 0) == color->bits.red);
   assert(util_format_get_component_bits(color->format, UTIL_FORMAT_COLORSPACE_RGB, 1) == color->bits.green);
   assert(util_format_get_component_bits(color->format, UTIL_FORMAT_COLORSPACE_RGB, 2) == color->bits.blue);
   assert(util_format_get_component_bits(color->format, UTIL_FORMAT_COLORSPACE_RGB, 3) == color->bits.alpha);
   assert(util_format_get_component_bits(depth->format, UTIL_FORMAT_COLORSPACE_ZS, 0) == depth->bits.depth);
   assert(util_format_get_component_bits(depth->format, UTIL_FORMAT_COLORSPACE_ZS, 1) == depth->bits.stencil);
   
   pfi = &stw_dev->pixelformats[stw_dev->pixelformat_extended_count];
   
   memset(pfi, 0, sizeof *pfi);
   
   pfi->pfd.nSize = sizeof pfi->pfd;
   pfi->pfd.nVersion = 1;

   pfi->pfd.dwFlags = PFD_SUPPORT_OPENGL;
   
   /* TODO: also support non-native pixel formats */
   if (!extended) {
      pfi->pfd.dwFlags |= PFD_DRAW_TO_WINDOW;
   }

   /* See http://www.opengl.org/pipeline/article/vol003_7/ */
   pfi->pfd.dwFlags |= PFD_SUPPORT_COMPOSITION;

   if (doublebuffer)
      pfi->pfd.dwFlags |= PFD_DOUBLEBUFFER | PFD_SWAP_COPY;
   
   pfi->pfd.iPixelType = PFD_TYPE_RGBA;

   pfi->pfd.cColorBits = color->bits.red + color->bits.green + color->bits.blue + color->bits.alpha;
   pfi->pfd.cRedBits = color->bits.red;
   pfi->pfd.cRedShift = color->shift.red;
   pfi->pfd.cGreenBits = color->bits.green;
   pfi->pfd.cGreenShift = color->shift.green;
   pfi->pfd.cBlueBits = color->bits.blue;
   pfi->pfd.cBlueShift = color->shift.blue;
   pfi->pfd.cAlphaBits = color->bits.alpha;
   pfi->pfd.cAlphaShift = color->shift.alpha;
   pfi->pfd.cAccumBits = 4*accum;
   pfi->pfd.cAccumRedBits = accum;
   pfi->pfd.cAccumGreenBits = accum;
   pfi->pfd.cAccumBlueBits = accum;
   pfi->pfd.cAccumAlphaBits = accum;
   pfi->pfd.cDepthBits = depth->bits.depth;
   pfi->pfd.cStencilBits = depth->bits.stencil;
   pfi->pfd.cAuxBuffers = 0;
   pfi->pfd.iLayerType = 0;
   pfi->pfd.bReserved = 0;
   pfi->pfd.dwLayerMask = 0;
   pfi->pfd.dwVisibleMask = 0;
   pfi->pfd.dwDamageMask = 0;

   /*
    * since state trackers can allocate depth/stencil/accum buffers, we provide
    * only color buffers here
    */
   pfi->stvis.buffer_mask = ST_ATTACHMENT_FRONT_LEFT_MASK;
   if (doublebuffer)
      pfi->stvis.buffer_mask |= ST_ATTACHMENT_BACK_LEFT_MASK;

   pfi->stvis.color_format = color->format;
   pfi->stvis.depth_stencil_format = depth->format;

   pfi->stvis.accum_format = (accum) ?
      PIPE_FORMAT_R16G16B16A16_SNORM : PIPE_FORMAT_NONE;

   pfi->stvis.samples = samples;
   pfi->stvis.render_buffer = ST_ATTACHMENT_INVALID;
   
   ++stw_dev->pixelformat_extended_count;
   
   if(!extended) {
      ++stw_dev->pixelformat_count;
      assert(stw_dev->pixelformat_count == stw_dev->pixelformat_extended_count);
   }
}


/**
 * Add the depth/stencil/accum/ms variants for a particular color format.
 */
static void
add_color_format_variants(const struct stw_pf_color_info *color,
                          boolean extended)
{
   struct pipe_screen *screen = stw_dev->screen;
   unsigned ms, db, ds, acc;
   unsigned bind_flags = PIPE_BIND_RENDER_TARGET;

   if (!extended) {
      bind_flags |= PIPE_BIND_DISPLAY_TARGET;
   }

   if (!screen->is_format_supported(screen, color->format,
                                    PIPE_TEXTURE_2D, 0, bind_flags)) {
      return;
   }

   for (ms = 0; ms < Elements(stw_pf_multisample); ms++) {
      unsigned samples = stw_pf_multisample[ms];

      /* FIXME: re-enabled MSAA when we can query it */
      if (samples)
         continue;

      for (db = 0; db < Elements(stw_pf_doublebuffer); db++) {
         unsigned doublebuffer = stw_pf_doublebuffer[db];

         for (ds = 0; ds < Elements(stw_pf_depth_stencil); ds++) {
            const struct stw_pf_depth_info *depth = &stw_pf_depth_stencil[ds];

            if (!screen->is_format_supported(screen, depth->format,
                                             PIPE_TEXTURE_2D, 0,
                                             PIPE_BIND_DEPTH_STENCIL)) {
               continue;
            }

            for (acc = 0; acc < 2; acc++) {
               stw_pixelformat_add(stw_dev, extended, color, depth,
                                   acc * 16, doublebuffer, samples);
            }
         }
      }
   }
}


void
stw_pixelformat_init( void )
{
   unsigned i;

   assert( !stw_dev->pixelformat_count );
   assert( !stw_dev->pixelformat_extended_count );

   /* normal, displayable formats */
   for (i = 0; i < Elements(stw_pf_color); i++) {
      add_color_format_variants(&stw_pf_color[i], FALSE);
   }

   /* extended, pbuffer-only formats */
   for (i = 0; i < Elements(stw_pf_color_extended); i++) {
      add_color_format_variants(&stw_pf_color_extended[i], TRUE);
   }

   assert( stw_dev->pixelformat_count <= stw_dev->pixelformat_extended_count );
   assert( stw_dev->pixelformat_extended_count <= STW_MAX_PIXELFORMATS );
}

uint
stw_pixelformat_get_count( void )
{
   return stw_dev->pixelformat_count;
}

uint
stw_pixelformat_get_extended_count( void )
{
   return stw_dev->pixelformat_extended_count;
}

const struct stw_pixelformat_info *
stw_pixelformat_get_info( int iPixelFormat )
{
   int index;

   if (iPixelFormat <= 0) {
      return NULL;
   }

   index = iPixelFormat - 1;
   if (index >= stw_dev->pixelformat_extended_count) {
      return NULL;
   }

   return &stw_dev->pixelformats[index];
}


LONG APIENTRY
DrvDescribePixelFormat(
   HDC hdc,
   INT iPixelFormat,
   ULONG cjpfd,
   PIXELFORMATDESCRIPTOR *ppfd )
{
   uint count;
   const struct stw_pixelformat_info *pfi;

   (void) hdc;

   if (!stw_dev)
      return 0;

   count = stw_pixelformat_get_count();

   if (ppfd == NULL)
      return count;
   if (cjpfd != sizeof( PIXELFORMATDESCRIPTOR ))
      return 0;

   pfi = stw_pixelformat_get_info( iPixelFormat );
   if (!pfi) {
      return 0;
   }
   
   memcpy(ppfd, &pfi->pfd, sizeof( PIXELFORMATDESCRIPTOR ));

   return count;
}

BOOL APIENTRY
DrvDescribeLayerPlane(
   HDC hdc,
   INT iPixelFormat,
   INT iLayerPlane,
   UINT nBytes,
   LPLAYERPLANEDESCRIPTOR plpd )
{
   assert(0);
   return FALSE;
}

int APIENTRY
DrvGetLayerPaletteEntries(
   HDC hdc,
   INT iLayerPlane,
   INT iStart,
   INT cEntries,
   COLORREF *pcr )
{
   assert(0);
   return 0;
}

int APIENTRY
DrvSetLayerPaletteEntries(
   HDC hdc,
   INT iLayerPlane,
   INT iStart,
   INT cEntries,
   CONST COLORREF *pcr )
{
   assert(0);
   return 0;
}

BOOL APIENTRY
DrvRealizeLayerPalette(
   HDC hdc,
   INT iLayerPlane,
   BOOL bRealize )
{
   assert(0);
   return FALSE;
}

/* Only used by the wgl code, but have it here to avoid exporting the
 * pixelformat.h functionality.
 */
int stw_pixelformat_choose( HDC hdc,
                            CONST PIXELFORMATDESCRIPTOR *ppfd )
{
   uint count;
   uint index;
   uint bestindex;
   uint bestdelta;

   (void) hdc;

   count = stw_pixelformat_get_extended_count();
   bestindex = 0;
   bestdelta = ~0U;

   for (index = 1; index <= count; index++) {
      uint delta = 0;
      const struct stw_pixelformat_info *pfi = stw_pixelformat_get_info( index );

      if (!(ppfd->dwFlags & PFD_DOUBLEBUFFER_DONTCARE) &&
          !!(ppfd->dwFlags & PFD_DOUBLEBUFFER) !=
          !!(pfi->pfd.dwFlags & PFD_DOUBLEBUFFER))
         continue;

      /* FIXME: Take in account individual channel bits */
      if (ppfd->cColorBits != pfi->pfd.cColorBits)
         delta += 8;

      if (ppfd->cDepthBits != pfi->pfd.cDepthBits)
         delta += 4;

      if (ppfd->cStencilBits != pfi->pfd.cStencilBits)
         delta += 2;

      if (ppfd->cAlphaBits != pfi->pfd.cAlphaBits)
         delta++;

      if (delta < bestdelta) {
         bestindex = index;
         bestdelta = delta;
         if (bestdelta == 0)
            break;
      }
   }

   return bestindex;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d161 1
a161 1
      pfi->pfd.dwFlags |= PFD_DOUBLEBUFFER | PFD_SWAP_EXCHANGE;
d217 1
a217 1
static unsigned
a223 1
   unsigned num_added = 0;
d231 1
a231 1
      return 0;
a255 1
               num_added++;
a259 2

   return num_added;
a266 1
   unsigned num_formats = 0;
d273 1
a273 1
      num_formats += add_color_format_variants(&stw_pf_color[i], FALSE);
a274 1
   assert(num_formats > 0);
d300 1
a300 1
   unsigned index;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d161 1
a161 1
      pfi->pfd.dwFlags |= PFD_DOUBLEBUFFER | PFD_SWAP_COPY;
d217 1
a217 1
static void
d224 1
d232 1
a232 1
      return;
d257 1
d262 2
d271 1
d278 1
a278 1
      add_color_format_variants(&stw_pf_color[i], FALSE);
d280 1
d306 1
a306 1
   int index;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d88 4
d101 2
a102 2
   { PIPE_FORMAT_Z24_UNORM_S8_USCALED, {24, 8} },
   { PIPE_FORMAT_S8_USCALED_Z24_UNORM, {24, 8} }
d123 1
a129 1
   boolean extended = FALSE;
d153 3
a155 1
   pfi->pfd.dwFlags |= PFD_DRAW_TO_WINDOW;
d213 7
a219 2
void
stw_pixelformat_init( void )
d222 14
a235 4
   unsigned i, j, k, l;
   
   assert( !stw_dev->pixelformat_count );
   assert( !stw_dev->pixelformat_extended_count );
a236 3
   for(i = 0; i < Elements(stw_pf_multisample); ++i) {
      unsigned samples = stw_pf_multisample[i];
      
d238 1
a238 1
      if(samples)
d241 11
a251 17
      for(j = 0; j < Elements(stw_pf_color); ++j) {
         const struct stw_pf_color_info *color = &stw_pf_color[j];
         
         if(!screen->is_format_supported(screen, color->format, PIPE_TEXTURE_2D,
                                         0, PIPE_BIND_RENDER_TARGET |
                                         PIPE_BIND_DISPLAY_TARGET))
            continue;
         
         for(k = 0; k < Elements(stw_pf_doublebuffer); ++k) {
            unsigned doublebuffer = stw_pf_doublebuffer[k];
            
            for(l = 0; l < Elements(stw_pf_depth_stencil); ++l) {
               const struct stw_pf_depth_info *depth = &stw_pf_depth_stencil[l];
               
               if(!screen->is_format_supported(screen, depth->format, PIPE_TEXTURE_2D, 
                                               0, PIPE_BIND_DEPTH_STENCIL))
                  continue;
d253 3
a255 2
               stw_pixelformat_add( stw_dev, color, depth,  0, doublebuffer, samples );
               stw_pixelformat_add( stw_dev, color, depth, 16, doublebuffer, samples );
d260 21
a280 1
   
d298 1
a298 1
stw_pixelformat_get_info( uint index )
d300 10
a309 1
   assert( index < stw_dev->pixelformat_extended_count );
a322 1
   uint index;
d330 1
a330 2
   count = stw_pixelformat_get_extended_count();
   index = (uint) iPixelFormat - 1;
d334 1
a334 1
   if (index >= count || cjpfd != sizeof( PIXELFORMATDESCRIPTOR ))
d337 4
a340 1
   pfi = stw_pixelformat_get_info( index );
d406 2
a407 2
   count = stw_pixelformat_get_count();
   bestindex = count;
d410 1
a410 1
   for (index = 0; index < count; index++) {
d440 1
a440 4
   if (bestindex == count)
      return 0;

   return bestindex + 1;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d228 1
a228 1
                                         PIPE_BIND_DISPLAY_TARGET, 0))
d238 1
a238 1
                                               0, PIPE_BIND_DEPTH_STENCIL, 0))
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a27 3
#include "main/mtypes.h"
#include "main/context.h"

d34 1
d97 2
a98 2
   { PIPE_FORMAT_Z24S8_UNORM, {24, 8} },
   { PIPE_FORMAT_S8Z24_UNORM, {24, 8} }
a142 3
   pfi->color_format = color->format;
   pfi->depth_stencil_format = depth->format;
   
d182 16
a197 5
   if(samples) {
      pfi->numSampleBuffers = 1;
      pfi->numSamples = samples;
      extended = TRUE;
   }
d226 3
a228 3
         if(!screen->is_format_supported(screen, color->format, PIPE_TEXTURE_2D, 
                                         PIPE_TEXTURE_USAGE_RENDER_TARGET |
                                         PIPE_TEXTURE_USAGE_DISPLAY_TARGET, 0))
d238 1
a238 1
                                               PIPE_TEXTURE_USAGE_DEPTH_STENCIL, 0))
a269 23
}


void
stw_pixelformat_visual(GLvisual *visual, 
                       const struct stw_pixelformat_info *pfi )
{
   memset(visual, 0, sizeof *visual);
   _mesa_initialize_visual(
      visual,
      (pfi->pfd.dwFlags & PFD_DOUBLEBUFFER) ? GL_TRUE : GL_FALSE,
      (pfi->pfd.dwFlags & PFD_STEREO) ? GL_TRUE : GL_FALSE,
      pfi->pfd.cRedBits,
      pfi->pfd.cGreenBits,
      pfi->pfd.cBlueBits,
      pfi->pfd.cAlphaBits,
      pfi->pfd.cDepthBits,
      pfi->pfd.cStencilBits,
      pfi->pfd.cAccumRedBits,
      pfi->pfd.cAccumGreenBits,
      pfi->pfd.cAccumBlueBits,
      pfi->pfd.cAccumAlphaBits,
      pfi->numSamples );
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d28 3
a36 1
#include "util/u_memory.h"
d99 2
a100 2
   { PIPE_FORMAT_Z24_UNORM_S8_USCALED, {24, 8} },
   { PIPE_FORMAT_S8_USCALED_Z24_UNORM, {24, 8} }
d145 3
d187 5
a191 16
   /*
    * since state trackers can allocate depth/stencil/accum buffers, we provide
    * only color buffers here
    */
   pfi->stvis.buffer_mask = ST_ATTACHMENT_FRONT_LEFT_MASK;
   if (doublebuffer)
      pfi->stvis.buffer_mask |= ST_ATTACHMENT_BACK_LEFT_MASK;

   pfi->stvis.color_format = color->format;
   pfi->stvis.depth_stencil_format = depth->format;

   pfi->stvis.accum_format = (accum) ?
      PIPE_FORMAT_R16G16B16A16_SNORM : PIPE_FORMAT_NONE;

   pfi->stvis.samples = samples;
   pfi->stvis.render_buffer = ST_ATTACHMENT_INVALID;
d220 3
a222 3
         if(!screen->is_format_supported(screen, color->format, PIPE_TEXTURE_2D,
                                         0, PIPE_BIND_RENDER_TARGET |
                                         PIPE_BIND_DISPLAY_TARGET, 0))
d232 1
a232 1
                                               0, PIPE_BIND_DEPTH_STENCIL, 0))
d264 23
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a87 4
static const struct stw_pf_color_info
stw_pf_color_extended[] = {
    { PIPE_FORMAT_R32G32B32A32_FLOAT, { 32,  32, 32,  32}, { 0,  32, 64, 96} }
};
d97 2
a98 2
   { PIPE_FORMAT_Z24_UNORM_S8_UINT, {24, 8} },
   { PIPE_FORMAT_S8_UINT_Z24_UNORM, {24, 8} }
a118 1
   boolean extended,
d125 1
d149 1
a149 3
   if (!extended) {
      pfi->pfd.dwFlags |= PFD_DRAW_TO_WINDOW;
   }
d207 2
a208 7

/**
 * Add the depth/stencil/accum/ms variants for a particular color format.
 */
static void
add_color_format_variants(const struct stw_pf_color_info *color,
                          boolean extended)
d211 4
a214 14
   unsigned ms, db, ds, acc;
   unsigned bind_flags = PIPE_BIND_RENDER_TARGET;

   if (!extended) {
      bind_flags |= PIPE_BIND_DISPLAY_TARGET;
   }

   if (!screen->is_format_supported(screen, color->format,
                                    PIPE_TEXTURE_2D, 0, bind_flags)) {
      return;
   }

   for (ms = 0; ms < Elements(stw_pf_multisample); ms++) {
      unsigned samples = stw_pf_multisample[ms];
d216 3
d220 1
a220 1
      if (samples)
d223 17
a239 11
      for (db = 0; db < Elements(stw_pf_doublebuffer); db++) {
         unsigned doublebuffer = stw_pf_doublebuffer[db];

         for (ds = 0; ds < Elements(stw_pf_depth_stencil); ds++) {
            const struct stw_pf_depth_info *depth = &stw_pf_depth_stencil[ds];

            if (!screen->is_format_supported(screen, depth->format,
                                             PIPE_TEXTURE_2D, 0,
                                             PIPE_BIND_DEPTH_STENCIL)) {
               continue;
            }
d241 2
a242 3
            for (acc = 0; acc < 2; acc++) {
               stw_pixelformat_add(stw_dev, extended, color, depth,
                                   acc * 16, doublebuffer, samples);
d247 1
a247 21
}


void
stw_pixelformat_init( void )
{
   unsigned i;

   assert( !stw_dev->pixelformat_count );
   assert( !stw_dev->pixelformat_extended_count );

   /* normal, displayable formats */
   for (i = 0; i < Elements(stw_pf_color); i++) {
      add_color_format_variants(&stw_pf_color[i], FALSE);
   }

   /* extended, pbuffer-only formats */
   for (i = 0; i < Elements(stw_pf_color_extended); i++) {
      add_color_format_variants(&stw_pf_color_extended[i], TRUE);
   }

d265 1
a265 1
stw_pixelformat_get_info( int iPixelFormat )
d267 1
a267 10
   int index;

   if (iPixelFormat <= 0) {
      return NULL;
   }

   index = iPixelFormat - 1;
   if (index >= stw_dev->pixelformat_extended_count) {
      return NULL;
   }
d281 1
d289 2
a290 1
   count = stw_pixelformat_get_count();
d294 1
a294 1
   if (cjpfd != sizeof( PIXELFORMATDESCRIPTOR ))
d297 1
a297 4
   pfi = stw_pixelformat_get_info( iPixelFormat );
   if (!pfi) {
      return 0;
   }
d363 2
a364 2
   count = stw_pixelformat_get_extended_count();
   bestindex = 0;
d367 1
a367 1
   for (index = 1; index <= count; index++) {
d397 4
a400 1
   return bestindex;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d161 1
a161 1
      pfi->pfd.dwFlags |= PFD_DOUBLEBUFFER | PFD_SWAP_EXCHANGE;
d217 1
a217 1
static unsigned
a223 1
   unsigned num_added = 0;
d231 1
a231 1
      return 0;
a255 1
               num_added++;
a259 2

   return num_added;
a266 1
   unsigned num_formats = 0;
d273 1
a273 1
      num_formats += add_color_format_variants(&stw_pf_color[i], FALSE);
a274 1
   assert(num_formats > 0);
d300 1
a300 1
   unsigned index;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d161 1
a161 1
      pfi->pfd.dwFlags |= PFD_DOUBLEBUFFER | PFD_SWAP_COPY;
d217 1
a217 1
static void
d224 1
d232 1
a232 1
      return;
d257 1
d262 2
d271 1
d278 1
a278 1
      add_color_format_variants(&stw_pf_color[i], FALSE);
d280 1
d306 1
a306 1
   int index;
@


