head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.38;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.17;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2013.09.05.14.01.52;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.34;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.09.41;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.46.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008-2009 Vmware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include <windows.h>

#include "pipe/p_format.h"
#include "pipe/p_screen.h"
#include "util/u_format.h"
#include "util/u_memory.h"
#include "hud/hud_context.h"
#include "state_tracker/st_api.h"

#include "stw_icd.h"
#include "stw_framebuffer.h"
#include "stw_device.h"
#include "stw_winsys.h"
#include "stw_tls.h"
#include "stw_context.h"
#include "stw_st.h"


/**
 * Search the framebuffer with the matching HWND while holding the
 * stw_dev::fb_mutex global lock.
 */
static INLINE struct stw_framebuffer *
stw_framebuffer_from_hwnd_locked(
   HWND hwnd )
{
   struct stw_framebuffer *fb;

   for (fb = stw_dev->fb_head; fb != NULL; fb = fb->next)
      if (fb->hWnd == hwnd) {
         pipe_mutex_lock(fb->mutex);
         break;
      }

   return fb;
}


/**
 * Destroy this framebuffer. Both stw_dev::fb_mutex and stw_framebuffer::mutex
 * must be held, by this order.  If there are still references to the
 * framebuffer, nothing will happen.
 */
static INLINE void
stw_framebuffer_destroy_locked(
   struct stw_framebuffer *fb )
{
   struct stw_framebuffer **link;

   /* check the reference count */
   fb->refcnt--;
   if (fb->refcnt) {
      pipe_mutex_unlock( fb->mutex );
      return;
   }

   link = &stw_dev->fb_head;
   while (*link != fb)
      link = &(*link)->next;
   assert(*link);
   *link = fb->next;
   fb->next = NULL;

   if(fb->shared_surface)
      stw_dev->stw_winsys->shared_surface_close(stw_dev->screen, fb->shared_surface);

   stw_st_destroy_framebuffer_locked(fb->stfb);
   
   pipe_mutex_unlock( fb->mutex );

   pipe_mutex_destroy( fb->mutex );
   
   FREE( fb );
}


void
stw_framebuffer_release(
   struct stw_framebuffer *fb)
{
   assert(fb);
   pipe_mutex_unlock( fb->mutex );
}


static INLINE void
stw_framebuffer_get_size( struct stw_framebuffer *fb )
{
   LONG width, height;
   RECT client_rect;
   RECT window_rect;
   POINT client_pos;

   /*
    * Sanity checking.
    */

   assert(fb->hWnd);
   assert(fb->width && fb->height);
   assert(fb->client_rect.right  == fb->client_rect.left + fb->width);
   assert(fb->client_rect.bottom == fb->client_rect.top  + fb->height);

   /*
    * Get the client area size.
    */

   if (!GetClientRect(fb->hWnd, &client_rect)) {
      return;
   }

   assert(client_rect.left == 0);
   assert(client_rect.top == 0);
   width  = client_rect.right  - client_rect.left;
   height = client_rect.bottom - client_rect.top;

   fb->minimized = width == 0 || height == 0;

   if (width <= 0 || height <= 0) {
      /*
       * When the window is minimized GetClientRect will return zeros.  Simply
       * preserve the current window size, until the window is restored or
       * maximized again.
       */

      return;
   }

   if (width != fb->width || height != fb->height) {
      fb->must_resize = TRUE;
      fb->width = width; 
      fb->height = height; 
   }

   client_pos.x = 0;
   client_pos.y = 0;
   if (ClientToScreen(fb->hWnd, &client_pos) &&
       GetWindowRect(fb->hWnd, &window_rect)) {
      fb->client_rect.left = client_pos.x - window_rect.left;
      fb->client_rect.top  = client_pos.y - window_rect.top;
   }

   fb->client_rect.right  = fb->client_rect.left + fb->width;
   fb->client_rect.bottom = fb->client_rect.top  + fb->height;

#if 0
   debug_printf("\n");
   debug_printf("%s: hwnd = %p\n", __FUNCTION__, fb->hWnd);
   debug_printf("%s: client_position = (%li, %li)\n",
                __FUNCTION__, client_pos.x, client_pos.y);
   debug_printf("%s: window_rect = (%li, %li) - (%li, %li)\n",
                __FUNCTION__,
                window_rect.left, window_rect.top,
                window_rect.right, window_rect.bottom);
   debug_printf("%s: client_rect = (%li, %li) - (%li, %li)\n",
                __FUNCTION__,
                fb->client_rect.left, fb->client_rect.top,
                fb->client_rect.right, fb->client_rect.bottom);
#endif
}


/**
 * @@sa http://msdn.microsoft.com/en-us/library/ms644975(VS.85).aspx
 * @@sa http://msdn.microsoft.com/en-us/library/ms644960(VS.85).aspx
 */
LRESULT CALLBACK
stw_call_window_proc(
   int nCode,
   WPARAM wParam,
   LPARAM lParam )
{
   struct stw_tls_data *tls_data;
   PCWPSTRUCT pParams = (PCWPSTRUCT)lParam;
   struct stw_framebuffer *fb;
   
   tls_data = stw_tls_get_data();
   if(!tls_data)
      return 0;
   
   if (nCode < 0 || !stw_dev)
       return CallNextHookEx(tls_data->hCallWndProcHook, nCode, wParam, lParam);

   if (pParams->message == WM_WINDOWPOSCHANGED) {
      /* We handle WM_WINDOWPOSCHANGED instead of WM_SIZE because according to
       * http://blogs.msdn.com/oldnewthing/archive/2008/01/15/7113860.aspx 
       * WM_SIZE is generated from WM_WINDOWPOSCHANGED by DefWindowProc so it 
       * can be masked out by the application. */
      LPWINDOWPOS lpWindowPos = (LPWINDOWPOS)pParams->lParam;
      if((lpWindowPos->flags & SWP_SHOWWINDOW) || 
         !(lpWindowPos->flags & SWP_NOMOVE) ||
         !(lpWindowPos->flags & SWP_NOSIZE)) {
         fb = stw_framebuffer_from_hwnd( pParams->hwnd );
         if(fb) {
            /* Size in WINDOWPOS includes the window frame, so get the size 
             * of the client area via GetClientRect.  */
            stw_framebuffer_get_size(fb);
            stw_framebuffer_release(fb);
         }
      }
   }
   else if (pParams->message == WM_DESTROY) {
      pipe_mutex_lock( stw_dev->fb_mutex );
      fb = stw_framebuffer_from_hwnd_locked( pParams->hwnd );
      if(fb)
         stw_framebuffer_destroy_locked(fb);
      pipe_mutex_unlock( stw_dev->fb_mutex );
   }

   return CallNextHookEx(tls_data->hCallWndProcHook, nCode, wParam, lParam);
}


struct stw_framebuffer *
stw_framebuffer_create(
   HDC hdc,
   int iPixelFormat )
{
   HWND hWnd;
   struct stw_framebuffer *fb;
   const struct stw_pixelformat_info *pfi;

   /* We only support drawing to a window. */
   hWnd = WindowFromDC( hdc );
   if(!hWnd)
      return NULL;
   
   fb = CALLOC_STRUCT( stw_framebuffer );
   if (fb == NULL)
      return NULL;

   fb->hWnd = hWnd;
   fb->iPixelFormat = iPixelFormat;

   /*
    * We often need a displayable pixel format to make GDI happy. Set it here (always 1, i.e.,
    * out first pixel format) where appropriat.
    */
   fb->iDisplayablePixelFormat = iPixelFormat <= stw_dev->pixelformat_count ? iPixelFormat : 1;

   fb->pfi = pfi = stw_pixelformat_get_info( iPixelFormat );
   fb->stfb = stw_st_create_framebuffer( fb );
   if (!fb->stfb) {
      FREE( fb );
      return NULL;
   }

   fb->refcnt = 1;

   /*
    * Windows can be sometimes have zero width and or height, but we ensure
    * a non-zero framebuffer size at all times.
    */

   fb->must_resize = TRUE;
   fb->width  = 1;
   fb->height = 1;
   fb->client_rect.left   = 0;
   fb->client_rect.top    = 0;
   fb->client_rect.right  = fb->client_rect.left + fb->width;
   fb->client_rect.bottom = fb->client_rect.top  + fb->height;

   stw_framebuffer_get_size(fb);

   pipe_mutex_init( fb->mutex );

   /* This is the only case where we lock the stw_framebuffer::mutex before
    * stw_dev::fb_mutex, since no other thread can know about this framebuffer
    * and we must prevent any other thread from destroying it before we return.
    */
   pipe_mutex_lock( fb->mutex );

   pipe_mutex_lock( stw_dev->fb_mutex );
   fb->next = stw_dev->fb_head;
   stw_dev->fb_head = fb;
   pipe_mutex_unlock( stw_dev->fb_mutex );

   return fb;
}

/**
 * Have ptr reference fb.  The referenced framebuffer should be locked.
 */
void
stw_framebuffer_reference(
   struct stw_framebuffer **ptr,
   struct stw_framebuffer *fb)
{
   struct stw_framebuffer *old_fb = *ptr;

   if (old_fb == fb)
      return;

   if (fb)
      fb->refcnt++;
   if (old_fb) {
      pipe_mutex_lock(stw_dev->fb_mutex);

      pipe_mutex_lock(old_fb->mutex);
      stw_framebuffer_destroy_locked(old_fb);

      pipe_mutex_unlock(stw_dev->fb_mutex);
   }

   *ptr = fb;
}


/**
 * Update the framebuffer's size if necessary.
 */
void
stw_framebuffer_update(
   struct stw_framebuffer *fb)
{
   assert(fb->stfb);
   assert(fb->height);
   assert(fb->width);
   
   /* XXX: It would be nice to avoid checking the size again -- in theory  
    * stw_call_window_proc would have cought the resize and stored the right 
    * size already, but unfortunately threads created before the DllMain is 
    * called don't get a DLL_THREAD_ATTACH notification, and there is no way
    * to know of their existing without using the not very portable PSAPI.
    */
   stw_framebuffer_get_size(fb);
}                      


void
stw_framebuffer_cleanup( void )
{
   struct stw_framebuffer *fb;
   struct stw_framebuffer *next;

   if (!stw_dev)
      return;

   pipe_mutex_lock( stw_dev->fb_mutex );

   fb = stw_dev->fb_head;
   while (fb) {
      next = fb->next;
      
      pipe_mutex_lock(fb->mutex);
      stw_framebuffer_destroy_locked(fb);
      
      fb = next;
   }
   stw_dev->fb_head = NULL;
   
   pipe_mutex_unlock( stw_dev->fb_mutex );
}


/**
 * Given an hdc, return the corresponding stw_framebuffer.
 */
static INLINE struct stw_framebuffer *
stw_framebuffer_from_hdc_locked(
   HDC hdc )
{
   HWND hwnd;

   hwnd = WindowFromDC(hdc);
   if (!hwnd) {
      return NULL;
   }

   return stw_framebuffer_from_hwnd_locked(hwnd);
}


/**
 * Given an hdc, return the corresponding stw_framebuffer.
 */
struct stw_framebuffer *
stw_framebuffer_from_hdc(
   HDC hdc )
{
   struct stw_framebuffer *fb;

   if (!stw_dev)
      return NULL;

   pipe_mutex_lock( stw_dev->fb_mutex );
   fb = stw_framebuffer_from_hdc_locked(hdc);
   pipe_mutex_unlock( stw_dev->fb_mutex );

   return fb;
}


/**
 * Given an hdc, return the corresponding stw_framebuffer.
 */
struct stw_framebuffer *
stw_framebuffer_from_hwnd(
   HWND hwnd )
{
   struct stw_framebuffer *fb;

   pipe_mutex_lock( stw_dev->fb_mutex );
   fb = stw_framebuffer_from_hwnd_locked(hwnd);
   pipe_mutex_unlock( stw_dev->fb_mutex );

   return fb;
}


BOOL APIENTRY
DrvSetPixelFormat(
   HDC hdc,
   LONG iPixelFormat )
{
   uint count;
   uint index;
   struct stw_framebuffer *fb;

   if (!stw_dev)
      return FALSE;

   index = (uint) iPixelFormat - 1;
   count = stw_pixelformat_get_count();
   if (index >= count)
      return FALSE;

   fb = stw_framebuffer_from_hdc_locked(hdc);
   if(fb) {
      /*
       * SetPixelFormat must be called only once.  However ignore 
       * pbuffers, for which the framebuffer object is created first.
       */
      boolean bPbuffer = fb->bPbuffer;

      stw_framebuffer_release( fb );

      return bPbuffer;
   }

   fb = stw_framebuffer_create(hdc, iPixelFormat);
   if(!fb) {
      return FALSE;
   }
      
   stw_framebuffer_release( fb );

   /* Some applications mistakenly use the undocumented wglSetPixelFormat 
    * function instead of SetPixelFormat, so we call SetPixelFormat here to 
    * avoid opengl32.dll's wglCreateContext to fail */
   if (GetPixelFormat(hdc) == 0) {
      BOOL bRet = SetPixelFormat(hdc, iPixelFormat, NULL);
      assert(bRet);
   }
   
   return TRUE;
}


int
stw_pixelformat_get(
   HDC hdc )
{
   int iPixelFormat = 0;
   struct stw_framebuffer *fb;

   fb = stw_framebuffer_from_hdc(hdc);
   if(fb) {
      iPixelFormat = fb->iPixelFormat;
      stw_framebuffer_release(fb);
   }
   
   return iPixelFormat;
}


BOOL APIENTRY
DrvPresentBuffers(HDC hdc, PGLPRESENTBUFFERSDATA data)
{
   struct stw_framebuffer *fb;
   struct pipe_screen *screen;
   struct pipe_resource *res;

   if (!stw_dev)
      return FALSE;

   fb = stw_framebuffer_from_hdc( hdc );
   if (fb == NULL)
      return FALSE;

   screen = stw_dev->screen;

   res = (struct pipe_resource *)data->pPrivateData;

   if(data->hSharedSurface != fb->hSharedSurface) {
      if(fb->shared_surface) {
         stw_dev->stw_winsys->shared_surface_close(screen, fb->shared_surface);
         fb->shared_surface = NULL;
      }

      fb->hSharedSurface = data->hSharedSurface;

      if(data->hSharedSurface &&
         stw_dev->stw_winsys->shared_surface_open) {
         fb->shared_surface = stw_dev->stw_winsys->shared_surface_open(screen, fb->hSharedSurface);
      }
   }

   if (!fb->minimized) {
      if (fb->shared_surface) {
         stw_dev->stw_winsys->compose(screen,
                                      res,
                                      fb->shared_surface,
                                      &fb->client_rect,
                                      data->PresentHistoryToken);
      }
      else {
         stw_dev->stw_winsys->present( screen, res, hdc );
      }
   }

   stw_framebuffer_update(fb);
   stw_notify_current_locked(fb);

   stw_framebuffer_release(fb);

   return TRUE;
}


/**
 * Queue a composition.
 *
 * It will drop the lock on success.
 */
BOOL
stw_framebuffer_present_locked(HDC hdc,
                               struct stw_framebuffer *fb,
                               struct pipe_resource *res)
{
   if(stw_dev->callbacks.wglCbPresentBuffers &&
      stw_dev->stw_winsys->compose) {
      GLCBPRESENTBUFFERSDATA data;

      memset(&data, 0, sizeof data);
      data.magic1 = 2;
      data.magic2 = 0;
      data.AdapterLuid = stw_dev->AdapterLuid;
      data.rect = fb->client_rect;
      data.pPrivateData = (void *)res;

      stw_notify_current_locked(fb);
      stw_framebuffer_release(fb);

      return stw_dev->callbacks.wglCbPresentBuffers(hdc, &data);
   }
   else {
      struct pipe_screen *screen = stw_dev->screen;

      stw_dev->stw_winsys->present( screen, res, hdc );

      stw_framebuffer_update(fb);
      stw_notify_current_locked(fb);
      stw_framebuffer_release(fb);

      return TRUE;
   }
}


BOOL APIENTRY
DrvSwapBuffers(
   HDC hdc )
{
   struct stw_context *ctx;
   struct stw_framebuffer *fb;

   if (!stw_dev)
      return FALSE;

   fb = stw_framebuffer_from_hdc( hdc );
   if (fb == NULL)
      return FALSE;

   if (!(fb->pfi->pfd.dwFlags & PFD_DOUBLEBUFFER)) {
      stw_framebuffer_release(fb);
      return TRUE;
   }

   /* Display the HUD */
   ctx = stw_current_context();
   if (ctx && ctx->hud) {
      struct pipe_resource *back =
         stw_get_framebuffer_resource(fb->stfb, ST_ATTACHMENT_BACK_LEFT);
      hud_draw(ctx->hud, back);
   }

   stw_flush_current_locked(fb);

   return stw_st_swap_framebuffer_locked(hdc, fb->stfb);
}


BOOL APIENTRY
DrvSwapLayerBuffers(
   HDC hdc,
   UINT fuPlanes )
{
   if(fuPlanes & WGL_SWAP_MAIN_PLANE)
      return DrvSwapBuffers(hdc);

   return FALSE;
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d30 1
d32 1
d71 3
a73 2
static void
stw_framebuffer_destroy_locked(struct stw_framebuffer *fb)
d91 2
a92 3
   if (fb->shared_surface)
      stw_dev->stw_winsys->shared_surface_close(stw_dev->screen,
                                                fb->shared_surface);
d95 1
a95 1

d99 1
a99 1

d105 2
a106 1
stw_framebuffer_release(struct stw_framebuffer *fb)
d113 2
a114 2
static void
stw_framebuffer_get_size(struct stw_framebuffer *fb)
d157 2
a158 2
      fb->width = width;
      fb->height = height;
d194 4
a197 1
stw_call_window_proc(int nCode, WPARAM wParam, LPARAM lParam)
d202 1
a202 1

d204 1
a204 1
   if (!tls_data)
d206 1
a206 1

d212 3
a214 4
       * http://blogs.msdn.com/oldnewthing/archive/2008/01/15/7113860.aspx
       * WM_SIZE is generated from WM_WINDOWPOSCHANGED by DefWindowProc so it
       * can be masked out by the application.
       */
d216 3
a218 3
      if ((lpWindowPos->flags & SWP_SHOWWINDOW) ||
          !(lpWindowPos->flags & SWP_NOMOVE) ||
          !(lpWindowPos->flags & SWP_NOSIZE)) {
d220 3
a222 4
         if (fb) {
            /* Size in WINDOWPOS includes the window frame, so get the size
             * of the client area via GetClientRect.
             */
d231 1
a231 1
      if (fb)
d241 3
a243 1
stw_framebuffer_create(HDC hdc, int iPixelFormat)
d251 1
a251 1
   if (!hWnd)
d253 1
a253 1

d262 2
a263 2
    * We often need a displayable pixel format to make GDI happy. Set it
    * here (always 1, i.e., out first pixel format) where appropriate.
d265 1
a265 2
   fb->iDisplayablePixelFormat = iPixelFormat <= stw_dev->pixelformat_count
      ? iPixelFormat : 1;
a306 1

d311 3
a313 2
stw_framebuffer_reference(struct stw_framebuffer **ptr,
                          struct stw_framebuffer *fb)
d339 2
a340 1
stw_framebuffer_update(struct stw_framebuffer *fb)
d345 4
a348 4

   /* XXX: It would be nice to avoid checking the size again -- in theory
    * stw_call_window_proc would have cought the resize and stored the right
    * size already, but unfortunately threads created before the DllMain is
d353 1
a353 1
}
d357 1
a357 1
stw_framebuffer_cleanup(void)
d370 1
a370 1

d373 1
a373 1

d377 1
a377 1

d404 2
a405 1
stw_framebuffer_from_hdc(HDC hdc)
d424 2
a425 1
stw_framebuffer_from_hwnd(HWND hwnd)
d438 3
a440 1
DrvSetPixelFormat(HDC hdc, LONG iPixelFormat)
d455 1
a455 1
   if (fb) {
d468 1
a468 1
   if (!fb) {
d471 1
a471 1

d474 2
a475 2
   /* Some applications mistakenly use the undocumented wglSetPixelFormat
    * function instead of SetPixelFormat, so we call SetPixelFormat here to
d481 1
a481 1

d487 2
a488 1
stw_pixelformat_get(HDC hdc)
d494 1
a494 1
   if (fb) {
d498 1
a498 1

d521 2
a522 2
   if (data->hSharedSurface != fb->hSharedSurface) {
      if (fb->shared_surface) {
d529 1
a529 1
      if (data->hSharedSurface &&
d531 1
a531 3
         fb->shared_surface =
            stw_dev->stw_winsys->shared_surface_open(screen,
                                                     fb->hSharedSurface);
d567 1
a567 1
   if (stw_dev->callbacks.wglCbPresentBuffers &&
d598 2
a599 1
DrvSwapBuffers(HDC hdc)
d631 3
a633 1
DrvSwapLayerBuffers(HDC hdc, UINT fuPlanes)
d635 1
a635 1
   if (fuPlanes & WGL_SWAP_MAIN_PLANE)
@


1.3
log
@Merge Mesa 9.2.0
@
text
@a29 1
#include "pipe/p_format.h"
a30 1
#include "util/u_format.h"
d69 2
a70 3
static INLINE void
stw_framebuffer_destroy_locked(
   struct stw_framebuffer *fb )
d88 3
a90 2
   if(fb->shared_surface)
      stw_dev->stw_winsys->shared_surface_close(stw_dev->screen, fb->shared_surface);
d93 1
a93 1
   
d97 1
a97 1
   
d103 1
a103 2
stw_framebuffer_release(
   struct stw_framebuffer *fb)
d110 2
a111 2
static INLINE void
stw_framebuffer_get_size( struct stw_framebuffer *fb )
d154 2
a155 2
      fb->width = width; 
      fb->height = height; 
d191 1
a191 4
stw_call_window_proc(
   int nCode,
   WPARAM wParam,
   LPARAM lParam )
d196 1
a196 1
   
d198 1
a198 1
   if(!tls_data)
d200 1
a200 1
   
d206 4
a209 3
       * http://blogs.msdn.com/oldnewthing/archive/2008/01/15/7113860.aspx 
       * WM_SIZE is generated from WM_WINDOWPOSCHANGED by DefWindowProc so it 
       * can be masked out by the application. */
d211 3
a213 3
      if((lpWindowPos->flags & SWP_SHOWWINDOW) || 
         !(lpWindowPos->flags & SWP_NOMOVE) ||
         !(lpWindowPos->flags & SWP_NOSIZE)) {
d215 4
a218 3
         if(fb) {
            /* Size in WINDOWPOS includes the window frame, so get the size 
             * of the client area via GetClientRect.  */
d227 1
a227 1
      if(fb)
d237 1
a237 3
stw_framebuffer_create(
   HDC hdc,
   int iPixelFormat )
d245 1
a245 1
   if(!hWnd)
d247 1
a247 1
   
d256 2
a257 2
    * We often need a displayable pixel format to make GDI happy. Set it here (always 1, i.e.,
    * out first pixel format) where appropriat.
d259 2
a260 1
   fb->iDisplayablePixelFormat = iPixelFormat <= stw_dev->pixelformat_count ? iPixelFormat : 1;
d302 1
d307 2
a308 3
stw_framebuffer_reference(
   struct stw_framebuffer **ptr,
   struct stw_framebuffer *fb)
d334 1
a334 2
stw_framebuffer_update(
   struct stw_framebuffer *fb)
d339 4
a342 4
   
   /* XXX: It would be nice to avoid checking the size again -- in theory  
    * stw_call_window_proc would have cought the resize and stored the right 
    * size already, but unfortunately threads created before the DllMain is 
d347 1
a347 1
}                      
d351 1
a351 1
stw_framebuffer_cleanup( void )
d364 1
a364 1
      
d367 1
a367 1
      
d371 1
a371 1
   
d398 1
a398 2
stw_framebuffer_from_hdc(
   HDC hdc )
d417 1
a417 2
stw_framebuffer_from_hwnd(
   HWND hwnd )
d430 1
a430 3
DrvSetPixelFormat(
   HDC hdc,
   LONG iPixelFormat )
d445 1
a445 1
   if(fb) {
d458 1
a458 1
   if(!fb) {
d461 1
a461 1
      
d464 2
a465 2
   /* Some applications mistakenly use the undocumented wglSetPixelFormat 
    * function instead of SetPixelFormat, so we call SetPixelFormat here to 
d471 1
a471 1
   
d477 1
a477 2
stw_pixelformat_get(
   HDC hdc )
d483 1
a483 1
   if(fb) {
d487 1
a487 1
   
d510 2
a511 2
   if(data->hSharedSurface != fb->hSharedSurface) {
      if(fb->shared_surface) {
d518 1
a518 1
      if(data->hSharedSurface &&
d520 3
a522 1
         fb->shared_surface = stw_dev->stw_winsys->shared_surface_open(screen, fb->hSharedSurface);
d558 1
a558 1
   if(stw_dev->callbacks.wglCbPresentBuffers &&
d589 1
a589 2
DrvSwapBuffers(
   HDC hdc )
d621 1
a621 3
DrvSwapLayerBuffers(
   HDC hdc,
   UINT fuPlanes )
d623 1
a623 1
   if(fuPlanes & WGL_SWAP_MAIN_PLANE)
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d34 1
a95 2
   ReleaseDC(fb->hWnd, fb->hDC);

d143 2
a257 5
   /* Applications use, create, destroy device contexts, so the hdc passed is.  We create our own DC
    * because we need one for single buffered visuals.
    */
   fb->hDC = GetDC(hWnd);

d261 7
a267 1
   fb->pfi = pfi = stw_pixelformat_get_info( iPixelFormat - 1 );
d450 1
a450 1
   count = stw_pixelformat_get_extended_count();
d456 6
a461 1
      /* SetPixelFormat must be called only once */
d463 2
a464 1
      return FALSE;
d478 2
a479 1
        SetPixelFormat(hdc, iPixelFormat, NULL);
d535 11
a545 9
   if(fb->shared_surface) {
      stw_dev->stw_winsys->compose(screen,
                                   res,
                                   fb->shared_surface,
                                   &fb->client_rect,
                                   data->PresentHistoryToken);
   }
   else {
      stw_dev->stw_winsys->present( screen, res, hdc );
d601 1
d614 8
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a29 1
#include "main/context.h"
d33 2
a34 7
#include "state_tracker/st_context.h"
#include "state_tracker/st_public.h"

#ifdef DEBUG
#include "trace/tr_screen.h"
#include "trace/tr_texture.h"
#endif
d41 2
d67 2
a68 2
 * must be held, by this order. Obviously no further access to fb can be done 
 * after this.
d76 7
d93 1
a93 1
   st_unreference_framebuffer(fb->stfb);
d95 2
d117 1
a117 1
   unsigned width, height;
d122 4
d127 12
a138 3
   
   /* Get the client area size. */
   GetClientRect( fb->hWnd, &client_rect );
d141 1
a141 1
   width = client_rect.right - client_rect.left;
d144 6
a149 4
   if(width < 1)
      width = 1;
   if(height < 1)
      height = 1;
d151 4
a154 1
   if(width != fb->width || height != fb->height) {
d162 5
a166 1
   ClientToScreen(fb->hWnd, &client_pos);
d168 2
a169 6
   GetWindowRect(fb->hWnd, &window_rect);

   fb->client_rect.left = client_pos.x - window_rect.left;
   fb->client_rect.top =  client_pos.y - window_rect.top;
   fb->client_rect.right = fb->client_rect.left + fb->width;
   fb->client_rect.bottom = fb->client_rect.top + fb->height;
d173 2
a174 1
   debug_printf("%s: client_position = (%i, %i)\n",
d176 1
a176 1
   debug_printf("%s: window_rect = (%i, %i) - (%i, %i)\n",
d180 1
a180 1
   debug_printf("%s: client_rect = (%i, %i) - (%i, %i)\n",
d257 5
a261 1
   fb->hDC = hdc;
d266 20
a286 2
   stw_pixelformat_visual(&fb->visual, pfi);
   
d305 6
a310 3

BOOL
stw_framebuffer_allocate(
d313 14
a326 33
   assert(fb);
   
   if(!fb->stfb) {
      const struct stw_pixelformat_info *pfi = fb->pfi;
      enum pipe_format colorFormat, depthFormat, stencilFormat;

      colorFormat = pfi->color_format;

      if(util_format_get_component_bits(pfi->depth_stencil_format, UTIL_FORMAT_COLORSPACE_ZS, 0))
         depthFormat = pfi->depth_stencil_format;
      else
         depthFormat = PIPE_FORMAT_NONE;
   
      if(util_format_get_component_bits(pfi->depth_stencil_format, UTIL_FORMAT_COLORSPACE_ZS, 1))
         stencilFormat = pfi->depth_stencil_format;
      else
         stencilFormat = PIPE_FORMAT_NONE;
   
      assert(fb->must_resize);
      assert(fb->width);
      assert(fb->height);

      fb->stfb = st_create_framebuffer(
         &fb->visual,
         colorFormat,
         depthFormat,
         stencilFormat,
         fb->width,
         fb->height,
         (void *) fb );
      
      // to notify the context
      fb->must_resize = TRUE;
d328 2
a329 2
   
   return fb->stfb ? TRUE : FALSE;
a350 5
   
   if(fb->must_resize) {
      st_resize_framebuffer(fb->stfb, fb->width, fb->height);
      fb->must_resize = FALSE;
   }
a387 1
   struct stw_framebuffer *fb;
a388 5
   /* 
    * Some applications create and use several HDCs for the same window, so 
    * looking up the framebuffer by the HDC is not reliable. Use HWND whenever
    * possible.
    */ 
d390 3
a392 8
   if(hwnd)
      return stw_framebuffer_from_hwnd_locked(hwnd);
   
   for (fb = stw_dev->fb_head; fb != NULL; fb = fb->next)
      if (fb->hDC == hdc) {
         pipe_mutex_lock(fb->mutex);
         break;
      }
d394 1
a394 1
   return fb;
d499 1
a499 1
   struct pipe_surface *surface;
d510 1
a510 8
   surface = (struct pipe_surface *)data->pPrivateData;

#ifdef DEBUG
   if(stw_dev->trace_running) {
      screen = trace_screen(screen)->screen;
      surface = trace_surface(surface)->surface;
   }
#endif
d528 1
a528 1
                                   surface,
d534 1
a534 1
      stw_dev->stw_winsys->present( screen, surface, hdc );
d538 1
d554 1
a554 1
                               struct pipe_surface *surface)
d565 1
a565 1
      data.pPrivateData = (void *)surface;
d567 1
d575 1
a575 8
#ifdef DEBUG
      if(stw_dev->trace_running) {
         screen = trace_screen(screen)->screen;
         surface = trace_surface(surface)->surface;
      }
#endif

      stw_dev->stw_winsys->present( screen, surface, hdc );
d578 1
a578 1

a590 1
   struct pipe_surface *surface = NULL;
d604 1
a604 1
   st_swapbuffers(fb->stfb, &surface, NULL);
d606 1
a606 1
   return stw_framebuffer_present_locked(hdc, fb, surface);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d30 1
d34 7
a40 2
#include "util/u_memory.h"
#include "state_tracker/st_api.h"
a46 2
#include "stw_context.h"
#include "stw_st.h"
d71 2
a72 2
 * must be held, by this order.  If there are still references to the
 * framebuffer, nothing will happen.
a79 7
   /* check the reference count */
   fb->refcnt--;
   if (fb->refcnt) {
      pipe_mutex_unlock( fb->mutex );
      return;
   }

d90 1
a90 1
   stw_st_destroy_framebuffer_locked(fb->stfb);
a91 2
   ReleaseDC(fb->hWnd, fb->hDC);

d112 1
a112 1
   LONG width, height;
a116 4
   /*
    * Sanity checking.
    */

d118 3
a120 12
   assert(fb->width && fb->height);
   assert(fb->client_rect.right  == fb->client_rect.left + fb->width);
   assert(fb->client_rect.bottom == fb->client_rect.top  + fb->height);

   /*
    * Get the client area size.
    */

   if (!GetClientRect(fb->hWnd, &client_rect)) {
      return;
   }

d123 1
a123 1
   width  = client_rect.right  - client_rect.left;
d126 4
a129 6
   if (width <= 0 || height <= 0) {
      /*
       * When the window is minimized GetClientRect will return zeros.  Simply
       * preserve the current window size, until the window is restored or
       * maximized again.
       */
d131 1
a131 4
      return;
   }

   if (width != fb->width || height != fb->height) {
d139 3
a141 5
   if (ClientToScreen(fb->hWnd, &client_pos) &&
       GetWindowRect(fb->hWnd, &window_rect)) {
      fb->client_rect.left = client_pos.x - window_rect.left;
      fb->client_rect.top  = client_pos.y - window_rect.top;
   }
d143 4
a146 2
   fb->client_rect.right  = fb->client_rect.left + fb->width;
   fb->client_rect.bottom = fb->client_rect.top  + fb->height;
d150 1
a150 2
   debug_printf("%s: hwnd = %p\n", __FUNCTION__, fb->hWnd);
   debug_printf("%s: client_position = (%li, %li)\n",
d152 1
a152 1
   debug_printf("%s: window_rect = (%li, %li) - (%li, %li)\n",
d156 1
a156 1
   debug_printf("%s: client_rect = (%li, %li) - (%li, %li)\n",
d233 1
a233 5
   /* Applications use, create, destroy device contexts, so the hdc passed is.  We create our own DC
    * because we need one for single buffered visuals.
    */
   fb->hDC = GetDC(hWnd);

a237 20
   fb->stfb = stw_st_create_framebuffer( fb );
   if (!fb->stfb) {
      FREE( fb );
      return NULL;
   }

   fb->refcnt = 1;

   /*
    * Windows can be sometimes have zero width and or height, but we ensure
    * a non-zero framebuffer size at all times.
    */

   fb->must_resize = TRUE;
   fb->width  = 1;
   fb->height = 1;
   fb->client_rect.left   = 0;
   fb->client_rect.top    = 0;
   fb->client_rect.right  = fb->client_rect.left + fb->width;
   fb->client_rect.bottom = fb->client_rect.top  + fb->height;
d239 2
d259 3
a261 6
/**
 * Have ptr reference fb.  The referenced framebuffer should be locked.
 */
void
stw_framebuffer_reference(
   struct stw_framebuffer **ptr,
d264 33
a296 14
   struct stw_framebuffer *old_fb = *ptr;

   if (old_fb == fb)
      return;

   if (fb)
      fb->refcnt++;
   if (old_fb) {
      pipe_mutex_lock(stw_dev->fb_mutex);

      pipe_mutex_lock(old_fb->mutex);
      stw_framebuffer_destroy_locked(old_fb);

      pipe_mutex_unlock(stw_dev->fb_mutex);
d298 2
a299 2

   *ptr = fb;
d321 5
d363 1
d365 5
d371 8
a378 3
   if (!hwnd) {
      return NULL;
   }
d380 1
a380 1
   return stw_framebuffer_from_hwnd_locked(hwnd);
d485 1
a485 1
   struct pipe_resource *res;
d496 8
a503 1
   res = (struct pipe_resource *)data->pPrivateData;
d521 1
a521 1
                                   res,
d527 1
a527 1
      stw_dev->stw_winsys->present( screen, res, hdc );
a530 1
   stw_notify_current_locked(fb);
d546 1
a546 1
                               struct pipe_resource *res)
d557 1
a557 1
      data.pPrivateData = (void *)res;
a558 1
      stw_notify_current_locked(fb);
d566 8
a573 1
      stw_dev->stw_winsys->present( screen, res, hdc );
d576 1
a576 1
      stw_notify_current_locked(fb);
d589 1
d603 1
a603 1
   stw_flush_current_locked(fb);
d605 1
a605 1
   return stw_st_swap_framebuffer_locked(hdc, fb->stfb);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a33 1
#include "hud/hud_context.h"
d95 2
a143 2
   fb->minimized = width == 0 || height == 0;

d257 5
d265 1
a265 7
   /*
    * We often need a displayable pixel format to make GDI happy. Set it here (always 1, i.e.,
    * out first pixel format) where appropriat.
    */
   fb->iDisplayablePixelFormat = iPixelFormat <= stw_dev->pixelformat_count ? iPixelFormat : 1;

   fb->pfi = pfi = stw_pixelformat_get_info( iPixelFormat );
d448 1
a448 1
   count = stw_pixelformat_get_count();
d454 1
a454 6
      /*
       * SetPixelFormat must be called only once.  However ignore 
       * pbuffers, for which the framebuffer object is created first.
       */
      boolean bPbuffer = fb->bPbuffer;

d456 1
a456 2

      return bPbuffer;
d470 1
a470 2
      BOOL bRet = SetPixelFormat(hdc, iPixelFormat, NULL);
      assert(bRet);
d526 9
a534 11
   if (!fb->minimized) {
      if (fb->shared_surface) {
         stw_dev->stw_winsys->compose(screen,
                                      res,
                                      fb->shared_surface,
                                      &fb->client_rect,
                                      data->PresentHistoryToken);
      }
      else {
         stw_dev->stw_winsys->present( screen, res, hdc );
      }
a589 1
   struct stw_context *ctx;
a601 8
   }

   /* Display the HUD */
   ctx = stw_current_context();
   if (ctx && ctx->hud) {
      struct pipe_resource *back =
         stw_get_framebuffer_resource(fb->stfb, ST_ATTACHMENT_BACK_LEFT);
      hud_draw(ctx->hud, back);
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d30 1
d32 1
d71 3
a73 2
static void
stw_framebuffer_destroy_locked(struct stw_framebuffer *fb)
d91 2
a92 3
   if (fb->shared_surface)
      stw_dev->stw_winsys->shared_surface_close(stw_dev->screen,
                                                fb->shared_surface);
d95 1
a95 1

d99 1
a99 1

d105 2
a106 1
stw_framebuffer_release(struct stw_framebuffer *fb)
d113 2
a114 2
static void
stw_framebuffer_get_size(struct stw_framebuffer *fb)
d157 2
a158 2
      fb->width = width;
      fb->height = height;
d194 4
a197 1
stw_call_window_proc(int nCode, WPARAM wParam, LPARAM lParam)
d202 1
a202 1

d204 1
a204 1
   if (!tls_data)
d206 1
a206 1

d212 3
a214 4
       * http://blogs.msdn.com/oldnewthing/archive/2008/01/15/7113860.aspx
       * WM_SIZE is generated from WM_WINDOWPOSCHANGED by DefWindowProc so it
       * can be masked out by the application.
       */
d216 3
a218 3
      if ((lpWindowPos->flags & SWP_SHOWWINDOW) ||
          !(lpWindowPos->flags & SWP_NOMOVE) ||
          !(lpWindowPos->flags & SWP_NOSIZE)) {
d220 3
a222 4
         if (fb) {
            /* Size in WINDOWPOS includes the window frame, so get the size
             * of the client area via GetClientRect.
             */
d231 1
a231 1
      if (fb)
d241 3
a243 1
stw_framebuffer_create(HDC hdc, int iPixelFormat)
d251 1
a251 1
   if (!hWnd)
d253 1
a253 1

d262 2
a263 2
    * We often need a displayable pixel format to make GDI happy. Set it
    * here (always 1, i.e., out first pixel format) where appropriate.
d265 1
a265 2
   fb->iDisplayablePixelFormat = iPixelFormat <= stw_dev->pixelformat_count
      ? iPixelFormat : 1;
a306 1

d311 3
a313 2
stw_framebuffer_reference(struct stw_framebuffer **ptr,
                          struct stw_framebuffer *fb)
d339 2
a340 1
stw_framebuffer_update(struct stw_framebuffer *fb)
d345 4
a348 4

   /* XXX: It would be nice to avoid checking the size again -- in theory
    * stw_call_window_proc would have cought the resize and stored the right
    * size already, but unfortunately threads created before the DllMain is
d353 1
a353 1
}
d357 1
a357 1
stw_framebuffer_cleanup(void)
d370 1
a370 1

d373 1
a373 1

d377 1
a377 1

d404 2
a405 1
stw_framebuffer_from_hdc(HDC hdc)
d424 2
a425 1
stw_framebuffer_from_hwnd(HWND hwnd)
d438 3
a440 1
DrvSetPixelFormat(HDC hdc, LONG iPixelFormat)
d455 1
a455 1
   if (fb) {
d468 1
a468 1
   if (!fb) {
d471 1
a471 1

d474 2
a475 2
   /* Some applications mistakenly use the undocumented wglSetPixelFormat
    * function instead of SetPixelFormat, so we call SetPixelFormat here to
d481 1
a481 1

d487 2
a488 1
stw_pixelformat_get(HDC hdc)
d494 1
a494 1
   if (fb) {
d498 1
a498 1

d521 2
a522 2
   if (data->hSharedSurface != fb->hSharedSurface) {
      if (fb->shared_surface) {
d529 1
a529 1
      if (data->hSharedSurface &&
d531 1
a531 3
         fb->shared_surface =
            stw_dev->stw_winsys->shared_surface_open(screen,
                                                     fb->hSharedSurface);
d567 1
a567 1
   if (stw_dev->callbacks.wglCbPresentBuffers &&
d598 2
a599 1
DrvSwapBuffers(HDC hdc)
d631 3
a633 1
DrvSwapLayerBuffers(HDC hdc, UINT fuPlanes)
d635 1
a635 1
   if (fuPlanes & WGL_SWAP_MAIN_PLANE)
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@a29 1
#include "pipe/p_format.h"
a30 1
#include "util/u_format.h"
d69 2
a70 3
static INLINE void
stw_framebuffer_destroy_locked(
   struct stw_framebuffer *fb )
d88 3
a90 2
   if(fb->shared_surface)
      stw_dev->stw_winsys->shared_surface_close(stw_dev->screen, fb->shared_surface);
d93 1
a93 1
   
d97 1
a97 1
   
d103 1
a103 2
stw_framebuffer_release(
   struct stw_framebuffer *fb)
d110 2
a111 2
static INLINE void
stw_framebuffer_get_size( struct stw_framebuffer *fb )
d154 2
a155 2
      fb->width = width; 
      fb->height = height; 
d191 1
a191 4
stw_call_window_proc(
   int nCode,
   WPARAM wParam,
   LPARAM lParam )
d196 1
a196 1
   
d198 1
a198 1
   if(!tls_data)
d200 1
a200 1
   
d206 4
a209 3
       * http://blogs.msdn.com/oldnewthing/archive/2008/01/15/7113860.aspx 
       * WM_SIZE is generated from WM_WINDOWPOSCHANGED by DefWindowProc so it 
       * can be masked out by the application. */
d211 3
a213 3
      if((lpWindowPos->flags & SWP_SHOWWINDOW) || 
         !(lpWindowPos->flags & SWP_NOMOVE) ||
         !(lpWindowPos->flags & SWP_NOSIZE)) {
d215 4
a218 3
         if(fb) {
            /* Size in WINDOWPOS includes the window frame, so get the size 
             * of the client area via GetClientRect.  */
d227 1
a227 1
      if(fb)
d237 1
a237 3
stw_framebuffer_create(
   HDC hdc,
   int iPixelFormat )
d245 1
a245 1
   if(!hWnd)
d247 1
a247 1
   
d256 2
a257 2
    * We often need a displayable pixel format to make GDI happy. Set it here (always 1, i.e.,
    * out first pixel format) where appropriat.
d259 2
a260 1
   fb->iDisplayablePixelFormat = iPixelFormat <= stw_dev->pixelformat_count ? iPixelFormat : 1;
d302 1
d307 2
a308 3
stw_framebuffer_reference(
   struct stw_framebuffer **ptr,
   struct stw_framebuffer *fb)
d334 1
a334 2
stw_framebuffer_update(
   struct stw_framebuffer *fb)
d339 4
a342 4
   
   /* XXX: It would be nice to avoid checking the size again -- in theory  
    * stw_call_window_proc would have cought the resize and stored the right 
    * size already, but unfortunately threads created before the DllMain is 
d347 1
a347 1
}                      
d351 1
a351 1
stw_framebuffer_cleanup( void )
d364 1
a364 1
      
d367 1
a367 1
      
d371 1
a371 1
   
d398 1
a398 2
stw_framebuffer_from_hdc(
   HDC hdc )
d417 1
a417 2
stw_framebuffer_from_hwnd(
   HWND hwnd )
d430 1
a430 3
DrvSetPixelFormat(
   HDC hdc,
   LONG iPixelFormat )
d445 1
a445 1
   if(fb) {
d458 1
a458 1
   if(!fb) {
d461 1
a461 1
      
d464 2
a465 2
   /* Some applications mistakenly use the undocumented wglSetPixelFormat 
    * function instead of SetPixelFormat, so we call SetPixelFormat here to 
d471 1
a471 1
   
d477 1
a477 2
stw_pixelformat_get(
   HDC hdc )
d483 1
a483 1
   if(fb) {
d487 1
a487 1
   
d510 2
a511 2
   if(data->hSharedSurface != fb->hSharedSurface) {
      if(fb->shared_surface) {
d518 1
a518 1
      if(data->hSharedSurface &&
d520 3
a522 1
         fb->shared_surface = stw_dev->stw_winsys->shared_surface_open(screen, fb->hSharedSurface);
d558 1
a558 1
   if(stw_dev->callbacks.wglCbPresentBuffers &&
d589 1
a589 2
DrvSwapBuffers(
   HDC hdc )
d621 1
a621 3
DrvSwapLayerBuffers(
   HDC hdc,
   UINT fuPlanes )
d623 1
a623 1
   if(fuPlanes & WGL_SWAP_MAIN_PLANE)
@


