head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.38;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.56;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.01.52;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.34;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.21;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#ifndef STW_FRAMEBUFFER_H
#define STW_FRAMEBUFFER_H

#include <windows.h>

#include "os/os_thread.h"

struct pipe_resource;
struct st_framebuffer_iface;
struct stw_pixelformat_info;

/**
 * Windows framebuffer.
 */
struct stw_framebuffer
{
   /**
    * This mutex has two purposes:
    * - protect the access to the mutable data members below
    * - prevent the framebuffer from being deleted while being accessed.
    * 
    * It is OK to lock this mutex while holding the stw_device::fb_mutex lock, 
    * but the opposite must never happen.
    */
   pipe_mutex mutex;
   
   /*
    * Immutable members.
    * 
    * Note that even access to immutable members implies acquiring the mutex 
    * above, to prevent the framebuffer from being destroyed.
    */
   
   HWND hWnd;

   int iPixelFormat;
   const struct stw_pixelformat_info *pfi;

   /* A pixel format that can be used by GDI */
   int iDisplayablePixelFormat;
   boolean bPbuffer;

   struct st_framebuffer_iface *stfb;

   /*
    * Mutable members. 
    */

   unsigned refcnt;

   
   /* FIXME: Make this work for multiple contexts bound to the same framebuffer */
   boolean must_resize;

   boolean minimized;  /**< Is the window currently minimized? */

   unsigned width;
   unsigned height;
   
   /**
    * Client area rectangle, relative to the window upper-left corner.
    *
    * @@sa GLCBPRESENTBUFFERSDATA::rect.
    */
   RECT client_rect;

   HANDLE hSharedSurface;
   struct stw_shared_surface *shared_surface;

   /** 
    * This is protected by stw_device::fb_mutex, not the mutex above.
    * 
    * Deletions must be done by first acquiring stw_device::fb_mutex, and then
    * acquiring the stw_framebuffer::mutex of the framebuffer to be deleted. 
    * This ensures that nobody else is reading/writing to the.
    * 
    * It is not necessary to aquire the mutex above to navigate the linked list
    * given that deletions are done with stw_device::fb_mutex held, so no other
    * thread can delete.
    */
   struct stw_framebuffer *next;
};


/**
 * Create a new framebuffer object which will correspond to the given HDC.
 * 
 * This function will acquire stw_framebuffer::mutex. stw_framebuffer_release
 * must be called when done 
 */
struct stw_framebuffer *
stw_framebuffer_create(
   HDC hdc,
   int iPixelFormat );

void
stw_framebuffer_reference(
   struct stw_framebuffer **ptr,
   struct stw_framebuffer *fb);

/**
 * Search a framebuffer with a matching HWND.
 * 
 * This function will acquire stw_framebuffer::mutex. stw_framebuffer_release
 * must be called when done 
 */
struct stw_framebuffer *
stw_framebuffer_from_hwnd(
   HWND hwnd );

/**
 * Search a framebuffer with a matching HDC.
 * 
 * This function will acquire stw_framebuffer::mutex. stw_framebuffer_release
 * must be called when done 
 */
struct stw_framebuffer *
stw_framebuffer_from_hdc(
   HDC hdc );

BOOL
stw_framebuffer_present_locked(HDC hdc,
                               struct stw_framebuffer *fb,
                               struct pipe_resource *res);

void
stw_framebuffer_update(
   struct stw_framebuffer *fb);

/**
 * Release stw_framebuffer::mutex lock. This framebuffer must not be accessed
 * after calling this function, as it may have been deleted by another thread
 * in the meanwhile.
 */
void
stw_framebuffer_release(
   struct stw_framebuffer *fb);

/**
 * Cleanup any existing framebuffers when exiting application.
 */
void
stw_framebuffer_cleanup(void);

#endif /* STW_FRAMEBUFFER_H */
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d40 1
a40 1
 * Windows framebuffer, derived from gl_framebuffer.
a60 1
   HDC hDC;
d66 4
d81 2
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a32 2
#include "main/mtypes.h"

d35 2
a36 1
struct pipe_surface;
d66 2
a67 1
   GLvisual visual;
d73 2
a74 1
   struct st_framebuffer *stfb;
d118 5
a143 4
stw_framebuffer_allocate(
   struct stw_framebuffer *fb );

BOOL
d146 1
a146 1
                               struct pipe_surface *surface);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d33 2
d37 1
a37 2
struct pipe_resource;
struct st_framebuffer_iface;
d67 1
a67 2

   struct st_framebuffer_iface *stfb;
d73 1
a73 2
   unsigned refcnt;

a116 5
void
stw_framebuffer_reference(
   struct stw_framebuffer **ptr,
   struct stw_framebuffer *fb);

d138 4
d144 1
a144 1
                               struct pipe_resource *res);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d40 1
a40 1
 * Windows framebuffer.
d61 1
a66 4
   /* A pixel format that can be used by GDI */
   int iDisplayablePixelFormat;
   boolean bPbuffer;

a77 2

   boolean minimized;  /**< Is the window currently minimized? */
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


