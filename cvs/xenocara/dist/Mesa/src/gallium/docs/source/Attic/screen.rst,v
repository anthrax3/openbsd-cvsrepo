head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.9
date	2015.12.23.05.17.29;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.22.09.30.33;	author jsg;	state Exp;
branches;
next	1.7;
commitid	yhStanAcs6cSYmBc;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.54;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.24;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.01;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.07;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@.. _screen:

Screen
======

A screen is an object representing the context-independent part of a device.

Flags and enumerations
----------------------

XXX some of these don't belong in this section.


.. _pipe_cap:

PIPE_CAP_*
^^^^^^^^^^

Capability queries return information about the features and limits of the
driver/GPU.  For floating-point values, use :ref:`get_paramf`, and for boolean
or integer values, use :ref:`get_param`.

The integer capabilities:

* ``PIPE_CAP_NPOT_TEXTURES``: Whether :term:`NPOT` textures may have repeat modes,
  normalized coordinates, and mipmaps.
* ``PIPE_CAP_TWO_SIDED_STENCIL``: Whether the stencil test can also affect back-facing
  polygons.
* ``PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS``: How many dual-source blend RTs are support.
  :ref:`Blend` for more information.
* ``PIPE_CAP_ANISOTROPIC_FILTER``: Whether textures can be filtered anisotropically.
* ``PIPE_CAP_POINT_SPRITE``: Whether point sprites are available.
* ``PIPE_CAP_MAX_RENDER_TARGETS``: The maximum number of render targets that may be
  bound.
* ``PIPE_CAP_OCCLUSION_QUERY``: Whether occlusion queries are available.
* ``PIPE_CAP_QUERY_TIME_ELAPSED``: Whether PIPE_QUERY_TIME_ELAPSED queries are available.
* ``PIPE_CAP_TEXTURE_SHADOW_MAP``: indicates whether the fragment shader hardware
  can do the depth texture / Z comparison operation in TEX instructions
  for shadow testing.
* ``PIPE_CAP_TEXTURE_SWIZZLE``: Whether swizzling through sampler views is
  supported.
* ``PIPE_CAP_MAX_TEXTURE_2D_LEVELS``: The maximum number of mipmap levels available
  for a 2D texture.
* ``PIPE_CAP_MAX_TEXTURE_3D_LEVELS``: The maximum number of mipmap levels available
  for a 3D texture.
* ``PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS``: The maximum number of mipmap levels available
  for a cubemap.
* ``PIPE_CAP_TEXTURE_MIRROR_CLAMP``: Whether mirrored texture coordinates with clamp
  are supported.
* ``PIPE_CAP_BLEND_EQUATION_SEPARATE``: Whether alpha blend equations may be different
  from color blend equations, in :ref:`Blend` state.
* ``PIPE_CAP_SM3``: Whether the vertex shader and fragment shader support equivalent
  opcodes to the Shader Model 3 specification. XXX oh god this is horrible
* ``PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS``: The maximum number of stream buffers.
* ``PIPE_CAP_PRIMITIVE_RESTART``: Whether primitive restart is supported.
* ``PIPE_CAP_INDEP_BLEND_ENABLE``: Whether per-rendertarget blend enabling and channel
  masks are supported. If 0, then the first rendertarget's blend mask is
  replicated across all MRTs.
* ``PIPE_CAP_INDEP_BLEND_FUNC``: Whether per-rendertarget blend functions are
  available. If 0, then the first rendertarget's blend functions affect all
  MRTs.
* ``PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS``: The maximum number of texture array
  layers supported. If 0, the array textures are not supported at all and
  the ARRAY texture targets are invalid.
* ``PIPE_CAP_TGSI_FS_COORD_ORIGIN_UPPER_LEFT``: Whether the TGSI property
  FS_COORD_ORIGIN with value UPPER_LEFT is supported.
* ``PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT``: Whether the TGSI property
  FS_COORD_ORIGIN with value LOWER_LEFT is supported.
* ``PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER``: Whether the TGSI
  property FS_COORD_PIXEL_CENTER with value HALF_INTEGER is supported.
* ``PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER``: Whether the TGSI
  property FS_COORD_PIXEL_CENTER with value INTEGER is supported.
* ``PIPE_CAP_DEPTH_CLIP_DISABLE``: Whether the driver is capable of disabling
  depth clipping (through pipe_rasterizer_state)
* ``PIPE_CAP_SHADER_STENCIL_EXPORT``: Whether a stencil reference value can be
  written from a fragment shader.
* ``PIPE_CAP_TGSI_INSTANCEID``: Whether TGSI_SEMANTIC_INSTANCEID is supported
  in the vertex shader.
* ``PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR``: Whether the driver supports
  per-instance vertex attribs.
* ``PIPE_CAP_FRAGMENT_COLOR_CLAMPED``: Whether fragment color clamping is
  supported.  That is, is the pipe_rasterizer_state::clamp_fragment_color
  flag supported by the driver?  If not, the state tracker will insert
  clamping code into the fragment shaders when needed.

* ``PIPE_CAP_MIXED_COLORBUFFER_FORMATS``: Whether mixed colorbuffer formats are
  supported, e.g. RGBA8 and RGBA32F as the first and second colorbuffer, resp.
* ``PIPE_CAP_VERTEX_COLOR_UNCLAMPED``: Whether the driver is capable of
  outputting unclamped vertex colors from a vertex shader. If unsupported,
  the vertex colors are always clamped. This is the default for DX9 hardware.
* ``PIPE_CAP_VERTEX_COLOR_CLAMPED``: Whether the driver is capable of
  clamping vertex colors when they come out of a vertex shader, as specified
  by the pipe_rasterizer_state::clamp_vertex_color flag.  If unsupported,
  the vertex colors are never clamped. This is the default for DX10 hardware.
  If both clamped and unclamped CAPs are supported, the clamping can be
  controlled through pipe_rasterizer_state.  If the driver cannot do vertex
  color clamping, the state tracker may insert clamping code into the vertex
  shader.
* ``PIPE_CAP_GLSL_FEATURE_LEVEL``: Whether the driver supports features
  equivalent to a specific GLSL version. E.g. for GLSL 1.3, report 130.
* ``PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION``: Whether quads adhere to
  the flatshade_first setting in ``pipe_rasterizer_state``.
* ``PIPE_CAP_USER_VERTEX_BUFFERS``: Whether the driver supports user vertex
  buffers.  If not, the state tracker must upload all data which is not in hw
  resources.  If user-space buffers are supported, the driver must also still
  accept HW resource buffers.
* ``PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY``: This CAP describes a hw
  limitation.  If true, pipe_vertex_buffer::buffer_offset must always be aligned
  to 4.  If false, there are no restrictions on the offset.
* ``PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY``: This CAP describes a hw
  limitation.  If true, pipe_vertex_buffer::stride must always be aligned to 4.
  If false, there are no restrictions on the stride.
* ``PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY``: This CAP describes
  a hw limitation.  If true, pipe_vertex_element::src_offset must always be
  aligned to 4.  If false, there are no restrictions on src_offset.
* ``PIPE_CAP_COMPUTE``: Whether the implementation supports the
  compute entry points defined in pipe_context and pipe_screen.
* ``PIPE_CAP_USER_INDEX_BUFFERS``: Whether user index buffers are supported.
  If not, the state tracker must upload all indices which are not in hw
  resources.  If user-space buffers are supported, the driver must also still
  accept HW resource buffers.
* ``PIPE_CAP_USER_CONSTANT_BUFFERS``: Whether user-space constant buffers
  are supported.  If not, the state tracker must put constants into HW
  resources/buffers.  If user-space constant buffers are supported, the
  driver must still accept HW constant buffers also.
* ``PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT``: Describes the required
  alignment of pipe_constant_buffer::buffer_offset.
* ``PIPE_CAP_START_INSTANCE``: Whether the driver supports
  pipe_draw_info::start_instance.
* ``PIPE_CAP_QUERY_TIMESTAMP``: Whether PIPE_QUERY_TIMESTAMP and
  the pipe_screen::get_timestamp hook are implemented.
* ``PIPE_CAP_TEXTURE_MULTISAMPLE``: Whether all MSAA resources supported
  for rendering are also supported for texturing.
* ``PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT``: The minimum alignment that should be
  expected for a pointer returned by transfer_map if the resource is
  PIPE_BUFFER. In other words, the pointer returned by transfer_map is
  always aligned to this value.
* ``PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT``: Describes the required
  alignment for pipe_sampler_view::u.buf.first_element, in bytes.
  If a driver does not support first/last_element, it should return 0.
* ``PIPE_CAP_TGSI_TEXCOORD``: This CAP describes a hw limitation.
  If true, the hardware cannot replace arbitrary shader inputs with sprite
  coordinates and hence the inputs that are desired to be replaceable must
  be declared with TGSI_SEMANTIC_TEXCOORD instead of TGSI_SEMANTIC_GENERIC.
  The rasterizer's sprite_coord_enable state therefore also applies to the
  TEXCOORD semantic.
  Also, TGSI_SEMANTIC_PCOORD becomes available, which labels a fragment shader
  input that will always be replaced with sprite coordinates.
* ``PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER``: Whether it is preferable
  to use a blit to implement a texture transfer which needs format conversions
  and swizzling in state trackers. Generally, all hardware drivers with
  dedicated memory should return 1 and all software rasterizers should return 0.
* ``PIPE_CAP_QUERY_PIPELINE_STATISTICS``: Whether PIPE_QUERY_PIPELINE_STATISTICS
  is supported.
* ``PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK``: Bitmask indicating whether special
  considerations have to be given to the interaction between the border color
  in the sampler object and the sampler view used with it.
  If PIPE_QUIRK_TEXTURE_BORDER_COLOR_SWIZZLE_R600 is set, the border color
  may be affected in undefined ways for any kind of permutational swizzle
  (any swizzle XYZW where X/Y/Z/W are not ZERO, ONE, or R/G/B/A respectively)
  in the sampler view.
  If PIPE_QUIRK_TEXTURE_BORDER_COLOR_SWIZZLE_NV50 is set, the border color
  state should be swizzled manually according to the swizzle in the sampler
  view it is intended to be used with, or herein undefined results may occur
  for permutational swizzles.
* ``PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE``: The maximum accessible size with
  a buffer sampler view, in bytes.
* ``PIPE_CAP_MAX_VIEWPORTS``: The maximum number of viewports (and scissors
  since they are linked) a driver can support. Returning 0 is equivalent
  to returning 1 because every driver has to support at least a single
  viewport/scissor combination.
* ``PIPE_CAP_ENDIANNESS``:: The endianness of the device.  Either
  PIPE_ENDIAN_BIG or PIPE_ENDIAN_LITTLE.
* ``PIPE_CAP_MIXED_FRAMEBUFFER_SIZES``: Whether it is allowed to have
  different sizes for fb color/zs attachments. This controls whether
  ARB_framebuffer_object is provided.
* ``PIPE_CAP_TGSI_VS_LAYER``: Whether TGSI_SEMANTIC_LAYER is supported
  as a vertex shader output.
* ``PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES``: The maximum number of vertices
  output by a single invocation of a geometry shader.
* ``PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS``: The maximum number of
  vertex components output by a single invocation of a geometry shader.
  This is the product of the number of attribute components per vertex and
  the number of output vertices.
* ``PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS``: Max number of components
  in format that texture gather can operate on. 1 == RED, ALPHA etc,
  4 == All formats.
* ``PIPE_CAP_TEXTURE_GATHER_SM5``: Whether the texture gather
  hardware implements the SM5 features, component selection,
  shadow comparison, and run-time offsets.
* ``PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT``: Whether
  PIPE_TRANSFER_PERSISTENT and PIPE_TRANSFER_COHERENT are supported
  for buffers.
* ``PIPE_CAP_TEXTURE_QUERY_LOD``: Whether the ``LODQ`` instruction is
  supported.
* ``PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET``: The minimum offset that can be used
  in conjunction with a texture gather opcode.
* ``PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET``: The maximum offset that can be used
  in conjunction with a texture gather opcode.
* ``PIPE_CAP_SAMPLE_SHADING``: Whether there is support for per-sample
  shading. The context->set_min_samples function will be expected to be
  implemented.
* ``PIPE_CAP_VENDOR_ID``: The vendor ID of the underlying hardware. If it's
  not available one should return 0xFFFFFFFF.
* ``PIPE_CAP_DEVICE_ID``: The device ID (PCI ID) of the underlying hardware.
  0xFFFFFFFF if not available.
* ``PIPE_CAP_ACCELERATED``: Whether the renderer is hardware accelerated.
* ``PIPE_CAP_VIDEO_MEMORY``: The amount of video memory in megabytes.
* ``PIPE_CAP_UMA``: If the device has a unified memory architecture or on-card
  memory and GART.


.. _pipe_capf:

PIPE_CAPF_*
^^^^^^^^^^^^^^^^

The floating-point capabilities are:

* ``PIPE_CAPF_MAX_LINE_WIDTH``: The maximum width of a regular line.
* ``PIPE_CAPF_MAX_LINE_WIDTH_AA``: The maximum width of a smoothed line.
* ``PIPE_CAPF_MAX_POINT_WIDTH``: The maximum width and height of a point.
* ``PIPE_CAPF_MAX_POINT_WIDTH_AA``: The maximum width and height of a smoothed point.
* ``PIPE_CAPF_MAX_TEXTURE_ANISOTROPY``: The maximum level of anisotropy that can be
  applied to anisotropically filtered textures.
* ``PIPE_CAPF_MAX_TEXTURE_LOD_BIAS``: The maximum :term:`LOD` bias that may be applied
  to filtered textures.
* ``PIPE_CAPF_GUARD_BAND_LEFT``,
  ``PIPE_CAPF_GUARD_BAND_TOP``,
  ``PIPE_CAPF_GUARD_BAND_RIGHT``,
  ``PIPE_CAPF_GUARD_BAND_BOTTOM``: TODO


.. _pipe_shader_cap:

PIPE_SHADER_CAP_*
^^^^^^^^^^^^^^^^^

These are per-shader-stage capabitity queries. Different shader stages may
support different features.

* ``PIPE_SHADER_CAP_MAX_INSTRUCTIONS``: The maximum number of instructions.
* ``PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS``: The maximum number of arithmetic instructions.
* ``PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS``: The maximum number of texture instructions.
* ``PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS``: The maximum number of texture indirections.
* ``PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH``: The maximum nested control flow depth.
* ``PIPE_SHADER_CAP_MAX_INPUTS``: The maximum number of input registers.
* ``PIPE_SHADER_CAP_MAX_CONSTS``: The maximum number of constants.
* ``PIPE_SHADER_CAP_MAX_CONST_BUFFERS``: Maximum number of constant buffers that can be bound
  to any shader stage using ``set_constant_buffer``. If 0 or 1, the pipe will
  only permit binding one constant buffer per shader, and the shaders will
  not permit two-dimensional access to constants.

If a value greater than 0 is returned, the driver can have multiple
constant buffers bound to shader stages. The CONST register file can
be accessed with two-dimensional indices, like in the example below.

DCL CONST[0][0..7]       # declare first 8 vectors of constbuf 0
DCL CONST[3][0]          # declare first vector of constbuf 3
MOV OUT[0], CONST[0][3]  # copy vector 3 of constbuf 0

For backwards compatibility, one-dimensional access to CONST register
file is still supported. In that case, the constbuf index is assumed
to be 0.

* ``PIPE_SHADER_CAP_MAX_TEMPS``: The maximum number of temporary registers.
* ``PIPE_SHADER_CAP_MAX_ADDRS``: The maximum number of address registers.
* ``PIPE_SHADER_CAP_MAX_PREDS``: The maximum number of predicate registers.
* ``PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED``: Whether the continue opcode is supported.
* ``PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR``: Whether indirect addressing
  of the input file is supported.
* ``PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR``: Whether indirect addressing
  of the output file is supported.
* ``PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR``: Whether indirect addressing
  of the temporary file is supported.
* ``PIPE_SHADER_CAP_INDIRECT_CONST_ADDR``: Whether indirect addressing
  of the constant file is supported.
* ``PIPE_SHADER_CAP_SUBROUTINES``: Whether subroutines are supported, i.e.
  BGNSUB, ENDSUB, CAL, and RET, including RET in the main block.
* ``PIPE_SHADER_CAP_INTEGERS``: Whether integer opcodes are supported.
  If unsupported, only float opcodes are supported.
* ``PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS``: The maximum number of texture
  samplers.
* ``PIPE_SHADER_CAP_PREFERRED_IR``: Preferred representation of the
  program.  It should be one of the ``pipe_shader_ir`` enum values.
* ``PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS``: The maximum number of texture
  sampler views. Must not be lower than PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS.


.. _pipe_compute_cap:

PIPE_COMPUTE_CAP_*
^^^^^^^^^^^^^^^^^^

Compute-specific capabilities. They can be queried using
pipe_screen::get_compute_param.

* ``PIPE_COMPUTE_CAP_IR_TARGET``: A description of the target of the form
  ``processor-arch-manufacturer-os`` that will be passed on to the compiler.
  This CAP is only relevant for drivers that specify PIPE_SHADER_IR_LLVM for
  their preferred IR.
  Value type: null-terminated string.
* ``PIPE_COMPUTE_CAP_GRID_DIMENSION``: Number of supported dimensions
  for grid and block coordinates.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_GRID_SIZE``: Maximum grid size in block
  units.  Value type: ``uint64_t []``.
* ``PIPE_COMPUTE_CAP_MAX_BLOCK_SIZE``: Maximum block size in thread
  units.  Value type: ``uint64_t []``.
* ``PIPE_COMPUTE_CAP_MAX_THREADS_PER_BLOCK``: Maximum number of threads that
  a single block can contain.  Value type: ``uint64_t``.
  This may be less than the product of the components of MAX_BLOCK_SIZE and is
  usually limited by the number of threads that can be resident simultaneously
  on a compute unit.
* ``PIPE_COMPUTE_CAP_MAX_GLOBAL_SIZE``: Maximum size of the GLOBAL
  resource.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_LOCAL_SIZE``: Maximum size of the LOCAL
  resource.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_PRIVATE_SIZE``: Maximum size of the PRIVATE
  resource.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_INPUT_SIZE``: Maximum size of the INPUT
  resource.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_MEM_ALLOC_SIZE``: Maximum size of a memory object
  allocation in bytes.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_CLOCK_FREQUENCY``: Maximum frequency of the GPU
  clock in MHz. Value type: ``uint32_t``

.. _pipe_bind:

PIPE_BIND_*
^^^^^^^^^^^

These flags indicate how a resource will be used and are specified at resource
creation time. Resources may be used in different roles
during their lifecycle. Bind flags are cumulative and may be combined to create
a resource which can be used for multiple things.
Depending on the pipe driver's memory management and these bind flags,
resources might be created and handled quite differently.

* ``PIPE_BIND_RENDER_TARGET``: A color buffer or pixel buffer which will be
  rendered to.  Any surface/resource attached to pipe_framebuffer_state::cbufs
  must have this flag set.
* ``PIPE_BIND_DEPTH_STENCIL``: A depth (Z) buffer and/or stencil buffer. Any
  depth/stencil surface/resource attached to pipe_framebuffer_state::zsbuf must
  have this flag set.
* ``PIPE_BIND_BLENDABLE``: Used in conjunction with PIPE_BIND_RENDER_TARGET to
  query whether a device supports blending for a given format.
  If this flag is set, surface creation may fail if blending is not supported
  for the specified format. If it is not set, a driver may choose to ignore
  blending on surfaces with formats that would require emulation.
* ``PIPE_BIND_DISPLAY_TARGET``: A surface that can be presented to screen. Arguments to
  pipe_screen::flush_front_buffer must have this flag set.
* ``PIPE_BIND_SAMPLER_VIEW``: A texture that may be sampled from in a fragment
  or vertex shader.
* ``PIPE_BIND_VERTEX_BUFFER``: A vertex buffer.
* ``PIPE_BIND_INDEX_BUFFER``: An vertex index/element buffer.
* ``PIPE_BIND_CONSTANT_BUFFER``: A buffer of shader constants.
* ``PIPE_BIND_TRANSFER_WRITE``: A transfer object which will be written to.
* ``PIPE_BIND_TRANSFER_READ``: A transfer object which will be read from.
* ``PIPE_BIND_STREAM_OUTPUT``: A stream output buffer.
* ``PIPE_BIND_CUSTOM``:
* ``PIPE_BIND_SCANOUT``: A front color buffer or scanout buffer.
* ``PIPE_BIND_SHARED``: A sharable buffer that can be given to another
  process.
* ``PIPE_BIND_GLOBAL``: A buffer that can be mapped into the global
  address space of a compute program.
* ``PIPE_BIND_SHADER_RESOURCE``: A buffer or texture that can be
  bound to the graphics pipeline as a shader resource.
* ``PIPE_BIND_COMPUTE_RESOURCE``: A buffer or texture that can be
  bound to the compute program as a shader resource.

.. _pipe_usage:

PIPE_USAGE_*
^^^^^^^^^^^^

The PIPE_USAGE enums are hints about the expected usage pattern of a resource.
Note that drivers must always support read and write CPU access at any time
no matter which hint they got.

* ``PIPE_USAGE_DEFAULT``: Optimized for fast GPU access.
* ``PIPE_USAGE_IMMUTABLE``: Optimized for fast GPU access and the resource is
  not expected to be mapped or changed (even by the GPU) after the first upload.
* ``PIPE_USAGE_DYNAMIC``: Expect frequent write-only CPU access. What is
  uploaded is expected to be used at least several times by the GPU.
* ``PIPE_USAGE_STREAM``: Expect frequent write-only CPU access. What is
  uploaded is expected to be used only once by the GPU.
* ``PIPE_USAGE_STAGING``: Optimized for fast CPU access.


Methods
-------

XXX to-do

get_name
^^^^^^^^

Returns an identifying name for the screen.

get_vendor
^^^^^^^^^^

Returns the screen vendor.

.. _get_param:

get_param
^^^^^^^^^

Get an integer/boolean screen parameter.

**param** is one of the :ref:`PIPE_CAP` names.

.. _get_paramf:

get_paramf
^^^^^^^^^^

Get a floating-point screen parameter.

**param** is one of the :ref:`PIPE_CAP` names.

context_create
^^^^^^^^^^^^^^

Create a pipe_context.

**priv** is private data of the caller, which may be put to various
unspecified uses, typically to do with implementing swapbuffers
and/or front-buffer rendering.

is_format_supported
^^^^^^^^^^^^^^^^^^^

Determine if a resource in the given format can be used in a specific manner.

**format** the resource format

**target** one of the PIPE_TEXTURE_x flags

**sample_count** the number of samples. 0 and 1 mean no multisampling,
the maximum allowed legal value is 32.

**bindings** is a bitmask of :ref:`PIPE_BIND` flags.

**geom_flags** is a bitmask of PIPE_TEXTURE_GEOM_x flags.

Returns TRUE if all usages can be satisfied.


can_create_resource
^^^^^^^^^^^^^^^^^^^

Check if a resource can actually be created (but don't actually allocate any
memory).  This is used to implement OpenGL's proxy textures.  Typically, a
driver will simply check if the total size of the given resource is less than
some limit.


.. _resource_create:

resource_create
^^^^^^^^^^^^^^^

Create a new resource from a template.
The following fields of the pipe_resource must be specified in the template:

**target** one of the pipe_texture_target enums.
Note that PIPE_BUFFER and PIPE_TEXTURE_X are not really fundamentally different.
Modern APIs allow using buffers as shader resources.

**format** one of the pipe_format enums.

**width0** the width of the base mip level of the texture or size of the buffer.

**height0** the height of the base mip level of the texture
(1 for 1D or 1D array textures).

**depth0** the depth of the base mip level of the texture
(1 for everything else).

**array_size** the array size for 1D and 2D array textures.
For cube maps this must be 6, for other textures 1.

**last_level** the last mip map level present.

**nr_samples** the nr of msaa samples. 0 (or 1) specifies a resource
which isn't multisampled.

**usage** one of the PIPE_USAGE flags.

**bind** bitmask of the PIPE_BIND flags.

**flags** bitmask of PIPE_RESOURCE_FLAG flags.



resource_destroy
^^^^^^^^^^^^^^^^

Destroy a resource. A resource is destroyed if it has no more references.



get_timestamp
^^^^^^^^^^^^^

Query a timestamp in nanoseconds. The returned value should match
PIPE_QUERY_TIMESTAMP. This function returns immediately and doesn't
wait for rendering to complete (which cannot be achieved with queries).



get_driver_query_info
^^^^^^^^^^^^^^^^^^^^^

Return a driver-specific query. If the **info** parameter is NULL,
the number of available queries is returned.  Otherwise, the driver
query at the specified **index** is returned in **info**.
The function returns non-zero on success.
The driver-specific query is described with the pipe_driver_query_info
structure.
@


1.8
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.7
log
@Merge Mesa 10.2.9
@
text
@d203 8
@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d177 2
a178 4
* ``PIPE_CAP_TGSI_VS_LAYER_VIEWPORT``: Whether ``TGSI_SEMANTIC_LAYER`` and
  ``TGSI_SEMANTIC_VIEWPORT_INDEX`` are supported as vertex shader
  outputs. Note that the viewport will only be used if multiple viewports are
  exposed.
a202 31
* ``PIPE_CAP_TEXTURE_GATHER_OFFSETS``: Whether the ``TG4`` instruction can
  accept 4 offsets.
* ``PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION``: Whether
  TGSI_PROPERTY_VS_WINDOW_SPACE_POSITION is supported, which disables clipping
  and viewport transformation.
* ``PIPE_CAP_MAX_VERTEX_STREAMS``: The maximum number of vertex streams
  supported by the geometry shader. If stream-out is supported, this should be
  at least 1. If stream-out is not supported, this should be 0.
* ``PIPE_CAP_DRAW_INDIRECT``: Whether the driver supports taking draw arguments
  { count, instance_count, start, index_bias } from a PIPE_BUFFER resource.
  See pipe_draw_info.
* ``PIPE_CAP_TGSI_FS_FINE_DERIVATIVE``: Whether the fragment shader supports
  the FINE versions of DDX/DDY.
* ``PIPE_CAP_VENDOR_ID``: The vendor ID of the underlying hardware. If it's
  not available one should return 0xFFFFFFFF.
* ``PIPE_CAP_DEVICE_ID``: The device ID (PCI ID) of the underlying hardware.
  0xFFFFFFFF if not available.
* ``PIPE_CAP_ACCELERATED``: Whether the renderer is hardware accelerated.
* ``PIPE_CAP_VIDEO_MEMORY``: The amount of video memory in megabytes.
* ``PIPE_CAP_UMA``: If the device has a unified memory architecture or on-card
  memory and GART.
* ``PIPE_CAP_CONDITIONAL_RENDER_INVERTED``: Whether the driver supports inverted
  condition for conditional rendering.
* ``PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE``: The maximum supported vertex stride.
* ``PIPE_CAP_SAMPLER_VIEW_TARGET``: Whether the sampler view's target can be
  different than the underlying resource's, as permitted by
  ARB_texture_view. For example a 2d array texture may be reinterpreted as a
  cube (array) texture and vice-versa.
* ``PIPE_CAP_CLIP_HALFZ``: Whether the driver supports the
  pipe_rasterizer_state::clip_halfz being set to true. This is required
  for enabling ARB_clip_control.
d240 1
a240 3
* ``PIPE_SHADER_CAP_MAX_OUTPUTS``: The maximum number of output registers.
  This is valid for all shaders except the fragment shader.
* ``PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE``: The maximum size per constant buffer in bytes.
d259 1
a279 2
* ``PIPE_SHADER_CAP_DOUBLES``: Whether double precision floating-point
  operations are supported.
d292 2
a293 2
  This CAP is only relevant for drivers that specify PIPE_SHADER_IR_LLVM
  or PIPE_SHADER_IR_NATIVE for their preferred IR.
a317 4
* ``PIPE_COMPUTE_CAP_MAX_COMPUTE_UNITS``: Maximum number of compute units
  Value type: ``uint32_t``
* ``PIPE_COMPUTE_CAP_IMAGES_SUPPORTED``: Whether images are supported
  non-zero means yes, zero means no. Value type: ``uint32_t``
a361 3
* ``PIPE_BIND_COMMAND_ARGS_BUFFER``: A buffer that may be sourced by the
  GPU command processor. It can contain, for example, the arguments to
  indirect draw calls.
a449 2

For PIPE_TEXTURE_CUBE, the pipe_resource::array_size field should be 6.
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d177 4
a180 2
* ``PIPE_CAP_TGSI_VS_LAYER``: Whether TGSI_SEMANTIC_LAYER is supported
  as a vertex shader output.
d205 31
d273 3
a275 1
* ``PIPE_SHADER_CAP_MAX_CONSTS``: The maximum number of constants.
a293 1
* ``PIPE_SHADER_CAP_MAX_ADDRS``: The maximum number of address registers.
d314 2
d328 2
a329 2
  This CAP is only relevant for drivers that specify PIPE_SHADER_IR_LLVM for
  their preferred IR.
d354 4
d402 3
d493 2
@


1.4
log
@Merge Mesa 9.2.0
@
text
@a55 2
* ``PIPE_CAP_MAX_COMBINED_SAMPLERS``: The total number of samplers accessible from
  the vertex and fragment shader, inclusive.
d105 2
a106 1
  resources.
d120 6
a125 4
  resources.
* ``PIPE_CAP_USER_CONSTANT_BUFFERS``: Whether user constant buffers are
  supported. If not, the state tracker must upload constants which are not in hw
  resources.
d171 2
a172 2
  viewport/scissor combination.  
* ''PIPE_CAP_ENDIANNESS``:: The endianness of the device.  Either
d174 29
d245 1
a245 1
  
d257 1
a257 1
  
d274 1
a274 1
* ``PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS``: THe maximum number of texture
d278 2
d316 2
d369 2
d372 8
a379 5
* ``PIPE_USAGE_DEFAULT``: Expect many uploads to the resource, intermixed with draws.
* ``PIPE_USAGE_DYNAMIC``: Expect many uploads to the resource, intermixed with draws.
* ``PIPE_USAGE_STATIC``: Same as immutable (?)
* ``PIPE_USAGE_IMMUTABLE``: Resource will not be changed after first upload.
* ``PIPE_USAGE_STREAM``: Upload will be followed by draw, followed by upload, ...
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d25 1
a25 2
* ``MAX_TEXTURE_IMAGE_UNITS``: The maximum number of samplers available.
* ``NPOT_TEXTURES``: Whether :term:`NPOT` textures may have repeat modes,
d27 1
a27 1
* ``TWO_SIDED_STENCIL``: Whether the stencil test can also affect back-facing
d29 1
a29 2
* ``GLSL``: Deprecated.
* ``DUAL_SOURCE_BLEND``: Whether dual-source blend factors are supported. See
d31 3
a33 3
* ``ANISOTROPIC_FILTER``: Whether textures can be filtered anisotropically.
* ``POINT_SPRITE``: Whether point sprites are available.
* ``MAX_RENDER_TARGETS``: The maximum number of render targets that may be
d35 3
a37 4
* ``OCCLUSION_QUERY``: Whether occlusion queries are available.
* ``TIMER_QUERY``: Whether timer queries are available.
* ``INSTANCED_DRAWING``: indicates support for instanced drawing.
* ``TEXTURE_SHADOW_MAP``: indicates whether the fragment shader hardware
d40 3
a42 1
* ``MAX_TEXTURE_2D_LEVELS``: The maximum number of mipmap levels available
d44 1
a44 1
* ``MAX_TEXTURE_3D_LEVELS``: The maximum number of mipmap levels available
d46 1
a46 1
* ``MAX_TEXTURE_CUBE_LEVELS``: The maximum number of mipmap levels available
d48 1
a48 1
* ``TEXTURE_MIRROR_CLAMP``: Whether mirrored texture coordinates with clamp
d50 1
a50 7
* ``TEXTURE_MIRROR_REPEAT``: Whether mirrored repeating texture coordinates
  are supported.
* ``MAX_VERTEX_TEXTURE_UNITS``: The maximum number of samplers addressable
  inside the vertex shader. If this is 0, then the vertex shader cannot
  sample textures.
* ``TGSI_CONT_SUPPORTED``: Whether the TGSI CONT opcode is supported.
* ``BLEND_EQUATION_SEPARATE``: Whether alpha blend equations may be different
d52 1
a52 1
* ``SM3``: Whether the vertex shader and fragment shader support equivalent
d54 3
a56 8
* ``MAX_PREDICATE_REGISTERS``: indicates the number of predicate registers
  available.  Predicate register may be set as a side-effect of ALU
  instructions to indicate less than, greater than or equal to zero.
  Later instructions can use a predicate register to control writing to
  each channel of destination registers.  NOTE: predicate registers have
  not been fully implemented in Gallium at this time.  See the
  GL_NV_fragment_program extension for more info (look for "condition codes").
* ``MAX_COMBINED_SAMPLERS``: The total number of samplers accessible from
d58 1
a58 19
* ``MAX_CONST_BUFFERS``: Maximum number of constant buffers that can be bound
  to any shader stage using ``set_constant_buffer``. If 0 or 1, the pipe will
  only permit binding one constant buffer per shader, and the shaders will
  not permit two-dimensional access to constants.

If a value greater than 0 is returned, the driver can have multiple
constant buffers bound to shader stages. The CONST register file can
be accessed with two-dimensional indices, like in the example below.

DCL CONST[0][0..7]       # declare first 8 vectors of constbuf 0
DCL CONST[3][0]          # declare first vector of constbuf 3
MOV OUT[0], CONST[0][3]  # copy vector 3 of constbuf 0

For backwards compatibility, one-dimensional access to CONST register
file is still supported. In that case, the constbuf index is assumed
to be 0.

* ``MAX_CONST_BUFFER_SIZE``: Maximum byte size of a single constant buffer.
* ``INDEP_BLEND_ENABLE``: Whether per-rendertarget blend enabling and channel
d61 1
a61 1
* ``INDEP_BLEND_FUNC``: Whether per-rendertarget blend functions are
d64 3
d75 104
d180 1
a180 1
The floating-point capabilities:
d182 5
a186 5
* ``MAX_LINE_WIDTH``: The maximum width of a regular line.
* ``MAX_LINE_WIDTH_AA``: The maximum width of a smoothed line.
* ``MAX_POINT_WIDTH``: The maximum width and height of a point.
* ``MAX_POINT_WIDTH_AA``: The maximum width and height of a smoothed point.
* ``MAX_TEXTURE_ANISOTROPY``: The maximum level of anisotropy that can be
d188 1
a188 1
* ``MAX_TEXTURE_LOD_BIAS``: The maximum :term:`LOD` bias that may be applied
d190 4
a193 2
* ``GUARD_BAND_LEFT``, ``GUARD_BAND_TOP``, ``GUARD_BAND_RIGHT``,
  ``GUARD_BAND_BOTTOM``: XXX
a194 1
Fragment shader limits:
d196 1
a196 10
* ``PIPE_CAP_MAX_FS_INSTRUCTIONS``: The maximum number of instructions.
* ``PIPE_CAP_MAX_FS_ALU_INSTRUCTIONS``: The maximum number of arithmetic instructions.
* ``PIPE_CAP_MAX_FS_TEX_INSTRUCTIONS``: The maximum number of texture instructions.
* ``PIPE_CAP_MAX_FS_TEX_INDIRECTIONS``: The maximum number of texture indirections.
* ``PIPE_CAP_MAX_FS_CONTROL_FLOW_DEPTH``: The maximum nested control flow depth.
* ``PIPE_CAP_MAX_FS_INPUTS``: The maximum number of input registers.
* ``PIPE_CAP_MAX_FS_CONSTS``: The maximum number of constants.
* ``PIPE_CAP_MAX_FS_TEMPS``: The maximum number of temporary registers.
* ``PIPE_CAP_MAX_FS_ADDRS``: The maximum number of address registers.
* ``PIPE_CAP_MAX_FS_PREDS``: The maximum number of predicate registers.
d198 2
a199 1
Vertex shader limits:
d201 2
a202 1
* ``PIPE_CAP_MAX_VS_*``: Identical to ``PIPE_CAP_MAX_FS_*``.
d204 80
d303 5
d317 1
d322 6
a342 14

PIPE_TEXTURE_GEOM
^^^^^^^^^^^^^^^^^

These flags are used when querying whether a particular pipe_format is
supported by the driver (with the `is_format_supported` function).
Some formats may only be supported for certain kinds of textures.
For example, a compressed format might only be used for POT textures.

* ``PIPE_TEXTURE_GEOM_NON_SQUARE``: The texture may not be square
* ``PIPE_TEXTURE_GEOM_NON_POWER_OF_TWO``: The texture dimensions may not be
  powers of two.


d403 10
d456 20
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d39 1
d276 1
a276 1
**array_size the array size for 1D and 2D array textures.
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d1 2
d8 5
a12 2
Useful Flags
------------
d16 2
a17 2
PIPE_CAP
^^^^^^^^
d19 2
a20 2
Pipe capabilities help expose hardware functionality not explicitly required
by Gallium. For floating-point values, use :ref:`get_paramf`, and for boolean
d38 4
a41 1
* ``TEXTURE_SHADOW_MAP``: XXX
d60 7
a66 1
* ``MAX_PREDICATE_REGISTERS``: XXX
d73 13
d115 1
a115 9
XXX Is there a better home for this? vvv

If 0 is returned, the driver is not aware of multiple constant buffers,
supports binding of only one constant buffer, and does not support
two-dimensional CONST register file access in TGSI shaders.

If a value greater than 0 is returned, the driver can have multiple
constant buffers bound to shader stages. The CONST register file can
be accessed with two-dimensional indices, like in the example below.
d117 47
a163 3
DCL CONST[0][0..7]       # declare first 8 vectors of constbuf 0
DCL CONST[3][0]          # declare first vector of constbuf 3
MOV OUT[0], CONST[0][3]  # copy vector 3 of constbuf 0
d165 1
a165 3
For backwards compatibility, one-dimensional access to CONST register
file is still supported. In that case, the constbuf index is assumed
to be 0.
d167 2
a168 1
.. _pipe_buffer_usage:
d170 1
a170 2
PIPE_BUFFER_USAGE
^^^^^^^^^^^^^^^^^
d172 5
a176 2
These flags control buffer creation. Buffers may only have one role, so
care should be taken to not allocate a buffer with the wrong usage.
a177 45
* ``PIXEL``: This is the flag to use for all textures.
* ``VERTEX``: A vertex buffer.
* ``INDEX``: An element buffer.
* ``CONSTANT``: A buffer of shader constants.

Buffers are inevitably abstracting the pipe's underlying memory management,
so many of their usage flags can be used to direct the way the buffer is
handled.

* ``CPU_READ``, ``CPU_WRITE``: Whether the user will map and, in the case of
  the latter, write to, the buffer. The convenience flag ``CPU_READ_WRITE`` is
  available to signify a read/write buffer.
* ``GPU_READ``, ``GPU_WRITE``: Whether the driver will internally need to
  read from or write to the buffer. The latter will only happen if the buffer
  is made into a render target.
* ``DISCARD``: When set on a map, the contents of the map will be discarded
  beforehand. Cannot be used with ``CPU_READ``.
* ``DONTBLOCK``: When set on a map, the map will fail if the buffer cannot be
  mapped immediately.
* ``UNSYNCHRONIZED``: When set on a map, any outstanding operations on the
  buffer will be ignored. The interaction of any writes to the map and any
  operations pending with the buffer are undefined. Cannot be used with
  ``CPU_READ``.
* ``FLUSH_EXPLICIT``: When set on a map, written ranges of the map require
  explicit flushes using :ref:`buffer_flush_mapped_range`. Requires
  ``CPU_WRITE``.

.. _pipe_texture_usage:

PIPE_TEXTURE_USAGE
^^^^^^^^^^^^^^^^^^

These flags determine the possible roles a texture may be used for during its
lifetime. Texture usage flags are cumulative and may be combined to create a
texture that can be used as multiple things.

* ``RENDER_TARGET``: A color buffer or pixel buffer which will be rendered to.
* ``DISPLAY_TARGET``: A sharable buffer that can be given to another process.
* ``PRIMARY``: A front color buffer or scanout buffer.
* ``DEPTH_STENCIL``: A depth (Z) buffer or stencil buffer.  Gallium does
  not explicitly provide for stencil-only buffers, so any stencil buffer
  validated here is implicitly also a depth buffer.
* ``SAMPLER``: A texture that may be sampled from in a fragment or vertex
  shader.
* ``DYNAMIC``: A texture that will be mapped frequently.
d196 1
a196 1
XXX moar; got bored
d238 1
a238 1
See if a format can be used in a specific manner.
d240 1
a240 1
**usage** is a bitmask of :ref:`PIPE_TEXTURE_USAGE` flags.
d242 1
a242 1
Returns TRUE if all usages can be satisfied.
d244 2
a245 1
.. note::
d247 1
a247 1
   ``PIPE_TEXTURE_USAGE_DYNAMIC`` is not a valid usage.
d249 1
a249 1
.. _texture_create:
d251 1
a251 2
texture_create
^^^^^^^^^^^^^^
d253 1
a253 1
Given a template of texture setup, create a buffer and texture.
d255 1
a255 1
texture_blanket
d258 2
a259 5
Like :ref:`texture_create`, but use a supplied buffer instead of creating a
new one.

texture_destroy
^^^^^^^^^^^^^^^
d261 3
a263 2
Destroy a texture. The buffer backing the texture is destroyed if it has no
more references.
d265 1
a265 2
buffer_map
^^^^^^^^^^
d267 1
a267 1
Map a buffer into memory.
d269 2
a270 1
**usage** is a bitmask of :ref:`PIPE_BUFFER_USAGE` flags.
d272 2
a273 1
Returns a pointer to the map, or NULL if the mapping failed.
d275 2
a276 2
buffer_map_range
^^^^^^^^^^^^^^^^
d278 1
a278 1
Map a range of a buffer into memory.
d280 2
a281 2
The returned map is always relative to the beginning of the buffer, not the
beginning of the mapped range.
d283 1
a283 1
.. _buffer_flush_mapped_range:
d285 1
a285 2
buffer_flush_mapped_range
^^^^^^^^^^^^^^^^^^^^^^^^^
d287 1
a287 1
Flush a range of mapped memory into a buffer.
a288 1
The buffer must have been mapped with ``PIPE_BUFFER_USAGE_FLUSH_EXPLICIT``.
a289 1
**usage** is a bitmask of :ref:`PIPE_BUFFER_USAGE` flags.
d291 2
a292 2
buffer_unmap
^^^^^^^^^^^^
d294 1
a294 1
Unmap a buffer from memory.
a295 1
Any pointers into the map should be considered invalid and discarded.
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a0 2
.. _screen:

d6 2
a7 5
Flags and enumerations
----------------------

XXX some of these don't belong in this section.

d11 2
a12 2
PIPE_CAP_*
^^^^^^^^^^
d14 2
a15 2
Capability queries return information about the features and limits of the
driver/GPU.  For floating-point values, use :ref:`get_paramf`, and for boolean
d33 1
a33 4
* ``TIMER_QUERY``: Whether timer queries are available.
* ``TEXTURE_SHADOW_MAP``: indicates whether the fragment shader hardware
  can do the depth texture / Z comparison operation in TEX instructions
  for shadow testing.
d52 1
a52 7
* ``MAX_PREDICATE_REGISTERS``: indicates the number of predicate registers
  available.  Predicate register may be set as a side-effect of ALU
  instructions to indicate less than, greater than or equal to zero.
  Later instructions can use a predicate register to control writing to
  each channel of destination registers.  NOTE: predicate registers have
  not been fully implemented in Gallium at this time.  See the
  GL_NV_fragment_program extension for more info (look for "condition codes").
a58 13

If a value greater than 0 is returned, the driver can have multiple
constant buffers bound to shader stages. The CONST register file can
be accessed with two-dimensional indices, like in the example below.

DCL CONST[0][0..7]       # declare first 8 vectors of constbuf 0
DCL CONST[3][0]          # declare first vector of constbuf 3
MOV OUT[0], CONST[0][3]  # copy vector 3 of constbuf 0

For backwards compatibility, one-dimensional access to CONST register
file is still supported. In that case, the constbuf index is assumed
to be 0.

d88 9
a96 1
Fragment shader limits:
d98 3
a100 47
* ``PIPE_CAP_MAX_FS_INSTRUCTIONS``: The maximum number of instructions.
* ``PIPE_CAP_MAX_FS_ALU_INSTRUCTIONS``: The maximum number of arithmetic instructions.
* ``PIPE_CAP_MAX_FS_TEX_INSTRUCTIONS``: The maximum number of texture instructions.
* ``PIPE_CAP_MAX_FS_TEX_INDIRECTIONS``: The maximum number of texture indirections.
* ``PIPE_CAP_MAX_FS_CONTROL_FLOW_DEPTH``: The maximum nested control flow depth.
* ``PIPE_CAP_MAX_FS_INPUTS``: The maximum number of input registers.
* ``PIPE_CAP_MAX_FS_CONSTS``: The maximum number of constants.
* ``PIPE_CAP_MAX_FS_TEMPS``: The maximum number of temporary registers.
* ``PIPE_CAP_MAX_FS_ADDRS``: The maximum number of address registers.
* ``PIPE_CAP_MAX_FS_PREDS``: The maximum number of predicate registers.

Vertex shader limits:

* ``PIPE_CAP_MAX_VS_*``: Identical to ``PIPE_CAP_MAX_FS_*``.


.. _pipe_bind:

PIPE_BIND_*
^^^^^^^^^^^

These flags indicate how a resource will be used and are specified at resource
creation time. Resources may be used in different roles
during their lifecycle. Bind flags are cumulative and may be combined to create
a resource which can be used for multiple things.
Depending on the pipe driver's memory management and these bind flags,
resources might be created and handled quite differently.

* ``PIPE_BIND_RENDER_TARGET``: A color buffer or pixel buffer which will be
  rendered to.  Any surface/resource attached to pipe_framebuffer_state::cbufs
  must have this flag set.
* ``PIPE_BIND_DEPTH_STENCIL``: A depth (Z) buffer and/or stencil buffer. Any
  depth/stencil surface/resource attached to pipe_framebuffer_state::zsbuf must
  have this flag set.
* ``PIPE_BIND_DISPLAY_TARGET``: A surface that can be presented to screen. Arguments to
  pipe_screen::flush_front_buffer must have this flag set.
* ``PIPE_BIND_SAMPLER_VIEW``: A texture that may be sampled from in a fragment
  or vertex shader.
* ``PIPE_BIND_VERTEX_BUFFER``: A vertex buffer.
* ``PIPE_BIND_INDEX_BUFFER``: An vertex index/element buffer.
* ``PIPE_BIND_CONSTANT_BUFFER``: A buffer of shader constants.
* ``PIPE_BIND_TRANSFER_WRITE``: A transfer object which will be written to.
* ``PIPE_BIND_TRANSFER_READ``: A transfer object which will be read from.
* ``PIPE_BIND_CUSTOM``:
* ``PIPE_BIND_SCANOUT``: A front color buffer or scanout buffer.
* ``PIPE_BIND_SHARED``: A sharable buffer that can be given to another
  process.
d102 3
a104 1
.. _pipe_usage:
d106 1
a106 2
PIPE_USAGE_*
^^^^^^^^^^^^
d108 2
a109 1
The PIPE_USAGE enums are hints about the expected usage pattern of a resource.
d111 2
a112 5
* ``PIPE_USAGE_DEFAULT``: Expect many uploads to the resource, intermixed with draws.
* ``PIPE_USAGE_DYNAMIC``: Expect many uploads to the resource, intermixed with draws.
* ``PIPE_USAGE_STATIC``: Same as immutable (?)
* ``PIPE_USAGE_IMMUTABLE``: Resource will not be changed after first upload.
* ``PIPE_USAGE_STREAM``: Upload will be followed by draw, followed by upload, ...
d114 45
d177 1
a177 1
XXX to-do
d219 1
a219 1
Determine if a resource in the given format can be used in a specific manner.
d221 1
a221 1
**format** the resource format
d223 1
a223 1
**target** one of the PIPE_TEXTURE_x flags
d225 1
a225 2
**sample_count** the number of samples. 0 and 1 mean no multisampling,
the maximum allowed legal value is 32.
d227 1
a227 1
**bindings** is a bitmask of :ref:`PIPE_BIND` flags.
d229 1
a229 1
**geom_flags** is a bitmask of PIPE_TEXTURE_GEOM_x flags.
d231 2
a232 1
Returns TRUE if all usages can be satisfied.
d234 1
a234 1
.. _resource_create:
d236 1
a236 1
resource_create
d239 5
a243 2
Create a new resource from a template.
The following fields of the pipe_resource must be specified in the template:
d245 2
a246 3
**target** one of the pipe_texture_target enums.
Note that PIPE_BUFFER and PIPE_TEXTURE_X are not really fundamentally different.
Modern APIs allow using buffers as shader resources.
d248 2
a249 1
**format** one of the pipe_format enums.
d251 1
a251 1
**width0** the width of the base mip level of the texture or size of the buffer.
d253 1
a253 2
**height0** the height of the base mip level of the texture
(1 for 1D or 1D array textures).
d255 1
a255 2
**depth0** the depth of the base mip level of the texture
(1 for everything else).
d257 2
a258 2
**array_size the array size for 1D and 2D array textures.
For cube maps this must be 6, for other textures 1.
d260 1
a260 1
**last_level** the last mip map level present.
d262 2
a263 2
**nr_samples** the nr of msaa samples. 0 (or 1) specifies a resource
which isn't multisampled.
d265 1
a265 1
**usage** one of the PIPE_USAGE flags.
d267 2
a268 1
**bind** bitmask of the PIPE_BIND flags.
d270 1
a270 1
**flags** bitmask of PIPE_RESOURCE_FLAG flags.
d272 1
d274 1
d276 2
a277 2
resource_destroy
^^^^^^^^^^^^^^^^
d279 1
a279 1
Destroy a resource. A resource is destroyed if it has no more references.
d281 1
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d25 2
a26 1
* ``PIPE_CAP_NPOT_TEXTURES``: Whether :term:`NPOT` textures may have repeat modes,
d28 1
a28 1
* ``PIPE_CAP_TWO_SIDED_STENCIL``: Whether the stencil test can also affect back-facing
d30 2
a31 1
* ``PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS``: How many dual-source blend RTs are support.
d33 3
a35 3
* ``PIPE_CAP_ANISOTROPIC_FILTER``: Whether textures can be filtered anisotropically.
* ``PIPE_CAP_POINT_SPRITE``: Whether point sprites are available.
* ``PIPE_CAP_MAX_RENDER_TARGETS``: The maximum number of render targets that may be
d37 3
a39 3
* ``PIPE_CAP_OCCLUSION_QUERY``: Whether occlusion queries are available.
* ``PIPE_CAP_QUERY_TIME_ELAPSED``: Whether PIPE_QUERY_TIME_ELAPSED queries are available.
* ``PIPE_CAP_TEXTURE_SHADOW_MAP``: indicates whether the fragment shader hardware
d42 1
a42 3
* ``PIPE_CAP_TEXTURE_SWIZZLE``: Whether swizzling through sampler views is
  supported.
* ``PIPE_CAP_MAX_TEXTURE_2D_LEVELS``: The maximum number of mipmap levels available
d44 1
a44 1
* ``PIPE_CAP_MAX_TEXTURE_3D_LEVELS``: The maximum number of mipmap levels available
d46 1
a46 1
* ``PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS``: The maximum number of mipmap levels available
d48 1
a48 1
* ``PIPE_CAP_TEXTURE_MIRROR_CLAMP``: Whether mirrored texture coordinates with clamp
d50 7
a56 1
* ``PIPE_CAP_BLEND_EQUATION_SEPARATE``: Whether alpha blend equations may be different
d58 1
a58 1
* ``PIPE_CAP_SM3``: Whether the vertex shader and fragment shader support equivalent
d60 8
a67 3
* ``PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS``: The maximum number of stream buffers.
* ``PIPE_CAP_PRIMITIVE_RESTART``: Whether primitive restart is supported.
* ``PIPE_CAP_MAX_COMBINED_SAMPLERS``: The total number of samplers accessible from
d69 19
a87 1
* ``PIPE_CAP_INDEP_BLEND_ENABLE``: Whether per-rendertarget blend enabling and channel
d90 1
a90 1
* ``PIPE_CAP_INDEP_BLEND_FUNC``: Whether per-rendertarget blend functions are
a92 3
* ``PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS``: The maximum number of texture array
  layers supported. If 0, the array textures are not supported at all and
  the ARRAY texture targets are invalid.
a100 104
* ``PIPE_CAP_DEPTH_CLIP_DISABLE``: Whether the driver is capable of disabling
  depth clipping (through pipe_rasterizer_state)
* ``PIPE_CAP_SHADER_STENCIL_EXPORT``: Whether a stencil reference value can be
  written from a fragment shader.
* ``PIPE_CAP_TGSI_INSTANCEID``: Whether TGSI_SEMANTIC_INSTANCEID is supported
  in the vertex shader.
* ``PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR``: Whether the driver supports
  per-instance vertex attribs.
* ``PIPE_CAP_FRAGMENT_COLOR_CLAMPED``: Whether fragment color clamping is
  supported.  That is, is the pipe_rasterizer_state::clamp_fragment_color
  flag supported by the driver?  If not, the state tracker will insert
  clamping code into the fragment shaders when needed.

* ``PIPE_CAP_MIXED_COLORBUFFER_FORMATS``: Whether mixed colorbuffer formats are
  supported, e.g. RGBA8 and RGBA32F as the first and second colorbuffer, resp.
* ``PIPE_CAP_VERTEX_COLOR_UNCLAMPED``: Whether the driver is capable of
  outputting unclamped vertex colors from a vertex shader. If unsupported,
  the vertex colors are always clamped. This is the default for DX9 hardware.
* ``PIPE_CAP_VERTEX_COLOR_CLAMPED``: Whether the driver is capable of
  clamping vertex colors when they come out of a vertex shader, as specified
  by the pipe_rasterizer_state::clamp_vertex_color flag.  If unsupported,
  the vertex colors are never clamped. This is the default for DX10 hardware.
  If both clamped and unclamped CAPs are supported, the clamping can be
  controlled through pipe_rasterizer_state.  If the driver cannot do vertex
  color clamping, the state tracker may insert clamping code into the vertex
  shader.
* ``PIPE_CAP_GLSL_FEATURE_LEVEL``: Whether the driver supports features
  equivalent to a specific GLSL version. E.g. for GLSL 1.3, report 130.
* ``PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION``: Whether quads adhere to
  the flatshade_first setting in ``pipe_rasterizer_state``.
* ``PIPE_CAP_USER_VERTEX_BUFFERS``: Whether the driver supports user vertex
  buffers.  If not, the state tracker must upload all data which is not in hw
  resources.
* ``PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY``: This CAP describes a hw
  limitation.  If true, pipe_vertex_buffer::buffer_offset must always be aligned
  to 4.  If false, there are no restrictions on the offset.
* ``PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY``: This CAP describes a hw
  limitation.  If true, pipe_vertex_buffer::stride must always be aligned to 4.
  If false, there are no restrictions on the stride.
* ``PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY``: This CAP describes
  a hw limitation.  If true, pipe_vertex_element::src_offset must always be
  aligned to 4.  If false, there are no restrictions on src_offset.
* ``PIPE_CAP_COMPUTE``: Whether the implementation supports the
  compute entry points defined in pipe_context and pipe_screen.
* ``PIPE_CAP_USER_INDEX_BUFFERS``: Whether user index buffers are supported.
  If not, the state tracker must upload all indices which are not in hw
  resources.
* ``PIPE_CAP_USER_CONSTANT_BUFFERS``: Whether user constant buffers are
  supported. If not, the state tracker must upload constants which are not in hw
  resources.
* ``PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT``: Describes the required
  alignment of pipe_constant_buffer::buffer_offset.
* ``PIPE_CAP_START_INSTANCE``: Whether the driver supports
  pipe_draw_info::start_instance.
* ``PIPE_CAP_QUERY_TIMESTAMP``: Whether PIPE_QUERY_TIMESTAMP and
  the pipe_screen::get_timestamp hook are implemented.
* ``PIPE_CAP_TEXTURE_MULTISAMPLE``: Whether all MSAA resources supported
  for rendering are also supported for texturing.
* ``PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT``: The minimum alignment that should be
  expected for a pointer returned by transfer_map if the resource is
  PIPE_BUFFER. In other words, the pointer returned by transfer_map is
  always aligned to this value.
* ``PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT``: Describes the required
  alignment for pipe_sampler_view::u.buf.first_element, in bytes.
  If a driver does not support first/last_element, it should return 0.
* ``PIPE_CAP_TGSI_TEXCOORD``: This CAP describes a hw limitation.
  If true, the hardware cannot replace arbitrary shader inputs with sprite
  coordinates and hence the inputs that are desired to be replaceable must
  be declared with TGSI_SEMANTIC_TEXCOORD instead of TGSI_SEMANTIC_GENERIC.
  The rasterizer's sprite_coord_enable state therefore also applies to the
  TEXCOORD semantic.
  Also, TGSI_SEMANTIC_PCOORD becomes available, which labels a fragment shader
  input that will always be replaced with sprite coordinates.
* ``PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER``: Whether it is preferable
  to use a blit to implement a texture transfer which needs format conversions
  and swizzling in state trackers. Generally, all hardware drivers with
  dedicated memory should return 1 and all software rasterizers should return 0.
* ``PIPE_CAP_QUERY_PIPELINE_STATISTICS``: Whether PIPE_QUERY_PIPELINE_STATISTICS
  is supported.
* ``PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK``: Bitmask indicating whether special
  considerations have to be given to the interaction between the border color
  in the sampler object and the sampler view used with it.
  If PIPE_QUIRK_TEXTURE_BORDER_COLOR_SWIZZLE_R600 is set, the border color
  may be affected in undefined ways for any kind of permutational swizzle
  (any swizzle XYZW where X/Y/Z/W are not ZERO, ONE, or R/G/B/A respectively)
  in the sampler view.
  If PIPE_QUIRK_TEXTURE_BORDER_COLOR_SWIZZLE_NV50 is set, the border color
  state should be swizzled manually according to the swizzle in the sampler
  view it is intended to be used with, or herein undefined results may occur
  for permutational swizzles.
* ``PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE``: The maximum accessible size with
  a buffer sampler view, in bytes.
* ``PIPE_CAP_MAX_VIEWPORTS``: The maximum number of viewports (and scissors
  since they are linked) a driver can support. Returning 0 is equivalent
  to returning 1 because every driver has to support at least a single
  viewport/scissor combination.  
* ''PIPE_CAP_ENDIANNESS``:: The endianness of the device.  Either
  PIPE_ENDIAN_BIG or PIPE_ENDIAN_LITTLE.


.. _pipe_capf:

PIPE_CAPF_*
^^^^^^^^^^^^^^^^
d102 1
a102 1
The floating-point capabilities are:
d104 5
a108 5
* ``PIPE_CAPF_MAX_LINE_WIDTH``: The maximum width of a regular line.
* ``PIPE_CAPF_MAX_LINE_WIDTH_AA``: The maximum width of a smoothed line.
* ``PIPE_CAPF_MAX_POINT_WIDTH``: The maximum width and height of a point.
* ``PIPE_CAPF_MAX_POINT_WIDTH_AA``: The maximum width and height of a smoothed point.
* ``PIPE_CAPF_MAX_TEXTURE_ANISOTROPY``: The maximum level of anisotropy that can be
d110 1
a110 1
* ``PIPE_CAPF_MAX_TEXTURE_LOD_BIAS``: The maximum :term:`LOD` bias that may be applied
d112 2
a113 4
* ``PIPE_CAPF_GUARD_BAND_LEFT``,
  ``PIPE_CAPF_GUARD_BAND_TOP``,
  ``PIPE_CAPF_GUARD_BAND_RIGHT``,
  ``PIPE_CAPF_GUARD_BAND_BOTTOM``: TODO
d115 1
d117 10
a126 1
.. _pipe_shader_cap:
d128 1
a128 2
PIPE_SHADER_CAP_*
^^^^^^^^^^^^^^^^^
d130 1
a130 2
These are per-shader-stage capabitity queries. Different shader stages may
support different features.
a131 80
* ``PIPE_SHADER_CAP_MAX_INSTRUCTIONS``: The maximum number of instructions.
* ``PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS``: The maximum number of arithmetic instructions.
* ``PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS``: The maximum number of texture instructions.
* ``PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS``: The maximum number of texture indirections.
* ``PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH``: The maximum nested control flow depth.
* ``PIPE_SHADER_CAP_MAX_INPUTS``: The maximum number of input registers.
* ``PIPE_SHADER_CAP_MAX_CONSTS``: The maximum number of constants.
* ``PIPE_SHADER_CAP_MAX_CONST_BUFFERS``: Maximum number of constant buffers that can be bound
  to any shader stage using ``set_constant_buffer``. If 0 or 1, the pipe will
  only permit binding one constant buffer per shader, and the shaders will
  not permit two-dimensional access to constants.
  
If a value greater than 0 is returned, the driver can have multiple
constant buffers bound to shader stages. The CONST register file can
be accessed with two-dimensional indices, like in the example below.

DCL CONST[0][0..7]       # declare first 8 vectors of constbuf 0
DCL CONST[3][0]          # declare first vector of constbuf 3
MOV OUT[0], CONST[0][3]  # copy vector 3 of constbuf 0

For backwards compatibility, one-dimensional access to CONST register
file is still supported. In that case, the constbuf index is assumed
to be 0.
  
* ``PIPE_SHADER_CAP_MAX_TEMPS``: The maximum number of temporary registers.
* ``PIPE_SHADER_CAP_MAX_ADDRS``: The maximum number of address registers.
* ``PIPE_SHADER_CAP_MAX_PREDS``: The maximum number of predicate registers.
* ``PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED``: Whether the continue opcode is supported.
* ``PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR``: Whether indirect addressing
  of the input file is supported.
* ``PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR``: Whether indirect addressing
  of the output file is supported.
* ``PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR``: Whether indirect addressing
  of the temporary file is supported.
* ``PIPE_SHADER_CAP_INDIRECT_CONST_ADDR``: Whether indirect addressing
  of the constant file is supported.
* ``PIPE_SHADER_CAP_SUBROUTINES``: Whether subroutines are supported, i.e.
  BGNSUB, ENDSUB, CAL, and RET, including RET in the main block.
* ``PIPE_SHADER_CAP_INTEGERS``: Whether integer opcodes are supported.
  If unsupported, only float opcodes are supported.
* ``PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS``: THe maximum number of texture
  samplers.
* ``PIPE_SHADER_CAP_PREFERRED_IR``: Preferred representation of the
  program.  It should be one of the ``pipe_shader_ir`` enum values.


.. _pipe_compute_cap:

PIPE_COMPUTE_CAP_*
^^^^^^^^^^^^^^^^^^

Compute-specific capabilities. They can be queried using
pipe_screen::get_compute_param.

* ``PIPE_COMPUTE_CAP_IR_TARGET``: A description of the target of the form
  ``processor-arch-manufacturer-os`` that will be passed on to the compiler.
  This CAP is only relevant for drivers that specify PIPE_SHADER_IR_LLVM for
  their preferred IR.
  Value type: null-terminated string.
* ``PIPE_COMPUTE_CAP_GRID_DIMENSION``: Number of supported dimensions
  for grid and block coordinates.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_GRID_SIZE``: Maximum grid size in block
  units.  Value type: ``uint64_t []``.
* ``PIPE_COMPUTE_CAP_MAX_BLOCK_SIZE``: Maximum block size in thread
  units.  Value type: ``uint64_t []``.
* ``PIPE_COMPUTE_CAP_MAX_THREADS_PER_BLOCK``: Maximum number of threads that
  a single block can contain.  Value type: ``uint64_t``.
  This may be less than the product of the components of MAX_BLOCK_SIZE and is
  usually limited by the number of threads that can be resident simultaneously
  on a compute unit.
* ``PIPE_COMPUTE_CAP_MAX_GLOBAL_SIZE``: Maximum size of the GLOBAL
  resource.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_LOCAL_SIZE``: Maximum size of the LOCAL
  resource.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_PRIVATE_SIZE``: Maximum size of the PRIVATE
  resource.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_INPUT_SIZE``: Maximum size of the INPUT
  resource.  Value type: ``uint64_t``.
* ``PIPE_COMPUTE_CAP_MAX_MEM_ALLOC_SIZE``: Maximum size of a memory object
  allocation in bytes.  Value type: ``uint64_t``.
a150 5
* ``PIPE_BIND_BLENDABLE``: Used in conjunction with PIPE_BIND_RENDER_TARGET to
  query whether a device supports blending for a given format.
  If this flag is set, surface creation may fail if blending is not supported
  for the specified format. If it is not set, a driver may choose to ignore
  blending on surfaces with formats that would require emulation.
a159 1
* ``PIPE_BIND_STREAM_OUTPUT``: A stream output buffer.
a163 6
* ``PIPE_BIND_GLOBAL``: A buffer that can be mapped into the global
  address space of a compute program.
* ``PIPE_BIND_SHADER_RESOURCE``: A buffer or texture that can be
  bound to the graphics pipeline as a shader resource.
* ``PIPE_BIND_COMPUTE_RESOURCE``: A buffer or texture that can be
  bound to the compute program as a shader resource.
d179 14
a252 10

can_create_resource
^^^^^^^^^^^^^^^^^^^

Check if a resource can actually be created (but don't actually allocate any
memory).  This is used to implement OpenGL's proxy textures.  Typically, a
driver will simply check if the total size of the given resource is less than
some limit.


d275 1
a275 1
**array_size** the array size for 1D and 2D array textures.
a295 20


get_timestamp
^^^^^^^^^^^^^

Query a timestamp in nanoseconds. The returned value should match
PIPE_QUERY_TIMESTAMP. This function returns immediately and doesn't
wait for rendering to complete (which cannot be achieved with queries).



get_driver_query_info
^^^^^^^^^^^^^^^^^^^^^

Return a driver-specific query. If the **info** parameter is NULL,
the number of available queries is returned.  Otherwise, the driver
query at the specified **index** is returned in **info**.
The function returns non-zero on success.
The driver-specific query is described with the pipe_driver_query_info
structure.
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d56 2
d107 1
a107 2
  resources.  If user-space buffers are supported, the driver must also still
  accept HW resource buffers.
d121 4
a124 6
  resources.  If user-space buffers are supported, the driver must also still
  accept HW resource buffers.
* ``PIPE_CAP_USER_CONSTANT_BUFFERS``: Whether user-space constant buffers
  are supported.  If not, the state tracker must put constants into HW
  resources/buffers.  If user-space constant buffers are supported, the
  driver must still accept HW constant buffers also.
d170 2
a171 2
  viewport/scissor combination.
* ``PIPE_CAP_ENDIANNESS``:: The endianness of the device.  Either
a172 29
* ``PIPE_CAP_MIXED_FRAMEBUFFER_SIZES``: Whether it is allowed to have
  different sizes for fb color/zs attachments. This controls whether
  ARB_framebuffer_object is provided.
* ``PIPE_CAP_TGSI_VS_LAYER``: Whether TGSI_SEMANTIC_LAYER is supported
  as a vertex shader output.
* ``PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES``: The maximum number of vertices
  output by a single invocation of a geometry shader.
* ``PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS``: The maximum number of
  vertex components output by a single invocation of a geometry shader.
  This is the product of the number of attribute components per vertex and
  the number of output vertices.
* ``PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS``: Max number of components
  in format that texture gather can operate on. 1 == RED, ALPHA etc,
  4 == All formats.
* ``PIPE_CAP_TEXTURE_GATHER_SM5``: Whether the texture gather
  hardware implements the SM5 features, component selection,
  shadow comparison, and run-time offsets.
* ``PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT``: Whether
  PIPE_TRANSFER_PERSISTENT and PIPE_TRANSFER_COHERENT are supported
  for buffers.
* ``PIPE_CAP_TEXTURE_QUERY_LOD``: Whether the ``LODQ`` instruction is
  supported.
* ``PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET``: The minimum offset that can be used
  in conjunction with a texture gather opcode.
* ``PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET``: The maximum offset that can be used
  in conjunction with a texture gather opcode.
* ``PIPE_CAP_SAMPLE_SHADING``: Whether there is support for per-sample
  shading. The context->set_min_samples function will be expected to be
  implemented.
d215 1
a215 1

d227 1
a227 1

d244 1
a244 1
* ``PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS``: The maximum number of texture
a247 2
* ``PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS``: The maximum number of texture
  sampler views. Must not be lower than PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS.
a283 2
* ``PIPE_COMPUTE_CAP_MAX_CLOCK_FREQUENCY``: Maximum frequency of the GPU
  clock in MHz. Value type: ``uint32_t``
a334 2
Note that drivers must always support read and write CPU access at any time
no matter which hint they got.
d336 5
a340 8
* ``PIPE_USAGE_DEFAULT``: Optimized for fast GPU access.
* ``PIPE_USAGE_IMMUTABLE``: Optimized for fast GPU access and the resource is
  not expected to be mapped or changed (even by the GPU) after the first upload.
* ``PIPE_USAGE_DYNAMIC``: Expect frequent write-only CPU access. What is
  uploaded is expected to be used at least several times by the GPU.
* ``PIPE_USAGE_STREAM``: Expect frequent write-only CPU access. What is
  uploaded is expected to be used only once by the GPU.
* ``PIPE_USAGE_STAGING``: Optimized for fast CPU access.
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d177 2
a178 4
* ``PIPE_CAP_TGSI_VS_LAYER_VIEWPORT``: Whether ``TGSI_SEMANTIC_LAYER`` and
  ``TGSI_SEMANTIC_VIEWPORT_INDEX`` are supported as vertex shader
  outputs. Note that the viewport will only be used if multiple viewports are
  exposed.
a202 31
* ``PIPE_CAP_TEXTURE_GATHER_OFFSETS``: Whether the ``TG4`` instruction can
  accept 4 offsets.
* ``PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION``: Whether
  TGSI_PROPERTY_VS_WINDOW_SPACE_POSITION is supported, which disables clipping
  and viewport transformation.
* ``PIPE_CAP_MAX_VERTEX_STREAMS``: The maximum number of vertex streams
  supported by the geometry shader. If stream-out is supported, this should be
  at least 1. If stream-out is not supported, this should be 0.
* ``PIPE_CAP_DRAW_INDIRECT``: Whether the driver supports taking draw arguments
  { count, instance_count, start, index_bias } from a PIPE_BUFFER resource.
  See pipe_draw_info.
* ``PIPE_CAP_TGSI_FS_FINE_DERIVATIVE``: Whether the fragment shader supports
  the FINE versions of DDX/DDY.
* ``PIPE_CAP_VENDOR_ID``: The vendor ID of the underlying hardware. If it's
  not available one should return 0xFFFFFFFF.
* ``PIPE_CAP_DEVICE_ID``: The device ID (PCI ID) of the underlying hardware.
  0xFFFFFFFF if not available.
* ``PIPE_CAP_ACCELERATED``: Whether the renderer is hardware accelerated.
* ``PIPE_CAP_VIDEO_MEMORY``: The amount of video memory in megabytes.
* ``PIPE_CAP_UMA``: If the device has a unified memory architecture or on-card
  memory and GART.
* ``PIPE_CAP_CONDITIONAL_RENDER_INVERTED``: Whether the driver supports inverted
  condition for conditional rendering.
* ``PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE``: The maximum supported vertex stride.
* ``PIPE_CAP_SAMPLER_VIEW_TARGET``: Whether the sampler view's target can be
  different than the underlying resource's, as permitted by
  ARB_texture_view. For example a 2d array texture may be reinterpreted as a
  cube (array) texture and vice-versa.
* ``PIPE_CAP_CLIP_HALFZ``: Whether the driver supports the
  pipe_rasterizer_state::clip_halfz being set to true. This is required
  for enabling ARB_clip_control.
d240 1
a240 3
* ``PIPE_SHADER_CAP_MAX_OUTPUTS``: The maximum number of output registers.
  This is valid for all shaders except the fragment shader.
* ``PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE``: The maximum size per constant buffer in bytes.
d259 1
a279 2
* ``PIPE_SHADER_CAP_DOUBLES``: Whether double precision floating-point
  operations are supported.
d292 2
a293 2
  This CAP is only relevant for drivers that specify PIPE_SHADER_IR_LLVM
  or PIPE_SHADER_IR_NATIVE for their preferred IR.
a317 4
* ``PIPE_COMPUTE_CAP_MAX_COMPUTE_UNITS``: Maximum number of compute units
  Value type: ``uint32_t``
* ``PIPE_COMPUTE_CAP_IMAGES_SUPPORTED``: Whether images are supported
  non-zero means yes, zero means no. Value type: ``uint32_t``
a361 3
* ``PIPE_BIND_COMMAND_ARGS_BUFFER``: A buffer that may be sourced by the
  GPU command processor. It can contain, for example, the arguments to
  indirect draw calls.
a449 2

For PIPE_TEXTURE_CUBE, the pipe_resource::array_size field should be 6.
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d177 4
a180 2
* ``PIPE_CAP_TGSI_VS_LAYER``: Whether TGSI_SEMANTIC_LAYER is supported
  as a vertex shader output.
d205 31
d273 3
a275 1
* ``PIPE_SHADER_CAP_MAX_CONSTS``: The maximum number of constants.
a293 1
* ``PIPE_SHADER_CAP_MAX_ADDRS``: The maximum number of address registers.
d314 2
d328 2
a329 2
  This CAP is only relevant for drivers that specify PIPE_SHADER_IR_LLVM for
  their preferred IR.
d354 4
d402 3
d493 2
@


