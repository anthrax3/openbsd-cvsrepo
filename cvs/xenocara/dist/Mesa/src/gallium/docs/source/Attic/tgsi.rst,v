head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2015.12.23.05.17.29;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.55;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.25;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.01;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.08;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@TGSI
====

TGSI, Tungsten Graphics Shader Infrastructure, is an intermediate language
for describing shaders. Since Gallium is inherently shaderful, shaders are
an important part of the API. TGSI is the only intermediate representation
used by all drivers.

Basics
------

All TGSI instructions, known as *opcodes*, operate on arbitrary-precision
floating-point four-component vectors. An opcode may have up to one
destination register, known as *dst*, and between zero and three source
registers, called *src0* through *src2*, or simply *src* if there is only
one.

Some instructions, like :opcode:`I2F`, permit re-interpretation of vector
components as integers. Other instructions permit using registers as
two-component vectors with double precision; see :ref:`doubleopcodes`.

When an instruction has a scalar result, the result is usually copied into
each of the components of *dst*. When this happens, the result is said to be
*replicated* to *dst*. :opcode:`RCP` is one such instruction.

Modifiers
^^^^^^^^^^^^^^^

TGSI supports modifiers on inputs (as well as saturate modifier on instructions).

For inputs which have a floating point type, both absolute value and negation
modifiers are supported (with absolute value being applied first).
TGSI_OPCODE_MOV is considered to have float input type for applying modifiers.

For inputs which have signed or unsigned type only the negate modifier is
supported.

Instruction Set
---------------

Core ISA
^^^^^^^^^^^^^^^^^^^^^^^^^

These opcodes are guaranteed to be available regardless of the driver being
used.

.. opcode:: ARL - Address Register Load

.. math::

  dst.x = \lfloor src.x\rfloor

  dst.y = \lfloor src.y\rfloor

  dst.z = \lfloor src.z\rfloor

  dst.w = \lfloor src.w\rfloor


.. opcode:: MOV - Move

.. math::

  dst.x = src.x

  dst.y = src.y

  dst.z = src.z

  dst.w = src.w


.. opcode:: LIT - Light Coefficients

.. math::

  dst.x &= 1 \\
  dst.y &= max(src.x, 0) \\
  dst.z &= (src.x > 0) ? max(src.y, 0)^{clamp(src.w, -128, 128))} : 0 \\
  dst.w &= 1


.. opcode:: RCP - Reciprocal

This instruction replicates its result.

.. math::

  dst = \frac{1}{src.x}


.. opcode:: RSQ - Reciprocal Square Root

This instruction replicates its result. The results are undefined for src <= 0.

.. math::

  dst = \frac{1}{\sqrt{src.x}}


.. opcode:: SQRT - Square Root

This instruction replicates its result. The results are undefined for src < 0.

.. math::

  dst = {\sqrt{src.x}}


.. opcode:: EXP - Approximate Exponential Base 2

.. math::

  dst.x &= 2^{\lfloor src.x\rfloor} \\
  dst.y &= src.x - \lfloor src.x\rfloor \\
  dst.z &= 2^{src.x} \\
  dst.w &= 1


.. opcode:: LOG - Approximate Logarithm Base 2

.. math::

  dst.x &= \lfloor\log_2{|src.x|}\rfloor \\
  dst.y &= \frac{|src.x|}{2^{\lfloor\log_2{|src.x|}\rfloor}} \\
  dst.z &= \log_2{|src.x|} \\
  dst.w &= 1


.. opcode:: MUL - Multiply

.. math::

  dst.x = src0.x \times src1.x

  dst.y = src0.y \times src1.y

  dst.z = src0.z \times src1.z

  dst.w = src0.w \times src1.w


.. opcode:: ADD - Add

.. math::

  dst.x = src0.x + src1.x

  dst.y = src0.y + src1.y

  dst.z = src0.z + src1.z

  dst.w = src0.w + src1.w


.. opcode:: DP3 - 3-component Dot Product

This instruction replicates its result.

.. math::

  dst = src0.x \times src1.x + src0.y \times src1.y + src0.z \times src1.z


.. opcode:: DP4 - 4-component Dot Product

This instruction replicates its result.

.. math::

  dst = src0.x \times src1.x + src0.y \times src1.y + src0.z \times src1.z + src0.w \times src1.w


.. opcode:: DST - Distance Vector

.. math::

  dst.x &= 1\\
  dst.y &= src0.y \times src1.y\\
  dst.z &= src0.z\\
  dst.w &= src1.w


.. opcode:: MIN - Minimum

.. math::

  dst.x = min(src0.x, src1.x)

  dst.y = min(src0.y, src1.y)

  dst.z = min(src0.z, src1.z)

  dst.w = min(src0.w, src1.w)


.. opcode:: MAX - Maximum

.. math::

  dst.x = max(src0.x, src1.x)

  dst.y = max(src0.y, src1.y)

  dst.z = max(src0.z, src1.z)

  dst.w = max(src0.w, src1.w)


.. opcode:: SLT - Set On Less Than

.. math::

  dst.x = (src0.x < src1.x) ? 1.0F : 0.0F

  dst.y = (src0.y < src1.y) ? 1.0F : 0.0F

  dst.z = (src0.z < src1.z) ? 1.0F : 0.0F

  dst.w = (src0.w < src1.w) ? 1.0F : 0.0F


.. opcode:: SGE - Set On Greater Equal Than

.. math::

  dst.x = (src0.x >= src1.x) ? 1.0F : 0.0F

  dst.y = (src0.y >= src1.y) ? 1.0F : 0.0F

  dst.z = (src0.z >= src1.z) ? 1.0F : 0.0F

  dst.w = (src0.w >= src1.w) ? 1.0F : 0.0F


.. opcode:: MAD - Multiply And Add

.. math::

  dst.x = src0.x \times src1.x + src2.x

  dst.y = src0.y \times src1.y + src2.y

  dst.z = src0.z \times src1.z + src2.z

  dst.w = src0.w \times src1.w + src2.w


.. opcode:: SUB - Subtract

.. math::

  dst.x = src0.x - src1.x

  dst.y = src0.y - src1.y

  dst.z = src0.z - src1.z

  dst.w = src0.w - src1.w


.. opcode:: LRP - Linear Interpolate

.. math::

  dst.x = src0.x \times src1.x + (1 - src0.x) \times src2.x

  dst.y = src0.y \times src1.y + (1 - src0.y) \times src2.y

  dst.z = src0.z \times src1.z + (1 - src0.z) \times src2.z

  dst.w = src0.w \times src1.w + (1 - src0.w) \times src2.w


.. opcode:: CND - Condition

.. math::

  dst.x = (src2.x > 0.5) ? src0.x : src1.x

  dst.y = (src2.y > 0.5) ? src0.y : src1.y

  dst.z = (src2.z > 0.5) ? src0.z : src1.z

  dst.w = (src2.w > 0.5) ? src0.w : src1.w


.. opcode:: DP2A - 2-component Dot Product And Add

.. math::

  dst.x = src0.x \times src1.x + src0.y \times src1.y + src2.x

  dst.y = src0.x \times src1.x + src0.y \times src1.y + src2.x

  dst.z = src0.x \times src1.x + src0.y \times src1.y + src2.x

  dst.w = src0.x \times src1.x + src0.y \times src1.y + src2.x


.. opcode:: FRC - Fraction

.. math::

  dst.x = src.x - \lfloor src.x\rfloor

  dst.y = src.y - \lfloor src.y\rfloor

  dst.z = src.z - \lfloor src.z\rfloor

  dst.w = src.w - \lfloor src.w\rfloor


.. opcode:: CLAMP - Clamp

.. math::

  dst.x = clamp(src0.x, src1.x, src2.x)

  dst.y = clamp(src0.y, src1.y, src2.y)

  dst.z = clamp(src0.z, src1.z, src2.z)

  dst.w = clamp(src0.w, src1.w, src2.w)


.. opcode:: FLR - Floor

This is identical to :opcode:`ARL`.

.. math::

  dst.x = \lfloor src.x\rfloor

  dst.y = \lfloor src.y\rfloor

  dst.z = \lfloor src.z\rfloor

  dst.w = \lfloor src.w\rfloor


.. opcode:: ROUND - Round

.. math::

  dst.x = round(src.x)

  dst.y = round(src.y)

  dst.z = round(src.z)

  dst.w = round(src.w)


.. opcode:: EX2 - Exponential Base 2

This instruction replicates its result.

.. math::

  dst = 2^{src.x}


.. opcode:: LG2 - Logarithm Base 2

This instruction replicates its result.

.. math::

  dst = \log_2{src.x}


.. opcode:: POW - Power

This instruction replicates its result.

.. math::

  dst = src0.x^{src1.x}

.. opcode:: XPD - Cross Product

.. math::

  dst.x = src0.y \times src1.z - src1.y \times src0.z

  dst.y = src0.z \times src1.x - src1.z \times src0.x

  dst.z = src0.x \times src1.y - src1.x \times src0.y

  dst.w = 1


.. opcode:: ABS - Absolute

.. math::

  dst.x = |src.x|

  dst.y = |src.y|

  dst.z = |src.z|

  dst.w = |src.w|


.. opcode:: RCC - Reciprocal Clamped

This instruction replicates its result.

XXX cleanup on aisle three

.. math::

  dst = (1 / src.x) > 0 ? clamp(1 / src.x, 5.42101e-020, 1.84467e+019) : clamp(1 / src.x, -1.84467e+019, -5.42101e-020)


.. opcode:: DPH - Homogeneous Dot Product

This instruction replicates its result.

.. math::

  dst = src0.x \times src1.x + src0.y \times src1.y + src0.z \times src1.z + src1.w


.. opcode:: COS - Cosine

This instruction replicates its result.

.. math::

  dst = \cos{src.x}


.. opcode:: DDX - Derivative Relative To X

.. math::

  dst.x = partialx(src.x)

  dst.y = partialx(src.y)

  dst.z = partialx(src.z)

  dst.w = partialx(src.w)


.. opcode:: DDY - Derivative Relative To Y

.. math::

  dst.x = partialy(src.x)

  dst.y = partialy(src.y)

  dst.z = partialy(src.z)

  dst.w = partialy(src.w)


.. opcode:: PK2H - Pack Two 16-bit Floats

  TBD


.. opcode:: PK2US - Pack Two Unsigned 16-bit Scalars

  TBD


.. opcode:: PK4B - Pack Four Signed 8-bit Scalars

  TBD


.. opcode:: PK4UB - Pack Four Unsigned 8-bit Scalars

  TBD


.. opcode:: RFL - Reflection Vector

.. math::

  dst.x = 2 \times (src0.x \times src1.x + src0.y \times src1.y + src0.z \times src1.z) / (src0.x \times src0.x + src0.y \times src0.y + src0.z \times src0.z) \times src0.x - src1.x

  dst.y = 2 \times (src0.x \times src1.x + src0.y \times src1.y + src0.z \times src1.z) / (src0.x \times src0.x + src0.y \times src0.y + src0.z \times src0.z) \times src0.y - src1.y

  dst.z = 2 \times (src0.x \times src1.x + src0.y \times src1.y + src0.z \times src1.z) / (src0.x \times src0.x + src0.y \times src0.y + src0.z \times src0.z) \times src0.z - src1.z

  dst.w = 1

.. note::

   Considered for removal.


.. opcode:: SEQ - Set On Equal

.. math::

  dst.x = (src0.x == src1.x) ? 1.0F : 0.0F

  dst.y = (src0.y == src1.y) ? 1.0F : 0.0F

  dst.z = (src0.z == src1.z) ? 1.0F : 0.0F

  dst.w = (src0.w == src1.w) ? 1.0F : 0.0F


.. opcode:: SFL - Set On False

This instruction replicates its result.

.. math::

  dst = 0.0F

.. note::

   Considered for removal.


.. opcode:: SGT - Set On Greater Than

.. math::

  dst.x = (src0.x > src1.x) ? 1.0F : 0.0F

  dst.y = (src0.y > src1.y) ? 1.0F : 0.0F

  dst.z = (src0.z > src1.z) ? 1.0F : 0.0F

  dst.w = (src0.w > src1.w) ? 1.0F : 0.0F


.. opcode:: SIN - Sine

This instruction replicates its result.

.. math::

  dst = \sin{src.x}


.. opcode:: SLE - Set On Less Equal Than

.. math::

  dst.x = (src0.x <= src1.x) ? 1.0F : 0.0F

  dst.y = (src0.y <= src1.y) ? 1.0F : 0.0F

  dst.z = (src0.z <= src1.z) ? 1.0F : 0.0F

  dst.w = (src0.w <= src1.w) ? 1.0F : 0.0F


.. opcode:: SNE - Set On Not Equal

.. math::

  dst.x = (src0.x != src1.x) ? 1.0F : 0.0F

  dst.y = (src0.y != src1.y) ? 1.0F : 0.0F

  dst.z = (src0.z != src1.z) ? 1.0F : 0.0F

  dst.w = (src0.w != src1.w) ? 1.0F : 0.0F


.. opcode:: STR - Set On True

This instruction replicates its result.

.. math::

  dst = 1.0F


.. opcode:: TEX - Texture Lookup

  for array textures src0.y contains the slice for 1D,
  and src0.z contain the slice for 2D.

  for shadow textures with no arrays, src0.z contains
  the reference value.

  for shadow textures with arrays, src0.z contains
  the reference value for 1D arrays, and src0.w contains
  the reference value for 2D arrays.

  There is no way to pass a bias in the .w value for
  shadow arrays, and GLSL doesn't allow this.
  GLSL does allow cube shadows maps to take a bias value,
  and we have to determine how this will look in TGSI.

.. math::

  coord = src0

  bias = 0.0

  dst = texture\_sample(unit, coord, bias)

.. opcode:: TXD - Texture Lookup with Derivatives

.. math::

  coord = src0

  ddx = src1

  ddy = src2

  bias = 0.0

  dst = texture\_sample\_deriv(unit, coord, bias, ddx, ddy)


.. opcode:: TXP - Projective Texture Lookup

.. math::

  coord.x = src0.x / src.w

  coord.y = src0.y / src.w

  coord.z = src0.z / src.w

  coord.w = src0.w

  bias = 0.0

  dst = texture\_sample(unit, coord, bias)


.. opcode:: UP2H - Unpack Two 16-Bit Floats

  TBD

.. note::

   Considered for removal.

.. opcode:: UP2US - Unpack Two Unsigned 16-Bit Scalars

  TBD

.. note::

   Considered for removal.

.. opcode:: UP4B - Unpack Four Signed 8-Bit Values

  TBD

.. note::

   Considered for removal.

.. opcode:: UP4UB - Unpack Four Unsigned 8-Bit Scalars

  TBD

.. note::

   Considered for removal.

.. opcode:: X2D - 2D Coordinate Transformation

.. math::

  dst.x = src0.x + src1.x \times src2.x + src1.y \times src2.y

  dst.y = src0.y + src1.x \times src2.z + src1.y \times src2.w

  dst.z = src0.x + src1.x \times src2.x + src1.y \times src2.y

  dst.w = src0.y + src1.x \times src2.z + src1.y \times src2.w

.. note::

   Considered for removal.


.. opcode:: ARA - Address Register Add

  TBD

.. note::

   Considered for removal.

.. opcode:: ARR - Address Register Load With Round

.. math::

  dst.x = round(src.x)

  dst.y = round(src.y)

  dst.z = round(src.z)

  dst.w = round(src.w)


.. opcode:: SSG - Set Sign

.. math::

  dst.x = (src.x > 0) ? 1 : (src.x < 0) ? -1 : 0

  dst.y = (src.y > 0) ? 1 : (src.y < 0) ? -1 : 0

  dst.z = (src.z > 0) ? 1 : (src.z < 0) ? -1 : 0

  dst.w = (src.w > 0) ? 1 : (src.w < 0) ? -1 : 0


.. opcode:: CMP - Compare

.. math::

  dst.x = (src0.x < 0) ? src1.x : src2.x

  dst.y = (src0.y < 0) ? src1.y : src2.y

  dst.z = (src0.z < 0) ? src1.z : src2.z

  dst.w = (src0.w < 0) ? src1.w : src2.w


.. opcode:: KILL_IF - Conditional Discard

  Conditional discard.  Allowed in fragment shaders only.

.. math::

  if (src.x < 0 || src.y < 0 || src.z < 0 || src.w < 0)
    discard
  endif


.. opcode:: KILL - Discard

  Unconditional discard.  Allowed in fragment shaders only.


.. opcode:: SCS - Sine Cosine

.. math::

  dst.x = \cos{src.x}

  dst.y = \sin{src.x}

  dst.z = 0

  dst.w = 1


.. opcode:: TXB - Texture Lookup With Bias

.. math::

  coord.x = src.x

  coord.y = src.y

  coord.z = src.z

  coord.w = 1.0

  bias = src.z

  dst = texture\_sample(unit, coord, bias)


.. opcode:: NRM - 3-component Vector Normalise

.. math::

  dst.x = src.x / (src.x \times src.x + src.y \times src.y + src.z \times src.z)

  dst.y = src.y / (src.x \times src.x + src.y \times src.y + src.z \times src.z)

  dst.z = src.z / (src.x \times src.x + src.y \times src.y + src.z \times src.z)

  dst.w = 1


.. opcode:: DIV - Divide

.. math::

  dst.x = \frac{src0.x}{src1.x}

  dst.y = \frac{src0.y}{src1.y}

  dst.z = \frac{src0.z}{src1.z}

  dst.w = \frac{src0.w}{src1.w}


.. opcode:: DP2 - 2-component Dot Product

This instruction replicates its result.

.. math::

  dst = src0.x \times src1.x + src0.y \times src1.y


.. opcode:: TXL - Texture Lookup With explicit LOD

.. math::

  coord.x = src0.x

  coord.y = src0.y

  coord.z = src0.z

  coord.w = 1.0

  lod = src0.w

  dst = texture\_sample(unit, coord, lod)


.. opcode:: PUSHA - Push Address Register On Stack

  push(src.x)
  push(src.y)
  push(src.z)
  push(src.w)

.. note::

   Considered for cleanup.

.. note::

   Considered for removal.

.. opcode:: POPA - Pop Address Register From Stack

  dst.w = pop()
  dst.z = pop()
  dst.y = pop()
  dst.x = pop()

.. note::

   Considered for cleanup.

.. note::

   Considered for removal.


.. opcode:: BRA - Branch

  pc = target

.. note::

   Considered for removal.


.. opcode:: CALLNZ - Subroutine Call If Not Zero

   TBD

.. note::

   Considered for cleanup.

.. note::

   Considered for removal.


Compute ISA
^^^^^^^^^^^^^^^^^^^^^^^^

These opcodes are primarily provided for special-use computational shaders.
Support for these opcodes indicated by a special pipe capability bit (TBD).

XXX doesn't look like most of the opcodes really belong here.

.. opcode:: CEIL - Ceiling

.. math::

  dst.x = \lceil src.x\rceil

  dst.y = \lceil src.y\rceil

  dst.z = \lceil src.z\rceil

  dst.w = \lceil src.w\rceil


.. opcode:: TRUNC - Truncate

.. math::

  dst.x = trunc(src.x)

  dst.y = trunc(src.y)

  dst.z = trunc(src.z)

  dst.w = trunc(src.w)


.. opcode:: MOD - Modulus

.. math::

  dst.x = src0.x \bmod src1.x

  dst.y = src0.y \bmod src1.y

  dst.z = src0.z \bmod src1.z

  dst.w = src0.w \bmod src1.w


.. opcode:: UARL - Integer Address Register Load

  Moves the contents of the source register, assumed to be an integer, into the
  destination register, which is assumed to be an address (ADDR) register.


.. opcode:: SAD - Sum Of Absolute Differences

.. math::

  dst.x = |src0.x - src1.x| + src2.x

  dst.y = |src0.y - src1.y| + src2.y

  dst.z = |src0.z - src1.z| + src2.z

  dst.w = |src0.w - src1.w| + src2.w


.. opcode:: TXF - Texel Fetch

  As per NV_gpu_shader4, extract a single texel from a specified texture
  image. The source sampler may not be a CUBE or SHADOW.  src 0 is a
  four-component signed integer vector used to identify the single texel
  accessed. 3 components + level.  src 1 is a 3 component constant signed
  integer vector, with each component only have a range of -8..+8 (hw only
  seems to deal with this range, interface allows for up to unsigned int).
  TXF(uint_vec coord, int_vec offset).


.. opcode:: TXQ - Texture Size Query

  As per NV_gpu_program4, retrieve the dimensions of the texture depending on
  the target. For 1D (width), 2D/RECT/CUBE (width, height), 3D (width, height,
  depth), 1D array (width, layers), 2D array (width, height, layers)

.. math::

  lod = src0.x

  dst.x = texture\_width(unit, lod)

  dst.y = texture\_height(unit, lod)

  dst.z = texture\_depth(unit, lod)

.. opcode:: TG4 - Texture Gather

  As per ARB_texture_gather, gathers the four texels to be used in a bi-linear
  filtering operation and packs them into a single register.  Only works with
  2D, 2D array, cubemaps, and cubemaps arrays.  For 2D textures, only the
  addressing modes of the sampler and the top level of any mip pyramid are
  used. Set W to zero.  It behaves like the TEX instruction, but a filtered
  sample is not generated. The four samples that contribute to filtering are
  placed into xyzw in clockwise order, starting with the (u,v) texture
  coordinate delta at the following locations (-, +), (+, +), (+, -), (-, -),
  where the magnitude of the deltas are half a texel.

  PIPE_CAP_TEXTURE_SM5 enhances this instruction to support shadow per-sample
  depth compares, single component selection, and a non-constant offset. It
  doesn't allow support for the GL independent offset to get i0,j0. This would
  require another CAP is hw can do it natively. For now we lower that before
  TGSI.

.. math::

   coord = src0

   component = src1

   dst = texture\_gather4 (unit, coord, component)

(with SM5 - cube array shadow)

.. math::

   coord = src0

   compare = src1

   dst = texture\_gather (uint, coord, compare)

.. opcode:: LODQ - level of detail query

   Compute the LOD information that the texture pipe would use to access the
   texture. The Y component contains the computed LOD lambda_prime. The X
   component contains the LOD that will be accessed, based on min/max lod's
   and mipmap filters.

.. math::

   coord = src0

   dst.xy = lodq(uint, coord);

Integer ISA
^^^^^^^^^^^^^^^^^^^^^^^^
These opcodes are used for integer operations.
Support for these opcodes indicated by PIPE_SHADER_CAP_INTEGERS (all of them?)


.. opcode:: I2F - Signed Integer To Float

   Rounding is unspecified (round to nearest even suggested).

.. math::

  dst.x = (float) src.x

  dst.y = (float) src.y

  dst.z = (float) src.z

  dst.w = (float) src.w


.. opcode:: U2F - Unsigned Integer To Float

   Rounding is unspecified (round to nearest even suggested).

.. math::

  dst.x = (float) src.x

  dst.y = (float) src.y

  dst.z = (float) src.z

  dst.w = (float) src.w


.. opcode:: F2I - Float to Signed Integer

   Rounding is towards zero (truncate).
   Values outside signed range (including NaNs) produce undefined results.

.. math::

  dst.x = (int) src.x

  dst.y = (int) src.y

  dst.z = (int) src.z

  dst.w = (int) src.w


.. opcode:: F2U - Float to Unsigned Integer

   Rounding is towards zero (truncate).
   Values outside unsigned range (including NaNs) produce undefined results.

.. math::

  dst.x = (unsigned) src.x

  dst.y = (unsigned) src.y

  dst.z = (unsigned) src.z

  dst.w = (unsigned) src.w


.. opcode:: UADD - Integer Add

   This instruction works the same for signed and unsigned integers.
   The low 32bit of the result is returned.

.. math::

  dst.x = src0.x + src1.x

  dst.y = src0.y + src1.y

  dst.z = src0.z + src1.z

  dst.w = src0.w + src1.w


.. opcode:: UMAD - Integer Multiply And Add

   This instruction works the same for signed and unsigned integers.
   The multiplication returns the low 32bit (as does the result itself).

.. math::

  dst.x = src0.x \times src1.x + src2.x

  dst.y = src0.y \times src1.y + src2.y

  dst.z = src0.z \times src1.z + src2.z

  dst.w = src0.w \times src1.w + src2.w


.. opcode:: UMUL - Integer Multiply

   This instruction works the same for signed and unsigned integers.
   The low 32bit of the result is returned.

.. math::

  dst.x = src0.x \times src1.x

  dst.y = src0.y \times src1.y

  dst.z = src0.z \times src1.z

  dst.w = src0.w \times src1.w


.. opcode:: IMUL_HI - Signed Integer Multiply High Bits

   The high 32bits of the multiplication of 2 signed integers are returned.

.. math::

  dst.x = (src0.x \times src1.x) >> 32

  dst.y = (src0.y \times src1.y) >> 32

  dst.z = (src0.z \times src1.z) >> 32

  dst.w = (src0.w \times src1.w) >> 32


.. opcode:: UMUL_HI - Unsigned Integer Multiply High Bits

   The high 32bits of the multiplication of 2 unsigned integers are returned.

.. math::

  dst.x = (src0.x \times src1.x) >> 32

  dst.y = (src0.y \times src1.y) >> 32

  dst.z = (src0.z \times src1.z) >> 32

  dst.w = (src0.w \times src1.w) >> 32


.. opcode:: IDIV - Signed Integer Division

   TBD: behavior for division by zero.

.. math::

  dst.x = src0.x \ src1.x

  dst.y = src0.y \ src1.y

  dst.z = src0.z \ src1.z

  dst.w = src0.w \ src1.w


.. opcode:: UDIV - Unsigned Integer Division

   For division by zero, 0xffffffff is returned.

.. math::

  dst.x = src0.x \ src1.x

  dst.y = src0.y \ src1.y

  dst.z = src0.z \ src1.z

  dst.w = src0.w \ src1.w


.. opcode:: UMOD - Unsigned Integer Remainder

   If second arg is zero, 0xffffffff is returned.

.. math::

  dst.x = src0.x \ src1.x

  dst.y = src0.y \ src1.y

  dst.z = src0.z \ src1.z

  dst.w = src0.w \ src1.w


.. opcode:: NOT - Bitwise Not

.. math::

  dst.x = \sim src.x

  dst.y = \sim src.y

  dst.z = \sim src.z

  dst.w = \sim src.w


.. opcode:: AND - Bitwise And

.. math::

  dst.x = src0.x \& src1.x

  dst.y = src0.y \& src1.y

  dst.z = src0.z \& src1.z

  dst.w = src0.w \& src1.w


.. opcode:: OR - Bitwise Or

.. math::

  dst.x = src0.x | src1.x

  dst.y = src0.y | src1.y

  dst.z = src0.z | src1.z

  dst.w = src0.w | src1.w


.. opcode:: XOR - Bitwise Xor

.. math::

  dst.x = src0.x \oplus src1.x

  dst.y = src0.y \oplus src1.y

  dst.z = src0.z \oplus src1.z

  dst.w = src0.w \oplus src1.w


.. opcode:: IMAX - Maximum of Signed Integers

.. math::

  dst.x = max(src0.x, src1.x)

  dst.y = max(src0.y, src1.y)

  dst.z = max(src0.z, src1.z)

  dst.w = max(src0.w, src1.w)


.. opcode:: UMAX - Maximum of Unsigned Integers

.. math::

  dst.x = max(src0.x, src1.x)

  dst.y = max(src0.y, src1.y)

  dst.z = max(src0.z, src1.z)

  dst.w = max(src0.w, src1.w)


.. opcode:: IMIN - Minimum of Signed Integers

.. math::

  dst.x = min(src0.x, src1.x)

  dst.y = min(src0.y, src1.y)

  dst.z = min(src0.z, src1.z)

  dst.w = min(src0.w, src1.w)


.. opcode:: UMIN - Minimum of Unsigned Integers

.. math::

  dst.x = min(src0.x, src1.x)

  dst.y = min(src0.y, src1.y)

  dst.z = min(src0.z, src1.z)

  dst.w = min(src0.w, src1.w)


.. opcode:: SHL - Shift Left

   The shift count is masked with 0x1f before the shift is applied.

.. math::

  dst.x = src0.x << (0x1f \& src1.x)

  dst.y = src0.y << (0x1f \& src1.y)

  dst.z = src0.z << (0x1f \& src1.z)

  dst.w = src0.w << (0x1f \& src1.w)


.. opcode:: ISHR - Arithmetic Shift Right (of Signed Integer)

   The shift count is masked with 0x1f before the shift is applied.

.. math::

  dst.x = src0.x >> (0x1f \& src1.x)

  dst.y = src0.y >> (0x1f \& src1.y)

  dst.z = src0.z >> (0x1f \& src1.z)

  dst.w = src0.w >> (0x1f \& src1.w)


.. opcode:: USHR - Logical Shift Right

   The shift count is masked with 0x1f before the shift is applied.

.. math::

  dst.x = src0.x >> (unsigned) (0x1f \& src1.x)

  dst.y = src0.y >> (unsigned) (0x1f \& src1.y)

  dst.z = src0.z >> (unsigned) (0x1f \& src1.z)

  dst.w = src0.w >> (unsigned) (0x1f \& src1.w)


.. opcode:: UCMP - Integer Conditional Move

.. math::

  dst.x = src0.x ? src1.x : src2.x

  dst.y = src0.y ? src1.y : src2.y

  dst.z = src0.z ? src1.z : src2.z

  dst.w = src0.w ? src1.w : src2.w



.. opcode:: ISSG - Integer Set Sign

.. math::

  dst.x = (src0.x < 0) ? -1 : (src0.x > 0) ? 1 : 0

  dst.y = (src0.y < 0) ? -1 : (src0.y > 0) ? 1 : 0

  dst.z = (src0.z < 0) ? -1 : (src0.z > 0) ? 1 : 0

  dst.w = (src0.w < 0) ? -1 : (src0.w > 0) ? 1 : 0



.. opcode:: FSLT - Float Set On Less Than (ordered)

   Same comparison as SLT but returns integer instead of 1.0/0.0 float

.. math::

  dst.x = (src0.x < src1.x) ? \sim 0 : 0

  dst.y = (src0.y < src1.y) ? \sim 0 : 0

  dst.z = (src0.z < src1.z) ? \sim 0 : 0

  dst.w = (src0.w < src1.w) ? \sim 0 : 0


.. opcode:: ISLT - Signed Integer Set On Less Than

.. math::

  dst.x = (src0.x < src1.x) ? \sim 0 : 0

  dst.y = (src0.y < src1.y) ? \sim 0 : 0

  dst.z = (src0.z < src1.z) ? \sim 0 : 0

  dst.w = (src0.w < src1.w) ? \sim 0 : 0


.. opcode:: USLT - Unsigned Integer Set On Less Than

.. math::

  dst.x = (src0.x < src1.x) ? \sim 0 : 0

  dst.y = (src0.y < src1.y) ? \sim 0 : 0

  dst.z = (src0.z < src1.z) ? \sim 0 : 0

  dst.w = (src0.w < src1.w) ? \sim 0 : 0


.. opcode:: FSGE - Float Set On Greater Equal Than (ordered)

   Same comparison as SGE but returns integer instead of 1.0/0.0 float

.. math::

  dst.x = (src0.x >= src1.x) ? \sim 0 : 0

  dst.y = (src0.y >= src1.y) ? \sim 0 : 0

  dst.z = (src0.z >= src1.z) ? \sim 0 : 0

  dst.w = (src0.w >= src1.w) ? \sim 0 : 0


.. opcode:: ISGE - Signed Integer Set On Greater Equal Than

.. math::

  dst.x = (src0.x >= src1.x) ? \sim 0 : 0

  dst.y = (src0.y >= src1.y) ? \sim 0 : 0

  dst.z = (src0.z >= src1.z) ? \sim 0 : 0

  dst.w = (src0.w >= src1.w) ? \sim 0 : 0


.. opcode:: USGE - Unsigned Integer Set On Greater Equal Than

.. math::

  dst.x = (src0.x >= src1.x) ? \sim 0 : 0

  dst.y = (src0.y >= src1.y) ? \sim 0 : 0

  dst.z = (src0.z >= src1.z) ? \sim 0 : 0

  dst.w = (src0.w >= src1.w) ? \sim 0 : 0


.. opcode:: FSEQ - Float Set On Equal (ordered)

   Same comparison as SEQ but returns integer instead of 1.0/0.0 float

.. math::

  dst.x = (src0.x == src1.x) ? \sim 0 : 0

  dst.y = (src0.y == src1.y) ? \sim 0 : 0

  dst.z = (src0.z == src1.z) ? \sim 0 : 0

  dst.w = (src0.w == src1.w) ? \sim 0 : 0


.. opcode:: USEQ - Integer Set On Equal

.. math::

  dst.x = (src0.x == src1.x) ? \sim 0 : 0

  dst.y = (src0.y == src1.y) ? \sim 0 : 0

  dst.z = (src0.z == src1.z) ? \sim 0 : 0

  dst.w = (src0.w == src1.w) ? \sim 0 : 0


.. opcode:: FSNE - Float Set On Not Equal (unordered)

   Same comparison as SNE but returns integer instead of 1.0/0.0 float

.. math::

  dst.x = (src0.x != src1.x) ? \sim 0 : 0

  dst.y = (src0.y != src1.y) ? \sim 0 : 0

  dst.z = (src0.z != src1.z) ? \sim 0 : 0

  dst.w = (src0.w != src1.w) ? \sim 0 : 0


.. opcode:: USNE - Integer Set On Not Equal

.. math::

  dst.x = (src0.x != src1.x) ? \sim 0 : 0

  dst.y = (src0.y != src1.y) ? \sim 0 : 0

  dst.z = (src0.z != src1.z) ? \sim 0 : 0

  dst.w = (src0.w != src1.w) ? \sim 0 : 0


.. opcode:: INEG - Integer Negate

  Two's complement.

.. math::

  dst.x = -src.x

  dst.y = -src.y

  dst.z = -src.z

  dst.w = -src.w


.. opcode:: IABS - Integer Absolute Value

.. math::

  dst.x = |src.x|

  dst.y = |src.y|

  dst.z = |src.z|

  dst.w = |src.w|

Bitwise ISA
^^^^^^^^^^^
These opcodes are used for bit-level manipulation of integers.

.. opcode:: IBFE - Signed Bitfield Extract

  See SM5 instruction of the same name. Extracts a set of bits from the input,
  and sign-extends them if the high bit of the extracted window is set.

  Pseudocode::

    def ibfe(value, offset, bits):
      offset = offset & 0x1f
      bits = bits & 0x1f
      if bits == 0: return 0
      # Note: >> sign-extends
      if width + offset < 32:
        return (value << (32 - offset - bits)) >> (32 - bits)
      else:
        return value >> offset

.. opcode:: UBFE - Unsigned Bitfield Extract

  See SM5 instruction of the same name. Extracts a set of bits from the input,
  without any sign-extension.

  Pseudocode::

    def ubfe(value, offset, bits):
      offset = offset & 0x1f
      bits = bits & 0x1f
      if bits == 0: return 0
      # Note: >> does not sign-extend
      if width + offset < 32:
        return (value << (32 - offset - bits)) >> (32 - bits)
      else:
        return value >> offset

.. opcode:: BFI - Bitfield Insert

  See SM5 instruction of the same name. Replaces a bit region of 'base' with
  the low bits of 'insert'.

  Pseudocode::

    def bfi(base, insert, offset, bits):
      offset = offset & 0x1f
      bits = bits & 0x1f
      mask = ((1 << bits) - 1) << offset
      return ((insert << offset) & mask) | (base & ~mask)

.. opcode:: BREV - Bitfield Reverse

  See SM5 instruction BFREV. Reverses the bits of the argument.

.. opcode:: POPC - Population Count

  See SM5 instruction COUNTBITS. Counts the number of set bits in the argument.

.. opcode:: LSB - Index of lowest set bit

  See SM5 instruction FIRSTBIT_LO. Computes the 0-based index of the first set
  bit of the argument. Returns -1 if none are set.

.. opcode:: IMSB - Index of highest non-sign bit

  See SM5 instruction FIRSTBIT_SHI. Computes the 0-based index of the highest
  non-sign bit of the argument (i.e. highest 0 bit for negative numbers,
  highest 1 bit for positive numbers). Returns -1 if all bits are the same
  (i.e. for inputs 0 and -1).

.. opcode:: UMSB - Index of highest set bit

  See SM5 instruction FIRSTBIT_HI. Computes the 0-based index of the highest
  set bit of the argument. Returns -1 if none are set.

Geometry ISA
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These opcodes are only supported in geometry shaders; they have no meaning
in any other type of shader.

.. opcode:: EMIT - Emit

  Generate a new vertex for the current primitive using the values in the
  output registers.


.. opcode:: ENDPRIM - End Primitive

  Complete the current primitive (consisting of the emitted vertices),
  and start a new one.


GLSL ISA
^^^^^^^^^^

These opcodes are part of :term:`GLSL`'s opcode set. Support for these
opcodes is determined by a special capability bit, ``GLSL``.
Some require glsl version 1.30 (UIF/BREAKC/SWITCH/CASE/DEFAULT/ENDSWITCH).

.. opcode:: CAL - Subroutine Call

  push(pc)
  pc = target


.. opcode:: RET - Subroutine Call Return

  pc = pop()


.. opcode:: CONT - Continue

  Unconditionally moves the point of execution to the instruction after the
  last bgnloop. The instruction must appear within a bgnloop/endloop.

.. note::

   Support for CONT is determined by a special capability bit,
   ``TGSI_CONT_SUPPORTED``. See :ref:`Screen` for more information.


.. opcode:: BGNLOOP - Begin a Loop

  Start a loop. Must have a matching endloop.


.. opcode:: BGNSUB - Begin Subroutine

  Starts definition of a subroutine. Must have a matching endsub.


.. opcode:: ENDLOOP - End a Loop

  End a loop started with bgnloop.


.. opcode:: ENDSUB - End Subroutine

  Ends definition of a subroutine.


.. opcode:: NOP - No Operation

  Do nothing.


.. opcode:: BRK - Break

  Unconditionally moves the point of execution to the instruction after the
  next endloop or endswitch. The instruction must appear within a loop/endloop
  or switch/endswitch.


.. opcode:: BREAKC - Break Conditional

  Conditionally moves the point of execution to the instruction after the
  next endloop or endswitch. The instruction must appear within a loop/endloop
  or switch/endswitch.
  Condition evaluates to true if src0.x != 0 where src0.x is interpreted
  as an integer register.

.. note::

   Considered for removal as it's quite inconsistent wrt other opcodes
   (could emulate with UIF/BRK/ENDIF). 


.. opcode:: IF - Float If

  Start an IF ... ELSE .. ENDIF block.  Condition evaluates to true if

    src0.x != 0.0

  where src0.x is interpreted as a floating point register.


.. opcode:: UIF - Bitwise If

  Start an UIF ... ELSE .. ENDIF block. Condition evaluates to true if

    src0.x != 0

  where src0.x is interpreted as an integer register.


.. opcode:: ELSE - Else

  Starts an else block, after an IF or UIF statement.


.. opcode:: ENDIF - End If

  Ends an IF or UIF block.


.. opcode:: SWITCH - Switch

   Starts a C-style switch expression. The switch consists of one or multiple
   CASE statements, and at most one DEFAULT statement. Execution of a statement
   ends when a BRK is hit, but just like in C falling through to other cases
   without a break is allowed. Similarly, DEFAULT label is allowed anywhere not
   just as last statement, and fallthrough is allowed into/from it.
   CASE src arguments are evaluated at bit level against the SWITCH src argument.

   Example::

     SWITCH src[0].x
     CASE src[0].x
     (some instructions here)
     (optional BRK here)
     DEFAULT
     (some instructions here)
     (optional BRK here)
     CASE src[0].x
     (some instructions here)
     (optional BRK here)
     ENDSWITCH


.. opcode:: CASE - Switch case

   This represents a switch case label. The src arg must be an integer immediate.


.. opcode:: DEFAULT - Switch default

   This represents the default case in the switch, which is taken if no other
   case matches.


.. opcode:: ENDSWITCH - End of switch

   Ends a switch expression.


.. opcode:: NRM4 - 4-component Vector Normalise

This instruction replicates its result.

.. math::

  dst = \frac{src.x}{src.x \times src.x + src.y \times src.y + src.z \times src.z + src.w \times src.w}


.. _doubleopcodes:

Double ISA
^^^^^^^^^^^^^^^

The double-precision opcodes reinterpret four-component vectors into
two-component vectors with doubled precision in each component.

Support for these opcodes is XXX undecided. :T

.. opcode:: DADD - Add

.. math::

  dst.xy = src0.xy + src1.xy

  dst.zw = src0.zw + src1.zw


.. opcode:: DDIV - Divide

.. math::

  dst.xy = src0.xy / src1.xy

  dst.zw = src0.zw / src1.zw

.. opcode:: DSEQ - Set on Equal

.. math::

  dst.xy = src0.xy == src1.xy ? 1.0F : 0.0F

  dst.zw = src0.zw == src1.zw ? 1.0F : 0.0F

.. opcode:: DSLT - Set on Less than

.. math::

  dst.xy = src0.xy < src1.xy ? 1.0F : 0.0F

  dst.zw = src0.zw < src1.zw ? 1.0F : 0.0F

.. opcode:: DFRAC - Fraction

.. math::

  dst.xy = src.xy - \lfloor src.xy\rfloor

  dst.zw = src.zw - \lfloor src.zw\rfloor


.. opcode:: DFRACEXP - Convert Number to Fractional and Integral Components

Like the ``frexp()`` routine in many math libraries, this opcode stores the
exponent of its source to ``dst0``, and the significand to ``dst1``, such that
:math:`dst1 \times 2^{dst0} = src` .

.. math::

  dst0.xy = exp(src.xy)

  dst1.xy = frac(src.xy)

  dst0.zw = exp(src.zw)

  dst1.zw = frac(src.zw)

.. opcode:: DLDEXP - Multiply Number by Integral Power of 2

This opcode is the inverse of :opcode:`DFRACEXP`.

.. math::

  dst.xy = src0.xy \times 2^{src1.xy}

  dst.zw = src0.zw \times 2^{src1.zw}

.. opcode:: DMIN - Minimum

.. math::

  dst.xy = min(src0.xy, src1.xy)

  dst.zw = min(src0.zw, src1.zw)

.. opcode:: DMAX - Maximum

.. math::

  dst.xy = max(src0.xy, src1.xy)

  dst.zw = max(src0.zw, src1.zw)

.. opcode:: DMUL - Multiply

.. math::

  dst.xy = src0.xy \times src1.xy

  dst.zw = src0.zw \times src1.zw


.. opcode:: DMAD - Multiply And Add

.. math::

  dst.xy = src0.xy \times src1.xy + src2.xy

  dst.zw = src0.zw \times src1.zw + src2.zw


.. opcode:: DRCP - Reciprocal

.. math::

   dst.xy = \frac{1}{src.xy}

   dst.zw = \frac{1}{src.zw}

.. opcode:: DSQRT - Square Root

.. math::

   dst.xy = \sqrt{src.xy}

   dst.zw = \sqrt{src.zw}


.. _samplingopcodes:

Resource Sampling Opcodes
^^^^^^^^^^^^^^^^^^^^^^^^^

Those opcodes follow very closely semantics of the respective Direct3D
instructions. If in doubt double check Direct3D documentation.
Note that the swizzle on SVIEW (src1) determines texel swizzling
after lookup.

.. opcode:: SAMPLE

  Using provided address, sample data from the specified texture using the
  filtering mode identified by the gven sampler. The source data may come from
  any resource type other than buffers.

  Syntax: ``SAMPLE dst, address, sampler_view, sampler``

  Example: ``SAMPLE TEMP[0], TEMP[1], SVIEW[0], SAMP[0]``

.. opcode:: SAMPLE_I

  Simplified alternative to the SAMPLE instruction.  Using the provided
  integer address, SAMPLE_I fetches data from the specified sampler view
  without any filtering.  The source data may come from any resource type
  other than CUBE.

  Syntax: ``SAMPLE_I dst, address, sampler_view``

  Example: ``SAMPLE_I TEMP[0], TEMP[1], SVIEW[0]``

  The 'address' is specified as unsigned integers. If the 'address' is out of
  range [0...(# texels - 1)] the result of the fetch is always 0 in all
  components.  As such the instruction doesn't honor address wrap modes, in
  cases where that behavior is desirable 'SAMPLE' instruction should be used.
  address.w always provides an unsigned integer mipmap level. If the value is
  out of the range then the instruction always returns 0 in all components.
  address.yz are ignored for buffers and 1d textures.  address.z is ignored
  for 1d texture arrays and 2d textures.

  For 1D texture arrays address.y provides the array index (also as unsigned
  integer). If the value is out of the range of available array indices
  [0... (array size - 1)] then the opcode always returns 0 in all components.
  For 2D texture arrays address.z provides the array index, otherwise it
  exhibits the same behavior as in the case for 1D texture arrays.  The exact
  semantics of the source address are presented in the table below:

  +---------------------------+----+-----+-----+---------+
  | resource type             | X  |  Y  |  Z  |    W    |
  +===========================+====+=====+=====+=========+
  | ``PIPE_BUFFER``           | x  |     |     | ignored |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_1D``       | x  |     |     |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_2D``       | x  |  y  |     |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_3D``       | x  |  y  |  z  |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_RECT``     | x  |  y  |     |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_CUBE``     | not allowed as source    |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_1D_ARRAY`` | x  | idx |     |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_2D_ARRAY`` | x  |  y  | idx |   mpl   |
  +---------------------------+----+-----+-----+---------+

  Where 'mpl' is a mipmap level and 'idx' is the array index.

.. opcode:: SAMPLE_I_MS

  Just like SAMPLE_I but allows fetch data from multi-sampled surfaces.

  Syntax: ``SAMPLE_I_MS dst, address, sampler_view, sample``

.. opcode:: SAMPLE_B

  Just like the SAMPLE instruction with the exception that an additional bias
  is applied to the level of detail computed as part of the instruction
  execution.

  Syntax: ``SAMPLE_B dst, address, sampler_view, sampler, lod_bias``

  Example: ``SAMPLE_B TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2].x``

.. opcode:: SAMPLE_C

  Similar to the SAMPLE instruction but it performs a comparison filter. The
  operands to SAMPLE_C are identical to SAMPLE, except that there is an
  additional float32 operand, reference value, which must be a register with
  single-component, or a scalar literal.  SAMPLE_C makes the hardware use the
  current samplers compare_func (in pipe_sampler_state) to compare reference
  value against the red component value for the surce resource at each texel
  that the currently configured texture filter covers based on the provided
  coordinates.

  Syntax: ``SAMPLE_C dst, address, sampler_view.r, sampler, ref_value``

  Example: ``SAMPLE_C TEMP[0], TEMP[1], SVIEW[0].r, SAMP[0], TEMP[2].x``

.. opcode:: SAMPLE_C_LZ

  Same as SAMPLE_C, but LOD is 0 and derivatives are ignored. The LZ stands
  for level-zero.

  Syntax: ``SAMPLE_C_LZ dst, address, sampler_view.r, sampler, ref_value``

  Example: ``SAMPLE_C_LZ TEMP[0], TEMP[1], SVIEW[0].r, SAMP[0], TEMP[2].x``


.. opcode:: SAMPLE_D

  SAMPLE_D is identical to the SAMPLE opcode except that the derivatives for
  the source address in the x direction and the y direction are provided by
  extra parameters.

  Syntax: ``SAMPLE_D dst, address, sampler_view, sampler, der_x, der_y``

  Example: ``SAMPLE_D TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2], TEMP[3]``

.. opcode:: SAMPLE_L

  SAMPLE_L is identical to the SAMPLE opcode except that the LOD is provided
  directly as a scalar value, representing no anisotropy.

  Syntax: ``SAMPLE_L dst, address, sampler_view, sampler, explicit_lod``

  Example: ``SAMPLE_L TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2].x``

.. opcode:: GATHER4

  Gathers the four texels to be used in a bi-linear filtering operation and
  packs them into a single register.  Only works with 2D, 2D array, cubemaps,
  and cubemaps arrays.  For 2D textures, only the addressing modes of the
  sampler and the top level of any mip pyramid are used. Set W to zero.  It
  behaves like the SAMPLE instruction, but a filtered sample is not
  generated. The four samples that contribute to filtering are placed into
  xyzw in counter-clockwise order, starting with the (u,v) texture coordinate
  delta at the following locations (-, +), (+, +), (+, -), (-, -), where the
  magnitude of the deltas are half a texel.


.. opcode:: SVIEWINFO

  Query the dimensions of a given sampler view.  dst receives width, height,
  depth or array size and number of mipmap levels as int4. The dst can have a
  writemask which will specify what info is the caller interested in.

  Syntax: ``SVIEWINFO dst, src_mip_level, sampler_view``

  Example: ``SVIEWINFO TEMP[0], TEMP[1].x, SVIEW[0]``

  src_mip_level is an unsigned integer scalar. If it's out of range then
  returns 0 for width, height and depth/array size but the total number of
  mipmap is still returned correctly for the given sampler view.  The returned
  width, height and depth values are for the mipmap level selected by the
  src_mip_level and are in the number of texels.  For 1d texture array width
  is in dst.x, array size is in dst.y and dst.z is 0. The number of mipmaps is
  still in dst.w.  In contrast to d3d10 resinfo, there's no way in the tgsi
  instruction encoding to specify the return type (float/rcpfloat/uint), hence
  always using uint. Also, unlike the SAMPLE instructions, the swizzle on src1
  resinfo allowing swizzling dst values is ignored (due to the interaction
  with rcpfloat modifier which requires some swizzle handling in the state
  tracker anyway).

.. opcode:: SAMPLE_POS

  Query the position of a given sample.  dst receives float4 (x, y, 0, 0)
  indicated where the sample is located. If the resource is not a multi-sample
  resource and not a render target, the result is 0.

.. opcode:: SAMPLE_INFO

  dst receives number of samples in x.  If the resource is not a multi-sample
  resource and not a render target, the result is 0.


.. _resourceopcodes:

Resource Access Opcodes
^^^^^^^^^^^^^^^^^^^^^^^

.. opcode:: LOAD - Fetch data from a shader resource

               Syntax: ``LOAD dst, resource, address``

               Example: ``LOAD TEMP[0], RES[0], TEMP[1]``

               Using the provided integer address, LOAD fetches data
               from the specified buffer or texture without any
               filtering.

               The 'address' is specified as a vector of unsigned
               integers.  If the 'address' is out of range the result
               is unspecified.

               Only the first mipmap level of a resource can be read
               from using this instruction.

               For 1D or 2D texture arrays, the array index is
               provided as an unsigned integer in address.y or
               address.z, respectively.  address.yz are ignored for
               buffers and 1D textures.  address.z is ignored for 1D
               texture arrays and 2D textures.  address.w is always
               ignored.

.. opcode:: STORE - Write data to a shader resource

               Syntax: ``STORE resource, address, src``

               Example: ``STORE RES[0], TEMP[0], TEMP[1]``

               Using the provided integer address, STORE writes data
               to the specified buffer or texture.

               The 'address' is specified as a vector of unsigned
               integers.  If the 'address' is out of range the result
               is unspecified.

               Only the first mipmap level of a resource can be
               written to using this instruction.

               For 1D or 2D texture arrays, the array index is
               provided as an unsigned integer in address.y or
               address.z, respectively.  address.yz are ignored for
               buffers and 1D textures.  address.z is ignored for 1D
               texture arrays and 2D textures.  address.w is always
               ignored.


.. _threadsyncopcodes:

Inter-thread synchronization opcodes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These opcodes are intended for communication between threads running
within the same compute grid.  For now they're only valid in compute
programs.

.. opcode:: MFENCE - Memory fence

  Syntax: ``MFENCE resource``

  Example: ``MFENCE RES[0]``

  This opcode forces strong ordering between any memory access
  operations that affect the specified resource.  This means that
  previous loads and stores (and only those) will be performed and
  visible to other threads before the program execution continues.


.. opcode:: LFENCE - Load memory fence

  Syntax: ``LFENCE resource``

  Example: ``LFENCE RES[0]``

  Similar to MFENCE, but it only affects the ordering of memory loads.


.. opcode:: SFENCE - Store memory fence

  Syntax: ``SFENCE resource``

  Example: ``SFENCE RES[0]``

  Similar to MFENCE, but it only affects the ordering of memory stores.


.. opcode:: BARRIER - Thread group barrier

  ``BARRIER``

  This opcode suspends the execution of the current thread until all
  the remaining threads in the working group reach the same point of
  the program.  Results are unspecified if any of the remaining
  threads terminates or never reaches an executed BARRIER instruction.


.. _atomopcodes:

Atomic opcodes
^^^^^^^^^^^^^^

These opcodes provide atomic variants of some common arithmetic and
logical operations.  In this context atomicity means that another
concurrent memory access operation that affects the same memory
location is guaranteed to be performed strictly before or after the
entire execution of the atomic operation.

For the moment they're only valid in compute programs.

.. opcode:: ATOMUADD - Atomic integer addition

  Syntax: ``ATOMUADD dst, resource, offset, src``

  Example: ``ATOMUADD TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = dst_i + src_i


.. opcode:: ATOMXCHG - Atomic exchange

  Syntax: ``ATOMXCHG dst, resource, offset, src``

  Example: ``ATOMXCHG TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = src_i


.. opcode:: ATOMCAS - Atomic compare-and-exchange

  Syntax: ``ATOMCAS dst, resource, offset, cmp, src``

  Example: ``ATOMCAS TEMP[0], RES[0], TEMP[1], TEMP[2], TEMP[3]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i == cmp_i ? src_i : dst_i)


.. opcode:: ATOMAND - Atomic bitwise And

  Syntax: ``ATOMAND dst, resource, offset, src``

  Example: ``ATOMAND TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = dst_i \& src_i


.. opcode:: ATOMOR - Atomic bitwise Or

  Syntax: ``ATOMOR dst, resource, offset, src``

  Example: ``ATOMOR TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = dst_i | src_i


.. opcode:: ATOMXOR - Atomic bitwise Xor

  Syntax: ``ATOMXOR dst, resource, offset, src``

  Example: ``ATOMXOR TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = dst_i \oplus src_i


.. opcode:: ATOMUMIN - Atomic unsigned minimum

  Syntax: ``ATOMUMIN dst, resource, offset, src``

  Example: ``ATOMUMIN TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i < src_i ? dst_i : src_i)


.. opcode:: ATOMUMAX - Atomic unsigned maximum

  Syntax: ``ATOMUMAX dst, resource, offset, src``

  Example: ``ATOMUMAX TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i > src_i ? dst_i : src_i)


.. opcode:: ATOMIMIN - Atomic signed minimum

  Syntax: ``ATOMIMIN dst, resource, offset, src``

  Example: ``ATOMIMIN TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i < src_i ? dst_i : src_i)


.. opcode:: ATOMIMAX - Atomic signed maximum

  Syntax: ``ATOMIMAX dst, resource, offset, src``

  Example: ``ATOMIMAX TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i > src_i ? dst_i : src_i)



Explanation of symbols used
------------------------------


Functions
^^^^^^^^^^^^^^


  :math:`|x|`       Absolute value of `x`.

  :math:`\lceil x \rceil` Ceiling of `x`.

  clamp(x,y,z)      Clamp x between y and z.
                    (x < y) ? y : (x > z) ? z : x

  :math:`\lfloor x\rfloor` Floor of `x`.

  :math:`\log_2{x}` Logarithm of `x`, base 2.

  max(x,y)          Maximum of x and y.
                    (x > y) ? x : y

  min(x,y)          Minimum of x and y.
                    (x < y) ? x : y

  partialx(x)       Derivative of x relative to fragment's X.

  partialy(x)       Derivative of x relative to fragment's Y.

  pop()             Pop from stack.

  :math:`x^y`       `x` to the power `y`.

  push(x)           Push x on stack.

  round(x)          Round x.

  trunc(x)          Truncate x, i.e. drop the fraction bits.


Keywords
^^^^^^^^^^^^^


  discard           Discard fragment.

  pc                Program counter.

  target            Label of target instruction.


Other tokens
---------------


Declaration
^^^^^^^^^^^


Declares a register that is will be referenced as an operand in Instruction
tokens.

File field contains register file that is being declared and is one
of TGSI_FILE.

UsageMask field specifies which of the register components can be accessed
and is one of TGSI_WRITEMASK.

The Local flag specifies that a given value isn't intended for
subroutine parameter passing and, as a result, the implementation
isn't required to give any guarantees of it being preserved across
subroutine boundaries.  As it's merely a compiler hint, the
implementation is free to ignore it.

If Dimension flag is set to 1, a Declaration Dimension token follows.

If Semantic flag is set to 1, a Declaration Semantic token follows.

If Interpolate flag is set to 1, a Declaration Interpolate token follows.

If file is TGSI_FILE_RESOURCE, a Declaration Resource token follows.

If Array flag is set to 1, a Declaration Array token follows.

Array Declaration
^^^^^^^^^^^^^^^^^^^^^^^^

Declarations can optional have an ArrayID attribute which can be referred by
indirect addressing operands. An ArrayID of zero is reserved and treaded as
if no ArrayID is specified.

If an indirect addressing operand refers to a specific declaration by using
an ArrayID only the registers in this declaration are guaranteed to be
accessed, accessing any register outside this declaration results in undefined
behavior. Note that for compatibility the effective index is zero-based and
not relative to the specified declaration

If no ArrayID is specified with an indirect addressing operand the whole
register file might be accessed by this operand. This is strongly discouraged
and will prevent packing of scalar/vec2 arrays and effective alias analysis.

Declaration Semantic
^^^^^^^^^^^^^^^^^^^^^^^^

Vertex and fragment shader input and output registers may be labeled
with semantic information consisting of a name and index.

Follows Declaration token if Semantic bit is set.

Since its purpose is to link a shader with other stages of the pipeline,
it is valid to follow only those Declaration tokens that declare a register
either in INPUT or OUTPUT file.

SemanticName field contains the semantic name of the register being declared.
There is no default value.

SemanticIndex is an optional subscript that can be used to distinguish
different register declarations with the same semantic name. The default value
is 0.

The meanings of the individual semantic names are explained in the following
sections.

TGSI_SEMANTIC_POSITION
""""""""""""""""""""""

For vertex shaders, TGSI_SEMANTIC_POSITION indicates the vertex shader
output register which contains the homogeneous vertex position in the clip
space coordinate system.  After clipping, the X, Y and Z components of the
vertex will be divided by the W value to get normalized device coordinates.

For fragment shaders, TGSI_SEMANTIC_POSITION is used to indicate that
fragment shader input contains the fragment's window position.  The X
component starts at zero and always increases from left to right.
The Y component starts at zero and always increases but Y=0 may either
indicate the top of the window or the bottom depending on the fragment
coordinate origin convention (see TGSI_PROPERTY_FS_COORD_ORIGIN).
The Z coordinate ranges from 0 to 1 to represent depth from the front
to the back of the Z buffer.  The W component contains the reciprocol
of the interpolated vertex position W component.

Fragment shaders may also declare an output register with
TGSI_SEMANTIC_POSITION.  Only the Z component is writable.  This allows
the fragment shader to change the fragment's Z position.



TGSI_SEMANTIC_COLOR
"""""""""""""""""""

For vertex shader outputs or fragment shader inputs/outputs, this
label indicates that the resister contains an R,G,B,A color.

Several shader inputs/outputs may contain colors so the semantic index
is used to distinguish them.  For example, color[0] may be the diffuse
color while color[1] may be the specular color.

This label is needed so that the flat/smooth shading can be applied
to the right interpolants during rasterization.



TGSI_SEMANTIC_BCOLOR
""""""""""""""""""""

Back-facing colors are only used for back-facing polygons, and are only valid
in vertex shader outputs. After rasterization, all polygons are front-facing
and COLOR and BCOLOR end up occupying the same slots in the fragment shader,
so all BCOLORs effectively become regular COLORs in the fragment shader.


TGSI_SEMANTIC_FOG
"""""""""""""""""

Vertex shader inputs and outputs and fragment shader inputs may be
labeled with TGSI_SEMANTIC_FOG to indicate that the register contains
a fog coordinate.  Typically, the fragment shader will use the fog coordinate
to compute a fog blend factor which is used to blend the normal fragment color
with a constant fog color.  But fog coord really is just an ordinary vec4
register like regular semantics.


TGSI_SEMANTIC_PSIZE
"""""""""""""""""""

Vertex shader input and output registers may be labeled with
TGIS_SEMANTIC_PSIZE to indicate that the register contains a point size
in the form (S, 0, 0, 1).  The point size controls the width or diameter
of points for rasterization.  This label cannot be used in fragment
shaders.

When using this semantic, be sure to set the appropriate state in the
:ref:`rasterizer` first.


TGSI_SEMANTIC_TEXCOORD
""""""""""""""""""""""

Only available if PIPE_CAP_TGSI_TEXCOORD is exposed !

Vertex shader outputs and fragment shader inputs may be labeled with
this semantic to make them replaceable by sprite coordinates via the
sprite_coord_enable state in the :ref:`rasterizer`.
The semantic index permitted with this semantic is limited to <= 7.

If the driver does not support TEXCOORD, sprite coordinate replacement
applies to inputs with the GENERIC semantic instead.

The intended use case for this semantic is gl_TexCoord.


TGSI_SEMANTIC_PCOORD
""""""""""""""""""""

Only available if PIPE_CAP_TGSI_TEXCOORD is exposed !

Fragment shader inputs may be labeled with TGSI_SEMANTIC_PCOORD to indicate
that the register contains sprite coordinates in the form (x, y, 0, 1), if
the current primitive is a point and point sprites are enabled. Otherwise,
the contents of the register are undefined.

The intended use case for this semantic is gl_PointCoord.


TGSI_SEMANTIC_GENERIC
"""""""""""""""""""""

All vertex/fragment shader inputs/outputs not labeled with any other
semantic label can be considered to be generic attributes.  Typical
uses of generic inputs/outputs are texcoords and user-defined values.


TGSI_SEMANTIC_NORMAL
""""""""""""""""""""

Indicates that a vertex shader input is a normal vector.  This is
typically only used for legacy graphics APIs.


TGSI_SEMANTIC_FACE
""""""""""""""""""

This label applies to fragment shader inputs only and indicates that
the register contains front/back-face information of the form (F, 0,
0, 1).  The first component will be positive when the fragment belongs
to a front-facing polygon, and negative when the fragment belongs to a
back-facing polygon.


TGSI_SEMANTIC_EDGEFLAG
""""""""""""""""""""""

For vertex shaders, this sematic label indicates that an input or
output is a boolean edge flag.  The register layout is [F, x, x, x]
where F is 0.0 or 1.0 and x = don't care.  Normally, the vertex shader
simply copies the edge flag input to the edgeflag output.

Edge flags are used to control which lines or points are actually
drawn when the polygon mode converts triangles/quads/polygons into
points or lines.


TGSI_SEMANTIC_STENCIL
"""""""""""""""""""""

For fragment shaders, this semantic label indicates that an output
is a writable stencil reference value. Only the Y component is writable.
This allows the fragment shader to change the fragments stencilref value.


TGSI_SEMANTIC_VIEWPORT_INDEX
""""""""""""""""""""""""""""

For geometry shaders, this semantic label indicates that an output
contains the index of the viewport (and scissor) to use.
Only the X value is used.


TGSI_SEMANTIC_LAYER
"""""""""""""""""""

For geometry shaders, this semantic label indicates that an output
contains the layer value to use for the color and depth/stencil surfaces.
Only the X value is used. (Also known as rendertarget array index.)


TGSI_SEMANTIC_CULLDIST
""""""""""""""""""""""

Used as distance to plane for performing application-defined culling
of individual primitives against a plane. When components of vertex
elements are given this label, these values are assumed to be a
float32 signed distance to a plane. Primitives will be completely
discarded if the plane distance for all of the vertices in the
primitive are < 0. If a vertex has a cull distance of NaN, that
vertex counts as "out" (as if its < 0);
The limits on both clip and cull distances are bound
by the PIPE_MAX_CLIP_OR_CULL_DISTANCE_COUNT define which defines
the maximum number of components that can be used to hold the
distances and by the PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT
which specifies the maximum number of registers which can be
annotated with those semantics.


TGSI_SEMANTIC_CLIPDIST
""""""""""""""""""""""

When components of vertex elements are identified this way, these
values are each assumed to be a float32 signed distance to a plane.
Primitive setup only invokes rasterization on pixels for which
the interpolated plane distances are >= 0. Multiple clip planes
can be implemented simultaneously, by annotating multiple
components of one or more vertex elements with the above specified
semantic. The limits on both clip and cull distances are bound
by the PIPE_MAX_CLIP_OR_CULL_DISTANCE_COUNT define which defines
the maximum number of components that can be used to hold the
distances and by the PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT
which specifies the maximum number of registers which can be
annotated with those semantics.

TGSI_SEMANTIC_SAMPLEID
""""""""""""""""""""""

For fragment shaders, this semantic label indicates that a system value
contains the current sample id (i.e. gl_SampleID). Only the X value is used.

TGSI_SEMANTIC_SAMPLEPOS
"""""""""""""""""""""""

For fragment shaders, this semantic label indicates that a system value
contains the current sample's position (i.e. gl_SamplePosition). Only the X
and Y values are used.

TGSI_SEMANTIC_SAMPLEMASK
""""""""""""""""""""""""

For fragment shaders, this semantic label indicates that an output contains
the sample mask used to disable further sample processing
(i.e. gl_SampleMask). Only the X value is used, up to 32x MS.

TGSI_SEMANTIC_INVOCATIONID
""""""""""""""""""""""""""

For geometry shaders, this semantic label indicates that a system value
contains the current invocation id (i.e. gl_InvocationID). Only the X value is
used.

Declaration Interpolate
^^^^^^^^^^^^^^^^^^^^^^^

This token is only valid for fragment shader INPUT declarations.

The Interpolate field specifes the way input is being interpolated by
the rasteriser and is one of TGSI_INTERPOLATE_*.

The CylindricalWrap bitfield specifies which register components
should be subject to cylindrical wrapping when interpolating by the
rasteriser. If TGSI_CYLINDRICAL_WRAP_X is set to 1, the X component
should be interpolated according to cylindrical wrapping rules.


Declaration Sampler View
^^^^^^^^^^^^^^^^^^^^^^^^

Follows Declaration token if file is TGSI_FILE_SAMPLER_VIEW.

DCL SVIEW[#], resource, type(s)

Declares a shader input sampler view and assigns it to a SVIEW[#]
register.

resource can be one of BUFFER, 1D, 2D, 3D, 1DArray and 2DArray.

type must be 1 or 4 entries (if specifying on a per-component
level) out of UNORM, SNORM, SINT, UINT and FLOAT.


Declaration Resource
^^^^^^^^^^^^^^^^^^^^

Follows Declaration token if file is TGSI_FILE_RESOURCE.

DCL RES[#], resource [, WR] [, RAW]

Declares a shader input resource and assigns it to a RES[#]
register.

resource can be one of BUFFER, 1D, 2D, 3D, CUBE, 1DArray and
2DArray.

If the RAW keyword is not specified, the texture data will be
subject to conversion, swizzling and scaling as required to yield
the specified data type from the physical data format of the bound
resource.

If the RAW keyword is specified, no channel conversion will be
performed: the values read for each of the channels (X,Y,Z,W) will
correspond to consecutive words in the same order and format
they're found in memory.  No element-to-address conversion will be
performed either: the value of the provided X coordinate will be
interpreted in byte units instead of texel units.  The result of
accessing a misaligned address is undefined.

Usage of the STORE opcode is only allowed if the WR (writable) flag
is set.


Properties
^^^^^^^^^^^^^^^^^^^^^^^^

Properties are general directives that apply to the whole TGSI program.

FS_COORD_ORIGIN
"""""""""""""""

Specifies the fragment shader TGSI_SEMANTIC_POSITION coordinate origin.
The default value is UPPER_LEFT.

If UPPER_LEFT, the position will be (0,0) at the upper left corner and
increase downward and rightward.
If LOWER_LEFT, the position will be (0,0) at the lower left corner and
increase upward and rightward.

OpenGL defaults to LOWER_LEFT, and is configurable with the
GL_ARB_fragment_coord_conventions extension.

DirectX 9/10 use UPPER_LEFT.

FS_COORD_PIXEL_CENTER
"""""""""""""""""""""

Specifies the fragment shader TGSI_SEMANTIC_POSITION pixel center convention.
The default value is HALF_INTEGER.

If HALF_INTEGER, the fractionary part of the position will be 0.5
If INTEGER, the fractionary part of the position will be 0.0

Note that this does not affect the set of fragments generated by
rasterization, which is instead controlled by half_pixel_center in the
rasterizer.

OpenGL defaults to HALF_INTEGER, and is configurable with the
GL_ARB_fragment_coord_conventions extension.

DirectX 9 uses INTEGER.
DirectX 10 uses HALF_INTEGER.

FS_COLOR0_WRITES_ALL_CBUFS
""""""""""""""""""""""""""
Specifies that writes to the fragment shader color 0 are replicated to all
bound cbufs. This facilitates OpenGL's fragColor output vs fragData[0] where
fragData is directed to a single color buffer, but fragColor is broadcast.

VS_PROHIBIT_UCPS
""""""""""""""""""""""""""
If this property is set on the program bound to the shader stage before the
fragment shader, user clip planes should have no effect (be disabled) even if
that shader does not write to any clip distance outputs and the rasterizer's
clip_plane_enable is non-zero.
This property is only supported by drivers that also support shader clip
distance outputs.
This is useful for APIs that don't have UCPs and where clip distances written
by a shader cannot be disabled.

GS_INVOCATIONS
""""""""""""""

Specifies the number of times a geometry shader should be executed for each
input primitive. Each invocation will have a different
TGSI_SEMANTIC_INVOCATIONID system value set. If not specified, assumed to
be 1.


Texture Sampling and Texture Formats
------------------------------------

This table shows how texture image components are returned as (x,y,z,w) tuples
by TGSI texture instructions, such as :opcode:`TEX`, :opcode:`TXD`, and
:opcode:`TXP`. For reference, OpenGL and Direct3D conventions are shown as
well.

+--------------------+--------------+--------------------+--------------+
| Texture Components | Gallium      | OpenGL             | Direct3D 9   |
+====================+==============+====================+==============+
| R                  | (r, 0, 0, 1) | (r, 0, 0, 1)       | (r, 1, 1, 1) |
+--------------------+--------------+--------------------+--------------+
| RG                 | (r, g, 0, 1) | (r, g, 0, 1)       | (r, g, 1, 1) |
+--------------------+--------------+--------------------+--------------+
| RGB                | (r, g, b, 1) | (r, g, b, 1)       | (r, g, b, 1) |
+--------------------+--------------+--------------------+--------------+
| RGBA               | (r, g, b, a) | (r, g, b, a)       | (r, g, b, a) |
+--------------------+--------------+--------------------+--------------+
| A                  | (0, 0, 0, a) | (0, 0, 0, a)       | (0, 0, 0, a) |
+--------------------+--------------+--------------------+--------------+
| L                  | (l, l, l, 1) | (l, l, l, 1)       | (l, l, l, 1) |
+--------------------+--------------+--------------------+--------------+
| LA                 | (l, l, l, a) | (l, l, l, a)       | (l, l, l, a) |
+--------------------+--------------+--------------------+--------------+
| I                  | (i, i, i, i) | (i, i, i, i)       | N/A          |
+--------------------+--------------+--------------------+--------------+
| UV                 | XXX TBD      | (0, 0, 0, 1)       | (u, v, 1, 1) |
|                    |              | [#envmap-bumpmap]_ |              |
+--------------------+--------------+--------------------+--------------+
| Z                  | XXX TBD      | (z, z, z, 1)       | (0, z, 0, 1) |
|                    |              | [#depth-tex-mode]_ |              |
+--------------------+--------------+--------------------+--------------+
| S                  | (s, s, s, s) | unknown            | unknown      |
+--------------------+--------------+--------------------+--------------+

.. [#envmap-bumpmap] http://www.opengl.org/registry/specs/ATI/envmap_bumpmap.txt
.. [#depth-tex-mode] the default is (z, z, z, 1) but may also be (0, 0, 0, z)
   or (z, z, z, z) depending on the value of GL_DEPTH_TEXTURE_MODE.
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d436 1
a436 5
.. opcode:: DDX, DDX_FINE - Derivative Relative To X

The fine variant is only used when ``PIPE_CAP_TGSI_FS_FINE_DERIVATIVE`` is
advertised. When it is, the fine version guarantees one derivative per row
while DDX is allowed to be the same for the entire 2x2 quad.
d449 1
a449 5
.. opcode:: DDY, DDY_FINE - Derivative Relative To Y

The fine variant is only used when ``PIPE_CAP_TGSI_FS_FINE_DERIVATIVE`` is
advertised. When it is, the fine version guarantees one derivative per column
while DDY is allowed to be the same for the entire 2x2 quad.
d587 2
a588 2
  for shadow textures with no arrays (and not cube map),
  src0.z contains the reference value.
d592 1
a592 1
  the reference value for 2D arrays and cube maps.
d594 4
a597 2
  for cube map array shadow textures, the reference value
  cannot be passed in src0.w, and TEX2 must be used instead.
d603 1
a603 23
  shadow_ref = src0.z or src0.w (optional)

  unit = src1

  dst = texture\_sample(unit, coord, shadow_ref)


.. opcode:: TEX2 - Texture Lookup (for shadow cube map arrays only)

  this is the same as TEX, but uses another reg to encode the
  reference value.

.. math::

  coord = src0

  shadow_ref = src1.x

  unit = src2

  dst = texture\_sample(unit, coord, shadow_ref)


d605 1
d617 1
a617 1
  unit = src3
d619 1
a619 1
  dst = texture\_sample\_deriv(unit, coord, ddx, ddy)
d626 1
a626 1
  coord.x = src0.x / src0.w
d628 1
a628 1
  coord.y = src0.y / src0.w
d630 1
a630 1
  coord.z = src0.z / src0.w
d634 1
a634 1
  unit = src1
d636 1
a636 1
  dst = texture\_sample(unit, coord)
a765 7
  for cube map array textures and shadow cube maps, the bias value
  cannot be passed in src0.w, and TXB2 must be used instead.

  if the target is a shadow texture, the reference value is always
  in src.z (this prevents shadow 3d and shadow 2d arrays from
  using this instruction, but this is not needed).

d768 1
a768 13
  coord.x = src0.x

  coord.y = src0.y

  coord.z = src0.z

  coord.w = none

  bias = src0.w

  unit = src1

  dst = texture\_sample(unit, coord, bias)
d770 1
d772 1
a772 1
.. opcode:: TXB2 - Texture Lookup With Bias (some cube maps only)
d774 1
a774 4
  this is the same as TXB, but uses another reg to encode the
  lod bias value for cube map arrays and shadow cube maps.
  Presumably shadow 2d arrays and shadow 3d targets could use
  this encoding too, but this is not legal.
d776 1
a776 9
  shadow cube map arrays are neither possible nor required.

.. math::

  coord = src0

  bias = src1.x

  unit = src2
a783 4
  
  u = src.x \times src.x + src.y \times src.y + src.z \times src.z

  v = \frac{1}{\sqrt{u}}
d785 1
a785 1
  dst.x = src.x \times v
d787 1
a787 1
  dst.y = src.y \times v
d789 1
a789 1
  dst.z = src.z \times v
a793 17
.. opcode:: NRM4 - 4-component Vector Normalise

.. math::
  
  u = src.x \times src.x + src.y \times src.y + src.z \times src.z + src.w \times src.w

  v = \frac{1}{\sqrt{u}}

  dst.x = src.x \times v

  dst.y = src.y \times v

  dst.z = src.z \times v

  dst.w = src.w \times v


a817 7
  for cube map array textures, the explicit lod value
  cannot be passed in src0.w, and TXL2 must be used instead.

  if the target is a shadow texture, the reference value is always
  in src.z (this prevents shadow 3d / 2d array / cube targets from
  using this instruction, but this is not needed).

d826 1
a826 1
  coord.w = none
a829 22
  unit = src1

  dst = texture\_sample(unit, coord, lod)


.. opcode:: TXL2 - Texture Lookup With explicit LOD (for cube map arrays only)

  this is the same as TXL, but uses another reg to encode the
  explicit lod value.
  Presumably shadow 3d / 2d array / cube targets could use
  this encoding too, but this is not legal.

  shadow cube map arrays are neither possible nor required.

.. math::

  coord = src0

  lod = src1.x

  unit = src2

d957 3
a959 3
  accessed. 3 components + level.  Just like texture instructions, an optional
  offset vector is provided, which is subject to various driver restrictions
  (regarding range, source of offsets).
d967 1
a967 7
  depth), 1D array (width, layers), 2D array (width, height, layers).
  Also return the number of accessible levels (last_level - first_level + 1)
  in W.

  For components which don't return a resource dimension, their value
  is undefined.

a978 2
  dst.w = texture\_levels(unit)

d1645 2
a1646 2
  Generate a new vertex for the current primitive into the specified vertex
  stream using the values in the output registers.
d1651 2
a1652 2
  Complete the current primitive in the specified vertex stream (consisting of
  the emitted vertices), and start a new one.
d1798 1
a1798 2
Interpolation ISA
^^^^^^^^^^^^^^^^^
d1800 1
a1800 4
The interpolation instructions allow an input to be interpolated in a
different way than its declaration. This corresponds to the GLSL 4.00
interpolateAt* functions. The first argument of each of these must come from
``TGSI_FILE_INPUT``.
d1802 1
a1802 5
.. opcode:: INTERP_CENTROID - Interpolate at the centroid

   Interpolates the varying specified by src0 at the centroid

.. opcode:: INTERP_SAMPLE - Interpolate at the specified sample
d1804 1
a1804 7
   Interpolates the varying specified by src0 at the sample id specified by
   src1.x (interpreted as an integer)

.. opcode:: INTERP_OFFSET - Interpolate at the specified offset

   Interpolates the varying specified by src0 at the offset src1.xy from the
   pixel center (interpreted as floats)
a2733 5
The Location field specifies the location inside the pixel that the
interpolation should be done at, one of ``TGSI_INTERPOLATE_LOC_*``. Note that
when per-sample shading is enabled, the implementation may choose to
interpolate at the sample irrespective of the Location field.

a2850 9
VS_WINDOW_SPACE_POSITION
""""""""""""""""""""""""""
If this property is set on the vertex shader, the TGSI_SEMANTIC_POSITION output
is assumed to contain window space coordinates.
Division of X,Y,Z by W and the viewport transformation are disabled, and 1/W is
directly taken from the 4-th component of the shader output.
Naturally, clipping is not performed on window coordinates either.
The effect of this property is undefined if a geometry or tessellation shader
are in use.
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d436 5
a440 1
.. opcode:: DDX - Derivative Relative To X
d453 5
a457 1
.. opcode:: DDY - Derivative Relative To Y
d595 2
a596 2
  for shadow textures with no arrays, src0.z contains
  the reference value.
d600 1
a600 1
  the reference value for 2D arrays.
d602 2
a603 4
  There is no way to pass a bias in the .w value for
  shadow arrays, and GLSL doesn't allow this.
  GLSL does allow cube shadows maps to take a bias value,
  and we have to determine how this will look in TGSI.
d609 23
a631 1
  bias = 0.0
a632 1
  dst = texture\_sample(unit, coord, bias)
d644 1
a644 1
  bias = 0.0
d646 1
a646 1
  dst = texture\_sample\_deriv(unit, coord, bias, ddx, ddy)
d653 1
a653 1
  coord.x = src0.x / src.w
d655 1
a655 1
  coord.y = src0.y / src.w
d657 1
a657 1
  coord.z = src0.z / src.w
d661 1
a661 1
  bias = 0.0
d663 1
a663 1
  dst = texture\_sample(unit, coord, bias)
d793 7
d802 13
a814 1
  coord.x = src.x
a815 1
  coord.y = src.y
d817 1
a817 1
  coord.z = src.z
d819 4
a822 1
  coord.w = 1.0
d824 9
a832 1
  bias = src.z
d840 4
d845 1
a845 1
  dst.x = src.x / (src.x \times src.x + src.y \times src.y + src.z \times src.z)
d847 1
a847 1
  dst.y = src.y / (src.x \times src.x + src.y \times src.y + src.z \times src.z)
d849 1
a849 1
  dst.z = src.z / (src.x \times src.x + src.y \times src.y + src.z \times src.z)
d854 17
d895 7
d910 1
a910 1
  coord.w = 1.0
d914 22
d1063 3
a1065 3
  accessed. 3 components + level.  src 1 is a 3 component constant signed
  integer vector, with each component only have a range of -8..+8 (hw only
  seems to deal with this range, interface allows for up to unsigned int).
d1073 7
a1079 1
  depth), 1D array (width, layers), 2D array (width, height, layers)
d1091 2
d1759 2
a1760 2
  Generate a new vertex for the current primitive using the values in the
  output registers.
d1765 2
a1766 2
  Complete the current primitive (consisting of the emitted vertices),
  and start a new one.
d1912 13
a1924 1
.. opcode:: NRM4 - 4-component Vector Normalise
d1926 2
a1927 1
This instruction replicates its result.
d1929 1
a1929 1
.. math::
d1931 2
a1932 1
  dst = \frac{src.x}{src.x \times src.x + src.y \times src.y + src.z \times src.z + src.w \times src.w}
d2862 5
d2984 9
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d20 1
a20 1
two-component vectors with double precision; see :ref:`Double Opcodes`.
d77 4
a80 7
  dst.x = 1

  dst.y = max(src.x, 0)

  dst.z = (src.x > 0) ? max(src.y, 0)^{clamp(src.w, -128, 128))} : 0

  dst.w = 1
d114 4
a117 7
  dst.x = 2^{\lfloor src.x\rfloor}

  dst.y = src.x - \lfloor src.x\rfloor

  dst.z = 2^{src.x}

  dst.w = 1
d124 4
a127 7
  dst.x = \lfloor\log_2{|src.x|}\rfloor

  dst.y = \frac{|src.x|}{2^{\lfloor\log_2{|src.x|}\rfloor}}

  dst.z = \log_2{|src.x|}

  dst.w = 1
d178 4
a181 7
  dst.x = 1

  dst.y = src0.y \times src1.y

  dst.z = src0.z

  dst.w = src1.w
d214 1
a214 1
  dst.x = (src0.x < src1.x) ? 1 : 0
d216 1
a216 1
  dst.y = (src0.y < src1.y) ? 1 : 0
d218 1
a218 1
  dst.z = (src0.z < src1.z) ? 1 : 0
d220 1
a220 1
  dst.w = (src0.w < src1.w) ? 1 : 0
d227 1
a227 1
  dst.x = (src0.x >= src1.x) ? 1 : 0
d229 1
a229 1
  dst.y = (src0.y >= src1.y) ? 1 : 0
d231 1
a231 1
  dst.z = (src0.z >= src1.z) ? 1 : 0
d233 1
a233 1
  dst.w = (src0.w >= src1.w) ? 1 : 0
d415 1
a415 1
  dst = (1 / src.x) > 0 ? clamp(1 / src.x, 5.42101e-020, 1.884467e+019) : clamp(1 / src.x, -1.884467e+019, -5.42101e-020)
d503 1
a503 1
  dst.x = (src0.x == src1.x) ? 1 : 0
d505 1
a505 1
  dst.y = (src0.y == src1.y) ? 1 : 0
d507 1
a507 1
  dst.z = (src0.z == src1.z) ? 1 : 0
d509 1
a509 1
  dst.w = (src0.w == src1.w) ? 1 : 0
d518 1
a518 1
  dst = 0
d529 1
a529 1
  dst.x = (src0.x > src1.x) ? 1 : 0
d531 1
a531 1
  dst.y = (src0.y > src1.y) ? 1 : 0
d533 1
a533 1
  dst.z = (src0.z > src1.z) ? 1 : 0
d535 1
a535 1
  dst.w = (src0.w > src1.w) ? 1 : 0
d551 1
a551 1
  dst.x = (src0.x <= src1.x) ? 1 : 0
d553 1
a553 1
  dst.y = (src0.y <= src1.y) ? 1 : 0
d555 1
a555 1
  dst.z = (src0.z <= src1.z) ? 1 : 0
d557 1
a557 1
  dst.w = (src0.w <= src1.w) ? 1 : 0
d564 1
a564 1
  dst.x = (src0.x != src1.x) ? 1 : 0
d566 1
a566 1
  dst.y = (src0.y != src1.y) ? 1 : 0
d568 1
a568 1
  dst.z = (src0.z != src1.z) ? 1 : 0
d570 1
a570 1
  dst.w = (src0.w != src1.w) ? 1 : 0
d579 1
a579 1
  dst = 1
a583 8
.. math::

  coord = src0

  bias = 0.0

  dst = texture_sample(unit, coord, bias)

d586 1
d589 1
d593 1
d599 8
d619 1
a619 1
  dst = texture_sample_deriv(unit, coord, bias, ddx, ddy)
d636 1
a636 1
  dst = texture_sample(unit, coord, bias)
d778 1
a778 1
  dst = texture_sample(unit, coord, bias)
d830 1
a830 1
  dst = texture_sample(unit, coord, lod)
d952 16
a967 17
.. opcode:: TXF - Texel Fetch (as per NV_gpu_shader4), extract a single texel
                  from a specified texture image. The source sampler may
		  not be a CUBE or SHADOW.
                  src 0 is a four-component signed integer vector used to
		  identify the single texel accessed. 3 components + level.
		  src 1 is a 3 component constant signed integer vector,
		  with each component only have a range of
		  -8..+8 (hw only seems to deal with this range, interface
		  allows for up to unsigned int).
		  TXF(uint_vec coord, int_vec offset).


.. opcode:: TXQ - Texture Size Query (as per NV_gpu_program4)
                  retrieve the dimensions of the texture
                  depending on the target. For 1D (width), 2D/RECT/CUBE
		  (width, height), 3D (width, height, depth),
		  1D array (width, layers), 2D array (width, height, layers)
d973 39
a1011 1
  dst.x = texture_width(unit, lod)
d1013 1
a1013 1
  dst.y = texture_height(unit, lod)
d1015 1
a1015 1
  dst.z = texture_depth(unit, lod)
d1017 10
d1144 30
d1223 1
a1223 1
  dst.x = ~src.x
d1225 1
a1225 1
  dst.y = ~src.y
d1227 1
a1227 1
  dst.z = ~src.z
d1229 1
a1229 1
  dst.w = ~src.w
d1236 1
a1236 1
  dst.x = src0.x & src1.x
d1238 1
a1238 1
  dst.y = src0.y & src1.y
d1240 1
a1240 1
  dst.z = src0.z & src1.z
d1242 1
a1242 1
  dst.w = src0.w & src1.w
d1325 2
d1329 1
a1329 1
  dst.x = src0.x << src1.x
d1331 1
a1331 1
  dst.y = src0.y << src1.x
d1333 1
a1333 1
  dst.z = src0.z << src1.x
d1335 1
a1335 1
  dst.w = src0.w << src1.x
d1340 2
d1344 1
a1344 1
  dst.x = src0.x >> src1.x
d1346 1
a1346 1
  dst.y = src0.y >> src1.x
d1348 1
a1348 1
  dst.z = src0.z >> src1.x
d1350 1
a1350 1
  dst.w = src0.w >> src1.x
d1355 2
d1359 1
a1359 1
  dst.x = src0.x >> (unsigned) src1.x
d1361 1
a1361 1
  dst.y = src0.y >> (unsigned) src1.x
d1363 1
a1363 1
  dst.z = src0.z >> (unsigned) src1.x
d1365 1
a1365 1
  dst.w = src0.w >> (unsigned) src1.x
d1396 15
d1415 1
a1415 1
  dst.x = (src0.x < src1.x) ? ~0 : 0
d1417 1
a1417 1
  dst.y = (src0.y < src1.y) ? ~0 : 0
d1419 1
a1419 1
  dst.z = (src0.z < src1.z) ? ~0 : 0
d1421 1
a1421 1
  dst.w = (src0.w < src1.w) ? ~0 : 0
d1428 16
a1443 1
  dst.x = (src0.x < src1.x) ? ~0 : 0
d1445 1
a1445 1
  dst.y = (src0.y < src1.y) ? ~0 : 0
d1447 1
a1447 1
  dst.z = (src0.z < src1.z) ? ~0 : 0
d1449 1
a1449 1
  dst.w = (src0.w < src1.w) ? ~0 : 0
d1456 1
a1456 1
  dst.x = (src0.x >= src1.x) ? ~0 : 0
d1458 1
a1458 1
  dst.y = (src0.y >= src1.y) ? ~0 : 0
d1460 1
a1460 1
  dst.z = (src0.z >= src1.z) ? ~0 : 0
d1462 1
a1462 1
  dst.w = (src0.w >= src1.w) ? ~0 : 0
d1469 16
a1484 1
  dst.x = (src0.x >= src1.x) ? ~0 : 0
d1486 1
a1486 1
  dst.y = (src0.y >= src1.y) ? ~0 : 0
d1488 1
a1488 1
  dst.z = (src0.z >= src1.z) ? ~0 : 0
d1490 1
a1490 1
  dst.w = (src0.w >= src1.w) ? ~0 : 0
d1497 16
a1512 1
  dst.x = (src0.x == src1.x) ? ~0 : 0
d1514 1
a1514 1
  dst.y = (src0.y == src1.y) ? ~0 : 0
d1516 1
a1516 1
  dst.z = (src0.z == src1.z) ? ~0 : 0
d1518 1
a1518 1
  dst.w = (src0.w == src1.w) ? ~0 : 0
d1525 1
a1525 1
  dst.x = (src0.x != src1.x) ? ~0 : 0
d1527 1
a1527 1
  dst.y = (src0.y != src1.y) ? ~0 : 0
d1529 1
a1529 1
  dst.z = (src0.z != src1.z) ? ~0 : 0
d1531 1
a1531 1
  dst.w = (src0.w != src1.w) ? ~0 : 0
d1561 75
d1767 13
a1779 12
   Example:
   SWITCH src[0].x
   CASE src[0].x
   (some instructions here)
   (optional BRK here)
   DEFAULT
   (some instructions here)
   (optional BRK here)
   CASE src[0].x
   (some instructions here)
   (optional BRK here)
   ENDSWITCH
d1943 61
d2005 106
a2110 139
.. opcode:: SAMPLE - Using provided address, sample data from the
               specified texture using the filtering mode identified
               by the gven sampler. The source data may come from
               any resource type other than buffers.
               SAMPLE dst, address, sampler_view, sampler
               e.g.
               SAMPLE TEMP[0], TEMP[1], SVIEW[0], SAMP[0]

.. opcode:: SAMPLE_I - Simplified alternative to the SAMPLE instruction.
               Using the provided integer address, SAMPLE_I fetches data
               from the specified sampler view without any filtering.
               The source data may come from any resource type other
               than CUBE.
               SAMPLE_I dst, address, sampler_view
               e.g.
               SAMPLE_I TEMP[0], TEMP[1], SVIEW[0]
               The 'address' is specified as unsigned integers. If the
               'address' is out of range [0...(# texels - 1)] the
               result of the fetch is always 0 in all components.
               As such the instruction doesn't honor address wrap
               modes, in cases where that behavior is desirable
               'SAMPLE' instruction should be used.
               address.w always provides an unsigned integer mipmap
               level. If the value is out of the range then the
               instruction always returns 0 in all components.
               address.yz are ignored for buffers and 1d textures.
               address.z is ignored for 1d texture arrays and 2d
               textures.
               For 1D texture arrays address.y provides the array
               index (also as unsigned integer). If the value is
               out of the range of available array indices
               [0... (array size - 1)] then the opcode always returns
               0 in all components.
               For 2D texture arrays address.z provides the array
               index, otherwise it exhibits the same behavior as in
               the case for 1D texture arrays.
               The exact semantics of the source address are presented
               in the table below:
               resource type         X     Y     Z       W
               -------------         ------------------------
               PIPE_BUFFER           x                ignored
               PIPE_TEXTURE_1D       x                  mpl
               PIPE_TEXTURE_2D       x     y            mpl
               PIPE_TEXTURE_3D       x     y     z      mpl
               PIPE_TEXTURE_RECT     x     y            mpl
               PIPE_TEXTURE_CUBE     not allowed as source
               PIPE_TEXTURE_1D_ARRAY x    idx           mpl
               PIPE_TEXTURE_2D_ARRAY x     y    idx     mpl

               Where 'mpl' is a mipmap level and 'idx' is the
               array index.

.. opcode:: SAMPLE_I_MS - Just like SAMPLE_I but allows fetch data from
               multi-sampled surfaces.
               SAMPLE_I_MS dst, address, sampler_view, sample

.. opcode:: SAMPLE_B - Just like the SAMPLE instruction with the
               exception that an additional bias is applied to the
               level of detail computed as part of the instruction
               execution.
               SAMPLE_B dst, address, sampler_view, sampler, lod_bias
               e.g.
               SAMPLE_B TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2].x

.. opcode:: SAMPLE_C - Similar to the SAMPLE instruction but it
               performs a comparison filter. The operands to SAMPLE_C
               are identical to SAMPLE, except that there is an additional
               float32 operand, reference value, which must be a register
               with single-component, or a scalar literal.
               SAMPLE_C makes the hardware use the current samplers
               compare_func (in pipe_sampler_state) to compare
               reference value against the red component value for the
               surce resource at each texel that the currently configured
               texture filter covers based on the provided coordinates.
               SAMPLE_C dst, address, sampler_view.r, sampler, ref_value
               e.g.
               SAMPLE_C TEMP[0], TEMP[1], SVIEW[0].r, SAMP[0], TEMP[2].x

.. opcode:: SAMPLE_C_LZ - Same as SAMPLE_C, but LOD is 0 and derivatives
               are ignored. The LZ stands for level-zero.
               SAMPLE_C_LZ dst, address, sampler_view.r, sampler, ref_value
               e.g.
               SAMPLE_C_LZ TEMP[0], TEMP[1], SVIEW[0].r, SAMP[0], TEMP[2].x


.. opcode:: SAMPLE_D - SAMPLE_D is identical to the SAMPLE opcode except
               that the derivatives for the source address in the x
               direction and the y direction are provided by extra
               parameters.
               SAMPLE_D dst, address, sampler_view, sampler, der_x, der_y
               e.g.
               SAMPLE_D TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2], TEMP[3]

.. opcode:: SAMPLE_L - SAMPLE_L is identical to the SAMPLE opcode except
               that the LOD is provided directly as a scalar value,
               representing no anisotropy.
               SAMPLE_L dst, address, sampler_view, sampler, explicit_lod
               e.g.
               SAMPLE_L TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2].x

.. opcode:: GATHER4 - Gathers the four texels to be used in a bi-linear
               filtering operation and packs them into a single register.
               Only works with 2D, 2D array, cubemaps, and cubemaps arrays.
               For 2D textures, only the addressing modes of the sampler and
               the top level of any mip pyramid are used. Set W to zero.
               It behaves like the SAMPLE instruction, but a filtered
               sample is not generated. The four samples that contribute
               to filtering are placed into xyzw in counter-clockwise order,
               starting with the (u,v) texture coordinate delta at the
               following locations (-, +), (+, +), (+, -), (-, -), where
               the magnitude of the deltas are half a texel.


.. opcode:: SVIEWINFO - query the dimensions of a given sampler view.
               dst receives width, height, depth or array size and
               number of mipmap levels as int4. The dst can have a writemask
               which will specify what info is the caller interested
               in.
               SVIEWINFO dst, src_mip_level, sampler_view
               e.g.
               SVIEWINFO TEMP[0], TEMP[1].x, SVIEW[0]
               src_mip_level is an unsigned integer scalar. If it's
               out of range then returns 0 for width, height and
               depth/array size but the total number of mipmap is
               still returned correctly for the given sampler view.
               The returned width, height and depth values are for
               the mipmap level selected by the src_mip_level and
               are in the number of texels.
               For 1d texture array width is in dst.x, array size
               is in dst.y and dst.zw are always 0.

.. opcode:: SAMPLE_POS - query the position of a given sample.
               dst receives float4 (x, y, 0, 0) indicated where the
               sample is located. If the resource is not a multi-sample
               resource and not a render target, the result is 0.

.. opcode:: SAMPLE_INFO - dst receives number of samples in x.
               If the resource is not a multi-sample resource and
               not a render target, the result is 0.
d2483 2
a2484 2
  Vertex and fragment shader input and output registers may be labeled
  with semantic information consisting of a name and index.
d2486 1
a2486 1
  Follows Declaration token if Semantic bit is set.
d2488 3
a2490 3
  Since its purpose is to link a shader with other stages of the pipeline,
  it is valid to follow only those Declaration tokens that declare a register
  either in INPUT or OUTPUT file.
d2492 2
a2493 2
  SemanticName field contains the semantic name of the register being declared.
  There is no default value.
d2495 3
a2497 3
  SemanticIndex is an optional subscript that can be used to distinguish
  different register declarations with the same semantic name. The default value
  is 0.
d2499 2
a2500 2
  The meanings of the individual semantic names are explained in the following
  sections.
d2555 4
a2558 7
a fog coordinate in the form (F, 0, 0, 1).  Typically, the fragment
shader will use the fog coordinate to compute a fog blend factor which
is used to blend the normal fragment color with a constant fog color.

Only the first component matters when writing from the vertex shader;
the driver will ensure that the coordinate is in this format when used
as a fragment shader input.
d2699 26
d2743 1
a2743 1
   Follows Declaration token if file is TGSI_FILE_SAMPLER_VIEW.
d2745 1
a2745 1
   DCL SVIEW[#], resource, type(s)
d2747 2
a2748 2
   Declares a shader input sampler view and assigns it to a SVIEW[#]
   register.
d2750 1
a2750 1
   resource can be one of BUFFER, 1D, 2D, 3D, 1DArray and 2DArray.
d2752 2
a2753 2
   type must be 1 or 4 entries (if specifying on a per-component
   level) out of UNORM, SNORM, SINT, UINT and FLOAT.
d2759 1
a2759 1
   Follows Declaration token if file is TGSI_FILE_RESOURCE.
d2761 1
a2761 1
   DCL RES[#], resource [, WR] [, RAW]
d2763 2
a2764 2
   Declares a shader input resource and assigns it to a RES[#]
   register.
d2766 15
a2780 15
   resource can be one of BUFFER, 1D, 2D, 3D, CUBE, 1DArray and
   2DArray.

   If the RAW keyword is not specified, the texture data will be
   subject to conversion, swizzling and scaling as required to yield
   the specified data type from the physical data format of the bound
   resource.

   If the RAW keyword is specified, no channel conversion will be
   performed: the values read for each of the channels (X,Y,Z,W) will
   correspond to consecutive words in the same order and format
   they're found in memory.  No element-to-address conversion will be
   performed either: the value of the provided X coordinate will be
   interpreted in byte units instead of texel units.  The result of
   accessing a misaligned address is undefined.
d2782 2
a2783 2
   Usage of the STORE opcode is only allowed if the WR (writable) flag
   is set.
d2789 1
a2789 2

  Properties are general directives that apply to the whole TGSI program.
d2842 8
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d26 12
d97 10
a106 1
This instruction replicates its result.
d110 1
a110 1
  dst = \frac{1}{\sqrt{|src.x|}}
a473 5
.. opcode:: KILP - Predicated Discard

  discard


d604 11
a717 19
.. opcode:: BRA - Branch

  pc = target

.. note::

   Considered for removal.

.. opcode:: CAL - Subroutine Call

  push(pc)
  pc = target


.. opcode:: RET - Subroutine Call Return

  pc = pop()


d744 3
a746 1
.. opcode:: KIL - Conditional Discard
d755 5
a841 20
.. opcode:: BRK - Break

  TBD


.. opcode:: IF - If

  TBD


.. opcode:: ELSE - Else

  TBD


.. opcode:: ENDIF - End If

  TBD


d873 22
d901 1
a901 1
XXX so let's discuss it, yeah?
d916 1
a916 1
.. opcode:: I2F - Integer To Float
d920 1
a920 1
  dst.x = (float) src.x
d922 1
a922 1
  dst.y = (float) src.y
d924 1
a924 1
  dst.z = (float) src.z
d926 1
a926 1
  dst.w = (float) src.w
d929 1
a929 1
.. opcode:: NOT - Bitwise Not
d933 3
a935 1
  dst.x = ~src.x
d937 1
a937 1
  dst.y = ~src.y
d939 1
a939 1
  dst.z = ~src.z
a940 1
  dst.w = ~src.w
d942 1
d944 2
a945 1
.. opcode:: TRUNC - Truncate
a946 1
.. math::
d948 1
a948 1
  dst.x = trunc(src.x)
d950 1
a950 1
  dst.y = trunc(src.y)
d952 1
a952 1
  dst.z = trunc(src.z)
d954 1
a954 1
  dst.w = trunc(src.w)
d956 1
d958 1
a958 1
.. opcode:: SHL - Shift Left
a959 1
.. math::
d961 10
a970 1
  dst.x = src0.x << src1.x
a971 1
  dst.y = src0.y << src1.x
d973 5
a977 1
  dst.z = src0.z << src1.x
d979 1
a979 1
  dst.w = src0.w << src1.x
d981 1
d983 1
a983 1
.. opcode:: SHR - Shift Right
d985 1
a985 1
.. math::
d987 1
a987 1
  dst.x = src0.x >> src1.x
a988 1
  dst.y = src0.y >> src1.x
d990 4
a993 1
  dst.z = src0.z >> src1.x
a994 1
  dst.w = src0.w >> src1.x
d996 1
d998 1
a998 1
.. opcode:: AND - Bitwise And
d1002 3
a1004 1
  dst.x = src0.x & src1.x
d1006 1
a1006 1
  dst.y = src0.y & src1.y
d1008 1
a1008 1
  dst.z = src0.z & src1.z
a1009 1
  dst.w = src0.w & src1.w
d1011 1
d1013 1
a1013 1
.. opcode:: OR - Bitwise Or
d1017 3
a1019 1
  dst.x = src0.x | src1.x
d1021 1
a1021 1
  dst.y = src0.y | src1.y
d1023 1
a1023 1
  dst.z = src0.z | src1.z
a1024 1
  dst.w = src0.w | src1.w
d1026 1
d1028 2
a1029 1
.. opcode:: MOD - Modulus
d1033 3
a1035 1
  dst.x = src0.x \bmod src1.x
d1037 1
a1037 1
  dst.y = src0.y \bmod src1.y
d1039 1
a1039 1
  dst.z = src0.z \bmod src1.z
a1040 1
  dst.w = src0.w \bmod src1.w
d1042 1
d1044 2
a1045 1
.. opcode:: XOR - Bitwise Xor
d1049 3
a1051 1
  dst.x = src0.x \oplus src1.x
d1053 1
a1053 1
  dst.y = src0.y \oplus src1.y
d1055 1
a1055 1
  dst.z = src0.z \oplus src1.z
a1056 1
  dst.w = src0.w \oplus src1.w
d1058 1
d1060 2
a1061 1
.. opcode:: SAD - Sum Of Absolute Differences
d1065 3
a1067 1
  dst.x = |src0.x - src1.x| + src2.x
d1069 1
a1069 1
  dst.y = |src0.y - src1.y| + src2.y
d1071 1
a1071 1
  dst.z = |src0.z - src1.z| + src2.z
a1072 1
  dst.w = |src0.w - src1.w| + src2.w
d1074 1
d1076 2
a1077 1
.. opcode:: TXF - Texel Fetch
d1079 1
a1079 1
  TBD
d1081 1
d1083 1
a1083 1
.. opcode:: TXQ - Texture Size Query
d1085 1
a1085 1
  TBD
d1087 1
a1088 1
.. opcode:: CONT - Continue
d1090 1
a1090 1
  TBD
d1092 2
a1093 1
.. note::
d1095 1
a1095 2
   Support for CONT is determined by a special capability bit,
   ``TGSI_CONT_SUPPORTED``. See :ref:`Screen` for more information.
d1097 1
d1099 1
a1099 2
Geometry ISA
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
d1101 1
a1101 2
These opcodes are only supported in geometry shaders; they have no meaning
in any other type of shader.
d1103 1
a1103 1
.. opcode:: EMIT - Emit
a1104 1
  TBD
d1106 1
d1108 1
a1108 1
.. opcode:: ENDPRIM - End Primitive
d1110 1
a1110 1
  TBD
d1112 1
d1114 1
a1114 2
GLSL ISA
^^^^^^^^^^
d1116 1
a1116 2
These opcodes are part of :term:`GLSL`'s opcode set. Support for these
opcodes is determined by a special capability bit, ``GLSL``.
d1118 1
a1118 1
.. opcode:: BGNLOOP - Begin a Loop
a1119 1
  TBD
d1121 1
d1123 1
a1123 1
.. opcode:: BGNSUB - Begin Subroutine
d1125 1
a1125 1
  TBD
d1127 1
d1129 1
a1129 1
.. opcode:: ENDLOOP - End a Loop
d1131 1
a1131 1
  TBD
d1133 1
a1134 1
.. opcode:: ENDSUB - End Subroutine
d1136 1
a1136 1
  TBD
d1138 1
d1140 1
a1140 1
.. opcode:: NOP - No Operation
d1142 1
a1142 1
  Do nothing.
d1144 1
d1146 1
a1146 1
.. opcode:: NRM4 - 4-component Vector Normalise
d1148 1
a1148 1
This instruction replicates its result.
a1149 1
.. math::
d1151 1
a1151 1
  dst = \frac{src.x}{src.x \times src.x + src.y \times src.y + src.z \times src.z + src.w \times src.w}
d1153 1
d1155 1
a1155 2
ps_2_x
^^^^^^^^^^^^
d1157 1
a1157 1
XXX wait what
d1159 1
a1159 1
.. opcode:: CALLNZ - Subroutine Call If Not Zero
d1161 1
a1161 1
  TBD
d1164 1
a1164 1
.. opcode:: IFC - If
d1166 1
a1166 1
  TBD
d1168 1
d1170 1
a1170 1
.. opcode:: BREAKC - Break Conditional
d1172 1
a1172 1
  TBD
d1174 1
a1174 1
.. _doubleopcodes:
a1175 2
Double ISA
^^^^^^^^^^^^^^^
d1177 1
a1177 2
The double-precision opcodes reinterpret four-component vectors into
two-component vectors with doubled precision in each component.
d1179 1
a1179 1
Support for these opcodes is XXX undecided. :T
d1181 1
a1181 1
.. opcode:: DADD - Add
d1183 1
a1183 1
.. math::
d1185 1
a1185 1
  dst.xy = src0.xy + src1.xy
d1187 1
a1187 1
  dst.zw = src0.zw + src1.zw
d1190 1
a1190 1
.. opcode:: DDIV - Divide
d1194 1
a1194 1
  dst.xy = src0.xy / src1.xy
d1196 1
a1196 1
  dst.zw = src0.zw / src1.zw
d1198 1
a1198 1
.. opcode:: DSEQ - Set on Equal
d1200 1
a1200 1
.. math::
a1201 1
  dst.xy = src0.xy == src1.xy ? 1.0F : 0.0F
d1203 428
a1630 1
  dst.zw = src0.zw == src1.zw ? 1.0F : 0.0F
d1726 1
a1726 1
.. _resourceopcodes:
d1728 2
a1729 2
Resource Access Opcodes
^^^^^^^^^^^^^^^^^^^^^^^^
d1734 11
a1744 3
.. opcode:: LOAD - Simplified alternative to the "SAMPLE" instruction.
               Using the provided integer address, LOAD fetches data
               from the specified buffer/texture without any filtering.
d1747 1
a1747 1
               LOAD dst, address, resource
d1749 1
a1749 1
               LOAD TEMP[0], TEMP[1], RES[0]
d1755 1
a1755 1
               'sample' instruction should be used.
d1770 1
a1770 1
               The exeact semantics of the source address are presented
d1786 1
a1786 2

.. opcode:: LOAD_MS - Just like LOAD but allows fetch data from
d1788 1
a1788 8

.. opcode:: SAMPLE - Using provided address, sample data from the
               specified texture using the filtering mode identified
               by the gven sampler. The source data may come from
               any resource type other than buffers.
               SAMPLE dst, address, resource, sampler
               e.g.
               SAMPLE TEMP[0], TEMP[1], RES[0], SAMP[0]
d1791 1
a1791 1
               exception that an additiona bias is applied to the
d1794 1
a1794 1
               SAMPLE_B dst, address, resource, sampler, lod_bias
d1796 1
a1796 1
               SAMPLE_B TEMP[0], TEMP[1], RES[0], SAMP[0], TEMP[2].x
d1800 1
a1800 1
               are identical to SAMPLE, except that tere is an additional
d1808 1
a1808 1
               SAMPLE_C dst, address, resource.r, sampler, ref_value
d1810 1
a1810 1
               SAMPLE_C TEMP[0], TEMP[1], RES[0].r, SAMP[0], TEMP[2].x
d1814 1
a1814 1
               SAMPLE_C_LZ dst, address, resource.r, sampler, ref_value
d1816 1
a1816 1
               SAMPLE_C_LZ TEMP[0], TEMP[1], RES[0].r, SAMP[0], TEMP[2].x
d1823 1
a1823 1
               SAMPLE_D dst, address, resource, sampler, der_x, der_y
d1825 1
a1825 1
               SAMPLE_D TEMP[0], TEMP[1], RES[0], SAMP[0], TEMP[2], TEMP[3]
d1829 2
a1830 3
               representing no anisotropy. Source addresses A channel
               is used as the LOD.
               SAMPLE_L dst, address, resource, sampler
d1832 1
a1832 2
               SAMPLE_L TEMP[0], TEMP[1], RES[0], SAMP[0]

d1836 1
a1836 1
               Only woth with 2D, 2D array, cubemaps, and cubemaps arrays.
d1841 1
a1841 1
               to filtering are places into xyzw in cunter-clockwise order,
d1847 1
a1847 1
.. opcode:: RESINFO - query the dimensions of a given input buffer.
d1849 1
a1849 1
               number of mipmap levels. The dst can have a writemask
d1852 1
a1852 1
               RESINFO dst, src_mip_level, resource
d1854 1
a1854 1
               RESINFO TEMP[0], TEMP[1].x, RES[0]
d1858 1
a1858 1
               still returned correctly for the given resource.
d1875 266
d2209 5
a2213 3
Interpolate field is only valid for fragment shader INPUT register files.
It specifes the way input is being interpolated by the rasteriser and is one
of TGSI_INTERPOLATE.
d2219 1
a2219 5
CylindricalWrap bitfield is only valid for fragment shader INPUT register
files. It specifies which register components should be subject to cylindrical
wrapping when interpolating by the rasteriser. If TGSI_CYLINDRICAL_WRAP_X
is set to 1, the X component should be interpolated according to cylindrical
wrapping rules.
d2223 18
d2339 29
d2405 1
d2407 1
a2407 1
""""""""""""""""""""""
d2409 1
a2409 1
For fragment shaders, this semantic label indicates than an output
d2414 81
d2496 1
a2496 1
^^^^^^^^^^^^^^^^^^^^^^^^
d2500 1
a2500 1
   DCL RES[#], resource, type(s)
d2508 15
a2522 2
   type must be 1 or 4 entries (if specifying on a per-component
   level) out of UNORM, SNORM, SINT, UINT and FLOAT.
d2557 1
a2557 1
rasterization, which is instead controlled by gl_rasterization_rules in the
d2571 11
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d580 7
a586 1
  TBD
d591 11
a601 1
  TBD
d606 13
a618 1
  TBD
d760 13
a772 1
  TBD
d810 9
a818 1
.. opcode:: TXL - Texture Lookup With LOD
d820 5
a824 1
  TBD
d1253 151
d1486 2
d1631 17
d1689 5
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d29 1
a29 1
From GL_NV_vertex_program
d32 2
d292 1
a292 1
.. opcode:: FRAC - Fraction
a641 4
From GL_NV_vertex_program2
^^^^^^^^^^^^^^^^^^^^^^^^^^


a680 2
  Potential restrictions:  
  * Only occurs at end of function.
d727 1
a727 1
  dst.y = 1
a784 27
.. opcode:: BGNFOR - Begin a For-Loop

  dst.x = floor(src.x)
  dst.y = floor(src.y)
  dst.z = floor(src.z)

  if (dst.y <= 0)
    pc = [matching ENDFOR] + 1
  endif

  Note: The destination must be a loop register.
        The source must be a constant register.

.. note::

   Considered for cleanup.

.. note::

   Considered for removal.


.. opcode:: REP - Repeat

  TBD


a794 24
.. opcode:: ENDFOR - End a For-Loop

  dst.x = dst.x + dst.z
  dst.y = dst.y - 1.0

  if (dst.y > 0)
    pc = [matching BGNFOR instruction] + 1
  endif

  Note: The destination must be a loop register.

.. note::

   Considered for cleanup.

.. note::

   Considered for removal.

.. opcode:: ENDREP - End Repeat

  TBD


d826 1
a826 1
From GL_NV_gpu_program4
d829 1
d832 2
d991 4
d996 2
a997 1
From GL_NV_geometry_program4
d1000 2
d1013 1
a1013 1
From GLSL
d1016 2
d1056 1
d1074 1
a1074 1
Double Opcodes
d1077 6
a1082 1
.. opcode:: DADD - Add Double
d1091 1
a1091 1
.. opcode:: DDIV - Divide Double
d1099 1
a1099 1
.. opcode:: DSEQ - Set Double on Equal
d1107 1
a1107 1
.. opcode:: DSLT - Set Double on Less than
d1115 1
a1115 1
.. opcode:: DFRAC - Double Fraction
d1124 5
a1128 1
.. opcode:: DFRACEXP - Convert Double Number to Fractional and Integral Components
d1132 5
a1136 1
  dst0.xy = frexp(src.xy, dst1.xy)
d1138 1
a1138 1
  dst0.zw = frexp(src.zw, dst1.zw)
d1140 3
a1142 1
.. opcode:: DLDEXP - Multiple Double Number by Integral Power of 2
d1146 1
a1146 1
  dst.xy = ldexp(src0.xy, src1.xy)
d1148 1
a1148 1
  dst.zw = ldexp(src0.zw, src1.zw)
d1150 1
a1150 1
.. opcode:: DMIN - Minimum Double
d1158 1
a1158 1
.. opcode:: DMAX - Maximum Double
d1166 1
a1166 1
.. opcode:: DMUL - Multiply Double
d1175 1
a1175 1
.. opcode:: DMAD - Multiply And Add Doubles
d1184 1
a1184 1
.. opcode:: DRCP - Reciprocal Double
d1192 1
a1192 1
.. opcode:: DSQRT - Square root double
d1287 2
d1309 18
a1326 11
Position, sometimes known as HPOS or WPOS for historical reasons, is the
location of the vertex in space, in ``(x, y, z, w)`` format. ``x``, ``y``, and ``z``
are the Cartesian coordinates, and ``w`` is the homogenous coordinate and used
for the perspective divide, if enabled.

As a vertex shader output, position should be scaled to the viewport. When
used in fragment shaders, position will be in window coordinates. The convention
used depends on the FS_COORD_ORIGIN and FS_COORD_PIXEL_CENTER properties.

XXX additionally, is there a way to configure the perspective divide? it's
accelerated on most chipsets AFAIK...
a1327 2
Position, if not specified, usually defaults to ``(0, 0, 0, 1)``, and can
be partially specified as ``(x, y, 0, 1)`` or ``(x, y, z, 1)``.
a1328 1
XXX usually? can we solidify that?
d1333 10
a1342 2
Colors are used to, well, color the primitives. Colors are always in
``(r, g, b, a)`` format.
a1343 1
If alpha is not specified, it defaults to 1.
d1350 3
a1352 2
and COLOR and BCOLOR end up occupying the same slots in the fragment, so
all BCOLORs effectively become regular COLORs in the fragment shader.
d1357 10
a1366 8
The fog coordinate historically has been used to replace the depth coordinate
for generation of fog in dedicated fog blocks. Gallium, however, does not use
dedicated fog acceleration, placing it entirely in the fragment shader
instead.

The fog coordinate should be written in ``(f, 0, 0, 1)`` format. Only the first
component matters when writing from the vertex shader; the driver will ensure
that the coordinate is in this format when used as a fragment shader input.
d1371 5
a1375 3
PSIZE, or point size, is used to specify point sizes per-vertex. It should
be in ``(s, 0, 0, 1)`` format, where ``s`` is the (possibly clamped) point size.
Only the first component matters when writing from the vertex shader.
d1380 1
d1384 4
a1387 7
Generic semantics are nearly always used for texture coordinate attributes,
in ``(s, t, r, q)`` format. ``t`` and ``r`` may be unused for certain kinds
of lookups, and ``q`` is the level-of-detail bias for biased sampling.

These attributes are called "generic" because they may be used for anything
else, including parameters, texture generation information, or anything that
can be stored inside a four-component vector.
d1392 3
a1394 2
Vertex normal; could be used to implement per-pixel lighting for legacy APIs
that allow mixing fixed-function and programmable stages.
d1399 6
a1404 4
FACE is the facing bit, to store the facing information for the fragment
shader. ``(f, 0, 0, 1)`` is the format. The first component will be positive
when the fragment is front-facing, and negative when the component is
back-facing.
d1409 15
a1423 1
XXX no clue
d1480 1
a1480 1
| R                  | XXX TBD      | (r, 0, 0, 1)       | (r, 1, 1, 1) |
d1482 1
a1482 1
| RG                 | XXX TBD      | (r, g, 0, 1)       | (r, g, 1, 1) |
d1501 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d29 1
a29 1
Core ISA
a31 2
These opcodes are guaranteed to be available regardless of the driver being
used.
d290 1
a290 1
.. opcode:: FRC - Fraction
d640 4
d683 2
d731 1
a731 1
  dst.w = 1
d789 27
d826 24
d881 1
a881 1
Compute ISA
a883 1
These opcodes are primarily provided for special-use computational shaders.
a885 2
XXX so let's discuss it, yeah?

a1042 4
.. note::

   Support for CONT is determined by a special capability bit,
   ``TGSI_CONT_SUPPORTED``. See :ref:`Screen` for more information.
d1044 1
a1044 2

Geometry ISA
a1046 2
These opcodes are only supported in geometry shaders; they have no meaning
in any other type of shader.
d1058 1
a1058 1
GLSL ISA
a1060 2
These opcodes are part of :term:`GLSL`'s opcode set. Support for these
opcodes is determined by a special capability bit, ``GLSL``.
a1098 1
XXX wait what
d1116 1
a1116 1
Double ISA
d1119 1
a1119 6
The double-precision opcodes reinterpret four-component vectors into
two-component vectors with doubled precision in each component.

Support for these opcodes is XXX undecided. :T

.. opcode:: DADD - Add
d1128 1
a1128 1
.. opcode:: DDIV - Divide
d1136 1
a1136 1
.. opcode:: DSEQ - Set on Equal
d1144 1
a1144 1
.. opcode:: DSLT - Set on Less than
d1152 1
a1152 1
.. opcode:: DFRAC - Fraction
d1161 1
a1161 5
.. opcode:: DFRACEXP - Convert Number to Fractional and Integral Components

Like the ``frexp()`` routine in many math libraries, this opcode stores the
exponent of its source to ``dst0``, and the significand to ``dst1``, such that
:math:`dst1 \times 2^{dst0} = src` .
d1165 1
a1165 5
  dst0.xy = exp(src.xy)

  dst1.xy = frac(src.xy)

  dst0.zw = exp(src.zw)
d1167 1
a1167 1
  dst1.zw = frac(src.zw)
d1169 1
a1169 3
.. opcode:: DLDEXP - Multiply Number by Integral Power of 2

This opcode is the inverse of :opcode:`DFRACEXP`.
d1173 1
a1173 1
  dst.xy = src0.xy \times 2^{src1.xy}
d1175 1
a1175 1
  dst.zw = src0.zw \times 2^{src1.zw}
d1177 1
a1177 1
.. opcode:: DMIN - Minimum
d1185 1
a1185 1
.. opcode:: DMAX - Maximum
d1193 1
a1193 1
.. opcode:: DMUL - Multiply
d1202 1
a1202 1
.. opcode:: DMAD - Multiply And Add
d1211 1
a1211 1
.. opcode:: DRCP - Reciprocal
d1219 1
a1219 1
.. opcode:: DSQRT - Square Root
a1313 2
  Vertex and fragment shader input and output registers may be labeled
  with semantic information consisting of a name and index.
d1334 11
a1344 18
For vertex shaders, TGSI_SEMANTIC_POSITION indicates the vertex shader
output register which contains the homogeneous vertex position in the clip
space coordinate system.  After clipping, the X, Y and Z components of the
vertex will be divided by the W value to get normalized device coordinates.

For fragment shaders, TGSI_SEMANTIC_POSITION is used to indicate that
fragment shader input contains the fragment's window position.  The X
component starts at zero and always increases from left to right.
The Y component starts at zero and always increases but Y=0 may either
indicate the top of the window or the bottom depending on the fragment
coordinate origin convention (see TGSI_PROPERTY_FS_COORD_ORIGIN).
The Z coordinate ranges from 0 to 1 to represent depth from the front
to the back of the Z buffer.  The W component contains the reciprocol
of the interpolated vertex position W component.

Fragment shaders may also declare an output register with
TGSI_SEMANTIC_POSITION.  Only the Z component is writable.  This allows
the fragment shader to change the fragment's Z position.
d1346 2
d1349 1
d1354 2
a1355 10
For vertex shader outputs or fragment shader inputs/outputs, this
label indicates that the resister contains an R,G,B,A color.

Several shader inputs/outputs may contain colors so the semantic index
is used to distinguish them.  For example, color[0] may be the diffuse
color while color[1] may be the specular color.

This label is needed so that the flat/smooth shading can be applied
to the right interpolants during rasterization.

d1357 1
d1364 2
a1365 3
and COLOR and BCOLOR end up occupying the same slots in the fragment shader,
so all BCOLORs effectively become regular COLORs in the fragment shader.

d1370 8
a1377 10
Vertex shader inputs and outputs and fragment shader inputs may be
labeled with TGSI_SEMANTIC_FOG to indicate that the register contains
a fog coordinate in the form (F, 0, 0, 1).  Typically, the fragment
shader will use the fog coordinate to compute a fog blend factor which
is used to blend the normal fragment color with a constant fog color.

Only the first component matters when writing from the vertex shader;
the driver will ensure that the coordinate is in this format when used
as a fragment shader input.

d1382 3
a1384 5
Vertex shader input and output registers may be labeled with
TGIS_SEMANTIC_PSIZE to indicate that the register contains a point size
in the form (S, 0, 0, 1).  The point size controls the width or diameter
of points for rasterization.  This label cannot be used in fragment
shaders.
a1388 1

d1392 7
a1398 4
All vertex/fragment shader inputs/outputs not labeled with any other
semantic label can be considered to be generic attributes.  Typical
uses of generic inputs/outputs are texcoords and user-defined values.

d1403 2
a1404 3
Indicates that a vertex shader input is a normal vector.  This is
typically only used for legacy graphics APIs.

d1409 4
a1412 6
This label applies to fragment shader inputs only and indicates that
the register contains front/back-face information of the form (F, 0,
0, 1).  The first component will be positive when the fragment belongs
to a front-facing polygon, and negative when the fragment belongs to a
back-facing polygon.

d1417 1
a1417 15
For vertex shaders, this sematic label indicates that an input or
output is a boolean edge flag.  The register layout is [F, x, x, x]
where F is 0.0 or 1.0 and x = don't care.  Normally, the vertex shader
simply copies the edge flag input to the edgeflag output.

Edge flags are used to control which lines or points are actually
drawn when the polygon mode converts triangles/quads/polygons into
points or lines.

TGSI_SEMANTIC_STENCIL
""""""""""""""""""""""

For fragment shaders, this semantic label indicates than an output
is a writable stencil reference value. Only the Y component is writable.
This allows the fragment shader to change the fragments stencilref value.
d1474 1
a1474 1
| R                  | (r, 0, 0, 1) | (r, 0, 0, 1)       | (r, 1, 1, 1) |
d1476 1
a1476 1
| RG                 | (r, g, 0, 1) | (r, g, 0, 1)       | (r, g, 1, 1) |
a1494 2
+--------------------+--------------+--------------------+--------------+
| S                  | (s, s, s, s) | unknown            | unknown      |
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a25 12
Modifiers
^^^^^^^^^^^^^^^

TGSI supports modifiers on inputs (as well as saturate modifier on instructions).

For inputs which have a floating point type, both absolute value and negation
modifiers are supported (with absolute value being applied first).
TGSI_OPCODE_MOV is considered to have float input type for applying modifiers.

For inputs which have signed or unsigned type only the negate modifier is
supported.

d85 1
a85 10
This instruction replicates its result. The results are undefined for src <= 0.

.. math::

  dst = \frac{1}{\sqrt{src.x}}


.. opcode:: SQRT - Square Root

This instruction replicates its result. The results are undefined for src < 0.
d89 1
a89 1
  dst = {\sqrt{src.x}}
d453 5
d580 1
a580 7
.. math::

  coord = src0

  bias = 0.0

  dst = texture_sample(unit, coord, bias)
a581 11
  for array textures src0.y contains the slice for 1D,
  and src0.z contain the slice for 2D.
  for shadow textures with no arrays, src0.z contains
  the reference value.
  for shadow textures with arrays, src0.z contains
  the reference value for 1D arrays, and src0.w contains
  the reference value for 2D arrays.
  There is no way to pass a bias in the .w value for
  shadow arrays, and GLSL doesn't allow this.
  GLSL does allow cube shadows maps to take a bias value,
  and we have to determine how this will look in TGSI.
d585 1
a585 11
.. math::

  coord = src0

  ddx = src1

  ddy = src2

  bias = 0.0

  dst = texture_sample_deriv(unit, coord, bias, ddx, ddy)
d590 1
a590 13
.. math::

  coord.x = src0.x / src.w

  coord.y = src0.y / src.w

  coord.z = src0.z / src.w

  coord.w = src0.w

  bias = 0.0

  dst = texture_sample(unit, coord, bias)
d663 19
d708 1
a708 3
.. opcode:: KILL_IF - Conditional Discard

  Conditional discard.  Allowed in fragment shaders only.
a716 5
.. opcode:: KILL - Discard

  Unconditional discard.  Allowed in fragment shaders only.


d732 1
a732 13
.. math::

  coord.x = src.x

  coord.y = src.y

  coord.z = src.z

  coord.w = 1.0

  bias = src.z

  dst = texture_sample(unit, coord, bias)
d770 11
a780 1
.. opcode:: TXL - Texture Lookup With explicit LOD
d782 1
a782 1
.. math::
a783 1
  coord.x = src0.x
d785 1
a785 1
  coord.y = src0.y
d787 1
a787 1
  coord.z = src0.z
a788 1
  coord.w = 1.0
d790 1
a790 1
  lod = src0.w
d792 1
a792 1
  dst = texture_sample(unit, coord, lod)
d826 7
a832 1
.. opcode:: BRA - Branch
d834 1
a834 1
  pc = target
d836 1
a836 1
.. note::
d838 1
a838 1
   Considered for removal.
d840 1
d842 1
a842 1
.. opcode:: CALLNZ - Subroutine Call If Not Zero
d844 1
a844 1
   TBD
a845 1
.. note::
d847 1
a847 1
   Considered for cleanup.
d849 1
a849 1
.. note::
d851 1
a851 1
   Considered for removal.
d853 1
d855 1
a855 2
Compute ISA
^^^^^^^^^^^^^^^^^^^^^^^^
d857 1
a857 2
These opcodes are primarily provided for special-use computational shaders.
Support for these opcodes indicated by a special pipe capability bit (TBD).
a858 1
XXX doesn't look like most of the opcodes really belong here.
d860 1
a860 1
.. opcode:: CEIL - Ceiling
d864 1
a864 1
  dst.x = \lceil src.x\rceil
d866 1
a866 1
  dst.y = \lceil src.y\rceil
d868 1
a868 1
  dst.z = \lceil src.z\rceil
d870 1
a870 1
  dst.w = \lceil src.w\rceil
d886 1
a886 1
.. opcode:: MOD - Modulus
d890 1
a890 1
  dst.x = src0.x \bmod src1.x
d892 1
a892 1
  dst.y = src0.y \bmod src1.y
d894 1
a894 1
  dst.z = src0.z \bmod src1.z
d896 1
a896 1
  dst.w = src0.w \bmod src1.w
d899 1
a899 1
.. opcode:: UARL - Integer Address Register Load
d901 1
a901 2
  Moves the contents of the source register, assumed to be an integer, into the
  destination register, which is assumed to be an address (ADDR) register.
d903 1
d905 1
a905 1
.. opcode:: SAD - Sum Of Absolute Differences
d907 1
a907 1
.. math::
d909 1
a909 1
  dst.x = |src0.x - src1.x| + src2.x
a910 1
  dst.y = |src0.y - src1.y| + src2.y
d912 1
a912 1
  dst.z = |src0.z - src1.z| + src2.z
d914 1
a914 1
  dst.w = |src0.w - src1.w| + src2.w
d916 1
d918 1
a918 10
.. opcode:: TXF - Texel Fetch (as per NV_gpu_shader4), extract a single texel
                  from a specified texture image. The source sampler may
		  not be a CUBE or SHADOW.
                  src 0 is a four-component signed integer vector used to
		  identify the single texel accessed. 3 components + level.
		  src 1 is a 3 component constant signed integer vector,
		  with each component only have a range of
		  -8..+8 (hw only seems to deal with this range, interface
		  allows for up to unsigned int).
		  TXF(uint_vec coord, int_vec offset).
d920 1
d922 1
a922 5
.. opcode:: TXQ - Texture Size Query (as per NV_gpu_program4)
                  retrieve the dimensions of the texture
                  depending on the target. For 1D (width), 2D/RECT/CUBE
		  (width, height), 3D (width, height, depth),
		  1D array (width, layers), 2D array (width, height, layers)
a923 1
.. math::
d925 1
a925 1
  lod = src0.x
d927 1
a927 1
  dst.x = texture_width(unit, lod)
d929 1
a929 1
  dst.y = texture_height(unit, lod)
d931 1
a931 1
  dst.z = texture_depth(unit, lod)
d933 1
d935 1
a935 4
Integer ISA
^^^^^^^^^^^^^^^^^^^^^^^^
These opcodes are used for integer operations.
Support for these opcodes indicated by PIPE_SHADER_CAP_INTEGERS (all of them?)
d938 1
a938 3
.. opcode:: I2F - Signed Integer To Float

   Rounding is unspecified (round to nearest even suggested).
d942 1
a942 1
  dst.x = (float) src.x
d944 1
a944 1
  dst.y = (float) src.y
d946 1
a946 1
  dst.z = (float) src.z
d948 1
a948 1
  dst.w = (float) src.w
d951 1
a951 3
.. opcode:: U2F - Unsigned Integer To Float

   Rounding is unspecified (round to nearest even suggested).
d955 1
a955 1
  dst.x = (float) src.x
d957 1
a957 1
  dst.y = (float) src.y
d959 1
a959 1
  dst.z = (float) src.z
d961 1
a961 1
  dst.w = (float) src.w
d964 1
a964 4
.. opcode:: F2I - Float to Signed Integer

   Rounding is towards zero (truncate).
   Values outside signed range (including NaNs) produce undefined results.
d968 1
a968 1
  dst.x = (int) src.x
d970 1
a970 1
  dst.y = (int) src.y
d972 1
a972 1
  dst.z = (int) src.z
d974 1
a974 1
  dst.w = (int) src.w
d977 1
a977 1
.. opcode:: F2U - Float to Unsigned Integer
d979 1
a979 2
   Rounding is towards zero (truncate).
   Values outside unsigned range (including NaNs) produce undefined results.
a980 1
.. math::
d982 1
a982 1
  dst.x = (unsigned) src.x
d984 1
a984 1
  dst.y = (unsigned) src.y
a985 1
  dst.z = (unsigned) src.z
d987 1
a987 1
  dst.w = (unsigned) src.w
d989 1
d991 1
a991 1
.. opcode:: UADD - Integer Add
d993 2
a994 2
   This instruction works the same for signed and unsigned integers.
   The low 32bit of the result is returned.
a995 1
.. math::
d997 2
a998 1
  dst.x = src0.x + src1.x
d1000 2
a1001 1
  dst.y = src0.y + src1.y
d1003 1
a1003 1
  dst.z = src0.z + src1.z
d1005 1
a1005 1
  dst.w = src0.w + src1.w
d1008 1
a1008 1
.. opcode:: UMAD - Integer Multiply And Add
d1010 1
a1010 2
   This instruction works the same for signed and unsigned integers.
   The multiplication returns the low 32bit (as does the result itself).
a1011 1
.. math::
d1013 2
a1014 1
  dst.x = src0.x \times src1.x + src2.x
d1016 2
a1017 1
  dst.y = src0.y \times src1.y + src2.y
d1019 1
a1019 1
  dst.z = src0.z \times src1.z + src2.z
d1021 1
a1021 1
  dst.w = src0.w \times src1.w + src2.w
d1024 1
a1024 1
.. opcode:: UMUL - Integer Multiply
d1026 1
a1026 2
   This instruction works the same for signed and unsigned integers.
   The low 32bit of the result is returned.
a1027 1
.. math::
d1029 1
a1029 1
  dst.x = src0.x \times src1.x
d1031 1
a1031 1
  dst.y = src0.y \times src1.y
a1032 1
  dst.z = src0.z \times src1.z
d1034 1
a1034 1
  dst.w = src0.w \times src1.w
d1036 1
a1037 1
.. opcode:: IDIV - Signed Integer Division
d1039 1
a1039 1
   TBD: behavior for division by zero.
d1041 1
a1041 1
.. math::
a1042 1
  dst.x = src0.x \ src1.x
d1044 1
a1044 1
  dst.y = src0.y \ src1.y
d1046 1
a1046 1
  dst.z = src0.z \ src1.z
d1048 1
a1048 1
  dst.w = src0.w \ src1.w
d1050 1
a1051 1
.. opcode:: UDIV - Unsigned Integer Division
d1053 2
a1054 1
   For division by zero, 0xffffffff is returned.
d1056 1
a1056 1
.. math::
d1058 1
a1058 1
  dst.x = src0.x \ src1.x
d1060 1
a1060 1
  dst.y = src0.y \ src1.y
a1061 1
  dst.z = src0.z \ src1.z
d1063 1
a1063 1
  dst.w = src0.w \ src1.w
d1065 1
a1066 1
.. opcode:: UMOD - Unsigned Integer Remainder
d1068 1
a1068 1
   If second arg is zero, 0xffffffff is returned.
d1070 1
a1070 1
.. math::
d1072 1
a1072 1
  dst.x = src0.x \ src1.x
d1074 2
a1075 1
  dst.y = src0.y \ src1.y
d1077 2
a1078 1
  dst.z = src0.z \ src1.z
d1080 1
a1080 1
  dst.w = src0.w \ src1.w
d1082 1
a1082 2

.. opcode:: NOT - Bitwise Not
d1086 1
a1086 1
  dst.x = ~src.x
d1088 1
a1088 1
  dst.y = ~src.y
a1089 1
  dst.z = ~src.z
d1091 1
a1091 1
  dst.w = ~src.w
d1093 1
a1093 456

.. opcode:: AND - Bitwise And

.. math::

  dst.x = src0.x & src1.x

  dst.y = src0.y & src1.y

  dst.z = src0.z & src1.z

  dst.w = src0.w & src1.w


.. opcode:: OR - Bitwise Or

.. math::

  dst.x = src0.x | src1.x

  dst.y = src0.y | src1.y

  dst.z = src0.z | src1.z

  dst.w = src0.w | src1.w


.. opcode:: XOR - Bitwise Xor

.. math::

  dst.x = src0.x \oplus src1.x

  dst.y = src0.y \oplus src1.y

  dst.z = src0.z \oplus src1.z

  dst.w = src0.w \oplus src1.w


.. opcode:: IMAX - Maximum of Signed Integers

.. math::

  dst.x = max(src0.x, src1.x)

  dst.y = max(src0.y, src1.y)

  dst.z = max(src0.z, src1.z)

  dst.w = max(src0.w, src1.w)


.. opcode:: UMAX - Maximum of Unsigned Integers

.. math::

  dst.x = max(src0.x, src1.x)

  dst.y = max(src0.y, src1.y)

  dst.z = max(src0.z, src1.z)

  dst.w = max(src0.w, src1.w)


.. opcode:: IMIN - Minimum of Signed Integers

.. math::

  dst.x = min(src0.x, src1.x)

  dst.y = min(src0.y, src1.y)

  dst.z = min(src0.z, src1.z)

  dst.w = min(src0.w, src1.w)


.. opcode:: UMIN - Minimum of Unsigned Integers

.. math::

  dst.x = min(src0.x, src1.x)

  dst.y = min(src0.y, src1.y)

  dst.z = min(src0.z, src1.z)

  dst.w = min(src0.w, src1.w)


.. opcode:: SHL - Shift Left

.. math::

  dst.x = src0.x << src1.x

  dst.y = src0.y << src1.x

  dst.z = src0.z << src1.x

  dst.w = src0.w << src1.x


.. opcode:: ISHR - Arithmetic Shift Right (of Signed Integer)

.. math::

  dst.x = src0.x >> src1.x

  dst.y = src0.y >> src1.x

  dst.z = src0.z >> src1.x

  dst.w = src0.w >> src1.x


.. opcode:: USHR - Logical Shift Right

.. math::

  dst.x = src0.x >> (unsigned) src1.x

  dst.y = src0.y >> (unsigned) src1.x

  dst.z = src0.z >> (unsigned) src1.x

  dst.w = src0.w >> (unsigned) src1.x


.. opcode:: UCMP - Integer Conditional Move

.. math::

  dst.x = src0.x ? src1.x : src2.x

  dst.y = src0.y ? src1.y : src2.y

  dst.z = src0.z ? src1.z : src2.z

  dst.w = src0.w ? src1.w : src2.w



.. opcode:: ISSG - Integer Set Sign

.. math::

  dst.x = (src0.x < 0) ? -1 : (src0.x > 0) ? 1 : 0

  dst.y = (src0.y < 0) ? -1 : (src0.y > 0) ? 1 : 0

  dst.z = (src0.z < 0) ? -1 : (src0.z > 0) ? 1 : 0

  dst.w = (src0.w < 0) ? -1 : (src0.w > 0) ? 1 : 0



.. opcode:: ISLT - Signed Integer Set On Less Than

.. math::

  dst.x = (src0.x < src1.x) ? ~0 : 0

  dst.y = (src0.y < src1.y) ? ~0 : 0

  dst.z = (src0.z < src1.z) ? ~0 : 0

  dst.w = (src0.w < src1.w) ? ~0 : 0


.. opcode:: USLT - Unsigned Integer Set On Less Than

.. math::

  dst.x = (src0.x < src1.x) ? ~0 : 0

  dst.y = (src0.y < src1.y) ? ~0 : 0

  dst.z = (src0.z < src1.z) ? ~0 : 0

  dst.w = (src0.w < src1.w) ? ~0 : 0


.. opcode:: ISGE - Signed Integer Set On Greater Equal Than

.. math::

  dst.x = (src0.x >= src1.x) ? ~0 : 0

  dst.y = (src0.y >= src1.y) ? ~0 : 0

  dst.z = (src0.z >= src1.z) ? ~0 : 0

  dst.w = (src0.w >= src1.w) ? ~0 : 0


.. opcode:: USGE - Unsigned Integer Set On Greater Equal Than

.. math::

  dst.x = (src0.x >= src1.x) ? ~0 : 0

  dst.y = (src0.y >= src1.y) ? ~0 : 0

  dst.z = (src0.z >= src1.z) ? ~0 : 0

  dst.w = (src0.w >= src1.w) ? ~0 : 0


.. opcode:: USEQ - Integer Set On Equal

.. math::

  dst.x = (src0.x == src1.x) ? ~0 : 0

  dst.y = (src0.y == src1.y) ? ~0 : 0

  dst.z = (src0.z == src1.z) ? ~0 : 0

  dst.w = (src0.w == src1.w) ? ~0 : 0


.. opcode:: USNE - Integer Set On Not Equal

.. math::

  dst.x = (src0.x != src1.x) ? ~0 : 0

  dst.y = (src0.y != src1.y) ? ~0 : 0

  dst.z = (src0.z != src1.z) ? ~0 : 0

  dst.w = (src0.w != src1.w) ? ~0 : 0


.. opcode:: INEG - Integer Negate

  Two's complement.

.. math::

  dst.x = -src.x

  dst.y = -src.y

  dst.z = -src.z

  dst.w = -src.w


.. opcode:: IABS - Integer Absolute Value

.. math::

  dst.x = |src.x|

  dst.y = |src.y|

  dst.z = |src.z|

  dst.w = |src.w|


Geometry ISA
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These opcodes are only supported in geometry shaders; they have no meaning
in any other type of shader.

.. opcode:: EMIT - Emit

  Generate a new vertex for the current primitive using the values in the
  output registers.


.. opcode:: ENDPRIM - End Primitive

  Complete the current primitive (consisting of the emitted vertices),
  and start a new one.


GLSL ISA
^^^^^^^^^^

These opcodes are part of :term:`GLSL`'s opcode set. Support for these
opcodes is determined by a special capability bit, ``GLSL``.
Some require glsl version 1.30 (UIF/BREAKC/SWITCH/CASE/DEFAULT/ENDSWITCH).

.. opcode:: CAL - Subroutine Call

  push(pc)
  pc = target


.. opcode:: RET - Subroutine Call Return

  pc = pop()


.. opcode:: CONT - Continue

  Unconditionally moves the point of execution to the instruction after the
  last bgnloop. The instruction must appear within a bgnloop/endloop.

.. note::

   Support for CONT is determined by a special capability bit,
   ``TGSI_CONT_SUPPORTED``. See :ref:`Screen` for more information.


.. opcode:: BGNLOOP - Begin a Loop

  Start a loop. Must have a matching endloop.


.. opcode:: BGNSUB - Begin Subroutine

  Starts definition of a subroutine. Must have a matching endsub.


.. opcode:: ENDLOOP - End a Loop

  End a loop started with bgnloop.


.. opcode:: ENDSUB - End Subroutine

  Ends definition of a subroutine.


.. opcode:: NOP - No Operation

  Do nothing.


.. opcode:: BRK - Break

  Unconditionally moves the point of execution to the instruction after the
  next endloop or endswitch. The instruction must appear within a loop/endloop
  or switch/endswitch.


.. opcode:: BREAKC - Break Conditional

  Conditionally moves the point of execution to the instruction after the
  next endloop or endswitch. The instruction must appear within a loop/endloop
  or switch/endswitch.
  Condition evaluates to true if src0.x != 0 where src0.x is interpreted
  as an integer register.

.. note::

   Considered for removal as it's quite inconsistent wrt other opcodes
   (could emulate with UIF/BRK/ENDIF). 


.. opcode:: IF - Float If

  Start an IF ... ELSE .. ENDIF block.  Condition evaluates to true if

    src0.x != 0.0

  where src0.x is interpreted as a floating point register.


.. opcode:: UIF - Bitwise If

  Start an UIF ... ELSE .. ENDIF block. Condition evaluates to true if

    src0.x != 0

  where src0.x is interpreted as an integer register.


.. opcode:: ELSE - Else

  Starts an else block, after an IF or UIF statement.


.. opcode:: ENDIF - End If

  Ends an IF or UIF block.


.. opcode:: SWITCH - Switch

   Starts a C-style switch expression. The switch consists of one or multiple
   CASE statements, and at most one DEFAULT statement. Execution of a statement
   ends when a BRK is hit, but just like in C falling through to other cases
   without a break is allowed. Similarly, DEFAULT label is allowed anywhere not
   just as last statement, and fallthrough is allowed into/from it.
   CASE src arguments are evaluated at bit level against the SWITCH src argument.

   Example:
   SWITCH src[0].x
   CASE src[0].x
   (some instructions here)
   (optional BRK here)
   DEFAULT
   (some instructions here)
   (optional BRK here)
   CASE src[0].x
   (some instructions here)
   (optional BRK here)
   ENDSWITCH


.. opcode:: CASE - Switch case

   This represents a switch case label. The src arg must be an integer immediate.


.. opcode:: DEFAULT - Switch default

   This represents the default case in the switch, which is taken if no other
   case matches.


.. opcode:: ENDSWITCH - End of switch

   Ends a switch expression.


.. opcode:: NRM4 - 4-component Vector Normalise

This instruction replicates its result.

.. math::

  dst = \frac{src.x}{src.x \times src.x + src.y \times src.y + src.z \times src.z + src.w \times src.w}


.. _doubleopcodes:

Double ISA
^^^^^^^^^^^^^^^

The double-precision opcodes reinterpret four-component vectors into
two-component vectors with doubled precision in each component.

Support for these opcodes is XXX undecided. :T

.. opcode:: DADD - Add

.. math::

  dst.xy = src0.xy + src1.xy

  dst.zw = src0.zw + src1.zw


.. opcode:: DDIV - Divide

.. math::
a1200 415
.. _samplingopcodes:

Resource Sampling Opcodes
^^^^^^^^^^^^^^^^^^^^^^^^^

Those opcodes follow very closely semantics of the respective Direct3D
instructions. If in doubt double check Direct3D documentation.

.. opcode:: SAMPLE - Using provided address, sample data from the
               specified texture using the filtering mode identified
               by the gven sampler. The source data may come from
               any resource type other than buffers.
               SAMPLE dst, address, sampler_view, sampler
               e.g.
               SAMPLE TEMP[0], TEMP[1], SVIEW[0], SAMP[0]

.. opcode:: SAMPLE_I - Simplified alternative to the SAMPLE instruction.
               Using the provided integer address, SAMPLE_I fetches data
               from the specified sampler view without any filtering.
               The source data may come from any resource type other
               than CUBE.
               SAMPLE_I dst, address, sampler_view
               e.g.
               SAMPLE_I TEMP[0], TEMP[1], SVIEW[0]
               The 'address' is specified as unsigned integers. If the
               'address' is out of range [0...(# texels - 1)] the
               result of the fetch is always 0 in all components.
               As such the instruction doesn't honor address wrap
               modes, in cases where that behavior is desirable
               'SAMPLE' instruction should be used.
               address.w always provides an unsigned integer mipmap
               level. If the value is out of the range then the
               instruction always returns 0 in all components.
               address.yz are ignored for buffers and 1d textures.
               address.z is ignored for 1d texture arrays and 2d
               textures.
               For 1D texture arrays address.y provides the array
               index (also as unsigned integer). If the value is
               out of the range of available array indices
               [0... (array size - 1)] then the opcode always returns
               0 in all components.
               For 2D texture arrays address.z provides the array
               index, otherwise it exhibits the same behavior as in
               the case for 1D texture arrays.
               The exact semantics of the source address are presented
               in the table below:
               resource type         X     Y     Z       W
               -------------         ------------------------
               PIPE_BUFFER           x                ignored
               PIPE_TEXTURE_1D       x                  mpl
               PIPE_TEXTURE_2D       x     y            mpl
               PIPE_TEXTURE_3D       x     y     z      mpl
               PIPE_TEXTURE_RECT     x     y            mpl
               PIPE_TEXTURE_CUBE     not allowed as source
               PIPE_TEXTURE_1D_ARRAY x    idx           mpl
               PIPE_TEXTURE_2D_ARRAY x     y    idx     mpl

               Where 'mpl' is a mipmap level and 'idx' is the
               array index.

.. opcode:: SAMPLE_I_MS - Just like SAMPLE_I but allows fetch data from
               multi-sampled surfaces.
               SAMPLE_I_MS dst, address, sampler_view, sample

.. opcode:: SAMPLE_B - Just like the SAMPLE instruction with the
               exception that an additional bias is applied to the
               level of detail computed as part of the instruction
               execution.
               SAMPLE_B dst, address, sampler_view, sampler, lod_bias
               e.g.
               SAMPLE_B TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2].x

.. opcode:: SAMPLE_C - Similar to the SAMPLE instruction but it
               performs a comparison filter. The operands to SAMPLE_C
               are identical to SAMPLE, except that there is an additional
               float32 operand, reference value, which must be a register
               with single-component, or a scalar literal.
               SAMPLE_C makes the hardware use the current samplers
               compare_func (in pipe_sampler_state) to compare
               reference value against the red component value for the
               surce resource at each texel that the currently configured
               texture filter covers based on the provided coordinates.
               SAMPLE_C dst, address, sampler_view.r, sampler, ref_value
               e.g.
               SAMPLE_C TEMP[0], TEMP[1], SVIEW[0].r, SAMP[0], TEMP[2].x

.. opcode:: SAMPLE_C_LZ - Same as SAMPLE_C, but LOD is 0 and derivatives
               are ignored. The LZ stands for level-zero.
               SAMPLE_C_LZ dst, address, sampler_view.r, sampler, ref_value
               e.g.
               SAMPLE_C_LZ TEMP[0], TEMP[1], SVIEW[0].r, SAMP[0], TEMP[2].x


.. opcode:: SAMPLE_D - SAMPLE_D is identical to the SAMPLE opcode except
               that the derivatives for the source address in the x
               direction and the y direction are provided by extra
               parameters.
               SAMPLE_D dst, address, sampler_view, sampler, der_x, der_y
               e.g.
               SAMPLE_D TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2], TEMP[3]

.. opcode:: SAMPLE_L - SAMPLE_L is identical to the SAMPLE opcode except
               that the LOD is provided directly as a scalar value,
               representing no anisotropy.
               SAMPLE_L dst, address, sampler_view, sampler, explicit_lod
               e.g.
               SAMPLE_L TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2].x

.. opcode:: GATHER4 - Gathers the four texels to be used in a bi-linear
               filtering operation and packs them into a single register.
               Only works with 2D, 2D array, cubemaps, and cubemaps arrays.
               For 2D textures, only the addressing modes of the sampler and
               the top level of any mip pyramid are used. Set W to zero.
               It behaves like the SAMPLE instruction, but a filtered
               sample is not generated. The four samples that contribute
               to filtering are placed into xyzw in counter-clockwise order,
               starting with the (u,v) texture coordinate delta at the
               following locations (-, +), (+, +), (+, -), (-, -), where
               the magnitude of the deltas are half a texel.


.. opcode:: SVIEWINFO - query the dimensions of a given sampler view.
               dst receives width, height, depth or array size and
               number of mipmap levels as int4. The dst can have a writemask
               which will specify what info is the caller interested
               in.
               SVIEWINFO dst, src_mip_level, sampler_view
               e.g.
               SVIEWINFO TEMP[0], TEMP[1].x, SVIEW[0]
               src_mip_level is an unsigned integer scalar. If it's
               out of range then returns 0 for width, height and
               depth/array size but the total number of mipmap is
               still returned correctly for the given sampler view.
               The returned width, height and depth values are for
               the mipmap level selected by the src_mip_level and
               are in the number of texels.
               For 1d texture array width is in dst.x, array size
               is in dst.y and dst.zw are always 0.

.. opcode:: SAMPLE_POS - query the position of a given sample.
               dst receives float4 (x, y, 0, 0) indicated where the
               sample is located. If the resource is not a multi-sample
               resource and not a render target, the result is 0.

.. opcode:: SAMPLE_INFO - dst receives number of samples in x.
               If the resource is not a multi-sample resource and
               not a render target, the result is 0.


.. _resourceopcodes:

Resource Access Opcodes
^^^^^^^^^^^^^^^^^^^^^^^

.. opcode:: LOAD - Fetch data from a shader resource

               Syntax: ``LOAD dst, resource, address``

               Example: ``LOAD TEMP[0], RES[0], TEMP[1]``

               Using the provided integer address, LOAD fetches data
               from the specified buffer or texture without any
               filtering.

               The 'address' is specified as a vector of unsigned
               integers.  If the 'address' is out of range the result
               is unspecified.

               Only the first mipmap level of a resource can be read
               from using this instruction.

               For 1D or 2D texture arrays, the array index is
               provided as an unsigned integer in address.y or
               address.z, respectively.  address.yz are ignored for
               buffers and 1D textures.  address.z is ignored for 1D
               texture arrays and 2D textures.  address.w is always
               ignored.

.. opcode:: STORE - Write data to a shader resource

               Syntax: ``STORE resource, address, src``

               Example: ``STORE RES[0], TEMP[0], TEMP[1]``

               Using the provided integer address, STORE writes data
               to the specified buffer or texture.

               The 'address' is specified as a vector of unsigned
               integers.  If the 'address' is out of range the result
               is unspecified.

               Only the first mipmap level of a resource can be
               written to using this instruction.

               For 1D or 2D texture arrays, the array index is
               provided as an unsigned integer in address.y or
               address.z, respectively.  address.yz are ignored for
               buffers and 1D textures.  address.z is ignored for 1D
               texture arrays and 2D textures.  address.w is always
               ignored.


.. _threadsyncopcodes:

Inter-thread synchronization opcodes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These opcodes are intended for communication between threads running
within the same compute grid.  For now they're only valid in compute
programs.

.. opcode:: MFENCE - Memory fence

  Syntax: ``MFENCE resource``

  Example: ``MFENCE RES[0]``

  This opcode forces strong ordering between any memory access
  operations that affect the specified resource.  This means that
  previous loads and stores (and only those) will be performed and
  visible to other threads before the program execution continues.


.. opcode:: LFENCE - Load memory fence

  Syntax: ``LFENCE resource``

  Example: ``LFENCE RES[0]``

  Similar to MFENCE, but it only affects the ordering of memory loads.


.. opcode:: SFENCE - Store memory fence

  Syntax: ``SFENCE resource``

  Example: ``SFENCE RES[0]``

  Similar to MFENCE, but it only affects the ordering of memory stores.


.. opcode:: BARRIER - Thread group barrier

  ``BARRIER``

  This opcode suspends the execution of the current thread until all
  the remaining threads in the working group reach the same point of
  the program.  Results are unspecified if any of the remaining
  threads terminates or never reaches an executed BARRIER instruction.


.. _atomopcodes:

Atomic opcodes
^^^^^^^^^^^^^^

These opcodes provide atomic variants of some common arithmetic and
logical operations.  In this context atomicity means that another
concurrent memory access operation that affects the same memory
location is guaranteed to be performed strictly before or after the
entire execution of the atomic operation.

For the moment they're only valid in compute programs.

.. opcode:: ATOMUADD - Atomic integer addition

  Syntax: ``ATOMUADD dst, resource, offset, src``

  Example: ``ATOMUADD TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = dst_i + src_i


.. opcode:: ATOMXCHG - Atomic exchange

  Syntax: ``ATOMXCHG dst, resource, offset, src``

  Example: ``ATOMXCHG TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = src_i


.. opcode:: ATOMCAS - Atomic compare-and-exchange

  Syntax: ``ATOMCAS dst, resource, offset, cmp, src``

  Example: ``ATOMCAS TEMP[0], RES[0], TEMP[1], TEMP[2], TEMP[3]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i == cmp_i ? src_i : dst_i)


.. opcode:: ATOMAND - Atomic bitwise And

  Syntax: ``ATOMAND dst, resource, offset, src``

  Example: ``ATOMAND TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = dst_i \& src_i


.. opcode:: ATOMOR - Atomic bitwise Or

  Syntax: ``ATOMOR dst, resource, offset, src``

  Example: ``ATOMOR TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = dst_i | src_i


.. opcode:: ATOMXOR - Atomic bitwise Xor

  Syntax: ``ATOMXOR dst, resource, offset, src``

  Example: ``ATOMXOR TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = dst_i \oplus src_i


.. opcode:: ATOMUMIN - Atomic unsigned minimum

  Syntax: ``ATOMUMIN dst, resource, offset, src``

  Example: ``ATOMUMIN TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i < src_i ? dst_i : src_i)


.. opcode:: ATOMUMAX - Atomic unsigned maximum

  Syntax: ``ATOMUMAX dst, resource, offset, src``

  Example: ``ATOMUMAX TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i > src_i ? dst_i : src_i)


.. opcode:: ATOMIMIN - Atomic signed minimum

  Syntax: ``ATOMIMIN dst, resource, offset, src``

  Example: ``ATOMIMIN TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i < src_i ? dst_i : src_i)


.. opcode:: ATOMIMAX - Atomic signed maximum

  Syntax: ``ATOMIMAX dst, resource, offset, src``

  Example: ``ATOMIMAX TEMP[0], RES[0], TEMP[1], TEMP[2]``

  The following operation is performed atomically on each component:

.. math::

  dst_i = resource[offset]_i

  resource[offset]_i = (dst_i > src_i ? dst_i : src_i)



d1269 3
a1271 5
The Local flag specifies that a given value isn't intended for
subroutine parameter passing and, as a result, the implementation
isn't required to give any guarantees of it being preserved across
subroutine boundaries.  As it's merely a compiler hint, the
implementation is free to ignore it.
d1277 5
a1281 5
If Interpolate flag is set to 1, a Declaration Interpolate token follows.

If file is TGSI_FILE_RESOURCE, a Declaration Resource token follows.

If Array flag is set to 1, a Declaration Array token follows.
a1282 16
Array Declaration
^^^^^^^^^^^^^^^^^^^^^^^^

Declarations can optional have an ArrayID attribute which can be referred by
indirect addressing operands. An ArrayID of zero is reserved and treaded as
if no ArrayID is specified.

If an indirect addressing operand refers to a specific declaration by using
an ArrayID only the registers in this declaration are guaranteed to be
accessed, accessing any register outside this declaration results in undefined
behavior. Note that for compatibility the effective index is zero-based and
not relative to the specified declaration

If no ArrayID is specified with an indirect addressing operand the whole
register file might be accessed by this operand. This is strongly discouraged
and will prevent packing of scalar/vec2 arrays and effective alias analysis.
a1380 29
TGSI_SEMANTIC_TEXCOORD
""""""""""""""""""""""

Only available if PIPE_CAP_TGSI_TEXCOORD is exposed !

Vertex shader outputs and fragment shader inputs may be labeled with
this semantic to make them replaceable by sprite coordinates via the
sprite_coord_enable state in the :ref:`rasterizer`.
The semantic index permitted with this semantic is limited to <= 7.

If the driver does not support TEXCOORD, sprite coordinate replacement
applies to inputs with the GENERIC semantic instead.

The intended use case for this semantic is gl_TexCoord.


TGSI_SEMANTIC_PCOORD
""""""""""""""""""""

Only available if PIPE_CAP_TGSI_TEXCOORD is exposed !

Fragment shader inputs may be labeled with TGSI_SEMANTIC_PCOORD to indicate
that the register contains sprite coordinates in the form (x, y, 0, 1), if
the current primitive is a point and point sprites are enabled. Otherwise,
the contents of the register are undefined.

The intended use case for this semantic is gl_PointCoord.


a1417 1

d1419 1
a1419 1
"""""""""""""""""""""
d1421 1
a1421 1
For fragment shaders, this semantic label indicates that an output
a1425 111
TGSI_SEMANTIC_VIEWPORT_INDEX
""""""""""""""""""""""""""""

For geometry shaders, this semantic label indicates that an output
contains the index of the viewport (and scissor) to use.
Only the X value is used.


TGSI_SEMANTIC_LAYER
"""""""""""""""""""

For geometry shaders, this semantic label indicates that an output
contains the layer value to use for the color and depth/stencil surfaces.
Only the X value is used. (Also known as rendertarget array index.)


TGSI_SEMANTIC_CULLDIST
""""""""""""""""""""""

Used as distance to plane for performing application-defined culling
of individual primitives against a plane. When components of vertex
elements are given this label, these values are assumed to be a
float32 signed distance to a plane. Primitives will be completely
discarded if the plane distance for all of the vertices in the
primitive are < 0. If a vertex has a cull distance of NaN, that
vertex counts as "out" (as if its < 0);
The limits on both clip and cull distances are bound
by the PIPE_MAX_CLIP_OR_CULL_DISTANCE_COUNT define which defines
the maximum number of components that can be used to hold the
distances and by the PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT
which specifies the maximum number of registers which can be
annotated with those semantics.


TGSI_SEMANTIC_CLIPDIST
""""""""""""""""""""""

When components of vertex elements are identified this way, these
values are each assumed to be a float32 signed distance to a plane.
Primitive setup only invokes rasterization on pixels for which
the interpolated plane distances are >= 0. Multiple clip planes
can be implemented simultaneously, by annotating multiple
components of one or more vertex elements with the above specified
semantic. The limits on both clip and cull distances are bound
by the PIPE_MAX_CLIP_OR_CULL_DISTANCE_COUNT define which defines
the maximum number of components that can be used to hold the
distances and by the PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT
which specifies the maximum number of registers which can be
annotated with those semantics.


Declaration Interpolate
^^^^^^^^^^^^^^^^^^^^^^^

This token is only valid for fragment shader INPUT declarations.

The Interpolate field specifes the way input is being interpolated by
the rasteriser and is one of TGSI_INTERPOLATE_*.

The CylindricalWrap bitfield specifies which register components
should be subject to cylindrical wrapping when interpolating by the
rasteriser. If TGSI_CYLINDRICAL_WRAP_X is set to 1, the X component
should be interpolated according to cylindrical wrapping rules.


Declaration Sampler View
^^^^^^^^^^^^^^^^^^^^^^^^

   Follows Declaration token if file is TGSI_FILE_SAMPLER_VIEW.

   DCL SVIEW[#], resource, type(s)

   Declares a shader input sampler view and assigns it to a SVIEW[#]
   register.

   resource can be one of BUFFER, 1D, 2D, 3D, 1DArray and 2DArray.

   type must be 1 or 4 entries (if specifying on a per-component
   level) out of UNORM, SNORM, SINT, UINT and FLOAT.


Declaration Resource
^^^^^^^^^^^^^^^^^^^^

   Follows Declaration token if file is TGSI_FILE_RESOURCE.

   DCL RES[#], resource [, WR] [, RAW]

   Declares a shader input resource and assigns it to a RES[#]
   register.

   resource can be one of BUFFER, 1D, 2D, 3D, CUBE, 1DArray and
   2DArray.

   If the RAW keyword is not specified, the texture data will be
   subject to conversion, swizzling and scaling as required to yield
   the specified data type from the physical data format of the bound
   resource.

   If the RAW keyword is specified, no channel conversion will be
   performed: the values read for each of the channels (X,Y,Z,W) will
   correspond to consecutive words in the same order and format
   they're found in memory.  No element-to-address conversion will be
   performed either: the value of the provided X coordinate will be
   interpreted in byte units instead of texel units.  The result of
   accessing a misaligned address is undefined.

   Usage of the STORE opcode is only allowed if the WR (writable) flag
   is set.


d1458 1
a1458 1
rasterization, which is instead controlled by half_pixel_center in the
a1466 16
FS_COLOR0_WRITES_ALL_CBUFS
""""""""""""""""""""""""""
Specifies that writes to the fragment shader color 0 are replicated to all
bound cbufs. This facilitates OpenGL's fragColor output vs fragData[0] where
fragData is directed to a single color buffer, but fragColor is broadcast.

VS_PROHIBIT_UCPS
""""""""""""""""""""""""""
If this property is set on the program bound to the shader stage before the
fragment shader, user clip planes should have no effect (be disabled) even if
that shader does not write to any clip distance outputs and the rasterizer's
clip_plane_enable is non-zero.
This property is only supported by drivers that also support shader clip
distance outputs.
This is useful for APIs that don't have UCPs and where clip distances written
by a shader cannot be disabled.
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d20 1
a20 1
two-component vectors with double precision; see :ref:`doubleopcodes`.
d77 7
a83 4
  dst.x &= 1 \\
  dst.y &= max(src.x, 0) \\
  dst.z &= (src.x > 0) ? max(src.y, 0)^{clamp(src.w, -128, 128))} : 0 \\
  dst.w &= 1
d117 7
a123 4
  dst.x &= 2^{\lfloor src.x\rfloor} \\
  dst.y &= src.x - \lfloor src.x\rfloor \\
  dst.z &= 2^{src.x} \\
  dst.w &= 1
d130 7
a136 4
  dst.x &= \lfloor\log_2{|src.x|}\rfloor \\
  dst.y &= \frac{|src.x|}{2^{\lfloor\log_2{|src.x|}\rfloor}} \\
  dst.z &= \log_2{|src.x|} \\
  dst.w &= 1
d187 7
a193 4
  dst.x &= 1\\
  dst.y &= src0.y \times src1.y\\
  dst.z &= src0.z\\
  dst.w &= src1.w
d226 1
a226 1
  dst.x = (src0.x < src1.x) ? 1.0F : 0.0F
d228 1
a228 1
  dst.y = (src0.y < src1.y) ? 1.0F : 0.0F
d230 1
a230 1
  dst.z = (src0.z < src1.z) ? 1.0F : 0.0F
d232 1
a232 1
  dst.w = (src0.w < src1.w) ? 1.0F : 0.0F
d239 1
a239 1
  dst.x = (src0.x >= src1.x) ? 1.0F : 0.0F
d241 1
a241 1
  dst.y = (src0.y >= src1.y) ? 1.0F : 0.0F
d243 1
a243 1
  dst.z = (src0.z >= src1.z) ? 1.0F : 0.0F
d245 1
a245 1
  dst.w = (src0.w >= src1.w) ? 1.0F : 0.0F
d427 1
a427 1
  dst = (1 / src.x) > 0 ? clamp(1 / src.x, 5.42101e-020, 1.84467e+019) : clamp(1 / src.x, -1.84467e+019, -5.42101e-020)
d515 1
a515 1
  dst.x = (src0.x == src1.x) ? 1.0F : 0.0F
d517 1
a517 1
  dst.y = (src0.y == src1.y) ? 1.0F : 0.0F
d519 1
a519 1
  dst.z = (src0.z == src1.z) ? 1.0F : 0.0F
d521 1
a521 1
  dst.w = (src0.w == src1.w) ? 1.0F : 0.0F
d530 1
a530 1
  dst = 0.0F
d541 1
a541 1
  dst.x = (src0.x > src1.x) ? 1.0F : 0.0F
d543 1
a543 1
  dst.y = (src0.y > src1.y) ? 1.0F : 0.0F
d545 1
a545 1
  dst.z = (src0.z > src1.z) ? 1.0F : 0.0F
d547 1
a547 1
  dst.w = (src0.w > src1.w) ? 1.0F : 0.0F
d563 1
a563 1
  dst.x = (src0.x <= src1.x) ? 1.0F : 0.0F
d565 1
a565 1
  dst.y = (src0.y <= src1.y) ? 1.0F : 0.0F
d567 1
a567 1
  dst.z = (src0.z <= src1.z) ? 1.0F : 0.0F
d569 1
a569 1
  dst.w = (src0.w <= src1.w) ? 1.0F : 0.0F
d576 1
a576 1
  dst.x = (src0.x != src1.x) ? 1.0F : 0.0F
d578 1
a578 1
  dst.y = (src0.y != src1.y) ? 1.0F : 0.0F
d580 1
a580 1
  dst.z = (src0.z != src1.z) ? 1.0F : 0.0F
d582 1
a582 1
  dst.w = (src0.w != src1.w) ? 1.0F : 0.0F
d591 1
a591 1
  dst = 1.0F
d596 8
a605 1

a607 1

a610 1

a615 8
.. math::

  coord = src0

  bias = 0.0

  dst = texture\_sample(unit, coord, bias)

d628 1
a628 1
  dst = texture\_sample\_deriv(unit, coord, bias, ddx, ddy)
d645 1
a645 1
  dst = texture\_sample(unit, coord, bias)
d787 1
a787 1
  dst = texture\_sample(unit, coord, bias)
d839 1
a839 1
  dst = texture\_sample(unit, coord, lod)
d961 17
a977 16
.. opcode:: TXF - Texel Fetch

  As per NV_gpu_shader4, extract a single texel from a specified texture
  image. The source sampler may not be a CUBE or SHADOW.  src 0 is a
  four-component signed integer vector used to identify the single texel
  accessed. 3 components + level.  src 1 is a 3 component constant signed
  integer vector, with each component only have a range of -8..+8 (hw only
  seems to deal with this range, interface allows for up to unsigned int).
  TXF(uint_vec coord, int_vec offset).


.. opcode:: TXQ - Texture Size Query

  As per NV_gpu_program4, retrieve the dimensions of the texture depending on
  the target. For 1D (width), 2D/RECT/CUBE (width, height), 3D (width, height,
  depth), 1D array (width, layers), 2D array (width, height, layers)
d983 1
a983 39
  dst.x = texture\_width(unit, lod)

  dst.y = texture\_height(unit, lod)

  dst.z = texture\_depth(unit, lod)

.. opcode:: TG4 - Texture Gather

  As per ARB_texture_gather, gathers the four texels to be used in a bi-linear
  filtering operation and packs them into a single register.  Only works with
  2D, 2D array, cubemaps, and cubemaps arrays.  For 2D textures, only the
  addressing modes of the sampler and the top level of any mip pyramid are
  used. Set W to zero.  It behaves like the TEX instruction, but a filtered
  sample is not generated. The four samples that contribute to filtering are
  placed into xyzw in clockwise order, starting with the (u,v) texture
  coordinate delta at the following locations (-, +), (+, +), (+, -), (-, -),
  where the magnitude of the deltas are half a texel.

  PIPE_CAP_TEXTURE_SM5 enhances this instruction to support shadow per-sample
  depth compares, single component selection, and a non-constant offset. It
  doesn't allow support for the GL independent offset to get i0,j0. This would
  require another CAP is hw can do it natively. For now we lower that before
  TGSI.

.. math::

   coord = src0

   component = src1

   dst = texture\_gather4 (unit, coord, component)

(with SM5 - cube array shadow)

.. math::

   coord = src0

   compare = src1
d985 1
a985 1
   dst = texture\_gather (uint, coord, compare)
d987 1
a987 1
.. opcode:: LODQ - level of detail query
a988 10
   Compute the LOD information that the texture pipe would use to access the
   texture. The Y component contains the computed LOD lambda_prime. The X
   component contains the LOD that will be accessed, based on min/max lod's
   and mipmap filters.

.. math::

   coord = src0

   dst.xy = lodq(uint, coord);
a1105 30
.. opcode:: IMUL_HI - Signed Integer Multiply High Bits

   The high 32bits of the multiplication of 2 signed integers are returned.

.. math::

  dst.x = (src0.x \times src1.x) >> 32

  dst.y = (src0.y \times src1.y) >> 32

  dst.z = (src0.z \times src1.z) >> 32

  dst.w = (src0.w \times src1.w) >> 32


.. opcode:: UMUL_HI - Unsigned Integer Multiply High Bits

   The high 32bits of the multiplication of 2 unsigned integers are returned.

.. math::

  dst.x = (src0.x \times src1.x) >> 32

  dst.y = (src0.y \times src1.y) >> 32

  dst.z = (src0.z \times src1.z) >> 32

  dst.w = (src0.w \times src1.w) >> 32


d1155 1
a1155 1
  dst.x = \sim src.x
d1157 1
a1157 1
  dst.y = \sim src.y
d1159 1
a1159 1
  dst.z = \sim src.z
d1161 1
a1161 1
  dst.w = \sim src.w
d1168 1
a1168 1
  dst.x = src0.x \& src1.x
d1170 1
a1170 1
  dst.y = src0.y \& src1.y
d1172 1
a1172 1
  dst.z = src0.z \& src1.z
d1174 1
a1174 1
  dst.w = src0.w \& src1.w
a1256 2
   The shift count is masked with 0x1f before the shift is applied.

d1259 1
a1259 1
  dst.x = src0.x << (0x1f \& src1.x)
d1261 1
a1261 1
  dst.y = src0.y << (0x1f \& src1.y)
d1263 1
a1263 1
  dst.z = src0.z << (0x1f \& src1.z)
d1265 1
a1265 1
  dst.w = src0.w << (0x1f \& src1.w)
a1269 2
   The shift count is masked with 0x1f before the shift is applied.

d1272 1
a1272 1
  dst.x = src0.x >> (0x1f \& src1.x)
d1274 1
a1274 1
  dst.y = src0.y >> (0x1f \& src1.y)
d1276 1
a1276 1
  dst.z = src0.z >> (0x1f \& src1.z)
d1278 1
a1278 1
  dst.w = src0.w >> (0x1f \& src1.w)
a1282 2
   The shift count is masked with 0x1f before the shift is applied.

d1285 1
a1285 1
  dst.x = src0.x >> (unsigned) (0x1f \& src1.x)
d1287 1
a1287 1
  dst.y = src0.y >> (unsigned) (0x1f \& src1.y)
d1289 1
a1289 1
  dst.z = src0.z >> (unsigned) (0x1f \& src1.z)
d1291 1
a1291 1
  dst.w = src0.w >> (unsigned) (0x1f \& src1.w)
a1321 15
.. opcode:: FSLT - Float Set On Less Than (ordered)

   Same comparison as SLT but returns integer instead of 1.0/0.0 float

.. math::

  dst.x = (src0.x < src1.x) ? \sim 0 : 0

  dst.y = (src0.y < src1.y) ? \sim 0 : 0

  dst.z = (src0.z < src1.z) ? \sim 0 : 0

  dst.w = (src0.w < src1.w) ? \sim 0 : 0


d1326 1
a1326 1
  dst.x = (src0.x < src1.x) ? \sim 0 : 0
d1328 1
a1328 1
  dst.y = (src0.y < src1.y) ? \sim 0 : 0
d1330 1
a1330 1
  dst.z = (src0.z < src1.z) ? \sim 0 : 0
d1332 1
a1332 1
  dst.w = (src0.w < src1.w) ? \sim 0 : 0
d1339 1
a1339 16
  dst.x = (src0.x < src1.x) ? \sim 0 : 0

  dst.y = (src0.y < src1.y) ? \sim 0 : 0

  dst.z = (src0.z < src1.z) ? \sim 0 : 0

  dst.w = (src0.w < src1.w) ? \sim 0 : 0


.. opcode:: FSGE - Float Set On Greater Equal Than (ordered)

   Same comparison as SGE but returns integer instead of 1.0/0.0 float

.. math::

  dst.x = (src0.x >= src1.x) ? \sim 0 : 0
d1341 1
a1341 1
  dst.y = (src0.y >= src1.y) ? \sim 0 : 0
d1343 1
a1343 1
  dst.z = (src0.z >= src1.z) ? \sim 0 : 0
d1345 1
a1345 1
  dst.w = (src0.w >= src1.w) ? \sim 0 : 0
d1352 1
a1352 1
  dst.x = (src0.x >= src1.x) ? \sim 0 : 0
d1354 1
a1354 1
  dst.y = (src0.y >= src1.y) ? \sim 0 : 0
d1356 1
a1356 1
  dst.z = (src0.z >= src1.z) ? \sim 0 : 0
d1358 1
a1358 1
  dst.w = (src0.w >= src1.w) ? \sim 0 : 0
d1365 1
a1365 16
  dst.x = (src0.x >= src1.x) ? \sim 0 : 0

  dst.y = (src0.y >= src1.y) ? \sim 0 : 0

  dst.z = (src0.z >= src1.z) ? \sim 0 : 0

  dst.w = (src0.w >= src1.w) ? \sim 0 : 0


.. opcode:: FSEQ - Float Set On Equal (ordered)

   Same comparison as SEQ but returns integer instead of 1.0/0.0 float

.. math::

  dst.x = (src0.x == src1.x) ? \sim 0 : 0
d1367 1
a1367 1
  dst.y = (src0.y == src1.y) ? \sim 0 : 0
d1369 1
a1369 1
  dst.z = (src0.z == src1.z) ? \sim 0 : 0
d1371 1
a1371 1
  dst.w = (src0.w == src1.w) ? \sim 0 : 0
d1378 1
a1378 16
  dst.x = (src0.x == src1.x) ? \sim 0 : 0

  dst.y = (src0.y == src1.y) ? \sim 0 : 0

  dst.z = (src0.z == src1.z) ? \sim 0 : 0

  dst.w = (src0.w == src1.w) ? \sim 0 : 0


.. opcode:: FSNE - Float Set On Not Equal (unordered)

   Same comparison as SNE but returns integer instead of 1.0/0.0 float

.. math::

  dst.x = (src0.x != src1.x) ? \sim 0 : 0
d1380 1
a1380 1
  dst.y = (src0.y != src1.y) ? \sim 0 : 0
d1382 1
a1382 1
  dst.z = (src0.z != src1.z) ? \sim 0 : 0
d1384 1
a1384 1
  dst.w = (src0.w != src1.w) ? \sim 0 : 0
d1391 1
a1391 1
  dst.x = (src0.x != src1.x) ? \sim 0 : 0
d1393 1
a1393 1
  dst.y = (src0.y != src1.y) ? \sim 0 : 0
d1395 1
a1395 1
  dst.z = (src0.z != src1.z) ? \sim 0 : 0
d1397 1
a1397 1
  dst.w = (src0.w != src1.w) ? \sim 0 : 0
a1426 75
Bitwise ISA
^^^^^^^^^^^
These opcodes are used for bit-level manipulation of integers.

.. opcode:: IBFE - Signed Bitfield Extract

  See SM5 instruction of the same name. Extracts a set of bits from the input,
  and sign-extends them if the high bit of the extracted window is set.

  Pseudocode::

    def ibfe(value, offset, bits):
      offset = offset & 0x1f
      bits = bits & 0x1f
      if bits == 0: return 0
      # Note: >> sign-extends
      if width + offset < 32:
        return (value << (32 - offset - bits)) >> (32 - bits)
      else:
        return value >> offset

.. opcode:: UBFE - Unsigned Bitfield Extract

  See SM5 instruction of the same name. Extracts a set of bits from the input,
  without any sign-extension.

  Pseudocode::

    def ubfe(value, offset, bits):
      offset = offset & 0x1f
      bits = bits & 0x1f
      if bits == 0: return 0
      # Note: >> does not sign-extend
      if width + offset < 32:
        return (value << (32 - offset - bits)) >> (32 - bits)
      else:
        return value >> offset

.. opcode:: BFI - Bitfield Insert

  See SM5 instruction of the same name. Replaces a bit region of 'base' with
  the low bits of 'insert'.

  Pseudocode::

    def bfi(base, insert, offset, bits):
      offset = offset & 0x1f
      bits = bits & 0x1f
      mask = ((1 << bits) - 1) << offset
      return ((insert << offset) & mask) | (base & ~mask)

.. opcode:: BREV - Bitfield Reverse

  See SM5 instruction BFREV. Reverses the bits of the argument.

.. opcode:: POPC - Population Count

  See SM5 instruction COUNTBITS. Counts the number of set bits in the argument.

.. opcode:: LSB - Index of lowest set bit

  See SM5 instruction FIRSTBIT_LO. Computes the 0-based index of the first set
  bit of the argument. Returns -1 if none are set.

.. opcode:: IMSB - Index of highest non-sign bit

  See SM5 instruction FIRSTBIT_SHI. Computes the 0-based index of the highest
  non-sign bit of the argument (i.e. highest 0 bit for negative numbers,
  highest 1 bit for positive numbers). Returns -1 if all bits are the same
  (i.e. for inputs 0 and -1).

.. opcode:: UMSB - Index of highest set bit

  See SM5 instruction FIRSTBIT_HI. Computes the 0-based index of the highest
  set bit of the argument. Returns -1 if none are set.
d1558 12
a1569 13
   Example::

     SWITCH src[0].x
     CASE src[0].x
     (some instructions here)
     (optional BRK here)
     DEFAULT
     (some instructions here)
     (optional BRK here)
     CASE src[0].x
     (some instructions here)
     (optional BRK here)
     ENDSWITCH
a1732 61
Note that the swizzle on SVIEW (src1) determines texel swizzling
after lookup.

.. opcode:: SAMPLE

  Using provided address, sample data from the specified texture using the
  filtering mode identified by the gven sampler. The source data may come from
  any resource type other than buffers.

  Syntax: ``SAMPLE dst, address, sampler_view, sampler``

  Example: ``SAMPLE TEMP[0], TEMP[1], SVIEW[0], SAMP[0]``

.. opcode:: SAMPLE_I

  Simplified alternative to the SAMPLE instruction.  Using the provided
  integer address, SAMPLE_I fetches data from the specified sampler view
  without any filtering.  The source data may come from any resource type
  other than CUBE.

  Syntax: ``SAMPLE_I dst, address, sampler_view``

  Example: ``SAMPLE_I TEMP[0], TEMP[1], SVIEW[0]``

  The 'address' is specified as unsigned integers. If the 'address' is out of
  range [0...(# texels - 1)] the result of the fetch is always 0 in all
  components.  As such the instruction doesn't honor address wrap modes, in
  cases where that behavior is desirable 'SAMPLE' instruction should be used.
  address.w always provides an unsigned integer mipmap level. If the value is
  out of the range then the instruction always returns 0 in all components.
  address.yz are ignored for buffers and 1d textures.  address.z is ignored
  for 1d texture arrays and 2d textures.

  For 1D texture arrays address.y provides the array index (also as unsigned
  integer). If the value is out of the range of available array indices
  [0... (array size - 1)] then the opcode always returns 0 in all components.
  For 2D texture arrays address.z provides the array index, otherwise it
  exhibits the same behavior as in the case for 1D texture arrays.  The exact
  semantics of the source address are presented in the table below:

  +---------------------------+----+-----+-----+---------+
  | resource type             | X  |  Y  |  Z  |    W    |
  +===========================+====+=====+=====+=========+
  | ``PIPE_BUFFER``           | x  |     |     | ignored |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_1D``       | x  |     |     |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_2D``       | x  |  y  |     |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_3D``       | x  |  y  |  z  |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_RECT``     | x  |  y  |     |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_CUBE``     | not allowed as source    |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_1D_ARRAY`` | x  | idx |     |   mpl   |
  +---------------------------+----+-----+-----+---------+
  | ``PIPE_TEXTURE_2D_ARRAY`` | x  |  y  | idx |   mpl   |
  +---------------------------+----+-----+-----+---------+

  Where 'mpl' is a mipmap level and 'idx' is the array index.
d1734 139
a1872 106
.. opcode:: SAMPLE_I_MS

  Just like SAMPLE_I but allows fetch data from multi-sampled surfaces.

  Syntax: ``SAMPLE_I_MS dst, address, sampler_view, sample``

.. opcode:: SAMPLE_B

  Just like the SAMPLE instruction with the exception that an additional bias
  is applied to the level of detail computed as part of the instruction
  execution.

  Syntax: ``SAMPLE_B dst, address, sampler_view, sampler, lod_bias``

  Example: ``SAMPLE_B TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2].x``

.. opcode:: SAMPLE_C

  Similar to the SAMPLE instruction but it performs a comparison filter. The
  operands to SAMPLE_C are identical to SAMPLE, except that there is an
  additional float32 operand, reference value, which must be a register with
  single-component, or a scalar literal.  SAMPLE_C makes the hardware use the
  current samplers compare_func (in pipe_sampler_state) to compare reference
  value against the red component value for the surce resource at each texel
  that the currently configured texture filter covers based on the provided
  coordinates.

  Syntax: ``SAMPLE_C dst, address, sampler_view.r, sampler, ref_value``

  Example: ``SAMPLE_C TEMP[0], TEMP[1], SVIEW[0].r, SAMP[0], TEMP[2].x``

.. opcode:: SAMPLE_C_LZ

  Same as SAMPLE_C, but LOD is 0 and derivatives are ignored. The LZ stands
  for level-zero.

  Syntax: ``SAMPLE_C_LZ dst, address, sampler_view.r, sampler, ref_value``

  Example: ``SAMPLE_C_LZ TEMP[0], TEMP[1], SVIEW[0].r, SAMP[0], TEMP[2].x``


.. opcode:: SAMPLE_D

  SAMPLE_D is identical to the SAMPLE opcode except that the derivatives for
  the source address in the x direction and the y direction are provided by
  extra parameters.

  Syntax: ``SAMPLE_D dst, address, sampler_view, sampler, der_x, der_y``

  Example: ``SAMPLE_D TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2], TEMP[3]``

.. opcode:: SAMPLE_L

  SAMPLE_L is identical to the SAMPLE opcode except that the LOD is provided
  directly as a scalar value, representing no anisotropy.

  Syntax: ``SAMPLE_L dst, address, sampler_view, sampler, explicit_lod``

  Example: ``SAMPLE_L TEMP[0], TEMP[1], SVIEW[0], SAMP[0], TEMP[2].x``

.. opcode:: GATHER4

  Gathers the four texels to be used in a bi-linear filtering operation and
  packs them into a single register.  Only works with 2D, 2D array, cubemaps,
  and cubemaps arrays.  For 2D textures, only the addressing modes of the
  sampler and the top level of any mip pyramid are used. Set W to zero.  It
  behaves like the SAMPLE instruction, but a filtered sample is not
  generated. The four samples that contribute to filtering are placed into
  xyzw in counter-clockwise order, starting with the (u,v) texture coordinate
  delta at the following locations (-, +), (+, +), (+, -), (-, -), where the
  magnitude of the deltas are half a texel.


.. opcode:: SVIEWINFO

  Query the dimensions of a given sampler view.  dst receives width, height,
  depth or array size and number of mipmap levels as int4. The dst can have a
  writemask which will specify what info is the caller interested in.

  Syntax: ``SVIEWINFO dst, src_mip_level, sampler_view``

  Example: ``SVIEWINFO TEMP[0], TEMP[1].x, SVIEW[0]``

  src_mip_level is an unsigned integer scalar. If it's out of range then
  returns 0 for width, height and depth/array size but the total number of
  mipmap is still returned correctly for the given sampler view.  The returned
  width, height and depth values are for the mipmap level selected by the
  src_mip_level and are in the number of texels.  For 1d texture array width
  is in dst.x, array size is in dst.y and dst.z is 0. The number of mipmaps is
  still in dst.w.  In contrast to d3d10 resinfo, there's no way in the tgsi
  instruction encoding to specify the return type (float/rcpfloat/uint), hence
  always using uint. Also, unlike the SAMPLE instructions, the swizzle on src1
  resinfo allowing swizzling dst values is ignored (due to the interaction
  with rcpfloat modifier which requires some swizzle handling in the state
  tracker anyway).

.. opcode:: SAMPLE_POS

  Query the position of a given sample.  dst receives float4 (x, y, 0, 0)
  indicated where the sample is located. If the resource is not a multi-sample
  resource and not a render target, the result is 0.

.. opcode:: SAMPLE_INFO

  dst receives number of samples in x.  If the resource is not a multi-sample
  resource and not a render target, the result is 0.
d2245 2
a2246 2
Vertex and fragment shader input and output registers may be labeled
with semantic information consisting of a name and index.
d2248 1
a2248 1
Follows Declaration token if Semantic bit is set.
d2250 3
a2252 3
Since its purpose is to link a shader with other stages of the pipeline,
it is valid to follow only those Declaration tokens that declare a register
either in INPUT or OUTPUT file.
d2254 2
a2255 2
SemanticName field contains the semantic name of the register being declared.
There is no default value.
d2257 3
a2259 3
SemanticIndex is an optional subscript that can be used to distinguish
different register declarations with the same semantic name. The default value
is 0.
d2261 2
a2262 2
The meanings of the individual semantic names are explained in the following
sections.
d2317 7
a2323 4
a fog coordinate.  Typically, the fragment shader will use the fog coordinate
to compute a fog blend factor which is used to blend the normal fragment color
with a constant fog color.  But fog coord really is just an ordinary vec4
register like regular semantics.
a2463 26
TGSI_SEMANTIC_SAMPLEID
""""""""""""""""""""""

For fragment shaders, this semantic label indicates that a system value
contains the current sample id (i.e. gl_SampleID). Only the X value is used.

TGSI_SEMANTIC_SAMPLEPOS
"""""""""""""""""""""""

For fragment shaders, this semantic label indicates that a system value
contains the current sample's position (i.e. gl_SamplePosition). Only the X
and Y values are used.

TGSI_SEMANTIC_SAMPLEMASK
""""""""""""""""""""""""

For fragment shaders, this semantic label indicates that an output contains
the sample mask used to disable further sample processing
(i.e. gl_SampleMask). Only the X value is used, up to 32x MS.

TGSI_SEMANTIC_INVOCATIONID
""""""""""""""""""""""""""

For geometry shaders, this semantic label indicates that a system value
contains the current invocation id (i.e. gl_InvocationID). Only the X value is
used.
d2482 1
a2482 1
Follows Declaration token if file is TGSI_FILE_SAMPLER_VIEW.
d2484 1
a2484 1
DCL SVIEW[#], resource, type(s)
d2486 2
a2487 2
Declares a shader input sampler view and assigns it to a SVIEW[#]
register.
d2489 1
a2489 1
resource can be one of BUFFER, 1D, 2D, 3D, 1DArray and 2DArray.
d2491 2
a2492 2
type must be 1 or 4 entries (if specifying on a per-component
level) out of UNORM, SNORM, SINT, UINT and FLOAT.
d2498 1
a2498 1
Follows Declaration token if file is TGSI_FILE_RESOURCE.
d2500 1
a2500 1
DCL RES[#], resource [, WR] [, RAW]
d2502 2
a2503 2
Declares a shader input resource and assigns it to a RES[#]
register.
d2505 15
a2519 15
resource can be one of BUFFER, 1D, 2D, 3D, CUBE, 1DArray and
2DArray.

If the RAW keyword is not specified, the texture data will be
subject to conversion, swizzling and scaling as required to yield
the specified data type from the physical data format of the bound
resource.

If the RAW keyword is specified, no channel conversion will be
performed: the values read for each of the channels (X,Y,Z,W) will
correspond to consecutive words in the same order and format
they're found in memory.  No element-to-address conversion will be
performed either: the value of the provided X coordinate will be
interpreted in byte units instead of texel units.  The result of
accessing a misaligned address is undefined.
d2521 2
a2522 2
Usage of the STORE opcode is only allowed if the WR (writable) flag
is set.
d2528 2
a2529 1
Properties are general directives that apply to the whole TGSI program.
a2581 8

GS_INVOCATIONS
""""""""""""""

Specifies the number of times a geometry shader should be executed for each
input primitive. Each invocation will have a different
TGSI_SEMANTIC_INVOCATIONID system value set. If not specified, assumed to
be 1.
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d436 1
a436 5
.. opcode:: DDX, DDX_FINE - Derivative Relative To X

The fine variant is only used when ``PIPE_CAP_TGSI_FS_FINE_DERIVATIVE`` is
advertised. When it is, the fine version guarantees one derivative per row
while DDX is allowed to be the same for the entire 2x2 quad.
d449 1
a449 5
.. opcode:: DDY, DDY_FINE - Derivative Relative To Y

The fine variant is only used when ``PIPE_CAP_TGSI_FS_FINE_DERIVATIVE`` is
advertised. When it is, the fine version guarantees one derivative per column
while DDY is allowed to be the same for the entire 2x2 quad.
d587 2
a588 2
  for shadow textures with no arrays (and not cube map),
  src0.z contains the reference value.
d592 1
a592 1
  the reference value for 2D arrays and cube maps.
d594 4
a597 2
  for cube map array shadow textures, the reference value
  cannot be passed in src0.w, and TEX2 must be used instead.
d603 1
a603 23
  shadow_ref = src0.z or src0.w (optional)

  unit = src1

  dst = texture\_sample(unit, coord, shadow_ref)


.. opcode:: TEX2 - Texture Lookup (for shadow cube map arrays only)

  this is the same as TEX, but uses another reg to encode the
  reference value.

.. math::

  coord = src0

  shadow_ref = src1.x

  unit = src2

  dst = texture\_sample(unit, coord, shadow_ref)


d605 1
d617 1
a617 1
  unit = src3
d619 1
a619 1
  dst = texture\_sample\_deriv(unit, coord, ddx, ddy)
d626 1
a626 1
  coord.x = src0.x / src0.w
d628 1
a628 1
  coord.y = src0.y / src0.w
d630 1
a630 1
  coord.z = src0.z / src0.w
d634 1
a634 1
  unit = src1
d636 1
a636 1
  dst = texture\_sample(unit, coord)
a765 7
  for cube map array textures and shadow cube maps, the bias value
  cannot be passed in src0.w, and TXB2 must be used instead.

  if the target is a shadow texture, the reference value is always
  in src.z (this prevents shadow 3d and shadow 2d arrays from
  using this instruction, but this is not needed).

d768 1
a768 13
  coord.x = src0.x

  coord.y = src0.y

  coord.z = src0.z

  coord.w = none

  bias = src0.w

  unit = src1

  dst = texture\_sample(unit, coord, bias)
d770 1
d772 1
a772 1
.. opcode:: TXB2 - Texture Lookup With Bias (some cube maps only)
d774 1
a774 4
  this is the same as TXB, but uses another reg to encode the
  lod bias value for cube map arrays and shadow cube maps.
  Presumably shadow 2d arrays and shadow 3d targets could use
  this encoding too, but this is not legal.
d776 1
a776 9
  shadow cube map arrays are neither possible nor required.

.. math::

  coord = src0

  bias = src1.x

  unit = src2
a783 4
  
  u = src.x \times src.x + src.y \times src.y + src.z \times src.z

  v = \frac{1}{\sqrt{u}}
d785 1
a785 1
  dst.x = src.x \times v
d787 1
a787 1
  dst.y = src.y \times v
d789 1
a789 1
  dst.z = src.z \times v
a793 17
.. opcode:: NRM4 - 4-component Vector Normalise

.. math::
  
  u = src.x \times src.x + src.y \times src.y + src.z \times src.z + src.w \times src.w

  v = \frac{1}{\sqrt{u}}

  dst.x = src.x \times v

  dst.y = src.y \times v

  dst.z = src.z \times v

  dst.w = src.w \times v


a817 7
  for cube map array textures, the explicit lod value
  cannot be passed in src0.w, and TXL2 must be used instead.

  if the target is a shadow texture, the reference value is always
  in src.z (this prevents shadow 3d / 2d array / cube targets from
  using this instruction, but this is not needed).

d826 1
a826 1
  coord.w = none
a829 22
  unit = src1

  dst = texture\_sample(unit, coord, lod)


.. opcode:: TXL2 - Texture Lookup With explicit LOD (for cube map arrays only)

  this is the same as TXL, but uses another reg to encode the
  explicit lod value.
  Presumably shadow 3d / 2d array / cube targets could use
  this encoding too, but this is not legal.

  shadow cube map arrays are neither possible nor required.

.. math::

  coord = src0

  lod = src1.x

  unit = src2

d957 3
a959 3
  accessed. 3 components + level.  Just like texture instructions, an optional
  offset vector is provided, which is subject to various driver restrictions
  (regarding range, source of offsets).
d967 1
a967 7
  depth), 1D array (width, layers), 2D array (width, height, layers).
  Also return the number of accessible levels (last_level - first_level + 1)
  in W.

  For components which don't return a resource dimension, their value
  is undefined.

a978 2
  dst.w = texture\_levels(unit)

d1645 2
a1646 2
  Generate a new vertex for the current primitive into the specified vertex
  stream using the values in the output registers.
d1651 2
a1652 2
  Complete the current primitive in the specified vertex stream (consisting of
  the emitted vertices), and start a new one.
d1798 1
a1798 2
Interpolation ISA
^^^^^^^^^^^^^^^^^
d1800 1
a1800 4
The interpolation instructions allow an input to be interpolated in a
different way than its declaration. This corresponds to the GLSL 4.00
interpolateAt* functions. The first argument of each of these must come from
``TGSI_FILE_INPUT``.
d1802 1
a1802 5
.. opcode:: INTERP_CENTROID - Interpolate at the centroid

   Interpolates the varying specified by src0 at the centroid

.. opcode:: INTERP_SAMPLE - Interpolate at the specified sample
d1804 1
a1804 7
   Interpolates the varying specified by src0 at the sample id specified by
   src1.x (interpreted as an integer)

.. opcode:: INTERP_OFFSET - Interpolate at the specified offset

   Interpolates the varying specified by src0 at the offset src1.xy from the
   pixel center (interpreted as floats)
a2733 5
The Location field specifies the location inside the pixel that the
interpolation should be done at, one of ``TGSI_INTERPOLATE_LOC_*``. Note that
when per-sample shading is enabled, the implementation may choose to
interpolate at the sample irrespective of the Location field.

a2850 9
VS_WINDOW_SPACE_POSITION
""""""""""""""""""""""""""
If this property is set on the vertex shader, the TGSI_SEMANTIC_POSITION output
is assumed to contain window space coordinates.
Division of X,Y,Z by W and the viewport transformation are disabled, and 1/W is
directly taken from the 4-th component of the shader output.
Naturally, clipping is not performed on window coordinates either.
The effect of this property is undefined if a geometry or tessellation shader
are in use.
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d436 5
a440 1
.. opcode:: DDX - Derivative Relative To X
d453 5
a457 1
.. opcode:: DDY - Derivative Relative To Y
d595 2
a596 2
  for shadow textures with no arrays, src0.z contains
  the reference value.
d600 1
a600 1
  the reference value for 2D arrays.
d602 2
a603 4
  There is no way to pass a bias in the .w value for
  shadow arrays, and GLSL doesn't allow this.
  GLSL does allow cube shadows maps to take a bias value,
  and we have to determine how this will look in TGSI.
d609 23
a631 1
  bias = 0.0
a632 1
  dst = texture\_sample(unit, coord, bias)
d644 1
a644 1
  bias = 0.0
d646 1
a646 1
  dst = texture\_sample\_deriv(unit, coord, bias, ddx, ddy)
d653 1
a653 1
  coord.x = src0.x / src.w
d655 1
a655 1
  coord.y = src0.y / src.w
d657 1
a657 1
  coord.z = src0.z / src.w
d661 1
a661 1
  bias = 0.0
d663 1
a663 1
  dst = texture\_sample(unit, coord, bias)
d793 7
d802 13
a814 1
  coord.x = src.x
a815 1
  coord.y = src.y
d817 1
a817 1
  coord.z = src.z
d819 4
a822 1
  coord.w = 1.0
d824 9
a832 1
  bias = src.z
d840 4
d845 1
a845 1
  dst.x = src.x / (src.x \times src.x + src.y \times src.y + src.z \times src.z)
d847 1
a847 1
  dst.y = src.y / (src.x \times src.x + src.y \times src.y + src.z \times src.z)
d849 1
a849 1
  dst.z = src.z / (src.x \times src.x + src.y \times src.y + src.z \times src.z)
d854 17
d895 7
d910 1
a910 1
  coord.w = 1.0
d914 22
d1063 3
a1065 3
  accessed. 3 components + level.  src 1 is a 3 component constant signed
  integer vector, with each component only have a range of -8..+8 (hw only
  seems to deal with this range, interface allows for up to unsigned int).
d1073 7
a1079 1
  depth), 1D array (width, layers), 2D array (width, height, layers)
d1091 2
d1759 2
a1760 2
  Generate a new vertex for the current primitive using the values in the
  output registers.
d1765 2
a1766 2
  Complete the current primitive (consisting of the emitted vertices),
  and start a new one.
d1912 13
a1924 1
.. opcode:: NRM4 - 4-component Vector Normalise
d1926 2
a1927 1
This instruction replicates its result.
d1929 1
a1929 1
.. math::
d1931 2
a1932 1
  dst = \frac{src.x}{src.x \times src.x + src.y \times src.y + src.z \times src.z + src.w \times src.w}
d2862 5
d2984 9
@


