head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2015.12.23.05.17.29;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.54;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.24;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.00;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.07;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@.. _context:

Context
=======

A Gallium rendering context encapsulates the state which effects 3D
rendering such as blend state, depth/stencil state, texture samplers,
etc.

Note that resource/texture allocation is not per-context but per-screen.


Methods
-------

CSO State
^^^^^^^^^

All Constant State Object (CSO) state is created, bound, and destroyed,
with triplets of methods that all follow a specific naming scheme.
For example, ``create_blend_state``, ``bind_blend_state``, and
``destroy_blend_state``.

CSO objects handled by the context object:

* :ref:`Blend`: ``*_blend_state``
* :ref:`Sampler`: Texture sampler states are bound separately for fragment,
  vertex, geometry and compute shaders with the ``bind_sampler_states``
  function.  The ``start`` and ``num_samplers`` parameters indicate a range
  of samplers to change.  NOTE: at this time, start is always zero and
  the CSO module will always replace all samplers at once (no sub-ranges).
  This may change in the future.
* :ref:`Rasterizer`: ``*_rasterizer_state``
* :ref:`depth-stencil-alpha`: ``*_depth_stencil_alpha_state``
* :ref:`Shader`: These are create, bind and destroy methods for vertex,
  fragment and geometry shaders.
* :ref:`vertexelements`: ``*_vertex_elements_state``


Resource Binding State
^^^^^^^^^^^^^^^^^^^^^^

This state describes how resources in various flavours (textures,
buffers, surfaces) are bound to the driver.


* ``set_constant_buffer`` sets a constant buffer to be used for a given shader
  type. index is used to indicate which buffer to set (some apis may allow
  multiple ones to be set, and binding a specific one later, though drivers
  are mostly restricted to the first one right now).

* ``set_framebuffer_state``

* ``set_vertex_buffers``

* ``set_index_buffer``


Non-CSO State
^^^^^^^^^^^^^

These pieces of state are too small, variable, and/or trivial to have CSO
objects. They all follow simple, one-method binding calls, e.g.
``set_blend_color``.

* ``set_stencil_ref`` sets the stencil front and back reference values
  which are used as comparison values in stencil test.
* ``set_blend_color``
* ``set_sample_mask``
* ``set_min_samples`` sets the minimum number of samples that must be run.
* ``set_clip_state``
* ``set_polygon_stipple``
* ``set_scissor_states`` sets the bounds for the scissor test, which culls
  pixels before blending to render targets. If the :ref:`Rasterizer` does
  not have the scissor test enabled, then the scissor bounds never need to
  be set since they will not be used.  Note that scissor xmin and ymin are
  inclusive, but  xmax and ymax are exclusive.  The inclusive ranges in x
  and y would be [xmin..xmax-1] and [ymin..ymax-1]. The number of scissors
  should be the same as the number of set viewports and can be up to
  PIPE_MAX_VIEWPORTS.
* ``set_viewport_states``


Sampler Views
^^^^^^^^^^^^^

These are the means to bind textures to shader stages. To create one, specify
its format, swizzle and LOD range in sampler view template.

If texture format is different than template format, it is said the texture
is being cast to another format. Casting can be done only between compatible
formats, that is formats that have matching component order and sizes.

Swizzle fields specify they way in which fetched texel components are placed
in the result register. For example, ``swizzle_r`` specifies what is going to be
placed in first component of result register.

The ``first_level`` and ``last_level`` fields of sampler view template specify
the LOD range the texture is going to be constrained to. Note that these
values are in addition to the respective min_lod, max_lod values in the
pipe_sampler_state (that is if min_lod is 2.0, and first_level 3, the first mip
level used for sampling from the resource is effectively the fifth).

The ``first_layer`` and ``last_layer`` fields specify the layer range the
texture is going to be constrained to. Similar to the LOD range, this is added
to the array index which is used for sampling.

* ``set_sampler_views`` binds an array of sampler views to a shader stage.
  Every binding point acquires a reference
  to a respective sampler view and releases a reference to the previous
  sampler view.

* ``create_sampler_view`` creates a new sampler view. ``texture`` is associated
  with the sampler view which results in sampler view holding a reference
  to the texture. Format specified in template must be compatible
  with texture format.

* ``sampler_view_destroy`` destroys a sampler view and releases its reference
  to associated texture.

Shader Resources
^^^^^^^^^^^^^^^^

Shader resources are textures or buffers that may be read or written
from a shader without an associated sampler.  This means that they
have no support for floating point coordinates, address wrap modes or
filtering.

Shader resources are specified for all the shader stages at once using
the ``set_shader_resources`` method.  When binding texture resources,
the ``level``, ``first_layer`` and ``last_layer`` pipe_surface fields
specify the mipmap level and the range of layers the texture will be
constrained to.  In the case of buffers, ``first_element`` and
``last_element`` specify the range within the buffer that will be used
by the shader resource.  Writes to a shader resource are only allowed
when the ``writable`` flag is set.

Surfaces
^^^^^^^^

These are the means to use resources as color render targets or depthstencil
attachments. To create one, specify the mip level, the range of layers, and
the bind flags (either PIPE_BIND_DEPTH_STENCIL or PIPE_BIND_RENDER_TARGET).
Note that layer values are in addition to what is indicated by the geometry
shader output variable XXX_FIXME (that is if first_layer is 3 and geometry
shader indicates index 2, the 5th layer of the resource will be used). These
first_layer and last_layer parameters will only be used for 1d array, 2d array,
cube, and 3d textures otherwise they are 0.

* ``create_surface`` creates a new surface.

* ``surface_destroy`` destroys a surface and releases its reference to the
  associated resource.

Stream output targets
^^^^^^^^^^^^^^^^^^^^^

Stream output, also known as transform feedback, allows writing the primitives
produced by the vertex pipeline to buffers. This is done after the geometry
shader or vertex shader if no geometry shader is present.

The stream output targets are views into buffer resources which can be bound
as stream outputs and specify a memory range where it's valid to write
primitives. The pipe driver must implement memory protection such that any
primitives written outside of the specified memory range are discarded.

Two stream output targets can use the same resource at the same time, but
with a disjoint memory range.

Additionally, the stream output target internally maintains the offset
into the buffer which is incremented everytime something is written to it.
The internal offset is equal to how much data has already been written.
It can be stored in device memory and the CPU actually doesn't have to query
it.

The stream output target can be used in a draw command to provide
the vertex count. The vertex count is derived from the internal offset
discussed above.

* ``create_stream_output_target`` create a new target.

* ``stream_output_target_destroy`` destroys a target. Users of this should
  use pipe_so_target_reference instead.

* ``set_stream_output_targets`` binds stream output targets. The parameter
  offset is an array which specifies the internal offset of the buffer. The
  internal offset is, besides writing, used for reading the data during the
  draw_auto stage, i.e. it specifies how much data there is in the buffer
  for the purposes of the draw_auto stage. -1 means the buffer should
  be appended to, and everything else sets the internal offset.

NOTE: The currently-bound vertex or geometry shader must be compiled with
the properly-filled-in structure pipe_stream_output_info describing which
outputs should be written to buffers and how. The structure is part of
pipe_shader_state.

Clearing
^^^^^^^^

Clear is one of the most difficult concepts to nail down to a single
interface (due to both different requirements from APIs and also driver/hw
specific differences).

``clear`` initializes some or all of the surfaces currently bound to
the framebuffer to particular RGBA, depth, or stencil values.
Currently, this does not take into account color or stencil write masks (as
used by GL), and always clears the whole surfaces (no scissoring as used by
GL clear or explicit rectangles like d3d9 uses). It can, however, also clear
only depth or stencil in a combined depth/stencil surface.
If a surface includes several layers then all layers will be cleared.

``clear_render_target`` clears a single color rendertarget with the specified
color value. While it is only possible to clear one surface at a time (which can
include several layers), this surface need not be bound to the framebuffer.

``clear_depth_stencil`` clears a single depth, stencil or depth/stencil surface
with the specified depth and stencil values (for combined depth/stencil buffers,
is is also possible to only clear one or the other part). While it is only
possible to clear one surface at a time (which can include several layers),
this surface need not be bound to the framebuffer.

``clear_buffer`` clears a PIPE_BUFFER resource with the specified clear value
(which may be multiple bytes in length). Logically this is a memset with a
multi-byte element value starting at offset bytes from resource start, going
for size bytes. It is guaranteed that size % clear_value_size == 0.


Drawing
^^^^^^^

``draw_vbo`` draws a specified primitive.  The primitive mode and other
properties are described by ``pipe_draw_info``.

The ``mode``, ``start``, and ``count`` fields of ``pipe_draw_info`` specify the
the mode of the primitive and the vertices to be fetched, in the range between
``start`` to ``start``+``count``-1, inclusive.

Every instance with instanceID in the range between ``start_instance`` and
``start_instance``+``instance_count``-1, inclusive, will be drawn.

If there is an index buffer bound, and ``indexed`` field is true, all vertex
indices will be looked up in the index buffer.

In indexed draw, ``min_index`` and ``max_index`` respectively provide a lower
and upper bound of the indices contained in the index buffer inside the range
between ``start`` to ``start``+``count``-1.  This allows the driver to
determine which subset of vertices will be referenced during te draw call
without having to scan the index buffer.  Providing a over-estimation of the
the true bounds, for example, a ``min_index`` and ``max_index`` of 0 and
0xffffffff respectively, must give exactly the same rendering, albeit with less
performance due to unreferenced vertex buffers being unnecessarily DMA'ed or
processed.  Providing a underestimation of the true bounds will result in
undefined behavior, but should not result in program or system failure.

In case of non-indexed draw, ``min_index`` should be set to
``start`` and ``max_index`` should be set to ``start``+``count``-1.

``index_bias`` is a value added to every vertex index after lookup and before
fetching vertex attributes.

When drawing indexed primitives, the primitive restart index can be
used to draw disjoint primitive strips.  For example, several separate
line strips can be drawn by designating a special index value as the
restart index.  The ``primitive_restart`` flag enables/disables this
feature.  The ``restart_index`` field specifies the restart index value.

When primitive restart is in use, array indexes are compared to the
restart index before adding the index_bias offset.

If a given vertex element has ``instance_divisor`` set to 0, it is said
it contains per-vertex data and effective vertex attribute address needs
to be recalculated for every index.

  attribAddr = ``stride`` * index + ``src_offset``

If a given vertex element has ``instance_divisor`` set to non-zero,
it is said it contains per-instance data and effective vertex attribute
address needs to recalculated for every ``instance_divisor``-th instance.

  attribAddr = ``stride`` * instanceID / ``instance_divisor`` + ``src_offset``

In the above formulas, ``src_offset`` is taken from the given vertex element
and ``stride`` is taken from a vertex buffer associated with the given
vertex element.

The calculated attribAddr is used as an offset into the vertex buffer to
fetch the attribute data.

The value of ``instanceID`` can be read in a vertex shader through a system
value register declared with INSTANCEID semantic name.


Queries
^^^^^^^

Queries gather some statistic from the 3D pipeline over one or more
draws.  Queries may be nested, though not all state trackers exercise this.

Queries can be created with ``create_query`` and deleted with
``destroy_query``. To start a query, use ``begin_query``, and when finished,
use ``end_query`` to end the query.

``get_query_result`` is used to retrieve the results of a query.  If
the ``wait`` parameter is TRUE, then the ``get_query_result`` call
will block until the results of the query are ready (and TRUE will be
returned).  Otherwise, if the ``wait`` parameter is FALSE, the call
will not block and the return value will be TRUE if the query has
completed or FALSE otherwise.

The interface currently includes the following types of queries:

``PIPE_QUERY_OCCLUSION_COUNTER`` counts the number of fragments which
are written to the framebuffer without being culled by
:ref:`depth-stencil-alpha` testing or shader KILL instructions.
The result is an unsigned 64-bit integer.
This query can be used with ``render_condition``.

In cases where a boolean result of an occlusion query is enough,
``PIPE_QUERY_OCCLUSION_PREDICATE`` should be used. It is just like
``PIPE_QUERY_OCCLUSION_COUNTER`` except that the result is a boolean
value of FALSE for cases where COUNTER would result in 0 and TRUE
for all other cases.
This query can be used with ``render_condition``.

``PIPE_QUERY_TIME_ELAPSED`` returns the amount of time, in nanoseconds,
the context takes to perform operations.
The result is an unsigned 64-bit integer.

``PIPE_QUERY_TIMESTAMP`` returns a device/driver internal timestamp,
scaled to nanoseconds, recorded after all commands issued prior to
``end_query`` have been processed.
This query does not require a call to ``begin_query``.
The result is an unsigned 64-bit integer.

``PIPE_QUERY_TIMESTAMP_DISJOINT`` can be used to check the
internal timer resolution and whether the timestamp counter has become
unreliable due to things like throttling etc. - only if this is FALSE
a timestamp query (within the timestamp_disjoint query) should be trusted.
The result is a 64-bit integer specifying the timer resolution in Hz,
followed by a boolean value indicating whether the timestamp counter
is discontinuous or disjoint.

``PIPE_QUERY_PRIMITIVES_GENERATED`` returns a 64-bit integer indicating
the number of primitives processed by the pipeline (regardless of whether
stream output is active or not).

``PIPE_QUERY_PRIMITIVES_EMITTED`` returns a 64-bit integer indicating
the number of primitives written to stream output buffers.

``PIPE_QUERY_SO_STATISTICS`` returns 2 64-bit integers corresponding to
the result of
``PIPE_QUERY_PRIMITIVES_EMITTED`` and
the number of primitives that would have been written to stream output buffers
if they had infinite space available (primitives_storage_needed), in this order.
XXX the 2nd value is equivalent to ``PIPE_QUERY_PRIMITIVES_GENERATED`` but it is
unclear if it should be increased if stream output is not active.

``PIPE_QUERY_SO_OVERFLOW_PREDICATE`` returns a boolean value indicating
whether the stream output targets have overflowed as a result of the
commands issued between ``begin_query`` and ``end_query``.
This query can be used with ``render_condition``.

``PIPE_QUERY_GPU_FINISHED`` returns a boolean value indicating whether
all commands issued before ``end_query`` have completed. However, this
does not imply serialization.
This query does not require a call to ``begin_query``.

``PIPE_QUERY_PIPELINE_STATISTICS`` returns an array of the following
64-bit integers:
Number of vertices read from vertex buffers.
Number of primitives read from vertex buffers.
Number of vertex shader threads launched.
Number of geometry shader threads launched.
Number of primitives generated by geometry shaders.
Number of primitives forwarded to the rasterizer.
Number of primitives rasterized.
Number of fragment shader threads launched.
Number of tessellation control shader threads launched.
Number of tessellation evaluation shader threads launched.
If a shader type is not supported by the device/driver,
the corresponding values should be set to 0.

Gallium does not guarantee the availability of any query types; one must
always check the capabilities of the :ref:`Screen` first.


Conditional Rendering
^^^^^^^^^^^^^^^^^^^^^

A drawing command can be skipped depending on the outcome of a query
(typically an occlusion query, or streamout overflow predicate).
The ``render_condition`` function specifies the query which should be checked
prior to rendering anything. Functions honoring render_condition include
(and are limited to) draw_vbo, clear, clear_render_target, clear_depth_stencil.

If ``render_condition`` is called with ``query`` = NULL, conditional
rendering is disabled and drawing takes place normally.

If ``render_condition`` is called with a non-null ``query`` subsequent
drawing commands will be predicated on the outcome of the query.
Commands will be skipped if ``condition`` is equal to the predicate result
(for non-boolean queries such as OCCLUSION_QUERY, zero counts as FALSE,
non-zero as TRUE).

If ``mode`` is PIPE_RENDER_COND_WAIT the driver will wait for the
query to complete before deciding whether to render.

If ``mode`` is PIPE_RENDER_COND_NO_WAIT and the query has not yet
completed, the drawing command will be executed normally.  If the query
has completed, drawing will be predicated on the outcome of the query.

If ``mode`` is PIPE_RENDER_COND_BY_REGION_WAIT or
PIPE_RENDER_COND_BY_REGION_NO_WAIT rendering will be predicated as above
for the non-REGION modes but in the case that an occlusion query returns
a non-zero result, regions which were occluded may be ommitted by subsequent
drawing commands.  This can result in better performance with some GPUs.
Normally, if the occlusion query returned a non-zero result subsequent
drawing happens normally so fragments may be generated, shaded and
processed even where they're known to be obscured.


Flushing
^^^^^^^^

``flush``


``flush_resource``

Flush the resource cache, so that the resource can be used
by an external client. Possible usage:
- flushing a resource before presenting it on the screen
- flushing a resource if some other process or device wants to use it
This shouldn't be used to flush caches if the resource is only managed
by a single pipe_screen and is not shared with another process.
(i.e. you shouldn't use it to flush caches explicitly if you want to e.g.
use the resource for texturing)



Resource Busy Queries
^^^^^^^^^^^^^^^^^^^^^

``is_resource_referenced``



Blitting
^^^^^^^^

These methods emulate classic blitter controls.

These methods operate directly on ``pipe_resource`` objects, and stand
apart from any 3D state in the context.  Blitting functionality may be
moved to a separate abstraction at some point in the future.

``resource_copy_region`` blits a region of a resource to a region of another
resource, provided that both resources have the same format, or compatible
formats, i.e., formats for which copying the bytes from the source resource
unmodified to the destination resource will achieve the same effect of a
textured quad blitter.. The source and destination may be the same resource,
but overlapping blits are not permitted.
This can be considered the equivalent of a CPU memcpy.

``blit`` blits a region of a resource to a region of another resource, including
scaling, format conversion, and up-/downsampling, as well as
a destination clip rectangle (scissors).
As opposed to manually drawing a textured quad, this lets the pipe driver choose
the optimal method for blitting (like using a special 2D engine), and usually
offers, for example, accelerated stencil-only copies even where
PIPE_CAP_SHADER_STENCIL_EXPORT is not available.


Transfers
^^^^^^^^^

These methods are used to get data to/from a resource.

``transfer_map`` creates a memory mapping and the transfer object
associated with it.
The returned pointer points to the start of the mapped range according to
the box region, not the beginning of the resource. If transfer_map fails,
the returned pointer to the buffer memory is NULL, and the pointer
to the transfer object remains unchanged (i.e. it can be non-NULL).

``transfer_unmap`` remove the memory mapping for and destroy
the transfer object. The pointer into the resource should be considered
invalid and discarded.

``transfer_inline_write`` performs a simplified transfer for simple writes.
Basically transfer_map, data write, and transfer_unmap all in one.


The box parameter to some of these functions defines a 1D, 2D or 3D
region of pixels.  This is self-explanatory for 1D, 2D and 3D texture
targets.

For PIPE_TEXTURE_1D_ARRAY and PIPE_TEXTURE_2D_ARRAY, the box::z and box::depth
fields refer to the array dimension of the texture.

For PIPE_TEXTURE_CUBE, the box:z and box::depth fields refer to the
faces of the cube map (z + depth <= 6).

For PIPE_TEXTURE_CUBE_ARRAY, the box:z and box::depth fields refer to both
the face and array dimension of the texture (face = z % 6, array = z / 6).


.. _transfer_flush_region:

transfer_flush_region
%%%%%%%%%%%%%%%%%%%%%

If a transfer was created with ``FLUSH_EXPLICIT``, it will not automatically
be flushed on write or unmap. Flushes must be requested with
``transfer_flush_region``. Flush ranges are relative to the mapped range, not
the beginning of the resource.



.. _texture_barrier:

texture_barrier
%%%%%%%%%%%%%%%

This function flushes all pending writes to the currently-set surfaces and
invalidates all read caches of the currently-set samplers.



.. _memory_barrier:

memory_barrier
%%%%%%%%%%%%%%%

This function flushes caches according to which of the PIPE_BARRIER_* flags
are set.



.. _pipe_transfer:

PIPE_TRANSFER
^^^^^^^^^^^^^

These flags control the behavior of a transfer object.

``PIPE_TRANSFER_READ``
  Resource contents read back (or accessed directly) at transfer create time.

``PIPE_TRANSFER_WRITE``
  Resource contents will be written back at transfer_unmap time (or modified
  as a result of being accessed directly).

``PIPE_TRANSFER_MAP_DIRECTLY``
  a transfer should directly map the resource. May return NULL if not supported.

``PIPE_TRANSFER_DISCARD_RANGE``
  The memory within the mapped region is discarded.  Cannot be used with
  ``PIPE_TRANSFER_READ``.

``PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE``
  Discards all memory backing the resource.  It should not be used with
  ``PIPE_TRANSFER_READ``.

``PIPE_TRANSFER_DONTBLOCK``
  Fail if the resource cannot be mapped immediately.

``PIPE_TRANSFER_UNSYNCHRONIZED``
  Do not synchronize pending operations on the resource when mapping. The
  interaction of any writes to the map and any operations pending on the
  resource are undefined. Cannot be used with ``PIPE_TRANSFER_READ``.

``PIPE_TRANSFER_FLUSH_EXPLICIT``
  Written ranges will be notified later with :ref:`transfer_flush_region`.
  Cannot be used with ``PIPE_TRANSFER_READ``.

``PIPE_TRANSFER_PERSISTENT``
  Allows the resource to be used for rendering while mapped.
  PIPE_RESOURCE_FLAG_MAP_PERSISTENT must be set when creating
  the resource.
  If COHERENT is not set, memory_barrier(PIPE_BARRIER_MAPPED_BUFFER)
  must be called to ensure the device can see what the CPU has written.

``PIPE_TRANSFER_COHERENT``
  If PERSISTENT is set, this ensures any writes done by the device are
  immediately visible to the CPU and vice versa.
  PIPE_RESOURCE_FLAG_MAP_COHERENT must be set when creating
  the resource.

Compute kernel execution
^^^^^^^^^^^^^^^^^^^^^^^^

A compute program can be defined, bound or destroyed using
``create_compute_state``, ``bind_compute_state`` or
``destroy_compute_state`` respectively.

Any of the subroutines contained within the compute program can be
executed on the device using the ``launch_grid`` method.  This method
will execute as many instances of the program as elements in the
specified N-dimensional grid, hopefully in parallel.

The compute program has access to four special resources:

* ``GLOBAL`` represents a memory space shared among all the threads
  running on the device.  An arbitrary buffer created with the
  ``PIPE_BIND_GLOBAL`` flag can be mapped into it using the
  ``set_global_binding`` method.

* ``LOCAL`` represents a memory space shared among all the threads
  running in the same working group.  The initial contents of this
  resource are undefined.

* ``PRIVATE`` represents a memory space local to a single thread.
  The initial contents of this resource are undefined.

* ``INPUT`` represents a read-only memory space that can be
  initialized at ``launch_grid`` time.

These resources use a byte-based addressing scheme, and they can be
accessed from the compute program by means of the LOAD/STORE TGSI
opcodes.  Additional resources to be accessed using the same opcodes
may be specified by the user with the ``set_compute_resources``
method.

In addition, normal texture sampling is allowed from the compute
program: ``bind_sampler_states`` may be used to set up texture
samplers for the compute stage and ``set_sampler_views`` may
be used to bind a number of sampler views to it.
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a302 6
``create_query`` takes a query type (``PIPE_QUERY_*``), as well as an index,
which is the vertex stream for ``PIPE_QUERY_PRIMITIVES_GENERATED`` and
``PIPE_QUERY_PRIMITIVES_EMITTED``, and allocates a query structure.

``begin_query`` will clear/reset previous query results.

d393 1
a393 1
prior to rendering anything. Functions always honoring render_condition include
a394 2
The blit function (but not resource_copy_region, which seems inconsistent)
can also optionally honor the current render condition.
d466 2
a467 4
scaling, format conversion, and up-/downsampling, as well as a destination clip
rectangle (scissors). It can also optionally honor the current render condition
(but either way the blit itself never contributes anything to queries currently
gathering data).
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d303 6
d399 1
a399 1
prior to rendering anything. Functions honoring render_condition include
d401 2
d474 4
a477 2
scaling, format conversion, and up-/downsampling, as well as
a destination clip rectangle (scissors).
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d28 5
a32 4
  vertex and geometry samplers.  Note that sampler states are set en masse.
  If M is the max number of sampler units supported by the driver and N
  samplers are bound with ``bind_fragment_sampler_states`` then sampler
  units N..M-1 are considered disabled/NULL.
d34 1
a34 1
* :ref:`Depth, Stencil, & Alpha`: ``*_depth_stencil_alpha_state``
d37 1
a37 1
* :ref:`Vertex Elements`: ``*_vertex_elements_state``
d70 1
d108 2
a109 2
* ``set_fragment_sampler_views`` binds an array of sampler views to
  fragment shader stage. Every binding point acquires a reference
d111 1
a111 7
  sampler view.  If M is the maximum number of sampler units and N units
  is passed to set_fragment_sampler_views, the driver should unbind the
  sampler views for units N..M-1.

* ``set_vertex_sampler_views`` binds an array of sampler views to vertex
  shader stage. Every binding point acquires a reference to a respective
  sampler view and releases a reference to the previous sampler view.
d186 5
a190 4
  append_bitmask is a bitmask, where the i-th bit specifies whether new
  primitives should be appended to the i-th buffer (writing starts at
  the internal offset), or whether writing should start at the beginning
  (the internal offset is effectively set to 0).
d222 5
d314 1
a314 1
:ref:`Depth, Stencil, & Alpha` testing or shader KILL instructions.
d355 2
d428 13
d530 10
d577 12
d626 2
a627 2
program: ``bind_compute_sampler_states`` may be used to set up texture
samplers for the compute stage and ``set_compute_sampler_views`` may
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a56 2
* ``set_stream_output_buffers``

d71 1
a71 1
* ``set_scissor_state`` sets the bounds for the scissor test, which culls
d76 4
a79 2
  and y would be [xmin..xmax-1] and [ymin..ymax-1].
* ``set_viewport_state``
d125 17
d159 41
d212 1
a212 2
only depth or stencil in a combined depth/stencil surface, if the driver
supports PIPE_CAP_DEPTHSTENCIL_CLEAR_SEPARATE.
d295 1
a295 2
draws.  Queries may be nested, though no state tracker currently
exercises this.  
d308 3
a310 2
The most common type of query is the occlusion query,
``PIPE_QUERY_OCCLUSION_COUNTER``, which counts the number of fragments which
d314 2
d321 5
d327 4
a330 2
Another type of query, ``PIPE_QUERY_TIME_ELAPSED``, returns the amount of
time, in nanoseconds, the context takes to perform operations.
d333 46
d387 4
a390 2
(typically an occlusion query).  The ``render_condition`` function specifies
the query which should be checked prior to rendering anything.
d396 4
a399 2
drawing commands will be predicated on the outcome of the query.  If
the query result is zero subsequent drawing commands will be skipped.
d410 1
a410 1
for the non-REGION modes but in the case that an occulusion query returns
d446 1
d448 7
a454 24
``resource_resolve`` resolves a multisampled resource into a non-multisampled
one. Formats and dimensions must match. This function must be present if a driver
supports multisampling.

The interfaces to these calls are likely to change to make it easier
for a driver to batch multiple blits with the same source and
destination.


Stream Output
^^^^^^^^^^^^^

Stream output, also known as transform feedback allows writing the results of the
vertex pipeline (after the geometry shader or vertex shader if no geometry shader
is present) to be written to a buffer created with a ``PIPE_BIND_STREAM_OUTPUT``
flag.

First a stream output state needs to be created with the
``create_stream_output_state`` call. It specific the details of what's being written,
to which buffer and with what kind of a writemask.

Then target buffers needs to be set with the call to ``set_stream_output_buffers``
which sets the buffers and the offsets from the start of those buffer to where
the data will be written to.
d462 10
a471 11
``get_transfer`` creates a transfer object.

``transfer_destroy`` destroys the transfer object. May cause
data to be written to the resource at this point.

``transfer_map`` creates a memory mapping for the transfer object.
The returned map points to the start of the mapped range according to
the box region, not the beginning of the resource.

``transfer_unmap`` remove the memory mapping for the transfer object.
Any pointers into the map should be considered invalid and discarded.
d474 1
a474 2
Basically get_transfer, transfer_map, data write, transfer_unmap, and
transfer_destroy all in one.
d481 2
a482 5
For PIPE_TEXTURE_1D_ARRAY, the box::y and box::height fields refer to the
array dimension of the texture.

For PIPE_TEXTURE_2D_ARRAY, the box::z and box::depth fields refer to the
array dimension of the texture.
d487 2
d503 1
a503 15
.. _redefine_user_buffer:

redefine_user_buffer
%%%%%%%%%%%%%%%%%%%%

This function notifies a driver that the user buffer content has been changed.
The updated region starts at ``offset`` and is ``size`` bytes large.
The ``offset`` is relative to the pointer specified in ``user_buffer_create``.
While uploading the user buffer, the driver is allowed not to upload
the memory outside of this region.
The width0 is redefined to ``MAX2(width0, offset+size)``.



.. _texture_barrier
d524 1
a524 1
  Resource contents will be written back at transfer_destroy time (or modified
d549 41
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d6 6
a11 2
The context object represents the purest, most directly accessible, abilities
of the device's 3D rendering pipeline.
d19 4
a22 3
All CSO state is created, bound, and destroyed, with triplets of methods that
all follow a specific naming scheme. For example, ``create_blend_state``,
``bind_blend_state``, and ``destroy_blend_state``.
d27 5
a31 3
* :ref:`Sampler`: These are special; they can be bound to either vertex or
  fragment samplers, and they are bound in groups.
  ``bind_fragment_sampler_states``, ``bind_vertex_sampler_states``
d34 2
a35 2
* :ref:`Shader`: These have two sets of methods. ``*_fs_state`` is for
  fragment shaders, and ``*_vs_state`` is for vertex shaders.
d57 3
d109 3
a111 1
  sampler view.
d182 15
a196 2
All vertex indices must fall inside the range given by ``min_index`` and
``max_index``.  In case non-indexed draw, ``min_index`` should be set to
d199 2
a200 6
``index_bias`` is a value added to every vertex index before fetching vertex
attributes.  It does not affect ``min_index`` and ``max_index``.

If there is an index buffer bound, and ``indexed`` field is true, all vertex
indices will be looked up in the index buffer.  ``min_index``, ``max_index``,
and ``index_bias`` apply after index lookup.
d256 6
d265 1
d378 16
d404 26
d437 29
a465 13
* ``READ``: resource contents are read at transfer create time.
* ``WRITE``: resource contents will be written back at transfer destroy time.
* ``MAP_DIRECTLY``: a transfer should directly map the resource. May return
  NULL if not supported.
* ``DISCARD``: The memory within the mapped region is discarded.
  Cannot be used with ``READ``.
* ``DONTBLOCK``: Fail if the resource cannot be mapped immediately.
* ``UNSYNCHRONIZED``: Do not synchronize pending operations on the resource
  when mapping. The interaction of any writes to the map and any
  operations pending on the resource are undefined. Cannot be used with
  ``READ``.
* ``FLUSH_EXPLICIT``: Written ranges will be notified later with
  :ref:`transfer_flush_region`. Cannot be used with ``READ``.
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d1 2
d29 1
d45 1
a45 2
* ``set_fragment_sampler_textures``
* ``set_vertex_sampler_textures``
d48 1
d56 1
d60 1
d66 3
a68 1
  be set since they will not be used.
a69 1
* ``set_vertex_elements``
d72 2
a73 2
Clearing
^^^^^^^^
d75 2
a76 2
``clear`` initializes some or all of the surfaces currently bound to
the framebuffer to particular RGBA, depth, or stencil values.
d78 31
a108 5
Clear is one of the most difficult concepts to nail down to a single
interface and it seems likely that we will want to add additional
clear paths, for instance clearing surfaces not bound to the
framebuffer, or read-modify-write clears such as depth-only or
stencil-only clears of packed depth-stencil buffers.  
d110 2
d113 2
a114 2
Drawing
^^^^^^^
d116 8
a123 1
``draw_arrays`` draws a specified primitive.
d125 1
a125 2
This command is equivalent to calling ``draw_arrays_instanced``
with ``startInstance`` set to 0 and ``instanceCount`` set to 1.
d127 2
a128 2
``draw_elements`` draws a specified primitive using an optional
index buffer.
d130 2
a131 2
This command is equivalent to calling ``draw_elements_instanced``
with ``startInstance`` set to 0 and ``instanceCount`` set to 1.
d133 3
a135 1
``draw_range_elements``
d137 18
a154 4
XXX: this is (probably) a temporary entrypoint, as the range
information should be available from the vertex_buffer state.
Using this to quickly evaluate a specialized path in the draw
module.
a155 1
``draw_arrays_instanced`` draws multiple instances of the same primitive.
d157 2
a158 5
This command is equivalent to calling ``draw_elements_instanced``
with ``indexBuffer`` set to NULL and ``indexSize`` set to 0.

``draw_elements_instanced`` draws multiple instances of the same primitive
using an optional index buffer.
d160 2
a161 4
For instanceID in the range between ``startInstance``
and ``startInstance``+``instanceCount``-1, inclusive, draw a primitive
specified by ``mode`` and sequential numbers in the range between ``start``
and ``start``+``count``-1, inclusive.
d163 23
a185 4
If ``indexBuffer`` is not NULL, it specifies an index buffer with index
byte size of ``indexSize``. The sequential numbers are used to lookup
the index buffer and the resulting indices in turn are used to fetch
vertex attributes.
d187 2
a188 2
If ``indexBuffer`` is NULL, the sequential numbers are used directly
as indices to fetch vertex attributes.
d231 10
a240 3
A common type of query is the occlusion query which counts the number of
fragments/pixels which are written to the framebuffer (and not culled by
Z/stencil/alpha testing or shader KILL instructions).
d283 1
a283 3
``is_texture_referenced``

``is_buffer_referenced``
d290 1
a290 2
These methods emulate classic blitter controls. They are not guaranteed to be
available; if they are set to NULL, then they are not present.
d292 1
a292 1
These methods operate directly on ``pipe_surface`` objects, and stand
d296 10
a305 5
``surface_fill`` performs a fill operation on a section of a surface.

``surface_copy`` blits a region of a surface to a region of another surface,
provided that both surfaces are the same format. The source and destination
may be the same surface, and overlapping blits are permitted.
d311 69
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a0 2
.. _context:

a26 1
* :ref:`Vertex Elements`: ``*_vertex_elements_state``
d42 2
a43 1

a45 1
* ``set_index_buffer``
a52 1

a55 1
* ``set_sample_mask``
d61 1
a61 3
  be set since they will not be used.  Note that scissor xmin and ymin are
  inclusive, but  xmax and ymax are exclusive.  The inclusive ranges in x
  and y would be [xmin..xmax-1] and [ymin..ymax-1].
d63 1
d66 5
a70 2
Sampler Views
^^^^^^^^^^^^^
d72 5
a76 2
These are the means to bind textures to shader stages. To create one, specify
its format, swizzle and LOD range in sampler view template.
a77 31
If texture format is different than template format, it is said the texture
is being cast to another format. Casting can be done only between compatible
formats, that is formats that have matching component order and sizes.

Swizzle fields specify they way in which fetched texel components are placed
in the result register. For example, ``swizzle_r`` specifies what is going to be
placed in first component of result register.

The ``first_level`` and ``last_level`` fields of sampler view template specify
the LOD range the texture is going to be constrained to. Note that these
values are in addition to the respective min_lod, max_lod values in the
pipe_sampler_state (that is if min_lod is 2.0, and first_level 3, the first mip
level used for sampling from the resource is effectively the fifth).

The ``first_layer`` and ``last_layer`` fields specify the layer range the
texture is going to be constrained to. Similar to the LOD range, this is added
to the array index which is used for sampling.

* ``set_fragment_sampler_views`` binds an array of sampler views to
  fragment shader stage. Every binding point acquires a reference
  to a respective sampler view and releases a reference to the previous
  sampler view.

* ``set_vertex_sampler_views`` binds an array of sampler views to vertex
  shader stage. Every binding point acquires a reference to a respective
  sampler view and releases a reference to the previous sampler view.

* ``create_sampler_view`` creates a new sampler view. ``texture`` is associated
  with the sampler view which results in sampler view holding a reference
  to the texture. Format specified in template must be compatible
  with texture format.
d79 2
a80 2
* ``sampler_view_destroy`` destroys a sampler view and releases its reference
  to associated texture.
d82 1
a82 2
Surfaces
^^^^^^^^
d84 2
a85 8
These are the means to use resources as color render targets or depthstencil
attachments. To create one, specify the mip level, the range of layers, and
the bind flags (either PIPE_BIND_DEPTH_STENCIL or PIPE_BIND_RENDER_TARGET).
Note that layer values are in addition to what is indicated by the geometry
shader output variable XXX_FIXME (that is if first_layer is 3 and geometry
shader indicates index 2, the 5th layer of the resource will be used). These
first_layer and last_layer parameters will only be used for 1d array, 2d array,
cube, and 3d textures otherwise they are 0.
d87 2
a88 1
* ``create_surface`` creates a new surface.
d90 2
a91 2
* ``surface_destroy`` destroys a surface and releases its reference to the
  associated resource.
d93 1
a93 2
Clearing
^^^^^^^^
d95 4
a98 3
Clear is one of the most difficult concepts to nail down to a single
interface (due to both different requirements from APIs and also driver/hw
specific differences).
d100 1
a100 18
``clear`` initializes some or all of the surfaces currently bound to
the framebuffer to particular RGBA, depth, or stencil values.
Currently, this does not take into account color or stencil write masks (as
used by GL), and always clears the whole surfaces (no scissoring as used by
GL clear or explicit rectangles like d3d9 uses). It can, however, also clear
only depth or stencil in a combined depth/stencil surface, if the driver
supports PIPE_CAP_DEPTHSTENCIL_CLEAR_SEPARATE.
If a surface includes several layers then all layers will be cleared.

``clear_render_target`` clears a single color rendertarget with the specified
color value. While it is only possible to clear one surface at a time (which can
include several layers), this surface need not be bound to the framebuffer.

``clear_depth_stencil`` clears a single depth, stencil or depth/stencil surface
with the specified depth and stencil values (for combined depth/stencil buffers,
is is also possible to only clear one or the other part). While it is only
possible to clear one surface at a time (which can include several layers),
this surface need not be bound to the framebuffer.
d102 2
d105 2
a106 2
Drawing
^^^^^^^
d108 4
a111 2
``draw_vbo`` draws a specified primitive.  The primitive mode and other
properties are described by ``pipe_draw_info``.
d113 4
a116 23
The ``mode``, ``start``, and ``count`` fields of ``pipe_draw_info`` specify the
the mode of the primitive and the vertices to be fetched, in the range between
``start`` to ``start``+``count``-1, inclusive.

Every instance with instanceID in the range between ``start_instance`` and
``start_instance``+``instance_count``-1, inclusive, will be drawn.

All vertex indices must fall inside the range given by ``min_index`` and
``max_index``.  In case non-indexed draw, ``min_index`` should be set to
``start`` and ``max_index`` should be set to ``start``+``count``-1.

``index_bias`` is a value added to every vertex index before fetching vertex
attributes.  It does not affect ``min_index`` and ``max_index``.

If there is an index buffer bound, and ``indexed`` field is true, all vertex
indices will be looked up in the index buffer.  ``min_index``, ``max_index``,
and ``index_bias`` apply after index lookup.

When drawing indexed primitives, the primitive restart index can be
used to draw disjoint primitive strips.  For example, several separate
line strips can be drawn by designating a special index value as the
restart index.  The ``primitive_restart`` flag enables/disables this
feature.  The ``restart_index`` field specifies the restart index value.
d118 2
a119 2
When primitive restart is in use, array indexes are compared to the
restart index before adding the index_bias offset.
d162 3
a164 10
The most common type of query is the occlusion query,
``PIPE_QUERY_OCCLUSION_COUNTER``, which counts the number of fragments which
are written to the framebuffer without being culled by
:ref:`Depth, Stencil, & Alpha` testing or shader KILL instructions.

Another type of query, ``PIPE_QUERY_TIME_ELAPSED``, returns the amount of
time, in nanoseconds, the context takes to perform operations.

Gallium does not guarantee the availability of any query types; one must
always check the capabilities of the :ref:`Screen` first.
d207 3
a209 1
``is_resource_referenced``
d216 2
a217 1
These methods emulate classic blitter controls.
d219 1
a219 1
These methods operate directly on ``pipe_resource`` objects, and stand
d223 5
a227 10
``resource_copy_region`` blits a region of a resource to a region of another
resource, provided that both resources have the same format, or compatible
formats, i.e., formats for which copying the bytes from the source resource
unmodified to the destination resource will achieve the same effect of a
textured quad blitter.. The source and destination may be the same resource,
but overlapping blits are not permitted.

``resource_resolve`` resolves a multisampled resource into a non-multisampled
one. Formats and dimensions must match. This function must be present if a driver
supports multisampling.
a232 69

Stream Output
^^^^^^^^^^^^^

Stream output, also known as transform feedback allows writing the results of the
vertex pipeline (after the geometry shader or vertex shader if no geometry shader
is present) to be written to a buffer created with a ``PIPE_BIND_STREAM_OUTPUT``
flag.

First a stream output state needs to be created with the
``create_stream_output_state`` call. It specific the details of what's being written,
to which buffer and with what kind of a writemask.

Then target buffers needs to be set with the call to ``set_stream_output_buffers``
which sets the buffers and the offsets from the start of those buffer to where
the data will be written to.


Transfers
^^^^^^^^^

These methods are used to get data to/from a resource.

``get_transfer`` creates a transfer object.

``transfer_destroy`` destroys the transfer object. May cause
data to be written to the resource at this point.

``transfer_map`` creates a memory mapping for the transfer object.
The returned map points to the start of the mapped range according to
the box region, not the beginning of the resource.

``transfer_unmap`` remove the memory mapping for the transfer object.
Any pointers into the map should be considered invalid and discarded.

``transfer_inline_write`` performs a simplified transfer for simple writes.
Basically get_transfer, transfer_map, data write, transfer_unmap, and
transfer_destroy all in one.

.. _transfer_flush_region:

transfer_flush_region
%%%%%%%%%%%%%%%%%%%%%

If a transfer was created with ``FLUSH_EXPLICIT``, it will not automatically
be flushed on write or unmap. Flushes must be requested with
``transfer_flush_region``. Flush ranges are relative to the mapped range, not
the beginning of the resource.

.. _pipe_transfer:

PIPE_TRANSFER
^^^^^^^^^^^^^

These flags control the behavior of a transfer object.

* ``READ``: resource contents are read at transfer create time.
* ``WRITE``: resource contents will be written back at transfer destroy time.
* ``MAP_DIRECTLY``: a transfer should directly map the resource. May return
  NULL if not supported.
* ``DISCARD``: The memory within the mapped region is discarded.
  Cannot be used with ``READ``.
* ``DONTBLOCK``: Fail if the resource cannot be mapped immediately.
* ``UNSYNCHRONIZED``: Do not synchronize pending operations on the resource
  when mapping. The interaction of any writes to the map and any
  operations pending on the resource are undefined. Cannot be used with
  ``READ``.
* ``FLUSH_EXPLICIT``: Written ranges will be notified later with
  :ref:`transfer_flush_region`. Cannot be used with ``READ``.
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d6 2
a7 6
A Gallium rendering context encapsulates the state which effects 3D
rendering such as blend state, depth/stencil state, texture samplers,
etc.

Note that resource/texture allocation is not per-context but per-screen.

d15 3
a17 4
All Constant State Object (CSO) state is created, bound, and destroyed,
with triplets of methods that all follow a specific naming scheme.
For example, ``create_blend_state``, ``bind_blend_state``, and
``destroy_blend_state``.
d22 3
a24 5
* :ref:`Sampler`: Texture sampler states are bound separately for fragment,
  vertex and geometry samplers.  Note that sampler states are set en masse.
  If M is the max number of sampler units supported by the driver and N
  samplers are bound with ``bind_fragment_sampler_states`` then sampler
  units N..M-1 are considered disabled/NULL.
d27 2
a28 2
* :ref:`Shader`: These are create, bind and destroy methods for vertex,
  fragment and geometry shaders.
a49 1

d63 1
a63 1
* ``set_scissor_states`` sets the bounds for the scissor test, which culls
d68 2
a69 4
  and y would be [xmin..xmax-1] and [ymin..ymax-1]. The number of scissors
  should be the same as the number of set viewports and can be up to
  PIPE_MAX_VIEWPORTS.
* ``set_viewport_states``
d99 1
a99 3
  sampler view.  If M is the maximum number of sampler units and N units
  is passed to set_fragment_sampler_views, the driver should unbind the
  sampler views for units N..M-1.
a112 17
Shader Resources
^^^^^^^^^^^^^^^^

Shader resources are textures or buffers that may be read or written
from a shader without an associated sampler.  This means that they
have no support for floating point coordinates, address wrap modes or
filtering.

Shader resources are specified for all the shader stages at once using
the ``set_shader_resources`` method.  When binding texture resources,
the ``level``, ``first_layer`` and ``last_layer`` pipe_surface fields
specify the mipmap level and the range of layers the texture will be
constrained to.  In the case of buffers, ``first_element`` and
``last_element`` specify the range within the buffer that will be used
by the shader resource.  Writes to a shader resource are only allowed
when the ``writable`` flag is set.

a129 41
Stream output targets
^^^^^^^^^^^^^^^^^^^^^

Stream output, also known as transform feedback, allows writing the primitives
produced by the vertex pipeline to buffers. This is done after the geometry
shader or vertex shader if no geometry shader is present.

The stream output targets are views into buffer resources which can be bound
as stream outputs and specify a memory range where it's valid to write
primitives. The pipe driver must implement memory protection such that any
primitives written outside of the specified memory range are discarded.

Two stream output targets can use the same resource at the same time, but
with a disjoint memory range.

Additionally, the stream output target internally maintains the offset
into the buffer which is incremented everytime something is written to it.
The internal offset is equal to how much data has already been written.
It can be stored in device memory and the CPU actually doesn't have to query
it.

The stream output target can be used in a draw command to provide
the vertex count. The vertex count is derived from the internal offset
discussed above.

* ``create_stream_output_target`` create a new target.

* ``stream_output_target_destroy`` destroys a target. Users of this should
  use pipe_so_target_reference instead.

* ``set_stream_output_targets`` binds stream output targets. The parameter
  append_bitmask is a bitmask, where the i-th bit specifies whether new
  primitives should be appended to the i-th buffer (writing starts at
  the internal offset), or whether writing should start at the beginning
  (the internal offset is effectively set to 0).

NOTE: The currently-bound vertex or geometry shader must be compiled with
the properly-filled-in structure pipe_stream_output_info describing which
outputs should be written to buffers and how. The structure is part of
pipe_shader_state.

d142 2
a143 1
only depth or stencil in a combined depth/stencil surface.
d170 3
a172 2
If there is an index buffer bound, and ``indexed`` field is true, all vertex
indices will be looked up in the index buffer.
d174 2
a175 10
In indexed draw, ``min_index`` and ``max_index`` respectively provide a lower
and upper bound of the indices contained in the index buffer inside the range
between ``start`` to ``start``+``count``-1.  This allows the driver to
determine which subset of vertices will be referenced during te draw call
without having to scan the index buffer.  Providing a over-estimation of the
the true bounds, for example, a ``min_index`` and ``max_index`` of 0 and
0xffffffff respectively, must give exactly the same rendering, albeit with less
performance due to unreferenced vertex buffers being unnecessarily DMA'ed or
processed.  Providing a underestimation of the true bounds will result in
undefined behavior, but should not result in program or system failure.
d177 3
a179 5
In case of non-indexed draw, ``min_index`` should be set to
``start`` and ``max_index`` should be set to ``start``+``count``-1.

``index_bias`` is a value added to every vertex index after lookup and before
fetching vertex attributes.
d217 2
a218 1
draws.  Queries may be nested, though not all state trackers exercise this.
d231 2
a232 3
The interface currently includes the following types of queries:

``PIPE_QUERY_OCCLUSION_COUNTER`` counts the number of fragments which
a234 2
The result is an unsigned 64-bit integer.
This query can be used with ``render_condition``.
d236 2
a237 62
In cases where a boolean result of an occlusion query is enough,
``PIPE_QUERY_OCCLUSION_PREDICATE`` should be used. It is just like
``PIPE_QUERY_OCCLUSION_COUNTER`` except that the result is a boolean
value of FALSE for cases where COUNTER would result in 0 and TRUE
for all other cases.
This query can be used with ``render_condition``.

``PIPE_QUERY_TIME_ELAPSED`` returns the amount of time, in nanoseconds,
the context takes to perform operations.
The result is an unsigned 64-bit integer.

``PIPE_QUERY_TIMESTAMP`` returns a device/driver internal timestamp,
scaled to nanoseconds, recorded after all commands issued prior to
``end_query`` have been processed.
This query does not require a call to ``begin_query``.
The result is an unsigned 64-bit integer.

``PIPE_QUERY_TIMESTAMP_DISJOINT`` can be used to check the
internal timer resolution and whether the timestamp counter has become
unreliable due to things like throttling etc. - only if this is FALSE
a timestamp query (within the timestamp_disjoint query) should be trusted.
The result is a 64-bit integer specifying the timer resolution in Hz,
followed by a boolean value indicating whether the timestamp counter
is discontinuous or disjoint.

``PIPE_QUERY_PRIMITIVES_GENERATED`` returns a 64-bit integer indicating
the number of primitives processed by the pipeline (regardless of whether
stream output is active or not).

``PIPE_QUERY_PRIMITIVES_EMITTED`` returns a 64-bit integer indicating
the number of primitives written to stream output buffers.

``PIPE_QUERY_SO_STATISTICS`` returns 2 64-bit integers corresponding to
the result of
``PIPE_QUERY_PRIMITIVES_EMITTED`` and
the number of primitives that would have been written to stream output buffers
if they had infinite space available (primitives_storage_needed), in this order.

``PIPE_QUERY_SO_OVERFLOW_PREDICATE`` returns a boolean value indicating
whether the stream output targets have overflowed as a result of the
commands issued between ``begin_query`` and ``end_query``.
This query can be used with ``render_condition``.

``PIPE_QUERY_GPU_FINISHED`` returns a boolean value indicating whether
all commands issued before ``end_query`` have completed. However, this
does not imply serialization.
This query does not require a call to ``begin_query``.

``PIPE_QUERY_PIPELINE_STATISTICS`` returns an array of the following
64-bit integers:
Number of vertices read from vertex buffers.
Number of primitives read from vertex buffers.
Number of vertex shader threads launched.
Number of geometry shader threads launched.
Number of primitives generated by geometry shaders.
Number of primitives forwarded to the rasterizer.
Number of primitives rasterized.
Number of fragment shader threads launched.
Number of tessellation control shader threads launched.
Number of tessellation evaluation shader threads launched.
If a shader type is not supported by the device/driver,
the corresponding values should be set to 0.
d247 2
a248 4
(typically an occlusion query, or streamout overflow predicate).
The ``render_condition`` function specifies the query which should be checked
prior to rendering anything. Functions honoring render_condition include
(and are limited to) draw_vbo, clear, clear_render_target, clear_depth_stencil.
d254 2
a255 4
drawing commands will be predicated on the outcome of the query.
Commands will be skipped if ``condition`` is equal to the predicate result
(for non-boolean queries such as OCCLUSION_QUERY, zero counts as FALSE,
non-zero as TRUE).
d266 1
a266 1
for the non-REGION modes but in the case that an occlusion query returns
a301 1
This can be considered the equivalent of a CPU memcpy.
d303 24
a326 7
``blit`` blits a region of a resource to a region of another resource, including
scaling, format conversion, and up-/downsampling, as well as
a destination clip rectangle (scissors).
As opposed to manually drawing a textured quad, this lets the pipe driver choose
the optimal method for blitting (like using a special 2D engine), and usually
offers, for example, accelerated stencil-only copies even where
PIPE_CAP_SHADER_STENCIL_EXPORT is not available.
d334 1
a334 10
``transfer_map`` creates a memory mapping and the transfer object
associated with it.
The returned pointer points to the start of the mapped range according to
the box region, not the beginning of the resource. If transfer_map fails,
the returned pointer to the buffer memory is NULL, and the pointer
to the transfer object remains unchanged (i.e. it can be non-NULL).

``transfer_unmap`` remove the memory mapping for and destroy
the transfer object. The pointer into the resource should be considered
invalid and discarded.
d336 2
a337 2
``transfer_inline_write`` performs a simplified transfer for simple writes.
Basically transfer_map, data write, and transfer_unmap all in one.
d339 3
d343 2
a344 12
The box parameter to some of these functions defines a 1D, 2D or 3D
region of pixels.  This is self-explanatory for 1D, 2D and 3D texture
targets.

For PIPE_TEXTURE_1D_ARRAY and PIPE_TEXTURE_2D_ARRAY, the box::z and box::depth
fields refer to the array dimension of the texture.

For PIPE_TEXTURE_CUBE, the box:z and box::depth fields refer to the
faces of the cube map (z + depth <= 6).

For PIPE_TEXTURE_CUBE_ARRAY, the box:z and box::depth fields refer to both
the face and array dimension of the texture (face = z % 6, array = z / 6).
d346 3
a359 12


.. _texture_barrier:

texture_barrier
%%%%%%%%%%%%%%%

This function flushes all pending writes to the currently-set surfaces and
invalidates all read caches of the currently-set samplers.



d367 13
a379 70
``PIPE_TRANSFER_READ``
  Resource contents read back (or accessed directly) at transfer create time.

``PIPE_TRANSFER_WRITE``
  Resource contents will be written back at transfer_unmap time (or modified
  as a result of being accessed directly).

``PIPE_TRANSFER_MAP_DIRECTLY``
  a transfer should directly map the resource. May return NULL if not supported.

``PIPE_TRANSFER_DISCARD_RANGE``
  The memory within the mapped region is discarded.  Cannot be used with
  ``PIPE_TRANSFER_READ``.

``PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE``
  Discards all memory backing the resource.  It should not be used with
  ``PIPE_TRANSFER_READ``.

``PIPE_TRANSFER_DONTBLOCK``
  Fail if the resource cannot be mapped immediately.

``PIPE_TRANSFER_UNSYNCHRONIZED``
  Do not synchronize pending operations on the resource when mapping. The
  interaction of any writes to the map and any operations pending on the
  resource are undefined. Cannot be used with ``PIPE_TRANSFER_READ``.

``PIPE_TRANSFER_FLUSH_EXPLICIT``
  Written ranges will be notified later with :ref:`transfer_flush_region`.
  Cannot be used with ``PIPE_TRANSFER_READ``.


Compute kernel execution
^^^^^^^^^^^^^^^^^^^^^^^^

A compute program can be defined, bound or destroyed using
``create_compute_state``, ``bind_compute_state`` or
``destroy_compute_state`` respectively.

Any of the subroutines contained within the compute program can be
executed on the device using the ``launch_grid`` method.  This method
will execute as many instances of the program as elements in the
specified N-dimensional grid, hopefully in parallel.

The compute program has access to four special resources:

* ``GLOBAL`` represents a memory space shared among all the threads
  running on the device.  An arbitrary buffer created with the
  ``PIPE_BIND_GLOBAL`` flag can be mapped into it using the
  ``set_global_binding`` method.

* ``LOCAL`` represents a memory space shared among all the threads
  running in the same working group.  The initial contents of this
  resource are undefined.

* ``PRIVATE`` represents a memory space local to a single thread.
  The initial contents of this resource are undefined.

* ``INPUT`` represents a read-only memory space that can be
  initialized at ``launch_grid`` time.

These resources use a byte-based addressing scheme, and they can be
accessed from the compute program by means of the LOAD/STORE TGSI
opcodes.  Additional resources to be accessed using the same opcodes
may be specified by the user with the ``set_compute_resources``
method.

In addition, normal texture sampling is allowed from the compute
program: ``bind_compute_sampler_states`` may be used to set up texture
samplers for the compute stage and ``set_compute_sampler_views`` may
be used to bind a number of sampler views to it.
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d28 4
a31 5
  vertex, geometry and compute shaders with the ``bind_sampler_states``
  function.  The ``start`` and ``num_samplers`` parameters indicate a range
  of samplers to change.  NOTE: at this time, start is always zero and
  the CSO module will always replace all samplers at once (no sub-ranges).
  This may change in the future.
d33 1
a33 1
* :ref:`depth-stencil-alpha`: ``*_depth_stencil_alpha_state``
d36 1
a36 1
* :ref:`vertexelements`: ``*_vertex_elements_state``
a68 1
* ``set_min_samples`` sets the minimum number of samples that must be run.
d106 2
a107 2
* ``set_sampler_views`` binds an array of sampler views to a shader stage.
  Every binding point acquires a reference
d109 7
a115 1
  sampler view.
d190 4
a193 5
  offset is an array which specifies the internal offset of the buffer. The
  internal offset is, besides writing, used for reading the data during the
  draw_auto stage, i.e. it specifies how much data there is in the buffer
  for the purposes of the draw_auto stage. -1 means the buffer should
  be appended to, and everything else sets the internal offset.
a224 5
``clear_buffer`` clears a PIPE_BUFFER resource with the specified clear value
(which may be multiple bytes in length). Logically this is a memset with a
multi-byte element value starting at offset bytes from resource start, going
for size bytes. It is guaranteed that size % clear_value_size == 0.

d312 1
a312 1
:ref:`depth-stencil-alpha` testing or shader KILL instructions.
a352 2
XXX the 2nd value is equivalent to ``PIPE_QUERY_PRIMITIVES_GENERATED`` but it is
unclear if it should be increased if stream output is not active.
a423 13
``flush_resource``

Flush the resource cache, so that the resource can be used
by an external client. Possible usage:
- flushing a resource before presenting it on the screen
- flushing a resource if some other process or device wants to use it
This shouldn't be used to flush caches if the resource is only managed
by a single pipe_screen and is not shared with another process.
(i.e. you shouldn't use it to flush caches explicitly if you want to e.g.
use the resource for texturing)



a512 10
.. _memory_barrier:

memory_barrier
%%%%%%%%%%%%%%%

This function flushes caches according to which of the PIPE_BARRIER_* flags
are set.



a549 12
``PIPE_TRANSFER_PERSISTENT``
  Allows the resource to be used for rendering while mapped.
  PIPE_RESOURCE_FLAG_MAP_PERSISTENT must be set when creating
  the resource.
  If COHERENT is not set, memory_barrier(PIPE_BARRIER_MAPPED_BUFFER)
  must be called to ensure the device can see what the CPU has written.

``PIPE_TRANSFER_COHERENT``
  If PERSISTENT is set, this ensures any writes done by the device are
  immediately visible to the CPU and vice versa.
  PIPE_RESOURCE_FLAG_MAP_COHERENT must be set when creating
  the resource.
d587 2
a588 2
program: ``bind_sampler_states`` may be used to set up texture
samplers for the compute stage and ``set_sampler_views`` may
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a302 6
``create_query`` takes a query type (``PIPE_QUERY_*``), as well as an index,
which is the vertex stream for ``PIPE_QUERY_PRIMITIVES_GENERATED`` and
``PIPE_QUERY_PRIMITIVES_EMITTED``, and allocates a query structure.

``begin_query`` will clear/reset previous query results.

d393 1
a393 1
prior to rendering anything. Functions always honoring render_condition include
a394 2
The blit function (but not resource_copy_region, which seems inconsistent)
can also optionally honor the current render condition.
d466 2
a467 4
scaling, format conversion, and up-/downsampling, as well as a destination clip
rectangle (scissors). It can also optionally honor the current render condition
(but either way the blit itself never contributes anything to queries currently
gathering data).
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d303 6
d399 1
a399 1
prior to rendering anything. Functions honoring render_condition include
d401 2
d474 4
a477 2
scaling, format conversion, and up-/downsampling, as well as
a destination clip rectangle (scissors).
@


