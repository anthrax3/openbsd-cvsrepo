head	1.4;
access;
symbols
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.6
	OPENBSD_5_7_BASE:1.3
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.12.23.05.17.41;	author jsg;	state dead;
branches;
next	1.3;
commitid	TnlogFl9nOv2eaRf;

1.3
date	2013.09.05.14.02.10;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.09;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove the now unused Mesa 10.2.9 code
@
text
@
#include "i915_drm_winsys.h"
#include "util/u_memory.h"

#include "i915_drm.h"
#include "i915/i915_debug.h"
#include <xf86drm.h>
#include <stdio.h>

#define BATCH_RESERVED 16

#define INTEL_DEFAULT_RELOCS 100
#define INTEL_MAX_RELOCS 400

#define INTEL_BATCH_NO_CLIPRECTS 0x1
#define INTEL_BATCH_CLIPRECTS    0x2

#undef INTEL_RUN_SYNC

struct i915_drm_batchbuffer
{
   struct i915_winsys_batchbuffer base;

   size_t actual_size;

   drm_intel_bo *bo;
};

static INLINE struct i915_drm_batchbuffer *
i915_drm_batchbuffer(struct i915_winsys_batchbuffer *batch)
{
   return (struct i915_drm_batchbuffer *)batch;
}

static void
i915_drm_batchbuffer_reset(struct i915_drm_batchbuffer *batch)
{
   struct i915_drm_winsys *idws = i915_drm_winsys(batch->base.iws);

   if (batch->bo)
      drm_intel_bo_unreference(batch->bo);
   batch->bo = drm_intel_bo_alloc(idws->gem_manager,
                                  "gallium3d_batchbuffer",
                                  batch->actual_size,
                                  4096);

   memset(batch->base.map, 0, batch->actual_size);
   batch->base.ptr = batch->base.map;
   batch->base.size = batch->actual_size - BATCH_RESERVED;
   batch->base.relocs = 0;
}

static struct i915_winsys_batchbuffer *
i915_drm_batchbuffer_create(struct i915_winsys *iws)
{
   struct i915_drm_winsys *idws = i915_drm_winsys(iws);
   struct i915_drm_batchbuffer *batch = CALLOC_STRUCT(i915_drm_batchbuffer);

   batch->actual_size = idws->max_batch_size;

   batch->base.map = MALLOC(batch->actual_size);
   batch->base.ptr = NULL;
   batch->base.size = 0;

   batch->base.relocs = 0;

   batch->base.iws = iws;

   i915_drm_batchbuffer_reset(batch);

   return &batch->base;
}

static boolean
i915_drm_batchbuffer_validate_buffers(struct i915_winsys_batchbuffer *batch,
				      struct i915_winsys_buffer **buffer,
				      int num_of_buffers)
{
   struct i915_drm_batchbuffer *drm_batch = i915_drm_batchbuffer(batch);
   drm_intel_bo *bos[num_of_buffers + 1];
   int i, ret;

   bos[0] = drm_batch->bo;
   for (i = 0; i < num_of_buffers; i++)
      bos[i+1] = intel_bo(buffer[i]);

   ret = drm_intel_bufmgr_check_aperture_space(bos, num_of_buffers);
   if (ret != 0)
      return FALSE;

   return TRUE;
}

static int
i915_drm_batchbuffer_reloc(struct i915_winsys_batchbuffer *ibatch,
                            struct i915_winsys_buffer *buffer,
                            enum i915_winsys_buffer_usage usage,
                            unsigned pre_add, boolean fenced)
{
   struct i915_drm_batchbuffer *batch = i915_drm_batchbuffer(ibatch);
   unsigned write_domain = 0;
   unsigned read_domain = 0;
   unsigned offset;
   int ret = 0;

   switch (usage) {
   case I915_USAGE_SAMPLER:
      write_domain = 0;
      read_domain = I915_GEM_DOMAIN_SAMPLER;
      break;
   case I915_USAGE_RENDER:
      write_domain = I915_GEM_DOMAIN_RENDER;
      read_domain = I915_GEM_DOMAIN_RENDER;
      break;
   case I915_USAGE_2D_TARGET:
      write_domain = I915_GEM_DOMAIN_RENDER;
      read_domain = I915_GEM_DOMAIN_RENDER;
      break;
   case I915_USAGE_2D_SOURCE:
      write_domain = 0;
      read_domain = I915_GEM_DOMAIN_RENDER;
      break;
   case I915_USAGE_VERTEX:
      write_domain = 0;
      read_domain = I915_GEM_DOMAIN_VERTEX;
      break;
   default:
      assert(0);
      return -1;
   }

   offset = (unsigned)(batch->base.ptr - batch->base.map);

   if (fenced)
      ret = drm_intel_bo_emit_reloc_fence(batch->bo, offset,
				    intel_bo(buffer), pre_add,
				    read_domain,
				    write_domain);
   else
      ret = drm_intel_bo_emit_reloc(batch->bo, offset,
				    intel_bo(buffer), pre_add,
				    read_domain,
				    write_domain);

   ((uint32_t*)batch->base.ptr)[0] = intel_bo(buffer)->offset + pre_add;
   batch->base.ptr += 4;

   if (!ret)
      batch->base.relocs++;

   return ret;
}

static void
i915_drm_throttle(struct i915_drm_winsys *idws)
{
   drmIoctl(idws->fd, DRM_IOCTL_I915_GEM_THROTTLE, NULL);
}

static void
i915_drm_batchbuffer_flush(struct i915_winsys_batchbuffer *ibatch,
                           struct pipe_fence_handle **fence,
                           enum i915_winsys_flush_flags flags)
{
   struct i915_drm_batchbuffer *batch = i915_drm_batchbuffer(ibatch);
   unsigned used;
   int ret;

   /* MI_BATCH_BUFFER_END */
   i915_winsys_batchbuffer_dword_unchecked(ibatch, (0xA<<23));

   used = batch->base.ptr - batch->base.map;
   if (used & 4) {
      /* MI_NOOP */
      i915_winsys_batchbuffer_dword_unchecked(ibatch, 0);
      used += 4;
   }

   /* Do the sending to HW */
   ret = drm_intel_bo_subdata(batch->bo, 0, used, batch->base.map);
   if (ret == 0 && i915_drm_winsys(ibatch->iws)->send_cmd)
      ret = drm_intel_bo_exec(batch->bo, used, NULL, 0, 0);

   if (flags & I915_FLUSH_END_OF_FRAME)
      i915_drm_throttle(i915_drm_winsys(ibatch->iws));

   if (ret != 0 || i915_drm_winsys(ibatch->iws)->dump_cmd) {
      i915_dump_batchbuffer(ibatch);
      assert(ret == 0);
   }

   if (i915_drm_winsys(ibatch->iws)->dump_raw_file) {
      FILE *file = fopen(i915_drm_winsys(ibatch->iws)->dump_raw_file, "a");
      if (file) {
	 fwrite(batch->base.map, used, 1, file);
	 fclose(file);
      }
   }

#ifdef INTEL_RUN_SYNC
   drm_intel_bo_wait_rendering(batch->bo);
#endif

   if (fence) {
      ibatch->iws->fence_reference(ibatch->iws, fence, NULL);

#ifdef INTEL_RUN_SYNC
      /* we run synced to GPU so just pass null */
      (*fence) = i915_drm_fence_create(NULL);
#else
      (*fence) = i915_drm_fence_create(batch->bo);
#endif
   }

   i915_drm_batchbuffer_reset(batch);
}

static void
i915_drm_batchbuffer_destroy(struct i915_winsys_batchbuffer *ibatch)
{
   struct i915_drm_batchbuffer *batch = i915_drm_batchbuffer(ibatch);

   if (batch->bo)
      drm_intel_bo_unreference(batch->bo);

   FREE(batch->base.map);
   FREE(batch);
}

void i915_drm_winsys_init_batchbuffer_functions(struct i915_drm_winsys *idws)
{
   idws->base.batchbuffer_create = i915_drm_batchbuffer_create;
   idws->base.validate_buffers = i915_drm_batchbuffer_validate_buffers;
   idws->base.batchbuffer_reloc = i915_drm_batchbuffer_reloc;
   idws->base.batchbuffer_flush = i915_drm_batchbuffer_flush;
   idws->base.batchbuffer_destroy = i915_drm_batchbuffer_destroy;
}
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d154 1
a154 1
static void 
d162 2
a163 1
                            struct pipe_fence_handle **fence)
d184 2
a185 1
   i915_drm_throttle(i915_drm_winsys(ibatch->iws));
@


1.1
log
@Initial revision
@
text
@d7 2
a38 1
   int ret;
a46 12
#ifdef INTEL_MAP_BATCHBUFFER
#ifdef INTEL_MAP_GTT
   ret = drm_intel_gem_bo_map_gtt(batch->bo);
#else
   ret = drm_intel_bo_map(batch->bo, TRUE);
#endif
   assert(ret == 0);
   batch->base.map = batch->bo->virtual;
#else
   (void)ret;
#endif

a65 1
   batch->base.max_relocs = 300;/*INTEL_DEFAULT_RELOCS;*/
d74 20
d98 1
a98 1
                            unsigned pre_add, bool fenced)
a105 2
   assert(batch->base.relocs < batch->base.max_relocs);

d154 6
d183 2
d190 8
d231 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a6 2
#include <xf86drm.h>
#include <stdio.h>
d37 1
d46 12
d77 1
a85 20
static boolean
i915_drm_batchbuffer_validate_buffers(struct i915_winsys_batchbuffer *batch,
				      struct i915_winsys_buffer **buffer,
				      int num_of_buffers)
{
   struct i915_drm_batchbuffer *drm_batch = i915_drm_batchbuffer(batch);
   drm_intel_bo *bos[num_of_buffers + 1];
   int i, ret;

   bos[0] = drm_batch->bo;
   for (i = 0; i < num_of_buffers; i++)
      bos[i+1] = intel_bo(buffer[i]);

   ret = drm_intel_bufmgr_check_aperture_space(bos, num_of_buffers);
   if (ret != 0)
      return FALSE;

   return TRUE;
}

d90 1
a90 1
                            unsigned pre_add, boolean fenced)
d98 2
a148 6
i915_drm_throttle(struct i915_drm_winsys *idws)
{
   drmIoctl(idws->fd, DRM_IOCTL_I915_GEM_THROTTLE, NULL);
}

static void
d150 1
a150 2
                           struct pipe_fence_handle **fence,
                           enum i915_winsys_flush_flags flags)
a170 3
   if (flags & I915_FLUSH_END_OF_FRAME)
      i915_drm_throttle(i915_drm_winsys(ibatch->iws));

a175 8
   if (i915_drm_winsys(ibatch->iws)->dump_raw_file) {
      FILE *file = fopen(i915_drm_winsys(ibatch->iws)->dump_raw_file, "a");
      if (file) {
	 fwrite(batch->base.map, used, 1, file);
	 fclose(file);
      }
   }

a208 1
   idws->base.validate_buffers = i915_drm_batchbuffer_validate_buffers;
@

