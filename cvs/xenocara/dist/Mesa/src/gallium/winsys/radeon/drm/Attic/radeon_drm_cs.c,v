head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.42;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.56;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.4;
commitid	7kimTMT4YlQauAIU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.10.05.09.53.54;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.05.14.02.16;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.09;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.13.54;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.10.05.09.23.35;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.23;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.04.18;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.09.54;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.47.01;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright © 2008 Jérôme Glisse
 * Copyright © 2010 Marek Olšák <maraeo@@gmail.com>
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
 * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 */
/*
 * Authors:
 *      Marek Olšák <maraeo@@gmail.com>
 *
 * Based on work from libdrm_radeon by:
 *      Aapo Tahkola <aet@@rasterburn.org>
 *      Nicolai Haehnle <prefect_@@gmx.net>
 *      Jérôme Glisse <glisse@@freedesktop.org>
 */

/*
    This file replaces libdrm's radeon_cs_gem with our own implemention.
    It's optimized specifically for Radeon DRM.
    Reloc writes and space checking are faster and simpler than their
    counterparts in libdrm (the time complexity of all the functions
    is O(1) in nearly all scenarios, thanks to hashing).

    It works like this:

    cs_add_reloc(cs, buf, read_domain, write_domain) adds a new relocation and
    also adds the size of 'buf' to the used_gart and used_vram winsys variables
    based on the domains, which are simply or'd for the accounting purposes.
    The adding is skipped if the reloc is already present in the list, but it
    accounts any newly-referenced domains.

    cs_validate is then called, which just checks:
        used_vram/gart < vram/gart_size * 0.8
    The 0.8 number allows for some memory fragmentation. If the validation
    fails, the pipe driver flushes CS and tries do the validation again,
    i.e. it validates only that one operation. If it fails again, it drops
    the operation on the floor and prints some nasty message to stderr.
    (done in the pipe driver)

    cs_write_reloc(cs, buf) just writes a reloc that has been added using
    cs_add_reloc. The read_domain and write_domain parameters have been removed,
    because we already specify them in cs_add_reloc.
*/

#include "radeon_drm_cs.h"

#include "util/u_memory.h"
#include "os/os_time.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <xf86drm.h>


#define RELOC_DWORDS (sizeof(struct drm_radeon_cs_reloc) / sizeof(uint32_t))

static struct pipe_fence_handle *
radeon_cs_create_fence(struct radeon_winsys_cs *rcs);
static void radeon_fence_reference(struct pipe_fence_handle **dst,
                                   struct pipe_fence_handle *src);

static boolean radeon_init_cs_context(struct radeon_cs_context *csc,
                                      struct radeon_drm_winsys *ws)
{
    int i;

    csc->fd = ws->fd;
    csc->nrelocs = 512;
    csc->relocs_bo = (struct radeon_bo**)
                     CALLOC(1, csc->nrelocs * sizeof(struct radeon_bo*));
    if (!csc->relocs_bo) {
        return FALSE;
    }

    csc->relocs = (struct drm_radeon_cs_reloc*)
                  CALLOC(1, csc->nrelocs * sizeof(struct drm_radeon_cs_reloc));
    if (!csc->relocs) {
        FREE(csc->relocs_bo);
        return FALSE;
    }

    csc->chunks[0].chunk_id = RADEON_CHUNK_ID_IB;
    csc->chunks[0].length_dw = 0;
    csc->chunks[0].chunk_data = (uint64_t)(uintptr_t)csc->buf;
    csc->chunks[1].chunk_id = RADEON_CHUNK_ID_RELOCS;
    csc->chunks[1].length_dw = 0;
    csc->chunks[1].chunk_data = (uint64_t)(uintptr_t)csc->relocs;
    csc->chunks[2].chunk_id = RADEON_CHUNK_ID_FLAGS;
    csc->chunks[2].length_dw = 2;
    csc->chunks[2].chunk_data = (uint64_t)(uintptr_t)&csc->flags;

    csc->chunk_array[0] = (uint64_t)(uintptr_t)&csc->chunks[0];
    csc->chunk_array[1] = (uint64_t)(uintptr_t)&csc->chunks[1];
    csc->chunk_array[2] = (uint64_t)(uintptr_t)&csc->chunks[2];

    csc->cs.chunks = (uint64_t)(uintptr_t)csc->chunk_array;

    for (i = 0; i < Elements(csc->reloc_indices_hashlist); i++) {
        csc->reloc_indices_hashlist[i] = -1;
    }
    return TRUE;
}

static void radeon_cs_context_cleanup(struct radeon_cs_context *csc)
{
    unsigned i;

    for (i = 0; i < csc->crelocs; i++) {
        p_atomic_dec(&csc->relocs_bo[i]->num_cs_references);
        radeon_bo_reference(&csc->relocs_bo[i], NULL);
    }

    csc->crelocs = 0;
    csc->validated_crelocs = 0;
    csc->chunks[0].length_dw = 0;
    csc->chunks[1].length_dw = 0;
    csc->used_gart = 0;
    csc->used_vram = 0;

    for (i = 0; i < Elements(csc->reloc_indices_hashlist); i++) {
        csc->reloc_indices_hashlist[i] = -1;
    }
}

static void radeon_destroy_cs_context(struct radeon_cs_context *csc)
{
    radeon_cs_context_cleanup(csc);
    FREE(csc->relocs_bo);
    FREE(csc->relocs);
}


static struct radeon_winsys_cs *
radeon_drm_cs_create(struct radeon_winsys *rws,
                     enum ring_type ring_type,
                     void (*flush)(void *ctx, unsigned flags,
                                   struct pipe_fence_handle **fence),
                     void *flush_ctx,
                     struct radeon_winsys_cs_handle *trace_buf)
{
    struct radeon_drm_winsys *ws = radeon_drm_winsys(rws);
    struct radeon_drm_cs *cs;

    cs = CALLOC_STRUCT(radeon_drm_cs);
    if (!cs) {
        return NULL;
    }
    pipe_semaphore_init(&cs->flush_completed, 1);

    cs->ws = ws;
    cs->flush_cs = flush;
    cs->flush_data = flush_ctx;
    cs->trace_buf = (struct radeon_bo*)trace_buf;

    if (!radeon_init_cs_context(&cs->csc1, cs->ws)) {
        FREE(cs);
        return NULL;
    }
    if (!radeon_init_cs_context(&cs->csc2, cs->ws)) {
        radeon_destroy_cs_context(&cs->csc1);
        FREE(cs);
        return NULL;
    }

    /* Set the first command buffer as current. */
    cs->csc = &cs->csc1;
    cs->cst = &cs->csc2;
    cs->base.buf = cs->csc->buf;
    cs->base.ring_type = ring_type;

    p_atomic_inc(&ws->num_cs);
    return &cs->base;
}

#define OUT_CS(cs, value) (cs)->buf[(cs)->cdw++] = (value)

static INLINE void update_reloc(struct drm_radeon_cs_reloc *reloc,
                                enum radeon_bo_domain rd,
                                enum radeon_bo_domain wd,
                                unsigned priority,
                                enum radeon_bo_domain *added_domains)
{
    *added_domains = (rd | wd) & ~(reloc->read_domains | reloc->write_domain);

    reloc->read_domains |= rd;
    reloc->write_domain |= wd;
    reloc->flags = MAX2(reloc->flags, priority);
}

int radeon_get_reloc(struct radeon_cs_context *csc, struct radeon_bo *bo)
{
    unsigned hash = bo->handle & (Elements(csc->reloc_indices_hashlist)-1);
    int i = csc->reloc_indices_hashlist[hash];

    /* not found or found */
    if (i == -1 || csc->relocs_bo[i] == bo)
        return i;

    /* Hash collision, look for the BO in the list of relocs linearly. */
    for (i = csc->crelocs - 1; i >= 0; i--) {
        if (csc->relocs_bo[i] == bo) {
            /* Put this reloc in the hash list.
             * This will prevent additional hash collisions if there are
             * several consecutive get_reloc calls for the same buffer.
             *
             * Example: Assuming buffers A,B,C collide in the hash list,
             * the following sequence of relocs:
             *         AAAAAAAAAAABBBBBBBBBBBBBBCCCCCCCC
             * will collide here: ^ and here:   ^,
             * meaning that we should get very few collisions in the end. */
            csc->reloc_indices_hashlist[hash] = i;
            return i;
        }
    }
    return -1;
}

static unsigned radeon_add_reloc(struct radeon_drm_cs *cs,
                                 struct radeon_bo *bo,
                                 enum radeon_bo_usage usage,
                                 enum radeon_bo_domain domains,
                                 unsigned priority,
                                 enum radeon_bo_domain *added_domains)
{
    struct radeon_cs_context *csc = cs->csc;
    struct drm_radeon_cs_reloc *reloc;
    unsigned hash = bo->handle & (Elements(csc->reloc_indices_hashlist)-1);
    enum radeon_bo_domain rd = usage & RADEON_USAGE_READ ? domains : 0;
    enum radeon_bo_domain wd = usage & RADEON_USAGE_WRITE ? domains : 0;
    int i = -1;

    priority = MIN2(priority, 15);
    *added_domains = 0;

    i = radeon_get_reloc(csc, bo);

    if (i >= 0) {
        reloc = &csc->relocs[i];
        update_reloc(reloc, rd, wd, priority, added_domains);

        /* For async DMA, every add_reloc call must add a buffer to the list
         * no matter how many duplicates there are. This is due to the fact
         * the DMA CS checker doesn't use NOP packets for offset patching,
         * but always uses the i-th buffer from the list to patch the i-th
         * offset. If there are N offsets in a DMA CS, there must also be N
         * buffers in the relocation list.
         *
         * This doesn't have to be done if virtual memory is enabled,
         * because there is no offset patching with virtual memory.
         */
        if (cs->base.ring_type != RING_DMA || cs->ws->info.r600_virtual_address) {
            return i;
        }
    }

    /* New relocation, check if the backing array is large enough. */
    if (csc->crelocs >= csc->nrelocs) {
        uint32_t size;
        csc->nrelocs += 10;

        size = csc->nrelocs * sizeof(struct radeon_bo*);
        csc->relocs_bo = realloc(csc->relocs_bo, size);

        size = csc->nrelocs * sizeof(struct drm_radeon_cs_reloc);
        csc->relocs = realloc(csc->relocs, size);

        csc->chunks[1].chunk_data = (uint64_t)(uintptr_t)csc->relocs;
    }

    /* Initialize the new relocation. */
    csc->relocs_bo[csc->crelocs] = NULL;
    radeon_bo_reference(&csc->relocs_bo[csc->crelocs], bo);
    p_atomic_inc(&bo->num_cs_references);
    reloc = &csc->relocs[csc->crelocs];
    reloc->handle = bo->handle;
    reloc->read_domains = rd;
    reloc->write_domain = wd;
    reloc->flags = priority;

    csc->reloc_indices_hashlist[hash] = csc->crelocs;

    csc->chunks[1].length_dw += RELOC_DWORDS;

    *added_domains = rd | wd;
    return csc->crelocs++;
}

static unsigned radeon_drm_cs_add_reloc(struct radeon_winsys_cs *rcs,
                                        struct radeon_winsys_cs_handle *buf,
                                        enum radeon_bo_usage usage,
                                        enum radeon_bo_domain domains,
                                        enum radeon_bo_priority priority)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    struct radeon_bo *bo = (struct radeon_bo*)buf;
    enum radeon_bo_domain added_domains;
    unsigned index = radeon_add_reloc(cs, bo, usage, domains, priority, &added_domains);

    if (added_domains & RADEON_DOMAIN_GTT)
        cs->csc->used_gart += bo->base.size;
    if (added_domains & RADEON_DOMAIN_VRAM)
        cs->csc->used_vram += bo->base.size;

    return index;
}

static int radeon_drm_cs_get_reloc(struct radeon_winsys_cs *rcs,
                                   struct radeon_winsys_cs_handle *buf)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);

    return radeon_get_reloc(cs->csc, (struct radeon_bo*)buf);
}

static boolean radeon_drm_cs_validate(struct radeon_winsys_cs *rcs)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    boolean status =
        cs->csc->used_gart < cs->ws->info.gart_size * 0.8 &&
        cs->csc->used_vram < cs->ws->info.vram_size * 0.8;

    if (status) {
        cs->csc->validated_crelocs = cs->csc->crelocs;
    } else {
        /* Remove lately-added relocations. The validation failed with them
         * and the CS is about to be flushed because of that. Keep only
         * the already-validated relocations. */
        unsigned i;

        for (i = cs->csc->validated_crelocs; i < cs->csc->crelocs; i++) {
            p_atomic_dec(&cs->csc->relocs_bo[i]->num_cs_references);
            radeon_bo_reference(&cs->csc->relocs_bo[i], NULL);
        }
        cs->csc->crelocs = cs->csc->validated_crelocs;

        /* Flush if there are any relocs. Clean up otherwise. */
        if (cs->csc->crelocs) {
            cs->flush_cs(cs->flush_data, RADEON_FLUSH_ASYNC, NULL);
        } else {
            radeon_cs_context_cleanup(cs->csc);

            assert(cs->base.cdw == 0);
            if (cs->base.cdw != 0) {
                fprintf(stderr, "radeon: Unexpected error in %s.\n", __func__);
            }
        }
    }
    return status;
}

static boolean radeon_drm_cs_memory_below_limit(struct radeon_winsys_cs *rcs, uint64_t vram, uint64_t gtt)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    boolean status =
        (cs->csc->used_gart + gtt) < cs->ws->info.gart_size * 0.7 &&
        (cs->csc->used_vram + vram) < cs->ws->info.vram_size * 0.7;

    return status;
}

void radeon_drm_cs_emit_ioctl_oneshot(struct radeon_drm_cs *cs, struct radeon_cs_context *csc)
{
    unsigned i;

    if (drmCommandWriteRead(csc->fd, DRM_RADEON_CS,
                            &csc->cs, sizeof(struct drm_radeon_cs))) {
        if (debug_get_bool_option("RADEON_DUMP_CS", FALSE)) {
            unsigned i;

            fprintf(stderr, "radeon: The kernel rejected CS, dumping...\n");
            for (i = 0; i < csc->chunks[0].length_dw; i++) {
                fprintf(stderr, "0x%08X\n", csc->buf[i]);
            }
        } else {
            fprintf(stderr, "radeon: The kernel rejected CS, "
                    "see dmesg for more information.\n");
        }
    }

    if (cs->trace_buf) {
        radeon_dump_cs_on_lockup(cs, csc);
    }

    for (i = 0; i < csc->crelocs; i++)
        p_atomic_dec(&csc->relocs_bo[i]->num_active_ioctls);

    radeon_cs_context_cleanup(csc);
}

/*
 * Make sure previous submission of this cs are completed
 */
void radeon_drm_cs_sync_flush(struct radeon_winsys_cs *rcs)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);

    /* Wait for any pending ioctl to complete. */
    if (cs->ws->thread) {
        pipe_semaphore_wait(&cs->flush_completed);
        pipe_semaphore_signal(&cs->flush_completed);
    }
}

DEBUG_GET_ONCE_BOOL_OPTION(noop, "RADEON_NOOP", FALSE)

static void radeon_drm_cs_flush(struct radeon_winsys_cs *rcs,
                                unsigned flags,
                                struct pipe_fence_handle **fence,
                                uint32_t cs_trace_id)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    struct radeon_cs_context *tmp;

    switch (cs->base.ring_type) {
    case RING_DMA:
        /* pad DMA ring to 8 DWs */
        if (cs->ws->info.chip_class <= SI) {
            while (rcs->cdw & 7)
                OUT_CS(&cs->base, 0xf0000000); /* NOP packet */
        } else {
            while (rcs->cdw & 7)
                OUT_CS(&cs->base, 0x00000000); /* NOP packet */
        }
        break;
    case RING_GFX:
        /* pad DMA ring to 8 DWs to meet CP fetch alignment requirements
         * r6xx, requires at least 4 dw alignment to avoid a hw bug.
         * hawaii with old firmware needs type2 nop packet.
         * accel_working2 with value 3 indicates the new firmware.
         */
        if (cs->ws->info.chip_class <= SI ||
            (cs->ws->info.family == CHIP_HAWAII &&
             cs->ws->accel_working2 < 3)) {
            while (rcs->cdw & 7)
                OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
        } else {
            while (rcs->cdw & 7)
                OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
        }
        break;
    case RING_UVD:
        while (rcs->cdw & 15)
            OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
        break;
    default:
        break;
    }

    if (rcs->cdw > RADEON_MAX_CMDBUF_DWORDS) {
       fprintf(stderr, "radeon: command stream overflowed\n");
    }

    if (fence) {
        radeon_fence_reference(fence, NULL);
        *fence = radeon_cs_create_fence(rcs);
    }

    radeon_drm_cs_sync_flush(rcs);

    /* Swap command streams. */
    tmp = cs->csc;
    cs->csc = cs->cst;
    cs->cst = tmp;

    cs->cst->cs_trace_id = cs_trace_id;

    /* If the CS is not empty or overflowed, emit it in a separate thread. */
    if (cs->base.cdw && cs->base.cdw <= RADEON_MAX_CMDBUF_DWORDS && !debug_get_option_noop()) {
        unsigned i, crelocs;

        crelocs = cs->cst->crelocs;

        cs->cst->chunks[0].length_dw = cs->base.cdw;

        for (i = 0; i < crelocs; i++) {
            /* Update the number of active asynchronous CS ioctls for the buffer. */
            p_atomic_inc(&cs->cst->relocs_bo[i]->num_active_ioctls);
        }

        switch (cs->base.ring_type) {
        case RING_DMA:
            cs->cst->flags[0] = 0;
            cs->cst->flags[1] = RADEON_CS_RING_DMA;
            cs->cst->cs.num_chunks = 3;
            if (cs->ws->info.r600_virtual_address) {
                cs->cst->flags[0] |= RADEON_CS_USE_VM;
            }
            break;

        case RING_UVD:
            cs->cst->flags[0] = 0;
            cs->cst->flags[1] = RADEON_CS_RING_UVD;
            cs->cst->cs.num_chunks = 3;
            break;

        case RING_VCE:
            cs->cst->flags[0] = 0;
            cs->cst->flags[1] = RADEON_CS_RING_VCE;
            cs->cst->cs.num_chunks = 3;
            break;

        default:
        case RING_GFX:
            cs->cst->flags[0] = 0;
            cs->cst->flags[1] = RADEON_CS_RING_GFX;
            cs->cst->cs.num_chunks = 2;
            if (flags & RADEON_FLUSH_KEEP_TILING_FLAGS) {
                cs->cst->flags[0] |= RADEON_CS_KEEP_TILING_FLAGS;
                cs->cst->cs.num_chunks = 3;
            }
            if (cs->ws->info.r600_virtual_address) {
                cs->cst->flags[0] |= RADEON_CS_USE_VM;
                cs->cst->cs.num_chunks = 3;
            }
            if (flags & RADEON_FLUSH_END_OF_FRAME) {
                cs->cst->flags[0] |= RADEON_CS_END_OF_FRAME;
                cs->cst->cs.num_chunks = 3;
            }
            if (flags & RADEON_FLUSH_COMPUTE) {
                cs->cst->flags[1] = RADEON_CS_RING_COMPUTE;
                cs->cst->cs.num_chunks = 3;
            }
            break;
        }

        if (cs->ws->thread) {
            pipe_semaphore_wait(&cs->flush_completed);
            radeon_drm_ws_queue_cs(cs->ws, cs);
            if (!(flags & RADEON_FLUSH_ASYNC))
                radeon_drm_cs_sync_flush(rcs);
        } else {
            radeon_drm_cs_emit_ioctl_oneshot(cs, cs->cst);
        }
    } else {
        radeon_cs_context_cleanup(cs->cst);
    }

    /* Prepare a new CS. */
    cs->base.buf = cs->csc->buf;
    cs->base.cdw = 0;

    cs->ws->num_cs_flushes++;
}

static void radeon_drm_cs_destroy(struct radeon_winsys_cs *rcs)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);

    radeon_drm_cs_sync_flush(rcs);
    pipe_semaphore_destroy(&cs->flush_completed);
    radeon_cs_context_cleanup(&cs->csc1);
    radeon_cs_context_cleanup(&cs->csc2);
    p_atomic_dec(&cs->ws->num_cs);
    radeon_destroy_cs_context(&cs->csc1);
    radeon_destroy_cs_context(&cs->csc2);
    FREE(cs);
}

static boolean radeon_bo_is_referenced(struct radeon_winsys_cs *rcs,
                                       struct radeon_winsys_cs_handle *_buf,
                                       enum radeon_bo_usage usage)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    struct radeon_bo *bo = (struct radeon_bo*)_buf;
    int index;

    if (!bo->num_cs_references)
        return FALSE;

    index = radeon_get_reloc(cs->csc, bo);
    if (index == -1)
        return FALSE;

    if ((usage & RADEON_USAGE_WRITE) && cs->csc->relocs[index].write_domain)
        return TRUE;
    if ((usage & RADEON_USAGE_READ) && cs->csc->relocs[index].read_domains)
        return TRUE;

    return FALSE;
}

/* FENCES */

static struct pipe_fence_handle *
radeon_cs_create_fence(struct radeon_winsys_cs *rcs)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    struct pb_buffer *fence;

    /* Create a fence, which is a dummy BO. */
    fence = cs->ws->base.buffer_create(&cs->ws->base, 1, 1, TRUE,
                                       RADEON_DOMAIN_GTT);
    /* Add the fence as a dummy relocation. */
    cs->ws->base.cs_add_reloc(rcs, cs->ws->base.buffer_get_cs_handle(fence),
                              RADEON_USAGE_READWRITE, RADEON_DOMAIN_GTT,
                              RADEON_PRIO_MIN);
    return (struct pipe_fence_handle*)fence;
}

static bool radeon_fence_wait(struct radeon_winsys *ws,
                              struct pipe_fence_handle *fence,
                              uint64_t timeout)
{
    struct pb_buffer *rfence = (struct pb_buffer*)fence;

    if (timeout == 0)
        return !ws->buffer_is_busy(rfence, RADEON_USAGE_READWRITE);

    if (timeout != PIPE_TIMEOUT_INFINITE) {
        int64_t start_time = os_time_get();

        /* Convert to microseconds. */
        timeout /= 1000;

        /* Wait in a loop. */
        while (ws->buffer_is_busy(rfence, RADEON_USAGE_READWRITE)) {
            if (os_time_get() - start_time >= timeout) {
                return FALSE;
            }
            os_time_sleep(10);
        }
        return TRUE;
    }

    ws->buffer_wait(rfence, RADEON_USAGE_READWRITE);
    return TRUE;
}

static void radeon_fence_reference(struct pipe_fence_handle **dst,
                                   struct pipe_fence_handle *src)
{
    pb_reference((struct pb_buffer**)dst, (struct pb_buffer*)src);
}

void radeon_drm_cs_init_functions(struct radeon_drm_winsys *ws)
{
    ws->base.cs_create = radeon_drm_cs_create;
    ws->base.cs_destroy = radeon_drm_cs_destroy;
    ws->base.cs_add_reloc = radeon_drm_cs_add_reloc;
    ws->base.cs_get_reloc = radeon_drm_cs_get_reloc;
    ws->base.cs_validate = radeon_drm_cs_validate;
    ws->base.cs_memory_below_limit = radeon_drm_cs_memory_below_limit;
    ws->base.cs_flush = radeon_drm_cs_flush;
    ws->base.cs_is_buffer_referenced = radeon_bo_is_referenced;
    ws->base.cs_sync_flush = radeon_drm_cs_sync_flush;
    ws->base.fence_wait = radeon_fence_wait;
    ws->base.fence_reference = radeon_fence_reference;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d613 1
a613 1
                                       RADEON_DOMAIN_GTT, 0);
@


1.5
log
@Merge Mesa 10.2.7
@
text
@d613 1
a613 1
                                       RADEON_DOMAIN_GTT);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d158 1
a158 1
				   struct pipe_fence_handle **fence),
d199 4
a202 4
				enum radeon_bo_domain rd,
				enum radeon_bo_domain wd,
				unsigned priority,
				enum radeon_bo_domain *added_domains)
d437 9
a445 9
	    /* pad DMA ring to 8 DWs */
	    if (cs->ws->info.chip_class <= SI) {
		    while (rcs->cdw & 7)
			    OUT_CS(&cs->base, 0xf0000000); /* NOP packet */
	    } else {
		    while (rcs->cdw & 7)
			    OUT_CS(&cs->base, 0x00000000); /* NOP packet */
	    }
	    break;
d447 15
a461 11
	    /* pad DMA ring to 8 DWs to meet CP fetch alignment requirements
	     * r6xx, requires at least 4 dw alignment to avoid a hw bug.
	     */
	    if (cs->ws->info.chip_class <= SI) {
		    while (rcs->cdw & 7)
			    OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
	    } else {
		    while (rcs->cdw & 7)
			    OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
	    }
	    break;
d463 3
a465 3
            while (rcs->cdw & 15)
		OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
	    break;
d467 1
a467 1
	    break;
@


1.3
log
@Merge Mesa 9.2.1
@
text
@d68 1
a74 7
/*
 * this are copy from radeon_drm, once an updated libdrm is released
 * we should bump configure.ac requirement for it and remove the following
 * field
 */
#ifndef RADEON_CHUNK_ID_FLAGS
#define RADEON_CHUNK_ID_FLAGS       0x03
d76 1
a76 22
/* The first dword of RADEON_CHUNK_ID_FLAGS is a uint32 of these flags: */
#define RADEON_CS_KEEP_TILING_FLAGS 0x01
#endif

#ifndef RADEON_CS_USE_VM
#define RADEON_CS_USE_VM            0x02
/* The second dword of RADEON_CHUNK_ID_FLAGS is a uint32 that sets the ring type */
#define RADEON_CS_RING_GFX          0
#define RADEON_CS_RING_COMPUTE      1
#endif

#ifndef RADEON_CS_RING_DMA
#define RADEON_CS_RING_DMA          2
#endif

#ifndef RADEON_CS_RING_UVD
#define RADEON_CS_RING_UVD          3
#endif

#ifndef RADEON_CS_END_OF_FRAME
#define RADEON_CS_END_OF_FRAME      0x04
#endif
d78 4
a81 2

#define RELOC_DWORDS (sizeof(struct drm_radeon_cs_reloc) / sizeof(uint32_t))
d86 2
d118 4
d140 4
a143 1
    memset(csc->is_handle_added, 0, sizeof(csc->is_handle_added));
d154 7
a160 3
static struct radeon_winsys_cs *radeon_drm_cs_create(struct radeon_winsys *rws,
                                                     enum ring_type ring_type,
                                                     struct radeon_winsys_cs_handle *trace_buf)
d169 1
a169 1
    pipe_semaphore_init(&cs->flush_completed, 0);
d172 2
d198 5
a202 4
static INLINE void update_reloc_domains(struct drm_radeon_cs_reloc *reloc,
                                        enum radeon_bo_domain rd,
                                        enum radeon_bo_domain wd,
                                        enum radeon_bo_domain *added_domains)
d208 1
d213 2
a214 3
    struct drm_radeon_cs_reloc *reloc;
    unsigned i;
    unsigned hash = bo->handle & (sizeof(csc->is_handle_added)-1);
d216 17
a232 4
    if (csc->is_handle_added[hash]) {
        i = csc->reloc_indices_hashlist[hash];
        reloc = &csc->relocs[i];
        if (reloc->handle == bo->handle) {
a234 20

        /* Hash collision, look for the BO in the list of relocs linearly. */
        for (i = csc->crelocs; i != 0;) {
            --i;
            reloc = &csc->relocs[i];
            if (reloc->handle == bo->handle) {
                /* Put this reloc in the hash list.
                 * This will prevent additional hash collisions if there are
                 * several consecutive get_reloc calls for the same buffer.
                 *
                 * Example: Assuming buffers A,B,C collide in the hash list,
                 * the following sequence of relocs:
                 *         AAAAAAAAAAABBBBBBBBBBBBBBCCCCCCCC
                 * will collide here: ^ and here:   ^,
                 * meaning that we should get very few collisions in the end. */
                csc->reloc_indices_hashlist[hash] = i;
                /*printf("write_reloc collision, hash: %i, handle: %i\n", hash, bo->handle);*/
                return i;
            }
        }
a235 1

d243 1
d248 1
a248 1
    unsigned hash = bo->handle & (sizeof(csc->is_handle_added)-1);
d251 1
a251 2
    bool update_hash = TRUE;
    int i;
d253 1
d255 4
a258 2
    if (csc->is_handle_added[hash]) {
        i = csc->reloc_indices_hashlist[hash];
d260 1
a260 10
        if (reloc->handle != bo->handle) {
            /* Hash collision, look for the BO in the list of relocs linearly. */
            for (i = csc->crelocs - 1; i >= 0; i--) {
                reloc = &csc->relocs[i];
                if (reloc->handle == bo->handle) {
                    /*printf("write_reloc collision, hash: %i, handle: %i\n", hash, bo->handle);*/
                    break;
                }
            }
        }
d262 12
a273 16
        if (i >= 0) {
            /* On DMA ring we need to emit as many relocation as there is use of the bo
             * thus each time this function is call we should grow add again the bo to
             * the relocation buffer
             *
             * Do not update the hash table if it's dma ring, so that first hash always point
             * to first bo relocation which will the one used by the kernel. Following relocation
             * will be ignore by the kernel memory placement (but still use by the kernel to
             * update the cmd stream with proper buffer offset).
             */
            update_hash = FALSE;
            update_reloc_domains(reloc, rd, wd, added_domains);
            if (cs->base.ring_type != RING_DMA) {
                csc->reloc_indices_hashlist[hash] = i;
                return i;
            }
d299 1
a299 1
    reloc->flags = 0;
d301 1
a301 4
    csc->is_handle_added[hash] = TRUE;
    if (update_hash) {
        csc->reloc_indices_hashlist[hash] = csc->crelocs;
    }
d312 2
a313 1
                                        enum radeon_bo_domain domains)
d318 1
a318 1
    unsigned index = radeon_add_reloc(cs, bo, usage, domains, &added_domains);
d328 8
d359 1
a359 1
            cs->flush_cs(cs->flush_data, RADEON_FLUSH_ASYNC);
a381 16
static void radeon_drm_cs_write_reloc(struct radeon_winsys_cs *rcs,
                                      struct radeon_winsys_cs_handle *buf)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    struct radeon_bo *bo = (struct radeon_bo*)buf;
    unsigned index = radeon_get_reloc(cs->csc, bo);

    if (index == -1) {
        fprintf(stderr, "radeon: Cannot get a relocation in %s.\n", __func__);
        return;
    }

    OUT_CS(&cs->base, 0xc0001000);
    OUT_CS(&cs->base, index * RELOC_DWORDS);
}

d419 1
a419 1
    if (cs->ws->thread && cs->flush_started) {
d421 1
a421 1
        cs->flush_started = 0;
d427 4
a430 1
static void radeon_drm_cs_flush(struct radeon_winsys_cs *rcs, unsigned flags, uint32_t cs_trace_id)
d450 3
a452 8
            if (flags & RADEON_FLUSH_COMPUTE) {
		    if (cs->ws->info.chip_class <= SI) {
			    while (rcs->cdw & 7)
				    OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
		    } else {
			    while (rcs->cdw & 7)
				    OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
		    }
d455 1
a455 1
			    OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
d458 6
d470 5
d477 1
a477 1
    /* Flip command streams. */
d486 3
a488 1
        unsigned i, crelocs = cs->cst->crelocs;
d513 6
d543 2
a544 2
        if (cs->ws->thread && (flags & RADEON_FLUSH_ASYNC)) {
            cs->flush_started = 1;
d546 2
a548 7
            pipe_mutex_lock(cs->ws->cs_stack_lock);
            if (cs->ws->thread) {
                while (p_atomic_read(&cs->ws->ncs)) {
                    pipe_condvar_wait(cs->ws->cs_queue_empty, cs->ws->cs_stack_lock);
                }
            }
            pipe_mutex_unlock(cs->ws->cs_stack_lock);
d558 2
a575 10
static void radeon_drm_cs_set_flush(struct radeon_winsys_cs *rcs,
                                    void (*flush)(void *ctx, unsigned flags),
                                    void *user)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);

    cs->flush_cs = flush;
    cs->flush_data = user;
}

d599 53
d657 1
a659 1
    ws->base.cs_write_reloc = radeon_drm_cs_write_reloc;
a660 1
    ws->base.cs_set_flush_callback = radeon_drm_cs_set_flush;
d663 2
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d469 30
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d74 32
d108 2
a109 1
static boolean radeon_init_cs_context(struct radeon_cs_context *csc, int fd)
d111 1
a111 1
    csc->fd = fd;
d132 3
d138 1
a139 1
    csc->cs.num_chunks = 2;
d169 4
a172 1
static struct radeon_winsys_cs *radeon_drm_cs_create(struct radeon_winsys *rws)
d181 1
d184 1
d186 1
a186 1
    if (!radeon_init_cs_context(&cs->csc1, cs->ws->fd)) {
d190 1
a190 1
    if (!radeon_init_cs_context(&cs->csc2, cs->ws->fd)) {
d200 1
d208 4
a211 4
static INLINE void update_domains(struct drm_radeon_cs_reloc *reloc,
                                  enum radeon_bo_domain rd,
                                  enum radeon_bo_domain wd,
                                  enum radeon_bo_domain *added_domains)
d215 2
a216 10
    if (reloc->read_domains & wd) {
        reloc->read_domains = rd;
        reloc->write_domain = wd;
    } else if (rd & reloc->write_domain) {
        reloc->read_domains = rd;
        reloc->write_domain |= wd;
    } else {
        reloc->read_domains |= rd;
        reloc->write_domain |= wd;
    }
d226 2
a227 1
        reloc = csc->relocs_hashlist[hash];
d229 1
a229 1
            return csc->reloc_indices_hashlist[hash];
d239 1
a239 1
                 * several subsequent get_reloc calls of the same buffer.
a245 1
                csc->relocs_hashlist[hash] = reloc;
d256 5
a260 5
static void radeon_add_reloc(struct radeon_cs_context *csc,
                             struct radeon_bo *bo,
                             enum radeon_bo_domain rd,
                             enum radeon_bo_domain wd,
                             enum radeon_bo_domain *added_domains)
d262 1
a263 1
    unsigned i;
d265 4
d270 1
d272 11
a282 4
        reloc = csc->relocs_hashlist[hash];
        if (reloc->handle == bo->handle) {
            update_domains(reloc, rd, wd, added_domains);
            return;
d285 13
a297 8
        /* Hash collision, look for the BO in the list of relocs linearly. */
        for (i = csc->crelocs; i != 0;) {
            --i;
            reloc = &csc->relocs[i];
            if (reloc->handle == bo->handle) {
                update_domains(reloc, rd, wd, added_domains);

                csc->relocs_hashlist[hash] = reloc;
d299 1
a299 2
                /*printf("write_reloc collision, hash: %i, handle: %i\n", hash, bo->handle);*/
                return;
d310 1
a310 1
        csc->relocs_bo = (struct radeon_bo**)realloc(csc->relocs_bo, size);
d313 1
a313 1
        csc->relocs = (struct drm_radeon_cs_reloc*)realloc(csc->relocs, size);
d329 3
a331 2
    csc->relocs_hashlist[hash] = reloc;
    csc->reloc_indices_hashlist[hash] = csc->crelocs;
a333 1
    csc->crelocs++;
d336 1
d339 4
a342 4
static void radeon_drm_cs_add_reloc(struct radeon_winsys_cs *rcs,
                                    struct radeon_winsys_cs_handle *buf,
                                    enum radeon_bo_domain rd,
                                    enum radeon_bo_domain wd)
d347 1
a347 5

    radeon_add_reloc(cs->csc, bo, rd, wd, &added_domains);

    if (!added_domains)
        return;
d350 1
a350 1
        cs->csc->used_gart += bo->size;
d352 3
a354 1
        cs->csc->used_vram += bo->size;
d361 2
a362 2
        cs->csc->used_gart < cs->ws->gart_size * 0.8 &&
        cs->csc->used_vram < cs->ws->vram_size * 0.8;
d393 10
a407 1

d419 1
a419 1
static PIPE_THREAD_ROUTINE(radeon_drm_cs_emit_ioctl, param)
a420 1
    struct radeon_cs_context *csc = (struct radeon_cs_context*)param;
d438 4
d444 2
a445 1
    return NULL;
d448 4
a451 1
void radeon_drm_cs_sync_flush(struct radeon_drm_cs *cs)
d453 2
d456 3
a458 3
    if (cs->thread) {
        pipe_thread_wait(cs->thread);
        cs->thread = 0;
d462 1
a462 1
DEBUG_GET_ONCE_BOOL_OPTION(thread, "RADEON_THREAD", TRUE)
d464 1
a464 1
static void radeon_drm_cs_flush(struct radeon_winsys_cs *rcs, unsigned flags)
d469 12
a480 1
    radeon_drm_cs_sync_flush(cs);
d482 3
a484 3
    /* If the CS is not empty, emit it in a newly-spawned thread. */
    if (cs->base.cdw) {
        unsigned i, crelocs = cs->csc->crelocs;
d486 1
a486 1
        cs->csc->chunks[0].length_dw = cs->base.cdw;
d490 2
a491 1
            p_atomic_inc(&cs->csc->relocs_bo[i]->num_active_ioctls);
d493 32
a524 3
            /* Update whether the buffer is busy for write. */
            if (cs->csc->relocs[i].write_domain) {
                cs->csc->relocs_bo[i]->busy_for_write = TRUE;
d526 5
d533 3
a535 4
        if (cs->ws->num_cpus > 1 && debug_get_option_thread() &&
            (flags & RADEON_FLUSH_ASYNC)) {
            cs->thread = pipe_thread_create(radeon_drm_cs_emit_ioctl, cs->csc);
            assert(cs->thread);
d537 8
a544 1
            radeon_drm_cs_emit_ioctl(cs->csc);
d546 2
a549 5
    /* Flip command streams. */
    tmp = cs->csc;
    cs->csc = cs->cst;
    cs->cst = tmp;

a550 2
    radeon_cs_context_cleanup(cs->csc);

d558 3
a560 1
    radeon_drm_cs_sync_flush(cs);
d574 1
d580 2
a581 1
                                       struct radeon_winsys_cs_handle *_buf)
d585 13
d599 1
a599 1
    return radeon_bo_is_referenced_by_cs(cs, bo);
d608 1
d611 1
a611 1
    ws->base.cs_set_flush = radeon_drm_cs_set_flush;
d613 1
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@a73 32
/*
 * this are copy from radeon_drm, once an updated libdrm is released
 * we should bump configure.ac requirement for it and remove the following
 * field
 */
#ifndef RADEON_CHUNK_ID_FLAGS
#define RADEON_CHUNK_ID_FLAGS       0x03

/* The first dword of RADEON_CHUNK_ID_FLAGS is a uint32 of these flags: */
#define RADEON_CS_KEEP_TILING_FLAGS 0x01
#endif

#ifndef RADEON_CS_USE_VM
#define RADEON_CS_USE_VM            0x02
/* The second dword of RADEON_CHUNK_ID_FLAGS is a uint32 that sets the ring type */
#define RADEON_CS_RING_GFX          0
#define RADEON_CS_RING_COMPUTE      1
#endif

#ifndef RADEON_CS_RING_DMA
#define RADEON_CS_RING_DMA          2
#endif

#ifndef RADEON_CS_RING_UVD
#define RADEON_CS_RING_UVD          3
#endif

#ifndef RADEON_CS_END_OF_FRAME
#define RADEON_CS_END_OF_FRAME      0x04
#endif


d76 1
a76 2
static boolean radeon_init_cs_context(struct radeon_cs_context *csc,
                                      struct radeon_drm_winsys *ws)
d78 1
a78 1
    csc->fd = ws->fd;
a98 3
    csc->chunks[2].chunk_id = RADEON_CHUNK_ID_FLAGS;
    csc->chunks[2].length_dw = 2;
    csc->chunks[2].chunk_data = (uint64_t)(uintptr_t)&csc->flags;
a101 1
    csc->chunk_array[2] = (uint64_t)(uintptr_t)&csc->chunks[2];
d103 1
d133 1
a133 4

static struct radeon_winsys_cs *radeon_drm_cs_create(struct radeon_winsys *rws,
                                                     enum ring_type ring_type,
                                                     struct radeon_winsys_cs_handle *trace_buf)
a141 1
    pipe_semaphore_init(&cs->flush_completed, 0);
a143 1
    cs->trace_buf = (struct radeon_bo*)trace_buf;
d145 1
a145 1
    if (!radeon_init_cs_context(&cs->csc1, cs->ws)) {
d149 1
a149 1
    if (!radeon_init_cs_context(&cs->csc2, cs->ws)) {
a158 1
    cs->base.ring_type = ring_type;
d166 4
a169 4
static INLINE void update_reloc_domains(struct drm_radeon_cs_reloc *reloc,
                                        enum radeon_bo_domain rd,
                                        enum radeon_bo_domain wd,
                                        enum radeon_bo_domain *added_domains)
d173 10
a182 2
    reloc->read_domains |= rd;
    reloc->write_domain |= wd;
d192 1
a192 2
        i = csc->reloc_indices_hashlist[hash];
        reloc = &csc->relocs[i];
d194 1
a194 1
            return i;
d204 1
a204 1
                 * several consecutive get_reloc calls for the same buffer.
d211 1
d222 5
a226 5
static unsigned radeon_add_reloc(struct radeon_drm_cs *cs,
                                 struct radeon_bo *bo,
                                 enum radeon_bo_usage usage,
                                 enum radeon_bo_domain domains,
                                 enum radeon_bo_domain *added_domains)
a227 1
    struct radeon_cs_context *csc = cs->csc;
d229 1
a230 4
    enum radeon_bo_domain rd = usage & RADEON_USAGE_READ ? domains : 0;
    enum radeon_bo_domain wd = usage & RADEON_USAGE_WRITE ? domains : 0;
    bool update_hash = TRUE;
    int i;
a231 1
    *added_domains = 0;
d233 4
a236 11
        i = csc->reloc_indices_hashlist[hash];
        reloc = &csc->relocs[i];
        if (reloc->handle != bo->handle) {
            /* Hash collision, look for the BO in the list of relocs linearly. */
            for (i = csc->crelocs - 1; i >= 0; i--) {
                reloc = &csc->relocs[i];
                if (reloc->handle == bo->handle) {
                    /*printf("write_reloc collision, hash: %i, handle: %i\n", hash, bo->handle);*/
                    break;
                }
            }
d239 8
a246 13
        if (i >= 0) {
            /* On DMA ring we need to emit as many relocation as there is use of the bo
             * thus each time this function is call we should grow add again the bo to
             * the relocation buffer
             *
             * Do not update the hash table if it's dma ring, so that first hash always point
             * to first bo relocation which will the one used by the kernel. Following relocation
             * will be ignore by the kernel memory placement (but still use by the kernel to
             * update the cmd stream with proper buffer offset).
             */
            update_hash = FALSE;
            update_reloc_domains(reloc, rd, wd, added_domains);
            if (cs->base.ring_type != RING_DMA) {
d248 2
a249 1
                return i;
d260 1
a260 1
        csc->relocs_bo = realloc(csc->relocs_bo, size);
d263 1
a263 1
        csc->relocs = realloc(csc->relocs, size);
d279 2
a280 3
    if (update_hash) {
        csc->reloc_indices_hashlist[hash] = csc->crelocs;
    }
d283 1
a285 1
    return csc->crelocs++;
d288 4
a291 4
static unsigned radeon_drm_cs_add_reloc(struct radeon_winsys_cs *rcs,
                                        struct radeon_winsys_cs_handle *buf,
                                        enum radeon_bo_usage usage,
                                        enum radeon_bo_domain domains)
d296 5
a300 1
    unsigned index = radeon_add_reloc(cs, bo, usage, domains, &added_domains);
d303 1
a303 1
        cs->csc->used_gart += bo->base.size;
d305 1
a305 3
        cs->csc->used_vram += bo->base.size;

    return index;
d312 2
a313 2
        cs->csc->used_gart < cs->ws->info.gart_size * 0.8 &&
        cs->csc->used_vram < cs->ws->info.vram_size * 0.8;
a343 10
static boolean radeon_drm_cs_memory_below_limit(struct radeon_winsys_cs *rcs, uint64_t vram, uint64_t gtt)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    boolean status =
        (cs->csc->used_gart + gtt) < cs->ws->info.gart_size * 0.7 &&
        (cs->csc->used_vram + vram) < cs->ws->info.vram_size * 0.7;

    return status;
}

d349 1
d361 1
a361 1
void radeon_drm_cs_emit_ioctl_oneshot(struct radeon_drm_cs *cs, struct radeon_cs_context *csc)
d363 1
a380 4
    if (cs->trace_buf) {
        radeon_dump_cs_on_lockup(cs, csc);
    }

d383 1
a383 2

    radeon_cs_context_cleanup(csc);
d386 1
a386 4
/*
 * Make sure previous submission of this cs are completed
 */
void radeon_drm_cs_sync_flush(struct radeon_winsys_cs *rcs)
a387 2
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);

d389 3
a391 3
    if (cs->ws->thread && cs->flush_started) {
        pipe_semaphore_wait(&cs->flush_completed);
        cs->flush_started = 0;
d395 1
a395 1
DEBUG_GET_ONCE_BOOL_OPTION(noop, "RADEON_NOOP", FALSE)
d397 1
a397 1
static void radeon_drm_cs_flush(struct radeon_winsys_cs *rcs, unsigned flags, uint32_t cs_trace_id)
d402 1
a402 12
    if (rcs->cdw > RADEON_MAX_CMDBUF_DWORDS) {
       fprintf(stderr, "radeon: command stream overflowed\n");
    }

    radeon_drm_cs_sync_flush(rcs);

    /* Flip command streams. */
    tmp = cs->csc;
    cs->csc = cs->cst;
    cs->cst = tmp;

    cs->cst->cs_trace_id = cs_trace_id;
d404 3
a406 3
    /* If the CS is not empty or overflowed, emit it in a separate thread. */
    if (cs->base.cdw && cs->base.cdw <= RADEON_MAX_CMDBUF_DWORDS && !debug_get_option_noop()) {
        unsigned i, crelocs = cs->cst->crelocs;
d408 1
a408 1
        cs->cst->chunks[0].length_dw = cs->base.cdw;
d412 1
a412 2
            p_atomic_inc(&cs->cst->relocs_bo[i]->num_active_ioctls);
        }
d414 3
a416 32
        switch (cs->base.ring_type) {
        case RING_DMA:
            cs->cst->flags[0] = 0;
            cs->cst->flags[1] = RADEON_CS_RING_DMA;
            cs->cst->cs.num_chunks = 3;
            if (cs->ws->info.r600_virtual_address) {
                cs->cst->flags[0] |= RADEON_CS_USE_VM;
            }
            break;

        case RING_UVD:
            cs->cst->flags[0] = 0;
            cs->cst->flags[1] = RADEON_CS_RING_UVD;
            cs->cst->cs.num_chunks = 3;
            break;

        default:
        case RING_GFX:
            cs->cst->flags[0] = 0;
            cs->cst->flags[1] = RADEON_CS_RING_GFX;
            cs->cst->cs.num_chunks = 2;
            if (flags & RADEON_FLUSH_KEEP_TILING_FLAGS) {
                cs->cst->flags[0] |= RADEON_CS_KEEP_TILING_FLAGS;
                cs->cst->cs.num_chunks = 3;
            }
            if (cs->ws->info.r600_virtual_address) {
                cs->cst->flags[0] |= RADEON_CS_USE_VM;
                cs->cst->cs.num_chunks = 3;
            }
            if (flags & RADEON_FLUSH_END_OF_FRAME) {
                cs->cst->flags[0] |= RADEON_CS_END_OF_FRAME;
                cs->cst->cs.num_chunks = 3;
a417 5
            if (flags & RADEON_FLUSH_COMPUTE) {
                cs->cst->flags[1] = RADEON_CS_RING_COMPUTE;
                cs->cst->cs.num_chunks = 3;
            }
            break;
d420 4
a423 3
        if (cs->ws->thread && (flags & RADEON_FLUSH_ASYNC)) {
            cs->flush_started = 1;
            radeon_drm_ws_queue_cs(cs->ws, cs);
d425 1
a425 8
            pipe_mutex_lock(cs->ws->cs_stack_lock);
            if (cs->ws->thread) {
                while (p_atomic_read(&cs->ws->ncs)) {
                    pipe_condvar_wait(cs->ws->cs_queue_empty, cs->ws->cs_stack_lock);
                }
            }
            pipe_mutex_unlock(cs->ws->cs_stack_lock);
            radeon_drm_cs_emit_ioctl_oneshot(cs, cs->cst);
a426 2
    } else {
        radeon_cs_context_cleanup(cs->cst);
d429 5
d435 2
d444 1
a444 3

    radeon_drm_cs_sync_flush(rcs);
    pipe_semaphore_destroy(&cs->flush_completed);
a457 1

d463 1
a463 2
                                       struct radeon_winsys_cs_handle *_buf,
                                       enum radeon_bo_usage usage)
a466 13
    int index;

    if (!bo->num_cs_references)
        return FALSE;

    index = radeon_get_reloc(cs->csc, bo);
    if (index == -1)
        return FALSE;

    if ((usage & RADEON_USAGE_WRITE) && cs->csc->relocs[index].write_domain)
        return TRUE;
    if ((usage & RADEON_USAGE_READ) && cs->csc->relocs[index].read_domains)
        return TRUE;
d468 1
a468 1
    return FALSE;
a476 1
    ws->base.cs_memory_below_limit = radeon_drm_cs_memory_below_limit;
d479 1
a479 1
    ws->base.cs_set_flush_callback = radeon_drm_cs_set_flush;
a480 1
    ws->base.cs_sync_flush = radeon_drm_cs_sync_flush;
@


1.1.1.2
log
@Import Mesa 9.2.1
@
text
@a468 30
    switch (cs->base.ring_type) {
    case RING_DMA:
	    /* pad DMA ring to 8 DWs */
	    if (cs->ws->info.chip_class <= SI) {
		    while (rcs->cdw & 7)
			    OUT_CS(&cs->base, 0xf0000000); /* NOP packet */
	    } else {
		    while (rcs->cdw & 7)
			    OUT_CS(&cs->base, 0x00000000); /* NOP packet */
	    }
	    break;
    case RING_GFX:
	    /* pad DMA ring to 8 DWs to meet CP fetch alignment requirements
	     * r6xx, requires at least 4 dw alignment to avoid a hw bug.
	     */
            if (flags & RADEON_FLUSH_COMPUTE) {
		    if (cs->ws->info.chip_class <= SI) {
			    while (rcs->cdw & 7)
				    OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
		    } else {
			    while (rcs->cdw & 7)
				    OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
		    }
	    } else {
		    while (rcs->cdw & 7)
			    OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
	    }
	    break;
    }

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a67 1
#include "os/os_time.h"
d74 31
a107 5
static struct pipe_fence_handle *
radeon_cs_create_fence(struct radeon_winsys_cs *rcs);
static void radeon_fence_reference(struct pipe_fence_handle **dst,
                                   struct pipe_fence_handle *src);

a110 2
    int i;

a140 4

    for (i = 0; i < Elements(csc->reloc_indices_hashlist); i++) {
        csc->reloc_indices_hashlist[i] = -1;
    }
d159 1
a159 4

    for (i = 0; i < Elements(csc->reloc_indices_hashlist); i++) {
        csc->reloc_indices_hashlist[i] = -1;
    }
d170 3
a172 7
static struct radeon_winsys_cs *
radeon_drm_cs_create(struct radeon_winsys *rws,
                     enum ring_type ring_type,
                     void (*flush)(void *ctx, unsigned flags,
				   struct pipe_fence_handle **fence),
                     void *flush_ctx,
                     struct radeon_winsys_cs_handle *trace_buf)
d181 1
a181 1
    pipe_semaphore_init(&cs->flush_completed, 1);
a183 2
    cs->flush_cs = flush;
    cs->flush_data = flush_ctx;
d208 4
a211 5
static INLINE void update_reloc(struct drm_radeon_cs_reloc *reloc,
				enum radeon_bo_domain rd,
				enum radeon_bo_domain wd,
				unsigned priority,
				enum radeon_bo_domain *added_domains)
a216 1
    reloc->flags = MAX2(reloc->flags, priority);
d221 3
a223 2
    unsigned hash = bo->handle & (Elements(csc->reloc_indices_hashlist)-1);
    int i = csc->reloc_indices_hashlist[hash];
d225 4
a228 17
    /* not found or found */
    if (i == -1 || csc->relocs_bo[i] == bo)
        return i;

    /* Hash collision, look for the BO in the list of relocs linearly. */
    for (i = csc->crelocs - 1; i >= 0; i--) {
        if (csc->relocs_bo[i] == bo) {
            /* Put this reloc in the hash list.
             * This will prevent additional hash collisions if there are
             * several consecutive get_reloc calls for the same buffer.
             *
             * Example: Assuming buffers A,B,C collide in the hash list,
             * the following sequence of relocs:
             *         AAAAAAAAAAABBBBBBBBBBBBBBCCCCCCCC
             * will collide here: ^ and here:   ^,
             * meaning that we should get very few collisions in the end. */
            csc->reloc_indices_hashlist[hash] = i;
d231 20
d252 1
a259 1
                                 unsigned priority,
d264 1
a264 1
    unsigned hash = bo->handle & (Elements(csc->reloc_indices_hashlist)-1);
d267 2
a268 1
    int i = -1;
a269 1
    priority = MIN2(priority, 15);
d271 2
a272 4

    i = radeon_get_reloc(csc, bo);

    if (i >= 0) {
d274 10
a283 1
        update_reloc(reloc, rd, wd, priority, added_domains);
d285 16
a300 12
        /* For async DMA, every add_reloc call must add a buffer to the list
         * no matter how many duplicates there are. This is due to the fact
         * the DMA CS checker doesn't use NOP packets for offset patching,
         * but always uses the i-th buffer from the list to patch the i-th
         * offset. If there are N offsets in a DMA CS, there must also be N
         * buffers in the relocation list.
         *
         * This doesn't have to be done if virtual memory is enabled,
         * because there is no offset patching with virtual memory.
         */
        if (cs->base.ring_type != RING_DMA || cs->ws->info.r600_virtual_address) {
            return i;
d326 1
a326 1
    reloc->flags = priority;
d328 4
a331 1
    csc->reloc_indices_hashlist[hash] = csc->crelocs;
d342 1
a342 2
                                        enum radeon_bo_domain domains,
                                        enum radeon_bo_priority priority)
d347 1
a347 1
    unsigned index = radeon_add_reloc(cs, bo, usage, domains, priority, &added_domains);
a356 8
static int radeon_drm_cs_get_reloc(struct radeon_winsys_cs *rcs,
                                   struct radeon_winsys_cs_handle *buf)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);

    return radeon_get_reloc(cs->csc, (struct radeon_bo*)buf);
}

d380 1
a380 1
            cs->flush_cs(cs->flush_data, RADEON_FLUSH_ASYNC, NULL);
d403 16
d456 1
a456 1
    if (cs->ws->thread) {
d458 1
a458 1
        pipe_semaphore_signal(&cs->flush_completed);
d464 1
a464 4
static void radeon_drm_cs_flush(struct radeon_winsys_cs *rcs,
                                unsigned flags,
                                struct pipe_fence_handle **fence,
                                uint32_t cs_trace_id)
d484 9
a492 1
	    if (cs->ws->info.chip_class <= SI) {
a494 3
	    } else {
		    while (rcs->cdw & 7)
			    OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
a496 6
    case RING_UVD:
            while (rcs->cdw & 15)
		OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
	    break;
    default:
	    break;
a502 5
    if (fence) {
        radeon_fence_reference(fence, NULL);
        *fence = radeon_cs_create_fence(rcs);
    }

d505 1
a505 1
    /* Swap command streams. */
d514 1
a514 3
        unsigned i, crelocs;

        crelocs = cs->cst->crelocs;
a538 6
        case RING_VCE:
            cs->cst->flags[0] = 0;
            cs->cst->flags[1] = RADEON_CS_RING_VCE;
            cs->cst->cs.num_chunks = 3;
            break;

d563 2
a564 2
        if (cs->ws->thread) {
            pipe_semaphore_wait(&cs->flush_completed);
a565 2
            if (!(flags & RADEON_FLUSH_ASYNC))
                radeon_drm_cs_sync_flush(rcs);
d567 7
a582 2

    cs->ws->num_cs_flushes++;
d599 10
a631 53
/* FENCES */

static struct pipe_fence_handle *
radeon_cs_create_fence(struct radeon_winsys_cs *rcs)
{
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    struct pb_buffer *fence;

    /* Create a fence, which is a dummy BO. */
    fence = cs->ws->base.buffer_create(&cs->ws->base, 1, 1, TRUE,
                                       RADEON_DOMAIN_GTT);
    /* Add the fence as a dummy relocation. */
    cs->ws->base.cs_add_reloc(rcs, cs->ws->base.buffer_get_cs_handle(fence),
                              RADEON_USAGE_READWRITE, RADEON_DOMAIN_GTT,
                              RADEON_PRIO_MIN);
    return (struct pipe_fence_handle*)fence;
}

static bool radeon_fence_wait(struct radeon_winsys *ws,
                              struct pipe_fence_handle *fence,
                              uint64_t timeout)
{
    struct pb_buffer *rfence = (struct pb_buffer*)fence;

    if (timeout == 0)
        return !ws->buffer_is_busy(rfence, RADEON_USAGE_READWRITE);

    if (timeout != PIPE_TIMEOUT_INFINITE) {
        int64_t start_time = os_time_get();

        /* Convert to microseconds. */
        timeout /= 1000;

        /* Wait in a loop. */
        while (ws->buffer_is_busy(rfence, RADEON_USAGE_READWRITE)) {
            if (os_time_get() - start_time >= timeout) {
                return FALSE;
            }
            os_time_sleep(10);
        }
        return TRUE;
    }

    ws->buffer_wait(rfence, RADEON_USAGE_READWRITE);
    return TRUE;
}

static void radeon_fence_reference(struct pipe_fence_handle **dst,
                                   struct pipe_fence_handle *src)
{
    pb_reference((struct pb_buffer**)dst, (struct pb_buffer*)src);
}

a636 1
    ws->base.cs_get_reloc = radeon_drm_cs_get_reloc;
d639 1
d641 1
a643 2
    ws->base.fence_wait = radeon_fence_wait;
    ws->base.fence_reference = radeon_fence_reference;
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@d158 1
a158 1
                                   struct pipe_fence_handle **fence),
d199 4
a202 4
                                enum radeon_bo_domain rd,
                                enum radeon_bo_domain wd,
                                unsigned priority,
                                enum radeon_bo_domain *added_domains)
d437 9
a445 9
        /* pad DMA ring to 8 DWs */
        if (cs->ws->info.chip_class <= SI) {
            while (rcs->cdw & 7)
                OUT_CS(&cs->base, 0xf0000000); /* NOP packet */
        } else {
            while (rcs->cdw & 7)
                OUT_CS(&cs->base, 0x00000000); /* NOP packet */
        }
        break;
d447 11
a457 15
        /* pad DMA ring to 8 DWs to meet CP fetch alignment requirements
         * r6xx, requires at least 4 dw alignment to avoid a hw bug.
         * hawaii with old firmware needs type2 nop packet.
         * accel_working2 with value 3 indicates the new firmware.
         */
        if (cs->ws->info.chip_class <= SI ||
            (cs->ws->info.family == CHIP_HAWAII &&
             cs->ws->accel_working2 < 3)) {
            while (rcs->cdw & 7)
                OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
        } else {
            while (rcs->cdw & 7)
                OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
        }
        break;
d459 3
a461 3
        while (rcs->cdw & 15)
            OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
        break;
d463 1
a463 1
        break;
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d613 1
a613 1
                                       RADEON_DOMAIN_GTT, 0);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d613 1
a613 1
                                       RADEON_DOMAIN_GTT);
@


