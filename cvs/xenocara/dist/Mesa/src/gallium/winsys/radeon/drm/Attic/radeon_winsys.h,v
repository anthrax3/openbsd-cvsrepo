head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.42;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.56;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.4;
commitid	7kimTMT4YlQauAIU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.16;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.09;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.54;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.23;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.04.19;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.09.54;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.47.02;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2010 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#ifndef RADEON_WINSYS_H
#define RADEON_WINSYS_H

/* The public winsys interface header for the radeon driver. */

/* R300 features in DRM.
 *
 * 2.6.0:
 * - Hyper-Z
 * - GB_Z_PEQ_CONFIG on rv350->r4xx
 * - R500 FG_ALPHA_VALUE
 *
 * 2.8.0:
 * - R500 US_FORMAT regs
 * - R500 ARGB2101010 colorbuffer
 * - CMask and AA regs
 * - R16F/RG16F
 */

#include "pipebuffer/pb_buffer.h"
#include "radeon_surface.h"

#define RADEON_MAX_CMDBUF_DWORDS (16 * 1024)

#define RADEON_FLUSH_ASYNC		(1 << 0)
#define RADEON_FLUSH_KEEP_TILING_FLAGS	(1 << 1) /* needs DRM 2.12.0 */
#define RADEON_FLUSH_COMPUTE		(1 << 2)
#define RADEON_FLUSH_END_OF_FRAME       (1 << 3)

/* Tiling flags. */
enum radeon_bo_layout {
    RADEON_LAYOUT_LINEAR = 0,
    RADEON_LAYOUT_TILED,
    RADEON_LAYOUT_SQUARETILED,

    RADEON_LAYOUT_UNKNOWN
};

enum radeon_bo_domain { /* bitfield */
    RADEON_DOMAIN_GTT  = 2,
    RADEON_DOMAIN_VRAM = 4,
    RADEON_DOMAIN_VRAM_GTT = RADEON_DOMAIN_VRAM | RADEON_DOMAIN_GTT
};

enum radeon_bo_usage { /* bitfield */
    RADEON_USAGE_READ = 2,
    RADEON_USAGE_WRITE = 4,
    RADEON_USAGE_READWRITE = RADEON_USAGE_READ | RADEON_USAGE_WRITE
};

enum radeon_family {
    CHIP_UNKNOWN = 0,
    CHIP_R300, /* R3xx-based cores. */
    CHIP_R350,
    CHIP_RV350,
    CHIP_RV370,
    CHIP_RV380,
    CHIP_RS400,
    CHIP_RC410,
    CHIP_RS480,
    CHIP_R420,     /* R4xx-based cores. */
    CHIP_R423,
    CHIP_R430,
    CHIP_R480,
    CHIP_R481,
    CHIP_RV410,
    CHIP_RS600,
    CHIP_RS690,
    CHIP_RS740,
    CHIP_RV515,    /* R5xx-based cores. */
    CHIP_R520,
    CHIP_RV530,
    CHIP_R580,
    CHIP_RV560,
    CHIP_RV570,
    CHIP_R600,
    CHIP_RV610,
    CHIP_RV630,
    CHIP_RV670,
    CHIP_RV620,
    CHIP_RV635,
    CHIP_RS780,
    CHIP_RS880,
    CHIP_RV770,
    CHIP_RV730,
    CHIP_RV710,
    CHIP_RV740,
    CHIP_CEDAR,
    CHIP_REDWOOD,
    CHIP_JUNIPER,
    CHIP_CYPRESS,
    CHIP_HEMLOCK,
    CHIP_PALM,
    CHIP_SUMO,
    CHIP_SUMO2,
    CHIP_BARTS,
    CHIP_TURKS,
    CHIP_CAICOS,
    CHIP_CAYMAN,
    CHIP_ARUBA,
    CHIP_TAHITI,
    CHIP_PITCAIRN,
    CHIP_VERDE,
    CHIP_OLAND,
    CHIP_HAINAN,
    CHIP_BONAIRE,
    CHIP_KAVERI,
    CHIP_KABINI,
    CHIP_HAWAII,
    CHIP_MULLINS,
    CHIP_LAST,
};

enum chip_class {
    CLASS_UNKNOWN = 0,
    R300,
    R400,
    R500,
    R600,
    R700,
    EVERGREEN,
    CAYMAN,
    SI,
    CIK,
};

enum ring_type {
    RING_GFX = 0,
    RING_DMA,
    RING_UVD,
    RING_VCE,
    RING_LAST,
};

enum radeon_value_id {
    RADEON_REQUESTED_VRAM_MEMORY,
    RADEON_REQUESTED_GTT_MEMORY,
    RADEON_BUFFER_WAIT_TIME_NS,
    RADEON_TIMESTAMP,
    RADEON_NUM_CS_FLUSHES,
    RADEON_NUM_BYTES_MOVED,
    RADEON_VRAM_USAGE,
    RADEON_GTT_USAGE
};

enum radeon_bo_priority {
    RADEON_PRIO_MIN,
    RADEON_PRIO_SHADER_DATA, /* shader code, resource descriptors */
    RADEON_PRIO_SHADER_BUFFER_RO, /* read-only */
    RADEON_PRIO_SHADER_TEXTURE_RO, /* read-only */
    RADEON_PRIO_SHADER_RESOURCE_RW, /* buffers, textures, streamout, GS rings, RATs; read/write */
    RADEON_PRIO_COLOR_BUFFER,
    RADEON_PRIO_DEPTH_BUFFER,
    RADEON_PRIO_SHADER_TEXTURE_MSAA,
    RADEON_PRIO_COLOR_BUFFER_MSAA,
    RADEON_PRIO_DEPTH_BUFFER_MSAA,
    RADEON_PRIO_COLOR_META,
    RADEON_PRIO_DEPTH_META,
    RADEON_PRIO_MAX /* must be <= 15 */
};

struct winsys_handle;
struct radeon_winsys_cs_handle;

struct radeon_winsys_cs {
    unsigned                    cdw;  /* Number of used dwords. */
    uint32_t                    *buf; /* The command buffer. */
    enum ring_type              ring_type;
};

struct radeon_info {
    uint32_t                    pci_id;
    enum radeon_family          family;
    enum chip_class             chip_class;
    uint64_t                    gart_size;
    uint64_t                    vram_size;
    uint32_t                    max_sclk;

    uint32_t                    drm_major; /* version */
    uint32_t                    drm_minor;
    uint32_t                    drm_patchlevel;

    boolean                     has_uvd;
    uint32_t                    vce_fw_version;

    uint32_t                    r300_num_gb_pipes;
    uint32_t                    r300_num_z_pipes;

    uint32_t                    r600_num_backends;
    uint32_t                    r600_clock_crystal_freq;
    uint32_t                    r600_tiling_config;
    uint32_t                    r600_num_tile_pipes;
    uint32_t                    r600_max_pipes;
    boolean                     r600_virtual_address;
    boolean                     r600_has_dma;

    uint32_t                    r600_backend_map;
    boolean                     r600_backend_map_valid;

    boolean                     si_tile_mode_array_valid;
    uint32_t                    si_tile_mode_array[32];

    boolean                     cik_macrotile_mode_array_valid;
    uint32_t                    cik_macrotile_mode_array[16];
};

enum radeon_feature_id {
    RADEON_FID_R300_HYPERZ_ACCESS,     /* ZMask + HiZ */
    RADEON_FID_R300_CMASK_ACCESS,
};

struct radeon_winsys {
    /**
     * The screen object this winsys was created for
     */
    struct pipe_screen *screen;

    /**
     * Decrement the winsys reference count.
     *
     * \param ws  The winsys this function is called for.
     * \return    True if the winsys and screen should be destroyed.
     */
    bool (*unref)(struct radeon_winsys *ws);

    /**
     * Destroy this winsys.
     *
     * \param ws        The winsys this function is called from.
     */
    void (*destroy)(struct radeon_winsys *ws);

    /**
     * Query an info structure from winsys.
     *
     * \param ws        The winsys this function is called from.
     * \param info      Return structure
     */
    void (*query_info)(struct radeon_winsys *ws,
                       struct radeon_info *info);

    /**************************************************************************
     * Buffer management. Buffer attributes are mostly fixed over its lifetime.
     *
     * Remember that gallium gets to choose the interface it needs, and the
     * window systems must then implement that interface (rather than the
     * other way around...).
     *************************************************************************/

    /**
     * Create a buffer object.
     *
     * \param ws        The winsys this function is called from.
     * \param size      The size to allocate.
     * \param alignment An alignment of the buffer in memory.
     * \param use_reusable_pool Whether the cache buffer manager should be used.
     * \param domain    A bitmask of the RADEON_DOMAIN_* flags.
     * \return          The created buffer object.
     */
    struct pb_buffer *(*buffer_create)(struct radeon_winsys *ws,
                                       unsigned size,
                                       unsigned alignment,
                                       boolean use_reusable_pool,
                                       enum radeon_bo_domain domain);

    struct radeon_winsys_cs_handle *(*buffer_get_cs_handle)(
            struct pb_buffer *buf);

    /**
     * Map the entire data store of a buffer object into the client's address
     * space.
     *
     * \param buf       A winsys buffer object to map.
     * \param cs        A command stream to flush if the buffer is referenced by it.
     * \param usage     A bitmask of the PIPE_TRANSFER_* flags.
     * \return          The pointer at the beginning of the buffer.
     */
    void *(*buffer_map)(struct radeon_winsys_cs_handle *buf,
                        struct radeon_winsys_cs *cs,
                        enum pipe_transfer_usage usage);

    /**
     * Unmap a buffer object from the client's address space.
     *
     * \param buf       A winsys buffer object to unmap.
     */
    void (*buffer_unmap)(struct radeon_winsys_cs_handle *buf);

    /**
     * Return TRUE if a buffer object is being used by the GPU.
     *
     * \param buf       A winsys buffer object.
     * \param usage     Only check whether the buffer is busy for the given usage.
     */
    boolean (*buffer_is_busy)(struct pb_buffer *buf,
                              enum radeon_bo_usage usage);

    /**
     * Wait for a buffer object until it is not used by a GPU. This is
     * equivalent to a fence placed after the last command using the buffer,
     * and synchronizing to the fence.
     *
     * \param buf       A winsys buffer object to wait for.
     * \param usage     Only wait until the buffer is idle for the given usage,
     *                  but may still be busy for some other usage.
     */
    void (*buffer_wait)(struct pb_buffer *buf, enum radeon_bo_usage usage);

    /**
     * Return tiling flags describing a memory layout of a buffer object.
     *
     * \param buf       A winsys buffer object to get the flags from.
     * \param macrotile A pointer to the return value of the microtile flag.
     * \param microtile A pointer to the return value of the macrotile flag.
     *
     * \note microtile and macrotile are not bitmasks!
     */
    void (*buffer_get_tiling)(struct pb_buffer *buf,
                              enum radeon_bo_layout *microtile,
                              enum radeon_bo_layout *macrotile,
                              unsigned *bankw, unsigned *bankh,
                              unsigned *tile_split,
                              unsigned *stencil_tile_split,
                              unsigned *mtilea,
                              bool *scanout);

    /**
     * Set tiling flags describing a memory layout of a buffer object.
     *
     * \param buf       A winsys buffer object to set the flags for.
     * \param cs        A command stream to flush if the buffer is referenced by it.
     * \param macrotile A macrotile flag.
     * \param microtile A microtile flag.
     * \param stride    A stride of the buffer in bytes, for texturing.
     *
     * \note microtile and macrotile are not bitmasks!
     */
    void (*buffer_set_tiling)(struct pb_buffer *buf,
                              struct radeon_winsys_cs *rcs,
                              enum radeon_bo_layout microtile,
                              enum radeon_bo_layout macrotile,
                              unsigned bankw, unsigned bankh,
                              unsigned tile_split,
                              unsigned stencil_tile_split,
                              unsigned mtilea,
                              unsigned stride,
                              bool scanout);

    /**
     * Get a winsys buffer from a winsys handle. The internal structure
     * of the handle is platform-specific and only a winsys should access it.
     *
     * \param ws        The winsys this function is called from.
     * \param whandle   A winsys handle pointer as was received from a state
     *                  tracker.
     * \param stride    The returned buffer stride in bytes.
     */
    struct pb_buffer *(*buffer_from_handle)(struct radeon_winsys *ws,
                                            struct winsys_handle *whandle,
                                            unsigned *stride);

    /**
     * Get a winsys handle from a winsys buffer. The internal structure
     * of the handle is platform-specific and only a winsys should access it.
     *
     * \param buf       A winsys buffer object to get the handle from.
     * \param whandle   A winsys handle pointer.
     * \param stride    A stride of the buffer in bytes, for texturing.
     * \return          TRUE on success.
     */
    boolean (*buffer_get_handle)(struct pb_buffer *buf,
                                 unsigned stride,
                                 struct winsys_handle *whandle);

    /**
     * Return the virtual address of a buffer.
     *
     * \param buf       A winsys buffer object
     * \return          virtual address
     */
    uint64_t (*buffer_get_virtual_address)(struct radeon_winsys_cs_handle *buf);

    /**
     * Query the initial placement of the buffer from the kernel driver.
     */
    enum radeon_bo_domain (*buffer_get_initial_domain)(struct radeon_winsys_cs_handle *buf);

    /**************************************************************************
     * Command submission.
     *
     * Each pipe context should create its own command stream and submit
     * commands independently of other contexts.
     *************************************************************************/

    /**
     * Create a command stream.
     *
     * \param ws        The winsys this function is called from.
     * \param ring_type The ring type (GFX, DMA, UVD)
     * \param flush     Flush callback function associated with the command stream.
     * \param user      User pointer that will be passed to the flush callback.
     * \param trace_buf Trace buffer when tracing is enabled
     */
    struct radeon_winsys_cs *(*cs_create)(struct radeon_winsys *ws,
                                          enum ring_type ring_type,
                                          void (*flush)(void *ctx, unsigned flags,
							struct pipe_fence_handle **fence),
                                          void *flush_ctx,
                                          struct radeon_winsys_cs_handle *trace_buf);

    /**
     * Destroy a command stream.
     *
     * \param cs        A command stream to destroy.
     */
    void (*cs_destroy)(struct radeon_winsys_cs *cs);

    /**
     * Add a new buffer relocation. Every relocation must first be added
     * before it can be written.
     *
     * \param cs  A command stream to add buffer for validation against.
     * \param buf A winsys buffer to validate.
     * \param usage   Whether the buffer is used for read and/or write.
     * \param domain  Bitmask of the RADEON_DOMAIN_* flags.
     * \param priority  A higher number means a greater chance of being
     *                  placed in the requested domain. 15 is the maximum.
     * \return Relocation index.
     */
    unsigned (*cs_add_reloc)(struct radeon_winsys_cs *cs,
                             struct radeon_winsys_cs_handle *buf,
                             enum radeon_bo_usage usage,
                             enum radeon_bo_domain domain,
                             enum radeon_bo_priority priority);

    /**
     * Return the index of an already-added buffer.
     *
     * \param cs        Command stream
     * \param buf       Buffer
     * \return          The buffer index, or -1 if the buffer has not been added.
     */
    int (*cs_get_reloc)(struct radeon_winsys_cs *cs,
                        struct radeon_winsys_cs_handle *buf);

    /**
     * Return TRUE if there is enough memory in VRAM and GTT for the relocs
     * added so far. If the validation fails, all the relocations which have
     * been added since the last call of cs_validate will be removed and
     * the CS will be flushed (provided there are still any relocations).
     *
     * \param cs        A command stream to validate.
     */
    boolean (*cs_validate)(struct radeon_winsys_cs *cs);

    /**
     * Return TRUE if there is enough memory in VRAM and GTT for the relocs
     * added so far.
     *
     * \param cs        A command stream to validate.
     * \param vram      VRAM memory size pending to be use
     * \param gtt       GTT memory size pending to be use
     */
    boolean (*cs_memory_below_limit)(struct radeon_winsys_cs *cs, uint64_t vram, uint64_t gtt);

    /**
     * Flush a command stream.
     *
     * \param cs          A command stream to flush.
     * \param flags,      RADEON_FLUSH_ASYNC or 0.
     * \param fence       Pointer to a fence. If non-NULL, a fence is inserted
     *                    after the CS and is returned through this parameter.
     * \param cs_trace_id A unique identifier of the cs, used for tracing.
     */
    void (*cs_flush)(struct radeon_winsys_cs *cs,
                     unsigned flags,
                     struct pipe_fence_handle **fence,
                     uint32_t cs_trace_id);

    /**
     * Return TRUE if a buffer is referenced by a command stream.
     *
     * \param cs        A command stream.
     * \param buf       A winsys buffer.
     */
    boolean (*cs_is_buffer_referenced)(struct radeon_winsys_cs *cs,
                                       struct radeon_winsys_cs_handle *buf,
                                       enum radeon_bo_usage usage);

    /**
     * Request access to a feature for a command stream.
     *
     * \param cs        A command stream.
     * \param fid       Feature ID, one of RADEON_FID_*
     * \param enable    Whether to enable or disable the feature.
     */
    boolean (*cs_request_feature)(struct radeon_winsys_cs *cs,
                                  enum radeon_feature_id fid,
                                  boolean enable);
     /**
      * Make sure all asynchronous flush of the cs have completed
      *
      * \param cs        A command stream.
      */
    void (*cs_sync_flush)(struct radeon_winsys_cs *cs);

    /**
     * Wait for the fence and return true if the fence has been signalled.
     * The timeout of 0 will only return the status.
     * The timeout of PIPE_TIMEOUT_INFINITE will always wait until the fence
     * is signalled.
     */
    bool (*fence_wait)(struct radeon_winsys *ws,
                       struct pipe_fence_handle *fence,
                       uint64_t timeout);

    /**
     * Reference counting for fences.
     */
    void (*fence_reference)(struct pipe_fence_handle **dst,
                            struct pipe_fence_handle *src);

    /**
     * Initialize surface
     *
     * \param ws        The winsys this function is called from.
     * \param surf      Surface structure ptr
     */
    int (*surface_init)(struct radeon_winsys *ws,
                        struct radeon_surface *surf);

    /**
     * Find best values for a surface
     *
     * \param ws        The winsys this function is called from.
     * \param surf      Surface structure ptr
     */
    int (*surface_best)(struct radeon_winsys *ws,
                        struct radeon_surface *surf);

    uint64_t (*query_value)(struct radeon_winsys *ws,
                            enum radeon_value_id value);
};


static INLINE void radeon_emit(struct radeon_winsys_cs *cs, uint32_t value)
{
    cs->buf[cs->cdw++] = value;
}

static INLINE void radeon_emit_array(struct radeon_winsys_cs *cs,
				     const uint32_t *values, unsigned count)
{
    memcpy(cs->buf+cs->cdw, values, count * 4);
    cs->cdw += count;
}

#endif
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a67 6
enum radeon_bo_flag { /* bitfield */
    RADEON_FLAG_GTT_WC =        (1 << 0),
    RADEON_FLAG_CPU_ACCESS =    (1 << 1),
    RADEON_FLAG_NO_CPU_ACCESS = (1 << 2),
};

a200 3
    uint32_t                    max_compute_units;
    uint32_t                    max_se;
    uint32_t                    max_sh_per_se;
a224 1
    uint32_t                    si_backend_enabled_mask;
d287 1
a287 2
                                       enum radeon_bo_domain domain,
                                       enum radeon_bo_flag flags);
@


1.5
log
@Merge Mesa 10.2.7
@
text
@d68 6
d207 3
d234 1
d297 2
a298 1
                                       enum radeon_bo_domain domain);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d198 2
a199 2
    uint32_t                    gart_size;
    uint32_t                    vram_size;
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d64 2
a65 1
    RADEON_DOMAIN_VRAM = 4
d132 2
d154 1
d162 21
a182 1
    RADEON_TIMESTAMP
d200 1
d207 1
a215 3
    uint32_t                    r600_backend_map;
    uint32_t                    r600_va_start;
    uint32_t                    r600_ib_vm_max_size;
a216 1
    boolean                     r600_backend_map_valid;
d219 9
d237 1
a237 1
     * Reference counting
d239 9
a247 1
    struct pipe_reference reference;
d347 2
a348 1
                              unsigned *mtilea);
d369 2
a370 1
                              unsigned stride);
d406 5
d423 2
d429 3
d449 2
d456 12
a467 1
                             enum radeon_bo_domain domain);
a489 9
     * Write a relocated dword to a command buffer.
     *
     * \param cs        A command stream the relocation is written to.
     * \param buf       A winsys buffer to write the relocation for.
     */
    void (*cs_write_reloc)(struct radeon_winsys_cs *cs,
                           struct radeon_winsys_cs_handle *buf);

    /**
d494 8
a501 15
     * \param cs_trace_id A unique identifiant for the cs
     */
    void (*cs_flush)(struct radeon_winsys_cs *cs, unsigned flags, uint32_t cs_trace_id);

    /**
     * Set a flush callback which is called from winsys when flush is
     * required.
     *
     * \param cs        A command stream to set the callback for.
     * \param flush     A flush callback function associated with the command stream.
     * \param user      A user pointer that will be passed to the flush callback.
     */
    void (*cs_set_flush_callback)(struct radeon_winsys_cs *cs,
                                  void (*flush)(void *ctx, unsigned flags),
                                  void *ctx);
d531 16
d567 13
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d29 16
a44 3
#include "pipebuffer/pb_bufmgr.h"
#include "pipe/p_defines.h"
#include "pipe/p_state.h"
d47 5
a51 1
#define RADEON_FLUSH_ASYNC       (1 << 0)
d67 94
d162 1
a162 1
struct radeon_winsys_cs_handle;   /* for write_reloc etc. */
d165 3
a167 2
    unsigned cdw;  /* Number of used dwords. */
    uint32_t *buf; /* The command buffer. */
d170 27
a196 32
enum radeon_value_id {
    RADEON_VID_PCI_ID,
    RADEON_VID_R300_GB_PIPES,
    RADEON_VID_R300_Z_PIPES,
    RADEON_VID_GART_SIZE,
    RADEON_VID_VRAM_SIZE,
    RADEON_VID_DRM_MAJOR,
    RADEON_VID_DRM_MINOR,
    RADEON_VID_DRM_PATCHLEVEL,

    /* These should probably go away: */

    /* R300 features:
     * - Hyper-Z
     * - GB_Z_PEQ_CONFIG on rv350->r4xx
     * - R500 FG_ALPHA_VALUE
     *
     * R600 features:
     * - TBD
     */
    RADEON_VID_DRM_2_6_0,

    /* R300 features:
     * - R500 US_FORMAT regs
     * - R500 ARGB2101010 colorbuffer
     * - CMask and AA regs
     * - R16F/RG16F
     *
     * R600 features:
     * - TBD
     */
    RADEON_VID_DRM_2_8_0,
d200 2
a201 2
    RADEON_FID_HYPERZ_RAM_ACCESS,     /* ZMask + HiZ */
    RADEON_FID_CMASK_RAM_ACCESS,
d206 5
d218 1
a218 1
     * Query a system value from a winsys.
d221 1
a221 1
     * \param vid       One of the RADEON_VID_* enums.
d223 2
a224 2
    uint32_t (*get_value)(struct radeon_winsys *ws,
                          enum radeon_value_id vid);
d240 1
a240 2
     * \param bind      A bitmask of the PIPE_BIND_* flags.
     * \param usage     A bitmask of the PIPE_USAGE_* flags.
d247 1
a247 2
                                       unsigned bind,
                                       unsigned usage,
d262 1
a262 1
    void *(*buffer_map)(struct pb_buffer *buf,
d271 1
a271 1
    void (*buffer_unmap)(struct pb_buffer *buf);
d277 1
d279 2
a280 1
    boolean (*buffer_is_busy)(struct pb_buffer *buf);
d288 2
d291 1
a291 1
    void (*buffer_wait)(struct pb_buffer *buf);
d304 5
a308 1
                              enum radeon_bo_layout *macrotile);
d322 1
a322 1
                              struct radeon_winsys_cs *cs,
d325 4
a338 1
     * \param size      The returned buffer size.
d342 1
a342 2
                                            unsigned *stride,
                                            unsigned *size);
d357 8
d376 2
d379 3
a381 1
    struct radeon_winsys_cs *(*cs_create)(struct radeon_winsys *ws);
d396 8
a403 7
     * \param rd  A read domain containing a bitmask of the RADEON_DOMAIN_* flags.
     * \param wd  A write domain containing a bitmask of the RADEON_DOMAIN_* flags.
     */
    void (*cs_add_reloc)(struct radeon_winsys_cs *cs,
                         struct radeon_winsys_cs_handle *buf,
                         enum radeon_bo_domain rd,
                         enum radeon_bo_domain wd);
d416 10
a429 2
     * \param rd        A read domain containing a bitmask of the RADEON_DOMAIN_* flags.
     * \param wd        A write domain containing a bitmask of the RADEON_DOMAIN_* flags.
d437 3
a439 2
     * \param cs        A command stream to flush.
     * \param flags,    RADEON_FLUSH_ASYNC or 0.
d441 1
a441 1
    void (*cs_flush)(struct radeon_winsys_cs *cs, unsigned flags);
d451 3
a453 3
    void (*cs_set_flush)(struct radeon_winsys_cs *cs,
                         void (*flush)(void *ctx, unsigned flags),
                         void *user);
d462 2
a463 1
                                       struct radeon_winsys_cs_handle *buf);
d469 2
a470 1
     * \param fid       A winsys buffer.
d475 27
@


1.1
log
@Initial revision
@
text
@d2 2
a3 2
 * Copyright © 2009 Corbin Simpson
 * All Rights Reserved.
d5 6
a10 7
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
d12 3
a14 8
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
 * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
d16 8
a23 8
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 */
/*
 * Authors:
 *      Corbin Simpson <MostAwesomeDude@@gmail.com>
 */
d27 1
a27 1
#include "r300_winsys.h"
d29 12
a40 2
struct radeon_drm_winsys {
    struct r300_winsys_screen base;
d42 2
a43 1
    int fd; /* DRM file descriptor */
d45 4
a48 3
    struct radeon_bo_manager *bom; /* Radeon BO manager. */
    struct pb_manager *kman;
    struct pb_manager *cman;
d50 2
a51 12
    uint32_t pci_id;        /* PCI ID */
    uint32_t gb_pipes;      /* GB pipe count */
    uint32_t z_pipes;       /* Z pipe count (rv530 only) */
    uint32_t gart_size;     /* GART size. */
    uint32_t vram_size;     /* VRAM size. */
    boolean squaretiling;   /* Square tiling support. */
    /* DRM 2.3.0 (R500 VAP regs, MSPOS regs, fixed tex3D size checking) */
    boolean drm_2_3_0;
    /* DRM 2.6.0 (Hyper-Z, GB_Z_PEQ_CONFIG allowed on rv350->r4xx) */
    boolean drm_2_6_0;
    /* Hyper-Z user */
    boolean hyperz;
d53 3
a55 2
    /* Radeon CS manager. */
    struct radeon_cs_manager *csm;
d58 33
a90 2
struct radeon_drm_cs {
    struct r300_winsys_cs base;
d92 4
a95 2
    /* The winsys. */
    struct radeon_drm_winsys *ws;
d97 234
a330 6
    /* The libdrm command stream. */
    struct radeon_cs *cs;

    /* Flush CS. */
    void (*flush_cs)(void *);
    void *flush_data;
a331 14

static INLINE struct radeon_drm_cs *
radeon_drm_cs(struct r300_winsys_cs *base)
{
    return (struct radeon_drm_cs*)base;
}

static INLINE struct radeon_drm_winsys *
radeon_drm_winsys(struct r300_winsys_screen *base)
{
    return (struct radeon_drm_winsys*)base;
}

void radeon_winsys_init_functions(struct radeon_drm_winsys *ws);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d2 2
a3 2
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2010 Marek Olšák <maraeo@@gmail.com>
d5 7
a11 6
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
d13 8
a20 3
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
d22 8
a29 8
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

d33 1
a33 31
/* The public winsys interface header for the radeon driver. */

/* R300 features in DRM.
 *
 * 2.6.0:
 * - Hyper-Z
 * - GB_Z_PEQ_CONFIG on rv350->r4xx
 * - R500 FG_ALPHA_VALUE
 *
 * 2.8.0:
 * - R500 US_FORMAT regs
 * - R500 ARGB2101010 colorbuffer
 * - CMask and AA regs
 * - R16F/RG16F
 */

#include "pipebuffer/pb_buffer.h"
#include "libdrm/radeon_surface.h"

#define RADEON_MAX_CMDBUF_DWORDS (16 * 1024)

#define RADEON_FLUSH_ASYNC		(1 << 0)
#define RADEON_FLUSH_KEEP_TILING_FLAGS	(1 << 1) /* needs DRM 2.12.0 */
#define RADEON_FLUSH_COMPUTE		(1 << 2)
#define RADEON_FLUSH_END_OF_FRAME       (1 << 3)

/* Tiling flags. */
enum radeon_bo_layout {
    RADEON_LAYOUT_LINEAR = 0,
    RADEON_LAYOUT_TILED,
    RADEON_LAYOUT_SQUARETILED,
d35 2
a36 2
    RADEON_LAYOUT_UNKNOWN
};
d38 1
a38 4
enum radeon_bo_domain { /* bitfield */
    RADEON_DOMAIN_GTT  = 2,
    RADEON_DOMAIN_VRAM = 4
};
d40 3
a42 66
enum radeon_bo_usage { /* bitfield */
    RADEON_USAGE_READ = 2,
    RADEON_USAGE_WRITE = 4,
    RADEON_USAGE_READWRITE = RADEON_USAGE_READ | RADEON_USAGE_WRITE
};

enum radeon_family {
    CHIP_UNKNOWN = 0,
    CHIP_R300, /* R3xx-based cores. */
    CHIP_R350,
    CHIP_RV350,
    CHIP_RV370,
    CHIP_RV380,
    CHIP_RS400,
    CHIP_RC410,
    CHIP_RS480,
    CHIP_R420,     /* R4xx-based cores. */
    CHIP_R423,
    CHIP_R430,
    CHIP_R480,
    CHIP_R481,
    CHIP_RV410,
    CHIP_RS600,
    CHIP_RS690,
    CHIP_RS740,
    CHIP_RV515,    /* R5xx-based cores. */
    CHIP_R520,
    CHIP_RV530,
    CHIP_R580,
    CHIP_RV560,
    CHIP_RV570,
    CHIP_R600,
    CHIP_RV610,
    CHIP_RV630,
    CHIP_RV670,
    CHIP_RV620,
    CHIP_RV635,
    CHIP_RS780,
    CHIP_RS880,
    CHIP_RV770,
    CHIP_RV730,
    CHIP_RV710,
    CHIP_RV740,
    CHIP_CEDAR,
    CHIP_REDWOOD,
    CHIP_JUNIPER,
    CHIP_CYPRESS,
    CHIP_HEMLOCK,
    CHIP_PALM,
    CHIP_SUMO,
    CHIP_SUMO2,
    CHIP_BARTS,
    CHIP_TURKS,
    CHIP_CAICOS,
    CHIP_CAYMAN,
    CHIP_ARUBA,
    CHIP_TAHITI,
    CHIP_PITCAIRN,
    CHIP_VERDE,
    CHIP_OLAND,
    CHIP_HAINAN,
    CHIP_BONAIRE,
    CHIP_KAVERI,
    CHIP_KABINI,
    CHIP_LAST,
};
d44 12
a55 12
enum chip_class {
    CLASS_UNKNOWN = 0,
    R300,
    R400,
    R500,
    R600,
    R700,
    EVERGREEN,
    CAYMAN,
    SI,
    CIK,
};
d57 2
a58 5
enum ring_type {
    RING_GFX = 0,
    RING_DMA,
    RING_UVD,
    RING_LAST,
d61 2
a62 6
enum radeon_value_id {
    RADEON_REQUESTED_VRAM_MEMORY,
    RADEON_REQUESTED_GTT_MEMORY,
    RADEON_BUFFER_WAIT_TIME_NS,
    RADEON_TIMESTAMP
};
d64 2
a65 2
struct winsys_handle;
struct radeon_winsys_cs_handle;
d67 2
a68 5
struct radeon_winsys_cs {
    unsigned                    cdw;  /* Number of used dwords. */
    uint32_t                    *buf; /* The command buffer. */
    enum ring_type              ring_type;
};
d70 3
a72 27
struct radeon_info {
    uint32_t                    pci_id;
    enum radeon_family          family;
    enum chip_class             chip_class;
    uint32_t                    gart_size;
    uint32_t                    vram_size;

    uint32_t                    drm_major; /* version */
    uint32_t                    drm_minor;
    uint32_t                    drm_patchlevel;

    boolean                     has_uvd;

    uint32_t                    r300_num_gb_pipes;
    uint32_t                    r300_num_z_pipes;

    uint32_t                    r600_num_backends;
    uint32_t                    r600_clock_crystal_freq;
    uint32_t                    r600_tiling_config;
    uint32_t                    r600_num_tile_pipes;
    uint32_t                    r600_backend_map;
    uint32_t                    r600_va_start;
    uint32_t                    r600_ib_vm_max_size;
    uint32_t                    r600_max_pipes;
    boolean                     r600_backend_map_valid;
    boolean                     r600_virtual_address;
    boolean                     r600_has_dma;
d75 5
a79 4
enum radeon_feature_id {
    RADEON_FID_R300_HYPERZ_ACCESS,     /* ZMask + HiZ */
    RADEON_FID_R300_CMASK_ACCESS,
};
d81 5
a85 295
struct radeon_winsys {
    /**
     * Reference counting
     */
    struct pipe_reference reference;

    /**
     * Destroy this winsys.
     *
     * \param ws        The winsys this function is called from.
     */
    void (*destroy)(struct radeon_winsys *ws);

    /**
     * Query an info structure from winsys.
     *
     * \param ws        The winsys this function is called from.
     * \param info      Return structure
     */
    void (*query_info)(struct radeon_winsys *ws,
                       struct radeon_info *info);

    /**************************************************************************
     * Buffer management. Buffer attributes are mostly fixed over its lifetime.
     *
     * Remember that gallium gets to choose the interface it needs, and the
     * window systems must then implement that interface (rather than the
     * other way around...).
     *************************************************************************/

    /**
     * Create a buffer object.
     *
     * \param ws        The winsys this function is called from.
     * \param size      The size to allocate.
     * \param alignment An alignment of the buffer in memory.
     * \param use_reusable_pool Whether the cache buffer manager should be used.
     * \param domain    A bitmask of the RADEON_DOMAIN_* flags.
     * \return          The created buffer object.
     */
    struct pb_buffer *(*buffer_create)(struct radeon_winsys *ws,
                                       unsigned size,
                                       unsigned alignment,
                                       boolean use_reusable_pool,
                                       enum radeon_bo_domain domain);

    struct radeon_winsys_cs_handle *(*buffer_get_cs_handle)(
            struct pb_buffer *buf);

    /**
     * Map the entire data store of a buffer object into the client's address
     * space.
     *
     * \param buf       A winsys buffer object to map.
     * \param cs        A command stream to flush if the buffer is referenced by it.
     * \param usage     A bitmask of the PIPE_TRANSFER_* flags.
     * \return          The pointer at the beginning of the buffer.
     */
    void *(*buffer_map)(struct radeon_winsys_cs_handle *buf,
                        struct radeon_winsys_cs *cs,
                        enum pipe_transfer_usage usage);

    /**
     * Unmap a buffer object from the client's address space.
     *
     * \param buf       A winsys buffer object to unmap.
     */
    void (*buffer_unmap)(struct radeon_winsys_cs_handle *buf);

    /**
     * Return TRUE if a buffer object is being used by the GPU.
     *
     * \param buf       A winsys buffer object.
     * \param usage     Only check whether the buffer is busy for the given usage.
     */
    boolean (*buffer_is_busy)(struct pb_buffer *buf,
                              enum radeon_bo_usage usage);

    /**
     * Wait for a buffer object until it is not used by a GPU. This is
     * equivalent to a fence placed after the last command using the buffer,
     * and synchronizing to the fence.
     *
     * \param buf       A winsys buffer object to wait for.
     * \param usage     Only wait until the buffer is idle for the given usage,
     *                  but may still be busy for some other usage.
     */
    void (*buffer_wait)(struct pb_buffer *buf, enum radeon_bo_usage usage);

    /**
     * Return tiling flags describing a memory layout of a buffer object.
     *
     * \param buf       A winsys buffer object to get the flags from.
     * \param macrotile A pointer to the return value of the microtile flag.
     * \param microtile A pointer to the return value of the macrotile flag.
     *
     * \note microtile and macrotile are not bitmasks!
     */
    void (*buffer_get_tiling)(struct pb_buffer *buf,
                              enum radeon_bo_layout *microtile,
                              enum radeon_bo_layout *macrotile,
                              unsigned *bankw, unsigned *bankh,
                              unsigned *tile_split,
                              unsigned *stencil_tile_split,
                              unsigned *mtilea);

    /**
     * Set tiling flags describing a memory layout of a buffer object.
     *
     * \param buf       A winsys buffer object to set the flags for.
     * \param cs        A command stream to flush if the buffer is referenced by it.
     * \param macrotile A macrotile flag.
     * \param microtile A microtile flag.
     * \param stride    A stride of the buffer in bytes, for texturing.
     *
     * \note microtile and macrotile are not bitmasks!
     */
    void (*buffer_set_tiling)(struct pb_buffer *buf,
                              struct radeon_winsys_cs *rcs,
                              enum radeon_bo_layout microtile,
                              enum radeon_bo_layout macrotile,
                              unsigned bankw, unsigned bankh,
                              unsigned tile_split,
                              unsigned stencil_tile_split,
                              unsigned mtilea,
                              unsigned stride);

    /**
     * Get a winsys buffer from a winsys handle. The internal structure
     * of the handle is platform-specific and only a winsys should access it.
     *
     * \param ws        The winsys this function is called from.
     * \param whandle   A winsys handle pointer as was received from a state
     *                  tracker.
     * \param stride    The returned buffer stride in bytes.
     */
    struct pb_buffer *(*buffer_from_handle)(struct radeon_winsys *ws,
                                            struct winsys_handle *whandle,
                                            unsigned *stride);

    /**
     * Get a winsys handle from a winsys buffer. The internal structure
     * of the handle is platform-specific and only a winsys should access it.
     *
     * \param buf       A winsys buffer object to get the handle from.
     * \param whandle   A winsys handle pointer.
     * \param stride    A stride of the buffer in bytes, for texturing.
     * \return          TRUE on success.
     */
    boolean (*buffer_get_handle)(struct pb_buffer *buf,
                                 unsigned stride,
                                 struct winsys_handle *whandle);

    /**
     * Return the virtual address of a buffer.
     *
     * \param buf       A winsys buffer object
     * \return          virtual address
     */
    uint64_t (*buffer_get_virtual_address)(struct radeon_winsys_cs_handle *buf);

    /**************************************************************************
     * Command submission.
     *
     * Each pipe context should create its own command stream and submit
     * commands independently of other contexts.
     *************************************************************************/

    /**
     * Create a command stream.
     *
     * \param ws        The winsys this function is called from.
     * \param ring_type The ring type (GFX, DMA, UVD)
     * \param trace_buf Trace buffer when tracing is enabled
     */
    struct radeon_winsys_cs *(*cs_create)(struct radeon_winsys *ws,
                                          enum ring_type ring_type,
                                          struct radeon_winsys_cs_handle *trace_buf);

    /**
     * Destroy a command stream.
     *
     * \param cs        A command stream to destroy.
     */
    void (*cs_destroy)(struct radeon_winsys_cs *cs);

    /**
     * Add a new buffer relocation. Every relocation must first be added
     * before it can be written.
     *
     * \param cs  A command stream to add buffer for validation against.
     * \param buf A winsys buffer to validate.
     * \param usage   Whether the buffer is used for read and/or write.
     * \param domain  Bitmask of the RADEON_DOMAIN_* flags.
     * \return Relocation index.
     */
    unsigned (*cs_add_reloc)(struct radeon_winsys_cs *cs,
                             struct radeon_winsys_cs_handle *buf,
                             enum radeon_bo_usage usage,
                             enum radeon_bo_domain domain);

    /**
     * Return TRUE if there is enough memory in VRAM and GTT for the relocs
     * added so far. If the validation fails, all the relocations which have
     * been added since the last call of cs_validate will be removed and
     * the CS will be flushed (provided there are still any relocations).
     *
     * \param cs        A command stream to validate.
     */
    boolean (*cs_validate)(struct radeon_winsys_cs *cs);

    /**
     * Return TRUE if there is enough memory in VRAM and GTT for the relocs
     * added so far.
     *
     * \param cs        A command stream to validate.
     * \param vram      VRAM memory size pending to be use
     * \param gtt       GTT memory size pending to be use
     */
    boolean (*cs_memory_below_limit)(struct radeon_winsys_cs *cs, uint64_t vram, uint64_t gtt);

    /**
     * Write a relocated dword to a command buffer.
     *
     * \param cs        A command stream the relocation is written to.
     * \param buf       A winsys buffer to write the relocation for.
     */
    void (*cs_write_reloc)(struct radeon_winsys_cs *cs,
                           struct radeon_winsys_cs_handle *buf);

    /**
     * Flush a command stream.
     *
     * \param cs          A command stream to flush.
     * \param flags,      RADEON_FLUSH_ASYNC or 0.
     * \param cs_trace_id A unique identifiant for the cs
     */
    void (*cs_flush)(struct radeon_winsys_cs *cs, unsigned flags, uint32_t cs_trace_id);

    /**
     * Set a flush callback which is called from winsys when flush is
     * required.
     *
     * \param cs        A command stream to set the callback for.
     * \param flush     A flush callback function associated with the command stream.
     * \param user      A user pointer that will be passed to the flush callback.
     */
    void (*cs_set_flush_callback)(struct radeon_winsys_cs *cs,
                                  void (*flush)(void *ctx, unsigned flags),
                                  void *ctx);

    /**
     * Return TRUE if a buffer is referenced by a command stream.
     *
     * \param cs        A command stream.
     * \param buf       A winsys buffer.
     */
    boolean (*cs_is_buffer_referenced)(struct radeon_winsys_cs *cs,
                                       struct radeon_winsys_cs_handle *buf,
                                       enum radeon_bo_usage usage);

    /**
     * Request access to a feature for a command stream.
     *
     * \param cs        A command stream.
     * \param fid       Feature ID, one of RADEON_FID_*
     * \param enable    Whether to enable or disable the feature.
     */
    boolean (*cs_request_feature)(struct radeon_winsys_cs *cs,
                                  enum radeon_feature_id fid,
                                  boolean enable);
     /**
      * Make sure all asynchronous flush of the cs have completed
      *
      * \param cs        A command stream.
      */
    void (*cs_sync_flush)(struct radeon_winsys_cs *cs);

    /**
     * Initialize surface
     *
     * \param ws        The winsys this function is called from.
     * \param surf      Surface structure ptr
     */
    int (*surface_init)(struct radeon_winsys *ws,
                        struct radeon_surface *surf);

    /**
     * Find best values for a surface
     *
     * \param ws        The winsys this function is called from.
     * \param surf      Surface structure ptr
     */
    int (*surface_best)(struct radeon_winsys *ws,
                        struct radeon_surface *surf);
d87 1
a87 3
    uint64_t (*query_value)(struct radeon_winsys *ws,
                            enum radeon_value_id value);
};
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d44 1
a44 1
#include "radeon_surface.h"
d64 1
a64 2
    RADEON_DOMAIN_VRAM = 4,
    RADEON_DOMAIN_VRAM_GTT = RADEON_DOMAIN_VRAM | RADEON_DOMAIN_GTT
a130 2
    CHIP_HAWAII,
    CHIP_MULLINS,
a150 1
    RING_VCE,
d158 1
a158 21
    RADEON_TIMESTAMP,
    RADEON_NUM_CS_FLUSHES,
    RADEON_NUM_BYTES_MOVED,
    RADEON_VRAM_USAGE,
    RADEON_GTT_USAGE
};

enum radeon_bo_priority {
    RADEON_PRIO_MIN,
    RADEON_PRIO_SHADER_DATA, /* shader code, resource descriptors */
    RADEON_PRIO_SHADER_BUFFER_RO, /* read-only */
    RADEON_PRIO_SHADER_TEXTURE_RO, /* read-only */
    RADEON_PRIO_SHADER_RESOURCE_RW, /* buffers, textures, streamout, GS rings, RATs; read/write */
    RADEON_PRIO_COLOR_BUFFER,
    RADEON_PRIO_DEPTH_BUFFER,
    RADEON_PRIO_SHADER_TEXTURE_MSAA,
    RADEON_PRIO_COLOR_BUFFER_MSAA,
    RADEON_PRIO_DEPTH_BUFFER_MSAA,
    RADEON_PRIO_COLOR_META,
    RADEON_PRIO_DEPTH_META,
    RADEON_PRIO_MAX /* must be <= 15 */
a175 1
    uint32_t                    max_sclk;
a181 1
    uint32_t                    vce_fw_version;
d190 3
d194 1
a196 9

    uint32_t                    r600_backend_map;
    boolean                     r600_backend_map_valid;

    boolean                     si_tile_mode_array_valid;
    uint32_t                    si_tile_mode_array[32];

    boolean                     cik_macrotile_mode_array_valid;
    uint32_t                    cik_macrotile_mode_array[16];
d206 1
a206 9
     * The screen object this winsys was created for
     */
    struct pipe_screen *screen;

    /**
     * Decrement the winsys reference count.
     *
     * \param ws  The winsys this function is called for.
     * \return    True if the winsys and screen should be destroyed.
d208 1
a208 1
    bool (*unref)(struct radeon_winsys *ws);
d308 1
a308 2
                              unsigned *mtilea,
                              bool *scanout);
d329 1
a329 2
                              unsigned stride,
                              bool scanout);
a364 5
    /**
     * Query the initial placement of the buffer from the kernel driver.
     */
    enum radeon_bo_domain (*buffer_get_initial_domain)(struct radeon_winsys_cs_handle *buf);

a376 2
     * \param flush     Flush callback function associated with the command stream.
     * \param user      User pointer that will be passed to the flush callback.
a380 3
                                          void (*flush)(void *ctx, unsigned flags,
							struct pipe_fence_handle **fence),
                                          void *flush_ctx,
a397 2
     * \param priority  A higher number means a greater chance of being
     *                  placed in the requested domain. 15 is the maximum.
d403 1
a403 12
                             enum radeon_bo_domain domain,
                             enum radeon_bo_priority priority);

    /**
     * Return the index of an already-added buffer.
     *
     * \param cs        Command stream
     * \param buf       Buffer
     * \return          The buffer index, or -1 if the buffer has not been added.
     */
    int (*cs_get_reloc)(struct radeon_winsys_cs *cs,
                        struct radeon_winsys_cs_handle *buf);
d426 9
d439 15
a453 8
     * \param fence       Pointer to a fence. If non-NULL, a fence is inserted
     *                    after the CS and is returned through this parameter.
     * \param cs_trace_id A unique identifier of the cs, used for tracing.
     */
    void (*cs_flush)(struct radeon_winsys_cs *cs,
                     unsigned flags,
                     struct pipe_fence_handle **fence,
                     uint32_t cs_trace_id);
a482 16
     * Wait for the fence and return true if the fence has been signalled.
     * The timeout of 0 will only return the status.
     * The timeout of PIPE_TIMEOUT_INFINITE will always wait until the fence
     * is signalled.
     */
    bool (*fence_wait)(struct radeon_winsys *ws,
                       struct pipe_fence_handle *fence,
                       uint64_t timeout);

    /**
     * Reference counting for fences.
     */
    void (*fence_reference)(struct pipe_fence_handle **dst,
                            struct pipe_fence_handle *src);

    /**
a502 13


static INLINE void radeon_emit(struct radeon_winsys_cs *cs, uint32_t value)
{
    cs->buf[cs->cdw++] = value;
}

static INLINE void radeon_emit_array(struct radeon_winsys_cs *cs,
				     const uint32_t *values, unsigned count)
{
    memcpy(cs->buf+cs->cdw, values, count * 4);
    cs->cdw += count;
}
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@d198 2
a199 2
    uint64_t                    gart_size;
    uint64_t                    vram_size;
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a67 6
enum radeon_bo_flag { /* bitfield */
    RADEON_FLAG_GTT_WC =        (1 << 0),
    RADEON_FLAG_CPU_ACCESS =    (1 << 1),
    RADEON_FLAG_NO_CPU_ACCESS = (1 << 2),
};

a200 3
    uint32_t                    max_compute_units;
    uint32_t                    max_se;
    uint32_t                    max_sh_per_se;
a224 1
    uint32_t                    si_backend_enabled_mask;
d287 1
a287 2
                                       enum radeon_bo_domain domain,
                                       enum radeon_bo_flag flags);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d68 6
d207 3
d234 1
d297 2
a298 1
                                       enum radeon_bo_domain domain);
@


