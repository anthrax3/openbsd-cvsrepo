head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.42;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.18;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.56;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.24;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2010 LunarG Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#include <sys/mman.h>
#include <sys/ioctl.h>
#include <linux/fb.h>

#include "pipe/p_compiler.h"
#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "state_tracker/sw_winsys.h"

#include "fbdev_sw_winsys.h"

struct fbdev_sw_displaytarget
{
   enum pipe_format format;
   unsigned width;
   unsigned height;
   unsigned stride;

   void *data;
   void *mapped;
};

struct fbdev_sw_winsys
{
   struct sw_winsys base;

   int fd;

   struct fb_fix_screeninfo finfo;
   unsigned rows;
   unsigned stride;
};

static INLINE struct fbdev_sw_displaytarget *
fbdev_sw_displaytarget(struct sw_displaytarget *dt)
{
   return (struct fbdev_sw_displaytarget *) dt;
}

static INLINE struct fbdev_sw_winsys *
fbdev_sw_winsys(struct sw_winsys *ws)
{
   return (struct fbdev_sw_winsys *) ws;
}

static void
fbdev_displaytarget_display(struct sw_winsys *ws,
                            struct sw_displaytarget *dt,
                            void *winsys_private,
                            struct pipe_box *box)
{
   struct fbdev_sw_winsys *fbdev = fbdev_sw_winsys(ws);
   struct fbdev_sw_displaytarget *src = fbdev_sw_displaytarget(dt);
   const struct fbdev_sw_drawable *dst =
      (const struct fbdev_sw_drawable *) winsys_private;
   unsigned height, row_offset, row_len, i;
   void *fbmem;

   /* FIXME format conversion */
   if (dst->format != src->format) {
      assert(0);
      return;
   }

   height = dst->height;
   if (dst->y + dst->height > fbdev->rows) {
      /* nothing to copy */
      if (dst->y >= fbdev->rows)
         return;

      height = fbdev->rows - dst->y;
   }

   row_offset = util_format_get_stride(dst->format, dst->x);
   row_len = util_format_get_stride(dst->format, dst->width);
   if (row_offset + row_len > fbdev->stride) {
      /* nothing to copy */
      if (row_offset >= fbdev->stride)
         return;

      row_len = fbdev->stride - row_offset;
   }

   fbmem = mmap(0, fbdev->finfo.smem_len,
         PROT_WRITE, MAP_SHARED, fbdev->fd, 0);
   if (fbmem == MAP_FAILED)
      return;

   for (i = 0; i < height; i++) {
      char *from = (char *) src->data + src->stride * i;
      char *to = (char *) fbmem + fbdev->stride * (dst->y + i) + row_offset;

      memcpy(to, from, row_len);
   }

   munmap(fbmem, fbdev->finfo.smem_len);
}

static void
fbdev_displaytarget_unmap(struct sw_winsys *ws,
                           struct sw_displaytarget *dt)
{
   struct fbdev_sw_displaytarget *fbdt = fbdev_sw_displaytarget(dt);
   fbdt->mapped = NULL;
}

static void *
fbdev_displaytarget_map(struct sw_winsys *ws,
                        struct sw_displaytarget *dt,
                        unsigned flags)
{
   struct fbdev_sw_displaytarget *fbdt = fbdev_sw_displaytarget(dt);
   fbdt->mapped = fbdt->data;
   return fbdt->mapped;
}

static void
fbdev_displaytarget_destroy(struct sw_winsys *ws,
                            struct sw_displaytarget *dt)
{
   struct fbdev_sw_displaytarget *fbdt = fbdev_sw_displaytarget(dt);

   if (fbdt->data)
      align_free(fbdt->data);

   FREE(fbdt);
}

static struct sw_displaytarget *
fbdev_displaytarget_create(struct sw_winsys *ws,
                           unsigned tex_usage,
                           enum pipe_format format,
                           unsigned width, unsigned height,
                           unsigned alignment,
                           unsigned *stride)
{
   struct fbdev_sw_displaytarget *fbdt;
   unsigned nblocksy, size, format_stride;

   fbdt = CALLOC_STRUCT(fbdev_sw_displaytarget);
   if (!fbdt)
      return NULL;

   fbdt->format = format;
   fbdt->width = width;
   fbdt->height = height;

   format_stride = util_format_get_stride(format, width);
   fbdt->stride = align(format_stride, alignment);

   nblocksy = util_format_get_nblocksy(format, height);
   size = fbdt->stride * nblocksy;

   fbdt->data = align_malloc(size, alignment);
   if (!fbdt->data) {
      FREE(fbdt);
      return NULL;
   }

   *stride = fbdt->stride;

   return (struct sw_displaytarget *) fbdt;
}

static boolean
fbdev_is_displaytarget_format_supported(struct sw_winsys *ws,
                                        unsigned tex_usage,
                                        enum pipe_format format)
{
   return TRUE;
}

static void
fbdev_destroy(struct sw_winsys *ws)
{
   struct fbdev_sw_winsys *fbdev = fbdev_sw_winsys(ws);

   FREE(fbdev);
}

struct sw_winsys *
fbdev_create_sw_winsys(int fd)
{
   struct fbdev_sw_winsys *fbdev;

   fbdev = CALLOC_STRUCT(fbdev_sw_winsys);
   if (!fbdev)
      return NULL;

   fbdev->fd = fd;
   if (ioctl(fbdev->fd, FBIOGET_FSCREENINFO, &fbdev->finfo)) {
      FREE(fbdev);
      return NULL;
   }

   fbdev->rows = fbdev->finfo.smem_len / fbdev->finfo.line_length;
   fbdev->stride = fbdev->finfo.line_length;

   fbdev->base.destroy = fbdev_destroy;
   fbdev->base.is_displaytarget_format_supported =
      fbdev_is_displaytarget_format_supported;

   fbdev->base.displaytarget_create = fbdev_displaytarget_create;
   fbdev->base.displaytarget_destroy = fbdev_displaytarget_destroy;
   fbdev->base.displaytarget_map = fbdev_displaytarget_map;
   fbdev->base.displaytarget_unmap = fbdev_displaytarget_unmap;

   fbdev->base.displaytarget_display = fbdev_displaytarget_display;

   return &fbdev->base;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d77 2
a78 1
                            void *winsys_private)
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.9
@


1.1
log
@Initial revision
@
text
@a56 1
   enum pipe_format format;
a58 1
   void *fbmem;
d78 1
a78 1
                            void *context_private)
d81 5
a85 2
   struct fbdev_sw_displaytarget *fbdt = fbdev_sw_displaytarget(dt);
   unsigned rows, len, i;
d87 5
a91 3
   rows = MIN2(fbdt->height, fbdev->rows);
   len = util_format_get_stride(fbdt->format, fbdt->width);
   len = MIN2(len, fbdev->stride);
d93 5
a97 3
   for (i = 0; i < rows; i++) {
      void *dst = fbdev->fbmem + fbdev->stride * i;
      void *src = fbdt->data + fbdt->stride * i;
d99 1
a99 1
      memcpy(dst, src, len);
d101 24
a164 1
   struct fbdev_sw_winsys *fbdev = fbdev_sw_winsys(ws);
a167 3
   if (fbdev->format != format)
      return NULL;

d198 1
a198 2
   struct fbdev_sw_winsys *fbdev = fbdev_sw_winsys(ws);
   return (fbdev->format == format);
a205 1
   munmap(fbdev->fbmem, fbdev->finfo.smem_len);
d210 1
a210 1
fbdev_create_sw_winsys(int fd, enum pipe_format format)
a218 1
   fbdev->format = format;
a219 7
      FREE(fbdev);
      return NULL;
   }

   fbdev->fbmem = mmap(0, fbdev->finfo.smem_len,
         PROT_WRITE, MAP_SHARED, fbdev->fd, 0);
   if (fbdev->fbmem == MAP_FAILED) {
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d57 1
d60 1
d80 1
a80 1
                            void *winsys_private)
d83 2
a84 30
   struct fbdev_sw_displaytarget *src = fbdev_sw_displaytarget(dt);
   const struct fbdev_sw_drawable *dst =
      (const struct fbdev_sw_drawable *) winsys_private;
   unsigned height, row_offset, row_len, i;
   void *fbmem;

   /* FIXME format conversion */
   if (dst->format != src->format) {
      assert(0);
      return;
   }

   height = dst->height;
   if (dst->y + dst->height > fbdev->rows) {
      /* nothing to copy */
      if (dst->y >= fbdev->rows)
         return;

      height = fbdev->rows - dst->y;
   }

   row_offset = util_format_get_stride(dst->format, dst->x);
   row_len = util_format_get_stride(dst->format, dst->width);
   if (row_offset + row_len > fbdev->stride) {
      /* nothing to copy */
      if (row_offset >= fbdev->stride)
         return;

      row_len = fbdev->stride - row_offset;
   }
d86 3
a88 4
   fbmem = mmap(0, fbdev->finfo.smem_len,
         PROT_WRITE, MAP_SHARED, fbdev->fd, 0);
   if (fbmem == MAP_FAILED)
      return;
d90 3
a92 3
   for (i = 0; i < height; i++) {
      char *from = (char *) src->data + src->stride * i;
      char *to = (char *) fbmem + fbdev->stride * (dst->y + i) + row_offset;
d94 1
a94 1
      memcpy(to, from, row_len);
a95 2

   munmap(fbmem, fbdev->finfo.smem_len);
d136 1
d140 3
d173 2
a174 1
   return TRUE;
d182 1
d187 1
a187 1
fbdev_create_sw_winsys(int fd)
d196 1
d198 7
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d77 1
a77 2
                            void *winsys_private,
                            struct pipe_box *box)
@


