head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.42;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.56;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2013.09.05.14.02.19;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.57;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.09.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.47.06;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2010 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/


#include "wrapper_sw_winsys.h"

#include "pipe/p_format.h"
#include "pipe/p_state.h"

#include "state_tracker/sw_winsys.h"

#include "util/u_memory.h"
#include "util/u_inlines.h"

/*
 * This code wraps a pipe_screen and exposes a sw_winsys interface for use
 * with software resterizers. This code is used by the DRM based winsys to
 * allow access to the drm driver.
 *
 * We must borrow the whole stack because only the pipe screen knows how
 * to decode the content of a buffer. Or how to create a buffer that
 * can still be used by drivers using real hardware (as the case is
 * with software st/xorg but hw st/dri).
 *
 * We also need a pipe context for the transfers.
 */

struct wrapper_sw_winsys
{
   struct sw_winsys base;
   struct pipe_screen *screen;
   struct pipe_context *pipe;
   enum pipe_texture_target target;
};

struct wrapper_sw_displaytarget
{
   struct wrapper_sw_winsys *winsys;
   struct pipe_resource *tex;
   struct pipe_transfer *transfer;

   unsigned map_count;
   unsigned stride; /**< because we get stride at create */
   void *ptr;
};

static INLINE struct wrapper_sw_winsys *
wrapper_sw_winsys(struct sw_winsys *ws)
{
   return (struct wrapper_sw_winsys *)ws;
}

static INLINE struct wrapper_sw_displaytarget *
wrapper_sw_displaytarget(struct sw_displaytarget *dt)
{
   return (struct wrapper_sw_displaytarget *)dt;
}


/*
 * Functions
 */


static boolean
wsw_dt_get_stride(struct wrapper_sw_displaytarget *wdt, unsigned *stride)
{
   struct pipe_context *pipe = wdt->winsys->pipe;
   struct pipe_resource *tex = wdt->tex;
   struct pipe_transfer *tr;
   void *map;

   map = pipe_transfer_map(pipe, tex, 0, 0,
                           PIPE_TRANSFER_READ_WRITE,
                           0, 0, wdt->tex->width0, wdt->tex->height0, &tr);
   if (!map)
      return FALSE;

   *stride = tr->stride;
   wdt->stride = tr->stride;

   pipe->transfer_unmap(pipe, tr);

   return TRUE;
}

static struct sw_displaytarget *
wsw_dt_wrap_texture(struct wrapper_sw_winsys *wsw,
                    struct pipe_resource *tex, unsigned *stride)
{
   struct wrapper_sw_displaytarget *wdt = CALLOC_STRUCT(wrapper_sw_displaytarget);
   if (!wdt)
      goto err_unref;

   wdt->tex = tex;
   wdt->winsys = wsw;

   if (!wsw_dt_get_stride(wdt, stride))
      goto err_free;

   return (struct sw_displaytarget *)wdt;

err_free:
   FREE(wdt);
err_unref:
   pipe_resource_reference(&tex, NULL);
   return NULL;
}

static struct sw_displaytarget *
wsw_dt_create(struct sw_winsys *ws,
              unsigned bind,
              enum pipe_format format,
              unsigned width, unsigned height,
              unsigned alignment,
              unsigned *stride)
{
   struct wrapper_sw_winsys *wsw = wrapper_sw_winsys(ws);
   struct pipe_resource templ;
   struct pipe_resource *tex;

   /*
    * XXX Why don't we just get the template.
    */
   memset(&templ, 0, sizeof(templ));
   templ.target = wsw->target;
   templ.width0 = width;
   templ.height0 = height;
   templ.depth0 = 1;
   templ.array_size = 1;
   templ.format = format;
   templ.bind = bind;

   /* XXX alignment: we can't do anything about this */

   tex = wsw->screen->resource_create(wsw->screen, &templ);
   if (!tex)
      return NULL;

   return wsw_dt_wrap_texture(wsw, tex, stride);
}

static struct sw_displaytarget *
wsw_dt_from_handle(struct sw_winsys *ws,
                   const struct pipe_resource *templ,
                   struct winsys_handle *whandle,
                   unsigned *stride)
{
   struct wrapper_sw_winsys *wsw = wrapper_sw_winsys(ws);
   struct pipe_resource *tex;

   tex = wsw->screen->resource_from_handle(wsw->screen, templ, whandle);
   if (!tex)
      return NULL;

   return wsw_dt_wrap_texture(wsw, tex, stride);
}

static boolean
wsw_dt_get_handle(struct sw_winsys *ws,
                  struct sw_displaytarget *dt,
                  struct winsys_handle *whandle)
{
   struct wrapper_sw_winsys *wsw = wrapper_sw_winsys(ws);
   struct wrapper_sw_displaytarget *wdt = wrapper_sw_displaytarget(dt);
   struct pipe_resource *tex = wdt->tex;

   return wsw->screen->resource_get_handle(wsw->screen, tex, whandle);
}

static void *
wsw_dt_map(struct sw_winsys *ws,
           struct sw_displaytarget *dt,
           unsigned flags)
{
   struct wrapper_sw_displaytarget *wdt = wrapper_sw_displaytarget(dt);
   struct pipe_context *pipe = wdt->winsys->pipe;
   struct pipe_resource *tex = wdt->tex;
   struct pipe_transfer *tr;
   void *ptr;

   if (!wdt->map_count) {

      assert(!wdt->transfer);

      ptr = pipe_transfer_map(pipe, tex, 0, 0,
                              PIPE_TRANSFER_READ_WRITE,
                              0, 0, wdt->tex->width0, wdt->tex->height0, &tr);
      if (!ptr)
        goto err;

      wdt->transfer = tr;
      wdt->ptr = ptr;

      /* XXX Handle this case */
      assert(tr->stride == wdt->stride);
   }

   wdt->map_count++;

   return wdt->ptr;

err:
   pipe->transfer_unmap(pipe, tr);
   return NULL;
}

static void
wsw_dt_unmap(struct sw_winsys *ws,
             struct sw_displaytarget *dt)
{
   struct wrapper_sw_displaytarget *wdt = wrapper_sw_displaytarget(dt);
   struct pipe_context *pipe = wdt->winsys->pipe;

   assert(wdt->transfer);

   wdt->map_count--;

   if (wdt->map_count)
      return;

   pipe->transfer_unmap(pipe, wdt->transfer);
   pipe->flush(pipe, NULL, 0);
   wdt->transfer = NULL;
}

static void
wsw_dt_destroy(struct sw_winsys *ws,
               struct sw_displaytarget *dt)
{
   struct wrapper_sw_displaytarget *wdt = wrapper_sw_displaytarget(dt);

   pipe_resource_reference(&wdt->tex, NULL);

   FREE(wdt);
}

static void
wsw_destroy(struct sw_winsys *ws)
{
   struct wrapper_sw_winsys *wsw = wrapper_sw_winsys(ws);

   wsw->pipe->destroy(wsw->pipe);
   wsw->screen->destroy(wsw->screen);

   FREE(wsw);
}

struct sw_winsys *
wrapper_sw_winsys_wrap_pipe_screen(struct pipe_screen *screen)
{
   struct wrapper_sw_winsys *wsw = CALLOC_STRUCT(wrapper_sw_winsys);

   if (!wsw)
      goto err;

   wsw->base.displaytarget_create = wsw_dt_create;
   wsw->base.displaytarget_from_handle = wsw_dt_from_handle;
   wsw->base.displaytarget_get_handle = wsw_dt_get_handle;
   wsw->base.displaytarget_map = wsw_dt_map;
   wsw->base.displaytarget_unmap = wsw_dt_unmap;
   wsw->base.displaytarget_destroy = wsw_dt_destroy;
   wsw->base.destroy = wsw_destroy;

   wsw->screen = screen;
   wsw->pipe = screen->context_create(screen, NULL);
   if (!wsw->pipe)
      goto err_free;

   if(screen->get_param(screen, PIPE_CAP_NPOT_TEXTURES))
      wsw->target = PIPE_TEXTURE_2D;
   else
      wsw->target = PIPE_TEXTURE_RECT;

   return &wsw->base;

err_free:
   FREE(wsw);
err:
   return NULL;
}

struct pipe_screen *
wrapper_sw_winsys_dewrap_pipe_screen(struct sw_winsys *ws)
{
   struct wrapper_sw_winsys *wsw = wrapper_sw_winsys(ws);
   struct pipe_screen *screen = wsw->screen;

   wsw->pipe->destroy(wsw->pipe);
   /* don't destroy the screen its needed later on */

   FREE(wsw);
   return screen;
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a87 13
wsw_is_dt_format_supported(struct sw_winsys *ws,
                           unsigned tex_usage,
                           enum pipe_format format)
{
   struct wrapper_sw_winsys *wsw = wrapper_sw_winsys(ws);

   return wsw->screen->is_format_supported(wsw->screen, format,
                                           PIPE_TEXTURE_2D, 0,
                                           PIPE_BIND_RENDER_TARGET |
                                           PIPE_BIND_DISPLAY_TARGET);
}

static boolean
a278 1
   wsw->base.is_displaytarget_format_supported = wsw_is_dt_format_supported;
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d88 13
d292 1
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d93 1
d95 4
a98 4
   tr = pipe_get_transfer(pipe, tex, 0, 0,
                          PIPE_TRANSFER_READ_WRITE,
                          0, 0, wdt->tex->width0, wdt->tex->height0);
   if (!tr)
d104 1
a104 1
   pipe->transfer_destroy(pipe, tr);
d208 3
a210 7
      tr = pipe_get_transfer(pipe, tex, 0, 0,
                             PIPE_TRANSFER_READ_WRITE,
                             0, 0, wdt->tex->width0, wdt->tex->height0);
      if (!tr)
         return NULL;

      ptr = pipe->transfer_map(pipe, tr);
d226 1
a226 1
   pipe->transfer_destroy(pipe, tr);
d245 1
a245 2
   pipe->transfer_destroy(pipe, wdt->transfer);
   pipe->flush(pipe, NULL);
@


1.1
log
@Initial revision
@
text
@a63 2
   unsigned width;
   unsigned height;
d65 1
a65 1
   unsigned stride; /**< because we give stride at create */
d96 1
a96 1
                          0, 0, wdt->width, wdt->height);
d209 1
a209 1
                             0, 0, wdt->width, wdt->height);
d249 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d64 2
d67 1
a67 1
   unsigned stride; /**< because we get stride at create */
a94 1
   void *map;
d96 4
a99 4
   map = pipe_transfer_map(pipe, tex, 0, 0,
                           PIPE_TRANSFER_READ_WRITE,
                           0, 0, wdt->tex->width0, wdt->tex->height0, &tr);
   if (!map)
d105 1
a105 1
   pipe->transfer_unmap(pipe, tr);
d209 7
a215 3
      ptr = pipe_transfer_map(pipe, tex, 0, 0,
                              PIPE_TRANSFER_READ_WRITE,
                              0, 0, wdt->tex->width0, wdt->tex->height0, &tr);
d231 1
a231 1
   pipe->transfer_unmap(pipe, tr);
d250 1
a250 1
   pipe->flush(pipe, NULL, 0);
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a87 13
wsw_is_dt_format_supported(struct sw_winsys *ws,
                           unsigned tex_usage,
                           enum pipe_format format)
{
   struct wrapper_sw_winsys *wsw = wrapper_sw_winsys(ws);

   return wsw->screen->is_format_supported(wsw->screen, format,
                                           PIPE_TEXTURE_2D, 0,
                                           PIPE_BIND_RENDER_TARGET |
                                           PIPE_BIND_DISPLAY_TARGET);
}

static boolean
a278 1
   wsw->base.is_displaytarget_format_supported = wsw_is_dt_format_supported;
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d88 13
d292 1
@


