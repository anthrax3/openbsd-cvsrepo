head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.15;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.01;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.25;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.03;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.09;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


/**
 * @@file
 * 
 * Abstract graphics pipe state objects.
 *
 * Basic notes:
 *   1. Want compact representations, so we use bitfields.
 *   2. Put bitfields before other (GLfloat) fields.
 */


#ifndef PIPE_STATE_H
#define PIPE_STATE_H

#include "p_compiler.h"
#include "p_defines.h"
#include "p_format.h"


#ifdef __cplusplus
extern "C" {
#endif


/**
 * Implementation limits
 */
#define PIPE_MAX_ATTRIBS          32
#define PIPE_MAX_CLIP_PLANES       8
#define PIPE_MAX_COLOR_BUFS        8
#define PIPE_MAX_CONSTANT_BUFFERS 32
#define PIPE_MAX_SAMPLERS         16
#define PIPE_MAX_SHADER_INPUTS    32
#define PIPE_MAX_SHADER_OUTPUTS   48 /* 32 GENERICs + POS, PSIZE, FOG, etc. */
#define PIPE_MAX_SHADER_SAMPLER_VIEWS 32
#define PIPE_MAX_SHADER_RESOURCES 32
#define PIPE_MAX_TEXTURE_LEVELS   16
#define PIPE_MAX_SO_BUFFERS        4
#define PIPE_MAX_SO_OUTPUTS       64
#define PIPE_MAX_VIEWPORTS        16
#define PIPE_MAX_CLIP_OR_CULL_DISTANCE_COUNT 8
#define PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT 2


struct pipe_reference
{
   int32_t count; /* atomic */
};



/**
 * Primitive (point/line/tri) rasterization info
 */
struct pipe_rasterizer_state
{
   unsigned flatshade:1;
   unsigned light_twoside:1;
   unsigned clamp_vertex_color:1;
   unsigned clamp_fragment_color:1;
   unsigned front_ccw:1;
   unsigned cull_face:2;      /**< PIPE_FACE_x */
   unsigned fill_front:2;     /**< PIPE_POLYGON_MODE_x */
   unsigned fill_back:2;      /**< PIPE_POLYGON_MODE_x */
   unsigned offset_point:1;
   unsigned offset_line:1;
   unsigned offset_tri:1;
   unsigned scissor:1;
   unsigned poly_smooth:1;
   unsigned poly_stipple_enable:1;
   unsigned point_smooth:1;
   unsigned sprite_coord_mode:1;     /**< PIPE_SPRITE_COORD_ */
   unsigned point_quad_rasterization:1; /** points rasterized as quads or points */
   unsigned point_tri_clip:1; /** large points clipped as tris or points */
   unsigned point_size_per_vertex:1; /**< size computed in vertex shader */
   unsigned multisample:1;         /* XXX maybe more ms state in future */
   unsigned line_smooth:1;
   unsigned line_stipple_enable:1;
   unsigned line_last_pixel:1;

   /**
    * Use the first vertex of a primitive as the provoking vertex for
    * flat shading.
    */
   unsigned flatshade_first:1;

   unsigned half_pixel_center:1;
   unsigned bottom_edge_rule:1;

   /**
    * When true, rasterization is disabled and no pixels are written.
    * This only makes sense with the Stream Out functionality.
    */
   unsigned rasterizer_discard:1;

   /**
    * When false, depth clipping is disabled and the depth value will be
    * clamped later at the per-pixel level before depth testing.
    * This depends on PIPE_CAP_DEPTH_CLIP_DISABLE.
    */
   unsigned depth_clip:1;

   /**
    * When true clip space in the z axis goes from [0..1] (D3D).  When false
    * [-1, 1] (GL).
    *
    * NOTE: D3D will always use depth clamping.
    */
   unsigned clip_halfz:1;

   /**
    * Enable bits for clipping half-spaces.
    * This applies to both user clip planes and shader clip distances.
    * Note that if the bound shader exports any clip distances, these
    * replace all user clip planes, and clip half-spaces enabled here
    * but not written by the shader count as disabled.
    */
   unsigned clip_plane_enable:PIPE_MAX_CLIP_PLANES;

   unsigned line_stipple_factor:8;  /**< [1..256] actually */
   unsigned line_stipple_pattern:16;

   uint32_t sprite_coord_enable; /* referring to 32 TEXCOORD/GENERIC inputs */

   float line_width;
   float point_size;           /**< used when no per-vertex size */
   float offset_units;
   float offset_scale;
   float offset_clamp;
};


struct pipe_poly_stipple
{
   unsigned stipple[32];
};


struct pipe_viewport_state
{
   float scale[4];
   float translate[4];
};


struct pipe_scissor_state
{
   unsigned minx:16;
   unsigned miny:16;
   unsigned maxx:16;
   unsigned maxy:16;
};


struct pipe_clip_state
{
   float ucp[PIPE_MAX_CLIP_PLANES][4];
};


/**
 * Stream output for vertex transform feedback.
 */
struct pipe_stream_output_info
{
   unsigned num_outputs;
   /** stride for an entire vertex for each buffer in dwords */
   unsigned stride[PIPE_MAX_SO_BUFFERS];

   /**
    * Array of stream outputs, in the order they are to be written in.
    * Selected components are tightly packed into the output buffer.
    */
   struct {
      unsigned register_index:8;  /**< 0 to PIPE_MAX_SHADER_OUTPUTS */
      unsigned start_component:2; /** 0 to 3 */
      unsigned num_components:3;  /** 1 to 4 */
      unsigned output_buffer:3;   /**< 0 to PIPE_MAX_SO_BUFFERS */
      unsigned dst_offset:16;     /**< offset into the buffer in dwords */
   } output[PIPE_MAX_SO_OUTPUTS];
};


struct pipe_shader_state
{
   const struct tgsi_token *tokens;
   struct pipe_stream_output_info stream_output;
};


struct pipe_depth_state 
{
   unsigned enabled:1;         /**< depth test enabled? */
   unsigned writemask:1;       /**< allow depth buffer writes? */
   unsigned func:3;            /**< depth test func (PIPE_FUNC_x) */
};


struct pipe_stencil_state
{
   unsigned enabled:1;  /**< stencil[0]: stencil enabled, stencil[1]: two-side enabled */
   unsigned func:3;     /**< PIPE_FUNC_x */
   unsigned fail_op:3;  /**< PIPE_STENCIL_OP_x */
   unsigned zpass_op:3; /**< PIPE_STENCIL_OP_x */
   unsigned zfail_op:3; /**< PIPE_STENCIL_OP_x */
   unsigned valuemask:8;
   unsigned writemask:8;
};


struct pipe_alpha_state
{
   unsigned enabled:1;
   unsigned func:3;     /**< PIPE_FUNC_x */
   float ref_value;     /**< reference value */
};


struct pipe_depth_stencil_alpha_state
{
   struct pipe_depth_state depth;
   struct pipe_stencil_state stencil[2]; /**< [0] = front, [1] = back */
   struct pipe_alpha_state alpha;
};


struct pipe_rt_blend_state
{
   unsigned blend_enable:1;

   unsigned rgb_func:3;          /**< PIPE_BLEND_x */
   unsigned rgb_src_factor:5;    /**< PIPE_BLENDFACTOR_x */
   unsigned rgb_dst_factor:5;    /**< PIPE_BLENDFACTOR_x */

   unsigned alpha_func:3;        /**< PIPE_BLEND_x */
   unsigned alpha_src_factor:5;  /**< PIPE_BLENDFACTOR_x */
   unsigned alpha_dst_factor:5;  /**< PIPE_BLENDFACTOR_x */

   unsigned colormask:4;         /**< bitmask of PIPE_MASK_R/G/B/A */
};

struct pipe_blend_state
{
   unsigned independent_blend_enable:1;
   unsigned logicop_enable:1;
   unsigned logicop_func:4;      /**< PIPE_LOGICOP_x */
   unsigned dither:1;
   unsigned alpha_to_coverage:1;
   unsigned alpha_to_one:1;
   struct pipe_rt_blend_state rt[PIPE_MAX_COLOR_BUFS];
};


struct pipe_blend_color
{
   float color[4];
};

struct pipe_stencil_ref
{
   ubyte ref_value[2];
};

struct pipe_framebuffer_state
{
   unsigned width, height;

   /** multiple color buffers for multiple render targets */
   unsigned nr_cbufs;
   struct pipe_surface *cbufs[PIPE_MAX_COLOR_BUFS];

   struct pipe_surface *zsbuf;      /**< Z/stencil buffer */
};


/**
 * Texture sampler state.
 */
struct pipe_sampler_state
{
   unsigned wrap_s:3;            /**< PIPE_TEX_WRAP_x */
   unsigned wrap_t:3;            /**< PIPE_TEX_WRAP_x */
   unsigned wrap_r:3;            /**< PIPE_TEX_WRAP_x */
   unsigned min_img_filter:2;    /**< PIPE_TEX_FILTER_x */
   unsigned min_mip_filter:2;    /**< PIPE_TEX_MIPFILTER_x */
   unsigned mag_img_filter:2;    /**< PIPE_TEX_FILTER_x */
   unsigned compare_mode:1;      /**< PIPE_TEX_COMPARE_x */
   unsigned compare_func:3;      /**< PIPE_FUNC_x */
   unsigned normalized_coords:1; /**< Are coords normalized to [0,1]? */
   unsigned max_anisotropy:6;
   unsigned seamless_cube_map:1;
   float lod_bias;               /**< LOD/lambda bias */
   float min_lod, max_lod;       /**< LOD clamp range, after bias */
   union pipe_color_union border_color;
};


/**
 * A view into a texture that can be bound to a color render target /
 * depth stencil attachment point.
 */
struct pipe_surface
{
   struct pipe_reference reference;
   struct pipe_resource *texture; /**< resource into which this is a view  */
   struct pipe_context *context; /**< context this surface belongs to */
   enum pipe_format format;

   /* XXX width/height should be removed */
   unsigned width;               /**< logical width in pixels */
   unsigned height;              /**< logical height in pixels */

   unsigned writable:1;          /**< writable shader resource */

   union {
      struct {
         unsigned level;
         unsigned first_layer:16;
         unsigned last_layer:16;
      } tex;
      struct {
         unsigned first_element;
         unsigned last_element;
      } buf;
   } u;
};


/**
 * A view into a texture that can be bound to a shader stage.
 */
struct pipe_sampler_view
{
   struct pipe_reference reference;
   enum pipe_format format;      /**< typed PIPE_FORMAT_x */
   struct pipe_resource *texture; /**< texture into which this is a view  */
   struct pipe_context *context; /**< context this view belongs to */
   union {
      struct {
         unsigned first_layer:16;     /**< first layer to use for array textures */
         unsigned last_layer:16;      /**< last layer to use for array textures */
         unsigned first_level:8;      /**< first mipmap level to use */
         unsigned last_level:8;       /**< last mipmap level to use */
      } tex;
      struct {
         unsigned first_element;
         unsigned last_element;
      } buf;
   } u;
   unsigned swizzle_r:3;         /**< PIPE_SWIZZLE_x for red component */
   unsigned swizzle_g:3;         /**< PIPE_SWIZZLE_x for green component */
   unsigned swizzle_b:3;         /**< PIPE_SWIZZLE_x for blue component */
   unsigned swizzle_a:3;         /**< PIPE_SWIZZLE_x for alpha component */
};


/**
 * Subregion of 1D/2D/3D image resource.
 */
struct pipe_box
{
   int x;
   int y;
   int z;
   int width;
   int height;
   int depth;
};


/**
 * A memory object/resource such as a vertex buffer or texture.
 */
struct pipe_resource
{
   struct pipe_reference reference;
   struct pipe_screen *screen; /**< screen that this texture belongs to */
   enum pipe_texture_target target; /**< PIPE_TEXTURE_x */
   enum pipe_format format;         /**< PIPE_FORMAT_x */

   unsigned width0;
   unsigned height0;
   unsigned depth0;
   unsigned array_size;

   unsigned last_level:8;    /**< Index of last mipmap level present/defined */
   unsigned nr_samples:8;    /**< for multisampled surfaces, nr of samples */
   unsigned usage:8;         /**< PIPE_USAGE_x (not a bitmask) */

   unsigned bind;            /**< bitmask of PIPE_BIND_x */
   unsigned flags;           /**< bitmask of PIPE_RESOURCE_FLAG_x */
};


/**
 * Transfer object.  For data transfer to/from a resource.
 */
struct pipe_transfer
{
   struct pipe_resource *resource; /**< resource to transfer to/from  */
   unsigned level;                 /**< texture mipmap level */
   enum pipe_transfer_usage usage;
   struct pipe_box box;            /**< region of the resource to access */
   unsigned stride;                /**< row stride in bytes */
   unsigned layer_stride;          /**< image/layer stride in bytes */
};



/**
 * A vertex buffer.  Typically, all the vertex data/attributes for
 * drawing something will be in one buffer.  But it's also possible, for
 * example, to put colors in one buffer and texcoords in another.
 */
struct pipe_vertex_buffer
{
   unsigned stride;    /**< stride to same attrib in next vertex, in bytes */
   unsigned buffer_offset;  /**< offset to start of data in buffer, in bytes */
   struct pipe_resource *buffer;  /**< the actual buffer */
   const void *user_buffer;  /**< pointer to a user buffer if buffer == NULL */
};


/**
 * A constant buffer.  A subrange of an existing buffer can be set
 * as a constant buffer.
 */
struct pipe_constant_buffer {
   struct pipe_resource *buffer; /**< the actual buffer */
   unsigned buffer_offset; /**< offset to start of data in buffer, in bytes */
   unsigned buffer_size;   /**< how much data can be read in shader */
   const void *user_buffer;  /**< pointer to a user buffer if buffer == NULL */
};


/**
 * A stream output target. The structure specifies the range vertices can
 * be written to.
 *
 * In addition to that, the structure should internally maintain the offset
 * into the buffer, which should be incremented everytime something is written
 * (appended) to it. The internal offset is buffer_offset + how many bytes
 * have been written. The internal offset can be stored on the device
 * and the CPU actually doesn't have to query it.
 *
 * Note that the buffer_size variable is actually specifying the available
 * space in the buffer, not the size of the attached buffer. 
 * In other words in majority of cases buffer_size would simply be 
 * 'buffer->width0 - buffer_offset', so buffer_size refers to the size
 * of the buffer left, after accounting for buffer offset, for stream output
 * to write to.
 *
 * Use PIPE_QUERY_SO_STATISTICS to know how many primitives have
 * actually been written.
 */
struct pipe_stream_output_target
{
   struct pipe_reference reference;
   struct pipe_resource *buffer; /**< the output buffer */
   struct pipe_context *context; /**< context this SO target belongs to */

   unsigned buffer_offset;  /**< offset where data should be written, in bytes */
   unsigned buffer_size;    /**< how much data is allowed to be written */
};


/**
 * Information to describe a vertex attribute (position, color, etc)
 */
struct pipe_vertex_element
{
   /** Offset of this attribute, in bytes, from the start of the vertex */
   unsigned src_offset;

   /** Instance data rate divisor. 0 means this is per-vertex data,
    *  n means per-instance data used for n consecutive instances (n > 0).
    */
   unsigned instance_divisor;

   /** Which vertex_buffer (as given to pipe->set_vertex_buffer()) does
    * this attribute live in?
    */
   unsigned vertex_buffer_index;
 
   enum pipe_format src_format;
};


/**
 * An index buffer.  When an index buffer is bound, all indices to vertices
 * will be looked up in the buffer.
 */
struct pipe_index_buffer
{
   unsigned index_size;  /**< size of an index, in bytes */
   unsigned offset;  /**< offset to start of data in buffer, in bytes */
   struct pipe_resource *buffer; /**< the actual buffer */
   const void *user_buffer;  /**< pointer to a user buffer if buffer == NULL */
};


/**
 * Information to describe a draw_vbo call.
 */
struct pipe_draw_info
{
   boolean indexed;  /**< use index buffer */

   unsigned mode;  /**< the mode of the primitive */
   unsigned start;  /**< the index of the first vertex */
   unsigned count;  /**< number of vertices */

   unsigned start_instance; /**< first instance id */
   unsigned instance_count; /**< number of instances */

   /**
    * For indexed drawing, these fields apply after index lookup.
    */
   int index_bias; /**< a bias to be added to each index */
   unsigned min_index; /**< the min index */
   unsigned max_index; /**< the max index */

   /**
    * Primitive restart enable/index (only applies to indexed drawing)
    */
   boolean primitive_restart;
   unsigned restart_index;

   /**
    * Stream output target. If not NULL, it's used to provide the 'count'
    * parameter based on the number vertices captured by the stream output
    * stage. (or generally, based on the number of bytes captured)
    *
    * Only 'mode', 'start_instance', and 'instance_count' are taken into
    * account, all the other variables from pipe_draw_info are ignored.
    *
    * 'start' is implicitly 0 and 'count' is set as discussed above.
    * The draw command is non-indexed.
    *
    * Note that this only provides the count. The vertex buffers must
    * be set via set_vertex_buffers manually.
    */
   struct pipe_stream_output_target *count_from_stream_output;
};


/**
 * Information to describe a blit call.
 */
struct pipe_blit_info
{
   struct {
      struct pipe_resource *resource;
      unsigned level;
      struct pipe_box box; /**< negative width, height only legal for src */
      /* For pipe_surface-like format casting: */
      enum pipe_format format; /**< must be supported for sampling (src)
                               or rendering (dst), ZS is always supported */
   } dst, src;

   unsigned mask; /**< bitmask of PIPE_MASK_R/G/B/A/Z/S */
   unsigned filter; /**< PIPE_TEX_FILTER_* */

   boolean scissor_enable;
   struct pipe_scissor_state scissor;

   boolean render_condition_enable; /**< whether to leave current render
                                    condition enabled */
};


/**
 * Structure used as a header for serialized LLVM programs.
 */
struct pipe_llvm_program_header
{
   uint32_t num_bytes; /**< Number of bytes in the LLVM bytecode program. */
};

struct pipe_compute_state
{
   const void *prog; /**< Compute program to be executed. */
   unsigned req_local_mem; /**< Required size of the LOCAL resource. */
   unsigned req_private_mem; /**< Required size of the PRIVATE resource. */
   unsigned req_input_mem; /**< Required size of the INPUT resource. */
};

#ifdef __cplusplus
}
#endif
   
#endif
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a207 1
      unsigned stream:2;          /**< 0 to 3 */
a362 1
   enum pipe_texture_target target; /**< PIPE_TEXTURE_x */
a571 22

   /* Indirect parameters resource: If not NULL, most values are taken
    * from this buffer instead, which is laid out as follows:
    *
    * if indexed is TRUE:
    *  struct {
    *     uint32_t count;
    *     uint32_t instance_count;
    *     uint32_t start;
    *     int32_t index_bias;
    *     uint32_t start_instance;
    *  };
    * otherwise:
    *  struct {
    *     uint32_t count;
    *     uint32_t instance_count;
    *     uint32_t start;
    *     uint32_t start_instance;
    *  };
    */
   struct pipe_resource *indirect;
   unsigned indirect_offset; /**< must be 4 byte aligned */
d595 2
a596 2
   boolean render_condition_enable; /**< whether the blit should honor the
                                    current render condition */
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d208 1
d364 1
d574 22
d619 2
a620 2
   boolean render_condition_enable; /**< whether to leave current render
                                    condition enabled */
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d102 1
d134 2
d594 3
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d57 1
a57 1
#define PIPE_MAX_CLIP_PLANES       6
a60 2
#define PIPE_MAX_VERTEX_SAMPLERS  16
#define PIPE_MAX_GEOMETRY_SAMPLERS  16
d62 2
a63 1
#define PIPE_MAX_SHADER_OUTPUTS   32
d67 4
d114 3
d118 24
a141 9
    * When true, triangle rasterization uses (0.5, 0.5) pixel centers
    * for determining pixel ownership.
    *
    * When false, triangle rasterization uses (0,0) pixel centers for
    * determining pixel ownership.
    *
    * Triangle rasterization always uses a 'top,left' rule for pixel
    * ownership, this just alters which point we consider the pixel
    * center for that test.
d143 1
a143 1
   unsigned gl_rasterization_rules:1;
d148 1
a148 1
   unsigned sprite_coord_enable:PIPE_MAX_SHADER_OUTPUTS;
d154 1
d183 23
a205 2
   unsigned nr;
   unsigned depth_clamp:1;
d212 1
d319 1
a319 1
   float border_color[4];
d331 1
a331 1
   struct pipe_context *context; /**< context this view belongs to */
d338 1
a338 1
   unsigned usage;               /**< bitmask of PIPE_BIND_x */
d387 6
a392 6
   unsigned x;
   unsigned y;
   unsigned z;
   unsigned width;
   unsigned height;
   unsigned depth;
a420 18
 * Stream output for vertex transform feedback.
 */
struct pipe_stream_output_state
{
   /** number of the output buffer to insert each element into */
   int output_buffer[PIPE_MAX_SHADER_OUTPUTS];
   /** which register to grab each output from */
   int register_index[PIPE_MAX_SHADER_OUTPUTS];
   /** TGSI_WRITEMASK signifying which components to output */
   ubyte register_mask[PIPE_MAX_SHADER_OUTPUTS];
   /** number of outputs */
   int num_outputs;
   /** stride for an entire vertex, only used if all output_buffers are 0 */
   unsigned stride;
};


/**
a430 1
   void *data;
d445 44
d523 1
d553 16
d571 38
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d65 1
d84 2
a96 1
   unsigned sprite_coord_enable:PIPE_MAX_SHADER_OUTPUTS;
a102 2
   unsigned line_stipple_factor:8;  /**< [1..256] actually */
   unsigned line_stipple_pattern:16;
d105 1
a105 1
   /** 
d109 1
a109 1
   unsigned flatshade_first:1;   
d111 1
a111 1
   /** 
d124 5
d272 1
d375 4
d381 1
a381 1
   /**< number of the output buffer to insert each element into */
d383 1
a383 1
   /**< which register to grab each output from */
d385 1
a385 1
   /**< TGSI_WRITEMASK signifying which components to output */
d387 1
a387 1
   /**< number of outputs */
d389 1
a389 3

   /**< stride for an entire vertex, only used if all output_buffers
    * are 0 */
d400 1
a400 1
   unsigned level;
d402 3
a404 3
   struct pipe_box box;
   unsigned stride;
   unsigned layer_stride;
a417 1
   unsigned max_index;   /**< number of vertices in this buffer */
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a45 1
#include "p_screen.h"
d62 3
a64 2
#define PIPE_MAX_SHADER_INPUTS    16
#define PIPE_MAX_SHADER_OUTPUTS   16
d66 1
a74 13
/**
 * The driver will certainly subclass this to include actual memory
 * management information.
 */
struct pipe_buffer
{
   struct pipe_reference  reference;
   unsigned               size;
   struct pipe_screen    *screen;
   unsigned               alignment;
   unsigned               usage;
};

d83 7
a89 6
   unsigned front_winding:2;  /**< PIPE_WINDING_x */
   unsigned cull_mode:2;      /**< PIPE_WINDING_x */
   unsigned fill_cw:2;        /**< PIPE_POLYGON_MODE_x */
   unsigned fill_ccw:2;       /**< PIPE_POLYGON_MODE_x */
   unsigned offset_cw:1;
   unsigned offset_ccw:1;
d157 1
d224 2
d244 1
a244 1
   /** multiple colorbuffers for multiple render targets */
d274 2
a275 2
 * 2D surface.  This is basically a view into a memory buffer.
 * May be a renderbuffer, texture mipmap level, etc.
d280 5
a284 1
   enum pipe_format format;      /**< PIPE_FORMAT_x */
d287 14
a300 8
   unsigned layout;              /**< PIPE_SURFACE_LAYOUT_x */
   unsigned offset;              /**< offset from start of buffer, in bytes */
   unsigned usage;               /**< PIPE_BUFFER_USAGE_*  */

   unsigned zslice;
   struct pipe_texture *texture; /**< texture into which this is a view  */
   unsigned face;
   unsigned level;
d305 1
a305 1
 * Transfer object.  For data transfer to/from a texture.
d307 1
a307 1
struct pipe_transfer
d309 22
a330 6
   unsigned x;                   /**< x offset from start of texture image */
   unsigned y;                   /**< y offset from start of texture image */
   unsigned width;               /**< logical width in pixels */
   unsigned height;              /**< logical height in pixels */
   unsigned stride;              /**< stride in bytes between rows of blocks */
   enum pipe_transfer_usage usage; /**< PIPE_TRANSFER_*  */
d332 11
a342 4
   struct pipe_texture *texture; /**< texture to transfer to/from  */
   unsigned face;
   unsigned level;
   unsigned zslice;
d347 1
a347 1
 * Texture object.
d349 2
a350 2
struct pipe_texture
{ 
d352 1
a352 1

d359 1
d362 6
d369 15
a383 1
   unsigned nr_samples:8;    /**< for multisampled surfaces, nr of samples */
a384 1
   unsigned tex_usage;       /* PIPE_TEXTURE_USAGE_* */
d386 12
a397 1
   struct pipe_screen *screen; /**< screen that this texture belongs to */
d401 1
d412 1
a412 1
   struct pipe_buffer *buffer;  /**< the actual buffer */
d432 1
a432 2
   unsigned vertex_buffer_index:8;
   unsigned nr_components:8;
d434 42
a475 1
   enum pipe_format src_format; 	   /**< PIPE_FORMAT_* */
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d46 1
d63 2
a64 3
#define PIPE_MAX_GEOMETRY_SAMPLERS  16
#define PIPE_MAX_SHADER_INPUTS    32
#define PIPE_MAX_SHADER_OUTPUTS   32
a65 1
#define PIPE_MAX_SO_BUFFERS        4
d74 13
d95 6
a100 7
   unsigned front_ccw:1;
   unsigned cull_face:2;      /**< PIPE_FACE_x */
   unsigned fill_front:2;     /**< PIPE_POLYGON_MODE_x */
   unsigned fill_back:2;      /**< PIPE_POLYGON_MODE_x */
   unsigned offset_point:1;
   unsigned offset_line:1;
   unsigned offset_tri:1;
a167 1
   unsigned depth_clamp:1;
a233 2
   unsigned alpha_to_coverage:1;
   unsigned alpha_to_one:1;
d252 1
a252 1
   /** multiple color buffers for multiple render targets */
d282 2
a283 2
 * A view into a texture that can be bound to a color render target /
 * depth stencil attachment point.
d288 1
a288 5
   struct pipe_resource *texture; /**< resource into which this is a view  */
   struct pipe_context *context; /**< context this view belongs to */
   enum pipe_format format;

   /* XXX width/height should be removed */
d291 8
a298 14

   unsigned usage;               /**< bitmask of PIPE_BIND_x */

   union {
      struct {
         unsigned level;
         unsigned first_layer:16;
         unsigned last_layer:16;
      } tex;
      struct {
         unsigned first_element;
         unsigned last_element;
      } buf;
   } u;
d303 1
a303 1
 * A view into a texture that can be bound to a shader stage.
d305 1
a305 1
struct pipe_sampler_view
d307 6
a312 21
   struct pipe_reference reference;
   enum pipe_format format;      /**< typed PIPE_FORMAT_x */
   struct pipe_resource *texture; /**< texture into which this is a view  */
   struct pipe_context *context; /**< context this view belongs to */
   union {
      struct {
         unsigned first_layer:16;     /**< first layer to use for array textures */
         unsigned last_layer:16;      /**< last layer to use for array textures */
         unsigned first_level:8;      /**< first mipmap level to use */
         unsigned last_level:8;       /**< last mipmap level to use */
      } tex;
      struct {
         unsigned first_element;
         unsigned last_element;
      } buf;
   } u;
   unsigned swizzle_r:3;         /**< PIPE_SWIZZLE_x for red component */
   unsigned swizzle_g:3;         /**< PIPE_SWIZZLE_x for green component */
   unsigned swizzle_b:3;         /**< PIPE_SWIZZLE_x for blue component */
   unsigned swizzle_a:3;         /**< PIPE_SWIZZLE_x for alpha component */
};
d314 4
a317 12

/**
 * Subregion of 1D/2D/3D image resource.
 */
struct pipe_box
{
   unsigned x;
   unsigned y;
   unsigned z;
   unsigned width;
   unsigned height;
   unsigned depth;
d322 1
a322 1
 * A memory object/resource such as a vertex buffer or texture.
d324 2
a325 2
struct pipe_resource
{
d327 1
a327 1
   struct pipe_screen *screen; /**< screen that this texture belongs to */
a333 1
   unsigned array_size;
d336 1
a337 1
   unsigned usage:8;         /**< PIPE_USAGE_x (not a bitmask) */
d339 1
a339 3
   unsigned bind;            /**< bitmask of PIPE_BIND_x */
   unsigned flags;           /**< bitmask of PIPE_RESOURCE_FLAG_x */
};
d341 1
a341 14
struct pipe_stream_output_state
{
   /**< number of the output buffer to insert each element into */
   int output_buffer[PIPE_MAX_SHADER_OUTPUTS];
   /**< which register to grab each output from */
   int register_index[PIPE_MAX_SHADER_OUTPUTS];
   /**< TGSI_WRITEMASK signifying which components to output */
   ubyte register_mask[PIPE_MAX_SHADER_OUTPUTS];
   /**< number of outputs */
   int num_outputs;

   /**< stride for an entire vertex, only used if all output_buffers
    * are 0 */
   unsigned stride;
a345 16
 * Transfer object.  For data transfer to/from a resource.
 */
struct pipe_transfer
{
   struct pipe_resource *resource; /**< resource to transfer to/from  */
   unsigned level;
   enum pipe_transfer_usage usage;
   struct pipe_box box;
   unsigned stride;
   unsigned layer_stride;
   void *data;
};



/**
d355 1
a355 1
   struct pipe_resource *buffer;  /**< the actual buffer */
d375 2
a376 1
   unsigned vertex_buffer_index;
d378 1
a378 42
   enum pipe_format src_format;
};


/**
 * An index buffer.  When an index buffer is bound, all indices to vertices
 * will be looked up in the buffer.
 */
struct pipe_index_buffer
{
   unsigned index_size;  /**< size of an index, in bytes */
   unsigned offset;  /**< offset to start of data in buffer, in bytes */
   struct pipe_resource *buffer; /**< the actual buffer */
};


/**
 * Information to describe a draw_vbo call.
 */
struct pipe_draw_info
{
   boolean indexed;  /**< use index buffer */

   unsigned mode;  /**< the mode of the primitive */
   unsigned start;  /**< the index of the first vertex */
   unsigned count;  /**< number of vertices */

   unsigned start_instance; /**< first instance id */
   unsigned instance_count; /**< number of instances */

   /**
    * For indexed drawing, these fields apply after index lookup.
    */
   int index_bias; /**< a bias to be added to each index */
   unsigned min_index; /**< the min index */
   unsigned max_index; /**< the max index */

   /**
    * Primitive restart enable/index (only applies to indexed drawing)
    */
   boolean primitive_restart;
   unsigned restart_index;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d57 1
a57 1
#define PIPE_MAX_CLIP_PLANES       8
d61 2
d64 1
a64 3
#define PIPE_MAX_SHADER_OUTPUTS   48 /* 32 GENERICs + POS, PSIZE, FOG, etc. */
#define PIPE_MAX_SHADER_SAMPLER_VIEWS 32
#define PIPE_MAX_SHADER_RESOURCES 32
a66 4
#define PIPE_MAX_SO_OUTPUTS       64
#define PIPE_MAX_VIEWPORTS        16
#define PIPE_MAX_CLIP_OR_CULL_DISTANCE_COUNT 8
#define PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT 2
a82 2
   unsigned clamp_vertex_color:1;
   unsigned clamp_fragment_color:1;
d94 1
d101 2
d105 1
a105 1
   /**
d109 1
a109 1
   unsigned flatshade_first:1;
d111 10
a120 13
   unsigned half_pixel_center:1;
   unsigned bottom_edge_rule:1;

   /**
    * When true, rasterization is disabled and no pixels are written.
    * This only makes sense with the Stream Out functionality.
    */
   unsigned rasterizer_discard:1;

   /**
    * When false, depth clipping is disabled and the depth value will be
    * clamped later at the per-pixel level before depth testing.
    * This depends on PIPE_CAP_DEPTH_CLIP_DISABLE.
d122 1
a122 21
   unsigned depth_clip:1;

   /**
    * When true clip space in the z axis goes from [0..1] (D3D).  When false
    * [-1, 1] (GL).
    */
   unsigned clip_halfz:1;

   /**
    * Enable bits for clipping half-spaces.
    * This applies to both user clip planes and shader clip distances.
    * Note that if the bound shader exports any clip distances, these
    * replace all user clip planes, and clip half-spaces enabled here
    * but not written by the shader count as disabled.
    */
   unsigned clip_plane_enable:PIPE_MAX_CLIP_PLANES;

   unsigned line_stipple_factor:8;  /**< [1..256] actually */
   unsigned line_stipple_pattern:16;

   uint32_t sprite_coord_enable; /* referring to 32 TEXCOORD/GENERIC inputs */
a127 1
   float offset_clamp;
d156 2
a157 23
};


/**
 * Stream output for vertex transform feedback.
 */
struct pipe_stream_output_info
{
   unsigned num_outputs;
   /** stride for an entire vertex for each buffer in dwords */
   unsigned stride[PIPE_MAX_SO_BUFFERS];

   /**
    * Array of stream outputs, in the order they are to be written in.
    * Selected components are tightly packed into the output buffer.
    */
   struct {
      unsigned register_index:8;  /**< 0 to PIPE_MAX_SHADER_OUTPUTS */
      unsigned start_component:2; /** 0 to 3 */
      unsigned num_components:3;  /** 1 to 4 */
      unsigned output_buffer:3;   /**< 0 to PIPE_MAX_SO_BUFFERS */
      unsigned dst_offset:16;     /**< offset into the buffer in dwords */
   } output[PIPE_MAX_SO_OUTPUTS];
a163 1
   struct pipe_stream_output_info stream_output;
a266 1
   unsigned seamless_cube_map:1;
d269 1
a269 1
   union pipe_color_union border_color;
d281 1
a281 1
   struct pipe_context *context; /**< context this surface belongs to */
d288 1
a288 1
   unsigned writable:1;          /**< writable shader resource */
d337 6
a342 6
   int x;
   int y;
   int z;
   int width;
   int height;
   int depth;
d369 16
d392 1
a392 1
   unsigned level;                 /**< texture mipmap level */
d394 4
a397 3
   struct pipe_box box;            /**< region of the resource to access */
   unsigned stride;                /**< row stride in bytes */
   unsigned layer_stride;          /**< image/layer stride in bytes */
d410 1
a412 44
   const void *user_buffer;  /**< pointer to a user buffer if buffer == NULL */
};


/**
 * A constant buffer.  A subrange of an existing buffer can be set
 * as a constant buffer.
 */
struct pipe_constant_buffer {
   struct pipe_resource *buffer; /**< the actual buffer */
   unsigned buffer_offset; /**< offset to start of data in buffer, in bytes */
   unsigned buffer_size;   /**< how much data can be read in shader */
   const void *user_buffer;  /**< pointer to a user buffer if buffer == NULL */
};


/**
 * A stream output target. The structure specifies the range vertices can
 * be written to.
 *
 * In addition to that, the structure should internally maintain the offset
 * into the buffer, which should be incremented everytime something is written
 * (appended) to it. The internal offset is buffer_offset + how many bytes
 * have been written. The internal offset can be stored on the device
 * and the CPU actually doesn't have to query it.
 *
 * Note that the buffer_size variable is actually specifying the available
 * space in the buffer, not the size of the attached buffer. 
 * In other words in majority of cases buffer_size would simply be 
 * 'buffer->width0 - buffer_offset', so buffer_size refers to the size
 * of the buffer left, after accounting for buffer offset, for stream output
 * to write to.
 *
 * Use PIPE_QUERY_SO_STATISTICS to know how many primitives have
 * actually been written.
 */
struct pipe_stream_output_target
{
   struct pipe_reference reference;
   struct pipe_resource *buffer; /**< the output buffer */
   struct pipe_context *context; /**< context this SO target belongs to */

   unsigned buffer_offset;  /**< offset where data should be written, in bytes */
   unsigned buffer_size;    /**< how much data is allowed to be written */
a446 1
   const void *user_buffer;  /**< pointer to a user buffer if buffer == NULL */
a475 38

   /**
    * Stream output target. If not NULL, it's used to provide the 'count'
    * parameter based on the number vertices captured by the stream output
    * stage. (or generally, based on the number of bytes captured)
    *
    * Only 'mode', 'start_instance', and 'instance_count' are taken into
    * account, all the other variables from pipe_draw_info are ignored.
    *
    * 'start' is implicitly 0 and 'count' is set as discussed above.
    * The draw command is non-indexed.
    *
    * Note that this only provides the count. The vertex buffers must
    * be set via set_vertex_buffers manually.
    */
   struct pipe_stream_output_target *count_from_stream_output;
};


/**
 * Information to describe a blit call.
 */
struct pipe_blit_info
{
   struct {
      struct pipe_resource *resource;
      unsigned level;
      struct pipe_box box; /**< negative width, height only legal for src */
      /* For pipe_surface-like format casting: */
      enum pipe_format format; /**< must be supported for sampling (src)
                               or rendering (dst), ZS is always supported */
   } dst, src;

   unsigned mask; /**< bitmask of PIPE_MASK_R/G/B/A/Z/S */
   unsigned filter; /**< PIPE_TEX_FILTER_* */

   boolean scissor_enable;
   struct pipe_scissor_state scissor;
a477 16

/**
 * Structure used as a header for serialized LLVM programs.
 */
struct pipe_llvm_program_header
{
   uint32_t num_bytes; /**< Number of bytes in the LLVM bytecode program. */
};

struct pipe_compute_state
{
   const void *prog; /**< Compute program to be executed. */
   unsigned req_local_mem; /**< Required size of the LOCAL resource. */
   unsigned req_private_mem; /**< Required size of the PRIVATE resource. */
   unsigned req_input_mem; /**< Required size of the INPUT resource. */
};
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a101 1
   unsigned point_tri_clip:1; /** large points clipped as tris or points */
a132 2
    *
    * NOTE: D3D will always use depth clamping.
a590 3

   boolean render_condition_enable; /**< whether to leave current render
                                    condition enabled */
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a207 1
      unsigned stream:2;          /**< 0 to 3 */
a362 1
   enum pipe_texture_target target; /**< PIPE_TEXTURE_x */
a571 22

   /* Indirect parameters resource: If not NULL, most values are taken
    * from this buffer instead, which is laid out as follows:
    *
    * if indexed is TRUE:
    *  struct {
    *     uint32_t count;
    *     uint32_t instance_count;
    *     uint32_t start;
    *     int32_t index_bias;
    *     uint32_t start_instance;
    *  };
    * otherwise:
    *  struct {
    *     uint32_t count;
    *     uint32_t instance_count;
    *     uint32_t start;
    *     uint32_t start_instance;
    *  };
    */
   struct pipe_resource *indirect;
   unsigned indirect_offset; /**< must be 4 byte aligned */
d595 2
a596 2
   boolean render_condition_enable; /**< whether the blit should honor the
                                    current render condition */
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d208 1
d364 1
d574 22
d619 2
a620 2
   boolean render_condition_enable; /**< whether to leave current render
                                    condition enabled */
@


