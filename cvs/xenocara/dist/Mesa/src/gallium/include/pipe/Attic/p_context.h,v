head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.14;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.00;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.25;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.02;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.09;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#ifndef PIPE_CONTEXT_H
#define PIPE_CONTEXT_H

#include "p_compiler.h"
#include "p_format.h"
#include "p_video_enums.h"
#include "p_defines.h"

#ifdef __cplusplus
extern "C" {
#endif


struct pipe_blend_color;
struct pipe_blend_state;
struct pipe_blit_info;
struct pipe_box;
struct pipe_clip_state;
struct pipe_constant_buffer;
struct pipe_depth_stencil_alpha_state;
struct pipe_draw_info;
struct pipe_fence_handle;
struct pipe_framebuffer_state;
struct pipe_index_buffer;
struct pipe_query;
struct pipe_poly_stipple;
struct pipe_rasterizer_state;
struct pipe_resolve_info;
struct pipe_resource;
struct pipe_sampler_state;
struct pipe_sampler_view;
struct pipe_scissor_state;
struct pipe_shader_state;
struct pipe_stencil_ref;
struct pipe_stream_output_target;
struct pipe_surface;
struct pipe_transfer;
struct pipe_vertex_buffer;
struct pipe_vertex_element;
struct pipe_video_buffer;
struct pipe_video_codec;
struct pipe_viewport_state;
struct pipe_compute_state;
union pipe_color_union;
union pipe_query_result;

/**
 * Gallium rendering context.  Basically:
 *  - state setting functions
 *  - VBO drawing functions
 *  - surface functions
 */
struct pipe_context {
   struct pipe_screen *screen;

   void *priv;  /**< context private data (for DRI for example) */
   void *draw;  /**< private, for draw module (temporary?) */

   void (*destroy)( struct pipe_context * );

   /**
    * VBO drawing
    */
   /*@@{*/
   void (*draw_vbo)( struct pipe_context *pipe,
                     const struct pipe_draw_info *info );
   /*@@}*/

   /**
    * Predicate subsequent rendering on occlusion query result
    * \param query  the query predicate, or NULL if no predicate
    * \param condition whether to skip on FALSE or TRUE query results
    * \param mode  one of PIPE_RENDER_COND_x
    */
   void (*render_condition)( struct pipe_context *pipe,
                             struct pipe_query *query,
                             boolean condition,
                             uint mode );

   /**
    * Query objects
    */
   /*@@{*/
   struct pipe_query *(*create_query)( struct pipe_context *pipe,
                                       unsigned query_type );

   void (*destroy_query)(struct pipe_context *pipe,
                         struct pipe_query *q);

   void (*begin_query)(struct pipe_context *pipe, struct pipe_query *q);
   void (*end_query)(struct pipe_context *pipe, struct pipe_query *q);

   /**
    * Get results of a query.
    * \param wait  if true, this query will block until the result is ready
    * \return TRUE if results are ready, FALSE otherwise
    */
   boolean (*get_query_result)(struct pipe_context *pipe,
                               struct pipe_query *q,
                               boolean wait,
                               union pipe_query_result *result);
   /*@@}*/

   /**
    * State functions (create/bind/destroy state objects)
    */
   /*@@{*/
   void * (*create_blend_state)(struct pipe_context *,
                                const struct pipe_blend_state *);
   void   (*bind_blend_state)(struct pipe_context *, void *);
   void   (*delete_blend_state)(struct pipe_context *, void  *);

   void * (*create_sampler_state)(struct pipe_context *,
                                  const struct pipe_sampler_state *);
   void   (*bind_sampler_states)(struct pipe_context *,
                                 unsigned shader, unsigned start_slot,
                                 unsigned num_samplers, void **samplers);
   void   (*delete_sampler_state)(struct pipe_context *, void *);

   void * (*create_rasterizer_state)(struct pipe_context *,
                                     const struct pipe_rasterizer_state *);
   void   (*bind_rasterizer_state)(struct pipe_context *, void *);
   void   (*delete_rasterizer_state)(struct pipe_context *, void *);

   void * (*create_depth_stencil_alpha_state)(struct pipe_context *,
                                        const struct pipe_depth_stencil_alpha_state *);
   void   (*bind_depth_stencil_alpha_state)(struct pipe_context *, void *);
   void   (*delete_depth_stencil_alpha_state)(struct pipe_context *, void *);

   void * (*create_fs_state)(struct pipe_context *,
                             const struct pipe_shader_state *);
   void   (*bind_fs_state)(struct pipe_context *, void *);
   void   (*delete_fs_state)(struct pipe_context *, void *);

   void * (*create_vs_state)(struct pipe_context *,
                             const struct pipe_shader_state *);
   void   (*bind_vs_state)(struct pipe_context *, void *);
   void   (*delete_vs_state)(struct pipe_context *, void *);

   void * (*create_gs_state)(struct pipe_context *,
                             const struct pipe_shader_state *);
   void   (*bind_gs_state)(struct pipe_context *, void *);
   void   (*delete_gs_state)(struct pipe_context *, void *);

   void * (*create_vertex_elements_state)(struct pipe_context *,
                                          unsigned num_elements,
                                          const struct pipe_vertex_element *);
   void   (*bind_vertex_elements_state)(struct pipe_context *, void *);
   void   (*delete_vertex_elements_state)(struct pipe_context *, void *);

   /*@@}*/

   /**
    * Parameter-like state (or properties)
    */
   /*@@{*/
   void (*set_blend_color)( struct pipe_context *,
                            const struct pipe_blend_color * );

   void (*set_stencil_ref)( struct pipe_context *,
                            const struct pipe_stencil_ref * );

   void (*set_sample_mask)( struct pipe_context *,
                            unsigned sample_mask );

   void (*set_min_samples)( struct pipe_context *,
                            unsigned min_samples );

   void (*set_clip_state)( struct pipe_context *,
                            const struct pipe_clip_state * );

   void (*set_constant_buffer)( struct pipe_context *,
                                uint shader, uint index,
                                struct pipe_constant_buffer *buf );

   void (*set_framebuffer_state)( struct pipe_context *,
                                  const struct pipe_framebuffer_state * );

   void (*set_polygon_stipple)( struct pipe_context *,
				const struct pipe_poly_stipple * );

   void (*set_scissor_states)( struct pipe_context *,
                               unsigned start_slot,
                               unsigned num_scissors,
                               const struct pipe_scissor_state * );

   void (*set_viewport_states)( struct pipe_context *,
                                unsigned start_slot,
                                unsigned num_viewports,
                                const struct pipe_viewport_state *);

   void (*set_sampler_views)(struct pipe_context *, unsigned shader,
                             unsigned start_slot, unsigned num_views,
                             struct pipe_sampler_view **);

   /**
    * Bind an array of shader resources that will be used by the
    * graphics pipeline.  Any resources that were previously bound to
    * the specified range will be unbound after this call.
    *
    * \param start      first resource to bind.
    * \param count      number of consecutive resources to bind.
    * \param resources  array of pointers to the resources to bind, it
    *                   should contain at least \a count elements
    *                   unless it's NULL, in which case no new
    *                   resources will be bound.
    */
   void (*set_shader_resources)(struct pipe_context *,
                                unsigned start, unsigned count,
                                struct pipe_surface **resources);

   void (*set_vertex_buffers)( struct pipe_context *,
                               unsigned start_slot,
                               unsigned num_buffers,
                               const struct pipe_vertex_buffer * );

   void (*set_index_buffer)( struct pipe_context *pipe,
                             const struct pipe_index_buffer * );

   /*@@}*/

   /**
    * Stream output functions.
    */
   /*@@{*/

   struct pipe_stream_output_target *(*create_stream_output_target)(
                        struct pipe_context *,
                        struct pipe_resource *,
                        unsigned buffer_offset,
                        unsigned buffer_size);

   void (*stream_output_target_destroy)(struct pipe_context *,
                                        struct pipe_stream_output_target *);

   void (*set_stream_output_targets)(struct pipe_context *,
                              unsigned num_targets,
                              struct pipe_stream_output_target **targets,
                              const unsigned *offsets);

   /*@@}*/


   /**
    * Resource functions for blit-like functionality
    *
    * If a driver supports multisampling, blit must implement color resolve.
    */
   /*@@{*/

   /**
    * Copy a block of pixels from one resource to another.
    * The resource must be of the same format.
    * Resources with nr_samples > 1 are not allowed.
    */
   void (*resource_copy_region)(struct pipe_context *pipe,
                                struct pipe_resource *dst,
                                unsigned dst_level,
                                unsigned dstx, unsigned dsty, unsigned dstz,
                                struct pipe_resource *src,
                                unsigned src_level,
                                const struct pipe_box *src_box);

   /* Optimal hardware path for blitting pixels.
    * Scaling, format conversion, up- and downsampling (resolve) are allowed.
    */
   void (*blit)(struct pipe_context *pipe,
                const struct pipe_blit_info *info);

   /*@@}*/

   /**
    * Clear the specified set of currently bound buffers to specified values.
    * The entire buffers are cleared (no scissor, no colormask, etc).
    *
    * \param buffers  bitfield of PIPE_CLEAR_* values.
    * \param color  pointer to a union of fiu array for each of r, g, b, a.
    * \param depth  depth clear value in [0,1].
    * \param stencil  stencil clear value
    */
   void (*clear)(struct pipe_context *pipe,
                 unsigned buffers,
                 const union pipe_color_union *color,
                 double depth,
                 unsigned stencil);

   /**
    * Clear a color rendertarget surface.
    * \param color  pointer to an union of fiu array for each of r, g, b, a.
    */
   void (*clear_render_target)(struct pipe_context *pipe,
                               struct pipe_surface *dst,
                               const union pipe_color_union *color,
                               unsigned dstx, unsigned dsty,
                               unsigned width, unsigned height);

   /**
    * Clear a depth-stencil surface.
    * \param clear_flags  bitfield of PIPE_CLEAR_DEPTH/STENCIL values.
    * \param depth  depth clear value in [0,1].
    * \param stencil  stencil clear value
    */
   void (*clear_depth_stencil)(struct pipe_context *pipe,
                               struct pipe_surface *dst,
                               unsigned clear_flags,
                               double depth,
                               unsigned stencil,
                               unsigned dstx, unsigned dsty,
                               unsigned width, unsigned height);

   /**
    * Clear a buffer. Runs a memset over the specified region with the element
    * value passed in through clear_value of size clear_value_size.
    */
   void (*clear_buffer)(struct pipe_context *pipe,
                        struct pipe_resource *res,
                        unsigned offset,
                        unsigned size,
                        const void *clear_value,
                        int clear_value_size);

   /** Flush draw commands
    *
    * \param flags  bitfield of enum pipe_flush_flags values.
    */
   void (*flush)(struct pipe_context *pipe,
                 struct pipe_fence_handle **fence,
                 unsigned flags);

   /**
    * Create a view on a texture to be used by a shader stage.
    */
   struct pipe_sampler_view * (*create_sampler_view)(struct pipe_context *ctx,
                                                     struct pipe_resource *texture,
                                                     const struct pipe_sampler_view *templat);

   void (*sampler_view_destroy)(struct pipe_context *ctx,
                                struct pipe_sampler_view *view);


   /**
    * Get a surface which is a "view" into a resource, used by
    * render target / depth stencil stages.
    */
   struct pipe_surface *(*create_surface)(struct pipe_context *ctx,
                                          struct pipe_resource *resource,
                                          const struct pipe_surface *templat);

   void (*surface_destroy)(struct pipe_context *ctx,
                           struct pipe_surface *);

   /**
    * Map a resource.
    *
    * Transfers are (by default) context-private and allow uploads to be
    * interleaved with rendering.
    *
    * out_transfer will contain the transfer object that must be passed
    * to all the other transfer functions. It also contains useful
    * information (like texture strides).
    */
   void *(*transfer_map)(struct pipe_context *,
                         struct pipe_resource *resource,
                         unsigned level,
                         unsigned usage,  /* a combination of PIPE_TRANSFER_x */
                         const struct pipe_box *,
                         struct pipe_transfer **out_transfer);

   /* If transfer was created with WRITE|FLUSH_EXPLICIT, only the
    * regions specified with this call are guaranteed to be written to
    * the resource.
    */
   void (*transfer_flush_region)( struct pipe_context *,
				  struct pipe_transfer *transfer,
				  const struct pipe_box *);

   void (*transfer_unmap)(struct pipe_context *,
                          struct pipe_transfer *transfer);

   /* One-shot transfer operation with data supplied in a user
    * pointer.  XXX: strides??
    */
   void (*transfer_inline_write)( struct pipe_context *,
                                  struct pipe_resource *,
                                  unsigned level,
                                  unsigned usage, /* a combination of PIPE_TRANSFER_x */
                                  const struct pipe_box *,
                                  const void *data,
                                  unsigned stride,
                                  unsigned layer_stride);

   /**
    * Flush any pending framebuffer writes and invalidate texture caches.
    */
   void (*texture_barrier)(struct pipe_context *);

   /**
    * Flush caches according to flags.
    */
   void (*memory_barrier)(struct pipe_context *, unsigned flags);

   /**
    * Creates a video codec for a specific video format/profile
    */
   struct pipe_video_codec *(*create_video_codec)( struct pipe_context *context,
                                                   const struct pipe_video_codec *templat );

   /**
    * Creates a video buffer as decoding target
    */
   struct pipe_video_buffer *(*create_video_buffer)( struct pipe_context *context,
                                                     const struct pipe_video_buffer *templat );

   /**
    * Compute kernel execution
    */
   /*@@{*/
   /**
    * Define the compute program and parameters to be used by
    * pipe_context::launch_grid.
    */
   void *(*create_compute_state)(struct pipe_context *context,
				 const struct pipe_compute_state *);
   void (*bind_compute_state)(struct pipe_context *, void *);
   void (*delete_compute_state)(struct pipe_context *, void *);

   /**
    * Bind an array of shader resources that will be used by the
    * compute program.  Any resources that were previously bound to
    * the specified range will be unbound after this call.
    *
    * \param start      first resource to bind.
    * \param count      number of consecutive resources to bind.
    * \param resources  array of pointers to the resources to bind, it
    *                   should contain at least \a count elements
    *                   unless it's NULL, in which case no new
    *                   resources will be bound.
    */
   void (*set_compute_resources)(struct pipe_context *,
                                 unsigned start, unsigned count,
                                 struct pipe_surface **resources);

   /**
    * Bind an array of buffers to be mapped into the address space of
    * the GLOBAL resource.  Any buffers that were previously bound
    * between [first, first + count - 1] are unbound after this call.
    *
    * \param first      first buffer to map.
    * \param count      number of consecutive buffers to map.
    * \param resources  array of pointers to the buffers to map, it
    *                   should contain at least \a count elements
    *                   unless it's NULL, in which case no new
    *                   resources will be bound.
    * \param handles    array of pointers to the memory locations that
    *                   will be updated with the address each buffer
    *                   will be mapped to.  The base memory address of
    *                   each of the buffers will be added to the value
    *                   pointed to by its corresponding handle to form
    *                   the final address argument.  It should contain
    *                   at least \a count elements, unless \a
    *                   resources is NULL in which case \a handles
    *                   should be NULL as well.
    *
    * Note that the driver isn't required to make any guarantees about
    * the contents of the \a handles array being valid anytime except
    * during the subsequent calls to pipe_context::launch_grid.  This
    * means that the only sensible location handles[i] may point to is
    * somewhere within the INPUT buffer itself.  This is so to
    * accommodate implementations that lack virtual memory but
    * nevertheless migrate buffers on the fly, leading to resource
    * base addresses that change on each kernel invocation or are
    * unknown to the pipe driver.
    */
   void (*set_global_binding)(struct pipe_context *context,
                              unsigned first, unsigned count,
                              struct pipe_resource **resources,
                              uint32_t **handles);

   /**
    * Launch the compute kernel starting from instruction \a pc of the
    * currently bound compute program.
    *
    * \a grid_layout and \a block_layout are arrays of size \a
    * PIPE_COMPUTE_CAP_GRID_DIMENSION that determine the layout of the
    * grid (in block units) and working block (in thread units) to be
    * used, respectively.
    *
    * \a pc For drivers that use PIPE_SHADER_IR_LLVM as their prefered IR,
    * this value will be the index of the kernel in the opencl.kernels
    * metadata list.
    *
    * \a input will be used to initialize the INPUT resource, and it
    * should point to a buffer of at least
    * pipe_compute_state::req_input_mem bytes.
    */
   void (*launch_grid)(struct pipe_context *context,
                       const uint *block_layout, const uint *grid_layout,
                       uint32_t pc, const void *input);
   /*@@}*/

   /**
    * Get sample position for an individual sample point.
    *
    * \param sample_count - total number of samples
    * \param sample_index - sample to get the position values for
    * \param out_value - return value of 2 floats for x and y position for
    *                    requested sample.
    */
   void (*get_sample_position)(struct pipe_context *context,
                               unsigned sample_count,
                               unsigned sample_index,
                               float *out_value);

   /**
    * Flush the resource cache, so that the resource can be used
    * by an external client. Possible usage:
    * - flushing a resource before presenting it on the screen
    * - flushing a resource if some other process or device wants to use it
    * This shouldn't be used to flush caches if the resource is only managed
    * by a single pipe_screen and is not shared with another process.
    * (i.e. you shouldn't use it to flush caches explicitly if you want to e.g.
    * use the resource for texturing)
    */
   void (*flush_resource)(struct pipe_context *ctx,
                          struct pipe_resource *resource);
};


#ifdef __cplusplus
}
#endif

#endif /* PIPE_CONTEXT_H */
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d112 1
a112 2
                                       unsigned query_type,
                                       unsigned index );
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d112 2
a113 1
                                       unsigned query_type );
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d68 1
a68 1
struct pipe_video_decoder;
d142 3
a144 13
   void   (*bind_fragment_sampler_states)(struct pipe_context *,
                                          unsigned num_samplers,
                                          void **samplers);
   void   (*bind_vertex_sampler_states)(struct pipe_context *,
                                        unsigned num_samplers,
                                        void **samplers);
   void   (*bind_geometry_sampler_states)(struct pipe_context *,
                                          unsigned num_samplers,
                                          void **samplers);
   void   (*bind_compute_sampler_states)(struct pipe_context *,
                                         unsigned start_slot,
                                         unsigned num_samplers,
                                         void **samplers);
d193 3
d219 3
a221 15
   void (*set_fragment_sampler_views)(struct pipe_context *,
                                      unsigned num_views,
                                      struct pipe_sampler_view **);

   void (*set_vertex_sampler_views)(struct pipe_context *,
                                    unsigned num_views,
                                    struct pipe_sampler_view **);

   void (*set_geometry_sampler_views)(struct pipe_context *,
                                      unsigned num_views,
                                      struct pipe_sampler_view **);

   void (*set_compute_sampler_views)(struct pipe_context *,
                                     unsigned start_slot, unsigned num_views,
                                     struct pipe_sampler_view **);
d266 1
a266 1
                              unsigned append_bitmask);
d338 11
d423 1
a423 1
   
d425 1
a425 1
    * Creates a video decoder for a specific video codec/profile
d427 7
a433 6
   struct pipe_video_decoder *(*create_video_decoder)( struct pipe_context *context,
                                                       enum pipe_video_profile profile,
                                                       enum pipe_video_entrypoint entrypoint,
                                                       enum pipe_video_chroma_format chroma_format,
                                                       unsigned width, unsigned height, unsigned max_references,
                                                       bool expect_chunked_decode);
d482 8
a489 5
    *                   will be filled with the respective base
    *                   addresses each buffer will be mapped to.  It
    *                   should contain at least \a count elements,
    *                   unless \a resources is NULL in which case \a
    *                   handles should be NULL as well.
d540 13
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d32 3
d43 1
d46 1
d55 1
d62 1
a62 1
struct pipe_stream_output_state;
d64 1
d67 2
d70 3
a80 1
   struct pipe_winsys *winsys;
a93 5

   /**
    * Draw the stream output buffer at index 0
    */
   void (*draw_stream_output)( struct pipe_context *pipe, unsigned mode );
d99 1
d104 1
d128 1
a128 1
                               void *result);
d151 4
a187 5
   void * (*create_stream_output_state)(struct pipe_context *,
                                        const struct pipe_stream_output_state *);
   void   (*bind_stream_output_state)(struct pipe_context *, void *);
   void   (*delete_stream_output_state)(struct pipe_context*, void*);

d208 1
a208 1
                                struct pipe_resource *buf );
d216 9
a224 5
   void (*set_scissor_state)( struct pipe_context *,
                              const struct pipe_scissor_state * );

   void (*set_viewport_state)( struct pipe_context *,
                               const struct pipe_viewport_state * );
d238 20
d259 1
d266 20
a285 6
   void (*set_stream_output_buffers)(struct pipe_context *,
                                     struct pipe_resource **buffers,
                                     int *offsets, /*array of offsets
                                                     from the start of each
                                                     of the buffers */
                                     int num_buffers);
d293 1
a293 1
    * If a driver supports multisampling, resource_resolve must be available.
d310 2
a311 3
   /**
    * Resolve a multisampled resource into a non-multisampled one.
    * Source and destination must have the same size and same format.
d313 2
a314 5
   void (*resource_resolve)(struct pipe_context *pipe,
                            struct pipe_resource *dst,
                            unsigned dst_layer,
                            struct pipe_resource *src,
                            unsigned src_layer);
d323 1
a323 1
    * \param rgba  pointer to an array of one float for each of r, g, b, a.
d329 1
a329 1
                 const float *rgba,
d335 1
a335 1
    * \param rgba  pointer to an array of one float for each of r, g, b, a.
d339 1
a339 1
                               const float *rgba,
d358 2
d361 3
a363 2
   void (*flush)( struct pipe_context *pipe,
                  struct pipe_fence_handle **fence );
a378 1
    * \param usage  bitmaks of PIPE_BIND_* flags
d388 1
a388 1
    * Get a transfer object for transferring data to/from a texture.
d391 12
a402 13
    * interleaved with
    */
   struct pipe_transfer *(*get_transfer)(struct pipe_context *,
                                         struct pipe_resource *resource,
                                         unsigned level,
                                         unsigned usage,  /* a combination of PIPE_TRANSFER_x */
                                         const struct pipe_box *);

   void (*transfer_destroy)(struct pipe_context *,
                            struct pipe_transfer *);

   void *(*transfer_map)( struct pipe_context *,
                          struct pipe_transfer *transfer );
d412 2
a413 3
   void (*transfer_unmap)( struct pipe_context *,
                           struct pipe_transfer *transfer );

d427 14
d442 5
a446 7
   /* Notify a driver that a content of a user buffer has been changed.
    * The changed range is [offset, offset+size-1].
    * The new width0 of the buffer is offset+size. */
   void (*redefine_user_buffer)(struct pipe_context *,
                                struct pipe_resource *,
                                unsigned offset,
                                unsigned size);
d449 6
a454 1
    * Flush any pending framebuffer writes and invalidate texture caches.
d456 88
a543 1
   void (*texture_barrier)(struct pipe_context *);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d315 1
a315 2
   /** Flush rendering
    * \param flags  bitmask of PIPE_FLUSH_x tokens)
a317 1
                  unsigned flags,
a320 15
    * Check whether a texture is referenced by an unflushed hw command.
    * The state-tracker uses this function to avoid unnecessary flushes.
    * It is safe (but wasteful) to always return
    * PIPE_REFERENCED_FOR_READ | PIPE_REFERENCED_FOR_WRITE.
    * \param pipe  context whose unflushed hw commands will be checked.
    * \param texture  texture to check.
    * \param level  mipmap level.
    * \param layer  cubemap face, 2d array or 3d slice, 0 otherwise. Use -1 for any layer.
    * \return mask of PIPE_REFERENCED_FOR_READ/WRITE or PIPE_UNREFERENCED
    */
   unsigned int (*is_resource_referenced)(struct pipe_context *pipe,
                                          struct pipe_resource *texture,
                                          unsigned level, int layer);

   /**
d385 13
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a31 2
#include "p_state.h"

d37 7
a43 2
   
struct pipe_screen;
d45 2
a46 1
struct pipe_state_cache;
d48 13
a60 1
struct pipe_winsys;
d78 1
a78 1
    * VBO drawing (return false on fallbacks (temporary??))
d81 2
a82 2
   void (*draw_arrays)( struct pipe_context *pipe,
                        unsigned mode, unsigned start, unsigned count);
d84 4
a87 34
   void (*draw_elements)( struct pipe_context *pipe,
                          struct pipe_buffer *indexBuffer,
                          unsigned indexSize,
                          unsigned mode, unsigned start, unsigned count);

   void (*draw_arrays_instanced)(struct pipe_context *pipe,
                                 unsigned mode,
                                 unsigned start,
                                 unsigned count,
                                 unsigned startInstance,
                                 unsigned instanceCount);

   void (*draw_elements_instanced)(struct pipe_context *pipe,
                                   struct pipe_buffer *indexBuffer,
                                   unsigned indexSize,
                                   unsigned mode,
                                   unsigned start,
                                   unsigned count,
                                   unsigned startInstance,
                                   unsigned instanceCount);

   /* XXX: this is (probably) a temporary entrypoint, as the range
    * information should be available from the vertex_buffer state.
    * Using this to quickly evaluate a specialized path in the draw
    * module.
    */
   void (*draw_range_elements)( struct pipe_context *pipe,
                                struct pipe_buffer *indexBuffer,
                                unsigned indexSize,
                                unsigned minIndex,
                                unsigned maxIndex,
                                unsigned mode, 
                                unsigned start, 
                                unsigned count);
d117 1
a117 1
   boolean (*get_query_result)(struct pipe_context *pipe, 
d120 1
a120 1
                               uint64_t *result);
d140 3
d170 11
d193 3
d201 1
a201 1
                                struct pipe_buffer *buf );
d215 11
a225 7
   void (*set_fragment_sampler_textures)(struct pipe_context *,
                                         unsigned num_textures,
                                         struct pipe_texture **);

   void (*set_vertex_sampler_textures)(struct pipe_context *,
                                       unsigned num_textures,
                                       struct pipe_texture **);
d231 10
a240 3
   void (*set_vertex_elements)( struct pipe_context *,
                                unsigned num_elements,
                                const struct pipe_vertex_element * );
d245 1
a245 1
    * Surface functions
d247 1
a247 2
    * The pipe driver is allowed to set these functions to NULL, and in that
    * case, they will not be available.
d252 22
a273 18
    * Copy a block of pixels from one surface to another.
    * The surfaces must be of the same format.
    */
   void (*surface_copy)(struct pipe_context *pipe,
			struct pipe_surface *dest,
			unsigned destx, unsigned desty,
			struct pipe_surface *src,
			unsigned srcx, unsigned srcy,
			unsigned width, unsigned height);

   /**
    * Fill a region of a surface with a constant value.
    */
   void (*surface_fill)(struct pipe_context *pipe,
			struct pipe_surface *dst,
			unsigned dstx, unsigned dsty,
			unsigned width, unsigned height,
			unsigned value);
d287 1
a287 1
		 const float *rgba,
d289 25
a313 1
		 unsigned stencil);
a328 1
    * \param face  cubemap face. Use 0 for non-cubemap texture.
d330 1
d333 26
a358 3
   unsigned int (*is_texture_referenced)(struct pipe_context *pipe,
					 struct pipe_texture *texture,
					 unsigned face, unsigned level);
d361 4
a364 7
    * Check whether a buffer is referenced by an unflushed hw command.
    * The state-tracker uses this function to avoid unnecessary flushes.
    * It is safe (but wasteful) to always return
    * PIPE_REFERENCED_FOR_READ | PIPE_REFERENCED_FOR_WRITE.
    * \param pipe  context whose unflushed hw commands will be checked.
    * \param buf  buffer to check.
    * \return mask of PIPE_REFERENCED_FOR_READ/WRITE or PIPE_UNREFERENCED
d366 36
a401 2
   unsigned int (*is_buffer_referenced)(struct pipe_context *pipe,
					struct pipe_buffer *buf);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d31 2
a32 1
#include "p_compiler.h"
d38 2
a39 7

struct pipe_blend_color;
struct pipe_blend_state;
struct pipe_box;
struct pipe_clip_state;
struct pipe_depth_stencil_alpha_state;
struct pipe_draw_info;
d41 1
a41 2
struct pipe_framebuffer_state;
struct pipe_index_buffer;
d43 1
a43 13
struct pipe_poly_stipple;
struct pipe_rasterizer_state;
struct pipe_resource;
struct pipe_sampler_state;
struct pipe_sampler_view;
struct pipe_scissor_state;
struct pipe_shader_state;
struct pipe_stencil_ref;
struct pipe_stream_output_state;
struct pipe_surface;
struct pipe_vertex_buffer;
struct pipe_vertex_element;
struct pipe_viewport_state;
d61 1
a61 1
    * VBO drawing
d64 2
a65 2
   void (*draw_vbo)( struct pipe_context *pipe,
                     const struct pipe_draw_info *info );
d67 34
a100 4
   /**
    * Draw the stream output buffer at index 0
    */
   void (*draw_stream_output)( struct pipe_context *pipe, unsigned mode );
d130 1
a130 1
   boolean (*get_query_result)(struct pipe_context *pipe,
d133 1
a133 1
                               void *result);
a152 3
   void   (*bind_geometry_sampler_states)(struct pipe_context *,
                                          unsigned num_samplers,
                                          void **samplers);
a179 11
   void * (*create_vertex_elements_state)(struct pipe_context *,
                                          unsigned num_elements,
                                          const struct pipe_vertex_element *);
   void   (*bind_vertex_elements_state)(struct pipe_context *, void *);
   void   (*delete_vertex_elements_state)(struct pipe_context *, void *);

   void * (*create_stream_output_state)(struct pipe_context *,
                                        const struct pipe_stream_output_state *);
   void   (*bind_stream_output_state)(struct pipe_context *, void *);
   void   (*delete_stream_output_state)(struct pipe_context*, void*);

a191 3
   void (*set_sample_mask)( struct pipe_context *,
                            unsigned sample_mask );

d197 1
a197 1
                                struct pipe_resource *buf );
d211 7
a217 11
   void (*set_fragment_sampler_views)(struct pipe_context *,
                                      unsigned num_views,
                                      struct pipe_sampler_view **);

   void (*set_vertex_sampler_views)(struct pipe_context *,
                                    unsigned num_views,
                                    struct pipe_sampler_view **);

   void (*set_geometry_sampler_views)(struct pipe_context *,
                                      unsigned num_views,
                                      struct pipe_sampler_view **);
d223 3
a225 10
   void (*set_index_buffer)( struct pipe_context *pipe,
                             const struct pipe_index_buffer * );

   void (*set_stream_output_buffers)(struct pipe_context *,
                                     struct pipe_resource **buffers,
                                     int *offsets, /*array of offsets
                                                     from the start of each
                                                     of the buffers */
                                     int num_buffers);

d230 1
a230 1
    * Resource functions for blit-like functionality
d232 2
a233 1
    * If a driver supports multisampling, resource_resolve must be available.
d238 18
a255 22
    * Copy a block of pixels from one resource to another.
    * The resource must be of the same format.
    * Resources with nr_samples > 1 are not allowed.
    */
   void (*resource_copy_region)(struct pipe_context *pipe,
                                struct pipe_resource *dst,
                                unsigned dst_level,
                                unsigned dstx, unsigned dsty, unsigned dstz,
                                struct pipe_resource *src,
                                unsigned src_level,
                                const struct pipe_box *src_box);

   /**
    * Resolve a multisampled resource into a non-multisampled one.
    * Source and destination must have the same size and same format.
    */
   void (*resource_resolve)(struct pipe_context *pipe,
                            struct pipe_resource *dst,
                            unsigned dst_layer,
                            struct pipe_resource *src,
                            unsigned src_layer);

d269 1
a269 1
                 const float *rgba,
d271 1
a271 25
                 unsigned stencil);

   /**
    * Clear a color rendertarget surface.
    * \param rgba  pointer to an array of one float for each of r, g, b, a.
    */
   void (*clear_render_target)(struct pipe_context *pipe,
                               struct pipe_surface *dst,
                               const float *rgba,
                               unsigned dstx, unsigned dsty,
                               unsigned width, unsigned height);

   /**
    * Clear a depth-stencil surface.
    * \param clear_flags  bitfield of PIPE_CLEAR_DEPTH/STENCIL values.
    * \param depth  depth clear value in [0,1].
    * \param stencil  stencil clear value
    */
   void (*clear_depth_stencil)(struct pipe_context *pipe,
                               struct pipe_surface *dst,
                               unsigned clear_flags,
                               double depth,
                               unsigned stencil,
                               unsigned dstx, unsigned dsty,
                               unsigned width, unsigned height);
d287 1
a288 1
    * \param layer  cubemap face, 2d array or 3d slice, 0 otherwise. Use -1 for any layer.
d291 3
a293 3
   unsigned int (*is_resource_referenced)(struct pipe_context *pipe,
                                          struct pipe_resource *texture,
                                          unsigned level, int layer);
d296 7
a302 14
    * Create a view on a texture to be used by a shader stage.
    */
   struct pipe_sampler_view * (*create_sampler_view)(struct pipe_context *ctx,
                                                     struct pipe_resource *texture,
                                                     const struct pipe_sampler_view *templat);

   void (*sampler_view_destroy)(struct pipe_context *ctx,
                                struct pipe_sampler_view *view);


   /**
    * Get a surface which is a "view" into a resource, used by
    * render target / depth stencil stages.
    * \param usage  bitmaks of PIPE_BIND_* flags
d304 2
a305 49
   struct pipe_surface *(*create_surface)(struct pipe_context *ctx,
                                          struct pipe_resource *resource,
                                          const struct pipe_surface *templat);

   void (*surface_destroy)(struct pipe_context *ctx,
                           struct pipe_surface *);

   /**
    * Get a transfer object for transferring data to/from a texture.
    *
    * Transfers are (by default) context-private and allow uploads to be
    * interleaved with
    */
   struct pipe_transfer *(*get_transfer)(struct pipe_context *,
                                         struct pipe_resource *resource,
                                         unsigned level,
                                         unsigned usage,  /* a combination of PIPE_TRANSFER_x */
                                         const struct pipe_box *);

   void (*transfer_destroy)(struct pipe_context *,
                            struct pipe_transfer *);

   void *(*transfer_map)( struct pipe_context *,
                          struct pipe_transfer *transfer );

   /* If transfer was created with WRITE|FLUSH_EXPLICIT, only the
    * regions specified with this call are guaranteed to be written to
    * the resource.
    */
   void (*transfer_flush_region)( struct pipe_context *,
				  struct pipe_transfer *transfer,
				  const struct pipe_box *);

   void (*transfer_unmap)( struct pipe_context *,
                           struct pipe_transfer *transfer );


   /* One-shot transfer operation with data supplied in a user
    * pointer.  XXX: strides??
    */
   void (*transfer_inline_write)( struct pipe_context *,
                                  struct pipe_resource *,
                                  unsigned level,
                                  unsigned usage, /* a combination of PIPE_TRANSFER_x */
                                  const struct pipe_box *,
                                  const void *data,
                                  unsigned stride,
                                  unsigned layer_stride);

@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a31 3
#include "p_format.h"
#include "p_video_enums.h"
#include "p_defines.h"
a39 1
struct pipe_blit_info;
a41 1
struct pipe_constant_buffer;
a49 1
struct pipe_resolve_info;
d56 1
a56 1
struct pipe_stream_output_target;
a57 1
struct pipe_transfer;
a59 2
struct pipe_video_buffer;
struct pipe_video_decoder;
a60 3
struct pipe_compute_state;
union pipe_color_union;
union pipe_query_result;
d69 1
d83 5
a92 1
    * \param condition whether to skip on FALSE or TRUE query results
a96 1
                             boolean condition,
d120 1
a120 1
                               union pipe_query_result *result);
a142 4
   void   (*bind_compute_sampler_states)(struct pipe_context *,
                                         unsigned start_slot,
                                         unsigned num_samplers,
                                         void **samplers);
d176 5
d201 1
a201 1
                                struct pipe_constant_buffer *buf );
d209 5
a213 9
   void (*set_scissor_states)( struct pipe_context *,
                               unsigned start_slot,
                               unsigned num_scissors,
                               const struct pipe_scissor_state * );

   void (*set_viewport_states)( struct pipe_context *,
                                unsigned start_slot,
                                unsigned num_viewports,
                                const struct pipe_viewport_state *);
a226 20
   void (*set_compute_sampler_views)(struct pipe_context *,
                                     unsigned start_slot, unsigned num_views,
                                     struct pipe_sampler_view **);

   /**
    * Bind an array of shader resources that will be used by the
    * graphics pipeline.  Any resources that were previously bound to
    * the specified range will be unbound after this call.
    *
    * \param start      first resource to bind.
    * \param count      number of consecutive resources to bind.
    * \param resources  array of pointers to the resources to bind, it
    *                   should contain at least \a count elements
    *                   unless it's NULL, in which case no new
    *                   resources will be bound.
    */
   void (*set_shader_resources)(struct pipe_context *,
                                unsigned start, unsigned count,
                                struct pipe_surface **resources);

a227 1
                               unsigned start_slot,
d234 6
a239 20
   /*@@}*/

   /**
    * Stream output functions.
    */
   /*@@{*/

   struct pipe_stream_output_target *(*create_stream_output_target)(
                        struct pipe_context *,
                        struct pipe_resource *,
                        unsigned buffer_offset,
                        unsigned buffer_size);

   void (*stream_output_target_destroy)(struct pipe_context *,
                                        struct pipe_stream_output_target *);

   void (*set_stream_output_targets)(struct pipe_context *,
                              unsigned num_targets,
                              struct pipe_stream_output_target **targets,
                              unsigned append_bitmask);
d247 1
a247 1
    * If a driver supports multisampling, blit must implement color resolve.
d264 3
a266 2
   /* Optimal hardware path for blitting pixels.
    * Scaling, format conversion, up- and downsampling (resolve) are allowed.
d268 5
a272 2
   void (*blit)(struct pipe_context *pipe,
                const struct pipe_blit_info *info);
d281 1
a281 1
    * \param color  pointer to a union of fiu array for each of r, g, b, a.
d287 1
a287 1
                 const union pipe_color_union *color,
d293 1
a293 1
    * \param color  pointer to an union of fiu array for each of r, g, b, a.
d297 1
a297 1
                               const union pipe_color_union *color,
d315 2
a316 3
   /** Flush draw commands
    *
    * \param flags  bitfield of enum pipe_flush_flags values.
d318 18
a335 3
   void (*flush)(struct pipe_context *pipe,
                 struct pipe_fence_handle **fence,
                 unsigned flags);
d351 1
d361 1
a361 1
    * Map a resource.
d364 13
a376 12
    * interleaved with rendering.
    *
    * out_transfer will contain the transfer object that must be passed
    * to all the other transfer functions. It also contains useful
    * information (like texture strides).
    */
   void *(*transfer_map)(struct pipe_context *,
                         struct pipe_resource *resource,
                         unsigned level,
                         unsigned usage,  /* a combination of PIPE_TRANSFER_x */
                         const struct pipe_box *,
                         struct pipe_transfer **out_transfer);
d386 3
a388 2
   void (*transfer_unmap)(struct pipe_context *,
                          struct pipe_transfer *transfer);
a401 117
   /**
    * Flush any pending framebuffer writes and invalidate texture caches.
    */
   void (*texture_barrier)(struct pipe_context *);
   
   /**
    * Creates a video decoder for a specific video codec/profile
    */
   struct pipe_video_decoder *(*create_video_decoder)( struct pipe_context *context,
                                                       enum pipe_video_profile profile,
                                                       enum pipe_video_entrypoint entrypoint,
                                                       enum pipe_video_chroma_format chroma_format,
                                                       unsigned width, unsigned height, unsigned max_references,
                                                       bool expect_chunked_decode);

   /**
    * Creates a video buffer as decoding target
    */
   struct pipe_video_buffer *(*create_video_buffer)( struct pipe_context *context,
                                                     const struct pipe_video_buffer *templat );

   /**
    * Compute kernel execution
    */
   /*@@{*/
   /**
    * Define the compute program and parameters to be used by
    * pipe_context::launch_grid.
    */
   void *(*create_compute_state)(struct pipe_context *context,
				 const struct pipe_compute_state *);
   void (*bind_compute_state)(struct pipe_context *, void *);
   void (*delete_compute_state)(struct pipe_context *, void *);

   /**
    * Bind an array of shader resources that will be used by the
    * compute program.  Any resources that were previously bound to
    * the specified range will be unbound after this call.
    *
    * \param start      first resource to bind.
    * \param count      number of consecutive resources to bind.
    * \param resources  array of pointers to the resources to bind, it
    *                   should contain at least \a count elements
    *                   unless it's NULL, in which case no new
    *                   resources will be bound.
    */
   void (*set_compute_resources)(struct pipe_context *,
                                 unsigned start, unsigned count,
                                 struct pipe_surface **resources);

   /**
    * Bind an array of buffers to be mapped into the address space of
    * the GLOBAL resource.  Any buffers that were previously bound
    * between [first, first + count - 1] are unbound after this call.
    *
    * \param first      first buffer to map.
    * \param count      number of consecutive buffers to map.
    * \param resources  array of pointers to the buffers to map, it
    *                   should contain at least \a count elements
    *                   unless it's NULL, in which case no new
    *                   resources will be bound.
    * \param handles    array of pointers to the memory locations that
    *                   will be filled with the respective base
    *                   addresses each buffer will be mapped to.  It
    *                   should contain at least \a count elements,
    *                   unless \a resources is NULL in which case \a
    *                   handles should be NULL as well.
    *
    * Note that the driver isn't required to make any guarantees about
    * the contents of the \a handles array being valid anytime except
    * during the subsequent calls to pipe_context::launch_grid.  This
    * means that the only sensible location handles[i] may point to is
    * somewhere within the INPUT buffer itself.  This is so to
    * accommodate implementations that lack virtual memory but
    * nevertheless migrate buffers on the fly, leading to resource
    * base addresses that change on each kernel invocation or are
    * unknown to the pipe driver.
    */
   void (*set_global_binding)(struct pipe_context *context,
                              unsigned first, unsigned count,
                              struct pipe_resource **resources,
                              uint32_t **handles);

   /**
    * Launch the compute kernel starting from instruction \a pc of the
    * currently bound compute program.
    *
    * \a grid_layout and \a block_layout are arrays of size \a
    * PIPE_COMPUTE_CAP_GRID_DIMENSION that determine the layout of the
    * grid (in block units) and working block (in thread units) to be
    * used, respectively.
    *
    * \a pc For drivers that use PIPE_SHADER_IR_LLVM as their prefered IR,
    * this value will be the index of the kernel in the opencl.kernels
    * metadata list.
    *
    * \a input will be used to initialize the INPUT resource, and it
    * should point to a buffer of at least
    * pipe_compute_state::req_input_mem bytes.
    */
   void (*launch_grid)(struct pipe_context *context,
                       const uint *block_layout, const uint *grid_layout,
                       uint32_t pc, const void *input);
   /*@@}*/

   /**
    * Get sample position for an individual sample point.
    *
    * \param sample_count - total number of samples
    * \param sample_index - sample to get the position values for
    * \param out_value - return value of 2 floats for x and y position for
    *                    requested sample.
    */
   void (*get_sample_position)(struct pipe_context *context,
                               unsigned sample_count,
                               unsigned sample_index,
                               float *out_value);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d68 1
a68 1
struct pipe_video_codec;
d142 13
a154 3
   void   (*bind_sampler_states)(struct pipe_context *,
                                 unsigned shader, unsigned start_slot,
                                 unsigned num_samplers, void **samplers);
a202 3
   void (*set_min_samples)( struct pipe_context *,
                            unsigned min_samples );

d226 15
a240 3
   void (*set_sampler_views)(struct pipe_context *, unsigned shader,
                             unsigned start_slot, unsigned num_views,
                             struct pipe_sampler_view **);
d285 1
a285 1
                              const unsigned *offsets);
a356 11
   /**
    * Clear a buffer. Runs a memset over the specified region with the element
    * value passed in through clear_value of size clear_value_size.
    */
   void (*clear_buffer)(struct pipe_context *pipe,
                        struct pipe_resource *res,
                        unsigned offset,
                        unsigned size,
                        const void *clear_value,
                        int clear_value_size);

d431 1
a431 1

d433 1
a433 1
    * Flush caches according to flags.
d435 6
a440 7
   void (*memory_barrier)(struct pipe_context *, unsigned flags);

   /**
    * Creates a video codec for a specific video format/profile
    */
   struct pipe_video_codec *(*create_video_codec)( struct pipe_context *context,
                                                   const struct pipe_video_codec *templat );
d489 5
a493 8
    *                   will be updated with the address each buffer
    *                   will be mapped to.  The base memory address of
    *                   each of the buffers will be added to the value
    *                   pointed to by its corresponding handle to form
    *                   the final address argument.  It should contain
    *                   at least \a count elements, unless \a
    *                   resources is NULL in which case \a handles
    *                   should be NULL as well.
a543 13

   /**
    * Flush the resource cache, so that the resource can be used
    * by an external client. Possible usage:
    * - flushing a resource before presenting it on the screen
    * - flushing a resource if some other process or device wants to use it
    * This shouldn't be used to flush caches if the resource is only managed
    * by a single pipe_screen and is not shared with another process.
    * (i.e. you shouldn't use it to flush caches explicitly if you want to e.g.
    * use the resource for texturing)
    */
   void (*flush_resource)(struct pipe_context *ctx,
                          struct pipe_resource *resource);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d112 1
a112 2
                                       unsigned query_type,
                                       unsigned index );
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d112 2
a113 1
                                       unsigned query_type );
@


