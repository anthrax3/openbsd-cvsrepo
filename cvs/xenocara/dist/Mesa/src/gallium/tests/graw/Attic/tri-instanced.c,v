head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.40;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.07;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.08;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.50;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.23;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Test draw instancing.
 */

#include <stdio.h>
#include <string.h>

#include "state_tracker/graw.h"
#include "pipe/p_screen.h"
#include "pipe/p_context.h"
#include "pipe/p_state.h"
#include "pipe/p_defines.h"

#include "util/u_memory.h"      /* Offset() */
#include "util/u_draw_quad.h"
#include "util/u_inlines.h"


enum pipe_format formats[] = {
   PIPE_FORMAT_RGBA8888_UNORM,
   PIPE_FORMAT_BGRA8888_UNORM,
   PIPE_FORMAT_NONE
};

static const int WIDTH = 300;
static const int HEIGHT = 300;

static struct pipe_screen *screen = NULL;
static struct pipe_context *ctx = NULL;
static struct pipe_surface *surf = NULL;
static struct pipe_resource *tex = NULL;
static void *window = NULL;

struct vertex {
   float position[4];
   float color[4];
};


static int draw_elements = 0;


/**
 * Vertex data.
 * Each vertex has three attributes: position, color and translation.
 * The translation attribute is a per-instance attribute.  See
 * "instance_divisor" below.
 */
static struct vertex vertices[4] =
{
   {
      { 0.0f, -0.3f, 0.0f, 1.0f },  /* pos */
      { 1.0f, 0.0f, 0.0f, 1.0f }    /* color */
   },
   {
      { -0.2f, 0.3f, 0.0f, 1.0f },
      { 0.0f, 1.0f, 0.0f, 1.0f }
   },
   {
      { 0.2f, 0.3f, 0.0f, 1.0f },
      { 0.0f, 0.0f, 1.0f, 1.0f }
   }
};


#define NUM_INST 5

static float inst_data[NUM_INST][4] =
{
   { -0.50f, 0.4f, 0.0f, 0.0f },
   { -0.25f, 0.1f, 0.0f, 0.0f },
   { 0.00f, 0.2f, 0.0f, 0.0f },
   { 0.25f, 0.1f, 0.0f, 0.0f },
   { 0.50f, 0.3f, 0.0f, 0.0f }
};


static ushort indices[3] = { 0, 2, 1 };


static void set_viewport( float x, float y,
                          float width, float height,
                          float near, float far)
{
   float z = far;
   float half_width = (float)width / 2.0f;
   float half_height = (float)height / 2.0f;
   float half_depth = ((float)far - (float)near) / 2.0f;
   struct pipe_viewport_state vp;

   vp.scale[0] = half_width;
   vp.scale[1] = half_height;
   vp.scale[2] = half_depth;
   vp.scale[3] = 1.0f;

   vp.translate[0] = half_width + x;
   vp.translate[1] = half_height + y;
   vp.translate[2] = half_depth + z;
   vp.translate[3] = 0.0f;

   ctx->set_viewport_states( ctx, 0, 1, &vp );
}


static void set_vertices( void )
{
   struct pipe_vertex_element ve[3];
   struct pipe_vertex_buffer vbuf[2];
   struct pipe_index_buffer ibuf;
   void *handle;

   memset(ve, 0, sizeof ve);

   /* pos */
   ve[0].src_offset = Offset(struct vertex, position);
   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
   ve[0].vertex_buffer_index = 0;

   /* color */
   ve[1].src_offset = Offset(struct vertex, color);
   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
   ve[1].vertex_buffer_index = 0;

   /* per-instance info */
   ve[2].src_offset = 0;
   ve[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
   ve[2].vertex_buffer_index = 1;
   ve[2].instance_divisor = 1;

   handle = ctx->create_vertex_elements_state(ctx, 3, ve);
   ctx->bind_vertex_elements_state(ctx, handle);

   memset(&vbuf, 0, sizeof vbuf);

   /* vertex data */
   vbuf[0].stride = sizeof( struct vertex );
   vbuf[0].buffer_offset = 0;
   vbuf[0].buffer = pipe_buffer_create_with_data(ctx,
                                                 PIPE_BIND_VERTEX_BUFFER,
                                                 PIPE_USAGE_DEFAULT,
                                                 sizeof(vertices),
                                                 vertices);

   /* instance data */
   vbuf[1].stride = sizeof( inst_data[0] );
   vbuf[1].buffer_offset = 0;
   vbuf[1].buffer = pipe_buffer_create_with_data(ctx,
                                                 PIPE_BIND_VERTEX_BUFFER,
                                                 PIPE_USAGE_DEFAULT,
                                                 sizeof(inst_data),
                                                 inst_data);

   ctx->set_vertex_buffers(ctx, 0, 2, vbuf);

   /* index data */
   ibuf.buffer = pipe_buffer_create_with_data(ctx,
                                              PIPE_BIND_INDEX_BUFFER,
                                              PIPE_USAGE_DEFAULT,
                                              sizeof(indices),
                                              indices);
   ibuf.offset = 0;
   ibuf.index_size = 2;

   ctx->set_index_buffer(ctx, &ibuf);

}

static void set_vertex_shader( void )
{
   void *handle;
   const char *text =
      "VERT\n"
      "DCL IN[0]\n"
      "DCL IN[1]\n"
      "DCL IN[2]\n"
      "DCL OUT[0], POSITION\n"
      "DCL OUT[1], COLOR\n"
      "  0: MOV OUT[1], IN[1]\n"
      "  1: ADD OUT[0], IN[0], IN[2]\n"  /* add instance pos to vertex pos */
      "  2: END\n";

   handle = graw_parse_vertex_shader(ctx, text);
   ctx->bind_vs_state(ctx, handle);
}

static void set_fragment_shader( void )
{
   void *handle;
   const char *text =
      "FRAG\n"
      "DCL IN[0], COLOR, LINEAR\n"
      "DCL OUT[0], COLOR\n"
      "  0: MOV OUT[0], IN[0]\n"
      "  1: END\n";

   handle = graw_parse_fragment_shader(ctx, text);
   ctx->bind_fs_state(ctx, handle);
}


static void draw( void )
{
   union pipe_color_union clear_color = { {1,0,1,1} };
   struct pipe_draw_info info;

   ctx->clear(ctx, PIPE_CLEAR_COLOR, &clear_color, 0, 0);

   util_draw_init_info(&info);
   info.indexed = (draw_elements != 0);
   info.mode = PIPE_PRIM_TRIANGLES;
   info.start = 0;
   info.count = 3;
   /* draw NUM_INST triangles */
   info.instance_count = NUM_INST;

   ctx->draw_vbo(ctx, &info);

   ctx->flush(ctx, NULL, 0);

   graw_save_surface_to_file(ctx, surf, NULL);

   screen->flush_frontbuffer(screen, tex, 0, 0, window, NULL);
}


static void init( void )
{
   struct pipe_framebuffer_state fb;
   struct pipe_resource templat;
   struct pipe_surface surf_tmpl;
   int i;

   /* It's hard to say whether window or screen should be created
    * first.  Different environments would prefer one or the other.
    *
    * Also, no easy way of querying supported formats if the screen
    * cannot be created first.
    */
   for (i = 0; formats[i] != PIPE_FORMAT_NONE; i++) {
      screen = graw_create_window_and_screen(0, 0, 300, 300,
                                             formats[i],
                                             &window);
      if (window && screen)
         break;
   }
   if (!screen || !window) {
      fprintf(stderr, "Unable to create window\n");
      exit(1);
   }
   
   ctx = screen->context_create(screen, NULL);
   if (ctx == NULL)
      exit(3);

   templat.target = PIPE_TEXTURE_2D;
   templat.format = formats[i];
   templat.width0 = WIDTH;
   templat.height0 = HEIGHT;
   templat.depth0 = 1;
   templat.array_size = 1;
   templat.last_level = 0;
   templat.nr_samples = 1;
   templat.bind = (PIPE_BIND_RENDER_TARGET |
                   PIPE_BIND_DISPLAY_TARGET);
   
   tex = screen->resource_create(screen,
                                 &templat);
   if (tex == NULL)
      exit(4);

   surf_tmpl.format = templat.format;
   surf_tmpl.u.tex.level = 0;
   surf_tmpl.u.tex.first_layer = 0;
   surf_tmpl.u.tex.last_layer = 0;
   surf = ctx->create_surface(ctx, tex, &surf_tmpl);
   if (surf == NULL)
      exit(5);

   memset(&fb, 0, sizeof fb);
   fb.nr_cbufs = 1;
   fb.width = WIDTH;
   fb.height = HEIGHT;
   fb.cbufs[0] = surf;

   ctx->set_framebuffer_state(ctx, &fb);
   
   {
      struct pipe_blend_state blend;
      void *handle;
      memset(&blend, 0, sizeof blend);
      blend.rt[0].colormask = PIPE_MASK_RGBA;
      handle = ctx->create_blend_state(ctx, &blend);
      ctx->bind_blend_state(ctx, handle);
   }

   {
      struct pipe_depth_stencil_alpha_state depthstencil;
      void *handle;
      memset(&depthstencil, 0, sizeof depthstencil);
      handle = ctx->create_depth_stencil_alpha_state(ctx, &depthstencil);
      ctx->bind_depth_stencil_alpha_state(ctx, handle);
   }

   {
      struct pipe_rasterizer_state rasterizer;
      void *handle;
      memset(&rasterizer, 0, sizeof rasterizer);
      rasterizer.cull_face = PIPE_FACE_NONE;
      rasterizer.half_pixel_center = 1;
      rasterizer.bottom_edge_rule = 1;
      rasterizer.depth_clip = 1;
      handle = ctx->create_rasterizer_state(ctx, &rasterizer);
      ctx->bind_rasterizer_state(ctx, handle);
   }

   set_viewport(0, 0, WIDTH, HEIGHT, 30, 1000);
   set_vertices();
   set_vertex_shader();
   set_fragment_shader();
}


static void options(int argc, char *argv[])
{
   int i;

   for (i = 1; i < argc;) {
      if (graw_parse_args(&i, argc, argv)) {
         continue;
      }
      if (strcmp(argv[i], "-e") == 0) {
         draw_elements = 1;
         i++;
      }
      else {
         i++;
      }
   }
   if (draw_elements)
      printf("Using pipe_context::draw_elements_instanced()\n");
   else
      printf("Using pipe_context::draw_arrays_instanced()\n");
}


int main( int argc, char *argv[] )
{
   options(argc, argv);

   init();

   graw_set_display_func( draw );
   graw_main_loop();
   return 0;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d140 1
a140 1
                                                 PIPE_USAGE_STATIC,
d149 1
a149 1
                                                 PIPE_USAGE_STATIC,
d158 1
a158 1
                                              PIPE_USAGE_STATIC,
d222 1
a222 1
   screen->flush_frontbuffer(screen, tex, 0, 0, window);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d16 1
d20 2
a21 2
   PIPE_FORMAT_R8G8B8A8_UNORM,
   PIPE_FORMAT_B8G8R8A8_UNORM,
d101 1
a101 1
   ctx->set_viewport_state( ctx, &vp );
d133 1
d138 5
a142 4
   vbuf[0].buffer = screen->user_buffer_create(screen,
                                               vertices,
                                               sizeof(vertices),
                                               PIPE_BIND_VERTEX_BUFFER);
d147 5
a151 4
   vbuf[1].buffer = screen->user_buffer_create(screen,
                                               inst_data,
                                               sizeof(inst_data),
                                               PIPE_BIND_VERTEX_BUFFER);
d153 1
a153 2

   ctx->set_vertex_buffers(ctx, 2, vbuf);
d156 5
a160 4
   ibuf.buffer = screen->user_buffer_create(screen,
                                            indices,
                                            sizeof(indices),
                                            PIPE_BIND_VERTEX_BUFFER);
d203 1
a203 1
   float clear_color[4] = {1,0,1,1};
d206 1
a206 1
   ctx->clear(ctx, PIPE_CLEAR_COLOR, clear_color, 0, 0);
d218 1
a218 1
   ctx->flush(ctx, NULL);
a271 1
   surf_tmpl.usage = PIPE_BIND_RENDER_TARGET;
d309 3
a311 1
      rasterizer.gl_rasterization_rules = 1;
@


1.1
log
@Initial revision
@
text
@a134 1
   vbuf[0].max_index = sizeof(vertices) / vbuf[0].stride;
a142 1
   vbuf[1].max_index = sizeof(inst_data) / vbuf[1].stride;
d214 1
a214 1
   ctx->flush(ctx, PIPE_FLUSH_RENDER_CACHE, NULL);
d235 2
a236 5
   for (i = 0; 
        window == NULL && formats[i] != PIPE_FORMAT_NONE;
        i++) {
      
      screen = graw_create_window_and_screen(0,0,300,300,
d239 6
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a15 1
#include "util/u_inlines.h"
d19 2
a20 2
   PIPE_FORMAT_RGBA8888_UNORM,
   PIPE_FORMAT_BGRA8888_UNORM,
d100 1
a100 1
   ctx->set_viewport_states( ctx, 0, 1, &vp );
a131 1
   memset(&vbuf, 0, sizeof vbuf);
d135 1
d137 4
a140 5
   vbuf[0].buffer = pipe_buffer_create_with_data(ctx,
                                                 PIPE_BIND_VERTEX_BUFFER,
                                                 PIPE_USAGE_STATIC,
                                                 sizeof(vertices),
                                                 vertices);
d144 1
d146 4
a149 5
   vbuf[1].buffer = pipe_buffer_create_with_data(ctx,
                                                 PIPE_BIND_VERTEX_BUFFER,
                                                 PIPE_USAGE_STATIC,
                                                 sizeof(inst_data),
                                                 inst_data);
d151 2
a152 1
   ctx->set_vertex_buffers(ctx, 0, 2, vbuf);
d155 4
a158 5
   ibuf.buffer = pipe_buffer_create_with_data(ctx,
                                              PIPE_BIND_INDEX_BUFFER,
                                              PIPE_USAGE_STATIC,
                                              sizeof(indices),
                                              indices);
d201 1
a201 1
   union pipe_color_union clear_color = { {1,0,1,1} };
d204 1
a204 1
   ctx->clear(ctx, PIPE_CLEAR_COLOR, &clear_color, 0, 0);
d216 1
a216 1
   ctx->flush(ctx, NULL, 0);
d237 5
a241 2
   for (i = 0; formats[i] != PIPE_FORMAT_NONE; i++) {
      screen = graw_create_window_and_screen(0, 0, 300, 300,
a243 6
      if (window && screen)
         break;
   }
   if (!screen || !window) {
      fprintf(stderr, "Unable to create window\n");
      exit(1);
d267 1
d305 1
a305 3
      rasterizer.half_pixel_center = 1;
      rasterizer.bottom_edge_rule = 1;
      rasterizer.depth_clip = 1;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d140 1
a140 1
                                                 PIPE_USAGE_DEFAULT,
d149 1
a149 1
                                                 PIPE_USAGE_DEFAULT,
d158 1
a158 1
                                              PIPE_USAGE_DEFAULT,
d222 1
a222 1
   screen->flush_frontbuffer(screen, tex, 0, 0, window, NULL);
@


