head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.1.0.14
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.12
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.10
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.27;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.22.09.30.33;	author jsg;	state Exp;
branches;
next	1.4;
commitid	yhStanAcs6cSYmBc;

1.4
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.3;
commitid	4ry2gvZGMXkCUD2n;

1.3
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.2;
commitid	mcxB0JvoI9gTDYXU;

1.2
date	2013.09.05.13.59.38;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.18;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.06.24;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.43.32;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008-2010 Vmware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "os_misc.h"

#include <stdarg.h>


#if defined(PIPE_SUBSYSTEM_WINDOWS_USER)

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN      // Exclude rarely-used stuff from Windows headers
#endif
#include <windows.h>
#include <stdio.h>

#else

#include <stdio.h>
#include <stdlib.h>

#endif


#if defined(PIPE_OS_LINUX)
#  include <unistd.h>
#elif defined(PIPE_OS_APPLE) || defined(PIPE_OS_BSD)
#  include <sys/sysctl.h>
#elif defined(PIPE_OS_HAIKU)
#  include <kernel/OS.h>
#elif defined(PIPE_OS_WINDOWS)
#  include <windows.h>
#else
#error unexpected platform in os_sysinfo.c
#endif


void
os_log_message(const char *message)
{
   /* If the GALLIUM_LOG_FILE environment variable is set to a valid filename,
    * write all messages to that file.
    */
   static FILE *fout = NULL;

   if (!fout) {
      /* one-time init */
      const char *filename = os_get_option("GALLIUM_LOG_FILE");
      if (filename)
         fout = fopen(filename, "w");
      if (!fout)
         fout = stderr;
   }

#if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
   OutputDebugStringA(message);
   if(GetConsoleWindow() && !IsDebuggerPresent()) {
      fflush(stdout);
      fputs(message, fout);
      fflush(fout);
   }
   else if (fout != stderr) {
      fputs(message, fout);
      fflush(fout);
   }
#else /* !PIPE_SUBSYSTEM_WINDOWS */
   fflush(stdout);
   fputs(message, fout);
   fflush(fout);
#endif
}


const char *
os_get_option(const char *name)
{
   return getenv(name);
}


/**
 * Return the size of the total physical memory.
 * \param size returns the size of the total physical memory
 * \return true for success, or false on failure
 */
bool
os_get_total_physical_memory(uint64_t *size)
{
#if defined(PIPE_OS_LINUX)
   const long phys_pages = sysconf(_SC_PHYS_PAGES);
   const long page_size = sysconf(_SC_PAGE_SIZE);

   *size = phys_pages * page_size;
   return (phys_pages > 0 && page_size > 0);
#elif defined(PIPE_OS_APPLE) || defined(PIPE_OS_BSD)
   size_t len = sizeof(*size);
   int mib[2];

   mib[0] = CTL_HW;
#if defined(PIPE_OS_APPLE)
   mib[1] = HW_MEMSIZE;
#elif defined(PIPE_OS_NETBSD) || defined(PIPE_OS_OPENBSD)
   mib[1] = HW_PHYSMEM64;
#elif defined(PIPE_OS_FREEBSD)
   mib[1] = HW_REALMEM;
#else
#error Unsupported *BSD
#endif

   return (sysctl(mib, 2, size, &len, NULL, 0) == 0);
#elif defined(PIPE_OS_HAIKU)
   system_info info;
   status_t ret;

   ret = get_system_info(&info);
   *size = info.max_pages * B_PAGE_SIZE;
   return (ret == B_OK);
#elif defined(PIPE_OS_WINDOWS)
   MEMORYSTATUSEX status;
   BOOL ret;

   status.dwLength = sizeof(status);
   ret = GlobalMemoryStatusEx(&status);
   *size = status.ullTotalPhys;
   return (ret == TRUE);
#else
#error unexpected platform in os_sysinfo.c
   return false;
#endif
}
@


1.5
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.4
log
@Merge Mesa 10.2.9
@
text
@d50 13
d105 51
@


1.3
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a49 13
#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_SOLARIS)
#  include <unistd.h>
#elif defined(PIPE_OS_APPLE) || defined(PIPE_OS_BSD)
#  include <sys/sysctl.h>
#elif defined(PIPE_OS_HAIKU)
#  include <kernel/OS.h>
#elif defined(PIPE_OS_WINDOWS)
#  include <windows.h>
#else
#error unexpected platform in os_sysinfo.c
#endif


a91 53

/**
 * Return the size of the total physical memory.
 * \param size returns the size of the total physical memory
 * \return true for success, or false on failure
 */
bool
os_get_total_physical_memory(uint64_t *size)
{
#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_SOLARIS)
   const long phys_pages = sysconf(_SC_PHYS_PAGES);
   const long page_size = sysconf(_SC_PAGE_SIZE);

   *size = phys_pages * page_size;
   return (phys_pages > 0 && page_size > 0);
#elif defined(PIPE_OS_APPLE) || defined(PIPE_OS_BSD)
   size_t len = sizeof(size);
   int mib[2];

   mib[0] = CTL_HW;
#if defined(PIPE_OS_APPLE)
   mib[1] = HW_MEMSIZE;
#elif defined(PIPE_OS_NETBSD) || defined(PIPE_OS_OPENBSD)
   mib[1] = HW_PHYSMEM64;
#elif defined(PIPE_OS_FREEBSD)
   mib[1] = HW_REALMEM;
#elif defined(PIPE_OS_DRAGONFLY)
   mib[1] = HW_PHYSMEM;
#else
#error Unsupported *BSD
#endif

   return (sysctl(mib, 2, &size, &len, NULL, 0) == 0);
#elif defined(PIPE_OS_HAIKU)
   system_info info;
   status_t ret;

   ret = get_system_info(&info);
   *size = info.max_pages * B_PAGE_SIZE;
   return (ret == B_OK);
#elif defined(PIPE_OS_WINDOWS)
   MEMORYSTATUSEX status;
   BOOL ret;

   status.dwLength = sizeof(status);
   ret = GlobalMemoryStatusEx(&status);
   *size = status.ullTotalPhys;
   return (ret == TRUE);
#else
#error unexpected platform in os_sysinfo.c
   return false;
#endif
}
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d50 13
d105 53
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 1
a34 13
#ifdef PIPE_SUBSYSTEM_WINDOWS_DISPLAY

#include <windows.h>
#include <winddi.h>

#elif defined(PIPE_SUBSYSTEM_WINDOWS_CE)

#include <stdio.h> 
#include <stdlib.h> 
#include <windows.h> 
#include <types.h> 

#elif defined(PIPE_SUBSYSTEM_WINDOWS_USER)
a49 12
#ifdef PIPE_SUBSYSTEM_WINDOWS_DISPLAY
static INLINE void 
_EngDebugPrint(const char *format, ...)
{
   va_list ap;
   va_start(ap, format);
   EngDebugPrint("", (PCHAR)format, ap);
   va_end(ap);
}
#endif


d53 15
a67 3
#if defined(PIPE_SUBSYSTEM_WINDOWS_DISPLAY)
   _EngDebugPrint("%s", message);
#elif defined(PIPE_SUBSYSTEM_WINDOWS_USER)
d71 6
a76 2
      fputs(message, stderr);
      fflush(stderr);
a77 14
#elif defined(PIPE_SUBSYSTEM_WINDOWS_CE)
   wchar_t *wide_format;
   long wide_str_len;   
   /* Format is ascii - needs to be converted to wchar_t for printing */   
   wide_str_len = MultiByteToWideChar(CP_ACP, 0, message, -1, NULL, 0);
   wide_format = (wchar_t *) malloc((wide_str_len+1) * sizeof(wchar_t));   
   if (wide_format) {   
      MultiByteToWideChar(CP_ACP, 0, message, -1,
            wide_format, wide_str_len);   
      NKDbgPrintfW(wide_format, wide_format);   
      free(wide_format);   
   } 
#elif defined(PIPE_SUBSYSTEM_WINDOWS_MINIPORT)
   /* TODO */
d80 2
a81 1
   fputs(message, stderr);
a85 37
#ifdef PIPE_SUBSYSTEM_WINDOWS_DISPLAY
static const char *
find(const char *start, const char *end, char c)
{
   const char *p;
   for(p = start; !end || p != end; ++p) {
      if(*p == c)
         return p;
      if(*p < 32)
         break;
   }
   return NULL;
}

static int
compare(const char *start, const char *end, const char *s)
{
   const char *p, *q;
   for(p = start, q = s; p != end && *q != '\0'; ++p, ++q) {
      if(*p != *q)
         return 0;
   }
   return p == end && *q == '\0';
}

static void
copy(char *dst, const char *start, const char *end, size_t n)
{
   const char *p;
   char *q;
   for(p = start, q = dst, n = n - 1; p != end && n; ++p, ++q, --n)
      *q = *p;
   *q = '\0';
}
#endif


a88 38
#if defined(PIPE_SUBSYSTEM_WINDOWS_DISPLAY)
   /* EngMapFile creates the file if it does not exists, so it must either be
    * disabled on release versions (or put in a less conspicuous place). */
#ifdef DEBUG
   const char *result = NULL;
   ULONG_PTR iFile = 0;
   const void *pMap = NULL;
   const char *sol, *eol, *sep;
   static char output[1024];
   
   pMap = EngMapFile(L"\\??\\c:\\gallium.cfg", 0, &iFile);
   if(pMap) {
      sol = (const char *)pMap;
      while(1) {
	 /* TODO: handle LF line endings */
	 eol = find(sol, NULL, '\r');
	 if(!eol || eol == sol)
	    break;
	 sep = find(sol, eol, '=');
	 if(!sep)
	    break;
	 if(compare(sol, sep, name)) {
	    copy(output, sep + 1, eol, sizeof(output));
	    result = output;
	    break;
	 }
	 sol = eol + 2;
      }
      EngUnmapFile(iFile);
   }
   return result;
#else
   return NULL;
#endif
#elif defined(PIPE_SUBSYSTEM_WINDOWS_CE) || defined(PIPE_SUBSYSTEM_WINDOWS_MINIPORT) 
   /* TODO: implement */
   return NULL;
#else
a89 1
#endif
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d34 13
a46 1
#if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
d62 12
d77 3
a79 15
   /* If the GALLIUM_LOG_FILE environment variable is set to a valid filename,
    * write all messages to that file.
    */
   static FILE *fout = NULL;

   if (!fout) {
      /* one-time init */
      const char *filename = os_get_option("GALLIUM_LOG_FILE");
      if (filename)
         fout = fopen(filename, "w");
      if (!fout)
         fout = stderr;
   }

#if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
d83 2
a84 6
      fputs(message, fout);
      fflush(fout);
   }
   else if (fout != stderr) {
      fputs(message, fout);
      fflush(fout);
d86 14
d102 1
a102 2
   fputs(message, fout);
   fflush(fout);
d107 37
d147 38
d186 1
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a49 13
#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_SOLARIS)
#  include <unistd.h>
#elif defined(PIPE_OS_APPLE) || defined(PIPE_OS_BSD)
#  include <sys/sysctl.h>
#elif defined(PIPE_OS_HAIKU)
#  include <kernel/OS.h>
#elif defined(PIPE_OS_WINDOWS)
#  include <windows.h>
#else
#error unexpected platform in os_sysinfo.c
#endif


a91 53

/**
 * Return the size of the total physical memory.
 * \param size returns the size of the total physical memory
 * \return true for success, or false on failure
 */
bool
os_get_total_physical_memory(uint64_t *size)
{
#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_SOLARIS)
   const long phys_pages = sysconf(_SC_PHYS_PAGES);
   const long page_size = sysconf(_SC_PAGE_SIZE);

   *size = phys_pages * page_size;
   return (phys_pages > 0 && page_size > 0);
#elif defined(PIPE_OS_APPLE) || defined(PIPE_OS_BSD)
   size_t len = sizeof(size);
   int mib[2];

   mib[0] = CTL_HW;
#if defined(PIPE_OS_APPLE)
   mib[1] = HW_MEMSIZE;
#elif defined(PIPE_OS_NETBSD) || defined(PIPE_OS_OPENBSD)
   mib[1] = HW_PHYSMEM64;
#elif defined(PIPE_OS_FREEBSD)
   mib[1] = HW_REALMEM;
#elif defined(PIPE_OS_DRAGONFLY)
   mib[1] = HW_PHYSMEM;
#else
#error Unsupported *BSD
#endif

   return (sysctl(mib, 2, &size, &len, NULL, 0) == 0);
#elif defined(PIPE_OS_HAIKU)
   system_info info;
   status_t ret;

   ret = get_system_info(&info);
   *size = info.max_pages * B_PAGE_SIZE;
   return (ret == B_OK);
#elif defined(PIPE_OS_WINDOWS)
   MEMORYSTATUSEX status;
   BOOL ret;

   status.dwLength = sizeof(status);
   ret = GlobalMemoryStatusEx(&status);
   *size = status.ullTotalPhys;
   return (ret == TRUE);
#else
#error unexpected platform in os_sysinfo.c
   return false;
#endif
}
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d50 13
d105 53
@


