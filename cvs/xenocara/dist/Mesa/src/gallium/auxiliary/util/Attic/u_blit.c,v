head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.27;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.47;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.44;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.46;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.38;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * @@file
 * Copy/blit pixel rect between surfaces
 *  
 * @@author Brian Paul
 */


#include "pipe/p_context.h"
#include "util/u_debug.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "pipe/p_shader_tokens.h"
#include "pipe/p_state.h"

#include "util/u_blit.h"
#include "util/u_draw_quad.h"
#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_sampler.h"
#include "util/u_texture.h"
#include "util/u_simple_shaders.h"

#include "cso_cache/cso_context.h"


struct blit_state
{
   struct pipe_context *pipe;
   struct cso_context *cso;

   struct pipe_blend_state blend_write_color;
   struct pipe_depth_stencil_alpha_state dsa_keep_depthstencil;
   struct pipe_rasterizer_state rasterizer;
   struct pipe_sampler_state sampler;
   struct pipe_viewport_state viewport;
   struct pipe_vertex_element velem[2];

   void *vs;
   void *fs[PIPE_MAX_TEXTURE_TYPES][TGSI_WRITEMASK_XYZW + 1];

   struct pipe_resource *vbuf;  /**< quad vertices */
   unsigned vbuf_slot;

   float vertices[4][2][4];   /**< vertex/texcoords for quad */
};


/**
 * Create state object for blit.
 * Intended to be created once and re-used for many blit() calls.
 */
struct blit_state *
util_create_blit(struct pipe_context *pipe, struct cso_context *cso)
{
   struct blit_state *ctx;
   uint i;

   ctx = CALLOC_STRUCT(blit_state);
   if (!ctx)
      return NULL;

   ctx->pipe = pipe;
   ctx->cso = cso;

   /* disabled blending/masking */
   ctx->blend_write_color.rt[0].colormask = PIPE_MASK_RGBA;

   /* rasterizer */
   ctx->rasterizer.cull_face = PIPE_FACE_NONE;
   ctx->rasterizer.half_pixel_center = 1;
   ctx->rasterizer.bottom_edge_rule = 1;
   ctx->rasterizer.depth_clip = 1;

   /* samplers */
   ctx->sampler.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->sampler.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->sampler.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   ctx->sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
   ctx->sampler.min_img_filter = 0; /* set later */
   ctx->sampler.mag_img_filter = 0; /* set later */

   /* vertex elements state */
   for (i = 0; i < 2; i++) {
      ctx->velem[i].src_offset = i * 4 * sizeof(float);
      ctx->velem[i].instance_divisor = 0;
      ctx->velem[i].vertex_buffer_index = cso_get_aux_vertex_buffer_slot(cso);
      ctx->velem[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
   }

   ctx->vbuf = NULL;

   /* init vertex data that doesn't change */
   for (i = 0; i < 4; i++) {
      ctx->vertices[i][0][3] = 1.0f; /* w */
      ctx->vertices[i][1][3] = 1.0f; /* q */
   }

   return ctx;
}


/**
 * Destroy a blit context
 */
void
util_destroy_blit(struct blit_state *ctx)
{
   struct pipe_context *pipe = ctx->pipe;
   unsigned i, j;

   if (ctx->vs)
      pipe->delete_vs_state(pipe, ctx->vs);

   for (i = 0; i < Elements(ctx->fs); i++) {
      for (j = 0; j < Elements(ctx->fs[i]); j++) {
         if (ctx->fs[i][j])
            pipe->delete_fs_state(pipe, ctx->fs[i][j]);
      }
   }

   pipe_resource_reference(&ctx->vbuf, NULL);

   FREE(ctx);
}


/**
 * Helper function to set the fragment shaders.
 */
static INLINE void
set_fragment_shader(struct blit_state *ctx, uint writemask,
                    enum pipe_texture_target pipe_tex)
{
   if (!ctx->fs[pipe_tex][writemask]) {
      unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex, 0);

      ctx->fs[pipe_tex][writemask] =
         util_make_fragment_tex_shader_writemask(ctx->pipe, tgsi_tex,
                                                 TGSI_INTERPOLATE_LINEAR,
                                                 writemask);
   }

   cso_set_fragment_shader_handle(ctx->cso, ctx->fs[pipe_tex][writemask]);
}


/**
 * Helper function to set the vertex shader.
 */
static INLINE void
set_vertex_shader(struct blit_state *ctx)
{
   /* vertex shader - still required to provide the linkage between
    * fragment shader input semantics and vertex_element/buffers.
    */
   if (!ctx->vs) {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indexes[] = { 0, 0 };
      ctx->vs = util_make_vertex_passthrough_shader(ctx->pipe, 2,
                                                    semantic_names,
                                                    semantic_indexes);
   }

   cso_set_vertex_shader_handle(ctx->cso, ctx->vs);
}


/**
 * Get offset of next free slot in vertex buffer for quad vertices.
 */
static unsigned
get_next_slot( struct blit_state *ctx )
{
   const unsigned max_slots = 4096 / sizeof ctx->vertices;

   if (ctx->vbuf_slot >= max_slots) {
      pipe_resource_reference(&ctx->vbuf, NULL);
      ctx->vbuf_slot = 0;
   }

   if (!ctx->vbuf) {
      ctx->vbuf = pipe_buffer_create(ctx->pipe->screen,
                                     PIPE_BIND_VERTEX_BUFFER,
                                     PIPE_USAGE_STREAM,
                                     max_slots * sizeof ctx->vertices);
   }
   
   return ctx->vbuf_slot++ * sizeof ctx->vertices;
}




/**
 * Setup vertex data for the textured quad we'll draw.
 * Note: y=0=top
 *
 * FIXME: We should call util_map_texcoords2d_onto_cubemap
 * for cubemaps.
 */
static unsigned
setup_vertex_data_tex(struct blit_state *ctx,
                      unsigned src_target,
                      unsigned src_face,
                      float x0, float y0, float x1, float y1,
                      float s0, float t0, float s1, float t1,
                      float z)
{
   unsigned offset;

   ctx->vertices[0][0][0] = x0;
   ctx->vertices[0][0][1] = y0;
   ctx->vertices[0][0][2] = z;
   ctx->vertices[0][1][0] = s0; /*s*/
   ctx->vertices[0][1][1] = t0; /*t*/
   ctx->vertices[0][1][2] = 0;  /*r*/

   ctx->vertices[1][0][0] = x1;
   ctx->vertices[1][0][1] = y0;
   ctx->vertices[1][0][2] = z;
   ctx->vertices[1][1][0] = s1; /*s*/
   ctx->vertices[1][1][1] = t0; /*t*/
   ctx->vertices[1][1][2] = 0;  /*r*/

   ctx->vertices[2][0][0] = x1;
   ctx->vertices[2][0][1] = y1;
   ctx->vertices[2][0][2] = z;
   ctx->vertices[2][1][0] = s1;
   ctx->vertices[2][1][1] = t1;
   ctx->vertices[3][1][2] = 0;

   ctx->vertices[3][0][0] = x0;
   ctx->vertices[3][0][1] = y1;
   ctx->vertices[3][0][2] = z;
   ctx->vertices[3][1][0] = s0;
   ctx->vertices[3][1][1] = t1;
   ctx->vertices[3][1][2] = 0;

   if (src_target == PIPE_TEXTURE_CUBE ||
       src_target == PIPE_TEXTURE_CUBE_ARRAY) {
      /* Map cubemap texture coordinates inplace. */
      const unsigned stride = sizeof ctx->vertices[0] / sizeof ctx->vertices[0][0][0];
      util_map_texcoords2d_onto_cubemap(src_face,
                                        &ctx->vertices[0][1][0], stride,
                                        &ctx->vertices[0][1][0], stride,
                                        TRUE);
   }

   offset = get_next_slot( ctx );

   if (ctx->vbuf) {
      pipe_buffer_write_nooverlap(ctx->pipe, ctx->vbuf,
                                  offset, sizeof(ctx->vertices), ctx->vertices);
   }

   return offset;
}


/**
 * \return TRUE if two regions overlap, FALSE otherwise
 */
static boolean
regions_overlap(int srcX0, int srcY0,
                int srcX1, int srcY1,
                int dstX0, int dstY0,
                int dstX1, int dstY1)
{
   if (MAX2(srcX0, srcX1) < MIN2(dstX0, dstX1))
      return FALSE; /* src completely left of dst */

   if (MAX2(dstX0, dstX1) < MIN2(srcX0, srcX1))
      return FALSE; /* dst completely left of src */

   if (MAX2(srcY0, srcY1) < MIN2(dstY0, dstY1))
      return FALSE; /* src completely above dst */

   if (MAX2(dstY0, dstY1) < MIN2(srcY0, srcY1))
      return FALSE; /* dst completely above src */

   return TRUE; /* some overlap */
}


/**
 * Can we blit from src format to dest format with a simple copy?
 */
static boolean
formats_compatible(enum pipe_format src_format,
                   enum pipe_format dst_format)
{
   if (src_format == dst_format) {
      return TRUE;
   }
   else {
      const struct util_format_description *src_desc =
         util_format_description(src_format);
      const struct util_format_description *dst_desc =
         util_format_description(dst_format);
      return util_is_format_compatible(src_desc, dst_desc);
   }
}


/**
 * Copy pixel block from src surface to dst surface.
 * Overlapping regions are acceptable.
 * Flipping and stretching are supported.
 * \param filter  one of PIPE_TEX_MIPFILTER_NEAREST/LINEAR
 * \param writemask  controls which channels in the dest surface are sourced
 *                   from the src surface.  Disabled channels are sourced
 *                   from (0,0,0,1).
 */
void
util_blit_pixels(struct blit_state *ctx,
                 struct pipe_resource *src_tex,
                 unsigned src_level,
                 int srcX0, int srcY0,
                 int srcX1, int srcY1,
                 int srcZ0,
                 struct pipe_surface *dst,
                 int dstX0, int dstY0,
                 int dstX1, int dstY1,
                 float z, uint filter,
                 uint writemask, uint zs_writemask)
{
   struct pipe_context *pipe = ctx->pipe;
   enum pipe_format src_format, dst_format;
   const int srcW = abs(srcX1 - srcX0);
   const int srcH = abs(srcY1 - srcY0);
   boolean overlap;
   boolean is_stencil, is_depth, blit_depth, blit_stencil;
   const struct util_format_description *src_desc =
         util_format_description(src_tex->format);
   struct pipe_blit_info info;

   assert(filter == PIPE_TEX_MIPFILTER_NEAREST ||
          filter == PIPE_TEX_MIPFILTER_LINEAR);

   assert(src_level <= src_tex->last_level);

   /* do the regions overlap? */
   overlap = src_tex == dst->texture &&
             dst->u.tex.level == src_level &&
             dst->u.tex.first_layer == srcZ0 &&
      regions_overlap(srcX0, srcY0, srcX1, srcY1,
                      dstX0, dstY0, dstX1, dstY1);

   src_format = util_format_linear(src_tex->format);
   dst_format = util_format_linear(dst->texture->format);

   /* See whether we will blit depth or stencil. */
   is_depth = util_format_has_depth(src_desc);
   is_stencil = util_format_has_stencil(src_desc);

   blit_depth = is_depth && (zs_writemask & BLIT_WRITEMASK_Z);
   blit_stencil = is_stencil && (zs_writemask & BLIT_WRITEMASK_STENCIL);

   assert((writemask && !zs_writemask && !is_depth && !is_stencil) ||
          (!writemask && (blit_depth || blit_stencil)));

   /*
    * XXX: z parameter is deprecated. dst->u.tex.first_layer
    * specificies the destination layer.
    */
   assert(z == 0.0f);

   /*
    * Check for simple case:  no format conversion, no flipping, no stretching,
    * no overlapping, same number of samples.
    * Filter mode should not matter since there's no stretching.
    */
   if (formats_compatible(src_format, dst_format) &&
       src_tex->nr_samples == dst->texture->nr_samples &&
       is_stencil == blit_stencil &&
       is_depth == blit_depth &&
       srcX0 < srcX1 &&
       dstX0 < dstX1 &&
       srcY0 < srcY1 &&
       dstY0 < dstY1 &&
       (dstX1 - dstX0) == (srcX1 - srcX0) &&
       (dstY1 - dstY0) == (srcY1 - srcY0) &&
       !overlap) {
      struct pipe_box src_box;
      src_box.x = srcX0;
      src_box.y = srcY0;
      src_box.z = srcZ0;
      src_box.width = srcW;
      src_box.height = srcH;
      src_box.depth = 1;
      pipe->resource_copy_region(pipe,
                                 dst->texture, dst->u.tex.level,
                                 dstX0, dstY0, dst->u.tex.first_layer,/* dest */
                                 src_tex, src_level,
                                 &src_box);
      return;
   }

   memset(&info, 0, sizeof info);
   info.dst.resource = dst->texture;
   info.dst.level = dst->u.tex.level;
   info.dst.box.x = dstX0;
   info.dst.box.y = dstY0;
   info.dst.box.z = dst->u.tex.first_layer;
   info.dst.box.width = dstX1 - dstX0;
   info.dst.box.height = dstY1 - dstY0;
   assert(info.dst.box.width >= 0);
   assert(info.dst.box.height >= 0);
   info.dst.box.depth = 1;
   info.dst.format = dst->texture->format;
   info.src.resource = src_tex;
   info.src.level = src_level;
   info.src.box.x = srcX0;
   info.src.box.y = srcY0;
   info.src.box.z = srcZ0;
   info.src.box.width = srcX1 - srcX0;
   info.src.box.height = srcY1 - srcY0;
   info.src.box.depth = 1;
   info.src.format = src_tex->format;
   info.mask = writemask | (zs_writemask << 4);
   info.filter = filter;
   info.scissor_enable = 0;

   pipe->blit(pipe, &info);
}


/**
 * Copy pixel block from src sampler view to dst surface.
 *
 * The sampler view's first_level field indicates the source
 * mipmap level to use.
 *
 * The sampler view's first_layer indicate the layer to use, but for
 * cube maps it must point to the first face.  Face is passed in src_face.
 *
 * The main advantage over util_blit_pixels is that it allows to specify swizzles in
 * pipe_sampler_view::swizzle_?.
 *
 * But there is no control over blitting Z and/or stencil.
 */
void
util_blit_pixels_tex(struct blit_state *ctx,
                     struct pipe_sampler_view *src_sampler_view,
                     int srcX0, int srcY0,
                     int srcX1, int srcY1,
                     unsigned src_face,
                     struct pipe_surface *dst,
                     int dstX0, int dstY0,
                     int dstX1, int dstY1,
                     float z, uint filter)
{
   boolean normalized = src_sampler_view->texture->target != PIPE_TEXTURE_RECT;
   struct pipe_framebuffer_state fb;
   float s0, t0, s1, t1;
   unsigned offset;
   struct pipe_resource *tex = src_sampler_view->texture;

   assert(filter == PIPE_TEX_MIPFILTER_NEAREST ||
          filter == PIPE_TEX_MIPFILTER_LINEAR);

   assert(tex);
   assert(tex->width0 != 0);
   assert(tex->height0 != 0);

   s0 = (float) srcX0;
   s1 = (float) srcX1;
   t0 = (float) srcY0;
   t1 = (float) srcY1;

   if(normalized)
   {
      /* normalize according to the mipmap level's size */
      int level = src_sampler_view->u.tex.first_level;
      float w = (float) u_minify(tex->width0, level);
      float h = (float) u_minify(tex->height0, level);
      s0 /= w;
      s1 /= w;
      t0 /= h;
      t1 /= h;
   }

   assert(ctx->pipe->screen->is_format_supported(ctx->pipe->screen, dst->format,
                                                 PIPE_TEXTURE_2D,
                                                 dst->texture->nr_samples,
                                                 PIPE_BIND_RENDER_TARGET));

   /* save state (restored below) */
   cso_save_blend(ctx->cso);
   cso_save_depth_stencil_alpha(ctx->cso);
   cso_save_rasterizer(ctx->cso);
   cso_save_sample_mask(ctx->cso);
   cso_save_min_samples(ctx->cso);
   cso_save_samplers(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_save_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_save_stream_outputs(ctx->cso);
   cso_save_viewport(ctx->cso);
   cso_save_framebuffer(ctx->cso);
   cso_save_fragment_shader(ctx->cso);
   cso_save_vertex_shader(ctx->cso);
   cso_save_geometry_shader(ctx->cso);
   cso_save_vertex_elements(ctx->cso);
   cso_save_aux_vertex_buffer_slot(ctx->cso);

   /* set misc state we care about */
   cso_set_blend(ctx->cso, &ctx->blend_write_color);
   cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_keep_depthstencil);
   cso_set_sample_mask(ctx->cso, ~0);
   cso_set_min_samples(ctx->cso, 1);
   cso_set_rasterizer(ctx->cso, &ctx->rasterizer);
   cso_set_vertex_elements(ctx->cso, 2, ctx->velem);
   cso_set_stream_outputs(ctx->cso, 0, NULL, NULL);

   /* sampler */
   ctx->sampler.normalized_coords = normalized;
   ctx->sampler.min_img_filter = filter;
   ctx->sampler.mag_img_filter = filter;
   cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);
   cso_single_sampler_done(ctx->cso, PIPE_SHADER_FRAGMENT);

   /* viewport */
   ctx->viewport.scale[0] = 0.5f * dst->width;
   ctx->viewport.scale[1] = 0.5f * dst->height;
   ctx->viewport.scale[2] = 0.5f;
   ctx->viewport.scale[3] = 1.0f;
   ctx->viewport.translate[0] = 0.5f * dst->width;
   ctx->viewport.translate[1] = 0.5f * dst->height;
   ctx->viewport.translate[2] = 0.5f;
   ctx->viewport.translate[3] = 0.0f;
   cso_set_viewport(ctx->cso, &ctx->viewport);

   /* texture */
   cso_set_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT, 1, &src_sampler_view);

   /* shaders */
   set_fragment_shader(ctx, TGSI_WRITEMASK_XYZW,
                       src_sampler_view->texture->target);
   set_vertex_shader(ctx);
   cso_set_geometry_shader_handle(ctx->cso, NULL);

   /* drawing dest */
   memset(&fb, 0, sizeof(fb));
   fb.width = dst->width;
   fb.height = dst->height;
   fb.nr_cbufs = 1;
   fb.cbufs[0] = dst;
   cso_set_framebuffer(ctx->cso, &fb);

   /* draw quad */
   offset = setup_vertex_data_tex(ctx,
                                  src_sampler_view->texture->target,
                                  src_face,
                                  (float) dstX0 / dst->width * 2.0f - 1.0f,
                                  (float) dstY0 / dst->height * 2.0f - 1.0f,
                                  (float) dstX1 / dst->width * 2.0f - 1.0f,
                                  (float) dstY1 / dst->height * 2.0f - 1.0f,
                                  s0, t0, s1, t1,
                                  z);

   util_draw_vertex_buffer(ctx->pipe, ctx->cso, ctx->vbuf,
                           cso_get_aux_vertex_buffer_slot(ctx->cso),
                           offset,
                           PIPE_PRIM_TRIANGLE_FAN,
                           4,  /* verts */
                           2); /* attribs/vert */

   /* restore state we changed */
   cso_restore_blend(ctx->cso);
   cso_restore_depth_stencil_alpha(ctx->cso);
   cso_restore_rasterizer(ctx->cso);
   cso_restore_sample_mask(ctx->cso);
   cso_restore_min_samples(ctx->cso);
   cso_restore_samplers(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_restore_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_restore_viewport(ctx->cso);
   cso_restore_framebuffer(ctx->cso);
   cso_restore_fragment_shader(ctx->cso);
   cso_restore_vertex_shader(ctx->cso);
   cso_restore_geometry_shader(ctx->cso);
   cso_restore_vertex_elements(ctx->cso);
   cso_restore_aux_vertex_buffer_slot(ctx->cso);
   cso_restore_stream_outputs(ctx->cso);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d339 4
a342 4
 * \param filter  one of PIPE_TEX_FILTER_NEAREST/LINEAR
 * \param writemask  bitmask of PIPE_MASK_[RGBAZS].  Controls which channels
 *                   in the dest surface are sourced from the src surface.
 *                   Disabled color channels are sourced from (0,0,0,1).
d355 1
a355 1
                 uint writemask)
d367 2
a368 2
   assert(filter == PIPE_TEX_FILTER_NEAREST ||
          filter == PIPE_TEX_FILTER_LINEAR);
d386 2
a387 2
   blit_depth = is_depth && (writemask & PIPE_MASK_Z);
   blit_stencil = is_stencil && (writemask & PIPE_MASK_S);
d389 2
a390 9
   if (is_depth || is_stencil) {
      assert((writemask & PIPE_MASK_RGBA) == 0);
      assert(blit_depth || blit_stencil);
   }
   else {
      assert((writemask & PIPE_MASK_ZS) == 0);
      assert(!blit_depth);
      assert(!blit_stencil);
   }
d440 1
a440 1
   info.dst.format = dst_format;
d449 2
a450 2
   info.src.format = src_format;
   info.mask = writemask;
d489 2
a490 2
   assert(filter == PIPE_TEX_FILTER_NEAREST ||
          filter == PIPE_TEX_FILTER_LINEAR);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d339 4
a342 4
 * \param filter  one of PIPE_TEX_MIPFILTER_NEAREST/LINEAR
 * \param writemask  controls which channels in the dest surface are sourced
 *                   from the src surface.  Disabled channels are sourced
 *                   from (0,0,0,1).
d355 1
a355 1
                 uint writemask, uint zs_writemask)
d367 2
a368 2
   assert(filter == PIPE_TEX_MIPFILTER_NEAREST ||
          filter == PIPE_TEX_MIPFILTER_LINEAR);
d386 2
a387 2
   blit_depth = is_depth && (zs_writemask & BLIT_WRITEMASK_Z);
   blit_stencil = is_stencil && (zs_writemask & BLIT_WRITEMASK_STENCIL);
d389 9
a397 2
   assert((writemask && !zs_writemask && !is_depth && !is_stencil) ||
          (!writemask && (blit_depth || blit_stencil)));
d447 1
a447 1
   info.dst.format = dst->texture->format;
d456 2
a457 2
   info.src.format = src_tex->format;
   info.mask = writemask | (zs_writemask << 4);
d496 2
a497 2
   assert(filter == PIPE_TEX_MIPFILTER_NEAREST ||
          filter == PIPE_TEX_MIPFILTER_LINEAR);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d49 1
d60 1
a60 1
   struct pipe_blend_state blend_write_color, blend_keep_color;
a61 3
   struct pipe_depth_stencil_alpha_state dsa_write_depthstencil;
   struct pipe_depth_stencil_alpha_state dsa_write_depth;
   struct pipe_depth_stencil_alpha_state dsa_write_stencil;
a65 1
   enum pipe_texture_target internal_target;
a68 3
   void *fs_depthstencil[PIPE_MAX_TEXTURE_TYPES];
   void *fs_depth[PIPE_MAX_TEXTURE_TYPES];
   void *fs_stencil[PIPE_MAX_TEXTURE_TYPES];
a73 2

   boolean has_stencil_export;
a96 14
   /* depth stencil states */
   ctx->dsa_write_depth.depth.enabled = 1;
   ctx->dsa_write_depth.depth.writemask = 1;
   ctx->dsa_write_depth.depth.func = PIPE_FUNC_ALWAYS;
   ctx->dsa_write_stencil.stencil[0].enabled = 1;
   ctx->dsa_write_stencil.stencil[0].func = PIPE_FUNC_ALWAYS;
   ctx->dsa_write_stencil.stencil[0].fail_op = PIPE_STENCIL_OP_REPLACE;
   ctx->dsa_write_stencil.stencil[0].zpass_op = PIPE_STENCIL_OP_REPLACE;
   ctx->dsa_write_stencil.stencil[0].zfail_op = PIPE_STENCIL_OP_REPLACE;
   ctx->dsa_write_stencil.stencil[0].valuemask = 0xff;
   ctx->dsa_write_stencil.stencil[0].writemask = 0xff;
   ctx->dsa_write_depthstencil.depth = ctx->dsa_write_depth.depth;
   ctx->dsa_write_depthstencil.stencil[0] = ctx->dsa_write_stencil.stencil[0];

a123 1
      ctx->vertices[i][1][2] = 0.0f; /* r */
a126 8
   if(pipe->screen->get_param(pipe->screen, PIPE_CAP_NPOT_TEXTURES))
      ctx->internal_target = PIPE_TEXTURE_2D;
   else
      ctx->internal_target = PIPE_TEXTURE_RECT;

   ctx->has_stencil_export =
      pipe->screen->get_param(pipe->screen, PIPE_CAP_SHADER_STENCIL_EXPORT);

a149 12
   for (i = 0; i < PIPE_MAX_TEXTURE_TYPES; i++) {
      if (ctx->fs_depthstencil[i]) {
         pipe->delete_fs_state(pipe, ctx->fs_depthstencil[i]);
      }
      if (ctx->fs_depth[i]) {
         pipe->delete_fs_state(pipe, ctx->fs_depth[i]);
      }
      if (ctx->fs_stencil[i]) {
         pipe->delete_fs_state(pipe, ctx->fs_stencil[i]);
      }
   }

a176 57
 * Helper function to set the shader which writes depth and stencil.
 */
static INLINE void
set_depthstencil_fragment_shader(struct blit_state *ctx,
                                 enum pipe_texture_target pipe_tex)
{
   if (!ctx->fs_depthstencil[pipe_tex]) {
      unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex, 0);

      ctx->fs_depthstencil[pipe_tex] =
         util_make_fragment_tex_shader_writedepthstencil(ctx->pipe, tgsi_tex,
                                                  TGSI_INTERPOLATE_LINEAR);
   }

   cso_set_fragment_shader_handle(ctx->cso, ctx->fs_depthstencil[pipe_tex]);
}


/**
 * Helper function to set the shader which writes depth.
 */
static INLINE void
set_depth_fragment_shader(struct blit_state *ctx,
                          enum pipe_texture_target pipe_tex)
{
   if (!ctx->fs_depth[pipe_tex]) {
      unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex, 0);

      ctx->fs_depth[pipe_tex] =
         util_make_fragment_tex_shader_writedepth(ctx->pipe, tgsi_tex,
                                                  TGSI_INTERPOLATE_LINEAR);
   }

   cso_set_fragment_shader_handle(ctx->cso, ctx->fs_depth[pipe_tex]);
}


/**
 * Helper function to set the shader which writes stencil.
 */
static INLINE void
set_stencil_fragment_shader(struct blit_state *ctx,
                            enum pipe_texture_target pipe_tex)
{
   if (!ctx->fs_stencil[pipe_tex]) {
      unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex, 0);

      ctx->fs_stencil[pipe_tex] =
         util_make_fragment_tex_shader_writestencil(ctx->pipe, tgsi_tex,
                                                    TGSI_INTERPOLATE_LINEAR);
   }

   cso_set_fragment_shader_handle(ctx->cso, ctx->fs_stencil[pipe_tex]);
}


/**
d227 3
d233 2
d246 1
d253 1
d260 1
d267 11
a357 1
   struct pipe_screen *screen = pipe->screen;
a358 4
   struct pipe_sampler_view *sampler_view = NULL;
   struct pipe_sampler_view sv_templ;
   struct pipe_surface *dst_surface;
   struct pipe_framebuffer_state fb;
a360 1
   unsigned offset;
a361 2
   float s0, t0, s1, t1;
   boolean normalized;
d365 1
d393 6
d429 24
a452 101
   /* XXX Reading multisample textures is unimplemented. */
   assert(src_tex->nr_samples <= 1);
   if (src_tex->nr_samples > 1) {
      return;
   }

   /* It's a mistake to call this function with a stencil format and
    * without shader stencil export. We don't do software fallbacks here.
    * Ignore stencil and only copy depth.
    */
   if (blit_stencil && !ctx->has_stencil_export) {
      blit_stencil = FALSE;

      if (!blit_depth)
         return;
   }

   if (dst_format == dst->format) {
      dst_surface = dst;
   } else {
      struct pipe_surface templ = *dst;
      templ.format = dst_format;
      dst_surface = pipe->create_surface(pipe, dst->texture, &templ);
   }

   /* Create a temporary texture when src and dest alias.
    */
   if (src_tex == dst_surface->texture &&
       dst_surface->u.tex.level == src_level &&
       dst_surface->u.tex.first_layer == srcZ0) {
      /* Make a temporary texture which contains a copy of the source pixels.
       * Then we'll sample from the temporary texture.
       */
      struct pipe_resource texTemp;
      struct pipe_resource *tex;
      struct pipe_sampler_view sv_templ;
      struct pipe_box src_box;
      const int srcLeft = MIN2(srcX0, srcX1);
      const int srcTop = MIN2(srcY0, srcY1);

      if (srcLeft != srcX0) {
         /* left-right flip */
         int tmp = dstX0;
         dstX0 = dstX1;
         dstX1 = tmp;
      }

      if (srcTop != srcY0) {
         /* up-down flip */
         int tmp = dstY0;
         dstY0 = dstY1;
         dstY1 = tmp;
      }

      /* create temp texture */
      memset(&texTemp, 0, sizeof(texTemp));
      texTemp.target = ctx->internal_target;
      texTemp.format = src_format;
      texTemp.last_level = 0;
      texTemp.width0 = srcW;
      texTemp.height0 = srcH;
      texTemp.depth0 = 1;
      texTemp.array_size = 1;
      texTemp.bind = PIPE_BIND_SAMPLER_VIEW;

      tex = screen->resource_create(screen, &texTemp);
      if (!tex)
         return;

      src_box.x = srcLeft;
      src_box.y = srcTop;
      src_box.z = srcZ0;
      src_box.width = srcW;
      src_box.height = srcH;
      src_box.depth = 1;
      /* load temp texture */
      pipe->resource_copy_region(pipe,
                                 tex, 0, 0, 0, 0,  /* dest */
                                 src_tex, src_level, &src_box);

      normalized = tex->target != PIPE_TEXTURE_RECT;
      if(normalized) {
         s0 = 0.0f;
         s1 = 1.0f;
         t0 = 0.0f;
         t1 = 1.0f;
      }
      else {
         s0 = 0.0f;
         s1 = (float) srcW;
         t0 = 0.0f;
         t1 = (float) srcH;
      }

      u_sampler_view_default_template(&sv_templ, tex, tex->format);
      if (!blit_depth && blit_stencil) {
         /* set a stencil-only format, e.g. Z24S8 --> X24S8 */
         sv_templ.format = util_format_stencil_only(tex->format);
         assert(sv_templ.format != PIPE_FORMAT_NONE);
      }
      sampler_view = pipe->create_sampler_view(pipe, tex, &sv_templ);
d454 1
a454 197
      if (!sampler_view) {
         pipe_resource_reference(&tex, NULL);
         return;
      }
      pipe_resource_reference(&tex, NULL);
   }
   else {
      /* Directly sample from the source resource/texture */
      u_sampler_view_default_template(&sv_templ, src_tex, src_format);
      if (!blit_depth && blit_stencil) {
         /* set a stencil-only format, e.g. Z24S8 --> X24S8 */
         sv_templ.format = util_format_stencil_only(src_format);
         assert(sv_templ.format != PIPE_FORMAT_NONE);
      }
      sampler_view = pipe->create_sampler_view(pipe, src_tex, &sv_templ);

      if (!sampler_view) {
         return;
      }

      s0 = (float) srcX0;
      s1 = (float) srcX1;
      t0 = (float) srcY0;
      t1 = (float) srcY1;
      normalized = sampler_view->texture->target != PIPE_TEXTURE_RECT;
      if(normalized)
      {
         s0 /= (float)(u_minify(sampler_view->texture->width0, src_level));
         s1 /= (float)(u_minify(sampler_view->texture->width0, src_level));
         t0 /= (float)(u_minify(sampler_view->texture->height0, src_level));
         t1 /= (float)(u_minify(sampler_view->texture->height0, src_level));
      }
   }

   assert(screen->is_format_supported(screen, sampler_view->format,
                     ctx->internal_target, sampler_view->texture->nr_samples,
                     PIPE_BIND_SAMPLER_VIEW));
   assert(screen->is_format_supported(screen, dst_format, ctx->internal_target,
                     dst_surface->texture->nr_samples,
                     is_depth || is_stencil ? PIPE_BIND_DEPTH_STENCIL :
                                              PIPE_BIND_RENDER_TARGET));

   /* save state (restored below) */
   cso_save_blend(ctx->cso);
   cso_save_depth_stencil_alpha(ctx->cso);
   cso_save_rasterizer(ctx->cso);
   cso_save_sample_mask(ctx->cso);
   cso_save_samplers(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_save_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_save_stream_outputs(ctx->cso);
   cso_save_viewport(ctx->cso);
   cso_save_framebuffer(ctx->cso);
   cso_save_fragment_shader(ctx->cso);
   cso_save_vertex_shader(ctx->cso);
   cso_save_geometry_shader(ctx->cso);
   cso_save_vertex_elements(ctx->cso);
   cso_save_aux_vertex_buffer_slot(ctx->cso);
   cso_save_render_condition(ctx->cso);

   /* set misc state we care about */
   if (writemask)
      cso_set_blend(ctx->cso, &ctx->blend_write_color);
   else
      cso_set_blend(ctx->cso, &ctx->blend_keep_color);

   cso_set_sample_mask(ctx->cso, ~0);
   cso_set_rasterizer(ctx->cso, &ctx->rasterizer);
   cso_set_vertex_elements(ctx->cso, 2, ctx->velem);
   cso_set_stream_outputs(ctx->cso, 0, NULL, 0);
   cso_set_render_condition(ctx->cso, NULL, FALSE, 0);

   /* default sampler state */
   ctx->sampler.normalized_coords = normalized;
   ctx->sampler.min_img_filter = filter;
   ctx->sampler.mag_img_filter = filter;
   ctx->sampler.min_lod = (float) src_level;
   ctx->sampler.max_lod = (float) src_level;

   /* Depth stencil state, fragment shader and sampler setup depending on what
    * we blit.
    */
   if (blit_depth && blit_stencil) {
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);
      /* don't filter stencil */
      ctx->sampler.min_img_filter = PIPE_TEX_FILTER_NEAREST;
      ctx->sampler.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 1, &ctx->sampler);

      cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_write_depthstencil);
      set_depthstencil_fragment_shader(ctx, sampler_view->texture->target);
   }
   else if (blit_depth) {
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);
      cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_write_depth);
      set_depth_fragment_shader(ctx, sampler_view->texture->target);
   }
   else if (blit_stencil) {
      /* don't filter stencil */
      ctx->sampler.min_img_filter = PIPE_TEX_FILTER_NEAREST;
      ctx->sampler.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);

      cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_write_stencil);
      set_stencil_fragment_shader(ctx, sampler_view->texture->target);
   }
   else { /* color */
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);
      cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_keep_depthstencil);
      set_fragment_shader(ctx, writemask, sampler_view->texture->target);
   }
   cso_single_sampler_done(ctx->cso, PIPE_SHADER_FRAGMENT);

   /* textures */
   if (blit_depth && blit_stencil) {
      /* Setup two samplers, one for depth and the other one for stencil. */
      struct pipe_sampler_view templ;
      struct pipe_sampler_view *views[2];

      templ = *sampler_view;
      templ.format = util_format_stencil_only(templ.format);
      assert(templ.format != PIPE_FORMAT_NONE);

      views[0] = sampler_view;
      views[1] = pipe->create_sampler_view(pipe, views[0]->texture, &templ);
      cso_set_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT, 2, views);

      pipe_sampler_view_reference(&views[1], NULL);
   }
   else {
      cso_set_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT, 1, &sampler_view);
   }

   /* viewport */
   ctx->viewport.scale[0] = 0.5f * dst_surface->width;
   ctx->viewport.scale[1] = 0.5f * dst_surface->height;
   ctx->viewport.scale[2] = 0.5f;
   ctx->viewport.scale[3] = 1.0f;
   ctx->viewport.translate[0] = 0.5f * dst_surface->width;
   ctx->viewport.translate[1] = 0.5f * dst_surface->height;
   ctx->viewport.translate[2] = 0.5f;
   ctx->viewport.translate[3] = 0.0f;
   cso_set_viewport(ctx->cso, &ctx->viewport);

   set_vertex_shader(ctx);
   cso_set_geometry_shader_handle(ctx->cso, NULL);

   /* drawing dest */
   memset(&fb, 0, sizeof(fb));
   fb.width = dst_surface->width;
   fb.height = dst_surface->height;
   if (blit_depth || blit_stencil) {
      fb.zsbuf = dst_surface;
   } else {
      fb.nr_cbufs = 1;
      fb.cbufs[0] = dst_surface;
   }
   cso_set_framebuffer(ctx->cso, &fb);

   /* draw quad */
   offset = setup_vertex_data_tex(ctx,
                                  (float) dstX0 / dst_surface->width * 2.0f - 1.0f,
                                  (float) dstY0 / dst_surface->height * 2.0f - 1.0f,
                                  (float) dstX1 / dst_surface->width * 2.0f - 1.0f,
                                  (float) dstY1 / dst_surface->height * 2.0f - 1.0f,
                                  s0, t0,
                                  s1, t1,
                                  z);

   if (ctx->vbuf) {
      util_draw_vertex_buffer(ctx->pipe, ctx->cso, ctx->vbuf,
                              cso_get_aux_vertex_buffer_slot(ctx->cso),
                              offset,
                              PIPE_PRIM_TRIANGLE_FAN,
                              4,  /* verts */
                              2); /* attribs/vert */
   }

   /* restore state we changed */
   cso_restore_blend(ctx->cso);
   cso_restore_depth_stencil_alpha(ctx->cso);
   cso_restore_rasterizer(ctx->cso);
   cso_restore_sample_mask(ctx->cso);
   cso_restore_samplers(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_restore_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_restore_viewport(ctx->cso);
   cso_restore_framebuffer(ctx->cso);
   cso_restore_fragment_shader(ctx->cso);
   cso_restore_vertex_shader(ctx->cso);
   cso_restore_geometry_shader(ctx->cso);
   cso_restore_vertex_elements(ctx->cso);
   cso_restore_aux_vertex_buffer_slot(ctx->cso);
   cso_restore_stream_outputs(ctx->cso);
   cso_restore_render_condition(ctx->cso);

   pipe_sampler_view_reference(&sampler_view, NULL);
   if (dst_surface != dst)
      pipe_surface_reference(&dst_surface, NULL);
d459 2
a460 1
 * Copy pixel block from src texture to dst surface.
d463 8
a470 1
 * XXX need some control over blitting Z and/or stencil.
d477 1
d523 1
d539 1
d542 1
a542 1
   cso_set_stream_outputs(ctx->cso, 0, NULL, 0);
d581 2
d602 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d59 5
a63 3
   struct pipe_blend_state blend;
   struct pipe_depth_stencil_alpha_state depthstencil_keep;
   struct pipe_depth_stencil_alpha_state depthstencil_write;
a66 1
   struct pipe_clip_state clip;
d71 4
a74 2
   void *fs[TGSI_WRITEMASK_XYZW + 1];
   void *fs_depth;
d80 2
d103 1
a103 2
   memset(&ctx->blend, 0, sizeof(ctx->blend));
   ctx->blend.rt[0].colormask = PIPE_MASK_RGBA;
d105 13
a117 6
   /* no-op depth/stencil/alpha */
   memset(&ctx->depthstencil_keep, 0, sizeof(ctx->depthstencil_keep));
   memset(&ctx->depthstencil_write, 0, sizeof(ctx->depthstencil_write));
   ctx->depthstencil_write.depth.enabled = 1;
   ctx->depthstencil_write.depth.writemask = 1;
   ctx->depthstencil_write.depth.func = PIPE_FUNC_ALWAYS;
a119 1
   memset(&ctx->rasterizer, 0, sizeof(ctx->rasterizer));
d121 3
a123 1
   ctx->rasterizer.gl_rasterization_rules = 1;
a125 1
   memset(&ctx->sampler, 0, sizeof(ctx->sampler));
a133 1
   memset(&ctx->velem[0], 0, sizeof(ctx->velem[0]) * 2);
d137 1
a137 1
      ctx->velem[i].vertex_buffer_index = 0;
d155 3
d169 1
a169 1
   unsigned i;
d174 6
a179 3
   for (i = 0; i < Elements(ctx->fs); i++)
      if (ctx->fs[i])
         pipe->delete_fs_state(pipe, ctx->fs[i]);
d181 11
a191 2
   if (ctx->fs_depth)
      pipe->delete_fs_state(pipe, ctx->fs_depth);
d203 2
a204 1
set_fragment_shader(struct blit_state *ctx, uint writemask)
d206 5
a210 3
   if (!ctx->fs[writemask])
      ctx->fs[writemask] =
         util_make_fragment_tex_shader_writemask(ctx->pipe, TGSI_TEXTURE_2D,
d213 1
d215 1
a215 1
   cso_set_fragment_shader_handle(ctx->cso, ctx->fs[writemask]);
d220 1
a220 1
 * Helper function to set the depthwrite shader.
d223 2
a224 1
set_depth_fragment_shader(struct blit_state *ctx)
d226 5
a230 3
   if (!ctx->fs_depth)
      ctx->fs_depth =
         util_make_fragment_tex_shader_writedepth(ctx->pipe, TGSI_TEXTURE_2D,
d232 34
d267 6
a272 1
   cso_set_fragment_shader_handle(ctx->cso, ctx->fs_depth);
d306 4
a309 2
   if (ctx->vbuf_slot >= max_slots) 
      util_blit_flush( ctx );
d362 4
a365 2
   pipe_buffer_write_nooverlap(ctx->pipe, ctx->vbuf,
                               offset, sizeof(ctx->vertices), ctx->vertices);
d397 20
a423 1
 * XXX need some control over blitting stencil.
d426 11
a436 11
util_blit_pixels_writemask(struct blit_state *ctx,
                           struct pipe_resource *src_tex,
                           unsigned src_level,
                           int srcX0, int srcY0,
                           int srcX1, int srcY1,
                           int srcZ0,
                           struct pipe_surface *dst,
                           int dstX0, int dstY0,
                           int dstX1, int dstY1,
                           float z, uint filter,
                           uint writemask)
d448 1
a448 1
   boolean overlap, dst_is_depth;
d451 3
d468 11
a478 1
   dst_format = util_format_linear(dst->format);
d482 1
a482 1
    * no overlapping.
d485 4
a488 1
   if (dst_format == src_format &&
d508 18
a525 1
       return;
d536 1
a536 6
   /* Create a temporary texture when src and dest alias or when src
    * is anything other than a 2d texture.
    * XXX should just use appropriate shader to access 1d / 3d slice / cube face,
    * much like the u_blitter code does (should be pretty trivial).
    * 
    * This can still be improved upon.
d538 1
a538 1
   if ((src_tex == dst_surface->texture &&
d540 4
a543 5
       dst_surface->u.tex.first_layer == srcZ0) ||
       (src_tex->target != PIPE_TEXTURE_2D &&
       src_tex->target != PIPE_TEXTURE_2D &&
       src_tex->target != PIPE_TEXTURE_RECT))
   {
d599 4
a602 4
         s0 = 0;
         s1 = srcW;
         t0 = 0;
         t1 = srcH;
d606 5
d620 1
d622 5
d633 4
a636 4
      s0 = srcX0;
      s1 = srcX1;
      t0 = srcY0;
      t1 = srcY1;
d647 7
a653 1
   dst_is_depth = util_format_is_depth_or_stencil(dst_format);
a654 7
   assert(screen->is_format_supported(screen, sampler_view->format, ctx->internal_target,
                                      sampler_view->texture->nr_samples,
                                      PIPE_BIND_SAMPLER_VIEW));
   assert(screen->is_format_supported(screen, dst_format, ctx->internal_target,
                                      dst_surface->texture->nr_samples,
                                      dst_is_depth ? PIPE_BIND_DEPTH_STENCIL :
                                                     PIPE_BIND_RENDER_TARGET));
d659 4
a662 2
   cso_save_samplers(ctx->cso);
   cso_save_fragment_sampler_views(ctx->cso);
d667 1
a667 1
   cso_save_clip(ctx->cso);
d669 2
a670 1
   cso_save_vertex_buffers(ctx->cso);
d673 6
a678 4
   cso_set_blend(ctx->cso, &ctx->blend);
   cso_set_depth_stencil_alpha(ctx->cso,
                               dst_is_depth ? &ctx->depthstencil_write :
                                              &ctx->depthstencil_keep);
a679 1
   cso_set_clip(ctx->cso, &ctx->clip);
d681 2
d684 1
a684 1
   /* sampler */
d688 56
a743 4
   ctx->sampler.min_lod = src_level;
   ctx->sampler.max_lod = src_level;
   cso_single_sampler(ctx->cso, 0, &ctx->sampler);
   cso_single_sampler_done(ctx->cso);
a755 9
   /* texture */
   cso_set_fragment_sampler_views(ctx->cso, 1, &sampler_view);

   /* shaders */
   if (dst_is_depth) {
      set_depth_fragment_shader(ctx);
   } else {
      set_fragment_shader(ctx, writemask);
   }
d757 1
d763 1
a763 1
   if (dst_is_depth) {
d781 8
a788 4
   util_draw_vertex_buffer(ctx->pipe, ctx->cso, ctx->vbuf, offset,
                           PIPE_PRIM_TRIANGLE_FAN,
                           4,  /* verts */
                           2); /* attribs/vert */
d794 3
a796 2
   cso_restore_samplers(ctx->cso);
   cso_restore_fragment_sampler_views(ctx->cso);
d801 1
a801 1
   cso_restore_clip(ctx->cso);
d803 3
a805 1
   cso_restore_vertex_buffers(ctx->cso);
a812 36
void
util_blit_pixels(struct blit_state *ctx,
                 struct pipe_resource *src_tex,
                 unsigned src_level,
                 int srcX0, int srcY0,
                 int srcX1, int srcY1,
                 int srcZ,
                 struct pipe_surface *dst,
                 int dstX0, int dstY0,
                 int dstX1, int dstY1,
                 float z, uint filter )
{
   util_blit_pixels_writemask( ctx, src_tex,
                               src_level,
                               srcX0, srcY0,
                               srcX1, srcY1,
                               srcZ,
                               dst,
                               dstX0, dstY0,
                               dstX1, dstY1,
                               z, filter,
                               TGSI_WRITEMASK_XYZW );
}


/* Release vertex buffer at end of frame to avoid synchronous
 * rendering.
 */
void util_blit_flush( struct blit_state *ctx )
{
   pipe_resource_reference(&ctx->vbuf, NULL);
   ctx->vbuf_slot = 0;
} 



d815 2
a816 2
 *
 * XXX Should support selection of level.
d842 4
a845 4
   s0 = srcX0;
   s1 = srcX1;
   t0 = srcY0;
   t1 = srcY1;
d849 8
a856 4
      s0 /= (float)tex->width0;
      s1 /= (float)tex->width0;
      t0 /= (float)tex->height0;
      t1 /= (float)tex->height0;
d868 4
a871 2
   cso_save_samplers(ctx->cso);
   cso_save_fragment_sampler_views(ctx->cso);
d876 1
a876 1
   cso_save_clip(ctx->cso);
d878 1
a878 1
   cso_save_vertex_buffers(ctx->cso);
d881 3
a883 2
   cso_set_blend(ctx->cso, &ctx->blend);
   cso_set_depth_stencil_alpha(ctx->cso, &ctx->depthstencil_keep);
a884 1
   cso_set_clip(ctx->cso, &ctx->clip);
d886 1
d892 2
a893 2
   cso_single_sampler(ctx->cso, 0, &ctx->sampler);
   cso_single_sampler_done(ctx->cso);
d907 1
a907 1
   cso_set_fragment_sampler_views(ctx->cso, 1, &src_sampler_view);
d910 2
a911 1
   set_fragment_shader(ctx, TGSI_WRITEMASK_XYZW);
d913 1
d932 3
a934 2
   util_draw_vertex_buffer(ctx->pipe, ctx->cso,
                           ctx->vbuf, offset,
d943 3
a945 2
   cso_restore_samplers(ctx->cso);
   cso_restore_fragment_sampler_views(ctx->cso);
d950 1
a950 1
   cso_restore_clip(ctx->cso);
d952 2
a953 1
   cso_restore_vertex_buffers(ctx->cso);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a130 15
   /* vertex shader - still required to provide the linkage between
    * fragment shader input semantics and vertex_element/buffers.
    */
   {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indexes[] = { 0, 0 };
      ctx->vs = util_make_vertex_passthrough_shader(pipe, 2, semantic_names,
                                                    semantic_indexes);
   }

   /* fragment shader */
   ctx->fs[TGSI_WRITEMASK_XYZW] =
      util_make_fragment_tex_shader(pipe, TGSI_TEXTURE_2D,
                                    TGSI_INTERPOLATE_LINEAR);
d158 2
a159 1
   pipe->delete_vs_state(pipe, ctx->vs);
d175 53
d241 1
d346 1
d349 1
d370 3
d378 1
a378 1
   if (dst->format == src_tex->format &&
d401 8
d416 3
a418 3
   if ((src_tex == dst->texture &&
       dst->u.tex.level == src_level &&
       dst->u.tex.first_layer == srcZ0) ||
d447 1
a447 1
      texTemp.format = src_tex->format;
d494 1
a494 1
      u_sampler_view_default_template(&sv_templ, src_tex, src_tex->format);
d515 1
a515 1
   dst_is_depth = util_format_is_depth_or_stencil(dst->format);
d519 3
a521 3
                                      PIPE_BIND_SAMPLER_VIEW, 0));
   assert(screen->is_format_supported(screen, dst->format, ctx->internal_target,
                                      dst->texture->nr_samples,
d523 1
a523 1
                                                     PIPE_BIND_RENDER_TARGET, 0));
d536 1
d557 2
a558 2
   ctx->viewport.scale[0] = 0.5f * dst->width;
   ctx->viewport.scale[1] = 0.5f * dst->height;
d561 2
a562 2
   ctx->viewport.translate[0] = 0.5f * dst->width;
   ctx->viewport.translate[1] = 0.5f * dst->height;
d572 1
a572 6
      if (ctx->fs_depth == NULL)
         ctx->fs_depth =
            util_make_fragment_tex_shader_writedepth(pipe, TGSI_TEXTURE_2D,
                                                     TGSI_INTERPOLATE_LINEAR);

      cso_set_fragment_shader_handle(ctx->cso, ctx->fs_depth);
d574 1
a574 7
      if (ctx->fs[writemask] == NULL)
         ctx->fs[writemask] =
            util_make_fragment_tex_shader_writemask(pipe, TGSI_TEXTURE_2D,
                                                    TGSI_INTERPOLATE_LINEAR,
                                                    writemask);

      cso_set_fragment_shader_handle(ctx->cso, ctx->fs[writemask]);
d576 1
a576 1
   cso_set_vertex_shader_handle(ctx->cso, ctx->vs);
d580 2
a581 2
   fb.width = dst->width;
   fb.height = dst->height;
d583 1
a583 1
      fb.zsbuf = dst;
d586 1
a586 1
      fb.cbufs[0] = dst;
d592 4
a595 4
                                  (float) dstX0 / dst->width * 2.0f - 1.0f,
                                  (float) dstY0 / dst->height * 2.0f - 1.0f,
                                  (float) dstX1 / dst->width * 2.0f - 1.0f,
                                  (float) dstY1 / dst->height * 2.0f - 1.0f,
d600 1
a600 1
   util_draw_vertex_buffer(ctx->pipe, ctx->vbuf, offset,
d617 1
d620 2
d706 1
a706 2
                                                 PIPE_BIND_RENDER_TARGET,
                                                 0));
d720 1
d751 2
a752 2
   cso_set_fragment_shader_handle(ctx->cso, ctx->fs[TGSI_WRITEMASK_XYZW]);
   cso_set_vertex_shader_handle(ctx->cso, ctx->vs);
d771 1
a771 1
   util_draw_vertex_buffer(ctx->pipe, 
d789 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d48 1
a49 2
#include "util/u_surface.h"
#include "util/u_rect.h"
d60 2
a61 1
   struct pipe_depth_stencil_alpha_state depthstencil;
d66 2
d71 1
d73 1
a73 1
   struct pipe_buffer *vbuf;  /**< quad vertices */
d102 5
a106 1
   memset(&ctx->depthstencil, 0, sizeof(ctx->depthstencil));
d110 1
a110 2
   ctx->rasterizer.front_winding = PIPE_WINDING_CW;
   ctx->rasterizer.cull_mode = PIPE_WINDING_NONE;
d121 9
a129 1
   ctx->sampler.normalized_coords = 1;
d144 2
a145 1
      util_make_fragment_tex_shader(pipe, TGSI_TEXTURE_2D);
d155 5
d179 4
a182 1
   pipe_buffer_reference(&ctx->vbuf, NULL);
d201 1
a201 2
                                     32,
                                     PIPE_BUFFER_USAGE_VERTEX,
a206 1
                               
d249 1
a249 1
   pipe_buffer_write_nooverlap(ctx->pipe->screen, ctx->vbuf,
d289 1
a289 1
 * XXX need some control over blitting Z and/or stencil.
d293 2
a294 1
                           struct pipe_surface *src,
d297 1
d306 2
a307 1
   struct pipe_texture *tex = NULL;
d312 1
a312 1
   boolean overlap;
d314 1
d319 1
a319 4
   assert(screen->is_format_supported(screen, src->format, PIPE_TEXTURE_2D,
                                      PIPE_TEXTURE_USAGE_SAMPLER, 0));
   assert(screen->is_format_supported(screen, dst->format, PIPE_TEXTURE_2D,
                                      PIPE_TEXTURE_USAGE_RENDER_TARGET, 0));
d322 3
a324 1
   overlap = util_same_surface(src, dst) &&
d333 1
a333 2
   if (pipe->surface_copy &&
       dst->format == src->format &&
d341 13
a353 5
      pipe->surface_copy(pipe,
			 dst, dstX0, dstY0, /* dest */
			 src, srcX0, srcY0, /* src */
			 srcW, srcH);       /* size */
      return;
a354 3
   
   assert(screen->is_format_supported(screen, dst->format, PIPE_TEXTURE_2D,
                                      PIPE_TEXTURE_USAGE_RENDER_TARGET, 0));
d357 3
a359 1
    * is anything other than a single-level 2d texture.
d363 6
a368 3
   if (util_same_surface(src, dst) ||
       src->texture->target != PIPE_TEXTURE_2D ||
       src->texture->last_level != 0)
d370 4
a373 2
      struct pipe_texture texTemp;
      struct pipe_surface *texSurf;
d393 2
a394 2
      texTemp.target = PIPE_TEXTURE_2D;
      texTemp.format = src->format;
d399 2
d402 1
a402 1
      tex = screen->texture_create(screen, &texTemp);
d406 6
a411 3
      texSurf = screen->get_tex_surface(screen, tex, 0, 0, 0, 
                                        PIPE_BUFFER_USAGE_GPU_WRITE);

d413 10
a422 10
      if (pipe->surface_copy) {
         pipe->surface_copy(pipe,
                            texSurf, 0, 0,   /* dest */
                            src, srcLeft, srcTop, /* src */
                            srcW, srcH);     /* size */
      } else {
         util_surface_copy(pipe, FALSE,
                           texSurf, 0, 0,   /* dest */
                           src, srcLeft, srcTop, /* src */
                           srcW, srcH);     /* size */
d424 9
d434 5
a438 7
      /* free the surface, update the texture if necessary.
       */
      pipe_surface_reference(&texSurf, NULL);
      s0 = 0.0f; 
      s1 = 1.0f;
      t0 = 0.0f;
      t1 = 1.0f;
d441 19
a459 5
      pipe_texture_reference(&tex, src->texture);
      s0 = srcX0 / (float)tex->width0;
      s1 = srcX1 / (float)tex->width0;
      t0 = srcY0 / (float)tex->height0;
      t1 = srcY1 / (float)tex->height0;
d462 1
d464 7
d476 1
a476 1
   cso_save_sampler_textures(ctx->cso);
d482 1
d486 3
a488 1
   cso_set_depth_stencil_alpha(ctx->cso, &ctx->depthstencil);
d491 1
d494 1
d497 2
d514 1
a514 1
   cso_set_sampler_textures(ctx->cso, 1, &tex);
d516 14
a529 4
   if (ctx->fs[writemask] == NULL)
      ctx->fs[writemask] =
         util_make_fragment_tex_shader_writemask(pipe, TGSI_TEXTURE_2D,
                                                 writemask);
d531 2
a532 2
   /* shaders */
   cso_set_fragment_shader_handle(ctx->cso, ctx->fs[writemask]);
d539 6
a544 2
   fb.nr_cbufs = 1;
   fb.cbufs[0] = dst;
d567 1
a567 1
   cso_restore_sampler_textures(ctx->cso);
d573 1
d575 1
a575 1
   pipe_texture_reference(&tex, NULL);
d581 2
a582 1
                 struct pipe_surface *src,
d585 1
d591 2
a592 1
   util_blit_pixels_writemask( ctx, src, 
d595 1
d609 1
a609 1
   pipe_buffer_reference(&ctx->vbuf, NULL);
a616 1
 * Overlapping regions are acceptable.
d623 7
a629 7
                 struct pipe_texture *tex,
                 int srcX0, int srcY0,
                 int srcX1, int srcY1,
                 struct pipe_surface *dst,
                 int dstX0, int dstY0,
                 int dstX1, int dstY1,
                 float z, uint filter)
d631 1
d635 1
d640 1
d644 12
a655 4
   s0 = srcX0 / (float)tex->width0;
   s1 = srcX1 / (float)tex->width0;
   t0 = srcY0 / (float)tex->height0;
   t1 = srcY1 / (float)tex->height0;
d659 2
a660 1
                                                 PIPE_TEXTURE_USAGE_RENDER_TARGET,
d668 2
a669 1
   cso_save_sampler_textures(ctx->cso);
d674 1
d678 1
a678 1
   cso_set_depth_stencil_alpha(ctx->cso, &ctx->depthstencil);
d681 1
d684 1
d702 1
a702 1
   cso_set_sampler_textures(ctx->cso, 1, &tex);
d736 2
a737 1
   cso_restore_sampler_textures(ctx->cso);
d742 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a47 1
#include "util/u_sampler.h"
d49 2
d61 1
a61 2
   struct pipe_depth_stencil_alpha_state depthstencil_keep;
   struct pipe_depth_stencil_alpha_state depthstencil_write;
a65 2
   struct pipe_vertex_element velem[2];
   enum pipe_texture_target internal_target;
a68 1
   void *fs_depth;
d70 1
a70 1
   struct pipe_resource *vbuf;  /**< quad vertices */
d99 1
a99 5
   memset(&ctx->depthstencil_keep, 0, sizeof(ctx->depthstencil_keep));
   memset(&ctx->depthstencil_write, 0, sizeof(ctx->depthstencil_write));
   ctx->depthstencil_write.depth.enabled = 1;
   ctx->depthstencil_write.depth.writemask = 1;
   ctx->depthstencil_write.depth.func = PIPE_FUNC_ALWAYS;
d103 2
a104 1
   ctx->rasterizer.cull_face = PIPE_FACE_NONE;
d115 1
a115 9

   /* vertex elements state */
   memset(&ctx->velem[0], 0, sizeof(ctx->velem[0]) * 2);
   for (i = 0; i < 2; i++) {
      ctx->velem[i].src_offset = i * 4 * sizeof(float);
      ctx->velem[i].instance_divisor = 0;
      ctx->velem[i].vertex_buffer_index = 0;
      ctx->velem[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
   }
d130 1
a130 2
      util_make_fragment_tex_shader(pipe, TGSI_TEXTURE_2D,
                                    TGSI_INTERPOLATE_LINEAR);
a139 5
   if(pipe->screen->get_param(pipe->screen, PIPE_CAP_NPOT_TEXTURES))
      ctx->internal_target = PIPE_TEXTURE_2D;
   else
      ctx->internal_target = PIPE_TEXTURE_RECT;

d159 1
a159 4
   if (ctx->fs_depth)
      pipe->delete_fs_state(pipe, ctx->fs_depth);

   pipe_resource_reference(&ctx->vbuf, NULL);
d178 2
a179 1
                                     PIPE_BIND_VERTEX_BUFFER,
d185 1
d228 1
a228 1
   pipe_buffer_write_nooverlap(ctx->pipe, ctx->vbuf,
d268 1
a268 1
 * XXX need some control over blitting stencil.
d272 1
a272 2
                           struct pipe_resource *src_tex,
                           unsigned src_level,
a274 1
                           int srcZ0,
d283 1
a283 2
   struct pipe_sampler_view *sampler_view = NULL;
   struct pipe_sampler_view sv_templ;
d288 1
a288 1
   boolean overlap, dst_is_depth;
a289 1
   boolean normalized;
d294 4
a297 1
   assert(src_level <= src_tex->last_level);
d300 1
a300 3
   overlap = src_tex == dst->texture &&
             dst->u.tex.level == src_level &&
             dst->u.tex.first_layer == srcZ0 &&
d309 2
a310 1
   if (dst->format == src_tex->format &&
d318 5
a322 13
      struct pipe_box src_box;
      src_box.x = srcX0;
      src_box.y = srcY0;
      src_box.z = srcZ0;
      src_box.width = srcW;
      src_box.height = srcH;
      src_box.depth = 1;
      pipe->resource_copy_region(pipe,
                                 dst->texture, dst->u.tex.level,
                                 dstX0, dstY0, dst->u.tex.first_layer,/* dest */
                                 src_tex, src_level,
                                 &src_box);
       return;
d324 3
d329 1
a329 3
    * is anything other than a 2d texture.
    * XXX should just use appropriate shader to access 1d / 3d slice / cube face,
    * much like the u_blitter code does (should be pretty trivial).
d333 3
a335 6
   if ((src_tex == dst->texture &&
       dst->u.tex.level == src_level &&
       dst->u.tex.first_layer == srcZ0) ||
       (src_tex->target != PIPE_TEXTURE_2D &&
       src_tex->target != PIPE_TEXTURE_2D &&
       src_tex->target != PIPE_TEXTURE_RECT))
d337 2
a338 4
      struct pipe_resource texTemp;
      struct pipe_resource *tex;
      struct pipe_sampler_view sv_templ;
      struct pipe_box src_box;
d358 2
a359 2
      texTemp.target = ctx->internal_target;
      texTemp.format = src_tex->format;
a363 2
      texTemp.array_size = 1;
      texTemp.bind = PIPE_BIND_SAMPLER_VIEW;
d365 1
a365 1
      tex = screen->resource_create(screen, &texTemp);
d369 3
a371 6
      src_box.x = srcLeft;
      src_box.y = srcTop;
      src_box.z = srcZ0;
      src_box.width = srcW;
      src_box.height = srcH;
      src_box.depth = 1;
d373 10
a382 10
      pipe->resource_copy_region(pipe,
                                 tex, 0, 0, 0, 0,  /* dest */
                                 src_tex, src_level, &src_box);

      normalized = tex->target != PIPE_TEXTURE_RECT;
      if(normalized) {
         s0 = 0.0f;
         s1 = 1.0f;
         t0 = 0.0f;
         t1 = 1.0f;
a383 9
      else {
         s0 = 0;
         s1 = srcW;
         t0 = 0;
         t1 = srcH;
      }

      u_sampler_view_default_template(&sv_templ, tex, tex->format);
      sampler_view = pipe->create_sampler_view(pipe, tex, &sv_templ);
d385 7
a391 5
      if (!sampler_view) {
         pipe_resource_reference(&tex, NULL);
         return;
      }
      pipe_resource_reference(&tex, NULL);
d394 5
a398 19
      u_sampler_view_default_template(&sv_templ, src_tex, src_tex->format);
      sampler_view = pipe->create_sampler_view(pipe, src_tex, &sv_templ);

      if (!sampler_view) {
         return;
      }

      s0 = srcX0;
      s1 = srcX1;
      t0 = srcY0;
      t1 = srcY1;
      normalized = sampler_view->texture->target != PIPE_TEXTURE_RECT;
      if(normalized)
      {
         s0 /= (float)(u_minify(sampler_view->texture->width0, src_level));
         s1 /= (float)(u_minify(sampler_view->texture->width0, src_level));
         t0 /= (float)(u_minify(sampler_view->texture->height0, src_level));
         t1 /= (float)(u_minify(sampler_view->texture->height0, src_level));
      }
a400 1
   dst_is_depth = util_format_is_depth_or_stencil(dst->format);
a401 7
   assert(screen->is_format_supported(screen, sampler_view->format, ctx->internal_target,
                                      sampler_view->texture->nr_samples,
                                      PIPE_BIND_SAMPLER_VIEW, 0));
   assert(screen->is_format_supported(screen, dst->format, ctx->internal_target,
                                      dst->texture->nr_samples,
                                      dst_is_depth ? PIPE_BIND_DEPTH_STENCIL :
                                                     PIPE_BIND_RENDER_TARGET, 0));
d407 1
a407 1
   cso_save_fragment_sampler_views(ctx->cso);
a412 1
   cso_save_vertex_elements(ctx->cso);
d416 1
a416 3
   cso_set_depth_stencil_alpha(ctx->cso,
                               dst_is_depth ? &ctx->depthstencil_write :
                                              &ctx->depthstencil_keep);
a418 1
   cso_set_vertex_elements(ctx->cso, 2, ctx->velem);
a420 1
   ctx->sampler.normalized_coords = normalized;
a422 2
   ctx->sampler.min_lod = src_level;
   ctx->sampler.max_lod = src_level;
d438 6
a443 1
   cso_set_fragment_sampler_views(ctx->cso, 1, &sampler_view);
d446 1
a446 16
   if (dst_is_depth) {
      if (ctx->fs_depth == NULL)
         ctx->fs_depth =
            util_make_fragment_tex_shader_writedepth(pipe, TGSI_TEXTURE_2D,
                                                     TGSI_INTERPOLATE_LINEAR);

      cso_set_fragment_shader_handle(ctx->cso, ctx->fs_depth);
   } else {
      if (ctx->fs[writemask] == NULL)
         ctx->fs[writemask] =
            util_make_fragment_tex_shader_writemask(pipe, TGSI_TEXTURE_2D,
                                                    TGSI_INTERPOLATE_LINEAR,
                                                    writemask);

      cso_set_fragment_shader_handle(ctx->cso, ctx->fs[writemask]);
   }
d453 2
a454 6
   if (dst_is_depth) {
      fb.zsbuf = dst;
   } else {
      fb.nr_cbufs = 1;
      fb.cbufs[0] = dst;
   }
d477 1
a477 1
   cso_restore_fragment_sampler_views(ctx->cso);
a482 1
   cso_restore_vertex_elements(ctx->cso);
d484 1
a484 1
   pipe_sampler_view_reference(&sampler_view, NULL);
d490 1
a490 2
                 struct pipe_resource *src_tex,
                 unsigned src_level,
a492 1
                 int srcZ,
d498 1
a498 2
   util_blit_pixels_writemask( ctx, src_tex,
                               src_level,
a500 1
                               srcZ,
d514 1
a514 1
   pipe_resource_reference(&ctx->vbuf, NULL);
d522 1
d529 7
a535 7
                     struct pipe_sampler_view *src_sampler_view,
                     int srcX0, int srcY0,
                     int srcX1, int srcY1,
                     struct pipe_surface *dst,
                     int dstX0, int dstY0,
                     int dstX1, int dstY1,
                     float z, uint filter)
a536 1
   boolean normalized = src_sampler_view->texture->target != PIPE_TEXTURE_RECT;
a539 1
   struct pipe_resource *tex = src_sampler_view->texture;
a543 1
   assert(tex);
d547 4
a550 12
   s0 = srcX0;
   s1 = srcX1;
   t0 = srcY0;
   t1 = srcY1;

   if(normalized)
   {
      s0 /= (float)tex->width0;
      s1 /= (float)tex->width0;
      t0 /= (float)tex->height0;
      t1 /= (float)tex->height0;
   }
d554 1
a554 2
                                                 dst->texture->nr_samples,
                                                 PIPE_BIND_RENDER_TARGET,
d562 1
a562 2
   cso_save_fragment_sampler_views(ctx->cso);
   cso_save_viewport(ctx->cso);
a566 1
   cso_save_vertex_elements(ctx->cso);
d570 1
a570 1
   cso_set_depth_stencil_alpha(ctx->cso, &ctx->depthstencil_keep);
a572 1
   cso_set_vertex_elements(ctx->cso, 2, ctx->velem);
a574 1
   ctx->sampler.normalized_coords = normalized;
d592 1
a592 1
   cso_set_fragment_sampler_views(ctx->cso, 1, &src_sampler_view);
d626 1
a626 2
   cso_restore_fragment_sampler_views(ctx->cso);
   cso_restore_viewport(ctx->cso);
a630 1
   cso_restore_vertex_elements(ctx->cso);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d59 3
a61 5
   struct pipe_blend_state blend_write_color, blend_keep_color;
   struct pipe_depth_stencil_alpha_state dsa_keep_depthstencil;
   struct pipe_depth_stencil_alpha_state dsa_write_depthstencil;
   struct pipe_depth_stencil_alpha_state dsa_write_depth;
   struct pipe_depth_stencil_alpha_state dsa_write_stencil;
d65 1
d70 2
a71 4
   void *fs[PIPE_MAX_TEXTURE_TYPES][TGSI_WRITEMASK_XYZW + 1];
   void *fs_depthstencil[PIPE_MAX_TEXTURE_TYPES];
   void *fs_depth[PIPE_MAX_TEXTURE_TYPES];
   void *fs_stencil[PIPE_MAX_TEXTURE_TYPES];
a76 2

   boolean has_stencil_export;
d98 2
a99 1
   ctx->blend_write_color.rt[0].colormask = PIPE_MASK_RGBA;
d101 6
a106 13
   /* depth stencil states */
   ctx->dsa_write_depth.depth.enabled = 1;
   ctx->dsa_write_depth.depth.writemask = 1;
   ctx->dsa_write_depth.depth.func = PIPE_FUNC_ALWAYS;
   ctx->dsa_write_stencil.stencil[0].enabled = 1;
   ctx->dsa_write_stencil.stencil[0].func = PIPE_FUNC_ALWAYS;
   ctx->dsa_write_stencil.stencil[0].fail_op = PIPE_STENCIL_OP_REPLACE;
   ctx->dsa_write_stencil.stencil[0].zpass_op = PIPE_STENCIL_OP_REPLACE;
   ctx->dsa_write_stencil.stencil[0].zfail_op = PIPE_STENCIL_OP_REPLACE;
   ctx->dsa_write_stencil.stencil[0].valuemask = 0xff;
   ctx->dsa_write_stencil.stencil[0].writemask = 0xff;
   ctx->dsa_write_depthstencil.depth = ctx->dsa_write_depth.depth;
   ctx->dsa_write_depthstencil.stencil[0] = ctx->dsa_write_stencil.stencil[0];
d109 1
d111 1
a111 3
   ctx->rasterizer.half_pixel_center = 1;
   ctx->rasterizer.bottom_edge_rule = 1;
   ctx->rasterizer.depth_clip = 1;
d114 1
d123 1
d127 1
a127 1
      ctx->velem[i].vertex_buffer_index = cso_get_aux_vertex_buffer_slot(cso);
d131 15
a159 3
   ctx->has_stencil_export =
      pipe->screen->get_param(pipe->screen, PIPE_CAP_SHADER_STENCIL_EXPORT);

d171 1
a171 1
   unsigned i, j;
d173 1
a173 2
   if (ctx->vs)
      pipe->delete_vs_state(pipe, ctx->vs);
d175 3
a177 6
   for (i = 0; i < Elements(ctx->fs); i++) {
      for (j = 0; j < Elements(ctx->fs[i]); j++) {
         if (ctx->fs[i][j])
            pipe->delete_fs_state(pipe, ctx->fs[i][j]);
      }
   }
d179 2
a180 11
   for (i = 0; i < PIPE_MAX_TEXTURE_TYPES; i++) {
      if (ctx->fs_depthstencil[i]) {
         pipe->delete_fs_state(pipe, ctx->fs_depthstencil[i]);
      }
      if (ctx->fs_depth[i]) {
         pipe->delete_fs_state(pipe, ctx->fs_depth[i]);
      }
      if (ctx->fs_stencil[i]) {
         pipe->delete_fs_state(pipe, ctx->fs_stencil[i]);
      }
   }
a188 99
 * Helper function to set the fragment shaders.
 */
static INLINE void
set_fragment_shader(struct blit_state *ctx, uint writemask,
                    enum pipe_texture_target pipe_tex)
{
   if (!ctx->fs[pipe_tex][writemask]) {
      unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex, 0);

      ctx->fs[pipe_tex][writemask] =
         util_make_fragment_tex_shader_writemask(ctx->pipe, tgsi_tex,
                                                 TGSI_INTERPOLATE_LINEAR,
                                                 writemask);
   }

   cso_set_fragment_shader_handle(ctx->cso, ctx->fs[pipe_tex][writemask]);
}


/**
 * Helper function to set the shader which writes depth and stencil.
 */
static INLINE void
set_depthstencil_fragment_shader(struct blit_state *ctx,
                                 enum pipe_texture_target pipe_tex)
{
   if (!ctx->fs_depthstencil[pipe_tex]) {
      unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex, 0);

      ctx->fs_depthstencil[pipe_tex] =
         util_make_fragment_tex_shader_writedepthstencil(ctx->pipe, tgsi_tex,
                                                  TGSI_INTERPOLATE_LINEAR);
   }

   cso_set_fragment_shader_handle(ctx->cso, ctx->fs_depthstencil[pipe_tex]);
}


/**
 * Helper function to set the shader which writes depth.
 */
static INLINE void
set_depth_fragment_shader(struct blit_state *ctx,
                          enum pipe_texture_target pipe_tex)
{
   if (!ctx->fs_depth[pipe_tex]) {
      unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex, 0);

      ctx->fs_depth[pipe_tex] =
         util_make_fragment_tex_shader_writedepth(ctx->pipe, tgsi_tex,
                                                  TGSI_INTERPOLATE_LINEAR);
   }

   cso_set_fragment_shader_handle(ctx->cso, ctx->fs_depth[pipe_tex]);
}


/**
 * Helper function to set the shader which writes stencil.
 */
static INLINE void
set_stencil_fragment_shader(struct blit_state *ctx,
                            enum pipe_texture_target pipe_tex)
{
   if (!ctx->fs_stencil[pipe_tex]) {
      unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(pipe_tex, 0);

      ctx->fs_stencil[pipe_tex] =
         util_make_fragment_tex_shader_writestencil(ctx->pipe, tgsi_tex,
                                                    TGSI_INTERPOLATE_LINEAR);
   }

   cso_set_fragment_shader_handle(ctx->cso, ctx->fs_stencil[pipe_tex]);
}


/**
 * Helper function to set the vertex shader.
 */
static INLINE void
set_vertex_shader(struct blit_state *ctx)
{
   /* vertex shader - still required to provide the linkage between
    * fragment shader input semantics and vertex_element/buffers.
    */
   if (!ctx->vs) {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indexes[] = { 0, 0 };
      ctx->vs = util_make_vertex_passthrough_shader(ctx->pipe, 2,
                                                    semantic_names,
                                                    semantic_indexes);
   }

   cso_set_vertex_shader_handle(ctx->cso, ctx->vs);
}


/**
d196 2
a197 4
   if (ctx->vbuf_slot >= max_slots) {
      pipe_resource_reference(&ctx->vbuf, NULL);
      ctx->vbuf_slot = 0;
   }
a201 1
                                     PIPE_USAGE_STREAM,
d249 2
a250 4
   if (ctx->vbuf) {
      pipe_buffer_write_nooverlap(ctx->pipe, ctx->vbuf,
                                  offset, sizeof(ctx->vertices), ctx->vertices);
   }
a281 20
 * Can we blit from src format to dest format with a simple copy?
 */
static boolean
formats_compatible(enum pipe_format src_format,
                   enum pipe_format dst_format)
{
   if (src_format == dst_format) {
      return TRUE;
   }
   else {
      const struct util_format_description *src_desc =
         util_format_description(src_format);
      const struct util_format_description *dst_desc =
         util_format_description(dst_format);
      return util_is_format_compatible(src_desc, dst_desc);
   }
}


/**
d289 1
d292 11
a302 11
util_blit_pixels(struct blit_state *ctx,
                 struct pipe_resource *src_tex,
                 unsigned src_level,
                 int srcX0, int srcY0,
                 int srcX1, int srcY1,
                 int srcZ0,
                 struct pipe_surface *dst,
                 int dstX0, int dstY0,
                 int dstX1, int dstY1,
                 float z, uint filter,
                 uint writemask, uint zs_writemask)
a305 1
   enum pipe_format src_format, dst_format;
a307 1
   struct pipe_surface *dst_surface;
d312 1
a312 1
   boolean overlap;
a314 3
   boolean is_stencil, is_depth, blit_depth, blit_stencil;
   const struct util_format_description *src_desc =
         util_format_description(src_tex->format);
a327 13
   src_format = util_format_linear(src_tex->format);
   dst_format = util_format_linear(dst->texture->format);

   /* See whether we will blit depth or stencil. */
   is_depth = util_format_has_depth(src_desc);
   is_stencil = util_format_has_stencil(src_desc);

   blit_depth = is_depth && (zs_writemask & BLIT_WRITEMASK_Z);
   blit_stencil = is_stencil && (zs_writemask & BLIT_WRITEMASK_STENCIL);

   assert((writemask && !zs_writemask && !is_depth && !is_stencil) ||
          (!writemask && (blit_depth || blit_stencil)));

d330 1
a330 1
    * no overlapping, same number of samples.
d333 1
a333 4
   if (formats_compatible(src_format, dst_format) &&
       src_tex->nr_samples == dst->texture->nr_samples &&
       is_stencil == blit_stencil &&
       is_depth == blit_depth &&
d353 1
a353 1
      return;
d356 6
a361 9
   /* XXX Reading multisample textures is unimplemented. */
   assert(src_tex->nr_samples <= 1);
   if (src_tex->nr_samples > 1) {
      return;
   }

   /* It's a mistake to call this function with a stencil format and
    * without shader stencil export. We don't do software fallbacks here.
    * Ignore stencil and only copy depth.
d363 7
a369 23
   if (blit_stencil && !ctx->has_stencil_export) {
      blit_stencil = FALSE;

      if (!blit_depth)
         return;
   }

   if (dst_format == dst->format) {
      dst_surface = dst;
   } else {
      struct pipe_surface templ = *dst;
      templ.format = dst_format;
      dst_surface = pipe->create_surface(pipe, dst->texture, &templ);
   }

   /* Create a temporary texture when src and dest alias.
    */
   if (src_tex == dst_surface->texture &&
       dst_surface->u.tex.level == src_level &&
       dst_surface->u.tex.first_layer == srcZ0) {
      /* Make a temporary texture which contains a copy of the source pixels.
       * Then we'll sample from the temporary texture.
       */
d394 1
a394 1
      texTemp.format = src_format;
d425 4
a428 4
         s0 = 0.0f;
         s1 = (float) srcW;
         t0 = 0.0f;
         t1 = (float) srcH;
a431 5
      if (!blit_depth && blit_stencil) {
         /* set a stencil-only format, e.g. Z24S8 --> X24S8 */
         sv_templ.format = util_format_stencil_only(tex->format);
         assert(sv_templ.format != PIPE_FORMAT_NONE);
      }
d441 1
a441 7
      /* Directly sample from the source resource/texture */
      u_sampler_view_default_template(&sv_templ, src_tex, src_format);
      if (!blit_depth && blit_stencil) {
         /* set a stencil-only format, e.g. Z24S8 --> X24S8 */
         sv_templ.format = util_format_stencil_only(src_format);
         assert(sv_templ.format != PIPE_FORMAT_NONE);
      }
d448 4
a451 4
      s0 = (float) srcX0;
      s1 = (float) srcX1;
      t0 = (float) srcY0;
      t1 = (float) srcY1;
d462 1
a462 7
   assert(screen->is_format_supported(screen, sampler_view->format,
                     ctx->internal_target, sampler_view->texture->nr_samples,
                     PIPE_BIND_SAMPLER_VIEW));
   assert(screen->is_format_supported(screen, dst_format, ctx->internal_target,
                     dst_surface->texture->nr_samples,
                     is_depth || is_stencil ? PIPE_BIND_DEPTH_STENCIL :
                                              PIPE_BIND_RENDER_TARGET));
d464 7
d475 2
a476 4
   cso_save_sample_mask(ctx->cso);
   cso_save_samplers(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_save_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_save_stream_outputs(ctx->cso);
d481 1
a481 1
   cso_save_geometry_shader(ctx->cso);
a482 2
   cso_save_aux_vertex_buffer_slot(ctx->cso);
   cso_save_render_condition(ctx->cso);
d485 4
a488 6
   if (writemask)
      cso_set_blend(ctx->cso, &ctx->blend_write_color);
   else
      cso_set_blend(ctx->cso, &ctx->blend_keep_color);

   cso_set_sample_mask(ctx->cso, ~0);
d490 1
a491 2
   cso_set_stream_outputs(ctx->cso, 0, NULL, 0);
   cso_set_render_condition(ctx->cso, NULL, FALSE, 0);
d493 1
a493 1
   /* default sampler state */
d497 4
a500 56
   ctx->sampler.min_lod = (float) src_level;
   ctx->sampler.max_lod = (float) src_level;

   /* Depth stencil state, fragment shader and sampler setup depending on what
    * we blit.
    */
   if (blit_depth && blit_stencil) {
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);
      /* don't filter stencil */
      ctx->sampler.min_img_filter = PIPE_TEX_FILTER_NEAREST;
      ctx->sampler.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 1, &ctx->sampler);

      cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_write_depthstencil);
      set_depthstencil_fragment_shader(ctx, sampler_view->texture->target);
   }
   else if (blit_depth) {
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);
      cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_write_depth);
      set_depth_fragment_shader(ctx, sampler_view->texture->target);
   }
   else if (blit_stencil) {
      /* don't filter stencil */
      ctx->sampler.min_img_filter = PIPE_TEX_FILTER_NEAREST;
      ctx->sampler.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);

      cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_write_stencil);
      set_stencil_fragment_shader(ctx, sampler_view->texture->target);
   }
   else { /* color */
      cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);
      cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_keep_depthstencil);
      set_fragment_shader(ctx, writemask, sampler_view->texture->target);
   }
   cso_single_sampler_done(ctx->cso, PIPE_SHADER_FRAGMENT);

   /* textures */
   if (blit_depth && blit_stencil) {
      /* Setup two samplers, one for depth and the other one for stencil. */
      struct pipe_sampler_view templ;
      struct pipe_sampler_view *views[2];

      templ = *sampler_view;
      templ.format = util_format_stencil_only(templ.format);
      assert(templ.format != PIPE_FORMAT_NONE);

      views[0] = sampler_view;
      views[1] = pipe->create_sampler_view(pipe, views[0]->texture, &templ);
      cso_set_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT, 2, views);

      pipe_sampler_view_reference(&views[1], NULL);
   }
   else {
      cso_set_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT, 1, &sampler_view);
   }
d503 2
a504 2
   ctx->viewport.scale[0] = 0.5f * dst_surface->width;
   ctx->viewport.scale[1] = 0.5f * dst_surface->height;
d507 2
a508 2
   ctx->viewport.translate[0] = 0.5f * dst_surface->width;
   ctx->viewport.translate[1] = 0.5f * dst_surface->height;
d513 21
a533 2
   set_vertex_shader(ctx);
   cso_set_geometry_shader_handle(ctx->cso, NULL);
d537 4
a540 4
   fb.width = dst_surface->width;
   fb.height = dst_surface->height;
   if (blit_depth || blit_stencil) {
      fb.zsbuf = dst_surface;
d543 1
a543 1
      fb.cbufs[0] = dst_surface;
d549 4
a552 4
                                  (float) dstX0 / dst_surface->width * 2.0f - 1.0f,
                                  (float) dstY0 / dst_surface->height * 2.0f - 1.0f,
                                  (float) dstX1 / dst_surface->width * 2.0f - 1.0f,
                                  (float) dstY1 / dst_surface->height * 2.0f - 1.0f,
d557 4
a560 8
   if (ctx->vbuf) {
      util_draw_vertex_buffer(ctx->pipe, ctx->cso, ctx->vbuf,
                              cso_get_aux_vertex_buffer_slot(ctx->cso),
                              offset,
                              PIPE_PRIM_TRIANGLE_FAN,
                              4,  /* verts */
                              2); /* attribs/vert */
   }
d566 2
a567 3
   cso_restore_sample_mask(ctx->cso);
   cso_restore_samplers(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_restore_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT);
d572 1
a572 1
   cso_restore_geometry_shader(ctx->cso);
a573 3
   cso_restore_aux_vertex_buffer_slot(ctx->cso);
   cso_restore_stream_outputs(ctx->cso);
   cso_restore_render_condition(ctx->cso);
a575 2
   if (dst_surface != dst)
      pipe_surface_reference(&dst_surface, NULL);
d579 36
d617 2
a618 2
 * The sampler view's first_level field indicates the source
 * mipmap level to use.
d644 4
a647 4
   s0 = (float) srcX0;
   s1 = (float) srcX1;
   t0 = (float) srcY0;
   t1 = (float) srcY1;
d651 4
a654 8
      /* normalize according to the mipmap level's size */
      int level = src_sampler_view->u.tex.first_level;
      float w = (float) u_minify(tex->width0, level);
      float h = (float) u_minify(tex->height0, level);
      s0 /= w;
      s1 /= w;
      t0 /= h;
      t1 /= h;
d660 2
a661 1
                                                 PIPE_BIND_RENDER_TARGET));
d667 2
a668 4
   cso_save_sample_mask(ctx->cso);
   cso_save_samplers(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_save_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_save_stream_outputs(ctx->cso);
d673 1
a673 1
   cso_save_geometry_shader(ctx->cso);
a674 1
   cso_save_aux_vertex_buffer_slot(ctx->cso);
d677 2
a678 3
   cso_set_blend(ctx->cso, &ctx->blend_write_color);
   cso_set_depth_stencil_alpha(ctx->cso, &ctx->dsa_keep_depthstencil);
   cso_set_sample_mask(ctx->cso, ~0);
d680 1
a681 1
   cso_set_stream_outputs(ctx->cso, 0, NULL, 0);
d687 2
a688 2
   cso_single_sampler(ctx->cso, PIPE_SHADER_FRAGMENT, 0, &ctx->sampler);
   cso_single_sampler_done(ctx->cso, PIPE_SHADER_FRAGMENT);
d702 1
a702 1
   cso_set_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT, 1, &src_sampler_view);
d705 2
a706 4
   set_fragment_shader(ctx, TGSI_WRITEMASK_XYZW,
                       src_sampler_view->texture->target);
   set_vertex_shader(ctx);
   cso_set_geometry_shader_handle(ctx->cso, NULL);
d725 2
a726 3
   util_draw_vertex_buffer(ctx->pipe, ctx->cso, ctx->vbuf,
                           cso_get_aux_vertex_buffer_slot(ctx->cso),
                           offset,
d735 2
a736 3
   cso_restore_sample_mask(ctx->cso);
   cso_restore_samplers(ctx->cso, PIPE_SHADER_FRAGMENT);
   cso_restore_sampler_views(ctx->cso, PIPE_SHADER_FRAGMENT);
d741 1
a741 1
   cso_restore_geometry_shader(ctx->cso);
a742 2
   cso_restore_aux_vertex_buffer_slot(ctx->cso);
   cso_restore_stream_outputs(ctx->cso);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a48 1
#include "util/u_texture.h"
d59 1
a59 1
   struct pipe_blend_state blend_write_color;
d61 3
d68 1
d72 3
d80 2
d105 14
d146 1
d150 8
d181 12
d220 57
a326 3
 *
 * FIXME: We should call util_map_texcoords2d_onto_cubemap
 * for cubemaps.
a329 2
                      unsigned src_target,
                      unsigned src_face,
a340 1
   ctx->vertices[0][1][2] = 0;  /*r*/
a346 1
   ctx->vertices[1][1][2] = 0;  /*r*/
a352 1
   ctx->vertices[3][1][2] = 0;
a358 11
   ctx->vertices[3][1][2] = 0;

   if (src_target == PIPE_TEXTURE_CUBE ||
       src_target == PIPE_TEXTURE_CUBE_ARRAY) {
      /* Map cubemap texture coordinates inplace. */
      const unsigned stride = sizeof ctx->vertices[0] / sizeof ctx->vertices[0][0][0];
      util_map_texcoords2d_onto_cubemap(src_face,
                                        &ctx->vertices[0][1][0], stride,
                                        &ctx->vertices[0][1][0], stride,
                                        TRUE);
   }
d439 1
d441 4
d447 1
d449 2
a453 1
   struct pipe_blit_info info;
a480 6
    * XXX: z parameter is deprecated. dst->u.tex.first_layer
    * specificies the destination layer.
    */
   assert(z == 0.0f);

   /*
d511 101
a611 24
   memset(&info, 0, sizeof info);
   info.dst.resource = dst->texture;
   info.dst.level = dst->u.tex.level;
   info.dst.box.x = dstX0;
   info.dst.box.y = dstY0;
   info.dst.box.z = dst->u.tex.first_layer;
   info.dst.box.width = dstX1 - dstX0;
   info.dst.box.height = dstY1 - dstY0;
   assert(info.dst.box.width >= 0);
   assert(info.dst.box.height >= 0);
   info.dst.box.depth = 1;
   info.dst.format = dst->texture->format;
   info.src.resource = src_tex;
   info.src.level = src_level;
   info.src.box.x = srcX0;
   info.src.box.y = srcY0;
   info.src.box.z = srcZ0;
   info.src.box.width = srcX1 - srcX0;
   info.src.box.height = srcY1 - srcY0;
   info.src.box.depth = 1;
   info.src.format = src_tex->format;
   info.mask = writemask | (zs_writemask << 4);
   info.filter = filter;
   info.scissor_enable = 0;
d613 197
a809 1
   pipe->blit(pipe, &info);
d814 1
a814 2
 * Copy pixel block from src sampler view to dst surface.
 *
d817 1
a817 8
 *
 * The sampler view's first_layer indicate the layer to use, but for
 * cube maps it must point to the first face.  Face is passed in src_face.
 *
 * The main advantage over util_blit_pixels is that it allows to specify swizzles in
 * pipe_sampler_view::swizzle_?.
 *
 * But there is no control over blitting Z and/or stencil.
a823 1
                     unsigned src_face,
a868 1
   cso_save_min_samples(ctx->cso);
a883 1
   cso_set_min_samples(ctx->cso, 1);
d886 1
a886 1
   cso_set_stream_outputs(ctx->cso, 0, NULL, NULL);
a924 2
                                  src_sampler_view->texture->target,
                                  src_face,
a943 1
   cso_restore_min_samples(ctx->cso);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d339 4
a342 4
 * \param filter  one of PIPE_TEX_FILTER_NEAREST/LINEAR
 * \param writemask  bitmask of PIPE_MASK_[RGBAZS].  Controls which channels
 *                   in the dest surface are sourced from the src surface.
 *                   Disabled color channels are sourced from (0,0,0,1).
d355 1
a355 1
                 uint writemask)
d367 2
a368 2
   assert(filter == PIPE_TEX_FILTER_NEAREST ||
          filter == PIPE_TEX_FILTER_LINEAR);
d386 2
a387 2
   blit_depth = is_depth && (writemask & PIPE_MASK_Z);
   blit_stencil = is_stencil && (writemask & PIPE_MASK_S);
d389 2
a390 9
   if (is_depth || is_stencil) {
      assert((writemask & PIPE_MASK_RGBA) == 0);
      assert(blit_depth || blit_stencil);
   }
   else {
      assert((writemask & PIPE_MASK_ZS) == 0);
      assert(!blit_depth);
      assert(!blit_stencil);
   }
d440 1
a440 1
   info.dst.format = dst_format;
d449 2
a450 2
   info.src.format = src_format;
   info.mask = writemask;
d489 2
a490 2
   assert(filter == PIPE_TEX_FILTER_NEAREST ||
          filter == PIPE_TEX_FILTER_LINEAR);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d339 4
a342 4
 * \param filter  one of PIPE_TEX_MIPFILTER_NEAREST/LINEAR
 * \param writemask  controls which channels in the dest surface are sourced
 *                   from the src surface.  Disabled channels are sourced
 *                   from (0,0,0,1).
d355 1
a355 1
                 uint writemask, uint zs_writemask)
d367 2
a368 2
   assert(filter == PIPE_TEX_MIPFILTER_NEAREST ||
          filter == PIPE_TEX_MIPFILTER_LINEAR);
d386 2
a387 2
   blit_depth = is_depth && (zs_writemask & BLIT_WRITEMASK_Z);
   blit_stencil = is_stencil && (zs_writemask & BLIT_WRITEMASK_STENCIL);
d389 9
a397 2
   assert((writemask && !zs_writemask && !is_depth && !is_stencil) ||
          (!writemask && (blit_depth || blit_stencil)));
d447 1
a447 1
   info.dst.format = dst->texture->format;
d456 2
a457 2
   info.src.format = src_tex->format;
   info.mask = writemask | (zs_writemask << 4);
d496 2
a497 2
   assert(filter == PIPE_TEX_MIPFILTER_NEAREST ||
          filter == PIPE_TEX_MIPFILTER_LINEAR);
@


