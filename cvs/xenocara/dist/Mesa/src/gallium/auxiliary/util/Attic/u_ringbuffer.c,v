head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.0.22
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.20
	OPENBSD_5_7_BASE:1.1
	v10_2_9:1.1.1.1
	v10_4_3:1.1.1.1
	v10_2_7:1.1.1.1
	OPENBSD_5_6:1.1.0.18
	OPENBSD_5_6_BASE:1.1
	v10_2_3:1.1.1.1
	OPENBSD_5_5:1.1.0.16
	OPENBSD_5_5_BASE:1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	OPENBSD_5_4:1.1.0.14
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.12
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.10
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@
#include "os/os_thread.h"
#include "pipe/p_defines.h"
#include "util/u_ringbuffer.h"
#include "util/u_math.h"
#include "util/u_memory.h"

/* Generic ringbuffer: 
 */
struct util_ringbuffer 
{
   struct util_packet *buf;
   unsigned mask;

   /* Can this be done with atomic variables??
    */
   unsigned head;
   unsigned tail;
   pipe_condvar change;
   pipe_mutex mutex;
};


struct util_ringbuffer *util_ringbuffer_create( unsigned dwords )
{
   struct util_ringbuffer *ring = CALLOC_STRUCT(util_ringbuffer);
   if (ring == NULL)
      return NULL;

   assert(util_is_power_of_two(dwords));
   
   ring->buf = MALLOC( dwords * sizeof(unsigned) );
   if (ring->buf == NULL)
      goto fail;

   ring->mask = dwords - 1;

   pipe_condvar_init(ring->change);
   pipe_mutex_init(ring->mutex);
   return ring;

fail:
   FREE(ring->buf);
   FREE(ring);
   return NULL;
}

void util_ringbuffer_destroy( struct util_ringbuffer *ring )
{
   pipe_condvar_destroy(ring->change);
   pipe_mutex_destroy(ring->mutex);
   FREE(ring->buf);
   FREE(ring);
}

/**
 * Return number of free entries in the ring
 */
static INLINE unsigned util_ringbuffer_space( const struct util_ringbuffer *ring )
{
   return (ring->tail - (ring->head + 1)) & ring->mask;
}

/**
 * Is the ring buffer empty?
 */
static INLINE boolean util_ringbuffer_empty( const struct util_ringbuffer *ring )
{
   return util_ringbuffer_space(ring) == ring->mask;
}

void util_ringbuffer_enqueue( struct util_ringbuffer *ring,
                              const struct util_packet *packet )
{
   unsigned i;

   /* XXX: over-reliance on mutexes, etc:
    */
   pipe_mutex_lock(ring->mutex);

   /* make sure we don't request an impossible amount of space
    */
   assert(packet->dwords <= ring->mask);

   /* Wait for free space:
    */
   while (util_ringbuffer_space(ring) < packet->dwords)
      pipe_condvar_wait(ring->change, ring->mutex);

   /* Copy data to ring:
    */
   for (i = 0; i < packet->dwords; i++) {

      /* Copy all dwords of the packet.  Note we're abusing the
       * typesystem a little - we're being passed a pointer to
       * something, but probably not an array of packet structs:
       */
      ring->buf[ring->head] = packet[i];
      ring->head++;
      ring->head &= ring->mask;
   }

   /* Signal change:
    */
   pipe_condvar_signal(ring->change);
   pipe_mutex_unlock(ring->mutex);
}

enum pipe_error util_ringbuffer_dequeue( struct util_ringbuffer *ring,
                                         struct util_packet *packet,
                                         unsigned max_dwords,
                                         boolean wait )
{
   const struct util_packet *ring_packet;
   unsigned i;
   int ret = PIPE_OK;

   /* XXX: over-reliance on mutexes, etc:
    */
   pipe_mutex_lock(ring->mutex);

   /* Get next ring entry:
    */
   if (wait) {
      while (util_ringbuffer_empty(ring))
         pipe_condvar_wait(ring->change, ring->mutex);
   }
   else {
      if (util_ringbuffer_empty(ring)) {
         ret = PIPE_ERROR_OUT_OF_MEMORY;
         goto out;
      }
   }

   ring_packet = &ring->buf[ring->tail];

   /* Both of these are considered bugs.  Raise an assert on debug builds.
    */
   if (ring_packet->dwords > ring->mask + 1 - util_ringbuffer_space(ring) ||
       ring_packet->dwords > max_dwords) {
      assert(0);
      ret = PIPE_ERROR_BAD_INPUT;
      goto out;
   }

   /* Copy data from ring:
    */
   for (i = 0; i < ring_packet->dwords; i++) {
      packet[i] = ring->buf[ring->tail];
      ring->tail++;
      ring->tail &= ring->mask;
   }

out:
   /* Signal change:
    */
   pipe_condvar_signal(ring->change);
   pipe_mutex_unlock(ring->mutex);
   return ret;
}
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@

