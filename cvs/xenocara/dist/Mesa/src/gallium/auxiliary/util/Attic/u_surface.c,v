head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.52;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.54;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.48;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * @@file
 * Surface utility functions.
 *  
 * @@author Brian Paul
 */


#include "pipe/p_defines.h"
#include "pipe/p_screen.h"
#include "pipe/p_state.h"

#include "util/u_format.h"
#include "util/u_inlines.h"
#include "util/u_rect.h"
#include "util/u_surface.h"
#include "util/u_pack_color.h"


/**
 * Initialize a pipe_surface object.  'view' is considered to have
 * uninitialized contents.
 */
void
u_surface_default_template(struct pipe_surface *surf,
                           const struct pipe_resource *texture)
{
   memset(surf, 0, sizeof(*surf));

   surf->format = texture->format;
}


/**
 * Copy 2D rect from one place to another.
 * Position and sizes are in pixels.
 * src_stride may be negative to do vertical flip of pixels from source.
 */
void
util_copy_rect(ubyte * dst,
               enum pipe_format format,
               unsigned dst_stride,
               unsigned dst_x,
               unsigned dst_y,
               unsigned width,
               unsigned height,
               const ubyte * src,
               int src_stride,
               unsigned src_x,
               unsigned src_y)
{
   unsigned i;
   int src_stride_pos = src_stride < 0 ? -src_stride : src_stride;
   int blocksize = util_format_get_blocksize(format);
   int blockwidth = util_format_get_blockwidth(format);
   int blockheight = util_format_get_blockheight(format);

   assert(blocksize > 0);
   assert(blockwidth > 0);
   assert(blockheight > 0);

   dst_x /= blockwidth;
   dst_y /= blockheight;
   width = (width + blockwidth - 1)/blockwidth;
   height = (height + blockheight - 1)/blockheight;
   src_x /= blockwidth;
   src_y /= blockheight;

   dst += dst_x * blocksize;
   src += src_x * blocksize;
   dst += dst_y * dst_stride;
   src += src_y * src_stride_pos;
   width *= blocksize;

   if (width == dst_stride && width == src_stride)
      memcpy(dst, src, height * width);
   else {
      for (i = 0; i < height; i++) {
         memcpy(dst, src, width);
         dst += dst_stride;
         src += src_stride;
      }
   }
}


/**
 * Copy 3D box from one place to another.
 * Position and sizes are in pixels.
 */
void
util_copy_box(ubyte * dst,
              enum pipe_format format,
              unsigned dst_stride, unsigned dst_slice_stride,
              unsigned dst_x, unsigned dst_y, unsigned dst_z,
              unsigned width, unsigned height, unsigned depth,
              const ubyte * src,
              int src_stride, unsigned src_slice_stride,
              unsigned src_x, unsigned src_y, unsigned src_z)
{
   unsigned z;
   dst += dst_z * dst_slice_stride;
   src += src_z * src_slice_stride;
   for (z = 0; z < depth; ++z) {
      util_copy_rect(dst,
                     format,
                     dst_stride,
                     dst_x, dst_y,
                     width, height,
                     src,
                     src_stride,
                     src_x, src_y);

      dst += dst_slice_stride;
      src += src_slice_stride;
   }
}


void
util_fill_rect(ubyte * dst,
               enum pipe_format format,
               unsigned dst_stride,
               unsigned dst_x,
               unsigned dst_y,
               unsigned width,
               unsigned height,
               union util_color *uc)
{
   const struct util_format_description *desc = util_format_description(format);
   unsigned i, j;
   unsigned width_size;
   int blocksize = desc->block.bits / 8;
   int blockwidth = desc->block.width;
   int blockheight = desc->block.height;

   assert(blocksize > 0);
   assert(blockwidth > 0);
   assert(blockheight > 0);

   dst_x /= blockwidth;
   dst_y /= blockheight;
   width = (width + blockwidth - 1)/blockwidth;
   height = (height + blockheight - 1)/blockheight;

   dst += dst_x * blocksize;
   dst += dst_y * dst_stride;
   width_size = width * blocksize;

   switch (blocksize) {
   case 1:
      if(dst_stride == width_size)
         memset(dst, uc->ub, height * width_size);
      else {
         for (i = 0; i < height; i++) {
            memset(dst, uc->ub, width_size);
            dst += dst_stride;
         }
      }
      break;
   case 2:
      for (i = 0; i < height; i++) {
         uint16_t *row = (uint16_t *)dst;
         for (j = 0; j < width; j++)
            *row++ = uc->us;
         dst += dst_stride;
      }
      break;
   case 4:
      for (i = 0; i < height; i++) {
         uint32_t *row = (uint32_t *)dst;
         for (j = 0; j < width; j++)
            *row++ = uc->ui[0];
         dst += dst_stride;
      }
      break;
   default:
      for (i = 0; i < height; i++) {
         ubyte *row = dst;
         for (j = 0; j < width; j++) {
            memcpy(row, uc, blocksize);
            row += blocksize;
         }
         dst += dst_stride;
      }
      break;
   }
}


void
util_fill_box(ubyte * dst,
              enum pipe_format format,
              unsigned stride,
              unsigned layer_stride,
              unsigned x,
              unsigned y,
              unsigned z,
              unsigned width,
              unsigned height,
              unsigned depth,
              union util_color *uc)
{
   unsigned layer;
   dst += z * layer_stride;
   for (layer = z; layer < depth; layer++) {
      util_fill_rect(dst, format,
                     stride,
                     x, y, width, height, uc);
      dst += layer_stride;
   }
}


/**
 * Fallback function for pipe->resource_copy_region().
 * Note: (X,Y)=(0,0) is always the upper-left corner.
 */
void
util_resource_copy_region(struct pipe_context *pipe,
                          struct pipe_resource *dst,
                          unsigned dst_level,
                          unsigned dst_x, unsigned dst_y, unsigned dst_z,
                          struct pipe_resource *src,
                          unsigned src_level,
                          const struct pipe_box *src_box)
{
   struct pipe_transfer *src_trans, *dst_trans;
   uint8_t *dst_map;
   const uint8_t *src_map;
   enum pipe_format src_format, dst_format;
   struct pipe_box dst_box;

   assert(src && dst);
   if (!src || !dst)
      return;

   assert((src->target == PIPE_BUFFER && dst->target == PIPE_BUFFER) ||
          (src->target != PIPE_BUFFER && dst->target != PIPE_BUFFER));

   src_format = src->format;
   dst_format = dst->format;

   assert(util_format_get_blocksize(dst_format) == util_format_get_blocksize(src_format));
   assert(util_format_get_blockwidth(dst_format) == util_format_get_blockwidth(src_format));
   assert(util_format_get_blockheight(dst_format) == util_format_get_blockheight(src_format));

   src_map = pipe->transfer_map(pipe,
                                src,
                                src_level,
                                PIPE_TRANSFER_READ,
                                src_box, &src_trans);
   assert(src_map);
   if (!src_map) {
      goto no_src_map;
   }

   dst_box.x = dst_x;
   dst_box.y = dst_y;
   dst_box.z = dst_z;
   dst_box.width  = src_box->width;
   dst_box.height = src_box->height;
   dst_box.depth  = src_box->depth;

   dst_map = pipe->transfer_map(pipe,
                                dst,
                                dst_level,
                                PIPE_TRANSFER_WRITE | PIPE_TRANSFER_DISCARD_RANGE,
                                &dst_box, &dst_trans);
   assert(dst_map);
   if (!dst_map) {
      goto no_dst_map;
   }

   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      assert(src_box->height == 1);
      assert(src_box->depth == 1);
      memcpy(dst_map, src_map, src_box->width);
   } else {
      util_copy_box(dst_map,
                    dst_format,
                    dst_trans->stride, dst_trans->layer_stride,
                    0, 0, 0,
                    src_box->width, src_box->height, src_box->depth,
                    src_map,
                    src_trans->stride, src_trans->layer_stride,
                    0, 0, 0);
   }

   pipe->transfer_unmap(pipe, dst_trans);
no_dst_map:
   pipe->transfer_unmap(pipe, src_trans);
no_src_map:
   ;
}



#define UBYTE_TO_USHORT(B) ((B) | ((B) << 8))


/**
 * Fallback for pipe->clear_render_target() function.
 * XXX this looks too hackish to be really useful.
 * cpp > 4 looks like a gross hack at best...
 * Plus can't use these transfer fallbacks when clearing
 * multisampled surfaces for instance.
 * Clears all bound layers.
 */
void
util_clear_render_target(struct pipe_context *pipe,
                         struct pipe_surface *dst,
                         const union pipe_color_union *color,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
{
   struct pipe_transfer *dst_trans;
   ubyte *dst_map;
   union util_color uc;
   unsigned max_layer;

   assert(dst->texture);
   if (!dst->texture)
      return;

   if (dst->texture->target == PIPE_BUFFER) {
      /*
       * The fill naturally works on the surface format, however
       * the transfer uses resource format which is just bytes for buffers.
       */
      unsigned dx, w;
      unsigned pixstride = util_format_get_blocksize(dst->format);
      dx = (dst->u.buf.first_element + dstx) * pixstride;
      w = width * pixstride;
      max_layer = 0;
      dst_map = pipe_transfer_map(pipe,
                                  dst->texture,
                                  0, 0,
                                  PIPE_TRANSFER_WRITE,
                                  dx, 0, w, 1,
                                  &dst_trans);
   }
   else {
      max_layer = dst->u.tex.last_layer - dst->u.tex.first_layer;
      dst_map = pipe_transfer_map_3d(pipe,
                                     dst->texture,
                                     dst->u.tex.level,
                                     PIPE_TRANSFER_WRITE,
                                     dstx, dsty, dst->u.tex.first_layer,
                                     width, height, max_layer + 1, &dst_trans);
   }

   assert(dst_map);

   if (dst_map) {
      enum pipe_format format = dst->format;
      assert(dst_trans->stride > 0);

      if (util_format_is_pure_integer(format)) {
         /*
          * We expect int/uint clear values here, though some APIs
          * might disagree (but in any case util_pack_color()
          * couldn't handle it)...
          */
         if (util_format_is_pure_sint(format)) {
            util_format_write_4i(format, color->i, 0, &uc, 0, 0, 0, 1, 1);
         }
         else {
            assert(util_format_is_pure_uint(format));
            util_format_write_4ui(format, color->ui, 0, &uc, 0, 0, 0, 1, 1);
         }
      }
      else {
         util_pack_color(color->f, dst->format, &uc);
      }

      util_fill_box(dst_map, dst->format,
                    dst_trans->stride, dst_trans->layer_stride,
                    0, 0, 0, width, height, max_layer + 1, &uc);

      pipe->transfer_unmap(pipe, dst_trans);
   }
}

/**
 * Fallback for pipe->clear_stencil() function.
 * sw fallback doesn't look terribly useful here.
 * Plus can't use these transfer fallbacks when clearing
 * multisampled surfaces for instance.
 * Clears all bound layers.
 */
void
util_clear_depth_stencil(struct pipe_context *pipe,
                         struct pipe_surface *dst,
                         unsigned clear_flags,
                         double depth,
                         unsigned stencil,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
{
   enum pipe_format format = dst->format;
   struct pipe_transfer *dst_trans;
   ubyte *dst_map;
   boolean need_rmw = FALSE;
   unsigned max_layer, layer;

   if ((clear_flags & PIPE_CLEAR_DEPTHSTENCIL) &&
       ((clear_flags & PIPE_CLEAR_DEPTHSTENCIL) != PIPE_CLEAR_DEPTHSTENCIL) &&
       util_format_is_depth_and_stencil(format))
      need_rmw = TRUE;

   assert(dst->texture);
   if (!dst->texture)
      return;

   max_layer = dst->u.tex.last_layer - dst->u.tex.first_layer;
   dst_map = pipe_transfer_map_3d(pipe,
                                  dst->texture,
                                  dst->u.tex.level,
                                  (need_rmw ? PIPE_TRANSFER_READ_WRITE :
                                              PIPE_TRANSFER_WRITE),
                                  dstx, dsty, dst->u.tex.first_layer,
                                  width, height, max_layer + 1, &dst_trans);
   assert(dst_map);

   if (dst_map) {
      unsigned dst_stride = dst_trans->stride;
      uint64_t zstencil = util_pack64_z_stencil(format, depth, stencil);
      ubyte *dst_layer = dst_map;
      unsigned i, j;
      assert(dst_trans->stride > 0);

      for (layer = 0; layer <= max_layer; layer++) {
         dst_map = dst_layer;

         switch (util_format_get_blocksize(format)) {
         case 1:
            assert(format == PIPE_FORMAT_S8_UINT);
            if(dst_stride == width)
               memset(dst_map, (uint8_t) zstencil, height * width);
            else {
               for (i = 0; i < height; i++) {
                  memset(dst_map, (uint8_t) zstencil, width);
                  dst_map += dst_stride;
               }
            }
            break;
         case 2:
            assert(format == PIPE_FORMAT_Z16_UNORM);
            for (i = 0; i < height; i++) {
               uint16_t *row = (uint16_t *)dst_map;
               for (j = 0; j < width; j++)
                  *row++ = (uint16_t) zstencil;
               dst_map += dst_stride;
               }
            break;
         case 4:
            if (!need_rmw) {
               for (i = 0; i < height; i++) {
                  uint32_t *row = (uint32_t *)dst_map;
                  for (j = 0; j < width; j++)
                     *row++ = (uint32_t) zstencil;
                  dst_map += dst_stride;
               }
            }
            else {
               uint32_t dst_mask;
               if (format == PIPE_FORMAT_Z24_UNORM_S8_UINT)
                  dst_mask = 0x00ffffff;
               else {
                  assert(format == PIPE_FORMAT_S8_UINT_Z24_UNORM);
                  dst_mask = 0xffffff00;
               }
               if (clear_flags & PIPE_CLEAR_DEPTH)
                  dst_mask = ~dst_mask;
               for (i = 0; i < height; i++) {
                  uint32_t *row = (uint32_t *)dst_map;
                  for (j = 0; j < width; j++) {
                     uint32_t tmp = *row & dst_mask;
                     *row++ = tmp | ((uint32_t) zstencil & ~dst_mask);
                  }
                  dst_map += dst_stride;
               }
            }
            break;
         case 8:
            if (!need_rmw) {
               for (i = 0; i < height; i++) {
                  uint64_t *row = (uint64_t *)dst_map;
                  for (j = 0; j < width; j++)
                     *row++ = zstencil;
                  dst_map += dst_stride;
               }
            }
            else {
               uint64_t src_mask;

               if (clear_flags & PIPE_CLEAR_DEPTH)
                  src_mask = 0x00000000ffffffffull;
               else
                  src_mask = 0x000000ff00000000ull;

               for (i = 0; i < height; i++) {
                  uint64_t *row = (uint64_t *)dst_map;
                  for (j = 0; j < width; j++) {
                     uint64_t tmp = *row & ~src_mask;
                     *row++ = tmp | (zstencil & src_mask);
                  }
                  dst_map += dst_stride;
               }
            }
            break;
         default:
            assert(0);
            break;
         }
         dst_layer += dst_trans->layer_stride;
      }

      pipe->transfer_unmap(pipe, dst_trans);
   }
}


/* Return if the box is totally inside the resource.
 */
static boolean
is_box_inside_resource(const struct pipe_resource *res,
                       const struct pipe_box *box,
                       unsigned level)
{
   unsigned width = 1, height = 1, depth = 1;

   switch (res->target) {
   case PIPE_BUFFER:
      width = res->width0;
      height = 1;
      depth = 1;
      break;
   case PIPE_TEXTURE_1D:
      width = u_minify(res->width0, level);
      height = 1;
      depth = 1;
      break;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = 1;
      break;
   case PIPE_TEXTURE_3D:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = u_minify(res->depth0, level);
      break;
   case PIPE_TEXTURE_CUBE:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = 6;
      break;
   case PIPE_TEXTURE_1D_ARRAY:
      width = u_minify(res->width0, level);
      height = 1;
      depth = res->array_size;
      break;
   case PIPE_TEXTURE_2D_ARRAY:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = res->array_size;
      break;
   case PIPE_TEXTURE_CUBE_ARRAY:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = res->array_size;
      assert(res->array_size % 6 == 0);
      break;
   case PIPE_MAX_TEXTURE_TYPES:;
   }

   return box->x >= 0 &&
          box->x + box->width <= (int) width &&
          box->y >= 0 &&
          box->y + box->height <= (int) height &&
          box->z >= 0 &&
          box->z + box->depth <= (int) depth;
}

static unsigned
get_sample_count(const struct pipe_resource *res)
{
   return res->nr_samples ? res->nr_samples : 1;
}

/**
 * Try to do a blit using resource_copy_region. The function calls
 * resource_copy_region if the blit description is compatible with it.
 *
 * It returns TRUE if the blit was done using resource_copy_region.
 *
 * It returns FALSE otherwise and the caller must fall back to a more generic
 * codepath for the blit operation. (e.g. by using u_blitter)
 */
boolean
util_try_blit_via_copy_region(struct pipe_context *ctx,
                              const struct pipe_blit_info *blit)
{
   unsigned mask = util_format_get_mask(blit->dst.format);

   /* No format conversions. */
   if (blit->src.resource->format != blit->src.format ||
       blit->dst.resource->format != blit->dst.format ||
       !util_is_format_compatible(
          util_format_description(blit->src.resource->format),
          util_format_description(blit->dst.resource->format))) {
      return FALSE;
   }

   /* No masks, no filtering, no scissor. */
   if ((blit->mask & mask) != mask ||
       blit->filter != PIPE_TEX_FILTER_NEAREST ||
       blit->scissor_enable) {
      return FALSE;
   }

   /* No flipping. */
   if (blit->src.box.width < 0 ||
       blit->src.box.height < 0 ||
       blit->src.box.depth < 0) {
      return FALSE;
   }

   /* No scaling. */
   if (blit->src.box.width != blit->dst.box.width ||
       blit->src.box.height != blit->dst.box.height ||
       blit->src.box.depth != blit->dst.box.depth) {
      return FALSE;
   }

   /* No out-of-bounds access. */
   if (!is_box_inside_resource(blit->src.resource, &blit->src.box,
                               blit->src.level) ||
       !is_box_inside_resource(blit->dst.resource, &blit->dst.box,
                               blit->dst.level)) {
      return FALSE;
   }

   /* Sample counts must match. */
   if (get_sample_count(blit->src.resource) !=
       get_sample_count(blit->dst.resource)) {
      return FALSE;
   }

   ctx->resource_copy_region(ctx, blit->dst.resource, blit->dst.level,
                             blit->dst.box.x, blit->dst.box.y, blit->dst.box.z,
                             blit->src.resource, blit->src.level,
                             &blit->src.box);
   return TRUE;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d199 1
a199 1
            *row++ = uc->ui;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d45 5
d51 6
a56 10
u_surface_default_template(struct pipe_surface *view,
                           const struct pipe_resource *texture,
                           unsigned bind)
{
   view->format = texture->format;
   view->u.tex.level = 0;
   view->u.tex.first_layer = 0;
   view->u.tex.last_layer = 0;
   /* XXX should filter out all non-rt/ds bind flags ? */
   view->usage = bind;
d59 1
d61 3
a63 4
 * Helper to quickly create an RGBA rendering surface of a certain size.
 * \param textureOut  returns the new texture
 * \param surfaceOut  returns the new surface
 * \return TRUE for success, FALSE if failure
d65 43
a107 26
boolean
util_create_rgba_surface(struct pipe_context *pipe,
                         uint width, uint height,
                         uint bind,
                         struct pipe_resource **textureOut,
                         struct pipe_surface **surfaceOut)
{
   static const enum pipe_format rgbaFormats[] = {
      PIPE_FORMAT_B8G8R8A8_UNORM,
      PIPE_FORMAT_A8R8G8B8_UNORM,
      PIPE_FORMAT_A8B8G8R8_UNORM,
      PIPE_FORMAT_NONE
   };
   const uint target = PIPE_TEXTURE_2D;
   enum pipe_format format = PIPE_FORMAT_NONE;
   struct pipe_resource templ;
   struct pipe_surface surf_templ;
   struct pipe_screen *screen = pipe->screen;
   uint i;

   /* Choose surface format */
   for (i = 0; rgbaFormats[i]; i++) {
      if (screen->is_format_supported(screen, rgbaFormats[i],
                                      target, 0, bind)) {
         format = rgbaFormats[i];
         break;
d110 1
a110 2
   if (format == PIPE_FORMAT_NONE)
      return FALSE;  /* unable to get an rgba format!?! */
a111 10
   /* create texture */
   memset(&templ, 0, sizeof(templ));
   templ.target = target;
   templ.format = format;
   templ.last_level = 0;
   templ.width0 = width;
   templ.height0 = height;
   templ.depth0 = 1;
   templ.array_size = 1;
   templ.bind = bind;
d113 26
a138 3
   *textureOut = screen->resource_create(screen, &templ);
   if (!*textureOut)
      return FALSE;
d140 2
a141 10
   /* create surface */
   memset(&surf_templ, 0, sizeof(surf_templ));
   u_surface_default_template(&surf_templ, *textureOut, bind);
   /* create surface / view into texture */
   *surfaceOut = pipe->create_surface(pipe,
                                      *textureOut,
                                      &surf_templ);
   if (!*surfaceOut) {
      pipe_resource_reference(textureOut, NULL);
      return FALSE;
d143 1
d145 69
a213 1
   return TRUE;
a216 3
/**
 * Release the surface and texture from util_create_rgba_surface().
 */
d218 11
a228 2
util_destroy_rgba_surface(struct pipe_resource *texture,
                          struct pipe_surface *surface)
d230 8
a237 2
   pipe_surface_reference(&surface, NULL);
   pipe_resource_reference(&texture, NULL);
a240 1

d255 2
a256 2
   void *dst_map;
   const void *src_map;
d258 1
a258 2
   unsigned w = src_box->width;
   unsigned h = src_box->height;
d261 3
a266 3
   if (!src || !dst)
      return;

a269 14
   src_trans = pipe_get_transfer(pipe,
                                 src,
                                 src_level,
                                 src_box->z,
                                 PIPE_TRANSFER_READ,
                                 src_box->x, src_box->y, w, h);

   dst_trans = pipe_get_transfer(pipe,
                                 dst,
                                 dst_level,
                                 dst_z,
                                 PIPE_TRANSFER_WRITE,
                                 dst_x, dst_y, w, h);

d274 9
a282 2
   src_map = pipe->transfer_map(pipe, src_trans);
   dst_map = pipe->transfer_map(pipe, dst_trans);
d284 12
a295 1
   assert(src_map);
d297 3
d301 13
a313 14
   if (src_map && dst_map) {
      if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
         memcpy(dst_map, src_map, w);
      } else {
         util_copy_rect(dst_map,
                        dst_format,
                        dst_trans->stride,
                        0, 0,
                        w, h,
                        src_map,
                        src_trans->stride,
                        0,
                        0);
      }
d316 2
d319 2
a320 4
   pipe->transfer_unmap(pipe, dst_trans);

   pipe->transfer_destroy(pipe, src_trans);
   pipe->transfer_destroy(pipe, dst_trans);
d334 1
d339 1
a339 1
                         const float *rgba,
d344 1
a344 1
   void *dst_map;
d346 1
a350 7
   /* XXX: should handle multiple layers */
   dst_trans = pipe_get_transfer(pipe,
                                 dst->texture,
                                 dst->u.tex.level,
                                 dst->u.tex.first_layer,
                                 PIPE_TRANSFER_WRITE,
                                 dstx, dsty, width, height);
d352 26
a377 1
   dst_map = pipe->transfer_map(pipe, dst_trans);
d382 1
d385 23
a407 4
      util_pack_color(rgba, dst->texture->format, &uc);
      util_fill_rect(dst_map, dst->texture->format,
                     dst_trans->stride,
                     0, 0, width, height, &uc);
a408 3

   pipe->transfer_unmap(pipe, dst_trans);
   pipe->transfer_destroy(pipe, dst_trans);
d416 1
d427 1
d431 1
d435 1
a435 1
       util_format_is_depth_and_stencil(dst->format))
a440 9
   dst_trans = pipe_get_transfer(pipe,
                                 dst->texture,
                                 dst->u.tex.level,
                                 dst->u.tex.first_layer,
                                 (need_rmw ? PIPE_TRANSFER_READ_WRITE :
                                     PIPE_TRANSFER_WRITE),
                                 dstx, dsty, width, height);

   dst_map = pipe->transfer_map(pipe, dst_trans);
d442 8
d454 2
a455 1
      unsigned zstencil = util_pack_z_stencil(dst->texture->format, depth, stencil);
d459 13
a471 9
      switch (util_format_get_blocksize(dst->format)) {
      case 1:
         assert(dst->format == PIPE_FORMAT_S8_USCALED);
         if(dst_stride == width)
            memset(dst_map, (ubyte) zstencil, height * width);
         else {
            for (i = 0; i < height; i++) {
               memset(dst_map, (ubyte) zstencil, width);
               dst_map += dst_stride;
d473 3
a475 13
         }
         break;
      case 2:
         assert(dst->format == PIPE_FORMAT_Z16_UNORM);
         for (i = 0; i < height; i++) {
            uint16_t *row = (uint16_t *)dst_map;
            for (j = 0; j < width; j++)
               *row++ = (uint16_t) zstencil;
            dst_map += dst_stride;
            }
         break;
      case 4:
         if (!need_rmw) {
d477 1
a477 1
               uint32_t *row = (uint32_t *)dst_map;
d479 1
a479 1
                  *row++ = zstencil;
d481 10
a491 5
         }
         else {
            uint32_t dst_mask;
            if (dst->format == PIPE_FORMAT_Z24_UNORM_S8_USCALED)
               dst_mask = 0xffffff00;
d493 27
a519 2
               assert(dst->format == PIPE_FORMAT_S8_USCALED_Z24_UNORM);
               dst_mask = 0xffffff;
d521 15
a535 7
            if (clear_flags & PIPE_CLEAR_DEPTH)
               dst_mask = ~dst_mask;
            for (i = 0; i < height; i++) {
               uint32_t *row = (uint32_t *)dst_map;
               for (j = 0; j < width; j++) {
                  uint32_t tmp = *row & dst_mask;
                  *row++ = tmp | (zstencil & ~dst_mask);
a536 1
               dst_map += dst_stride;
d538 4
d543 1
a543 5
        break;
      case 8:
      default:
         assert(0);
         break;
d545 59
d606 78
a683 2
   pipe->transfer_unmap(pipe, dst_trans);
   pipe->transfer_destroy(pipe, dst_trans);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d87 1
a87 1
                                      target, 0, bind, 0)) {
d160 3
d194 13
a206 9
      util_copy_rect(dst_map,
                     dst_format,
                     dst_trans->stride,
                     0, 0,
                     w, h,
                     src_map,
                     src_trans->stride,
                     0,
                     0);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d35 1
d38 2
a39 1
#include "pipe/p_defines.h"
d41 1
a41 2

#include "util/u_memory.h"
d43 1
d45 12
d65 1
a65 1
util_create_rgba_surface(struct pipe_screen *screen,
d67 2
a68 1
                         struct pipe_texture **textureOut,
a77 1
   const uint usage = PIPE_TEXTURE_USAGE_RENDER_TARGET;
d79 3
a81 1
   struct pipe_texture templ;
d87 1
a87 1
                                      target, usage, 0)) {
d103 2
a104 1
   templ.tex_usage = usage;
d106 1
a106 1
   *textureOut = screen->texture_create(screen, &templ);
d110 3
d114 3
a116 1
   *surfaceOut = screen->get_tex_surface(screen, *textureOut, 0, 0, 0, PIPE_BUFFER_USAGE_GPU_WRITE);
d118 1
a118 1
      pipe_texture_reference(textureOut, NULL);
d130 1
a130 1
util_destroy_rgba_surface(struct pipe_texture *texture,
d134 1
a134 1
   pipe_texture_reference(&texture, NULL);
d140 2
a141 2
 * Compare pipe_framebuffer_state objects.
 * \return TRUE if same, FALSE if different
d143 8
a150 3
boolean
util_framebuffer_state_equal(const struct pipe_framebuffer_state *dst,
                             const struct pipe_framebuffer_state *src)
d152 49
a200 1
   unsigned i;
d202 2
a203 3
   if (dst->width != src->width ||
       dst->height != src->height)
      return FALSE;
d205 3
a207 5
   for (i = 0; i < Elements(src->cbufs); i++) {
      if (dst->cbufs[i] != src->cbufs[i]) {
         return FALSE;
      }
   }
a208 3
   if (dst->nr_cbufs != src->nr_cbufs) {
      return FALSE;
   }
a209 3
   if (dst->zsbuf != src->zsbuf) {
      return FALSE;
   }
d211 1
a211 2
   return TRUE;
}
d215 5
a219 1
 * Copy framebuffer state from src to dst, updating refcounts.
d222 5
a226 2
util_copy_framebuffer_state(struct pipe_framebuffer_state *dst,
                            const struct pipe_framebuffer_state *src)
d228 26
a253 7
   unsigned i;

   dst->width = src->width;
   dst->height = src->height;

   for (i = 0; i < Elements(src->cbufs); i++) {
      pipe_surface_reference(&dst->cbufs[i], src->cbufs[i]);
d256 2
a257 3
   dst->nr_cbufs = src->nr_cbufs;

   pipe_surface_reference(&dst->zsbuf, src->zsbuf);
d260 6
a265 1

d267 7
a273 1
util_unreference_framebuffer_state(struct pipe_framebuffer_state *fb)
d275 85
a359 4
   unsigned i;

   for (i = 0; i < fb->nr_cbufs; i++) {
      pipe_surface_reference(&fb->cbufs[i], NULL);
d362 2
a363 4
   pipe_surface_reference(&fb->zsbuf, NULL);

   fb->width = fb->height = 0;
   fb->nr_cbufs = 0;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a34 1
#include "pipe/p_defines.h"
d37 2
d40 1
a40 3
#include "util/u_format.h"
#include "util/u_inlines.h"
#include "util/u_rect.h"
a41 1
#include "util/u_pack_color.h"
a42 12
void
u_surface_default_template(struct pipe_surface *view,
                           const struct pipe_resource *texture,
                           unsigned bind)
{
   view->format = texture->format;
   view->u.tex.level = 0;
   view->u.tex.first_layer = 0;
   view->u.tex.last_layer = 0;
   /* XXX should filter out all non-rt/ds bind flags ? */
   view->usage = bind;
}
d51 1
a51 1
util_create_rgba_surface(struct pipe_context *pipe,
d53 1
a53 2
                         uint bind,
                         struct pipe_resource **textureOut,
d63 1
d65 1
a65 3
   struct pipe_resource templ;
   struct pipe_surface surf_templ;
   struct pipe_screen *screen = pipe->screen;
d71 1
a71 1
                                      target, 0, bind, 0)) {
d87 1
a87 2
   templ.array_size = 1;
   templ.bind = bind;
d89 1
a89 1
   *textureOut = screen->resource_create(screen, &templ);
a92 3
   /* create surface */
   memset(&surf_templ, 0, sizeof(surf_templ));
   u_surface_default_template(&surf_templ, *textureOut, bind);
d94 1
a94 3
   *surfaceOut = pipe->create_surface(pipe,
                                      *textureOut,
                                      &surf_templ);
d96 1
a96 1
      pipe_resource_reference(textureOut, NULL);
d108 1
a108 1
util_destroy_rgba_surface(struct pipe_resource *texture,
d112 1
a112 1
   pipe_resource_reference(&texture, NULL);
d118 2
a119 2
 * Fallback function for pipe->resource_copy_region().
 * Note: (X,Y)=(0,0) is always the upper-left corner.
d121 3
a123 8
void
util_resource_copy_region(struct pipe_context *pipe,
                          struct pipe_resource *dst,
                          unsigned dst_level,
                          unsigned dst_x, unsigned dst_y, unsigned dst_z,
                          struct pipe_resource *src,
                          unsigned src_level,
                          const struct pipe_box *src_box)
d125 1
a125 49
   struct pipe_transfer *src_trans, *dst_trans;
   void *dst_map;
   const void *src_map;
   enum pipe_format src_format, dst_format;
   unsigned w = src_box->width;
   unsigned h = src_box->height;

   assert(src && dst);
   if (!src || !dst)
      return;

   src_format = src->format;
   dst_format = dst->format;

   src_trans = pipe_get_transfer(pipe,
                                 src,
                                 src_level,
                                 src_box->z,
                                 PIPE_TRANSFER_READ,
                                 src_box->x, src_box->y, w, h);

   dst_trans = pipe_get_transfer(pipe,
                                 dst,
                                 dst_level,
                                 dst_z,
                                 PIPE_TRANSFER_WRITE,
                                 dst_x, dst_y, w, h);

   assert(util_format_get_blocksize(dst_format) == util_format_get_blocksize(src_format));
   assert(util_format_get_blockwidth(dst_format) == util_format_get_blockwidth(src_format));
   assert(util_format_get_blockheight(dst_format) == util_format_get_blockheight(src_format));

   src_map = pipe->transfer_map(pipe, src_trans);
   dst_map = pipe->transfer_map(pipe, dst_trans);

   assert(src_map);
   assert(dst_map);

   if (src_map && dst_map) {
      util_copy_rect(dst_map,
                     dst_format,
                     dst_trans->stride,
                     0, 0,
                     w, h,
                     src_map,
                     src_trans->stride,
                     0,
                     0);
   }
d127 3
a129 2
   pipe->transfer_unmap(pipe, src_trans);
   pipe->transfer_unmap(pipe, dst_trans);
d131 5
a135 3
   pipe->transfer_destroy(pipe, src_trans);
   pipe->transfer_destroy(pipe, dst_trans);
}
d137 3
d141 3
d145 2
a146 1
#define UBYTE_TO_USHORT(B) ((B) | ((B) << 8))
d150 1
a150 5
 * Fallback for pipe->clear_render_target() function.
 * XXX this looks too hackish to be really useful.
 * cpp > 4 looks like a gross hack at best...
 * Plus can't use these transfer fallbacks when clearing
 * multisampled surfaces for instance.
d153 2
a154 5
util_clear_render_target(struct pipe_context *pipe,
                         struct pipe_surface *dst,
                         const float *rgba,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
d156 7
a162 26
   struct pipe_transfer *dst_trans;
   void *dst_map;
   union util_color uc;

   assert(dst->texture);
   if (!dst->texture)
      return;
   /* XXX: should handle multiple layers */
   dst_trans = pipe_get_transfer(pipe,
                                 dst->texture,
                                 dst->u.tex.level,
                                 dst->u.tex.first_layer,
                                 PIPE_TRANSFER_WRITE,
                                 dstx, dsty, width, height);

   dst_map = pipe->transfer_map(pipe, dst_trans);

   assert(dst_map);

   if (dst_map) {
      assert(dst_trans->stride > 0);

      util_pack_color(rgba, dst->texture->format, &uc);
      util_fill_rect(dst_map, dst->texture->format,
                     dst_trans->stride,
                     0, 0, width, height, &uc);
d165 3
a167 2
   pipe->transfer_unmap(pipe, dst_trans);
   pipe->transfer_destroy(pipe, dst_trans);
d170 1
a170 6
/**
 * Fallback for pipe->clear_stencil() function.
 * sw fallback doesn't look terribly useful here.
 * Plus can't use these transfer fallbacks when clearing
 * multisampled surfaces for instance.
 */
d172 1
a172 7
util_clear_depth_stencil(struct pipe_context *pipe,
                         struct pipe_surface *dst,
                         unsigned clear_flags,
                         double depth,
                         unsigned stencil,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
d174 4
a177 85
   struct pipe_transfer *dst_trans;
   ubyte *dst_map;
   boolean need_rmw = FALSE;

   if ((clear_flags & PIPE_CLEAR_DEPTHSTENCIL) &&
       ((clear_flags & PIPE_CLEAR_DEPTHSTENCIL) != PIPE_CLEAR_DEPTHSTENCIL) &&
       util_format_is_depth_and_stencil(dst->format))
      need_rmw = TRUE;

   assert(dst->texture);
   if (!dst->texture)
      return;
   dst_trans = pipe_get_transfer(pipe,
                                 dst->texture,
                                 dst->u.tex.level,
                                 dst->u.tex.first_layer,
                                 (need_rmw ? PIPE_TRANSFER_READ_WRITE :
                                     PIPE_TRANSFER_WRITE),
                                 dstx, dsty, width, height);

   dst_map = pipe->transfer_map(pipe, dst_trans);

   assert(dst_map);

   if (dst_map) {
      unsigned dst_stride = dst_trans->stride;
      unsigned zstencil = util_pack_z_stencil(dst->texture->format, depth, stencil);
      unsigned i, j;
      assert(dst_trans->stride > 0);

      switch (util_format_get_blocksize(dst->format)) {
      case 1:
         assert(dst->format == PIPE_FORMAT_S8_USCALED);
         if(dst_stride == width)
            memset(dst_map, (ubyte) zstencil, height * width);
         else {
            for (i = 0; i < height; i++) {
               memset(dst_map, (ubyte) zstencil, width);
               dst_map += dst_stride;
            }
         }
         break;
      case 2:
         assert(dst->format == PIPE_FORMAT_Z16_UNORM);
         for (i = 0; i < height; i++) {
            uint16_t *row = (uint16_t *)dst_map;
            for (j = 0; j < width; j++)
               *row++ = (uint16_t) zstencil;
            dst_map += dst_stride;
            }
         break;
      case 4:
         if (!need_rmw) {
            for (i = 0; i < height; i++) {
               uint32_t *row = (uint32_t *)dst_map;
               for (j = 0; j < width; j++)
                  *row++ = zstencil;
               dst_map += dst_stride;
            }
         }
         else {
            uint32_t dst_mask;
            if (dst->format == PIPE_FORMAT_Z24_UNORM_S8_USCALED)
               dst_mask = 0xffffff00;
            else {
               assert(dst->format == PIPE_FORMAT_S8_USCALED_Z24_UNORM);
               dst_mask = 0xffffff;
            }
            if (clear_flags & PIPE_CLEAR_DEPTH)
               dst_mask = ~dst_mask;
            for (i = 0; i < height; i++) {
               uint32_t *row = (uint32_t *)dst_map;
               for (j = 0; j < width; j++) {
                  uint32_t tmp = *row & dst_mask;
                  *row++ = tmp | (zstencil & ~dst_mask);
               }
               dst_map += dst_stride;
            }
         }
        break;
      case 8:
      default:
         assert(0);
         break;
      }
d180 4
a183 2
   pipe->transfer_unmap(pipe, dst_trans);
   pipe->transfer_destroy(pipe, dst_trans);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a44 5

/**
 * Initialize a pipe_surface object.  'view' is considered to have
 * uninitialized contents.
 */
d46 10
a55 6
u_surface_default_template(struct pipe_surface *surf,
                           const struct pipe_resource *texture)
{
   memset(surf, 0, sizeof(*surf));

   surf->format = texture->format;
a57 1

d59 4
a62 3
 * Copy 2D rect from one place to another.
 * Position and sizes are in pixels.
 * src_stride may be negative to do vertical flip of pixels from source.
d64 26
a89 43
void
util_copy_rect(ubyte * dst,
               enum pipe_format format,
               unsigned dst_stride,
               unsigned dst_x,
               unsigned dst_y,
               unsigned width,
               unsigned height,
               const ubyte * src,
               int src_stride,
               unsigned src_x,
               unsigned src_y)
{
   unsigned i;
   int src_stride_pos = src_stride < 0 ? -src_stride : src_stride;
   int blocksize = util_format_get_blocksize(format);
   int blockwidth = util_format_get_blockwidth(format);
   int blockheight = util_format_get_blockheight(format);

   assert(blocksize > 0);
   assert(blockwidth > 0);
   assert(blockheight > 0);

   dst_x /= blockwidth;
   dst_y /= blockheight;
   width = (width + blockwidth - 1)/blockwidth;
   height = (height + blockheight - 1)/blockheight;
   src_x /= blockwidth;
   src_y /= blockheight;

   dst += dst_x * blocksize;
   src += src_x * blocksize;
   dst += dst_y * dst_stride;
   src += src_y * src_stride_pos;
   width *= blocksize;

   if (width == dst_stride && width == src_stride)
      memcpy(dst, src, height * width);
   else {
      for (i = 0; i < height; i++) {
         memcpy(dst, src, width);
         dst += dst_stride;
         src += src_stride;
d92 2
a93 1
}
d95 10
d106 3
a108 26
/**
 * Copy 3D box from one place to another.
 * Position and sizes are in pixels.
 */
void
util_copy_box(ubyte * dst,
              enum pipe_format format,
              unsigned dst_stride, unsigned dst_slice_stride,
              unsigned dst_x, unsigned dst_y, unsigned dst_z,
              unsigned width, unsigned height, unsigned depth,
              const ubyte * src,
              int src_stride, unsigned src_slice_stride,
              unsigned src_x, unsigned src_y, unsigned src_z)
{
   unsigned z;
   dst += dst_z * dst_slice_stride;
   src += src_z * src_slice_stride;
   for (z = 0; z < depth; ++z) {
      util_copy_rect(dst,
                     format,
                     dst_stride,
                     dst_x, dst_y,
                     width, height,
                     src,
                     src_stride,
                     src_x, src_y);
d110 10
a119 2
      dst += dst_slice_stride;
      src += src_slice_stride;
d121 2
d126 3
d130 2
a131 8
util_fill_rect(ubyte * dst,
               enum pipe_format format,
               unsigned dst_stride,
               unsigned dst_x,
               unsigned dst_y,
               unsigned width,
               unsigned height,
               union util_color *uc)
d133 2
a134 58
   const struct util_format_description *desc = util_format_description(format);
   unsigned i, j;
   unsigned width_size;
   int blocksize = desc->block.bits / 8;
   int blockwidth = desc->block.width;
   int blockheight = desc->block.height;

   assert(blocksize > 0);
   assert(blockwidth > 0);
   assert(blockheight > 0);

   dst_x /= blockwidth;
   dst_y /= blockheight;
   width = (width + blockwidth - 1)/blockwidth;
   height = (height + blockheight - 1)/blockheight;

   dst += dst_x * blocksize;
   dst += dst_y * dst_stride;
   width_size = width * blocksize;

   switch (blocksize) {
   case 1:
      if(dst_stride == width_size)
         memset(dst, uc->ub, height * width_size);
      else {
         for (i = 0; i < height; i++) {
            memset(dst, uc->ub, width_size);
            dst += dst_stride;
         }
      }
      break;
   case 2:
      for (i = 0; i < height; i++) {
         uint16_t *row = (uint16_t *)dst;
         for (j = 0; j < width; j++)
            *row++ = uc->us;
         dst += dst_stride;
      }
      break;
   case 4:
      for (i = 0; i < height; i++) {
         uint32_t *row = (uint32_t *)dst;
         for (j = 0; j < width; j++)
            *row++ = uc->ui;
         dst += dst_stride;
      }
      break;
   default:
      for (i = 0; i < height; i++) {
         ubyte *row = dst;
         for (j = 0; j < width; j++) {
            memcpy(row, uc, blocksize);
            row += blocksize;
         }
         dst += dst_stride;
      }
      break;
   }
a137 23
void
util_fill_box(ubyte * dst,
              enum pipe_format format,
              unsigned stride,
              unsigned layer_stride,
              unsigned x,
              unsigned y,
              unsigned z,
              unsigned width,
              unsigned height,
              unsigned depth,
              union util_color *uc)
{
   unsigned layer;
   dst += z * layer_stride;
   for (layer = z; layer < depth; layer++) {
      util_fill_rect(dst, format,
                     stride,
                     x, y, width, height, uc);
      dst += layer_stride;
   }
}

d153 2
a154 2
   uint8_t *dst_map;
   const uint8_t *src_map;
d156 2
a157 1
   struct pipe_box dst_box;
a162 3
   assert((src->target == PIPE_BUFFER && dst->target == PIPE_BUFFER) ||
          (src->target != PIPE_BUFFER && dst->target != PIPE_BUFFER));

d166 14
d184 3
a186 5
   src_map = pipe->transfer_map(pipe,
                                src,
                                src_level,
                                PIPE_TRANSFER_READ,
                                src_box, &src_trans);
a187 16
   if (!src_map) {
      goto no_src_map;
   }

   dst_box.x = dst_x;
   dst_box.y = dst_y;
   dst_box.z = dst_z;
   dst_box.width  = src_box->width;
   dst_box.height = src_box->height;
   dst_box.depth  = src_box->depth;

   dst_map = pipe->transfer_map(pipe,
                                dst,
                                dst_level,
                                PIPE_TRANSFER_WRITE | PIPE_TRANSFER_DISCARD_RANGE,
                                &dst_box, &dst_trans);
a188 3
   if (!dst_map) {
      goto no_dst_map;
   }
d190 10
a199 13
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      assert(src_box->height == 1);
      assert(src_box->depth == 1);
      memcpy(dst_map, src_map, src_box->width);
   } else {
      util_copy_box(dst_map,
                    dst_format,
                    dst_trans->stride, dst_trans->layer_stride,
                    0, 0, 0,
                    src_box->width, src_box->height, src_box->depth,
                    src_map,
                    src_trans->stride, src_trans->layer_stride,
                    0, 0, 0);
d202 1
d204 3
a206 4
no_dst_map:
   pipe->transfer_unmap(pipe, src_trans);
no_src_map:
   ;
a219 1
 * Clears all bound layers.
d224 1
a224 1
                         const union pipe_color_union *color,
d229 1
a229 1
   ubyte *dst_map;
a230 1
   unsigned max_layer;
d235 7
d243 1
a243 26
   if (dst->texture->target == PIPE_BUFFER) {
      /*
       * The fill naturally works on the surface format, however
       * the transfer uses resource format which is just bytes for buffers.
       */
      unsigned dx, w;
      unsigned pixstride = util_format_get_blocksize(dst->format);
      dx = (dst->u.buf.first_element + dstx) * pixstride;
      w = width * pixstride;
      max_layer = 0;
      dst_map = pipe_transfer_map(pipe,
                                  dst->texture,
                                  0, 0,
                                  PIPE_TRANSFER_WRITE,
                                  dx, 0, w, 1,
                                  &dst_trans);
   }
   else {
      max_layer = dst->u.tex.last_layer - dst->u.tex.first_layer;
      dst_map = pipe_transfer_map_3d(pipe,
                                     dst->texture,
                                     dst->u.tex.level,
                                     PIPE_TRANSFER_WRITE,
                                     dstx, dsty, dst->u.tex.first_layer,
                                     width, height, max_layer + 1, &dst_trans);
   }
a247 1
      enum pipe_format format = dst->format;
d250 5
a254 17
      if (util_format_is_pure_integer(format)) {
         /*
          * We expect int/uint clear values here, though some APIs
          * might disagree (but in any case util_pack_color()
          * couldn't handle it)...
          */
         if (util_format_is_pure_sint(format)) {
            util_format_write_4i(format, color->i, 0, &uc, 0, 0, 0, 1, 1);
         }
         else {
            assert(util_format_is_pure_uint(format));
            util_format_write_4ui(format, color->ui, 0, &uc, 0, 0, 0, 1, 1);
         }
      }
      else {
         util_pack_color(color->f, dst->format, &uc);
      }
d256 2
a257 6
      util_fill_box(dst_map, dst->format,
                    dst_trans->stride, dst_trans->layer_stride,
                    0, 0, 0, width, height, max_layer + 1, &uc);

      pipe->transfer_unmap(pipe, dst_trans);
   }
a264 1
 * Clears all bound layers.
a274 1
   enum pipe_format format = dst->format;
a277 1
   unsigned max_layer, layer;
d281 1
a281 1
       util_format_is_depth_and_stencil(format))
d287 9
a296 8
   max_layer = dst->u.tex.last_layer - dst->u.tex.first_layer;
   dst_map = pipe_transfer_map_3d(pipe,
                                  dst->texture,
                                  dst->u.tex.level,
                                  (need_rmw ? PIPE_TRANSFER_READ_WRITE :
                                              PIPE_TRANSFER_WRITE),
                                  dstx, dsty, dst->u.tex.first_layer,
                                  width, height, max_layer + 1, &dst_trans);
d301 1
a301 2
      uint64_t zstencil = util_pack64_z_stencil(format, depth, stencil);
      ubyte *dst_layer = dst_map;
d305 19
a323 13
      for (layer = 0; layer <= max_layer; layer++) {
         dst_map = dst_layer;

         switch (util_format_get_blocksize(format)) {
         case 1:
            assert(format == PIPE_FORMAT_S8_UINT);
            if(dst_stride == width)
               memset(dst_map, (uint8_t) zstencil, height * width);
            else {
               for (i = 0; i < height; i++) {
                  memset(dst_map, (uint8_t) zstencil, width);
                  dst_map += dst_stride;
               }
d325 3
a327 3
            break;
         case 2:
            assert(format == PIPE_FORMAT_Z16_UNORM);
d329 1
a329 1
               uint16_t *row = (uint16_t *)dst_map;
d331 1
a331 1
                  *row++ = (uint16_t) zstencil;
a332 10
               }
            break;
         case 4:
            if (!need_rmw) {
               for (i = 0; i < height; i++) {
                  uint32_t *row = (uint32_t *)dst_map;
                  for (j = 0; j < width; j++)
                     *row++ = (uint32_t) zstencil;
                  dst_map += dst_stride;
               }
d334 5
d340 2
a341 17
               uint32_t dst_mask;
               if (format == PIPE_FORMAT_Z24_UNORM_S8_UINT)
                  dst_mask = 0x00ffffff;
               else {
                  assert(format == PIPE_FORMAT_S8_UINT_Z24_UNORM);
                  dst_mask = 0xffffff00;
               }
               if (clear_flags & PIPE_CLEAR_DEPTH)
                  dst_mask = ~dst_mask;
               for (i = 0; i < height; i++) {
                  uint32_t *row = (uint32_t *)dst_map;
                  for (j = 0; j < width; j++) {
                     uint32_t tmp = *row & dst_mask;
                     *row++ = tmp | ((uint32_t) zstencil & ~dst_mask);
                  }
                  dst_map += dst_stride;
               }
d343 7
a349 8
            break;
         case 8:
            if (!need_rmw) {
               for (i = 0; i < height; i++) {
                  uint64_t *row = (uint64_t *)dst_map;
                  for (j = 0; j < width; j++)
                     *row++ = zstencil;
                  dst_map += dst_stride;
d351 1
a352 21
            else {
               uint64_t src_mask;

               if (clear_flags & PIPE_CLEAR_DEPTH)
                  src_mask = 0x00000000ffffffffull;
               else
                  src_mask = 0x000000ff00000000ull;

               for (i = 0; i < height; i++) {
                  uint64_t *row = (uint64_t *)dst_map;
                  for (j = 0; j < width; j++) {
                     uint64_t tmp = *row & ~src_mask;
                     *row++ = tmp | (zstencil & src_mask);
                  }
                  dst_map += dst_stride;
               }
            }
            break;
         default:
            assert(0);
            break;
d354 5
a358 1
         dst_layer += dst_trans->layer_stride;
a359 2

      pipe->transfer_unmap(pipe, dst_trans);
a360 1
}
d362 2
a363 134

/* Return if the box is totally inside the resource.
 */
static boolean
is_box_inside_resource(const struct pipe_resource *res,
                       const struct pipe_box *box,
                       unsigned level)
{
   unsigned width = 1, height = 1, depth = 1;

   switch (res->target) {
   case PIPE_BUFFER:
      width = res->width0;
      height = 1;
      depth = 1;
      break;
   case PIPE_TEXTURE_1D:
      width = u_minify(res->width0, level);
      height = 1;
      depth = 1;
      break;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = 1;
      break;
   case PIPE_TEXTURE_3D:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = u_minify(res->depth0, level);
      break;
   case PIPE_TEXTURE_CUBE:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = 6;
      break;
   case PIPE_TEXTURE_1D_ARRAY:
      width = u_minify(res->width0, level);
      height = 1;
      depth = res->array_size;
      break;
   case PIPE_TEXTURE_2D_ARRAY:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = res->array_size;
      break;
   case PIPE_TEXTURE_CUBE_ARRAY:
      width = u_minify(res->width0, level);
      height = u_minify(res->height0, level);
      depth = res->array_size;
      assert(res->array_size % 6 == 0);
      break;
   case PIPE_MAX_TEXTURE_TYPES:;
   }

   return box->x >= 0 &&
          box->x + box->width <= (int) width &&
          box->y >= 0 &&
          box->y + box->height <= (int) height &&
          box->z >= 0 &&
          box->z + box->depth <= (int) depth;
}

static unsigned
get_sample_count(const struct pipe_resource *res)
{
   return res->nr_samples ? res->nr_samples : 1;
}

/**
 * Try to do a blit using resource_copy_region. The function calls
 * resource_copy_region if the blit description is compatible with it.
 *
 * It returns TRUE if the blit was done using resource_copy_region.
 *
 * It returns FALSE otherwise and the caller must fall back to a more generic
 * codepath for the blit operation. (e.g. by using u_blitter)
 */
boolean
util_try_blit_via_copy_region(struct pipe_context *ctx,
                              const struct pipe_blit_info *blit)
{
   unsigned mask = util_format_get_mask(blit->dst.format);

   /* No format conversions. */
   if (blit->src.resource->format != blit->src.format ||
       blit->dst.resource->format != blit->dst.format ||
       !util_is_format_compatible(
          util_format_description(blit->src.resource->format),
          util_format_description(blit->dst.resource->format))) {
      return FALSE;
   }

   /* No masks, no filtering, no scissor. */
   if ((blit->mask & mask) != mask ||
       blit->filter != PIPE_TEX_FILTER_NEAREST ||
       blit->scissor_enable) {
      return FALSE;
   }

   /* No flipping. */
   if (blit->src.box.width < 0 ||
       blit->src.box.height < 0 ||
       blit->src.box.depth < 0) {
      return FALSE;
   }

   /* No scaling. */
   if (blit->src.box.width != blit->dst.box.width ||
       blit->src.box.height != blit->dst.box.height ||
       blit->src.box.depth != blit->dst.box.depth) {
      return FALSE;
   }

   /* No out-of-bounds access. */
   if (!is_box_inside_resource(blit->src.resource, &blit->src.box,
                               blit->src.level) ||
       !is_box_inside_resource(blit->dst.resource, &blit->dst.box,
                               blit->dst.level)) {
      return FALSE;
   }

   /* Sample counts must match. */
   if (get_sample_count(blit->src.resource) !=
       get_sample_count(blit->dst.resource)) {
      return FALSE;
   }

   ctx->resource_copy_region(ctx, blit->dst.resource, blit->dst.level,
                             blit->dst.box.x, blit->dst.box.y, blit->dst.box.z,
                             blit->src.resource, blit->src.level,
                             &blit->src.box);
   return TRUE;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d199 1
a199 1
            *row++ = uc->ui[0];
@


