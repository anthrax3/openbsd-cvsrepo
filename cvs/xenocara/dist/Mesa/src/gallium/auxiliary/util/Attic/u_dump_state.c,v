head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2013.09.05.13.59.49;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.47;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.06.41;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.43.48;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008-2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "pipe/p_compiler.h"
#include "util/u_memory.h"
#include "util/u_string.h"
#include "util/u_format.h"
#include "tgsi/tgsi_dump.h"

#include "u_dump.h"


/*
 * Dump primitives
 */

static INLINE void
util_stream_writef(FILE *stream, const char *format, ...)
{
   static char buf[1024];
   unsigned len;
   va_list ap;
   va_start(ap, format);
   len = util_vsnprintf(buf, sizeof(buf), format, ap);
   va_end(ap);
   fwrite(buf, len, 1, stream);
}

static void
util_dump_bool(FILE *stream, int value)
{
   util_stream_writef(stream, "%c", value ? '1' : '0');
}

static void
util_dump_int(FILE *stream, long long int value)
{
   util_stream_writef(stream, "%lli", value);
}

static void
util_dump_uint(FILE *stream, long long unsigned value)
{
   util_stream_writef(stream, "%llu", value);
}

static void
util_dump_float(FILE *stream, double value)
{
   util_stream_writef(stream, "%g", value);
}

static void
util_dump_string(FILE *stream, const char *str)
{
   fputs("\"", stream);
   fputs(str, stream);
   fputs("\"", stream);
}

static void
util_dump_enum(FILE *stream, const char *value)
{
   fputs(value, stream);
}

static void
util_dump_array_begin(FILE *stream)
{
   fputs("{", stream);
}

static void
util_dump_array_end(FILE *stream)
{
   fputs("}", stream);
}

static void
util_dump_elem_begin(FILE *stream)
{
}

static void
util_dump_elem_end(FILE *stream)
{
   fputs(", ", stream);
}

static void
util_dump_struct_begin(FILE *stream, const char *name)
{
   fputs("{", stream);
}

static void
util_dump_struct_end(FILE *stream)
{
   fputs("}", stream);
}

static void
util_dump_member_begin(FILE *stream, const char *name)
{
   util_stream_writef(stream, "%s = ", name);
}

static void
util_dump_member_end(FILE *stream)
{
   fputs(", ", stream);
}

static void
util_dump_null(FILE *stream)
{
   fputs("NULL", stream);
}

static void
util_dump_ptr(FILE *stream, const void *value)
{
   if(value)
      util_stream_writef(stream, "0x%08lx", (unsigned long)(uintptr_t)value);
   else
      util_dump_null(stream);
}


/*
 * Code saving macros.
 */

#define util_dump_arg(_stream, _type, _arg) \
   do { \
      util_dump_arg_begin(_stream, #_arg); \
      util_dump_##_type(_stream, _arg); \
      util_dump_arg_end(_stream); \
   } while(0)

#define util_dump_ret(_stream, _type, _arg) \
   do { \
      util_dump_ret_begin(_stream); \
      util_dump_##_type(_stream, _arg); \
      util_dump_ret_end(_stream); \
   } while(0)

#define util_dump_array(_stream, _type, _obj, _size) \
   do { \
      size_t idx; \
      util_dump_array_begin(_stream); \
      for(idx = 0; idx < (_size); ++idx) { \
         util_dump_elem_begin(_stream); \
         util_dump_##_type(_stream, (_obj)[idx]); \
         util_dump_elem_end(_stream); \
      } \
      util_dump_array_end(_stream); \
   } while(0)

#define util_dump_struct_array(_stream, _type, _obj, _size) \
   do { \
      size_t idx; \
      util_dump_array_begin(_stream); \
      for(idx = 0; idx < (_size); ++idx) { \
         util_dump_elem_begin(_stream); \
         util_dump_##_type(_stream, &(_obj)[idx]); \
         util_dump_elem_end(_stream); \
      } \
      util_dump_array_end(_stream); \
   } while(0)

#define util_dump_member(_stream, _type, _obj, _member) \
   do { \
      util_dump_member_begin(_stream, #_member); \
      util_dump_##_type(_stream, (_obj)->_member); \
      util_dump_member_end(_stream); \
   } while(0)

#define util_dump_arg_array(_stream, _type, _arg, _size) \
   do { \
      util_dump_arg_begin(_stream, #_arg); \
      util_dump_array(_stream, _type, _arg, _size); \
      util_dump_arg_end(_stream); \
   } while(0)

#define util_dump_member_array(_stream, _type, _obj, _member) \
   do { \
      util_dump_member_begin(_stream, #_member); \
      util_dump_array(_stream, _type, (_obj)->_member, sizeof((_obj)->_member)/sizeof((_obj)->_member[0])); \
      util_dump_member_end(_stream); \
   } while(0)



/*
 * Wrappers for enum -> string dumpers.
 */


static void
util_dump_format(FILE *stream, enum pipe_format format)
{
   util_dump_enum(stream, util_format_name(format));
}


static void
util_dump_enum_blend_factor(FILE *stream, unsigned value)
{
   util_dump_enum(stream, util_dump_blend_factor(value, TRUE));
}

static void
util_dump_enum_blend_func(FILE *stream, unsigned value)
{
   util_dump_enum(stream, util_dump_blend_func(value, TRUE));
}

static void
util_dump_enum_func(FILE *stream, unsigned value)
{
   util_dump_enum(stream, util_dump_func(value, TRUE));
}


/*
 * Public functions
 */


void
util_dump_template(FILE *stream, const struct pipe_resource *templat)
{
   if(!templat) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_resource");

   util_dump_member(stream, int, templat, target);
   util_dump_member(stream, format, templat, format);

   util_dump_member_begin(stream, "width");
   util_dump_uint(stream, templat->width0);
   util_dump_member_end(stream);

   util_dump_member_begin(stream, "height");
   util_dump_uint(stream, templat->height0);
   util_dump_member_end(stream);

   util_dump_member_begin(stream, "depth");
   util_dump_uint(stream, templat->depth0);
   util_dump_member_end(stream);

   util_dump_member_begin(stream, "array_size");
   util_dump_uint(stream, templat->array_size);
   util_dump_member_end(stream);

   util_dump_member(stream, uint, templat, last_level);
   util_dump_member(stream, uint, templat, usage);
   util_dump_member(stream, uint, templat, bind);
   util_dump_member(stream, uint, templat, flags);

   util_dump_struct_end(stream);
}


void
util_dump_rasterizer_state(FILE *stream, const struct pipe_rasterizer_state *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_rasterizer_state");

   util_dump_member(stream, bool, state, flatshade);
   util_dump_member(stream, bool, state, light_twoside);
   util_dump_member(stream, bool, state, clamp_vertex_color);
   util_dump_member(stream, bool, state, clamp_fragment_color);
   util_dump_member(stream, uint, state, front_ccw);
   util_dump_member(stream, uint, state, cull_face);
   util_dump_member(stream, uint, state, fill_front);
   util_dump_member(stream, uint, state, fill_back);
   util_dump_member(stream, bool, state, offset_point);
   util_dump_member(stream, bool, state, offset_line);
   util_dump_member(stream, bool, state, offset_tri);
   util_dump_member(stream, bool, state, scissor);
   util_dump_member(stream, bool, state, poly_smooth);
   util_dump_member(stream, bool, state, poly_stipple_enable);
   util_dump_member(stream, bool, state, point_smooth);
   util_dump_member(stream, uint, state, sprite_coord_enable);
   util_dump_member(stream, bool, state, sprite_coord_mode);
   util_dump_member(stream, bool, state, point_quad_rasterization);
   util_dump_member(stream, bool, state, point_size_per_vertex);
   util_dump_member(stream, bool, state, multisample);
   util_dump_member(stream, bool, state, line_smooth);
   util_dump_member(stream, bool, state, line_stipple_enable);
   util_dump_member(stream, uint, state, line_stipple_factor);
   util_dump_member(stream, uint, state, line_stipple_pattern);
   util_dump_member(stream, bool, state, line_last_pixel);
   util_dump_member(stream, bool, state, flatshade_first);
   util_dump_member(stream, bool, state, half_pixel_center);
   util_dump_member(stream, bool, state, bottom_edge_rule);
   util_dump_member(stream, bool, state, rasterizer_discard);
   util_dump_member(stream, bool, state, depth_clip);
   util_dump_member(stream, uint, state, clip_plane_enable);

   util_dump_member(stream, float, state, line_width);
   util_dump_member(stream, float, state, point_size);
   util_dump_member(stream, float, state, offset_units);
   util_dump_member(stream, float, state, offset_scale);
   util_dump_member(stream, float, state, offset_clamp);

   util_dump_struct_end(stream);
}


void
util_dump_poly_stipple(FILE *stream, const struct pipe_poly_stipple *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_poly_stipple");

   util_dump_member_begin(stream, "stipple");
   util_dump_member_array(stream, uint, state, stipple);
   util_dump_member_end(stream);

   util_dump_struct_end(stream);
}


void
util_dump_viewport_state(FILE *stream, const struct pipe_viewport_state *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_viewport_state");

   util_dump_member_array(stream, float, state, scale);
   util_dump_member_array(stream, float, state, translate);

   util_dump_struct_end(stream);
}


void
util_dump_scissor_state(FILE *stream, const struct pipe_scissor_state *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_scissor_state");

   util_dump_member(stream, uint, state, minx);
   util_dump_member(stream, uint, state, miny);
   util_dump_member(stream, uint, state, maxx);
   util_dump_member(stream, uint, state, maxy);

   util_dump_struct_end(stream);
}


void
util_dump_clip_state(FILE *stream, const struct pipe_clip_state *state)
{
   unsigned i;

   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_clip_state");

   util_dump_member_begin(stream, "ucp");
   util_dump_array_begin(stream);
   for(i = 0; i < PIPE_MAX_CLIP_PLANES; ++i) {
      util_dump_elem_begin(stream);
      util_dump_array(stream, float, state->ucp[i], 4);
      util_dump_elem_end(stream);
   }
   util_dump_array_end(stream);
   util_dump_member_end(stream);

   util_dump_struct_end(stream);
}


void
util_dump_shader_state(FILE *stream, const struct pipe_shader_state *state)
{
   char str[8192];
   unsigned i;

   if(!state) {
      util_dump_null(stream);
      return;
   }

   tgsi_dump_str(state->tokens, 0, str, sizeof(str));

   util_dump_struct_begin(stream, "pipe_shader_state");

   util_dump_member_begin(stream, "tokens");
   util_dump_string(stream, str);
   util_dump_member_end(stream);

   util_dump_member_begin(stream, "stream_output");
   util_dump_struct_begin(stream, "pipe_stream_output_info");
   util_dump_member(stream, uint, &state->stream_output, num_outputs);
   util_dump_array(stream, uint, state->stream_output.stride,
                   Elements(state->stream_output.stride));
   util_dump_array_begin(stream);
   for(i = 0; i < state->stream_output.num_outputs; ++i) {
      util_dump_elem_begin(stream);
      util_dump_struct_begin(stream, ""); /* anonymous */
      util_dump_member(stream, uint, &state->stream_output.output[i], register_index);
      util_dump_member(stream, uint, &state->stream_output.output[i], start_component);
      util_dump_member(stream, uint, &state->stream_output.output[i], num_components);
      util_dump_member(stream, uint, &state->stream_output.output[i], output_buffer);
      util_dump_struct_end(stream);
      util_dump_elem_end(stream);
   }
   util_dump_array_end(stream);
   util_dump_struct_end(stream);
   util_dump_member_end(stream);

   util_dump_struct_end(stream);
}


void
util_dump_depth_stencil_alpha_state(FILE *stream, const struct pipe_depth_stencil_alpha_state *state)
{
   unsigned i;

   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_depth_stencil_alpha_state");

   util_dump_member_begin(stream, "depth");
   util_dump_struct_begin(stream, "pipe_depth_state");
   util_dump_member(stream, bool, &state->depth, enabled);
   if (state->depth.enabled) {
      util_dump_member(stream, bool, &state->depth, writemask);
      util_dump_member(stream, enum_func, &state->depth, func);
   }
   util_dump_struct_end(stream);
   util_dump_member_end(stream);

   util_dump_member_begin(stream, "stencil");
   util_dump_array_begin(stream);
   for(i = 0; i < Elements(state->stencil); ++i) {
      util_dump_elem_begin(stream);
      util_dump_struct_begin(stream, "pipe_stencil_state");
      util_dump_member(stream, bool, &state->stencil[i], enabled);
      if (state->stencil[i].enabled) {
         util_dump_member(stream, enum_func, &state->stencil[i], func);
         util_dump_member(stream, uint, &state->stencil[i], fail_op);
         util_dump_member(stream, uint, &state->stencil[i], zpass_op);
         util_dump_member(stream, uint, &state->stencil[i], zfail_op);
         util_dump_member(stream, uint, &state->stencil[i], valuemask);
         util_dump_member(stream, uint, &state->stencil[i], writemask);
      }
      util_dump_struct_end(stream);
      util_dump_elem_end(stream);
   }
   util_dump_array_end(stream);
   util_dump_member_end(stream);

   util_dump_member_begin(stream, "alpha");
   util_dump_struct_begin(stream, "pipe_alpha_state");
   util_dump_member(stream, bool, &state->alpha, enabled);
   if (state->alpha.enabled) {
      util_dump_member(stream, enum_func, &state->alpha, func);
      util_dump_member(stream, float, &state->alpha, ref_value);
   }
   util_dump_struct_end(stream);
   util_dump_member_end(stream);

   util_dump_struct_end(stream);
}

void
util_dump_rt_blend_state(FILE *stream, const struct pipe_rt_blend_state *state)
{
   util_dump_struct_begin(stream, "pipe_rt_blend_state");

   util_dump_member(stream, uint, state, blend_enable);
   if (state->blend_enable) {
      util_dump_member(stream, enum_blend_func, state, rgb_func);
      util_dump_member(stream, enum_blend_factor, state, rgb_src_factor);
      util_dump_member(stream, enum_blend_factor, state, rgb_dst_factor);

      util_dump_member(stream, enum_blend_func, state, alpha_func);
      util_dump_member(stream, enum_blend_factor, state, alpha_src_factor);
      util_dump_member(stream, enum_blend_factor, state, alpha_dst_factor);
   }

   util_dump_member(stream, uint, state, colormask);

   util_dump_struct_end(stream);
}

void
util_dump_blend_state(FILE *stream, const struct pipe_blend_state *state)
{
   unsigned valid_entries = 1;

   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_blend_state");

   util_dump_member(stream, bool, state, dither);

   util_dump_member(stream, bool, state, logicop_enable);
   if (state->logicop_enable) {
      util_dump_member(stream, enum_func, state, logicop_func);
   }
   else {
      util_dump_member(stream, bool, state, independent_blend_enable);

      util_dump_member_begin(stream, "rt");
      if (state->independent_blend_enable)
         valid_entries = PIPE_MAX_COLOR_BUFS;
      util_dump_struct_array(stream, rt_blend_state, state->rt, valid_entries);
      util_dump_member_end(stream);
   }

   util_dump_struct_end(stream);
}


void
util_dump_blend_color(FILE *stream, const struct pipe_blend_color *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_blend_color");

   util_dump_member_array(stream, float, state, color);

   util_dump_struct_end(stream);
}

void
util_dump_stencil_ref(FILE *stream, const struct pipe_stencil_ref *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_stencil_ref");

   util_dump_member_array(stream, uint, state, ref_value);

   util_dump_struct_end(stream);
}

void
util_dump_framebuffer_state(FILE *stream, const struct pipe_framebuffer_state *state)
{
   util_dump_struct_begin(stream, "pipe_framebuffer_state");

   util_dump_member(stream, uint, state, width);
   util_dump_member(stream, uint, state, height);
   util_dump_member(stream, uint, state, nr_cbufs);
   util_dump_member_array(stream, ptr, state, cbufs);
   util_dump_member(stream, ptr, state, zsbuf);

   util_dump_struct_end(stream);
}


void
util_dump_sampler_state(FILE *stream, const struct pipe_sampler_state *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_sampler_state");

   util_dump_member(stream, uint, state, wrap_s);
   util_dump_member(stream, uint, state, wrap_t);
   util_dump_member(stream, uint, state, wrap_r);
   util_dump_member(stream, uint, state, min_img_filter);
   util_dump_member(stream, uint, state, min_mip_filter);
   util_dump_member(stream, uint, state, mag_img_filter);
   util_dump_member(stream, uint, state, compare_mode);
   util_dump_member(stream, enum_func, state, compare_func);
   util_dump_member(stream, bool, state, normalized_coords);
   util_dump_member(stream, uint, state, max_anisotropy);
   util_dump_member(stream, float, state, lod_bias);
   util_dump_member(stream, float, state, min_lod);
   util_dump_member(stream, float, state, max_lod);
   util_dump_member_array(stream, float, state, border_color.f);

   util_dump_struct_end(stream);
}


void
util_dump_surface(FILE *stream, const struct pipe_surface *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_surface");

   util_dump_member(stream, format, state, format);
   util_dump_member(stream, uint, state, width);
   util_dump_member(stream, uint, state, height);

   util_dump_member(stream, ptr, state, texture);
   util_dump_member(stream, uint, state, u.tex.level);
   util_dump_member(stream, uint, state, u.tex.first_layer);
   util_dump_member(stream, uint, state, u.tex.last_layer);

   util_dump_struct_end(stream);
}


void
util_dump_transfer(FILE *stream, const struct pipe_transfer *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_transfer");

   util_dump_member(stream, ptr, state, resource);
   util_dump_member(stream, uint, state, level);
   util_dump_member(stream, uint, state, usage);
   util_dump_member_begin(stream, "box");
   util_dump_box(stream, &state->box);
   util_dump_member_end(stream);
   util_dump_member(stream, uint, state, stride);
   util_dump_member(stream, uint, state, layer_stride);

   util_dump_struct_end(stream);
}


void
util_dump_vertex_buffer(FILE *stream, const struct pipe_vertex_buffer *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_vertex_buffer");

   util_dump_member(stream, uint, state, stride);
   util_dump_member(stream, uint, state, buffer_offset);
   util_dump_member(stream, ptr, state, buffer);

   util_dump_struct_end(stream);
}


void
util_dump_vertex_element(FILE *stream, const struct pipe_vertex_element *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_vertex_element");

   util_dump_member(stream, uint, state, src_offset);
   util_dump_member(stream, uint, state, instance_divisor);
   util_dump_member(stream, uint, state, vertex_buffer_index);
   util_dump_member(stream, format, state, src_format);

   util_dump_struct_end(stream);
}


void
util_dump_draw_info(FILE *stream, const struct pipe_draw_info *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_draw_info");

   util_dump_member(stream, bool, state, indexed);

   util_dump_member(stream, uint, state, mode);
   util_dump_member(stream, uint, state, start);
   util_dump_member(stream, uint, state, count);

   util_dump_member(stream, uint, state, start_instance);
   util_dump_member(stream, uint, state, instance_count);

   util_dump_member(stream, int,  state, index_bias);
   util_dump_member(stream, uint, state, min_index);
   util_dump_member(stream, uint, state, max_index);

   util_dump_member(stream, bool, state, primitive_restart);
   util_dump_member(stream, uint, state, restart_index);

   util_dump_member(stream, ptr, state, count_from_stream_output);

   util_dump_struct_end(stream);
}

void util_dump_box(FILE *stream, const struct pipe_box *box)
{
   if(!box) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_box");

   util_dump_member(stream, int, box, x);
   util_dump_member(stream, int, box, y);
   util_dump_member(stream, int, box, z);
   util_dump_member(stream, int, box, width);
   util_dump_member(stream, int, box, height);
   util_dump_member(stream, int, box, depth);

   util_dump_struct_end(stream);
}

void util_dump_blit_info(FILE *stream, const struct pipe_blit_info *info)
{
   char mask[7];

   if (!info) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_blit_info");

   util_dump_member_begin(stream, "dst");
   util_dump_struct_begin(stream, "dst");
   util_dump_member(stream, ptr, &info->dst, resource);
   util_dump_member(stream, uint, &info->dst, level);
   util_dump_member(stream, format, &info->dst, format);
   util_dump_member_begin(stream, "box");
   util_dump_box(stream, &info->dst.box);
   util_dump_member_end(stream);
   util_dump_struct_end(stream);
   util_dump_member_end(stream);

   util_dump_member_begin(stream, "src");
   util_dump_struct_begin(stream, "src");
   util_dump_member(stream, ptr, &info->src, resource);
   util_dump_member(stream, uint, &info->src, level);
   util_dump_member(stream, format, &info->src, format);
   util_dump_member_begin(stream, "box");
   util_dump_box(stream, &info->src.box);
   util_dump_member_end(stream);
   util_dump_struct_end(stream);
   util_dump_member_end(stream);

   mask[0] = (info->mask & PIPE_MASK_R) ? 'R' : '-';
   mask[1] = (info->mask & PIPE_MASK_G) ? 'G' : '-';
   mask[2] = (info->mask & PIPE_MASK_B) ? 'B' : '-';
   mask[3] = (info->mask & PIPE_MASK_A) ? 'A' : '-';
   mask[4] = (info->mask & PIPE_MASK_Z) ? 'Z' : '-';
   mask[5] = (info->mask & PIPE_MASK_S) ? 'S' : '-';
   mask[6] = 0;

   util_dump_member_begin(stream, "mask");
   util_dump_string(stream, mask);
   util_dump_member_end(stream);
   util_dump_member(stream, uint, info, filter);

   util_dump_member(stream, bool, info, scissor_enable);
   util_dump_member_begin(stream, "scissor");
   util_dump_scissor_state(stream, &info->scissor);
   util_dump_member_end(stream);

   util_dump_struct_end(stream);
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a761 3
   util_dump_member(stream, ptr, state, indirect);
   util_dump_member(stream, uint, state, indirect_offset);

@


1.4
log
@Merge Mesa 9.2.0
@
text
@d762 3
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a29 1
#include "os/os_stream.h"
d43 1
a43 1
util_stream_writef(struct os_stream *stream, const char *format, ...)
d51 1
a51 1
   os_stream_write(stream, buf, len);
d55 1
a55 1
util_dump_bool(struct os_stream *stream, int value)
d61 1
a61 1
util_dump_int(struct os_stream *stream, long long int value)
d67 1
a67 1
util_dump_uint(struct os_stream *stream, long long unsigned value)
d73 1
a73 1
util_dump_float(struct os_stream *stream, double value)
d79 1
a79 1
util_dump_string(struct os_stream *stream, const char *str)
d81 3
a83 3
   os_stream_write_str(stream, "\"");
   os_stream_write_str(stream, str);
   os_stream_write_str(stream, "\"");
d87 1
a87 1
util_dump_enum(struct os_stream *stream, const char *value)
d89 1
a89 1
   os_stream_write_str(stream, value);
d93 1
a93 1
util_dump_array_begin(struct os_stream *stream)
d95 1
a95 1
   os_stream_write_str(stream, "{");
d99 1
a99 1
util_dump_array_end(struct os_stream *stream)
d101 1
a101 1
   os_stream_write_str(stream, "}");
d105 1
a105 1
util_dump_elem_begin(struct os_stream *stream)
d110 1
a110 1
util_dump_elem_end(struct os_stream *stream)
d112 1
a112 1
   os_stream_write_str(stream, ", ");
d116 1
a116 1
util_dump_struct_begin(struct os_stream *stream, const char *name)
d118 1
a118 1
   os_stream_write_str(stream, "{");
d122 1
a122 1
util_dump_struct_end(struct os_stream *stream)
d124 1
a124 1
   os_stream_write_str(stream, "}");
d128 1
a128 1
util_dump_member_begin(struct os_stream *stream, const char *name)
d134 1
a134 1
util_dump_member_end(struct os_stream *stream)
d136 1
a136 1
   os_stream_write_str(stream, ", ");
d140 1
a140 1
util_dump_null(struct os_stream *stream)
d142 1
a142 1
   os_stream_write_str(stream, "NULL");
d146 1
a146 1
util_dump_ptr(struct os_stream *stream, const void *value)
d226 1
a226 1
util_dump_format(struct os_stream *stream, enum pipe_format format)
d233 1
a233 1
util_dump_enum_blend_factor(struct os_stream *stream, unsigned value)
d239 1
a239 1
util_dump_enum_blend_func(struct os_stream *stream, unsigned value)
d245 1
a245 1
util_dump_enum_func(struct os_stream *stream, unsigned value)
d257 1
a257 1
util_dump_template(struct os_stream *stream, const struct pipe_resource *templat)
d295 1
a295 1
util_dump_rasterizer_state(struct os_stream *stream, const struct pipe_rasterizer_state *state)
d306 2
d330 5
a334 1
   util_dump_member(stream, bool, state, gl_rasterization_rules);
d340 1
d347 1
a347 1
util_dump_poly_stipple(struct os_stream *stream, const struct pipe_poly_stipple *state)
d365 1
a365 1
util_dump_viewport_state(struct os_stream *stream, const struct pipe_viewport_state *state)
d382 1
a382 1
util_dump_scissor_state(struct os_stream *stream, const struct pipe_scissor_state *state)
d401 1
a401 1
util_dump_clip_state(struct os_stream *stream, const struct pipe_clip_state *state)
a421 2
   util_dump_member(stream, uint, state, nr);

d427 1
a427 1
util_dump_shader_state(struct os_stream *stream, const struct pipe_shader_state *state)
d430 1
d445 20
d470 1
a470 1
util_dump_depth_stencil_alpha_state(struct os_stream *stream, const struct pipe_depth_stencil_alpha_state *state)
d525 1
a525 1
util_dump_rt_blend_state(struct os_stream *stream, const struct pipe_rt_blend_state *state)
d546 1
a546 1
util_dump_blend_state(struct os_stream *stream, const struct pipe_blend_state *state)
d578 1
a578 1
util_dump_blend_color(struct os_stream *stream, const struct pipe_blend_color *state)
d593 1
a593 1
util_dump_stencil_ref(struct os_stream *stream, const struct pipe_stencil_ref *state)
d608 1
a608 1
util_dump_framebuffer_state(struct os_stream *stream, const struct pipe_framebuffer_state *state)
d623 1
a623 1
util_dump_sampler_state(struct os_stream *stream, const struct pipe_sampler_state *state)
d645 1
a645 1
   util_dump_member_array(stream, float, state, border_color);
d652 1
a652 1
util_dump_surface(struct os_stream *stream, const struct pipe_surface *state)
a664 2
   util_dump_member(stream, uint, state, usage);

d675 1
a675 1
util_dump_transfer(struct os_stream *stream, const struct pipe_transfer *state)
d685 5
a689 2
   /*util_dump_member(stream, uint, state, box);*/

a692 2
   /*util_dump_member(stream, ptr, state, data);*/

d698 1
a698 1
util_dump_vertex_buffer(struct os_stream *stream, const struct pipe_vertex_buffer *state)
d716 1
a716 1
util_dump_vertex_element(struct os_stream *stream, const struct pipe_vertex_element *state)
d726 30
d757 72
a828 1
   util_dump_member(stream, uint, state, vertex_buffer_index);
d830 4
a833 1
   util_dump_member(stream, format, state, src_format);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a683 1
   util_dump_member(stream, uint, state, max_index);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d258 1
a258 1
util_dump_template(struct os_stream *stream, const struct pipe_texture *templat)
d265 1
a265 1
   util_dump_struct_begin(stream, "pipe_texture");
d282 4
d287 3
a289 1
   util_dump_member(stream, uint, templat, tex_usage);
d307 7
a313 6
   util_dump_member(stream, uint, state, front_winding);
   util_dump_member(stream, uint, state, cull_mode);
   util_dump_member(stream, uint, state, fill_cw);
   util_dump_member(stream, uint, state, fill_ccw);
   util_dump_member(stream, bool, state, offset_cw);
   util_dump_member(stream, bool, state, offset_ccw);
a639 2
   util_dump_member(stream, uint, state, layout);
   util_dump_member(stream, uint, state, offset);
d643 3
a645 3
   util_dump_member(stream, uint, state, face);
   util_dump_member(stream, uint, state, level);
   util_dump_member(stream, uint, state, zslice);
d661 2
a662 2
   util_dump_member(stream, uint, state, width);
   util_dump_member(stream, uint, state, height);
d665 1
a665 1
   util_dump_member(stream, uint, state, usage);
d667 1
a667 4
   util_dump_member(stream, ptr, state, texture);
   util_dump_member(stream, uint, state, face);
   util_dump_member(stream, uint, state, level);
   util_dump_member(stream, uint, state, zslice);
a704 1
   util_dump_member(stream, uint, state, nr_components);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d258 1
a258 1
util_dump_template(struct os_stream *stream, const struct pipe_resource *templat)
d265 1
a265 1
   util_dump_struct_begin(stream, "pipe_resource");
a281 4
   util_dump_member_begin(stream, "array_size");
   util_dump_uint(stream, templat->array_size);
   util_dump_member_end(stream);

d283 1
a283 3
   util_dump_member(stream, uint, templat, usage);
   util_dump_member(stream, uint, templat, bind);
   util_dump_member(stream, uint, templat, flags);
d301 6
a306 7
   util_dump_member(stream, uint, state, front_ccw);
   util_dump_member(stream, uint, state, cull_face);
   util_dump_member(stream, uint, state, fill_front);
   util_dump_member(stream, uint, state, fill_back);
   util_dump_member(stream, bool, state, offset_point);
   util_dump_member(stream, bool, state, offset_line);
   util_dump_member(stream, bool, state, offset_tri);
d633 2
d638 3
a640 3
   util_dump_member(stream, uint, state, u.tex.level);
   util_dump_member(stream, uint, state, u.tex.first_layer);
   util_dump_member(stream, uint, state, u.tex.last_layer);
d656 2
a657 2
   util_dump_member(stream, ptr, state, resource);
   /*util_dump_member(stream, uint, state, box);*/
d660 1
a660 1
   util_dump_member(stream, uint, state, layer_stride);
d662 4
a665 1
   /*util_dump_member(stream, ptr, state, data);*/
d703 1
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d30 1
d44 1
a44 1
util_stream_writef(FILE *stream, const char *format, ...)
d52 1
a52 1
   fwrite(buf, len, 1, stream);
d56 1
a56 1
util_dump_bool(FILE *stream, int value)
d62 1
a62 1
util_dump_int(FILE *stream, long long int value)
d68 1
a68 1
util_dump_uint(FILE *stream, long long unsigned value)
d74 1
a74 1
util_dump_float(FILE *stream, double value)
d80 1
a80 1
util_dump_string(FILE *stream, const char *str)
d82 3
a84 3
   fputs("\"", stream);
   fputs(str, stream);
   fputs("\"", stream);
d88 1
a88 1
util_dump_enum(FILE *stream, const char *value)
d90 1
a90 1
   fputs(value, stream);
d94 1
a94 1
util_dump_array_begin(FILE *stream)
d96 1
a96 1
   fputs("{", stream);
d100 1
a100 1
util_dump_array_end(FILE *stream)
d102 1
a102 1
   fputs("}", stream);
d106 1
a106 1
util_dump_elem_begin(FILE *stream)
d111 1
a111 1
util_dump_elem_end(FILE *stream)
d113 1
a113 1
   fputs(", ", stream);
d117 1
a117 1
util_dump_struct_begin(FILE *stream, const char *name)
d119 1
a119 1
   fputs("{", stream);
d123 1
a123 1
util_dump_struct_end(FILE *stream)
d125 1
a125 1
   fputs("}", stream);
d129 1
a129 1
util_dump_member_begin(FILE *stream, const char *name)
d135 1
a135 1
util_dump_member_end(FILE *stream)
d137 1
a137 1
   fputs(", ", stream);
d141 1
a141 1
util_dump_null(FILE *stream)
d143 1
a143 1
   fputs("NULL", stream);
d147 1
a147 1
util_dump_ptr(FILE *stream, const void *value)
d227 1
a227 1
util_dump_format(FILE *stream, enum pipe_format format)
d234 1
a234 1
util_dump_enum_blend_factor(FILE *stream, unsigned value)
d240 1
a240 1
util_dump_enum_blend_func(FILE *stream, unsigned value)
d246 1
a246 1
util_dump_enum_func(FILE *stream, unsigned value)
d258 1
a258 1
util_dump_template(FILE *stream, const struct pipe_resource *templat)
d296 1
a296 1
util_dump_rasterizer_state(FILE *stream, const struct pipe_rasterizer_state *state)
a306 2
   util_dump_member(stream, bool, state, clamp_vertex_color);
   util_dump_member(stream, bool, state, clamp_fragment_color);
d329 1
a329 5
   util_dump_member(stream, bool, state, half_pixel_center);
   util_dump_member(stream, bool, state, bottom_edge_rule);
   util_dump_member(stream, bool, state, rasterizer_discard);
   util_dump_member(stream, bool, state, depth_clip);
   util_dump_member(stream, uint, state, clip_plane_enable);
a334 1
   util_dump_member(stream, float, state, offset_clamp);
d341 1
a341 1
util_dump_poly_stipple(FILE *stream, const struct pipe_poly_stipple *state)
d359 1
a359 1
util_dump_viewport_state(FILE *stream, const struct pipe_viewport_state *state)
d376 1
a376 1
util_dump_scissor_state(FILE *stream, const struct pipe_scissor_state *state)
d395 1
a395 1
util_dump_clip_state(FILE *stream, const struct pipe_clip_state *state)
d416 2
d423 1
a423 1
util_dump_shader_state(FILE *stream, const struct pipe_shader_state *state)
a425 1
   unsigned i;
a439 20
   util_dump_member_begin(stream, "stream_output");
   util_dump_struct_begin(stream, "pipe_stream_output_info");
   util_dump_member(stream, uint, &state->stream_output, num_outputs);
   util_dump_array(stream, uint, state->stream_output.stride,
                   Elements(state->stream_output.stride));
   util_dump_array_begin(stream);
   for(i = 0; i < state->stream_output.num_outputs; ++i) {
      util_dump_elem_begin(stream);
      util_dump_struct_begin(stream, ""); /* anonymous */
      util_dump_member(stream, uint, &state->stream_output.output[i], register_index);
      util_dump_member(stream, uint, &state->stream_output.output[i], start_component);
      util_dump_member(stream, uint, &state->stream_output.output[i], num_components);
      util_dump_member(stream, uint, &state->stream_output.output[i], output_buffer);
      util_dump_struct_end(stream);
      util_dump_elem_end(stream);
   }
   util_dump_array_end(stream);
   util_dump_struct_end(stream);
   util_dump_member_end(stream);

d445 1
a445 1
util_dump_depth_stencil_alpha_state(FILE *stream, const struct pipe_depth_stencil_alpha_state *state)
d500 1
a500 1
util_dump_rt_blend_state(FILE *stream, const struct pipe_rt_blend_state *state)
d521 1
a521 1
util_dump_blend_state(FILE *stream, const struct pipe_blend_state *state)
d553 1
a553 1
util_dump_blend_color(FILE *stream, const struct pipe_blend_color *state)
d568 1
a568 1
util_dump_stencil_ref(FILE *stream, const struct pipe_stencil_ref *state)
d583 1
a583 1
util_dump_framebuffer_state(FILE *stream, const struct pipe_framebuffer_state *state)
d598 1
a598 1
util_dump_sampler_state(FILE *stream, const struct pipe_sampler_state *state)
d620 1
a620 1
   util_dump_member_array(stream, float, state, border_color.f);
d627 1
a627 1
util_dump_surface(FILE *stream, const struct pipe_surface *state)
d640 2
d652 1
a652 1
util_dump_transfer(FILE *stream, const struct pipe_transfer *state)
d662 2
a663 5
   util_dump_member(stream, uint, state, level);
   util_dump_member(stream, uint, state, usage);
   util_dump_member_begin(stream, "box");
   util_dump_box(stream, &state->box);
   util_dump_member_end(stream);
d667 2
d674 1
a674 1
util_dump_vertex_buffer(FILE *stream, const struct pipe_vertex_buffer *state)
d684 1
d693 1
a693 1
util_dump_vertex_element(FILE *stream, const struct pipe_vertex_element *state)
d703 1
a703 1
   util_dump_member(stream, uint, state, instance_divisor);
d705 1
a706 105

   util_dump_struct_end(stream);
}


void
util_dump_draw_info(FILE *stream, const struct pipe_draw_info *state)
{
   if(!state) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_draw_info");

   util_dump_member(stream, bool, state, indexed);

   util_dump_member(stream, uint, state, mode);
   util_dump_member(stream, uint, state, start);
   util_dump_member(stream, uint, state, count);

   util_dump_member(stream, uint, state, start_instance);
   util_dump_member(stream, uint, state, instance_count);

   util_dump_member(stream, int,  state, index_bias);
   util_dump_member(stream, uint, state, min_index);
   util_dump_member(stream, uint, state, max_index);

   util_dump_member(stream, bool, state, primitive_restart);
   util_dump_member(stream, uint, state, restart_index);

   util_dump_member(stream, ptr, state, count_from_stream_output);

   util_dump_struct_end(stream);
}

void util_dump_box(FILE *stream, const struct pipe_box *box)
{
   if(!box) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_box");

   util_dump_member(stream, int, box, x);
   util_dump_member(stream, int, box, y);
   util_dump_member(stream, int, box, z);
   util_dump_member(stream, int, box, width);
   util_dump_member(stream, int, box, height);
   util_dump_member(stream, int, box, depth);

   util_dump_struct_end(stream);
}

void util_dump_blit_info(FILE *stream, const struct pipe_blit_info *info)
{
   char mask[7];

   if (!info) {
      util_dump_null(stream);
      return;
   }

   util_dump_struct_begin(stream, "pipe_blit_info");

   util_dump_member_begin(stream, "dst");
   util_dump_struct_begin(stream, "dst");
   util_dump_member(stream, ptr, &info->dst, resource);
   util_dump_member(stream, uint, &info->dst, level);
   util_dump_member(stream, format, &info->dst, format);
   util_dump_member_begin(stream, "box");
   util_dump_box(stream, &info->dst.box);
   util_dump_member_end(stream);
   util_dump_struct_end(stream);
   util_dump_member_end(stream);

   util_dump_member_begin(stream, "src");
   util_dump_struct_begin(stream, "src");
   util_dump_member(stream, ptr, &info->src, resource);
   util_dump_member(stream, uint, &info->src, level);
   util_dump_member(stream, format, &info->src, format);
   util_dump_member_begin(stream, "box");
   util_dump_box(stream, &info->src.box);
   util_dump_member_end(stream);
   util_dump_struct_end(stream);
   util_dump_member_end(stream);

   mask[0] = (info->mask & PIPE_MASK_R) ? 'R' : '-';
   mask[1] = (info->mask & PIPE_MASK_G) ? 'G' : '-';
   mask[2] = (info->mask & PIPE_MASK_B) ? 'B' : '-';
   mask[3] = (info->mask & PIPE_MASK_A) ? 'A' : '-';
   mask[4] = (info->mask & PIPE_MASK_Z) ? 'Z' : '-';
   mask[5] = (info->mask & PIPE_MASK_S) ? 'S' : '-';
   mask[6] = 0;

   util_dump_member_begin(stream, "mask");
   util_dump_string(stream, mask);
   util_dump_member_end(stream);
   util_dump_member(stream, uint, info, filter);

   util_dump_member(stream, bool, info, scissor_enable);
   util_dump_member_begin(stream, "scissor");
   util_dump_scissor_state(stream, &info->scissor);
   util_dump_member_end(stream);
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a761 3
   util_dump_member(stream, ptr, state, indirect);
   util_dump_member(stream, uint, state, indirect_offset);

@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d762 3
@


