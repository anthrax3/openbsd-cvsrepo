head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.51;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.53;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.48;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * @@file
 * Functions to produce packed colors/Z from floats.
 */


#ifndef U_PACK_COLOR_H
#define U_PACK_COLOR_H


#include "pipe/p_compiler.h"
#include "pipe/p_format.h"
#include "util/u_debug.h"
#include "util/u_format.h"
#include "util/u_math.h"


/**
 * Helper union for packing pixel values.
 * Will often contain values in formats which are too complex to be described
 * in simple terms, hence might just effectively contain a number of bytes.
 * Must be big enough to hold data for all formats (currently 256 bits).
 */
union util_color {
   ubyte ub;
   ushort us;
   uint ui[4];
   ushort h[4]; /* half float */
   float f[4];
   double d[4];
};

/**
 * Pack ubyte R,G,B,A into dest pixel.
 */
static INLINE void
util_pack_color_ub(ubyte r, ubyte g, ubyte b, ubyte a,
                   enum pipe_format format, union util_color *uc)
{
   switch (format) {
   case PIPE_FORMAT_ABGR8888_UNORM:
      {
         uc->ui[0] = (r << 24) | (g << 16) | (b << 8) | a;
      }
      return;
   case PIPE_FORMAT_XBGR8888_UNORM:
      {
         uc->ui[0] = (r << 24) | (g << 16) | (b << 8) | 0xff;
      }
      return;
   case PIPE_FORMAT_BGRA8888_UNORM:
      {
         uc->ui[0] = (a << 24) | (r << 16) | (g << 8) | b;
      }
      return;
   case PIPE_FORMAT_BGRX8888_UNORM:
      {
         uc->ui[0] = (0xff << 24) | (r << 16) | (g << 8) | b;
      }
      return;
   case PIPE_FORMAT_ARGB8888_UNORM:
      {
         uc->ui[0] = (b << 24) | (g << 16) | (r << 8) | a;
      }
      return;
   case PIPE_FORMAT_XRGB8888_UNORM:
      {
         uc->ui[0] = (b << 24) | (g << 16) | (r << 8) | 0xff;
      }
      return;
   case PIPE_FORMAT_B5G6R5_UNORM:
      {
         uc->us = ((r & 0xf8) << 8) | ((g & 0xfc) << 3) | (b >> 3);
      }
      return;
   case PIPE_FORMAT_B5G5R5X1_UNORM:
      {
         uc->us = ((0x80) << 8) | ((r & 0xf8) << 7) | ((g & 0xf8) << 2) | (b >> 3);
      }
      return;
   case PIPE_FORMAT_B5G5R5A1_UNORM:
      {
         uc->us = ((a & 0x80) << 8) | ((r & 0xf8) << 7) | ((g & 0xf8) << 2) | (b >> 3);
      }
      return;
   case PIPE_FORMAT_B4G4R4A4_UNORM:
      {
         uc->us = ((a & 0xf0) << 8) | ((r & 0xf0) << 4) | ((g & 0xf0) << 0) | (b >> 4);
      }
      return;
   case PIPE_FORMAT_A8_UNORM:
      {
         uc->ub = a;
      }
      return;
   case PIPE_FORMAT_L8_UNORM:
   case PIPE_FORMAT_I8_UNORM:
      {
         uc->ub = r;
      }
      return;
   case PIPE_FORMAT_R32G32B32A32_FLOAT:
      {
         uc->f[0] = (float)r / 255.0f;
         uc->f[1] = (float)g / 255.0f;
         uc->f[2] = (float)b / 255.0f;
         uc->f[3] = (float)a / 255.0f;
      }
      return;
   case PIPE_FORMAT_R32G32B32_FLOAT:
      {
         uc->f[0] = (float)r / 255.0f;
         uc->f[1] = (float)g / 255.0f;
         uc->f[2] = (float)b / 255.0f;
      }
      return;

   /* Handle other cases with a generic function.
    */
   default:
      {
         ubyte src[4];

         src[0] = r;
         src[1] = g;
         src[2] = b;
         src[3] = a;
         util_format_write_4ub(format, src, 0, uc, 0, 0, 0, 1, 1);
      }
   }
}
 

/**
 * Unpack RGBA from a packed pixel, returning values as ubytes in [0,255].
 */
static INLINE void
util_unpack_color_ub(enum pipe_format format, union util_color *uc,
                     ubyte *r, ubyte *g, ubyte *b, ubyte *a)
{
   switch (format) {
   case PIPE_FORMAT_ABGR8888_UNORM:
      {
         uint p = uc->ui[0];
         *r = (ubyte) ((p >> 24) & 0xff);
         *g = (ubyte) ((p >> 16) & 0xff);
         *b = (ubyte) ((p >>  8) & 0xff);
         *a = (ubyte) ((p >>  0) & 0xff);
      }
      return;
   case PIPE_FORMAT_XBGR8888_UNORM:
      {
         uint p = uc->ui[0];
         *r = (ubyte) ((p >> 24) & 0xff);
         *g = (ubyte) ((p >> 16) & 0xff);
         *b = (ubyte) ((p >>  8) & 0xff);
         *a = (ubyte) 0xff;
      }
      return;
   case PIPE_FORMAT_BGRA8888_UNORM:
      {
         uint p = uc->ui[0];
         *r = (ubyte) ((p >> 16) & 0xff);
         *g = (ubyte) ((p >>  8) & 0xff);
         *b = (ubyte) ((p >>  0) & 0xff);
         *a = (ubyte) ((p >> 24) & 0xff);
      }
      return;
   case PIPE_FORMAT_BGRX8888_UNORM:
      {
         uint p = uc->ui[0];
         *r = (ubyte) ((p >> 16) & 0xff);
         *g = (ubyte) ((p >>  8) & 0xff);
         *b = (ubyte) ((p >>  0) & 0xff);
         *a = (ubyte) 0xff;
      }
      return;
   case PIPE_FORMAT_ARGB8888_UNORM:
      {
         uint p = uc->ui[0];
         *r = (ubyte) ((p >>  8) & 0xff);
         *g = (ubyte) ((p >> 16) & 0xff);
         *b = (ubyte) ((p >> 24) & 0xff);
         *a = (ubyte) ((p >>  0) & 0xff);
      }
      return;
   case PIPE_FORMAT_XRGB8888_UNORM:
      {
         uint p = uc->ui[0];
         *r = (ubyte) ((p >>  8) & 0xff);
         *g = (ubyte) ((p >> 16) & 0xff);
         *b = (ubyte) ((p >> 24) & 0xff);
         *a = (ubyte) 0xff;
      }
      return;
   case PIPE_FORMAT_B5G6R5_UNORM:
      {
         ushort p = uc->us;
         *r = (ubyte) (((p >> 8) & 0xf8) | ((p >> 13) & 0x7));
         *g = (ubyte) (((p >> 3) & 0xfc) | ((p >>  9) & 0x3));
         *b = (ubyte) (((p << 3) & 0xf8) | ((p >>  2) & 0x7));
         *a = (ubyte) 0xff;
      }
      return;
   case PIPE_FORMAT_B5G5R5X1_UNORM:
      {
         ushort p = uc->us;
         *r = (ubyte) (((p >>  7) & 0xf8) | ((p >> 12) & 0x7));
         *g = (ubyte) (((p >>  2) & 0xf8) | ((p >>  7) & 0x7));
         *b = (ubyte) (((p <<  3) & 0xf8) | ((p >>  2) & 0x7));
         *a = (ubyte) 0xff;
      }
      return;
   case PIPE_FORMAT_B5G5R5A1_UNORM:
      {
         ushort p = uc->us;
         *r = (ubyte) (((p >>  7) & 0xf8) | ((p >> 12) & 0x7));
         *g = (ubyte) (((p >>  2) & 0xf8) | ((p >>  7) & 0x7));
         *b = (ubyte) (((p <<  3) & 0xf8) | ((p >>  2) & 0x7));
         *a = (ubyte) (0xff * (p >> 15));
      }
      return;
   case PIPE_FORMAT_B4G4R4A4_UNORM:
      {
         ushort p = uc->us;
         *r = (ubyte) (((p >> 4) & 0xf0) | ((p >>  8) & 0xf));
         *g = (ubyte) (((p >> 0) & 0xf0) | ((p >>  4) & 0xf));
         *b = (ubyte) (((p << 4) & 0xf0) | ((p >>  0) & 0xf));
         *a = (ubyte) (((p >> 8) & 0xf0) | ((p >> 12) & 0xf));
      }
      return;
   case PIPE_FORMAT_A8_UNORM:
      {
         ubyte p = uc->ub;
         *r = *g = *b = (ubyte) 0xff;
         *a = p;
      }
      return;
   case PIPE_FORMAT_L8_UNORM:
      {
         ubyte p = uc->ub;
         *r = *g = *b = p;
         *a = (ubyte) 0xff;
      }
      return;
   case PIPE_FORMAT_I8_UNORM:
      {
         ubyte p = uc->ub;
         *r = *g = *b = *a = p;
      }
      return;
   case PIPE_FORMAT_R32G32B32A32_FLOAT:
      {
         const float *p = &uc->f[0];
         *r = float_to_ubyte(p[0]);
         *g = float_to_ubyte(p[1]);
         *b = float_to_ubyte(p[2]);
         *a = float_to_ubyte(p[3]);
      }
      return;
   case PIPE_FORMAT_R32G32B32_FLOAT:
      {
         const float *p = &uc->f[0];
         *r = float_to_ubyte(p[0]);
         *g = float_to_ubyte(p[1]);
         *b = float_to_ubyte(p[2]);
         *a = (ubyte) 0xff;
      }
      return;

   case PIPE_FORMAT_R32G32_FLOAT:
      {
         const float *p = &uc->f[0];
         *r = float_to_ubyte(p[0]);
         *g = float_to_ubyte(p[1]);
         *b = *a = (ubyte) 0xff;
      }
      return;

   case PIPE_FORMAT_R32_FLOAT:
      {
         const float *p = &uc->f[0];
         *r = float_to_ubyte(p[0]);
         *g = *b = *a = (ubyte) 0xff;
      }
      return;

   /* Handle other cases with a generic function.
    */
   default:
      {
         ubyte dst[4];

         util_format_read_4ub(format, dst, 0, uc, 0, 0, 0, 1, 1);
         *r = dst[0];
         *g = dst[1];
         *b = dst[2];
         *a = dst[3];
      }
   }
}


/**
 * Note rgba outside [0,1] will be clamped for int pixel formats.
 * This will not work (and might not really be useful with float input)
 * for pure integer formats (which lack the pack_rgba_float function).
 */
static INLINE void
util_pack_color(const float rgba[4], enum pipe_format format, union util_color *uc)
{
   ubyte r = 0;
   ubyte g = 0;
   ubyte b = 0;
   ubyte a = 0;

   if (util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_RGB, 0) <= 8) {
      /* format uses 8-bit components or less */
      r = float_to_ubyte(rgba[0]);
      g = float_to_ubyte(rgba[1]);
      b = float_to_ubyte(rgba[2]);
      a = float_to_ubyte(rgba[3]);
   }

   switch (format) {
   case PIPE_FORMAT_ABGR8888_UNORM:
      {
         uc->ui[0] = (r << 24) | (g << 16) | (b << 8) | a;
      }
      return;
   case PIPE_FORMAT_XBGR8888_UNORM:
      {
         uc->ui[0] = (r << 24) | (g << 16) | (b << 8) | 0xff;
      }
      return;
   case PIPE_FORMAT_BGRA8888_UNORM:
      {
         uc->ui[0] = (a << 24) | (r << 16) | (g << 8) | b;
      }
      return;
   case PIPE_FORMAT_BGRX8888_UNORM:
      {
         uc->ui[0] = (0xff << 24) | (r << 16) | (g << 8) | b;
      }
      return;
   case PIPE_FORMAT_ARGB8888_UNORM:
      {
         uc->ui[0] = (b << 24) | (g << 16) | (r << 8) | a;
      }
      return;
   case PIPE_FORMAT_XRGB8888_UNORM:
      {
         uc->ui[0] = (b << 24) | (g << 16) | (r << 8) | 0xff;
      }
      return;
   case PIPE_FORMAT_B5G6R5_UNORM:
      {
         uc->us = ((r & 0xf8) << 8) | ((g & 0xfc) << 3) | (b >> 3);
      }
      return;
   case PIPE_FORMAT_B5G5R5X1_UNORM:
      {
         uc->us = ((0x80) << 8) | ((r & 0xf8) << 7) | ((g & 0xf8) << 2) | (b >> 3);
      }
      return;
   case PIPE_FORMAT_B5G5R5A1_UNORM:
      {
         uc->us = ((a & 0x80) << 8) | ((r & 0xf8) << 7) | ((g & 0xf8) << 2) | (b >> 3);
      }
      return;
   case PIPE_FORMAT_B4G4R4A4_UNORM:
      {
         uc->us = ((a & 0xf0) << 8) | ((r & 0xf0) << 4) | ((g & 0xf0) << 0) | (b >> 4);
      }
      return;
   case PIPE_FORMAT_A8_UNORM:
      {
         uc->ub = a;
      }
      return;
   case PIPE_FORMAT_L8_UNORM:
   case PIPE_FORMAT_I8_UNORM:
      {
         uc->ub = r;
      }
      return;
   case PIPE_FORMAT_R32G32B32A32_FLOAT:
      {
         uc->f[0] = rgba[0];
         uc->f[1] = rgba[1];
         uc->f[2] = rgba[2];
         uc->f[3] = rgba[3];
      }
      return;
   case PIPE_FORMAT_R32G32B32_FLOAT:
      {
         uc->f[0] = rgba[0];
         uc->f[1] = rgba[1];
         uc->f[2] = rgba[2];
      }
      return;

   /* Handle other cases with a generic function.
    */
   default:
      util_format_write_4f(format, rgba, 0, uc, 0, 0, 0, 1, 1);
   }
}
 
/* Integer versions of util_pack_z and util_pack_z_stencil - useful for
 * constructing clear masks.
 */
static INLINE uint32_t
util_pack_mask_z(enum pipe_format format, uint32_t z)
{
   switch (format) {
   case PIPE_FORMAT_Z16_UNORM:
      return z & 0xffff;
   case PIPE_FORMAT_Z32_UNORM:
   case PIPE_FORMAT_Z32_FLOAT:
      return z;
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
   case PIPE_FORMAT_Z24X8_UNORM:
      return z & 0xffffff;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
   case PIPE_FORMAT_X8Z24_UNORM:
      return (z & 0xffffff) << 8;
   case PIPE_FORMAT_S8_UINT:
      return 0;
   default:
      debug_print_format("gallium: unhandled format in util_pack_mask_z()", format);
      assert(0);
      return 0;
   }
}


static INLINE uint64_t
util_pack64_mask_z(enum pipe_format format, uint32_t z)
{
   switch (format) {
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      return z;
   default:
      return util_pack_mask_z(format, z);
   }
}


static INLINE uint32_t
util_pack_mask_z_stencil(enum pipe_format format, uint32_t z, uint8_t s)
{
   uint32_t packed = util_pack_mask_z(format, z);

   switch (format) {
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      packed |= (uint32_t)s << 24;
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      packed |= s;
      break;
   case PIPE_FORMAT_S8_UINT:
      packed |= s;
      break;
   default:
      break;
   }

   return packed;
}


static INLINE uint64_t
util_pack64_mask_z_stencil(enum pipe_format format, uint32_t z, uint8_t s)
{
   uint64_t packed;

   switch (format) {
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      packed = util_pack64_mask_z(format, z);
      packed |= (uint64_t)s << 32ull;
      return packed;
   default:
      return util_pack_mask_z_stencil(format, z, s);
   }
}


/**
 * Note: it's assumed that z is in [0,1]
 */
static INLINE uint32_t
util_pack_z(enum pipe_format format, double z)
{
   union fi fui;

   if (z == 0.0)
      return 0;

   switch (format) {
   case PIPE_FORMAT_Z16_UNORM:
      if (z == 1.0)
         return 0xffff;
      return (uint32_t) lrint(z * 0xffff);
   case PIPE_FORMAT_Z32_UNORM:
      /* special-case to avoid overflow */
      if (z == 1.0)
         return 0xffffffff;
      return (uint32_t) llrint(z * 0xffffffff);
   case PIPE_FORMAT_Z32_FLOAT:
      fui.f = (float)z;
      return fui.ui;
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
   case PIPE_FORMAT_Z24X8_UNORM:
      if (z == 1.0)
         return 0xffffff;
      return (uint32_t) lrint(z * 0xffffff);
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
   case PIPE_FORMAT_X8Z24_UNORM:
      if (z == 1.0)
         return 0xffffff00;
      return ((uint32_t) lrint(z * 0xffffff)) << 8;
   case PIPE_FORMAT_S8_UINT:
      /* this case can get it via util_pack_z_stencil() */
      return 0;
   default:
      debug_print_format("gallium: unhandled format in util_pack_z()", format);
      assert(0);
      return 0;
   }
}


static INLINE uint64_t
util_pack64_z(enum pipe_format format, double z)
{
   union fi fui;

   if (z == 0)
      return 0;

   switch (format) {
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      fui.f = (float)z;
      return fui.ui;
   default:
      return util_pack_z(format, z);
   }
}
 

/**
 * Pack Z and/or stencil values into a 32-bit value described by format.
 * Note: it's assumed that z is in [0,1] and s in [0,255]
 */
static INLINE uint32_t
util_pack_z_stencil(enum pipe_format format, double z, uint8_t s)
{
   uint32_t packed = util_pack_z(format, z);

   switch (format) {
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      packed |= (uint32_t)s << 24;
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      packed |= s;
      break;
   case PIPE_FORMAT_S8_UINT:
      packed |= s;
      break;
   default:
      break;
   }

   return packed;
}


static INLINE uint64_t
util_pack64_z_stencil(enum pipe_format format, double z, uint8_t s)
{
   uint64_t packed;

   switch (format) {
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      packed = util_pack64_z(format, z);
      packed |= (uint64_t)s << 32ull;
      break;
   default:
      return util_pack_z_stencil(format, z, s);
   }

   return packed;
}


/**
 * Pack 4 ubytes into a 4-byte word
 */
static INLINE unsigned
pack_ub4(ubyte b0, ubyte b1, ubyte b2, ubyte b3)
{
   return ((((unsigned int)b0) << 0) |
	   (((unsigned int)b1) << 8) |
	   (((unsigned int)b2) << 16) |
	   (((unsigned int)b3) << 24));
}


/**
 * Pack/convert 4 floats into one 4-byte word.
 */
static INLINE unsigned
pack_ui32_float4(float a, float b, float c, float d)
{
   return pack_ub4( float_to_ubyte(a),
		    float_to_ubyte(b),
		    float_to_ubyte(c),
		    float_to_ubyte(d) );
}



#endif /* U_PACK_COLOR_H */
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d54 1
a54 1
   uint ui;
d70 1
a70 1
         uc->ui = (r << 24) | (g << 16) | (b << 8) | a;
d75 1
a75 1
         uc->ui = (r << 24) | (g << 16) | (b << 8) | 0xff;
d80 1
a80 1
         uc->ui = (a << 24) | (r << 16) | (g << 8) | b;
d85 1
a85 1
         uc->ui = (0xff << 24) | (r << 16) | (g << 8) | b;
d90 1
a90 1
         uc->ui = (b << 24) | (g << 16) | (r << 8) | a;
d95 1
a95 1
         uc->ui = (b << 24) | (g << 16) | (r << 8) | 0xff;
d171 1
a171 1
         uint p = uc->ui;
d180 1
a180 1
         uint p = uc->ui;
d189 1
a189 1
         uint p = uc->ui;
d198 1
a198 1
         uint p = uc->ui;
d207 1
a207 1
         uint p = uc->ui;
d216 1
a216 1
         uint p = uc->ui;
d355 1
a355 1
         uc->ui = (r << 24) | (g << 16) | (b << 8) | a;
d360 1
a360 1
         uc->ui = (r << 24) | (g << 16) | (b << 8) | 0xff;
d365 1
a365 1
         uc->ui = (a << 24) | (r << 16) | (g << 8) | b;
d370 1
a370 1
         uc->ui = (0xff << 24) | (r << 16) | (g << 8) | b;
d375 1
a375 1
         uc->ui = (b << 24) | (g << 16) | (r << 8) | a;
d380 1
a380 1
         uc->ui = (b << 24) | (g << 16) | (r << 8) | 0xff;
d531 1
a531 1
      return (uint32_t) (z * 0xffff);
d536 1
a536 1
      return (uint32_t) (z * 0xffffffff);
d544 1
a544 1
      return (uint32_t) (z * 0xffffff);
d549 1
a549 1
      return ((uint32_t) (z * 0xffffff)) << 8;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d55 1
d68 1
a68 1
   case PIPE_FORMAT_A8B8G8R8_UNORM:
d73 1
a73 1
   case PIPE_FORMAT_X8B8G8R8_UNORM:
d78 1
a78 1
   case PIPE_FORMAT_B8G8R8A8_UNORM:
d83 1
a83 1
   case PIPE_FORMAT_B8G8R8X8_UNORM:
d88 1
a88 1
   case PIPE_FORMAT_A8R8G8B8_UNORM:
d93 1
a93 1
   case PIPE_FORMAT_X8R8G8B8_UNORM:
d126 1
a126 1
         uc->ub = a;
d169 1
a169 1
   case PIPE_FORMAT_A8B8G8R8_UNORM:
d178 1
a178 1
   case PIPE_FORMAT_X8B8G8R8_UNORM:
d187 1
a187 1
   case PIPE_FORMAT_B8G8R8A8_UNORM:
d196 1
a196 1
   case PIPE_FORMAT_B8G8R8X8_UNORM:
d205 1
a205 1
   case PIPE_FORMAT_A8R8G8B8_UNORM:
d214 1
a214 1
   case PIPE_FORMAT_X8R8G8B8_UNORM:
d333 2
d353 1
a353 1
   case PIPE_FORMAT_A8B8G8R8_UNORM:
d358 1
a358 1
   case PIPE_FORMAT_X8B8G8R8_UNORM:
d363 1
a363 1
   case PIPE_FORMAT_B8G8R8A8_UNORM:
d368 1
a368 1
   case PIPE_FORMAT_B8G8R8X8_UNORM:
d373 1
a373 1
   case PIPE_FORMAT_A8R8G8B8_UNORM:
d378 1
a378 1
   case PIPE_FORMAT_X8R8G8B8_UNORM:
d449 1
a449 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d452 1
a452 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d455 1
a455 1
   case PIPE_FORMAT_S8_USCALED:
d464 13
d483 1
a483 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d486 1
a486 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d489 1
a489 1
   case PIPE_FORMAT_S8_USCALED:
d500 15
d540 1
a540 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d545 1
a545 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d550 1
a550 1
   case PIPE_FORMAT_S8_USCALED:
d559 18
d589 1
a589 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d592 1
a592 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d595 1
a595 1
   case PIPE_FORMAT_S8_USCALED:
d600 18
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d40 1
d45 6
a50 1

d56 1
d102 5
d231 9
d385 5
d397 1
a397 1
         uc->ub = ((a & 0xf0) << 8) | ((r & 0xf0) << 4) | ((g & 0xf0) << 0) | (b >> 4);
d434 50
d488 1
a488 1
static INLINE uint
d491 2
d500 1
a500 1
      return (uint) (z * 0xffff);
d505 1
a505 1
      return (uint) (z * 0xffffffff);
d507 3
a509 2
      return (uint)z;
   case PIPE_FORMAT_Z24S8_UNORM:
d513 2
a514 2
      return (uint) (z * 0xffffff);
   case PIPE_FORMAT_S8Z24_UNORM:
d518 2
a519 2
      return ((uint) (z * 0xffffff)) << 8;
   case PIPE_FORMAT_S8_UNORM:
d534 2
a535 2
static INLINE uint
util_pack_z_stencil(enum pipe_format format, double z, uint s)
d537 1
a537 1
   unsigned packed = util_pack_z(format, z);
d540 2
a541 2
   case PIPE_FORMAT_Z24S8_UNORM:
      packed |= s << 24;
d543 1
a543 1
   case PIPE_FORMAT_S8Z24_UNORM:
d546 1
a546 1
   case PIPE_FORMAT_S8_UNORM:
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a39 1
#include "util/u_debug.h"
d44 1
a44 6
/**
 * Helper union for packing pixel values.
 * Will often contain values in formats which are too complex to be described
 * in simple terms, hence might just effectively contain a number of bytes.
 * Must be big enough to hold data for all formats (currently 256 bits).
 */
a49 1
   double d[4];
a94 5
   case PIPE_FORMAT_B5G5R5X1_UNORM:
      {
         uc->us = ((0x80) << 8) | ((r & 0xf8) << 7) | ((g & 0xf8) << 2) | (b >> 3);
      }
      return;
a218 9
   case PIPE_FORMAT_B5G5R5X1_UNORM:
      {
         ushort p = uc->us;
         *r = (ubyte) (((p >>  7) & 0xf8) | ((p >> 12) & 0x7));
         *g = (ubyte) (((p >>  2) & 0xf8) | ((p >>  7) & 0x7));
         *b = (ubyte) (((p <<  3) & 0xf8) | ((p >>  2) & 0x7));
         *a = (ubyte) 0xff;
      }
      return;
a363 5
   case PIPE_FORMAT_B5G5R5X1_UNORM:
      {
         uc->us = ((0x80) << 8) | ((r & 0xf8) << 7) | ((g & 0xf8) << 2) | (b >> 3);
      }
      return;
d371 1
a371 1
         uc->us = ((a & 0xf0) << 8) | ((r & 0xf0) << 4) | ((g & 0xf0) << 0) | (b >> 4);
a407 50
/* Integer versions of util_pack_z and util_pack_z_stencil - useful for
 * constructing clear masks.
 */
static INLINE uint32_t
util_pack_mask_z(enum pipe_format format, uint32_t z)
{
   switch (format) {
   case PIPE_FORMAT_Z16_UNORM:
      return z & 0xffff;
   case PIPE_FORMAT_Z32_UNORM:
   case PIPE_FORMAT_Z32_FLOAT:
      return z;
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
   case PIPE_FORMAT_Z24X8_UNORM:
      return z & 0xffffff;
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
   case PIPE_FORMAT_X8Z24_UNORM:
      return (z & 0xffffff) << 8;
   case PIPE_FORMAT_S8_USCALED:
      return 0;
   default:
      debug_print_format("gallium: unhandled format in util_pack_mask_z()", format);
      assert(0);
      return 0;
   }
}

static INLINE uint32_t
util_pack_mask_z_stencil(enum pipe_format format, uint32_t z, uint8_t s)
{
   uint32_t packed = util_pack_mask_z(format, z);

   switch (format) {
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
      packed |= (uint32_t)s << 24;
      break;
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
      packed |= s;
      break;
   case PIPE_FORMAT_S8_USCALED:
      packed |= s;
      break;
   default:
      break;
   }

   return packed;
}


d412 1
a412 1
static INLINE uint32_t
a414 2
   union fi fui;

d422 1
a422 1
      return (uint32_t) (z * 0xffff);
d427 1
a427 1
      return (uint32_t) (z * 0xffffffff);
d429 2
a430 3
      fui.f = (float)z;
      return fui.ui;
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d434 2
a435 2
      return (uint32_t) (z * 0xffffff);
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d439 2
a440 2
      return ((uint32_t) (z * 0xffffff)) << 8;
   case PIPE_FORMAT_S8_USCALED:
d455 2
a456 2
static INLINE uint32_t
util_pack_z_stencil(enum pipe_format format, double z, uint8_t s)
d458 1
a458 1
   uint32_t packed = util_pack_z(format, z);
d461 2
a462 2
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
      packed |= (uint32_t)s << 24;
d464 1
a464 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d467 1
a467 1
   case PIPE_FORMAT_S8_USCALED:
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a54 1
   ushort h[4]; /* half float */
d67 1
a67 1
   case PIPE_FORMAT_ABGR8888_UNORM:
d72 1
a72 1
   case PIPE_FORMAT_XBGR8888_UNORM:
d77 1
a77 1
   case PIPE_FORMAT_BGRA8888_UNORM:
d82 1
a82 1
   case PIPE_FORMAT_BGRX8888_UNORM:
d87 1
a87 1
   case PIPE_FORMAT_ARGB8888_UNORM:
d92 1
a92 1
   case PIPE_FORMAT_XRGB8888_UNORM:
d125 1
a125 1
         uc->ub = r;
d168 1
a168 1
   case PIPE_FORMAT_ABGR8888_UNORM:
d177 1
a177 1
   case PIPE_FORMAT_XBGR8888_UNORM:
d186 1
a186 1
   case PIPE_FORMAT_BGRA8888_UNORM:
d195 1
a195 1
   case PIPE_FORMAT_BGRX8888_UNORM:
d204 1
a204 1
   case PIPE_FORMAT_ARGB8888_UNORM:
d213 1
a213 1
   case PIPE_FORMAT_XRGB8888_UNORM:
a331 2
 * This will not work (and might not really be useful with float input)
 * for pure integer formats (which lack the pack_rgba_float function).
d350 1
a350 1
   case PIPE_FORMAT_ABGR8888_UNORM:
d355 1
a355 1
   case PIPE_FORMAT_XBGR8888_UNORM:
d360 1
a360 1
   case PIPE_FORMAT_BGRA8888_UNORM:
d365 1
a365 1
   case PIPE_FORMAT_BGRX8888_UNORM:
d370 1
a370 1
   case PIPE_FORMAT_ARGB8888_UNORM:
d375 1
a375 1
   case PIPE_FORMAT_XRGB8888_UNORM:
d446 1
a446 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d449 1
a449 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d452 1
a452 1
   case PIPE_FORMAT_S8_UINT:
a460 13

static INLINE uint64_t
util_pack64_mask_z(enum pipe_format format, uint32_t z)
{
   switch (format) {
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      return z;
   default:
      return util_pack_mask_z(format, z);
   }
}


d467 1
a467 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d470 1
a470 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d473 1
a473 1
   case PIPE_FORMAT_S8_UINT:
a483 15
static INLINE uint64_t
util_pack64_mask_z_stencil(enum pipe_format format, uint32_t z, uint8_t s)
{
   uint64_t packed;

   switch (format) {
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      packed = util_pack64_mask_z(format, z);
      packed |= (uint64_t)s << 32ull;
      return packed;
   default:
      return util_pack_mask_z_stencil(format, z, s);
   }
}

d509 1
a509 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d514 1
a514 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d519 1
a519 1
   case PIPE_FORMAT_S8_UINT:
a527 18


static INLINE uint64_t
util_pack64_z(enum pipe_format format, double z)
{
   union fi fui;

   if (z == 0)
      return 0;

   switch (format) {
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      fui.f = (float)z;
      return fui.ui;
   default:
      return util_pack_z(format, z);
   }
}
d540 1
a540 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d543 1
a543 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d546 1
a546 1
   case PIPE_FORMAT_S8_UINT:
a550 18
   }

   return packed;
}


static INLINE uint64_t
util_pack64_z_stencil(enum pipe_format format, double z, uint8_t s)
{
   uint64_t packed;

   switch (format) {
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      packed = util_pack64_z(format, z);
      packed |= (uint64_t)s << 32ull;
      break;
   default:
      return util_pack_z_stencil(format, z, s);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d54 1
a54 1
   uint ui[4];
d70 1
a70 1
         uc->ui[0] = (r << 24) | (g << 16) | (b << 8) | a;
d75 1
a75 1
         uc->ui[0] = (r << 24) | (g << 16) | (b << 8) | 0xff;
d80 1
a80 1
         uc->ui[0] = (a << 24) | (r << 16) | (g << 8) | b;
d85 1
a85 1
         uc->ui[0] = (0xff << 24) | (r << 16) | (g << 8) | b;
d90 1
a90 1
         uc->ui[0] = (b << 24) | (g << 16) | (r << 8) | a;
d95 1
a95 1
         uc->ui[0] = (b << 24) | (g << 16) | (r << 8) | 0xff;
d171 1
a171 1
         uint p = uc->ui[0];
d180 1
a180 1
         uint p = uc->ui[0];
d189 1
a189 1
         uint p = uc->ui[0];
d198 1
a198 1
         uint p = uc->ui[0];
d207 1
a207 1
         uint p = uc->ui[0];
d216 1
a216 1
         uint p = uc->ui[0];
d355 1
a355 1
         uc->ui[0] = (r << 24) | (g << 16) | (b << 8) | a;
d360 1
a360 1
         uc->ui[0] = (r << 24) | (g << 16) | (b << 8) | 0xff;
d365 1
a365 1
         uc->ui[0] = (a << 24) | (r << 16) | (g << 8) | b;
d370 1
a370 1
         uc->ui[0] = (0xff << 24) | (r << 16) | (g << 8) | b;
d375 1
a375 1
         uc->ui[0] = (b << 24) | (g << 16) | (r << 8) | a;
d380 1
a380 1
         uc->ui[0] = (b << 24) | (g << 16) | (r << 8) | 0xff;
d531 1
a531 1
      return (uint32_t) lrint(z * 0xffff);
d536 1
a536 1
      return (uint32_t) llrint(z * 0xffffffff);
d544 1
a544 1
      return (uint32_t) lrint(z * 0xffffff);
d549 1
a549 1
      return ((uint32_t) lrint(z * 0xffffff)) << 8;
@


