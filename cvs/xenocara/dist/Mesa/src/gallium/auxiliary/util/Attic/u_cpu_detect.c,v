head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.47;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.45;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.47;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.39;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.46;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2008 Dennis Smit
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * AUTHORS, COPYRIGHT HOLDERS, AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * @@file
 * CPU feature detection.
 *
 * @@author Dennis Smit
 * @@author Based on the work of Eric Anholt <anholt@@FreeBSD.org>
 */

#include "pipe/p_config.h"

#include "u_debug.h"
#include "u_cpu_detect.h"

#if defined(PIPE_ARCH_PPC)
#if defined(PIPE_OS_APPLE)
#include <sys/sysctl.h>
#else
#include <signal.h>
#include <setjmp.h>
#endif
#endif

#if defined(PIPE_OS_NETBSD) || defined(PIPE_OS_OPENBSD)
#include <sys/param.h>
#include <sys/sysctl.h>
#include <machine/cpu.h>
#endif

#if defined(PIPE_OS_FREEBSD)
#include <sys/types.h>
#include <sys/sysctl.h>
#endif

#if defined(PIPE_OS_LINUX)
#include <signal.h>
#endif

#ifdef PIPE_OS_UNIX
#include <unistd.h>
#endif

#if defined(PIPE_OS_WINDOWS)
#include <windows.h>
#if defined(PIPE_CC_MSVC)
#include <intrin.h>
#endif
#endif


#ifdef DEBUG
DEBUG_GET_ONCE_BOOL_OPTION(dump_cpu, "GALLIUM_DUMP_CPU", FALSE)
#endif


struct util_cpu_caps util_cpu_caps;

#if defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
static int has_cpuid(void);
#endif


#if defined(PIPE_ARCH_PPC) && !defined(PIPE_OS_APPLE)
static jmp_buf  __lv_powerpc_jmpbuf;
static volatile sig_atomic_t __lv_powerpc_canjump = 0;

static void
sigill_handler(int sig)
{
   if (!__lv_powerpc_canjump) {
      signal (sig, SIG_DFL);
      raise (sig);
   }

   __lv_powerpc_canjump = 0;
   longjmp(__lv_powerpc_jmpbuf, 1);
}
#endif

#if defined(PIPE_ARCH_PPC)
static void
check_os_altivec_support(void)
{
#if defined(PIPE_OS_APPLE)
   int sels[2] = {CTL_HW, HW_VECTORUNIT};
   int has_vu = 0;
   int len = sizeof (has_vu);
   int err;

   err = sysctl(sels, 2, &has_vu, &len, NULL, 0);

   if (err == 0) {
      if (has_vu != 0) {
         util_cpu_caps.has_altivec = 1;
      }
   }
#else /* !PIPE_OS_APPLE */
   /* not on Apple/Darwin, do it the brute-force way */
   /* this is borrowed from the libmpeg2 library */
   signal(SIGILL, sigill_handler);
   if (setjmp(__lv_powerpc_jmpbuf)) {
      signal(SIGILL, SIG_DFL);
   } else {
      __lv_powerpc_canjump = 1;

      __asm __volatile
         ("mtspr 256, %0\n\t"
          "vand %%v0, %%v0, %%v0"
          :
          : "r" (-1));

      signal(SIGILL, SIG_DFL);
      util_cpu_caps.has_altivec = 1;
   }
#endif /* !PIPE_OS_APPLE */
}
#endif /* PIPE_ARCH_PPC */


#if defined(PIPE_ARCH_X86) || defined (PIPE_ARCH_X86_64)
static int has_cpuid(void)
{
#if defined(PIPE_ARCH_X86)
#if defined(PIPE_OS_GCC)
   int a, c;

   __asm __volatile
      ("pushf\n"
       "popl %0\n"
       "movl %0, %1\n"
       "xorl $0x200000, %0\n"
       "push %0\n"
       "popf\n"
       "pushf\n"
       "popl %0\n"
       : "=a" (a), "=c" (c)
       :
       : "cc");

   return a != c;
#else
   /* FIXME */
   return 1;
#endif
#elif defined(PIPE_ARCH_X86_64)
   return 1;
#else
   return 0;
#endif
}


/**
 * @@sa cpuid.h included in gcc-4.3 onwards.
 * @@sa http://msdn.microsoft.com/en-us/library/hskdteyh.aspx
 */
static INLINE void
cpuid(uint32_t ax, uint32_t *p)
{
#if (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO)) && defined(PIPE_ARCH_X86)
   __asm __volatile (
     "xchgl %%ebx, %1\n\t"
     "cpuid\n\t"
     "xchgl %%ebx, %1"
     : "=a" (p[0]),
       "=S" (p[1]),
       "=c" (p[2]),
       "=d" (p[3])
     : "0" (ax)
   );
#elif (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO)) && defined(PIPE_ARCH_X86_64)
   __asm __volatile (
     "cpuid\n\t"
     : "=a" (p[0]),
       "=b" (p[1]),
       "=c" (p[2]),
       "=d" (p[3])
     : "0" (ax)
   );
#elif defined(PIPE_CC_MSVC)
   __cpuid(p, ax);
#else
   p[0] = 0;
   p[1] = 0;
   p[2] = 0;
   p[3] = 0;
#endif
}

/**
 * @@sa cpuid.h included in gcc-4.4 onwards.
 * @@sa http://msdn.microsoft.com/en-us/library/hskdteyh%28v=vs.90%29.aspx
 */
static INLINE void
cpuid_count(uint32_t ax, uint32_t cx, uint32_t *p)
{
#if (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO)) && defined(PIPE_ARCH_X86)
   __asm __volatile (
     "xchgl %%ebx, %1\n\t"
     "cpuid\n\t"
     "xchgl %%ebx, %1"
     : "=a" (p[0]),
       "=S" (p[1]),
       "=c" (p[2]),
       "=d" (p[3])
     : "0" (ax), "2" (cx)
   );
#elif (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO)) && defined(PIPE_ARCH_X86_64)
   __asm __volatile (
     "cpuid\n\t"
     : "=a" (p[0]),
       "=b" (p[1]),
       "=c" (p[2]),
       "=d" (p[3])
     : "0" (ax), "2" (cx)
   );
#elif defined(PIPE_CC_MSVC)
   __cpuidex(p, ax, cx);
#else
   p[0] = 0;
   p[1] = 0;
   p[2] = 0;
   p[3] = 0;
#endif
}


static INLINE uint64_t xgetbv(void)
{
#if defined(PIPE_CC_GCC)
   uint32_t eax, edx;

   __asm __volatile (
     ".byte 0x0f, 0x01, 0xd0" // xgetbv isn't supported on gcc < 4.4
     : "=a"(eax),
       "=d"(edx)
     : "c"(0)
   );

   return ((uint64_t)edx << 32) | eax;
#elif defined(PIPE_CC_MSVC) && defined(_MSC_FULL_VER) && defined(_XCR_XFEATURE_ENABLED_MASK)
   return _xgetbv(_XCR_XFEATURE_ENABLED_MASK);
#else
   return 0;
#endif
}


#if defined(PIPE_ARCH_X86)
static INLINE boolean sse2_has_daz(void)
{
   struct {
      uint32_t pad1[7];
      uint32_t mxcsr_mask;
      uint32_t pad2[128-8];
   } PIPE_ALIGN_VAR(16) fxarea;

   fxarea.mxcsr_mask = 0;
#if (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO))
   __asm __volatile ("fxsave %0" : "+m" (fxarea));
#elif (defined(PIPE_CC_MSVC) && _MSC_VER >= 1700) || defined(PIPE_CC_ICL)
   /* 1700 = Visual Studio 2012 */
   _fxsave(&fxarea);
#else
   fxarea.mxcsr_mask = 0;
#endif
   return !!(fxarea.mxcsr_mask & (1 << 6));
}
#endif

#endif /* X86 or X86_64 */

void
util_cpu_detect(void)
{
   static boolean util_cpu_detect_initialized = FALSE;

   if(util_cpu_detect_initialized)
      return;

   memset(&util_cpu_caps, 0, sizeof util_cpu_caps);

   /* Count the number of CPUs in system */
#if defined(PIPE_OS_WINDOWS)
   {
      SYSTEM_INFO system_info;
      GetSystemInfo(&system_info);
      util_cpu_caps.nr_cpus = system_info.dwNumberOfProcessors;
   }
#elif defined(PIPE_OS_UNIX) && defined(_SC_NPROCESSORS_ONLN)
   util_cpu_caps.nr_cpus = sysconf(_SC_NPROCESSORS_ONLN);
   if (util_cpu_caps.nr_cpus == -1)
      util_cpu_caps.nr_cpus = 1;
#elif defined(PIPE_OS_BSD)
   {
      int mib[2], ncpu;
      int len;

      mib[0] = CTL_HW;
      mib[1] = HW_NCPU;

      len = sizeof (ncpu);
      sysctl(mib, 2, &ncpu, &len, NULL, 0);
      util_cpu_caps.nr_cpus = ncpu;
   }
#else
   util_cpu_caps.nr_cpus = 1;
#endif

   /* Make the fallback cacheline size nonzero so that it can be
    * safely passed to align().
    */
   util_cpu_caps.cacheline = sizeof(void *);

#if defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   if (has_cpuid()) {
      uint32_t regs[4];
      uint32_t regs2[4];

      util_cpu_caps.cacheline = 32;

      /* Get max cpuid level */
      cpuid(0x00000000, regs);

      if (regs[0] >= 0x00000001) {
         unsigned int cacheline;

         cpuid (0x00000001, regs2);

         util_cpu_caps.x86_cpu_type = (regs2[0] >> 8) & 0xf;
         if (util_cpu_caps.x86_cpu_type == 0xf)
             util_cpu_caps.x86_cpu_type = 8 + ((regs2[0] >> 20) & 255); /* use extended family (P4, IA64) */

         /* general feature flags */
         util_cpu_caps.has_tsc    = (regs2[3] >>  4) & 1; /* 0x0000010 */
         util_cpu_caps.has_mmx    = (regs2[3] >> 23) & 1; /* 0x0800000 */
         util_cpu_caps.has_sse    = (regs2[3] >> 25) & 1; /* 0x2000000 */
         util_cpu_caps.has_sse2   = (regs2[3] >> 26) & 1; /* 0x4000000 */
         util_cpu_caps.has_sse3   = (regs2[2] >>  0) & 1; /* 0x0000001 */
         util_cpu_caps.has_ssse3  = (regs2[2] >>  9) & 1; /* 0x0000020 */
         util_cpu_caps.has_sse4_1 = (regs2[2] >> 19) & 1;
         util_cpu_caps.has_sse4_2 = (regs2[2] >> 20) & 1;
         util_cpu_caps.has_popcnt = (regs2[2] >> 23) & 1;
         util_cpu_caps.has_avx    = ((regs2[2] >> 28) & 1) && // AVX
                                    ((regs2[2] >> 27) & 1) && // OSXSAVE
                                    ((xgetbv() & 6) == 6);    // XMM & YMM
         util_cpu_caps.has_f16c   = (regs2[2] >> 29) & 1;
         util_cpu_caps.has_mmx2   = util_cpu_caps.has_sse; /* SSE cpus supports mmxext too */
#if defined(PIPE_ARCH_X86_64)
         util_cpu_caps.has_daz = 1;
#else
         util_cpu_caps.has_daz = util_cpu_caps.has_sse3 ||
            (util_cpu_caps.has_sse2 && sse2_has_daz());
#endif

         cacheline = ((regs2[1] >> 8) & 0xFF) * 8;
         if (cacheline > 0)
            util_cpu_caps.cacheline = cacheline;
      }
      if (util_cpu_caps.has_avx && regs[0] >= 0x00000007) {
         uint32_t regs7[4];
         cpuid_count(0x00000007, 0x00000000, regs7);
         util_cpu_caps.has_avx2 = (regs7[1] >> 5) & 1;
      }

      if (regs[1] == 0x756e6547 && regs[2] == 0x6c65746e && regs[3] == 0x49656e69) {
         /* GenuineIntel */
         util_cpu_caps.has_intel = 1;
      }

      cpuid(0x80000000, regs);

      if (regs[0] >= 0x80000001) {

         cpuid(0x80000001, regs2);

         util_cpu_caps.has_mmx  |= (regs2[3] >> 23) & 1;
         util_cpu_caps.has_mmx2 |= (regs2[3] >> 22) & 1;
         util_cpu_caps.has_3dnow = (regs2[3] >> 31) & 1;
         util_cpu_caps.has_3dnow_ext = (regs2[3] >> 30) & 1;

         util_cpu_caps.has_xop = util_cpu_caps.has_avx &&
                                 ((regs2[2] >> 11) & 1);
      }

      if (regs[0] >= 0x80000006) {
         cpuid(0x80000006, regs2);
         util_cpu_caps.cacheline = regs2[2] & 0xFF;
      }

      if (!util_cpu_caps.has_sse) {
         util_cpu_caps.has_sse2 = 0;
         util_cpu_caps.has_sse3 = 0;
         util_cpu_caps.has_ssse3 = 0;
         util_cpu_caps.has_sse4_1 = 0;
      }
   }
#endif /* PIPE_ARCH_X86 || PIPE_ARCH_X86_64 */

#if defined(PIPE_ARCH_PPC)
   check_os_altivec_support();
#endif /* PIPE_ARCH_PPC */

#ifdef DEBUG
   if (debug_get_option_dump_cpu()) {
      debug_printf("util_cpu_caps.nr_cpus = %u\n", util_cpu_caps.nr_cpus);

      debug_printf("util_cpu_caps.x86_cpu_type = %u\n", util_cpu_caps.x86_cpu_type);
      debug_printf("util_cpu_caps.cacheline = %u\n", util_cpu_caps.cacheline);

      debug_printf("util_cpu_caps.has_tsc = %u\n", util_cpu_caps.has_tsc);
      debug_printf("util_cpu_caps.has_mmx = %u\n", util_cpu_caps.has_mmx);
      debug_printf("util_cpu_caps.has_mmx2 = %u\n", util_cpu_caps.has_mmx2);
      debug_printf("util_cpu_caps.has_sse = %u\n", util_cpu_caps.has_sse);
      debug_printf("util_cpu_caps.has_sse2 = %u\n", util_cpu_caps.has_sse2);
      debug_printf("util_cpu_caps.has_sse3 = %u\n", util_cpu_caps.has_sse3);
      debug_printf("util_cpu_caps.has_ssse3 = %u\n", util_cpu_caps.has_ssse3);
      debug_printf("util_cpu_caps.has_sse4_1 = %u\n", util_cpu_caps.has_sse4_1);
      debug_printf("util_cpu_caps.has_sse4_2 = %u\n", util_cpu_caps.has_sse4_2);
      debug_printf("util_cpu_caps.has_avx = %u\n", util_cpu_caps.has_avx);
      debug_printf("util_cpu_caps.has_avx2 = %u\n", util_cpu_caps.has_avx2);
      debug_printf("util_cpu_caps.has_f16c = %u\n", util_cpu_caps.has_f16c);
      debug_printf("util_cpu_caps.has_popcnt = %u\n", util_cpu_caps.has_popcnt);
      debug_printf("util_cpu_caps.has_3dnow = %u\n", util_cpu_caps.has_3dnow);
      debug_printf("util_cpu_caps.has_3dnow_ext = %u\n", util_cpu_caps.has_3dnow_ext);
      debug_printf("util_cpu_caps.has_xop = %u\n", util_cpu_caps.has_xop);
      debug_printf("util_cpu_caps.has_altivec = %u\n", util_cpu_caps.has_altivec);
      debug_printf("util_cpu_caps.has_daz = %u\n", util_cpu_caps.has_daz);
   }
#endif

   util_cpu_detect_initialized = TRUE;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d275 1
a275 1
PIPE_ALIGN_STACK static INLINE boolean sse2_has_daz(void)
d372 1
a372 1
         util_cpu_caps.has_f16c   = ((regs2[2] >> 29) & 1) && util_cpu_caps.has_avx;
a411 2
         /* should we really do this if the clflush size above worked? */
         unsigned int cacheline;
d413 1
a413 3
         cacheline = regs2[2] & 0xFF;
         if (cacheline > 0)
            util_cpu_caps.cacheline = cacheline;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d275 1
a275 1
static INLINE boolean sse2_has_daz(void)
d372 1
a372 1
         util_cpu_caps.has_f16c   = (regs2[2] >> 29) & 1;
d412 2
d415 3
a417 1
         util_cpu_caps.cacheline = regs2[2] & 0xFF;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d70 1
a70 1
#if defined(MSVC)
d214 82
d369 3
a371 1
         util_cpu_caps.has_avx    = (regs2[2] >> 28) & 1;
d374 6
d385 5
d406 3
d446 3
d451 1
d453 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d185 1
a185 1
#if defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86)
d196 1
a196 1
#elif defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86_64)
d253 5
d278 1
a278 1
         util_cpu_caps.has_tsc    = (regs2[3] >>  8) & 1; /* 0x0000010 */
d286 1
d288 1
d294 5
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d273 9
a281 7
         util_cpu_caps.has_tsc    = (regs2[3] & (1 << 8  )) >>  8; /* 0x0000010 */
         util_cpu_caps.has_mmx    = (regs2[3] & (1 << 23 )) >> 23; /* 0x0800000 */
         util_cpu_caps.has_sse    = (regs2[3] & (1 << 25 )) >> 25; /* 0x2000000 */
         util_cpu_caps.has_sse2   = (regs2[3] & (1 << 26 )) >> 26; /* 0x4000000 */
         util_cpu_caps.has_sse3   = (regs2[2] & (1));          /* 0x0000001 */
         util_cpu_caps.has_ssse3  = (regs2[2] & (1 << 9 )) >> 9;   /* 0x0000020 */
         util_cpu_caps.has_sse4_1 = (regs2[2] & (1 << 19)) >> 19;
d295 4
a298 4
         util_cpu_caps.has_mmx  |= (regs2[3] & (1 << 23 )) >> 23; /* 0x0800000 */
         util_cpu_caps.has_mmx2 |= (regs2[3] & (1 << 22 )) >> 22; /* 0x400000 */
         util_cpu_caps.has_3dnow    = (regs2[3] & (1 << 31 )) >> 31; /* 0x80000000 */
         util_cpu_caps.has_3dnow_ext = (regs2[3] & (1 << 30 )) >> 30;
d334 2
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d41 1
a41 1
#if defined(PIPE_OS_DARWIN)
d76 5
d83 1
d85 1
a86 51
#if defined(PIPE_ARCH_X86)

/* The sigill handlers */
#if defined(PIPE_OS_LINUX) /*&& defined(_POSIX_SOURCE) && defined(X86_FXSR_MAGIC)*/
static void
sigill_handler_sse(int signal, struct sigcontext sc)
{
   /* Both the "xorps %%xmm0,%%xmm0" and "divps %xmm0,%%xmm1"
    * instructions are 3 bytes long.  We must increment the instruction
    * pointer manually to avoid repeated execution of the offending
    * instruction.
    *
    * If the SIGILL is caused by a divide-by-zero when unmasked
    * exceptions aren't supported, the SIMD FPU status and control
    * word will be restored at the end of the test, so we don't need
    * to worry about doing it here.  Besides, we may not be able to...
    */
   sc.eip += 3;

   util_cpu_caps.has_sse=0;
}

static void
sigfpe_handler_sse(int signal, struct sigcontext sc)
{
   if (sc.fpstate->magic != 0xffff) {
      /* Our signal context has the extended FPU state, so reset the
       * divide-by-zero exception mask and clear the divide-by-zero
       * exception bit.
       */
      sc.fpstate->mxcsr |= 0x00000200;
      sc.fpstate->mxcsr &= 0xfffffffb;
   } else {
      /* If we ever get here, we're completely hosed.
      */
   }
}
#endif /* PIPE_OS_LINUX && _POSIX_SOURCE && X86_FXSR_MAGIC */

#if defined(PIPE_OS_WINDOWS)
static LONG CALLBACK
win32_sig_handler_sse(EXCEPTION_POINTERS* ep)
{
   if(ep->ExceptionRecord->ExceptionCode==EXCEPTION_ILLEGAL_INSTRUCTION){
      ep->ContextRecord->Eip +=3;
      util_cpu_caps.has_sse=0;
      return EXCEPTION_CONTINUE_EXECUTION;
   }
   return EXCEPTION_CONTINUE_SEARCH;
}
#endif /* PIPE_OS_WINDOWS */
d88 1
a88 4
#endif /* PIPE_ARCH_X86 */


#if defined(PIPE_ARCH_PPC) && !defined(PIPE_OS_DARWIN)
d109 1
a109 1
#if defined(PIPE_OS_DARWIN)
d122 2
a123 2
#else /* !PIPE_OS_DARWIN */
   /* no Darwin, do it the brute-force way */
d140 1
a140 1
#endif /* PIPE_OS_DARWIN */
d144 1
a144 6
/* If we're running on a processor that can do SSE, let's see if we
 * are allowed to or not.  This will catch 2.4.0 or later kernels that
 * haven't been configured for a Pentium III but are running on one,
 * and RedHat patched 2.2 kernels that have broken exception handling
 * support for user space apps that do SSE.
 */
a145 110
static void
check_os_katmai_support(void)
{
#if defined(PIPE_ARCH_X86)
#if defined(PIPE_OS_FREEBSD)
   int has_sse=0, ret;
   int len = sizeof (has_sse);

   ret = sysctlbyname("hw.instruction_sse", &has_sse, &len, NULL, 0);
   if (ret || !has_sse)
      util_cpu_caps.has_sse=0;

#elif defined(PIPE_OS_NETBSD) || defined(PIPE_OS_OPENBSD)
   int has_sse, has_sse2, ret, mib[2];
   int varlen;

   mib[0] = CTL_MACHDEP;
   mib[1] = CPU_SSE;
   varlen = sizeof (has_sse);

   ret = sysctl(mib, 2, &has_sse, &varlen, NULL, 0);
   if (ret < 0 || !has_sse) {
      util_cpu_caps.has_sse = 0;
   } else {
      util_cpu_caps.has_sse = 1;
   }

   mib[1] = CPU_SSE2;
   varlen = sizeof (has_sse2);
   ret = sysctl(mib, 2, &has_sse2, &varlen, NULL, 0);
   if (ret < 0 || !has_sse2) {
      util_cpu_caps.has_sse2 = 0;
   } else {
      util_cpu_caps.has_sse2 = 1;
   }
   util_cpu_caps.has_sse = 0; /* FIXME ?!?!? */

#elif defined(PIPE_OS_WINDOWS)
   LPTOP_LEVEL_EXCEPTION_FILTER exc_fil;
   if (util_cpu_caps.has_sse) {
      exc_fil = SetUnhandledExceptionFilter(win32_sig_handler_sse);
#if defined(PIPE_CC_GCC)
      __asm __volatile ("xorps %xmm0, %xmm0");
#elif defined(PIPE_CC_MSVC)
      __asm {
          xorps xmm0, xmm0        /* executing SSE instruction */
      }
#else
#error Unsupported compiler
#endif
      SetUnhandledExceptionFilter(exc_fil);
   }
#elif defined(PIPE_OS_LINUX)
   struct sigaction saved_sigill;
   struct sigaction saved_sigfpe;

   /* Save the original signal handlers.
   */
   sigaction(SIGILL, NULL, &saved_sigill);
   sigaction(SIGFPE, NULL, &saved_sigfpe);

   signal(SIGILL, (void (*)(int))sigill_handler_sse);
   signal(SIGFPE, (void (*)(int))sigfpe_handler_sse);

   /* Emulate test for OSFXSR in CR4.  The OS will set this bit if it
    * supports the extended FPU save and restore required for SSE.  If
    * we execute an SSE instruction on a PIII and get a SIGILL, the OS
    * doesn't support Streaming SIMD Exceptions, even if the processor
    * does.
    */
   if (util_cpu_caps.has_sse) {
      __asm __volatile ("xorps %xmm1, %xmm0");
   }

   /* Emulate test for OSXMMEXCPT in CR4.  The OS will set this bit if
    * it supports unmasked SIMD FPU exceptions.  If we unmask the
    * exceptions, do a SIMD divide-by-zero and get a SIGILL, the OS
    * doesn't support unmasked SIMD FPU exceptions.  If we get a SIGFPE
    * as expected, we're okay but we need to clean up after it.
    *
    * Are we being too stringent in our requirement that the OS support
    * unmasked exceptions?  Certain RedHat 2.2 kernels enable SSE by
    * setting CR4.OSFXSR but don't support unmasked exceptions.  Win98
    * doesn't even support them.  We at least know the user-space SSE
    * support is good in kernels that do support unmasked exceptions,
    * and therefore to be safe I'm going to leave this test in here.
    */
   if (util_cpu_caps.has_sse) {
      /* test_os_katmai_exception_support(); */
   }

   /* Restore the original signal handlers.
   */
   sigaction(SIGILL, &saved_sigill, NULL);
   sigaction(SIGFPE, &saved_sigfpe, NULL);

#else
   /* We can't use POSIX signal handling to test the availability of
    * SSE, so we disable it by default.
    */
   util_cpu_caps.has_sse = 0;
#endif /* __linux__ */
#endif

#if defined(PIPE_ARCH_X86_64)
   util_cpu_caps.has_sse = 1;
#endif
}


a225 17
   /* Check for arch type */
#if defined(PIPE_ARCH_MIPS)
   util_cpu_caps.arch = UTIL_CPU_ARCH_MIPS;
#elif defined(PIPE_ARCH_ALPHA)
   util_cpu_caps.arch = UTIL_CPU_ARCH_ALPHA;
#elif defined(PIPE_ARCH_SPARC)
   util_cpu_caps.arch = UTIL_CPU_ARCH_SPARC;
#elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   util_cpu_caps.arch = UTIL_CPU_ARCH_X86;
   util_cpu_caps.little_endian = 1;
#elif defined(PIPE_ARCH_PPC)
   util_cpu_caps.arch = UTIL_CPU_ARCH_POWERPC;
   util_cpu_caps.little_endian = 0;
#else
   util_cpu_caps.arch = UTIL_CPU_ARCH_UNKNOWN;
#endif

a303 3
      if (util_cpu_caps.has_sse)
         check_os_katmai_support();

d318 2
a319 2
   debug_printf("util_cpu_caps.arch = %i\n", util_cpu_caps.arch);
   debug_printf("util_cpu_caps.nr_cpus = %u\n", util_cpu_caps.nr_cpus);
d321 2
a322 2
   debug_printf("util_cpu_caps.x86_cpu_type = %u\n", util_cpu_caps.x86_cpu_type);
   debug_printf("util_cpu_caps.cacheline = %u\n", util_cpu_caps.cacheline);
d324 12
a335 11
   debug_printf("util_cpu_caps.has_tsc = %u\n", util_cpu_caps.has_tsc);
   debug_printf("util_cpu_caps.has_mmx = %u\n", util_cpu_caps.has_mmx);
   debug_printf("util_cpu_caps.has_mmx2 = %u\n", util_cpu_caps.has_mmx2);
   debug_printf("util_cpu_caps.has_sse = %u\n", util_cpu_caps.has_sse);
   debug_printf("util_cpu_caps.has_sse2 = %u\n", util_cpu_caps.has_sse2);
   debug_printf("util_cpu_caps.has_sse3 = %u\n", util_cpu_caps.has_sse3);
   debug_printf("util_cpu_caps.has_ssse3 = %u\n", util_cpu_caps.has_ssse3);
   debug_printf("util_cpu_caps.has_sse4_1 = %u\n", util_cpu_caps.has_sse4_1);
   debug_printf("util_cpu_caps.has_3dnow = %u\n", util_cpu_caps.has_3dnow);
   debug_printf("util_cpu_caps.has_3dnow_ext = %u\n", util_cpu_caps.has_3dnow_ext);
   debug_printf("util_cpu_caps.has_altivec = %u\n", util_cpu_caps.has_altivec);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d41 1
a41 1
#if defined(PIPE_OS_APPLE)
d76 25
a100 3
#ifdef DEBUG
DEBUG_GET_ONCE_BOOL_OPTION(dump_cpu, "GALLIUM_DUMP_CPU", FALSE)
#endif
d102 16
d119 12
a130 1
struct util_cpu_caps util_cpu_caps;
d132 1
a132 3
#if defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
static int has_cpuid(void);
#endif
d135 1
a135 1
#if defined(PIPE_ARCH_PPC) && !defined(PIPE_OS_APPLE)
d156 1
a156 1
#if defined(PIPE_OS_APPLE)
d169 2
a170 2
#else /* !PIPE_OS_APPLE */
   /* not on Apple/Darwin, do it the brute-force way */
d187 1
a187 1
#endif /* !PIPE_OS_APPLE */
d191 116
a307 1
#if defined(PIPE_ARCH_X86) || defined (PIPE_ARCH_X86_64)
d388 17
d483 3
d500 2
a501 2
   if (debug_get_option_dump_cpu()) {
      debug_printf("util_cpu_caps.nr_cpus = %u\n", util_cpu_caps.nr_cpus);
d503 2
a504 2
      debug_printf("util_cpu_caps.x86_cpu_type = %u\n", util_cpu_caps.x86_cpu_type);
      debug_printf("util_cpu_caps.cacheline = %u\n", util_cpu_caps.cacheline);
d506 11
a516 12
      debug_printf("util_cpu_caps.has_tsc = %u\n", util_cpu_caps.has_tsc);
      debug_printf("util_cpu_caps.has_mmx = %u\n", util_cpu_caps.has_mmx);
      debug_printf("util_cpu_caps.has_mmx2 = %u\n", util_cpu_caps.has_mmx2);
      debug_printf("util_cpu_caps.has_sse = %u\n", util_cpu_caps.has_sse);
      debug_printf("util_cpu_caps.has_sse2 = %u\n", util_cpu_caps.has_sse2);
      debug_printf("util_cpu_caps.has_sse3 = %u\n", util_cpu_caps.has_sse3);
      debug_printf("util_cpu_caps.has_ssse3 = %u\n", util_cpu_caps.has_ssse3);
      debug_printf("util_cpu_caps.has_sse4_1 = %u\n", util_cpu_caps.has_sse4_1);
      debug_printf("util_cpu_caps.has_3dnow = %u\n", util_cpu_caps.has_3dnow);
      debug_printf("util_cpu_caps.has_3dnow_ext = %u\n", util_cpu_caps.has_3dnow_ext);
      debug_printf("util_cpu_caps.has_altivec = %u\n", util_cpu_caps.has_altivec);
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d185 1
a185 1
#if (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO)) && defined(PIPE_ARCH_X86)
d196 1
a196 1
#elif (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO)) && defined(PIPE_ARCH_X86_64)
a252 5
   /* Make the fallback cacheline size nonzero so that it can be
    * safely passed to align().
    */
   util_cpu_caps.cacheline = sizeof(void *);

d273 7
a279 11
         util_cpu_caps.has_tsc    = (regs2[3] >>  4) & 1; /* 0x0000010 */
         util_cpu_caps.has_mmx    = (regs2[3] >> 23) & 1; /* 0x0800000 */
         util_cpu_caps.has_sse    = (regs2[3] >> 25) & 1; /* 0x2000000 */
         util_cpu_caps.has_sse2   = (regs2[3] >> 26) & 1; /* 0x4000000 */
         util_cpu_caps.has_sse3   = (regs2[2] >>  0) & 1; /* 0x0000001 */
         util_cpu_caps.has_ssse3  = (regs2[2] >>  9) & 1; /* 0x0000020 */
         util_cpu_caps.has_sse4_1 = (regs2[2] >> 19) & 1;
         util_cpu_caps.has_sse4_2 = (regs2[2] >> 20) & 1;
         util_cpu_caps.has_popcnt = (regs2[2] >> 23) & 1;
         util_cpu_caps.has_avx    = (regs2[2] >> 28) & 1;
         util_cpu_caps.has_f16c   = (regs2[2] >> 29) & 1;
a286 5
      if (regs[1] == 0x756e6547 && regs[2] == 0x6c65746e && regs[3] == 0x49656e69) {
         /* GenuineIntel */
         util_cpu_caps.has_intel = 1;
      }

d293 4
a296 4
         util_cpu_caps.has_mmx  |= (regs2[3] >> 23) & 1;
         util_cpu_caps.has_mmx2 |= (regs2[3] >> 22) & 1;
         util_cpu_caps.has_3dnow = (regs2[3] >> 31) & 1;
         util_cpu_caps.has_3dnow_ext = (regs2[3] >> 30) & 1;
a331 2
      debug_printf("util_cpu_caps.has_sse4_2 = %u\n", util_cpu_caps.has_sse4_2);
      debug_printf("util_cpu_caps.has_avx = %u\n", util_cpu_caps.has_avx);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d70 1
a70 1
#if defined(PIPE_CC_MSVC)
a213 82

/**
 * @@sa cpuid.h included in gcc-4.4 onwards.
 * @@sa http://msdn.microsoft.com/en-us/library/hskdteyh%28v=vs.90%29.aspx
 */
static INLINE void
cpuid_count(uint32_t ax, uint32_t cx, uint32_t *p)
{
#if (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO)) && defined(PIPE_ARCH_X86)
   __asm __volatile (
     "xchgl %%ebx, %1\n\t"
     "cpuid\n\t"
     "xchgl %%ebx, %1"
     : "=a" (p[0]),
       "=S" (p[1]),
       "=c" (p[2]),
       "=d" (p[3])
     : "0" (ax), "2" (cx)
   );
#elif (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO)) && defined(PIPE_ARCH_X86_64)
   __asm __volatile (
     "cpuid\n\t"
     : "=a" (p[0]),
       "=b" (p[1]),
       "=c" (p[2]),
       "=d" (p[3])
     : "0" (ax), "2" (cx)
   );
#elif defined(PIPE_CC_MSVC)
   __cpuidex(p, ax, cx);
#else
   p[0] = 0;
   p[1] = 0;
   p[2] = 0;
   p[3] = 0;
#endif
}


static INLINE uint64_t xgetbv(void)
{
#if defined(PIPE_CC_GCC)
   uint32_t eax, edx;

   __asm __volatile (
     ".byte 0x0f, 0x01, 0xd0" // xgetbv isn't supported on gcc < 4.4
     : "=a"(eax),
       "=d"(edx)
     : "c"(0)
   );

   return ((uint64_t)edx << 32) | eax;
#elif defined(PIPE_CC_MSVC) && defined(_MSC_FULL_VER) && defined(_XCR_XFEATURE_ENABLED_MASK)
   return _xgetbv(_XCR_XFEATURE_ENABLED_MASK);
#else
   return 0;
#endif
}


#if defined(PIPE_ARCH_X86)
static INLINE boolean sse2_has_daz(void)
{
   struct {
      uint32_t pad1[7];
      uint32_t mxcsr_mask;
      uint32_t pad2[128-8];
   } PIPE_ALIGN_VAR(16) fxarea;

   fxarea.mxcsr_mask = 0;
#if (defined(PIPE_CC_GCC) || defined(PIPE_CC_SUNPRO))
   __asm __volatile ("fxsave %0" : "+m" (fxarea));
#elif (defined(PIPE_CC_MSVC) && _MSC_VER >= 1700) || defined(PIPE_CC_ICL)
   /* 1700 = Visual Studio 2012 */
   _fxsave(&fxarea);
#else
   fxarea.mxcsr_mask = 0;
#endif
   return !!(fxarea.mxcsr_mask & (1 << 6));
}
#endif

d287 1
a287 3
         util_cpu_caps.has_avx    = ((regs2[2] >> 28) & 1) && // AVX
                                    ((regs2[2] >> 27) & 1) && // OSXSAVE
                                    ((xgetbv() & 6) == 6);    // XMM & YMM
a289 6
#if defined(PIPE_ARCH_X86_64)
         util_cpu_caps.has_daz = 1;
#else
         util_cpu_caps.has_daz = util_cpu_caps.has_sse3 ||
            (util_cpu_caps.has_sse2 && sse2_has_daz());
#endif
a294 5
      if (util_cpu_caps.has_avx && regs[0] >= 0x00000007) {
         uint32_t regs7[4];
         cpuid_count(0x00000007, 0x00000000, regs7);
         util_cpu_caps.has_avx2 = (regs7[1] >> 5) & 1;
      }
a310 3

         util_cpu_caps.has_xop = util_cpu_caps.has_avx &&
                                 ((regs2[2] >> 11) & 1);
a347 3
      debug_printf("util_cpu_caps.has_avx2 = %u\n", util_cpu_caps.has_avx2);
      debug_printf("util_cpu_caps.has_f16c = %u\n", util_cpu_caps.has_f16c);
      debug_printf("util_cpu_caps.has_popcnt = %u\n", util_cpu_caps.has_popcnt);
a349 1
      debug_printf("util_cpu_caps.has_xop = %u\n", util_cpu_caps.has_xop);
a350 1
      debug_printf("util_cpu_caps.has_daz = %u\n", util_cpu_caps.has_daz);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d275 1
a275 1
PIPE_ALIGN_STACK static INLINE boolean sse2_has_daz(void)
d372 1
a372 1
         util_cpu_caps.has_f16c   = ((regs2[2] >> 29) & 1) && util_cpu_caps.has_avx;
a411 2
         /* should we really do this if the clflush size above worked? */
         unsigned int cacheline;
d413 1
a413 3
         cacheline = regs2[2] & 0xFF;
         if (cacheline > 0)
            util_cpu_caps.cacheline = cacheline;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d275 1
a275 1
static INLINE boolean sse2_has_daz(void)
d372 1
a372 1
         util_cpu_caps.has_f16c   = (regs2[2] >> 29) & 1;
d412 2
d415 3
a417 1
         util_cpu_caps.cacheline = regs2[2] & 0xFF;
@


