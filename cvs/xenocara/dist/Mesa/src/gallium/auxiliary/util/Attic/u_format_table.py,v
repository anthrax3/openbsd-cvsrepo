head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.50;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.49;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.47;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.44;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.50;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@#!/usr/bin/env python

CopyRight = '''
/**************************************************************************
 *
 * Copyright 2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/
'''


import sys

from u_format_parse import *
import u_format_pack


def layout_map(layout):
    return 'UTIL_FORMAT_LAYOUT_' + str(layout).upper()


def colorspace_map(colorspace):
    return 'UTIL_FORMAT_COLORSPACE_' + str(colorspace).upper()


colorspace_channels_map = {
    'rgb': ['r', 'g', 'b', 'a'],
    'srgb': ['sr', 'sg', 'sb', 'a'],
    'zs': ['z', 's'],
    'yuv': ['y', 'u', 'v'],
}


type_map = {
    VOID:     "UTIL_FORMAT_TYPE_VOID",
    UNSIGNED: "UTIL_FORMAT_TYPE_UNSIGNED",
    SIGNED:   "UTIL_FORMAT_TYPE_SIGNED",
    FIXED:    "UTIL_FORMAT_TYPE_FIXED",
    FLOAT:    "UTIL_FORMAT_TYPE_FLOAT",
}


def bool_map(value):
    if value:
        return "TRUE"
    else:
        return "FALSE"


swizzle_map = {
    SWIZZLE_X:    "UTIL_FORMAT_SWIZZLE_X",
    SWIZZLE_Y:    "UTIL_FORMAT_SWIZZLE_Y",
    SWIZZLE_Z:    "UTIL_FORMAT_SWIZZLE_Z",
    SWIZZLE_W:    "UTIL_FORMAT_SWIZZLE_W",
    SWIZZLE_0:    "UTIL_FORMAT_SWIZZLE_0",
    SWIZZLE_1:    "UTIL_FORMAT_SWIZZLE_1",
    SWIZZLE_NONE: "UTIL_FORMAT_SWIZZLE_NONE",
}


def write_format_table(formats):
    print '/* This file is autogenerated by u_format_table.py from u_format.csv. Do not edit directly. */'
    print
    # This will print the copyright message on the top of this file
    print CopyRight.strip()
    print
    print '#include "u_format.h"'
    print '#include "u_format_s3tc.h"'
    print '#include "u_format_rgtc.h"'
    print '#include "u_format_latc.h"'
    print '#include "u_format_etc.h"'
    print
    
    u_format_pack.generate(formats)
    
    def do_channel_array(channels, swizzles):
        print "   {"
        for i in range(4):
            channel = channels[i]
            if i < 3:
                sep = ","
            else:
                sep = ""
            if channel.size:
                print "      {%s, %s, %s, %u, %u}%s\t/* %s = %s */" % (type_map[channel.type], bool_map(channel.norm), bool_map(channel.pure), channel.size, channel.shift, sep, "xyzw"[i], channel.name)
            else:
                print "      {0, 0, 0, 0, 0}%s" % (sep,)
        print "   },"

    def do_swizzle_array(channels, swizzles):
        print "   {"
        for i in range(4):
            swizzle = swizzles[i]
            if i < 3:
                sep = ","
            else:
                sep = ""
            try:
                comment = colorspace_channels_map[format.colorspace][i]
            except (KeyError, IndexError):
                comment = 'ignored'
            print "      %s%s\t/* %s */" % (swizzle_map[swizzle], sep, comment)
        print "   },"

    for format in formats:
        print 'const struct util_format_description'
        print 'util_format_%s_description = {' % (format.short_name(),)
        print "   %s," % (format.name,)
        print "   \"%s\"," % (format.name,)
        print "   \"%s\"," % (format.short_name(),)
        print "   {%u, %u, %u},\t/* block */" % (format.block_width, format.block_height, format.block_size())
        print "   %s," % (layout_map(format.layout),)
        print "   %u,\t/* nr_channels */" % (format.nr_channels(),)
        print "   %s,\t/* is_array */" % (bool_map(format.is_array()),)
        print "   %s,\t/* is_bitmask */" % (bool_map(format.is_bitmask()),)
        print "   %s,\t/* is_mixed */" % (bool_map(format.is_mixed()),)
        u_format_pack.print_channels(format, do_channel_array)
        u_format_pack.print_channels(format, do_swizzle_array)
        print "   %s," % (colorspace_map(format.colorspace),)
        if format.colorspace != ZS and not format.is_pure_color():
            print "   &util_format_%s_unpack_rgba_8unorm," % format.short_name() 
            print "   &util_format_%s_pack_rgba_8unorm," % format.short_name() 
            if format.layout == 's3tc' or format.layout == 'rgtc':
                print "   &util_format_%s_fetch_rgba_8unorm," % format.short_name()
            else:
                print "   NULL, /* fetch_rgba_8unorm */" 
            print "   &util_format_%s_unpack_rgba_float," % format.short_name() 
            print "   &util_format_%s_pack_rgba_float," % format.short_name() 
            print "   &util_format_%s_fetch_rgba_float," % format.short_name()
        else:
            print "   NULL, /* unpack_rgba_8unorm */" 
            print "   NULL, /* pack_rgba_8unorm */" 
            print "   NULL, /* fetch_rgba_8unorm */" 
            print "   NULL, /* unpack_rgba_float */" 
            print "   NULL, /* pack_rgba_float */" 
            print "   NULL, /* fetch_rgba_float */" 
        if format.has_depth():
            print "   &util_format_%s_unpack_z_32unorm," % format.short_name() 
            print "   &util_format_%s_pack_z_32unorm," % format.short_name() 
            print "   &util_format_%s_unpack_z_float," % format.short_name() 
            print "   &util_format_%s_pack_z_float," % format.short_name() 
        else:
            print "   NULL, /* unpack_z_32unorm */" 
            print "   NULL, /* pack_z_32unorm */" 
            print "   NULL, /* unpack_z_float */" 
            print "   NULL, /* pack_z_float */" 
        if format.has_stencil():
            print "   &util_format_%s_unpack_s_8uint," % format.short_name() 
            print "   &util_format_%s_pack_s_8uint," % format.short_name() 
        else:
            print "   NULL, /* unpack_s_8uint */" 
            print "   NULL, /* pack_s_8uint */"
        if format.is_pure_unsigned():
            print "   &util_format_%s_unpack_unsigned, /* unpack_rgba_uint */" % format.short_name() 
            print "   &util_format_%s_pack_unsigned, /* pack_rgba_uint */" % format.short_name()
            print "   &util_format_%s_unpack_signed, /* unpack_rgba_sint */" % format.short_name()
            print "   &util_format_%s_pack_signed,  /* pack_rgba_sint */" % format.short_name()
            print "   &util_format_%s_fetch_unsigned,  /* fetch_rgba_uint */" % format.short_name()
            print "   NULL  /* fetch_rgba_sint */"
        elif format.is_pure_signed():
            print "   &util_format_%s_unpack_unsigned, /* unpack_rgba_uint */" % format.short_name()
            print "   &util_format_%s_pack_unsigned, /* pack_rgba_uint */" % format.short_name()
            print "   &util_format_%s_unpack_signed, /* unpack_rgba_sint */" % format.short_name()
            print "   &util_format_%s_pack_signed,  /* pack_rgba_sint */" % format.short_name()
            print "   NULL,  /* fetch_rgba_uint */"
            print "   &util_format_%s_fetch_signed  /* fetch_rgba_sint */" % format.short_name()
        else:
            print "   NULL, /* unpack_rgba_uint */" 
            print "   NULL, /* pack_rgba_uint */" 
            print "   NULL, /* unpack_rgba_sint */" 
            print "   NULL, /* pack_rgba_sint */"
            print "   NULL, /* fetch_rgba_uint */"
            print "   NULL  /* fetch_rgba_sint */"
        print "};"
        print
        
    print "const struct util_format_description *"
    print "util_format_description(enum pipe_format format)"
    print "{"
    print "   if (format >= PIPE_FORMAT_COUNT) {"
    print "      return NULL;"
    print "   }"
    print
    print "   switch (format) {"
    for format in formats:
        print "   case %s:" % format.name
        print "      return &util_format_%s_description;" % (format.short_name(),)
    print "   default:"
    print "      return NULL;"
    print "   }"
    print "}"
    print


def main():

    formats = []
    for arg in sys.argv[1:]:
        formats.extend(parse(arg))
    write_format_table(formats)


if __name__ == '__main__':
    main()
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a92 1
    print '#include "u_format_bptc.h"'
d144 1
a144 1
            if format.layout == 's3tc' or format.layout == 'rgtc' or format.layout == 'bptc':
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d93 1
d145 1
a145 1
            if format.layout == 's3tc' or format.layout == 'rgtc':
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d97 1
a97 12
    for format in formats:
        print 'const struct util_format_description'
        print 'util_format_%s_description = {' % (format.short_name(),)
        print "   %s," % (format.name,)
        print "   \"%s\"," % (format.name,)
        print "   \"%s\"," % (format.short_name(),)
        print "   {%u, %u, %u},\t/* block */" % (format.block_width, format.block_height, format.block_size())
        print "   %s," % (layout_map(format.layout),)
        print "   %u,\t/* nr_channels */" % (format.nr_channels(),)
        print "   %s,\t/* is_array */" % (bool_map(format.is_array()),)
        print "   %s,\t/* is_bitmask */" % (bool_map(format.is_bitmask()),)
        print "   %s,\t/* is_mixed */" % (bool_map(format.is_mixed()),)
d100 1
a100 1
            channel = format.channels[i]
d110 2
d114 1
a114 1
            swizzle = format.swizzles[i]
d125 15
d141 1
a141 1
        if format.colorspace != ZS and format.channels[0].pure == False:
d158 1
a158 1
        if format.colorspace == ZS and format.swizzles[0] != SWIZZLE_NONE:
d168 1
a168 1
        if format.colorspace == ZS and format.swizzles[1] != SWIZZLE_NONE:
d174 1
a174 1
        if format.colorspace != ZS and format.channels[0].pure == True and format.channels[0].type == UNSIGNED:
d181 1
a181 1
        elif format.colorspace != ZS and format.channels[0].pure == True and format.channels[0].type == SIGNED:
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d92 1
d117 1
a117 1
                print "      {%s, %s, %u}%s\t/* %s = %s */" % (type_map[channel.type], bool_map(channel.norm), channel.size, sep, "xyzw"[i], channel.name)
d119 1
a119 1
                print "      {0, 0, 0}%s" % (sep,)
d135 1
a135 1
        if format.colorspace != ZS:
d163 2
a164 2
            print "   &util_format_%s_unpack_s_8uscaled," % format.short_name() 
            print "   &util_format_%s_pack_s_8uscaled" % format.short_name() 
d166 23
a188 2
            print "   NULL, /* unpack_s_8uscaled */" 
            print "   NULL /* pack_s_8uscaled */" 
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d90 2
d137 1
a137 1
            if format.layout == 's3tc':
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d3 1
a3 1
'''
d6 1
a6 1
 * Copyright 2009 VMware, Inc.
d36 1
d86 1
a86 1
    print __doc__.strip()
d89 1
d91 3
a93 14
    print 'const struct util_format_description'
    print 'util_format_none_description = {'
    print "   PIPE_FORMAT_NONE,"
    print "   \"PIPE_FORMAT_NONE\","
    print "   {0, 0, 0},"
    print "   0,"
    print "   0,"
    print "   0,"
    print "   0,"
    print "   {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}},"
    print "   {0, 0, 0, 0},"
    print "   0"
    print "};"
    print
d99 1
d104 1
d132 33
d167 1
a175 2
    print "   case PIPE_FORMAT_NONE:"
    print "      return &util_format_none_description;"
a179 1
    print "      assert(0);"
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
CopyRight = '''
d6 1
a6 1
 * Copyright 2010 VMware, Inc.
a35 1
import u_format_pack
d85 1
a85 1
    print CopyRight.strip()
a87 1
    print '#include "u_format_s3tc.h"'
d89 14
a102 3
    
    u_format_pack.generate(formats)
    
a107 1
        print "   \"%s\"," % (format.short_name(),)
a111 1
        print "   %s,\t/* is_bitmask */" % (bool_map(format.is_bitmask()),)
a138 33
        if format.colorspace != ZS:
            print "   &util_format_%s_unpack_rgba_8unorm," % format.short_name() 
            print "   &util_format_%s_pack_rgba_8unorm," % format.short_name() 
            if format.layout == 's3tc':
                print "   &util_format_%s_fetch_rgba_8unorm," % format.short_name()
            else:
                print "   NULL, /* fetch_rgba_8unorm */" 
            print "   &util_format_%s_unpack_rgba_float," % format.short_name() 
            print "   &util_format_%s_pack_rgba_float," % format.short_name() 
            print "   &util_format_%s_fetch_rgba_float," % format.short_name()
        else:
            print "   NULL, /* unpack_rgba_8unorm */" 
            print "   NULL, /* pack_rgba_8unorm */" 
            print "   NULL, /* fetch_rgba_8unorm */" 
            print "   NULL, /* unpack_rgba_float */" 
            print "   NULL, /* pack_rgba_float */" 
            print "   NULL, /* fetch_rgba_float */" 
        if format.colorspace == ZS and format.swizzles[0] != SWIZZLE_NONE:
            print "   &util_format_%s_unpack_z_32unorm," % format.short_name() 
            print "   &util_format_%s_pack_z_32unorm," % format.short_name() 
            print "   &util_format_%s_unpack_z_float," % format.short_name() 
            print "   &util_format_%s_pack_z_float," % format.short_name() 
        else:
            print "   NULL, /* unpack_z_32unorm */" 
            print "   NULL, /* pack_z_32unorm */" 
            print "   NULL, /* unpack_z_float */" 
            print "   NULL, /* pack_z_float */" 
        if format.colorspace == ZS and format.swizzles[1] != SWIZZLE_NONE:
            print "   &util_format_%s_unpack_s_8uscaled," % format.short_name() 
            print "   &util_format_%s_pack_s_8uscaled" % format.short_name() 
        else:
            print "   NULL, /* unpack_s_8uscaled */" 
            print "   NULL /* pack_s_8uscaled */" 
a140 1
        
d149 2
d155 1
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a89 3
    print '#include "u_format_rgtc.h"'
    print '#include "u_format_latc.h"'
    print '#include "u_format_etc.h"'
d114 1
a114 1
                print "      {%s, %s, %s, %u, %u}%s\t/* %s = %s */" % (type_map[channel.type], bool_map(channel.norm), bool_map(channel.pure), channel.size, channel.shift, sep, "xyzw"[i], channel.name)
d116 1
a116 1
                print "      {0, 0, 0, 0, 0}%s" % (sep,)
d132 1
a132 1
        if format.colorspace != ZS and format.channels[0].pure == False:
d135 1
a135 1
            if format.layout == 's3tc' or format.layout == 'rgtc':
d160 2
a161 2
            print "   &util_format_%s_unpack_s_8uint," % format.short_name() 
            print "   &util_format_%s_pack_s_8uint," % format.short_name() 
d163 2
a164 23
            print "   NULL, /* unpack_s_8uint */" 
            print "   NULL, /* pack_s_8uint */"
        if format.colorspace != ZS and format.channels[0].pure == True and format.channels[0].type == UNSIGNED:
            print "   &util_format_%s_unpack_unsigned, /* unpack_rgba_uint */" % format.short_name() 
            print "   &util_format_%s_pack_unsigned, /* pack_rgba_uint */" % format.short_name()
            print "   &util_format_%s_unpack_signed, /* unpack_rgba_sint */" % format.short_name()
            print "   &util_format_%s_pack_signed,  /* pack_rgba_sint */" % format.short_name()
            print "   &util_format_%s_fetch_unsigned,  /* fetch_rgba_uint */" % format.short_name()
            print "   NULL  /* fetch_rgba_sint */"
        elif format.colorspace != ZS and format.channels[0].pure == True and format.channels[0].type == SIGNED:
            print "   &util_format_%s_unpack_unsigned, /* unpack_rgba_uint */" % format.short_name()
            print "   &util_format_%s_pack_unsigned, /* pack_rgba_uint */" % format.short_name()
            print "   &util_format_%s_unpack_signed, /* unpack_rgba_sint */" % format.short_name()
            print "   &util_format_%s_pack_signed,  /* pack_rgba_sint */" % format.short_name()
            print "   NULL,  /* fetch_rgba_uint */"
            print "   &util_format_%s_fetch_signed  /* fetch_rgba_sint */" % format.short_name()
        else:
            print "   NULL, /* unpack_rgba_uint */" 
            print "   NULL, /* pack_rgba_uint */" 
            print "   NULL, /* unpack_rgba_sint */" 
            print "   NULL, /* pack_rgba_sint */"
            print "   NULL, /* fetch_rgba_uint */"
            print "   NULL  /* fetch_rgba_sint */"
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d97 12
a108 1
    def do_channel_array(channels, swizzles):
d111 1
a111 1
            channel = channels[i]
a120 2

    def do_swizzle_array(channels, swizzles):
d123 1
a123 1
            swizzle = swizzles[i]
a133 15

    for format in formats:
        print 'const struct util_format_description'
        print 'util_format_%s_description = {' % (format.short_name(),)
        print "   %s," % (format.name,)
        print "   \"%s\"," % (format.name,)
        print "   \"%s\"," % (format.short_name(),)
        print "   {%u, %u, %u},\t/* block */" % (format.block_width, format.block_height, format.block_size())
        print "   %s," % (layout_map(format.layout),)
        print "   %u,\t/* nr_channels */" % (format.nr_channels(),)
        print "   %s,\t/* is_array */" % (bool_map(format.is_array()),)
        print "   %s,\t/* is_bitmask */" % (bool_map(format.is_bitmask()),)
        print "   %s,\t/* is_mixed */" % (bool_map(format.is_mixed()),)
        u_format_pack.print_channels(format, do_channel_array)
        u_format_pack.print_channels(format, do_swizzle_array)
d135 1
a135 1
        if format.colorspace != ZS and not format.is_pure_color():
d152 1
a152 1
        if format.has_depth():
d162 1
a162 1
        if format.has_stencil():
d168 1
a168 1
        if format.is_pure_unsigned():
d175 1
a175 1
        elif format.is_pure_signed():
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a92 1
    print '#include "u_format_bptc.h"'
d144 1
a144 1
            if format.layout == 's3tc' or format.layout == 'rgtc' or format.layout == 'bptc':
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d93 1
d145 1
a145 1
            if format.layout == 's3tc' or format.layout == 'rgtc':
@


