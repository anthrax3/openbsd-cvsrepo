head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.09.07.15.20.06;	author jsg;	state Exp;
branches;
next	1.3;
commitid	7kimTMT4YlQauAIU;

1.3
date	2013.09.05.13.59.53;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.09.07.15.01.25;	author jsg;	state Exp;
branches;
next	;
commitid	dm8VnQHhowGHmemJ;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@#include "pipe/p_context.h"
#include "util/u_surface.h"
#include "util/u_inlines.h"
#include "util/u_transfer.h"
#include "util/u_memory.h"

/* One-shot transfer operation with data supplied in a user
 * pointer.  XXX: strides??
 */
void u_default_transfer_inline_write( struct pipe_context *pipe,
                                      struct pipe_resource *resource,
                                      unsigned level,
                                      unsigned usage,
                                      const struct pipe_box *box,
                                      const void *data,
                                      unsigned stride,
                                      unsigned layer_stride)
{
   struct pipe_transfer *transfer = NULL;
   uint8_t *map = NULL;

   assert(!(usage & PIPE_TRANSFER_READ));

   /* the write flag is implicit by the nature of transfer_inline_write */
   usage |= PIPE_TRANSFER_WRITE;

   /* transfer_inline_write implicitly discards the rewritten buffer range */
   if (resource->target == PIPE_BUFFER &&
       box->x == 0 && box->width == resource->width0) {
      usage |= PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE;
   } else {
      usage |= PIPE_TRANSFER_DISCARD_RANGE;
   }

   map = pipe->transfer_map(pipe,
                            resource,
                            level,
                            usage,
                            box, &transfer);
   if (map == NULL)
      return;

   if (resource->target == PIPE_BUFFER) {
      assert(box->height == 1);
      assert(box->depth == 1);

      memcpy(map, data, box->width);
   }
   else {
      const uint8_t *src_data = data;

      util_copy_box(map,
		    resource->format,
		    transfer->stride, /* bytes */
		    transfer->layer_stride, /* bytes */
                    0, 0, 0,
		    box->width,
		    box->height,
		    box->depth,
		    src_data,
		    stride,       /* bytes */
		    layer_stride, /* bytes */
		    0, 0, 0);
   }

   pipe_transfer_unmap(pipe, transfer);
}


boolean u_default_resource_get_handle(struct pipe_screen *screen,
                                      struct pipe_resource *resource,
                                      struct winsys_handle *handle)
{
   return FALSE;
}



void u_default_transfer_flush_region( struct pipe_context *pipe,
                                      struct pipe_transfer *transfer,
                                      const struct pipe_box *box)
{
   /* This is a no-op implementation, nothing to do.
    */
}

void u_default_transfer_unmap( struct pipe_context *pipe,
                               struct pipe_transfer *transfer )
{
}


static INLINE struct u_resource *
u_resource( struct pipe_resource *res )
{
   return (struct u_resource *)res;
}

boolean u_resource_get_handle_vtbl(struct pipe_screen *screen,
                                   struct pipe_resource *resource,
                                   struct winsys_handle *handle)
{
   struct u_resource *ur = u_resource(resource);
   return ur->vtbl->resource_get_handle(screen, resource, handle);
}

void u_resource_destroy_vtbl(struct pipe_screen *screen,
                             struct pipe_resource *resource)
{
   struct u_resource *ur = u_resource(resource);
   ur->vtbl->resource_destroy(screen, resource);
}

void *u_transfer_map_vtbl(struct pipe_context *context,
                          struct pipe_resource *resource,
                          unsigned level,
                          unsigned usage,
                          const struct pipe_box *box,
                          struct pipe_transfer **transfer)
{
   struct u_resource *ur = u_resource(resource);
   return ur->vtbl->transfer_map(context, resource, level, usage, box,
                                 transfer);
}

void u_transfer_flush_region_vtbl( struct pipe_context *pipe,
                                   struct pipe_transfer *transfer,
                                   const struct pipe_box *box)
{
   struct u_resource *ur = u_resource(transfer->resource);
   ur->vtbl->transfer_flush_region(pipe, transfer, box);
}

void u_transfer_unmap_vtbl( struct pipe_context *pipe,
                            struct pipe_transfer *transfer )
{
   struct u_resource *ur = u_resource(transfer->resource);
   ur->vtbl->transfer_unmap(pipe, transfer);
}

void u_transfer_inline_write_vtbl( struct pipe_context *pipe,
                                   struct pipe_resource *resource,
                                   unsigned level,
                                   unsigned usage,
                                   const struct pipe_box *box,
                                   const void *data,
                                   unsigned stride,
                                   unsigned layer_stride)
{
   struct u_resource *ur = u_resource(resource);
   ur->vtbl->transfer_inline_write(pipe,
                                   resource,
                                   level,
                                   usage,
                                   box,
                                   data,
                                   stride,
                                   layer_stride);
}




@


1.4
log
@Merge Mesa 10.2.7
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d28 2
a29 2
   /* XXX this looks very broken for non-buffer resources having more than one dim. */
   if (box->x == 0 && box->width == resource->width0) {
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d2 1
a2 1
#include "util/u_rect.h"
a20 2
   const uint8_t *src_data = data;
   unsigned i;
d22 1
a22 7
   transfer = pipe->get_transfer(pipe,
                                 resource,
                                 level,
                                 usage,
                                 box );
   if (transfer == NULL)
      goto out;
d24 16
a39 1
   map = pipe_transfer_map(pipe, transfer);
d41 5
a45 1
      goto out;
d47 1
a47 12
   for (i = 0; i < box->depth; i++) {
      util_copy_rect(map,
                     resource->format,
                     transfer->stride, /* bytes */
                     0, 0,
                     box->width,
                     box->height,
                     src_data,
                     stride,       /* bytes */
                     0, 0);
      map += transfer->layer_stride;
      src_data += layer_stride;
d49 2
d52 13
a64 3
out:
   if (map)
      pipe_transfer_unmap(pipe, transfer);
d66 1
a66 2
   if (transfer)
      pipe_transfer_destroy(pipe, transfer);
d87 5
a91 14
struct pipe_transfer * u_default_get_transfer(struct pipe_context *context,
                                              struct pipe_resource *resource,
                                              unsigned level,
                                              unsigned usage,
                                              const struct pipe_box *box)
{
   struct pipe_transfer *transfer = CALLOC_STRUCT(pipe_transfer);
   if (transfer == NULL)
      return NULL;

   transfer->resource = resource;
   transfer->level = level;
   transfer->usage = usage;
   transfer->box = *box;
d93 31
a123 4
   /* Note strides are zero, this is ok for buffers, but not for
    * textures 2d & higher at least. 
    */
   return transfer;
d126 3
a128 2
void u_default_transfer_unmap( struct pipe_context *pipe,
                               struct pipe_transfer *transfer )
d130 2
d134 2
a135 2
void u_default_transfer_destroy(struct pipe_context *pipe,
                                struct pipe_transfer *transfer)
d137 2
a138 1
   FREE(transfer);
d141 8
a148 4
void u_default_redefine_user_buffer(struct pipe_context *ctx,
                                    struct pipe_resource *resource,
                                    unsigned offset,
                                    unsigned size)
d150 9
a158 1
   resource->width0 = MAX2(resource->width0, offset + size);
d160 4
@


1.1
log
@Initial revision
@
text
@a75 7
unsigned u_default_is_resource_referenced( struct pipe_context *pipe,
                                           struct pipe_resource *resource,
                                           unsigned level, int layer)
{
   return 0;
}

d108 7
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d2 1
a2 1
#include "util/u_surface.h"
d21 2
d24 7
a30 1
   assert(!(usage & PIPE_TRANSFER_READ));
d32 1
a32 16
   /* the write flag is implicit by the nature of transfer_inline_write */
   usage |= PIPE_TRANSFER_WRITE;

   /* transfer_inline_write implicitly discards the rewritten buffer range */
   /* XXX this looks very broken for non-buffer resources having more than one dim. */
   if (box->x == 0 && box->width == resource->width0) {
      usage |= PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE;
   } else {
      usage |= PIPE_TRANSFER_DISCARD_RANGE;
   }

   map = pipe->transfer_map(pipe,
                            resource,
                            level,
                            usage,
                            box, &transfer);
d34 1
a34 5
      return;

   if (resource->target == PIPE_BUFFER) {
      assert(box->height == 1);
      assert(box->depth == 1);
d36 12
a47 1
      memcpy(map, data, box->width);
a48 2
   else {
      const uint8_t *src_data = data;
d50 3
a52 13
      util_copy_box(map,
		    resource->format,
		    transfer->stride, /* bytes */
		    transfer->layer_stride, /* bytes */
                    0, 0, 0,
		    box->width,
		    box->height,
		    box->depth,
		    src_data,
		    stride,       /* bytes */
		    layer_stride, /* bytes */
		    0, 0, 0);
   }
d54 2
a55 1
   pipe_transfer_unmap(pipe, transfer);
d76 21
a96 4
void u_default_transfer_unmap( struct pipe_context *pipe,
                               struct pipe_transfer *transfer )
{
}
d98 4
a101 5

static INLINE struct u_resource *
u_resource( struct pipe_resource *res )
{
   return (struct u_resource *)res;
d104 2
a105 3
boolean u_resource_get_handle_vtbl(struct pipe_screen *screen,
                                   struct pipe_resource *resource,
                                   struct winsys_handle *handle)
a106 2
   struct u_resource *ur = u_resource(resource);
   return ur->vtbl->resource_get_handle(screen, resource, handle);
d109 2
a110 2
void u_resource_destroy_vtbl(struct pipe_screen *screen,
                             struct pipe_resource *resource)
d112 1
a112 2
   struct u_resource *ur = u_resource(resource);
   ur->vtbl->resource_destroy(screen, resource);
a113 50

void *u_transfer_map_vtbl(struct pipe_context *context,
                          struct pipe_resource *resource,
                          unsigned level,
                          unsigned usage,
                          const struct pipe_box *box,
                          struct pipe_transfer **transfer)
{
   struct u_resource *ur = u_resource(resource);
   return ur->vtbl->transfer_map(context, resource, level, usage, box,
                                 transfer);
}

void u_transfer_flush_region_vtbl( struct pipe_context *pipe,
                                   struct pipe_transfer *transfer,
                                   const struct pipe_box *box)
{
   struct u_resource *ur = u_resource(transfer->resource);
   ur->vtbl->transfer_flush_region(pipe, transfer, box);
}

void u_transfer_unmap_vtbl( struct pipe_context *pipe,
                            struct pipe_transfer *transfer )
{
   struct u_resource *ur = u_resource(transfer->resource);
   ur->vtbl->transfer_unmap(pipe, transfer);
}

void u_transfer_inline_write_vtbl( struct pipe_context *pipe,
                                   struct pipe_resource *resource,
                                   unsigned level,
                                   unsigned usage,
                                   const struct pipe_box *box,
                                   const void *data,
                                   unsigned stride,
                                   unsigned layer_stride)
{
   struct u_resource *ur = u_resource(resource);
   ur->vtbl->transfer_inline_write(pipe,
                                   resource,
                                   level,
                                   usage,
                                   box,
                                   data,
                                   stride,
                                   layer_stride);
}



@


1.1.1.3
log
@Import Mesa 10.2.7
@
text
@d28 2
a29 2
   if (resource->target == PIPE_BUFFER &&
       box->x == 0 && box->width == resource->width0) {
@


