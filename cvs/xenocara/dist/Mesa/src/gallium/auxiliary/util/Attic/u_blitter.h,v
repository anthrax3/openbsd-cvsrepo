head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.47;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.45;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.47;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#ifndef U_BLITTER_H
#define U_BLITTER_H

#include "util/u_framebuffer.h"
#include "util/u_inlines.h"

#include "pipe/p_state.h"

/* u_memory.h conflicts with st/mesa */
#ifndef Elements
#define Elements(x) (sizeof(x)/sizeof((x)[0]))
#endif


#ifdef __cplusplus
extern "C" {
#endif

struct pipe_context;

enum blitter_attrib_type {
   UTIL_BLITTER_ATTRIB_NONE,
   UTIL_BLITTER_ATTRIB_COLOR,
   UTIL_BLITTER_ATTRIB_TEXCOORD
};

struct blitter_context
{
   /**
    * Draw a rectangle.
    *
    * \param x1      An X coordinate of the top-left corner.
    * \param y1      A Y coordinate of the top-left corner.
    * \param x2      An X coordinate of the bottom-right corner.
    * \param y2      A Y coordinate of the bottom-right corner.
    * \param depth   A depth which the rectangle is rendered at.
    *
    * \param type   Semantics of the attributes "attrib".
    *               If type is UTIL_BLITTER_ATTRIB_NONE, ignore them.
    *               If type is UTIL_BLITTER_ATTRIB_COLOR, the attributes
    *               make up a constant RGBA color, and should go
    *               to the GENERIC0 varying slot of a fragment shader.
    *               If type is UTIL_BLITTER_ATTRIB_TEXCOORD, {a1, a2} and
    *               {a3, a4} specify top-left and bottom-right texture
    *               coordinates of the rectangle, respectively, and should go
    *               to the GENERIC0 varying slot of a fragment shader.
    *
    * \param attrib See type.
    *
    * \note A driver may optionally override this callback to implement
    *       a specialized hardware path for drawing a rectangle, e.g. using
    *       a rectangular point sprite.
    */
   void (*draw_rectangle)(struct blitter_context *blitter,
                          int x1, int y1, int x2, int y2,
                          float depth,
                          enum blitter_attrib_type type,
                          const union pipe_color_union *color);

   /**
    * Get the next surface layer for the pipe surface, i.e. make a copy
    * of the surface and increment the first and last layer by 1.
    *
    * This callback is exposed, so that drivers can override it if needed.
    */
   struct pipe_surface *(*get_next_surface_layer)(struct pipe_context *pipe,
                                                  struct pipe_surface *surf);

   /* Whether the blitter is running. */
   boolean running;

   /* Private members, really. */
   struct pipe_context *pipe; /**< pipe context */

   void *saved_blend_state;   /**< blend state */
   void *saved_dsa_state;     /**< depth stencil alpha state */
   void *saved_velem_state;   /**< vertex elements state */
   void *saved_rs_state;      /**< rasterizer state */
   void *saved_fs, *saved_vs, *saved_gs; /**< shaders */

   struct pipe_framebuffer_state saved_fb_state;  /**< framebuffer state */
   struct pipe_stencil_ref saved_stencil_ref;     /**< stencil ref */
   struct pipe_viewport_state saved_viewport;
   struct pipe_scissor_state saved_scissor;
   boolean is_sample_mask_saved;
   unsigned saved_sample_mask;

   unsigned saved_num_sampler_states;
   void *saved_sampler_states[PIPE_MAX_SAMPLERS];

   unsigned saved_num_sampler_views;
   struct pipe_sampler_view *saved_sampler_views[PIPE_MAX_SAMPLERS];

   unsigned vb_slot;
   struct pipe_vertex_buffer saved_vertex_buffer;

   unsigned saved_num_so_targets;
   struct pipe_stream_output_target *saved_so_targets[PIPE_MAX_SO_BUFFERS];

   struct pipe_query *saved_render_cond_query;
   uint saved_render_cond_mode;
   boolean saved_render_cond_cond;
};

/**
 * Create a blitter context.
 */
struct blitter_context *util_blitter_create(struct pipe_context *pipe);

/**
 * Destroy a blitter context.
 */
void util_blitter_destroy(struct blitter_context *blitter);

void util_blitter_cache_all_shaders(struct blitter_context *blitter);

/**
 * Return the pipe context associated with a blitter context.
 */
static INLINE
struct pipe_context *util_blitter_get_pipe(struct blitter_context *blitter)
{
   return blitter->pipe;
}

/**
 * Override PIPE_CAP_TEXTURE_MULTISAMPLE as reported by the driver.
 */
void util_blitter_set_texture_multisample(struct blitter_context *blitter,
                                          boolean supported);

/* The default function to draw a rectangle. This can only be used
 * inside of the draw_rectangle callback if the driver overrides it. */
void util_blitter_draw_rectangle(struct blitter_context *blitter,
                                 int x1, int y1, int x2, int y2, float depth,
                                 enum blitter_attrib_type type,
                                 const union pipe_color_union *attrib);


/*
 * These states must be saved before any of the following functions are called:
 * - vertex buffers
 * - vertex elements
 * - vertex shader
 * - geometry shader (if supported)
 * - stream output targets (if supported)
 * - rasterizer state
 */

/**
 * Clear a specified set of currently bound buffers to specified values.
 *
 * These states must be saved in the blitter in addition to the state objects
 * already required to be saved:
 * - fragment shader
 * - depth stencil alpha state
 * - blend state
 */
void util_blitter_clear(struct blitter_context *blitter,
                        unsigned width, unsigned height, unsigned num_layers,
                        unsigned clear_buffers,
                        const union pipe_color_union *color,
                        double depth, unsigned stencil);

/**
 * Check if the blitter (with the help of the driver) can blit between
 * the two resources.
 */
boolean util_blitter_is_copy_supported(struct blitter_context *blitter,
                                       const struct pipe_resource *dst,
                                       const struct pipe_resource *src);

boolean util_blitter_is_blit_supported(struct blitter_context *blitter,
				       const struct pipe_blit_info *info);

/**
 * Copy a block of pixels from one surface to another.
 *
 * These states must be saved in the blitter in addition to the state objects
 * already required to be saved:
 * - fragment shader
 * - depth stencil alpha state
 * - blend state
 * - fragment sampler states
 * - fragment sampler textures
 * - framebuffer state
 * - sample mask
 */
void util_blitter_copy_texture(struct blitter_context *blitter,
                               struct pipe_resource *dst,
                               unsigned dst_level,
                               unsigned dstx, unsigned dsty, unsigned dstz,
                               struct pipe_resource *src,
                               unsigned src_level,
                               const struct pipe_box *srcbox);

/**
 * This is a generic implementation of pipe->blit, which accepts
 * sampler/surface views instead of resources.
 *
 * The layer and mipmap level are specified by the views.
 *
 * Drivers can use this to change resource properties (like format, width,
 * height) by changing how the views interpret them, instead of changing
 * pipe_resource directly. This is used to blit resources of formats which
 * are not renderable.
 *
 * src_width0 and src_height0 are sampler_view-private properties that
 * override pipe_resource. The blitter uses them for computation of texture
 * coordinates. The dst dimensions are supplied through pipe_surface::width
 * and height.
 *
 * The mask is a combination of the PIPE_MASK_* flags.
 * Set to PIPE_MASK_RGBAZS if unsure.
 */
void util_blitter_blit_generic(struct blitter_context *blitter,
                               struct pipe_surface *dst,
                               const struct pipe_box *dstbox,
                               struct pipe_sampler_view *src,
                               const struct pipe_box *srcbox,
                               unsigned src_width0, unsigned src_height0,
                               unsigned mask, unsigned filter,
                               const struct pipe_scissor_state *scissor);

void util_blitter_blit(struct blitter_context *blitter,
		       const struct pipe_blit_info *info);

/**
 * Helper function to initialize a view for copy_texture_view.
 * The parameters must match copy_texture_view.
 */
void util_blitter_default_dst_texture(struct pipe_surface *dst_templ,
                                      struct pipe_resource *dst,
                                      unsigned dstlevel,
                                      unsigned dstz);

/**
 * Helper function to initialize a view for copy_texture_view.
 * The parameters must match copy_texture_view.
 */
void util_blitter_default_src_texture(struct pipe_sampler_view *src_templ,
                                      struct pipe_resource *src,
                                      unsigned srclevel);

/**
 * Copy data from one buffer to another using the Stream Output functionality.
 * 4-byte alignment is required, otherwise software fallback is used.
 */
void util_blitter_copy_buffer(struct blitter_context *blitter,
                              struct pipe_resource *dst,
                              unsigned dstx,
                              struct pipe_resource *src,
                              unsigned srcx,
                              unsigned size);

/**
 * Clear the contents of a buffer using the Stream Output functionality.
 * 4-byte alignment is required.
 *
 * "num_channels" can be 1, 2, 3, or 4, and specifies if the clear value is
 * R, RG, RGB, or RGBA.
 *
 * For each element, only "num_channels" components of "clear_value" are
 * copied to the buffer, then the offset is incremented by num_channels*4.
 */
void util_blitter_clear_buffer(struct blitter_context *blitter,
                               struct pipe_resource *dst,
                               unsigned offset, unsigned size,
                               unsigned num_channels,
                               const union pipe_color_union *clear_value);

/**
 * Clear a region of a (color) surface to a constant value.
 *
 * These states must be saved in the blitter in addition to the state objects
 * already required to be saved:
 * - fragment shader
 * - depth stencil alpha state
 * - blend state
 * - framebuffer state
 */
void util_blitter_clear_render_target(struct blitter_context *blitter,
                                      struct pipe_surface *dst,
                                      const union pipe_color_union *color,
                                      unsigned dstx, unsigned dsty,
                                      unsigned width, unsigned height);

/**
 * Clear a region of a depth-stencil surface, both stencil and depth
 * or only one of them if this is a combined depth-stencil surface.
 *
 * These states must be saved in the blitter in addition to the state objects
 * already required to be saved:
 * - fragment shader
 * - depth stencil alpha state
 * - blend state
 * - framebuffer state
 */
void util_blitter_clear_depth_stencil(struct blitter_context *blitter,
                                      struct pipe_surface *dst,
                                      unsigned clear_flags,
                                      double depth,
                                      unsigned stencil,
                                      unsigned dstx, unsigned dsty,
                                      unsigned width, unsigned height);

/* The following functions are customized variants of the clear functions.
 * Some drivers use them internally to do things like MSAA resolve
 * and resource decompression. It usually consists of rendering a full-screen
 * quad with a special blend or DSA state.
 */

/* Used by r300g for depth decompression. */
void util_blitter_custom_clear_depth(struct blitter_context *blitter,
                                     unsigned width, unsigned height,
                                     double depth, void *custom_dsa);

/* Used by r600g for depth decompression. */
void util_blitter_custom_depth_stencil(struct blitter_context *blitter,
				       struct pipe_surface *zsurf,
				       struct pipe_surface *cbsurf,
				       unsigned sample_mask,
				       void *dsa_stage, float depth);

/* Used by r600g for color decompression. */
void util_blitter_custom_color(struct blitter_context *blitter,
                               struct pipe_surface *dstsurf,
                               void *custom_blend);

/* Used by r600g for MSAA color resolve. */
void util_blitter_custom_resolve_color(struct blitter_context *blitter,
                                       struct pipe_resource *dst,
                                       unsigned dst_level,
                                       unsigned dst_layer,
                                       struct pipe_resource *src,
                                       unsigned src_layer,
				       unsigned sampled_mask,
                                       void *custom_blend,
                                       enum pipe_format format);

/* The functions below should be used to save currently bound constant state
 * objects inside a driver. The objects are automatically restored at the end
 * of the util_blitter_{clear, copy_region, fill_region} functions and then
 * forgotten.
 *
 * States not listed here are not affected by util_blitter. */

static INLINE
void util_blitter_save_blend(struct blitter_context *blitter,
                             void *state)
{
   blitter->saved_blend_state = state;
}

static INLINE
void util_blitter_save_depth_stencil_alpha(struct blitter_context *blitter,
                                           void *state)
{
   blitter->saved_dsa_state = state;
}

static INLINE
void util_blitter_save_vertex_elements(struct blitter_context *blitter,
                                       void *state)
{
   blitter->saved_velem_state = state;
}

static INLINE
void util_blitter_save_stencil_ref(struct blitter_context *blitter,
                                   const struct pipe_stencil_ref *state)
{
   blitter->saved_stencil_ref = *state;
}

static INLINE
void util_blitter_save_rasterizer(struct blitter_context *blitter,
                                  void *state)
{
   blitter->saved_rs_state = state;
}

static INLINE
void util_blitter_save_fragment_shader(struct blitter_context *blitter,
                                       void *fs)
{
   blitter->saved_fs = fs;
}

static INLINE
void util_blitter_save_vertex_shader(struct blitter_context *blitter,
                                     void *vs)
{
   blitter->saved_vs = vs;
}

static INLINE
void util_blitter_save_geometry_shader(struct blitter_context *blitter,
                                       void *gs)
{
   blitter->saved_gs = gs;
}

static INLINE
void util_blitter_save_framebuffer(struct blitter_context *blitter,
                                   const struct pipe_framebuffer_state *state)
{
   blitter->saved_fb_state.nr_cbufs = 0; /* It's ~0 now, meaning it's unsaved. */
   util_copy_framebuffer_state(&blitter->saved_fb_state, state);
}

static INLINE
void util_blitter_save_viewport(struct blitter_context *blitter,
                                struct pipe_viewport_state *state)
{
   blitter->saved_viewport = *state;
}

static INLINE
void util_blitter_save_scissor(struct blitter_context *blitter,
                               struct pipe_scissor_state *state)
{
   blitter->saved_scissor = *state;
}

static INLINE
void util_blitter_save_fragment_sampler_states(
                  struct blitter_context *blitter,
                  unsigned num_sampler_states,
                  void **sampler_states)
{
   assert(num_sampler_states <= Elements(blitter->saved_sampler_states));

   blitter->saved_num_sampler_states = num_sampler_states;
   memcpy(blitter->saved_sampler_states, sampler_states,
          num_sampler_states * sizeof(void *));
}

static INLINE void
util_blitter_save_fragment_sampler_views(struct blitter_context *blitter,
                                         unsigned num_views,
                                         struct pipe_sampler_view **views)
{
   unsigned i;
   assert(num_views <= Elements(blitter->saved_sampler_views));

   blitter->saved_num_sampler_views = num_views;
   for (i = 0; i < num_views; i++)
      pipe_sampler_view_reference(&blitter->saved_sampler_views[i],
                                  views[i]);
}

static INLINE void
util_blitter_save_vertex_buffer_slot(struct blitter_context *blitter,
                                     struct pipe_vertex_buffer *vertex_buffers)
{
   pipe_resource_reference(&blitter->saved_vertex_buffer.buffer,
                           vertex_buffers[blitter->vb_slot].buffer);
   memcpy(&blitter->saved_vertex_buffer, &vertex_buffers[blitter->vb_slot],
          sizeof(struct pipe_vertex_buffer));
}

static INLINE void
util_blitter_save_so_targets(struct blitter_context *blitter,
                             unsigned num_targets,
                             struct pipe_stream_output_target **targets)
{
   unsigned i;
   assert(num_targets <= Elements(blitter->saved_so_targets));

   blitter->saved_num_so_targets = num_targets;
   for (i = 0; i < num_targets; i++)
      pipe_so_target_reference(&blitter->saved_so_targets[i],
                               targets[i]);
}

static INLINE void
util_blitter_save_sample_mask(struct blitter_context *blitter,
                              unsigned sample_mask)
{
   blitter->is_sample_mask_saved = TRUE;
   blitter->saved_sample_mask = sample_mask;
}

static INLINE void
util_blitter_save_render_condition(struct blitter_context *blitter,
                                   struct pipe_query *query,
                                   boolean condition,
                                   uint mode)
{
   blitter->saved_render_cond_query = query;
   blitter->saved_render_cond_mode = mode;
   blitter->saved_render_cond_cond = condition;
}

#ifdef __cplusplus
}
#endif

#endif
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d20 1
a20 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d186 1
a186 1
                        unsigned width, unsigned height,
a193 2
 * The mask is a combination of the PIPE_MASK_* flags.
 * Set to PIPE_MASK_RGBAZS if unsure.
d197 1
a197 2
                                       const struct pipe_resource *src,
                                       unsigned mask);
d221 1
a221 2
                               const struct pipe_box *srcbox, unsigned mask,
                               boolean copy_all_samples);
d249 1
a249 2
                               const struct pipe_scissor_state *scissor,
                               boolean copy_all_samples);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a31 1
#include "util/u_memory.h"
d35 5
d81 1
a81 1
                          unsigned x1, unsigned y1, unsigned x2, unsigned y2,
d84 10
a93 1
                          const float attrib[4]);
d105 1
a105 1
   void *saved_fs, *saved_vs; /**< fragment shader, vertex shader */
d110 3
a112 1
   struct pipe_clip_state saved_clip;
d114 1
a114 1
   int saved_num_sampler_states;
d117 1
a117 1
   int saved_num_sampler_views;
d120 9
a128 2
   int saved_num_vertex_buffers;
   struct pipe_vertex_buffer saved_vertex_buffers[PIPE_MAX_ATTRIBS];
d141 2
d152 14
d167 6
a172 3
 * These CSOs must be saved before any of the following functions is called:
 * - blend state
 * - depth stencil alpha state
a173 2
 * - vertex shader
 * - fragment shader
d178 6
a186 1
                        unsigned num_cbufs,
d188 1
a188 1
                        const float *rgba,
d191 13
a203 3
void util_blitter_clear_depth_custom(struct blitter_context *blitter,
                                     unsigned width, unsigned height,
                                     double depth, void *custom_dsa);
a207 12
 * You can copy from any color format to any other color format provided
 * the former can be sampled and the latter can be rendered to. Otherwise,
 * a software fallback path is taken and both surfaces must be of the same
 * format.
 *
 * The same holds for depth-stencil formats with the exception that stencil
 * cannot be copied unless you set ignore_stencil to FALSE. In that case,
 * a software fallback path is taken and both surfaces must be of the same
 * format.
 *
 * Use pipe_screen->is_format_supported to know your options.
 *
d210 3
a212 1
 * - framebuffer state
d215 2
d218 63
a280 1
void util_blitter_copy_region(struct blitter_context *blitter,
d282 1
a282 2
                              unsigned dstlevel,
                              unsigned dstx, unsigned dsty, unsigned dstz,
d284 18
a301 3
                              unsigned srclevel,
                              const struct pipe_box *srcbox,
                              boolean ignore_stencil);
d308 3
d315 1
a315 1
                                      const float *rgba,
d325 3
d338 12
d353 1
d356 16
d377 1
a377 1
 * CSOs not listed here are not affected by util_blitter. */
d429 7
d451 2
a452 2
void util_blitter_save_clip(struct blitter_context *blitter,
                            struct pipe_clip_state *state)
d454 1
a454 1
   blitter->saved_clip = *state;
d460 1
a460 1
                  int num_sampler_states,
d472 1
a472 1
                                         int num_views,
d485 40
a524 11
util_blitter_save_vertex_buffers(struct blitter_context *blitter,
                                         int num_vertex_buffers,
                                         struct pipe_vertex_buffer *vertex_buffers)
{
   assert(num_vertex_buffers <= Elements(blitter->saved_vertex_buffers));

   blitter->saved_num_vertex_buffers = 0;
   util_copy_vertex_buffers(blitter->saved_vertex_buffers,
                            (unsigned*)&blitter->saved_num_vertex_buffers,
                            vertex_buffers,
                            num_vertex_buffers);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d58 1
a58 1
    * \param depth  A depth which the rectangle is rendered at.
d63 2
a64 2
    *               make up a constant RGBA color, and should go to the COLOR0
    *               varying slot of a fragment shader.
d82 3
d147 4
a209 3
void util_blitter_flush_depth_stencil(struct blitter_context *blitter,
                                      struct pipe_surface *dstsurf);

a324 1
   unsigned i;
d327 5
a331 12
   blitter->saved_num_vertex_buffers = num_vertex_buffers;

   for (i = 0; i < num_vertex_buffers; i++) {
      if (vertex_buffers[i].buffer) {
         pipe_resource_reference(&blitter->saved_vertex_buffers[i].buffer,
                                 vertex_buffers[i].buffer);
      }
   }

   memcpy(blitter->saved_vertex_buffers,
          vertex_buffers,
          num_vertex_buffers * sizeof(struct pipe_vertex_buffer));
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d30 2
d43 6
d51 31
d83 2
d87 1
d97 1
a97 1
   void *saved_sampler_states[32];
d99 5
a103 2
   int saved_num_textures;
   struct pipe_texture *saved_textures[32]; /* is 32 enough? */
d116 9
d165 8
a172 7
void util_blitter_copy(struct blitter_context *blitter,
                       struct pipe_surface *dst,
                       unsigned dstx, unsigned dsty,
                       struct pipe_surface *src,
                       unsigned srcx, unsigned srcy,
                       unsigned width, unsigned height,
                       boolean ignore_stencil);
d175 1
a175 4
 * Fill a region of a surface with a constant value.
 *
 * If the surface cannot be rendered to or it's a depth-stencil format,
 * a software fallback path is taken.
d181 5
a185 5
void util_blitter_fill(struct blitter_context *blitter,
                       struct pipe_surface *dst,
                       unsigned dstx, unsigned dsty,
                       unsigned width, unsigned height,
                       unsigned value);
d188 2
a189 1
 * Copy all pixels from one surface to another.
d191 3
a193 2
 * The rules are the same as in util_blitter_copy with the addition that
 * surfaces must have the same size.
d195 15
a209 12
static INLINE
void util_blitter_copy_surface(struct blitter_context *blitter,
                               struct pipe_surface *dst,
                               struct pipe_surface *src,
                               boolean ignore_stencil)
{
   assert(dst->width == src->width && dst->height == src->height);

   util_blitter_copy(blitter, dst, 0, 0, src, 0, 0, src->width, src->height,
                     ignore_stencil);
}

d213 1
a213 1
 * of the util_blitter_{clear, fill, copy, copy_surface} functions and then
d233 7
d269 1
a269 1
                                   struct pipe_framebuffer_state *state)
d271 2
a272 1
   blitter->saved_fb_state = *state;
d302 34
a335 11
static INLINE
void util_blitter_save_fragment_sampler_textures(
                  struct blitter_context *blitter,
                  int num_textures,
                  struct pipe_texture **textures)
{
   assert(num_textures <= Elements(blitter->saved_textures));

   blitter->saved_num_textures = num_textures;
   memcpy(blitter->saved_textures, textures,
          num_textures * sizeof(struct pipe_texture *));
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a29 2
#include "util/u_framebuffer.h"
#include "util/u_inlines.h"
a40 6
enum blitter_attrib_type {
   UTIL_BLITTER_ATTRIB_NONE,
   UTIL_BLITTER_ATTRIB_COLOR,
   UTIL_BLITTER_ATTRIB_TEXCOORD
};

a42 31
   /**
    * Draw a rectangle.
    *
    * \param x1      An X coordinate of the top-left corner.
    * \param y1      A Y coordinate of the top-left corner.
    * \param x2      An X coordinate of the bottom-right corner.
    * \param y2      A Y coordinate of the bottom-right corner.
    * \param depth  A depth which the rectangle is rendered at.
    *
    * \param type   Semantics of the attributes "attrib".
    *               If type is UTIL_BLITTER_ATTRIB_NONE, ignore them.
    *               If type is UTIL_BLITTER_ATTRIB_COLOR, the attributes
    *               make up a constant RGBA color, and should go to the COLOR0
    *               varying slot of a fragment shader.
    *               If type is UTIL_BLITTER_ATTRIB_TEXCOORD, {a1, a2} and
    *               {a3, a4} specify top-left and bottom-right texture
    *               coordinates of the rectangle, respectively, and should go
    *               to the GENERIC0 varying slot of a fragment shader.
    *
    * \param attrib See type.
    *
    * \note A driver may optionally override this callback to implement
    *       a specialized hardware path for drawing a rectangle, e.g. using
    *       a rectangular point sprite.
    */
   void (*draw_rectangle)(struct blitter_context *blitter,
                          unsigned x1, unsigned y1, unsigned x2, unsigned y2,
                          float depth,
                          enum blitter_attrib_type type,
                          const float attrib[4]);

a43 2
   struct pipe_context *pipe; /**< pipe context */

a45 1
   void *saved_velem_state;   /**< vertex elements state */
d55 1
a55 1
   void *saved_sampler_states[PIPE_MAX_SAMPLERS];
d57 2
a58 5
   int saved_num_sampler_views;
   struct pipe_sampler_view *saved_sampler_views[PIPE_MAX_SAMPLERS];

   int saved_num_vertex_buffers;
   struct pipe_vertex_buffer saved_vertex_buffers[PIPE_MAX_ATTRIBS];
a70 9
/**
 * Return the pipe context associated with a blitter context.
 */
static INLINE
struct pipe_context *util_blitter_get_pipe(struct blitter_context *blitter)
{
   return blitter->pipe;
}

d111 7
a117 8
void util_blitter_copy_region(struct blitter_context *blitter,
                              struct pipe_resource *dst,
                              unsigned dstlevel,
                              unsigned dstx, unsigned dsty, unsigned dstz,
                              struct pipe_resource *src,
                              unsigned srclevel,
                              const struct pipe_box *srcbox,
                              boolean ignore_stencil);
d120 4
a123 1
 * Clear a region of a (color) surface to a constant value.
d129 5
a133 5
void util_blitter_clear_render_target(struct blitter_context *blitter,
                                      struct pipe_surface *dst,
                                      const float *rgba,
                                      unsigned dstx, unsigned dsty,
                                      unsigned width, unsigned height);
d136 1
a136 2
 * Clear a region of a depth-stencil surface, both stencil and depth
 * or only one of them if this is a combined depth-stencil surface.
d138 2
a139 3
 * These states must be saved in the blitter in addition to the state objects
 * already required to be saved:
 * - framebuffer state
d141 12
a152 15
void util_blitter_clear_depth_stencil(struct blitter_context *blitter,
                                      struct pipe_surface *dst,
                                      unsigned clear_flags,
                                      double depth,
                                      unsigned stencil,
                                      unsigned dstx, unsigned dsty,
                                      unsigned width, unsigned height);

void util_blitter_flush_depth_stencil(struct blitter_context *blitter,
                                      struct pipe_surface *dstsurf);

void util_blitter_custom_depth_stencil(struct blitter_context *blitter,
				       struct pipe_surface *zsurf,
				       struct pipe_surface *cbsurf,
				       void *dsa_stage, float depth);
d156 1
a156 1
 * of the util_blitter_{clear, copy_region, fill_region} functions and then
a175 7
void util_blitter_save_vertex_elements(struct blitter_context *blitter,
                                       void *state)
{
   blitter->saved_velem_state = state;
}

static INLINE
d205 1
a205 1
                                   const struct pipe_framebuffer_state *state)
d207 1
a207 2
   blitter->saved_fb_state.nr_cbufs = 0; /* It's ~0 now, meaning it's unsaved. */
   util_copy_framebuffer_state(&blitter->saved_fb_state, state);
d237 11
a247 34
static INLINE void
util_blitter_save_fragment_sampler_views(struct blitter_context *blitter,
                                         int num_views,
                                         struct pipe_sampler_view **views)
{
   unsigned i;
   assert(num_views <= Elements(blitter->saved_sampler_views));

   blitter->saved_num_sampler_views = num_views;
   for (i = 0; i < num_views; i++)
      pipe_sampler_view_reference(&blitter->saved_sampler_views[i],
                                  views[i]);
}

static INLINE void
util_blitter_save_vertex_buffers(struct blitter_context *blitter,
                                         int num_vertex_buffers,
                                         struct pipe_vertex_buffer *vertex_buffers)
{
   unsigned i;
   assert(num_vertex_buffers <= Elements(blitter->saved_vertex_buffers));

   blitter->saved_num_vertex_buffers = num_vertex_buffers;

   for (i = 0; i < num_vertex_buffers; i++) {
      if (vertex_buffers[i].buffer) {
         pipe_resource_reference(&blitter->saved_vertex_buffers[i].buffer,
                                 vertex_buffers[i].buffer);
      }
   }

   memcpy(blitter->saved_vertex_buffers,
          vertex_buffers,
          num_vertex_buffers * sizeof(struct pipe_vertex_buffer));
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d32 1
a35 5
/* u_memory.h conflicts with st/mesa */
#ifndef Elements
#define Elements(x) (sizeof(x)/sizeof((x)[0]))
#endif

d58 1
a58 1
    * \param depth   A depth which the rectangle is rendered at.
d63 2
a64 2
    *               make up a constant RGBA color, and should go
    *               to the GENERIC0 varying slot of a fragment shader.
d77 1
a77 1
                          int x1, int y1, int x2, int y2,
d80 1
a80 13
                          const union pipe_color_union *color);

   /**
    * Get the next surface layer for the pipe surface, i.e. make a copy
    * of the surface and increment the first and last layer by 1.
    *
    * This callback is exposed, so that drivers can override it if needed.
    */
   struct pipe_surface *(*get_next_surface_layer)(struct pipe_context *pipe,
                                                  struct pipe_surface *surf);

   /* Whether the blitter is running. */
   boolean running;
d89 1
a89 1
   void *saved_fs, *saved_vs, *saved_gs; /**< shaders */
d94 1
a94 3
   struct pipe_scissor_state saved_scissor;
   boolean is_sample_mask_saved;
   unsigned saved_sample_mask;
d96 1
a96 1
   unsigned saved_num_sampler_states;
d99 1
a99 1
   unsigned saved_num_sampler_views;
d102 2
a103 9
   unsigned vb_slot;
   struct pipe_vertex_buffer saved_vertex_buffer;

   unsigned saved_num_so_targets;
   struct pipe_stream_output_target *saved_so_targets[PIPE_MAX_SO_BUFFERS];

   struct pipe_query *saved_render_cond_query;
   uint saved_render_cond_mode;
   boolean saved_render_cond_cond;
a115 2
void util_blitter_cache_all_shaders(struct blitter_context *blitter);

a124 14
/**
 * Override PIPE_CAP_TEXTURE_MULTISAMPLE as reported by the driver.
 */
void util_blitter_set_texture_multisample(struct blitter_context *blitter,
                                          boolean supported);

/* The default function to draw a rectangle. This can only be used
 * inside of the draw_rectangle callback if the driver overrides it. */
void util_blitter_draw_rectangle(struct blitter_context *blitter,
                                 int x1, int y1, int x2, int y2, float depth,
                                 enum blitter_attrib_type type,
                                 const union pipe_color_union *attrib);


d126 4
a129 3
 * These states must be saved before any of the following functions are called:
 * - vertex buffers
 * - vertex elements
d131 1
a131 3
 * - geometry shader (if supported)
 * - stream output targets (if supported)
 * - rasterizer state
a135 6
 *
 * These states must be saved in the blitter in addition to the state objects
 * already required to be saved:
 * - fragment shader
 * - depth stencil alpha state
 * - blend state
d139 1
d141 1
a141 1
                        const union pipe_color_union *color,
a144 14
 * Check if the blitter (with the help of the driver) can blit between
 * the two resources.
 * The mask is a combination of the PIPE_MASK_* flags.
 * Set to PIPE_MASK_RGBAZS if unsure.
 */
boolean util_blitter_is_copy_supported(struct blitter_context *blitter,
                                       const struct pipe_resource *dst,
                                       const struct pipe_resource *src,
                                       unsigned mask);

boolean util_blitter_is_blit_supported(struct blitter_context *blitter,
				       const struct pipe_blit_info *info);

/**
d147 12
d161 1
a161 3
 * - fragment shader
 * - depth stencil alpha state
 * - blend state
a163 2
 * - framebuffer state
 * - sample mask
d165 1
a165 63
void util_blitter_copy_texture(struct blitter_context *blitter,
                               struct pipe_resource *dst,
                               unsigned dst_level,
                               unsigned dstx, unsigned dsty, unsigned dstz,
                               struct pipe_resource *src,
                               unsigned src_level,
                               const struct pipe_box *srcbox, unsigned mask,
                               boolean copy_all_samples);

/**
 * This is a generic implementation of pipe->blit, which accepts
 * sampler/surface views instead of resources.
 *
 * The layer and mipmap level are specified by the views.
 *
 * Drivers can use this to change resource properties (like format, width,
 * height) by changing how the views interpret them, instead of changing
 * pipe_resource directly. This is used to blit resources of formats which
 * are not renderable.
 *
 * src_width0 and src_height0 are sampler_view-private properties that
 * override pipe_resource. The blitter uses them for computation of texture
 * coordinates. The dst dimensions are supplied through pipe_surface::width
 * and height.
 *
 * The mask is a combination of the PIPE_MASK_* flags.
 * Set to PIPE_MASK_RGBAZS if unsure.
 */
void util_blitter_blit_generic(struct blitter_context *blitter,
                               struct pipe_surface *dst,
                               const struct pipe_box *dstbox,
                               struct pipe_sampler_view *src,
                               const struct pipe_box *srcbox,
                               unsigned src_width0, unsigned src_height0,
                               unsigned mask, unsigned filter,
                               const struct pipe_scissor_state *scissor,
                               boolean copy_all_samples);

void util_blitter_blit(struct blitter_context *blitter,
		       const struct pipe_blit_info *info);

/**
 * Helper function to initialize a view for copy_texture_view.
 * The parameters must match copy_texture_view.
 */
void util_blitter_default_dst_texture(struct pipe_surface *dst_templ,
                                      struct pipe_resource *dst,
                                      unsigned dstlevel,
                                      unsigned dstz);

/**
 * Helper function to initialize a view for copy_texture_view.
 * The parameters must match copy_texture_view.
 */
void util_blitter_default_src_texture(struct pipe_sampler_view *src_templ,
                                      struct pipe_resource *src,
                                      unsigned srclevel);

/**
 * Copy data from one buffer to another using the Stream Output functionality.
 * 4-byte alignment is required, otherwise software fallback is used.
 */
void util_blitter_copy_buffer(struct blitter_context *blitter,
d167 2
a168 1
                              unsigned dstx,
d170 3
a172 18
                              unsigned srcx,
                              unsigned size);

/**
 * Clear the contents of a buffer using the Stream Output functionality.
 * 4-byte alignment is required.
 *
 * "num_channels" can be 1, 2, 3, or 4, and specifies if the clear value is
 * R, RG, RGB, or RGBA.
 *
 * For each element, only "num_channels" components of "clear_value" are
 * copied to the buffer, then the offset is incremented by num_channels*4.
 */
void util_blitter_clear_buffer(struct blitter_context *blitter,
                               struct pipe_resource *dst,
                               unsigned offset, unsigned size,
                               unsigned num_channels,
                               const union pipe_color_union *clear_value);
a178 3
 * - fragment shader
 * - depth stencil alpha state
 * - blend state
d183 1
a183 1
                                      const union pipe_color_union *color,
a192 3
 * - fragment shader
 * - depth stencil alpha state
 * - blend state
d203 2
a204 10
/* The following functions are customized variants of the clear functions.
 * Some drivers use them internally to do things like MSAA resolve
 * and resource decompression. It usually consists of rendering a full-screen
 * quad with a special blend or DSA state.
 */

/* Used by r300g for depth decompression. */
void util_blitter_custom_clear_depth(struct blitter_context *blitter,
                                     unsigned width, unsigned height,
                                     double depth, void *custom_dsa);
a205 1
/* Used by r600g for depth decompression. */
a208 1
				       unsigned sample_mask,
a210 16
/* Used by r600g for color decompression. */
void util_blitter_custom_color(struct blitter_context *blitter,
                               struct pipe_surface *dstsurf,
                               void *custom_blend);

/* Used by r600g for MSAA color resolve. */
void util_blitter_custom_resolve_color(struct blitter_context *blitter,
                                       struct pipe_resource *dst,
                                       unsigned dst_level,
                                       unsigned dst_layer,
                                       struct pipe_resource *src,
                                       unsigned src_layer,
				       unsigned sampled_mask,
                                       void *custom_blend,
                                       enum pipe_format format);

d216 1
a216 1
 * States not listed here are not affected by util_blitter. */
a267 7
void util_blitter_save_geometry_shader(struct blitter_context *blitter,
                                       void *gs)
{
   blitter->saved_gs = gs;
}

static INLINE
d283 2
a284 2
void util_blitter_save_scissor(struct blitter_context *blitter,
                               struct pipe_scissor_state *state)
d286 1
a286 1
   blitter->saved_scissor = *state;
d292 1
a292 1
                  unsigned num_sampler_states,
d304 1
a304 1
                                         unsigned num_views,
d317 3
a319 13
util_blitter_save_vertex_buffer_slot(struct blitter_context *blitter,
                                     struct pipe_vertex_buffer *vertex_buffers)
{
   pipe_resource_reference(&blitter->saved_vertex_buffer.buffer,
                           vertex_buffers[blitter->vb_slot].buffer);
   memcpy(&blitter->saved_vertex_buffer, &vertex_buffers[blitter->vb_slot],
          sizeof(struct pipe_vertex_buffer));
}

static INLINE void
util_blitter_save_so_targets(struct blitter_context *blitter,
                             unsigned num_targets,
                             struct pipe_stream_output_target **targets)
d322 1
a322 7
   assert(num_targets <= Elements(blitter->saved_so_targets));

   blitter->saved_num_so_targets = num_targets;
   for (i = 0; i < num_targets; i++)
      pipe_so_target_reference(&blitter->saved_so_targets[i],
                               targets[i]);
}
d324 1
a324 7
static INLINE void
util_blitter_save_sample_mask(struct blitter_context *blitter,
                              unsigned sample_mask)
{
   blitter->is_sample_mask_saved = TRUE;
   blitter->saved_sample_mask = sample_mask;
}
d326 10
a335 9
static INLINE void
util_blitter_save_render_condition(struct blitter_context *blitter,
                                   struct pipe_query *query,
                                   boolean condition,
                                   uint mode)
{
   blitter->saved_render_cond_query = query;
   blitter->saved_render_cond_mode = mode;
   blitter->saved_render_cond_cond = condition;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d20 1
a20 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d186 1
a186 1
                        unsigned width, unsigned height, unsigned num_layers,
d194 2
d199 2
a200 1
                                       const struct pipe_resource *src);
d224 2
a225 1
                               const struct pipe_box *srcbox);
d253 2
a254 1
                               const struct pipe_scissor_state *scissor);
@


