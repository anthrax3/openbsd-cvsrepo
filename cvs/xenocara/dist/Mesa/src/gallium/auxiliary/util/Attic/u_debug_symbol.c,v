head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.13.59.48;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.46;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * @@file
 * Symbol lookup.
 * 
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 */

#include "pipe/p_compiler.h"
#include "os/os_thread.h"
#include "u_string.h"

#include "u_debug.h"
#include "u_debug_symbol.h"
#include "u_hash_table.h"


#if defined(PIPE_OS_WINDOWS)
   
#include <windows.h>
#include <stddef.h>

#include "dbghelp.h"


/**
 * SymInitialize() must be called once for each process (in this case, the
 * current process), before any of the other functions can be called.
 */
static BOOL g_bSymInitialized = FALSE;


/**
 * Lookup the address of a DbgHelp function.
 */
static FARPROC WINAPI
getDbgHelpProcAddress(LPCSTR lpProcName)
{
   static HMODULE hModule = NULL;

   if (!hModule) {
      static boolean bail = FALSE;

      if (bail) {
         return NULL;
      }

#ifdef PIPE_CC_GCC
      /*
       * DbgHelp does not understand the debug information generated by MinGW toolchain.
       *
       * mgwhelp.dll is a dbghelp.dll look-alike replacement, which is able to
       * understand MinGW symbols, including on 64-bit builds.
       */
      if (!hModule) {
         hModule = LoadLibraryA("mgwhelp.dll");
         if (!hModule) {
            _debug_printf("warning: mgwhelp.dll not found: symbol names will not be resolved\n"
                          "warning: download it from http://code.google.com/p/jrfonseca/wiki/DrMingw#MgwHelp\n");
         }
      }

      /*
       * bfdhelp.dll was the predecessor of mgwhelp.dll.  It is available from
       * http://people.freedesktop.org/~jrfonseca/bfdhelp/ for now.
       */
      if (!hModule) {
         hModule = LoadLibraryA("bfdhelp.dll");
      }
   #endif

      /*
       * Fallback to the real DbgHelp.
       */
      if (!hModule) {
         hModule = LoadLibraryA("dbghelp.dll");
      }

      if (!hModule) {
         bail = TRUE;
         return NULL;
      }
   }

   return GetProcAddress(hModule, lpProcName);
}


/**
 * Generic macro to dispatch a DbgHelp functions.
 */
#define DBGHELP_DISPATCH(_name, _ret_type, _ret_default, _arg_types, _arg_names) \
   static _ret_type WINAPI \
   j_##_name _arg_types \
   { \
      typedef BOOL (WINAPI *PFN) _arg_types; \
      static PFN pfn = NULL; \
      if (!pfn) { \
         pfn = (PFN) getDbgHelpProcAddress(#_name); \
         if (!pfn) { \
            return _ret_default; \
         } \
      } \
      return pfn _arg_names; \
   }

DBGHELP_DISPATCH(SymInitialize,
                 BOOL, 0,
                 (HANDLE hProcess, PSTR UserSearchPath, BOOL fInvadeProcess),
                 (hProcess, UserSearchPath, fInvadeProcess))

DBGHELP_DISPATCH(SymSetOptions,
                 DWORD, FALSE,
                 (DWORD SymOptions),
                 (SymOptions))

DBGHELP_DISPATCH(SymFromAddr,
                 BOOL, FALSE,
                 (HANDLE hProcess, DWORD64 Address, PDWORD64 Displacement, PSYMBOL_INFO Symbol),
                 (hProcess, Address, Displacement, Symbol))

DBGHELP_DISPATCH(SymGetLineFromAddr64,
                 BOOL, FALSE,
                 (HANDLE hProcess, DWORD64 dwAddr, PDWORD pdwDisplacement, PIMAGEHLP_LINE64 Line),
                 (hProcess, dwAddr, pdwDisplacement, Line))


#undef DBGHELP_DISPATCH


static INLINE boolean
debug_symbol_name_dbghelp(const void *addr, char* buf, unsigned size)
{
   DWORD64 dwAddr = (DWORD64)(uintptr_t)addr;
   HANDLE hProcess = GetCurrentProcess();

   /* General purpose buffer, to back pSymbol and other temporary stuff.
    * Must not be too memory hungry here to avoid stack overflows.
    */
   CHAR buffer[512];

   PSYMBOL_INFO pSymbol = (PSYMBOL_INFO) buffer;
   DWORD64 dwDisplacement = 0;  /* Displacement of the input address, relative to the start of the symbol */
   DWORD dwLineDisplacement = 0;
   IMAGEHLP_LINE64 Line;

   memset(pSymbol, 0, sizeof *pSymbol);
   pSymbol->SizeOfStruct = sizeof buffer;
   pSymbol->MaxNameLen = sizeof buffer - offsetof(SYMBOL_INFO, Name);

   if (!g_bSymInitialized) {
      j_SymSetOptions(/* SYMOPT_UNDNAME | */ SYMOPT_LOAD_LINES);
      if (j_SymInitialize(hProcess, NULL, TRUE)) {
         g_bSymInitialized = TRUE;
      }
   }

   /* Lookup symbol name */
   if (!g_bSymInitialized ||
       !j_SymFromAddr(hProcess, dwAddr, &dwDisplacement, pSymbol)) {
      /*
       * We couldn't obtain symbol information.  At least tell which module the address belongs.
       */

      HMODULE hModule = NULL;

      if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
                             (LPCTSTR)addr,
                             &hModule)) {
         return FALSE;
      }

      if (GetModuleFileNameA(hModule, buffer, sizeof buffer) == sizeof buffer) {
         return FALSE;
      }
      util_snprintf(buf, size, "%p at %s+0x%lx",
                    addr, buffer,
                    (unsigned long)((uintptr_t)addr - (uintptr_t)hModule));

      return TRUE;
   }

   /*
    * Try to get filename and line number.
    */
   memset(&Line, 0, sizeof Line);
   Line.SizeOfStruct = sizeof Line;
   if (!j_SymGetLineFromAddr64(hProcess, dwAddr, &dwLineDisplacement, &Line)) {
      Line.FileName = NULL;
   }

   if (Line.FileName) {
      util_snprintf(buf, size, "%s at %s:%lu", pSymbol->Name, Line.FileName, Line.LineNumber);
   } else {
      util_snprintf(buf, size, "%s", pSymbol->Name);
   }

   return TRUE;
}

#endif /* PIPE_OS_WINDOWS */


#if defined(__GLIBC__) && !defined(__UCLIBC__)

#include <execinfo.h>

/* This can only provide dynamic symbols, or binary offsets into a file.
 *
 * To fix this, post-process the output with tools/addr2line.sh
 */
static INLINE boolean
debug_symbol_name_glibc(const void *addr, char* buf, unsigned size)
{
   char** syms = backtrace_symbols((void**)&addr, 1);
   if (!syms) {
      return FALSE;
   }
   strncpy(buf, syms[0], size);
   buf[size - 1] = 0;
   free(syms);
   return TRUE;
}

#endif /* defined(__GLIBC__) && !defined(__UCLIBC__) */


void
debug_symbol_name(const void *addr, char* buf, unsigned size)
{
#if defined(PIPE_OS_WINDOWS)
   if (debug_symbol_name_dbghelp(addr, buf, size)) {
      return;
   }
#endif

#if defined(__GLIBC__) && !defined(__UCLIBC__)
   if (debug_symbol_name_glibc(addr, buf, size)) {
       return;
   }
#endif

   util_snprintf(buf, size, "%p", addr);
   buf[size - 1] = 0;
}

void
debug_symbol_print(const void *addr)
{
   char buf[1024];
   debug_symbol_name(addr, buf, sizeof(buf));
   debug_printf("\t%s\n", buf);
}

struct util_hash_table* symbols_hash;
pipe_static_mutex(symbols_mutex);

static unsigned hash_ptr(void* p)
{
   return (unsigned)(uintptr_t)p;
}

static int compare_ptr(void* a, void* b)
{
   if(a == b)
      return 0;
   else if(a < b)
      return -1;
   else
      return 1;
}

const char*
debug_symbol_name_cached(const void *addr)
{
   const char* name;
#ifdef PIPE_SUBSYSTEM_WINDOWS_USER
   static boolean first = TRUE;

   if (first) {
      pipe_mutex_init(symbols_mutex);
      first = FALSE;
   }
#endif

   pipe_mutex_lock(symbols_mutex);
   if(!symbols_hash)
      symbols_hash = util_hash_table_create(hash_ptr, compare_ptr);
   name = util_hash_table_get(symbols_hash, (void*)addr);
   if(!name)
   {
      char buf[1024];
      debug_symbol_name(addr, buf, sizeof(buf));
      name = strdup(buf);

      util_hash_table_set(symbols_hash, (void*)addr, (void*)name);
   }
   pipe_mutex_unlock(symbols_mutex);
   return name;
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d43 2
a44 1
#if defined(PIPE_OS_WINDOWS) && defined(PIPE_ARCH_X86)
d52 14
a65 1
static BOOL bSymInitialized = FALSE;
d67 2
a68 1
static HMODULE hModule_Dbghelp = NULL;
d70 3
a73 3
static
FARPROC WINAPI __GetProcAddress(LPCSTR lpProcName)
{
a74 1
   if (!hModule_Dbghelp) {
d76 15
a90 2
       * bfdhelp.dll is a dbghelp.dll look-alike replacement, which is able to
       * understand MinGW symbols using BFD library.  It is available from
d93 11
a103 3
      hModule_Dbghelp = LoadLibraryA("bfdhelp.dll");
   }
#endif
d105 2
a106 3
   if (!hModule_Dbghelp) {
      hModule_Dbghelp = LoadLibraryA("dbghelp.dll");
      if (!hModule_Dbghelp) {
d111 1
a111 1
   return GetProcAddress(hModule_Dbghelp, lpProcName);
d115 17
a131 2
typedef BOOL (WINAPI *PFNSYMINITIALIZE)(HANDLE, LPSTR, BOOL);
static PFNSYMINITIALIZE pfnSymInitialize = NULL;
d133 9
a141 10
static
BOOL WINAPI j_SymInitialize(HANDLE hProcess, PSTR UserSearchPath, BOOL fInvadeProcess)
{
   if(
      (pfnSymInitialize || (pfnSymInitialize = (PFNSYMINITIALIZE) __GetProcAddress("SymInitialize")))
   )
      return pfnSymInitialize(hProcess, UserSearchPath, fInvadeProcess);
   else
      return FALSE;
}
d143 4
a146 2
typedef DWORD (WINAPI *PFNSYMSETOPTIONS)(DWORD);
static PFNSYMSETOPTIONS pfnSymSetOptions = NULL;
d148 4
a151 10
static
DWORD WINAPI j_SymSetOptions(DWORD SymOptions)
{
   if(
      (pfnSymSetOptions || (pfnSymSetOptions = (PFNSYMSETOPTIONS) __GetProcAddress("SymSetOptions")))
   )
      return pfnSymSetOptions(SymOptions);
   else
      return FALSE;
}
a152 2
typedef BOOL (WINAPI *PFNSYMGETSYMFROMADDR)(HANDLE, DWORD64, PDWORD64, PSYMBOL_INFO);
static PFNSYMGETSYMFROMADDR pfnSymFromAddr = NULL;
d154 1
a154 10
static
BOOL WINAPI j_SymFromAddr(HANDLE hProcess, DWORD64 Address, PDWORD64 Displacement, PSYMBOL_INFO Symbol)
{
   if(
      (pfnSymFromAddr || (pfnSymFromAddr = (PFNSYMGETSYMFROMADDR) __GetProcAddress("SymFromAddr")))
   )
      return pfnSymFromAddr(hProcess, Address, Displacement, Symbol);
   else
      return FALSE;
}
d157 1
a157 1
static INLINE void
d160 9
a168 3
   HANDLE hProcess;
   BYTE symbolBuffer[1024];
   PSYMBOL_INFO pSymbol = (PSYMBOL_INFO) symbolBuffer;
d170 2
a171 2

   hProcess = GetCurrentProcess();
d174 2
a175 2
   pSymbol->SizeOfStruct = sizeof(symbolBuffer);
   pSymbol->MaxNameLen = sizeof(symbolBuffer) - offsetof(SYMBOL_INFO, Name);
d177 1
a177 1
   if(!bSymInitialized) {
d179 28
a206 2
      if(j_SymInitialize(hProcess, NULL, TRUE))
         bSymInitialized = TRUE;
d209 7
a215 6
   if(!j_SymFromAddr(hProcess, (DWORD64)(uintptr_t)addr, &dwDisplacement, pSymbol))
      buf[0] = 0;
   else
   {
      strncpy(buf, pSymbol->Name, size);
      buf[size - 1] = 0;
d217 8
a225 1
#endif
d227 5
a231 1
#ifdef __GLIBC__
d238 1
a238 1
static INLINE void
d242 3
d248 1
d250 3
a252 1
#endif
d257 2
a258 3
#if defined(PIPE_OS_WINDOWS) && defined(PIPE_ARCH_X86)
   debug_symbol_name_dbghelp(addr, buf, size);
   if(buf[0])
d260 1
d263 4
a266 4
#ifdef __GLIBC__
   debug_symbol_name_glibc(addr, buf, size);
   if(buf[0])
      return;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d43 1
a43 1
#if defined(PIPE_CC_MSVC) && defined(PIPE_ARCH_X86)
a46 1
#include <imagehlp.h>
d48 2
a49 4
/*
 * TODO: Cleanup code.
 * TODO: Support x86_64 
 */
d53 27
a79 1
static HMODULE hModule_Imagehlp = NULL;
d88 1
a88 2
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnSymInitialize || (pfnSymInitialize = (PFNSYMINITIALIZE) GetProcAddress(hModule_Imagehlp, "SymInitialize")))
d102 1
a102 2
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnSymSetOptions || (pfnSymSetOptions = (PFNSYMSETOPTIONS) GetProcAddress(hModule_Imagehlp, "SymSetOptions")))
d109 2
a110 2
typedef PGET_MODULE_BASE_ROUTINE PFNSYMGETMODULEBASE;
static PFNSYMGETMODULEBASE pfnSymGetModuleBase = NULL;
d113 1
a113 1
DWORD WINAPI j_SymGetModuleBase(HANDLE hProcess, DWORD dwAddr)
d116 1
a116 2
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnSymGetModuleBase || (pfnSymGetModuleBase = (PFNSYMGETMODULEBASE) GetProcAddress(hModule_Imagehlp, "SymGetModuleBase")))
d118 1
a118 16
      return pfnSymGetModuleBase(hProcess, dwAddr);
   else
      return 0;
}

typedef BOOL (WINAPI *PFNSYMGETSYMFROMADDR)(HANDLE, DWORD, LPDWORD, PIMAGEHLP_SYMBOL);
static PFNSYMGETSYMFROMADDR pfnSymGetSymFromAddr = NULL;

static
BOOL WINAPI j_SymGetSymFromAddr(HANDLE hProcess, DWORD Address, PDWORD Displacement, PIMAGEHLP_SYMBOL Symbol)
{
   if(
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnSymGetSymFromAddr || (pfnSymGetSymFromAddr = (PFNSYMGETSYMFROMADDR) GetProcAddress(hModule_Imagehlp, "SymGetSymFromAddr")))
   )
      return pfnSymGetSymFromAddr(hProcess, Address, Displacement, Symbol);
d125 1
a125 1
debug_symbol_name_imagehlp(const void *addr, char* buf, unsigned size)
d129 2
a130 2
   PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL) symbolBuffer;
   DWORD dwDisplacement = 0;  /* Displacement of the input address, relative to the start of the symbol */
d134 1
d136 1
a136 1
   pSymbol->MaxNameLength = sizeof(symbolBuffer) - offsetof(IMAGEHLP_SYMBOL, Name);
d144 1
a144 1
   if(!j_SymGetSymFromAddr(hProcess, (DWORD)addr, &dwDisplacement, pSymbol))
d174 2
a175 2
#if defined(PIPE_CC_MSVC) && defined(PIPE_ARCH_X86)
   debug_symbol_name_imagehlp(addr, buf, size);
d199 1
a199 1
pipe_mutex symbols_mutex;
d220 9
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d36 2
d41 1
d43 1
a43 1
#if defined(PIPE_SUBSYSTEM_WINDOWS_USER) && defined(PIPE_ARCH_X86)
a72 15
typedef BOOL (WINAPI *PFNSYMCLEANUP)(HANDLE);
static PFNSYMCLEANUP pfnSymCleanup = NULL;

static
BOOL WINAPI j_SymCleanup(HANDLE hProcess)
{
   if(
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnSymCleanup || (pfnSymCleanup = (PFNSYMCLEANUP) GetProcAddress(hModule_Imagehlp, "SymCleanup")))
   )
      return pfnSymCleanup(hProcess);
   else
      return FALSE;
}

a87 30
typedef BOOL (WINAPI *PFNSYMUNDNAME)(PIMAGEHLP_SYMBOL, PSTR, DWORD);
static PFNSYMUNDNAME pfnSymUnDName = NULL;

static
BOOL WINAPI j_SymUnDName(PIMAGEHLP_SYMBOL Symbol, PSTR UnDecName, DWORD UnDecNameLength)
{
   if(
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnSymUnDName || (pfnSymUnDName = (PFNSYMUNDNAME) GetProcAddress(hModule_Imagehlp, "SymUnDName")))
   )
      return pfnSymUnDName(Symbol, UnDecName, UnDecNameLength);
   else
      return FALSE;
}

typedef PFUNCTION_TABLE_ACCESS_ROUTINE PFNSYMFUNCTIONTABLEACCESS;
static PFNSYMFUNCTIONTABLEACCESS pfnSymFunctionTableAccess = NULL;

static
PVOID WINAPI j_SymFunctionTableAccess(HANDLE hProcess, DWORD AddrBase)
{
   if(
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnSymFunctionTableAccess || (pfnSymFunctionTableAccess = (PFNSYMFUNCTIONTABLEACCESS) GetProcAddress(hModule_Imagehlp, "SymFunctionTableAccess")))
   )
      return pfnSymFunctionTableAccess(hProcess, AddrBase);
   else
      return NULL;
}

a102 35
typedef BOOL (WINAPI *PFNSTACKWALK)(DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID, PREAD_PROCESS_MEMORY_ROUTINE, PFUNCTION_TABLE_ACCESS_ROUTINE, PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE);
static PFNSTACKWALK pfnStackWalk = NULL;

static
BOOL WINAPI j_StackWalk(
   DWORD MachineType, 
   HANDLE hProcess, 
   HANDLE hThread, 
   LPSTACKFRAME StackFrame, 
   PVOID ContextRecord, 
   PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,  
   PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
   PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine, 
   PTRANSLATE_ADDRESS_ROUTINE TranslateAddress 
)
{
   if(
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnStackWalk || (pfnStackWalk = (PFNSTACKWALK) GetProcAddress(hModule_Imagehlp, "StackWalk")))
   )
      return pfnStackWalk(
         MachineType, 
         hProcess, 
         hThread, 
         StackFrame, 
         ContextRecord, 
         ReadMemoryRoutine,  
         FunctionTableAccessRoutine,
         GetModuleBaseRoutine, 
         TranslateAddress 
      );
   else
      return FALSE;
}

a117 15
typedef BOOL (WINAPI *PFNSYMGETLINEFROMADDR)(HANDLE, DWORD, LPDWORD, PIMAGEHLP_LINE);
static PFNSYMGETLINEFROMADDR pfnSymGetLineFromAddr = NULL;

static
BOOL WINAPI j_SymGetLineFromAddr(HANDLE hProcess, DWORD dwAddr, PDWORD pdwDisplacement, PIMAGEHLP_LINE Line)
{
   if(
      (hModule_Imagehlp || (hModule_Imagehlp = LoadLibraryA("IMAGEHLP.DLL"))) &&
      (pfnSymGetLineFromAddr || (pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR) GetProcAddress(hModule_Imagehlp, "SymGetLineFromAddr")))
   )
      return pfnSymGetLineFromAddr(hProcess, dwAddr, pdwDisplacement, Line);
   else
      return FALSE;
}

d119 2
a120 2
static INLINE boolean
debug_symbol_print_imagehlp(const void *addr)
d137 1
a137 1
      
d139 8
a146 1
      return FALSE;
d148 2
a149 1
   debug_printf("\t%s\n", pSymbol->Name);
d151 11
a161 2
   return TRUE;
   
d165 18
d187 41
a227 6
#if defined(PIPE_SUBSYSTEM_WINDOWS_USER) && defined(PIPE_ARCH_X86)
   if(debug_symbol_print_imagehlp(addr))
      return;
#endif
   
   debug_printf("\t%p\n", addr);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a35 2
#include "os/os_thread.h"
#include "u_string.h"
a38 1
#include "u_hash_table.h"
d40 1
a40 1
#if defined(PIPE_CC_MSVC) && defined(PIPE_ARCH_X86)
d70 15
d100 30
d145 35
d195 15
d211 2
a212 2
static INLINE void
debug_symbol_name_imagehlp(const void *addr, char* buf, unsigned size)
d229 1
a229 1

d231 1
a231 8
      buf[0] = 0;
   else
   {
      strncpy(buf, pSymbol->Name, size);
      buf[size - 1] = 0;
   }
}
#endif
d233 1
a233 2
#ifdef __GLIBC__
#include <execinfo.h>
d235 2
a236 11
/* This can only provide dynamic symbols, or binary offsets into a file.
 *
 * To fix this, post-process the output with tools/addr2line.sh
 */
static INLINE void
debug_symbol_name_glibc(const void *addr, char* buf, unsigned size)
{
   char** syms = backtrace_symbols((void**)&addr, 1);
   strncpy(buf, syms[0], size);
   buf[size - 1] = 0;
   free(syms);
d240 1
d242 1
a242 1
debug_symbol_name(const void *addr, char* buf, unsigned size)
d244 2
a245 3
#if defined(PIPE_CC_MSVC) && defined(PIPE_ARCH_X86)
   debug_symbol_name_imagehlp(addr, buf, size);
   if(buf[0])
d248 2
a249 55

#ifdef __GLIBC__
   debug_symbol_name_glibc(addr, buf, size);
   if(buf[0])
      return;
#endif

   util_snprintf(buf, size, "%p", addr);
   buf[size - 1] = 0;
}

void
debug_symbol_print(const void *addr)
{
   char buf[1024];
   debug_symbol_name(addr, buf, sizeof(buf));
   debug_printf("\t%s\n", buf);
}

struct util_hash_table* symbols_hash;
pipe_mutex symbols_mutex;

static unsigned hash_ptr(void* p)
{
   return (unsigned)(uintptr_t)p;
}

static int compare_ptr(void* a, void* b)
{
   if(a == b)
      return 0;
   else if(a < b)
      return -1;
   else
      return 1;
}

const char*
debug_symbol_name_cached(const void *addr)
{
   const char* name;
   pipe_mutex_lock(symbols_mutex);
   if(!symbols_hash)
      symbols_hash = util_hash_table_create(hash_ptr, compare_ptr);
   name = util_hash_table_get(symbols_hash, (void*)addr);
   if(!name)
   {
      char buf[1024];
      debug_symbol_name(addr, buf, sizeof(buf));
      name = strdup(buf);

      util_hash_table_set(symbols_hash, (void*)addr, (void*)name);
   }
   pipe_mutex_unlock(symbols_mutex);
   return name;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d43 1
a43 2

#if defined(PIPE_OS_WINDOWS)
d47 1
d49 4
a52 1
#include "dbghelp.h"
d54 1
d56 1
a56 5
/**
 * SymInitialize() must be called once for each process (in this case, the
 * current process), before any of the other functions can be called.
 */
static BOOL g_bSymInitialized = FALSE;
d58 2
d61 2
a62 5
/**
 * Lookup the address of a DbgHelp function.
 */
static FARPROC WINAPI
getDbgHelpProcAddress(LPCSTR lpProcName)
d64 8
a71 1
   static HMODULE hModule = NULL;
d73 2
a74 2
   if (!hModule) {
      static boolean bail = FALSE;
d76 10
a85 42
      if (bail) {
         return NULL;
      }

#ifdef PIPE_CC_GCC
      /*
       * DbgHelp does not understand the debug information generated by MinGW toolchain.
       *
       * mgwhelp.dll is a dbghelp.dll look-alike replacement, which is able to
       * understand MinGW symbols, including on 64-bit builds.
       */
      if (!hModule) {
         hModule = LoadLibraryA("mgwhelp.dll");
         if (!hModule) {
            _debug_printf("warning: mgwhelp.dll not found: symbol names will not be resolved\n"
                          "warning: download it from http://code.google.com/p/jrfonseca/wiki/DrMingw#MgwHelp\n");
         }
      }

      /*
       * bfdhelp.dll was the predecessor of mgwhelp.dll.  It is available from
       * http://people.freedesktop.org/~jrfonseca/bfdhelp/ for now.
       */
      if (!hModule) {
         hModule = LoadLibraryA("bfdhelp.dll");
      }
   #endif

      /*
       * Fallback to the real DbgHelp.
       */
      if (!hModule) {
         hModule = LoadLibraryA("dbghelp.dll");
      }

      if (!hModule) {
         bail = TRUE;
         return NULL;
      }
   }

   return GetProcAddress(hModule, lpProcName);
d88 2
d91 11
a101 17
/**
 * Generic macro to dispatch a DbgHelp functions.
 */
#define DBGHELP_DISPATCH(_name, _ret_type, _ret_default, _arg_types, _arg_names) \
   static _ret_type WINAPI \
   j_##_name _arg_types \
   { \
      typedef BOOL (WINAPI *PFN) _arg_types; \
      static PFN pfn = NULL; \
      if (!pfn) { \
         pfn = (PFN) getDbgHelpProcAddress(#_name); \
         if (!pfn) { \
            return _ret_default; \
         } \
      } \
      return pfn _arg_names; \
   }
d103 2
a104 19
DBGHELP_DISPATCH(SymInitialize,
                 BOOL, 0,
                 (HANDLE hProcess, PSTR UserSearchPath, BOOL fInvadeProcess),
                 (hProcess, UserSearchPath, fInvadeProcess))

DBGHELP_DISPATCH(SymSetOptions,
                 DWORD, FALSE,
                 (DWORD SymOptions),
                 (SymOptions))

DBGHELP_DISPATCH(SymFromAddr,
                 BOOL, FALSE,
                 (HANDLE hProcess, DWORD64 Address, PDWORD64 Displacement, PSYMBOL_INFO Symbol),
                 (hProcess, Address, Displacement, Symbol))

DBGHELP_DISPATCH(SymGetLineFromAddr64,
                 BOOL, FALSE,
                 (HANDLE hProcess, DWORD64 dwAddr, PDWORD pdwDisplacement, PIMAGEHLP_LINE64 Line),
                 (hProcess, dwAddr, pdwDisplacement, Line))
d106 11
a117 1
#undef DBGHELP_DISPATCH
d119 2
a120 3

static INLINE boolean
debug_symbol_name_dbghelp(const void *addr, char* buf, unsigned size)
d122 4
a125 7
   DWORD64 dwAddr = (DWORD64)(uintptr_t)addr;
   HANDLE hProcess = GetCurrentProcess();

   /* General purpose buffer, to back pSymbol and other temporary stuff.
    * Must not be too memory hungry here to avoid stack overflows.
    */
   CHAR buffer[512];
d127 1
a127 4
   PSYMBOL_INFO pSymbol = (PSYMBOL_INFO) buffer;
   DWORD64 dwDisplacement = 0;  /* Displacement of the input address, relative to the start of the symbol */
   DWORD dwLineDisplacement = 0;
   IMAGEHLP_LINE64 Line;
d129 2
a130 3
   memset(pSymbol, 0, sizeof *pSymbol);
   pSymbol->SizeOfStruct = sizeof buffer;
   pSymbol->MaxNameLen = sizeof buffer - offsetof(SYMBOL_INFO, Name);
d132 1
a132 1
   if (!g_bSymInitialized) {
d134 2
a135 3
      if (j_SymInitialize(hProcess, NULL, TRUE)) {
         g_bSymInitialized = TRUE;
      }
d138 6
a143 23
   /* Lookup symbol name */
   if (!g_bSymInitialized ||
       !j_SymFromAddr(hProcess, dwAddr, &dwDisplacement, pSymbol)) {
      /*
       * We couldn't obtain symbol information.  At least tell which module the address belongs.
       */

      HMODULE hModule = NULL;

      if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
                             (LPCTSTR)addr,
                             &hModule)) {
         return FALSE;
      }

      if (GetModuleFileNameA(hModule, buffer, sizeof buffer) == sizeof buffer) {
         return FALSE;
      }
      util_snprintf(buf, size, "%p at %s+0x%lx",
                    addr, buffer,
                    (unsigned long)((uintptr_t)addr - (uintptr_t)hModule));

      return TRUE;
a144 17

   /*
    * Try to get filename and line number.
    */
   memset(&Line, 0, sizeof Line);
   Line.SizeOfStruct = sizeof Line;
   if (!j_SymGetLineFromAddr64(hProcess, dwAddr, &dwLineDisplacement, &Line)) {
      Line.FileName = NULL;
   }

   if (Line.FileName) {
      util_snprintf(buf, size, "%s at %s:%lu", pSymbol->Name, Line.FileName, Line.LineNumber);
   } else {
      util_snprintf(buf, size, "%s", pSymbol->Name);
   }

   return TRUE;
d146 1
d148 1
a148 5
#endif /* PIPE_OS_WINDOWS */


#if defined(__GLIBC__) && !defined(__UCLIBC__)

d155 1
a155 1
static INLINE boolean
a158 3
   if (!syms) {
      return FALSE;
   }
a161 1
   return TRUE;
d163 1
a163 3

#endif /* defined(__GLIBC__) && !defined(__UCLIBC__) */

d168 3
a170 2
#if defined(PIPE_OS_WINDOWS)
   if (debug_symbol_name_dbghelp(addr, buf, size)) {
a171 1
   }
d174 4
a177 4
#if defined(__GLIBC__) && !defined(__UCLIBC__)
   if (debug_symbol_name_glibc(addr, buf, size)) {
       return;
   }
d193 1
a193 1
pipe_static_mutex(symbols_mutex);
a213 9
#ifdef PIPE_SUBSYSTEM_WINDOWS_USER
   static boolean first = TRUE;

   if (first) {
      pipe_mutex_init(symbols_mutex);
      first = FALSE;
   }
#endif

@


