head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.53;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.48;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/* Helper utility for uploading user buffers & other data, and
 * coalescing small buffers into larger ones.
 */

#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "pipe/p_context.h"
#include "util/u_memory.h"
#include "util/u_math.h"

#include "u_upload_mgr.h"


struct u_upload_mgr {
   struct pipe_context *pipe;

   unsigned default_size;  /* Minimum size of the upload buffer, in bytes. */
   unsigned alignment;     /* Alignment of each sub-allocation. */
   unsigned bind;          /* Bitmask of PIPE_BIND_* flags. */
   unsigned map_flags;     /* Bitmask of PIPE_TRANSFER_* flags. */
   boolean map_persistent; /* If persistent mappings are supported. */

   struct pipe_resource *buffer;   /* Upload buffer. */
   struct pipe_transfer *transfer; /* Transfer object for the upload buffer. */
   uint8_t *map;    /* Pointer to the mapped upload buffer. */
   unsigned offset; /* Aligned offset to the upload buffer, pointing
                     * at the first unused byte. */
};


struct u_upload_mgr *u_upload_create( struct pipe_context *pipe,
                                      unsigned default_size,
                                      unsigned alignment,
                                      unsigned bind )
{
   struct u_upload_mgr *upload = CALLOC_STRUCT( u_upload_mgr );
   if (!upload)
      return NULL;

   upload->pipe = pipe;
   upload->default_size = default_size;
   upload->alignment = alignment;
   upload->bind = bind;

   upload->map_persistent =
      pipe->screen->get_param(pipe->screen,
                              PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT);

   if (upload->map_persistent) {
      upload->map_flags = PIPE_TRANSFER_WRITE |
                          PIPE_TRANSFER_PERSISTENT |
                          PIPE_TRANSFER_COHERENT;
   }
   else {
      upload->map_flags = PIPE_TRANSFER_WRITE |
                          PIPE_TRANSFER_UNSYNCHRONIZED |
                          PIPE_TRANSFER_FLUSH_EXPLICIT;
   }

   return upload;
}


static void upload_unmap_internal(struct u_upload_mgr *upload, boolean destroying)
{
   if (!destroying && upload->map_persistent)
      return;

   if (upload->transfer) {
      struct pipe_box *box = &upload->transfer->box;

      if (!upload->map_persistent && (int) upload->offset > box->x) {
         pipe_buffer_flush_mapped_range(upload->pipe, upload->transfer,
                                        box->x, upload->offset - box->x);
      }

      pipe_transfer_unmap(upload->pipe, upload->transfer);
      upload->transfer = NULL;
      upload->map = NULL;
   }
}


void u_upload_unmap( struct u_upload_mgr *upload )
{
   upload_unmap_internal(upload, FALSE);
}


static void u_upload_release_buffer(struct u_upload_mgr *upload)
{
   /* Unmap and unreference the upload buffer. */
   upload_unmap_internal(upload, TRUE);
   pipe_resource_reference( &upload->buffer, NULL );
}


void u_upload_destroy( struct u_upload_mgr *upload )
{
   u_upload_release_buffer( upload );
   FREE( upload );
}


static enum pipe_error 
u_upload_alloc_buffer( struct u_upload_mgr *upload,
                       unsigned min_size )
{
   struct pipe_screen *screen = upload->pipe->screen;
   struct pipe_resource buffer;
   unsigned size;

   /* Release the old buffer, if present:
    */
   u_upload_release_buffer( upload );

   /* Allocate a new one: 
    */
   size = align(MAX2(upload->default_size, min_size), 4096);

   memset(&buffer, 0, sizeof buffer);
   buffer.target = PIPE_BUFFER;
   buffer.format = PIPE_FORMAT_R8_UNORM; /* want TYPELESS or similar */
   buffer.bind = upload->bind;
   buffer.usage = PIPE_USAGE_STREAM;
   buffer.width0 = size;
   buffer.height0 = 1;
   buffer.depth0 = 1;
   buffer.array_size = 1;

   if (upload->map_persistent) {
      buffer.flags = PIPE_RESOURCE_FLAG_MAP_PERSISTENT |
                     PIPE_RESOURCE_FLAG_MAP_COHERENT;
   }

   upload->buffer = screen->resource_create(screen, &buffer);
   if (upload->buffer == NULL) {
      return PIPE_ERROR_OUT_OF_MEMORY;
   }

   /* Map the new buffer. */
   upload->map = pipe_buffer_map_range(upload->pipe, upload->buffer,
                                       0, size, upload->map_flags,
                                       &upload->transfer);
   if (upload->map == NULL) {
      upload->transfer = NULL;
      pipe_resource_reference(&upload->buffer, NULL);
      return PIPE_ERROR_OUT_OF_MEMORY;
   }

   upload->offset = 0;
   return PIPE_OK;
}

enum pipe_error u_upload_alloc( struct u_upload_mgr *upload,
                                unsigned min_out_offset,
                                unsigned size,
                                unsigned *out_offset,
                                struct pipe_resource **outbuf,
                                void **ptr )
{
   unsigned alloc_size = align( size, upload->alignment );
   unsigned alloc_offset = align(min_out_offset, upload->alignment);
   unsigned offset;

   /* Init these return values here in case we fail below to make
    * sure the caller doesn't get garbage values.
    */
   *out_offset = ~0;
   pipe_resource_reference(outbuf, NULL);
   *ptr = NULL;

   /* Make sure we have enough space in the upload buffer
    * for the sub-allocation. */
   if (!upload->buffer ||
       MAX2(upload->offset, alloc_offset) + alloc_size > upload->buffer->width0) {
      enum pipe_error ret = u_upload_alloc_buffer(upload,
                                                  alloc_offset + alloc_size);
      if (ret != PIPE_OK)
         return ret;
   }

   offset = MAX2(upload->offset, alloc_offset);

   if (!upload->map) {
      upload->map = pipe_buffer_map_range(upload->pipe, upload->buffer,
                                          offset,
                                          upload->buffer->width0 - offset,
                                          upload->map_flags,
					  &upload->transfer);
      if (!upload->map) {
         upload->transfer = NULL;
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      upload->map -= offset;
   }

   assert(offset < upload->buffer->width0);
   assert(offset + size <= upload->buffer->width0);
   assert(size);

   /* Emit the return values: */
   *ptr = upload->map + offset;
   pipe_resource_reference( outbuf, upload->buffer );
   *out_offset = offset;

   upload->offset = offset + alloc_size;
   return PIPE_OK;
}

enum pipe_error u_upload_data( struct u_upload_mgr *upload,
                               unsigned min_out_offset,
                               unsigned size,
                               const void *data,
                               unsigned *out_offset,
                               struct pipe_resource **outbuf)
{
   uint8_t *ptr;
   enum pipe_error ret = u_upload_alloc(upload, min_out_offset, size,
                                        out_offset, outbuf,
                                        (void**)&ptr);
   if (ret != PIPE_OK)
      return ret;

   memcpy(ptr, data, size);
   return PIPE_OK;
}


/* As above, but upload the full contents of a buffer.  Useful for
 * uploading user buffers, avoids generating an explosion of GPU
 * buffers if you have an app that does lots of small vertex buffer
 * renders or DrawElements calls.
 */
enum pipe_error u_upload_buffer( struct u_upload_mgr *upload,
                                 unsigned min_out_offset,
                                 unsigned offset,
                                 unsigned size,
                                 struct pipe_resource *inbuf,
                                 unsigned *out_offset,
                                 struct pipe_resource **outbuf)
{
   enum pipe_error ret = PIPE_OK;
   struct pipe_transfer *transfer = NULL;
   const char *map = NULL;

   map = (const char *)pipe_buffer_map_range(upload->pipe,
                                             inbuf,
                                             offset, size,
                                             PIPE_TRANSFER_READ,
                                             &transfer);

   if (map == NULL) {
      return PIPE_ERROR_OUT_OF_MEMORY;
   }

   if (0)
      debug_printf("upload ptr %p ofs %d sz %d\n", map, offset, size);

   ret = u_upload_data( upload,
                        min_out_offset,
                        size,
                        map,
                        out_offset,
                        outbuf);

   pipe_buffer_unmap( upload->pipe, transfer );

   return ret;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d47 2
a52 1
   unsigned size;   /* Actual size of the upload buffer. */
d71 15
a85 1
   upload->buffer = NULL;
d90 2
a91 1
void u_upload_unmap( struct u_upload_mgr *upload )
d93 3
a97 1
      if ((int) upload->offset > box->x) {
d99 1
d103 1
d110 8
a117 10
/* Release old buffer.
 * 
 * This must usually be called prior to firing the command stream
 * which references the upload buffer, as many memory managers will
 * cause subsequent maps of a fired buffer to wait.
 *
 * Can improve this with a change to pipe_buffer_write to use the
 * DONT_WAIT bit, but for now, it's easiest just to grab a new buffer.
 */
void u_upload_flush( struct u_upload_mgr *upload )
d120 1
a120 1
   u_upload_unmap(upload);
a121 1
   upload->size = 0;
d127 1
a127 1
   u_upload_flush( upload );
d136 2
d142 1
a142 1
   u_upload_flush( upload );
d148 16
a163 4
   upload->buffer = pipe_buffer_create( upload->pipe->screen,
                                        upload->bind,
                                        PIPE_USAGE_STREAM,
                                        size );
d170 1
a170 3
                                       0, size,
                                       PIPE_TRANSFER_WRITE |
                                       PIPE_TRANSFER_FLUSH_EXPLICIT,
a173 1
      upload->size = 0;
a177 1
   upload->size = size;
d202 2
a203 1
   if (MAX2(upload->offset, alloc_offset) + alloc_size > upload->size) {
d214 3
a216 4
					  offset, upload->size - offset,
					  PIPE_TRANSFER_WRITE |
					  PIPE_TRANSFER_FLUSH_EXPLICIT |
					  PIPE_TRANSFER_UNSYNCHRONIZED,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d75 15
d102 1
a102 9
   if (upload->transfer) {
      if (upload->offset) {
         pipe_buffer_flush_mapped_range(upload->pipe, upload->transfer,
                                        0, upload->offset);
      }
      pipe_transfer_unmap(upload->pipe, upload->transfer);
      pipe_transfer_destroy(upload->pipe, upload->transfer);
      upload->transfer = NULL;
   }
d133 3
a135 2
   if (upload->buffer == NULL) 
      goto fail;
d143 7
a149 1
   
a150 1

d152 1
a152 7
   return 0;

fail:
   if (upload->buffer)
      pipe_resource_reference( &upload->buffer, NULL );

   return PIPE_ERROR_OUT_OF_MEMORY;
a159 1
                                boolean *flushed,
d166 7
d178 1
a178 1
      if (ret)
a179 4

      *flushed = TRUE;
   } else {
      *flushed = FALSE;
d184 15
d217 1
a217 2
                               struct pipe_resource **outbuf,
                               boolean *flushed )
d221 1
a221 1
                                        out_offset, outbuf, flushed,
d223 1
a223 1
   if (ret)
d242 1
a242 2
                                 struct pipe_resource **outbuf,
                                 boolean *flushed )
d248 5
a252 4
   map = (const char *)pipe_buffer_map(upload->pipe,
				       inbuf,
				       PIPE_TRANSFER_READ,
				       &transfer);
d255 1
a255 2
      ret = PIPE_ERROR_OUT_OF_MEMORY;
      goto done;
d264 1
a264 1
                        map + offset,
d266 1
a266 1
                        outbuf, flushed );
d268 1
a268 3
done:
   if (map)
      pipe_buffer_unmap( upload->pipe, transfer );
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d44 10
a53 9
   unsigned default_size;
   unsigned alignment;
   unsigned usage;

   /* The active buffer:
    */
   struct pipe_resource *buffer;
   unsigned size;
   unsigned offset;
d60 1
a60 1
                                      unsigned usage )
d69 1
a69 1
   upload->usage = usage;
a74 42
/* Slightly specialized version of buffer_write designed to maximize
 * chances of the driver consolidating successive writes into a single
 * upload.
 *
 * dirty_size may be slightly greater than size to cope with
 * alignment.  We don't want to leave holes between succesively mapped
 * regions as that may prevent the driver from consolidating uploads.
 * 
 * Note that the 'data' pointer has probably come from the application
 * and we cannot read even a byte past its end without risking
 * segfaults, or at least complaints from valgrind..
 */
static INLINE enum pipe_error
my_buffer_write(struct pipe_context *pipe,
                struct pipe_resource *buf,
                unsigned offset, unsigned size, unsigned dirty_size,
                const void *data)
{
   struct pipe_transfer *transfer = NULL;
   uint8_t *map;
   
   assert(offset < buf->width0);
   assert(offset + size <= buf->width0);
   assert(dirty_size >= size);
   assert(size);

   map = pipe_buffer_map_range(pipe, buf, offset, dirty_size,
                               PIPE_TRANSFER_WRITE |
                               PIPE_TRANSFER_FLUSH_EXPLICIT |
                               PIPE_TRANSFER_DISCARD |
                               PIPE_TRANSFER_UNSYNCHRONIZED,
			       &transfer);
   if (map == NULL) 
      return PIPE_ERROR_OUT_OF_MEMORY;

   memcpy(map + offset, data, size);
   pipe_buffer_flush_mapped_range(pipe, transfer, offset, dirty_size);
   pipe_buffer_unmap(pipe, buf, transfer);

   return PIPE_OK;
}

d86 10
d114 1
a114 1
   /* Release old buffer, if present:
d123 2
a124 1
                                        upload->usage,
d128 7
d148 7
a154 6

enum pipe_error u_upload_data( struct u_upload_mgr *upload,
                               unsigned size,
                               const void *data,
                               unsigned *out_offset,
                               struct pipe_resource **outbuf )
d157 2
a158 1
   enum pipe_error ret = PIPE_OK;
d160 5
a164 2
   if (upload->offset + alloc_size > upload->size) {
      ret = u_upload_alloc_buffer( upload, alloc_size );
d167 4
d173 27
a199 8
   /* Copy the data, using map_range if available:
    */
   ret = my_buffer_write( upload->pipe, 
                          upload->buffer,
                          upload->offset,
                          size, 
                          alloc_size,
                          data );
d203 1
a203 5
   /* Emit the return values:
    */
   pipe_resource_reference( outbuf, upload->buffer );
   *out_offset = upload->offset;
   upload->offset += alloc_size;
d214 1
d219 2
a220 1
                                 struct pipe_resource **outbuf )
d239 2
a240 1
   ret = u_upload_data( upload, 
d244 1
a244 3
                        outbuf );
   if (ret)
      goto done;
d248 1
a248 1
      pipe_buffer_unmap( upload->pipe, inbuf, transfer );
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 1
a34 1
#include "pipe/p_screen.h"
d42 1
a42 1
   struct pipe_screen *screen;
d50 1
a50 1
   struct pipe_buffer *buffer;
d56 1
a56 1
struct u_upload_mgr *u_upload_create( struct pipe_screen *screen,
d62 2
d65 1
a66 1
   upload->screen = screen;
d74 12
a85 1

d87 2
a88 2
my_buffer_write(struct pipe_screen *screen,
                struct pipe_buffer *buf,
d92 1
d95 2
a96 2
   assert(offset < buf->size);
   assert(offset + size <= buf->size);
d100 6
a105 5
   map = pipe_buffer_map_range(screen, buf, offset, size, 
                               PIPE_BUFFER_USAGE_CPU_WRITE |
                               PIPE_BUFFER_USAGE_FLUSH_EXPLICIT |
                               PIPE_BUFFER_USAGE_DISCARD |
                               PIPE_BUFFER_USAGE_UNSYNCHRONIZED);
d110 2
a111 2
   pipe_buffer_flush_mapped_range(screen, buf, offset, dirty_size);
   pipe_buffer_unmap(screen, buf);
d127 1
a127 1
   pipe_buffer_reference( &upload->buffer, NULL );
d153 2
a154 3
   upload->buffer = pipe_buffer_create( upload->screen,
                                        upload->alignment,
                                        upload->usage | PIPE_BUFFER_USAGE_CPU_WRITE,
d166 1
a166 1
      pipe_buffer_reference( &upload->buffer, NULL );
d176 1
a176 1
                               struct pipe_buffer **outbuf )
d189 1
a189 1
   ret = my_buffer_write( upload->screen, 
d200 1
a200 1
   pipe_buffer_reference( outbuf, upload->buffer );
d215 1
a215 1
                                 struct pipe_buffer *inbuf,
d217 1
a217 1
                                 struct pipe_buffer **outbuf )
d220 1
d223 4
a226 2
   map = (const char *)pipe_buffer_map( 
      upload->screen, inbuf, PIPE_BUFFER_USAGE_CPU_READ );
d246 1
a246 1
      pipe_buffer_unmap( upload->screen, inbuf );
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 1
a34 1
#include "pipe/p_context.h"
d42 1
a42 1
   struct pipe_context *pipe;
d50 1
a50 1
   struct pipe_resource *buffer;
d56 1
a56 1
struct u_upload_mgr *u_upload_create( struct pipe_context *pipe,
a61 2
   if (!upload)
      return NULL;
a62 1
   upload->pipe = pipe;
d64 1
d72 1
a72 12
/* Slightly specialized version of buffer_write designed to maximize
 * chances of the driver consolidating successive writes into a single
 * upload.
 *
 * dirty_size may be slightly greater than size to cope with
 * alignment.  We don't want to leave holes between succesively mapped
 * regions as that may prevent the driver from consolidating uploads.
 * 
 * Note that the 'data' pointer has probably come from the application
 * and we cannot read even a byte past its end without risking
 * segfaults, or at least complaints from valgrind..
 */
d74 2
a75 2
my_buffer_write(struct pipe_context *pipe,
                struct pipe_resource *buf,
a78 1
   struct pipe_transfer *transfer = NULL;
d81 2
a82 2
   assert(offset < buf->width0);
   assert(offset + size <= buf->width0);
d86 5
a90 6
   map = pipe_buffer_map_range(pipe, buf, offset, dirty_size,
                               PIPE_TRANSFER_WRITE |
                               PIPE_TRANSFER_FLUSH_EXPLICIT |
                               PIPE_TRANSFER_DISCARD |
                               PIPE_TRANSFER_UNSYNCHRONIZED,
			       &transfer);
d95 2
a96 2
   pipe_buffer_flush_mapped_range(pipe, transfer, offset, dirty_size);
   pipe_buffer_unmap(pipe, buf, transfer);
d112 1
a112 1
   pipe_resource_reference( &upload->buffer, NULL );
d138 3
a140 2
   upload->buffer = pipe_buffer_create( upload->pipe->screen,
                                        upload->usage,
d152 1
a152 1
      pipe_resource_reference( &upload->buffer, NULL );
d162 1
a162 1
                               struct pipe_resource **outbuf )
d175 1
a175 1
   ret = my_buffer_write( upload->pipe, 
d186 1
a186 1
   pipe_resource_reference( outbuf, upload->buffer );
d201 1
a201 1
                                 struct pipe_resource *inbuf,
d203 1
a203 1
                                 struct pipe_resource **outbuf )
a205 1
   struct pipe_transfer *transfer = NULL;
d208 2
a209 4
   map = (const char *)pipe_buffer_map(upload->pipe,
				       inbuf,
				       PIPE_TRANSFER_READ,
				       &transfer);
d229 1
a229 1
      pipe_buffer_unmap( upload->pipe, inbuf, transfer );
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d44 9
a52 10
   unsigned default_size;  /* Minimum size of the upload buffer, in bytes. */
   unsigned alignment;     /* Alignment of each sub-allocation. */
   unsigned bind;          /* Bitmask of PIPE_BIND_* flags. */

   struct pipe_resource *buffer;   /* Upload buffer. */
   struct pipe_transfer *transfer; /* Transfer object for the upload buffer. */
   uint8_t *map;    /* Pointer to the mapped upload buffer. */
   unsigned size;   /* Actual size of the upload buffer. */
   unsigned offset; /* Aligned offset to the upload buffer, pointing
                     * at the first unused byte. */
d59 1
a59 1
                                      unsigned bind )
d68 1
a68 1
   upload->bind = bind;
d74 17
a90 1
void u_upload_unmap( struct u_upload_mgr *upload )
d92 22
a113 11
   if (upload->transfer) {
      struct pipe_box *box = &upload->transfer->box;
      if ((int) upload->offset > box->x) {

         pipe_buffer_flush_mapped_range(upload->pipe, upload->transfer,
                                        box->x, upload->offset - box->x);
      }
      pipe_transfer_unmap(upload->pipe, upload->transfer);
      upload->transfer = NULL;
      upload->map = NULL;
   }
a126 2
   /* Unmap and unreference the upload buffer. */
   u_upload_unmap(upload);
d145 1
a145 1
   /* Release the old buffer, if present:
d154 1
a154 2
                                        upload->bind,
                                        PIPE_USAGE_STREAM,
d156 4
a159 3
   if (upload->buffer == NULL) {
      return PIPE_ERROR_OUT_OF_MEMORY;
   }
a160 14
   /* Map the new buffer. */
   upload->map = pipe_buffer_map_range(upload->pipe, upload->buffer,
                                       0, size,
                                       PIPE_TRANSFER_WRITE |
                                       PIPE_TRANSFER_FLUSH_EXPLICIT,
                                       &upload->transfer);
   if (upload->map == NULL) {
      upload->transfer = NULL;
      upload->size = 0;
      pipe_resource_reference(&upload->buffer, NULL);
      return PIPE_ERROR_OUT_OF_MEMORY;
   }

   upload->size = size;
d162 1
a162 13
   return PIPE_OK;
}

enum pipe_error u_upload_alloc( struct u_upload_mgr *upload,
                                unsigned min_out_offset,
                                unsigned size,
                                unsigned *out_offset,
                                struct pipe_resource **outbuf,
                                void **ptr )
{
   unsigned alloc_size = align( size, upload->alignment );
   unsigned alloc_offset = align(min_out_offset, upload->alignment);
   unsigned offset;
d164 3
a166 15
   /* Init these return values here in case we fail below to make
    * sure the caller doesn't get garbage values.
    */
   *out_offset = ~0;
   pipe_resource_reference(outbuf, NULL);
   *ptr = NULL;

   /* Make sure we have enough space in the upload buffer
    * for the sub-allocation. */
   if (MAX2(upload->offset, alloc_offset) + alloc_size > upload->size) {
      enum pipe_error ret = u_upload_alloc_buffer(upload,
                                                  alloc_offset + alloc_size);
      if (ret != PIPE_OK)
         return ret;
   }
d168 2
a169 25
   offset = MAX2(upload->offset, alloc_offset);

   if (!upload->map) {
      upload->map = pipe_buffer_map_range(upload->pipe, upload->buffer,
					  offset, upload->size - offset,
					  PIPE_TRANSFER_WRITE |
					  PIPE_TRANSFER_FLUSH_EXPLICIT |
					  PIPE_TRANSFER_UNSYNCHRONIZED,
					  &upload->transfer);
      if (!upload->map) {
         upload->transfer = NULL;
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      upload->map -= offset;
   }

   assert(offset < upload->buffer->width0);
   assert(offset + size <= upload->buffer->width0);
   assert(size);

   /* Emit the return values: */
   *ptr = upload->map + offset;
   pipe_resource_reference( outbuf, upload->buffer );
   *out_offset = offset;
a170 3
   upload->offset = offset + alloc_size;
   return PIPE_OK;
}
a172 1
                               unsigned min_out_offset,
d176 1
a176 1
                               struct pipe_resource **outbuf)
d178 18
a195 5
   uint8_t *ptr;
   enum pipe_error ret = u_upload_alloc(upload, min_out_offset, size,
                                        out_offset, outbuf,
                                        (void**)&ptr);
   if (ret != PIPE_OK)
d198 5
a202 1
   memcpy(ptr, data, size);
a212 1
                                 unsigned min_out_offset,
d217 1
a217 1
                                 struct pipe_resource **outbuf)
d223 4
a226 5
   map = (const char *)pipe_buffer_map_range(upload->pipe,
                                             inbuf,
                                             offset, size,
                                             PIPE_TRANSFER_READ,
                                             &transfer);
d229 2
a230 1
      return PIPE_ERROR_OUT_OF_MEMORY;
d236 1
a236 2
   ret = u_upload_data( upload,
                        min_out_offset,
d238 1
a238 1
                        map,
d240 7
a246 3
                        outbuf);

   pipe_buffer_unmap( upload->pipe, transfer );
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a46 2
   unsigned map_flags;     /* Bitmask of PIPE_TRANSFER_* flags. */
   boolean map_persistent; /* If persistent mappings are supported. */
d51 1
d70 1
a70 15

   upload->map_persistent =
      pipe->screen->get_param(pipe->screen,
                              PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT);

   if (upload->map_persistent) {
      upload->map_flags = PIPE_TRANSFER_WRITE |
                          PIPE_TRANSFER_PERSISTENT |
                          PIPE_TRANSFER_COHERENT;
   }
   else {
      upload->map_flags = PIPE_TRANSFER_WRITE |
                          PIPE_TRANSFER_UNSYNCHRONIZED |
                          PIPE_TRANSFER_FLUSH_EXPLICIT;
   }
d75 1
a75 2

static void upload_unmap_internal(struct u_upload_mgr *upload, boolean destroying)
a76 3
   if (!destroying && upload->map_persistent)
      return;

d79 1
a80 1
      if (!upload->map_persistent && (int) upload->offset > box->x) {
a83 1

d90 10
a99 8

void u_upload_unmap( struct u_upload_mgr *upload )
{
   upload_unmap_internal(upload, FALSE);
}


static void u_upload_release_buffer(struct u_upload_mgr *upload)
d102 1
a102 1
   upload_unmap_internal(upload, TRUE);
d104 1
d110 1
a110 1
   u_upload_release_buffer( upload );
a118 2
   struct pipe_screen *screen = upload->pipe->screen;
   struct pipe_resource buffer;
d123 1
a123 1
   u_upload_release_buffer( upload );
d129 4
a132 16
   memset(&buffer, 0, sizeof buffer);
   buffer.target = PIPE_BUFFER;
   buffer.format = PIPE_FORMAT_R8_UNORM; /* want TYPELESS or similar */
   buffer.bind = upload->bind;
   buffer.usage = PIPE_USAGE_STREAM;
   buffer.width0 = size;
   buffer.height0 = 1;
   buffer.depth0 = 1;
   buffer.array_size = 1;

   if (upload->map_persistent) {
      buffer.flags = PIPE_RESOURCE_FLAG_MAP_PERSISTENT |
                     PIPE_RESOURCE_FLAG_MAP_COHERENT;
   }

   upload->buffer = screen->resource_create(screen, &buffer);
d139 3
a141 1
                                       0, size, upload->map_flags,
d145 1
d150 1
d175 1
a175 2
   if (!upload->buffer ||
       MAX2(upload->offset, alloc_offset) + alloc_size > upload->buffer->width0) {
d186 4
a189 3
                                          offset,
                                          upload->buffer->width0 - offset,
                                          upload->map_flags,
@


