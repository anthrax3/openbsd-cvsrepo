head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.09.07.15.20.06;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.51;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.52;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.48;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.01.22;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.06.47;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.43.54;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


/**
 * Math utilities and approximations for common math functions.
 * Reduced precision is usually acceptable in shaders...
 *
 * "fast" is used in the names of functions which are low-precision,
 * or at least lower-precision than the normal C lib functions.
 */


#ifndef U_MATH_H
#define U_MATH_H


#include "pipe/p_compiler.h"


#ifdef __cplusplus
extern "C" {
#endif


#include <math.h>
#include <float.h>
#include <stdarg.h>

#ifdef PIPE_OS_UNIX
#include <strings.h> /* for ffs */
#endif


#ifndef M_SQRT2
#define M_SQRT2 1.41421356237309504880
#endif


#if defined(_MSC_VER) 

#if _MSC_VER < 1400 && !defined(__cplusplus)
 
static INLINE float cosf( float f ) 
{
   return (float) cos( (double) f );
}

static INLINE float sinf( float f ) 
{
   return (float) sin( (double) f );
}

static INLINE float ceilf( float f ) 
{
   return (float) ceil( (double) f );
}

static INLINE float floorf( float f ) 
{
   return (float) floor( (double) f );
}

static INLINE float powf( float f, float g ) 
{
   return (float) pow( (double) f, (double) g );
}

static INLINE float sqrtf( float f ) 
{
   return (float) sqrt( (double) f );
}

static INLINE float fabsf( float f ) 
{
   return (float) fabs( (double) f );
}

static INLINE float logf( float f ) 
{
   return (float) log( (double) f );
}

#else
/* Work-around an extra semi-colon in VS 2005 logf definition */
#ifdef logf
#undef logf
#define logf(x) ((float)log((double)(x)))
#endif /* logf */

#if _MSC_VER < 1800
#define isfinite(x) _finite((double)(x))
#define isnan(x) _isnan((double)(x))
#endif /* _MSC_VER < 1800 */
#endif /* _MSC_VER < 1400 && !defined(__cplusplus) */

#if _MSC_VER < 1800
static INLINE double log2( double x )
{
   const double invln2 = 1.442695041;
   return log( x ) * invln2;
}

static INLINE double
round(double x)
{
   return x >= 0.0 ? floor(x + 0.5) : ceil(x - 0.5);
}

static INLINE float
roundf(float x)
{
   return x >= 0.0f ? floorf(x + 0.5f) : ceilf(x - 0.5f);
}
#endif

#ifndef INFINITY
#define INFINITY (DBL_MAX + DBL_MAX)
#endif

#ifndef NAN
#define NAN (INFINITY - INFINITY)
#endif

#endif /* _MSC_VER */


#if __STDC_VERSION__ < 199901L && (!defined(__cplusplus) || defined(_MSC_VER))
static INLINE long int
lrint(double d)
{
   long int rounded = (long int)(d + 0.5);

   if (d - floor(d) == 0.5) {
      if (rounded % 2 != 0)
         rounded += (d > 0) ? -1 : 1;
   }

   return rounded;
}

static INLINE long int
lrintf(float f)
{
   long int rounded = (long int)(f + 0.5f);

   if (f - floorf(f) == 0.5f) {
      if (rounded % 2 != 0)
         rounded += (f > 0) ? -1 : 1;
   }

   return rounded;
}

static INLINE long long int
llrint(double d)
{
   long long int rounded = (long long int)(d + 0.5);

   if (d - floor(d) == 0.5) {
      if (rounded % 2 != 0)
         rounded += (d > 0) ? -1 : 1;
   }

   return rounded;
}

static INLINE long long int
llrintf(float f)
{
   long long int rounded = (long long int)(f + 0.5f);

   if (f - floorf(f) == 0.5f) {
      if (rounded % 2 != 0)
         rounded += (f > 0) ? -1 : 1;
   }

   return rounded;
}
#endif /* C99 */

#define POW2_TABLE_SIZE_LOG2 9
#define POW2_TABLE_SIZE (1 << POW2_TABLE_SIZE_LOG2)
#define POW2_TABLE_OFFSET (POW2_TABLE_SIZE/2)
#define POW2_TABLE_SCALE ((float)(POW2_TABLE_SIZE/2))
extern float pow2_table[POW2_TABLE_SIZE];


/**
 * Initialize math module.  This should be called before using any
 * other functions in this module.
 */
extern void
util_init_math(void);


union fi {
   float f;
   int32_t i;
   uint32_t ui;
};


union di {
   double d;
   int64_t i;
   uint64_t ui;
};


/**
 * Extract the IEEE float32 exponent.
 */
static INLINE signed
util_get_float32_exponent(float x) {
   union fi f;

   f.f = x;

   return ((f.ui >> 23) & 0xff) - 127;
}


/**
 * Fast version of 2^x
 * Identity: exp2(a + b) = exp2(a) * exp2(b)
 * Let ipart = int(x)
 * Let fpart = x - ipart;
 * So, exp2(x) = exp2(ipart) * exp2(fpart)
 * Compute exp2(ipart) with i << ipart
 * Compute exp2(fpart) with lookup table.
 */
static INLINE float
util_fast_exp2(float x)
{
   int32_t ipart;
   float fpart, mpart;
   union fi epart;

   if(x > 129.00000f)
      return 3.402823466e+38f;

   if (x < -126.99999f)
      return 0.0f;

   ipart = (int32_t) x;
   fpart = x - (float) ipart;

   /* same as
    *   epart.f = (float) (1 << ipart)
    * but faster and without integer overflow for ipart > 31
    */
   epart.i = (ipart + 127 ) << 23;

   mpart = pow2_table[POW2_TABLE_OFFSET + (int)(fpart * POW2_TABLE_SCALE)];

   return epart.f * mpart;
}


/**
 * Fast approximation to exp(x).
 */
static INLINE float
util_fast_exp(float x)
{
   const float k = 1.44269f; /* = log2(e) */
   return util_fast_exp2(k * x);
}


#define LOG2_TABLE_SIZE_LOG2 16
#define LOG2_TABLE_SCALE (1 << LOG2_TABLE_SIZE_LOG2)
#define LOG2_TABLE_SIZE (LOG2_TABLE_SCALE + 1)
extern float log2_table[LOG2_TABLE_SIZE];


/**
 * Fast approximation to log2(x).
 */
static INLINE float
util_fast_log2(float x)
{
   union fi num;
   float epart, mpart;
   num.f = x;
   epart = (float)(((num.i & 0x7f800000) >> 23) - 127);
   /* mpart = log2_table[mantissa*LOG2_TABLE_SCALE + 0.5] */
   mpart = log2_table[((num.i & 0x007fffff) + (1 << (22 - LOG2_TABLE_SIZE_LOG2))) >> (23 - LOG2_TABLE_SIZE_LOG2)];
   return epart + mpart;
}


/**
 * Fast approximation to x^y.
 */
static INLINE float
util_fast_pow(float x, float y)
{
   return util_fast_exp2(util_fast_log2(x) * y);
}

/* Note that this counts zero as a power of two.
 */
static INLINE boolean
util_is_power_of_two( unsigned v )
{
   return (v & (v-1)) == 0;
}


/**
 * Floor(x), returned as int.
 */
static INLINE int
util_ifloor(float f)
{
   int ai, bi;
   double af, bf;
   union fi u;
   af = (3 << 22) + 0.5 + (double) f;
   bf = (3 << 22) + 0.5 - (double) f;
   u.f = (float) af;  ai = u.i;
   u.f = (float) bf;  bi = u.i;
   return (ai - bi) >> 1;
}


/**
 * Round float to nearest int.
 */
static INLINE int
util_iround(float f)
{
#if defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86) 
   int r;
   __asm__ ("fistpl %0" : "=m" (r) : "t" (f) : "st");
   return r;
#elif defined(PIPE_CC_MSVC) && defined(PIPE_ARCH_X86)
   int r;
   _asm {
      fld f
      fistp r
   }
   return r;
#else
   if (f >= 0.0f)
      return (int) (f + 0.5f);
   else
      return (int) (f - 0.5f);
#endif
}


/**
 * Approximate floating point comparison
 */
static INLINE boolean
util_is_approx(float a, float b, float tol)
{
   return fabs(b - a) <= tol;
}


/**
 * util_is_X_inf_or_nan = test if x is NaN or +/- Inf
 * util_is_X_nan        = test if x is NaN
 * util_X_inf_sign      = return +1 for +Inf, -1 for -Inf, or 0 for not Inf
 *
 * NaN can be checked with x != x, however this fails with the fast math flag
 **/


/**
 * Single-float
 */
static INLINE boolean
util_is_inf_or_nan(float x)
{
   union fi tmp;
   tmp.f = x;
   return (tmp.ui & 0x7f800000) == 0x7f800000;
}


static INLINE boolean
util_is_nan(float x)
{
   union fi tmp;
   tmp.f = x;
   return (tmp.ui & 0x7fffffff) > 0x7f800000;
}


static INLINE int
util_inf_sign(float x)
{
   union fi tmp;
   tmp.f = x;
   if ((tmp.ui & 0x7fffffff) != 0x7f800000) {
      return 0;
   }

   return (x < 0) ? -1 : 1;
}


/**
 * Double-float
 */
static INLINE boolean
util_is_double_inf_or_nan(double x)
{
   union di tmp;
   tmp.d = x;
   return (tmp.ui & 0x7ff0000000000000ULL) == 0x7ff0000000000000ULL;
}


static INLINE boolean
util_is_double_nan(double x)
{
   union di tmp;
   tmp.d = x;
   return (tmp.ui & 0x7fffffffffffffffULL) > 0x7ff0000000000000ULL;
}


static INLINE int
util_double_inf_sign(double x)
{
   union di tmp;
   tmp.d = x;
   if ((tmp.ui & 0x7fffffffffffffffULL) != 0x7ff0000000000000ULL) {
      return 0;
   }

   return (x < 0) ? -1 : 1;
}


/**
 * Half-float
 */
static INLINE boolean
util_is_half_inf_or_nan(int16_t x)
{
   return (x & 0x7c00) == 0x7c00;
}


static INLINE boolean
util_is_half_nan(int16_t x)
{
   return (x & 0x7fff) > 0x7c00;
}


static INLINE int
util_half_inf_sign(int16_t x)
{
   if ((x & 0x7fff) != 0x7c00) {
      return 0;
   }

   return (x < 0) ? -1 : 1;
}


/**
 * Find first bit set in word.  Least significant bit is 1.
 * Return 0 if no bits set.
 */
#ifndef FFS_DEFINED
#define FFS_DEFINED 1

#if defined(_MSC_VER) && _MSC_VER >= 1300 && (_M_IX86 || _M_AMD64 || _M_IA64)
unsigned char _BitScanForward(unsigned long* Index, unsigned long Mask);
#pragma intrinsic(_BitScanForward)
static INLINE
unsigned long ffs( unsigned long u )
{
   unsigned long i;
   if (_BitScanForward(&i, u))
      return i + 1;
   else
      return 0;
}
#elif defined(PIPE_CC_MSVC) && defined(PIPE_ARCH_X86)
static INLINE
unsigned ffs( unsigned u )
{
   unsigned i;

   if (u == 0) {
      return 0;
   }

   __asm bsf eax, [u]
   __asm inc eax
   __asm mov [i], eax

   return i;
}
#elif defined(__MINGW32__) || defined(PIPE_OS_ANDROID)
#define ffs __builtin_ffs
#endif

#endif /* FFS_DEFINED */

/**
 * Find last bit set in a word.  The least significant bit is 1.
 * Return 0 if no bits are set.
 */
static INLINE unsigned util_last_bit(unsigned u)
{
#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 304)
   return u == 0 ? 0 : 32 - __builtin_clz(u);
#else
   unsigned r = 0;
   while (u) {
       r++;
       u >>= 1;
   }
   return r;
#endif
}

/**
 * Find last bit in a word that does not match the sign bit. The least
 * significant bit is 1.
 * Return 0 if no bits are set.
 */
static INLINE unsigned util_last_bit_signed(int i)
{
#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 407)
   return 31 - __builtin_clrsb(i);
#else
   if (i >= 0)
      return util_last_bit(i);
   else
      return util_last_bit(~(unsigned)i);
#endif
}

/* Destructively loop over all of the bits in a mask as in:
 *
 * while (mymask) {
 *   int i = u_bit_scan(&mymask);
 *   ... process element i
 * }
 * 
 */
static INLINE int u_bit_scan(unsigned *mask)
{
   int i = ffs(*mask) - 1;
   *mask &= ~(1 << i);
   return i;
}


/**
 * Return float bits.
 */
static INLINE unsigned
fui( float f )
{
   union fi fi;
   fi.f = f;
   return fi.ui;
}


/**
 * Convert ubyte to float in [0, 1].
 * XXX a 256-entry lookup table would be slightly faster.
 */
static INLINE float
ubyte_to_float(ubyte ub)
{
   return (float) ub * (1.0f / 255.0f);
}


/**
 * Convert float in [0,1] to ubyte in [0,255] with clamping.
 */
static INLINE ubyte
float_to_ubyte(float f)
{
   union fi tmp;

   tmp.f = f;
   if (tmp.i < 0) {
      return (ubyte) 0;
   }
   else if (tmp.i >= 0x3f800000 /* 1.0f */) {
      return (ubyte) 255;
   }
   else {
      tmp.f = tmp.f * (255.0f/256.0f) + 32768.0f;
      return (ubyte) tmp.i;
   }
}

static INLINE float
byte_to_float_tex(int8_t b)
{
   return (b == -128) ? -1.0F : b * 1.0F / 127.0F;
}

static INLINE int8_t
float_to_byte_tex(float f)
{
   return (int8_t) (127.0F * f);
}

/**
 * Calc log base 2
 */
static INLINE unsigned
util_logbase2(unsigned n)
{
#if defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 304)
   return ((sizeof(unsigned) * 8 - 1) - __builtin_clz(n | 1));
#else
   unsigned pos = 0;
   if (n >= 1<<16) { n >>= 16; pos += 16; }
   if (n >= 1<< 8) { n >>=  8; pos +=  8; }
   if (n >= 1<< 4) { n >>=  4; pos +=  4; }
   if (n >= 1<< 2) { n >>=  2; pos +=  2; }
   if (n >= 1<< 1) {           pos +=  1; }
   return pos;
#endif
}


/**
 * Returns the smallest power of two >= x
 */
static INLINE unsigned
util_next_power_of_two(unsigned x)
{
#if defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 304)
   if (x <= 1)
       return 1;

   return (1 << ((sizeof(unsigned) * 8) - __builtin_clz(x - 1)));
#else
   unsigned val = x;

   if (x <= 1)
      return 1;

   if (util_is_power_of_two(x))
      return x;

   val--;
   val = (val >> 1) | val;
   val = (val >> 2) | val;
   val = (val >> 4) | val;
   val = (val >> 8) | val;
   val = (val >> 16) | val;
   val++;
   return val;
#endif
}


/**
 * Return number of bits set in n.
 */
static INLINE unsigned
util_bitcount(unsigned n)
{
#if defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 304)
   return __builtin_popcount(n);
#else
   /* K&R classic bitcount.
    *
    * For each iteration, clear the LSB from the bitfield.
    * Requires only one iteration per set bit, instead of
    * one iteration per bit less than highest set bit.
    */
   unsigned bits = 0;
   for (bits; n; bits++) {
      n &= n - 1;
   }
   return bits;
#endif
}

/**
 * Reverse bits in n
 * Algorithm taken from:
 * http://stackoverflow.com/questions/9144800/c-reverse-bits-in-unsigned-integer
 */
static INLINE unsigned
util_bitreverse(unsigned n)
{
    n = ((n >> 1) & 0x55555555u) | ((n & 0x55555555u) << 1);
    n = ((n >> 2) & 0x33333333u) | ((n & 0x33333333u) << 2);
    n = ((n >> 4) & 0x0f0f0f0fu) | ((n & 0x0f0f0f0fu) << 4);
    n = ((n >> 8) & 0x00ff00ffu) | ((n & 0x00ff00ffu) << 8);
    n = ((n >> 16) & 0xffffu) | ((n & 0xffffu) << 16);
    return n;
}

/**
 * Convert from little endian to CPU byte order.
 */

#ifdef PIPE_ARCH_BIG_ENDIAN
#define util_le64_to_cpu(x) util_bswap64(x)
#define util_le32_to_cpu(x) util_bswap32(x)
#define util_le16_to_cpu(x) util_bswap16(x)
#else
#define util_le64_to_cpu(x) (x)
#define util_le32_to_cpu(x) (x)
#define util_le16_to_cpu(x) (x)
#endif

#define util_cpu_to_le64(x) util_le64_to_cpu(x)
#define util_cpu_to_le32(x) util_le32_to_cpu(x)
#define util_cpu_to_le16(x) util_le16_to_cpu(x)

/**
 * Reverse byte order of a 32 bit word.
 */
static INLINE uint32_t
util_bswap32(uint32_t n)
{
/* We need the gcc version checks for non-autoconf build system */
#if defined(HAVE___BUILTIN_BSWAP32) || (defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 403))
   return __builtin_bswap32(n);
#else
   return (n >> 24) |
          ((n >> 8) & 0x0000ff00) |
          ((n << 8) & 0x00ff0000) |
          (n << 24);
#endif
}

/**
 * Reverse byte order of a 64bit word.
 */
static INLINE uint64_t
util_bswap64(uint64_t n)
{
#if defined(HAVE___BUILTIN_BSWAP64)
   return __builtin_bswap64(n);
#else
   return ((uint64_t)util_bswap32(n) << 32) |
          util_bswap32((n >> 32));
#endif
}


/**
 * Reverse byte order of a 16 bit word.
 */
static INLINE uint16_t
util_bswap16(uint16_t n)
{
   return (n >> 8) |
          (n << 8);
}


/**
 * Clamp X to [MIN, MAX].
 * This is a macro to allow float, int, uint, etc. types.
 */
#define CLAMP( X, MIN, MAX )  ( (X)<(MIN) ? (MIN) : ((X)>(MAX) ? (MAX) : (X)) )

#define MIN2( A, B )   ( (A)<(B) ? (A) : (B) )
#define MAX2( A, B )   ( (A)>(B) ? (A) : (B) )

#define MIN3( A, B, C ) ((A) < (B) ? MIN2(A, C) : MIN2(B, C))
#define MAX3( A, B, C ) ((A) > (B) ? MAX2(A, C) : MAX2(B, C))

#define MIN4( A, B, C, D ) ((A) < (B) ? MIN3(A, C, D) : MIN3(B, C, D))
#define MAX4( A, B, C, D ) ((A) > (B) ? MAX3(A, C, D) : MAX3(B, C, D))


/**
 * Align a value, only works pot alignemnts.
 */
static INLINE int
align(int value, int alignment)
{
   return (value + alignment - 1) & ~(alignment - 1);
}

/**
 * Works like align but on npot alignments.
 */
static INLINE size_t
util_align_npot(size_t value, size_t alignment)
{
   if (value % alignment)
      return value + (alignment - (value % alignment));
   return value;
}

static INLINE unsigned
u_minify(unsigned value, unsigned levels)
{
    return MAX2(1, value >> levels);
}

#ifndef COPY_4V
#define COPY_4V( DST, SRC )         \
do {                                \
   (DST)[0] = (SRC)[0];             \
   (DST)[1] = (SRC)[1];             \
   (DST)[2] = (SRC)[2];             \
   (DST)[3] = (SRC)[3];             \
} while (0)
#endif


#ifndef COPY_4FV
#define COPY_4FV( DST, SRC )  COPY_4V(DST, SRC)
#endif


#ifndef ASSIGN_4V
#define ASSIGN_4V( DST, V0, V1, V2, V3 ) \
do {                                     \
   (DST)[0] = (V0);                      \
   (DST)[1] = (V1);                      \
   (DST)[2] = (V2);                      \
   (DST)[3] = (V3);                      \
} while (0)
#endif


static INLINE uint32_t util_unsigned_fixed(float value, unsigned frac_bits)
{
   return value < 0 ? 0 : (uint32_t)(value * (1<<frac_bits));
}

static INLINE int32_t util_signed_fixed(float value, unsigned frac_bits)
{
   return (int32_t)(value * (1<<frac_bits));
}

unsigned
util_fpstate_get(void);
unsigned
util_fpstate_set_denorms_to_zero(unsigned current_fpstate);
void
util_fpstate_set(unsigned fpstate);



#ifdef __cplusplus
}
#endif

#endif /* U_MATH_H */
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a42 1
#include "util/u_debug.h"
d64 1
a64 1
#if defined(_MSC_VER)
d67 2
a68 2

static INLINE float cosf( float f )
d73 1
a73 1
static INLINE float sinf( float f )
d78 1
a78 1
static INLINE float ceilf( float f )
d83 1
a83 1
static INLINE float floorf( float f )
d88 1
a88 1
static INLINE float powf( float f, float g )
d93 1
a93 1
static INLINE float sqrtf( float f )
d98 1
a98 1
static INLINE float fabsf( float f )
d103 1
a103 1
static INLINE float logf( float f )
d239 1
a239 2
util_get_float32_exponent(float x)
{
d539 1
a539 2
static INLINE unsigned
util_last_bit(unsigned u)
d558 1
a558 2
static INLINE unsigned
util_last_bit_signed(int i)
d560 1
a560 1
#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 407) && !defined(__INTEL_COMPILER)
d576 1
a576 1
 *
d578 1
a578 2
static INLINE int
u_bit_scan(unsigned *mask)
a596 8
static INLINE float
uif(uint32_t ui)
{
        union fi fi;
        fi.ui = ui;
        return fi.f;
}

a716 12

static INLINE unsigned
util_bitcount64(uint64_t n)
{
#ifdef HAVE___BUILTIN_POPCOUNTLL
   return __builtin_popcountll(n);
#else
   return util_bitcount(n) + util_bitcount(n >> 32);
#endif
}


d777 1
a777 1
   return ((uint64_t)util_bswap32((uint32_t)n) << 32) |
a792 17
static INLINE void*
util_memcpy_cpu_to_le32(void * restrict dest, const void * restrict src, size_t n)
{
#ifdef PIPE_ARCH_BIG_ENDIAN
   size_t i, e;
   assert(n % 4 == 0);

   for (i = 0, e = n / 4; i < e; i++) {
      uint32_t * restrict d = (uint32_t* restrict)dest;
      const uint32_t * restrict s = (const uint32_t* restrict)src;
      d[i] = util_bswap32(s[i]);
   }
   return dest;
#else
   return memcpy(dest, src, n);
#endif
}
d863 1
a863 2
static INLINE uint32_t
util_unsigned_fixed(float value, unsigned frac_bits)
d868 1
a868 2
static INLINE int32_t
util_signed_fixed(float value, unsigned frac_bits)
@


1.6
log
@Merge Mesa 10.2.7
@
text
@d43 1
d65 1
a65 1
#if defined(_MSC_VER) 
d68 2
a69 2
 
static INLINE float cosf( float f ) 
d74 1
a74 1
static INLINE float sinf( float f ) 
d79 1
a79 1
static INLINE float ceilf( float f ) 
d84 1
a84 1
static INLINE float floorf( float f ) 
d89 1
a89 1
static INLINE float powf( float f, float g ) 
d94 1
a94 1
static INLINE float sqrtf( float f ) 
d99 1
a99 1
static INLINE float fabsf( float f ) 
d104 1
a104 1
static INLINE float logf( float f ) 
d240 2
a241 1
util_get_float32_exponent(float x) {
d541 2
a542 1
static INLINE unsigned util_last_bit(unsigned u)
d561 2
a562 1
static INLINE unsigned util_last_bit_signed(int i)
d564 1
a564 1
#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 407)
d580 1
a580 1
 * 
d582 2
a583 1
static INLINE int u_bit_scan(unsigned *mask)
d602 8
d730 12
d802 1
a802 1
   return ((uint64_t)util_bswap32(n) << 32) |
d818 17
d905 2
a906 1
static INLINE uint32_t util_unsigned_fixed(float value, unsigned frac_bits)
d911 2
a912 1
static INLINE int32_t util_signed_fixed(float value, unsigned frac_bits)
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a151 22
#ifdef PIPE_OS_ANDROID

static INLINE
double log2(double d)
{
   return log(d) * (1.0 / M_LN2);
}

/* workaround a conflict with main/imports.h */
#ifdef log2f
#undef log2f
#endif

static INLINE
float log2f(float f)
{
   return logf(f) * (float) (1.0 / M_LN2);
}

#endif


@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d51 1
d115 1
d118 1
d121 1
d139 9
d174 31
d206 21
d258 13
d575 16
d739 15
d760 1
d764 1
d769 3
d779 2
a780 1
#if defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 403)
d787 14
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a42 1
#include "util/u_debug.h"
a49 65
#if defined(PIPE_SUBSYSTEM_WINDOWS_MINIPORT)
__inline double ceil(double val)
{
   double ceil_val;

   if ((val - (long) val) == 0) {
      ceil_val = val;
   }
   else {
      if (val > 0) {
         ceil_val = (long) val + 1;
      }
      else {
         ceil_val = (long) val;
      }
   }

   return ceil_val;
}

#ifndef PIPE_SUBSYSTEM_WINDOWS_CE_OGL
__inline double floor(double val)
{
   double floor_val;

   if ((val - (long) val) == 0) {
      floor_val = val;
   }
   else {
      if (val > 0) {
         floor_val = (long) val;
      }
      else {
         floor_val = (long) val - 1;
      }
   }

   return floor_val;
}
#endif

#pragma function(pow)
__inline double __cdecl pow(double val, double exponent)
{
   /* XXX */
   assert(0);
   return 0;
}

#pragma function(log)
__inline double __cdecl log(double val)
{
   /* XXX */
   assert(0);
   return 0;
}

#pragma function(atan2)
__inline double __cdecl atan2(double val)
{
   /* XXX */
   assert(0);
   return 0;
}
#else
d52 3
d65 1
a65 1
#if _MSC_VER < 1400 && !defined(__cplusplus) || defined(PIPE_SUBSYSTEM_WINDOWS_CE)
d139 21
d185 7
d334 10
a343 1
 * Test if x is NaN or +/- infinity.
d350 85
a434 1
   return !(int)((unsigned int)((tmp.i & 0x7fffffff)-0x7f800000) >> 31);
d442 3
d473 1
a473 1
#elif defined(__MINGW32__)
d477 36
a542 1
   const int ieee_0996 = 0x3f7f0000;   /* 0.996 or so */
d549 1
a549 1
   else if (tmp.i >= ieee_0996) {
d765 7
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d179 1
a179 1
#endif
d187 12
a415 16
#ifdef __MINGW32__
#define ffs __builtin_ffs
#endif


/* Could also binary search for the highest bit.
 */
static INLINE unsigned
util_unsigned_logbase2(unsigned n)
{
   unsigned log2 = 0;
   while (n >>= 1)
      ++log2;
   return log2;
}

d462 11
d480 11
a490 4
   unsigned log2 = 0;
   while (n >>= 1)
      ++log2;
   return log2;
d500 7
a506 1
   unsigned i;
d508 1
a508 1
   if (x == 0)
d511 2
a512 1
   --x;
d514 9
a522 4
   for (i = 1; i < sizeof(unsigned) * 8; i <<= 1)
      x |= x >> i;

   return x + 1;
d532 1
a532 1
#if defined(PIPE_CC_GCC)
d551 13
d600 2
a601 2
#define MIN3( A, B, C ) MIN2( MIN2( A, B ), C )
#define MAX3( A, B, C ) MAX2( MAX2( A, B ), C )
d603 2
a604 2
#define MIN4( A, B, C, D ) MIN2( MIN2( A, B ), MIN2(C, D) )
#define MAX4( A, B, C, D ) MAX2( MAX2( A, B ), MAX2(C, D) )
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d121 5
d176 3
a345 1

d347 1
a347 1
 * Test if x is NaN or +/- infinity.
d350 1
a350 1
util_is_inf_or_nan(float x)
d352 1
a352 3
   union fi tmp;
   tmp.f = x;
   return !(int)((unsigned int)((tmp.i & 0x7fffffff)-0x7f800000) >> 31);
d357 1
a357 1
 * Test whether x is a power of two.
d360 1
a360 1
util_is_pot(unsigned x)
d362 3
a364 1
   return (x & (x - 1)) == 0;
d564 2
d567 4
d575 11
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a120 5
#ifndef M_SQRT2
#define M_SQRT2 1.41421356237309504880
#endif


a170 3

#define isfinite(x) _finite((double)(x))
#define isnan(x) _isnan((double)(x))
d338 1
d340 1
a340 1
 * Approximate floating point comparison
d343 1
a343 1
util_is_approx(float a, float b, float tol)
d345 3
a347 1
   return fabs(b - a) <= tol;
d352 1
a352 1
 * Test if x is NaN or +/- infinity.
d355 1
a355 1
util_is_inf_or_nan(float x)
d357 1
a357 3
   union fi tmp;
   tmp.f = x;
   return !(int)((unsigned int)((tmp.i & 0x7fffffff)-0x7f800000) >> 31);
a556 2
#define MIN4( A, B, C, D ) MIN2( MIN2( A, B ), MIN2(C, D) )
#define MAX4( A, B, C, D ) MAX2( MAX2( A, B ), MAX2(C, D) )
a557 4

/**
 * Align a value, only works pot alignemnts.
 */
a561 11
}

/**
 * Works like align but on npot alignments.
 */
static INLINE size_t
util_align_npot(size_t value, size_t alignment)
{
   if (value % alignment)
      return value + (alignment - (value % alignment));
   return value;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d43 1
d51 65
a117 3

#ifdef PIPE_OS_UNIX
#include <strings.h> /* for ffs */
d128 1
a128 1
#if _MSC_VER < 1400 && !defined(__cplusplus)
d179 1
a179 1
#endif /* _MSC_VER < 1400 && !defined(__cplusplus) */
a186 12
static INLINE double
round(double x)
{
   return x >= 0.0 ? floor(x + 0.5) : ceil(x - 0.5);
}

static INLINE float
roundf(float x)
{
   return x >= 0.0f ? floorf(x + 0.5f) : ceilf(x - 0.5f);
}

a189 21
#ifdef PIPE_OS_ANDROID

static INLINE
double log2(double d)
{
   return log(d) * (1.0 / M_LN2);
}

/* workaround a conflict with main/imports.h */
#ifdef log2f
#undef log2f
#endif

static INLINE
float log2f(float f)
{
   return logf(f) * (float) (1.0 / M_LN2);
}

#endif

a214 7
union di {
   double d;
   int64_t i;
   uint64_t ui;
};


d357 1
a357 10
 * util_is_X_inf_or_nan = test if x is NaN or +/- Inf
 * util_is_X_nan        = test if x is NaN
 * util_X_inf_sign      = return +1 for +Inf, -1 for -Inf, or 0 for not Inf
 *
 * NaN can be checked with x != x, however this fails with the fast math flag
 **/


/**
 * Single-float
d364 1
a364 85
   return (tmp.ui & 0x7f800000) == 0x7f800000;
}


static INLINE boolean
util_is_nan(float x)
{
   union fi tmp;
   tmp.f = x;
   return (tmp.ui & 0x7fffffff) > 0x7f800000;
}


static INLINE int
util_inf_sign(float x)
{
   union fi tmp;
   tmp.f = x;
   if ((tmp.ui & 0x7fffffff) != 0x7f800000) {
      return 0;
   }

   return (x < 0) ? -1 : 1;
}


/**
 * Double-float
 */
static INLINE boolean
util_is_double_inf_or_nan(double x)
{
   union di tmp;
   tmp.d = x;
   return (tmp.ui & 0x7ff0000000000000ULL) == 0x7ff0000000000000ULL;
}


static INLINE boolean
util_is_double_nan(double x)
{
   union di tmp;
   tmp.d = x;
   return (tmp.ui & 0x7fffffffffffffffULL) > 0x7ff0000000000000ULL;
}


static INLINE int
util_double_inf_sign(double x)
{
   union di tmp;
   tmp.d = x;
   if ((tmp.ui & 0x7fffffffffffffffULL) != 0x7ff0000000000000ULL) {
      return 0;
   }

   return (x < 0) ? -1 : 1;
}


/**
 * Half-float
 */
static INLINE boolean
util_is_half_inf_or_nan(int16_t x)
{
   return (x & 0x7c00) == 0x7c00;
}


static INLINE boolean
util_is_half_nan(int16_t x)
{
   return (x & 0x7fff) > 0x7c00;
}


static INLINE int
util_half_inf_sign(int16_t x)
{
   if ((x & 0x7fff) != 0x7c00) {
      return 0;
   }

   return (x < 0) ? -1 : 1;
a371 3
#ifndef FFS_DEFINED
#define FFS_DEFINED 1

d400 1
a400 1
#elif defined(__MINGW32__) || defined(PIPE_OS_ANDROID)
d404 2
a405 17
#endif /* FFS_DEFINED */

/**
 * Find last bit set in a word.  The least significant bit is 1.
 * Return 0 if no bits are set.
 */
static INLINE unsigned util_last_bit(unsigned u)
{
#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 304)
   return u == 0 ? 0 : 32 - __builtin_clz(u);
#else
   unsigned r = 0;
   while (u) {
       r++;
       u >>= 1;
   }
   return r;
a406 1
}
d409 1
a409 7
/* Destructively loop over all of the bits in a mask as in:
 *
 * while (mymask) {
 *   int i = u_bit_scan(&mymask);
 *   ... process element i
 * }
 * 
d411 2
a412 1
static INLINE int u_bit_scan(unsigned *mask)
d414 4
a417 3
   int i = ffs(*mask) - 1;
   *mask &= ~(1 << i);
   return i;
d450 1
d457 1
a457 1
   else if (tmp.i >= 0x3f800000 /* 1.0f */) {
a465 11
static INLINE float
byte_to_float_tex(int8_t b)
{
   return (b == -128) ? -1.0F : b * 1.0F / 127.0F;
}

static INLINE int8_t
float_to_byte_tex(float f)
{
   return (int8_t) (127.0F * f);
}
d473 4
a476 11
#if defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 304)
   return ((sizeof(unsigned) * 8 - 1) - __builtin_clz(n | 1));
#else
   unsigned pos = 0;
   if (n >= 1<<16) { n >>= 16; pos += 16; }
   if (n >= 1<< 8) { n >>=  8; pos +=  8; }
   if (n >= 1<< 4) { n >>=  4; pos +=  4; }
   if (n >= 1<< 2) { n >>=  2; pos +=  2; }
   if (n >= 1<< 1) {           pos +=  1; }
   return pos;
#endif
d486 1
a486 3
#if defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 304)
   if (x <= 1)
       return 1;
d488 2
a489 3
   return (1 << ((sizeof(unsigned) * 8) - __builtin_clz(x - 1)));
#else
   unsigned val = x;
d491 1
a491 2
   if (x <= 1)
      return 1;
d493 2
a494 2
   if (util_is_power_of_two(x))
      return x;
d496 1
a496 9
   val--;
   val = (val >> 1) | val;
   val = (val >> 2) | val;
   val = (val >> 4) | val;
   val = (val >> 8) | val;
   val = (val >> 16) | val;
   val++;
   return val;
#endif
d506 1
a506 1
#if defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 304)
a524 13
 * Convert from little endian to CPU byte order.
 */

#ifdef PIPE_ARCH_BIG_ENDIAN
#define util_le32_to_cpu(x) util_bswap32(x)
#define util_le16_to_cpu(x) util_bswap16(x)
#else
#define util_le32_to_cpu(x) (x)
#define util_le16_to_cpu(x) (x)
#endif


/**
d561 2
a562 2
#define MIN3( A, B, C ) ((A) < (B) ? MIN2(A, C) : MIN2(B, C))
#define MAX3( A, B, C ) ((A) > (B) ? MAX2(A, C) : MAX2(B, C))
d564 2
a565 2
#define MIN4( A, B, C, D ) ((A) < (B) ? MIN3(A, C, D) : MIN3(B, C, D))
#define MAX4( A, B, C, D ) ((A) > (B) ? MAX3(A, C, D) : MAX3(B, C, D))
a629 7

unsigned
util_fpstate_get(void);
unsigned
util_fpstate_set_denorms_to_zero(unsigned current_fpstate);
void
util_fpstate_set(unsigned fpstate);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a50 1
#include <float.h>
a113 1
#if _MSC_VER < 1800
a115 1
#endif /* _MSC_VER < 1800 */
a117 1
#if _MSC_VER < 1800
a134 9
#endif

#ifndef INFINITY
#define INFINITY (DBL_MAX + DBL_MAX)
#endif

#ifndef NAN
#define NAN (INFINITY - INFINITY)
#endif
a160 31
#if __STDC_VERSION__ < 199901L && (!defined(__cplusplus) || defined(_MSC_VER))
static INLINE long int
lrint(double d)
{
   long int rounded = (long int)(d + 0.5);

   if (d - floor(d) == 0.5) {
      if (rounded % 2 != 0)
         rounded += (d > 0) ? -1 : 1;
   }

   return rounded;
}

static INLINE long int
lrintf(float f)
{
   long int rounded = (long int)(f + 0.5f);

   if (f - floorf(f) == 0.5f) {
      if (rounded % 2 != 0)
         rounded += (f > 0) ? -1 : 1;
   }

   return rounded;
}

static INLINE long long int
llrint(double d)
{
   long long int rounded = (long long int)(d + 0.5);
a161 21
   if (d - floor(d) == 0.5) {
      if (rounded % 2 != 0)
         rounded += (d > 0) ? -1 : 1;
   }

   return rounded;
}

static INLINE long long int
llrintf(float f)
{
   long long int rounded = (long long int)(f + 0.5f);

   if (f - floorf(f) == 0.5f) {
      if (rounded % 2 != 0)
         rounded += (f > 0) ? -1 : 1;
   }

   return rounded;
}
#endif /* C99 */
a192 13
 * Extract the IEEE float32 exponent.
 */
static INLINE signed
util_get_float32_exponent(float x) {
   union fi f;

   f.f = x;

   return ((f.ui >> 23) & 0xff) - 127;
}


/**
a496 16
/**
 * Find last bit in a word that does not match the sign bit. The least
 * significant bit is 1.
 * Return 0 if no bits are set.
 */
static INLINE unsigned util_last_bit_signed(int i)
{
#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 407)
   return 31 - __builtin_clrsb(i);
#else
   if (i >= 0)
      return util_last_bit(i);
   else
      return util_last_bit(~(unsigned)i);
#endif
}
a644 15
/**
 * Reverse bits in n
 * Algorithm taken from:
 * http://stackoverflow.com/questions/9144800/c-reverse-bits-in-unsigned-integer
 */
static INLINE unsigned
util_bitreverse(unsigned n)
{
    n = ((n >> 1) & 0x55555555u) | ((n & 0x55555555u) << 1);
    n = ((n >> 2) & 0x33333333u) | ((n & 0x33333333u) << 2);
    n = ((n >> 4) & 0x0f0f0f0fu) | ((n & 0x0f0f0f0fu) << 4);
    n = ((n >> 8) & 0x00ff00ffu) | ((n & 0x00ff00ffu) << 8);
    n = ((n >> 16) & 0xffffu) | ((n & 0xffffu) << 16);
    return n;
}
a650 1
#define util_le64_to_cpu(x) util_bswap64(x)
a653 1
#define util_le64_to_cpu(x) (x)
a657 3
#define util_cpu_to_le64(x) util_le64_to_cpu(x)
#define util_cpu_to_le32(x) util_le32_to_cpu(x)
#define util_cpu_to_le16(x) util_le16_to_cpu(x)
d665 1
a665 2
/* We need the gcc version checks for non-autoconf build system */
#if defined(HAVE___BUILTIN_BSWAP32) || (defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 403))
a671 14
#endif
}

/**
 * Reverse byte order of a 64bit word.
 */
static INLINE uint64_t
util_bswap64(uint64_t n)
{
#if defined(HAVE___BUILTIN_BSWAP64)
   return __builtin_bswap64(n);
#else
   return ((uint64_t)util_bswap32(n) << 32) |
          util_bswap32((n >> 32));
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@d152 22
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a42 1
#include "util/u_debug.h"
d64 1
a64 1
#if defined(_MSC_VER)
d67 2
a68 2

static INLINE float cosf( float f )
d73 1
a73 1
static INLINE float sinf( float f )
d78 1
a78 1
static INLINE float ceilf( float f )
d83 1
a83 1
static INLINE float floorf( float f )
d88 1
a88 1
static INLINE float powf( float f, float g )
d93 1
a93 1
static INLINE float sqrtf( float f )
d98 1
a98 1
static INLINE float fabsf( float f )
d103 1
a103 1
static INLINE float logf( float f )
d239 1
a239 2
util_get_float32_exponent(float x)
{
d539 1
a539 2
static INLINE unsigned
util_last_bit(unsigned u)
d558 1
a558 2
static INLINE unsigned
util_last_bit_signed(int i)
d560 1
a560 1
#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 407) && !defined(__INTEL_COMPILER)
d576 1
a576 1
 *
d578 1
a578 2
static INLINE int
u_bit_scan(unsigned *mask)
a596 8
static INLINE float
uif(uint32_t ui)
{
        union fi fi;
        fi.ui = ui;
        return fi.f;
}

a716 12

static INLINE unsigned
util_bitcount64(uint64_t n)
{
#ifdef HAVE___BUILTIN_POPCOUNTLL
   return __builtin_popcountll(n);
#else
   return util_bitcount(n) + util_bitcount(n >> 32);
#endif
}


d777 1
a777 1
   return ((uint64_t)util_bswap32((uint32_t)n) << 32) |
a792 17
static INLINE void*
util_memcpy_cpu_to_le32(void * restrict dest, const void * restrict src, size_t n)
{
#ifdef PIPE_ARCH_BIG_ENDIAN
   size_t i, e;
   assert(n % 4 == 0);

   for (i = 0, e = n / 4; i < e; i++) {
      uint32_t * restrict d = (uint32_t* restrict)dest;
      const uint32_t * restrict s = (const uint32_t* restrict)src;
      d[i] = util_bswap32(s[i]);
   }
   return dest;
#else
   return memcpy(dest, src, n);
#endif
}
d863 1
a863 2
static INLINE uint32_t
util_unsigned_fixed(float value, unsigned frac_bits)
d868 1
a868 2
static INLINE int32_t
util_signed_fixed(float value, unsigned frac_bits)
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d43 1
d65 1
a65 1
#if defined(_MSC_VER) 
d68 2
a69 2
 
static INLINE float cosf( float f ) 
d74 1
a74 1
static INLINE float sinf( float f ) 
d79 1
a79 1
static INLINE float ceilf( float f ) 
d84 1
a84 1
static INLINE float floorf( float f ) 
d89 1
a89 1
static INLINE float powf( float f, float g ) 
d94 1
a94 1
static INLINE float sqrtf( float f ) 
d99 1
a99 1
static INLINE float fabsf( float f ) 
d104 1
a104 1
static INLINE float logf( float f ) 
d240 2
a241 1
util_get_float32_exponent(float x) {
d541 2
a542 1
static INLINE unsigned util_last_bit(unsigned u)
d561 2
a562 1
static INLINE unsigned util_last_bit_signed(int i)
d564 1
a564 1
#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 407)
d580 1
a580 1
 * 
d582 2
a583 1
static INLINE int u_bit_scan(unsigned *mask)
d602 8
d730 12
d802 1
a802 1
   return ((uint64_t)util_bswap32(n) << 32) |
d818 17
d905 2
a906 1
static INLINE uint32_t util_unsigned_fixed(float value, unsigned frac_bits)
d911 2
a912 1
static INLINE int32_t util_signed_fixed(float value, unsigned frac_bits)
@


