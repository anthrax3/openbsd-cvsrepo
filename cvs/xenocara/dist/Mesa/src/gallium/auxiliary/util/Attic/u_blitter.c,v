head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.27;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.09.07.15.20.06;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.47;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.45;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.47;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.01.12;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.06.38;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.43.46;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 Marek Ol코치k <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * @@file
 * Blitter utility to facilitate acceleration of the clear, clear_render_target,
 * clear_depth_stencil, resource_copy_region, and blit functions.
 *
 * @@author Marek Ol코치k
 */

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "pipe/p_shader_tokens.h"
#include "pipe/p_state.h"

#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_blitter.h"
#include "util/u_draw_quad.h"
#include "util/u_sampler.h"
#include "util/u_simple_shaders.h"
#include "util/u_surface.h"
#include "util/u_texture.h"
#include "util/u_upload_mgr.h"

#define INVALID_PTR ((void*)~0)

#define GET_CLEAR_BLEND_STATE_IDX(clear_buffers) \
   ((clear_buffers) / PIPE_CLEAR_COLOR0)

#define NUM_RESOLVE_FRAG_SHADERS 5 /* MSAA 2x, 4x, 8x, 16x, 32x */
#define GET_MSAA_RESOLVE_FS_IDX(nr_samples) (util_logbase2(nr_samples)-1)

struct blitter_context_priv
{
   struct blitter_context base;

   struct u_upload_mgr *upload;

   float vertices[4][2][4];   /**< {pos, color} or {pos, texcoord} */

   /* Templates for various state objects. */

   /* Constant state objects. */
   /* Vertex shaders. */
   void *vs; /**< Vertex shader which passes {pos, generic} to the output.*/
   void *vs_pos_only; /**< Vertex shader which passes pos to the output.*/
   void *vs_layered; /**< Vertex shader which sets LAYER = INSTANCEID. */

   /* Fragment shaders. */
   void *fs_empty;
   void *fs_write_one_cbuf;
   void *fs_write_all_cbufs;

   /* FS which outputs a color from a texture,
      where the index is PIPE_TEXTURE_* to be sampled. */
   void *fs_texfetch_col[PIPE_MAX_TEXTURE_TYPES];

   /* FS which outputs a depth from a texture,
      where the index is PIPE_TEXTURE_* to be sampled. */
   void *fs_texfetch_depth[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_depthstencil[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_stencil[PIPE_MAX_TEXTURE_TYPES];

   /* FS which outputs one sample from a multisample texture. */
   void *fs_texfetch_col_msaa[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_depth_msaa[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_depthstencil_msaa[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_stencil_msaa[PIPE_MAX_TEXTURE_TYPES];

   /* FS which outputs an average of all samples. */
   void *fs_resolve[PIPE_MAX_TEXTURE_TYPES][NUM_RESOLVE_FRAG_SHADERS][2];
   void *fs_resolve_sint[PIPE_MAX_TEXTURE_TYPES][NUM_RESOLVE_FRAG_SHADERS][2];
   void *fs_resolve_uint[PIPE_MAX_TEXTURE_TYPES][NUM_RESOLVE_FRAG_SHADERS][2];

   /* Blend state. */
   void *blend[PIPE_MASK_RGBA+1]; /**< blend state with writemask */
   void *blend_clear[GET_CLEAR_BLEND_STATE_IDX(PIPE_CLEAR_COLOR)+1];

   /* Depth stencil alpha state. */
   void *dsa_write_depth_stencil;
   void *dsa_write_depth_keep_stencil;
   void *dsa_keep_depth_stencil;
   void *dsa_keep_depth_write_stencil;

   /* Vertex elements states. */
   void *velem_state;
   void *velem_state_readbuf[4]; /**< X, XY, XYZ, XYZW */

   /* Sampler state. */
   void *sampler_state;
   void *sampler_state_linear;
   void *sampler_state_rect;
   void *sampler_state_rect_linear;

   /* Rasterizer state. */
   void *rs_state, *rs_state_scissor, *rs_discard_state;

   /* Viewport state. */
   struct pipe_viewport_state viewport;

   /* Destination surface dimensions. */
   unsigned dst_width;
   unsigned dst_height;

   boolean has_geometry_shader;
   boolean has_stream_out;
   boolean has_stencil_export;
   boolean has_texture_multisample;

   /* The Draw module overrides these functions.
    * Always create the blitter before Draw. */
   void   (*bind_fs_state)(struct pipe_context *, void *);
   void   (*delete_fs_state)(struct pipe_context *, void *);
};

static struct pipe_surface *
util_blitter_get_next_surface_layer(struct pipe_context *pipe,
                                    struct pipe_surface *surf);

struct blitter_context *util_blitter_create(struct pipe_context *pipe)
{
   struct blitter_context_priv *ctx;
   struct pipe_blend_state blend;
   struct pipe_depth_stencil_alpha_state dsa;
   struct pipe_rasterizer_state rs_state;
   struct pipe_sampler_state sampler_state;
   struct pipe_vertex_element velem[2];
   unsigned i;

   ctx = CALLOC_STRUCT(blitter_context_priv);
   if (!ctx)
      return NULL;

   ctx->base.pipe = pipe;
   ctx->base.draw_rectangle = util_blitter_draw_rectangle;
   ctx->base.get_next_surface_layer = util_blitter_get_next_surface_layer;

   ctx->bind_fs_state = pipe->bind_fs_state;
   ctx->delete_fs_state = pipe->delete_fs_state;

   /* init state objects for them to be considered invalid */
   ctx->base.saved_blend_state = INVALID_PTR;
   ctx->base.saved_dsa_state = INVALID_PTR;
   ctx->base.saved_rs_state = INVALID_PTR;
   ctx->base.saved_fs = INVALID_PTR;
   ctx->base.saved_vs = INVALID_PTR;
   ctx->base.saved_gs = INVALID_PTR;
   ctx->base.saved_velem_state = INVALID_PTR;
   ctx->base.saved_fb_state.nr_cbufs = ~0;
   ctx->base.saved_num_sampler_views = ~0;
   ctx->base.saved_num_sampler_states = ~0;
   ctx->base.saved_num_so_targets = ~0;

   ctx->has_geometry_shader =
      pipe->screen->get_shader_param(pipe->screen, PIPE_SHADER_GEOMETRY,
                                     PIPE_SHADER_CAP_MAX_INSTRUCTIONS) > 0;
   ctx->has_stream_out =
      pipe->screen->get_param(pipe->screen,
                              PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS) != 0;

   ctx->has_stencil_export =
         pipe->screen->get_param(pipe->screen,
                                 PIPE_CAP_SHADER_STENCIL_EXPORT);

   ctx->has_texture_multisample =
      pipe->screen->get_param(pipe->screen, PIPE_CAP_TEXTURE_MULTISAMPLE);

   /* blend state objects */
   memset(&blend, 0, sizeof(blend));

   for (i = 0; i <= PIPE_MASK_RGBA; i++) {
      blend.rt[0].colormask = i;
      ctx->blend[i] = pipe->create_blend_state(pipe, &blend);
   }

   /* depth stencil alpha state objects */
   memset(&dsa, 0, sizeof(dsa));
   ctx->dsa_keep_depth_stencil =
      pipe->create_depth_stencil_alpha_state(pipe, &dsa);

   dsa.depth.enabled = 1;
   dsa.depth.writemask = 1;
   dsa.depth.func = PIPE_FUNC_ALWAYS;
   ctx->dsa_write_depth_keep_stencil =
      pipe->create_depth_stencil_alpha_state(pipe, &dsa);

   dsa.stencil[0].enabled = 1;
   dsa.stencil[0].func = PIPE_FUNC_ALWAYS;
   dsa.stencil[0].fail_op = PIPE_STENCIL_OP_REPLACE;
   dsa.stencil[0].zpass_op = PIPE_STENCIL_OP_REPLACE;
   dsa.stencil[0].zfail_op = PIPE_STENCIL_OP_REPLACE;
   dsa.stencil[0].valuemask = 0xff;
   dsa.stencil[0].writemask = 0xff;
   ctx->dsa_write_depth_stencil =
      pipe->create_depth_stencil_alpha_state(pipe, &dsa);

   dsa.depth.enabled = 0;
   dsa.depth.writemask = 0;
   ctx->dsa_keep_depth_write_stencil =
      pipe->create_depth_stencil_alpha_state(pipe, &dsa);

   /* sampler state */
   memset(&sampler_state, 0, sizeof(sampler_state));
   sampler_state.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state.normalized_coords = 1;
   ctx->sampler_state = pipe->create_sampler_state(pipe, &sampler_state);
   sampler_state.normalized_coords = 0;
   ctx->sampler_state_rect = pipe->create_sampler_state(pipe, &sampler_state);

   sampler_state.min_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler_state.mag_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler_state.normalized_coords = 1;
   ctx->sampler_state_linear = pipe->create_sampler_state(pipe, &sampler_state);
   sampler_state.normalized_coords = 0;
   ctx->sampler_state_rect_linear = pipe->create_sampler_state(pipe, &sampler_state);

   /* rasterizer state */
   memset(&rs_state, 0, sizeof(rs_state));
   rs_state.cull_face = PIPE_FACE_NONE;
   rs_state.half_pixel_center = 1;
   rs_state.bottom_edge_rule = 1;
   rs_state.flatshade = 1;
   rs_state.depth_clip = 1;
   ctx->rs_state = pipe->create_rasterizer_state(pipe, &rs_state);

   rs_state.scissor = 1;
   ctx->rs_state_scissor = pipe->create_rasterizer_state(pipe, &rs_state);

   if (ctx->has_stream_out) {
      rs_state.scissor = 0;
      rs_state.rasterizer_discard = 1;
      ctx->rs_discard_state = pipe->create_rasterizer_state(pipe, &rs_state);
   }

   ctx->base.vb_slot = 0; /* 0 for now */

   /* vertex elements states */
   memset(&velem[0], 0, sizeof(velem[0]) * 2);
   for (i = 0; i < 2; i++) {
      velem[i].src_offset = i * 4 * sizeof(float);
      velem[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
      velem[i].vertex_buffer_index = ctx->base.vb_slot;
   }
   ctx->velem_state = pipe->create_vertex_elements_state(pipe, 2, &velem[0]);

   if (ctx->has_stream_out) {
      static enum pipe_format formats[4] = {
         PIPE_FORMAT_R32_UINT,
         PIPE_FORMAT_R32G32_UINT,
         PIPE_FORMAT_R32G32B32_UINT,
         PIPE_FORMAT_R32G32B32A32_UINT
      };

      for (i = 0; i < 4; i++) {
         velem[0].src_format = formats[i];
         velem[0].vertex_buffer_index = ctx->base.vb_slot;
         ctx->velem_state_readbuf[i] =
               pipe->create_vertex_elements_state(pipe, 1, &velem[0]);
      }
   }

   /* Fragment shaders are created on-demand, except these.
    * The interpolation must be constant for integer texture clearing to work.
    */
   ctx->fs_empty = util_make_empty_fragment_shader(pipe);
   ctx->fs_write_one_cbuf =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, FALSE);
   ctx->fs_write_all_cbufs =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, TRUE);

   /* vertex shaders */
   {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indices[] = { 0, 0 };
      ctx->vs =
         util_make_vertex_passthrough_shader(pipe, 2, semantic_names,
                                             semantic_indices);
   }

   if (ctx->has_stream_out) {
      struct pipe_stream_output_info so;
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION };
      const uint semantic_indices[] = { 0 };

      memset(&so, 0, sizeof(so));
      so.num_outputs = 1;
      so.output[0].num_components = 1;
      so.stride[0] = 1;

      ctx->vs_pos_only =
         util_make_vertex_passthrough_shader_with_so(pipe, 1, semantic_names,
                                                     semantic_indices, &so);
   }

   if (pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_INSTANCEID) &&
       pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_VS_LAYER)) {
      ctx->vs_layered = util_make_layered_clear_vertex_shader(pipe);
   }

   /* set invariant vertex coordinates */
   for (i = 0; i < 4; i++)
      ctx->vertices[i][0][3] = 1; /*v.w*/

   ctx->upload = u_upload_create(pipe, 65536, 4, PIPE_BIND_VERTEX_BUFFER);

   return &ctx->base;
}

void util_blitter_destroy(struct blitter_context *blitter)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = blitter->pipe;
   int i, j, f;

   for (i = 0; i <= PIPE_MASK_RGBA; i++) {
      pipe->delete_blend_state(pipe, ctx->blend[i]);
   }
   for (i = 0; i < Elements(ctx->blend_clear); i++) {
      if (ctx->blend_clear[i])
         pipe->delete_blend_state(pipe, ctx->blend_clear[i]);
   }
   pipe->delete_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
   pipe->delete_depth_stencil_alpha_state(pipe,
                                          ctx->dsa_write_depth_keep_stencil);
   pipe->delete_depth_stencil_alpha_state(pipe, ctx->dsa_write_depth_stencil);
   pipe->delete_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_write_stencil);

   pipe->delete_rasterizer_state(pipe, ctx->rs_state);
   pipe->delete_rasterizer_state(pipe, ctx->rs_state_scissor);
   if (ctx->rs_discard_state)
      pipe->delete_rasterizer_state(pipe, ctx->rs_discard_state);
   pipe->delete_vs_state(pipe, ctx->vs);
   if (ctx->vs_pos_only)
      pipe->delete_vs_state(pipe, ctx->vs_pos_only);
   if (ctx->vs_layered)
      pipe->delete_vs_state(pipe, ctx->vs_layered);
   pipe->delete_vertex_elements_state(pipe, ctx->velem_state);
   for (i = 0; i < 4; i++) {
      if (ctx->velem_state_readbuf[i]) {
         pipe->delete_vertex_elements_state(pipe, ctx->velem_state_readbuf[i]);
      }
   }

   for (i = 0; i < PIPE_MAX_TEXTURE_TYPES; i++) {
      if (ctx->fs_texfetch_col[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_col[i]);
      if (ctx->fs_texfetch_depth[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_depth[i]);
      if (ctx->fs_texfetch_depthstencil[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_depthstencil[i]);
      if (ctx->fs_texfetch_stencil[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_stencil[i]);

      if (ctx->fs_texfetch_col_msaa[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_col_msaa[i]);
      if (ctx->fs_texfetch_depth_msaa[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_depth_msaa[i]);
      if (ctx->fs_texfetch_depthstencil_msaa[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_depthstencil_msaa[i]);
      if (ctx->fs_texfetch_stencil_msaa[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_stencil_msaa[i]);

      for (j = 0; j< Elements(ctx->fs_resolve[i]); j++)
         for (f = 0; f < 2; f++)
            if (ctx->fs_resolve[i][j][f])
               ctx->delete_fs_state(pipe, ctx->fs_resolve[i][j][f]);

      for (j = 0; j< Elements(ctx->fs_resolve_sint[i]); j++)
         for (f = 0; f < 2; f++)
            if (ctx->fs_resolve_sint[i][j][f])
               ctx->delete_fs_state(pipe, ctx->fs_resolve_sint[i][j][f]);

      for (j = 0; j< Elements(ctx->fs_resolve_uint[i]); j++)
         for (f = 0; f < 2; f++)
            if (ctx->fs_resolve_uint[i][j][f])
               ctx->delete_fs_state(pipe, ctx->fs_resolve_uint[i][j][f]);
   }

   ctx->delete_fs_state(pipe, ctx->fs_empty);
   ctx->delete_fs_state(pipe, ctx->fs_write_one_cbuf);
   ctx->delete_fs_state(pipe, ctx->fs_write_all_cbufs);

   pipe->delete_sampler_state(pipe, ctx->sampler_state_rect_linear);
   pipe->delete_sampler_state(pipe, ctx->sampler_state_rect);
   pipe->delete_sampler_state(pipe, ctx->sampler_state_linear);
   pipe->delete_sampler_state(pipe, ctx->sampler_state);
   u_upload_destroy(ctx->upload);
   FREE(ctx);
}

void util_blitter_set_texture_multisample(struct blitter_context *blitter,
                                          boolean supported)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;

   ctx->has_texture_multisample = supported;
}

static void blitter_set_running_flag(struct blitter_context_priv *ctx)
{
   if (ctx->base.running) {
      _debug_printf("u_blitter:%i: Caught recursion. This is a driver bug.\n",
                    __LINE__);
   }
   ctx->base.running = TRUE;
}

static void blitter_unset_running_flag(struct blitter_context_priv *ctx)
{
   if (!ctx->base.running) {
      _debug_printf("u_blitter:%i: Caught recursion. This is a driver bug.\n",
                    __LINE__);
   }
   ctx->base.running = FALSE;
}

static void blitter_check_saved_vertex_states(struct blitter_context_priv *ctx)
{
   assert(ctx->base.saved_velem_state != INVALID_PTR);
   assert(ctx->base.saved_vs != INVALID_PTR);
   assert(!ctx->has_geometry_shader || ctx->base.saved_gs != INVALID_PTR);
   assert(!ctx->has_stream_out || ctx->base.saved_num_so_targets != ~0);
   assert(ctx->base.saved_rs_state != INVALID_PTR);
}

static void blitter_restore_vertex_states(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;
   unsigned i;

   /* Vertex buffer. */
   pipe->set_vertex_buffers(pipe, ctx->base.vb_slot, 1,
                            &ctx->base.saved_vertex_buffer);
   pipe_resource_reference(&ctx->base.saved_vertex_buffer.buffer, NULL);

   /* Vertex elements. */
   pipe->bind_vertex_elements_state(pipe, ctx->base.saved_velem_state);
   ctx->base.saved_velem_state = INVALID_PTR;

   /* Vertex shader. */
   pipe->bind_vs_state(pipe, ctx->base.saved_vs);
   ctx->base.saved_vs = INVALID_PTR;

   /* Geometry shader. */
   if (ctx->has_geometry_shader) {
      pipe->bind_gs_state(pipe, ctx->base.saved_gs);
      ctx->base.saved_gs = INVALID_PTR;
   }

   /* Stream outputs. */
   if (ctx->has_stream_out) {
      unsigned offsets[PIPE_MAX_SO_BUFFERS];
      for (i = 0; i < ctx->base.saved_num_so_targets; i++)
         offsets[i] = (unsigned)-1;
      pipe->set_stream_output_targets(pipe,
                                      ctx->base.saved_num_so_targets,
                                      ctx->base.saved_so_targets, offsets);

      for (i = 0; i < ctx->base.saved_num_so_targets; i++)
         pipe_so_target_reference(&ctx->base.saved_so_targets[i], NULL);

      ctx->base.saved_num_so_targets = ~0;
   }

   /* Rasterizer. */
   pipe->bind_rasterizer_state(pipe, ctx->base.saved_rs_state);
   ctx->base.saved_rs_state = INVALID_PTR;
}

static void blitter_check_saved_fragment_states(struct blitter_context_priv *ctx)
{
   assert(ctx->base.saved_fs != INVALID_PTR);
   assert(ctx->base.saved_dsa_state != INVALID_PTR);
   assert(ctx->base.saved_blend_state != INVALID_PTR);
}

static void blitter_restore_fragment_states(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   /* Fragment shader. */
   ctx->bind_fs_state(pipe, ctx->base.saved_fs);
   ctx->base.saved_fs = INVALID_PTR;

   /* Depth, stencil, alpha. */
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->base.saved_dsa_state);
   ctx->base.saved_dsa_state = INVALID_PTR;

   /* Blend state. */
   pipe->bind_blend_state(pipe, ctx->base.saved_blend_state);
   ctx->base.saved_blend_state = INVALID_PTR;

   /* Sample mask. */
   if (ctx->base.is_sample_mask_saved) {
      pipe->set_sample_mask(pipe, ctx->base.saved_sample_mask);
      ctx->base.is_sample_mask_saved = FALSE;
   }

   /* Miscellaneous states. */
   /* XXX check whether these are saved and whether they need to be restored
    * (depending on the operation) */
   pipe->set_stencil_ref(pipe, &ctx->base.saved_stencil_ref);
   pipe->set_viewport_states(pipe, 0, 1, &ctx->base.saved_viewport);
}

static void blitter_check_saved_fb_state(struct blitter_context_priv *ctx)
{
   assert(ctx->base.saved_fb_state.nr_cbufs != ~0);
}

static void blitter_disable_render_cond(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (ctx->base.saved_render_cond_query) {
      pipe->render_condition(pipe, NULL, FALSE, 0);
   }
}

static void blitter_restore_render_cond(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (ctx->base.saved_render_cond_query) {
      pipe->render_condition(pipe, ctx->base.saved_render_cond_query,
                             ctx->base.saved_render_cond_cond,
                             ctx->base.saved_render_cond_mode);
      ctx->base.saved_render_cond_query = NULL;
   }
}

static void blitter_restore_fb_state(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   pipe->set_framebuffer_state(pipe, &ctx->base.saved_fb_state);
   util_unreference_framebuffer_state(&ctx->base.saved_fb_state);
}

static void blitter_check_saved_textures(struct blitter_context_priv *ctx)
{
   assert(ctx->base.saved_num_sampler_states != ~0);
   assert(ctx->base.saved_num_sampler_views != ~0);
}

static void blitter_restore_textures(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;
   unsigned i;

   /* Fragment sampler states. */
   pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
                             ctx->base.saved_num_sampler_states,
                             ctx->base.saved_sampler_states);

   ctx->base.saved_num_sampler_states = ~0;

   /* Fragment sampler views. */
   pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0,
                           ctx->base.saved_num_sampler_views,
                           ctx->base.saved_sampler_views);

   for (i = 0; i < ctx->base.saved_num_sampler_views; i++)
      pipe_sampler_view_reference(&ctx->base.saved_sampler_views[i], NULL);

   ctx->base.saved_num_sampler_views = ~0;
}

static void blitter_set_rectangle(struct blitter_context_priv *ctx,
                                  int x1, int y1, int x2, int y2,
                                  float depth)
{
   int i;

   /* set vertex positions */
   ctx->vertices[0][0][0] = (float)x1 / ctx->dst_width * 2.0f - 1.0f; /*v0.x*/
   ctx->vertices[0][0][1] = (float)y1 / ctx->dst_height * 2.0f - 1.0f; /*v0.y*/

   ctx->vertices[1][0][0] = (float)x2 / ctx->dst_width * 2.0f - 1.0f; /*v1.x*/
   ctx->vertices[1][0][1] = (float)y1 / ctx->dst_height * 2.0f - 1.0f; /*v1.y*/

   ctx->vertices[2][0][0] = (float)x2 / ctx->dst_width * 2.0f - 1.0f; /*v2.x*/
   ctx->vertices[2][0][1] = (float)y2 / ctx->dst_height * 2.0f - 1.0f; /*v2.y*/

   ctx->vertices[3][0][0] = (float)x1 / ctx->dst_width * 2.0f - 1.0f; /*v3.x*/
   ctx->vertices[3][0][1] = (float)y2 / ctx->dst_height * 2.0f - 1.0f; /*v3.y*/

   for (i = 0; i < 4; i++)
      ctx->vertices[i][0][2] = depth; /*z*/

   /* viewport */
   ctx->viewport.scale[0] = 0.5f * ctx->dst_width;
   ctx->viewport.scale[1] = 0.5f * ctx->dst_height;
   ctx->viewport.scale[2] = 1.0f;
   ctx->viewport.scale[3] = 1.0f;
   ctx->viewport.translate[0] = 0.5f * ctx->dst_width;
   ctx->viewport.translate[1] = 0.5f * ctx->dst_height;
   ctx->viewport.translate[2] = 0.0f;
   ctx->viewport.translate[3] = 0.0f;
   ctx->base.pipe->set_viewport_states(ctx->base.pipe, 0, 1, &ctx->viewport);
}

static void blitter_set_clear_color(struct blitter_context_priv *ctx,
                                    const union pipe_color_union *color)
{
   int i;

   if (color) {
      for (i = 0; i < 4; i++) {
         uint32_t *uiverts = (uint32_t *)ctx->vertices[i][1];
         uiverts[0] = color->ui[0];
         uiverts[1] = color->ui[1];
         uiverts[2] = color->ui[2];
         uiverts[3] = color->ui[3];
      }
   } else {
      for (i = 0; i < 4; i++) {
         ctx->vertices[i][1][0] = 0;
         ctx->vertices[i][1][1] = 0;
         ctx->vertices[i][1][2] = 0;
         ctx->vertices[i][1][3] = 0;
      }
   }
}

static void get_texcoords(struct pipe_sampler_view *src,
                          unsigned src_width0, unsigned src_height0,
                          int x1, int y1, int x2, int y2,
                          float out[4])
{
   struct pipe_resource *tex = src->texture;
   unsigned level = src->u.tex.first_level;
   boolean normalized = tex->target != PIPE_TEXTURE_RECT &&
                        tex->nr_samples <= 1;

   if (normalized) {
      out[0] = x1 / (float)u_minify(src_width0,  level);
      out[1] = y1 / (float)u_minify(src_height0, level);
      out[2] = x2 / (float)u_minify(src_width0,  level);
      out[3] = y2 / (float)u_minify(src_height0, level);
   } else {
      out[0] = (float) x1;
      out[1] = (float) y1;
      out[2] = (float) x2;
      out[3] = (float) y2;
   }
}

static void set_texcoords_in_vertices(const float coord[4],
                                      float *out, unsigned stride)
{
   out[0] = coord[0]; /*t0.s*/
   out[1] = coord[1]; /*t0.t*/
   out += stride;
   out[0] = coord[2]; /*t1.s*/
   out[1] = coord[1]; /*t1.t*/
   out += stride;
   out[0] = coord[2]; /*t2.s*/
   out[1] = coord[3]; /*t2.t*/
   out += stride;
   out[0] = coord[0]; /*t3.s*/
   out[1] = coord[3]; /*t3.t*/
}

static void blitter_set_texcoords(struct blitter_context_priv *ctx,
                                  struct pipe_sampler_view *src,
                                  unsigned src_width0, unsigned src_height0,
                                  float layer, unsigned sample,
                                  int x1, int y1, int x2, int y2)
{
   unsigned i;
   float coord[4];
   float face_coord[4][2];

   get_texcoords(src, src_width0, src_height0, x1, y1, x2, y2, coord);

   if (src->texture->target == PIPE_TEXTURE_CUBE ||
       src->texture->target == PIPE_TEXTURE_CUBE_ARRAY) {
      set_texcoords_in_vertices(coord, &face_coord[0][0], 2);
      util_map_texcoords2d_onto_cubemap((unsigned)layer % 6,
                                        /* pointer, stride in floats */
                                        &face_coord[0][0], 2,
                                        &ctx->vertices[0][1][0], 8,
                                        FALSE);
   } else {
      set_texcoords_in_vertices(coord, &ctx->vertices[0][1][0], 8);
   }

   /* Set the layer. */
   switch (src->texture->target) {
   case PIPE_TEXTURE_3D:
      {
         float r = layer / (float)u_minify(src->texture->depth0,
                                           src->u.tex.first_level);
         for (i = 0; i < 4; i++)
            ctx->vertices[i][1][2] = r; /*r*/
      }
      break;

   case PIPE_TEXTURE_1D_ARRAY:
      for (i = 0; i < 4; i++)
         ctx->vertices[i][1][1] = (float) layer; /*t*/
      break;

   case PIPE_TEXTURE_2D_ARRAY:
      for (i = 0; i < 4; i++) {
         ctx->vertices[i][1][2] = (float) layer;  /*r*/
         ctx->vertices[i][1][3] = (float) sample; /*q*/
      }
      break;

   case PIPE_TEXTURE_CUBE_ARRAY:
      for (i = 0; i < 4; i++)
         ctx->vertices[i][1][3] = (float) ((unsigned)layer / 6); /*w*/
      break;

   case PIPE_TEXTURE_2D:
      for (i = 0; i < 4; i++) {
         ctx->vertices[i][1][3] = (float) sample; /*r*/
      }
      break;

   default:;
   }
}

static void blitter_set_dst_dimensions(struct blitter_context_priv *ctx,
                                       unsigned width, unsigned height)
{
   ctx->dst_width = width;
   ctx->dst_height = height;
}

static void *blitter_get_fs_texfetch_col(struct blitter_context_priv *ctx,
                                         enum pipe_format format,
                                         enum pipe_texture_target target,
                                         unsigned src_nr_samples,
                                         unsigned dst_nr_samples,
                                         unsigned filter)
{
   struct pipe_context *pipe = ctx->base.pipe;
   unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, src_nr_samples);

   assert(target < PIPE_MAX_TEXTURE_TYPES);

   if (src_nr_samples > 1) {
      void **shader;

      if (dst_nr_samples <= 1) {
         /* The destination has one sample, so we'll do color resolve. */
         boolean is_uint, is_sint;
         unsigned index = GET_MSAA_RESOLVE_FS_IDX(src_nr_samples);

         is_uint = util_format_is_pure_uint(format);
         is_sint = util_format_is_pure_sint(format);

         assert(filter < 2);

         if (is_uint)
            shader = &ctx->fs_resolve_uint[target][index][filter];
         else if (is_sint)
            shader = &ctx->fs_resolve_sint[target][index][filter];
         else
            shader = &ctx->fs_resolve[target][index][filter];

         if (!*shader) {
            if (filter == PIPE_TEX_FILTER_LINEAR) {
               *shader = util_make_fs_msaa_resolve_bilinear(pipe, tgsi_tex,
                                                   src_nr_samples,
                                                   is_uint, is_sint);
            }
            else {
               *shader = util_make_fs_msaa_resolve(pipe, tgsi_tex,
                                                   src_nr_samples,
                                                   is_uint, is_sint);
            }
         }
      }
      else {
         /* The destination has multiple samples, we'll do
          * an MSAA->MSAA copy.
          */
         shader = &ctx->fs_texfetch_col_msaa[target];

         /* Create the fragment shader on-demand. */
         if (!*shader) {
            *shader = util_make_fs_blit_msaa_color(pipe, tgsi_tex);
         }
      }

      return *shader;
   } else {
      void **shader = &ctx->fs_texfetch_col[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         *shader = util_make_fragment_tex_shader(pipe, tgsi_tex,
                                                 TGSI_INTERPOLATE_LINEAR);
      }

      return *shader;
   }
}

static INLINE
void *blitter_get_fs_texfetch_depth(struct blitter_context_priv *ctx,
                                    enum pipe_texture_target target,
                                    unsigned nr_samples)
{
   struct pipe_context *pipe = ctx->base.pipe;

   assert(target < PIPE_MAX_TEXTURE_TYPES);

   if (nr_samples > 1) {
      void **shader = &ctx->fs_texfetch_depth_msaa[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_depth(pipe, tgsi_tex);
      }

      return *shader;
   } else {
      void **shader = &ctx->fs_texfetch_depth[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

         *shader =
            util_make_fragment_tex_shader_writedepth(pipe, tgsi_tex,
                                                     TGSI_INTERPOLATE_LINEAR);
      }

      return *shader;
   }
}

static INLINE
void *blitter_get_fs_texfetch_depthstencil(struct blitter_context_priv *ctx,
                                           enum pipe_texture_target target,
                                           unsigned nr_samples)
{
   struct pipe_context *pipe = ctx->base.pipe;

   assert(target < PIPE_MAX_TEXTURE_TYPES);

   if (nr_samples > 1) {
      void **shader = &ctx->fs_texfetch_depthstencil_msaa[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_depthstencil(pipe, tgsi_tex);
      }

      return *shader;
   } else {
      void **shader = &ctx->fs_texfetch_depthstencil[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

         *shader =
            util_make_fragment_tex_shader_writedepthstencil(pipe, tgsi_tex,
                                                     TGSI_INTERPOLATE_LINEAR);
      }

      return *shader;
   }
}

static INLINE
void *blitter_get_fs_texfetch_stencil(struct blitter_context_priv *ctx,
                                      enum pipe_texture_target target,
                                      unsigned nr_samples)
{
   struct pipe_context *pipe = ctx->base.pipe;

   assert(target < PIPE_MAX_TEXTURE_TYPES);

   if (nr_samples > 1) {
      void **shader = &ctx->fs_texfetch_stencil_msaa[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_stencil(pipe, tgsi_tex);
      }

      return *shader;
   } else {
      void **shader = &ctx->fs_texfetch_stencil[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

         *shader =
            util_make_fragment_tex_shader_writestencil(pipe, tgsi_tex,
                                                       TGSI_INTERPOLATE_LINEAR);
      }

      return *shader;
   }
}

void util_blitter_cache_all_shaders(struct blitter_context *blitter)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_screen *screen = blitter->pipe->screen;
   unsigned samples, j, f, target, max_samples;
   boolean has_arraytex, has_cubearraytex;

   max_samples = ctx->has_texture_multisample ? 2 : 1;
   has_arraytex = screen->get_param(screen,
                                    PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS) != 0;
   has_cubearraytex = screen->get_param(screen,
                                    PIPE_CAP_CUBE_MAP_ARRAY) != 0;

   /* It only matters if i <= 1 or > 1. */
   for (samples = 1; samples <= max_samples; samples++) {
      for (target = PIPE_TEXTURE_1D; target < PIPE_MAX_TEXTURE_TYPES; target++) {
         if (!has_arraytex &&
             (target == PIPE_TEXTURE_1D_ARRAY ||
              target == PIPE_TEXTURE_2D_ARRAY)) {
            continue;
         }
         if (!has_cubearraytex &&
             (target == PIPE_TEXTURE_CUBE_ARRAY))
            continue;

	 if (samples > 1 &&
	     (target != PIPE_TEXTURE_2D &&
	      target != PIPE_TEXTURE_2D_ARRAY))
	    continue;

         /* If samples == 1, the shaders read one texel. If samples >= 1,
          * they read one sample.
          */
         blitter_get_fs_texfetch_col(ctx, PIPE_FORMAT_R32_FLOAT, target,
                                     samples, samples, 0);
         blitter_get_fs_texfetch_depth(ctx, target, samples);
         if (ctx->has_stencil_export) {
            blitter_get_fs_texfetch_depthstencil(ctx, target, samples);
            blitter_get_fs_texfetch_stencil(ctx, target, samples);
         }

         if (samples == 1)
            continue;

         /* MSAA resolve shaders. */
         for (j = 2; j < 32; j++) {
            if (!screen->is_format_supported(screen, PIPE_FORMAT_R32_FLOAT,
                                             target, j,
                                             PIPE_BIND_SAMPLER_VIEW)) {
               continue;
            }

            for (f = 0; f < 2; f++) {
               blitter_get_fs_texfetch_col(ctx, PIPE_FORMAT_R32_FLOAT, target,
                                           j, 1, f);
               blitter_get_fs_texfetch_col(ctx, PIPE_FORMAT_R32_UINT, target,
                                           j, 1, f);
               blitter_get_fs_texfetch_col(ctx, PIPE_FORMAT_R32_SINT, target,
                                           j, 1, f);
            }
         }
      }
   }
}

static void blitter_set_common_draw_rect_state(struct blitter_context_priv *ctx,
                                               boolean scissor,
                                               boolean vs_layered)
{
   struct pipe_context *pipe = ctx->base.pipe;

   pipe->bind_rasterizer_state(pipe, scissor ? ctx->rs_state_scissor
                                             : ctx->rs_state);
   pipe->bind_vs_state(pipe, vs_layered ? ctx->vs_layered : ctx->vs);
   if (ctx->has_geometry_shader)
      pipe->bind_gs_state(pipe, NULL);
   if (ctx->has_stream_out)
      pipe->set_stream_output_targets(pipe, 0, NULL, NULL);
}

static void blitter_draw(struct blitter_context_priv *ctx,
                         int x1, int y1, int x2, int y2, float depth,
                         unsigned num_instances)
{
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_vertex_buffer vb = {0};

   blitter_set_rectangle(ctx, x1, y1, x2, y2, depth);

   vb.stride = 8 * sizeof(float);

   u_upload_data(ctx->upload, 0, sizeof(ctx->vertices), ctx->vertices,
                 &vb.buffer_offset, &vb.buffer);
   u_upload_unmap(ctx->upload);

   pipe->set_vertex_buffers(pipe, ctx->base.vb_slot, 1, &vb);
   util_draw_arrays_instanced(pipe, PIPE_PRIM_TRIANGLE_FAN, 0, 4,
                              0, num_instances);
   pipe_resource_reference(&vb.buffer, NULL);
}

void util_blitter_draw_rectangle(struct blitter_context *blitter,
                                 int x1, int y1, int x2, int y2, float depth,
                                 enum blitter_attrib_type type,
                                 const union pipe_color_union *attrib)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;

   switch (type) {
      case UTIL_BLITTER_ATTRIB_COLOR:
         blitter_set_clear_color(ctx, attrib);
         break;

      case UTIL_BLITTER_ATTRIB_TEXCOORD:
         set_texcoords_in_vertices(attrib->f, &ctx->vertices[0][1][0], 8);
         break;

      default:;
   }

   blitter_draw(ctx, x1, y1, x2, y2, depth, 1);
}

static void *get_clear_blend_state(struct blitter_context_priv *ctx,
                                   unsigned clear_buffers)
{
   struct pipe_context *pipe = ctx->base.pipe;
   int index;

   clear_buffers &= PIPE_CLEAR_COLOR;

   /* Return an existing blend state. */
   if (!clear_buffers)
      return ctx->blend[0];

   index = GET_CLEAR_BLEND_STATE_IDX(clear_buffers);

   if (ctx->blend_clear[index])
      return ctx->blend_clear[index];

   /* Create a new one. */
   {
      struct pipe_blend_state blend = {0};
      unsigned i;

      blend.independent_blend_enable = 1;

      for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
         if (clear_buffers & (PIPE_CLEAR_COLOR0 << i)) {
            blend.rt[i].colormask = PIPE_MASK_RGBA;
         }
      }

      ctx->blend_clear[index] = pipe->create_blend_state(pipe, &blend);
   }
   return ctx->blend_clear[index];
}

static void util_blitter_clear_custom(struct blitter_context *blitter,
                                      unsigned width, unsigned height,
                                      unsigned num_layers,
                                      unsigned clear_buffers,
                                      const union pipe_color_union *color,
                                      double depth, unsigned stencil,
                                      void *custom_blend, void *custom_dsa)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_stencil_ref sr = { { 0 } };

   assert(ctx->vs_layered || num_layers <= 1);

   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   if (custom_blend) {
      pipe->bind_blend_state(pipe, custom_blend);
   } else {
      pipe->bind_blend_state(pipe, get_clear_blend_state(ctx, clear_buffers));
   }

   if (custom_dsa) {
      pipe->bind_depth_stencil_alpha_state(pipe, custom_dsa);
   } else if ((clear_buffers & PIPE_CLEAR_DEPTHSTENCIL) == PIPE_CLEAR_DEPTHSTENCIL) {
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_write_depth_stencil);
   } else if (clear_buffers & PIPE_CLEAR_DEPTH) {
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_write_depth_keep_stencil);
   } else if (clear_buffers & PIPE_CLEAR_STENCIL) {
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_write_stencil);
   } else {
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
   }

   sr.ref_value[0] = stencil & 0xff;
   pipe->set_stencil_ref(pipe, &sr);

   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
   ctx->bind_fs_state(pipe, ctx->fs_write_all_cbufs);
   pipe->set_sample_mask(pipe, ~0);

   blitter_set_dst_dimensions(ctx, width, height);

   if (num_layers > 1 && ctx->vs_layered) {
      blitter_set_common_draw_rect_state(ctx, FALSE, TRUE);
      blitter_set_clear_color(ctx, color);
      blitter_draw(ctx, 0, 0, width, height, depth, num_layers);
   }
   else {
      blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
      blitter->draw_rectangle(blitter, 0, 0, width, height, (float) depth,
                              UTIL_BLITTER_ATTRIB_COLOR, color);
   }

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}

void util_blitter_clear(struct blitter_context *blitter,
                        unsigned width, unsigned height, unsigned num_layers,
                        unsigned clear_buffers,
                        const union pipe_color_union *color,
                        double depth, unsigned stencil)
{
   util_blitter_clear_custom(blitter, width, height, num_layers,
                             clear_buffers, color, depth, stencil,
                             NULL, NULL);
}

void util_blitter_custom_clear_depth(struct blitter_context *blitter,
                                     unsigned width, unsigned height,
                                     double depth, void *custom_dsa)
{
    static const union pipe_color_union color;
    util_blitter_clear_custom(blitter, width, height, 0, 0, &color, depth, 0,
                              NULL, custom_dsa);
}

void util_blitter_default_dst_texture(struct pipe_surface *dst_templ,
                                      struct pipe_resource *dst,
                                      unsigned dstlevel,
                                      unsigned dstz)
{
    memset(dst_templ, 0, sizeof(*dst_templ));
    dst_templ->format = util_format_linear(dst->format);
    dst_templ->u.tex.level = dstlevel;
    dst_templ->u.tex.first_layer = dstz;
    dst_templ->u.tex.last_layer = dstz;
}

static struct pipe_surface *
util_blitter_get_next_surface_layer(struct pipe_context *pipe,
                                    struct pipe_surface *surf)
{
   struct pipe_surface dst_templ;

   memset(&dst_templ, 0, sizeof(dst_templ));
   dst_templ.format = surf->format;
   dst_templ.u.tex.level = surf->u.tex.level;
   dst_templ.u.tex.first_layer = surf->u.tex.first_layer + 1;
   dst_templ.u.tex.last_layer = surf->u.tex.last_layer + 1;

   return pipe->create_surface(pipe, surf->texture, &dst_templ);
}

void util_blitter_default_src_texture(struct pipe_sampler_view *src_templ,
                                      struct pipe_resource *src,
                                      unsigned srclevel)
{
    memset(src_templ, 0, sizeof(*src_templ));
    src_templ->format = util_format_linear(src->format);
    src_templ->u.tex.first_level = srclevel;
    src_templ->u.tex.last_level = srclevel;
    src_templ->u.tex.first_layer = 0;
    src_templ->u.tex.last_layer =
        src->target == PIPE_TEXTURE_3D ? u_minify(src->depth0, srclevel) - 1
                                       : src->array_size - 1;
    src_templ->swizzle_r = PIPE_SWIZZLE_RED;
    src_templ->swizzle_g = PIPE_SWIZZLE_GREEN;
    src_templ->swizzle_b = PIPE_SWIZZLE_BLUE;
    src_templ->swizzle_a = PIPE_SWIZZLE_ALPHA;
}

static boolean is_blit_generic_supported(struct blitter_context *blitter,
                                         const struct pipe_resource *dst,
                                         enum pipe_format dst_format,
                                         const struct pipe_resource *src,
                                         enum pipe_format src_format,
                                         unsigned mask)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_screen *screen = ctx->base.pipe->screen;

   if (dst) {
      unsigned bind;
      const struct util_format_description *desc =
            util_format_description(dst_format);
      boolean dst_has_stencil = util_format_has_stencil(desc);

      /* Stencil export must be supported for stencil copy. */
      if ((mask & PIPE_MASK_S) && dst_has_stencil &&
          !ctx->has_stencil_export) {
         return FALSE;
      }

      if (dst_has_stencil || util_format_has_depth(desc))
         bind = PIPE_BIND_DEPTH_STENCIL;
      else
         bind = PIPE_BIND_RENDER_TARGET;

      if (!screen->is_format_supported(screen, dst_format, dst->target,
                                       dst->nr_samples, bind)) {
         return FALSE;
      }
   }

   if (src) {
      if (src->nr_samples > 1 && !ctx->has_texture_multisample) {
         return FALSE;
      }

      if (!screen->is_format_supported(screen, src_format, src->target,
                                 src->nr_samples, PIPE_BIND_SAMPLER_VIEW)) {
         return FALSE;
      }

      /* Check stencil sampler support for stencil copy. */
      if (mask & PIPE_MASK_S) {
         if (util_format_has_stencil(util_format_description(src_format))) {
            enum pipe_format stencil_format =
               util_format_stencil_only(src_format);
            assert(stencil_format != PIPE_FORMAT_NONE);

            if (stencil_format != src_format &&
                !screen->is_format_supported(screen, stencil_format,
                                             src->target, src->nr_samples,
                                             PIPE_BIND_SAMPLER_VIEW)) {
               return FALSE;
            }
         }
      }
   }

   return TRUE;
}

boolean util_blitter_is_copy_supported(struct blitter_context *blitter,
                                       const struct pipe_resource *dst,
                                       const struct pipe_resource *src)
{
   return is_blit_generic_supported(blitter, dst, dst->format,
                                    src, src->format, PIPE_MASK_RGBAZS);
}

boolean util_blitter_is_blit_supported(struct blitter_context *blitter,
				       const struct pipe_blit_info *info)
{
   return is_blit_generic_supported(blitter,
                                    info->dst.resource, info->dst.format,
                                    info->src.resource, info->src.format,
                                    info->mask);
}

void util_blitter_copy_texture(struct blitter_context *blitter,
                               struct pipe_resource *dst,
                               unsigned dst_level,
                               unsigned dstx, unsigned dsty, unsigned dstz,
                               struct pipe_resource *src,
                               unsigned src_level,
                               const struct pipe_box *srcbox)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_surface *dst_view, dst_templ;
   struct pipe_sampler_view src_templ, *src_view;
   struct pipe_box dstbox;

   assert(dst && src);
   assert(src->target < PIPE_MAX_TEXTURE_TYPES);

   u_box_3d(dstx, dsty, dstz, abs(srcbox->width), abs(srcbox->height),
            abs(srcbox->depth), &dstbox);

   /* Initialize the surface. */
   util_blitter_default_dst_texture(&dst_templ, dst, dst_level, dstz);
   dst_view = pipe->create_surface(pipe, dst, &dst_templ);

   /* Initialize the sampler view. */
   util_blitter_default_src_texture(&src_templ, src, src_level);
   src_view = pipe->create_sampler_view(pipe, src, &src_templ);

   /* Copy. */
   util_blitter_blit_generic(blitter, dst_view, &dstbox,
                             src_view, srcbox, src->width0, src->height0,
                             PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL);

   pipe_surface_reference(&dst_view, NULL);
   pipe_sampler_view_reference(&src_view, NULL);
}

void util_blitter_blit_generic(struct blitter_context *blitter,
                               struct pipe_surface *dst,
                               const struct pipe_box *dstbox,
                               struct pipe_sampler_view *src,
                               const struct pipe_box *srcbox,
                               unsigned src_width0, unsigned src_height0,
                               unsigned mask, unsigned filter,
                               const struct pipe_scissor_state *scissor)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;
   enum pipe_texture_target src_target = src->texture->target;
   unsigned src_samples = src->texture->nr_samples;
   unsigned dst_samples = dst->texture->nr_samples;
   boolean has_depth, has_stencil, has_color;
   boolean blit_stencil, blit_depth, blit_color;
   void *sampler_state;
   const struct util_format_description *src_desc =
         util_format_description(src->format);
   const struct util_format_description *dst_desc =
         util_format_description(dst->format);

   has_color = src_desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS &&
               dst_desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS;
   has_depth = util_format_has_depth(src_desc) &&
               util_format_has_depth(dst_desc);
   has_stencil = util_format_has_stencil(src_desc) &&
                 util_format_has_stencil(dst_desc);

   blit_color = has_color && (mask & PIPE_MASK_RGBA);
   blit_depth = has_depth && (mask & PIPE_MASK_Z);
   blit_stencil = has_stencil && (mask & PIPE_MASK_S) &&
                  ctx->has_stencil_export;

   if (!blit_stencil && !blit_depth && !blit_color) {
      return;
   }

   if (blit_stencil ||
       (dstbox->width == abs(srcbox->width) &&
        dstbox->height == abs(srcbox->height))) {
      filter = PIPE_TEX_FILTER_NEAREST;
   }

   /* Check whether the states are properly saved. */
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_textures(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);

   /* Initialize framebuffer state. */
   fb_state.width = dst->width;
   fb_state.height = dst->height;
   fb_state.nr_cbufs = blit_depth || blit_stencil ? 0 : 1;
   fb_state.cbufs[0] = NULL;
   fb_state.zsbuf = NULL;

   if (blit_depth || blit_stencil) {
      pipe->bind_blend_state(pipe, ctx->blend[0]);

      if (blit_depth && blit_stencil) {
         pipe->bind_depth_stencil_alpha_state(pipe,
                                              ctx->dsa_write_depth_stencil);
         ctx->bind_fs_state(pipe,
               blitter_get_fs_texfetch_depthstencil(ctx, src_target,
                                                    src_samples));
      } else if (blit_depth) {
         pipe->bind_depth_stencil_alpha_state(pipe,
                                              ctx->dsa_write_depth_keep_stencil);
         ctx->bind_fs_state(pipe,
               blitter_get_fs_texfetch_depth(ctx, src_target,
                                             src_samples));
      } else { /* is_stencil */
         pipe->bind_depth_stencil_alpha_state(pipe,
                                              ctx->dsa_keep_depth_write_stencil);
         ctx->bind_fs_state(pipe,
               blitter_get_fs_texfetch_stencil(ctx, src_target,
                                               src_samples));
      }

   } else {
      pipe->bind_blend_state(pipe, ctx->blend[mask & PIPE_MASK_RGBA]);
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
      ctx->bind_fs_state(pipe,
            blitter_get_fs_texfetch_col(ctx, src->format, src_target,
                                        src_samples, dst_samples, filter));
   }

   /* Set the linear filter only for scaled color non-MSAA blits. */
   if (filter == PIPE_TEX_FILTER_LINEAR) {
      if (src_target == PIPE_TEXTURE_RECT) {
         sampler_state = ctx->sampler_state_rect_linear;
      } else {
         sampler_state = ctx->sampler_state_linear;
      }
   } else {
      if (src_target == PIPE_TEXTURE_RECT) {
         sampler_state = ctx->sampler_state_rect;
      } else {
         sampler_state = ctx->sampler_state;
      }
   }

   /* Set samplers. */
   if (blit_depth && blit_stencil) {
      /* Setup two samplers, one for depth and the other one for stencil. */
      struct pipe_sampler_view templ;
      struct pipe_sampler_view *views[2];
      void *samplers[2] = {sampler_state, sampler_state};

      templ = *src;
      templ.format = util_format_stencil_only(templ.format);
      assert(templ.format != PIPE_FORMAT_NONE);

      views[0] = src;
      views[1] = pipe->create_sampler_view(pipe, src->texture, &templ);

      pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, 2, views);
      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0, 2, samplers);

      pipe_sampler_view_reference(&views[1], NULL);
   } else if (blit_stencil) {
      /* Set a stencil-only sampler view for it not to sample depth instead. */
      struct pipe_sampler_view templ;
      struct pipe_sampler_view *view;

      templ = *src;
      templ.format = util_format_stencil_only(templ.format);
      assert(templ.format != PIPE_FORMAT_NONE);

      view = pipe->create_sampler_view(pipe, src->texture, &templ);

      pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, 1, &view);
      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT,
                                0, 1, &sampler_state);

      pipe_sampler_view_reference(&view, NULL);
   } else {
      pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, 1, &src);
      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT,
                                0, 1, &sampler_state);
   }

   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
   if (scissor) {
      pipe->set_scissor_states(pipe, 0, 1, scissor);
   }

   blitter_set_common_draw_rect_state(ctx, scissor != NULL, FALSE);
   blitter_set_dst_dimensions(ctx, dst->width, dst->height);

   if ((src_target == PIPE_TEXTURE_1D ||
        src_target == PIPE_TEXTURE_2D ||
        src_target == PIPE_TEXTURE_RECT) &&
       src_samples <= 1) {
      /* Draw the quad with the draw_rectangle callback. */

      /* Set texture coordinates. - use a pipe color union
       * for interface purposes.
       * XXX pipe_color_union is a wrong name since we use that to set
       * texture coordinates too.
       */
      union pipe_color_union coord;
      get_texcoords(src, src_width0, src_height0, srcbox->x, srcbox->y,
                    srcbox->x+srcbox->width, srcbox->y+srcbox->height, coord.f);

      /* Set framebuffer state. */
      if (blit_depth || blit_stencil) {
         fb_state.zsbuf = dst;
      } else {
         fb_state.cbufs[0] = dst;
      }
      pipe->set_framebuffer_state(pipe, &fb_state);

      /* Draw. */
      pipe->set_sample_mask(pipe, ~0);
      blitter->draw_rectangle(blitter, dstbox->x, dstbox->y,
                              dstbox->x + dstbox->width,
                              dstbox->y + dstbox->height, 0,
                              UTIL_BLITTER_ATTRIB_TEXCOORD, &coord);
   } else {
      /* Draw the quad with the generic codepath. */
      int dst_z;
      for (dst_z = 0; dst_z < dstbox->depth; dst_z++) {
         struct pipe_surface *old;
         float dst2src_scale = srcbox->depth / (float)dstbox->depth;

         /* Scale Z properly if the blit is scaled.
          *
          * When downscaling, we want the coordinates centered, so that
          * mipmapping works for 3D textures. For example, when generating
          * a 4x4x4 level, this wouldn't average the pixels:
          *
          *   src Z:  0 1 2 3 4 5 6 7
          *   dst Z:  0   1   2   3
          *
          * Because the pixels are not centered below the pixels of the higher
          * level. Therefore, we want this:
          *   src Z:  0 1 2 3 4 5 6 7
          *   dst Z:   0   1   2   3
          *
          * dst_offset defines the offset needed for centering the pixels and
          * it works with any scaling (not just 2x).
          */
         float dst_offset = ((srcbox->depth - 1) -
                             (dstbox->depth - 1) * dst2src_scale) * 0.5;
         float src_z = (dst_z + dst_offset) * dst2src_scale;

         /* Set framebuffer state. */
         if (blit_depth || blit_stencil) {
            fb_state.zsbuf = dst;
         } else {
            fb_state.cbufs[0] = dst;
         }
         pipe->set_framebuffer_state(pipe, &fb_state);

         /* See if we need to blit a multisample or singlesample buffer. */
         if (src_samples == dst_samples && dst_samples > 1) {
            /* MSAA copy. */
            unsigned i, max_sample = dst_samples - 1;

            for (i = 0; i <= max_sample; i++) {
               pipe->set_sample_mask(pipe, 1 << i);
               blitter_set_texcoords(ctx, src, src_width0, src_height0,
                                     srcbox->z + src_z,
                                     i, srcbox->x, srcbox->y,
                                     srcbox->x + srcbox->width,
                                     srcbox->y + srcbox->height);
               blitter_draw(ctx, dstbox->x, dstbox->y,
                            dstbox->x + dstbox->width,
                            dstbox->y + dstbox->height, 0, 1);
            }
         } else {
            /* Normal copy, MSAA upsampling, or MSAA resolve. */
            pipe->set_sample_mask(pipe, ~0);
            blitter_set_texcoords(ctx, src, src_width0, src_height0,
                                  srcbox->z + src_z, 0,
                                  srcbox->x, srcbox->y,
                                  srcbox->x + srcbox->width,
                                  srcbox->y + srcbox->height);
            blitter_draw(ctx, dstbox->x, dstbox->y,
                         dstbox->x + dstbox->width,
                         dstbox->y + dstbox->height, 0, 1);
         }

         /* Get the next surface or (if this is the last iteration)
          * just unreference the last one. */
         old = dst;
         if (dst_z < dstbox->depth-1) {
            dst = ctx->base.get_next_surface_layer(ctx->base.pipe, dst);
         }
         if (dst_z) {
            pipe_surface_reference(&old, NULL);
         }
      }
   }

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_textures(ctx);
   blitter_restore_fb_state(ctx);
   if (scissor) {
      pipe->set_scissor_states(pipe, 0, 1, &ctx->base.saved_scissor);
   }
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}

void
util_blitter_blit(struct blitter_context *blitter,
		  const struct pipe_blit_info *info)
{
   struct pipe_resource *dst = info->dst.resource;
   struct pipe_resource *src = info->src.resource;
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_surface *dst_view, dst_templ;
   struct pipe_sampler_view src_templ, *src_view;

   /* Initialize the surface. */
   util_blitter_default_dst_texture(&dst_templ, dst, info->dst.level,
                                    info->dst.box.z);
   dst_templ.format = info->dst.format;
   dst_view = pipe->create_surface(pipe, dst, &dst_templ);

   /* Initialize the sampler view. */
   util_blitter_default_src_texture(&src_templ, src, info->src.level);
   src_templ.format = info->src.format;
   src_view = pipe->create_sampler_view(pipe, src, &src_templ);

   /* Copy. */
   util_blitter_blit_generic(blitter, dst_view, &info->dst.box,
                             src_view, &info->src.box, src->width0, src->height0,
                             info->mask, info->filter,
                             info->scissor_enable ? &info->scissor : NULL);

   pipe_surface_reference(&dst_view, NULL);
   pipe_sampler_view_reference(&src_view, NULL);
}

/* Clear a region of a color surface to a constant value. */
void util_blitter_clear_render_target(struct blitter_context *blitter,
                                      struct pipe_surface *dstsurf,
                                      const union pipe_color_union *color,
                                      unsigned dstx, unsigned dsty,
                                      unsigned width, unsigned height)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;

   assert(dstsurf->texture);
   if (!dstsurf->texture)
      return;

   /* check the saved state */
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   pipe->bind_blend_state(pipe, ctx->blend[PIPE_MASK_RGBA]);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);

   /* set a framebuffer state */
   fb_state.width = dstsurf->width;
   fb_state.height = dstsurf->height;
   fb_state.nr_cbufs = 1;
   fb_state.cbufs[0] = dstsurf;
   fb_state.zsbuf = 0;
   pipe->set_framebuffer_state(pipe, &fb_state);
   pipe->set_sample_mask(pipe, ~0);

   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
   blitter_set_dst_dimensions(ctx, dstsurf->width, dstsurf->height);
   blitter->draw_rectangle(blitter, dstx, dsty, dstx+width, dsty+height, 0,
                           UTIL_BLITTER_ATTRIB_COLOR, color);

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_fb_state(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}

/* Clear a region of a depth stencil surface. */
void util_blitter_clear_depth_stencil(struct blitter_context *blitter,
                                      struct pipe_surface *dstsurf,
                                      unsigned clear_flags,
                                      double depth,
                                      unsigned stencil,
                                      unsigned dstx, unsigned dsty,
                                      unsigned width, unsigned height)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;
   struct pipe_stencil_ref sr = { { 0 } };

   assert(dstsurf->texture);
   if (!dstsurf->texture)
      return;

   /* check the saved state */
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   pipe->bind_blend_state(pipe, ctx->blend[0]);
   if ((clear_flags & PIPE_CLEAR_DEPTHSTENCIL) == PIPE_CLEAR_DEPTHSTENCIL) {
      sr.ref_value[0] = stencil & 0xff;
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_write_depth_stencil);
      pipe->set_stencil_ref(pipe, &sr);
   }
   else if (clear_flags & PIPE_CLEAR_DEPTH) {
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_write_depth_keep_stencil);
   }
   else if (clear_flags & PIPE_CLEAR_STENCIL) {
      sr.ref_value[0] = stencil & 0xff;
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_write_stencil);
      pipe->set_stencil_ref(pipe, &sr);
   }
   else
      /* hmm that should be illegal probably, or make it a no-op somewhere */
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);

   ctx->bind_fs_state(pipe, ctx->fs_empty);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);

   /* set a framebuffer state */
   fb_state.width = dstsurf->width;
   fb_state.height = dstsurf->height;
   fb_state.nr_cbufs = 0;
   fb_state.cbufs[0] = 0;
   fb_state.zsbuf = dstsurf;
   pipe->set_framebuffer_state(pipe, &fb_state);
   pipe->set_sample_mask(pipe, ~0);

   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
   blitter_set_dst_dimensions(ctx, dstsurf->width, dstsurf->height);
   blitter->draw_rectangle(blitter, dstx, dsty, dstx+width, dsty+height,
                           (float) depth,
                           UTIL_BLITTER_ATTRIB_NONE, NULL);

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_fb_state(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}

/* draw a rectangle across a region using a custom dsa stage - for r600g */
void util_blitter_custom_depth_stencil(struct blitter_context *blitter,
				       struct pipe_surface *zsurf,
				       struct pipe_surface *cbsurf,
				       unsigned sample_mask,
				       void *dsa_stage, float depth)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;

   assert(zsurf->texture);
   if (!zsurf->texture)
      return;

   /* check the saved state */
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   pipe->bind_blend_state(pipe, cbsurf ? ctx->blend[PIPE_MASK_RGBA] :
                                         ctx->blend[0]);
   pipe->bind_depth_stencil_alpha_state(pipe, dsa_stage);
   ctx->bind_fs_state(pipe, ctx->fs_empty);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);

   /* set a framebuffer state */
   fb_state.width = zsurf->width;
   fb_state.height = zsurf->height;
   fb_state.nr_cbufs = 1;
   if (cbsurf) {
	   fb_state.cbufs[0] = cbsurf;
	   fb_state.nr_cbufs = 1;
   } else {
	   fb_state.cbufs[0] = NULL;
	   fb_state.nr_cbufs = 0;
   }
   fb_state.zsbuf = zsurf;
   pipe->set_framebuffer_state(pipe, &fb_state);
   pipe->set_sample_mask(pipe, sample_mask);

   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
   blitter_set_dst_dimensions(ctx, zsurf->width, zsurf->height);
   blitter->draw_rectangle(blitter, 0, 0, zsurf->width, zsurf->height, depth,
                           UTIL_BLITTER_ATTRIB_NONE, NULL);

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_fb_state(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}

void util_blitter_copy_buffer(struct blitter_context *blitter,
                              struct pipe_resource *dst,
                              unsigned dstx,
                              struct pipe_resource *src,
                              unsigned srcx,
                              unsigned size)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_vertex_buffer vb;
   struct pipe_stream_output_target *so_target;
   unsigned offsets[PIPE_MAX_SO_BUFFERS] = {0};

   if (srcx >= src->width0 ||
       dstx >= dst->width0) {
      return;
   }
   if (srcx + size > src->width0) {
      size = src->width0 - srcx;
   }
   if (dstx + size > dst->width0) {
      size = dst->width0 - dstx;
   }

   /* Drivers not capable of Stream Out should not call this function
    * in the first place. */
   assert(ctx->has_stream_out);

   /* Some alignment is required. */
   if (srcx % 4 != 0 || dstx % 4 != 0 || size % 4 != 0 ||
       !ctx->has_stream_out) {
      struct pipe_box box;
      u_box_1d(srcx, size, &box);
      util_resource_copy_region(pipe, dst, 0, dstx, 0, 0, src, 0, &box);
      return;
   }

   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_disable_render_cond(ctx);

   vb.buffer = src;
   vb.buffer_offset = srcx;
   vb.stride = 4;

   pipe->set_vertex_buffers(pipe, ctx->base.vb_slot, 1, &vb);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state_readbuf[0]);
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
   if (ctx->has_geometry_shader)
      pipe->bind_gs_state(pipe, NULL);
   pipe->bind_rasterizer_state(pipe, ctx->rs_discard_state);

   so_target = pipe->create_stream_output_target(pipe, dst, dstx, size);
   pipe->set_stream_output_targets(pipe, 1, &so_target, offsets);

   util_draw_arrays(pipe, PIPE_PRIM_POINTS, 0, size / 4);

   blitter_restore_vertex_states(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
   pipe_so_target_reference(&so_target, NULL);
}

void util_blitter_clear_buffer(struct blitter_context *blitter,
                               struct pipe_resource *dst,
                               unsigned offset, unsigned size,
                               unsigned num_channels,
                               const union pipe_color_union *clear_value)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_vertex_buffer vb = {0};
   struct pipe_stream_output_target *so_target;
   unsigned offsets[PIPE_MAX_SO_BUFFERS] = {0};

   assert(num_channels >= 1);
   assert(num_channels <= 4);

   /* IMPORTANT:  DON'T DO ANY BOUNDS CHECKING HERE!
    *
    * R600 uses this to initialize texture resources, so width0 might not be
    * what you think it is.
    */

   /* Streamout is required. */
   if (!ctx->has_stream_out) {
      assert(!"Streamout unsupported in util_blitter_clear_buffer()");
      return;
   }

   /* Some alignment is required. */
   if (offset % 4 != 0 || size % 4 != 0) {
      assert(!"Bad alignment in util_blitter_clear_buffer()");
      return;
   }

   u_upload_data(ctx->upload, 0, num_channels*4, clear_value,
                 &vb.buffer_offset, &vb.buffer);
   vb.stride = 0;

   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_disable_render_cond(ctx);

   pipe->set_vertex_buffers(pipe, ctx->base.vb_slot, 1, &vb);
   pipe->bind_vertex_elements_state(pipe,
                                    ctx->velem_state_readbuf[num_channels-1]);
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
   if (ctx->has_geometry_shader)
      pipe->bind_gs_state(pipe, NULL);
   pipe->bind_rasterizer_state(pipe, ctx->rs_discard_state);

   so_target = pipe->create_stream_output_target(pipe, dst, offset, size);
   pipe->set_stream_output_targets(pipe, 1, &so_target, offsets);

   util_draw_arrays(pipe, PIPE_PRIM_POINTS, 0, size / 4);

   blitter_restore_vertex_states(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
   pipe_so_target_reference(&so_target, NULL);
   pipe_resource_reference(&vb.buffer, NULL);
}

/* probably radeon specific */
void util_blitter_custom_resolve_color(struct blitter_context *blitter,
				       struct pipe_resource *dst,
				       unsigned dst_level,
				       unsigned dst_layer,
				       struct pipe_resource *src,
				       unsigned src_layer,
				       unsigned sample_mask,
				       void *custom_blend,
                                       enum pipe_format format)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;
   struct pipe_surface *srcsurf, *dstsurf, surf_tmpl;

   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   pipe->bind_blend_state(pipe, custom_blend);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
   pipe->set_sample_mask(pipe, sample_mask);

   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   surf_tmpl.format = format;
   surf_tmpl.u.tex.level = dst_level;
   surf_tmpl.u.tex.first_layer = dst_layer;
   surf_tmpl.u.tex.last_layer = dst_layer;

   dstsurf = pipe->create_surface(pipe, dst, &surf_tmpl);

   surf_tmpl.u.tex.level = 0;
   surf_tmpl.u.tex.first_layer = src_layer;
   surf_tmpl.u.tex.last_layer = src_layer;

   srcsurf = pipe->create_surface(pipe, src, &surf_tmpl);

   /* set a framebuffer state */
   fb_state.width = src->width0;
   fb_state.height = src->height0;
   fb_state.nr_cbufs = 2;
   fb_state.cbufs[0] = srcsurf;
   fb_state.cbufs[1] = dstsurf;
   fb_state.zsbuf = NULL;
   pipe->set_framebuffer_state(pipe, &fb_state);

   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
   blitter_set_dst_dimensions(ctx, src->width0, src->height0);
   blitter->draw_rectangle(blitter, 0, 0, src->width0, src->height0,
                           0, 0, NULL);
   blitter_restore_fb_state(ctx);
   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);

   pipe_surface_reference(&srcsurf, NULL);
   pipe_surface_reference(&dstsurf, NULL);
}

void util_blitter_custom_color(struct blitter_context *blitter,
                               struct pipe_surface *dstsurf,
                               void *custom_blend)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;

   assert(dstsurf->texture);
   if (!dstsurf->texture)
      return;

   /* check the saved state */
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   pipe->bind_blend_state(pipe, custom_blend ? custom_blend
                                             : ctx->blend[PIPE_MASK_RGBA]);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
   pipe->set_sample_mask(pipe, (1ull << MAX2(1, dstsurf->texture->nr_samples)) - 1);

   /* set a framebuffer state */
   fb_state.width = dstsurf->width;
   fb_state.height = dstsurf->height;
   fb_state.nr_cbufs = 1;
   fb_state.cbufs[0] = dstsurf;
   fb_state.zsbuf = 0;
   pipe->set_framebuffer_state(pipe, &fb_state);
   pipe->set_sample_mask(pipe, ~0);

   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
   blitter_set_dst_dimensions(ctx, dstsurf->width, dstsurf->height);
   blitter->draw_rectangle(blitter, 0, 0, dstsurf->width, dstsurf->height,
                           0, 0, NULL);

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_fb_state(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a132 1
   boolean has_layered;
a135 1
   boolean cached_all_shaders;
d291 10
a300 3
   ctx->has_layered =
      pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_INSTANCEID) &&
      pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_VS_LAYER_VIEWPORT);
d302 9
a310 3
   /* set invariant vertex coordinates */
   for (i = 0; i < 4; i++)
      ctx->vertices[i][0][3] = 1; /*v.w*/
d312 1
a312 10
   ctx->upload = u_upload_create(pipe, 65536, 4, PIPE_BIND_VERTEX_BUFFER);

   return &ctx->base;
}

static void bind_vs_pos_only(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->vs_pos_only) {
d327 2
a328 24
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
}

static void bind_vs_passthrough(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->vs) {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indices[] = { 0, 0 };
      ctx->vs =
         util_make_vertex_passthrough_shader(pipe, 2, semantic_names,
                                             semantic_indices);
   }

   pipe->bind_vs_state(pipe, ctx->vs);
}

static void bind_vs_layered(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->vs_layered) {
d332 3
a334 2
   pipe->bind_vs_state(pipe, ctx->vs_layered);
}
d336 1
a336 3
static void bind_fs_empty(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;
d338 1
a338 34
   if (!ctx->fs_empty) {
      assert(!ctx->cached_all_shaders);
      ctx->fs_empty = util_make_empty_fragment_shader(pipe);
   }

   ctx->bind_fs_state(pipe, ctx->fs_empty);
}

static void bind_fs_write_one_cbuf(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->fs_write_one_cbuf) {
      assert(!ctx->cached_all_shaders);
      ctx->fs_write_one_cbuf =
         util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                               TGSI_INTERPOLATE_CONSTANT, FALSE);
   }

   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
}

static void bind_fs_write_all_cbufs(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->fs_write_all_cbufs) {
      assert(!ctx->cached_all_shaders);
      ctx->fs_write_all_cbufs =
         util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                               TGSI_INTERPOLATE_CONSTANT, TRUE);
   }

   ctx->bind_fs_state(pipe, ctx->fs_write_all_cbufs);
d364 1
a364 2
   if (ctx->vs)
      pipe->delete_vs_state(pipe, ctx->vs);
d411 3
a413 6
   if (ctx->fs_empty)
      ctx->delete_fs_state(pipe, ctx->fs_empty);
   if (ctx->fs_write_one_cbuf)
      ctx->delete_fs_state(pipe, ctx->fs_write_one_cbuf);
   if (ctx->fs_write_all_cbufs)
      ctx->delete_fs_state(pipe, ctx->fs_write_all_cbufs);
a798 1
            assert(!ctx->cached_all_shaders);
a818 1
            assert(!ctx->cached_all_shaders);
a828 1
         assert(!ctx->cached_all_shaders);
d851 5
a855 4
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
         *shader = util_make_fs_blit_msaa_depth(pipe, tgsi_tex);
d864 2
a865 3
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
d889 5
a893 4
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
         *shader = util_make_fs_blit_msaa_depthstencil(pipe, tgsi_tex);
d902 2
a903 3
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
d927 5
a931 4
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
         *shader = util_make_fs_blit_msaa_stencil(pipe, tgsi_tex);
d940 2
a941 3
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
a950 7

/**
 * Generate and save all fragment shaders that we will ever need for
 * blitting.  Drivers which use the 'draw' fallbacks will typically use
 * this to make sure we generate/use shaders that don't go through the
 * draw module's wrapper functions.
 */
d954 1
a954 2
   struct pipe_context *pipe = blitter->pipe;
   struct pipe_screen *screen = pipe->screen;
a1013 12

   ctx->fs_empty = util_make_empty_fragment_shader(pipe);

   ctx->fs_write_one_cbuf =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, FALSE);

   ctx->fs_write_all_cbufs =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, TRUE);

   ctx->cached_all_shaders = TRUE;
d1024 1
a1024 5
   if (vs_layered)
      bind_vs_layered(ctx);
   else
      bind_vs_passthrough(ctx);

d1121 1
a1121 1
   assert(ctx->has_layered || num_layers <= 1);
d1151 1
a1151 1
   bind_fs_write_all_cbufs(ctx);
d1156 1
a1156 1
   if (num_layers > 1 && ctx->has_layered) {
d1683 1
a1683 1
   bind_fs_write_one_cbuf(ctx);
d1751 1
a1751 1
   bind_fs_empty(ctx);
d1802 1
a1802 4
   if (cbsurf)
      bind_fs_write_one_cbuf(ctx);
   else
      bind_fs_empty(ctx);
d1879 1
a1879 1
   bind_vs_pos_only(ctx);
d1939 1
a1939 1
   bind_vs_pos_only(ctx);
d1981 1
a1981 1
   bind_fs_write_one_cbuf(ctx);
d2044 1
a2044 1
   bind_fs_write_one_cbuf(ctx);
@


1.6
log
@Merge Mesa 10.2.7
@
text
@d133 1
d137 1
d293 12
a304 10
   /* Fragment shaders are created on-demand, except these.
    * The interpolation must be constant for integer texture clearing to work.
    */
   ctx->fs_empty = util_make_empty_fragment_shader(pipe);
   ctx->fs_write_one_cbuf =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, FALSE);
   ctx->fs_write_all_cbufs =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, TRUE);
d306 3
a308 9
   /* vertex shaders */
   {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indices[] = { 0, 0 };
      ctx->vs =
         util_make_vertex_passthrough_shader(pipe, 2, semantic_names,
                                             semantic_indices);
   }
d310 1
a310 1
   if (ctx->has_stream_out) {
d325 24
a348 2
   if (pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_INSTANCEID) &&
       pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_VS_LAYER)) {
d352 32
a383 3
   /* set invariant vertex coordinates */
   for (i = 0; i < 4; i++)
      ctx->vertices[i][0][3] = 1; /*v.w*/
d385 6
a390 1
   ctx->upload = u_upload_create(pipe, 65536, 4, PIPE_BIND_VERTEX_BUFFER);
d392 1
a392 1
   return &ctx->base;
d418 2
a419 1
   pipe->delete_vs_state(pipe, ctx->vs);
d466 6
a471 3
   ctx->delete_fs_state(pipe, ctx->fs_empty);
   ctx->delete_fs_state(pipe, ctx->fs_write_one_cbuf);
   ctx->delete_fs_state(pipe, ctx->fs_write_all_cbufs);
d857 1
d878 1
d889 1
d912 4
a915 5
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_depth(pipe, tgsi_tex);
d924 3
a926 2
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

d950 4
a953 5
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_depthstencil(pipe, tgsi_tex);
d962 3
a964 2
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

d988 4
a991 5
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_stencil(pipe, tgsi_tex);
d1000 3
a1002 2
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

d1012 7
d1022 2
a1023 1
   struct pipe_screen *screen = blitter->pipe->screen;
d1083 12
d1105 5
a1109 1
   pipe->bind_vs_state(pipe, vs_layered ? ctx->vs_layered : ctx->vs);
d1206 1
a1206 1
   assert(ctx->vs_layered || num_layers <= 1);
d1236 1
a1236 1
   ctx->bind_fs_state(pipe, ctx->fs_write_all_cbufs);
d1241 1
a1241 1
   if (num_layers > 1 && ctx->vs_layered) {
d1768 1
a1768 1
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
d1836 1
a1836 1
   ctx->bind_fs_state(pipe, ctx->fs_empty);
d1887 4
a1890 1
   ctx->bind_fs_state(pipe, ctx->fs_empty);
d1967 1
a1967 1
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
d2027 1
a2027 1
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
d2069 1
a2069 1
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
d2132 1
a2132 1
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d386 9
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d20 1
a20 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d54 6
d74 1
d97 5
d104 1
d311 1
d327 5
d345 1
a345 1
   int i;
d350 4
d367 2
d385 15
d401 1
d475 3
d480 1
a480 1
                                      ctx->base.saved_so_targets, ~0);
d575 4
a578 3
   pipe->bind_fragment_sampler_states(pipe,
                                      ctx->base.saved_num_sampler_states,
                                      ctx->base.saved_sampler_states);
d582 3
a584 3
   pipe->set_fragment_sampler_views(pipe,
                                    ctx->base.saved_num_sampler_views,
                                    ctx->base.saved_sampler_views);
d691 1
a691 1
                                  unsigned layer, unsigned sample,
d703 1
a703 1
      util_map_texcoords2d_onto_cubemap(layer % 6,
d706 2
a707 1
                                        &ctx->vertices[0][1][0], 8);
d737 1
a737 1
         ctx->vertices[i][1][3] = (float) (layer / 6); /*w*/
d758 1
d760 3
a762 1
                                         unsigned nr_samples)
d765 1
d769 2
a770 2
   if (nr_samples > 1) {
      void **shader = &ctx->fs_texfetch_col_msaa[target];
d772 40
a811 6
      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader = util_make_fs_blit_msaa_color(pipe, tgsi_tex);
d820 2
a821 5
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

         *shader =
            util_make_fragment_tex_shader(pipe, tgsi_tex,
                                          TGSI_INTERPOLATE_LINEAR);
d946 1
a946 1
   unsigned i, target, max_samples;
d956 1
a956 1
   for (i = 1; i <= max_samples; i++) {
d967 1
a967 1
	 if (i > 1 &&
d972 6
a977 2
         blitter_get_fs_texfetch_col(ctx, target, i);
         blitter_get_fs_texfetch_depth(ctx, target, i);
d979 23
a1001 2
            blitter_get_fs_texfetch_depthstencil(ctx, target, i);
            blitter_get_fs_texfetch_stencil(ctx, target, i);
d1008 2
a1009 1
                                               boolean scissor)
d1015 1
a1015 1
   pipe->bind_vs_state(pipe, ctx->vs);
d1019 1
a1019 1
      pipe->set_stream_output_targets(pipe, 0, NULL, 0);
d1023 2
a1024 1
                         int x1, int y1, int x2, int y2, float depth)
d1026 2
a1027 2
   struct pipe_resource *buf = NULL;
   unsigned offset = 0;
d1031 2
d1034 1
a1034 1
                 &offset, &buf);
d1036 5
a1040 3
   util_draw_vertex_buffer(ctx->base.pipe, NULL, buf, ctx->base.vb_slot,
                           offset, PIPE_PRIM_TRIANGLE_FAN, 4, 2);
   pipe_resource_reference(&buf, NULL);
d1062 36
a1097 1
   blitter_draw(ctx, x1, y1, x2, y2, depth);
d1102 1
d1112 2
a1121 2
   } else if (clear_buffers & PIPE_CLEAR_COLOR) {
      pipe->bind_blend_state(pipe, ctx->blend[PIPE_MASK_RGBA]);
d1123 1
a1123 1
      pipe->bind_blend_state(pipe, ctx->blend[0]);
a1144 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d1146 11
a1156 2
   blitter->draw_rectangle(blitter, 0, 0, width, height, (float) depth,
                           UTIL_BLITTER_ATTRIB_COLOR, color);
d1165 1
a1165 1
                        unsigned width, unsigned height,
d1170 1
a1170 1
   util_blitter_clear_custom(blitter, width, height,
d1180 1
a1180 1
    util_blitter_clear_custom(blitter, width, height, 0, &color, depth, 0,
d1294 1
a1294 2
                                       const struct pipe_resource *src,
                                       unsigned mask)
d1297 1
a1297 1
                                    src, src->format, mask);
d1315 1
a1315 2
                               const struct pipe_box *srcbox, unsigned mask,
                               boolean copy_all_samples)
d1340 1
a1340 2
                             mask, PIPE_TEX_FILTER_NEAREST, NULL,
                             copy_all_samples);
d1353 1
a1353 2
                               const struct pipe_scissor_state *scissor,
                               boolean copy_all_samples)
d1360 1
d1385 6
d1433 2
a1434 2
            blitter_get_fs_texfetch_col(ctx, src_target,
                                        src_samples));
d1438 1
a1438 5
   if (filter == PIPE_TEX_FILTER_LINEAR &&
       !blit_depth && !blit_stencil &&
       src_samples <= 1 &&
       (dstbox->width != abs(srcbox->width) ||
        dstbox->height != abs(srcbox->height))) {
d1466 2
a1467 2
      pipe->set_fragment_sampler_views(pipe, 2, views);
      pipe->bind_fragment_sampler_states(pipe, 2, samplers);
d1481 3
a1483 2
      pipe->set_fragment_sampler_views(pipe, 1, &view);
      pipe->bind_fragment_sampler_states(pipe, 1, &sampler_state);
d1487 3
a1489 2
      pipe->set_fragment_sampler_views(pipe, 1, &src);
      pipe->bind_fragment_sampler_states(pipe, 1, &sampler_state);
d1497 1
a1497 1
   blitter_set_common_draw_rect_state(ctx, scissor != NULL);
d1531 2
a1532 2
      int z;
      for (z = 0; z < dstbox->depth; z++) {
d1534 22
d1566 3
a1568 4
         if (copy_all_samples &&
             src_samples == dst->texture->nr_samples &&
             dst->texture->nr_samples > 1) {
            unsigned i, max_sample = MAX2(dst->texture->nr_samples, 1) - 1;
d1573 1
a1573 1
                                     srcbox->z + z,
d1579 1
a1579 1
                            dstbox->y + dstbox->height, 0);
d1582 1
d1585 1
a1585 1
                                  srcbox->z + z, 0,
d1591 1
a1591 1
                         dstbox->y + dstbox->height, 0);
d1597 1
a1597 1
         if (z < dstbox->depth-1) {
d1600 1
a1600 1
         if (z) {
d1643 1
a1643 1
                             info->scissor_enable ? &info->scissor : NULL, TRUE);
d1686 1
a1686 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d1754 1
a1754 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d1811 1
a1811 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d1834 1
d1876 1
a1876 1
   pipe->set_stream_output_targets(pipe, 1, &so_target, 0);
d1896 1
d1936 1
a1936 1
   pipe->set_stream_output_targets(pipe, 1, &so_target, 0);
d1998 1
a1998 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d2048 1
a2048 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d29 2
a30 2
 * Blitter utility to facilitate acceleration of the clear, clear_render_target, clear_depth_stencil
 * resource_copy_region functions.
d50 1
d58 1
a58 1
   struct pipe_resource *vbuf;  /**< quad */
a62 1
   struct pipe_sampler_state template_sampler_state;
d67 1
d70 3
a72 2
   /* The shader at index i outputs color to color buffers 0,1,...,i-1. */
   void *fs_col[PIPE_MAX_COLOR_BUFS+1];
d81 8
d91 1
a91 2
   void *blend_write_color;   /**< blend state with writemask of RGBA */
   void *blend_keep_color;    /**< blend state with writemask of 0 */
d99 1
d101 1
d103 5
a107 2
   /* Sampler state for clamping to a miplevel. */
   void *sampler_state[PIPE_MAX_TEXTURE_LEVELS * 2];
d110 1
a110 1
   void *rs_state;
a114 3
   /* Clip state. */
   struct pipe_clip_state clip;

d118 10
d130 3
a132 7
static void blitter_draw_rectangle(struct blitter_context *blitter,
                                   unsigned x, unsigned y,
                                   unsigned width, unsigned height,
                                   float depth,
                                   enum blitter_attrib_type type,
                                   const float attrib[4]);

d140 1
a140 1
   struct pipe_sampler_state *sampler_state;
d149 5
a153 1
   ctx->base.draw_rectangle = blitter_draw_rectangle;
d161 1
d166 15
a180 1
   ctx->base.saved_num_vertex_buffers = ~0;
a183 1
   ctx->blend_keep_color = pipe->create_blend_state(pipe, &blend);
d185 4
a188 2
   blend.rt[0].colormask = PIPE_MASK_RGBA;
   ctx->blend_write_color = pipe->create_blend_state(pipe, &blend);
a210 1

d217 15
a231 7
   sampler_state = &ctx->template_sampler_state;
   sampler_state->wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state->wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state->wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state->normalized_coords = TRUE;
   /* The sampler state objects which sample from a specified mipmap level
    * are created on-demand. */
d236 2
a237 1
   rs_state.gl_rasterization_rules = 1;
d239 1
d242 12
a253 1
   /* vertex elements state */
a256 2
      velem[i].instance_divisor = 0;
      velem[i].vertex_buffer_index = 0;
d258 1
d262 26
a287 1
   /* fragment shaders are created on-demand */
d289 1
a289 1
   /* vertex shader */
d298 14
d317 1
a317 5
   /* create the vertex buffer */
   ctx->vbuf = pipe_user_buffer_create(ctx->base.pipe->screen,
                                       ctx->vertices,
                                       sizeof(ctx->vertices),
                                       PIPE_BIND_VERTEX_BUFFER);
d328 3
a330 2
   pipe->delete_blend_state(pipe, ctx->blend_write_color);
   pipe->delete_blend_state(pipe, ctx->blend_keep_color);
d338 3
d342 2
d345 5
d353 1
a353 1
         pipe->delete_fs_state(pipe, ctx->fs_texfetch_col[i]);
d355 17
a371 2
         pipe->delete_fs_state(pipe, ctx->fs_texfetch_depth[i]);
   }
d373 4
a376 7
   for (i = 0; i <= PIPE_MAX_COLOR_BUFS; i++)
      if (ctx->fs_col[i])
         pipe->delete_fs_state(pipe, ctx->fs_col[i]);

   for (i = 0; i < PIPE_MAX_TEXTURE_LEVELS * 2; i++)
      if (ctx->sampler_state[i])
         pipe->delete_sampler_state(pipe, ctx->sampler_state[i]);
d378 1
a378 2
   pipe_resource_reference(&ctx->vbuf, NULL);
   FREE(ctx);
d381 1
a381 1
static void blitter_check_saved_CSOs(struct blitter_context_priv *ctx)
d384 2
a385 2
      _debug_printf("u_blitter: Caught recursion on save. "
                    "This is a driver bug.\n");
d388 1
d390 16
a405 7
   /* make sure these CSOs have been saved */
   assert(ctx->base.saved_blend_state != INVALID_PTR &&
          ctx->base.saved_dsa_state != INVALID_PTR &&
          ctx->base.saved_rs_state != INVALID_PTR &&
          ctx->base.saved_fs != INVALID_PTR &&
          ctx->base.saved_vs != INVALID_PTR &&
          ctx->base.saved_velem_state != INVALID_PTR);
d408 1
a408 1
static void blitter_restore_CSOs(struct blitter_context_priv *ctx)
d413 10
a422 5
   /* restore the state objects which are always required to be saved */
   pipe->bind_blend_state(pipe, ctx->base.saved_blend_state);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->base.saved_dsa_state);
   pipe->bind_rasterizer_state(pipe, ctx->base.saved_rs_state);
   pipe->bind_fs_state(pipe, ctx->base.saved_fs);
d424 19
a442 1
   pipe->bind_vertex_elements_state(pipe, ctx->base.saved_velem_state);
d444 2
a445 2
   ctx->base.saved_blend_state = INVALID_PTR;
   ctx->base.saved_dsa_state = INVALID_PTR;
d447 15
a462 2
   ctx->base.saved_vs = INVALID_PTR;
   ctx->base.saved_velem_state = INVALID_PTR;
d464 17
d482 7
a488 2
   pipe->set_viewport_state(pipe, &ctx->base.saved_viewport);
   pipe->set_clip_state(pipe, &ctx->base.saved_clip);
d490 6
a495 6
   /* restore the state objects which are required to be saved before copy/fill
    */
   if (ctx->base.saved_fb_state.nr_cbufs != ~0) {
      pipe->set_framebuffer_state(pipe, &ctx->base.saved_fb_state);
      util_unreference_framebuffer_state(&ctx->base.saved_fb_state);
      ctx->base.saved_fb_state.nr_cbufs = ~0;
d497 5
d503 5
a507 5
   if (ctx->base.saved_num_sampler_states != ~0) {
      pipe->bind_fragment_sampler_states(pipe,
                                         ctx->base.saved_num_sampler_states,
                                         ctx->base.saved_sampler_states);
      ctx->base.saved_num_sampler_states = ~0;
d509 1
d511 7
a517 4
   if (ctx->base.saved_num_sampler_views != ~0) {
      pipe->set_fragment_sampler_views(pipe,
                                       ctx->base.saved_num_sampler_views,
                                       ctx->base.saved_sampler_views);
d519 5
a523 3
      for (i = 0; i < ctx->base.saved_num_sampler_views; i++)
         pipe_sampler_view_reference(&ctx->base.saved_sampler_views[i],
                                     NULL);
d525 10
a534 2
      ctx->base.saved_num_sampler_views = ~0;
   }
d536 4
a539 4
   if (ctx->base.saved_num_vertex_buffers != ~0) {
      pipe->set_vertex_buffers(pipe,
                               ctx->base.saved_num_vertex_buffers,
                               ctx->base.saved_vertex_buffers);
d541 2
a542 8
      for (i = 0; i < ctx->base.saved_num_vertex_buffers; i++) {
         if (ctx->base.saved_vertex_buffers[i].buffer) {
            pipe_resource_reference(&ctx->base.saved_vertex_buffers[i].buffer,
                                    NULL);
         }
      }
      ctx->base.saved_num_vertex_buffers = ~0;
   }
d544 1
a544 5
   if (!ctx->base.running) {
      _debug_printf("u_blitter: Caught recursion on restore. "
                    "This is a driver bug.\n");
   }
   ctx->base.running = FALSE;
d548 1
a548 2
                                  unsigned x1, unsigned y1,
                                  unsigned x2, unsigned y2,
d578 1
a578 4
   ctx->base.pipe->set_viewport_state(ctx->base.pipe, &ctx->viewport);

   /* clip */
   ctx->base.pipe->set_clip_state(ctx->base.pipe, &ctx->clip);
d582 1
a582 1
                                    const float *rgba)
d586 1
a586 1
   if (rgba) {
d588 5
a592 4
         ctx->vertices[i][1][0] = rgba[0];
         ctx->vertices[i][1][1] = rgba[1];
         ctx->vertices[i][1][2] = rgba[2];
         ctx->vertices[i][1][3] = rgba[3];
d604 20
a623 19
static void get_texcoords(struct pipe_resource *src,
                          unsigned level,
                          unsigned x1, unsigned y1,
                          unsigned x2, unsigned y2,
                          boolean normalized, float out[4])
{
   if(normalized)
   {
      out[0] = x1 / (float)u_minify(src->width0,  level);
      out[1] = y1 / (float)u_minify(src->height0, level);
      out[2] = x2 / (float)u_minify(src->width0,  level);
      out[3] = y2 / (float)u_minify(src->height0, level);
   }
   else
   {
      out[0] = x1;
      out[1] = y1;
      out[2] = x2;
      out[3] = y2;
d643 5
a647 5
static void blitter_set_texcoords_2d(struct blitter_context_priv *ctx,
                                     struct pipe_resource *src,
                                     unsigned level,
                                     unsigned x1, unsigned y1,
                                     unsigned x2, unsigned y2)
d651 1
d653 1
a653 2
   get_texcoords(src, level, x1, y1, x2, y2, TRUE, coord);
   set_texcoords_in_vertices(coord, &ctx->vertices[0][1][0], 8);
d655 9
a663 3
   for (i = 0; i < 4; i++) {
      ctx->vertices[i][1][2] = 0; /*r*/
      ctx->vertices[i][1][3] = 1; /*q*/
a664 1
}
d666 10
a675 9
static void blitter_set_texcoords_3d(struct blitter_context_priv *ctx,
                                     struct pipe_resource *src,
                                     unsigned level,
                                     unsigned zslice,
                                     unsigned x1, unsigned y1,
                                     unsigned x2, unsigned y2)
{
   int i;
   float r = zslice / (float)u_minify(src->depth0, level);
d677 4
a680 1
   blitter_set_texcoords_2d(ctx, src, level, x1, y1, x2, y2);
d682 6
a687 3
   for (i = 0; i < 4; i++)
      ctx->vertices[i][1][2] = r; /*r*/
}
d689 4
a692 9
static void blitter_set_texcoords_cube(struct blitter_context_priv *ctx,
                                       struct pipe_resource *src,
                                       unsigned level, unsigned face,
                                       unsigned x1, unsigned y1,
                                       unsigned x2, unsigned y2)
{
   int i;
   float coord[4];
   float st[4][2];
d694 5
a698 2
   get_texcoords(src, level, x1, y1, x2, y2, TRUE, coord);
   set_texcoords_in_vertices(coord, &st[0][0], 2);
d700 2
a701 7
   util_map_texcoords2d_onto_cubemap(face,
                                     /* pointer, stride in floats */
                                     &st[0][0], 2,
                                     &ctx->vertices[0][1][0], 8);

   for (i = 0; i < 4; i++)
      ctx->vertices[i][1][3] = 1; /*q*/
d711 3
a713 3
static INLINE
void **blitter_get_sampler_state(struct blitter_context_priv *ctx,
                                 int miplevel, boolean normalized)
a715 1
   struct pipe_sampler_state *sampler_state = &ctx->template_sampler_state;
d717 4
a720 1
   assert(miplevel < PIPE_MAX_TEXTURE_LEVELS);
d722 4
a725 6
   /* Create the sampler state on-demand. */
   if (!ctx->sampler_state[miplevel * 2 + normalized]) {
      sampler_state->lod_bias = miplevel;
      sampler_state->min_lod = miplevel;
      sampler_state->max_lod = miplevel;
      sampler_state->normalized_coords = normalized;
d727 17
a743 2
      ctx->sampler_state[miplevel * 2 + normalized] = pipe->create_sampler_state(pipe,
                                                                sampler_state);
a744 4

   /* Return void** so that it can be passed to bind_fragment_sampler_states
    * directly. */
   return &ctx->sampler_state[miplevel * 2 + normalized];
d748 3
a750 1
void *blitter_get_fs_col(struct blitter_context_priv *ctx, unsigned num_cbufs)
d754 9
a762 1
   assert(num_cbufs <= PIPE_MAX_COLOR_BUFS);
d764 7
a770 5
   if (!ctx->fs_col[num_cbufs])
      ctx->fs_col[num_cbufs] =
         util_make_fragment_cloneinput_shader(pipe, num_cbufs,
                                              TGSI_SEMANTIC_GENERIC,
                                              TGSI_INTERPOLATE_LINEAR);
d772 11
a782 1
   return ctx->fs_col[num_cbufs];
d785 4
a788 3
/** Convert PIPE_TEXTURE_x to TGSI_TEXTURE_x */
static unsigned
pipe_tex_to_tgsi_tex(enum pipe_texture_target pipe_tex_target)
d790 30
a819 14
   switch (pipe_tex_target) {
   case PIPE_TEXTURE_1D:
      return TGSI_TEXTURE_1D;
   case PIPE_TEXTURE_2D:
      return TGSI_TEXTURE_2D;
   case PIPE_TEXTURE_RECT:
      return TGSI_TEXTURE_RECT;
   case PIPE_TEXTURE_3D:
      return TGSI_TEXTURE_3D;
   case PIPE_TEXTURE_CUBE:
      return TGSI_TEXTURE_CUBE;
   default:
      assert(0 && "unexpected texture target");
      return TGSI_TEXTURE_UNKNOWN;
a822 1

d824 3
a826 2
void *blitter_get_fs_texfetch_col(struct blitter_context_priv *ctx,
                                  unsigned tex_target)
d830 1
a830 1
   assert(tex_target < PIPE_MAX_TEXTURE_TYPES);
d832 2
a833 3
   /* Create the fragment shader on-demand. */
   if (!ctx->fs_texfetch_col[tex_target]) {
      unsigned tgsi_tex = pipe_tex_to_tgsi_tex(tex_target);
d835 23
a857 2
      ctx->fs_texfetch_col[tex_target] =
        util_make_fragment_tex_shader(pipe, tgsi_tex, TGSI_INTERPOLATE_LINEAR);
d859 1
d861 38
a898 1
   return ctx->fs_texfetch_col[tex_target];
d901 2
a902 3
static INLINE
void *blitter_get_fs_texfetch_depth(struct blitter_context_priv *ctx,
                                    unsigned tex_target)
d906 8
a913 1
   assert(tex_target < PIPE_MAX_TEXTURE_TYPES);
d915 5
a919 3
   /* Create the fragment shader on-demand. */
   if (!ctx->fs_texfetch_depth[tex_target]) {
      unsigned tgsi_tex = pipe_tex_to_tgsi_tex(tex_target);
d921 1
a921 4
      ctx->fs_texfetch_depth[tex_target] =
         util_make_fragment_tex_shader_writedepth(pipe, tgsi_tex,
                                                  TGSI_INTERPOLATE_LINEAR);
   }
d923 6
a928 1
   return ctx->fs_texfetch_depth[tex_target];
d931 4
a934 6
static void blitter_draw_rectangle(struct blitter_context *blitter,
                                   unsigned x1, unsigned y1,
                                   unsigned x2, unsigned y2,
                                   float depth,
                                   enum blitter_attrib_type type,
                                   const float attrib[4])
d944 1
a944 1
         set_texcoords_in_vertices(attrib, &ctx->vertices[0][1][0], 8);
d950 1
a950 5
   blitter_set_rectangle(ctx, x1, y1, x2, y2, depth);
   ctx->base.pipe->redefine_user_buffer(ctx->base.pipe, ctx->vbuf,
                                        0, ctx->vbuf->width0);
   util_draw_vertex_buffer(ctx->base.pipe, NULL, ctx->vbuf, 0,
                           PIPE_PRIM_TRIANGLE_FAN, 4, 2);
a954 1
                                      unsigned num_cbufs,
d956 1
a956 1
                                      const float *rgba,
d964 4
a967 3
   assert(num_cbufs <= PIPE_MAX_COLOR_BUFS);

   blitter_check_saved_CSOs(ctx);
d969 1
a969 1
   /* bind CSOs */
d973 1
a973 1
      pipe->bind_blend_state(pipe, ctx->blend_write_color);
d975 1
a975 1
      pipe->bind_blend_state(pipe, ctx->blend_keep_color);
a992 1
   pipe->bind_rasterizer_state(pipe, ctx->rs_state);
d994 2
a995 2
   pipe->bind_fs_state(pipe, blitter_get_fs_col(ctx, num_cbufs));
   pipe->bind_vs_state(pipe, ctx->vs);
d997 1
d999 7
a1005 3
   blitter->draw_rectangle(blitter, 0, 0, width, height, depth,
                           UTIL_BLITTER_ATTRIB_COLOR, rgba);
   blitter_restore_CSOs(ctx);
a1009 1
                        unsigned num_cbufs,
d1011 1
a1011 1
                        const float *rgba,
d1014 2
a1015 2
   util_blitter_clear_custom(blitter, width, height, num_cbufs,
                             clear_buffers, rgba, depth, stencil,
d1019 1
a1019 1
void util_blitter_clear_depth_custom(struct blitter_context *blitter,
d1023 120
a1142 3
    const float rgba[4] = {0, 0, 0, 0};
    util_blitter_clear_custom(blitter, width, height, 0,
                              0, rgba, depth, 0, NULL, custom_dsa);
d1145 2
a1146 3
static
boolean is_overlap(unsigned sx1, unsigned sx2, unsigned sy1, unsigned sy2,
                   unsigned dx1, unsigned dx2, unsigned dy1, unsigned dy2)
d1148 4
a1151 1
   return sx1 < dx2 && sx2 > dx1 && sy1 < dy2 && sy2 > dy1;
d1154 8
a1161 8
void util_blitter_copy_region(struct blitter_context *blitter,
                              struct pipe_resource *dst,
                              unsigned dstlevel,
                              unsigned dstx, unsigned dsty, unsigned dstz,
                              struct pipe_resource *src,
                              unsigned srclevel,
                              const struct pipe_box *srcbox,
                              boolean ignore_stencil)
d1165 3
a1167 9
   struct pipe_screen *screen = pipe->screen;
   struct pipe_surface *dstsurf, surf_templ;
   struct pipe_framebuffer_state fb_state;
   struct pipe_sampler_view viewTempl, *view;
   unsigned bind;
   unsigned width = srcbox->width;
   unsigned height = srcbox->height;
   boolean is_stencil, is_depth;
   boolean normalized;
a1168 1
   /* Give up if textures are not set. */
a1169 8
   if (!dst || !src)
      return;

   /* Sanity checks. */
   if (dst == src) {
      assert(!is_overlap(srcbox->x, srcbox->x + width, srcbox->y, srcbox->y + height,
                         dstx, dstx + width, dsty, dsty + height));
   }
a1170 2
   /* XXX should handle 3d regions */
   assert(srcbox->depth == 1);
d1172 2
a1173 3
   /* Is this a ZS format? */
   is_depth = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 0) != 0;
   is_stencil = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 1) != 0;
d1175 52
a1226 4
   if (is_depth || is_stencil)
      bind = PIPE_BIND_DEPTH_STENCIL;
   else
      bind = PIPE_BIND_RENDER_TARGET;
d1228 1
a1228 11
   /* Check if we can sample from and render to the surfaces. */
   /* (assuming copying a stencil buffer is not possible) */
   if ((!ignore_stencil && is_stencil) ||
       !screen->is_format_supported(screen, dst->format, dst->target,
                                    dst->nr_samples, bind) ||
       !screen->is_format_supported(screen, src->format, src->target,
                                    src->nr_samples, PIPE_BIND_SAMPLER_VIEW)) {
      ctx->base.running = TRUE;
      util_resource_copy_region(pipe, dst, dstlevel, dstx, dsty, dstz,
                                src, srclevel, srcbox);
      ctx->base.running = FALSE;
a1231 9
   /* Get surface. */
   memset(&surf_templ, 0, sizeof(surf_templ));
   u_surface_default_template(&surf_templ, dst, bind);
   surf_templ.format = util_format_linear(dst->format);
   surf_templ.u.tex.level = dstlevel;
   surf_templ.u.tex.first_layer = dstz;
   surf_templ.u.tex.last_layer = dstz;
   dstsurf = pipe->create_surface(pipe, dst, &surf_templ);

d1233 6
a1238 4
   blitter_check_saved_CSOs(ctx);
   assert(blitter->saved_fb_state.nr_cbufs != ~0);
   assert(blitter->saved_num_sampler_views != ~0);
   assert(blitter->saved_num_sampler_states != ~0);
d1241 28
a1268 9
   fb_state.width = dstsurf->width;
   fb_state.height = dstsurf->height;

   if (is_depth) {
      pipe->bind_blend_state(pipe, ctx->blend_keep_color);
      pipe->bind_depth_stencil_alpha_state(pipe,
                                           ctx->dsa_write_depth_keep_stencil);
      pipe->bind_fs_state(pipe,
                          blitter_get_fs_texfetch_depth(ctx, src->target));
a1269 2
      fb_state.nr_cbufs = 0;
      fb_state.zsbuf = dstsurf;
d1271 1
a1271 1
      pipe->bind_blend_state(pipe, ctx->blend_write_color);
d1273 4
a1276 2
      pipe->bind_fs_state(pipe,
                          blitter_get_fs_texfetch_col(ctx, src->target));
d1278 17
a1294 3
      fb_state.nr_cbufs = 1;
      fb_state.cbufs[0] = dstsurf;
      fb_state.zsbuf = 0;
d1297 31
a1327 1
   normalized = src->target != PIPE_TEXTURE_RECT;
d1329 5
a1333 3
   /* Initialize sampler view. */
   u_sampler_view_default_template(&viewTempl, src, util_format_linear(src->format));
   view = pipe->create_sampler_view(pipe, src, &viewTempl);
a1334 5
   /* Set rasterizer state, shaders, and textures. */
   pipe->bind_rasterizer_state(pipe, ctx->rs_state);
   pipe->bind_vs_state(pipe, ctx->vs);
   pipe->bind_fragment_sampler_states(pipe, 1,
                                      blitter_get_sampler_state(ctx, srclevel, normalized));
d1336 3
a1338 2
   pipe->set_fragment_sampler_views(pipe, 1, &view);
   pipe->set_framebuffer_state(pipe, &fb_state);
d1340 2
a1341 1
   blitter_set_dst_dimensions(ctx, dstsurf->width, dstsurf->height);
d1343 4
a1346 1
   switch (src->target) {
d1348 35
a1382 12
      case PIPE_TEXTURE_1D:
      case PIPE_TEXTURE_2D:
      case PIPE_TEXTURE_RECT:
         {
            /* Set texture coordinates. */
            float coord[4];
            get_texcoords(src, srclevel, srcbox->x, srcbox->y,
                          srcbox->x+width, srcbox->y+height, normalized, coord);

            /* Draw. */
            blitter->draw_rectangle(blitter, dstx, dsty, dstx+width, dsty+height, 0,
                                    UTIL_BLITTER_ATTRIB_TEXCOORD, coord);
d1384 1
a1384 1
         break;
d1386 28
a1413 20
      /* Draw the quad with the generic codepath. */
      case PIPE_TEXTURE_3D:
      case PIPE_TEXTURE_CUBE:
         /* Set texture coordinates. */
         if (src->target == PIPE_TEXTURE_3D)
            blitter_set_texcoords_3d(ctx, src, srclevel, srcbox->z,
                                     srcbox->x, srcbox->y,
                                     srcbox->x + width, srcbox->y + height);
         else
            blitter_set_texcoords_cube(ctx, src, srclevel, srcbox->z,
                                       srcbox->x, srcbox->y,
                                       srcbox->x + width, srcbox->y + height);

         /* Draw. */
         blitter_set_rectangle(ctx, dstx, dsty, dstx+width, dsty+height, 0);
         ctx->base.pipe->redefine_user_buffer(ctx->base.pipe, ctx->vbuf,
                                              0, ctx->vbuf->width0);
         util_draw_vertex_buffer(ctx->base.pipe, NULL, ctx->vbuf, 0,
                                 PIPE_PRIM_TRIANGLE_FAN, 4, 2);
         break;
d1415 10
a1424 3
      default:
         assert(0);
         return;
d1427 21
a1447 1
   blitter_restore_CSOs(ctx);
d1449 19
a1467 2
   pipe_surface_reference(&dstsurf, NULL);
   pipe_sampler_view_reference(&view, NULL);
d1473 1
a1473 1
                                      const float *rgba,
d1486 5
a1490 2
   blitter_check_saved_CSOs(ctx);
   assert(blitter->saved_fb_state.nr_cbufs != ~0);
d1492 2
a1493 2
   /* bind CSOs */
   pipe->bind_blend_state(pipe, ctx->blend_write_color);
d1495 1
a1495 3
   pipe->bind_rasterizer_state(pipe, ctx->rs_state);
   pipe->bind_fs_state(pipe, blitter_get_fs_col(ctx, 1));
   pipe->bind_vs_state(pipe, ctx->vs);
d1505 1
d1507 1
d1510 7
a1516 2
                           UTIL_BLITTER_ATTRIB_COLOR, rgba);
   blitter_restore_CSOs(ctx);
d1538 5
a1542 2
   blitter_check_saved_CSOs(ctx);
   assert(blitter->saved_fb_state.nr_cbufs != ~0);
d1544 2
a1545 2
   /* bind CSOs */
   pipe->bind_blend_state(pipe, ctx->blend_keep_color);
d1563 1
a1563 3
   pipe->bind_rasterizer_state(pipe, ctx->rs_state);
   pipe->bind_fs_state(pipe, blitter_get_fs_col(ctx, 0));
   pipe->bind_vs_state(pipe, ctx->vs);
d1573 1
d1575 1
d1577 2
a1578 1
   blitter->draw_rectangle(blitter, dstx, dsty, dstx+width, dsty+height, depth,
d1580 6
a1585 1
   blitter_restore_CSOs(ctx);
d1592 1
d1604 9
a1612 5
   blitter_check_saved_CSOs(ctx);
   assert(blitter->saved_fb_state.nr_cbufs != ~0);

   /* bind CSOs */
   pipe->bind_blend_state(pipe, ctx->blend_write_color);
d1614 1
a1614 4

   pipe->bind_rasterizer_state(pipe, ctx->rs_state);
   pipe->bind_fs_state(pipe, blitter_get_fs_col(ctx, 0));
   pipe->bind_vs_state(pipe, ctx->vs);
d1630 1
d1632 1
d1636 241
a1876 1
   blitter_restore_CSOs(ctx);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a88 1
   void *dsa_flush_depth_stencil;
a157 4
   dsa.depth.writemask = 1;
   ctx->dsa_flush_depth_stencil =
      pipe->create_depth_stencil_alpha_state(pipe, &dsa);

d223 4
a226 3
   ctx->vbuf = pipe_buffer_create(ctx->base.pipe->screen,
                                  PIPE_BIND_VERTEX_BUFFER,
                                  sizeof(ctx->vertices));
a243 1
   pipe->delete_depth_stencil_alpha_state(pipe, ctx->dsa_flush_depth_stencil);
d270 6
a305 1

d349 6
a517 16
static void blitter_draw_quad(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_box box;

   /* write vertices and draw them */
   u_box_1d(0, sizeof(ctx->vertices), &box);
   pipe->transfer_inline_write(pipe, ctx->vbuf, 0,
                               PIPE_TRANSFER_WRITE | PIPE_TRANSFER_DISCARD,
                               &box, ctx->vertices, sizeof(ctx->vertices), 0);

   util_draw_vertex_buffer(pipe, ctx->vbuf, 0, PIPE_PRIM_TRIANGLE_FAN,
                           4,  /* verts */
                           2); /* attribs/vert */
}

d642 4
a645 1
   blitter_draw_quad(ctx);
d648 7
a654 6
void util_blitter_clear(struct blitter_context *blitter,
                        unsigned width, unsigned height,
                        unsigned num_cbufs,
                        unsigned clear_buffers,
                        const float *rgba,
                        double depth, unsigned stencil)
d665 3
a667 1
   if (clear_buffers & PIPE_CLEAR_COLOR)
d669 1
a669 1
   else
d671 1
d673 3
a675 2
   if ((clear_buffers & PIPE_CLEAR_DEPTHSTENCIL) == PIPE_CLEAR_DEPTHSTENCIL) {
      sr.ref_value[0] = stencil & 0xff;
d677 1
a677 3
      pipe->set_stencil_ref(pipe, &sr);
   }
   else if (clear_buffers & PIPE_CLEAR_DEPTH) {
d679 1
a679 3
   }
   else if (clear_buffers & PIPE_CLEAR_STENCIL) {
      sr.ref_value[0] = stencil & 0xff;
d681 2
a682 1
      pipe->set_stencil_ref(pipe, &sr);
d684 3
a686 2
   else
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
d699 21
a756 3
   } else {
      assert(util_is_format_compatible(util_format_description(dst->format),
                                       util_format_description(src->format)));
d773 1
a773 1
    if ((!ignore_stencil && is_stencil) ||
d775 1
a775 1
                                    dst->nr_samples, bind, 0) ||
d777 2
a778 1
                                    src->nr_samples, PIPE_BIND_SAMPLER_VIEW, 0)) {
d781 1
d788 1
d827 1
a827 1
   u_sampler_view_default_template(&viewTempl, src, src->format);
d873 4
a876 1
         blitter_draw_quad(ctx);
a1035 9
}

/* flush a region of a depth stencil surface for r300g */
void util_blitter_flush_depth_stencil(struct blitter_context *blitter,
                                      struct pipe_surface *dstsurf)
{
	struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
	util_blitter_custom_depth_stencil(blitter, dstsurf, NULL,
					  ctx->dsa_flush_depth_stencil, 0.0f);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d29 2
a30 2
 * Blitter utility to facilitate acceleration of the clear, surface_copy,
 * and surface_fill functions.
d46 1
a46 2
#include "util/u_pack_color.h"
#include "util/u_rect.h"
d48 1
d55 1
a55 1
   struct blitter_context blitter;
d57 1
a57 2
   struct pipe_context *pipe; /**< pipe context */
   struct pipe_buffer *vbuf;  /**< quad */
d66 1
a66 2
   void *vs_col; /**< Vertex shader which passes {pos, color} to the output */
   void *vs_tex; /**< Vertex shader which passes {pos, texcoord} to the output.*/
d69 2
a70 2
   /* FS which outputs a color to multiple color buffers. */
   void *fs_col[PIPE_MAX_COLOR_BUFS];
d88 4
d94 1
a94 1
   void *sampler_state[PIPE_MAX_TEXTURE_LEVELS];
d104 4
d110 8
d121 3
a123 3
   struct pipe_blend_state blend = { 0 };
   struct pipe_depth_stencil_alpha_state dsa = { { 0 } };
   struct pipe_rasterizer_state rs_state = { 0 };
d125 1
d132 2
a133 1
   ctx->pipe = pipe;
d136 10
a145 8
   ctx->blitter.saved_blend_state = INVALID_PTR;
   ctx->blitter.saved_dsa_state = INVALID_PTR;
   ctx->blitter.saved_rs_state = INVALID_PTR;
   ctx->blitter.saved_fs = INVALID_PTR;
   ctx->blitter.saved_vs = INVALID_PTR;
   ctx->blitter.saved_fb_state.nr_cbufs = ~0;
   ctx->blitter.saved_num_textures = ~0;
   ctx->blitter.saved_num_sampler_states = ~0;
d148 1
d155 1
d159 4
d178 6
a183 2
   /* The DSA state objects which write depth and stencil are created
    * on-demand. */
d190 1
d196 1
a196 2
   rs_state.front_winding = PIPE_WINDING_CW;
   rs_state.cull_mode = PIPE_WINDING_NONE;
d201 10
d213 1
a213 9
   /* vertex shaders */
   {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_COLOR };
      const uint semantic_indices[] = { 0, 0 };
      ctx->vs_col =
         util_make_vertex_passthrough_shader(pipe, 2, semantic_names,
                                             semantic_indices);
   }
d218 1
a218 1
      ctx->vs_tex =
d228 2
a229 3
   ctx->vbuf = pipe_buffer_create(ctx->pipe->screen,
                                  32,
                                  PIPE_BUFFER_USAGE_VERTEX,
d232 1
a232 1
   return &ctx->blitter;
d238 1
a238 1
   struct pipe_context *pipe = ctx->pipe;
d247 2
d251 2
a252 2
   pipe->delete_vs_state(pipe, ctx->vs_col);
   pipe->delete_vs_state(pipe, ctx->vs_tex);
d261 1
a261 1
   for (i = 0; i < PIPE_MAX_COLOR_BUFS && ctx->fs_col[i]; i++)
d265 1
a265 1
   for (i = 0; i < PIPE_MAX_TEXTURE_LEVELS; i++)
d269 1
a269 1
   pipe_buffer_reference(&ctx->vbuf, NULL);
d276 6
a281 5
   assert(ctx->blitter.saved_blend_state != INVALID_PTR &&
          ctx->blitter.saved_dsa_state != INVALID_PTR &&
          ctx->blitter.saved_rs_state != INVALID_PTR &&
          ctx->blitter.saved_fs != INVALID_PTR &&
          ctx->blitter.saved_vs != INVALID_PTR);
d286 2
a287 1
   struct pipe_context *pipe = ctx->pipe;
d290 13
a302 11
   pipe->bind_blend_state(pipe, ctx->blitter.saved_blend_state);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->blitter.saved_dsa_state);
   pipe->bind_rasterizer_state(pipe, ctx->blitter.saved_rs_state);
   pipe->bind_fs_state(pipe, ctx->blitter.saved_fs);
   pipe->bind_vs_state(pipe, ctx->blitter.saved_vs);

   ctx->blitter.saved_blend_state = INVALID_PTR;
   ctx->blitter.saved_dsa_state = INVALID_PTR;
   ctx->blitter.saved_rs_state = INVALID_PTR;
   ctx->blitter.saved_fs = INVALID_PTR;
   ctx->blitter.saved_vs = INVALID_PTR;
d304 1
a304 1
   pipe->set_stencil_ref(pipe, &ctx->blitter.saved_stencil_ref);
d306 2
a307 2
   pipe->set_viewport_state(pipe, &ctx->blitter.saved_viewport);
   pipe->set_clip_state(pipe, &ctx->blitter.saved_clip);
d311 4
a314 3
   if (ctx->blitter.saved_fb_state.nr_cbufs != ~0) {
      pipe->set_framebuffer_state(pipe, &ctx->blitter.saved_fb_state);
      ctx->blitter.saved_fb_state.nr_cbufs = ~0;
d317 1
a317 1
   if (ctx->blitter.saved_num_sampler_states != ~0) {
d319 3
a321 3
                                         ctx->blitter.saved_num_sampler_states,
                                         ctx->blitter.saved_sampler_states);
      ctx->blitter.saved_num_sampler_states = ~0;
d324 24
a347 5
   if (ctx->blitter.saved_num_textures != ~0) {
      pipe->set_fragment_sampler_textures(pipe,
                                          ctx->blitter.saved_num_textures,
                                          ctx->blitter.saved_textures);
      ctx->blitter.saved_num_textures = ~0;
a353 1
                                  unsigned width, unsigned height,
d359 2
a360 2
   ctx->vertices[0][0][0] = (float)x1 / width * 2.0f - 1.0f; /*v0.x*/
   ctx->vertices[0][0][1] = (float)y1 / height * 2.0f - 1.0f; /*v0.y*/
d362 2
a363 2
   ctx->vertices[1][0][0] = (float)x2 / width * 2.0f - 1.0f; /*v1.x*/
   ctx->vertices[1][0][1] = (float)y1 / height * 2.0f - 1.0f; /*v1.y*/
d365 2
a366 2
   ctx->vertices[2][0][0] = (float)x2 / width * 2.0f - 1.0f; /*v2.x*/
   ctx->vertices[2][0][1] = (float)y2 / height * 2.0f - 1.0f; /*v2.y*/
d368 2
a369 2
   ctx->vertices[3][0][0] = (float)x1 / width * 2.0f - 1.0f; /*v3.x*/
   ctx->vertices[3][0][1] = (float)y2 / height * 2.0f - 1.0f; /*v3.y*/
d375 2
a376 2
   ctx->viewport.scale[0] = 0.5f * width;
   ctx->viewport.scale[1] = 0.5f * height;
d379 2
a380 2
   ctx->viewport.translate[0] = 0.5f * width;
   ctx->viewport.translate[1] = 0.5f * height;
d383 1
a383 1
   ctx->pipe->set_viewport_state(ctx->pipe, &ctx->viewport);
d386 1
a386 1
   ctx->pipe->set_clip_state(ctx->pipe, &ctx->clip);
d394 36
a429 5
   for (i = 0; i < 4; i++) {
      ctx->vertices[i][1][0] = rgba[0];
      ctx->vertices[i][1][1] = rgba[1];
      ctx->vertices[i][1][2] = rgba[2];
      ctx->vertices[i][1][3] = rgba[3];
d433 16
d450 2
a451 1
                                     struct pipe_surface *surf,
d455 2
a456 8
   int i;
   float s1 = x1 / (float)surf->width;
   float t1 = y1 / (float)surf->height;
   float s2 = x2 / (float)surf->width;
   float t2 = y2 / (float)surf->height;

   ctx->vertices[0][1][0] = s1; /*t0.s*/
   ctx->vertices[0][1][1] = t1; /*t0.t*/
d458 2
a459 8
   ctx->vertices[1][1][0] = s2; /*t1.s*/
   ctx->vertices[1][1][1] = t1; /*t1.t*/

   ctx->vertices[2][1][0] = s2; /*t2.s*/
   ctx->vertices[2][1][1] = t2; /*t2.t*/

   ctx->vertices[3][1][0] = s1; /*t3.s*/
   ctx->vertices[3][1][1] = t2; /*t3.t*/
d468 3
a470 1
                                     struct pipe_surface *surf,
d475 1
a475 2
   float depth = u_minify(surf->texture->depth0, surf->level);
   float r = surf->zslice / depth;
d477 1
a477 1
   blitter_set_texcoords_2d(ctx, surf, x1, y1, x2, y2);
d484 2
a485 1
                                       struct pipe_surface *surf,
d490 1
a490 4
   float s1 = x1 / (float)surf->width;
   float t1 = y1 / (float)surf->height;
   float s2 = x2 / (float)surf->width;
   float t2 = y2 / (float)surf->height;
d493 2
a494 8
   st[0][0] = s1;
   st[0][1] = t1;
   st[1][0] = s2;
   st[1][1] = t1;
   st[2][0] = s2;
   st[2][1] = t2;
   st[3][0] = s1;
   st[3][1] = t2;
d496 1
a496 1
   util_map_texcoords2d_onto_cubemap(surf->face,
d505 7
d514 2
a515 1
   struct pipe_context *pipe = ctx->pipe;
d518 4
a521 2
   pipe_buffer_write(pipe->screen, ctx->vbuf,
                     0, sizeof(ctx->vertices), ctx->vertices);
d530 1
a530 1
                                 int miplevel)
d532 1
a532 1
   struct pipe_context *pipe = ctx->pipe;
d538 1
a538 1
   if (!ctx->sampler_state[miplevel]) {
d542 1
d544 1
a544 1
      ctx->sampler_state[miplevel] = pipe->create_sampler_state(pipe,
d550 1
a550 1
   return &ctx->sampler_state[miplevel];
d556 1
a556 2
   struct pipe_context *pipe = ctx->pipe;
   unsigned index = num_cbufs ? num_cbufs - 1 : 0;
d560 29
a588 3
   if (!ctx->fs_col[index])
      ctx->fs_col[index] =
         util_make_fragment_clonecolor_shader(pipe, num_cbufs);
a589 2
   return ctx->fs_col[index];
}
d595 1
a595 1
   struct pipe_context *pipe = ctx->pipe;
d601 4
a604 19
      switch (tex_target) {
         case PIPE_TEXTURE_1D:
            ctx->fs_texfetch_col[PIPE_TEXTURE_1D] =
               util_make_fragment_tex_shader(pipe, TGSI_TEXTURE_1D);
            break;
         case PIPE_TEXTURE_2D:
            ctx->fs_texfetch_col[PIPE_TEXTURE_2D] =
               util_make_fragment_tex_shader(pipe, TGSI_TEXTURE_2D);
            break;
         case PIPE_TEXTURE_3D:
            ctx->fs_texfetch_col[PIPE_TEXTURE_3D] =
               util_make_fragment_tex_shader(pipe, TGSI_TEXTURE_3D);
            break;
         case PIPE_TEXTURE_CUBE:
            ctx->fs_texfetch_col[PIPE_TEXTURE_CUBE] =
               util_make_fragment_tex_shader(pipe, TGSI_TEXTURE_CUBE);
            break;
         default:;
      }
d614 1
a614 1
   struct pipe_context *pipe = ctx->pipe;
d620 5
a624 19
      switch (tex_target) {
         case PIPE_TEXTURE_1D:
            ctx->fs_texfetch_depth[PIPE_TEXTURE_1D] =
               util_make_fragment_tex_shader_writedepth(pipe, TGSI_TEXTURE_1D);
            break;
         case PIPE_TEXTURE_2D:
            ctx->fs_texfetch_depth[PIPE_TEXTURE_2D] =
               util_make_fragment_tex_shader_writedepth(pipe, TGSI_TEXTURE_2D);
            break;
         case PIPE_TEXTURE_3D:
            ctx->fs_texfetch_depth[PIPE_TEXTURE_3D] =
               util_make_fragment_tex_shader_writedepth(pipe, TGSI_TEXTURE_3D);
            break;
         case PIPE_TEXTURE_CUBE:
            ctx->fs_texfetch_depth[PIPE_TEXTURE_CUBE] =
               util_make_fragment_tex_shader_writedepth(pipe,TGSI_TEXTURE_CUBE);
            break;
         default:;
      }
d630 25
d663 1
a663 1
   struct pipe_context *pipe = ctx->pipe;
d676 1
a676 1
   if (clear_buffers & PIPE_CLEAR_DEPTHSTENCIL) {
d681 8
d693 1
d695 1
a695 1
   pipe->bind_vs_state(pipe, ctx->vs_col);
d697 3
a699 3
   blitter_set_clear_color(ctx, rgba);
   blitter_set_rectangle(ctx, 0, 0, width, height, width, height, depth);
   blitter_draw_quad(ctx);
d703 15
a717 18
static boolean
is_overlap(unsigned sx1, unsigned sx2, unsigned sy1, unsigned sy2,
           unsigned dx1, unsigned dx2, unsigned dy1, unsigned dy2)
{
    if (sx1 >= dx2 || sx2 <= dx1 || sy1 >= dy2 || sy2 <= dy1) {
        return FALSE;
    } else {
        return TRUE;
    }
}

static void util_blitter_do_copy(struct blitter_context *blitter,
				 struct pipe_surface *dst,
				 unsigned dstx, unsigned dsty,
				 struct pipe_surface *src,
				 unsigned srcx, unsigned srcy,
				 unsigned width, unsigned height,
				 boolean is_depth)
d720 3
a722 1
   struct pipe_context *pipe = ctx->pipe;
d724 11
d736 43
d780 1
a780 1
   assert(blitter->saved_num_textures != ~0);
a781 1
   assert(src->texture->target < PIPE_MAX_TEXTURE_TYPES);
d783 3
a785 3
   /* bind CSOs */
   fb_state.width = dst->width;
   fb_state.height = dst->height;
d792 1
a792 1
         blitter_get_fs_texfetch_depth(ctx, src->texture->target));
d795 1
a795 1
      fb_state.zsbuf = dst;
d800 1
a800 1
         blitter_get_fs_texfetch_col(ctx, src->texture->target));
d803 1
a803 1
      fb_state.cbufs[0] = dst;
d807 7
d815 1
a815 1
   pipe->bind_vs_state(pipe, ctx->vs_tex);
d817 3
a819 2
      blitter_get_sampler_state(ctx, src->level));
   pipe->set_fragment_sampler_textures(pipe, 1, &src->texture);
d822 4
a825 2
   /* set texture coordinates */
   switch (src->texture->target) {
d828 11
a838 2
         blitter_set_texcoords_2d(ctx, src, srcx, srcy,
                                  srcx+width, srcy+height);
d840 2
a842 3
         blitter_set_texcoords_3d(ctx, src, srcx, srcy,
                                  srcx+width, srcy+height);
         break;
d844 13
a856 2
         blitter_set_texcoords_cube(ctx, src, srcx, srcy,
                                    srcx+width, srcy+height);
d858 1
d861 1
d864 1
a864 2
   blitter_set_rectangle(ctx, dstx, dsty, dstx+width, dsty+height, dst->width, dst->height, 0);
   blitter_draw_quad(ctx);
d866 2
d870 6
a875 6
static void util_blitter_overlap_copy(struct blitter_context *blitter,
				      struct pipe_surface *dst,
				      unsigned dstx, unsigned dsty,
				      struct pipe_surface *src,
				      unsigned srcx, unsigned srcy,
				      unsigned width, unsigned height)
d878 2
a879 2
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_screen *screen = pipe->screen;
d881 3
a883 3
   struct pipe_texture texTemp;
   struct pipe_texture *texture;
   struct pipe_surface *tex_surf;
d885 1
a885 1
   /* check whether the states are properly saved */
d887 1
d889 7
a895 7
   memset(&texTemp, 0, sizeof(texTemp));
   texTemp.target = PIPE_TEXTURE_2D;
   texTemp.format = dst->texture->format; /* XXX verify supported by driver! */
   texTemp.last_level = 0;
   texTemp.width0 = width;
   texTemp.height0 = height;
   texTemp.depth0 = 1;
d897 7
a903 3
   texture = screen->texture_create(screen, &texTemp);
   if (!texture)
      return;
d905 3
a907 15
   tex_surf = screen->get_tex_surface(screen, texture, 0, 0, 0,
				      PIPE_BUFFER_USAGE_GPU_READ | 
				      PIPE_BUFFER_USAGE_GPU_WRITE);

   /* blit from the src to the temp */
   util_blitter_do_copy(blitter, tex_surf, 0, 0,
			src, srcx, srcy,
			width, height,
			FALSE);
   util_blitter_do_copy(blitter, dst, dstx, dsty,
			tex_surf, 0, 0,
			width, height,
			FALSE);
   pipe_surface_reference(&tex_surf, NULL);
   pipe_texture_reference(&texture, NULL);
d911 8
a918 7
void util_blitter_copy(struct blitter_context *blitter,
                       struct pipe_surface *dst,
                       unsigned dstx, unsigned dsty,
                       struct pipe_surface *src,
                       unsigned srcx, unsigned srcy,
                       unsigned width, unsigned height,
                       boolean ignore_stencil)
d921 3
a923 4
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_screen *screen = pipe->screen;
   boolean is_stencil, is_depth;
   unsigned dst_tex_usage;
d925 2
a926 3
   /* give up if textures are not set */
   assert(dst->texture && src->texture);
   if (!dst->texture || !src->texture)
d929 18
a946 7
   if (dst->texture == src->texture) {
      if (is_overlap(srcx, srcx + width, srcy, srcy + height,
		             dstx, dstx + width, dsty, dsty + height)) {
         util_blitter_overlap_copy(blitter, dst, dstx, dsty, src, srcx, srcy,
                                   width, height);
         return;
      }
d948 8
a955 5
		   
   is_depth = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 0) != 0;
   is_stencil = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 1) != 0;
   dst_tex_usage = is_depth || is_stencil ? PIPE_TEXTURE_USAGE_DEPTH_STENCIL :
                                            PIPE_TEXTURE_USAGE_RENDER_TARGET;
d957 7
a963 11
   /* check if we can sample from and render to the surfaces */
   /* (assuming copying a stencil buffer is not possible) */
   if ((!ignore_stencil && is_stencil) ||
       !screen->is_format_supported(screen, dst->format, dst->texture->target,
                                    dst_tex_usage, 0) ||
       !screen->is_format_supported(screen, src->format, src->texture->target,
                                    PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
      util_surface_copy(pipe, FALSE, dst, dstx, dsty, src, srcx, srcy,
                        width, height);
      return;
   }
d965 3
a967 6
   /* check whether the states are properly saved */
   blitter_check_saved_CSOs(ctx);
   util_blitter_do_copy(blitter,
			dst, dstx, dsty,
			src, srcx, srcy,
			width, height, is_depth);
d971 5
a975 5
void util_blitter_fill(struct blitter_context *blitter,
                       struct pipe_surface *dst,
                       unsigned dstx, unsigned dsty,
                       unsigned width, unsigned height,
                       unsigned value)
d978 1
a978 2
   struct pipe_context *pipe = ctx->pipe;
   struct pipe_screen *screen = pipe->screen;
a979 8
   float rgba[4];
   ubyte ub_rgba[4] = {0};
   union util_color color;
   int i;

   assert(dst->texture);
   if (!dst->texture)
      return;
d981 2
a982 5
   /* check if we can render to the surface */
   if (util_format_is_depth_or_stencil(dst->format) || /* unlikely, but you never know */
       !screen->is_format_supported(screen, dst->format, dst->texture->target,
                                    PIPE_TEXTURE_USAGE_RENDER_TARGET, 0)) {
      util_surface_fill(pipe, dst, dstx, dsty, width, height, value);
a983 8
   }

   /* unpack the color */
   color.ui = value;
   util_unpack_color_ub(dst->format, &color,
                        ub_rgba, ub_rgba+1, ub_rgba+2, ub_rgba+3);
   for (i = 0; i < 4; i++)
      rgba[i] = ubyte_to_float(ub_rgba[i]);
d991 2
a992 1
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
d994 3
a996 2
   pipe->bind_fs_state(pipe, blitter_get_fs_col(ctx, 1));
   pipe->bind_vs_state(pipe, ctx->vs_col);
d999 2
a1000 2
   fb_state.width = dst->width;
   fb_state.height = dst->height;
d1002 8
a1009 2
   fb_state.cbufs[0] = dst;
   fb_state.zsbuf = 0;
d1012 3
a1014 3
   blitter_set_clear_color(ctx, rgba);
   blitter_set_rectangle(ctx, 0, 0, width, height, dst->width, dst->height, 0);
   blitter_draw_quad(ctx);
d1016 9
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d29 2
a30 2
 * Blitter utility to facilitate acceleration of the clear, clear_render_target, clear_depth_stencil
 * resource_copy_region functions.
d46 2
a47 1
#include "util/u_sampler.h"
a48 1
#include "util/u_surface.h"
d55 1
a55 1
   struct blitter_context base;
d57 2
a58 1
   struct pipe_resource *vbuf;  /**< quad */
d67 2
a68 1
   void *vs; /**< Vertex shader which passes {pos, generic} to the output.*/
d71 2
a72 2
   /* The shader at index i outputs color to color buffers 0,1,...,i-1. */
   void *fs_col[PIPE_MAX_COLOR_BUFS+1];
a89 4
   void *dsa_keep_depth_write_stencil;
   void *dsa_flush_depth_stencil;

   void *velem_state;
d92 1
a92 1
   void *sampler_state[PIPE_MAX_TEXTURE_LEVELS * 2];
a101 4

   /* Destination surface dimensions. */
   unsigned dst_width;
   unsigned dst_height;
a103 8
static void blitter_draw_rectangle(struct blitter_context *blitter,
                                   unsigned x, unsigned y,
                                   unsigned width, unsigned height,
                                   float depth,
                                   enum blitter_attrib_type type,
                                   const float attrib[4]);


d107 3
a109 3
   struct pipe_blend_state blend;
   struct pipe_depth_stencil_alpha_state dsa;
   struct pipe_rasterizer_state rs_state;
a110 1
   struct pipe_vertex_element velem[2];
d117 1
a117 2
   ctx->base.pipe = pipe;
   ctx->base.draw_rectangle = blitter_draw_rectangle;
d120 8
a127 10
   ctx->base.saved_blend_state = INVALID_PTR;
   ctx->base.saved_dsa_state = INVALID_PTR;
   ctx->base.saved_rs_state = INVALID_PTR;
   ctx->base.saved_fs = INVALID_PTR;
   ctx->base.saved_vs = INVALID_PTR;
   ctx->base.saved_velem_state = INVALID_PTR;
   ctx->base.saved_fb_state.nr_cbufs = ~0;
   ctx->base.saved_num_sampler_views = ~0;
   ctx->base.saved_num_sampler_states = ~0;
   ctx->base.saved_num_vertex_buffers = ~0;
a129 1
   memset(&blend, 0, sizeof(blend));
a135 1
   memset(&dsa, 0, sizeof(dsa));
a138 4
   dsa.depth.writemask = 1;
   ctx->dsa_flush_depth_stencil =
      pipe->create_depth_stencil_alpha_state(pipe, &dsa);

d154 2
a155 6


   dsa.depth.enabled = 0;
   dsa.depth.writemask = 0;
   ctx->dsa_keep_depth_write_stencil =
      pipe->create_depth_stencil_alpha_state(pipe, &dsa);
a161 1
   sampler_state->normalized_coords = TRUE;
d167 2
a168 1
   rs_state.cull_face = PIPE_FACE_NONE;
a172 10
   /* vertex elements state */
   memset(&velem[0], 0, sizeof(velem[0]) * 2);
   for (i = 0; i < 2; i++) {
      velem[i].src_offset = i * 4 * sizeof(float);
      velem[i].instance_divisor = 0;
      velem[i].vertex_buffer_index = 0;
      velem[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
   }
   ctx->velem_state = pipe->create_vertex_elements_state(pipe, 2, &velem[0]);

d175 9
a183 1
   /* vertex shader */
d188 1
a188 1
      ctx->vs =
d198 3
a200 2
   ctx->vbuf = pipe_buffer_create(ctx->base.pipe->screen,
                                  PIPE_BIND_VERTEX_BUFFER,
d203 1
a203 1
   return &ctx->base;
d209 1
a209 1
   struct pipe_context *pipe = blitter->pipe;
a217 2
   pipe->delete_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_write_stencil);
   pipe->delete_depth_stencil_alpha_state(pipe, ctx->dsa_flush_depth_stencil);
d220 2
a221 2
   pipe->delete_vs_state(pipe, ctx->vs);
   pipe->delete_vertex_elements_state(pipe, ctx->velem_state);
d230 1
a230 1
   for (i = 0; i <= PIPE_MAX_COLOR_BUFS; i++)
d234 1
a234 1
   for (i = 0; i < PIPE_MAX_TEXTURE_LEVELS * 2; i++)
d238 1
a238 1
   pipe_resource_reference(&ctx->vbuf, NULL);
d245 5
a249 6
   assert(ctx->base.saved_blend_state != INVALID_PTR &&
          ctx->base.saved_dsa_state != INVALID_PTR &&
          ctx->base.saved_rs_state != INVALID_PTR &&
          ctx->base.saved_fs != INVALID_PTR &&
          ctx->base.saved_vs != INVALID_PTR &&
          ctx->base.saved_velem_state != INVALID_PTR);
d254 1
a254 2
   struct pipe_context *pipe = ctx->base.pipe;
   unsigned i;
d257 11
a267 13
   pipe->bind_blend_state(pipe, ctx->base.saved_blend_state);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->base.saved_dsa_state);
   pipe->bind_rasterizer_state(pipe, ctx->base.saved_rs_state);
   pipe->bind_fs_state(pipe, ctx->base.saved_fs);
   pipe->bind_vs_state(pipe, ctx->base.saved_vs);
   pipe->bind_vertex_elements_state(pipe, ctx->base.saved_velem_state);

   ctx->base.saved_blend_state = INVALID_PTR;
   ctx->base.saved_dsa_state = INVALID_PTR;
   ctx->base.saved_rs_state = INVALID_PTR;
   ctx->base.saved_fs = INVALID_PTR;
   ctx->base.saved_vs = INVALID_PTR;
   ctx->base.saved_velem_state = INVALID_PTR;
d269 1
a269 1
   pipe->set_stencil_ref(pipe, &ctx->base.saved_stencil_ref);
d271 2
a272 2
   pipe->set_viewport_state(pipe, &ctx->base.saved_viewport);
   pipe->set_clip_state(pipe, &ctx->base.saved_clip);
d276 3
a278 4
   if (ctx->base.saved_fb_state.nr_cbufs != ~0) {
      pipe->set_framebuffer_state(pipe, &ctx->base.saved_fb_state);
      util_unreference_framebuffer_state(&ctx->base.saved_fb_state);
      ctx->base.saved_fb_state.nr_cbufs = ~0;
d281 1
a281 1
   if (ctx->base.saved_num_sampler_states != ~0) {
d283 3
a285 3
                                         ctx->base.saved_num_sampler_states,
                                         ctx->base.saved_sampler_states);
      ctx->base.saved_num_sampler_states = ~0;
d288 5
a292 24
   if (ctx->base.saved_num_sampler_views != ~0) {
      pipe->set_fragment_sampler_views(pipe,
                                       ctx->base.saved_num_sampler_views,
                                       ctx->base.saved_sampler_views);

      for (i = 0; i < ctx->base.saved_num_sampler_views; i++)
         pipe_sampler_view_reference(&ctx->base.saved_sampler_views[i],
                                     NULL);

      ctx->base.saved_num_sampler_views = ~0;
   }

   if (ctx->base.saved_num_vertex_buffers != ~0) {
      pipe->set_vertex_buffers(pipe,
                               ctx->base.saved_num_vertex_buffers,
                               ctx->base.saved_vertex_buffers);

      for (i = 0; i < ctx->base.saved_num_vertex_buffers; i++) {
         if (ctx->base.saved_vertex_buffers[i].buffer) {
            pipe_resource_reference(&ctx->base.saved_vertex_buffers[i].buffer,
                                    NULL);
         }
      }
      ctx->base.saved_num_vertex_buffers = ~0;
d299 1
d305 2
a306 2
   ctx->vertices[0][0][0] = (float)x1 / ctx->dst_width * 2.0f - 1.0f; /*v0.x*/
   ctx->vertices[0][0][1] = (float)y1 / ctx->dst_height * 2.0f - 1.0f; /*v0.y*/
d308 2
a309 2
   ctx->vertices[1][0][0] = (float)x2 / ctx->dst_width * 2.0f - 1.0f; /*v1.x*/
   ctx->vertices[1][0][1] = (float)y1 / ctx->dst_height * 2.0f - 1.0f; /*v1.y*/
d311 2
a312 2
   ctx->vertices[2][0][0] = (float)x2 / ctx->dst_width * 2.0f - 1.0f; /*v2.x*/
   ctx->vertices[2][0][1] = (float)y2 / ctx->dst_height * 2.0f - 1.0f; /*v2.y*/
d314 2
a315 2
   ctx->vertices[3][0][0] = (float)x1 / ctx->dst_width * 2.0f - 1.0f; /*v3.x*/
   ctx->vertices[3][0][1] = (float)y2 / ctx->dst_height * 2.0f - 1.0f; /*v3.y*/
d321 2
a322 2
   ctx->viewport.scale[0] = 0.5f * ctx->dst_width;
   ctx->viewport.scale[1] = 0.5f * ctx->dst_height;
d325 2
a326 2
   ctx->viewport.translate[0] = 0.5f * ctx->dst_width;
   ctx->viewport.translate[1] = 0.5f * ctx->dst_height;
d329 1
a329 1
   ctx->base.pipe->set_viewport_state(ctx->base.pipe, &ctx->viewport);
d332 1
a332 1
   ctx->base.pipe->set_clip_state(ctx->base.pipe, &ctx->clip);
d340 5
a344 36
   if (rgba) {
      for (i = 0; i < 4; i++) {
         ctx->vertices[i][1][0] = rgba[0];
         ctx->vertices[i][1][1] = rgba[1];
         ctx->vertices[i][1][2] = rgba[2];
         ctx->vertices[i][1][3] = rgba[3];
      }
   } else {
      for (i = 0; i < 4; i++) {
         ctx->vertices[i][1][0] = 0;
         ctx->vertices[i][1][1] = 0;
         ctx->vertices[i][1][2] = 0;
         ctx->vertices[i][1][3] = 0;
      }
   }
}

static void get_texcoords(struct pipe_resource *src,
                          unsigned level,
                          unsigned x1, unsigned y1,
                          unsigned x2, unsigned y2,
                          boolean normalized, float out[4])
{
   if(normalized)
   {
      out[0] = x1 / (float)u_minify(src->width0,  level);
      out[1] = y1 / (float)u_minify(src->height0, level);
      out[2] = x2 / (float)u_minify(src->width0,  level);
      out[3] = y2 / (float)u_minify(src->height0, level);
   }
   else
   {
      out[0] = x1;
      out[1] = y1;
      out[2] = x2;
      out[3] = y2;
a347 16
static void set_texcoords_in_vertices(const float coord[4],
                                      float *out, unsigned stride)
{
   out[0] = coord[0]; /*t0.s*/
   out[1] = coord[1]; /*t0.t*/
   out += stride;
   out[0] = coord[2]; /*t1.s*/
   out[1] = coord[1]; /*t1.t*/
   out += stride;
   out[0] = coord[2]; /*t2.s*/
   out[1] = coord[3]; /*t2.t*/
   out += stride;
   out[0] = coord[0]; /*t3.s*/
   out[1] = coord[3]; /*t3.t*/
}

d349 1
a349 2
                                     struct pipe_resource *src,
                                     unsigned level,
d353 14
a366 2
   unsigned i;
   float coord[4];
d368 2
a369 2
   get_texcoords(src, level, x1, y1, x2, y2, TRUE, coord);
   set_texcoords_in_vertices(coord, &ctx->vertices[0][1][0], 8);
d378 1
a378 3
                                     struct pipe_resource *src,
                                     unsigned level,
                                     unsigned zslice,
d383 2
a384 1
   float r = zslice / (float)u_minify(src->depth0, level);
d386 1
a386 1
   blitter_set_texcoords_2d(ctx, src, level, x1, y1, x2, y2);
d393 1
a393 2
                                       struct pipe_resource *src,
                                       unsigned level, unsigned face,
d398 4
a401 1
   float coord[4];
d404 8
a411 2
   get_texcoords(src, level, x1, y1, x2, y2, TRUE, coord);
   set_texcoords_in_vertices(coord, &st[0][0], 2);
d413 1
a413 1
   util_map_texcoords2d_onto_cubemap(face,
a421 7
static void blitter_set_dst_dimensions(struct blitter_context_priv *ctx,
                                       unsigned width, unsigned height)
{
   ctx->dst_width = width;
   ctx->dst_height = height;
}

d424 1
a424 2
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_box box;
d427 2
a428 4
   u_box_1d(0, sizeof(ctx->vertices), &box);
   pipe->transfer_inline_write(pipe, ctx->vbuf, 0,
                               PIPE_TRANSFER_WRITE | PIPE_TRANSFER_DISCARD,
                               &box, ctx->vertices, sizeof(ctx->vertices), 0);
d437 1
a437 1
                                 int miplevel, boolean normalized)
d439 1
a439 1
   struct pipe_context *pipe = ctx->base.pipe;
d445 1
a445 1
   if (!ctx->sampler_state[miplevel * 2 + normalized]) {
a448 1
      sampler_state->normalized_coords = normalized;
d450 1
a450 1
      ctx->sampler_state[miplevel * 2 + normalized] = pipe->create_sampler_state(pipe,
d456 1
a456 1
   return &ctx->sampler_state[miplevel * 2 + normalized];
d462 2
a463 1
   struct pipe_context *pipe = ctx->base.pipe;
d467 5
a471 28
   if (!ctx->fs_col[num_cbufs])
      ctx->fs_col[num_cbufs] =
         util_make_fragment_cloneinput_shader(pipe, num_cbufs,
                                              TGSI_SEMANTIC_GENERIC,
                                              TGSI_INTERPOLATE_LINEAR);

   return ctx->fs_col[num_cbufs];
}

/** Convert PIPE_TEXTURE_x to TGSI_TEXTURE_x */
static unsigned
pipe_tex_to_tgsi_tex(enum pipe_texture_target pipe_tex_target)
{
   switch (pipe_tex_target) {
   case PIPE_TEXTURE_1D:
      return TGSI_TEXTURE_1D;
   case PIPE_TEXTURE_2D:
      return TGSI_TEXTURE_2D;
   case PIPE_TEXTURE_RECT:
      return TGSI_TEXTURE_RECT;
   case PIPE_TEXTURE_3D:
      return TGSI_TEXTURE_3D;
   case PIPE_TEXTURE_CUBE:
      return TGSI_TEXTURE_CUBE;
   default:
      assert(0 && "unexpected texture target");
      return TGSI_TEXTURE_UNKNOWN;
   }
a473 1

d478 1
a478 1
   struct pipe_context *pipe = ctx->base.pipe;
d484 19
a502 4
      unsigned tgsi_tex = pipe_tex_to_tgsi_tex(tex_target);

      ctx->fs_texfetch_col[tex_target] =
        util_make_fragment_tex_shader(pipe, tgsi_tex, TGSI_INTERPOLATE_LINEAR);
d512 1
a512 1
   struct pipe_context *pipe = ctx->base.pipe;
d518 19
a536 5
      unsigned tgsi_tex = pipe_tex_to_tgsi_tex(tex_target);

      ctx->fs_texfetch_depth[tex_target] =
         util_make_fragment_tex_shader_writedepth(pipe, tgsi_tex,
                                                  TGSI_INTERPOLATE_LINEAR);
a541 25
static void blitter_draw_rectangle(struct blitter_context *blitter,
                                   unsigned x1, unsigned y1,
                                   unsigned x2, unsigned y2,
                                   float depth,
                                   enum blitter_attrib_type type,
                                   const float attrib[4])
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;

   switch (type) {
      case UTIL_BLITTER_ATTRIB_COLOR:
         blitter_set_clear_color(ctx, attrib);
         break;

      case UTIL_BLITTER_ATTRIB_TEXCOORD:
         set_texcoords_in_vertices(attrib, &ctx->vertices[0][1][0], 8);
         break;

      default:;
   }

   blitter_set_rectangle(ctx, x1, y1, x2, y2, depth);
   blitter_draw_quad(ctx);
}

d550 1
a550 1
   struct pipe_context *pipe = ctx->base.pipe;
d563 1
a563 1
   if ((clear_buffers & PIPE_CLEAR_DEPTHSTENCIL) == PIPE_CLEAR_DEPTHSTENCIL) {
a567 8
   else if (clear_buffers & PIPE_CLEAR_DEPTH) {
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_write_depth_keep_stencil);
   }
   else if (clear_buffers & PIPE_CLEAR_STENCIL) {
      sr.ref_value[0] = stencil & 0xff;
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_write_stencil);
      pipe->set_stencil_ref(pipe, &sr);
   }
a571 1
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
d573 1
a573 1
   pipe->bind_vs_state(pipe, ctx->vs);
d575 3
a577 3
   blitter_set_dst_dimensions(ctx, width, height);
   blitter->draw_rectangle(blitter, 0, 0, width, height, depth,
                           UTIL_BLITTER_ATTRIB_COLOR, rgba);
d581 18
a598 15
static
boolean is_overlap(unsigned sx1, unsigned sx2, unsigned sy1, unsigned sy2,
                   unsigned dx1, unsigned dx2, unsigned dy1, unsigned dy2)
{
   return sx1 < dx2 && sx2 > dx1 && sy1 < dy2 && sy2 > dy1;
}

void util_blitter_copy_region(struct blitter_context *blitter,
                              struct pipe_resource *dst,
                              unsigned dstlevel,
                              unsigned dstx, unsigned dsty, unsigned dstz,
                              struct pipe_resource *src,
                              unsigned srclevel,
                              const struct pipe_box *srcbox,
                              boolean ignore_stencil)
d601 1
a601 3
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_screen *screen = pipe->screen;
   struct pipe_surface *dstsurf, surf_templ;
a602 11
   struct pipe_sampler_view viewTempl, *view;
   unsigned bind;
   unsigned width = srcbox->width;
   unsigned height = srcbox->height;
   boolean is_stencil, is_depth;
   boolean normalized;

   /* Give up if textures are not set. */
   assert(dst && src);
   if (!dst || !src)
      return;
a603 43
   /* Sanity checks. */
   if (dst == src) {
      assert(!is_overlap(srcbox->x, srcbox->x + width, srcbox->y, srcbox->y + height,
                         dstx, dstx + width, dsty, dsty + height));
   } else {
      assert(util_is_format_compatible(util_format_description(dst->format),
                                       util_format_description(src->format)));
   }
   assert(src->target < PIPE_MAX_TEXTURE_TYPES);
   /* XXX should handle 3d regions */
   assert(srcbox->depth == 1);

   /* Is this a ZS format? */
   is_depth = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 0) != 0;
   is_stencil = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 1) != 0;

   if (is_depth || is_stencil)
      bind = PIPE_BIND_DEPTH_STENCIL;
   else
      bind = PIPE_BIND_RENDER_TARGET;

   /* Check if we can sample from and render to the surfaces. */
   /* (assuming copying a stencil buffer is not possible) */
    if ((!ignore_stencil && is_stencil) ||
       !screen->is_format_supported(screen, dst->format, dst->target,
                                    dst->nr_samples, bind, 0) ||
       !screen->is_format_supported(screen, src->format, src->target,
                                    src->nr_samples, PIPE_BIND_SAMPLER_VIEW, 0)) {
      util_resource_copy_region(pipe, dst, dstlevel, dstx, dsty, dstz,
                                src, srclevel, srcbox);
      return;
   }

   /* Get surface. */
   memset(&surf_templ, 0, sizeof(surf_templ));
   u_surface_default_template(&surf_templ, dst, bind);
   surf_templ.u.tex.level = dstlevel;
   surf_templ.u.tex.first_layer = dstz;
   surf_templ.u.tex.last_layer = dstz;
   dstsurf = pipe->create_surface(pipe, dst, &surf_templ);

   /* Check whether the states are properly saved. */
   blitter_check_saved_CSOs(ctx);
d605 1
a605 1
   assert(blitter->saved_num_sampler_views != ~0);
d607 1
d609 3
a611 3
   /* Initialize framebuffer state. */
   fb_state.width = dstsurf->width;
   fb_state.height = dstsurf->height;
d618 1
a618 1
                          blitter_get_fs_texfetch_depth(ctx, src->target));
d621 1
a621 1
      fb_state.zsbuf = dstsurf;
d626 1
a626 1
                          blitter_get_fs_texfetch_col(ctx, src->target));
d629 1
a629 1
      fb_state.cbufs[0] = dstsurf;
a632 7
   normalized = src->target != PIPE_TEXTURE_RECT;

   /* Initialize sampler view. */
   u_sampler_view_default_template(&viewTempl, src, src->format);
   view = pipe->create_sampler_view(pipe, src, &viewTempl);

   /* Set rasterizer state, shaders, and textures. */
d634 1
a634 1
   pipe->bind_vs_state(pipe, ctx->vs);
d636 2
a637 3
                                      blitter_get_sampler_state(ctx, srclevel, normalized));
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
   pipe->set_fragment_sampler_views(pipe, 1, &view);
d640 2
a641 4
   blitter_set_dst_dimensions(ctx, dstsurf->width, dstsurf->height);

   switch (src->target) {
      /* Draw the quad with the draw_rectangle callback. */
d644 2
a645 11
      case PIPE_TEXTURE_RECT:
         {
            /* Set texture coordinates. */
            float coord[4];
            get_texcoords(src, srclevel, srcbox->x, srcbox->y,
                          srcbox->x+width, srcbox->y+height, normalized, coord);

            /* Draw. */
            blitter->draw_rectangle(blitter, dstx, dsty, dstx+width, dsty+height, 0,
                                    UTIL_BLITTER_ATTRIB_TEXCOORD, coord);
         }
a646 2

      /* Draw the quad with the generic codepath. */
d648 3
d652 2
a653 13
         /* Set texture coordinates. */
         if (src->target == PIPE_TEXTURE_3D)
            blitter_set_texcoords_3d(ctx, src, srclevel, srcbox->z,
                                     srcbox->x, srcbox->y,
                                     srcbox->x + width, srcbox->y + height);
         else
            blitter_set_texcoords_cube(ctx, src, srclevel, srcbox->z,
                                       srcbox->x, srcbox->y,
                                       srcbox->x + width, srcbox->y + height);

         /* Draw. */
         blitter_set_rectangle(ctx, dstx, dsty, dstx+width, dsty+height, 0);
         blitter_draw_quad(ctx);
a654 1

a656 1
         return;
d659 2
a660 1
   blitter_restore_CSOs(ctx);
a661 2
   pipe_surface_reference(&dstsurf, NULL);
   pipe_sampler_view_reference(&view, NULL);
d664 6
a669 6
/* Clear a region of a color surface to a constant value. */
void util_blitter_clear_render_target(struct blitter_context *blitter,
                                      struct pipe_surface *dstsurf,
                                      const float *rgba,
                                      unsigned dstx, unsigned dsty,
                                      unsigned width, unsigned height)
d672 2
a673 2
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;
d675 3
a677 3
   assert(dstsurf->texture);
   if (!dstsurf->texture)
      return;
d679 1
a679 1
   /* check the saved state */
a680 1
   assert(blitter->saved_fb_state.nr_cbufs != ~0);
d682 7
a688 7
   /* bind CSOs */
   pipe->bind_blend_state(pipe, ctx->blend_write_color);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
   pipe->bind_rasterizer_state(pipe, ctx->rs_state);
   pipe->bind_fs_state(pipe, blitter_get_fs_col(ctx, 1));
   pipe->bind_vs_state(pipe, ctx->vs);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
d690 3
a692 7
   /* set a framebuffer state */
   fb_state.width = dstsurf->width;
   fb_state.height = dstsurf->height;
   fb_state.nr_cbufs = 1;
   fb_state.cbufs[0] = dstsurf;
   fb_state.zsbuf = 0;
   pipe->set_framebuffer_state(pipe, &fb_state);
d694 15
a708 3
   blitter_set_dst_dimensions(ctx, dstsurf->width, dstsurf->height);
   blitter->draw_rectangle(blitter, dstx, dsty, dstx+width, dsty+height, 0,
                           UTIL_BLITTER_ATTRIB_COLOR, rgba);
d712 7
a718 8
/* Clear a region of a depth stencil surface. */
void util_blitter_clear_depth_stencil(struct blitter_context *blitter,
                                      struct pipe_surface *dstsurf,
                                      unsigned clear_flags,
                                      double depth,
                                      unsigned stencil,
                                      unsigned dstx, unsigned dsty,
                                      unsigned width, unsigned height)
d721 4
a724 3
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;
   struct pipe_stencil_ref sr = { { 0 } };
d726 3
a728 2
   assert(dstsurf->texture);
   if (!dstsurf->texture)
d731 13
a743 3
   /* check the saved state */
   blitter_check_saved_CSOs(ctx);
   assert(blitter->saved_fb_state.nr_cbufs != ~0);
d745 10
a754 14
   /* bind CSOs */
   pipe->bind_blend_state(pipe, ctx->blend_keep_color);
   if ((clear_flags & PIPE_CLEAR_DEPTHSTENCIL) == PIPE_CLEAR_DEPTHSTENCIL) {
      sr.ref_value[0] = stencil & 0xff;
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_write_depth_stencil);
      pipe->set_stencil_ref(pipe, &sr);
   }
   else if (clear_flags & PIPE_CLEAR_DEPTH) {
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_write_depth_keep_stencil);
   }
   else if (clear_flags & PIPE_CLEAR_STENCIL) {
      sr.ref_value[0] = stencil & 0xff;
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_write_stencil);
      pipe->set_stencil_ref(pipe, &sr);
a755 3
   else
      /* hmm that should be illegal probably, or make it a no-op somewhere */
      pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
d757 6
a762 16
   pipe->bind_rasterizer_state(pipe, ctx->rs_state);
   pipe->bind_fs_state(pipe, blitter_get_fs_col(ctx, 0));
   pipe->bind_vs_state(pipe, ctx->vs);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);

   /* set a framebuffer state */
   fb_state.width = dstsurf->width;
   fb_state.height = dstsurf->height;
   fb_state.nr_cbufs = 0;
   fb_state.cbufs[0] = 0;
   fb_state.zsbuf = dstsurf;
   pipe->set_framebuffer_state(pipe, &fb_state);

   blitter_set_dst_dimensions(ctx, dstsurf->width, dstsurf->height);
   blitter->draw_rectangle(blitter, dstx, dsty, dstx+width, dsty+height, depth,
                           UTIL_BLITTER_ATTRIB_NONE, NULL);
d766 5
a770 5
/* draw a rectangle across a region using a custom dsa stage - for r600g */
void util_blitter_custom_depth_stencil(struct blitter_context *blitter,
				       struct pipe_surface *zsurf,
				       struct pipe_surface *cbsurf,
				       void *dsa_stage, float depth)
d773 2
a774 1
   struct pipe_context *pipe = ctx->base.pipe;
d776 8
d785 5
a789 2
   assert(zsurf->texture);
   if (!zsurf->texture)
d791 8
d806 1
a806 2
   pipe->bind_depth_stencil_alpha_state(pipe, dsa_stage);

d808 2
a809 3
   pipe->bind_fs_state(pipe, blitter_get_fs_col(ctx, 0));
   pipe->bind_vs_state(pipe, ctx->vs);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
d812 2
a813 2
   fb_state.width = zsurf->width;
   fb_state.height = zsurf->height;
d815 2
a816 8
   if (cbsurf) {
	   fb_state.cbufs[0] = cbsurf;
	   fb_state.nr_cbufs = 1;
   } else {
	   fb_state.cbufs[0] = NULL;
	   fb_state.nr_cbufs = 0;
   }
   fb_state.zsbuf = zsurf;
d819 3
a821 3
   blitter_set_dst_dimensions(ctx, zsurf->width, zsurf->height);
   blitter->draw_rectangle(blitter, 0, 0, zsurf->width, zsurf->height, depth,
                           UTIL_BLITTER_ATTRIB_NONE, NULL);
a822 9
}

/* flush a region of a depth stencil surface for r300g */
void util_blitter_flush_depth_stencil(struct blitter_context *blitter,
                                      struct pipe_surface *dstsurf)
{
	struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
	util_blitter_custom_depth_stencil(blitter, dstsurf, NULL,
					  ctx->dsa_flush_depth_stencil, 0.0f);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d29 2
a30 2
 * Blitter utility to facilitate acceleration of the clear, clear_render_target,
 * clear_depth_stencil, resource_copy_region, and blit functions.
a49 1
#include "util/u_upload_mgr.h"
d57 1
a57 1
   struct u_upload_mgr *upload;
d62 1
a66 1
   void *vs_pos_only; /**< Vertex shader which passes pos to the output.*/
d69 2
a70 3
   void *fs_empty;
   void *fs_write_one_cbuf;
   void *fs_write_all_cbufs;
a78 8
   void *fs_texfetch_depthstencil[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_stencil[PIPE_MAX_TEXTURE_TYPES];

   /* FS which outputs one sample from a multisample texture. */
   void *fs_texfetch_col_msaa[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_depth_msaa[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_depthstencil_msaa[PIPE_MAX_TEXTURE_TYPES];
   void *fs_texfetch_stencil_msaa[PIPE_MAX_TEXTURE_TYPES];
d81 2
a82 1
   void *blend[PIPE_MASK_RGBA+1]; /**< blend state with writemask */
d89 1
a90 1
   /* Vertex elements states. */
a91 1
   void *velem_state_readbuf[4]; /**< X, XY, XYZ, XYZW */
d93 2
a94 5
   /* Sampler state. */
   void *sampler_state;
   void *sampler_state_linear;
   void *sampler_state_rect;
   void *sampler_state_rect_linear;
d97 1
a97 1
   void *rs_state, *rs_state_scissor, *rs_discard_state;
d102 3
d108 1
d110 6
a115 10
   boolean has_geometry_shader;
   boolean has_stream_out;
   boolean has_stencil_export;
   boolean has_texture_multisample;

   /* The Draw module overrides these functions.
    * Always create the blitter before Draw. */
   void   (*bind_fs_state)(struct pipe_context *, void *);
   void   (*delete_fs_state)(struct pipe_context *, void *);
};
a116 3
static struct pipe_surface *
util_blitter_get_next_surface_layer(struct pipe_context *pipe,
                                    struct pipe_surface *surf);
d124 1
a124 1
   struct pipe_sampler_state sampler_state;
d133 1
a133 5
   ctx->base.draw_rectangle = util_blitter_draw_rectangle;
   ctx->base.get_next_surface_layer = util_blitter_get_next_surface_layer;

   ctx->bind_fs_state = pipe->bind_fs_state;
   ctx->delete_fs_state = pipe->delete_fs_state;
a140 1
   ctx->base.saved_gs = INVALID_PTR;
d145 1
a145 15
   ctx->base.saved_num_so_targets = ~0;

   ctx->has_geometry_shader =
      pipe->screen->get_shader_param(pipe->screen, PIPE_SHADER_GEOMETRY,
                                     PIPE_SHADER_CAP_MAX_INSTRUCTIONS) > 0;
   ctx->has_stream_out =
      pipe->screen->get_param(pipe->screen,
                              PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS) != 0;

   ctx->has_stencil_export =
         pipe->screen->get_param(pipe->screen,
                                 PIPE_CAP_SHADER_STENCIL_EXPORT);

   ctx->has_texture_multisample =
      pipe->screen->get_param(pipe->screen, PIPE_CAP_TEXTURE_MULTISAMPLE);
d149 1
d151 2
a152 4
   for (i = 0; i <= PIPE_MASK_RGBA; i++) {
      blend.rt[0].colormask = i;
      ctx->blend[i] = pipe->create_blend_state(pipe, &blend);
   }
d159 4
d179 1
d186 7
a192 15
   memset(&sampler_state, 0, sizeof(sampler_state));
   sampler_state.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler_state.normalized_coords = 1;
   ctx->sampler_state = pipe->create_sampler_state(pipe, &sampler_state);
   sampler_state.normalized_coords = 0;
   ctx->sampler_state_rect = pipe->create_sampler_state(pipe, &sampler_state);

   sampler_state.min_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler_state.mag_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler_state.normalized_coords = 1;
   ctx->sampler_state_linear = pipe->create_sampler_state(pipe, &sampler_state);
   sampler_state.normalized_coords = 0;
   ctx->sampler_state_rect_linear = pipe->create_sampler_state(pipe, &sampler_state);
d197 1
a197 2
   rs_state.half_pixel_center = 1;
   rs_state.bottom_edge_rule = 1;
a198 1
   rs_state.depth_clip = 1;
d201 1
a201 12
   rs_state.scissor = 1;
   ctx->rs_state_scissor = pipe->create_rasterizer_state(pipe, &rs_state);

   if (ctx->has_stream_out) {
      rs_state.scissor = 0;
      rs_state.rasterizer_discard = 1;
      ctx->rs_discard_state = pipe->create_rasterizer_state(pipe, &rs_state);
   }

   ctx->base.vb_slot = 0; /* 0 for now */

   /* vertex elements states */
d205 2
a207 1
      velem[i].vertex_buffer_index = ctx->base.vb_slot;
d211 1
a211 7
   if (ctx->has_stream_out) {
      static enum pipe_format formats[4] = {
         PIPE_FORMAT_R32_UINT,
         PIPE_FORMAT_R32G32_UINT,
         PIPE_FORMAT_R32G32B32_UINT,
         PIPE_FORMAT_R32G32B32A32_UINT
      };
d213 1
a213 20
      for (i = 0; i < 4; i++) {
         velem[0].src_format = formats[i];
         velem[0].vertex_buffer_index = ctx->base.vb_slot;
         ctx->velem_state_readbuf[i] =
               pipe->create_vertex_elements_state(pipe, 1, &velem[0]);
      }
   }

   /* Fragment shaders are created on-demand, except these.
    * The interpolation must be constant for integer texture clearing to work.
    */
   ctx->fs_empty = util_make_empty_fragment_shader(pipe);
   ctx->fs_write_one_cbuf =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, FALSE);
   ctx->fs_write_all_cbufs =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, TRUE);

   /* vertex shaders */
a221 14
   if (ctx->has_stream_out) {
      struct pipe_stream_output_info so;
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION };
      const uint semantic_indices[] = { 0 };

      memset(&so, 0, sizeof(so));
      so.num_outputs = 1;
      so.output[0].num_components = 1;
      so.stride[0] = 1;

      ctx->vs_pos_only =
         util_make_vertex_passthrough_shader_with_so(pipe, 1, semantic_names,
                                                     semantic_indices, &so);
   }
d227 4
a230 1
   ctx->upload = u_upload_create(pipe, 65536, 4, PIPE_BIND_VERTEX_BUFFER);
d241 2
a242 3
   for (i = 0; i <= PIPE_MASK_RGBA; i++) {
      pipe->delete_blend_state(pipe, ctx->blend[i]);
   }
d248 1
a250 3
   pipe->delete_rasterizer_state(pipe, ctx->rs_state_scissor);
   if (ctx->rs_discard_state)
      pipe->delete_rasterizer_state(pipe, ctx->rs_discard_state);
a251 2
   if (ctx->vs_pos_only)
      pipe->delete_vs_state(pipe, ctx->vs_pos_only);
a252 5
   for (i = 0; i < 4; i++) {
      if (ctx->velem_state_readbuf[i]) {
         pipe->delete_vertex_elements_state(pipe, ctx->velem_state_readbuf[i]);
      }
   }
d256 1
a256 1
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_col[i]);
d258 2
a259 17
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_depth[i]);
      if (ctx->fs_texfetch_depthstencil[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_depthstencil[i]);
      if (ctx->fs_texfetch_stencil[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_stencil[i]);
   }
   ctx->delete_fs_state(pipe, ctx->fs_empty);
   ctx->delete_fs_state(pipe, ctx->fs_write_one_cbuf);
   ctx->delete_fs_state(pipe, ctx->fs_write_all_cbufs);

   pipe->delete_sampler_state(pipe, ctx->sampler_state_rect_linear);
   pipe->delete_sampler_state(pipe, ctx->sampler_state_rect);
   pipe->delete_sampler_state(pipe, ctx->sampler_state_linear);
   pipe->delete_sampler_state(pipe, ctx->sampler_state);
   u_upload_destroy(ctx->upload);
   FREE(ctx);
}
d261 3
a263 4
void util_blitter_set_texture_multisample(struct blitter_context *blitter,
                                          boolean supported)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
d265 3
a267 2
   ctx->has_texture_multisample = supported;
}
d269 2
a270 16
static void blitter_set_running_flag(struct blitter_context_priv *ctx)
{
   if (ctx->base.running) {
      _debug_printf("u_blitter:%i: Caught recursion. This is a driver bug.\n",
                    __LINE__);
   }
   ctx->base.running = TRUE;
}

static void blitter_unset_running_flag(struct blitter_context_priv *ctx)
{
   if (!ctx->base.running) {
      _debug_printf("u_blitter:%i: Caught recursion. This is a driver bug.\n",
                    __LINE__);
   }
   ctx->base.running = FALSE;
d273 1
a273 1
static void blitter_check_saved_vertex_states(struct blitter_context_priv *ctx)
d275 7
a281 5
   assert(ctx->base.saved_velem_state != INVALID_PTR);
   assert(ctx->base.saved_vs != INVALID_PTR);
   assert(!ctx->has_geometry_shader || ctx->base.saved_gs != INVALID_PTR);
   assert(!ctx->has_stream_out || ctx->base.saved_num_so_targets != ~0);
   assert(ctx->base.saved_rs_state != INVALID_PTR);
d284 1
a284 1
static void blitter_restore_vertex_states(struct blitter_context_priv *ctx)
d289 6
a294 6
   /* Vertex buffer. */
   pipe->set_vertex_buffers(pipe, ctx->base.vb_slot, 1,
                            &ctx->base.saved_vertex_buffer);
   pipe_resource_reference(&ctx->base.saved_vertex_buffer.buffer, NULL);

   /* Vertex elements. */
a295 1
   ctx->base.saved_velem_state = INVALID_PTR;
d297 4
a300 2
   /* Vertex shader. */
   pipe->bind_vs_state(pipe, ctx->base.saved_vs);
d302 1
d304 1
a304 5
   /* Geometry shader. */
   if (ctx->has_geometry_shader) {
      pipe->bind_gs_state(pipe, ctx->base.saved_gs);
      ctx->base.saved_gs = INVALID_PTR;
   }
d306 2
a307 5
   /* Stream outputs. */
   if (ctx->has_stream_out) {
      pipe->set_stream_output_targets(pipe,
                                      ctx->base.saved_num_so_targets,
                                      ctx->base.saved_so_targets, ~0);
d309 6
a314 4
      for (i = 0; i < ctx->base.saved_num_so_targets; i++)
         pipe_so_target_reference(&ctx->base.saved_so_targets[i], NULL);

      ctx->base.saved_num_so_targets = ~0;
d317 5
a321 32
   /* Rasterizer. */
   pipe->bind_rasterizer_state(pipe, ctx->base.saved_rs_state);
   ctx->base.saved_rs_state = INVALID_PTR;
}

static void blitter_check_saved_fragment_states(struct blitter_context_priv *ctx)
{
   assert(ctx->base.saved_fs != INVALID_PTR);
   assert(ctx->base.saved_dsa_state != INVALID_PTR);
   assert(ctx->base.saved_blend_state != INVALID_PTR);
}

static void blitter_restore_fragment_states(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   /* Fragment shader. */
   ctx->bind_fs_state(pipe, ctx->base.saved_fs);
   ctx->base.saved_fs = INVALID_PTR;

   /* Depth, stencil, alpha. */
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->base.saved_dsa_state);
   ctx->base.saved_dsa_state = INVALID_PTR;

   /* Blend state. */
   pipe->bind_blend_state(pipe, ctx->base.saved_blend_state);
   ctx->base.saved_blend_state = INVALID_PTR;

   /* Sample mask. */
   if (ctx->base.is_sample_mask_saved) {
      pipe->set_sample_mask(pipe, ctx->base.saved_sample_mask);
      ctx->base.is_sample_mask_saved = FALSE;
d324 4
a327 11
   /* Miscellaneous states. */
   /* XXX check whether these are saved and whether they need to be restored
    * (depending on the operation) */
   pipe->set_stencil_ref(pipe, &ctx->base.saved_stencil_ref);
   pipe->set_viewport_states(pipe, 0, 1, &ctx->base.saved_viewport);
}

static void blitter_check_saved_fb_state(struct blitter_context_priv *ctx)
{
   assert(ctx->base.saved_fb_state.nr_cbufs != ~0);
}
d329 3
a331 3
static void blitter_disable_render_cond(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;
d333 1
a333 2
   if (ctx->base.saved_render_cond_query) {
      pipe->render_condition(pipe, NULL, FALSE, 0);
a334 1
}
d336 4
a339 3
static void blitter_restore_render_cond(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;
d341 7
a347 5
   if (ctx->base.saved_render_cond_query) {
      pipe->render_condition(pipe, ctx->base.saved_render_cond_query,
                             ctx->base.saved_render_cond_cond,
                             ctx->base.saved_render_cond_mode);
      ctx->base.saved_render_cond_query = NULL;
a350 36
static void blitter_restore_fb_state(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   pipe->set_framebuffer_state(pipe, &ctx->base.saved_fb_state);
   util_unreference_framebuffer_state(&ctx->base.saved_fb_state);
}

static void blitter_check_saved_textures(struct blitter_context_priv *ctx)
{
   assert(ctx->base.saved_num_sampler_states != ~0);
   assert(ctx->base.saved_num_sampler_views != ~0);
}

static void blitter_restore_textures(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;
   unsigned i;

   /* Fragment sampler states. */
   pipe->bind_fragment_sampler_states(pipe,
                                      ctx->base.saved_num_sampler_states,
                                      ctx->base.saved_sampler_states);
   ctx->base.saved_num_sampler_states = ~0;

   /* Fragment sampler views. */
   pipe->set_fragment_sampler_views(pipe,
                                    ctx->base.saved_num_sampler_views,
                                    ctx->base.saved_sampler_views);

   for (i = 0; i < ctx->base.saved_num_sampler_views; i++)
      pipe_sampler_view_reference(&ctx->base.saved_sampler_views[i], NULL);

   ctx->base.saved_num_sampler_views = ~0;
}

d352 2
a353 1
                                  int x1, int y1, int x2, int y2,
d383 4
a386 1
   ctx->base.pipe->set_viewport_states(ctx->base.pipe, 0, 1, &ctx->viewport);
d390 1
a390 1
                                    const union pipe_color_union *color)
d394 1
a394 1
   if (color) {
d396 4
a399 5
         uint32_t *uiverts = (uint32_t *)ctx->vertices[i][1];
         uiverts[0] = color->ui[0];
         uiverts[1] = color->ui[1];
         uiverts[2] = color->ui[2];
         uiverts[3] = color->ui[3];
d411 19
a429 20
static void get_texcoords(struct pipe_sampler_view *src,
                          unsigned src_width0, unsigned src_height0,
                          int x1, int y1, int x2, int y2,
                          float out[4])
{
   struct pipe_resource *tex = src->texture;
   unsigned level = src->u.tex.first_level;
   boolean normalized = tex->target != PIPE_TEXTURE_RECT &&
                        tex->nr_samples <= 1;

   if (normalized) {
      out[0] = x1 / (float)u_minify(src_width0,  level);
      out[1] = y1 / (float)u_minify(src_height0, level);
      out[2] = x2 / (float)u_minify(src_width0,  level);
      out[3] = y2 / (float)u_minify(src_height0, level);
   } else {
      out[0] = (float) x1;
      out[1] = (float) y1;
      out[2] = (float) x2;
      out[3] = (float) y2;
d449 5
a453 5
static void blitter_set_texcoords(struct blitter_context_priv *ctx,
                                  struct pipe_sampler_view *src,
                                  unsigned src_width0, unsigned src_height0,
                                  unsigned layer, unsigned sample,
                                  int x1, int y1, int x2, int y2)
a456 1
   float face_coord[4][2];
d458 2
a459 1
   get_texcoords(src, src_width0, src_height0, x1, y1, x2, y2, coord);
d461 3
a463 9
   if (src->texture->target == PIPE_TEXTURE_CUBE ||
       src->texture->target == PIPE_TEXTURE_CUBE_ARRAY) {
      set_texcoords_in_vertices(coord, &face_coord[0][0], 2);
      util_map_texcoords2d_onto_cubemap(layer % 6,
                                        /* pointer, stride in floats */
                                        &face_coord[0][0], 2,
                                        &ctx->vertices[0][1][0], 8);
   } else {
      set_texcoords_in_vertices(coord, &ctx->vertices[0][1][0], 8);
d465 1
d467 11
a477 10
   /* Set the layer. */
   switch (src->texture->target) {
   case PIPE_TEXTURE_3D:
      {
         float r = layer / (float)u_minify(src->texture->depth0,
                                           src->u.tex.first_level);
         for (i = 0; i < 4; i++)
            ctx->vertices[i][1][2] = r; /*r*/
      }
      break;
d479 3
a481 4
   case PIPE_TEXTURE_1D_ARRAY:
      for (i = 0; i < 4; i++)
         ctx->vertices[i][1][1] = (float) layer; /*t*/
      break;
d483 9
a491 6
   case PIPE_TEXTURE_2D_ARRAY:
      for (i = 0; i < 4; i++) {
         ctx->vertices[i][1][2] = (float) layer;  /*r*/
         ctx->vertices[i][1][3] = (float) sample; /*q*/
      }
      break;
d493 2
a494 4
   case PIPE_TEXTURE_CUBE_ARRAY:
      for (i = 0; i < 4; i++)
         ctx->vertices[i][1][3] = (float) (layer / 6); /*w*/
      break;
d496 4
a499 5
   case PIPE_TEXTURE_2D:
      for (i = 0; i < 4; i++) {
         ctx->vertices[i][1][3] = (float) sample; /*r*/
      }
      break;
d501 2
a502 2
   default:;
   }
d512 1
a512 3
static void *blitter_get_fs_texfetch_col(struct blitter_context_priv *ctx,
                                         enum pipe_texture_target target,
                                         unsigned nr_samples)
d515 1
d517 5
a521 1
   assert(target < PIPE_MAX_TEXTURE_TYPES);
d523 3
a525 26
   if (nr_samples > 1) {
      void **shader = &ctx->fs_texfetch_col_msaa[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader = util_make_fs_blit_msaa_color(pipe, tgsi_tex);
      }

      return *shader;
   } else {
      void **shader = &ctx->fs_texfetch_col[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

         *shader =
            util_make_fragment_tex_shader(pipe, tgsi_tex,
                                          TGSI_INTERPOLATE_LINEAR);
      }

      return *shader;
   }
d529 2
a530 3
void *blitter_get_fs_texfetch_depth(struct blitter_context_priv *ctx,
                                    enum pipe_texture_target target,
                                    unsigned nr_samples)
d533 1
d535 1
a535 1
   assert(target < PIPE_MAX_TEXTURE_TYPES);
d537 6
a542 2
   if (nr_samples > 1) {
      void **shader = &ctx->fs_texfetch_depth_msaa[target];
d544 3
a546 4
      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);
d548 3
a550 19
         *shader =
            util_make_fs_blit_msaa_depth(pipe, tgsi_tex);
      }

      return *shader;
   } else {
      void **shader = &ctx->fs_texfetch_depth[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

         *shader =
            util_make_fragment_tex_shader_writedepth(pipe, tgsi_tex,
                                                     TGSI_INTERPOLATE_LINEAR);
      }

      return *shader;
   }
d554 1
a554 3
void *blitter_get_fs_texfetch_depthstencil(struct blitter_context_priv *ctx,
                                           enum pipe_texture_target target,
                                           unsigned nr_samples)
d558 1
a558 1
   assert(target < PIPE_MAX_TEXTURE_TYPES);
d560 5
a564 2
   if (nr_samples > 1) {
      void **shader = &ctx->fs_texfetch_depthstencil_msaa[target];
d566 2
a567 4
      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);
d569 18
a586 18
         *shader =
            util_make_fs_blit_msaa_depthstencil(pipe, tgsi_tex);
      }

      return *shader;
   } else {
      void **shader = &ctx->fs_texfetch_depthstencil[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

         *shader =
            util_make_fragment_tex_shader_writedepthstencil(pipe, tgsi_tex,
                                                     TGSI_INTERPOLATE_LINEAR);
      }

      return *shader;
d590 1
d592 2
a593 3
void *blitter_get_fs_texfetch_stencil(struct blitter_context_priv *ctx,
                                      enum pipe_texture_target target,
                                      unsigned nr_samples)
d597 1
a597 17
   assert(target < PIPE_MAX_TEXTURE_TYPES);

   if (nr_samples > 1) {
      void **shader = &ctx->fs_texfetch_stencil_msaa[target];

      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_stencil(pipe, tgsi_tex);
      }

      return *shader;
   } else {
      void **shader = &ctx->fs_texfetch_stencil[target];
d599 3
a601 8
      /* Create the fragment shader on-demand. */
      if (!*shader) {
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

         *shader =
            util_make_fragment_tex_shader_writestencil(pipe, tgsi_tex,
                                                       TGSI_INTERPOLATE_LINEAR);
      }
d603 2
a604 1
      return *shader;
a605 1
}
d607 1
a607 38
void util_blitter_cache_all_shaders(struct blitter_context *blitter)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_screen *screen = blitter->pipe->screen;
   unsigned i, target, max_samples;
   boolean has_arraytex, has_cubearraytex;

   max_samples = ctx->has_texture_multisample ? 2 : 1;
   has_arraytex = screen->get_param(screen,
                                    PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS) != 0;
   has_cubearraytex = screen->get_param(screen,
                                    PIPE_CAP_CUBE_MAP_ARRAY) != 0;

   /* It only matters if i <= 1 or > 1. */
   for (i = 1; i <= max_samples; i++) {
      for (target = PIPE_TEXTURE_1D; target < PIPE_MAX_TEXTURE_TYPES; target++) {
         if (!has_arraytex &&
             (target == PIPE_TEXTURE_1D_ARRAY ||
              target == PIPE_TEXTURE_2D_ARRAY)) {
            continue;
         }
         if (!has_cubearraytex &&
             (target == PIPE_TEXTURE_CUBE_ARRAY))
            continue;

	 if (i > 1 &&
	     (target != PIPE_TEXTURE_2D &&
	      target != PIPE_TEXTURE_2D_ARRAY))
	    continue;

         blitter_get_fs_texfetch_col(ctx, target, i);
         blitter_get_fs_texfetch_depth(ctx, target, i);
         if (ctx->has_stencil_export) {
            blitter_get_fs_texfetch_depthstencil(ctx, target, i);
            blitter_get_fs_texfetch_stencil(ctx, target, i);
         }
      }
   }
d610 3
a612 2
static void blitter_set_common_draw_rect_state(struct blitter_context_priv *ctx,
                                               boolean scissor)
d616 1
a616 8
   pipe->bind_rasterizer_state(pipe, scissor ? ctx->rs_state_scissor
                                             : ctx->rs_state);
   pipe->bind_vs_state(pipe, ctx->vs);
   if (ctx->has_geometry_shader)
      pipe->bind_gs_state(pipe, NULL);
   if (ctx->has_stream_out)
      pipe->set_stream_output_targets(pipe, 0, NULL, 0);
}
d618 3
a620 5
static void blitter_draw(struct blitter_context_priv *ctx,
                         int x1, int y1, int x2, int y2, float depth)
{
   struct pipe_resource *buf = NULL;
   unsigned offset = 0;
d622 4
a625 1
   blitter_set_rectangle(ctx, x1, y1, x2, y2, depth);
d627 1
a627 6
   u_upload_data(ctx->upload, 0, sizeof(ctx->vertices), ctx->vertices,
                 &offset, &buf);
   u_upload_unmap(ctx->upload);
   util_draw_vertex_buffer(ctx->base.pipe, NULL, buf, ctx->base.vb_slot,
                           offset, PIPE_PRIM_TRIANGLE_FAN, 4, 2);
   pipe_resource_reference(&buf, NULL);
d630 6
a635 4
void util_blitter_draw_rectangle(struct blitter_context *blitter,
                                 int x1, int y1, int x2, int y2, float depth,
                                 enum blitter_attrib_type type,
                                 const union pipe_color_union *attrib)
d645 1
a645 1
         set_texcoords_in_vertices(attrib->f, &ctx->vertices[0][1][0], 8);
d651 2
a652 1
   blitter_draw(ctx, x1, y1, x2, y2, depth);
d655 6
a660 6
static void util_blitter_clear_custom(struct blitter_context *blitter,
                                      unsigned width, unsigned height,
                                      unsigned clear_buffers,
                                      const union pipe_color_union *color,
                                      double depth, unsigned stencil,
                                      void *custom_blend, void *custom_dsa)
d666 9
a674 13
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   if (custom_blend) {
      pipe->bind_blend_state(pipe, custom_blend);
   } else if (clear_buffers & PIPE_CLEAR_COLOR) {
      pipe->bind_blend_state(pipe, ctx->blend[PIPE_MASK_RGBA]);
   } else {
      pipe->bind_blend_state(pipe, ctx->blend[0]);
   }
d676 2
a677 3
   if (custom_dsa) {
      pipe->bind_depth_stencil_alpha_state(pipe, custom_dsa);
   } else if ((clear_buffers & PIPE_CLEAR_DEPTHSTENCIL) == PIPE_CLEAR_DEPTHSTENCIL) {
d679 3
a681 1
   } else if (clear_buffers & PIPE_CLEAR_DEPTH) {
d683 3
a685 1
   } else if (clear_buffers & PIPE_CLEAR_STENCIL) {
d687 3
a689 1
   } else {
a690 4
   }

   sr.ref_value[0] = stencil & 0xff;
   pipe->set_stencil_ref(pipe, &sr);
d692 1
d694 2
a695 2
   ctx->bind_fs_state(pipe, ctx->fs_write_all_cbufs);
   pipe->set_sample_mask(pipe, ~0);
a696 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d698 3
a700 135
   blitter->draw_rectangle(blitter, 0, 0, width, height, (float) depth,
                           UTIL_BLITTER_ATTRIB_COLOR, color);

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}

void util_blitter_clear(struct blitter_context *blitter,
                        unsigned width, unsigned height,
                        unsigned clear_buffers,
                        const union pipe_color_union *color,
                        double depth, unsigned stencil)
{
   util_blitter_clear_custom(blitter, width, height,
                             clear_buffers, color, depth, stencil,
                             NULL, NULL);
}

void util_blitter_custom_clear_depth(struct blitter_context *blitter,
                                     unsigned width, unsigned height,
                                     double depth, void *custom_dsa)
{
    static const union pipe_color_union color;
    util_blitter_clear_custom(blitter, width, height, 0, &color, depth, 0,
                              NULL, custom_dsa);
}

void util_blitter_default_dst_texture(struct pipe_surface *dst_templ,
                                      struct pipe_resource *dst,
                                      unsigned dstlevel,
                                      unsigned dstz)
{
    memset(dst_templ, 0, sizeof(*dst_templ));
    dst_templ->format = util_format_linear(dst->format);
    dst_templ->u.tex.level = dstlevel;
    dst_templ->u.tex.first_layer = dstz;
    dst_templ->u.tex.last_layer = dstz;
}

static struct pipe_surface *
util_blitter_get_next_surface_layer(struct pipe_context *pipe,
                                    struct pipe_surface *surf)
{
   struct pipe_surface dst_templ;

   memset(&dst_templ, 0, sizeof(dst_templ));
   dst_templ.format = surf->format;
   dst_templ.u.tex.level = surf->u.tex.level;
   dst_templ.u.tex.first_layer = surf->u.tex.first_layer + 1;
   dst_templ.u.tex.last_layer = surf->u.tex.last_layer + 1;

   return pipe->create_surface(pipe, surf->texture, &dst_templ);
}

void util_blitter_default_src_texture(struct pipe_sampler_view *src_templ,
                                      struct pipe_resource *src,
                                      unsigned srclevel)
{
    memset(src_templ, 0, sizeof(*src_templ));
    src_templ->format = util_format_linear(src->format);
    src_templ->u.tex.first_level = srclevel;
    src_templ->u.tex.last_level = srclevel;
    src_templ->u.tex.first_layer = 0;
    src_templ->u.tex.last_layer =
        src->target == PIPE_TEXTURE_3D ? u_minify(src->depth0, srclevel) - 1
                                       : src->array_size - 1;
    src_templ->swizzle_r = PIPE_SWIZZLE_RED;
    src_templ->swizzle_g = PIPE_SWIZZLE_GREEN;
    src_templ->swizzle_b = PIPE_SWIZZLE_BLUE;
    src_templ->swizzle_a = PIPE_SWIZZLE_ALPHA;
}

static boolean is_blit_generic_supported(struct blitter_context *blitter,
                                         const struct pipe_resource *dst,
                                         enum pipe_format dst_format,
                                         const struct pipe_resource *src,
                                         enum pipe_format src_format,
                                         unsigned mask)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_screen *screen = ctx->base.pipe->screen;

   if (dst) {
      unsigned bind;
      const struct util_format_description *desc =
            util_format_description(dst_format);
      boolean dst_has_stencil = util_format_has_stencil(desc);

      /* Stencil export must be supported for stencil copy. */
      if ((mask & PIPE_MASK_S) && dst_has_stencil &&
          !ctx->has_stencil_export) {
         return FALSE;
      }

      if (dst_has_stencil || util_format_has_depth(desc))
         bind = PIPE_BIND_DEPTH_STENCIL;
      else
         bind = PIPE_BIND_RENDER_TARGET;

      if (!screen->is_format_supported(screen, dst_format, dst->target,
                                       dst->nr_samples, bind)) {
         return FALSE;
      }
   }

   if (src) {
      if (src->nr_samples > 1 && !ctx->has_texture_multisample) {
         return FALSE;
      }

      if (!screen->is_format_supported(screen, src_format, src->target,
                                 src->nr_samples, PIPE_BIND_SAMPLER_VIEW)) {
         return FALSE;
      }

      /* Check stencil sampler support for stencil copy. */
      if (mask & PIPE_MASK_S) {
         if (util_format_has_stencil(util_format_description(src_format))) {
            enum pipe_format stencil_format =
               util_format_stencil_only(src_format);
            assert(stencil_format != PIPE_FORMAT_NONE);

            if (stencil_format != src_format &&
                !screen->is_format_supported(screen, stencil_format,
                                             src->target, src->nr_samples,
                                             PIPE_BIND_SAMPLER_VIEW)) {
               return FALSE;
            }
         }
      }
   }

   return TRUE;
d703 3
a705 4
boolean util_blitter_is_copy_supported(struct blitter_context *blitter,
                                       const struct pipe_resource *dst,
                                       const struct pipe_resource *src,
                                       unsigned mask)
d707 1
a707 2
   return is_blit_generic_supported(blitter, dst, dst->format,
                                    src, src->format, mask);
d710 8
a717 17
boolean util_blitter_is_blit_supported(struct blitter_context *blitter,
				       const struct pipe_blit_info *info)
{
   return is_blit_generic_supported(blitter,
                                    info->dst.resource, info->dst.format,
                                    info->src.resource, info->src.format,
                                    info->mask);
}

void util_blitter_copy_texture(struct blitter_context *blitter,
                               struct pipe_resource *dst,
                               unsigned dst_level,
                               unsigned dstx, unsigned dsty, unsigned dstz,
                               struct pipe_resource *src,
                               unsigned src_level,
                               const struct pipe_box *srcbox, unsigned mask,
                               boolean copy_all_samples)
d721 9
a729 3
   struct pipe_surface *dst_view, dst_templ;
   struct pipe_sampler_view src_templ, *src_view;
   struct pipe_box dstbox;
d731 1
d733 11
d745 2
d748 3
a750 2
   u_box_3d(dstx, dsty, dstz, abs(srcbox->width), abs(srcbox->height),
            abs(srcbox->depth), &dstbox);
d752 4
a755 52
   /* Initialize the surface. */
   util_blitter_default_dst_texture(&dst_templ, dst, dst_level, dstz);
   dst_view = pipe->create_surface(pipe, dst, &dst_templ);

   /* Initialize the sampler view. */
   util_blitter_default_src_texture(&src_templ, src, src_level);
   src_view = pipe->create_sampler_view(pipe, src, &src_templ);

   /* Copy. */
   util_blitter_blit_generic(blitter, dst_view, &dstbox,
                             src_view, srcbox, src->width0, src->height0,
                             mask, PIPE_TEX_FILTER_NEAREST, NULL,
                             copy_all_samples);

   pipe_surface_reference(&dst_view, NULL);
   pipe_sampler_view_reference(&src_view, NULL);
}

void util_blitter_blit_generic(struct blitter_context *blitter,
                               struct pipe_surface *dst,
                               const struct pipe_box *dstbox,
                               struct pipe_sampler_view *src,
                               const struct pipe_box *srcbox,
                               unsigned src_width0, unsigned src_height0,
                               unsigned mask, unsigned filter,
                               const struct pipe_scissor_state *scissor,
                               boolean copy_all_samples)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;
   enum pipe_texture_target src_target = src->texture->target;
   unsigned src_samples = src->texture->nr_samples;
   boolean has_depth, has_stencil, has_color;
   boolean blit_stencil, blit_depth, blit_color;
   void *sampler_state;
   const struct util_format_description *src_desc =
         util_format_description(src->format);
   const struct util_format_description *dst_desc =
         util_format_description(dst->format);

   has_color = src_desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS &&
               dst_desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS;
   has_depth = util_format_has_depth(src_desc) &&
               util_format_has_depth(dst_desc);
   has_stencil = util_format_has_stencil(src_desc) &&
                 util_format_has_stencil(dst_desc);

   blit_color = has_color && (mask & PIPE_MASK_RGBA);
   blit_depth = has_depth && (mask & PIPE_MASK_Z);
   blit_stencil = has_stencil && (mask & PIPE_MASK_S) &&
                  ctx->has_stencil_export;
d757 9
a765 1
   if (!blit_stencil && !blit_depth && !blit_color) {
d769 8
d778 4
a781 6
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_textures(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);
d784 9
a792 28
   fb_state.width = dst->width;
   fb_state.height = dst->height;
   fb_state.nr_cbufs = blit_depth || blit_stencil ? 0 : 1;
   fb_state.cbufs[0] = NULL;
   fb_state.zsbuf = NULL;

   if (blit_depth || blit_stencil) {
      pipe->bind_blend_state(pipe, ctx->blend[0]);

      if (blit_depth && blit_stencil) {
         pipe->bind_depth_stencil_alpha_state(pipe,
                                              ctx->dsa_write_depth_stencil);
         ctx->bind_fs_state(pipe,
               blitter_get_fs_texfetch_depthstencil(ctx, src_target,
                                                    src_samples));
      } else if (blit_depth) {
         pipe->bind_depth_stencil_alpha_state(pipe,
                                              ctx->dsa_write_depth_keep_stencil);
         ctx->bind_fs_state(pipe,
               blitter_get_fs_texfetch_depth(ctx, src_target,
                                             src_samples));
      } else { /* is_stencil */
         pipe->bind_depth_stencil_alpha_state(pipe,
                                              ctx->dsa_keep_depth_write_stencil);
         ctx->bind_fs_state(pipe,
               blitter_get_fs_texfetch_stencil(ctx, src_target,
                                               src_samples));
      }
d794 2
d797 1
a797 1
      pipe->bind_blend_state(pipe, ctx->blend[mask & PIPE_MASK_RGBA]);
d799 2
a800 4
      ctx->bind_fs_state(pipe,
            blitter_get_fs_texfetch_col(ctx, src_target,
                                        src_samples));
   }
d802 3
a804 17
   /* Set the linear filter only for scaled color non-MSAA blits. */
   if (filter == PIPE_TEX_FILTER_LINEAR &&
       !blit_depth && !blit_stencil &&
       src_samples <= 1 &&
       (dstbox->width != abs(srcbox->width) ||
        dstbox->height != abs(srcbox->height))) {
      if (src_target == PIPE_TEXTURE_RECT) {
         sampler_state = ctx->sampler_state_rect_linear;
      } else {
         sampler_state = ctx->sampler_state_linear;
      }
   } else {
      if (src_target == PIPE_TEXTURE_RECT) {
         sampler_state = ctx->sampler_state_rect;
      } else {
         sampler_state = ctx->sampler_state;
      }
d807 1
a807 26
   /* Set samplers. */
   if (blit_depth && blit_stencil) {
      /* Setup two samplers, one for depth and the other one for stencil. */
      struct pipe_sampler_view templ;
      struct pipe_sampler_view *views[2];
      void *samplers[2] = {sampler_state, sampler_state};

      templ = *src;
      templ.format = util_format_stencil_only(templ.format);
      assert(templ.format != PIPE_FORMAT_NONE);

      views[0] = src;
      views[1] = pipe->create_sampler_view(pipe, src->texture, &templ);

      pipe->set_fragment_sampler_views(pipe, 2, views);
      pipe->bind_fragment_sampler_states(pipe, 2, samplers);

      pipe_sampler_view_reference(&views[1], NULL);
   } else if (blit_stencil) {
      /* Set a stencil-only sampler view for it not to sample depth instead. */
      struct pipe_sampler_view templ;
      struct pipe_sampler_view *view;

      templ = *src;
      templ.format = util_format_stencil_only(templ.format);
      assert(templ.format != PIPE_FORMAT_NONE);
d809 3
a811 10
      view = pipe->create_sampler_view(pipe, src->texture, &templ);

      pipe->set_fragment_sampler_views(pipe, 1, &view);
      pipe->bind_fragment_sampler_states(pipe, 1, &sampler_state);

      pipe_sampler_view_reference(&view, NULL);
   } else {
      pipe->set_fragment_sampler_views(pipe, 1, &src);
      pipe->bind_fragment_sampler_states(pipe, 1, &sampler_state);
   }
d813 5
d819 2
a820 3
   if (scissor) {
      pipe->set_scissor_states(pipe, 0, 1, scissor);
   }
d822 1
a822 2
   blitter_set_common_draw_rect_state(ctx, scissor != NULL);
   blitter_set_dst_dimensions(ctx, dst->width, dst->height);
d824 1
a824 4
   if ((src_target == PIPE_TEXTURE_1D ||
        src_target == PIPE_TEXTURE_2D ||
        src_target == PIPE_TEXTURE_RECT) &&
       src_samples <= 1) {
d826 14
a840 24
      /* Set texture coordinates. - use a pipe color union
       * for interface purposes.
       * XXX pipe_color_union is a wrong name since we use that to set
       * texture coordinates too.
       */
      union pipe_color_union coord;
      get_texcoords(src, src_width0, src_height0, srcbox->x, srcbox->y,
                    srcbox->x+srcbox->width, srcbox->y+srcbox->height, coord.f);

      /* Set framebuffer state. */
      if (blit_depth || blit_stencil) {
         fb_state.zsbuf = dst;
      } else {
         fb_state.cbufs[0] = dst;
      }
      pipe->set_framebuffer_state(pipe, &fb_state);

      /* Draw. */
      pipe->set_sample_mask(pipe, ~0);
      blitter->draw_rectangle(blitter, dstbox->x, dstbox->y,
                              dstbox->x + dstbox->width,
                              dstbox->y + dstbox->height, 0,
                              UTIL_BLITTER_ATTRIB_TEXCOORD, &coord);
   } else {
d842 16
a857 11
      int z;
      for (z = 0; z < dstbox->depth; z++) {
         struct pipe_surface *old;

         /* Set framebuffer state. */
         if (blit_depth || blit_stencil) {
            fb_state.zsbuf = dst;
         } else {
            fb_state.cbufs[0] = dst;
         }
         pipe->set_framebuffer_state(pipe, &fb_state);
d859 3
a861 39
         /* See if we need to blit a multisample or singlesample buffer. */
         if (copy_all_samples &&
             src_samples == dst->texture->nr_samples &&
             dst->texture->nr_samples > 1) {
            unsigned i, max_sample = MAX2(dst->texture->nr_samples, 1) - 1;

            for (i = 0; i <= max_sample; i++) {
               pipe->set_sample_mask(pipe, 1 << i);
               blitter_set_texcoords(ctx, src, src_width0, src_height0,
                                     srcbox->z + z,
                                     i, srcbox->x, srcbox->y,
                                     srcbox->x + srcbox->width,
                                     srcbox->y + srcbox->height);
               blitter_draw(ctx, dstbox->x, dstbox->y,
                            dstbox->x + dstbox->width,
                            dstbox->y + dstbox->height, 0);
            }
         } else {
            pipe->set_sample_mask(pipe, ~0);
            blitter_set_texcoords(ctx, src, src_width0, src_height0,
                                  srcbox->z + z, 0,
                                  srcbox->x, srcbox->y,
                                  srcbox->x + srcbox->width,
                                  srcbox->y + srcbox->height);
            blitter_draw(ctx, dstbox->x, dstbox->y,
                         dstbox->x + dstbox->width,
                         dstbox->y + dstbox->height, 0);
         }

         /* Get the next surface or (if this is the last iteration)
          * just unreference the last one. */
         old = dst;
         if (z < dstbox->depth-1) {
            dst = ctx->base.get_next_surface_layer(ctx->base.pipe, dst);
         }
         if (z) {
            pipe_surface_reference(&old, NULL);
         }
      }
d864 1
a864 38
   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_textures(ctx);
   blitter_restore_fb_state(ctx);
   if (scissor) {
      pipe->set_scissor_states(pipe, 0, 1, &ctx->base.saved_scissor);
   }
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}

void
util_blitter_blit(struct blitter_context *blitter,
		  const struct pipe_blit_info *info)
{
   struct pipe_resource *dst = info->dst.resource;
   struct pipe_resource *src = info->src.resource;
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_surface *dst_view, dst_templ;
   struct pipe_sampler_view src_templ, *src_view;

   /* Initialize the surface. */
   util_blitter_default_dst_texture(&dst_templ, dst, info->dst.level,
                                    info->dst.box.z);
   dst_templ.format = info->dst.format;
   dst_view = pipe->create_surface(pipe, dst, &dst_templ);

   /* Initialize the sampler view. */
   util_blitter_default_src_texture(&src_templ, src, info->src.level);
   src_templ.format = info->src.format;
   src_view = pipe->create_sampler_view(pipe, src, &src_templ);

   /* Copy. */
   util_blitter_blit_generic(blitter, dst_view, &info->dst.box,
                             src_view, &info->src.box, src->width0, src->height0,
                             info->mask, info->filter,
                             info->scissor_enable ? &info->scissor : NULL, TRUE);
d866 2
a867 2
   pipe_surface_reference(&dst_view, NULL);
   pipe_sampler_view_reference(&src_view, NULL);
d873 1
a873 1
                                      const union pipe_color_union *color,
d886 2
a887 5
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);
d889 2
a890 2
   /* bind states */
   pipe->bind_blend_state(pipe, ctx->blend[PIPE_MASK_RGBA]);
d892 3
a894 1
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
a903 1
   pipe->set_sample_mask(pipe, ~0);
a904 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d907 2
a908 7
                           UTIL_BLITTER_ATTRIB_COLOR, color);

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_fb_state(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
d930 2
a931 5
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);
d933 2
a934 2
   /* bind states */
   pipe->bind_blend_state(pipe, ctx->blend[0]);
d952 3
a954 1
   ctx->bind_fs_state(pipe, ctx->fs_empty);
a963 1
   pipe->set_sample_mask(pipe, ~0);
a964 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d966 1
a966 2
   blitter->draw_rectangle(blitter, dstx, dsty, dstx+width, dsty+height,
                           (float) depth,
d968 1
a968 6

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_fb_state(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
a974 1
				       unsigned sample_mask,
d986 5
a990 9
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   pipe->bind_blend_state(pipe, cbsurf ? ctx->blend[PIPE_MASK_RGBA] :
                                         ctx->blend[0]);
d992 4
a995 1
   ctx->bind_fs_state(pipe, ctx->fs_empty);
a1010 1
   pipe->set_sample_mask(pipe, sample_mask);
a1011 1
   blitter_set_common_draw_rect_state(ctx, FALSE);
d1015 1
a1015 193

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_fb_state(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
}

void util_blitter_copy_buffer(struct blitter_context *blitter,
                              struct pipe_resource *dst,
                              unsigned dstx,
                              struct pipe_resource *src,
                              unsigned srcx,
                              unsigned size)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_vertex_buffer vb;
   struct pipe_stream_output_target *so_target;

   if (srcx >= src->width0 ||
       dstx >= dst->width0) {
      return;
   }
   if (srcx + size > src->width0) {
      size = src->width0 - srcx;
   }
   if (dstx + size > dst->width0) {
      size = dst->width0 - dstx;
   }

   /* Drivers not capable of Stream Out should not call this function
    * in the first place. */
   assert(ctx->has_stream_out);

   /* Some alignment is required. */
   if (srcx % 4 != 0 || dstx % 4 != 0 || size % 4 != 0 ||
       !ctx->has_stream_out) {
      struct pipe_box box;
      u_box_1d(srcx, size, &box);
      util_resource_copy_region(pipe, dst, 0, dstx, 0, 0, src, 0, &box);
      return;
   }

   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_disable_render_cond(ctx);

   vb.buffer = src;
   vb.buffer_offset = srcx;
   vb.stride = 4;

   pipe->set_vertex_buffers(pipe, ctx->base.vb_slot, 1, &vb);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state_readbuf[0]);
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
   if (ctx->has_geometry_shader)
      pipe->bind_gs_state(pipe, NULL);
   pipe->bind_rasterizer_state(pipe, ctx->rs_discard_state);

   so_target = pipe->create_stream_output_target(pipe, dst, dstx, size);
   pipe->set_stream_output_targets(pipe, 1, &so_target, 0);

   util_draw_arrays(pipe, PIPE_PRIM_POINTS, 0, size / 4);

   blitter_restore_vertex_states(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
   pipe_so_target_reference(&so_target, NULL);
}

void util_blitter_clear_buffer(struct blitter_context *blitter,
                               struct pipe_resource *dst,
                               unsigned offset, unsigned size,
                               unsigned num_channels,
                               const union pipe_color_union *clear_value)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_vertex_buffer vb = {0};
   struct pipe_stream_output_target *so_target;

   assert(num_channels >= 1);
   assert(num_channels <= 4);

   /* IMPORTANT:  DON'T DO ANY BOUNDS CHECKING HERE!
    *
    * R600 uses this to initialize texture resources, so width0 might not be
    * what you think it is.
    */

   /* Streamout is required. */
   if (!ctx->has_stream_out) {
      assert(!"Streamout unsupported in util_blitter_clear_buffer()");
      return;
   }

   /* Some alignment is required. */
   if (offset % 4 != 0 || size % 4 != 0) {
      assert(!"Bad alignment in util_blitter_clear_buffer()");
      return;
   }

   u_upload_data(ctx->upload, 0, num_channels*4, clear_value,
                 &vb.buffer_offset, &vb.buffer);
   vb.stride = 0;

   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_disable_render_cond(ctx);

   pipe->set_vertex_buffers(pipe, ctx->base.vb_slot, 1, &vb);
   pipe->bind_vertex_elements_state(pipe,
                                    ctx->velem_state_readbuf[num_channels-1]);
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
   if (ctx->has_geometry_shader)
      pipe->bind_gs_state(pipe, NULL);
   pipe->bind_rasterizer_state(pipe, ctx->rs_discard_state);

   so_target = pipe->create_stream_output_target(pipe, dst, offset, size);
   pipe->set_stream_output_targets(pipe, 1, &so_target, 0);

   util_draw_arrays(pipe, PIPE_PRIM_POINTS, 0, size / 4);

   blitter_restore_vertex_states(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
   pipe_so_target_reference(&so_target, NULL);
   pipe_resource_reference(&vb.buffer, NULL);
}

/* probably radeon specific */
void util_blitter_custom_resolve_color(struct blitter_context *blitter,
				       struct pipe_resource *dst,
				       unsigned dst_level,
				       unsigned dst_layer,
				       struct pipe_resource *src,
				       unsigned src_layer,
				       unsigned sample_mask,
				       void *custom_blend,
                                       enum pipe_format format)
{
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;
   struct pipe_surface *srcsurf, *dstsurf, surf_tmpl;

   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   pipe->bind_blend_state(pipe, custom_blend);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
   pipe->set_sample_mask(pipe, sample_mask);

   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   surf_tmpl.format = format;
   surf_tmpl.u.tex.level = dst_level;
   surf_tmpl.u.tex.first_layer = dst_layer;
   surf_tmpl.u.tex.last_layer = dst_layer;

   dstsurf = pipe->create_surface(pipe, dst, &surf_tmpl);

   surf_tmpl.u.tex.level = 0;
   surf_tmpl.u.tex.first_layer = src_layer;
   surf_tmpl.u.tex.last_layer = src_layer;

   srcsurf = pipe->create_surface(pipe, src, &surf_tmpl);

   /* set a framebuffer state */
   fb_state.width = src->width0;
   fb_state.height = src->height0;
   fb_state.nr_cbufs = 2;
   fb_state.cbufs[0] = srcsurf;
   fb_state.cbufs[1] = dstsurf;
   fb_state.zsbuf = NULL;
   pipe->set_framebuffer_state(pipe, &fb_state);

   blitter_set_common_draw_rect_state(ctx, FALSE);
   blitter_set_dst_dimensions(ctx, src->width0, src->height0);
   blitter->draw_rectangle(blitter, 0, 0, src->width0, src->height0,
                           0, 0, NULL);
   blitter_restore_fb_state(ctx);
   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);

   pipe_surface_reference(&srcsurf, NULL);
   pipe_surface_reference(&dstsurf, NULL);
d1018 3
a1020 3
void util_blitter_custom_color(struct blitter_context *blitter,
                               struct pipe_surface *dstsurf,
                               void *custom_blend)
d1022 3
a1024 42
   struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_framebuffer_state fb_state;

   assert(dstsurf->texture);
   if (!dstsurf->texture)
      return;

   /* check the saved state */
   blitter_set_running_flag(ctx);
   blitter_check_saved_vertex_states(ctx);
   blitter_check_saved_fragment_states(ctx);
   blitter_check_saved_fb_state(ctx);
   blitter_disable_render_cond(ctx);

   /* bind states */
   pipe->bind_blend_state(pipe, custom_blend ? custom_blend
                                             : ctx->blend[PIPE_MASK_RGBA]);
   pipe->bind_depth_stencil_alpha_state(pipe, ctx->dsa_keep_depth_stencil);
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
   pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
   pipe->set_sample_mask(pipe, (1ull << MAX2(1, dstsurf->texture->nr_samples)) - 1);

   /* set a framebuffer state */
   fb_state.width = dstsurf->width;
   fb_state.height = dstsurf->height;
   fb_state.nr_cbufs = 1;
   fb_state.cbufs[0] = dstsurf;
   fb_state.zsbuf = 0;
   pipe->set_framebuffer_state(pipe, &fb_state);
   pipe->set_sample_mask(pipe, ~0);

   blitter_set_common_draw_rect_state(ctx, FALSE);
   blitter_set_dst_dimensions(ctx, dstsurf->width, dstsurf->height);
   blitter->draw_rectangle(blitter, 0, 0, dstsurf->width, dstsurf->height,
                           0, 0, NULL);

   blitter_restore_vertex_states(ctx);
   blitter_restore_fragment_states(ctx);
   blitter_restore_fb_state(ctx);
   blitter_restore_render_cond(ctx);
   blitter_unset_running_flag(ctx);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d20 1
a20 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a53 6
#define GET_CLEAR_BLEND_STATE_IDX(clear_buffers) \
   ((clear_buffers) / PIPE_CLEAR_COLOR0)

#define NUM_RESOLVE_FRAG_SHADERS 5 /* MSAA 2x, 4x, 8x, 16x, 32x */
#define GET_MSAA_RESOLVE_FS_IDX(nr_samples) (util_logbase2(nr_samples)-1)

a67 1
   void *vs_layered; /**< Vertex shader which sets LAYER = INSTANCEID. */
a89 5
   /* FS which outputs an average of all samples. */
   void *fs_resolve[PIPE_MAX_TEXTURE_TYPES][NUM_RESOLVE_FRAG_SHADERS][2];
   void *fs_resolve_sint[PIPE_MAX_TEXTURE_TYPES][NUM_RESOLVE_FRAG_SHADERS][2];
   void *fs_resolve_uint[PIPE_MAX_TEXTURE_TYPES][NUM_RESOLVE_FRAG_SHADERS][2];

a91 1
   void *blend_clear[GET_CLEAR_BLEND_STATE_IDX(PIPE_CLEAR_COLOR)+1];
a297 1

a312 5
   if (pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_INSTANCEID) &&
       pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_VS_LAYER)) {
      ctx->vs_layered = util_make_layered_clear_vertex_shader(pipe);
   }

d326 1
a326 1
   int i, j, f;
a330 4
   for (i = 0; i < Elements(ctx->blend_clear); i++) {
      if (ctx->blend_clear[i])
         pipe->delete_blend_state(pipe, ctx->blend_clear[i]);
   }
a343 2
   if (ctx->vs_layered)
      pipe->delete_vs_state(pipe, ctx->vs_layered);
a359 15

      for (j = 0; j< Elements(ctx->fs_resolve[i]); j++)
         for (f = 0; f < 2; f++)
            if (ctx->fs_resolve[i][j][f])
               ctx->delete_fs_state(pipe, ctx->fs_resolve[i][j][f]);

      for (j = 0; j< Elements(ctx->fs_resolve_sint[i]); j++)
         for (f = 0; f < 2; f++)
            if (ctx->fs_resolve_sint[i][j][f])
               ctx->delete_fs_state(pipe, ctx->fs_resolve_sint[i][j][f]);

      for (j = 0; j< Elements(ctx->fs_resolve_uint[i]); j++)
         for (f = 0; f < 2; f++)
            if (ctx->fs_resolve_uint[i][j][f])
               ctx->delete_fs_state(pipe, ctx->fs_resolve_uint[i][j][f]);
a360 1

a433 3
      unsigned offsets[PIPE_MAX_SO_BUFFERS];
      for (i = 0; i < ctx->base.saved_num_so_targets; i++)
         offsets[i] = (unsigned)-1;
d436 1
a436 1
                                      ctx->base.saved_so_targets, offsets);
d531 3
a533 4
   pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
                             ctx->base.saved_num_sampler_states,
                             ctx->base.saved_sampler_states);

d537 3
a539 3
   pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0,
                           ctx->base.saved_num_sampler_views,
                           ctx->base.saved_sampler_views);
d646 1
a646 1
                                  float layer, unsigned sample,
d658 1
a658 1
      util_map_texcoords2d_onto_cubemap((unsigned)layer % 6,
d661 1
a661 2
                                        &ctx->vertices[0][1][0], 8,
                                        FALSE);
d691 1
a691 1
         ctx->vertices[i][1][3] = (float) ((unsigned)layer / 6); /*w*/
a711 1
                                         enum pipe_format format,
d713 1
a713 3
                                         unsigned src_nr_samples,
                                         unsigned dst_nr_samples,
                                         unsigned filter)
a715 1
   unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, src_nr_samples);
d719 2
a720 2
   if (src_nr_samples > 1) {
      void **shader;
d722 6
a727 40
      if (dst_nr_samples <= 1) {
         /* The destination has one sample, so we'll do color resolve. */
         boolean is_uint, is_sint;
         unsigned index = GET_MSAA_RESOLVE_FS_IDX(src_nr_samples);

         is_uint = util_format_is_pure_uint(format);
         is_sint = util_format_is_pure_sint(format);

         assert(filter < 2);

         if (is_uint)
            shader = &ctx->fs_resolve_uint[target][index][filter];
         else if (is_sint)
            shader = &ctx->fs_resolve_sint[target][index][filter];
         else
            shader = &ctx->fs_resolve[target][index][filter];

         if (!*shader) {
            if (filter == PIPE_TEX_FILTER_LINEAR) {
               *shader = util_make_fs_msaa_resolve_bilinear(pipe, tgsi_tex,
                                                   src_nr_samples,
                                                   is_uint, is_sint);
            }
            else {
               *shader = util_make_fs_msaa_resolve(pipe, tgsi_tex,
                                                   src_nr_samples,
                                                   is_uint, is_sint);
            }
         }
      }
      else {
         /* The destination has multiple samples, we'll do
          * an MSAA->MSAA copy.
          */
         shader = &ctx->fs_texfetch_col_msaa[target];

         /* Create the fragment shader on-demand. */
         if (!*shader) {
            *shader = util_make_fs_blit_msaa_color(pipe, tgsi_tex);
         }
d736 5
a740 2
         *shader = util_make_fragment_tex_shader(pipe, tgsi_tex,
                                                 TGSI_INTERPOLATE_LINEAR);
d865 1
a865 1
   unsigned samples, j, f, target, max_samples;
d875 1
a875 1
   for (samples = 1; samples <= max_samples; samples++) {
d886 1
a886 1
	 if (samples > 1 &&
d891 2
a892 6
         /* If samples == 1, the shaders read one texel. If samples >= 1,
          * they read one sample.
          */
         blitter_get_fs_texfetch_col(ctx, PIPE_FORMAT_R32_FLOAT, target,
                                     samples, samples, 0);
         blitter_get_fs_texfetch_depth(ctx, target, samples);
d894 2
a895 23
            blitter_get_fs_texfetch_depthstencil(ctx, target, samples);
            blitter_get_fs_texfetch_stencil(ctx, target, samples);
         }

         if (samples == 1)
            continue;

         /* MSAA resolve shaders. */
         for (j = 2; j < 32; j++) {
            if (!screen->is_format_supported(screen, PIPE_FORMAT_R32_FLOAT,
                                             target, j,
                                             PIPE_BIND_SAMPLER_VIEW)) {
               continue;
            }

            for (f = 0; f < 2; f++) {
               blitter_get_fs_texfetch_col(ctx, PIPE_FORMAT_R32_FLOAT, target,
                                           j, 1, f);
               blitter_get_fs_texfetch_col(ctx, PIPE_FORMAT_R32_UINT, target,
                                           j, 1, f);
               blitter_get_fs_texfetch_col(ctx, PIPE_FORMAT_R32_SINT, target,
                                           j, 1, f);
            }
d902 1
a902 2
                                               boolean scissor,
                                               boolean vs_layered)
d908 1
a908 1
   pipe->bind_vs_state(pipe, vs_layered ? ctx->vs_layered : ctx->vs);
d912 1
a912 1
      pipe->set_stream_output_targets(pipe, 0, NULL, NULL);
d916 1
a916 2
                         int x1, int y1, int x2, int y2, float depth,
                         unsigned num_instances)
d918 2
a919 2
   struct pipe_context *pipe = ctx->base.pipe;
   struct pipe_vertex_buffer vb = {0};
a922 2
   vb.stride = 8 * sizeof(float);

d924 1
a924 1
                 &vb.buffer_offset, &vb.buffer);
d926 3
a928 5

   pipe->set_vertex_buffers(pipe, ctx->base.vb_slot, 1, &vb);
   util_draw_arrays_instanced(pipe, PIPE_PRIM_TRIANGLE_FAN, 0, 4,
                              0, num_instances);
   pipe_resource_reference(&vb.buffer, NULL);
d950 1
a950 36
   blitter_draw(ctx, x1, y1, x2, y2, depth, 1);
}

static void *get_clear_blend_state(struct blitter_context_priv *ctx,
                                   unsigned clear_buffers)
{
   struct pipe_context *pipe = ctx->base.pipe;
   int index;

   clear_buffers &= PIPE_CLEAR_COLOR;

   /* Return an existing blend state. */
   if (!clear_buffers)
      return ctx->blend[0];

   index = GET_CLEAR_BLEND_STATE_IDX(clear_buffers);

   if (ctx->blend_clear[index])
      return ctx->blend_clear[index];

   /* Create a new one. */
   {
      struct pipe_blend_state blend = {0};
      unsigned i;

      blend.independent_blend_enable = 1;

      for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
         if (clear_buffers & (PIPE_CLEAR_COLOR0 << i)) {
            blend.rt[i].colormask = PIPE_MASK_RGBA;
         }
      }

      ctx->blend_clear[index] = pipe->create_blend_state(pipe, &blend);
   }
   return ctx->blend_clear[index];
a954 1
                                      unsigned num_layers,
a963 2
   assert(ctx->vs_layered || num_layers <= 1);

d972 2
d975 1
a975 1
      pipe->bind_blend_state(pipe, get_clear_blend_state(ctx, clear_buffers));
d997 1
d999 2
a1000 11

   if (num_layers > 1 && ctx->vs_layered) {
      blitter_set_common_draw_rect_state(ctx, FALSE, TRUE);
      blitter_set_clear_color(ctx, color);
      blitter_draw(ctx, 0, 0, width, height, depth, num_layers);
   }
   else {
      blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
      blitter->draw_rectangle(blitter, 0, 0, width, height, (float) depth,
                              UTIL_BLITTER_ATTRIB_COLOR, color);
   }
d1009 1
a1009 1
                        unsigned width, unsigned height, unsigned num_layers,
d1014 1
a1014 1
   util_blitter_clear_custom(blitter, width, height, num_layers,
d1024 1
a1024 1
    util_blitter_clear_custom(blitter, width, height, 0, 0, &color, depth, 0,
d1138 2
a1139 1
                                       const struct pipe_resource *src)
d1142 1
a1142 1
                                    src, src->format, PIPE_MASK_RGBAZS);
d1160 2
a1161 1
                               const struct pipe_box *srcbox)
d1186 2
a1187 1
                             PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL);
d1200 2
a1201 1
                               const struct pipe_scissor_state *scissor)
a1207 1
   unsigned dst_samples = dst->texture->nr_samples;
a1231 6
   if (blit_stencil ||
       (dstbox->width == abs(srcbox->width) &&
        dstbox->height == abs(srcbox->height))) {
      filter = PIPE_TEX_FILTER_NEAREST;
   }

d1274 2
a1275 2
            blitter_get_fs_texfetch_col(ctx, src->format, src_target,
                                        src_samples, dst_samples, filter));
d1279 5
a1283 1
   if (filter == PIPE_TEX_FILTER_LINEAR) {
d1311 2
a1312 2
      pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, 2, views);
      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0, 2, samplers);
d1326 2
a1327 3
      pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, 1, &view);
      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT,
                                0, 1, &sampler_state);
d1331 2
a1332 3
      pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, 1, &src);
      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT,
                                0, 1, &sampler_state);
d1340 1
a1340 1
   blitter_set_common_draw_rect_state(ctx, scissor != NULL, FALSE);
d1374 2
a1375 2
      int dst_z;
      for (dst_z = 0; dst_z < dstbox->depth; dst_z++) {
a1376 22
         float dst2src_scale = srcbox->depth / (float)dstbox->depth;

         /* Scale Z properly if the blit is scaled.
          *
          * When downscaling, we want the coordinates centered, so that
          * mipmapping works for 3D textures. For example, when generating
          * a 4x4x4 level, this wouldn't average the pixels:
          *
          *   src Z:  0 1 2 3 4 5 6 7
          *   dst Z:  0   1   2   3
          *
          * Because the pixels are not centered below the pixels of the higher
          * level. Therefore, we want this:
          *   src Z:  0 1 2 3 4 5 6 7
          *   dst Z:   0   1   2   3
          *
          * dst_offset defines the offset needed for centering the pixels and
          * it works with any scaling (not just 2x).
          */
         float dst_offset = ((srcbox->depth - 1) -
                             (dstbox->depth - 1) * dst2src_scale) * 0.5;
         float src_z = (dst_z + dst_offset) * dst2src_scale;
d1387 4
a1390 3
         if (src_samples == dst_samples && dst_samples > 1) {
            /* MSAA copy. */
            unsigned i, max_sample = dst_samples - 1;
d1395 1
a1395 1
                                     srcbox->z + src_z,
d1401 1
a1401 1
                            dstbox->y + dstbox->height, 0, 1);
a1403 1
            /* Normal copy, MSAA upsampling, or MSAA resolve. */
d1406 1
a1406 1
                                  srcbox->z + src_z, 0,
d1412 1
a1412 1
                         dstbox->y + dstbox->height, 0, 1);
d1418 1
a1418 1
         if (dst_z < dstbox->depth-1) {
d1421 1
a1421 1
         if (dst_z) {
d1464 1
a1464 1
                             info->scissor_enable ? &info->scissor : NULL);
d1507 1
a1507 1
   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
d1575 1
a1575 1
   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
d1632 1
a1632 1
   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
a1654 1
   unsigned offsets[PIPE_MAX_SO_BUFFERS] = {0};
d1696 1
a1696 1
   pipe->set_stream_output_targets(pipe, 1, &so_target, offsets);
a1715 1
   unsigned offsets[PIPE_MAX_SO_BUFFERS] = {0};
d1755 1
a1755 1
   pipe->set_stream_output_targets(pipe, 1, &so_target, offsets);
d1817 1
a1817 1
   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
d1867 1
a1867 1
   blitter_set_common_draw_rect_state(ctx, FALSE, FALSE);
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@a385 9
      if (ctx->fs_texfetch_col_msaa[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_col_msaa[i]);
      if (ctx->fs_texfetch_depth_msaa[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_depth_msaa[i]);
      if (ctx->fs_texfetch_depthstencil_msaa[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_depthstencil_msaa[i]);
      if (ctx->fs_texfetch_stencil_msaa[i])
         ctx->delete_fs_state(pipe, ctx->fs_texfetch_stencil_msaa[i]);

@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a132 1
   boolean has_layered;
a135 1
   boolean cached_all_shaders;
d291 10
a300 3
   ctx->has_layered =
      pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_INSTANCEID) &&
      pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_VS_LAYER_VIEWPORT);
d302 9
a310 3
   /* set invariant vertex coordinates */
   for (i = 0; i < 4; i++)
      ctx->vertices[i][0][3] = 1; /*v.w*/
d312 1
a312 10
   ctx->upload = u_upload_create(pipe, 65536, 4, PIPE_BIND_VERTEX_BUFFER);

   return &ctx->base;
}

static void bind_vs_pos_only(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->vs_pos_only) {
d327 2
a328 24
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
}

static void bind_vs_passthrough(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->vs) {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indices[] = { 0, 0 };
      ctx->vs =
         util_make_vertex_passthrough_shader(pipe, 2, semantic_names,
                                             semantic_indices);
   }

   pipe->bind_vs_state(pipe, ctx->vs);
}

static void bind_vs_layered(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->vs_layered) {
d332 3
a334 2
   pipe->bind_vs_state(pipe, ctx->vs_layered);
}
d336 1
a336 3
static void bind_fs_empty(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;
d338 1
a338 34
   if (!ctx->fs_empty) {
      assert(!ctx->cached_all_shaders);
      ctx->fs_empty = util_make_empty_fragment_shader(pipe);
   }

   ctx->bind_fs_state(pipe, ctx->fs_empty);
}

static void bind_fs_write_one_cbuf(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->fs_write_one_cbuf) {
      assert(!ctx->cached_all_shaders);
      ctx->fs_write_one_cbuf =
         util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                               TGSI_INTERPOLATE_CONSTANT, FALSE);
   }

   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
}

static void bind_fs_write_all_cbufs(struct blitter_context_priv *ctx)
{
   struct pipe_context *pipe = ctx->base.pipe;

   if (!ctx->fs_write_all_cbufs) {
      assert(!ctx->cached_all_shaders);
      ctx->fs_write_all_cbufs =
         util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                               TGSI_INTERPOLATE_CONSTANT, TRUE);
   }

   ctx->bind_fs_state(pipe, ctx->fs_write_all_cbufs);
d364 1
a364 2
   if (ctx->vs)
      pipe->delete_vs_state(pipe, ctx->vs);
d411 3
a413 6
   if (ctx->fs_empty)
      ctx->delete_fs_state(pipe, ctx->fs_empty);
   if (ctx->fs_write_one_cbuf)
      ctx->delete_fs_state(pipe, ctx->fs_write_one_cbuf);
   if (ctx->fs_write_all_cbufs)
      ctx->delete_fs_state(pipe, ctx->fs_write_all_cbufs);
a798 1
            assert(!ctx->cached_all_shaders);
a818 1
            assert(!ctx->cached_all_shaders);
a828 1
         assert(!ctx->cached_all_shaders);
d851 5
a855 4
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
         *shader = util_make_fs_blit_msaa_depth(pipe, tgsi_tex);
d864 2
a865 3
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
d889 5
a893 4
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
         *shader = util_make_fs_blit_msaa_depthstencil(pipe, tgsi_tex);
d902 2
a903 3
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
d927 5
a931 4
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
         *shader = util_make_fs_blit_msaa_stencil(pipe, tgsi_tex);
d940 2
a941 3
         unsigned tgsi_tex;
         assert(!ctx->cached_all_shaders);
         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
a950 7

/**
 * Generate and save all fragment shaders that we will ever need for
 * blitting.  Drivers which use the 'draw' fallbacks will typically use
 * this to make sure we generate/use shaders that don't go through the
 * draw module's wrapper functions.
 */
d954 1
a954 2
   struct pipe_context *pipe = blitter->pipe;
   struct pipe_screen *screen = pipe->screen;
a1013 12

   ctx->fs_empty = util_make_empty_fragment_shader(pipe);

   ctx->fs_write_one_cbuf =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, FALSE);

   ctx->fs_write_all_cbufs =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, TRUE);

   ctx->cached_all_shaders = TRUE;
d1024 1
a1024 5
   if (vs_layered)
      bind_vs_layered(ctx);
   else
      bind_vs_passthrough(ctx);

d1121 1
a1121 1
   assert(ctx->has_layered || num_layers <= 1);
d1151 1
a1151 1
   bind_fs_write_all_cbufs(ctx);
d1156 1
a1156 1
   if (num_layers > 1 && ctx->has_layered) {
d1683 1
a1683 1
   bind_fs_write_one_cbuf(ctx);
d1751 1
a1751 1
   bind_fs_empty(ctx);
d1802 1
a1802 4
   if (cbsurf)
      bind_fs_write_one_cbuf(ctx);
   else
      bind_fs_empty(ctx);
d1879 1
a1879 1
   bind_vs_pos_only(ctx);
d1939 1
a1939 1
   bind_vs_pos_only(ctx);
d1981 1
a1981 1
   bind_fs_write_one_cbuf(ctx);
d2044 1
a2044 1
   bind_fs_write_one_cbuf(ctx);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d133 1
d137 1
d293 12
a304 10
   /* Fragment shaders are created on-demand, except these.
    * The interpolation must be constant for integer texture clearing to work.
    */
   ctx->fs_empty = util_make_empty_fragment_shader(pipe);
   ctx->fs_write_one_cbuf =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, FALSE);
   ctx->fs_write_all_cbufs =
      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                            TGSI_INTERPOLATE_CONSTANT, TRUE);
d306 3
a308 9
   /* vertex shaders */
   {
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indices[] = { 0, 0 };
      ctx->vs =
         util_make_vertex_passthrough_shader(pipe, 2, semantic_names,
                                             semantic_indices);
   }
d310 1
a310 1
   if (ctx->has_stream_out) {
d325 24
a348 2
   if (pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_INSTANCEID) &&
       pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_VS_LAYER)) {
d352 32
a383 3
   /* set invariant vertex coordinates */
   for (i = 0; i < 4; i++)
      ctx->vertices[i][0][3] = 1; /*v.w*/
d385 6
a390 1
   ctx->upload = u_upload_create(pipe, 65536, 4, PIPE_BIND_VERTEX_BUFFER);
d392 1
a392 1
   return &ctx->base;
d418 2
a419 1
   pipe->delete_vs_state(pipe, ctx->vs);
d466 6
a471 3
   ctx->delete_fs_state(pipe, ctx->fs_empty);
   ctx->delete_fs_state(pipe, ctx->fs_write_one_cbuf);
   ctx->delete_fs_state(pipe, ctx->fs_write_all_cbufs);
d857 1
d878 1
d889 1
d912 4
a915 5
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_depth(pipe, tgsi_tex);
d924 3
a926 2
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

d950 4
a953 5
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_depthstencil(pipe, tgsi_tex);
d962 3
a964 2
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

d988 4
a991 5
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
                                                       nr_samples);

         *shader =
            util_make_fs_blit_msaa_stencil(pipe, tgsi_tex);
d1000 3
a1002 2
         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);

d1012 7
d1022 2
a1023 1
   struct pipe_screen *screen = blitter->pipe->screen;
d1083 12
d1105 5
a1109 1
   pipe->bind_vs_state(pipe, vs_layered ? ctx->vs_layered : ctx->vs);
d1206 1
a1206 1
   assert(ctx->vs_layered || num_layers <= 1);
d1236 1
a1236 1
   ctx->bind_fs_state(pipe, ctx->fs_write_all_cbufs);
d1241 1
a1241 1
   if (num_layers > 1 && ctx->vs_layered) {
d1768 1
a1768 1
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
d1836 1
a1836 1
   ctx->bind_fs_state(pipe, ctx->fs_empty);
d1887 4
a1890 1
   ctx->bind_fs_state(pipe, ctx->fs_empty);
d1967 1
a1967 1
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
d2027 1
a2027 1
   pipe->bind_vs_state(pipe, ctx->vs_pos_only);
d2069 1
a2069 1
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
d2132 1
a2132 1
   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
@


