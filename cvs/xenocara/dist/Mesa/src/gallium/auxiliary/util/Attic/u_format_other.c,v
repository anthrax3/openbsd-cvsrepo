head	1.4;
access;
symbols
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.6
	OPENBSD_5_7_BASE:1.3
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.3;
commitid	TnlogFl9nOv2eaRf;

1.3
date	2013.09.05.13.59.49;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.48;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 **************************************************************************/


#include "u_math.h"
#include "u_format_other.h"
#include "u_format_rgb9e5.h"
#include "u_format_r11g11b10f.h"


void
util_format_r9g9b9e5_float_unpack_rgba_float(float *dst_row, unsigned dst_stride,
                                        const uint8_t *src_row, unsigned src_stride,
                                        unsigned width, unsigned height)
{
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      float *dst = dst_row;
      const uint8_t *src = src_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         rgb9e5_to_float3(value, dst);
         dst[3] = 1; /* a */
         src += 4;
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
}

void
util_format_r9g9b9e5_float_pack_rgba_float(uint8_t *dst_row, unsigned dst_stride,
                                      const float *src_row, unsigned src_stride,
                                      unsigned width, unsigned height)
{
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      const float *src = src_row;
      uint8_t *dst = dst_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = float3_to_rgb9e5(src);
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         *(uint32_t *)dst = value;
         src += 4;
         dst += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
}

void
util_format_r9g9b9e5_float_fetch_rgba_float(float *dst, const uint8_t *src,
                                       unsigned i, unsigned j)
{
   uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   rgb9e5_to_float3(value, dst);
   dst[3] = 1; /* a */
}


void
util_format_r9g9b9e5_float_unpack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                         const uint8_t *src_row, unsigned src_stride,
                                         unsigned width, unsigned height)
{
   unsigned x, y;
   float p[3];
   for(y = 0; y < height; y += 1) {
      uint8_t *dst = dst_row;
      const uint8_t *src = src_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         rgb9e5_to_float3(value, p);
         dst[0] = float_to_ubyte(p[0]); /* r */
         dst[1] = float_to_ubyte(p[1]); /* g */
         dst[2] = float_to_ubyte(p[2]); /* b */
         dst[3] = 255; /* a */
         src += 4;
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
}


void
util_format_r9g9b9e5_float_pack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                       const uint8_t *src_row, unsigned src_stride,
                                       unsigned width, unsigned height)
{
   unsigned x, y;
   float p[3];
   for(y = 0; y < height; y += 1) {
      const uint8_t *src = src_row;
      uint8_t *dst = dst_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value;
         p[0] = ubyte_to_float(src[0]);
         p[1] = ubyte_to_float(src[1]);
         p[2] = ubyte_to_float(src[2]);
         value = float3_to_rgb9e5(p);
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         *(uint32_t *)dst = value;
         src += 4;
         dst += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
}


void
util_format_r11g11b10_float_unpack_rgba_float(float *dst_row, unsigned dst_stride,
                                        const uint8_t *src_row, unsigned src_stride,
                                        unsigned width, unsigned height)
{
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      float *dst = dst_row;
      const uint8_t *src = src_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         r11g11b10f_to_float3(value, dst);
         dst[3] = 1; /* a */
         src += 4;
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
}

void
util_format_r11g11b10_float_pack_rgba_float(uint8_t *dst_row, unsigned dst_stride,
                                      const float *src_row, unsigned src_stride,
                                      unsigned width, unsigned height)
{
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      const float *src = src_row;
      uint8_t *dst = dst_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = float3_to_r11g11b10f(src);
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         *(uint32_t *)dst = value;
         src += 4;
         dst += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
}

void
util_format_r11g11b10_float_fetch_rgba_float(float *dst, const uint8_t *src,
                                       unsigned i, unsigned j)
{
   uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   r11g11b10f_to_float3(value, dst);
   dst[3] = 1; /* a */
}


void
util_format_r11g11b10_float_unpack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                         const uint8_t *src_row, unsigned src_stride,
                                         unsigned width, unsigned height)
{
   unsigned x, y;
   float p[3];
   for(y = 0; y < height; y += 1) {
      uint8_t *dst = dst_row;
      const uint8_t *src = src_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         r11g11b10f_to_float3(value, p);
         dst[0] = float_to_ubyte(p[0]); /* r */
         dst[1] = float_to_ubyte(p[1]); /* g */
         dst[2] = float_to_ubyte(p[2]); /* b */
         dst[3] = 255; /* a */
         src += 4;
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
}


void
util_format_r11g11b10_float_pack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                       const uint8_t *src_row, unsigned src_stride,
                                       unsigned width, unsigned height)
{
   unsigned x, y;
   float p[3];
   for(y = 0; y < height; y += 1) {
      const uint8_t *src = src_row;
      uint8_t *dst = dst_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value;
         p[0] = ubyte_to_float(src[0]);
         p[1] = ubyte_to_float(src[1]);
         p[2] = ubyte_to_float(src[2]);
         value = float3_to_r11g11b10f(p);
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         *(uint32_t *)dst = value;
         src += 4;
         dst += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
}


void
util_format_r1_unorm_unpack_rgba_float(float *dst_row, unsigned dst_stride,
                                  const uint8_t *src_row, unsigned src_stride,
                                  unsigned width, unsigned height)
{

}


void
util_format_r1_unorm_pack_rgba_float(uint8_t *dst_row, unsigned dst_stride,
                                const float *src_row, unsigned src_stride,
                                unsigned width, unsigned height)
{

}


void
util_format_r1_unorm_fetch_rgba_float(float *dst, const uint8_t *src,
                                 unsigned i, unsigned j)
{

}


void
util_format_r1_unorm_unpack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                   const uint8_t *src_row, unsigned src_stride,
                                   unsigned width, unsigned height)
{

}


void
util_format_r1_unorm_pack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                 const uint8_t *src_row, unsigned src_stride,
                                 unsigned width, unsigned height)
{
}


/*
 * PIPE_FORMAT_R8G8Bx_SNORM
 *
 * A.k.a. D3DFMT_CxV8U8
 */

static uint8_t
r8g8bx_derive(int16_t r, int16_t g)
{
   /* Derive blue from red and green components.
    * Apparently, we must always use integers to perform calculations,
    * otherwise the results won't match D3D's CxV8U8 definition.
    */
   return (uint8_t)sqrtf(0x7f * 0x7f - r * r - g * g) * 0xff / 0x7f;
}

void
util_format_r8g8bx_snorm_unpack_rgba_float(float *dst_row, unsigned dst_stride,
                                      const uint8_t *src_row, unsigned src_stride,
                                      unsigned width, unsigned height)
{
   unsigned x, y;

   for(y = 0; y < height; y += 1) {
      float *dst = dst_row;
      const uint16_t *src = (const uint16_t *)src_row;
      for(x = 0; x < width; x += 1) {
         uint16_t value = *src++;
         int16_t r, g;

#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap16(value);
#endif

         r = ((int16_t)(value << 8)) >> 8;
         g = ((int16_t)(value << 0)) >> 8;

         dst[0] = (float)(r * (1.0f/0x7f)); /* r */
         dst[1] = (float)(g * (1.0f/0x7f)); /* g */
         dst[2] = r8g8bx_derive(r, g) * (1.0f/0xff); /* b */
         dst[3] = 1.0f; /* a */
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
}


void
util_format_r8g8bx_snorm_unpack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                       const uint8_t *src_row, unsigned src_stride,
                                       unsigned width, unsigned height)
{
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      uint8_t *dst = dst_row;
      const uint16_t *src = (const uint16_t *)src_row;
      for(x = 0; x < width; x += 1) {
         uint16_t value = *src++;
         int16_t r, g;

#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap16(value);
#endif

         r = ((int16_t)(value << 8)) >> 8;
         g = ((int16_t)(value << 0)) >> 8;

         dst[0] = (uint8_t)(((uint16_t)MAX2(r, 0)) * 0xff / 0x7f); /* r */
         dst[1] = (uint8_t)(((uint16_t)MAX2(g, 0)) * 0xff / 0x7f); /* g */
         dst[2] = r8g8bx_derive(r, g); /* b */
         dst[3] = 255; /* a */
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
}


void
util_format_r8g8bx_snorm_pack_rgba_float(uint8_t *dst_row, unsigned dst_stride,
                                    const float *src_row, unsigned src_stride,
                                    unsigned width, unsigned height)
{
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      const float *src = src_row;
      uint16_t *dst = (uint16_t *)dst_row;
      for(x = 0; x < width; x += 1) {
         uint16_t value = 0;

         value |= (uint16_t)(((int8_t)(CLAMP(src[0], -1, 1) * 0x7f)) & 0xff) ;
         value |= (uint16_t)((((int8_t)(CLAMP(src[1], -1, 1) * 0x7f)) & 0xff) << 8) ;

#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap16(value);
#endif

         *dst++ = value;

         src += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
}


void
util_format_r8g8bx_snorm_pack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                     const uint8_t *src_row, unsigned src_stride,
                                     unsigned width, unsigned height)
{
   unsigned x, y;

   for(y = 0; y < height; y += 1) {
      const uint8_t *src = src_row;
      uint16_t *dst = (uint16_t *)dst_row;
      for(x = 0; x < width; x += 1) {
         uint16_t value = 0;

         value |= src[0] >> 1;
         value |= (src[1] >> 1) << 8;

#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap16(value);
#endif

         *dst++ = value;

         src += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
}


void
util_format_r8g8bx_snorm_fetch_rgba_float(float *dst, const uint8_t *src,
                                     unsigned i, unsigned j)
{
   uint16_t value = *(const uint16_t *)src;
   int16_t r, g;

#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap16(value);
#endif

   r = ((int16_t)(value << 8)) >> 8;
   g = ((int16_t)(value << 0)) >> 8;

   dst[0] = r * (1.0f/0x7f); /* r */
   dst[1] = g * (1.0f/0x7f); /* g */
   dst[2] = r8g8bx_derive(r, g) * (1.0f/0xff); /* b */
   dst[3] = 1.0f; /* a */
}
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d345 1
a345 1
         value = util_bswap32(value);
d377 1
a377 1
         value = util_bswap32(value);
d411 1
a411 1
         value = util_bswap32(value);
d441 1
a441 1
         value = util_bswap32(value);
d462 1
a462 1
   value = util_bswap32(value);
@


1.1
log
@Initial revision
@
text
@d31 2
d40 17
a56 1

d64 16
a79 1

d86 6
a91 1

d100 21
a120 1

d129 70
d200 68
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a30 2
#include "u_format_rgb9e5.h"
#include "u_format_r11g11b10f.h"
d38 1
a38 17
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      float *dst = dst_row;
      const uint8_t *src = src_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         rgb9e5_to_float3(value, dst);
         dst[3] = 1; /* a */
         src += 4;
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
d46 1
a46 16
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      const float *src = src_row;
      uint8_t *dst = dst_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = float3_to_rgb9e5(src);
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         *(uint32_t *)dst = value;
         src += 4;
         dst += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
d53 1
a53 6
   uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   rgb9e5_to_float3(value, dst);
   dst[3] = 1; /* a */
d62 1
a62 21
   unsigned x, y;
   float p[3];
   for(y = 0; y < height; y += 1) {
      uint8_t *dst = dst_row;
      const uint8_t *src = src_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         rgb9e5_to_float3(value, p);
         dst[0] = float_to_ubyte(p[0]); /* r */
         dst[1] = float_to_ubyte(p[1]); /* g */
         dst[2] = float_to_ubyte(p[2]); /* b */
         dst[3] = 255; /* a */
         src += 4;
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
a70 112
   unsigned x, y;
   float p[3];
   for(y = 0; y < height; y += 1) {
      const uint8_t *src = src_row;
      uint8_t *dst = dst_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value;
         p[0] = ubyte_to_float(src[0]);
         p[1] = ubyte_to_float(src[1]);
         p[2] = ubyte_to_float(src[2]);
         value = float3_to_rgb9e5(p);
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         *(uint32_t *)dst = value;
         src += 4;
         dst += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
}


void
util_format_r11g11b10_float_unpack_rgba_float(float *dst_row, unsigned dst_stride,
                                        const uint8_t *src_row, unsigned src_stride,
                                        unsigned width, unsigned height)
{
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      float *dst = dst_row;
      const uint8_t *src = src_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         r11g11b10f_to_float3(value, dst);
         dst[3] = 1; /* a */
         src += 4;
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
}

void
util_format_r11g11b10_float_pack_rgba_float(uint8_t *dst_row, unsigned dst_stride,
                                      const float *src_row, unsigned src_stride,
                                      unsigned width, unsigned height)
{
   unsigned x, y;
   for(y = 0; y < height; y += 1) {
      const float *src = src_row;
      uint8_t *dst = dst_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = float3_to_r11g11b10f(src);
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         *(uint32_t *)dst = value;
         src += 4;
         dst += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
}

void
util_format_r11g11b10_float_fetch_rgba_float(float *dst, const uint8_t *src,
                                       unsigned i, unsigned j)
{
   uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   r11g11b10f_to_float3(value, dst);
   dst[3] = 1; /* a */
}


void
util_format_r11g11b10_float_unpack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                         const uint8_t *src_row, unsigned src_stride,
                                         unsigned width, unsigned height)
{
   unsigned x, y;
   float p[3];
   for(y = 0; y < height; y += 1) {
      uint8_t *dst = dst_row;
      const uint8_t *src = src_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value = *(const uint32_t *)src;
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         r11g11b10f_to_float3(value, p);
         dst[0] = float_to_ubyte(p[0]); /* r */
         dst[1] = float_to_ubyte(p[1]); /* g */
         dst[2] = float_to_ubyte(p[2]); /* b */
         dst[3] = 255; /* a */
         src += 4;
         dst += 4;
      }
      src_row += src_stride;
      dst_row += dst_stride/sizeof(*dst_row);
   }
}

a71 26
void
util_format_r11g11b10_float_pack_rgba_8unorm(uint8_t *dst_row, unsigned dst_stride,
                                       const uint8_t *src_row, unsigned src_stride,
                                       unsigned width, unsigned height)
{
   unsigned x, y;
   float p[3];
   for(y = 0; y < height; y += 1) {
      const uint8_t *src = src_row;
      uint8_t *dst = dst_row;
      for(x = 0; x < width; x += 1) {
         uint32_t value;
         p[0] = ubyte_to_float(src[0]);
         p[1] = ubyte_to_float(src[1]);
         p[2] = ubyte_to_float(src[2]);
         value = float3_to_r11g11b10f(p);
#ifdef PIPE_ARCH_BIG_ENDIAN
         value = util_bswap32(value);
#endif
         *(uint32_t *)dst = value;
         src += 4;
         dst += 4;
      }
      dst_row += dst_stride;
      src_row += src_stride/sizeof(*src_row);
   }
d149 1
a149 1
         value = util_bswap16(value);
d181 1
a181 1
         value = util_bswap16(value);
d215 1
a215 1
         value = util_bswap16(value);
d245 1
a245 1
         value = util_bswap16(value);
d266 1
a266 1
   value = util_bswap16(value);
@

