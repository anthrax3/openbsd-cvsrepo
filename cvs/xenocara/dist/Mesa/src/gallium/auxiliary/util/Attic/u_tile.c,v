head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.52;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.48;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * RGBA/float tile get/put functions.
 * Usable both by drivers and state trackers.
 */


#include "pipe/p_defines.h"
#include "util/u_inlines.h"

#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_surface.h"
#include "util/u_tile.h"


/**
 * Move raw block of pixels from transfer object to user memory.
 */
void
pipe_get_tile_raw(struct pipe_transfer *pt,
                  const void *src,
                  uint x, uint y, uint w, uint h,
                  void *dst, int dst_stride)
{
   if (dst_stride == 0)
      dst_stride = util_format_get_stride(pt->resource->format, w);

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   util_copy_rect(dst, pt->resource->format, dst_stride, 0, 0, w, h, src, pt->stride, x, y);
}


/**
 * Move raw block of pixels from user memory to transfer object.
 */
void
pipe_put_tile_raw(struct pipe_transfer *pt,
                  void *dst,
                  uint x, uint y, uint w, uint h,
                  const void *src, int src_stride)
{
   enum pipe_format format = pt->resource->format;

   if (src_stride == 0)
      src_stride = util_format_get_stride(format, w);

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   util_copy_rect(dst, format, pt->stride, x, y, w, h, src, src_stride, 0, 0);
}




/** Convert short in [-32768,32767] to GLfloat in [-1.0,1.0] */
#define SHORT_TO_FLOAT(S)   ((2.0F * (S) + 1.0F) * (1.0F/65535.0F))

#define UNCLAMPED_FLOAT_TO_SHORT(us, f)  \
   us = ( (short) ( CLAMP((f), -1.0, 1.0) * 32767.0F) )



/*** PIPE_FORMAT_Z16_UNORM ***/

/**
 * Return each Z value as four floats in [0,1].
 */
static void
z16_get_tile_rgba(const ushort *src,
                  unsigned w, unsigned h,
                  float *p,
                  unsigned dst_stride)
{
   const float scale = 1.0f / 65535.0f;
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = *src++ * scale;
      }
      p += dst_stride;
   }
}




/*** PIPE_FORMAT_Z32_UNORM ***/

/**
 * Return each Z value as four floats in [0,1].
 */
static void
z32_get_tile_rgba(const unsigned *src,
                  unsigned w, unsigned h,
                  float *p,
                  unsigned dst_stride)
{
   const double scale = 1.0 / (double) 0xffffffff;
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = (float) (*src++ * scale);
      }
      p += dst_stride;
   }
}


/*** PIPE_FORMAT_Z24_UNORM_S8_UINT ***/

/**
 * Return Z component as four float in [0,1].  Stencil part ignored.
 */
static void
s8z24_get_tile_rgba(const unsigned *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride)
{
   const double scale = 1.0 / ((1 << 24) - 1);
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = (float) (scale * (*src++ & 0xffffff));
      }
      p += dst_stride;
   }
}


/*** PIPE_FORMAT_S8_UINT_Z24_UNORM ***/

/**
 * Return Z component as four float in [0,1].  Stencil part ignored.
 */
static void
z24s8_get_tile_rgba(const unsigned *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride)
{
   const double scale = 1.0 / ((1 << 24) - 1);
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = (float) (scale * (*src++ >> 8));
      }
      p += dst_stride;
   }
}

/*** PIPE_FORMAT_S8X24_UINT ***/

/**
 * Return S component as four uint32_t in [0..255].  Z part ignored.
 */
static void
s8x24_get_tile_rgba(const unsigned *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;

      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = (float)((*src++ >> 24) & 0xff);
      }

      p += dst_stride;
   }
}

/*** PIPE_FORMAT_X24S8_UINT ***/

/**
 * Return S component as four uint32_t in [0..255].  Z part ignored.
 */
static void
x24s8_get_tile_rgba(const unsigned *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = (float)(*src++ & 0xff);
      }
      p += dst_stride;
   }
}


/**
 * Return S component as four uint32_t in [0..255].  Z part ignored.
 */
static void
s8_get_tile_rgba(const unsigned char *src,
		 unsigned w, unsigned h,
		 float *p,
		 unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = (float)(*src++ & 0xff);
      }
      p += dst_stride;
   }
}

/*** PIPE_FORMAT_Z32_FLOAT ***/

/**
 * Return each Z value as four floats in [0,1].
 */
static void
z32f_get_tile_rgba(const float *src,
                   unsigned w, unsigned h,
                   float *p,
                   unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = *src++;
      }
      p += dst_stride;
   }
}

/*** PIPE_FORMAT_Z32_FLOAT_S8X24_UINT ***/

/**
 * Return each Z value as four floats in [0,1].
 */
static void
z32f_x24s8_get_tile_rgba(const float *src,
                         unsigned w, unsigned h,
                         float *p,
                         unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = *src;
         src += 2;
      }
      p += dst_stride;
   }
}

/*** PIPE_FORMAT_X32_S8X24_UINT ***/

/**
 * Return S component as four uint32_t in [0..255].  Z part ignored.
 */
static void
x32_s8_get_tile_rgba(const unsigned *src,
                     unsigned w, unsigned h,
                     float *p,
                     unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         src++;
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = (float)(*src++ & 0xff);
      }
      p += dst_stride;
   }
}

void
pipe_tile_raw_to_rgba(enum pipe_format format,
                      const void *src,
                      uint w, uint h,
                      float *dst, unsigned dst_stride)
{
   switch (format) {
   case PIPE_FORMAT_Z16_UNORM:
      z16_get_tile_rgba((ushort *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_Z32_UNORM:
      z32_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
   case PIPE_FORMAT_Z24X8_UNORM:
      s8z24_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_S8_UINT:
      s8_get_tile_rgba((unsigned char *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_X24S8_UINT:
      s8x24_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
   case PIPE_FORMAT_X8Z24_UNORM:
      z24s8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_S8X24_UINT:
      x24s8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      z32f_get_tile_rgba((float *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      z32f_x24s8_get_tile_rgba((float *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_X32_S8X24_UINT:
      x32_s8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   default:
      util_format_read_4f(format,
                          dst, dst_stride * sizeof(float),
                          src, util_format_get_stride(format, w),
                          0, 0, w, h);
   }
}

void
pipe_tile_raw_to_unsigned(enum pipe_format format,
                          const void *src,
                          uint w, uint h,
                          unsigned *dst, unsigned dst_stride)
{
  util_format_read_4ui(format,
                       dst, dst_stride * sizeof(float),
                       src, util_format_get_stride(format, w),
                       0, 0, w, h);
}

void
pipe_tile_raw_to_signed(enum pipe_format format,
                          void *src,
                          uint w, uint h,
                          int *dst, unsigned dst_stride)
{
  util_format_read_4i(format,
                      dst, dst_stride * sizeof(float),
                      src, util_format_get_stride(format, w),
                      0, 0, w, h);
}

void
pipe_get_tile_rgba(struct pipe_transfer *pt,
                   const void *src,
                   uint x, uint y, uint w, uint h,
                   float *p)
{
   pipe_get_tile_rgba_format(pt, src, x, y, w, h, pt->resource->format, p);
}


void
pipe_get_tile_rgba_format(struct pipe_transfer *pt,
                          const void *src,
                          uint x, uint y, uint w, uint h,
                          enum pipe_format format,
                          float *p)
{
   unsigned dst_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box)) {
      return;
   }

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));
   if (!packed) {
      return;
   }

   if (format == PIPE_FORMAT_UYVY || format == PIPE_FORMAT_YUYV) {
      assert((x & 1) == 0);
   }

   pipe_get_tile_raw(pt, src, x, y, w, h, packed, 0);

   pipe_tile_raw_to_rgba(format, packed, w, h, p, dst_stride);

   FREE(packed);
}


void
pipe_put_tile_rgba(struct pipe_transfer *pt,
                   void *dst,
                   uint x, uint y, uint w, uint h,
                   const float *p)
{
   pipe_put_tile_rgba_format(pt, dst, x, y, w, h, pt->resource->format, p);
}


void
pipe_put_tile_rgba_format(struct pipe_transfer *pt,
                          void *dst,
                          uint x, uint y, uint w, uint h,
                          enum pipe_format format,
                          const float *p)
{
   unsigned src_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));

   if (!packed)
      return;

   switch (format) {
   case PIPE_FORMAT_Z16_UNORM:
      /*z16_put_tile_rgba((ushort *) packed, w, h, p, src_stride);*/
      break;
   case PIPE_FORMAT_Z32_UNORM:
      /*z32_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);*/
      break;
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
   case PIPE_FORMAT_Z24X8_UNORM:
      /*s8z24_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);*/
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
   case PIPE_FORMAT_X8Z24_UNORM:
      /*z24s8_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);*/
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      /*z32f_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);*/
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      /*z32f_s8x24_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);*/
      break;
   default:
      util_format_write_4f(format,
                           p, src_stride * sizeof(float),
                           packed, util_format_get_stride(format, w),
                           0, 0, w, h);
   }

   pipe_put_tile_raw(pt, dst, x, y, w, h, packed, 0);

   FREE(packed);
}

void
pipe_put_tile_i_format(struct pipe_transfer *pt,
                       void *dst,
                       uint x, uint y, uint w, uint h,
                       enum pipe_format format,
                       const int *p)
{
   unsigned src_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));

   if (!packed)
      return;

   util_format_write_4i(format,
                        p, src_stride * sizeof(float),
                        packed, util_format_get_stride(format, w),
                        0, 0, w, h);

   pipe_put_tile_raw(pt, dst, x, y, w, h, packed, 0);

   FREE(packed);
}

void
pipe_put_tile_ui_format(struct pipe_transfer *pt,
                        void *dst,
                        uint x, uint y, uint w, uint h,
                        enum pipe_format format,
                        const unsigned int *p)
{
   unsigned src_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));

   if (!packed)
      return;

   util_format_write_4ui(format,
                         p, src_stride * sizeof(float),
                         packed, util_format_get_stride(format, w),
                         0, 0, w, h);

   pipe_put_tile_raw(pt, dst, x, y, w, h, packed, 0);

   FREE(packed);
}

/**
 * Get a block of Z values, converted to 32-bit range.
 */
void
pipe_get_tile_z(struct pipe_transfer *pt,
                const void *src,
                uint x, uint y, uint w, uint h,
                uint *z)
{
   const uint dstStride = w;
   const ubyte *map = src;
   uint *pDest = z;
   uint i, j;
   enum pipe_format format = pt->resource->format;

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   switch (format) {
   case PIPE_FORMAT_Z32_UNORM:
      {
         const uint *ptrc
            = (const uint *)(map  + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            memcpy(pDest, ptrc, 4 * w);
            pDest += dstStride;
            ptrc += pt->stride/4;
         }
      }
      break;
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
   case PIPE_FORMAT_Z24X8_UNORM:
      {
         const uint *ptrc
            = (const uint *)(map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 24-bit Z to 32-bit Z */
               pDest[j] = (ptrc[j] << 8) | ((ptrc[j] >> 16) & 0xff);
            }
            pDest += dstStride;
            ptrc += pt->stride/4;
         }
      }
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
   case PIPE_FORMAT_X8Z24_UNORM:
      {
         const uint *ptrc
            = (const uint *)(map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 24-bit Z to 32-bit Z */
               pDest[j] = (ptrc[j] & 0xffffff00) | ((ptrc[j] >> 24) & 0xff);
            }
            pDest += dstStride;
            ptrc += pt->stride/4;
         }
      }
      break;
   case PIPE_FORMAT_Z16_UNORM:
      {
         const ushort *ptrc
            = (const ushort *)(map + y * pt->stride + x*2);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 16-bit Z to 32-bit Z */
               pDest[j] = (ptrc[j] << 16) | ptrc[j];
            }
            pDest += dstStride;
            ptrc += pt->stride/2;
         }
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      {
         const float *ptrc = (const float *)(map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert float Z to 32-bit Z */
               if (ptrc[j] <= 0.0) {
                  pDest[j] = 0;
               }
               else if (ptrc[j] >= 1.0) {
                  pDest[j] = 0xffffffff;
               }
               else {
                  double z = ptrc[j] * 0xffffffff;
                  pDest[j] = (uint) z;
               }
            }
            pDest += dstStride;
            ptrc += pt->stride/4;
         }
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      {
         const float *ptrc = (const float *)(map + y * pt->stride + x*8);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert float Z to 32-bit Z */
               if (ptrc[j] <= 0.0) {
                  pDest[j*2] = 0;
               }
               else if (ptrc[j] >= 1.0) {
                  pDest[j*2] = 0xffffffff;
               }
               else {
                  double z = ptrc[j] * 0xffffffff;
                  pDest[j*2] = (uint) z;
               }
            }
            pDest += dstStride;
            ptrc += pt->stride/4;
         }
      }
      break;
   default:
      assert(0);
   }
}


void
pipe_put_tile_z(struct pipe_transfer *pt,
                void *dst,
                uint x, uint y, uint w, uint h,
                const uint *zSrc)
{
   const uint srcStride = w;
   const uint *ptrc = zSrc;
   ubyte *map = dst;
   uint i, j;
   enum pipe_format format = pt->resource->format;

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   switch (format) {
   case PIPE_FORMAT_Z32_UNORM:
      {
         uint *pDest = (uint *) (map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            memcpy(pDest, ptrc, 4 * w);
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      {
         uint *pDest = (uint *) (map + y * pt->stride + x*4);
         /*assert((pt->usage & PIPE_TRANSFER_READ_WRITE) == PIPE_TRANSFER_READ_WRITE);*/
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit Z to 24-bit Z, preserve stencil */
               pDest[j] = (pDest[j] & 0xff000000) | ptrc[j] >> 8;
            }
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
   case PIPE_FORMAT_Z24X8_UNORM:
      {
         uint *pDest = (uint *) (map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit Z to 24-bit Z (0 stencil) */
               pDest[j] = ptrc[j] >> 8;
            }
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      {
         uint *pDest = (uint *) (map + y * pt->stride + x*4);
         /*assert((pt->usage & PIPE_TRANSFER_READ_WRITE) == PIPE_TRANSFER_READ_WRITE);*/
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit Z to 24-bit Z, preserve stencil */
               pDest[j] = (pDest[j] & 0xff) | (ptrc[j] & 0xffffff00);
            }
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
   case PIPE_FORMAT_X8Z24_UNORM:
      {
         uint *pDest = (uint *) (map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit Z to 24-bit Z (0 stencil) */
               pDest[j] = ptrc[j] & 0xffffff00;
            }
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
   case PIPE_FORMAT_Z16_UNORM:
      {
         ushort *pDest = (ushort *) (map + y * pt->stride + x*2);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit Z to 16-bit Z */
               pDest[j] = ptrc[j] >> 16;
            }
            pDest += pt->stride/2;
            ptrc += srcStride;
         }
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      {
         float *pDest = (float *) (map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit integer Z to float Z */
               const double scale = 1.0 / 0xffffffffU;
               pDest[j] = (float) (ptrc[j] * scale);
            }
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      {
         float *pDest = (float *) (map + y * pt->stride + x*8);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit integer Z to float Z */
               const double scale = 1.0 / 0xffffffffU;
               pDest[j*2] = (float) (ptrc[j] * scale);
            }
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
   default:
      assert(0);
   }
}


void
pipe_get_tile_ui_format(struct pipe_transfer *pt,
                        const void *src,
                        uint x, uint y, uint w, uint h,
                        enum pipe_format format,
                        unsigned int *p)
{
   unsigned dst_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box)) {
      return;
   }

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));
   if (!packed) {
      return;
   }

   if (format == PIPE_FORMAT_UYVY || format == PIPE_FORMAT_YUYV) {
      assert((x & 1) == 0);
   }

   pipe_get_tile_raw(pt, src, x, y, w, h, packed, 0);

   pipe_tile_raw_to_unsigned(format, packed, w, h, p, dst_stride);

   FREE(packed);
}


void
pipe_get_tile_i_format(struct pipe_transfer *pt,
                       const void *src,
                       uint x, uint y, uint w, uint h,
                       enum pipe_format format,
                       int *p)
{
   unsigned dst_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box)) {
      return;
   }

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));
   if (!packed) {
      return;
   }

   if (format == PIPE_FORMAT_UYVY || format == PIPE_FORMAT_YUYV) {
      assert((x & 1) == 0);
   }

   pipe_get_tile_raw(pt, src, x, y, w, h, packed, 0);

   pipe_tile_raw_to_signed(format, packed, w, h, p, dst_stride);

   FREE(packed);
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d40 1
a40 1
#include "util/u_rect.h"
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d48 2
a49 2
pipe_get_tile_raw(struct pipe_context *pipe,
                  struct pipe_transfer *pt,
a52 2
   const void *src;

a58 5
   src = pipe->transfer_map(pipe, pt);
   assert(src);
   if(!src)
      return;

a59 2

   pipe->transfer_unmap(pipe, pt);
d67 2
a68 2
pipe_put_tile_raw(struct pipe_context *pipe,
                  struct pipe_transfer *pt,
a71 1
   void *dst;
a79 5
   dst = pipe->transfer_map(pipe, pt);
   assert(dst);
   if(!dst)
      return;

a80 2

   pipe->transfer_unmap(pipe, pt);
d150 1
a150 1
/*** PIPE_FORMAT_Z24_UNORM_S8_USCALED ***/
d177 1
a177 1
/*** PIPE_FORMAT_S8_USCALED_Z24_UNORM ***/
d203 1
a203 1
/*** PIPE_FORMAT_S8X24_USCALED ***/
d230 1
a230 1
/*** PIPE_FORMAT_X24S8_USCALED ***/
d304 51
d358 1
a358 1
                      void *src,
d369 1
a369 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d373 1
a373 1
   case PIPE_FORMAT_S8_USCALED:
d376 1
a376 1
   case PIPE_FORMAT_X24S8_USCALED:
d379 1
a379 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d383 1
a383 1
   case PIPE_FORMAT_S8X24_USCALED:
d389 6
d403 23
d428 2
a429 2
pipe_get_tile_rgba(struct pipe_context *pipe,
                   struct pipe_transfer *pt,
d433 1
a433 1
   pipe_get_tile_rgba_format(pipe, pt, x, y, w, h, pt->resource->format, p);
d438 2
a439 2
pipe_get_tile_rgba_format(struct pipe_context *pipe,
                          struct pipe_transfer *pt,
d460 1
a460 1
   pipe_get_tile_raw(pipe, pt, x, y, w, h, packed, 0);
d469 2
a470 2
pipe_put_tile_rgba(struct pipe_context *pipe,
                   struct pipe_transfer *pt,
d474 1
a474 1
   pipe_put_tile_rgba_format(pipe, pt, x, y, w, h, pt->resource->format, p);
d479 2
a480 2
pipe_put_tile_rgba_format(struct pipe_context *pipe,
                          struct pipe_transfer *pt,
d503 1
a503 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d507 1
a507 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d511 6
d524 1
a524 1
   pipe_put_tile_raw(pipe, pt, x, y, w, h, packed, 0);
d529 55
d589 2
a590 2
pipe_get_tile_z(struct pipe_context *pipe,
                struct pipe_transfer *pt,
d595 1
a595 1
   ubyte *map;
a602 6
   map = (ubyte *)pipe->transfer_map(pipe, pt);
   if (!map) {
      assert(0);
      return;
   }

d615 1
a615 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d630 1
a630 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d659 44
a705 2

   pipe->transfer_unmap(pipe, pt);
d710 2
a711 2
pipe_put_tile_z(struct pipe_context *pipe,
                struct pipe_transfer *pt,
d717 1
a717 1
   ubyte *map;
a723 6
   map = (ubyte *)pipe->transfer_map(pipe, pt);
   if (!map) {
      assert(0);
      return;
   }

d735 1
a735 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d762 1
a762 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d802 28
d833 16
d850 14
a863 1
   pipe->transfer_unmap(pipe, pt);
d867 29
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d370 1
a370 20
   unsigned dst_stride = w * 4;
   void *packed;
   enum pipe_format format = pt->resource->format;

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));

   if (!packed)
      return;

   if(format == PIPE_FORMAT_UYVY || format == PIPE_FORMAT_YUYV)
      assert((x & 1) == 0);

   pipe_get_tile_raw(pipe, pt, x, y, w, h, packed, 0);

   pipe_tile_raw_to_rgba(format, packed, w, h, p, dst_stride);

   FREE(packed);
d375 5
a379 12
pipe_get_tile_swizzle(struct pipe_context *pipe,
		      struct pipe_transfer *pt,
                      uint x,
                      uint y,
                      uint w,
                      uint h,
                      uint swizzle_r,
                      uint swizzle_g,
                      uint swizzle_b,
                      uint swizzle_a,
                      enum pipe_format format,
                      float *p)
a382 2
   uint iy;
   float rgba01[6];
a401 29

   if (swizzle_r == PIPE_SWIZZLE_RED &&
       swizzle_g == PIPE_SWIZZLE_GREEN &&
       swizzle_b == PIPE_SWIZZLE_BLUE &&
       swizzle_a == PIPE_SWIZZLE_ALPHA) {
      /* no-op, skip */
      return;
   }

   rgba01[PIPE_SWIZZLE_ZERO] = 0.0f;
   rgba01[PIPE_SWIZZLE_ONE] = 1.0f;

   for (iy = 0; iy < h; iy++) {
      float *row = p;
      uint ix;

      for (ix = 0; ix < w; ix++) {
         rgba01[PIPE_SWIZZLE_RED] = row[0];
         rgba01[PIPE_SWIZZLE_GREEN] = row[1];
         rgba01[PIPE_SWIZZLE_BLUE] = row[2];
         rgba01[PIPE_SWIZZLE_ALPHA] = row[3];

         *row++ = rgba01[swizzle_r];
         *row++ = rgba01[swizzle_g];
         *row++ = rgba01[swizzle_b];
         *row++ = rgba01[swizzle_a];
      }
      p += dst_stride;
   }
d411 11
a423 1
   enum pipe_format format = pt->resource->format;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d48 2
a49 1
pipe_get_tile_raw(struct pipe_transfer *pt,
a52 1
   struct pipe_screen *screen = pt->texture->screen;
d56 1
a56 1
      dst_stride = util_format_get_stride(pt->texture->format, w);
d58 1
a58 1
   if (pipe_clip_tile(x, y, &w, &h, pt))
d61 1
a61 1
   src = screen->transfer_map(screen, pt);
d66 1
a66 1
   util_copy_rect(dst, pt->texture->format, dst_stride, 0, 0, w, h, src, pt->stride, x, y);
d68 1
a68 1
   screen->transfer_unmap(screen, pt);
d76 2
a77 1
pipe_put_tile_raw(struct pipe_transfer *pt,
a80 1
   struct pipe_screen *screen = pt->texture->screen;
d82 1
a82 1
   enum pipe_format format = pt->texture->format;
d87 1
a87 1
   if (pipe_clip_tile(x, y, &w, &h, pt))
d90 1
a90 1
   dst = screen->transfer_map(screen, pt);
d97 1
a97 1
   screen->transfer_unmap(screen, pt);
a110 381
/*** PIPE_FORMAT_B8G8R8A8_UNORM ***/

static void
a8r8g8b8_get_tile_rgba(const unsigned *src,
                       unsigned w, unsigned h,
                       float *p,
                       unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         const unsigned pixel = *src++;
         pRow[0] = ubyte_to_float((pixel >> 16) & 0xff);
         pRow[1] = ubyte_to_float((pixel >>  8) & 0xff);
         pRow[2] = ubyte_to_float((pixel >>  0) & 0xff);
         pRow[3] = ubyte_to_float((pixel >> 24) & 0xff);
      }
      p += dst_stride;
   }
}


static void
a8r8g8b8_put_tile_rgba(unsigned *dst,
                       unsigned w, unsigned h,
                       const float *p,
                       unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, g, b, a;
         r = float_to_ubyte(pRow[0]);
         g = float_to_ubyte(pRow[1]);
         b = float_to_ubyte(pRow[2]);
         a = float_to_ubyte(pRow[3]);
         *dst++ = (a << 24) | (r << 16) | (g << 8) | b;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_B8G8R8X8_UNORM ***/

static void
x8r8g8b8_get_tile_rgba(const unsigned *src,
                       unsigned w, unsigned h,
                       float *p,
                       unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         const unsigned pixel = *src++;
         pRow[0] = ubyte_to_float((pixel >> 16) & 0xff);
         pRow[1] = ubyte_to_float((pixel >>  8) & 0xff);
         pRow[2] = ubyte_to_float((pixel >>  0) & 0xff);
         pRow[3] = 1.0F;
      }
      p += dst_stride;
   }
}


static void
x8r8g8b8_put_tile_rgba(unsigned *dst,
                       unsigned w, unsigned h,
                       const float *p,
                       unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, g, b;
         r = float_to_ubyte(pRow[0]);
         g = float_to_ubyte(pRow[1]);
         b = float_to_ubyte(pRow[2]);
         *dst++ = (0xff << 24) | (r << 16) | (g << 8) | b;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_A8R8G8B8_UNORM ***/

static void
b8g8r8a8_get_tile_rgba(const unsigned *src,
                       unsigned w, unsigned h,
                       float *p,
                       unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         const unsigned pixel = *src++;
         pRow[0] = ubyte_to_float((pixel >>  8) & 0xff);
         pRow[1] = ubyte_to_float((pixel >> 16) & 0xff);
         pRow[2] = ubyte_to_float((pixel >> 24) & 0xff);
         pRow[3] = ubyte_to_float((pixel >>  0) & 0xff);
      }
      p += dst_stride;
   }
}


static void
b8g8r8a8_put_tile_rgba(unsigned *dst,
                       unsigned w, unsigned h,
                       const float *p,
                       unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, g, b, a;
         r = float_to_ubyte(pRow[0]);
         g = float_to_ubyte(pRow[1]);
         b = float_to_ubyte(pRow[2]);
         a = float_to_ubyte(pRow[3]);
         *dst++ = (b << 24) | (g << 16) | (r << 8) | a;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_A8B8G8R8_UNORM ***/

static void
r8g8b8a8_get_tile_rgba(const unsigned *src,
                       unsigned w, unsigned h,
                       float *p,
                       unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         const unsigned pixel = *src++;
         pRow[0] = ubyte_to_float((pixel >> 24) & 0xff);
         pRow[1] = ubyte_to_float((pixel >> 16) & 0xff);
         pRow[2] = ubyte_to_float((pixel >>  8) & 0xff);
         pRow[3] = ubyte_to_float((pixel >>  0) & 0xff);
      }
      p += dst_stride;
   }
}


static void
r8g8b8a8_put_tile_rgba(unsigned *dst,
                       unsigned w, unsigned h,
                       const float *p,
                       unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, g, b, a;
         r = float_to_ubyte(pRow[0]);
         g = float_to_ubyte(pRow[1]);
         b = float_to_ubyte(pRow[2]);
         a = float_to_ubyte(pRow[3]);
         *dst++ = (r << 24) | (g << 16) | (b << 8) | a;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_B5G5R5A1_UNORM ***/

static void
a1r5g5b5_get_tile_rgba(const ushort *src,
                       unsigned w, unsigned h,
                       float *p,
                       unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         const ushort pixel = *src++;
         pRow[0] = ((pixel >> 10) & 0x1f) * (1.0f / 31.0f);
         pRow[1] = ((pixel >>  5) & 0x1f) * (1.0f / 31.0f);
         pRow[2] = ((pixel      ) & 0x1f) * (1.0f / 31.0f);
         pRow[3] = ((pixel >> 15)       ) * 1.0f;
      }
      p += dst_stride;
   }
}


static void
a1r5g5b5_put_tile_rgba(ushort *dst,
                       unsigned w, unsigned h,
                       const float *p,
                       unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, g, b, a;
         r = float_to_ubyte(pRow[0]);
         g = float_to_ubyte(pRow[1]);
         b = float_to_ubyte(pRow[2]);
         a = float_to_ubyte(pRow[3]);
         r = r >> 3;  /* 5 bits */
         g = g >> 3;  /* 5 bits */
         b = b >> 3;  /* 5 bits */
         a = a >> 7;  /* 1 bit */
         *dst++ = (a << 15) | (r << 10) | (g << 5) | b;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_B4G4R4A4_UNORM ***/

static void
a4r4g4b4_get_tile_rgba(const ushort *src,
                       unsigned w, unsigned h,
                       float *p,
                       unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         const ushort pixel = *src++;
         pRow[0] = ((pixel >>  8) & 0xf) * (1.0f / 15.0f);
         pRow[1] = ((pixel >>  4) & 0xf) * (1.0f / 15.0f);
         pRow[2] = ((pixel      ) & 0xf) * (1.0f / 15.0f);
         pRow[3] = ((pixel >> 12)      ) * (1.0f / 15.0f);
      }
      p += dst_stride;
   }
}


static void
a4r4g4b4_put_tile_rgba(ushort *dst,
                       unsigned w, unsigned h,
                       const float *p,
                       unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, g, b, a;
         r = float_to_ubyte(pRow[0]);
         g = float_to_ubyte(pRow[1]);
         b = float_to_ubyte(pRow[2]);
         a = float_to_ubyte(pRow[3]);
         r >>= 4;
         g >>= 4;
         b >>= 4;
         a >>= 4;
         *dst++ = (a << 12) | (r << 8) | (g << 4) | b;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_B5G6R5_UNORM ***/

static void
r5g6b5_get_tile_rgba(const ushort *src,
                     unsigned w, unsigned h,
                     float *p,
                     unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         const ushort pixel = *src++;
         pRow[0] = ((pixel >> 11) & 0x1f) * (1.0f / 31.0f);
         pRow[1] = ((pixel >>  5) & 0x3f) * (1.0f / 63.0f);
         pRow[2] = ((pixel      ) & 0x1f) * (1.0f / 31.0f);
         pRow[3] = 1.0f;
      }
      p += dst_stride;
   }
}


static void
r5g6b5_put_tile_rgba(ushort *dst,
                     unsigned w, unsigned h,
                     const float *p,
                     unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         uint r = (uint) (CLAMP(pRow[0], 0.0, 1.0) * 31.0);
         uint g = (uint) (CLAMP(pRow[1], 0.0, 1.0) * 63.0);
         uint b = (uint) (CLAMP(pRow[2], 0.0, 1.0) * 31.0);
         *dst++ = (r << 11) | (g << 5) | (b);
      }
      p += src_stride;
   }
}



/*** PIPE_FORMAT_R8G8B8_UNORM ***/

static void
r8g8b8_get_tile_rgba(const ubyte *src,
                     unsigned w, unsigned h,
                     float *p,
                     unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] = ubyte_to_float(src[0]);
         pRow[1] = ubyte_to_float(src[1]);
         pRow[2] = ubyte_to_float(src[2]);
         pRow[3] = 1.0f;
         src += 3;
      }
      p += dst_stride;
   }
}


static void
r8g8b8_put_tile_rgba(ubyte *dst,
                     unsigned w, unsigned h,
                     const float *p,
                     unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         dst[0] = float_to_ubyte(pRow[0]);
         dst[1] = float_to_ubyte(pRow[1]);
         dst[2] = float_to_ubyte(pRow[2]);
         dst += 3;
      }
      p += src_stride;
   }
}



d114 1
a114 233
 * Return each Z value as four floats in [0,1].
 */
static void
z16_get_tile_rgba(const ushort *src,
                  unsigned w, unsigned h,
                  float *p,
                  unsigned dst_stride)
{
   const float scale = 1.0f / 65535.0f;
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = *src++ * scale;
      }
      p += dst_stride;
   }
}




/*** PIPE_FORMAT_L8_UNORM ***/

static void
l8_get_tile_rgba(const ubyte *src,
                 unsigned w, unsigned h,
                 float *p,
                 unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, src++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] = ubyte_to_float(*src);
         pRow[3] = 1.0;
      }
      p += dst_stride;
   }
}


static void
l8_put_tile_rgba(ubyte *dst,
                 unsigned w, unsigned h,
                 const float *p,
                 unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r;
         r = float_to_ubyte(pRow[0]);
         *dst++ = (ubyte) r;
      }
      p += src_stride;
   }
}



/*** PIPE_FORMAT_A8_UNORM ***/

static void
a8_get_tile_rgba(const ubyte *src,
                 unsigned w, unsigned h,
                 float *p,
                 unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, src++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] = 0.0;
         pRow[3] = ubyte_to_float(*src);
      }
      p += dst_stride;
   }
}


static void
a8_put_tile_rgba(ubyte *dst,
                 unsigned w, unsigned h,
                 const float *p,
                 unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned a;
         a = float_to_ubyte(pRow[3]);
         *dst++ = (ubyte) a;
      }
      p += src_stride;
   }
}



/*** PIPE_FORMAT_R16_SNORM ***/

static void
r16_get_tile_rgba(const short *src,
                  unsigned w, unsigned h,
                  float *p,
                  unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, src++, pRow += 4) {
         pRow[0] = SHORT_TO_FLOAT(src[0]);
         pRow[1] =
         pRow[2] = 0.0;
         pRow[3] = 1.0;
      }
      p += dst_stride;
   }
}


static void
r16_put_tile_rgba(short *dst,
                  unsigned w, unsigned h,
                  const float *p,
                  unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, dst++, pRow += 4) {
         UNCLAMPED_FLOAT_TO_SHORT(dst[0], pRow[0]);
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_R16G16B16A16_SNORM ***/

static void
r16g16b16a16_get_tile_rgba(const short *src,
                           unsigned w, unsigned h,
                           float *p,
                           unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, src += 4, pRow += 4) {
         pRow[0] = SHORT_TO_FLOAT(src[0]);
         pRow[1] = SHORT_TO_FLOAT(src[1]);
         pRow[2] = SHORT_TO_FLOAT(src[2]);
         pRow[3] = SHORT_TO_FLOAT(src[3]);
      }
      p += dst_stride;
   }
}


static void
r16g16b16a16_put_tile_rgba(short *dst,
                           unsigned w, unsigned h,
                           const float *p,
                           unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, dst += 4, pRow += 4) {
         UNCLAMPED_FLOAT_TO_SHORT(dst[0], pRow[0]);
         UNCLAMPED_FLOAT_TO_SHORT(dst[1], pRow[1]);
         UNCLAMPED_FLOAT_TO_SHORT(dst[2], pRow[2]);
         UNCLAMPED_FLOAT_TO_SHORT(dst[3], pRow[3]);
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_A8B8G8R8_SRGB ***/

/**
 * Convert an 8-bit sRGB value from non-linear space to a
 * linear RGB value in [0, 1].
 * Implemented with a 256-entry lookup table.
 */
static INLINE float
srgb_to_linear(ubyte cs8)
{
   static float table[256];
   static boolean tableReady = FALSE;
   if (!tableReady) {
      /* compute lookup table now */
      uint i;
      for (i = 0; i < 256; i++) {
         const float cs = ubyte_to_float(i);
         if (cs <= 0.04045) {
            table[i] = cs / 12.92f;
         }
         else {
            table[i] = (float) powf((cs + 0.055) / 1.055, 2.4);
         }
      }
      tableReady = TRUE;
   }
   return table[cs8];
}


/**
 * Convert linear float in [0,1] to an srgb ubyte value in [0,255].
 * XXX this hasn't been tested (render to srgb surface).
 * XXX this needs optimization.
a115 14
static INLINE ubyte
linear_to_srgb(float cl)
{
   if (cl >= 1.0F)
      return 255;
   else if (cl >= 0.0031308F)
      return float_to_ubyte(1.055F * powf(cl, 0.41666F) - 0.055F);
   else if (cl > 0.0F)
      return float_to_ubyte(12.92F * cl);
   else
      return 0.0;
}


d117 4
a120 4
a8r8g8b8_srgb_get_tile_rgba(const unsigned *src,
                            unsigned w, unsigned h,
                            float *p,
                            unsigned dst_stride)
d122 1
d128 4
a131 5
         const unsigned pixel = *src++;
         pRow[0] = srgb_to_linear((pixel >> 16) & 0xff);
         pRow[1] = srgb_to_linear((pixel >>  8) & 0xff);
         pRow[2] = srgb_to_linear((pixel >>  0) & 0xff);
         pRow[3] = ubyte_to_float((pixel >> 24) & 0xff);
a136 7
static void
a8r8g8b8_srgb_put_tile_rgba(unsigned *dst,
                            unsigned w, unsigned h,
                            const float *p,
                            unsigned src_stride)
{
   unsigned i, j;
a137 13
   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, g, b, a;
         r = linear_to_srgb(pRow[0]);
         g = linear_to_srgb(pRow[1]);
         b = linear_to_srgb(pRow[2]);
         a = float_to_ubyte(pRow[3]);
         *dst++ = (a << 24) | (r << 16) | (g << 8) | b;
      }
      p += src_stride;
   }
}
d140 1
a140 1
/*** PIPE_FORMAT_L8A8_SRGB ***/
d142 3
d146 4
a149 4
a8l8_srgb_get_tile_rgba(const ushort *src,
                        unsigned w, unsigned h,
                        float *p,
                        unsigned dst_stride)
d151 1
a156 1
         ushort p = *src++;
d159 2
a160 2
         pRow[2] = srgb_to_linear(p & 0xff);
         pRow[3] = ubyte_to_float(p >> 8);
a165 7
static void
a8l8_srgb_put_tile_rgba(ushort *dst,
                        unsigned w, unsigned h,
                        const float *p,
                        unsigned src_stride)
{
   unsigned i, j;
d167 1
a167 14
   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, a;
         r = linear_to_srgb(pRow[0]);
         a = float_to_ubyte(pRow[3]);
         *dst++ = (a << 8) | r;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_L8_SRGB ***/
d169 3
d173 4
a176 4
l8_srgb_get_tile_rgba(const ubyte *src,
                      unsigned w, unsigned h,
                      float *p,
                      unsigned dst_stride)
d178 1
a182 20
      for (j = 0; j < w; j++, src++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] = srgb_to_linear(*src);
         pRow[3] = 1.0;
      }
      p += dst_stride;
   }
}

static void
l8_srgb_put_tile_rgba(ubyte *dst,
                      unsigned w, unsigned h,
                      const float *p,
                      unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
a183 22
         unsigned r;
         r = linear_to_srgb(pRow[0]);
         *dst++ = (ubyte) r;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_I8_UNORM ***/

static void
i8_get_tile_rgba(const ubyte *src,
                 unsigned w, unsigned h,
                 float *p,
                 unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, src++, pRow += 4) {
d187 1
a187 1
         pRow[3] = ubyte_to_float(*src);
d194 1
a194 21
static void
i8_put_tile_rgba(ubyte *dst,
                 unsigned w, unsigned h,
                 const float *p,
                 unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r;
         r = float_to_ubyte(pRow[0]);
         *dst++ = (ubyte) r;
      }
      p += src_stride;
   }
}


/*** PIPE_FORMAT_L8A8_UNORM ***/
d196 3
d200 4
a203 4
a8l8_get_tile_rgba(const ushort *src,
                   unsigned w, unsigned h,
                   float *p,
                   unsigned dst_stride)
d205 1
a210 1
         ushort p = *src++;
d213 2
a214 2
         pRow[2] = ubyte_to_float(p & 0xff);
         pRow[3] = ubyte_to_float(p >> 8);
d220 1
a220 25

static void
a8l8_put_tile_rgba(ushort *dst,
                   unsigned w, unsigned h,
                   const float *p,
                   unsigned src_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      const float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         unsigned r, a;
         r = float_to_ubyte(pRow[0]);
         a = float_to_ubyte(pRow[3]);
         *dst++ = (a << 8) | r;
      }
      p += src_stride;
   }
}




/*** PIPE_FORMAT_Z32_UNORM ***/
d223 1
a223 1
 * Return each Z value as four floats in [0,1].
d226 4
a229 4
z32_get_tile_rgba(const unsigned *src,
                  unsigned w, unsigned h,
                  float *p,
                  unsigned dst_stride)
a230 1
   const double scale = 1.0 / (double) 0xffffffff;
d235 1
d240 1
a240 1
         pRow[3] = (float) (*src++ * scale);
d242 1
d247 1
a247 2

/*** PIPE_FORMAT_Z24S8_UNORM ***/
d250 1
a250 1
 * Return Z component as four float in [0,1].  Stencil part ignored.
d253 1
a253 1
s8z24_get_tile_rgba(const unsigned *src,
a257 1
   const double scale = 1.0 / ((1 << 24) - 1);
d266 1
a266 1
         pRow[3] = (float) (scale * (*src++ & 0xffffff));
a272 2
/*** PIPE_FORMAT_S8Z24_UNORM ***/

d274 1
a274 1
 * Return Z component as four float in [0,1].  Stencil part ignored.
d277 4
a280 4
z24s8_get_tile_rgba(const unsigned *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride)
a281 1
   const double scale = 1.0 / ((1 << 24) - 1);
d290 1
a290 1
         pRow[3] = (float) (scale * (*src++ >> 8));
a295 1

a321 88
/*** PIPE_FORMAT_UYVY / PIPE_FORMAT_YUYV ***/

/**
 * Convert YCbCr (or YCrCb) to RGBA.
 */
static void
ycbcr_get_tile_rgba(const ushort *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride,
                    boolean rev)
{
   const float scale = 1.0f / 255.0f;
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      /* do two texels at a time */
      for (j = 0; j < (w & ~1); j += 2, src += 2) {
         const ushort t0 = src[0];
         const ushort t1 = src[1];
         const ubyte y0 = (t0 >> 8) & 0xff;  /* luminance */
         const ubyte y1 = (t1 >> 8) & 0xff;  /* luminance */
         ubyte cb, cr;
         float r, g, b;

         if (rev) {
            cb = t1 & 0xff;         /* chroma U */
            cr = t0 & 0xff;         /* chroma V */
         }
         else {
            cb = t0 & 0xff;         /* chroma U */
            cr = t1 & 0xff;         /* chroma V */
         }

         /* even pixel: y0,cr,cb */
         r = 1.164f * (y0-16) + 1.596f * (cr-128);
         g = 1.164f * (y0-16) - 0.813f * (cr-128) - 0.391f * (cb-128);
         b = 1.164f * (y0-16) + 2.018f * (cb-128);
         pRow[0] = r * scale;
         pRow[1] = g * scale;
         pRow[2] = b * scale;
         pRow[3] = 1.0f;
         pRow += 4;

         /* odd pixel: use y1,cr,cb */
         r = 1.164f * (y1-16) + 1.596f * (cr-128);
         g = 1.164f * (y1-16) - 0.813f * (cr-128) - 0.391f * (cb-128);
         b = 1.164f * (y1-16) + 2.018f * (cb-128);
         pRow[0] = r * scale;
         pRow[1] = g * scale;
         pRow[2] = b * scale;
         pRow[3] = 1.0f;
         pRow += 4;

      }
      /* do the last texel */
      if (w & 1) {
         const ushort t0 = src[0];
         const ushort t1 = src[1];
         const ubyte y0 = (t0 >> 8) & 0xff;  /* luminance */
         ubyte cb, cr;
         float r, g, b;

         if (rev) {
            cb = t1 & 0xff;         /* chroma U */
            cr = t0 & 0xff;         /* chroma V */
         }
         else {
            cb = t0 & 0xff;         /* chroma U */
            cr = t1 & 0xff;         /* chroma V */
         }

         /* even pixel: y0,cr,cb */
         r = 1.164f * (y0-16) + 1.596f * (cr-128);
         g = 1.164f * (y0-16) - 0.813f * (cr-128) - 0.391f * (cb-128);
         b = 1.164f * (y0-16) + 2.018f * (cb-128);
         pRow[0] = r * scale;
         pRow[1] = g * scale;
         pRow[2] = b * scale;
         pRow[3] = 1.0f;
         pRow += 4;
      }
      p += dst_stride;
   }
}


a328 51
   case PIPE_FORMAT_B8G8R8A8_UNORM:
      a8r8g8b8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_B8G8R8X8_UNORM:
      x8r8g8b8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_A8R8G8B8_UNORM:
      b8g8r8a8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_A8B8G8R8_UNORM:
      r8g8b8a8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_B5G5R5A1_UNORM:
      a1r5g5b5_get_tile_rgba((ushort *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_B4G4R4A4_UNORM:
      a4r4g4b4_get_tile_rgba((ushort *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_B5G6R5_UNORM:
      r5g6b5_get_tile_rgba((ushort *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_R8G8B8_UNORM:
      r8g8b8_get_tile_rgba((ubyte *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_L8_UNORM:
      l8_get_tile_rgba((ubyte *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_A8_UNORM:
      a8_get_tile_rgba((ubyte *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_I8_UNORM:
      i8_get_tile_rgba((ubyte *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_L8A8_UNORM:
      a8l8_get_tile_rgba((ushort *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_R16_SNORM:
      r16_get_tile_rgba((short *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_R16G16B16A16_SNORM:
      r16g16b16a16_get_tile_rgba((short *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_B8G8R8A8_SRGB:
      a8r8g8b8_srgb_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_L8A8_SRGB:
      a8l8_srgb_get_tile_rgba((ushort *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_L8_SRGB:
      l8_srgb_get_tile_rgba((ubyte *) src, w, h, dst, dst_stride);
      break;
d335 1
a335 1
   case PIPE_FORMAT_Z24S8_UNORM:
d339 7
a345 1
   case PIPE_FORMAT_S8Z24_UNORM:
d349 3
a354 6
   case PIPE_FORMAT_UYVY:
      ycbcr_get_tile_rgba((ushort *) src, w, h, dst, dst_stride, FALSE);
      break;
   case PIPE_FORMAT_YUYV:
      ycbcr_get_tile_rgba((ushort *) src, w, h, dst, dst_stride, TRUE);
      break;
d365 2
a366 1
pipe_get_tile_rgba(struct pipe_transfer *pt,
d372 1
a372 1
   enum pipe_format format = pt->texture->format;
d374 1
a374 1
   if (pipe_clip_tile(x, y, &w, &h, pt))
d385 41
a425 1
   pipe_get_tile_raw(pt, x, y, w, h, packed, 0);
d430 29
d463 2
a464 1
pipe_put_tile_rgba(struct pipe_transfer *pt,
d470 1
a470 1
   enum pipe_format format = pt->texture->format;
d472 1
a472 1
   if (pipe_clip_tile(x, y, &w, &h, pt))
a480 51
   case PIPE_FORMAT_B8G8R8A8_UNORM:
      a8r8g8b8_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_B8G8R8X8_UNORM:
      x8r8g8b8_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_A8R8G8B8_UNORM:
      b8g8r8a8_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_A8B8G8R8_UNORM:
      r8g8b8a8_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_B5G5R5A1_UNORM:
      a1r5g5b5_put_tile_rgba((ushort *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_B5G6R5_UNORM:
      r5g6b5_put_tile_rgba((ushort *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_R8G8B8_UNORM:
      r8g8b8_put_tile_rgba((ubyte *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_B4G4R4A4_UNORM:
      a4r4g4b4_put_tile_rgba((ushort *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_L8_UNORM:
      l8_put_tile_rgba((ubyte *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_A8_UNORM:
      a8_put_tile_rgba((ubyte *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_I8_UNORM:
      i8_put_tile_rgba((ubyte *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_L8A8_UNORM:
      a8l8_put_tile_rgba((ushort *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_R16_SNORM:
      r16_put_tile_rgba((short *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_R16G16B16A16_SNORM:
      r16g16b16a16_put_tile_rgba((short *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_B8G8R8A8_SRGB:
      a8r8g8b8_srgb_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_L8A8_SRGB:
      a8l8_srgb_put_tile_rgba((ushort *) packed, w, h, p, src_stride);
      break;
   case PIPE_FORMAT_L8_SRGB:
      l8_srgb_put_tile_rgba((ubyte *) packed, w, h, p, src_stride);
      break;
d487 1
a487 1
   case PIPE_FORMAT_Z24S8_UNORM:
d491 1
a491 1
   case PIPE_FORMAT_S8Z24_UNORM:
d502 1
a502 1
   pipe_put_tile_raw(pt, x, y, w, h, packed, 0);
d512 2
a513 1
pipe_get_tile_z(struct pipe_transfer *pt,
a516 1
   struct pipe_screen *screen = pt->texture->screen;
d521 1
a521 1
   enum pipe_format format = pt->texture->format;
d523 1
a523 1
   if (pipe_clip_tile(x, y, &w, &h, pt))
d526 1
a526 1
   map = (ubyte *)screen->transfer_map(screen, pt);
d544 1
a544 1
   case PIPE_FORMAT_Z24S8_UNORM:
d559 1
a559 1
   case PIPE_FORMAT_S8Z24_UNORM:
d592 1
a592 1
   screen->transfer_unmap(screen, pt);
d597 2
a598 1
pipe_put_tile_z(struct pipe_transfer *pt,
a601 1
   struct pipe_screen *screen = pt->texture->screen;
d606 1
a606 1
   enum pipe_format format = pt->texture->format;
d608 1
a608 1
   if (pipe_clip_tile(x, y, &w, &h, pt))
d611 1
a611 1
   map = (ubyte *)screen->transfer_map(screen, pt);
d628 1
a628 1
   case PIPE_FORMAT_Z24S8_UNORM:
d631 1
a631 1
         assert((pt->usage & PIPE_TRANSFER_READ_WRITE) == PIPE_TRANSFER_READ_WRITE);
d655 1
a655 1
   case PIPE_FORMAT_S8Z24_UNORM:
d658 1
a658 1
         assert((pt->usage & PIPE_TRANSFER_READ_WRITE) == PIPE_TRANSFER_READ_WRITE);
d699 1
a699 1
   screen->transfer_unmap(screen, pt);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d48 1
a48 2
pipe_get_tile_raw(struct pipe_context *pipe,
                  struct pipe_transfer *pt,
d52 1
d56 1
a56 1
      dst_stride = util_format_get_stride(pt->resource->format, w);
d58 1
a58 1
   if (u_clip_tile(x, y, &w, &h, &pt->box))
d61 1
a61 1
   src = pipe->transfer_map(pipe, pt);
d66 1
a66 1
   util_copy_rect(dst, pt->resource->format, dst_stride, 0, 0, w, h, src, pt->stride, x, y);
d68 1
a68 1
   pipe->transfer_unmap(pipe, pt);
d76 1
a76 2
pipe_put_tile_raw(struct pipe_context *pipe,
                  struct pipe_transfer *pt,
d80 1
d82 1
a82 1
   enum pipe_format format = pt->resource->format;
d87 1
a87 1
   if (u_clip_tile(x, y, &w, &h, &pt->box))
d90 1
a90 1
   dst = pipe->transfer_map(pipe, pt);
d97 1
a97 1
   pipe->transfer_unmap(pipe, pt);
d111 612
a722 1
/*** PIPE_FORMAT_Z16_UNORM ***/
d725 3
a727 1
 * Return each Z value as four floats in [0,1].
d729 60
d790 4
a793 4
z16_get_tile_rgba(const ushort *src,
                  unsigned w, unsigned h,
                  float *p,
                  unsigned dst_stride)
a794 1
   const float scale = 1.0f / 65535.0f;
d800 1
d803 2
a804 2
         pRow[2] =
         pRow[3] = *src++ * scale;
d810 7
d818 11
d831 1
a831 1
/*** PIPE_FORMAT_Z32_UNORM ***/
a832 3
/**
 * Return each Z value as four floats in [0,1].
 */
d834 4
a837 4
z32_get_tile_rgba(const unsigned *src,
                  unsigned w, unsigned h,
                  float *p,
                  unsigned dst_stride)
a838 1
   const double scale = 1.0 / (double) 0xffffffff;
d843 1
a843 1
      for (j = 0; j < w; j++, pRow += 4) {
d846 2
a847 2
         pRow[2] =
         pRow[3] = (float) (*src++ * scale);
d853 19
d873 1
a873 1
/*** PIPE_FORMAT_Z24_UNORM_S8_USCALED ***/
a874 3
/**
 * Return Z component as four float in [0,1].  Stencil part ignored.
 */
d876 4
a879 4
s8z24_get_tile_rgba(const unsigned *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride)
a880 1
   const double scale = 1.0 / ((1 << 24) - 1);
d885 1
a885 1
      for (j = 0; j < w; j++, pRow += 4) {
d889 1
a889 1
         pRow[3] = (float) (scale * (*src++ & 0xffffff));
d896 21
a916 1
/*** PIPE_FORMAT_S8_USCALED_Z24_UNORM ***/
a917 3
/**
 * Return Z component as four float in [0,1].  Stencil part ignored.
 */
d919 4
a922 4
z24s8_get_tile_rgba(const unsigned *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride)
a923 1
   const double scale = 1.0 / ((1 << 24) - 1);
d929 1
d932 2
a933 2
         pRow[2] =
         pRow[3] = (float) (scale * (*src++ >> 8));
d939 25
a963 1
/*** PIPE_FORMAT_S8X24_USCALED ***/
d966 1
a966 1
 * Return S component as four uint32_t in [0..255].  Z part ignored.
d969 4
a972 4
s8x24_get_tile_rgba(const unsigned *src,
                    unsigned w, unsigned h,
                    float *p,
                    unsigned dst_stride)
d974 1
a978 1

d983 1
a983 1
         pRow[3] = (float)((*src++ >> 24) & 0xff);
a984 1

d989 2
a990 1
/*** PIPE_FORMAT_X24S8_USCALED ***/
d993 1
a993 1
 * Return S component as four uint32_t in [0..255].  Z part ignored.
d996 1
a996 1
x24s8_get_tile_rgba(const unsigned *src,
d1001 1
d1010 1
a1010 1
         pRow[3] = (float)(*src++ & 0xff);
d1017 2
d1020 1
a1020 1
 * Return S component as four uint32_t in [0..255].  Z part ignored.
d1023 4
a1026 4
s8_get_tile_rgba(const unsigned char *src,
		 unsigned w, unsigned h,
		 float *p,
		 unsigned dst_stride)
d1028 1
d1037 1
a1037 1
         pRow[3] = (float)(*src++ & 0xff);
d1043 1
d1070 88
d1165 51
d1222 1
a1222 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d1226 1
a1226 7
   case PIPE_FORMAT_S8_USCALED:
      s8_get_tile_rgba((unsigned char *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_X24S8_USCALED:
      s8x24_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
a1229 3
   case PIPE_FORMAT_S8X24_USCALED:
      x24s8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
d1233 6
d1249 1
a1249 2
pipe_get_tile_rgba(struct pipe_context *pipe,
                   struct pipe_transfer *pt,
d1255 1
a1255 1
   enum pipe_format format = pt->resource->format;
d1257 1
a1257 1
   if (u_clip_tile(x, y, &w, &h, &pt->box))
d1268 1
a1268 41
   pipe_get_tile_raw(pipe, pt, x, y, w, h, packed, 0);

   pipe_tile_raw_to_rgba(format, packed, w, h, p, dst_stride);

   FREE(packed);
}


void
pipe_get_tile_swizzle(struct pipe_context *pipe,
		      struct pipe_transfer *pt,
                      uint x,
                      uint y,
                      uint w,
                      uint h,
                      uint swizzle_r,
                      uint swizzle_g,
                      uint swizzle_b,
                      uint swizzle_a,
                      enum pipe_format format,
                      float *p)
{
   unsigned dst_stride = w * 4;
   void *packed;
   uint iy;
   float rgba01[6];

   if (u_clip_tile(x, y, &w, &h, &pt->box)) {
      return;
   }

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));
   if (!packed) {
      return;
   }

   if (format == PIPE_FORMAT_UYVY || format == PIPE_FORMAT_YUYV) {
      assert((x & 1) == 0);
   }

   pipe_get_tile_raw(pipe, pt, x, y, w, h, packed, 0);
a1272 29

   if (swizzle_r == PIPE_SWIZZLE_RED &&
       swizzle_g == PIPE_SWIZZLE_GREEN &&
       swizzle_b == PIPE_SWIZZLE_BLUE &&
       swizzle_a == PIPE_SWIZZLE_ALPHA) {
      /* no-op, skip */
      return;
   }

   rgba01[PIPE_SWIZZLE_ZERO] = 0.0f;
   rgba01[PIPE_SWIZZLE_ONE] = 1.0f;

   for (iy = 0; iy < h; iy++) {
      float *row = p;
      uint ix;

      for (ix = 0; ix < w; ix++) {
         rgba01[PIPE_SWIZZLE_RED] = row[0];
         rgba01[PIPE_SWIZZLE_GREEN] = row[1];
         rgba01[PIPE_SWIZZLE_BLUE] = row[2];
         rgba01[PIPE_SWIZZLE_ALPHA] = row[3];

         *row++ = rgba01[swizzle_r];
         *row++ = rgba01[swizzle_g];
         *row++ = rgba01[swizzle_b];
         *row++ = rgba01[swizzle_a];
      }
      p += dst_stride;
   }
d1277 1
a1277 2
pipe_put_tile_rgba(struct pipe_context *pipe,
                   struct pipe_transfer *pt,
d1283 1
a1283 1
   enum pipe_format format = pt->resource->format;
d1285 1
a1285 1
   if (u_clip_tile(x, y, &w, &h, &pt->box))
d1294 51
d1351 1
a1351 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d1355 1
a1355 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d1366 1
a1366 1
   pipe_put_tile_raw(pipe, pt, x, y, w, h, packed, 0);
d1376 1
a1376 2
pipe_get_tile_z(struct pipe_context *pipe,
                struct pipe_transfer *pt,
d1380 1
d1385 1
a1385 1
   enum pipe_format format = pt->resource->format;
d1387 1
a1387 1
   if (u_clip_tile(x, y, &w, &h, &pt->box))
d1390 1
a1390 1
   map = (ubyte *)pipe->transfer_map(pipe, pt);
d1408 1
a1408 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d1423 1
a1423 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d1456 1
a1456 1
   pipe->transfer_unmap(pipe, pt);
d1461 1
a1461 2
pipe_put_tile_z(struct pipe_context *pipe,
                struct pipe_transfer *pt,
d1465 1
d1470 1
a1470 1
   enum pipe_format format = pt->resource->format;
d1472 1
a1472 1
   if (u_clip_tile(x, y, &w, &h, &pt->box))
d1475 1
a1475 1
   map = (ubyte *)pipe->transfer_map(pipe, pt);
d1492 1
a1492 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d1495 1
a1495 1
         /*assert((pt->usage & PIPE_TRANSFER_READ_WRITE) == PIPE_TRANSFER_READ_WRITE);*/
d1519 1
a1519 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d1522 1
a1522 1
         /*assert((pt->usage & PIPE_TRANSFER_READ_WRITE) == PIPE_TRANSFER_READ_WRITE);*/
d1563 1
a1563 1
   pipe->transfer_unmap(pipe, pt);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d48 2
a49 2
pipe_get_tile_raw(struct pipe_transfer *pt,
                  const void *src,
d53 2
d61 5
d67 2
d76 2
a77 2
pipe_put_tile_raw(struct pipe_transfer *pt,
                  void *dst,
d81 1
d90 5
d96 2
d167 1
a167 1
/*** PIPE_FORMAT_Z24_UNORM_S8_UINT ***/
d194 1
a194 1
/*** PIPE_FORMAT_S8_UINT_Z24_UNORM ***/
d220 1
a220 1
/*** PIPE_FORMAT_S8X24_UINT ***/
d247 1
a247 1
/*** PIPE_FORMAT_X24S8_UINT ***/
a320 51
/*** PIPE_FORMAT_Z32_FLOAT_S8X24_UINT ***/

/**
 * Return each Z value as four floats in [0,1].
 */
static void
z32f_x24s8_get_tile_rgba(const float *src,
                         unsigned w, unsigned h,
                         float *p,
                         unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = *src;
         src += 2;
      }
      p += dst_stride;
   }
}

/*** PIPE_FORMAT_X32_S8X24_UINT ***/

/**
 * Return S component as four uint32_t in [0..255].  Z part ignored.
 */
static void
x32_s8_get_tile_rgba(const unsigned *src,
                     unsigned w, unsigned h,
                     float *p,
                     unsigned dst_stride)
{
   unsigned i, j;

   for (i = 0; i < h; i++) {
      float *pRow = p;
      for (j = 0; j < w; j++, pRow += 4) {
         src++;
         pRow[0] =
         pRow[1] =
         pRow[2] =
         pRow[3] = (float)(*src++ & 0xff);
      }
      p += dst_stride;
   }
}
d324 1
a324 1
                      const void *src,
d335 1
a335 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d339 1
a339 1
   case PIPE_FORMAT_S8_UINT:
d342 1
a342 1
   case PIPE_FORMAT_X24S8_UINT:
d345 1
a345 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d349 1
a349 1
   case PIPE_FORMAT_S8X24_UINT:
a354 6
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      z32f_x24s8_get_tile_rgba((float *) src, w, h, dst, dst_stride);
      break;
   case PIPE_FORMAT_X32_S8X24_UINT:
      x32_s8_get_tile_rgba((unsigned *) src, w, h, dst, dst_stride);
      break;
a362 23
void
pipe_tile_raw_to_unsigned(enum pipe_format format,
                          const void *src,
                          uint w, uint h,
                          unsigned *dst, unsigned dst_stride)
{
  util_format_read_4ui(format,
                       dst, dst_stride * sizeof(float),
                       src, util_format_get_stride(format, w),
                       0, 0, w, h);
}

void
pipe_tile_raw_to_signed(enum pipe_format format,
                          void *src,
                          uint w, uint h,
                          int *dst, unsigned dst_stride)
{
  util_format_read_4i(format,
                      dst, dst_stride * sizeof(float),
                      src, util_format_get_stride(format, w),
                      0, 0, w, h);
}
d365 2
a366 2
pipe_get_tile_rgba(struct pipe_transfer *pt,
                   const void *src,
d370 20
a389 1
   pipe_get_tile_rgba_format(pt, src, x, y, w, h, pt->resource->format, p);
d394 12
a405 5
pipe_get_tile_rgba_format(struct pipe_transfer *pt,
                          const void *src,
                          uint x, uint y, uint w, uint h,
                          enum pipe_format format,
                          float *p)
d409 2
d425 1
a425 1
   pipe_get_tile_raw(pt, src, x, y, w, h, packed, 0);
d430 29
d463 2
a464 2
pipe_put_tile_rgba(struct pipe_transfer *pt,
                   void *dst,
a467 11
   pipe_put_tile_rgba_format(pt, dst, x, y, w, h, pt->resource->format, p);
}


void
pipe_put_tile_rgba_format(struct pipe_transfer *pt,
                          void *dst,
                          uint x, uint y, uint w, uint h,
                          enum pipe_format format,
                          const float *p)
{
d470 1
d487 1
a487 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d491 1
a491 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
a494 6
   case PIPE_FORMAT_Z32_FLOAT:
      /*z32f_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);*/
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      /*z32f_s8x24_put_tile_rgba((unsigned *) packed, w, h, p, src_stride);*/
      break;
d502 1
a502 1
   pipe_put_tile_raw(pt, dst, x, y, w, h, packed, 0);
a506 55
void
pipe_put_tile_i_format(struct pipe_transfer *pt,
                       void *dst,
                       uint x, uint y, uint w, uint h,
                       enum pipe_format format,
                       const int *p)
{
   unsigned src_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));

   if (!packed)
      return;

   util_format_write_4i(format,
                        p, src_stride * sizeof(float),
                        packed, util_format_get_stride(format, w),
                        0, 0, w, h);

   pipe_put_tile_raw(pt, dst, x, y, w, h, packed, 0);

   FREE(packed);
}

void
pipe_put_tile_ui_format(struct pipe_transfer *pt,
                        void *dst,
                        uint x, uint y, uint w, uint h,
                        enum pipe_format format,
                        const unsigned int *p)
{
   unsigned src_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box))
      return;

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));

   if (!packed)
      return;

   util_format_write_4ui(format,
                         p, src_stride * sizeof(float),
                         packed, util_format_get_stride(format, w),
                         0, 0, w, h);

   pipe_put_tile_raw(pt, dst, x, y, w, h, packed, 0);

   FREE(packed);
}
d512 2
a513 2
pipe_get_tile_z(struct pipe_transfer *pt,
                const void *src,
d518 1
a518 1
   const ubyte *map = src;
d526 6
d544 1
a544 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d559 1
a559 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
a587 44
   case PIPE_FORMAT_Z32_FLOAT:
      {
         const float *ptrc = (const float *)(map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert float Z to 32-bit Z */
               if (ptrc[j] <= 0.0) {
                  pDest[j] = 0;
               }
               else if (ptrc[j] >= 1.0) {
                  pDest[j] = 0xffffffff;
               }
               else {
                  double z = ptrc[j] * 0xffffffff;
                  pDest[j] = (uint) z;
               }
            }
            pDest += dstStride;
            ptrc += pt->stride/4;
         }
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      {
         const float *ptrc = (const float *)(map + y * pt->stride + x*8);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert float Z to 32-bit Z */
               if (ptrc[j] <= 0.0) {
                  pDest[j*2] = 0;
               }
               else if (ptrc[j] >= 1.0) {
                  pDest[j*2] = 0xffffffff;
               }
               else {
                  double z = ptrc[j] * 0xffffffff;
                  pDest[j*2] = (uint) z;
               }
            }
            pDest += dstStride;
            ptrc += pt->stride/4;
         }
      }
      break;
d591 2
d597 2
a598 2
pipe_put_tile_z(struct pipe_transfer *pt,
                void *dst,
d604 1
a604 1
   ubyte *map = dst;
d611 6
d628 1
a628 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d655 1
a655 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
a694 28
   case PIPE_FORMAT_Z32_FLOAT:
      {
         float *pDest = (float *) (map + y * pt->stride + x*4);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit integer Z to float Z */
               const double scale = 1.0 / 0xffffffffU;
               pDest[j] = (float) (ptrc[j] * scale);
            }
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      {
         float *pDest = (float *) (map + y * pt->stride + x*8);
         for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {
               /* convert 32-bit integer Z to float Z */
               const double scale = 1.0 / 0xffffffffU;
               pDest[j*2] = (float) (ptrc[j] * scale);
            }
            pDest += pt->stride/4;
            ptrc += srcStride;
         }
      }
      break;
a697 1
}
d699 1
a699 29

void
pipe_get_tile_ui_format(struct pipe_transfer *pt,
                        const void *src,
                        uint x, uint y, uint w, uint h,
                        enum pipe_format format,
                        unsigned int *p)
{
   unsigned dst_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box)) {
      return;
   }

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));
   if (!packed) {
      return;
   }

   if (format == PIPE_FORMAT_UYVY || format == PIPE_FORMAT_YUYV) {
      assert((x & 1) == 0);
   }

   pipe_get_tile_raw(pt, src, x, y, w, h, packed, 0);

   pipe_tile_raw_to_unsigned(format, packed, w, h, p, dst_stride);

   FREE(packed);
a702 29
void
pipe_get_tile_i_format(struct pipe_transfer *pt,
                       const void *src,
                       uint x, uint y, uint w, uint h,
                       enum pipe_format format,
                       int *p)
{
   unsigned dst_stride = w * 4;
   void *packed;

   if (u_clip_tile(x, y, &w, &h, &pt->box)) {
      return;
   }

   packed = MALLOC(util_format_get_nblocks(format, w, h) * util_format_get_blocksize(format));
   if (!packed) {
      return;
   }

   if (format == PIPE_FORMAT_UYVY || format == PIPE_FORMAT_YUYV) {
      assert((x & 1) == 0);
   }

   pipe_get_tile_raw(pt, src, x, y, w, h, packed, 0);

   pipe_tile_raw_to_signed(format, packed, w, h, p, dst_stride);

   FREE(packed);
}
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d40 1
a40 1
#include "util/u_surface.h"
@


