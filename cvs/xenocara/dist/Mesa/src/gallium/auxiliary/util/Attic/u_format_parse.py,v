head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.7
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.49;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.48;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.47;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.42;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.49;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@#!/usr/bin/env python

'''
/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/
'''


VOID, UNSIGNED, SIGNED, FIXED, FLOAT = range(5)

SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W, SWIZZLE_0, SWIZZLE_1, SWIZZLE_NONE, = range(7)

PLAIN = 'plain'

RGB = 'rgb'
SRGB = 'srgb'
YUV = 'yuv'
ZS = 'zs'


def is_pot(x):
   return (x & (x - 1)) == 0


VERY_LARGE = 99999999999999999999999


class Channel:
    '''Describe the channel of a color channel.'''
    
    def __init__(self, type, norm, pure, size, name = ''):
        self.type = type
        self.norm = norm
        self.pure = pure
        self.size = size
        self.sign = type in (SIGNED, FIXED, FLOAT)
        self.name = name

    def __str__(self):
        s = str(self.type)
        if self.norm:
            s += 'n'
        if self.pure:
            s += 'p'
        s += str(self.size)
        return s

    def __eq__(self, other):
        return self.type == other.type and self.norm == other.norm and self.pure == other.pure and self.size == other.size

    def max(self):
        '''Maximum representable number.'''
        if self.type == FLOAT:
            return VERY_LARGE
        if self.type == FIXED:
            return (1 << (self.size/2)) - 1
        if self.norm:
            return 1
        if self.type == UNSIGNED:
            return (1 << self.size) - 1
        if self.type == SIGNED:
            return (1 << (self.size - 1)) - 1
        assert False
    
    def min(self):
        '''Minimum representable number.'''
        if self.type == FLOAT:
            return -VERY_LARGE
        if self.type == FIXED:
            return -(1 << (self.size/2))
        if self.type == UNSIGNED:
            return 0
        if self.norm:
            return -1
        if self.type == SIGNED:
            return -(1 << (self.size - 1))
        assert False


class Format:
    '''Describe a pixel format.'''

    def __init__(self, name, layout, block_width, block_height, le_channels, le_swizzles, be_channels, be_swizzles, colorspace):
        self.name = name
        self.layout = layout
        self.block_width = block_width
        self.block_height = block_height
        self.le_channels = le_channels
        self.le_swizzles = le_swizzles
        self.be_channels = be_channels
        self.be_swizzles = be_swizzles
        self.name = name
        self.colorspace = colorspace

    def __str__(self):
        return self.name

    def short_name(self):
        '''Make up a short norm for a format, suitable to be used as suffix in
        function names.'''

        name = self.name
        if name.startswith('PIPE_FORMAT_'):
            name = name[len('PIPE_FORMAT_'):]
        name = name.lower()
        return name

    def block_size(self):
        size = 0
        for channel in self.le_channels:
            size += channel.size
        return size

    def nr_channels(self):
        nr_channels = 0
        for channel in self.le_channels:
            if channel.size:
                nr_channels += 1
        return nr_channels

    def array_element(self):
        if self.layout != PLAIN:
            return None
        ref_channel = self.le_channels[0]
        if ref_channel.type == VOID:
           ref_channel = self.le_channels[1]
        for channel in self.le_channels:
            if channel.size and (channel.size != ref_channel.size or channel.size % 8):
                return None
            if channel.type != VOID:
                if channel.type != ref_channel.type:
                    return None
                if channel.norm != ref_channel.norm:
                    return None
                if channel.pure != ref_channel.pure:
                    return None
        return ref_channel

    def is_array(self):
        return self.array_element() != None

    def is_mixed(self):
        if self.layout != PLAIN:
            return False
        ref_channel = self.le_channels[0]
        if ref_channel.type == VOID:
           ref_channel = self.le_channels[1]
        for channel in self.le_channels[1:]:
            if channel.type != VOID:
                if channel.type != ref_channel.type:
                    return True
                if channel.norm != ref_channel.norm:
                    return True
                if channel.pure != ref_channel.pure:
                    return True
        return False

    def is_pot(self):
        return is_pot(self.block_size())

    def is_int(self):
        if self.layout != PLAIN:
            return False
        for channel in self.le_channels:
            if channel.type not in (VOID, UNSIGNED, SIGNED):
                return False
        return True

    def is_float(self):
        if self.layout != PLAIN:
            return False
        for channel in self.le_channels:
            if channel.type not in (VOID, FLOAT):
                return False
        return True

    def is_bitmask(self):
        if self.layout != PLAIN:
            return False
        if self.block_size() not in (8, 16, 32):
            return False
        for channel in self.le_channels:
            if channel.type not in (VOID, UNSIGNED, SIGNED):
                return False
        return True

    def is_pure_color(self):
        if self.layout != PLAIN or self.colorspace == ZS:
            return False
        pures = [channel.pure
                 for channel in self.le_channels
                 if channel.type != VOID]
        for x in pures:
           assert x == pures[0]
        return pures[0]

    def channel_type(self):
        types = [channel.type
                 for channel in self.le_channels
                 if channel.type != VOID]
        for x in types:
           assert x == types[0]
        return types[0]

    def is_pure_signed(self):
        return self.is_pure_color() and self.channel_type() == SIGNED

    def is_pure_unsigned(self):
        return self.is_pure_color() and self.channel_type() == UNSIGNED

    def has_channel(self, id):
        return self.le_swizzles[id] != SWIZZLE_NONE

    def has_depth(self):
        return self.colorspace == ZS and self.has_channel(0)

    def has_stencil(self):
        return self.colorspace == ZS and self.has_channel(1)

    def stride(self):
        return self.block_size()/8


_type_parse_map = {
    '':  VOID,
    'x': VOID,
    'u': UNSIGNED,
    's': SIGNED,
    'h': FIXED,
    'f': FLOAT,
}

_swizzle_parse_map = {
    'x': SWIZZLE_X,
    'y': SWIZZLE_Y,
    'z': SWIZZLE_Z,
    'w': SWIZZLE_W,
    '0': SWIZZLE_0,
    '1': SWIZZLE_1,
    '_': SWIZZLE_NONE,
}

def _parse_channels(fields, layout, colorspace, swizzles):
    if layout == PLAIN:
        names = ['']*4
        if colorspace in (RGB, SRGB):
            for i in range(4):
                swizzle = swizzles[i]
                if swizzle < 4:
                    names[swizzle] += 'rgba'[i]
        elif colorspace == ZS:
            for i in range(4):
                swizzle = swizzles[i]
                if swizzle < 4:
                    names[swizzle] += 'zs'[i]
        else:
            assert False
        for i in range(4):
            if names[i] == '':
                names[i] = 'x'
    else:
        names = ['x', 'y', 'z', 'w']

    channels = []
    for i in range(0, 4):
        field = fields[i]
        if field:
            type = _type_parse_map[field[0]]
            if field[1] == 'n':
                norm = True
                pure = False
                size = int(field[2:])
            elif field[1] == 'p':
                pure = True
                norm = False
                size = int(field[2:])
            else:
                norm = False
                pure = False
                size = int(field[1:])
        else:
            type = VOID
            norm = False
            pure = False
            size = 0
        channel = Channel(type, norm, pure, size, names[i])
        channels.append(channel)

    return channels

def parse(filename):
    '''Parse the format descrition in CSV format in terms of the 
    Channel and Format classes above.'''

    stream = open(filename)
    formats = []
    for line in stream:
        try:
            comment = line.index('#')
        except ValueError:
            pass
        else:
            line = line[:comment]
        line = line.strip()
        if not line:
            continue

        fields = [field.strip() for field in line.split(',')]
        
        name = fields[0]
        layout = fields[1]
        block_width, block_height = map(int, fields[2:4])
        colorspace = fields[9]

        le_swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[8]]
        le_channels = _parse_channels(fields[4:8], layout, colorspace, le_swizzles)

        be_swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[8]]
        be_channels = _parse_channels(fields[4:8], layout, colorspace, be_swizzles)

        le_shift = 0
        for channel in le_channels:
            channel.shift = le_shift
            le_shift += channel.size

        be_shift = 0
        for channel in be_channels[3::-1]:
            channel.shift = be_shift
            be_shift += channel.size

        assert le_shift == be_shift

        format = Format(name, layout, block_width, block_height, le_channels, le_swizzles, be_channels, be_swizzles, colorspace)
        formats.append(format)
    return formats

@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a332 3
        if len (fields) == 10:
           fields += fields[4:9]
        assert len (fields) == 15
d342 2
a343 2
        be_swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[14]]
        be_channels = _parse_channels(fields[10:14], layout, colorspace, be_swizzles)
a355 2
        for i in range(4):
            assert (le_swizzles[i] != SWIZZLE_NONE) == (be_swizzles[i] != SWIZZLE_NONE)
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d333 3
d345 2
a346 2
        be_swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[8]]
        be_channels = _parse_channels(fields[4:8], layout, colorspace, be_swizzles)
d359 2
@


1.3
log
@Merge Mesa 9.2.0
@
text
@a32 2
import sys

a44 3
# Not cross-compiler friendly
is_big_endian = sys.byteorder == 'big'

d107 1
a107 1
    def __init__(self, name, layout, block_width, block_height, channels, swizzles, colorspace):
d112 4
a115 2
        self.channels = channels
        self.swizzles = swizzles
d134 1
a134 1
        for channel in self.channels:
d140 1
a140 1
        for channel in self.channels:
d145 1
a145 1
    def is_array(self):
d147 2
a148 2
            return False
        ref_channel = self.channels[0]
d150 2
a151 2
           ref_channel = self.channels[1]
        for channel in self.channels:
d153 1
a153 1
                return False
d156 1
a156 1
                    return False
d158 1
a158 1
                    return False
d160 5
a164 2
                    return False
        return True
d169 1
a169 1
        ref_channel = self.channels[0]
d171 2
a172 2
           ref_channel = self.channels[1]
        for channel in self.channels[1:]:
d188 1
a188 1
        for channel in self.channels:
d196 1
a196 1
        for channel in self.channels:
d206 1
a206 1
        for channel in self.channels:
d211 32
a242 9
    def inv_swizzles(self):
        '''Return an array[4] of inverse swizzle terms'''
        '''Only pick the first matching value to avoid l8 getting blue and i8 getting alpha'''
        inv_swizzle = [None]*4
        for i in range(4):
            swizzle = self.swizzles[i]
            if swizzle < 4 and inv_swizzle[swizzle] == None:
                inv_swizzle[swizzle] = i
        return inv_swizzle
d267 48
d337 7
d345 9
a353 22
        swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[8]]
        colorspace = fields[9]
        
        if layout == PLAIN:
            names = ['']*4
            if colorspace in (RGB, SRGB):
                for i in range(4):
                    swizzle = swizzles[i]
                    if swizzle < 4:
                        names[swizzle] += 'rgba'[i]
            elif colorspace == ZS:
                for i in range(4):
                    swizzle = swizzles[i]
                    if swizzle < 4:
                        names[swizzle] += 'zs'[i]
            else:
                assert False
            for i in range(4):
                if names[i] == '':
                    names[i] = 'x'
        else:
            names = ['x', 'y', 'z', 'w']
d355 1
a355 29
        channels = []
        for i in range(0, 4):
            field = fields[4 + i]
            if field:
                type = _type_parse_map[field[0]]
                if field[1] == 'n':
                    norm = True
                    pure = False
                    size = int(field[2:])
                elif field[1] == 'p':
                    pure = True
                    norm = False
                    size = int(field[2:])
                else:
                    norm = False
                    pure = False
                    size = int(field[1:])
            else:
                type = VOID
                norm = False
                pure = False
                size = 0
            channel = Channel(type, norm, pure, size, names[i])
            channels.append(channel)

        shift = 0
        for channel in channels[3::-1] if is_big_endian else channels:
            channel.shift = shift
            shift += channel.size
d357 1
a357 1
        format = Format(name, layout, block_width, block_height, channels, swizzles, colorspace)
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d33 2
d47 3
d60 1
a60 1
    def __init__(self, type, norm, size, name = ''):
d63 1
d72 2
d78 1
a78 1
        return self.type == other.type and self.norm == other.norm and self.size == other.size
d152 3
a154 1
        for channel in self.channels[1:]:
d157 7
d178 2
d213 1
d217 1
a217 1
            if swizzle < 4:
d297 5
d305 1
d310 1
d312 1
a312 1
            channel = Channel(type, norm, size, names[i])
d314 5
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d46 1
a46 1
   return (x & (x - 1)) == 0;
d76 2
d83 1
a83 1
            return self.size - 1
d90 2
d141 2
d150 2
d153 2
d167 2
d175 2
d183 1
a183 1
        if self.block_size() > 32:
d185 1
a185 1
        if not self.is_pot():
a187 2
            if not is_pot(channel.size):
                return True
a188 2
                return False
            if channel.size >= 32:
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d46 1
a46 1
   return (x & (x - 1)) == 0
a75 2
        if self.type == FIXED:
            return (1 << (self.size/2)) - 1
d81 1
a81 1
            return (1 << (self.size - 1)) - 1
a87 2
        if self.type == FIXED:
            return -(1 << (self.size/2))
a136 2
        if self.layout != PLAIN:
            return False
a143 2
        if self.layout != PLAIN:
            return False
a144 2
        if ref_channel.type == VOID:
           ref_channel = self.channels[1]
a156 2
        if self.layout != PLAIN:
            return False
a162 2
        if self.layout != PLAIN:
            return False
d169 1
a169 1
        if self.layout != PLAIN:
d171 1
a171 1
        if self.block_size() not in (8, 16, 32):
d174 2
d177 2
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a32 2
import sys

a44 3
# Not cross-compiler friendly
is_big_endian = sys.byteorder == 'big'

d55 1
a55 1
    def __init__(self, type, norm, pure, size, name = ''):
a57 1
        self.pure = pure
a65 2
        if self.pure:
            s += 'p'
d70 1
a70 1
        return self.type == other.type and self.norm == other.norm and self.pure == other.pure and self.size == other.size
d144 1
a144 3
        if ref_channel.type == VOID:
           ref_channel = self.channels[1]
        for channel in self.channels:
a146 7
            if channel.type != VOID:
                if channel.type != ref_channel.type:
                    return False
                if channel.norm != ref_channel.norm:
                    return False
                if channel.pure != ref_channel.pure:
                    return False
a160 2
                if channel.pure != ref_channel.pure:
                    return True
a193 1
        '''Only pick the first matching value to avoid l8 getting blue and i8 getting alpha'''
d197 1
a197 1
            if swizzle < 4 and inv_swizzle[swizzle] == None:
a276 5
                    pure = False
                    size = int(field[2:])
                elif field[1] == 'p':
                    pure = True
                    norm = False
a279 1
                    pure = False
a283 1
                pure = False
d285 1
a285 1
            channel = Channel(type, norm, pure, size, names[i])
a286 5

        shift = 0
        for channel in channels[3::-1] if is_big_endian else channels:
            channel.shift = shift
            shift += channel.size
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d33 2
d47 3
d112 1
a112 1
    def __init__(self, name, layout, block_width, block_height, le_channels, le_swizzles, be_channels, be_swizzles, colorspace):
d117 2
a118 4
        self.le_channels = le_channels
        self.le_swizzles = le_swizzles
        self.be_channels = be_channels
        self.be_swizzles = be_swizzles
d137 1
a137 1
        for channel in self.le_channels:
d143 1
a143 1
        for channel in self.le_channels:
d148 1
a148 1
    def array_element(self):
d150 2
a151 2
            return None
        ref_channel = self.le_channels[0]
d153 2
a154 2
           ref_channel = self.le_channels[1]
        for channel in self.le_channels:
d156 1
a156 1
                return None
d159 1
a159 1
                    return None
d161 1
a161 1
                    return None
d163 2
a164 5
                    return None
        return ref_channel

    def is_array(self):
        return self.array_element() != None
d169 1
a169 1
        ref_channel = self.le_channels[0]
d171 2
a172 2
           ref_channel = self.le_channels[1]
        for channel in self.le_channels[1:]:
d188 1
a188 1
        for channel in self.le_channels:
d196 1
a196 1
        for channel in self.le_channels:
d206 1
a206 1
        for channel in self.le_channels:
d211 9
a219 32
    def is_pure_color(self):
        if self.layout != PLAIN or self.colorspace == ZS:
            return False
        pures = [channel.pure
                 for channel in self.le_channels
                 if channel.type != VOID]
        for x in pures:
           assert x == pures[0]
        return pures[0]

    def channel_type(self):
        types = [channel.type
                 for channel in self.le_channels
                 if channel.type != VOID]
        for x in types:
           assert x == types[0]
        return types[0]

    def is_pure_signed(self):
        return self.is_pure_color() and self.channel_type() == SIGNED

    def is_pure_unsigned(self):
        return self.is_pure_color() and self.channel_type() == UNSIGNED

    def has_channel(self, id):
        return self.le_swizzles[id] != SWIZZLE_NONE

    def has_depth(self):
        return self.colorspace == ZS and self.has_channel(0)

    def has_stencil(self):
        return self.colorspace == ZS and self.has_channel(1)
a243 48
def _parse_channels(fields, layout, colorspace, swizzles):
    if layout == PLAIN:
        names = ['']*4
        if colorspace in (RGB, SRGB):
            for i in range(4):
                swizzle = swizzles[i]
                if swizzle < 4:
                    names[swizzle] += 'rgba'[i]
        elif colorspace == ZS:
            for i in range(4):
                swizzle = swizzles[i]
                if swizzle < 4:
                    names[swizzle] += 'zs'[i]
        else:
            assert False
        for i in range(4):
            if names[i] == '':
                names[i] = 'x'
    else:
        names = ['x', 'y', 'z', 'w']

    channels = []
    for i in range(0, 4):
        field = fields[i]
        if field:
            type = _type_parse_map[field[0]]
            if field[1] == 'n':
                norm = True
                pure = False
                size = int(field[2:])
            elif field[1] == 'p':
                pure = True
                norm = False
                size = int(field[2:])
            else:
                norm = False
                pure = False
                size = int(field[1:])
        else:
            type = VOID
            norm = False
            pure = False
            size = 0
        channel = Channel(type, norm, pure, size, names[i])
        channels.append(channel)

    return channels

d266 2
d269 20
d290 29
a318 17
        le_swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[8]]
        le_channels = _parse_channels(fields[4:8], layout, colorspace, le_swizzles)

        be_swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[8]]
        be_channels = _parse_channels(fields[4:8], layout, colorspace, be_swizzles)

        le_shift = 0
        for channel in le_channels:
            channel.shift = le_shift
            le_shift += channel.size

        be_shift = 0
        for channel in be_channels[3::-1]:
            channel.shift = be_shift
            be_shift += channel.size

        assert le_shift == be_shift
d320 1
a320 1
        format = Format(name, layout, block_width, block_height, le_channels, le_swizzles, be_channels, be_swizzles, colorspace)
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a332 3
        if len (fields) == 10:
           fields += fields[4:9]
        assert len (fields) == 15
d342 2
a343 2
        be_swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[14]]
        be_channels = _parse_channels(fields[10:14], layout, colorspace, be_swizzles)
a355 2
        for i in range(4):
            assert (le_swizzles[i] != SWIZZLE_NONE) == (be_swizzles[i] != SWIZZLE_NONE)
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d333 3
d345 2
a346 2
        be_swizzles = [_swizzle_parse_map[swizzle] for swizzle in fields[8]]
        be_channels = _parse_channels(fields[4:8], layout, colorspace, be_swizzles)
d359 2
@


