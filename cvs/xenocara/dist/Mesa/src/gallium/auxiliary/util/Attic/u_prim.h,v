head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.09.07.15.20.06;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.51;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.53;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.48;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.01.22;	author jsg;	state Exp;
branches;
next	;
commitid	dm8VnQHhowGHmemJ;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#ifndef U_PRIM_H
#define U_PRIM_H


#include "pipe/p_defines.h"
#include "util/u_debug.h"

#ifdef __cplusplus
extern "C" {
#endif

struct u_prim_vertex_count {
   unsigned min;
   unsigned incr;
};

/**
 * Decompose a primitive that is a loop, a strip, or a fan.  Return the
 * original primitive if it is already decomposed.
 */
static INLINE unsigned
u_decomposed_prim(unsigned prim)
{
   switch (prim) {
   case PIPE_PRIM_LINE_LOOP:
   case PIPE_PRIM_LINE_STRIP:
      return PIPE_PRIM_LINES;
   case PIPE_PRIM_TRIANGLE_STRIP:
   case PIPE_PRIM_TRIANGLE_FAN:
      return PIPE_PRIM_TRIANGLES;
   case PIPE_PRIM_QUAD_STRIP:
      return PIPE_PRIM_QUADS;
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      return PIPE_PRIM_LINES_ADJACENCY;
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      return PIPE_PRIM_TRIANGLES_ADJACENCY;
   default:
      return prim;
   }
}

/**
 * Reduce a primitive to one of PIPE_PRIM_POINTS, PIPE_PRIM_LINES, and
 * PIPE_PRIM_TRIANGLES.
 */
static INLINE unsigned
u_reduced_prim(unsigned prim)
{
   switch (prim) {
   case PIPE_PRIM_POINTS:
      return PIPE_PRIM_POINTS;
   case PIPE_PRIM_LINES:
   case PIPE_PRIM_LINE_LOOP:
   case PIPE_PRIM_LINE_STRIP:
   case PIPE_PRIM_LINES_ADJACENCY:
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      return PIPE_PRIM_LINES;
   default:
      return PIPE_PRIM_TRIANGLES;
   }
}

/**
 * Re-assemble a primitive to remove its adjacency.
 */
static INLINE unsigned
u_assembled_prim(unsigned prim)
{
   switch (prim) {
   case PIPE_PRIM_LINES_ADJACENCY:
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      return PIPE_PRIM_LINES;
   case PIPE_PRIM_TRIANGLES_ADJACENCY:
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      return PIPE_PRIM_TRIANGLES;
   default:
      return prim;
   }
}

/**
 * Return the vertex count information for a primitive.
 *
 * Note that if this function is called directly or indirectly anywhere in a
 * source file, it will increase the size of the binary slightly more than
 * expected because of the use of a table.
 */
static INLINE const struct u_prim_vertex_count *
u_prim_vertex_count(unsigned prim)
{
   static const struct u_prim_vertex_count prim_table[PIPE_PRIM_MAX] = {
      { 1, 1 }, /* PIPE_PRIM_POINTS */
      { 2, 2 }, /* PIPE_PRIM_LINES */
      { 2, 1 }, /* PIPE_PRIM_LINE_LOOP */
      { 2, 1 }, /* PIPE_PRIM_LINE_STRIP */
      { 3, 3 }, /* PIPE_PRIM_TRIANGLES */
      { 3, 1 }, /* PIPE_PRIM_TRIANGLE_STRIP */
      { 3, 1 }, /* PIPE_PRIM_TRIANGLE_FAN */
      { 4, 4 }, /* PIPE_PRIM_QUADS */
      { 4, 2 }, /* PIPE_PRIM_QUAD_STRIP */
      { 3, 1 }, /* PIPE_PRIM_POLYGON */
      { 4, 4 }, /* PIPE_PRIM_LINES_ADJACENCY */
      { 4, 1 }, /* PIPE_PRIM_LINE_STRIP_ADJACENCY */
      { 6, 6 }, /* PIPE_PRIM_TRIANGLES_ADJACENCY */
      { 6, 2 }, /* PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY */
   };

   return (likely(prim < PIPE_PRIM_MAX)) ? &prim_table[prim] : NULL;
}

/**
 * Given a vertex count, return the number of primitives.
 * For polygons, return the number of triangles.
 */
static INLINE unsigned
u_prims_for_vertices(unsigned prim, unsigned num)
{
   const struct u_prim_vertex_count *info = u_prim_vertex_count(prim);

   if (num < info->min)
      return 0;

   return 1 + ((num - info->min) / info->incr);
}

static INLINE boolean u_validate_pipe_prim( unsigned pipe_prim, unsigned nr )
{
   const struct u_prim_vertex_count *count = u_prim_vertex_count(pipe_prim);

   return (count && nr >= count->min);
}


static INLINE boolean u_trim_pipe_prim( unsigned pipe_prim, unsigned *nr )
{
   const struct u_prim_vertex_count *count = u_prim_vertex_count(pipe_prim);

   if (count && *nr >= count->min) {
      if (count->incr > 1)
         *nr -= (*nr % count->incr);
      return TRUE;
   }
   else {
      *nr = 0;
      return FALSE;
   }
}

static INLINE unsigned
u_vertices_per_prim(int primitive)
{
   switch(primitive) {
   case PIPE_PRIM_POINTS:
      return 1;
   case PIPE_PRIM_LINES:
   case PIPE_PRIM_LINE_LOOP:
   case PIPE_PRIM_LINE_STRIP:
      return 2;
   case PIPE_PRIM_TRIANGLES:
   case PIPE_PRIM_TRIANGLE_STRIP:
   case PIPE_PRIM_TRIANGLE_FAN:
      return 3;
   case PIPE_PRIM_LINES_ADJACENCY:
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      return 4;
   case PIPE_PRIM_TRIANGLES_ADJACENCY:
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      return 6;

   /* following primitives should never be used
    * with geometry shaders abd their size is
    * undefined */
   case PIPE_PRIM_POLYGON:
   case PIPE_PRIM_QUADS:
   case PIPE_PRIM_QUAD_STRIP:
   default:
      debug_printf("Unrecognized geometry shader primitive");
      return 3;
   }
}

/**
 * Returns the number of decomposed primitives for the given
 * vertex count.
 * Parts of the pipline are invoked once for each triangle in
 * triangle strip, triangle fans and triangles and once
 * for each line in line strip, line loop, lines. Also 
 * statistics depend on knowing the exact number of decomposed
 * primitives for a set of vertices.
 */
static INLINE unsigned
u_decomposed_prims_for_vertices(int primitive, int vertices)
{
   switch (primitive) {
   case PIPE_PRIM_POINTS:
      return vertices;
   case PIPE_PRIM_LINES:
      return vertices / 2;
   case PIPE_PRIM_LINE_LOOP:
      return (vertices >= 2) ? vertices : 0;
   case PIPE_PRIM_LINE_STRIP:
      return (vertices >= 2) ? vertices - 1 : 0;
   case PIPE_PRIM_TRIANGLES:
      return vertices / 3;
   case PIPE_PRIM_TRIANGLE_STRIP:
      return (vertices >= 3) ? vertices - 2 : 0;
   case PIPE_PRIM_TRIANGLE_FAN:
      return (vertices >= 3) ? vertices - 2 : 0;
   case PIPE_PRIM_LINES_ADJACENCY:
      return vertices / 4;
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      return (vertices >= 4) ? vertices - 3 : 0;
   case PIPE_PRIM_TRIANGLES_ADJACENCY:
      return vertices / 6;
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      return (vertices >= 6) ? 1 + (vertices - 6) / 2 : 0;
   case PIPE_PRIM_QUADS:
      return vertices / 4;
   case PIPE_PRIM_QUAD_STRIP:
      return (vertices >= 4) ? (vertices - 2) / 2 : 0;
   /* Polygons can't be decomposed
    * because the number of their vertices isn't known so
    * for them and whatever else we don't recognize just
    * return 1 if the number of vertices is greater than
    * or equal to 3 and zero otherwise */
   case PIPE_PRIM_POLYGON:
   default:
      debug_printf("Invalid decomposition primitive!\n");
      return (vertices >= 3) ? 1 : 0;
   }
}

/**
 * Returns the number of reduced/tessellated primitives for the given vertex
 * count.  Each quad is treated as two triangles.  Polygons are treated as
 * triangle fans.
 */
static INLINE unsigned
u_reduced_prims_for_vertices(int primitive, int vertices)
{
   switch (primitive) {
   case PIPE_PRIM_QUADS:
   case PIPE_PRIM_QUAD_STRIP:
      return u_decomposed_prims_for_vertices(primitive, vertices) * 2;
   case PIPE_PRIM_POLYGON:
      primitive = PIPE_PRIM_TRIANGLE_FAN;
      /* fall through */
   default:
      return u_decomposed_prims_for_vertices(primitive, vertices);
   }
}

const char *u_prim_name( unsigned pipe_prim );

#endif
@


1.6
log
@Merge Mesa 10.2.7
@
text
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d139 15
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d29 2
a30 2
#ifndef U_BLIT_H
#define U_BLIT_H
d40 11
a50 1
static INLINE boolean u_validate_pipe_prim( unsigned pipe_prim, unsigned nr )
d52 2
a53 9
   boolean ok = TRUE;

   switch (pipe_prim) {
   case PIPE_PRIM_POINTS:
      ok = (nr >= 1);
      break;
   case PIPE_PRIM_LINES:
      ok = (nr >= 2);
      break;
d55 1
a55 6
   case PIPE_PRIM_LINE_LOOP:
      ok = (nr >= 2);
      break;
   case PIPE_PRIM_TRIANGLES:
      ok = (nr >= 3);
      break;
d58 1
a58 6
   case PIPE_PRIM_POLYGON:
      ok = (nr >= 3);
      break;
   case PIPE_PRIM_QUADS:
      ok = (nr >= 4);
      break;
d60 5
a64 2
      ok = (nr >= 4);
      break;
d66 1
a66 2
      ok = 0;
      break;
d68 1
d70 19
a88 1
   return ok;
d91 17
d109 9
a117 1
static INLINE boolean u_trim_pipe_prim( unsigned pipe_prim, unsigned *nr )
d119 2
a120 3
   boolean ok = TRUE;
   const static int values[][2] = {
      { 1, 0 }, /* PIPE_PRIM_POINTS */
d122 2
a123 2
      { 2, 0 }, /* PIPE_PRIM_LINE_LOOP */
      { 2, 0 }, /* PIPE_PRIM_LINE_STRIP */
d125 5
a129 5
      { 3, 0 }, /* PIPE_PRIM_TRIANGLE_STRIP */
      { 3, 0 }, /* PIPE_PRIM_TRIANGLE_FAN */
      { 4, 4 }, /* PIPE_PRIM_TRIANGLE_QUADS */
      { 4, 2 }, /* PIPE_PRIM_TRIANGLE_QUAD_STRIP */
      { 3, 0 }, /* PIPE_PRIM_TRIANGLE_POLYGON */
d131 3
a133 3
      { 4, 0 }, /* PIPE_PRIM_LINE_STRIP_ADJACENCY */
      { 6, 5 }, /* PIPE_PRIM_TRIANGLES_ADJACENCY */
      { 4, 0 }, /* PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY */
d136 2
a137 4
   if (unlikely(pipe_prim >= PIPE_PRIM_MAX)) {
       *nr = 0;
       return FALSE;
   }
d139 3
a141 3
   ok = (*nr >= values[pipe_prim][0]);
   if (values[pipe_prim][1])
       *nr -= (*nr % values[pipe_prim][1]);
d143 1
a143 4
   if (!ok)
      *nr = 0;

   return ok;
d147 1
a147 1
static INLINE unsigned u_reduced_prim( unsigned pipe_prim )
d149 1
a149 3
   switch (pipe_prim) {
   case PIPE_PRIM_POINTS:
      return PIPE_PRIM_POINTS;
d151 8
a158 7
   case PIPE_PRIM_LINES:
   case PIPE_PRIM_LINE_STRIP:
   case PIPE_PRIM_LINE_LOOP:
      return PIPE_PRIM_LINES;

   default:
      return PIPE_PRIM_TRIANGLES;
d198 1
a198 1
 * Geometry shader is invoked once for each triangle in
d200 3
a202 1
 * for each line in line strip, line loop, lines.
d205 1
a205 1
u_gs_prims_for_vertices(int primitive, int vertices)
d207 1
a207 1
   switch(primitive) {
d213 1
a213 1
      return vertices;
d215 1
a215 1
      return vertices - 1;
d217 1
a217 1
      return vertices /  3;
d219 1
a219 1
      return vertices - 2;
d221 1
a221 1
      return vertices - 2;
d223 1
a223 1
      return vertices / 2;
d225 1
a225 1
      return vertices - 1;
d227 1
a227 1
      return vertices / 3;
d229 16
a244 1
      return vertices - 2;
d246 9
a254 4
   /* following primitives should never be used
    * with geometry shaders abd their size is
    * undefined */
   case PIPE_PRIM_POLYGON:
d257 4
d262 1
a262 2
      debug_printf("Unrecognized geometry shader primitive");
      return 3;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d81 16
d98 3
a100 46
   switch (pipe_prim) {
   case PIPE_PRIM_POINTS:
      ok = (*nr >= 1);
      break;
   case PIPE_PRIM_LINES:
      ok = (*nr >= 2);
      *nr -= (*nr % 2);
      break;
   case PIPE_PRIM_LINE_STRIP:
   case PIPE_PRIM_LINE_LOOP:
      ok = (*nr >= 2);
      break;
   case PIPE_PRIM_TRIANGLES:
      ok = (*nr >= 3);
      *nr -= (*nr % 3);
      break;
   case PIPE_PRIM_TRIANGLE_STRIP:
   case PIPE_PRIM_TRIANGLE_FAN:
   case PIPE_PRIM_POLYGON:
      ok = (*nr >= 3);
      break;
   case PIPE_PRIM_QUADS:
      ok = (*nr >= 4);
      *nr -= (*nr % 4);
      break;
   case PIPE_PRIM_QUAD_STRIP:
      ok = (*nr >= 4);
      *nr -= (*nr % 2);
      break;
   case PIPE_PRIM_LINES_ADJACENCY:
      ok = (*nr >= 4);
      *nr -= (*nr % 4);
      break;
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      ok = (*nr >= 4);
      break;
   case PIPE_PRIM_TRIANGLES_ADJACENCY:
      ok = (*nr >= 6);
      *nr -= (*nr % 5);
      break;
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      ok = (*nr >= 4);
      break;
   default:
      ok = 0;
      break;
d102 4
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d111 14
d173 46
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a110 14
   case PIPE_PRIM_LINES_ADJACENCY:
      ok = (*nr >= 4);
      *nr -= (*nr % 4);
      break;
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      ok = (*nr >= 4);
      break;
   case PIPE_PRIM_TRIANGLES_ADJACENCY:
      ok = (*nr >= 6);
      *nr -= (*nr % 5);
      break;
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      ok = (*nr >= 4);
      break;
a158 46

   /* following primitives should never be used
    * with geometry shaders abd their size is
    * undefined */
   case PIPE_PRIM_POLYGON:
   case PIPE_PRIM_QUADS:
   case PIPE_PRIM_QUAD_STRIP:
   default:
      debug_printf("Unrecognized geometry shader primitive");
      return 3;
   }
}

/**
 * Returns the number of decomposed primitives for the given
 * vertex count.
 * Geometry shader is invoked once for each triangle in
 * triangle strip, triangle fans and triangles and once
 * for each line in line strip, line loop, lines.
 */
static INLINE unsigned
u_gs_prims_for_vertices(int primitive, int vertices)
{
   switch(primitive) {
   case PIPE_PRIM_POINTS:
      return vertices;
   case PIPE_PRIM_LINES:
      return vertices / 2;
   case PIPE_PRIM_LINE_LOOP:
      return vertices;
   case PIPE_PRIM_LINE_STRIP:
      return vertices - 1;
   case PIPE_PRIM_TRIANGLES:
      return vertices /  3;
   case PIPE_PRIM_TRIANGLE_STRIP:
      return vertices - 2;
   case PIPE_PRIM_TRIANGLE_FAN:
      return vertices - 2;
   case PIPE_PRIM_LINES_ADJACENCY:
      return vertices / 2;
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      return vertices - 1;
   case PIPE_PRIM_TRIANGLES_ADJACENCY:
      return vertices / 3;
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      return vertices - 2;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d29 2
a30 2
#ifndef U_PRIM_H
#define U_PRIM_H
d40 3
a42 4
struct u_prim_vertex_count {
   unsigned min;
   unsigned incr;
};
d44 8
a51 8
/**
 * Decompose a primitive that is a loop, a strip, or a fan.  Return the
 * original primitive if it is already decomposed.
 */
static INLINE unsigned
u_decomposed_prim(unsigned prim)
{
   switch (prim) {
d53 5
a57 2
   case PIPE_PRIM_LINE_STRIP:
      return PIPE_PRIM_LINES;
d60 6
a65 1
      return PIPE_PRIM_TRIANGLES;
d67 2
a68 5
      return PIPE_PRIM_QUADS;
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      return PIPE_PRIM_LINES_ADJACENCY;
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      return PIPE_PRIM_TRIANGLES_ADJACENCY;
d70 2
a71 1
      return prim;
d73 2
d77 2
a78 6
/**
 * Reduce a primitive to one of PIPE_PRIM_POINTS, PIPE_PRIM_LINES, and
 * PIPE_PRIM_TRIANGLES.
 */
static INLINE unsigned
u_reduced_prim(unsigned prim)
d80 3
a82 1
   switch (prim) {
d84 2
a85 1
      return PIPE_PRIM_POINTS;
d87 4
d92 19
a110 1
   case PIPE_PRIM_LINE_STRIP:
d112 3
d116 2
a117 16
      return PIPE_PRIM_LINES;
   default:
      return PIPE_PRIM_TRIANGLES;
   }
}

/**
 * Re-assemble a primitive to remove its adjacency.
 */
static INLINE unsigned
u_assembled_prim(unsigned prim)
{
   switch (prim) {
   case PIPE_PRIM_LINES_ADJACENCY:
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      return PIPE_PRIM_LINES;
d119 3
d123 2
a124 1
      return PIPE_PRIM_TRIANGLES;
d126 2
a127 1
      return prim;
a128 1
}
d130 2
a131 26
/**
 * Return the vertex count information for a primitive.
 *
 * Note that if this function is called directly or indirectly anywhere in a
 * source file, it will increase the size of the binary slightly more than
 * expected because of the use of a table.
 */
static INLINE const struct u_prim_vertex_count *
u_prim_vertex_count(unsigned prim)
{
   static const struct u_prim_vertex_count prim_table[PIPE_PRIM_MAX] = {
      { 1, 1 }, /* PIPE_PRIM_POINTS */
      { 2, 2 }, /* PIPE_PRIM_LINES */
      { 2, 1 }, /* PIPE_PRIM_LINE_LOOP */
      { 2, 1 }, /* PIPE_PRIM_LINE_STRIP */
      { 3, 3 }, /* PIPE_PRIM_TRIANGLES */
      { 3, 1 }, /* PIPE_PRIM_TRIANGLE_STRIP */
      { 3, 1 }, /* PIPE_PRIM_TRIANGLE_FAN */
      { 4, 4 }, /* PIPE_PRIM_QUADS */
      { 4, 2 }, /* PIPE_PRIM_QUAD_STRIP */
      { 3, 1 }, /* PIPE_PRIM_POLYGON */
      { 4, 4 }, /* PIPE_PRIM_LINES_ADJACENCY */
      { 4, 1 }, /* PIPE_PRIM_LINE_STRIP_ADJACENCY */
      { 6, 6 }, /* PIPE_PRIM_TRIANGLES_ADJACENCY */
      { 6, 2 }, /* PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY */
   };
d133 1
a133 1
   return (likely(prim < PIPE_PRIM_MAX)) ? &prim_table[prim] : NULL;
d136 2
a137 1
static INLINE boolean u_validate_pipe_prim( unsigned pipe_prim, unsigned nr )
d139 3
a141 1
   const struct u_prim_vertex_count *count = u_prim_vertex_count(pipe_prim);
d143 4
a146 2
   return (count && nr >= count->min);
}
d148 2
a149 13

static INLINE boolean u_trim_pipe_prim( unsigned pipe_prim, unsigned *nr )
{
   const struct u_prim_vertex_count *count = u_prim_vertex_count(pipe_prim);

   if (count && *nr >= count->min) {
      if (count->incr > 1)
         *nr -= (*nr % count->incr);
      return TRUE;
   }
   else {
      *nr = 0;
      return FALSE;
d189 1
a189 1
 * Parts of the pipline are invoked once for each triangle in
d191 1
a191 3
 * for each line in line strip, line loop, lines. Also 
 * statistics depend on knowing the exact number of decomposed
 * primitives for a set of vertices.
d194 1
a194 1
u_decomposed_prims_for_vertices(int primitive, int vertices)
d196 1
a196 1
   switch (primitive) {
d202 1
a202 1
      return (vertices >= 2) ? vertices : 0;
d204 1
a204 1
      return (vertices >= 2) ? vertices - 1 : 0;
d206 1
a206 1
      return vertices / 3;
d208 1
a208 1
      return (vertices >= 3) ? vertices - 2 : 0;
d210 1
a210 1
      return (vertices >= 3) ? vertices - 2 : 0;
d212 1
a212 1
      return vertices / 4;
d214 1
a214 1
      return (vertices >= 4) ? vertices - 3 : 0;
d216 1
a216 1
      return vertices / 6;
d218 5
a222 10
      return (vertices >= 6) ? 1 + (vertices - 6) / 2 : 0;
   case PIPE_PRIM_QUADS:
      return vertices / 4;
   case PIPE_PRIM_QUAD_STRIP:
      return (vertices >= 4) ? (vertices - 2) / 2 : 0;
   /* Polygons can't be decomposed
    * because the number of their vertices isn't known so
    * for them and whatever else we don't recognize just
    * return 1 if the number of vertices is greater than
    * or equal to 3 and zero otherwise */
a223 15
   default:
      debug_printf("Invalid decomposition primitive!\n");
      return (vertices >= 3) ? 1 : 0;
   }
}

/**
 * Returns the number of reduced/tessellated primitives for the given vertex
 * count.  Each quad is treated as two triangles.  Polygons are treated as
 * triangle fans.
 */
static INLINE unsigned
u_reduced_prims_for_vertices(int primitive, int vertices)
{
   switch (primitive) {
a225 4
      return u_decomposed_prims_for_vertices(primitive, vertices) * 2;
   case PIPE_PRIM_POLYGON:
      primitive = PIPE_PRIM_TRIANGLE_FAN;
      /* fall through */
d227 2
a228 1
      return u_decomposed_prims_for_vertices(primitive, vertices);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@a138 15
/**
 * Given a vertex count, return the number of primitives.
 * For polygons, return the number of triangles.
 */
static INLINE unsigned
u_prims_for_vertices(unsigned prim, unsigned num)
{
   const struct u_prim_vertex_count *info = u_prim_vertex_count(prim);

   if (num < info->min)
      return 0;

   return 1 + ((num - info->min) / info->incr);
}

@


