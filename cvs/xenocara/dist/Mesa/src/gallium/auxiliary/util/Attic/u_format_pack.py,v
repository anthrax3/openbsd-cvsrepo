head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.49;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.48;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.47;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.42;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.49;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@#!/usr/bin/env python

'''
/**************************************************************************
 *
 * Copyright 2009-2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * @@file
 * Pixel format packing and unpacking functions.
 *
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 */
'''


from u_format_parse import *


def inv_swizzles(swizzles):
    '''Return an array[4] of inverse swizzle terms'''
    '''Only pick the first matching value to avoid l8 getting blue and i8 getting alpha'''
    inv_swizzle = [None]*4
    for i in range(4):
        swizzle = swizzles[i]
        if swizzle < 4 and inv_swizzle[swizzle] == None:
            inv_swizzle[swizzle] = i
    return inv_swizzle

def print_channels(format, func):
    if format.nr_channels() <= 1:
        func(format.le_channels, format.le_swizzles)
    else:
        print '#ifdef PIPE_ARCH_BIG_ENDIAN'
        func(format.be_channels, format.be_swizzles)
        print '#else'
        func(format.le_channels, format.le_swizzles)
        print '#endif'

def generate_format_type(format):
    '''Generate a structure that describes the format.'''

    assert format.layout == PLAIN
    
    def generate_bitfields(channels, swizzles):
        for channel in channels:
            if channel.type == VOID:
                if channel.size:
                    print '      unsigned %s:%u;' % (channel.name, channel.size)
            elif channel.type == UNSIGNED:
                print '      unsigned %s:%u;' % (channel.name, channel.size)
            elif channel.type in (SIGNED, FIXED):
                print '      int %s:%u;' % (channel.name, channel.size)
            elif channel.type == FLOAT:
                if channel.size == 64:
                    print '      double %s;' % (channel.name)
                elif channel.size == 32:
                    print '      float %s;' % (channel.name)
                else:
                    print '      unsigned %s:%u;' % (channel.name, channel.size)
            else:
                assert 0

    def generate_full_fields(channels, swizzles):
        for channel in channels:
            assert channel.size % 8 == 0 and is_pot(channel.size)
            if channel.type == VOID:
                if channel.size:
                    print '      uint%u_t %s;' % (channel.size, channel.name)
            elif channel.type == UNSIGNED:
                print '      uint%u_t %s;' % (channel.size, channel.name)
            elif channel.type in (SIGNED, FIXED):
                print '      int%u_t %s;' % (channel.size, channel.name)
            elif channel.type == FLOAT:
                if channel.size == 64:
                    print '      double %s;' % (channel.name)
                elif channel.size == 32:
                    print '      float %s;' % (channel.name)
                elif channel.size == 16:
                    print '      uint16_t %s;' % (channel.name)
                else:
                    assert 0
            else:
                assert 0

    print 'union util_format_%s {' % format.short_name()
    
    if format.block_size() in (8, 16, 32, 64):
        print '   uint%u_t value;' % (format.block_size(),)

    use_bitfields = False
    for channel in format.le_channels:
        if channel.size % 8 or not is_pot(channel.size):
            use_bitfields = True

    print '   struct {'
    if use_bitfields:
        print_channels(format, generate_bitfields)
    else:
        print_channels(format, generate_full_fields)
    print '   } chan;'
    print '};'
    print


def is_format_supported(format):
    '''Determines whether we actually have the plumbing necessary to generate the 
    to read/write to/from this format.'''

    # FIXME: Ideally we would support any format combination here.

    if format.layout != PLAIN:
        return False

    for i in range(4):
        channel = format.le_channels[i]
        if channel.type not in (VOID, UNSIGNED, SIGNED, FLOAT, FIXED):
            return False
        if channel.type == FLOAT and channel.size not in (16, 32, 64):
            return False

    return True

def native_type(format):
    '''Get the native appropriate for a format.'''

    if format.name == 'PIPE_FORMAT_R11G11B10_FLOAT':
        return 'uint32_t'
    if format.name == 'PIPE_FORMAT_R9G9B9E5_FLOAT':
        return 'uint32_t'

    if format.layout == PLAIN:
        if not format.is_array():
            # For arithmetic pixel formats return the integer type that matches the whole pixel
            return 'uint%u_t' % format.block_size()
        else:
            # For array pixel formats return the integer type that matches the color channel
            channel = format.array_element()
            if channel.type in (UNSIGNED, VOID):
                return 'uint%u_t' % channel.size
            elif channel.type in (SIGNED, FIXED):
                return 'int%u_t' % channel.size
            elif channel.type == FLOAT:
                if channel.size == 16:
                    return 'uint16_t'
                elif channel.size == 32:
                    return 'float'
                elif channel.size == 64:
                    return 'double'
                else:
                    assert False
            else:
                assert False
    else:
        assert False


def intermediate_native_type(bits, sign):
    '''Find a native type adequate to hold intermediate results of the request bit size.'''

    bytes = 4 # don't use anything smaller than 32bits
    while bytes * 8 < bits:
        bytes *= 2
    bits = bytes*8

    if sign:
        return 'int%u_t' % bits
    else:
        return 'uint%u_t' % bits


def get_one_shift(type):
    '''Get the number of the bit that matches unity for this type.'''
    if type.type == 'FLOAT':
        assert False
    if not type.norm:
        return 0
    if type.type == UNSIGNED:
        return type.size
    if type.type == SIGNED:
        return type.size - 1
    if type.type == FIXED:
        return type.size / 2
    assert False


def value_to_native(type, value):
    '''Get the value of unity for this type.'''
    if type.type == FLOAT:
        return value
    if type.type == FIXED:
        return int(value * (1 << (type.size/2)))
    if not type.norm:
        return int(value)
    if type.type == UNSIGNED:
        return int(value * ((1 << type.size) - 1))
    if type.type == SIGNED:
        return int(value * ((1 << (type.size - 1)) - 1))
    assert False


def native_to_constant(type, value):
    '''Get the value of unity for this type.'''
    if type.type == FLOAT:
        if type.size <= 32:
            return "%ff" % value 
        else:
            return "%ff" % value 
    else:
        return str(int(value))


def get_one(type):
    '''Get the value of unity for this type.'''
    return value_to_native(type, 1)


def clamp_expr(src_channel, dst_channel, dst_native_type, value):
    '''Generate the expression to clamp the value in the source type to the
    destination type range.'''

    if src_channel == dst_channel:
        return value

    src_min = src_channel.min()
    src_max = src_channel.max()
    dst_min = dst_channel.min()
    dst_max = dst_channel.max()
    
    # Translate the destination range to the src native value
    dst_min_native = value_to_native(src_channel, dst_min)
    dst_max_native = value_to_native(src_channel, dst_max)

    if src_min < dst_min and src_max > dst_max:
        return 'CLAMP(%s, %s, %s)' % (value, dst_min_native, dst_max_native)

    if src_max > dst_max:
        return 'MIN2(%s, %s)' % (value, dst_max_native)
        
    if src_min < dst_min:
        return 'MAX2(%s, %s)' % (value, dst_min_native)

    return value


def conversion_expr(src_channel, 
                    dst_channel, dst_native_type, 
                    value, 
                    clamp=True, 
                    src_colorspace = RGB, 
                    dst_colorspace = RGB):
    '''Generate the expression to convert a value between two types.'''

    if src_colorspace != dst_colorspace:
        if src_colorspace == SRGB:
            assert src_channel.type == UNSIGNED
            assert src_channel.norm
            assert src_channel.size <= 8
            assert src_channel.size >= 4
            assert dst_colorspace == RGB
            if src_channel.size < 8:
                value = '%s << %x | %s >> %x' % (value, 8 - src_channel.size, value, 2 * src_channel.size - 8)
            if dst_channel.type == FLOAT:
                return 'util_format_srgb_8unorm_to_linear_float(%s)' % value
            else:
                assert dst_channel.type == UNSIGNED
                assert dst_channel.norm
                assert dst_channel.size == 8
                return 'util_format_srgb_to_linear_8unorm(%s)' % value
        elif dst_colorspace == SRGB:
            assert dst_channel.type == UNSIGNED
            assert dst_channel.norm
            assert dst_channel.size <= 8
            assert src_colorspace == RGB
            if src_channel.type == FLOAT:
                value =  'util_format_linear_float_to_srgb_8unorm(%s)' % value
            else:
                assert src_channel.type == UNSIGNED
                assert src_channel.norm
                assert src_channel.size == 8
                value = 'util_format_linear_to_srgb_8unorm(%s)' % value
            # XXX rounding is all wrong.
            if dst_channel.size < 8:
                return '%s >> %x' % (value, 8 - dst_channel.size)
            else:
                return value
        elif src_colorspace == ZS:
            pass
        elif dst_colorspace == ZS:
            pass
        else:
            assert 0

    if src_channel == dst_channel:
        return value

    src_type = src_channel.type
    src_size = src_channel.size
    src_norm = src_channel.norm
    src_pure = src_channel.pure

    # Promote half to float
    if src_type == FLOAT and src_size == 16:
        value = 'util_half_to_float(%s)' % value
        src_size = 32

    # Special case for float <-> ubytes for more accurate results
    # Done before clamping since these functions already take care of that
    if src_type == UNSIGNED and src_norm and src_size == 8 and dst_channel.type == FLOAT and dst_channel.size == 32:
        return 'ubyte_to_float(%s)' % value
    if src_type == FLOAT and src_size == 32 and dst_channel.type == UNSIGNED and dst_channel.norm and dst_channel.size == 8:
        return 'float_to_ubyte(%s)' % value

    if clamp:
        if dst_channel.type != FLOAT or src_type != FLOAT:
            value = clamp_expr(src_channel, dst_channel, dst_native_type, value)

    if src_type in (SIGNED, UNSIGNED) and dst_channel.type in (SIGNED, UNSIGNED):
        if not src_norm and not dst_channel.norm:
            # neither is normalized -- just cast
            return '(%s)%s' % (dst_native_type, value)

        src_one = get_one(src_channel)
        dst_one = get_one(dst_channel)

        if src_one > dst_one and src_norm and dst_channel.norm:
            # We can just bitshift
            src_shift = get_one_shift(src_channel)
            dst_shift = get_one_shift(dst_channel)
            value = '(%s >> %s)' % (value, src_shift - dst_shift)
        else:
            # We need to rescale using an intermediate type big enough to hold the multiplication of both
            tmp_native_type = intermediate_native_type(src_size + dst_channel.size, src_channel.sign and dst_channel.sign)
            value = '((%s)%s)' % (tmp_native_type, value)
            value = '(%s * 0x%x / 0x%x)' % (value, dst_one, src_one)
        value = '(%s)%s' % (dst_native_type, value)
        return value

    # Promote to either float or double
    if src_type != FLOAT:
        if src_norm or src_type == FIXED:
            one = get_one(src_channel)
            if src_size <= 23:
                value = '(%s * (1.0f/0x%x))' % (value, one)
                if dst_channel.size <= 32:
                    value = '(float)%s' % value
                src_size = 32
            else:
                # bigger than single precision mantissa, use double
                value = '(%s * (1.0/0x%x))' % (value, one)
                src_size = 64
            src_norm = False
        else:
            if src_size <= 23 or dst_channel.size <= 32:
                value = '(float)%s' % value
                src_size = 32
            else:
                # bigger than single precision mantissa, use double
                value = '(double)%s' % value
                src_size = 64
        src_type = FLOAT

    # Convert double or float to non-float
    if dst_channel.type != FLOAT:
        if dst_channel.norm or dst_channel.type == FIXED:
            dst_one = get_one(dst_channel)
            if dst_channel.size <= 23:
                value = 'util_iround(%s * 0x%x)' % (value, dst_one)
            else:
                # bigger than single precision mantissa, use double
                value = '(%s * (double)0x%x)' % (value, dst_one)
        value = '(%s)%s' % (dst_native_type, value)
    else:
        # Cast double to float when converting to either half or float
        if dst_channel.size <= 32 and src_size > 32:
            value = '(float)%s' % value
            src_size = 32

        if dst_channel.size == 16:
            value = 'util_float_to_half(%s)' % value
        elif dst_channel.size == 64 and src_size < 64:
            value = '(double)%s' % value

    return value


def generate_unpack_kernel(format, dst_channel, dst_native_type):

    if not is_format_supported(format):
        return
    
    assert format.layout == PLAIN

    src_native_type = native_type(format)

    def unpack_from_bitmask(channels, swizzles):
        depth = format.block_size()
        print '         uint%u_t value = *(const uint%u_t *)src;' % (depth, depth) 

        # Declare the intermediate variables
        for i in range(format.nr_channels()):
            src_channel = channels[i]
            if src_channel.type == UNSIGNED:
                print '         uint%u_t %s;' % (depth, src_channel.name)
            elif src_channel.type == SIGNED:
                print '         int%u_t %s;' % (depth, src_channel.name)

        # Compute the intermediate unshifted values 
        for i in range(format.nr_channels()):
            src_channel = channels[i]
            value = 'value'
            shift = src_channel.shift
            if src_channel.type == UNSIGNED:
                if shift:
                    value = '%s >> %u' % (value, shift)
                if shift + src_channel.size < depth:
                    value = '(%s) & 0x%x' % (value, (1 << src_channel.size) - 1)
            elif src_channel.type == SIGNED:
                if shift + src_channel.size < depth:
                    # Align the sign bit
                    lshift = depth - (shift + src_channel.size)
                    value = '%s << %u' % (value, lshift)
                # Cast to signed
                value = '(int%u_t)(%s) ' % (depth, value)
                if src_channel.size < depth:
                    # Align the LSB bit
                    rshift = depth - src_channel.size
                    value = '(%s) >> %u' % (value, rshift)
            else:
                value = None
                
            if value is not None:
                print '         %s = %s;' % (src_channel.name, value)
                
        # Convert, swizzle, and store final values
        for i in range(4):
            swizzle = swizzles[i]
            if swizzle < 4:
                src_channel = channels[swizzle]
                src_colorspace = format.colorspace
                if src_colorspace == SRGB and i == 3:
                    # Alpha channel is linear
                    src_colorspace = RGB
                value = src_channel.name 
                value = conversion_expr(src_channel, 
                                        dst_channel, dst_native_type, 
                                        value,
                                        src_colorspace = src_colorspace)
            elif swizzle == SWIZZLE_0:
                value = '0'
            elif swizzle == SWIZZLE_1:
                value = get_one(dst_channel)
            elif swizzle == SWIZZLE_NONE:
                value = '0'
            else:
                assert False
            print '         dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i])
        
    def unpack_from_union(channels, swizzles):
        print '         union util_format_%s pixel;' % format.short_name()
        print '         memcpy(&pixel, src, sizeof pixel);'
    
        for i in range(4):
            swizzle = swizzles[i]
            if swizzle < 4:
                src_channel = channels[swizzle]
                src_colorspace = format.colorspace
                if src_colorspace == SRGB and i == 3:
                    # Alpha channel is linear
                    src_colorspace = RGB
                value = 'pixel.chan.%s' % src_channel.name 
                value = conversion_expr(src_channel, 
                                        dst_channel, dst_native_type, 
                                        value,
                                        src_colorspace = src_colorspace)
            elif swizzle == SWIZZLE_0:
                value = '0'
            elif swizzle == SWIZZLE_1:
                value = get_one(dst_channel)
            elif swizzle == SWIZZLE_NONE:
                value = '0'
            else:
                assert False
            print '         dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i])
    
    if format.is_bitmask():
        print_channels(format, unpack_from_bitmask)
    else:
        print_channels(format, unpack_from_union)


def generate_pack_kernel(format, src_channel, src_native_type):

    if not is_format_supported(format):
        return
    
    dst_native_type = native_type(format)

    assert format.layout == PLAIN

    def pack_into_bitmask(channels, swizzles):
        inv_swizzle = inv_swizzles(swizzles)

        depth = format.block_size()
        print '         uint%u_t value = 0;' % depth 

        for i in range(4):
            dst_channel = channels[i]
            shift = dst_channel.shift
            if inv_swizzle[i] is not None:
                value ='src[%u]' % inv_swizzle[i]
                dst_colorspace = format.colorspace
                if dst_colorspace == SRGB and inv_swizzle[i] == 3:
                    # Alpha channel is linear
                    dst_colorspace = RGB
                value = conversion_expr(src_channel, 
                                        dst_channel, dst_native_type, 
                                        value,
                                        dst_colorspace = dst_colorspace)
                if dst_channel.type in (UNSIGNED, SIGNED):
                    if shift + dst_channel.size < depth:
                        value = '(%s) & 0x%x' % (value, (1 << dst_channel.size) - 1)
                    if shift:
                        value = '(%s) << %u' % (value, shift)
                    if dst_channel.type == SIGNED:
                        # Cast to unsigned
                        value = '(uint%u_t)(%s) ' % (depth, value)
                else:
                    value = None
                if value is not None:
                    print '         value |= %s;' % (value)
                
        print '         *(uint%u_t *)dst = value;' % depth 

    def pack_into_union(channels, swizzles):
        inv_swizzle = inv_swizzles(swizzles)

        print '         union util_format_%s pixel;' % format.short_name()
    
        for i in range(4):
            dst_channel = channels[i]
            width = dst_channel.size
            if inv_swizzle[i] is None:
                continue
            dst_colorspace = format.colorspace
            if dst_colorspace == SRGB and inv_swizzle[i] == 3:
                # Alpha channel is linear
                dst_colorspace = RGB
            value ='src[%u]' % inv_swizzle[i]
            value = conversion_expr(src_channel, 
                                    dst_channel, dst_native_type, 
                                    value, 
                                    dst_colorspace = dst_colorspace)
            print '         pixel.chan.%s = %s;' % (dst_channel.name, value)
    
        print '         memcpy(dst, &pixel, sizeof pixel);'
    
    if format.is_bitmask():
        print_channels(format, pack_into_bitmask)
    else:
        print_channels(format, pack_into_union)


def generate_format_unpack(format, dst_channel, dst_native_type, dst_suffix):
    '''Generate the function to unpack pixels from a particular format'''

    name = format.short_name()

    print 'static INLINE void'
    print 'util_format_%s_unpack_%s(%s *dst_row, unsigned dst_stride, const uint8_t *src_row, unsigned src_stride, unsigned width, unsigned height)' % (name, dst_suffix, dst_native_type)
    print '{'

    if is_format_supported(format):
        print '   unsigned x, y;'
        print '   for(y = 0; y < height; y += %u) {' % (format.block_height,)
        print '      %s *dst = dst_row;' % (dst_native_type)
        print '      const uint8_t *src = src_row;'
        print '      for(x = 0; x < width; x += %u) {' % (format.block_width,)
        
        generate_unpack_kernel(format, dst_channel, dst_native_type)
    
        print '         src += %u;' % (format.block_size() / 8,)
        print '         dst += 4;'
        print '      }'
        print '      src_row += src_stride;'
        print '      dst_row += dst_stride/sizeof(*dst_row);'
        print '   }'

    print '}'
    print
    

def generate_format_pack(format, src_channel, src_native_type, src_suffix):
    '''Generate the function to pack pixels to a particular format'''

    name = format.short_name()

    print 'static INLINE void'
    print 'util_format_%s_pack_%s(uint8_t *dst_row, unsigned dst_stride, const %s *src_row, unsigned src_stride, unsigned width, unsigned height)' % (name, src_suffix, src_native_type)
    print '{'
    
    if is_format_supported(format):
        print '   unsigned x, y;'
        print '   for(y = 0; y < height; y += %u) {' % (format.block_height,)
        print '      const %s *src = src_row;' % (src_native_type)
        print '      uint8_t *dst = dst_row;'
        print '      for(x = 0; x < width; x += %u) {' % (format.block_width,)
    
        generate_pack_kernel(format, src_channel, src_native_type)
            
        print '         src += 4;'
        print '         dst += %u;' % (format.block_size() / 8,)
        print '      }'
        print '      dst_row += dst_stride;'
        print '      src_row += src_stride/sizeof(*src_row);'
        print '   }'
        
    print '}'
    print
    

def generate_format_fetch(format, dst_channel, dst_native_type, dst_suffix):
    '''Generate the function to unpack pixels from a particular format'''

    name = format.short_name()

    print 'static INLINE void'
    print 'util_format_%s_fetch_%s(%s *dst, const uint8_t *src, unsigned i, unsigned j)' % (name, dst_suffix, dst_native_type)
    print '{'

    if is_format_supported(format):
        generate_unpack_kernel(format, dst_channel, dst_native_type)

    print '}'
    print


def is_format_hand_written(format):
    return format.layout in ('s3tc', 'rgtc', 'etc', 'subsampled', 'other') or format.colorspace == ZS


def generate(formats):
    print
    print '#include "pipe/p_compiler.h"'
    print '#include "u_math.h"'
    print '#include "u_half.h"'
    print '#include "u_format.h"'
    print '#include "u_format_other.h"'
    print '#include "u_format_srgb.h"'
    print '#include "u_format_yuv.h"'
    print '#include "u_format_zs.h"'
    print

    for format in formats:
        if not is_format_hand_written(format):
            
            if is_format_supported(format):
                generate_format_type(format)

            if format.is_pure_unsigned():
                native_type = 'unsigned'
                suffix = 'unsigned'
                channel = Channel(UNSIGNED, False, True, 32)

                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)
                generate_format_fetch(format, channel, native_type, suffix)

                channel = Channel(SIGNED, False, True, 32)
                native_type = 'int'
                suffix = 'signed'
                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)   
            elif format.is_pure_signed():
                native_type = 'int'
                suffix = 'signed'
                channel = Channel(SIGNED, False, True, 32)

                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)   
                generate_format_fetch(format, channel, native_type, suffix)

                native_type = 'unsigned'
                suffix = 'unsigned'
                channel = Channel(UNSIGNED, False, True, 32)
                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)   
            else:
                channel = Channel(FLOAT, False, False, 32)
                native_type = 'float'
                suffix = 'rgba_float'

                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)
                generate_format_fetch(format, channel, native_type, suffix)

                channel = Channel(UNSIGNED, True, False, 8)
                native_type = 'uint8_t'
                suffix = 'rgba_8unorm'

                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)

@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a209 24
def truncate_mantissa(x, bits):
    '''Truncate an integer so it can be represented exactly with a floating
    point mantissa'''

    assert isinstance(x, (int, long))

    s = 1
    if x < 0:
        s = -1
        x = -x

    # We can represent integers up to mantissa + 1 bits exactly
    mask = (1 << (bits + 1)) - 1

    # Slide the mask until the MSB matches
    shift = 0
    while (x >> shift) & ~mask:
        shift += 1

    x &= mask << shift
    x *= s
    return x


a212 3
        if type.size <= 32 \
            and isinstance(value, (int, long)):
            return truncate_mantissa(value, 23)
d229 1
a229 1
            return "%.1ff" % float(value)
d231 1
a231 1
            return "%.1f" % float(value)
d254 2
a255 2
    dst_min_native = native_to_constant(src_channel, value_to_native(src_channel, dst_min))
    dst_max_native = native_to_constant(src_channel, value_to_native(src_channel, dst_max))
d662 1
a662 1
    return format.layout in ('s3tc', 'rgtc', 'etc', 'bptc', 'subsampled', 'other') or format.colorspace == ZS
d672 1
a672 1
    print '#include "util/format_srgb.h"'
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d210 24
d237 3
d256 1
a256 1
            return "%ff" % value 
d258 1
a258 1
            return "%ff" % value 
d281 2
a282 2
    dst_min_native = value_to_native(src_channel, dst_min)
    dst_max_native = value_to_native(src_channel, dst_max)
d689 1
a689 1
    return format.layout in ('s3tc', 'rgtc', 'etc', 'subsampled', 'other') or format.colorspace == ZS
d699 1
a699 1
    print '#include "u_format_srgb.h"'
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d43 20
d68 2
a69 13
    print 'union util_format_%s {' % format.short_name()
    
    if format.block_size() in (8, 16, 32, 64):
        print '   uint%u_t value;' % (format.block_size(),)

    use_bitfields = False
    for channel in format.channels:
        if channel.size % 8 or not is_pot(channel.size):
            use_bitfields = True

    print '   struct {'
    for channel in format.channels:
        if use_bitfields:
d86 3
a88 1
        else:
d108 16
d139 1
a139 1
        channel = format.channels[i]
a146 21
def is_format_pure_unsigned(format):
    for i in range(4):
        channel = format.channels[i]
        if channel.type not in (VOID, UNSIGNED):
            return False
        if channel.type == UNSIGNED and channel.pure == False:
            return False

    return True


def is_format_pure_signed(format):
    for i in range(4):
        channel = format.channels[i]
        if channel.type not in (VOID, SIGNED):
            return False
        if channel.type == SIGNED and channel.pure == False:
            return False

    return True

d161 1
a161 1
            channel = format.channels[0]
d281 2
a282 1
            assert src_channel.size == 8
d284 2
d296 1
a296 1
            assert dst_channel.size == 8
d299 1
a299 1
                return 'util_format_linear_float_to_srgb_8unorm(%s)' % value
d304 6
a309 1
                return 'util_format_linear_to_srgb_8unorm(%s)' % value
d419 1
a419 1
    if format.is_bitmask():
d425 1
a425 1
            src_channel = format.channels[i]
d433 1
a433 1
            src_channel = format.channels[i]
d460 1
a460 1
            swizzle = format.swizzles[i]
d462 1
a462 1
                src_channel = format.channels[swizzle]
d482 1
a482 1
    else:
d487 1
a487 1
            swizzle = format.swizzles[i]
d489 1
a489 1
                src_channel = format.channels[swizzle]
d509 5
d524 2
a525 1
    inv_swizzle = format.inv_swizzles()
a526 1
    if format.is_bitmask():
d531 1
a531 1
            dst_channel = format.channels[i]
d558 3
a560 1
    else:
d564 1
a564 1
            dst_channel = format.channels[i]
d581 5
d683 1
a683 1
            if is_format_pure_unsigned(format):
d697 1
a697 1
            elif is_format_pure_signed(format):
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a101 9
def bswap_format(format):
    '''Generate a structure that describes the format.'''

    if format.is_bitmask() and not format.is_array() and format.block_size() > 8:
        print '#ifdef PIPE_ARCH_BIG_ENDIAN'
        print '   pixel.value = util_bswap%u(pixel.value);' % format.block_size()
        print '#endif'


d120 20
d144 5
d309 1
d377 1
a377 1
                value = '(%s * 0x%x)' % (value, dst_one)
a416 5
        if depth > 8:
            print '#ifdef PIPE_ARCH_BIG_ENDIAN'
            print '         value = util_bswap%u(value);' % depth
            print '#endif'

a417 1
        shift = 0
d421 1
a443 2
            shift += src_channel.size

a470 1
        bswap_format(format)
a510 1
        shift = 0
d513 1
a536 7
            shift += dst_channel.size

        if depth > 8:
            print '#ifdef PIPE_ARCH_BIG_ENDIAN'
            print '         value = util_bswap%u(value);' % depth
            print '#endif'
        
a557 1
        bswap_format(format)
d636 1
a636 1
    return format.layout in ('s3tc', 'rgtc', 'subsampled', 'other') or format.colorspace == ZS
d657 40
a696 11
            channel = Channel(FLOAT, False, 32)
            native_type = 'float'
            suffix = 'rgba_float'

            generate_format_unpack(format, channel, native_type, suffix)
            generate_format_pack(format, channel, native_type, suffix)
            generate_format_fetch(format, channel, native_type, suffix)

            channel = Channel(UNSIGNED, True, 8)
            native_type = 'uint8_t'
            suffix = 'rgba_8unorm'
d698 2
a699 2
            generate_format_unpack(format, channel, native_type, suffix)
            generate_format_pack(format, channel, native_type, suffix)
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d635 1
a635 1
    return format.layout in ('s3tc', 'subsampled', 'other') or format.colorspace == ZS
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d6 1
a6 1
 * Copyright 2009 VMware, Inc.
a39 2
import sys

d46 2
d49 2
a50 1
    if format.is_bitmask():
d52 6
d60 1
a60 1
        if format.is_bitmask() and not format.is_array():
d66 1
a66 1
            elif channel.type == SIGNED:
d68 7
d105 1
a105 1
    if format.is_bitmask() and not format.is_array():
d122 3
a124 1
        if channel.type not in (VOID, UNSIGNED, SIGNED, FLOAT):
a126 4
    # We can only read a color from a depth/stencil format if the depth channel is present
    if format.colorspace == 'zs' and format.swizzles[0] == SWIZZLE_NONE:
        return False

d139 9
a147 7
            type = format.channels[0]
            if type.type == UNSIGNED:
                return 'uint%u_t' % type.size
            elif type.type == SIGNED:
                return 'int%u_t' % type.size
            elif type.type == FLOAT:
                if type.size == 32:
d149 1
a149 1
                elif type.size == 64:
d188 16
a203 1
def get_one(type):
d205 5
a209 2
    if type.type == 'FLOAT' or not type.norm:
        return 1
d211 1
a211 1
        return (1 << get_one_shift(type)) - 1
d214 3
a216 23
def generate_clamp():
    '''Code generate the clamping functions for each type.

    We don't use a macro so that arguments with side effects, 
    like *src_pixel++ are correctly handled.
    '''

    for suffix, native_type in [
        ('', 'double'),
        ('f', 'float'),
        ('ui', 'unsigned int'),
        ('si', 'int'),
    ]:
        print 'static INLINE %s' % native_type
        print 'clamp%s(%s value, %s lbound, %s ubound)' % (suffix, native_type, native_type, native_type)
        print '{'
        print '   if(value < lbound)'
        print '      return lbound;'
        print '   if(value > ubound)'
        print '      return ubound;'
        print '   return value;'
        print '}'
        print
a225 15
    # Pick the approriate clamp function
    if src_channel.type == FLOAT:
        if src_channel.size == 32:
            func = 'clampf'
        elif src_channel.size == 64:
            func = 'clamp'
        else:
            assert False
    elif src_channel.type == UNSIGNED:
        func = 'clampui'
    elif src_channel.type == SIGNED:
        func = 'clampsi'
    else:
        assert False

d230 4
d236 1
a236 1
        return 'CLAMP(%s, %s, %s)' % (value, dst_min, dst_max)
d239 1
a239 1
        return 'MIN2(%s, %s)' % (value, dst_max)
d242 1
a242 1
        return 'MAX2(%s, %s)' % (value, dst_min)
d247 6
a252 1
def conversion_expr(src_channel, dst_channel, dst_native_type, value, clamp=True):
d255 32
d290 15
a304 5
    if src_channel.type == FLOAT and dst_channel.type == FLOAT:
        return '(%s)%s' % (dst_native_type, value)
    
    if not src_channel.norm and not dst_channel.norm:
        return '(%s)%s' % (dst_native_type, value)
d307 2
a308 1
        value = clamp_expr(src_channel, dst_channel, dst_native_type, value)
d310 4
a313 10
    if dst_channel.type == FLOAT:
        if src_channel.norm:
            one = get_one(src_channel)
            if src_channel.size <= 23:
                scale = '(1.0f/0x%x)' % one
            else:
                # bigger than single precision mantissa, use double
                scale = '(1.0/0x%x)' % one
            value = '(%s * %s)' % (value, scale)
        return '(%s)%s' % (dst_native_type, value)
a314 16
    if src_channel.type == FLOAT:
        if dst_channel.norm:
            dst_one = get_one(dst_channel)
            if dst_channel.size <= 23:
                scale = '0x%x' % dst_one
            else:
                # bigger than single precision mantissa, use double
                scale = '(double)0x%x' % dst_one
            value = '(%s * %s)' % (value, scale)
        return '(%s)%s' % (dst_native_type, value)

    if not src_channel.norm and not dst_channel.norm:
        # neither is normalized -- just cast
        return '(%s)%s' % (dst_native_type, value)

    if src_channel.type in (SIGNED, UNSIGNED) and dst_channel.type in (SIGNED, UNSIGNED):
d318 1
a318 1
        if src_one > dst_one and src_channel.norm:
d325 2
a326 2
            tmp_native_type = intermediate_native_type(src_channel.size + dst_channel.size, src_channel.sign and dst_channel.sign)
            value = '(%s)%s' % (tmp_native_type, value)
d331 46
a376 1
    assert False
d379 1
a379 2
def generate_format_unpack(format, dst_channel, dst_native_type, dst_suffix):
    '''Generate the function to unpack pixels from a particular format'''
d381 4
a384 1
    name = format.short_name()
d388 105
a492 6
    print 'static INLINE void'
    print 'util_format_%s_unpack_%s(%s *dst, const void *src)' % (name, dst_suffix, dst_native_type)
    print '{'
    print '   union util_format_%s pixel;' % format.short_name()
    print '   memcpy(&pixel, src, sizeof pixel);'
    bswap_format(format)
d496 40
a535 20
    for i in range(4):
        swizzle = format.swizzles[i]
        if swizzle < 4:
            src_channel = format.channels[swizzle]
            value = 'pixel.chan.%s' % src_channel.name 
            value = conversion_expr(src_channel, dst_channel, dst_native_type, value)
        elif swizzle == SWIZZLE_0:
            value = '0'
        elif swizzle == SWIZZLE_1:
            value = get_one(dst_channel)
        elif swizzle == SWIZZLE_NONE:
            value = '0'
        else:
            assert False
        if format.colorspace == ZS:
            if i == 3:
                value = get_one(dst_channel)
            elif i >= 1:
                value = 'dst[0]'
        print '   dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i])
d537 21
a557 2
    print '}'
    print
d560 2
a561 2
def generate_format_pack(format, src_channel, src_native_type, src_suffix):
    '''Generate the function to pack pixels to a particular format'''
a564 2
    dst_native_type = native_type(format)

d566 1
a566 1
    print 'util_format_%s_pack_%s(void *dst, %s r, %s g, %s b, %s a)' % (name, src_suffix, src_native_type, src_native_type, src_native_type, src_native_type)
a567 1
    print '   union util_format_%s pixel;' % format.short_name()
d569 15
a583 3
    assert format.layout == PLAIN

    inv_swizzle = format.inv_swizzles()
a584 16
    for i in range(4):
        dst_channel = format.channels[i]
        width = dst_channel.size
        if inv_swizzle[i] is None:
            continue
        value = 'rgba'[inv_swizzle[i]]
        value = conversion_expr(src_channel, dst_channel, dst_native_type, value)
        if format.colorspace == ZS:
            if i == 3:
                value = get_one(dst_channel)
            elif i >= 1:
                value = '0'
        print '   pixel.chan.%s = %s;' % (dst_channel.name, value)

    bswap_format(format)
    print '   memcpy(dst, &pixel, sizeof pixel);'
d589 2
a590 2
def generate_unpack(formats, dst_channel, dst_native_type, dst_suffix):
    '''Generate the dispatch function to unpack pixels from any format'''
d592 1
a592 3
    for format in formats:
        if is_format_supported(format):
            generate_format_unpack(format, dst_channel, dst_native_type, dst_suffix)
d595 1
a595 1
    print 'util_format_unpack_%s(enum pipe_format format, %s *dst, const void *src)' % (dst_suffix, dst_native_type)
d597 17
a613 12
    print '   void (*func)(%s *dst, const void *src);' % dst_native_type
    print '   switch(format) {'
    for format in formats:
        if is_format_supported(format):
            print '   case %s:' % format.name
            print '      func = &util_format_%s_unpack_%s;' % (format.short_name(), dst_suffix)
            print '      break;'
    print '   default:'
    print '      debug_printf("unsupported format\\n");'
    print '      return;'
    print '   }'
    print '   func(dst, src);'
d616 1
d618 2
d621 1
a621 6
def generate_pack(formats, src_channel, src_native_type, src_suffix):
    '''Generate the dispatch function to pack pixels to any format'''

    for format in formats:
        if is_format_supported(format):
            generate_format_pack(format, src_channel, src_native_type, src_suffix)
d624 1
a624 1
    print 'util_format_pack_%s(enum pipe_format format, void *dst, %s r, %s g, %s b, %s a)' % (src_suffix, src_native_type, src_native_type, src_native_type, src_native_type)
d626 4
a629 12
    print '   void (*func)(void *dst, %s r, %s g, %s b, %s a);' % (src_native_type, src_native_type, src_native_type, src_native_type)
    print '   switch(format) {'
    for format in formats:
        if is_format_supported(format):
            print '   case %s:' % format.name
            print '      func = &util_format_%s_pack_%s;' % (format.short_name(), src_suffix)
            print '      break;'
    print '   default:'
    print '      debug_printf("%s: unsupported format\\n", __FUNCTION__);'
    print '      return;'
    print '   }'
    print '   func(dst, r, g, b, a);'
d634 2
a635 4
def main():
    formats = []
    for arg in sys.argv[1:]:
        formats.extend(parse(arg))
a636 4
    print '/* This file is autogenerated by u_format_pack.py from u_format.csv. Do not edit directly. */'
    print
    # This will print the copyright message on the top of this file
    print __doc__.strip()
d638 1
a638 3
    print
    print '#ifndef U_FORMAT_PACK_H'
    print '#define U_FORMAT_PACK_H'
d642 1
d644 4
a649 2
    generate_clamp()

d651 16
a666 23
        if format.layout == PLAIN:
            generate_format_type(format)

    channel = Channel(FLOAT, False, 32)
    native_type = 'float'
    suffix = '4f'

    generate_unpack(formats, channel, native_type, suffix)
    generate_pack(formats, channel, native_type, suffix)

    channel = Channel(UNSIGNED, True, 8)
    native_type = 'uint8_t'
    suffix = '4ub'

    generate_unpack(formats, channel, native_type, suffix)
    generate_pack(formats, channel, native_type, suffix)

    print
    print '#ifdef __cplusplus'
    print '}'
    print '#endif'
    print
    print '#endif /* ! U_FORMAT_PACK_H */'
d668 2
a670 2
if __name__ == '__main__':
    main()
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d6 1
a6 1
 * Copyright 2009-2010 VMware, Inc.
d40 2
a47 2
    assert format.layout == PLAIN
    
d49 1
a49 2
    
    if format.block_size() in (8, 16, 32, 64):
a50 6

    use_bitfields = False
    for channel in format.channels:
        if channel.size % 8 or not is_pot(channel.size):
            use_bitfields = True

d53 1
a53 1
        if use_bitfields:
d59 1
a59 1
            elif channel.type in (SIGNED, FIXED):
a60 7
            elif channel.type == FLOAT:
                if channel.size == 64:
                    print '      double %s;' % (channel.name)
                elif channel.size == 32:
                    print '      float %s;' % (channel.name)
                else:
                    print '      unsigned %s:%u;' % (channel.name, channel.size)
d91 1
a91 1
    if format.is_bitmask() and not format.is_array() and format.block_size() > 8:
d108 1
a108 3
        if channel.type not in (VOID, UNSIGNED, SIGNED, FLOAT, FIXED):
            return False
        if channel.type == FLOAT and channel.size not in (16, 32, 64):
d110 4
d127 7
a133 9
            channel = format.channels[0]
            if channel.type in (UNSIGNED, VOID):
                return 'uint%u_t' % channel.size
            elif channel.type in (SIGNED, FIXED):
                return 'int%u_t' % channel.size
            elif channel.type == FLOAT:
                if channel.size == 16:
                    return 'uint16_t'
                elif channel.size == 32:
d135 1
a135 1
                elif channel.size == 64:
d174 1
a174 1
def value_to_native(type, value):
d176 4
a179 11
    if type.type == FLOAT:
        return value
    if type.type == FIXED:
        return int(value * (1 << (type.size/2)))
    if not type.norm:
        return int(value)
    if type.type == UNSIGNED:
        return int(value * ((1 << type.size) - 1))
    if type.type == SIGNED:
        return int(value * ((1 << (type.size - 1)) - 1))
    assert False
d182 2
a183 9
def native_to_constant(type, value):
    '''Get the value of unity for this type.'''
    if type.type == FLOAT:
        if type.size <= 32:
            return "%ff" % value 
        else:
            return "%ff" % value 
    else:
        return str(int(value))
d185 20
a204 4

def get_one(type):
    '''Get the value of unity for this type.'''
    return value_to_native(type, 1)
d214 15
a232 4
    
    # Translate the destination range to the src native value
    dst_min_native = value_to_native(src_channel, dst_min)
    dst_max_native = value_to_native(src_channel, dst_max)
d235 1
a235 1
        return 'CLAMP(%s, %s, %s)' % (value, dst_min_native, dst_max_native)
d238 1
a238 1
        return 'MIN2(%s, %s)' % (value, dst_max_native)
d241 1
a241 1
        return 'MAX2(%s, %s)' % (value, dst_min_native)
d246 1
a246 6
def conversion_expr(src_channel, 
                    dst_channel, dst_native_type, 
                    value, 
                    clamp=True, 
                    src_colorspace = RGB, 
                    dst_colorspace = RGB):
a248 32
    if src_colorspace != dst_colorspace:
        if src_colorspace == SRGB:
            assert src_channel.type == UNSIGNED
            assert src_channel.norm
            assert src_channel.size == 8
            assert dst_colorspace == RGB
            if dst_channel.type == FLOAT:
                return 'util_format_srgb_8unorm_to_linear_float(%s)' % value
            else:
                assert dst_channel.type == UNSIGNED
                assert dst_channel.norm
                assert dst_channel.size == 8
                return 'util_format_srgb_to_linear_8unorm(%s)' % value
        elif dst_colorspace == SRGB:
            assert dst_channel.type == UNSIGNED
            assert dst_channel.norm
            assert dst_channel.size == 8
            assert src_colorspace == RGB
            if src_channel.type == FLOAT:
                return 'util_format_linear_float_to_srgb_8unorm(%s)' % value
            else:
                assert src_channel.type == UNSIGNED
                assert src_channel.norm
                assert src_channel.size == 8
                return 'util_format_linear_to_srgb_8unorm(%s)' % value
        elif src_colorspace == ZS:
            pass
        elif dst_colorspace == ZS:
            pass
        else:
            assert 0

d252 5
a256 15
    src_type = src_channel.type
    src_size = src_channel.size
    src_norm = src_channel.norm

    # Promote half to float
    if src_type == FLOAT and src_size == 16:
        value = 'util_half_to_float(%s)' % value
        src_size = 32

    # Special case for float <-> ubytes for more accurate results
    # Done before clamping since these functions already take care of that
    if src_type == UNSIGNED and src_norm and src_size == 8 and dst_channel.type == FLOAT and dst_channel.size == 32:
        return 'ubyte_to_float(%s)' % value
    if src_type == FLOAT and src_size == 32 and dst_channel.type == UNSIGNED and dst_channel.norm and dst_channel.size == 8:
        return 'float_to_ubyte(%s)' % value
d259 1
a259 2
        if dst_channel.type != FLOAT or src_type != FLOAT:
            value = clamp_expr(src_channel, dst_channel, dst_native_type, value)
d261 10
a270 4
    if src_type in (SIGNED, UNSIGNED) and dst_channel.type in (SIGNED, UNSIGNED):
        if not src_norm and not dst_channel.norm:
            # neither is normalized -- just cast
            return '(%s)%s' % (dst_native_type, value)
d272 16
d291 1
a291 1
        if src_one > dst_one and src_norm and dst_channel.norm:
d298 2
a299 2
            tmp_native_type = intermediate_native_type(src_size + dst_channel.size, src_channel.sign and dst_channel.sign)
            value = '((%s)%s)' % (tmp_native_type, value)
d304 1
a304 44
    # Promote to either float or double
    if src_type != FLOAT:
        if src_norm or src_type == FIXED:
            one = get_one(src_channel)
            if src_size <= 23:
                value = '(%s * (1.0f/0x%x))' % (value, one)
                if dst_channel.size <= 32:
                    value = '(float)%s' % value
                src_size = 32
            else:
                # bigger than single precision mantissa, use double
                value = '(%s * (1.0/0x%x))' % (value, one)
                src_size = 64
            src_norm = False
        else:
            if src_size <= 23 or dst_channel.size <= 32:
                value = '(float)%s' % value
                src_size = 32
            else:
                # bigger than single precision mantissa, use double
                value = '(double)%s' % value
                src_size = 64
        src_type = FLOAT

    # Convert double or float to non-float
    if dst_channel.type != FLOAT:
        if dst_channel.norm or dst_channel.type == FIXED:
            dst_one = get_one(dst_channel)
            if dst_channel.size <= 23:
                value = '(%s * 0x%x)' % (value, dst_one)
            else:
                # bigger than single precision mantissa, use double
                value = '(%s * (double)0x%x)' % (value, dst_one)
        value = '(%s)%s' % (dst_native_type, value)
    else:
        # Cast double to float when converting to either half or float
        if dst_channel.size <= 32 and src_size > 32:
            value = '(float)%s' % value
            src_size = 32

        if dst_channel.size == 16:
            value = 'util_float_to_half(%s)' % value
        elif dst_channel.size == 64 and src_size < 64:
            value = '(double)%s' % value
a305 1
    return value
d307 2
d310 1
a310 6
def generate_unpack_kernel(format, dst_channel, dst_native_type):

    if not is_format_supported(format):
        return
    
    assert format.layout == PLAIN
d314 6
a319 105
    if format.is_bitmask():
        depth = format.block_size()
        print '         uint%u_t value = *(const uint%u_t *)src;' % (depth, depth) 

        # Declare the intermediate variables
        for i in range(format.nr_channels()):
            src_channel = format.channels[i]
            if src_channel.type == UNSIGNED:
                print '         uint%u_t %s;' % (depth, src_channel.name)
            elif src_channel.type == SIGNED:
                print '         int%u_t %s;' % (depth, src_channel.name)

        if depth > 8:
            print '#ifdef PIPE_ARCH_BIG_ENDIAN'
            print '         value = util_bswap%u(value);' % depth
            print '#endif'

        # Compute the intermediate unshifted values 
        shift = 0
        for i in range(format.nr_channels()):
            src_channel = format.channels[i]
            value = 'value'
            if src_channel.type == UNSIGNED:
                if shift:
                    value = '%s >> %u' % (value, shift)
                if shift + src_channel.size < depth:
                    value = '(%s) & 0x%x' % (value, (1 << src_channel.size) - 1)
            elif src_channel.type == SIGNED:
                if shift + src_channel.size < depth:
                    # Align the sign bit
                    lshift = depth - (shift + src_channel.size)
                    value = '%s << %u' % (value, lshift)
                # Cast to signed
                value = '(int%u_t)(%s) ' % (depth, value)
                if src_channel.size < depth:
                    # Align the LSB bit
                    rshift = depth - src_channel.size
                    value = '(%s) >> %u' % (value, rshift)
            else:
                value = None
                
            if value is not None:
                print '         %s = %s;' % (src_channel.name, value)
                
            shift += src_channel.size

        # Convert, swizzle, and store final values
        for i in range(4):
            swizzle = format.swizzles[i]
            if swizzle < 4:
                src_channel = format.channels[swizzle]
                src_colorspace = format.colorspace
                if src_colorspace == SRGB and i == 3:
                    # Alpha channel is linear
                    src_colorspace = RGB
                value = src_channel.name 
                value = conversion_expr(src_channel, 
                                        dst_channel, dst_native_type, 
                                        value,
                                        src_colorspace = src_colorspace)
            elif swizzle == SWIZZLE_0:
                value = '0'
            elif swizzle == SWIZZLE_1:
                value = get_one(dst_channel)
            elif swizzle == SWIZZLE_NONE:
                value = '0'
            else:
                assert False
            print '         dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i])
        
    else:
        print '         union util_format_%s pixel;' % format.short_name()
        print '         memcpy(&pixel, src, sizeof pixel);'
        bswap_format(format)
    
        for i in range(4):
            swizzle = format.swizzles[i]
            if swizzle < 4:
                src_channel = format.channels[swizzle]
                src_colorspace = format.colorspace
                if src_colorspace == SRGB and i == 3:
                    # Alpha channel is linear
                    src_colorspace = RGB
                value = 'pixel.chan.%s' % src_channel.name 
                value = conversion_expr(src_channel, 
                                        dst_channel, dst_native_type, 
                                        value,
                                        src_colorspace = src_colorspace)
            elif swizzle == SWIZZLE_0:
                value = '0'
            elif swizzle == SWIZZLE_1:
                value = get_one(dst_channel)
            elif swizzle == SWIZZLE_NONE:
                value = '0'
            else:
                assert False
            print '         dst[%u] = %s; /* %s */' % (i, value, 'rgba'[i])
    

def generate_pack_kernel(format, src_channel, src_native_type):

    if not is_format_supported(format):
        return
    
    dst_native_type = native_type(format)
d323 20
a342 1
    inv_swizzle = format.inv_swizzles()
d344 2
a345 60
    if format.is_bitmask():
        depth = format.block_size()
        print '         uint%u_t value = 0;' % depth 

        shift = 0
        for i in range(4):
            dst_channel = format.channels[i]
            if inv_swizzle[i] is not None:
                value ='src[%u]' % inv_swizzle[i]
                dst_colorspace = format.colorspace
                if dst_colorspace == SRGB and inv_swizzle[i] == 3:
                    # Alpha channel is linear
                    dst_colorspace = RGB
                value = conversion_expr(src_channel, 
                                        dst_channel, dst_native_type, 
                                        value,
                                        dst_colorspace = dst_colorspace)
                if dst_channel.type in (UNSIGNED, SIGNED):
                    if shift + dst_channel.size < depth:
                        value = '(%s) & 0x%x' % (value, (1 << dst_channel.size) - 1)
                    if shift:
                        value = '(%s) << %u' % (value, shift)
                    if dst_channel.type == SIGNED:
                        # Cast to unsigned
                        value = '(uint%u_t)(%s) ' % (depth, value)
                else:
                    value = None
                if value is not None:
                    print '         value |= %s;' % (value)
                
            shift += dst_channel.size

        if depth > 8:
            print '#ifdef PIPE_ARCH_BIG_ENDIAN'
            print '         value = util_bswap%u(value);' % depth
            print '#endif'
        
        print '         *(uint%u_t *)dst = value;' % depth 

    else:
        print '         union util_format_%s pixel;' % format.short_name()
    
        for i in range(4):
            dst_channel = format.channels[i]
            width = dst_channel.size
            if inv_swizzle[i] is None:
                continue
            dst_colorspace = format.colorspace
            if dst_colorspace == SRGB and inv_swizzle[i] == 3:
                # Alpha channel is linear
                dst_colorspace = RGB
            value ='src[%u]' % inv_swizzle[i]
            value = conversion_expr(src_channel, 
                                    dst_channel, dst_native_type, 
                                    value, 
                                    dst_colorspace = dst_colorspace)
            print '         pixel.chan.%s = %s;' % (dst_channel.name, value)
    
        bswap_format(format)
        print '         memcpy(dst, &pixel, sizeof pixel);'
d348 2
a349 2
def generate_format_unpack(format, dst_channel, dst_native_type, dst_suffix):
    '''Generate the function to unpack pixels from a particular format'''
d353 2
d356 1
a356 1
    print 'util_format_%s_unpack_%s(%s *dst_row, unsigned dst_stride, const uint8_t *src_row, unsigned src_stride, unsigned width, unsigned height)' % (name, dst_suffix, dst_native_type)
d358 3
d362 15
a376 15
    if is_format_supported(format):
        print '   unsigned x, y;'
        print '   for(y = 0; y < height; y += %u) {' % (format.block_height,)
        print '      %s *dst = dst_row;' % (dst_native_type)
        print '      const uint8_t *src = src_row;'
        print '      for(x = 0; x < width; x += %u) {' % (format.block_width,)
        
        generate_unpack_kernel(format, dst_channel, dst_native_type)
    
        print '         src += %u;' % (format.block_size() / 8,)
        print '         dst += 4;'
        print '      }'
        print '      src_row += src_stride;'
        print '      dst_row += dst_stride/sizeof(*dst_row);'
        print '   }'
d378 2
d384 2
a385 2
def generate_format_pack(format, src_channel, src_native_type, src_suffix):
    '''Generate the function to pack pixels to a particular format'''
d387 3
a389 1
    name = format.short_name()
d392 1
a392 1
    print 'util_format_%s_pack_%s(uint8_t *dst_row, unsigned dst_stride, const %s *src_row, unsigned src_stride, unsigned width, unsigned height)' % (name, src_suffix, src_native_type)
d394 12
a405 17
    
    if is_format_supported(format):
        print '   unsigned x, y;'
        print '   for(y = 0; y < height; y += %u) {' % (format.block_height,)
        print '      const %s *src = src_row;' % (src_native_type)
        print '      uint8_t *dst = dst_row;'
        print '      for(x = 0; x < width; x += %u) {' % (format.block_width,)
    
        generate_pack_kernel(format, src_channel, src_native_type)
            
        print '         src += 4;'
        print '         dst += %u;' % (format.block_size() / 8,)
        print '      }'
        print '      dst_row += dst_stride;'
        print '      src_row += src_stride/sizeof(*src_row);'
        print '   }'
        
a407 1
    
a408 2
def generate_format_fetch(format, dst_channel, dst_native_type, dst_suffix):
    '''Generate the function to unpack pixels from a particular format'''
d410 6
a415 1
    name = format.short_name()
d418 1
a418 1
    print 'util_format_%s_fetch_%s(%s *dst, const uint8_t *src, unsigned i, unsigned j)' % (name, dst_suffix, dst_native_type)
d420 12
a431 4

    if is_format_supported(format):
        generate_unpack_kernel(format, dst_channel, dst_native_type)

d436 4
a439 2
def is_format_hand_written(format):
    return format.layout in ('s3tc', 'subsampled', 'other') or format.colorspace == ZS
d441 4
d446 3
a448 1
def generate(formats):
a451 1
    print '#include "u_half.h"'
a452 4
    print '#include "u_format_other.h"'
    print '#include "u_format_srgb.h"'
    print '#include "u_format_yuv.h"'
    print '#include "u_format_zs.h"'
d455 2
d458 23
a480 16
        if not is_format_hand_written(format):
            
            if is_format_supported(format):
                generate_format_type(format)

            channel = Channel(FLOAT, False, 32)
            native_type = 'float'
            suffix = 'rgba_float'

            generate_format_unpack(format, channel, native_type, suffix)
            generate_format_pack(format, channel, native_type, suffix)
            generate_format_fetch(format, channel, native_type, suffix)

            channel = Channel(UNSIGNED, True, 8)
            native_type = 'uint8_t'
            suffix = 'rgba_8unorm'
a481 2
            generate_format_unpack(format, channel, native_type, suffix)
            generate_format_pack(format, channel, native_type, suffix)
d483 2
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d102 9
a128 20
def is_format_pure_unsigned(format):
    for i in range(4):
        channel = format.channels[i]
        if channel.type not in (VOID, UNSIGNED):
            return False
        if channel.type == UNSIGNED and channel.pure == False:
            return False

    return True


def is_format_pure_signed(format):
    for i in range(4):
        channel = format.channels[i]
        if channel.type not in (VOID, SIGNED):
            return False
        if channel.type == SIGNED and channel.pure == False:
            return False

    return True
a132 5
    if format.name == 'PIPE_FORMAT_R11G11B10_FLOAT':
        return 'uint32_t'
    if format.name == 'PIPE_FORMAT_R9G9B9E5_FLOAT':
        return 'uint32_t'

a292 1
    src_pure = src_channel.pure
d360 1
a360 1
                value = 'util_iround(%s * 0x%x)' % (value, dst_one)
d400 5
d406 1
a409 1
            shift = src_channel.shift
d432 2
d461 1
d502 1
a504 1
            shift = dst_channel.shift
d528 7
d556 1
d635 1
a635 1
    return format.layout in ('s3tc', 'rgtc', 'etc', 'subsampled', 'other') or format.colorspace == ZS
d656 11
a666 40
            if is_format_pure_unsigned(format):
                native_type = 'unsigned'
                suffix = 'unsigned'
                channel = Channel(UNSIGNED, False, True, 32)

                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)
                generate_format_fetch(format, channel, native_type, suffix)

                channel = Channel(SIGNED, False, True, 32)
                native_type = 'int'
                suffix = 'signed'
                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)   
            elif is_format_pure_signed(format):
                native_type = 'int'
                suffix = 'signed'
                channel = Channel(SIGNED, False, True, 32)

                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)   
                generate_format_fetch(format, channel, native_type, suffix)

                native_type = 'unsigned'
                suffix = 'unsigned'
                channel = Channel(UNSIGNED, False, True, 32)
                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)   
            else:
                channel = Channel(FLOAT, False, False, 32)
                native_type = 'float'
                suffix = 'rgba_float'

                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)
                generate_format_fetch(format, channel, native_type, suffix)

                channel = Channel(UNSIGNED, True, False, 8)
                native_type = 'uint8_t'
                suffix = 'rgba_8unorm'
d668 2
a669 2
                generate_format_unpack(format, channel, native_type, suffix)
                generate_format_pack(format, channel, native_type, suffix)
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a42 20
def inv_swizzles(swizzles):
    '''Return an array[4] of inverse swizzle terms'''
    '''Only pick the first matching value to avoid l8 getting blue and i8 getting alpha'''
    inv_swizzle = [None]*4
    for i in range(4):
        swizzle = swizzles[i]
        if swizzle < 4 and inv_swizzle[swizzle] == None:
            inv_swizzle[swizzle] = i
    return inv_swizzle

def print_channels(format, func):
    if format.nr_channels() <= 1:
        func(format.le_channels, format.le_swizzles)
    else:
        print '#ifdef PIPE_ARCH_BIG_ENDIAN'
        func(format.be_channels, format.be_swizzles)
        print '#else'
        func(format.le_channels, format.le_swizzles)
        print '#endif'

d48 13
a60 2
    def generate_bitfields(channels, swizzles):
        for channel in channels:
d77 1
a77 3

    def generate_full_fields(channels, swizzles):
        for channel in channels:
a96 16

    print 'union util_format_%s {' % format.short_name()
    
    if format.block_size() in (8, 16, 32, 64):
        print '   uint%u_t value;' % (format.block_size(),)

    use_bitfields = False
    for channel in format.le_channels:
        if channel.size % 8 or not is_pot(channel.size):
            use_bitfields = True

    print '   struct {'
    if use_bitfields:
        print_channels(format, generate_bitfields)
    else:
        print_channels(format, generate_full_fields)
d112 1
a112 1
        channel = format.le_channels[i]
d120 21
d155 1
a155 1
            channel = format.array_element()
d275 1
a275 2
            assert src_channel.size <= 8
            assert src_channel.size >= 4
a276 2
            if src_channel.size < 8:
                value = '%s << %x | %s >> %x' % (value, 8 - src_channel.size, value, 2 * src_channel.size - 8)
d287 1
a287 1
            assert dst_channel.size <= 8
d290 1
a290 1
                value =  'util_format_linear_float_to_srgb_8unorm(%s)' % value
d295 1
a295 6
                value = 'util_format_linear_to_srgb_8unorm(%s)' % value
            # XXX rounding is all wrong.
            if dst_channel.size < 8:
                return '%s >> %x' % (value, 8 - dst_channel.size)
            else:
                return value
d405 1
a405 1
    def unpack_from_bitmask(channels, swizzles):
d411 1
a411 1
            src_channel = channels[i]
d419 1
a419 1
            src_channel = channels[i]
d446 1
a446 1
            swizzle = swizzles[i]
d448 1
a448 1
                src_channel = channels[swizzle]
d468 1
a468 1
    def unpack_from_union(channels, swizzles):
d473 1
a473 1
            swizzle = swizzles[i]
d475 1
a475 1
                src_channel = channels[swizzle]
a494 5
    if format.is_bitmask():
        print_channels(format, unpack_from_bitmask)
    else:
        print_channels(format, unpack_from_union)

d505 1
a505 2
    def pack_into_bitmask(channels, swizzles):
        inv_swizzle = inv_swizzles(swizzles)
d507 1
d512 1
a512 1
            dst_channel = channels[i]
d539 1
a539 3
    def pack_into_union(channels, swizzles):
        inv_swizzle = inv_swizzles(swizzles)

d543 1
a543 1
            dst_channel = channels[i]
a559 5
    if format.is_bitmask():
        print_channels(format, pack_into_bitmask)
    else:
        print_channels(format, pack_into_union)

d657 1
a657 1
            if format.is_pure_unsigned():
d671 1
a671 1
            elif format.is_pure_signed():
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a209 24
def truncate_mantissa(x, bits):
    '''Truncate an integer so it can be represented exactly with a floating
    point mantissa'''

    assert isinstance(x, (int, long))

    s = 1
    if x < 0:
        s = -1
        x = -x

    # We can represent integers up to mantissa + 1 bits exactly
    mask = (1 << (bits + 1)) - 1

    # Slide the mask until the MSB matches
    shift = 0
    while (x >> shift) & ~mask:
        shift += 1

    x &= mask << shift
    x *= s
    return x


a212 3
        if type.size <= 32 \
            and isinstance(value, (int, long)):
            return truncate_mantissa(value, 23)
d229 1
a229 1
            return "%.1ff" % float(value)
d231 1
a231 1
            return "%.1f" % float(value)
d254 2
a255 2
    dst_min_native = native_to_constant(src_channel, value_to_native(src_channel, dst_min))
    dst_max_native = native_to_constant(src_channel, value_to_native(src_channel, dst_max))
d662 1
a662 1
    return format.layout in ('s3tc', 'rgtc', 'etc', 'bptc', 'subsampled', 'other') or format.colorspace == ZS
d672 1
a672 1
    print '#include "util/format_srgb.h"'
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d210 24
d237 3
d256 1
a256 1
            return "%ff" % value 
d258 1
a258 1
            return "%ff" % value 
d281 2
a282 2
    dst_min_native = value_to_native(src_channel, dst_min)
    dst_max_native = value_to_native(src_channel, dst_max)
d689 1
a689 1
    return format.layout in ('s3tc', 'rgtc', 'etc', 'subsampled', 'other') or format.colorspace == ZS
d699 1
a699 1
    print '#include "u_format_srgb.h"'
@


