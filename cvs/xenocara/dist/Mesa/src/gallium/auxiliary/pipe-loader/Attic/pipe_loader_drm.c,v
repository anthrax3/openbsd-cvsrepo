head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.27;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.09.33;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.09.33;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.33.41;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2014.09.07.15.00.32;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	dm8VnQHhowGHmemJ;

1.1.1.4
date	2015.01.25.14.06.04;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.12;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2011 Intel Corporation
 * Copyright 2012 Francisco Jerez
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Kristian HÃ¸gsberg <krh@@bitplanet.net>
 *    Benjamin Franzke <benjaminfranzke@@googlemail.com>
 *
 **************************************************************************/

#include <fcntl.h>
#include <stdio.h>
#include <libudev.h>
#include <xf86drm.h>

#ifdef HAVE_PIPE_LOADER_XCB

#include <xcb/dri2.h>

#endif

#include "state_tracker/drm_driver.h"
#include "pipe_loader_priv.h"

#include "util/u_memory.h"
#include "util/u_dl.h"
#include "util/u_debug.h"

#define DRIVER_MAP_GALLIUM_ONLY
#include "pci_ids/pci_id_driver_map.h"

struct pipe_loader_drm_device {
   struct pipe_loader_device base;
   struct util_dl_library *lib;
   int fd;
};

#define pipe_loader_drm_device(dev) ((struct pipe_loader_drm_device *)dev)

static boolean
find_drm_pci_id(struct pipe_loader_drm_device *ddev)
{
   struct udev *udev = NULL;
   struct udev_device *parent, *device = NULL;
   struct stat stat;
   const char *pci_id;

   if (fstat(ddev->fd, &stat) < 0)
      goto fail;

   udev = udev_new();
   if (!udev)
      goto fail;

   device = udev_device_new_from_devnum(udev, 'c', stat.st_rdev);
   if (!device)
      goto fail;

   parent = udev_device_get_parent(device);
   if (!parent)
      goto fail;

   pci_id = udev_device_get_property_value(parent, "PCI_ID");
   if (!pci_id ||
       sscanf(pci_id, "%x:%x", &ddev->base.u.pci.vendor_id,
              &ddev->base.u.pci.chip_id) != 2)
      goto fail;

   return TRUE;

  fail:
   if (device)
      udev_device_unref(device);
   if (udev)
      udev_unref(udev);

   return FALSE;
}

static boolean
find_drm_driver_name(struct pipe_loader_drm_device *ddev)
{
   struct pipe_loader_device *dev = &ddev->base;
   int i, j;

   for (i = 0; driver_map[i].driver; i++) {
      if (dev->u.pci.vendor_id != driver_map[i].vendor_id)
         continue;

      if (driver_map[i].num_chips_ids == -1) {
         dev->driver_name = driver_map[i].driver;
         goto found;
      }

      for (j = 0; j < driver_map[i].num_chips_ids; j++) {
         if (dev->u.pci.chip_id == driver_map[i].chip_ids[j]) {
            dev->driver_name = driver_map[i].driver;
            goto found;
         }
      }
   }

   return FALSE;

  found:
   return TRUE;
}

static struct pipe_loader_ops pipe_loader_drm_ops;

static void
pipe_loader_drm_x_auth(int fd)
{
#if HAVE_PIPE_LOADER_XCB
   /* Try authenticate with the X server to give us access to devices that X
    * is running on. */
   xcb_connection_t *xcb_conn;
   const xcb_setup_t *xcb_setup;
   xcb_screen_iterator_t s;
   xcb_dri2_connect_cookie_t connect_cookie;
   xcb_dri2_connect_reply_t *connect;
   drm_magic_t magic;
   xcb_dri2_authenticate_cookie_t authenticate_cookie;
   xcb_dri2_authenticate_reply_t *authenticate;

   xcb_conn = xcb_connect(NULL,  NULL);

   if(!xcb_conn)
      return;

   xcb_setup = xcb_get_setup(xcb_conn);

  if (!xcb_setup)
    goto disconnect;

   s = xcb_setup_roots_iterator(xcb_setup);
   connect_cookie = xcb_dri2_connect_unchecked(xcb_conn, s.data->root,
                                               XCB_DRI2_DRIVER_TYPE_DRI);
   connect = xcb_dri2_connect_reply(xcb_conn, connect_cookie, NULL);

   if (!connect || connect->driver_name_length
                   + connect->device_name_length == 0) {

      goto disconnect;
   }

   if (drmGetMagic(fd, &magic))
      goto disconnect;

   authenticate_cookie = xcb_dri2_authenticate_unchecked(xcb_conn,
                                                         s.data->root,
                                                         magic);
   authenticate = xcb_dri2_authenticate_reply(xcb_conn,
                                              authenticate_cookie,
                                              NULL);
   FREE(authenticate);

disconnect:
   xcb_disconnect(xcb_conn);

#endif
}

boolean
pipe_loader_drm_probe_fd(struct pipe_loader_device **dev, int fd)
{
   struct pipe_loader_drm_device *ddev = CALLOC_STRUCT(pipe_loader_drm_device);

   ddev->base.type = PIPE_LOADER_DEVICE_PCI;
   ddev->base.ops = &pipe_loader_drm_ops;
   ddev->fd = fd;

   pipe_loader_drm_x_auth(fd);

   if (!find_drm_pci_id(ddev))
      goto fail;

   if (!find_drm_driver_name(ddev))
      goto fail;

   *dev = &ddev->base;
   return TRUE;

  fail:
   FREE(ddev);
   return FALSE;
}

static int
open_drm_minor(int minor)
{
   char path[PATH_MAX];
   snprintf(path, sizeof(path), DRM_DEV_NAME, DRM_DIR_NAME, minor);
   return open(path, O_RDWR, 0);
}

int
pipe_loader_drm_probe(struct pipe_loader_device **devs, int ndev)
{
   int i, j, fd;

   for (i = 0, j = 0; i < DRM_MAX_MINOR; i++) {
      fd = open_drm_minor(i);
      if (fd < 0)
         continue;

      if (j >= ndev || !pipe_loader_drm_probe_fd(&devs[j], fd))
         close(fd);

      j++;
   }

   return j;
}

static void
pipe_loader_drm_release(struct pipe_loader_device **dev)
{
   struct pipe_loader_drm_device *ddev = pipe_loader_drm_device(*dev);

   if (ddev->lib)
      util_dl_close(ddev->lib);

   close(ddev->fd);
   FREE(ddev);
   *dev = NULL;
}

static struct pipe_screen *
pipe_loader_drm_create_screen(struct pipe_loader_device *dev,
                              const char *library_paths)
{
   struct pipe_loader_drm_device *ddev = pipe_loader_drm_device(dev);
   const struct drm_driver_descriptor *dd;

   if (!ddev->lib)
      ddev->lib = pipe_loader_find_module(dev, library_paths);
   if (!ddev->lib)
      return NULL;

   dd = (const struct drm_driver_descriptor *)
      util_dl_get_proc_address(ddev->lib, "driver_descriptor");

   /* sanity check on the name */
   if (!dd || strcmp(dd->name, ddev->base.driver_name) != 0)
      return NULL;

   return dd->create_screen(ddev->fd);
}

static struct pipe_loader_ops pipe_loader_drm_ops = {
   .create_screen = pipe_loader_drm_create_screen,
   .release = pipe_loader_drm_release
};
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d35 1
a43 1
#include "loader.h"
d51 2
a52 4
#define DRM_RENDER_NODE_DEV_NAME_FORMAT "%s/renderD%d"
#define DRM_RENDER_NODE_MAX_NODES 63
#define DRM_RENDER_NODE_MIN_MINOR 128
#define DRM_RENDER_NODE_MAX_MINOR (DRM_RENDER_NODE_MIN_MINOR + DRM_RENDER_NODE_MAX_NODES)
d62 69
d136 1
a136 1
#ifdef HAVE_PIPE_LOADER_XCB
d186 2
a187 3
bool
pipe_loader_drm_probe_fd(struct pipe_loader_device **dev, int fd,
                         boolean auth_x)
a189 4
   int vendor_id, chip_id;

   if (!ddev)
      return false;
d191 1
a191 7
   if (loader_get_pci_id_for_fd(fd, &vendor_id, &chip_id)) {
      ddev->base.type = PIPE_LOADER_DEVICE_PCI;
      ddev->base.u.pci.vendor_id = vendor_id;
      ddev->base.u.pci.chip_id = chip_id;
   } else {
      ddev->base.type = PIPE_LOADER_DEVICE_PLATFORM;
   }
d195 4
a198 2
   if (auth_x)
      pipe_loader_drm_x_auth(fd);
d200 1
a200 2
   ddev->base.driver_name = loader_get_driver_for_fd(fd, _LOADER_GALLIUM);
   if (!ddev->base.driver_name)
d204 1
a204 1
   return true;
d208 1
a208 1
   return false;
a218 9
static int
open_drm_render_node_minor(int minor)
{
   char path[PATH_MAX];
   snprintf(path, sizeof(path), DRM_RENDER_NODE_DEV_NAME_FORMAT, DRM_DIR_NAME,
            minor);
   return open(path, O_RDWR, 0);
}

d222 1
a222 20
   int i, k, fd, num_render_node_devs;
   int j = 0;

   struct {
      unsigned vendor_id;
      unsigned chip_id;
   } render_node_devs[DRM_RENDER_NODE_MAX_NODES];

   /* Look for render nodes first */
   for (i = DRM_RENDER_NODE_MIN_MINOR, j = 0;
        i <= DRM_RENDER_NODE_MAX_MINOR; i++) {
      fd = open_drm_render_node_minor(i);
      struct pipe_loader_device *dev;
      if (fd < 0)
         continue;

      if (!pipe_loader_drm_probe_fd(&dev, fd, false)) {
         close(fd);
         continue;
      }
d224 1
a224 18
      render_node_devs[j].vendor_id = dev->u.pci.vendor_id;
      render_node_devs[j].chip_id = dev->u.pci.chip_id;

      if (j < ndev) {
         devs[j] = dev;
      } else {
         close(fd);
         dev->ops->release(&dev);
      }
      j++;
   }

   num_render_node_devs = j;

   /* Next look for drm devices. */
   for (i = 0; i < DRM_MAX_MINOR; i++) {
      struct pipe_loader_device *dev;
      boolean duplicate = FALSE;
d229 1
a229 1
      if (!pipe_loader_drm_probe_fd(&dev, fd, true)) {
a230 24
         continue;
      }

      /* Check to make sure we aren't already accessing this device via
       * render nodes.
       */
      for (k = 0; k < num_render_node_devs; k++) {
         if (dev->u.pci.vendor_id == render_node_devs[k].vendor_id &&
             dev->u.pci.chip_id == render_node_devs[k].chip_id) {
            close(fd);
            dev->ops->release(&dev);
            duplicate = TRUE;
            break;
         }
      }

      if (duplicate)
         continue;

      if (j < ndev) {
         devs[j] = dev;
      } else {
         dev->ops->release(&dev);
      }
@


1.1.1.3
log
@Import Mesa 10.2.7
@
text
@a258 1
   FREE(ddev->base.driver_name);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a35 1
#include <unistd.h>
a65 14
#ifdef HAVE_PIPE_LOADER_XCB

static xcb_screen_t *
get_xcb_screen(xcb_screen_iterator_t iter, int screen)
{
    for (; iter.rem; --screen, xcb_screen_next(&iter))
        if (screen == 0)
            return iter.data;

    return NULL;
}

#endif

a79 1
   int screen;
d81 1
a81 1
   xcb_conn = xcb_connect(NULL, &screen);
d92 1
a92 2
   connect_cookie = xcb_dri2_connect_unchecked(xcb_conn,
                                               get_xcb_screen(s, screen)->root,
a263 23
static const struct drm_conf_ret *
pipe_loader_drm_configuration(struct pipe_loader_device *dev,
                              enum drm_conf conf)
{
   struct pipe_loader_drm_device *ddev = pipe_loader_drm_device(dev);
   const struct drm_driver_descriptor *dd;

   if (!ddev->lib)
      return NULL;

   dd = (const struct drm_driver_descriptor *)
      util_dl_get_proc_address(ddev->lib, "driver_descriptor");

   /* sanity check on the name */
   if (!dd || strcmp(dd->name, ddev->base.driver_name) != 0)
      return NULL;

   if (!dd->configuration)
      return NULL;

   return dd->configuration(conf);
}

a287 1
   .configuration = pipe_loader_drm_configuration,
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d36 1
d67 14
d95 1
d97 1
a97 1
   xcb_conn = xcb_connect(NULL,  NULL);
d108 2
a109 1
   connect_cookie = xcb_dri2_connect_unchecked(xcb_conn, s.data->root,
d281 23
d328 1
@


