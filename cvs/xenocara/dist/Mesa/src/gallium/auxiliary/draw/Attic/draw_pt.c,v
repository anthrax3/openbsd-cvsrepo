head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.31;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.42;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.42;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */

#include "draw/draw_context.h"
#include "draw/draw_gs.h"
#include "draw/draw_private.h"
#include "draw/draw_pt.h"
#include "draw/draw_vbuf.h"
#include "draw/draw_vs.h"
#include "tgsi/tgsi_dump.h"
#include "util/u_math.h"
#include "util/u_prim.h"
#include "util/u_format.h"
#include "util/u_draw.h"


DEBUG_GET_ONCE_BOOL_OPTION(draw_fse, "DRAW_FSE", FALSE)
DEBUG_GET_ONCE_BOOL_OPTION(draw_no_fse, "DRAW_NO_FSE", FALSE)

/* Overall we split things into:
 *     - frontend -- prepare fetch_elts, draw_elts - eg vsplit
 *     - middle   -- fetch, shade, cliptest, viewport
 *     - pipeline -- the prim pipeline: clipping, wide lines, etc 
 *     - backend  -- the vbuf_render provided by the driver.
 */
static boolean
draw_pt_arrays(struct draw_context *draw,
               unsigned prim,
               unsigned start, 
               unsigned count)
{
   struct draw_pt_front_end *frontend = NULL;
   struct draw_pt_middle_end *middle = NULL;
   unsigned opt = 0;

   /* Sanitize primitive length:
    */
   {
      unsigned first, incr;
      draw_pt_split_prim(prim, &first, &incr);
      count = draw_pt_trim_count(count, first, incr);
      if (count < first)
         return TRUE;
   }

   if (!draw->force_passthrough) {
      unsigned gs_out_prim = (draw->gs.geometry_shader ? 
                              draw->gs.geometry_shader->output_primitive :
                              prim);

      if (!draw->render) {
         opt |= PT_PIPELINE;
      }

      if (draw_need_pipeline(draw,
                             draw->rasterizer,
                             gs_out_prim)) {
         opt |= PT_PIPELINE;
      }

      if ((draw->clip_xy ||
           draw->clip_z ||
           draw->clip_user) && !draw->pt.test_fse) {
         opt |= PT_CLIPTEST;
      }

      opt |= PT_SHADE;
   }

   if (draw->pt.middle.llvm) {
      middle = draw->pt.middle.llvm;
   } else {
      if (opt == 0)
         middle = draw->pt.middle.fetch_emit;
      else if (opt == PT_SHADE && !draw->pt.no_fse)
         middle = draw->pt.middle.fetch_shade_emit;
      else
         middle = draw->pt.middle.general;
   }

   frontend = draw->pt.frontend;

   if (frontend ) {
      if (draw->pt.prim != prim || draw->pt.opt != opt) {
         /* In certain conditions switching primitives requires us to flush
          * and validate the different stages. One example is when smooth
          * lines are active but first drawn with triangles and then with
          * lines.
          */
         draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
         frontend = NULL;
      } else if (draw->pt.eltSize != draw->pt.user.eltSize) {
         /* Flush draw state if eltSize changed.
          * This could be improved so only the frontend is flushed since it
          * converts all indices to ushorts and the fetch part of the middle
          * always prepares both linear and indexed.
          */
         frontend->flush( frontend, DRAW_FLUSH_STATE_CHANGE );
         frontend = NULL;
      }
   }

   if (!frontend) {
      frontend = draw->pt.front.vsplit;

      frontend->prepare( frontend, prim, middle, opt );

      draw->pt.frontend = frontend;
      draw->pt.eltSize = draw->pt.user.eltSize;
      draw->pt.prim = prim;
      draw->pt.opt = opt;
   }

   if (draw->pt.rebind_parameters) {
      /* update constants, viewport dims, clip planes, etc */
      middle->bind_parameters(middle);
      draw->pt.rebind_parameters = FALSE;
   }

   frontend->run( frontend, start, count );

   return TRUE;
}

void draw_pt_flush( struct draw_context *draw, unsigned flags )
{
   assert(flags);

   if (draw->pt.frontend) {
      draw->pt.frontend->flush( draw->pt.frontend, flags );

      /* don't prepare if we only are flushing the backend */
      if (flags & DRAW_FLUSH_STATE_CHANGE)
         draw->pt.frontend = NULL;
   }

   if (flags & DRAW_FLUSH_PARAMETER_CHANGE) {
      draw->pt.rebind_parameters = TRUE;
   }
}



boolean draw_pt_init( struct draw_context *draw )
{
   draw->pt.test_fse = debug_get_option_draw_fse();
   draw->pt.no_fse = debug_get_option_draw_no_fse();

   draw->pt.front.vsplit = draw_pt_vsplit(draw);
   if (!draw->pt.front.vsplit)
      return FALSE;

   draw->pt.middle.fetch_emit = draw_pt_fetch_emit( draw );
   if (!draw->pt.middle.fetch_emit)
      return FALSE;

   draw->pt.middle.fetch_shade_emit = draw_pt_middle_fse( draw );
   if (!draw->pt.middle.fetch_shade_emit)
      return FALSE;

   draw->pt.middle.general = draw_pt_fetch_pipeline_or_emit( draw );
   if (!draw->pt.middle.general)
      return FALSE;

#if HAVE_LLVM
   if (draw->llvm)
      draw->pt.middle.llvm = draw_pt_fetch_pipeline_or_emit_llvm( draw );
#endif

   return TRUE;
}


void draw_pt_destroy( struct draw_context *draw )
{
   if (draw->pt.middle.llvm) {
      draw->pt.middle.llvm->destroy( draw->pt.middle.llvm );
      draw->pt.middle.llvm = NULL;
   }

   if (draw->pt.middle.general) {
      draw->pt.middle.general->destroy( draw->pt.middle.general );
      draw->pt.middle.general = NULL;
   }

   if (draw->pt.middle.fetch_emit) {
      draw->pt.middle.fetch_emit->destroy( draw->pt.middle.fetch_emit );
      draw->pt.middle.fetch_emit = NULL;
   }

   if (draw->pt.middle.fetch_shade_emit) {
      draw->pt.middle.fetch_shade_emit->destroy( draw->pt.middle.fetch_shade_emit );
      draw->pt.middle.fetch_shade_emit = NULL;
   }

   if (draw->pt.front.vsplit) {
      draw->pt.front.vsplit->destroy( draw->pt.front.vsplit );
      draw->pt.front.vsplit = NULL;
   }
}


/**
 * Debug- print the first 'count' vertices.
 */
static void
draw_print_arrays(struct draw_context *draw, uint prim, int start, uint count)
{
   uint i;

   debug_printf("Draw arrays(prim = %u, start = %u, count = %u)\n",
                prim, start, count);

   for (i = 0; i < count; i++) {
      uint ii = 0;
      uint j;

      if (draw->pt.user.eltSize) {
         /* indexed arrays */

         switch (draw->pt.user.eltSize) {
         case 1:
            {
               const ubyte *elem = (const ubyte *) draw->pt.user.elts;
               ii = elem[start + i];
            }
            break;
         case 2:
            {
               const ushort *elem = (const ushort *) draw->pt.user.elts;
               ii = elem[start + i];
            }
            break;
         case 4:
            {
               const uint *elem = (const uint *) draw->pt.user.elts;
               ii = elem[start + i];
            }
            break;
         default:
            assert(0);
            return;
         }
         ii += draw->pt.user.eltBias;
         debug_printf("Element[%u + %u] + %i -> Vertex %u:\n", start, i,
                      draw->pt.user.eltBias, ii);
      }
      else {
         /* non-indexed arrays */
         ii = start + i;
         debug_printf("Vertex %u:\n", ii);
      }

      for (j = 0; j < draw->pt.nr_vertex_elements; j++) {
         uint buf = draw->pt.vertex_element[j].vertex_buffer_index;
         ubyte *ptr = (ubyte *) draw->pt.user.vbuffer[buf].map;

         if (draw->pt.vertex_element[j].instance_divisor) {
            ii = draw->instance_id / draw->pt.vertex_element[j].instance_divisor;
         }

         ptr += draw->pt.vertex_buffer[buf].buffer_offset;
         ptr += draw->pt.vertex_buffer[buf].stride * ii;
         ptr += draw->pt.vertex_element[j].src_offset;

         debug_printf("  Attr %u: ", j);
         switch (draw->pt.vertex_element[j].src_format) {
         case PIPE_FORMAT_R32_FLOAT:
            {
               float *v = (float *) ptr;
               debug_printf("R %f  @@ %p\n", v[0], (void *) v);
            }
            break;
         case PIPE_FORMAT_R32G32_FLOAT:
            {
               float *v = (float *) ptr;
               debug_printf("RG %f %f  @@ %p\n", v[0], v[1], (void *) v);
            }
            break;
         case PIPE_FORMAT_R32G32B32_FLOAT:
            {
               float *v = (float *) ptr;
               debug_printf("RGB %f %f %f  @@ %p\n", v[0], v[1], v[2], (void *) v);
            }
            break;
         case PIPE_FORMAT_R32G32B32A32_FLOAT:
            {
               float *v = (float *) ptr;
               debug_printf("RGBA %f %f %f %f  @@ %p\n", v[0], v[1], v[2], v[3],
                            (void *) v);
            }
            break;
         case PIPE_FORMAT_B8G8R8A8_UNORM:
            {
               ubyte *u = (ubyte *) ptr;
               debug_printf("BGRA %d %d %d %d  @@ %p\n", u[0], u[1], u[2], u[3],
                            (void *) u);
            }
            break;
         case PIPE_FORMAT_A8R8G8B8_UNORM:
            {
               ubyte *u = (ubyte *) ptr;
               debug_printf("ARGB %d %d %d %d  @@ %p\n", u[0], u[1], u[2], u[3],
                            (void *) u);
            }
            break;
         default:
            debug_printf("other format %s (fix me)\n",
                     util_format_name(draw->pt.vertex_element[j].src_format));
         }
      }
   }
}


/** Helper code for below */
#define PRIM_RESTART_LOOP(elements) \
   do { \
      for (j = 0; j < count; j++) {               \
         i = draw_overflow_uadd(start, j, MAX_LOOP_IDX);  \
         if (i < elt_max && elements[i] == info->restart_index) { \
            if (cur_count > 0) { \
               /* draw elts up to prev pos */ \
               draw_pt_arrays(draw, prim, cur_start, cur_count); \
            } \
            /* begin new prim at next elt */ \
            cur_start = i + 1; \
            cur_count = 0; \
         } \
         else { \
            cur_count++; \
         } \
      } \
      if (cur_count > 0) { \
         draw_pt_arrays(draw, prim, cur_start, cur_count); \
      } \
   } while (0)


/**
 * For drawing prims with primitive restart enabled.
 * Scan for restart indexes and draw the runs of elements/vertices between
 * the restarts.
 */
static void
draw_pt_arrays_restart(struct draw_context *draw,
                       const struct pipe_draw_info *info)
{
   const unsigned prim = info->mode;
   const unsigned start = info->start;
   const unsigned count = info->count;
   const unsigned elt_max = draw->pt.user.eltMax;
   unsigned i, j, cur_start, cur_count;
   /* The largest index within a loop using the i variable as the index.
    * Used for overflow detection */
   const unsigned MAX_LOOP_IDX = 0xffffffff;

   assert(info->primitive_restart);

   if (draw->pt.user.eltSize) {
      /* indexed prims (draw_elements) */
      cur_start = start;
      cur_count = 0;

      switch (draw->pt.user.eltSize) {
      case 1:
         {
            const ubyte *elt_ub = (const ubyte *) draw->pt.user.elts;
            PRIM_RESTART_LOOP(elt_ub);
         }
         break;
      case 2:
         {
            const ushort *elt_us = (const ushort *) draw->pt.user.elts;
            PRIM_RESTART_LOOP(elt_us);
         }
         break;
      case 4:
         {
            const uint *elt_ui = (const uint *) draw->pt.user.elts;
            PRIM_RESTART_LOOP(elt_ui);
         }
         break;
      default:
         assert(0 && "bad eltSize in draw_arrays()");
      }
   }
   else {
      /* Non-indexed prims (draw_arrays).
       * Primitive restart should have been handled in the state tracker.
       */
      draw_pt_arrays(draw, prim, start, count);
   }
}


/**
 * Resolve true values within pipe_draw_info.
 * If we're rendering from transform feedback/stream output
 * buffers both the count and max_index need to be computed
 * from the attached stream output target. 
 */
static void
resolve_draw_info(const struct pipe_draw_info *raw_info,
                  struct pipe_draw_info *info,
                  struct pipe_vertex_buffer *vertex_buffer)
{
   memcpy(info, raw_info, sizeof(struct pipe_draw_info));

   if (raw_info->count_from_stream_output) {
      struct draw_so_target *target =
         (struct draw_so_target *)info->count_from_stream_output;
      assert(vertex_buffer != NULL);
      info->count = target->internal_offset / vertex_buffer->stride;

      /* Stream output draw can not be indexed */
      debug_assert(!info->indexed);
      info->max_index = info->count - 1;
   }
}

/**
 * Draw vertex arrays.
 * This is the main entrypoint into the drawing module.  If drawing an indexed
 * primitive, the draw_set_indexes() function should have already been called
 * to specify the element/index buffer information.
 */
void
draw_vbo(struct draw_context *draw,
         const struct pipe_draw_info *info)
{
   unsigned instance;
   unsigned index_limit;
   unsigned count;
   unsigned fpstate = util_fpstate_get();
   struct pipe_draw_info resolved_info;

   /* Make sure that denorms are treated like zeros. This is 
    * the behavior required by D3D10. OpenGL doesn't care.
    */
   util_fpstate_set_denorms_to_zero(fpstate);

   resolve_draw_info(info, &resolved_info, &(draw->pt.vertex_buffer[0]));
   info = &resolved_info;

   assert(info->instance_count > 0);
   if (info->indexed)
      assert(draw->pt.user.elts);

   count = info->count;

   draw->pt.user.eltBias = info->index_bias;
   draw->pt.user.min_index = info->min_index;
   draw->pt.user.max_index = info->max_index;
   draw->pt.user.eltSize = info->indexed ? draw->pt.user.eltSizeIB : 0;

   if (0)
      debug_printf("draw_vbo(mode=%u start=%u count=%u):\n",
                   info->mode, info->start, count);

   if (0)
      tgsi_dump(draw->vs.vertex_shader->state.tokens, 0);

   if (0) {
      unsigned int i;
      debug_printf("Elements:\n");
      for (i = 0; i < draw->pt.nr_vertex_elements; i++) {
         debug_printf("  %u: src_offset=%u  inst_div=%u   vbuf=%u  format=%s\n",
                      i,
                      draw->pt.vertex_element[i].src_offset,
                      draw->pt.vertex_element[i].instance_divisor,
                      draw->pt.vertex_element[i].vertex_buffer_index,
                      util_format_name(draw->pt.vertex_element[i].src_format));
      }
      debug_printf("Buffers:\n");
      for (i = 0; i < draw->pt.nr_vertex_buffers; i++) {
         debug_printf("  %u: stride=%u offset=%u size=%d ptr=%p\n",
                      i,
                      draw->pt.vertex_buffer[i].stride,
                      draw->pt.vertex_buffer[i].buffer_offset,
                      (int) draw->pt.user.vbuffer[i].size,
                      draw->pt.user.vbuffer[i].map);
      }
   }

   if (0)
      draw_print_arrays(draw, info->mode, info->start, MIN2(count, 20));

   index_limit = util_draw_max_index(draw->pt.vertex_buffer,
                                     draw->pt.vertex_element,
                                     draw->pt.nr_vertex_elements,
                                     info);
#if HAVE_LLVM
   if (!draw->llvm)
#endif
   {
      if (index_limit == 0) {
      /* one of the buffers is too small to do any valid drawing */
         debug_warning("draw: VBO too small to draw anything\n");
         util_fpstate_set(fpstate);
         return;
      }
   }

   /* If we're collecting stats then make sure we start from scratch */
   if (draw->collect_statistics) {
      memset(&draw->statistics, 0, sizeof(draw->statistics));
   }

   draw->pt.max_index = index_limit - 1;
   draw->start_index = info->start;

   /*
    * TODO: We could use draw->pt.max_index to further narrow
    * the min_index/max_index hints given by the state tracker.
    */

   for (instance = 0; instance < info->instance_count; instance++) {
      unsigned instance_idx = instance + info->start_instance;
      draw->start_instance = info->start_instance;
      draw->instance_id = instance;
      /* check for overflow */
      if (instance_idx < instance ||
          instance_idx < draw->start_instance) {
         /* if we overflown just set the instance id to the max */
         draw->instance_id = 0xffffffff;
      }

      draw_new_instance(draw);

      if (info->primitive_restart) {
         draw_pt_arrays_restart(draw, info);
      }
      else {
         draw_pt_arrays(draw, info->mode, info->start, count);
      }
   }

   /* If requested emit the pipeline statistics for this run */
   if (draw->collect_statistics) {
      draw->render->pipeline_statistics(draw->render, &draw->statistics);
   }
   util_fpstate_set(fpstate);
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d434 2
a435 1
                  struct pipe_draw_info *info)
d442 2
a443 1
      info->count = target->emitted_vertices;
d472 1
a472 1
   resolve_draw_info(info, &resolved_info);
d540 1
d548 1
a548 1
      draw->instance_id = instance + info->start_instance;
d550 1
d552 2
a553 2
      if (draw->instance_id < instance ||
          draw->instance_id < info->start_instance) {
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d37 1
d56 1
a56 1
draw_pt_arrays(struct draw_context *draw, 
d110 1
a110 1
   frontend = draw->pt.front.vsplit;
d112 19
a130 1
   frontend->prepare( frontend, prim, middle, opt );
d132 16
a147 1
   frontend->run(frontend, start, count);
d149 1
a149 1
   frontend->finish( frontend );
d154 18
a247 2
         const char *elts;

a248 2
         elts = (const char *) draw->pt.user.elts;
         elts += draw->pt.index_buffer.offset;
d253 1
a253 1
               const ubyte *elem = (const ubyte *) elts;
d259 1
a259 1
               const ushort *elem = (const ushort *) elts;
d265 1
a265 1
               const uint *elem = (const uint *) elts;
d285 1
a285 1
         ubyte *ptr = (ubyte *) draw->pt.user.vbuffer[buf];
d329 7
d348 3
a350 2
      for (i = start; i < end; i++) { \
         if (elements[i] == info->restart_index) { \
d381 5
a385 2
   const unsigned end = start + count;
   unsigned i, cur_start, cur_count;
d389 1
a389 1
   if (draw->pt.user.elts) {
a425 1

d427 4
a430 2
 * Non-instanced drawing.
 * \sa draw_arrays_instanced
d432 3
a434 3
void
draw_arrays(struct draw_context *draw, unsigned prim,
            unsigned start, unsigned count)
d436 1
a436 2
   draw_arrays_instanced(draw, prim, start, count, 0, 1);
}
d438 8
a445 27

/**
 * Instanced drawing.
 * \sa draw_vbo
 */
void
draw_arrays_instanced(struct draw_context *draw,
                      unsigned mode,
                      unsigned start,
                      unsigned count,
                      unsigned startInstance,
                      unsigned instanceCount)
{
   struct pipe_draw_info info;

   util_draw_init_info(&info);

   info.mode = mode;
   info.start = start;
   info.count = count;
   info.start_instance = startInstance;
   info.instance_count = instanceCount;

   info.indexed = (draw->pt.user.elts != NULL);
   if (!info.indexed) {
      info.min_index = start;
      info.max_index = start + count - 1;
a446 2

   draw_vbo(draw, &info);
a448 1

d452 2
a453 3
 * primitive, the draw_set_index_buffer() and draw_set_mapped_index_buffer()
 * functions should have already been called to specify the element/index
 * buffer information.
a458 1
   unsigned reduced_prim = u_reduced_prim(info->mode);
d460 12
d477 1
a477 2
   draw->pt.user.eltSize =
      (info->indexed) ? draw->pt.index_buffer.index_size : 0;
d482 1
a482 5

   if (reduced_prim != draw->reduced_prim) {
      draw_do_flush(draw, DRAW_FLUSH_STATE_CHANGE);
      draw->reduced_prim = reduced_prim;
   }
d486 1
a486 1
                   info->mode, info->start, info->count);
d504 1
a504 1
         debug_printf("  %u: stride=%u offset=%u ptr=%p\n",
d508 2
a509 1
                      draw->pt.user.vbuffer[i]);
d514 1
a514 1
      draw_print_arrays(draw, info->mode, info->start, MIN2(info->count, 20));
d516 22
a537 5
   draw->pt.max_index = util_draw_max_index(draw->pt.vertex_buffer,
                                            draw->pt.nr_vertex_buffers,
                                            draw->pt.vertex_element,
                                            draw->pt.nr_vertex_elements,
                                            info);
d546 9
d560 1
a560 1
         draw_pt_arrays(draw, info->mode, info->start, info->count);
d563 6
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d462 1
a462 1
         debug_printf("  %u: stride=%u maxindex=%u offset=%u ptr=%p\n",
a464 1
                      draw->pt.vertex_buffer[i].max_index,
d472 11
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 1
d37 1
d41 2
a42 7

static unsigned trim( unsigned count, unsigned first, unsigned incr )
{
   if (count < first)
      return 0;
   return count - (count - first) % incr; 
}
d45 2
d49 1
a49 1
 *     - frontend -- prepare fetch_elts, draw_elts - eg vcache
d69 1
a69 1
      count = trim(count, first, incr); 
d75 4
d82 1
a82 1
      
d85 1
a85 1
                             prim)) {
d89 3
a91 1
      if (!draw->bypass_clipping && !draw->pt.test_fse) {
d94 1
a94 1
      
a96 8
      
   if (opt == 0) 
      middle = draw->pt.middle.fetch_emit;
   else if (opt == PT_SHADE && !draw->pt.no_fse)
      middle = draw->pt.middle.fetch_shade_emit;
   else
      middle = draw->pt.middle.general;

d98 2
a99 4
   /* Pick the right frontend
    */
   if (draw->pt.user.elts || (opt & PT_PIPELINE)) {
      frontend = draw->pt.front.vcache;
d101 6
a106 1
      frontend = draw->pt.front.varray;
d109 2
d113 1
a113 4
   frontend->run(frontend, 
                 draw_pt_elt_func(draw),
                 draw_pt_elt_ptr(draw, start),
                 count);
d123 2
a124 2
   draw->pt.test_fse = debug_get_bool_option("DRAW_FSE", FALSE);
   draw->pt.no_fse = debug_get_bool_option("DRAW_NO_FSE", FALSE);
d126 2
a127 6
   draw->pt.front.vcache = draw_pt_vcache( draw );
   if (!draw->pt.front.vcache)
      return FALSE;

   draw->pt.front.varray = draw_pt_varray(draw);
   if (!draw->pt.front.varray)
d142 5
d153 5
d173 3
a175 8
   if (draw->pt.front.vcache) {
      draw->pt.front.vcache->destroy( draw->pt.front.vcache );
      draw->pt.front.vcache = NULL;
   }

   if (draw->pt.front.varray) {
      draw->pt.front.varray->destroy( draw->pt.front.varray );
      draw->pt.front.varray = NULL;
d195 3
a197 1
      if (draw->pt.user.elts) {
d199 3
d205 1
a205 1
               const ubyte *elem = (const ubyte *) draw->pt.user.elts;
d211 1
a211 1
               const ushort *elem = (const ushort *) draw->pt.user.elts;
d217 1
a217 1
               const uint *elem = (const uint *) draw->pt.user.elts;
d223 1
d225 3
a227 1
         debug_printf("Element[%u + %u] -> Vertex %u:\n", start, i, ii);
d238 6
d252 1
a252 1
               debug_printf("%f  @@ %p\n", v[0], (void *) v);
d258 1
a258 1
               debug_printf("%f %f  @@ %p\n", v[0], v[1], (void *) v);
d264 1
a264 1
               debug_printf("%f %f %f  @@ %p\n", v[0], v[1], v[2], (void *) v);
d270 1
a270 1
               debug_printf("%f %f %f %f  @@ %p\n", v[0], v[1], v[2], v[3],
d274 7
d282 2
a283 2
            debug_printf("other format (fix me)\n");
            ;
d290 23
d314 57
a370 5
 * Draw vertex arrays
 * This is the main entrypoint into the drawing module.
 * \param prim  one of PIPE_PRIM_x
 * \param start  index of first vertex to draw
 * \param count  number of vertices to draw
d379 5
d392 32
a423 1
   unsigned reduced_prim = u_reduced_prim(mode);
d426 11
d443 2
a444 1
      draw_print_arrays(draw, mode, start, MIN2(count, 20));
d446 1
a446 5
#if 0
   {
      int i;
      debug_printf("draw_arrays(mode=%u start=%u count=%u):\n",
                   mode, start, count);
d448 3
d453 6
a458 3
         debug_printf("  format=%s comps=%u\n",
                      util_format_name(draw->pt.vertex_element[i].src_format),
                      draw->pt.vertex_element[i].nr_components);
d462 2
a463 1
         debug_printf("  stride=%u offset=%u ptr=%p\n",
d465 1
a469 1
#endif
d471 12
a482 3
   for (instance = 0; instance < instanceCount; instance++) {
      draw->instance_id = instance + startInstance;
      draw_pt_arrays(draw, mode, start, count);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a33 1
#include "draw/draw_gs.h"
a35 1
#include "draw/draw_vs.h"
d39 7
a45 2
#include "util/u_format.h"
#include "util/u_draw.h"
a47 2
DEBUG_GET_ONCE_BOOL_OPTION(draw_fse, "DRAW_FSE", FALSE)
DEBUG_GET_ONCE_BOOL_OPTION(draw_no_fse, "DRAW_NO_FSE", FALSE)
d50 1
a50 1
 *     - frontend -- prepare fetch_elts, draw_elts - eg vsplit
d70 1
a70 1
      count = draw_pt_trim_count(count, first, incr);
a75 4
      unsigned gs_out_prim = (draw->gs.geometry_shader ? 
                              draw->gs.geometry_shader->output_primitive :
                              prim);

d79 1
a79 1

d82 1
a82 1
                             gs_out_prim)) {
d86 1
a86 3
      if ((draw->clip_xy ||
           draw->clip_z ||
           draw->clip_user) && !draw->pt.test_fse) {
d89 1
a89 1

d92 8
d101 4
a104 2
   if (draw->pt.middle.llvm) {
      middle = draw->pt.middle.llvm;
d106 1
a106 6
      if (opt == 0)
         middle = draw->pt.middle.fetch_emit;
      else if (opt == PT_SHADE && !draw->pt.no_fse)
         middle = draw->pt.middle.fetch_shade_emit;
      else
         middle = draw->pt.middle.general;
a108 2
   frontend = draw->pt.front.vsplit;

d111 4
a114 1
   frontend->run(frontend, start, count);
d124 2
a125 2
   draw->pt.test_fse = debug_get_option_draw_fse();
   draw->pt.no_fse = debug_get_option_draw_no_fse();
d127 6
a132 2
   draw->pt.front.vsplit = draw_pt_vsplit(draw);
   if (!draw->pt.front.vsplit)
a146 5
#if HAVE_LLVM
   if (draw->llvm)
      draw->pt.middle.llvm = draw_pt_fetch_pipeline_or_emit_llvm( draw );
#endif

a152 5
   if (draw->pt.middle.llvm) {
      draw->pt.middle.llvm->destroy( draw->pt.middle.llvm );
      draw->pt.middle.llvm = NULL;
   }

d168 8
a175 3
   if (draw->pt.front.vsplit) {
      draw->pt.front.vsplit->destroy( draw->pt.front.vsplit );
      draw->pt.front.vsplit = NULL;
d195 1
a195 3
      if (draw->pt.user.eltSize) {
         const char *elts;

a196 3
         elts = (const char *) draw->pt.user.elts;
         elts += draw->pt.index_buffer.offset;

d200 1
a200 1
               const ubyte *elem = (const ubyte *) elts;
d206 1
a206 1
               const ushort *elem = (const ushort *) elts;
d212 1
a212 1
               const uint *elem = (const uint *) elts;
a217 1
            return;
d219 1
a219 3
         ii += draw->pt.user.eltBias;
         debug_printf("Element[%u + %u] + %i -> Vertex %u:\n", start, i,
                      draw->pt.user.eltBias, ii);
a229 6

         if (draw->pt.vertex_element[j].instance_divisor) {
            ii = draw->instance_id / draw->pt.vertex_element[j].instance_divisor;
         }

         ptr += draw->pt.vertex_buffer[buf].buffer_offset;
d238 1
a238 1
               debug_printf("R %f  @@ %p\n", v[0], (void *) v);
d244 1
a244 1
               debug_printf("RG %f %f  @@ %p\n", v[0], v[1], (void *) v);
d250 1
a250 1
               debug_printf("RGB %f %f %f  @@ %p\n", v[0], v[1], v[2], (void *) v);
d256 1
a256 1
               debug_printf("RGBA %f %f %f %f  @@ %p\n", v[0], v[1], v[2], v[3],
a259 7
         case PIPE_FORMAT_B8G8R8A8_UNORM:
            {
               ubyte *u = (ubyte *) ptr;
               debug_printf("BGRA %d %d %d %d  @@ %p\n", u[0], u[1], u[2], u[3],
                            (void *) u);
            }
            break;
d261 2
a262 2
            debug_printf("other format %s (fix me)\n",
                     util_format_name(draw->pt.vertex_element[j].src_format));
a268 23
/** Helper code for below */
#define PRIM_RESTART_LOOP(elements) \
   do { \
      for (i = start; i < end; i++) { \
         if (elements[i] == info->restart_index) { \
            if (cur_count > 0) { \
               /* draw elts up to prev pos */ \
               draw_pt_arrays(draw, prim, cur_start, cur_count); \
            } \
            /* begin new prim at next elt */ \
            cur_start = i + 1; \
            cur_count = 0; \
         } \
         else { \
            cur_count++; \
         } \
      } \
      if (cur_count > 0) { \
         draw_pt_arrays(draw, prim, cur_start, cur_count); \
      } \
   } while (0)


d270 5
a274 57
 * For drawing prims with primitive restart enabled.
 * Scan for restart indexes and draw the runs of elements/vertices between
 * the restarts.
 */
static void
draw_pt_arrays_restart(struct draw_context *draw,
                       const struct pipe_draw_info *info)
{
   const unsigned prim = info->mode;
   const unsigned start = info->start;
   const unsigned count = info->count;
   const unsigned end = start + count;
   unsigned i, cur_start, cur_count;

   assert(info->primitive_restart);

   if (draw->pt.user.elts) {
      /* indexed prims (draw_elements) */
      cur_start = start;
      cur_count = 0;

      switch (draw->pt.user.eltSize) {
      case 1:
         {
            const ubyte *elt_ub = (const ubyte *) draw->pt.user.elts;
            PRIM_RESTART_LOOP(elt_ub);
         }
         break;
      case 2:
         {
            const ushort *elt_us = (const ushort *) draw->pt.user.elts;
            PRIM_RESTART_LOOP(elt_us);
         }
         break;
      case 4:
         {
            const uint *elt_ui = (const uint *) draw->pt.user.elts;
            PRIM_RESTART_LOOP(elt_ui);
         }
         break;
      default:
         assert(0 && "bad eltSize in draw_arrays()");
      }
   }
   else {
      /* Non-indexed prims (draw_arrays).
       * Primitive restart should have been handled in the state tracker.
       */
      draw_pt_arrays(draw, prim, start, count);
   }
}



/**
 * Non-instanced drawing.
 * \sa draw_arrays_instanced
a282 5

/**
 * Instanced drawing.
 * \sa draw_vbo
 */
d291 1
a291 32
   struct pipe_draw_info info;

   util_draw_init_info(&info);

   info.mode = mode;
   info.start = start;
   info.count = count;
   info.start_instance = startInstance;
   info.instance_count = instanceCount;

   info.indexed = (draw->pt.user.elts != NULL);
   if (!info.indexed) {
      info.min_index = start;
      info.max_index = start + count - 1;
   }

   draw_vbo(draw, &info);
}


/**
 * Draw vertex arrays.
 * This is the main entrypoint into the drawing module.  If drawing an indexed
 * primitive, the draw_set_index_buffer() and draw_set_mapped_index_buffer()
 * functions should have already been called to specify the element/index
 * buffer information.
 */
void
draw_vbo(struct draw_context *draw,
         const struct pipe_draw_info *info)
{
   unsigned reduced_prim = u_reduced_prim(info->mode);
a293 11
   assert(info->instance_count > 0);
   if (info->indexed)
      assert(draw->pt.user.elts);

   draw->pt.user.eltSize =
      (info->indexed) ? draw->pt.index_buffer.index_size : 0;

   draw->pt.user.eltBias = info->index_bias;
   draw->pt.user.min_index = info->min_index;
   draw->pt.user.max_index = info->max_index;

d300 1
a300 2
      debug_printf("draw_vbo(mode=%u start=%u count=%u):\n",
                   info->mode, info->start, info->count);
d302 5
a306 1
   if (0)
a307 3

   if (0) {
      unsigned int i;
d310 3
a312 6
         debug_printf("  %u: src_offset=%u  inst_div=%u   vbuf=%u  format=%s\n",
                      i,
                      draw->pt.vertex_element[i].src_offset,
                      draw->pt.vertex_element[i].instance_divisor,
                      draw->pt.vertex_element[i].vertex_buffer_index,
                      util_format_name(draw->pt.vertex_element[i].src_format));
d316 1
a316 2
         debug_printf("  %u: stride=%u maxindex=%u offset=%u ptr=%p\n",
                      i,
a317 1
                      draw->pt.vertex_buffer[i].max_index,
d322 1
d324 3
a326 12
   if (0)
      draw_print_arrays(draw, info->mode, info->start, MIN2(info->count, 20));

   for (instance = 0; instance < info->instance_count; instance++) {
      draw->instance_id = instance + info->start_instance;

      if (info->primitive_restart) {
         draw_pt_arrays_restart(draw, info);
      }
      else {
         draw_pt_arrays(draw, info->mode, info->start, info->count);
      }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a36 1
#include "draw/draw_vbuf.h"
d55 1
a55 1
draw_pt_arrays(struct draw_context *draw,
d109 1
a109 1
   frontend = draw->pt.frontend;
d111 1
a111 19
   if (frontend ) {
      if (draw->pt.prim != prim || draw->pt.opt != opt) {
         /* In certain conditions switching primitives requires us to flush
          * and validate the different stages. One example is when smooth
          * lines are active but first drawn with triangles and then with
          * lines.
          */
         draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
         frontend = NULL;
      } else if (draw->pt.eltSize != draw->pt.user.eltSize) {
         /* Flush draw state if eltSize changed.
          * This could be improved so only the frontend is flushed since it
          * converts all indices to ushorts and the fetch part of the middle
          * always prepares both linear and indexed.
          */
         frontend->flush( frontend, DRAW_FLUSH_STATE_CHANGE );
         frontend = NULL;
      }
   }
d113 1
a113 16
   if (!frontend) {
      frontend = draw->pt.front.vsplit;

      frontend->prepare( frontend, prim, middle, opt );

      draw->pt.frontend = frontend;
      draw->pt.eltSize = draw->pt.user.eltSize;
      draw->pt.prim = prim;
      draw->pt.opt = opt;
   }

   if (draw->pt.rebind_parameters) {
      /* update constants, viewport dims, clip planes, etc */
      middle->bind_parameters(middle);
      draw->pt.rebind_parameters = FALSE;
   }
d115 1
a115 1
   frontend->run( frontend, start, count );
a119 18
void draw_pt_flush( struct draw_context *draw, unsigned flags )
{
   assert(flags);

   if (draw->pt.frontend) {
      draw->pt.frontend->flush( draw->pt.frontend, flags );

      /* don't prepare if we only are flushing the backend */
      if (flags & DRAW_FLUSH_STATE_CHANGE)
         draw->pt.frontend = NULL;
   }

   if (flags & DRAW_FLUSH_PARAMETER_CHANGE) {
      draw->pt.rebind_parameters = TRUE;
   }
}


d196 2
d199 2
d205 1
a205 1
               const ubyte *elem = (const ubyte *) draw->pt.user.elts;
d211 1
a211 1
               const ushort *elem = (const ushort *) draw->pt.user.elts;
d217 1
a217 1
               const uint *elem = (const uint *) draw->pt.user.elts;
d237 1
a237 1
         ubyte *ptr = (ubyte *) draw->pt.user.vbuffer[buf].map;
a280 7
         case PIPE_FORMAT_A8R8G8B8_UNORM:
            {
               ubyte *u = (ubyte *) ptr;
               debug_printf("ARGB %d %d %d %d  @@ %p\n", u[0], u[1], u[2], u[3],
                            (void *) u);
            }
            break;
d293 2
a294 3
      for (j = 0; j < count; j++) {               \
         i = draw_overflow_uadd(start, j, MAX_LOOP_IDX);  \
         if (i < elt_max && elements[i] == info->restart_index) { \
d325 2
a326 5
   const unsigned elt_max = draw->pt.user.eltMax;
   unsigned i, j, cur_start, cur_count;
   /* The largest index within a loop using the i variable as the index.
    * Used for overflow detection */
   const unsigned MAX_LOOP_IDX = 0xffffffff;
d330 1
a330 1
   if (draw->pt.user.eltSize) {
d367 13
d381 2
a382 4
 * Resolve true values within pipe_draw_info.
 * If we're rendering from transform feedback/stream output
 * buffers both the count and max_index need to be computed
 * from the attached stream output target. 
d384 7
a390 3
static void
resolve_draw_info(const struct pipe_draw_info *raw_info,
                  struct pipe_draw_info *info)
d392 9
a400 1
   memcpy(info, raw_info, sizeof(struct pipe_draw_info));
d402 4
a405 8
   if (raw_info->count_from_stream_output) {
      struct draw_so_target *target =
         (struct draw_so_target *)info->count_from_stream_output;
      info->count = target->emitted_vertices;

      /* Stream output draw can not be indexed */
      debug_assert(!info->indexed);
      info->max_index = info->count - 1;
d407 2
d411 1
d415 3
a417 2
 * primitive, the draw_set_indexes() function should have already been called
 * to specify the element/index buffer information.
d423 1
a424 12
   unsigned index_limit;
   unsigned count;
   unsigned fpstate = util_fpstate_get();
   struct pipe_draw_info resolved_info;

   /* Make sure that denorms are treated like zeros. This is 
    * the behavior required by D3D10. OpenGL doesn't care.
    */
   util_fpstate_set_denorms_to_zero(fpstate);

   resolve_draw_info(info, &resolved_info);
   info = &resolved_info;
d430 2
a431 1
   count = info->count;
d436 5
a440 1
   draw->pt.user.eltSize = info->indexed ? draw->pt.user.eltSizeIB : 0;
d444 1
a444 1
                   info->mode, info->start, count);
d462 1
a462 1
         debug_printf("  %u: stride=%u offset=%u size=%d ptr=%p\n",
d465 1
d467 1
a467 2
                      (int) draw->pt.user.vbuffer[i].size,
                      draw->pt.user.vbuffer[i].map);
d472 1
a472 29
      draw_print_arrays(draw, info->mode, info->start, MIN2(count, 20));

   index_limit = util_draw_max_index(draw->pt.vertex_buffer,
                                     draw->pt.vertex_element,
                                     draw->pt.nr_vertex_elements,
                                     info);
#if HAVE_LLVM
   if (!draw->llvm)
#endif
   {
      if (index_limit == 0) {
      /* one of the buffers is too small to do any valid drawing */
         debug_warning("draw: VBO too small to draw anything\n");
         util_fpstate_set(fpstate);
         return;
      }
   }

   /* If we're collecting stats then make sure we start from scratch */
   if (draw->collect_statistics) {
      memset(&draw->statistics, 0, sizeof(draw->statistics));
   }

   draw->pt.max_index = index_limit - 1;

   /*
    * TODO: We could use draw->pt.max_index to further narrow
    * the min_index/max_index hints given by the state tracker.
    */
a475 9
      draw->start_instance = info->start_instance;
      /* check for overflow */
      if (draw->instance_id < instance ||
          draw->instance_id < info->start_instance) {
         /* if we overflown just set the instance id to the max */
         draw->instance_id = 0xffffffff;
      }

      draw_new_instance(draw);
d481 1
a481 1
         draw_pt_arrays(draw, info->mode, info->start, count);
a483 6

   /* If requested emit the pipeline statistics for this run */
   if (draw->collect_statistics) {
      draw->render->pipeline_statistics(draw->render, &draw->statistics);
   }
   util_fpstate_set(fpstate);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keithw@@vmware.com>
d434 1
a434 2
                  struct pipe_draw_info *info,
                  struct pipe_vertex_buffer *vertex_buffer)
d441 1
a441 2
      assert(vertex_buffer != NULL);
      info->count = target->internal_offset / vertex_buffer->stride;
d470 1
a470 1
   resolve_draw_info(info, &resolved_info, &(draw->pt.vertex_buffer[0]));
a537 1
   draw->start_index = info->start;
d545 1
a545 1
      unsigned instance_idx = instance + info->start_instance;
a546 1
      draw->instance_id = instance;
d548 2
a549 2
      if (instance_idx < instance ||
          instance_idx < draw->start_instance) {
@


