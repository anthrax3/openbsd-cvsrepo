head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.30;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.41;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.42;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/* Authors:  Keith Whitwell <keithw@@vmware.com>
 */

#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_prim.h"
#include "pipe/p_defines.h"
#include "draw_private.h"
#include "draw_pipe.h"
#include "draw_context.h"
#include "draw_vbuf.h"


/**
 * Default version of a function to check if we need any special
 * pipeline stages, or whether prims/verts can go through untouched.
 * Don't test for bypass clipping or vs modes, this function is just
 * about the primitive pipeline stages.
 *
 * This can be overridden by the driver.
 */
boolean
draw_need_pipeline(const struct draw_context *draw,
                   const struct pipe_rasterizer_state *rasterizer,
                   unsigned int prim )
{
   unsigned reduced_prim = u_reduced_prim(prim);

   /* If the driver has overridden this, use that version: 
    */
   if (draw->render &&
       draw->render->need_pipeline) 
   {
      return draw->render->need_pipeline( draw->render,
                                          rasterizer,
                                          prim );
   }

   /* Don't have to worry about triangles turning into lines/points
    * and triggering the pipeline, because we have to trigger the
    * pipeline *anyway* if unfilled mode is active.
    */
   if (reduced_prim == PIPE_PRIM_LINES) {
      /* line stipple */
      if (rasterizer->line_stipple_enable && draw->pipeline.line_stipple)
         return TRUE;

      /* wide lines */
      if (roundf(rasterizer->line_width) > draw->pipeline.wide_line_threshold)
         return TRUE;

      /* AA lines */
      if (rasterizer->line_smooth && draw->pipeline.aaline)
         return TRUE;

      if (draw_current_shader_num_written_culldistances(draw))
         return TRUE;
   }
   else if (reduced_prim == PIPE_PRIM_POINTS) {
      /* large points */
      if (rasterizer->point_size > draw->pipeline.wide_point_threshold)
         return TRUE;

      /* sprite points */
      if (rasterizer->point_quad_rasterization
          && draw->pipeline.wide_point_sprites)
         return TRUE;

      /* AA points */
      if (rasterizer->point_smooth && draw->pipeline.aapoint)
         return TRUE;

      /* point sprites */
      if (rasterizer->sprite_coord_enable && draw->pipeline.point_sprite)
         return TRUE;
   }
   else if (reduced_prim == PIPE_PRIM_TRIANGLES) {
      /* polygon stipple */
      if (rasterizer->poly_stipple_enable && draw->pipeline.pstipple)
         return TRUE;

      /* unfilled polygons */
      if (rasterizer->fill_front != PIPE_POLYGON_MODE_FILL ||
          rasterizer->fill_back != PIPE_POLYGON_MODE_FILL)
         return TRUE;
      
      /* polygon offset */
      if (rasterizer->offset_point ||
          rasterizer->offset_line ||
          rasterizer->offset_tri)
         return TRUE;

      /* two-side lighting */
      if (rasterizer->light_twoside)
         return TRUE;

      if (draw_current_shader_num_written_culldistances(draw))
         return TRUE;
   }

   /* polygon cull - this is difficult - hardware can cull just fine
    * most of the time (though sometimes CULL_NEITHER is unsupported.
    * 
    * Generally this isn't a reason to require the pipeline, though.
    *
   if (rasterizer->cull_mode)
      return TRUE;
   */

   return FALSE;
}



/**
 * Rebuild the rendering pipeline.
 */
static struct draw_stage *validate_pipeline( struct draw_stage *stage )
{
   struct draw_context *draw = stage->draw;
   struct draw_stage *next = draw->pipeline.rasterize;
   boolean need_det = FALSE;
   boolean precalc_flat = FALSE;
   boolean wide_lines, wide_points;
   const struct pipe_rasterizer_state *rast = draw->rasterizer;

   /* Set the validate's next stage to the rasterize stage, so that it
    * can be found later if needed for flushing.
    */
   stage->next = next;

   /* drawing wide lines? */
   wide_lines = (roundf(rast->line_width) > draw->pipeline.wide_line_threshold
                 && !rast->line_smooth);

   /* drawing large/sprite points (but not AA points)? */
   if (rast->sprite_coord_enable && draw->pipeline.point_sprite)
      wide_points = TRUE;
   else if (rast->point_smooth && draw->pipeline.aapoint)
      wide_points = FALSE;
   else if (rast->point_size > draw->pipeline.wide_point_threshold)
      wide_points = TRUE;
   else if (rast->point_quad_rasterization && draw->pipeline.wide_point_sprites)
      wide_points = TRUE;
   else
      wide_points = FALSE;

   /*
    * NOTE: we build up the pipeline in end-to-start order.
    *
    * TODO: make the current primitive part of the state and build
    * shorter pipelines for lines & points.
    */

   if (rast->line_smooth && draw->pipeline.aaline) {
      draw->pipeline.aaline->next = next;
      next = draw->pipeline.aaline;
      precalc_flat = TRUE;
   }

   if (rast->point_smooth && draw->pipeline.aapoint) {
      draw->pipeline.aapoint->next = next;
      next = draw->pipeline.aapoint;
   }

   if (wide_lines) {
      draw->pipeline.wide_line->next = next;
      next = draw->pipeline.wide_line;
      precalc_flat = TRUE;
   }

   if (wide_points) {
      draw->pipeline.wide_point->next = next;
      next = draw->pipeline.wide_point;
   }

   if (rast->line_stipple_enable && draw->pipeline.line_stipple) {
      draw->pipeline.stipple->next = next;
      next = draw->pipeline.stipple;
      precalc_flat = TRUE;		/* only needed for lines really */
   }

   if (rast->poly_stipple_enable
       && draw->pipeline.pstipple) {
      draw->pipeline.pstipple->next = next;
      next = draw->pipeline.pstipple;
   }

   if (rast->fill_front != PIPE_POLYGON_MODE_FILL ||
       rast->fill_back != PIPE_POLYGON_MODE_FILL) {
      draw->pipeline.unfilled->next = next;
      next = draw->pipeline.unfilled;
      precalc_flat = TRUE;		/* only needed for triangles really */
      need_det = TRUE;
   }

   if (rast->flatshade && precalc_flat) {
      draw->pipeline.flatshade->next = next;
      next = draw->pipeline.flatshade;
   }
	 
   if (rast->offset_point ||
       rast->offset_line ||
       rast->offset_tri) {
      draw->pipeline.offset->next = next;
      next = draw->pipeline.offset;
      need_det = TRUE;
   }

   if (rast->light_twoside) {
      draw->pipeline.twoside->next = next;
      next = draw->pipeline.twoside;
      need_det = TRUE;
   }

   /* Always run the cull stage as we calculate determinant there
    * also.  
    *
    * This can actually be a win as culling out the triangles can lead
    * to less work emitting vertices, smaller vertex buffers, etc.
    * It's difficult to say whether this will be true in general.
    */
   if (need_det || rast->cull_face != PIPE_FACE_NONE ||
       draw_current_shader_num_written_culldistances(draw)) {
      draw->pipeline.cull->next = next;
      next = draw->pipeline.cull;
   }

   /* Clip stage
    */
   if (draw->clip_xy || draw->clip_z || draw->clip_user)
   {
      draw->pipeline.clip->next = next;
      next = draw->pipeline.clip;
   }

   draw->pipeline.first = next;

   if (0) {
      debug_printf("draw pipeline:\n");
      for (next = draw->pipeline.first; next ; next = next->next ) 
         debug_printf("   %s\n", next->name);
      debug_printf("\n");
   }
   
   return draw->pipeline.first;
}

static void validate_tri( struct draw_stage *stage, 
			  struct prim_header *header )
{
   struct draw_stage *pipeline = validate_pipeline( stage );
   pipeline->tri( pipeline, header );
}

static void validate_line( struct draw_stage *stage, 
			   struct prim_header *header )
{
   struct draw_stage *pipeline = validate_pipeline( stage );
   pipeline->line( pipeline, header );
}

static void validate_point( struct draw_stage *stage, 
			    struct prim_header *header )
{
   struct draw_stage *pipeline = validate_pipeline( stage );
   pipeline->point( pipeline, header );
}

static void validate_reset_stipple_counter( struct draw_stage *stage )
{
   struct draw_stage *pipeline = validate_pipeline( stage );
   pipeline->reset_stipple_counter( pipeline );
}

static void validate_flush( struct draw_stage *stage, 
			    unsigned flags )
{
   /* May need to pass a backend flush on to the rasterize stage.
    */
   if (stage->next)
      stage->next->flush( stage->next, flags );
}


static void validate_destroy( struct draw_stage *stage )
{
   FREE( stage );
}


/**
 * Create validate pipeline stage.
 */
struct draw_stage *draw_validate_stage( struct draw_context *draw )
{
   struct draw_stage *stage = CALLOC_STRUCT(draw_stage);
   if (stage == NULL)
      return NULL;

   stage->draw = draw;
   stage->name = "validate";
   stage->next = NULL;
   stage->point = validate_point;
   stage->line = validate_line;
   stage->tri = validate_tri;
   stage->flush = validate_flush;
   stage->reset_stipple_counter = validate_reset_stipple_counter;
   stage->destroy = validate_destroy;

   return stage;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d28 1
a28 1
/* Authors:  Keith Whitwell <keith@@tungstengraphics.com>
d33 1
a39 16
static boolean points( unsigned prim )
{
   return (prim == PIPE_PRIM_POINTS);
}

static boolean lines( unsigned prim )
{
   return (prim == PIPE_PRIM_LINES ||
           prim == PIPE_PRIM_LINE_STRIP ||
           prim == PIPE_PRIM_LINE_LOOP);
}

static boolean triangles( unsigned prim )
{
   return prim >= PIPE_PRIM_TRIANGLES;
}
d54 2
d70 1
a70 2
   if (lines(prim)) 
   {
d86 1
a86 3

   if (points(prim))
   {
d104 1
a104 4


   if (triangles(prim)) 
   {
a263 1
   
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d96 3
d142 3
d154 1
a154 1
    */
d204 1
d269 2
a270 1
   if (need_det || rast->cull_face != PIPE_FACE_NONE) {
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d32 1
d90 1
a90 1
      if (rasterizer->line_width > draw->pipeline.wide_line_threshold)
d173 1
a173 1
   wide_lines = (rast->line_width > draw->pipeline.wide_line_threshold
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d103 5
d125 2
a126 2
      if (rasterizer->fill_cw != PIPE_POLYGON_MODE_FILL ||
          rasterizer->fill_ccw != PIPE_POLYGON_MODE_FILL)
d130 3
a132 1
      if (rasterizer->offset_cw || rasterizer->offset_ccw)
d164 1
d172 2
a173 2
   wide_lines = (draw->rasterizer->line_width > draw->pipeline.wide_line_threshold
                 && !draw->rasterizer->line_smooth);
d175 2
a176 2
   /* drawing large points? */
   if (draw->rasterizer->sprite_coord_enable && draw->pipeline.point_sprite)
d178 1
a178 1
   else if (draw->rasterizer->point_smooth && draw->pipeline.aapoint)
d180 3
a182 1
   else if (draw->rasterizer->point_size > draw->pipeline.wide_point_threshold)
d194 1
a194 1
   if (draw->rasterizer->line_smooth && draw->pipeline.aaline) {
d199 1
a199 1
   if (draw->rasterizer->point_smooth && draw->pipeline.aapoint) {
d210 1
a210 1
   if (wide_points || draw->rasterizer->sprite_coord_enable) {
d215 1
a215 1
   if (draw->rasterizer->line_stipple_enable && draw->pipeline.line_stipple) {
d221 1
a221 1
   if (draw->rasterizer->poly_stipple_enable
d227 2
a228 2
   if (draw->rasterizer->fill_cw != PIPE_POLYGON_MODE_FILL ||
       draw->rasterizer->fill_ccw != PIPE_POLYGON_MODE_FILL) {
d235 1
a235 1
   if (draw->rasterizer->flatshade && precalc_flat) {
d240 3
a242 2
   if (draw->rasterizer->offset_cw ||
       draw->rasterizer->offset_ccw) {
d248 1
a248 1
   if (draw->rasterizer->light_twoside) {
d261 1
a261 1
   if (need_det || draw->rasterizer->cull_mode) {
d268 1
a268 1
   if (!draw->bypass_clipping)
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a102 5
      /* sprite points */
      if (rasterizer->point_quad_rasterization
          && draw->pipeline.wide_point_sprites)
         return TRUE;

d120 2
a121 2
      if (rasterizer->fill_front != PIPE_POLYGON_MODE_FILL ||
          rasterizer->fill_back != PIPE_POLYGON_MODE_FILL)
d125 1
a125 3
      if (rasterizer->offset_point ||
          rasterizer->offset_line ||
          rasterizer->offset_tri)
a156 1
   const struct pipe_rasterizer_state *rast = draw->rasterizer;
d164 2
a165 2
   wide_lines = (rast->line_width > draw->pipeline.wide_line_threshold
                 && !rast->line_smooth);
d167 2
a168 2
   /* drawing large/sprite points (but not AA points)? */
   if (rast->sprite_coord_enable && draw->pipeline.point_sprite)
d170 1
a170 1
   else if (rast->point_smooth && draw->pipeline.aapoint)
d172 1
a172 3
   else if (rast->point_size > draw->pipeline.wide_point_threshold)
      wide_points = TRUE;
   else if (rast->point_quad_rasterization && draw->pipeline.wide_point_sprites)
d184 1
a184 1
   if (rast->line_smooth && draw->pipeline.aaline) {
d189 1
a189 1
   if (rast->point_smooth && draw->pipeline.aapoint) {
d200 1
a200 1
   if (wide_points) {
d205 1
a205 1
   if (rast->line_stipple_enable && draw->pipeline.line_stipple) {
d211 1
a211 1
   if (rast->poly_stipple_enable
d217 2
a218 2
   if (rast->fill_front != PIPE_POLYGON_MODE_FILL ||
       rast->fill_back != PIPE_POLYGON_MODE_FILL) {
d225 1
a225 1
   if (rast->flatshade && precalc_flat) {
d230 2
a231 3
   if (rast->offset_point ||
       rast->offset_line ||
       rast->offset_tri) {
d237 1
a237 1
   if (rast->light_twoside) {
d250 1
a250 1
   if (need_det || rast->cull_face != PIPE_FACE_NONE) {
d257 1
a257 1
   if (draw->clip_xy || draw->clip_z || draw->clip_user)
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a31 1
#include "util/u_math.h"
d89 1
a89 1
      if (roundf(rasterizer->line_width) > draw->pipeline.wide_line_threshold)
a94 3

      if (draw_current_shader_num_written_culldistances(draw))
         return TRUE;
a137 3

      if (draw_current_shader_num_written_culldistances(draw))
         return TRUE;
d147 1
a147 1
   */
d172 1
a172 1
   wide_lines = (roundf(rast->line_width) > draw->pipeline.wide_line_threshold
a196 1
      precalc_flat = TRUE;
d261 1
a261 2
   if (need_det || rast->cull_face != PIPE_FACE_NONE ||
       draw_current_shader_num_written_culldistances(draw)) {
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d28 1
a28 1
/* Authors:  Keith Whitwell <keithw@@vmware.com>
a32 1
#include "util/u_prim.h"
d39 16
a68 2
   unsigned reduced_prim = u_reduced_prim(prim);

d83 2
a84 1
   if (reduced_prim == PIPE_PRIM_LINES) {
d100 3
a102 1
   else if (reduced_prim == PIPE_PRIM_POINTS) {
d120 4
a123 1
   else if (reduced_prim == PIPE_PRIM_TRIANGLES) {
d283 1
@


