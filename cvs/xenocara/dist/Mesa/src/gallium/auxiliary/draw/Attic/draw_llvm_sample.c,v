head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.29;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.41;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2010 VMware, Inc.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * Texture sampling code generation
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 */

#include "pipe/p_defines.h"
#include "pipe/p_shader_tokens.h"
#include "gallivm/lp_bld_const.h"
#include "gallivm/lp_bld_debug.h"
#include "gallivm/lp_bld_type.h"
#include "gallivm/lp_bld_sample.h"
#include "gallivm/lp_bld_tgsi.h"


#include "util/u_debug.h"
#include "util/u_memory.h"
#include "util/u_pointer.h"
#include "util/u_string.h"

#include "draw_llvm.h"


/**
 * This provides the bridge between the sampler state store in
 * lp_jit_context and lp_jit_texture and the sampler code
 * generator. It provides the texture layout information required by
 * the texture sampler code generator in terms of the state stored in
 * lp_jit_context and lp_jit_texture in runtime.
 */
struct draw_llvm_sampler_dynamic_state
{
   struct lp_sampler_dynamic_state base;

   const struct draw_sampler_static_state *static_state;

   LLVMValueRef context_ptr;
};


/**
 * This is the bridge between our sampler and the TGSI translator.
 */
struct draw_llvm_sampler_soa
{
   struct lp_build_sampler_soa base;

   struct draw_llvm_sampler_dynamic_state dynamic_state;
};


/**
 * Fetch the specified member of the lp_jit_texture structure.
 * \param emit_load  if TRUE, emit the LLVM load instruction to actually
 *                   fetch the field's value.  Otherwise, just emit the
 *                   GEP code to address the field.
 *
 * @@sa http://llvm.org/docs/GetElementPtr.html
 */
static LLVMValueRef
draw_llvm_texture_member(const struct lp_sampler_dynamic_state *base,
                         struct gallivm_state *gallivm,
                         unsigned texture_unit,
                         unsigned member_index,
                         const char *member_name,
                         boolean emit_load)
{
   LLVMBuilderRef builder = gallivm->builder;
   struct draw_llvm_sampler_dynamic_state *state =
      (struct draw_llvm_sampler_dynamic_state *)base;
   LLVMValueRef indices[4];
   LLVMValueRef ptr;
   LLVMValueRef res;

   debug_assert(texture_unit < PIPE_MAX_SHADER_SAMPLER_VIEWS);

   /* context[0] */
   indices[0] = lp_build_const_int32(gallivm, 0);
   /* context[0].textures */
   indices[1] = lp_build_const_int32(gallivm, DRAW_JIT_CTX_TEXTURES);
   /* context[0].textures[unit] */
   indices[2] = lp_build_const_int32(gallivm, texture_unit);
   /* context[0].textures[unit].member */
   indices[3] = lp_build_const_int32(gallivm, member_index);

   ptr = LLVMBuildGEP(builder, state->context_ptr, indices, Elements(indices), "");

   if (emit_load)
      res = LLVMBuildLoad(builder, ptr, "");
   else
      res = ptr;

   lp_build_name(res, "context.texture%u.%s", texture_unit, member_name);

   return res;
}


/**
 * Fetch the specified member of the lp_jit_sampler structure.
 * \param emit_load  if TRUE, emit the LLVM load instruction to actually
 *                   fetch the field's value.  Otherwise, just emit the
 *                   GEP code to address the field.
 *
 * @@sa http://llvm.org/docs/GetElementPtr.html
 */
static LLVMValueRef
draw_llvm_sampler_member(const struct lp_sampler_dynamic_state *base,
                         struct gallivm_state *gallivm,
                         unsigned sampler_unit,
                         unsigned member_index,
                         const char *member_name,
                         boolean emit_load)
{
   LLVMBuilderRef builder = gallivm->builder;
   struct draw_llvm_sampler_dynamic_state *state =
      (struct draw_llvm_sampler_dynamic_state *)base;
   LLVMValueRef indices[4];
   LLVMValueRef ptr;
   LLVMValueRef res;

   debug_assert(sampler_unit < PIPE_MAX_SAMPLERS);

   /* context[0] */
   indices[0] = lp_build_const_int32(gallivm, 0);
   /* context[0].samplers */
   indices[1] = lp_build_const_int32(gallivm, DRAW_JIT_CTX_SAMPLERS);
   /* context[0].samplers[unit] */
   indices[2] = lp_build_const_int32(gallivm, sampler_unit);
   /* context[0].samplers[unit].member */
   indices[3] = lp_build_const_int32(gallivm, member_index);

   ptr = LLVMBuildGEP(builder, state->context_ptr, indices, Elements(indices), "");

   if (emit_load)
      res = LLVMBuildLoad(builder, ptr, "");
   else
      res = ptr;

   lp_build_name(res, "context.sampler%u.%s", sampler_unit, member_name);

   return res;
}


/**
 * Helper macro to instantiate the functions that generate the code to
 * fetch the members of lp_jit_texture to fulfill the sampler code
 * generator requests.
 *
 * This complexity is the price we have to pay to keep the texture
 * sampler code generator a reusable module without dependencies to
 * llvmpipe internals.
 */
#define DRAW_LLVM_TEXTURE_MEMBER(_name, _index, _emit_load)  \
   static LLVMValueRef \
   draw_llvm_texture_##_name( const struct lp_sampler_dynamic_state *base, \
                              struct gallivm_state *gallivm,               \
                              unsigned texture_unit)                       \
   { \
      return draw_llvm_texture_member(base, gallivm, texture_unit, _index, #_name, _emit_load ); \
   }


DRAW_LLVM_TEXTURE_MEMBER(width,      DRAW_JIT_TEXTURE_WIDTH, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(height,     DRAW_JIT_TEXTURE_HEIGHT, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(depth,      DRAW_JIT_TEXTURE_DEPTH, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(first_level,DRAW_JIT_TEXTURE_FIRST_LEVEL, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(last_level, DRAW_JIT_TEXTURE_LAST_LEVEL, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(base_ptr,   DRAW_JIT_TEXTURE_BASE, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(row_stride, DRAW_JIT_TEXTURE_ROW_STRIDE, FALSE)
DRAW_LLVM_TEXTURE_MEMBER(img_stride, DRAW_JIT_TEXTURE_IMG_STRIDE, FALSE)
DRAW_LLVM_TEXTURE_MEMBER(mip_offsets, DRAW_JIT_TEXTURE_MIP_OFFSETS, FALSE)


#define DRAW_LLVM_SAMPLER_MEMBER(_name, _index, _emit_load)  \
   static LLVMValueRef \
   draw_llvm_sampler_##_name( const struct lp_sampler_dynamic_state *base, \
                              struct gallivm_state *gallivm,               \
                              unsigned sampler_unit)                       \
   { \
      return draw_llvm_sampler_member(base, gallivm, sampler_unit, _index, #_name, _emit_load ); \
   }


DRAW_LLVM_SAMPLER_MEMBER(min_lod,    DRAW_JIT_SAMPLER_MIN_LOD, TRUE)
DRAW_LLVM_SAMPLER_MEMBER(max_lod,    DRAW_JIT_SAMPLER_MAX_LOD, TRUE)
DRAW_LLVM_SAMPLER_MEMBER(lod_bias,   DRAW_JIT_SAMPLER_LOD_BIAS, TRUE)
DRAW_LLVM_SAMPLER_MEMBER(border_color, DRAW_JIT_SAMPLER_BORDER_COLOR, FALSE)


static void
draw_llvm_sampler_soa_destroy(struct lp_build_sampler_soa *sampler)
{
   FREE(sampler);
}


/**
 * Fetch filtered values from texture.
 * The 'texel' parameter returns four vectors corresponding to R, G, B, A.
 */
static void
draw_llvm_sampler_soa_emit_fetch_texel(const struct lp_build_sampler_soa *base,
                                       struct gallivm_state *gallivm,
                                       struct lp_type type,
                                       boolean is_fetch,
                                       unsigned texture_index,
                                       unsigned sampler_index,
                                       const LLVMValueRef *coords,
                                       const LLVMValueRef *offsets,
                                       const struct lp_derivatives *derivs,
                                       LLVMValueRef lod_bias, /* optional */
                                       LLVMValueRef explicit_lod, /* optional */
                                       enum lp_sampler_lod_property lod_property,
                                       LLVMValueRef *texel)
{
   struct draw_llvm_sampler_soa *sampler = (struct draw_llvm_sampler_soa *)base;

   assert(texture_index < PIPE_MAX_SHADER_SAMPLER_VIEWS);
   assert(sampler_index < PIPE_MAX_SAMPLERS);

   lp_build_sample_soa(gallivm,
                       &sampler->dynamic_state.static_state[texture_index].texture_state,
                       &sampler->dynamic_state.static_state[sampler_index].sampler_state,
                       &sampler->dynamic_state.base,
                       type,
                       is_fetch,
                       texture_index,
                       sampler_index,
                       coords,
                       offsets,
                       derivs,
                       lod_bias, explicit_lod, lod_property,
                       texel);
}


/**
 * Fetch the texture size.
 */
static void
draw_llvm_sampler_soa_emit_size_query(const struct lp_build_sampler_soa *base,
                                      struct gallivm_state *gallivm,
                                      struct lp_type type,
                                      unsigned texture_unit,
                                      unsigned target,
                                      boolean is_sviewinfo,
                                      enum lp_sampler_lod_property lod_property,
                                      LLVMValueRef explicit_lod, /* optional */
                                      LLVMValueRef *sizes_out)
{
   struct draw_llvm_sampler_soa *sampler = (struct draw_llvm_sampler_soa *)base;

   assert(texture_unit < PIPE_MAX_SHADER_SAMPLER_VIEWS);

   lp_build_size_query_soa(gallivm,
                           &sampler->dynamic_state.static_state[texture_unit].texture_state,
                           &sampler->dynamic_state.base,
                           type,
                           texture_unit,
                           target,
                           is_sviewinfo,
                           lod_property,
                           explicit_lod,
                           sizes_out);
}

struct lp_build_sampler_soa *
draw_llvm_sampler_soa_create(const struct draw_sampler_static_state *static_state,
                             LLVMValueRef context_ptr)
{
   struct draw_llvm_sampler_soa *sampler;

   sampler = CALLOC_STRUCT(draw_llvm_sampler_soa);
   if(!sampler)
      return NULL;

   sampler->base.destroy = draw_llvm_sampler_soa_destroy;
   sampler->base.emit_fetch_texel = draw_llvm_sampler_soa_emit_fetch_texel;
   sampler->base.emit_size_query = draw_llvm_sampler_soa_emit_size_query;
   sampler->dynamic_state.base.width = draw_llvm_texture_width;
   sampler->dynamic_state.base.height = draw_llvm_texture_height;
   sampler->dynamic_state.base.depth = draw_llvm_texture_depth;
   sampler->dynamic_state.base.first_level = draw_llvm_texture_first_level;
   sampler->dynamic_state.base.last_level = draw_llvm_texture_last_level;
   sampler->dynamic_state.base.row_stride = draw_llvm_texture_row_stride;
   sampler->dynamic_state.base.img_stride = draw_llvm_texture_img_stride;
   sampler->dynamic_state.base.base_ptr = draw_llvm_texture_base_ptr;
   sampler->dynamic_state.base.mip_offsets = draw_llvm_texture_mip_offsets;
   sampler->dynamic_state.base.min_lod = draw_llvm_sampler_min_lod;
   sampler->dynamic_state.base.max_lod = draw_llvm_sampler_max_lod;
   sampler->dynamic_state.base.lod_bias = draw_llvm_sampler_lod_bias;
   sampler->dynamic_state.base.border_color = draw_llvm_sampler_border_color;
   sampler->dynamic_state.static_state = static_state;
   sampler->dynamic_state.context_ptr = context_ptr;

   return &sampler->base;
}

@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d241 1
a241 1
                                       boolean scalar_lod,
d260 1
a260 1
                       lod_bias, explicit_lod, scalar_lod,
d273 3
a275 1
                                      boolean need_nr_mips,
d288 3
a290 1
                           need_nr_mips,
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d61 1
a61 1
   const struct lp_sampler_static_state *static_state;
d89 1
a89 1
                         unsigned unit,
d101 1
a101 1
   debug_assert(unit < PIPE_MAX_VERTEX_SAMPLERS);
d108 1
a108 1
   indices[2] = lp_build_const_int32(gallivm, unit);
d119 48
a166 1
   lp_build_name(res, "context.texture%u.%s", unit, member_name);
d185 1
a185 1
                              unsigned unit)                            \
d187 1
a187 1
      return draw_llvm_texture_member(base, gallivm, unit, _index, #_name, _emit_load ); \
d196 1
d199 17
a215 5
DRAW_LLVM_TEXTURE_MEMBER(data_ptr,   DRAW_JIT_TEXTURE_DATA, FALSE)
DRAW_LLVM_TEXTURE_MEMBER(min_lod,    DRAW_JIT_TEXTURE_MIN_LOD, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(max_lod,    DRAW_JIT_TEXTURE_MAX_LOD, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(lod_bias,   DRAW_JIT_TEXTURE_LOD_BIAS, TRUE)
DRAW_LLVM_TEXTURE_MEMBER(border_color, DRAW_JIT_TEXTURE_BORDER_COLOR, FALSE)
d233 3
a235 2
                                       unsigned unit,
                                       unsigned num_coords,
d237 2
a238 2
                                       const LLVMValueRef *ddx,
                                       const LLVMValueRef *ddy,
d241 1
d246 2
a247 1
   assert(unit < PIPE_MAX_VERTEX_SAMPLERS);
d250 2
a251 1
                       &sampler->dynamic_state.static_state[unit],
d254 7
a260 4
                       unit,
                       num_coords, coords,
                       ddx, ddy,
                       lod_bias, explicit_lod,
d265 26
d292 1
a292 1
draw_llvm_sampler_soa_create(const struct lp_sampler_static_state *static_state,
d303 1
d311 6
a316 5
   sampler->dynamic_state.base.data_ptr = draw_llvm_texture_data_ptr;
   sampler->dynamic_state.base.min_lod = draw_llvm_texture_min_lod;
   sampler->dynamic_state.base.max_lod = draw_llvm_texture_max_lod;
   sampler->dynamic_state.base.lod_bias = draw_llvm_texture_lod_bias;
   sampler->dynamic_state.base.border_color = draw_llvm_texture_border_color;
@


1.1
log
@Initial revision
@
text
@d147 1
d213 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d61 1
a61 1
   const struct draw_sampler_static_state *static_state;
d89 1
a89 1
                         unsigned texture_unit,
d101 1
a101 1
   debug_assert(texture_unit < PIPE_MAX_SHADER_SAMPLER_VIEWS);
d108 1
a108 1
   indices[2] = lp_build_const_int32(gallivm, texture_unit);
d119 1
a119 48
   lp_build_name(res, "context.texture%u.%s", texture_unit, member_name);

   return res;
}


/**
 * Fetch the specified member of the lp_jit_sampler structure.
 * \param emit_load  if TRUE, emit the LLVM load instruction to actually
 *                   fetch the field's value.  Otherwise, just emit the
 *                   GEP code to address the field.
 *
 * @@sa http://llvm.org/docs/GetElementPtr.html
 */
static LLVMValueRef
draw_llvm_sampler_member(const struct lp_sampler_dynamic_state *base,
                         struct gallivm_state *gallivm,
                         unsigned sampler_unit,
                         unsigned member_index,
                         const char *member_name,
                         boolean emit_load)
{
   LLVMBuilderRef builder = gallivm->builder;
   struct draw_llvm_sampler_dynamic_state *state =
      (struct draw_llvm_sampler_dynamic_state *)base;
   LLVMValueRef indices[4];
   LLVMValueRef ptr;
   LLVMValueRef res;

   debug_assert(sampler_unit < PIPE_MAX_SAMPLERS);

   /* context[0] */
   indices[0] = lp_build_const_int32(gallivm, 0);
   /* context[0].samplers */
   indices[1] = lp_build_const_int32(gallivm, DRAW_JIT_CTX_SAMPLERS);
   /* context[0].samplers[unit] */
   indices[2] = lp_build_const_int32(gallivm, sampler_unit);
   /* context[0].samplers[unit].member */
   indices[3] = lp_build_const_int32(gallivm, member_index);

   ptr = LLVMBuildGEP(builder, state->context_ptr, indices, Elements(indices), "");

   if (emit_load)
      res = LLVMBuildLoad(builder, ptr, "");
   else
      res = ptr;

   lp_build_name(res, "context.sampler%u.%s", sampler_unit, member_name);
d138 1
a138 1
                              unsigned texture_unit)                       \
d140 1
a140 1
      return draw_llvm_texture_member(base, gallivm, texture_unit, _index, #_name, _emit_load ); \
a146 1
DRAW_LLVM_TEXTURE_MEMBER(first_level,DRAW_JIT_TEXTURE_FIRST_LEVEL, TRUE)
a147 1
DRAW_LLVM_TEXTURE_MEMBER(base_ptr,   DRAW_JIT_TEXTURE_BASE, TRUE)
d150 5
a154 17
DRAW_LLVM_TEXTURE_MEMBER(mip_offsets, DRAW_JIT_TEXTURE_MIP_OFFSETS, FALSE)


#define DRAW_LLVM_SAMPLER_MEMBER(_name, _index, _emit_load)  \
   static LLVMValueRef \
   draw_llvm_sampler_##_name( const struct lp_sampler_dynamic_state *base, \
                              struct gallivm_state *gallivm,               \
                              unsigned sampler_unit)                       \
   { \
      return draw_llvm_sampler_member(base, gallivm, sampler_unit, _index, #_name, _emit_load ); \
   }


DRAW_LLVM_SAMPLER_MEMBER(min_lod,    DRAW_JIT_SAMPLER_MIN_LOD, TRUE)
DRAW_LLVM_SAMPLER_MEMBER(max_lod,    DRAW_JIT_SAMPLER_MAX_LOD, TRUE)
DRAW_LLVM_SAMPLER_MEMBER(lod_bias,   DRAW_JIT_SAMPLER_LOD_BIAS, TRUE)
DRAW_LLVM_SAMPLER_MEMBER(border_color, DRAW_JIT_SAMPLER_BORDER_COLOR, FALSE)
d172 2
a173 3
                                       boolean is_fetch,
                                       unsigned texture_index,
                                       unsigned sampler_index,
d175 2
a176 2
                                       const LLVMValueRef *offsets,
                                       const struct lp_derivatives *derivs,
a178 1
                                       boolean scalar_lod,
d183 1
a183 2
   assert(texture_index < PIPE_MAX_SHADER_SAMPLER_VIEWS);
   assert(sampler_index < PIPE_MAX_SAMPLERS);
d186 1
a186 2
                       &sampler->dynamic_state.static_state[texture_index].texture_state,
                       &sampler->dynamic_state.static_state[sampler_index].sampler_state,
d189 4
a192 7
                       is_fetch,
                       texture_index,
                       sampler_index,
                       coords,
                       offsets,
                       derivs,
                       lod_bias, explicit_lod, scalar_lod,
a196 26
/**
 * Fetch the texture size.
 */
static void
draw_llvm_sampler_soa_emit_size_query(const struct lp_build_sampler_soa *base,
                                      struct gallivm_state *gallivm,
                                      struct lp_type type,
                                      unsigned texture_unit,
                                      boolean need_nr_mips,
                                      LLVMValueRef explicit_lod, /* optional */
                                      LLVMValueRef *sizes_out)
{
   struct draw_llvm_sampler_soa *sampler = (struct draw_llvm_sampler_soa *)base;

   assert(texture_unit < PIPE_MAX_SHADER_SAMPLER_VIEWS);

   lp_build_size_query_soa(gallivm,
                           &sampler->dynamic_state.static_state[texture_unit].texture_state,
                           &sampler->dynamic_state.base,
                           type,
                           texture_unit,
                           need_nr_mips,
                           explicit_lod,
                           sizes_out);
}

d198 1
a198 1
draw_llvm_sampler_soa_create(const struct draw_sampler_static_state *static_state,
a208 1
   sampler->base.emit_size_query = draw_llvm_sampler_soa_emit_size_query;
a211 1
   sampler->dynamic_state.base.first_level = draw_llvm_texture_first_level;
d215 5
a219 6
   sampler->dynamic_state.base.base_ptr = draw_llvm_texture_base_ptr;
   sampler->dynamic_state.base.mip_offsets = draw_llvm_texture_mip_offsets;
   sampler->dynamic_state.base.min_lod = draw_llvm_sampler_min_lod;
   sampler->dynamic_state.base.max_lod = draw_llvm_sampler_max_lod;
   sampler->dynamic_state.base.lod_bias = draw_llvm_sampler_lod_bias;
   sampler->dynamic_state.base.border_color = draw_llvm_sampler_border_color;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d241 1
a241 1
                                       enum lp_sampler_lod_property lod_property,
d260 1
a260 1
                       lod_bias, explicit_lod, lod_property,
d273 1
a273 3
                                      unsigned target,
                                      boolean is_sviewinfo,
                                      enum lp_sampler_lod_property lod_property,
d286 1
a286 3
                           target,
                           is_sviewinfo,
                           lod_property,
@


