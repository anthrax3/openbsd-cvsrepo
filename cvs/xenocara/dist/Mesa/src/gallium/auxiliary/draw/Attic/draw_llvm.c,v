head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.29;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2012.07.13.13.00.28;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.41;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.07;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.15;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "draw_llvm.h"

#include "draw_context.h"
#include "draw_vs.h"
#include "draw_gs.h"

#include "gallivm/lp_bld_arit.h"
#include "gallivm/lp_bld_arit_overflow.h"
#include "gallivm/lp_bld_logic.h"
#include "gallivm/lp_bld_const.h"
#include "gallivm/lp_bld_swizzle.h"
#include "gallivm/lp_bld_struct.h"
#include "gallivm/lp_bld_type.h"
#include "gallivm/lp_bld_flow.h"
#include "gallivm/lp_bld_debug.h"
#include "gallivm/lp_bld_tgsi.h"
#include "gallivm/lp_bld_printf.h"
#include "gallivm/lp_bld_intr.h"
#include "gallivm/lp_bld_init.h"
#include "gallivm/lp_bld_type.h"
#include "gallivm/lp_bld_pack.h"
#include "gallivm/lp_bld_format.h"

#include "tgsi/tgsi_exec.h"
#include "tgsi/tgsi_dump.h"

#include "util/u_math.h"
#include "util/u_pointer.h"
#include "util/u_string.h"
#include "util/u_simple_list.h"


#define DEBUG_STORE 0


static void
draw_llvm_generate(struct draw_llvm *llvm, struct draw_llvm_variant *var,
                   boolean elts);


struct draw_gs_llvm_iface {
   struct lp_build_tgsi_gs_iface base;

   struct draw_gs_llvm_variant *variant;
   LLVMValueRef input;
};

static INLINE const struct draw_gs_llvm_iface *
draw_gs_llvm_iface(const struct lp_build_tgsi_gs_iface *iface)
{
   return (const struct draw_gs_llvm_iface *)iface;
}

/**
 * Create LLVM type for draw_vertex_buffer.
 */
static LLVMTypeRef
create_jit_dvbuffer_type(struct gallivm_state *gallivm,
                         const char *struct_name)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef dvbuffer_type;
   LLVMTypeRef elem_types[DRAW_JIT_DVBUFFER_NUM_FIELDS];
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(gallivm->context);

   elem_types[DRAW_JIT_DVBUFFER_MAP] =
      LLVMPointerType(LLVMIntTypeInContext(gallivm->context, 8), 0);
   elem_types[DRAW_JIT_DVBUFFER_SIZE] = int32_type;

   dvbuffer_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                           Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, dvbuffer_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, dvbuffer_type);
#endif

   LP_CHECK_MEMBER_OFFSET(struct draw_vertex_buffer, map,
                          target, dvbuffer_type,
                          DRAW_JIT_DVBUFFER_MAP);
   LP_CHECK_MEMBER_OFFSET(struct draw_vertex_buffer, size,
                          target, dvbuffer_type,
                          DRAW_JIT_DVBUFFER_SIZE);

   return dvbuffer_type;
}

/**
 * Create LLVM type for struct draw_jit_texture
 */
static LLVMTypeRef
create_jit_texture_type(struct gallivm_state *gallivm, const char *struct_name)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef texture_type;
   LLVMTypeRef elem_types[DRAW_JIT_TEXTURE_NUM_FIELDS];
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(gallivm->context);

   elem_types[DRAW_JIT_TEXTURE_WIDTH]  =
   elem_types[DRAW_JIT_TEXTURE_HEIGHT] =
   elem_types[DRAW_JIT_TEXTURE_DEPTH] =
   elem_types[DRAW_JIT_TEXTURE_FIRST_LEVEL] =
   elem_types[DRAW_JIT_TEXTURE_LAST_LEVEL] = int32_type;
   elem_types[DRAW_JIT_TEXTURE_BASE] =
      LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0);
   elem_types[DRAW_JIT_TEXTURE_ROW_STRIDE] =
   elem_types[DRAW_JIT_TEXTURE_IMG_STRIDE] =
   elem_types[DRAW_JIT_TEXTURE_MIP_OFFSETS] =
      LLVMArrayType(int32_type, PIPE_MAX_TEXTURE_LEVELS);

   texture_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                          Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, texture_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, texture_type);
#endif

   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, width,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_WIDTH);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, height,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_HEIGHT);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, depth,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_DEPTH);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, first_level,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_FIRST_LEVEL);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, last_level,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_LAST_LEVEL);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, base,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_BASE);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, row_stride,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_ROW_STRIDE);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, img_stride,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_IMG_STRIDE);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, mip_offsets,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_MIP_OFFSETS);

   LP_CHECK_STRUCT_SIZE(struct draw_jit_texture, target, texture_type);

   return texture_type;
}


/**
 * Create LLVM type for struct draw_jit_sampler
 */
static LLVMTypeRef
create_jit_sampler_type(struct gallivm_state *gallivm, const char *struct_name)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef sampler_type;
   LLVMTypeRef elem_types[DRAW_JIT_SAMPLER_NUM_FIELDS];

   elem_types[DRAW_JIT_SAMPLER_MIN_LOD] =
   elem_types[DRAW_JIT_SAMPLER_MAX_LOD] =
   elem_types[DRAW_JIT_SAMPLER_LOD_BIAS] = LLVMFloatTypeInContext(gallivm->context);
   elem_types[DRAW_JIT_SAMPLER_BORDER_COLOR] =
      LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);

   sampler_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                          Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, sampler_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, sampler_type);
#endif

   LP_CHECK_MEMBER_OFFSET(struct draw_jit_sampler, min_lod,
                          target, sampler_type,
                          DRAW_JIT_SAMPLER_MIN_LOD);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_sampler, max_lod,
                          target, sampler_type,
                          DRAW_JIT_SAMPLER_MAX_LOD);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_sampler, lod_bias,
                          target, sampler_type,
                          DRAW_JIT_SAMPLER_LOD_BIAS);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_sampler, border_color,
                          target, sampler_type,
                          DRAW_JIT_SAMPLER_BORDER_COLOR);

   LP_CHECK_STRUCT_SIZE(struct draw_jit_sampler, target, sampler_type);

   return sampler_type;
}


/**
 * Create LLVM type for struct draw_jit_context
 */
static LLVMTypeRef
create_jit_context_type(struct gallivm_state *gallivm,
                        LLVMTypeRef texture_type, LLVMTypeRef sampler_type,
                        const char *struct_name)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
   LLVMTypeRef int_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMTypeRef elem_types[DRAW_JIT_CTX_NUM_FIELDS];
   LLVMTypeRef context_type;

   elem_types[0] = LLVMArrayType(LLVMPointerType(float_type, 0), /* vs_constants */
                                 LP_MAX_TGSI_CONST_BUFFERS);
   elem_types[1] = LLVMArrayType(int_type, /* num_vs_constants */
                                 LP_MAX_TGSI_CONST_BUFFERS);
   elem_types[2] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4),
                                                 DRAW_TOTAL_CLIP_PLANES), 0);
   elem_types[3] = LLVMPointerType(float_type, 0); /* viewport */
   elem_types[4] = LLVMArrayType(texture_type,
                                 PIPE_MAX_SHADER_SAMPLER_VIEWS); /* textures */
   elem_types[5] = LLVMArrayType(sampler_type,
                                 PIPE_MAX_SAMPLERS); /* samplers */
   context_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                          Elements(elem_types), 0);
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, context_type);

   LLVMInvalidateStructLayout(gallivm->target, context_type);
#endif

   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, vs_constants,
                          target, context_type, DRAW_JIT_CTX_CONSTANTS);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, num_vs_constants,
                          target, context_type, DRAW_JIT_CTX_NUM_CONSTANTS);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, planes,
                          target, context_type, DRAW_JIT_CTX_PLANES);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, viewport,
                          target, context_type, DRAW_JIT_CTX_VIEWPORT);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, textures,
                          target, context_type,
                          DRAW_JIT_CTX_TEXTURES);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, samplers,
                          target, context_type,
                          DRAW_JIT_CTX_SAMPLERS);
   LP_CHECK_STRUCT_SIZE(struct draw_jit_context,
                        target, context_type);

   return context_type;
}


/**
 * Create LLVM type for struct draw_gs_jit_context
 */
static LLVMTypeRef
create_gs_jit_context_type(struct gallivm_state *gallivm,
                           unsigned vector_length,
                           LLVMTypeRef texture_type, LLVMTypeRef sampler_type,
                           const char *struct_name)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
   LLVMTypeRef int_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMTypeRef elem_types[DRAW_GS_JIT_CTX_NUM_FIELDS];
   LLVMTypeRef context_type;

   elem_types[0] = LLVMArrayType(LLVMPointerType(float_type, 0), /* constants */
                                 LP_MAX_TGSI_CONST_BUFFERS);
   elem_types[1] = LLVMArrayType(int_type, /* num_constants */
                                 LP_MAX_TGSI_CONST_BUFFERS);
   elem_types[2] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4),
                                                 DRAW_TOTAL_CLIP_PLANES), 0);
   elem_types[3] = LLVMPointerType(float_type, 0); /* viewport */

   elem_types[4] = LLVMArrayType(texture_type,
                                 PIPE_MAX_SHADER_SAMPLER_VIEWS); /* textures */
   elem_types[5] = LLVMArrayType(sampler_type,
                                 PIPE_MAX_SAMPLERS); /* samplers */
   
   elem_types[6] = LLVMPointerType(LLVMPointerType(int_type, 0), 0);
   elem_types[7] = LLVMPointerType(LLVMVectorType(int_type,
                                                  vector_length), 0);
   elem_types[8] = LLVMPointerType(LLVMVectorType(int_type,
                                                  vector_length), 0);

   context_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                          Elements(elem_types), 0);
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, context_type);

   LLVMInvalidateStructLayout(gallivm->target, context_type);
#endif

   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, constants,
                          target, context_type, DRAW_GS_JIT_CTX_CONSTANTS);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, num_constants,
                          target, context_type, DRAW_GS_JIT_CTX_NUM_CONSTANTS);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, planes,
                          target, context_type, DRAW_GS_JIT_CTX_PLANES);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, viewport,
                          target, context_type, DRAW_GS_JIT_CTX_VIEWPORT);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, textures,
                          target, context_type,
                          DRAW_GS_JIT_CTX_TEXTURES);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, samplers,
                          target, context_type,
                          DRAW_GS_JIT_CTX_SAMPLERS);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, prim_lengths,
                          target, context_type,
                          DRAW_GS_JIT_CTX_PRIM_LENGTHS);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, emitted_vertices,
                          target, context_type,
                          DRAW_GS_JIT_CTX_EMITTED_VERTICES);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, emitted_prims,
                          target, context_type,
                          DRAW_GS_JIT_CTX_EMITTED_PRIMS);
   LP_CHECK_STRUCT_SIZE(struct draw_gs_jit_context,
                        target, context_type);

   return context_type;
}


static LLVMTypeRef
create_gs_jit_input_type(struct gallivm_state *gallivm)
{
   LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
   LLVMTypeRef input_array;

   input_array = LLVMVectorType(float_type, TGSI_NUM_CHANNELS); /* num primitives */
   input_array = LLVMArrayType(input_array, TGSI_NUM_CHANNELS); /* num channels */
   input_array = LLVMArrayType(input_array, PIPE_MAX_SHADER_INPUTS); /* num attrs per vertex */
   input_array = LLVMPointerType(input_array, 0); /* num vertices per prim */

   return input_array;
}

/**
 * Create LLVM type for struct pipe_vertex_buffer
 */
static LLVMTypeRef
create_jit_vertex_buffer_type(struct gallivm_state *gallivm,
                              const char *struct_name)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef elem_types[4];
   LLVMTypeRef vb_type;

   elem_types[0] =
   elem_types[1] = LLVMInt32TypeInContext(gallivm->context);
   elem_types[2] =
   elem_types[3] = LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0);

   vb_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                     Elements(elem_types), 0);
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, vb_type);

   LLVMInvalidateStructLayout(gallivm->target, vb_type);
#endif

   LP_CHECK_MEMBER_OFFSET(struct pipe_vertex_buffer, stride,
                          target, vb_type, 0);
   LP_CHECK_MEMBER_OFFSET(struct pipe_vertex_buffer, buffer_offset,
                          target, vb_type, 1);

   LP_CHECK_STRUCT_SIZE(struct pipe_vertex_buffer, target, vb_type);

   return vb_type;
}


/**
 * Create LLVM type for struct vertex_header;
 */
static LLVMTypeRef
create_jit_vertex_header(struct gallivm_state *gallivm, int data_elems)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef elem_types[4];
   LLVMTypeRef vertex_header;
   char struct_name[24];

   util_snprintf(struct_name, 23, "vertex_header%d", data_elems);

   elem_types[DRAW_JIT_VERTEX_VERTEX_ID]  = LLVMIntTypeInContext(gallivm->context, 32);
   elem_types[DRAW_JIT_VERTEX_CLIP]  = LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);
   elem_types[DRAW_JIT_VERTEX_PRE_CLIP_POS]  = LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);
   elem_types[DRAW_JIT_VERTEX_DATA]  = LLVMArrayType(elem_types[1], data_elems);

   vertex_header = LLVMStructTypeInContext(gallivm->context, elem_types,
                                           Elements(elem_types), 0);
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, vertex_header);

   LLVMInvalidateStructLayout(gallivm->target, vertex_header);
#endif

   /* these are bit-fields and we can't take address of them
      LP_CHECK_MEMBER_OFFSET(struct vertex_header, clipmask,
      target, vertex_header,
      DRAW_JIT_VERTEX_CLIPMASK);
      LP_CHECK_MEMBER_OFFSET(struct vertex_header, edgeflag,
      target, vertex_header,
      DRAW_JIT_VERTEX_EDGEFLAG);
      LP_CHECK_MEMBER_OFFSET(struct vertex_header, pad,
      target, vertex_header,
      DRAW_JIT_VERTEX_PAD);
      LP_CHECK_MEMBER_OFFSET(struct vertex_header, vertex_id,
      target, vertex_header,
      DRAW_JIT_VERTEX_VERTEX_ID);
   */
   LP_CHECK_MEMBER_OFFSET(struct vertex_header, clip,
                          target, vertex_header,
                          DRAW_JIT_VERTEX_CLIP);
   LP_CHECK_MEMBER_OFFSET(struct vertex_header, pre_clip_pos,
                          target, vertex_header,
                          DRAW_JIT_VERTEX_PRE_CLIP_POS);
   LP_CHECK_MEMBER_OFFSET(struct vertex_header, data,
                          target, vertex_header,
                          DRAW_JIT_VERTEX_DATA);

   assert(LLVMABISizeOfType(target, vertex_header) ==
          offsetof(struct vertex_header, data[data_elems]));

   return vertex_header;
}


/**
 * Create LLVM types for various structures.
 */
static void
create_jit_types(struct draw_llvm_variant *variant)
{
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMTypeRef texture_type, sampler_type, context_type, buffer_type,
      vb_type;

   texture_type = create_jit_texture_type(gallivm, "texture");
   sampler_type = create_jit_sampler_type(gallivm, "sampler");

   context_type = create_jit_context_type(gallivm, texture_type, sampler_type,
                                          "draw_jit_context");
   variant->context_ptr_type = LLVMPointerType(context_type, 0);

   buffer_type = create_jit_dvbuffer_type(gallivm, "draw_vertex_buffer");
   variant->buffer_ptr_type = LLVMPointerType(buffer_type, 0);
   
   vb_type = create_jit_vertex_buffer_type(gallivm, "pipe_vertex_buffer");
   variant->vb_ptr_type = LLVMPointerType(vb_type, 0);
}


static LLVMTypeRef
get_context_ptr_type(struct draw_llvm_variant *variant)
{
   if (!variant->context_ptr_type)
      create_jit_types(variant);
   return variant->context_ptr_type;
}


static LLVMTypeRef
get_buffer_ptr_type(struct draw_llvm_variant *variant)
{
   if (!variant->buffer_ptr_type)
      create_jit_types(variant);
   return variant->buffer_ptr_type;
}


static LLVMTypeRef
get_vb_ptr_type(struct draw_llvm_variant *variant)
{
   if (!variant->vb_ptr_type)
      create_jit_types(variant);
   return variant->vb_ptr_type;
}

static LLVMTypeRef
get_vertex_header_ptr_type(struct draw_llvm_variant *variant)
{
   if (!variant->vertex_header_ptr_type)
      create_jit_types(variant);
   return variant->vertex_header_ptr_type;
}


/**
 * Create per-context LLVM info.
 */
struct draw_llvm *
draw_llvm_create(struct draw_context *draw)
{
   struct draw_llvm *llvm;

   llvm = CALLOC_STRUCT( draw_llvm );
   if (!llvm)
      return NULL;

   lp_build_init();

   llvm->draw = draw;

   llvm->nr_variants = 0;
   make_empty_list(&llvm->vs_variants_list);

   llvm->nr_gs_variants = 0;
   make_empty_list(&llvm->gs_variants_list);

   return llvm;
}


/**
 * Free per-context LLVM info.
 */
void
draw_llvm_destroy(struct draw_llvm *llvm)
{
   /* XXX free other draw_llvm data? */
   FREE(llvm);
}


/**
 * Create LLVM-generated code for a vertex shader.
 */
struct draw_llvm_variant *
draw_llvm_create_variant(struct draw_llvm *llvm,
                         unsigned num_inputs,
                         const struct draw_llvm_variant_key *key)
{
   struct draw_llvm_variant *variant;
   struct llvm_vertex_shader *shader =
      llvm_vertex_shader(llvm->draw->vs.vertex_shader);
   LLVMTypeRef vertex_header;

   variant = MALLOC(sizeof *variant +
                    shader->variant_key_size -
                    sizeof variant->key);
   if (variant == NULL)
      return NULL;

   variant->llvm = llvm;

   variant->gallivm = gallivm_create();

   create_jit_types(variant);

   memcpy(&variant->key, key, shader->variant_key_size);

   vertex_header = create_jit_vertex_header(variant->gallivm, num_inputs);

   variant->vertex_header_ptr_type = LLVMPointerType(vertex_header, 0);

   draw_llvm_generate(llvm, variant, FALSE);  /* linear */
   draw_llvm_generate(llvm, variant, TRUE);   /* elts */

   gallivm_compile_module(variant->gallivm);

   variant->jit_func = (draw_jit_vert_func)
         gallivm_jit_function(variant->gallivm, variant->function);

   variant->jit_func_elts = (draw_jit_vert_func_elts)
         gallivm_jit_function(variant->gallivm, variant->function_elts);

   variant->shader = shader;
   variant->list_item_global.base = variant;
   variant->list_item_local.base = variant;
   /*variant->no = */shader->variants_created++;
   variant->list_item_global.base = variant;

   return variant;
}


static void
generate_vs(struct draw_llvm_variant *variant,
            LLVMBuilderRef builder,
            struct lp_type vs_type,
            LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
            const LLVMValueRef (*inputs)[TGSI_NUM_CHANNELS],
            const struct lp_bld_tgsi_system_values *system_values,
            LLVMValueRef context_ptr,
            struct lp_build_sampler_soa *draw_sampler,
            boolean clamp_vertex_color)
{
   struct draw_llvm *llvm = variant->llvm;
   const struct tgsi_token *tokens = llvm->draw->vs.vertex_shader->state.tokens;
   LLVMValueRef consts_ptr =
      draw_jit_context_vs_constants(variant->gallivm, context_ptr);
   LLVMValueRef num_consts_ptr =
      draw_jit_context_num_vs_constants(variant->gallivm, context_ptr);
   struct lp_build_sampler_soa *sampler = 0;

   if (gallivm_debug & (GALLIVM_DEBUG_TGSI | GALLIVM_DEBUG_IR)) {
      tgsi_dump(tokens, 0);
      draw_llvm_dump_variant_key(&variant->key);
   }

   if (llvm->draw->num_sampler_views && llvm->draw->num_samplers)
      sampler = draw_sampler;

   lp_build_tgsi_soa(variant->gallivm,
                     tokens,
                     vs_type,
                     NULL /*struct lp_build_mask_context *mask*/,
                     consts_ptr,
                     num_consts_ptr,
                     system_values,
                     inputs,
                     outputs,
                     sampler,
                     &llvm->draw->vs.vertex_shader->info,
                     NULL);

   {
      LLVMValueRef out;
      unsigned chan, attrib;
      struct lp_build_context bld;
      struct tgsi_shader_info* info = &llvm->draw->vs.vertex_shader->info;
      lp_build_context_init(&bld, variant->gallivm, vs_type);

      for (attrib = 0; attrib < info->num_outputs; ++attrib) {
         for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
            if (outputs[attrib][chan]) {
               switch (info->output_semantic_name[attrib]) {
               case TGSI_SEMANTIC_COLOR:
               case TGSI_SEMANTIC_BCOLOR:
                  if (clamp_vertex_color) {
                     out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
                     out = lp_build_clamp(&bld, out, bld.zero, bld.one);
                     LLVMBuildStore(builder, out, outputs[attrib][chan]);
                  }
                  break;
               }
            }
         }
      }
   }
}

static void
generate_fetch(struct gallivm_state *gallivm,
               struct draw_context *draw,
               LLVMValueRef vbuffers_ptr,
               LLVMValueRef *res,
               struct pipe_vertex_element *velem,
               LLVMValueRef vbuf,
               LLVMValueRef index,
               LLVMValueRef instance_id)
{
   const struct util_format_description *format_desc =
      util_format_description(velem->src_format);
   LLVMValueRef zero = LLVMConstNull(LLVMInt32TypeInContext(gallivm->context));
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef indices =
      LLVMConstInt(LLVMInt64TypeInContext(gallivm->context),
                   velem->vertex_buffer_index, 0);
   LLVMValueRef vbuffer_ptr = LLVMBuildGEP(builder, vbuffers_ptr,
                                           &indices, 1, "");
   LLVMValueRef vb_stride = draw_jit_vbuffer_stride(gallivm, vbuf);
   LLVMValueRef vb_buffer_offset = draw_jit_vbuffer_offset(gallivm, vbuf);
   LLVMValueRef map_ptr = draw_jit_dvbuffer_map(gallivm, vbuffer_ptr);
   LLVMValueRef buffer_size = draw_jit_dvbuffer_size(gallivm, vbuffer_ptr);
   LLVMValueRef stride;
   LLVMValueRef buffer_overflowed;
   LLVMValueRef needed_buffer_size;
   LLVMValueRef temp_ptr =
      lp_build_alloca(gallivm,
                      lp_build_vec_type(gallivm, lp_float32_vec4_type()), "");
   LLVMValueRef ofbit = NULL;
   struct lp_build_if_state if_ctx;

   if (velem->instance_divisor) {
      /* Index is equal to the start instance plus the number of current 
       * instance divided by the divisor. In this case we compute it as:
       * index = start_instance + (instance_id  / divisor)
       */
      LLVMValueRef current_instance;
      index = lp_build_const_int32(gallivm, draw->start_instance);
      current_instance = LLVMBuildUDiv(builder, instance_id,
                                       lp_build_const_int32(gallivm, velem->instance_divisor),
                                       "instance_divisor");
      index = lp_build_uadd_overflow(gallivm, index, current_instance, &ofbit);
   }

   stride = lp_build_umul_overflow(gallivm, vb_stride, index, &ofbit);
   stride = lp_build_uadd_overflow(gallivm, stride, vb_buffer_offset, &ofbit);
   stride = lp_build_uadd_overflow(
      gallivm, stride,
      lp_build_const_int32(gallivm, velem->src_offset), &ofbit);
   needed_buffer_size = lp_build_uadd_overflow(
      gallivm, stride,
      lp_build_const_int32(gallivm,
                           util_format_get_blocksize(velem->src_format)),
      &ofbit);

   buffer_overflowed = LLVMBuildICmp(builder, LLVMIntUGT,
                                     needed_buffer_size, buffer_size,
                                     "buffer_overflowed");
   buffer_overflowed = LLVMBuildOr(builder, buffer_overflowed, ofbit, "");
#if 0
   lp_build_printf(gallivm, "vbuf index = %u, vb_stride is %u\n",
                   index, vb_stride);
   lp_build_printf(gallivm, "   vb_buffer_offset = %u, src_offset is %u\n",
                   vb_buffer_offset,
                   lp_build_const_int32(gallivm, velem->src_offset));
   lp_build_print_value(gallivm, "   blocksize = ",
                        lp_build_const_int32(
                           gallivm,
                           util_format_get_blocksize(velem->src_format)));
   lp_build_printf(gallivm, "   instance_id = %u\n", instance_id);
   lp_build_printf(gallivm, "   stride = %u\n", stride);
   lp_build_printf(gallivm, "   buffer size = %u\n", buffer_size);
   lp_build_printf(gallivm, "   needed_buffer_size = %u\n", needed_buffer_size);
   lp_build_print_value(gallivm, "   buffer overflowed = ", buffer_overflowed);
#endif

   lp_build_if(&if_ctx, gallivm, buffer_overflowed);
   {
      LLVMValueRef val =
         lp_build_const_vec(gallivm, lp_float32_vec4_type(), 0);
      LLVMBuildStore(builder, val, temp_ptr);
   }
   lp_build_else(&if_ctx);
   {
      LLVMValueRef val;
      map_ptr = LLVMBuildGEP(builder, map_ptr, &stride, 1, "");

      val = lp_build_fetch_rgba_aos(gallivm,
                                    format_desc,
                                    lp_float32_vec4_type(),
                                    map_ptr,
                                    zero, zero, zero);
      LLVMBuildStore(builder, val, temp_ptr);
   }
   lp_build_endif(&if_ctx);

   *res = LLVMBuildLoad(builder, temp_ptr, "aos");
}

static void
convert_to_soa(struct gallivm_state *gallivm,
               LLVMValueRef (*src_aos)[LP_MAX_VECTOR_WIDTH / 32],
               LLVMValueRef (*dst_soa)[TGSI_NUM_CHANNELS],
               unsigned num_attribs, const struct lp_type soa_type)
{
   unsigned i, j, k;
   struct lp_type aos_channel_type = soa_type;

   debug_assert(TGSI_NUM_CHANNELS == 4);
   debug_assert((soa_type.length % TGSI_NUM_CHANNELS) == 0);

   aos_channel_type.length >>= 1;

   for (i = 0; i < num_attribs; ++i) {
      LLVMValueRef aos_channels[TGSI_NUM_CHANNELS];
      unsigned pixels_per_channel = soa_type.length / TGSI_NUM_CHANNELS;

      for (j = 0; j < TGSI_NUM_CHANNELS; ++j) {
         LLVMValueRef channel[LP_MAX_VECTOR_LENGTH] = { 0 };

         assert(pixels_per_channel <= LP_MAX_VECTOR_LENGTH);

         for (k = 0; k < pixels_per_channel; ++k) {
            channel[k] = src_aos[i][j + TGSI_NUM_CHANNELS * k];
         }

         aos_channels[j] = lp_build_concat(gallivm, channel, aos_channel_type, pixels_per_channel);
      }

      lp_build_transpose_aos(gallivm, soa_type, aos_channels, dst_soa[i]);
   }
}


static void
store_aos(struct gallivm_state *gallivm,
          LLVMValueRef io_ptr,
          LLVMValueRef index,
          LLVMValueRef value)
{
   LLVMTypeRef data_ptr_type = LLVMPointerType(lp_build_vec_type(gallivm, lp_float32_vec4_type()), 0);
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef data_ptr = draw_jit_header_data(gallivm, io_ptr);
   LLVMValueRef indices[3];

   indices[0] = lp_build_const_int32(gallivm, 0);
   indices[1] = index;
   indices[2] = lp_build_const_int32(gallivm, 0);

   data_ptr = LLVMBuildGEP(builder, data_ptr, indices, 3, "");
   data_ptr = LLVMBuildPointerCast(builder, data_ptr, data_ptr_type, "");

#if DEBUG_STORE
   lp_build_printf(gallivm, "    ---- %p storing attribute %d (io = %p)\n", data_ptr, index, io_ptr);
#endif

   /* Unaligned store due to the vertex header */
   lp_set_store_alignment(LLVMBuildStore(builder, value, data_ptr), sizeof(float));
}

/**
 * Adjust the mask to architecture endianess. The mask will the store in struct:
 *
 * struct vertex_header {
 *    unsigned clipmask:DRAW_TOTAL_CLIP_PLANES;
 *    unsigned edgeflag:1;
 *    unsigned have_clipdist:1;
 *    unsigned vertex_id:16;
 *    [...]
 * }
 *
 * On little-endian machine nothing needs to done, however on bit-endian machine
 * the mask's fields need to be adjusted with the algorithm:
 *
 * uint32_t reverse (uint32_t x)
 * {
 *   return (x >> 16) |              // vertex_id
 *          ((x & 0x3fff) << 18) |   // clipmask
 *          ((x & 0x4000) << 3) |    // have_clipdist
 *          ((x & 0x8000) << 1);     // edgeflag
 * }
 */
static LLVMValueRef
adjust_mask(struct gallivm_state *gallivm,
            LLVMValueRef mask)
{
#ifdef PIPE_ARCH_BIG_ENDIAN
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef vertex_id;
   LLVMValueRef clipmask;
   LLVMValueRef have_clipdist;
   LLVMValueRef edgeflag;

   vertex_id = LLVMBuildLShr(builder, mask, lp_build_const_int32(gallivm, 16), "");
   clipmask  = LLVMBuildAnd(builder, mask, lp_build_const_int32(gallivm, 0x3fff), "");
   clipmask  = LLVMBuildShl(builder, clipmask, lp_build_const_int32(gallivm, 18), "");
   have_clipdist = LLVMBuildAnd(builder, mask, lp_build_const_int32(gallivm, 0x4000), "");
   have_clipdist = LLVMBuildShl(builder, have_clipdist, lp_build_const_int32(gallivm, 3), "");
   edgeflag = LLVMBuildAnd(builder, mask, lp_build_const_int32(gallivm, 0x8000), "");
   edgeflag = LLVMBuildShl(builder, edgeflag, lp_build_const_int32(gallivm, 1), "");

   mask = LLVMBuildOr(builder, vertex_id, clipmask, "");
   mask = LLVMBuildOr(builder, mask, have_clipdist, "");
   mask = LLVMBuildOr(builder, mask, edgeflag, "");
#endif
   return mask;
}

static void
store_aos_array(struct gallivm_state *gallivm,
                struct lp_type soa_type,
                LLVMValueRef io_ptr,
                LLVMValueRef *indices,
                LLVMValueRef* aos,
                int attrib,
                int num_outputs,
                LLVMValueRef clipmask,
                boolean have_clipdist)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef attr_index = lp_build_const_int32(gallivm, attrib);
   LLVMValueRef inds[LP_MAX_VECTOR_WIDTH / 32];
   LLVMValueRef linear_inds[LP_MAX_VECTOR_WIDTH / 32];
   LLVMValueRef io_ptrs[LP_MAX_VECTOR_WIDTH / 32];
   int vector_length = soa_type.length;
   int i;

   debug_assert(TGSI_NUM_CHANNELS == 4);

   for (i = 0; i < vector_length; i++) {
      linear_inds[i] = lp_build_const_int32(gallivm, i);
      if (indices) {
         inds[i] = indices[i];
      } else {
         inds[i] = linear_inds[i];
      }
      io_ptrs[i] = LLVMBuildGEP(builder, io_ptr, &inds[i], 1, "");
   }

   if (attrib == 0) {
      /* store vertex header for each of the n vertices */
      LLVMValueRef val, cliptmp;
      int vertex_id_pad_edgeflag;

      /* If this assertion fails, it means we need to update the bit twidding
       * code here.  See struct vertex_header in draw_private.h.
       */
      assert(DRAW_TOTAL_CLIP_PLANES==14);
      /* initialize vertex id:16 = 0xffff, have_clipdist:1 = 0, edgeflag:1 = 1 */
      vertex_id_pad_edgeflag = (0xffff << 16) | (1 << DRAW_TOTAL_CLIP_PLANES);
      if (have_clipdist)
         vertex_id_pad_edgeflag |= 1 << (DRAW_TOTAL_CLIP_PLANES+1);
      val = lp_build_const_int_vec(gallivm, lp_int_type(soa_type), vertex_id_pad_edgeflag);
      /* OR with the clipmask */
      cliptmp = LLVMBuildOr(builder, val, clipmask, "");
      for (i = 0; i < vector_length; i++) {
         LLVMValueRef id_ptr = draw_jit_header_id(gallivm, io_ptrs[i]);
         val = LLVMBuildExtractElement(builder, cliptmp, linear_inds[i], "");
         val = adjust_mask(gallivm, val);
#if DEBUG_STORE
         lp_build_printf(gallivm, "io = %p, index %d, clipmask = %x\n",
                         io_ptrs[i], inds[i], val);
#endif
         LLVMBuildStore(builder, val, id_ptr);
      }
   }

   /* store for each of the n vertices */
   for (i = 0; i < vector_length; i++) {
      store_aos(gallivm, io_ptrs[i], attr_index, aos[i]);
   }
}


static void
convert_to_aos(struct gallivm_state *gallivm,
               LLVMValueRef io,
               LLVMValueRef *indices,
               LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
               LLVMValueRef clipmask,
               int num_outputs,
               struct lp_type soa_type,
               boolean have_clipdist)
{
   LLVMBuilderRef builder = gallivm->builder;
   unsigned chan, attrib, i;

#if DEBUG_STORE
   lp_build_printf(gallivm, "   # storing begin\n");
#endif
   for (attrib = 0; attrib < num_outputs; ++attrib) {
      LLVMValueRef soa[TGSI_NUM_CHANNELS];
      LLVMValueRef aos[LP_MAX_VECTOR_WIDTH / 32];
      for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
         if (outputs[attrib][chan]) {
            LLVMValueRef out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
            lp_build_name(out, "output%u.%c", attrib, "xyzw"[chan]);
#if DEBUG_STORE
            lp_build_printf(gallivm, "output %d : %d ",
                            LLVMConstInt(LLVMInt32TypeInContext(gallivm->context),
                                         attrib, 0),
                            LLVMConstInt(LLVMInt32TypeInContext(gallivm->context),
                                         chan, 0));
            lp_build_print_value(gallivm, "val = ", out);
            {
               LLVMValueRef iv =
                  LLVMBuildBitCast(builder, out, lp_build_int_vec_type(gallivm, soa_type), "");
               
               lp_build_print_value(gallivm, "  ival = ", iv);
            }
#endif
            soa[chan] = out;
         }
         else {
            soa[chan] = 0;
         }
      }


      if (soa_type.length == TGSI_NUM_CHANNELS) {
         lp_build_transpose_aos(gallivm, soa_type, soa, aos);
      } else {
         lp_build_transpose_aos(gallivm, soa_type, soa, soa);

         for (i = 0; i < soa_type.length; ++i) {
            aos[i] = lp_build_extract_range(gallivm,
                                            soa[i % TGSI_NUM_CHANNELS],
                                            (i / TGSI_NUM_CHANNELS) * TGSI_NUM_CHANNELS,
                                            TGSI_NUM_CHANNELS);
         }
      }

      store_aos_array(gallivm,
                      soa_type,
                      io, indices,
                      aos,
                      attrib,
                      num_outputs,
                      clipmask, have_clipdist);
   }
#if DEBUG_STORE
   lp_build_printf(gallivm, "   # storing end\n");
#endif
}


/**
 * Stores original vertex positions in clip coordinates
 */
static void
store_clip(struct gallivm_state *gallivm,
           const struct lp_type vs_type,
           LLVMValueRef io_ptr,
           LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
           boolean pre_clip_pos, int idx)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef soa[4];
   LLVMValueRef aos[LP_MAX_VECTOR_LENGTH];
   LLVMValueRef indices[2];
   LLVMValueRef io_ptrs[LP_MAX_VECTOR_WIDTH / 32];
   LLVMValueRef inds[LP_MAX_VECTOR_WIDTH / 32];
   LLVMValueRef clip_ptrs[LP_MAX_VECTOR_WIDTH / 32];
   LLVMTypeRef clip_ptr_type =
      LLVMPointerType(LLVMVectorType(LLVMFloatTypeInContext(gallivm->context),
                                     4), 0);
   int i, j;

   indices[0] =
   indices[1] = lp_build_const_int32(gallivm, 0);

   for (i = 0; i < vs_type.length; i++) {
      inds[i] = lp_build_const_int32(gallivm, i);
      io_ptrs[i] = LLVMBuildGEP(builder, io_ptr, &inds[i], 1, "");
   }

   soa[0] = LLVMBuildLoad(builder, outputs[idx][0], ""); /*x0 x1 .. xn*/
   soa[1] = LLVMBuildLoad(builder, outputs[idx][1], ""); /*y0 y1 .. yn*/
   soa[2] = LLVMBuildLoad(builder, outputs[idx][2], ""); /*z0 z1 .. zn*/
   soa[3] = LLVMBuildLoad(builder, outputs[idx][3], ""); /*w0 w1 .. wn*/

   if (!pre_clip_pos) {
      for (i = 0; i < vs_type.length; i++) {
         clip_ptrs[i] = draw_jit_header_clip(gallivm, io_ptrs[i]);
      }
   } else {
      for (i = 0; i < vs_type.length; i++) {
         clip_ptrs[i] = draw_jit_header_pre_clip_pos(gallivm, io_ptrs[i]);
      }
   }

   lp_build_transpose_aos(gallivm, vs_type, soa, soa);
   for (i = 0; i < vs_type.length; ++i) {
      aos[i] = lp_build_extract_range(gallivm,
                                      soa[i % TGSI_NUM_CHANNELS],
                                      (i / TGSI_NUM_CHANNELS) * TGSI_NUM_CHANNELS,
                                      TGSI_NUM_CHANNELS);
   }

   for (j = 0; j < vs_type.length; j++) {
      LLVMValueRef clip_ptr;

      clip_ptr = LLVMBuildGEP(builder, clip_ptrs[j], indices, 2, "clipo");
      clip_ptr = LLVMBuildPointerCast(builder, clip_ptr, clip_ptr_type, "");

      /* Unaligned store */
      lp_set_store_alignment(LLVMBuildStore(builder, aos[j], clip_ptr), sizeof(float));
   }
}


/**
 * Transforms the outputs for viewport mapping
 */
static void
generate_viewport(struct draw_llvm_variant *variant,
                  LLVMBuilderRef builder,
                  struct lp_type vs_type,
                  LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
                  LLVMValueRef context_ptr)
{
   int i;
   struct gallivm_state *gallivm = variant->gallivm;
   struct lp_type f32_type = vs_type;
   const unsigned pos = variant->llvm->draw->vs.position_output;
   LLVMTypeRef vs_type_llvm = lp_build_vec_type(gallivm, vs_type);
   LLVMValueRef out3 = LLVMBuildLoad(builder, outputs[pos][3], ""); /*w0 w1 .. wn*/
   LLVMValueRef const1 = lp_build_const_vec(gallivm, f32_type, 1.0);       /*1.0 1.0 1.0 1.0*/
   LLVMValueRef vp_ptr = draw_jit_context_viewport(gallivm, context_ptr);

   /* for 1/w convention*/
   out3 = LLVMBuildFDiv(builder, const1, out3, "");
   LLVMBuildStore(builder, out3, outputs[pos][3]);

   /* Viewport Mapping */
   for (i=0; i<3; i++) {
      LLVMValueRef out = LLVMBuildLoad(builder, outputs[pos][i], ""); /*x0 x1 .. xn*/
      LLVMValueRef scale;
      LLVMValueRef trans;
      LLVMValueRef scale_i;
      LLVMValueRef trans_i;
      LLVMValueRef index;

      index = lp_build_const_int32(gallivm, i);
      scale_i = LLVMBuildGEP(builder, vp_ptr, &index, 1, "");

      index = lp_build_const_int32(gallivm, i+4);
      trans_i = LLVMBuildGEP(builder, vp_ptr, &index, 1, "");

      scale = lp_build_broadcast(gallivm, vs_type_llvm,
                                 LLVMBuildLoad(builder, scale_i, "scale"));
      trans = lp_build_broadcast(gallivm, vs_type_llvm,
                                 LLVMBuildLoad(builder, trans_i, "trans"));

      /* divide by w */
      out = LLVMBuildFMul(builder, out, out3, "");
      /* mult by scale */
      out = LLVMBuildFMul(builder, out, scale, "");
      /* add translation */
      out = LLVMBuildFAdd(builder, out, trans, "");

      /* store transformed outputs */
      LLVMBuildStore(builder, out, outputs[pos][i]);
   }

}


/**
 * Returns clipmask as nxi32 bitmask for the n vertices
 */
static LLVMValueRef
generate_clipmask(struct draw_llvm *llvm,
                  struct gallivm_state *gallivm,
                  struct lp_type vs_type,
                  LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
                  boolean clip_xy,
                  boolean clip_z,
                  boolean clip_user,
                  boolean clip_halfz,
                  unsigned ucp_enable,
                  LLVMValueRef context_ptr,
                  boolean *have_clipdist)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef mask; /* stores the <nxi32> clipmasks */
   LLVMValueRef test, temp;
   LLVMValueRef zero, shift;
   LLVMValueRef pos_x, pos_y, pos_z, pos_w;
   LLVMValueRef cv_x, cv_y, cv_z, cv_w;
   LLVMValueRef plane1, planes, plane_ptr, sum;
   struct lp_type f32_type = vs_type;
   struct lp_type i32_type = lp_int_type(vs_type);
   const unsigned pos = llvm->draw->vs.position_output;
   const unsigned cv = llvm->draw->vs.clipvertex_output;
   int num_written_clipdistance = llvm->draw->vs.vertex_shader->info.num_written_clipdistance;
   bool have_cd = false;
   unsigned cd[2];

   cd[0] = llvm->draw->vs.clipdistance_output[0];
   cd[1] = llvm->draw->vs.clipdistance_output[1];

   if (cd[0] != pos || cd[1] != pos)
      have_cd = true;

   if (num_written_clipdistance && !clip_user) {
      clip_user = true;
      ucp_enable = (1 << num_written_clipdistance) - 1;
   }

   mask = lp_build_const_int_vec(gallivm, i32_type, 0);
   temp = lp_build_const_int_vec(gallivm, i32_type, 0);
   zero = lp_build_const_vec(gallivm, f32_type, 0);         /* 0.0f 0.0f 0.0f 0.0f */
   shift = lp_build_const_int_vec(gallivm, i32_type, 1);    /* 1 1 1 1 */

   /*
    * load clipvertex and position from correct locations.
    * if they are the same just load them once.
    */
   pos_x = LLVMBuildLoad(builder, outputs[pos][0], ""); /*x0 x1 .. xn */
   pos_y = LLVMBuildLoad(builder, outputs[pos][1], ""); /*y0 y1 .. yn */
   pos_z = LLVMBuildLoad(builder, outputs[pos][2], ""); /*z0 z1 .. zn */
   pos_w = LLVMBuildLoad(builder, outputs[pos][3], ""); /*w0 w1 .. wn */

   if (clip_user && cv != pos) {
      cv_x = LLVMBuildLoad(builder, outputs[cv][0], ""); /*x0 x1 .. xn */
      cv_y = LLVMBuildLoad(builder, outputs[cv][1], ""); /*y0 y1 .. yn */
      cv_z = LLVMBuildLoad(builder, outputs[cv][2], ""); /*z0 z1 .. zn */
      cv_w = LLVMBuildLoad(builder, outputs[cv][3], ""); /*w0 w1 .. wn */
   } else {
      cv_x = pos_x;
      cv_y = pos_y;
      cv_z = pos_z;
      cv_w = pos_w;
   }

   /* Cliptest, for hardwired planes */
   if (clip_xy) {
      /* plane 1 */
      test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, pos_x , pos_w);
      temp = shift;
      test = LLVMBuildAnd(builder, test, temp, "");
      mask = test;

      /* plane 2 */
      test = LLVMBuildFAdd(builder, pos_x, pos_w, "");
      test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, test);
      temp = LLVMBuildShl(builder, temp, shift, "");
      test = LLVMBuildAnd(builder, test, temp, "");
      mask = LLVMBuildOr(builder, mask, test, "");

      /* plane 3 */
      test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, pos_y, pos_w);
      temp = LLVMBuildShl(builder, temp, shift, "");
      test = LLVMBuildAnd(builder, test, temp, "");
      mask = LLVMBuildOr(builder, mask, test, "");

      /* plane 4 */
      test = LLVMBuildFAdd(builder, pos_y, pos_w, "");
      test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, test);
      temp = LLVMBuildShl(builder, temp, shift, "");
      test = LLVMBuildAnd(builder, test, temp, "");
      mask = LLVMBuildOr(builder, mask, test, "");
   }

   if (clip_z) {
      temp = lp_build_const_int_vec(gallivm, i32_type, 16);
      if (clip_halfz) {
         /* plane 5 */
         test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, pos_z);
         test = LLVMBuildAnd(builder, test, temp, "");
         mask = LLVMBuildOr(builder, mask, test, "");
      }
      else {
         /* plane 5 */
         test = LLVMBuildFAdd(builder, pos_z, pos_w, "");
         test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, test);
         test = LLVMBuildAnd(builder, test, temp, "");
         mask = LLVMBuildOr(builder, mask, test, "");
      }
      /* plane 6 */
      test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, pos_z, pos_w);
      temp = LLVMBuildShl(builder, temp, shift, "");
      test = LLVMBuildAnd(builder, test, temp, "");
      mask = LLVMBuildOr(builder, mask, test, "");
   }

   if (clip_user) {
      LLVMValueRef planes_ptr = draw_jit_context_planes(gallivm, context_ptr);
      LLVMValueRef indices[3];
      LLVMValueRef is_nan_or_inf;

      /* userclip planes */
      while (ucp_enable) {
         unsigned plane_idx = ffs(ucp_enable)-1;
         ucp_enable &= ~(1 << plane_idx);
         plane_idx += 6;

         if (have_cd && num_written_clipdistance) {
            LLVMValueRef clipdist;
            int i;
            i = plane_idx - 6;

            *have_clipdist = TRUE;
            if (i < 4) {
               clipdist = LLVMBuildLoad(builder, outputs[cd[0]][i], "");
            } else {
               clipdist = LLVMBuildLoad(builder, outputs[cd[1]][i-4], "");
            }
            test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, clipdist);
            is_nan_or_inf = lp_build_is_inf_or_nan(gallivm, vs_type, clipdist);
            test = LLVMBuildOr(builder, test, is_nan_or_inf, "");
            temp = lp_build_const_int_vec(gallivm, i32_type, 1 << plane_idx);
            test = LLVMBuildAnd(builder, test, temp, "");
            mask = LLVMBuildOr(builder, mask, test, "");
         } else {
            LLVMTypeRef vs_type_llvm = lp_build_vec_type(gallivm, vs_type);
            indices[0] = lp_build_const_int32(gallivm, 0);
            indices[1] = lp_build_const_int32(gallivm, plane_idx);

            indices[2] = lp_build_const_int32(gallivm, 0);
            plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
            plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_x");
            planes = lp_build_broadcast(gallivm, vs_type_llvm, plane1);
            sum = LLVMBuildFMul(builder, planes, cv_x, "");

            indices[2] = lp_build_const_int32(gallivm, 1);
            plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
            plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_y");
            planes = lp_build_broadcast(gallivm, vs_type_llvm, plane1);
            test = LLVMBuildFMul(builder, planes, cv_y, "");
            sum = LLVMBuildFAdd(builder, sum, test, "");

            indices[2] = lp_build_const_int32(gallivm, 2);
            plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
            plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_z");
            planes = lp_build_broadcast(gallivm, vs_type_llvm, plane1);
            test = LLVMBuildFMul(builder, planes, cv_z, "");
            sum = LLVMBuildFAdd(builder, sum, test, "");

            indices[2] = lp_build_const_int32(gallivm, 3);
            plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
            plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_w");
            planes = lp_build_broadcast(gallivm, vs_type_llvm, plane1);
            test = LLVMBuildFMul(builder, planes, cv_w, "");
            sum = LLVMBuildFAdd(builder, sum, test, "");

            test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, sum);
            temp = lp_build_const_int_vec(gallivm, i32_type, 1 << plane_idx);
            test = LLVMBuildAnd(builder, test, temp, "");
            mask = LLVMBuildOr(builder, mask, test, "");
         }
      }
   }
   return mask;
}


/**
 * Returns boolean if any clipping has occurred
 * Used zero/non-zero i32 value to represent boolean
 */
static LLVMValueRef
clipmask_booli32(struct gallivm_state *gallivm,
                 const struct lp_type vs_type,
                 LLVMValueRef clipmask_bool_ptr)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMValueRef clipmask_bool = LLVMBuildLoad(builder, clipmask_bool_ptr, "");
   LLVMValueRef ret = LLVMConstNull(int32_type);
   LLVMValueRef temp;
   int i;

   /*
    * Can do this with log2(vector length) pack instructions and one extract
    * (as we don't actually need a or) with sse2 which would be way better.
    */
   for (i=0; i < vs_type.length; i++) {
      temp = LLVMBuildExtractElement(builder, clipmask_bool,
                                     lp_build_const_int32(gallivm, i) , "");
      ret = LLVMBuildOr(builder, ret, temp, "");
   }
   return ret;
}

static LLVMValueRef
draw_gs_llvm_fetch_input(const struct lp_build_tgsi_gs_iface *gs_iface,
                         struct lp_build_tgsi_context * bld_base,
                         boolean is_vindex_indirect,
                         LLVMValueRef vertex_index,
                         boolean is_aindex_indirect,
                         LLVMValueRef attrib_index,
                         LLVMValueRef swizzle_index)
{
   const struct draw_gs_llvm_iface *gs = draw_gs_llvm_iface(gs_iface);
   struct gallivm_state *gallivm = bld_base->base.gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef indices[3];
   LLVMValueRef res;
   struct lp_type type = bld_base->base.type;

   if (is_vindex_indirect || is_aindex_indirect) {
      int i;
      res = bld_base->base.zero;
      for (i = 0; i < type.length; ++i) {
         LLVMValueRef idx = lp_build_const_int32(gallivm, i);
         LLVMValueRef vert_chan_index = vertex_index;
         LLVMValueRef attr_chan_index = attrib_index;
         LLVMValueRef channel_vec, value;

         if (is_vindex_indirect) {
            vert_chan_index = LLVMBuildExtractElement(builder,
                                                      vertex_index, idx, "");
         }
         if (is_aindex_indirect) {
            attr_chan_index = LLVMBuildExtractElement(builder,
                                                      attrib_index, idx, "");
         }

         indices[0] = vert_chan_index;
         indices[1] = attr_chan_index;
         indices[2] = swizzle_index;

         channel_vec = LLVMBuildGEP(builder, gs->input, indices, 3, "");
         channel_vec = LLVMBuildLoad(builder, channel_vec, "");
         value = LLVMBuildExtractElement(builder, channel_vec, idx, "");

         res = LLVMBuildInsertElement(builder, res, value, idx, "");
      }
   } else {
      indices[0] = vertex_index;
      indices[1] = attrib_index;
      indices[2] = swizzle_index;

      res = LLVMBuildGEP(builder, gs->input, indices, 3, "");
      res = LLVMBuildLoad(builder, res, "");
   }

   return res;
}

static void
draw_gs_llvm_emit_vertex(const struct lp_build_tgsi_gs_iface *gs_base,
                         struct lp_build_tgsi_context * bld_base,
                         LLVMValueRef (*outputs)[4],
                         LLVMValueRef emitted_vertices_vec)
{
   const struct draw_gs_llvm_iface *gs_iface = draw_gs_llvm_iface(gs_base);
   struct draw_gs_llvm_variant *variant = gs_iface->variant;
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type gs_type = bld_base->base.type;
   LLVMValueRef clipmask = lp_build_const_int_vec(gallivm,
                                                  lp_int_type(gs_type), 0);
   LLVMValueRef indices[LP_MAX_VECTOR_LENGTH];
   LLVMValueRef next_prim_offset =
      lp_build_const_int32(gallivm, variant->shader->base.primitive_boundary);
   LLVMValueRef io = variant->io_ptr;
   unsigned i;
   const struct tgsi_shader_info *gs_info = &variant->shader->base.info;

   for (i = 0; i < gs_type.length; ++i) {
      LLVMValueRef ind = lp_build_const_int32(gallivm, i);
      LLVMValueRef currently_emitted =
         LLVMBuildExtractElement(builder, emitted_vertices_vec, ind, "");
      indices[i] = LLVMBuildMul(builder, ind, next_prim_offset, "");
      indices[i] = LLVMBuildAdd(builder, indices[i], currently_emitted, "");
   }

   convert_to_aos(gallivm, io, indices,
                  outputs, clipmask,
                  gs_info->num_outputs, gs_type,
                  FALSE);
}

static void
draw_gs_llvm_end_primitive(const struct lp_build_tgsi_gs_iface *gs_base,
                           struct lp_build_tgsi_context * bld_base,
                           LLVMValueRef verts_per_prim_vec,
                           LLVMValueRef emitted_prims_vec)
{
   const struct draw_gs_llvm_iface *gs_iface = draw_gs_llvm_iface(gs_base);
   struct draw_gs_llvm_variant *variant = gs_iface->variant;
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef prim_lengts_ptr =
      draw_gs_jit_prim_lengths(variant->gallivm, variant->context_ptr);
   unsigned i;

   for (i = 0; i < bld_base->base.type.length; ++i) {
      LLVMValueRef ind = lp_build_const_int32(gallivm, i);
      LLVMValueRef prims_emitted =
         LLVMBuildExtractElement(builder, emitted_prims_vec, ind, "");
      LLVMValueRef store_ptr;
      LLVMValueRef num_vertices =
         LLVMBuildExtractElement(builder, verts_per_prim_vec, ind, "");

      store_ptr = LLVMBuildGEP(builder, prim_lengts_ptr, &prims_emitted, 1, "");
      store_ptr = LLVMBuildLoad(builder, store_ptr, "");
      store_ptr = LLVMBuildGEP(builder, store_ptr, &ind, 1, "");
      LLVMBuildStore(builder, num_vertices, store_ptr);
   }
}

static void
draw_gs_llvm_epilogue(const struct lp_build_tgsi_gs_iface *gs_base,
                      struct lp_build_tgsi_context * bld_base,
                      LLVMValueRef total_emitted_vertices_vec,
                      LLVMValueRef emitted_prims_vec)
{
   const struct draw_gs_llvm_iface *gs_iface = draw_gs_llvm_iface(gs_base);
   struct draw_gs_llvm_variant *variant = gs_iface->variant;
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef emitted_verts_ptr =
      draw_gs_jit_emitted_vertices(gallivm, variant->context_ptr);
   LLVMValueRef emitted_prims_ptr =
      draw_gs_jit_emitted_prims(gallivm, variant->context_ptr);
   LLVMValueRef zero = lp_build_const_int32(gallivm, 0);
   
   emitted_verts_ptr = LLVMBuildGEP(builder, emitted_verts_ptr, &zero, 0, "");
   emitted_prims_ptr = LLVMBuildGEP(builder, emitted_prims_ptr, &zero, 0, "");

   LLVMBuildStore(builder, total_emitted_vertices_vec, emitted_verts_ptr);
   LLVMBuildStore(builder, emitted_prims_vec, emitted_prims_ptr);
}

static void
draw_llvm_generate(struct draw_llvm *llvm, struct draw_llvm_variant *variant,
                   boolean elts)
{
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMContextRef context = gallivm->context;
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(context);
   LLVMTypeRef arg_types[10];
   unsigned num_arg_types =
      elts ? Elements(arg_types) : Elements(arg_types) - 1;
   LLVMTypeRef func_type;
   LLVMValueRef context_ptr;
   LLVMBasicBlockRef block;
   LLVMBuilderRef builder;
   struct lp_type vs_type;
   LLVMValueRef end, start;
   LLVMValueRef count, fetch_elts, fetch_elt_max, fetch_count;
   LLVMValueRef vertex_id_offset;
   LLVMValueRef stride, step, io_itr;
   LLVMValueRef io_ptr, vbuffers_ptr, vb_ptr;
   LLVMValueRef zero = lp_build_const_int32(gallivm, 0);
   LLVMValueRef one = lp_build_const_int32(gallivm, 1);
   struct draw_context *draw = llvm->draw;
   const struct tgsi_shader_info *vs_info = &draw->vs.vertex_shader->info;
   unsigned i, j;
   struct lp_build_context bld;
   struct lp_build_loop_state lp_loop;
   const int vector_length = lp_native_vector_width / 32;
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][TGSI_NUM_CHANNELS];
   LLVMValueRef fetch_max;
   struct lp_build_sampler_soa *sampler = 0;
   LLVMValueRef ret, clipmask_bool_ptr;
   const struct draw_geometry_shader *gs = draw->gs.geometry_shader;
   struct draw_llvm_variant_key *key = &variant->key;
   /* If geometry shader is present we need to skip both the viewport
    * transformation and clipping otherwise the inputs to the geometry
    * shader will be incorrect.
    */
   const boolean bypass_viewport = gs || key->bypass_viewport;
   const boolean enable_cliptest = !gs && (key->clip_xy ||
                                           key->clip_z  ||
                                           key->clip_user);
   LLVMValueRef variant_func;
   const unsigned pos = llvm->draw->vs.position_output;
   const unsigned cv = llvm->draw->vs.clipvertex_output;
   boolean have_clipdist = FALSE;
   struct lp_bld_tgsi_system_values system_values;

   memset(&system_values, 0, sizeof(system_values));

   i = 0;
   arg_types[i++] = get_context_ptr_type(variant);       /* context */
   arg_types[i++] = get_vertex_header_ptr_type(variant); /* vertex_header */
   arg_types[i++] = get_buffer_ptr_type(variant);        /* vbuffers */
   if (elts) {
      arg_types[i++] = LLVMPointerType(int32_type, 0);/* fetch_elts  */
      arg_types[i++] = int32_type;                  /* fetch_elt_max */
   } else
      arg_types[i++] = int32_type;                  /* start */
   arg_types[i++] = int32_type;                     /* fetch_count / count */
   arg_types[i++] = int32_type;                     /* stride */
   arg_types[i++] = get_vb_ptr_type(variant);       /* pipe_vertex_buffer's */
   arg_types[i++] = int32_type;                     /* instance_id */
   arg_types[i++] = int32_type;                     /* vertex_id_offset */

   func_type = LLVMFunctionType(int32_type, arg_types, num_arg_types, 0);

   variant_func = LLVMAddFunction(gallivm->module,
                                  elts ? "draw_llvm_shader_elts" : "draw_llvm_shader",
                                  func_type);

   if (elts)
      variant->function_elts = variant_func;
   else
      variant->function = variant_func;

   LLVMSetFunctionCallConv(variant_func, LLVMCCallConv);
   for (i = 0; i < num_arg_types; ++i)
      if (LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
         LLVMAddAttribute(LLVMGetParam(variant_func, i),
                          LLVMNoAliasAttribute);

   context_ptr               = LLVMGetParam(variant_func, 0);
   io_ptr                    = LLVMGetParam(variant_func, 1);
   vbuffers_ptr              = LLVMGetParam(variant_func, 2);
   stride                    = LLVMGetParam(variant_func, 5 + (elts ? 1 : 0));
   vb_ptr                    = LLVMGetParam(variant_func, 6 + (elts ? 1 : 0));
   system_values.instance_id = LLVMGetParam(variant_func, 7 + (elts ? 1 : 0));
   vertex_id_offset          = LLVMGetParam(variant_func, 8 + (elts ? 1 : 0));

   lp_build_name(context_ptr, "context");
   lp_build_name(io_ptr, "io");
   lp_build_name(vbuffers_ptr, "vbuffers");
   lp_build_name(stride, "stride");
   lp_build_name(vb_ptr, "vb");
   lp_build_name(system_values.instance_id, "instance_id");
   lp_build_name(vertex_id_offset, "vertex_id_offset");

   if (elts) {
      fetch_elts    = LLVMGetParam(variant_func, 3);
      fetch_elt_max = LLVMGetParam(variant_func, 4);
      fetch_count   = LLVMGetParam(variant_func, 5);
      lp_build_name(fetch_elts, "fetch_elts");
      lp_build_name(fetch_elt_max, "fetch_elt_max");
      lp_build_name(fetch_count, "fetch_count");
      start = count = NULL;
   }
   else {
      start        = LLVMGetParam(variant_func, 3);
      count        = LLVMGetParam(variant_func, 4);
      lp_build_name(start, "start");
      lp_build_name(count, "count");
      fetch_elts = fetch_count = NULL;
   }

   /*
    * Function body
    */

   block = LLVMAppendBasicBlockInContext(gallivm->context, variant_func, "entry");
   builder = gallivm->builder;
   LLVMPositionBuilderAtEnd(builder, block);

   lp_build_context_init(&bld, gallivm, lp_type_int(32));

   memset(&vs_type, 0, sizeof vs_type);
   vs_type.floating = TRUE; /* floating point values */
   vs_type.sign = TRUE;     /* values are signed */
   vs_type.norm = FALSE;    /* values are not limited to [0,1] or [-1,1] */
   vs_type.width = 32;      /* 32-bit float */
   vs_type.length = vector_length;

   /* hold temporary "bool" clipmask */
   clipmask_bool_ptr = lp_build_alloca(gallivm, lp_build_int_vec_type(gallivm, vs_type), "");
   LLVMBuildStore(builder, lp_build_zero(gallivm, lp_int_type(vs_type)), clipmask_bool_ptr);

   /* code generated texture sampling */
   sampler = draw_llvm_sampler_soa_create(
      draw_llvm_variant_key_samplers(key),
      context_ptr);

   if (elts) {
      start = zero;
      end = fetch_count;
      count = fetch_count;
   }
   else {
      end = lp_build_add(&bld, start, count);
   }

   step = lp_build_const_int32(gallivm, vector_length);

   fetch_max = LLVMBuildSub(builder, end, one, "fetch_max");

   lp_build_loop_begin(&lp_loop, gallivm, zero);
   {
      LLVMValueRef inputs[PIPE_MAX_SHADER_INPUTS][TGSI_NUM_CHANNELS];
      LLVMValueRef aos_attribs[PIPE_MAX_SHADER_INPUTS][LP_MAX_VECTOR_WIDTH / 32] = { { 0 } };
      LLVMValueRef io;
      LLVMValueRef clipmask;   /* holds the clipmask value */
      const LLVMValueRef (*ptr_aos)[TGSI_NUM_CHANNELS];

      io_itr = lp_loop.counter;

      io = LLVMBuildGEP(builder, io_ptr, &io_itr, 1, "");
#if DEBUG_STORE
      lp_build_printf(gallivm, " --- io %d = %p, loop counter %d\n",
                      io_itr, io, lp_loop.counter);
#endif
      system_values.vertex_id = lp_build_zero(gallivm, lp_type_uint_vec(32, 32*vector_length));
      for (i = 0; i < vector_length; ++i) {
         LLVMValueRef vert_index =
            LLVMBuildAdd(builder,
                         lp_loop.counter,
                         lp_build_const_int32(gallivm, i), "");
         LLVMValueRef true_index =
            LLVMBuildAdd(builder, start, vert_index, "");
         LLVMValueRef vertex_id;

         /* make sure we're not out of bounds which can happen
          * if fetch_count % 4 != 0, because on the last iteration
          * a few of the 4 vertex fetches will be out of bounds */
         true_index = lp_build_min(&bld, true_index, fetch_max);

         if (elts) {
            LLVMValueRef fetch_ptr;
            LLVMValueRef index_overflowed;
            LLVMValueRef index_ptr =
               lp_build_alloca(
                  gallivm,
                  lp_build_vec_type(gallivm, lp_type_int(32)), "");
            struct lp_build_if_state if_ctx;
            index_overflowed = LLVMBuildICmp(builder, LLVMIntUGT,
                                             true_index, fetch_elt_max,
                                             "index_overflowed");

            lp_build_if(&if_ctx, gallivm, index_overflowed);
            {
               /* Generate maximum possible index so that
                * generate_fetch can treat it just like
                * any other overflow and return zeros.
                * We don't have to worry about the restart
                * primitive index because it has already been 
                * handled
                */
               LLVMValueRef val =
                  lp_build_const_int32(gallivm, 0xffffffff);
               LLVMBuildStore(builder, val, index_ptr);
            }
            lp_build_else(&if_ctx);
            {
               LLVMValueRef val;
               fetch_ptr = LLVMBuildGEP(builder, fetch_elts,
                                        &true_index, 1, "");
               val = LLVMBuildLoad(builder, fetch_ptr, "");
               LLVMBuildStore(builder, val, index_ptr);
            }
            lp_build_endif(&if_ctx);
            true_index = LLVMBuildLoad(builder, index_ptr, "true_index");
         }
         /* in the paths with elts vertex id has to be unaffected by the
          * index bias and because indices inside our elements array have
          * already had index bias applied we need to subtract it here to
          * get back to the original index.
          * in the linear paths vertex id has to be unaffected by the
          * original start index and because we abuse the 'start' variable
          * to either represent the actual start index or the index at which
          * the primitive was split (we split rendering into chunks of at
          * most 4095-vertices) we need to back out the original start
          * index out of our vertex id here.
          */
         vertex_id = LLVMBuildSub(builder, true_index, vertex_id_offset, "");

         system_values.vertex_id = LLVMBuildInsertElement(
            gallivm->builder,
            system_values.vertex_id, vertex_id,
            lp_build_const_int32(gallivm, i), "");

         for (j = 0; j < draw->pt.nr_vertex_elements; ++j) {
            struct pipe_vertex_element *velem = &draw->pt.vertex_element[j];
            LLVMValueRef vb_index =
               lp_build_const_int32(gallivm, velem->vertex_buffer_index);
            LLVMValueRef vb = LLVMBuildGEP(builder, vb_ptr, &vb_index, 1, "");
            generate_fetch(gallivm, draw, vbuffers_ptr,
                           &aos_attribs[j][i], velem, vb, true_index,
                           system_values.instance_id);
         }
      }
      convert_to_soa(gallivm, aos_attribs, inputs,
                     draw->pt.nr_vertex_elements, vs_type);

      ptr_aos = (const LLVMValueRef (*)[TGSI_NUM_CHANNELS]) inputs;
      generate_vs(variant,
                  builder,
                  vs_type,
                  outputs,
                  ptr_aos,
                  &system_values,
                  context_ptr,
                  sampler,
                  key->clamp_vertex_color);

      if (pos != -1 && cv != -1) {
         /* store original positions in clip before further manipulation */
         store_clip(gallivm, vs_type, io, outputs, 0, cv);
         store_clip(gallivm, vs_type, io, outputs, 1, pos);

         /* do cliptest */
         if (enable_cliptest) {
            LLVMValueRef temp = LLVMBuildLoad(builder, clipmask_bool_ptr, "");
            /* allocate clipmask, assign it integer type */
            clipmask = generate_clipmask(llvm,
                                         gallivm,
                                         vs_type,
                                         outputs,
                                         key->clip_xy,
                                         key->clip_z,
                                         key->clip_user,
                                         key->clip_halfz,
                                         key->ucp_enable,
                                         context_ptr, &have_clipdist);
            temp = LLVMBuildOr(builder, clipmask, temp, "");
            /* store temporary clipping boolean value */
            LLVMBuildStore(builder, temp, clipmask_bool_ptr);
         }
         else {
            clipmask = lp_build_const_int_vec(gallivm, lp_int_type(vs_type), 0);
         }

         /* do viewport mapping */
         if (!bypass_viewport) {
            generate_viewport(variant, builder, vs_type, outputs, context_ptr);
         }
      }
      else {
         clipmask = lp_build_const_int_vec(gallivm, lp_int_type(vs_type), 0);
      }

      /* store clipmask in vertex header,
       * original positions in clip
       * and transformed positions in data
       */
      convert_to_aos(gallivm, io, NULL, outputs, clipmask,
                     vs_info->num_outputs, vs_type,
                     have_clipdist);
   }
   lp_build_loop_end_cond(&lp_loop, count, step, LLVMIntUGE);

   sampler->destroy(sampler);

   /* return clipping boolean value for function */
   ret = clipmask_booli32(gallivm, vs_type, clipmask_bool_ptr);

   LLVMBuildRet(builder, ret);

   gallivm_verify_function(gallivm, variant_func);
}


struct draw_llvm_variant_key *
draw_llvm_make_variant_key(struct draw_llvm *llvm, char *store)
{
   unsigned i;
   struct draw_llvm_variant_key *key;
   struct draw_sampler_static_state *draw_sampler;

   key = (struct draw_llvm_variant_key *)store;

   key->clamp_vertex_color = llvm->draw->rasterizer->clamp_vertex_color; /**/

   /* Presumably all variants of the shader should have the same
    * number of vertex elements - ie the number of shader inputs.
    * NOTE: we NEED to store the needed number of needed inputs
    * here, not the number of provided elements to match keysize
    * (and the offset of sampler state in the key).
    */
   key->nr_vertex_elements = llvm->draw->vs.vertex_shader->info.file_max[TGSI_FILE_INPUT] + 1;
   assert(key->nr_vertex_elements <= llvm->draw->pt.nr_vertex_elements);

   /* will have to rig this up properly later */
   key->clip_xy = llvm->draw->clip_xy;
   key->clip_z = llvm->draw->clip_z;
   key->clip_user = llvm->draw->clip_user;
   key->bypass_viewport = llvm->draw->identity_viewport;
   key->clip_halfz = llvm->draw->rasterizer->clip_halfz;
   key->need_edgeflags = (llvm->draw->vs.edgeflag_output ? TRUE : FALSE);
   key->ucp_enable = llvm->draw->rasterizer->clip_plane_enable;
   key->has_gs = llvm->draw->gs.geometry_shader != NULL;
   key->num_outputs = draw_total_vs_outputs(llvm->draw);
   key->pad1 = 0;

   /* All variants of this shader will have the same value for
    * nr_samplers.  Not yet trying to compact away holes in the
    * sampler array.
    */
   key->nr_samplers = llvm->draw->vs.vertex_shader->info.file_max[TGSI_FILE_SAMPLER] + 1;
   if (llvm->draw->vs.vertex_shader->info.file_max[TGSI_FILE_SAMPLER_VIEW] != -1) {
      key->nr_sampler_views =
         llvm->draw->vs.vertex_shader->info.file_max[TGSI_FILE_SAMPLER_VIEW] + 1;
   }
   else {
      key->nr_sampler_views = key->nr_samplers;
   }

   draw_sampler = draw_llvm_variant_key_samplers(key);

   memcpy(key->vertex_element,
          llvm->draw->pt.vertex_element,
          sizeof(struct pipe_vertex_element) * key->nr_vertex_elements);

   memset(draw_sampler, 0, MAX2(key->nr_samplers, key->nr_sampler_views) * sizeof *draw_sampler);

   for (i = 0 ; i < key->nr_samplers; i++) {
      lp_sampler_static_sampler_state(&draw_sampler[i].sampler_state,
                                      llvm->draw->samplers[PIPE_SHADER_VERTEX][i]);
   }
   for (i = 0 ; i < key->nr_sampler_views; i++) {
      lp_sampler_static_texture_state(&draw_sampler[i].texture_state,
                                      llvm->draw->sampler_views[PIPE_SHADER_VERTEX][i]);
   }

   return key;
}


void
draw_llvm_dump_variant_key(struct draw_llvm_variant_key *key)
{
   unsigned i;
   struct draw_sampler_static_state *sampler = draw_llvm_variant_key_samplers(key);

   debug_printf("clamp_vertex_color = %u\n", key->clamp_vertex_color);
   debug_printf("clip_xy = %u\n", key->clip_xy);
   debug_printf("clip_z = %u\n", key->clip_z);
   debug_printf("clip_user = %u\n", key->clip_user);
   debug_printf("bypass_viewport = %u\n", key->bypass_viewport);
   debug_printf("clip_halfz = %u\n", key->clip_halfz);
   debug_printf("need_edgeflags = %u\n", key->need_edgeflags);
   debug_printf("has_gs = %u\n", key->has_gs);
   debug_printf("ucp_enable = %u\n", key->ucp_enable);

   for (i = 0 ; i < key->nr_vertex_elements; i++) {
      debug_printf("vertex_element[%i].src_offset = %u\n", i, key->vertex_element[i].src_offset);
      debug_printf("vertex_element[%i].instance_divisor = %u\n", i, key->vertex_element[i].instance_divisor);
      debug_printf("vertex_element[%i].vertex_buffer_index = %u\n", i, key->vertex_element[i].vertex_buffer_index);
      debug_printf("vertex_element[%i].src_format = %s\n", i, util_format_name(key->vertex_element[i].src_format));
   }

   for (i = 0 ; i < key->nr_sampler_views; i++) {
      debug_printf("sampler[%i].src_format = %s\n", i, util_format_name(sampler[i].texture_state.format));
   }
}


void
draw_llvm_set_mapped_texture(struct draw_context *draw,
                             unsigned shader_stage,
                             unsigned sview_idx,
                             uint32_t width, uint32_t height, uint32_t depth,
                             uint32_t first_level, uint32_t last_level,
                             const void *base_ptr,
                             uint32_t row_stride[PIPE_MAX_TEXTURE_LEVELS],
                             uint32_t img_stride[PIPE_MAX_TEXTURE_LEVELS],
                             uint32_t mip_offsets[PIPE_MAX_TEXTURE_LEVELS])
{
   unsigned j;
   struct draw_jit_texture *jit_tex;

   assert(shader_stage == PIPE_SHADER_VERTEX ||
          shader_stage == PIPE_SHADER_GEOMETRY);

   if (shader_stage == PIPE_SHADER_VERTEX) {
      assert(sview_idx < Elements(draw->llvm->jit_context.textures));

      jit_tex = &draw->llvm->jit_context.textures[sview_idx];
   } else if (shader_stage == PIPE_SHADER_GEOMETRY) {
      assert(sview_idx < Elements(draw->llvm->gs_jit_context.textures));

      jit_tex = &draw->llvm->gs_jit_context.textures[sview_idx];
   } else {
      assert(0);
      return;
   }

   jit_tex->width = width;
   jit_tex->height = height;
   jit_tex->depth = depth;
   jit_tex->first_level = first_level;
   jit_tex->last_level = last_level;
   jit_tex->base = base_ptr;

   for (j = first_level; j <= last_level; j++) {
      jit_tex->mip_offsets[j] = mip_offsets[j];
      jit_tex->row_stride[j] = row_stride[j];
      jit_tex->img_stride[j] = img_stride[j];
   }
}


void
draw_llvm_set_sampler_state(struct draw_context *draw, 
                            unsigned shader_type)
{
   unsigned i;

   if (shader_type == PIPE_SHADER_VERTEX) {
      for (i = 0; i < draw->num_samplers[PIPE_SHADER_VERTEX]; i++) {
         struct draw_jit_sampler *jit_sam = &draw->llvm->jit_context.samplers[i];

         if (draw->samplers[i]) {
            const struct pipe_sampler_state *s
               = draw->samplers[PIPE_SHADER_VERTEX][i];
            jit_sam->min_lod = s->min_lod;
            jit_sam->max_lod = s->max_lod;
            jit_sam->lod_bias = s->lod_bias;
            COPY_4V(jit_sam->border_color, s->border_color.f);
         }
      }
   } else if (shader_type == PIPE_SHADER_GEOMETRY) {
      for (i = 0; i < draw->num_samplers[PIPE_SHADER_GEOMETRY]; i++) {
         struct draw_jit_sampler *jit_sam = &draw->llvm->gs_jit_context.samplers[i];

         if (draw->samplers[i]) {
            const struct pipe_sampler_state *s
               = draw->samplers[PIPE_SHADER_GEOMETRY][i];
            jit_sam->min_lod = s->min_lod;
            jit_sam->max_lod = s->max_lod;
            jit_sam->lod_bias = s->lod_bias;
            COPY_4V(jit_sam->border_color, s->border_color.f);
         }
      }
   }
}


void
draw_llvm_destroy_variant(struct draw_llvm_variant *variant)
{
   struct draw_llvm *llvm = variant->llvm;

   if (variant->function_elts) {
      gallivm_free_function(variant->gallivm,
                            variant->function_elts, variant->jit_func_elts);
   }

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function, variant->jit_func);
   }

   gallivm_destroy(variant->gallivm);

   remove_from_list(&variant->list_item_local);
   variant->shader->variants_cached--;
   remove_from_list(&variant->list_item_global);
   llvm->nr_variants--;
   FREE(variant);
}


/**
 * Create LLVM types for various structures.
 */
static void
create_gs_jit_types(struct draw_gs_llvm_variant *var)
{
   struct gallivm_state *gallivm = var->gallivm;
   LLVMTypeRef texture_type, sampler_type, context_type;

   texture_type = create_jit_texture_type(gallivm, "texture");
   sampler_type = create_jit_sampler_type(gallivm, "sampler");

   context_type = create_gs_jit_context_type(gallivm,
                                             var->shader->base.vector_length,
                                             texture_type, sampler_type,
                                             "draw_gs_jit_context");
   var->context_ptr_type = LLVMPointerType(context_type, 0);

   var->input_array_type = create_gs_jit_input_type(gallivm);
}

static LLVMTypeRef
get_gs_context_ptr_type(struct draw_gs_llvm_variant *variant)
{
   if (!variant->context_ptr_type)
      create_gs_jit_types(variant);
   return variant->context_ptr_type;
}

static LLVMValueRef
generate_mask_value(struct draw_gs_llvm_variant *variant,
                    struct lp_type gs_type)
{
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type mask_type = lp_int_type(gs_type);
   LLVMValueRef num_prims;
   LLVMValueRef mask_val = lp_build_const_vec(gallivm, mask_type, 0);
   unsigned i;

   num_prims = lp_build_broadcast(gallivm, lp_build_vec_type(gallivm, mask_type),
                                  variant->num_prims);
   for (i = 0; i <= gs_type.length; i++) {
      LLVMValueRef idx = lp_build_const_int32(gallivm, i);
      mask_val = LLVMBuildInsertElement(builder, mask_val, idx, idx, "");
   }
   mask_val = lp_build_compare(gallivm, mask_type,
                               PIPE_FUNC_GREATER, num_prims, mask_val);

   return mask_val;
}

static void
draw_gs_llvm_generate(struct draw_llvm *llvm,
                      struct draw_gs_llvm_variant *variant)
{
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMContextRef context = gallivm->context;
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(context);
   LLVMTypeRef arg_types[6];
   LLVMTypeRef func_type;
   LLVMValueRef variant_func;
   LLVMValueRef context_ptr;
   LLVMValueRef prim_id_ptr;
   LLVMBasicBlockRef block;
   LLVMBuilderRef builder;
   LLVMValueRef io_ptr, input_array, num_prims, mask_val;
   struct lp_build_sampler_soa *sampler = 0;
   struct lp_build_context bld;
   struct lp_bld_tgsi_system_values system_values;
   struct lp_type gs_type;
   unsigned i;
   struct draw_gs_llvm_iface gs_iface;
   const struct tgsi_token *tokens = variant->shader->base.state.tokens;
   LLVMValueRef consts_ptr, num_consts_ptr;
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][TGSI_NUM_CHANNELS];
   struct lp_build_mask_context mask;
   const struct tgsi_shader_info *gs_info = &variant->shader->base.info;
   unsigned vector_length = variant->shader->base.vector_length;

   memset(&system_values, 0, sizeof(system_values));

   assert(variant->vertex_header_ptr_type);

   arg_types[0] = get_gs_context_ptr_type(variant);    /* context */
   arg_types[1] = variant->input_array_type;           /* input */
   arg_types[2] = variant->vertex_header_ptr_type;     /* vertex_header */
   arg_types[3] = int32_type;                          /* num_prims */
   arg_types[4] = int32_type;                          /* instance_id */
   arg_types[5] = LLVMPointerType(
      LLVMVectorType(int32_type, vector_length), 0);   /* prim_id_ptr */

   func_type = LLVMFunctionType(int32_type, arg_types, Elements(arg_types), 0);

   variant_func = LLVMAddFunction(gallivm->module, "draw_geometry_shader",
                                  func_type);
   variant->function = variant_func;

   LLVMSetFunctionCallConv(variant_func, LLVMCCallConv);

   for (i = 0; i < Elements(arg_types); ++i)
      if (LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
         LLVMAddAttribute(LLVMGetParam(variant_func, i),
                          LLVMNoAliasAttribute);

   context_ptr               = LLVMGetParam(variant_func, 0);
   input_array               = LLVMGetParam(variant_func, 1);
   io_ptr                    = LLVMGetParam(variant_func, 2);
   num_prims                 = LLVMGetParam(variant_func, 3);
   system_values.instance_id = LLVMGetParam(variant_func, 4);
   prim_id_ptr               = LLVMGetParam(variant_func, 5);

   lp_build_name(context_ptr, "context");
   lp_build_name(input_array, "input");
   lp_build_name(io_ptr, "io");
   lp_build_name(num_prims, "num_prims");
   lp_build_name(system_values.instance_id, "instance_id");
   lp_build_name(prim_id_ptr, "prim_id_ptr");

   variant->context_ptr = context_ptr;
   variant->io_ptr = io_ptr;
   variant->num_prims = num_prims;

   gs_iface.base.fetch_input = draw_gs_llvm_fetch_input;
   gs_iface.base.emit_vertex = draw_gs_llvm_emit_vertex;
   gs_iface.base.end_primitive = draw_gs_llvm_end_primitive;
   gs_iface.base.gs_epilogue = draw_gs_llvm_epilogue;
   gs_iface.input = input_array;
   gs_iface.variant = variant;

   /*
    * Function body
    */

   block = LLVMAppendBasicBlockInContext(gallivm->context, variant_func, "entry");
   builder = gallivm->builder;
   LLVMPositionBuilderAtEnd(builder, block);

   lp_build_context_init(&bld, gallivm, lp_type_int(32));

   memset(&gs_type, 0, sizeof gs_type);
   gs_type.floating = TRUE; /* floating point values */
   gs_type.sign = TRUE;     /* values are signed */
   gs_type.norm = FALSE;    /* values are not limited to [0,1] or [-1,1] */
   gs_type.width = 32;      /* 32-bit float */
   gs_type.length = vector_length;

   consts_ptr = draw_gs_jit_context_constants(variant->gallivm, context_ptr);
   num_consts_ptr =
      draw_gs_jit_context_num_constants(variant->gallivm, context_ptr);

   /* code generated texture sampling */
   sampler = draw_llvm_sampler_soa_create(variant->key.samplers,
                                          context_ptr);

   mask_val = generate_mask_value(variant, gs_type);
   lp_build_mask_begin(&mask, gallivm, gs_type, mask_val);

   if (gs_info->uses_primid) {
      system_values.prim_id = LLVMBuildLoad(builder, prim_id_ptr, "prim_id");
   }

   if (gallivm_debug & (GALLIVM_DEBUG_TGSI | GALLIVM_DEBUG_IR)) {
      tgsi_dump(tokens, 0);
      draw_gs_llvm_dump_variant_key(&variant->key);
   }

   lp_build_tgsi_soa(variant->gallivm,
                     tokens,
                     gs_type,
                     &mask,
                     consts_ptr,
                     num_consts_ptr,
                     &system_values,
                     NULL,
                     outputs,
                     sampler,
                     &llvm->draw->gs.geometry_shader->info,
                     (const struct lp_build_tgsi_gs_iface *)&gs_iface);

   sampler->destroy(sampler);

   lp_build_mask_end(&mask);

   LLVMBuildRet(builder, lp_build_zero(gallivm, lp_type_uint(32)));

   gallivm_verify_function(gallivm, variant_func);
}


struct draw_gs_llvm_variant *
draw_gs_llvm_create_variant(struct draw_llvm *llvm,
                            unsigned num_outputs,
                            const struct draw_gs_llvm_variant_key *key)
{
   struct draw_gs_llvm_variant *variant;
   struct llvm_geometry_shader *shader =
      llvm_geometry_shader(llvm->draw->gs.geometry_shader);
   LLVMTypeRef vertex_header;

   variant = MALLOC(sizeof *variant +
                    shader->variant_key_size -
                    sizeof variant->key);
   if (variant == NULL)
      return NULL;

   variant->llvm = llvm;
   variant->shader = shader;

   variant->gallivm = gallivm_create();

   create_gs_jit_types(variant);

   memcpy(&variant->key, key, shader->variant_key_size);

   vertex_header = create_jit_vertex_header(variant->gallivm, num_outputs);

   variant->vertex_header_ptr_type = LLVMPointerType(vertex_header, 0);

   draw_gs_llvm_generate(llvm, variant);

   gallivm_compile_module(variant->gallivm);

   variant->jit_func = (draw_gs_jit_func)
         gallivm_jit_function(variant->gallivm, variant->function);

   variant->list_item_global.base = variant;
   variant->list_item_local.base = variant;
   /*variant->no = */shader->variants_created++;
   variant->list_item_global.base = variant;

   return variant;
}

void
draw_gs_llvm_destroy_variant(struct draw_gs_llvm_variant *variant)
{
   struct draw_llvm *llvm = variant->llvm;

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function, variant->jit_func);
   }

   gallivm_destroy(variant->gallivm);

   remove_from_list(&variant->list_item_local);
   variant->shader->variants_cached--;
   remove_from_list(&variant->list_item_global);
   llvm->nr_gs_variants--;
   FREE(variant);
}

struct draw_gs_llvm_variant_key *
draw_gs_llvm_make_variant_key(struct draw_llvm *llvm, char *store)
{
   unsigned i;
   struct draw_gs_llvm_variant_key *key;
   struct draw_sampler_static_state *draw_sampler;

   key = (struct draw_gs_llvm_variant_key *)store;

   key->num_outputs = draw_total_gs_outputs(llvm->draw);

   /* All variants of this shader will have the same value for
    * nr_samplers.  Not yet trying to compact away holes in the
    * sampler array.
    */
   key->nr_samplers = llvm->draw->gs.geometry_shader->info.file_max[TGSI_FILE_SAMPLER] + 1;
   if (llvm->draw->gs.geometry_shader->info.file_max[TGSI_FILE_SAMPLER_VIEW] != -1) {
      key->nr_sampler_views =
         llvm->draw->gs.geometry_shader->info.file_max[TGSI_FILE_SAMPLER_VIEW] + 1;
   }
   else {
      key->nr_sampler_views = key->nr_samplers;
   }

   draw_sampler = key->samplers;

   memset(draw_sampler, 0, MAX2(key->nr_samplers, key->nr_sampler_views) * sizeof *draw_sampler);

   for (i = 0 ; i < key->nr_samplers; i++) {
      lp_sampler_static_sampler_state(&draw_sampler[i].sampler_state,
                                      llvm->draw->samplers[PIPE_SHADER_GEOMETRY][i]);
   }
   for (i = 0 ; i < key->nr_sampler_views; i++) {
      lp_sampler_static_texture_state(&draw_sampler[i].texture_state,
                                      llvm->draw->sampler_views[PIPE_SHADER_GEOMETRY][i]);
   }

   return key;
}

void
draw_gs_llvm_dump_variant_key(struct draw_gs_llvm_variant_key *key)
{
   unsigned i;
   struct draw_sampler_static_state *sampler = key->samplers;

   for (i = 0 ; i < key->nr_sampler_views; i++) {
      debug_printf("sampler[%i].src_format = %s\n", i,
                   util_format_name(sampler[i].texture_state.format));
   }
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d100 9
d145 9
d207 9
d262 6
d325 5
d393 5
d430 5
d531 1
a531 1
draw_llvm_create(struct draw_context *draw, LLVMContextRef context)
a534 3
   if (!lp_build_init())
      return NULL;

d539 2
a542 8
   llvm->context = context;
   if (!llvm->context) {
      llvm->context = LLVMContextCreate();
      llvm->context_owned = true;
   }
   if (!llvm->context)
      goto fail;

a549 4

fail:
   draw_llvm_destroy(llvm);
   return NULL;
a558 4
   if (llvm->context_owned)
      LLVMContextDispose(llvm->context);
   llvm->context = NULL;

a575 1
   char module_name[64];
a583 1
   variant->shader = shader;
d585 1
a585 4
   util_snprintf(module_name, sizeof(module_name), "draw_llvm_vs_variant%u",
                 variant->shader->variants_cached);

   variant->gallivm = gallivm_create(module_name, llvm->context);
d606 1
a606 2
   gallivm_free_ir(variant->gallivm);

d633 1
d640 3
d652 1
a652 1
                     draw_sampler,
d690 1
a690 2
               LLVMValueRef instance_id,
               LLVMValueRef start_instance)
d720 1
d724 1
a724 2
      index = lp_build_uadd_overflow(gallivm, start_instance,
                                     current_instance, &ofbit);
d1518 1
a1518 1
   LLVMTypeRef arg_types[11];
a1524 1
   char func_name[64];
d1528 1
a1528 1
   LLVMValueRef vertex_id_offset, start_instance;
d1543 1
d1549 4
a1552 4
   const boolean bypass_viewport = key->has_gs || key->bypass_viewport;
   const boolean enable_cliptest = !key->has_gs && (key->clip_xy ||
                                                    key->clip_z  ||
                                                    key->clip_user);
a1560 3
   util_snprintf(func_name, sizeof(func_name), "draw_llvm_vs_variant%u_%s",
                 variant->shader->variants_cached, elts ? "elts" : "linear");

a1574 1
   arg_types[i++] = int32_type;                     /* start_instance */
d1578 3
a1580 1
   variant_func = LLVMAddFunction(gallivm->module, func_name, func_type);
a1599 1
   start_instance            = LLVMGetParam(variant_func, 9 + (elts ? 1 : 0));
a1607 1
   lp_build_name(start_instance, "start_instance");
d1756 1
a1756 1
                           system_values.instance_id, start_instance);
d1775 2
a1776 2
         store_clip(gallivm, vs_type, io, outputs, FALSE, key->clip_user ? cv : pos);
         store_clip(gallivm, vs_type, io, outputs, TRUE, pos);
d2011 10
a2100 1
   char func_name[64];
a2112 3
   util_snprintf(func_name, sizeof(func_name), "draw_llvm_gs_variant%u",
                 variant->shader->variants_cached);

d2125 2
a2126 2
   variant_func = LLVMAddFunction(gallivm->module, func_name, func_type);

a2229 1
   char module_name[64];
d2240 1
a2240 4
   util_snprintf(module_name, sizeof(module_name), "draw_llvm_gs_variant%u",
                 variant->shader->variants_cached);

   variant->gallivm = gallivm_create(module_name, llvm->context);
a2256 2
   gallivm_free_ir(variant->gallivm);

d2269 5
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a99 9
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, dvbuffer_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, dvbuffer_type);
#endif

a135 9
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, texture_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, texture_type);
#endif

a188 9
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, sampler_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, sampler_type);
#endif

a234 6
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, context_type);

   LLVMInvalidateStructLayout(gallivm->target, context_type);
#endif

a291 5
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, context_type);

   LLVMInvalidateStructLayout(gallivm->target, context_type);
#endif
a354 5
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, vb_type);

   LLVMInvalidateStructLayout(gallivm->target, vb_type);
#endif
a386 5
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, vertex_header);

   LLVMInvalidateStructLayout(gallivm->target, vertex_header);
#endif
d483 1
a483 1
draw_llvm_create(struct draw_context *draw)
d487 3
d494 1
a494 1
   lp_build_init();
d496 7
a502 1
   llvm->draw = draw;
d511 4
d524 4
d545 1
d554 1
d556 4
a559 1
   variant->gallivm = gallivm_create();
d580 2
a581 1
   variant->shader = shader;
a607 1
   struct lp_build_sampler_soa *sampler = 0;
a613 3
   if (llvm->draw->num_sampler_views && llvm->draw->num_samplers)
      sampler = draw_sampler;

d623 1
a623 1
                     sampler,
d661 2
a662 1
               LLVMValueRef instance_id)
a691 1
      index = lp_build_const_int32(gallivm, draw->start_instance);
d695 2
a696 1
      index = lp_build_uadd_overflow(gallivm, index, current_instance, &ofbit);
d1490 1
a1490 1
   LLVMTypeRef arg_types[10];
d1497 1
d1501 1
a1501 1
   LLVMValueRef vertex_id_offset;
a1515 1
   const struct draw_geometry_shader *gs = draw->gs.geometry_shader;
d1521 4
a1524 4
   const boolean bypass_viewport = gs || key->bypass_viewport;
   const boolean enable_cliptest = !gs && (key->clip_xy ||
                                           key->clip_z  ||
                                           key->clip_user);
d1533 3
d1550 1
d1554 1
a1554 3
   variant_func = LLVMAddFunction(gallivm->module,
                                  elts ? "draw_llvm_shader_elts" : "draw_llvm_shader",
                                  func_type);
d1574 1
d1583 1
d1732 1
a1732 1
                           system_values.instance_id);
d1751 2
a1752 2
         store_clip(gallivm, vs_type, io, outputs, 0, cv);
         store_clip(gallivm, vs_type, io, outputs, 1, pos);
a1986 10
   if (variant->function_elts) {
      gallivm_free_function(variant->gallivm,
                            variant->function_elts, variant->jit_func_elts);
   }

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function, variant->jit_func);
   }

d2067 1
d2080 3
d2095 2
a2096 2
   variant_func = LLVMAddFunction(gallivm->module, "draw_geometry_shader",
                                  func_type);
d2200 1
d2211 4
a2214 1
   variant->gallivm = gallivm_create();
d2231 2
a2244 5

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function, variant->jit_func);
   }
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d245 1
d251 3
a253 1
   elem_types[1] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4),
d255 2
a256 2
   elem_types[2] = LLVMPointerType(float_type, 0); /* viewport */
   elem_types[3] = LLVMArrayType(texture_type,
d258 1
a258 1
   elem_types[4] = LLVMArrayType(sampler_type,
d270 2
d306 3
a308 1
   elem_types[1] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4),
d310 1
a310 1
   elem_types[2] = LLVMPointerType(float_type, 0); /* viewport */
d312 1
a312 1
   elem_types[3] = LLVMArrayType(texture_type,
d314 1
a314 1
   elem_types[4] = LLVMArrayType(sampler_type,
d317 2
a318 2
   elem_types[5] = LLVMPointerType(LLVMPointerType(int_type, 0), 0);
   elem_types[6] = LLVMPointerType(LLVMVectorType(int_type,
d320 1
a320 1
   elem_types[7] = LLVMPointerType(LLVMVectorType(int_type,
d333 2
d629 4
a632 1
   LLVMValueRef consts_ptr = draw_jit_context_vs_constants(variant->gallivm, context_ptr);
d648 1
a674 6
               case TGSI_SEMANTIC_FOG:
                  if (chan == 1 || chan == 2)
                     LLVMBuildStore(builder, bld.zero, outputs[attrib][chan]);
                  else if (chan == 3)
                     LLVMBuildStore(builder, bld.one, outputs[attrib][chan]);
                  break;
d717 1
a717 1
       * index = start_instance + ((instance_id - start_instance) / divisor)
d721 1
a721 2
      current_instance = LLVMBuildSub(builder, instance_id, index, "");
      current_instance = LLVMBuildUDiv(builder, current_instance,
d724 1
a724 1
      index = LLVMBuildAdd(builder, index, current_instance, "instance");
a941 1
         LLVMBuildStore(builder, val, id_ptr);
d946 1
d987 6
d1046 3
a1082 1
      LLVMTypeRef  clip_ptr_type = LLVMPointerType(LLVMVectorType(LLVMFloatTypeInContext(gallivm->context), 4), 0);
d1107 1
a1107 1
   const unsigned pos = draw_current_shader_position_output(variant->llvm->draw);
d1176 2
a1177 2
   const unsigned pos = draw_current_shader_position_output(llvm->draw);
   const unsigned cv = draw_current_shader_clipvertex_output(llvm->draw);
d1182 2
a1183 2
   cd[0] = draw_current_shader_clipdistance_output(llvm->draw, 0);
   cd[1] = draw_current_shader_clipdistance_output(llvm->draw, 1);
d1273 1
d1293 2
d1372 1
a1372 1
                         boolean is_indirect,
d1374 1
d1385 1
a1385 1
   if (is_indirect) {
d1390 2
a1391 2
         LLVMValueRef vert_chan_index = LLVMBuildExtractElement(builder,
                                                                vertex_index, idx, "");
d1393 10
d1404 1
a1404 1
         indices[1] = attrib_index;
d1406 1
a1406 1
         
d1518 1
a1518 1
   LLVMTypeRef arg_types[9];
d1528 1
d1554 2
a1555 2
   const unsigned pos = draw_current_shader_position_output(llvm->draw);
   const unsigned cv = draw_current_shader_clipvertex_output(llvm->draw);
d1574 1
d1599 1
d1607 1
d1682 1
a1682 1
         LLVMValueRef true_index =
d1686 3
a1688 1
         true_index = LLVMBuildAdd(builder, start, true_index, "");
a1694 5
         system_values.vertex_id = LLVMBuildInsertElement(
            gallivm->builder,
            system_values.vertex_id, true_index,
            lp_build_const_int32(gallivm, i), "");

d1706 1
a1706 1
            
d1731 17
d1859 1
d2066 3
a2068 6
   LLVMValueRef bits[16];
   struct lp_type  mask_type = lp_int_type(gs_type);
   struct lp_type mask_elem_type = lp_elem_type(mask_type);
   LLVMValueRef mask_val = lp_build_const_vec(gallivm,
                                              mask_type,
                                              0);
d2071 5
a2075 8
   assert(gs_type.length <= Elements(bits));

   for (i = gs_type.length; i >= 1; --i) {
      int idx = i - 1;
      LLVMValueRef ind = lp_build_const_int32(gallivm, i);
      bits[idx] = lp_build_compare(gallivm,
                                   mask_elem_type, PIPE_FUNC_GEQUAL,
                                   variant->num_prims, ind);
d2077 2
a2078 8
   for (i = 0; i < gs_type.length; ++i) {
      LLVMValueRef ind = lp_build_const_int32(gallivm, i);
      mask_val = LLVMBuildInsertElement(builder, mask_val, bits[i], ind, "");
   }
   mask_val = lp_build_compare(gallivm,
                               mask_type, PIPE_FUNC_NOTEQUAL,
                               mask_val,
                               lp_build_const_int_vec(gallivm, mask_type, 0));
d2105 1
a2105 1
   LLVMValueRef consts_ptr;
d2179 2
d2190 6
a2195 1
      system_values.prim_id = LLVMBuildLoad(builder, prim_id_ptr, "prim_id");;
d2203 1
d2292 2
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d32 1
d35 1
d48 2
d63 18
d82 1
a82 3
 * This function is called by the gallivm "garbage collector" when
 * the LLVM global data structures are freed.  We must free all LLVM-related
 * data.  Specifically, all JIT'd shader variants.
d84 3
a86 2
static void
draw_llvm_garbage_collect_callback(void *cb_data)
d88 4
a91 2
   struct draw_llvm *llvm = (struct draw_llvm *) cb_data;
   struct draw_llvm_variant_list_item *li;
d93 3
a95 7
   /* free all shader variants */
   li = first_elem(&llvm->vs_variants_list);
   while (!at_end(&llvm->vs_variants_list, li)) {
      struct draw_llvm_variant_list_item *next = next_elem(li);
      draw_llvm_destroy_variant(li->base);
      li = next;
   }
d97 2
a98 8
   /* Null-out these pointers so they get remade next time they're needed.
    * See the accessor functions below.
    */
   llvm->context_ptr_type = NULL;
   llvm->buffer_ptr_type = NULL;
   llvm->vb_ptr_type = NULL;
   llvm->vertex_header_ptr_type = NULL;
}
d100 2
d103 5
a107 2
static void
draw_llvm_generate(struct draw_llvm *llvm, struct draw_llvm_variant *var);
d109 6
a114 2
static void
draw_llvm_generate_elts(struct draw_llvm *llvm, struct draw_llvm_variant *var);
d116 2
d135 2
d139 1
a140 8
   elem_types[DRAW_JIT_TEXTURE_DATA] =
      LLVMArrayType(LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0),
                    PIPE_MAX_TEXTURE_LEVELS);
   elem_types[DRAW_JIT_TEXTURE_MIN_LOD] =
   elem_types[DRAW_JIT_TEXTURE_MAX_LOD] =
   elem_types[DRAW_JIT_TEXTURE_LOD_BIAS] = LLVMFloatTypeInContext(gallivm->context);
   elem_types[DRAW_JIT_TEXTURE_BORDER_COLOR] = 
      LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);
a141 5
#if HAVE_LLVM >= 0x0300
   texture_type = LLVMStructCreateNamed(gallivm->context, struct_name);
   LLVMStructSetBody(texture_type, elem_types,
                     Elements(elem_types), 0);
#else
d145 1
d169 3
d178 1
a178 10
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, data,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_DATA);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, min_lod,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_MIN_LOD);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, max_lod,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_MAX_LOD);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, lod_bias,
d180 1
a180 4
                          DRAW_JIT_TEXTURE_LOD_BIAS);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, border_color,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_BORDER_COLOR);
d189 48
a236 1
 * Create LLVM type for struct draw_jit_texture
d240 2
a241 1
                        LLVMTypeRef texture_type, const char *struct_name)
d245 1
a245 1
   LLVMTypeRef elem_types[5];
d248 9
a256 11
   elem_types[0] = LLVMPointerType(float_type, 0); /* vs_constants */
   elem_types[1] = LLVMPointerType(float_type, 0); /* gs_constants */
   elem_types[2] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4), 12), 0); /* planes */
   elem_types[3] = LLVMPointerType(float_type, 0); /* viewport */
   elem_types[4] = LLVMArrayType(texture_type,
                                 PIPE_MAX_VERTEX_SAMPLERS); /* textures */
#if HAVE_LLVM >= 0x0300
   context_type = LLVMStructCreateNamed(gallivm->context, struct_name);
   LLVMStructSetBody(context_type, elem_types,
                     Elements(elem_types), 0);
#else
d259 1
d266 1
a266 3
                          target, context_type, 0);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, gs_constants,
                          target, context_type, 1);
d268 3
a270 1
                          target, context_type, 2);
d274 3
d285 82
d370 2
a371 1
create_jit_vertex_buffer_type(struct gallivm_state *gallivm, const char *struct_name)
d374 1
a374 1
   LLVMTypeRef elem_types[3];
d379 2
a380 1
   elem_types[2] = LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0); /* vs_constants */
a381 5
#if HAVE_LLVM >= 0x0300
   vb_type = LLVMStructCreateNamed(gallivm->context, struct_name);
   LLVMStructSetBody(vb_type, elem_types,
                     Elements(elem_types), 0);
#else
d384 1
d408 1
a408 1
   LLVMTypeRef elem_types[3];
d414 5
a418 9
   elem_types[0]  = LLVMIntTypeInContext(gallivm->context, 32);
   elem_types[1]  = LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);
   elem_types[2]  = LLVMArrayType(elem_types[1], data_elems);

#if HAVE_LLVM >= 0x0300
   vertex_header = LLVMStructCreateNamed(gallivm->context, struct_name);
   LLVMStructSetBody(vertex_header, elem_types,
                     Elements(elem_types), 0);
#else
d421 1
d444 3
d451 3
d462 1
a462 1
create_jit_types(struct draw_llvm *llvm)
d464 3
a466 2
   struct gallivm_state *gallivm = llvm->gallivm;
   LLVMTypeRef texture_type, context_type, buffer_type, vb_type;
d469 1
d471 3
a473 5
   context_type = create_jit_context_type(gallivm, texture_type, "draw_jit_context");
   llvm->context_ptr_type = LLVMPointerType(context_type, 0);

   buffer_type = LLVMPointerType(LLVMIntTypeInContext(gallivm->context, 8), 0);
   llvm->buffer_ptr_type = LLVMPointerType(buffer_type, 0);
d475 3
d479 1
a479 1
   llvm->vb_ptr_type = LLVMPointerType(vb_type, 0);
d484 1
a484 1
get_context_ptr_type(struct draw_llvm *llvm)
d486 3
a488 3
   if (!llvm->context_ptr_type)
      create_jit_types(llvm);
   return llvm->context_ptr_type;
d493 1
a493 1
get_buffer_ptr_type(struct draw_llvm *llvm)
d495 3
a497 3
   if (!llvm->buffer_ptr_type)
      create_jit_types(llvm);
   return llvm->buffer_ptr_type;
d502 1
a502 1
get_vb_ptr_type(struct draw_llvm *llvm)
d504 3
a506 3
   if (!llvm->vb_ptr_type)
      create_jit_types(llvm);
   return llvm->vb_ptr_type;
d510 1
a510 1
get_vertex_header_ptr_type(struct draw_llvm *llvm)
d512 3
a514 3
   if (!llvm->vertex_header_ptr_type)
      create_jit_types(llvm);
   return llvm->vertex_header_ptr_type;
d522 1
a522 1
draw_llvm_create(struct draw_context *draw, struct gallivm_state *gallivm)
a532 5
   llvm->gallivm = gallivm;

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      LLVMDumpModule(llvm->gallivm->module);
   }
d537 2
a538 2
   gallivm_register_garbage_collector_callback(
                              draw_llvm_garbage_collect_callback, llvm);
a549 3
   gallivm_remove_garbage_collector_callback(
                              draw_llvm_garbage_collect_callback, llvm);

d560 2
a561 2
			 unsigned num_inputs,
			 const struct draw_llvm_variant_key *key)
d569 2
a570 2
		    shader->variant_key_size -
		    sizeof variant->key);
d576 4
d582 8
a589 1
   vertex_header = create_jit_vertex_header(llvm->gallivm, num_inputs);
d591 2
a592 1
   llvm->vertex_header_ptr_type = LLVMPointerType(vertex_header, 0);
d594 2
a595 2
   draw_llvm_generate(llvm, variant);
   draw_llvm_generate_elts(llvm, variant);
d608 1
a608 1
generate_vs(struct draw_llvm *llvm,
d610 4
a613 3
            LLVMValueRef (*outputs)[NUM_CHANNELS],
            const LLVMValueRef (*inputs)[NUM_CHANNELS],
            LLVMValueRef system_values_array,
d618 1
d620 1
a620 2
   struct lp_type vs_type;
   LLVMValueRef consts_ptr = draw_jit_context_vs_constants(llvm->gallivm, context_ptr);
d623 1
a623 11
   memset(&vs_type, 0, sizeof vs_type);
   vs_type.floating = TRUE; /* floating point values */
   vs_type.sign = TRUE;     /* values are signed */
   vs_type.norm = FALSE;    /* values are not limited to [0,1] or [-1,1] */
   vs_type.width = 32;      /* 32-bit float */
   vs_type.length = 4;      /* 4 elements per vector */
#if 0
   num_vs = 4;              /* number of vertices per block */
#endif

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
d625 1
d631 1
a631 1
   lp_build_tgsi_soa(llvm->gallivm,
d636 1
a636 2
                     system_values_array,
                     NULL /*pos*/,
d640 2
a641 1
                     &llvm->draw->vs.vertex_shader->info);
d643 1
a643 1
   if (clamp_vertex_color) {
d648 1
a648 1
      lp_build_context_init(&bld, llvm->gallivm, vs_type);
d651 1
a651 1
         for (chan = 0; chan < NUM_CHANNELS; ++chan) {
d656 11
a666 3
                  out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
                  out = lp_build_clamp(&bld, out, bld.zero, bld.one);
                  LLVMBuildStore(builder, out, outputs[attrib][chan]);
a674 20

#if DEBUG_STORE
static void print_vectorf(LLVMBuilderRef builder,
                         LLVMValueRef vec)
{
   LLVMValueRef val[4];
   val[0] = LLVMBuildExtractElement(builder, vec,
                                    lp_build_const_int32(gallivm, 0), "");
   val[1] = LLVMBuildExtractElement(builder, vec,
                                    lp_build_const_int32(gallivm, 1), "");
   val[2] = LLVMBuildExtractElement(builder, vec,
                                    lp_build_const_int32(gallivm, 2), "");
   val[3] = LLVMBuildExtractElement(builder, vec,
                                    lp_build_const_int32(gallivm, 3), "");
   lp_build_printf(builder, "vector = [%f, %f, %f, %f]\n",
                   val[0], val[1], val[2], val[3]);
}
#endif


d677 1
d685 3
d696 2
d699 7
d708 50
a757 4
      /* array index = instance_id / instance_divisor */
      index = LLVMBuildUDiv(builder, instance_id,
                            lp_build_const_int32(gallivm, velem->instance_divisor),
                            "instance_divisor");
d759 4
d764 8
a771 13
   stride = LLVMBuildMul(builder, vb_stride, index, "");

   vbuffer_ptr = LLVMBuildLoad(builder, vbuffer_ptr, "vbuffer");

   stride = LLVMBuildAdd(builder, stride,
                         vb_buffer_offset,
                         "");
   stride = LLVMBuildAdd(builder, stride,
                         lp_build_const_int32(gallivm, velem->src_offset),
                         "");

   /*lp_build_printf(builder, "vbuf index = %d, stride is %d\n", indices, stride);*/
   vbuffer_ptr = LLVMBuildGEP(builder, vbuffer_ptr, &stride, 1, "");
d773 1
a773 1
   *res = draw_llvm_translate_from(gallivm, vbuffer_ptr, velem->src_format);
a775 45

static LLVMValueRef
aos_to_soa(struct gallivm_state *gallivm,
           LLVMValueRef val0,
           LLVMValueRef val1,
           LLVMValueRef val2,
           LLVMValueRef val3,
           LLVMValueRef channel)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef ex, res;

   ex = LLVMBuildExtractElement(builder, val0,
                                channel, "");
   res = LLVMBuildInsertElement(builder,
                                LLVMConstNull(LLVMTypeOf(val0)),
                                ex,
                                lp_build_const_int32(gallivm, 0),
                                "");

   ex = LLVMBuildExtractElement(builder, val1,
                                channel, "");
   res = LLVMBuildInsertElement(builder,
                                res, ex,
                                lp_build_const_int32(gallivm, 1),
                                "");

   ex = LLVMBuildExtractElement(builder, val2,
                                channel, "");
   res = LLVMBuildInsertElement(builder,
                                res, ex,
                                lp_build_const_int32(gallivm, 2),
                                "");

   ex = LLVMBuildExtractElement(builder, val3,
                                channel, "");
   res = LLVMBuildInsertElement(builder,
                                res, ex,
                                lp_build_const_int32(gallivm, 3),
                                "");

   return res;
}


d777 4
a780 3
soa_to_aos(struct gallivm_state *gallivm,
           LLVMValueRef soa[NUM_CHANNELS],
           LLVMValueRef aos[NUM_CHANNELS])
d782 2
a783 3
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef comp;
   int i = 0;
d785 2
a786 1
   debug_assert(NUM_CHANNELS == 4);
d788 1
a788 2
   aos[0] = LLVMConstNull(LLVMTypeOf(soa[0]));
   aos[1] = aos[2] = aos[3] = aos[0];
d790 3
a792 2
   for (i = 0; i < NUM_CHANNELS; ++i) {
      LLVMValueRef channel = lp_build_const_int32(gallivm, i);
d794 2
a795 3
      comp = LLVMBuildExtractElement(builder, soa[i],
                                     lp_build_const_int32(gallivm, 0), "");
      aos[0] = LLVMBuildInsertElement(builder, aos[0], comp, channel, "");
d797 1
a797 3
      comp = LLVMBuildExtractElement(builder, soa[i],
                                     lp_build_const_int32(gallivm, 1), "");
      aos[1] = LLVMBuildInsertElement(builder, aos[1], comp, channel, "");
d799 3
a801 3
      comp = LLVMBuildExtractElement(builder, soa[i],
                                     lp_build_const_int32(gallivm, 2), "");
      aos[2] = LLVMBuildInsertElement(builder, aos[2], comp, channel, "");
d803 2
a804 15
      comp = LLVMBuildExtractElement(builder, soa[i],
                                     lp_build_const_int32(gallivm, 3), "");
      aos[3] = LLVMBuildInsertElement(builder, aos[3], comp, channel, "");

   }
}


static void
convert_to_soa(struct gallivm_state *gallivm,
               LLVMValueRef (*aos)[NUM_CHANNELS],
               LLVMValueRef (*soa)[NUM_CHANNELS],
               int num_attribs)
{
   int i;
d806 1
a806 16
   debug_assert(NUM_CHANNELS == 4);

   for (i = 0; i < num_attribs; ++i) {
      LLVMValueRef val0 = aos[i][0];
      LLVMValueRef val1 = aos[i][1];
      LLVMValueRef val2 = aos[i][2];
      LLVMValueRef val3 = aos[i][3];

      soa[i][0] = aos_to_soa(gallivm, val0, val1, val2, val3,
                             lp_build_const_int32(gallivm, 0));
      soa[i][1] = aos_to_soa(gallivm, val0, val1, val2, val3,
                             lp_build_const_int32(gallivm, 1));
      soa[i][2] = aos_to_soa(gallivm, val0, val1, val2, val3,
                             lp_build_const_int32(gallivm, 2));
      soa[i][3] = aos_to_soa(gallivm, val0, val1, val2, val3,
                             lp_build_const_int32(gallivm, 3));
d815 1
a815 2
          LLVMValueRef value,
          LLVMValueRef clipmask)
d817 1
a818 1
   LLVMValueRef id_ptr = draw_jit_header_id(gallivm, io_ptr);
a820 1
   LLVMValueRef val, shift;
d826 2
a827 10
   /* initialize vertex id:16 = 0xffff, pad:3 = 0, edgeflag:1 = 1 */
   val = lp_build_const_int32(gallivm, 0xffff1);
   shift = lp_build_const_int32(gallivm, 12);
   val = LLVMBuildShl(builder, val, shift, "");
   /* add clipmask:12 */   
   val = LLVMBuildOr(builder, val, clipmask, "");               

   /* store vertex header */
   LLVMBuildStore(builder, val, id_ptr);

d830 1
a830 1
   lp_build_printf(builder, "    ---- %p storing attribute %d (io = %p)\n", data_ptr, index, io_ptr);
a831 7
#if 0
   /*lp_build_printf(builder, " ---- %p storing at %d (%p)  ", io_ptr, index, data_ptr);
     print_vectorf(builder, value);*/
   data_ptr = LLVMBuildBitCast(builder, data_ptr,
                               LLVMPointerType(LLVMArrayType(LLVMVectorType(LLVMFloatTypeInContext(gallivm->context), 4), 0), 0),
                               "datavec");
   data_ptr = LLVMBuildGEP(builder, data_ptr, indices, 2, "");
d833 48
a880 34
   LLVMBuildStore(builder, value, data_ptr);
#else
   {
      LLVMValueRef x, y, z, w;
      LLVMValueRef idx0, idx1, idx2, idx3;
      LLVMValueRef gep0, gep1, gep2, gep3;
      data_ptr = LLVMBuildGEP(builder, data_ptr, indices, 3, "");

      idx0 = lp_build_const_int32(gallivm, 0);
      idx1 = lp_build_const_int32(gallivm, 1);
      idx2 = lp_build_const_int32(gallivm, 2);
      idx3 = lp_build_const_int32(gallivm, 3);

      x = LLVMBuildExtractElement(builder, value,
                                  idx0, "");
      y = LLVMBuildExtractElement(builder, value,
                                  idx1, "");
      z = LLVMBuildExtractElement(builder, value,
                                  idx2, "");
      w = LLVMBuildExtractElement(builder, value,
                                  idx3, "");

      gep0 = LLVMBuildGEP(builder, data_ptr, &idx0, 1, "");
      gep1 = LLVMBuildGEP(builder, data_ptr, &idx1, 1, "");
      gep2 = LLVMBuildGEP(builder, data_ptr, &idx2, 1, "");
      gep3 = LLVMBuildGEP(builder, data_ptr, &idx3, 1, "");

      /*lp_build_printf(builder, "##### x = %f (%p), y = %f (%p), z = %f (%p), w = %f (%p)\n",
        x, gep0, y, gep1, z, gep2, w, gep3);*/
      LLVMBuildStore(builder, x, gep0);
      LLVMBuildStore(builder, y, gep1);
      LLVMBuildStore(builder, z, gep2);
      LLVMBuildStore(builder, w, gep3);
   }
d882 1
a884 1

d887 1
d889 2
a890 1
                LLVMValueRef aos[NUM_CHANNELS],
d893 2
a894 1
                LLVMValueRef clipmask)
d898 7
a904 8
   LLVMValueRef ind0 = lp_build_const_int32(gallivm, 0);
   LLVMValueRef ind1 = lp_build_const_int32(gallivm, 1);
   LLVMValueRef ind2 = lp_build_const_int32(gallivm, 2);
   LLVMValueRef ind3 = lp_build_const_int32(gallivm, 3);
   LLVMValueRef io0_ptr, io1_ptr, io2_ptr, io3_ptr;
   LLVMValueRef clipmask0, clipmask1, clipmask2, clipmask3;
   
   debug_assert(NUM_CHANNELS == 4);
d906 9
a914 17
   io0_ptr = LLVMBuildGEP(builder, io_ptr,
                          &ind0, 1, "");
   io1_ptr = LLVMBuildGEP(builder, io_ptr,
                          &ind1, 1, "");
   io2_ptr = LLVMBuildGEP(builder, io_ptr,
                          &ind2, 1, "");
   io3_ptr = LLVMBuildGEP(builder, io_ptr,
                          &ind3, 1, "");

   clipmask0 = LLVMBuildExtractElement(builder, clipmask,
                                       ind0, "");
   clipmask1 = LLVMBuildExtractElement(builder, clipmask,
                                       ind1, "");
   clipmask2 = LLVMBuildExtractElement(builder, clipmask,
                                       ind2, "");
   clipmask3 = LLVMBuildExtractElement(builder, clipmask,
                                       ind3, "");
d916 21
d938 2
a939 2
   lp_build_printf(builder, "io = %p, indexes[%d, %d, %d, %d]\n, clipmask0 = %x, clipmask1 = %x, clipmask2 = %x, clipmask3 = %x\n",
                   io_ptr, ind0, ind1, ind2, ind3, clipmask0, clipmask1, clipmask2, clipmask3);
d941 7
a947 5
   /* store for each of the 4 vertices */
   store_aos(gallivm, io0_ptr, attr_index, aos[0], clipmask0);
   store_aos(gallivm, io1_ptr, attr_index, aos[1], clipmask1);
   store_aos(gallivm, io2_ptr, attr_index, aos[2], clipmask2);
   store_aos(gallivm, io3_ptr, attr_index, aos[3], clipmask3);
d954 2
a955 1
               LLVMValueRef (*outputs)[NUM_CHANNELS],
d958 2
a959 1
               int max_vertices)
d962 1
a962 1
   unsigned chan, attrib;
d965 1
a965 1
   lp_build_printf(builder, "   # storing begin\n");
d968 3
a970 3
      LLVMValueRef soa[4];
      LLVMValueRef aos[4];
      for (chan = 0; chan < NUM_CHANNELS; ++chan) {
d974 8
a981 4
            /*lp_build_printf(builder, "output %d : %d ",
                            LLVMConstInt(LLVMInt32Type(), attrib, 0),
                            LLVMConstInt(LLVMInt32Type(), chan, 0));
              print_vectorf(builder, out);*/
d988 15
a1002 1
      soa_to_aos(gallivm, soa, aos);
d1004 2
a1005 1
                      io,
d1009 1
a1009 1
                      clipmask);
d1012 1
a1012 1
   lp_build_printf(builder, "   # storing end\n");
a1018 2
 * There is probably a more efficient way to do this, 4 floats at once
 * rather than extracting each element one by one.
d1022 4
a1025 2
           LLVMValueRef io_ptr,           
           LLVMValueRef (*outputs)[NUM_CHANNELS])
d1028 7
a1034 7
   LLVMValueRef out[4];
   LLVMValueRef indices[2]; 
   LLVMValueRef io0_ptr, io1_ptr, io2_ptr, io3_ptr;
   LLVMValueRef clip_ptr0, clip_ptr1, clip_ptr2, clip_ptr3;
   LLVMValueRef clip0_ptr, clip1_ptr, clip2_ptr, clip3_ptr;    
   LLVMValueRef out0elem, out1elem, out2elem, out3elem;
   int i;
a1035 5
   LLVMValueRef ind0 = lp_build_const_int32(gallivm, 0);
   LLVMValueRef ind1 = lp_build_const_int32(gallivm, 1);
   LLVMValueRef ind2 = lp_build_const_int32(gallivm, 2);
   LLVMValueRef ind3 = lp_build_const_int32(gallivm, 3);
   
a1037 31
   
   out[0] = LLVMBuildLoad(builder, outputs[0][0], ""); /*x0 x1 x2 x3*/
   out[1] = LLVMBuildLoad(builder, outputs[0][1], ""); /*y0 y1 y2 y3*/
   out[2] = LLVMBuildLoad(builder, outputs[0][2], ""); /*z0 z1 z2 z3*/
   out[3] = LLVMBuildLoad(builder, outputs[0][3], ""); /*w0 w1 w2 w3*/  

   io0_ptr = LLVMBuildGEP(builder, io_ptr, &ind0, 1, "");
   io1_ptr = LLVMBuildGEP(builder, io_ptr, &ind1, 1, "");
   io2_ptr = LLVMBuildGEP(builder, io_ptr, &ind2, 1, "");
   io3_ptr = LLVMBuildGEP(builder, io_ptr, &ind3, 1, "");

   clip_ptr0 = draw_jit_header_clip(gallivm, io0_ptr);
   clip_ptr1 = draw_jit_header_clip(gallivm, io1_ptr);
   clip_ptr2 = draw_jit_header_clip(gallivm, io2_ptr);
   clip_ptr3 = draw_jit_header_clip(gallivm, io3_ptr);

   for (i = 0; i<4; i++) {
      clip0_ptr = LLVMBuildGEP(builder, clip_ptr0, indices, 2, ""); /* x0 */
      clip1_ptr = LLVMBuildGEP(builder, clip_ptr1, indices, 2, ""); /* x1 */
      clip2_ptr = LLVMBuildGEP(builder, clip_ptr2, indices, 2, ""); /* x2 */
      clip3_ptr = LLVMBuildGEP(builder, clip_ptr3, indices, 2, ""); /* x3 */

      out0elem = LLVMBuildExtractElement(builder, out[i], ind0, ""); /* x0 */
      out1elem = LLVMBuildExtractElement(builder, out[i], ind1, ""); /* x1 */
      out2elem = LLVMBuildExtractElement(builder, out[i], ind2, ""); /* x2 */
      out3elem = LLVMBuildExtractElement(builder, out[i], ind3, ""); /* x3 */
  
      LLVMBuildStore(builder, out0elem, clip0_ptr);
      LLVMBuildStore(builder, out1elem, clip1_ptr);
      LLVMBuildStore(builder, out2elem, clip2_ptr);
      LLVMBuildStore(builder, out3elem, clip3_ptr);
d1039 3
a1041 1
      indices[1]= LLVMBuildAdd(builder, indices[1], ind1, "");
d1044 14
a1057 1
}
d1059 11
d1071 2
a1072 11
/**
 * Equivalent of _mm_set1_ps(a)
 */
static LLVMValueRef
vec4f_from_scalar(struct gallivm_state *gallivm,
                  LLVMValueRef a,
                  const char *name)
{
   LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
   LLVMValueRef res = LLVMGetUndef(LLVMVectorType(float_type, 4));
   int i;
d1074 2
a1075 4
   for (i = 0; i < 4; ++i) {
      LLVMValueRef index = lp_build_const_int32(gallivm, i);
      res = LLVMBuildInsertElement(gallivm->builder, res, a,
                                   index, i == 3 ? name : "");
a1076 2

   return res;
d1084 1
a1084 1
generate_viewport(struct draw_llvm *llvm,
d1086 2
a1087 1
                  LLVMValueRef (*outputs)[NUM_CHANNELS],
d1091 6
a1096 4
   struct gallivm_state *gallivm = llvm->gallivm;
   struct lp_type f32_type = lp_type_float_vec(32);
   LLVMValueRef out3 = LLVMBuildLoad(builder, outputs[0][3], ""); /*w0 w1 w2 w3*/   
   LLVMValueRef const1 = lp_build_const_vec(gallivm, f32_type, 1.0);       /*1.0 1.0 1.0 1.0*/ 
d1101 2
a1102 2
   LLVMBuildStore(builder, out3, outputs[0][3]);
  
d1105 1
a1105 1
      LLVMValueRef out = LLVMBuildLoad(builder, outputs[0][i], ""); /*x0 x1 x2 x3*/
d1111 1
a1111 1
      
d1118 4
a1121 2
      scale = vec4f_from_scalar(gallivm, LLVMBuildLoad(builder, scale_i, ""), "scale");
      trans = vec4f_from_scalar(gallivm, LLVMBuildLoad(builder, trans_i, ""), "trans");
d1131 1
a1131 1
      LLVMBuildStore(builder, out, outputs[0][i]);
d1133 1
a1133 1
   
d1138 1
a1138 1
 * Returns clipmask as 4xi32 bitmask for the 4 vertices
d1140 5
a1144 3
static LLVMValueRef 
generate_clipmask(struct gallivm_state *gallivm,
                  LLVMValueRef (*outputs)[NUM_CHANNELS],
d1149 3
a1151 2
                  unsigned nr,
                  LLVMValueRef context_ptr)
d1154 2
a1155 2
   LLVMValueRef mask; /* stores the <4xi32> clipmasks */     
   LLVMValueRef test, temp; 
d1158 1
d1160 23
a1182 2
   unsigned i;
   struct lp_type f32_type = lp_type_float_vec(32); 
d1184 20
a1203 10
   mask = lp_build_const_int_vec(gallivm, lp_type_int_vec(32), 0);
   temp = lp_build_const_int_vec(gallivm, lp_type_int_vec(32), 0);
   zero = lp_build_const_vec(gallivm, f32_type, 0);                    /* 0.0f 0.0f 0.0f 0.0f */
   shift = lp_build_const_int_vec(gallivm, lp_type_int_vec(32), 1);    /* 1 1 1 1 */

   /* Assuming position stored at output[0] */
   pos_x = LLVMBuildLoad(builder, outputs[0][0], ""); /*x0 x1 x2 x3*/
   pos_y = LLVMBuildLoad(builder, outputs[0][1], ""); /*y0 y1 y2 y3*/
   pos_z = LLVMBuildLoad(builder, outputs[0][2], ""); /*z0 z1 z2 z3*/
   pos_w = LLVMBuildLoad(builder, outputs[0][3], ""); /*w0 w1 w2 w3*/   
d1210 1
a1210 1
      test = LLVMBuildAnd(builder, test, temp, ""); 
d1212 1
a1212 1
   
d1217 1
a1217 1
      test = LLVMBuildAnd(builder, test, temp, ""); 
d1219 1
a1219 1
   
d1223 1
a1223 1
      test = LLVMBuildAnd(builder, test, temp, ""); 
d1230 1
a1230 1
      test = LLVMBuildAnd(builder, test, temp, ""); 
d1235 1
a1235 1
      temp = lp_build_const_int_vec(gallivm, lp_type_int_vec(32), 16);
d1239 1
a1239 1
         test = LLVMBuildAnd(builder, test, temp, ""); 
d1241 1
a1241 1
      }  
d1246 1
a1246 1
         test = LLVMBuildAnd(builder, test, temp, ""); 
d1252 1
a1252 1
      test = LLVMBuildAnd(builder, test, temp, ""); 
d1254 1
a1254 1
   }   
a1258 1
      temp = lp_build_const_int_vec(gallivm, lp_type_int_vec(32), 32);
d1261 57
a1317 35
      for (i = 6; i < nr; i++) {
         indices[0] = lp_build_const_int32(gallivm, 0);
         indices[1] = lp_build_const_int32(gallivm, i);

         indices[2] = lp_build_const_int32(gallivm, 0);
         plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
         plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_x");
         planes = vec4f_from_scalar(gallivm, plane1, "plane4_x");
         sum = LLVMBuildFMul(builder, planes, pos_x, "");

         indices[2] = lp_build_const_int32(gallivm, 1);
         plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
         plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_y"); 
         planes = vec4f_from_scalar(gallivm, plane1, "plane4_y");
         test = LLVMBuildFMul(builder, planes, pos_y, "");
         sum = LLVMBuildFAdd(builder, sum, test, "");
         
         indices[2] = lp_build_const_int32(gallivm, 2);
         plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
         plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_z"); 
         planes = vec4f_from_scalar(gallivm, plane1, "plane4_z");
         test = LLVMBuildFMul(builder, planes, pos_z, "");
         sum = LLVMBuildFAdd(builder, sum, test, "");

         indices[2] = lp_build_const_int32(gallivm, 3);
         plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
         plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_w"); 
         planes = vec4f_from_scalar(gallivm, plane1, "plane4_w");
         test = LLVMBuildFMul(builder, planes, pos_w, "");
         sum = LLVMBuildFAdd(builder, sum, test, "");

         test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, sum);
         temp = LLVMBuildShl(builder, temp, shift, "");
         test = LLVMBuildAnd(builder, test, temp, ""); 
         mask = LLVMBuildOr(builder, mask, test, "");
d1326 1
a1326 1
 * Used zero/non-zero i32 value to represent boolean 
d1328 4
a1331 4
static void
clipmask_bool(struct gallivm_state *gallivm,
              LLVMValueRef clipmask,
              LLVMValueRef ret_ptr)
d1334 3
a1336 1
   LLVMValueRef ret = LLVMBuildLoad(builder, ret_ptr, "");   
d1340 6
a1345 2
   for (i=0; i<4; i++) {   
      temp = LLVMBuildExtractElement(builder, clipmask,
d1349 1
a1349 2
   
   LLVMBuildStore(builder, ret, ret_ptr);
d1352 14
d1367 15
a1381 38
static void
draw_llvm_generate(struct draw_llvm *llvm, struct draw_llvm_variant *variant)
{
   struct gallivm_state *gallivm = llvm->gallivm;
   LLVMContextRef context = gallivm->context;
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(context);
   LLVMTypeRef arg_types[8];
   LLVMTypeRef func_type;
   LLVMValueRef context_ptr;
   LLVMBasicBlockRef block;
   LLVMBuilderRef builder;
   LLVMValueRef start, end, count, stride, step, io_itr;
   LLVMValueRef io_ptr, vbuffers_ptr, vb_ptr;
   LLVMValueRef instance_id;
   LLVMValueRef system_values_array;
   struct draw_context *draw = llvm->draw;
   const struct tgsi_shader_info *vs_info = &draw->vs.vertex_shader->info;
   unsigned i, j;
   struct lp_build_context bld;
   struct lp_build_loop_state lp_loop;
   const int max_vertices = 4;
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][NUM_CHANNELS];
   void *code;
   struct lp_build_sampler_soa *sampler = 0;
   LLVMValueRef ret, ret_ptr;
   boolean bypass_viewport = variant->key.bypass_viewport;
   boolean enable_cliptest = variant->key.clip_xy || 
                             variant->key.clip_z  ||
                             variant->key.clip_user;
   
   arg_types[0] = get_context_ptr_type(llvm);       /* context */
   arg_types[1] = get_vertex_header_ptr_type(llvm); /* vertex_header */
   arg_types[2] = get_buffer_ptr_type(llvm);        /* vbuffers */
   arg_types[3] = int32_type;                       /* start */
   arg_types[4] = int32_type;                       /* count */
   arg_types[5] = int32_type;                       /* stride */
   arg_types[6] = get_vb_ptr_type(llvm);            /* pipe_vertex_buffer's */
   arg_types[7] = int32_type;                       /* instance_id */
d1383 6
a1388 1
   func_type = LLVMFunctionType(int32_type, arg_types, Elements(arg_types), 0);
d1390 3
a1392 6
   variant->function = LLVMAddFunction(gallivm->module, "draw_llvm_shader",
                                       func_type);
   LLVMSetFunctionCallConv(variant->function, LLVMCCallConv);
   for (i = 0; i < Elements(arg_types); ++i)
      if (LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
         LLVMAddAttribute(LLVMGetParam(variant->function, i), LLVMNoAliasAttribute);
d1394 2
a1395 8
   context_ptr  = LLVMGetParam(variant->function, 0);
   io_ptr       = LLVMGetParam(variant->function, 1);
   vbuffers_ptr = LLVMGetParam(variant->function, 2);
   start        = LLVMGetParam(variant->function, 3);
   count        = LLVMGetParam(variant->function, 4);
   stride       = LLVMGetParam(variant->function, 5);
   vb_ptr       = LLVMGetParam(variant->function, 6);
   instance_id  = LLVMGetParam(variant->function, 7);
d1397 19
a1415 47
   lp_build_name(context_ptr, "context");
   lp_build_name(io_ptr, "io");
   lp_build_name(vbuffers_ptr, "vbuffers");
   lp_build_name(start, "start");
   lp_build_name(count, "count");
   lp_build_name(stride, "stride");
   lp_build_name(vb_ptr, "vb");
   lp_build_name(instance_id, "instance_id");

   /*
    * Function body
    */

   block = LLVMAppendBasicBlockInContext(gallivm->context, variant->function, "entry");
   builder = gallivm->builder;
   assert(builder);
   LLVMPositionBuilderAtEnd(builder, block);

   lp_build_context_init(&bld, llvm->gallivm, lp_type_int(32));

   system_values_array = lp_build_system_values_array(gallivm, vs_info,
                                                      instance_id, NULL);

   end = lp_build_add(&bld, start, count);

   step = lp_build_const_int32(gallivm, max_vertices);

   /* function will return non-zero i32 value if any clipped vertices */     
   ret_ptr = lp_build_alloca(gallivm, int32_type, "");   
   LLVMBuildStore(builder, lp_build_const_int32(gallivm, 0), ret_ptr);

   /* code generated texture sampling */
   sampler = draw_llvm_sampler_soa_create(
      draw_llvm_variant_key_samplers(&variant->key),
      context_ptr);

#if DEBUG_STORE
   lp_build_printf(builder, "start = %d, end = %d, step = %d\n",
                   start, end, step);
#endif
   lp_build_loop_begin(&lp_loop, llvm->gallivm, start);
   {
      LLVMValueRef inputs[PIPE_MAX_SHADER_INPUTS][NUM_CHANNELS];
      LLVMValueRef aos_attribs[PIPE_MAX_SHADER_INPUTS][NUM_CHANNELS] = { { 0 } };
      LLVMValueRef io;
      LLVMValueRef clipmask;   /* holds the clipmask value */
      const LLVMValueRef (*ptr_aos)[NUM_CHANNELS];
d1417 6
a1422 62
      io_itr = LLVMBuildSub(builder, lp_loop.counter, start, "");
      io = LLVMBuildGEP(builder, io_ptr, &io_itr, 1, "");
#if DEBUG_STORE
      lp_build_printf(builder, " --- io %d = %p, loop counter %d\n",
                      io_itr, io, lp_loop.counter);
#endif
      for (i = 0; i < NUM_CHANNELS; ++i) {
         LLVMValueRef true_index = LLVMBuildAdd(
            builder,
            lp_loop.counter,
            lp_build_const_int32(gallivm, i), "");
         for (j = 0; j < draw->pt.nr_vertex_elements; ++j) {
            struct pipe_vertex_element *velem = &draw->pt.vertex_element[j];
            LLVMValueRef vb_index = lp_build_const_int32(gallivm, velem->vertex_buffer_index);
            LLVMValueRef vb = LLVMBuildGEP(builder, vb_ptr,
                                           &vb_index, 1, "");
            generate_fetch(llvm->gallivm, vbuffers_ptr,
                           &aos_attribs[j][i], velem, vb, true_index,
                           instance_id);
         }
      }
      convert_to_soa(gallivm, aos_attribs, inputs,
                     draw->pt.nr_vertex_elements);

      ptr_aos = (const LLVMValueRef (*)[NUM_CHANNELS]) inputs;
      generate_vs(llvm,
                  builder,
                  outputs,
                  ptr_aos,
                  system_values_array,
                  context_ptr,
                  sampler,
                  variant->key.clamp_vertex_color);

      /* store original positions in clip before further manipulation */
      store_clip(gallivm, io, outputs);

      /* do cliptest */
      if (enable_cliptest) {
         /* allocate clipmask, assign it integer type */
         clipmask = generate_clipmask(gallivm, outputs,
                                      variant->key.clip_xy,
                                      variant->key.clip_z, 
                                      variant->key.clip_user,
                                      variant->key.clip_halfz,
                                      variant->key.nr_planes,
                                      context_ptr);
         /* return clipping boolean value for function */
         clipmask_bool(gallivm, clipmask, ret_ptr);
      }
      else {
         clipmask = lp_build_const_int_vec(gallivm, lp_type_int_vec(32), 0);    
      }
      
      /* do viewport mapping */
      if (!bypass_viewport) {
         generate_viewport(llvm, builder, outputs, context_ptr);
      }

      /* store clipmask in vertex header and positions in data */
      convert_to_aos(gallivm, io, outputs, clipmask,
                     vs_info->num_outputs, max_vertices);
d1425 5
a1429 1
   lp_build_loop_end_cond(&lp_loop, end, step, LLVMIntUGE);
d1431 13
a1443 1
   sampler->destroy(sampler);
d1445 12
a1456 10
   ret = LLVMBuildLoad(builder, ret_ptr,"");
   LLVMBuildRet(builder, ret);
      
   /*
    * Translate the LLVM IR into machine code.
    */
#ifdef DEBUG
   if (LLVMVerifyFunction(variant->function, LLVMPrintMessageAction)) {
      lp_debug_dump_value(variant->function);
      assert(0);
d1458 1
a1458 1
#endif
d1460 18
a1477 6
   LLVMRunFunctionPassManager(gallivm->passmgr, variant->function);

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      lp_debug_dump_value(variant->function);
      debug_printf("\n");
   }
d1479 2
a1480 7
   code = LLVMGetPointerToGlobal(gallivm->engine, variant->function);
   variant->jit_func = (draw_jit_vert_func)pointer_to_func(code);

   if (gallivm_debug & GALLIVM_DEBUG_ASM) {
      lp_disassemble(code);
   }
   lp_func_delete_body(variant->function);
a1482 1

d1484 2
a1485 1
draw_llvm_generate_elts(struct draw_llvm *llvm, struct draw_llvm_variant *variant)
d1487 1
a1487 1
   struct gallivm_state *gallivm = llvm->gallivm;
d1490 3
a1492 1
   LLVMTypeRef arg_types[8];
d1497 4
a1500 1
   LLVMValueRef fetch_elts, fetch_count, stride, step, io_itr;
d1502 2
a1503 2
   LLVMValueRef instance_id;
   LLVMValueRef system_values_array;
d1509 2
a1510 2
   const int max_vertices = 4;
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][NUM_CHANNELS];
a1511 1
   void *code;
d1513 43
a1555 14
   LLVMValueRef ret, ret_ptr;
   boolean bypass_viewport = variant->key.bypass_viewport;
   boolean enable_cliptest = variant->key.clip_xy || 
                             variant->key.clip_z  ||
                             variant->key.clip_user;
   
   arg_types[0] = get_context_ptr_type(llvm);           /* context */
   arg_types[1] = get_vertex_header_ptr_type(llvm);     /* vertex_header */
   arg_types[2] = get_buffer_ptr_type(llvm);            /* vbuffers */
   arg_types[3] = LLVMPointerType(int32_type, 0);       /* fetch_elts * */
   arg_types[4] = int32_type;                           /* fetch_count */
   arg_types[5] = int32_type;                           /* stride */
   arg_types[6] = get_vb_ptr_type(llvm);                /* pipe_vertex_buffer's */
   arg_types[7] = int32_type;                           /* instance_id */
d1557 2
a1558 5
   func_type = LLVMFunctionType(int32_type, arg_types, Elements(arg_types), 0);

   variant->function_elts = LLVMAddFunction(gallivm->module, "draw_llvm_shader_elts", func_type);
   LLVMSetFunctionCallConv(variant->function_elts, LLVMCCallConv);
   for (i = 0; i < Elements(arg_types); ++i)
d1560 1
a1560 1
         LLVMAddAttribute(LLVMGetParam(variant->function_elts, i),
d1563 6
a1568 8
   context_ptr  = LLVMGetParam(variant->function_elts, 0);
   io_ptr       = LLVMGetParam(variant->function_elts, 1);
   vbuffers_ptr = LLVMGetParam(variant->function_elts, 2);
   fetch_elts   = LLVMGetParam(variant->function_elts, 3);
   fetch_count  = LLVMGetParam(variant->function_elts, 4);
   stride       = LLVMGetParam(variant->function_elts, 5);
   vb_ptr       = LLVMGetParam(variant->function_elts, 6);
   instance_id  = LLVMGetParam(variant->function_elts, 7);
a1572 2
   lp_build_name(fetch_elts, "fetch_elts");
   lp_build_name(fetch_count, "fetch_count");
d1575 18
a1592 1
   lp_build_name(instance_id, "instance_id");
d1598 1
a1598 1
   block = LLVMAppendBasicBlockInContext(gallivm->context, variant->function_elts, "entry");
d1604 6
a1609 2
   system_values_array = lp_build_system_values_array(gallivm, vs_info,
                                                      instance_id, NULL);
d1611 3
a1613 2

   step = lp_build_const_int32(gallivm, max_vertices);
d1617 1
a1617 1
      draw_llvm_variant_key_samplers(&variant->key),
d1620 10
a1629 7
   fetch_max = LLVMBuildSub(builder, fetch_count,
                            lp_build_const_int32(gallivm, 1),
                            "fetch_max");

   /* function returns non-zero i32 value if any clipped vertices */
   ret_ptr = lp_build_alloca(gallivm, int32_type, ""); 
   LLVMBuildStore(builder, lp_build_const_int32(gallivm, 0), ret_ptr);
d1631 3
a1633 1
   lp_build_loop_begin(&lp_loop, gallivm, lp_build_const_int32(gallivm, 0));
d1635 2
a1636 2
      LLVMValueRef inputs[PIPE_MAX_SHADER_INPUTS][NUM_CHANNELS];
      LLVMValueRef aos_attribs[PIPE_MAX_SHADER_INPUTS][NUM_CHANNELS] = { { 0 } };
d1639 1
a1639 1
      const LLVMValueRef (*ptr_aos)[NUM_CHANNELS];
d1642 1
d1645 1
a1645 1
      lp_build_printf(builder, " --- io %d = %p, loop counter %d\n",
d1648 7
a1654 6
      for (i = 0; i < NUM_CHANNELS; ++i) {
         LLVMValueRef true_index = LLVMBuildAdd(
            builder,
            lp_loop.counter,
            lp_build_const_int32(gallivm, i), "");
         LLVMValueRef fetch_ptr;
d1661 42
a1702 3
         fetch_ptr = LLVMBuildGEP(builder, fetch_elts,
                                  &true_index, 1, "");
         true_index = LLVMBuildLoad(builder, fetch_ptr, "fetch_elt");
d1705 4
a1708 4
            LLVMValueRef vb_index = lp_build_const_int32(gallivm, velem->vertex_buffer_index);
            LLVMValueRef vb = LLVMBuildGEP(builder, vb_ptr,
                                           &vb_index, 1, "");
            generate_fetch(gallivm, vbuffers_ptr,
d1710 1
a1710 1
                           instance_id);
d1714 1
a1714 1
                     draw->pt.nr_vertex_elements);
d1716 2
a1717 2
      ptr_aos = (const LLVMValueRef (*)[NUM_CHANNELS]) inputs;
      generate_vs(llvm,
d1719 1
d1722 1
a1722 1
                  system_values_array,
d1725 1
a1725 1
                  variant->key.clamp_vertex_color);
d1727 26
a1752 2
      /* store original positions in clip before further manipulation */
      store_clip(gallivm, io, outputs);
d1754 4
a1757 12
      /* do cliptest */
      if (enable_cliptest) {
         /* allocate clipmask, assign it integer type */
         clipmask = generate_clipmask(gallivm, outputs,
                                      variant->key.clip_xy,
                                      variant->key.clip_z, 
                                      variant->key.clip_user,
                                      variant->key.clip_halfz,
                                      variant->key.nr_planes,
                                      context_ptr);
         /* return clipping boolean value for function */
         clipmask_bool(gallivm, clipmask, ret_ptr);
d1760 1
a1760 6
         clipmask = lp_build_const_int_vec(gallivm, lp_type_int_vec(32), 0);
      }
      
      /* do viewport mapping */
      if (!bypass_viewport) {
         generate_viewport(llvm, builder, outputs, context_ptr);
d1763 7
a1769 6
      /* store clipmask in vertex header, 
       * original positions in clip 
       * and transformed positions in data 
       */   
      convert_to_aos(gallivm, io, outputs, clipmask,
                     vs_info->num_outputs, max_vertices);
d1771 1
d1773 1
a1773 1
   lp_build_loop_end_cond(&lp_loop, fetch_count, step, LLVMIntUGE);
d1775 2
a1776 1
   sampler->destroy(sampler);
a1777 1
   ret = LLVMBuildLoad(builder, ret_ptr,"");   
a1778 17
   
   /*
    * Translate the LLVM IR into machine code.
    */
#ifdef DEBUG
   if (LLVMVerifyFunction(variant->function_elts, LLVMPrintMessageAction)) {
      lp_debug_dump_value(variant->function_elts);
      assert(0);
   }
#endif

   LLVMRunFunctionPassManager(gallivm->passmgr, variant->function_elts);

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      lp_debug_dump_value(variant->function_elts);
      debug_printf("\n");
   }
d1780 1
a1780 7
   code = LLVMGetPointerToGlobal(gallivm->engine, variant->function_elts);
   variant->jit_func_elts = (draw_jit_vert_func_elts)pointer_to_func(code);

   if (gallivm_debug & GALLIVM_DEBUG_ASM) {
      lp_disassemble(code);
   }
   lp_func_delete_body(variant->function_elts);
d1789 1
a1789 1
   struct lp_sampler_static_state *sampler;
d1797 3
d1801 2
a1802 1
   key->nr_vertex_elements = llvm->draw->pt.nr_vertex_elements;
d1809 1
a1809 1
   key->clip_halfz = !llvm->draw->rasterizer->gl_rasterization_rules;
d1811 3
a1813 2
   key->nr_planes = llvm->draw->nr_planes;
   key->pad = 0;
d1820 7
d1828 1
a1828 1
   sampler = draw_llvm_variant_key_samplers(key);
d1833 2
a1834 2
   
   memset(sampler, 0, key->nr_samplers * sizeof *sampler);
d1837 6
a1842 3
      lp_sampler_static_state(&sampler[i],
			      llvm->draw->sampler_views[i],
			      llvm->draw->samplers[i]);
d1850 29
d1880 2
a1881 1
                             unsigned sampler_idx,
d1884 1
d1887 1
a1887 1
                             const void *data[PIPE_MAX_TEXTURE_LEVELS])
d1892 5
a1896 1
   assert(sampler_idx < PIPE_MAX_VERTEX_SAMPLERS);
d1898 9
a1906 1
   jit_tex = &draw->llvm->jit_context.textures[sampler_idx];
d1913 1
d1916 1
a1916 1
      jit_tex->data[j] = data[j];
d1924 2
a1925 1
draw_llvm_set_sampler_state(struct draw_context *draw)
d1929 25
a1953 8
   for (i = 0; i < draw->num_samplers; i++) {
      struct draw_jit_texture *jit_tex = &draw->llvm->jit_context.textures[i];

      if (draw->samplers[i]) {
         jit_tex->min_lod = draw->samplers[i]->min_lod;
         jit_tex->max_lod = draw->samplers[i]->max_lod;
         jit_tex->lod_bias = draw->samplers[i]->lod_bias;
         COPY_4V(jit_tex->border_color, draw->samplers[i]->border_color);
d1965 2
a1966 3
      LLVMFreeMachineCodeForFunction(llvm->gallivm->engine,
                                     variant->function_elts);
      LLVMDeleteFunction(variant->function_elts);
d1970 2
a1971 3
      LLVMFreeMachineCodeForFunction(llvm->gallivm->engine,
                                     variant->function);
      LLVMDeleteFunction(variant->function);
d1974 2
d1981 308
@


1.2
log
@Lets gallium a chance to build with our llvm port
@
text
@d109 1
d148 3
d235 1
a235 1
   LLVMTypeRef elem_types[4];
d239 2
a240 3
   elem_types[1] =
   elem_types[2] = LLVMInt32TypeInContext(gallivm->context);
   elem_types[3] = LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0); /* vs_constants */
d257 1
a257 1
                          target, vb_type, 2);
d460 1
d466 1
d468 2
a469 1
            struct lp_build_sampler_soa *draw_sampler)
d490 1
a490 2
   if (llvm->draw->num_sampler_views &&
       llvm->draw->num_samplers)
d498 1
d504 23
d529 1
d548 1
a564 1
   LLVMValueRef vb_max_index = draw_jit_vbuffer_max_index(gallivm, vbuf);
a565 1
   LLVMValueRef cond;
a574 4
   /* limit index to min(index, vb_max_index) */
   cond = LLVMBuildICmp(builder, LLVMIntULE, index, vb_max_index, "");
   index = LLVMBuildSelect(builder, cond, index, vb_max_index, "");

d592 1
d636 1
d673 1
d701 1
d778 1
d827 1
d845 2
a846 2
      for(chan = 0; chan < NUM_CHANNELS; ++chan) {
         if(outputs[attrib][chan]) {
d854 2
a855 1
         } else
d857 1
d872 2
a873 1
/*
d915 1
a915 1
   for (i = 0; i<4; i++){
d936 3
a938 1
/* Equivalent of _mm_set1_ps(a)
d949 1
a949 1
   for(i = 0; i < 4; ++i) {
d958 2
a959 1
/*
d980 1
a980 1
   for (i=0; i<3; i++){
d1011 1
a1011 1
/*
a1029 1

a1030 1

d1045 1
a1045 1
   if (clip_xy){
d1073 1
a1073 1
   if (clip_z){
d1075 1
a1075 1
      if (clip_halfz){
d1081 1
a1081 1
      else{
d1095 1
a1095 1
   if (clip_user){
d1141 2
a1142 1
/*
d1156 1
a1156 1
   for (i=0; i<4; i++){   
d1165 1
d1180 1
d1182 1
d1210 2
a1211 2
   for(i = 0; i < Elements(arg_types); ++i)
      if(LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
d1243 3
d1300 1
d1302 2
a1303 1
                  sampler);
d1309 1
a1309 1
      if (enable_cliptest){
d1321 1
a1321 1
      else{
d1326 1
a1326 1
      if (!bypass_viewport){
d1332 1
a1332 2
                     draw->vs.vertex_shader->info.num_outputs,
                     max_vertices);
d1346 1
a1346 1
   if(LLVMVerifyFunction(variant->function, LLVMPrintMessageAction)) {
d1383 1
d1385 1
d1413 2
a1414 2
   for(i = 0; i < Elements(arg_types); ++i)
      if(LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
d1446 4
d1512 1
d1514 2
a1515 1
                  sampler);
d1521 1
a1521 1
      if (enable_cliptest){
d1533 1
a1533 1
      else{
d1538 1
a1538 1
      if (!bypass_viewport){
d1547 1
a1547 2
                     draw->vs.vertex_shader->info.num_outputs,
                     max_vertices);
d1561 1
a1561 1
   if(LLVMVerifyFunction(variant->function_elts, LLVMPrintMessageAction)) {
d1593 2
d1633 1
d1638 1
a1638 1
                             uint32_t last_level,
a1647 1

d1653 1
d1656 1
a1656 1
   for (j = 0; j <= last_level; j++) {
d1688 2
a1689 3
      if (variant->function_elts)
         LLVMFreeMachineCodeForFunction(llvm->gallivm->engine,
                                        variant->function_elts);
d1694 2
a1695 3
      if (variant->function)
         LLVMFreeMachineCodeForFunction(llvm->gallivm->engine,
                                        variant->function);
@


1.1
log
@Initial revision
@
text
@d99 1
a99 1
create_jit_texture_type(struct gallivm_state *gallivm)
d122 5
d130 2
d136 1
d183 1
a183 1
                        LLVMTypeRef texture_type)
d196 5
a200 1

d203 1
d206 1
d228 1
a228 1
create_jit_vertex_buffer_type(struct gallivm_state *gallivm)
d237 1
a237 1
   elem_types[3] = LLVMPointerType(LLVMOpaqueTypeInContext(gallivm->context), 0); /* vs_constants */
d239 5
d246 1
d249 1
d279 5
d286 1
d289 1
a311 2
   LLVMAddTypeName(gallivm->module, struct_name, vertex_header);

d325 1
a325 2
   texture_type = create_jit_texture_type(gallivm);
   LLVMAddTypeName(gallivm->module, "texture", texture_type);
d327 1
a327 2
   context_type = create_jit_context_type(gallivm, texture_type);
   LLVMAddTypeName(gallivm->module, "draw_jit_context", context_type);
a330 1
   LLVMAddTypeName(gallivm->module, "buffer", buffer_type);
d333 1
a333 2
   vb_type = create_jit_vertex_buffer_type(gallivm);
   LLVMAddTypeName(gallivm->module, "pipe_vertex_buffer", vb_type);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a31 1
#include "draw_gs.h"
a33 1
#include "gallivm/lp_bld_arit_overflow.h"
a45 2
#include "gallivm/lp_bld_pack.h"
#include "gallivm/lp_bld_format.h"
a58 18
static void
draw_llvm_generate(struct draw_llvm *llvm, struct draw_llvm_variant *var,
                   boolean elts);


struct draw_gs_llvm_iface {
   struct lp_build_tgsi_gs_iface base;

   struct draw_gs_llvm_variant *variant;
   LLVMValueRef input;
};

static INLINE const struct draw_gs_llvm_iface *
draw_gs_llvm_iface(const struct lp_build_tgsi_gs_iface *iface)
{
   return (const struct draw_gs_llvm_iface *)iface;
}

d60 3
a62 1
 * Create LLVM type for draw_vertex_buffer.
d64 2
a65 3
static LLVMTypeRef
create_jit_dvbuffer_type(struct gallivm_state *gallivm,
                         const char *struct_name)
d67 2
a68 4
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef dvbuffer_type;
   LLVMTypeRef elem_types[DRAW_JIT_DVBUFFER_NUM_FIELDS];
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(gallivm->context);
d70 7
a76 3
   elem_types[DRAW_JIT_DVBUFFER_MAP] =
      LLVMPointerType(LLVMIntTypeInContext(gallivm->context, 8), 0);
   elem_types[DRAW_JIT_DVBUFFER_SIZE] = int32_type;
d78 8
a85 2
   dvbuffer_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                           Elements(elem_types), 0);
a86 2
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, dvbuffer_type);
d88 2
a89 5
   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, dvbuffer_type);
#endif
d91 2
a92 6
   LP_CHECK_MEMBER_OFFSET(struct draw_vertex_buffer, map,
                          target, dvbuffer_type,
                          DRAW_JIT_DVBUFFER_MAP);
   LP_CHECK_MEMBER_OFFSET(struct draw_vertex_buffer, size,
                          target, dvbuffer_type,
                          DRAW_JIT_DVBUFFER_SIZE);
a93 2
   return dvbuffer_type;
}
d99 1
a99 1
create_jit_texture_type(struct gallivm_state *gallivm, const char *struct_name)
a108 1
   elem_types[DRAW_JIT_TEXTURE_FIRST_LEVEL] =
a109 2
   elem_types[DRAW_JIT_TEXTURE_BASE] =
      LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0);
a111 1
   elem_types[DRAW_JIT_TEXTURE_MIP_OFFSETS] =
d113 8
a124 3
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, texture_type);

a128 1
#endif
a138 3
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, first_level,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_FIRST_LEVEL);
a141 3
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, base,
                          target, texture_type,
                          DRAW_JIT_TEXTURE_BASE);
d148 13
a160 1
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, mip_offsets,
d162 1
a162 1
                          DRAW_JIT_TEXTURE_MIP_OFFSETS);
d171 1
a171 48
 * Create LLVM type for struct draw_jit_sampler
 */
static LLVMTypeRef
create_jit_sampler_type(struct gallivm_state *gallivm, const char *struct_name)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef sampler_type;
   LLVMTypeRef elem_types[DRAW_JIT_SAMPLER_NUM_FIELDS];

   elem_types[DRAW_JIT_SAMPLER_MIN_LOD] =
   elem_types[DRAW_JIT_SAMPLER_MAX_LOD] =
   elem_types[DRAW_JIT_SAMPLER_LOD_BIAS] = LLVMFloatTypeInContext(gallivm->context);
   elem_types[DRAW_JIT_SAMPLER_BORDER_COLOR] =
      LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);

   sampler_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                          Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, sampler_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, sampler_type);
#endif

   LP_CHECK_MEMBER_OFFSET(struct draw_jit_sampler, min_lod,
                          target, sampler_type,
                          DRAW_JIT_SAMPLER_MIN_LOD);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_sampler, max_lod,
                          target, sampler_type,
                          DRAW_JIT_SAMPLER_MAX_LOD);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_sampler, lod_bias,
                          target, sampler_type,
                          DRAW_JIT_SAMPLER_LOD_BIAS);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_sampler, border_color,
                          target, sampler_type,
                          DRAW_JIT_SAMPLER_BORDER_COLOR);

   LP_CHECK_STRUCT_SIZE(struct draw_jit_sampler, target, sampler_type);

   return sampler_type;
}


/**
 * Create LLVM type for struct draw_jit_context
d175 1
a175 2
                        LLVMTypeRef texture_type, LLVMTypeRef sampler_type,
                        const char *struct_name)
d179 1
a179 1
   LLVMTypeRef elem_types[DRAW_JIT_CTX_NUM_FIELDS];
d182 7
a188 9
   elem_types[0] = LLVMArrayType(LLVMPointerType(float_type, 0), /* vs_constants */
                                 LP_MAX_TGSI_CONST_BUFFERS);
   elem_types[1] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4),
                                                 DRAW_TOTAL_CLIP_PLANES), 0);
   elem_types[2] = LLVMPointerType(float_type, 0); /* viewport */
   elem_types[3] = LLVMArrayType(texture_type,
                                 PIPE_MAX_SHADER_SAMPLER_VIEWS); /* textures */
   elem_types[4] = LLVMArrayType(sampler_type,
                                 PIPE_MAX_SAMPLERS); /* samplers */
a190 2
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, context_type);
a192 1
#endif
d195 3
a197 1
                          target, context_type, DRAW_JIT_CTX_CONSTANTS);
d199 1
a199 3
                          target, context_type, DRAW_JIT_CTX_PLANES);
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, viewport,
                          target, context_type, DRAW_JIT_CTX_VIEWPORT);
a202 3
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, samplers,
                          target, context_type,
                          DRAW_JIT_CTX_SAMPLERS);
a210 82
 * Create LLVM type for struct draw_gs_jit_context
 */
static LLVMTypeRef
create_gs_jit_context_type(struct gallivm_state *gallivm,
                           unsigned vector_length,
                           LLVMTypeRef texture_type, LLVMTypeRef sampler_type,
                           const char *struct_name)
{
   LLVMTargetDataRef target = gallivm->target;
   LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
   LLVMTypeRef int_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMTypeRef elem_types[DRAW_GS_JIT_CTX_NUM_FIELDS];
   LLVMTypeRef context_type;

   elem_types[0] = LLVMArrayType(LLVMPointerType(float_type, 0), /* constants */
                                 LP_MAX_TGSI_CONST_BUFFERS);
   elem_types[1] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4),
                                                 DRAW_TOTAL_CLIP_PLANES), 0);
   elem_types[2] = LLVMPointerType(float_type, 0); /* viewport */

   elem_types[3] = LLVMArrayType(texture_type,
                                 PIPE_MAX_SHADER_SAMPLER_VIEWS); /* textures */
   elem_types[4] = LLVMArrayType(sampler_type,
                                 PIPE_MAX_SAMPLERS); /* samplers */
   
   elem_types[5] = LLVMPointerType(LLVMPointerType(int_type, 0), 0);
   elem_types[6] = LLVMPointerType(LLVMVectorType(int_type,
                                                  vector_length), 0);
   elem_types[7] = LLVMPointerType(LLVMVectorType(int_type,
                                                  vector_length), 0);

   context_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                          Elements(elem_types), 0);
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, context_type);

   LLVMInvalidateStructLayout(gallivm->target, context_type);
#endif

   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, constants,
                          target, context_type, DRAW_GS_JIT_CTX_CONSTANTS);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, planes,
                          target, context_type, DRAW_GS_JIT_CTX_PLANES);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, viewport,
                          target, context_type, DRAW_GS_JIT_CTX_VIEWPORT);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, textures,
                          target, context_type,
                          DRAW_GS_JIT_CTX_TEXTURES);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, samplers,
                          target, context_type,
                          DRAW_GS_JIT_CTX_SAMPLERS);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, prim_lengths,
                          target, context_type,
                          DRAW_GS_JIT_CTX_PRIM_LENGTHS);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, emitted_vertices,
                          target, context_type,
                          DRAW_GS_JIT_CTX_EMITTED_VERTICES);
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, emitted_prims,
                          target, context_type,
                          DRAW_GS_JIT_CTX_EMITTED_PRIMS);
   LP_CHECK_STRUCT_SIZE(struct draw_gs_jit_context,
                        target, context_type);

   return context_type;
}


static LLVMTypeRef
create_gs_jit_input_type(struct gallivm_state *gallivm)
{
   LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
   LLVMTypeRef input_array;

   input_array = LLVMVectorType(float_type, TGSI_NUM_CHANNELS); /* num primitives */
   input_array = LLVMArrayType(input_array, TGSI_NUM_CHANNELS); /* num channels */
   input_array = LLVMArrayType(input_array, PIPE_MAX_SHADER_INPUTS); /* num attrs per vertex */
   input_array = LLVMPointerType(input_array, 0); /* num vertices per prim */

   return input_array;
}

/**
d214 1
a214 2
create_jit_vertex_buffer_type(struct gallivm_state *gallivm,
                              const char *struct_name)
d221 3
a223 3
   elem_types[1] = LLVMInt32TypeInContext(gallivm->context);
   elem_types[2] =
   elem_types[3] = LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0);
a226 2
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, vb_type);
a228 1
#endif
d233 1
a233 1
                          target, vb_type, 1);
d248 1
a248 1
   LLVMTypeRef elem_types[4];
d254 3
a256 4
   elem_types[DRAW_JIT_VERTEX_VERTEX_ID]  = LLVMIntTypeInContext(gallivm->context, 32);
   elem_types[DRAW_JIT_VERTEX_CLIP]  = LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);
   elem_types[DRAW_JIT_VERTEX_PRE_CLIP_POS]  = LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);
   elem_types[DRAW_JIT_VERTEX_DATA]  = LLVMArrayType(elem_types[1], data_elems);
a259 2
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, vertex_header);
a261 1
#endif
a279 3
   LP_CHECK_MEMBER_OFFSET(struct vertex_header, pre_clip_pos,
                          target, vertex_header,
                          DRAW_JIT_VERTEX_PRE_CLIP_POS);
d284 1
a284 2
   assert(LLVMABISizeOfType(target, vertex_header) ==
          offsetof(struct vertex_header, data[data_elems]));
d294 1
a294 1
create_jit_types(struct draw_llvm_variant *variant)
d296 5
a300 3
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMTypeRef texture_type, sampler_type, context_type, buffer_type,
      vb_type;
d302 3
a304 2
   texture_type = create_jit_texture_type(gallivm, "texture");
   sampler_type = create_jit_sampler_type(gallivm, "sampler");
d306 3
a308 3
   context_type = create_jit_context_type(gallivm, texture_type, sampler_type,
                                          "draw_jit_context");
   variant->context_ptr_type = LLVMPointerType(context_type, 0);
d310 3
a312 5
   buffer_type = create_jit_dvbuffer_type(gallivm, "draw_vertex_buffer");
   variant->buffer_ptr_type = LLVMPointerType(buffer_type, 0);
   
   vb_type = create_jit_vertex_buffer_type(gallivm, "pipe_vertex_buffer");
   variant->vb_ptr_type = LLVMPointerType(vb_type, 0);
d317 1
a317 1
get_context_ptr_type(struct draw_llvm_variant *variant)
d319 3
a321 3
   if (!variant->context_ptr_type)
      create_jit_types(variant);
   return variant->context_ptr_type;
d326 1
a326 1
get_buffer_ptr_type(struct draw_llvm_variant *variant)
d328 3
a330 3
   if (!variant->buffer_ptr_type)
      create_jit_types(variant);
   return variant->buffer_ptr_type;
d335 1
a335 1
get_vb_ptr_type(struct draw_llvm_variant *variant)
d337 3
a339 3
   if (!variant->vb_ptr_type)
      create_jit_types(variant);
   return variant->vb_ptr_type;
d343 1
a343 1
get_vertex_header_ptr_type(struct draw_llvm_variant *variant)
d345 3
a347 3
   if (!variant->vertex_header_ptr_type)
      create_jit_types(variant);
   return variant->vertex_header_ptr_type;
d355 1
a355 1
draw_llvm_create(struct draw_context *draw)
d366 5
d375 2
a376 2
   llvm->nr_gs_variants = 0;
   make_empty_list(&llvm->gs_variants_list);
d388 3
d401 2
a402 2
                         unsigned num_inputs,
                         const struct draw_llvm_variant_key *key)
d410 2
a411 2
                    shader->variant_key_size -
                    sizeof variant->key);
a416 4
   variant->gallivm = gallivm_create();

   create_jit_types(variant);

d419 1
a419 1
   vertex_header = create_jit_vertex_header(variant->gallivm, num_inputs);
d421 1
a421 1
   variant->vertex_header_ptr_type = LLVMPointerType(vertex_header, 0);
d423 2
a424 10
   draw_llvm_generate(llvm, variant, FALSE);  /* linear */
   draw_llvm_generate(llvm, variant, TRUE);   /* elts */

   gallivm_compile_module(variant->gallivm);

   variant->jit_func = (draw_jit_vert_func)
         gallivm_jit_function(variant->gallivm, variant->function);

   variant->jit_func_elts = (draw_jit_vert_func_elts)
         gallivm_jit_function(variant->gallivm, variant->function_elts);
a434 1

d436 1
a436 1
generate_vs(struct draw_llvm_variant *variant,
d438 2
a439 4
            struct lp_type vs_type,
            LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
            const LLVMValueRef (*inputs)[TGSI_NUM_CHANNELS],
            const struct lp_bld_tgsi_system_values *system_values,
d441 1
a441 2
            struct lp_build_sampler_soa *draw_sampler,
            boolean clamp_vertex_color)
a442 1
   struct draw_llvm *llvm = variant->llvm;
d444 2
a445 1
   LLVMValueRef consts_ptr = draw_jit_context_vs_constants(variant->gallivm, context_ptr);
d448 11
a458 1
   if (gallivm_debug & (GALLIVM_DEBUG_TGSI | GALLIVM_DEBUG_IR)) {
a459 1
      draw_llvm_dump_variant_key(&variant->key);
d462 2
a463 1
   if (llvm->draw->num_sampler_views && llvm->draw->num_samplers)
d466 1
a466 1
   lp_build_tgsi_soa(variant->gallivm,
d471 1
a471 1
                     system_values,
d475 2
a476 2
                     &llvm->draw->vs.vertex_shader->info,
                     NULL);
d478 15
a492 30
   {
      LLVMValueRef out;
      unsigned chan, attrib;
      struct lp_build_context bld;
      struct tgsi_shader_info* info = &llvm->draw->vs.vertex_shader->info;
      lp_build_context_init(&bld, variant->gallivm, vs_type);

      for (attrib = 0; attrib < info->num_outputs; ++attrib) {
         for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
            if (outputs[attrib][chan]) {
               switch (info->output_semantic_name[attrib]) {
               case TGSI_SEMANTIC_COLOR:
               case TGSI_SEMANTIC_BCOLOR:
                  if (clamp_vertex_color) {
                     out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
                     out = lp_build_clamp(&bld, out, bld.zero, bld.one);
                     LLVMBuildStore(builder, out, outputs[attrib][chan]);
                  }
                  break;
               case TGSI_SEMANTIC_FOG:
                  if (chan == 1 || chan == 2)
                     LLVMBuildStore(builder, bld.zero, outputs[attrib][chan]);
                  else if (chan == 3)
                     LLVMBuildStore(builder, bld.one, outputs[attrib][chan]);
                  break;
               }
            }
         }
      }
   }
d494 1
a497 1
               struct draw_context *draw,
a504 3
   const struct util_format_description *format_desc =
      util_format_description(velem->src_format);
   LLVMValueRef zero = LLVMConstNull(LLVMInt32TypeInContext(gallivm->context));
d512 1
d514 1
a514 2
   LLVMValueRef map_ptr = draw_jit_dvbuffer_map(gallivm, vbuffer_ptr);
   LLVMValueRef buffer_size = draw_jit_dvbuffer_size(gallivm, vbuffer_ptr);
a515 7
   LLVMValueRef buffer_overflowed;
   LLVMValueRef needed_buffer_size;
   LLVMValueRef temp_ptr =
      lp_build_alloca(gallivm,
                      lp_build_vec_type(gallivm, lp_float32_vec4_type()), "");
   LLVMValueRef ofbit = NULL;
   struct lp_build_if_state if_ctx;
d518 26
a543 44
      /* Index is equal to the start instance plus the number of current 
       * instance divided by the divisor. In this case we compute it as:
       * index = start_instance + ((instance_id - start_instance) / divisor)
       */
      LLVMValueRef current_instance;
      index = lp_build_const_int32(gallivm, draw->start_instance);
      current_instance = LLVMBuildSub(builder, instance_id, index, "");
      current_instance = LLVMBuildUDiv(builder, current_instance,
                                       lp_build_const_int32(gallivm, velem->instance_divisor),
                                       "instance_divisor");
      index = LLVMBuildAdd(builder, index, current_instance, "instance");
   }

   stride = lp_build_umul_overflow(gallivm, vb_stride, index, &ofbit);
   stride = lp_build_uadd_overflow(gallivm, stride, vb_buffer_offset, &ofbit);
   stride = lp_build_uadd_overflow(
      gallivm, stride,
      lp_build_const_int32(gallivm, velem->src_offset), &ofbit);
   needed_buffer_size = lp_build_uadd_overflow(
      gallivm, stride,
      lp_build_const_int32(gallivm,
                           util_format_get_blocksize(velem->src_format)),
      &ofbit);

   buffer_overflowed = LLVMBuildICmp(builder, LLVMIntUGT,
                                     needed_buffer_size, buffer_size,
                                     "buffer_overflowed");
   buffer_overflowed = LLVMBuildOr(builder, buffer_overflowed, ofbit, "");
#if 0
   lp_build_printf(gallivm, "vbuf index = %u, vb_stride is %u\n",
                   index, vb_stride);
   lp_build_printf(gallivm, "   vb_buffer_offset = %u, src_offset is %u\n",
                   vb_buffer_offset,
                   lp_build_const_int32(gallivm, velem->src_offset));
   lp_build_print_value(gallivm, "   blocksize = ",
                        lp_build_const_int32(
                           gallivm,
                           util_format_get_blocksize(velem->src_format)));
   lp_build_printf(gallivm, "   instance_id = %u\n", instance_id);
   lp_build_printf(gallivm, "   stride = %u\n", stride);
   lp_build_printf(gallivm, "   buffer size = %u\n", buffer_size);
   lp_build_printf(gallivm, "   needed_buffer_size = %u\n", needed_buffer_size);
   lp_build_print_value(gallivm, "   buffer overflowed = ", buffer_overflowed);
#endif
d545 10
a554 10
   lp_build_if(&if_ctx, gallivm, buffer_overflowed);
   {
      LLVMValueRef val =
         lp_build_const_vec(gallivm, lp_float32_vec4_type(), 0);
      LLVMBuildStore(builder, val, temp_ptr);
   }
   lp_build_else(&if_ctx);
   {
      LLVMValueRef val;
      map_ptr = LLVMBuildGEP(builder, map_ptr, &stride, 1, "");
d556 28
a583 8
      val = lp_build_fetch_rgba_aos(gallivm,
                                    format_desc,
                                    lp_float32_vec4_type(),
                                    map_ptr,
                                    zero, zero, zero);
      LLVMBuildStore(builder, val, temp_ptr);
   }
   lp_build_endif(&if_ctx);
d585 1
a585 1
   *res = LLVMBuildLoad(builder, temp_ptr, "aos");
d589 3
a591 4
convert_to_soa(struct gallivm_state *gallivm,
               LLVMValueRef (*src_aos)[LP_MAX_VECTOR_WIDTH / 32],
               LLVMValueRef (*dst_soa)[TGSI_NUM_CHANNELS],
               unsigned num_attribs, const struct lp_type soa_type)
d593 3
a595 2
   unsigned i, j, k;
   struct lp_type aos_channel_type = soa_type;
d597 1
a597 2
   debug_assert(TGSI_NUM_CHANNELS == 4);
   debug_assert((soa_type.length % TGSI_NUM_CHANNELS) == 0);
d599 2
a600 1
   aos_channel_type.length >>= 1;
d602 2
a603 3
   for (i = 0; i < num_attribs; ++i) {
      LLVMValueRef aos_channels[TGSI_NUM_CHANNELS];
      unsigned pixels_per_channel = soa_type.length / TGSI_NUM_CHANNELS;
d605 3
a607 2
      for (j = 0; j < TGSI_NUM_CHANNELS; ++j) {
         LLVMValueRef channel[LP_MAX_VECTOR_LENGTH] = { 0 };
d609 3
a611 1
         assert(pixels_per_channel <= LP_MAX_VECTOR_LENGTH);
d613 3
a615 3
         for (k = 0; k < pixels_per_channel; ++k) {
            channel[k] = src_aos[i][j + TGSI_NUM_CHANNELS * k];
         }
d617 3
a619 2
         aos_channels[j] = lp_build_concat(gallivm, channel, aos_channel_type, pixels_per_channel);
      }
a620 1
      lp_build_transpose_aos(gallivm, soa_type, aos_channels, dst_soa[i]);
d624 26
d655 2
a656 1
          LLVMValueRef value)
a657 1
   LLVMTypeRef data_ptr_type = LLVMPointerType(lp_build_vec_type(gallivm, lp_float32_vec4_type()), 0);
d659 1
d662 1
d668 10
a677 2
   data_ptr = LLVMBuildGEP(builder, data_ptr, indices, 3, "");
   data_ptr = LLVMBuildPointerCast(builder, data_ptr, data_ptr_type, "");
d680 1
a680 1
   lp_build_printf(gallivm, "    ---- %p storing attribute %d (io = %p)\n", data_ptr, index, io_ptr);
d682 7
d690 34
a723 48
   /* Unaligned store due to the vertex header */
   lp_set_store_alignment(LLVMBuildStore(builder, value, data_ptr), sizeof(float));
}

/**
 * Adjust the mask to architecture endianess. The mask will the store in struct:
 *
 * struct vertex_header {
 *    unsigned clipmask:DRAW_TOTAL_CLIP_PLANES;
 *    unsigned edgeflag:1;
 *    unsigned have_clipdist:1;
 *    unsigned vertex_id:16;
 *    [...]
 * }
 *
 * On little-endian machine nothing needs to done, however on bit-endian machine
 * the mask's fields need to be adjusted with the algorithm:
 *
 * uint32_t reverse (uint32_t x)
 * {
 *   return (x >> 16) |              // vertex_id
 *          ((x & 0x3fff) << 18) |   // clipmask
 *          ((x & 0x4000) << 3) |    // have_clipdist
 *          ((x & 0x8000) << 1);     // edgeflag
 * }
 */
static LLVMValueRef
adjust_mask(struct gallivm_state *gallivm,
            LLVMValueRef mask)
{
#ifdef PIPE_ARCH_BIG_ENDIAN
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef vertex_id;
   LLVMValueRef clipmask;
   LLVMValueRef have_clipdist;
   LLVMValueRef edgeflag;

   vertex_id = LLVMBuildLShr(builder, mask, lp_build_const_int32(gallivm, 16), "");
   clipmask  = LLVMBuildAnd(builder, mask, lp_build_const_int32(gallivm, 0x3fff), "");
   clipmask  = LLVMBuildShl(builder, clipmask, lp_build_const_int32(gallivm, 18), "");
   have_clipdist = LLVMBuildAnd(builder, mask, lp_build_const_int32(gallivm, 0x4000), "");
   have_clipdist = LLVMBuildShl(builder, have_clipdist, lp_build_const_int32(gallivm, 3), "");
   edgeflag = LLVMBuildAnd(builder, mask, lp_build_const_int32(gallivm, 0x8000), "");
   edgeflag = LLVMBuildShl(builder, edgeflag, lp_build_const_int32(gallivm, 1), "");

   mask = LLVMBuildOr(builder, vertex_id, clipmask, "");
   mask = LLVMBuildOr(builder, mask, have_clipdist, "");
   mask = LLVMBuildOr(builder, mask, edgeflag, "");
a724 1
   return mask;
a728 1
                struct lp_type soa_type,
d730 1
a730 2
                LLVMValueRef *indices,
                LLVMValueRef* aos,
d733 1
a733 2
                LLVMValueRef clipmask,
                boolean have_clipdist)
d737 8
a744 7
   LLVMValueRef inds[LP_MAX_VECTOR_WIDTH / 32];
   LLVMValueRef linear_inds[LP_MAX_VECTOR_WIDTH / 32];
   LLVMValueRef io_ptrs[LP_MAX_VECTOR_WIDTH / 32];
   int vector_length = soa_type.length;
   int i;

   debug_assert(TGSI_NUM_CHANNELS == 4);
d746 17
a762 9
   for (i = 0; i < vector_length; i++) {
      linear_inds[i] = lp_build_const_int32(gallivm, i);
      if (indices) {
         inds[i] = indices[i];
      } else {
         inds[i] = linear_inds[i];
      }
      io_ptrs[i] = LLVMBuildGEP(builder, io_ptr, &inds[i], 1, "");
   }
a763 21
   if (attrib == 0) {
      /* store vertex header for each of the n vertices */
      LLVMValueRef val, cliptmp;
      int vertex_id_pad_edgeflag;

      /* If this assertion fails, it means we need to update the bit twidding
       * code here.  See struct vertex_header in draw_private.h.
       */
      assert(DRAW_TOTAL_CLIP_PLANES==14);
      /* initialize vertex id:16 = 0xffff, have_clipdist:1 = 0, edgeflag:1 = 1 */
      vertex_id_pad_edgeflag = (0xffff << 16) | (1 << DRAW_TOTAL_CLIP_PLANES);
      if (have_clipdist)
         vertex_id_pad_edgeflag |= 1 << (DRAW_TOTAL_CLIP_PLANES+1);
      val = lp_build_const_int_vec(gallivm, lp_int_type(soa_type), vertex_id_pad_edgeflag);
      /* OR with the clipmask */
      cliptmp = LLVMBuildOr(builder, val, clipmask, "");
      for (i = 0; i < vector_length; i++) {
         LLVMValueRef id_ptr = draw_jit_header_id(gallivm, io_ptrs[i]);
         val = LLVMBuildExtractElement(builder, cliptmp, linear_inds[i], "");
         val = adjust_mask(gallivm, val);
         LLVMBuildStore(builder, val, id_ptr);
d765 2
a766 2
         lp_build_printf(gallivm, "io = %p, index %d, clipmask = %x\n",
                         io_ptrs[i], inds[i], val);
d768 5
a772 7
      }
   }

   /* store for each of the n vertices */
   for (i = 0; i < vector_length; i++) {
      store_aos(gallivm, io_ptrs[i], attr_index, aos[i]);
   }
a774 1

d778 1
a778 2
               LLVMValueRef *indices,
               LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
d781 1
a781 2
               struct lp_type soa_type,
               boolean have_clipdist)
d784 1
a784 1
   unsigned chan, attrib, i;
d787 1
a787 1
   lp_build_printf(gallivm, "   # storing begin\n");
d790 4
a793 4
      LLVMValueRef soa[TGSI_NUM_CHANNELS];
      LLVMValueRef aos[LP_MAX_VECTOR_WIDTH / 32];
      for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
         if (outputs[attrib][chan]) {
d796 4
a799 8
#if DEBUG_STORE
            lp_build_printf(gallivm, "output %d : %d ",
                            LLVMConstInt(LLVMInt32TypeInContext(gallivm->context),
                                         attrib, 0),
                            LLVMConstInt(LLVMInt32TypeInContext(gallivm->context),
                                         chan, 0));
            lp_build_print_value(gallivm, "val = ", out);
#endif
d801 1
a801 2
         }
         else {
a802 15
         }
      }


      if (soa_type.length == TGSI_NUM_CHANNELS) {
         lp_build_transpose_aos(gallivm, soa_type, soa, aos);
      } else {
         lp_build_transpose_aos(gallivm, soa_type, soa, soa);

         for (i = 0; i < soa_type.length; ++i) {
            aos[i] = lp_build_extract_range(gallivm,
                                            soa[i % TGSI_NUM_CHANNELS],
                                            (i / TGSI_NUM_CHANNELS) * TGSI_NUM_CHANNELS,
                                            TGSI_NUM_CHANNELS);
         }
d804 1
a804 1

d806 1
a806 2
                      soa_type,
                      io, indices,
d810 1
a810 1
                      clipmask, have_clipdist);
d813 1
a813 1
   lp_build_printf(gallivm, "   # storing end\n");
d817 1
a817 2

/**
d819 2
d824 2
a825 4
           const struct lp_type vs_type,
           LLVMValueRef io_ptr,
           LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
           boolean pre_clip_pos, int idx)
d828 7
a834 7
   LLVMValueRef soa[4];
   LLVMValueRef aos[LP_MAX_VECTOR_LENGTH];
   LLVMValueRef indices[2];
   LLVMValueRef io_ptrs[LP_MAX_VECTOR_WIDTH / 32];
   LLVMValueRef inds[LP_MAX_VECTOR_WIDTH / 32];
   LLVMValueRef clip_ptrs[LP_MAX_VECTOR_WIDTH / 32];
   int i, j;
d836 5
d843 31
d875 1
a875 3
   for (i = 0; i < vs_type.length; i++) {
      inds[i] = lp_build_const_int32(gallivm, i);
      io_ptrs[i] = LLVMBuildGEP(builder, io_ptr, &inds[i], 1, "");
d878 1
a878 14
   soa[0] = LLVMBuildLoad(builder, outputs[idx][0], ""); /*x0 x1 .. xn*/
   soa[1] = LLVMBuildLoad(builder, outputs[idx][1], ""); /*y0 y1 .. yn*/
   soa[2] = LLVMBuildLoad(builder, outputs[idx][2], ""); /*z0 z1 .. zn*/
   soa[3] = LLVMBuildLoad(builder, outputs[idx][3], ""); /*w0 w1 .. wn*/

   if (!pre_clip_pos) {
      for (i = 0; i < vs_type.length; i++) {
         clip_ptrs[i] = draw_jit_header_clip(gallivm, io_ptrs[i]);
      }
   } else {
      for (i = 0; i < vs_type.length; i++) {
         clip_ptrs[i] = draw_jit_header_pre_clip_pos(gallivm, io_ptrs[i]);
      }
   }
d880 10
a889 11
   lp_build_transpose_aos(gallivm, vs_type, soa, soa);
   for (i = 0; i < vs_type.length; ++i) {
      aos[i] = lp_build_extract_range(gallivm,
                                      soa[i % TGSI_NUM_CHANNELS],
                                      (i / TGSI_NUM_CHANNELS) * TGSI_NUM_CHANNELS,
                                      TGSI_NUM_CHANNELS);
   }

   for (j = 0; j < vs_type.length; j++) {
      LLVMTypeRef  clip_ptr_type = LLVMPointerType(LLVMVectorType(LLVMFloatTypeInContext(gallivm->context), 4), 0);
      LLVMValueRef clip_ptr;
d891 5
a895 2
      clip_ptr = LLVMBuildGEP(builder, clip_ptrs[j], indices, 2, "clipo");
      clip_ptr = LLVMBuildPointerCast(builder, clip_ptr, clip_ptr_type, "");
d897 1
a897 3
      /* Unaligned store */
      lp_set_store_alignment(LLVMBuildStore(builder, aos[j], clip_ptr), sizeof(float));
   }
d900 1
a900 2

/**
d904 1
a904 1
generate_viewport(struct draw_llvm_variant *variant,
d906 1
a906 2
                  struct lp_type vs_type,
                  LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
d910 4
a913 6
   struct gallivm_state *gallivm = variant->gallivm;
   struct lp_type f32_type = vs_type;
   const unsigned pos = draw_current_shader_position_output(variant->llvm->draw);
   LLVMTypeRef vs_type_llvm = lp_build_vec_type(gallivm, vs_type);
   LLVMValueRef out3 = LLVMBuildLoad(builder, outputs[pos][3], ""); /*w0 w1 .. wn*/
   LLVMValueRef const1 = lp_build_const_vec(gallivm, f32_type, 1.0);       /*1.0 1.0 1.0 1.0*/
d918 2
a919 2
   LLVMBuildStore(builder, out3, outputs[pos][3]);

d921 2
a922 2
   for (i=0; i<3; i++) {
      LLVMValueRef out = LLVMBuildLoad(builder, outputs[pos][i], ""); /*x0 x1 .. xn*/
d928 1
a928 1

d935 2
a936 4
      scale = lp_build_broadcast(gallivm, vs_type_llvm,
                                 LLVMBuildLoad(builder, scale_i, "scale"));
      trans = lp_build_broadcast(gallivm, vs_type_llvm,
                                 LLVMBuildLoad(builder, trans_i, "trans"));
d946 1
a946 1
      LLVMBuildStore(builder, out, outputs[pos][i]);
d948 1
a948 1

d952 2
a953 2
/**
 * Returns clipmask as nxi32 bitmask for the n vertices
d955 3
a957 5
static LLVMValueRef
generate_clipmask(struct draw_llvm *llvm,
                  struct gallivm_state *gallivm,
                  struct lp_type vs_type,
                  LLVMValueRef (*outputs)[TGSI_NUM_CHANNELS],
d962 2
a963 3
                  unsigned ucp_enable,
                  LLVMValueRef context_ptr,
                  boolean *have_clipdist)
d966 2
a967 2
   LLVMValueRef mask; /* stores the <nxi32> clipmasks */
   LLVMValueRef test, temp;
a969 1
   LLVMValueRef cv_x, cv_y, cv_z, cv_w;
a970 23
   struct lp_type f32_type = vs_type;
   struct lp_type i32_type = lp_int_type(vs_type);
   const unsigned pos = draw_current_shader_position_output(llvm->draw);
   const unsigned cv = draw_current_shader_clipvertex_output(llvm->draw);
   int num_written_clipdistance = llvm->draw->vs.vertex_shader->info.num_written_clipdistance;
   bool have_cd = false;
   unsigned cd[2];

   cd[0] = draw_current_shader_clipdistance_output(llvm->draw, 0);
   cd[1] = draw_current_shader_clipdistance_output(llvm->draw, 1);

   if (cd[0] != pos || cd[1] != pos)
      have_cd = true;

   if (num_written_clipdistance && !clip_user) {
      clip_user = true;
      ucp_enable = (1 << num_written_clipdistance) - 1;
   }

   mask = lp_build_const_int_vec(gallivm, i32_type, 0);
   temp = lp_build_const_int_vec(gallivm, i32_type, 0);
   zero = lp_build_const_vec(gallivm, f32_type, 0);         /* 0.0f 0.0f 0.0f 0.0f */
   shift = lp_build_const_int_vec(gallivm, i32_type, 1);    /* 1 1 1 1 */
d972 14
a985 20
   /*
    * load clipvertex and position from correct locations.
    * if they are the same just load them once.
    */
   pos_x = LLVMBuildLoad(builder, outputs[pos][0], ""); /*x0 x1 .. xn */
   pos_y = LLVMBuildLoad(builder, outputs[pos][1], ""); /*y0 y1 .. yn */
   pos_z = LLVMBuildLoad(builder, outputs[pos][2], ""); /*z0 z1 .. zn */
   pos_w = LLVMBuildLoad(builder, outputs[pos][3], ""); /*w0 w1 .. wn */

   if (clip_user && cv != pos) {
      cv_x = LLVMBuildLoad(builder, outputs[cv][0], ""); /*x0 x1 .. xn */
      cv_y = LLVMBuildLoad(builder, outputs[cv][1], ""); /*y0 y1 .. yn */
      cv_z = LLVMBuildLoad(builder, outputs[cv][2], ""); /*z0 z1 .. zn */
      cv_w = LLVMBuildLoad(builder, outputs[cv][3], ""); /*w0 w1 .. wn */
   } else {
      cv_x = pos_x;
      cv_y = pos_y;
      cv_z = pos_z;
      cv_w = pos_w;
   }
d988 1
a988 1
   if (clip_xy) {
d992 1
a992 1
      test = LLVMBuildAnd(builder, test, temp, "");
d994 1
a994 1

d999 1
a999 1
      test = LLVMBuildAnd(builder, test, temp, "");
d1001 1
a1001 1

d1005 1
a1005 1
      test = LLVMBuildAnd(builder, test, temp, "");
d1012 1
a1012 1
      test = LLVMBuildAnd(builder, test, temp, "");
d1016 3
a1018 3
   if (clip_z) {
      temp = lp_build_const_int_vec(gallivm, i32_type, 16);
      if (clip_halfz) {
d1021 1
a1021 1
         test = LLVMBuildAnd(builder, test, temp, "");
d1023 2
a1024 2
      }
      else {
d1028 1
a1028 1
         test = LLVMBuildAnd(builder, test, temp, "");
d1034 1
a1034 1
      test = LLVMBuildAnd(builder, test, temp, "");
d1036 1
a1036 1
   }
d1038 1
a1038 1
   if (clip_user) {
d1041 1
d1044 35
a1078 57
      while (ucp_enable) {
         unsigned plane_idx = ffs(ucp_enable)-1;
         ucp_enable &= ~(1 << plane_idx);
         plane_idx += 6;

         if (have_cd && num_written_clipdistance) {
            LLVMValueRef clipdist;
            int i;
            i = plane_idx - 6;

            *have_clipdist = TRUE;
            if (i < 4) {
               clipdist = LLVMBuildLoad(builder, outputs[cd[0]][i], "");
            } else {
               clipdist = LLVMBuildLoad(builder, outputs[cd[1]][i-4], "");
            }
            test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, clipdist);
            temp = lp_build_const_int_vec(gallivm, i32_type, 1 << plane_idx);
            test = LLVMBuildAnd(builder, test, temp, "");
            mask = LLVMBuildOr(builder, mask, test, "");
         } else {
            LLVMTypeRef vs_type_llvm = lp_build_vec_type(gallivm, vs_type);
            indices[0] = lp_build_const_int32(gallivm, 0);
            indices[1] = lp_build_const_int32(gallivm, plane_idx);

            indices[2] = lp_build_const_int32(gallivm, 0);
            plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
            plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_x");
            planes = lp_build_broadcast(gallivm, vs_type_llvm, plane1);
            sum = LLVMBuildFMul(builder, planes, cv_x, "");

            indices[2] = lp_build_const_int32(gallivm, 1);
            plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
            plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_y");
            planes = lp_build_broadcast(gallivm, vs_type_llvm, plane1);
            test = LLVMBuildFMul(builder, planes, cv_y, "");
            sum = LLVMBuildFAdd(builder, sum, test, "");

            indices[2] = lp_build_const_int32(gallivm, 2);
            plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
            plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_z");
            planes = lp_build_broadcast(gallivm, vs_type_llvm, plane1);
            test = LLVMBuildFMul(builder, planes, cv_z, "");
            sum = LLVMBuildFAdd(builder, sum, test, "");

            indices[2] = lp_build_const_int32(gallivm, 3);
            plane_ptr = LLVMBuildGEP(builder, planes_ptr, indices, 3, "");
            plane1 = LLVMBuildLoad(builder, plane_ptr, "plane_w");
            planes = lp_build_broadcast(gallivm, vs_type_llvm, plane1);
            test = LLVMBuildFMul(builder, planes, cv_w, "");
            sum = LLVMBuildFAdd(builder, sum, test, "");

            test = lp_build_compare(gallivm, f32_type, PIPE_FUNC_GREATER, zero, sum);
            temp = lp_build_const_int_vec(gallivm, i32_type, 1 << plane_idx);
            test = LLVMBuildAnd(builder, test, temp, "");
            mask = LLVMBuildOr(builder, mask, test, "");
         }
d1084 1
a1084 2

/**
d1086 1
a1086 1
 * Used zero/non-zero i32 value to represent boolean
d1088 4
a1091 4
static LLVMValueRef
clipmask_booli32(struct gallivm_state *gallivm,
                 const struct lp_type vs_type,
                 LLVMValueRef clipmask_bool_ptr)
d1094 1
a1094 3
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMValueRef clipmask_bool = LLVMBuildLoad(builder, clipmask_bool_ptr, "");
   LLVMValueRef ret = LLVMConstNull(int32_type);
d1098 2
a1099 6
   /*
    * Can do this with log2(vector length) pack instructions and one extract
    * (as we don't actually need a or) with sse2 which would be way better.
    */
   for (i=0; i < vs_type.length; i++) {
      temp = LLVMBuildExtractElement(builder, clipmask_bool,
d1103 2
a1104 1
   return ret;
d1107 2
a1108 7
static LLVMValueRef
draw_gs_llvm_fetch_input(const struct lp_build_tgsi_gs_iface *gs_iface,
                         struct lp_build_tgsi_context * bld_base,
                         boolean is_indirect,
                         LLVMValueRef vertex_index,
                         LLVMValueRef attrib_index,
                         LLVMValueRef swizzle_index)
d1110 33
a1142 6
   const struct draw_gs_llvm_iface *gs = draw_gs_llvm_iface(gs_iface);
   struct gallivm_state *gallivm = bld_base->base.gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef indices[3];
   LLVMValueRef res;
   struct lp_type type = bld_base->base.type;
d1144 97
a1240 15
   if (is_indirect) {
      int i;
      res = bld_base->base.zero;
      for (i = 0; i < type.length; ++i) {
         LLVMValueRef idx = lp_build_const_int32(gallivm, i);
         LLVMValueRef vert_chan_index = LLVMBuildExtractElement(builder,
                                                                vertex_index, idx, "");
         LLVMValueRef channel_vec, value;
         indices[0] = vert_chan_index;
         indices[1] = attrib_index;
         indices[2] = swizzle_index;
         
         channel_vec = LLVMBuildGEP(builder, gs->input, indices, 3, "");
         channel_vec = LLVMBuildLoad(builder, channel_vec, "");
         value = LLVMBuildExtractElement(builder, channel_vec, idx, "");
d1242 20
a1261 1
         res = LLVMBuildInsertElement(builder, res, value, idx, "");
a1262 4
   } else {
      indices[0] = vertex_index;
      indices[1] = attrib_index;
      indices[2] = swizzle_index;
d1264 4
a1267 2
      res = LLVMBuildGEP(builder, gs->input, indices, 3, "");
      res = LLVMBuildLoad(builder, res, "");
d1270 1
a1270 2
   return res;
}
d1272 1
a1272 19
static void
draw_gs_llvm_emit_vertex(const struct lp_build_tgsi_gs_iface *gs_base,
                         struct lp_build_tgsi_context * bld_base,
                         LLVMValueRef (*outputs)[4],
                         LLVMValueRef emitted_vertices_vec)
{
   const struct draw_gs_llvm_iface *gs_iface = draw_gs_llvm_iface(gs_base);
   struct draw_gs_llvm_variant *variant = gs_iface->variant;
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type gs_type = bld_base->base.type;
   LLVMValueRef clipmask = lp_build_const_int_vec(gallivm,
                                                  lp_int_type(gs_type), 0);
   LLVMValueRef indices[LP_MAX_VECTOR_LENGTH];
   LLVMValueRef next_prim_offset =
      lp_build_const_int32(gallivm, variant->shader->base.primitive_boundary);
   LLVMValueRef io = variant->io_ptr;
   unsigned i;
   const struct tgsi_shader_info *gs_info = &variant->shader->base.info;
d1274 10
a1283 6
   for (i = 0; i < gs_type.length; ++i) {
      LLVMValueRef ind = lp_build_const_int32(gallivm, i);
      LLVMValueRef currently_emitted =
         LLVMBuildExtractElement(builder, emitted_vertices_vec, ind, "");
      indices[i] = LLVMBuildMul(builder, ind, next_prim_offset, "");
      indices[i] = LLVMBuildAdd(builder, indices[i], currently_emitted, "");
d1285 3
d1289 4
a1292 5
   convert_to_aos(gallivm, io, indices,
                  outputs, clipmask,
                  gs_info->num_outputs, gs_type,
                  FALSE);
}
d1294 2
a1295 13
static void
draw_gs_llvm_end_primitive(const struct lp_build_tgsi_gs_iface *gs_base,
                           struct lp_build_tgsi_context * bld_base,
                           LLVMValueRef verts_per_prim_vec,
                           LLVMValueRef emitted_prims_vec)
{
   const struct draw_gs_llvm_iface *gs_iface = draw_gs_llvm_iface(gs_base);
   struct draw_gs_llvm_variant *variant = gs_iface->variant;
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef prim_lengts_ptr =
      draw_gs_jit_prim_lengths(variant->gallivm, variant->context_ptr);
   unsigned i;
d1297 2
a1298 12
   for (i = 0; i < bld_base->base.type.length; ++i) {
      LLVMValueRef ind = lp_build_const_int32(gallivm, i);
      LLVMValueRef prims_emitted =
         LLVMBuildExtractElement(builder, emitted_prims_vec, ind, "");
      LLVMValueRef store_ptr;
      LLVMValueRef num_vertices =
         LLVMBuildExtractElement(builder, verts_per_prim_vec, ind, "");

      store_ptr = LLVMBuildGEP(builder, prim_lengts_ptr, &prims_emitted, 1, "");
      store_ptr = LLVMBuildLoad(builder, store_ptr, "");
      store_ptr = LLVMBuildGEP(builder, store_ptr, &ind, 1, "");
      LLVMBuildStore(builder, num_vertices, store_ptr);
d1300 1
a1302 22
static void
draw_gs_llvm_epilogue(const struct lp_build_tgsi_gs_iface *gs_base,
                      struct lp_build_tgsi_context * bld_base,
                      LLVMValueRef total_emitted_vertices_vec,
                      LLVMValueRef emitted_prims_vec)
{
   const struct draw_gs_llvm_iface *gs_iface = draw_gs_llvm_iface(gs_base);
   struct draw_gs_llvm_variant *variant = gs_iface->variant;
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef emitted_verts_ptr =
      draw_gs_jit_emitted_vertices(gallivm, variant->context_ptr);
   LLVMValueRef emitted_prims_ptr =
      draw_gs_jit_emitted_prims(gallivm, variant->context_ptr);
   LLVMValueRef zero = lp_build_const_int32(gallivm, 0);
   
   emitted_verts_ptr = LLVMBuildGEP(builder, emitted_verts_ptr, &zero, 0, "");
   emitted_prims_ptr = LLVMBuildGEP(builder, emitted_prims_ptr, &zero, 0, "");

   LLVMBuildStore(builder, total_emitted_vertices_vec, emitted_verts_ptr);
   LLVMBuildStore(builder, emitted_prims_vec, emitted_prims_ptr);
}
d1305 1
a1305 2
draw_llvm_generate(struct draw_llvm *llvm, struct draw_llvm_variant *variant,
                   boolean elts)
d1307 1
a1307 1
   struct gallivm_state *gallivm = variant->gallivm;
d1310 1
a1310 3
   LLVMTypeRef arg_types[9];
   unsigned num_arg_types =
      elts ? Elements(arg_types) : Elements(arg_types) - 1;
d1315 1
a1315 4
   struct lp_type vs_type;
   LLVMValueRef end, start;
   LLVMValueRef count, fetch_elts, fetch_elt_max, fetch_count;
   LLVMValueRef stride, step, io_itr;
d1317 1
a1317 2
   LLVMValueRef zero = lp_build_const_int32(gallivm, 0);
   LLVMValueRef one = lp_build_const_int32(gallivm, 1);
a1318 1
   const struct tgsi_shader_info *vs_info = &draw->vs.vertex_shader->info;
d1322 2
a1323 2
   const int vector_length = lp_native_vector_width / 32;
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][TGSI_NUM_CHANNELS];
d1325 1
d1327 22
a1348 48
   LLVMValueRef ret, clipmask_bool_ptr;
   const struct draw_geometry_shader *gs = draw->gs.geometry_shader;
   struct draw_llvm_variant_key *key = &variant->key;
   /* If geometry shader is present we need to skip both the viewport
    * transformation and clipping otherwise the inputs to the geometry
    * shader will be incorrect.
    */
   const boolean bypass_viewport = gs || key->bypass_viewport;
   const boolean enable_cliptest = !gs && (key->clip_xy ||
                                           key->clip_z  ||
                                           key->clip_user);
   LLVMValueRef variant_func;
   const unsigned pos = draw_current_shader_position_output(llvm->draw);
   const unsigned cv = draw_current_shader_clipvertex_output(llvm->draw);
   boolean have_clipdist = FALSE;
   struct lp_bld_tgsi_system_values system_values;

   memset(&system_values, 0, sizeof(system_values));

   i = 0;
   arg_types[i++] = get_context_ptr_type(variant);       /* context */
   arg_types[i++] = get_vertex_header_ptr_type(variant); /* vertex_header */
   arg_types[i++] = get_buffer_ptr_type(variant);        /* vbuffers */
   if (elts) {
      arg_types[i++] = LLVMPointerType(int32_type, 0);/* fetch_elts  */
      arg_types[i++] = int32_type;                  /* fetch_elt_max */
   } else
      arg_types[i++] = int32_type;                  /* start */
   arg_types[i++] = int32_type;                     /* fetch_count / count */
   arg_types[i++] = int32_type;                     /* stride */
   arg_types[i++] = get_vb_ptr_type(variant);       /* pipe_vertex_buffer's */
   arg_types[i++] = int32_type;                     /* instance_id */

   func_type = LLVMFunctionType(int32_type, arg_types, num_arg_types, 0);

   variant_func = LLVMAddFunction(gallivm->module,
                                  elts ? "draw_llvm_shader_elts" : "draw_llvm_shader",
                                  func_type);

   if (elts)
      variant->function_elts = variant_func;
   else
      variant->function = variant_func;

   LLVMSetFunctionCallConv(variant_func, LLVMCCallConv);
   for (i = 0; i < num_arg_types; ++i)
      if (LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
         LLVMAddAttribute(LLVMGetParam(variant_func, i),
d1351 8
a1358 6
   context_ptr               = LLVMGetParam(variant_func, 0);
   io_ptr                    = LLVMGetParam(variant_func, 1);
   vbuffers_ptr              = LLVMGetParam(variant_func, 2);
   stride                    = LLVMGetParam(variant_func, 5 + (elts ? 1 : 0));
   vb_ptr                    = LLVMGetParam(variant_func, 6 + (elts ? 1 : 0));
   system_values.instance_id = LLVMGetParam(variant_func, 7 + (elts ? 1 : 0));
d1363 2
d1367 1
a1367 18
   lp_build_name(system_values.instance_id, "instance_id");

   if (elts) {
      fetch_elts    = LLVMGetParam(variant_func, 3);
      fetch_elt_max = LLVMGetParam(variant_func, 4);
      fetch_count   = LLVMGetParam(variant_func, 5);
      lp_build_name(fetch_elts, "fetch_elts");
      lp_build_name(fetch_elt_max, "fetch_elt_max");
      lp_build_name(fetch_count, "fetch_count");
      start = count = NULL;
   }
   else {
      start        = LLVMGetParam(variant_func, 3);
      count        = LLVMGetParam(variant_func, 4);
      lp_build_name(start, "start");
      lp_build_name(count, "count");
      fetch_elts = fetch_count = NULL;
   }
d1373 1
a1373 1
   block = LLVMAppendBasicBlockInContext(gallivm->context, variant_func, "entry");
d1379 1
a1379 10
   memset(&vs_type, 0, sizeof vs_type);
   vs_type.floating = TRUE; /* floating point values */
   vs_type.sign = TRUE;     /* values are signed */
   vs_type.norm = FALSE;    /* values are not limited to [0,1] or [-1,1] */
   vs_type.width = 32;      /* 32-bit float */
   vs_type.length = vector_length;

   /* hold temporary "bool" clipmask */
   clipmask_bool_ptr = lp_build_alloca(gallivm, lp_build_int_vec_type(gallivm, vs_type), "");
   LLVMBuildStore(builder, lp_build_zero(gallivm, lp_int_type(vs_type)), clipmask_bool_ptr);
d1383 1
a1383 1
      draw_llvm_variant_key_samplers(key),
d1386 7
a1392 8
   if (elts) {
      start = zero;
      end = fetch_count;
      count = fetch_count;
   }
   else {
      end = lp_build_add(&bld, start, count);
   }
d1394 1
a1394 5
   step = lp_build_const_int32(gallivm, vector_length);

   fetch_max = LLVMBuildSub(builder, end, one, "fetch_max");

   lp_build_loop_begin(&lp_loop, gallivm, zero);
d1396 2
a1397 2
      LLVMValueRef inputs[PIPE_MAX_SHADER_INPUTS][TGSI_NUM_CHANNELS];
      LLVMValueRef aos_attribs[PIPE_MAX_SHADER_INPUTS][LP_MAX_VECTOR_WIDTH / 32] = { { 0 } };
d1400 1
a1400 1
      const LLVMValueRef (*ptr_aos)[TGSI_NUM_CHANNELS];
a1402 1

d1405 1
a1405 1
      lp_build_printf(gallivm, " --- io %d = %p, loop counter %d\n",
d1408 6
a1413 7
      system_values.vertex_id = lp_build_zero(gallivm, lp_type_uint_vec(32, 32*vector_length));
      for (i = 0; i < vector_length; ++i) {
         LLVMValueRef true_index =
            LLVMBuildAdd(builder,
                         lp_loop.counter,
                         lp_build_const_int32(gallivm, i), "");
         true_index = LLVMBuildAdd(builder, start, true_index, "");
d1420 3
a1422 42
         system_values.vertex_id = LLVMBuildInsertElement(
            gallivm->builder,
            system_values.vertex_id, true_index,
            lp_build_const_int32(gallivm, i), "");

         if (elts) {
            LLVMValueRef fetch_ptr;
            LLVMValueRef index_overflowed;
            LLVMValueRef index_ptr =
               lp_build_alloca(
                  gallivm,
                  lp_build_vec_type(gallivm, lp_type_int(32)), "");
            struct lp_build_if_state if_ctx;
            index_overflowed = LLVMBuildICmp(builder, LLVMIntUGT,
                                             true_index, fetch_elt_max,
                                             "index_overflowed");
            
            lp_build_if(&if_ctx, gallivm, index_overflowed);
            {
               /* Generate maximum possible index so that
                * generate_fetch can treat it just like
                * any other overflow and return zeros.
                * We don't have to worry about the restart
                * primitive index because it has already been 
                * handled
                */
               LLVMValueRef val =
                  lp_build_const_int32(gallivm, 0xffffffff);
               LLVMBuildStore(builder, val, index_ptr);
            }
            lp_build_else(&if_ctx);
            {
               LLVMValueRef val;
               fetch_ptr = LLVMBuildGEP(builder, fetch_elts,
                                        &true_index, 1, "");
               val = LLVMBuildLoad(builder, fetch_ptr, "");
               LLVMBuildStore(builder, val, index_ptr);
            }
            lp_build_endif(&if_ctx);
            true_index = LLVMBuildLoad(builder, index_ptr, "true_index");
         }

d1425 4
a1428 4
            LLVMValueRef vb_index =
               lp_build_const_int32(gallivm, velem->vertex_buffer_index);
            LLVMValueRef vb = LLVMBuildGEP(builder, vb_ptr, &vb_index, 1, "");
            generate_fetch(gallivm, draw, vbuffers_ptr,
d1430 1
a1430 1
                           system_values.instance_id);
d1434 1
a1434 1
                     draw->pt.nr_vertex_elements, vs_type);
d1436 2
a1437 2
      ptr_aos = (const LLVMValueRef (*)[TGSI_NUM_CHANNELS]) inputs;
      generate_vs(variant,
a1438 1
                  vs_type,
a1440 1
                  &system_values,
d1442 1
a1442 2
                  sampler,
                  key->clamp_vertex_color);
d1444 2
a1445 26
      if (pos != -1 && cv != -1) {
         /* store original positions in clip before further manipulation */
         store_clip(gallivm, vs_type, io, outputs, 0, cv);
         store_clip(gallivm, vs_type, io, outputs, 1, pos);

         /* do cliptest */
         if (enable_cliptest) {
            LLVMValueRef temp = LLVMBuildLoad(builder, clipmask_bool_ptr, "");
            /* allocate clipmask, assign it integer type */
            clipmask = generate_clipmask(llvm,
                                         gallivm,
                                         vs_type,
                                         outputs,
                                         key->clip_xy,
                                         key->clip_z,
                                         key->clip_user,
                                         key->clip_halfz,
                                         key->ucp_enable,
                                         context_ptr, &have_clipdist);
            temp = LLVMBuildOr(builder, clipmask, temp, "");
            /* store temporary clipping boolean value */
            LLVMBuildStore(builder, temp, clipmask_bool_ptr);
         }
         else {
            clipmask = lp_build_const_int_vec(gallivm, lp_int_type(vs_type), 0);
         }
d1447 15
a1461 4
         /* do viewport mapping */
         if (!bypass_viewport) {
            generate_viewport(variant, builder, vs_type, outputs, context_ptr);
         }
d1463 4
a1466 2
      else {
         clipmask = lp_build_const_int_vec(gallivm, lp_int_type(vs_type), 0);
d1469 7
a1475 7
      /* store clipmask in vertex header,
       * original positions in clip
       * and transformed positions in data
       */
      convert_to_aos(gallivm, io, NULL, outputs, clipmask,
                     vs_info->num_outputs, vs_type,
                     have_clipdist);
d1477 2
a1478 1
   lp_build_loop_end_cond(&lp_loop, count, step, LLVMIntUGE);
d1482 12
a1493 2
   /* return clipping boolean value for function */
   ret = clipmask_booli32(gallivm, vs_type, clipmask_bool_ptr);
d1495 9
a1503 1
   LLVMBuildRet(builder, ret);
d1505 4
a1508 1
   gallivm_verify_function(gallivm, variant_func);
d1517 1
a1517 1
   struct draw_sampler_static_state *draw_sampler;
a1520 2
   key->clamp_vertex_color = llvm->draw->rasterizer->clamp_vertex_color; /**/

a1522 3
    * NOTE: we NEED to store the needed number of needed inputs
    * here, not the number of provided elements to match keysize
    * (and the offset of sampler state in the key).
d1524 1
a1524 2
   key->nr_vertex_elements = llvm->draw->vs.vertex_shader->info.file_max[TGSI_FILE_INPUT] + 1;
   assert(key->nr_vertex_elements <= llvm->draw->pt.nr_vertex_elements);
d1531 1
a1531 1
   key->clip_halfz = llvm->draw->rasterizer->clip_halfz;
d1533 2
a1534 3
   key->ucp_enable = llvm->draw->rasterizer->clip_plane_enable;
   key->has_gs = llvm->draw->gs.geometry_shader != NULL;
   key->pad1 = 0;
a1540 7
   if (llvm->draw->vs.vertex_shader->info.file_max[TGSI_FILE_SAMPLER_VIEW] != -1) {
      key->nr_sampler_views =
         llvm->draw->vs.vertex_shader->info.file_max[TGSI_FILE_SAMPLER_VIEW] + 1;
   }
   else {
      key->nr_sampler_views = key->nr_samplers;
   }
d1542 1
a1542 1
   draw_sampler = draw_llvm_variant_key_samplers(key);
d1547 2
a1548 2

   memset(draw_sampler, 0, MAX2(key->nr_samplers, key->nr_sampler_views) * sizeof *draw_sampler);
d1551 3
a1553 6
      lp_sampler_static_sampler_state(&draw_sampler[i].sampler_state,
                                      llvm->draw->samplers[PIPE_SHADER_VERTEX][i]);
   }
   for (i = 0 ; i < key->nr_sampler_views; i++) {
      lp_sampler_static_texture_state(&draw_sampler[i].texture_state,
                                      llvm->draw->sampler_views[PIPE_SHADER_VERTEX][i]);
a1558 30

void
draw_llvm_dump_variant_key(struct draw_llvm_variant_key *key)
{
   unsigned i;
   struct draw_sampler_static_state *sampler = draw_llvm_variant_key_samplers(key);

   debug_printf("clamp_vertex_color = %u\n", key->clamp_vertex_color);
   debug_printf("clip_xy = %u\n", key->clip_xy);
   debug_printf("clip_z = %u\n", key->clip_z);
   debug_printf("clip_user = %u\n", key->clip_user);
   debug_printf("bypass_viewport = %u\n", key->bypass_viewport);
   debug_printf("clip_halfz = %u\n", key->clip_halfz);
   debug_printf("need_edgeflags = %u\n", key->need_edgeflags);
   debug_printf("has_gs = %u\n", key->has_gs);
   debug_printf("ucp_enable = %u\n", key->ucp_enable);

   for (i = 0 ; i < key->nr_vertex_elements; i++) {
      debug_printf("vertex_element[%i].src_offset = %u\n", i, key->vertex_element[i].src_offset);
      debug_printf("vertex_element[%i].instance_divisor = %u\n", i, key->vertex_element[i].instance_divisor);
      debug_printf("vertex_element[%i].vertex_buffer_index = %u\n", i, key->vertex_element[i].vertex_buffer_index);
      debug_printf("vertex_element[%i].src_format = %s\n", i, util_format_name(key->vertex_element[i].src_format));
   }

   for (i = 0 ; i < key->nr_sampler_views; i++) {
      debug_printf("sampler[%i].src_format = %s\n", i, util_format_name(sampler[i].texture_state.format));
   }
}


d1561 1
a1561 2
                             unsigned shader_stage,
                             unsigned sview_idx,
d1563 1
a1563 2
                             uint32_t first_level, uint32_t last_level,
                             const void *base_ptr,
d1566 1
a1566 1
                             uint32_t mip_offsets[PIPE_MAX_TEXTURE_LEVELS])
d1571 1
a1571 2
   assert(shader_stage == PIPE_SHADER_VERTEX ||
          shader_stage == PIPE_SHADER_GEOMETRY);
a1572 2
   if (shader_stage == PIPE_SHADER_VERTEX) {
      assert(sview_idx < Elements(draw->llvm->jit_context.textures));
d1574 1
a1574 9
      jit_tex = &draw->llvm->jit_context.textures[sview_idx];
   } else if (shader_stage == PIPE_SHADER_GEOMETRY) {
      assert(sview_idx < Elements(draw->llvm->gs_jit_context.textures));

      jit_tex = &draw->llvm->gs_jit_context.textures[sview_idx];
   } else {
      assert(0);
      return;
   }
a1578 1
   jit_tex->first_level = first_level;
a1579 1
   jit_tex->base = base_ptr;
d1581 2
a1582 2
   for (j = first_level; j <= last_level; j++) {
      jit_tex->mip_offsets[j] = mip_offsets[j];
d1590 1
a1590 2
draw_llvm_set_sampler_state(struct draw_context *draw, 
                            unsigned shader_type)
d1594 8
a1601 25
   if (shader_type == PIPE_SHADER_VERTEX) {
      for (i = 0; i < draw->num_samplers[PIPE_SHADER_VERTEX]; i++) {
         struct draw_jit_sampler *jit_sam = &draw->llvm->jit_context.samplers[i];

         if (draw->samplers[i]) {
            const struct pipe_sampler_state *s
               = draw->samplers[PIPE_SHADER_VERTEX][i];
            jit_sam->min_lod = s->min_lod;
            jit_sam->max_lod = s->max_lod;
            jit_sam->lod_bias = s->lod_bias;
            COPY_4V(jit_sam->border_color, s->border_color.f);
         }
      }
   } else if (shader_type == PIPE_SHADER_GEOMETRY) {
      for (i = 0; i < draw->num_samplers[PIPE_SHADER_GEOMETRY]; i++) {
         struct draw_jit_sampler *jit_sam = &draw->llvm->gs_jit_context.samplers[i];

         if (draw->samplers[i]) {
            const struct pipe_sampler_state *s
               = draw->samplers[PIPE_SHADER_GEOMETRY][i];
            jit_sam->min_lod = s->min_lod;
            jit_sam->max_lod = s->max_lod;
            jit_sam->lod_bias = s->lod_bias;
            COPY_4V(jit_sam->border_color, s->border_color.f);
         }
d1613 4
a1616 2
      gallivm_free_function(variant->gallivm,
                            variant->function_elts, variant->jit_func_elts);
d1620 4
a1623 2
      gallivm_free_function(variant->gallivm,
                            variant->function, variant->jit_func);
a1625 2
   gallivm_destroy(variant->gallivm);

a1630 308
}


/**
 * Create LLVM types for various structures.
 */
static void
create_gs_jit_types(struct draw_gs_llvm_variant *var)
{
   struct gallivm_state *gallivm = var->gallivm;
   LLVMTypeRef texture_type, sampler_type, context_type;

   texture_type = create_jit_texture_type(gallivm, "texture");
   sampler_type = create_jit_sampler_type(gallivm, "sampler");

   context_type = create_gs_jit_context_type(gallivm,
                                             var->shader->base.vector_length,
                                             texture_type, sampler_type,
                                             "draw_gs_jit_context");
   var->context_ptr_type = LLVMPointerType(context_type, 0);

   var->input_array_type = create_gs_jit_input_type(gallivm);
}

static LLVMTypeRef
get_gs_context_ptr_type(struct draw_gs_llvm_variant *variant)
{
   if (!variant->context_ptr_type)
      create_gs_jit_types(variant);
   return variant->context_ptr_type;
}

static LLVMValueRef
generate_mask_value(struct draw_gs_llvm_variant *variant,
                    struct lp_type gs_type)
{
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef bits[16];
   struct lp_type  mask_type = lp_int_type(gs_type);
   struct lp_type mask_elem_type = lp_elem_type(mask_type);
   LLVMValueRef mask_val = lp_build_const_vec(gallivm,
                                              mask_type,
                                              0);
   unsigned i;

   assert(gs_type.length <= Elements(bits));

   for (i = gs_type.length; i >= 1; --i) {
      int idx = i - 1;
      LLVMValueRef ind = lp_build_const_int32(gallivm, i);
      bits[idx] = lp_build_compare(gallivm,
                                   mask_elem_type, PIPE_FUNC_GEQUAL,
                                   variant->num_prims, ind);
   }
   for (i = 0; i < gs_type.length; ++i) {
      LLVMValueRef ind = lp_build_const_int32(gallivm, i);
      mask_val = LLVMBuildInsertElement(builder, mask_val, bits[i], ind, "");
   }
   mask_val = lp_build_compare(gallivm,
                               mask_type, PIPE_FUNC_NOTEQUAL,
                               mask_val,
                               lp_build_const_int_vec(gallivm, mask_type, 0));

   return mask_val;
}

static void
draw_gs_llvm_generate(struct draw_llvm *llvm,
                      struct draw_gs_llvm_variant *variant)
{
   struct gallivm_state *gallivm = variant->gallivm;
   LLVMContextRef context = gallivm->context;
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(context);
   LLVMTypeRef arg_types[6];
   LLVMTypeRef func_type;
   LLVMValueRef variant_func;
   LLVMValueRef context_ptr;
   LLVMValueRef prim_id_ptr;
   LLVMBasicBlockRef block;
   LLVMBuilderRef builder;
   LLVMValueRef io_ptr, input_array, num_prims, mask_val;
   struct lp_build_sampler_soa *sampler = 0;
   struct lp_build_context bld;
   struct lp_bld_tgsi_system_values system_values;
   struct lp_type gs_type;
   unsigned i;
   struct draw_gs_llvm_iface gs_iface;
   const struct tgsi_token *tokens = variant->shader->base.state.tokens;
   LLVMValueRef consts_ptr;
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][TGSI_NUM_CHANNELS];
   struct lp_build_mask_context mask;
   const struct tgsi_shader_info *gs_info = &variant->shader->base.info;
   unsigned vector_length = variant->shader->base.vector_length;

   memset(&system_values, 0, sizeof(system_values));

   assert(variant->vertex_header_ptr_type);

   arg_types[0] = get_gs_context_ptr_type(variant);    /* context */
   arg_types[1] = variant->input_array_type;           /* input */
   arg_types[2] = variant->vertex_header_ptr_type;     /* vertex_header */
   arg_types[3] = int32_type;                          /* num_prims */
   arg_types[4] = int32_type;                          /* instance_id */
   arg_types[5] = LLVMPointerType(
      LLVMVectorType(int32_type, vector_length), 0);   /* prim_id_ptr */

   func_type = LLVMFunctionType(int32_type, arg_types, Elements(arg_types), 0);

   variant_func = LLVMAddFunction(gallivm->module, "draw_geometry_shader",
                                  func_type);
   variant->function = variant_func;

   LLVMSetFunctionCallConv(variant_func, LLVMCCallConv);

   for (i = 0; i < Elements(arg_types); ++i)
      if (LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
         LLVMAddAttribute(LLVMGetParam(variant_func, i),
                          LLVMNoAliasAttribute);

   context_ptr               = LLVMGetParam(variant_func, 0);
   input_array               = LLVMGetParam(variant_func, 1);
   io_ptr                    = LLVMGetParam(variant_func, 2);
   num_prims                 = LLVMGetParam(variant_func, 3);
   system_values.instance_id = LLVMGetParam(variant_func, 4);
   prim_id_ptr               = LLVMGetParam(variant_func, 5);

   lp_build_name(context_ptr, "context");
   lp_build_name(input_array, "input");
   lp_build_name(io_ptr, "io");
   lp_build_name(num_prims, "num_prims");
   lp_build_name(system_values.instance_id, "instance_id");
   lp_build_name(prim_id_ptr, "prim_id_ptr");

   variant->context_ptr = context_ptr;
   variant->io_ptr = io_ptr;
   variant->num_prims = num_prims;

   gs_iface.base.fetch_input = draw_gs_llvm_fetch_input;
   gs_iface.base.emit_vertex = draw_gs_llvm_emit_vertex;
   gs_iface.base.end_primitive = draw_gs_llvm_end_primitive;
   gs_iface.base.gs_epilogue = draw_gs_llvm_epilogue;
   gs_iface.input = input_array;
   gs_iface.variant = variant;

   /*
    * Function body
    */

   block = LLVMAppendBasicBlockInContext(gallivm->context, variant_func, "entry");
   builder = gallivm->builder;
   LLVMPositionBuilderAtEnd(builder, block);

   lp_build_context_init(&bld, gallivm, lp_type_int(32));

   memset(&gs_type, 0, sizeof gs_type);
   gs_type.floating = TRUE; /* floating point values */
   gs_type.sign = TRUE;     /* values are signed */
   gs_type.norm = FALSE;    /* values are not limited to [0,1] or [-1,1] */
   gs_type.width = 32;      /* 32-bit float */
   gs_type.length = vector_length;

   consts_ptr = draw_gs_jit_context_constants(variant->gallivm, context_ptr);

   /* code generated texture sampling */
   sampler = draw_llvm_sampler_soa_create(variant->key.samplers,
                                          context_ptr);

   mask_val = generate_mask_value(variant, gs_type);
   lp_build_mask_begin(&mask, gallivm, gs_type, mask_val);

   if (gs_info->uses_primid) {
      system_values.prim_id = LLVMBuildLoad(builder, prim_id_ptr, "prim_id");;
   }

   lp_build_tgsi_soa(variant->gallivm,
                     tokens,
                     gs_type,
                     &mask,
                     consts_ptr,
                     &system_values,
                     NULL,
                     outputs,
                     sampler,
                     &llvm->draw->gs.geometry_shader->info,
                     (const struct lp_build_tgsi_gs_iface *)&gs_iface);

   sampler->destroy(sampler);

   lp_build_mask_end(&mask);

   LLVMBuildRet(builder, lp_build_zero(gallivm, lp_type_uint(32)));

   gallivm_verify_function(gallivm, variant_func);
}


struct draw_gs_llvm_variant *
draw_gs_llvm_create_variant(struct draw_llvm *llvm,
                            unsigned num_outputs,
                            const struct draw_gs_llvm_variant_key *key)
{
   struct draw_gs_llvm_variant *variant;
   struct llvm_geometry_shader *shader =
      llvm_geometry_shader(llvm->draw->gs.geometry_shader);
   LLVMTypeRef vertex_header;

   variant = MALLOC(sizeof *variant +
                    shader->variant_key_size -
                    sizeof variant->key);
   if (variant == NULL)
      return NULL;

   variant->llvm = llvm;
   variant->shader = shader;

   variant->gallivm = gallivm_create();

   create_gs_jit_types(variant);

   memcpy(&variant->key, key, shader->variant_key_size);

   vertex_header = create_jit_vertex_header(variant->gallivm, num_outputs);

   variant->vertex_header_ptr_type = LLVMPointerType(vertex_header, 0);

   draw_gs_llvm_generate(llvm, variant);

   gallivm_compile_module(variant->gallivm);

   variant->jit_func = (draw_gs_jit_func)
         gallivm_jit_function(variant->gallivm, variant->function);

   variant->list_item_global.base = variant;
   variant->list_item_local.base = variant;
   /*variant->no = */shader->variants_created++;
   variant->list_item_global.base = variant;

   return variant;
}

void
draw_gs_llvm_destroy_variant(struct draw_gs_llvm_variant *variant)
{
   struct draw_llvm *llvm = variant->llvm;

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function, variant->jit_func);
   }

   gallivm_destroy(variant->gallivm);

   remove_from_list(&variant->list_item_local);
   variant->shader->variants_cached--;
   remove_from_list(&variant->list_item_global);
   llvm->nr_gs_variants--;
   FREE(variant);
}

struct draw_gs_llvm_variant_key *
draw_gs_llvm_make_variant_key(struct draw_llvm *llvm, char *store)
{
   unsigned i;
   struct draw_gs_llvm_variant_key *key;
   struct draw_sampler_static_state *draw_sampler;

   key = (struct draw_gs_llvm_variant_key *)store;

   /* All variants of this shader will have the same value for
    * nr_samplers.  Not yet trying to compact away holes in the
    * sampler array.
    */
   key->nr_samplers = llvm->draw->gs.geometry_shader->info.file_max[TGSI_FILE_SAMPLER] + 1;
   if (llvm->draw->gs.geometry_shader->info.file_max[TGSI_FILE_SAMPLER_VIEW] != -1) {
      key->nr_sampler_views =
         llvm->draw->gs.geometry_shader->info.file_max[TGSI_FILE_SAMPLER_VIEW] + 1;
   }
   else {
      key->nr_sampler_views = key->nr_samplers;
   }

   draw_sampler = key->samplers;

   memset(draw_sampler, 0, MAX2(key->nr_samplers, key->nr_sampler_views) * sizeof *draw_sampler);

   for (i = 0 ; i < key->nr_samplers; i++) {
      lp_sampler_static_sampler_state(&draw_sampler[i].sampler_state,
                                      llvm->draw->samplers[PIPE_SHADER_GEOMETRY][i]);
   }
   for (i = 0 ; i < key->nr_sampler_views; i++) {
      lp_sampler_static_texture_state(&draw_sampler[i].texture_state,
                                      llvm->draw->sampler_views[PIPE_SHADER_GEOMETRY][i]);
   }

   return key;
}

void
draw_gs_llvm_dump_variant_key(struct draw_gs_llvm_variant_key *key)
{
   unsigned i;
   struct draw_sampler_static_state *sampler = key->samplers;

   for (i = 0 ; i < key->nr_sampler_views; i++) {
      debug_printf("sampler[%i].src_format = %s\n", i,
                   util_format_name(sampler[i].texture_state.format));
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a244 1
   LLVMTypeRef int_type = LLVMInt32TypeInContext(gallivm->context);
d250 1
a250 3
   elem_types[1] = LLVMArrayType(int_type, /* num_vs_constants */
                                 LP_MAX_TGSI_CONST_BUFFERS);
   elem_types[2] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4),
d252 2
a253 2
   elem_types[3] = LLVMPointerType(float_type, 0); /* viewport */
   elem_types[4] = LLVMArrayType(texture_type,
d255 1
a255 1
   elem_types[5] = LLVMArrayType(sampler_type,
a266 2
   LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, num_vs_constants,
                          target, context_type, DRAW_JIT_CTX_NUM_CONSTANTS);
d301 1
a301 3
   elem_types[1] = LLVMArrayType(int_type, /* num_constants */
                                 LP_MAX_TGSI_CONST_BUFFERS);
   elem_types[2] = LLVMPointerType(LLVMArrayType(LLVMArrayType(float_type, 4),
d303 1
a303 1
   elem_types[3] = LLVMPointerType(float_type, 0); /* viewport */
d305 1
a305 1
   elem_types[4] = LLVMArrayType(texture_type,
d307 1
a307 1
   elem_types[5] = LLVMArrayType(sampler_type,
d310 3
a312 1
   elem_types[6] = LLVMPointerType(LLVMPointerType(int_type, 0), 0);
a314 2
   elem_types[8] = LLVMPointerType(LLVMVectorType(int_type,
                                                  vector_length), 0);
a325 2
   LP_CHECK_MEMBER_OFFSET(struct draw_gs_jit_context, num_constants,
                          target, context_type, DRAW_GS_JIT_CTX_NUM_CONSTANTS);
d620 1
a620 4
   LLVMValueRef consts_ptr =
      draw_jit_context_vs_constants(variant->gallivm, context_ptr);
   LLVMValueRef num_consts_ptr =
      draw_jit_context_num_vs_constants(variant->gallivm, context_ptr);
a635 1
                     num_consts_ptr,
d662 6
d710 1
a710 1
       * index = start_instance + (instance_id  / divisor)
d714 2
a715 1
      current_instance = LLVMBuildUDiv(builder, instance_id,
d718 1
a718 1
      index = lp_build_uadd_overflow(gallivm, index, current_instance, &ofbit);
d936 1
a940 1
         LLVMBuildStore(builder, val, id_ptr);
a980 6
            {
               LLVMValueRef iv =
                  LLVMBuildBitCast(builder, out, lp_build_int_vec_type(gallivm, soa_type), "");
               
               lp_build_print_value(gallivm, "  ival = ", iv);
            }
a1033 3
   LLVMTypeRef clip_ptr_type =
      LLVMPointerType(LLVMVectorType(LLVMFloatTypeInContext(gallivm->context),
                                     4), 0);
d1068 1
d1093 1
a1093 1
   const unsigned pos = variant->llvm->draw->vs.position_output;
d1162 2
a1163 2
   const unsigned pos = llvm->draw->vs.position_output;
   const unsigned cv = llvm->draw->vs.clipvertex_output;
d1168 2
a1169 2
   cd[0] = llvm->draw->vs.clipdistance_output[0];
   cd[1] = llvm->draw->vs.clipdistance_output[1];
a1258 1
      LLVMValueRef is_nan_or_inf;
a1277 2
            is_nan_or_inf = lp_build_is_inf_or_nan(gallivm, vs_type, clipdist);
            test = LLVMBuildOr(builder, test, is_nan_or_inf, "");
d1355 1
a1355 1
                         boolean is_vindex_indirect,
a1356 1
                         boolean is_aindex_indirect,
d1367 1
a1367 1
   if (is_vindex_indirect || is_aindex_indirect) {
d1372 2
a1373 2
         LLVMValueRef vert_chan_index = vertex_index;
         LLVMValueRef attr_chan_index = attrib_index;
a1374 10

         if (is_vindex_indirect) {
            vert_chan_index = LLVMBuildExtractElement(builder,
                                                      vertex_index, idx, "");
         }
         if (is_aindex_indirect) {
            attr_chan_index = LLVMBuildExtractElement(builder,
                                                      attrib_index, idx, "");
         }

d1376 1
a1376 1
         indices[1] = attr_chan_index;
d1378 1
a1378 1

d1490 1
a1490 1
   LLVMTypeRef arg_types[10];
a1499 1
   LLVMValueRef vertex_id_offset;
d1525 2
a1526 2
   const unsigned pos = llvm->draw->vs.position_output;
   const unsigned cv = llvm->draw->vs.clipvertex_output;
a1544 1
   arg_types[i++] = int32_type;                     /* vertex_id_offset */
a1568 1
   vertex_id_offset          = LLVMGetParam(variant_func, 8 + (elts ? 1 : 0));
a1575 1
   lp_build_name(vertex_id_offset, "vertex_id_offset");
d1650 1
a1650 1
         LLVMValueRef vert_index =
d1654 1
a1654 3
         LLVMValueRef true_index =
            LLVMBuildAdd(builder, start, vert_index, "");
         LLVMValueRef vertex_id;
d1661 5
d1677 1
a1677 1

a1701 17
         /* in the paths with elts vertex id has to be unaffected by the
          * index bias and because indices inside our elements array have
          * already had index bias applied we need to subtract it here to
          * get back to the original index.
          * in the linear paths vertex id has to be unaffected by the
          * original start index and because we abuse the 'start' variable
          * to either represent the actual start index or the index at which
          * the primitive was split (we split rendering into chunks of at
          * most 4095-vertices) we need to back out the original start
          * index out of our vertex id here.
          */
         vertex_id = LLVMBuildSub(builder, true_index, vertex_id_offset, "");

         system_values.vertex_id = LLVMBuildInsertElement(
            gallivm->builder,
            system_values.vertex_id, vertex_id,
            lp_build_const_int32(gallivm, i), "");
a1812 1
   key->num_outputs = draw_total_vs_outputs(llvm->draw);
d2019 6
a2024 3
   struct lp_type mask_type = lp_int_type(gs_type);
   LLVMValueRef num_prims;
   LLVMValueRef mask_val = lp_build_const_vec(gallivm, mask_type, 0);
d2027 8
a2034 5
   num_prims = lp_build_broadcast(gallivm, lp_build_vec_type(gallivm, mask_type),
                                  variant->num_prims);
   for (i = 0; i <= gs_type.length; i++) {
      LLVMValueRef idx = lp_build_const_int32(gallivm, i);
      mask_val = LLVMBuildInsertElement(builder, mask_val, idx, idx, "");
d2036 8
a2043 2
   mask_val = lp_build_compare(gallivm, mask_type,
                               PIPE_FUNC_GREATER, num_prims, mask_val);
d2070 1
a2070 1
   LLVMValueRef consts_ptr, num_consts_ptr;
a2143 2
   num_consts_ptr =
      draw_gs_jit_context_num_constants(variant->gallivm, context_ptr);
d2153 1
a2153 6
      system_values.prim_id = LLVMBuildLoad(builder, prim_id_ptr, "prim_id");
   }

   if (gallivm_debug & (GALLIVM_DEBUG_TGSI | GALLIVM_DEBUG_IR)) {
      tgsi_dump(tokens, 0);
      draw_gs_llvm_dump_variant_key(&variant->key);
a2160 1
                     num_consts_ptr,
a2248 2

   key->num_outputs = draw_total_gs_outputs(llvm->draw);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d100 9
d145 9
d207 9
d262 6
d325 5
d393 5
d430 5
d531 1
a531 1
draw_llvm_create(struct draw_context *draw, LLVMContextRef context)
a534 3
   if (!lp_build_init())
      return NULL;

d539 2
a542 8
   llvm->context = context;
   if (!llvm->context) {
      llvm->context = LLVMContextCreate();
      llvm->context_owned = true;
   }
   if (!llvm->context)
      goto fail;

a549 4

fail:
   draw_llvm_destroy(llvm);
   return NULL;
a558 4
   if (llvm->context_owned)
      LLVMContextDispose(llvm->context);
   llvm->context = NULL;

a575 1
   char module_name[64];
a583 1
   variant->shader = shader;
d585 1
a585 4
   util_snprintf(module_name, sizeof(module_name), "draw_llvm_vs_variant%u",
                 variant->shader->variants_cached);

   variant->gallivm = gallivm_create(module_name, llvm->context);
d606 1
a606 2
   gallivm_free_ir(variant->gallivm);

d633 1
d640 3
d652 1
a652 1
                     draw_sampler,
d690 1
a690 2
               LLVMValueRef instance_id,
               LLVMValueRef start_instance)
d720 1
d724 1
a724 2
      index = lp_build_uadd_overflow(gallivm, start_instance,
                                     current_instance, &ofbit);
d1518 1
a1518 1
   LLVMTypeRef arg_types[11];
a1524 1
   char func_name[64];
d1528 1
a1528 1
   LLVMValueRef vertex_id_offset, start_instance;
d1543 1
d1549 4
a1552 4
   const boolean bypass_viewport = key->has_gs || key->bypass_viewport;
   const boolean enable_cliptest = !key->has_gs && (key->clip_xy ||
                                                    key->clip_z  ||
                                                    key->clip_user);
a1560 3
   util_snprintf(func_name, sizeof(func_name), "draw_llvm_vs_variant%u_%s",
                 variant->shader->variants_cached, elts ? "elts" : "linear");

a1574 1
   arg_types[i++] = int32_type;                     /* start_instance */
d1578 3
a1580 1
   variant_func = LLVMAddFunction(gallivm->module, func_name, func_type);
a1599 1
   start_instance            = LLVMGetParam(variant_func, 9 + (elts ? 1 : 0));
a1607 1
   lp_build_name(start_instance, "start_instance");
d1756 1
a1756 1
                           system_values.instance_id, start_instance);
d1775 2
a1776 2
         store_clip(gallivm, vs_type, io, outputs, FALSE, key->clip_user ? cv : pos);
         store_clip(gallivm, vs_type, io, outputs, TRUE, pos);
d2011 10
a2100 1
   char func_name[64];
a2112 3
   util_snprintf(func_name, sizeof(func_name), "draw_llvm_gs_variant%u",
                 variant->shader->variants_cached);

d2125 2
a2126 2
   variant_func = LLVMAddFunction(gallivm->module, func_name, func_type);

a2229 1
   char module_name[64];
d2240 1
a2240 4
   util_snprintf(module_name, sizeof(module_name), "draw_llvm_gs_variant%u",
                 variant->shader->variants_cached);

   variant->gallivm = gallivm_create(module_name, llvm->context);
a2256 2
   gallivm_free_ir(variant->gallivm);

d2269 5
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a99 9
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, dvbuffer_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, dvbuffer_type);
#endif

a135 9
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, texture_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, texture_type);
#endif

a188 9
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, sampler_type);

   /* Make sure the target's struct layout cache doesn't return
    * stale/invalid data.
    */
   LLVMInvalidateStructLayout(gallivm->target, sampler_type);
#endif

a234 6
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, context_type);

   LLVMInvalidateStructLayout(gallivm->target, context_type);
#endif

a291 5
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, context_type);

   LLVMInvalidateStructLayout(gallivm->target, context_type);
#endif
a354 5
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, vb_type);

   LLVMInvalidateStructLayout(gallivm->target, vb_type);
#endif
a386 5
#if HAVE_LLVM < 0x0300
   LLVMAddTypeName(gallivm->module, struct_name, vertex_header);

   LLVMInvalidateStructLayout(gallivm->target, vertex_header);
#endif
d483 1
a483 1
draw_llvm_create(struct draw_context *draw)
d487 3
d494 1
a494 1
   lp_build_init();
d496 7
a502 1
   llvm->draw = draw;
d511 4
d524 4
d545 1
d554 1
d556 4
a559 1
   variant->gallivm = gallivm_create();
d580 2
a581 1
   variant->shader = shader;
a607 1
   struct lp_build_sampler_soa *sampler = 0;
a613 3
   if (llvm->draw->num_sampler_views && llvm->draw->num_samplers)
      sampler = draw_sampler;

d623 1
a623 1
                     sampler,
d661 2
a662 1
               LLVMValueRef instance_id)
a691 1
      index = lp_build_const_int32(gallivm, draw->start_instance);
d695 2
a696 1
      index = lp_build_uadd_overflow(gallivm, index, current_instance, &ofbit);
d1490 1
a1490 1
   LLVMTypeRef arg_types[10];
d1497 1
d1501 1
a1501 1
   LLVMValueRef vertex_id_offset;
a1515 1
   const struct draw_geometry_shader *gs = draw->gs.geometry_shader;
d1521 4
a1524 4
   const boolean bypass_viewport = gs || key->bypass_viewport;
   const boolean enable_cliptest = !gs && (key->clip_xy ||
                                           key->clip_z  ||
                                           key->clip_user);
d1533 3
d1550 1
d1554 1
a1554 3
   variant_func = LLVMAddFunction(gallivm->module,
                                  elts ? "draw_llvm_shader_elts" : "draw_llvm_shader",
                                  func_type);
d1574 1
d1583 1
d1732 1
a1732 1
                           system_values.instance_id);
d1751 2
a1752 2
         store_clip(gallivm, vs_type, io, outputs, 0, cv);
         store_clip(gallivm, vs_type, io, outputs, 1, pos);
a1986 10
   if (variant->function_elts) {
      gallivm_free_function(variant->gallivm,
                            variant->function_elts, variant->jit_func_elts);
   }

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function, variant->jit_func);
   }

d2067 1
d2080 3
d2095 2
a2096 2
   variant_func = LLVMAddFunction(gallivm->module, "draw_geometry_shader",
                                  func_type);
d2200 1
d2211 4
a2214 1
   variant->gallivm = gallivm_create();
d2231 2
a2244 5

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function, variant->jit_func);
   }
@


