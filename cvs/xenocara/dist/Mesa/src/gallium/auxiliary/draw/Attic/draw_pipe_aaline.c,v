head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.30;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.40;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.41;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.08;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.15;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * AA line stage:  AA lines are converted to texture mapped triangles.
 *
 * Authors:  Brian Paul
 */


#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "pipe/p_shader_tokens.h"
#include "util/u_inlines.h"

#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_sampler.h"

#include "tgsi/tgsi_transform.h"
#include "tgsi/tgsi_dump.h"

#include "draw_context.h"
#include "draw_private.h"
#include "draw_pipe.h"


/** Approx number of new tokens for instructions in aa_transform_inst() */
#define NUM_NEW_TOKENS 50


/**
 * Size for the alpha texture used for antialiasing
 */
#define TEXTURE_SIZE_LOG2  5   /* 32 x 32 */

/**
 * Max texture level for the alpha texture used for antialiasing
 *
 * Don't use the 1x1 and 2x2 mipmap levels.
 */
#define MAX_TEXTURE_LEVEL  (TEXTURE_SIZE_LOG2 - 2)


/**
 * Subclass of pipe_shader_state to carry extra fragment shader info.
 */
struct aaline_fragment_shader
{
   struct pipe_shader_state state;
   void *driver_fs;
   void *aaline_fs;
   uint sampler_unit;
   int generic_attrib;  /**< texcoord/generic used for texture */
};


/**
 * Subclass of draw_stage
 */
struct aaline_stage
{
   struct draw_stage stage;

   float half_line_width;

   /** For AA lines, this is the vertex attrib slot for the new texcoords */
   uint tex_slot;
   /** position, not necessarily output zero */
   uint pos_slot;

   void *sampler_cso;
   struct pipe_resource *texture;
   struct pipe_sampler_view *sampler_view;
   uint num_samplers;
   uint num_sampler_views;


   /*
    * Currently bound state
    */
   struct aaline_fragment_shader *fs;
   struct {
      void *sampler[PIPE_MAX_SAMPLERS];
      struct pipe_sampler_view *sampler_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
   } state;

   /*
    * Driver interface/override functions
    */
   void * (*driver_create_fs_state)(struct pipe_context *,
                                    const struct pipe_shader_state *);
   void (*driver_bind_fs_state)(struct pipe_context *, void *);
   void (*driver_delete_fs_state)(struct pipe_context *, void *);

   void (*driver_bind_sampler_states)(struct pipe_context *, unsigned, unsigned,
                                      unsigned, void **);

   void (*driver_set_sampler_views)(struct pipe_context *, unsigned shader,
                                    unsigned start, unsigned count,
                                    struct pipe_sampler_view **);
};



/**
 * Subclass of tgsi_transform_context, used for transforming the
 * user's fragment shader to add the special AA instructions.
 */
struct aa_transform_context {
   struct tgsi_transform_context base;
   uint tempsUsed;  /**< bitmask */
   int colorOutput; /**< which output is the primary color */
   uint samplersUsed;  /**< bitfield of samplers used */
   int freeSampler;  /** an available sampler for the pstipple */
   int maxInput, maxGeneric;  /**< max input index found */
   int colorTemp, texTemp;  /**< temp registers */
   boolean firstInstruction;
};


/**
 * TGSI declaration transform callback.
 * Look for a free sampler, a free input attrib, and two free temp regs.
 */
static void
aa_transform_decl(struct tgsi_transform_context *ctx,
                  struct tgsi_full_declaration *decl)
{
   struct aa_transform_context *aactx = (struct aa_transform_context *) ctx;

   if (decl->Declaration.File == TGSI_FILE_OUTPUT &&
       decl->Semantic.Name == TGSI_SEMANTIC_COLOR &&
       decl->Semantic.Index == 0) {
      aactx->colorOutput = decl->Range.First;
   }
   else if (decl->Declaration.File == TGSI_FILE_SAMPLER) {
      uint i;
      for (i = decl->Range.First;
           i <= decl->Range.Last; i++) {
         aactx->samplersUsed |= 1 << i;
      }
   }
   else if (decl->Declaration.File == TGSI_FILE_INPUT) {
      if ((int) decl->Range.Last > aactx->maxInput)
         aactx->maxInput = decl->Range.Last;
      if (decl->Semantic.Name == TGSI_SEMANTIC_GENERIC &&
           (int) decl->Semantic.Index > aactx->maxGeneric) {
         aactx->maxGeneric = decl->Semantic.Index;
      }
   }
   else if (decl->Declaration.File == TGSI_FILE_TEMPORARY) {
      uint i;
      for (i = decl->Range.First;
           i <= decl->Range.Last; i++) {
         aactx->tempsUsed |= (1 << i);
      }
   }

   ctx->emit_declaration(ctx, decl);
}


/**
 * Find the lowest zero bit in the given word, or -1 if bitfield is all ones.
 */
static int
free_bit(uint bitfield)
{
   return ffs(~bitfield) - 1;
}


/**
 * TGSI instruction transform callback.
 * Replace writes to result.color w/ a temp reg.
 * Upon END instruction, insert texture sampling code for antialiasing.
 */
static void
aa_transform_inst(struct tgsi_transform_context *ctx,
                  struct tgsi_full_instruction *inst)
{
   struct aa_transform_context *aactx = (struct aa_transform_context *) ctx;

   if (aactx->firstInstruction) {
      /* emit our new declarations before the first instruction */

      struct tgsi_full_declaration decl;
      uint i;

      /* find free sampler */
      aactx->freeSampler = free_bit(aactx->samplersUsed);
      if (aactx->freeSampler >= PIPE_MAX_SAMPLERS)
         aactx->freeSampler = PIPE_MAX_SAMPLERS - 1;

      /* find two free temp regs */
      for (i = 0; i < 32; i++) {
         if ((aactx->tempsUsed & (1 << i)) == 0) {
            /* found a free temp */
            if (aactx->colorTemp < 0)
               aactx->colorTemp  = i;
            else if (aactx->texTemp < 0)
               aactx->texTemp  = i;
            else
               break;
         }
      }
      assert(aactx->colorTemp >= 0);
      assert(aactx->texTemp >= 0);

      /* declare new generic input/texcoord */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_INPUT;
      /* XXX this could be linear... */
      decl.Declaration.Interpolate = 1;
      decl.Declaration.Semantic = 1;
      decl.Semantic.Name = TGSI_SEMANTIC_GENERIC;
      decl.Semantic.Index = aactx->maxGeneric + 1;
      decl.Range.First = 
      decl.Range.Last = aactx->maxInput + 1;
      decl.Interp.Interpolate = TGSI_INTERPOLATE_PERSPECTIVE;
      ctx->emit_declaration(ctx, &decl);

      /* declare new sampler */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_SAMPLER;
      decl.Range.First = 
      decl.Range.Last = aactx->freeSampler;
      ctx->emit_declaration(ctx, &decl);

      /* declare new temp regs */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_TEMPORARY;
      decl.Range.First = 
      decl.Range.Last = aactx->texTemp;
      ctx->emit_declaration(ctx, &decl);

      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_TEMPORARY;
      decl.Range.First = 
      decl.Range.Last = aactx->colorTemp;
      ctx->emit_declaration(ctx, &decl);

      aactx->firstInstruction = FALSE;
   }

   if (inst->Instruction.Opcode == TGSI_OPCODE_END &&
       aactx->colorOutput != -1) {
      struct tgsi_full_instruction newInst;

      /* TEX */
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_TEX;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Dst[0].Register.Index = aactx->texTemp;
      newInst.Instruction.NumSrcRegs = 2;
      newInst.Instruction.Texture = TRUE;
      newInst.Texture.Texture = TGSI_TEXTURE_2D;
      newInst.Src[0].Register.File = TGSI_FILE_INPUT;
      newInst.Src[0].Register.Index = aactx->maxInput + 1;
      newInst.Src[1].Register.File = TGSI_FILE_SAMPLER;
      newInst.Src[1].Register.Index = aactx->freeSampler;

      ctx->emit_instruction(ctx, &newInst);

      /* MOV rgb */
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_MOV;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_OUTPUT;
      newInst.Dst[0].Register.Index = aactx->colorOutput;
      newInst.Dst[0].Register.WriteMask = TGSI_WRITEMASK_XYZ;
      newInst.Instruction.NumSrcRegs = 1;
      newInst.Src[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[0].Register.Index = aactx->colorTemp;
      ctx->emit_instruction(ctx, &newInst);

      /* MUL alpha */
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_MUL;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_OUTPUT;
      newInst.Dst[0].Register.Index = aactx->colorOutput;
      newInst.Dst[0].Register.WriteMask = TGSI_WRITEMASK_W;
      newInst.Instruction.NumSrcRegs = 2;
      newInst.Src[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[0].Register.Index = aactx->colorTemp;
      newInst.Src[1].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[1].Register.Index = aactx->texTemp;
      ctx->emit_instruction(ctx, &newInst);

      /* END */
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_END;
      newInst.Instruction.NumDstRegs = 0;
      newInst.Instruction.NumSrcRegs = 0;
      ctx->emit_instruction(ctx, &newInst);
   }
   else {
      /* Not an END instruction.
       * Look for writes to result.color and replace with colorTemp reg.
       */
      uint i;

      for (i = 0; i < inst->Instruction.NumDstRegs; i++) {
         struct tgsi_full_dst_register *dst = &inst->Dst[i];
         if (dst->Register.File == TGSI_FILE_OUTPUT &&
             dst->Register.Index == aactx->colorOutput) {
            dst->Register.File = TGSI_FILE_TEMPORARY;
            dst->Register.Index = aactx->colorTemp;
         }
      }

      ctx->emit_instruction(ctx, inst);
   }
}


/**
 * Generate the frag shader we'll use for drawing AA lines.
 * This will be the user's shader plus some texture/modulate instructions.
 */
static boolean
generate_aaline_fs(struct aaline_stage *aaline)
{
   struct pipe_context *pipe = aaline->stage.draw->pipe;
   const struct pipe_shader_state *orig_fs = &aaline->fs->state;
   struct pipe_shader_state aaline_fs;
   struct aa_transform_context transform;
   const uint newLen = tgsi_num_tokens(orig_fs->tokens) + NUM_NEW_TOKENS;

   aaline_fs = *orig_fs; /* copy to init */
   aaline_fs.tokens = tgsi_alloc_tokens(newLen);
   if (aaline_fs.tokens == NULL)
      return FALSE;

   memset(&transform, 0, sizeof(transform));
   transform.colorOutput = -1;
   transform.maxInput = -1;
   transform.maxGeneric = -1;
   transform.colorTemp = -1;
   transform.texTemp = -1;
   transform.firstInstruction = TRUE;
   transform.base.transform_instruction = aa_transform_inst;
   transform.base.transform_declaration = aa_transform_decl;

   tgsi_transform_shader(orig_fs->tokens,
                         (struct tgsi_token *) aaline_fs.tokens,
                         newLen, &transform.base);

#if 0 /* DEBUG */
   debug_printf("draw_aaline, orig shader:\n");
   tgsi_dump(orig_fs->tokens, 0);
   debug_printf("draw_aaline, new shader:\n");
   tgsi_dump(aaline_fs.tokens, 0);
#endif

   aaline->fs->sampler_unit = transform.freeSampler;

   aaline->fs->aaline_fs = aaline->driver_create_fs_state(pipe, &aaline_fs);
   if (aaline->fs->aaline_fs == NULL)
      goto fail;

   aaline->fs->generic_attrib = transform.maxGeneric + 1;
   FREE((void *)aaline_fs.tokens);
   return TRUE;

fail:
   FREE((void *)aaline_fs.tokens);
   return FALSE;
}


/**
 * Create the texture map we'll use for antialiasing the lines.
 */
static boolean
aaline_create_texture(struct aaline_stage *aaline)
{
   struct pipe_context *pipe = aaline->stage.draw->pipe;
   struct pipe_screen *screen = pipe->screen;
   struct pipe_resource texTemp;
   struct pipe_sampler_view viewTempl;
   uint level;

   memset(&texTemp, 0, sizeof(texTemp));
   texTemp.target = PIPE_TEXTURE_2D;
   texTemp.format = PIPE_FORMAT_A8_UNORM; /* XXX verify supported by driver! */
   texTemp.last_level = MAX_TEXTURE_LEVEL;
   texTemp.width0 = 1 << TEXTURE_SIZE_LOG2;
   texTemp.height0 = 1 << TEXTURE_SIZE_LOG2;
   texTemp.depth0 = 1;
   texTemp.array_size = 1;
   texTemp.bind = PIPE_BIND_SAMPLER_VIEW;

   aaline->texture = screen->resource_create(screen, &texTemp);
   if (!aaline->texture)
      return FALSE;

   u_sampler_view_default_template(&viewTempl,
                                   aaline->texture,
                                   aaline->texture->format);
   aaline->sampler_view = pipe->create_sampler_view(pipe,
                                                    aaline->texture,
                                                    &viewTempl);
   if (!aaline->sampler_view) {
      return FALSE;
   }

   /* Fill in mipmap images.
    * Basically each level is solid opaque, except for the outermost
    * texels which are zero.  Special case the 1x1 and 2x2 levels
    * (though, those levels shouldn't be used - see the max_lod setting).
    */
   for (level = 0; level <= MAX_TEXTURE_LEVEL; level++) {
      struct pipe_transfer *transfer;
      struct pipe_box box;
      const uint size = u_minify(aaline->texture->width0, level);
      ubyte *data;
      uint i, j;

      assert(aaline->texture->width0 == aaline->texture->height0);

      u_box_origin_2d( size, size, &box );

      /* This texture is new, no need to flush. 
       */
      data = pipe->transfer_map(pipe,
                                aaline->texture,
                                level,
                                PIPE_TRANSFER_WRITE,
                                &box, &transfer);

      if (data == NULL)
         return FALSE;

      for (i = 0; i < size; i++) {
         for (j = 0; j < size; j++) {
            ubyte d;
            if (size == 1) {
               d = 255;
            }
            else if (size == 2) {
               d = 200; /* tuneable */
            }
            else if (i == 0 || j == 0 || i == size - 1 || j == size - 1) {
               d = 35;  /* edge texel */
            }
            else {
               d = 255;
            }
            data[i * transfer->stride + j] = d;
         }
      }

      /* unmap */
      pipe->transfer_unmap(pipe, transfer);
   }
   return TRUE;
}


/**
 * Create the sampler CSO that'll be used for antialiasing.
 * By using a mipmapped texture, we don't have to generate a different
 * texture image for each line size.
 */
static boolean
aaline_create_sampler(struct aaline_stage *aaline)
{
   struct pipe_sampler_state sampler;
   struct pipe_context *pipe = aaline->stage.draw->pipe;

   memset(&sampler, 0, sizeof(sampler));
   sampler.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   sampler.min_mip_filter = PIPE_TEX_MIPFILTER_LINEAR;
   sampler.min_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler.mag_img_filter = PIPE_TEX_FILTER_LINEAR;
   sampler.normalized_coords = 1;
   sampler.min_lod = 0.0f;
   sampler.max_lod = MAX_TEXTURE_LEVEL;

   aaline->sampler_cso = pipe->create_sampler_state(pipe, &sampler);
   if (aaline->sampler_cso == NULL)
      return FALSE;

   return TRUE;
}


/**
 * When we're about to draw our first AA line in a batch, this function is
 * called to tell the driver to bind our modified fragment shader.
 */
static boolean
bind_aaline_fragment_shader(struct aaline_stage *aaline)
{
   struct draw_context *draw = aaline->stage.draw;
   struct pipe_context *pipe = draw->pipe;

   if (!aaline->fs->aaline_fs && 
       !generate_aaline_fs(aaline))
      return FALSE;

   draw->suspend_flushing = TRUE;
   aaline->driver_bind_fs_state(pipe, aaline->fs->aaline_fs);
   draw->suspend_flushing = FALSE;

   return TRUE;
}



static INLINE struct aaline_stage *
aaline_stage( struct draw_stage *stage )
{
   return (struct aaline_stage *) stage;
}


/**
 * Draw a wide line by drawing a quad, using geometry which will
 * fullfill GL's antialiased line requirements.
 */
static void
aaline_line(struct draw_stage *stage, struct prim_header *header)
{
   const struct aaline_stage *aaline = aaline_stage(stage);
   const float half_width = aaline->half_line_width;
   struct prim_header tri;
   struct vertex_header *v[8];
   uint texPos = aaline->tex_slot;
   uint posPos = aaline->pos_slot;
   float *pos, *tex;
   float dx = header->v[1]->data[posPos][0] - header->v[0]->data[posPos][0];
   float dy = header->v[1]->data[posPos][1] - header->v[0]->data[posPos][1];
   double a = atan2(dy, dx);
   float c_a = (float) cos(a), s_a = (float) sin(a);
   uint i;

   /* XXX the ends of lines aren't quite perfect yet, but probably passable */
   dx = 0.5F * half_width;
   dy = half_width;

   /* allocate/dup new verts */
   for (i = 0; i < 8; i++) {
      v[i] = dup_vert(stage, header->v[i/4], i);
   }

   /*
    * Quad strip for line from v0 to v1 (*=endpoints):
    *
    *  1   3                     5   7
    *  +---+---------------------+---+
    *  |                             |
    *  | *v0                     v1* |
    *  |                             |
    *  +---+---------------------+---+
    *  0   2                     4   6
    */

   /* new verts */
   pos = v[0]->data[posPos];
   pos[0] += (-dx * c_a -  dy * s_a);
   pos[1] += (-dx * s_a +  dy * c_a);

   pos = v[1]->data[posPos];
   pos[0] += (-dx * c_a - -dy * s_a);
   pos[1] += (-dx * s_a + -dy * c_a);

   pos = v[2]->data[posPos];
   pos[0] += ( dx * c_a -  dy * s_a);
   pos[1] += ( dx * s_a +  dy * c_a);

   pos = v[3]->data[posPos];
   pos[0] += ( dx * c_a - -dy * s_a);
   pos[1] += ( dx * s_a + -dy * c_a);

   pos = v[4]->data[posPos];
   pos[0] += (-dx * c_a -  dy * s_a);
   pos[1] += (-dx * s_a +  dy * c_a);

   pos = v[5]->data[posPos];
   pos[0] += (-dx * c_a - -dy * s_a);
   pos[1] += (-dx * s_a + -dy * c_a);

   pos = v[6]->data[posPos];
   pos[0] += ( dx * c_a -  dy * s_a);
   pos[1] += ( dx * s_a +  dy * c_a);

   pos = v[7]->data[posPos];
   pos[0] += ( dx * c_a - -dy * s_a);
   pos[1] += ( dx * s_a + -dy * c_a);

   /* new texcoords */
   tex = v[0]->data[texPos];
   ASSIGN_4V(tex, 0, 0, 0, 1);

   tex = v[1]->data[texPos];
   ASSIGN_4V(tex, 0, 1, 0, 1);

   tex = v[2]->data[texPos];
   ASSIGN_4V(tex, .5, 0, 0, 1);

   tex = v[3]->data[texPos];
   ASSIGN_4V(tex, .5, 1, 0, 1);

   tex = v[4]->data[texPos];
   ASSIGN_4V(tex, .5, 0, 0, 1);

   tex = v[5]->data[texPos];
   ASSIGN_4V(tex, .5, 1, 0, 1);

   tex = v[6]->data[texPos];
   ASSIGN_4V(tex, 1, 0, 0, 1);

   tex = v[7]->data[texPos];
   ASSIGN_4V(tex, 1, 1, 0, 1);

   /* emit 6 tris for the quad strip */
   tri.v[0] = v[2];  tri.v[1] = v[1];  tri.v[2] = v[0];
   stage->next->tri( stage->next, &tri );

   tri.v[0] = v[3];  tri.v[1] = v[1];  tri.v[2] = v[2];
   stage->next->tri( stage->next, &tri );

   tri.v[0] = v[4];  tri.v[1] = v[3];  tri.v[2] = v[2];
   stage->next->tri( stage->next, &tri );

   tri.v[0] = v[5];  tri.v[1] = v[3];  tri.v[2] = v[4];
   stage->next->tri( stage->next, &tri );

   tri.v[0] = v[6];  tri.v[1] = v[5];  tri.v[2] = v[4];
   stage->next->tri( stage->next, &tri );

   tri.v[0] = v[7];  tri.v[1] = v[5];  tri.v[2] = v[6];
   stage->next->tri( stage->next, &tri );
}


static void
aaline_first_line(struct draw_stage *stage, struct prim_header *header)
{
   auto struct aaline_stage *aaline = aaline_stage(stage);
   struct draw_context *draw = stage->draw;
   struct pipe_context *pipe = draw->pipe;
   const struct pipe_rasterizer_state *rast = draw->rasterizer;
   uint num_samplers;
   void *r;

   assert(draw->rasterizer->line_smooth);

   if (draw->rasterizer->line_width <= 2.2)
      aaline->half_line_width = 1.1f;
   else
      aaline->half_line_width = 0.5f * draw->rasterizer->line_width;

   /*
    * Bind (generate) our fragprog, sampler and texture
    */
   if (!bind_aaline_fragment_shader(aaline)) {
      stage->line = draw_pipe_passthrough_line;
      stage->line(stage, header);
      return;
   }

   draw_aaline_prepare_outputs(draw, draw->pipeline.aaline);

   /* how many samplers? */
   /* we'll use sampler/texture[pstip->sampler_unit] for the stipple */
   num_samplers = MAX2(aaline->num_sampler_views, aaline->num_samplers);
   num_samplers = MAX2(num_samplers, aaline->fs->sampler_unit + 1);

   aaline->state.sampler[aaline->fs->sampler_unit] = aaline->sampler_cso;
   pipe_sampler_view_reference(&aaline->state.sampler_views[aaline->fs->sampler_unit],
                               aaline->sampler_view);

   draw->suspend_flushing = TRUE;

   aaline->driver_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
                                      num_samplers, aaline->state.sampler);

   aaline->driver_set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0,
                                    num_samplers, aaline->state.sampler_views);

   /* Disable triangle culling, stippling, unfilled mode etc. */
   r = draw_get_rasterizer_no_cull(draw, rast->scissor, rast->flatshade);
   pipe->bind_rasterizer_state(pipe, r);

   draw->suspend_flushing = FALSE;

   /* now really draw first line */
   stage->line = aaline_line;
   stage->line(stage, header);
}


static void
aaline_flush(struct draw_stage *stage, unsigned flags)
{
   struct draw_context *draw = stage->draw;
   struct aaline_stage *aaline = aaline_stage(stage);
   struct pipe_context *pipe = draw->pipe;

   stage->line = aaline_first_line;
   stage->next->flush( stage->next, flags );

   /* restore original frag shader, texture, sampler state */
   draw->suspend_flushing = TRUE;
   aaline->driver_bind_fs_state(pipe, aaline->fs ? aaline->fs->driver_fs : NULL);

   aaline->driver_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
                                      aaline->num_samplers,
                                      aaline->state.sampler);

   aaline->driver_set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0,
                                    aaline->num_samplers,
                                    aaline->state.sampler_views);

   /* restore original rasterizer state */
   if (draw->rast_handle) {
      pipe->bind_rasterizer_state(pipe, draw->rast_handle);
   }

   draw->suspend_flushing = FALSE;

   draw_remove_extra_vertex_attribs(draw);
}


static void
aaline_reset_stipple_counter(struct draw_stage *stage)
{
   stage->next->reset_stipple_counter( stage->next );
}


static void
aaline_destroy(struct draw_stage *stage)
{
   struct aaline_stage *aaline = aaline_stage(stage);
   struct pipe_context *pipe = stage->draw->pipe;
   uint i;

   for (i = 0; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; i++) {
      pipe_sampler_view_reference(&aaline->state.sampler_views[i], NULL);
   }

   if (aaline->sampler_cso)
      pipe->delete_sampler_state(pipe, aaline->sampler_cso);

   if (aaline->texture)
      pipe_resource_reference(&aaline->texture, NULL);

   if (aaline->sampler_view) {
      pipe_sampler_view_reference(&aaline->sampler_view, NULL);
   }

   draw_free_temp_verts( stage );

   /* restore the old entry points */
   pipe->create_fs_state = aaline->driver_create_fs_state;
   pipe->bind_fs_state = aaline->driver_bind_fs_state;
   pipe->delete_fs_state = aaline->driver_delete_fs_state;

   pipe->bind_sampler_states = aaline->driver_bind_sampler_states;
   pipe->set_sampler_views = aaline->driver_set_sampler_views;

   FREE( stage );
}


static struct aaline_stage *
draw_aaline_stage(struct draw_context *draw)
{
   struct aaline_stage *aaline = CALLOC_STRUCT(aaline_stage);
   if (aaline == NULL)
      return NULL;

   aaline->stage.draw = draw;
   aaline->stage.name = "aaline";
   aaline->stage.next = NULL;
   aaline->stage.point = draw_pipe_passthrough_point;
   aaline->stage.line = aaline_first_line;
   aaline->stage.tri = draw_pipe_passthrough_tri;
   aaline->stage.flush = aaline_flush;
   aaline->stage.reset_stipple_counter = aaline_reset_stipple_counter;
   aaline->stage.destroy = aaline_destroy;

   if (!draw_alloc_temp_verts( &aaline->stage, 8 ))
      goto fail;

   return aaline;

 fail:
   if (aaline)
      aaline->stage.destroy(&aaline->stage);

   return NULL;
}


static struct aaline_stage *
aaline_stage_from_pipe(struct pipe_context *pipe)
{
   struct draw_context *draw = (struct draw_context *) pipe->draw;

   if (draw) {
      return aaline_stage(draw->pipeline.aaline);
   } else {
      return NULL;
   }
}


/**
 * This function overrides the driver's create_fs_state() function and
 * will typically be called by the state tracker.
 */
static void *
aaline_create_fs_state(struct pipe_context *pipe,
                       const struct pipe_shader_state *fs)
{
   struct aaline_stage *aaline = aaline_stage_from_pipe(pipe);
   struct aaline_fragment_shader *aafs = NULL;

   if (aaline == NULL)
      return NULL;

   aafs = CALLOC_STRUCT(aaline_fragment_shader);

   if (aafs == NULL)
      return NULL;

   aafs->state.tokens = tgsi_dup_tokens(fs->tokens);

   /* pass-through */
   aafs->driver_fs = aaline->driver_create_fs_state(pipe, fs);

   return aafs;
}


static void
aaline_bind_fs_state(struct pipe_context *pipe, void *fs)
{
   struct aaline_stage *aaline = aaline_stage_from_pipe(pipe);
   struct aaline_fragment_shader *aafs = (struct aaline_fragment_shader *) fs;

   if (aaline == NULL) {
      return;
   }

   /* save current */
   aaline->fs = aafs;
   /* pass-through */
   aaline->driver_bind_fs_state(pipe, (aafs ? aafs->driver_fs : NULL));
}


static void
aaline_delete_fs_state(struct pipe_context *pipe, void *fs)
{
   struct aaline_stage *aaline = aaline_stage_from_pipe(pipe);
   struct aaline_fragment_shader *aafs = (struct aaline_fragment_shader *) fs;

   if (aafs == NULL) {
      return;
   }

   if (aaline != NULL) {
      /* pass-through */
      aaline->driver_delete_fs_state(pipe, aafs->driver_fs);

      if (aafs->aaline_fs)
         aaline->driver_delete_fs_state(pipe, aafs->aaline_fs);
   }

   FREE((void*)aafs->state.tokens);
   FREE(aafs);
}


static void
aaline_bind_sampler_states(struct pipe_context *pipe, unsigned shader,
                           unsigned start, unsigned num, void **sampler)
{
   struct aaline_stage *aaline = aaline_stage_from_pipe(pipe);

   assert(start == 0);

   if (aaline == NULL) {
      return;
   }

   if (shader == PIPE_SHADER_FRAGMENT) {
      /* save current */
      memcpy(aaline->state.sampler, sampler, num * sizeof(void *));
      aaline->num_samplers = num;
   }

   /* pass-through */
   aaline->driver_bind_sampler_states(pipe, shader, start, num, sampler);
}


static void
aaline_set_sampler_views(struct pipe_context *pipe, unsigned shader,
                         unsigned start, unsigned num,
                         struct pipe_sampler_view **views)
{
   struct aaline_stage *aaline = aaline_stage_from_pipe(pipe);
   uint i;

   if (aaline == NULL) {
      return;
   }

   if (shader == PIPE_SHADER_FRAGMENT) {
      /* save current */
      for (i = 0; i < num; i++) {
         pipe_sampler_view_reference(&aaline->state.sampler_views[start + i],
                                     views[i]);
      }
      aaline->num_sampler_views = num;
   }

   /* pass-through */
   aaline->driver_set_sampler_views(pipe, shader, start, num, views);
}


void
draw_aaline_prepare_outputs(struct draw_context *draw,
                            struct draw_stage *stage)
{
   struct aaline_stage *aaline = aaline_stage(stage);
   const struct pipe_rasterizer_state *rast = draw->rasterizer;

   /* update vertex attrib info */
   aaline->pos_slot = draw_current_shader_position_output(draw);;

   if (!rast->line_smooth)
      return;

   /* allocate the extra post-transformed vertex attribute */
   aaline->tex_slot = draw_alloc_extra_vertex_attrib(draw,
                                                     TGSI_SEMANTIC_GENERIC,
                                                     aaline->fs->generic_attrib);
}

/**
 * Called by drivers that want to install this AA line prim stage
 * into the draw module's pipeline.  This will not be used if the
 * hardware has native support for AA lines.
 */
boolean
draw_install_aaline_stage(struct draw_context *draw, struct pipe_context *pipe)
{
   struct aaline_stage *aaline;

   pipe->draw = (void *) draw;

   /*
    * Create / install AA line drawing / prim stage
    */
   aaline = draw_aaline_stage( draw );
   if (!aaline)
      goto fail;

   /* save original driver functions */
   aaline->driver_create_fs_state = pipe->create_fs_state;
   aaline->driver_bind_fs_state = pipe->bind_fs_state;
   aaline->driver_delete_fs_state = pipe->delete_fs_state;

   aaline->driver_bind_sampler_states = pipe->bind_sampler_states;
   aaline->driver_set_sampler_views = pipe->set_sampler_views;

   /* create special texture, sampler state */
   if (!aaline_create_texture(aaline))
      goto fail;

   if (!aaline_create_sampler(aaline))
      goto fail;

   /* override the driver's functions */
   pipe->create_fs_state = aaline_create_fs_state;
   pipe->bind_fs_state = aaline_bind_fs_state;
   pipe->delete_fs_state = aaline_delete_fs_state;

   pipe->bind_sampler_states = aaline_bind_sampler_states;
   pipe->set_sampler_views = aaline_set_sampler_views;
   
   /* Install once everything is known to be OK:
    */
   draw->pipeline.aaline = &aaline->stage;

   return TRUE;

 fail:
   if (aaline)
      aaline->stage.destroy( &aaline->stage );
   
   return FALSE;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d143 1
d200 3
a202 1
 * TGSI transform prolog callback.
d205 2
a206 1
aa_transform_prolog(struct tgsi_transform_context *ctx)
a208 1
   uint i;
d210 2
a211 19
   /* find free sampler */
   aactx->freeSampler = free_bit(aactx->samplersUsed);
   if (aactx->freeSampler >= PIPE_MAX_SAMPLERS)
      aactx->freeSampler = PIPE_MAX_SAMPLERS - 1;

   /* find two free temp regs */
   for (i = 0; i < 32; i++) {
      if ((aactx->tempsUsed & (1 << i)) == 0) {
      /* found a free temp */
      if (aactx->colorTemp < 0)
         aactx->colorTemp  = i;
      else if (aactx->texTemp < 0)
         aactx->texTemp  = i;
      else
         break;
      }
   }
   assert(aactx->colorTemp >= 0);
   assert(aactx->texTemp >= 0);
d213 2
a214 12
   /* declare new generic input/texcoord */
   tgsi_transform_input_decl(ctx, aactx->maxInput + 1,
                             TGSI_SEMANTIC_GENERIC, aactx->maxGeneric + 1,
                             TGSI_INTERPOLATE_LINEAR);

   /* declare new sampler */
   tgsi_transform_sampler_decl(ctx, aactx->freeSampler);

   /* declare new temp regs */
   tgsi_transform_temp_decl(ctx, aactx->texTemp);
   tgsi_transform_temp_decl(ctx, aactx->colorTemp);
}
d216 19
d236 53
a288 10
/**
 * TGSI transform epilog callback.
 */
static void
aa_transform_epilog(struct tgsi_transform_context *ctx)
{
   struct aa_transform_context *aactx = (struct aa_transform_context *) ctx;

   if (aactx->colorOutput != -1) {
      /* insert texture sampling code for antialiasing. */
d290 1
a290 5
      /* TEX texTemp, input_coord, sampler */
      tgsi_transform_tex_2d_inst(ctx,
                                 TGSI_FILE_TEMPORARY, aactx->texTemp,
                                 TGSI_FILE_INPUT, aactx->maxInput + 1,
                                 aactx->freeSampler);
d293 10
a302 4
      tgsi_transform_op1_inst(ctx, TGSI_OPCODE_MOV,
                              TGSI_FILE_OUTPUT, aactx->colorOutput,
                              TGSI_WRITEMASK_XYZ,
                              TGSI_FILE_TEMPORARY, aactx->colorTemp);
d305 25
a329 7
      tgsi_transform_op2_inst(ctx, TGSI_OPCODE_MUL,
                              TGSI_FILE_OUTPUT, aactx->colorOutput,
                              TGSI_WRITEMASK_W,
                              TGSI_FILE_TEMPORARY, aactx->colorTemp,
                              TGSI_FILE_TEMPORARY, aactx->texTemp);
   }
}
d331 8
d340 1
a340 21
/**
 * TGSI instruction transform callback.
 * Replace writes to result.color w/ a temp reg.
 */
static void
aa_transform_inst(struct tgsi_transform_context *ctx,
                  struct tgsi_full_instruction *inst)
{
   struct aa_transform_context *aactx = (struct aa_transform_context *) ctx;
   uint i;

   /*
    * Look for writes to result.color and replace with colorTemp reg.
    */
   for (i = 0; i < inst->Instruction.NumDstRegs; i++) {
      struct tgsi_full_dst_register *dst = &inst->Dst[i];
      if (dst->Register.File == TGSI_FILE_OUTPUT &&
          dst->Register.Index == aactx->colorOutput) {
         dst->Register.File = TGSI_FILE_TEMPORARY;
         dst->Register.Index = aactx->colorTemp;
      }
a341 2

   ctx->emit_instruction(ctx, inst);
d369 1
a369 2
   transform.base.prolog = aa_transform_prolog;
   transform.base.epilog = aa_transform_epilog;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a142 1
   boolean firstInstruction;
d199 1
a199 3
 * TGSI instruction transform callback.
 * Replace writes to result.color w/ a temp reg.
 * Upon END instruction, insert texture sampling code for antialiasing.
d202 1
a202 2
aa_transform_inst(struct tgsi_transform_context *ctx,
                  struct tgsi_full_instruction *inst)
d205 1
d207 32
a238 2
   if (aactx->firstInstruction) {
      /* emit our new declarations before the first instruction */
a239 2
      struct tgsi_full_declaration decl;
      uint i;
d241 7
a247 19
      /* find free sampler */
      aactx->freeSampler = free_bit(aactx->samplersUsed);
      if (aactx->freeSampler >= PIPE_MAX_SAMPLERS)
         aactx->freeSampler = PIPE_MAX_SAMPLERS - 1;

      /* find two free temp regs */
      for (i = 0; i < 32; i++) {
         if ((aactx->tempsUsed & (1 << i)) == 0) {
            /* found a free temp */
            if (aactx->colorTemp < 0)
               aactx->colorTemp  = i;
            else if (aactx->texTemp < 0)
               aactx->texTemp  = i;
            else
               break;
         }
      }
      assert(aactx->colorTemp >= 0);
      assert(aactx->texTemp >= 0);
d249 2
a250 53
      /* declare new generic input/texcoord */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_INPUT;
      /* XXX this could be linear... */
      decl.Declaration.Interpolate = 1;
      decl.Declaration.Semantic = 1;
      decl.Semantic.Name = TGSI_SEMANTIC_GENERIC;
      decl.Semantic.Index = aactx->maxGeneric + 1;
      decl.Range.First = 
      decl.Range.Last = aactx->maxInput + 1;
      decl.Interp.Interpolate = TGSI_INTERPOLATE_PERSPECTIVE;
      ctx->emit_declaration(ctx, &decl);

      /* declare new sampler */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_SAMPLER;
      decl.Range.First = 
      decl.Range.Last = aactx->freeSampler;
      ctx->emit_declaration(ctx, &decl);

      /* declare new temp regs */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_TEMPORARY;
      decl.Range.First = 
      decl.Range.Last = aactx->texTemp;
      ctx->emit_declaration(ctx, &decl);

      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_TEMPORARY;
      decl.Range.First = 
      decl.Range.Last = aactx->colorTemp;
      ctx->emit_declaration(ctx, &decl);

      aactx->firstInstruction = FALSE;
   }

   if (inst->Instruction.Opcode == TGSI_OPCODE_END &&
       aactx->colorOutput != -1) {
      struct tgsi_full_instruction newInst;

      /* TEX */
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_TEX;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Dst[0].Register.Index = aactx->texTemp;
      newInst.Instruction.NumSrcRegs = 2;
      newInst.Instruction.Texture = TRUE;
      newInst.Texture.Texture = TGSI_TEXTURE_2D;
      newInst.Src[0].Register.File = TGSI_FILE_INPUT;
      newInst.Src[0].Register.Index = aactx->maxInput + 1;
      newInst.Src[1].Register.File = TGSI_FILE_SAMPLER;
      newInst.Src[1].Register.Index = aactx->freeSampler;
d252 5
a256 1
      ctx->emit_instruction(ctx, &newInst);
d259 4
a262 10
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_MOV;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_OUTPUT;
      newInst.Dst[0].Register.Index = aactx->colorOutput;
      newInst.Dst[0].Register.WriteMask = TGSI_WRITEMASK_XYZ;
      newInst.Instruction.NumSrcRegs = 1;
      newInst.Src[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[0].Register.Index = aactx->colorTemp;
      ctx->emit_instruction(ctx, &newInst);
d265 19
a283 25
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_MUL;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_OUTPUT;
      newInst.Dst[0].Register.Index = aactx->colorOutput;
      newInst.Dst[0].Register.WriteMask = TGSI_WRITEMASK_W;
      newInst.Instruction.NumSrcRegs = 2;
      newInst.Src[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[0].Register.Index = aactx->colorTemp;
      newInst.Src[1].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[1].Register.Index = aactx->texTemp;
      ctx->emit_instruction(ctx, &newInst);

      /* END */
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_END;
      newInst.Instruction.NumDstRegs = 0;
      newInst.Instruction.NumSrcRegs = 0;
      ctx->emit_instruction(ctx, &newInst);
   }
   else {
      /* Not an END instruction.
       * Look for writes to result.color and replace with colorTemp reg.
       */
      uint i;
d285 9
a293 7
      for (i = 0; i < inst->Instruction.NumDstRegs; i++) {
         struct tgsi_full_dst_register *dst = &inst->Dst[i];
         if (dst->Register.File == TGSI_FILE_OUTPUT &&
             dst->Register.Index == aactx->colorOutput) {
            dst->Register.File = TGSI_FILE_TEMPORARY;
            dst->Register.Index = aactx->colorTemp;
         }
d295 1
d297 1
a297 2
      ctx->emit_instruction(ctx, inst);
   }
d325 2
a326 1
   transform.firstInstruction = TRUE;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d110 1
a110 1
      struct pipe_sampler_view *sampler_views[PIPE_MAX_SAMPLERS];
d121 2
a122 2
   void (*driver_bind_sampler_states)(struct pipe_context *, unsigned,
                                      void **);
d124 2
a125 2
   void (*driver_set_sampler_views)(struct pipe_context *,
                                    unsigned,
d695 1
a695 7
   /* update vertex attrib info */
   aaline->pos_slot = draw_current_shader_position_output(draw);;

   /* allocate the extra post-transformed vertex attribute */
   aaline->tex_slot = draw_alloc_extra_vertex_attrib(draw,
                                                     TGSI_SEMANTIC_GENERIC,
                                                     aaline->fs->generic_attrib);
d707 6
a712 2
   aaline->driver_bind_sampler_states(pipe, num_samplers, aaline->state.sampler);
   aaline->driver_set_sampler_views(pipe, num_samplers, aaline->state.sampler_views);
d739 3
a741 1
   aaline->driver_bind_sampler_states(pipe, aaline->num_samplers,
d743 3
a745 2
   aaline->driver_set_sampler_views(pipe,
                                    aaline->num_sampler_views,
d773 1
a773 1
   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
d794 2
a795 2
   pipe->bind_fragment_sampler_states = aaline->driver_bind_sampler_states;
   pipe->set_fragment_sampler_views = aaline->driver_set_sampler_views;
d913 2
a914 2
aaline_bind_sampler_states(struct pipe_context *pipe,
                           unsigned num, void **sampler)
d918 2
d924 5
a928 3
   /* save current */
   memcpy(aaline->state.sampler, sampler, num * sizeof(void *));
   aaline->num_samplers = num;
d931 1
a931 1
   aaline->driver_bind_sampler_states(pipe, num, sampler);
d936 2
a937 2
aaline_set_sampler_views(struct pipe_context *pipe,
                         unsigned num,
d947 7
a953 6
   /* save current */
   for (i = 0; i < num; i++) {
      pipe_sampler_view_reference(&aaline->state.sampler_views[i], views[i]);
   }
   for ( ; i < PIPE_MAX_SAMPLERS; i++) {
      pipe_sampler_view_reference(&aaline->state.sampler_views[i], NULL);
a954 1
   aaline->num_sampler_views = num;
d957 1
a957 1
   aaline->driver_set_sampler_views(pipe, num, views);
d961 19
d999 8
a1013 8
   /* save original driver functions */
   aaline->driver_create_fs_state = pipe->create_fs_state;
   aaline->driver_bind_fs_state = pipe->bind_fs_state;
   aaline->driver_delete_fs_state = pipe->delete_fs_state;

   aaline->driver_bind_sampler_states = pipe->bind_fragment_sampler_states;
   aaline->driver_set_sampler_views = pipe->set_fragment_sampler_views;

d1019 2
a1020 2
   pipe->bind_fragment_sampler_states = aaline_bind_sampler_states;
   pipe->set_fragment_sampler_views = aaline_set_sampler_views;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d240 1
a240 1
      decl.Declaration.Interpolate = TGSI_INTERPOLATE_PERSPECTIVE;
d246 1
d378 1
d380 1
d454 5
a458 5
      transfer = pipe->get_transfer(pipe,
                                    aaline->texture,
                                    level,
                                    PIPE_TRANSFER_WRITE,
                                    &box);
a459 1
      data = pipe->transfer_map(pipe, transfer);
a483 1
      pipe->transfer_destroy(pipe, transfer);
a695 1
   aaline->tex_slot = draw_current_shader_outputs(draw);
d699 3
a701 2
   (void) draw_alloc_extra_vertex_attrib(draw, TGSI_SEMANTIC_GENERIC,
                                         aaline->fs->generic_attrib);
d740 1
a740 1
   aaline->driver_bind_fs_state(pipe, aaline->fs->driver_fs);
d788 8
d834 6
a839 1
   return aaline_stage(draw->pipeline.aaline);
d852 6
a857 1
   struct aaline_fragment_shader *aafs = CALLOC_STRUCT(aaline_fragment_shader);
d862 1
a862 1
   aafs->state = *fs;
d877 4
d894 7
a900 2
   /* pass-through */
   aaline->driver_delete_fs_state(pipe, aafs->driver_fs);
d902 3
a904 2
   if (aafs->aaline_fs)
      aaline->driver_delete_fs_state(pipe, aafs->aaline_fs);
d906 1
d917 4
d937 4
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d58 5
d64 2
d67 1
a67 1
#define MAX_TEXTURE_LEVEL  5   /* 32 x 32 */
d413 2
a414 2
   texTemp.width0 = 1 << MAX_TEXTURE_LEVEL;
   texTemp.height0 = 1 << MAX_TEXTURE_LEVEL;
d471 1
a471 1
               d = 0;
d508 1
a508 2
   /* avoid using the 1x1 and 2x2 mipmap levels */
   sampler.max_lod = MAX_TEXTURE_LEVEL - 2;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d43 1
d91 2
a92 1
   struct pipe_texture *texture;
d94 1
a94 1
   uint num_textures;
d103 1
a103 1
      struct pipe_texture *texture[PIPE_MAX_SAMPLERS];
d116 4
a119 2
   void (*driver_set_sampler_textures)(struct pipe_context *, unsigned,
                                       struct pipe_texture **);
d376 1
a376 2
   aaline->fs->aaline_fs
      = aaline->driver_create_fs_state(pipe, &aaline_fs);
d398 2
a399 1
   struct pipe_texture texTemp;
d409 2
d412 1
a412 1
   aaline->texture = screen->texture_create(screen, &texTemp);
d416 10
d428 2
a429 1
    * texels which are zero.  Special case the 1x1 and 2x2 levels.
d433 1
d440 2
d444 7
a450 3
      transfer = screen->get_tex_transfer(screen, aaline->texture, 0, level, 0,
                                         PIPE_TRANSFER_WRITE, 0, 0, size, size);
      data = screen->transfer_map(screen, transfer);
d474 2
a475 2
      screen->transfer_unmap(screen, transfer);
      screen->tex_transfer_destroy(transfer);
d501 2
a502 1
   sampler.max_lod = MAX_TEXTURE_LEVEL;
d674 2
a675 2
   if (draw->rasterizer->line_width <= 3.0)
      aaline->half_line_width = 1.5f;
d692 3
a694 4
   /* advertise the extra post-transformed vertex attribute */
   draw->extra_shader_outputs.semantic_name = TGSI_SEMANTIC_GENERIC;
   draw->extra_shader_outputs.semantic_index = aaline->fs->generic_attrib;
   draw->extra_shader_outputs.slot = aaline->tex_slot;
d698 1
a698 1
   num_samplers = MAX2(aaline->num_textures, aaline->num_samplers);
d702 2
a703 2
   pipe_texture_reference(&aaline->state.texture[aaline->fs->sampler_unit],
                          aaline->texture);
d707 1
a707 1
   aaline->driver_set_sampler_textures(pipe, num_samplers, aaline->state.texture);
d736 3
a738 2
   aaline->driver_set_sampler_textures(pipe, aaline->num_textures,
                                       aaline->state.texture);
d747 1
a747 1
   draw->extra_shader_outputs.slot = 0;
d766 1
a766 1
      pipe_texture_reference(&aaline->state.texture[i], NULL);
d773 5
a777 1
      pipe_texture_reference(&aaline->texture, NULL);
a791 3
   if (!draw_alloc_temp_verts( &aaline->stage, 8 ))
      goto fail;

d802 3
d809 1
a809 1
      aaline_destroy(&aaline->stage);
d891 3
a893 2
aaline_set_sampler_textures(struct pipe_context *pipe,
                            unsigned num, struct pipe_texture **texture)
d900 1
a900 1
      pipe_texture_reference(&aaline->state.texture[i], texture[i]);
d903 1
a903 1
      pipe_texture_reference(&aaline->state.texture[i], NULL);
d905 1
a905 1
   aaline->num_textures = num;
d908 1
a908 1
   aaline->driver_set_sampler_textures(pipe, num, texture);
d944 1
a944 1
   aaline->driver_set_sampler_textures = pipe->set_fragment_sampler_textures;
d952 1
a952 1
   pipe->set_fragment_sampler_textures = aaline_set_sampler_textures;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a42 1
#include "util/u_sampler.h"
d90 1
a90 2
   struct pipe_resource *texture;
   struct pipe_sampler_view *sampler_view;
d92 1
a92 1
   uint num_sampler_views;
d101 1
a101 1
      struct pipe_sampler_view *sampler_views[PIPE_MAX_SAMPLERS];
d114 2
a115 4

   void (*driver_set_sampler_views)(struct pipe_context *,
                                    unsigned,
                                    struct pipe_sampler_view **);
d372 2
a373 1
   aaline->fs->aaline_fs = aaline->driver_create_fs_state(pipe, &aaline_fs);
d395 1
a395 2
   struct pipe_resource texTemp;
   struct pipe_sampler_view viewTempl;
a404 2
   texTemp.array_size = 1;
   texTemp.bind = PIPE_BIND_SAMPLER_VIEW;
d406 1
a406 1
   aaline->texture = screen->resource_create(screen, &texTemp);
a409 10
   u_sampler_view_default_template(&viewTempl,
                                   aaline->texture,
                                   aaline->texture->format);
   aaline->sampler_view = pipe->create_sampler_view(pipe,
                                                    aaline->texture,
                                                    &viewTempl);
   if (!aaline->sampler_view) {
      return FALSE;
   }

d412 1
a412 2
    * texels which are zero.  Special case the 1x1 and 2x2 levels
    * (though, those levels shouldn't be used - see the max_lod setting).
a415 1
      struct pipe_box box;
a421 2
      u_box_origin_2d( size, size, &box );

d424 3
a426 7
      transfer = pipe->get_transfer(pipe,
                                    aaline->texture,
                                    level,
                                    PIPE_TRANSFER_WRITE,
                                    &box);

      data = pipe->transfer_map(pipe, transfer);
d450 2
a451 2
      pipe->transfer_unmap(pipe, transfer);
      pipe->transfer_destroy(pipe, transfer);
d477 1
a477 2
   /* avoid using the 1x1 and 2x2 mipmap levels */
   sampler.max_lod = MAX_TEXTURE_LEVEL - 2;
d649 2
a650 2
   if (draw->rasterizer->line_width <= 2.2)
      aaline->half_line_width = 1.1f;
d667 4
a670 3
   /* allocate the extra post-transformed vertex attribute */
   (void) draw_alloc_extra_vertex_attrib(draw, TGSI_SEMANTIC_GENERIC,
                                         aaline->fs->generic_attrib);
d674 1
a674 1
   num_samplers = MAX2(aaline->num_sampler_views, aaline->num_samplers);
d678 2
a679 2
   pipe_sampler_view_reference(&aaline->state.sampler_views[aaline->fs->sampler_unit],
                               aaline->sampler_view);
d683 1
a683 1
   aaline->driver_set_sampler_views(pipe, num_samplers, aaline->state.sampler_views);
d712 2
a713 3
   aaline->driver_set_sampler_views(pipe,
                                    aaline->num_sampler_views,
                                    aaline->state.sampler_views);
d722 1
a722 1
   draw_remove_extra_vertex_attribs(draw);
d741 1
a741 1
      pipe_sampler_view_reference(&aaline->state.sampler_views[i], NULL);
d748 1
a748 5
      pipe_resource_reference(&aaline->texture, NULL);

   if (aaline->sampler_view) {
      pipe_sampler_view_reference(&aaline->sampler_view, NULL);
   }
d763 3
a775 3
   if (!draw_alloc_temp_verts( &aaline->stage, 8 ))
      goto fail;

d780 1
a780 1
      aaline->stage.destroy(&aaline->stage);
d862 2
a863 3
aaline_set_sampler_views(struct pipe_context *pipe,
                         unsigned num,
                         struct pipe_sampler_view **views)
d870 1
a870 1
      pipe_sampler_view_reference(&aaline->state.sampler_views[i], views[i]);
d873 1
a873 1
      pipe_sampler_view_reference(&aaline->state.sampler_views[i], NULL);
d875 1
a875 1
   aaline->num_sampler_views = num;
d878 1
a878 1
   aaline->driver_set_sampler_views(pipe, num, views);
d914 1
a914 1
   aaline->driver_set_sampler_views = pipe->set_fragment_sampler_views;
d922 1
a922 1
   pipe->set_fragment_sampler_views = aaline_set_sampler_views;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a57 5
 * Size for the alpha texture used for antialiasing
 */
#define TEXTURE_SIZE_LOG2  5   /* 32 x 32 */

/**
a58 2
 *
 * Don't use the 1x1 and 2x2 mipmap levels.
d60 1
a60 1
#define MAX_TEXTURE_LEVEL  (TEXTURE_SIZE_LOG2 - 2)
d233 1
a233 1
      decl.Declaration.Interpolate = 1;
a238 1
      decl.Interp.Interpolate = TGSI_INTERPOLATE_PERSPECTIVE;
a369 1
   debug_printf("draw_aaline, orig shader:\n");
a370 1
   debug_printf("draw_aaline, new shader:\n");
d406 2
a407 2
   texTemp.width0 = 1 << TEXTURE_SIZE_LOG2;
   texTemp.height0 = 1 << TEXTURE_SIZE_LOG2;
d444 5
a448 5
      data = pipe->transfer_map(pipe,
                                aaline->texture,
                                level,
                                PIPE_TRANSFER_WRITE,
                                &box, &transfer);
d450 1
d464 1
a464 1
               d = 35;  /* edge texel */
d475 1
d501 2
a502 1
   sampler.max_lod = MAX_TEXTURE_LEVEL;
d689 1
d693 2
a694 3
   aaline->tex_slot = draw_alloc_extra_vertex_attrib(draw,
                                                     TGSI_SEMANTIC_GENERIC,
                                                     aaline->fs->generic_attrib);
d733 1
a733 1
   aaline->driver_bind_fs_state(pipe, aaline->fs ? aaline->fs->driver_fs : NULL);
a780 8
   /* restore the old entry points */
   pipe->create_fs_state = aaline->driver_create_fs_state;
   pipe->bind_fs_state = aaline->driver_bind_fs_state;
   pipe->delete_fs_state = aaline->driver_delete_fs_state;

   pipe->bind_fragment_sampler_states = aaline->driver_bind_sampler_states;
   pipe->set_fragment_sampler_views = aaline->driver_set_sampler_views;

d819 1
a819 6

   if (draw) {
      return aaline_stage(draw->pipeline.aaline);
   } else {
      return NULL;
   }
d832 1
a832 6
   struct aaline_fragment_shader *aafs = NULL;

   if (aaline == NULL)
      return NULL;

   aafs = CALLOC_STRUCT(aaline_fragment_shader);
d837 1
a837 1
   aafs->state.tokens = tgsi_dup_tokens(fs->tokens);
a851 4
   if (aaline == NULL) {
      return;
   }

d865 2
a866 7
   if (aafs == NULL) {
      return;
   }

   if (aaline != NULL) {
      /* pass-through */
      aaline->driver_delete_fs_state(pipe, aafs->driver_fs);
d868 2
a869 3
      if (aafs->aaline_fs)
         aaline->driver_delete_fs_state(pipe, aafs->aaline_fs);
   }
a870 1
   FREE((void*)aafs->state.tokens);
a880 4
   if (aaline == NULL) {
      return;
   }

a896 4

   if (aaline == NULL) {
      return;
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d110 1
a110 1
      struct pipe_sampler_view *sampler_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
d121 2
a122 2
   void (*driver_bind_sampler_states)(struct pipe_context *, unsigned, unsigned,
                                      unsigned, void **);
d124 2
a125 2
   void (*driver_set_sampler_views)(struct pipe_context *, unsigned shader,
                                    unsigned start, unsigned count,
d695 7
a701 1
   draw_aaline_prepare_outputs(draw, draw->pipeline.aaline);
d713 2
a714 6

   aaline->driver_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
                                      num_samplers, aaline->state.sampler);

   aaline->driver_set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0,
                                    num_samplers, aaline->state.sampler_views);
d741 1
a741 3

   aaline->driver_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
                                      aaline->num_samplers,
d743 2
a744 3

   aaline->driver_set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0,
                                    aaline->num_samplers,
d772 1
a772 1
   for (i = 0; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; i++) {
d793 2
a794 2
   pipe->bind_sampler_states = aaline->driver_bind_sampler_states;
   pipe->set_sampler_views = aaline->driver_set_sampler_views;
d912 2
a913 2
aaline_bind_sampler_states(struct pipe_context *pipe, unsigned shader,
                           unsigned start, unsigned num, void **sampler)
a916 2
   assert(start == 0);

d921 3
a923 5
   if (shader == PIPE_SHADER_FRAGMENT) {
      /* save current */
      memcpy(aaline->state.sampler, sampler, num * sizeof(void *));
      aaline->num_samplers = num;
   }
d926 1
a926 1
   aaline->driver_bind_sampler_states(pipe, shader, start, num, sampler);
d931 2
a932 2
aaline_set_sampler_views(struct pipe_context *pipe, unsigned shader,
                         unsigned start, unsigned num,
d942 6
a947 7
   if (shader == PIPE_SHADER_FRAGMENT) {
      /* save current */
      for (i = 0; i < num; i++) {
         pipe_sampler_view_reference(&aaline->state.sampler_views[start + i],
                                     views[i]);
      }
      aaline->num_sampler_views = num;
d949 1
d952 1
a952 1
   aaline->driver_set_sampler_views(pipe, shader, start, num, views);
a955 19
void
draw_aaline_prepare_outputs(struct draw_context *draw,
                            struct draw_stage *stage)
{
   struct aaline_stage *aaline = aaline_stage(stage);
   const struct pipe_rasterizer_state *rast = draw->rasterizer;

   /* update vertex attrib info */
   aaline->pos_slot = draw_current_shader_position_output(draw);;

   if (!rast->line_smooth)
      return;

   /* allocate the extra post-transformed vertex attribute */
   aaline->tex_slot = draw_alloc_extra_vertex_attrib(draw,
                                                     TGSI_SEMANTIC_GENERIC,
                                                     aaline->fs->generic_attrib);
}

a974 8
   /* save original driver functions */
   aaline->driver_create_fs_state = pipe->create_fs_state;
   aaline->driver_bind_fs_state = pipe->bind_fs_state;
   aaline->driver_delete_fs_state = pipe->delete_fs_state;

   aaline->driver_bind_sampler_states = pipe->bind_sampler_states;
   aaline->driver_set_sampler_views = pipe->set_sampler_views;

d982 8
d995 2
a996 2
   pipe->bind_sampler_states = aaline_bind_sampler_states;
   pipe->set_sampler_views = aaline_set_sampler_views;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d143 1
d200 3
a202 1
 * TGSI transform prolog callback.
d205 2
a206 1
aa_transform_prolog(struct tgsi_transform_context *ctx)
a208 1
   uint i;
d210 2
a211 19
   /* find free sampler */
   aactx->freeSampler = free_bit(aactx->samplersUsed);
   if (aactx->freeSampler >= PIPE_MAX_SAMPLERS)
      aactx->freeSampler = PIPE_MAX_SAMPLERS - 1;

   /* find two free temp regs */
   for (i = 0; i < 32; i++) {
      if ((aactx->tempsUsed & (1 << i)) == 0) {
      /* found a free temp */
      if (aactx->colorTemp < 0)
         aactx->colorTemp  = i;
      else if (aactx->texTemp < 0)
         aactx->texTemp  = i;
      else
         break;
      }
   }
   assert(aactx->colorTemp >= 0);
   assert(aactx->texTemp >= 0);
d213 2
a214 12
   /* declare new generic input/texcoord */
   tgsi_transform_input_decl(ctx, aactx->maxInput + 1,
                             TGSI_SEMANTIC_GENERIC, aactx->maxGeneric + 1,
                             TGSI_INTERPOLATE_LINEAR);

   /* declare new sampler */
   tgsi_transform_sampler_decl(ctx, aactx->freeSampler);

   /* declare new temp regs */
   tgsi_transform_temp_decl(ctx, aactx->texTemp);
   tgsi_transform_temp_decl(ctx, aactx->colorTemp);
}
d216 19
d236 53
a288 10
/**
 * TGSI transform epilog callback.
 */
static void
aa_transform_epilog(struct tgsi_transform_context *ctx)
{
   struct aa_transform_context *aactx = (struct aa_transform_context *) ctx;

   if (aactx->colorOutput != -1) {
      /* insert texture sampling code for antialiasing. */
d290 1
a290 5
      /* TEX texTemp, input_coord, sampler */
      tgsi_transform_tex_2d_inst(ctx,
                                 TGSI_FILE_TEMPORARY, aactx->texTemp,
                                 TGSI_FILE_INPUT, aactx->maxInput + 1,
                                 aactx->freeSampler);
d293 10
a302 4
      tgsi_transform_op1_inst(ctx, TGSI_OPCODE_MOV,
                              TGSI_FILE_OUTPUT, aactx->colorOutput,
                              TGSI_WRITEMASK_XYZ,
                              TGSI_FILE_TEMPORARY, aactx->colorTemp);
d305 25
a329 7
      tgsi_transform_op2_inst(ctx, TGSI_OPCODE_MUL,
                              TGSI_FILE_OUTPUT, aactx->colorOutput,
                              TGSI_WRITEMASK_W,
                              TGSI_FILE_TEMPORARY, aactx->colorTemp,
                              TGSI_FILE_TEMPORARY, aactx->texTemp);
   }
}
d331 8
d340 1
a340 21
/**
 * TGSI instruction transform callback.
 * Replace writes to result.color w/ a temp reg.
 */
static void
aa_transform_inst(struct tgsi_transform_context *ctx,
                  struct tgsi_full_instruction *inst)
{
   struct aa_transform_context *aactx = (struct aa_transform_context *) ctx;
   uint i;

   /*
    * Look for writes to result.color and replace with colorTemp reg.
    */
   for (i = 0; i < inst->Instruction.NumDstRegs; i++) {
      struct tgsi_full_dst_register *dst = &inst->Dst[i];
      if (dst->Register.File == TGSI_FILE_OUTPUT &&
          dst->Register.Index == aactx->colorOutput) {
         dst->Register.File = TGSI_FILE_TEMPORARY;
         dst->Register.Index = aactx->colorTemp;
      }
a341 2

   ctx->emit_instruction(ctx, inst);
d369 1
a369 2
   transform.base.prolog = aa_transform_prolog;
   transform.base.epilog = aa_transform_epilog;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a142 1
   boolean firstInstruction;
d199 1
a199 3
 * TGSI instruction transform callback.
 * Replace writes to result.color w/ a temp reg.
 * Upon END instruction, insert texture sampling code for antialiasing.
d202 1
a202 2
aa_transform_inst(struct tgsi_transform_context *ctx,
                  struct tgsi_full_instruction *inst)
d205 1
d207 32
a238 2
   if (aactx->firstInstruction) {
      /* emit our new declarations before the first instruction */
a239 2
      struct tgsi_full_declaration decl;
      uint i;
d241 7
a247 19
      /* find free sampler */
      aactx->freeSampler = free_bit(aactx->samplersUsed);
      if (aactx->freeSampler >= PIPE_MAX_SAMPLERS)
         aactx->freeSampler = PIPE_MAX_SAMPLERS - 1;

      /* find two free temp regs */
      for (i = 0; i < 32; i++) {
         if ((aactx->tempsUsed & (1 << i)) == 0) {
            /* found a free temp */
            if (aactx->colorTemp < 0)
               aactx->colorTemp  = i;
            else if (aactx->texTemp < 0)
               aactx->texTemp  = i;
            else
               break;
         }
      }
      assert(aactx->colorTemp >= 0);
      assert(aactx->texTemp >= 0);
d249 2
a250 53
      /* declare new generic input/texcoord */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_INPUT;
      /* XXX this could be linear... */
      decl.Declaration.Interpolate = 1;
      decl.Declaration.Semantic = 1;
      decl.Semantic.Name = TGSI_SEMANTIC_GENERIC;
      decl.Semantic.Index = aactx->maxGeneric + 1;
      decl.Range.First = 
      decl.Range.Last = aactx->maxInput + 1;
      decl.Interp.Interpolate = TGSI_INTERPOLATE_PERSPECTIVE;
      ctx->emit_declaration(ctx, &decl);

      /* declare new sampler */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_SAMPLER;
      decl.Range.First = 
      decl.Range.Last = aactx->freeSampler;
      ctx->emit_declaration(ctx, &decl);

      /* declare new temp regs */
      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_TEMPORARY;
      decl.Range.First = 
      decl.Range.Last = aactx->texTemp;
      ctx->emit_declaration(ctx, &decl);

      decl = tgsi_default_full_declaration();
      decl.Declaration.File = TGSI_FILE_TEMPORARY;
      decl.Range.First = 
      decl.Range.Last = aactx->colorTemp;
      ctx->emit_declaration(ctx, &decl);

      aactx->firstInstruction = FALSE;
   }

   if (inst->Instruction.Opcode == TGSI_OPCODE_END &&
       aactx->colorOutput != -1) {
      struct tgsi_full_instruction newInst;

      /* TEX */
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_TEX;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Dst[0].Register.Index = aactx->texTemp;
      newInst.Instruction.NumSrcRegs = 2;
      newInst.Instruction.Texture = TRUE;
      newInst.Texture.Texture = TGSI_TEXTURE_2D;
      newInst.Src[0].Register.File = TGSI_FILE_INPUT;
      newInst.Src[0].Register.Index = aactx->maxInput + 1;
      newInst.Src[1].Register.File = TGSI_FILE_SAMPLER;
      newInst.Src[1].Register.Index = aactx->freeSampler;
d252 5
a256 1
      ctx->emit_instruction(ctx, &newInst);
d259 4
a262 10
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_MOV;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_OUTPUT;
      newInst.Dst[0].Register.Index = aactx->colorOutput;
      newInst.Dst[0].Register.WriteMask = TGSI_WRITEMASK_XYZ;
      newInst.Instruction.NumSrcRegs = 1;
      newInst.Src[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[0].Register.Index = aactx->colorTemp;
      ctx->emit_instruction(ctx, &newInst);
d265 19
a283 25
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_MUL;
      newInst.Instruction.NumDstRegs = 1;
      newInst.Dst[0].Register.File = TGSI_FILE_OUTPUT;
      newInst.Dst[0].Register.Index = aactx->colorOutput;
      newInst.Dst[0].Register.WriteMask = TGSI_WRITEMASK_W;
      newInst.Instruction.NumSrcRegs = 2;
      newInst.Src[0].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[0].Register.Index = aactx->colorTemp;
      newInst.Src[1].Register.File = TGSI_FILE_TEMPORARY;
      newInst.Src[1].Register.Index = aactx->texTemp;
      ctx->emit_instruction(ctx, &newInst);

      /* END */
      newInst = tgsi_default_full_instruction();
      newInst.Instruction.Opcode = TGSI_OPCODE_END;
      newInst.Instruction.NumDstRegs = 0;
      newInst.Instruction.NumSrcRegs = 0;
      ctx->emit_instruction(ctx, &newInst);
   }
   else {
      /* Not an END instruction.
       * Look for writes to result.color and replace with colorTemp reg.
       */
      uint i;
d285 9
a293 7
      for (i = 0; i < inst->Instruction.NumDstRegs; i++) {
         struct tgsi_full_dst_register *dst = &inst->Dst[i];
         if (dst->Register.File == TGSI_FILE_OUTPUT &&
             dst->Register.Index == aactx->colorOutput) {
            dst->Register.File = TGSI_FILE_TEMPORARY;
            dst->Register.Index = aactx->colorTemp;
         }
d295 1
d297 1
a297 2
      ctx->emit_instruction(ctx, inst);
   }
d325 2
a326 1
   transform.firstInstruction = TRUE;
@


