head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.29;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.37;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.41;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.05;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.13;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#include "pipe/p_context.h"
#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_cpu_detect.h"
#include "util/u_inlines.h"
#include "util/u_helpers.h"
#include "util/u_prim.h"
#include "util/u_format.h"
#include "draw_context.h"
#include "draw_pipe.h"
#include "draw_prim_assembler.h"
#include "draw_vs.h"
#include "draw_gs.h"

#if HAVE_LLVM
#include "gallivm/lp_bld_init.h"
#include "gallivm/lp_bld_limits.h"
#include "draw_llvm.h"

boolean
draw_get_option_use_llvm(void)
{
   static boolean first = TRUE;
   static boolean value;
   if (first) {
      first = FALSE;
      value = debug_get_bool_option("DRAW_USE_LLVM", TRUE);

#ifdef PIPE_ARCH_X86
      util_cpu_detect();
      /* require SSE2 due to LLVM PR6960. XXX Might be fixed by now? */
      if (!util_cpu_caps.has_sse2)
         value = FALSE;
#endif
   }
   return value;
}
#else
boolean
draw_get_option_use_llvm(void)
{
   return FALSE;
}
#endif


/**
 * Create new draw module context with gallivm state for LLVM JIT.
 */
static struct draw_context *
draw_create_context(struct pipe_context *pipe, boolean try_llvm)
{
   struct draw_context *draw = CALLOC_STRUCT( draw_context );
   if (draw == NULL)
      goto err_out;

   /* we need correct cpu caps for disabling denorms in draw_vbo() */
   util_cpu_detect();

#if HAVE_LLVM
   if (try_llvm && draw_get_option_use_llvm()) {
      draw->llvm = draw_llvm_create(draw);
      if (!draw->llvm)
         goto err_destroy;
   }
#endif

   draw->pipe = pipe;

   if (!draw_init(draw))
      goto err_destroy;

   draw->ia = draw_prim_assembler_create(draw);
   if (!draw->ia)
      goto err_destroy;

   return draw;

err_destroy:
   draw_destroy( draw );
err_out:
   return NULL;
}


/**
 * Create new draw module context, with LLVM JIT.
 */
struct draw_context *
draw_create(struct pipe_context *pipe)
{
   return draw_create_context(pipe, TRUE);
}


/**
 * Create a new draw context, without LLVM JIT.
 */
struct draw_context *
draw_create_no_llvm(struct pipe_context *pipe)
{
   return draw_create_context(pipe, FALSE);
}


boolean draw_init(struct draw_context *draw)
{
   /*
    * Note that several functions compute the clipmask of the predefined
    * formats with hardcoded formulas instead of using these. So modifications
    * here must be reflected there too.
    */

   ASSIGN_4V( draw->plane[0], -1,  0,  0, 1 );
   ASSIGN_4V( draw->plane[1],  1,  0,  0, 1 );
   ASSIGN_4V( draw->plane[2],  0, -1,  0, 1 );
   ASSIGN_4V( draw->plane[3],  0,  1,  0, 1 );
   ASSIGN_4V( draw->plane[4],  0,  0,  1, 1 ); /* yes these are correct */
   ASSIGN_4V( draw->plane[5],  0,  0, -1, 1 ); /* mesa's a bit wonky */
   draw->clip_xy = TRUE;
   draw->clip_z = TRUE;

   draw->pt.user.planes = (float (*) [DRAW_TOTAL_CLIP_PLANES][4]) &(draw->plane[0]);
   draw->pt.user.eltMax = ~0;

   if (!draw_pipeline_init( draw ))
      return FALSE;

   if (!draw_pt_init( draw ))
      return FALSE;

   if (!draw_vs_init( draw ))
      return FALSE;

   if (!draw_gs_init( draw ))
      return FALSE;

   draw->quads_always_flatshade_last = !draw->pipe->screen->get_param(
      draw->pipe->screen, PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION);

   draw->floating_point_depth = false;

   return TRUE;
}

/*
 * Called whenever we're starting to draw a new instance.
 * Some internal structures don't want to have to reset internal
 * members on each invocation (because their state might have to persist
 * between multiple primitive restart rendering call) but might have to 
 * for each new instance. 
 * This is particularly the case for primitive id's in geometry shader.
 */
void draw_new_instance(struct draw_context *draw)
{
   draw_geometry_shader_new_instance(draw->gs.geometry_shader);
}


void draw_destroy( struct draw_context *draw )
{
   struct pipe_context *pipe;
   unsigned i, j;

   if (!draw)
      return;

   pipe = draw->pipe;

   /* free any rasterizer CSOs that we may have created.
    */
   for (i = 0; i < 2; i++) {
      for (j = 0; j < 2; j++) {
         if (draw->rasterizer_no_cull[i][j]) {
            pipe->delete_rasterizer_state(pipe, draw->rasterizer_no_cull[i][j]);
         }
      }
   }

   for (i = 0; i < draw->pt.nr_vertex_buffers; i++) {
      pipe_resource_reference(&draw->pt.vertex_buffer[i].buffer, NULL);
   }

   /* Not so fast -- we're just borrowing this at the moment.
    * 
   if (draw->render)
      draw->render->destroy( draw->render );
   */

   draw_prim_assembler_destroy(draw->ia);
   draw_pipeline_destroy( draw );
   draw_pt_destroy( draw );
   draw_vs_destroy( draw );
   draw_gs_destroy( draw );
#ifdef HAVE_LLVM
   if (draw->llvm)
      draw_llvm_destroy( draw->llvm );
#endif

   FREE( draw );
}



void draw_flush( struct draw_context *draw )
{
   draw_do_flush( draw, DRAW_FLUSH_BACKEND );
}


/**
 * Specify the depth stencil format for the draw pipeline. This function
 * determines the Minimum Resolvable Depth factor for polygon offset.
 * This factor potentially depends on the number of Z buffer bits,
 * the rasterization algorithm and the arithmetic performed on Z
 * values between vertex shading and rasterization.
 */
void draw_set_zs_format(struct draw_context *draw, enum pipe_format format)
{
   const struct util_format_description *desc = util_format_description(format);

   draw->floating_point_depth =
      (util_get_depth_format_type(desc) == UTIL_FORMAT_TYPE_FLOAT);

   draw->mrd = util_get_depth_format_mrd(desc);
}


static void update_clip_flags( struct draw_context *draw )
{
   draw->clip_xy = !draw->driver.bypass_clip_xy;
   draw->guard_band_xy = (!draw->driver.bypass_clip_xy &&
                          draw->driver.guard_band_xy);
   draw->clip_z = (!draw->driver.bypass_clip_z &&
                   draw->rasterizer && draw->rasterizer->depth_clip);
   draw->clip_user = draw->rasterizer &&
                     draw->rasterizer->clip_plane_enable != 0;
   draw->guard_band_points_xy = draw->guard_band_xy ||
                                (draw->driver.bypass_clip_points &&
                                (draw->rasterizer &&
                                 draw->rasterizer->point_tri_clip));
}

/**
 * Register new primitive rasterization/rendering state.
 * This causes the drawing pipeline to be rebuilt.
 */
void draw_set_rasterizer_state( struct draw_context *draw,
                                const struct pipe_rasterizer_state *raster,
                                void *rast_handle )
{
   if (!draw->suspend_flushing) {
      draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );

      draw->rasterizer = raster;
      draw->rast_handle = rast_handle;
      update_clip_flags(draw);
   }
}

/* With a little more work, llvmpipe will be able to turn this off and
 * do its own x/y clipping.  
 *
 * Some hardware can turn off clipping altogether - in particular any
 * hardware with a TNL unit can do its own clipping, even if it is
 * relying on the draw module for some other reason.
 * Setting bypass_clip_points to achieve d3d-style point clipping (the driver
 * will need to do the "vp scissoring") _requires_ the driver to implement
 * wide points / point sprites itself (points will still be clipped if rasterizer
 * point_tri_clip isn't set). Only relevant if bypass_clip_xy isn't set.
 */
void draw_set_driver_clipping( struct draw_context *draw,
                               boolean bypass_clip_xy,
                               boolean bypass_clip_z,
                               boolean guard_band_xy,
                               boolean bypass_clip_points)
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );

   draw->driver.bypass_clip_xy = bypass_clip_xy;
   draw->driver.bypass_clip_z = bypass_clip_z;
   draw->driver.guard_band_xy = guard_band_xy;
   draw->driver.bypass_clip_points = bypass_clip_points;
   update_clip_flags(draw);
}


/** 
 * Plug in the primitive rendering/rasterization stage (which is the last
 * stage in the drawing pipeline).
 * This is provided by the device driver.
 */
void draw_set_rasterize_stage( struct draw_context *draw,
                               struct draw_stage *stage )
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );

   draw->pipeline.rasterize = stage;
}


/**
 * Set the draw module's clipping state.
 */
void draw_set_clip_state( struct draw_context *draw,
                          const struct pipe_clip_state *clip )
{
   draw_do_flush(draw, DRAW_FLUSH_PARAMETER_CHANGE);

   memcpy(&draw->plane[6], clip->ucp, sizeof(clip->ucp));
}


/**
 * Set the draw module's viewport state.
 */
void draw_set_viewport_states( struct draw_context *draw,
                               unsigned start_slot,
                               unsigned num_viewports,
                               const struct pipe_viewport_state *vps )
{
   const struct pipe_viewport_state *viewport = vps;
   draw_do_flush(draw, DRAW_FLUSH_PARAMETER_CHANGE);

   debug_assert(start_slot < PIPE_MAX_VIEWPORTS);
   debug_assert((start_slot + num_viewports) <= PIPE_MAX_VIEWPORTS);

   memcpy(draw->viewports + start_slot, vps,
          sizeof(struct pipe_viewport_state) * num_viewports);

   draw->identity_viewport = (num_viewports == 1) &&
      (viewport->scale[0] == 1.0f &&
       viewport->scale[1] == 1.0f &&
       viewport->scale[2] == 1.0f &&
       viewport->scale[3] == 1.0f &&
       viewport->translate[0] == 0.0f &&
       viewport->translate[1] == 0.0f &&
       viewport->translate[2] == 0.0f &&
       viewport->translate[3] == 0.0f);
}



void
draw_set_vertex_buffers(struct draw_context *draw,
                        unsigned start_slot, unsigned count,
                        const struct pipe_vertex_buffer *buffers)
{
   assert(start_slot + count <= PIPE_MAX_ATTRIBS);

   util_set_vertex_buffers_count(draw->pt.vertex_buffer,
                                 &draw->pt.nr_vertex_buffers,
                                 buffers, start_slot, count);
}


void
draw_set_vertex_elements(struct draw_context *draw,
                         unsigned count,
                         const struct pipe_vertex_element *elements)
{
   assert(count <= PIPE_MAX_ATTRIBS);

   /* We could improve this by only flushing the frontend and the fetch part
    * of the middle. This would avoid recalculating the emit keys.*/
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );

   memcpy(draw->pt.vertex_element, elements, count * sizeof(elements[0]));
   draw->pt.nr_vertex_elements = count;
}


/**
 * Tell drawing context where to find mapped vertex buffers.
 */
void
draw_set_mapped_vertex_buffer(struct draw_context *draw,
                              unsigned attr, const void *buffer,
                              size_t size)
{
   draw->pt.user.vbuffer[attr].map  = buffer;
   draw->pt.user.vbuffer[attr].size = size;
}


void
draw_set_mapped_constant_buffer(struct draw_context *draw,
                                unsigned shader_type,
                                unsigned slot,
                                const void *buffer,
                                unsigned size )
{
   debug_assert(shader_type == PIPE_SHADER_VERTEX ||
                shader_type == PIPE_SHADER_GEOMETRY);
   debug_assert(slot < PIPE_MAX_CONSTANT_BUFFERS);

   draw_do_flush(draw, DRAW_FLUSH_PARAMETER_CHANGE);

   switch (shader_type) {
   case PIPE_SHADER_VERTEX:
      draw->pt.user.vs_constants[slot] = buffer;
      draw->pt.user.vs_constants_size[slot] = size;
      break;
   case PIPE_SHADER_GEOMETRY:
      draw->pt.user.gs_constants[slot] = buffer;
      draw->pt.user.gs_constants_size[slot] = size;
      break;
   default:
      assert(0 && "invalid shader type in draw_set_mapped_constant_buffer");
   }
}


/**
 * Tells the draw module to draw points with triangles if their size
 * is greater than this threshold.
 */
void
draw_wide_point_threshold(struct draw_context *draw, float threshold)
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
   draw->pipeline.wide_point_threshold = threshold;
}


/**
 * Should the draw module handle point->quad conversion for drawing sprites?
 */
void
draw_wide_point_sprites(struct draw_context *draw, boolean draw_sprite)
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
   draw->pipeline.wide_point_sprites = draw_sprite;
}


/**
 * Tells the draw module to draw lines with triangles if their width
 * is greater than this threshold.
 */
void
draw_wide_line_threshold(struct draw_context *draw, float threshold)
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
   draw->pipeline.wide_line_threshold = roundf(threshold);
}


/**
 * Tells the draw module whether or not to implement line stipple.
 */
void
draw_enable_line_stipple(struct draw_context *draw, boolean enable)
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
   draw->pipeline.line_stipple = enable;
}


/**
 * Tells draw module whether to convert points to quads for sprite mode.
 */
void
draw_enable_point_sprites(struct draw_context *draw, boolean enable)
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
   draw->pipeline.point_sprite = enable;
}


void
draw_set_force_passthrough( struct draw_context *draw, boolean enable )
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
   draw->force_passthrough = enable;
}



/**
 * Allocate an extra vertex/geometry shader vertex attribute, if it doesn't
 * exist already.
 *
 * This is used by some of the optional draw module stages such
 * as wide_point which may need to allocate additional generic/texcoord
 * attributes.
 */
int
draw_alloc_extra_vertex_attrib(struct draw_context *draw,
                               uint semantic_name, uint semantic_index)
{
   int slot;
   uint num_outputs;
   uint n;

   slot = draw_find_shader_output(draw, semantic_name, semantic_index);
   if (slot >= 0) {
      return slot;
   }

   num_outputs = draw_current_shader_outputs(draw);
   n = draw->extra_shader_outputs.num;

   assert(n < Elements(draw->extra_shader_outputs.semantic_name));

   draw->extra_shader_outputs.semantic_name[n] = semantic_name;
   draw->extra_shader_outputs.semantic_index[n] = semantic_index;
   draw->extra_shader_outputs.slot[n] = num_outputs + n;
   draw->extra_shader_outputs.num++;

   return draw->extra_shader_outputs.slot[n];
}


/**
 * Remove all extra vertex attributes that were allocated with
 * draw_alloc_extra_vertex_attrib().
 */
void
draw_remove_extra_vertex_attribs(struct draw_context *draw)
{
   draw->extra_shader_outputs.num = 0;
}


/**
 * If a geometry shader is present, return its info, else the vertex shader's
 * info.
 */
struct tgsi_shader_info *
draw_get_shader_info(const struct draw_context *draw)
{

   if (draw->gs.geometry_shader) {
      return &draw->gs.geometry_shader->info;
   } else {
      return &draw->vs.vertex_shader->info;
   }
}

/**
 * Prepare outputs slots from the draw module
 *
 * Certain parts of the draw module can emit additional
 * outputs that can be quite useful to the backends, a good
 * example of it is the process of decomposing primitives
 * into wireframes (aka. lines) which normally would lose
 * the face-side information, but using this method we can
 * inject another shader output which passes the original
 * face side information to the backend.
 */
void
draw_prepare_shader_outputs(struct draw_context *draw)
{
   draw_remove_extra_vertex_attribs(draw);
   draw_prim_assembler_prepare_outputs(draw->ia);
   draw_unfilled_prepare_outputs(draw, draw->pipeline.unfilled);
   if (draw->pipeline.aapoint)
      draw_aapoint_prepare_outputs(draw, draw->pipeline.aapoint);
   if (draw->pipeline.aaline)
      draw_aaline_prepare_outputs(draw, draw->pipeline.aaline);
}

/**
 * Ask the draw module for the location/slot of the given vertex attribute in
 * a post-transformed vertex.
 *
 * With this function, drivers that use the draw module should have no reason
 * to track the current vertex/geometry shader.
 *
 * Note that the draw module may sometimes generate vertices with extra
 * attributes (such as texcoords for AA lines).  The driver can call this
 * function to find those attributes.
 *
 * -1 is returned if the attribute is not found since this is
 * an undefined situation. Note, that zero is valid and can
 * be used by any of the attributes, because position is not
 * required to be attribute 0 or even at all present.
 */
int
draw_find_shader_output(const struct draw_context *draw,
                        uint semantic_name, uint semantic_index)
{
   const struct tgsi_shader_info *info = draw_get_shader_info(draw);
   uint i;

   for (i = 0; i < info->num_outputs; i++) {
      if (info->output_semantic_name[i] == semantic_name &&
          info->output_semantic_index[i] == semantic_index)
         return i;
   }

   /* Search the extra vertex attributes */
   for (i = 0; i < draw->extra_shader_outputs.num; i++) {
      if (draw->extra_shader_outputs.semantic_name[i] == semantic_name &&
          draw->extra_shader_outputs.semantic_index[i] == semantic_index) {
         return draw->extra_shader_outputs.slot[i];
      }
   }

   return -1;
}


/**
 * Return total number of the shader outputs.  This function is similar to
 * draw_current_shader_outputs() but this function also counts any extra
 * vertex/geometry output attributes that may be filled in by some draw
 * stages (such as AA point, AA line).
 *
 * If geometry shader is present, its output will be returned,
 * if not vertex shader is used.
 */
uint
draw_num_shader_outputs(const struct draw_context *draw)
{
   const struct tgsi_shader_info *info = draw_get_shader_info(draw);
   uint count;

   count = info->num_outputs;
   count += draw->extra_shader_outputs.num;

   return count;
}


/**
 * Return total number of the vertex shader outputs.  This function
 * also counts any extra vertex output attributes that may
 * be filled in by some draw stages (such as AA point, AA line,
 * front face).
 */
uint
draw_total_vs_outputs(const struct draw_context *draw)
{
   const struct tgsi_shader_info *info = &draw->vs.vertex_shader->info;

   return info->num_outputs + draw->extra_shader_outputs.num;;
}

/**
 * Return total number of the geometry shader outputs. This function
 * also counts any extra geometry output attributes that may
 * be filled in by some draw stages (such as AA point, AA line, front
 * face).
 */
uint
draw_total_gs_outputs(const struct draw_context *draw)
{   
   const struct tgsi_shader_info *info;

   if (!draw->gs.geometry_shader)
      return 0;

   info = &draw->gs.geometry_shader->info;

   return info->num_outputs + draw->extra_shader_outputs.num;
}


/**
 * Provide TGSI sampler objects for vertex/geometry shaders that use
 * texture fetches.  This state only needs to be set once per context.
 * This might only be used by software drivers for the time being.
 */
void
draw_texture_sampler(struct draw_context *draw,
                     uint shader,
                     struct tgsi_sampler *sampler)
{
   if (shader == PIPE_SHADER_VERTEX) {
      draw->vs.tgsi.sampler = sampler;
   } else {
      debug_assert(shader == PIPE_SHADER_GEOMETRY);
      draw->gs.tgsi.sampler = sampler;
   }
}




void draw_set_render( struct draw_context *draw, 
		      struct vbuf_render *render )
{
   draw->render = render;
}


/**
 * Tell the draw module where vertex indexes/elements are located, and
 * their size (in bytes).
 *
 * Note: the caller must apply the pipe_index_buffer::offset value to
 * the address.  The draw module doesn't do that.
 */
void
draw_set_indexes(struct draw_context *draw,
                 const void *elements, unsigned elem_size,
                 unsigned elem_buffer_space)
{
   assert(elem_size == 0 ||
          elem_size == 1 ||
          elem_size == 2 ||
          elem_size == 4);
   draw->pt.user.elts = elements;
   draw->pt.user.eltSizeIB = elem_size;
   if (elem_size)
      draw->pt.user.eltMax = elem_buffer_space / elem_size;
   else
      draw->pt.user.eltMax = 0;
}


/* Revamp me please:
 */
void draw_do_flush( struct draw_context *draw, unsigned flags )
{
   if (!draw->suspend_flushing)
   {
      assert(!draw->flushing); /* catch inadvertant recursion */

      draw->flushing = TRUE;

      draw_pipeline_flush( draw, flags );

      draw_pt_flush( draw, flags );

      draw->flushing = FALSE;
   }
}


/**
 * Return the number of output attributes produced by the geometry
 * shader, if present.  If no geometry shader, return the number of
 * outputs from the vertex shader.
 * \sa draw_num_shader_outputs
 */
uint
draw_current_shader_outputs(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.num_gs_outputs;
   return draw->vs.num_vs_outputs;
}


/**
 * Return the index of the shader output which will contain the
 * vertex position.
 */
uint
draw_current_shader_position_output(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.position_output;
   return draw->vs.position_output;
}


/**
 * Return the index of the shader output which will contain the
 * viewport index.
 */
uint
draw_current_shader_viewport_index_output(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->viewport_index_output;
   return 0;
}

/**
 * Returns true if there's a geometry shader bound and the geometry
 * shader writes out a viewport index.
 */
boolean
draw_current_shader_uses_viewport_index(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->info.writes_viewport_index;
   return FALSE;
}


/**
 * Return the index of the shader output which will contain the
 * vertex position.
 */
uint
draw_current_shader_clipvertex_output(const struct draw_context *draw)
{
   return draw->vs.clipvertex_output;
}

uint
draw_current_shader_clipdistance_output(const struct draw_context *draw, int index)
{
   debug_assert(index < PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT);
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->clipdistance_output[index];
   return draw->vs.clipdistance_output[index];
}


uint
draw_current_shader_num_written_clipdistances(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->info.num_written_clipdistance;
   return draw->vs.vertex_shader->info.num_written_clipdistance;
}


uint
draw_current_shader_culldistance_output(const struct draw_context *draw, int index)
{
   debug_assert(index < PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT);
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->culldistance_output[index];
   return draw->vs.vertex_shader->culldistance_output[index];
}

uint
draw_current_shader_num_written_culldistances(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->info.num_written_culldistance;
   return draw->vs.vertex_shader->info.num_written_culldistance;
}

/**
 * Return a pointer/handle for a driver/CSO rasterizer object which
 * disabled culling, stippling, unfilled tris, etc.
 * This is used by some pipeline stages (such as wide_point, aa_line
 * and aa_point) which convert points/lines into triangles.  In those
 * cases we don't want to accidentally cull the triangles.
 *
 * \param scissor  should the rasterizer state enable scissoring?
 * \param flatshade  should the rasterizer state use flat shading?
 * \return  rasterizer CSO handle
 */
void *
draw_get_rasterizer_no_cull( struct draw_context *draw,
                             boolean scissor,
                             boolean flatshade )
{
   if (!draw->rasterizer_no_cull[scissor][flatshade]) {
      /* create now */
      struct pipe_context *pipe = draw->pipe;
      struct pipe_rasterizer_state rast;

      memset(&rast, 0, sizeof(rast));
      rast.scissor = scissor;
      rast.flatshade = flatshade;
      rast.front_ccw = 1;
      rast.half_pixel_center = draw->rasterizer->half_pixel_center;
      rast.bottom_edge_rule = draw->rasterizer->bottom_edge_rule;
      rast.clip_halfz = draw->rasterizer->clip_halfz;

      draw->rasterizer_no_cull[scissor][flatshade] =
         pipe->create_rasterizer_state(pipe, &rast);
   }
   return draw->rasterizer_no_cull[scissor][flatshade];
}

void
draw_set_mapped_so_targets(struct draw_context *draw,
                           int num_targets,
                           struct draw_so_target *targets[PIPE_MAX_SO_BUFFERS])
{
   int i;

   for (i = 0; i < num_targets; i++)
      draw->so.targets[i] = targets[i];
   for (i = num_targets; i < PIPE_MAX_SO_BUFFERS; i++)
      draw->so.targets[i] = NULL;

   draw->so.num_targets = num_targets;
}

void
draw_set_sampler_views(struct draw_context *draw,
                       unsigned shader_stage,
                       struct pipe_sampler_view **views,
                       unsigned num)
{
   unsigned i;

   debug_assert(shader_stage < PIPE_SHADER_TYPES);
   debug_assert(num <= PIPE_MAX_SHADER_SAMPLER_VIEWS);

   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );

   for (i = 0; i < num; ++i)
      draw->sampler_views[shader_stage][i] = views[i];
   for (i = num; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; ++i)
      draw->sampler_views[shader_stage][i] = NULL;

   draw->num_sampler_views[shader_stage] = num;
}

void
draw_set_samplers(struct draw_context *draw,
                  unsigned shader_stage,
                  struct pipe_sampler_state **samplers,
                  unsigned num)
{
   unsigned i;

   debug_assert(shader_stage < PIPE_SHADER_TYPES);
   debug_assert(num <= PIPE_MAX_SAMPLERS);

   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );

   for (i = 0; i < num; ++i)
      draw->samplers[shader_stage][i] = samplers[i];
   for (i = num; i < PIPE_MAX_SAMPLERS; ++i)
      draw->samplers[shader_stage][i] = NULL;

   draw->num_samplers[shader_stage] = num;

#ifdef HAVE_LLVM
   if (draw->llvm)
      draw_llvm_set_sampler_state(draw, shader_stage);
#endif
}

void
draw_set_mapped_texture(struct draw_context *draw,
                        unsigned shader_stage,
                        unsigned sview_idx,
                        uint32_t width, uint32_t height, uint32_t depth,
                        uint32_t first_level, uint32_t last_level,
                        const void *base_ptr,
                        uint32_t row_stride[PIPE_MAX_TEXTURE_LEVELS],
                        uint32_t img_stride[PIPE_MAX_TEXTURE_LEVELS],
                        uint32_t mip_offsets[PIPE_MAX_TEXTURE_LEVELS])
{
#ifdef HAVE_LLVM
   if (draw->llvm)
      draw_llvm_set_mapped_texture(draw,
                                   shader_stage,
                                   sview_idx,
                                   width, height, depth, first_level,
                                   last_level, base_ptr,
                                   row_stride, img_stride, mip_offsets);
#endif
}

/**
 * XXX: Results for PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS because there are two
 * different ways of setting textures, and drivers typically only support one.
 */
int
draw_get_shader_param_no_llvm(unsigned shader, enum pipe_shader_cap param)
{
   switch(shader) {
   case PIPE_SHADER_VERTEX:
   case PIPE_SHADER_GEOMETRY:
      return tgsi_exec_get_shader_param(param);
   default:
      return 0;
   }
}

/**
 * XXX: Results for PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS because there are two
 * different ways of setting textures, and drivers typically only support one.
 * Drivers requesting a draw context explicitly without llvm must call
 * draw_get_shader_param_no_llvm instead.
 */
int
draw_get_shader_param(unsigned shader, enum pipe_shader_cap param)
{

#ifdef HAVE_LLVM
   if (draw_get_option_use_llvm()) {
      switch(shader) {
      case PIPE_SHADER_VERTEX:
      case PIPE_SHADER_GEOMETRY:
         return gallivm_get_shader_param(param);
      default:
         return 0;
      }
   }
#endif

   return draw_get_shader_param_no_llvm(shader, param);
}

/**
 * Enables or disables collection of statistics.
 *
 * Draw module is capable of generating statistics for the vertex
 * processing pipeline. Collection of that data isn't free and so
 * it's disabled by default. The users of the module can enable
 * (or disable) this functionality through this function.
 * The actual data will be emitted through the VBUF interface,
 * the 'pipeline_statistics' callback to be exact.
 */
void
draw_collect_pipeline_statistics(struct draw_context *draw,
                                 boolean enable)
{
   draw->collect_statistics = enable;
}

/**
 * Computes clipper invocation statistics.
 *
 * Figures out how many primitives would have been
 * sent to the clipper given the specified
 * prim info data.
 */
void
draw_stats_clipper_primitives(struct draw_context *draw,
                              const struct draw_prim_info *prim_info)
{
   if (draw->collect_statistics) {
      unsigned i;
      for (i = 0; i < prim_info->primitive_count; i++) {
         draw->statistics.c_invocations +=
            u_decomposed_prims_for_vertices(prim_info->prim,
                                            prim_info->primitive_lengths[i]);
      }
   }
}


/**
 * Returns true if the draw module will inject the frontface
 * info into the outputs.
 *
 * Given the specified primitive and rasterizer state
 * the function will figure out if the draw module
 * will inject the front-face information into shader
 * outputs. This is done to preserve the front-facing
 * info when decomposing primitives into wireframes.
 */
boolean
draw_will_inject_frontface(const struct draw_context *draw)
{
   unsigned reduced_prim = u_reduced_prim(draw->pt.prim);
   const struct pipe_rasterizer_state *rast = draw->rasterizer;

   if (reduced_prim != PIPE_PRIM_TRIANGLES) {
      return FALSE;
   }

   return (rast &&
           (rast->fill_front != PIPE_POLYGON_MODE_FILL ||
            rast->fill_back != PIPE_POLYGON_MODE_FILL));
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d84 1
a84 2
draw_create_context(struct pipe_context *pipe, void *context,
                    boolean try_llvm)
d95 3
a97 1
      draw->llvm = draw_llvm_create(draw, (LLVMContextRef)context);
d125 1
a125 1
   return draw_create_context(pipe, NULL, TRUE);
a128 9
#if HAVE_LLVM
struct draw_context *
draw_create_with_llvm_context(struct pipe_context *pipe,
                              void *context)
{
   return draw_create_context(pipe, context, TRUE);
}
#endif

d135 1
a135 1
   return draw_create_context(pipe, NULL, FALSE);
d821 1
a821 3
 * clip vertex position.
 * Note we don't support clipvertex output in the gs. For clipping
 * to work correctly hence we return ordinary position output instead.
a825 2
   if (draw->gs.geometry_shader)
      return draw->gs.position_output;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d84 2
a85 1
draw_create_context(struct pipe_context *pipe, boolean try_llvm)
d96 1
a96 3
      draw->llvm = draw_llvm_create(draw);
      if (!draw->llvm)
         goto err_destroy;
d124 1
a124 1
   return draw_create_context(pipe, TRUE);
d128 9
d143 1
a143 1
   return draw_create_context(pipe, FALSE);
d829 3
a831 1
 * vertex position.
d836 2
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d41 1
d43 2
d71 6
d106 4
d174 2
d223 1
d245 2
a246 1
 * Specify the Minimum Resolvable Depth factor for polygon offset.
d249 1
a249 2
 * values between vertex shading and rasterization.  It will vary
 * from one driver to another.
d251 1
a251 1
void draw_set_mrd(struct draw_context *draw, double mrd)
d253 6
a258 1
   draw->mrd = mrd;
d271 4
d300 4
d308 2
a309 1
                               boolean guard_band_xy)
d316 1
d574 22
d661 34
d1003 2
d1054 2
a1055 5
      unsigned start, i;
      for (start = i = 0;
           i < prim_info->primitive_count;
           start += prim_info->primitive_lengths[i], i++)
      {
d1061 26
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d39 2
d47 1
d50 1
a50 1
static boolean
d61 1
a61 1
      /* require SSE2 due to LLVM PR6960. */
a70 12

/**
 * Create new draw module context.
 */
struct draw_context *
draw_create(struct pipe_context *pipe)
{
   return draw_create_gallivm(pipe, NULL);
}



d74 2
a75 2
struct draw_context *
draw_create_gallivm(struct pipe_context *pipe, struct gallivm_state *gallivm)
d79 4
a82 1
      goto fail;
d85 4
a88 8
   if (draw_get_option_use_llvm()) {
      if (!gallivm) {
         gallivm = gallivm_create();
         draw->own_gallivm = gallivm;
      }

      if (gallivm)
         draw->llvm = draw_llvm_create(draw, gallivm);
d92 2
d95 1
a95 3
      goto fail;

   draw->pipe = pipe;
d99 1
a99 1
fail:
d101 1
d106 19
a139 1
   draw->nr_planes = 6;
d143 2
a144 3

   draw->reduced_prim = ~0; /* != any of PIPE_PRIM_x */

d158 3
d164 13
d181 1
a181 1
   int i, j;
a214 3

   if (draw->own_gallivm)
      gallivm_destroy(draw->own_gallivm);
d244 2
d247 3
a249 2
                   !draw->depth_clamp);
   draw->clip_user = (draw->nr_planes > 6);
d265 2
a266 2

  }
d278 2
a279 1
                               boolean bypass_clip_z )
d285 1
d310 1
a310 1
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
d312 1
a312 6
   assert(clip->nr <= PIPE_MAX_CLIP_PLANES);
   memcpy(&draw->plane[6], clip->ucp, clip->nr * sizeof(clip->ucp[0]));
   draw->nr_planes = 6 + clip->nr;
   draw->depth_clamp = clip->depth_clamp;

   update_clip_flags(draw);
d319 23
a341 15
void draw_set_viewport_state( struct draw_context *draw,
                              const struct pipe_viewport_state *viewport )
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
   draw->viewport = *viewport; /* struct copy */
   draw->identity_viewport = (viewport->scale[0] == 1.0f &&
                              viewport->scale[1] == 1.0f &&
                              viewport->scale[2] == 1.0f &&
                              viewport->scale[3] == 1.0f &&
                              viewport->translate[0] == 0.0f &&
                              viewport->translate[1] == 0.0f &&
                              viewport->translate[2] == 0.0f &&
                              viewport->translate[3] == 0.0f);

   draw_vs_set_viewport( draw, viewport );
d348 1
a348 1
                        unsigned count,
d351 1
a351 1
   assert(count <= PIPE_MAX_ATTRIBS);
d353 3
a355 3
   util_copy_vertex_buffers(draw->pt.vertex_buffer,
                            &draw->pt.nr_vertex_buffers,
                            buffers, count);
d366 4
d380 2
a381 1
                              unsigned attr, const void *buffer)
d383 2
a384 1
   draw->pt.user.vbuffer[attr] = buffer;
d399 2
a404 2
      draw->pt.user.planes = (float (*) [12][4]) &(draw->plane[0]);
      draw_vs_set_constants(draw, slot, buffer, size);
a408 1
      draw_gs_set_constants(draw, slot, buffer, size);
d483 3
a485 1
 * Allocate an extra vertex/geometry shader vertex attribute.
d494 11
a504 2
   const int num_outputs = draw_current_shader_outputs(draw);
   const int n = draw->extra_shader_outputs.num;
d529 16
d555 4
a558 3
 * Zero is returned if the attribute is not found since this is
 * a don't care / undefined situtation.  Returning -1 would be a bit more
 * work for the drivers.
d564 1
a564 2
   const struct draw_vertex_shader *vs = draw->vs.vertex_shader;
   const struct draw_geometry_shader *gs = draw->gs.geometry_shader;
a565 4
   const struct tgsi_shader_info *info = &vs->info;

   if (gs)
      info = &gs->info;
d581 1
a581 1
   return 0;
d597 1
d600 1
a600 8
   /* If a geometry shader is present, its outputs go to the
    * driver, else the vertex shader's outputs.
    */
   if (draw->gs.geometry_shader)
      count = draw->gs.geometry_shader->info.num_outputs;
   else
      count = draw->vs.vertex_shader->info.num_outputs;

d609 1
a609 1
 * texture fetches.
d613 3
a615 4
draw_texture_samplers(struct draw_context *draw,
                      uint shader,
                      uint num_samplers,
                      struct tgsi_sampler **samplers)
d618 1
a618 2
      draw->vs.num_samplers = num_samplers;
      draw->vs.samplers = samplers;
d621 1
a621 2
      draw->gs.num_samplers = num_samplers;
      draw->gs.samplers = samplers;
a634 11
void
draw_set_index_buffer(struct draw_context *draw,
                      const struct pipe_index_buffer *ib)
{
   if (ib)
      memcpy(&draw->pt.index_buffer, ib, sizeof(draw->pt.index_buffer));
   else
      memset(&draw->pt.index_buffer, 0, sizeof(draw->pt.index_buffer));
}


d636 5
a640 1
 * Tell drawing context where to find mapped index/element buffer.
d643 14
a656 4
draw_set_mapped_index_buffer(struct draw_context *draw,
                             const void *elements)
{
    draw->pt.user.elts = elements;
d672 2
a673 2
      draw->reduced_prim = ~0; /* is reduced_prim needed any more? */
      
d708 71
d803 3
a805 1
      rast.gl_rasterization_rules = draw->rasterizer->gl_rasterization_rules;
d814 3
a816 3
draw_set_mapped_so_buffers(struct draw_context *draw,
                           void *buffers[PIPE_MAX_SO_BUFFERS],
                           unsigned num_buffers)
d820 4
a823 5
   for (i = 0; i < num_buffers; ++i) {
      draw->so.buffers[i] = buffers[i];
   }
   draw->so.num_buffers = num_buffers;
}
d825 1
a825 7
void
draw_set_so_state(struct draw_context *draw,
                  struct pipe_stream_output_state *state)
{
   memcpy(&draw->so.state,
          state,
          sizeof(struct pipe_stream_output_state));
d830 1
d836 4
a839 1
   debug_assert(num <= PIPE_MAX_VERTEX_SAMPLERS);
d842 3
a844 3
      draw->sampler_views[i] = views[i];
   for (i = num; i < PIPE_MAX_VERTEX_SAMPLERS; ++i)
      draw->sampler_views[i] = NULL;
d846 1
a846 1
   draw->num_sampler_views = num;
d851 1
d857 4
a860 1
   debug_assert(num <= PIPE_MAX_VERTEX_SAMPLERS);
d863 3
a865 3
      draw->samplers[i] = samplers[i];
   for (i = num; i < PIPE_MAX_VERTEX_SAMPLERS; ++i)
      draw->samplers[i] = NULL;
d867 1
a867 1
   draw->num_samplers = num;
d871 1
a871 1
      draw_llvm_set_sampler_state(draw);
d877 2
a878 1
                        unsigned sampler_idx,
d881 1
d884 1
a884 1
                        const void *data[PIPE_MAX_TEXTURE_LEVELS])
d887 1
a887 1
   if(draw->llvm)
d889 5
a893 3
                                sampler_idx,
                                width, height, depth, first_level, last_level,
                                row_stride, img_stride, data);
d895 80
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d38 1
d91 8
a98 2
   if (draw_get_option_use_llvm() && gallivm) {
      draw->llvm = draw_llvm_create(draw, gallivm);
d131 2
a132 2
   draw->clip_xy = 1;
   draw->clip_z = 1;
d174 4
d189 1
a189 1
   if(draw->llvm)
d191 3
d324 3
a326 2
   memcpy(draw->pt.vertex_buffer, buffers, count * sizeof(buffers[0]));
   draw->pt.nr_vertex_buffers = count;
d413 1
a413 1
   draw->pipeline.wide_line_threshold = threshold;
d754 1
a754 1
                        uint32_t last_level,
d763 1
a763 1
                                width, height, depth, last_level,
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d37 1
d42 25
d68 16
a83 1
struct draw_context *draw_create( struct pipe_context *pipe )
d89 28
d124 2
d132 1
a132 1
      goto fail;
d135 1
a135 1
      goto fail;
d138 1
a138 1
      goto fail;
d141 1
a141 3
      goto fail;

   draw->pipe = pipe;
d143 1
a143 5
   return draw;

fail:
   draw_destroy( draw );   
   return NULL;
d149 1
a149 1
   struct pipe_context *pipe = draw->pipe;
d155 2
d177 4
d206 8
d228 1
a228 2
      draw->bypass_clipping = draw->driver.bypass_clipping;
   }
d231 7
a237 1

d239 2
a240 1
                               boolean bypass_clipping )
d244 3
a246 2
   draw->driver.bypass_clipping = bypass_clipping;
   draw->bypass_clipping = draw->driver.bypass_clipping;
d275 3
d349 2
a350 1
   if (shader_type == PIPE_SHADER_VERTEX) {
d352 2
d355 2
a356 1
   } else if (shader_type == PIPE_SHADER_GEOMETRY) {
d358 1
d360 3
d380 11
d432 36
d501 6
a506 6
   /* XXX there may be more than one extra vertex attrib.
    * For example, simulated gl_FragCoord and gl_PointCoord.
    */
   if (draw->extra_shader_outputs.semantic_name == semantic_name &&
       draw->extra_shader_outputs.semantic_index == semantic_index) {
      return draw->extra_shader_outputs.slot;
d525 1
a525 1
   uint count = draw->vs.vertex_shader->info.num_outputs;
d532 4
a536 2
   if (draw->extra_shader_outputs.slot > 0)
      count++;
d548 1
d552 8
a559 4
   draw->vs.num_samplers = num_samplers;
   draw->vs.samplers = samplers;
   draw->gs.num_samplers = num_samplers;
   draw->gs.samplers = samplers;
a571 11

/**
 * Tell the drawing context about the index/element buffer to use
 * (ala glDrawElements)
 * If no element buffer is to be used (i.e. glDrawArrays) then this
 * should be called with eltSize=0 and elements=NULL.
 *
 * \param draw  the drawing context
 * \param eltSize  size of each element (1, 2 or 4 bytes)
 * \param elements  the element buffer ptr
 */
d573 2
a574 5
draw_set_mapped_element_buffer_range( struct draw_context *draw,
                                      unsigned eltSize,
                                      unsigned min_index,
                                      unsigned max_index,
                                      const void *elements )
d576 4
a579 4
   draw->pt.user.elts = elements;
   draw->pt.user.eltSize = eltSize;
   draw->pt.user.min_index = min_index;
   draw->pt.user.max_index = max_index;
d583 3
d587 2
a588 3
draw_set_mapped_element_buffer( struct draw_context *draw,
                                unsigned eltSize,
                                const void *elements )
d590 1
a590 4
   draw->pt.user.elts = elements;
   draw->pt.user.eltSize = eltSize;
   draw->pt.user.min_index = 0;
   draw->pt.user.max_index = 0xffffffff;
d593 1
a593 1
 
d665 1
a665 1
      rast.front_winding = PIPE_WINDING_CCW;
d672 79
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a36 1
#include "util/u_cpu_detect.h"
a40 25
#if HAVE_LLVM
#include "gallivm/lp_bld_init.h"
#include "draw_llvm.h"

static boolean
draw_get_option_use_llvm(void)
{
   static boolean first = TRUE;
   static boolean value;
   if (first) {
      first = FALSE;
      value = debug_get_bool_option("DRAW_USE_LLVM", TRUE);

#ifdef PIPE_ARCH_X86
      util_cpu_detect();
      /* require SSE2 due to LLVM PR6960. */
      if (!util_cpu_caps.has_sse2)
         value = FALSE;
#endif
   }
   return value;
}
#endif


d42 1
a42 16
/**
 * Create new draw module context.
 */
struct draw_context *
draw_create(struct pipe_context *pipe)
{
   return draw_create_gallivm(pipe, NULL);
}



/**
 * Create new draw module context with gallivm state for LLVM JIT.
 */
struct draw_context *
draw_create_gallivm(struct pipe_context *pipe, struct gallivm_state *gallivm)
a47 28
#if HAVE_LLVM
   if (draw_get_option_use_llvm() && gallivm) {
      draw->llvm = draw_llvm_create(draw, gallivm);
   }
#endif

   if (!draw_init(draw))
      goto fail;

   draw->pipe = pipe;

   return draw;

fail:
   draw_destroy( draw );
   return NULL;
}



boolean draw_init(struct draw_context *draw)
{
   /*
    * Note that several functions compute the clipmask of the predefined
    * formats with hardcoded formulas instead of using these. So modifications
    * here must be reflected there too.
    */

a54 2
   draw->clip_xy = 1;
   draw->clip_z = 1;
d61 1
a61 1
      return FALSE;
d64 1
a64 1
      return FALSE;
d67 1
a67 1
      return FALSE;
d70 3
a72 1
      return FALSE;
d74 5
a78 1
   return TRUE;
d84 1
a84 1
   struct pipe_context *pipe;
a89 2
   pipe = draw->pipe;

a109 4
#ifdef HAVE_LLVM
   if(draw->llvm)
      draw_llvm_destroy( draw->llvm );
#endif
a134 8
static void update_clip_flags( struct draw_context *draw )
{
   draw->clip_xy = !draw->driver.bypass_clip_xy;
   draw->clip_z = (!draw->driver.bypass_clip_z &&
                   !draw->depth_clamp);
   draw->clip_user = (draw->nr_planes > 6);
}

d149 2
a150 1
  }
d153 1
a153 7
/* With a little more work, llvmpipe will be able to turn this off and
 * do its own x/y clipping.  
 *
 * Some hardware can turn off clipping altogether - in particular any
 * hardware with a TNL unit can do its own clipping, even if it is
 * relying on the draw module for some other reason.
 */
d155 1
a155 2
                               boolean bypass_clip_xy,
                               boolean bypass_clip_z )
d159 2
a160 3
   draw->driver.bypass_clip_xy = bypass_clip_xy;
   draw->driver.bypass_clip_z = bypass_clip_z;
   update_clip_flags(draw);
a188 3
   draw->depth_clamp = clip->depth_clamp;

   update_clip_flags(draw);
d260 1
a260 2
   switch (shader_type) {
   case PIPE_SHADER_VERTEX:
a261 2
      draw->pt.user.vs_constants_size[slot] = size;
      draw->pt.user.planes = (float (*) [12][4]) &(draw->plane[0]);
d263 1
a263 2
      break;
   case PIPE_SHADER_GEOMETRY:
a264 1
      draw->pt.user.gs_constants_size[slot] = size;
a265 3
      break;
   default:
      assert(0 && "invalid shader type in draw_set_mapped_constant_buffer");
a282 11
 * Should the draw module handle point->quad conversion for drawing sprites?
 */
void
draw_wide_point_sprites(struct draw_context *draw, boolean draw_sprite)
{
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
   draw->pipeline.wide_point_sprites = draw_sprite;
}


/**
a323 36

/**
 * Allocate an extra vertex/geometry shader vertex attribute.
 * This is used by some of the optional draw module stages such
 * as wide_point which may need to allocate additional generic/texcoord
 * attributes.
 */
int
draw_alloc_extra_vertex_attrib(struct draw_context *draw,
                               uint semantic_name, uint semantic_index)
{
   const int num_outputs = draw_current_shader_outputs(draw);
   const int n = draw->extra_shader_outputs.num;

   assert(n < Elements(draw->extra_shader_outputs.semantic_name));

   draw->extra_shader_outputs.semantic_name[n] = semantic_name;
   draw->extra_shader_outputs.semantic_index[n] = semantic_index;
   draw->extra_shader_outputs.slot[n] = num_outputs + n;
   draw->extra_shader_outputs.num++;

   return draw->extra_shader_outputs.slot[n];
}


/**
 * Remove all extra vertex attributes that were allocated with
 * draw_alloc_extra_vertex_attrib().
 */
void
draw_remove_extra_vertex_attribs(struct draw_context *draw)
{
   draw->extra_shader_outputs.num = 0;
}


d357 6
a362 6
   /* Search the extra vertex attributes */
   for (i = 0; i < draw->extra_shader_outputs.num; i++) {
      if (draw->extra_shader_outputs.semantic_name[i] == semantic_name &&
          draw->extra_shader_outputs.semantic_index[i] == semantic_index) {
         return draw->extra_shader_outputs.slot[i];
      }
d381 1
a381 1
   uint count;
a387 4
   else
      count = draw->vs.vertex_shader->info.num_outputs;

   count += draw->extra_shader_outputs.num;
d389 2
a401 1
                      uint shader,
d405 4
a408 8
   if (shader == PIPE_SHADER_VERTEX) {
      draw->vs.num_samplers = num_samplers;
      draw->vs.samplers = samplers;
   } else {
      debug_assert(shader == PIPE_SHADER_GEOMETRY);
      draw->gs.num_samplers = num_samplers;
      draw->gs.samplers = samplers;
   }
d421 11
d433 5
a437 2
draw_set_index_buffer(struct draw_context *draw,
                      const struct pipe_index_buffer *ib)
d439 4
a442 4
   if (ib)
      memcpy(&draw->pt.index_buffer, ib, sizeof(draw->pt.index_buffer));
   else
      memset(&draw->pt.index_buffer, 0, sizeof(draw->pt.index_buffer));
a445 3
/**
 * Tell drawing context where to find mapped index/element buffer.
 */
d447 3
a449 2
draw_set_mapped_index_buffer(struct draw_context *draw,
                             const void *elements)
d451 4
a454 1
    draw->pt.user.elts = elements;
d457 1
a457 1

d529 1
a529 1
      rast.front_ccw = 1;
a535 79
}

void
draw_set_mapped_so_buffers(struct draw_context *draw,
                           void *buffers[PIPE_MAX_SO_BUFFERS],
                           unsigned num_buffers)
{
   int i;

   for (i = 0; i < num_buffers; ++i) {
      draw->so.buffers[i] = buffers[i];
   }
   draw->so.num_buffers = num_buffers;
}

void
draw_set_so_state(struct draw_context *draw,
                  struct pipe_stream_output_state *state)
{
   memcpy(&draw->so.state,
          state,
          sizeof(struct pipe_stream_output_state));
}

void
draw_set_sampler_views(struct draw_context *draw,
                       struct pipe_sampler_view **views,
                       unsigned num)
{
   unsigned i;

   debug_assert(num <= PIPE_MAX_VERTEX_SAMPLERS);

   for (i = 0; i < num; ++i)
      draw->sampler_views[i] = views[i];
   for (i = num; i < PIPE_MAX_VERTEX_SAMPLERS; ++i)
      draw->sampler_views[i] = NULL;

   draw->num_sampler_views = num;
}

void
draw_set_samplers(struct draw_context *draw,
                  struct pipe_sampler_state **samplers,
                  unsigned num)
{
   unsigned i;

   debug_assert(num <= PIPE_MAX_VERTEX_SAMPLERS);

   for (i = 0; i < num; ++i)
      draw->samplers[i] = samplers[i];
   for (i = num; i < PIPE_MAX_VERTEX_SAMPLERS; ++i)
      draw->samplers[i] = NULL;

   draw->num_samplers = num;

#ifdef HAVE_LLVM
   if (draw->llvm)
      draw_llvm_set_sampler_state(draw);
#endif
}

void
draw_set_mapped_texture(struct draw_context *draw,
                        unsigned sampler_idx,
                        uint32_t width, uint32_t height, uint32_t depth,
                        uint32_t last_level,
                        uint32_t row_stride[PIPE_MAX_TEXTURE_LEVELS],
                        uint32_t img_stride[PIPE_MAX_TEXTURE_LEVELS],
                        const void *data[PIPE_MAX_TEXTURE_LEVELS])
{
#ifdef HAVE_LLVM
   if(draw->llvm)
      draw_llvm_set_mapped_texture(draw,
                                sampler_idx,
                                width, height, depth, last_level,
                                row_stride, img_stride, data);
#endif
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a37 3
#include "util/u_inlines.h"
#include "util/u_helpers.h"
#include "util/u_prim.h"
a43 1
#include "gallivm/lp_bld_limits.h"
d46 1
a46 1
boolean
d57 1
a57 1
      /* require SSE2 due to LLVM PR6960. XXX Might be fixed by now? */
d67 12
d82 2
a83 2
static struct draw_context *
draw_create_context(struct pipe_context *pipe, boolean try_llvm)
d87 1
a87 4
      goto err_out;

   /* we need correct cpu caps for disabling denorms in draw_vbo() */
   util_cpu_detect();
d90 2
a91 4
   if (try_llvm && draw_get_option_use_llvm()) {
      draw->llvm = draw_llvm_create(draw);
      if (!draw->llvm)
         goto err_destroy;
d95 3
a99 3
   if (!draw_init(draw))
      goto err_destroy;

d102 1
a102 1
err_destroy:
a103 1
err_out:
a107 19
/**
 * Create new draw module context, with LLVM JIT.
 */
struct draw_context *
draw_create(struct pipe_context *pipe)
{
   return draw_create_context(pipe, TRUE);
}


/**
 * Create a new draw context, without LLVM JIT.
 */
struct draw_context *
draw_create_no_llvm(struct pipe_context *pipe)
{
   return draw_create_context(pipe, FALSE);
}

d123 6
a128 2
   draw->clip_xy = TRUE;
   draw->clip_z = TRUE;
a129 2
   draw->pt.user.planes = (float (*) [DRAW_TOTAL_CLIP_PLANES][4]) &(draw->plane[0]);
   draw->pt.user.eltMax = ~0;
a142 3
   draw->quads_always_flatshade_last = !draw->pipe->screen->get_param(
      draw->pipe->screen, PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION);

a145 13
/*
 * Called whenever we're starting to draw a new instance.
 * Some internal structures don't want to have to reset internal
 * members on each invocation (because their state might have to persist
 * between multiple primitive restart rendering call) but might have to 
 * for each new instance. 
 * This is particularly the case for primitive id's in geometry shader.
 */
void draw_new_instance(struct draw_context *draw)
{
   draw_geometry_shader_new_instance(draw->gs.geometry_shader);
}

d150 1
a150 1
   unsigned i, j;
a166 4
   for (i = 0; i < draw->pt.nr_vertex_buffers; i++) {
      pipe_resource_reference(&draw->pt.vertex_buffer[i].buffer, NULL);
   }

d178 1
a178 1
   if (draw->llvm)
a208 2
   draw->guard_band_xy = (!draw->driver.bypass_clip_xy &&
                          draw->driver.guard_band_xy);
d210 2
a211 3
                   draw->rasterizer && draw->rasterizer->depth_clip);
   draw->clip_user = draw->rasterizer &&
                     draw->rasterizer->clip_plane_enable != 0;
d227 2
a228 2
      update_clip_flags(draw);
   }
d240 1
a240 2
                               boolean bypass_clip_z,
                               boolean guard_band_xy)
a245 1
   draw->driver.guard_band_xy = guard_band_xy;
d270 1
a270 1
   draw_do_flush(draw, DRAW_FLUSH_PARAMETER_CHANGE);
d272 6
a277 1
   memcpy(&draw->plane[6], clip->ucp, sizeof(clip->ucp));
d284 15
a298 23
void draw_set_viewport_states( struct draw_context *draw,
                               unsigned start_slot,
                               unsigned num_viewports,
                               const struct pipe_viewport_state *vps )
{
   const struct pipe_viewport_state *viewport = vps;
   draw_do_flush(draw, DRAW_FLUSH_PARAMETER_CHANGE);

   debug_assert(start_slot < PIPE_MAX_VIEWPORTS);
   debug_assert((start_slot + num_viewports) <= PIPE_MAX_VIEWPORTS);

   memcpy(draw->viewports + start_slot, vps,
          sizeof(struct pipe_viewport_state) * num_viewports);

   draw->identity_viewport = (num_viewports == 1) &&
      (viewport->scale[0] == 1.0f &&
       viewport->scale[1] == 1.0f &&
       viewport->scale[2] == 1.0f &&
       viewport->scale[3] == 1.0f &&
       viewport->translate[0] == 0.0f &&
       viewport->translate[1] == 0.0f &&
       viewport->translate[2] == 0.0f &&
       viewport->translate[3] == 0.0f);
d305 1
a305 1
                        unsigned start_slot, unsigned count,
d308 1
a308 1
   assert(start_slot + count <= PIPE_MAX_ATTRIBS);
d310 2
a311 3
   util_set_vertex_buffers_count(draw->pt.vertex_buffer,
                                 &draw->pt.nr_vertex_buffers,
                                 buffers, start_slot, count);
a321 4
   /* We could improve this by only flushing the frontend and the fetch part
    * of the middle. This would avoid recalculating the emit keys.*/
   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );

d332 1
a332 2
                              unsigned attr, const void *buffer,
                              size_t size)
d334 1
a334 2
   draw->pt.user.vbuffer[attr].map  = buffer;
   draw->pt.user.vbuffer[attr].size = size;
a348 2
   draw_do_flush(draw, DRAW_FLUSH_PARAMETER_CHANGE);

d353 2
d359 1
d398 1
a398 1
   draw->pipeline.wide_line_threshold = roundf(threshold);
d434 1
a434 3
 * Allocate an extra vertex/geometry shader vertex attribute, if it doesn't
 * exist already.
 *
d443 2
a444 11
   int slot;
   uint num_outputs;
   uint n;

   slot = draw_find_shader_output(draw, semantic_name, semantic_index);
   if (slot >= 0) {
      return slot;
   }

   num_outputs = draw_current_shader_outputs(draw);
   n = draw->extra_shader_outputs.num;
a468 16
 * If a geometry shader is present, return its info, else the vertex shader's
 * info.
 */
struct tgsi_shader_info *
draw_get_shader_info(const struct draw_context *draw)
{

   if (draw->gs.geometry_shader) {
      return &draw->gs.geometry_shader->info;
   } else {
      return &draw->vs.vertex_shader->info;
   }
}


/**
d479 3
a481 4
 * -1 is returned if the attribute is not found since this is
 * an undefined situation. Note, that zero is valid and can
 * be used by any of the attributes, because position is not
 * required to be attribute 0 or even at all present.
d487 2
a488 1
   const struct tgsi_shader_info *info = draw_get_shader_info(draw);
d490 4
d509 1
a509 1
   return -1;
a524 1
   const struct tgsi_shader_info *info = draw_get_shader_info(draw);
d527 8
a534 1
   count = info->num_outputs;
d543 1
a543 1
 * texture fetches.  This state only needs to be set once per context.
d547 4
a550 3
draw_texture_sampler(struct draw_context *draw,
                     uint shader,
                     struct tgsi_sampler *sampler)
d553 2
a554 1
      draw->vs.tgsi.sampler = sampler;
d557 2
a558 1
      draw->gs.tgsi.sampler = sampler;
d572 11
d584 1
a584 5
 * Tell the draw module where vertex indexes/elements are located, and
 * their size (in bytes).
 *
 * Note: the caller must apply the pipe_index_buffer::offset value to
 * the address.  The draw module doesn't do that.
d587 4
a590 14
draw_set_indexes(struct draw_context *draw,
                 const void *elements, unsigned elem_size,
                 unsigned elem_buffer_space)
{
   assert(elem_size == 0 ||
          elem_size == 1 ||
          elem_size == 2 ||
          elem_size == 4);
   draw->pt.user.elts = elements;
   draw->pt.user.eltSizeIB = elem_size;
   if (elem_size)
      draw->pt.user.eltMax = elem_buffer_space / elem_size;
   else
      draw->pt.user.eltMax = 0;
d606 2
a607 2
      draw_pt_flush( draw, flags );

a641 71
 * Return the index of the shader output which will contain the
 * viewport index.
 */
uint
draw_current_shader_viewport_index_output(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->viewport_index_output;
   return 0;
}

/**
 * Returns true if there's a geometry shader bound and the geometry
 * shader writes out a viewport index.
 */
boolean
draw_current_shader_uses_viewport_index(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->info.writes_viewport_index;
   return FALSE;
}


/**
 * Return the index of the shader output which will contain the
 * vertex position.
 */
uint
draw_current_shader_clipvertex_output(const struct draw_context *draw)
{
   return draw->vs.clipvertex_output;
}

uint
draw_current_shader_clipdistance_output(const struct draw_context *draw, int index)
{
   debug_assert(index < PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT);
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->clipdistance_output[index];
   return draw->vs.clipdistance_output[index];
}


uint
draw_current_shader_num_written_clipdistances(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->info.num_written_clipdistance;
   return draw->vs.vertex_shader->info.num_written_clipdistance;
}


uint
draw_current_shader_culldistance_output(const struct draw_context *draw, int index)
{
   debug_assert(index < PIPE_MAX_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT);
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->culldistance_output[index];
   return draw->vs.vertex_shader->culldistance_output[index];
}

uint
draw_current_shader_num_written_culldistances(const struct draw_context *draw)
{
   if (draw->gs.geometry_shader)
      return draw->gs.geometry_shader->info.num_written_culldistance;
   return draw->vs.vertex_shader->info.num_written_culldistance;
}

/**
d666 1
a666 3
      rast.half_pixel_center = draw->rasterizer->half_pixel_center;
      rast.bottom_edge_rule = draw->rasterizer->bottom_edge_rule;
      rast.clip_halfz = draw->rasterizer->clip_halfz;
d675 3
a677 3
draw_set_mapped_so_targets(struct draw_context *draw,
                           int num_targets,
                           struct draw_so_target *targets[PIPE_MAX_SO_BUFFERS])
d681 5
a685 4
   for (i = 0; i < num_targets; i++)
      draw->so.targets[i] = targets[i];
   for (i = num_targets; i < PIPE_MAX_SO_BUFFERS; i++)
      draw->so.targets[i] = NULL;
d687 7
a693 1
   draw->so.num_targets = num_targets;
a697 1
                       unsigned shader_stage,
d703 1
a703 4
   debug_assert(shader_stage < PIPE_SHADER_TYPES);
   debug_assert(num <= PIPE_MAX_SHADER_SAMPLER_VIEWS);

   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
d706 3
a708 3
      draw->sampler_views[shader_stage][i] = views[i];
   for (i = num; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; ++i)
      draw->sampler_views[shader_stage][i] = NULL;
d710 1
a710 1
   draw->num_sampler_views[shader_stage] = num;
a714 1
                  unsigned shader_stage,
d720 1
a720 4
   debug_assert(shader_stage < PIPE_SHADER_TYPES);
   debug_assert(num <= PIPE_MAX_SAMPLERS);

   draw_do_flush( draw, DRAW_FLUSH_STATE_CHANGE );
d723 3
a725 3
      draw->samplers[shader_stage][i] = samplers[i];
   for (i = num; i < PIPE_MAX_SAMPLERS; ++i)
      draw->samplers[shader_stage][i] = NULL;
d727 1
a727 1
   draw->num_samplers[shader_stage] = num;
d731 1
a731 1
      draw_llvm_set_sampler_state(draw, shader_stage);
d737 1
a737 2
                        unsigned shader_stage,
                        unsigned sview_idx,
d739 1
a739 2
                        uint32_t first_level, uint32_t last_level,
                        const void *base_ptr,
d742 1
a742 1
                        uint32_t mip_offsets[PIPE_MAX_TEXTURE_LEVELS])
d745 1
a745 1
   if (draw->llvm)
d747 3
a749 42
                                   shader_stage,
                                   sview_idx,
                                   width, height, depth, first_level,
                                   last_level, base_ptr,
                                   row_stride, img_stride, mip_offsets);
#endif
}

/**
 * XXX: Results for PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS because there are two
 * different ways of setting textures, and drivers typically only support one.
 */
int
draw_get_shader_param_no_llvm(unsigned shader, enum pipe_shader_cap param)
{
   switch(shader) {
   case PIPE_SHADER_VERTEX:
   case PIPE_SHADER_GEOMETRY:
      return tgsi_exec_get_shader_param(param);
   default:
      return 0;
   }
}

/**
 * XXX: Results for PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS because there are two
 * different ways of setting textures, and drivers typically only support one.
 */
int
draw_get_shader_param(unsigned shader, enum pipe_shader_cap param)
{

#ifdef HAVE_LLVM
   if (draw_get_option_use_llvm()) {
      switch(shader) {
      case PIPE_SHADER_VERTEX:
      case PIPE_SHADER_GEOMETRY:
         return gallivm_get_shader_param(param);
      default:
         return 0;
      }
   }
a750 43

   return draw_get_shader_param_no_llvm(shader, param);
}

/**
 * Enables or disables collection of statistics.
 *
 * Draw module is capable of generating statistics for the vertex
 * processing pipeline. Collection of that data isn't free and so
 * it's disabled by default. The users of the module can enable
 * (or disable) this functionality through this function.
 * The actual data will be emitted through the VBUF interface,
 * the 'pipeline_statistics' callback to be exact.
 */
void
draw_collect_pipeline_statistics(struct draw_context *draw,
                                 boolean enable)
{
   draw->collect_statistics = enable;
}

/**
 * Computes clipper invocation statistics.
 *
 * Figures out how many primitives would have been
 * sent to the clipper given the specified
 * prim info data.
 */
void
draw_stats_clipper_primitives(struct draw_context *draw,
                              const struct draw_prim_info *prim_info)
{
   if (draw->collect_statistics) {
      unsigned start, i;
      for (start = i = 0;
           i < prim_info->primitive_count;
           start += prim_info->primitive_lengths[i], i++)
      {
         draw->statistics.c_invocations +=
            u_decomposed_prims_for_vertices(prim_info->prim,
                                            prim_info->primitive_lengths[i]);
      }
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keithw@@vmware.com>
a40 1
#include "util/u_format.h"
a41 2
#include "draw_pipe.h"
#include "draw_prim_assembler.h"
a67 6
#else
boolean
draw_get_option_use_llvm(void)
{
   return FALSE;
}
a96 4
   draw->ia = draw_prim_assembler_create(draw);
   if (!draw->ia)
      goto err_destroy;

a160 2
   draw->floating_point_depth = false;

a207 1
   draw_prim_assembler_destroy(draw->ia);
d229 1
a229 2
 * Specify the depth stencil format for the draw pipeline. This function
 * determines the Minimum Resolvable Depth factor for polygon offset.
d232 2
a233 1
 * values between vertex shading and rasterization.
d235 1
a235 1
void draw_set_zs_format(struct draw_context *draw, enum pipe_format format)
d237 1
a237 6
   const struct util_format_description *desc = util_format_description(format);

   draw->floating_point_depth =
      (util_get_depth_format_type(desc) == UTIL_FORMAT_TYPE_FLOAT);

   draw->mrd = util_get_depth_format_mrd(desc);
a249 4
   draw->guard_band_points_xy = draw->guard_band_xy ||
                                (draw->driver.bypass_clip_points &&
                                (draw->rasterizer &&
                                 draw->rasterizer->point_tri_clip));
a274 4
 * Setting bypass_clip_points to achieve d3d-style point clipping (the driver
 * will need to do the "vp scissoring") _requires_ the driver to implement
 * wide points / point sprites itself (points will still be clipped if rasterizer
 * point_tri_clip isn't set). Only relevant if bypass_clip_xy isn't set.
d279 1
a279 2
                               boolean guard_band_xy,
                               boolean bypass_clip_points)
a285 1
   draw->driver.bypass_clip_points = bypass_clip_points;
a542 22
/**
 * Prepare outputs slots from the draw module
 *
 * Certain parts of the draw module can emit additional
 * outputs that can be quite useful to the backends, a good
 * example of it is the process of decomposing primitives
 * into wireframes (aka. lines) which normally would lose
 * the face-side information, but using this method we can
 * inject another shader output which passes the original
 * face side information to the backend.
 */
void
draw_prepare_shader_outputs(struct draw_context *draw)
{
   draw_remove_extra_vertex_attribs(draw);
   draw_prim_assembler_prepare_outputs(draw->ia);
   draw_unfilled_prepare_outputs(draw, draw->pipeline.unfilled);
   if (draw->pipeline.aapoint)
      draw_aapoint_prepare_outputs(draw, draw->pipeline.aapoint);
   if (draw->pipeline.aaline)
      draw_aaline_prepare_outputs(draw, draw->pipeline.aaline);
}
a607 34
 * Return total number of the vertex shader outputs.  This function
 * also counts any extra vertex output attributes that may
 * be filled in by some draw stages (such as AA point, AA line,
 * front face).
 */
uint
draw_total_vs_outputs(const struct draw_context *draw)
{
   const struct tgsi_shader_info *info = &draw->vs.vertex_shader->info;

   return info->num_outputs + draw->extra_shader_outputs.num;;
}

/**
 * Return total number of the geometry shader outputs. This function
 * also counts any extra geometry output attributes that may
 * be filled in by some draw stages (such as AA point, AA line, front
 * face).
 */
uint
draw_total_gs_outputs(const struct draw_context *draw)
{   
   const struct tgsi_shader_info *info;

   if (!draw->gs.geometry_shader)
      return 0;

   info = &draw->gs.geometry_shader->info;

   return info->num_outputs + draw->extra_shader_outputs.num;
}


/**
a915 2
 * Drivers requesting a draw context explicitly without llvm must call
 * draw_get_shader_param_no_llvm instead.
d965 5
a969 2
      unsigned i;
      for (i = 0; i < prim_info->primitive_count; i++) {
a974 26
}


/**
 * Returns true if the draw module will inject the frontface
 * info into the outputs.
 *
 * Given the specified primitive and rasterizer state
 * the function will figure out if the draw module
 * will inject the front-face information into shader
 * outputs. This is done to preserve the front-facing
 * info when decomposing primitives into wireframes.
 */
boolean
draw_will_inject_frontface(const struct draw_context *draw)
{
   unsigned reduced_prim = u_reduced_prim(draw->pt.prim);
   const struct pipe_rasterizer_state *rast = draw->rasterizer;

   if (reduced_prim != PIPE_PRIM_TRIANGLES) {
      return FALSE;
   }

   return (rast &&
           (rast->fill_front != PIPE_POLYGON_MODE_FILL ||
            rast->fill_back != PIPE_POLYGON_MODE_FILL));
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d84 1
a84 2
draw_create_context(struct pipe_context *pipe, void *context,
                    boolean try_llvm)
d95 3
a97 1
      draw->llvm = draw_llvm_create(draw, (LLVMContextRef)context);
d125 1
a125 1
   return draw_create_context(pipe, NULL, TRUE);
a128 9
#if HAVE_LLVM
struct draw_context *
draw_create_with_llvm_context(struct pipe_context *pipe,
                              void *context)
{
   return draw_create_context(pipe, context, TRUE);
}
#endif

d135 1
a135 1
   return draw_create_context(pipe, NULL, FALSE);
d821 1
a821 3
 * clip vertex position.
 * Note we don't support clipvertex output in the gs. For clipping
 * to work correctly hence we return ordinary position output instead.
a825 2
   if (draw->gs.geometry_shader)
      return draw->gs.position_output;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d84 2
a85 1
draw_create_context(struct pipe_context *pipe, boolean try_llvm)
d96 1
a96 3
      draw->llvm = draw_llvm_create(draw);
      if (!draw->llvm)
         goto err_destroy;
d124 1
a124 1
   return draw_create_context(pipe, TRUE);
d128 9
d143 1
a143 1
   return draw_create_context(pipe, FALSE);
d829 3
a831 1
 * vertex position.
d836 2
@


