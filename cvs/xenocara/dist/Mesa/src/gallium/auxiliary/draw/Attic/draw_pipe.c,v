head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.30;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.41;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */

#include "draw/draw_private.h"
#include "draw/draw_pipe.h"
#include "util/u_debug.h"
#include "util/u_math.h"



boolean draw_pipeline_init( struct draw_context *draw )
{
   /* create pipeline stages */
   draw->pipeline.wide_line  = draw_wide_line_stage( draw );
   draw->pipeline.wide_point = draw_wide_point_stage( draw );
   draw->pipeline.stipple   = draw_stipple_stage( draw );
   draw->pipeline.unfilled  = draw_unfilled_stage( draw );
   draw->pipeline.twoside   = draw_twoside_stage( draw );
   draw->pipeline.offset    = draw_offset_stage( draw );
   draw->pipeline.clip      = draw_clip_stage( draw );
   draw->pipeline.flatshade = draw_flatshade_stage( draw );
   draw->pipeline.cull      = draw_cull_stage( draw );
   draw->pipeline.validate  = draw_validate_stage( draw );
   draw->pipeline.first     = draw->pipeline.validate;

   if (!draw->pipeline.wide_line ||
       !draw->pipeline.wide_point ||
       !draw->pipeline.stipple ||
       !draw->pipeline.unfilled ||
       !draw->pipeline.twoside ||
       !draw->pipeline.offset ||
       !draw->pipeline.clip ||
       !draw->pipeline.flatshade ||
       !draw->pipeline.cull ||
       !draw->pipeline.validate)
      return FALSE;

   /* these defaults are oriented toward the needs of softpipe */
   draw->pipeline.wide_point_threshold = 1000000.0f; /* infinity */
   draw->pipeline.wide_line_threshold = 1.0f;
   draw->pipeline.wide_point_sprites = FALSE;
   draw->pipeline.line_stipple = TRUE;
   draw->pipeline.point_sprite = TRUE;

   return TRUE;
}


void draw_pipeline_destroy( struct draw_context *draw )
{
   if (draw->pipeline.wide_line)
      draw->pipeline.wide_line->destroy( draw->pipeline.wide_line );
   if (draw->pipeline.wide_point)
      draw->pipeline.wide_point->destroy( draw->pipeline.wide_point );
   if (draw->pipeline.stipple)
      draw->pipeline.stipple->destroy( draw->pipeline.stipple );
   if (draw->pipeline.unfilled)
      draw->pipeline.unfilled->destroy( draw->pipeline.unfilled );
   if (draw->pipeline.twoside)
      draw->pipeline.twoside->destroy( draw->pipeline.twoside );
   if (draw->pipeline.offset)
      draw->pipeline.offset->destroy( draw->pipeline.offset );
   if (draw->pipeline.clip)
      draw->pipeline.clip->destroy( draw->pipeline.clip );
   if (draw->pipeline.flatshade)
      draw->pipeline.flatshade->destroy( draw->pipeline.flatshade );
   if (draw->pipeline.cull)
      draw->pipeline.cull->destroy( draw->pipeline.cull );
   if (draw->pipeline.validate)
      draw->pipeline.validate->destroy( draw->pipeline.validate );
   if (draw->pipeline.aaline)
      draw->pipeline.aaline->destroy( draw->pipeline.aaline );
   if (draw->pipeline.aapoint)
      draw->pipeline.aapoint->destroy( draw->pipeline.aapoint );
   if (draw->pipeline.pstipple)
      draw->pipeline.pstipple->destroy( draw->pipeline.pstipple );
   if (draw->pipeline.rasterize)
      draw->pipeline.rasterize->destroy( draw->pipeline.rasterize );
}



/**
 * Build primitive to render a point with vertex at v0.
 */
static void do_point( struct draw_context *draw,
		      const char *v0 )
{
   struct prim_header prim;
   
   prim.flags = 0;
   prim.pad = 0;
   prim.v[0] = (struct vertex_header *)v0;

   draw->pipeline.first->point( draw->pipeline.first, &prim );
}


/**
 * Build primitive to render a line with vertices at v0, v1.
 * \param flags  bitmask of DRAW_PIPE_EDGE_x, DRAW_PIPE_RESET_STIPPLE
 */
static void do_line( struct draw_context *draw,
                     ushort flags,
		     const char *v0,
		     const char *v1 )
{
   struct prim_header prim;
   
   prim.flags = flags;
   prim.pad = 0;
   prim.v[0] = (struct vertex_header *)v0;
   prim.v[1] = (struct vertex_header *)v1;

   draw->pipeline.first->line( draw->pipeline.first, &prim );
}


/**
 * Build primitive to render a triangle with vertices at v0, v1, v2.
 * \param flags  bitmask of DRAW_PIPE_EDGE_x, DRAW_PIPE_RESET_STIPPLE
 */
static void do_triangle( struct draw_context *draw,
                         ushort flags,
			 char *v0,
			 char *v1,
			 char *v2 )
{
   struct prim_header prim;
   
   prim.v[0] = (struct vertex_header *)v0;
   prim.v[1] = (struct vertex_header *)v1;
   prim.v[2] = (struct vertex_header *)v2;
   prim.flags = flags;
   prim.pad = 0;

   draw->pipeline.first->tri( draw->pipeline.first, &prim );
}


/*
 * Set up macros for draw_pt_decompose.h template code.
 * This code uses vertex indexes / elements.
 */

#define TRIANGLE(flags,i0,i1,i2)                                  \
   do {                                                           \
      do_triangle( draw,                                          \
                   flags,                                         \
                   verts + stride * (i0),                         \
                   verts + stride * (i1),                         \
                   verts + stride * (i2) );                       \
   } while (0)

#define LINE(flags,i0,i1)                                         \
   do {                                                           \
      do_line( draw,                                              \
               flags,                                             \
               verts + stride * (i0),                             \
               verts + stride * (i1) );                           \
   } while (0)

#define POINT(i0)                               \
   do {                                         \
      do_point( draw, verts + stride * (i0) );  \
   } while (0)

#define GET_ELT(idx) (MIN2(elts[idx], max_index))

#define FUNC pipe_run_elts
#define FUNC_VARS                               \
    struct draw_context *draw,                  \
    unsigned prim,                              \
    unsigned prim_flags,                        \
    struct vertex_header *vertices,             \
    unsigned stride,                            \
    const ushort *elts,                         \
    unsigned count,                             \
    unsigned max_index

#include "draw_pt_decompose.h"



/**
 * Code to run the pipeline on a fairly arbitrary collection of vertices.
 * For drawing indexed primitives.
 *
 * Vertex headers must be pre-initialized with the
 * UNDEFINED_VERTEX_ID, this code will cause that id to become
 * overwritten, so it may have to be reset if there is the intention
 * to reuse the vertices.
 *
 * This code provides a callback to reset the vertex id's which the
 * draw_vbuf.c code uses when it has to perform a flush.
 */
void draw_pipeline_run( struct draw_context *draw,
                        const struct draw_vertex_info *vert_info,
                        const struct draw_prim_info *prim_info)
{
   unsigned i, start;

   draw->pipeline.verts = (char *)vert_info->verts;
   draw->pipeline.vertex_stride = vert_info->stride;
   draw->pipeline.vertex_count = vert_info->count;

   for (start = i = 0;
        i < prim_info->primitive_count;
        start += prim_info->primitive_lengths[i], i++)
   {
      const unsigned count = prim_info->primitive_lengths[i];

#if DEBUG
      /* Warn if one of the element indexes go outside the vertex buffer */
      {
         unsigned max_index = 0x0, i;
         /* find the largest element index */
         for (i = 0; i < count; i++) {
            unsigned int index = prim_info->elts[start + i];
            if (index > max_index)
               max_index = index;
         }
         if (max_index >= vert_info->count) {
            debug_printf("%s: max_index (%u) outside vertex buffer (%u)\n",
                         __FUNCTION__,
                         max_index,
                         vert_info->count);
         }
      }
#endif

      pipe_run_elts(draw,
                    prim_info->prim,
                    prim_info->flags,
                    vert_info->verts,
                    vert_info->stride,
                    prim_info->elts + start,
                    count,
                    vert_info->count - 1);
   }

   draw->pipeline.verts = NULL;
   draw->pipeline.vertex_count = 0;
}


/*
 * Set up macros for draw_pt_decompose.h template code.
 * This code is for non-indexed (aka linear) rendering (no elts).
 */

#define TRIANGLE(flags,i0,i1,i2)       \
   do_triangle( draw, flags,           \
                verts + stride * (i0), \
                verts + stride * (i1), \
                verts + stride * (i2) )

#define LINE(flags,i0,i1)              \
   do_line( draw, flags,               \
            verts + stride * (i0),     \
            verts + stride * (i1) )

#define POINT(i0)                      \
   do_point( draw, verts + stride * (i0) )


#define GET_ELT(idx) (idx)

#define FUNC pipe_run_linear
#define FUNC_VARS                      \
    struct draw_context *draw,         \
    unsigned prim,                     \
    unsigned prim_flags,               \
    struct vertex_header *vertices,    \
    unsigned stride,                   \
    unsigned count

#include "draw_pt_decompose.h"


/*
 * For drawing non-indexed primitives.
 */
void draw_pipeline_run_linear( struct draw_context *draw,
                               const struct draw_vertex_info *vert_info,
                               const struct draw_prim_info *prim_info)
{
   unsigned i, start;

   for (start = i = 0;
        i < prim_info->primitive_count;
        start += prim_info->primitive_lengths[i], i++)
   {
      unsigned count = prim_info->primitive_lengths[i];
      char *verts = ((char*)vert_info->verts) +
                    (start * vert_info->stride);

      draw->pipeline.verts = verts;
      draw->pipeline.vertex_stride = vert_info->stride;
      draw->pipeline.vertex_count = count;

      assert(count <= vert_info->count);

      pipe_run_linear(draw,
                      prim_info->prim,
                      prim_info->flags,
                      (struct vertex_header*)verts,
                      vert_info->stride,
                      count);
   }

   draw->pipeline.verts = NULL;
   draw->pipeline.vertex_count = 0;
}


void draw_pipeline_flush( struct draw_context *draw, 
                          unsigned flags )
{
   draw->pipeline.first->flush( draw->pipeline.first, flags );
   if (flags & DRAW_FLUSH_STATE_CHANGE)
      draw->pipeline.first = draw->pipeline.validate;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d36 1
d197 1
a197 1
#define GET_ELT(idx) (elts[idx])
d207 2
a208 1
    unsigned count
d267 2
a268 1
                    count);
d350 2
a351 1
   draw->pipeline.first = draw->pipeline.validate;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d67 2
a68 2
   draw->pipeline.wide_point_threshold = 1000000.0; /* infinity */
   draw->pipeline.wide_line_threshold = 1.0;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d69 1
d173 17
a189 27
#define QUAD(i0,i1,i2,i3)                       \
   do_triangle( draw,                           \
                ( DRAW_PIPE_RESET_STIPPLE |     \
                  DRAW_PIPE_EDGE_FLAG_0 |       \
                  DRAW_PIPE_EDGE_FLAG_2 ),      \
                verts + stride * elts[i0],      \
                verts + stride * elts[i1],      \
                verts + stride * elts[i3]);     \
   do_triangle( draw,                           \
                ( DRAW_PIPE_EDGE_FLAG_0 |       \
                  DRAW_PIPE_EDGE_FLAG_1 ),      \
                verts + stride * elts[i1],      \
                verts + stride * elts[i2],      \
                verts + stride * elts[i3])

#define TRIANGLE(flags,i0,i1,i2)                                        \
   do_triangle( draw,                                                   \
                elts[i0],  /* flags */                                  \
                verts + stride * (elts[i0] & ~DRAW_PIPE_FLAG_MASK),     \
                verts + stride * (elts[i1] & ~DRAW_PIPE_FLAG_MASK),     \
                verts + stride * (elts[i2] & ~DRAW_PIPE_FLAG_MASK) );

#define LINE(flags,i0,i1)                                       \
   do_line( draw,                                               \
            elts[i0],                                           \
            verts + stride * (elts[i0] & ~DRAW_PIPE_FLAG_MASK), \
            verts + stride * (elts[i1] & ~DRAW_PIPE_FLAG_MASK) );
d192 5
a196 2
   do_point( draw,                              \
             verts + stride * elts[i0] )
d198 2
a199 2
#define FUNC pipe_run
#define ARGS                                    \
d202 1
d205 2
a206 10
    const ushort *elts

#define LOCAL_VARS                                           \
   char *verts = (char *)vertices;                           \
   boolean flatfirst = (draw->rasterizer->flatshade &&       \
                        draw->rasterizer->flatshade_first);  \
   unsigned i;                                               \
   ushort flags

#define FLUSH
a208 2
#undef ARGS
#undef LOCAL_VARS
d213 1
a213 1
 * Code to run the pipeline on a fairly arbitary collection of vertices.
d225 2
a226 6
                        unsigned prim,
                        struct vertex_header *vertices,
                        unsigned vertex_count,
                        unsigned stride,
                        const ushort *elts,
                        unsigned count )
d228 39
a266 1
   char *verts = (char *)vertices;
a267 6
   draw->pipeline.verts = verts;
   draw->pipeline.vertex_stride = stride;
   draw->pipeline.vertex_count = vertex_count;
   
   pipe_run(draw, prim, vertices, stride, elts, count);
   
a272 1

d275 1
a275 1
 * This code is for non-indexed rendering (no elts).
a276 27
#define QUAD(i0,i1,i2,i3)                                        \
   do_triangle( draw,                                            \
                ( DRAW_PIPE_RESET_STIPPLE |                      \
                  DRAW_PIPE_EDGE_FLAG_0 |                        \
                  DRAW_PIPE_EDGE_FLAG_2 ),                       \
                verts + stride * ((i0) & ~DRAW_PIPE_FLAG_MASK),  \
                verts + stride * (i1),                           \
                verts + stride * (i3));                          \
   do_triangle( draw,                                            \
                ( DRAW_PIPE_EDGE_FLAG_0 |                        \
                  DRAW_PIPE_EDGE_FLAG_1 ),                       \
                verts + stride * ((i1) & ~DRAW_PIPE_FLAG_MASK),  \
                verts + stride * (i2),                           \
                verts + stride * (i3))

#define TRIANGLE(flags,i0,i1,i2)                                 \
   do_triangle( draw,                                            \
                flags,  /* flags */                              \
                verts + stride * ((i0) & ~DRAW_PIPE_FLAG_MASK),  \
                verts + stride * (i1),                           \
                verts + stride * (i2))

#define LINE(flags,i0,i1)                                   \
   do_line( draw,                                           \
            flags,                                          \
            verts + stride * ((i0) & ~DRAW_PIPE_FLAG_MASK), \
            verts + stride * (i1))
d278 13
a290 3
#define POINT(i0)                               \
   do_point( draw,                              \
             verts + stride * i0 )
a291 6
#define FUNC pipe_run_linear
#define ARGS                                    \
    struct draw_context *draw,                  \
    unsigned prim,                              \
    struct vertex_header *vertices,             \
    unsigned stride
d293 1
a293 6
#define LOCAL_VARS                                           \
   char *verts = (char *)vertices;                           \
   boolean flatfirst = (draw->rasterizer->flatshade &&       \
                        draw->rasterizer->flatshade_first);  \
   unsigned i;                                               \
   ushort flags
d295 8
a302 1
#define FLUSH
d311 2
a312 4
                               unsigned prim,
                               struct vertex_header *vertices,
                               unsigned count,
                               unsigned stride )
d314 1
a314 4
   char *verts = (char *)vertices;
   draw->pipeline.verts = verts;
   draw->pipeline.vertex_stride = stride;
   draw->pipeline.vertex_count = count;
d316 21
a336 1
   pipe_run_linear(draw, prim, vertices, stride, count);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a68 1
   draw->pipeline.wide_point_sprites = FALSE;
d172 27
a198 17

#define TRIANGLE(flags,i0,i1,i2)                                  \
   do {                                                           \
      do_triangle( draw,                                          \
                   flags,                                         \
                   verts + stride * (i0),                         \
                   verts + stride * (i1),                         \
                   verts + stride * (i2) );                       \
   } while (0)

#define LINE(flags,i0,i1)                                         \
   do {                                                           \
      do_line( draw,                                              \
               flags,                                             \
               verts + stride * (i0),                             \
               verts + stride * (i1) );                           \
   } while (0)
d201 2
a202 5
   do {                                         \
      do_point( draw, verts + stride * (i0) );  \
   } while (0)

#define GET_ELT(idx) (elts[idx])
d204 2
a205 2
#define FUNC pipe_run_elts
#define FUNC_VARS                               \
a207 1
    unsigned prim_flags,                        \
d210 10
a219 2
    const ushort *elts,                         \
    unsigned count
d222 2
d228 1
a228 1
 * Code to run the pipeline on a fairly arbitrary collection of vertices.
d240 6
a245 2
                        const struct draw_vertex_info *vert_info,
                        const struct draw_prim_info *prim_info)
d247 1
a247 39
   unsigned i, start;

   draw->pipeline.verts = (char *)vert_info->verts;
   draw->pipeline.vertex_stride = vert_info->stride;
   draw->pipeline.vertex_count = vert_info->count;

   for (start = i = 0;
        i < prim_info->primitive_count;
        start += prim_info->primitive_lengths[i], i++)
   {
      const unsigned count = prim_info->primitive_lengths[i];

#if DEBUG
      /* Warn if one of the element indexes go outside the vertex buffer */
      {
         unsigned max_index = 0x0, i;
         /* find the largest element index */
         for (i = 0; i < count; i++) {
            unsigned int index = prim_info->elts[start + i];
            if (index > max_index)
               max_index = index;
         }
         if (max_index >= vert_info->count) {
            debug_printf("%s: max_index (%u) outside vertex buffer (%u)\n",
                         __FUNCTION__,
                         max_index,
                         vert_info->count);
         }
      }
#endif

      pipe_run_elts(draw,
                    prim_info->prim,
                    prim_info->flags,
                    vert_info->verts,
                    vert_info->stride,
                    prim_info->elts + start,
                    count);
   }
d249 6
d260 1
d263 1
a263 1
 * This code is for non-indexed (aka linear) rendering (no elts).
d265 27
d293 3
a295 13
#define TRIANGLE(flags,i0,i1,i2)       \
   do_triangle( draw, flags,           \
                verts + stride * (i0), \
                verts + stride * (i1), \
                verts + stride * (i2) )

#define LINE(flags,i0,i1)              \
   do_line( draw, flags,               \
            verts + stride * (i0),     \
            verts + stride * (i1) )

#define POINT(i0)                      \
   do_point( draw, verts + stride * (i0) )
d297 6
d304 6
a309 1
#define GET_ELT(idx) (idx)
d311 1
a311 8
#define FUNC pipe_run_linear
#define FUNC_VARS                      \
    struct draw_context *draw,         \
    unsigned prim,                     \
    unsigned prim_flags,               \
    struct vertex_header *vertices,    \
    unsigned stride,                   \
    unsigned count
d320 4
a323 2
                               const struct draw_vertex_info *vert_info,
                               const struct draw_prim_info *prim_info)
d325 4
a328 1
   unsigned i, start;
d330 1
a330 21
   for (start = i = 0;
        i < prim_info->primitive_count;
        start += prim_info->primitive_lengths[i], i++)
   {
      unsigned count = prim_info->primitive_lengths[i];
      char *verts = ((char*)vert_info->verts) +
                    (start * vert_info->stride);

      draw->pipeline.verts = verts;
      draw->pipeline.vertex_stride = vert_info->stride;
      draw->pipeline.vertex_count = count;

      assert(count <= vert_info->count);

      pipe_run_linear(draw,
                      prim_info->prim,
                      prim_info->flags,
                      (struct vertex_header*)verts,
                      vert_info->stride,
                      count);
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a35 1
#include "util/u_math.h"
d67 2
a68 2
   draw->pipeline.wide_point_threshold = 1000000.0f; /* infinity */
   draw->pipeline.wide_line_threshold = 1.0f;
d196 1
a196 1
#define GET_ELT(idx) (MIN2(elts[idx], max_index))
d206 1
a206 2
    unsigned count,                             \
    unsigned max_index
d265 1
a265 2
                    count,
                    vert_info->count - 1);
d347 1
a347 2
   if (flags & DRAW_FLUSH_STATE_CHANGE)
      draw->pipeline.first = draw->pipeline.validate;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keithw@@vmware.com>
@


