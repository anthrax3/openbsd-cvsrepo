head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.32;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.45;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.42;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_prim.h"
#include "pipe/p_context.h"
#include "draw/draw_context.h"
#include "draw/draw_private.h"
#include "draw/draw_pt.h"
#include "draw/draw_vs.h"

#define DO_CLIP_XY           0x1
#define DO_CLIP_FULL_Z       0x2
#define DO_CLIP_HALF_Z       0x4
#define DO_CLIP_USER         0x8
#define DO_VIEWPORT          0x10
#define DO_EDGEFLAG          0x20
#define DO_CLIP_XY_GUARD_BAND 0x40


struct pt_post_vs {
   struct draw_context *draw;

   unsigned flags;

   boolean (*run)( struct pt_post_vs *pvs,
                   struct draw_vertex_info *info,
                   const struct draw_prim_info *prim_info );
};

static INLINE void
initialize_vertex_header(struct vertex_header *header)
{
   header->clipmask = 0;
   header->edgeflag = 1;
   header->have_clipdist = 0;
   header->vertex_id = UNDEFINED_VERTEX_ID;
}

static INLINE float
dot4(const float *a, const float *b)
{
   return (a[0]*b[0] +
           a[1]*b[1] +
           a[2]*b[2] +
           a[3]*b[3]);
}

#define FLAGS (0)
#define TAG(x) x##_none
#include "draw_cliptest_tmp.h"

#define FLAGS (DO_CLIP_XY | DO_CLIP_FULL_Z | DO_VIEWPORT)
#define TAG(x) x##_xy_fullz_viewport
#include "draw_cliptest_tmp.h"

#define FLAGS (DO_CLIP_XY | DO_CLIP_HALF_Z | DO_VIEWPORT)
#define TAG(x) x##_xy_halfz_viewport
#include "draw_cliptest_tmp.h"

#define FLAGS (DO_CLIP_XY_GUARD_BAND | DO_CLIP_HALF_Z | DO_VIEWPORT)
#define TAG(x) x##_xy_gb_halfz_viewport
#include "draw_cliptest_tmp.h"

#define FLAGS (DO_CLIP_FULL_Z | DO_VIEWPORT)
#define TAG(x) x##_fullz_viewport
#include "draw_cliptest_tmp.h"

#define FLAGS (DO_CLIP_HALF_Z | DO_VIEWPORT)
#define TAG(x) x##_halfz_viewport
#include "draw_cliptest_tmp.h"

#define FLAGS (DO_CLIP_XY | DO_CLIP_FULL_Z | DO_CLIP_USER | DO_VIEWPORT)
#define TAG(x) x##_xy_fullz_user_viewport
#include "draw_cliptest_tmp.h"

#define FLAGS (DO_CLIP_XY | DO_CLIP_FULL_Z | DO_CLIP_USER | DO_VIEWPORT | DO_EDGEFLAG)
#define TAG(x) x##_xy_fullz_user_viewport_edgeflag
#include "draw_cliptest_tmp.h"



/* Don't want to create 64 versions of this function, so catch the
 * less common ones here.  This is looking like something which should
 * be code-generated, perhaps appended to the end of the vertex
 * shader.
 */
#define FLAGS (pvs->flags)
#define TAG(x) x##_generic
#include "draw_cliptest_tmp.h"



boolean draw_pt_post_vs_run( struct pt_post_vs *pvs,
			     struct draw_vertex_info *info,
                             const struct draw_prim_info *prim_info )
{
   return pvs->run( pvs, info, prim_info );
}


void draw_pt_post_vs_prepare( struct pt_post_vs *pvs,
			      boolean clip_xy,
			      boolean clip_z,
                              boolean clip_user,
                              boolean guard_band,
			      boolean bypass_viewport,
                              boolean clip_halfz,
			      boolean need_edgeflags )
{
   pvs->flags = 0;

   /* This combination not currently tested/in use:
    */
   if (!clip_halfz)
      guard_band = FALSE;

   if (clip_xy && !guard_band) {
      pvs->flags |= DO_CLIP_XY;
      ASSIGN_4V( pvs->draw->plane[0], -1,  0,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[1],  1,  0,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[2],  0, -1,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[3],  0,  1,  0, 1 );
   }
   else if (clip_xy && guard_band) {
      pvs->flags |= DO_CLIP_XY_GUARD_BAND;
      ASSIGN_4V( pvs->draw->plane[0], -0.5,  0,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[1],  0.5,  0,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[2],  0, -0.5,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[3],  0,  0.5,  0, 1 );
   }

   if (clip_z) {
      if (clip_halfz) {
         pvs->flags |= DO_CLIP_HALF_Z;
         ASSIGN_4V( pvs->draw->plane[4],  0,  0,  1, 0 );
      } else {
         pvs->flags |= DO_CLIP_FULL_Z;
         ASSIGN_4V( pvs->draw->plane[4],  0,  0,  1, 1 );
      }
   }

   if (clip_user)
      pvs->flags |= DO_CLIP_USER;

   if (!bypass_viewport)
      pvs->flags |= DO_VIEWPORT;

   if (need_edgeflags)
      pvs->flags |= DO_EDGEFLAG;

   /* Now select the relevant function:
    */
   switch (pvs->flags) {
   case 0:
      pvs->run = do_cliptest_none;
      break;

   case DO_CLIP_XY | DO_CLIP_FULL_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_xy_fullz_viewport;
      break;

   case DO_CLIP_XY | DO_CLIP_HALF_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_xy_halfz_viewport;
      break;

   case DO_CLIP_XY_GUARD_BAND | DO_CLIP_HALF_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_xy_gb_halfz_viewport;
      break;

   case DO_CLIP_FULL_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_fullz_viewport;
      break;

   case DO_CLIP_HALF_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_halfz_viewport;
      break;

   case DO_CLIP_XY | DO_CLIP_FULL_Z | DO_CLIP_USER | DO_VIEWPORT:
      pvs->run = do_cliptest_xy_fullz_user_viewport;
      break;

   case (DO_CLIP_XY | DO_CLIP_FULL_Z | DO_CLIP_USER |
         DO_VIEWPORT | DO_EDGEFLAG):
      pvs->run = do_cliptest_xy_fullz_user_viewport_edgeflag;
      break;
      
   default:
      pvs->run = do_cliptest_generic;
      break;
   }
}


struct pt_post_vs *draw_pt_post_vs_create( struct draw_context *draw )
{
   struct pt_post_vs *pvs = CALLOC_STRUCT( pt_post_vs );
   if (!pvs)
      return NULL;

   pvs->draw = draw;

   return pvs;
}

void draw_pt_post_vs_destroy( struct pt_post_vs *pvs )
{
   FREE(pvs);
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d30 1
d35 1
a35 1

d43 1
d52 2
a53 1
                   struct draw_vertex_info *info );
d61 1
a61 1
   header->pad = 0;
d86 4
d120 2
a121 1
			     struct draw_vertex_info *info )
d123 1
a123 1
   return pvs->run( pvs, info );
d131 1
d133 1
a133 1
			      boolean opengl,
d138 6
a143 1
   if (clip_xy)
d145 11
a155 4
   
   if (clip_z && opengl) {
      pvs->flags |= DO_CLIP_FULL_Z;
      ASSIGN_4V( pvs->draw->plane[4],  0,  0,  1, 1 );
d158 8
a165 3
   if (clip_z && !opengl) {
      pvs->flags |= DO_CLIP_HALF_Z;
      ASSIGN_4V( pvs->draw->plane[4],  0,  0,  1, 0 );
d190 4
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d29 1
a32 1
#include "draw/draw_vbuf.h"
d35 9
d47 2
d50 1
a50 3
		struct vertex_header *vertices,
		unsigned count,
		unsigned stride );
d53 8
a60 1

d71 3
d75 3
d79 7
a85 5
static INLINE unsigned
compute_clipmask_gl(const float *clip, /*const*/ float plane[][4], unsigned nr)
{
   unsigned mask = 0x0;
   unsigned i;
d87 3
a89 5
#if 0
   debug_printf("compute clipmask %f %f %f %f\n",
                clip[0], clip[1], clip[2], clip[3]);
   assert(clip[3] != 0.0);
#endif
d91 3
a93 8
   /* Do the hardwired planes first:
    */
   if (-clip[0] + clip[3] < 0) mask |= (1<<0);
   if ( clip[0] + clip[3] < 0) mask |= (1<<1);
   if (-clip[1] + clip[3] < 0) mask |= (1<<2);
   if ( clip[1] + clip[3] < 0) mask |= (1<<3);
   if ( clip[2] + clip[3] < 0) mask |= (1<<4); /* match mesa clipplane numbering - for now */
   if (-clip[2] + clip[3] < 0) mask |= (1<<5); /* match mesa clipplane numbering - for now */
d95 3
a97 6
   /* Followed by any remaining ones:
    */
   for (i = 6; i < nr; i++) {
      if (dot4(clip, plane[i]) < 0) 
         mask |= (1<<i);
   }
a98 2
   return mask;
}
d101 4
a104 4
/* The normal case - cliptest, rhw divide, viewport transform.
 *
 * Also handle identity viewport here at the expense of a few wasted
 * instructions
d106 3
a108 49
static boolean post_vs_cliptest_viewport_gl( struct pt_post_vs *pvs,
					  struct vertex_header *vertices,
					  unsigned count,
					  unsigned stride )
{
   struct vertex_header *out = vertices;
   const float *scale = pvs->draw->viewport.scale;
   const float *trans = pvs->draw->viewport.translate;
   const unsigned pos = draw_current_shader_position_output(pvs->draw);
   unsigned clipped = 0;
   unsigned j;

   if (0) debug_printf("%s\n", __FUNCTION__);

   for (j = 0; j < count; j++) {
      float *position = out->data[pos];

      out->clip[0] = position[0];
      out->clip[1] = position[1];
      out->clip[2] = position[2];
      out->clip[3] = position[3];

      out->vertex_id = 0xffff;
      out->clipmask = compute_clipmask_gl(out->clip, 
					  pvs->draw->plane,
					  pvs->draw->nr_planes);
      clipped += out->clipmask;

      if (out->clipmask == 0)
      {
	 /* divide by w */
	 float w = 1.0f / position[3];

	 /* Viewport mapping */
	 position[0] = position[0] * w * scale[0] + trans[0];
	 position[1] = position[1] * w * scale[1] + trans[1];
	 position[2] = position[2] * w * scale[2] + trans[2];
	 position[3] = w;
#if 0
         debug_printf("post viewport: %f %f %f %f\n",
                      position[0],
                      position[1],
                      position[2],
                      position[3]);
#endif
      }

      out = (struct vertex_header *)( (char *)out + stride );
   }
a109 2
   return clipped != 0;
}
d112 2
a113 8

/* As above plus edgeflags
 */
static boolean 
post_vs_cliptest_viewport_gl_edgeflag(struct pt_post_vs *pvs,
                                      struct vertex_header *vertices,
                                      unsigned count,
                                      unsigned stride )
d115 1
a115 20
   unsigned j;
   boolean needpipe;

   needpipe = post_vs_cliptest_viewport_gl( pvs, vertices, count, stride);

   /* If present, copy edgeflag VS output into vertex header.
    * Otherwise, leave header as is.
    */
   if (pvs->draw->vs.edgeflag_output) {
      struct vertex_header *out = vertices;
      int ef = pvs->draw->vs.edgeflag_output;

      for (j = 0; j < count; j++) {
         const float *edgeflag = out->data[ef];
         out->edgeflag = !(edgeflag[0] != 1.0f);
         needpipe |= !out->edgeflag;
         out = (struct vertex_header *)( (char *)out + stride );
      }
   }
   return needpipe;
d119 7
a125 8


/* If bypass_clipping is set, skip cliptest and rhw divide.
 */
static boolean post_vs_viewport( struct pt_post_vs *pvs,
			      struct vertex_header *vertices,
			      unsigned count,
			      unsigned stride )
d127 1
a127 15
   struct vertex_header *out = vertices;
   const float *scale = pvs->draw->viewport.scale;
   const float *trans = pvs->draw->viewport.translate;
   const unsigned pos = draw_current_shader_position_output(pvs->draw);
   unsigned j;

   if (0) debug_printf("%s\n", __FUNCTION__);
   for (j = 0; j < count; j++) {
      float *position = out->data[pos];

      /* Viewport mapping only, no cliptest/rhw divide
       */
      position[0] = position[0] * scale[0] + trans[0];
      position[1] = position[1] * scale[1] + trans[1];
      position[2] = position[2] * scale[2] + trans[2];
d129 6
a134 1
      out = (struct vertex_header *)((char *)out + stride);
a135 3
   
   return FALSE;
}
d137 4
d142 2
a143 11
/* If bypass_clipping is set and we have an identity viewport, nothing
 * to do.
 */
static boolean post_vs_none( struct pt_post_vs *pvs,
			     struct vertex_header *vertices,
			     unsigned count,
			     unsigned stride )
{
   if (0) debug_printf("%s\n", __FUNCTION__);
   return FALSE;
}
d145 2
a146 7
boolean draw_pt_post_vs_run( struct pt_post_vs *pvs,
			     struct vertex_header *pipeline_verts,
			     unsigned count,
			     unsigned stride )
{
   return pvs->run( pvs, pipeline_verts, count, stride );
}
d148 2
d151 35
a185 26
void draw_pt_post_vs_prepare( struct pt_post_vs *pvs,
			      boolean bypass_clipping,
			      boolean bypass_viewport,
			      boolean opengl,
			      boolean need_edgeflags )
{
   if (!need_edgeflags) {
      if (bypass_clipping) {
         if (bypass_viewport)
            pvs->run = post_vs_none;
         else
            pvs->run = post_vs_viewport;
      }
      else {
         /* if (opengl) */
         pvs->run = post_vs_cliptest_viewport_gl;
      }
   }
   else {
      /* If we need to copy edgeflags to the vertex header, it should
       * mean we're running the primitive pipeline.  Hence the bypass
       * flags should be false.
       */
      assert(!bypass_clipping);
      assert(!bypass_viewport);
      pvs->run = post_vs_cliptest_viewport_gl_edgeflag;
d197 1
a197 1
   
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a28 1
#include "util/u_math.h"
d32 1
a34 9

#define DO_CLIP_XY           0x1
#define DO_CLIP_FULL_Z       0x2
#define DO_CLIP_HALF_Z       0x4
#define DO_CLIP_USER         0x8
#define DO_VIEWPORT          0x10
#define DO_EDGEFLAG          0x20


a37 2
   unsigned flags;

d39 3
a41 1
                   struct draw_vertex_info *info );
d44 1
a44 8
static INLINE void
initialize_vertex_header(struct vertex_header *header)
{
   header->clipmask = 0;
   header->edgeflag = 1;
   header->pad = 0;
   header->vertex_id = UNDEFINED_VERTEX_ID;
}
a54 3
#define FLAGS (0)
#define TAG(x) x##_none
#include "draw_cliptest_tmp.h"
a55 3
#define FLAGS (DO_CLIP_XY | DO_CLIP_FULL_Z | DO_VIEWPORT)
#define TAG(x) x##_xy_fullz_viewport
#include "draw_cliptest_tmp.h"
d57 91
a147 3
#define FLAGS (DO_CLIP_XY | DO_CLIP_HALF_Z | DO_VIEWPORT)
#define TAG(x) x##_xy_halfz_viewport
#include "draw_cliptest_tmp.h"
d149 10
a158 3
#define FLAGS (DO_CLIP_FULL_Z | DO_VIEWPORT)
#define TAG(x) x##_fullz_viewport
#include "draw_cliptest_tmp.h"
d160 1
a160 3
#define FLAGS (DO_CLIP_HALF_Z | DO_VIEWPORT)
#define TAG(x) x##_halfz_viewport
#include "draw_cliptest_tmp.h"
d162 16
a177 3
#define FLAGS (DO_CLIP_XY | DO_CLIP_FULL_Z | DO_CLIP_USER | DO_VIEWPORT)
#define TAG(x) x##_xy_fullz_user_viewport
#include "draw_cliptest_tmp.h"
a178 3
#define FLAGS (DO_CLIP_XY | DO_CLIP_FULL_Z | DO_CLIP_USER | DO_VIEWPORT | DO_EDGEFLAG)
#define TAG(x) x##_xy_fullz_user_viewport_edgeflag
#include "draw_cliptest_tmp.h"
d182 1
a182 4
/* Don't want to create 64 versions of this function, so catch the
 * less common ones here.  This is looking like something which should
 * be code-generated, perhaps appended to the end of the vertex
 * shader.
d184 20
a203 3
#define FLAGS (pvs->flags)
#define TAG(x) x##_generic
#include "draw_cliptest_tmp.h"
d205 5
d212 12
d225 3
a227 1
			     struct draw_vertex_info *info )
d229 1
a229 1
   return pvs->run( pvs, info );
d234 1
a234 3
			      boolean clip_xy,
			      boolean clip_z,
                              boolean clip_user,
d239 11
a249 8
   pvs->flags = 0;

   if (clip_xy)
      pvs->flags |= DO_CLIP_XY;
   
   if (clip_z && opengl) {
      pvs->flags |= DO_CLIP_FULL_Z;
      ASSIGN_4V( pvs->draw->plane[4],  0,  0,  1, 1 );
d251 8
a258 50

   if (clip_z && !opengl) {
      pvs->flags |= DO_CLIP_HALF_Z;
      ASSIGN_4V( pvs->draw->plane[4],  0,  0,  1, 0 );
   }

   if (clip_user)
      pvs->flags |= DO_CLIP_USER;

   if (!bypass_viewport)
      pvs->flags |= DO_VIEWPORT;

   if (need_edgeflags)
      pvs->flags |= DO_EDGEFLAG;

   /* Now select the relevant function:
    */
   switch (pvs->flags) {
   case 0:
      pvs->run = do_cliptest_none;
      break;

   case DO_CLIP_XY | DO_CLIP_FULL_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_xy_fullz_viewport;
      break;

   case DO_CLIP_XY | DO_CLIP_HALF_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_xy_halfz_viewport;
      break;

   case DO_CLIP_FULL_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_fullz_viewport;
      break;

   case DO_CLIP_HALF_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_halfz_viewport;
      break;

   case DO_CLIP_XY | DO_CLIP_FULL_Z | DO_CLIP_USER | DO_VIEWPORT:
      pvs->run = do_cliptest_xy_fullz_user_viewport;
      break;

   case (DO_CLIP_XY | DO_CLIP_FULL_Z | DO_CLIP_USER |
         DO_VIEWPORT | DO_EDGEFLAG):
      pvs->run = do_cliptest_xy_fullz_user_viewport_edgeflag;
      break;
      
   default:
      pvs->run = do_cliptest_generic;
      break;
d270 1
a270 1

@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a29 1
#include "util/u_prim.h"
d34 1
a34 1
#include "draw/draw_vs.h"
a41 1
#define DO_CLIP_XY_GUARD_BAND 0x40
d50 1
a50 2
                   struct draw_vertex_info *info,
                   const struct draw_prim_info *prim_info );
d58 1
a58 1
   header->have_clipdist = 0;
a82 4
#define FLAGS (DO_CLIP_XY_GUARD_BAND | DO_CLIP_HALF_Z | DO_VIEWPORT)
#define TAG(x) x##_xy_gb_halfz_viewport
#include "draw_cliptest_tmp.h"

d113 1
a113 2
			     struct draw_vertex_info *info,
                             const struct draw_prim_info *prim_info )
d115 1
a115 1
   return pvs->run( pvs, info, prim_info );
a122 1
                              boolean guard_band,
d124 1
a124 1
                              boolean clip_halfz,
d129 1
a129 6
   /* This combination not currently tested/in use:
    */
   if (!clip_halfz)
      guard_band = FALSE;

   if (clip_xy && !guard_band) {
d131 4
a134 11
      ASSIGN_4V( pvs->draw->plane[0], -1,  0,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[1],  1,  0,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[2],  0, -1,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[3],  0,  1,  0, 1 );
   }
   else if (clip_xy && guard_band) {
      pvs->flags |= DO_CLIP_XY_GUARD_BAND;
      ASSIGN_4V( pvs->draw->plane[0], -0.5,  0,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[1],  0.5,  0,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[2],  0, -0.5,  0, 1 );
      ASSIGN_4V( pvs->draw->plane[3],  0,  0.5,  0, 1 );
d137 3
a139 8
   if (clip_z) {
      if (clip_halfz) {
         pvs->flags |= DO_CLIP_HALF_Z;
         ASSIGN_4V( pvs->draw->plane[4],  0,  0,  1, 0 );
      } else {
         pvs->flags |= DO_CLIP_FULL_Z;
         ASSIGN_4V( pvs->draw->plane[4],  0,  0,  1, 1 );
      }
a163 4
      break;

   case DO_CLIP_XY_GUARD_BAND | DO_CLIP_HALF_Z | DO_VIEWPORT:
      pvs->run = do_cliptest_xy_gb_halfz_viewport;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


