head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.32;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.44;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.42;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_prim.h"
#include "draw/draw_context.h"
#include "draw/draw_vbuf.h"
#include "draw/draw_vertex.h"
#include "draw/draw_prim_assembler.h"
#include "draw/draw_pt.h"
#include "draw/draw_vs.h"
#include "draw/draw_gs.h"


struct fetch_pipeline_middle_end {
   struct draw_pt_middle_end base;
   struct draw_context *draw;

   struct pt_emit *emit;
   struct pt_so_emit *so_emit;
   struct pt_fetch *fetch;
   struct pt_post_vs *post_vs;

   unsigned vertex_data_offset;
   unsigned vertex_size;
   unsigned input_prim;
   unsigned opt;
};


/** cast wrapper */
static INLINE struct fetch_pipeline_middle_end *
fetch_pipeline_middle_end(struct draw_pt_middle_end *middle)
{
   return (struct fetch_pipeline_middle_end *) middle;
}


/**
 * Prepare/validate middle part of the vertex pipeline.
 * NOTE: if you change this function, also look at the LLVM
 * function llvm_middle_end_prepare() for similar changes.
 */
static void
fetch_pipeline_prepare(struct draw_pt_middle_end *middle,
                       unsigned prim,
                       unsigned opt,
                       unsigned *max_vertices)
{
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
   struct draw_context *draw = fpme->draw;
   struct draw_vertex_shader *vs = draw->vs.vertex_shader;
   struct draw_geometry_shader *gs = draw->gs.geometry_shader;
   unsigned i;
   unsigned instance_id_index = ~0;
   const unsigned gs_out_prim = (gs ? gs->output_primitive :
                                 u_assembled_prim(prim));
   unsigned nr_vs_outputs = draw_total_vs_outputs(draw);
   unsigned nr = MAX2(vs->info.num_inputs, nr_vs_outputs);
   unsigned point_clip = draw->rasterizer->fill_front == PIPE_POLYGON_MODE_POINT ||
                         gs_out_prim == PIPE_PRIM_POINTS;

   if (gs) {
      nr = MAX2(nr, gs->info.num_outputs + 1);
   }

   /* Scan for instanceID system value.
    */
   for (i = 0; i < vs->info.num_inputs; i++) {
      if (vs->info.input_semantic_name[i] == TGSI_SEMANTIC_INSTANCEID) {
         instance_id_index = i;
         break;
      }
   }

   fpme->input_prim = prim;
   fpme->opt = opt;

   /* Always leave room for the vertex header whether we need it or
    * not.  It's hard to get rid of it in particular because of the
    * viewport code in draw_pt_post_vs.c.
    */
   fpme->vertex_size = sizeof(struct vertex_header) + nr * 4 * sizeof(float);

   draw_pt_fetch_prepare( fpme->fetch,
                          vs->info.num_inputs,
                          fpme->vertex_size,
                          instance_id_index );
   draw_pt_post_vs_prepare( fpme->post_vs,
                            draw->clip_xy,
                            draw->clip_z,
                            draw->clip_user,
                            point_clip ? draw->guard_band_points_xy :
                                         draw->guard_band_xy,
                            draw->identity_viewport,
                            draw->rasterizer->clip_halfz,
                            (draw->vs.edgeflag_output ? TRUE : FALSE) );

   draw_pt_so_emit_prepare( fpme->so_emit, FALSE );

   if (!(opt & PT_PIPELINE)) {
      draw_pt_emit_prepare( fpme->emit,
			    gs_out_prim,
                            max_vertices );

      *max_vertices = MAX2( *max_vertices, 4096 );
   }
   else {
      /* limit max fetches by limiting max_vertices */
      *max_vertices = 4096;
   }

   /* No need to prepare the shader.
    */
   vs->prepare(vs, draw);

   /* Make sure that the vertex size didn't change at any point above */
   assert(nr_vs_outputs == draw_total_vs_outputs(draw));
}


static void
fetch_pipeline_bind_parameters(struct draw_pt_middle_end *middle)
{
   /* No-op since the vertex shader executor and drawing pipeline
    * just grab the constants, viewport, etc. from the draw context state.
    */
}


static void fetch( struct pt_fetch *fetch,
                   const struct draw_fetch_info *fetch_info,
                   char *output)
{
   if (fetch_info->linear) {
      draw_pt_fetch_run_linear( fetch,
                                fetch_info->start,
                                fetch_info->count,
                                output );
   }
   else {
      draw_pt_fetch_run( fetch,
                         fetch_info->elts,
                         fetch_info->count,
                         output );
   }
}


static void pipeline(struct fetch_pipeline_middle_end *fpme,
                     const struct draw_vertex_info *vert_info,
                     const struct draw_prim_info *prim_info)
{
   if (prim_info->linear)
      draw_pipeline_run_linear( fpme->draw,
                                vert_info,
                                prim_info);
   else
      draw_pipeline_run( fpme->draw,
                         vert_info,
                         prim_info );
}


static void
emit(struct pt_emit *emit,
     const struct draw_vertex_info *vert_info,
     const struct draw_prim_info *prim_info)
{
   if (prim_info->linear) {
      draw_pt_emit_linear(emit, vert_info, prim_info);
   }
   else {
      draw_pt_emit(emit, vert_info, prim_info);
   }
}


static void
draw_vertex_shader_run(struct draw_vertex_shader *vshader,
                       const void *constants[PIPE_MAX_CONSTANT_BUFFERS],
                       unsigned const_size[PIPE_MAX_CONSTANT_BUFFERS],
                       const struct draw_vertex_info *input_verts,
                       struct draw_vertex_info *output_verts)
{
   output_verts->vertex_size = input_verts->vertex_size;
   output_verts->stride = input_verts->vertex_size;
   output_verts->count = input_verts->count;
   output_verts->verts =
      (struct vertex_header *)MALLOC(output_verts->vertex_size *
                                     align(output_verts->count, 4));

   vshader->run_linear(vshader,
                       (const float (*)[4])input_verts->verts->data,
                       (      float (*)[4])output_verts->verts->data,
                       constants,
                       const_size,
                       input_verts->count,
                       input_verts->vertex_size,
                       input_verts->vertex_size);
}


static void
fetch_pipeline_generic(struct draw_pt_middle_end *middle,
                       const struct draw_fetch_info *fetch_info,
                       const struct draw_prim_info *in_prim_info)
{
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
   struct draw_context *draw = fpme->draw;
   struct draw_vertex_shader *vshader = draw->vs.vertex_shader;
   struct draw_geometry_shader *gshader = draw->gs.geometry_shader;
   struct draw_prim_info gs_prim_info;
   struct draw_vertex_info fetched_vert_info;
   struct draw_vertex_info vs_vert_info;
   struct draw_vertex_info gs_vert_info;
   struct draw_vertex_info *vert_info;
   struct draw_prim_info ia_prim_info;
   struct draw_vertex_info ia_vert_info;
   const struct draw_prim_info *prim_info = in_prim_info;
   boolean free_prim_info = FALSE;
   unsigned opt = fpme->opt;

   fetched_vert_info.count = fetch_info->count;
   fetched_vert_info.vertex_size = fpme->vertex_size;
   fetched_vert_info.stride = fpme->vertex_size;
   fetched_vert_info.verts =
      (struct vertex_header *)MALLOC(fpme->vertex_size *
                                     align(fetch_info->count,  4));
   if (!fetched_vert_info.verts) {
      assert(0);
      return;
   }
   if (draw->collect_statistics) {
      draw->statistics.ia_vertices += prim_info->count;
      draw->statistics.ia_primitives +=
         u_decomposed_prims_for_vertices(prim_info->prim, fetch_info->count);
      draw->statistics.vs_invocations += fetch_info->count;
   }

   /* Fetch into our vertex buffer.
    */
   fetch( fpme->fetch, fetch_info, (char *)fetched_vert_info.verts );

   /* Finished with fetch:
    */
   fetch_info = NULL;
   vert_info = &fetched_vert_info;

   /* Run the shader, note that this overwrites the data[] parts of
    * the pipeline verts.
    */
   if (fpme->opt & PT_SHADE) {
      draw_vertex_shader_run(vshader,
                             draw->pt.user.vs_constants,
                             draw->pt.user.vs_constants_size,
                             vert_info,
                             &vs_vert_info);

      FREE(vert_info->verts);
      vert_info = &vs_vert_info;
   }

   if ((fpme->opt & PT_SHADE) && gshader) {
      draw_geometry_shader_run(gshader,
                               draw->pt.user.gs_constants,
                               draw->pt.user.gs_constants_size,
                               vert_info,
                               prim_info,
                               &vshader->info,
                               &gs_vert_info,
                               &gs_prim_info);

      FREE(vert_info->verts);
      vert_info = &gs_vert_info;
      prim_info = &gs_prim_info;
   } else {
      if (draw_prim_assembler_is_required(draw, prim_info, vert_info)) {
         draw_prim_assembler_run(draw, prim_info, vert_info,
                                 &ia_prim_info, &ia_vert_info);

         if (ia_vert_info.count) {
            FREE(vert_info->verts);
            vert_info = &ia_vert_info;
            prim_info = &ia_prim_info;
            free_prim_info = TRUE;
         }
      }
   }
   if (prim_info->count == 0) {
      debug_printf("GS/IA didn't emit any vertices!\n");

      FREE(vert_info->verts);
      if (free_prim_info) {
         FREE(prim_info->primitive_lengths);
      }
      return;
   }


   /* Stream output needs to be done before clipping.
    *
    * XXX: Stream output surely needs to respect the prim_info->elt
    *      lists.
    */
   draw_pt_so_emit( fpme->so_emit, vert_info, prim_info );

   draw_stats_clipper_primitives(draw, prim_info);

   /*
    * if there's no position, need to stop now, or the latter stages
    * will try to access non-existent position output.
    */
   if (draw_current_shader_position_output(draw) != -1) {

      if (draw_pt_post_vs_run( fpme->post_vs, vert_info, prim_info ))
      {
         opt |= PT_PIPELINE;
      }

      /* Do we need to run the pipeline?
       */
      if (opt & PT_PIPELINE) {
         pipeline( fpme, vert_info, prim_info );
      }
      else {
         emit( fpme->emit, vert_info, prim_info );
      }
   }
   FREE(vert_info->verts);
   if (free_prim_info) {
      FREE(prim_info->primitive_lengths);
   }
}


static void
fetch_pipeline_run(struct draw_pt_middle_end *middle,
                   const unsigned *fetch_elts,
                   unsigned fetch_count,
                   const ushort *draw_elts,
                   unsigned draw_count,
                   unsigned prim_flags)
{
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
   struct draw_fetch_info fetch_info;
   struct draw_prim_info prim_info;

   fetch_info.linear = FALSE;
   fetch_info.start = 0;
   fetch_info.elts = fetch_elts;
   fetch_info.count = fetch_count;

   prim_info.linear = FALSE;
   prim_info.start = 0;
   prim_info.count = draw_count;
   prim_info.elts = draw_elts;
   prim_info.prim = fpme->input_prim;
   prim_info.flags = prim_flags;
   prim_info.primitive_count = 1;
   prim_info.primitive_lengths = &draw_count;

   fetch_pipeline_generic( middle, &fetch_info, &prim_info );
}


static void
fetch_pipeline_linear_run(struct draw_pt_middle_end *middle,
                          unsigned start,
                          unsigned count,
                          unsigned prim_flags)
{
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
   struct draw_fetch_info fetch_info;
   struct draw_prim_info prim_info;

   fetch_info.linear = TRUE;
   fetch_info.start = start;
   fetch_info.count = count;
   fetch_info.elts = NULL;

   prim_info.linear = TRUE;
   prim_info.start = 0;
   prim_info.count = count;
   prim_info.elts = NULL;
   prim_info.prim = fpme->input_prim;
   prim_info.flags = prim_flags;
   prim_info.primitive_count = 1;
   prim_info.primitive_lengths = &count;

   fetch_pipeline_generic( middle, &fetch_info, &prim_info );
}



static boolean
fetch_pipeline_linear_run_elts(struct draw_pt_middle_end *middle,
                               unsigned start,
                               unsigned count,
                               const ushort *draw_elts,
                               unsigned draw_count,
                               unsigned prim_flags )
{
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
   struct draw_fetch_info fetch_info;
   struct draw_prim_info prim_info;

   fetch_info.linear = TRUE;
   fetch_info.start = start;
   fetch_info.count = count;
   fetch_info.elts = NULL;

   prim_info.linear = FALSE;
   prim_info.start = 0;
   prim_info.count = draw_count;
   prim_info.elts = draw_elts;
   prim_info.prim = fpme->input_prim;
   prim_info.flags = prim_flags;
   prim_info.primitive_count = 1;
   prim_info.primitive_lengths = &draw_count;

   fetch_pipeline_generic( middle, &fetch_info, &prim_info );

   return TRUE;
}


static void
fetch_pipeline_finish( struct draw_pt_middle_end *middle )
{
   /* nothing to do */
}


static void
fetch_pipeline_destroy( struct draw_pt_middle_end *middle )
{
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);

   if (fpme->fetch)
      draw_pt_fetch_destroy( fpme->fetch );

   if (fpme->emit)
      draw_pt_emit_destroy( fpme->emit );

   if (fpme->so_emit)
      draw_pt_so_emit_destroy( fpme->so_emit );

   if (fpme->post_vs)
      draw_pt_post_vs_destroy( fpme->post_vs );

   FREE(middle);
}


struct draw_pt_middle_end *
draw_pt_fetch_pipeline_or_emit(struct draw_context *draw)
{
   struct fetch_pipeline_middle_end *fpme =
      CALLOC_STRUCT( fetch_pipeline_middle_end );
   if (!fpme)
      goto fail;

   fpme->base.prepare        = fetch_pipeline_prepare;
   fpme->base.bind_parameters  = fetch_pipeline_bind_parameters;
   fpme->base.run            = fetch_pipeline_run;
   fpme->base.run_linear     = fetch_pipeline_linear_run;
   fpme->base.run_linear_elts = fetch_pipeline_linear_run_elts;
   fpme->base.finish         = fetch_pipeline_finish;
   fpme->base.destroy        = fetch_pipeline_destroy;

   fpme->draw = draw;

   fpme->fetch = draw_pt_fetch_create( draw );
   if (!fpme->fetch)
      goto fail;

   fpme->post_vs = draw_pt_post_vs_create( draw );
   if (!fpme->post_vs)
      goto fail;

   fpme->emit = draw_pt_emit_create( draw );
   if (!fpme->emit)
      goto fail;

   fpme->so_emit = draw_pt_so_emit_create( draw );
   if (!fpme->so_emit)
      goto fail;

   return &fpme->base;

 fail:
   if (fpme)
      fetch_pipeline_destroy( &fpme->base );

   return NULL;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d56 8
d69 5
a73 4
static void fetch_pipeline_prepare( struct draw_pt_middle_end *middle,
                                    unsigned prim,
				    unsigned opt,
                                    unsigned *max_vertices )
d75 1
a75 1
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
a80 1

d83 4
a86 6

   /* Add one to num_outputs because the pipeline occasionally tags on
    * an additional texcoord, eg for AA lines.
    */
   unsigned nr = MAX2( vs->info.num_inputs,
		       vs->info.num_outputs + 1 );
d106 1
a106 1
    * viewport code in draw_pt_post_vs.c.  
d110 1
a110 3
   

   draw_pt_fetch_prepare( fpme->fetch, 
d118 2
a119 1
                            draw->guard_band_xy,
d141 3
d189 5
a193 3
static void emit(struct pt_emit *emit,
                 const struct draw_vertex_info *vert_info,
                 const struct draw_prim_info *prim_info)
d204 6
a209 5
static void draw_vertex_shader_run(struct draw_vertex_shader *vshader,
                                   const void *constants[PIPE_MAX_CONSTANT_BUFFERS], 
                                   unsigned const_size[PIPE_MAX_CONSTANT_BUFFERS],
                                   const struct draw_vertex_info *input_verts,
                                   struct draw_vertex_info *output_verts )
d228 5
a232 3
static void fetch_pipeline_generic( struct draw_pt_middle_end *middle,
                                    const struct draw_fetch_info *fetch_info,
                                    const struct draw_prim_info *in_prim_info )
d234 1
a234 1
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
d317 1
a317 1
      
d361 8
a368 6
static void fetch_pipeline_run( struct draw_pt_middle_end *middle,
                                const unsigned *fetch_elts,
                                unsigned fetch_count,
                                const ushort *draw_elts,
                                unsigned draw_count,
                                unsigned prim_flags )
d370 1
a370 1
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
d392 5
a396 4
static void fetch_pipeline_linear_run( struct draw_pt_middle_end *middle,
                                       unsigned start,
                                       unsigned count,
                                       unsigned prim_flags)
d398 1
a398 1
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
d421 7
a427 6
static boolean fetch_pipeline_linear_run_elts( struct draw_pt_middle_end *middle,
                                               unsigned start,
                                               unsigned count,
                                               const ushort *draw_elts,
                                               unsigned draw_count,
                                               unsigned prim_flags )
d429 1
a429 1
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
d453 2
a454 2

static void fetch_pipeline_finish( struct draw_pt_middle_end *middle )
d459 3
a461 1
static void fetch_pipeline_destroy( struct draw_pt_middle_end *middle )
d463 1
a463 1
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
d481 2
a482 1
struct draw_pt_middle_end *draw_pt_fetch_pipeline_or_emit( struct draw_context *draw )
d484 2
a485 1
   struct fetch_pipeline_middle_end *fpme = CALLOC_STRUCT( fetch_pipeline_middle_end );
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d34 1
d55 6
d69 1
d73 2
a74 3
   unsigned gs_out_prim = (draw->gs.geometry_shader ? 
                           draw->gs.geometry_shader->output_primitive :
                           prim);
d82 4
a109 3
   /* XXX: it's not really gl rasterization rules we care about here,
    * but gl vs dx9 clip spaces.
    */
d111 7
a117 6
			    draw->clip_xy,
			    draw->clip_z,
			    draw->clip_user,
			    draw->identity_viewport,
			    (boolean)draw->rasterizer->gl_rasterization_rules,
			    (draw->vs.edgeflag_output ? TRUE : FALSE) );
d119 1
a119 1
   draw_pt_so_emit_prepare( fpme->so_emit );
d139 9
d219 1
a219 1
                                    const struct draw_prim_info *prim_info )
d230 4
d246 6
d282 1
d289 21
d318 1
a318 3
   draw_pt_so_emit( fpme->so_emit,
                    vert_info,
                    prim_info );
d320 1
a320 5
   if (draw_pt_post_vs_run( fpme->post_vs,
                            vert_info ))
   {
      opt |= PT_PIPELINE;
   }
d322 3
a324 1
   /* Do we need to run the pipeline?
d326 15
a340 4
   if (opt & PT_PIPELINE) {
      pipeline( fpme,
                vert_info,
                prim_info );
d342 3
a344 4
   else {
      emit( fpme->emit,
            vert_info,
            prim_info );
a345 1
   FREE(vert_info->verts);
d469 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d30 1
d44 1
d50 1
a50 1
   unsigned prim;
a53 1

d65 4
d84 1
a84 1
   fpme->prim = prim;
d103 4
a106 2
			    (boolean)draw->bypass_clipping,
			    (boolean)draw->identity_viewport,
d108 3
a110 1
			    (draw->vs.edgeflag_output ? true : false) );    
d113 2
a114 2
      draw_pt_emit_prepare( fpme->emit, 
			    prim,
d117 1
a117 2
      *max_vertices = MAX2( *max_vertices,
                            DRAW_PIPE_MAX_VERTICES );
d120 2
a121 1
      *max_vertices = DRAW_PIPE_MAX_VERTICES; 
a123 3
   /* return even number */
   *max_vertices = *max_vertices & ~1;

d130 3
a132 6

static void fetch_pipeline_run( struct draw_pt_middle_end *middle,
                                const unsigned *fetch_elts,
                                unsigned fetch_count,
                                const ushort *draw_elts,
                                unsigned draw_count )
d134 5
a138 15
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
   struct draw_context *draw = fpme->draw;
   struct draw_vertex_shader *vshader = draw->vs.vertex_shader;
   struct draw_geometry_shader *gshader = draw->gs.geometry_shader;
   unsigned opt = fpme->opt;
   unsigned alloc_count = align( fetch_count, 4 );

   struct vertex_header *pipeline_verts = 
      (struct vertex_header *)MALLOC(fpme->vertex_size * alloc_count);

   if (!pipeline_verts) {
      /* Not much we can do here - just skip the rendering.
       */
      assert(0);
      return;
d140 5
a144 28

   /* Fetch into our vertex buffer
    */
   draw_pt_fetch_run( fpme->fetch,
		      fetch_elts, 
		      fetch_count,
		      (char *)pipeline_verts );

   /* Run the shader, note that this overwrites the data[] parts of
    * the pipeline verts.
    */
   if (opt & PT_SHADE)
   {
      vshader->run_linear(vshader,
                          (const float (*)[4])pipeline_verts->data,
                          (      float (*)[4])pipeline_verts->data,
                          draw->pt.user.vs_constants,
                          fetch_count,
                          fpme->vertex_size,
                          fpme->vertex_size);
      if (gshader)
         draw_geometry_shader_run(gshader,
                                  (const float (*)[4])pipeline_verts->data,
                                  (      float (*)[4])pipeline_verts->data,
                                  draw->pt.user.gs_constants,
                                  fetch_count,
                                  fpme->vertex_size,
                                  fpme->vertex_size);
d146 1
a147 7
   if (draw_pt_post_vs_run( fpme->post_vs,
			    pipeline_verts,
			    fetch_count,
			    fpme->vertex_size ))
   {
      opt |= PT_PIPELINE;
   }
d149 9
a157 3
   /* Do we need to run the pipeline?
    */
   if (opt & PT_PIPELINE) {
d159 10
a168 6
                         fpme->prim,
                         pipeline_verts,
                         fetch_count,
                         fpme->vertex_size,
                         draw_elts,
                         draw_count );
d171 1
a171 6
      draw_pt_emit( fpme->emit,
		    (const float (*)[4])pipeline_verts->data,
		    fetch_count,
		    fpme->vertex_size,
		    draw_elts,
		    draw_count );
d173 1
d176 21
a196 1
   FREE(pipeline_verts);
d199 3
a201 4

static void fetch_pipeline_linear_run( struct draw_pt_middle_end *middle,
                                       unsigned start,
                                       unsigned count)
d205 7
a211 2
   struct draw_vertex_shader *shader = draw->vs.vertex_shader;
   struct draw_geometry_shader *geometry_shader = draw->gs.geometry_shader;
a212 1
   unsigned alloc_count = align( count, 4 );
d214 7
a220 6
   struct vertex_header *pipeline_verts =
      (struct vertex_header *)MALLOC(fpme->vertex_size * alloc_count);

   if (!pipeline_verts) {
      /* Not much we can do here - just skip the rendering.
       */
d225 5
a229 1
   /* Fetch into our vertex buffer
d231 2
a232 4
   draw_pt_fetch_run_linear( fpme->fetch,
                             start,
                             count,
                             (char *)pipeline_verts );
d237 23
a259 18
   if (opt & PT_SHADE)
   {
      shader->run_linear(shader,
			 (const float (*)[4])pipeline_verts->data,
			 (      float (*)[4])pipeline_verts->data,
                         draw->pt.user.vs_constants,
			 count,
			 fpme->vertex_size,
			 fpme->vertex_size);

      if (geometry_shader)
         draw_geometry_shader_run(geometry_shader,
                                  (const float (*)[4])pipeline_verts->data,
                                  (      float (*)[4])pipeline_verts->data,
                                  draw->pt.user.gs_constants,
                                  count,
                                  fpme->vertex_size,
                                  fpme->vertex_size);
d262 10
d273 1
a273 3
			    pipeline_verts,
			    count,
			    fpme->vertex_size ))
d281 3
a283 5
      draw_pipeline_run_linear( fpme->draw,
                                fpme->prim,
                                pipeline_verts,
                                count,
                                fpme->vertex_size);
d286 3
a288 4
      draw_pt_emit_linear( fpme->emit,
                           (const float (*)[4])pipeline_verts->data,
                           fpme->vertex_size,
                           count );
d290 13
d304 15
a318 1
   FREE(pipeline_verts);
d322 4
a325 6

static boolean fetch_pipeline_linear_run_elts( struct draw_pt_middle_end *middle,
                                            unsigned start,
                                            unsigned count,
                                            const ushort *draw_elts,
                                            unsigned draw_count )
d328 16
a343 5
   struct draw_context *draw = fpme->draw;
   struct draw_vertex_shader *shader = draw->vs.vertex_shader;
   struct draw_geometry_shader *geometry_shader = draw->gs.geometry_shader;
   unsigned opt = fpme->opt;
   unsigned alloc_count = align( count, 4 );
d345 2
a346 2
   struct vertex_header *pipeline_verts =
      (struct vertex_header *)MALLOC(fpme->vertex_size * alloc_count);
a347 2
   if (!pipeline_verts) 
      return FALSE;
a348 6
   /* Fetch into our vertex buffer
    */
   draw_pt_fetch_run_linear( fpme->fetch,
                             start,
                             count,
                             (char *)pipeline_verts );
d350 10
a359 22
   /* Run the shader, note that this overwrites the data[] parts of
    * the pipeline verts.
    */
   if (opt & PT_SHADE)
   {
      shader->run_linear(shader,
			 (const float (*)[4])pipeline_verts->data,
			 (      float (*)[4])pipeline_verts->data,
                         draw->pt.user.vs_constants,
			 count,
			 fpme->vertex_size,
			 fpme->vertex_size);

      if (geometry_shader)
         draw_geometry_shader_run(geometry_shader,
                                  (const float (*)[4])pipeline_verts->data,
                                  (      float (*)[4])pipeline_verts->data,
                                  draw->pt.user.gs_constants,
                                  count,
                                  fpme->vertex_size,
                                  fpme->vertex_size);
   }
d361 13
a373 7
   if (draw_pt_post_vs_run( fpme->post_vs,
			    pipeline_verts,
			    count,
			    fpme->vertex_size ))
   {
      opt |= PT_PIPELINE;
   }
d375 1
a375 19
   /* Do we need to run the pipeline?
    */
   if (opt & PT_PIPELINE) {
      draw_pipeline_run( fpme->draw,
                         fpme->prim,
                         pipeline_verts,
                         count,
                         fpme->vertex_size,
                         draw_elts,
                         draw_count );
   }
   else {
      draw_pt_emit( fpme->emit,
		    (const float (*)[4])pipeline_verts->data,
		    count,
		    fpme->vertex_size,
		    draw_elts,
		    draw_count );
   }
a376 1
   FREE(pipeline_verts);
d397 3
d431 5
a435 1
   if (!fpme->emit) 
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a29 1
#include "util/u_prim.h"
a42 1
   struct pt_so_emit *so_emit;
d48 1
a48 1
   unsigned input_prim;
d52 1
a63 4
   unsigned gs_out_prim = (draw->gs.geometry_shader ? 
                           draw->gs.geometry_shader->output_primitive :
                           prim);

d79 1
a79 1
   fpme->input_prim = prim;
d98 2
a99 4
			    draw->clip_xy,
			    draw->clip_z,
			    draw->clip_user,
			    draw->identity_viewport,
d101 1
a101 3
			    (draw->vs.edgeflag_output ? TRUE : FALSE) );

   draw_pt_so_emit_prepare( fpme->so_emit );
d104 2
a105 2
      draw_pt_emit_prepare( fpme->emit,
			    gs_out_prim,
d108 2
a109 1
      *max_vertices = MAX2( *max_vertices, 4096 );
d112 1
a112 2
      /* limit max fetches by limiting max_vertices */
      *max_vertices = 4096;
d115 3
d124 6
a129 3
static void fetch( struct pt_fetch *fetch,
                   const struct draw_fetch_info *fetch_info,
                   char *output)
d131 15
a145 5
   if (fetch_info->linear) {
      draw_pt_fetch_run_linear( fetch,
                                fetch_info->start,
                                fetch_info->count,
                                output );
d147 28
a174 5
   else {
      draw_pt_fetch_run( fetch,
                         fetch_info->elts,
                         fetch_info->count,
                         output );
a175 1
}
d177 7
d185 3
a187 9
static void pipeline(struct fetch_pipeline_middle_end *fpme,
                     const struct draw_vertex_info *vert_info,
                     const struct draw_prim_info *prim_info)
{
   if (prim_info->linear)
      draw_pipeline_run_linear( fpme->draw,
                                vert_info,
                                prim_info);
   else
d189 6
a194 10
                         vert_info,
                         prim_info );
}

static void emit(struct pt_emit *emit,
                 const struct draw_vertex_info *vert_info,
                 const struct draw_prim_info *prim_info)
{
   if (prim_info->linear) {
      draw_pt_emit_linear(emit, vert_info, prim_info);
d197 6
a202 1
      draw_pt_emit(emit, vert_info, prim_info);
a203 1
}
d206 1
a206 21
static void draw_vertex_shader_run(struct draw_vertex_shader *vshader,
                                   const void *constants[PIPE_MAX_CONSTANT_BUFFERS], 
                                   unsigned const_size[PIPE_MAX_CONSTANT_BUFFERS],
                                   const struct draw_vertex_info *input_verts,
                                   struct draw_vertex_info *output_verts )
{
   output_verts->vertex_size = input_verts->vertex_size;
   output_verts->stride = input_verts->vertex_size;
   output_verts->count = input_verts->count;
   output_verts->verts =
      (struct vertex_header *)MALLOC(output_verts->vertex_size *
                                     align(output_verts->count, 4));

   vshader->run_linear(vshader,
                       (const float (*)[4])input_verts->verts->data,
                       (      float (*)[4])output_verts->verts->data,
                       constants,
                       const_size,
                       input_verts->count,
                       input_verts->vertex_size,
                       input_verts->vertex_size);
d209 4
a212 3
static void fetch_pipeline_generic( struct draw_pt_middle_end *middle,
                                    const struct draw_fetch_info *fetch_info,
                                    const struct draw_prim_info *prim_info )
d216 2
a217 7
   struct draw_vertex_shader *vshader = draw->vs.vertex_shader;
   struct draw_geometry_shader *gshader = draw->gs.geometry_shader;
   struct draw_prim_info gs_prim_info;
   struct draw_vertex_info fetched_vert_info;
   struct draw_vertex_info vs_vert_info;
   struct draw_vertex_info gs_vert_info;
   struct draw_vertex_info *vert_info;
d219 1
d221 6
a226 7
   fetched_vert_info.count = fetch_info->count;
   fetched_vert_info.vertex_size = fpme->vertex_size;
   fetched_vert_info.stride = fpme->vertex_size;
   fetched_vert_info.verts =
      (struct vertex_header *)MALLOC(fpme->vertex_size *
                                     align(fetch_info->count,  4));
   if (!fetched_vert_info.verts) {
d231 1
a231 5
   /* Fetch into our vertex buffer.
    */
   fetch( fpme->fetch, fetch_info, (char *)fetched_vert_info.verts );

   /* Finished with fetch:
d233 4
a236 2
   fetch_info = NULL;
   vert_info = &fetched_vert_info;
d241 18
a258 23
   if (fpme->opt & PT_SHADE) {
      draw_vertex_shader_run(vshader,
                             draw->pt.user.vs_constants,
                             draw->pt.user.vs_constants_size,
                             vert_info,
                             &vs_vert_info);

      FREE(vert_info->verts);
      vert_info = &vs_vert_info;
   }

   if ((fpme->opt & PT_SHADE) && gshader) {
      draw_geometry_shader_run(gshader,
                               draw->pt.user.gs_constants,
                               draw->pt.user.gs_constants_size,
                               vert_info,
                               prim_info,
                               &gs_vert_info,
                               &gs_prim_info);

      FREE(vert_info->verts);
      vert_info = &gs_vert_info;
      prim_info = &gs_prim_info;
a260 10

   /* Stream output needs to be done before clipping.
    *
    * XXX: Stream output surely needs to respect the prim_info->elt
    *      lists.
    */
   draw_pt_so_emit( fpme->so_emit,
                    vert_info,
                    prim_info );

d262 3
a264 1
                            vert_info ))
d272 5
a276 3
      pipeline( fpme,
                vert_info,
                prim_info );
d279 4
a282 3
      emit( fpme->emit,
            vert_info,
            prim_info );
d284 2
a285 1
   FREE(vert_info->verts);
a287 24
static void fetch_pipeline_run( struct draw_pt_middle_end *middle,
                                const unsigned *fetch_elts,
                                unsigned fetch_count,
                                const ushort *draw_elts,
                                unsigned draw_count,
                                unsigned prim_flags )
{
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
   struct draw_fetch_info fetch_info;
   struct draw_prim_info prim_info;

   fetch_info.linear = FALSE;
   fetch_info.start = 0;
   fetch_info.elts = fetch_elts;
   fetch_info.count = fetch_count;

   prim_info.linear = FALSE;
   prim_info.start = 0;
   prim_info.count = draw_count;
   prim_info.elts = draw_elts;
   prim_info.prim = fpme->input_prim;
   prim_info.flags = prim_flags;
   prim_info.primitive_count = 1;
   prim_info.primitive_lengths = &draw_count;
a288 2
   fetch_pipeline_generic( middle, &fetch_info, &prim_info );
}
d290 5
a294 5

static void fetch_pipeline_linear_run( struct draw_pt_middle_end *middle,
                                       unsigned start,
                                       unsigned count,
                                       unsigned prim_flags)
d297 5
a301 2
   struct draw_fetch_info fetch_info;
   struct draw_prim_info prim_info;
d303 2
a304 13
   fetch_info.linear = TRUE;
   fetch_info.start = start;
   fetch_info.count = count;
   fetch_info.elts = NULL;

   prim_info.linear = TRUE;
   prim_info.start = 0;
   prim_info.count = count;
   prim_info.elts = NULL;
   prim_info.prim = fpme->input_prim;
   prim_info.flags = prim_flags;
   prim_info.primitive_count = 1;
   prim_info.primitive_lengths = &count;
d306 2
a307 2
   fetch_pipeline_generic( middle, &fetch_info, &prim_info );
}
d309 6
d316 22
d339 7
a345 10
static boolean fetch_pipeline_linear_run_elts( struct draw_pt_middle_end *middle,
                                               unsigned start,
                                               unsigned count,
                                               const ushort *draw_elts,
                                               unsigned draw_count,
                                               unsigned prim_flags )
{
   struct fetch_pipeline_middle_end *fpme = (struct fetch_pipeline_middle_end *)middle;
   struct draw_fetch_info fetch_info;
   struct draw_prim_info prim_info;
d347 19
a365 15
   fetch_info.linear = TRUE;
   fetch_info.start = start;
   fetch_info.count = count;
   fetch_info.elts = NULL;

   prim_info.linear = FALSE;
   prim_info.start = 0;
   prim_info.count = draw_count;
   prim_info.elts = draw_elts;
   prim_info.prim = fpme->input_prim;
   prim_info.flags = prim_flags;
   prim_info.primitive_count = 1;
   prim_info.primitive_lengths = &draw_count;

   fetch_pipeline_generic( middle, &fetch_info, &prim_info );
d367 1
a387 3
   if (fpme->so_emit)
      draw_pt_so_emit_destroy( fpme->so_emit );

d419 1
a419 5
   if (!fpme->emit)
      goto fail;

   fpme->so_emit = draw_pt_so_emit_create( draw );
   if (!fpme->so_emit)
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a33 1
#include "draw/draw_prim_assembler.h"
a53 6

/**
 * Prepare/validate middle part of the vertex pipeline.
 * NOTE: if you change this function, also look at the LLVM
 * function llvm_middle_end_prepare() for similar changes.
 */
a61 1
   struct draw_geometry_shader *gs = draw->gs.geometry_shader;
d65 3
a67 2
   const unsigned gs_out_prim = (gs ? gs->output_primitive :
                                 u_assembled_prim(prim));
a74 4
   if (gs) {
      nr = MAX2(nr, gs->info.num_outputs + 1);
   }

d99 3
d103 6
a108 7
                            draw->clip_xy,
                            draw->clip_z,
                            draw->clip_user,
                            draw->guard_band_xy,
                            draw->identity_viewport,
                            draw->rasterizer->clip_halfz,
                            (draw->vs.edgeflag_output ? TRUE : FALSE) );
d110 1
a110 1
   draw_pt_so_emit_prepare( fpme->so_emit, FALSE );
a129 9
static void
fetch_pipeline_bind_parameters(struct draw_pt_middle_end *middle)
{
   /* No-op since the vertex shader executor and drawing pipeline
    * just grab the constants, viewport, etc. from the draw context state.
    */
}


d201 1
a201 1
                                    const struct draw_prim_info *in_prim_info )
a211 4
   struct draw_prim_info ia_prim_info;
   struct draw_vertex_info ia_vert_info;
   const struct draw_prim_info *prim_info = in_prim_info;
   boolean free_prim_info = FALSE;
a223 6
   if (draw->collect_statistics) {
      draw->statistics.ia_vertices += prim_info->count;
      draw->statistics.ia_primitives +=
         u_decomposed_prims_for_vertices(prim_info->prim, fetch_info->count);
      draw->statistics.vs_invocations += fetch_info->count;
   }
a253 1
                               &vshader->info,
a259 21
   } else {
      if (draw_prim_assembler_is_required(draw, prim_info, vert_info)) {
         draw_prim_assembler_run(draw, prim_info, vert_info,
                                 &ia_prim_info, &ia_vert_info);

         if (ia_vert_info.count) {
            FREE(vert_info->verts);
            vert_info = &ia_vert_info;
            prim_info = &ia_prim_info;
            free_prim_info = TRUE;
         }
      }
   }
   if (prim_info->count == 0) {
      debug_printf("GS/IA didn't emit any vertices!\n");
      
      FREE(vert_info->verts);
      if (free_prim_info) {
         FREE(prim_info->primitive_lengths);
      }
      return;
d268 3
a270 1
   draw_pt_so_emit( fpme->so_emit, vert_info, prim_info );
d272 5
a276 1
   draw_stats_clipper_primitives(draw, prim_info);
d278 1
a278 3
   /*
    * if there's no position, need to stop now, or the latter stages
    * will try to access non-existent position output.
d280 9
a288 15
   if (draw_current_shader_position_output(draw) != -1) {

      if (draw_pt_post_vs_run( fpme->post_vs, vert_info, prim_info ))
      {
         opt |= PT_PIPELINE;
      }

      /* Do we need to run the pipeline?
       */
      if (opt & PT_PIPELINE) {
         pipeline( fpme, vert_info, prim_info );
      }
      else {
         emit( fpme->emit, vert_info, prim_info );
      }
a290 3
   if (free_prim_info) {
      FREE(prim_info->primitive_lengths);
   }
a413 1
   fpme->base.bind_parameters  = fetch_pipeline_bind_parameters;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a55 8
/** cast wrapper */
static INLINE struct fetch_pipeline_middle_end *
fetch_pipeline_middle_end(struct draw_pt_middle_end *middle)
{
   return (struct fetch_pipeline_middle_end *) middle;
}


d61 4
a64 5
static void
fetch_pipeline_prepare(struct draw_pt_middle_end *middle,
                       unsigned prim,
                       unsigned opt,
                       unsigned *max_vertices)
d66 1
a66 1
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
d72 1
d75 6
a80 4
   unsigned nr_vs_outputs = draw_total_vs_outputs(draw);
   unsigned nr = MAX2(vs->info.num_inputs, nr_vs_outputs);
   unsigned point_clip = draw->rasterizer->fill_front == PIPE_POLYGON_MODE_POINT ||
                         gs_out_prim == PIPE_PRIM_POINTS;
d100 1
a100 1
    * viewport code in draw_pt_post_vs.c.
d104 3
a106 1
   draw_pt_fetch_prepare( fpme->fetch,
d114 1
a114 2
                            point_clip ? draw->guard_band_points_xy :
                                         draw->guard_band_xy,
a135 3

   /* Make sure that the vertex size didn't change at any point above */
   assert(nr_vs_outputs == draw_total_vs_outputs(draw));
d181 3
a183 5

static void
emit(struct pt_emit *emit,
     const struct draw_vertex_info *vert_info,
     const struct draw_prim_info *prim_info)
d194 5
a198 6
static void
draw_vertex_shader_run(struct draw_vertex_shader *vshader,
                       const void *constants[PIPE_MAX_CONSTANT_BUFFERS],
                       unsigned const_size[PIPE_MAX_CONSTANT_BUFFERS],
                       const struct draw_vertex_info *input_verts,
                       struct draw_vertex_info *output_verts)
d217 3
a219 5

static void
fetch_pipeline_generic(struct draw_pt_middle_end *middle,
                       const struct draw_fetch_info *fetch_info,
                       const struct draw_prim_info *in_prim_info)
d221 1
a221 1
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
d304 1
a304 1

d348 6
a353 8

static void
fetch_pipeline_run(struct draw_pt_middle_end *middle,
                   const unsigned *fetch_elts,
                   unsigned fetch_count,
                   const ushort *draw_elts,
                   unsigned draw_count,
                   unsigned prim_flags)
d355 1
a355 1
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
d377 4
a380 5
static void
fetch_pipeline_linear_run(struct draw_pt_middle_end *middle,
                          unsigned start,
                          unsigned count,
                          unsigned prim_flags)
d382 1
a382 1
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
d405 6
a410 7
static boolean
fetch_pipeline_linear_run_elts(struct draw_pt_middle_end *middle,
                               unsigned start,
                               unsigned count,
                               const ushort *draw_elts,
                               unsigned draw_count,
                               unsigned prim_flags )
d412 1
a412 1
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
d436 2
a437 2
static void
fetch_pipeline_finish( struct draw_pt_middle_end *middle )
d442 1
a442 3

static void
fetch_pipeline_destroy( struct draw_pt_middle_end *middle )
d444 1
a444 1
   struct fetch_pipeline_middle_end *fpme = fetch_pipeline_middle_end(middle);
d462 1
a462 2
struct draw_pt_middle_end *
draw_pt_fetch_pipeline_or_emit(struct draw_context *draw)
d464 1
a464 2
   struct fetch_pipeline_middle_end *fpme =
      CALLOC_STRUCT( fetch_pipeline_middle_end );
@


