head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.28;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.54;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.10.56;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.33.49;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 Younes Manton.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "util/u_math.h"
#include "util/u_debug.h"

#include "vl_csc.h"

/*
 * Color space conversion formulas
 *
 * To convert YCbCr to RGB,
 *    vec4  ycbcr, rgb
 *    mat44 csc
 *    rgb = csc * ycbcr
 *
 * To calculate the color space conversion matrix csc with ProcAmp adjustments,
 *    mat44 csc, cstd, procamp, bias
 *    csc = cstd * (procamp * bias)
 *
 * Where cstd is a matrix corresponding to one of the color standards (BT.601, BT.709, etc)
 * adjusted for the kind of YCbCr -> RGB mapping wanted (1:1, full),
 * bias is a matrix corresponding to the kind of YCbCr -> RGB mapping wanted (1:1, full)
 *
 * To calculate procamp,
 *    mat44 procamp, hue, saturation, brightness, contrast
 *    procamp = brightness * (saturation * (contrast * hue))
 * Alternatively,
 *    procamp = saturation * (brightness * (contrast * hue))
 *
 * contrast
 * [ c, 0, 0, 0]
 * [ 0, c, 0, 0]
 * [ 0, 0, c, 0]
 * [ 0, 0, 0, 1]
 *
 * brightness
 * [ 1, 0, 0, b]
 * [ 0, 1, 0, 0]
 * [ 0, 0, 1, 0]
 * [ 0, 0, 0, 1]
 *
 * saturation
 * [ 1, 0, 0, 0]
 * [ 0, s, 0, 0]
 * [ 0, 0, s, 0]
 * [ 0, 0, 0, 1]
 *
 * hue
 * [ 1,       0,      0, 0]
 * [ 0,  cos(h), sin(h), 0]
 * [ 0, -sin(h), cos(h), 0]
 * [ 0,       0,      0, 1]
 *
 * procamp
 * [ c,           0,          0, b]
 * [ 0,  c*s*cos(h), c*s*sin(h), 0]
 * [ 0, -c*s*sin(h), c*s*cos(h), 0]
 * [ 0,           0,          0, 1]
 *
 * bias
 * [ 1, 0, 0,  ybias]
 * [ 0, 1, 0, cbbias]
 * [ 0, 0, 1, crbias]
 * [ 0, 0, 0,      1]
 *
 * csc
 * [ c*cstd[ 0], c*cstd[ 1]*s*cos(h) - c*cstd[ 2]*s*sin(h), c*cstd[ 2]*s*cos(h) + c*cstd[ 1]*s*sin(h), cstd[ 3] + cstd[ 0]*(b + c*ybias) + cstd[ 1]*(c*cbbias*s*cos(h) + c*crbias*s*sin(h)) + cstd[ 2]*(c*crbias*s*cos(h) - c*cbbias*s*sin(h))]
 * [ c*cstd[ 4], c*cstd[ 5]*s*cos(h) - c*cstd[ 6]*s*sin(h), c*cstd[ 6]*s*cos(h) + c*cstd[ 5]*s*sin(h), cstd[ 7] + cstd[ 4]*(b + c*ybias) + cstd[ 5]*(c*cbbias*s*cos(h) + c*crbias*s*sin(h)) + cstd[ 6]*(c*crbias*s*cos(h) - c*cbbias*s*sin(h))]
 * [ c*cstd[ 8], c*cstd[ 9]*s*cos(h) - c*cstd[10]*s*sin(h), c*cstd[10]*s*cos(h) + c*cstd[ 9]*s*sin(h), cstd[11] + cstd[ 8]*(b + c*ybias) + cstd[ 9]*(c*cbbias*s*cos(h) + c*crbias*s*sin(h)) + cstd[10]*(c*crbias*s*cos(h) - c*cbbias*s*sin(h))]
 * [ c*cstd[12], c*cstd[13]*s*cos(h) - c*cstd[14]*s*sin(h), c*cstd[14]*s*cos(h) + c*cstd[13]*s*sin(h), cstd[15] + cstd[12]*(b + c*ybias) + cstd[13]*(c*cbbias*s*cos(h) + c*crbias*s*sin(h)) + cstd[14]*(c*crbias*s*cos(h) - c*cbbias*s*sin(h))]
 */

/*
 * Converts ITU-R BT.601 YCbCr pixels to RGB pixels where:
 * Y is in [16,235], Cb and Cr are in [16,240]
 * R, G, and B are in [16,235]
 */
static const vl_csc_matrix bt_601 =
{
   { 1.0f,  0.0f,    1.371f, 0.0f, },
   { 1.0f, -0.336f, -0.698f, 0.0f, },
   { 1.0f,  1.732f,  0.0f,   0.0f, }
};

/*
 * Converts ITU-R BT.601 YCbCr pixels to RGB pixels where:
 * Y is in [16,235], Cb and Cr are in [16,240]
 * R, G, and B are in [0,255]
 */
static const vl_csc_matrix bt_601_full =
{
   { 1.164f,  0.0f,    1.596f, 0.0f, },
   { 1.164f, -0.391f, -0.813f, 0.0f, },
   { 1.164f,  2.018f,  0.0f,   0.0f, }
};

/*
 * Converts ITU-R BT.709 YCbCr pixels to RGB pixels where:
 * Y is in [16,235], Cb and Cr are in [16,240]
 * R, G, and B are in [16,235]
 */
static const vl_csc_matrix bt_709 =
{
   { 1.0f,  0.0f,    1.540f, 0.0f, },
   { 1.0f, -0.183f, -0.459f, 0.0f, },
   { 1.0f,  1.816f,  0.0f,   0.0f, }
};

/*
 * Converts ITU-R BT.709 YCbCr pixels to RGB pixels where:
 * Y is in [16,235], Cb and Cr are in [16,240]
 * R, G, and B are in [0,255]
 */
static const vl_csc_matrix bt_709_full =
{
   { 1.164f,  0.0f,    1.793f, 0.0f, },
   { 1.164f, -0.213f, -0.534f, 0.0f, },
   { 1.164f,  2.115f,  0.0f,   0.0f, }
};

static const vl_csc_matrix smpte240m =
{
   { 1.0f,  0.0f,    1.582f, 0.0f, },
   { 1.0f, -0.228f, -0.478f, 0.0f, },
   { 1.0f,  1.833f,  0.0f,   0.0f, }
};

static const vl_csc_matrix smpte240m_full =
{
   { 1.164f,  0.0f,    1.794f, 0.0f, },
   { 1.164f, -0.258f, -0.543f, 0.0f, },
   { 1.164f,  2.079f,  0.0f,   0.0f, }
};

static const vl_csc_matrix identity =
{
   { 1.0f, 0.0f, 0.0f, 0.0f, },
   { 0.0f, 1.0f, 0.0f, 0.0f, },
   { 0.0f, 0.0f, 1.0f, 0.0f, }
};

const struct vl_procamp vl_default_procamp = {
   0.0f,  /* brightness */
   1.0f,  /* contrast   */
   1.0f,  /* saturation */
   0.0f   /* hue        */
};

void vl_csc_get_matrix(enum VL_CSC_COLOR_STANDARD cs,
                       struct vl_procamp *procamp,
                       bool full_range,
                       vl_csc_matrix *matrix)
{
   float ybias = full_range ? -16.0f/255.0f : 0.0f;
   float cbbias = -128.0f/255.0f;
   float crbias = -128.0f/255.0f;

   const struct vl_procamp *p = procamp ? procamp : &vl_default_procamp;
   float c = p->contrast;
   float s = p->saturation;
   float b = p->brightness;
   float h = p->hue;

   const vl_csc_matrix *cstd;

   assert(matrix);

   switch (cs) {
      case VL_CSC_COLOR_STANDARD_BT_601:
         cstd = full_range ? &bt_601_full : &bt_601;
         break;
      case VL_CSC_COLOR_STANDARD_BT_709:
         cstd = full_range ? &bt_709_full : &bt_709;
         break;
      case VL_CSC_COLOR_STANDARD_SMPTE_240M:
         cstd = full_range ? &smpte240m_full : &smpte240m;
         break;
      case VL_CSC_COLOR_STANDARD_IDENTITY:
      default:
         assert(cs == VL_CSC_COLOR_STANDARD_IDENTITY);
         memcpy(matrix, identity, sizeof(vl_csc_matrix));
         return;
   }

   (*matrix)[0][0] = c * (*cstd)[0][0];
   (*matrix)[0][1] = c * (*cstd)[0][1] * s * cosf(h) - c * (*cstd)[0][2] * s * sinf(h);
   (*matrix)[0][2] = c * (*cstd)[0][2] * s * cosf(h) + c * (*cstd)[0][1] * s * sinf(h);
   (*matrix)[0][3] = (*cstd)[0][3] + (*cstd)[0][0] * (b + c * ybias) +
                     (*cstd)[0][1] * (c * cbbias * s * cosf(h) + c * crbias * s * sinf(h)) +
                     (*cstd)[0][2] * (c * crbias * s * cosf(h) - c * cbbias * s * sinf(h));

   (*matrix)[1][0] = c * (*cstd)[1][0];
   (*matrix)[1][1] = c * (*cstd)[1][1] * s * cosf(h) - c * (*cstd)[1][2] * s * sinf(h);
   (*matrix)[1][2] = c * (*cstd)[1][2] * s * cosf(h) + c * (*cstd)[1][1] * s * sinf(h);
   (*matrix)[1][3] = (*cstd)[1][3] + (*cstd)[1][0] * (b + c * ybias) +
                     (*cstd)[1][1] * (c * cbbias * s * cosf(h) + c * crbias * s * sinf(h)) +
                     (*cstd)[1][2] * (c * crbias * s * cosf(h) - c * cbbias * s * sinf(h));

   (*matrix)[2][0] = c * (*cstd)[2][0];
   (*matrix)[2][1] = c * (*cstd)[2][1] * s * cosf(h) - c * (*cstd)[2][2] * s * sinf(h);
   (*matrix)[2][2] = c * (*cstd)[2][2] * s * cosf(h) + c * (*cstd)[2][1] * s * sinf(h);
   (*matrix)[2][3] = (*cstd)[2][3] + (*cstd)[2][0] * (b + c * ybias) +
                     (*cstd)[2][1] * (c * cbbias * s * cosf(h) + c * crbias * s * sinf(h)) +
                     (*cstd)[2][2] * (c * crbias * s * cosf(h) - c * cbbias * s * sinf(h));
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d2 1
a2 1
 * 
d5 1
a5 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d25 1
a25 1
 * 
d28 3
a31 2
#include <util/u_math.h>
#include <util/u_debug.h>
d103 1
a103 1
static const float bt_601[16] =
d105 3
a107 4
   1.0f,  0.0f,    1.371f, 0.0f,
   1.0f, -0.336f, -0.698f, 0.0f,
   1.0f,  1.732f,  0.0f,   0.0f,
   0.0f,  0.0f,    0.0f,   1.0f
d115 1
a115 1
static const float bt_601_full[16] =
d117 3
a119 4
   1.164f,  0.0f,    1.596f, 0.0f,
   1.164f, -0.391f, -0.813f, 0.0f,
   1.164f,  2.018f,  0.0f,   0.0f,
   0.0f,    0.0f,    0.0f,   1.0f
d127 1
a127 1
static const float bt_709[16] =
d129 3
a131 4
   1.0f,  0.0f,    1.540f, 0.0f,
   1.0f, -0.183f, -0.459f, 0.0f,
   1.0f,  1.816f,  0.0f,   0.0f,
   0.0f,  0.0f,    0.0f,   1.0f
d139 8
a146 1
static const float bt_709_full[16] =
d148 3
a150 4
   1.164f,  0.0f,    1.793f, 0.0f,
   1.164f, -0.213f, -0.534f, 0.0f,
   1.164f,  2.115f,  0.0f,   0.0f,
   0.0f,    0.0f,    0.0f,   1.0f
d153 1
a153 1
static const float identity[16] =
d155 17
a171 4
   1.0f, 0.0f, 0.0f, 0.0f,
   0.0f, 1.0f, 0.0f, 0.0f,
   0.0f, 0.0f, 1.0f, 0.0f,
   0.0f, 0.0f, 0.0f, 1.0f
d177 1
a177 1
                       float *matrix)
d182 8
a189 5
   float c = procamp ? procamp->contrast : 1.0f;
   float s = procamp ? procamp->saturation : 1.0f;
   float b = procamp ? procamp->brightness : 0.0f;
   float h = procamp ? procamp->hue : 0.0f;
   const float *cstd;
d195 1
a195 1
         cstd = full_range ? &bt_601_full[0] : &bt_601[0];
d198 4
a201 1
         cstd = full_range ? &bt_709_full[0] : &bt_709[0];
d206 1
a206 1
         memcpy(matrix, &identity[0], sizeof(float) * 16);
d210 20
a229 19
   matrix[ 0] = c*cstd[ 0];
   matrix[ 1] = c*cstd[ 1]*s*cosf(h) - c*cstd[ 2]*s*sinf(h);
   matrix[ 2] = c*cstd[ 2]*s*cosf(h) + c*cstd[ 1]*s*sinf(h);
   matrix[ 3] = cstd[ 3] + cstd[ 0]*(b + c*ybias) + cstd[ 1]*(c*cbbias*s*cosf(h) + c*crbias*s*sinf(h)) + cstd[ 2]*(c*crbias*s*cosf(h) - c*cbbias*s*sinf(h));

   matrix[ 4] = c*cstd[ 4];
   matrix[ 5] = c*cstd[ 5]*s*cosf(h) - c*cstd[ 6]*s*sinf(h);
   matrix[ 6] = c*cstd[ 6]*s*cosf(h) + c*cstd[ 5]*s*sinf(h);
   matrix[ 7] = cstd[ 7] + cstd[ 4]*(b + c*ybias) + cstd[ 5]*(c*cbbias*s*cosf(h) + c*crbias*s*sinf(h)) + cstd[ 6]*(c*crbias*s*cosf(h) - c*cbbias*s*sinf(h));

   matrix[ 8] = c*cstd[ 8];
   matrix[ 9] = c*cstd[ 9]*s*cosf(h) - c*cstd[10]*s*sinf(h);
   matrix[10] = c*cstd[10]*s*cosf(h) + c*cstd[ 9]*s*sinf(h);
   matrix[11] = cstd[11] + cstd[ 8]*(b + c*ybias) + cstd[ 9]*(c*cbbias*s*cosf(h) + c*crbias*s*sinf(h)) + cstd[10]*(c*crbias*s*cosf(h) - c*cbbias*s*sinf(h));

   matrix[12] = c*cstd[12];
   matrix[13] = c*cstd[13]*s*cos(h) - c*cstd[14]*s*sin(h);
   matrix[14] = c*cstd[14]*s*cos(h) + c*cstd[13]*s*sin(h);
   matrix[15] = cstd[15] + cstd[12]*(b + c*ybias) + cstd[13]*(c*cbbias*s*cos(h) + c*crbias*s*sin(h)) + cstd[14]*(c*crbias*s*cos(h) - c*cbbias*s*sin(h));
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d2 1
a2 1
 *
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 1
a17 1
 *
d25 1
a25 1
 *
a27 3
#include "util/u_math.h"
#include "util/u_debug.h"

d29 2
d102 1
a102 1
static const vl_csc_matrix bt_601 =
d104 4
a107 3
   { 1.0f,  0.0f,    1.371f, 0.0f, },
   { 1.0f, -0.336f, -0.698f, 0.0f, },
   { 1.0f,  1.732f,  0.0f,   0.0f, }
d115 1
a115 1
static const vl_csc_matrix bt_601_full =
d117 4
a120 3
   { 1.164f,  0.0f,    1.596f, 0.0f, },
   { 1.164f, -0.391f, -0.813f, 0.0f, },
   { 1.164f,  2.018f,  0.0f,   0.0f, }
d128 1
a128 1
static const vl_csc_matrix bt_709 =
d130 4
a133 3
   { 1.0f,  0.0f,    1.540f, 0.0f, },
   { 1.0f, -0.183f, -0.459f, 0.0f, },
   { 1.0f,  1.816f,  0.0f,   0.0f, }
d141 1
a141 8
static const vl_csc_matrix bt_709_full =
{
   { 1.164f,  0.0f,    1.793f, 0.0f, },
   { 1.164f, -0.213f, -0.534f, 0.0f, },
   { 1.164f,  2.115f,  0.0f,   0.0f, }
};

static const vl_csc_matrix smpte240m =
d143 4
a146 3
   { 1.0f,  0.0f,    1.582f, 0.0f, },
   { 1.0f, -0.228f, -0.478f, 0.0f, },
   { 1.0f,  1.833f,  0.0f,   0.0f, }
d149 1
a149 1
static const vl_csc_matrix smpte240m_full =
d151 4
a154 17
   { 1.164f,  0.0f,    1.794f, 0.0f, },
   { 1.164f, -0.258f, -0.543f, 0.0f, },
   { 1.164f,  2.079f,  0.0f,   0.0f, }
};

static const vl_csc_matrix identity =
{
   { 1.0f, 0.0f, 0.0f, 0.0f, },
   { 0.0f, 1.0f, 0.0f, 0.0f, },
   { 0.0f, 0.0f, 1.0f, 0.0f, }
};

const struct vl_procamp vl_default_procamp = {
   0.0f,  /* brightness */
   1.0f,  /* contrast   */
   1.0f,  /* saturation */
   0.0f   /* hue        */
d160 1
a160 1
                       vl_csc_matrix *matrix)
d165 5
a169 8

   const struct vl_procamp *p = procamp ? procamp : &vl_default_procamp;
   float c = p->contrast;
   float s = p->saturation;
   float b = p->brightness;
   float h = p->hue;

   const vl_csc_matrix *cstd;
d175 1
a175 1
         cstd = full_range ? &bt_601_full : &bt_601;
d178 1
a178 4
         cstd = full_range ? &bt_709_full : &bt_709;
         break;
      case VL_CSC_COLOR_STANDARD_SMPTE_240M:
         cstd = full_range ? &smpte240m_full : &smpte240m;
d183 1
a183 1
         memcpy(matrix, identity, sizeof(vl_csc_matrix));
d187 19
a205 20
   (*matrix)[0][0] = c * (*cstd)[0][0];
   (*matrix)[0][1] = c * (*cstd)[0][1] * s * cosf(h) - c * (*cstd)[0][2] * s * sinf(h);
   (*matrix)[0][2] = c * (*cstd)[0][2] * s * cosf(h) + c * (*cstd)[0][1] * s * sinf(h);
   (*matrix)[0][3] = (*cstd)[0][3] + (*cstd)[0][0] * (b + c * ybias) +
                     (*cstd)[0][1] * (c * cbbias * s * cosf(h) + c * crbias * s * sinf(h)) +
                     (*cstd)[0][2] * (c * crbias * s * cosf(h) - c * cbbias * s * sinf(h));

   (*matrix)[1][0] = c * (*cstd)[1][0];
   (*matrix)[1][1] = c * (*cstd)[1][1] * s * cosf(h) - c * (*cstd)[1][2] * s * sinf(h);
   (*matrix)[1][2] = c * (*cstd)[1][2] * s * cosf(h) + c * (*cstd)[1][1] * s * sinf(h);
   (*matrix)[1][3] = (*cstd)[1][3] + (*cstd)[1][0] * (b + c * ybias) +
                     (*cstd)[1][1] * (c * cbbias * s * cosf(h) + c * crbias * s * sinf(h)) +
                     (*cstd)[1][2] * (c * crbias * s * cosf(h) - c * cbbias * s * sinf(h));

   (*matrix)[2][0] = c * (*cstd)[2][0];
   (*matrix)[2][1] = c * (*cstd)[2][1] * s * cosf(h) - c * (*cstd)[2][2] * s * sinf(h);
   (*matrix)[2][2] = c * (*cstd)[2][2] * s * cosf(h) + c * (*cstd)[2][1] * s * sinf(h);
   (*matrix)[2][3] = (*cstd)[2][3] + (*cstd)[2][0] * (b + c * ybias) +
                     (*cstd)[2][1] * (c * cbbias * s * cosf(h) + c * crbias * s * sinf(h)) +
                     (*cstd)[2][2] * (c * crbias * s * cosf(h) - c * cbbias * s * sinf(h));
@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


