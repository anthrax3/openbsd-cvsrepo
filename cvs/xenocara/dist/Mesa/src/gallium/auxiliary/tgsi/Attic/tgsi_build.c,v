head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.27;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.43;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.36;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.45;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.31;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.38;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "util/u_debug.h"
#include "pipe/p_format.h"
#include "pipe/p_shader_tokens.h"
#include "tgsi_build.h"
#include "tgsi_parse.h"


/*
 * header
 */

struct tgsi_header
tgsi_build_header( void )
{
   struct tgsi_header header;

   header.HeaderSize = 1;
   header.BodySize = 0;

   return header;
}

static void
header_headersize_grow( struct tgsi_header *header )
{
   assert( header->HeaderSize < 0xFF );
   assert( header->BodySize == 0 );

   header->HeaderSize++;
}

static void
header_bodysize_grow( struct tgsi_header *header )
{
   assert( header->BodySize < 0xFFFFFF );

   header->BodySize++;
}

struct tgsi_processor
tgsi_build_processor(
   unsigned type,
   struct tgsi_header *header )
{
   struct tgsi_processor processor;

   processor.Processor = type;
   processor.Padding = 0;

   header_headersize_grow( header );

   return processor;
}

/*
 * declaration
 */

static void
declaration_grow(
   struct tgsi_declaration *declaration,
   struct tgsi_header *header )
{
   assert( declaration->NrTokens < 0xFF );

   declaration->NrTokens++;

   header_bodysize_grow( header );
}

static struct tgsi_declaration
tgsi_default_declaration( void )
{
   struct tgsi_declaration declaration;

   declaration.Type = TGSI_TOKEN_TYPE_DECLARATION;
   declaration.NrTokens = 1;
   declaration.File = TGSI_FILE_NULL;
   declaration.UsageMask = TGSI_WRITEMASK_XYZW;
   declaration.Interpolate = 0;
   declaration.Dimension = 0;
   declaration.Semantic = 0;
   declaration.Invariant = 0;
   declaration.Local = 0;
   declaration.Array = 0;
   declaration.Padding = 0;

   return declaration;
}

static struct tgsi_declaration
tgsi_build_declaration(
   unsigned file,
   unsigned usage_mask,
   unsigned interpolate,
   unsigned dimension,
   unsigned semantic,
   unsigned invariant,
   unsigned local,
   unsigned array,
   struct tgsi_header *header )
{
   struct tgsi_declaration declaration;

   assert( file < TGSI_FILE_COUNT );
   assert( interpolate < TGSI_INTERPOLATE_COUNT );

   declaration = tgsi_default_declaration();
   declaration.File = file;
   declaration.UsageMask = usage_mask;
   declaration.Interpolate = interpolate;
   declaration.Dimension = dimension;
   declaration.Semantic = semantic;
   declaration.Invariant = invariant;
   declaration.Local = local;
   declaration.Array = array;
   header_bodysize_grow( header );

   return declaration;
}

static struct tgsi_declaration_range
tgsi_default_declaration_range( void )
{
   struct tgsi_declaration_range dr;

   dr.First = 0;
   dr.Last = 0;

   return dr;
}

static struct tgsi_declaration_range
tgsi_build_declaration_range(
   unsigned first,
   unsigned last,
   struct tgsi_declaration *declaration,
   struct tgsi_header *header )
{
   struct tgsi_declaration_range declaration_range;

   assert( last >= first );
   assert( last <= 0xFFFF );

   declaration_range.First = first;
   declaration_range.Last = last;

   declaration_grow( declaration, header );

   return declaration_range;
}

static struct tgsi_declaration_dimension
tgsi_build_declaration_dimension(unsigned index_2d,
                                 struct tgsi_declaration *declaration,
                                 struct tgsi_header *header)
{
   struct tgsi_declaration_dimension dd;

   assert(index_2d <= 0xFFFF);

   dd.Index2D = index_2d;
   dd.Padding = 0;

   declaration_grow(declaration, header);

   return dd;
}

static struct tgsi_declaration_interp
tgsi_default_declaration_interp( void )
{
   struct tgsi_declaration_interp di;

   di.Interpolate = TGSI_INTERPOLATE_CONSTANT;
   di.Centroid = 0;
   di.CylindricalWrap = 0;
   di.Padding = 0;

   return di;
}

static struct tgsi_declaration_interp
tgsi_build_declaration_interp(unsigned interpolate,
                              unsigned centroid,
                              unsigned cylindrical_wrap,
                              struct tgsi_declaration *declaration,
                              struct tgsi_header *header)
{
   struct tgsi_declaration_interp di;

   di.Interpolate = interpolate;
   di.Centroid = centroid;
   di.CylindricalWrap = cylindrical_wrap;
   di.Padding = 0;

   declaration_grow(declaration, header);

   return di;
}

static struct tgsi_declaration_semantic
tgsi_default_declaration_semantic( void )
{
   struct tgsi_declaration_semantic ds;

   ds.Name = TGSI_SEMANTIC_POSITION;
   ds.Index = 0;
   ds.Padding = 0;

   return ds;
}

static struct tgsi_declaration_semantic
tgsi_build_declaration_semantic(
   unsigned semantic_name,
   unsigned semantic_index,
   struct tgsi_declaration *declaration,
   struct tgsi_header *header )
{
   struct tgsi_declaration_semantic ds;

   assert( semantic_name <= TGSI_SEMANTIC_COUNT );
   assert( semantic_index <= 0xFFFF );

   ds.Name = semantic_name;
   ds.Index = semantic_index;
   ds.Padding = 0;

   declaration_grow( declaration, header );

   return ds;
}

static struct tgsi_declaration_resource
tgsi_default_declaration_resource(void)
{
   struct tgsi_declaration_resource dr;

   dr.Resource = TGSI_TEXTURE_BUFFER;
   dr.Raw = 0;
   dr.Writable = 0;
   dr.Padding = 0;

   return dr;
}

static struct tgsi_declaration_resource
tgsi_build_declaration_resource(unsigned texture,
                                unsigned raw,
                                unsigned writable,
                                struct tgsi_declaration *declaration,
                                struct tgsi_header *header)
{
   struct tgsi_declaration_resource dr;

   dr = tgsi_default_declaration_resource();
   dr.Resource = texture;
   dr.Raw = raw;
   dr.Writable = writable;

   declaration_grow(declaration, header);

   return dr;
}

static struct tgsi_declaration_sampler_view
tgsi_default_declaration_sampler_view(void)
{
   struct tgsi_declaration_sampler_view dsv;

   dsv.Resource = TGSI_TEXTURE_BUFFER;
   dsv.ReturnTypeX = PIPE_TYPE_UNORM;
   dsv.ReturnTypeY = PIPE_TYPE_UNORM;
   dsv.ReturnTypeZ = PIPE_TYPE_UNORM;
   dsv.ReturnTypeW = PIPE_TYPE_UNORM;

   return dsv;
}

static struct tgsi_declaration_sampler_view
tgsi_build_declaration_sampler_view(unsigned texture,
                                    unsigned return_type_x,
                                    unsigned return_type_y,
                                    unsigned return_type_z,
                                    unsigned return_type_w,
                                    struct tgsi_declaration *declaration,
                                    struct tgsi_header *header)
{
   struct tgsi_declaration_sampler_view dsv;

   dsv = tgsi_default_declaration_sampler_view();
   dsv.Resource = texture;
   dsv.ReturnTypeX = return_type_x;
   dsv.ReturnTypeY = return_type_y;
   dsv.ReturnTypeZ = return_type_z;
   dsv.ReturnTypeW = return_type_w;

   declaration_grow(declaration, header);

   return dsv;
}


static struct tgsi_declaration_array
tgsi_default_declaration_array( void )
{
   struct tgsi_declaration_array a;

   a.ArrayID = 0;
   a.Padding = 0;

   return a;
}

static struct tgsi_declaration_array
tgsi_build_declaration_array(unsigned arrayid,
                             struct tgsi_declaration *declaration,
                             struct tgsi_header *header)
{
   struct tgsi_declaration_array da;

   da = tgsi_default_declaration_array();
   da.ArrayID = arrayid;

   declaration_grow(declaration, header);

   return da;
}

struct tgsi_full_declaration
tgsi_default_full_declaration( void )
{
   struct tgsi_full_declaration  full_declaration;

   full_declaration.Declaration  = tgsi_default_declaration();
   full_declaration.Range = tgsi_default_declaration_range();
   full_declaration.Semantic = tgsi_default_declaration_semantic();
   full_declaration.Interp = tgsi_default_declaration_interp();
   full_declaration.Resource = tgsi_default_declaration_resource();
   full_declaration.SamplerView = tgsi_default_declaration_sampler_view();
   full_declaration.Array = tgsi_default_declaration_array();

   return full_declaration;
}

unsigned
tgsi_build_full_declaration(
   const struct tgsi_full_declaration *full_decl,
   struct tgsi_token *tokens,
   struct tgsi_header *header,
   unsigned maxsize )
{
   unsigned size = 0;
   struct tgsi_declaration *declaration;
   struct tgsi_declaration_range *dr;

   if( maxsize <= size )
      return 0;
   declaration = (struct tgsi_declaration *) &tokens[size];
   size++;

   *declaration = tgsi_build_declaration(
      full_decl->Declaration.File,
      full_decl->Declaration.UsageMask,
      full_decl->Declaration.Interpolate,
      full_decl->Declaration.Dimension,
      full_decl->Declaration.Semantic,
      full_decl->Declaration.Invariant,
      full_decl->Declaration.Local,
      full_decl->Declaration.Array,
      header );

   if (maxsize <= size)
      return 0;
   dr = (struct tgsi_declaration_range *) &tokens[size];
   size++;

   *dr = tgsi_build_declaration_range(
      full_decl->Range.First,
      full_decl->Range.Last,
      declaration,
      header );

   if (full_decl->Declaration.Dimension) {
      struct tgsi_declaration_dimension *dd;

      if (maxsize <= size) {
         return 0;
      }
      dd = (struct tgsi_declaration_dimension *)&tokens[size];
      size++;

      *dd = tgsi_build_declaration_dimension(full_decl->Dim.Index2D,
                                             declaration,
                                             header);
   }

   if (full_decl->Declaration.Interpolate) {
      struct tgsi_declaration_interp *di;

      if (maxsize <= size) {
         return 0;
      }
      di = (struct tgsi_declaration_interp *)&tokens[size];
      size++;

      *di = tgsi_build_declaration_interp(full_decl->Interp.Interpolate,
                                          full_decl->Interp.Centroid,
                                          full_decl->Interp.CylindricalWrap,
                                          declaration,
                                          header);
   }

   if( full_decl->Declaration.Semantic ) {
      struct tgsi_declaration_semantic *ds;

      if( maxsize <= size )
         return  0;
      ds = (struct tgsi_declaration_semantic *) &tokens[size];
      size++;

      *ds = tgsi_build_declaration_semantic(
         full_decl->Semantic.Name,
         full_decl->Semantic.Index,
         declaration,
         header );
   }

   if (full_decl->Declaration.File == TGSI_FILE_RESOURCE) {
      struct tgsi_declaration_resource *dr;

      if (maxsize <= size) {
         return  0;
      }
      dr = (struct tgsi_declaration_resource *)&tokens[size];
      size++;

      *dr = tgsi_build_declaration_resource(full_decl->Resource.Resource,
                                            full_decl->Resource.Raw,
                                            full_decl->Resource.Writable,
                                            declaration,
                                            header);
   }

   if (full_decl->Declaration.File == TGSI_FILE_SAMPLER_VIEW) {
      struct tgsi_declaration_sampler_view *dsv;

      if (maxsize <= size) {
         return  0;
      }
      dsv = (struct tgsi_declaration_sampler_view *)&tokens[size];
      size++;

      *dsv = tgsi_build_declaration_sampler_view(
         full_decl->SamplerView.Resource,
         full_decl->SamplerView.ReturnTypeX,
         full_decl->SamplerView.ReturnTypeY,
         full_decl->SamplerView.ReturnTypeZ,
         full_decl->SamplerView.ReturnTypeW,
         declaration,
         header);
   }

   if (full_decl->Declaration.Array) {
      struct tgsi_declaration_array *da;

      if (maxsize <= size) {
         return 0;
      }
      da = (struct tgsi_declaration_array *)&tokens[size];
      size++;
      *da = tgsi_build_declaration_array(
         full_decl->Array.ArrayID,
         declaration,
         header);
   }
   return size;
}

/*
 * immediate
 */

static struct tgsi_immediate
tgsi_default_immediate( void )
{
   struct tgsi_immediate immediate;

   immediate.Type = TGSI_TOKEN_TYPE_IMMEDIATE;
   immediate.NrTokens = 1;
   immediate.DataType = TGSI_IMM_FLOAT32;
   immediate.Padding = 0;

   return immediate;
}

static struct tgsi_immediate
tgsi_build_immediate(
   struct tgsi_header *header,
   unsigned type )
{
   struct tgsi_immediate immediate;

   immediate = tgsi_default_immediate();
   immediate.DataType = type;

   header_bodysize_grow( header );

   return immediate;
}

struct tgsi_full_immediate
tgsi_default_full_immediate( void )
{
   struct tgsi_full_immediate fullimm;

   fullimm.Immediate = tgsi_default_immediate();
   fullimm.u[0].Float = 0.0f;
   fullimm.u[1].Float = 0.0f;
   fullimm.u[2].Float = 0.0f;
   fullimm.u[3].Float = 0.0f;

   return fullimm;
}

static void
immediate_grow(
   struct tgsi_immediate *immediate,
   struct tgsi_header *header )
{
   assert( immediate->NrTokens < 0xFF );

   immediate->NrTokens++;

   header_bodysize_grow( header );
}

unsigned
tgsi_build_full_immediate(
   const struct tgsi_full_immediate *full_imm,
   struct tgsi_token *tokens,
   struct tgsi_header *header,
   unsigned maxsize )
{
   unsigned size = 0, i;
   struct tgsi_immediate *immediate;

   if( maxsize <= size )
      return 0;
   immediate = (struct tgsi_immediate *) &tokens[size];
   size++;

   *immediate = tgsi_build_immediate( header, full_imm->Immediate.DataType );

   assert( full_imm->Immediate.NrTokens <= 4 + 1 );

   for( i = 0; i < full_imm->Immediate.NrTokens - 1; i++ ) {
      union tgsi_immediate_data *data;

      if( maxsize <= size )
         return  0;

      data = (union tgsi_immediate_data *) &tokens[size];
      *data = full_imm->u[i];

      immediate_grow( immediate, header );
      size++;
   }

   return size;
}

/*
 * instruction
 */

struct tgsi_instruction
tgsi_default_instruction( void )
{
   struct tgsi_instruction instruction;

   instruction.Type = TGSI_TOKEN_TYPE_INSTRUCTION;
   instruction.NrTokens = 0;
   instruction.Opcode = TGSI_OPCODE_MOV;
   instruction.Saturate = TGSI_SAT_NONE;
   instruction.Predicate = 0;
   instruction.NumDstRegs = 1;
   instruction.NumSrcRegs = 1;
   instruction.Label = 0;
   instruction.Texture = 0;
   instruction.Padding  = 0;

   return instruction;
}

static struct tgsi_instruction
tgsi_build_instruction(unsigned opcode,
                       unsigned saturate,
                       unsigned predicate,
                       unsigned num_dst_regs,
                       unsigned num_src_regs,
                       struct tgsi_header *header)
{
   struct tgsi_instruction instruction;

   assert (opcode <= TGSI_OPCODE_LAST);
   assert (saturate <= TGSI_SAT_MINUS_PLUS_ONE);
   assert (num_dst_regs <= 3);
   assert (num_src_regs <= 15);

   instruction = tgsi_default_instruction();
   instruction.Opcode = opcode;
   instruction.Saturate = saturate;
   instruction.Predicate = predicate;
   instruction.NumDstRegs = num_dst_regs;
   instruction.NumSrcRegs = num_src_regs;

   header_bodysize_grow( header );

   return instruction;
}

static void
instruction_grow(
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   assert (instruction->NrTokens <   0xFF);

   instruction->NrTokens++;

   header_bodysize_grow( header );
}

struct tgsi_instruction_predicate
tgsi_default_instruction_predicate(void)
{
   struct tgsi_instruction_predicate instruction_predicate;

   instruction_predicate.SwizzleX = TGSI_SWIZZLE_X;
   instruction_predicate.SwizzleY = TGSI_SWIZZLE_Y;
   instruction_predicate.SwizzleZ = TGSI_SWIZZLE_Z;
   instruction_predicate.SwizzleW = TGSI_SWIZZLE_W;
   instruction_predicate.Negate = 0;
   instruction_predicate.Index = 0;
   instruction_predicate.Padding = 0;

   return instruction_predicate;
}

static struct tgsi_instruction_predicate
tgsi_build_instruction_predicate(int index,
                                 unsigned negate,
                                 unsigned swizzleX,
                                 unsigned swizzleY,
                                 unsigned swizzleZ,
                                 unsigned swizzleW,
                                 struct tgsi_instruction *instruction,
                                 struct tgsi_header *header)
{
   struct tgsi_instruction_predicate instruction_predicate;

   instruction_predicate = tgsi_default_instruction_predicate();
   instruction_predicate.SwizzleX = swizzleX;
   instruction_predicate.SwizzleY = swizzleY;
   instruction_predicate.SwizzleZ = swizzleZ;
   instruction_predicate.SwizzleW = swizzleW;
   instruction_predicate.Negate = negate;
   instruction_predicate.Index = index;

   instruction_grow(instruction, header);

   return instruction_predicate;
}

static struct tgsi_instruction_label
tgsi_default_instruction_label( void )
{
   struct tgsi_instruction_label instruction_label;

   instruction_label.Label = 0;
   instruction_label.Padding = 0;

   return instruction_label;
}

static struct tgsi_instruction_label
tgsi_build_instruction_label(
   unsigned label,
   struct tgsi_token  *prev_token,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_instruction_label instruction_label;

   instruction_label.Label = label;
   instruction_label.Padding = 0;
   instruction->Label = 1;

   instruction_grow( instruction, header );

   return instruction_label;
}

static struct tgsi_instruction_texture
tgsi_default_instruction_texture( void )
{
   struct tgsi_instruction_texture instruction_texture;

   instruction_texture.Texture = TGSI_TEXTURE_UNKNOWN;
   instruction_texture.NumOffsets = 0;
   instruction_texture.Padding = 0;

   return instruction_texture;
}

static struct tgsi_instruction_texture
tgsi_build_instruction_texture(
   unsigned texture,
   unsigned num_offsets,
   struct tgsi_token *prev_token,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_instruction_texture instruction_texture;

   instruction_texture.Texture = texture;
   instruction_texture.NumOffsets = num_offsets;
   instruction_texture.Padding = 0;
   instruction->Texture = 1;

   instruction_grow( instruction, header );

   return instruction_texture;
}


static struct tgsi_texture_offset
tgsi_default_texture_offset( void )
{
   struct tgsi_texture_offset texture_offset;

   texture_offset.Index = 0;
   texture_offset.File = 0;
   texture_offset.SwizzleX = 0;
   texture_offset.SwizzleY = 0;
   texture_offset.SwizzleZ = 0;
   texture_offset.Padding = 0;

   return texture_offset;
}

static struct tgsi_texture_offset
tgsi_build_texture_offset(
   int index, int file, int swizzle_x, int swizzle_y, int swizzle_z,
   struct tgsi_token *prev_token,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_texture_offset texture_offset;

   texture_offset.Index = index;
   texture_offset.File = file;
   texture_offset.SwizzleX = swizzle_x;
   texture_offset.SwizzleY = swizzle_y;
   texture_offset.SwizzleZ = swizzle_z;
   texture_offset.Padding = 0;

   instruction_grow( instruction, header );

   return texture_offset;
}

static struct tgsi_src_register
tgsi_default_src_register( void )
{
   struct tgsi_src_register src_register;

   src_register.File = TGSI_FILE_NULL;
   src_register.SwizzleX = TGSI_SWIZZLE_X;
   src_register.SwizzleY = TGSI_SWIZZLE_Y;
   src_register.SwizzleZ = TGSI_SWIZZLE_Z;
   src_register.SwizzleW = TGSI_SWIZZLE_W;
   src_register.Negate = 0;
   src_register.Absolute = 0;
   src_register.Indirect = 0;
   src_register.Dimension = 0;
   src_register.Index = 0;

   return src_register;
}

static struct tgsi_src_register
tgsi_build_src_register(
   unsigned file,
   unsigned swizzle_x,
   unsigned swizzle_y,
   unsigned swizzle_z,
   unsigned swizzle_w,
   unsigned negate,
   unsigned absolute,
   unsigned indirect,
   unsigned dimension,
   int index,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_src_register   src_register;

   assert( file < TGSI_FILE_COUNT );
   assert( swizzle_x <= TGSI_SWIZZLE_W );
   assert( swizzle_y <= TGSI_SWIZZLE_W );
   assert( swizzle_z <= TGSI_SWIZZLE_W );
   assert( swizzle_w <= TGSI_SWIZZLE_W );
   assert( negate <= 1 );
   assert( index >= -0x8000 && index <= 0x7FFF );

   src_register.File = file;
   src_register.SwizzleX = swizzle_x;
   src_register.SwizzleY = swizzle_y;
   src_register.SwizzleZ = swizzle_z;
   src_register.SwizzleW = swizzle_w;
   src_register.Negate = negate;
   src_register.Absolute = absolute;
   src_register.Indirect = indirect;
   src_register.Dimension = dimension;
   src_register.Index = index;

   instruction_grow( instruction, header );

   return src_register;
}

static struct tgsi_ind_register
tgsi_default_ind_register( void )
{
   struct tgsi_ind_register ind_register;

   ind_register.File = TGSI_FILE_NULL;
   ind_register.Index = 0;
   ind_register.Swizzle = TGSI_SWIZZLE_X;
   ind_register.ArrayID = 0;

   return ind_register;
}

static struct tgsi_ind_register
tgsi_build_ind_register(
   unsigned file,
   unsigned swizzle,
   int index,
   unsigned arrayid,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_ind_register   ind_register;

   assert( file < TGSI_FILE_COUNT );
   assert( swizzle <= TGSI_SWIZZLE_W );
   assert( index >= -0x8000 && index <= 0x7FFF );

   ind_register.File = file;
   ind_register.Swizzle = swizzle;
   ind_register.Index = index;
   ind_register.ArrayID = arrayid;

   instruction_grow( instruction, header );

   return ind_register;
}

static struct tgsi_dimension
tgsi_default_dimension( void )
{
   struct tgsi_dimension dimension;

   dimension.Indirect = 0;
   dimension.Dimension = 0;
   dimension.Padding = 0;
   dimension.Index = 0;

   return dimension;
}

static struct tgsi_full_src_register
tgsi_default_full_src_register( void )
{
   struct tgsi_full_src_register full_src_register;

   full_src_register.Register = tgsi_default_src_register();
   full_src_register.Indirect = tgsi_default_ind_register();
   full_src_register.Dimension = tgsi_default_dimension();
   full_src_register.DimIndirect = tgsi_default_ind_register();

   return full_src_register;
}

static struct tgsi_dimension
tgsi_build_dimension(
   unsigned indirect,
   unsigned index,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_dimension dimension;

   dimension.Indirect = indirect;
   dimension.Dimension = 0;
   dimension.Padding = 0;
   dimension.Index = index;

   instruction_grow( instruction, header );

   return dimension;
}

static struct tgsi_dst_register
tgsi_default_dst_register( void )
{
   struct tgsi_dst_register dst_register;

   dst_register.File = TGSI_FILE_NULL;
   dst_register.WriteMask = TGSI_WRITEMASK_XYZW;
   dst_register.Indirect = 0;
   dst_register.Dimension = 0;
   dst_register.Index = 0;
   dst_register.Padding = 0;

   return dst_register;
}

static struct tgsi_dst_register
tgsi_build_dst_register(
   unsigned file,
   unsigned mask,
   unsigned indirect,
   unsigned dimension,
   int index,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_dst_register dst_register;

   assert( file < TGSI_FILE_COUNT );
   assert( mask <= TGSI_WRITEMASK_XYZW );
   assert( index >= -32768 && index <= 32767 );

   dst_register.File = file;
   dst_register.WriteMask = mask;
   dst_register.Indirect = indirect;
   dst_register.Dimension = dimension;
   dst_register.Index = index;
   dst_register.Padding = 0;

   instruction_grow( instruction, header );

   return dst_register;
}

static struct tgsi_full_dst_register
tgsi_default_full_dst_register( void )
{
   struct tgsi_full_dst_register full_dst_register;

   full_dst_register.Register = tgsi_default_dst_register();
   full_dst_register.Indirect = tgsi_default_ind_register();
   full_dst_register.Dimension = tgsi_default_dimension();
   full_dst_register.DimIndirect = tgsi_default_ind_register();

   return full_dst_register;
}

struct tgsi_full_instruction
tgsi_default_full_instruction( void )
{
   struct tgsi_full_instruction full_instruction;
   unsigned i;

   full_instruction.Instruction = tgsi_default_instruction();
   full_instruction.Predicate = tgsi_default_instruction_predicate();
   full_instruction.Label = tgsi_default_instruction_label();
   full_instruction.Texture = tgsi_default_instruction_texture();
   for( i = 0;  i < TGSI_FULL_MAX_TEX_OFFSETS; i++ ) {
      full_instruction.TexOffsets[i] = tgsi_default_texture_offset();
   }
   for( i = 0;  i < TGSI_FULL_MAX_DST_REGISTERS; i++ ) {
      full_instruction.Dst[i] = tgsi_default_full_dst_register();
   }
   for( i = 0;  i < TGSI_FULL_MAX_SRC_REGISTERS; i++ ) {
      full_instruction.Src[i] = tgsi_default_full_src_register();
   }

   return full_instruction;
}

unsigned
tgsi_build_full_instruction(
   const struct tgsi_full_instruction *full_inst,
   struct  tgsi_token *tokens,
   struct  tgsi_header *header,
   unsigned  maxsize )
{
   unsigned size = 0;
   unsigned i;
   struct tgsi_instruction *instruction;
   struct tgsi_token *prev_token;

   if( maxsize <= size )
      return 0;
   instruction = (struct tgsi_instruction *) &tokens[size];
   size++;

   *instruction = tgsi_build_instruction(full_inst->Instruction.Opcode,
                                         full_inst->Instruction.Saturate,
                                         full_inst->Instruction.Predicate,
                                         full_inst->Instruction.NumDstRegs,
                                         full_inst->Instruction.NumSrcRegs,
                                         header);
   prev_token = (struct tgsi_token  *) instruction;

   if (full_inst->Instruction.Predicate) {
      struct tgsi_instruction_predicate *instruction_predicate;

      if (maxsize <= size) {
         return 0;
      }
      instruction_predicate = (struct tgsi_instruction_predicate *)&tokens[size];
      size++;

      *instruction_predicate =
         tgsi_build_instruction_predicate(full_inst->Predicate.Index,
                                          full_inst->Predicate.Negate,
                                          full_inst->Predicate.SwizzleX,
                                          full_inst->Predicate.SwizzleY,
                                          full_inst->Predicate.SwizzleZ,
                                          full_inst->Predicate.SwizzleW,
                                          instruction,
                                          header);
   }

   if (full_inst->Instruction.Label) {
      struct tgsi_instruction_label *instruction_label;

      if( maxsize <= size )
         return 0;
      instruction_label =
         (struct  tgsi_instruction_label *) &tokens[size];
      size++;

      *instruction_label = tgsi_build_instruction_label(
         full_inst->Label.Label,
         prev_token,
         instruction,
         header );
      prev_token = (struct tgsi_token  *) instruction_label;
   }

   if (full_inst->Instruction.Texture) {
      struct tgsi_instruction_texture *instruction_texture;

      if( maxsize <= size )
         return 0;
      instruction_texture =
         (struct  tgsi_instruction_texture *) &tokens[size];
      size++;

      *instruction_texture = tgsi_build_instruction_texture(
         full_inst->Texture.Texture,
	 full_inst->Texture.NumOffsets,
         prev_token,
         instruction,
         header   );
      prev_token = (struct tgsi_token  *) instruction_texture;

      for (i = 0; i < full_inst->Texture.NumOffsets; i++) {
         struct tgsi_texture_offset *texture_offset;
	
         if ( maxsize <= size )
            return 0;
	 texture_offset = (struct tgsi_texture_offset *)&tokens[size];
         size++;
         *texture_offset = tgsi_build_texture_offset(
            full_inst->TexOffsets[i].Index,
            full_inst->TexOffsets[i].File,
            full_inst->TexOffsets[i].SwizzleX,
            full_inst->TexOffsets[i].SwizzleY,
            full_inst->TexOffsets[i].SwizzleZ,
            prev_token,
            instruction,
            header);
         prev_token = (struct tgsi_token *) texture_offset;
      }
   }
   for( i = 0;  i <   full_inst->Instruction.NumDstRegs; i++ ) {
      const struct tgsi_full_dst_register *reg = &full_inst->Dst[i];
      struct tgsi_dst_register *dst_register;

      if( maxsize <= size )
         return 0;
      dst_register = (struct tgsi_dst_register *) &tokens[size];
      size++;

      *dst_register = tgsi_build_dst_register(
         reg->Register.File,
         reg->Register.WriteMask,
         reg->Register.Indirect,
         reg->Register.Dimension,
         reg->Register.Index,
         instruction,
         header );

      if( reg->Register.Indirect ) {
         struct tgsi_ind_register *ind;

         if( maxsize <= size )
            return 0;
         ind = (struct tgsi_ind_register *) &tokens[size];
         size++;

         *ind = tgsi_build_ind_register(
            reg->Indirect.File,
            reg->Indirect.Swizzle,
            reg->Indirect.Index,
            reg->Indirect.ArrayID,
            instruction,
            header );
      }

      if( reg->Register.Dimension ) {
         struct  tgsi_dimension *dim;

         assert( !reg->Dimension.Dimension );

         if( maxsize <= size )
            return 0;
         dim = (struct tgsi_dimension *) &tokens[size];
         size++;

         *dim = tgsi_build_dimension(
            reg->Dimension.Indirect,
            reg->Dimension.Index,
            instruction,
            header );

         if( reg->Dimension.Indirect ) {
            struct tgsi_ind_register *ind;

            if( maxsize <= size )
               return 0;
            ind = (struct tgsi_ind_register *) &tokens[size];
            size++;

            *ind = tgsi_build_ind_register(
               reg->DimIndirect.File,
               reg->DimIndirect.Swizzle,
               reg->DimIndirect.Index,
               reg->DimIndirect.ArrayID,
               instruction,
               header );
         }
      }
   }

   for( i = 0;  i < full_inst->Instruction.NumSrcRegs; i++ ) {
      const struct tgsi_full_src_register *reg = &full_inst->Src[i];
      struct tgsi_src_register *src_register;

      if( maxsize <= size )
         return 0;
      src_register = (struct tgsi_src_register *)  &tokens[size];
      size++;

      *src_register = tgsi_build_src_register(
         reg->Register.File,
         reg->Register.SwizzleX,
         reg->Register.SwizzleY,
         reg->Register.SwizzleZ,
         reg->Register.SwizzleW,
         reg->Register.Negate,
         reg->Register.Absolute,
         reg->Register.Indirect,
         reg->Register.Dimension,
         reg->Register.Index,
         instruction,
         header );

      if( reg->Register.Indirect ) {
         struct  tgsi_ind_register *ind;

         if( maxsize <= size )
            return 0;
         ind = (struct tgsi_ind_register *) &tokens[size];
         size++;

         *ind = tgsi_build_ind_register(
            reg->Indirect.File,
            reg->Indirect.Swizzle,
            reg->Indirect.Index,
            reg->Indirect.ArrayID,
            instruction,
            header );
      }

      if( reg->Register.Dimension ) {
         struct  tgsi_dimension *dim;

         assert( !reg->Dimension.Dimension );

         if( maxsize <= size )
            return 0;
         dim = (struct tgsi_dimension *) &tokens[size];
         size++;

         *dim = tgsi_build_dimension(
            reg->Dimension.Indirect,
            reg->Dimension.Index,
            instruction,
            header );

         if( reg->Dimension.Indirect ) {
            struct tgsi_ind_register *ind;

            if( maxsize <= size )
               return 0;
            ind = (struct tgsi_ind_register *) &tokens[size];
            size++;

            *ind = tgsi_build_ind_register(
               reg->DimIndirect.File,
               reg->DimIndirect.Swizzle,
               reg->DimIndirect.Index,
               reg->DimIndirect.ArrayID,
               instruction,
               header );
         }
      }
   }

   return size;
}

static struct tgsi_property
tgsi_default_property( void )
{
   struct tgsi_property property;

   property.Type = TGSI_TOKEN_TYPE_PROPERTY;
   property.NrTokens = 1;
   property.PropertyName = TGSI_PROPERTY_GS_INPUT_PRIM;
   property.Padding = 0;

   return property;
}

static struct tgsi_property
tgsi_build_property(unsigned property_name,
                    struct tgsi_header *header)
{
   struct tgsi_property property;

   property = tgsi_default_property();
   property.PropertyName = property_name;

   header_bodysize_grow( header );

   return property;
}


struct tgsi_full_property
tgsi_default_full_property( void )
{
   struct tgsi_full_property  full_property;

   full_property.Property  = tgsi_default_property();
   memset(full_property.u, 0,
          sizeof(struct tgsi_property_data) * 8);

   return full_property;
}

static void
property_grow(
   struct tgsi_property *property,
   struct tgsi_header *header )
{
   assert( property->NrTokens < 0xFF );

   property->NrTokens++;

   header_bodysize_grow( header );
}

static struct tgsi_property_data
tgsi_build_property_data(
   unsigned value,
   struct tgsi_property *property,
   struct tgsi_header *header )
{
   struct tgsi_property_data property_data;

   property_data.Data = value;

   property_grow( property, header );

   return property_data;
}

unsigned
tgsi_build_full_property(
   const struct tgsi_full_property *full_prop,
   struct tgsi_token *tokens,
   struct tgsi_header *header,
   unsigned maxsize )
{
   unsigned size = 0, i;
   struct tgsi_property *property;

   if( maxsize <= size )
      return 0;
   property = (struct tgsi_property *) &tokens[size];
   size++;

   *property = tgsi_build_property(
      full_prop->Property.PropertyName,
      header );

   assert( full_prop->Property.NrTokens <= 8 + 1 );

   for( i = 0; i < full_prop->Property.NrTokens - 1; i++ ) {
      struct tgsi_property_data *data;

      if( maxsize <= size )
         return  0;
      data = (struct tgsi_property_data *) &tokens[size];
      size++;

      *data = tgsi_build_property_data(
         full_prop->u[i].Data,
         property,
         header );
   }

   return size;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d203 1
a203 1
   di.Location = TGSI_INTERPOLATE_LOC_CENTER;
d212 1
a212 1
                              unsigned interpolate_location,
d220 1
a220 1
   di.Location = interpolate_location;
d300 4
a303 4
   dsv.ReturnTypeX = TGSI_RETURN_TYPE_UNORM;
   dsv.ReturnTypeY = TGSI_RETURN_TYPE_UNORM;
   dsv.ReturnTypeZ = TGSI_RETURN_TYPE_UNORM;
   dsv.ReturnTypeW = TGSI_RETURN_TYPE_UNORM;
d436 1
a436 1
                                          full_decl->Interp.Location,
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d203 1
a203 1
   di.Centroid = 0;
d212 1
a212 1
                              unsigned centroid,
d220 1
a220 1
   di.Centroid = centroid;
d300 4
a303 4
   dsv.ReturnTypeX = PIPE_TYPE_UNORM;
   dsv.ReturnTypeY = PIPE_TYPE_UNORM;
   dsv.ReturnTypeZ = PIPE_TYPE_UNORM;
   dsv.ReturnTypeW = PIPE_TYPE_UNORM;
d436 1
a436 1
                                          full_decl->Interp.Centroid,
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d127 1
d143 1
a143 1

d343 15
d398 1
d492 13
d879 1
a880 1
   int index,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d107 1
a107 1
   declaration.Interpolate = TGSI_INTERPOLATE_CONSTANT;
a109 1
   declaration.Centroid = 0;
d111 3
a113 1
   declaration.CylindricalWrap = 0;
a124 1
   unsigned centroid,
d126 1
a126 1
   unsigned cylindrical_wrap,
a139 1
   declaration.Centroid = centroid;
d141 1
a141 1
   declaration.CylindricalWrap = cylindrical_wrap;
d196 32
a260 1

d264 1
a264 1
   struct tgsi_declaration_resource declaration_resource;
d266 4
a269 5
   declaration_resource.Resource = TGSI_TEXTURE_UNKNOWN;
   declaration_resource.ReturnTypeX = PIPE_TYPE_UNORM;
   declaration_resource.ReturnTypeY = PIPE_TYPE_UNORM;
   declaration_resource.ReturnTypeZ = PIPE_TYPE_UNORM;
   declaration_resource.ReturnTypeW = PIPE_TYPE_UNORM;
d271 1
a271 1
   return declaration_resource;
d276 2
a277 4
                                unsigned return_type_x,
                                unsigned return_type_y,
                                unsigned return_type_z,
                                unsigned return_type_w,
d281 1
a281 1
   struct tgsi_declaration_resource declaration_resource;
d283 4
a286 6
   declaration_resource = tgsi_default_declaration_resource();
   declaration_resource.Resource = texture;
   declaration_resource.ReturnTypeX = return_type_x;
   declaration_resource.ReturnTypeY = return_type_y;
   declaration_resource.ReturnTypeZ = return_type_z;
   declaration_resource.ReturnTypeW = return_type_w;
d290 38
a327 1
   return declaration_resource;
d331 11
d350 1
a350 1
   full_declaration.ImmediateData.u = NULL;
d352 2
a379 1
      full_decl->Declaration.Centroid,
d381 1
a381 1
      full_decl->Declaration.CylindricalWrap,
d409 16
a439 18
   if (full_decl->Declaration.File == TGSI_FILE_IMMEDIATE_ARRAY) {
      unsigned i, j;
      union tgsi_immediate_data *data;

      for (i = 0; i <= dr->Last; ++i) {
         for (j = 0; j < 4; ++j) {
            unsigned idx = i*4 + j;
            if (maxsize <= size)
               return 0;
            data = (union tgsi_immediate_data *) &tokens[size];
            ++size;

            *data = full_decl->ImmediateData.u[idx];
            declaration_grow( declaration, header );
         }
      }
   }

d450 2
a451 4
                                            full_decl->Resource.ReturnTypeX,
                                            full_decl->Resource.ReturnTypeY,
                                            full_decl->Resource.ReturnTypeZ,
                                            full_decl->Resource.ReturnTypeW,
d456 19
d497 2
a498 1
   struct tgsi_header *header )
d503 1
a535 15
static union tgsi_immediate_data
tgsi_build_immediate_float32(
   float value,
   struct tgsi_immediate *immediate,
   struct tgsi_header *header )
{
   union tgsi_immediate_data immediate_data;

   immediate_data.Float = value;

   immediate_grow( immediate, header );

   return immediate_data;
}

d551 1
a551 1
   *immediate = tgsi_build_immediate( header );
d560 1
d562 3
a565 5

      *data = tgsi_build_immediate_float32(
         full_imm->u[i].Float,
         immediate,
         header );
d709 1
d718 1
d726 1
d735 37
d832 38
d889 1
a889 1
   full_src_register.Indirect = tgsi_default_src_register();
d891 1
a891 1
   full_src_register.DimIndirect = tgsi_default_src_register();
d964 1
a964 1
   full_dst_register.Indirect = tgsi_default_src_register();
d966 1
a966 1
   full_dst_register.DimIndirect = tgsi_default_src_register();
d981 3
d1067 1
d1072 19
a1091 1

d1111 1
a1111 1
         struct tgsi_src_register *ind;
d1115 1
a1115 1
         ind = (struct tgsi_src_register *) &tokens[size];
d1118 1
a1118 1
         *ind = tgsi_build_src_register(
d1120 1
a1120 8
            reg->Indirect.SwizzleX,
            reg->Indirect.SwizzleY,
            reg->Indirect.SwizzleZ,
            reg->Indirect.SwizzleW,
            reg->Indirect.Negate,
            reg->Indirect.Absolute,
            reg->Indirect.Indirect,
            reg->Indirect.Dimension,
d1122 1
d1144 1
a1144 1
            struct tgsi_src_register *ind;
d1148 1
a1148 1
            ind = (struct tgsi_src_register *) &tokens[size];
d1151 1
a1151 1
            *ind = tgsi_build_src_register(
d1153 1
a1153 8
               reg->DimIndirect.SwizzleX,
               reg->DimIndirect.SwizzleY,
               reg->DimIndirect.SwizzleZ,
               reg->DimIndirect.SwizzleW,
               reg->DimIndirect.Negate,
               reg->DimIndirect.Absolute,
               reg->DimIndirect.Indirect,
               reg->DimIndirect.Dimension,
d1155 1
d1186 1
a1186 1
         struct  tgsi_src_register *ind;
d1190 1
a1190 1
         ind = (struct tgsi_src_register *) &tokens[size];
d1193 1
a1193 1
         *ind = tgsi_build_src_register(
d1195 1
a1195 8
            reg->Indirect.SwizzleX,
            reg->Indirect.SwizzleY,
            reg->Indirect.SwizzleZ,
            reg->Indirect.SwizzleW,
            reg->Indirect.Negate,
            reg->Indirect.Absolute,
            reg->Indirect.Indirect,
            reg->Indirect.Dimension,
d1197 1
d1219 1
a1219 1
            struct tgsi_src_register *ind;
d1223 1
a1223 1
            ind = (struct tgsi_src_register *) &tokens[size];
d1226 1
a1226 1
            *ind = tgsi_build_src_register(
d1228 1
a1228 8
               reg->DimIndirect.SwizzleX,
               reg->DimIndirect.SwizzleY,
               reg->DimIndirect.SwizzleZ,
               reg->DimIndirect.SwizzleW,
               reg->DimIndirect.Negate,
               reg->DimIndirect.Absolute,
               reg->DimIndirect.Indirect,
               reg->DimIndirect.Dimension,
d1230 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d29 1
d230 39
d278 1
d368 18
a919 1
      struct tgsi_token *prev_token;
a933 1
      prev_token = (struct tgsi_token  *) dst_register;
a1001 1
      struct tgsi_token *prev_token;
a1020 1
      prev_token = (struct tgsi_token  *) src_register;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a66 11
tgsi_default_processor( void )
{
   struct tgsi_processor processor;

   processor.Processor = TGSI_PROCESSOR_FRAGMENT;
   processor.Padding = 0;

   return processor;
}

struct tgsi_processor
a72 1
   processor = tgsi_default_processor();
d74 1
d85 13
a97 1
struct tgsi_declaration
d116 1
a116 1
struct tgsi_declaration
d148 64
a211 2
static void
declaration_grow(
d215 8
a222 1
   assert( declaration->NrTokens < 0xFF );
d224 1
a224 1
   declaration->NrTokens++;
d226 1
a226 1
   header_bodysize_grow( header );
d237 1
d254 1
a254 1
     return 0;
d309 3
a311 2
   return size;
}
d313 7
a319 4
struct tgsi_declaration_range
tgsi_default_declaration_range( void )
{
   struct tgsi_declaration_range dr;
d321 5
a325 2
   dr.First = 0;
   dr.Last = 0;
d327 1
a327 83
   return dr;
}

struct tgsi_declaration_range
tgsi_build_declaration_range(
   unsigned first,
   unsigned last,
   struct tgsi_declaration *declaration,
   struct tgsi_header *header )
{
   struct tgsi_declaration_range declaration_range;

   assert( last >= first );
   assert( last <= 0xFFFF );

   declaration_range = tgsi_default_declaration_range();
   declaration_range.First = first;
   declaration_range.Last = last;

   declaration_grow( declaration, header );

   return declaration_range;
}

struct tgsi_declaration_dimension
tgsi_default_declaration_dimension(void)
{
   struct tgsi_declaration_dimension dd;

   dd.Index2D = 0;
   dd.Padding = 0;

   return dd;
}

struct tgsi_declaration_dimension
tgsi_build_declaration_dimension(unsigned index_2d,
                                 struct tgsi_declaration *declaration,
                                 struct tgsi_header *header)
{
   struct tgsi_declaration_dimension dd;

   assert(index_2d <= 0xFFFF);

   dd = tgsi_default_declaration_dimension();
   dd.Index2D = index_2d;

   declaration_grow(declaration, header);

   return dd;
}

struct tgsi_declaration_semantic
tgsi_default_declaration_semantic( void )
{
   struct tgsi_declaration_semantic ds;

   ds.Name = TGSI_SEMANTIC_POSITION;
   ds.Index = 0;
   ds.Padding = 0;

   return ds;
}

struct tgsi_declaration_semantic
tgsi_build_declaration_semantic(
   unsigned semantic_name,
   unsigned semantic_index,
   struct tgsi_declaration *declaration,
   struct tgsi_header *header )
{
   struct tgsi_declaration_semantic ds;

   assert( semantic_name <= TGSI_SEMANTIC_COUNT );
   assert( semantic_index <= 0xFFFF );

   ds = tgsi_default_declaration_semantic();
   ds.Name = semantic_name;
   ds.Index = semantic_index;

   declaration_grow( declaration, header );

   return ds;
d334 1
a334 1
struct tgsi_immediate
d347 1
a347 1
struct tgsi_immediate
d386 1
a386 1
union tgsi_immediate_data
d460 1
a460 1
struct tgsi_instruction
d499 2
a500 2
struct tgsi_full_instruction
tgsi_default_full_instruction( void )
d502 1
a502 2
   struct tgsi_full_instruction full_instruction;
   unsigned i;
d504 7
a510 10
   full_instruction.Instruction = tgsi_default_instruction();
   full_instruction.Predicate = tgsi_default_instruction_predicate();
   full_instruction.Label = tgsi_default_instruction_label();
   full_instruction.Texture = tgsi_default_instruction_texture();
   for( i = 0;  i < TGSI_FULL_MAX_DST_REGISTERS; i++ ) {
      full_instruction.Dst[i] = tgsi_default_full_dst_register();
   }
   for( i = 0;  i < TGSI_FULL_MAX_SRC_REGISTERS; i++ ) {
      full_instruction.Src[i] = tgsi_default_full_src_register();
   }
d512 1
a512 1
   return full_instruction;
d515 9
a523 6
unsigned
tgsi_build_full_instruction(
   const struct tgsi_full_instruction *full_inst,
   struct  tgsi_token *tokens,
   struct  tgsi_header *header,
   unsigned  maxsize )
d525 9
a533 4
   unsigned size = 0;
   unsigned i;
   struct tgsi_instruction *instruction;
   struct tgsi_token *prev_token;
d535 1
a535 4
   if( maxsize <= size )
      return 0;
   instruction = (struct tgsi_instruction *) &tokens[size];
   size++;
d537 2
a538 7
   *instruction = tgsi_build_instruction(full_inst->Instruction.Opcode,
                                         full_inst->Instruction.Saturate,
                                         full_inst->Instruction.Predicate,
                                         full_inst->Instruction.NumDstRegs,
                                         full_inst->Instruction.NumSrcRegs,
                                         header);
   prev_token = (struct tgsi_token  *) instruction;
d540 4
a543 2
   if (full_inst->Instruction.Predicate) {
      struct tgsi_instruction_predicate *instruction_predicate;
d545 1
a545 233
      if (maxsize <= size) {
         return 0;
      }
      instruction_predicate = (struct tgsi_instruction_predicate *)&tokens[size];
      size++;

      *instruction_predicate =
         tgsi_build_instruction_predicate(full_inst->Predicate.Index,
                                          full_inst->Predicate.Negate,
                                          full_inst->Predicate.SwizzleX,
                                          full_inst->Predicate.SwizzleY,
                                          full_inst->Predicate.SwizzleZ,
                                          full_inst->Predicate.SwizzleW,
                                          instruction,
                                          header);
   }

   if (full_inst->Instruction.Label) {
      struct tgsi_instruction_label *instruction_label;

      if( maxsize <= size )
         return 0;
      instruction_label =
         (struct  tgsi_instruction_label *) &tokens[size];
      size++;

      *instruction_label = tgsi_build_instruction_label(
         full_inst->Label.Label,
         prev_token,
         instruction,
         header );
      prev_token = (struct tgsi_token  *) instruction_label;
   }

   if (full_inst->Instruction.Texture) {
      struct tgsi_instruction_texture *instruction_texture;

      if( maxsize <= size )
         return 0;
      instruction_texture =
         (struct  tgsi_instruction_texture *) &tokens[size];
      size++;

      *instruction_texture = tgsi_build_instruction_texture(
         full_inst->Texture.Texture,
         prev_token,
         instruction,
         header   );
      prev_token = (struct tgsi_token  *) instruction_texture;
   }

   for( i = 0;  i <   full_inst->Instruction.NumDstRegs; i++ ) {
      const struct tgsi_full_dst_register *reg = &full_inst->Dst[i];
      struct tgsi_dst_register *dst_register;
      struct tgsi_token *prev_token;

      if( maxsize <= size )
         return 0;
      dst_register = (struct tgsi_dst_register *) &tokens[size];
      size++;

      *dst_register = tgsi_build_dst_register(
         reg->Register.File,
         reg->Register.WriteMask,
         reg->Register.Indirect,
         reg->Register.Index,
         instruction,
         header );
      prev_token = (struct tgsi_token  *) dst_register;

      if( reg->Register.Indirect ) {
         struct tgsi_src_register *ind;

         if( maxsize <= size )
            return 0;
         ind = (struct tgsi_src_register *) &tokens[size];
         size++;

         *ind = tgsi_build_src_register(
            reg->Indirect.File,
            reg->Indirect.SwizzleX,
            reg->Indirect.SwizzleY,
            reg->Indirect.SwizzleZ,
            reg->Indirect.SwizzleW,
            reg->Indirect.Negate,
            reg->Indirect.Absolute,
            reg->Indirect.Indirect,
            reg->Indirect.Dimension,
            reg->Indirect.Index,
            instruction,
            header );
      }
   }

   for( i = 0;  i < full_inst->Instruction.NumSrcRegs; i++ ) {
      const struct tgsi_full_src_register *reg = &full_inst->Src[i];
      struct tgsi_src_register *src_register;
      struct tgsi_token *prev_token;

      if( maxsize <= size )
         return 0;
      src_register = (struct tgsi_src_register *)  &tokens[size];
      size++;

      *src_register = tgsi_build_src_register(
         reg->Register.File,
         reg->Register.SwizzleX,
         reg->Register.SwizzleY,
         reg->Register.SwizzleZ,
         reg->Register.SwizzleW,
         reg->Register.Negate,
         reg->Register.Absolute,
         reg->Register.Indirect,
         reg->Register.Dimension,
         reg->Register.Index,
         instruction,
         header );
      prev_token = (struct tgsi_token  *) src_register;

      if( reg->Register.Indirect ) {
         struct  tgsi_src_register *ind;

         if( maxsize <= size )
            return 0;
         ind = (struct tgsi_src_register *) &tokens[size];
         size++;

         *ind = tgsi_build_src_register(
            reg->Indirect.File,
            reg->Indirect.SwizzleX,
            reg->Indirect.SwizzleY,
            reg->Indirect.SwizzleZ,
            reg->Indirect.SwizzleW,
            reg->Indirect.Negate,
            reg->Indirect.Absolute,
            reg->Indirect.Indirect,
            reg->Indirect.Dimension,
            reg->Indirect.Index,
            instruction,
            header );
      }

      if( reg->Register.Dimension ) {
         struct  tgsi_dimension *dim;

         assert( !reg->Dimension.Dimension );

         if( maxsize <= size )
            return 0;
         dim = (struct tgsi_dimension *) &tokens[size];
         size++;

         *dim = tgsi_build_dimension(
            reg->Dimension.Indirect,
            reg->Dimension.Index,
            instruction,
            header );

         if( reg->Dimension.Indirect ) {
            struct tgsi_src_register *ind;

            if( maxsize <= size )
               return 0;
            ind = (struct tgsi_src_register *) &tokens[size];
            size++;

            *ind = tgsi_build_src_register(
               reg->DimIndirect.File,
               reg->DimIndirect.SwizzleX,
               reg->DimIndirect.SwizzleY,
               reg->DimIndirect.SwizzleZ,
               reg->DimIndirect.SwizzleW,
               reg->DimIndirect.Negate,
               reg->DimIndirect.Absolute,
               reg->DimIndirect.Indirect,
               reg->DimIndirect.Dimension,
               reg->DimIndirect.Index,
               instruction,
               header );
         }
      }
   }

   return size;
}

struct tgsi_instruction_predicate
tgsi_default_instruction_predicate(void)
{
   struct tgsi_instruction_predicate instruction_predicate;

   instruction_predicate.SwizzleX = TGSI_SWIZZLE_X;
   instruction_predicate.SwizzleY = TGSI_SWIZZLE_Y;
   instruction_predicate.SwizzleZ = TGSI_SWIZZLE_Z;
   instruction_predicate.SwizzleW = TGSI_SWIZZLE_W;
   instruction_predicate.Negate = 0;
   instruction_predicate.Index = 0;
   instruction_predicate.Padding = 0;

   return instruction_predicate;
}

struct tgsi_instruction_predicate
tgsi_build_instruction_predicate(int index,
                                 unsigned negate,
                                 unsigned swizzleX,
                                 unsigned swizzleY,
                                 unsigned swizzleZ,
                                 unsigned swizzleW,
                                 struct tgsi_instruction *instruction,
                                 struct tgsi_header *header)
{
   struct tgsi_instruction_predicate instruction_predicate;

   instruction_predicate = tgsi_default_instruction_predicate();
   instruction_predicate.SwizzleX = swizzleX;
   instruction_predicate.SwizzleY = swizzleY;
   instruction_predicate.SwizzleZ = swizzleZ;
   instruction_predicate.SwizzleW = swizzleW;
   instruction_predicate.Negate = negate;
   instruction_predicate.Index = index;

   instruction_grow(instruction, header);

   return instruction_predicate;
}

struct tgsi_instruction_label
tgsi_default_instruction_label( void )
{
   struct tgsi_instruction_label instruction_label;

   instruction_label.Label = 0;
d551 1
a551 1
struct tgsi_instruction_label
a559 1
   instruction_label = tgsi_default_instruction_label();
d561 1
d569 1
a569 1
struct tgsi_instruction_texture
d580 1
a580 1
struct tgsi_instruction_texture
a588 1
   instruction_texture = tgsi_default_instruction_texture();
d590 1
d598 1
a598 1
struct tgsi_src_register
d617 1
a617 1
struct tgsi_src_register
a641 1
   src_register = tgsi_default_src_register();
d658 14
a671 1
struct tgsi_full_src_register
d684 6
a689 3

struct tgsi_dimension
tgsi_default_dimension( void )
d693 1
a693 1
   dimension.Indirect = 0;
d696 1
a696 17
   dimension.Index = 0;

   return dimension;
}

struct tgsi_dimension
tgsi_build_dimension(
   unsigned indirect,
   unsigned index,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_dimension dimension;

   dimension = tgsi_default_dimension();
   dimension.Indirect = indirect;
   dimension.Index = index;
d703 1
a703 1
struct tgsi_dst_register
d718 1
a718 1
struct tgsi_dst_register
d723 1
a733 1
   dst_register = tgsi_default_dst_register();
d736 2
d739 1
a739 1
   dst_register.Indirect = indirect;
d746 1
a746 1
struct tgsi_full_dst_register
d753 2
d759 276
a1034 1
struct tgsi_property
d1047 1
a1047 1
struct tgsi_property
d1086 1
a1086 1
struct tgsi_property_data
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d67 11
d84 1
a85 1
   processor.Padding = 0;
d96 1
a96 13
static void
declaration_grow(
   struct tgsi_declaration *declaration,
   struct tgsi_header *header )
{
   assert( declaration->NrTokens < 0xFF );

   declaration->NrTokens++;

   header_bodysize_grow( header );
}

static struct tgsi_declaration
d115 1
a115 1
static struct tgsi_declaration
d147 2
a148 15
static struct tgsi_declaration_range
tgsi_default_declaration_range( void )
{
   struct tgsi_declaration_range dr;

   dr.First = 0;
   dr.Last = 0;

   return dr;
}

static struct tgsi_declaration_range
tgsi_build_declaration_range(
   unsigned first,
   unsigned last,
d152 1
a152 1
   struct tgsi_declaration_range declaration_range;
d154 1
a154 2
   assert( last >= first );
   assert( last <= 0xFFFF );
d156 1
a156 56
   declaration_range.First = first;
   declaration_range.Last = last;

   declaration_grow( declaration, header );

   return declaration_range;
}

static struct tgsi_declaration_dimension
tgsi_build_declaration_dimension(unsigned index_2d,
                                 struct tgsi_declaration *declaration,
                                 struct tgsi_header *header)
{
   struct tgsi_declaration_dimension dd;

   assert(index_2d <= 0xFFFF);

   dd.Index2D = index_2d;
   dd.Padding = 0;

   declaration_grow(declaration, header);

   return dd;
}

static struct tgsi_declaration_semantic
tgsi_default_declaration_semantic( void )
{
   struct tgsi_declaration_semantic ds;

   ds.Name = TGSI_SEMANTIC_POSITION;
   ds.Index = 0;
   ds.Padding = 0;

   return ds;
}

static struct tgsi_declaration_semantic
tgsi_build_declaration_semantic(
   unsigned semantic_name,
   unsigned semantic_index,
   struct tgsi_declaration *declaration,
   struct tgsi_header *header )
{
   struct tgsi_declaration_semantic ds;

   assert( semantic_name <= TGSI_SEMANTIC_COUNT );
   assert( semantic_index <= 0xFFFF );

   ds.Name = semantic_name;
   ds.Index = semantic_index;
   ds.Padding = 0;

   declaration_grow( declaration, header );

   return ds;
a166 1
   full_declaration.ImmediateData.u = NULL;
d183 1
a183 1
      return 0;
d238 86
a323 3
   if (full_decl->Declaration.File == TGSI_FILE_IMMEDIATE_ARRAY) {
      unsigned i, j;
      union tgsi_immediate_data *data;
d325 3
a327 7
      for (i = 0; i <= dr->Last; ++i) {
         for (j = 0; j < 4; ++j) {
            unsigned idx = i*4 + j;
            if (maxsize <= size)
               return 0;
            data = (union tgsi_immediate_data *) &tokens[size];
            ++size;
d329 1
a329 5
            *data = full_decl->ImmediateData.u[idx];
            declaration_grow( declaration, header );
         }
      }
   }
d331 1
a331 1
   return size;
d338 1
a338 1
static struct tgsi_immediate
d351 1
a351 1
static struct tgsi_immediate
d390 1
a390 1
static union tgsi_immediate_data
d464 1
a464 1
static struct tgsi_instruction
d503 2
a504 2
struct tgsi_instruction_predicate
tgsi_default_instruction_predicate(void)
d506 2
a507 1
   struct tgsi_instruction_predicate instruction_predicate;
d509 10
a518 7
   instruction_predicate.SwizzleX = TGSI_SWIZZLE_X;
   instruction_predicate.SwizzleY = TGSI_SWIZZLE_Y;
   instruction_predicate.SwizzleZ = TGSI_SWIZZLE_Z;
   instruction_predicate.SwizzleW = TGSI_SWIZZLE_W;
   instruction_predicate.Negate = 0;
   instruction_predicate.Index = 0;
   instruction_predicate.Padding = 0;
d520 1
a520 1
   return instruction_predicate;
d523 6
a528 9
static struct tgsi_instruction_predicate
tgsi_build_instruction_predicate(int index,
                                 unsigned negate,
                                 unsigned swizzleX,
                                 unsigned swizzleY,
                                 unsigned swizzleZ,
                                 unsigned swizzleW,
                                 struct tgsi_instruction *instruction,
                                 struct tgsi_header *header)
d530 4
a533 1
   struct tgsi_instruction_predicate instruction_predicate;
d535 4
a538 7
   instruction_predicate = tgsi_default_instruction_predicate();
   instruction_predicate.SwizzleX = swizzleX;
   instruction_predicate.SwizzleY = swizzleY;
   instruction_predicate.SwizzleZ = swizzleZ;
   instruction_predicate.SwizzleW = swizzleW;
   instruction_predicate.Negate = negate;
   instruction_predicate.Index = index;
d540 7
a546 1
   instruction_grow(instruction, header);
d548 2
a549 2
   return instruction_predicate;
}
d551 228
a778 1
static struct tgsi_instruction_label
d789 1
a789 1
static struct tgsi_instruction_label
d798 1
a799 1
   instruction_label.Padding = 0;
d807 1
a807 1
static struct tgsi_instruction_texture
d818 1
a818 1
static struct tgsi_instruction_texture
d827 1
a828 1
   instruction_texture.Padding = 0;
d836 1
a836 1
static struct tgsi_src_register
d855 1
a855 1
static struct tgsi_src_register
d880 1
d897 15
a911 1
static struct tgsi_dimension
d924 1
a924 14
static struct tgsi_full_src_register
tgsi_default_full_src_register( void )
{
   struct tgsi_full_src_register full_src_register;

   full_src_register.Register = tgsi_default_src_register();
   full_src_register.Indirect = tgsi_default_src_register();
   full_src_register.Dimension = tgsi_default_dimension();
   full_src_register.DimIndirect = tgsi_default_src_register();

   return full_src_register;
}

static struct tgsi_dimension
d933 1
a934 2
   dimension.Dimension = 0;
   dimension.Padding = 0;
d942 1
a942 1
static struct tgsi_dst_register
d957 1
a957 1
static struct tgsi_dst_register
a961 1
   unsigned dimension,
d972 1
d975 1
a976 3
   dst_register.Dimension = dimension;
   dst_register.Index = index;
   dst_register.Padding = 0;
d983 1
a983 1
static struct tgsi_full_dst_register
a989 2
   full_dst_register.Dimension = tgsi_default_dimension();
   full_dst_register.DimIndirect = tgsi_default_src_register();
d994 1
a994 276
struct tgsi_full_instruction
tgsi_default_full_instruction( void )
{
   struct tgsi_full_instruction full_instruction;
   unsigned i;

   full_instruction.Instruction = tgsi_default_instruction();
   full_instruction.Predicate = tgsi_default_instruction_predicate();
   full_instruction.Label = tgsi_default_instruction_label();
   full_instruction.Texture = tgsi_default_instruction_texture();
   for( i = 0;  i < TGSI_FULL_MAX_DST_REGISTERS; i++ ) {
      full_instruction.Dst[i] = tgsi_default_full_dst_register();
   }
   for( i = 0;  i < TGSI_FULL_MAX_SRC_REGISTERS; i++ ) {
      full_instruction.Src[i] = tgsi_default_full_src_register();
   }

   return full_instruction;
}

unsigned
tgsi_build_full_instruction(
   const struct tgsi_full_instruction *full_inst,
   struct  tgsi_token *tokens,
   struct  tgsi_header *header,
   unsigned  maxsize )
{
   unsigned size = 0;
   unsigned i;
   struct tgsi_instruction *instruction;
   struct tgsi_token *prev_token;

   if( maxsize <= size )
      return 0;
   instruction = (struct tgsi_instruction *) &tokens[size];
   size++;

   *instruction = tgsi_build_instruction(full_inst->Instruction.Opcode,
                                         full_inst->Instruction.Saturate,
                                         full_inst->Instruction.Predicate,
                                         full_inst->Instruction.NumDstRegs,
                                         full_inst->Instruction.NumSrcRegs,
                                         header);
   prev_token = (struct tgsi_token  *) instruction;

   if (full_inst->Instruction.Predicate) {
      struct tgsi_instruction_predicate *instruction_predicate;

      if (maxsize <= size) {
         return 0;
      }
      instruction_predicate = (struct tgsi_instruction_predicate *)&tokens[size];
      size++;

      *instruction_predicate =
         tgsi_build_instruction_predicate(full_inst->Predicate.Index,
                                          full_inst->Predicate.Negate,
                                          full_inst->Predicate.SwizzleX,
                                          full_inst->Predicate.SwizzleY,
                                          full_inst->Predicate.SwizzleZ,
                                          full_inst->Predicate.SwizzleW,
                                          instruction,
                                          header);
   }

   if (full_inst->Instruction.Label) {
      struct tgsi_instruction_label *instruction_label;

      if( maxsize <= size )
         return 0;
      instruction_label =
         (struct  tgsi_instruction_label *) &tokens[size];
      size++;

      *instruction_label = tgsi_build_instruction_label(
         full_inst->Label.Label,
         prev_token,
         instruction,
         header );
      prev_token = (struct tgsi_token  *) instruction_label;
   }

   if (full_inst->Instruction.Texture) {
      struct tgsi_instruction_texture *instruction_texture;

      if( maxsize <= size )
         return 0;
      instruction_texture =
         (struct  tgsi_instruction_texture *) &tokens[size];
      size++;

      *instruction_texture = tgsi_build_instruction_texture(
         full_inst->Texture.Texture,
         prev_token,
         instruction,
         header   );
      prev_token = (struct tgsi_token  *) instruction_texture;
   }

   for( i = 0;  i <   full_inst->Instruction.NumDstRegs; i++ ) {
      const struct tgsi_full_dst_register *reg = &full_inst->Dst[i];
      struct tgsi_dst_register *dst_register;
      struct tgsi_token *prev_token;

      if( maxsize <= size )
         return 0;
      dst_register = (struct tgsi_dst_register *) &tokens[size];
      size++;

      *dst_register = tgsi_build_dst_register(
         reg->Register.File,
         reg->Register.WriteMask,
         reg->Register.Indirect,
         reg->Register.Dimension,
         reg->Register.Index,
         instruction,
         header );
      prev_token = (struct tgsi_token  *) dst_register;

      if( reg->Register.Indirect ) {
         struct tgsi_src_register *ind;

         if( maxsize <= size )
            return 0;
         ind = (struct tgsi_src_register *) &tokens[size];
         size++;

         *ind = tgsi_build_src_register(
            reg->Indirect.File,
            reg->Indirect.SwizzleX,
            reg->Indirect.SwizzleY,
            reg->Indirect.SwizzleZ,
            reg->Indirect.SwizzleW,
            reg->Indirect.Negate,
            reg->Indirect.Absolute,
            reg->Indirect.Indirect,
            reg->Indirect.Dimension,
            reg->Indirect.Index,
            instruction,
            header );
      }

      if( reg->Register.Dimension ) {
         struct  tgsi_dimension *dim;

         assert( !reg->Dimension.Dimension );

         if( maxsize <= size )
            return 0;
         dim = (struct tgsi_dimension *) &tokens[size];
         size++;

         *dim = tgsi_build_dimension(
            reg->Dimension.Indirect,
            reg->Dimension.Index,
            instruction,
            header );

         if( reg->Dimension.Indirect ) {
            struct tgsi_src_register *ind;

            if( maxsize <= size )
               return 0;
            ind = (struct tgsi_src_register *) &tokens[size];
            size++;

            *ind = tgsi_build_src_register(
               reg->DimIndirect.File,
               reg->DimIndirect.SwizzleX,
               reg->DimIndirect.SwizzleY,
               reg->DimIndirect.SwizzleZ,
               reg->DimIndirect.SwizzleW,
               reg->DimIndirect.Negate,
               reg->DimIndirect.Absolute,
               reg->DimIndirect.Indirect,
               reg->DimIndirect.Dimension,
               reg->DimIndirect.Index,
               instruction,
               header );
         }
      }
   }

   for( i = 0;  i < full_inst->Instruction.NumSrcRegs; i++ ) {
      const struct tgsi_full_src_register *reg = &full_inst->Src[i];
      struct tgsi_src_register *src_register;
      struct tgsi_token *prev_token;

      if( maxsize <= size )
         return 0;
      src_register = (struct tgsi_src_register *)  &tokens[size];
      size++;

      *src_register = tgsi_build_src_register(
         reg->Register.File,
         reg->Register.SwizzleX,
         reg->Register.SwizzleY,
         reg->Register.SwizzleZ,
         reg->Register.SwizzleW,
         reg->Register.Negate,
         reg->Register.Absolute,
         reg->Register.Indirect,
         reg->Register.Dimension,
         reg->Register.Index,
         instruction,
         header );
      prev_token = (struct tgsi_token  *) src_register;

      if( reg->Register.Indirect ) {
         struct  tgsi_src_register *ind;

         if( maxsize <= size )
            return 0;
         ind = (struct tgsi_src_register *) &tokens[size];
         size++;

         *ind = tgsi_build_src_register(
            reg->Indirect.File,
            reg->Indirect.SwizzleX,
            reg->Indirect.SwizzleY,
            reg->Indirect.SwizzleZ,
            reg->Indirect.SwizzleW,
            reg->Indirect.Negate,
            reg->Indirect.Absolute,
            reg->Indirect.Indirect,
            reg->Indirect.Dimension,
            reg->Indirect.Index,
            instruction,
            header );
      }

      if( reg->Register.Dimension ) {
         struct  tgsi_dimension *dim;

         assert( !reg->Dimension.Dimension );

         if( maxsize <= size )
            return 0;
         dim = (struct tgsi_dimension *) &tokens[size];
         size++;

         *dim = tgsi_build_dimension(
            reg->Dimension.Indirect,
            reg->Dimension.Index,
            instruction,
            header );

         if( reg->Dimension.Indirect ) {
            struct tgsi_src_register *ind;

            if( maxsize <= size )
               return 0;
            ind = (struct tgsi_src_register *) &tokens[size];
            size++;

            *ind = tgsi_build_src_register(
               reg->DimIndirect.File,
               reg->DimIndirect.SwizzleX,
               reg->DimIndirect.SwizzleY,
               reg->DimIndirect.SwizzleZ,
               reg->DimIndirect.SwizzleW,
               reg->DimIndirect.Negate,
               reg->DimIndirect.Absolute,
               reg->DimIndirect.Indirect,
               reg->DimIndirect.Dimension,
               reg->DimIndirect.Index,
               instruction,
               header );
         }
      }
   }

   return size;
}

static struct tgsi_property
d1007 1
a1007 1
static struct tgsi_property
d1046 1
a1046 1
static struct tgsi_property_data
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a28 1
#include "pipe/p_format.h"
d106 1
a106 1
   declaration.Interpolate = 0;
d109 1
d111 1
a111 3
   declaration.Local = 0;
   declaration.Array = 0;
   declaration.Padding = 0;
d123 1
d125 1
a125 1
   unsigned local,
d139 1
d141 1
a141 1
   declaration.Local = local;
a195 32
static struct tgsi_declaration_interp
tgsi_default_declaration_interp( void )
{
   struct tgsi_declaration_interp di;

   di.Interpolate = TGSI_INTERPOLATE_CONSTANT;
   di.Centroid = 0;
   di.CylindricalWrap = 0;
   di.Padding = 0;

   return di;
}

static struct tgsi_declaration_interp
tgsi_build_declaration_interp(unsigned interpolate,
                              unsigned centroid,
                              unsigned cylindrical_wrap,
                              struct tgsi_declaration *declaration,
                              struct tgsi_header *header)
{
   struct tgsi_declaration_interp di;

   di.Interpolate = interpolate;
   di.Centroid = centroid;
   di.CylindricalWrap = cylindrical_wrap;
   di.Padding = 0;

   declaration_grow(declaration, header);

   return di;
}

a228 81
static struct tgsi_declaration_resource
tgsi_default_declaration_resource(void)
{
   struct tgsi_declaration_resource dr;

   dr.Resource = TGSI_TEXTURE_BUFFER;
   dr.Raw = 0;
   dr.Writable = 0;
   dr.Padding = 0;

   return dr;
}

static struct tgsi_declaration_resource
tgsi_build_declaration_resource(unsigned texture,
                                unsigned raw,
                                unsigned writable,
                                struct tgsi_declaration *declaration,
                                struct tgsi_header *header)
{
   struct tgsi_declaration_resource dr;

   dr = tgsi_default_declaration_resource();
   dr.Resource = texture;
   dr.Raw = raw;
   dr.Writable = writable;

   declaration_grow(declaration, header);

   return dr;
}

static struct tgsi_declaration_sampler_view
tgsi_default_declaration_sampler_view(void)
{
   struct tgsi_declaration_sampler_view dsv;

   dsv.Resource = TGSI_TEXTURE_BUFFER;
   dsv.ReturnTypeX = PIPE_TYPE_UNORM;
   dsv.ReturnTypeY = PIPE_TYPE_UNORM;
   dsv.ReturnTypeZ = PIPE_TYPE_UNORM;
   dsv.ReturnTypeW = PIPE_TYPE_UNORM;

   return dsv;
}

static struct tgsi_declaration_sampler_view
tgsi_build_declaration_sampler_view(unsigned texture,
                                    unsigned return_type_x,
                                    unsigned return_type_y,
                                    unsigned return_type_z,
                                    unsigned return_type_w,
                                    struct tgsi_declaration *declaration,
                                    struct tgsi_header *header)
{
   struct tgsi_declaration_sampler_view dsv;

   dsv = tgsi_default_declaration_sampler_view();
   dsv.Resource = texture;
   dsv.ReturnTypeX = return_type_x;
   dsv.ReturnTypeY = return_type_y;
   dsv.ReturnTypeZ = return_type_z;
   dsv.ReturnTypeW = return_type_w;

   declaration_grow(declaration, header);

   return dsv;
}


static struct tgsi_declaration_array
tgsi_default_declaration_array( void )
{
   struct tgsi_declaration_array a;

   a.ArrayID = 0;
   a.Padding = 0;

   return a;
}

d237 1
a237 4
   full_declaration.Interp = tgsi_default_declaration_interp();
   full_declaration.Resource = tgsi_default_declaration_resource();
   full_declaration.SamplerView = tgsi_default_declaration_sampler_view();
   full_declaration.Array = tgsi_default_declaration_array();
d264 1
d266 1
a266 1
      full_decl->Declaration.Local,
a293 16
   if (full_decl->Declaration.Interpolate) {
      struct tgsi_declaration_interp *di;

      if (maxsize <= size) {
         return 0;
      }
      di = (struct tgsi_declaration_interp *)&tokens[size];
      size++;

      *di = tgsi_build_declaration_interp(full_decl->Interp.Interpolate,
                                          full_decl->Interp.Centroid,
                                          full_decl->Interp.CylindricalWrap,
                                          declaration,
                                          header);
   }

d309 3
a311 2
   if (full_decl->Declaration.File == TGSI_FILE_RESOURCE) {
      struct tgsi_declaration_resource *dr;
d313 7
a319 5
      if (maxsize <= size) {
         return  0;
      }
      dr = (struct tgsi_declaration_resource *)&tokens[size];
      size++;
d321 3
a323 12
      *dr = tgsi_build_declaration_resource(full_decl->Resource.Resource,
                                            full_decl->Resource.Raw,
                                            full_decl->Resource.Writable,
                                            declaration,
                                            header);
   }

   if (full_decl->Declaration.File == TGSI_FILE_SAMPLER_VIEW) {
      struct tgsi_declaration_sampler_view *dsv;

      if (maxsize <= size) {
         return  0;
a324 11
      dsv = (struct tgsi_declaration_sampler_view *)&tokens[size];
      size++;

      *dsv = tgsi_build_declaration_sampler_view(
         full_decl->SamplerView.Resource,
         full_decl->SamplerView.ReturnTypeX,
         full_decl->SamplerView.ReturnTypeY,
         full_decl->SamplerView.ReturnTypeZ,
         full_decl->SamplerView.ReturnTypeW,
         declaration,
         header);
d349 1
a349 2
   struct tgsi_header *header,
   unsigned type )
a353 1
   immediate.DataType = type;
d386 15
d416 1
a416 1
   *immediate = tgsi_build_immediate( header, full_imm->Immediate.DataType );
a424 1

d426 1
a426 1
      *data = full_imm->u[i];
d428 4
a431 2
      immediate_grow( immediate, header );
      size++;
a574 1
   instruction_texture.NumOffsets = 0;
a582 1
   unsigned num_offsets,
a589 1
   instruction_texture.NumOffsets = num_offsets;
a597 37

static struct tgsi_texture_offset
tgsi_default_texture_offset( void )
{
   struct tgsi_texture_offset texture_offset;

   texture_offset.Index = 0;
   texture_offset.File = 0;
   texture_offset.SwizzleX = 0;
   texture_offset.SwizzleY = 0;
   texture_offset.SwizzleZ = 0;
   texture_offset.Padding = 0;

   return texture_offset;
}

static struct tgsi_texture_offset
tgsi_build_texture_offset(
   int index, int file, int swizzle_x, int swizzle_y, int swizzle_z,
   struct tgsi_token *prev_token,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_texture_offset texture_offset;

   texture_offset.Index = index;
   texture_offset.File = file;
   texture_offset.SwizzleX = swizzle_x;
   texture_offset.SwizzleY = swizzle_y;
   texture_offset.SwizzleZ = swizzle_z;
   texture_offset.Padding = 0;

   instruction_grow( instruction, header );

   return texture_offset;
}

a657 38
static struct tgsi_ind_register
tgsi_default_ind_register( void )
{
   struct tgsi_ind_register ind_register;

   ind_register.File = TGSI_FILE_NULL;
   ind_register.Index = 0;
   ind_register.Swizzle = TGSI_SWIZZLE_X;
   ind_register.ArrayID = 0;

   return ind_register;
}

static struct tgsi_ind_register
tgsi_build_ind_register(
   unsigned file,
   unsigned swizzle,
   unsigned arrayid,
   int index,
   struct tgsi_instruction *instruction,
   struct tgsi_header *header )
{
   struct tgsi_ind_register   ind_register;

   assert( file < TGSI_FILE_COUNT );
   assert( swizzle <= TGSI_SWIZZLE_W );
   assert( index >= -0x8000 && index <= 0x7FFF );

   ind_register.File = file;
   ind_register.Swizzle = swizzle;
   ind_register.Index = index;
   ind_register.ArrayID = arrayid;

   instruction_grow( instruction, header );

   return ind_register;
}

d677 1
a677 1
   full_src_register.Indirect = tgsi_default_ind_register();
d679 1
a679 1
   full_src_register.DimIndirect = tgsi_default_ind_register();
d752 1
a752 1
   full_dst_register.Indirect = tgsi_default_ind_register();
d754 1
a754 1
   full_dst_register.DimIndirect = tgsi_default_ind_register();
a768 3
   for( i = 0;  i < TGSI_FULL_MAX_TEX_OFFSETS; i++ ) {
      full_instruction.TexOffsets[i] = tgsi_default_texture_offset();
   }
a851 1
	 full_inst->Texture.NumOffsets,
d856 1
a857 19
      for (i = 0; i < full_inst->Texture.NumOffsets; i++) {
         struct tgsi_texture_offset *texture_offset;
	
         if ( maxsize <= size )
            return 0;
	 texture_offset = (struct tgsi_texture_offset *)&tokens[size];
         size++;
         *texture_offset = tgsi_build_texture_offset(
            full_inst->TexOffsets[i].Index,
            full_inst->TexOffsets[i].File,
            full_inst->TexOffsets[i].SwizzleX,
            full_inst->TexOffsets[i].SwizzleY,
            full_inst->TexOffsets[i].SwizzleZ,
            prev_token,
            instruction,
            header);
         prev_token = (struct tgsi_token *) texture_offset;
      }
   }
d861 1
d876 1
d879 1
a879 1
         struct tgsi_ind_register *ind;
d883 1
a883 1
         ind = (struct tgsi_ind_register *) &tokens[size];
d886 1
a886 1
         *ind = tgsi_build_ind_register(
d888 8
a895 1
            reg->Indirect.Swizzle,
a896 1
            reg->Indirect.ArrayID,
d918 1
a918 1
            struct tgsi_ind_register *ind;
d922 1
a922 1
            ind = (struct tgsi_ind_register *) &tokens[size];
d925 1
a925 1
            *ind = tgsi_build_ind_register(
d927 8
a934 1
               reg->DimIndirect.Swizzle,
a935 1
               reg->DimIndirect.ArrayID,
d945 1
d965 1
d968 1
a968 1
         struct  tgsi_ind_register *ind;
d972 1
a972 1
         ind = (struct tgsi_ind_register *) &tokens[size];
d975 1
a975 1
         *ind = tgsi_build_ind_register(
d977 8
a984 1
            reg->Indirect.Swizzle,
a985 1
            reg->Indirect.ArrayID,
d1007 1
a1007 1
            struct tgsi_ind_register *ind;
d1011 1
a1011 1
            ind = (struct tgsi_ind_register *) &tokens[size];
d1014 1
a1014 1
            *ind = tgsi_build_ind_register(
d1016 8
a1023 1
               reg->DimIndirect.Swizzle,
a1024 1
               reg->DimIndirect.ArrayID,
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a126 1
   unsigned array,
d142 1
a142 1
   declaration.Array = array;
a341 15
static struct tgsi_declaration_array
tgsi_build_declaration_array(unsigned arrayid,
                             struct tgsi_declaration *declaration,
                             struct tgsi_header *header)
{
   struct tgsi_declaration_array da;

   da = tgsi_default_declaration_array();
   da.ArrayID = arrayid;

   declaration_grow(declaration, header);

   return da;
}

a381 1
      full_decl->Declaration.Array,
a474 13
   if (full_decl->Declaration.Array) {
      struct tgsi_declaration_array *da;

      if (maxsize <= size) {
         return 0;
      }
      da = (struct tgsi_declaration_array *)&tokens[size];
      size++;
      *da = tgsi_build_declaration_array(
         full_decl->Array.ArrayID,
         declaration,
         header);
   }
d849 1
a850 1
   unsigned arrayid,
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d203 1
a203 1
   di.Location = TGSI_INTERPOLATE_LOC_CENTER;
d212 1
a212 1
                              unsigned interpolate_location,
d220 1
a220 1
   di.Location = interpolate_location;
d300 4
a303 4
   dsv.ReturnTypeX = TGSI_RETURN_TYPE_UNORM;
   dsv.ReturnTypeY = TGSI_RETURN_TYPE_UNORM;
   dsv.ReturnTypeZ = TGSI_RETURN_TYPE_UNORM;
   dsv.ReturnTypeW = TGSI_RETURN_TYPE_UNORM;
d436 1
a436 1
                                          full_decl->Interp.Location,
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d203 1
a203 1
   di.Centroid = 0;
d212 1
a212 1
                              unsigned centroid,
d220 1
a220 1
   di.Centroid = centroid;
d300 4
a303 4
   dsv.ReturnTypeX = PIPE_TYPE_UNORM;
   dsv.ReturnTypeY = PIPE_TYPE_UNORM;
   dsv.ReturnTypeZ = PIPE_TYPE_UNORM;
   dsv.ReturnTypeW = PIPE_TYPE_UNORM;
d436 1
a436 1
                                          full_decl->Interp.Centroid,
@


