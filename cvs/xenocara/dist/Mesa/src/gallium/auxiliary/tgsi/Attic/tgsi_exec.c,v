head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.27;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.44;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.46;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.33;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.40;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007-2008 VMware, Inc.
 * All Rights Reserved.
 * Copyright 2009-2010 VMware, Inc.  All rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * TGSI interpreter/executor.
 *
 * Flow control information:
 *
 * Since we operate on 'quads' (4 pixels or 4 vertices in parallel)
 * flow control statements (IF/ELSE/ENDIF, LOOP/ENDLOOP) require special
 * care since a condition may be true for some quad components but false
 * for other components.
 *
 * We basically execute all statements (even if they're in the part of
 * an IF/ELSE clause that's "not taken") and use a special mask to
 * control writing to destination registers.  This is the ExecMask.
 * See store_dest().
 *
 * The ExecMask is computed from three other masks (CondMask, LoopMask and
 * ContMask) which are controlled by the flow control instructions (namely:
 * (IF/ELSE/ENDIF, LOOP/ENDLOOP and CONT).
 *
 *
 * Authors:
 *   Michal Krol
 *   Brian Paul
 */

#include "pipe/p_compiler.h"
#include "pipe/p_state.h"
#include "pipe/p_shader_tokens.h"
#include "tgsi/tgsi_dump.h"
#include "tgsi/tgsi_parse.h"
#include "tgsi/tgsi_util.h"
#include "tgsi_exec.h"
#include "util/u_memory.h"
#include "util/u_math.h"


#define DEBUG_EXECUTION 0


#define FAST_MATH 0

#define TILE_TOP_LEFT     0
#define TILE_TOP_RIGHT    1
#define TILE_BOTTOM_LEFT  2
#define TILE_BOTTOM_RIGHT 3

static void
micro_abs(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = fabsf(src->f[0]);
   dst->f[1] = fabsf(src->f[1]);
   dst->f[2] = fabsf(src->f[2]);
   dst->f[3] = fabsf(src->f[3]);
}

static void
micro_arl(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->i[0] = (int)floorf(src->f[0]);
   dst->i[1] = (int)floorf(src->f[1]);
   dst->i[2] = (int)floorf(src->f[2]);
   dst->i[3] = (int)floorf(src->f[3]);
}

static void
micro_arr(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->i[0] = (int)floorf(src->f[0] + 0.5f);
   dst->i[1] = (int)floorf(src->f[1] + 0.5f);
   dst->i[2] = (int)floorf(src->f[2] + 0.5f);
   dst->i[3] = (int)floorf(src->f[3] + 0.5f);
}

static void
micro_ceil(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->f[0] = ceilf(src->f[0]);
   dst->f[1] = ceilf(src->f[1]);
   dst->f[2] = ceilf(src->f[2]);
   dst->f[3] = ceilf(src->f[3]);
}

static void
micro_clamp(union tgsi_exec_channel *dst,
            const union tgsi_exec_channel *src0,
            const union tgsi_exec_channel *src1,
            const union tgsi_exec_channel *src2)
{
   dst->f[0] = src0->f[0] < src1->f[0] ? src1->f[0] : src0->f[0] > src2->f[0] ? src2->f[0] : src0->f[0];
   dst->f[1] = src0->f[1] < src1->f[1] ? src1->f[1] : src0->f[1] > src2->f[1] ? src2->f[1] : src0->f[1];
   dst->f[2] = src0->f[2] < src1->f[2] ? src1->f[2] : src0->f[2] > src2->f[2] ? src2->f[2] : src0->f[2];
   dst->f[3] = src0->f[3] < src1->f[3] ? src1->f[3] : src0->f[3] > src2->f[3] ? src2->f[3] : src0->f[3];
}

static void
micro_cmp(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1,
          const union tgsi_exec_channel *src2)
{
   dst->f[0] = src0->f[0] < 0.0f ? src1->f[0] : src2->f[0];
   dst->f[1] = src0->f[1] < 0.0f ? src1->f[1] : src2->f[1];
   dst->f[2] = src0->f[2] < 0.0f ? src1->f[2] : src2->f[2];
   dst->f[3] = src0->f[3] < 0.0f ? src1->f[3] : src2->f[3];
}

static void
micro_cnd(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1,
          const union tgsi_exec_channel *src2)
{
   dst->f[0] = src2->f[0] > 0.5f ? src0->f[0] : src1->f[0];
   dst->f[1] = src2->f[1] > 0.5f ? src0->f[1] : src1->f[1];
   dst->f[2] = src2->f[2] > 0.5f ? src0->f[2] : src1->f[2];
   dst->f[3] = src2->f[3] > 0.5f ? src0->f[3] : src1->f[3];
}

static void
micro_cos(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = cosf(src->f[0]);
   dst->f[1] = cosf(src->f[1]);
   dst->f[2] = cosf(src->f[2]);
   dst->f[3] = cosf(src->f[3]);
}

static void
micro_ddx(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] =
   dst->f[1] =
   dst->f[2] =
   dst->f[3] = src->f[TILE_BOTTOM_RIGHT] - src->f[TILE_BOTTOM_LEFT];
}

static void
micro_ddy(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] =
   dst->f[1] =
   dst->f[2] =
   dst->f[3] = src->f[TILE_BOTTOM_LEFT] - src->f[TILE_TOP_LEFT];
}

static void
micro_exp2(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
#if FAST_MATH
   dst->f[0] = util_fast_exp2(src->f[0]);
   dst->f[1] = util_fast_exp2(src->f[1]);
   dst->f[2] = util_fast_exp2(src->f[2]);
   dst->f[3] = util_fast_exp2(src->f[3]);
#else
#if DEBUG
   /* Inf is okay for this instruction, so clamp it to silence assertions. */
   uint i;
   union tgsi_exec_channel clamped;

   for (i = 0; i < 4; i++) {
      if (src->f[i] > 127.99999f) {
         clamped.f[i] = 127.99999f;
      } else if (src->f[i] < -126.99999f) {
         clamped.f[i] = -126.99999f;
      } else {
         clamped.f[i] = src->f[i];
      }
   }
   src = &clamped;
#endif /* DEBUG */

   dst->f[0] = powf(2.0f, src->f[0]);
   dst->f[1] = powf(2.0f, src->f[1]);
   dst->f[2] = powf(2.0f, src->f[2]);
   dst->f[3] = powf(2.0f, src->f[3]);
#endif /* FAST_MATH */
}

static void
micro_flr(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = floorf(src->f[0]);
   dst->f[1] = floorf(src->f[1]);
   dst->f[2] = floorf(src->f[2]);
   dst->f[3] = floorf(src->f[3]);
}

static void
micro_frc(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = src->f[0] - floorf(src->f[0]);
   dst->f[1] = src->f[1] - floorf(src->f[1]);
   dst->f[2] = src->f[2] - floorf(src->f[2]);
   dst->f[3] = src->f[3] - floorf(src->f[3]);
}

static void
micro_iabs(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->i[0] = src->i[0] >= 0 ? src->i[0] : -src->i[0];
   dst->i[1] = src->i[1] >= 0 ? src->i[1] : -src->i[1];
   dst->i[2] = src->i[2] >= 0 ? src->i[2] : -src->i[2];
   dst->i[3] = src->i[3] >= 0 ? src->i[3] : -src->i[3];
}

static void
micro_ineg(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->i[0] = -src->i[0];
   dst->i[1] = -src->i[1];
   dst->i[2] = -src->i[2];
   dst->i[3] = -src->i[3];
}

static void
micro_lg2(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
#if FAST_MATH
   dst->f[0] = util_fast_log2(src->f[0]);
   dst->f[1] = util_fast_log2(src->f[1]);
   dst->f[2] = util_fast_log2(src->f[2]);
   dst->f[3] = util_fast_log2(src->f[3]);
#else
   dst->f[0] = logf(src->f[0]) * 1.442695f;
   dst->f[1] = logf(src->f[1]) * 1.442695f;
   dst->f[2] = logf(src->f[2]) * 1.442695f;
   dst->f[3] = logf(src->f[3]) * 1.442695f;
#endif
}

static void
micro_lrp(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1,
          const union tgsi_exec_channel *src2)
{
   dst->f[0] = src0->f[0] * (src1->f[0] - src2->f[0]) + src2->f[0];
   dst->f[1] = src0->f[1] * (src1->f[1] - src2->f[1]) + src2->f[1];
   dst->f[2] = src0->f[2] * (src1->f[2] - src2->f[2]) + src2->f[2];
   dst->f[3] = src0->f[3] * (src1->f[3] - src2->f[3]) + src2->f[3];
}

static void
micro_mad(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1,
          const union tgsi_exec_channel *src2)
{
   dst->f[0] = src0->f[0] * src1->f[0] + src2->f[0];
   dst->f[1] = src0->f[1] * src1->f[1] + src2->f[1];
   dst->f[2] = src0->f[2] * src1->f[2] + src2->f[2];
   dst->f[3] = src0->f[3] * src1->f[3] + src2->f[3];
}

static void
micro_mov(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->u[0] = src->u[0];
   dst->u[1] = src->u[1];
   dst->u[2] = src->u[2];
   dst->u[3] = src->u[3];
}

static void
micro_rcp(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
#if 0 /* for debugging */
   assert(src->f[0] != 0.0f);
   assert(src->f[1] != 0.0f);
   assert(src->f[2] != 0.0f);
   assert(src->f[3] != 0.0f);
#endif
   dst->f[0] = 1.0f / src->f[0];
   dst->f[1] = 1.0f / src->f[1];
   dst->f[2] = 1.0f / src->f[2];
   dst->f[3] = 1.0f / src->f[3];
}

static void
micro_rnd(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = floorf(src->f[0] + 0.5f);
   dst->f[1] = floorf(src->f[1] + 0.5f);
   dst->f[2] = floorf(src->f[2] + 0.5f);
   dst->f[3] = floorf(src->f[3] + 0.5f);
}

static void
micro_rsq(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
#if 0 /* for debugging */
   assert(src->f[0] != 0.0f);
   assert(src->f[1] != 0.0f);
   assert(src->f[2] != 0.0f);
   assert(src->f[3] != 0.0f);
#endif
   dst->f[0] = 1.0f / sqrtf(src->f[0]);
   dst->f[1] = 1.0f / sqrtf(src->f[1]);
   dst->f[2] = 1.0f / sqrtf(src->f[2]);
   dst->f[3] = 1.0f / sqrtf(src->f[3]);
}

static void
micro_sqrt(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->f[0] = sqrtf(src->f[0]);
   dst->f[1] = sqrtf(src->f[1]);
   dst->f[2] = sqrtf(src->f[2]);
   dst->f[3] = sqrtf(src->f[3]);
}

static void
micro_seq(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] == src1->f[0] ? 1.0f : 0.0f;
   dst->f[1] = src0->f[1] == src1->f[1] ? 1.0f : 0.0f;
   dst->f[2] = src0->f[2] == src1->f[2] ? 1.0f : 0.0f;
   dst->f[3] = src0->f[3] == src1->f[3] ? 1.0f : 0.0f;
}

static void
micro_sge(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] >= src1->f[0] ? 1.0f : 0.0f;
   dst->f[1] = src0->f[1] >= src1->f[1] ? 1.0f : 0.0f;
   dst->f[2] = src0->f[2] >= src1->f[2] ? 1.0f : 0.0f;
   dst->f[3] = src0->f[3] >= src1->f[3] ? 1.0f : 0.0f;
}

static void
micro_sgn(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = src->f[0] < 0.0f ? -1.0f : src->f[0] > 0.0f ? 1.0f : 0.0f;
   dst->f[1] = src->f[1] < 0.0f ? -1.0f : src->f[1] > 0.0f ? 1.0f : 0.0f;
   dst->f[2] = src->f[2] < 0.0f ? -1.0f : src->f[2] > 0.0f ? 1.0f : 0.0f;
   dst->f[3] = src->f[3] < 0.0f ? -1.0f : src->f[3] > 0.0f ? 1.0f : 0.0f;
}

static void
micro_isgn(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->i[0] = src->i[0] < 0 ? -1 : src->i[0] > 0 ? 1 : 0;
   dst->i[1] = src->i[1] < 0 ? -1 : src->i[1] > 0 ? 1 : 0;
   dst->i[2] = src->i[2] < 0 ? -1 : src->i[2] > 0 ? 1 : 0;
   dst->i[3] = src->i[3] < 0 ? -1 : src->i[3] > 0 ? 1 : 0;
}

static void
micro_sgt(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] > src1->f[0] ? 1.0f : 0.0f;
   dst->f[1] = src0->f[1] > src1->f[1] ? 1.0f : 0.0f;
   dst->f[2] = src0->f[2] > src1->f[2] ? 1.0f : 0.0f;
   dst->f[3] = src0->f[3] > src1->f[3] ? 1.0f : 0.0f;
}

static void
micro_sin(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = sinf(src->f[0]);
   dst->f[1] = sinf(src->f[1]);
   dst->f[2] = sinf(src->f[2]);
   dst->f[3] = sinf(src->f[3]);
}

static void
micro_sle(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] <= src1->f[0] ? 1.0f : 0.0f;
   dst->f[1] = src0->f[1] <= src1->f[1] ? 1.0f : 0.0f;
   dst->f[2] = src0->f[2] <= src1->f[2] ? 1.0f : 0.0f;
   dst->f[3] = src0->f[3] <= src1->f[3] ? 1.0f : 0.0f;
}

static void
micro_slt(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] < src1->f[0] ? 1.0f : 0.0f;
   dst->f[1] = src0->f[1] < src1->f[1] ? 1.0f : 0.0f;
   dst->f[2] = src0->f[2] < src1->f[2] ? 1.0f : 0.0f;
   dst->f[3] = src0->f[3] < src1->f[3] ? 1.0f : 0.0f;
}

static void
micro_sne(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] != src1->f[0] ? 1.0f : 0.0f;
   dst->f[1] = src0->f[1] != src1->f[1] ? 1.0f : 0.0f;
   dst->f[2] = src0->f[2] != src1->f[2] ? 1.0f : 0.0f;
   dst->f[3] = src0->f[3] != src1->f[3] ? 1.0f : 0.0f;
}

static void
micro_sfl(union tgsi_exec_channel *dst)
{
   dst->f[0] = 0.0f;
   dst->f[1] = 0.0f;
   dst->f[2] = 0.0f;
   dst->f[3] = 0.0f;
}

static void
micro_str(union tgsi_exec_channel *dst)
{
   dst->f[0] = 1.0f;
   dst->f[1] = 1.0f;
   dst->f[2] = 1.0f;
   dst->f[3] = 1.0f;
}

static void
micro_trunc(union tgsi_exec_channel *dst,
            const union tgsi_exec_channel *src)
{
   dst->f[0] = (float)(int)src->f[0];
   dst->f[1] = (float)(int)src->f[1];
   dst->f[2] = (float)(int)src->f[2];
   dst->f[3] = (float)(int)src->f[3];
}


enum tgsi_exec_datatype {
   TGSI_EXEC_DATA_FLOAT,
   TGSI_EXEC_DATA_INT,
   TGSI_EXEC_DATA_UINT
};

/*
 * Shorthand locations of various utility registers (_I = Index, _C = Channel)
 */
#define TEMP_KILMASK_I     TGSI_EXEC_TEMP_KILMASK_I
#define TEMP_KILMASK_C     TGSI_EXEC_TEMP_KILMASK_C
#define TEMP_OUTPUT_I      TGSI_EXEC_TEMP_OUTPUT_I
#define TEMP_OUTPUT_C      TGSI_EXEC_TEMP_OUTPUT_C
#define TEMP_PRIMITIVE_I   TGSI_EXEC_TEMP_PRIMITIVE_I
#define TEMP_PRIMITIVE_C   TGSI_EXEC_TEMP_PRIMITIVE_C


/** The execution mask depends on the conditional mask and the loop mask */
#define UPDATE_EXEC_MASK(MACH) \
      MACH->ExecMask = MACH->CondMask & MACH->LoopMask & MACH->ContMask & MACH->Switch.mask & MACH->FuncMask


static const union tgsi_exec_channel ZeroVec =
   { { 0.0, 0.0, 0.0, 0.0 } };

static const union tgsi_exec_channel OneVec = {
   {1.0f, 1.0f, 1.0f, 1.0f}
};

static const union tgsi_exec_channel P128Vec = {
   {128.0f, 128.0f, 128.0f, 128.0f}
};

static const union tgsi_exec_channel M128Vec = {
   {-128.0f, -128.0f, -128.0f, -128.0f}
};


/**
 * Assert that none of the float values in 'chan' are infinite or NaN.
 * NaN and Inf may occur normally during program execution and should
 * not lead to crashes, etc.  But when debugging, it's helpful to catch
 * them.
 */
static INLINE void
check_inf_or_nan(const union tgsi_exec_channel *chan)
{
   assert(!util_is_inf_or_nan((chan)->f[0]));
   assert(!util_is_inf_or_nan((chan)->f[1]));
   assert(!util_is_inf_or_nan((chan)->f[2]));
   assert(!util_is_inf_or_nan((chan)->f[3]));
}


#ifdef DEBUG
static void
print_chan(const char *msg, const union tgsi_exec_channel *chan)
{
   debug_printf("%s = {%f, %f, %f, %f}\n",
                msg, chan->f[0], chan->f[1], chan->f[2], chan->f[3]);
}
#endif


#ifdef DEBUG
static void
print_temp(const struct tgsi_exec_machine *mach, uint index)
{
   const struct tgsi_exec_vector *tmp = &mach->Temps[index];
   int i;
   debug_printf("Temp[%u] =\n", index);
   for (i = 0; i < 4; i++) {
      debug_printf("  %c: { %f, %f, %f, %f }\n",
                   "XYZW"[i],
                   tmp->xyzw[i].f[0],
                   tmp->xyzw[i].f[1],
                   tmp->xyzw[i].f[2],
                   tmp->xyzw[i].f[3]);
   }
}
#endif


void
tgsi_exec_set_constant_buffers(struct tgsi_exec_machine *mach,
                               unsigned num_bufs,
                               const void **bufs,
                               const unsigned *buf_sizes)
{
   unsigned i;

   for (i = 0; i < num_bufs; i++) {
      mach->Consts[i] = bufs[i];
      mach->ConstsSize[i] = buf_sizes[i];
   }
}


/**
 * Check if there's a potential src/dst register data dependency when
 * using SOA execution.
 * Example:
 *   MOV T, T.yxwz;
 * This would expand into:
 *   MOV t0, t1;
 *   MOV t1, t0;
 *   MOV t2, t3;
 *   MOV t3, t2;
 * The second instruction will have the wrong value for t0 if executed as-is.
 */
boolean
tgsi_check_soa_dependencies(const struct tgsi_full_instruction *inst)
{
   uint i, chan;

   uint writemask = inst->Dst[0].Register.WriteMask;
   if (writemask == TGSI_WRITEMASK_X ||
       writemask == TGSI_WRITEMASK_Y ||
       writemask == TGSI_WRITEMASK_Z ||
       writemask == TGSI_WRITEMASK_W ||
       writemask == TGSI_WRITEMASK_NONE) {
      /* no chance of data dependency */
      return FALSE;
   }

   /* loop over src regs */
   for (i = 0; i < inst->Instruction.NumSrcRegs; i++) {
      if ((inst->Src[i].Register.File ==
           inst->Dst[0].Register.File) &&
          ((inst->Src[i].Register.Index ==
            inst->Dst[0].Register.Index) ||
           inst->Src[i].Register.Indirect ||
           inst->Dst[0].Register.Indirect)) {
         /* loop over dest channels */
         uint channelsWritten = 0x0;
         for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
            if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
               /* check if we're reading a channel that's been written */
               uint swizzle = tgsi_util_get_full_src_register_swizzle(&inst->Src[i], chan);
               if (channelsWritten & (1 << swizzle)) {
                  return TRUE;
               }

               channelsWritten |= (1 << chan);
            }
         }
      }
   }
   return FALSE;
}


/**
 * Initialize machine state by expanding tokens to full instructions,
 * allocating temporary storage, setting up constants, etc.
 * After this, we can call tgsi_exec_machine_run() many times.
 */
void 
tgsi_exec_machine_bind_shader(
   struct tgsi_exec_machine *mach,
   const struct tgsi_token *tokens,
   struct tgsi_sampler *sampler)
{
   uint k;
   struct tgsi_parse_context parse;
   struct tgsi_full_instruction *instructions;
   struct tgsi_full_declaration *declarations;
   uint maxInstructions = 10, numInstructions = 0;
   uint maxDeclarations = 10, numDeclarations = 0;

#if 0
   tgsi_dump(tokens, 0);
#endif

   util_init_math();


   mach->Tokens = tokens;
   mach->Sampler = sampler;

   if (!tokens) {
      /* unbind and free all */
      FREE(mach->Declarations);
      mach->Declarations = NULL;
      mach->NumDeclarations = 0;

      FREE(mach->Instructions);
      mach->Instructions = NULL;
      mach->NumInstructions = 0;

      return;
   }

   k = tgsi_parse_init (&parse, mach->Tokens);
   if (k != TGSI_PARSE_OK) {
      debug_printf( "Problem parsing!\n" );
      return;
   }

   mach->Processor = parse.FullHeader.Processor.Processor;
   mach->ImmLimit = 0;
   mach->NumOutputs = 0;

   if (mach->Processor == TGSI_PROCESSOR_GEOMETRY &&
       !mach->UsedGeometryShader) {
      struct tgsi_exec_vector *inputs;
      struct tgsi_exec_vector *outputs;

      inputs = align_malloc(sizeof(struct tgsi_exec_vector) *
                            TGSI_MAX_PRIM_VERTICES * PIPE_MAX_ATTRIBS,
                            16);

      if (!inputs)
         return;

      outputs = align_malloc(sizeof(struct tgsi_exec_vector) *
                             TGSI_MAX_TOTAL_VERTICES, 16);

      if (!outputs) {
         align_free(inputs);
         return;
      }

      align_free(mach->Inputs);
      align_free(mach->Outputs);

      mach->Inputs = inputs;
      mach->Outputs = outputs;
      mach->UsedGeometryShader = TRUE;
   }

   declarations = (struct tgsi_full_declaration *)
      MALLOC( maxDeclarations * sizeof(struct tgsi_full_declaration) );

   if (!declarations) {
      return;
   }

   instructions = (struct tgsi_full_instruction *)
      MALLOC( maxInstructions * sizeof(struct tgsi_full_instruction) );

   if (!instructions) {
      FREE( declarations );
      return;
   }

   while( !tgsi_parse_end_of_tokens( &parse ) ) {
      uint i;

      tgsi_parse_token( &parse );
      switch( parse.FullToken.Token.Type ) {
      case TGSI_TOKEN_TYPE_DECLARATION:
         /* save expanded declaration */
         if (numDeclarations == maxDeclarations) {
            declarations = REALLOC(declarations,
                                   maxDeclarations
                                   * sizeof(struct tgsi_full_declaration),
                                   (maxDeclarations + 10)
                                   * sizeof(struct tgsi_full_declaration));
            maxDeclarations += 10;
         }
         if (parse.FullToken.FullDeclaration.Declaration.File == TGSI_FILE_OUTPUT) {
            unsigned reg;
            for (reg = parse.FullToken.FullDeclaration.Range.First;
                 reg <= parse.FullToken.FullDeclaration.Range.Last;
                 ++reg) {
               ++mach->NumOutputs;
            }
         }
         memcpy(declarations + numDeclarations,
                &parse.FullToken.FullDeclaration,
                sizeof(declarations[0]));
         numDeclarations++;
         break;

      case TGSI_TOKEN_TYPE_IMMEDIATE:
         {
            uint size = parse.FullToken.FullImmediate.Immediate.NrTokens - 1;
            assert( size <= 4 );
            assert( mach->ImmLimit + 1 <= TGSI_EXEC_NUM_IMMEDIATES );

            for( i = 0; i < size; i++ ) {
               mach->Imms[mach->ImmLimit][i] = 
		  parse.FullToken.FullImmediate.u[i].Float;
            }
            mach->ImmLimit += 1;
         }
         break;

      case TGSI_TOKEN_TYPE_INSTRUCTION:

         /* save expanded instruction */
         if (numInstructions == maxInstructions) {
            instructions = REALLOC(instructions,
                                   maxInstructions
                                   * sizeof(struct tgsi_full_instruction),
                                   (maxInstructions + 10)
                                   * sizeof(struct tgsi_full_instruction));
            maxInstructions += 10;
         }

         memcpy(instructions + numInstructions,
                &parse.FullToken.FullInstruction,
                sizeof(instructions[0]));

         numInstructions++;
         break;

      case TGSI_TOKEN_TYPE_PROPERTY:
         break;

      default:
         assert( 0 );
      }
   }
   tgsi_parse_free (&parse);

   FREE(mach->Declarations);
   mach->Declarations = declarations;
   mach->NumDeclarations = numDeclarations;

   FREE(mach->Instructions);
   mach->Instructions = instructions;
   mach->NumInstructions = numInstructions;
}


struct tgsi_exec_machine *
tgsi_exec_machine_create( void )
{
   struct tgsi_exec_machine *mach;
   uint i;

   mach = align_malloc( sizeof *mach, 16 );
   if (!mach)
      goto fail;

   memset(mach, 0, sizeof(*mach));

   mach->Addrs = &mach->Temps[TGSI_EXEC_TEMP_ADDR];
   mach->MaxGeometryShaderOutputs = TGSI_MAX_TOTAL_VERTICES;
   mach->Predicates = &mach->Temps[TGSI_EXEC_TEMP_P0];

   mach->Inputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_ATTRIBS, 16);
   mach->Outputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_ATTRIBS, 16);
   if (!mach->Inputs || !mach->Outputs)
      goto fail;

   /* Setup constants needed by the SSE2 executor. */
   for( i = 0; i < 4; i++ ) {
      mach->Temps[TGSI_EXEC_TEMP_00000000_I].xyzw[TGSI_EXEC_TEMP_00000000_C].u[i] = 0x00000000;
      mach->Temps[TGSI_EXEC_TEMP_7FFFFFFF_I].xyzw[TGSI_EXEC_TEMP_7FFFFFFF_C].u[i] = 0x7FFFFFFF;
      mach->Temps[TGSI_EXEC_TEMP_80000000_I].xyzw[TGSI_EXEC_TEMP_80000000_C].u[i] = 0x80000000;
      mach->Temps[TGSI_EXEC_TEMP_FFFFFFFF_I].xyzw[TGSI_EXEC_TEMP_FFFFFFFF_C].u[i] = 0xFFFFFFFF;    /* not used */
      mach->Temps[TGSI_EXEC_TEMP_ONE_I].xyzw[TGSI_EXEC_TEMP_ONE_C].f[i] = 1.0f;
      mach->Temps[TGSI_EXEC_TEMP_TWO_I].xyzw[TGSI_EXEC_TEMP_TWO_C].f[i] = 2.0f;    /* not used */
      mach->Temps[TGSI_EXEC_TEMP_128_I].xyzw[TGSI_EXEC_TEMP_128_C].f[i] = 128.0f;
      mach->Temps[TGSI_EXEC_TEMP_MINUS_128_I].xyzw[TGSI_EXEC_TEMP_MINUS_128_C].f[i] = -128.0f;
      mach->Temps[TGSI_EXEC_TEMP_THREE_I].xyzw[TGSI_EXEC_TEMP_THREE_C].f[i] = 3.0f;
      mach->Temps[TGSI_EXEC_TEMP_HALF_I].xyzw[TGSI_EXEC_TEMP_HALF_C].f[i] = 0.5f;
   }

#ifdef DEBUG
   /* silence warnings */
   (void) print_chan;
   (void) print_temp;
#endif

   return mach;

fail:
   if (mach) {
      align_free(mach->Inputs);
      align_free(mach->Outputs);
      align_free(mach);
   }
   return NULL;
}


void
tgsi_exec_machine_destroy(struct tgsi_exec_machine *mach)
{
   if (mach) {
      FREE(mach->Instructions);
      FREE(mach->Declarations);

      align_free(mach->Inputs);
      align_free(mach->Outputs);

      align_free(mach);
   }
}

static void
micro_add(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] + src1->f[0];
   dst->f[1] = src0->f[1] + src1->f[1];
   dst->f[2] = src0->f[2] + src1->f[2];
   dst->f[3] = src0->f[3] + src1->f[3];
}

static void
micro_div(
   union tgsi_exec_channel *dst,
   const union tgsi_exec_channel *src0,
   const union tgsi_exec_channel *src1 )
{
   if (src1->f[0] != 0) {
      dst->f[0] = src0->f[0] / src1->f[0];
   }
   if (src1->f[1] != 0) {
      dst->f[1] = src0->f[1] / src1->f[1];
   }
   if (src1->f[2] != 0) {
      dst->f[2] = src0->f[2] / src1->f[2];
   }
   if (src1->f[3] != 0) {
      dst->f[3] = src0->f[3] / src1->f[3];
   }
}

static void
micro_rcc(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   uint i;

   for (i = 0; i < 4; i++) {
      float recip = 1.0f / src->f[i];

      if (recip > 0.0f)
         dst->f[i] = CLAMP(recip, 5.42101e-020f, 1.84467e+019f);
      else
         dst->f[i] = CLAMP(recip, -1.84467e+019f, -5.42101e-020f);
   }
}

static void
micro_lt(
   union tgsi_exec_channel *dst,
   const union tgsi_exec_channel *src0,
   const union tgsi_exec_channel *src1,
   const union tgsi_exec_channel *src2,
   const union tgsi_exec_channel *src3 )
{
   dst->f[0] = src0->f[0] < src1->f[0] ? src2->f[0] : src3->f[0];
   dst->f[1] = src0->f[1] < src1->f[1] ? src2->f[1] : src3->f[1];
   dst->f[2] = src0->f[2] < src1->f[2] ? src2->f[2] : src3->f[2];
   dst->f[3] = src0->f[3] < src1->f[3] ? src2->f[3] : src3->f[3];
}

static void
micro_max(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] > src1->f[0] ? src0->f[0] : src1->f[0];
   dst->f[1] = src0->f[1] > src1->f[1] ? src0->f[1] : src1->f[1];
   dst->f[2] = src0->f[2] > src1->f[2] ? src0->f[2] : src1->f[2];
   dst->f[3] = src0->f[3] > src1->f[3] ? src0->f[3] : src1->f[3];
}

static void
micro_min(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] < src1->f[0] ? src0->f[0] : src1->f[0];
   dst->f[1] = src0->f[1] < src1->f[1] ? src0->f[1] : src1->f[1];
   dst->f[2] = src0->f[2] < src1->f[2] ? src0->f[2] : src1->f[2];
   dst->f[3] = src0->f[3] < src1->f[3] ? src0->f[3] : src1->f[3];
}

static void
micro_mul(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] * src1->f[0];
   dst->f[1] = src0->f[1] * src1->f[1];
   dst->f[2] = src0->f[2] * src1->f[2];
   dst->f[3] = src0->f[3] * src1->f[3];
}

static void
micro_neg(
   union tgsi_exec_channel *dst,
   const union tgsi_exec_channel *src )
{
   dst->f[0] = -src->f[0];
   dst->f[1] = -src->f[1];
   dst->f[2] = -src->f[2];
   dst->f[3] = -src->f[3];
}

static void
micro_pow(
   union tgsi_exec_channel *dst,
   const union tgsi_exec_channel *src0,
   const union tgsi_exec_channel *src1 )
{
#if FAST_MATH
   dst->f[0] = util_fast_pow( src0->f[0], src1->f[0] );
   dst->f[1] = util_fast_pow( src0->f[1], src1->f[1] );
   dst->f[2] = util_fast_pow( src0->f[2], src1->f[2] );
   dst->f[3] = util_fast_pow( src0->f[3], src1->f[3] );
#else
   dst->f[0] = powf( src0->f[0], src1->f[0] );
   dst->f[1] = powf( src0->f[1], src1->f[1] );
   dst->f[2] = powf( src0->f[2], src1->f[2] );
   dst->f[3] = powf( src0->f[3], src1->f[3] );
#endif
}

static void
micro_sub(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->f[0] = src0->f[0] - src1->f[0];
   dst->f[1] = src0->f[1] - src1->f[1];
   dst->f[2] = src0->f[2] - src1->f[2];
   dst->f[3] = src0->f[3] - src1->f[3];
}

static void
fetch_src_file_channel(const struct tgsi_exec_machine *mach,
                       const uint chan_index,
                       const uint file,
                       const uint swizzle,
                       const union tgsi_exec_channel *index,
                       const union tgsi_exec_channel *index2D,
                       union tgsi_exec_channel *chan)
{
   uint i;

   assert(swizzle < 4);

   switch (file) {
   case TGSI_FILE_CONSTANT:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         assert(index2D->i[i] >= 0 && index2D->i[i] < PIPE_MAX_CONSTANT_BUFFERS);
         assert(mach->Consts[index2D->i[i]]);

         if (index->i[i] < 0) {
            chan->u[i] = 0;
         } else {
            /* NOTE: copying the const value as a uint instead of float */
            const uint constbuf = index2D->i[i];
            const uint *buf = (const uint *)mach->Consts[constbuf];
            const int pos = index->i[i] * 4 + swizzle;
            /* const buffer bounds check */
            if (pos < 0 || pos >= (int) mach->ConstsSize[constbuf]) {
               if (0) {
                  /* Debug: print warning */
                  static int count = 0;
                  if (count++ < 100)
                     debug_printf("TGSI Exec: const buffer index %d"
                                  " out of bounds\n", pos);
               }
               chan->u[i] = 0;
            }
            else
               chan->u[i] = buf[pos];
         }
      }
      break;

   case TGSI_FILE_INPUT:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         /*
         if (TGSI_PROCESSOR_GEOMETRY == mach->Processor) {
            debug_printf("Fetching Input[%d] (2d=%d, 1d=%d)\n",
                         index2D->i[i] * TGSI_EXEC_MAX_INPUT_ATTRIBS + index->i[i],
                         index2D->i[i], index->i[i]);
                         }*/
         int pos = index2D->i[i] * TGSI_EXEC_MAX_INPUT_ATTRIBS + index->i[i];
         assert(pos >= 0);
         assert(pos < TGSI_MAX_PRIM_VERTICES * PIPE_MAX_ATTRIBS);
         chan->u[i] = mach->Inputs[pos].xyzw[swizzle].u[i];
      }
      break;

   case TGSI_FILE_SYSTEM_VALUE:
      /* XXX no swizzling at this point.  Will be needed if we put
       * gl_FragCoord, for example, in a sys value register.
       */
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         chan->u[i] = mach->SystemValue[index->i[i]].u[i];
      }
      break;

   case TGSI_FILE_TEMPORARY:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         assert(index->i[i] < TGSI_EXEC_NUM_TEMPS);
         assert(index2D->i[i] == 0);

         chan->u[i] = mach->Temps[index->i[i]].xyzw[swizzle].u[i];
      }
      break;

   case TGSI_FILE_IMMEDIATE:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         assert(index->i[i] >= 0 && index->i[i] < (int)mach->ImmLimit);
         assert(index2D->i[i] == 0);

         chan->f[i] = mach->Imms[index->i[i]][swizzle];
      }
      break;

   case TGSI_FILE_ADDRESS:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         assert(index->i[i] >= 0);
         assert(index2D->i[i] == 0);

         chan->u[i] = mach->Addrs[index->i[i]].xyzw[swizzle].u[i];
      }
      break;

   case TGSI_FILE_PREDICATE:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         assert(index->i[i] >= 0 && index->i[i] < TGSI_EXEC_NUM_PREDS);
         assert(index2D->i[i] == 0);

         chan->u[i] = mach->Predicates[0].xyzw[swizzle].u[i];
      }
      break;

   case TGSI_FILE_OUTPUT:
      /* vertex/fragment output vars can be read too */
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         assert(index->i[i] >= 0);
         assert(index2D->i[i] == 0);

         chan->u[i] = mach->Outputs[index->i[i]].xyzw[swizzle].u[i];
      }
      break;

   default:
      assert(0);
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         chan->u[i] = 0;
      }
   }
}

static void
fetch_source(const struct tgsi_exec_machine *mach,
             union tgsi_exec_channel *chan,
             const struct tgsi_full_src_register *reg,
             const uint chan_index,
             enum tgsi_exec_datatype src_datatype)
{
   union tgsi_exec_channel index;
   union tgsi_exec_channel index2D;
   uint swizzle;

   /* We start with a direct index into a register file.
    *
    *    file[1],
    *    where:
    *       file = Register.File
    *       [1] = Register.Index
    */
   index.i[0] =
   index.i[1] =
   index.i[2] =
   index.i[3] = reg->Register.Index;

   /* There is an extra source register that indirectly subscripts
    * a register file. The direct index now becomes an offset
    * that is being added to the indirect register.
    *
    *    file[ind[2].x+1],
    *    where:
    *       ind = Indirect.File
    *       [2] = Indirect.Index
    *       .x = Indirect.SwizzleX
    */
   if (reg->Register.Indirect) {
      union tgsi_exec_channel index2;
      union tgsi_exec_channel indir_index;
      const uint execmask = mach->ExecMask;
      uint i;

      /* which address register (always zero now) */
      index2.i[0] =
      index2.i[1] =
      index2.i[2] =
      index2.i[3] = reg->Indirect.Index;
      /* get current value of address register[swizzle] */
      swizzle = reg->Indirect.Swizzle;
      fetch_src_file_channel(mach,
                             chan_index,
                             reg->Indirect.File,
                             swizzle,
                             &index2,
                             &ZeroVec,
                             &indir_index);

      /* add value of address register to the offset */
      index.i[0] += indir_index.i[0];
      index.i[1] += indir_index.i[1];
      index.i[2] += indir_index.i[2];
      index.i[3] += indir_index.i[3];

      /* for disabled execution channels, zero-out the index to
       * avoid using a potential garbage value.
       */
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         if ((execmask & (1 << i)) == 0)
            index.i[i] = 0;
      }
   }

   /* There is an extra source register that is a second
    * subscript to a register file. Effectively it means that
    * the register file is actually a 2D array of registers.
    *
    *    file[3][1],
    *    where:
    *       [3] = Dimension.Index
    */
   if (reg->Register.Dimension) {
      index2D.i[0] =
      index2D.i[1] =
      index2D.i[2] =
      index2D.i[3] = reg->Dimension.Index;

      /* Again, the second subscript index can be addressed indirectly
       * identically to the first one.
       * Nothing stops us from indirectly addressing the indirect register,
       * but there is no need for that, so we won't exercise it.
       *
       *    file[ind[4].y+3][1],
       *    where:
       *       ind = DimIndirect.File
       *       [4] = DimIndirect.Index
       *       .y = DimIndirect.SwizzleX
       */
      if (reg->Dimension.Indirect) {
         union tgsi_exec_channel index2;
         union tgsi_exec_channel indir_index;
         const uint execmask = mach->ExecMask;
         uint i;

         index2.i[0] =
         index2.i[1] =
         index2.i[2] =
         index2.i[3] = reg->DimIndirect.Index;

         swizzle = reg->DimIndirect.Swizzle;
         fetch_src_file_channel(mach,
                                chan_index,
                                reg->DimIndirect.File,
                                swizzle,
                                &index2,
                                &ZeroVec,
                                &indir_index);

         index2D.i[0] += indir_index.i[0];
         index2D.i[1] += indir_index.i[1];
         index2D.i[2] += indir_index.i[2];
         index2D.i[3] += indir_index.i[3];

         /* for disabled execution channels, zero-out the index to
          * avoid using a potential garbage value.
          */
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
            if ((execmask & (1 << i)) == 0) {
               index2D.i[i] = 0;
            }
         }
      }

      /* If by any chance there was a need for a 3D array of register
       * files, we would have to check whether Dimension is followed
       * by a dimension register and continue the saga.
       */
   } else {
      index2D.i[0] =
      index2D.i[1] =
      index2D.i[2] =
      index2D.i[3] = 0;
   }

   swizzle = tgsi_util_get_full_src_register_swizzle( reg, chan_index );
   fetch_src_file_channel(mach,
                          chan_index,
                          reg->Register.File,
                          swizzle,
                          &index,
                          &index2D,
                          chan);

   if (reg->Register.Absolute) {
      if (src_datatype == TGSI_EXEC_DATA_FLOAT) {
         micro_abs(chan, chan);
      } else {
         micro_iabs(chan, chan);
      }
   }

   if (reg->Register.Negate) {
      if (src_datatype == TGSI_EXEC_DATA_FLOAT) {
         micro_neg(chan, chan);
      } else {
         micro_ineg(chan, chan);
      }
   }
}

static void
store_dest(struct tgsi_exec_machine *mach,
           const union tgsi_exec_channel *chan,
           const struct tgsi_full_dst_register *reg,
           const struct tgsi_full_instruction *inst,
           uint chan_index,
           enum tgsi_exec_datatype dst_datatype)
{
   uint i;
   union tgsi_exec_channel null;
   union tgsi_exec_channel *dst;
   union tgsi_exec_channel index2D;
   uint execmask = mach->ExecMask;
   int offset = 0;  /* indirection offset */
   int index;

   /* for debugging */
   if (0 && dst_datatype == TGSI_EXEC_DATA_FLOAT) {
      check_inf_or_nan(chan);
   }

   /* There is an extra source register that indirectly subscripts
    * a register file. The direct index now becomes an offset
    * that is being added to the indirect register.
    *
    *    file[ind[2].x+1],
    *    where:
    *       ind = Indirect.File
    *       [2] = Indirect.Index
    *       .x = Indirect.SwizzleX
    */
   if (reg->Register.Indirect) {
      union tgsi_exec_channel index;
      union tgsi_exec_channel indir_index;
      uint swizzle;

      /* which address register (always zero for now) */
      index.i[0] =
      index.i[1] =
      index.i[2] =
      index.i[3] = reg->Indirect.Index;

      /* get current value of address register[swizzle] */
      swizzle = reg->Indirect.Swizzle;

      /* fetch values from the address/indirection register */
      fetch_src_file_channel(mach,
                             chan_index,
                             reg->Indirect.File,
                             swizzle,
                             &index,
                             &ZeroVec,
                             &indir_index);

      /* save indirection offset */
      offset = indir_index.i[0];
   }

   /* There is an extra source register that is a second
    * subscript to a register file. Effectively it means that
    * the register file is actually a 2D array of registers.
    *
    *    file[3][1],
    *    where:
    *       [3] = Dimension.Index
    */
   if (reg->Register.Dimension) {
      index2D.i[0] =
      index2D.i[1] =
      index2D.i[2] =
      index2D.i[3] = reg->Dimension.Index;

      /* Again, the second subscript index can be addressed indirectly
       * identically to the first one.
       * Nothing stops us from indirectly addressing the indirect register,
       * but there is no need for that, so we won't exercise it.
       *
       *    file[ind[4].y+3][1],
       *    where:
       *       ind = DimIndirect.File
       *       [4] = DimIndirect.Index
       *       .y = DimIndirect.SwizzleX
       */
      if (reg->Dimension.Indirect) {
         union tgsi_exec_channel index2;
         union tgsi_exec_channel indir_index;
         const uint execmask = mach->ExecMask;
         unsigned swizzle;
         uint i;

         index2.i[0] =
         index2.i[1] =
         index2.i[2] =
         index2.i[3] = reg->DimIndirect.Index;

         swizzle = reg->DimIndirect.Swizzle;
         fetch_src_file_channel(mach,
                                chan_index,
                                reg->DimIndirect.File,
                                swizzle,
                                &index2,
                                &ZeroVec,
                                &indir_index);

         index2D.i[0] += indir_index.i[0];
         index2D.i[1] += indir_index.i[1];
         index2D.i[2] += indir_index.i[2];
         index2D.i[3] += indir_index.i[3];

         /* for disabled execution channels, zero-out the index to
          * avoid using a potential garbage value.
          */
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
            if ((execmask & (1 << i)) == 0) {
               index2D.i[i] = 0;
            }
         }
      }

      /* If by any chance there was a need for a 3D array of register
       * files, we would have to check whether Dimension is followed
       * by a dimension register and continue the saga.
       */
   } else {
      index2D.i[0] =
      index2D.i[1] =
      index2D.i[2] =
      index2D.i[3] = 0;
   }

   switch (reg->Register.File) {
   case TGSI_FILE_NULL:
      dst = &null;
      break;

   case TGSI_FILE_OUTPUT:
      index = mach->Temps[TEMP_OUTPUT_I].xyzw[TEMP_OUTPUT_C].u[0]
         + reg->Register.Index;
      dst = &mach->Outputs[offset + index].xyzw[chan_index];
#if 0
      debug_printf("NumOutputs = %d, TEMP_O_C/I = %d, redindex = %d\n",
                   mach->NumOutputs, mach->Temps[TEMP_OUTPUT_I].xyzw[TEMP_OUTPUT_C].u[0],
                   reg->Register.Index);
      if (TGSI_PROCESSOR_GEOMETRY == mach->Processor) {
         debug_printf("STORING OUT[%d] mask(%d), = (", offset + index, execmask);
         for (i = 0; i < TGSI_QUAD_SIZE; i++)
            if (execmask & (1 << i))
               debug_printf("%f, ", chan->f[i]);
         debug_printf(")\n");
      }
#endif
      break;

   case TGSI_FILE_TEMPORARY:
      index = reg->Register.Index;
      assert( index < TGSI_EXEC_NUM_TEMPS );
      dst = &mach->Temps[offset + index].xyzw[chan_index];
      break;

   case TGSI_FILE_ADDRESS:
      index = reg->Register.Index;
      dst = &mach->Addrs[index].xyzw[chan_index];
      break;

   case TGSI_FILE_PREDICATE:
      index = reg->Register.Index;
      assert(index < TGSI_EXEC_NUM_PREDS);
      dst = &mach->Predicates[index].xyzw[chan_index];
      break;

   default:
      assert( 0 );
      return;
   }

   if (inst->Instruction.Predicate) {
      uint swizzle;
      union tgsi_exec_channel *pred;

      switch (chan_index) {
      case TGSI_CHAN_X:
         swizzle = inst->Predicate.SwizzleX;
         break;
      case TGSI_CHAN_Y:
         swizzle = inst->Predicate.SwizzleY;
         break;
      case TGSI_CHAN_Z:
         swizzle = inst->Predicate.SwizzleZ;
         break;
      case TGSI_CHAN_W:
         swizzle = inst->Predicate.SwizzleW;
         break;
      default:
         assert(0);
         return;
      }

      assert(inst->Predicate.Index == 0);

      pred = &mach->Predicates[inst->Predicate.Index].xyzw[swizzle];

      if (inst->Predicate.Negate) {
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
            if (pred->u[i]) {
               execmask &= ~(1 << i);
            }
         }
      } else {
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
            if (!pred->u[i]) {
               execmask &= ~(1 << i);
            }
         }
      }
   }

   switch (inst->Instruction.Saturate) {
   case TGSI_SAT_NONE:
      for (i = 0; i < TGSI_QUAD_SIZE; i++)
         if (execmask & (1 << i))
            dst->i[i] = chan->i[i];
      break;

   case TGSI_SAT_ZERO_ONE:
      for (i = 0; i < TGSI_QUAD_SIZE; i++)
         if (execmask & (1 << i)) {
            if (chan->f[i] < 0.0f)
               dst->f[i] = 0.0f;
            else if (chan->f[i] > 1.0f)
               dst->f[i] = 1.0f;
            else
               dst->i[i] = chan->i[i];
         }
      break;

   case TGSI_SAT_MINUS_PLUS_ONE:
      for (i = 0; i < TGSI_QUAD_SIZE; i++)
         if (execmask & (1 << i)) {
            if (chan->f[i] < -1.0f)
               dst->f[i] = -1.0f;
            else if (chan->f[i] > 1.0f)
               dst->f[i] = 1.0f;
            else
               dst->i[i] = chan->i[i];
         }
      break;

   default:
      assert( 0 );
   }
}

#define FETCH(VAL,INDEX,CHAN)\
    fetch_source(mach, VAL, &inst->Src[INDEX], CHAN, TGSI_EXEC_DATA_FLOAT)

#define IFETCH(VAL,INDEX,CHAN)\
    fetch_source(mach, VAL, &inst->Src[INDEX], CHAN, TGSI_EXEC_DATA_INT)


/**
 * Execute ARB-style KIL which is predicated by a src register.
 * Kill fragment if any of the four values is less than zero.
 */
static void
exec_kill_if(struct tgsi_exec_machine *mach,
             const struct tgsi_full_instruction *inst)
{
   uint uniquemask;
   uint chan_index;
   uint kilmask = 0; /* bit 0 = pixel 0, bit 1 = pixel 1, etc */
   union tgsi_exec_channel r[1];

   /* This mask stores component bits that were already tested. */
   uniquemask = 0;

   for (chan_index = 0; chan_index < 4; chan_index++)
   {
      uint swizzle;
      uint i;

      /* unswizzle channel */
      swizzle = tgsi_util_get_full_src_register_swizzle (
                        &inst->Src[0],
                        chan_index);

      /* check if the component has not been already tested */
      if (uniquemask & (1 << swizzle))
         continue;
      uniquemask |= 1 << swizzle;

      FETCH(&r[0], 0, chan_index);
      for (i = 0; i < 4; i++)
         if (r[0].f[i] < 0.0f)
            kilmask |= 1 << i;
   }

   /* restrict to fragments currently executing */
   kilmask &= mach->ExecMask;

   mach->Temps[TEMP_KILMASK_I].xyzw[TEMP_KILMASK_C].u[0] |= kilmask;
}

/**
 * Unconditional fragment kill/discard.
 */
static void
exec_kill(struct tgsi_exec_machine *mach,
          const struct tgsi_full_instruction *inst)
{
   uint kilmask; /* bit 0 = pixel 0, bit 1 = pixel 1, etc */

   /* kill fragment for all fragments currently executing */
   kilmask = mach->ExecMask;
   mach->Temps[TEMP_KILMASK_I].xyzw[TEMP_KILMASK_C].u[0] |= kilmask;
}

static void
emit_vertex(struct tgsi_exec_machine *mach)
{
   /* FIXME: check for exec mask correctly
   unsigned i;
   for (i = 0; i < TGSI_QUAD_SIZE; ++i) {
         if ((mach->ExecMask & (1 << i)))
   */
   if (mach->ExecMask) {
      mach->Temps[TEMP_OUTPUT_I].xyzw[TEMP_OUTPUT_C].u[0] += mach->NumOutputs;
      mach->Primitives[mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0]]++;
   }
}

static void
emit_primitive(struct tgsi_exec_machine *mach)
{
   unsigned *prim_count = &mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0];
   /* FIXME: check for exec mask correctly
   unsigned i;
   for (i = 0; i < TGSI_QUAD_SIZE; ++i) {
         if ((mach->ExecMask & (1 << i)))
   */
   if (mach->ExecMask) {
      ++(*prim_count);
      debug_assert((*prim_count * mach->NumOutputs) < mach->MaxGeometryShaderOutputs);
      mach->Primitives[*prim_count] = 0;
   }
}

static void
conditional_emit_primitive(struct tgsi_exec_machine *mach)
{
   if (TGSI_PROCESSOR_GEOMETRY == mach->Processor) {
      int emitted_verts =
         mach->Primitives[mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0]];
      if (emitted_verts) {
         emit_primitive(mach);
      }
   }
}


/*
 * Fetch four texture samples using STR texture coordinates.
 */
static void
fetch_texel( struct tgsi_sampler *sampler,
             const unsigned sview_idx,
             const unsigned sampler_idx,
             const union tgsi_exec_channel *s,
             const union tgsi_exec_channel *t,
             const union tgsi_exec_channel *p,
             const union tgsi_exec_channel *c0,
             const union tgsi_exec_channel *c1,
             float derivs[3][2][TGSI_QUAD_SIZE],
             const int8_t offset[3],
             enum tgsi_sampler_control control,
             union tgsi_exec_channel *r,
             union tgsi_exec_channel *g,
             union tgsi_exec_channel *b,
             union tgsi_exec_channel *a )
{
   uint j;
   float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];

   /* FIXME: handle explicit derivs, offsets */
   sampler->get_samples(sampler, sview_idx, sampler_idx,
                        s->f, t->f, p->f, c0->f, c1->f, derivs, offset, control, rgba);

   for (j = 0; j < 4; j++) {
      r->f[j] = rgba[0][j];
      g->f[j] = rgba[1][j];
      b->f[j] = rgba[2][j];
      a->f[j] = rgba[3][j];
   }
}


#define TEX_MODIFIER_NONE           0
#define TEX_MODIFIER_PROJECTED      1
#define TEX_MODIFIER_LOD_BIAS       2
#define TEX_MODIFIER_EXPLICIT_LOD   3
#define TEX_MODIFIER_LEVEL_ZERO     4


/*
 * Fetch all 3 (for s,t,r coords) texel offsets, put them into int array.
 */
static void
fetch_texel_offsets(struct tgsi_exec_machine *mach,
                    const struct tgsi_full_instruction *inst,
                    int8_t offsets[3])
{
   if (inst->Texture.NumOffsets == 1) {
      union tgsi_exec_channel index;
      union tgsi_exec_channel offset[3];
      index.i[0] = index.i[1] = index.i[2] = index.i[3] = inst->TexOffsets[0].Index;
      fetch_src_file_channel(mach, 0, inst->TexOffsets[0].File,
                             inst->TexOffsets[0].SwizzleX, &index, &ZeroVec, &offset[0]);
      fetch_src_file_channel(mach, 0, inst->TexOffsets[0].File,
                             inst->TexOffsets[0].SwizzleY, &index, &ZeroVec, &offset[1]);
      fetch_src_file_channel(mach, 0, inst->TexOffsets[0].File,
                             inst->TexOffsets[0].SwizzleZ, &index, &ZeroVec, &offset[2]);
     offsets[0] = offset[0].i[0];
     offsets[1] = offset[1].i[0];
     offsets[2] = offset[2].i[0];
   } else {
     assert(inst->Texture.NumOffsets == 0);
     offsets[0] = offsets[1] = offsets[2] = 0;
   }
}


/*
 * Fetch dx and dy values for one channel (s, t or r).
 * Put dx values into one float array, dy values into another.
 */
static void
fetch_assign_deriv_channel(struct tgsi_exec_machine *mach,
                           const struct tgsi_full_instruction *inst,
                           unsigned regdsrcx,
                           unsigned chan,
                           float derivs[2][TGSI_QUAD_SIZE])
{
   union tgsi_exec_channel d;
   FETCH(&d, regdsrcx, chan);
   derivs[0][0] = d.f[0];
   derivs[0][1] = d.f[1];
   derivs[0][2] = d.f[2];
   derivs[0][3] = d.f[3];
   FETCH(&d, regdsrcx + 1, chan);
   derivs[1][0] = d.f[0];
   derivs[1][1] = d.f[1];
   derivs[1][2] = d.f[2];
   derivs[1][3] = d.f[3];
}


/*
 * execute a texture instruction.
 *
 * modifier is used to control the channel routing for the\
 * instruction variants like proj, lod, and texture with lod bias.
 * sampler indicates which src register the sampler is contained in.
 */
static void
exec_tex(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst,
         uint modifier, uint sampler)
{
   const uint unit = inst->Src[sampler].Register.Index;
   const union tgsi_exec_channel *args[5], *proj = NULL;
   union tgsi_exec_channel r[5];
   enum tgsi_sampler_control control =  tgsi_sampler_lod_none;
   uint chan;
   int8_t offsets[3];
   int dim, shadow_ref, i;

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

   assert(modifier != TEX_MODIFIER_LEVEL_ZERO);
   assert(inst->Texture.Texture != TGSI_TEXTURE_BUFFER);

   dim = tgsi_util_get_texture_coord_dim(inst->Texture.Texture, &shadow_ref);

   assert(dim <= 4);
   if (shadow_ref >= 0)
      assert(shadow_ref >= dim && shadow_ref < Elements(args));

   /* fetch modifier to the last argument */
   if (modifier != TEX_MODIFIER_NONE) {
      const int last = Elements(args) - 1;

      /* fetch modifier from src0.w or src1.x */
      if (sampler == 1) {
         assert(dim <= TGSI_CHAN_W && shadow_ref != TGSI_CHAN_W);
         FETCH(&r[last], 0, TGSI_CHAN_W);
      }
      else {
         assert(shadow_ref != 4);
         FETCH(&r[last], 1, TGSI_CHAN_X);
      }

      if (modifier != TEX_MODIFIER_PROJECTED) {
         args[last] = &r[last];
      }
      else {
         proj = &r[last];
         args[last] = &ZeroVec;
      }

      /* point unused arguments to zero vector */
      for (i = dim; i < last; i++)
         args[i] = &ZeroVec;

      if (modifier == TEX_MODIFIER_EXPLICIT_LOD)
         control = tgsi_sampler_lod_explicit;
      else if (modifier == TEX_MODIFIER_LOD_BIAS)
         control = tgsi_sampler_lod_bias;
   }
   else {
      for (i = dim; i < Elements(args); i++)
         args[i] = &ZeroVec;
   }

   /* fetch coordinates */
   for (i = 0; i < dim; i++) {
      FETCH(&r[i], 0, TGSI_CHAN_X + i);

      if (proj)
         micro_div(&r[i], &r[i], proj);

      args[i] = &r[i];
   }

   /* fetch reference value */
   if (shadow_ref >= 0) {
      FETCH(&r[shadow_ref], shadow_ref / 4, TGSI_CHAN_X + (shadow_ref % 4));

      if (proj)
         micro_div(&r[shadow_ref], &r[shadow_ref], proj);

      args[shadow_ref] = &r[shadow_ref];
   }

   fetch_texel(mach->Sampler, unit, unit,
         args[0], args[1], args[2], args[3], args[4],
         NULL, offsets, control,
         &r[0], &r[1], &r[2], &r[3]);     /* R, G, B, A */

#if 0
   debug_printf("fetch r: %g %g %g %g\n",
         r[0].f[0], r[0].f[1], r[0].f[2], r[0].f[3]);
   debug_printf("fetch g: %g %g %g %g\n",
         r[1].f[0], r[1].f[1], r[1].f[2], r[1].f[3]);
   debug_printf("fetch b: %g %g %g %g\n",
         r[2].f[0], r[2].f[1], r[2].f[2], r[2].f[3]);
   debug_printf("fetch a: %g %g %g %g\n",
         r[3].f[0], r[3].f[1], r[3].f[2], r[3].f[3]);
#endif

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}


static void
exec_txd(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   const uint unit = inst->Src[3].Register.Index;
   union tgsi_exec_channel r[4];
   float derivs[3][2][TGSI_QUAD_SIZE];
   uint chan;
   int8_t offsets[3];

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

   switch (inst->Texture.Texture) {
   case TGSI_TEXTURE_1D:
      FETCH(&r[0], 0, TGSI_CHAN_X);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &ZeroVec, &ZeroVec, &ZeroVec, &ZeroVec,   /* S, T, P, C, LOD */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);           /* R, G, B, A */
      break;

   case TGSI_TEXTURE_SHADOW1D:
   case TGSI_TEXTURE_1D_ARRAY:
   case TGSI_TEXTURE_SHADOW1D_ARRAY:
      /* SHADOW1D/1D_ARRAY would not need Y/Z respectively, but don't bother */
      FETCH(&r[0], 0, TGSI_CHAN_X);
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &r[1], &r[2], &ZeroVec, &ZeroVec,   /* S, T, P, C, LOD */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);           /* R, G, B, A */
      break;

   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_RECT:
      FETCH(&r[0], 0, TGSI_CHAN_X);
      FETCH(&r[1], 0, TGSI_CHAN_Y);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_Y, derivs[1]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &r[1], &ZeroVec, &ZeroVec, &ZeroVec,   /* S, T, P, C, LOD */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);           /* R, G, B, A */
      break;


   case TGSI_TEXTURE_SHADOW2D:
   case TGSI_TEXTURE_SHADOWRECT:
   case TGSI_TEXTURE_2D_ARRAY:
   case TGSI_TEXTURE_SHADOW2D_ARRAY:
      /* only SHADOW2D_ARRAY actually needs W */
      FETCH(&r[0], 0, TGSI_CHAN_X);
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      FETCH(&r[3], 0, TGSI_CHAN_W);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_Y, derivs[1]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &r[1], &r[2], &r[3], &ZeroVec,   /* inputs */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);     /* outputs */
      break;

   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_CUBE:
   case TGSI_TEXTURE_CUBE_ARRAY:
      /* only TEXTURE_CUBE_ARRAY actually needs W */
      FETCH(&r[0], 0, TGSI_CHAN_X);
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      FETCH(&r[3], 0, TGSI_CHAN_W);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_Y, derivs[1]);
      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_Z, derivs[2]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &r[1], &r[2], &r[3], &ZeroVec,   /* inputs */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);     /* outputs */
      break;

   default:
      assert(0);
   }

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}


static void
exec_txf(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   const uint unit = inst->Src[1].Register.Index;
   union tgsi_exec_channel r[4];
   uint chan;
   float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
   int j;
   int8_t offsets[3];
   unsigned target;

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

   IFETCH(&r[3], 0, TGSI_CHAN_W);

   if (inst->Instruction.Opcode == TGSI_OPCODE_SAMPLE_I) {
      target = mach->SamplerViews[unit].Resource;
   }
   else {
      target = inst->Texture.Texture;
   }
   switch(target) {
   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_2D_ARRAY:
   case TGSI_TEXTURE_SHADOW2D_ARRAY:
      IFETCH(&r[2], 0, TGSI_CHAN_Z);
      /* fallthrough */
   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_RECT:
   case TGSI_TEXTURE_SHADOW1D_ARRAY:
   case TGSI_TEXTURE_SHADOW2D:
   case TGSI_TEXTURE_SHADOWRECT:
   case TGSI_TEXTURE_1D_ARRAY:
      IFETCH(&r[1], 0, TGSI_CHAN_Y);
      /* fallthrough */
   case TGSI_TEXTURE_BUFFER:
   case TGSI_TEXTURE_1D:
   case TGSI_TEXTURE_SHADOW1D:
      IFETCH(&r[0], 0, TGSI_CHAN_X);
      break;
   default:
      assert(0);
      break;
   }      

   mach->Sampler->get_texel(mach->Sampler, unit, r[0].i, r[1].i, r[2].i, r[3].i,
                            offsets, rgba);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      r[0].f[j] = rgba[0][j];
      r[1].f[j] = rgba[1][j];
      r[2].f[j] = rgba[2][j];
      r[3].f[j] = rgba[3][j];
   }

   if (inst->Instruction.Opcode == TGSI_OPCODE_SAMPLE_I) {
      unsigned char swizzles[4];
      swizzles[0] = inst->Src[1].Register.SwizzleX;
      swizzles[1] = inst->Src[1].Register.SwizzleY;
      swizzles[2] = inst->Src[1].Register.SwizzleZ;
      swizzles[3] = inst->Src[1].Register.SwizzleW;

      for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
         if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
            store_dest(mach, &r[swizzles[chan]],
                       &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
         }
      }
   }
   else {
      for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
         if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
            store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
         }
      }
   }
}

static void
exec_txq(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   const uint unit = inst->Src[1].Register.Index;
   int result[4];
   union tgsi_exec_channel r[4], src;
   uint chan;
   int i,j;

   fetch_source(mach, &src, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_INT);

   /* XXX: This interface can't return per-pixel values */
   mach->Sampler->get_dims(mach->Sampler, unit, src.i[0], result);

   for (i = 0; i < TGSI_QUAD_SIZE; i++) {
      for (j = 0; j < 4; j++) {
         r[j].i[i] = result[j];
      }
   }

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan,
                    TGSI_EXEC_DATA_INT);
      }
   }
}

static void
exec_sample(struct tgsi_exec_machine *mach,
            const struct tgsi_full_instruction *inst,
            uint modifier, boolean compare)
{
   const uint resource_unit = inst->Src[1].Register.Index;
   const uint sampler_unit = inst->Src[2].Register.Index;
   union tgsi_exec_channel r[4], c1;
   const union tgsi_exec_channel *lod = &ZeroVec;
   enum tgsi_sampler_control control = tgsi_sampler_lod_none;
   uint chan;
   unsigned char swizzles[4];
   int8_t offsets[3];

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

   assert(modifier != TEX_MODIFIER_PROJECTED);

   if (modifier != TEX_MODIFIER_NONE) {
      if (modifier == TEX_MODIFIER_LOD_BIAS) {
         FETCH(&c1, 3, TGSI_CHAN_X);
         lod = &c1;
         control = tgsi_sampler_lod_bias;
      }
      else if (modifier == TEX_MODIFIER_EXPLICIT_LOD) {
         FETCH(&c1, 3, TGSI_CHAN_X);
         lod = &c1;
         control = tgsi_sampler_lod_explicit;
      }
      else {
         assert(modifier == TEX_MODIFIER_LEVEL_ZERO);
         control = tgsi_sampler_lod_zero;
      }
   }

   FETCH(&r[0], 0, TGSI_CHAN_X);

   switch (mach->SamplerViews[resource_unit].Resource) {
   case TGSI_TEXTURE_1D:
      if (compare) {
         FETCH(&r[2], 3, TGSI_CHAN_X);
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &ZeroVec, &r[2], &ZeroVec, lod, /* S, T, P, C, LOD */
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);     /* R, G, B, A */
      }
      else {
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &ZeroVec, &ZeroVec, &ZeroVec, lod, /* S, T, P, C, LOD */
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);     /* R, G, B, A */
      }
      break;

   case TGSI_TEXTURE_1D_ARRAY:
   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_RECT:
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      if (compare) {
         FETCH(&r[2], 3, TGSI_CHAN_X);
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &ZeroVec, lod,    /* S, T, P, C, LOD */
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);  /* outputs */
      }
      else {
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &ZeroVec, &ZeroVec, lod,    /* S, T, P, C, LOD */
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);  /* outputs */
      }
      break;

   case TGSI_TEXTURE_2D_ARRAY:
   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_CUBE:
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      if(compare) {
         FETCH(&r[3], 3, TGSI_CHAN_X);
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &r[3], lod,
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);
      }
      else {
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &ZeroVec, lod,
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);
      }
      break;

   case TGSI_TEXTURE_CUBE_ARRAY:
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      FETCH(&r[3], 0, TGSI_CHAN_W);
      if(compare) {
         FETCH(&r[4], 3, TGSI_CHAN_X);
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &r[3], &r[4],
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);
      }
      else {
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &r[3], lod,
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);
      }
      break;


   default:
      assert(0);
   }

   swizzles[0] = inst->Src[1].Register.SwizzleX;
   swizzles[1] = inst->Src[1].Register.SwizzleY;
   swizzles[2] = inst->Src[1].Register.SwizzleZ;
   swizzles[3] = inst->Src[1].Register.SwizzleW;

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[swizzles[chan]],
                    &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}

static void
exec_sample_d(struct tgsi_exec_machine *mach,
              const struct tgsi_full_instruction *inst)
{
   const uint resource_unit = inst->Src[1].Register.Index;
   const uint sampler_unit = inst->Src[2].Register.Index;
   union tgsi_exec_channel r[4];
   float derivs[3][2][TGSI_QUAD_SIZE];
   uint chan;
   unsigned char swizzles[4];
   int8_t offsets[3];

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

   FETCH(&r[0], 0, TGSI_CHAN_X);

   switch (mach->SamplerViews[resource_unit].Resource) {
   case TGSI_TEXTURE_1D:
   case TGSI_TEXTURE_1D_ARRAY:
      /* only 1D array actually needs Y */
      FETCH(&r[1], 0, TGSI_CHAN_Y);

      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_X, derivs[0]);

      fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                  &r[0], &r[1], &ZeroVec, &ZeroVec, &ZeroVec,   /* S, T, P, C, LOD */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);           /* R, G, B, A */
      break;

   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_RECT:
   case TGSI_TEXTURE_2D_ARRAY:
      /* only 2D array actually needs Z */
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);

      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_Y, derivs[1]);

      fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                  &r[0], &r[1], &r[2], &ZeroVec, &ZeroVec,   /* inputs */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);     /* outputs */
      break;

   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_CUBE:
   case TGSI_TEXTURE_CUBE_ARRAY:
      /* only cube array actually needs W */
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      FETCH(&r[3], 0, TGSI_CHAN_W);

      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_Y, derivs[1]);
      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_Z, derivs[2]);

      fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                  &r[0], &r[1], &r[2], &r[3], &ZeroVec,
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);
      break;

   default:
      assert(0);
   }

   swizzles[0] = inst->Src[1].Register.SwizzleX;
   swizzles[1] = inst->Src[1].Register.SwizzleY;
   swizzles[2] = inst->Src[1].Register.SwizzleZ;
   swizzles[3] = inst->Src[1].Register.SwizzleW;

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[swizzles[chan]],
                    &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}


/**
 * Evaluate a constant-valued coefficient at the position of the
 * current quad.
 */
static void
eval_constant_coef(
   struct tgsi_exec_machine *mach,
   unsigned attrib,
   unsigned chan )
{
   unsigned i;

   for( i = 0; i < TGSI_QUAD_SIZE; i++ ) {
      mach->Inputs[attrib].xyzw[chan].f[i] = mach->InterpCoefs[attrib].a0[chan];
   }
}

/**
 * Evaluate a linear-valued coefficient at the position of the
 * current quad.
 */
static void
eval_linear_coef(
   struct tgsi_exec_machine *mach,
   unsigned attrib,
   unsigned chan )
{
   const float x = mach->QuadPos.xyzw[0].f[0];
   const float y = mach->QuadPos.xyzw[1].f[0];
   const float dadx = mach->InterpCoefs[attrib].dadx[chan];
   const float dady = mach->InterpCoefs[attrib].dady[chan];
   const float a0 = mach->InterpCoefs[attrib].a0[chan] + dadx * x + dady * y;
   mach->Inputs[attrib].xyzw[chan].f[0] = a0;
   mach->Inputs[attrib].xyzw[chan].f[1] = a0 + dadx;
   mach->Inputs[attrib].xyzw[chan].f[2] = a0 + dady;
   mach->Inputs[attrib].xyzw[chan].f[3] = a0 + dadx + dady;
}

/**
 * Evaluate a perspective-valued coefficient at the position of the
 * current quad.
 */
static void
eval_perspective_coef(
   struct tgsi_exec_machine *mach,
   unsigned attrib,
   unsigned chan )
{
   const float x = mach->QuadPos.xyzw[0].f[0];
   const float y = mach->QuadPos.xyzw[1].f[0];
   const float dadx = mach->InterpCoefs[attrib].dadx[chan];
   const float dady = mach->InterpCoefs[attrib].dady[chan];
   const float a0 = mach->InterpCoefs[attrib].a0[chan] + dadx * x + dady * y;
   const float *w = mach->QuadPos.xyzw[3].f;
   /* divide by W here */
   mach->Inputs[attrib].xyzw[chan].f[0] = a0 / w[0];
   mach->Inputs[attrib].xyzw[chan].f[1] = (a0 + dadx) / w[1];
   mach->Inputs[attrib].xyzw[chan].f[2] = (a0 + dady) / w[2];
   mach->Inputs[attrib].xyzw[chan].f[3] = (a0 + dadx + dady) / w[3];
}


typedef void (* eval_coef_func)(
   struct tgsi_exec_machine *mach,
   unsigned attrib,
   unsigned chan );

static void
exec_declaration(struct tgsi_exec_machine *mach,
                 const struct tgsi_full_declaration *decl)
{
   if (decl->Declaration.File == TGSI_FILE_SAMPLER_VIEW) {
      mach->SamplerViews[decl->Range.First] = decl->SamplerView;
      return;
   }

   if (mach->Processor == TGSI_PROCESSOR_FRAGMENT) {
      if (decl->Declaration.File == TGSI_FILE_INPUT) {
         uint first, last, mask;

         first = decl->Range.First;
         last = decl->Range.Last;
         mask = decl->Declaration.UsageMask;

         /* XXX we could remove this special-case code since
          * mach->InterpCoefs[first].a0 should already have the
          * front/back-face value.  But we should first update the
          * ureg code to emit the right UsageMask value (WRITEMASK_X).
          * Then, we could remove the tgsi_exec_machine::Face field.
          */
         /* XXX make FACE a system value */
         if (decl->Semantic.Name == TGSI_SEMANTIC_FACE) {
            uint i;

            assert(decl->Semantic.Index == 0);
            assert(first == last);

            for (i = 0; i < TGSI_QUAD_SIZE; i++) {
               mach->Inputs[first].xyzw[0].f[i] = mach->Face;
            }
         } else {
            eval_coef_func eval;
            uint i, j;

            switch (decl->Interp.Interpolate) {
            case TGSI_INTERPOLATE_CONSTANT:
               eval = eval_constant_coef;
               break;

            case TGSI_INTERPOLATE_LINEAR:
               eval = eval_linear_coef;
               break;

            case TGSI_INTERPOLATE_PERSPECTIVE:
               eval = eval_perspective_coef;
               break;

            case TGSI_INTERPOLATE_COLOR:
               eval = mach->flatshade_color ? eval_constant_coef : eval_perspective_coef;
               break;

            default:
               assert(0);
               return;
            }

            for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
               if (mask & (1 << j)) {
                  for (i = first; i <= last; i++) {
                     eval(mach, i, j);
                  }
               }
            }
         }

         if (DEBUG_EXECUTION) {
            uint i, j;
            for (i = first; i <= last; ++i) {
               debug_printf("IN[%2u] = ", i);
               for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
                  if (j > 0) {
                     debug_printf("         ");
                  }
                  debug_printf("(%6f %u, %6f %u, %6f %u, %6f %u)\n",
                               mach->Inputs[i].xyzw[0].f[j], mach->Inputs[i].xyzw[0].u[j],
                               mach->Inputs[i].xyzw[1].f[j], mach->Inputs[i].xyzw[1].u[j],
                               mach->Inputs[i].xyzw[2].f[j], mach->Inputs[i].xyzw[2].u[j],
                               mach->Inputs[i].xyzw[3].f[j], mach->Inputs[i].xyzw[3].u[j]);
               }
            }
         }
      }
   }

   if (decl->Declaration.File == TGSI_FILE_SYSTEM_VALUE) {
      mach->SysSemanticToIndex[decl->Declaration.Semantic] = decl->Range.First;
   }
}


typedef void (* micro_op)(union tgsi_exec_channel *dst);

static void
exec_vector(struct tgsi_exec_machine *mach,
            const struct tgsi_full_instruction *inst,
            micro_op op,
            enum tgsi_exec_datatype dst_datatype)
{
   unsigned int chan;

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         union tgsi_exec_channel dst;

         op(&dst);
         store_dest(mach, &dst, &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

typedef void (* micro_unary_op)(union tgsi_exec_channel *dst,
                                const union tgsi_exec_channel *src);

static void
exec_scalar_unary(struct tgsi_exec_machine *mach,
                  const struct tgsi_full_instruction *inst,
                  micro_unary_op op,
                  enum tgsi_exec_datatype dst_datatype,
                  enum tgsi_exec_datatype src_datatype)
{
   unsigned int chan;
   union tgsi_exec_channel src;
   union tgsi_exec_channel dst;

   fetch_source(mach, &src, &inst->Src[0], TGSI_CHAN_X, src_datatype);
   op(&dst, &src);
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &dst, &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

static void
exec_vector_unary(struct tgsi_exec_machine *mach,
                  const struct tgsi_full_instruction *inst,
                  micro_unary_op op,
                  enum tgsi_exec_datatype dst_datatype,
                  enum tgsi_exec_datatype src_datatype)
{
   unsigned int chan;
   struct tgsi_exec_vector dst;

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         union tgsi_exec_channel src;

         fetch_source(mach, &src, &inst->Src[0], chan, src_datatype);
         op(&dst.xyzw[chan], &src);
      }
   }
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &dst.xyzw[chan], &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

typedef void (* micro_binary_op)(union tgsi_exec_channel *dst,
                                 const union tgsi_exec_channel *src0,
                                 const union tgsi_exec_channel *src1);

static void
exec_scalar_binary(struct tgsi_exec_machine *mach,
                   const struct tgsi_full_instruction *inst,
                   micro_binary_op op,
                   enum tgsi_exec_datatype dst_datatype,
                   enum tgsi_exec_datatype src_datatype)
{
   unsigned int chan;
   union tgsi_exec_channel src[2];
   union tgsi_exec_channel dst;

   fetch_source(mach, &src[0], &inst->Src[0], TGSI_CHAN_X, src_datatype);
   fetch_source(mach, &src[1], &inst->Src[1], TGSI_CHAN_X, src_datatype);
   op(&dst, &src[0], &src[1]);
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &dst, &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

static void
exec_vector_binary(struct tgsi_exec_machine *mach,
                   const struct tgsi_full_instruction *inst,
                   micro_binary_op op,
                   enum tgsi_exec_datatype dst_datatype,
                   enum tgsi_exec_datatype src_datatype)
{
   unsigned int chan;
   struct tgsi_exec_vector dst;

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         union tgsi_exec_channel src[2];

         fetch_source(mach, &src[0], &inst->Src[0], chan, src_datatype);
         fetch_source(mach, &src[1], &inst->Src[1], chan, src_datatype);
         op(&dst.xyzw[chan], &src[0], &src[1]);
      }
   }
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &dst.xyzw[chan], &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

typedef void (* micro_trinary_op)(union tgsi_exec_channel *dst,
                                  const union tgsi_exec_channel *src0,
                                  const union tgsi_exec_channel *src1,
                                  const union tgsi_exec_channel *src2);

static void
exec_vector_trinary(struct tgsi_exec_machine *mach,
                    const struct tgsi_full_instruction *inst,
                    micro_trinary_op op,
                    enum tgsi_exec_datatype dst_datatype,
                    enum tgsi_exec_datatype src_datatype)
{
   unsigned int chan;
   struct tgsi_exec_vector dst;

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         union tgsi_exec_channel src[3];

         fetch_source(mach, &src[0], &inst->Src[0], chan, src_datatype);
         fetch_source(mach, &src[1], &inst->Src[1], chan, src_datatype);
         fetch_source(mach, &src[2], &inst->Src[2], chan, src_datatype);
         op(&dst.xyzw[chan], &src[0], &src[1], &src[2]);
      }
   }
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &dst.xyzw[chan], &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

typedef void (* micro_quaternary_op)(union tgsi_exec_channel *dst,
                                     const union tgsi_exec_channel *src0,
                                     const union tgsi_exec_channel *src1,
                                     const union tgsi_exec_channel *src2,
                                     const union tgsi_exec_channel *src3);

static void
exec_vector_quaternary(struct tgsi_exec_machine *mach,
                       const struct tgsi_full_instruction *inst,
                       micro_quaternary_op op,
                       enum tgsi_exec_datatype dst_datatype,
                       enum tgsi_exec_datatype src_datatype)
{
   unsigned int chan;
   struct tgsi_exec_vector dst;

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         union tgsi_exec_channel src[4];

         fetch_source(mach, &src[0], &inst->Src[0], chan, src_datatype);
         fetch_source(mach, &src[1], &inst->Src[1], chan, src_datatype);
         fetch_source(mach, &src[2], &inst->Src[2], chan, src_datatype);
         fetch_source(mach, &src[3], &inst->Src[3], chan, src_datatype);
         op(&dst.xyzw[chan], &src[0], &src[1], &src[2], &src[3]);
      }
   }
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &dst.xyzw[chan], &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

static void
exec_dp3(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   unsigned int chan;
   union tgsi_exec_channel arg[3];

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_mul(&arg[2], &arg[0], &arg[1]);

   for (chan = TGSI_CHAN_Y; chan <= TGSI_CHAN_Z; chan++) {
      fetch_source(mach, &arg[0], &inst->Src[0], chan, TGSI_EXEC_DATA_FLOAT);
      fetch_source(mach, &arg[1], &inst->Src[1], chan, TGSI_EXEC_DATA_FLOAT);
      micro_mad(&arg[2], &arg[0], &arg[1], &arg[2]);
   }

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &arg[2], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}

static void
exec_dp4(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   unsigned int chan;
   union tgsi_exec_channel arg[3];

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_mul(&arg[2], &arg[0], &arg[1]);

   for (chan = TGSI_CHAN_Y; chan <= TGSI_CHAN_W; chan++) {
      fetch_source(mach, &arg[0], &inst->Src[0], chan, TGSI_EXEC_DATA_FLOAT);
      fetch_source(mach, &arg[1], &inst->Src[1], chan, TGSI_EXEC_DATA_FLOAT);
      micro_mad(&arg[2], &arg[0], &arg[1], &arg[2]);
   }

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &arg[2], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}

static void
exec_dp2a(struct tgsi_exec_machine *mach,
          const struct tgsi_full_instruction *inst)
{
   unsigned int chan;
   union tgsi_exec_channel arg[3];

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_mul(&arg[2], &arg[0], &arg[1]);

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   micro_mad(&arg[0], &arg[0], &arg[1], &arg[2]);

   fetch_source(mach, &arg[1], &inst->Src[2], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_add(&arg[0], &arg[0], &arg[1]);

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &arg[0], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}

static void
exec_dph(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   unsigned int chan;
   union tgsi_exec_channel arg[3];

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_mul(&arg[2], &arg[0], &arg[1]);

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   micro_mad(&arg[2], &arg[0], &arg[1], &arg[2]);

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   micro_mad(&arg[0], &arg[0], &arg[1], &arg[2]);

   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   micro_add(&arg[0], &arg[0], &arg[1]);

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &arg[0], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}

static void
exec_dp2(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   unsigned int chan;
   union tgsi_exec_channel arg[3];

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_mul(&arg[2], &arg[0], &arg[1]);

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   micro_mad(&arg[2], &arg[0], &arg[1], &arg[2]);

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &arg[2], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}

static void
exec_nrm4(struct tgsi_exec_machine *mach,
          const struct tgsi_full_instruction *inst)
{
   unsigned int chan;
   union tgsi_exec_channel arg[4];
   union tgsi_exec_channel scale;

   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_mul(&scale, &arg[0], &arg[0]);

   for (chan = TGSI_CHAN_Y; chan <= TGSI_CHAN_W; chan++) {
      union tgsi_exec_channel product;

      fetch_source(mach, &arg[chan], &inst->Src[0], chan, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&product, &arg[chan], &arg[chan]);
      micro_add(&scale, &scale, &product);
   }

   micro_rsq(&scale, &scale);

   for (chan = TGSI_CHAN_X; chan <= TGSI_CHAN_W; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         micro_mul(&arg[chan], &arg[chan], &scale);
         store_dest(mach, &arg[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}

static void
exec_nrm3(struct tgsi_exec_machine *mach,
          const struct tgsi_full_instruction *inst)
{
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_XYZ) {
      unsigned int chan;
      union tgsi_exec_channel arg[3];
      union tgsi_exec_channel scale;

      fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&scale, &arg[0], &arg[0]);

      for (chan = TGSI_CHAN_Y; chan <= TGSI_CHAN_Z; chan++) {
         union tgsi_exec_channel product;

         fetch_source(mach, &arg[chan], &inst->Src[0], chan, TGSI_EXEC_DATA_FLOAT);
         micro_mul(&product, &arg[chan], &arg[chan]);
         micro_add(&scale, &scale, &product);
      }

      micro_rsq(&scale, &scale);

      for (chan = TGSI_CHAN_X; chan <= TGSI_CHAN_Z; chan++) {
         if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
            micro_mul(&arg[chan], &arg[chan], &scale);
            store_dest(mach, &arg[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
         }
      }
   }

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_scs(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_XY) {
      union tgsi_exec_channel arg;
      union tgsi_exec_channel result;

      fetch_source(mach, &arg, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);

      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
         micro_cos(&result, &arg);
         store_dest(mach, &result, &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
      }
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
         micro_sin(&result, &arg);
         store_dest(mach, &result, &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      }
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &ZeroVec, &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_x2d(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[4];
   union tgsi_exec_channel d[2];

   fetch_source(mach, &r[0], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_XZ) {
      fetch_source(mach, &r[2], &inst->Src[2], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[2], &r[2], &r[0]);
      fetch_source(mach, &r[3], &inst->Src[2], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[3], &r[3], &r[1]);
      micro_add(&r[2], &r[2], &r[3]);
      fetch_source(mach, &r[3], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_add(&d[0], &r[2], &r[3]);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_YW) {
      fetch_source(mach, &r[2], &inst->Src[2], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[2], &r[2], &r[0]);
      fetch_source(mach, &r[3], &inst->Src[2], TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[3], &r[3], &r[1]);
      micro_add(&r[2], &r[2], &r[3]);
      fetch_source(mach, &r[3], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_add(&d[1], &r[2], &r[3]);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &d[0], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      store_dest(mach, &d[1], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &d[0], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &d[1], &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_rfl(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[9];

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_XYZ) {
      /* r0 = dp3(src0, src0) */
      fetch_source(mach, &r[2], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[0], &r[2], &r[2]);
      fetch_source(mach, &r[4], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[8], &r[4], &r[4]);
      micro_add(&r[0], &r[0], &r[8]);
      fetch_source(mach, &r[6], &inst->Src[0], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[8], &r[6], &r[6]);
      micro_add(&r[0], &r[0], &r[8]);

      /* r1 = dp3(src0, src1) */
      fetch_source(mach, &r[3], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[1], &r[2], &r[3]);
      fetch_source(mach, &r[5], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[8], &r[4], &r[5]);
      micro_add(&r[1], &r[1], &r[8]);
      fetch_source(mach, &r[7], &inst->Src[1], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[8], &r[6], &r[7]);
      micro_add(&r[1], &r[1], &r[8]);

      /* r1 = 2 * r1 / r0 */
      micro_add(&r[1], &r[1], &r[1]);
      micro_div(&r[1], &r[1], &r[0]);

      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
         micro_mul(&r[2], &r[2], &r[1]);
         micro_sub(&r[2], &r[2], &r[3]);
         store_dest(mach, &r[2], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
      }
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
         micro_mul(&r[4], &r[4], &r[1]);
         micro_sub(&r[4], &r[4], &r[5]);
         store_dest(mach, &r[4], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      }
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
         micro_mul(&r[6], &r[6], &r[1]);
         micro_sub(&r[6], &r[6], &r[7]);
         store_dest(mach, &r[6], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      }
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_xpd(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[6];
   union tgsi_exec_channel d[3];

   fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[1], &inst->Src[1], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);

   micro_mul(&r[2], &r[0], &r[1]);

   fetch_source(mach, &r[3], &inst->Src[0], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[4], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);

   micro_mul(&r[5], &r[3], &r[4] );
   micro_sub(&d[TGSI_CHAN_X], &r[2], &r[5]);

   fetch_source(mach, &r[2], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);

   micro_mul(&r[3], &r[3], &r[2]);

   fetch_source(mach, &r[5], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);

   micro_mul(&r[1], &r[1], &r[5]);
   micro_sub(&d[TGSI_CHAN_Y], &r[3], &r[1]);

   micro_mul(&r[5], &r[5], &r[4]);
   micro_mul(&r[0], &r[0], &r[2]);
   micro_sub(&d[TGSI_CHAN_Z], &r[5], &r[0]);

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &d[TGSI_CHAN_X], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      store_dest(mach, &d[TGSI_CHAN_Y], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &d[TGSI_CHAN_Z], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_dst(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[2];
   union tgsi_exec_channel d[4];

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      fetch_source(mach, &r[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&d[TGSI_CHAN_Y], &r[0], &r[1]);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      fetch_source(mach, &d[TGSI_CHAN_Z], &inst->Src[0], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      fetch_source(mach, &d[TGSI_CHAN_W], &inst->Src[1], TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      store_dest(mach, &d[TGSI_CHAN_Y], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &d[TGSI_CHAN_Z], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &d[TGSI_CHAN_W], &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_log(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[3];

   fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_abs(&r[2], &r[0]);  /* r2 = abs(r0) */
   micro_lg2(&r[1], &r[2]);  /* r1 = lg2(r2) */
   micro_flr(&r[0], &r[1]);  /* r0 = floor(r1) */
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &r[0], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      micro_exp2(&r[0], &r[0]);       /* r0 = 2 ^ r0 */
      micro_div(&r[0], &r[2], &r[0]); /* r0 = r2 / r0 */
      store_dest(mach, &r[0], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &r[1], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_exp(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[3];

   fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_flr(&r[1], &r[0]);  /* r1 = floor(r0) */
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      micro_exp2(&r[2], &r[1]);       /* r2 = 2 ^ r1 */
      store_dest(mach, &r[2], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      micro_sub(&r[2], &r[0], &r[1]); /* r2 = r0 - r1 */
      store_dest(mach, &r[2], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      micro_exp2(&r[2], &r[0]);       /* r2 = 2 ^ r0 */
      store_dest(mach, &r[2], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_lit(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[3];
   union tgsi_exec_channel d[3];

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_YZ) {
      fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
         fetch_source(mach, &r[1], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
         micro_max(&r[1], &r[1], &ZeroVec);

         fetch_source(mach, &r[2], &inst->Src[0], TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
         micro_min(&r[2], &r[2], &P128Vec);
         micro_max(&r[2], &r[2], &M128Vec);
         micro_pow(&r[1], &r[1], &r[2]);
         micro_lt(&d[TGSI_CHAN_Z], &ZeroVec, &r[0], &r[1], &ZeroVec);
         store_dest(mach, &d[TGSI_CHAN_Z], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      }
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
         micro_max(&d[TGSI_CHAN_Y], &r[0], &ZeroVec);
         store_dest(mach, &d[TGSI_CHAN_Y], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      }
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_break(struct tgsi_exec_machine *mach)
{
   if (mach->BreakType == TGSI_EXEC_BREAK_INSIDE_LOOP) {
      /* turn off loop channels for each enabled exec channel */
      mach->LoopMask &= ~mach->ExecMask;
      /* Todo: if mach->LoopMask == 0, jump to end of loop */
      UPDATE_EXEC_MASK(mach);
   } else {
      assert(mach->BreakType == TGSI_EXEC_BREAK_INSIDE_SWITCH);

      mach->Switch.mask = 0x0;

      UPDATE_EXEC_MASK(mach);
   }
}

static void
exec_switch(struct tgsi_exec_machine *mach,
            const struct tgsi_full_instruction *inst)
{
   assert(mach->SwitchStackTop < TGSI_EXEC_MAX_SWITCH_NESTING);
   assert(mach->BreakStackTop < TGSI_EXEC_MAX_BREAK_STACK);

   mach->SwitchStack[mach->SwitchStackTop++] = mach->Switch;
   fetch_source(mach, &mach->Switch.selector, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_UINT);
   mach->Switch.mask = 0x0;
   mach->Switch.defaultMask = 0x0;

   mach->BreakStack[mach->BreakStackTop++] = mach->BreakType;
   mach->BreakType = TGSI_EXEC_BREAK_INSIDE_SWITCH;

   UPDATE_EXEC_MASK(mach);
}

static void
exec_case(struct tgsi_exec_machine *mach,
          const struct tgsi_full_instruction *inst)
{
   uint prevMask = mach->SwitchStack[mach->SwitchStackTop - 1].mask;
   union tgsi_exec_channel src;
   uint mask = 0;

   fetch_source(mach, &src, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_UINT);

   if (mach->Switch.selector.u[0] == src.u[0]) {
      mask |= 0x1;
   }
   if (mach->Switch.selector.u[1] == src.u[1]) {
      mask |= 0x2;
   }
   if (mach->Switch.selector.u[2] == src.u[2]) {
      mask |= 0x4;
   }
   if (mach->Switch.selector.u[3] == src.u[3]) {
      mask |= 0x8;
   }

   mach->Switch.defaultMask |= mask;

   mach->Switch.mask |= mask & prevMask;

   UPDATE_EXEC_MASK(mach);
}

/* FIXME: this will only work if default is last */
static void
exec_default(struct tgsi_exec_machine *mach)
{
   uint prevMask = mach->SwitchStack[mach->SwitchStackTop - 1].mask;

   mach->Switch.mask |= ~mach->Switch.defaultMask & prevMask;

   UPDATE_EXEC_MASK(mach);
}

static void
exec_endswitch(struct tgsi_exec_machine *mach)
{
   mach->Switch = mach->SwitchStack[--mach->SwitchStackTop];
   mach->BreakType = mach->BreakStack[--mach->BreakStackTop];

   UPDATE_EXEC_MASK(mach);
}

static void
micro_i2f(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = (float)src->i[0];
   dst->f[1] = (float)src->i[1];
   dst->f[2] = (float)src->i[2];
   dst->f[3] = (float)src->i[3];
}

static void
micro_not(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->u[0] = ~src->u[0];
   dst->u[1] = ~src->u[1];
   dst->u[2] = ~src->u[2];
   dst->u[3] = ~src->u[3];
}

static void
micro_shl(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   unsigned masked_count;
   masked_count = src1->u[0] & 0x1f;
   dst->u[0] = src0->u[0] << masked_count;
   masked_count = src1->u[1] & 0x1f;
   dst->u[1] = src0->u[1] << masked_count;
   masked_count = src1->u[2] & 0x1f;
   dst->u[2] = src0->u[2] << masked_count;
   masked_count = src1->u[3] & 0x1f;
   dst->u[3] = src0->u[3] << masked_count;
}

static void
micro_and(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] & src1->u[0];
   dst->u[1] = src0->u[1] & src1->u[1];
   dst->u[2] = src0->u[2] & src1->u[2];
   dst->u[3] = src0->u[3] & src1->u[3];
}

static void
micro_or(union tgsi_exec_channel *dst,
         const union tgsi_exec_channel *src0,
         const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] | src1->u[0];
   dst->u[1] = src0->u[1] | src1->u[1];
   dst->u[2] = src0->u[2] | src1->u[2];
   dst->u[3] = src0->u[3] | src1->u[3];
}

static void
micro_xor(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] ^ src1->u[0];
   dst->u[1] = src0->u[1] ^ src1->u[1];
   dst->u[2] = src0->u[2] ^ src1->u[2];
   dst->u[3] = src0->u[3] ^ src1->u[3];
}

static void
micro_mod(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->i[0] = src0->i[0] % src1->i[0];
   dst->i[1] = src0->i[1] % src1->i[1];
   dst->i[2] = src0->i[2] % src1->i[2];
   dst->i[3] = src0->i[3] % src1->i[3];
}

static void
micro_f2i(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->i[0] = (int)src->f[0];
   dst->i[1] = (int)src->f[1];
   dst->i[2] = (int)src->f[2];
   dst->i[3] = (int)src->f[3];
}

static void
micro_fseq(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->f[0] == src1->f[0] ? ~0 : 0;
   dst->u[1] = src0->f[1] == src1->f[1] ? ~0 : 0;
   dst->u[2] = src0->f[2] == src1->f[2] ? ~0 : 0;
   dst->u[3] = src0->f[3] == src1->f[3] ? ~0 : 0;
}

static void
micro_fsge(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->f[0] >= src1->f[0] ? ~0 : 0;
   dst->u[1] = src0->f[1] >= src1->f[1] ? ~0 : 0;
   dst->u[2] = src0->f[2] >= src1->f[2] ? ~0 : 0;
   dst->u[3] = src0->f[3] >= src1->f[3] ? ~0 : 0;
}

static void
micro_fslt(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->f[0] < src1->f[0] ? ~0 : 0;
   dst->u[1] = src0->f[1] < src1->f[1] ? ~0 : 0;
   dst->u[2] = src0->f[2] < src1->f[2] ? ~0 : 0;
   dst->u[3] = src0->f[3] < src1->f[3] ? ~0 : 0;
}

static void
micro_fsne(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->f[0] != src1->f[0] ? ~0 : 0;
   dst->u[1] = src0->f[1] != src1->f[1] ? ~0 : 0;
   dst->u[2] = src0->f[2] != src1->f[2] ? ~0 : 0;
   dst->u[3] = src0->f[3] != src1->f[3] ? ~0 : 0;
}

static void
micro_idiv(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->i[0] = src1->i[0] ? src0->i[0] / src1->i[0] : 0;
   dst->i[1] = src1->i[1] ? src0->i[1] / src1->i[1] : 0;
   dst->i[2] = src1->i[2] ? src0->i[2] / src1->i[2] : 0;
   dst->i[3] = src1->i[3] ? src0->i[3] / src1->i[3] : 0;
}

static void
micro_imax(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->i[0] = src0->i[0] > src1->i[0] ? src0->i[0] : src1->i[0];
   dst->i[1] = src0->i[1] > src1->i[1] ? src0->i[1] : src1->i[1];
   dst->i[2] = src0->i[2] > src1->i[2] ? src0->i[2] : src1->i[2];
   dst->i[3] = src0->i[3] > src1->i[3] ? src0->i[3] : src1->i[3];
}

static void
micro_imin(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->i[0] = src0->i[0] < src1->i[0] ? src0->i[0] : src1->i[0];
   dst->i[1] = src0->i[1] < src1->i[1] ? src0->i[1] : src1->i[1];
   dst->i[2] = src0->i[2] < src1->i[2] ? src0->i[2] : src1->i[2];
   dst->i[3] = src0->i[3] < src1->i[3] ? src0->i[3] : src1->i[3];
}

static void
micro_isge(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->i[0] = src0->i[0] >= src1->i[0] ? -1 : 0;
   dst->i[1] = src0->i[1] >= src1->i[1] ? -1 : 0;
   dst->i[2] = src0->i[2] >= src1->i[2] ? -1 : 0;
   dst->i[3] = src0->i[3] >= src1->i[3] ? -1 : 0;
}

static void
micro_ishr(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   unsigned masked_count;
   masked_count = src1->i[0] & 0x1f;
   dst->i[0] = src0->i[0] >> masked_count;
   masked_count = src1->i[1] & 0x1f;
   dst->i[1] = src0->i[1] >> masked_count;
   masked_count = src1->i[2] & 0x1f;
   dst->i[2] = src0->i[2] >> masked_count;
   masked_count = src1->i[3] & 0x1f;
   dst->i[3] = src0->i[3] >> masked_count;
}

static void
micro_islt(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->i[0] = src0->i[0] < src1->i[0] ? -1 : 0;
   dst->i[1] = src0->i[1] < src1->i[1] ? -1 : 0;
   dst->i[2] = src0->i[2] < src1->i[2] ? -1 : 0;
   dst->i[3] = src0->i[3] < src1->i[3] ? -1 : 0;
}

static void
micro_f2u(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->u[0] = (uint)src->f[0];
   dst->u[1] = (uint)src->f[1];
   dst->u[2] = (uint)src->f[2];
   dst->u[3] = (uint)src->f[3];
}

static void
micro_u2f(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->f[0] = (float)src->u[0];
   dst->f[1] = (float)src->u[1];
   dst->f[2] = (float)src->u[2];
   dst->f[3] = (float)src->u[3];
}

static void
micro_uadd(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] + src1->u[0];
   dst->u[1] = src0->u[1] + src1->u[1];
   dst->u[2] = src0->u[2] + src1->u[2];
   dst->u[3] = src0->u[3] + src1->u[3];
}

static void
micro_udiv(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src1->u[0] ? src0->u[0] / src1->u[0] : ~0u;
   dst->u[1] = src1->u[1] ? src0->u[1] / src1->u[1] : ~0u;
   dst->u[2] = src1->u[2] ? src0->u[2] / src1->u[2] : ~0u;
   dst->u[3] = src1->u[3] ? src0->u[3] / src1->u[3] : ~0u;
}

static void
micro_umad(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1,
           const union tgsi_exec_channel *src2)
{
   dst->u[0] = src0->u[0] * src1->u[0] + src2->u[0];
   dst->u[1] = src0->u[1] * src1->u[1] + src2->u[1];
   dst->u[2] = src0->u[2] * src1->u[2] + src2->u[2];
   dst->u[3] = src0->u[3] * src1->u[3] + src2->u[3];
}

static void
micro_umax(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] > src1->u[0] ? src0->u[0] : src1->u[0];
   dst->u[1] = src0->u[1] > src1->u[1] ? src0->u[1] : src1->u[1];
   dst->u[2] = src0->u[2] > src1->u[2] ? src0->u[2] : src1->u[2];
   dst->u[3] = src0->u[3] > src1->u[3] ? src0->u[3] : src1->u[3];
}

static void
micro_umin(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] < src1->u[0] ? src0->u[0] : src1->u[0];
   dst->u[1] = src0->u[1] < src1->u[1] ? src0->u[1] : src1->u[1];
   dst->u[2] = src0->u[2] < src1->u[2] ? src0->u[2] : src1->u[2];
   dst->u[3] = src0->u[3] < src1->u[3] ? src0->u[3] : src1->u[3];
}

static void
micro_umod(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src1->u[0] ? src0->u[0] % src1->u[0] : ~0u;
   dst->u[1] = src1->u[1] ? src0->u[1] % src1->u[1] : ~0u;
   dst->u[2] = src1->u[2] ? src0->u[2] % src1->u[2] : ~0u;
   dst->u[3] = src1->u[3] ? src0->u[3] % src1->u[3] : ~0u;
}

static void
micro_umul(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] * src1->u[0];
   dst->u[1] = src0->u[1] * src1->u[1];
   dst->u[2] = src0->u[2] * src1->u[2];
   dst->u[3] = src0->u[3] * src1->u[3];
}

static void
micro_imul_hi(union tgsi_exec_channel *dst,
              const union tgsi_exec_channel *src0,
              const union tgsi_exec_channel *src1)
{
#define I64M(x, y) ((((int64_t)x) * ((int64_t)y)) >> 32)
   dst->i[0] = I64M(src0->i[0], src1->i[0]);
   dst->i[1] = I64M(src0->i[1], src1->i[1]);
   dst->i[2] = I64M(src0->i[2], src1->i[2]);
   dst->i[3] = I64M(src0->i[3], src1->i[3]);
#undef I64M
}

static void
micro_umul_hi(union tgsi_exec_channel *dst,
              const union tgsi_exec_channel *src0,
              const union tgsi_exec_channel *src1)
{
#define U64M(x, y) ((((uint64_t)x) * ((uint64_t)y)) >> 32)
   dst->u[0] = U64M(src0->u[0], src1->u[0]);
   dst->u[1] = U64M(src0->u[1], src1->u[1]);
   dst->u[2] = U64M(src0->u[2], src1->u[2]);
   dst->u[3] = U64M(src0->u[3], src1->u[3]);
#undef U64M
}

static void
micro_useq(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] == src1->u[0] ? ~0 : 0;
   dst->u[1] = src0->u[1] == src1->u[1] ? ~0 : 0;
   dst->u[2] = src0->u[2] == src1->u[2] ? ~0 : 0;
   dst->u[3] = src0->u[3] == src1->u[3] ? ~0 : 0;
}

static void
micro_usge(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] >= src1->u[0] ? ~0 : 0;
   dst->u[1] = src0->u[1] >= src1->u[1] ? ~0 : 0;
   dst->u[2] = src0->u[2] >= src1->u[2] ? ~0 : 0;
   dst->u[3] = src0->u[3] >= src1->u[3] ? ~0 : 0;
}

static void
micro_ushr(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   unsigned masked_count;
   masked_count = src1->u[0] & 0x1f;
   dst->u[0] = src0->u[0] >> masked_count;
   masked_count = src1->u[1] & 0x1f;
   dst->u[1] = src0->u[1] >> masked_count;
   masked_count = src1->u[2] & 0x1f;
   dst->u[2] = src0->u[2] >> masked_count;
   masked_count = src1->u[3] & 0x1f;
   dst->u[3] = src0->u[3] >> masked_count;
}

static void
micro_uslt(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] < src1->u[0] ? ~0 : 0;
   dst->u[1] = src0->u[1] < src1->u[1] ? ~0 : 0;
   dst->u[2] = src0->u[2] < src1->u[2] ? ~0 : 0;
   dst->u[3] = src0->u[3] < src1->u[3] ? ~0 : 0;
}

static void
micro_usne(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->u[0] != src1->u[0] ? ~0 : 0;
   dst->u[1] = src0->u[1] != src1->u[1] ? ~0 : 0;
   dst->u[2] = src0->u[2] != src1->u[2] ? ~0 : 0;
   dst->u[3] = src0->u[3] != src1->u[3] ? ~0 : 0;
}

static void
micro_uarl(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->i[0] = src->u[0];
   dst->i[1] = src->u[1];
   dst->i[2] = src->u[2];
   dst->i[3] = src->u[3];
}

static void
micro_ucmp(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1,
           const union tgsi_exec_channel *src2)
{
   dst->u[0] = src0->u[0] ? src1->u[0] : src2->u[0];
   dst->u[1] = src0->u[1] ? src1->u[1] : src2->u[1];
   dst->u[2] = src0->u[2] ? src1->u[2] : src2->u[2];
   dst->u[3] = src0->u[3] ? src1->u[3] : src2->u[3];
}

/**
 * Signed bitfield extract (i.e. sign-extend the extracted bits)
 */
static void
micro_ibfe(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1,
           const union tgsi_exec_channel *src2)
{
   int i;
   for (i = 0; i < 4; i++) {
      int width = src2->i[i] & 0x1f;
      int offset = src1->i[i] & 0x1f;
      if (width == 0)
         dst->i[i] = 0;
      else if (width + offset < 32)
         dst->i[i] = (src0->i[i] << (32 - width - offset)) >> (32 - width);
      else
         dst->i[i] = src0->i[i] >> offset;
   }
}

/**
 * Unsigned bitfield extract
 */
static void
micro_ubfe(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1,
           const union tgsi_exec_channel *src2)
{
   int i;
   for (i = 0; i < 4; i++) {
      int width = src2->u[i] & 0x1f;
      int offset = src1->u[i] & 0x1f;
      if (width == 0)
         dst->u[i] = 0;
      else if (width + offset < 32)
         dst->u[i] = (src0->u[i] << (32 - width - offset)) >> (32 - width);
      else
         dst->u[i] = src0->u[i] >> offset;
   }
}

/**
 * Bitfield insert: copy low bits from src1 into a region of src0.
 */
static void
micro_bfi(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1,
          const union tgsi_exec_channel *src2,
          const union tgsi_exec_channel *src3)
{
   int i;
   for (i = 0; i < 4; i++) {
      int width = src3->u[i] & 0x1f;
      int offset = src2->u[i] & 0x1f;
      int bitmask = ((1 << width) - 1) << offset;
      dst->u[i] = ((src1->u[i] << offset) & bitmask) | (src0->u[i] & ~bitmask);
   }
}

static void
micro_brev(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->u[0] = util_bitreverse(src->u[0]);
   dst->u[1] = util_bitreverse(src->u[1]);
   dst->u[2] = util_bitreverse(src->u[2]);
   dst->u[3] = util_bitreverse(src->u[3]);
}

static void
micro_popc(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->u[0] = util_bitcount(src->u[0]);
   dst->u[1] = util_bitcount(src->u[1]);
   dst->u[2] = util_bitcount(src->u[2]);
   dst->u[3] = util_bitcount(src->u[3]);
}

static void
micro_lsb(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->i[0] = ffs(src->u[0]) - 1;
   dst->i[1] = ffs(src->u[1]) - 1;
   dst->i[2] = ffs(src->u[2]) - 1;
   dst->i[3] = ffs(src->u[3]) - 1;
}

static void
micro_imsb(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->i[0] = util_last_bit_signed(src->i[0]) - 1;
   dst->i[1] = util_last_bit_signed(src->i[1]) - 1;
   dst->i[2] = util_last_bit_signed(src->i[2]) - 1;
   dst->i[3] = util_last_bit_signed(src->i[3]) - 1;
}

static void
micro_umsb(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->i[0] = util_last_bit(src->u[0]) - 1;
   dst->i[1] = util_last_bit(src->u[1]) - 1;
   dst->i[2] = util_last_bit(src->u[2]) - 1;
   dst->i[3] = util_last_bit(src->u[3]) - 1;
}

static void
exec_instruction(
   struct tgsi_exec_machine *mach,
   const struct tgsi_full_instruction *inst,
   int *pc )
{
   union tgsi_exec_channel r[10];

   (*pc)++;

   switch (inst->Instruction.Opcode) {
   case TGSI_OPCODE_ARL:
      exec_vector_unary(mach, inst, micro_arl, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_MOV:
      exec_vector_unary(mach, inst, micro_mov, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_LIT:
      exec_lit(mach, inst);
      break;

   case TGSI_OPCODE_RCP:
      exec_scalar_unary(mach, inst, micro_rcp, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_RSQ:
      exec_scalar_unary(mach, inst, micro_rsq, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_EXP:
      exec_exp(mach, inst);
      break;

   case TGSI_OPCODE_LOG:
      exec_log(mach, inst);
      break;

   case TGSI_OPCODE_MUL:
      exec_vector_binary(mach, inst, micro_mul, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_ADD:
      exec_vector_binary(mach, inst, micro_add, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_DP3:
      exec_dp3(mach, inst);
      break;

   case TGSI_OPCODE_DP4:
      exec_dp4(mach, inst);
      break;

   case TGSI_OPCODE_DST:
      exec_dst(mach, inst);
      break;

   case TGSI_OPCODE_MIN:
      exec_vector_binary(mach, inst, micro_min, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_MAX:
      exec_vector_binary(mach, inst, micro_max, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SLT:
      exec_vector_binary(mach, inst, micro_slt, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SGE:
      exec_vector_binary(mach, inst, micro_sge, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_MAD:
      exec_vector_trinary(mach, inst, micro_mad, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SUB:
      exec_vector_binary(mach, inst, micro_sub, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_LRP:
      exec_vector_trinary(mach, inst, micro_lrp, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_CND:
      exec_vector_trinary(mach, inst, micro_cnd, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SQRT:
      exec_scalar_unary(mach, inst, micro_sqrt, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_DP2A:
      exec_dp2a(mach, inst);
      break;

   case TGSI_OPCODE_FRC:
      exec_vector_unary(mach, inst, micro_frc, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_CLAMP:
      exec_vector_trinary(mach, inst, micro_clamp, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_FLR:
      exec_vector_unary(mach, inst, micro_flr, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_ROUND:
      exec_vector_unary(mach, inst, micro_rnd, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_EX2:
      exec_scalar_unary(mach, inst, micro_exp2, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_LG2:
      exec_scalar_unary(mach, inst, micro_lg2, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_POW:
      exec_scalar_binary(mach, inst, micro_pow, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_XPD:
      exec_xpd(mach, inst);
      break;

   case TGSI_OPCODE_ABS:
      exec_vector_unary(mach, inst, micro_abs, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_RCC:
      exec_scalar_unary(mach, inst, micro_rcc, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_DPH:
      exec_dph(mach, inst);
      break;

   case TGSI_OPCODE_COS:
      exec_scalar_unary(mach, inst, micro_cos, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_DDX:
      exec_vector_unary(mach, inst, micro_ddx, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_DDY:
      exec_vector_unary(mach, inst, micro_ddy, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_KILL:
      exec_kill (mach, inst);
      break;

   case TGSI_OPCODE_KILL_IF:
      exec_kill_if (mach, inst);
      break;

   case TGSI_OPCODE_PK2H:
      assert (0);
      break;

   case TGSI_OPCODE_PK2US:
      assert (0);
      break;

   case TGSI_OPCODE_PK4B:
      assert (0);
      break;

   case TGSI_OPCODE_PK4UB:
      assert (0);
      break;

   case TGSI_OPCODE_RFL:
      exec_rfl(mach, inst);
      break;

   case TGSI_OPCODE_SEQ:
      exec_vector_binary(mach, inst, micro_seq, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SFL:
      exec_vector(mach, inst, micro_sfl, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SGT:
      exec_vector_binary(mach, inst, micro_sgt, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SIN:
      exec_scalar_unary(mach, inst, micro_sin, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SLE:
      exec_vector_binary(mach, inst, micro_sle, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SNE:
      exec_vector_binary(mach, inst, micro_sne, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_STR:
      exec_vector(mach, inst, micro_str, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_TEX:
      /* simple texture lookup */
      /* src[0] = texcoord */
      /* src[1] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_NONE, 1);
      break;

   case TGSI_OPCODE_TXB:
      /* Texture lookup with lod bias */
      /* src[0] = texcoord (src[0].w = LOD bias) */
      /* src[1] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_LOD_BIAS, 1);
      break;

   case TGSI_OPCODE_TXD:
      /* Texture lookup with explict partial derivatives */
      /* src[0] = texcoord */
      /* src[1] = d[strq]/dx */
      /* src[2] = d[strq]/dy */
      /* src[3] = sampler unit */
      exec_txd(mach, inst);
      break;

   case TGSI_OPCODE_TXL:
      /* Texture lookup with explit LOD */
      /* src[0] = texcoord (src[0].w = LOD) */
      /* src[1] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_EXPLICIT_LOD, 1);
      break;

   case TGSI_OPCODE_TXP:
      /* Texture lookup with projection */
      /* src[0] = texcoord (src[0].w = projection) */
      /* src[1] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_PROJECTED, 1);
      break;

   case TGSI_OPCODE_UP2H:
      assert (0);
      break;

   case TGSI_OPCODE_UP2US:
      assert (0);
      break;

   case TGSI_OPCODE_UP4B:
      assert (0);
      break;

   case TGSI_OPCODE_UP4UB:
      assert (0);
      break;

   case TGSI_OPCODE_X2D:
      exec_x2d(mach, inst);
      break;

   case TGSI_OPCODE_ARA:
      assert (0);
      break;

   case TGSI_OPCODE_ARR:
      exec_vector_unary(mach, inst, micro_arr, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_BRA:
      assert (0);
      break;

   case TGSI_OPCODE_CAL:
      /* skip the call if no execution channels are enabled */
      if (mach->ExecMask) {
         /* do the call */

         /* First, record the depths of the execution stacks.
          * This is important for deeply nested/looped return statements.
          * We have to unwind the stacks by the correct amount.  For a
          * real code generator, we could determine the number of entries
          * to pop off each stack with simple static analysis and avoid
          * implementing this data structure at run time.
          */
         mach->CallStack[mach->CallStackTop].CondStackTop = mach->CondStackTop;
         mach->CallStack[mach->CallStackTop].LoopStackTop = mach->LoopStackTop;
         mach->CallStack[mach->CallStackTop].ContStackTop = mach->ContStackTop;
         mach->CallStack[mach->CallStackTop].SwitchStackTop = mach->SwitchStackTop;
         mach->CallStack[mach->CallStackTop].BreakStackTop = mach->BreakStackTop;
         /* note that PC was already incremented above */
         mach->CallStack[mach->CallStackTop].ReturnAddr = *pc;

         mach->CallStackTop++;

         /* Second, push the Cond, Loop, Cont, Func stacks */
         assert(mach->CondStackTop < TGSI_EXEC_MAX_COND_NESTING);
         assert(mach->LoopStackTop < TGSI_EXEC_MAX_LOOP_NESTING);
         assert(mach->ContStackTop < TGSI_EXEC_MAX_LOOP_NESTING);
         assert(mach->SwitchStackTop < TGSI_EXEC_MAX_SWITCH_NESTING);
         assert(mach->BreakStackTop < TGSI_EXEC_MAX_BREAK_STACK);
         assert(mach->FuncStackTop < TGSI_EXEC_MAX_CALL_NESTING);

         mach->CondStack[mach->CondStackTop++] = mach->CondMask;
         mach->LoopStack[mach->LoopStackTop++] = mach->LoopMask;
         mach->ContStack[mach->ContStackTop++] = mach->ContMask;
         mach->SwitchStack[mach->SwitchStackTop++] = mach->Switch;
         mach->BreakStack[mach->BreakStackTop++] = mach->BreakType;
         mach->FuncStack[mach->FuncStackTop++] = mach->FuncMask;

         /* Finally, jump to the subroutine */
         *pc = inst->Label.Label;
      }
      break;

   case TGSI_OPCODE_RET:
      mach->FuncMask &= ~mach->ExecMask;
      UPDATE_EXEC_MASK(mach);

      if (mach->FuncMask == 0x0) {
         /* really return now (otherwise, keep executing */

         if (mach->CallStackTop == 0) {
            /* returning from main() */
            mach->CondStackTop = 0;
            mach->LoopStackTop = 0;
            *pc = -1;
            return;
         }

         assert(mach->CallStackTop > 0);
         mach->CallStackTop--;

         mach->CondStackTop = mach->CallStack[mach->CallStackTop].CondStackTop;
         mach->CondMask = mach->CondStack[mach->CondStackTop];

         mach->LoopStackTop = mach->CallStack[mach->CallStackTop].LoopStackTop;
         mach->LoopMask = mach->LoopStack[mach->LoopStackTop];

         mach->ContStackTop = mach->CallStack[mach->CallStackTop].ContStackTop;
         mach->ContMask = mach->ContStack[mach->ContStackTop];

         mach->SwitchStackTop = mach->CallStack[mach->CallStackTop].SwitchStackTop;
         mach->Switch = mach->SwitchStack[mach->SwitchStackTop];

         mach->BreakStackTop = mach->CallStack[mach->CallStackTop].BreakStackTop;
         mach->BreakType = mach->BreakStack[mach->BreakStackTop];

         assert(mach->FuncStackTop > 0);
         mach->FuncMask = mach->FuncStack[--mach->FuncStackTop];

         *pc = mach->CallStack[mach->CallStackTop].ReturnAddr;

         UPDATE_EXEC_MASK(mach);
      }
      break;

   case TGSI_OPCODE_SSG:
      exec_vector_unary(mach, inst, micro_sgn, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_CMP:
      exec_vector_trinary(mach, inst, micro_cmp, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SCS:
      exec_scs(mach, inst);
      break;

   case TGSI_OPCODE_NRM:
      exec_nrm3(mach, inst);
      break;

   case TGSI_OPCODE_NRM4:
      exec_nrm4(mach, inst);
      break;

   case TGSI_OPCODE_DIV:
      exec_vector_binary(mach, inst, micro_div, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_DP2:
      exec_dp2(mach, inst);
      break;

   case TGSI_OPCODE_IF:
      /* push CondMask */
      assert(mach->CondStackTop < TGSI_EXEC_MAX_COND_NESTING);
      mach->CondStack[mach->CondStackTop++] = mach->CondMask;
      FETCH( &r[0], 0, TGSI_CHAN_X );
      /* update CondMask */
      if( ! r[0].f[0] ) {
         mach->CondMask &= ~0x1;
      }
      if( ! r[0].f[1] ) {
         mach->CondMask &= ~0x2;
      }
      if( ! r[0].f[2] ) {
         mach->CondMask &= ~0x4;
      }
      if( ! r[0].f[3] ) {
         mach->CondMask &= ~0x8;
      }
      UPDATE_EXEC_MASK(mach);
      /* Todo: If CondMask==0, jump to ELSE */
      break;

   case TGSI_OPCODE_UIF:
      /* push CondMask */
      assert(mach->CondStackTop < TGSI_EXEC_MAX_COND_NESTING);
      mach->CondStack[mach->CondStackTop++] = mach->CondMask;
      IFETCH( &r[0], 0, TGSI_CHAN_X );
      /* update CondMask */
      if( ! r[0].u[0] ) {
         mach->CondMask &= ~0x1;
      }
      if( ! r[0].u[1] ) {
         mach->CondMask &= ~0x2;
      }
      if( ! r[0].u[2] ) {
         mach->CondMask &= ~0x4;
      }
      if( ! r[0].u[3] ) {
         mach->CondMask &= ~0x8;
      }
      UPDATE_EXEC_MASK(mach);
      /* Todo: If CondMask==0, jump to ELSE */
      break;

   case TGSI_OPCODE_ELSE:
      /* invert CondMask wrt previous mask */
      {
         uint prevMask;
         assert(mach->CondStackTop > 0);
         prevMask = mach->CondStack[mach->CondStackTop - 1];
         mach->CondMask = ~mach->CondMask & prevMask;
         UPDATE_EXEC_MASK(mach);
         /* Todo: If CondMask==0, jump to ENDIF */
      }
      break;

   case TGSI_OPCODE_ENDIF:
      /* pop CondMask */
      assert(mach->CondStackTop > 0);
      mach->CondMask = mach->CondStack[--mach->CondStackTop];
      UPDATE_EXEC_MASK(mach);
      break;

   case TGSI_OPCODE_END:
      /* make sure we end primitives which haven't
       * been explicitly emitted */
      conditional_emit_primitive(mach);
      /* halt execution */
      *pc = -1;
      break;

   case TGSI_OPCODE_PUSHA:
      assert (0);
      break;

   case TGSI_OPCODE_POPA:
      assert (0);
      break;

   case TGSI_OPCODE_CEIL:
      exec_vector_unary(mach, inst, micro_ceil, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_I2F:
      exec_vector_unary(mach, inst, micro_i2f, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_NOT:
      exec_vector_unary(mach, inst, micro_not, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_TRUNC:
      exec_vector_unary(mach, inst, micro_trunc, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_SHL:
      exec_vector_binary(mach, inst, micro_shl, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_AND:
      exec_vector_binary(mach, inst, micro_and, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_OR:
      exec_vector_binary(mach, inst, micro_or, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_MOD:
      exec_vector_binary(mach, inst, micro_mod, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_XOR:
      exec_vector_binary(mach, inst, micro_xor, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_SAD:
      assert (0);
      break;

   case TGSI_OPCODE_TXF:
      exec_txf(mach, inst);
      break;

   case TGSI_OPCODE_TXQ:
      exec_txq(mach, inst);
      break;

   case TGSI_OPCODE_EMIT:
      emit_vertex(mach);
      break;

   case TGSI_OPCODE_ENDPRIM:
      emit_primitive(mach);
      break;

   case TGSI_OPCODE_BGNLOOP:
      /* push LoopMask and ContMasks */
      assert(mach->LoopStackTop < TGSI_EXEC_MAX_LOOP_NESTING);
      assert(mach->ContStackTop < TGSI_EXEC_MAX_LOOP_NESTING);
      assert(mach->LoopLabelStackTop < TGSI_EXEC_MAX_LOOP_NESTING);
      assert(mach->BreakStackTop < TGSI_EXEC_MAX_BREAK_STACK);

      mach->LoopStack[mach->LoopStackTop++] = mach->LoopMask;
      mach->ContStack[mach->ContStackTop++] = mach->ContMask;
      mach->LoopLabelStack[mach->LoopLabelStackTop++] = *pc - 1;
      mach->BreakStack[mach->BreakStackTop++] = mach->BreakType;
      mach->BreakType = TGSI_EXEC_BREAK_INSIDE_LOOP;
      break;

   case TGSI_OPCODE_ENDLOOP:
      /* Restore ContMask, but don't pop */
      assert(mach->ContStackTop > 0);
      mach->ContMask = mach->ContStack[mach->ContStackTop - 1];
      UPDATE_EXEC_MASK(mach);
      if (mach->ExecMask) {
         /* repeat loop: jump to instruction just past BGNLOOP */
         assert(mach->LoopLabelStackTop > 0);
         *pc = mach->LoopLabelStack[mach->LoopLabelStackTop - 1] + 1;
      }
      else {
         /* exit loop: pop LoopMask */
         assert(mach->LoopStackTop > 0);
         mach->LoopMask = mach->LoopStack[--mach->LoopStackTop];
         /* pop ContMask */
         assert(mach->ContStackTop > 0);
         mach->ContMask = mach->ContStack[--mach->ContStackTop];
         assert(mach->LoopLabelStackTop > 0);
         --mach->LoopLabelStackTop;

         mach->BreakType = mach->BreakStack[--mach->BreakStackTop];
      }
      UPDATE_EXEC_MASK(mach);
      break;

   case TGSI_OPCODE_BRK:
      exec_break(mach);
      break;

   case TGSI_OPCODE_CONT:
      /* turn off cont channels for each enabled exec channel */
      mach->ContMask &= ~mach->ExecMask;
      /* Todo: if mach->LoopMask == 0, jump to end of loop */
      UPDATE_EXEC_MASK(mach);
      break;

   case TGSI_OPCODE_BGNSUB:
      /* no-op */
      break;

   case TGSI_OPCODE_ENDSUB:
      /*
       * XXX: This really should be a no-op. We should never reach this opcode.
       */

      assert(mach->CallStackTop > 0);
      mach->CallStackTop--;

      mach->CondStackTop = mach->CallStack[mach->CallStackTop].CondStackTop;
      mach->CondMask = mach->CondStack[mach->CondStackTop];

      mach->LoopStackTop = mach->CallStack[mach->CallStackTop].LoopStackTop;
      mach->LoopMask = mach->LoopStack[mach->LoopStackTop];

      mach->ContStackTop = mach->CallStack[mach->CallStackTop].ContStackTop;
      mach->ContMask = mach->ContStack[mach->ContStackTop];

      mach->SwitchStackTop = mach->CallStack[mach->CallStackTop].SwitchStackTop;
      mach->Switch = mach->SwitchStack[mach->SwitchStackTop];

      mach->BreakStackTop = mach->CallStack[mach->CallStackTop].BreakStackTop;
      mach->BreakType = mach->BreakStack[mach->BreakStackTop];

      assert(mach->FuncStackTop > 0);
      mach->FuncMask = mach->FuncStack[--mach->FuncStackTop];

      *pc = mach->CallStack[mach->CallStackTop].ReturnAddr;

      UPDATE_EXEC_MASK(mach);
      break;

   case TGSI_OPCODE_NOP:
      break;

   case TGSI_OPCODE_BREAKC:
      IFETCH(&r[0], 0, TGSI_CHAN_X);
      /* update CondMask */
      if (r[0].u[0] && (mach->ExecMask & 0x1)) {
         mach->LoopMask &= ~0x1;
      }
      if (r[0].u[1] && (mach->ExecMask & 0x2)) {
         mach->LoopMask &= ~0x2;
      }
      if (r[0].u[2] && (mach->ExecMask & 0x4)) {
         mach->LoopMask &= ~0x4;
      }
      if (r[0].u[3] && (mach->ExecMask & 0x8)) {
         mach->LoopMask &= ~0x8;
      }
      /* Todo: if mach->LoopMask == 0, jump to end of loop */
      UPDATE_EXEC_MASK(mach);
      break;

   case TGSI_OPCODE_F2I:
      exec_vector_unary(mach, inst, micro_f2i, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_FSEQ:
      exec_vector_binary(mach, inst, micro_fseq, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_FSGE:
      exec_vector_binary(mach, inst, micro_fsge, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_FSLT:
      exec_vector_binary(mach, inst, micro_fslt, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_FSNE:
      exec_vector_binary(mach, inst, micro_fsne, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_IDIV:
      exec_vector_binary(mach, inst, micro_idiv, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_IMAX:
      exec_vector_binary(mach, inst, micro_imax, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_IMIN:
      exec_vector_binary(mach, inst, micro_imin, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_INEG:
      exec_vector_unary(mach, inst, micro_ineg, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_ISGE:
      exec_vector_binary(mach, inst, micro_isge, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_ISHR:
      exec_vector_binary(mach, inst, micro_ishr, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_ISLT:
      exec_vector_binary(mach, inst, micro_islt, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_F2U:
      exec_vector_unary(mach, inst, micro_f2u, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_U2F:
      exec_vector_unary(mach, inst, micro_u2f, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_UADD:
      exec_vector_binary(mach, inst, micro_uadd, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_UDIV:
      exec_vector_binary(mach, inst, micro_udiv, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_UMAD:
      exec_vector_trinary(mach, inst, micro_umad, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_UMAX:
      exec_vector_binary(mach, inst, micro_umax, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_UMIN:
      exec_vector_binary(mach, inst, micro_umin, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_UMOD:
      exec_vector_binary(mach, inst, micro_umod, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_UMUL:
      exec_vector_binary(mach, inst, micro_umul, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_IMUL_HI:
      exec_vector_binary(mach, inst, micro_imul_hi, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_UMUL_HI:
      exec_vector_binary(mach, inst, micro_umul_hi, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_USEQ:
      exec_vector_binary(mach, inst, micro_useq, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_USGE:
      exec_vector_binary(mach, inst, micro_usge, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_USHR:
      exec_vector_binary(mach, inst, micro_ushr, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_USLT:
      exec_vector_binary(mach, inst, micro_uslt, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_USNE:
      exec_vector_binary(mach, inst, micro_usne, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_SWITCH:
      exec_switch(mach, inst);
      break;

   case TGSI_OPCODE_CASE:
      exec_case(mach, inst);
      break;

   case TGSI_OPCODE_DEFAULT:
      exec_default(mach);
      break;

   case TGSI_OPCODE_ENDSWITCH:
      exec_endswitch(mach);
      break;

   case TGSI_OPCODE_SAMPLE_I:
      exec_txf(mach, inst);
      break;

   case TGSI_OPCODE_SAMPLE_I_MS:
      assert(0);
      break;

   case TGSI_OPCODE_SAMPLE:
      exec_sample(mach, inst, TEX_MODIFIER_NONE, FALSE);
      break;

   case TGSI_OPCODE_SAMPLE_B:
      exec_sample(mach, inst, TEX_MODIFIER_LOD_BIAS, FALSE);
      break;

   case TGSI_OPCODE_SAMPLE_C:
      exec_sample(mach, inst, TEX_MODIFIER_NONE, TRUE);
      break;

   case TGSI_OPCODE_SAMPLE_C_LZ:
      exec_sample(mach, inst, TEX_MODIFIER_LEVEL_ZERO, TRUE);
      break;

   case TGSI_OPCODE_SAMPLE_D:
      exec_sample_d(mach, inst);
      break;

   case TGSI_OPCODE_SAMPLE_L:
      exec_sample(mach, inst, TEX_MODIFIER_EXPLICIT_LOD, FALSE);
      break;

   case TGSI_OPCODE_GATHER4:
      assert(0);
      break;

   case TGSI_OPCODE_SVIEWINFO:
      exec_txq(mach, inst);
      break;

   case TGSI_OPCODE_SAMPLE_POS:
      assert(0);
      break;

   case TGSI_OPCODE_SAMPLE_INFO:
      assert(0);
      break;

   case TGSI_OPCODE_UARL:
      exec_vector_unary(mach, inst, micro_uarl, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_UCMP:
      exec_vector_trinary(mach, inst, micro_ucmp, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_IABS:
      exec_vector_unary(mach, inst, micro_iabs, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_ISSG:
      exec_vector_unary(mach, inst, micro_isgn, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_TEX2:
      /* simple texture lookup */
      /* src[0] = texcoord */
      /* src[1] = compare */
      /* src[2] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_NONE, 2);
      break;
   case TGSI_OPCODE_TXB2:
      /* simple texture lookup */
      /* src[0] = texcoord */
      /* src[1] = bias */
      /* src[2] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_LOD_BIAS, 2);
      break;
   case TGSI_OPCODE_TXL2:
      /* simple texture lookup */
      /* src[0] = texcoord */
      /* src[1] = lod */
      /* src[2] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_EXPLICIT_LOD, 2);
      break;

   case TGSI_OPCODE_IBFE:
      exec_vector_trinary(mach, inst, micro_ibfe, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;
   case TGSI_OPCODE_UBFE:
      exec_vector_trinary(mach, inst, micro_ubfe, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_BFI:
      exec_vector_quaternary(mach, inst, micro_bfi, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_BREV:
      exec_vector_unary(mach, inst, micro_brev, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_POPC:
      exec_vector_unary(mach, inst, micro_popc, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_LSB:
      exec_vector_unary(mach, inst, micro_lsb, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_IMSB:
      exec_vector_unary(mach, inst, micro_imsb, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;
   case TGSI_OPCODE_UMSB:
      exec_vector_unary(mach, inst, micro_umsb, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_UINT);
      break;
   default:
      assert( 0 );
   }
}


/**
 * Run TGSI interpreter.
 * \return bitmask of "alive" quad components
 */
uint
tgsi_exec_machine_run( struct tgsi_exec_machine *mach )
{
   uint i;
   int pc = 0;
   uint default_mask = 0xf;

   mach->Temps[TEMP_KILMASK_I].xyzw[TEMP_KILMASK_C].u[0] = 0;
   mach->Temps[TEMP_OUTPUT_I].xyzw[TEMP_OUTPUT_C].u[0] = 0;

   if( mach->Processor == TGSI_PROCESSOR_GEOMETRY ) {
      mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0] = 0;
      mach->Primitives[0] = 0;
      /* GS runs on a single primitive for now */
      default_mask = 0x1;
   }

   mach->CondMask = default_mask;
   mach->LoopMask = default_mask;
   mach->ContMask = default_mask;
   mach->FuncMask = default_mask;
   mach->ExecMask = default_mask;

   mach->Switch.mask = default_mask;

   assert(mach->CondStackTop == 0);
   assert(mach->LoopStackTop == 0);
   assert(mach->ContStackTop == 0);
   assert(mach->SwitchStackTop == 0);
   assert(mach->BreakStackTop == 0);
   assert(mach->CallStackTop == 0);


   /* execute declarations (interpolants) */
   for (i = 0; i < mach->NumDeclarations; i++) {
      exec_declaration( mach, mach->Declarations+i );
   }

   {
#if DEBUG_EXECUTION
      struct tgsi_exec_vector temps[TGSI_EXEC_NUM_TEMPS + TGSI_EXEC_NUM_TEMP_EXTRAS];
      struct tgsi_exec_vector outputs[PIPE_MAX_ATTRIBS];
      uint inst = 1;

      memset(mach->Temps, 0, sizeof(temps));
      memset(mach->Outputs, 0, sizeof(outputs));
      memset(temps, 0, sizeof(temps));
      memset(outputs, 0, sizeof(outputs));
#endif

      /* execute instructions, until pc is set to -1 */
      while (pc != -1) {

#if DEBUG_EXECUTION
         uint i;

         tgsi_dump_instruction(&mach->Instructions[pc], inst++);
#endif

         assert(pc < (int) mach->NumInstructions);
         exec_instruction(mach, mach->Instructions + pc, &pc);

#if DEBUG_EXECUTION
         for (i = 0; i < TGSI_EXEC_NUM_TEMPS + TGSI_EXEC_NUM_TEMP_EXTRAS; i++) {
            if (memcmp(&temps[i], &mach->Temps[i], sizeof(temps[i]))) {
               uint j;

               memcpy(&temps[i], &mach->Temps[i], sizeof(temps[i]));
               debug_printf("TEMP[%2u] = ", i);
               for (j = 0; j < 4; j++) {
                  if (j > 0) {
                     debug_printf("           ");
                  }
                  debug_printf("(%6f %u, %6f %u, %6f %u, %6f %u)\n",
                               temps[i].xyzw[0].f[j], temps[i].xyzw[0].u[j],
                               temps[i].xyzw[1].f[j], temps[i].xyzw[1].u[j],
                               temps[i].xyzw[2].f[j], temps[i].xyzw[2].u[j],
                               temps[i].xyzw[3].f[j], temps[i].xyzw[3].u[j]);
               }
            }
         }
         for (i = 0; i < PIPE_MAX_ATTRIBS; i++) {
            if (memcmp(&outputs[i], &mach->Outputs[i], sizeof(outputs[i]))) {
               uint j;

               memcpy(&outputs[i], &mach->Outputs[i], sizeof(outputs[i]));
               debug_printf("OUT[%2u] =  ", i);
               for (j = 0; j < 4; j++) {
                  if (j > 0) {
                     debug_printf("           ");
                  }
                  debug_printf("(%6f %u, %6f %u, %6f %u, %6f %u)\n",
                               outputs[i].xyzw[0].f[j], outputs[i].xyzw[0].u[j],
                               outputs[i].xyzw[1].f[j], outputs[i].xyzw[1].u[j],
                               outputs[i].xyzw[2].f[j], outputs[i].xyzw[2].u[j],
                               outputs[i].xyzw[3].f[j], outputs[i].xyzw[3].u[j]);
               }
            }
         }
#endif
      }
   }

#if 0
   /* we scale from floats in [0,1] to Zbuffer ints in sp_quad_depth_test.c */
   if (mach->Processor == TGSI_PROCESSOR_FRAGMENT) {
      /*
       * Scale back depth component.
       */
      for (i = 0; i < 4; i++)
         mach->Outputs[0].xyzw[2].f[i] *= ctx->DrawBuffer->_DepthMaxF;
   }
#endif

   /* Strictly speaking, these assertions aren't really needed but they
    * can potentially catch some bugs in the control flow code.
    */
   assert(mach->CondStackTop == 0);
   assert(mach->LoopStackTop == 0);
   assert(mach->ContStackTop == 0);
   assert(mach->SwitchStackTop == 0);
   assert(mach->BreakStackTop == 0);
   assert(mach->CallStackTop == 0);

   return ~mach->Temps[TEMP_KILMASK_I].xyzw[TEMP_KILMASK_C].u[0];
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d692 1
a692 1
                            TGSI_MAX_PRIM_VERTICES * PIPE_MAX_SHADER_INPUTS,
a791 5
         if (mach->Processor == TGSI_PROCESSOR_GEOMETRY) {
            if (parse.FullToken.FullProperty.Property.PropertyName == TGSI_PROPERTY_GS_MAX_OUTPUT_VERTICES) {
               mach->MaxOutputVertices = parse.FullToken.FullProperty.u[0].Data;
            }
         }
d826 2
a827 2
   mach->Inputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_SHADER_INPUTS, 16);
   mach->Outputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_SHADER_OUTPUTS, 16);
a1623 3
      if (mach->Primitives[mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0]] >= mach->MaxOutputVertices)
         return;

d1944 1
a1944 2
   case TGSI_TEXTURE_SHADOWCUBE:
      /* only TEXTURE_CUBE_ARRAY and TEXTURE_SHADOWCUBE actually need W */
a1998 1
   case TGSI_TEXTURE_2D_ARRAY_MSAA:
a2006 1
   case TGSI_TEXTURE_2D_MSAA:
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d692 1
a692 1
                            TGSI_MAX_PRIM_VERTICES * PIPE_MAX_ATTRIBS,
d792 5
d831 2
a832 2
   mach->Inputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_ATTRIBS, 16);
   mach->Outputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_ATTRIBS, 16);
d1629 3
d1952 2
a1953 1
      /* only TEXTURE_CUBE_ARRAY actually needs W */
d2008 1
d2017 1
d3346 4
a3349 4
   dst->i[0] = src0->i[0] / src1->i[0];
   dst->i[1] = src0->i[1] / src1->i[1];
   dst->i[2] = src0->i[2] / src1->i[2];
   dst->i[3] = src0->i[3] / src1->i[3];
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007-2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d22 1
a22 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d917 4
a920 22
      if (recip > 0.0f) {
         if (recip > 1.884467e+019f) {
            dst->f[i] = 1.884467e+019f;
         }
         else if (recip < 5.42101e-020f) {
            dst->f[i] = 5.42101e-020f;
         }
         else {
            dst->f[i] = recip;
         }
      }
      else {
         if (recip < -1.884467e+019f) {
            dst->f[i] = -1.884467e+019f;
         }
         else if (recip > -5.42101e-020f) {
            dst->f[i] = -5.42101e-020f;
         }
         else {
            dst->f[i] = recip;
         }
      }
d1595 3
d2029 19
a2047 3
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
d2064 1
d2092 1
d2199 5
d2206 2
a2207 1
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
d2221 1
d2281 5
d2288 2
a2289 1
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
d2606 34
d3221 9
a3229 4
   dst->u[0] = src0->u[0] << src1->u[0];
   dst->u[1] = src0->u[1] << src1->u[1];
   dst->u[2] = src0->u[2] << src1->u[2];
   dst->u[3] = src0->u[3] << src1->u[3];
d3287 44
d3379 9
a3387 4
   dst->i[0] = src0->i[0] >> src1->i[0];
   dst->i[1] = src0->i[1] >> src1->i[1];
   dst->i[2] = src0->i[2] >> src1->i[2];
   dst->i[3] = src0->i[3] >> src1->i[3];
d3500 26
d3552 9
a3560 4
   dst->u[0] = src0->u[0] >> src1->u[0];
   dst->u[1] = src0->u[1] >> src1->u[1];
   dst->u[2] = src0->u[2] >> src1->u[2];
   dst->u[3] = src0->u[3] >> src1->u[3];
d3607 113
d4358 16
d4438 8
d4566 25
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d65 4
a68 1
#define FAST_MATH 1
d342 14
a355 4
   dst->f[0] = 1.0f / sqrtf(fabsf(src->f[0]));
   dst->f[1] = 1.0f / sqrtf(fabsf(src->f[1]));
   dst->f[2] = 1.0f / sqrtf(fabsf(src->f[2]));
   dst->f[3] = 1.0f / sqrtf(fabsf(src->f[3]));
d391 10
a482 5
#define CHAN_X  0
#define CHAN_Y  1
#define CHAN_Z  2
#define CHAN_W  3

d618 1
a618 1
         for (chan = 0; chan < NUM_CHANNELS; chan++) {
d644 1
a644 2
   uint numSamplers,
   struct tgsi_sampler **samplers)
a658 3
   if (numSamplers) {
      assert(samplers);
   }
d661 1
a661 1
   mach->Samplers = samplers;
d665 1
a665 3
      if (mach->Declarations) {
         FREE( mach->Declarations );
      }
d669 1
a669 3
      if (mach->Instructions) {
         FREE( mach->Instructions );
      }
d684 1
d688 6
a693 7
      struct tgsi_exec_vector *inputs =
         align_malloc(sizeof(struct tgsi_exec_vector) *
                      TGSI_MAX_PRIM_VERTICES * PIPE_MAX_ATTRIBS,
                      16);
      struct tgsi_exec_vector *outputs =
         align_malloc(sizeof(struct tgsi_exec_vector) *
                      TGSI_MAX_TOTAL_VERTICES, 16);
d697 4
a751 13
         if (parse.FullToken.FullDeclaration.Declaration.File ==
             TGSI_FILE_IMMEDIATE_ARRAY) {
            unsigned reg;
            struct tgsi_full_declaration *decl =
               &parse.FullToken.FullDeclaration;
            debug_assert(decl->Range.Last < TGSI_EXEC_NUM_IMMEDIATES);
            for (reg = decl->Range.First; reg <= decl->Range.Last; ++reg) {
               for( i = 0; i < 4; i++ ) {
                  int idx = reg * 4 + i;
                  mach->ImmArray[reg][i] = decl->ImmediateData.u[idx].Float;
               }
            }
         }
d800 1
a800 3
   if (mach->Declarations) {
      FREE( mach->Declarations );
   }
d804 1
a804 3
   if (mach->Instructions) {
      FREE( mach->Instructions );
   }
d867 2
a868 4
      if (mach->Instructions)
         FREE(mach->Instructions);
      if (mach->Declarations)
         FREE(mach->Declarations);
d1032 1
d1045 1
a1045 1
      for (i = 0; i < QUAD_SIZE; i++) {
d1057 1
a1057 1
            if (pos < 0 || pos >= mach->ConstsSize[constbuf]) {
d1074 1
a1074 1
      for (i = 0; i < QUAD_SIZE; i++) {
d1092 2
a1093 2
      for (i = 0; i < QUAD_SIZE; i++) {
         chan->f[i] = mach->SystemValue[index->i[i]][0];
d1098 1
a1098 1
      for (i = 0; i < QUAD_SIZE; i++) {
a1105 10
   case TGSI_FILE_TEMPORARY_ARRAY:
      for (i = 0; i < QUAD_SIZE; i++) {
         assert(index->i[i] < TGSI_EXEC_NUM_TEMPS);
         assert(index2D->i[i] < TGSI_EXEC_NUM_TEMP_ARRAYS);

         chan->u[i] =
            mach->TempArray[index2D->i[i]][index->i[i]].xyzw[swizzle].u[i];
      }
      break;

d1107 1
a1107 1
      for (i = 0; i < QUAD_SIZE; i++) {
a1114 8
   case TGSI_FILE_IMMEDIATE_ARRAY:
      for (i = 0; i < QUAD_SIZE; i++) {
         assert(index2D->i[i] == 0);

         chan->f[i] = mach->ImmArray[index->i[i]][swizzle];
      }
      break;

d1116 1
a1116 1
      for (i = 0; i < QUAD_SIZE; i++) {
d1125 1
a1125 1
      for (i = 0; i < QUAD_SIZE; i++) {
d1135 1
a1135 1
      for (i = 0; i < QUAD_SIZE; i++) {
d1145 1
a1145 1
      for (i = 0; i < QUAD_SIZE; i++) {
a1194 1
      assert(reg->Indirect.File == TGSI_FILE_ADDRESS);
d1196 1
a1196 1
      swizzle = tgsi_util_get_src_register_swizzle( &reg->Indirect, CHAN_X );
d1198 1
d1214 1
a1214 1
      for (i = 0; i < QUAD_SIZE; i++) {
d1256 1
a1256 1
         swizzle = tgsi_util_get_src_register_swizzle( &reg->DimIndirect, CHAN_X );
d1258 1
d1273 1
a1273 1
         for (i = 0; i < QUAD_SIZE; i++) {
d1293 1
d1360 1
a1360 1
      swizzle = tgsi_util_get_src_register_swizzle( &reg->Indirect, CHAN_X );
d1364 1
d1412 1
a1412 1
         swizzle = tgsi_util_get_src_register_swizzle( &reg->DimIndirect, CHAN_X );
d1414 1
d1429 1
a1429 1
         for (i = 0; i < QUAD_SIZE; i++) {
d1457 3
d1461 2
a1462 2
         fprintf(stderr, "STORING OUT[%d] mask(%d), = (", offset + index, execmask);
         for (i = 0; i < QUAD_SIZE; i++)
d1464 2
a1465 2
               fprintf(stderr, "%f, ", chan->f[i]);
         fprintf(stderr, ")\n");
a1475 10
   case TGSI_FILE_TEMPORARY_ARRAY:
      index = reg->Register.Index;
      assert( index < TGSI_EXEC_NUM_TEMPS );
      assert( index2D.i[0] < TGSI_EXEC_NUM_TEMP_ARRAYS );
      /* XXX we use index2D.i[0] here but somehow we might
       * end up with someone trying to store indirectly in
       * different buffers */
      dst = &mach->TempArray[index2D.i[0]][offset + index].xyzw[chan_index];
      break;

d1497 1
a1497 1
      case CHAN_X:
d1500 1
a1500 1
      case CHAN_Y:
d1503 1
a1503 1
      case CHAN_Z:
d1506 1
a1506 1
      case CHAN_W:
d1519 1
a1519 1
         for (i = 0; i < QUAD_SIZE; i++) {
d1525 1
a1525 1
         for (i = 0; i < QUAD_SIZE; i++) {
d1535 1
a1535 1
      for (i = 0; i < QUAD_SIZE; i++)
d1541 1
a1541 1
      for (i = 0; i < QUAD_SIZE; i++)
d1553 1
a1553 1
      for (i = 0; i < QUAD_SIZE; i++)
d1572 3
d1581 2
a1582 2
exec_kil(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
d1617 1
a1617 2
 * Execute NVIDIA-style KIL which is predicated by a condition code.
 * Kill fragment if the condition code is TRUE.
d1620 1
a1620 1
exec_kilp(struct tgsi_exec_machine *mach,
d1625 1
a1625 1
   /* "unconditional" kil */
d1635 1
a1635 1
   for (i = 0; i < QUAD_SIZE; ++i) {
d1650 1
a1650 1
   for (i = 0; i < QUAD_SIZE; ++i) {
d1678 2
d1684 3
d1694 1
a1694 1
   float rgba[NUM_CHANNELS][QUAD_SIZE];
d1696 3
a1698 1
   sampler->get_samples(sampler, s->f, t->f, p->f, c0->f, control, rgba);
d1713 54
d1769 7
d1779 1
a1779 1
         uint modifier)
d1781 4
a1784 4
   const uint unit = inst->Src[1].Register.Index;
   union tgsi_exec_channel r[4];
   const union tgsi_exec_channel *lod = &ZeroVec;
   enum tgsi_sampler_control control;
d1786 2
d1789 2
a1790 6
   if (modifier != TEX_MODIFIER_NONE) {
      FETCH(&r[3], 0, CHAN_W);
      if (modifier != TEX_MODIFIER_PROJECTED) {
         lod = &r[3];
      }
   }
d1792 2
a1793 5
   if (modifier == TEX_MODIFIER_EXPLICIT_LOD) {
      control = tgsi_sampler_lod_explicit;
   } else {
      control = tgsi_sampler_lod_bias;
   }
d1795 1
a1795 4
   switch (inst->Texture.Texture) {
   case TGSI_TEXTURE_1D:
   case TGSI_TEXTURE_SHADOW1D:
      FETCH(&r[0], 0, CHAN_X);
d1797 3
a1799 3
      if (modifier == TEX_MODIFIER_PROJECTED) {
         micro_div(&r[0], &r[0], &r[3]);
      }
d1801 3
a1803 5
      fetch_texel(mach->Samplers[unit],
                  &r[0], &ZeroVec, &ZeroVec, lod,  /* S, T, P, LOD */
                  control,
                  &r[0], &r[1], &r[2], &r[3]);     /* R, G, B, A */
      break;
d1805 8
a1812 12
   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_RECT:
   case TGSI_TEXTURE_SHADOW2D:
   case TGSI_TEXTURE_SHADOWRECT:
      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      if (modifier == TEX_MODIFIER_PROJECTED) {
         micro_div(&r[0], &r[0], &r[3]);
         micro_div(&r[1], &r[1], &r[3]);
         micro_div(&r[2], &r[2], &r[3]);
d1815 7
a1821 5
      fetch_texel(mach->Samplers[unit],
                  &r[0], &r[1], &r[2], lod,     /* S, T, P, LOD */
                  control,
                  &r[0], &r[1], &r[2], &r[3]);  /* outputs */
      break;
d1823 3
a1825 3
   case TGSI_TEXTURE_1D_ARRAY:
      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
d1827 9
a1835 3
      if (modifier == TEX_MODIFIER_PROJECTED) {
         micro_div(&r[0], &r[0], &r[3]);
      }
d1837 3
a1839 5
      fetch_texel(mach->Samplers[unit],
                  &r[0], &r[1], &r[2], lod,     /* S, T, P, LOD */
                  control,
                  &r[0], &r[1], &r[2], &r[3]);  /* outputs */
      break;
d1841 2
a1842 9
   case TGSI_TEXTURE_2D_ARRAY:
      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      if (modifier == TEX_MODIFIER_PROJECTED) {
         micro_div(&r[0], &r[0], &r[3]);
         micro_div(&r[1], &r[1], &r[3]);
      }
d1844 2
a1845 5
      fetch_texel(mach->Samplers[unit],
                  &r[0], &r[1], &r[2], lod,     /* S, T, P, LOD */
                  control,
                  &r[0], &r[1], &r[2], &r[3]);  /* outputs */
      break;
d1847 3
a1849 11
   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_CUBE:
      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      if (modifier == TEX_MODIFIER_PROJECTED) {
         micro_div(&r[0], &r[0], &r[3]);
         micro_div(&r[1], &r[1], &r[3]);
         micro_div(&r[2], &r[2], &r[3]);
      }
d1851 2
a1852 5
      fetch_texel(mach->Samplers[unit],
                  &r[0], &r[1], &r[2], lod,
                  control,
                  &r[0], &r[1], &r[2], &r[3]);
      break;
d1854 1
a1854 2
   default:
      assert(0);
d1857 17
a1873 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d1880 1
d1887 1
d1889 1
d1891 2
a1892 3
   /*
    * XXX: This is fake TXD -- the derivatives are not taken into account, yet.
    */
d1896 1
a1896 1
   case TGSI_TEXTURE_SHADOW1D:
d1898 1
a1898 1
      FETCH(&r[0], 0, CHAN_X);
d1900 19
a1918 3
      fetch_texel(mach->Samplers[unit],
                  &r[0], &ZeroVec, &ZeroVec, &ZeroVec,   /* S, T, P, BIAS */
                  tgsi_sampler_lod_bias,
d1924 13
d1939 14
a1952 8

      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      fetch_texel(mach->Samplers[unit],
                  &r[0], &r[1], &r[2], &ZeroVec,   /* inputs */
                  tgsi_sampler_lod_bias,
d1958 27
d1986 42
a2027 8
      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      fetch_texel(mach->Samplers[unit],
                  &r[0], &r[1], &r[2], &ZeroVec,
                  tgsi_sampler_lod_bias,
                  &r[0], &r[1], &r[2], &r[3]);
a2028 1

d2031 11
d2044 1
a2044 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2051 11
d2063 15
d2082 1
a2082 1
            uint modifier)
d2086 1
a2086 1
   union tgsi_exec_channel r[4];
d2088 1
a2088 1
   enum tgsi_sampler_control control;
d2090 6
d2098 13
a2110 7
      if (modifier == TEX_MODIFIER_LOD_BIAS)
         FETCH(&r[3], 3, CHAN_X);
      else /*TEX_MODIFIER_LOD*/
         FETCH(&r[3], 0, CHAN_W);

      if (modifier != TEX_MODIFIER_PROJECTED) {
         lod = &r[3];
d2114 1
a2114 5
   if (modifier == TEX_MODIFIER_EXPLICIT_LOD) {
      control = tgsi_sampler_lod_explicit;
   } else {
      control = tgsi_sampler_lod_bias;
   }
d2116 1
a2116 1
   switch (mach->Resources[resource_unit].Resource) {
d2118 12
a2129 5
   case TGSI_TEXTURE_SHADOW1D:
      FETCH(&r[0], 0, CHAN_X);

      if (modifier == TEX_MODIFIER_PROJECTED) {
         micro_div(&r[0], &r[0], &r[3]);
a2130 5

      fetch_texel(mach->Samplers[sampler_unit],
                  &r[0], &ZeroVec, &ZeroVec, lod,  /* S, T, P, LOD */
                  control,
                  &r[0], &r[1], &r[2], &r[3]);     /* R, G, B, A */
d2133 1
d2136 13
a2148 10
   case TGSI_TEXTURE_SHADOW2D:
   case TGSI_TEXTURE_SHADOWRECT:
      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      if (modifier == TEX_MODIFIER_PROJECTED) {
         micro_div(&r[0], &r[0], &r[3]);
         micro_div(&r[1], &r[1], &r[3]);
         micro_div(&r[2], &r[2], &r[3]);
a2149 5

      fetch_texel(mach->Samplers[sampler_unit],
                  &r[0], &r[1], &r[2], lod,     /* S, T, P, LOD */
                  control,
                  &r[0], &r[1], &r[2], &r[3]);  /* outputs */
d2152 1
d2155 14
a2168 8
      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      if (modifier == TEX_MODIFIER_PROJECTED) {
         micro_div(&r[0], &r[0], &r[3]);
         micro_div(&r[1], &r[1], &r[3]);
         micro_div(&r[2], &r[2], &r[3]);
d2170 1
d2172 17
a2188 4
      fetch_texel(mach->Samplers[sampler_unit],
                  &r[0], &r[1], &r[2], lod,
                  control,
                  &r[0], &r[1], &r[2], &r[3]);
d2191 1
d2196 1
a2196 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2210 1
d2212 6
a2217 3
   /*
    * XXX: This is fake SAMPLE_D -- the derivatives are not taken into account, yet.
    */
d2219 1
a2219 1
   switch (mach->Resources[resource_unit].Resource) {
d2221 3
a2223 1
   case TGSI_TEXTURE_SHADOW1D:
d2225 1
a2225 1
      FETCH(&r[0], 0, CHAN_X);
d2227 3
a2229 3
      fetch_texel(mach->Samplers[sampler_unit],
                  &r[0], &ZeroVec, &ZeroVec, &ZeroVec,   /* S, T, P, BIAS */
                  tgsi_sampler_lod_bias,
d2235 11
a2245 10
   case TGSI_TEXTURE_SHADOW2D:
   case TGSI_TEXTURE_SHADOWRECT:

      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      fetch_texel(mach->Samplers[sampler_unit],
                  &r[0], &r[1], &r[2], &ZeroVec,   /* inputs */
                  tgsi_sampler_lod_bias,
d2251 13
a2263 8

      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 0, CHAN_Y);
      FETCH(&r[2], 0, CHAN_Z);

      fetch_texel(mach->Samplers[sampler_unit],
                  &r[0], &r[1], &r[2], &ZeroVec,
                  tgsi_sampler_lod_bias,
d2271 1
a2271 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2291 1
a2291 1
   for( i = 0; i < QUAD_SIZE; i++ ) {
d2350 2
a2351 2
   if (decl->Declaration.File == TGSI_FILE_RESOURCE) {
      mach->Resources[decl->Range.First] = decl->Resource;
d2376 1
a2376 1
            for (i = 0; i < QUAD_SIZE; i++) {
d2383 1
a2383 1
            switch (decl->Declaration.Interpolate) {
d2396 4
d2405 1
a2405 1
            for (j = 0; j < NUM_CHANNELS; j++) {
d2413 17
d2449 1
a2449 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2473 1
a2473 1
   fetch_source(mach, &src, &inst->Src[0], CHAN_X, src_datatype);
d2475 1
a2475 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2492 1
a2492 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2500 1
a2500 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2522 2
a2523 2
   fetch_source(mach, &src[0], &inst->Src[0], CHAN_X, src_datatype);
   fetch_source(mach, &src[1], &inst->Src[1], CHAN_Y, src_datatype);
d2525 1
a2525 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2542 1
a2542 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2551 1
a2551 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2573 1
a2573 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2583 1
a2583 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2597 2
a2598 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2601 1
a2601 1
   for (chan = CHAN_Y; chan <= CHAN_Z; chan++) {
d2607 1
a2607 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2621 2
a2622 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2625 1
a2625 1
   for (chan = CHAN_Y; chan <= CHAN_W; chan++) {
d2631 1
a2631 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2645 2
a2646 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2649 2
a2650 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2653 1
a2653 1
   fetch_source(mach, &arg[1], &inst->Src[2], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2656 1
a2656 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2670 2
a2671 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2674 2
a2675 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2678 2
a2679 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2682 1
a2682 1
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2685 1
a2685 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2699 2
a2700 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2703 2
a2704 2
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2707 1
a2707 1
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
d2722 1
a2722 1
   fetch_source(mach, &arg[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2725 1
a2725 1
   for (chan = CHAN_Y; chan <= CHAN_W; chan++) {
d2735 1
a2735 1
   for (chan = CHAN_X; chan <= CHAN_W; chan++) {
d2752 1
a2752 1
      fetch_source(mach, &arg[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2755 1
a2755 1
      for (chan = CHAN_Y; chan <= CHAN_Z; chan++) {
d2765 1
a2765 1
      for (chan = CHAN_X; chan <= CHAN_Z; chan++) {
d2774 1
a2774 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2786 1
a2786 1
      fetch_source(mach, &arg, &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2790 1
a2790 1
         store_dest(mach, &result, &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2794 1
a2794 1
         store_dest(mach, &result, &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2798 1
a2798 1
      store_dest(mach, &ZeroVec, &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2801 1
a2801 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2812 2
a2813 2
   fetch_source(mach, &r[0], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[1], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2815 1
a2815 1
      fetch_source(mach, &r[2], &inst->Src[2], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2817 1
a2817 1
      fetch_source(mach, &r[3], &inst->Src[2], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2820 1
a2820 1
      fetch_source(mach, &r[3], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2824 1
a2824 1
      fetch_source(mach, &r[2], &inst->Src[2], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2826 1
a2826 1
      fetch_source(mach, &r[3], &inst->Src[2], CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2829 1
a2829 1
      fetch_source(mach, &r[3], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2833 1
a2833 1
      store_dest(mach, &d[0], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2836 1
a2836 1
      store_dest(mach, &d[1], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2839 1
a2839 1
      store_dest(mach, &d[0], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2842 1
a2842 1
      store_dest(mach, &d[1], &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2854 1
a2854 1
      fetch_source(mach, &r[2], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2856 1
a2856 1
      fetch_source(mach, &r[4], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2859 1
a2859 1
      fetch_source(mach, &r[6], &inst->Src[0], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2864 1
a2864 1
      fetch_source(mach, &r[3], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2866 1
a2866 1
      fetch_source(mach, &r[5], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2869 1
a2869 1
      fetch_source(mach, &r[7], &inst->Src[1], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2880 1
a2880 1
         store_dest(mach, &r[2], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2885 1
a2885 1
         store_dest(mach, &r[4], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2890 1
a2890 1
         store_dest(mach, &r[6], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2894 1
a2894 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2905 2
a2906 2
   fetch_source(mach, &r[0], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[1], &inst->Src[1], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2910 2
a2911 2
   fetch_source(mach, &r[3], &inst->Src[0], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[4], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2914 1
a2914 1
   micro_sub(&d[CHAN_X], &r[2], &r[5]);
d2916 1
a2916 1
   fetch_source(mach, &r[2], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2920 1
a2920 1
   fetch_source(mach, &r[5], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2923 1
a2923 1
   micro_sub(&d[CHAN_Y], &r[3], &r[1]);
d2927 1
a2927 1
   micro_sub(&d[CHAN_Z], &r[5], &r[0]);
d2930 1
a2930 1
      store_dest(mach, &d[CHAN_X], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2933 1
a2933 1
      store_dest(mach, &d[CHAN_Y], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2936 1
a2936 1
      store_dest(mach, &d[CHAN_Z], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2939 1
a2939 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2951 3
a2953 3
      fetch_source(mach, &r[0], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      fetch_source(mach, &r[1], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&d[CHAN_Y], &r[0], &r[1]);
d2956 1
a2956 1
      fetch_source(mach, &d[CHAN_Z], &inst->Src[0], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2959 1
a2959 1
      fetch_source(mach, &d[CHAN_W], &inst->Src[1], CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2963 1
a2963 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2966 1
a2966 1
      store_dest(mach, &d[CHAN_Y], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2969 1
a2969 1
      store_dest(mach, &d[CHAN_Z], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2972 1
a2972 1
      store_dest(mach, &d[CHAN_W], &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2982 1
a2982 1
   fetch_source(mach, &r[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2987 1
a2987 1
      store_dest(mach, &r[0], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2992 1
a2992 1
      store_dest(mach, &r[0], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2995 1
a2995 1
      store_dest(mach, &r[1], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2998 1
a2998 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
d3008 1
a3008 1
   fetch_source(mach, &r[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
d3012 1
a3012 1
      store_dest(mach, &r[2], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
d3016 1
a3016 1
      store_dest(mach, &r[2], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d3020 1
a3020 1
      store_dest(mach, &r[2], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d3023 1
a3023 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
a3033 3
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
d3035 1
a3035 6
      fetch_source(mach, &r[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
         micro_max(&d[CHAN_Y], &r[0], &ZeroVec);
         store_dest(mach, &d[CHAN_Y], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      }

d3037 1
a3037 1
         fetch_source(mach, &r[1], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d3040 1
a3040 1
         fetch_source(mach, &r[2], &inst->Src[0], CHAN_W, TGSI_EXEC_DATA_FLOAT);
d3044 2
a3045 2
         micro_lt(&d[CHAN_Z], &ZeroVec, &r[0], &r[1], &ZeroVec);
         store_dest(mach, &d[CHAN_Z], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d3047 7
d3055 1
d3057 1
a3057 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
d3086 1
a3086 1
   fetch_source(mach, &mach->Switch.selector, &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_UINT);
d3104 1
a3104 1
   fetch_source(mach, &src, &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_UINT);
d3126 1
d3211 11
d3333 4
a3336 4
   dst->u[0] = src0->u[0] / src1->u[0];
   dst->u[1] = src0->u[1] / src1->u[1];
   dst->u[2] = src0->u[2] / src1->u[2];
   dst->u[3] = src0->u[3] / src1->u[3];
d3378 4
a3381 4
   dst->u[0] = src0->u[0] % src1->u[0];
   dst->u[1] = src0->u[1] % src1->u[1];
   dst->u[2] = src0->u[2] % src1->u[2];
   dst->u[3] = src0->u[3] % src1->u[3];
d3451 22
d3563 4
d3627 2
a3628 2
   case TGSI_OPCODE_KILP:
      exec_kilp (mach, inst);
d3631 2
a3632 2
   case TGSI_OPCODE_KIL:
      exec_kil (mach, inst);
d3687 1
a3687 1
      exec_tex(mach, inst, TEX_MODIFIER_NONE);
d3694 1
a3694 1
      exec_tex(mach, inst, TEX_MODIFIER_LOD_BIAS);
d3710 1
a3710 1
      exec_tex(mach, inst, TEX_MODIFIER_EXPLICIT_LOD);
d3717 1
a3717 1
      exec_tex(mach, inst, TEX_MODIFIER_PROJECTED);
d3868 23
a3890 1
      FETCH( &r[0], 0, CHAN_X );
d3972 1
a3972 1
      assert (0);
d3984 1
a3984 1
      assert (0);
d3988 1
a3988 1
      assert (0);
d4088 1
a4088 1
      FETCH(&r[0], 0, CHAN_X);
d4147 1
a4147 1
      exec_vector_binary(mach, inst, micro_uadd, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
d4210 2
a4211 2
   case TGSI_OPCODE_LOAD:
      assert(0);
d4214 1
a4214 1
   case TGSI_OPCODE_LOAD_MS:
d4219 1
a4219 1
      exec_sample(mach, inst, TEX_MODIFIER_NONE);
d4223 1
a4223 1
      exec_sample(mach, inst, TEX_MODIFIER_LOD_BIAS);
d4227 1
a4227 1
      exec_sample(mach, inst, TEX_MODIFIER_NONE);
d4231 1
a4231 1
      exec_sample(mach, inst, TEX_MODIFIER_LOD_BIAS);
d4239 1
a4239 1
      exec_sample(mach, inst, TEX_MODIFIER_EXPLICIT_LOD);
d4246 2
a4247 2
   case TGSI_OPCODE_RESINFO:
      assert(0);
d4258 37
a4300 3
#define DEBUG_EXECUTION 0


d4310 1
d4312 2
a4313 5
   mach->CondMask = 0xf;
   mach->LoopMask = 0xf;
   mach->ContMask = 0xf;
   mach->FuncMask = 0xf;
   mach->ExecMask = 0xf;
d4315 14
a4328 1
   mach->Switch.mask = 0xf;
a4336 7
   mach->Temps[TEMP_KILMASK_I].xyzw[TEMP_KILMASK_C].u[0] = 0;
   mach->Temps[TEMP_OUTPUT_I].xyzw[TEMP_OUTPUT_C].u[0] = 0;

   if( mach->Processor == TGSI_PROCESSOR_GEOMETRY ) {
      mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0] = 0;
      mach->Primitives[0] = 0;
   }
d4349 4
a4352 2
      memcpy(temps, mach->Temps, sizeof(temps));
      memcpy(outputs, mach->Outputs, sizeof(outputs));
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d675 25
d829 5
d857 5
a861 1
   align_free(mach);
d873 6
a878 1
      FREE(mach->Declarations);
a879 2

   align_free(mach);
a1077 1
   case TGSI_FILE_SYSTEM_VALUE:
d1087 1
a1087 1
         assert(pos < Elements(mach->Inputs));
d1092 9
d1790 30
d1913 158
d2142 5
d2148 1
a2148 2
      if (decl->Declaration.File == TGSI_FILE_INPUT ||
          decl->Declaration.File == TGSI_FILE_SYSTEM_VALUE) {
d2161 1
d2203 4
d2209 1
d3919 48
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d432 18
a473 16
#define TEMP_0_I           TGSI_EXEC_TEMP_00000000_I
#define TEMP_0_C           TGSI_EXEC_TEMP_00000000_C
#define TEMP_7F_I          TGSI_EXEC_TEMP_7FFFFFFF_I
#define TEMP_7F_C          TGSI_EXEC_TEMP_7FFFFFFF_C
#define TEMP_80_I          TGSI_EXEC_TEMP_80000000_I
#define TEMP_80_C          TGSI_EXEC_TEMP_80000000_C
#define TEMP_FF_I          TGSI_EXEC_TEMP_FFFFFFFF_I
#define TEMP_FF_C          TGSI_EXEC_TEMP_FFFFFFFF_C
#define TEMP_1_I           TGSI_EXEC_TEMP_ONE_I
#define TEMP_1_C           TGSI_EXEC_TEMP_ONE_C
#define TEMP_2_I           TGSI_EXEC_TEMP_TWO_I
#define TEMP_2_C           TGSI_EXEC_TEMP_TWO_C
#define TEMP_128_I         TGSI_EXEC_TEMP_128_I
#define TEMP_128_C         TGSI_EXEC_TEMP_128_C
#define TEMP_M128_I        TGSI_EXEC_TEMP_MINUS_128_I
#define TEMP_M128_C        TGSI_EXEC_TEMP_MINUS_128_C
a479 22
#define TEMP_CC_I          TGSI_EXEC_TEMP_CC_I
#define TEMP_CC_C          TGSI_EXEC_TEMP_CC_C
#define TEMP_3_I           TGSI_EXEC_TEMP_THREE_I
#define TEMP_3_C           TGSI_EXEC_TEMP_THREE_C
#define TEMP_HALF_I        TGSI_EXEC_TEMP_HALF_I
#define TEMP_HALF_C        TGSI_EXEC_TEMP_HALF_C
#define TEMP_R0            TGSI_EXEC_TEMP_R0
#define TEMP_P0            TGSI_EXEC_TEMP_P0

#define IS_CHANNEL_ENABLED(INST, CHAN)\
   ((INST).Dst[0].Register.WriteMask & (1 << (CHAN)))

#define IS_CHANNEL_ENABLED2(INST, CHAN)\
   ((INST).Dst[1].Register.WriteMask & (1 << (CHAN)))

#define FOR_EACH_ENABLED_CHANNEL(INST, CHAN)\
   for (CHAN = 0; CHAN < NUM_CHANNELS; CHAN++)\
      if (IS_CHANNEL_ENABLED( INST, CHAN ))

#define FOR_EACH_ENABLED_CHANNEL2(INST, CHAN)\
   for (CHAN = 0; CHAN < NUM_CHANNELS; CHAN++)\
      if (IS_CHANNEL_ENABLED2( INST, CHAN ))
d494 8
d548 15
d594 4
a597 2
          (inst->Src[i].Register.Index ==
           inst->Dst[0].Register.Index)) {
d600 9
a608 5
         FOR_EACH_ENABLED_CHANNEL(*inst, chan) {
            /* check if we're reading a channel that's been written */
            uint swizzle = tgsi_util_get_full_src_register_swizzle(&inst->Src[i], chan);
            if (channelsWritten & (1 << swizzle)) {
               return TRUE;
a609 2

            channelsWritten |= (1 << chan);
a630 1
   struct tgsi_exec_labels *labels = &mach->Labels;
a634 1
   uint instno = 0;
d642 4
d649 17
a673 1
   labels->count = 0;
a690 1
      uint pointer = parse.Position;
d713 13
a746 5
         assert( labels->count < MAX_LABELS );

         labels->labels[labels->count][0] = instno;
         labels->labels[labels->count][1] = pointer;
         labels->count++;
d804 1
a804 1
   /* Setup constants. */
d806 10
a815 10
      mach->Temps[TEMP_0_I].xyzw[TEMP_0_C].u[i] = 0x00000000;
      mach->Temps[TEMP_7F_I].xyzw[TEMP_7F_C].u[i] = 0x7FFFFFFF;
      mach->Temps[TEMP_80_I].xyzw[TEMP_80_C].u[i] = 0x80000000;
      mach->Temps[TEMP_FF_I].xyzw[TEMP_FF_C].u[i] = 0xFFFFFFFF;
      mach->Temps[TEMP_1_I].xyzw[TEMP_1_C].f[i] = 1.0f;
      mach->Temps[TEMP_2_I].xyzw[TEMP_2_C].f[i] = 2.0f;
      mach->Temps[TEMP_128_I].xyzw[TEMP_128_C].f[i] = 128.0f;
      mach->Temps[TEMP_M128_I].xyzw[TEMP_M128_C].f[i] = -128.0f;
      mach->Temps[TEMP_3_I].xyzw[TEMP_3_C].f[i] = 3.0f;
      mach->Temps[TEMP_HALF_I].xyzw[TEMP_HALF_C].f[i] = 0.5f;
d836 3
a838 1
      FREE(mach->Instructions);
d877 2
a878 2
micro_float_clamp(union tgsi_exec_channel *dst,
                  const union tgsi_exec_channel *src)
d883 4
a886 2
      if (src->f[i] > 0.0f) {
         if (src->f[i] > 1.884467e+019f)
d888 2
a889 1
         else if (src->f[i] < 5.42101e-020f)
d891 4
a894 2
         else
            dst->f[i] = src->f[i];
d897 1
a897 1
         if (src->f[i] < -1.884467e+019f)
d899 2
a900 1
         else if (src->f[i] > -5.42101e-020f)
d902 4
a905 2
         else
            dst->f[i] = src->f[i];
a956 54
#if 0
static void
micro_imul64(
   union tgsi_exec_channel *dst0,
   union tgsi_exec_channel *dst1,
   const union tgsi_exec_channel *src0,
   const union tgsi_exec_channel *src1 )
{
   dst1->i[0] = src0->i[0] * src1->i[0];
   dst1->i[1] = src0->i[1] * src1->i[1];
   dst1->i[2] = src0->i[2] * src1->i[2];
   dst1->i[3] = src0->i[3] * src1->i[3];
   dst0->i[0] = 0;
   dst0->i[1] = 0;
   dst0->i[2] = 0;
   dst0->i[3] = 0;
}
#endif

#if 0
static void
micro_umul64(
   union tgsi_exec_channel *dst0,
   union tgsi_exec_channel *dst1,
   const union tgsi_exec_channel *src0,
   const union tgsi_exec_channel *src1 )
{
   dst1->u[0] = src0->u[0] * src1->u[0];
   dst1->u[1] = src0->u[1] * src1->u[1];
   dst1->u[2] = src0->u[2] * src1->u[2];
   dst1->u[3] = src0->u[3] * src1->u[3];
   dst0->u[0] = 0;
   dst0->u[1] = 0;
   dst0->u[2] = 0;
   dst0->u[3] = 0;
}
#endif


#if 0
static void
micro_movc(
   union tgsi_exec_channel *dst,
   const union tgsi_exec_channel *src0,
   const union tgsi_exec_channel *src1,
   const union tgsi_exec_channel *src2 )
{
   dst->u[0] = src0->u[0] ? src1->u[0] : src2->u[0];
   dst->u[1] = src0->u[1] ? src1->u[1] : src2->u[1];
   dst->u[2] = src0->u[2] ? src1->u[2] : src2->u[2];
   dst->u[3] = src0->u[3] ? src1->u[3] : src2->u[3];
}
#endif

d1008 2
d1019 17
a1035 3
            const uint *p = (const uint *)mach->Consts[index2D->i[i]];

            chan->u[i] = p[index->i[i] * 4 + swizzle];
d1043 10
a1052 2
         /* XXX: 2D indexing */
         chan->u[i] = mach->Inputs[index2D->i[i] * TGSI_EXEC_MAX_INPUT_ATTRIBS + index->i[i]].xyzw[swizzle].u[i];
d1065 10
d1084 8
d1172 1
a1172 1

d1303 1
d1349 71
d1446 10
a1460 7
   case TGSI_FILE_LOOP:
      assert(reg->Register.Index == 0);
      assert(mach->LoopCounterStackTop > 0);
      assert(chan_index == CHAN_X);
      dst = &mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[chan_index];
      break;

a1551 3
#define STORE(VAL,INDEX,CHAN)\
   store_dest(mach, VAL, &inst->Dst[INDEX], inst, CHAN, TGSI_EXEC_DATA_FLOAT)

d1638 13
d1695 1
a1695 1
   uint chan_index;
d1767 4
a1770 2
   FOR_EACH_ENABLED_CHANNEL(*inst, chan_index) {
      STORE(&r[chan_index], 0, chan_index);
d1780 1
a1780 1
   uint chan_index;
d1830 4
a1833 2
   FOR_EACH_ENABLED_CHANNEL(*inst, chan_index) {
      STORE(&r[chan_index], 0, chan_index);
d1918 6
d1967 20
d2040 21
d2307 283
a2971 1
   uint chan_index;
a2972 1
   union tgsi_exec_channel d[8];
d2986 1
a2986 30
      if (IS_CHANNEL_ENABLED( *inst, CHAN_Y ) || IS_CHANNEL_ENABLED( *inst, CHAN_Z )) {
         FETCH( &r[0], 0, CHAN_X );
         if (IS_CHANNEL_ENABLED( *inst, CHAN_Y )) {
            micro_max(&d[CHAN_Y], &r[0], &mach->Temps[TEMP_0_I].xyzw[TEMP_0_C]);
         }

         if (IS_CHANNEL_ENABLED( *inst, CHAN_Z )) {
            FETCH( &r[1], 0, CHAN_Y );
            micro_max( &r[1], &r[1], &mach->Temps[TEMP_0_I].xyzw[TEMP_0_C] );

            FETCH( &r[2], 0, CHAN_W );
            micro_min( &r[2], &r[2], &mach->Temps[TEMP_128_I].xyzw[TEMP_128_C] );
            micro_max( &r[2], &r[2], &mach->Temps[TEMP_M128_I].xyzw[TEMP_M128_C] );
            micro_pow( &r[1], &r[1], &r[2] );
            micro_lt(&d[CHAN_Z], &mach->Temps[TEMP_0_I].xyzw[TEMP_0_C], &r[0], &r[1], &mach->Temps[TEMP_0_I].xyzw[TEMP_0_C]);
         }

         if (IS_CHANNEL_ENABLED(*inst, CHAN_Y)) {
            STORE(&d[CHAN_Y], 0, CHAN_Y);
         }
         if (IS_CHANNEL_ENABLED(*inst, CHAN_Z)) {
            STORE(&d[CHAN_Z], 0, CHAN_Z);
         }
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_X )) {
         STORE( &mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, CHAN_X );
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_W )) {
         STORE( &mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, CHAN_W );
      }
d2998 1
a2998 17
      FETCH( &r[0], 0, CHAN_X );
      micro_flr( &r[1], &r[0] );  /* r1 = floor(r0) */
      if (IS_CHANNEL_ENABLED( *inst, CHAN_X )) {
         micro_exp2( &r[2], &r[1] );       /* r2 = 2 ^ r1 */
         STORE( &r[2], 0, CHAN_X );        /* store r2 */
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_Y )) {
         micro_sub( &r[2], &r[0], &r[1] ); /* r2 = r0 - r1 */
         STORE( &r[2], 0, CHAN_Y );        /* store r2 */
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_Z )) {
         micro_exp2( &r[2], &r[0] );       /* r2 = 2 ^ r0 */
         STORE( &r[2], 0, CHAN_Z );        /* store r2 */
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_W )) {
         STORE( &mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, CHAN_W );
      }
d3002 1
a3002 18
      FETCH( &r[0], 0, CHAN_X );
      micro_abs( &r[2], &r[0] );  /* r2 = abs(r0) */
      micro_lg2( &r[1], &r[2] );  /* r1 = lg2(r2) */
      micro_flr( &r[0], &r[1] );  /* r0 = floor(r1) */
      if (IS_CHANNEL_ENABLED( *inst, CHAN_X )) {
         STORE( &r[0], 0, CHAN_X );
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_Y )) {
         micro_exp2( &r[0], &r[0] );       /* r0 = 2 ^ r0 */
         micro_div( &r[0], &r[2], &r[0] ); /* r0 = r2 / r0 */
         STORE( &r[0], 0, CHAN_Y );
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_Z )) {
         STORE( &r[1], 0, CHAN_Z );
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_W )) {
         STORE( &mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, CHAN_W );
      }
d3022 1
a3022 24
      if (IS_CHANNEL_ENABLED( *inst, CHAN_Y )) {
         FETCH( &r[0], 0, CHAN_Y );
         FETCH( &r[1], 1, CHAN_Y);
         micro_mul(&d[CHAN_Y], &r[0], &r[1]);
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_Z )) {
         FETCH(&d[CHAN_Z], 0, CHAN_Z);
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_W )) {
         FETCH(&d[CHAN_W], 1, CHAN_W);
      }

      if (IS_CHANNEL_ENABLED(*inst, CHAN_X)) {
         STORE(&mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, CHAN_X);
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_Y)) {
         STORE(&d[CHAN_Y], 0, CHAN_Y);
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_Z)) {
         STORE(&d[CHAN_Z], 0, CHAN_Z);
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_W)) {
         STORE(&d[CHAN_W], 0, CHAN_W);
      }
d3086 1
a3086 8
      FETCH(&r[0], 0, CHAN_X);
      FETCH(&r[1], 1, CHAN_X);

      micro_pow( &r[0], &r[0], &r[1] );

      FOR_EACH_ENABLED_CHANNEL( *inst, chan_index ) {
         STORE( &r[0], 0, chan_index );
      }
d3090 1
a3090 36
      FETCH(&r[0], 0, CHAN_Y);
      FETCH(&r[1], 1, CHAN_Z);

      micro_mul( &r[2], &r[0], &r[1] );

      FETCH(&r[3], 0, CHAN_Z);
      FETCH(&r[4], 1, CHAN_Y);

      micro_mul( &r[5], &r[3], &r[4] );
      micro_sub(&d[CHAN_X], &r[2], &r[5]);

      FETCH(&r[2], 1, CHAN_X);

      micro_mul( &r[3], &r[3], &r[2] );

      FETCH(&r[5], 0, CHAN_X);

      micro_mul( &r[1], &r[1], &r[5] );
      micro_sub(&d[CHAN_Y], &r[3], &r[1]);

      micro_mul( &r[5], &r[5], &r[4] );
      micro_mul( &r[0], &r[0], &r[2] );
      micro_sub(&d[CHAN_Z], &r[5], &r[0]);

      if (IS_CHANNEL_ENABLED(*inst, CHAN_X)) {
         STORE(&d[CHAN_X], 0, CHAN_X);
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_Y)) {
         STORE(&d[CHAN_Y], 0, CHAN_Y);
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_Z)) {
         STORE(&d[CHAN_Z], 0, CHAN_Z);
      }
      if (IS_CHANNEL_ENABLED( *inst, CHAN_W )) {
         STORE( &mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, CHAN_W );
      }
d3098 1
a3098 6
      FETCH(&r[0], 0, CHAN_X);
      micro_div(&r[0], &mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], &r[0]);
      micro_float_clamp(&r[0], &r[0]);
      FOR_EACH_ENABLED_CHANNEL(*inst, chan_index) {
         STORE(&r[0], 0, chan_index);
      }
d3142 1
a3142 46
      if (IS_CHANNEL_ENABLED(*inst, CHAN_X) ||
          IS_CHANNEL_ENABLED(*inst, CHAN_Y) ||
          IS_CHANNEL_ENABLED(*inst, CHAN_Z)) {
         /* r0 = dp3(src0, src0) */
         FETCH(&r[2], 0, CHAN_X);
         micro_mul(&r[0], &r[2], &r[2]);
         FETCH(&r[4], 0, CHAN_Y);
         micro_mul(&r[8], &r[4], &r[4]);
         micro_add(&r[0], &r[0], &r[8]);
         FETCH(&r[6], 0, CHAN_Z);
         micro_mul(&r[8], &r[6], &r[6]);
         micro_add(&r[0], &r[0], &r[8]);

         /* r1 = dp3(src0, src1) */
         FETCH(&r[3], 1, CHAN_X);
         micro_mul(&r[1], &r[2], &r[3]);
         FETCH(&r[5], 1, CHAN_Y);
         micro_mul(&r[8], &r[4], &r[5]);
         micro_add(&r[1], &r[1], &r[8]);
         FETCH(&r[7], 1, CHAN_Z);
         micro_mul(&r[8], &r[6], &r[7]);
         micro_add(&r[1], &r[1], &r[8]);

         /* r1 = 2 * r1 / r0 */
         micro_add(&r[1], &r[1], &r[1]);
         micro_div(&r[1], &r[1], &r[0]);

         if (IS_CHANNEL_ENABLED(*inst, CHAN_X)) {
            micro_mul(&r[2], &r[2], &r[1]);
            micro_sub(&r[2], &r[2], &r[3]);
            STORE(&r[2], 0, CHAN_X);
         }
         if (IS_CHANNEL_ENABLED(*inst, CHAN_Y)) {
            micro_mul(&r[4], &r[4], &r[1]);
            micro_sub(&r[4], &r[4], &r[5]);
            STORE(&r[4], 0, CHAN_Y);
         }
         if (IS_CHANNEL_ENABLED(*inst, CHAN_Z)) {
            micro_mul(&r[6], &r[6], &r[1]);
            micro_sub(&r[6], &r[6], &r[7]);
            STORE(&r[6], 0, CHAN_Z);
         }
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_W)) {
         STORE(&mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, CHAN_W);
      }
d3150 1
a3150 3
      FOR_EACH_ENABLED_CHANNEL(*inst, chan_index) {
         STORE(&mach->Temps[TEMP_0_I].xyzw[TEMP_0_C], 0, chan_index);
      }
d3170 1
a3170 3
      FOR_EACH_ENABLED_CHANNEL(*inst, chan_index) {
         STORE(&mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, chan_index);
      }
d3227 1
a3227 36
      FETCH(&r[0], 1, CHAN_X);
      FETCH(&r[1], 1, CHAN_Y);
      if (IS_CHANNEL_ENABLED(*inst, CHAN_X) ||
          IS_CHANNEL_ENABLED(*inst, CHAN_Z)) {
         FETCH(&r[2], 2, CHAN_X);
         micro_mul(&r[2], &r[2], &r[0]);
         FETCH(&r[3], 2, CHAN_Y);
         micro_mul(&r[3], &r[3], &r[1]);
         micro_add(&r[2], &r[2], &r[3]);
         FETCH(&r[3], 0, CHAN_X);
         micro_add(&d[CHAN_X], &r[2], &r[3]);
         
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_Y) ||
          IS_CHANNEL_ENABLED(*inst, CHAN_W)) {
         FETCH(&r[2], 2, CHAN_Z);
         micro_mul(&r[2], &r[2], &r[0]);
         FETCH(&r[3], 2, CHAN_W);
         micro_mul(&r[3], &r[3], &r[1]);
         micro_add(&r[2], &r[2], &r[3]);
         FETCH(&r[3], 0, CHAN_Y);
         micro_add(&d[CHAN_Y], &r[2], &r[3]);
         
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_X)) {
         STORE(&d[CHAN_X], 0, CHAN_X);
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_Y)) {
         STORE(&d[CHAN_Y], 0, CHAN_Y);
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_Z)) {
         STORE(&d[CHAN_X], 0, CHAN_Z);
      }
      if (IS_CHANNEL_ENABLED(*inst, CHAN_W)) {
         STORE(&d[CHAN_Y], 0, CHAN_W);
      }
d3293 2
d3335 1
a3335 17
      if( IS_CHANNEL_ENABLED( *inst, CHAN_X ) || IS_CHANNEL_ENABLED( *inst, CHAN_Y ) ) {
         FETCH( &r[0], 0, CHAN_X );
         if (IS_CHANNEL_ENABLED(*inst, CHAN_X)) {
            micro_cos(&r[1], &r[0]);
            STORE(&r[1], 0, CHAN_X);
         }
         if (IS_CHANNEL_ENABLED(*inst, CHAN_Y)) {
            micro_sin(&r[1], &r[0]);
            STORE(&r[1], 0, CHAN_Y);
         }
      }
      if( IS_CHANNEL_ENABLED( *inst, CHAN_Z ) ) {
         STORE( &mach->Temps[TEMP_0_I].xyzw[TEMP_0_C], 0, CHAN_Z );
      }
      if( IS_CHANNEL_ENABLED( *inst, CHAN_W ) ) {
         STORE( &mach->Temps[TEMP_1_I].xyzw[TEMP_1_C], 0, CHAN_W );
      }
d3347 1
a3347 1
      assert( 0 );
d3396 3
a3402 8
   case TGSI_OPCODE_REP:
      assert (0);
      break;

   case TGSI_OPCODE_ENDREP:
       assert (0);
       break;

a3466 23
   case TGSI_OPCODE_BGNFOR:
      assert(mach->LoopCounterStackTop < TGSI_EXEC_MAX_LOOP_NESTING);
      for (chan_index = 0; chan_index < 3; chan_index++) {
         FETCH( &mach->LoopCounterStack[mach->LoopCounterStackTop].xyzw[chan_index], 0, chan_index );
      }
      ++mach->LoopCounterStackTop;
      STORE(&mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_X], 0, CHAN_X);
      /* update LoopMask */
      if (mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y].f[0] <= 0.0f) {
         mach->LoopMask &= ~0x1;
      }
      if (mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y].f[1] <= 0.0f) {
         mach->LoopMask &= ~0x2;
      }
      if (mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y].f[2] <= 0.0f) {
         mach->LoopMask &= ~0x4;
      }
      if (mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y].f[3] <= 0.0f) {
         mach->LoopMask &= ~0x8;
      }
      /* TODO: if mach->LoopMask == 0, jump to end of loop */
      UPDATE_EXEC_MASK(mach);
      /* fall-through (for now) */
a3480 50
   case TGSI_OPCODE_ENDFOR:
      assert(mach->LoopCounterStackTop > 0);
      micro_sub(&mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y], 
                &mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y],
                &mach->Temps[TEMP_1_I].xyzw[TEMP_1_C]);
      /* update LoopMask */
      if (mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y].f[0] <= 0.0f) {
         mach->LoopMask &= ~0x1;
      }
      if (mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y].f[1] <= 0.0f) {
         mach->LoopMask &= ~0x2;
      }
      if (mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y].f[2] <= 0.0f) {
         mach->LoopMask &= ~0x4;
      }
      if (mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Y].f[3] <= 0.0f) {
         mach->LoopMask &= ~0x8;
      }
      micro_add(&mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_X], 
                &mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_X], 
                &mach->LoopCounterStack[mach->LoopCounterStackTop - 1].xyzw[CHAN_Z]);
      assert(mach->LoopLabelStackTop > 0);
      inst = mach->Instructions + mach->LoopLabelStack[mach->LoopLabelStackTop - 1];
      STORE(&mach->LoopCounterStack[mach->LoopCounterStackTop].xyzw[CHAN_X], 0, CHAN_X);
      /* Restore ContMask, but don't pop */
      assert(mach->ContStackTop > 0);
      mach->ContMask = mach->ContStack[mach->ContStackTop - 1];
      UPDATE_EXEC_MASK(mach);
      if (mach->ExecMask) {
         /* repeat loop: jump to instruction just past BGNLOOP */
         assert(mach->LoopLabelStackTop > 0);
         *pc = mach->LoopLabelStack[mach->LoopLabelStackTop - 1] + 1;
      }
      else {
         /* exit loop: pop LoopMask */
         assert(mach->LoopStackTop > 0);
         mach->LoopMask = mach->LoopStack[--mach->LoopStackTop];
         /* pop ContMask */
         assert(mach->ContStackTop > 0);
         mach->ContMask = mach->ContStack[--mach->ContStackTop];
         assert(mach->LoopLabelStackTop > 0);
         --mach->LoopLabelStackTop;
         assert(mach->LoopCounterStackTop > 0);
         --mach->LoopCounterStackTop;

         mach->BreakType = mach->BreakStack[--mach->BreakStackTop];
      }
      UPDATE_EXEC_MASK(mach);
      break;
      
a3719 8
   for (i = 0; i < QUAD_SIZE; i++) {
      mach->Temps[TEMP_CC_I].xyzw[TEMP_CC_C].u[i] =
         (TGSI_EXEC_CC_EQ << TGSI_EXEC_CC_X_SHIFT) |
         (TGSI_EXEC_CC_EQ << TGSI_EXEC_CC_Y_SHIFT) |
         (TGSI_EXEC_CC_EQ << TGSI_EXEC_CC_Z_SHIFT) |
         (TGSI_EXEC_CC_EQ << TGSI_EXEC_CC_W_SHIFT);
   }

d3799 3
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a431 18
micro_sfl(union tgsi_exec_channel *dst)
{
   dst->f[0] = 0.0f;
   dst->f[1] = 0.0f;
   dst->f[2] = 0.0f;
   dst->f[3] = 0.0f;
}

static void
micro_str(union tgsi_exec_channel *dst)
{
   dst->f[0] = 1.0f;
   dst->f[1] = 1.0f;
   dst->f[2] = 1.0f;
   dst->f[3] = 1.0f;
}

static void
d456 16
d478 22
a513 8
static const union tgsi_exec_channel P128Vec = {
   {128.0f, 128.0f, 128.0f, 128.0f}
};

static const union tgsi_exec_channel M128Vec = {
   {-128.0f, -128.0f, -128.0f, -128.0f}
};

a559 15
void
tgsi_exec_set_constant_buffers(struct tgsi_exec_machine *mach,
                               unsigned num_bufs,
                               const void **bufs,
                               const unsigned *buf_sizes)
{
   unsigned i;

   for (i = 0; i < num_bufs; i++) {
      mach->Consts[i] = bufs[i];
      mach->ConstsSize[i] = buf_sizes[i];
   }
}


d591 2
a592 4
          ((inst->Src[i].Register.Index ==
            inst->Dst[0].Register.Index) ||
           inst->Src[i].Register.Indirect ||
           inst->Dst[0].Register.Indirect)) {
d595 6
a600 7
         for (chan = 0; chan < NUM_CHANNELS; chan++) {
            if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
               /* check if we're reading a channel that's been written */
               uint swizzle = tgsi_util_get_full_src_register_swizzle(&inst->Src[i], chan);
               if (channelsWritten & (1 << swizzle)) {
                  return TRUE;
               }
d602 1
a602 2
               channelsWritten |= (1 << chan);
            }
d624 1
d629 1
a636 4
   if (numSamplers) {
      assert(samplers);
   }

a639 17
   if (!tokens) {
      /* unbind and free all */
      if (mach->Declarations) {
         FREE( mach->Declarations );
      }
      mach->Declarations = NULL;
      mach->NumDeclarations = 0;

      if (mach->Instructions) {
         FREE( mach->Instructions );
      }
      mach->Instructions = NULL;
      mach->NumInstructions = 0;

      return;
   }

d648 1
d666 1
a688 13
         if (parse.FullToken.FullDeclaration.Declaration.File ==
             TGSI_FILE_IMMEDIATE_ARRAY) {
            unsigned reg;
            struct tgsi_full_declaration *decl =
               &parse.FullToken.FullDeclaration;
            debug_assert(decl->Range.Last < TGSI_EXEC_NUM_IMMEDIATES);
            for (reg = decl->Range.First; reg <= decl->Range.Last; ++reg) {
               for( i = 0; i < 4; i++ ) {
                  int idx = reg * 4 + i;
                  mach->ImmArray[reg][i] = decl->ImmediateData.u[idx].Float;
               }
            }
         }
d710 5
d772 1
a772 1
   /* Setup constants needed by the SSE2 executor. */
d774 10
a783 10
      mach->Temps[TGSI_EXEC_TEMP_00000000_I].xyzw[TGSI_EXEC_TEMP_00000000_C].u[i] = 0x00000000;
      mach->Temps[TGSI_EXEC_TEMP_7FFFFFFF_I].xyzw[TGSI_EXEC_TEMP_7FFFFFFF_C].u[i] = 0x7FFFFFFF;
      mach->Temps[TGSI_EXEC_TEMP_80000000_I].xyzw[TGSI_EXEC_TEMP_80000000_C].u[i] = 0x80000000;
      mach->Temps[TGSI_EXEC_TEMP_FFFFFFFF_I].xyzw[TGSI_EXEC_TEMP_FFFFFFFF_C].u[i] = 0xFFFFFFFF;    /* not used */
      mach->Temps[TGSI_EXEC_TEMP_ONE_I].xyzw[TGSI_EXEC_TEMP_ONE_C].f[i] = 1.0f;
      mach->Temps[TGSI_EXEC_TEMP_TWO_I].xyzw[TGSI_EXEC_TEMP_TWO_C].f[i] = 2.0f;    /* not used */
      mach->Temps[TGSI_EXEC_TEMP_128_I].xyzw[TGSI_EXEC_TEMP_128_C].f[i] = 128.0f;
      mach->Temps[TGSI_EXEC_TEMP_MINUS_128_I].xyzw[TGSI_EXEC_TEMP_MINUS_128_C].f[i] = -128.0f;
      mach->Temps[TGSI_EXEC_TEMP_THREE_I].xyzw[TGSI_EXEC_TEMP_THREE_C].f[i] = 3.0f;
      mach->Temps[TGSI_EXEC_TEMP_HALF_I].xyzw[TGSI_EXEC_TEMP_HALF_C].f[i] = 0.5f;
d804 1
a804 3
      if (mach->Instructions)
         FREE(mach->Instructions);
      if (mach->Declarations)
d843 2
a844 2
micro_rcc(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
d849 2
a850 4
      float recip = 1.0f / src->f[i];

      if (recip > 0.0f) {
         if (recip > 1.884467e+019f) {
d852 1
a852 2
         }
         else if (recip < 5.42101e-020f) {
d854 2
a855 4
         }
         else {
            dst->f[i] = recip;
         }
d858 1
a858 1
         if (recip < -1.884467e+019f) {
d860 1
a860 2
         }
         else if (recip > -5.42101e-020f) {
d862 2
a863 4
         }
         else {
            dst->f[i] = recip;
         }
d915 54
a1019 2
   assert(swizzle < 4);

d1029 3
a1031 17
            /* NOTE: copying the const value as a uint instead of float */
            const uint constbuf = index2D->i[i];
            const uint *buf = (const uint *)mach->Consts[constbuf];
            const int pos = index->i[i] * 4 + swizzle;
            /* const buffer bounds check */
            if (pos < 0 || pos >= mach->ConstsSize[constbuf]) {
               if (0) {
                  /* Debug: print warning */
                  static int count = 0;
                  if (count++ < 100)
                     debug_printf("TGSI Exec: const buffer index %d"
                                  " out of bounds\n", pos);
               }
               chan->u[i] = 0;
            }
            else
               chan->u[i] = buf[pos];
d1039 2
a1040 10
         /*
         if (TGSI_PROCESSOR_GEOMETRY == mach->Processor) {
            debug_printf("Fetching Input[%d] (2d=%d, 1d=%d)\n",
                         index2D->i[i] * TGSI_EXEC_MAX_INPUT_ATTRIBS + index->i[i],
                         index2D->i[i], index->i[i]);
                         }*/
         int pos = index2D->i[i] * TGSI_EXEC_MAX_INPUT_ATTRIBS + index->i[i];
         assert(pos >= 0);
         assert(pos < Elements(mach->Inputs));
         chan->u[i] = mach->Inputs[pos].xyzw[swizzle].u[i];
a1052 10
   case TGSI_FILE_TEMPORARY_ARRAY:
      for (i = 0; i < QUAD_SIZE; i++) {
         assert(index->i[i] < TGSI_EXEC_NUM_TEMPS);
         assert(index2D->i[i] < TGSI_EXEC_NUM_TEMP_ARRAYS);

         chan->u[i] =
            mach->TempArray[index2D->i[i]][index->i[i]].xyzw[swizzle].u[i];
      }
      break;

a1061 8
   case TGSI_FILE_IMMEDIATE_ARRAY:
      for (i = 0; i < QUAD_SIZE; i++) {
         assert(index2D->i[i] == 0);

         chan->f[i] = mach->ImmArray[index->i[i]][swizzle];
      }
      break;

d1142 1
a1142 1
      assert(reg->Indirect.File == TGSI_FILE_ADDRESS);
a1272 1
   union tgsi_exec_channel index2D;
a1317 71
   /* There is an extra source register that is a second
    * subscript to a register file. Effectively it means that
    * the register file is actually a 2D array of registers.
    *
    *    file[3][1],
    *    where:
    *       [3] = Dimension.Index
    */
   if (reg->Register.Dimension) {
      index2D.i[0] =
      index2D.i[1] =
      index2D.i[2] =
      index2D.i[3] = reg->Dimension.Index;

      /* Again, the second subscript index can be addressed indirectly
       * identically to the first one.
       * Nothing stops us from indirectly addressing the indirect register,
       * but there is no need for that, so we won't exercise it.
       *
       *    file[ind[4].y+3][1],
       *    where:
       *       ind = DimIndirect.File
       *       [4] = DimIndirect.Index
       *       .y = DimIndirect.SwizzleX
       */
      if (reg->Dimension.Indirect) {
         union tgsi_exec_channel index2;
         union tgsi_exec_channel indir_index;
         const uint execmask = mach->ExecMask;
         unsigned swizzle;
         uint i;

         index2.i[0] =
         index2.i[1] =
         index2.i[2] =
         index2.i[3] = reg->DimIndirect.Index;

         swizzle = tgsi_util_get_src_register_swizzle( &reg->DimIndirect, CHAN_X );
         fetch_src_file_channel(mach,
                                reg->DimIndirect.File,
                                swizzle,
                                &index2,
                                &ZeroVec,
                                &indir_index);

         index2D.i[0] += indir_index.i[0];
         index2D.i[1] += indir_index.i[1];
         index2D.i[2] += indir_index.i[2];
         index2D.i[3] += indir_index.i[3];

         /* for disabled execution channels, zero-out the index to
          * avoid using a potential garbage value.
          */
         for (i = 0; i < QUAD_SIZE; i++) {
            if ((execmask & (1 << i)) == 0) {
               index2D.i[i] = 0;
            }
         }
      }

      /* If by any chance there was a need for a 3D array of register
       * files, we would have to check whether Dimension is followed
       * by a dimension register and continue the saga.
       */
   } else {
      index2D.i[0] =
      index2D.i[1] =
      index2D.i[2] =
      index2D.i[3] = 0;
   }

d1344 1
a1344 1
   case TGSI_FILE_TEMPORARY_ARRAY:
d1346 1
a1346 6
      assert( index < TGSI_EXEC_NUM_TEMPS );
      assert( index2D.i[0] < TGSI_EXEC_NUM_TEMP_ARRAYS );
      /* XXX we use index2D.i[0] here but somehow we might
       * end up with someone trying to store indirectly in
       * different buffers */
      dst = &mach->TempArray[index2D.i[0]][offset + index].xyzw[chan_index];
d1349 5
a1353 3
   case TGSI_FILE_ADDRESS:
      index = reg->Register.Index;
      dst = &mach->Addrs[index].xyzw[chan_index];
d1447 3
a1535 13
static void
conditional_emit_primitive(struct tgsi_exec_machine *mach)
{
   if (TGSI_PROCESSOR_GEOMETRY == mach->Processor) {
      int emitted_verts =
         mach->Primitives[mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0]];
      if (emitted_verts) {
         emit_primitive(mach);
      }
   }
}


d1580 1
a1580 1
   uint chan;
d1652 2
a1653 4
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
d1663 1
a1663 1
   uint chan;
d1713 2
a1714 4
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
a1798 6
         /* XXX we could remove this special-case code since
          * mach->InterpCoefs[first].a0 should already have the
          * front/back-face value.  But we should first update the
          * ureg code to emit the right UsageMask value (WRITEMASK_X).
          * Then, we could remove the tgsi_exec_machine::Face field.
          */
a1841 20
typedef void (* micro_op)(union tgsi_exec_channel *dst);

static void
exec_vector(struct tgsi_exec_machine *mach,
            const struct tgsi_full_instruction *inst,
            micro_op op,
            enum tgsi_exec_datatype dst_datatype)
{
   unsigned int chan;

   for (chan = 0; chan < NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         union tgsi_exec_channel dst;

         op(&dst);
         store_dest(mach, &dst, &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

a1894 21
exec_scalar_binary(struct tgsi_exec_machine *mach,
                   const struct tgsi_full_instruction *inst,
                   micro_binary_op op,
                   enum tgsi_exec_datatype dst_datatype,
                   enum tgsi_exec_datatype src_datatype)
{
   unsigned int chan;
   union tgsi_exec_channel src[2];
   union tgsi_exec_channel dst;

   fetch_source(mach, &src[0], &inst->Src[0], CHAN_X, src_datatype);
   fetch_source(mach, &src[1], &inst->Src[1], CHAN_Y, src_datatype);
   op(&dst, &src[0], &src[1]);
   for (chan = 0; chan < NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &dst, &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

static void
a2140 283
exec_scs(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_XY) {
      union tgsi_exec_channel arg;
      union tgsi_exec_channel result;

      fetch_source(mach, &arg, &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);

      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
         micro_cos(&result, &arg);
         store_dest(mach, &result, &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
      }
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
         micro_sin(&result, &arg);
         store_dest(mach, &result, &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      }
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &ZeroVec, &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_x2d(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[4];
   union tgsi_exec_channel d[2];

   fetch_source(mach, &r[0], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[1], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_XZ) {
      fetch_source(mach, &r[2], &inst->Src[2], CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[2], &r[2], &r[0]);
      fetch_source(mach, &r[3], &inst->Src[2], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[3], &r[3], &r[1]);
      micro_add(&r[2], &r[2], &r[3]);
      fetch_source(mach, &r[3], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_add(&d[0], &r[2], &r[3]);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_YW) {
      fetch_source(mach, &r[2], &inst->Src[2], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[2], &r[2], &r[0]);
      fetch_source(mach, &r[3], &inst->Src[2], CHAN_W, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[3], &r[3], &r[1]);
      micro_add(&r[2], &r[2], &r[3]);
      fetch_source(mach, &r[3], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_add(&d[1], &r[2], &r[3]);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &d[0], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      store_dest(mach, &d[1], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &d[0], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &d[1], &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_rfl(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[9];

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_XYZ) {
      /* r0 = dp3(src0, src0) */
      fetch_source(mach, &r[2], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[0], &r[2], &r[2]);
      fetch_source(mach, &r[4], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[8], &r[4], &r[4]);
      micro_add(&r[0], &r[0], &r[8]);
      fetch_source(mach, &r[6], &inst->Src[0], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[8], &r[6], &r[6]);
      micro_add(&r[0], &r[0], &r[8]);

      /* r1 = dp3(src0, src1) */
      fetch_source(mach, &r[3], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[1], &r[2], &r[3]);
      fetch_source(mach, &r[5], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[8], &r[4], &r[5]);
      micro_add(&r[1], &r[1], &r[8]);
      fetch_source(mach, &r[7], &inst->Src[1], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&r[8], &r[6], &r[7]);
      micro_add(&r[1], &r[1], &r[8]);

      /* r1 = 2 * r1 / r0 */
      micro_add(&r[1], &r[1], &r[1]);
      micro_div(&r[1], &r[1], &r[0]);

      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
         micro_mul(&r[2], &r[2], &r[1]);
         micro_sub(&r[2], &r[2], &r[3]);
         store_dest(mach, &r[2], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
      }
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
         micro_mul(&r[4], &r[4], &r[1]);
         micro_sub(&r[4], &r[4], &r[5]);
         store_dest(mach, &r[4], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      }
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
         micro_mul(&r[6], &r[6], &r[1]);
         micro_sub(&r[6], &r[6], &r[7]);
         store_dest(mach, &r[6], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      }
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_xpd(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[6];
   union tgsi_exec_channel d[3];

   fetch_source(mach, &r[0], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[1], &inst->Src[1], CHAN_Z, TGSI_EXEC_DATA_FLOAT);

   micro_mul(&r[2], &r[0], &r[1]);

   fetch_source(mach, &r[3], &inst->Src[0], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[4], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);

   micro_mul(&r[5], &r[3], &r[4] );
   micro_sub(&d[CHAN_X], &r[2], &r[5]);

   fetch_source(mach, &r[2], &inst->Src[1], CHAN_X, TGSI_EXEC_DATA_FLOAT);

   micro_mul(&r[3], &r[3], &r[2]);

   fetch_source(mach, &r[5], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);

   micro_mul(&r[1], &r[1], &r[5]);
   micro_sub(&d[CHAN_Y], &r[3], &r[1]);

   micro_mul(&r[5], &r[5], &r[4]);
   micro_mul(&r[0], &r[0], &r[2]);
   micro_sub(&d[CHAN_Z], &r[5], &r[0]);

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &d[CHAN_X], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      store_dest(mach, &d[CHAN_Y], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &d[CHAN_Z], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_dst(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[2];
   union tgsi_exec_channel d[4];

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      fetch_source(mach, &r[0], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      fetch_source(mach, &r[1], &inst->Src[1], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&d[CHAN_Y], &r[0], &r[1]);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      fetch_source(mach, &d[CHAN_Z], &inst->Src[0], CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      fetch_source(mach, &d[CHAN_W], &inst->Src[1], CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      store_dest(mach, &d[CHAN_Y], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &d[CHAN_Z], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &d[CHAN_W], &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_log(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[3];

   fetch_source(mach, &r[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_abs(&r[2], &r[0]);  /* r2 = abs(r0) */
   micro_lg2(&r[1], &r[2]);  /* r1 = lg2(r2) */
   micro_flr(&r[0], &r[1]);  /* r0 = floor(r1) */
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &r[0], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      micro_exp2(&r[0], &r[0]);       /* r0 = 2 ^ r0 */
      micro_div(&r[0], &r[2], &r[0]); /* r0 = r2 / r0 */
      store_dest(mach, &r[0], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      store_dest(mach, &r[1], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_exp(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[3];

   fetch_source(mach, &r[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
   micro_flr(&r[1], &r[0]);  /* r1 = floor(r0) */
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      micro_exp2(&r[2], &r[1]);       /* r2 = 2 ^ r1 */
      store_dest(mach, &r[2], &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
      micro_sub(&r[2], &r[0], &r[1]); /* r2 = r0 - r1 */
      store_dest(mach, &r[2], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
      micro_exp2(&r[2], &r[0]);       /* r2 = 2 ^ r0 */
      store_dest(mach, &r[2], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
exec_lit(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   union tgsi_exec_channel r[3];
   union tgsi_exec_channel d[3];

   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_YZ) {
      fetch_source(mach, &r[0], &inst->Src[0], CHAN_X, TGSI_EXEC_DATA_FLOAT);
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
         micro_max(&d[CHAN_Y], &r[0], &ZeroVec);
         store_dest(mach, &d[CHAN_Y], &inst->Dst[0], inst, CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      }

      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Z) {
         fetch_source(mach, &r[1], &inst->Src[0], CHAN_Y, TGSI_EXEC_DATA_FLOAT);
         micro_max(&r[1], &r[1], &ZeroVec);

         fetch_source(mach, &r[2], &inst->Src[0], CHAN_W, TGSI_EXEC_DATA_FLOAT);
         micro_min(&r[2], &r[2], &P128Vec);
         micro_max(&r[2], &r[2], &M128Vec);
         micro_pow(&r[1], &r[1], &r[2]);
         micro_lt(&d[CHAN_Z], &ZeroVec, &r[0], &r[1], &ZeroVec);
         store_dest(mach, &d[CHAN_Z], &inst->Dst[0], inst, CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      }
   }
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_W) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, CHAN_W, TGSI_EXEC_DATA_FLOAT);
   }
}

static void
d2523 1
d2525 1
d2539 30
a2568 1
      exec_lit(mach, inst);
d2580 17
a2596 1
      exec_exp(mach, inst);
d2600 18
a2617 1
      exec_log(mach, inst);
d2637 24
a2660 1
      exec_dst(mach, inst);
d2724 8
a2731 1
      exec_scalar_binary(mach, inst, micro_pow, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
d2735 36
a2770 1
      exec_xpd(mach, inst);
d2778 6
a2783 1
      exec_scalar_unary(mach, inst, micro_rcc, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
d2827 46
a2872 1
      exec_rfl(mach, inst);
d2880 3
a2882 1
      exec_vector(mach, inst, micro_sfl, TGSI_EXEC_DATA_FLOAT);
d2902 3
a2904 1
      exec_vector(mach, inst, micro_str, TGSI_EXEC_DATA_FLOAT);
d2961 36
a2996 1
      exec_x2d(mach, inst);
a3061 2
            mach->CondStackTop = 0;
            mach->LoopStackTop = 0;
d3102 17
a3118 1
      exec_scs(mach, inst);
d3130 1
a3130 1
      exec_vector_binary(mach, inst, micro_div, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
a3178 3
      /* make sure we end primitives which haven't
       * been explicitly emitted */
      conditional_emit_primitive(mach);
d3183 8
d3255 23
d3292 50
d3581 8
a3667 3
   /* Strictly speaking, these assertions aren't really needed but they
    * can potentially catch some bugs in the control flow code.
    */
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d65 1
a65 4
#define DEBUG_EXECUTION 0


#define FAST_MATH 0
d339 4
a342 14
   dst->f[0] = 1.0f / sqrtf(src->f[0]);
   dst->f[1] = 1.0f / sqrtf(src->f[1]);
   dst->f[2] = 1.0f / sqrtf(src->f[2]);
   dst->f[3] = 1.0f / sqrtf(src->f[3]);
}

static void
micro_sqrt(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->f[0] = sqrtf(src->f[0]);
   dst->f[1] = sqrtf(src->f[1]);
   dst->f[2] = sqrtf(src->f[2]);
   dst->f[3] = sqrtf(src->f[3]);
a377 10
micro_isgn(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->i[0] = src->i[0] < 0 ? -1 : src->i[0] > 0 ? 1 : 0;
   dst->i[1] = src->i[1] < 0 ? -1 : src->i[1] > 0 ? 1 : 0;
   dst->i[2] = src->i[2] < 0 ? -1 : src->i[2] > 0 ? 1 : 0;
   dst->i[3] = src->i[3] < 0 ? -1 : src->i[3] > 0 ? 1 : 0;
}

static void
d460 5
d600 1
a600 1
         for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d626 2
a627 1
   struct tgsi_sampler *sampler)
d642 3
d647 1
a647 1
   mach->Sampler = sampler;
d651 3
a653 1
      FREE(mach->Declarations);
d657 3
a659 1
      FREE(mach->Instructions);
a673 29
   mach->NumOutputs = 0;

   if (mach->Processor == TGSI_PROCESSOR_GEOMETRY &&
       !mach->UsedGeometryShader) {
      struct tgsi_exec_vector *inputs;
      struct tgsi_exec_vector *outputs;

      inputs = align_malloc(sizeof(struct tgsi_exec_vector) *
                            TGSI_MAX_PRIM_VERTICES * PIPE_MAX_ATTRIBS,
                            16);

      if (!inputs)
         return;

      outputs = align_malloc(sizeof(struct tgsi_exec_vector) *
                             TGSI_MAX_TOTAL_VERTICES, 16);

      if (!outputs) {
         align_free(inputs);
         return;
      }

      align_free(mach->Inputs);
      align_free(mach->Outputs);

      mach->Inputs = inputs;
      mach->Outputs = outputs;
      mach->UsedGeometryShader = TRUE;
   }
d713 13
d774 3
a776 1
   FREE(mach->Declarations);
d780 3
a782 1
   FREE(mach->Instructions);
a803 5
   mach->Inputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_ATTRIBS, 16);
   mach->Outputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_ATTRIBS, 16);
   if (!mach->Inputs || !mach->Outputs)
      goto fail;

d827 1
a827 5
   if (mach) {
      align_free(mach->Inputs);
      align_free(mach->Outputs);
      align_free(mach);
   }
d836 3
a838 1
      FREE(mach->Instructions);
d840 1
d842 1
a842 5
      align_free(mach->Inputs);
      align_free(mach->Outputs);

      align_free(mach);
   }
a999 1
                       const uint chan_index,
d1012 1
a1012 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1024 1
a1024 1
            if (pos < 0 || pos >= (int) mach->ConstsSize[constbuf]) {
d1041 2
a1042 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1051 1
a1051 1
         assert(pos < TGSI_MAX_PRIM_VERTICES * PIPE_MAX_ATTRIBS);
d1056 6
a1061 6
   case TGSI_FILE_SYSTEM_VALUE:
      /* XXX no swizzling at this point.  Will be needed if we put
       * gl_FragCoord, for example, in a sys value register.
       */
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         chan->u[i] = mach->SystemValue[index->i[i]].u[i];
d1065 2
a1066 2
   case TGSI_FILE_TEMPORARY:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1068 1
a1068 1
         assert(index2D->i[i] == 0);
d1070 2
a1071 1
         chan->u[i] = mach->Temps[index->i[i]].xyzw[swizzle].u[i];
d1076 1
a1076 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1084 8
d1093 1
a1093 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1102 1
a1102 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1112 1
a1112 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1122 1
a1122 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1172 1
d1174 1
a1174 1
      swizzle = reg->Indirect.Swizzle;
a1175 1
                             chan_index,
d1191 1
a1191 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1233 1
a1233 1
         swizzle = reg->DimIndirect.Swizzle;
a1234 1
                                chan_index,
d1249 1
a1249 1
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
a1268 1
                          chan_index,
d1335 1
a1335 1
      swizzle = reg->Indirect.Swizzle;
a1338 1
                             chan_index,
d1386 1
a1386 1
         swizzle = reg->DimIndirect.Swizzle;
a1387 1
                                chan_index,
d1402 1
a1402 1
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
a1429 3
      debug_printf("NumOutputs = %d, TEMP_O_C/I = %d, redindex = %d\n",
                   mach->NumOutputs, mach->Temps[TEMP_OUTPUT_I].xyzw[TEMP_OUTPUT_C].u[0],
                   reg->Register.Index);
d1431 2
a1432 2
         debug_printf("STORING OUT[%d] mask(%d), = (", offset + index, execmask);
         for (i = 0; i < TGSI_QUAD_SIZE; i++)
d1434 2
a1435 2
               debug_printf("%f, ", chan->f[i]);
         debug_printf(")\n");
d1446 10
d1477 1
a1477 1
      case TGSI_CHAN_X:
d1480 1
a1480 1
      case TGSI_CHAN_Y:
d1483 1
a1483 1
      case TGSI_CHAN_Z:
d1486 1
a1486 1
      case TGSI_CHAN_W:
d1499 1
a1499 1
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1505 1
a1505 1
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1515 1
a1515 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++)
d1521 1
a1521 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++)
d1533 1
a1533 1
      for (i = 0; i < TGSI_QUAD_SIZE; i++)
a1551 3
#define IFETCH(VAL,INDEX,CHAN)\
    fetch_source(mach, VAL, &inst->Src[INDEX], CHAN, TGSI_EXEC_DATA_INT)

d1558 2
a1559 2
exec_kill_if(struct tgsi_exec_machine *mach,
             const struct tgsi_full_instruction *inst)
d1594 2
a1595 1
 * Unconditional fragment kill/discard.
d1598 1
a1598 1
exec_kill(struct tgsi_exec_machine *mach,
d1603 1
a1603 1
   /* kill fragment for all fragments currently executing */
d1613 1
a1613 1
   for (i = 0; i < TGSI_QUAD_SIZE; ++i) {
d1628 1
a1628 1
   for (i = 0; i < TGSI_QUAD_SIZE; ++i) {
a1655 2
             const unsigned sview_idx,
             const unsigned sampler_idx,
a1659 3
             const union tgsi_exec_channel *c1,
             float derivs[3][2][TGSI_QUAD_SIZE],
             const int8_t offset[3],
d1667 1
a1667 1
   float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
d1669 1
a1669 3
   /* FIXME: handle explicit derivs, offsets */
   sampler->get_samples(sampler, sview_idx, sampler_idx,
                        s->f, t->f, p->f, c0->f, c1->f, derivs, offset, control, rgba);
a1683 1
#define TEX_MODIFIER_LEVEL_ZERO     4
a1685 60
/*
 * Fetch all 3 (for s,t,r coords) texel offsets, put them into int array.
 */
static void
fetch_texel_offsets(struct tgsi_exec_machine *mach,
                    const struct tgsi_full_instruction *inst,
                    int8_t offsets[3])
{
   if (inst->Texture.NumOffsets == 1) {
      union tgsi_exec_channel index;
      union tgsi_exec_channel offset[3];
      index.i[0] = index.i[1] = index.i[2] = index.i[3] = inst->TexOffsets[0].Index;
      fetch_src_file_channel(mach, 0, inst->TexOffsets[0].File,
                             inst->TexOffsets[0].SwizzleX, &index, &ZeroVec, &offset[0]);
      fetch_src_file_channel(mach, 0, inst->TexOffsets[0].File,
                             inst->TexOffsets[0].SwizzleY, &index, &ZeroVec, &offset[1]);
      fetch_src_file_channel(mach, 0, inst->TexOffsets[0].File,
                             inst->TexOffsets[0].SwizzleZ, &index, &ZeroVec, &offset[2]);
     offsets[0] = offset[0].i[0];
     offsets[1] = offset[1].i[0];
     offsets[2] = offset[2].i[0];
   } else {
     assert(inst->Texture.NumOffsets == 0);
     offsets[0] = offsets[1] = offsets[2] = 0;
   }
}


/*
 * Fetch dx and dy values for one channel (s, t or r).
 * Put dx values into one float array, dy values into another.
 */
static void
fetch_assign_deriv_channel(struct tgsi_exec_machine *mach,
                           const struct tgsi_full_instruction *inst,
                           unsigned regdsrcx,
                           unsigned chan,
                           float derivs[2][TGSI_QUAD_SIZE])
{
   union tgsi_exec_channel d;
   FETCH(&d, regdsrcx, chan);
   derivs[0][0] = d.f[0];
   derivs[0][1] = d.f[1];
   derivs[0][2] = d.f[2];
   derivs[0][3] = d.f[3];
   FETCH(&d, regdsrcx + 1, chan);
   derivs[1][0] = d.f[0];
   derivs[1][1] = d.f[1];
   derivs[1][2] = d.f[2];
   derivs[1][3] = d.f[3];
}


/*
 * execute a texture instruction.
 *
 * modifier is used to control the channel routing for the\
 * instruction variants like proj, lod, and texture with lod bias.
 * sampler indicates which src register the sampler is contained in.
 */
d1689 1
a1689 1
         uint modifier, uint sampler)
d1691 4
a1694 4
   const uint unit = inst->Src[sampler].Register.Index;
   const union tgsi_exec_channel *args[5], *proj = NULL;
   union tgsi_exec_channel r[5];
   enum tgsi_sampler_control control =  tgsi_sampler_lod_none;
a1695 14
   int8_t offsets[3];
   int dim, shadow_ref, i;

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

   assert(modifier != TEX_MODIFIER_LEVEL_ZERO);
   assert(inst->Texture.Texture != TGSI_TEXTURE_BUFFER);

   dim = tgsi_util_get_texture_coord_dim(inst->Texture.Texture, &shadow_ref);

   assert(dim <= 4);
   if (shadow_ref >= 0)
      assert(shadow_ref >= dim && shadow_ref < Elements(args));
a1696 1
   /* fetch modifier to the last argument */
d1698 1
a1698 12
      const int last = Elements(args) - 1;

      /* fetch modifier from src0.w or src1.x */
      if (sampler == 1) {
         assert(dim <= TGSI_CHAN_W && shadow_ref != TGSI_CHAN_W);
         FETCH(&r[last], 0, TGSI_CHAN_W);
      }
      else {
         assert(shadow_ref != 4);
         FETCH(&r[last], 1, TGSI_CHAN_X);
      }

d1700 1
a1700 1
         args[last] = &r[last];
a1701 17
      else {
         proj = &r[last];
         args[last] = &ZeroVec;
      }

      /* point unused arguments to zero vector */
      for (i = dim; i < last; i++)
         args[i] = &ZeroVec;

      if (modifier == TEX_MODIFIER_EXPLICIT_LOD)
         control = tgsi_sampler_lod_explicit;
      else if (modifier == TEX_MODIFIER_LOD_BIAS)
         control = tgsi_sampler_lod_bias;
   }
   else {
      for (i = dim; i < Elements(args); i++)
         args[i] = &ZeroVec;
d1704 4
a1707 18
   /* fetch coordinates */
   for (i = 0; i < dim; i++) {
      FETCH(&r[i], 0, TGSI_CHAN_X + i);

      if (proj)
         micro_div(&r[i], &r[i], proj);

      args[i] = &r[i];
   }

   /* fetch reference value */
   if (shadow_ref >= 0) {
      FETCH(&r[shadow_ref], shadow_ref / 4, TGSI_CHAN_X + (shadow_ref % 4));

      if (proj)
         micro_div(&r[shadow_ref], &r[shadow_ref], proj);

      args[shadow_ref] = &r[shadow_ref];
a1709 37
   fetch_texel(mach->Sampler, unit, unit,
         args[0], args[1], args[2], args[3], args[4],
         NULL, offsets, control,
         &r[0], &r[1], &r[2], &r[3]);     /* R, G, B, A */

#if 0
   debug_printf("fetch r: %g %g %g %g\n",
         r[0].f[0], r[0].f[1], r[0].f[2], r[0].f[3]);
   debug_printf("fetch g: %g %g %g %g\n",
         r[1].f[0], r[1].f[1], r[1].f[2], r[1].f[3]);
   debug_printf("fetch b: %g %g %g %g\n",
         r[2].f[0], r[2].f[1], r[2].f[2], r[2].f[3]);
   debug_printf("fetch a: %g %g %g %g\n",
         r[3].f[0], r[3].f[1], r[3].f[2], r[3].f[3]);
#endif

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}


static void
exec_txd(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   const uint unit = inst->Src[3].Register.Index;
   union tgsi_exec_channel r[4];
   float derivs[3][2][TGSI_QUAD_SIZE];
   uint chan;
   int8_t offsets[3];

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

a1711 10
      FETCH(&r[0], 0, TGSI_CHAN_X);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &ZeroVec, &ZeroVec, &ZeroVec, &ZeroVec,   /* S, T, P, C, LOD */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);           /* R, G, B, A */
      break;

d1713 1
a1713 28
   case TGSI_TEXTURE_1D_ARRAY:
   case TGSI_TEXTURE_SHADOW1D_ARRAY:
      /* SHADOW1D/1D_ARRAY would not need Y/Z respectively, but don't bother */
      FETCH(&r[0], 0, TGSI_CHAN_X);
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &r[1], &r[2], &ZeroVec, &ZeroVec,   /* S, T, P, C, LOD */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);           /* R, G, B, A */
      break;

   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_RECT:
      FETCH(&r[0], 0, TGSI_CHAN_X);
      FETCH(&r[1], 0, TGSI_CHAN_Y);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_Y, derivs[1]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &r[1], &ZeroVec, &ZeroVec, &ZeroVec,   /* S, T, P, C, LOD */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);           /* R, G, B, A */
      break;
d1715 3
d1719 4
a1722 36
   case TGSI_TEXTURE_SHADOW2D:
   case TGSI_TEXTURE_SHADOWRECT:
   case TGSI_TEXTURE_2D_ARRAY:
   case TGSI_TEXTURE_SHADOW2D_ARRAY:
      /* only SHADOW2D_ARRAY actually needs W */
      FETCH(&r[0], 0, TGSI_CHAN_X);
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      FETCH(&r[3], 0, TGSI_CHAN_W);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_Y, derivs[1]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &r[1], &r[2], &r[3], &ZeroVec,   /* inputs */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);     /* outputs */
      break;

   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_CUBE:
   case TGSI_TEXTURE_CUBE_ARRAY:
      /* only TEXTURE_CUBE_ARRAY actually needs W */
      FETCH(&r[0], 0, TGSI_CHAN_X);
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      FETCH(&r[3], 0, TGSI_CHAN_W);

      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_Y, derivs[1]);
      fetch_assign_deriv_channel(mach, inst, 1, TGSI_CHAN_Z, derivs[2]);

      fetch_texel(mach->Sampler, unit, unit,
                  &r[0], &r[1], &r[2], &r[3], &ZeroVec,   /* inputs */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
                  &r[0], &r[1], &r[2], &r[3]);     /* outputs */
a1724 41
   default:
      assert(0);
   }

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
      }
   }
}


static void
exec_txf(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   const uint unit = inst->Src[1].Register.Index;
   union tgsi_exec_channel r[4];
   uint chan;
   float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
   int j;
   int8_t offsets[3];
   unsigned target;

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

   IFETCH(&r[3], 0, TGSI_CHAN_W);

   if (inst->Instruction.Opcode == TGSI_OPCODE_SAMPLE_I) {
      target = mach->SamplerViews[unit].Resource;
   }
   else {
      target = inst->Texture.Texture;
   }
   switch(target) {
   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_2D_ARRAY:
   case TGSI_TEXTURE_SHADOW2D_ARRAY:
      IFETCH(&r[2], 0, TGSI_CHAN_Z);
      /* fallthrough */
a1726 1
   case TGSI_TEXTURE_SHADOW1D_ARRAY:
d1729 8
a1736 26
   case TGSI_TEXTURE_1D_ARRAY:
      IFETCH(&r[1], 0, TGSI_CHAN_Y);
      /* fallthrough */
   case TGSI_TEXTURE_BUFFER:
   case TGSI_TEXTURE_1D:
   case TGSI_TEXTURE_SHADOW1D:
      IFETCH(&r[0], 0, TGSI_CHAN_X);
      break;
   default:
      assert(0);
      break;
   }      

   mach->Sampler->get_texel(mach->Sampler, unit, r[0].i, r[1].i, r[2].i, r[3].i,
                            offsets, rgba);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      r[0].f[j] = rgba[0][j];
      r[1].f[j] = rgba[1][j];
      r[2].f[j] = rgba[2][j];
      r[3].f[j] = rgba[3][j];
   }

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
a1737 2
   }
}
d1739 4
a1742 80
static void
exec_txq(struct tgsi_exec_machine *mach,
         const struct tgsi_full_instruction *inst)
{
   const uint unit = inst->Src[1].Register.Index;
   int result[4];
   union tgsi_exec_channel r[4], src;
   uint chan;
   int i,j;

   fetch_source(mach, &src, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_INT);

   mach->Sampler->get_dims(mach->Sampler, unit, src.i[0], result);

   for (i = 0; i < TGSI_QUAD_SIZE; i++) {
      for (j = 0; j < 4; j++) {
         r[j].i[i] = result[j];
      }
   }

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &r[chan], &inst->Dst[0], inst, chan,
                    TGSI_EXEC_DATA_INT);
      }
   }
}

static void
exec_sample(struct tgsi_exec_machine *mach,
            const struct tgsi_full_instruction *inst,
            uint modifier, boolean compare)
{
   const uint resource_unit = inst->Src[1].Register.Index;
   const uint sampler_unit = inst->Src[2].Register.Index;
   union tgsi_exec_channel r[4], c1;
   const union tgsi_exec_channel *lod = &ZeroVec;
   enum tgsi_sampler_control control = tgsi_sampler_lod_none;
   uint chan;
   int8_t offsets[3];

   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);

   assert(modifier != TEX_MODIFIER_PROJECTED);

   if (modifier != TEX_MODIFIER_NONE) {
      if (modifier == TEX_MODIFIER_LOD_BIAS) {
         FETCH(&c1, 3, TGSI_CHAN_X);
         lod = &c1;
         control = tgsi_sampler_lod_bias;
      }
      else if (modifier == TEX_MODIFIER_EXPLICIT_LOD) {
         FETCH(&c1, 3, TGSI_CHAN_X);
         lod = &c1;
         control = tgsi_sampler_lod_explicit;
      }
      else {
         assert(modifier == TEX_MODIFIER_LEVEL_ZERO);
         control = tgsi_sampler_lod_zero;
      }
   }

   FETCH(&r[0], 0, TGSI_CHAN_X);

   switch (mach->SamplerViews[resource_unit].Resource) {
   case TGSI_TEXTURE_1D:
      if (compare) {
         FETCH(&r[2], 3, TGSI_CHAN_X);
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &ZeroVec, &r[2], &ZeroVec, lod, /* S, T, P, C, LOD */
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);     /* R, G, B, A */
      }
      else {
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &ZeroVec, &ZeroVec, &ZeroVec, lod, /* S, T, P, C, LOD */
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);     /* R, G, B, A */
      }
a1744 20
   case TGSI_TEXTURE_1D_ARRAY:
   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_RECT:
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      if (compare) {
         FETCH(&r[2], 3, TGSI_CHAN_X);
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &ZeroVec, lod,    /* S, T, P, C, LOD */
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);  /* outputs */
      }
      else {
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &ZeroVec, &ZeroVec, lod,    /* S, T, P, C, LOD */
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);  /* outputs */
      }
      break;

   case TGSI_TEXTURE_2D_ARRAY:
d1747 8
a1754 14
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      if(compare) {
         FETCH(&r[3], 3, TGSI_CHAN_X);
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &r[3], lod,
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);
      }
      else {
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &ZeroVec, lod,
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);
a1755 1
      break;
d1757 4
a1760 17
   case TGSI_TEXTURE_CUBE_ARRAY:
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      FETCH(&r[3], 0, TGSI_CHAN_W);
      if(compare) {
         FETCH(&r[4], 3, TGSI_CHAN_X);
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &r[3], &r[4],
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);
      }
      else {
         fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                     &r[0], &r[1], &r[2], &r[3], lod,
                     NULL, offsets, control,
                     &r[0], &r[1], &r[2], &r[3]);
      }
a1762 1

d1767 1
a1767 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d1775 2
a1776 2
exec_sample_d(struct tgsi_exec_machine *mach,
              const struct tgsi_full_instruction *inst)
d1778 1
a1778 2
   const uint resource_unit = inst->Src[1].Register.Index;
   const uint sampler_unit = inst->Src[2].Register.Index;
a1779 1
   float derivs[3][2][TGSI_QUAD_SIZE];
a1780 1
   int8_t offsets[3];
d1782 7
a1788 2
   /* always fetch all 3 offsets, overkill but keeps code simple */
   fetch_texel_offsets(mach, inst, offsets);
d1790 1
a1790 1
   FETCH(&r[0], 0, TGSI_CHAN_X);
d1792 3
a1794 11
   switch (mach->SamplerViews[resource_unit].Resource) {
   case TGSI_TEXTURE_1D:
   case TGSI_TEXTURE_1D_ARRAY:
      /* only 1D array actually needs Y */
      FETCH(&r[1], 0, TGSI_CHAN_Y);

      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_X, derivs[0]);

      fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                  &r[0], &r[1], &ZeroVec, &ZeroVec, &ZeroVec,   /* S, T, P, C, LOD */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
d1800 10
a1809 11
   case TGSI_TEXTURE_2D_ARRAY:
      /* only 2D array actually needs Z */
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);

      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_Y, derivs[1]);

      fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                  &r[0], &r[1], &r[2], &ZeroVec, &ZeroVec,   /* inputs */
                  derivs, offsets, tgsi_sampler_derivs_explicit,
d1815 8
a1822 13
   case TGSI_TEXTURE_CUBE_ARRAY:
      /* only cube array actually needs W */
      FETCH(&r[1], 0, TGSI_CHAN_Y);
      FETCH(&r[2], 0, TGSI_CHAN_Z);
      FETCH(&r[3], 0, TGSI_CHAN_W);

      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_X, derivs[0]);
      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_Y, derivs[1]);
      fetch_assign_deriv_channel(mach, inst, 3, TGSI_CHAN_Z, derivs[2]);

      fetch_texel(mach->Sampler, resource_unit, sampler_unit,
                  &r[0], &r[1], &r[2], &r[3], &ZeroVec,
                  derivs, offsets, tgsi_sampler_derivs_explicit,
d1830 1
a1830 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d1850 1
a1850 1
   for( i = 0; i < TGSI_QUAD_SIZE; i++ ) {
a1908 5
   if (decl->Declaration.File == TGSI_FILE_SAMPLER_VIEW) {
      mach->SamplerViews[decl->Range.First] = decl->SamplerView;
      return;
   }

d1910 2
a1911 1
      if (decl->Declaration.File == TGSI_FILE_INPUT) {
a1923 1
         /* XXX make FACE a system value */
d1930 1
a1930 1
            for (i = 0; i < TGSI_QUAD_SIZE; i++) {
d1937 1
a1937 1
            switch (decl->Interp.Interpolate) {
a1949 4
            case TGSI_INTERPOLATE_COLOR:
               eval = mach->flatshade_color ? eval_constant_coef : eval_perspective_coef;
               break;

d1955 1
a1955 1
            for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
a1962 17

         if (DEBUG_EXECUTION) {
            uint i, j;
            for (i = first; i <= last; ++i) {
               debug_printf("IN[%2u] = ", i);
               for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
                  if (j > 0) {
                     debug_printf("         ");
                  }
                  debug_printf("(%6f %u, %6f %u, %6f %u, %6f %u)\n",
                               mach->Inputs[i].xyzw[0].f[j], mach->Inputs[i].xyzw[0].u[j],
                               mach->Inputs[i].xyzw[1].f[j], mach->Inputs[i].xyzw[1].u[j],
                               mach->Inputs[i].xyzw[2].f[j], mach->Inputs[i].xyzw[2].u[j],
                               mach->Inputs[i].xyzw[3].f[j], mach->Inputs[i].xyzw[3].u[j]);
               }
            }
         }
a1964 4

   if (decl->Declaration.File == TGSI_FILE_SYSTEM_VALUE) {
      mach->SysSemanticToIndex[decl->Declaration.Semantic] = decl->Range.First;
   }
a1966 1

d1977 1
a1977 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2001 1
a2001 1
   fetch_source(mach, &src, &inst->Src[0], TGSI_CHAN_X, src_datatype);
d2003 1
a2003 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2020 1
a2020 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2028 1
a2028 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2050 2
a2051 2
   fetch_source(mach, &src[0], &inst->Src[0], TGSI_CHAN_X, src_datatype);
   fetch_source(mach, &src[1], &inst->Src[1], TGSI_CHAN_X, src_datatype);
d2053 1
a2053 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2070 1
a2070 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2079 1
a2079 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2101 1
a2101 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2111 1
a2111 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2125 2
a2126 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2129 1
a2129 1
   for (chan = TGSI_CHAN_Y; chan <= TGSI_CHAN_Z; chan++) {
d2135 1
a2135 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2149 2
a2150 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2153 1
a2153 1
   for (chan = TGSI_CHAN_Y; chan <= TGSI_CHAN_W; chan++) {
d2159 1
a2159 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2173 2
a2174 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2177 2
a2178 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2181 1
a2181 1
   fetch_source(mach, &arg[1], &inst->Src[2], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2184 1
a2184 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2198 2
a2199 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2202 2
a2203 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2206 2
a2207 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2210 1
a2210 1
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2213 1
a2213 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2227 2
a2228 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2231 2
a2232 2
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &arg[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2235 1
a2235 1
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
d2250 1
a2250 1
   fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2253 1
a2253 1
   for (chan = TGSI_CHAN_Y; chan <= TGSI_CHAN_W; chan++) {
d2263 1
a2263 1
   for (chan = TGSI_CHAN_X; chan <= TGSI_CHAN_W; chan++) {
d2280 1
a2280 1
      fetch_source(mach, &arg[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2283 1
a2283 1
      for (chan = TGSI_CHAN_Y; chan <= TGSI_CHAN_Z; chan++) {
d2293 1
a2293 1
      for (chan = TGSI_CHAN_X; chan <= TGSI_CHAN_Z; chan++) {
d2302 1
a2302 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2314 1
a2314 1
      fetch_source(mach, &arg, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2318 1
a2318 1
         store_dest(mach, &result, &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2322 1
a2322 1
         store_dest(mach, &result, &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2326 1
a2326 1
      store_dest(mach, &ZeroVec, &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2329 1
a2329 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2340 2
a2341 2
   fetch_source(mach, &r[0], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2343 1
a2343 1
      fetch_source(mach, &r[2], &inst->Src[2], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2345 1
a2345 1
      fetch_source(mach, &r[3], &inst->Src[2], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2348 1
a2348 1
      fetch_source(mach, &r[3], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2352 1
a2352 1
      fetch_source(mach, &r[2], &inst->Src[2], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2354 1
a2354 1
      fetch_source(mach, &r[3], &inst->Src[2], TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2357 1
a2357 1
      fetch_source(mach, &r[3], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2361 1
a2361 1
      store_dest(mach, &d[0], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2364 1
a2364 1
      store_dest(mach, &d[1], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2367 1
a2367 1
      store_dest(mach, &d[0], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2370 1
a2370 1
      store_dest(mach, &d[1], &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2382 1
a2382 1
      fetch_source(mach, &r[2], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2384 1
a2384 1
      fetch_source(mach, &r[4], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2387 1
a2387 1
      fetch_source(mach, &r[6], &inst->Src[0], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2392 1
a2392 1
      fetch_source(mach, &r[3], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2394 1
a2394 1
      fetch_source(mach, &r[5], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2397 1
a2397 1
      fetch_source(mach, &r[7], &inst->Src[1], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2408 1
a2408 1
         store_dest(mach, &r[2], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2413 1
a2413 1
         store_dest(mach, &r[4], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2418 1
a2418 1
         store_dest(mach, &r[6], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2422 1
a2422 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2433 2
a2434 2
   fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[1], &inst->Src[1], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2438 2
a2439 2
   fetch_source(mach, &r[3], &inst->Src[0], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
   fetch_source(mach, &r[4], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2442 1
a2442 1
   micro_sub(&d[TGSI_CHAN_X], &r[2], &r[5]);
d2444 1
a2444 1
   fetch_source(mach, &r[2], &inst->Src[1], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2448 1
a2448 1
   fetch_source(mach, &r[5], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2451 1
a2451 1
   micro_sub(&d[TGSI_CHAN_Y], &r[3], &r[1]);
d2455 1
a2455 1
   micro_sub(&d[TGSI_CHAN_Z], &r[5], &r[0]);
d2458 1
a2458 1
      store_dest(mach, &d[TGSI_CHAN_X], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2461 1
a2461 1
      store_dest(mach, &d[TGSI_CHAN_Y], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2464 1
a2464 1
      store_dest(mach, &d[TGSI_CHAN_Z], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2467 1
a2467 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2479 3
a2481 3
      fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      fetch_source(mach, &r[1], &inst->Src[1], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
      micro_mul(&d[TGSI_CHAN_Y], &r[0], &r[1]);
d2484 1
a2484 1
      fetch_source(mach, &d[TGSI_CHAN_Z], &inst->Src[0], TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2487 1
a2487 1
      fetch_source(mach, &d[TGSI_CHAN_W], &inst->Src[1], TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2491 1
a2491 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2494 1
a2494 1
      store_dest(mach, &d[TGSI_CHAN_Y], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2497 1
a2497 1
      store_dest(mach, &d[TGSI_CHAN_Z], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2500 1
a2500 1
      store_dest(mach, &d[TGSI_CHAN_W], &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2510 1
a2510 1
   fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2515 1
a2515 1
      store_dest(mach, &r[0], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2520 1
a2520 1
      store_dest(mach, &r[0], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2523 1
a2523 1
      store_dest(mach, &r[1], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2526 1
a2526 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2536 1
a2536 1
   fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2540 1
a2540 1
      store_dest(mach, &r[2], &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2544 1
a2544 1
      store_dest(mach, &r[2], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2548 1
a2548 1
      store_dest(mach, &r[2], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
d2551 1
a2551 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2562 3
d2566 6
a2571 1
      fetch_source(mach, &r[0], &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
d2573 1
a2573 1
         fetch_source(mach, &r[1], &inst->Src[0], TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
d2576 1
a2576 1
         fetch_source(mach, &r[2], &inst->Src[0], TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2580 2
a2581 6
         micro_lt(&d[TGSI_CHAN_Z], &ZeroVec, &r[0], &r[1], &ZeroVec);
         store_dest(mach, &d[TGSI_CHAN_Z], &inst->Dst[0], inst, TGSI_CHAN_Z, TGSI_EXEC_DATA_FLOAT);
      }
      if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_Y) {
         micro_max(&d[TGSI_CHAN_Y], &r[0], &ZeroVec);
         store_dest(mach, &d[TGSI_CHAN_Y], &inst->Dst[0], inst, TGSI_CHAN_Y, TGSI_EXEC_DATA_FLOAT);
a2583 4
   if (inst->Dst[0].Register.WriteMask & TGSI_WRITEMASK_X) {
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_X, TGSI_EXEC_DATA_FLOAT);
   }

d2585 1
a2585 1
      store_dest(mach, &OneVec, &inst->Dst[0], inst, TGSI_CHAN_W, TGSI_EXEC_DATA_FLOAT);
d2614 1
a2614 1
   fetch_source(mach, &mach->Switch.selector, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_UINT);
d2632 1
a2632 1
   fetch_source(mach, &src, &inst->Src[0], TGSI_CHAN_X, TGSI_EXEC_DATA_UINT);
a2653 1
/* FIXME: this will only work if default is last */
a2737 11
micro_mod(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1)
{
   dst->i[0] = src0->i[0] % src1->i[0];
   dst->i[1] = src0->i[1] % src1->i[1];
   dst->i[2] = src0->i[2] % src1->i[2];
   dst->i[3] = src0->i[3] % src1->i[3];
}

static void
d2849 4
a2852 4
   dst->u[0] = src1->u[0] ? src0->u[0] / src1->u[0] : ~0u;
   dst->u[1] = src1->u[1] ? src0->u[1] / src1->u[1] : ~0u;
   dst->u[2] = src1->u[2] ? src0->u[2] / src1->u[2] : ~0u;
   dst->u[3] = src1->u[3] ? src0->u[3] / src1->u[3] : ~0u;
d2894 4
a2897 4
   dst->u[0] = src1->u[0] ? src0->u[0] % src1->u[0] : ~0u;
   dst->u[1] = src1->u[1] ? src0->u[1] % src1->u[1] : ~0u;
   dst->u[2] = src1->u[2] ? src0->u[2] % src1->u[2] : ~0u;
   dst->u[3] = src1->u[3] ? src0->u[3] % src1->u[3] : ~0u;
a2966 22
micro_uarl(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->i[0] = src->u[0];
   dst->i[1] = src->u[1];
   dst->i[2] = src->u[2];
   dst->i[3] = src->u[3];
}

static void
micro_ucmp(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1,
           const union tgsi_exec_channel *src2)
{
   dst->u[0] = src0->u[0] ? src1->u[0] : src2->u[0];
   dst->u[1] = src0->u[1] ? src1->u[1] : src2->u[1];
   dst->u[2] = src0->u[2] ? src1->u[2] : src2->u[2];
   dst->u[3] = src0->u[3] ? src1->u[3] : src2->u[3];
}

static void
a3056 4
   case TGSI_OPCODE_SQRT:
      exec_scalar_unary(mach, inst, micro_sqrt, TGSI_EXEC_DATA_FLOAT, TGSI_EXEC_DATA_FLOAT);
      break;

d3117 2
a3118 2
   case TGSI_OPCODE_KILL:
      exec_kill (mach, inst);
d3121 2
a3122 2
   case TGSI_OPCODE_KILL_IF:
      exec_kill_if (mach, inst);
d3177 1
a3177 1
      exec_tex(mach, inst, TEX_MODIFIER_NONE, 1);
d3184 1
a3184 1
      exec_tex(mach, inst, TEX_MODIFIER_LOD_BIAS, 1);
d3200 1
a3200 1
      exec_tex(mach, inst, TEX_MODIFIER_EXPLICIT_LOD, 1);
d3207 1
a3207 1
      exec_tex(mach, inst, TEX_MODIFIER_PROJECTED, 1);
d3358 1
a3358 23
      FETCH( &r[0], 0, TGSI_CHAN_X );
      /* update CondMask */
      if( ! r[0].f[0] ) {
         mach->CondMask &= ~0x1;
      }
      if( ! r[0].f[1] ) {
         mach->CondMask &= ~0x2;
      }
      if( ! r[0].f[2] ) {
         mach->CondMask &= ~0x4;
      }
      if( ! r[0].f[3] ) {
         mach->CondMask &= ~0x8;
      }
      UPDATE_EXEC_MASK(mach);
      /* Todo: If CondMask==0, jump to ELSE */
      break;

   case TGSI_OPCODE_UIF:
      /* push CondMask */
      assert(mach->CondStackTop < TGSI_EXEC_MAX_COND_NESTING);
      mach->CondStack[mach->CondStackTop++] = mach->CondMask;
      IFETCH( &r[0], 0, TGSI_CHAN_X );
d3440 1
a3440 1
      exec_vector_binary(mach, inst, micro_mod, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
d3452 1
a3452 1
      exec_txf(mach, inst);
d3456 1
a3456 1
      exec_txq(mach, inst);
d3556 1
a3556 1
      IFETCH(&r[0], 0, TGSI_CHAN_X);
d3615 1
a3615 1
      exec_vector_binary(mach, inst, micro_uadd, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
a3677 85
   case TGSI_OPCODE_SAMPLE_I:
      exec_txf(mach, inst);
      break;

   case TGSI_OPCODE_SAMPLE_I_MS:
      assert(0);
      break;

   case TGSI_OPCODE_SAMPLE:
      exec_sample(mach, inst, TEX_MODIFIER_NONE, FALSE);
      break;

   case TGSI_OPCODE_SAMPLE_B:
      exec_sample(mach, inst, TEX_MODIFIER_LOD_BIAS, FALSE);
      break;

   case TGSI_OPCODE_SAMPLE_C:
      exec_sample(mach, inst, TEX_MODIFIER_NONE, TRUE);
      break;

   case TGSI_OPCODE_SAMPLE_C_LZ:
      exec_sample(mach, inst, TEX_MODIFIER_LEVEL_ZERO, TRUE);
      break;

   case TGSI_OPCODE_SAMPLE_D:
      exec_sample_d(mach, inst);
      break;

   case TGSI_OPCODE_SAMPLE_L:
      exec_sample(mach, inst, TEX_MODIFIER_EXPLICIT_LOD, FALSE);
      break;

   case TGSI_OPCODE_GATHER4:
      assert(0);
      break;

   case TGSI_OPCODE_SVIEWINFO:
      exec_txq(mach, inst);
      break;

   case TGSI_OPCODE_SAMPLE_POS:
      assert(0);
      break;

   case TGSI_OPCODE_SAMPLE_INFO:
      assert(0);
      break;

   case TGSI_OPCODE_UARL:
      exec_vector_unary(mach, inst, micro_uarl, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_UCMP:
      exec_vector_trinary(mach, inst, micro_ucmp, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

   case TGSI_OPCODE_IABS:
      exec_vector_unary(mach, inst, micro_iabs, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_ISSG:
      exec_vector_unary(mach, inst, micro_isgn, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_TEX2:
      /* simple texture lookup */
      /* src[0] = texcoord */
      /* src[1] = compare */
      /* src[2] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_NONE, 2);
      break;
   case TGSI_OPCODE_TXB2:
      /* simple texture lookup */
      /* src[0] = texcoord */
      /* src[1] = bias */
      /* src[2] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_LOD_BIAS, 2);
      break;
   case TGSI_OPCODE_TXL2:
      /* simple texture lookup */
      /* src[0] = texcoord */
      /* src[1] = lod */
      /* src[2] = sampler unit */
      exec_tex(mach, inst, TEX_MODIFIER_EXPLICIT_LOD, 2);
      break;
d3684 3
a3695 1
   uint default_mask = 0xf;
d3697 5
a3701 2
   mach->Temps[TEMP_KILMASK_I].xyzw[TEMP_KILMASK_C].u[0] = 0;
   mach->Temps[TEMP_OUTPUT_I].xyzw[TEMP_OUTPUT_C].u[0] = 0;
d3703 1
a3703 14
   if( mach->Processor == TGSI_PROCESSOR_GEOMETRY ) {
      mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0] = 0;
      mach->Primitives[0] = 0;
      /* GS runs on a single primitive for now */
      default_mask = 0x1;
   }

   mach->CondMask = default_mask;
   mach->LoopMask = default_mask;
   mach->ContMask = default_mask;
   mach->FuncMask = default_mask;
   mach->ExecMask = default_mask;

   mach->Switch.mask = default_mask;
d3712 7
d3731 2
a3732 4
      memset(mach->Temps, 0, sizeof(temps));
      memset(mach->Outputs, 0, sizeof(outputs));
      memset(temps, 0, sizeof(temps));
      memset(outputs, 0, sizeof(outputs));
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007-2008 VMware, Inc.
d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d917 22
a938 4
      if (recip > 0.0f)
         dst->f[i] = CLAMP(recip, 5.42101e-020f, 1.84467e+019f);
      else
         dst->f[i] = CLAMP(recip, -1.84467e+019f, -5.42101e-020f);
a1612 3
   /* restrict to fragments currently executing */
   kilmask &= mach->ExecMask;

d2044 3
a2046 19
   if (inst->Instruction.Opcode == TGSI_OPCODE_SAMPLE_I) {
      unsigned char swizzles[4];
      swizzles[0] = inst->Src[1].Register.SwizzleX;
      swizzles[1] = inst->Src[1].Register.SwizzleY;
      swizzles[2] = inst->Src[1].Register.SwizzleZ;
      swizzles[3] = inst->Src[1].Register.SwizzleW;

      for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
         if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
            store_dest(mach, &r[swizzles[chan]],
                       &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
         }
      }
   }
   else {
      for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
         if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
            store_dest(mach, &r[chan], &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
         }
a2062 1
   /* XXX: This interface can't return per-pixel values */
a2089 1
   unsigned char swizzles[4];
a2195 5
   swizzles[0] = inst->Src[1].Register.SwizzleX;
   swizzles[1] = inst->Src[1].Register.SwizzleY;
   swizzles[2] = inst->Src[1].Register.SwizzleZ;
   swizzles[3] = inst->Src[1].Register.SwizzleW;

d2198 1
a2198 2
         store_dest(mach, &r[swizzles[chan]],
                    &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
a2211 1
   unsigned char swizzles[4];
a2270 5
   swizzles[0] = inst->Src[1].Register.SwizzleX;
   swizzles[1] = inst->Src[1].Register.SwizzleY;
   swizzles[2] = inst->Src[1].Register.SwizzleZ;
   swizzles[3] = inst->Src[1].Register.SwizzleW;

d2273 1
a2273 2
         store_dest(mach, &r[swizzles[chan]],
                    &inst->Dst[0], inst, chan, TGSI_EXEC_DATA_FLOAT);
a2589 34
typedef void (* micro_quaternary_op)(union tgsi_exec_channel *dst,
                                     const union tgsi_exec_channel *src0,
                                     const union tgsi_exec_channel *src1,
                                     const union tgsi_exec_channel *src2,
                                     const union tgsi_exec_channel *src3);

static void
exec_vector_quaternary(struct tgsi_exec_machine *mach,
                       const struct tgsi_full_instruction *inst,
                       micro_quaternary_op op,
                       enum tgsi_exec_datatype dst_datatype,
                       enum tgsi_exec_datatype src_datatype)
{
   unsigned int chan;
   struct tgsi_exec_vector dst;

   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         union tgsi_exec_channel src[4];

         fetch_source(mach, &src[0], &inst->Src[0], chan, src_datatype);
         fetch_source(mach, &src[1], &inst->Src[1], chan, src_datatype);
         fetch_source(mach, &src[2], &inst->Src[2], chan, src_datatype);
         fetch_source(mach, &src[3], &inst->Src[3], chan, src_datatype);
         op(&dst.xyzw[chan], &src[0], &src[1], &src[2], &src[3]);
      }
   }
   for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
      if (inst->Dst[0].Register.WriteMask & (1 << chan)) {
         store_dest(mach, &dst.xyzw[chan], &inst->Dst[0], inst, chan, dst_datatype);
      }
   }
}

d3171 4
a3174 9
   unsigned masked_count;
   masked_count = src1->u[0] & 0x1f;
   dst->u[0] = src0->u[0] << masked_count;
   masked_count = src1->u[1] & 0x1f;
   dst->u[1] = src0->u[1] << masked_count;
   masked_count = src1->u[2] & 0x1f;
   dst->u[2] = src0->u[2] << masked_count;
   masked_count = src1->u[3] & 0x1f;
   dst->u[3] = src0->u[3] << masked_count;
a3231 44
micro_fseq(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->f[0] == src1->f[0] ? ~0 : 0;
   dst->u[1] = src0->f[1] == src1->f[1] ? ~0 : 0;
   dst->u[2] = src0->f[2] == src1->f[2] ? ~0 : 0;
   dst->u[3] = src0->f[3] == src1->f[3] ? ~0 : 0;
}

static void
micro_fsge(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->f[0] >= src1->f[0] ? ~0 : 0;
   dst->u[1] = src0->f[1] >= src1->f[1] ? ~0 : 0;
   dst->u[2] = src0->f[2] >= src1->f[2] ? ~0 : 0;
   dst->u[3] = src0->f[3] >= src1->f[3] ? ~0 : 0;
}

static void
micro_fslt(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->f[0] < src1->f[0] ? ~0 : 0;
   dst->u[1] = src0->f[1] < src1->f[1] ? ~0 : 0;
   dst->u[2] = src0->f[2] < src1->f[2] ? ~0 : 0;
   dst->u[3] = src0->f[3] < src1->f[3] ? ~0 : 0;
}

static void
micro_fsne(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1)
{
   dst->u[0] = src0->f[0] != src1->f[0] ? ~0 : 0;
   dst->u[1] = src0->f[1] != src1->f[1] ? ~0 : 0;
   dst->u[2] = src0->f[2] != src1->f[2] ? ~0 : 0;
   dst->u[3] = src0->f[3] != src1->f[3] ? ~0 : 0;
}

static void
d3280 4
a3283 9
   unsigned masked_count;
   masked_count = src1->i[0] & 0x1f;
   dst->i[0] = src0->i[0] >> masked_count;
   masked_count = src1->i[1] & 0x1f;
   dst->i[1] = src0->i[1] >> masked_count;
   masked_count = src1->i[2] & 0x1f;
   dst->i[2] = src0->i[2] >> masked_count;
   masked_count = src1->i[3] & 0x1f;
   dst->i[3] = src0->i[3] >> masked_count;
a3395 26
micro_imul_hi(union tgsi_exec_channel *dst,
              const union tgsi_exec_channel *src0,
              const union tgsi_exec_channel *src1)
{
#define I64M(x, y) ((((int64_t)x) * ((int64_t)y)) >> 32)
   dst->i[0] = I64M(src0->i[0], src1->i[0]);
   dst->i[1] = I64M(src0->i[1], src1->i[1]);
   dst->i[2] = I64M(src0->i[2], src1->i[2]);
   dst->i[3] = I64M(src0->i[3], src1->i[3]);
#undef I64M
}

static void
micro_umul_hi(union tgsi_exec_channel *dst,
              const union tgsi_exec_channel *src0,
              const union tgsi_exec_channel *src1)
{
#define U64M(x, y) ((((uint64_t)x) * ((uint64_t)y)) >> 32)
   dst->u[0] = U64M(src0->u[0], src1->u[0]);
   dst->u[1] = U64M(src0->u[1], src1->u[1]);
   dst->u[2] = U64M(src0->u[2], src1->u[2]);
   dst->u[3] = U64M(src0->u[3], src1->u[3]);
#undef U64M
}

static void
d3422 4
a3425 9
   unsigned masked_count;
   masked_count = src1->u[0] & 0x1f;
   dst->u[0] = src0->u[0] >> masked_count;
   masked_count = src1->u[1] & 0x1f;
   dst->u[1] = src0->u[1] >> masked_count;
   masked_count = src1->u[2] & 0x1f;
   dst->u[2] = src0->u[2] >> masked_count;
   masked_count = src1->u[3] & 0x1f;
   dst->u[3] = src0->u[3] >> masked_count;
a3471 113
/**
 * Signed bitfield extract (i.e. sign-extend the extracted bits)
 */
static void
micro_ibfe(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1,
           const union tgsi_exec_channel *src2)
{
   int i;
   for (i = 0; i < 4; i++) {
      int width = src2->i[i] & 0x1f;
      int offset = src1->i[i] & 0x1f;
      if (width == 0)
         dst->i[i] = 0;
      else if (width + offset < 32)
         dst->i[i] = (src0->i[i] << (32 - width - offset)) >> (32 - width);
      else
         dst->i[i] = src0->i[i] >> offset;
   }
}

/**
 * Unsigned bitfield extract
 */
static void
micro_ubfe(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src0,
           const union tgsi_exec_channel *src1,
           const union tgsi_exec_channel *src2)
{
   int i;
   for (i = 0; i < 4; i++) {
      int width = src2->u[i] & 0x1f;
      int offset = src1->u[i] & 0x1f;
      if (width == 0)
         dst->u[i] = 0;
      else if (width + offset < 32)
         dst->u[i] = (src0->u[i] << (32 - width - offset)) >> (32 - width);
      else
         dst->u[i] = src0->u[i] >> offset;
   }
}

/**
 * Bitfield insert: copy low bits from src1 into a region of src0.
 */
static void
micro_bfi(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src0,
          const union tgsi_exec_channel *src1,
          const union tgsi_exec_channel *src2,
          const union tgsi_exec_channel *src3)
{
   int i;
   for (i = 0; i < 4; i++) {
      int width = src3->u[i] & 0x1f;
      int offset = src2->u[i] & 0x1f;
      int bitmask = ((1 << width) - 1) << offset;
      dst->u[i] = ((src1->u[i] << offset) & bitmask) | (src0->u[i] & ~bitmask);
   }
}

static void
micro_brev(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->u[0] = util_bitreverse(src->u[0]);
   dst->u[1] = util_bitreverse(src->u[1]);
   dst->u[2] = util_bitreverse(src->u[2]);
   dst->u[3] = util_bitreverse(src->u[3]);
}

static void
micro_popc(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->u[0] = util_bitcount(src->u[0]);
   dst->u[1] = util_bitcount(src->u[1]);
   dst->u[2] = util_bitcount(src->u[2]);
   dst->u[3] = util_bitcount(src->u[3]);
}

static void
micro_lsb(union tgsi_exec_channel *dst,
          const union tgsi_exec_channel *src)
{
   dst->i[0] = ffs(src->u[0]) - 1;
   dst->i[1] = ffs(src->u[1]) - 1;
   dst->i[2] = ffs(src->u[2]) - 1;
   dst->i[3] = ffs(src->u[3]) - 1;
}

static void
micro_imsb(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->i[0] = util_last_bit_signed(src->i[0]) - 1;
   dst->i[1] = util_last_bit_signed(src->i[1]) - 1;
   dst->i[2] = util_last_bit_signed(src->i[2]) - 1;
   dst->i[3] = util_last_bit_signed(src->i[3]) - 1;
}

static void
micro_umsb(union tgsi_exec_channel *dst,
           const union tgsi_exec_channel *src)
{
   dst->i[0] = util_last_bit(src->u[0]) - 1;
   dst->i[1] = util_last_bit(src->u[1]) - 1;
   dst->i[2] = util_last_bit(src->u[2]) - 1;
   dst->i[3] = util_last_bit(src->u[3]) - 1;
}

a4109 16
   case TGSI_OPCODE_FSEQ:
      exec_vector_binary(mach, inst, micro_fseq, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_FSGE:
      exec_vector_binary(mach, inst, micro_fsge, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_FSLT:
      exec_vector_binary(mach, inst, micro_fslt, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

   case TGSI_OPCODE_FSNE:
      exec_vector_binary(mach, inst, micro_fsne, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_FLOAT);
      break;

a4173 8
   case TGSI_OPCODE_IMUL_HI:
      exec_vector_binary(mach, inst, micro_imul_hi, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;

   case TGSI_OPCODE_UMUL_HI:
      exec_vector_binary(mach, inst, micro_umul_hi, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;

a4293 25
      break;

   case TGSI_OPCODE_IBFE:
      exec_vector_trinary(mach, inst, micro_ibfe, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;
   case TGSI_OPCODE_UBFE:
      exec_vector_trinary(mach, inst, micro_ubfe, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_BFI:
      exec_vector_quaternary(mach, inst, micro_bfi, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_BREV:
      exec_vector_unary(mach, inst, micro_brev, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_POPC:
      exec_vector_unary(mach, inst, micro_popc, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_LSB:
      exec_vector_unary(mach, inst, micro_lsb, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_UINT);
      break;
   case TGSI_OPCODE_IMSB:
      exec_vector_unary(mach, inst, micro_imsb, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
      break;
   case TGSI_OPCODE_UMSB:
      exec_vector_unary(mach, inst, micro_umsb, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_UINT);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d692 1
a692 1
                            TGSI_MAX_PRIM_VERTICES * PIPE_MAX_SHADER_INPUTS,
a791 5
         if (mach->Processor == TGSI_PROCESSOR_GEOMETRY) {
            if (parse.FullToken.FullProperty.Property.PropertyName == TGSI_PROPERTY_GS_MAX_OUTPUT_VERTICES) {
               mach->MaxOutputVertices = parse.FullToken.FullProperty.u[0].Data;
            }
         }
d826 2
a827 2
   mach->Inputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_SHADER_INPUTS, 16);
   mach->Outputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_SHADER_OUTPUTS, 16);
a1623 3
      if (mach->Primitives[mach->Temps[TEMP_PRIMITIVE_I].xyzw[TEMP_PRIMITIVE_C].u[0]] >= mach->MaxOutputVertices)
         return;

d1944 1
a1944 2
   case TGSI_TEXTURE_SHADOWCUBE:
      /* only TEXTURE_CUBE_ARRAY and TEXTURE_SHADOWCUBE actually need W */
a1998 1
   case TGSI_TEXTURE_2D_ARRAY_MSAA:
a2006 1
   case TGSI_TEXTURE_2D_MSAA:
d3335 4
a3338 4
   dst->i[0] = src1->i[0] ? src0->i[0] / src1->i[0] : 0;
   dst->i[1] = src1->i[1] ? src0->i[1] / src1->i[1] : 0;
   dst->i[2] = src1->i[2] ? src0->i[2] / src1->i[2] : 0;
   dst->i[3] = src1->i[3] ? src0->i[3] / src1->i[3] : 0;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d692 1
a692 1
                            TGSI_MAX_PRIM_VERTICES * PIPE_MAX_ATTRIBS,
d792 5
d831 2
a832 2
   mach->Inputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_ATTRIBS, 16);
   mach->Outputs = align_malloc(sizeof(struct tgsi_exec_vector) * PIPE_MAX_ATTRIBS, 16);
d1629 3
d1952 2
a1953 1
      /* only TEXTURE_CUBE_ARRAY actually needs W */
d2008 1
d2017 1
@


