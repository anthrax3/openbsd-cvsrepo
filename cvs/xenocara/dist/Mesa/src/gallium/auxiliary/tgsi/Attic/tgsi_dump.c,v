head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.27;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.43;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.37;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.45;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.31;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.38;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007-2008 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "util/u_debug.h"
#include "util/u_string.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "tgsi_dump.h"
#include "tgsi_info.h"
#include "tgsi_iterate.h"
#include "tgsi_strings.h"


/** Number of spaces to indent for IF/LOOP/etc */
static const int indent_spaces = 3;


struct dump_ctx
{
   struct tgsi_iterate_context iter;

   uint instno;
   uint immno;
   int indent;
   
   uint indentation;

   void (*dump_printf)(struct dump_ctx *ctx, const char *format, ...);
};

static void 
dump_ctx_printf(struct dump_ctx *ctx, const char *format, ...)
{
   va_list ap;
   (void)ctx;
   va_start(ap, format);
   _debug_vprintf(format, ap);
   va_end(ap);
}

static void
dump_enum(
   struct dump_ctx *ctx,
   uint e,
   const char **enums,
   uint enum_count )
{
   if (e >= enum_count)
      ctx->dump_printf( ctx, "%u", e );
   else
      ctx->dump_printf( ctx, "%s", enums[e] );
}

#define EOL()           ctx->dump_printf( ctx, "\n" )
#define TXT(S)          ctx->dump_printf( ctx, "%s", S )
#define CHR(C)          ctx->dump_printf( ctx, "%c", C )
#define UIX(I)          ctx->dump_printf( ctx, "0x%x", I )
#define UID(I)          ctx->dump_printf( ctx, "%u", I )
#define INSTID(I)       ctx->dump_printf( ctx, "% 3u", I )
#define SID(I)          ctx->dump_printf( ctx, "%d", I )
#define FLT(F)          ctx->dump_printf( ctx, "%10.4f", F )
#define ENM(E,ENUMS)    dump_enum( ctx, E, ENUMS, sizeof( ENUMS ) / sizeof( *ENUMS ) )

const char *
tgsi_swizzle_names[4] =
{
   "x",
   "y",
   "z",
   "w"
};

static void
_dump_register_src(
   struct dump_ctx *ctx,
   const struct tgsi_full_src_register *src )
{
   TXT(tgsi_file_name(src->Register.File));
   if (src->Register.Dimension) {
      if (src->Dimension.Indirect) {
         CHR( '[' );
         TXT(tgsi_file_name(src->DimIndirect.File));
         CHR( '[' );
         SID( src->DimIndirect.Index );
         TXT( "]." );
         ENM( src->DimIndirect.Swizzle, tgsi_swizzle_names );
         if (src->Dimension.Index != 0) {
            if (src->Dimension.Index > 0)
               CHR( '+' );
            SID( src->Dimension.Index );
         }
         CHR( ']' );
         if (src->DimIndirect.ArrayID) {
            CHR( '(' );
            SID( src->DimIndirect.ArrayID );
            CHR( ')' );
         }
      } else {
         CHR('[');
         SID(src->Dimension.Index);
         CHR(']');
      }
   }
   if (src->Register.Indirect) {
      CHR( '[' );
      TXT(tgsi_file_name(src->Indirect.File));
      CHR( '[' );
      SID( src->Indirect.Index );
      TXT( "]." );
      ENM( src->Indirect.Swizzle, tgsi_swizzle_names );
      if (src->Register.Index != 0) {
         if (src->Register.Index > 0)
            CHR( '+' );
         SID( src->Register.Index );
      }
      CHR( ']' );
      if (src->Indirect.ArrayID) {
         CHR( '(' );
         SID( src->Indirect.ArrayID );
         CHR( ')' );
      }
   } else {
      CHR( '[' );
      SID( src->Register.Index );
      CHR( ']' );
   }
}


static void
_dump_register_dst(
   struct dump_ctx *ctx,
   const struct tgsi_full_dst_register *dst )
{
   TXT(tgsi_file_name(dst->Register.File));
   if (dst->Register.Dimension) {
      if (dst->Dimension.Indirect) {
         CHR( '[' );
         TXT(tgsi_file_name(dst->DimIndirect.File));
         CHR( '[' );
         SID( dst->DimIndirect.Index );
         TXT( "]." );
         ENM( dst->DimIndirect.Swizzle, tgsi_swizzle_names );
         if (dst->Dimension.Index != 0) {
            if (dst->Dimension.Index > 0)
               CHR( '+' );
            SID( dst->Dimension.Index );
         }
         CHR( ']' );
         if (dst->DimIndirect.ArrayID) {
            CHR( '(' );
            SID( dst->DimIndirect.ArrayID );
            CHR( ')' );
         }
      } else {
         CHR('[');
         SID(dst->Dimension.Index);
         CHR(']');
      }
   }
   if (dst->Register.Indirect) {
      CHR( '[' );
      TXT(tgsi_file_name(dst->Indirect.File));
      CHR( '[' );
      SID( dst->Indirect.Index );
      TXT( "]." );
      ENM( dst->Indirect.Swizzle, tgsi_swizzle_names );
      if (dst->Register.Index != 0) {
         if (dst->Register.Index > 0)
            CHR( '+' );
         SID( dst->Register.Index );
      }
      CHR( ']' );
      if (dst->Indirect.ArrayID) {
         CHR( '(' );
         SID( dst->Indirect.ArrayID );
         CHR( ')' );
      }
   } else {
      CHR( '[' );
      SID( dst->Register.Index );
      CHR( ']' );
   }
}
static void
_dump_writemask(
   struct dump_ctx *ctx,
   uint writemask )
{
   if (writemask != TGSI_WRITEMASK_XYZW) {
      CHR( '.' );
      if (writemask & TGSI_WRITEMASK_X)
         CHR( 'x' );
      if (writemask & TGSI_WRITEMASK_Y)
         CHR( 'y' );
      if (writemask & TGSI_WRITEMASK_Z)
         CHR( 'z' );
      if (writemask & TGSI_WRITEMASK_W)
         CHR( 'w' );
   }
}

static void
dump_imm_data(struct tgsi_iterate_context *iter,
              union tgsi_immediate_data *data,
              unsigned num_tokens,
              unsigned data_type)
{
   struct dump_ctx *ctx = (struct dump_ctx *)iter;
   unsigned i ;

   TXT( " {" );

   assert( num_tokens <= 4 );
   for (i = 0; i < num_tokens; i++) {
      switch (data_type) {
      case TGSI_IMM_FLOAT32:
         FLT( data[i].Float );
         break;
      case TGSI_IMM_UINT32:
         UID(data[i].Uint);
         break;
      case TGSI_IMM_INT32:
         SID(data[i].Int);
         break;
      default:
         assert( 0 );
      }

      if (i < num_tokens - 1)
         TXT( ", " );
   }
   TXT( "}" );
}

static boolean
iter_declaration(
   struct tgsi_iterate_context *iter,
   struct tgsi_full_declaration *decl )
{
   struct dump_ctx *ctx = (struct dump_ctx *)iter;

   TXT( "DCL " );

   TXT(tgsi_file_name(decl->Declaration.File));

   /* all geometry shader inputs are two dimensional */
   if (decl->Declaration.File == TGSI_FILE_INPUT &&
       iter->processor.Processor == TGSI_PROCESSOR_GEOMETRY) {
      TXT("[]");
   }

   if (decl->Declaration.Dimension) {
      CHR('[');
      SID(decl->Dim.Index2D);
      CHR(']');
   }

   CHR('[');
   SID(decl->Range.First);
   if (decl->Range.First != decl->Range.Last) {
      TXT("..");
      SID(decl->Range.Last);
   }
   CHR(']');

   _dump_writemask(
      ctx,
      decl->Declaration.UsageMask );

   if (decl->Declaration.Array) {
      TXT( ", ARRAY(" );
      SID(decl->Array.ArrayID);
      CHR(')');
   }

   if (decl->Declaration.Local)
      TXT( ", LOCAL" );

   if (decl->Declaration.Semantic) {
      TXT( ", " );
      ENM( decl->Semantic.Name, tgsi_semantic_names );
      if (decl->Semantic.Index != 0 ||
          decl->Semantic.Name == TGSI_SEMANTIC_TEXCOORD ||
          decl->Semantic.Name == TGSI_SEMANTIC_GENERIC) {
         CHR( '[' );
         UID( decl->Semantic.Index );
         CHR( ']' );
      }
   }

   if (decl->Declaration.File == TGSI_FILE_RESOURCE) {
      TXT(", ");
      ENM(decl->Resource.Resource, tgsi_texture_names);
      if (decl->Resource.Writable)
         TXT(", WR");
      if (decl->Resource.Raw)
         TXT(", RAW");
   }

   if (decl->Declaration.File == TGSI_FILE_SAMPLER_VIEW) {
      TXT(", ");
      ENM(decl->SamplerView.Resource, tgsi_texture_names);
      TXT(", ");
      if ((decl->SamplerView.ReturnTypeX == decl->SamplerView.ReturnTypeY) &&
          (decl->SamplerView.ReturnTypeX == decl->SamplerView.ReturnTypeZ) &&
          (decl->SamplerView.ReturnTypeX == decl->SamplerView.ReturnTypeW)) {
         ENM(decl->SamplerView.ReturnTypeX, tgsi_type_names);
      } else {
         ENM(decl->SamplerView.ReturnTypeX, tgsi_type_names);
         TXT(", ");
         ENM(decl->SamplerView.ReturnTypeY, tgsi_type_names);
         TXT(", ");
         ENM(decl->SamplerView.ReturnTypeZ, tgsi_type_names);
         TXT(", ");
         ENM(decl->SamplerView.ReturnTypeW, tgsi_type_names);
      }
   }

   if (decl->Declaration.Interpolate) {
      if (iter->processor.Processor == TGSI_PROCESSOR_FRAGMENT &&
          decl->Declaration.File == TGSI_FILE_INPUT)
      {
         TXT( ", " );
         ENM( decl->Interp.Interpolate, tgsi_interpolate_names );
      }

      if (decl->Interp.Centroid) {
         TXT( ", CENTROID" );
      }

      if (decl->Interp.CylindricalWrap) {
         TXT(", CYLWRAP_");
         if (decl->Interp.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_X) {
            CHR('X');
         }
         if (decl->Interp.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_Y) {
            CHR('Y');
         }
         if (decl->Interp.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_Z) {
            CHR('Z');
         }
         if (decl->Interp.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_W) {
            CHR('W');
         }
      }
   }

   if (decl->Declaration.Invariant) {
      TXT( ", INVARIANT" );
   }

   EOL();

   return TRUE;
}

void
tgsi_dump_declaration(
   const struct tgsi_full_declaration *decl )
{
   struct dump_ctx ctx;

   ctx.dump_printf = dump_ctx_printf;

   iter_declaration( &ctx.iter, (struct tgsi_full_declaration *)decl );
}

static boolean
iter_property(
   struct tgsi_iterate_context *iter,
   struct tgsi_full_property *prop )
{
   unsigned i;
   struct dump_ctx *ctx = (struct dump_ctx *)iter;

   TXT( "PROPERTY " );
   ENM(prop->Property.PropertyName, tgsi_property_names);

   if (prop->Property.NrTokens > 1)
      TXT(" ");

   for (i = 0; i < prop->Property.NrTokens - 1; ++i) {
      switch (prop->Property.PropertyName) {
      case TGSI_PROPERTY_GS_INPUT_PRIM:
      case TGSI_PROPERTY_GS_OUTPUT_PRIM:
         ENM(prop->u[i].Data, tgsi_primitive_names);
         break;
      case TGSI_PROPERTY_FS_COORD_ORIGIN:
         ENM(prop->u[i].Data, tgsi_fs_coord_origin_names);
         break;
      case TGSI_PROPERTY_FS_COORD_PIXEL_CENTER:
         ENM(prop->u[i].Data, tgsi_fs_coord_pixel_center_names);
         break;
      default:
         SID( prop->u[i].Data );
         break;
      }
      if (i < prop->Property.NrTokens - 2)
         TXT( ", " );
   }
   EOL();

   return TRUE;
}

void tgsi_dump_property(
   const struct tgsi_full_property *prop )
{
   struct dump_ctx ctx;

   ctx.dump_printf = dump_ctx_printf;

   iter_property( &ctx.iter, (struct tgsi_full_property *)prop );
}

static boolean
iter_immediate(
   struct tgsi_iterate_context *iter,
   struct tgsi_full_immediate *imm )
{
   struct dump_ctx *ctx = (struct dump_ctx *) iter;

   TXT( "IMM[" );
   SID( ctx->immno++ );
   TXT( "] " );
   ENM( imm->Immediate.DataType, tgsi_immediate_type_names );

   dump_imm_data(iter, imm->u, imm->Immediate.NrTokens - 1,
                 imm->Immediate.DataType);

   EOL();

   return TRUE;
}

void
tgsi_dump_immediate(
   const struct tgsi_full_immediate *imm )
{
   struct dump_ctx ctx;

   ctx.dump_printf = dump_ctx_printf;

   iter_immediate( &ctx.iter, (struct tgsi_full_immediate *)imm );
}

static boolean
iter_instruction(
   struct tgsi_iterate_context *iter,
   struct tgsi_full_instruction *inst )
{
   struct dump_ctx *ctx = (struct dump_ctx *) iter;
   uint instno = ctx->instno++;
   const struct tgsi_opcode_info *info = tgsi_get_opcode_info( inst->Instruction.Opcode );
   uint i;
   boolean first_reg = TRUE;

   INSTID( instno );
   TXT( ": " );

   ctx->indent -= info->pre_dedent;
   for(i = 0; (int)i < ctx->indent; ++i)
      TXT( "  " );
   ctx->indent += info->post_indent;

   if (inst->Instruction.Predicate) {
      CHR( '(' );

      if (inst->Predicate.Negate)
         CHR( '!' );

      TXT( "PRED[" );
      SID( inst->Predicate.Index );
      CHR( ']' );

      if (inst->Predicate.SwizzleX != TGSI_SWIZZLE_X ||
          inst->Predicate.SwizzleY != TGSI_SWIZZLE_Y ||
          inst->Predicate.SwizzleZ != TGSI_SWIZZLE_Z ||
          inst->Predicate.SwizzleW != TGSI_SWIZZLE_W) {
         CHR( '.' );
         ENM( inst->Predicate.SwizzleX, tgsi_swizzle_names );
         ENM( inst->Predicate.SwizzleY, tgsi_swizzle_names );
         ENM( inst->Predicate.SwizzleZ, tgsi_swizzle_names );
         ENM( inst->Predicate.SwizzleW, tgsi_swizzle_names );
      }

      TXT( ") " );
   }

   TXT( info->mnemonic );

   switch (inst->Instruction.Saturate) {
   case TGSI_SAT_NONE:
      break;
   case TGSI_SAT_ZERO_ONE:
      TXT( "_SAT" );
      break;
   case TGSI_SAT_MINUS_PLUS_ONE:
      TXT( "_SATNV" );
      break;
   default:
      assert( 0 );
   }

   for (i = 0; i < inst->Instruction.NumDstRegs; i++) {
      const struct tgsi_full_dst_register *dst = &inst->Dst[i];

      if (!first_reg)
         CHR( ',' );
      CHR( ' ' );

      _dump_register_dst( ctx, dst );
      _dump_writemask( ctx, dst->Register.WriteMask );

      first_reg = FALSE;
   }

   for (i = 0; i < inst->Instruction.NumSrcRegs; i++) {
      const struct tgsi_full_src_register *src = &inst->Src[i];

      if (!first_reg)
         CHR( ',' );
      CHR( ' ' );

      if (src->Register.Negate)
         CHR( '-' );
      if (src->Register.Absolute)
         CHR( '|' );

      _dump_register_src(ctx, src);

      if (src->Register.SwizzleX != TGSI_SWIZZLE_X ||
          src->Register.SwizzleY != TGSI_SWIZZLE_Y ||
          src->Register.SwizzleZ != TGSI_SWIZZLE_Z ||
          src->Register.SwizzleW != TGSI_SWIZZLE_W) {
         CHR( '.' );
         ENM( src->Register.SwizzleX, tgsi_swizzle_names );
         ENM( src->Register.SwizzleY, tgsi_swizzle_names );
         ENM( src->Register.SwizzleZ, tgsi_swizzle_names );
         ENM( src->Register.SwizzleW, tgsi_swizzle_names );
      }

      if (src->Register.Absolute)
         CHR( '|' );

      first_reg = FALSE;
   }

   if (inst->Instruction.Texture) {
      TXT( ", " );
      ENM( inst->Texture.Texture, tgsi_texture_names );
      for (i = 0; i < inst->Texture.NumOffsets; i++) {
         TXT( ", " );
         TXT(tgsi_file_name(inst->TexOffsets[i].File));
         CHR( '[' );
         SID( inst->TexOffsets[i].Index );
         CHR( ']' );
         CHR( '.' );
         ENM( inst->TexOffsets[i].SwizzleX, tgsi_swizzle_names);
         ENM( inst->TexOffsets[i].SwizzleY, tgsi_swizzle_names);
         ENM( inst->TexOffsets[i].SwizzleZ, tgsi_swizzle_names);
      }
   }

   switch (inst->Instruction.Opcode) {
   case TGSI_OPCODE_IF:
   case TGSI_OPCODE_UIF:
   case TGSI_OPCODE_ELSE:
   case TGSI_OPCODE_BGNLOOP:
   case TGSI_OPCODE_ENDLOOP:
   case TGSI_OPCODE_CAL:
      TXT( " :" );
      UID( inst->Label.Label );
      break;
   }

   /* update indentation */
   if (inst->Instruction.Opcode == TGSI_OPCODE_IF ||
       inst->Instruction.Opcode == TGSI_OPCODE_UIF ||
       inst->Instruction.Opcode == TGSI_OPCODE_ELSE ||
       inst->Instruction.Opcode == TGSI_OPCODE_BGNLOOP) {
      ctx->indentation += indent_spaces;
   }

   EOL();

   return TRUE;
}

void
tgsi_dump_instruction(
   const struct tgsi_full_instruction *inst,
   uint instno )
{
   struct dump_ctx ctx;

   ctx.instno = instno;
   ctx.immno = instno;
   ctx.indent = 0;
   ctx.dump_printf = dump_ctx_printf;
   ctx.indentation = 0;

   iter_instruction( &ctx.iter, (struct tgsi_full_instruction *)inst );
}

static boolean
prolog(
   struct tgsi_iterate_context *iter )
{
   struct dump_ctx *ctx = (struct dump_ctx *) iter;
   ENM( iter->processor.Processor, tgsi_processor_type_names );
   EOL();
   return TRUE;
}

void
tgsi_dump(
   const struct tgsi_token *tokens,
   uint flags )
{
   struct dump_ctx ctx;

   ctx.iter.prolog = prolog;
   ctx.iter.iterate_instruction = iter_instruction;
   ctx.iter.iterate_declaration = iter_declaration;
   ctx.iter.iterate_immediate = iter_immediate;
   ctx.iter.iterate_property = iter_property;
   ctx.iter.epilog = NULL;

   ctx.instno = 0;
   ctx.immno = 0;
   ctx.indent = 0;
   ctx.dump_printf = dump_ctx_printf;
   ctx.indentation = 0;

   tgsi_iterate_shader( tokens, &ctx.iter );
}

struct str_dump_ctx
{
   struct dump_ctx base;
   char *str;
   char *ptr;
   int left;
};

static void
str_dump_ctx_printf(struct dump_ctx *ctx, const char *format, ...)
{
   struct str_dump_ctx *sctx = (struct str_dump_ctx *)ctx;
   
   if(sctx->left > 1) {
      int written;
      va_list ap;
      va_start(ap, format);
      written = util_vsnprintf(sctx->ptr, sctx->left, format, ap);
      va_end(ap);

      /* Some complicated logic needed to handle the return value of
       * vsnprintf:
       */
      if (written > 0) {
         written = MIN2(sctx->left, written);
         sctx->ptr += written;
         sctx->left -= written;
      }
   }
}

void
tgsi_dump_str(
   const struct tgsi_token *tokens,
   uint flags,
   char *str,
   size_t size)
{
   struct str_dump_ctx ctx;

   ctx.base.iter.prolog = prolog;
   ctx.base.iter.iterate_instruction = iter_instruction;
   ctx.base.iter.iterate_declaration = iter_declaration;
   ctx.base.iter.iterate_immediate = iter_immediate;
   ctx.base.iter.iterate_property = iter_property;
   ctx.base.iter.epilog = NULL;

   ctx.base.instno = 0;
   ctx.base.immno = 0;
   ctx.base.indent = 0;
   ctx.base.dump_printf = &str_dump_ctx_printf;
   ctx.base.indentation = 0;

   ctx.str = str;
   ctx.str[0] = 0;
   ctx.ptr = str;
   ctx.left = (int)size;

   tgsi_iterate_shader( tokens, &ctx.base.iter );
}

void
tgsi_dump_instruction_str(
   const struct tgsi_full_instruction *inst,
   uint instno,
   char *str,
   size_t size)
{
   struct str_dump_ctx ctx;

   ctx.base.instno = instno;
   ctx.base.immno = instno;
   ctx.base.indent = 0;
   ctx.base.dump_printf = &str_dump_ctx_printf;
   ctx.base.indentation = 0;

   ctx.str = str;
   ctx.str[0] = 0;
   ctx.ptr = str;
   ctx.left = (int)size;

   iter_instruction( &ctx.base.iter, (struct tgsi_full_instruction *)inst );
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d332 1
a332 1
         ENM(decl->SamplerView.ReturnTypeX, tgsi_return_type_names);
d334 1
a334 1
         ENM(decl->SamplerView.ReturnTypeX, tgsi_return_type_names);
d336 1
a336 1
         ENM(decl->SamplerView.ReturnTypeY, tgsi_return_type_names);
d338 1
a338 1
         ENM(decl->SamplerView.ReturnTypeZ, tgsi_return_type_names);
d340 1
a340 1
         ENM(decl->SamplerView.ReturnTypeW, tgsi_return_type_names);
d352 2
a353 3
      if (decl->Interp.Location != TGSI_INTERPOLATE_LOC_CENTER) {
         TXT( ", " );
         ENM( decl->Interp.Location, tgsi_interpolate_locations );
d575 2
a576 5
      if (!(inst->Instruction.Opcode >= TGSI_OPCODE_SAMPLE &&
            inst->Instruction.Opcode <= TGSI_OPCODE_GATHER4)) {
         TXT( ", " );
         ENM( inst->Texture.Texture, tgsi_texture_names );
      }
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d332 1
a332 1
         ENM(decl->SamplerView.ReturnTypeX, tgsi_type_names);
d334 1
a334 1
         ENM(decl->SamplerView.ReturnTypeX, tgsi_type_names);
d336 1
a336 1
         ENM(decl->SamplerView.ReturnTypeY, tgsi_type_names);
d338 1
a338 1
         ENM(decl->SamplerView.ReturnTypeZ, tgsi_type_names);
d340 1
a340 1
         ENM(decl->SamplerView.ReturnTypeW, tgsi_type_names);
d352 3
a354 2
      if (decl->Interp.Centroid) {
         TXT( ", CENTROID" );
d576 5
a580 2
      TXT( ", " );
      ENM( inst->Texture.Texture, tgsi_texture_names );
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007-2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d723 23
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d35 1
d47 1
d52 1
a52 1
   void (*printf)(struct dump_ctx *ctx, const char *format, ...);
d73 1
a73 1
      ctx->printf( ctx, "%u", e );
d75 1
a75 1
      ctx->printf( ctx, "%s", enums[e] );
d78 8
a85 8
#define EOL()           ctx->printf( ctx, "\n" )
#define TXT(S)          ctx->printf( ctx, "%s", S )
#define CHR(C)          ctx->printf( ctx, "%c", C )
#define UIX(I)          ctx->printf( ctx, "0x%x", I )
#define UID(I)          ctx->printf( ctx, "%u", I )
#define INSTID(I)          ctx->printf( ctx, "% 3u", I )
#define SID(I)          ctx->printf( ctx, "%d", I )
#define FLT(F)          ctx->printf( ctx, "%10.4f", F )
a87 55
static const char *processor_type_names[] =
{
   "FRAG",
   "VERT",
   "GEOM"
};

const char *
tgsi_file_names[TGSI_FILE_COUNT] =
{
   "NULL",
   "CONST",
   "IN",
   "OUT",
   "TEMP",
   "SAMP",
   "ADDR",
   "IMM",
   "PRED",
   "SV",
   "IMMX",
   "TEMPX",
   "RES"
};

static const char *interpolate_names[] =
{
   "CONSTANT",
   "LINEAR",
   "PERSPECTIVE"
};

static const char *semantic_names[] =
{
   "POSITION",
   "COLOR",
   "BCOLOR",
   "FOG",
   "PSIZE",
   "GENERIC",
   "NORMAL",
   "FACE",
   "EDGEFLAG",
   "PRIM_ID",
   "INSTANCEID",
   "STENCIL"
};

static const char *immediate_type_names[] =
{
   "FLT32",
   "UINT32",
   "INT32"
};

a96 66
const char *
tgsi_texture_names[TGSI_TEXTURE_COUNT] =
{
   "UNKNOWN",
   "1D",
   "2D",
   "3D",
   "CUBE",
   "RECT",
   "SHADOW1D",
   "SHADOW2D",
   "SHADOWRECT",
   "1DARRAY",
   "2DARRAY"
};

const char *tgsi_property_names[TGSI_PROPERTY_COUNT] =
{
   "GS_INPUT_PRIMITIVE",
   "GS_OUTPUT_PRIMITIVE",
   "GS_MAX_OUTPUT_VERTICES",
   "FS_COORD_ORIGIN",
   "FS_COORD_PIXEL_CENTER",
   "FS_COLOR0_WRITES_ALL_CBUFS",
};

static const char *tgsi_type_names[] =
{
   "UNORM",
   "SNORM",
   "SINT",
   "UINT",
   "FLOAT"
};

const char *tgsi_primitive_names[PIPE_PRIM_MAX] =
{
   "POINTS",
   "LINES",
   "LINE_LOOP",
   "LINE_STRIP",
   "TRIANGLES",
   "TRIANGLE_STRIP",
   "TRIANGLE_FAN",
   "QUADS",
   "QUAD_STRIP",
   "POLYGON",
   "LINES_ADJACENCY",
   "LINE_STRIP_ADJACENCY",
   "TRIANGLES_ADJACENCY",
   "TRIANGLE_STRIP_ADJACENCY"
};

const char *tgsi_fs_coord_origin_names[2] =
{
   "UPPER_LEFT",
   "LOWER_LEFT"
};

const char *tgsi_fs_coord_pixel_center_names[2] =
{
   "HALF_INTEGER",
   "INTEGER"
};


d102 1
a102 1
   ENM(src->Register.File, tgsi_file_names);
d106 1
a106 1
         ENM( src->DimIndirect.File, tgsi_file_names );
d110 1
a110 1
         ENM( src->DimIndirect.SwizzleX, tgsi_swizzle_names );
d117 5
d130 1
a130 1
      ENM( src->Indirect.File, tgsi_file_names );
d134 1
a134 1
      ENM( src->Indirect.SwizzleX, tgsi_swizzle_names );
d141 5
d159 1
a159 1
   ENM(dst->Register.File, tgsi_file_names);
d163 1
a163 1
         ENM( dst->DimIndirect.File, tgsi_file_names );
d167 1
a167 1
         ENM( dst->DimIndirect.SwizzleX, tgsi_swizzle_names );
d174 5
d187 1
a187 1
      ENM( dst->Indirect.File, tgsi_file_names );
d191 1
a191 1
      ENM( dst->Indirect.SwizzleX, tgsi_swizzle_names );
d198 5
a266 3
   assert(Elements(semantic_names) == TGSI_SEMANTIC_COUNT);
   assert(Elements(interpolate_names) == TGSI_INTERPOLATE_COUNT);

d269 1
a269 1
   ENM(decl->Declaration.File, tgsi_file_names);
d295 9
d306 1
a306 1
      ENM( decl->Semantic.Name, semantic_names );
d308 1
d319 9
d329 4
a332 4
      if ((decl->Resource.ReturnTypeX == decl->Resource.ReturnTypeY) &&
          (decl->Resource.ReturnTypeX == decl->Resource.ReturnTypeZ) &&
          (decl->Resource.ReturnTypeX == decl->Resource.ReturnTypeW)) {
         ENM(decl->Resource.ReturnTypeX, tgsi_type_names);
d334 1
a334 1
         ENM(decl->Resource.ReturnTypeX, tgsi_type_names);
d336 1
a336 1
         ENM(decl->Resource.ReturnTypeY, tgsi_type_names);
d338 1
a338 1
         ENM(decl->Resource.ReturnTypeZ, tgsi_type_names);
d340 1
a340 1
         ENM(decl->Resource.ReturnTypeW, tgsi_type_names);
d342 1
d344 7
a350 1
   }
d352 3
a354 6
   if (iter->processor.Processor == TGSI_PROCESSOR_FRAGMENT &&
       decl->Declaration.File == TGSI_FILE_INPUT)
   {
      TXT( ", " );
      ENM( decl->Declaration.Interpolate, interpolate_names );
   }
d356 15
a370 2
   if (decl->Declaration.Centroid) {
      TXT( ", CENTROID" );
a376 53
   if (decl->Declaration.CylindricalWrap) {
      TXT(", CYLWRAP_");
      if (decl->Declaration.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_X) {
         CHR('X');
      }
      if (decl->Declaration.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_Y) {
         CHR('Y');
      }
      if (decl->Declaration.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_Z) {
         CHR('Z');
      }
      if (decl->Declaration.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_W) {
         CHR('W');
      }
   }

   if (decl->Declaration.File == TGSI_FILE_IMMEDIATE_ARRAY) {
      unsigned i;
      char range_indent[4];

      TXT(" {");

      if (decl->Range.Last < 10)
         range_indent[0] = '\0';
      else if (decl->Range.Last < 100) {
         range_indent[0] = ' ';
         range_indent[1] = '\0';
      } else if (decl->Range.Last < 1000) {
         range_indent[0] = ' ';
         range_indent[1] = ' ';
         range_indent[2] = '\0';
      } else {
         range_indent[0] = ' ';
         range_indent[1] = ' ';
         range_indent[2] = ' ';
         range_indent[3] = '\0';
      }

      dump_imm_data(iter, decl->ImmediateData.u,
                    4, TGSI_IMM_FLOAT32);
      for(i = 1; i <= decl->Range.Last; ++i) {
         /* indent by strlen of:
          *   "DCL IMMX[0..1] {" */
         CHR('\n');
         TXT( "                " );
         TXT( range_indent );
         dump_imm_data(iter, decl->ImmediateData.u + i,
                       4, TGSI_IMM_FLOAT32);
      }

      TXT(" }");
   }

d388 1
a388 1
   ctx.printf = dump_ctx_printf;
d398 1
a398 1
   int i;
a400 2
   assert(Elements(tgsi_property_names) == TGSI_PROPERTY_COUNT);

d436 1
a436 1
   ctx.printf = dump_ctx_printf;
d448 4
a451 2
   TXT( "IMM " );
   ENM( imm->Immediate.DataType, immediate_type_names );
d467 1
a467 1
   ctx.printf = dump_ctx_printf;
d577 11
d592 1
d604 1
d623 1
d625 1
a625 1
   ctx.printf = dump_ctx_printf;
d636 1
a636 1
   ENM( iter->processor.Processor, processor_type_names );
d656 1
d658 1
a658 1
   ctx.printf = dump_ctx_printf;
d712 1
d714 1
a714 1
   ctx.base.printf = &str_dump_ctx_printf;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d107 2
a108 1
   "TEMPX"
d142 1
a142 1
tgsi_swizzle_names[] =
d151 1
a151 1
tgsi_texture_names[] =
d161 3
a163 1
   "SHADOWRECT"
d166 1
a166 1
static const char *property_names[] =
d172 2
a173 1
   "FS_COORD_PIXEL_CENTER"
d176 10
a185 1
static const char *primitive_names[] =
d203 1
a203 1
static const char *fs_coord_origin_names[] =
d209 1
a209 1
static const char *fs_coord_pixel_center_names[] =
d408 20
d520 1
a520 1
   assert(Elements(property_names) == TGSI_PROPERTY_COUNT);
d523 1
a523 1
   ENM(prop->Property.PropertyName, property_names);
d532 1
a532 1
         ENM(prop->u[i].Data, primitive_names);
d535 1
a535 1
         ENM(prop->u[i].Data, fs_coord_origin_names);
d538 1
a538 1
         ENM(prop->u[i].Data, fs_coord_pixel_center_names);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d59 1
a59 1
   debug_vprintf(format, ap);
d93 2
a94 1
static const char *file_names[TGSI_FILE_COUNT] =
a103 1
   "LOOP",
d105 3
a107 1
   "SV"
d129 2
a130 1
   "INSTANCEID"
d140 2
a141 1
static const char *swizzle_names[] =
d149 2
a150 1
static const char *texture_names[] =
d183 5
a187 1
   "POLYGON"
a203 14
_dump_register_dst(
   struct dump_ctx *ctx,
   uint file,
   int index)
{
   ENM( file, file_names );

   CHR( '[' );
   SID( index );
   CHR( ']' );
}


static void
d208 1
a208 1
   ENM(src->Register.File, file_names);
d210 18
a227 3
      CHR('[');
      SID(src->Dimension.Index);
      CHR(']');
d231 1
a231 1
      ENM( src->Indirect.File, file_names );
d235 1
a235 1
      ENM( src->Indirect.SwizzleX, swizzle_names );
d249 1
d251 1
a251 1
_dump_register_ind(
d253 40
a292 17
   uint file,
   int index,
   uint ind_file,
   int ind_index,
   uint ind_swizzle )
{
   ENM( file, file_names );
   CHR( '[' );
   ENM( ind_file, file_names );
   CHR( '[' );
   SID( ind_index );
   TXT( "]." );
   ENM( ind_swizzle, swizzle_names );
   if (index != 0) {
      if (index > 0)
         CHR( '+' );
      SID( index );
a293 1
   CHR( ']' );
a294 1

d313 33
d358 1
a358 1
   ENM(decl->Declaration.File, file_names);
d426 37
a535 2
   uint i;

d539 2
a540 22
   TXT( " { " );

   assert( imm->Immediate.NrTokens <= 4 + 1 );
   for (i = 0; i < imm->Immediate.NrTokens - 1; i++) {
      switch (imm->Immediate.DataType) {
      case TGSI_IMM_FLOAT32:
         FLT( imm->u[i].Float );
         break;
      case TGSI_IMM_UINT32:
         UID(imm->u[i].Uint);
         break;
      case TGSI_IMM_INT32:
         SID(imm->u[i].Int);
         break;
      default:
         assert( 0 );
      }

      if (i < imm->Immediate.NrTokens - 2)
         TXT( ", " );
   }
   TXT( " }" );
d571 1
a571 1
   
d576 25
a600 1
   
d623 1
a623 15
      if (dst->Register.Indirect) {
         _dump_register_ind(
            ctx,
            dst->Register.File,
            dst->Register.Index,
            dst->Indirect.File,
            dst->Indirect.Index,
            dst->Indirect.SwizzleX );
      }
      else {
         _dump_register_dst(
            ctx,
            dst->Register.File,
            dst->Register.Index );
      }
d648 4
a651 4
         ENM( src->Register.SwizzleX, swizzle_names );
         ENM( src->Register.SwizzleY, swizzle_names );
         ENM( src->Register.SwizzleZ, swizzle_names );
         ENM( src->Register.SwizzleW, swizzle_names );
d662 1
a662 1
      ENM( inst->Texture.Texture, texture_names );
a678 1
       inst->Instruction.Opcode == TGSI_OPCODE_BGNFOR ||
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d59 1
a59 1
   _debug_vprintf(format, ap);
d93 1
a93 2
const char *
tgsi_file_names[TGSI_FILE_COUNT] =
d103 1
d105 1
a105 3
   "SV",
   "IMMX",
   "TEMPX"
d127 1
a127 2
   "INSTANCEID",
   "STENCIL"
d137 1
a137 2
const char *
tgsi_swizzle_names[] =
d145 1
a145 2
const char *
tgsi_texture_names[] =
d178 1
a178 5
   "POLYGON",
   "LINES_ADJACENCY",
   "LINE_STRIP_ADJACENCY",
   "TRIANGLES_ADJACENCY",
   "TRIANGLE_STRIP_ADJACENCY"
d195 14
d213 1
a213 1
   ENM(src->Register.File, tgsi_file_names);
d215 3
a217 18
      if (src->Dimension.Indirect) {
         CHR( '[' );
         ENM( src->DimIndirect.File, tgsi_file_names );
         CHR( '[' );
         SID( src->DimIndirect.Index );
         TXT( "]." );
         ENM( src->DimIndirect.SwizzleX, tgsi_swizzle_names );
         if (src->Dimension.Index != 0) {
            if (src->Dimension.Index > 0)
               CHR( '+' );
            SID( src->Dimension.Index );
         }
         CHR( ']' );
      } else {
         CHR('[');
         SID(src->Dimension.Index);
         CHR(']');
      }
d221 1
a221 1
      ENM( src->Indirect.File, tgsi_file_names );
d225 1
a225 1
      ENM( src->Indirect.SwizzleX, tgsi_swizzle_names );
a238 1

d240 1
a240 1
_dump_register_dst(
d242 17
a258 40
   const struct tgsi_full_dst_register *dst )
{
   ENM(dst->Register.File, tgsi_file_names);
   if (dst->Register.Dimension) {
      if (dst->Dimension.Indirect) {
         CHR( '[' );
         ENM( dst->DimIndirect.File, tgsi_file_names );
         CHR( '[' );
         SID( dst->DimIndirect.Index );
         TXT( "]." );
         ENM( dst->DimIndirect.SwizzleX, tgsi_swizzle_names );
         if (dst->Dimension.Index != 0) {
            if (dst->Dimension.Index > 0)
               CHR( '+' );
            SID( dst->Dimension.Index );
         }
         CHR( ']' );
      } else {
         CHR('[');
         SID(dst->Dimension.Index);
         CHR(']');
      }
   }
   if (dst->Register.Indirect) {
      CHR( '[' );
      ENM( dst->Indirect.File, tgsi_file_names );
      CHR( '[' );
      SID( dst->Indirect.Index );
      TXT( "]." );
      ENM( dst->Indirect.SwizzleX, tgsi_swizzle_names );
      if (dst->Register.Index != 0) {
         if (dst->Register.Index > 0)
            CHR( '+' );
         SID( dst->Register.Index );
      }
      CHR( ']' );
   } else {
      CHR( '[' );
      SID( dst->Register.Index );
      CHR( ']' );
d260 1
d262 1
a280 33
static void
dump_imm_data(struct tgsi_iterate_context *iter,
              union tgsi_immediate_data *data,
              unsigned num_tokens,
              unsigned data_type)
{
   struct dump_ctx *ctx = (struct dump_ctx *)iter;
   unsigned i ;

   TXT( " {" );

   assert( num_tokens <= 4 );
   for (i = 0; i < num_tokens; i++) {
      switch (data_type) {
      case TGSI_IMM_FLOAT32:
         FLT( data[i].Float );
         break;
      case TGSI_IMM_UINT32:
         UID(data[i].Uint);
         break;
      case TGSI_IMM_INT32:
         SID(data[i].Int);
         break;
      default:
         assert( 0 );
      }

      if (i < num_tokens - 1)
         TXT( ", " );
   }
   TXT( "}" );
}

d293 1
a293 1
   ENM(decl->Declaration.File, tgsi_file_names);
a360 37
   if (decl->Declaration.File == TGSI_FILE_IMMEDIATE_ARRAY) {
      unsigned i;
      char range_indent[4];

      TXT(" {");

      if (decl->Range.Last < 10)
         range_indent[0] = '\0';
      else if (decl->Range.Last < 100) {
         range_indent[0] = ' ';
         range_indent[1] = '\0';
      } else if (decl->Range.Last < 1000) {
         range_indent[0] = ' ';
         range_indent[1] = ' ';
         range_indent[2] = '\0';
      } else {
         range_indent[0] = ' ';
         range_indent[1] = ' ';
         range_indent[2] = ' ';
         range_indent[3] = '\0';
      }

      dump_imm_data(iter, decl->ImmediateData.u,
                    4, TGSI_IMM_FLOAT32);
      for(i = 1; i <= decl->Range.Last; ++i) {
         /* indent by strlen of:
          *   "DCL IMMX[0..1] {" */
         CHR('\n');
         TXT( "                " );
         TXT( range_indent );
         dump_imm_data(iter, decl->ImmediateData.u + i,
                       4, TGSI_IMM_FLOAT32);
      }

      TXT(" }");
   }

d434 2
d439 22
a460 2
   dump_imm_data(iter, imm->u, imm->Immediate.NrTokens - 1,
                 imm->Immediate.DataType);
d491 1
a491 1

d496 1
a496 25

   if (inst->Instruction.Predicate) {
      CHR( '(' );

      if (inst->Predicate.Negate)
         CHR( '!' );

      TXT( "PRED[" );
      SID( inst->Predicate.Index );
      CHR( ']' );

      if (inst->Predicate.SwizzleX != TGSI_SWIZZLE_X ||
          inst->Predicate.SwizzleY != TGSI_SWIZZLE_Y ||
          inst->Predicate.SwizzleZ != TGSI_SWIZZLE_Z ||
          inst->Predicate.SwizzleW != TGSI_SWIZZLE_W) {
         CHR( '.' );
         ENM( inst->Predicate.SwizzleX, tgsi_swizzle_names );
         ENM( inst->Predicate.SwizzleY, tgsi_swizzle_names );
         ENM( inst->Predicate.SwizzleZ, tgsi_swizzle_names );
         ENM( inst->Predicate.SwizzleW, tgsi_swizzle_names );
      }

      TXT( ") " );
   }

d519 15
a533 1
      _dump_register_dst( ctx, dst );
d558 4
a561 4
         ENM( src->Register.SwizzleX, tgsi_swizzle_names );
         ENM( src->Register.SwizzleY, tgsi_swizzle_names );
         ENM( src->Register.SwizzleZ, tgsi_swizzle_names );
         ENM( src->Register.SwizzleW, tgsi_swizzle_names );
d572 1
a572 1
      ENM( inst->Texture.Texture, tgsi_texture_names );
d589 1
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a34 1
#include "tgsi_strings.h"
a45 1
   uint immno;
d50 1
a50 1
   void (*dump_printf)(struct dump_ctx *ctx, const char *format, ...);
d71 1
a71 1
      ctx->dump_printf( ctx, "%u", e );
d73 1
a73 1
      ctx->dump_printf( ctx, "%s", enums[e] );
d76 8
a83 8
#define EOL()           ctx->dump_printf( ctx, "\n" )
#define TXT(S)          ctx->dump_printf( ctx, "%s", S )
#define CHR(C)          ctx->dump_printf( ctx, "%c", C )
#define UIX(I)          ctx->dump_printf( ctx, "0x%x", I )
#define UID(I)          ctx->dump_printf( ctx, "%u", I )
#define INSTID(I)       ctx->dump_printf( ctx, "% 3u", I )
#define SID(I)          ctx->dump_printf( ctx, "%d", I )
#define FLT(F)          ctx->dump_printf( ctx, "%10.4f", F )
d86 54
d141 1
a141 1
tgsi_swizzle_names[4] =
d149 54
d208 1
a208 1
   TXT(tgsi_file_name(src->Register.File));
d212 1
a212 1
         TXT(tgsi_file_name(src->DimIndirect.File));
d216 1
a216 1
         ENM( src->DimIndirect.Swizzle, tgsi_swizzle_names );
a222 5
         if (src->DimIndirect.ArrayID) {
            CHR( '(' );
            SID( src->DimIndirect.ArrayID );
            CHR( ')' );
         }
d231 1
a231 1
      TXT(tgsi_file_name(src->Indirect.File));
d235 1
a235 1
      ENM( src->Indirect.Swizzle, tgsi_swizzle_names );
a241 5
      if (src->Indirect.ArrayID) {
         CHR( '(' );
         SID( src->Indirect.ArrayID );
         CHR( ')' );
      }
d255 1
a255 1
   TXT(tgsi_file_name(dst->Register.File));
d259 1
a259 1
         TXT(tgsi_file_name(dst->DimIndirect.File));
d263 1
a263 1
         ENM( dst->DimIndirect.Swizzle, tgsi_swizzle_names );
a269 5
         if (dst->DimIndirect.ArrayID) {
            CHR( '(' );
            SID( dst->DimIndirect.ArrayID );
            CHR( ')' );
         }
d278 1
a278 1
      TXT(tgsi_file_name(dst->Indirect.File));
d282 1
a282 1
      ENM( dst->Indirect.Swizzle, tgsi_swizzle_names );
a288 5
      if (dst->Indirect.ArrayID) {
         CHR( '(' );
         SID( dst->Indirect.ArrayID );
         CHR( ')' );
      }
d353 3
d358 1
a358 1
   TXT(tgsi_file_name(decl->Declaration.File));
a383 9
   if (decl->Declaration.Array) {
      TXT( ", ARRAY(" );
      SID(decl->Array.ArrayID);
      CHR(')');
   }

   if (decl->Declaration.Local)
      TXT( ", LOCAL" );

d386 1
a386 1
      ENM( decl->Semantic.Name, tgsi_semantic_names );
a387 1
          decl->Semantic.Name == TGSI_SEMANTIC_TEXCOORD ||
d395 28
a422 25
   if (decl->Declaration.File == TGSI_FILE_RESOURCE) {
      TXT(", ");
      ENM(decl->Resource.Resource, tgsi_texture_names);
      if (decl->Resource.Writable)
         TXT(", WR");
      if (decl->Resource.Raw)
         TXT(", RAW");
   }

   if (decl->Declaration.File == TGSI_FILE_SAMPLER_VIEW) {
      TXT(", ");
      ENM(decl->SamplerView.Resource, tgsi_texture_names);
      TXT(", ");
      if ((decl->SamplerView.ReturnTypeX == decl->SamplerView.ReturnTypeY) &&
          (decl->SamplerView.ReturnTypeX == decl->SamplerView.ReturnTypeZ) &&
          (decl->SamplerView.ReturnTypeX == decl->SamplerView.ReturnTypeW)) {
         ENM(decl->SamplerView.ReturnTypeX, tgsi_type_names);
      } else {
         ENM(decl->SamplerView.ReturnTypeX, tgsi_type_names);
         TXT(", ");
         ENM(decl->SamplerView.ReturnTypeY, tgsi_type_names);
         TXT(", ");
         ENM(decl->SamplerView.ReturnTypeZ, tgsi_type_names);
         TXT(", ");
         ENM(decl->SamplerView.ReturnTypeW, tgsi_type_names);
d426 3
a428 7
   if (decl->Declaration.Interpolate) {
      if (iter->processor.Processor == TGSI_PROCESSOR_FRAGMENT &&
          decl->Declaration.File == TGSI_FILE_INPUT)
      {
         TXT( ", " );
         ENM( decl->Interp.Interpolate, tgsi_interpolate_names );
      }
d430 1
a430 3
      if (decl->Interp.Centroid) {
         TXT( ", CENTROID" );
      }
d432 26
a457 14
      if (decl->Interp.CylindricalWrap) {
         TXT(", CYLWRAP_");
         if (decl->Interp.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_X) {
            CHR('X');
         }
         if (decl->Interp.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_Y) {
            CHR('Y');
         }
         if (decl->Interp.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_Z) {
            CHR('Z');
         }
         if (decl->Interp.CylindricalWrap & TGSI_CYLINDRICAL_WRAP_W) {
            CHR('W');
         }
a458 1
   }
d460 1
a460 2
   if (decl->Declaration.Invariant) {
      TXT( ", INVARIANT" );
d474 1
a474 1
   ctx.dump_printf = dump_ctx_printf;
d484 1
a484 1
   unsigned i;
d487 2
d490 1
a490 1
   ENM(prop->Property.PropertyName, tgsi_property_names);
d499 1
a499 1
         ENM(prop->u[i].Data, tgsi_primitive_names);
d502 1
a502 1
         ENM(prop->u[i].Data, tgsi_fs_coord_origin_names);
d505 1
a505 1
         ENM(prop->u[i].Data, tgsi_fs_coord_pixel_center_names);
d524 1
a524 1
   ctx.dump_printf = dump_ctx_printf;
d536 2
a537 4
   TXT( "IMM[" );
   SID( ctx->immno++ );
   TXT( "] " );
   ENM( imm->Immediate.DataType, tgsi_immediate_type_names );
d553 1
a553 1
   ctx.dump_printf = dump_ctx_printf;
a662 11
      for (i = 0; i < inst->Texture.NumOffsets; i++) {
         TXT( ", " );
         TXT(tgsi_file_name(inst->TexOffsets[i].File));
         CHR( '[' );
         SID( inst->TexOffsets[i].Index );
         CHR( ']' );
         CHR( '.' );
         ENM( inst->TexOffsets[i].SwizzleX, tgsi_swizzle_names);
         ENM( inst->TexOffsets[i].SwizzleY, tgsi_swizzle_names);
         ENM( inst->TexOffsets[i].SwizzleZ, tgsi_swizzle_names);
      }
a666 1
   case TGSI_OPCODE_UIF:
a677 1
       inst->Instruction.Opcode == TGSI_OPCODE_UIF ||
a695 1
   ctx.immno = instno;
d697 1
a697 1
   ctx.dump_printf = dump_ctx_printf;
d708 1
a708 1
   ENM( iter->processor.Processor, tgsi_processor_type_names );
a727 1
   ctx.immno = 0;
d729 1
a729 1
   ctx.dump_printf = dump_ctx_printf;
a782 1
   ctx.base.immno = 0;
d784 1
a784 1
   ctx.base.dump_printf = &str_dump_ctx_printf;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007-2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a722 23
}

void
tgsi_dump_instruction_str(
   const struct tgsi_full_instruction *inst,
   uint instno,
   char *str,
   size_t size)
{
   struct str_dump_ctx ctx;

   ctx.base.instno = instno;
   ctx.base.immno = instno;
   ctx.base.indent = 0;
   ctx.base.dump_printf = &str_dump_ctx_printf;
   ctx.base.indentation = 0;

   ctx.str = str;
   ctx.str[0] = 0;
   ctx.ptr = str;
   ctx.left = (int)size;

   iter_instruction( &ctx.base.iter, (struct tgsi_full_instruction *)inst );
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d332 1
a332 1
         ENM(decl->SamplerView.ReturnTypeX, tgsi_return_type_names);
d334 1
a334 1
         ENM(decl->SamplerView.ReturnTypeX, tgsi_return_type_names);
d336 1
a336 1
         ENM(decl->SamplerView.ReturnTypeY, tgsi_return_type_names);
d338 1
a338 1
         ENM(decl->SamplerView.ReturnTypeZ, tgsi_return_type_names);
d340 1
a340 1
         ENM(decl->SamplerView.ReturnTypeW, tgsi_return_type_names);
d352 2
a353 3
      if (decl->Interp.Location != TGSI_INTERPOLATE_LOC_CENTER) {
         TXT( ", " );
         ENM( decl->Interp.Location, tgsi_interpolate_locations );
d575 2
a576 5
      if (!(inst->Instruction.Opcode >= TGSI_OPCODE_SAMPLE &&
            inst->Instruction.Opcode <= TGSI_OPCODE_GATHER4)) {
         TXT( ", " );
         ENM( inst->Texture.Texture, tgsi_texture_names );
      }
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d332 1
a332 1
         ENM(decl->SamplerView.ReturnTypeX, tgsi_type_names);
d334 1
a334 1
         ENM(decl->SamplerView.ReturnTypeX, tgsi_type_names);
d336 1
a336 1
         ENM(decl->SamplerView.ReturnTypeY, tgsi_type_names);
d338 1
a338 1
         ENM(decl->SamplerView.ReturnTypeZ, tgsi_type_names);
d340 1
a340 1
         ENM(decl->SamplerView.ReturnTypeW, tgsi_type_names);
d352 3
a354 2
      if (decl->Interp.Centroid) {
         TXT( ", CENTROID" );
d576 5
a580 2
      TXT( ", " );
      ENM( inst->Texture.Texture, tgsi_texture_names );
@


