head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.27;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.46;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.43;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.46;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */

#include "util/u_memory.h"
#include "util/u_format.h"
#include "util/u_half.h"
#include "util/u_math.h"
#include "pipe/p_state.h"
#include "translate.h"


#define DRAW_DBG 0

typedef void (*fetch_func)(void *dst,
                           const uint8_t *src,
                           unsigned i, unsigned j);
typedef void (*emit_func)(const void *attrib, void *ptr);



struct translate_generic {
   struct translate translate;

   struct {
      enum translate_element_type type;

      fetch_func fetch;
      unsigned buffer;
      unsigned input_offset;
      unsigned instance_divisor;

      emit_func emit;
      unsigned output_offset;
      
      const uint8_t *input_ptr;
      unsigned input_stride;
      unsigned max_index;

      /* this value is set to -1 if this is a normal element with output_format != input_format:
       * in this case, u_format is used to do a full conversion
       *
       * this value is set to the format size in bytes if output_format == input_format or for 32-bit instance ids:
       * in this case, memcpy is used to copy this amount of bytes
       */
      int copy_size;

   } attrib[TRANSLATE_MAX_ATTRIBS];

   unsigned nr_attrib;
};


static struct translate_generic *translate_generic( struct translate *translate )
{
   return (struct translate_generic *)translate;
}

/**
 * Fetch a dword[4] vertex attribute from memory, doing format/type
 * conversion as needed.
 *
 * This is probably needed/dupliocated elsewhere, eg format
 * conversion, texture sampling etc.
 */
#define ATTRIB( NAME, SZ, SRCTYPE, DSTTYPE, TO )        \
static void						\
emit_##NAME(const void *attrib, void *ptr)		\
{  \
   unsigned i;						\
   SRCTYPE *in = (SRCTYPE *)attrib;                     \
   DSTTYPE *out = (DSTTYPE *)ptr;			\
							\
   for (i = 0; i < SZ; i++) {				\
      out[i] = TO(in[i]);				\
   }							\
}


#define TO_64_FLOAT(x)   ((double) x)
#define TO_32_FLOAT(x)   (x)
#define TO_16_FLOAT(x)   util_float_to_half(x)

#define TO_8_USCALED(x)  ((unsigned char) x)
#define TO_16_USCALED(x) ((unsigned short) x)
#define TO_32_USCALED(x) ((unsigned int) x)

#define TO_8_SSCALED(x)  ((char) x)
#define TO_16_SSCALED(x) ((short) x)
#define TO_32_SSCALED(x) ((int) x)

#define TO_8_UNORM(x)    ((unsigned char) (x * 255.0f))
#define TO_16_UNORM(x)   ((unsigned short) (x * 65535.0f))
#define TO_32_UNORM(x)   ((unsigned int) (x * 4294967295.0f))

#define TO_8_SNORM(x)    ((char) (x * 127.0f))
#define TO_16_SNORM(x)   ((short) (x * 32767.0f))
#define TO_32_SNORM(x)   ((int) (x * 2147483647.0f))

#define TO_32_FIXED(x)   ((int) (x * 65536.0f))

#define TO_INT(x)        (x)


ATTRIB( R64G64B64A64_FLOAT,   4, float, double, TO_64_FLOAT )
ATTRIB( R64G64B64_FLOAT,      3, float, double, TO_64_FLOAT )
ATTRIB( R64G64_FLOAT,         2, float, double, TO_64_FLOAT )
ATTRIB( R64_FLOAT,            1, float, double, TO_64_FLOAT )

ATTRIB( R32G32B32A32_FLOAT,   4, float, float, TO_32_FLOAT )
ATTRIB( R32G32B32_FLOAT,      3, float, float, TO_32_FLOAT )
ATTRIB( R32G32_FLOAT,         2, float, float, TO_32_FLOAT )
ATTRIB( R32_FLOAT,            1, float, float, TO_32_FLOAT )

ATTRIB( R16G16B16A16_FLOAT,   4, float, ushort, TO_16_FLOAT )
ATTRIB( R16G16B16_FLOAT,      3, float, ushort, TO_16_FLOAT )
ATTRIB( R16G16_FLOAT,         2, float, ushort, TO_16_FLOAT )
ATTRIB( R16_FLOAT,            1, float, ushort, TO_16_FLOAT )

ATTRIB( R32G32B32A32_USCALED, 4, float, unsigned, TO_32_USCALED )
ATTRIB( R32G32B32_USCALED,    3, float, unsigned, TO_32_USCALED )
ATTRIB( R32G32_USCALED,       2, float, unsigned, TO_32_USCALED )
ATTRIB( R32_USCALED,          1, float, unsigned, TO_32_USCALED )

ATTRIB( R32G32B32A32_SSCALED, 4, float, int, TO_32_SSCALED )
ATTRIB( R32G32B32_SSCALED,    3, float, int, TO_32_SSCALED )
ATTRIB( R32G32_SSCALED,       2, float, int, TO_32_SSCALED )
ATTRIB( R32_SSCALED,          1, float, int, TO_32_SSCALED )

ATTRIB( R32G32B32A32_UNORM, 4, float, unsigned, TO_32_UNORM )
ATTRIB( R32G32B32_UNORM,    3, float, unsigned, TO_32_UNORM )
ATTRIB( R32G32_UNORM,       2, float, unsigned, TO_32_UNORM )
ATTRIB( R32_UNORM,          1, float, unsigned, TO_32_UNORM )

ATTRIB( R32G32B32A32_SNORM, 4, float, int, TO_32_SNORM )
ATTRIB( R32G32B32_SNORM,    3, float, int, TO_32_SNORM )
ATTRIB( R32G32_SNORM,       2, float, int, TO_32_SNORM )
ATTRIB( R32_SNORM,          1, float, int, TO_32_SNORM )

ATTRIB( R16G16B16A16_USCALED, 4, float, ushort, TO_16_USCALED )
ATTRIB( R16G16B16_USCALED,    3, float, ushort, TO_16_USCALED )
ATTRIB( R16G16_USCALED,       2, float, ushort, TO_16_USCALED )
ATTRIB( R16_USCALED,          1, float, ushort, TO_16_USCALED )

ATTRIB( R16G16B16A16_SSCALED, 4, float, short, TO_16_SSCALED )
ATTRIB( R16G16B16_SSCALED,    3, float, short, TO_16_SSCALED )
ATTRIB( R16G16_SSCALED,       2, float, short, TO_16_SSCALED )
ATTRIB( R16_SSCALED,          1, float, short, TO_16_SSCALED )

ATTRIB( R16G16B16A16_UNORM, 4, float, ushort, TO_16_UNORM )
ATTRIB( R16G16B16_UNORM,    3, float, ushort, TO_16_UNORM )
ATTRIB( R16G16_UNORM,       2, float, ushort, TO_16_UNORM )
ATTRIB( R16_UNORM,          1, float, ushort, TO_16_UNORM )

ATTRIB( R16G16B16A16_SNORM, 4, float, short, TO_16_SNORM )
ATTRIB( R16G16B16_SNORM,    3, float, short, TO_16_SNORM )
ATTRIB( R16G16_SNORM,       2, float, short, TO_16_SNORM )
ATTRIB( R16_SNORM,          1, float, short, TO_16_SNORM )

ATTRIB( R8G8B8A8_USCALED,   4, float, ubyte, TO_8_USCALED )
ATTRIB( R8G8B8_USCALED,     3, float, ubyte, TO_8_USCALED )
ATTRIB( R8G8_USCALED,       2, float, ubyte, TO_8_USCALED )
ATTRIB( R8_USCALED,         1, float, ubyte, TO_8_USCALED )

ATTRIB( R8G8B8A8_SSCALED,  4, float, char, TO_8_SSCALED )
ATTRIB( R8G8B8_SSCALED,    3, float, char, TO_8_SSCALED )
ATTRIB( R8G8_SSCALED,      2, float, char, TO_8_SSCALED )
ATTRIB( R8_SSCALED,        1, float, char, TO_8_SSCALED )

ATTRIB( R8G8B8A8_UNORM,  4, float, ubyte, TO_8_UNORM )
ATTRIB( R8G8B8_UNORM,    3, float, ubyte, TO_8_UNORM )
ATTRIB( R8G8_UNORM,      2, float, ubyte, TO_8_UNORM )
ATTRIB( R8_UNORM,        1, float, ubyte, TO_8_UNORM )

ATTRIB( R8G8B8A8_SNORM,  4, float, char, TO_8_SNORM )
ATTRIB( R8G8B8_SNORM,    3, float, char, TO_8_SNORM )
ATTRIB( R8G8_SNORM,      2, float, char, TO_8_SNORM )
ATTRIB( R8_SNORM,        1, float, char, TO_8_SNORM )

ATTRIB( R32G32B32A32_UINT, 4, uint32_t, unsigned, TO_INT )
ATTRIB( R32G32B32_UINT,    3, uint32_t, unsigned, TO_INT )
ATTRIB( R32G32_UINT,       2, uint32_t, unsigned, TO_INT )
ATTRIB( R32_UINT,          1, uint32_t, unsigned, TO_INT )

ATTRIB( R16G16B16A16_UINT, 4, uint32_t, ushort, TO_INT )
ATTRIB( R16G16B16_UINT,    3, uint32_t, ushort, TO_INT )
ATTRIB( R16G16_UINT,       2, uint32_t, ushort, TO_INT )
ATTRIB( R16_UINT,          1, uint32_t, ushort, TO_INT )

ATTRIB( R8G8B8A8_UINT,   4, uint32_t, ubyte, TO_INT )
ATTRIB( R8G8B8_UINT,     3, uint32_t, ubyte, TO_INT )
ATTRIB( R8G8_UINT,       2, uint32_t, ubyte, TO_INT )
ATTRIB( R8_UINT,         1, uint32_t, ubyte, TO_INT )

ATTRIB( R32G32B32A32_SINT, 4, int32_t, int, TO_INT )
ATTRIB( R32G32B32_SINT,    3, int32_t, int, TO_INT )
ATTRIB( R32G32_SINT,       2, int32_t, int, TO_INT )
ATTRIB( R32_SINT,          1, int32_t, int, TO_INT )

ATTRIB( R16G16B16A16_SINT, 4, int32_t, short, TO_INT )
ATTRIB( R16G16B16_SINT,    3, int32_t, short, TO_INT )
ATTRIB( R16G16_SINT,       2, int32_t, short, TO_INT )
ATTRIB( R16_SINT,          1, int32_t, short, TO_INT )

ATTRIB( R8G8B8A8_SINT,   4, int32_t, char, TO_INT )
ATTRIB( R8G8B8_SINT,     3, int32_t, char, TO_INT )
ATTRIB( R8G8_SINT,       2, int32_t, char, TO_INT )
ATTRIB( R8_SINT,         1, int32_t, char, TO_INT )

static void
emit_A8R8G8B8_UNORM( const void *attrib, void *ptr)
{
   float *in = (float *)attrib;
   ubyte *out = (ubyte *)ptr;
   out[0] = TO_8_UNORM(in[3]);
   out[1] = TO_8_UNORM(in[0]);
   out[2] = TO_8_UNORM(in[1]);
   out[3] = TO_8_UNORM(in[2]);
}

static void
emit_B8G8R8A8_UNORM( const void *attrib, void *ptr)
{
   float *in = (float *)attrib;
   ubyte *out = (ubyte *)ptr;
   out[2] = TO_8_UNORM(in[0]);
   out[1] = TO_8_UNORM(in[1]);
   out[0] = TO_8_UNORM(in[2]);
   out[3] = TO_8_UNORM(in[3]);
}

static void
emit_B10G10R10A2_UNORM( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= ((uint32_t)(CLAMP(src[2], 0, 1) * 0x3ff)) & 0x3ff;
   value |= (((uint32_t)(CLAMP(src[1], 0, 1) * 0x3ff)) & 0x3ff) << 10;
   value |= (((uint32_t)(CLAMP(src[0], 0, 1) * 0x3ff)) & 0x3ff) << 20;
   value |= ((uint32_t)(CLAMP(src[3], 0, 1) * 0x3)) << 30;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_B10G10R10A2_USCALED( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= ((uint32_t)CLAMP(src[2], 0, 1023)) & 0x3ff;
   value |= (((uint32_t)CLAMP(src[1], 0, 1023)) & 0x3ff) << 10;
   value |= (((uint32_t)CLAMP(src[0], 0, 1023)) & 0x3ff) << 20;
   value |= ((uint32_t)CLAMP(src[3], 0, 3)) << 30;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_B10G10R10A2_SNORM( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= (uint32_t)(((uint32_t)(CLAMP(src[2], -1, 1) * 0x1ff)) & 0x3ff) ;
   value |= (uint32_t)((((uint32_t)(CLAMP(src[1], -1, 1) * 0x1ff)) & 0x3ff) << 10) ;
   value |= (uint32_t)((((uint32_t)(CLAMP(src[0], -1, 1) * 0x1ff)) & 0x3ff) << 20) ;
   value |= (uint32_t)(((uint32_t)(CLAMP(src[3], -1, 1) * 0x1)) << 30) ;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_B10G10R10A2_SSCALED( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= (uint32_t)(((uint32_t)CLAMP(src[2], -512, 511)) & 0x3ff) ;
   value |= (uint32_t)((((uint32_t)CLAMP(src[1], -512, 511)) & 0x3ff) << 10) ;
   value |= (uint32_t)((((uint32_t)CLAMP(src[0], -512, 511)) & 0x3ff) << 20) ;
   value |= (uint32_t)(((uint32_t)CLAMP(src[3], -2, 1)) << 30) ;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_R10G10B10A2_UNORM( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= ((uint32_t)(CLAMP(src[0], 0, 1) * 0x3ff)) & 0x3ff;
   value |= (((uint32_t)(CLAMP(src[1], 0, 1) * 0x3ff)) & 0x3ff) << 10;
   value |= (((uint32_t)(CLAMP(src[2], 0, 1) * 0x3ff)) & 0x3ff) << 20;
   value |= ((uint32_t)(CLAMP(src[3], 0, 1) * 0x3)) << 30;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_R10G10B10A2_USCALED( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= ((uint32_t)CLAMP(src[0], 0, 1023)) & 0x3ff;
   value |= (((uint32_t)CLAMP(src[1], 0, 1023)) & 0x3ff) << 10;
   value |= (((uint32_t)CLAMP(src[2], 0, 1023)) & 0x3ff) << 20;
   value |= ((uint32_t)CLAMP(src[3], 0, 3)) << 30;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_R10G10B10A2_SNORM( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= (uint32_t)(((uint32_t)(CLAMP(src[0], -1, 1) * 0x1ff)) & 0x3ff) ;
   value |= (uint32_t)((((uint32_t)(CLAMP(src[1], -1, 1) * 0x1ff)) & 0x3ff) << 10) ;
   value |= (uint32_t)((((uint32_t)(CLAMP(src[2], -1, 1) * 0x1ff)) & 0x3ff) << 20) ;
   value |= (uint32_t)(((uint32_t)(CLAMP(src[3], -1, 1) * 0x1)) << 30) ;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_R10G10B10A2_SSCALED( const void *attrib, void *ptr)
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= (uint32_t)(((uint32_t)CLAMP(src[0], -512, 511)) & 0x3ff) ;
   value |= (uint32_t)((((uint32_t)CLAMP(src[1], -512, 511)) & 0x3ff) << 10) ;
   value |= (uint32_t)((((uint32_t)CLAMP(src[2], -512, 511)) & 0x3ff) << 20) ;
   value |= (uint32_t)(((uint32_t)CLAMP(src[3], -2, 1)) << 30) ;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void 
emit_NULL( const void *attrib, void *ptr )
{
   /* do nothing is the only sensible option */
}

static emit_func get_emit_func( enum pipe_format format )
{
   switch (format) {
   case PIPE_FORMAT_R64_FLOAT:
      return &emit_R64_FLOAT;
   case PIPE_FORMAT_R64G64_FLOAT:
      return &emit_R64G64_FLOAT;
   case PIPE_FORMAT_R64G64B64_FLOAT:
      return &emit_R64G64B64_FLOAT;
   case PIPE_FORMAT_R64G64B64A64_FLOAT:
      return &emit_R64G64B64A64_FLOAT;

   case PIPE_FORMAT_R32_FLOAT:
      return &emit_R32_FLOAT;
   case PIPE_FORMAT_R32G32_FLOAT:
      return &emit_R32G32_FLOAT;
   case PIPE_FORMAT_R32G32B32_FLOAT:
      return &emit_R32G32B32_FLOAT;
   case PIPE_FORMAT_R32G32B32A32_FLOAT:
      return &emit_R32G32B32A32_FLOAT;

   case PIPE_FORMAT_R16_FLOAT:
      return &emit_R16_FLOAT;
   case PIPE_FORMAT_R16G16_FLOAT:
      return &emit_R16G16_FLOAT;
   case PIPE_FORMAT_R16G16B16_FLOAT:
      return &emit_R16G16B16_FLOAT;
   case PIPE_FORMAT_R16G16B16A16_FLOAT:
      return &emit_R16G16B16A16_FLOAT;

   case PIPE_FORMAT_R32_UNORM:
      return &emit_R32_UNORM;
   case PIPE_FORMAT_R32G32_UNORM:
      return &emit_R32G32_UNORM;
   case PIPE_FORMAT_R32G32B32_UNORM:
      return &emit_R32G32B32_UNORM;
   case PIPE_FORMAT_R32G32B32A32_UNORM:
      return &emit_R32G32B32A32_UNORM;

   case PIPE_FORMAT_R32_USCALED:
      return &emit_R32_USCALED;
   case PIPE_FORMAT_R32G32_USCALED:
      return &emit_R32G32_USCALED;
   case PIPE_FORMAT_R32G32B32_USCALED:
      return &emit_R32G32B32_USCALED;
   case PIPE_FORMAT_R32G32B32A32_USCALED:
      return &emit_R32G32B32A32_USCALED;

   case PIPE_FORMAT_R32_SNORM:
      return &emit_R32_SNORM;
   case PIPE_FORMAT_R32G32_SNORM:
      return &emit_R32G32_SNORM;
   case PIPE_FORMAT_R32G32B32_SNORM:
      return &emit_R32G32B32_SNORM;
   case PIPE_FORMAT_R32G32B32A32_SNORM:
      return &emit_R32G32B32A32_SNORM;

   case PIPE_FORMAT_R32_SSCALED:
      return &emit_R32_SSCALED;
   case PIPE_FORMAT_R32G32_SSCALED:
      return &emit_R32G32_SSCALED;
   case PIPE_FORMAT_R32G32B32_SSCALED:
      return &emit_R32G32B32_SSCALED;
   case PIPE_FORMAT_R32G32B32A32_SSCALED:
      return &emit_R32G32B32A32_SSCALED;

   case PIPE_FORMAT_R16_UNORM:
      return &emit_R16_UNORM;
   case PIPE_FORMAT_R16G16_UNORM:
      return &emit_R16G16_UNORM;
   case PIPE_FORMAT_R16G16B16_UNORM:
      return &emit_R16G16B16_UNORM;
   case PIPE_FORMAT_R16G16B16A16_UNORM:
      return &emit_R16G16B16A16_UNORM;

   case PIPE_FORMAT_R16_USCALED:
      return &emit_R16_USCALED;
   case PIPE_FORMAT_R16G16_USCALED:
      return &emit_R16G16_USCALED;
   case PIPE_FORMAT_R16G16B16_USCALED:
      return &emit_R16G16B16_USCALED;
   case PIPE_FORMAT_R16G16B16A16_USCALED:
      return &emit_R16G16B16A16_USCALED;

   case PIPE_FORMAT_R16_SNORM:
      return &emit_R16_SNORM;
   case PIPE_FORMAT_R16G16_SNORM:
      return &emit_R16G16_SNORM;
   case PIPE_FORMAT_R16G16B16_SNORM:
      return &emit_R16G16B16_SNORM;
   case PIPE_FORMAT_R16G16B16A16_SNORM:
      return &emit_R16G16B16A16_SNORM;

   case PIPE_FORMAT_R16_SSCALED:
      return &emit_R16_SSCALED;
   case PIPE_FORMAT_R16G16_SSCALED:
      return &emit_R16G16_SSCALED;
   case PIPE_FORMAT_R16G16B16_SSCALED:
      return &emit_R16G16B16_SSCALED;
   case PIPE_FORMAT_R16G16B16A16_SSCALED:
      return &emit_R16G16B16A16_SSCALED;

   case PIPE_FORMAT_R8_UNORM:
      return &emit_R8_UNORM;
   case PIPE_FORMAT_R8G8_UNORM:
      return &emit_R8G8_UNORM;
   case PIPE_FORMAT_R8G8B8_UNORM:
      return &emit_R8G8B8_UNORM;
   case PIPE_FORMAT_R8G8B8A8_UNORM:
      return &emit_R8G8B8A8_UNORM;

   case PIPE_FORMAT_R8_USCALED:
      return &emit_R8_USCALED;
   case PIPE_FORMAT_R8G8_USCALED:
      return &emit_R8G8_USCALED;
   case PIPE_FORMAT_R8G8B8_USCALED:
      return &emit_R8G8B8_USCALED;
   case PIPE_FORMAT_R8G8B8A8_USCALED:
      return &emit_R8G8B8A8_USCALED;

   case PIPE_FORMAT_R8_SNORM:
      return &emit_R8_SNORM;
   case PIPE_FORMAT_R8G8_SNORM:
      return &emit_R8G8_SNORM;
   case PIPE_FORMAT_R8G8B8_SNORM:
      return &emit_R8G8B8_SNORM;
   case PIPE_FORMAT_R8G8B8A8_SNORM:
      return &emit_R8G8B8A8_SNORM;

   case PIPE_FORMAT_R8_SSCALED:
      return &emit_R8_SSCALED;
   case PIPE_FORMAT_R8G8_SSCALED:
      return &emit_R8G8_SSCALED;
   case PIPE_FORMAT_R8G8B8_SSCALED:
      return &emit_R8G8B8_SSCALED;
   case PIPE_FORMAT_R8G8B8A8_SSCALED:
      return &emit_R8G8B8A8_SSCALED;

   case PIPE_FORMAT_B8G8R8A8_UNORM:
      return &emit_B8G8R8A8_UNORM;

   case PIPE_FORMAT_A8R8G8B8_UNORM:
      return &emit_A8R8G8B8_UNORM;

   case PIPE_FORMAT_R32_UINT:
      return &emit_R32_UINT;
   case PIPE_FORMAT_R32G32_UINT:
      return &emit_R32G32_UINT;
   case PIPE_FORMAT_R32G32B32_UINT:
      return &emit_R32G32B32_UINT;
   case PIPE_FORMAT_R32G32B32A32_UINT:
      return &emit_R32G32B32A32_UINT;

   case PIPE_FORMAT_R16_UINT:
      return &emit_R16_UINT;
   case PIPE_FORMAT_R16G16_UINT:
      return &emit_R16G16_UINT;
   case PIPE_FORMAT_R16G16B16_UINT:
      return &emit_R16G16B16_UINT;
   case PIPE_FORMAT_R16G16B16A16_UINT:
      return &emit_R16G16B16A16_UINT;

   case PIPE_FORMAT_R8_UINT:
      return &emit_R8_UINT;
   case PIPE_FORMAT_R8G8_UINT:
      return &emit_R8G8_UINT;
   case PIPE_FORMAT_R8G8B8_UINT:
      return &emit_R8G8B8_UINT;
   case PIPE_FORMAT_R8G8B8A8_UINT:
      return &emit_R8G8B8A8_UINT;

   case PIPE_FORMAT_R32_SINT:
      return &emit_R32_SINT;
   case PIPE_FORMAT_R32G32_SINT:
      return &emit_R32G32_SINT;
   case PIPE_FORMAT_R32G32B32_SINT:
      return &emit_R32G32B32_SINT;
   case PIPE_FORMAT_R32G32B32A32_SINT:
      return &emit_R32G32B32A32_SINT;

   case PIPE_FORMAT_R16_SINT:
      return &emit_R16_SINT;
   case PIPE_FORMAT_R16G16_SINT:
      return &emit_R16G16_SINT;
   case PIPE_FORMAT_R16G16B16_SINT:
      return &emit_R16G16B16_SINT;
   case PIPE_FORMAT_R16G16B16A16_SINT:
      return &emit_R16G16B16A16_SINT;

   case PIPE_FORMAT_R8_SINT:
      return &emit_R8_SINT;
   case PIPE_FORMAT_R8G8_SINT:
      return &emit_R8G8_SINT;
   case PIPE_FORMAT_R8G8B8_SINT:
      return &emit_R8G8B8_SINT;
   case PIPE_FORMAT_R8G8B8A8_SINT:
      return &emit_R8G8B8A8_SINT;

   case PIPE_FORMAT_B10G10R10A2_UNORM:
      return &emit_B10G10R10A2_UNORM;
   case PIPE_FORMAT_B10G10R10A2_USCALED:
      return &emit_B10G10R10A2_USCALED;
   case PIPE_FORMAT_B10G10R10A2_SNORM:
      return &emit_B10G10R10A2_SNORM;
   case PIPE_FORMAT_B10G10R10A2_SSCALED:
      return &emit_B10G10R10A2_SSCALED;

   case PIPE_FORMAT_R10G10B10A2_UNORM:
      return &emit_R10G10B10A2_UNORM;
   case PIPE_FORMAT_R10G10B10A2_USCALED:
      return &emit_R10G10B10A2_USCALED;
   case PIPE_FORMAT_R10G10B10A2_SNORM:
      return &emit_R10G10B10A2_SNORM;
   case PIPE_FORMAT_R10G10B10A2_SSCALED:
      return &emit_R10G10B10A2_SSCALED;

   default:
      assert(0); 
      return &emit_NULL;
   }
}

static ALWAYS_INLINE void PIPE_CDECL generic_run_one( struct translate_generic *tg,
                                         unsigned elt,
                                         unsigned start_instance,
                                         unsigned instance_id,
                                         void *vert )
{
   unsigned nr_attrs = tg->nr_attrib;
   unsigned attr;

   for (attr = 0; attr < nr_attrs; attr++) {
      float data[4];
      uint8_t *dst = (uint8_t *)vert + tg->attrib[attr].output_offset;

      if (tg->attrib[attr].type == TRANSLATE_ELEMENT_NORMAL) {
         const uint8_t *src;
         unsigned index;
         int copy_size;

         if (tg->attrib[attr].instance_divisor) {
            index = start_instance;
            index += (instance_id  / tg->attrib[attr].instance_divisor);
            /* XXX we need to clamp the index here too, but to a
             * per-array max value, not the draw->pt.max_index value
             * that's being given to us via translate->set_buffer().
             */
         }
         else {
            index = elt;
            /* clamp to avoid going out of bounds */
            index = MIN2(index, tg->attrib[attr].max_index);
         }

         src = tg->attrib[attr].input_ptr +
               (ptrdiff_t)tg->attrib[attr].input_stride * index;

         copy_size = tg->attrib[attr].copy_size;
         if(likely(copy_size >= 0))
            memcpy(dst, src, copy_size);
         else
         {
            tg->attrib[attr].fetch( data, src, 0, 0 );

            if (0)
               debug_printf("Fetch linear attr %d  from %p  stride %d  index %d: "
                         " %f, %f, %f, %f \n",
                         attr,
                         tg->attrib[attr].input_ptr,
                         tg->attrib[attr].input_stride,
                         index,
                         data[0], data[1],data[2], data[3]);

            tg->attrib[attr].emit( data, dst );
         }
      } else {
         if(likely(tg->attrib[attr].copy_size >= 0))
            memcpy(data, &instance_id, 4);
         else
         {
            data[0] = (float)instance_id;
            tg->attrib[attr].emit( data, dst );
         }
      }
   }
}

/**
 * Fetch vertex attributes for 'count' vertices.
 */
static void PIPE_CDECL generic_run_elts( struct translate *translate,
                                         const unsigned *elts,
                                         unsigned count,
                                         unsigned start_instance,
                                         unsigned instance_id,
                                         void *output_buffer )
{
   struct translate_generic *tg = translate_generic(translate);
   char *vert = output_buffer;
   unsigned i;

   for (i = 0; i < count; i++) {
      generic_run_one(tg, *elts++, start_instance, instance_id, vert);
      vert += tg->translate.key.output_stride;
   }
}

static void PIPE_CDECL generic_run_elts16( struct translate *translate,
                                         const uint16_t *elts,
                                         unsigned count,
                                         unsigned start_instance,
                                         unsigned instance_id,
                                         void *output_buffer )
{
   struct translate_generic *tg = translate_generic(translate);
   char *vert = output_buffer;
   unsigned i;

   for (i = 0; i < count; i++) {
      generic_run_one(tg, *elts++, start_instance, instance_id, vert);
      vert += tg->translate.key.output_stride;
   }
}

static void PIPE_CDECL generic_run_elts8( struct translate *translate,
                                         const uint8_t *elts,
                                         unsigned count,
                                         unsigned start_instance, 
                                         unsigned instance_id,
                                         void *output_buffer )
{
   struct translate_generic *tg = translate_generic(translate);
   char *vert = output_buffer;
   unsigned i;

   for (i = 0; i < count; i++) {
      generic_run_one(tg, *elts++, start_instance, instance_id, vert);
      vert += tg->translate.key.output_stride;
   }
}

static void PIPE_CDECL generic_run( struct translate *translate,
                                    unsigned start,
                                    unsigned count,
                                    unsigned start_instance,
                                    unsigned instance_id,
                                    void *output_buffer )
{
   struct translate_generic *tg = translate_generic(translate);
   char *vert = output_buffer;
   unsigned i;

   for (i = 0; i < count; i++) {
      generic_run_one(tg, start + i, start_instance, instance_id, vert);
      vert += tg->translate.key.output_stride;
   }
}


			       
static void generic_set_buffer( struct translate *translate,
				unsigned buf,
				const void *ptr,
				unsigned stride,
				unsigned max_index )
{
   struct translate_generic *tg = translate_generic(translate);
   unsigned i;

   for (i = 0; i < tg->nr_attrib; i++) {
      if (tg->attrib[i].buffer == buf) {
	 tg->attrib[i].input_ptr = ((const uint8_t *)ptr +
				    tg->attrib[i].input_offset);
	 tg->attrib[i].input_stride = stride;
         tg->attrib[i].max_index = max_index;
      }
   }
}


static void generic_release( struct translate *translate )
{
   /* Refcount?
    */
   FREE(translate);
}

static boolean
is_legal_int_format_combo( const struct util_format_description *src,
                           const struct util_format_description *dst )
{
   unsigned i;
   unsigned nr = MIN2(src->nr_channels, dst->nr_channels);

   for (i = 0; i < nr; i++) {
      /* The signs must match. */
      if (src->channel[i].type != dst->channel[i].type) {
         return FALSE;
      }

      /* Integers must not lose precision at any point in the pipeline. */
      if (src->channel[i].size > dst->channel[i].size) {
         return FALSE;
      }
   }
   return TRUE;
}

struct translate *translate_generic_create( const struct translate_key *key )
{
   struct translate_generic *tg = CALLOC_STRUCT(translate_generic);
   unsigned i;

   if (tg == NULL)
      return NULL;

   assert(key->nr_elements <= TRANSLATE_MAX_ATTRIBS);

   tg->translate.key = *key;
   tg->translate.release = generic_release;
   tg->translate.set_buffer = generic_set_buffer;
   tg->translate.run_elts = generic_run_elts;
   tg->translate.run_elts16 = generic_run_elts16;
   tg->translate.run_elts8 = generic_run_elts8;
   tg->translate.run = generic_run;

   for (i = 0; i < key->nr_elements; i++) {
      const struct util_format_description *format_desc =
            util_format_description(key->element[i].input_format);

      assert(format_desc);

      tg->attrib[i].type = key->element[i].type;

      if (format_desc->channel[0].pure_integer) {
         const struct util_format_description *out_format_desc =
               util_format_description(key->element[i].output_format);

         if (!is_legal_int_format_combo(format_desc, out_format_desc)) {
            FREE(tg);
            return NULL;
         }

         if (format_desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
            assert(format_desc->fetch_rgba_sint);
            tg->attrib[i].fetch = (fetch_func)format_desc->fetch_rgba_sint;
         } else {
            assert(format_desc->fetch_rgba_uint);
            tg->attrib[i].fetch = (fetch_func)format_desc->fetch_rgba_uint;
         }
      } else {
         assert(format_desc->fetch_rgba_float);
         tg->attrib[i].fetch = (fetch_func)format_desc->fetch_rgba_float;
      }

      tg->attrib[i].buffer = key->element[i].input_buffer;
      tg->attrib[i].input_offset = key->element[i].input_offset;
      tg->attrib[i].instance_divisor = key->element[i].instance_divisor;

      tg->attrib[i].output_offset = key->element[i].output_offset;

      tg->attrib[i].copy_size = -1;
      if (tg->attrib[i].type == TRANSLATE_ELEMENT_INSTANCE_ID)
      {
            if(key->element[i].output_format == PIPE_FORMAT_R32_USCALED
                  || key->element[i].output_format == PIPE_FORMAT_R32_SSCALED)
               tg->attrib[i].copy_size = 4;
      }
      else
      {
         if(key->element[i].input_format == key->element[i].output_format
               && format_desc->block.width == 1
               && format_desc->block.height == 1
               && !(format_desc->block.bits & 7))
            tg->attrib[i].copy_size = format_desc->block.bits >> 3;
      }

      if(tg->attrib[i].copy_size < 0)
	      tg->attrib[i].emit = get_emit_func(key->element[i].output_format);
      else
	      tg->attrib[i].emit  = NULL;
   }

   tg->nr_attrib = key->nr_elements;


   return &tg->translate;
}

boolean translate_generic_is_output_format_supported(enum pipe_format format)
{
   switch(format)
   {
   case PIPE_FORMAT_R64G64B64A64_FLOAT: return TRUE;
   case PIPE_FORMAT_R64G64B64_FLOAT: return TRUE;
   case PIPE_FORMAT_R64G64_FLOAT: return TRUE;
   case PIPE_FORMAT_R64_FLOAT: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_FLOAT: return TRUE;
   case PIPE_FORMAT_R32G32B32_FLOAT: return TRUE;
   case PIPE_FORMAT_R32G32_FLOAT: return TRUE;
   case PIPE_FORMAT_R32_FLOAT: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_FLOAT: return TRUE;
   case PIPE_FORMAT_R16G16B16_FLOAT: return TRUE;
   case PIPE_FORMAT_R16G16_FLOAT: return TRUE;
   case PIPE_FORMAT_R16_FLOAT: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_USCALED: return TRUE;
   case PIPE_FORMAT_R32G32B32_USCALED: return TRUE;
   case PIPE_FORMAT_R32G32_USCALED: return TRUE;
   case PIPE_FORMAT_R32_USCALED: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_SSCALED: return TRUE;
   case PIPE_FORMAT_R32G32B32_SSCALED: return TRUE;
   case PIPE_FORMAT_R32G32_SSCALED: return TRUE;
   case PIPE_FORMAT_R32_SSCALED: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_UNORM: return TRUE;
   case PIPE_FORMAT_R32G32B32_UNORM: return TRUE;
   case PIPE_FORMAT_R32G32_UNORM: return TRUE;
   case PIPE_FORMAT_R32_UNORM: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_SNORM: return TRUE;
   case PIPE_FORMAT_R32G32B32_SNORM: return TRUE;
   case PIPE_FORMAT_R32G32_SNORM: return TRUE;
   case PIPE_FORMAT_R32_SNORM: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_USCALED: return TRUE;
   case PIPE_FORMAT_R16G16B16_USCALED: return TRUE;
   case PIPE_FORMAT_R16G16_USCALED: return TRUE;
   case PIPE_FORMAT_R16_USCALED: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_SSCALED: return TRUE;
   case PIPE_FORMAT_R16G16B16_SSCALED: return TRUE;
   case PIPE_FORMAT_R16G16_SSCALED: return TRUE;
   case PIPE_FORMAT_R16_SSCALED: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_UNORM: return TRUE;
   case PIPE_FORMAT_R16G16B16_UNORM: return TRUE;
   case PIPE_FORMAT_R16G16_UNORM: return TRUE;
   case PIPE_FORMAT_R16_UNORM: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_SNORM: return TRUE;
   case PIPE_FORMAT_R16G16B16_SNORM: return TRUE;
   case PIPE_FORMAT_R16G16_SNORM: return TRUE;
   case PIPE_FORMAT_R16_SNORM: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_USCALED: return TRUE;
   case PIPE_FORMAT_R8G8B8_USCALED: return TRUE;
   case PIPE_FORMAT_R8G8_USCALED: return TRUE;
   case PIPE_FORMAT_R8_USCALED: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_SSCALED: return TRUE;
   case PIPE_FORMAT_R8G8B8_SSCALED: return TRUE;
   case PIPE_FORMAT_R8G8_SSCALED: return TRUE;
   case PIPE_FORMAT_R8_SSCALED: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_UNORM: return TRUE;
   case PIPE_FORMAT_R8G8B8_UNORM: return TRUE;
   case PIPE_FORMAT_R8G8_UNORM: return TRUE;
   case PIPE_FORMAT_R8_UNORM: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_SNORM: return TRUE;
   case PIPE_FORMAT_R8G8B8_SNORM: return TRUE;
   case PIPE_FORMAT_R8G8_SNORM: return TRUE;
   case PIPE_FORMAT_R8_SNORM: return TRUE;

   case PIPE_FORMAT_A8R8G8B8_UNORM: return TRUE;
   case PIPE_FORMAT_B8G8R8A8_UNORM: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_UINT: return TRUE;
   case PIPE_FORMAT_R32G32B32_UINT: return TRUE;
   case PIPE_FORMAT_R32G32_UINT: return TRUE;
   case PIPE_FORMAT_R32_UINT: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_UINT: return TRUE;
   case PIPE_FORMAT_R16G16B16_UINT: return TRUE;
   case PIPE_FORMAT_R16G16_UINT: return TRUE;
   case PIPE_FORMAT_R16_UINT: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_UINT: return TRUE;
   case PIPE_FORMAT_R8G8B8_UINT: return TRUE;
   case PIPE_FORMAT_R8G8_UINT: return TRUE;
   case PIPE_FORMAT_R8_UINT: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_SINT: return TRUE;
   case PIPE_FORMAT_R32G32B32_SINT: return TRUE;
   case PIPE_FORMAT_R32G32_SINT: return TRUE;
   case PIPE_FORMAT_R32_SINT: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_SINT: return TRUE;
   case PIPE_FORMAT_R16G16B16_SINT: return TRUE;
   case PIPE_FORMAT_R16G16_SINT: return TRUE;
   case PIPE_FORMAT_R16_SINT: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_SINT: return TRUE;
   case PIPE_FORMAT_R8G8B8_SINT: return TRUE;
   case PIPE_FORMAT_R8G8_SINT: return TRUE;
   case PIPE_FORMAT_R8_SINT: return TRUE;

   case PIPE_FORMAT_B10G10R10A2_UNORM: return TRUE;
   case PIPE_FORMAT_B10G10R10A2_USCALED: return TRUE;
   case PIPE_FORMAT_B10G10R10A2_SNORM: return TRUE;
   case PIPE_FORMAT_B10G10R10A2_SSCALED: return TRUE;

   case PIPE_FORMAT_R10G10B10A2_UNORM: return TRUE;
   case PIPE_FORMAT_R10G10B10A2_USCALED: return TRUE;
   case PIPE_FORMAT_R10G10B10A2_SNORM: return TRUE;
   case PIPE_FORMAT_R10G10B10A2_SSCALED: return TRUE;

   default: return FALSE;
   }
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d76 1
a76 1
   } attrib[PIPE_MAX_ATTRIBS];
d628 1
a628 2
            index += (instance_id - start_instance) /
               tg->attrib[attr].instance_divisor;
d641 1
a641 1
               tg->attrib[attr].input_stride * index;
d801 2
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d35 1
d43 1
a43 1
typedef void (*fetch_func)(float *dst,
d46 1
a46 1
typedef void (*emit_func)(const float *attrib, void *ptr);
d88 1
a88 1
 * Fetch a float[4] vertex attribute from memory, doing format/type
d94 1
a94 1
#define ATTRIB( NAME, SZ, TYPE, TO )	    	        \
d96 1
a96 1
emit_##NAME(const float *attrib, void *ptr)		\
d99 2
a100 1
   TYPE *out = (TYPE *)ptr;				\
d103 1
a103 1
      out[i] = TO(attrib[i]);				\
d110 1
d130 1
d132 105
a236 69
ATTRIB( R64G64B64A64_FLOAT,   4, double, TO_64_FLOAT )
ATTRIB( R64G64B64_FLOAT,      3, double, TO_64_FLOAT )
ATTRIB( R64G64_FLOAT,         2, double, TO_64_FLOAT )
ATTRIB( R64_FLOAT,            1, double, TO_64_FLOAT )

ATTRIB( R32G32B32A32_FLOAT,   4, float, TO_32_FLOAT )
ATTRIB( R32G32B32_FLOAT,      3, float, TO_32_FLOAT )
ATTRIB( R32G32_FLOAT,         2, float, TO_32_FLOAT )
ATTRIB( R32_FLOAT,            1, float, TO_32_FLOAT )

ATTRIB( R32G32B32A32_USCALED, 4, unsigned, TO_32_USCALED )
ATTRIB( R32G32B32_USCALED,    3, unsigned, TO_32_USCALED )
ATTRIB( R32G32_USCALED,       2, unsigned, TO_32_USCALED )
ATTRIB( R32_USCALED,          1, unsigned, TO_32_USCALED )

ATTRIB( R32G32B32A32_SSCALED, 4, int, TO_32_SSCALED )
ATTRIB( R32G32B32_SSCALED,    3, int, TO_32_SSCALED )
ATTRIB( R32G32_SSCALED,       2, int, TO_32_SSCALED )
ATTRIB( R32_SSCALED,          1, int, TO_32_SSCALED )

ATTRIB( R32G32B32A32_UNORM, 4, unsigned, TO_32_UNORM )
ATTRIB( R32G32B32_UNORM,    3, unsigned, TO_32_UNORM )
ATTRIB( R32G32_UNORM,       2, unsigned, TO_32_UNORM )
ATTRIB( R32_UNORM,          1, unsigned, TO_32_UNORM )

ATTRIB( R32G32B32A32_SNORM, 4, int, TO_32_SNORM )
ATTRIB( R32G32B32_SNORM,    3, int, TO_32_SNORM )
ATTRIB( R32G32_SNORM,       2, int, TO_32_SNORM )
ATTRIB( R32_SNORM,          1, int, TO_32_SNORM )

ATTRIB( R16G16B16A16_USCALED, 4, ushort, TO_16_USCALED )
ATTRIB( R16G16B16_USCALED,    3, ushort, TO_16_USCALED )
ATTRIB( R16G16_USCALED,       2, ushort, TO_16_USCALED )
ATTRIB( R16_USCALED,          1, ushort, TO_16_USCALED )

ATTRIB( R16G16B16A16_SSCALED, 4, short, TO_16_SSCALED )
ATTRIB( R16G16B16_SSCALED,    3, short, TO_16_SSCALED )
ATTRIB( R16G16_SSCALED,       2, short, TO_16_SSCALED )
ATTRIB( R16_SSCALED,          1, short, TO_16_SSCALED )

ATTRIB( R16G16B16A16_UNORM, 4, ushort, TO_16_UNORM )
ATTRIB( R16G16B16_UNORM,    3, ushort, TO_16_UNORM )
ATTRIB( R16G16_UNORM,       2, ushort, TO_16_UNORM )
ATTRIB( R16_UNORM,          1, ushort, TO_16_UNORM )

ATTRIB( R16G16B16A16_SNORM, 4, short, TO_16_SNORM )
ATTRIB( R16G16B16_SNORM,    3, short, TO_16_SNORM )
ATTRIB( R16G16_SNORM,       2, short, TO_16_SNORM )
ATTRIB( R16_SNORM,          1, short, TO_16_SNORM )

ATTRIB( R8G8B8A8_USCALED,   4, ubyte, TO_8_USCALED )
ATTRIB( R8G8B8_USCALED,     3, ubyte, TO_8_USCALED )
ATTRIB( R8G8_USCALED,       2, ubyte, TO_8_USCALED )
ATTRIB( R8_USCALED,         1, ubyte, TO_8_USCALED )

ATTRIB( R8G8B8A8_SSCALED,  4, char, TO_8_SSCALED )
ATTRIB( R8G8B8_SSCALED,    3, char, TO_8_SSCALED )
ATTRIB( R8G8_SSCALED,      2, char, TO_8_SSCALED )
ATTRIB( R8_SSCALED,        1, char, TO_8_SSCALED )

ATTRIB( R8G8B8A8_UNORM,  4, ubyte, TO_8_UNORM )
ATTRIB( R8G8B8_UNORM,    3, ubyte, TO_8_UNORM )
ATTRIB( R8G8_UNORM,      2, ubyte, TO_8_UNORM )
ATTRIB( R8_UNORM,        1, ubyte, TO_8_UNORM )

ATTRIB( R8G8B8A8_SNORM,  4, char, TO_8_SNORM )
ATTRIB( R8G8B8_SNORM,    3, char, TO_8_SNORM )
ATTRIB( R8G8_SNORM,      2, char, TO_8_SNORM )
ATTRIB( R8_SNORM,        1, char, TO_8_SNORM )
d239 1
a239 1
emit_A8R8G8B8_UNORM( const float *attrib, void *ptr)
d241 1
d243 4
a246 4
   out[0] = TO_8_UNORM(attrib[3]);
   out[1] = TO_8_UNORM(attrib[0]);
   out[2] = TO_8_UNORM(attrib[1]);
   out[3] = TO_8_UNORM(attrib[2]);
d250 1
a250 1
emit_B8G8R8A8_UNORM( const float *attrib, void *ptr)
d252 1
d254 124
a377 4
   out[2] = TO_8_UNORM(attrib[0]);
   out[1] = TO_8_UNORM(attrib[1]);
   out[0] = TO_8_UNORM(attrib[2]);
   out[3] = TO_8_UNORM(attrib[3]);
d381 1
a381 1
emit_NULL( const float *attrib, void *ptr )
d407 9
d530 72
d610 1
d627 3
a629 1
            index = instance_id / tg->attrib[attr].instance_divisor;
d680 1
d689 1
a689 1
      generic_run_one(tg, *elts++, instance_id, vert);
d697 1
d706 1
a706 1
      generic_run_one(tg, *elts++, instance_id, vert);
d714 1
d723 1
a723 1
      generic_run_one(tg, *elts++, instance_id, vert);
d731 1
d740 1
a740 1
      generic_run_one(tg, start + i, instance_id, vert);
d774 21
a815 1
      assert(format_desc->fetch_rgba_float);
d819 21
a839 1
      tg->attrib[i].fetch = format_desc->fetch_rgba_float;
d888 5
d955 41
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d384 4
d391 2
a393 3

         /* clamp to void going out of bounds */
         index = MIN2(index, tg->attrib[attr].max_index);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 2
d42 3
a44 1
typedef void (*fetch_func)(const void *ptr, float *attrib);
d63 1
a63 1
      char *input_ptr;
d65 9
d93 1
a93 16
#define ATTRIB( NAME, SZ, TYPE, FROM, TO )		\
static void						\
fetch_##NAME(const void *ptr, float *attrib)		\
{							\
   const float defaults[4] = { 0.0f,0.0f,0.0f,1.0f };	\
   unsigned i;						\
							\
   for (i = 0; i < SZ; i++) {				\
      attrib[i] = FROM(i);				\
   }							\
							\
   for (; i < 4; i++) {					\
      attrib[i] = defaults[i];				\
   }							\
}							\
							\
a105 21
#define FROM_64_FLOAT(i)   ((float) ((double *) ptr)[i])
#define FROM_32_FLOAT(i)   (((float *) ptr)[i])

#define FROM_8_USCALED(i)  ((float) ((unsigned char *) ptr)[i])
#define FROM_16_USCALED(i) ((float) ((unsigned short *) ptr)[i])
#define FROM_32_USCALED(i) ((float) ((unsigned int *) ptr)[i])

#define FROM_8_SSCALED(i)  ((float) ((char *) ptr)[i])
#define FROM_16_SSCALED(i) ((float) ((short *) ptr)[i])
#define FROM_32_SSCALED(i) ((float) ((int *) ptr)[i])

#define FROM_8_UNORM(i)    ((float) ((unsigned char *) ptr)[i] / 255.0f)
#define FROM_16_UNORM(i)   ((float) ((unsigned short *) ptr)[i] / 65535.0f)
#define FROM_32_UNORM(i)   ((float) ((unsigned int *) ptr)[i] / 4294967295.0f)

#define FROM_8_SNORM(i)    ((float) ((char *) ptr)[i] / 127.0f)
#define FROM_16_SNORM(i)   ((float) ((short *) ptr)[i] / 32767.0f)
#define FROM_32_SNORM(i)   ((float) ((int *) ptr)[i] / 2147483647.0f)

#define FROM_32_FIXED(i)   (((int *) ptr)[i] / 65536.0f)

d128 69
a196 80

ATTRIB( R64G64B64A64_FLOAT,   4, double, FROM_64_FLOAT, TO_64_FLOAT )
ATTRIB( R64G64B64_FLOAT,      3, double, FROM_64_FLOAT, TO_64_FLOAT )
ATTRIB( R64G64_FLOAT,         2, double, FROM_64_FLOAT, TO_64_FLOAT )
ATTRIB( R64_FLOAT,            1, double, FROM_64_FLOAT, TO_64_FLOAT )

ATTRIB( R32G32B32A32_FLOAT,   4, float, FROM_32_FLOAT, TO_32_FLOAT )
ATTRIB( R32G32B32_FLOAT,      3, float, FROM_32_FLOAT, TO_32_FLOAT )
ATTRIB( R32G32_FLOAT,         2, float, FROM_32_FLOAT, TO_32_FLOAT )
ATTRIB( R32_FLOAT,            1, float, FROM_32_FLOAT, TO_32_FLOAT )

ATTRIB( R32G32B32A32_USCALED, 4, unsigned, FROM_32_USCALED, TO_32_USCALED )
ATTRIB( R32G32B32_USCALED,    3, unsigned, FROM_32_USCALED, TO_32_USCALED )
ATTRIB( R32G32_USCALED,       2, unsigned, FROM_32_USCALED, TO_32_USCALED )
ATTRIB( R32_USCALED,          1, unsigned, FROM_32_USCALED, TO_32_USCALED )

ATTRIB( R32G32B32A32_SSCALED, 4, int, FROM_32_SSCALED, TO_32_SSCALED )
ATTRIB( R32G32B32_SSCALED,    3, int, FROM_32_SSCALED, TO_32_SSCALED )
ATTRIB( R32G32_SSCALED,       2, int, FROM_32_SSCALED, TO_32_SSCALED )
ATTRIB( R32_SSCALED,          1, int, FROM_32_SSCALED, TO_32_SSCALED )

ATTRIB( R32G32B32A32_UNORM, 4, unsigned, FROM_32_UNORM, TO_32_UNORM )
ATTRIB( R32G32B32_UNORM,    3, unsigned, FROM_32_UNORM, TO_32_UNORM )
ATTRIB( R32G32_UNORM,       2, unsigned, FROM_32_UNORM, TO_32_UNORM )
ATTRIB( R32_UNORM,          1, unsigned, FROM_32_UNORM, TO_32_UNORM )

ATTRIB( R32G32B32A32_SNORM, 4, int, FROM_32_SNORM, TO_32_SNORM )
ATTRIB( R32G32B32_SNORM,    3, int, FROM_32_SNORM, TO_32_SNORM )
ATTRIB( R32G32_SNORM,       2, int, FROM_32_SNORM, TO_32_SNORM )
ATTRIB( R32_SNORM,          1, int, FROM_32_SNORM, TO_32_SNORM )

ATTRIB( R16G16B16A16_USCALED, 4, ushort, FROM_16_USCALED, TO_16_USCALED )
ATTRIB( R16G16B16_USCALED,    3, ushort, FROM_16_USCALED, TO_16_USCALED )
ATTRIB( R16G16_USCALED,       2, ushort, FROM_16_USCALED, TO_16_USCALED )
ATTRIB( R16_USCALED,          1, ushort, FROM_16_USCALED, TO_16_USCALED )

ATTRIB( R16G16B16A16_SSCALED, 4, short, FROM_16_SSCALED, TO_16_SSCALED )
ATTRIB( R16G16B16_SSCALED,    3, short, FROM_16_SSCALED, TO_16_SSCALED )
ATTRIB( R16G16_SSCALED,       2, short, FROM_16_SSCALED, TO_16_SSCALED )
ATTRIB( R16_SSCALED,          1, short, FROM_16_SSCALED, TO_16_SSCALED )

ATTRIB( R16G16B16A16_UNORM, 4, ushort, FROM_16_UNORM, TO_16_UNORM )
ATTRIB( R16G16B16_UNORM,    3, ushort, FROM_16_UNORM, TO_16_UNORM )
ATTRIB( R16G16_UNORM,       2, ushort, FROM_16_UNORM, TO_16_UNORM )
ATTRIB( R16_UNORM,          1, ushort, FROM_16_UNORM, TO_16_UNORM )

ATTRIB( R16G16B16A16_SNORM, 4, short, FROM_16_SNORM, TO_16_SNORM )
ATTRIB( R16G16B16_SNORM,    3, short, FROM_16_SNORM, TO_16_SNORM )
ATTRIB( R16G16_SNORM,       2, short, FROM_16_SNORM, TO_16_SNORM )
ATTRIB( R16_SNORM,          1, short, FROM_16_SNORM, TO_16_SNORM )

ATTRIB( R8G8B8A8_USCALED,   4, ubyte, FROM_8_USCALED, TO_8_USCALED )
ATTRIB( R8G8B8_USCALED,     3, ubyte, FROM_8_USCALED, TO_8_USCALED )
ATTRIB( R8G8_USCALED,       2, ubyte, FROM_8_USCALED, TO_8_USCALED )
ATTRIB( R8_USCALED,         1, ubyte, FROM_8_USCALED, TO_8_USCALED )

ATTRIB( R8G8B8A8_SSCALED,  4, char, FROM_8_SSCALED, TO_8_SSCALED )
ATTRIB( R8G8B8_SSCALED,    3, char, FROM_8_SSCALED, TO_8_SSCALED )
ATTRIB( R8G8_SSCALED,      2, char, FROM_8_SSCALED, TO_8_SSCALED )
ATTRIB( R8_SSCALED,        1, char, FROM_8_SSCALED, TO_8_SSCALED )

ATTRIB( R8G8B8A8_UNORM,  4, ubyte, FROM_8_UNORM, TO_8_UNORM )
ATTRIB( R8G8B8_UNORM,    3, ubyte, FROM_8_UNORM, TO_8_UNORM )
ATTRIB( R8G8_UNORM,      2, ubyte, FROM_8_UNORM, TO_8_UNORM )
ATTRIB( R8_UNORM,        1, ubyte, FROM_8_UNORM, TO_8_UNORM )

ATTRIB( R8G8B8A8_SNORM,  4, char, FROM_8_SNORM, TO_8_SNORM )
ATTRIB( R8G8B8_SNORM,    3, char, FROM_8_SNORM, TO_8_SNORM )
ATTRIB( R8G8_SNORM,      2, char, FROM_8_SNORM, TO_8_SNORM )
ATTRIB( R8_SNORM,        1, char, FROM_8_SNORM, TO_8_SNORM )

ATTRIB( A8R8G8B8_UNORM,       4, ubyte, FROM_8_UNORM, TO_8_UNORM )
/*ATTRIB( R8G8B8A8_UNORM,       4, ubyte, FROM_8_UNORM, TO_8_UNORM )*/

ATTRIB( R32G32B32A32_FIXED,   4, int, FROM_32_FIXED, TO_32_FIXED )
ATTRIB( R32G32B32_FIXED,      3, int, FROM_32_FIXED, TO_32_FIXED )
ATTRIB( R32G32_FIXED,         2, int, FROM_32_FIXED, TO_32_FIXED )
ATTRIB( R32_FIXED,            1, int, FROM_32_FIXED, TO_32_FIXED )


d199 1
a199 1
fetch_B8G8R8A8_UNORM(const void *ptr, float *attrib)
d201 5
a205 4
   attrib[2] = FROM_8_UNORM(0);
   attrib[1] = FROM_8_UNORM(1);
   attrib[0] = FROM_8_UNORM(2);
   attrib[3] = FROM_8_UNORM(3);
a218 9
fetch_NULL( const void *ptr, float *attrib )
{
   attrib[0] = 0;
   attrib[1] = 0;
   attrib[2] = 0;
   attrib[3] = 1;
}

static void 
a223 153
static fetch_func get_fetch_func( enum pipe_format format )
{
   switch (format) {
   case PIPE_FORMAT_R64_FLOAT:
      return &fetch_R64_FLOAT;
   case PIPE_FORMAT_R64G64_FLOAT:
      return &fetch_R64G64_FLOAT;
   case PIPE_FORMAT_R64G64B64_FLOAT:
      return &fetch_R64G64B64_FLOAT;
   case PIPE_FORMAT_R64G64B64A64_FLOAT:
      return &fetch_R64G64B64A64_FLOAT;

   case PIPE_FORMAT_R32_FLOAT:
      return &fetch_R32_FLOAT;
   case PIPE_FORMAT_R32G32_FLOAT:
      return &fetch_R32G32_FLOAT;
   case PIPE_FORMAT_R32G32B32_FLOAT:
      return &fetch_R32G32B32_FLOAT;
   case PIPE_FORMAT_R32G32B32A32_FLOAT:
      return &fetch_R32G32B32A32_FLOAT;

   case PIPE_FORMAT_R32_UNORM:
      return &fetch_R32_UNORM;
   case PIPE_FORMAT_R32G32_UNORM:
      return &fetch_R32G32_UNORM;
   case PIPE_FORMAT_R32G32B32_UNORM:
      return &fetch_R32G32B32_UNORM;
   case PIPE_FORMAT_R32G32B32A32_UNORM:
      return &fetch_R32G32B32A32_UNORM;

   case PIPE_FORMAT_R32_USCALED:
      return &fetch_R32_USCALED;
   case PIPE_FORMAT_R32G32_USCALED:
      return &fetch_R32G32_USCALED;
   case PIPE_FORMAT_R32G32B32_USCALED:
      return &fetch_R32G32B32_USCALED;
   case PIPE_FORMAT_R32G32B32A32_USCALED:
      return &fetch_R32G32B32A32_USCALED;

   case PIPE_FORMAT_R32_SNORM:
      return &fetch_R32_SNORM;
   case PIPE_FORMAT_R32G32_SNORM:
      return &fetch_R32G32_SNORM;
   case PIPE_FORMAT_R32G32B32_SNORM:
      return &fetch_R32G32B32_SNORM;
   case PIPE_FORMAT_R32G32B32A32_SNORM:
      return &fetch_R32G32B32A32_SNORM;

   case PIPE_FORMAT_R32_SSCALED:
      return &fetch_R32_SSCALED;
   case PIPE_FORMAT_R32G32_SSCALED:
      return &fetch_R32G32_SSCALED;
   case PIPE_FORMAT_R32G32B32_SSCALED:
      return &fetch_R32G32B32_SSCALED;
   case PIPE_FORMAT_R32G32B32A32_SSCALED:
      return &fetch_R32G32B32A32_SSCALED;

   case PIPE_FORMAT_R16_UNORM:
      return &fetch_R16_UNORM;
   case PIPE_FORMAT_R16G16_UNORM:
      return &fetch_R16G16_UNORM;
   case PIPE_FORMAT_R16G16B16_UNORM:
      return &fetch_R16G16B16_UNORM;
   case PIPE_FORMAT_R16G16B16A16_UNORM:
      return &fetch_R16G16B16A16_UNORM;

   case PIPE_FORMAT_R16_USCALED:
      return &fetch_R16_USCALED;
   case PIPE_FORMAT_R16G16_USCALED:
      return &fetch_R16G16_USCALED;
   case PIPE_FORMAT_R16G16B16_USCALED:
      return &fetch_R16G16B16_USCALED;
   case PIPE_FORMAT_R16G16B16A16_USCALED:
      return &fetch_R16G16B16A16_USCALED;

   case PIPE_FORMAT_R16_SNORM:
      return &fetch_R16_SNORM;
   case PIPE_FORMAT_R16G16_SNORM:
      return &fetch_R16G16_SNORM;
   case PIPE_FORMAT_R16G16B16_SNORM:
      return &fetch_R16G16B16_SNORM;
   case PIPE_FORMAT_R16G16B16A16_SNORM:
      return &fetch_R16G16B16A16_SNORM;

   case PIPE_FORMAT_R16_SSCALED:
      return &fetch_R16_SSCALED;
   case PIPE_FORMAT_R16G16_SSCALED:
      return &fetch_R16G16_SSCALED;
   case PIPE_FORMAT_R16G16B16_SSCALED:
      return &fetch_R16G16B16_SSCALED;
   case PIPE_FORMAT_R16G16B16A16_SSCALED:
      return &fetch_R16G16B16A16_SSCALED;

   case PIPE_FORMAT_R8_UNORM:
      return &fetch_R8_UNORM;
   case PIPE_FORMAT_R8G8_UNORM:
      return &fetch_R8G8_UNORM;
   case PIPE_FORMAT_R8G8B8_UNORM:
      return &fetch_R8G8B8_UNORM;
   case PIPE_FORMAT_R8G8B8A8_UNORM:
      return &fetch_R8G8B8A8_UNORM;

   case PIPE_FORMAT_R8_USCALED:
      return &fetch_R8_USCALED;
   case PIPE_FORMAT_R8G8_USCALED:
      return &fetch_R8G8_USCALED;
   case PIPE_FORMAT_R8G8B8_USCALED:
      return &fetch_R8G8B8_USCALED;
   case PIPE_FORMAT_R8G8B8A8_USCALED:
      return &fetch_R8G8B8A8_USCALED;

   case PIPE_FORMAT_R8_SNORM:
      return &fetch_R8_SNORM;
   case PIPE_FORMAT_R8G8_SNORM:
      return &fetch_R8G8_SNORM;
   case PIPE_FORMAT_R8G8B8_SNORM:
      return &fetch_R8G8B8_SNORM;
   case PIPE_FORMAT_R8G8B8A8_SNORM:
      return &fetch_R8G8B8A8_SNORM;

   case PIPE_FORMAT_R8_SSCALED:
      return &fetch_R8_SSCALED;
   case PIPE_FORMAT_R8G8_SSCALED:
      return &fetch_R8G8_SSCALED;
   case PIPE_FORMAT_R8G8B8_SSCALED:
      return &fetch_R8G8B8_SSCALED;
   case PIPE_FORMAT_R8G8B8A8_SSCALED:
      return &fetch_R8G8B8A8_SSCALED;

   case PIPE_FORMAT_B8G8R8A8_UNORM:
      return &fetch_A8R8G8B8_UNORM;

   case PIPE_FORMAT_A8R8G8B8_UNORM:
      return &fetch_B8G8R8A8_UNORM;

   case PIPE_FORMAT_R32_FIXED:
      return &fetch_R32_FIXED;
   case PIPE_FORMAT_R32G32_FIXED:
      return &fetch_R32G32_FIXED;
   case PIPE_FORMAT_R32G32B32_FIXED:
      return &fetch_R32G32B32_FIXED;
   case PIPE_FORMAT_R32G32B32A32_FIXED:
      return &fetch_R32G32B32A32_FIXED;

   default:
      assert(0); 
      return &fetch_NULL;
   }
}




a225 6
   /* silence warnings */
   (void) emit_R32G32B32A32_FIXED;
   (void) emit_R32G32B32_FIXED;
   (void) emit_R32G32_FIXED;
   (void) emit_R32_FIXED;

d354 1
a354 1
      return &emit_A8R8G8B8_UNORM;
d357 1
a357 1
      return &emit_B8G8R8A8_UNORM;
d365 16
d382 42
a435 2
   unsigned nr_attrs = tg->nr_attrib;
   unsigned attr;
a437 2
   /* loop over vertex attributes (vertex shader inputs)
    */
d439 4
a442 1
      unsigned elt = *elts++;
d444 9
a452 3
      for (attr = 0; attr < nr_attrs; attr++) {
	 float data[4];
         const char *src;
d454 5
a458 2
	 char *dst = (vert + 
		      tg->attrib[attr].output_offset);
d460 9
a468 8
         if (tg->attrib[attr].instance_divisor) {
            src = tg->attrib[attr].input_ptr +
                  tg->attrib[attr].input_stride *
                  (instance_id / tg->attrib[attr].instance_divisor);
         } else {
            src = tg->attrib[attr].input_ptr +
                  tg->attrib[attr].input_stride * elt;
         }
d470 2
a471 8
	 tg->attrib[attr].fetch( src, data );

         if (0) debug_printf("vert %d/%d attr %d: %f %f %f %f\n",
                             i, elt, attr, data[0], data[1], data[2], data[3]);

	 tg->attrib[attr].emit( data, dst );
      }
      
a475 2


a483 2
   unsigned nr_attrs = tg->nr_attrib;
   unsigned attr;
a485 2
   /* loop over vertex attributes (vertex shader inputs)
    */
d487 1
a487 31
      unsigned elt = start + i;

      for (attr = 0; attr < nr_attrs; attr++) {
	 float data[4];

	 char *dst = (vert + 
		      tg->attrib[attr].output_offset);

         if (tg->attrib[attr].type == TRANSLATE_ELEMENT_NORMAL) {
            const char *src;

            if (tg->attrib[attr].instance_divisor) {
               src = tg->attrib[attr].input_ptr +
                     tg->attrib[attr].input_stride *
                     (instance_id / tg->attrib[attr].instance_divisor);
            } else {
               src = tg->attrib[attr].input_ptr +
                     tg->attrib[attr].input_stride * elt;
            }

            tg->attrib[attr].fetch( src, data );
         } else {
            data[0] = (float)instance_id;
         }

         if (0) debug_printf("vert %d attr %d: %f %f %f %f\n",
                             i, attr, data[0], data[1], data[2], data[3]);

	 tg->attrib[attr].emit( data, dst );
      }
      
d497 2
a498 1
				unsigned stride )
d505 1
a505 1
	 tg->attrib[i].input_ptr = ((char *)ptr +
d508 1
d533 2
d538 6
d546 1
a546 1
      tg->attrib[i].fetch = get_fetch_func(key->element[i].input_format);
a550 1
      tg->attrib[i].emit = get_emit_func(key->element[i].output_format);
d553 20
d579 80
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a33 2
#include "util/u_format.h"
#include "util/u_math.h"
d40 1
a40 3
typedef void (*fetch_func)(float *dst,
                           const uint8_t *src,
                           unsigned i, unsigned j);
d59 1
a59 1
      const uint8_t *input_ptr;
a60 9
      unsigned max_index;

      /* this value is set to -1 if this is a normal element with output_format != input_format:
       * in this case, u_format is used to do a full conversion
       *
       * this value is set to the format size in bytes if output_format == input_format or for 32-bit instance ids:
       * in this case, memcpy is used to copy this amount of bytes
       */
      int copy_size;
d80 16
a95 1
#define ATTRIB( NAME, SZ, TYPE, TO )	    	        \
d108 21
d151 80
a230 69
ATTRIB( R64G64B64A64_FLOAT,   4, double, TO_64_FLOAT )
ATTRIB( R64G64B64_FLOAT,      3, double, TO_64_FLOAT )
ATTRIB( R64G64_FLOAT,         2, double, TO_64_FLOAT )
ATTRIB( R64_FLOAT,            1, double, TO_64_FLOAT )

ATTRIB( R32G32B32A32_FLOAT,   4, float, TO_32_FLOAT )
ATTRIB( R32G32B32_FLOAT,      3, float, TO_32_FLOAT )
ATTRIB( R32G32_FLOAT,         2, float, TO_32_FLOAT )
ATTRIB( R32_FLOAT,            1, float, TO_32_FLOAT )

ATTRIB( R32G32B32A32_USCALED, 4, unsigned, TO_32_USCALED )
ATTRIB( R32G32B32_USCALED,    3, unsigned, TO_32_USCALED )
ATTRIB( R32G32_USCALED,       2, unsigned, TO_32_USCALED )
ATTRIB( R32_USCALED,          1, unsigned, TO_32_USCALED )

ATTRIB( R32G32B32A32_SSCALED, 4, int, TO_32_SSCALED )
ATTRIB( R32G32B32_SSCALED,    3, int, TO_32_SSCALED )
ATTRIB( R32G32_SSCALED,       2, int, TO_32_SSCALED )
ATTRIB( R32_SSCALED,          1, int, TO_32_SSCALED )

ATTRIB( R32G32B32A32_UNORM, 4, unsigned, TO_32_UNORM )
ATTRIB( R32G32B32_UNORM,    3, unsigned, TO_32_UNORM )
ATTRIB( R32G32_UNORM,       2, unsigned, TO_32_UNORM )
ATTRIB( R32_UNORM,          1, unsigned, TO_32_UNORM )

ATTRIB( R32G32B32A32_SNORM, 4, int, TO_32_SNORM )
ATTRIB( R32G32B32_SNORM,    3, int, TO_32_SNORM )
ATTRIB( R32G32_SNORM,       2, int, TO_32_SNORM )
ATTRIB( R32_SNORM,          1, int, TO_32_SNORM )

ATTRIB( R16G16B16A16_USCALED, 4, ushort, TO_16_USCALED )
ATTRIB( R16G16B16_USCALED,    3, ushort, TO_16_USCALED )
ATTRIB( R16G16_USCALED,       2, ushort, TO_16_USCALED )
ATTRIB( R16_USCALED,          1, ushort, TO_16_USCALED )

ATTRIB( R16G16B16A16_SSCALED, 4, short, TO_16_SSCALED )
ATTRIB( R16G16B16_SSCALED,    3, short, TO_16_SSCALED )
ATTRIB( R16G16_SSCALED,       2, short, TO_16_SSCALED )
ATTRIB( R16_SSCALED,          1, short, TO_16_SSCALED )

ATTRIB( R16G16B16A16_UNORM, 4, ushort, TO_16_UNORM )
ATTRIB( R16G16B16_UNORM,    3, ushort, TO_16_UNORM )
ATTRIB( R16G16_UNORM,       2, ushort, TO_16_UNORM )
ATTRIB( R16_UNORM,          1, ushort, TO_16_UNORM )

ATTRIB( R16G16B16A16_SNORM, 4, short, TO_16_SNORM )
ATTRIB( R16G16B16_SNORM,    3, short, TO_16_SNORM )
ATTRIB( R16G16_SNORM,       2, short, TO_16_SNORM )
ATTRIB( R16_SNORM,          1, short, TO_16_SNORM )

ATTRIB( R8G8B8A8_USCALED,   4, ubyte, TO_8_USCALED )
ATTRIB( R8G8B8_USCALED,     3, ubyte, TO_8_USCALED )
ATTRIB( R8G8_USCALED,       2, ubyte, TO_8_USCALED )
ATTRIB( R8_USCALED,         1, ubyte, TO_8_USCALED )

ATTRIB( R8G8B8A8_SSCALED,  4, char, TO_8_SSCALED )
ATTRIB( R8G8B8_SSCALED,    3, char, TO_8_SSCALED )
ATTRIB( R8G8_SSCALED,      2, char, TO_8_SSCALED )
ATTRIB( R8_SSCALED,        1, char, TO_8_SSCALED )

ATTRIB( R8G8B8A8_UNORM,  4, ubyte, TO_8_UNORM )
ATTRIB( R8G8B8_UNORM,    3, ubyte, TO_8_UNORM )
ATTRIB( R8G8_UNORM,      2, ubyte, TO_8_UNORM )
ATTRIB( R8_UNORM,        1, ubyte, TO_8_UNORM )

ATTRIB( R8G8B8A8_SNORM,  4, char, TO_8_SNORM )
ATTRIB( R8G8B8_SNORM,    3, char, TO_8_SNORM )
ATTRIB( R8G8_SNORM,      2, char, TO_8_SNORM )
ATTRIB( R8_SNORM,        1, char, TO_8_SNORM )
d233 1
a233 1
emit_A8R8G8B8_UNORM( const float *attrib, void *ptr)
d235 4
a238 5
   ubyte *out = (ubyte *)ptr;
   out[0] = TO_8_UNORM(attrib[3]);
   out[1] = TO_8_UNORM(attrib[0]);
   out[2] = TO_8_UNORM(attrib[1]);
   out[3] = TO_8_UNORM(attrib[2]);
d252 9
d266 153
d421 6
d555 1
a555 1
      return &emit_B8G8R8A8_UNORM;
d558 1
a558 1
      return &emit_A8R8G8B8_UNORM;
a565 16
static ALWAYS_INLINE void PIPE_CDECL generic_run_one( struct translate_generic *tg,
                                         unsigned elt,
                                         unsigned instance_id,
                                         void *vert )
{
   unsigned nr_attrs = tg->nr_attrib;
   unsigned attr;

   for (attr = 0; attr < nr_attrs; attr++) {
      float data[4];
      uint8_t *dst = (uint8_t *)vert + tg->attrib[attr].output_offset;

      if (tg->attrib[attr].type == TRANSLATE_ELEMENT_NORMAL) {
         const uint8_t *src;
         unsigned index;
         int copy_size;
a566 42
         if (tg->attrib[attr].instance_divisor) {
            index = instance_id / tg->attrib[attr].instance_divisor;
         }
         else {
            index = elt;
         }

         /* clamp to void going out of bounds */
         index = MIN2(index, tg->attrib[attr].max_index);

         src = tg->attrib[attr].input_ptr +
               tg->attrib[attr].input_stride * index;

         copy_size = tg->attrib[attr].copy_size;
         if(likely(copy_size >= 0))
            memcpy(dst, src, copy_size);
         else
         {
            tg->attrib[attr].fetch( data, src, 0, 0 );

            if (0)
               debug_printf("Fetch linear attr %d  from %p  stride %d  index %d: "
                         " %f, %f, %f, %f \n",
                         attr,
                         tg->attrib[attr].input_ptr,
                         tg->attrib[attr].input_stride,
                         index,
                         data[0], data[1],data[2], data[3]);

            tg->attrib[attr].emit( data, dst );
         }
      } else {
         if(likely(tg->attrib[attr].copy_size >= 0))
            memcpy(data, &instance_id, 4);
         else
         {
            data[0] = (float)instance_id;
            tg->attrib[attr].emit( data, dst );
         }
      }
   }
}
d579 2
d583 2
d586 19
a604 4
      generic_run_one(tg, *elts++, instance_id, vert);
      vert += tg->translate.key.output_stride;
   }
}
d606 2
a607 9
static void PIPE_CDECL generic_run_elts16( struct translate *translate,
                                         const uint16_t *elts,
                                         unsigned count,
                                         unsigned instance_id,
                                         void *output_buffer )
{
   struct translate_generic *tg = translate_generic(translate);
   char *vert = output_buffer;
   unsigned i;
d609 3
a611 2
   for (i = 0; i < count; i++) {
      generic_run_one(tg, *elts++, instance_id, vert);
a615 9
static void PIPE_CDECL generic_run_elts8( struct translate *translate,
                                         const uint8_t *elts,
                                         unsigned count,
                                         unsigned instance_id,
                                         void *output_buffer )
{
   struct translate_generic *tg = translate_generic(translate);
   char *vert = output_buffer;
   unsigned i;
a616 5
   for (i = 0; i < count; i++) {
      generic_run_one(tg, *elts++, instance_id, vert);
      vert += tg->translate.key.output_stride;
   }
}
d626 2
d630 2
d633 31
a663 1
      generic_run_one(tg, start + i, instance_id, vert);
d673 1
a673 2
				unsigned stride,
				unsigned max_index )
d680 1
a680 1
	 tg->attrib[i].input_ptr = ((const uint8_t *)ptr +
a682 1
         tg->attrib[i].max_index = max_index;
a706 2
   tg->translate.run_elts16 = generic_run_elts16;
   tg->translate.run_elts8 = generic_run_elts8;
a709 6
      const struct util_format_description *format_desc =
            util_format_description(key->element[i].input_format);

      assert(format_desc);
      assert(format_desc->fetch_rgba_float);

d712 1
a712 1
      tg->attrib[i].fetch = format_desc->fetch_rgba_float;
d717 1
a719 20
      tg->attrib[i].copy_size = -1;
      if (tg->attrib[i].type == TRANSLATE_ELEMENT_INSTANCE_ID)
      {
            if(key->element[i].output_format == PIPE_FORMAT_R32_USCALED
                  || key->element[i].output_format == PIPE_FORMAT_R32_SSCALED)
               tg->attrib[i].copy_size = 4;
      }
      else
      {
         if(key->element[i].input_format == key->element[i].output_format
               && format_desc->block.width == 1
               && format_desc->block.height == 1
               && !(format_desc->block.bits & 7))
            tg->attrib[i].copy_size = format_desc->block.bits >> 3;
      }

      if(tg->attrib[i].copy_size < 0)
	      tg->attrib[i].emit = get_emit_func(key->element[i].output_format);
      else
	      tg->attrib[i].emit  = NULL;
a725 80
}

boolean translate_generic_is_output_format_supported(enum pipe_format format)
{
   switch(format)
   {
   case PIPE_FORMAT_R64G64B64A64_FLOAT: return TRUE;
   case PIPE_FORMAT_R64G64B64_FLOAT: return TRUE;
   case PIPE_FORMAT_R64G64_FLOAT: return TRUE;
   case PIPE_FORMAT_R64_FLOAT: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_FLOAT: return TRUE;
   case PIPE_FORMAT_R32G32B32_FLOAT: return TRUE;
   case PIPE_FORMAT_R32G32_FLOAT: return TRUE;
   case PIPE_FORMAT_R32_FLOAT: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_USCALED: return TRUE;
   case PIPE_FORMAT_R32G32B32_USCALED: return TRUE;
   case PIPE_FORMAT_R32G32_USCALED: return TRUE;
   case PIPE_FORMAT_R32_USCALED: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_SSCALED: return TRUE;
   case PIPE_FORMAT_R32G32B32_SSCALED: return TRUE;
   case PIPE_FORMAT_R32G32_SSCALED: return TRUE;
   case PIPE_FORMAT_R32_SSCALED: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_UNORM: return TRUE;
   case PIPE_FORMAT_R32G32B32_UNORM: return TRUE;
   case PIPE_FORMAT_R32G32_UNORM: return TRUE;
   case PIPE_FORMAT_R32_UNORM: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_SNORM: return TRUE;
   case PIPE_FORMAT_R32G32B32_SNORM: return TRUE;
   case PIPE_FORMAT_R32G32_SNORM: return TRUE;
   case PIPE_FORMAT_R32_SNORM: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_USCALED: return TRUE;
   case PIPE_FORMAT_R16G16B16_USCALED: return TRUE;
   case PIPE_FORMAT_R16G16_USCALED: return TRUE;
   case PIPE_FORMAT_R16_USCALED: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_SSCALED: return TRUE;
   case PIPE_FORMAT_R16G16B16_SSCALED: return TRUE;
   case PIPE_FORMAT_R16G16_SSCALED: return TRUE;
   case PIPE_FORMAT_R16_SSCALED: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_UNORM: return TRUE;
   case PIPE_FORMAT_R16G16B16_UNORM: return TRUE;
   case PIPE_FORMAT_R16G16_UNORM: return TRUE;
   case PIPE_FORMAT_R16_UNORM: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_SNORM: return TRUE;
   case PIPE_FORMAT_R16G16B16_SNORM: return TRUE;
   case PIPE_FORMAT_R16G16_SNORM: return TRUE;
   case PIPE_FORMAT_R16_SNORM: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_USCALED: return TRUE;
   case PIPE_FORMAT_R8G8B8_USCALED: return TRUE;
   case PIPE_FORMAT_R8G8_USCALED: return TRUE;
   case PIPE_FORMAT_R8_USCALED: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_SSCALED: return TRUE;
   case PIPE_FORMAT_R8G8B8_SSCALED: return TRUE;
   case PIPE_FORMAT_R8G8_SSCALED: return TRUE;
   case PIPE_FORMAT_R8_SSCALED: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_UNORM: return TRUE;
   case PIPE_FORMAT_R8G8B8_UNORM: return TRUE;
   case PIPE_FORMAT_R8G8_UNORM: return TRUE;
   case PIPE_FORMAT_R8_UNORM: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_SNORM: return TRUE;
   case PIPE_FORMAT_R8G8B8_SNORM: return TRUE;
   case PIPE_FORMAT_R8G8_SNORM: return TRUE;
   case PIPE_FORMAT_R8_SNORM: return TRUE;

   case PIPE_FORMAT_A8R8G8B8_UNORM: return TRUE;
   case PIPE_FORMAT_B8G8R8A8_UNORM: return TRUE;
   default: return FALSE;
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a34 1
#include "util/u_half.h"
d42 1
a42 1
typedef void (*fetch_func)(void *dst,
d45 1
a45 1
typedef void (*emit_func)(const void *attrib, void *ptr);
d87 1
a87 1
 * Fetch a dword[4] vertex attribute from memory, doing format/type
d93 1
a93 1
#define ATTRIB( NAME, SZ, SRCTYPE, DSTTYPE, TO )        \
d95 1
a95 1
emit_##NAME(const void *attrib, void *ptr)		\
d98 1
a98 2
   SRCTYPE *in = (SRCTYPE *)attrib;                     \
   DSTTYPE *out = (DSTTYPE *)ptr;			\
d101 1
a101 1
      out[i] = TO(in[i]);				\
a107 1
#define TO_16_FLOAT(x)   util_float_to_half(x)
a126 1
#define TO_INT(x)        (x)
d128 69
a196 105

ATTRIB( R64G64B64A64_FLOAT,   4, float, double, TO_64_FLOAT )
ATTRIB( R64G64B64_FLOAT,      3, float, double, TO_64_FLOAT )
ATTRIB( R64G64_FLOAT,         2, float, double, TO_64_FLOAT )
ATTRIB( R64_FLOAT,            1, float, double, TO_64_FLOAT )

ATTRIB( R32G32B32A32_FLOAT,   4, float, float, TO_32_FLOAT )
ATTRIB( R32G32B32_FLOAT,      3, float, float, TO_32_FLOAT )
ATTRIB( R32G32_FLOAT,         2, float, float, TO_32_FLOAT )
ATTRIB( R32_FLOAT,            1, float, float, TO_32_FLOAT )

ATTRIB( R16G16B16A16_FLOAT,   4, float, ushort, TO_16_FLOAT )
ATTRIB( R16G16B16_FLOAT,      3, float, ushort, TO_16_FLOAT )
ATTRIB( R16G16_FLOAT,         2, float, ushort, TO_16_FLOAT )
ATTRIB( R16_FLOAT,            1, float, ushort, TO_16_FLOAT )

ATTRIB( R32G32B32A32_USCALED, 4, float, unsigned, TO_32_USCALED )
ATTRIB( R32G32B32_USCALED,    3, float, unsigned, TO_32_USCALED )
ATTRIB( R32G32_USCALED,       2, float, unsigned, TO_32_USCALED )
ATTRIB( R32_USCALED,          1, float, unsigned, TO_32_USCALED )

ATTRIB( R32G32B32A32_SSCALED, 4, float, int, TO_32_SSCALED )
ATTRIB( R32G32B32_SSCALED,    3, float, int, TO_32_SSCALED )
ATTRIB( R32G32_SSCALED,       2, float, int, TO_32_SSCALED )
ATTRIB( R32_SSCALED,          1, float, int, TO_32_SSCALED )

ATTRIB( R32G32B32A32_UNORM, 4, float, unsigned, TO_32_UNORM )
ATTRIB( R32G32B32_UNORM,    3, float, unsigned, TO_32_UNORM )
ATTRIB( R32G32_UNORM,       2, float, unsigned, TO_32_UNORM )
ATTRIB( R32_UNORM,          1, float, unsigned, TO_32_UNORM )

ATTRIB( R32G32B32A32_SNORM, 4, float, int, TO_32_SNORM )
ATTRIB( R32G32B32_SNORM,    3, float, int, TO_32_SNORM )
ATTRIB( R32G32_SNORM,       2, float, int, TO_32_SNORM )
ATTRIB( R32_SNORM,          1, float, int, TO_32_SNORM )

ATTRIB( R16G16B16A16_USCALED, 4, float, ushort, TO_16_USCALED )
ATTRIB( R16G16B16_USCALED,    3, float, ushort, TO_16_USCALED )
ATTRIB( R16G16_USCALED,       2, float, ushort, TO_16_USCALED )
ATTRIB( R16_USCALED,          1, float, ushort, TO_16_USCALED )

ATTRIB( R16G16B16A16_SSCALED, 4, float, short, TO_16_SSCALED )
ATTRIB( R16G16B16_SSCALED,    3, float, short, TO_16_SSCALED )
ATTRIB( R16G16_SSCALED,       2, float, short, TO_16_SSCALED )
ATTRIB( R16_SSCALED,          1, float, short, TO_16_SSCALED )

ATTRIB( R16G16B16A16_UNORM, 4, float, ushort, TO_16_UNORM )
ATTRIB( R16G16B16_UNORM,    3, float, ushort, TO_16_UNORM )
ATTRIB( R16G16_UNORM,       2, float, ushort, TO_16_UNORM )
ATTRIB( R16_UNORM,          1, float, ushort, TO_16_UNORM )

ATTRIB( R16G16B16A16_SNORM, 4, float, short, TO_16_SNORM )
ATTRIB( R16G16B16_SNORM,    3, float, short, TO_16_SNORM )
ATTRIB( R16G16_SNORM,       2, float, short, TO_16_SNORM )
ATTRIB( R16_SNORM,          1, float, short, TO_16_SNORM )

ATTRIB( R8G8B8A8_USCALED,   4, float, ubyte, TO_8_USCALED )
ATTRIB( R8G8B8_USCALED,     3, float, ubyte, TO_8_USCALED )
ATTRIB( R8G8_USCALED,       2, float, ubyte, TO_8_USCALED )
ATTRIB( R8_USCALED,         1, float, ubyte, TO_8_USCALED )

ATTRIB( R8G8B8A8_SSCALED,  4, float, char, TO_8_SSCALED )
ATTRIB( R8G8B8_SSCALED,    3, float, char, TO_8_SSCALED )
ATTRIB( R8G8_SSCALED,      2, float, char, TO_8_SSCALED )
ATTRIB( R8_SSCALED,        1, float, char, TO_8_SSCALED )

ATTRIB( R8G8B8A8_UNORM,  4, float, ubyte, TO_8_UNORM )
ATTRIB( R8G8B8_UNORM,    3, float, ubyte, TO_8_UNORM )
ATTRIB( R8G8_UNORM,      2, float, ubyte, TO_8_UNORM )
ATTRIB( R8_UNORM,        1, float, ubyte, TO_8_UNORM )

ATTRIB( R8G8B8A8_SNORM,  4, float, char, TO_8_SNORM )
ATTRIB( R8G8B8_SNORM,    3, float, char, TO_8_SNORM )
ATTRIB( R8G8_SNORM,      2, float, char, TO_8_SNORM )
ATTRIB( R8_SNORM,        1, float, char, TO_8_SNORM )

ATTRIB( R32G32B32A32_UINT, 4, uint32_t, unsigned, TO_INT )
ATTRIB( R32G32B32_UINT,    3, uint32_t, unsigned, TO_INT )
ATTRIB( R32G32_UINT,       2, uint32_t, unsigned, TO_INT )
ATTRIB( R32_UINT,          1, uint32_t, unsigned, TO_INT )

ATTRIB( R16G16B16A16_UINT, 4, uint32_t, ushort, TO_INT )
ATTRIB( R16G16B16_UINT,    3, uint32_t, ushort, TO_INT )
ATTRIB( R16G16_UINT,       2, uint32_t, ushort, TO_INT )
ATTRIB( R16_UINT,          1, uint32_t, ushort, TO_INT )

ATTRIB( R8G8B8A8_UINT,   4, uint32_t, ubyte, TO_INT )
ATTRIB( R8G8B8_UINT,     3, uint32_t, ubyte, TO_INT )
ATTRIB( R8G8_UINT,       2, uint32_t, ubyte, TO_INT )
ATTRIB( R8_UINT,         1, uint32_t, ubyte, TO_INT )

ATTRIB( R32G32B32A32_SINT, 4, int32_t, int, TO_INT )
ATTRIB( R32G32B32_SINT,    3, int32_t, int, TO_INT )
ATTRIB( R32G32_SINT,       2, int32_t, int, TO_INT )
ATTRIB( R32_SINT,          1, int32_t, int, TO_INT )

ATTRIB( R16G16B16A16_SINT, 4, int32_t, short, TO_INT )
ATTRIB( R16G16B16_SINT,    3, int32_t, short, TO_INT )
ATTRIB( R16G16_SINT,       2, int32_t, short, TO_INT )
ATTRIB( R16_SINT,          1, int32_t, short, TO_INT )

ATTRIB( R8G8B8A8_SINT,   4, int32_t, char, TO_INT )
ATTRIB( R8G8B8_SINT,     3, int32_t, char, TO_INT )
ATTRIB( R8G8_SINT,       2, int32_t, char, TO_INT )
ATTRIB( R8_SINT,         1, int32_t, char, TO_INT )
d199 1
a199 1
emit_A8R8G8B8_UNORM( const void *attrib, void *ptr)
a200 1
   float *in = (float *)attrib;
d202 4
a205 4
   out[0] = TO_8_UNORM(in[3]);
   out[1] = TO_8_UNORM(in[0]);
   out[2] = TO_8_UNORM(in[1]);
   out[3] = TO_8_UNORM(in[2]);
d209 1
a209 1
emit_B8G8R8A8_UNORM( const void *attrib, void *ptr)
a210 1
   float *in = (float *)attrib;
d212 4
a215 124
   out[2] = TO_8_UNORM(in[0]);
   out[1] = TO_8_UNORM(in[1]);
   out[0] = TO_8_UNORM(in[2]);
   out[3] = TO_8_UNORM(in[3]);
}

static void
emit_B10G10R10A2_UNORM( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= ((uint32_t)(CLAMP(src[2], 0, 1) * 0x3ff)) & 0x3ff;
   value |= (((uint32_t)(CLAMP(src[1], 0, 1) * 0x3ff)) & 0x3ff) << 10;
   value |= (((uint32_t)(CLAMP(src[0], 0, 1) * 0x3ff)) & 0x3ff) << 20;
   value |= ((uint32_t)(CLAMP(src[3], 0, 1) * 0x3)) << 30;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_B10G10R10A2_USCALED( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= ((uint32_t)CLAMP(src[2], 0, 1023)) & 0x3ff;
   value |= (((uint32_t)CLAMP(src[1], 0, 1023)) & 0x3ff) << 10;
   value |= (((uint32_t)CLAMP(src[0], 0, 1023)) & 0x3ff) << 20;
   value |= ((uint32_t)CLAMP(src[3], 0, 3)) << 30;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_B10G10R10A2_SNORM( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= (uint32_t)(((uint32_t)(CLAMP(src[2], -1, 1) * 0x1ff)) & 0x3ff) ;
   value |= (uint32_t)((((uint32_t)(CLAMP(src[1], -1, 1) * 0x1ff)) & 0x3ff) << 10) ;
   value |= (uint32_t)((((uint32_t)(CLAMP(src[0], -1, 1) * 0x1ff)) & 0x3ff) << 20) ;
   value |= (uint32_t)(((uint32_t)(CLAMP(src[3], -1, 1) * 0x1)) << 30) ;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_B10G10R10A2_SSCALED( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= (uint32_t)(((uint32_t)CLAMP(src[2], -512, 511)) & 0x3ff) ;
   value |= (uint32_t)((((uint32_t)CLAMP(src[1], -512, 511)) & 0x3ff) << 10) ;
   value |= (uint32_t)((((uint32_t)CLAMP(src[0], -512, 511)) & 0x3ff) << 20) ;
   value |= (uint32_t)(((uint32_t)CLAMP(src[3], -2, 1)) << 30) ;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_R10G10B10A2_UNORM( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= ((uint32_t)(CLAMP(src[0], 0, 1) * 0x3ff)) & 0x3ff;
   value |= (((uint32_t)(CLAMP(src[1], 0, 1) * 0x3ff)) & 0x3ff) << 10;
   value |= (((uint32_t)(CLAMP(src[2], 0, 1) * 0x3ff)) & 0x3ff) << 20;
   value |= ((uint32_t)(CLAMP(src[3], 0, 1) * 0x3)) << 30;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_R10G10B10A2_USCALED( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= ((uint32_t)CLAMP(src[0], 0, 1023)) & 0x3ff;
   value |= (((uint32_t)CLAMP(src[1], 0, 1023)) & 0x3ff) << 10;
   value |= (((uint32_t)CLAMP(src[2], 0, 1023)) & 0x3ff) << 20;
   value |= ((uint32_t)CLAMP(src[3], 0, 3)) << 30;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_R10G10B10A2_SNORM( const void *attrib, void *ptr )
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= (uint32_t)(((uint32_t)(CLAMP(src[0], -1, 1) * 0x1ff)) & 0x3ff) ;
   value |= (uint32_t)((((uint32_t)(CLAMP(src[1], -1, 1) * 0x1ff)) & 0x3ff) << 10) ;
   value |= (uint32_t)((((uint32_t)(CLAMP(src[2], -1, 1) * 0x1ff)) & 0x3ff) << 20) ;
   value |= (uint32_t)(((uint32_t)(CLAMP(src[3], -1, 1) * 0x1)) << 30) ;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
}

static void
emit_R10G10B10A2_SSCALED( const void *attrib, void *ptr)
{
   float *src = (float *)ptr;
   uint32_t value = 0;
   value |= (uint32_t)(((uint32_t)CLAMP(src[0], -512, 511)) & 0x3ff) ;
   value |= (uint32_t)((((uint32_t)CLAMP(src[1], -512, 511)) & 0x3ff) << 10) ;
   value |= (uint32_t)((((uint32_t)CLAMP(src[2], -512, 511)) & 0x3ff) << 20) ;
   value |= (uint32_t)(((uint32_t)CLAMP(src[3], -2, 1)) << 30) ;
#ifdef PIPE_ARCH_BIG_ENDIAN
   value = util_bswap32(value);
#endif
   *(uint32_t *)attrib = value;
d219 1
a219 1
emit_NULL( const void *attrib, void *ptr )
a244 9
   case PIPE_FORMAT_R16_FLOAT:
      return &emit_R16_FLOAT;
   case PIPE_FORMAT_R16G16_FLOAT:
      return &emit_R16G16_FLOAT;
   case PIPE_FORMAT_R16G16B16_FLOAT:
      return &emit_R16G16B16_FLOAT;
   case PIPE_FORMAT_R16G16B16A16_FLOAT:
      return &emit_R16G16B16A16_FLOAT;

a358 72
   case PIPE_FORMAT_R32_UINT:
      return &emit_R32_UINT;
   case PIPE_FORMAT_R32G32_UINT:
      return &emit_R32G32_UINT;
   case PIPE_FORMAT_R32G32B32_UINT:
      return &emit_R32G32B32_UINT;
   case PIPE_FORMAT_R32G32B32A32_UINT:
      return &emit_R32G32B32A32_UINT;

   case PIPE_FORMAT_R16_UINT:
      return &emit_R16_UINT;
   case PIPE_FORMAT_R16G16_UINT:
      return &emit_R16G16_UINT;
   case PIPE_FORMAT_R16G16B16_UINT:
      return &emit_R16G16B16_UINT;
   case PIPE_FORMAT_R16G16B16A16_UINT:
      return &emit_R16G16B16A16_UINT;

   case PIPE_FORMAT_R8_UINT:
      return &emit_R8_UINT;
   case PIPE_FORMAT_R8G8_UINT:
      return &emit_R8G8_UINT;
   case PIPE_FORMAT_R8G8B8_UINT:
      return &emit_R8G8B8_UINT;
   case PIPE_FORMAT_R8G8B8A8_UINT:
      return &emit_R8G8B8A8_UINT;

   case PIPE_FORMAT_R32_SINT:
      return &emit_R32_SINT;
   case PIPE_FORMAT_R32G32_SINT:
      return &emit_R32G32_SINT;
   case PIPE_FORMAT_R32G32B32_SINT:
      return &emit_R32G32B32_SINT;
   case PIPE_FORMAT_R32G32B32A32_SINT:
      return &emit_R32G32B32A32_SINT;

   case PIPE_FORMAT_R16_SINT:
      return &emit_R16_SINT;
   case PIPE_FORMAT_R16G16_SINT:
      return &emit_R16G16_SINT;
   case PIPE_FORMAT_R16G16B16_SINT:
      return &emit_R16G16B16_SINT;
   case PIPE_FORMAT_R16G16B16A16_SINT:
      return &emit_R16G16B16A16_SINT;

   case PIPE_FORMAT_R8_SINT:
      return &emit_R8_SINT;
   case PIPE_FORMAT_R8G8_SINT:
      return &emit_R8G8_SINT;
   case PIPE_FORMAT_R8G8B8_SINT:
      return &emit_R8G8B8_SINT;
   case PIPE_FORMAT_R8G8B8A8_SINT:
      return &emit_R8G8B8A8_SINT;

   case PIPE_FORMAT_B10G10R10A2_UNORM:
      return &emit_B10G10R10A2_UNORM;
   case PIPE_FORMAT_B10G10R10A2_USCALED:
      return &emit_B10G10R10A2_USCALED;
   case PIPE_FORMAT_B10G10R10A2_SNORM:
      return &emit_B10G10R10A2_SNORM;
   case PIPE_FORMAT_B10G10R10A2_SSCALED:
      return &emit_B10G10R10A2_SSCALED;

   case PIPE_FORMAT_R10G10B10A2_UNORM:
      return &emit_R10G10B10A2_UNORM;
   case PIPE_FORMAT_R10G10B10A2_USCALED:
      return &emit_R10G10B10A2_USCALED;
   case PIPE_FORMAT_R10G10B10A2_SNORM:
      return &emit_R10G10B10A2_SNORM;
   case PIPE_FORMAT_R10G10B10A2_SSCALED:
      return &emit_R10G10B10A2_SSCALED;

a366 1
                                         unsigned start_instance,
d383 1
a383 7
            index = start_instance;
            index += (instance_id - start_instance) /
               tg->attrib[attr].instance_divisor;
            /* XXX we need to clamp the index here too, but to a
             * per-array max value, not the draw->pt.max_index value
             * that's being given to us via translate->set_buffer().
             */
a386 2
            /* clamp to avoid going out of bounds */
            index = MIN2(index, tg->attrib[attr].max_index);
d389 3
a430 1
                                         unsigned start_instance,
d439 1
a439 1
      generic_run_one(tg, *elts++, start_instance, instance_id, vert);
a446 1
                                         unsigned start_instance,
d455 1
a455 1
      generic_run_one(tg, *elts++, start_instance, instance_id, vert);
a462 1
                                         unsigned start_instance, 
d471 1
a471 1
      generic_run_one(tg, *elts++, start_instance, instance_id, vert);
a478 1
                                    unsigned start_instance,
d487 1
a487 1
      generic_run_one(tg, start + i, start_instance, instance_id, vert);
a520 21
static boolean
is_legal_int_format_combo( const struct util_format_description *src,
                           const struct util_format_description *dst )
{
   unsigned i;
   unsigned nr = MIN2(src->nr_channels, dst->nr_channels);

   for (i = 0; i < nr; i++) {
      /* The signs must match. */
      if (src->channel[i].type != dst->channel[i].type) {
         return FALSE;
      }

      /* Integers must not lose precision at any point in the pipeline. */
      if (src->channel[i].size > dst->channel[i].size) {
         return FALSE;
      }
   }
   return TRUE;
}

d542 1
d546 1
a546 21
      if (format_desc->channel[0].pure_integer) {
         const struct util_format_description *out_format_desc =
               util_format_description(key->element[i].output_format);

         if (!is_legal_int_format_combo(format_desc, out_format_desc)) {
            FREE(tg);
            return NULL;
         }

         if (format_desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
            assert(format_desc->fetch_rgba_sint);
            tg->attrib[i].fetch = (fetch_func)format_desc->fetch_rgba_sint;
         } else {
            assert(format_desc->fetch_rgba_uint);
            tg->attrib[i].fetch = (fetch_func)format_desc->fetch_rgba_uint;
         }
      } else {
         assert(format_desc->fetch_rgba_float);
         tg->attrib[i].fetch = (fetch_func)format_desc->fetch_rgba_float;
      }

a594 5
   case PIPE_FORMAT_R16G16B16A16_FLOAT: return TRUE;
   case PIPE_FORMAT_R16G16B16_FLOAT: return TRUE;
   case PIPE_FORMAT_R16G16_FLOAT: return TRUE;
   case PIPE_FORMAT_R16_FLOAT: return TRUE;

a656 41

   case PIPE_FORMAT_R32G32B32A32_UINT: return TRUE;
   case PIPE_FORMAT_R32G32B32_UINT: return TRUE;
   case PIPE_FORMAT_R32G32_UINT: return TRUE;
   case PIPE_FORMAT_R32_UINT: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_UINT: return TRUE;
   case PIPE_FORMAT_R16G16B16_UINT: return TRUE;
   case PIPE_FORMAT_R16G16_UINT: return TRUE;
   case PIPE_FORMAT_R16_UINT: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_UINT: return TRUE;
   case PIPE_FORMAT_R8G8B8_UINT: return TRUE;
   case PIPE_FORMAT_R8G8_UINT: return TRUE;
   case PIPE_FORMAT_R8_UINT: return TRUE;

   case PIPE_FORMAT_R32G32B32A32_SINT: return TRUE;
   case PIPE_FORMAT_R32G32B32_SINT: return TRUE;
   case PIPE_FORMAT_R32G32_SINT: return TRUE;
   case PIPE_FORMAT_R32_SINT: return TRUE;

   case PIPE_FORMAT_R16G16B16A16_SINT: return TRUE;
   case PIPE_FORMAT_R16G16B16_SINT: return TRUE;
   case PIPE_FORMAT_R16G16_SINT: return TRUE;
   case PIPE_FORMAT_R16_SINT: return TRUE;

   case PIPE_FORMAT_R8G8B8A8_SINT: return TRUE;
   case PIPE_FORMAT_R8G8B8_SINT: return TRUE;
   case PIPE_FORMAT_R8G8_SINT: return TRUE;
   case PIPE_FORMAT_R8_SINT: return TRUE;

   case PIPE_FORMAT_B10G10R10A2_UNORM: return TRUE;
   case PIPE_FORMAT_B10G10R10A2_USCALED: return TRUE;
   case PIPE_FORMAT_B10G10R10A2_SNORM: return TRUE;
   case PIPE_FORMAT_B10G10R10A2_SSCALED: return TRUE;

   case PIPE_FORMAT_R10G10B10A2_UNORM: return TRUE;
   case PIPE_FORMAT_R10G10B10A2_USCALED: return TRUE;
   case PIPE_FORMAT_R10G10B10A2_SNORM: return TRUE;
   case PIPE_FORMAT_R10G10B10A2_SSCALED: return TRUE;

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keithw@@vmware.com>
d76 1
a76 1
   } attrib[TRANSLATE_MAX_ATTRIBS];
d628 2
a629 1
            index += (instance_id  / tg->attrib[attr].instance_divisor);
d642 1
a642 1
               (ptrdiff_t)tg->attrib[attr].input_stride * index;
a801 2

   assert(key->nr_elements <= TRANSLATE_MAX_ATTRIBS);
@


