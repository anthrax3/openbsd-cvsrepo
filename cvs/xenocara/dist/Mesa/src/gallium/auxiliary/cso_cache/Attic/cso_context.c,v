head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.28;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.35;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.41;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.05;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.13;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

 /**
  * @@file
  *
  * Wrap the cso cache & hash mechanisms in a simplified
  * pipe-driver-specific interface.
  *
  * @@author Zack Rusin <zackr@@vmware.com>
  * @@author Keith Whitwell <keithw@@vmware.com>
  */

#include "pipe/p_state.h"
#include "util/u_draw.h"
#include "util/u_framebuffer.h"
#include "util/u_inlines.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_vbuf.h"
#include "tgsi/tgsi_parse.h"

#include "cso_cache/cso_context.h"
#include "cso_cache/cso_cache.h"
#include "cso_cache/cso_hash.h"
#include "cso_context.h"


/**
 * Info related to samplers and sampler views.
 * We have one of these for fragment samplers and another for vertex samplers.
 */
struct sampler_info
{
   struct {
      void *samplers[PIPE_MAX_SAMPLERS];
      unsigned nr_samplers;
   } hw;

   void *samplers[PIPE_MAX_SAMPLERS];
   unsigned nr_samplers;

   void *samplers_saved[PIPE_MAX_SAMPLERS];
   unsigned nr_samplers_saved;

   struct pipe_sampler_view *views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
   unsigned nr_views;

   struct pipe_sampler_view *views_saved[PIPE_MAX_SHADER_SAMPLER_VIEWS];
   unsigned nr_views_saved;
};



struct cso_context {
   struct pipe_context *pipe;
   struct cso_cache *cache;
   struct u_vbuf *vbuf;

   boolean has_geometry_shader;
   boolean has_streamout;

   struct sampler_info samplers[PIPE_SHADER_TYPES];

   struct pipe_vertex_buffer aux_vertex_buffer_current;
   struct pipe_vertex_buffer aux_vertex_buffer_saved;
   unsigned aux_vertex_buffer_index;

   struct pipe_constant_buffer aux_constbuf_current[PIPE_SHADER_TYPES];
   struct pipe_constant_buffer aux_constbuf_saved[PIPE_SHADER_TYPES];

   unsigned nr_so_targets;
   struct pipe_stream_output_target *so_targets[PIPE_MAX_SO_BUFFERS];

   unsigned nr_so_targets_saved;
   struct pipe_stream_output_target *so_targets_saved[PIPE_MAX_SO_BUFFERS];

   /** Current and saved state.
    * The saved state is used as a 1-deep stack.
    */
   void *blend, *blend_saved;
   void *depth_stencil, *depth_stencil_saved;
   void *rasterizer, *rasterizer_saved;
   void *fragment_shader, *fragment_shader_saved;
   void *vertex_shader, *vertex_shader_saved;
   void *geometry_shader, *geometry_shader_saved;
   void *velements, *velements_saved;
   struct pipe_query *render_condition, *render_condition_saved;
   uint render_condition_mode, render_condition_mode_saved;
   boolean render_condition_cond, render_condition_cond_saved;

   struct pipe_clip_state clip;
   struct pipe_clip_state clip_saved;

   struct pipe_framebuffer_state fb, fb_saved;
   struct pipe_viewport_state vp, vp_saved;
   struct pipe_blend_color blend_color;
   unsigned sample_mask, sample_mask_saved;
   unsigned min_samples, min_samples_saved;
   struct pipe_stencil_ref stencil_ref, stencil_ref_saved;
};


static boolean delete_blend_state(struct cso_context *ctx, void *state)
{
   struct cso_blend *cso = (struct cso_blend *)state;

   if (ctx->blend == cso->data)
      return FALSE;

   if (cso->delete_state)
      cso->delete_state(cso->context, cso->data);
   FREE(state);
   return TRUE;
}

static boolean delete_depth_stencil_state(struct cso_context *ctx, void *state)
{
   struct cso_depth_stencil_alpha *cso =
      (struct cso_depth_stencil_alpha *)state;

   if (ctx->depth_stencil == cso->data)
      return FALSE;

   if (cso->delete_state)
      cso->delete_state(cso->context, cso->data);
   FREE(state);

   return TRUE;
}

static boolean delete_sampler_state(struct cso_context *ctx, void *state)
{
   struct cso_sampler *cso = (struct cso_sampler *)state;
   if (cso->delete_state)
      cso->delete_state(cso->context, cso->data);
   FREE(state);
   return TRUE;
}

static boolean delete_rasterizer_state(struct cso_context *ctx, void *state)
{
   struct cso_rasterizer *cso = (struct cso_rasterizer *)state;

   if (ctx->rasterizer == cso->data)
      return FALSE;
   if (cso->delete_state)
      cso->delete_state(cso->context, cso->data);
   FREE(state);
   return TRUE;
}

static boolean delete_vertex_elements(struct cso_context *ctx,
                                      void *state)
{
   struct cso_velements *cso = (struct cso_velements *)state;

   if (ctx->velements == cso->data)
      return FALSE;

   if (cso->delete_state)
      cso->delete_state(cso->context, cso->data);
   FREE(state);
   return TRUE;
}


static INLINE boolean delete_cso(struct cso_context *ctx,
                                 void *state, enum cso_cache_type type)
{
   switch (type) {
   case CSO_BLEND:
      return delete_blend_state(ctx, state);
   case CSO_SAMPLER:
      return delete_sampler_state(ctx, state);
   case CSO_DEPTH_STENCIL_ALPHA:
      return delete_depth_stencil_state(ctx, state);
   case CSO_RASTERIZER:
      return delete_rasterizer_state(ctx, state);
   case CSO_VELEMENTS:
      return delete_vertex_elements(ctx, state);
   default:
      assert(0);
      FREE(state);
   }
   return FALSE;
}

static INLINE void
sanitize_hash(struct cso_hash *hash, enum cso_cache_type type,
              int max_size, void *user_data)
{
   struct cso_context *ctx = (struct cso_context *)user_data;
   /* if we're approach the maximum size, remove fourth of the entries
    * otherwise every subsequent call will go through the same */
   int hash_size = cso_hash_size(hash);
   int max_entries = (max_size > hash_size) ? max_size : hash_size;
   int to_remove =  (max_size < max_entries) * max_entries/4;
   struct cso_hash_iter iter = cso_hash_first_node(hash);
   if (hash_size > max_size)
      to_remove += hash_size - max_size;
   while (to_remove) {
      /*remove elements until we're good */
      /*fixme: currently we pick the nodes to remove at random*/
      void *cso = cso_hash_iter_data(iter);
      if (delete_cso(ctx, cso, type)) {
         iter = cso_hash_erase(hash, iter);
         --to_remove;
      } else
         iter = cso_hash_iter_next(iter);
   }
}

static void cso_init_vbuf(struct cso_context *cso)
{
   struct u_vbuf_caps caps;

   u_vbuf_get_caps(cso->pipe->screen, &caps);

   /* Install u_vbuf if there is anything unsupported. */
   if (!caps.buffer_offset_unaligned ||
       !caps.buffer_stride_unaligned ||
       !caps.velem_src_offset_unaligned ||
       !caps.format_fixed32 ||
       !caps.format_float16 ||
       !caps.format_float64 ||
       !caps.format_norm32 ||
       !caps.format_scaled32 ||
       !caps.user_vertex_buffers) {
      cso->vbuf = u_vbuf_create(cso->pipe, &caps,
                                cso->aux_vertex_buffer_index);
   }
}

struct cso_context *cso_create_context( struct pipe_context *pipe )
{
   struct cso_context *ctx = CALLOC_STRUCT(cso_context);
   if (ctx == NULL)
      goto out;

   ctx->cache = cso_cache_create();
   if (ctx->cache == NULL)
      goto out;
   cso_cache_set_sanitize_callback(ctx->cache,
                                   sanitize_hash,
                                   ctx);

   ctx->pipe = pipe;
   ctx->sample_mask = ~0;

   ctx->aux_vertex_buffer_index = 0; /* 0 for now */

   cso_init_vbuf(ctx);

   /* Enable for testing: */
   if (0) cso_set_maximum_cache_size( ctx->cache, 4 );

   if (pipe->screen->get_shader_param(pipe->screen, PIPE_SHADER_GEOMETRY,
                                PIPE_SHADER_CAP_MAX_INSTRUCTIONS) > 0) {
      ctx->has_geometry_shader = TRUE;
   }
   if (pipe->screen->get_param(pipe->screen,
                               PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS) != 0) {
      ctx->has_streamout = TRUE;
   }

   return ctx;

out:
   cso_destroy_context( ctx );
   return NULL;
}

/**
 * Prior to context destruction, this function unbinds all state objects.
 */
void cso_release_all( struct cso_context *ctx )
{
   unsigned i, shader;

   if (ctx->pipe) {
      ctx->pipe->bind_blend_state( ctx->pipe, NULL );
      ctx->pipe->bind_rasterizer_state( ctx->pipe, NULL );

      {
         static struct pipe_sampler_view *views[PIPE_MAX_SHADER_SAMPLER_VIEWS] = { NULL };
         static void *zeros[PIPE_MAX_SAMPLERS] = { NULL };
         struct pipe_screen *scr = ctx->pipe->screen;
         unsigned sh;
         for (sh = 0; sh < PIPE_SHADER_TYPES; sh++) {
            int maxsam = scr->get_shader_param(scr, sh,
                                               PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS);
            int maxview = scr->get_shader_param(scr, sh,
                                                PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS);
            assert(maxsam <= PIPE_MAX_SAMPLERS);
            assert(maxview <= PIPE_MAX_SHADER_SAMPLER_VIEWS);
            if (maxsam > 0) {
               ctx->pipe->bind_sampler_states(ctx->pipe, sh, 0, maxsam, zeros);
            }
            if (maxview > 0) {
               ctx->pipe->set_sampler_views(ctx->pipe, sh, 0, maxview, views);
            }
         }
      }

      ctx->pipe->bind_depth_stencil_alpha_state( ctx->pipe, NULL );
      ctx->pipe->bind_fs_state( ctx->pipe, NULL );
      ctx->pipe->bind_vs_state( ctx->pipe, NULL );
      ctx->pipe->bind_vertex_elements_state( ctx->pipe, NULL );

      if (ctx->pipe->set_stream_output_targets)
         ctx->pipe->set_stream_output_targets(ctx->pipe, 0, NULL, NULL);
   }

   /* free fragment sampler views */
   for (shader = 0; shader < Elements(ctx->samplers); shader++) {
      struct sampler_info *info = &ctx->samplers[shader];
      for (i = 0; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; i++) {
         pipe_sampler_view_reference(&info->views[i], NULL);
         pipe_sampler_view_reference(&info->views_saved[i], NULL);
      }
   }

   util_unreference_framebuffer_state(&ctx->fb);
   util_unreference_framebuffer_state(&ctx->fb_saved);

   pipe_resource_reference(&ctx->aux_vertex_buffer_current.buffer, NULL);
   pipe_resource_reference(&ctx->aux_vertex_buffer_saved.buffer, NULL);

   for (i = 0; i < PIPE_SHADER_TYPES; i++) {
      pipe_resource_reference(&ctx->aux_constbuf_current[i].buffer, NULL);
      pipe_resource_reference(&ctx->aux_constbuf_saved[i].buffer, NULL);
   }

   for (i = 0; i < PIPE_MAX_SO_BUFFERS; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], NULL);
      pipe_so_target_reference(&ctx->so_targets_saved[i], NULL);
   }

   if (ctx->cache) {
      cso_cache_delete( ctx->cache );
      ctx->cache = NULL;
   }
}


/**
 * Free the CSO context.  NOTE: the state tracker should have previously called
 * cso_release_all().
 */
void cso_destroy_context( struct cso_context *ctx )
{
   if (ctx) {
      if (ctx->vbuf)
         u_vbuf_destroy(ctx->vbuf);
      FREE( ctx );
   }
}


/* Those function will either find the state of the given template
 * in the cache or they will create a new state from the given
 * template, insert it in the cache and return it.
 */

/*
 * If the driver returns 0 from the create method then they will assign
 * the data member of the cso to be the template itself.
 */

enum pipe_error cso_set_blend(struct cso_context *ctx,
                              const struct pipe_blend_state *templ)
{
   unsigned key_size, hash_key;
   struct cso_hash_iter iter;
   void *handle;

   key_size = templ->independent_blend_enable ?
      sizeof(struct pipe_blend_state) :
      (char *)&(templ->rt[1]) - (char *)templ;
   hash_key = cso_construct_key((void*)templ, key_size);
   iter = cso_find_state_template(ctx->cache, hash_key, CSO_BLEND,
                                  (void*)templ, key_size);

   if (cso_hash_iter_is_null(iter)) {
      struct cso_blend *cso = MALLOC(sizeof(struct cso_blend));
      if (!cso)
         return PIPE_ERROR_OUT_OF_MEMORY;

      memset(&cso->state, 0, sizeof cso->state);
      memcpy(&cso->state, templ, key_size);
      cso->data = ctx->pipe->create_blend_state(ctx->pipe, &cso->state);
      cso->delete_state = (cso_state_callback)ctx->pipe->delete_blend_state;
      cso->context = ctx->pipe;

      iter = cso_insert_state(ctx->cache, hash_key, CSO_BLEND, cso);
      if (cso_hash_iter_is_null(iter)) {
         FREE(cso);
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      handle = cso->data;
   }
   else {
      handle = ((struct cso_blend *)cso_hash_iter_data(iter))->data;
   }

   if (ctx->blend != handle) {
      ctx->blend = handle;
      ctx->pipe->bind_blend_state(ctx->pipe, handle);
   }
   return PIPE_OK;
}

void cso_save_blend(struct cso_context *ctx)
{
   assert(!ctx->blend_saved);
   ctx->blend_saved = ctx->blend;
}

void cso_restore_blend(struct cso_context *ctx)
{
   if (ctx->blend != ctx->blend_saved) {
      ctx->blend = ctx->blend_saved;
      ctx->pipe->bind_blend_state(ctx->pipe, ctx->blend_saved);
   }
   ctx->blend_saved = NULL;
}



enum pipe_error
cso_set_depth_stencil_alpha(struct cso_context *ctx,
                            const struct pipe_depth_stencil_alpha_state *templ)
{
   unsigned key_size = sizeof(struct pipe_depth_stencil_alpha_state);
   unsigned hash_key = cso_construct_key((void*)templ, key_size);
   struct cso_hash_iter iter = cso_find_state_template(ctx->cache,
                                                       hash_key,
                                                       CSO_DEPTH_STENCIL_ALPHA,
                                                       (void*)templ, key_size);
   void *handle;

   if (cso_hash_iter_is_null(iter)) {
      struct cso_depth_stencil_alpha *cso =
         MALLOC(sizeof(struct cso_depth_stencil_alpha));
      if (!cso)
         return PIPE_ERROR_OUT_OF_MEMORY;

      memcpy(&cso->state, templ, sizeof(*templ));
      cso->data = ctx->pipe->create_depth_stencil_alpha_state(ctx->pipe,
                                                              &cso->state);
      cso->delete_state =
         (cso_state_callback)ctx->pipe->delete_depth_stencil_alpha_state;
      cso->context = ctx->pipe;

      iter = cso_insert_state(ctx->cache, hash_key,
                              CSO_DEPTH_STENCIL_ALPHA, cso);
      if (cso_hash_iter_is_null(iter)) {
         FREE(cso);
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      handle = cso->data;
   }
   else {
      handle = ((struct cso_depth_stencil_alpha *)
                cso_hash_iter_data(iter))->data;
   }

   if (ctx->depth_stencil != handle) {
      ctx->depth_stencil = handle;
      ctx->pipe->bind_depth_stencil_alpha_state(ctx->pipe, handle);
   }
   return PIPE_OK;
}

void cso_save_depth_stencil_alpha(struct cso_context *ctx)
{
   assert(!ctx->depth_stencil_saved);
   ctx->depth_stencil_saved = ctx->depth_stencil;
}

void cso_restore_depth_stencil_alpha(struct cso_context *ctx)
{
   if (ctx->depth_stencil != ctx->depth_stencil_saved) {
      ctx->depth_stencil = ctx->depth_stencil_saved;
      ctx->pipe->bind_depth_stencil_alpha_state(ctx->pipe,
                                                ctx->depth_stencil_saved);
   }
   ctx->depth_stencil_saved = NULL;
}



enum pipe_error cso_set_rasterizer(struct cso_context *ctx,
                                   const struct pipe_rasterizer_state *templ)
{
   unsigned key_size = sizeof(struct pipe_rasterizer_state);
   unsigned hash_key = cso_construct_key((void*)templ, key_size);
   struct cso_hash_iter iter = cso_find_state_template(ctx->cache,
                                                       hash_key,
                                                       CSO_RASTERIZER,
                                                       (void*)templ, key_size);
   void *handle = NULL;

   if (cso_hash_iter_is_null(iter)) {
      struct cso_rasterizer *cso = MALLOC(sizeof(struct cso_rasterizer));
      if (!cso)
         return PIPE_ERROR_OUT_OF_MEMORY;

      memcpy(&cso->state, templ, sizeof(*templ));
      cso->data = ctx->pipe->create_rasterizer_state(ctx->pipe, &cso->state);
      cso->delete_state =
         (cso_state_callback)ctx->pipe->delete_rasterizer_state;
      cso->context = ctx->pipe;

      iter = cso_insert_state(ctx->cache, hash_key, CSO_RASTERIZER, cso);
      if (cso_hash_iter_is_null(iter)) {
         FREE(cso);
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      handle = cso->data;
   }
   else {
      handle = ((struct cso_rasterizer *)cso_hash_iter_data(iter))->data;
   }

   if (ctx->rasterizer != handle) {
      ctx->rasterizer = handle;
      ctx->pipe->bind_rasterizer_state(ctx->pipe, handle);
   }
   return PIPE_OK;
}

void cso_save_rasterizer(struct cso_context *ctx)
{
   assert(!ctx->rasterizer_saved);
   ctx->rasterizer_saved = ctx->rasterizer;
}

void cso_restore_rasterizer(struct cso_context *ctx)
{
   if (ctx->rasterizer != ctx->rasterizer_saved) {
      ctx->rasterizer = ctx->rasterizer_saved;
      ctx->pipe->bind_rasterizer_state(ctx->pipe, ctx->rasterizer_saved);
   }
   ctx->rasterizer_saved = NULL;
}


void cso_set_fragment_shader_handle(struct cso_context *ctx, void *handle )
{
   if (ctx->fragment_shader != handle) {
      ctx->fragment_shader = handle;
      ctx->pipe->bind_fs_state(ctx->pipe, handle);
   }
}

void cso_delete_fragment_shader(struct cso_context *ctx, void *handle )
{
   if (handle == ctx->fragment_shader) {
      /* unbind before deleting */
      ctx->pipe->bind_fs_state(ctx->pipe, NULL);
      ctx->fragment_shader = NULL;
   }
   ctx->pipe->delete_fs_state(ctx->pipe, handle);
}

void cso_save_fragment_shader(struct cso_context *ctx)
{
   assert(!ctx->fragment_shader_saved);
   ctx->fragment_shader_saved = ctx->fragment_shader;
}

void cso_restore_fragment_shader(struct cso_context *ctx)
{
   if (ctx->fragment_shader_saved != ctx->fragment_shader) {
      ctx->pipe->bind_fs_state(ctx->pipe, ctx->fragment_shader_saved);
      ctx->fragment_shader = ctx->fragment_shader_saved;
   }
   ctx->fragment_shader_saved = NULL;
}


void cso_set_vertex_shader_handle(struct cso_context *ctx, void *handle)
{
   if (ctx->vertex_shader != handle) {
      ctx->vertex_shader = handle;
      ctx->pipe->bind_vs_state(ctx->pipe, handle);
   }
}

void cso_delete_vertex_shader(struct cso_context *ctx, void *handle )
{
   if (handle == ctx->vertex_shader) {
      /* unbind before deleting */
      ctx->pipe->bind_vs_state(ctx->pipe, NULL);
      ctx->vertex_shader = NULL;
   }
   ctx->pipe->delete_vs_state(ctx->pipe, handle);
}

void cso_save_vertex_shader(struct cso_context *ctx)
{
   assert(!ctx->vertex_shader_saved);
   ctx->vertex_shader_saved = ctx->vertex_shader;
}

void cso_restore_vertex_shader(struct cso_context *ctx)
{
   if (ctx->vertex_shader_saved != ctx->vertex_shader) {
      ctx->pipe->bind_vs_state(ctx->pipe, ctx->vertex_shader_saved);
      ctx->vertex_shader = ctx->vertex_shader_saved;
   }
   ctx->vertex_shader_saved = NULL;
}


void cso_set_framebuffer(struct cso_context *ctx,
                         const struct pipe_framebuffer_state *fb)
{
   if (memcmp(&ctx->fb, fb, sizeof(*fb)) != 0) {
      util_copy_framebuffer_state(&ctx->fb, fb);
      ctx->pipe->set_framebuffer_state(ctx->pipe, fb);
   }
}

void cso_save_framebuffer(struct cso_context *ctx)
{
   util_copy_framebuffer_state(&ctx->fb_saved, &ctx->fb);
}

void cso_restore_framebuffer(struct cso_context *ctx)
{
   if (memcmp(&ctx->fb, &ctx->fb_saved, sizeof(ctx->fb))) {
      util_copy_framebuffer_state(&ctx->fb, &ctx->fb_saved);
      ctx->pipe->set_framebuffer_state(ctx->pipe, &ctx->fb);
      util_unreference_framebuffer_state(&ctx->fb_saved);
   }
}


void cso_set_viewport(struct cso_context *ctx,
                      const struct pipe_viewport_state *vp)
{
   if (memcmp(&ctx->vp, vp, sizeof(*vp))) {
      ctx->vp = *vp;
      ctx->pipe->set_viewport_states(ctx->pipe, 0, 1, vp);
   }
}

void cso_save_viewport(struct cso_context *ctx)
{
   ctx->vp_saved = ctx->vp;
}


void cso_restore_viewport(struct cso_context *ctx)
{
   if (memcmp(&ctx->vp, &ctx->vp_saved, sizeof(ctx->vp))) {
      ctx->vp = ctx->vp_saved;
      ctx->pipe->set_viewport_states(ctx->pipe, 0, 1, &ctx->vp);
   }
}


void cso_set_blend_color(struct cso_context *ctx,
                         const struct pipe_blend_color *bc)
{
   if (memcmp(&ctx->blend_color, bc, sizeof(ctx->blend_color))) {
      ctx->blend_color = *bc;
      ctx->pipe->set_blend_color(ctx->pipe, bc);
   }
}

void cso_set_sample_mask(struct cso_context *ctx, unsigned sample_mask)
{
   if (ctx->sample_mask != sample_mask) {
      ctx->sample_mask = sample_mask;
      ctx->pipe->set_sample_mask(ctx->pipe, sample_mask);
   }
}

void cso_save_sample_mask(struct cso_context *ctx)
{
   ctx->sample_mask_saved = ctx->sample_mask;
}

void cso_restore_sample_mask(struct cso_context *ctx)
{
   cso_set_sample_mask(ctx, ctx->sample_mask_saved);
}

void cso_set_min_samples(struct cso_context *ctx, unsigned min_samples)
{
   if (ctx->min_samples != min_samples && ctx->pipe->set_min_samples) {
      ctx->min_samples = min_samples;
      ctx->pipe->set_min_samples(ctx->pipe, min_samples);
   }
}

void cso_save_min_samples(struct cso_context *ctx)
{
   ctx->min_samples_saved = ctx->min_samples;
}

void cso_restore_min_samples(struct cso_context *ctx)
{
   cso_set_min_samples(ctx, ctx->min_samples_saved);
}

void cso_set_stencil_ref(struct cso_context *ctx,
                         const struct pipe_stencil_ref *sr)
{
   if (memcmp(&ctx->stencil_ref, sr, sizeof(ctx->stencil_ref))) {
      ctx->stencil_ref = *sr;
      ctx->pipe->set_stencil_ref(ctx->pipe, sr);
   }
}

void cso_save_stencil_ref(struct cso_context *ctx)
{
   ctx->stencil_ref_saved = ctx->stencil_ref;
}


void cso_restore_stencil_ref(struct cso_context *ctx)
{
   if (memcmp(&ctx->stencil_ref, &ctx->stencil_ref_saved,
              sizeof(ctx->stencil_ref))) {
      ctx->stencil_ref = ctx->stencil_ref_saved;
      ctx->pipe->set_stencil_ref(ctx->pipe, &ctx->stencil_ref);
   }
}

void cso_set_render_condition(struct cso_context *ctx,
                              struct pipe_query *query,
                              boolean condition, uint mode)
{
   struct pipe_context *pipe = ctx->pipe;

   if (ctx->render_condition != query ||
       ctx->render_condition_mode != mode ||
       ctx->render_condition_cond != condition) {
      pipe->render_condition(pipe, query, condition, mode);
      ctx->render_condition = query;
      ctx->render_condition_cond = condition;
      ctx->render_condition_mode = mode;
   }
}

void cso_save_render_condition(struct cso_context *ctx)
{
   ctx->render_condition_saved = ctx->render_condition;
   ctx->render_condition_cond_saved = ctx->render_condition_cond;
   ctx->render_condition_mode_saved = ctx->render_condition_mode;
}

void cso_restore_render_condition(struct cso_context *ctx)
{
   cso_set_render_condition(ctx, ctx->render_condition_saved,
                            ctx->render_condition_cond_saved,
                            ctx->render_condition_mode_saved);
}

void cso_set_geometry_shader_handle(struct cso_context *ctx, void *handle)
{
   assert(ctx->has_geometry_shader || !handle);

   if (ctx->has_geometry_shader && ctx->geometry_shader != handle) {
      ctx->geometry_shader = handle;
      ctx->pipe->bind_gs_state(ctx->pipe, handle);
   }
}

void cso_delete_geometry_shader(struct cso_context *ctx, void *handle)
{
    if (handle == ctx->geometry_shader) {
      /* unbind before deleting */
      ctx->pipe->bind_gs_state(ctx->pipe, NULL);
      ctx->geometry_shader = NULL;
   }
   ctx->pipe->delete_gs_state(ctx->pipe, handle);
}

void cso_save_geometry_shader(struct cso_context *ctx)
{
   if (!ctx->has_geometry_shader) {
      return;
   }

   assert(!ctx->geometry_shader_saved);
   ctx->geometry_shader_saved = ctx->geometry_shader;
}

void cso_restore_geometry_shader(struct cso_context *ctx)
{
   if (!ctx->has_geometry_shader) {
      return;
   }

   if (ctx->geometry_shader_saved != ctx->geometry_shader) {
      ctx->pipe->bind_gs_state(ctx->pipe, ctx->geometry_shader_saved);
      ctx->geometry_shader = ctx->geometry_shader_saved;
   }
   ctx->geometry_shader_saved = NULL;
}

/* clip state */

static INLINE void
clip_state_cpy(struct pipe_clip_state *dst,
               const struct pipe_clip_state *src)
{
   memcpy(dst->ucp, src->ucp, sizeof(dst->ucp));
}

static INLINE int
clip_state_cmp(const struct pipe_clip_state *a,
               const struct pipe_clip_state *b)
{
   return memcmp(a->ucp, b->ucp, sizeof(a->ucp));
}

void
cso_set_clip(struct cso_context *ctx,
             const struct pipe_clip_state *clip)
{
   if (clip_state_cmp(&ctx->clip, clip)) {
      clip_state_cpy(&ctx->clip, clip);
      ctx->pipe->set_clip_state(ctx->pipe, clip);
   }
}

void
cso_save_clip(struct cso_context *ctx)
{
   clip_state_cpy(&ctx->clip_saved, &ctx->clip);
}

void
cso_restore_clip(struct cso_context *ctx)
{
   if (clip_state_cmp(&ctx->clip, &ctx->clip_saved)) {
      clip_state_cpy(&ctx->clip, &ctx->clip_saved);
      ctx->pipe->set_clip_state(ctx->pipe, &ctx->clip_saved);
   }
}

enum pipe_error
cso_set_vertex_elements(struct cso_context *ctx,
                        unsigned count,
                        const struct pipe_vertex_element *states)
{
   struct u_vbuf *vbuf = ctx->vbuf;
   unsigned key_size, hash_key;
   struct cso_hash_iter iter;
   void *handle;
   struct cso_velems_state velems_state;

   if (vbuf) {
      u_vbuf_set_vertex_elements(vbuf, count, states);
      return PIPE_OK;
   }

   /* Need to include the count into the stored state data too.
    * Otherwise first few count pipe_vertex_elements could be identical
    * even if count is different, and there's no guarantee the hash would
    * be different in that case neither.
    */
   key_size = sizeof(struct pipe_vertex_element) * count + sizeof(unsigned);
   velems_state.count = count;
   memcpy(velems_state.velems, states,
          sizeof(struct pipe_vertex_element) * count);
   hash_key = cso_construct_key((void*)&velems_state, key_size);
   iter = cso_find_state_template(ctx->cache, hash_key, CSO_VELEMENTS,
                                  (void*)&velems_state, key_size);

   if (cso_hash_iter_is_null(iter)) {
      struct cso_velements *cso = MALLOC(sizeof(struct cso_velements));
      if (!cso)
         return PIPE_ERROR_OUT_OF_MEMORY;

      memcpy(&cso->state, &velems_state, key_size);
      cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, count,
                                                      &cso->state.velems[0]);
      cso->delete_state =
         (cso_state_callback) ctx->pipe->delete_vertex_elements_state;
      cso->context = ctx->pipe;

      iter = cso_insert_state(ctx->cache, hash_key, CSO_VELEMENTS, cso);
      if (cso_hash_iter_is_null(iter)) {
         FREE(cso);
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      handle = cso->data;
   }
   else {
      handle = ((struct cso_velements *)cso_hash_iter_data(iter))->data;
   }

   if (ctx->velements != handle) {
      ctx->velements = handle;
      ctx->pipe->bind_vertex_elements_state(ctx->pipe, handle);
   }
   return PIPE_OK;
}

void cso_save_vertex_elements(struct cso_context *ctx)
{
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_save_vertex_elements(vbuf);
      return;
   }

   assert(!ctx->velements_saved);
   ctx->velements_saved = ctx->velements;
}

void cso_restore_vertex_elements(struct cso_context *ctx)
{
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_restore_vertex_elements(vbuf);
      return;
   }

   if (ctx->velements != ctx->velements_saved) {
      ctx->velements = ctx->velements_saved;
      ctx->pipe->bind_vertex_elements_state(ctx->pipe, ctx->velements_saved);
   }
   ctx->velements_saved = NULL;
}

/* vertex buffers */

void cso_set_vertex_buffers(struct cso_context *ctx,
                            unsigned start_slot, unsigned count,
                            const struct pipe_vertex_buffer *buffers)
{
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_set_vertex_buffers(vbuf, start_slot, count, buffers);
      return;
   }

   /* Save what's in the auxiliary slot, so that we can save and restore it
    * for meta ops. */
   if (start_slot <= ctx->aux_vertex_buffer_index &&
       start_slot+count > ctx->aux_vertex_buffer_index) {
      if (buffers) {
         const struct pipe_vertex_buffer *vb =
               buffers + (ctx->aux_vertex_buffer_index - start_slot);

         pipe_resource_reference(&ctx->aux_vertex_buffer_current.buffer,
                                 vb->buffer);
         memcpy(&ctx->aux_vertex_buffer_current, vb,
                sizeof(struct pipe_vertex_buffer));
      }
      else {
         pipe_resource_reference(&ctx->aux_vertex_buffer_current.buffer,
                                 NULL);
         ctx->aux_vertex_buffer_current.user_buffer = NULL;
      }
   }

   ctx->pipe->set_vertex_buffers(ctx->pipe, start_slot, count, buffers);
}

void cso_save_aux_vertex_buffer_slot(struct cso_context *ctx)
{
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_save_aux_vertex_buffer_slot(vbuf);
      return;
   }

   pipe_resource_reference(&ctx->aux_vertex_buffer_saved.buffer,
                           ctx->aux_vertex_buffer_current.buffer);
   memcpy(&ctx->aux_vertex_buffer_saved, &ctx->aux_vertex_buffer_current,
          sizeof(struct pipe_vertex_buffer));
}

void cso_restore_aux_vertex_buffer_slot(struct cso_context *ctx)
{
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_restore_aux_vertex_buffer_slot(vbuf);
      return;
   }

   cso_set_vertex_buffers(ctx, ctx->aux_vertex_buffer_index, 1,
                          &ctx->aux_vertex_buffer_saved);
   pipe_resource_reference(&ctx->aux_vertex_buffer_saved.buffer, NULL);
}

unsigned cso_get_aux_vertex_buffer_slot(struct cso_context *ctx)
{
   return ctx->aux_vertex_buffer_index;
}


/**************** fragment/vertex sampler view state *************************/

static enum pipe_error
single_sampler(struct cso_context *ctx,
               struct sampler_info *info,
               unsigned idx,
               const struct pipe_sampler_state *templ)
{
   void *handle = NULL;

   if (templ != NULL) {
      unsigned key_size = sizeof(struct pipe_sampler_state);
      unsigned hash_key = cso_construct_key((void*)templ, key_size);
      struct cso_hash_iter iter =
         cso_find_state_template(ctx->cache,
                                 hash_key, CSO_SAMPLER,
                                 (void *) templ, key_size);

      if (cso_hash_iter_is_null(iter)) {
         struct cso_sampler *cso = MALLOC(sizeof(struct cso_sampler));
         if (!cso)
            return PIPE_ERROR_OUT_OF_MEMORY;

         memcpy(&cso->state, templ, sizeof(*templ));
         cso->data = ctx->pipe->create_sampler_state(ctx->pipe, &cso->state);
         cso->delete_state =
            (cso_state_callback) ctx->pipe->delete_sampler_state;
         cso->context = ctx->pipe;

         iter = cso_insert_state(ctx->cache, hash_key, CSO_SAMPLER, cso);
         if (cso_hash_iter_is_null(iter)) {
            FREE(cso);
            return PIPE_ERROR_OUT_OF_MEMORY;
         }

         handle = cso->data;
      }
      else {
         handle = ((struct cso_sampler *)cso_hash_iter_data(iter))->data;
      }
   }

   info->samplers[idx] = handle;

   return PIPE_OK;
}

enum pipe_error
cso_single_sampler(struct cso_context *ctx,
                   unsigned shader_stage,
                   unsigned idx,
                   const struct pipe_sampler_state *templ)
{
   return single_sampler(ctx, &ctx->samplers[shader_stage], idx, templ);
}



static void
single_sampler_done(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i;

   /* find highest non-null sampler */
   for (i = PIPE_MAX_SAMPLERS; i > 0; i--) {
      if (info->samplers[i - 1] != NULL)
         break;
   }

   info->nr_samplers = i;

   if (info->hw.nr_samplers != info->nr_samplers ||
       memcmp(info->hw.samplers,
              info->samplers,
              info->nr_samplers * sizeof(void *)) != 0)
   {
      memcpy(info->hw.samplers,
             info->samplers,
             info->nr_samplers * sizeof(void *));

      /* set remaining slots/pointers to null */
      for (i = info->nr_samplers; i < info->hw.nr_samplers; i++)
         info->samplers[i] = NULL;

      ctx->pipe->bind_sampler_states(ctx->pipe, shader_stage, 0,
                                     MAX2(info->nr_samplers,
                                          info->hw.nr_samplers),
                                     info->samplers);

      info->hw.nr_samplers = info->nr_samplers;
   }
}

void
cso_single_sampler_done(struct cso_context *ctx, unsigned shader_stage)
{
   single_sampler_done(ctx, shader_stage);
}


/*
 * If the function encouters any errors it will return the
 * last one. Done to always try to set as many samplers
 * as possible.
 */
enum pipe_error
cso_set_samplers(struct cso_context *ctx,
                 unsigned shader_stage,
                 unsigned nr,
                 const struct pipe_sampler_state **templates)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i;
   enum pipe_error temp, error = PIPE_OK;

   /* TODO: fastpath
    */

   for (i = 0; i < nr; i++) {
      temp = single_sampler(ctx, info, i, templates[i]);
      if (temp != PIPE_OK)
         error = temp;
   }

   for ( ; i < info->nr_samplers; i++) {
      temp = single_sampler(ctx, info, i, NULL);
      if (temp != PIPE_OK)
         error = temp;
   }

   single_sampler_done(ctx, shader_stage);

   return error;
}

void
cso_save_samplers(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   info->nr_samplers_saved = info->nr_samplers;
   memcpy(info->samplers_saved, info->samplers, sizeof(info->samplers));
}


void
cso_restore_samplers(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   info->nr_samplers = info->nr_samplers_saved;
   memcpy(info->samplers, info->samplers_saved, sizeof(info->samplers));
   single_sampler_done(ctx, shader_stage);
}


void
cso_set_sampler_views(struct cso_context *ctx,
                      unsigned shader_stage,
                      unsigned count,
                      struct pipe_sampler_view **views)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i;
   boolean any_change = FALSE;

   /* reference new views */
   for (i = 0; i < count; i++) {
      any_change |= info->views[i] != views[i];
      pipe_sampler_view_reference(&info->views[i], views[i]);
   }
   /* unref extra old views, if any */
   for (; i < info->nr_views; i++) {
      any_change |= info->views[i] != NULL;
      pipe_sampler_view_reference(&info->views[i], NULL);
   }

   /* bind the new sampler views */
   if (any_change) {
      ctx->pipe->set_sampler_views(ctx->pipe, shader_stage, 0,
                                   MAX2(info->nr_views, count),
                                   info->views);
   }

   info->nr_views = count;
}


void
cso_save_sampler_views(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i;

   info->nr_views_saved = info->nr_views;

   for (i = 0; i < info->nr_views; i++) {
      assert(!info->views_saved[i]);
      pipe_sampler_view_reference(&info->views_saved[i], info->views[i]);
   }
}


void
cso_restore_sampler_views(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i, nr_saved = info->nr_views_saved;
   unsigned num;

   for (i = 0; i < nr_saved; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
      /* move the reference from one pointer to another */
      info->views[i] = info->views_saved[i];
      info->views_saved[i] = NULL;
   }
   for (; i < info->nr_views; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
   }

   num = MAX2(info->nr_views, nr_saved);

   /* bind the old/saved sampler views */
   ctx->pipe->set_sampler_views(ctx->pipe, shader_stage, 0, num, info->views);

   info->nr_views = nr_saved;
   info->nr_views_saved = 0;
}


void
cso_set_stream_outputs(struct cso_context *ctx,
                       unsigned num_targets,
                       struct pipe_stream_output_target **targets,
                       const unsigned *offsets)
{
   struct pipe_context *pipe = ctx->pipe;
   uint i;

   if (!ctx->has_streamout) {
      assert(num_targets == 0);
      return;
   }

   if (ctx->nr_so_targets == 0 && num_targets == 0) {
      /* Nothing to do. */
      return;
   }

   /* reference new targets */
   for (i = 0; i < num_targets; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], targets[i]);
   }
   /* unref extra old targets, if any */
   for (; i < ctx->nr_so_targets; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], NULL);
   }

   pipe->set_stream_output_targets(pipe, num_targets, targets,
                                   offsets);
   ctx->nr_so_targets = num_targets;
}

void
cso_save_stream_outputs(struct cso_context *ctx)
{
   uint i;

   if (!ctx->has_streamout) {
      return;
   }

   ctx->nr_so_targets_saved = ctx->nr_so_targets;

   for (i = 0; i < ctx->nr_so_targets; i++) {
      assert(!ctx->so_targets_saved[i]);
      pipe_so_target_reference(&ctx->so_targets_saved[i], ctx->so_targets[i]);
   }
}

void
cso_restore_stream_outputs(struct cso_context *ctx)
{
   struct pipe_context *pipe = ctx->pipe;
   uint i;
   unsigned offset[PIPE_MAX_SO_BUFFERS];

   if (!ctx->has_streamout) {
      return;
   }

   if (ctx->nr_so_targets == 0 && ctx->nr_so_targets_saved == 0) {
      /* Nothing to do. */
      return;
   }

   assert(ctx->nr_so_targets_saved <= PIPE_MAX_SO_BUFFERS);
   for (i = 0; i < ctx->nr_so_targets_saved; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], NULL);
      /* move the reference from one pointer to another */
      ctx->so_targets[i] = ctx->so_targets_saved[i];
      ctx->so_targets_saved[i] = NULL;
      /* -1 means append */
      offset[i] = (unsigned)-1;
   }
   for (; i < ctx->nr_so_targets; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], NULL);
   }

   pipe->set_stream_output_targets(pipe, ctx->nr_so_targets_saved,
                                   ctx->so_targets, offset);

   ctx->nr_so_targets = ctx->nr_so_targets_saved;
   ctx->nr_so_targets_saved = 0;
}

/* constant buffers */

void
cso_set_constant_buffer(struct cso_context *cso, unsigned shader_stage,
                        unsigned index, struct pipe_constant_buffer *cb)
{
   struct pipe_context *pipe = cso->pipe;

   pipe->set_constant_buffer(pipe, shader_stage, index, cb);

   if (index == 0) {
      util_copy_constant_buffer(&cso->aux_constbuf_current[shader_stage], cb);
   }
}

void
cso_set_constant_buffer_resource(struct cso_context *cso,
                                 unsigned shader_stage,
                                 unsigned index,
                                 struct pipe_resource *buffer)
{
   if (buffer) {
      struct pipe_constant_buffer cb;
      cb.buffer = buffer;
      cb.buffer_offset = 0;
      cb.buffer_size = buffer->width0;
      cb.user_buffer = NULL;
      cso_set_constant_buffer(cso, shader_stage, index, &cb);
   } else {
      cso_set_constant_buffer(cso, shader_stage, index, NULL);
   }
}

void
cso_save_constant_buffer_slot0(struct cso_context *cso,
                                  unsigned shader_stage)
{
   util_copy_constant_buffer(&cso->aux_constbuf_saved[shader_stage],
                             &cso->aux_constbuf_current[shader_stage]);
}

void
cso_restore_constant_buffer_slot0(struct cso_context *cso,
                                     unsigned shader_stage)
{
   cso_set_constant_buffer(cso, shader_stage, 0,
                           &cso->aux_constbuf_saved[shader_stage]);
   pipe_resource_reference(&cso->aux_constbuf_saved[shader_stage].buffer,
                           NULL);
}

/* drawing */

void
cso_set_index_buffer(struct cso_context *cso,
                     const struct pipe_index_buffer *ib)
{
   struct u_vbuf *vbuf = cso->vbuf;

   if (vbuf) {
      u_vbuf_set_index_buffer(vbuf, ib);
   } else {
      struct pipe_context *pipe = cso->pipe;
      pipe->set_index_buffer(pipe, ib);
   }
}

void
cso_draw_vbo(struct cso_context *cso,
             const struct pipe_draw_info *info)
{
   struct u_vbuf *vbuf = cso->vbuf;

   if (vbuf) {
      u_vbuf_draw_vbo(vbuf, info);
   } else {
      struct pipe_context *pipe = cso->pipe;
      pipe->draw_vbo(pipe, info);
   }
}

void
cso_draw_arrays(struct cso_context *cso, uint mode, uint start, uint count)
{
   struct pipe_draw_info info;

   util_draw_init_info(&info);

   info.mode = mode;
   info.start = start;
   info.count = count;
   info.min_index = start;
   info.max_index = start + count - 1;

   cso_draw_vbo(cso, &info);
}

void
cso_draw_arrays_instanced(struct cso_context *cso, uint mode,
                          uint start, uint count,
                          uint start_instance, uint instance_count)
{
   struct pipe_draw_info info;

   util_draw_init_info(&info);

   info.mode = mode;
   info.start = start;
   info.count = count;
   info.min_index = start;
   info.max_index = start + count - 1;
   info.start_instance = start_instance;
   info.instance_count = instance_count;

   cso_draw_vbo(cso, &info);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d242 2
d245 9
a253 1
   if (u_vbuf_get_caps(cso->pipe->screen, &caps)) {
d335 1
a335 1
      if (ctx->has_streamout)
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a241 2
   u_vbuf_get_caps(cso->pipe->screen, &caps);

d243 1
a243 9
   if (!caps.buffer_offset_unaligned ||
       !caps.buffer_stride_unaligned ||
       !caps.velem_src_offset_unaligned ||
       !caps.format_fixed32 ||
       !caps.format_float16 ||
       !caps.format_float64 ||
       !caps.format_norm32 ||
       !caps.format_scaled32 ||
       !caps.user_vertex_buffers) {
d325 1
a325 1
      if (ctx->pipe->set_stream_output_targets)
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d34 2
a35 2
  * @@author Zack Rusin <zack@@tungstengraphics.com>
  * @@author Keith Whitwell <keith@@tungstengraphics.com>
d70 1
a70 1
   struct pipe_sampler_view *views[PIPE_MAX_SAMPLERS];
d73 1
a73 1
   struct pipe_sampler_view *views_saved[PIPE_MAX_SAMPLERS];
d123 1
d273 1
a273 1
   ctx->sample_mask_saved = ~0;
d308 22
a329 3
      ctx->pipe->bind_fragment_sampler_states( ctx->pipe, 0, NULL );
      if (ctx->pipe->bind_vertex_sampler_states)
         ctx->pipe->bind_vertex_sampler_states(ctx->pipe, 0, NULL);
d334 1
a334 3
      ctx->pipe->set_fragment_sampler_views(ctx->pipe, 0, NULL);
      if (ctx->pipe->set_vertex_sampler_views)
         ctx->pipe->set_vertex_sampler_views(ctx->pipe, 0, NULL);
d336 1
a336 1
         ctx->pipe->set_stream_output_targets(ctx->pipe, 0, NULL, 0);
d339 1
a339 1
   /* free fragment samplers, views */
d342 1
a342 1
      for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
d720 18
d1116 10
a1126 20

      switch (shader_stage) {
      case PIPE_SHADER_FRAGMENT:
         ctx->pipe->bind_fragment_sampler_states(ctx->pipe,
                                                 info->nr_samplers,
                                                 info->samplers);
         break;
      case PIPE_SHADER_VERTEX:
         ctx->pipe->bind_vertex_sampler_states(ctx->pipe,
                                               info->nr_samplers,
                                               info->samplers);
         break;
      case PIPE_SHADER_GEOMETRY:
         ctx->pipe->bind_geometry_sampler_states(ctx->pipe,
                                               info->nr_samplers,
                                               info->samplers);
         break;
      default:
         assert(!"bad shader type in single_sampler_done()");
      }
d1199 1
d1203 1
d1208 1
a1211 2
   info->nr_views = count;

d1213 4
a1216 12
   switch (shader_stage) {
   case PIPE_SHADER_FRAGMENT:
      ctx->pipe->set_fragment_sampler_views(ctx->pipe, count, info->views);
      break;
   case PIPE_SHADER_VERTEX:
      ctx->pipe->set_vertex_sampler_views(ctx->pipe, count, info->views);
      break;
   case PIPE_SHADER_GEOMETRY:
      ctx->pipe->set_geometry_sampler_views(ctx->pipe, count, info->views);
      break;
   default:
      assert(!"bad shader type in cso_set_sampler_views()");
d1218 2
d1243 1
d1255 2
d1258 1
a1258 13
   switch (shader_stage) {
   case PIPE_SHADER_FRAGMENT:
      ctx->pipe->set_fragment_sampler_views(ctx->pipe, nr_saved, info->views);
      break;
   case PIPE_SHADER_VERTEX:
      ctx->pipe->set_vertex_sampler_views(ctx->pipe, nr_saved, info->views);
      break;
   case PIPE_SHADER_GEOMETRY:
      ctx->pipe->set_geometry_sampler_views(ctx->pipe, nr_saved, info->views);
      break;
   default:
      assert(!"bad shader type in cso_restore_sampler_views()");
   }
d1269 1
a1269 1
                       unsigned append_bitmask)
d1294 1
a1294 1
                                   append_bitmask);
d1320 1
d1331 1
d1337 2
a1343 1
   /* ~0 means append */
d1345 1
a1345 1
                                   ctx->so_targets, ~0);
d1444 20
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d30 1
a30 1
  * 
d39 1
d44 1
d82 6
d89 3
a91 2
   struct sampler_info fragment_samplers;
   struct sampler_info vertex_samplers;
d93 2
a94 2
   uint nr_vertex_buffers;
   struct pipe_vertex_buffer vertex_buffers[PIPE_MAX_ATTRIBS];
d96 5
a100 2
   uint nr_vertex_buffers_saved;
   struct pipe_vertex_buffer vertex_buffers_saved[PIPE_MAX_ATTRIBS];
d108 3
a110 2
   void *fragment_shader, *fragment_shader_saved, *geometry_shader;
   void *vertex_shader, *vertex_shader_saved, *geometry_shader_saved;
d112 3
d122 1
a122 1
   unsigned sample_mask;
d142 2
a143 1
   struct cso_depth_stencil_alpha *cso = (struct cso_depth_stencil_alpha *)state;
a175 22
static boolean delete_fs_state(struct cso_context *ctx, void *state)
{
   struct cso_fragment_shader *cso = (struct cso_fragment_shader *)state;
   if (ctx->fragment_shader == cso->data)
      return FALSE;
   if (cso->delete_state)
      cso->delete_state(cso->context, cso->data);
   FREE(state);
   return TRUE;
}

static boolean delete_vs_state(struct cso_context *ctx, void *state)
{
   struct cso_vertex_shader *cso = (struct cso_vertex_shader *)state;
   if (ctx->vertex_shader == cso->data)
      return TRUE;
   if (cso->delete_state)
      cso->delete_state(cso->context, cso->data);
   FREE(state);
   return FALSE;
}

a196 1
      break;
a198 1
      break;
a200 1
      break;
a202 7
      break;
   case CSO_FRAGMENT_SHADER:
      return delete_fs_state(ctx, state);
      break;
   case CSO_VERTEX_SHADER:
      return delete_vs_state(ctx, state);
      break;
a204 1
      break;
d212 3
a214 2
static INLINE void sanitize_hash(struct cso_hash *hash, enum cso_cache_type type,
                                 int max_size, void *user_data)
d237 20
a263 2
   assert(PIPE_MAX_SAMPLERS == PIPE_MAX_VERTEX_SAMPLERS);

d272 5
d281 9
d293 1
a293 1
   cso_destroy_context( ctx );      
a296 1

d302 1
a302 2
   unsigned i;
   struct sampler_info *info;
d317 2
d322 6
a327 11
   info = &ctx->fragment_samplers;   
   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
      pipe_sampler_view_reference(&info->views_saved[i], NULL);
   }

   /* free vertex samplers, views */
   info = &ctx->vertex_samplers;   
   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
      pipe_sampler_view_reference(&info->views_saved[i], NULL);
d333 12
a344 6
   util_copy_vertex_buffers(ctx->vertex_buffers,
                            &ctx->nr_vertex_buffers,
                            NULL, 0);
   util_copy_vertex_buffers(ctx->vertex_buffers_saved,
                            &ctx->nr_vertex_buffers_saved,
                            NULL, 0);
d360 2
d384 3
a386 2
   key_size = templ->independent_blend_enable ? sizeof(struct pipe_blend_state) :
              (char *)&(templ->rt[1]) - (char *)templ;
d388 2
a389 1
   iter = cso_find_state_template(ctx->cache, hash_key, CSO_BLEND, (void*)templ, key_size);
d438 3
a440 2
enum pipe_error cso_set_depth_stencil_alpha(struct cso_context *ctx,
                                            const struct pipe_depth_stencil_alpha_state *templ)
d445 1
a445 1
                                                       hash_key, 
d451 2
a452 1
      struct cso_depth_stencil_alpha *cso = MALLOC(sizeof(struct cso_depth_stencil_alpha));
d457 4
a460 2
      cso->data = ctx->pipe->create_depth_stencil_alpha_state(ctx->pipe, &cso->state);
      cso->delete_state = (cso_state_callback)ctx->pipe->delete_depth_stencil_alpha_state;
d463 2
a464 1
      iter = cso_insert_state(ctx->cache, hash_key, CSO_DEPTH_STENCIL_ALPHA, cso);
d473 2
a474 1
      handle = ((struct cso_depth_stencil_alpha *)cso_hash_iter_data(iter))->data;
d494 2
a495 1
      ctx->pipe->bind_depth_stencil_alpha_state(ctx->pipe, ctx->depth_stencil_saved);
d508 2
a509 1
                                                       hash_key, CSO_RASTERIZER,
d520 2
a521 1
      cso->delete_state = (cso_state_callback)ctx->pipe->delete_rasterizer_state;
d559 1
a559 3

enum pipe_error cso_set_fragment_shader_handle(struct cso_context *ctx,
                                               void *handle )
a564 1
   return PIPE_OK;
a576 46
/* Not really working:
 */
#if 0
enum pipe_error cso_set_fragment_shader(struct cso_context *ctx,
                                        const struct pipe_shader_state *templ)
{
   const struct tgsi_token *tokens = templ->tokens;
   unsigned num_tokens = tgsi_num_tokens(tokens);
   size_t tokens_size = num_tokens*sizeof(struct tgsi_token);
   unsigned hash_key = cso_construct_key((void*)tokens, tokens_size);
   struct cso_hash_iter iter = cso_find_state_template(ctx->cache,
                                                       hash_key, 
                                                       CSO_FRAGMENT_SHADER,
                                                       (void*)tokens,
                                                       sizeof(*templ)); /* XXX correct? tokens_size? */
   void *handle = NULL;

   if (cso_hash_iter_is_null(iter)) {
      struct cso_fragment_shader *cso = MALLOC(sizeof(struct cso_fragment_shader) + tokens_size);
      struct tgsi_token *cso_tokens = (struct tgsi_token *)((char *)cso + sizeof(*cso));

      if (!cso)
         return PIPE_ERROR_OUT_OF_MEMORY;

      memcpy(cso_tokens, tokens, tokens_size);
      cso->state.tokens = cso_tokens;
      cso->data = ctx->pipe->create_fs_state(ctx->pipe, &cso->state);
      cso->delete_state = (cso_state_callback)ctx->pipe->delete_fs_state;
      cso->context = ctx->pipe;

      iter = cso_insert_state(ctx->cache, hash_key, CSO_FRAGMENT_SHADER, cso);
      if (cso_hash_iter_is_null(iter)) {
         FREE(cso);
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      handle = cso->data;
   }
   else {
      handle = ((struct cso_fragment_shader *)cso_hash_iter_data(iter))->data;
   }

   return cso_set_fragment_shader_handle( ctx, handle );
}
#endif

d593 1
a593 2
enum pipe_error cso_set_vertex_shader_handle(struct cso_context *ctx,
                                             void *handle )
a598 1
   return PIPE_OK;
a610 44

/* Not really working:
 */
#if 0
enum pipe_error cso_set_vertex_shader(struct cso_context *ctx,
                                      const struct pipe_shader_state *templ)
{
   unsigned hash_key = cso_construct_key((void*)templ,
                                         sizeof(struct pipe_shader_state));
   struct cso_hash_iter iter = cso_find_state_template(ctx->cache,
                                                       hash_key, CSO_VERTEX_SHADER,
                                                       (void*)templ,
                                                       sizeof(*templ));
   void *handle = NULL;

   if (cso_hash_iter_is_null(iter)) {
      struct cso_vertex_shader *cso = MALLOC(sizeof(struct cso_vertex_shader));

      if (!cso)
         return PIPE_ERROR_OUT_OF_MEMORY;

      memcpy(cso->state, templ, sizeof(*templ));
      cso->data = ctx->pipe->create_vs_state(ctx->pipe, &cso->state);
      cso->delete_state = (cso_state_callback)ctx->pipe->delete_vs_state;
      cso->context = ctx->pipe;

      iter = cso_insert_state(ctx->cache, hash_key, CSO_VERTEX_SHADER, cso);
      if (cso_hash_iter_is_null(iter)) {
         FREE(cso);
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      handle = cso->data;
   }
   else {
      handle = ((struct cso_vertex_shader *)cso_hash_iter_data(iter))->data;
   }

   return cso_set_vertex_shader_handle( ctx, handle );
}
#endif



d627 2
a628 2
enum pipe_error cso_set_framebuffer(struct cso_context *ctx,
                                    const struct pipe_framebuffer_state *fb)
a633 1
   return PIPE_OK;
d651 2
a652 2
enum pipe_error cso_set_viewport(struct cso_context *ctx,
                                 const struct pipe_viewport_state *vp)
d656 1
a656 1
      ctx->pipe->set_viewport_state(ctx->pipe, vp);
a657 1
   return PIPE_OK;
d670 1
a670 1
      ctx->pipe->set_viewport_state(ctx->pipe, &ctx->vp);
d675 2
a676 2
enum pipe_error cso_set_blend_color(struct cso_context *ctx,
                                    const struct pipe_blend_color *bc)
a681 1
   return PIPE_OK;
d684 1
a684 2
enum pipe_error cso_set_sample_mask(struct cso_context *ctx,
                                    unsigned sample_mask)
a689 1
   return PIPE_OK;
d692 12
a703 2
enum pipe_error cso_set_stencil_ref(struct cso_context *ctx,
                                    const struct pipe_stencil_ref *sr)
a708 1
   return PIPE_OK;
d719 2
a720 1
   if (memcmp(&ctx->stencil_ref, &ctx->stencil_ref_saved, sizeof(ctx->stencil_ref))) {
d726 31
a756 2
enum pipe_error cso_set_geometry_shader_handle(struct cso_context *ctx,
                                               void *handle)
d758 3
a760 1
   if (ctx->geometry_shader != handle) {
a763 1
   return PIPE_OK;
d778 4
d788 4
d805 1
a805 5
   dst->depth_clamp = src->depth_clamp;
   dst->nr = src->nr;
   if (src->nr) {
      memcpy(dst->ucp, src->ucp, src->nr * sizeof(src->ucp[0]));
   }
d812 1
a812 10
   if (a->depth_clamp != b->depth_clamp) {
      return 1;
   }
   if (a->nr != b->nr) {
      return 1;
   }
   if (a->nr) {
      return memcmp(a->ucp, b->ucp, a->nr * sizeof(a->ucp[0]));
   }
   return 0;
d840 4
a843 3
enum pipe_error cso_set_vertex_elements(struct cso_context *ctx,
                                        unsigned count,
                                        const struct pipe_vertex_element *states)
d845 1
d851 10
a860 4
   /* need to include the count into the stored state data too.
      Otherwise first few count pipe_vertex_elements could be identical even if count
      is different, and there's no guarantee the hash would be different in that
      case neither */
d863 2
a864 1
   memcpy(velems_state.velems, states, sizeof(struct pipe_vertex_element) * count);
d866 2
a867 1
   iter = cso_find_state_template(ctx->cache, hash_key, CSO_VELEMENTS, (void*)&velems_state, key_size);
d875 4
a878 2
      cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, count, &cso->state.velems[0]);
      cso->delete_state = (cso_state_callback)ctx->pipe->delete_vertex_elements_state;
d902 7
d915 7
d932 1
a932 1
                            unsigned count,
d935 25
a959 6
   if (count != ctx->nr_vertex_buffers ||
       memcmp(buffers, ctx->vertex_buffers,
              sizeof(struct pipe_vertex_buffer) * count) != 0) {
      util_copy_vertex_buffers(ctx->vertex_buffers, &ctx->nr_vertex_buffers,
                               buffers, count);
      ctx->pipe->set_vertex_buffers(ctx->pipe, count, buffers);
d961 2
d965 1
a965 1
void cso_save_vertex_buffers(struct cso_context *ctx)
d967 11
a977 4
   util_copy_vertex_buffers(ctx->vertex_buffers_saved,
                            &ctx->nr_vertex_buffers_saved,
                            ctx->vertex_buffers,
                            ctx->nr_vertex_buffers);
d980 1
a980 1
void cso_restore_vertex_buffers(struct cso_context *ctx)
d982 15
a996 6
   util_copy_vertex_buffers(ctx->vertex_buffers,
                            &ctx->nr_vertex_buffers,
                            ctx->vertex_buffers_saved,
                            ctx->nr_vertex_buffers_saved);
   ctx->pipe->set_vertex_buffers(ctx->pipe, ctx->nr_vertex_buffers,
                                 ctx->vertex_buffers);
d1025 2
a1026 1
         cso->delete_state = (cso_state_callback)ctx->pipe->delete_sampler_state;
d1049 1
d1053 1
a1053 9
   return single_sampler(ctx, &ctx->fragment_samplers, idx, templ);
}

enum pipe_error
cso_single_vertex_sampler(struct cso_context *ctx,
                          unsigned idx,
                          const struct pipe_sampler_state *templ)
{
   return single_sampler(ctx, &ctx->vertex_samplers, idx, templ);
d1059 1
a1059 2
single_sampler_done(struct cso_context *ctx,
                    struct sampler_info *info)
d1061 1
d1075 1
a1075 1
              info->nr_samplers * sizeof(void *)) != 0) 
d1082 2
a1083 1
      if (info == &ctx->fragment_samplers) {
d1087 2
a1088 2
      }
      else if (info == &ctx->vertex_samplers) {
d1092 8
a1099 3
      }
      else {
         assert(0);
d1105 1
a1105 7
cso_single_sampler_done( struct cso_context *ctx )
{
   single_sampler_done(ctx, &ctx->fragment_samplers);
}

void
cso_single_vertex_sampler_done(struct cso_context *ctx)
d1107 1
a1107 1
   single_sampler_done(ctx, &ctx->vertex_samplers);
d1116 5
a1120 5
static enum pipe_error
set_samplers(struct cso_context *ctx,
             struct sampler_info *info,
             unsigned nr,
             const struct pipe_sampler_state **templates)
d1122 1
d1141 1
a1141 1
   single_sampler_done(ctx, info);
d1146 2
a1147 4
enum pipe_error
cso_set_samplers(struct cso_context *ctx,
                 unsigned nr,
                 const struct pipe_sampler_state **templates)
d1149 3
a1151 1
   return set_samplers(ctx, &ctx->fragment_samplers, nr, templates);
d1154 3
a1156 4
enum pipe_error
cso_set_vertex_samplers(struct cso_context *ctx,
                        unsigned nr,
                        const struct pipe_sampler_state **templates)
d1158 4
a1161 1
   return set_samplers(ctx, &ctx->vertex_samplers, nr, templates);
d1165 8
d1174 25
a1198 5
static void
save_samplers(struct cso_context *ctx, struct sampler_info *info)
{
   info->nr_samplers_saved = info->nr_samplers;
   memcpy(info->samplers_saved, info->samplers, sizeof(info->samplers));
d1201 1
d1203 1
a1203 1
cso_save_samplers(struct cso_context *ctx)
d1205 9
a1213 1
   save_samplers(ctx, &ctx->fragment_samplers);
d1216 1
d1218 1
a1218 1
cso_save_vertex_samplers(struct cso_context *ctx)
d1220 2
a1221 2
   save_samplers(ctx, &ctx->vertex_samplers);
}
d1223 9
d1233 14
d1248 2
a1249 6
static void
restore_samplers(struct cso_context *ctx, struct sampler_info *info)
{
   info->nr_samplers = info->nr_samplers_saved;
   memcpy(info->samplers, info->samplers_saved, sizeof(info->samplers));
   single_sampler_done(ctx, info);
d1252 1
d1254 4
a1257 1
cso_restore_samplers(struct cso_context *ctx)
d1259 25
a1283 1
   restore_samplers(ctx, &ctx->fragment_samplers);
d1287 1
a1287 1
cso_restore_vertex_samplers(struct cso_context *ctx)
d1289 1
a1289 2
   restore_samplers(ctx, &ctx->vertex_samplers);
}
d1291 3
d1295 1
d1297 8
a1304 8
static void
set_sampler_views(struct cso_context *ctx,
                  struct sampler_info *info,
                  void (*set_views)(struct pipe_context *,
                                    unsigned num_views,
                                    struct pipe_sampler_view **),
                  uint count,
                  struct pipe_sampler_view **views)
d1306 1
d1309 14
a1322 3
   /* reference new views */
   for (i = 0; i < count; i++) {
      pipe_sampler_view_reference(&info->views[i], views[i]);
d1324 2
a1325 3
   /* unref extra old views, if any */
   for (; i < info->nr_views; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
d1328 3
a1330 1
   info->nr_views = count;
d1332 2
a1333 2
   /* bind the new sampler views */
   set_views(ctx->pipe, count, info->views);
d1336 1
a1336 9
void
cso_set_fragment_sampler_views(struct cso_context *ctx,
                               uint count,
                               struct pipe_sampler_view **views)
{
   set_sampler_views(ctx, &ctx->fragment_samplers,
                     ctx->pipe->set_fragment_sampler_views,
                     count, views);
}
d1339 4
a1342 8
cso_set_vertex_sampler_views(struct cso_context *ctx,
                             uint count,
                             struct pipe_sampler_view **views)
{
   set_sampler_views(ctx, &ctx->vertex_samplers,
                     ctx->pipe->set_vertex_sampler_views,
                     count, views);
}
d1344 1
d1346 4
d1351 15
a1365 11
static void
save_sampler_views(struct cso_context *ctx,
                   struct sampler_info *info)
{
   uint i;

   info->nr_views_saved = info->nr_views;

   for (i = 0; i < info->nr_views; i++) {
      assert(!info->views_saved[i]);
      pipe_sampler_view_reference(&info->views_saved[i], info->views[i]);
d1370 2
a1371 1
cso_save_fragment_sampler_views(struct cso_context *ctx)
d1373 2
a1374 1
   save_sampler_views(ctx, &ctx->fragment_samplers);
d1378 2
a1379 1
cso_save_vertex_sampler_views(struct cso_context *ctx)
d1381 4
a1384 1
   save_sampler_views(ctx, &ctx->vertex_samplers);
d1387 1
d1389 3
a1391 6
static void
restore_sampler_views(struct cso_context *ctx,
                      struct sampler_info *info,
                      void (*set_views)(struct pipe_context *,
                                        unsigned num_views,
                                        struct pipe_sampler_view **))
d1393 1
a1393 1
   uint i;
d1395 5
a1399 6
   for (i = 0; i < info->nr_views_saved; i++) {
      pipe_sampler_view_reference(&info->views[i], info->views_saved[i]);
      pipe_sampler_view_reference(&info->views_saved[i], NULL);
   }
   for (; i < info->nr_views; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
a1400 6

   /* bind the old/saved sampler views */
   set_views(ctx->pipe, info->nr_views_saved, info->views);

   info->nr_views = info->nr_views_saved;
   info->nr_views_saved = 0;
d1404 2
a1405 1
cso_restore_fragment_sampler_views(struct cso_context *ctx)
d1407 8
a1414 2
   restore_sampler_views(ctx, &ctx->fragment_samplers,
                         ctx->pipe->set_fragment_sampler_views);
d1418 1
a1418 1
cso_restore_vertex_sampler_views(struct cso_context *ctx)
d1420 11
a1430 2
   restore_sampler_views(ctx, &ctx->vertex_samplers,
                         ctx->pipe->set_vertex_sampler_views);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a49 3
struct cso_context {
   struct pipe_context *pipe;
   struct cso_cache *cache;
d51 6
a59 3

      void *vertex_samplers[PIPE_MAX_VERTEX_SAMPLERS];
      unsigned nr_vertex_samplers;
d65 9
a73 2
   void *vertex_samplers[PIPE_MAX_VERTEX_SAMPLERS];
   unsigned nr_vertex_samplers;
a74 2
   unsigned nr_samplers_saved;
   void *samplers_saved[PIPE_MAX_SAMPLERS];
a75 2
   unsigned nr_vertex_samplers_saved;
   void *vertex_samplers_saved[PIPE_MAX_VERTEX_SAMPLERS];
d77 3
a79 2
   uint nr_fragment_sampler_views;
   struct pipe_sampler_view *fragment_sampler_views[PIPE_MAX_SAMPLERS];
d81 2
a82 2
   uint nr_vertex_sampler_views;
   struct pipe_sampler_view *vertex_sampler_views[PIPE_MAX_VERTEX_SAMPLERS];
d84 2
a85 2
   uint nr_fragment_sampler_views_saved;
   struct pipe_sampler_view *fragment_sampler_views_saved[PIPE_MAX_SAMPLERS];
d87 2
a88 2
   uint nr_vertex_sampler_views_saved;
   struct pipe_sampler_view *vertex_sampler_views_saved[PIPE_MAX_VERTEX_SAMPLERS];
d259 2
d287 2
a288 1
   
d304 2
d307 2
a308 2
      pipe_sampler_view_reference(&ctx->fragment_sampler_views[i], NULL);
      pipe_sampler_view_reference(&ctx->fragment_sampler_views_saved[i], NULL);
d311 5
a315 3
   for (i = 0; i < PIPE_MAX_VERTEX_SAMPLERS; i++) {
      pipe_sampler_view_reference(&ctx->vertex_sampler_views[i], NULL);
      pipe_sampler_view_reference(&ctx->vertex_sampler_views_saved[i], NULL);
d321 7
a415 227
enum pipe_error cso_single_sampler(struct cso_context *ctx,
                                   unsigned idx,
                                   const struct pipe_sampler_state *templ)
{
   void *handle = NULL;

   if (templ != NULL) {
      unsigned key_size = sizeof(struct pipe_sampler_state);
      unsigned hash_key = cso_construct_key((void*)templ, key_size);
      struct cso_hash_iter iter = cso_find_state_template(ctx->cache,
                                                          hash_key, CSO_SAMPLER,
                                                          (void*)templ, key_size);

      if (cso_hash_iter_is_null(iter)) {
         struct cso_sampler *cso = MALLOC(sizeof(struct cso_sampler));
         if (!cso)
            return PIPE_ERROR_OUT_OF_MEMORY;

         memcpy(&cso->state, templ, sizeof(*templ));
         cso->data = ctx->pipe->create_sampler_state(ctx->pipe, &cso->state);
         cso->delete_state = (cso_state_callback)ctx->pipe->delete_sampler_state;
         cso->context = ctx->pipe;

         iter = cso_insert_state(ctx->cache, hash_key, CSO_SAMPLER, cso);
         if (cso_hash_iter_is_null(iter)) {
            FREE(cso);
            return PIPE_ERROR_OUT_OF_MEMORY;
         }

         handle = cso->data;
      }
      else {
         handle = ((struct cso_sampler *)cso_hash_iter_data(iter))->data;
      }
   }

   ctx->samplers[idx] = handle;
   return PIPE_OK;
}

enum pipe_error
cso_single_vertex_sampler(struct cso_context *ctx,
                          unsigned idx,
                          const struct pipe_sampler_state *templ)
{
   void *handle = NULL;

   if (templ != NULL) {
      unsigned key_size = sizeof(struct pipe_sampler_state);
      unsigned hash_key = cso_construct_key((void*)templ, key_size);
      struct cso_hash_iter iter = cso_find_state_template(ctx->cache,
                                                          hash_key, CSO_SAMPLER,
                                                          (void*)templ, key_size);

      if (cso_hash_iter_is_null(iter)) {
         struct cso_sampler *cso = MALLOC(sizeof(struct cso_sampler));
         if (!cso)
            return PIPE_ERROR_OUT_OF_MEMORY;

         memcpy(&cso->state, templ, sizeof(*templ));
         cso->data = ctx->pipe->create_sampler_state(ctx->pipe, &cso->state);
         cso->delete_state = (cso_state_callback)ctx->pipe->delete_sampler_state;
         cso->context = ctx->pipe;

         iter = cso_insert_state(ctx->cache, hash_key, CSO_SAMPLER, cso);
         if (cso_hash_iter_is_null(iter)) {
            FREE(cso);
            return PIPE_ERROR_OUT_OF_MEMORY;
         }

         handle = cso->data;
      }
      else {
         handle = ((struct cso_sampler *)cso_hash_iter_data(iter))->data;
      }
   }

   ctx->vertex_samplers[idx] = handle;
   return PIPE_OK;
}

void cso_single_sampler_done( struct cso_context *ctx )
{
   unsigned i;

   /* find highest non-null sampler */
   for (i = PIPE_MAX_SAMPLERS; i > 0; i--) {
      if (ctx->samplers[i - 1] != NULL)
         break;
   }

   ctx->nr_samplers = i;

   if (ctx->hw.nr_samplers != ctx->nr_samplers ||
       memcmp(ctx->hw.samplers,
              ctx->samplers,
              ctx->nr_samplers * sizeof(void *)) != 0) 
   {
      memcpy(ctx->hw.samplers, ctx->samplers, ctx->nr_samplers * sizeof(void *));
      ctx->hw.nr_samplers = ctx->nr_samplers;

      ctx->pipe->bind_fragment_sampler_states(ctx->pipe, ctx->nr_samplers, ctx->samplers);
   }
}

void
cso_single_vertex_sampler_done(struct cso_context *ctx)
{
   unsigned i;

   /* find highest non-null sampler */
   for (i = PIPE_MAX_VERTEX_SAMPLERS; i > 0; i--) {
      if (ctx->vertex_samplers[i - 1] != NULL)
         break;
   }

   ctx->nr_vertex_samplers = i;

   if (ctx->hw.nr_vertex_samplers != ctx->nr_vertex_samplers ||
       memcmp(ctx->hw.vertex_samplers,
              ctx->vertex_samplers,
              ctx->nr_vertex_samplers * sizeof(void *)) != 0) 
   {
      memcpy(ctx->hw.vertex_samplers,
             ctx->vertex_samplers,
             ctx->nr_vertex_samplers * sizeof(void *));
      ctx->hw.nr_vertex_samplers = ctx->nr_vertex_samplers;

      ctx->pipe->bind_vertex_sampler_states(ctx->pipe,
                                            ctx->nr_vertex_samplers,
                                            ctx->vertex_samplers);
   }
}

/*
 * If the function encouters any errors it will return the
 * last one. Done to always try to set as many samplers
 * as possible.
 */
enum pipe_error cso_set_samplers( struct cso_context *ctx,
                                  unsigned nr,
                                  const struct pipe_sampler_state **templates )
{
   unsigned i;
   enum pipe_error temp, error = PIPE_OK;

   /* TODO: fastpath
    */

   for (i = 0; i < nr; i++) {
      temp = cso_single_sampler( ctx, i, templates[i] );
      if (temp != PIPE_OK)
         error = temp;
   }

   for ( ; i < ctx->nr_samplers; i++) {
      temp = cso_single_sampler( ctx, i, NULL );
      if (temp != PIPE_OK)
         error = temp;
   }

   cso_single_sampler_done( ctx );

   return error;
}

void cso_save_samplers(struct cso_context *ctx)
{
   ctx->nr_samplers_saved = ctx->nr_samplers;
   memcpy(ctx->samplers_saved, ctx->samplers, sizeof(ctx->samplers));
}

void cso_restore_samplers(struct cso_context *ctx)
{
   ctx->nr_samplers = ctx->nr_samplers_saved;
   memcpy(ctx->samplers, ctx->samplers_saved, sizeof(ctx->samplers));
   cso_single_sampler_done( ctx );
}

/*
 * If the function encouters any errors it will return the
 * last one. Done to always try to set as many samplers
 * as possible.
 */
enum pipe_error cso_set_vertex_samplers(struct cso_context *ctx,
                                        unsigned nr,
                                        const struct pipe_sampler_state **templates)
{
   unsigned i;
   enum pipe_error temp, error = PIPE_OK;

   /* TODO: fastpath
    */

   for (i = 0; i < nr; i++) {
      temp = cso_single_vertex_sampler( ctx, i, templates[i] );
      if (temp != PIPE_OK)
         error = temp;
   }

   for ( ; i < ctx->nr_vertex_samplers; i++) {
      temp = cso_single_vertex_sampler( ctx, i, NULL );
      if (temp != PIPE_OK)
         error = temp;
   }

   cso_single_vertex_sampler_done( ctx );

   return error;
}

void
cso_save_vertex_samplers(struct cso_context *ctx)
{
   ctx->nr_vertex_samplers_saved = ctx->nr_vertex_samplers;
   memcpy(ctx->vertex_samplers_saved, ctx->vertex_samplers, sizeof(ctx->vertex_samplers));
}

void
cso_restore_vertex_samplers(struct cso_context *ctx)
{
   ctx->nr_vertex_samplers = ctx->nr_vertex_samplers_saved;
   memcpy(ctx->vertex_samplers, ctx->vertex_samplers_saved, sizeof(ctx->vertex_samplers));
   cso_single_vertex_sampler_done(ctx);
}


d937 33
a969 1
/* fragment sampler view state */
d971 7
a977 4
void
cso_set_fragment_sampler_views(struct cso_context *cso,
                               uint count,
                               struct pipe_sampler_view **views)
d979 25
a1003 1
   uint i;
d1005 5
a1009 5
   for (i = 0; i < count; i++) {
      pipe_sampler_view_reference(&cso->fragment_sampler_views[i], views[i]);
   }
   for (; i < cso->nr_fragment_sampler_views; i++) {
      pipe_sampler_view_reference(&cso->fragment_sampler_views[i], NULL);
d1012 4
a1015 3
   cso->pipe->set_fragment_sampler_views(cso->pipe,
                                         MAX2(count, cso->nr_fragment_sampler_views),
                                         cso->fragment_sampler_views);
d1017 14
a1030 1
   cso->nr_fragment_sampler_views = count;
d1033 5
a1037 2
void
cso_save_fragment_sampler_views(struct cso_context *cso)
d1039 1
a1039 1
   uint i;
d1041 5
a1045 1
   cso->nr_fragment_sampler_views_saved = cso->nr_fragment_sampler_views;
d1047 1
a1047 2
   for (i = 0; i < cso->nr_fragment_sampler_views; i++) {
      assert(!cso->fragment_sampler_views_saved[i]);
d1049 23
a1071 2
      pipe_sampler_view_reference(&cso->fragment_sampler_views_saved[i],
                                  cso->fragment_sampler_views[i]);
d1076 1
a1076 1
cso_restore_fragment_sampler_views(struct cso_context *cso)
d1078 26
a1103 1
   uint i;
d1105 4
a1108 3
   for (i = 0; i < cso->nr_fragment_sampler_views_saved; i++) {
      pipe_sampler_view_reference(&cso->fragment_sampler_views[i], cso->fragment_sampler_views_saved[i]);
      pipe_sampler_view_reference(&cso->fragment_sampler_views_saved[i], NULL);
d1110 5
a1114 2
   for (; i < cso->nr_fragment_sampler_views; i++) {
      pipe_sampler_view_reference(&cso->fragment_sampler_views[i], NULL);
d1117 12
a1128 3
   cso->pipe->set_fragment_sampler_views(cso->pipe,
                                         MAX2(cso->nr_fragment_sampler_views, cso->nr_fragment_sampler_views_saved),
                                         cso->fragment_sampler_views);
d1130 6
a1135 2
   cso->nr_fragment_sampler_views = cso->nr_fragment_sampler_views_saved;
   cso->nr_fragment_sampler_views_saved = 0;
d1139 13
a1151 1
/* vertex sampler view state */
d1154 37
a1190 3
cso_set_vertex_sampler_views(struct cso_context *cso,
                             uint count,
                             struct pipe_sampler_view **views)
d1194 1
d1196 1
a1196 1
      pipe_sampler_view_reference(&cso->vertex_sampler_views[i], views[i]);
d1198 3
a1200 2
   for (; i < cso->nr_vertex_sampler_views; i++) {
      pipe_sampler_view_reference(&cso->vertex_sampler_views[i], NULL);
d1203 1
a1203 3
   cso->pipe->set_vertex_sampler_views(cso->pipe,
                                       MAX2(count, cso->nr_vertex_sampler_views),
                                       cso->vertex_sampler_views);
d1205 2
a1206 1
   cso->nr_vertex_sampler_views = count;
d1210 24
a1233 1
cso_save_vertex_sampler_views(struct cso_context *cso)
d1237 1
a1237 1
   cso->nr_vertex_sampler_views_saved = cso->nr_vertex_sampler_views;
d1239 5
a1243 2
   for (i = 0; i < cso->nr_vertex_sampler_views; i++) {
      assert(!cso->vertex_sampler_views_saved[i]);
d1245 4
a1248 3
      pipe_sampler_view_reference(&cso->vertex_sampler_views_saved[i],
                                  cso->vertex_sampler_views[i]);
   }
d1252 12
a1263 1
cso_restore_vertex_sampler_views(struct cso_context *cso)
d1267 3
a1269 3
   for (i = 0; i < cso->nr_vertex_sampler_views_saved; i++) {
      pipe_sampler_view_reference(&cso->vertex_sampler_views[i], cso->vertex_sampler_views_saved[i]);
      pipe_sampler_view_reference(&cso->vertex_sampler_views_saved[i], NULL);
d1271 2
a1272 2
   for (; i < cso->nr_vertex_sampler_views; i++) {
      pipe_sampler_view_reference(&cso->vertex_sampler_views[i], NULL);
d1275 13
a1287 3
   cso->pipe->set_vertex_sampler_views(cso->pipe,
                                       MAX2(cso->nr_vertex_sampler_views, cso->nr_vertex_sampler_views_saved),
                                       cso->vertex_sampler_views);
d1289 5
a1293 2
   cso->nr_vertex_sampler_views = cso->nr_vertex_sampler_views_saved;
   cso->nr_vertex_sampler_views_saved = 0;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 1
d41 1
d74 2
a75 2
   struct pipe_texture *textures[PIPE_MAX_SAMPLERS];
   uint nr_textures;
d77 2
a78 2
   struct pipe_texture *vertex_textures[PIPE_MAX_VERTEX_SAMPLERS];
   uint nr_vertex_textures;
d80 2
a81 2
   uint nr_textures_saved;
   struct pipe_texture *textures_saved[PIPE_MAX_SAMPLERS];
d83 2
a84 2
   uint nr_vertex_textures_saved;
   struct pipe_texture *vertex_textures_saved[PIPE_MAX_SAMPLERS];
d94 1
d102 1
a106 4
static void
free_framebuffer_state(struct pipe_framebuffer_state *fb);


d177 14
d214 3
d291 4
d298 2
a299 2
      pipe_texture_reference(&ctx->textures[i], NULL);
      pipe_texture_reference(&ctx->textures_saved[i], NULL);
d303 2
a304 2
      pipe_texture_reference(&ctx->vertex_textures[i], NULL);
      pipe_texture_reference(&ctx->vertex_textures_saved[i], NULL);
d307 2
a308 2
   free_framebuffer_state(&ctx->fb);
   free_framebuffer_state(&ctx->fb_saved);
d317 4
a323 1
      /*cso_release_all( ctx );*/
d356 1
d598 1
a598 1
   for ( ; i < ctx->nr_samplers; i++) {
a624 108
enum pipe_error cso_set_sampler_textures( struct cso_context *ctx,
                                          uint count,
                                          struct pipe_texture **textures )
{
   uint i;

   ctx->nr_textures = count;

   for (i = 0; i < count; i++)
      pipe_texture_reference(&ctx->textures[i], textures[i]);
   for ( ; i < PIPE_MAX_SAMPLERS; i++)
      pipe_texture_reference(&ctx->textures[i], NULL);

   ctx->pipe->set_fragment_sampler_textures(ctx->pipe, count, textures);

   return PIPE_OK;
}

void cso_save_sampler_textures( struct cso_context *ctx )
{
   uint i;

   ctx->nr_textures_saved = ctx->nr_textures;
   for (i = 0; i < ctx->nr_textures; i++) {
      assert(!ctx->textures_saved[i]);
      pipe_texture_reference(&ctx->textures_saved[i], ctx->textures[i]);
   }
}

void cso_restore_sampler_textures( struct cso_context *ctx )
{
   uint i;

   ctx->nr_textures = ctx->nr_textures_saved;

   for (i = 0; i < ctx->nr_textures; i++) {
      pipe_texture_reference(&ctx->textures[i], NULL);
      ctx->textures[i] = ctx->textures_saved[i];
      ctx->textures_saved[i] = NULL;
   }
   for ( ; i < PIPE_MAX_SAMPLERS; i++)
      pipe_texture_reference(&ctx->textures[i], NULL);

   ctx->pipe->set_fragment_sampler_textures(ctx->pipe, ctx->nr_textures, ctx->textures);

   ctx->nr_textures_saved = 0;
}



enum pipe_error
cso_set_vertex_sampler_textures(struct cso_context *ctx,
                                uint count,
                                struct pipe_texture **textures)
{
   uint i;

   ctx->nr_vertex_textures = count;

   for (i = 0; i < count; i++) {
      pipe_texture_reference(&ctx->vertex_textures[i], textures[i]);
   }
   for ( ; i < PIPE_MAX_VERTEX_SAMPLERS; i++) {
      pipe_texture_reference(&ctx->vertex_textures[i], NULL);
   }

   ctx->pipe->set_vertex_sampler_textures(ctx->pipe, count, textures);

   return PIPE_OK;
}

void
cso_save_vertex_sampler_textures(struct cso_context *ctx)
{
   uint i;

   ctx->nr_vertex_textures_saved = ctx->nr_vertex_textures;
   for (i = 0; i < ctx->nr_vertex_textures; i++) {
      assert(!ctx->vertex_textures_saved[i]);
      pipe_texture_reference(&ctx->vertex_textures_saved[i], ctx->vertex_textures[i]);
   }
}

void
cso_restore_vertex_sampler_textures(struct cso_context *ctx)
{
   uint i;

   ctx->nr_vertex_textures = ctx->nr_vertex_textures_saved;

   for (i = 0; i < ctx->nr_vertex_textures; i++) {
      pipe_texture_reference(&ctx->vertex_textures[i], NULL);
      ctx->vertex_textures[i] = ctx->vertex_textures_saved[i];
      ctx->vertex_textures_saved[i] = NULL;
   }
   for ( ; i < PIPE_MAX_VERTEX_SAMPLERS; i++) {
      pipe_texture_reference(&ctx->vertex_textures[i], NULL);
   }

   ctx->pipe->set_vertex_sampler_textures(ctx->pipe,
                                          ctx->nr_vertex_textures,
                                          ctx->vertex_textures);

   ctx->nr_vertex_textures_saved = 0;
}



a899 31
/**
 * Copy framebuffer state from src to dst with refcounting of surfaces.
 */
static void
copy_framebuffer_state(struct pipe_framebuffer_state *dst,
                       const struct pipe_framebuffer_state *src)
{
   uint i;

   dst->width = src->width;
   dst->height = src->height;
   dst->nr_cbufs = src->nr_cbufs;
   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
      pipe_surface_reference(&dst->cbufs[i], src->cbufs[i]);
   }
   pipe_surface_reference(&dst->zsbuf, src->zsbuf);
}


static void
free_framebuffer_state(struct pipe_framebuffer_state *fb)
{
   uint i;

   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
      pipe_surface_reference(&fb->cbufs[i], NULL);
   }
   pipe_surface_reference(&fb->zsbuf, NULL);
}


d904 1
a904 1
      copy_framebuffer_state(&ctx->fb, fb);
d912 1
a912 1
   copy_framebuffer_state(&ctx->fb_saved, &ctx->fb);
d918 1
a918 1
      copy_framebuffer_state(&ctx->fb, &ctx->fb_saved);
d920 1
a920 1
      free_framebuffer_state(&ctx->fb_saved);
d960 10
a1028 1

d1035 1
d1046 3
d1081 182
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a38 1
#include "util/u_framebuffer.h"
a39 1
#include "util/u_math.h"
d72 2
a73 2
   uint nr_fragment_sampler_views;
   struct pipe_sampler_view *fragment_sampler_views[PIPE_MAX_SAMPLERS];
d75 2
a76 2
   uint nr_vertex_sampler_views;
   struct pipe_sampler_view *vertex_sampler_views[PIPE_MAX_VERTEX_SAMPLERS];
d78 2
a79 2
   uint nr_fragment_sampler_views_saved;
   struct pipe_sampler_view *fragment_sampler_views_saved[PIPE_MAX_SAMPLERS];
d81 2
a82 2
   uint nr_vertex_sampler_views_saved;
   struct pipe_sampler_view *vertex_sampler_views_saved[PIPE_MAX_VERTEX_SAMPLERS];
a91 1
   void *velements, *velements_saved;
a98 1
   unsigned sample_mask;
d103 4
a176 14
static boolean delete_vertex_elements(struct cso_context *ctx,
                                      void *state)
{
   struct cso_velements *cso = (struct cso_velements *)state;

   if (ctx->velements == cso->data)
      return FALSE;

   if (cso->delete_state)
      cso->delete_state(cso->context, cso->data);
   FREE(state);
   return TRUE;
}

a199 3
   case CSO_VELEMENTS:
      return delete_vertex_elements(ctx, state);
      break;
a273 4
      ctx->pipe->bind_vertex_elements_state( ctx->pipe, NULL );
      ctx->pipe->set_fragment_sampler_views(ctx->pipe, 0, NULL);
      if (ctx->pipe->set_vertex_sampler_views)
         ctx->pipe->set_vertex_sampler_views(ctx->pipe, 0, NULL);
d277 2
a278 2
      pipe_sampler_view_reference(&ctx->fragment_sampler_views[i], NULL);
      pipe_sampler_view_reference(&ctx->fragment_sampler_views_saved[i], NULL);
d282 2
a283 2
      pipe_sampler_view_reference(&ctx->vertex_sampler_views[i], NULL);
      pipe_sampler_view_reference(&ctx->vertex_sampler_views_saved[i], NULL);
d286 2
a287 2
   util_unreference_framebuffer_state(&ctx->fb);
   util_unreference_framebuffer_state(&ctx->fb_saved);
a295 4
/**
 * Free the CSO context.  NOTE: the state tracker should have previously called
 * cso_release_all().
 */
d299 1
a331 1
      memset(&cso->state, 0, sizeof cso->state);
d573 1
a573 1
   for ( ; i < ctx->nr_vertex_samplers; i++) {
d600 108
d983 31
d1018 1
a1018 1
      util_copy_framebuffer_state(&ctx->fb, fb);
d1026 1
a1026 1
   util_copy_framebuffer_state(&ctx->fb_saved, &ctx->fb);
d1032 1
a1032 1
      util_copy_framebuffer_state(&ctx->fb, &ctx->fb_saved);
d1034 1
a1034 1
      util_unreference_framebuffer_state(&ctx->fb_saved);
a1073 10
enum pipe_error cso_set_sample_mask(struct cso_context *ctx,
                                    unsigned sample_mask)
{
   if (ctx->sample_mask != sample_mask) {
      ctx->sample_mask = sample_mask;
      ctx->pipe->set_sample_mask(ctx->pipe, sample_mask);
   }
   return PIPE_OK;
}

d1133 1
a1139 1
   dst->depth_clamp = src->depth_clamp;
a1149 3
   if (a->depth_clamp != b->depth_clamp) {
      return 1;
   }
a1181 182
}

enum pipe_error cso_set_vertex_elements(struct cso_context *ctx,
                                        unsigned count,
                                        const struct pipe_vertex_element *states)
{
   unsigned key_size, hash_key;
   struct cso_hash_iter iter;
   void *handle;
   struct cso_velems_state velems_state;

   /* need to include the count into the stored state data too.
      Otherwise first few count pipe_vertex_elements could be identical even if count
      is different, and there's no guarantee the hash would be different in that
      case neither */
   key_size = sizeof(struct pipe_vertex_element) * count + sizeof(unsigned);
   velems_state.count = count;
   memcpy(velems_state.velems, states, sizeof(struct pipe_vertex_element) * count);
   hash_key = cso_construct_key((void*)&velems_state, key_size);
   iter = cso_find_state_template(ctx->cache, hash_key, CSO_VELEMENTS, (void*)&velems_state, key_size);

   if (cso_hash_iter_is_null(iter)) {
      struct cso_velements *cso = MALLOC(sizeof(struct cso_velements));
      if (!cso)
         return PIPE_ERROR_OUT_OF_MEMORY;

      memcpy(&cso->state, &velems_state, key_size);
      cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, count, &cso->state.velems[0]);
      cso->delete_state = (cso_state_callback)ctx->pipe->delete_vertex_elements_state;
      cso->context = ctx->pipe;

      iter = cso_insert_state(ctx->cache, hash_key, CSO_VELEMENTS, cso);
      if (cso_hash_iter_is_null(iter)) {
         FREE(cso);
         return PIPE_ERROR_OUT_OF_MEMORY;
      }

      handle = cso->data;
   }
   else {
      handle = ((struct cso_velements *)cso_hash_iter_data(iter))->data;
   }

   if (ctx->velements != handle) {
      ctx->velements = handle;
      ctx->pipe->bind_vertex_elements_state(ctx->pipe, handle);
   }
   return PIPE_OK;
}

void cso_save_vertex_elements(struct cso_context *ctx)
{
   assert(!ctx->velements_saved);
   ctx->velements_saved = ctx->velements;
}

void cso_restore_vertex_elements(struct cso_context *ctx)
{
   if (ctx->velements != ctx->velements_saved) {
      ctx->velements = ctx->velements_saved;
      ctx->pipe->bind_vertex_elements_state(ctx->pipe, ctx->velements_saved);
   }
   ctx->velements_saved = NULL;
}

/* fragment sampler view state */

void
cso_set_fragment_sampler_views(struct cso_context *cso,
                               uint count,
                               struct pipe_sampler_view **views)
{
   uint i;

   for (i = 0; i < count; i++) {
      pipe_sampler_view_reference(&cso->fragment_sampler_views[i], views[i]);
   }
   for (; i < cso->nr_fragment_sampler_views; i++) {
      pipe_sampler_view_reference(&cso->fragment_sampler_views[i], NULL);
   }

   cso->pipe->set_fragment_sampler_views(cso->pipe,
                                         MAX2(count, cso->nr_fragment_sampler_views),
                                         cso->fragment_sampler_views);

   cso->nr_fragment_sampler_views = count;
}

void
cso_save_fragment_sampler_views(struct cso_context *cso)
{
   uint i;

   cso->nr_fragment_sampler_views_saved = cso->nr_fragment_sampler_views;

   for (i = 0; i < cso->nr_fragment_sampler_views; i++) {
      assert(!cso->fragment_sampler_views_saved[i]);

      pipe_sampler_view_reference(&cso->fragment_sampler_views_saved[i],
                                  cso->fragment_sampler_views[i]);
   }
}

void
cso_restore_fragment_sampler_views(struct cso_context *cso)
{
   uint i;

   for (i = 0; i < cso->nr_fragment_sampler_views_saved; i++) {
      pipe_sampler_view_reference(&cso->fragment_sampler_views[i], cso->fragment_sampler_views_saved[i]);
      pipe_sampler_view_reference(&cso->fragment_sampler_views_saved[i], NULL);
   }
   for (; i < cso->nr_fragment_sampler_views; i++) {
      pipe_sampler_view_reference(&cso->fragment_sampler_views[i], NULL);
   }

   cso->pipe->set_fragment_sampler_views(cso->pipe,
                                         MAX2(cso->nr_fragment_sampler_views, cso->nr_fragment_sampler_views_saved),
                                         cso->fragment_sampler_views);

   cso->nr_fragment_sampler_views = cso->nr_fragment_sampler_views_saved;
   cso->nr_fragment_sampler_views_saved = 0;
}


/* vertex sampler view state */

void
cso_set_vertex_sampler_views(struct cso_context *cso,
                             uint count,
                             struct pipe_sampler_view **views)
{
   uint i;

   for (i = 0; i < count; i++) {
      pipe_sampler_view_reference(&cso->vertex_sampler_views[i], views[i]);
   }
   for (; i < cso->nr_vertex_sampler_views; i++) {
      pipe_sampler_view_reference(&cso->vertex_sampler_views[i], NULL);
   }

   cso->pipe->set_vertex_sampler_views(cso->pipe,
                                       MAX2(count, cso->nr_vertex_sampler_views),
                                       cso->vertex_sampler_views);

   cso->nr_vertex_sampler_views = count;
}

void
cso_save_vertex_sampler_views(struct cso_context *cso)
{
   uint i;

   cso->nr_vertex_sampler_views_saved = cso->nr_vertex_sampler_views;

   for (i = 0; i < cso->nr_vertex_sampler_views; i++) {
      assert(!cso->vertex_sampler_views_saved[i]);

      pipe_sampler_view_reference(&cso->vertex_sampler_views_saved[i],
                                  cso->vertex_sampler_views[i]);
   }
}

void
cso_restore_vertex_sampler_views(struct cso_context *cso)
{
   uint i;

   for (i = 0; i < cso->nr_vertex_sampler_views_saved; i++) {
      pipe_sampler_view_reference(&cso->vertex_sampler_views[i], cso->vertex_sampler_views_saved[i]);
      pipe_sampler_view_reference(&cso->vertex_sampler_views_saved[i], NULL);
   }
   for (; i < cso->nr_vertex_sampler_views; i++) {
      pipe_sampler_view_reference(&cso->vertex_sampler_views[i], NULL);
   }

   cso->pipe->set_vertex_sampler_views(cso->pipe,
                                       MAX2(cso->nr_vertex_sampler_views, cso->nr_vertex_sampler_views_saved),
                                       cso->vertex_sampler_views);

   cso->nr_vertex_sampler_views = cso->nr_vertex_sampler_views_saved;
   cso->nr_vertex_sampler_views_saved = 0;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d30 1
a30 1
  *
a38 1
#include "util/u_draw.h"
a42 1
#include "util/u_vbuf.h"
d50 3
a53 6
/**
 * Info related to samplers and sampler views.
 * We have one of these for fragment samplers and another for vertex samplers.
 */
struct sampler_info
{
d57 3
d65 4
a69 10
   unsigned nr_samplers_saved;

   struct pipe_sampler_view *views[PIPE_MAX_SAMPLERS];
   unsigned nr_views;

   struct pipe_sampler_view *views_saved[PIPE_MAX_SAMPLERS];
   unsigned nr_views_saved;
};


d71 2
a72 7
struct cso_context {
   struct pipe_context *pipe;
   struct cso_cache *cache;
   struct u_vbuf *vbuf;

   boolean has_geometry_shader;
   boolean has_streamout;
d74 2
a75 1
   struct sampler_info samplers[PIPE_SHADER_TYPES];
d77 2
a78 3
   struct pipe_vertex_buffer aux_vertex_buffer_current;
   struct pipe_vertex_buffer aux_vertex_buffer_saved;
   unsigned aux_vertex_buffer_index;
d80 2
a81 2
   struct pipe_constant_buffer aux_constbuf_current[PIPE_SHADER_TYPES];
   struct pipe_constant_buffer aux_constbuf_saved[PIPE_SHADER_TYPES];
d83 2
a84 5
   unsigned nr_so_targets;
   struct pipe_stream_output_target *so_targets[PIPE_MAX_SO_BUFFERS];

   unsigned nr_so_targets_saved;
   struct pipe_stream_output_target *so_targets_saved[PIPE_MAX_SO_BUFFERS];
d92 2
a93 3
   void *fragment_shader, *fragment_shader_saved;
   void *vertex_shader, *vertex_shader_saved;
   void *geometry_shader, *geometry_shader_saved;
a94 3
   struct pipe_query *render_condition, *render_condition_saved;
   uint render_condition_mode, render_condition_mode_saved;
   boolean render_condition_cond, render_condition_cond_saved;
d102 1
a102 1
   unsigned sample_mask, sample_mask_saved;
d122 1
a122 2
   struct cso_depth_stencil_alpha *cso =
      (struct cso_depth_stencil_alpha *)state;
d155 22
d198 1
d201 1
d204 1
d207 7
d216 1
d224 2
a225 3
static INLINE void
sanitize_hash(struct cso_hash *hash, enum cso_cache_type type,
              int max_size, void *user_data)
a247 20
static void cso_init_vbuf(struct cso_context *cso)
{
   struct u_vbuf_caps caps;

   u_vbuf_get_caps(cso->pipe->screen, &caps);

   /* Install u_vbuf if there is anything unsupported. */
   if (!caps.buffer_offset_unaligned ||
       !caps.buffer_stride_unaligned ||
       !caps.velem_src_offset_unaligned ||
       !caps.format_fixed32 ||
       !caps.format_float16 ||
       !caps.format_float64 ||
       !caps.format_norm32 ||
       !caps.format_scaled32 ||
       !caps.user_vertex_buffers) {
      cso->vbuf = u_vbuf_create(cso->pipe, &caps,
                                cso->aux_vertex_buffer_index);
   }
}
a262 5
   ctx->sample_mask_saved = ~0;

   ctx->aux_vertex_buffer_index = 0; /* 0 for now */

   cso_init_vbuf(ctx);
a266 9
   if (pipe->screen->get_shader_param(pipe->screen, PIPE_SHADER_GEOMETRY,
                                PIPE_SHADER_CAP_MAX_INSTRUCTIONS) > 0) {
      ctx->has_geometry_shader = TRUE;
   }
   if (pipe->screen->get_param(pipe->screen,
                               PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS) != 0) {
      ctx->has_streamout = TRUE;
   }

d270 1
a270 1
   cso_destroy_context( ctx );
d274 1
d280 2
a281 2
   unsigned i, shader;

a294 2
      if (ctx->pipe->set_stream_output_targets)
         ctx->pipe->set_stream_output_targets(ctx->pipe, 0, NULL, 0);
d297 8
a304 7
   /* free fragment samplers, views */
   for (shader = 0; shader < Elements(ctx->samplers); shader++) {
      struct sampler_info *info = &ctx->samplers[shader];
      for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
         pipe_sampler_view_reference(&info->views[i], NULL);
         pipe_sampler_view_reference(&info->views_saved[i], NULL);
      }
a309 13
   pipe_resource_reference(&ctx->aux_vertex_buffer_current.buffer, NULL);
   pipe_resource_reference(&ctx->aux_vertex_buffer_saved.buffer, NULL);

   for (i = 0; i < PIPE_SHADER_TYPES; i++) {
      pipe_resource_reference(&ctx->aux_constbuf_current[i].buffer, NULL);
      pipe_resource_reference(&ctx->aux_constbuf_saved[i].buffer, NULL);
   }

   for (i = 0; i < PIPE_MAX_SO_BUFFERS; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], NULL);
      pipe_so_target_reference(&ctx->so_targets_saved[i], NULL);
   }

a323 2
      if (ctx->vbuf)
         u_vbuf_destroy(ctx->vbuf);
d346 2
a347 3
   key_size = templ->independent_blend_enable ?
      sizeof(struct pipe_blend_state) :
      (char *)&(templ->rt[1]) - (char *)templ;
d349 1
a349 2
   iter = cso_find_state_template(ctx->cache, hash_key, CSO_BLEND,
                                  (void*)templ, key_size);
d398 40
d439 188
a626 2
cso_set_depth_stencil_alpha(struct cso_context *ctx,
                            const struct pipe_depth_stencil_alpha_state *templ)
d631 1
a631 1
                                                       hash_key,
d637 1
a637 2
      struct cso_depth_stencil_alpha *cso =
         MALLOC(sizeof(struct cso_depth_stencil_alpha));
d642 2
a643 4
      cso->data = ctx->pipe->create_depth_stencil_alpha_state(ctx->pipe,
                                                              &cso->state);
      cso->delete_state =
         (cso_state_callback)ctx->pipe->delete_depth_stencil_alpha_state;
d646 1
a646 2
      iter = cso_insert_state(ctx->cache, hash_key,
                              CSO_DEPTH_STENCIL_ALPHA, cso);
d655 1
a655 2
      handle = ((struct cso_depth_stencil_alpha *)
                cso_hash_iter_data(iter))->data;
d675 1
a675 2
      ctx->pipe->bind_depth_stencil_alpha_state(ctx->pipe,
                                                ctx->depth_stencil_saved);
d688 1
a688 2
                                                       hash_key,
                                                       CSO_RASTERIZER,
d699 1
a699 2
      cso->delete_state =
         (cso_state_callback)ctx->pipe->delete_rasterizer_state;
d737 3
a739 1
void cso_set_fragment_shader_handle(struct cso_context *ctx, void *handle )
d745 1
d758 46
d820 2
a821 1
void cso_set_vertex_shader_handle(struct cso_context *ctx, void *handle)
d827 1
d840 44
d900 2
a901 2
void cso_set_framebuffer(struct cso_context *ctx,
                         const struct pipe_framebuffer_state *fb)
d907 1
d925 2
a926 2
void cso_set_viewport(struct cso_context *ctx,
                      const struct pipe_viewport_state *vp)
d930 1
a930 1
      ctx->pipe->set_viewport_states(ctx->pipe, 0, 1, vp);
d932 1
d945 1
a945 1
      ctx->pipe->set_viewport_states(ctx->pipe, 0, 1, &ctx->vp);
d950 2
a951 2
void cso_set_blend_color(struct cso_context *ctx,
                         const struct pipe_blend_color *bc)
d957 1
d960 2
a961 1
void cso_set_sample_mask(struct cso_context *ctx, unsigned sample_mask)
d967 1
d970 2
a971 12
void cso_save_sample_mask(struct cso_context *ctx)
{
   ctx->sample_mask_saved = ctx->sample_mask;
}

void cso_restore_sample_mask(struct cso_context *ctx)
{
   cso_set_sample_mask(ctx, ctx->sample_mask_saved);
}

void cso_set_stencil_ref(struct cso_context *ctx,
                         const struct pipe_stencil_ref *sr)
d977 1
d988 1
a988 2
   if (memcmp(&ctx->stencil_ref, &ctx->stencil_ref_saved,
              sizeof(ctx->stencil_ref))) {
d994 2
a995 31
void cso_set_render_condition(struct cso_context *ctx,
                              struct pipe_query *query,
                              boolean condition, uint mode)
{
   struct pipe_context *pipe = ctx->pipe;

   if (ctx->render_condition != query ||
       ctx->render_condition_mode != mode ||
       ctx->render_condition_cond != condition) {
      pipe->render_condition(pipe, query, condition, mode);
      ctx->render_condition = query;
      ctx->render_condition_cond = condition;
      ctx->render_condition_mode = mode;
   }
}

void cso_save_render_condition(struct cso_context *ctx)
{
   ctx->render_condition_saved = ctx->render_condition;
   ctx->render_condition_cond_saved = ctx->render_condition_cond;
   ctx->render_condition_mode_saved = ctx->render_condition_mode;
}

void cso_restore_render_condition(struct cso_context *ctx)
{
   cso_set_render_condition(ctx, ctx->render_condition_saved,
                            ctx->render_condition_cond_saved,
                            ctx->render_condition_mode_saved);
}

void cso_set_geometry_shader_handle(struct cso_context *ctx, void *handle)
d997 1
a997 3
   assert(ctx->has_geometry_shader || !handle);

   if (ctx->has_geometry_shader && ctx->geometry_shader != handle) {
d1001 1
a1015 4
   if (!ctx->has_geometry_shader) {
      return;
   }

a1021 4
   if (!ctx->has_geometry_shader) {
      return;
   }

d1035 5
a1039 1
   memcpy(dst->ucp, src->ucp, sizeof(dst->ucp));
d1046 10
a1055 1
   return memcmp(a->ucp, b->ucp, sizeof(a->ucp));
d1083 3
a1085 4
enum pipe_error
cso_set_vertex_elements(struct cso_context *ctx,
                        unsigned count,
                        const struct pipe_vertex_element *states)
a1086 1
   struct u_vbuf *vbuf = ctx->vbuf;
d1092 4
a1095 10
   if (vbuf) {
      u_vbuf_set_vertex_elements(vbuf, count, states);
      return PIPE_OK;
   }

   /* Need to include the count into the stored state data too.
    * Otherwise first few count pipe_vertex_elements could be identical
    * even if count is different, and there's no guarantee the hash would
    * be different in that case neither.
    */
d1098 1
a1098 2
   memcpy(velems_state.velems, states,
          sizeof(struct pipe_vertex_element) * count);
d1100 1
a1100 2
   iter = cso_find_state_template(ctx->cache, hash_key, CSO_VELEMENTS,
                                  (void*)&velems_state, key_size);
d1108 2
a1109 4
      cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, count,
                                                      &cso->state.velems[0]);
      cso->delete_state =
         (cso_state_callback) ctx->pipe->delete_vertex_elements_state;
a1132 7
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_save_vertex_elements(vbuf);
      return;
   }

a1138 7
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_restore_vertex_elements(vbuf);
      return;
   }

d1146 1
a1146 174
/* vertex buffers */

void cso_set_vertex_buffers(struct cso_context *ctx,
                            unsigned start_slot, unsigned count,
                            const struct pipe_vertex_buffer *buffers)
{
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_set_vertex_buffers(vbuf, start_slot, count, buffers);
      return;
   }

   /* Save what's in the auxiliary slot, so that we can save and restore it
    * for meta ops. */
   if (start_slot <= ctx->aux_vertex_buffer_index &&
       start_slot+count > ctx->aux_vertex_buffer_index) {
      if (buffers) {
         const struct pipe_vertex_buffer *vb =
               buffers + (ctx->aux_vertex_buffer_index - start_slot);

         pipe_resource_reference(&ctx->aux_vertex_buffer_current.buffer,
                                 vb->buffer);
         memcpy(&ctx->aux_vertex_buffer_current, vb,
                sizeof(struct pipe_vertex_buffer));
      }
      else {
         pipe_resource_reference(&ctx->aux_vertex_buffer_current.buffer,
                                 NULL);
         ctx->aux_vertex_buffer_current.user_buffer = NULL;
      }
   }

   ctx->pipe->set_vertex_buffers(ctx->pipe, start_slot, count, buffers);
}

void cso_save_aux_vertex_buffer_slot(struct cso_context *ctx)
{
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_save_aux_vertex_buffer_slot(vbuf);
      return;
   }

   pipe_resource_reference(&ctx->aux_vertex_buffer_saved.buffer,
                           ctx->aux_vertex_buffer_current.buffer);
   memcpy(&ctx->aux_vertex_buffer_saved, &ctx->aux_vertex_buffer_current,
          sizeof(struct pipe_vertex_buffer));
}

void cso_restore_aux_vertex_buffer_slot(struct cso_context *ctx)
{
   struct u_vbuf *vbuf = ctx->vbuf;

   if (vbuf) {
      u_vbuf_restore_aux_vertex_buffer_slot(vbuf);
      return;
   }

   cso_set_vertex_buffers(ctx, ctx->aux_vertex_buffer_index, 1,
                          &ctx->aux_vertex_buffer_saved);
   pipe_resource_reference(&ctx->aux_vertex_buffer_saved.buffer, NULL);
}

unsigned cso_get_aux_vertex_buffer_slot(struct cso_context *ctx)
{
   return ctx->aux_vertex_buffer_index;
}


/**************** fragment/vertex sampler view state *************************/

static enum pipe_error
single_sampler(struct cso_context *ctx,
               struct sampler_info *info,
               unsigned idx,
               const struct pipe_sampler_state *templ)
{
   void *handle = NULL;

   if (templ != NULL) {
      unsigned key_size = sizeof(struct pipe_sampler_state);
      unsigned hash_key = cso_construct_key((void*)templ, key_size);
      struct cso_hash_iter iter =
         cso_find_state_template(ctx->cache,
                                 hash_key, CSO_SAMPLER,
                                 (void *) templ, key_size);

      if (cso_hash_iter_is_null(iter)) {
         struct cso_sampler *cso = MALLOC(sizeof(struct cso_sampler));
         if (!cso)
            return PIPE_ERROR_OUT_OF_MEMORY;

         memcpy(&cso->state, templ, sizeof(*templ));
         cso->data = ctx->pipe->create_sampler_state(ctx->pipe, &cso->state);
         cso->delete_state =
            (cso_state_callback) ctx->pipe->delete_sampler_state;
         cso->context = ctx->pipe;

         iter = cso_insert_state(ctx->cache, hash_key, CSO_SAMPLER, cso);
         if (cso_hash_iter_is_null(iter)) {
            FREE(cso);
            return PIPE_ERROR_OUT_OF_MEMORY;
         }

         handle = cso->data;
      }
      else {
         handle = ((struct cso_sampler *)cso_hash_iter_data(iter))->data;
      }
   }

   info->samplers[idx] = handle;

   return PIPE_OK;
}

enum pipe_error
cso_single_sampler(struct cso_context *ctx,
                   unsigned shader_stage,
                   unsigned idx,
                   const struct pipe_sampler_state *templ)
{
   return single_sampler(ctx, &ctx->samplers[shader_stage], idx, templ);
}



static void
single_sampler_done(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i;

   /* find highest non-null sampler */
   for (i = PIPE_MAX_SAMPLERS; i > 0; i--) {
      if (info->samplers[i - 1] != NULL)
         break;
   }

   info->nr_samplers = i;

   if (info->hw.nr_samplers != info->nr_samplers ||
       memcmp(info->hw.samplers,
              info->samplers,
              info->nr_samplers * sizeof(void *)) != 0)
   {
      memcpy(info->hw.samplers,
             info->samplers,
             info->nr_samplers * sizeof(void *));
      info->hw.nr_samplers = info->nr_samplers;

      switch (shader_stage) {
      case PIPE_SHADER_FRAGMENT:
         ctx->pipe->bind_fragment_sampler_states(ctx->pipe,
                                                 info->nr_samplers,
                                                 info->samplers);
         break;
      case PIPE_SHADER_VERTEX:
         ctx->pipe->bind_vertex_sampler_states(ctx->pipe,
                                               info->nr_samplers,
                                               info->samplers);
         break;
      case PIPE_SHADER_GEOMETRY:
         ctx->pipe->bind_geometry_sampler_states(ctx->pipe,
                                               info->nr_samplers,
                                               info->samplers);
         break;
      default:
         assert(!"bad shader type in single_sampler_done()");
      }
   }
}
d1149 3
a1151 1
cso_single_sampler_done(struct cso_context *ctx, unsigned shader_stage)
d1153 1
a1153 18
   single_sampler_done(ctx, shader_stage);
}


/*
 * If the function encouters any errors it will return the
 * last one. Done to always try to set as many samplers
 * as possible.
 */
enum pipe_error
cso_set_samplers(struct cso_context *ctx,
                 unsigned shader_stage,
                 unsigned nr,
                 const struct pipe_sampler_state **templates)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i;
   enum pipe_error temp, error = PIPE_OK;
a1154 49
   /* TODO: fastpath
    */

   for (i = 0; i < nr; i++) {
      temp = single_sampler(ctx, info, i, templates[i]);
      if (temp != PIPE_OK)
         error = temp;
   }

   for ( ; i < info->nr_samplers; i++) {
      temp = single_sampler(ctx, info, i, NULL);
      if (temp != PIPE_OK)
         error = temp;
   }

   single_sampler_done(ctx, shader_stage);

   return error;
}

void
cso_save_samplers(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   info->nr_samplers_saved = info->nr_samplers;
   memcpy(info->samplers_saved, info->samplers, sizeof(info->samplers));
}


void
cso_restore_samplers(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   info->nr_samplers = info->nr_samplers_saved;
   memcpy(info->samplers, info->samplers_saved, sizeof(info->samplers));
   single_sampler_done(ctx, shader_stage);
}


void
cso_set_sampler_views(struct cso_context *ctx,
                      unsigned shader_stage,
                      unsigned count,
                      struct pipe_sampler_view **views)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i;

   /* reference new views */
d1156 1
a1156 1
      pipe_sampler_view_reference(&info->views[i], views[i]);
d1158 2
a1159 3
   /* unref extra old views, if any */
   for (; i < info->nr_views; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
d1162 3
a1164 1
   info->nr_views = count;
d1166 1
a1166 14
   /* bind the new sampler views */
   switch (shader_stage) {
   case PIPE_SHADER_FRAGMENT:
      ctx->pipe->set_fragment_sampler_views(ctx->pipe, count, info->views);
      break;
   case PIPE_SHADER_VERTEX:
      ctx->pipe->set_vertex_sampler_views(ctx->pipe, count, info->views);
      break;
   case PIPE_SHADER_GEOMETRY:
      ctx->pipe->set_geometry_sampler_views(ctx->pipe, count, info->views);
      break;
   default:
      assert(!"bad shader type in cso_set_sampler_views()");
   }
a1168 1

d1170 1
a1170 1
cso_save_sampler_views(struct cso_context *ctx, unsigned shader_stage)
d1172 1
a1172 10
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i;

   info->nr_views_saved = info->nr_views;

   for (i = 0; i < info->nr_views; i++) {
      assert(!info->views_saved[i]);
      pipe_sampler_view_reference(&info->views_saved[i], info->views[i]);
   }
}
d1174 1
d1176 2
a1177 5
void
cso_restore_sampler_views(struct cso_context *ctx, unsigned shader_stage)
{
   struct sampler_info *info = &ctx->samplers[shader_stage];
   unsigned i, nr_saved = info->nr_views_saved;
d1179 2
a1180 5
   for (i = 0; i < nr_saved; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
      /* move the reference from one pointer to another */
      info->views[i] = info->views_saved[i];
      info->views_saved[i] = NULL;
a1181 21
   for (; i < info->nr_views; i++) {
      pipe_sampler_view_reference(&info->views[i], NULL);
   }

   /* bind the old/saved sampler views */
   switch (shader_stage) {
   case PIPE_SHADER_FRAGMENT:
      ctx->pipe->set_fragment_sampler_views(ctx->pipe, nr_saved, info->views);
      break;
   case PIPE_SHADER_VERTEX:
      ctx->pipe->set_vertex_sampler_views(ctx->pipe, nr_saved, info->views);
      break;
   case PIPE_SHADER_GEOMETRY:
      ctx->pipe->set_geometry_sampler_views(ctx->pipe, nr_saved, info->views);
      break;
   default:
      assert(!"bad shader type in cso_restore_sampler_views()");
   }

   info->nr_views = nr_saved;
   info->nr_views_saved = 0;
a1183 1

d1185 1
a1185 4
cso_set_stream_outputs(struct cso_context *ctx,
                       unsigned num_targets,
                       struct pipe_stream_output_target **targets,
                       unsigned append_bitmask)
a1186 1
   struct pipe_context *pipe = ctx->pipe;
d1189 3
a1191 3
   if (!ctx->has_streamout) {
      assert(num_targets == 0);
      return;
d1193 2
a1194 4

   if (ctx->nr_so_targets == 0 && num_targets == 0) {
      /* Nothing to do. */
      return;
d1197 3
a1199 8
   /* reference new targets */
   for (i = 0; i < num_targets; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], targets[i]);
   }
   /* unref extra old targets, if any */
   for (; i < ctx->nr_so_targets; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], NULL);
   }
d1201 2
a1202 3
   pipe->set_stream_output_targets(pipe, num_targets, targets,
                                   append_bitmask);
   ctx->nr_so_targets = num_targets;
a1204 4
void
cso_save_stream_outputs(struct cso_context *ctx)
{
   uint i;
d1206 1
a1206 11
   if (!ctx->has_streamout) {
      return;
   }

   ctx->nr_so_targets_saved = ctx->nr_so_targets;

   for (i = 0; i < ctx->nr_so_targets; i++) {
      assert(!ctx->so_targets_saved[i]);
      pipe_so_target_reference(&ctx->so_targets_saved[i], ctx->so_targets[i]);
   }
}
d1209 3
a1211 1
cso_restore_stream_outputs(struct cso_context *ctx)
a1212 1
   struct pipe_context *pipe = ctx->pipe;
d1215 2
a1216 7
   if (!ctx->has_streamout) {
      return;
   }

   if (ctx->nr_so_targets == 0 && ctx->nr_so_targets_saved == 0) {
      /* Nothing to do. */
      return;
d1218 2
a1219 9

   for (i = 0; i < ctx->nr_so_targets_saved; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], NULL);
      /* move the reference from one pointer to another */
      ctx->so_targets[i] = ctx->so_targets_saved[i];
      ctx->so_targets_saved[i] = NULL;
   }
   for (; i < ctx->nr_so_targets; i++) {
      pipe_so_target_reference(&ctx->so_targets[i], NULL);
d1222 3
a1224 3
   /* ~0 means append */
   pipe->set_stream_output_targets(pipe, ctx->nr_so_targets_saved,
                                   ctx->so_targets, ~0);
d1226 1
a1226 2
   ctx->nr_so_targets = ctx->nr_so_targets_saved;
   ctx->nr_so_targets_saved = 0;
a1228 2
/* constant buffers */

d1230 1
a1230 2
cso_set_constant_buffer(struct cso_context *cso, unsigned shader_stage,
                        unsigned index, struct pipe_constant_buffer *cb)
d1232 1
a1232 1
   struct pipe_context *pipe = cso->pipe;
d1234 1
a1234 1
   pipe->set_constant_buffer(pipe, shader_stage, index, cb);
d1236 2
a1237 4
   if (index == 0) {
      util_copy_constant_buffer(&cso->aux_constbuf_current[shader_stage], cb);
   }
}
d1239 2
a1240 15
void
cso_set_constant_buffer_resource(struct cso_context *cso,
                                 unsigned shader_stage,
                                 unsigned index,
                                 struct pipe_resource *buffer)
{
   if (buffer) {
      struct pipe_constant_buffer cb;
      cb.buffer = buffer;
      cb.buffer_offset = 0;
      cb.buffer_size = buffer->width0;
      cb.user_buffer = NULL;
      cso_set_constant_buffer(cso, shader_stage, index, &cb);
   } else {
      cso_set_constant_buffer(cso, shader_stage, index, NULL);
d1245 1
a1245 2
cso_save_constant_buffer_slot0(struct cso_context *cso,
                                  unsigned shader_stage)
d1247 1
a1247 3
   util_copy_constant_buffer(&cso->aux_constbuf_saved[shader_stage],
                             &cso->aux_constbuf_current[shader_stage]);
}
d1249 3
a1251 23
void
cso_restore_constant_buffer_slot0(struct cso_context *cso,
                                     unsigned shader_stage)
{
   cso_set_constant_buffer(cso, shader_stage, 0,
                           &cso->aux_constbuf_saved[shader_stage]);
   pipe_resource_reference(&cso->aux_constbuf_saved[shader_stage].buffer,
                           NULL);
}

/* drawing */

void
cso_set_index_buffer(struct cso_context *cso,
                     const struct pipe_index_buffer *ib)
{
   struct u_vbuf *vbuf = cso->vbuf;

   if (vbuf) {
      u_vbuf_set_index_buffer(vbuf, ib);
   } else {
      struct pipe_context *pipe = cso->pipe;
      pipe->set_index_buffer(pipe, ib);
d1253 2
a1254 13
}

void
cso_draw_vbo(struct cso_context *cso,
             const struct pipe_draw_info *info)
{
   struct u_vbuf *vbuf = cso->vbuf;

   if (vbuf) {
      u_vbuf_draw_vbo(vbuf, info);
   } else {
      struct pipe_context *pipe = cso->pipe;
      pipe->draw_vbo(pipe, info);
a1255 8
}

void
cso_draw_arrays(struct cso_context *cso, uint mode, uint start, uint count)
{
   struct pipe_draw_info info;

   util_draw_init_info(&info);
d1257 3
a1259 5
   info.mode = mode;
   info.start = start;
   info.count = count;
   info.min_index = start;
   info.max_index = start + count - 1;
d1261 2
a1262 1
   cso_draw_vbo(cso, &info);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d34 2
a35 2
  * @@author Zack Rusin <zackr@@vmware.com>
  * @@author Keith Whitwell <keithw@@vmware.com>
d70 1
a70 1
   struct pipe_sampler_view *views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
d73 1
a73 1
   struct pipe_sampler_view *views_saved[PIPE_MAX_SHADER_SAMPLER_VIEWS];
a122 1
   unsigned min_samples, min_samples_saved;
d272 1
a272 1
   ctx->sample_mask = ~0;
d307 3
a309 22

      {
         static struct pipe_sampler_view *views[PIPE_MAX_SHADER_SAMPLER_VIEWS] = { NULL };
         static void *zeros[PIPE_MAX_SAMPLERS] = { NULL };
         struct pipe_screen *scr = ctx->pipe->screen;
         unsigned sh;
         for (sh = 0; sh < PIPE_SHADER_TYPES; sh++) {
            int maxsam = scr->get_shader_param(scr, sh,
                                               PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS);
            int maxview = scr->get_shader_param(scr, sh,
                                                PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS);
            assert(maxsam <= PIPE_MAX_SAMPLERS);
            assert(maxview <= PIPE_MAX_SHADER_SAMPLER_VIEWS);
            if (maxsam > 0) {
               ctx->pipe->bind_sampler_states(ctx->pipe, sh, 0, maxsam, zeros);
            }
            if (maxview > 0) {
               ctx->pipe->set_sampler_views(ctx->pipe, sh, 0, maxview, views);
            }
         }
      }

d314 3
a316 1

d318 1
a318 1
         ctx->pipe->set_stream_output_targets(ctx->pipe, 0, NULL, NULL);
d321 1
a321 1
   /* free fragment sampler views */
d324 1
a324 1
      for (i = 0; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; i++) {
a701 18
void cso_set_min_samples(struct cso_context *ctx, unsigned min_samples)
{
   if (ctx->min_samples != min_samples && ctx->pipe->set_min_samples) {
      ctx->min_samples = min_samples;
      ctx->pipe->set_min_samples(ctx->pipe, min_samples);
   }
}

void cso_save_min_samples(struct cso_context *ctx)
{
   ctx->min_samples_saved = ctx->min_samples;
}

void cso_restore_min_samples(struct cso_context *ctx)
{
   cso_set_min_samples(ctx, ctx->min_samples_saved);
}

d1080 1
d1082 19
a1100 10
      /* set remaining slots/pointers to null */
      for (i = info->nr_samplers; i < info->hw.nr_samplers; i++)
         info->samplers[i] = NULL;

      ctx->pipe->bind_sampler_states(ctx->pipe, shader_stage, 0,
                                     MAX2(info->nr_samplers,
                                          info->hw.nr_samplers),
                                     info->samplers);

      info->hw.nr_samplers = info->nr_samplers;
a1172 1
   boolean any_change = FALSE;
a1175 1
      any_change |= info->views[i] != views[i];
a1179 1
      any_change |= info->views[i] != NULL;
d1183 2
d1186 12
a1197 4
   if (any_change) {
      ctx->pipe->set_sampler_views(ctx->pipe, shader_stage, 0,
                                   MAX2(info->nr_views, count),
                                   info->views);
a1198 2

   info->nr_views = count;
a1221 1
   unsigned num;
a1232 2
   num = MAX2(info->nr_views, nr_saved);

d1234 13
a1246 1
   ctx->pipe->set_sampler_views(ctx->pipe, shader_stage, 0, num, info->views);
d1257 1
a1257 1
                       const unsigned *offsets)
d1282 1
a1282 1
                                   offsets);
a1307 1
   unsigned offset[PIPE_MAX_SO_BUFFERS];
a1317 1
   assert(ctx->nr_so_targets_saved <= PIPE_MAX_SO_BUFFERS);
a1322 2
      /* -1 means append */
      offset[i] = (unsigned)-1;
d1328 1
d1330 1
a1330 1
                                   ctx->so_targets, offset);
a1428 20

   cso_draw_vbo(cso, &info);
}

void
cso_draw_arrays_instanced(struct cso_context *cso, uint mode,
                          uint start, uint count,
                          uint start_instance, uint instance_count)
{
   struct pipe_draw_info info;

   util_draw_init_info(&info);

   info.mode = mode;
   info.start = start;
   info.count = count;
   info.min_index = start;
   info.max_index = start + count - 1;
   info.start_instance = start_instance;
   info.instance_count = instance_count;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d242 2
d245 9
a253 1
   if (u_vbuf_get_caps(cso->pipe->screen, &caps)) {
d335 1
a335 1
      if (ctx->has_streamout)
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a241 2
   u_vbuf_get_caps(cso->pipe->screen, &caps);

d243 1
a243 9
   if (!caps.buffer_offset_unaligned ||
       !caps.buffer_stride_unaligned ||
       !caps.velem_src_offset_unaligned ||
       !caps.format_fixed32 ||
       !caps.format_float16 ||
       !caps.format_float64 ||
       !caps.format_norm32 ||
       !caps.format_scaled32 ||
       !caps.user_vertex_buffers) {
d325 1
a325 1
      if (ctx->pipe->set_stream_output_targets)
@


