head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.34;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.50;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.42;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.13;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.20;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009-2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * @@file
 * Helper
 *
 * LLVM IR doesn't support all basic arithmetic operations we care about (most
 * notably min/max and saturated operations), and it is often necessary to
 * resort machine-specific intrinsics directly. The functions here hide all
 * these implementation details from the other modules.
 *
 * We also do simple expressions simplification here. Reasons are:
 * - it is very easy given we have all necessary information readily available
 * - LLVM optimization passes fail to simplify several vector expressions
 * - We often know value constraints which the optimization passes have no way
 *   of knowing, such as when source arguments are known to be in [0, 1] range.
 *
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 */


#include <float.h>

#include "util/u_memory.h"
#include "util/u_debug.h"
#include "util/u_math.h"
#include "util/u_string.h"
#include "util/u_cpu_detect.h"

#include "lp_bld_type.h"
#include "lp_bld_const.h"
#include "lp_bld_init.h"
#include "lp_bld_intr.h"
#include "lp_bld_logic.h"
#include "lp_bld_pack.h"
#include "lp_bld_debug.h"
#include "lp_bld_bitarit.h"
#include "lp_bld_arit.h"
#include "lp_bld_flow.h"

#if defined(PIPE_ARCH_SSE)
#include <xmmintrin.h>
#endif

#ifndef _MM_DENORMALS_ZERO_MASK
#define _MM_DENORMALS_ZERO_MASK 0x0040
#endif

#ifndef _MM_FLUSH_ZERO_MASK
#define _MM_FLUSH_ZERO_MASK 0x8000
#endif

#define EXP_POLY_DEGREE 5

#define LOG_POLY_DEGREE 4


/**
 * Generate min(a, b)
 * No checks for special case values of a or b = 1 or 0 are done.
 * NaN's are handled according to the behavior specified by the
 * nan_behavior argument.
 */
static LLVMValueRef
lp_build_min_simple(struct lp_build_context *bld,
                    LLVMValueRef a,
                    LLVMValueRef b,
                    enum gallivm_nan_behavior nan_behavior)
{
   const struct lp_type type = bld->type;
   const char *intrinsic = NULL;
   unsigned intr_size = 0;
   LLVMValueRef cond;

   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

   /* TODO: optimize the constant case */

   if (type.floating && util_cpu_caps.has_sse) {
      if (type.width == 32) {
         if (type.length == 1) {
            intrinsic = "llvm.x86.sse.min.ss";
            intr_size = 128;
         }
         else if (type.length <= 4 || !util_cpu_caps.has_avx) {
            intrinsic = "llvm.x86.sse.min.ps";
            intr_size = 128;
         }
         else {
            intrinsic = "llvm.x86.avx.min.ps.256";
            intr_size = 256;
         }
      }
      if (type.width == 64 && util_cpu_caps.has_sse2) {
         if (type.length == 1) {
            intrinsic = "llvm.x86.sse2.min.sd";
            intr_size = 128;
         }
         else if (type.length == 2 || !util_cpu_caps.has_avx) {
            intrinsic = "llvm.x86.sse2.min.pd";
            intr_size = 128;
         }
         else {
            intrinsic = "llvm.x86.avx.min.pd.256";
            intr_size = 256;
         }
      }
   }
   else if (type.floating && util_cpu_caps.has_altivec) {
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
         debug_printf("%s: altivec doesn't support nan return nan behavior\n",
                      __FUNCTION__);
      }
      if (type.width == 32 && type.length == 4) {
         intrinsic = "llvm.ppc.altivec.vminfp";
         intr_size = 128;
      }
   } else if (util_cpu_caps.has_sse2 && type.length >= 2) {
      intr_size = 128;
      if ((type.width == 8 || type.width == 16) &&
          (type.width * type.length <= 64) &&
          (gallivm_debug & GALLIVM_DEBUG_PERF)) {
         debug_printf("%s: inefficient code, bogus shuffle due to packing\n",
                      __FUNCTION__);
      }
      if (type.width == 8 && !type.sign) {
         intrinsic = "llvm.x86.sse2.pminu.b";
      }
      else if (type.width == 16 && type.sign) {
         intrinsic = "llvm.x86.sse2.pmins.w";
      }
      if (util_cpu_caps.has_sse4_1) {
         if (type.width == 8 && type.sign) {
            intrinsic = "llvm.x86.sse41.pminsb";
         }
         if (type.width == 16 && !type.sign) {
            intrinsic = "llvm.x86.sse41.pminuw";
         }
         if (type.width == 32 && !type.sign) {
            intrinsic = "llvm.x86.sse41.pminud";
         }
         if (type.width == 32 && type.sign) {
            intrinsic = "llvm.x86.sse41.pminsd";
         }
      }
   } else if (util_cpu_caps.has_altivec) {
      intr_size = 128;
      if (type.width == 8) {
         if (!type.sign) {
            intrinsic = "llvm.ppc.altivec.vminub";
         } else {
            intrinsic = "llvm.ppc.altivec.vminsb";
         }
      } else if (type.width == 16) {
         if (!type.sign) {
            intrinsic = "llvm.ppc.altivec.vminuh";
         } else {
            intrinsic = "llvm.ppc.altivec.vminsh";
         }
      } else if (type.width == 32) {
         if (!type.sign) {
            intrinsic = "llvm.ppc.altivec.vminuw";
         } else {
            intrinsic = "llvm.ppc.altivec.vminsw";
         }
      }
   }

   if(intrinsic) {
      /* We need to handle nan's for floating point numbers. If one of the
       * inputs is nan the other should be returned (required by both D3D10+
       * and OpenCL).
       * The sse intrinsics return the second operator in case of nan by
       * default so we need to special code to handle those.
       */
      if (util_cpu_caps.has_sse && type.floating &&
          nan_behavior != GALLIVM_NAN_BEHAVIOR_UNDEFINED &&
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
         LLVMValueRef isnan, max;
         max = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                   type,
                                                   intr_size, a, b);
         if (nan_behavior == GALLIVM_NAN_RETURN_OTHER) {
            isnan = lp_build_isnan(bld, b);
            return lp_build_select(bld, isnan, a, max);
         } else {
            assert(nan_behavior == GALLIVM_NAN_RETURN_NAN);
            isnan = lp_build_isnan(bld, a);
            return lp_build_select(bld, isnan, a, max);
         }
      } else {
         return lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                    type,
                                                    intr_size, a, b);
      }
   }

   if (type.floating) {
      switch (nan_behavior) {
      case GALLIVM_NAN_RETURN_NAN: {
         LLVMValueRef isnan = lp_build_isnan(bld, b);
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
         cond = LLVMBuildXor(bld->gallivm->builder, cond, isnan, "");
         return lp_build_select(bld, cond, a, b);
      }
         break;
      case GALLIVM_NAN_RETURN_OTHER: {
         LLVMValueRef isnan = lp_build_isnan(bld, a);
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
         cond = LLVMBuildXor(bld->gallivm->builder, cond, isnan, "");
         return lp_build_select(bld, cond, a, b);
      }
         break;
      case GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN:
         cond = lp_build_cmp_ordered(bld, PIPE_FUNC_LESS, a, b);
         return lp_build_select(bld, cond, a, b);
      case GALLIVM_NAN_BEHAVIOR_UNDEFINED:
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
         return lp_build_select(bld, cond, a, b);
         break;
      default:
         assert(0);
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
         return lp_build_select(bld, cond, a, b);
      }
   } else {
      cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
      return lp_build_select(bld, cond, a, b);
   }
}


/**
 * Generate max(a, b)
 * No checks for special case values of a or b = 1 or 0 are done.
 * NaN's are handled according to the behavior specified by the
 * nan_behavior argument.
 */
static LLVMValueRef
lp_build_max_simple(struct lp_build_context *bld,
                    LLVMValueRef a,
                    LLVMValueRef b,
                    enum gallivm_nan_behavior nan_behavior)
{
   const struct lp_type type = bld->type;
   const char *intrinsic = NULL;
   unsigned intr_size = 0;
   LLVMValueRef cond;

   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

   /* TODO: optimize the constant case */

   if (type.floating && util_cpu_caps.has_sse) {
      if (type.width == 32) {
         if (type.length == 1) {
            intrinsic = "llvm.x86.sse.max.ss";
            intr_size = 128;
         }
         else if (type.length <= 4 || !util_cpu_caps.has_avx) {
            intrinsic = "llvm.x86.sse.max.ps";
            intr_size = 128;
         }
         else {
            intrinsic = "llvm.x86.avx.max.ps.256";
            intr_size = 256;
         }
      }
      if (type.width == 64 && util_cpu_caps.has_sse2) {
         if (type.length == 1) {
            intrinsic = "llvm.x86.sse2.max.sd";
            intr_size = 128;
         }
         else if (type.length == 2 || !util_cpu_caps.has_avx) {
            intrinsic = "llvm.x86.sse2.max.pd";
            intr_size = 128;
         }
         else {
            intrinsic = "llvm.x86.avx.max.pd.256";
            intr_size = 256;
         }
      }
   }
   else if (type.floating && util_cpu_caps.has_altivec) {
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
         debug_printf("%s: altivec doesn't support nan return nan behavior\n",
                      __FUNCTION__);
      }
      if (type.width == 32 || type.length == 4) {
         intrinsic = "llvm.ppc.altivec.vmaxfp";
         intr_size = 128;
      }
   } else if (util_cpu_caps.has_sse2 && type.length >= 2) {
      intr_size = 128;
      if ((type.width == 8 || type.width == 16) &&
          (type.width * type.length <= 64) &&
          (gallivm_debug & GALLIVM_DEBUG_PERF)) {
         debug_printf("%s: inefficient code, bogus shuffle due to packing\n",
                      __FUNCTION__);
         }
      if (type.width == 8 && !type.sign) {
         intrinsic = "llvm.x86.sse2.pmaxu.b";
         intr_size = 128;
      }
      else if (type.width == 16 && type.sign) {
         intrinsic = "llvm.x86.sse2.pmaxs.w";
      }
      if (util_cpu_caps.has_sse4_1) {
         if (type.width == 8 && type.sign) {
            intrinsic = "llvm.x86.sse41.pmaxsb";
         }
         if (type.width == 16 && !type.sign) {
            intrinsic = "llvm.x86.sse41.pmaxuw";
         }
         if (type.width == 32 && !type.sign) {
            intrinsic = "llvm.x86.sse41.pmaxud";
        }
         if (type.width == 32 && type.sign) {
            intrinsic = "llvm.x86.sse41.pmaxsd";
         }
      }
   } else if (util_cpu_caps.has_altivec) {
     intr_size = 128;
     if (type.width == 8) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vmaxub";
       } else {
         intrinsic = "llvm.ppc.altivec.vmaxsb";
       }
     } else if (type.width == 16) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vmaxuh";
       } else {
         intrinsic = "llvm.ppc.altivec.vmaxsh";
       }
     } else if (type.width == 32) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vmaxuw";
       } else {
         intrinsic = "llvm.ppc.altivec.vmaxsw";
       }
     }
   }

   if(intrinsic) {
      if (util_cpu_caps.has_sse && type.floating &&
          nan_behavior != GALLIVM_NAN_BEHAVIOR_UNDEFINED &&
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
         LLVMValueRef isnan, min;
         min = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                   type,
                                                   intr_size, a, b);
         if (nan_behavior == GALLIVM_NAN_RETURN_OTHER) {
            isnan = lp_build_isnan(bld, b);
            return lp_build_select(bld, isnan, a, min);
         } else {
            assert(nan_behavior == GALLIVM_NAN_RETURN_NAN);
            isnan = lp_build_isnan(bld, a);
            return lp_build_select(bld, isnan, a, min);
         }
      } else {
         return lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                    type,
                                                    intr_size, a, b);
      }
   }

   if (type.floating) {
      switch (nan_behavior) {
      case GALLIVM_NAN_RETURN_NAN: {
         LLVMValueRef isnan = lp_build_isnan(bld, b);
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
         cond = LLVMBuildXor(bld->gallivm->builder, cond, isnan, "");
         return lp_build_select(bld, cond, a, b);
      }
         break;
      case GALLIVM_NAN_RETURN_OTHER: {
         LLVMValueRef isnan = lp_build_isnan(bld, a);
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
         cond = LLVMBuildXor(bld->gallivm->builder, cond, isnan, "");
         return lp_build_select(bld, cond, a, b);
      }
         break;
      case GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN:
         cond = lp_build_cmp_ordered(bld, PIPE_FUNC_GREATER, a, b);
         return lp_build_select(bld, cond, a, b);
      case GALLIVM_NAN_BEHAVIOR_UNDEFINED:
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
         return lp_build_select(bld, cond, a, b);
         break;
      default:
         assert(0);
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
         return lp_build_select(bld, cond, a, b);
      }
   } else {
      cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
      return lp_build_select(bld, cond, a, b);
   }
}


/**
 * Generate 1 - a, or ~a depending on bld->type.
 */
LLVMValueRef
lp_build_comp(struct lp_build_context *bld,
              LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(lp_check_value(type, a));

   if(a == bld->one)
      return bld->zero;
   if(a == bld->zero)
      return bld->one;

   if(type.norm && !type.floating && !type.fixed && !type.sign) {
      if(LLVMIsConstant(a))
         return LLVMConstNot(a);
      else
         return LLVMBuildNot(builder, a, "");
   }

   if(LLVMIsConstant(a))
      if (type.floating)
          return LLVMConstFSub(bld->one, a);
      else
          return LLVMConstSub(bld->one, a);
   else
      if (type.floating)
         return LLVMBuildFSub(builder, bld->one, a, "");
      else
         return LLVMBuildSub(builder, bld->one, a, "");
}


/**
 * Generate a + b
 */
LLVMValueRef
lp_build_add(struct lp_build_context *bld,
             LLVMValueRef a,
             LLVMValueRef b)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef res;

   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

   if(a == bld->zero)
      return b;
   if(b == bld->zero)
      return a;
   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if(bld->type.norm) {
      const char *intrinsic = NULL;

      if(a == bld->one || b == bld->one)
        return bld->one;

      if (type.width * type.length == 128 &&
          !type.floating && !type.fixed) {
         if(util_cpu_caps.has_sse2) {
           if(type.width == 8)
             intrinsic = type.sign ? "llvm.x86.sse2.padds.b" : "llvm.x86.sse2.paddus.b";
           if(type.width == 16)
             intrinsic = type.sign ? "llvm.x86.sse2.padds.w" : "llvm.x86.sse2.paddus.w";
         } else if (util_cpu_caps.has_altivec) {
           if(type.width == 8)
              intrinsic = type.sign ? "llvm.ppc.altivec.vaddsbs" : "llvm.ppc.altivec.vaddubs";
           if(type.width == 16)
              intrinsic = type.sign ? "llvm.ppc.altivec.vaddshs" : "llvm.ppc.altivec.vadduhs";
         }
      }
   
      if(intrinsic)
         return lp_build_intrinsic_binary(builder, intrinsic, lp_build_vec_type(bld->gallivm, bld->type), a, b);
   }

   /* TODO: handle signed case */
   if(type.norm && !type.floating && !type.fixed && !type.sign)
      a = lp_build_min_simple(bld, a, lp_build_comp(bld, b), GALLIVM_NAN_BEHAVIOR_UNDEFINED);

   if(LLVMIsConstant(a) && LLVMIsConstant(b))
      if (type.floating)
         res = LLVMConstFAdd(a, b);
      else
         res = LLVMConstAdd(a, b);
   else
      if (type.floating)
         res = LLVMBuildFAdd(builder, a, b, "");
      else
         res = LLVMBuildAdd(builder, a, b, "");

   /* clamp to ceiling of 1.0 */
   if(bld->type.norm && (bld->type.floating || bld->type.fixed))
      res = lp_build_min_simple(bld, res, bld->one, GALLIVM_NAN_BEHAVIOR_UNDEFINED);

   /* XXX clamp to floor of -1 or 0??? */

   return res;
}


/** Return the scalar sum of the elements of a.
 * Should avoid this operation whenever possible.
 */
LLVMValueRef
lp_build_horizontal_add(struct lp_build_context *bld,
                        LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef index, res;
   unsigned i, length;
   LLVMValueRef shuffles1[LP_MAX_VECTOR_LENGTH / 2];
   LLVMValueRef shuffles2[LP_MAX_VECTOR_LENGTH / 2];
   LLVMValueRef vecres, elem2;

   assert(lp_check_value(type, a));

   if (type.length == 1) {
      return a;
   }

   assert(!bld->type.norm);

   /*
    * for byte vectors can do much better with psadbw.
    * Using repeated shuffle/adds here. Note with multiple vectors
    * this can be done more efficiently as outlined in the intel
    * optimization manual.
    * Note: could cause data rearrangement if used with smaller element
    * sizes.
    */

   vecres = a;
   length = type.length / 2;
   while (length > 1) {
      LLVMValueRef vec1, vec2;
      for (i = 0; i < length; i++) {
         shuffles1[i] = lp_build_const_int32(bld->gallivm, i);
         shuffles2[i] = lp_build_const_int32(bld->gallivm, i + length);
      }
      vec1 = LLVMBuildShuffleVector(builder, vecres, vecres,
                                    LLVMConstVector(shuffles1, length), "");
      vec2 = LLVMBuildShuffleVector(builder, vecres, vecres,
                                    LLVMConstVector(shuffles2, length), "");
      if (type.floating) {
         vecres = LLVMBuildFAdd(builder, vec1, vec2, "");
      }
      else {
         vecres = LLVMBuildAdd(builder, vec1, vec2, "");
      }
      length = length >> 1;
   }

   /* always have vector of size 2 here */
   assert(length == 1);

   index = lp_build_const_int32(bld->gallivm, 0);
   res = LLVMBuildExtractElement(builder, vecres, index, "");
   index = lp_build_const_int32(bld->gallivm, 1);
   elem2 = LLVMBuildExtractElement(builder, vecres, index, "");

   if (type.floating)
      res = LLVMBuildFAdd(builder, res, elem2, "");
    else
      res = LLVMBuildAdd(builder, res, elem2, "");

   return res;
}

/**
 * Return the horizontal sums of 4 float vectors as a float4 vector.
 * This uses the technique as outlined in Intel Optimization Manual.
 */
static LLVMValueRef
lp_build_horizontal_add4x4f(struct lp_build_context *bld,
                            LLVMValueRef src[4])
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef shuffles[4];
   LLVMValueRef tmp[4];
   LLVMValueRef sumtmp[2], shuftmp[2];

   /* lower half of regs */
   shuffles[0] = lp_build_const_int32(gallivm, 0);
   shuffles[1] = lp_build_const_int32(gallivm, 1);
   shuffles[2] = lp_build_const_int32(gallivm, 4);
   shuffles[3] = lp_build_const_int32(gallivm, 5);
   tmp[0] = LLVMBuildShuffleVector(builder, src[0], src[1],
                                   LLVMConstVector(shuffles, 4), "");
   tmp[2] = LLVMBuildShuffleVector(builder, src[2], src[3],
                                   LLVMConstVector(shuffles, 4), "");

   /* upper half of regs */
   shuffles[0] = lp_build_const_int32(gallivm, 2);
   shuffles[1] = lp_build_const_int32(gallivm, 3);
   shuffles[2] = lp_build_const_int32(gallivm, 6);
   shuffles[3] = lp_build_const_int32(gallivm, 7);
   tmp[1] = LLVMBuildShuffleVector(builder, src[0], src[1],
                                   LLVMConstVector(shuffles, 4), "");
   tmp[3] = LLVMBuildShuffleVector(builder, src[2], src[3],
                                   LLVMConstVector(shuffles, 4), "");

   sumtmp[0] = LLVMBuildFAdd(builder, tmp[0], tmp[1], "");
   sumtmp[1] = LLVMBuildFAdd(builder, tmp[2], tmp[3], "");

   shuffles[0] = lp_build_const_int32(gallivm, 0);
   shuffles[1] = lp_build_const_int32(gallivm, 2);
   shuffles[2] = lp_build_const_int32(gallivm, 4);
   shuffles[3] = lp_build_const_int32(gallivm, 6);
   shuftmp[0] = LLVMBuildShuffleVector(builder, sumtmp[0], sumtmp[1],
                                       LLVMConstVector(shuffles, 4), "");

   shuffles[0] = lp_build_const_int32(gallivm, 1);
   shuffles[1] = lp_build_const_int32(gallivm, 3);
   shuffles[2] = lp_build_const_int32(gallivm, 5);
   shuffles[3] = lp_build_const_int32(gallivm, 7);
   shuftmp[1] = LLVMBuildShuffleVector(builder, sumtmp[0], sumtmp[1],
                                       LLVMConstVector(shuffles, 4), "");

   return LLVMBuildFAdd(builder, shuftmp[0], shuftmp[1], "");
}


/*
 * partially horizontally add 2-4 float vectors with length nx4,
 * i.e. only four adjacent values in each vector will be added,
 * assuming values are really grouped in 4 which also determines
 * output order.
 *
 * Return a vector of the same length as the initial vectors,
 * with the excess elements (if any) being undefined.
 * The element order is independent of number of input vectors.
 * For 3 vectors x0x1x2x3x4x5x6x7, y0y1y2y3y4y5y6y7, z0z1z2z3z4z5z6z7
 * the output order thus will be
 * sumx0-x3,sumy0-y3,sumz0-z3,undef,sumx4-x7,sumy4-y7,sumz4z7,undef
 */
LLVMValueRef
lp_build_hadd_partial4(struct lp_build_context *bld,
                       LLVMValueRef vectors[],
                       unsigned num_vecs)
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef ret_vec;
   LLVMValueRef tmp[4];
   const char *intrinsic = NULL;

   assert(num_vecs >= 2 && num_vecs <= 4);
   assert(bld->type.floating);

   /* only use this with at least 2 vectors, as it is sort of expensive
    * (depending on cpu) and we always need two horizontal adds anyway,
    * so a shuffle/add approach might be better.
    */

   tmp[0] = vectors[0];
   tmp[1] = vectors[1];

   tmp[2] = num_vecs > 2 ? vectors[2] : vectors[0];
   tmp[3] = num_vecs > 3 ? vectors[3] : vectors[0];

   if (util_cpu_caps.has_sse3 && bld->type.width == 32 &&
       bld->type.length == 4) {
      intrinsic = "llvm.x86.sse3.hadd.ps";
   }
   else if (util_cpu_caps.has_avx && bld->type.width == 32 &&
            bld->type.length == 8) {
      intrinsic = "llvm.x86.avx.hadd.ps.256";
   }
   if (intrinsic) {
      tmp[0] = lp_build_intrinsic_binary(builder, intrinsic,
                                       lp_build_vec_type(gallivm, bld->type),
                                       tmp[0], tmp[1]);
      if (num_vecs > 2) {
         tmp[1] = lp_build_intrinsic_binary(builder, intrinsic,
                                          lp_build_vec_type(gallivm, bld->type),
                                          tmp[2], tmp[3]);
      }
      else {
         tmp[1] = tmp[0];
      }
      return lp_build_intrinsic_binary(builder, intrinsic,
                                       lp_build_vec_type(gallivm, bld->type),
                                       tmp[0], tmp[1]);
   }

   if (bld->type.length == 4) {
      ret_vec = lp_build_horizontal_add4x4f(bld, tmp);
   }
   else {
      LLVMValueRef partres[LP_MAX_VECTOR_LENGTH/4];
      unsigned j;
      unsigned num_iter = bld->type.length / 4;
      struct lp_type parttype = bld->type;
      parttype.length = 4;
      for (j = 0; j < num_iter; j++) {
         LLVMValueRef partsrc[4];
         unsigned i;
         for (i = 0; i < 4; i++) {
            partsrc[i] = lp_build_extract_range(gallivm, tmp[i], j*4, 4);
         }
         partres[j] = lp_build_horizontal_add4x4f(bld, partsrc);
      }
      ret_vec = lp_build_concat(gallivm, partres, parttype, num_iter);
   }
   return ret_vec;
}

/**
 * Generate a - b
 */
LLVMValueRef
lp_build_sub(struct lp_build_context *bld,
             LLVMValueRef a,
             LLVMValueRef b)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef res;

   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

   if(b == bld->zero)
      return a;
   if(a == bld->undef || b == bld->undef)
      return bld->undef;
   if(a == b)
      return bld->zero;

   if(bld->type.norm) {
      const char *intrinsic = NULL;

      if(b == bld->one)
        return bld->zero;

      if (type.width * type.length == 128 &&
          !type.floating && !type.fixed) {
         if (util_cpu_caps.has_sse2) {
           if(type.width == 8)
              intrinsic = type.sign ? "llvm.x86.sse2.psubs.b" : "llvm.x86.sse2.psubus.b";
           if(type.width == 16)
              intrinsic = type.sign ? "llvm.x86.sse2.psubs.w" : "llvm.x86.sse2.psubus.w";
         } else if (util_cpu_caps.has_altivec) {
           if(type.width == 8)
              intrinsic = type.sign ? "llvm.ppc.altivec.vsubsbs" : "llvm.ppc.altivec.vsububs";
           if(type.width == 16)
              intrinsic = type.sign ? "llvm.ppc.altivec.vsubshs" : "llvm.ppc.altivec.vsubuhs";
         }
      }
   
      if(intrinsic)
         return lp_build_intrinsic_binary(builder, intrinsic, lp_build_vec_type(bld->gallivm, bld->type), a, b);
   }

   /* TODO: handle signed case */
   if(type.norm && !type.floating && !type.fixed && !type.sign)
      a = lp_build_max_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);

   if(LLVMIsConstant(a) && LLVMIsConstant(b))
      if (type.floating)
         res = LLVMConstFSub(a, b);
      else
         res = LLVMConstSub(a, b);
   else
      if (type.floating)
         res = LLVMBuildFSub(builder, a, b, "");
      else
         res = LLVMBuildSub(builder, a, b, "");

   if(bld->type.norm && (bld->type.floating || bld->type.fixed))
      res = lp_build_max_simple(bld, res, bld->zero, GALLIVM_NAN_BEHAVIOR_UNDEFINED);

   return res;
}



/**
 * Normalized multiplication.
 *
 * There are several approaches for (using 8-bit normalized multiplication as
 * an example):
 *
 * - alpha plus one
 *
 *     makes the following approximation to the division (Sree)
 *    
 *       a*b/255 ~= (a*(b + 1)) >> 256
 *    
 *     which is the fastest method that satisfies the following OpenGL criteria of
 *    
 *       0*0 = 0 and 255*255 = 255
 *
 * - geometric series
 *
 *     takes the geometric series approximation to the division
 *
 *       t/255 = (t >> 8) + (t >> 16) + (t >> 24) ..
 *
 *     in this case just the first two terms to fit in 16bit arithmetic
 *
 *       t/255 ~= (t + (t >> 8)) >> 8
 *
 *     note that just by itself it doesn't satisfies the OpenGL criteria, as
 *     255*255 = 254, so the special case b = 255 must be accounted or roundoff
 *     must be used.
 *
 * - geometric series plus rounding
 *
 *     when using a geometric series division instead of truncating the result
 *     use roundoff in the approximation (Jim Blinn)
 *
 *       t/255 ~= (t + (t >> 8) + 0x80) >> 8
 *
 *     achieving the exact results.
 *
 *
 *
 * @@sa Alvy Ray Smith, Image Compositing Fundamentals, Tech Memo 4, Aug 15, 1995, 
 *     ftp://ftp.alvyray.com/Acrobat/4_Comp.pdf
 * @@sa Michael Herf, The "double blend trick", May 2000, 
 *     http://www.stereopsis.com/doubleblend.html
 */
static LLVMValueRef
lp_build_mul_norm(struct gallivm_state *gallivm,
                  struct lp_type wide_type,
                  LLVMValueRef a, LLVMValueRef b)
{
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_build_context bld;
   unsigned n;
   LLVMValueRef half;
   LLVMValueRef ab;

   assert(!wide_type.floating);
   assert(lp_check_value(wide_type, a));
   assert(lp_check_value(wide_type, b));

   lp_build_context_init(&bld, gallivm, wide_type);

   n = wide_type.width / 2;
   if (wide_type.sign) {
      --n;
   }

   /*
    * TODO: for 16bits normalized SSE2 vectors we could consider using PMULHUW
    * http://ssp.impulsetrain.com/2011/07/03/multiplying-normalized-16-bit-numbers-with-sse2/
    */

   /*
    * a*b / (2**n - 1) ~= (a*b + (a*b >> n) + half) >> n
    */

   ab = LLVMBuildMul(builder, a, b, "");
   ab = LLVMBuildAdd(builder, ab, lp_build_shr_imm(&bld, ab, n), "");

   /*
    * half = sgn(ab) * 0.5 * (2 ** n) = sgn(ab) * (1 << (n - 1))
    */

   half = lp_build_const_int_vec(gallivm, wide_type, 1 << (n - 1));
   if (wide_type.sign) {
      LLVMValueRef minus_half = LLVMBuildNeg(builder, half, "");
      LLVMValueRef sign = lp_build_shr_imm(&bld, ab, wide_type.width - 1);
      half = lp_build_select(&bld, sign, minus_half, half);
   }
   ab = LLVMBuildAdd(builder, ab, half, "");

   /* Final division */
   ab = lp_build_shr_imm(&bld, ab, n);

   return ab;
}

/**
 * Generate a * b
 */
LLVMValueRef
lp_build_mul(struct lp_build_context *bld,
             LLVMValueRef a,
             LLVMValueRef b)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef shift;
   LLVMValueRef res;

   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

   if(a == bld->zero)
      return bld->zero;
   if(a == bld->one)
      return b;
   if(b == bld->zero)
      return bld->zero;
   if(b == bld->one)
      return a;
   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if (!type.floating && !type.fixed && type.norm) {
      struct lp_type wide_type = lp_wider_type(type);
      LLVMValueRef al, ah, bl, bh, abl, abh, ab;

      lp_build_unpack2(bld->gallivm, type, wide_type, a, &al, &ah);
      lp_build_unpack2(bld->gallivm, type, wide_type, b, &bl, &bh);

      /* PMULLW, PSRLW, PADDW */
      abl = lp_build_mul_norm(bld->gallivm, wide_type, al, bl);
      abh = lp_build_mul_norm(bld->gallivm, wide_type, ah, bh);

      ab = lp_build_pack2(bld->gallivm, wide_type, type, abl, abh);

      return ab;
   }

   if(type.fixed)
      shift = lp_build_const_int_vec(bld->gallivm, type, type.width/2);
   else
      shift = NULL;

   if(LLVMIsConstant(a) && LLVMIsConstant(b)) {
      if (type.floating)
         res = LLVMConstFMul(a, b);
      else
         res = LLVMConstMul(a, b);
      if(shift) {
         if(type.sign)
            res = LLVMConstAShr(res, shift);
         else
            res = LLVMConstLShr(res, shift);
      }
   }
   else {
      if (type.floating)
         res = LLVMBuildFMul(builder, a, b, "");
      else
         res = LLVMBuildMul(builder, a, b, "");
      if(shift) {
         if(type.sign)
            res = LLVMBuildAShr(builder, res, shift, "");
         else
            res = LLVMBuildLShr(builder, res, shift, "");
      }
   }

   return res;
}


/**
 * Small vector x scale multiplication optimization.
 */
LLVMValueRef
lp_build_mul_imm(struct lp_build_context *bld,
                 LLVMValueRef a,
                 int b)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef factor;

   assert(lp_check_value(bld->type, a));

   if(b == 0)
      return bld->zero;

   if(b == 1)
      return a;

   if(b == -1)
      return lp_build_negate(bld, a);

   if(b == 2 && bld->type.floating)
      return lp_build_add(bld, a, a);

   if(util_is_power_of_two(b)) {
      unsigned shift = ffs(b) - 1;

      if(bld->type.floating) {
#if 0
         /*
          * Power of two multiplication by directly manipulating the exponent.
          *
          * XXX: This might not be always faster, it will introduce a small error
          * for multiplication by zero, and it will produce wrong results
          * for Inf and NaN.
          */
         unsigned mantissa = lp_mantissa(bld->type);
         factor = lp_build_const_int_vec(bld->gallivm, bld->type, (unsigned long long)shift << mantissa);
         a = LLVMBuildBitCast(builder, a, lp_build_int_vec_type(bld->type), "");
         a = LLVMBuildAdd(builder, a, factor, "");
         a = LLVMBuildBitCast(builder, a, lp_build_vec_type(bld->gallivm, bld->type), "");
         return a;
#endif
      }
      else {
         factor = lp_build_const_vec(bld->gallivm, bld->type, shift);
         return LLVMBuildShl(builder, a, factor, "");
      }
   }

   factor = lp_build_const_vec(bld->gallivm, bld->type, (double)b);
   return lp_build_mul(bld, a, factor);
}


/**
 * Generate a / b
 */
LLVMValueRef
lp_build_div(struct lp_build_context *bld,
             LLVMValueRef a,
             LLVMValueRef b)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

   if(a == bld->zero)
      return bld->zero;
   if(a == bld->one)
      return lp_build_rcp(bld, b);
   if(b == bld->zero)
      return bld->undef;
   if(b == bld->one)
      return a;
   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if(LLVMIsConstant(a) && LLVMIsConstant(b)) {
      if (type.floating)
         return LLVMConstFDiv(a, b);
      else if (type.sign)
         return LLVMConstSDiv(a, b);
      else
         return LLVMConstUDiv(a, b);
   }

   if(((util_cpu_caps.has_sse && type.width == 32 && type.length == 4) ||
       (util_cpu_caps.has_avx && type.width == 32 && type.length == 8)) &&
      type.floating)
      return lp_build_mul(bld, a, lp_build_rcp(bld, b));

   if (type.floating)
      return LLVMBuildFDiv(builder, a, b, "");
   else if (type.sign)
      return LLVMBuildSDiv(builder, a, b, "");
   else
      return LLVMBuildUDiv(builder, a, b, "");
}


/**
 * Linear interpolation helper.
 *
 * @@param normalized whether we are interpolating normalized values,
 *        encoded in normalized integers, twice as wide.
 *
 * @@sa http://www.stereopsis.com/doubleblend.html
 */
static INLINE LLVMValueRef
lp_build_lerp_simple(struct lp_build_context *bld,
                     LLVMValueRef x,
                     LLVMValueRef v0,
                     LLVMValueRef v1,
                     unsigned flags)
{
   unsigned half_width = bld->type.width/2;
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef delta;
   LLVMValueRef res;

   assert(lp_check_value(bld->type, x));
   assert(lp_check_value(bld->type, v0));
   assert(lp_check_value(bld->type, v1));

   delta = lp_build_sub(bld, v1, v0);

   if (flags & LP_BLD_LERP_WIDE_NORMALIZED) {
      if (!bld->type.sign) {
         if (!(flags & LP_BLD_LERP_PRESCALED_WEIGHTS)) {
            /*
             * Scale x from [0, 2**n - 1] to [0, 2**n] by adding the
             * most-significant-bit to the lowest-significant-bit, so that
             * later we can just divide by 2**n instead of 2**n - 1.
             */

            x = lp_build_add(bld, x, lp_build_shr_imm(bld, x, half_width - 1));
         }

         /* (x * delta) >> n */
         res = lp_build_mul(bld, x, delta);
         res = lp_build_shr_imm(bld, res, half_width);
      } else {
         /*
          * The rescaling trick above doesn't work for signed numbers, so
          * use the 2**n - 1 divison approximation in lp_build_mul_norm
          * instead.
          */
         assert(!(flags & LP_BLD_LERP_PRESCALED_WEIGHTS));
         res = lp_build_mul_norm(bld->gallivm, bld->type, x, delta);
      }
   } else {
      assert(!(flags & LP_BLD_LERP_PRESCALED_WEIGHTS));
      res = lp_build_mul(bld, x, delta);
   }

   res = lp_build_add(bld, v0, res);

   if (((flags & LP_BLD_LERP_WIDE_NORMALIZED) && !bld->type.sign) ||
       bld->type.fixed) {
      /* We need to mask out the high order bits when lerping 8bit normalized colors stored on 16bits */
      /* XXX: This step is necessary for lerping 8bit colors stored on 16bits,
       * but it will be wrong for true fixed point use cases. Basically we need
       * a more powerful lp_type, capable of further distinguishing the values
       * interpretation from the value storage. */
      res = LLVMBuildAnd(builder, res, lp_build_const_int_vec(bld->gallivm, bld->type, (1 << half_width) - 1), "");
   }

   return res;
}


/**
 * Linear interpolation.
 */
LLVMValueRef
lp_build_lerp(struct lp_build_context *bld,
              LLVMValueRef x,
              LLVMValueRef v0,
              LLVMValueRef v1,
              unsigned flags)
{
   const struct lp_type type = bld->type;
   LLVMValueRef res;

   assert(lp_check_value(type, x));
   assert(lp_check_value(type, v0));
   assert(lp_check_value(type, v1));

   assert(!(flags & LP_BLD_LERP_WIDE_NORMALIZED));

   if (type.norm) {
      struct lp_type wide_type;
      struct lp_build_context wide_bld;
      LLVMValueRef xl, xh, v0l, v0h, v1l, v1h, resl, resh;

      assert(type.length >= 2);

      /*
       * Create a wider integer type, enough to hold the
       * intermediate result of the multiplication.
       */
      memset(&wide_type, 0, sizeof wide_type);
      wide_type.sign   = type.sign;
      wide_type.width  = type.width*2;
      wide_type.length = type.length/2;

      lp_build_context_init(&wide_bld, bld->gallivm, wide_type);

      lp_build_unpack2(bld->gallivm, type, wide_type, x,  &xl,  &xh);
      lp_build_unpack2(bld->gallivm, type, wide_type, v0, &v0l, &v0h);
      lp_build_unpack2(bld->gallivm, type, wide_type, v1, &v1l, &v1h);

      /*
       * Lerp both halves.
       */

      flags |= LP_BLD_LERP_WIDE_NORMALIZED;

      resl = lp_build_lerp_simple(&wide_bld, xl, v0l, v1l, flags);
      resh = lp_build_lerp_simple(&wide_bld, xh, v0h, v1h, flags);

      res = lp_build_pack2(bld->gallivm, wide_type, type, resl, resh);
   } else {
      res = lp_build_lerp_simple(bld, x, v0, v1, flags);
   }

   return res;
}


/**
 * Bilinear interpolation.
 *
 * Values indices are in v_{yx}.
 */
LLVMValueRef
lp_build_lerp_2d(struct lp_build_context *bld,
                 LLVMValueRef x,
                 LLVMValueRef y,
                 LLVMValueRef v00,
                 LLVMValueRef v01,
                 LLVMValueRef v10,
                 LLVMValueRef v11,
                 unsigned flags)
{
   LLVMValueRef v0 = lp_build_lerp(bld, x, v00, v01, flags);
   LLVMValueRef v1 = lp_build_lerp(bld, x, v10, v11, flags);
   return lp_build_lerp(bld, y, v0, v1, flags);
}


LLVMValueRef
lp_build_lerp_3d(struct lp_build_context *bld,
                 LLVMValueRef x,
                 LLVMValueRef y,
                 LLVMValueRef z,
                 LLVMValueRef v000,
                 LLVMValueRef v001,
                 LLVMValueRef v010,
                 LLVMValueRef v011,
                 LLVMValueRef v100,
                 LLVMValueRef v101,
                 LLVMValueRef v110,
                 LLVMValueRef v111,
                 unsigned flags)
{
   LLVMValueRef v0 = lp_build_lerp_2d(bld, x, y, v000, v001, v010, v011, flags);
   LLVMValueRef v1 = lp_build_lerp_2d(bld, x, y, v100, v101, v110, v111, flags);
   return lp_build_lerp(bld, z, v0, v1, flags);
}


/**
 * Generate min(a, b)
 * Do checks for special cases but not for nans.
 */
LLVMValueRef
lp_build_min(struct lp_build_context *bld,
             LLVMValueRef a,
             LLVMValueRef b)
{
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, b));

   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if(a == b)
      return a;

   if (bld->type.norm) {
      if (!bld->type.sign) {
         if (a == bld->zero || b == bld->zero) {
            return bld->zero;
         }
      }
      if(a == bld->one)
         return b;
      if(b == bld->one)
         return a;
   }

   return lp_build_min_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
}


/**
 * Generate min(a, b)
 * NaN's are handled according to the behavior specified by the
 * nan_behavior argument.
 */
LLVMValueRef
lp_build_min_ext(struct lp_build_context *bld,
                 LLVMValueRef a,
                 LLVMValueRef b,
                 enum gallivm_nan_behavior nan_behavior)
{
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, b));

   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if(a == b)
      return a;

   if (bld->type.norm) {
      if (!bld->type.sign) {
         if (a == bld->zero || b == bld->zero) {
            return bld->zero;
         }
      }
      if(a == bld->one)
         return b;
      if(b == bld->one)
         return a;
   }

   return lp_build_min_simple(bld, a, b, nan_behavior);
}

/**
 * Generate max(a, b)
 * Do checks for special cases, but NaN behavior is undefined.
 */
LLVMValueRef
lp_build_max(struct lp_build_context *bld,
             LLVMValueRef a,
             LLVMValueRef b)
{
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, b));

   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if(a == b)
      return a;

   if(bld->type.norm) {
      if(a == bld->one || b == bld->one)
         return bld->one;
      if (!bld->type.sign) {
         if (a == bld->zero) {
            return b;
         }
         if (b == bld->zero) {
            return a;
         }
      }
   }

   return lp_build_max_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
}


/**
 * Generate max(a, b)
 * Checks for special cases.
 * NaN's are handled according to the behavior specified by the
 * nan_behavior argument.
 */
LLVMValueRef
lp_build_max_ext(struct lp_build_context *bld,
                  LLVMValueRef a,
                  LLVMValueRef b,
                  enum gallivm_nan_behavior nan_behavior)
{
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, b));

   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if(a == b)
      return a;

   if(bld->type.norm) {
      if(a == bld->one || b == bld->one)
         return bld->one;
      if (!bld->type.sign) {
         if (a == bld->zero) {
            return b;
         }
         if (b == bld->zero) {
            return a;
         }
      }
   }

   return lp_build_max_simple(bld, a, b, nan_behavior);
}

/**
 * Generate clamp(a, min, max)
 * NaN behavior (for any of a, min, max) is undefined.
 * Do checks for special cases.
 */
LLVMValueRef
lp_build_clamp(struct lp_build_context *bld,
               LLVMValueRef a,
               LLVMValueRef min,
               LLVMValueRef max)
{
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, min));
   assert(lp_check_value(bld->type, max));

   a = lp_build_min(bld, a, max);
   a = lp_build_max(bld, a, min);
   return a;
}


/**
 * Generate clamp(a, 0, 1)
 * A NaN will get converted to zero.
 */
LLVMValueRef
lp_build_clamp_zero_one_nanzero(struct lp_build_context *bld,
                                LLVMValueRef a)
{
   a = lp_build_max_ext(bld, a, bld->zero, GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
   a = lp_build_min(bld, a, bld->one);
   return a;
}


/**
 * Generate abs(a)
 */
LLVMValueRef
lp_build_abs(struct lp_build_context *bld,
             LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);

   assert(lp_check_value(type, a));

   if(!type.sign)
      return a;

   if(type.floating) {
      /* Mask out the sign bit */
      LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
      unsigned long long absMask = ~(1ULL << (type.width - 1));
      LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type, ((unsigned long long) absMask));
      a = LLVMBuildBitCast(builder, a, int_vec_type, "");
      a = LLVMBuildAnd(builder, a, mask, "");
      a = LLVMBuildBitCast(builder, a, vec_type, "");
      return a;
   }

   if(type.width*type.length == 128 && util_cpu_caps.has_ssse3) {
      switch(type.width) {
      case 8:
         return lp_build_intrinsic_unary(builder, "llvm.x86.ssse3.pabs.b.128", vec_type, a);
      case 16:
         return lp_build_intrinsic_unary(builder, "llvm.x86.ssse3.pabs.w.128", vec_type, a);
      case 32:
         return lp_build_intrinsic_unary(builder, "llvm.x86.ssse3.pabs.d.128", vec_type, a);
      }
   }
   else if (type.width*type.length == 256 && util_cpu_caps.has_ssse3 &&
            (gallivm_debug & GALLIVM_DEBUG_PERF) &&
            (type.width == 8 || type.width == 16 || type.width == 32)) {
      debug_printf("%s: inefficient code, should split vectors manually\n",
                   __FUNCTION__);
   }

   return lp_build_max(bld, a, LLVMBuildNeg(builder, a, ""));
}


LLVMValueRef
lp_build_negate(struct lp_build_context *bld,
                LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;

   assert(lp_check_value(bld->type, a));

#if HAVE_LLVM >= 0x0207
   if (bld->type.floating)
      a = LLVMBuildFNeg(builder, a, "");
   else
#endif
      a = LLVMBuildNeg(builder, a, "");

   return a;
}


/** Return -1, 0 or +1 depending on the sign of a */
LLVMValueRef
lp_build_sgn(struct lp_build_context *bld,
             LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef cond;
   LLVMValueRef res;

   assert(lp_check_value(type, a));

   /* Handle non-zero case */
   if(!type.sign) {
      /* if not zero then sign must be positive */
      res = bld->one;
   }
   else if(type.floating) {
      LLVMTypeRef vec_type;
      LLVMTypeRef int_type;
      LLVMValueRef mask;
      LLVMValueRef sign;
      LLVMValueRef one;
      unsigned long long maskBit = (unsigned long long)1 << (type.width - 1);

      int_type = lp_build_int_vec_type(bld->gallivm, type);
      vec_type = lp_build_vec_type(bld->gallivm, type);
      mask = lp_build_const_int_vec(bld->gallivm, type, maskBit);

      /* Take the sign bit and add it to 1 constant */
      sign = LLVMBuildBitCast(builder, a, int_type, "");
      sign = LLVMBuildAnd(builder, sign, mask, "");
      one = LLVMConstBitCast(bld->one, int_type);
      res = LLVMBuildOr(builder, sign, one, "");
      res = LLVMBuildBitCast(builder, res, vec_type, "");
   }
   else
   {
      /* signed int/norm/fixed point */
      /* could use psign with sse3 and appropriate vectors here */
      LLVMValueRef minus_one = lp_build_const_vec(bld->gallivm, type, -1.0);
      cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, bld->zero);
      res = lp_build_select(bld, cond, bld->one, minus_one);
   }

   /* Handle zero */
   cond = lp_build_cmp(bld, PIPE_FUNC_EQUAL, a, bld->zero);
   res = lp_build_select(bld, cond, bld->zero, res);

   return res;
}


/**
 * Set the sign of float vector 'a' according to 'sign'.
 * If sign==0, return abs(a).
 * If sign==1, return -abs(a);
 * Other values for sign produce undefined results.
 */
LLVMValueRef
lp_build_set_sign(struct lp_build_context *bld,
                  LLVMValueRef a, LLVMValueRef sign)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
   LLVMValueRef shift = lp_build_const_int_vec(bld->gallivm, type, type.width - 1);
   LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type,
                             ~((unsigned long long) 1 << (type.width - 1)));
   LLVMValueRef val, res;

   assert(type.floating);
   assert(lp_check_value(type, a));

   /* val = reinterpret_cast<int>(a) */
   val = LLVMBuildBitCast(builder, a, int_vec_type, "");
   /* val = val & mask */
   val = LLVMBuildAnd(builder, val, mask, "");
   /* sign = sign << shift */
   sign = LLVMBuildShl(builder, sign, shift, "");
   /* res = val | sign */
   res = LLVMBuildOr(builder, val, sign, "");
   /* res = reinterpret_cast<float>(res) */
   res = LLVMBuildBitCast(builder, res, vec_type, "");

   return res;
}


/**
 * Convert vector of (or scalar) int to vector of (or scalar) float.
 */
LLVMValueRef
lp_build_int_to_float(struct lp_build_context *bld,
                      LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);

   assert(type.floating);

   return LLVMBuildSIToFP(builder, a, vec_type, "");
}

static boolean
arch_rounding_available(const struct lp_type type)
{
   if ((util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) ||
       (util_cpu_caps.has_avx && type.width*type.length == 256))
      return TRUE;
   else if ((util_cpu_caps.has_altivec &&
            (type.width == 32 && type.length == 4)))
      return TRUE;

   return FALSE;
}

enum lp_build_round_mode
{
   LP_BUILD_ROUND_NEAREST = 0,
   LP_BUILD_ROUND_FLOOR = 1,
   LP_BUILD_ROUND_CEIL = 2,
   LP_BUILD_ROUND_TRUNCATE = 3
};

/**
 * Helper for SSE4.1's ROUNDxx instructions.
 *
 * NOTE: In the SSE4.1's nearest mode, if two values are equally close, the
 * result is the even value.  That is, rounding 2.5 will be 2.0, and not 3.0.
 */
static INLINE LLVMValueRef
lp_build_round_sse41(struct lp_build_context *bld,
                     LLVMValueRef a,
                     enum lp_build_round_mode mode)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef i32t = LLVMInt32TypeInContext(bld->gallivm->context);
   const char *intrinsic;
   LLVMValueRef res;

   assert(type.floating);

   assert(lp_check_value(type, a));
   assert(util_cpu_caps.has_sse4_1);

   if (type.length == 1) {
      LLVMTypeRef vec_type;
      LLVMValueRef undef;
      LLVMValueRef args[3];
      LLVMValueRef index0 = LLVMConstInt(i32t, 0, 0);

      switch(type.width) {
      case 32:
         intrinsic = "llvm.x86.sse41.round.ss";
         break;
      case 64:
         intrinsic = "llvm.x86.sse41.round.sd";
         break;
      default:
         assert(0);
         return bld->undef;
      }

      vec_type = LLVMVectorType(bld->elem_type, 4);

      undef = LLVMGetUndef(vec_type);

      args[0] = undef;
      args[1] = LLVMBuildInsertElement(builder, undef, a, index0, "");
      args[2] = LLVMConstInt(i32t, mode, 0);

      res = lp_build_intrinsic(builder, intrinsic,
                               vec_type, args, Elements(args));

      res = LLVMBuildExtractElement(builder, res, index0, "");
   }
   else {
      if (type.width * type.length == 128) {
         switch(type.width) {
         case 32:
            intrinsic = "llvm.x86.sse41.round.ps";
            break;
         case 64:
            intrinsic = "llvm.x86.sse41.round.pd";
            break;
         default:
            assert(0);
            return bld->undef;
         }
      }
      else {
         assert(type.width * type.length == 256);
         assert(util_cpu_caps.has_avx);

         switch(type.width) {
         case 32:
            intrinsic = "llvm.x86.avx.round.ps.256";
            break;
         case 64:
            intrinsic = "llvm.x86.avx.round.pd.256";
            break;
         default:
            assert(0);
            return bld->undef;
         }
      }

      res = lp_build_intrinsic_binary(builder, intrinsic,
                                      bld->vec_type, a,
                                      LLVMConstInt(i32t, mode, 0));
   }

   return res;
}


static INLINE LLVMValueRef
lp_build_iround_nearest_sse2(struct lp_build_context *bld,
                             LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef i32t = LLVMInt32TypeInContext(bld->gallivm->context);
   LLVMTypeRef ret_type = lp_build_int_vec_type(bld->gallivm, type);
   const char *intrinsic;
   LLVMValueRef res;

   assert(type.floating);
   /* using the double precision conversions is a bit more complicated */
   assert(type.width == 32);

   assert(lp_check_value(type, a));
   assert(util_cpu_caps.has_sse2);

   /* This is relying on MXCSR rounding mode, which should always be nearest. */
   if (type.length == 1) {
      LLVMTypeRef vec_type;
      LLVMValueRef undef;
      LLVMValueRef arg;
      LLVMValueRef index0 = LLVMConstInt(i32t, 0, 0);

      vec_type = LLVMVectorType(bld->elem_type, 4);

      intrinsic = "llvm.x86.sse.cvtss2si";

      undef = LLVMGetUndef(vec_type);

      arg = LLVMBuildInsertElement(builder, undef, a, index0, "");

      res = lp_build_intrinsic_unary(builder, intrinsic,
                                     ret_type, arg);
   }
   else {
      if (type.width* type.length == 128) {
         intrinsic = "llvm.x86.sse2.cvtps2dq";
      }
      else {
         assert(type.width*type.length == 256);
         assert(util_cpu_caps.has_avx);

         intrinsic = "llvm.x86.avx.cvt.ps2dq.256";
      }
      res = lp_build_intrinsic_unary(builder, intrinsic,
                                     ret_type, a);
   }

   return res;
}


/*
 */
static INLINE LLVMValueRef
lp_build_round_altivec(struct lp_build_context *bld,
                       LLVMValueRef a,
                       enum lp_build_round_mode mode)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   const char *intrinsic = NULL;

   assert(type.floating);

   assert(lp_check_value(type, a));
   assert(util_cpu_caps.has_altivec);

   switch (mode) {
   case LP_BUILD_ROUND_NEAREST:
      intrinsic = "llvm.ppc.altivec.vrfin";
      break;
   case LP_BUILD_ROUND_FLOOR:
      intrinsic = "llvm.ppc.altivec.vrfim";
      break;
   case LP_BUILD_ROUND_CEIL:
      intrinsic = "llvm.ppc.altivec.vrfip";
      break;
   case LP_BUILD_ROUND_TRUNCATE:
      intrinsic = "llvm.ppc.altivec.vrfiz";
      break;
   }

   return lp_build_intrinsic_unary(builder, intrinsic, bld->vec_type, a);
}

static INLINE LLVMValueRef
lp_build_round_arch(struct lp_build_context *bld,
                    LLVMValueRef a,
                    enum lp_build_round_mode mode)
{
   if (util_cpu_caps.has_sse4_1)
     return lp_build_round_sse41(bld, a, mode);
   else /* (util_cpu_caps.has_altivec) */
     return lp_build_round_altivec(bld, a, mode);
}

/**
 * Return the integer part of a float (vector) value (== round toward zero).
 * The returned value is a float (vector).
 * Ex: trunc(-1.5) = -1.0
 */
LLVMValueRef
lp_build_trunc(struct lp_build_context *bld,
               LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(type.floating);
   assert(lp_check_value(type, a));

   if (arch_rounding_available(type)) {
      return lp_build_round_arch(bld, a, LP_BUILD_ROUND_TRUNCATE);
   }
   else {
      const struct lp_type type = bld->type;
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 1<<24);
      LLVMValueRef trunc, res, anosign, mask;
      LLVMTypeRef int_vec_type = bld->int_vec_type;
      LLVMTypeRef vec_type = bld->vec_type;

      assert(type.width == 32); /* might want to handle doubles at some point */

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      /* round by truncation */
      trunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      res = LLVMBuildSIToFP(builder, trunc, vec_type, "floor.trunc");

      /* mask out sign bit */
      anosign = lp_build_abs(bld, a);
      /*
       * mask out all values if anosign > 2^24
       * This should work both for large ints (all rounding is no-op for them
       * because such floats are always exact) as well as special cases like
       * NaNs, Infs (taking advantage of the fact they use max exponent).
       * (2^24 is arbitrary anything between 2^24 and 2^31 should work.)
       */
      anosign = LLVMBuildBitCast(builder, anosign, int_vec_type, "");
      cmpval = LLVMBuildBitCast(builder, cmpval, int_vec_type, "");
      mask = lp_build_cmp(&intbld, PIPE_FUNC_GREATER, anosign, cmpval);
      return lp_build_select(bld, mask, a, res);
   }
}


/**
 * Return float (vector) rounded to nearest integer (vector).  The returned
 * value is a float (vector).
 * Ex: round(0.9) = 1.0
 * Ex: round(-1.5) = -2.0
 */
LLVMValueRef
lp_build_round(struct lp_build_context *bld,
               LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(type.floating);
   assert(lp_check_value(type, a));

   if (arch_rounding_available(type)) {
      return lp_build_round_arch(bld, a, LP_BUILD_ROUND_NEAREST);
   }
   else {
      const struct lp_type type = bld->type;
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 1<<24);
      LLVMValueRef res, anosign, mask;
      LLVMTypeRef int_vec_type = bld->int_vec_type;
      LLVMTypeRef vec_type = bld->vec_type;

      assert(type.width == 32); /* might want to handle doubles at some point */

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      res = lp_build_iround(bld, a);
      res = LLVMBuildSIToFP(builder, res, vec_type, "");

      /* mask out sign bit */
      anosign = lp_build_abs(bld, a);
      /*
       * mask out all values if anosign > 2^24
       * This should work both for large ints (all rounding is no-op for them
       * because such floats are always exact) as well as special cases like
       * NaNs, Infs (taking advantage of the fact they use max exponent).
       * (2^24 is arbitrary anything between 2^24 and 2^31 should work.)
       */
      anosign = LLVMBuildBitCast(builder, anosign, int_vec_type, "");
      cmpval = LLVMBuildBitCast(builder, cmpval, int_vec_type, "");
      mask = lp_build_cmp(&intbld, PIPE_FUNC_GREATER, anosign, cmpval);
      return lp_build_select(bld, mask, a, res);
   }
}


/**
 * Return floor of float (vector), result is a float (vector)
 * Ex: floor(1.1) = 1.0
 * Ex: floor(-1.1) = -2.0
 */
LLVMValueRef
lp_build_floor(struct lp_build_context *bld,
               LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(type.floating);
   assert(lp_check_value(type, a));

   if (arch_rounding_available(type)) {
      return lp_build_round_arch(bld, a, LP_BUILD_ROUND_FLOOR);
   }
   else {
      const struct lp_type type = bld->type;
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 1<<24);
      LLVMValueRef trunc, res, anosign, mask;
      LLVMTypeRef int_vec_type = bld->int_vec_type;
      LLVMTypeRef vec_type = bld->vec_type;

      assert(type.width == 32); /* might want to handle doubles at some point */

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      /* round by truncation */
      trunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      res = LLVMBuildSIToFP(builder, trunc, vec_type, "floor.trunc");

      if (type.sign) {
         LLVMValueRef tmp;

         /*
          * fix values if rounding is wrong (for non-special cases)
          * - this is the case if trunc > a
          */
         mask = lp_build_cmp(bld, PIPE_FUNC_GREATER, res, a);
         /* tmp = trunc > a ? 1.0 : 0.0 */
         tmp = LLVMBuildBitCast(builder, bld->one, int_vec_type, "");
         tmp = lp_build_and(&intbld, mask, tmp);
         tmp = LLVMBuildBitCast(builder, tmp, vec_type, "");
         res = lp_build_sub(bld, res, tmp);
      }

      /* mask out sign bit */
      anosign = lp_build_abs(bld, a);
      /*
       * mask out all values if anosign > 2^24
       * This should work both for large ints (all rounding is no-op for them
       * because such floats are always exact) as well as special cases like
       * NaNs, Infs (taking advantage of the fact they use max exponent).
       * (2^24 is arbitrary anything between 2^24 and 2^31 should work.)
       */
      anosign = LLVMBuildBitCast(builder, anosign, int_vec_type, "");
      cmpval = LLVMBuildBitCast(builder, cmpval, int_vec_type, "");
      mask = lp_build_cmp(&intbld, PIPE_FUNC_GREATER, anosign, cmpval);
      return lp_build_select(bld, mask, a, res);
   }
}


/**
 * Return ceiling of float (vector), returning float (vector).
 * Ex: ceil( 1.1) = 2.0
 * Ex: ceil(-1.1) = -1.0
 */
LLVMValueRef
lp_build_ceil(struct lp_build_context *bld,
              LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(type.floating);
   assert(lp_check_value(type, a));

   if (arch_rounding_available(type)) {
      return lp_build_round_arch(bld, a, LP_BUILD_ROUND_CEIL);
   }
   else {
      const struct lp_type type = bld->type;
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 1<<24);
      LLVMValueRef trunc, res, anosign, mask, tmp;
      LLVMTypeRef int_vec_type = bld->int_vec_type;
      LLVMTypeRef vec_type = bld->vec_type;

      assert(type.width == 32); /* might want to handle doubles at some point */

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      /* round by truncation */
      trunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      trunc = LLVMBuildSIToFP(builder, trunc, vec_type, "ceil.trunc");

      /*
       * fix values if rounding is wrong (for non-special cases)
       * - this is the case if trunc < a
       */
      mask = lp_build_cmp(bld, PIPE_FUNC_LESS, trunc, a);
      /* tmp = trunc < a ? 1.0 : 0.0 */
      tmp = LLVMBuildBitCast(builder, bld->one, int_vec_type, "");
      tmp = lp_build_and(&intbld, mask, tmp);
      tmp = LLVMBuildBitCast(builder, tmp, vec_type, "");
      res = lp_build_add(bld, trunc, tmp);

      /* mask out sign bit */
      anosign = lp_build_abs(bld, a);
      /*
       * mask out all values if anosign > 2^24
       * This should work both for large ints (all rounding is no-op for them
       * because such floats are always exact) as well as special cases like
       * NaNs, Infs (taking advantage of the fact they use max exponent).
       * (2^24 is arbitrary anything between 2^24 and 2^31 should work.)
       */
      anosign = LLVMBuildBitCast(builder, anosign, int_vec_type, "");
      cmpval = LLVMBuildBitCast(builder, cmpval, int_vec_type, "");
      mask = lp_build_cmp(&intbld, PIPE_FUNC_GREATER, anosign, cmpval);
      return lp_build_select(bld, mask, a, res);
   }
}


/**
 * Return fractional part of 'a' computed as a - floor(a)
 * Typically used in texture coord arithmetic.
 */
LLVMValueRef
lp_build_fract(struct lp_build_context *bld,
               LLVMValueRef a)
{
   assert(bld->type.floating);
   return lp_build_sub(bld, a, lp_build_floor(bld, a));
}


/**
 * Prevent returning a fractional part of 1.0 for very small negative values of
 * 'a' by clamping against 0.99999(9).
 */
static inline LLVMValueRef
clamp_fract(struct lp_build_context *bld, LLVMValueRef fract)
{
   LLVMValueRef max;

   /* this is the largest number smaller than 1.0 representable as float */
   max = lp_build_const_vec(bld->gallivm, bld->type,
                            1.0 - 1.0/(1LL << (lp_mantissa(bld->type) + 1)));
   return lp_build_min(bld, fract, max);
}


/**
 * Same as lp_build_fract, but guarantees that the result is always smaller
 * than one.
 */
LLVMValueRef
lp_build_fract_safe(struct lp_build_context *bld,
                    LLVMValueRef a)
{
   return clamp_fract(bld, lp_build_fract(bld, a));
}


/**
 * Return the integer part of a float (vector) value (== round toward zero).
 * The returned value is an integer (vector).
 * Ex: itrunc(-1.5) = -1
 */
LLVMValueRef
lp_build_itrunc(struct lp_build_context *bld,
                LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);

   assert(type.floating);
   assert(lp_check_value(type, a));

   return LLVMBuildFPToSI(builder, a, int_vec_type, "");
}


/**
 * Return float (vector) rounded to nearest integer (vector).  The returned
 * value is an integer (vector).
 * Ex: iround(0.9) = 1
 * Ex: iround(-1.5) = -2
 */
LLVMValueRef
lp_build_iround(struct lp_build_context *bld,
                LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef int_vec_type = bld->int_vec_type;
   LLVMValueRef res;

   assert(type.floating);

   assert(lp_check_value(type, a));

   if ((util_cpu_caps.has_sse2 &&
       ((type.width == 32) && (type.length == 1 || type.length == 4))) ||
       (util_cpu_caps.has_avx && type.width == 32 && type.length == 8)) {
      return lp_build_iround_nearest_sse2(bld, a);
   }
   if (arch_rounding_available(type)) {
      res = lp_build_round_arch(bld, a, LP_BUILD_ROUND_NEAREST);
   }
   else {
      LLVMValueRef half;

      half = lp_build_const_vec(bld->gallivm, type, 0.5);

      if (type.sign) {
         LLVMTypeRef vec_type = bld->vec_type;
         LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type,
                                    (unsigned long long)1 << (type.width - 1));
         LLVMValueRef sign;

         /* get sign bit */
         sign = LLVMBuildBitCast(builder, a, int_vec_type, "");
         sign = LLVMBuildAnd(builder, sign, mask, "");

         /* sign * 0.5 */
         half = LLVMBuildBitCast(builder, half, int_vec_type, "");
         half = LLVMBuildOr(builder, sign, half, "");
         half = LLVMBuildBitCast(builder, half, vec_type, "");
      }

      res = LLVMBuildFAdd(builder, a, half, "");
   }

   res = LLVMBuildFPToSI(builder, res, int_vec_type, "");

   return res;
}


/**
 * Return floor of float (vector), result is an int (vector)
 * Ex: ifloor(1.1) = 1.0
 * Ex: ifloor(-1.1) = -2.0
 */
LLVMValueRef
lp_build_ifloor(struct lp_build_context *bld,
                LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef int_vec_type = bld->int_vec_type;
   LLVMValueRef res;

   assert(type.floating);
   assert(lp_check_value(type, a));

   res = a;
   if (type.sign) {
      if (arch_rounding_available(type)) {
         res = lp_build_round_arch(bld, a, LP_BUILD_ROUND_FLOOR);
      }
      else {
         struct lp_type inttype;
         struct lp_build_context intbld;
         LLVMValueRef trunc, itrunc, mask;

         assert(type.floating);
         assert(lp_check_value(type, a));

         inttype = type;
         inttype.floating = 0;
         lp_build_context_init(&intbld, bld->gallivm, inttype);

         /* round by truncation */
         itrunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
         trunc = LLVMBuildSIToFP(builder, itrunc, bld->vec_type, "ifloor.trunc");

         /*
          * fix values if rounding is wrong (for non-special cases)
          * - this is the case if trunc > a
          * The results of doing this with NaNs, very large values etc.
          * are undefined but this seems to be the case anyway.
          */
         mask = lp_build_cmp(bld, PIPE_FUNC_GREATER, trunc, a);
         /* cheapie minus one with mask since the mask is minus one / zero */
         return lp_build_add(&intbld, itrunc, mask);
      }
   }

   /* round to nearest (toward zero) */
   res = LLVMBuildFPToSI(builder, res, int_vec_type, "ifloor.res");

   return res;
}


/**
 * Return ceiling of float (vector), returning int (vector).
 * Ex: iceil( 1.1) = 2
 * Ex: iceil(-1.1) = -1
 */
LLVMValueRef
lp_build_iceil(struct lp_build_context *bld,
               LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef int_vec_type = bld->int_vec_type;
   LLVMValueRef res;

   assert(type.floating);
   assert(lp_check_value(type, a));

   if (arch_rounding_available(type)) {
      res = lp_build_round_arch(bld, a, LP_BUILD_ROUND_CEIL);
   }
   else {
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef trunc, itrunc, mask;

      assert(type.floating);
      assert(lp_check_value(type, a));

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      /* round by truncation */
      itrunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      trunc = LLVMBuildSIToFP(builder, itrunc, bld->vec_type, "iceil.trunc");

      /*
       * fix values if rounding is wrong (for non-special cases)
       * - this is the case if trunc < a
       * The results of doing this with NaNs, very large values etc.
       * are undefined but this seems to be the case anyway.
       */
      mask = lp_build_cmp(bld, PIPE_FUNC_LESS, trunc, a);
      /* cheapie plus one with mask since the mask is minus one / zero */
      return lp_build_sub(&intbld, itrunc, mask);
   }

   /* round to nearest (toward zero) */
   res = LLVMBuildFPToSI(builder, res, int_vec_type, "iceil.res");

   return res;
}


/**
 * Combined ifloor() & fract().
 *
 * Preferred to calling the functions separately, as it will ensure that the
 * strategy (floor() vs ifloor()) that results in less redundant work is used.
 */
void
lp_build_ifloor_fract(struct lp_build_context *bld,
                      LLVMValueRef a,
                      LLVMValueRef *out_ipart,
                      LLVMValueRef *out_fpart)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef ipart;

   assert(type.floating);
   assert(lp_check_value(type, a));

   if (arch_rounding_available(type)) {
      /*
       * floor() is easier.
       */

      ipart = lp_build_floor(bld, a);
      *out_fpart = LLVMBuildFSub(builder, a, ipart, "fpart");
      *out_ipart = LLVMBuildFPToSI(builder, ipart, bld->int_vec_type, "ipart");
   }
   else {
      /*
       * ifloor() is easier.
       */

      *out_ipart = lp_build_ifloor(bld, a);
      ipart = LLVMBuildSIToFP(builder, *out_ipart, bld->vec_type, "ipart");
      *out_fpart = LLVMBuildFSub(builder, a, ipart, "fpart");
   }
}


/**
 * Same as lp_build_ifloor_fract, but guarantees that the fractional part is
 * always smaller than one.
 */
void
lp_build_ifloor_fract_safe(struct lp_build_context *bld,
                           LLVMValueRef a,
                           LLVMValueRef *out_ipart,
                           LLVMValueRef *out_fpart)
{
   lp_build_ifloor_fract(bld, a, out_ipart, out_fpart);
   *out_fpart = clamp_fract(bld, *out_fpart);
}


LLVMValueRef
lp_build_sqrt(struct lp_build_context *bld,
              LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
   char intrinsic[32];

   assert(lp_check_value(type, a));

   /* TODO: optimize the constant case */

   assert(type.floating);
   if (type.length == 1) {
      util_snprintf(intrinsic, sizeof intrinsic, "llvm.sqrt.f%u", type.width);
   }
   else {
      util_snprintf(intrinsic, sizeof intrinsic, "llvm.sqrt.v%uf%u", type.length, type.width);
   }

   return lp_build_intrinsic_unary(builder, intrinsic, vec_type, a);
}


/**
 * Do one Newton-Raphson step to improve reciprocate precision:
 *
 *   x_{i+1} = x_i * (2 - a * x_i)
 *
 * XXX: Unfortunately this won't give IEEE-754 conformant results for 0 or
 * +/-Inf, giving NaN instead.  Certain applications rely on this behavior,
 * such as Google Earth, which does RCP(RSQRT(0.0) when drawing the Earth's
 * halo. It would be necessary to clamp the argument to prevent this.
 *
 * See also:
 * - http://en.wikipedia.org/wiki/Division_(digital)#Newton.E2.80.93Raphson_division
 * - http://softwarecommunity.intel.com/articles/eng/1818.htm
 */
static INLINE LLVMValueRef
lp_build_rcp_refine(struct lp_build_context *bld,
                    LLVMValueRef a,
                    LLVMValueRef rcp_a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef two = lp_build_const_vec(bld->gallivm, bld->type, 2.0);
   LLVMValueRef res;

   res = LLVMBuildFMul(builder, a, rcp_a, "");
   res = LLVMBuildFSub(builder, two, res, "");
   res = LLVMBuildFMul(builder, rcp_a, res, "");

   return res;
}


LLVMValueRef
lp_build_rcp(struct lp_build_context *bld,
             LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(lp_check_value(type, a));

   if(a == bld->zero)
      return bld->undef;
   if(a == bld->one)
      return bld->one;
   if(a == bld->undef)
      return bld->undef;

   assert(type.floating);

   if(LLVMIsConstant(a))
      return LLVMConstFDiv(bld->one, a);

   /*
    * We don't use RCPPS because:
    * - it only has 10bits of precision
    * - it doesn't even get the reciprocate of 1.0 exactly
    * - doing Newton-Rapshon steps yields wrong (NaN) values for 0.0 or Inf
    * - for recent processors the benefit over DIVPS is marginal, a case
    *   dependent
    *
    * We could still use it on certain processors if benchmarks show that the
    * RCPPS plus necessary workarounds are still preferrable to DIVPS; or for
    * particular uses that require less workarounds.
    */

   if (FALSE && ((util_cpu_caps.has_sse && type.width == 32 && type.length == 4) ||
         (util_cpu_caps.has_avx && type.width == 32 && type.length == 8))){
      const unsigned num_iterations = 0;
      LLVMValueRef res;
      unsigned i;
      const char *intrinsic = NULL;

      if (type.length == 4) {
         intrinsic = "llvm.x86.sse.rcp.ps";
      }
      else {
         intrinsic = "llvm.x86.avx.rcp.ps.256";
      }

      res = lp_build_intrinsic_unary(builder, intrinsic, bld->vec_type, a);

      for (i = 0; i < num_iterations; ++i) {
         res = lp_build_rcp_refine(bld, a, res);
      }

      return res;
   }

   return LLVMBuildFDiv(builder, bld->one, a, "");
}


/**
 * Do one Newton-Raphson step to improve rsqrt precision:
 *
 *   x_{i+1} = 0.5 * x_i * (3.0 - a * x_i * x_i)
 *
 * See also Intel 64 and IA-32 Architectures Optimization Manual.
 */
static INLINE LLVMValueRef
lp_build_rsqrt_refine(struct lp_build_context *bld,
                      LLVMValueRef a,
                      LLVMValueRef rsqrt_a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef half = lp_build_const_vec(bld->gallivm, bld->type, 0.5);
   LLVMValueRef three = lp_build_const_vec(bld->gallivm, bld->type, 3.0);
   LLVMValueRef res;

   res = LLVMBuildFMul(builder, rsqrt_a, rsqrt_a, "");
   res = LLVMBuildFMul(builder, a, res, "");
   res = LLVMBuildFSub(builder, three, res, "");
   res = LLVMBuildFMul(builder, rsqrt_a, res, "");
   res = LLVMBuildFMul(builder, half, res, "");

   return res;
}


/**
 * Generate 1/sqrt(a).
 * Result is undefined for values < 0, infinity for +0.
 */
LLVMValueRef
lp_build_rsqrt(struct lp_build_context *bld,
               LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(lp_check_value(type, a));

   assert(type.floating);

   /*
    * This should be faster but all denormals will end up as infinity.
    */
   if (0 && lp_build_fast_rsqrt_available(type)) {
      const unsigned num_iterations = 1;
      LLVMValueRef res;
      unsigned i;

      /* rsqrt(1.0) != 1.0 here */
      res = lp_build_fast_rsqrt(bld, a);

      if (num_iterations) {
         /*
          * Newton-Raphson will result in NaN instead of infinity for zero,
          * and NaN instead of zero for infinity.
          * Also, need to ensure rsqrt(1.0) == 1.0.
          * All numbers smaller than FLT_MIN will result in +infinity
          * (rsqrtps treats all denormals as zero).
          */
         /*
          * Certain non-c99 compilers don't know INFINITY and might not support
          * hacks to evaluate it at compile time neither.
          */
         const unsigned posinf_int = 0x7F800000;
         LLVMValueRef cmp;
         LLVMValueRef flt_min = lp_build_const_vec(bld->gallivm, type, FLT_MIN);
         LLVMValueRef inf = lp_build_const_int_vec(bld->gallivm, type, posinf_int);

         inf = LLVMBuildBitCast(builder, inf, lp_build_vec_type(bld->gallivm, type), "");

         for (i = 0; i < num_iterations; ++i) {
            res = lp_build_rsqrt_refine(bld, a, res);
         }
         cmp = lp_build_compare(bld->gallivm, type, PIPE_FUNC_LESS, a, flt_min);
         res = lp_build_select(bld, cmp, inf, res);
         cmp = lp_build_compare(bld->gallivm, type, PIPE_FUNC_EQUAL, a, inf);
         res = lp_build_select(bld, cmp, bld->zero, res);
         cmp = lp_build_compare(bld->gallivm, type, PIPE_FUNC_EQUAL, a, bld->one);
         res = lp_build_select(bld, cmp, bld->one, res);
      }

      return res;
   }

   return lp_build_rcp(bld, lp_build_sqrt(bld, a));
}

/**
 * If there's a fast (inaccurate) rsqrt instruction available
 * (caller may want to avoid to call rsqrt_fast if it's not available,
 * i.e. for calculating x^0.5 it may do rsqrt_fast(x) * x but if
 * unavailable it would result in sqrt/div/mul so obviously
 * much better to just call sqrt, skipping both div and mul).
 */
boolean
lp_build_fast_rsqrt_available(struct lp_type type)
{
   assert(type.floating);

   if ((util_cpu_caps.has_sse && type.width == 32 && type.length == 4) ||
       (util_cpu_caps.has_avx && type.width == 32 && type.length == 8)) {
      return true;
   }
   return false;
}


/**
 * Generate 1/sqrt(a).
 * Result is undefined for values < 0, infinity for +0.
 * Precision is limited, only ~10 bits guaranteed
 * (rsqrt 1.0 may not be 1.0, denorms may be flushed to 0).
 */
LLVMValueRef
lp_build_fast_rsqrt(struct lp_build_context *bld,
                    LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(lp_check_value(type, a));

   if (lp_build_fast_rsqrt_available(type)) {
      const char *intrinsic = NULL;

      if (type.length == 4) {
         intrinsic = "llvm.x86.sse.rsqrt.ps";
      }
      else {
         intrinsic = "llvm.x86.avx.rsqrt.ps.256";
      }
      return lp_build_intrinsic_unary(builder, intrinsic, bld->vec_type, a);
   }
   else {
      debug_printf("%s: emulating fast rsqrt with rcp/sqrt\n", __FUNCTION__);
   }
   return lp_build_rcp(bld, lp_build_sqrt(bld, a));
}


/**
 * Generate sin(a) or cos(a) using polynomial approximation.
 * TODO: it might be worth recognizing sin and cos using same source
 * (i.e. d3d10 sincos opcode). Obviously doing both at the same time
 * would be way cheaper than calculating (nearly) everything twice...
 * Not sure it's common enough to be worth bothering however, scs
 * opcode could also benefit from calculating both though.
 */
static LLVMValueRef
lp_build_sin_or_cos(struct lp_build_context *bld,
                    LLVMValueRef a,
                    boolean cos)
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef b = gallivm->builder;
   struct lp_type int_type = lp_int_type(bld->type);

   /*
    *  take the absolute value,
    *  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
    */

   LLVMValueRef inv_sig_mask = lp_build_const_int_vec(gallivm, bld->type, ~0x80000000);
   LLVMValueRef a_v4si = LLVMBuildBitCast(b, a, bld->int_vec_type, "a_v4si");

   LLVMValueRef absi = LLVMBuildAnd(b, a_v4si, inv_sig_mask, "absi");
   LLVMValueRef x_abs = LLVMBuildBitCast(b, absi, bld->vec_type, "x_abs");

   /*
    * scale by 4/Pi
    * y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);
    */

   LLVMValueRef FOPi = lp_build_const_vec(gallivm, bld->type, 1.27323954473516);
   LLVMValueRef scale_y = LLVMBuildFMul(b, x_abs, FOPi, "scale_y");

   /*
    * store the integer part of y in mm0
    * emm2 = _mm_cvttps_epi32(y);
    */

   LLVMValueRef emm2_i = LLVMBuildFPToSI(b, scale_y, bld->int_vec_type, "emm2_i");

   /*
    * j=(j+1) & (~1) (see the cephes sources)
    * emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
    */

   LLVMValueRef all_one = lp_build_const_int_vec(gallivm, bld->type, 1);
   LLVMValueRef emm2_add =  LLVMBuildAdd(b, emm2_i, all_one, "emm2_add");
   /*
    * emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
    */
   LLVMValueRef inv_one = lp_build_const_int_vec(gallivm, bld->type, ~1);
   LLVMValueRef emm2_and =  LLVMBuildAnd(b, emm2_add, inv_one, "emm2_and");

   /*
    * y = _mm_cvtepi32_ps(emm2);
    */
   LLVMValueRef y_2 = LLVMBuildSIToFP(b, emm2_and, bld->vec_type, "y_2");

   LLVMValueRef const_2 = lp_build_const_int_vec(gallivm, bld->type, 2);
   LLVMValueRef const_4 = lp_build_const_int_vec(gallivm, bld->type, 4);
   LLVMValueRef const_29 = lp_build_const_int_vec(gallivm, bld->type, 29);
   LLVMValueRef sign_mask = lp_build_const_int_vec(gallivm, bld->type, 0x80000000);

   /*
    * Argument used for poly selection and sign bit determination
    * is different for sin vs. cos.
    */
   LLVMValueRef emm2_2 = cos ? LLVMBuildSub(b, emm2_and, const_2, "emm2_2") :
                               emm2_and;

   LLVMValueRef sign_bit = cos ? LLVMBuildShl(b, LLVMBuildAnd(b, const_4,
                                                              LLVMBuildNot(b, emm2_2, ""), ""),
                                              const_29, "sign_bit") :
                                 LLVMBuildAnd(b, LLVMBuildXor(b, a_v4si,
                                                              LLVMBuildShl(b, emm2_add,
                                                                           const_29, ""), ""),
                                              sign_mask, "sign_bit");

   /*
    * get the polynom selection mask
    * there is one polynom for 0 <= x <= Pi/4
    * and another one for Pi/4<x<=Pi/2
    * Both branches will be computed.
    *
    * emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
    * emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
    */

   LLVMValueRef emm2_3 =  LLVMBuildAnd(b, emm2_2, const_2, "emm2_3");
   LLVMValueRef poly_mask = lp_build_compare(gallivm,
                                             int_type, PIPE_FUNC_EQUAL,
                                             emm2_3, lp_build_const_int_vec(gallivm, bld->type, 0));

   /*
    * _PS_CONST(minus_cephes_DP1, -0.78515625);
    * _PS_CONST(minus_cephes_DP2, -2.4187564849853515625e-4);
    * _PS_CONST(minus_cephes_DP3, -3.77489497744594108e-8);
    */
   LLVMValueRef DP1 = lp_build_const_vec(gallivm, bld->type, -0.78515625);
   LLVMValueRef DP2 = lp_build_const_vec(gallivm, bld->type, -2.4187564849853515625e-4);
   LLVMValueRef DP3 = lp_build_const_vec(gallivm, bld->type, -3.77489497744594108e-8);

   /*
    * The magic pass: "Extended precision modular arithmetic"
    * x = ((x - y * DP1) - y * DP2) - y * DP3;
    * xmm1 = _mm_mul_ps(y, xmm1);
    * xmm2 = _mm_mul_ps(y, xmm2);
    * xmm3 = _mm_mul_ps(y, xmm3);
    */
   LLVMValueRef xmm1 = LLVMBuildFMul(b, y_2, DP1, "xmm1");
   LLVMValueRef xmm2 = LLVMBuildFMul(b, y_2, DP2, "xmm2");
   LLVMValueRef xmm3 = LLVMBuildFMul(b, y_2, DP3, "xmm3");

   /*
    * x = _mm_add_ps(x, xmm1);
    * x = _mm_add_ps(x, xmm2);
    * x = _mm_add_ps(x, xmm3);
    */

   LLVMValueRef x_1 = LLVMBuildFAdd(b, x_abs, xmm1, "x_1");
   LLVMValueRef x_2 = LLVMBuildFAdd(b, x_1, xmm2, "x_2");
   LLVMValueRef x_3 = LLVMBuildFAdd(b, x_2, xmm3, "x_3");

   /*
    * Evaluate the first polynom  (0 <= x <= Pi/4)
    *
    * z = _mm_mul_ps(x,x);
    */
   LLVMValueRef z = LLVMBuildFMul(b, x_3, x_3, "z");

   /*
    * _PS_CONST(coscof_p0,  2.443315711809948E-005);
    * _PS_CONST(coscof_p1, -1.388731625493765E-003);
    * _PS_CONST(coscof_p2,  4.166664568298827E-002);
    */
   LLVMValueRef coscof_p0 = lp_build_const_vec(gallivm, bld->type, 2.443315711809948E-005);
   LLVMValueRef coscof_p1 = lp_build_const_vec(gallivm, bld->type, -1.388731625493765E-003);
   LLVMValueRef coscof_p2 = lp_build_const_vec(gallivm, bld->type, 4.166664568298827E-002);

   /*
    * y = *(v4sf*)_ps_coscof_p0;
    * y = _mm_mul_ps(y, z);
    */
   LLVMValueRef y_3 = LLVMBuildFMul(b, z, coscof_p0, "y_3");
   LLVMValueRef y_4 = LLVMBuildFAdd(b, y_3, coscof_p1, "y_4");
   LLVMValueRef y_5 = LLVMBuildFMul(b, y_4, z, "y_5");
   LLVMValueRef y_6 = LLVMBuildFAdd(b, y_5, coscof_p2, "y_6");
   LLVMValueRef y_7 = LLVMBuildFMul(b, y_6, z, "y_7");
   LLVMValueRef y_8 = LLVMBuildFMul(b, y_7, z, "y_8");


   /*
    * tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
    * y = _mm_sub_ps(y, tmp);
    * y = _mm_add_ps(y, *(v4sf*)_ps_1);
    */
   LLVMValueRef half = lp_build_const_vec(gallivm, bld->type, 0.5);
   LLVMValueRef tmp = LLVMBuildFMul(b, z, half, "tmp");
   LLVMValueRef y_9 = LLVMBuildFSub(b, y_8, tmp, "y_8");
   LLVMValueRef one = lp_build_const_vec(gallivm, bld->type, 1.0);
   LLVMValueRef y_10 = LLVMBuildFAdd(b, y_9, one, "y_9");

   /*
    * _PS_CONST(sincof_p0, -1.9515295891E-4);
    * _PS_CONST(sincof_p1,  8.3321608736E-3);
    * _PS_CONST(sincof_p2, -1.6666654611E-1);
    */
   LLVMValueRef sincof_p0 = lp_build_const_vec(gallivm, bld->type, -1.9515295891E-4);
   LLVMValueRef sincof_p1 = lp_build_const_vec(gallivm, bld->type, 8.3321608736E-3);
   LLVMValueRef sincof_p2 = lp_build_const_vec(gallivm, bld->type, -1.6666654611E-1);

   /*
    * Evaluate the second polynom  (Pi/4 <= x <= 0)
    *
    * y2 = *(v4sf*)_ps_sincof_p0;
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_mul_ps(y2, x);
    * y2 = _mm_add_ps(y2, x);
    */

   LLVMValueRef y2_3 = LLVMBuildFMul(b, z, sincof_p0, "y2_3");
   LLVMValueRef y2_4 = LLVMBuildFAdd(b, y2_3, sincof_p1, "y2_4");
   LLVMValueRef y2_5 = LLVMBuildFMul(b, y2_4, z, "y2_5");
   LLVMValueRef y2_6 = LLVMBuildFAdd(b, y2_5, sincof_p2, "y2_6");
   LLVMValueRef y2_7 = LLVMBuildFMul(b, y2_6, z, "y2_7");
   LLVMValueRef y2_8 = LLVMBuildFMul(b, y2_7, x_3, "y2_8");
   LLVMValueRef y2_9 = LLVMBuildFAdd(b, y2_8, x_3, "y2_9");

   /*
    * select the correct result from the two polynoms
    * xmm3 = poly_mask;
    * y2 = _mm_and_ps(xmm3, y2); //, xmm3);
    * y = _mm_andnot_ps(xmm3, y);
    * y = _mm_or_ps(y,y2);
    */
   LLVMValueRef y2_i = LLVMBuildBitCast(b, y2_9, bld->int_vec_type, "y2_i");
   LLVMValueRef y_i = LLVMBuildBitCast(b, y_10, bld->int_vec_type, "y_i");
   LLVMValueRef y2_and = LLVMBuildAnd(b, y2_i, poly_mask, "y2_and");
   LLVMValueRef poly_mask_inv = LLVMBuildNot(b, poly_mask, "poly_mask_inv");
   LLVMValueRef y_and = LLVMBuildAnd(b, y_i, poly_mask_inv, "y_and");
   LLVMValueRef y_combine = LLVMBuildOr(b, y_and, y2_and, "y_combine");

   /*
    * update the sign
    * y = _mm_xor_ps(y, sign_bit);
    */
   LLVMValueRef y_sign = LLVMBuildXor(b, y_combine, sign_bit, "y_sign");
   LLVMValueRef y_result = LLVMBuildBitCast(b, y_sign, bld->vec_type, "y_result");

   LLVMValueRef isfinite = lp_build_isfinite(bld, a);

   /* clamp output to be within [-1, 1] */
   y_result = lp_build_clamp(bld, y_result,
                             lp_build_const_vec(bld->gallivm, bld->type,  -1.f),
                             lp_build_const_vec(bld->gallivm, bld->type,  1.f));
   /* If a is -inf, inf or NaN then return NaN */
   y_result = lp_build_select(bld, isfinite, y_result,
                              lp_build_const_vec(bld->gallivm, bld->type,  NAN));
   return y_result;
}


/**
 * Generate sin(a)
 */
LLVMValueRef
lp_build_sin(struct lp_build_context *bld,
             LLVMValueRef a)
{
   return lp_build_sin_or_cos(bld, a, FALSE);
}


/**
 * Generate cos(a)
 */
LLVMValueRef
lp_build_cos(struct lp_build_context *bld,
             LLVMValueRef a)
{
   return lp_build_sin_or_cos(bld, a, TRUE);
}


/**
 * Generate pow(x, y)
 */
LLVMValueRef
lp_build_pow(struct lp_build_context *bld,
             LLVMValueRef x,
             LLVMValueRef y)
{
   /* TODO: optimize the constant case */
   if (gallivm_debug & GALLIVM_DEBUG_PERF &&
       LLVMIsConstant(x) && LLVMIsConstant(y)) {
      debug_printf("%s: inefficient/imprecise constant arithmetic\n",
                   __FUNCTION__);
   }

   return lp_build_exp2(bld, lp_build_mul(bld, lp_build_log2(bld, x), y));
}


/**
 * Generate exp(x)
 */
LLVMValueRef
lp_build_exp(struct lp_build_context *bld,
             LLVMValueRef x)
{
   /* log2(e) = 1/log(2) */
   LLVMValueRef log2e = lp_build_const_vec(bld->gallivm, bld->type,
                                           1.4426950408889634);

   assert(lp_check_value(bld->type, x));

   return lp_build_exp2(bld, lp_build_mul(bld, log2e, x));
}


/**
 * Generate log(x)
 * Behavior is undefined with infs, 0s and nans
 */
LLVMValueRef
lp_build_log(struct lp_build_context *bld,
             LLVMValueRef x)
{
   /* log(2) */
   LLVMValueRef log2 = lp_build_const_vec(bld->gallivm, bld->type,
                                          0.69314718055994529);

   assert(lp_check_value(bld->type, x));

   return lp_build_mul(bld, log2, lp_build_log2(bld, x));
}

/**
 * Generate log(x) that handles edge cases (infs, 0s and nans)
 */
LLVMValueRef
lp_build_log_safe(struct lp_build_context *bld,
                  LLVMValueRef x)
{
   /* log(2) */
   LLVMValueRef log2 = lp_build_const_vec(bld->gallivm, bld->type,
                                          0.69314718055994529);

   assert(lp_check_value(bld->type, x));

   return lp_build_mul(bld, log2, lp_build_log2_safe(bld, x));
}


/**
 * Generate polynomial.
 * Ex:  coeffs[0] + x * coeffs[1] + x^2 * coeffs[2].
 */
LLVMValueRef
lp_build_polynomial(struct lp_build_context *bld,
                    LLVMValueRef x,
                    const double *coeffs,
                    unsigned num_coeffs)
{
   const struct lp_type type = bld->type;
   LLVMValueRef even = NULL, odd = NULL;
   LLVMValueRef x2;
   unsigned i;

   assert(lp_check_value(bld->type, x));

   /* TODO: optimize the constant case */
   if (gallivm_debug & GALLIVM_DEBUG_PERF &&
       LLVMIsConstant(x)) {
      debug_printf("%s: inefficient/imprecise constant arithmetic\n",
                   __FUNCTION__);
   }

   /*
    * Calculate odd and even terms seperately to decrease data dependency
    * Ex:
    *     c[0] + x^2 * c[2] + x^4 * c[4] ...
    *     + x * (c[1] + x^2 * c[3] + x^4 * c[5]) ...
    */
   x2 = lp_build_mul(bld, x, x);

   for (i = num_coeffs; i--; ) {
      LLVMValueRef coeff;

      coeff = lp_build_const_vec(bld->gallivm, type, coeffs[i]);

      if (i % 2 == 0) {
         if (even)
            even = lp_build_add(bld, coeff, lp_build_mul(bld, x2, even));
         else
            even = coeff;
      } else {
         if (odd)
            odd = lp_build_add(bld, coeff, lp_build_mul(bld, x2, odd));
         else
            odd = coeff;
      }
   }

   if (odd)
      return lp_build_add(bld, lp_build_mul(bld, odd, x), even);
   else if (even)
      return even;
   else
      return bld->undef;
}


/**
 * Minimax polynomial fit of 2**x, in range [0, 1[
 */
const double lp_build_exp2_polynomial[] = {
#if EXP_POLY_DEGREE == 5
   1.000000000000000000000, /*XXX: was 0.999999925063526176901, recompute others */
   0.693153073200168932794,
   0.240153617044375388211,
   0.0558263180532956664775,
   0.00898934009049466391101,
   0.00187757667519147912699
#elif EXP_POLY_DEGREE == 4
   1.00000259337069434683,
   0.693003834469974940458,
   0.24144275689150793076,
   0.0520114606103070150235,
   0.0135341679161270268764
#elif EXP_POLY_DEGREE == 3
   0.999925218562710312959,
   0.695833540494823811697,
   0.226067155427249155588,
   0.0780245226406372992967
#elif EXP_POLY_DEGREE == 2
   1.00172476321474503578,
   0.657636275736077639316,
   0.33718943461968720704
#else
#error
#endif
};


LLVMValueRef
lp_build_exp2(struct lp_build_context *bld,
              LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
   LLVMValueRef ipart = NULL;
   LLVMValueRef fpart = NULL;
   LLVMValueRef expipart = NULL;
   LLVMValueRef expfpart = NULL;
   LLVMValueRef res = NULL;

   assert(lp_check_value(bld->type, x));


   /* TODO: optimize the constant case */
   if (gallivm_debug & GALLIVM_DEBUG_PERF &&
       LLVMIsConstant(x)) {
      debug_printf("%s: inefficient/imprecise constant arithmetic\n",
                   __FUNCTION__);
   }

   assert(type.floating && type.width == 32);

   /* We want to preserve NaN and make sure than for exp2 if x > 128,
    * the result is INF  and if it's smaller than -126.9 the result is 0 */
   x = lp_build_min_ext(bld, lp_build_const_vec(bld->gallivm, type,  128.0), x,
                        GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
   x = lp_build_max(bld, lp_build_const_vec(bld->gallivm, type, -126.99999), x);

   /* ipart = floor(x) */
   /* fpart = x - ipart */
   lp_build_ifloor_fract(bld, x, &ipart, &fpart);



   /* expipart = (float) (1 << ipart) */
   expipart = LLVMBuildAdd(builder, ipart,
                           lp_build_const_int_vec(bld->gallivm, type, 127), "");
   expipart = LLVMBuildShl(builder, expipart,
                           lp_build_const_int_vec(bld->gallivm, type, 23), "");
   expipart = LLVMBuildBitCast(builder, expipart, vec_type, "");


   expfpart = lp_build_polynomial(bld, fpart, lp_build_exp2_polynomial,
                                  Elements(lp_build_exp2_polynomial));

   res = LLVMBuildFMul(builder, expipart, expfpart, "");


   return res;
}



/**
 * Extract the exponent of a IEEE-754 floating point value.
 *
 * Optionally apply an integer bias.
 *
 * Result is an integer value with
 *
 *   ifloor(log2(x)) + bias
 */
LLVMValueRef
lp_build_extract_exponent(struct lp_build_context *bld,
                          LLVMValueRef x,
                          int bias)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   unsigned mantissa = lp_mantissa(type);
   LLVMValueRef res;

   assert(type.floating);

   assert(lp_check_value(bld->type, x));

   x = LLVMBuildBitCast(builder, x, bld->int_vec_type, "");

   res = LLVMBuildLShr(builder, x,
                       lp_build_const_int_vec(bld->gallivm, type, mantissa), "");
   res = LLVMBuildAnd(builder, res,
                      lp_build_const_int_vec(bld->gallivm, type, 255), "");
   res = LLVMBuildSub(builder, res,
                      lp_build_const_int_vec(bld->gallivm, type, 127 - bias), "");

   return res;
}


/**
 * Extract the mantissa of the a floating.
 *
 * Result is a floating point value with
 *
 *   x / floor(log2(x))
 */
LLVMValueRef
lp_build_extract_mantissa(struct lp_build_context *bld,
                          LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   unsigned mantissa = lp_mantissa(type);
   LLVMValueRef mantmask = lp_build_const_int_vec(bld->gallivm, type,
                                                  (1ULL << mantissa) - 1);
   LLVMValueRef one = LLVMConstBitCast(bld->one, bld->int_vec_type);
   LLVMValueRef res;

   assert(lp_check_value(bld->type, x));

   assert(type.floating);

   x = LLVMBuildBitCast(builder, x, bld->int_vec_type, "");

   /* res = x / 2**ipart */
   res = LLVMBuildAnd(builder, x, mantmask, "");
   res = LLVMBuildOr(builder, res, one, "");
   res = LLVMBuildBitCast(builder, res, bld->vec_type, "");

   return res;
}



/**
 * Minimax polynomial fit of log2((1.0 + sqrt(x))/(1.0 - sqrt(x)))/sqrt(x) ,for x in range of [0, 1/9[
 * These coefficients can be generate with
 * http://www.boost.org/doc/libs/1_36_0/libs/math/doc/sf_and_dist/html/math_toolkit/toolkit/internals2/minimax.html
 */
const double lp_build_log2_polynomial[] = {
#if LOG_POLY_DEGREE == 5
   2.88539008148777786488L,
   0.961796878841293367824L,
   0.577058946784739859012L,
   0.412914355135828735411L,
   0.308591899232910175289L,
   0.352376952300281371868L,
#elif LOG_POLY_DEGREE == 4
   2.88539009343309178325L,
   0.961791550404184197881L,
   0.577440339438736392009L,
   0.403343858251329912514L,
   0.406718052498846252698L,
#elif LOG_POLY_DEGREE == 3
   2.88538959748872753838L,
   0.961932915889597772928L,
   0.571118517972136195241L,
   0.493997535084709500285L,
#else
#error
#endif
};

/**
 * See http://www.devmaster.net/forums/showthread.php?p=43580
 * http://en.wikipedia.org/wiki/Logarithm#Calculation
 * http://www.nezumi.demon.co.uk/consult/logx.htm
 *
 * If handle_edge_cases is true the function will perform computations
 * to match the required D3D10+ behavior for each of the edge cases.
 * That means that if input is:
 * - less than zero (to and including -inf) then NaN will be returned
 * - equal to zero (-denorm, -0, +0 or +denorm), then -inf will be returned
 * - +infinity, then +infinity will be returned
 * - NaN, then NaN will be returned
 *
 * Those checks are fairly expensive so if you don't need them make sure
 * handle_edge_cases is false.
 */
void
lp_build_log2_approx(struct lp_build_context *bld,
                     LLVMValueRef x,
                     LLVMValueRef *p_exp,
                     LLVMValueRef *p_floor_log2,
                     LLVMValueRef *p_log2,
                     boolean handle_edge_cases)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);

   LLVMValueRef expmask = lp_build_const_int_vec(bld->gallivm, type, 0x7f800000);
   LLVMValueRef mantmask = lp_build_const_int_vec(bld->gallivm, type, 0x007fffff);
   LLVMValueRef one = LLVMConstBitCast(bld->one, int_vec_type);

   LLVMValueRef i = NULL;
   LLVMValueRef y = NULL;
   LLVMValueRef z = NULL;
   LLVMValueRef exp = NULL;
   LLVMValueRef mant = NULL;
   LLVMValueRef logexp = NULL;
   LLVMValueRef logmant = NULL;
   LLVMValueRef res = NULL;

   assert(lp_check_value(bld->type, x));

   if(p_exp || p_floor_log2 || p_log2) {
      /* TODO: optimize the constant case */
      if (gallivm_debug & GALLIVM_DEBUG_PERF &&
          LLVMIsConstant(x)) {
         debug_printf("%s: inefficient/imprecise constant arithmetic\n",
                      __FUNCTION__);
      }

      assert(type.floating && type.width == 32);

      /* 
       * We don't explicitly handle denormalized numbers. They will yield a
       * result in the neighbourhood of -127, which appears to be adequate
       * enough.
       */

      i = LLVMBuildBitCast(builder, x, int_vec_type, "");

      /* exp = (float) exponent(x) */
      exp = LLVMBuildAnd(builder, i, expmask, "");
   }

   if(p_floor_log2 || p_log2) {
      logexp = LLVMBuildLShr(builder, exp, lp_build_const_int_vec(bld->gallivm, type, 23), "");
      logexp = LLVMBuildSub(builder, logexp, lp_build_const_int_vec(bld->gallivm, type, 127), "");
      logexp = LLVMBuildSIToFP(builder, logexp, vec_type, "");
   }

   if(p_log2) {
      /* mant = 1 + (float) mantissa(x) */
      mant = LLVMBuildAnd(builder, i, mantmask, "");
      mant = LLVMBuildOr(builder, mant, one, "");
      mant = LLVMBuildBitCast(builder, mant, vec_type, "");

      /* y = (mant - 1) / (mant + 1) */
      y = lp_build_div(bld,
         lp_build_sub(bld, mant, bld->one),
         lp_build_add(bld, mant, bld->one)
      );

      /* z = y^2 */
      z = lp_build_mul(bld, y, y);

      /* compute P(z) */
      logmant = lp_build_polynomial(bld, z, lp_build_log2_polynomial,
                                    Elements(lp_build_log2_polynomial));

      /* logmant = y * P(z) */
      logmant = lp_build_mul(bld, y, logmant);

      res = lp_build_add(bld, logmant, logexp);

      if (type.floating && handle_edge_cases) {
         LLVMValueRef negmask, infmask,  zmask;
         negmask = lp_build_cmp(bld, PIPE_FUNC_LESS, x,
                                lp_build_const_vec(bld->gallivm, type,  0.0f));
         zmask = lp_build_cmp(bld, PIPE_FUNC_EQUAL, x,
                              lp_build_const_vec(bld->gallivm, type,  0.0f));
         infmask = lp_build_cmp(bld, PIPE_FUNC_GEQUAL, x,
                                lp_build_const_vec(bld->gallivm, type,  INFINITY));

         /* If x is qual to inf make sure we return inf */
         res = lp_build_select(bld, infmask,
                               lp_build_const_vec(bld->gallivm, type,  INFINITY),
                               res);
         /* If x is qual to 0, return -inf */
         res = lp_build_select(bld, zmask,
                               lp_build_const_vec(bld->gallivm, type,  -INFINITY),
                               res);
         /* If x is nan or less than 0, return nan */
         res = lp_build_select(bld, negmask,
                               lp_build_const_vec(bld->gallivm, type,  NAN),
                               res);
      }
   }

   if(p_exp) {
      exp = LLVMBuildBitCast(builder, exp, vec_type, "");
      *p_exp = exp;
   }

   if(p_floor_log2)
      *p_floor_log2 = logexp;

   if(p_log2)
      *p_log2 = res;
}


/*
 * log2 implementation which doesn't have special code to
 * handle edge cases (-inf, 0, inf, NaN). It's faster but
 * the results for those cases are undefined.
 */
LLVMValueRef
lp_build_log2(struct lp_build_context *bld,
              LLVMValueRef x)
{
   LLVMValueRef res;
   lp_build_log2_approx(bld, x, NULL, NULL, &res, FALSE);
   return res;
}

/*
 * Version of log2 which handles all edge cases.
 * Look at documentation of lp_build_log2_approx for
 * description of the behavior for each of the edge cases.
 */
LLVMValueRef
lp_build_log2_safe(struct lp_build_context *bld,
                   LLVMValueRef x)
{
   LLVMValueRef res;
   lp_build_log2_approx(bld, x, NULL, NULL, &res, TRUE);
   return res;
}


/**
 * Faster (and less accurate) log2.
 *
 *    log2(x) = floor(log2(x)) - 1 + x / 2**floor(log2(x))
 *
 * Piece-wise linear approximation, with exact results when x is a
 * power of two.
 *
 * See http://www.flipcode.com/archives/Fast_log_Function.shtml
 */
LLVMValueRef
lp_build_fast_log2(struct lp_build_context *bld,
                   LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef ipart;
   LLVMValueRef fpart;

   assert(lp_check_value(bld->type, x));

   assert(bld->type.floating);

   /* ipart = floor(log2(x)) - 1 */
   ipart = lp_build_extract_exponent(bld, x, -1);
   ipart = LLVMBuildSIToFP(builder, ipart, bld->vec_type, "");

   /* fpart = x / 2**ipart */
   fpart = lp_build_extract_mantissa(bld, x);

   /* ipart + fpart */
   return LLVMBuildFAdd(builder, ipart, fpart, "");
}


/**
 * Fast implementation of iround(log2(x)).
 *
 * Not an approximation -- it should give accurate results all the time.
 */
LLVMValueRef
lp_build_ilog2(struct lp_build_context *bld,
               LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef sqrt2 = lp_build_const_vec(bld->gallivm, bld->type, M_SQRT2);
   LLVMValueRef ipart;

   assert(bld->type.floating);

   assert(lp_check_value(bld->type, x));

   /* x * 2^(0.5)   i.e., add 0.5 to the log2(x) */
   x = LLVMBuildFMul(builder, x, sqrt2, "");

   /* ipart = floor(log2(x) + 0.5)  */
   ipart = lp_build_extract_exponent(bld, x, 0);

   return ipart;
}

LLVMValueRef
lp_build_mod(struct lp_build_context *bld,
             LLVMValueRef x,
             LLVMValueRef y)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef res;
   const struct lp_type type = bld->type;

   assert(lp_check_value(type, x));
   assert(lp_check_value(type, y));

   if (type.floating)
      res = LLVMBuildFRem(builder, x, y, "");
   else if (type.sign)
      res = LLVMBuildSRem(builder, x, y, "");
   else
      res = LLVMBuildURem(builder, x, y, "");
   return res;
}


/*
 * For floating inputs it creates and returns a mask
 * which is all 1's for channels which are NaN.
 * Channels inside x which are not NaN will be 0.
 */
LLVMValueRef
lp_build_isnan(struct lp_build_context *bld,
               LLVMValueRef x)
{
   LLVMValueRef mask;
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, bld->type);

   assert(bld->type.floating);
   assert(lp_check_value(bld->type, x));

   mask = LLVMBuildFCmp(bld->gallivm->builder, LLVMRealOEQ, x, x,
                        "isnotnan");
   mask = LLVMBuildNot(bld->gallivm->builder, mask, "");
   mask = LLVMBuildSExt(bld->gallivm->builder, mask, int_vec_type, "isnan");
   return mask;
}

/* Returns all 1's for floating point numbers that are
 * finite numbers and returns all zeros for -inf,
 * inf and nan's */
LLVMValueRef
lp_build_isfinite(struct lp_build_context *bld,
                  LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, bld->type);
   struct lp_type int_type = lp_int_type(bld->type);
   LLVMValueRef intx = LLVMBuildBitCast(builder, x, int_vec_type, "");
   LLVMValueRef infornan32 = lp_build_const_int_vec(bld->gallivm, bld->type,
                                                    0x7f800000);

   if (!bld->type.floating) {
      return lp_build_const_int_vec(bld->gallivm, bld->type, 0);
   }
   assert(bld->type.floating);
   assert(lp_check_value(bld->type, x));
   assert(bld->type.width == 32);

   intx = LLVMBuildAnd(builder, intx, infornan32, "");
   return lp_build_compare(bld->gallivm, int_type, PIPE_FUNC_NOTEQUAL,
                           intx, infornan32);
}

/*
 * Returns true if the number is nan or inf and false otherwise.
 * The input has to be a floating point vector.
 */
LLVMValueRef
lp_build_is_inf_or_nan(struct gallivm_state *gallivm,
                       const struct lp_type type,
                       LLVMValueRef x)
{
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type int_type = lp_int_type(type);
   LLVMValueRef const0 = lp_build_const_int_vec(gallivm, int_type,
                                                0x7f800000);
   LLVMValueRef ret;

   assert(type.floating);

   ret = LLVMBuildBitCast(builder, x, lp_build_vec_type(gallivm, int_type), "");
   ret = LLVMBuildAnd(builder, ret, const0, "");
   ret = lp_build_compare(gallivm, int_type, PIPE_FUNC_EQUAL,
                          ret, const0);

   return ret;
}


LLVMValueRef
lp_build_fpstate_get(struct gallivm_state *gallivm)
{
   if (util_cpu_caps.has_sse) {
      LLVMBuilderRef builder = gallivm->builder;
      LLVMValueRef mxcsr_ptr = lp_build_alloca(
         gallivm,
         LLVMInt32TypeInContext(gallivm->context),
         "mxcsr_ptr");
      LLVMValueRef mxcsr_ptr8 = LLVMBuildPointerCast(builder, mxcsr_ptr,
          LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0), "");
      lp_build_intrinsic(builder,
                         "llvm.x86.sse.stmxcsr",
                         LLVMVoidTypeInContext(gallivm->context),
                         &mxcsr_ptr8, 1);
      return mxcsr_ptr;
   }
   return 0;
}

void
lp_build_fpstate_set_denorms_zero(struct gallivm_state *gallivm,
                                  boolean zero)
{
   if (util_cpu_caps.has_sse) {
      /* turn on DAZ (64) | FTZ (32768) = 32832 if available */
      int daz_ftz = _MM_FLUSH_ZERO_MASK;

      LLVMBuilderRef builder = gallivm->builder;
      LLVMValueRef mxcsr_ptr = lp_build_fpstate_get(gallivm);
      LLVMValueRef mxcsr =
         LLVMBuildLoad(builder, mxcsr_ptr, "mxcsr");

      if (util_cpu_caps.has_daz) {
         /* Enable denormals are zero mode */
         daz_ftz |= _MM_DENORMALS_ZERO_MASK;
      }
      if (zero) {
         mxcsr = LLVMBuildOr(builder, mxcsr,
                             LLVMConstInt(LLVMTypeOf(mxcsr), daz_ftz, 0), "");
      } else {
         mxcsr = LLVMBuildAnd(builder, mxcsr,
                              LLVMConstInt(LLVMTypeOf(mxcsr), ~daz_ftz, 0), "");
      }

      LLVMBuildStore(builder, mxcsr, mxcsr_ptr);
      lp_build_fpstate_set(gallivm, mxcsr_ptr);
   }
}

void
lp_build_fpstate_set(struct gallivm_state *gallivm,
                     LLVMValueRef mxcsr_ptr)
{
   if (util_cpu_caps.has_sse) {
      LLVMBuilderRef builder = gallivm->builder;
      mxcsr_ptr = LLVMBuildPointerCast(builder, mxcsr_ptr,
                     LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0), "");
      lp_build_intrinsic(builder,
                         "llvm.x86.sse.ldmxcsr",
                         LLVMVoidTypeInContext(gallivm->context),
                         &mxcsr_ptr, 1);
   }
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d137 1
a137 2
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN ||
          nan_behavior == GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN) {
d205 3
a207 4
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN &&
          nan_behavior != GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN) {
         LLVMValueRef isnan, min;
         min = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
d212 1
a212 1
            return lp_build_select(bld, isnan, a, min);
d216 1
a216 1
            return lp_build_select(bld, isnan, a, min);
a243 3
      case GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN:
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, b, a);
         return lp_build_select(bld, cond, b, a);
d313 1
a313 2
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN ||
          nan_behavior == GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN) {
d376 3
a378 4
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN &&
          nan_behavior != GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN) {
         LLVMValueRef isnan, max;
         max = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
d383 1
a383 1
            return lp_build_select(bld, isnan, a, max);
d387 1
a387 1
            return lp_build_select(bld, isnan, a, max);
a414 3
      case GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN:
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, b, a);
         return lp_build_select(bld, cond, b, a);
d515 3
a517 14
   if(type.norm && !type.floating && !type.fixed) {
      if (type.sign) {
         uint64_t sign = (uint64_t)1 << (type.width - 1);
         LLVMValueRef max_val = lp_build_const_int_vec(bld->gallivm, type, sign - 1);
         LLVMValueRef min_val = lp_build_const_int_vec(bld->gallivm, type, sign);
         /* a_clamp_max is the maximum a for positive b,
            a_clamp_min is the minimum a for negative b. */
         LLVMValueRef a_clamp_max = lp_build_min_simple(bld, a, LLVMBuildSub(builder, max_val, b, ""), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
         LLVMValueRef a_clamp_min = lp_build_max_simple(bld, a, LLVMBuildSub(builder, min_val, b, ""), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
         a = lp_build_select(bld, lp_build_cmp(bld, PIPE_FUNC_GREATER, b, bld->zero), a_clamp_max, a_clamp_min);
      } else {
         a = lp_build_min_simple(bld, a, lp_build_comp(bld, b), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
      }
   }
d796 3
a798 14
   if(type.norm && !type.floating && !type.fixed) {
      if (type.sign) {
         uint64_t sign = (uint64_t)1 << (type.width - 1);
         LLVMValueRef max_val = lp_build_const_int_vec(bld->gallivm, type, sign - 1);
         LLVMValueRef min_val = lp_build_const_int_vec(bld->gallivm, type, sign);
         /* a_clamp_max is the maximum a for negative b,
            a_clamp_min is the minimum a for positive b. */
         LLVMValueRef a_clamp_max = lp_build_min_simple(bld, a, LLVMBuildAdd(builder, max_val, b, ""), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
         LLVMValueRef a_clamp_min = lp_build_max_simple(bld, a, LLVMBuildAdd(builder, min_val, b, ""), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
         a = lp_build_select(bld, lp_build_cmp(bld, PIPE_FUNC_GREATER, b, bld->zero), a_clamp_min, a_clamp_max);
      } else {
         a = lp_build_max_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
      }
   }
d1066 1
a1066 1
   if(a == bld->one && type.floating)
d1502 1
d1506 1
d3045 1
d3058 2
a3059 3
                        GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN);
   x = lp_build_max_ext(bld, lp_build_const_vec(bld->gallivm, type, -126.99999),
                        x, GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN);
d3065 2
d3074 1
d3079 1
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d137 2
a138 1
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
d206 4
a209 3
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
         LLVMValueRef isnan, max;
         max = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
d214 1
a214 1
            return lp_build_select(bld, isnan, a, max);
d218 1
a218 1
            return lp_build_select(bld, isnan, a, max);
d246 3
d318 2
a319 1
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
d382 4
a385 3
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
         LLVMValueRef isnan, min;
         min = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
d390 1
a390 1
            return lp_build_select(bld, isnan, a, min);
d394 1
a394 1
            return lp_build_select(bld, isnan, a, min);
d422 3
d525 14
a538 3
   /* TODO: handle signed case */
   if(type.norm && !type.floating && !type.fixed && !type.sign)
      a = lp_build_min_simple(bld, a, lp_build_comp(bld, b), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
d817 14
a830 3
   /* TODO: handle signed case */
   if(type.norm && !type.floating && !type.fixed && !type.sign)
      a = lp_build_max_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
d1098 1
a1098 1
   if(a == bld->one)
a1533 1
#if HAVE_LLVM >= 0x0207
a1536 1
#endif
d1885 1
a1885 1
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 2^24);
d1940 1
a1940 1
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 2^24);
d1993 1
a1993 1
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 2^24);
d2062 1
a2062 1
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 2^24);
a3074 1

d3087 3
a3089 2
                        GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
   x = lp_build_max(bld, lp_build_const_vec(bld->gallivm, type, -126.99999), x);
a3094 2


a3101 1

a3105 1

@


1.3
log
@Merge Mesa 9.2.0
@
text
@d67 11
d87 2
d93 2
a94 1
                    LLVMValueRef b)
d137 4
d152 1
a152 1
         }
d168 1
a168 1
        }
d174 20
a193 20
     intr_size = 128;
     if (type.width == 8) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vminub";
       } else {
         intrinsic = "llvm.ppc.altivec.vminsb";
       }
     } else if (type.width == 16) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vminuh";
       } else {
         intrinsic = "llvm.ppc.altivec.vminsh";
       }
     } else if (type.width == 32) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vminuw";
       } else {
         intrinsic = "llvm.ppc.altivec.vminsw";
       }
     }
d197 26
a222 3
      return lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                 type,
                                                 intr_size, a, b);
d225 32
a256 2
   cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
   return lp_build_select(bld, cond, a, b);
d263 2
d269 2
a270 1
                    LLVMValueRef b)
d313 4
d374 20
a393 3
      return lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                 type,
                                                 intr_size, a, b);
d396 32
a427 2
   cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
   return lp_build_select(bld, cond, a, b);
d517 1
a517 1
      a = lp_build_min_simple(bld, a, lp_build_comp(bld, b));
d532 1
a532 1
      res = lp_build_min_simple(bld, res, bld->one);
d798 1
a798 1
      a = lp_build_max_simple(bld, a, b);
d812 1
a812 1
      res = lp_build_max_simple(bld, res, bld->zero);
d1272 1
a1272 1
 * Do checks for special cases.
d1300 1
a1300 1
   return lp_build_min_simple(bld, a, b);
d1305 35
d1341 1
a1341 1
 * Do checks for special cases.
d1370 1
a1370 1
   return lp_build_max_simple(bld, a, b);
d1375 37
d1413 1
d1433 14
d2619 6
a2624 1
 * Generate sin(a) using SSE2
d2626 4
a2629 3
LLVMValueRef
lp_build_sin(struct lp_build_context *bld,
             LLVMValueRef a)
d2632 1
a2632 1
   LLVMBuilderRef builder = gallivm->builder;
a2633 1
   LLVMBuilderRef b = builder;
a2646 7
    * extract the sign bit (upper one)
    * sign_bit = _mm_and_ps(sign_bit, *(v4sf*)_ps_sign_mask);
    */
   LLVMValueRef sig_mask = lp_build_const_int_vec(gallivm, bld->type, 0x80000000);
   LLVMValueRef sign_bit_i = LLVMBuildAnd(b, a_v4si, sig_mask, "sign_bit_i");

   /*
d2650 1
a2650 1
   
d2658 1
a2658 1
   
d2679 8
a2686 2
   /* get the swap sign flag
    * emm0 = _mm_and_si128(emm2, *(v4si*)_pi32_4);
d2688 10
a2697 8
   LLVMValueRef pi32_4 = lp_build_const_int_vec(gallivm, bld->type, 4);
   LLVMValueRef emm0_and =  LLVMBuildAnd(b, emm2_add, pi32_4, "emm0_and");
   
   /*
    * emm2 = _mm_slli_epi32(emm0, 29);
    */  
   LLVMValueRef const_29 = lp_build_const_int_vec(gallivm, bld->type, 29);
   LLVMValueRef swap_sign_bit = LLVMBuildShl(b, emm0_and, const_29, "swap_sign_bit");
d2700 1
a2700 1
    * get the polynom selection mask 
d2704 1
a2704 1
    *  
d2709 1
a2709 2
   LLVMValueRef pi32_2 = lp_build_const_int_vec(gallivm, bld->type, 2);
   LLVMValueRef emm2_3 =  LLVMBuildAnd(b, emm2_and, pi32_2, "emm2_3");
a2712 4
   /*
    *   sign_bit = _mm_xor_ps(sign_bit, swap_sign_bit);
    */
   LLVMValueRef sign_bit_1 =  LLVMBuildXor(b, sign_bit_i, swap_sign_bit, "sign_bit");
d2724 2
a2725 2
    * The magic pass: "Extended precision modular arithmetic" 
    * x = ((x - y * DP1) - y * DP2) - y * DP3; 
d2738 1
a2738 1
    */ 
d2776 1
a2776 1
    */ 
d2831 1
a2831 1
   LLVMValueRef y_sign = LLVMBuildXor(b, y_combine, sign_bit_1, "y_sin");
d2833 10
d2848 1
a2848 1
 * Generate cos(a) using SSE2
d2851 1
a2851 1
lp_build_cos(struct lp_build_context *bld,
d2854 2
a2855 4
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type int_type = lp_int_type(bld->type);
   LLVMBuilderRef b = builder;
a2856 4
   /*
    *  take the absolute value,
    *  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
    */
d2858 8
a2865 197
   LLVMValueRef inv_sig_mask = lp_build_const_int_vec(gallivm, bld->type, ~0x80000000);
   LLVMValueRef a_v4si = LLVMBuildBitCast(b, a, bld->int_vec_type, "a_v4si");

   LLVMValueRef absi = LLVMBuildAnd(b, a_v4si, inv_sig_mask, "absi");
   LLVMValueRef x_abs = LLVMBuildBitCast(b, absi, bld->vec_type, "x_abs");

   /*
    * scale by 4/Pi
    * y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);
    */
   
   LLVMValueRef FOPi = lp_build_const_vec(gallivm, bld->type, 1.27323954473516);
   LLVMValueRef scale_y = LLVMBuildFMul(b, x_abs, FOPi, "scale_y");

   /*
    * store the integer part of y in mm0
    * emm2 = _mm_cvttps_epi32(y);
    */
   
   LLVMValueRef emm2_i = LLVMBuildFPToSI(b, scale_y, bld->int_vec_type, "emm2_i");

   /*
    * j=(j+1) & (~1) (see the cephes sources)
    * emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
    */

   LLVMValueRef all_one = lp_build_const_int_vec(gallivm, bld->type, 1);
   LLVMValueRef emm2_add =  LLVMBuildAdd(b, emm2_i, all_one, "emm2_add");
   /*
    * emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
    */
   LLVMValueRef inv_one = lp_build_const_int_vec(gallivm, bld->type, ~1);
   LLVMValueRef emm2_and =  LLVMBuildAnd(b, emm2_add, inv_one, "emm2_and");

   /*
    * y = _mm_cvtepi32_ps(emm2);
    */
   LLVMValueRef y_2 = LLVMBuildSIToFP(b, emm2_and, bld->vec_type, "y_2");


   /*
    * emm2 = _mm_sub_epi32(emm2, *(v4si*)_pi32_2);
    */
   LLVMValueRef const_2 = lp_build_const_int_vec(gallivm, bld->type, 2);
   LLVMValueRef emm2_2 = LLVMBuildSub(b, emm2_and, const_2, "emm2_2");


   /* get the swap sign flag
    * emm0 = _mm_andnot_si128(emm2, *(v4si*)_pi32_4);
    */
   LLVMValueRef inv = lp_build_const_int_vec(gallivm, bld->type, ~0);
   LLVMValueRef emm0_not = LLVMBuildXor(b, emm2_2, inv, "emm0_not");
   LLVMValueRef pi32_4 = lp_build_const_int_vec(gallivm, bld->type, 4);
   LLVMValueRef emm0_and =  LLVMBuildAnd(b, emm0_not, pi32_4, "emm0_and");
   
   /*
    * emm2 = _mm_slli_epi32(emm0, 29);
    */  
   LLVMValueRef const_29 = lp_build_const_int_vec(gallivm, bld->type, 29);
   LLVMValueRef sign_bit = LLVMBuildShl(b, emm0_and, const_29, "sign_bit");

   /*
    * get the polynom selection mask 
    * there is one polynom for 0 <= x <= Pi/4
    * and another one for Pi/4<x<=Pi/2
    * Both branches will be computed.
    *  
    * emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
    * emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
    */

   LLVMValueRef pi32_2 = lp_build_const_int_vec(gallivm, bld->type, 2);
   LLVMValueRef emm2_3 =  LLVMBuildAnd(b, emm2_2, pi32_2, "emm2_3");
   LLVMValueRef poly_mask = lp_build_compare(gallivm,
                                             int_type, PIPE_FUNC_EQUAL,
   				             emm2_3, lp_build_const_int_vec(gallivm, bld->type, 0));

   /*
    * _PS_CONST(minus_cephes_DP1, -0.78515625);
    * _PS_CONST(minus_cephes_DP2, -2.4187564849853515625e-4);
    * _PS_CONST(minus_cephes_DP3, -3.77489497744594108e-8);
    */
   LLVMValueRef DP1 = lp_build_const_vec(gallivm, bld->type, -0.78515625);
   LLVMValueRef DP2 = lp_build_const_vec(gallivm, bld->type, -2.4187564849853515625e-4);
   LLVMValueRef DP3 = lp_build_const_vec(gallivm, bld->type, -3.77489497744594108e-8);

   /*
    * The magic pass: "Extended precision modular arithmetic" 
    * x = ((x - y * DP1) - y * DP2) - y * DP3; 
    * xmm1 = _mm_mul_ps(y, xmm1);
    * xmm2 = _mm_mul_ps(y, xmm2);
    * xmm3 = _mm_mul_ps(y, xmm3);
    */
   LLVMValueRef xmm1 = LLVMBuildFMul(b, y_2, DP1, "xmm1");
   LLVMValueRef xmm2 = LLVMBuildFMul(b, y_2, DP2, "xmm2");
   LLVMValueRef xmm3 = LLVMBuildFMul(b, y_2, DP3, "xmm3");

   /*
    * x = _mm_add_ps(x, xmm1);
    * x = _mm_add_ps(x, xmm2);
    * x = _mm_add_ps(x, xmm3);
    */ 

   LLVMValueRef x_1 = LLVMBuildFAdd(b, x_abs, xmm1, "x_1");
   LLVMValueRef x_2 = LLVMBuildFAdd(b, x_1, xmm2, "x_2");
   LLVMValueRef x_3 = LLVMBuildFAdd(b, x_2, xmm3, "x_3");

   /*
    * Evaluate the first polynom  (0 <= x <= Pi/4)
    *
    * z = _mm_mul_ps(x,x);
    */
   LLVMValueRef z = LLVMBuildFMul(b, x_3, x_3, "z");

   /*
    * _PS_CONST(coscof_p0,  2.443315711809948E-005);
    * _PS_CONST(coscof_p1, -1.388731625493765E-003);
    * _PS_CONST(coscof_p2,  4.166664568298827E-002);
    */
   LLVMValueRef coscof_p0 = lp_build_const_vec(gallivm, bld->type, 2.443315711809948E-005);
   LLVMValueRef coscof_p1 = lp_build_const_vec(gallivm, bld->type, -1.388731625493765E-003);
   LLVMValueRef coscof_p2 = lp_build_const_vec(gallivm, bld->type, 4.166664568298827E-002);

   /*
    * y = *(v4sf*)_ps_coscof_p0;
    * y = _mm_mul_ps(y, z);
    */
   LLVMValueRef y_3 = LLVMBuildFMul(b, z, coscof_p0, "y_3");
   LLVMValueRef y_4 = LLVMBuildFAdd(b, y_3, coscof_p1, "y_4");
   LLVMValueRef y_5 = LLVMBuildFMul(b, y_4, z, "y_5");
   LLVMValueRef y_6 = LLVMBuildFAdd(b, y_5, coscof_p2, "y_6");
   LLVMValueRef y_7 = LLVMBuildFMul(b, y_6, z, "y_7");
   LLVMValueRef y_8 = LLVMBuildFMul(b, y_7, z, "y_8");


   /*
    * tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
    * y = _mm_sub_ps(y, tmp);
    * y = _mm_add_ps(y, *(v4sf*)_ps_1);
    */ 
   LLVMValueRef half = lp_build_const_vec(gallivm, bld->type, 0.5);
   LLVMValueRef tmp = LLVMBuildFMul(b, z, half, "tmp");
   LLVMValueRef y_9 = LLVMBuildFSub(b, y_8, tmp, "y_8");
   LLVMValueRef one = lp_build_const_vec(gallivm, bld->type, 1.0);
   LLVMValueRef y_10 = LLVMBuildFAdd(b, y_9, one, "y_9");

   /*
    * _PS_CONST(sincof_p0, -1.9515295891E-4);
    * _PS_CONST(sincof_p1,  8.3321608736E-3);
    * _PS_CONST(sincof_p2, -1.6666654611E-1);
    */
   LLVMValueRef sincof_p0 = lp_build_const_vec(gallivm, bld->type, -1.9515295891E-4);
   LLVMValueRef sincof_p1 = lp_build_const_vec(gallivm, bld->type, 8.3321608736E-3);
   LLVMValueRef sincof_p2 = lp_build_const_vec(gallivm, bld->type, -1.6666654611E-1);

   /*
    * Evaluate the second polynom  (Pi/4 <= x <= 0)
    *
    * y2 = *(v4sf*)_ps_sincof_p0;
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_mul_ps(y2, x);
    * y2 = _mm_add_ps(y2, x);
    */

   LLVMValueRef y2_3 = LLVMBuildFMul(b, z, sincof_p0, "y2_3");
   LLVMValueRef y2_4 = LLVMBuildFAdd(b, y2_3, sincof_p1, "y2_4");
   LLVMValueRef y2_5 = LLVMBuildFMul(b, y2_4, z, "y2_5");
   LLVMValueRef y2_6 = LLVMBuildFAdd(b, y2_5, sincof_p2, "y2_6");
   LLVMValueRef y2_7 = LLVMBuildFMul(b, y2_6, z, "y2_7");
   LLVMValueRef y2_8 = LLVMBuildFMul(b, y2_7, x_3, "y2_8");
   LLVMValueRef y2_9 = LLVMBuildFAdd(b, y2_8, x_3, "y2_9");

   /*
    * select the correct result from the two polynoms
    * xmm3 = poly_mask;
    * y2 = _mm_and_ps(xmm3, y2); //, xmm3);
    * y = _mm_andnot_ps(xmm3, y);
    * y = _mm_or_ps(y,y2);
    */
   LLVMValueRef y2_i = LLVMBuildBitCast(b, y2_9, bld->int_vec_type, "y2_i");
   LLVMValueRef y_i = LLVMBuildBitCast(b, y_10, bld->int_vec_type, "y_i");
   LLVMValueRef y2_and = LLVMBuildAnd(b, y2_i, poly_mask, "y2_and");
   LLVMValueRef poly_mask_inv = LLVMBuildNot(b, poly_mask, "poly_mask_inv");
   LLVMValueRef y_and = LLVMBuildAnd(b, y_i, poly_mask_inv, "y_and");
   LLVMValueRef y_combine = LLVMBuildOr(b, y_and, y2_and, "y_combine");

   /*
    * update the sign
    * y = _mm_xor_ps(y, sign_bit);
    */
   LLVMValueRef y_sign = LLVMBuildXor(b, y_combine, sign_bit, "y_sin");
   LLVMValueRef y_result = LLVMBuildBitCast(b, y_sign, bld->vec_type, "y_result");
   return y_result;
d2907 1
d2922 16
d3003 1
a3003 1
   0.999999925063526176901,
d3030 3
a3032 6
void
lp_build_exp2_approx(struct lp_build_context *bld,
                     LLVMValueRef x,
                     LLVMValueRef *p_exp2_int_part,
                     LLVMValueRef *p_frac_part,
                     LLVMValueRef *p_exp2)
a3044 7
   if(p_exp2_int_part || p_frac_part || p_exp2) {
      /* TODO: optimize the constant case */
      if (gallivm_debug & GALLIVM_DEBUG_PERF &&
          LLVMIsConstant(x)) {
         debug_printf("%s: inefficient/imprecise constant arithmetic\n",
                      __FUNCTION__);
      }
d3046 8
a3053 1
      assert(type.floating && type.width == 32);
d3055 5
a3059 2
      x = lp_build_min(bld, x, lp_build_const_vec(bld->gallivm, type,  129.0));
      x = lp_build_max(bld, x, lp_build_const_vec(bld->gallivm, type, -126.99999));
d3061 3
a3063 4
      /* ipart = floor(x) */
      /* fpart = x - ipart */
      lp_build_ifloor_fract(bld, x, &ipart, &fpart);
   }
a3064 8
   if(p_exp2_int_part || p_exp2) {
      /* expipart = (float) (1 << ipart) */
      expipart = LLVMBuildAdd(builder, ipart,
                              lp_build_const_int_vec(bld->gallivm, type, 127), "");
      expipart = LLVMBuildShl(builder, expipart,
                              lp_build_const_int_vec(bld->gallivm, type, 23), "");
      expipart = LLVMBuildBitCast(builder, expipart, vec_type, "");
   }
a3065 3
   if(p_exp2) {
      expfpart = lp_build_polynomial(bld, fpart, lp_build_exp2_polynomial,
                                     Elements(lp_build_exp2_polynomial));
d3067 6
a3072 2
      res = LLVMBuildFMul(builder, expipart, expfpart, "");
   }
a3073 2
   if(p_exp2_int_part)
      *p_exp2_int_part = expipart;
d3075 2
a3076 2
   if(p_frac_part)
      *p_frac_part = fpart;
d3078 1
a3078 3
   if(p_exp2)
      *p_exp2 = res;
}
a3080 6
LLVMValueRef
lp_build_exp2(struct lp_build_context *bld,
              LLVMValueRef x)
{
   LLVMValueRef res;
   lp_build_exp2_approx(bld, x, NULL, NULL, &res);
d3085 1
d3190 11
d3207 2
a3208 1
                     LLVMValueRef *p_log2)
d3281 23
d3319 5
d3329 15
a3343 1
   lp_build_log2_approx(bld, x, NULL, NULL, &res);
d3427 140
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d48 2
d63 1
d65 1
d68 1
a68 1
#define EXP_POLY_DEGREE 3
d70 1
a70 1
#define LOG_POLY_DEGREE 5
a81 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d84 1
d92 7
a98 3
   if(type.width * type.length == 128) {
      if(type.floating) {
         if(type.width == 32 && util_cpu_caps.has_sse)
d100 13
a112 1
         if(type.width == 64 && util_cpu_caps.has_sse2)
d114 23
d138 5
a142 4
      else {
         if(type.width == 8 && !type.sign && util_cpu_caps.has_sse2)
            intrinsic = "llvm.x86.sse2.pminu.b";
         if(type.width == 8 && type.sign && util_cpu_caps.has_sse4_1)
d144 2
a145 1
         if(type.width == 16 && !type.sign && util_cpu_caps.has_sse4_1)
d147 2
a148 3
         if(type.width == 16 && type.sign && util_cpu_caps.has_sse2)
            intrinsic = "llvm.x86.sse2.pmins.w";
         if(type.width == 32 && !type.sign && util_cpu_caps.has_sse4_1)
d150 2
a151 1
         if(type.width == 32 && type.sign && util_cpu_caps.has_sse4_1)
d153 1
d155 27
a183 3
   if(intrinsic)
      return lp_build_intrinsic_binary(builder, intrinsic, lp_build_vec_type(bld->gallivm, bld->type), a, b);

a197 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d200 1
d208 7
a214 3
   if(type.width * type.length == 128) {
      if(type.floating) {
         if(type.width == 32 && util_cpu_caps.has_sse)
d216 13
a228 1
         if(type.width == 64 && util_cpu_caps.has_sse2)
d230 27
d258 2
a259 4
      else {
         if(type.width == 8 && !type.sign && util_cpu_caps.has_sse2)
            intrinsic = "llvm.x86.sse2.pmaxu.b";
         if(type.width == 8 && type.sign && util_cpu_caps.has_sse4_1)
d261 2
a262 1
         if(type.width == 16 && !type.sign && util_cpu_caps.has_sse4_1)
d264 2
a265 3
         if(type.width == 16 && type.sign && util_cpu_caps.has_sse2)
            intrinsic = "llvm.x86.sse2.pmaxs.w";
         if(type.width == 32 && !type.sign && util_cpu_caps.has_sse4_1)
d267 2
a268 1
         if(type.width == 32 && type.sign && util_cpu_caps.has_sse4_1)
d270 1
d272 27
a300 3
   if(intrinsic)
      return lp_build_intrinsic_binary(builder, intrinsic, lp_build_vec_type(bld->gallivm, bld->type), a, b);

d371 13
a383 7
      if(util_cpu_caps.has_sse2 &&
         type.width * type.length == 128 &&
         !type.floating && !type.fixed) {
         if(type.width == 8)
            intrinsic = type.sign ? "llvm.x86.sse2.padds.b" : "llvm.x86.sse2.paddus.b";
         if(type.width == 16)
            intrinsic = type.sign ? "llvm.x86.sse2.padds.w" : "llvm.x86.sse2.paddus.w";
d390 4
d415 3
a417 1
/** Return the scalar sum of the elements of a */
d419 2
a420 2
lp_build_sum_vector(struct lp_build_context *bld,
                    LLVMValueRef a)
d425 4
a428 1
   unsigned i;
d438 33
d472 3
a474 1
   res = LLVMBuildExtractElement(builder, a, index, "");
d476 4
a479 13
   for (i = 1; i < type.length; i++) {
      index = lp_build_const_int32(bld->gallivm, i);
      if (type.floating)
         res = LLVMBuildFAdd(builder, res,
                            LLVMBuildExtractElement(builder,
                                                    a, index, ""),
                            "");
      else
         res = LLVMBuildAdd(builder, res,
                            LLVMBuildExtractElement(builder,
                                                    a, index, ""),
                            "");
   }
d484 139
d652 13
a664 7
      if(util_cpu_caps.has_sse2 &&
         type.width * type.length == 128 &&
         !type.floating && !type.fixed) {
         if(type.width == 8)
            intrinsic = type.sign ? "llvm.x86.sse2.psubs.b" : "llvm.x86.sse2.psubus.b";
         if(type.width == 16)
            intrinsic = type.sign ? "llvm.x86.sse2.psubs.w" : "llvm.x86.sse2.psubus.w";
d671 4
d693 1
d695 4
a698 1
 * Normalized 8bit multiplication.
d706 1
a706 1
 *     which is the fastest method that satisfies the following OpenGL criteria
d722 1
a722 1
 *     must be used
d731 3
a733 1
 *     achieving the exact results
d741 3
a743 3
lp_build_mul_u8n(struct gallivm_state *gallivm,
                 struct lp_type i16_type,
                 LLVMValueRef a, LLVMValueRef b)
d746 3
a748 1
   LLVMValueRef c8;
d751 19
a769 3
   assert(!i16_type.floating);
   assert(lp_check_value(i16_type, a));
   assert(lp_check_value(i16_type, b));
a770 6
   c8 = lp_build_const_int_vec(gallivm, i16_type, 8);
   
#if 0
   
   /* a*b/255 ~= (a*(b + 1)) >> 256 */
   b = LLVMBuildAdd(builder, b, lp_build_const_int_vec(gallium, i16_type, 1), "");
d772 5
d778 7
a784 6
#else
   
   /* ab/255 ~= (ab + (ab >> 8) + 0x80) >> 8 */
   ab = LLVMBuildMul(builder, a, b, "");
   ab = LLVMBuildAdd(builder, ab, LLVMBuildLShr(builder, ab, c8, ""), "");
   ab = LLVMBuildAdd(builder, ab, lp_build_const_int_vec(gallivm, i16_type, 0x80), "");
d786 2
a787 3
#endif
   
   ab = LLVMBuildLShr(builder, ab, c8, "");
a791 1

d819 3
a821 4
   if(!type.floating && !type.fixed && type.norm) {
      if(type.width == 8) {
         struct lp_type i16_type = lp_wider_type(type);
         LLVMValueRef al, ah, bl, bh, abl, abh, ab;
d823 2
a824 2
         lp_build_unpack2(bld->gallivm, type, i16_type, a, &al, &ah);
         lp_build_unpack2(bld->gallivm, type, i16_type, b, &bl, &bh);
d826 3
a828 3
         /* PMULLW, PSRLW, PADDW */
         abl = lp_build_mul_u8n(bld->gallivm, i16_type, al, bl);
         abh = lp_build_mul_u8n(bld->gallivm, i16_type, ah, bh);
d830 1
a830 4
         ab = lp_build_pack2(bld->gallivm, i16_type, type, abl, abh);
         
         return ab;
      }
d832 1
a832 2
      /* FIXME */
      assert(0);
d900 1
a900 1
          * Power of two multiplication by directly manipulating the mantissa.
d959 3
a961 1
   if(util_cpu_caps.has_sse && type.width == 32 && type.length == 4)
d974 4
a977 1
 * Linear interpolation -- without any checks.
d985 2
a986 1
                     LLVMValueRef v1)
d988 1
d999 28
a1026 1
   res = lp_build_mul(bld, x, delta);
d1030 3
a1032 1
   if (bld->type.fixed) {
d1034 2
a1035 2
       * but it will be wrong for other uses. Basically we need a more
       * powerful lp_type, capable of further distinguishing the values
d1037 1
a1037 1
      res = LLVMBuildAnd(builder, res, lp_build_const_int_vec(bld->gallivm, bld->type, (1 << bld->type.width/2) - 1), "");
d1051 2
a1052 1
              LLVMValueRef v1)
a1053 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d1061 2
a1066 1
      LLVMValueRef shift;
a1068 1
      assert(!type.sign);
d1071 2
a1072 2
       * Create a wider type, enough to hold the intermediate result of the
       * multiplication.
d1075 1
a1075 1
      wide_type.fixed  = TRUE;
d1086 1
a1086 1
       * Scale x from [0, 255] to [0, 256]
d1089 1
a1089 6
      shift = lp_build_const_int_vec(bld->gallivm, wide_type, type.width - 1);

      xl = lp_build_add(&wide_bld, xl,
                        LLVMBuildAShr(builder, xl, shift, ""));
      xh = lp_build_add(&wide_bld, xh,
                        LLVMBuildAShr(builder, xh, shift, ""));
d1091 2
a1092 6
      /*
       * Lerp both halves.
       */

      resl = lp_build_lerp_simple(&wide_bld, xl, v0l, v1l);
      resh = lp_build_lerp_simple(&wide_bld, xh, v0h, v1h);
d1096 1
a1096 1
      res = lp_build_lerp_simple(bld, x, v0, v1);
d1103 5
d1115 2
a1116 1
                 LLVMValueRef v11)
d1118 24
a1141 3
   LLVMValueRef v0 = lp_build_lerp(bld, x, v00, v01);
   LLVMValueRef v1 = lp_build_lerp(bld, x, v10, v11);
   return lp_build_lerp(bld, y, v0, v1);
d1163 6
a1168 3
   if(bld->type.norm) {
      if(a == bld->zero || b == bld->zero)
         return bld->zero;
d1200 8
a1207 4
      if(a == bld->zero)
         return b;
      if(b == bld->zero)
         return a;
d1271 6
d1339 2
d1407 2
a1408 3


enum lp_build_round_sse41_mode
d1410 17
a1426 4
   LP_BUILD_ROUND_SSE41_NEAREST = 0,
   LP_BUILD_ROUND_SSE41_FLOOR = 1,
   LP_BUILD_ROUND_SSE41_CEIL = 2,
   LP_BUILD_ROUND_SSE41_TRUNCATE = 3
a1428 1

d1438 1
a1438 1
                     enum lp_build_round_sse41_mode mode)
d1483 16
a1498 1
      assert(type.width*type.length == 128);
d1500 11
a1510 10
      switch(type.width) {
      case 32:
         intrinsic = "llvm.x86.sse41.round.ps";
         break;
      case 64:
         intrinsic = "llvm.x86.sse41.round.pd";
         break;
      default:
         assert(0);
         return bld->undef;
d1559 6
a1564 3
      assert(type.width*type.length == 128);

      intrinsic = "llvm.x86.sse2.cvtps2dq";
d1566 2
d1576 45
d1636 2
a1637 3
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
      return lp_build_round_sse41(bld, a, LP_BUILD_ROUND_SSE41_TRUNCATE);
d1640 31
a1670 6
      LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
      LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
      LLVMValueRef res;
      res = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      res = LLVMBuildSIToFP(builder, res, vec_type, "");
      return res;
d1691 2
a1692 3
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
      return lp_build_round_sse41(bld, a, LP_BUILD_ROUND_SSE41_NEAREST);
d1695 14
a1708 2
      LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
      LLVMValueRef res;
d1711 14
a1724 1
      return res;
d1744 2
a1745 3
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
      return lp_build_round_sse41(bld, a, LP_BUILD_ROUND_SSE41_FLOOR);
d1748 46
a1793 5
      LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
      LLVMValueRef res;
      res = lp_build_ifloor(bld, a);
      res = LLVMBuildSIToFP(builder, res, vec_type, "");
      return res;
d1813 2
a1814 3
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
      return lp_build_round_sse41(bld, a, LP_BUILD_ROUND_SSE41_CEIL);
d1817 42
a1858 5
      LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
      LLVMValueRef res;
      res = lp_build_iceil(bld, a);
      res = LLVMBuildSIToFP(builder, res, vec_type, "");
      return res;
d1877 28
d1943 3
a1945 2
   if (util_cpu_caps.has_sse2 &&
       ((type.width == 32) && (type.length == 1 || type.length == 4))) {
d1948 2
a1949 3
   else if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
      res = lp_build_round_sse41(bld, a, LP_BUILD_ROUND_SSE41_NEAREST);
d1998 20
a2017 6
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
      res = lp_build_round_sse41(bld, a, LP_BUILD_ROUND_SSE41_FLOOR);
   }
   else {
      res = a;
d2019 9
a2027 27
      if (type.sign) {
         /* Take the sign bit and add it to 1 constant */
         LLVMTypeRef vec_type = bld->vec_type;
         unsigned mantissa = lp_mantissa(type);
         LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type,
                                  (unsigned long long)1 << (type.width - 1));
         LLVMValueRef sign;
         LLVMValueRef offset;

         /* sign = a < 0 ? ~0 : 0 */
         sign = LLVMBuildBitCast(builder, a, int_vec_type, "");
         sign = LLVMBuildAnd(builder, sign, mask, "");
         sign = LLVMBuildAShr(builder, sign,
                              lp_build_const_int_vec(bld->gallivm, type,
                                                     type.width - 1),
                              "ifloor.sign");

         /* offset = -0.99999(9)f */
         offset = lp_build_const_vec(bld->gallivm, type,
                                     -(double)(((unsigned long long)1 << mantissa) - 10)/((unsigned long long)1 << mantissa));
         offset = LLVMConstBitCast(offset, int_vec_type);

         /* offset = a < 0 ? offset : 0.0f */
         offset = LLVMBuildAnd(builder, offset, sign, "");
         offset = LLVMBuildBitCast(builder, offset, vec_type, "ifloor.offset");

         res = LLVMBuildFAdd(builder, res, offset, "ifloor.res");
d2055 2
a2056 3
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
      res = lp_build_round_sse41(bld, a, LP_BUILD_ROUND_SSE41_CEIL);
d2059 14
a2072 3
      LLVMTypeRef vec_type = bld->vec_type;
      unsigned mantissa = lp_mantissa(type);
      LLVMValueRef offset;
d2074 9
a2082 25
      /* offset = 0.99999(9)f */
      offset = lp_build_const_vec(bld->gallivm, type,
                                  (double)(((unsigned long long)1 << mantissa) - 10)/((unsigned long long)1 << mantissa));

      if (type.sign) {
         LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type,
                                (unsigned long long)1 << (type.width - 1));
         LLVMValueRef sign;

         /* sign = a < 0 ? 0 : ~0 */
         sign = LLVMBuildBitCast(builder, a, int_vec_type, "");
         sign = LLVMBuildAnd(builder, sign, mask, "");
         sign = LLVMBuildAShr(builder, sign,
                              lp_build_const_int_vec(bld->gallivm, type,
                                                     type.width - 1),
                              "iceil.sign");
         sign = LLVMBuildNot(builder, sign, "iceil.not");

         /* offset = a < 0 ? 0.0 : offset */
         offset = LLVMConstBitCast(offset, int_vec_type);
         offset = LLVMBuildAnd(builder, offset, sign, "");
         offset = LLVMBuildBitCast(builder, offset, vec_type, "iceil.offset");
      }

      res = LLVMBuildFAdd(builder, a, offset, "iceil.res");
d2096 1
a2096 1
 * stratergy (floor() vs ifloor()) that results in less redundant work is used.
d2111 1
a2111 2
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
d2132 15
a2158 1
   /* TODO: optimize the constant case */
d2161 6
a2166 1
   util_snprintf(intrinsic, sizeof intrinsic, "llvm.sqrt.v%uf%u", type.length, type.width);
d2230 1
a2230 1
    *   depedent
d2237 2
a2238 1
   if (FALSE && util_cpu_caps.has_sse && type.width == 32 && type.length == 4) {
d2242 8
d2251 1
a2251 1
      res = lp_build_intrinsic_unary(builder, "llvm.x86.sse.rcp.ps", bld->vec_type, a);
d2269 1
a2269 2
 * See also:
 * - http://softwarecommunity.intel.com/articles/eng/1818.htm
d2292 2
a2293 1
 * Generate 1/sqrt(a)
d2306 5
a2310 2
   if (util_cpu_caps.has_sse && type.width == 32 && type.length == 4) {
      const unsigned num_iterations = 0;
d2314 2
a2315 1
      res = lp_build_intrinsic_unary(builder, "llvm.x86.sse.rsqrt.ps", bld->vec_type, a);
d2317 28
a2344 2
      for (i = 0; i < num_iterations; ++i) {
         res = lp_build_rsqrt_refine(bld, a, res);
d2353 11
d2365 5
a2369 6
static inline LLVMValueRef
lp_build_const_v4si(struct gallivm_state *gallivm, unsigned long value)
{
   LLVMValueRef element = lp_build_const_int32(gallivm, value);
   LLVMValueRef elements[4] = { element, element, element, element };
   return LLVMConstVector(elements, 4);
d2372 10
a2381 2
static inline LLVMValueRef
lp_build_const_v4sf(struct gallivm_state *gallivm, float value)
d2383 20
a2402 3
   LLVMValueRef element = lp_build_const_float(gallivm, value);
   LLVMValueRef elements[4] = { element, element, element, element };
   return LLVMConstVector(elements, 4);
a2412 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d2414 1
a2416 2
   LLVMTypeRef v4sf = LLVMVectorType(LLVMFloatTypeInContext(bld->gallivm->context), 4);
   LLVMTypeRef v4si = LLVMVectorType(LLVMInt32TypeInContext(bld->gallivm->context), 4);
d2423 2
a2424 2
   LLVMValueRef inv_sig_mask = lp_build_const_v4si(bld->gallivm, ~0x80000000);
   LLVMValueRef a_v4si = LLVMBuildBitCast(b, a, v4si, "a_v4si");
d2427 1
a2427 1
   LLVMValueRef x_abs = LLVMBuildBitCast(b, absi, v4sf, "x_abs");
d2433 1
a2433 1
   LLVMValueRef sig_mask = lp_build_const_v4si(bld->gallivm, 0x80000000);
d2441 1
a2441 1
   LLVMValueRef FOPi = lp_build_const_v4sf(gallivm, 1.27323954473516);
d2449 1
a2449 1
   LLVMValueRef emm2_i = LLVMBuildFPToSI(b, scale_y, v4si, "emm2_i");
d2456 1
a2456 1
   LLVMValueRef all_one = lp_build_const_v4si(bld->gallivm, 1);
d2461 1
a2461 1
   LLVMValueRef inv_one = lp_build_const_v4si(bld->gallivm, ~1);
d2467 1
a2467 1
   LLVMValueRef y_2 = LLVMBuildSIToFP(b, emm2_and, v4sf, "y_2");
d2472 1
a2472 1
   LLVMValueRef pi32_4 = lp_build_const_v4si(bld->gallivm, 4);
d2478 1
a2478 1
   LLVMValueRef const_29 = lp_build_const_v4si(bld->gallivm, 29);
d2491 1
a2491 1
   LLVMValueRef pi32_2 = lp_build_const_v4si(bld->gallivm, 2);
d2493 1
a2493 1
   LLVMValueRef poly_mask = lp_build_compare(bld->gallivm,
d2495 1
a2495 1
                                             emm2_3, lp_build_const_v4si(bld->gallivm, 0));
d2506 3
a2508 3
   LLVMValueRef DP1 = lp_build_const_v4sf(gallivm, -0.78515625);
   LLVMValueRef DP2 = lp_build_const_v4sf(gallivm, -2.4187564849853515625e-4);
   LLVMValueRef DP3 = lp_build_const_v4sf(gallivm, -3.77489497744594108e-8);
d2543 3
a2545 3
   LLVMValueRef coscof_p0 = lp_build_const_v4sf(gallivm, 2.443315711809948E-005);
   LLVMValueRef coscof_p1 = lp_build_const_v4sf(gallivm, -1.388731625493765E-003);
   LLVMValueRef coscof_p2 = lp_build_const_v4sf(gallivm, 4.166664568298827E-002);
d2564 1
a2564 1
   LLVMValueRef half = lp_build_const_v4sf(gallivm, 0.5);
d2567 1
a2567 1
   LLVMValueRef one = lp_build_const_v4sf(gallivm, 1.0);
d2575 3
a2577 3
   LLVMValueRef sincof_p0 = lp_build_const_v4sf(gallivm, -1.9515295891E-4);
   LLVMValueRef sincof_p1 = lp_build_const_v4sf(gallivm, 8.3321608736E-3);
   LLVMValueRef sincof_p2 = lp_build_const_v4sf(gallivm, -1.6666654611E-1);
d2605 1
a2605 1
    * y = _mm_add_ps(y,y2);
d2607 2
a2608 2
   LLVMValueRef y2_i = LLVMBuildBitCast(b, y2_9, v4si, "y2_i");
   LLVMValueRef y_i = LLVMBuildBitCast(b, y_10, v4si, "y_i");
d2610 1
a2610 2
   LLVMValueRef inv = lp_build_const_v4si(bld->gallivm, ~0);
   LLVMValueRef poly_mask_inv = LLVMBuildXor(b, poly_mask, inv, "poly_mask_inv");
d2612 1
a2612 1
   LLVMValueRef y_combine = LLVMBuildAdd(b, y_and, y2_and, "y_combine");
d2619 1
a2619 1
   LLVMValueRef y_result = LLVMBuildBitCast(b, y_sign, v4sf, "y_result");
a2630 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d2632 1
a2634 2
   LLVMTypeRef v4sf = LLVMVectorType(LLVMFloatTypeInContext(bld->gallivm->context), 4);
   LLVMTypeRef v4si = LLVMVectorType(LLVMInt32TypeInContext(bld->gallivm->context), 4);
d2641 2
a2642 2
   LLVMValueRef inv_sig_mask = lp_build_const_v4si(bld->gallivm, ~0x80000000);
   LLVMValueRef a_v4si = LLVMBuildBitCast(b, a, v4si, "a_v4si");
d2645 1
a2645 1
   LLVMValueRef x_abs = LLVMBuildBitCast(b, absi, v4sf, "x_abs");
d2652 1
a2652 1
   LLVMValueRef FOPi = lp_build_const_v4sf(gallivm, 1.27323954473516);
d2660 1
a2660 1
   LLVMValueRef emm2_i = LLVMBuildFPToSI(b, scale_y, v4si, "emm2_i");
d2667 1
a2667 1
   LLVMValueRef all_one = lp_build_const_v4si(bld->gallivm, 1);
d2672 1
a2672 1
   LLVMValueRef inv_one = lp_build_const_v4si(bld->gallivm, ~1);
d2678 1
a2678 1
   LLVMValueRef y_2 = LLVMBuildSIToFP(b, emm2_and, v4sf, "y_2");
d2684 1
a2684 1
   LLVMValueRef const_2 = lp_build_const_v4si(bld->gallivm, 2);
d2691 1
a2691 1
   LLVMValueRef inv = lp_build_const_v4si(bld->gallivm, ~0);
d2693 1
a2693 1
   LLVMValueRef pi32_4 = lp_build_const_v4si(bld->gallivm, 4);
d2699 1
a2699 1
   LLVMValueRef const_29 = lp_build_const_v4si(bld->gallivm, 29);
d2712 1
a2712 1
   LLVMValueRef pi32_2 = lp_build_const_v4si(bld->gallivm, 2);
d2714 1
a2714 1
   LLVMValueRef poly_mask = lp_build_compare(bld->gallivm,
d2716 1
a2716 1
   				             emm2_3, lp_build_const_v4si(bld->gallivm, 0));
d2723 3
a2725 3
   LLVMValueRef DP1 = lp_build_const_v4sf(gallivm, -0.78515625);
   LLVMValueRef DP2 = lp_build_const_v4sf(gallivm, -2.4187564849853515625e-4);
   LLVMValueRef DP3 = lp_build_const_v4sf(gallivm, -3.77489497744594108e-8);
d2760 3
a2762 3
   LLVMValueRef coscof_p0 = lp_build_const_v4sf(gallivm, 2.443315711809948E-005);
   LLVMValueRef coscof_p1 = lp_build_const_v4sf(gallivm, -1.388731625493765E-003);
   LLVMValueRef coscof_p2 = lp_build_const_v4sf(gallivm, 4.166664568298827E-002);
d2781 1
a2781 1
   LLVMValueRef half = lp_build_const_v4sf(gallivm, 0.5);
d2784 1
a2784 1
   LLVMValueRef one = lp_build_const_v4sf(gallivm, 1.0);
d2792 3
a2794 3
   LLVMValueRef sincof_p0 = lp_build_const_v4sf(gallivm, -1.9515295891E-4);
   LLVMValueRef sincof_p1 = lp_build_const_v4sf(gallivm, 8.3321608736E-3);
   LLVMValueRef sincof_p2 = lp_build_const_v4sf(gallivm, -1.6666654611E-1);
d2822 1
a2822 1
    * y = _mm_add_ps(y,y2);
d2824 2
a2825 2
   LLVMValueRef y2_i = LLVMBuildBitCast(b, y2_9, v4si, "y2_i");
   LLVMValueRef y_i = LLVMBuildBitCast(b, y_10, v4si, "y_i");
d2827 1
a2827 1
   LLVMValueRef poly_mask_inv = LLVMBuildXor(b, poly_mask, inv, "poly_mask_inv");
d2829 1
a2829 1
   LLVMValueRef y_combine = LLVMBuildAdd(b, y_and, y2_and, "y_combine");
d2836 1
a2836 1
   LLVMValueRef y_result = LLVMBuildBitCast(b, y_sign, v4sf, "y_result");
d2873 1
a2873 1
   return lp_build_mul(bld, log2e, lp_build_exp2(bld, x));
d2890 1
a2890 1
   return lp_build_mul(bld, log2, lp_build_exp2(bld, x));
d2898 1
a2898 1
static LLVMValueRef
d2905 2
a2906 1
   LLVMValueRef res = NULL;
d2918 8
d2931 11
a2941 4
      if(res)
         res = lp_build_add(bld, coeff, lp_build_mul(bld, x, res));
      else
         res = coeff;
d2944 4
a2947 2
   if(res)
      return res;
d2958 6
a2963 6
   0.999999999690134838155,
   0.583974334321735217258,
   0.164553105719676828492,
   0.0292811063701710962255,
   0.00354944426657875141846,
   0.000296253726543423377365
d2965 5
a2969 5
   1.00000001502262084505,
   0.563586057338685991394,
   0.150436017652442413623,
   0.0243220604213317927308,
   0.0025359088446580436489
a2994 1
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
a3016 2
      ipart = lp_build_floor(bld, x);

d3018 1
a3018 1
      fpart = LLVMBuildFSub(builder, x, ipart, "");
a3022 1
      ipart = LLVMBuildFPToSI(builder, ipart, int_vec_type, "");
d3130 1
a3130 1
 * Minimax polynomial fit of log2(x)/(x - 1), for x in range [1, 2[
d3135 7
a3141 13
#if LOG_POLY_DEGREE == 6
   3.11578814719469302614,
   -3.32419399085241980044,
   2.59883907202499966007,
   -1.23152682416275988241,
   0.318212422185251071475,
   -0.0344359067839062357313
#elif LOG_POLY_DEGREE == 5
   2.8882704548164776201,
   -2.52074962577807006663,
   1.48116647521213171641,
   -0.465725644288844778798,
   0.0596515482674574969533
d3143 5
a3147 4
   2.61761038894603480148,
   -1.75647175389045657003,
   0.688243882994381274313,
   -0.107254423828329604454
d3149 4
a3152 3
   2.28330284476918490682,
   -1.04913055217340124191,
   0.204446009836232697516
a3157 1

d3160 2
d3180 2
d3200 6
d3219 1
a3219 1
      /* mant = (float) mantissa(x) */
d3224 11
a3234 1
      logmant = lp_build_polynomial(bld, mant, lp_build_log2_polynomial,
d3237 2
a3238 2
      /* This effectively increases the polynomial degree by one, but ensures that log2(1) == 0*/
      logmant = LLVMBuildFMul(builder, logmant, LLVMBuildFSub(builder, mant, bld->one, ""), "");
d3240 1
a3240 1
      res = LLVMBuildFAdd(builder, logmant, logexp, "");
d3324 21
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d3 1
a3 1
 * Copyright 2009 VMware, Inc.
d56 1
d64 5
d78 1
d83 3
d112 1
a112 1
      return lp_build_intrinsic_binary(bld->builder, intrinsic, lp_build_vec_type(bld->type), a, b);
d128 1
d133 3
d162 1
a162 1
      return lp_build_intrinsic_binary(bld->builder, intrinsic, lp_build_vec_type(bld->type), a, b);
d176 1
d179 2
d190 1
a190 1
         return LLVMBuildNot(bld->builder, a, "");
d194 4
a197 1
      return LLVMConstSub(bld->one, a);
d199 4
a202 1
      return LLVMBuildSub(bld->builder, bld->one, a, "");
d214 1
d218 3
d244 1
a244 1
         return lp_build_intrinsic_binary(bld->builder, intrinsic, lp_build_vec_type(bld->type), a, b);
d248 4
a251 1
      res = LLVMConstAdd(a, b);
d253 4
a256 1
      res = LLVMBuildAdd(bld->builder, a, b, "");
d268 39
d315 1
d319 3
d345 1
a345 1
         return lp_build_intrinsic_binary(bld->builder, intrinsic, lp_build_vec_type(bld->type), a, b);
d349 4
a352 1
      res = LLVMConstSub(a, b);
d354 4
a357 1
      res = LLVMBuildSub(bld->builder, a, b, "");
d408 1
a408 1
lp_build_mul_u8n(LLVMBuilderRef builder,
d412 1
d416 5
a420 1
   c8 = lp_build_int_const_scalar(i16_type, 8);
d425 1
a425 1
   b = LLVMBuildAdd(builder, b, lp_build_int_const_scalar(i16_type, 1), "");
d433 1
a433 1
   ab = LLVMBuildAdd(builder, ab, lp_build_int_const_scalar(i16_type, 0x80), "");
d451 1
d456 3
d475 2
a476 2
         lp_build_unpack2(bld->builder, type, i16_type, a, &al, &ah);
         lp_build_unpack2(bld->builder, type, i16_type, b, &bl, &bh);
d479 2
a480 2
         abl = lp_build_mul_u8n(bld->builder, i16_type, al, bl);
         abh = lp_build_mul_u8n(bld->builder, i16_type, ah, bh);
d482 1
a482 1
         ab = lp_build_pack2(bld->builder, i16_type, type, abl, abh);
d492 1
a492 1
      shift = lp_build_int_const_scalar(type, type.width/2);
d497 4
a500 1
      res =  LLVMConstMul(a, b);
d509 4
a512 1
      res = LLVMBuildMul(bld->builder, a, b, "");
d515 1
a515 1
            res = LLVMBuildAShr(bld->builder, res, shift, "");
d517 1
a517 1
            res = LLVMBuildLShr(bld->builder, res, shift, "");
d533 1
d536 2
d545 1
a545 1
      return LLVMBuildNeg(bld->builder, a, "");
d550 1
a550 1
   if(util_is_pot(b)) {
d563 4
a566 4
         factor = lp_build_int_const_scalar(bld->type, (unsigned long long)shift << mantissa);
         a = LLVMBuildBitCast(bld->builder, a, lp_build_int_vec_type(bld->type), "");
         a = LLVMBuildAdd(bld->builder, a, factor, "");
         a = LLVMBuildBitCast(bld->builder, a, lp_build_vec_type(bld->type), "");
d571 2
a572 2
         factor = lp_build_const_scalar(bld->type, shift);
         return LLVMBuildShl(bld->builder, a, factor, "");
d576 1
a576 1
   factor = lp_build_const_scalar(bld->type, (double)b);
d589 1
d592 3
d606 8
a613 2
   if(LLVMIsConstant(a) && LLVMIsConstant(b))
      return LLVMConstFDiv(a, b);
d618 6
a623 1
   return LLVMBuildFDiv(bld->builder, a, b, "");
d628 1
a628 3
 * Linear interpolation.
 *
 * This also works for integer values with a few caveats.
d632 5
a636 5
LLVMValueRef
lp_build_lerp(struct lp_build_context *bld,
              LLVMValueRef x,
              LLVMValueRef v0,
              LLVMValueRef v1)
d638 1
d642 4
d652 1
a652 1
   if(bld->type.fixed)
d657 70
a726 1
      res = LLVMBuildAnd(bld->builder, res, lp_build_int_const_scalar(bld->type, (1 << bld->type.width/2) - 1), "");
d756 3
d787 3
d819 4
d836 1
d838 3
a840 1
   LLVMTypeRef vec_type = lp_build_vec_type(type);
d847 1
a847 1
      LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
d849 4
a852 4
      LLVMValueRef mask = lp_build_int_const_scalar(type, ((unsigned long long) absMask));
      a = LLVMBuildBitCast(bld->builder, a, int_vec_type, "");
      a = LLVMBuildAnd(bld->builder, a, mask, "");
      a = LLVMBuildBitCast(bld->builder, a, vec_type, "");
d859 1
a859 1
         return lp_build_intrinsic_unary(bld->builder, "llvm.x86.ssse3.pabs.b.128", vec_type, a);
d861 1
a861 1
         return lp_build_intrinsic_unary(bld->builder, "llvm.x86.ssse3.pabs.w.128", vec_type, a);
d863 1
a863 1
         return lp_build_intrinsic_unary(bld->builder, "llvm.x86.ssse3.pabs.d.128", vec_type, a);
d867 1
a867 1
   return lp_build_max(bld, a, LLVMBuildNeg(bld->builder, a, ""));
d875 12
a886 1
   return LLVMBuildNeg(bld->builder, a, "");
d890 1
d895 1
a896 1
   LLVMTypeRef vec_type = lp_build_vec_type(type);
d900 2
d908 3
a910 3
      /* Take the sign bit and add it to 1 constant */
      LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
      LLVMValueRef mask = lp_build_int_const_scalar(type, (unsigned long long)1 << (type.width - 1));
d913 12
a924 5
      sign = LLVMBuildBitCast(bld->builder, a, int_vec_type, "");
      sign = LLVMBuildAnd(bld->builder, sign, mask, "");
      one = LLVMConstBitCast(bld->one, int_vec_type);
      res = LLVMBuildOr(bld->builder, sign, one, "");
      res = LLVMBuildBitCast(bld->builder, res, vec_type, "");
d928 1
a928 1
      LLVMValueRef minus_one = lp_build_const_scalar(type, -1.0);
d935 1
a935 1
   res = lp_build_select(bld, cond, bld->zero, bld->one);
d951 1
d953 4
a956 4
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
   LLVMTypeRef vec_type = lp_build_vec_type(type);
   LLVMValueRef shift = lp_build_int_const_scalar(type, type.width - 1);
   LLVMValueRef mask = lp_build_int_const_scalar(type,
d961 1
d964 1
a964 1
   val = LLVMBuildBitCast(bld->builder, a, int_vec_type, "");
d966 1
a966 1
   val = LLVMBuildAnd(bld->builder, val, mask, "");
d968 1
a968 1
   sign = LLVMBuildShl(bld->builder, sign, shift, "");
d970 1
a970 1
   res = LLVMBuildOr(bld->builder, val, sign, "");
d972 1
a972 1
   res = LLVMBuildBitCast(bld->builder, res, vec_type, "");
d979 1
a979 1
 * Convert vector of int to vector of float.
d985 1
d987 1
a989 1
   /*assert(lp_check_value(type, a));*/
d991 1
a991 7
   {
      LLVMTypeRef vec_type = lp_build_vec_type(type);
      /*LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);*/
      LLVMValueRef res;
      res = LLVMBuildSIToFP(bld->builder, a, vec_type, "");
      return res;
   }
d1005 6
d1016 1
d1018 1
a1018 1
   LLVMTypeRef vec_type = lp_build_vec_type(type);
d1020 1
d1023 1
a1023 1
   assert(type.width*type.length == 128);
d1027 98
a1124 10
   switch(type.width) {
   case 32:
      intrinsic = "llvm.x86.sse41.round.ps";
      break;
   case 64:
      intrinsic = "llvm.x86.sse41.round.pd";
      break;
   default:
      assert(0);
      return bld->undef;
d1127 1
a1127 2
   return lp_build_intrinsic_binary(bld->builder, intrinsic, vec_type, a,
                                    LLVMConstInt(LLVMInt32Type(), mode, 0));
d1131 5
d1140 1
d1146 2
a1147 1
   if(util_cpu_caps.has_sse4_1)
d1149 1
d1151 2
a1152 2
      LLVMTypeRef vec_type = lp_build_vec_type(type);
      LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
d1154 2
a1155 2
      res = LLVMBuildFPToSI(bld->builder, a, int_vec_type, "");
      res = LLVMBuildSIToFP(bld->builder, res, vec_type, "");
d1161 6
d1171 1
d1177 2
a1178 1
   if(util_cpu_caps.has_sse4_1)
d1180 1
d1182 1
a1182 1
      LLVMTypeRef vec_type = lp_build_vec_type(type);
d1185 1
a1185 1
      res = LLVMBuildSIToFP(bld->builder, res, vec_type, "");
d1191 5
d1200 1
d1204 1
d1206 2
a1207 1
   if(util_cpu_caps.has_sse4_1)
d1209 1
d1211 1
a1211 1
      LLVMTypeRef vec_type = lp_build_vec_type(type);
d1214 1
a1214 1
      res = LLVMBuildSIToFP(bld->builder, res, vec_type, "");
d1220 5
d1229 1
d1235 2
a1236 1
   if(util_cpu_caps.has_sse4_1)
d1238 1
d1240 1
a1240 1
      LLVMTypeRef vec_type = lp_build_vec_type(type);
d1243 1
a1243 1
      res = LLVMBuildSIToFP(bld->builder, res, vec_type, "");
d1250 1
a1250 1
 * Return fractional part of 'a' computed as a - floor(f)
d1263 3
a1265 2
 * Convert to integer, through whichever rounding method that's fastest,
 * typically truncating toward zero.
d1271 1
d1273 1
a1273 1
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
d1278 1
a1278 1
   return LLVMBuildFPToSI(bld->builder, a, int_vec_type, "");
d1282 6
d1292 1
d1294 1
a1294 1
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
d1298 1
d1301 6
a1306 1
   if(util_cpu_caps.has_sse4_1) {
a1309 3
      LLVMTypeRef vec_type = lp_build_vec_type(type);
      LLVMValueRef mask = lp_build_int_const_scalar(type, (unsigned long long)1 << (type.width - 1));
      LLVMValueRef sign;
d1312 1
a1312 3
      /* get sign bit */
      sign = LLVMBuildBitCast(bld->builder, a, int_vec_type, "");
      sign = LLVMBuildAnd(bld->builder, sign, mask, "");
d1314 15
a1328 5
      /* sign * 0.5 */
      half = lp_build_const_scalar(type, 0.5);
      half = LLVMBuildBitCast(bld->builder, half, int_vec_type, "");
      half = LLVMBuildOr(bld->builder, sign, half, "");
      half = LLVMBuildBitCast(bld->builder, half, vec_type, "");
d1330 1
a1330 1
      res = LLVMBuildAdd(bld->builder, a, half, "");
d1333 1
a1333 1
   res = LLVMBuildFPToSI(bld->builder, res, int_vec_type, "");
d1340 3
a1342 1
 * Convert float[] to int[] with floor().
d1348 1
d1350 1
a1350 1
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
d1356 2
a1357 1
   if(util_cpu_caps.has_sse4_1) {
d1361 1
a1361 6
      /* Take the sign bit and add it to 1 constant */
      LLVMTypeRef vec_type = lp_build_vec_type(type);
      unsigned mantissa = lp_mantissa(type);
      LLVMValueRef mask = lp_build_int_const_scalar(type, (unsigned long long)1 << (type.width - 1));
      LLVMValueRef sign;
      LLVMValueRef offset;
d1363 25
a1387 14
      /* sign = a < 0 ? ~0 : 0 */
      sign = LLVMBuildBitCast(bld->builder, a, int_vec_type, "");
      sign = LLVMBuildAnd(bld->builder, sign, mask, "");
      sign = LLVMBuildAShr(bld->builder, sign, lp_build_int_const_scalar(type, type.width - 1), "");
      lp_build_name(sign, "floor.sign");

      /* offset = -0.99999(9)f */
      offset = lp_build_const_scalar(type, -(double)(((unsigned long long)1 << mantissa) - 1)/((unsigned long long)1 << mantissa));
      offset = LLVMConstBitCast(offset, int_vec_type);

      /* offset = a < 0 ? -0.99999(9)f : 0.0f */
      offset = LLVMBuildAnd(bld->builder, offset, sign, "");
      offset = LLVMBuildBitCast(bld->builder, offset, vec_type, "");
      lp_build_name(offset, "floor.offset");
d1389 2
a1390 2
      res = LLVMBuildAdd(bld->builder, a, offset, "");
      lp_build_name(res, "floor.res");
d1393 2
a1394 2
   res = LLVMBuildFPToSI(bld->builder, res, int_vec_type, "");
   lp_build_name(res, "floor");
d1400 5
d1409 1
d1411 1
a1411 1
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
d1417 2
a1418 1
   if(util_cpu_caps.has_sse4_1) {
d1422 29
a1450 2
      assert(0);
      res = bld->undef;
d1453 2
a1454 1
   res = LLVMBuildFPToSI(bld->builder, res, int_vec_type, "");
d1460 41
d1505 1
d1507 1
a1507 1
   LLVMTypeRef vec_type = lp_build_vec_type(type);
d1510 2
d1518 32
a1549 1
   return lp_build_intrinsic_unary(bld->builder, intrinsic, vec_type, a);
d1557 1
d1560 2
d1574 54
a1627 3
   if(util_cpu_caps.has_sse && type.width == 32 && type.length == 4)
      /* FIXME: improve precision */
      return lp_build_intrinsic_unary(bld->builder, "llvm.x86.sse.rcp.ps", lp_build_vec_type(type), a);
d1629 1
a1629 1
   return LLVMBuildFDiv(bld->builder, bld->one, a, "");
d1640 1
d1643 2
d1647 13
a1659 2
   if(util_cpu_caps.has_sse && type.width == 32 && type.length == 4)
      return lp_build_intrinsic_unary(bld->builder, "llvm.x86.sse.rsqrt.ps", lp_build_vec_type(type), a);
d1665 17
d1683 1
a1683 1
 * Generate cos(a)
d1686 2
a1687 2
lp_build_cos(struct lp_build_context *bld,
              LLVMValueRef a)
d1689 32
a1720 3
   const struct lp_type type = bld->type;
   LLVMTypeRef vec_type = lp_build_vec_type(type);
   char intrinsic[32];
d1722 6
a1727 1
   /* TODO: optimize the constant case */
d1729 171
a1899 4
   assert(type.floating);
   util_snprintf(intrinsic, sizeof intrinsic, "llvm.cos.v%uf%u", type.length, type.width);

   return lp_build_intrinsic_unary(bld->builder, intrinsic, vec_type, a);
d1904 1
a1904 1
 * Generate sin(a)
d1907 2
a1908 2
lp_build_sin(struct lp_build_context *bld,
              LLVMValueRef a)
d1910 25
a1934 3
   const struct lp_type type = bld->type;
   LLVMTypeRef vec_type = lp_build_vec_type(type);
   char intrinsic[32];
d1936 6
a1941 1
   /* TODO: optimize the constant case */
d1943 176
a2118 4
   assert(type.floating);
   util_snprintf(intrinsic, sizeof intrinsic, "llvm.sin.v%uf%u", type.length, type.width);

   return lp_build_intrinsic_unary(bld->builder, intrinsic, vec_type, a);
d2131 2
a2132 1
   if(LLVMIsConstant(x) && LLVMIsConstant(y))
d2135 1
d2149 4
a2152 1
   LLVMValueRef log2e = lp_build_const_scalar(bld->type, 1.4426950408889634);
d2166 4
a2169 1
   LLVMValueRef log2 = lp_build_const_scalar(bld->type, 0.69314718055994529);
a2174 4
#define EXP_POLY_DEGREE 3
#define LOG_POLY_DEGREE 5


d2189 2
d2192 2
a2193 1
   if(LLVMIsConstant(x))
d2196 1
d2199 4
a2202 1
      LLVMValueRef coeff = lp_build_const_scalar(type, coeffs[i]);
d2217 1
a2217 1
 * Minimax polynomial fit of 2**x, in range [-0.5, 0.5[
d2221 6
a2226 1
   9.9999994e-1, 6.9315308e-1, 2.4015361e-1, 5.5826318e-2, 8.9893397e-3, 1.8775767e-3
d2228 5
a2232 1
   1.0000026, 6.9300383e-1, 2.4144275e-1, 5.2011464e-2, 1.3534167e-2
d2234 4
a2237 1
   9.9992520e-1, 6.9583356e-1, 2.2606716e-1, 7.8024521e-2
d2239 3
a2241 1
   1.0017247, 6.5763628e-1, 3.3718944e-1
d2255 1
d2257 2
a2258 2
   LLVMTypeRef vec_type = lp_build_vec_type(type);
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
d2265 2
d2269 2
a2270 1
      if(LLVMIsConstant(x))
d2273 1
d2277 2
a2278 2
      x = lp_build_min(bld, x, lp_build_const_scalar(type,  129.0));
      x = lp_build_max(bld, x, lp_build_const_scalar(type, -126.99999));
d2280 2
a2281 3
      /* ipart = int(x - 0.5) */
      ipart = LLVMBuildSub(bld->builder, x, lp_build_const_scalar(type, 0.5f), "");
      ipart = LLVMBuildFPToSI(bld->builder, ipart, int_vec_type, "");
d2284 1
a2284 2
      fpart = LLVMBuildSIToFP(bld->builder, ipart, vec_type, "");
      fpart = LLVMBuildSub(bld->builder, x, fpart, "");
d2289 6
a2294 3
      expipart = LLVMBuildAdd(bld->builder, ipart, lp_build_int_const_scalar(type, 127), "");
      expipart = LLVMBuildShl(bld->builder, expipart, lp_build_int_const_scalar(type, 23), "");
      expipart = LLVMBuildBitCast(bld->builder, expipart, vec_type, "");
d2301 1
a2301 1
      res = LLVMBuildMul(bld->builder, expipart, expfpart, "");
d2326 71
d2403 6
a2408 1
   3.11578814719469302614, -3.32419399085241980044, 2.59883907202499966007, -1.23152682416275988241, 0.318212422185251071475, -0.0344359067839062357313
d2410 5
a2414 1
   2.8882704548164776201, -2.52074962577807006663, 1.48116647521213171641, -0.465725644288844778798, 0.0596515482674574969533
d2416 4
a2419 1
   2.61761038894603480148, -1.75647175389045657003, 0.688243882994381274313, -0.107254423828329604454
d2421 3
a2423 1
   2.28330284476918490682, -1.04913055217340124191, 0.204446009836232697516
d2440 1
d2442 2
a2443 2
   LLVMTypeRef vec_type = lp_build_vec_type(type);
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(type);
d2445 2
a2446 2
   LLVMValueRef expmask = lp_build_int_const_scalar(type, 0x7f800000);
   LLVMValueRef mantmask = lp_build_int_const_scalar(type, 0x007fffff);
d2456 2
d2460 2
a2461 1
      if(LLVMIsConstant(x))
d2464 1
d2468 1
a2468 1
      i = LLVMBuildBitCast(bld->builder, x, int_vec_type, "");
d2471 1
a2471 1
      exp = LLVMBuildAnd(bld->builder, i, expmask, "");
d2475 3
a2477 3
      logexp = LLVMBuildLShr(bld->builder, exp, lp_build_int_const_scalar(type, 23), "");
      logexp = LLVMBuildSub(bld->builder, logexp, lp_build_int_const_scalar(type, 127), "");
      logexp = LLVMBuildSIToFP(bld->builder, logexp, vec_type, "");
d2482 3
a2484 3
      mant = LLVMBuildAnd(bld->builder, i, mantmask, "");
      mant = LLVMBuildOr(bld->builder, mant, one, "");
      mant = LLVMBuildBitCast(bld->builder, mant, vec_type, "");
d2490 1
a2490 1
      logmant = LLVMBuildMul(bld->builder, logmant, LLVMBuildSub(bld->builder, mant, bld->one, ""), "");
d2492 1
a2492 1
      res = LLVMBuildAdd(bld->builder, logmant, logexp, "");
d2495 2
a2496 1
   if(p_exp)
d2498 1
d2515 61
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Copyright 2009-2010 VMware, Inc.
a55 1
#include "lp_bld_init.h"
a62 5
#define EXP_POLY_DEGREE 3

#define LOG_POLY_DEGREE 5


a71 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a75 3
   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

d102 1
a102 1
      return lp_build_intrinsic_binary(builder, intrinsic, lp_build_vec_type(bld->gallivm, bld->type), a, b);
a117 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a121 3
   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

d148 1
a148 1
      return lp_build_intrinsic_binary(builder, intrinsic, lp_build_vec_type(bld->gallivm, bld->type), a, b);
a161 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a163 2
   assert(lp_check_value(type, a));

d173 1
a173 1
         return LLVMBuildNot(builder, a, "");
d177 1
a177 4
      if (type.floating)
          return LLVMConstFSub(bld->one, a);
      else
          return LLVMConstSub(bld->one, a);
d179 1
a179 4
      if (type.floating)
         return LLVMBuildFSub(builder, bld->one, a, "");
      else
         return LLVMBuildSub(builder, bld->one, a, "");
a190 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a193 3
   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

d217 1
a217 1
         return lp_build_intrinsic_binary(builder, intrinsic, lp_build_vec_type(bld->gallivm, bld->type), a, b);
d221 1
a221 4
      if (type.floating)
         res = LLVMConstFAdd(a, b);
      else
         res = LLVMConstAdd(a, b);
d223 1
a223 4
      if (type.floating)
         res = LLVMBuildFAdd(builder, a, b, "");
      else
         res = LLVMBuildAdd(builder, a, b, "");
a234 39
/** Return the scalar sum of the elements of a */
LLVMValueRef
lp_build_sum_vector(struct lp_build_context *bld,
                    LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef index, res;
   unsigned i;

   assert(lp_check_value(type, a));

   if (type.length == 1) {
      return a;
   }

   assert(!bld->type.norm);

   index = lp_build_const_int32(bld->gallivm, 0);
   res = LLVMBuildExtractElement(builder, a, index, "");

   for (i = 1; i < type.length; i++) {
      index = lp_build_const_int32(bld->gallivm, i);
      if (type.floating)
         res = LLVMBuildFAdd(builder, res,
                            LLVMBuildExtractElement(builder,
                                                    a, index, ""),
                            "");
      else
         res = LLVMBuildAdd(builder, res,
                            LLVMBuildExtractElement(builder,
                                                    a, index, ""),
                            "");
   }

   return res;
}


a242 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a245 3
   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

d269 1
a269 1
         return lp_build_intrinsic_binary(builder, intrinsic, lp_build_vec_type(bld->gallivm, bld->type), a, b);
d273 1
a273 4
      if (type.floating)
         res = LLVMConstFSub(a, b);
      else
         res = LLVMConstSub(a, b);
d275 1
a275 4
      if (type.floating)
         res = LLVMBuildFSub(builder, a, b, "");
      else
         res = LLVMBuildSub(builder, a, b, "");
d326 1
a326 1
lp_build_mul_u8n(struct gallivm_state *gallivm,
a329 1
   LLVMBuilderRef builder = gallivm->builder;
d333 1
a333 5
   assert(!i16_type.floating);
   assert(lp_check_value(i16_type, a));
   assert(lp_check_value(i16_type, b));

   c8 = lp_build_const_int_vec(gallivm, i16_type, 8);
d338 1
a338 1
   b = LLVMBuildAdd(builder, b, lp_build_const_int_vec(gallium, i16_type, 1), "");
d346 1
a346 1
   ab = LLVMBuildAdd(builder, ab, lp_build_const_int_vec(gallivm, i16_type, 0x80), "");
a363 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a367 3
   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

d384 2
a385 2
         lp_build_unpack2(bld->gallivm, type, i16_type, a, &al, &ah);
         lp_build_unpack2(bld->gallivm, type, i16_type, b, &bl, &bh);
d388 2
a389 2
         abl = lp_build_mul_u8n(bld->gallivm, i16_type, al, bl);
         abh = lp_build_mul_u8n(bld->gallivm, i16_type, ah, bh);
d391 1
a391 1
         ab = lp_build_pack2(bld->gallivm, i16_type, type, abl, abh);
d401 1
a401 1
      shift = lp_build_const_int_vec(bld->gallivm, type, type.width/2);
d406 1
a406 4
      if (type.floating)
         res = LLVMConstFMul(a, b);
      else
         res = LLVMConstMul(a, b);
d415 1
a415 4
      if (type.floating)
         res = LLVMBuildFMul(builder, a, b, "");
      else
         res = LLVMBuildMul(builder, a, b, "");
d418 1
a418 1
            res = LLVMBuildAShr(builder, res, shift, "");
d420 1
a420 1
            res = LLVMBuildLShr(builder, res, shift, "");
a435 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a437 2
   assert(lp_check_value(bld->type, a));

d445 1
a445 1
      return lp_build_negate(bld, a);
d450 1
a450 1
   if(util_is_power_of_two(b)) {
d463 4
a466 4
         factor = lp_build_const_int_vec(bld->gallivm, bld->type, (unsigned long long)shift << mantissa);
         a = LLVMBuildBitCast(builder, a, lp_build_int_vec_type(bld->type), "");
         a = LLVMBuildAdd(builder, a, factor, "");
         a = LLVMBuildBitCast(builder, a, lp_build_vec_type(bld->gallivm, bld->type), "");
d471 2
a472 2
         factor = lp_build_const_vec(bld->gallivm, bld->type, shift);
         return LLVMBuildShl(builder, a, factor, "");
d476 1
a476 1
   factor = lp_build_const_vec(bld->gallivm, bld->type, (double)b);
a488 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a490 3
   assert(lp_check_value(type, a));
   assert(lp_check_value(type, b));

d502 2
a503 8
   if(LLVMIsConstant(a) && LLVMIsConstant(b)) {
      if (type.floating)
         return LLVMConstFDiv(a, b);
      else if (type.sign)
         return LLVMConstSDiv(a, b);
      else
         return LLVMConstUDiv(a, b);
   }
d508 1
a508 6
   if (type.floating)
      return LLVMBuildFDiv(builder, a, b, "");
   else if (type.sign)
      return LLVMBuildSDiv(builder, a, b, "");
   else
      return LLVMBuildUDiv(builder, a, b, "");
d513 3
a515 1
 * Linear interpolation -- without any checks.
d519 5
a523 5
static INLINE LLVMValueRef
lp_build_lerp_simple(struct lp_build_context *bld,
                     LLVMValueRef x,
                     LLVMValueRef v0,
                     LLVMValueRef v1)
a524 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a527 4
   assert(lp_check_value(bld->type, x));
   assert(lp_check_value(bld->type, v0));
   assert(lp_check_value(bld->type, v1));

d534 1
a534 1
   if (bld->type.fixed) {
d539 1
a539 70
      res = LLVMBuildAnd(builder, res, lp_build_const_int_vec(bld->gallivm, bld->type, (1 << bld->type.width/2) - 1), "");
   }

   return res;
}


/**
 * Linear interpolation.
 */
LLVMValueRef
lp_build_lerp(struct lp_build_context *bld,
              LLVMValueRef x,
              LLVMValueRef v0,
              LLVMValueRef v1)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef res;

   assert(lp_check_value(type, x));
   assert(lp_check_value(type, v0));
   assert(lp_check_value(type, v1));

   if (type.norm) {
      struct lp_type wide_type;
      struct lp_build_context wide_bld;
      LLVMValueRef xl, xh, v0l, v0h, v1l, v1h, resl, resh;
      LLVMValueRef shift;

      assert(type.length >= 2);
      assert(!type.sign);

      /*
       * Create a wider type, enough to hold the intermediate result of the
       * multiplication.
       */
      memset(&wide_type, 0, sizeof wide_type);
      wide_type.fixed  = TRUE;
      wide_type.width  = type.width*2;
      wide_type.length = type.length/2;

      lp_build_context_init(&wide_bld, bld->gallivm, wide_type);

      lp_build_unpack2(bld->gallivm, type, wide_type, x,  &xl,  &xh);
      lp_build_unpack2(bld->gallivm, type, wide_type, v0, &v0l, &v0h);
      lp_build_unpack2(bld->gallivm, type, wide_type, v1, &v1l, &v1h);

      /*
       * Scale x from [0, 255] to [0, 256]
       */

      shift = lp_build_const_int_vec(bld->gallivm, wide_type, type.width - 1);

      xl = lp_build_add(&wide_bld, xl,
                        LLVMBuildAShr(builder, xl, shift, ""));
      xh = lp_build_add(&wide_bld, xh,
                        LLVMBuildAShr(builder, xh, shift, ""));

      /*
       * Lerp both halves.
       */

      resl = lp_build_lerp_simple(&wide_bld, xl, v0l, v1l);
      resh = lp_build_lerp_simple(&wide_bld, xh, v0h, v1h);

      res = lp_build_pack2(bld->gallivm, wide_type, type, resl, resh);
   } else {
      res = lp_build_lerp_simple(bld, x, v0, v1);
   }
a568 3
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, b));

a596 3
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, b));

a625 4
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, min));
   assert(lp_check_value(bld->type, max));

a638 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d640 1
a640 3
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);

   assert(lp_check_value(type, a));
d647 1
a647 1
      LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
d649 4
a652 4
      LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type, ((unsigned long long) absMask));
      a = LLVMBuildBitCast(builder, a, int_vec_type, "");
      a = LLVMBuildAnd(builder, a, mask, "");
      a = LLVMBuildBitCast(builder, a, vec_type, "");
d659 1
a659 1
         return lp_build_intrinsic_unary(builder, "llvm.x86.ssse3.pabs.b.128", vec_type, a);
d661 1
a661 1
         return lp_build_intrinsic_unary(builder, "llvm.x86.ssse3.pabs.w.128", vec_type, a);
d663 1
a663 1
         return lp_build_intrinsic_unary(builder, "llvm.x86.ssse3.pabs.d.128", vec_type, a);
d667 1
a667 1
   return lp_build_max(bld, a, LLVMBuildNeg(builder, a, ""));
d675 1
a675 12
   LLVMBuilderRef builder = bld->gallivm->builder;

   assert(lp_check_value(bld->type, a));

#if HAVE_LLVM >= 0x0207
   if (bld->type.floating)
      a = LLVMBuildFNeg(builder, a, "");
   else
#endif
      a = LLVMBuildNeg(builder, a, "");

   return a;
a678 1
/** Return -1, 0 or +1 depending on the sign of a */
a682 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d684 1
a687 2
   assert(lp_check_value(type, a));

d694 3
a696 3
      LLVMTypeRef vec_type;
      LLVMTypeRef int_type;
      LLVMValueRef mask;
d699 5
a703 12
      unsigned long long maskBit = (unsigned long long)1 << (type.width - 1);

      int_type = lp_build_int_vec_type(bld->gallivm, type);
      vec_type = lp_build_vec_type(bld->gallivm, type);
      mask = lp_build_const_int_vec(bld->gallivm, type, maskBit);

      /* Take the sign bit and add it to 1 constant */
      sign = LLVMBuildBitCast(builder, a, int_type, "");
      sign = LLVMBuildAnd(builder, sign, mask, "");
      one = LLVMConstBitCast(bld->one, int_type);
      res = LLVMBuildOr(builder, sign, one, "");
      res = LLVMBuildBitCast(builder, res, vec_type, "");
d707 1
a707 1
      LLVMValueRef minus_one = lp_build_const_vec(bld->gallivm, type, -1.0);
d714 1
a714 1
   res = lp_build_select(bld, cond, bld->zero, res);
a729 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d731 4
a734 4
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
   LLVMValueRef shift = lp_build_const_int_vec(bld->gallivm, type, type.width - 1);
   LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type,
a738 1
   assert(lp_check_value(type, a));
d741 1
a741 1
   val = LLVMBuildBitCast(builder, a, int_vec_type, "");
d743 1
a743 1
   val = LLVMBuildAnd(builder, val, mask, "");
d745 1
a745 1
   sign = LLVMBuildShl(builder, sign, shift, "");
d747 1
a747 1
   res = LLVMBuildOr(builder, val, sign, "");
d749 1
a749 1
   res = LLVMBuildBitCast(builder, res, vec_type, "");
d756 1
a756 1
 * Convert vector of (or scalar) int to vector of (or scalar) float.
a761 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a762 1
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
d765 1
d767 7
a773 1
   return LLVMBuildSIToFP(builder, a, vec_type, "");
a786 6
/**
 * Helper for SSE4.1's ROUNDxx instructions.
 *
 * NOTE: In the SSE4.1's nearest mode, if two values are equally close, the
 * result is the even value.  That is, rounding 2.5 will be 2.0, and not 3.0.
 */
a791 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d793 1
a793 1
   LLVMTypeRef i32t = LLVMInt32TypeInContext(bld->gallivm->context);
a794 1
   LLVMValueRef res;
d797 1
a797 1

d801 10
a810 49
   if (type.length == 1) {
      LLVMTypeRef vec_type;
      LLVMValueRef undef;
      LLVMValueRef args[3];
      LLVMValueRef index0 = LLVMConstInt(i32t, 0, 0);

      switch(type.width) {
      case 32:
         intrinsic = "llvm.x86.sse41.round.ss";
         break;
      case 64:
         intrinsic = "llvm.x86.sse41.round.sd";
         break;
      default:
         assert(0);
         return bld->undef;
      }

      vec_type = LLVMVectorType(bld->elem_type, 4);

      undef = LLVMGetUndef(vec_type);

      args[0] = undef;
      args[1] = LLVMBuildInsertElement(builder, undef, a, index0, "");
      args[2] = LLVMConstInt(i32t, mode, 0);

      res = lp_build_intrinsic(builder, intrinsic,
                               vec_type, args, Elements(args));

      res = LLVMBuildExtractElement(builder, res, index0, "");
   }
   else {
      assert(type.width*type.length == 128);

      switch(type.width) {
      case 32:
         intrinsic = "llvm.x86.sse41.round.ps";
         break;
      case 64:
         intrinsic = "llvm.x86.sse41.round.pd";
         break;
      default:
         assert(0);
         return bld->undef;
      }

      res = lp_build_intrinsic_binary(builder, intrinsic,
                                      bld->vec_type, a,
                                      LLVMConstInt(i32t, mode, 0));
d813 2
a814 1
   return res;
a817 54
static INLINE LLVMValueRef
lp_build_iround_nearest_sse2(struct lp_build_context *bld,
                             LLVMValueRef a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMTypeRef i32t = LLVMInt32TypeInContext(bld->gallivm->context);
   LLVMTypeRef ret_type = lp_build_int_vec_type(bld->gallivm, type);
   const char *intrinsic;
   LLVMValueRef res;

   assert(type.floating);
   /* using the double precision conversions is a bit more complicated */
   assert(type.width == 32);

   assert(lp_check_value(type, a));
   assert(util_cpu_caps.has_sse2);

   /* This is relying on MXCSR rounding mode, which should always be nearest. */
   if (type.length == 1) {
      LLVMTypeRef vec_type;
      LLVMValueRef undef;
      LLVMValueRef arg;
      LLVMValueRef index0 = LLVMConstInt(i32t, 0, 0);

      vec_type = LLVMVectorType(bld->elem_type, 4);

      intrinsic = "llvm.x86.sse.cvtss2si";

      undef = LLVMGetUndef(vec_type);

      arg = LLVMBuildInsertElement(builder, undef, a, index0, "");

      res = lp_build_intrinsic_unary(builder, intrinsic,
                                     ret_type, arg);
   }
   else {
      assert(type.width*type.length == 128);

      intrinsic = "llvm.x86.sse2.cvtps2dq";

      res = lp_build_intrinsic_unary(builder, intrinsic,
                                     ret_type, a);
   }

   return res;
}


/**
 * Return the integer part of a float (vector) value (== round toward zero).
 * The returned value is a float (vector).
 * Ex: trunc(-1.5) = -1.0
 */
a821 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d827 1
a827 2
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
a828 1
   }
d830 2
a831 2
      LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
      LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
d833 2
a834 2
      res = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      res = LLVMBuildSIToFP(builder, res, vec_type, "");
a839 6
/**
 * Return float (vector) rounded to nearest integer (vector).  The returned
 * value is a float (vector).
 * Ex: round(0.9) = 1.0
 * Ex: round(-1.5) = -2.0
 */
a843 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d849 1
a849 2
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
a850 1
   }
d852 1
a852 1
      LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
d855 1
a855 1
      res = LLVMBuildSIToFP(builder, res, vec_type, "");
a860 5
/**
 * Return floor of float (vector), result is a float (vector)
 * Ex: floor(1.1) = 1.0
 * Ex: floor(-1.1) = -2.0
 */
a864 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a867 1
   assert(lp_check_value(type, a));
d869 1
a869 2
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
a870 1
   }
d872 1
a872 1
      LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
d875 1
a875 1
      res = LLVMBuildSIToFP(builder, res, vec_type, "");
a880 5
/**
 * Return ceiling of float (vector), returning float (vector).
 * Ex: ceil( 1.1) = 2.0
 * Ex: ceil(-1.1) = -1.0
 */
a884 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d890 1
a890 2
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
a891 1
   }
d893 1
a893 1
      LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
d896 1
a896 1
      res = LLVMBuildSIToFP(builder, res, vec_type, "");
d903 1
a903 1
 * Return fractional part of 'a' computed as a - floor(a)
d916 2
a917 3
 * Return the integer part of a float (vector) value (== round toward zero).
 * The returned value is an integer (vector).
 * Ex: itrunc(-1.5) = -1
a922 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d924 1
a924 1
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
d929 1
a929 1
   return LLVMBuildFPToSI(builder, a, int_vec_type, "");
a932 6
/**
 * Return float (vector) rounded to nearest integer (vector).  The returned
 * value is an integer (vector).
 * Ex: iround(0.9) = 1
 * Ex: iround(-1.5) = -2
 */
a936 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d938 1
a938 1
   LLVMTypeRef int_vec_type = bld->int_vec_type;
a941 1

d944 1
a944 6
   if (util_cpu_caps.has_sse2 &&
       ((type.width == 32) && (type.length == 1 || type.length == 4))) {
      return lp_build_iround_nearest_sse2(bld, a);
   }
   else if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
d948 3
d953 3
a955 1
      half = lp_build_const_vec(bld->gallivm, type, 0.5);
d957 5
a961 15
      if (type.sign) {
         LLVMTypeRef vec_type = bld->vec_type;
         LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type,
                                    (unsigned long long)1 << (type.width - 1));
         LLVMValueRef sign;

         /* get sign bit */
         sign = LLVMBuildBitCast(builder, a, int_vec_type, "");
         sign = LLVMBuildAnd(builder, sign, mask, "");

         /* sign * 0.5 */
         half = LLVMBuildBitCast(builder, half, int_vec_type, "");
         half = LLVMBuildOr(builder, sign, half, "");
         half = LLVMBuildBitCast(builder, half, vec_type, "");
      }
d963 1
a963 1
      res = LLVMBuildFAdd(builder, a, half, "");
d966 1
a966 1
   res = LLVMBuildFPToSI(builder, res, int_vec_type, "");
d973 1
a973 3
 * Return floor of float (vector), result is an int (vector)
 * Ex: ifloor(1.1) = 1.0
 * Ex: ifloor(-1.1) = -2.0
a978 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d980 1
a980 1
   LLVMTypeRef int_vec_type = bld->int_vec_type;
d986 1
a986 2
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
d990 6
a995 1
      res = a;
d997 14
a1010 25
      if (type.sign) {
         /* Take the sign bit and add it to 1 constant */
         LLVMTypeRef vec_type = bld->vec_type;
         unsigned mantissa = lp_mantissa(type);
         LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type,
                                  (unsigned long long)1 << (type.width - 1));
         LLVMValueRef sign;
         LLVMValueRef offset;

         /* sign = a < 0 ? ~0 : 0 */
         sign = LLVMBuildBitCast(builder, a, int_vec_type, "");
         sign = LLVMBuildAnd(builder, sign, mask, "");
         sign = LLVMBuildAShr(builder, sign,
                              lp_build_const_int_vec(bld->gallivm, type,
                                                     type.width - 1),
                              "ifloor.sign");

         /* offset = -0.99999(9)f */
         offset = lp_build_const_vec(bld->gallivm, type,
                                     -(double)(((unsigned long long)1 << mantissa) - 10)/((unsigned long long)1 << mantissa));
         offset = LLVMConstBitCast(offset, int_vec_type);

         /* offset = a < 0 ? offset : 0.0f */
         offset = LLVMBuildAnd(builder, offset, sign, "");
         offset = LLVMBuildBitCast(builder, offset, vec_type, "ifloor.offset");
d1012 2
a1013 2
         res = LLVMBuildFAdd(builder, res, offset, "ifloor.res");
      }
d1016 2
a1017 2
   /* round to nearest (toward zero) */
   res = LLVMBuildFPToSI(builder, res, int_vec_type, "ifloor.res");
a1022 5
/**
 * Return ceiling of float (vector), returning int (vector).
 * Ex: iceil( 1.1) = 2
 * Ex: iceil(-1.1) = -1
 */
a1026 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d1028 1
a1028 1
   LLVMTypeRef int_vec_type = bld->int_vec_type;
d1034 1
a1034 2
   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
d1038 2
a1039 29
      LLVMTypeRef vec_type = bld->vec_type;
      unsigned mantissa = lp_mantissa(type);
      LLVMValueRef offset;

      /* offset = 0.99999(9)f */
      offset = lp_build_const_vec(bld->gallivm, type,
                                  (double)(((unsigned long long)1 << mantissa) - 10)/((unsigned long long)1 << mantissa));

      if (type.sign) {
         LLVMValueRef mask = lp_build_const_int_vec(bld->gallivm, type,
                                (unsigned long long)1 << (type.width - 1));
         LLVMValueRef sign;

         /* sign = a < 0 ? 0 : ~0 */
         sign = LLVMBuildBitCast(builder, a, int_vec_type, "");
         sign = LLVMBuildAnd(builder, sign, mask, "");
         sign = LLVMBuildAShr(builder, sign,
                              lp_build_const_int_vec(bld->gallivm, type,
                                                     type.width - 1),
                              "iceil.sign");
         sign = LLVMBuildNot(builder, sign, "iceil.not");

         /* offset = a < 0 ? 0.0 : offset */
         offset = LLVMConstBitCast(offset, int_vec_type);
         offset = LLVMBuildAnd(builder, offset, sign, "");
         offset = LLVMBuildBitCast(builder, offset, vec_type, "iceil.offset");
      }

      res = LLVMBuildFAdd(builder, a, offset, "iceil.res");
d1042 1
a1042 2
   /* round to nearest (toward zero) */
   res = LLVMBuildFPToSI(builder, res, int_vec_type, "iceil.res");
a1047 41
/**
 * Combined ifloor() & fract().
 *
 * Preferred to calling the functions separately, as it will ensure that the
 * stratergy (floor() vs ifloor()) that results in less redundant work is used.
 */
void
lp_build_ifloor_fract(struct lp_build_context *bld,
                      LLVMValueRef a,
                      LLVMValueRef *out_ipart,
                      LLVMValueRef *out_fpart)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   LLVMValueRef ipart;

   assert(type.floating);
   assert(lp_check_value(type, a));

   if (util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) {
      /*
       * floor() is easier.
       */

      ipart = lp_build_floor(bld, a);
      *out_fpart = LLVMBuildFSub(builder, a, ipart, "fpart");
      *out_ipart = LLVMBuildFPToSI(builder, ipart, bld->int_vec_type, "ipart");
   }
   else {
      /*
       * ifloor() is easier.
       */

      *out_ipart = lp_build_ifloor(bld, a);
      ipart = LLVMBuildSIToFP(builder, *out_ipart, bld->vec_type, "ipart");
      *out_fpart = LLVMBuildFSub(builder, a, ipart, "fpart");
   }
}


a1051 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d1053 1
a1053 1
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
a1055 2
   assert(lp_check_value(type, a));

d1062 1
a1062 32
   return lp_build_intrinsic_unary(builder, intrinsic, vec_type, a);
}


/**
 * Do one Newton-Raphson step to improve reciprocate precision:
 *
 *   x_{i+1} = x_i * (2 - a * x_i)
 *
 * XXX: Unfortunately this won't give IEEE-754 conformant results for 0 or
 * +/-Inf, giving NaN instead.  Certain applications rely on this behavior,
 * such as Google Earth, which does RCP(RSQRT(0.0) when drawing the Earth's
 * halo. It would be necessary to clamp the argument to prevent this.
 *
 * See also:
 * - http://en.wikipedia.org/wiki/Division_(digital)#Newton.E2.80.93Raphson_division
 * - http://softwarecommunity.intel.com/articles/eng/1818.htm
 */
static INLINE LLVMValueRef
lp_build_rcp_refine(struct lp_build_context *bld,
                    LLVMValueRef a,
                    LLVMValueRef rcp_a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef two = lp_build_const_vec(bld->gallivm, bld->type, 2.0);
   LLVMValueRef res;

   res = LLVMBuildFMul(builder, a, rcp_a, "");
   res = LLVMBuildFSub(builder, two, res, "");
   res = LLVMBuildFMul(builder, rcp_a, res, "");

   return res;
a1069 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a1071 2
   assert(lp_check_value(type, a));

d1084 3
a1086 26
   /*
    * We don't use RCPPS because:
    * - it only has 10bits of precision
    * - it doesn't even get the reciprocate of 1.0 exactly
    * - doing Newton-Rapshon steps yields wrong (NaN) values for 0.0 or Inf
    * - for recent processors the benefit over DIVPS is marginal, a case
    *   depedent
    *
    * We could still use it on certain processors if benchmarks show that the
    * RCPPS plus necessary workarounds are still preferrable to DIVPS; or for
    * particular uses that require less workarounds.
    */

   if (FALSE && util_cpu_caps.has_sse && type.width == 32 && type.length == 4) {
      const unsigned num_iterations = 0;
      LLVMValueRef res;
      unsigned i;

      res = lp_build_intrinsic_unary(builder, "llvm.x86.sse.rcp.ps", bld->vec_type, a);

      for (i = 0; i < num_iterations; ++i) {
         res = lp_build_rcp_refine(bld, a, res);
      }

      return res;
   }
d1088 1
a1088 29
   return LLVMBuildFDiv(builder, bld->one, a, "");
}


/**
 * Do one Newton-Raphson step to improve rsqrt precision:
 *
 *   x_{i+1} = 0.5 * x_i * (3.0 - a * x_i * x_i)
 *
 * See also:
 * - http://softwarecommunity.intel.com/articles/eng/1818.htm
 */
static INLINE LLVMValueRef
lp_build_rsqrt_refine(struct lp_build_context *bld,
                      LLVMValueRef a,
                      LLVMValueRef rsqrt_a)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef half = lp_build_const_vec(bld->gallivm, bld->type, 0.5);
   LLVMValueRef three = lp_build_const_vec(bld->gallivm, bld->type, 3.0);
   LLVMValueRef res;

   res = LLVMBuildFMul(builder, rsqrt_a, rsqrt_a, "");
   res = LLVMBuildFMul(builder, a, res, "");
   res = LLVMBuildFSub(builder, three, res, "");
   res = LLVMBuildFMul(builder, rsqrt_a, res, "");
   res = LLVMBuildFMul(builder, half, res, "");

   return res;
a1098 1
   LLVMBuilderRef builder = bld->gallivm->builder;
a1100 2
   assert(lp_check_value(type, a));

d1103 2
a1104 13
   if (util_cpu_caps.has_sse && type.width == 32 && type.length == 4) {
      const unsigned num_iterations = 0;
      LLVMValueRef res;
      unsigned i;

      res = lp_build_intrinsic_unary(builder, "llvm.x86.sse.rsqrt.ps", bld->vec_type, a);

      for (i = 0; i < num_iterations; ++i) {
         res = lp_build_rsqrt_refine(bld, a, res);
      }

      return res;
   }
a1109 17
static inline LLVMValueRef
lp_build_const_v4si(struct gallivm_state *gallivm, unsigned long value)
{
   LLVMValueRef element = lp_build_const_int32(gallivm, value);
   LLVMValueRef elements[4] = { element, element, element, element };
   return LLVMConstVector(elements, 4);
}

static inline LLVMValueRef
lp_build_const_v4sf(struct gallivm_state *gallivm, float value)
{
   LLVMValueRef element = lp_build_const_float(gallivm, value);
   LLVMValueRef elements[4] = { element, element, element, element };
   return LLVMConstVector(elements, 4);
}


d1111 1
a1111 1
 * Generate sin(a) using SSE2
d1114 2
a1115 2
lp_build_sin(struct lp_build_context *bld,
             LLVMValueRef a)
d1117 5
a1121 32
   LLVMBuilderRef builder = bld->gallivm->builder;
   struct gallivm_state *gallivm = bld->gallivm;
   struct lp_type int_type = lp_int_type(bld->type);
   LLVMBuilderRef b = builder;
   LLVMTypeRef v4sf = LLVMVectorType(LLVMFloatTypeInContext(bld->gallivm->context), 4);
   LLVMTypeRef v4si = LLVMVectorType(LLVMInt32TypeInContext(bld->gallivm->context), 4);

   /*
    *  take the absolute value,
    *  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
    */

   LLVMValueRef inv_sig_mask = lp_build_const_v4si(bld->gallivm, ~0x80000000);
   LLVMValueRef a_v4si = LLVMBuildBitCast(b, a, v4si, "a_v4si");

   LLVMValueRef absi = LLVMBuildAnd(b, a_v4si, inv_sig_mask, "absi");
   LLVMValueRef x_abs = LLVMBuildBitCast(b, absi, v4sf, "x_abs");

   /*
    * extract the sign bit (upper one)
    * sign_bit = _mm_and_ps(sign_bit, *(v4sf*)_ps_sign_mask);
    */
   LLVMValueRef sig_mask = lp_build_const_v4si(bld->gallivm, 0x80000000);
   LLVMValueRef sign_bit_i = LLVMBuildAnd(b, a_v4si, sig_mask, "sign_bit_i");

   /*
    * scale by 4/Pi
    * y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);
    */
   
   LLVMValueRef FOPi = lp_build_const_v4sf(gallivm, 1.27323954473516);
   LLVMValueRef scale_y = LLVMBuildFMul(b, x_abs, FOPi, "scale_y");
d1123 2
a1124 6
   /*
    * store the integer part of y in mm0
    * emm2 = _mm_cvttps_epi32(y);
    */
   
   LLVMValueRef emm2_i = LLVMBuildFPToSI(b, scale_y, v4si, "emm2_i");
d1126 1
a1126 171
   /*
    * j=(j+1) & (~1) (see the cephes sources)
    * emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
    */

   LLVMValueRef all_one = lp_build_const_v4si(bld->gallivm, 1);
   LLVMValueRef emm2_add =  LLVMBuildAdd(b, emm2_i, all_one, "emm2_add");
   /*
    * emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
    */
   LLVMValueRef inv_one = lp_build_const_v4si(bld->gallivm, ~1);
   LLVMValueRef emm2_and =  LLVMBuildAnd(b, emm2_add, inv_one, "emm2_and");

   /*
    * y = _mm_cvtepi32_ps(emm2);
    */
   LLVMValueRef y_2 = LLVMBuildSIToFP(b, emm2_and, v4sf, "y_2");

   /* get the swap sign flag
    * emm0 = _mm_and_si128(emm2, *(v4si*)_pi32_4);
    */
   LLVMValueRef pi32_4 = lp_build_const_v4si(bld->gallivm, 4);
   LLVMValueRef emm0_and =  LLVMBuildAnd(b, emm2_add, pi32_4, "emm0_and");
   
   /*
    * emm2 = _mm_slli_epi32(emm0, 29);
    */  
   LLVMValueRef const_29 = lp_build_const_v4si(bld->gallivm, 29);
   LLVMValueRef swap_sign_bit = LLVMBuildShl(b, emm0_and, const_29, "swap_sign_bit");

   /*
    * get the polynom selection mask 
    * there is one polynom for 0 <= x <= Pi/4
    * and another one for Pi/4<x<=Pi/2
    * Both branches will be computed.
    *  
    * emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
    * emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
    */

   LLVMValueRef pi32_2 = lp_build_const_v4si(bld->gallivm, 2);
   LLVMValueRef emm2_3 =  LLVMBuildAnd(b, emm2_and, pi32_2, "emm2_3");
   LLVMValueRef poly_mask = lp_build_compare(bld->gallivm,
                                             int_type, PIPE_FUNC_EQUAL,
                                             emm2_3, lp_build_const_v4si(bld->gallivm, 0));
   /*
    *   sign_bit = _mm_xor_ps(sign_bit, swap_sign_bit);
    */
   LLVMValueRef sign_bit_1 =  LLVMBuildXor(b, sign_bit_i, swap_sign_bit, "sign_bit");

   /*
    * _PS_CONST(minus_cephes_DP1, -0.78515625);
    * _PS_CONST(minus_cephes_DP2, -2.4187564849853515625e-4);
    * _PS_CONST(minus_cephes_DP3, -3.77489497744594108e-8);
    */
   LLVMValueRef DP1 = lp_build_const_v4sf(gallivm, -0.78515625);
   LLVMValueRef DP2 = lp_build_const_v4sf(gallivm, -2.4187564849853515625e-4);
   LLVMValueRef DP3 = lp_build_const_v4sf(gallivm, -3.77489497744594108e-8);

   /*
    * The magic pass: "Extended precision modular arithmetic" 
    * x = ((x - y * DP1) - y * DP2) - y * DP3; 
    * xmm1 = _mm_mul_ps(y, xmm1);
    * xmm2 = _mm_mul_ps(y, xmm2);
    * xmm3 = _mm_mul_ps(y, xmm3);
    */
   LLVMValueRef xmm1 = LLVMBuildFMul(b, y_2, DP1, "xmm1");
   LLVMValueRef xmm2 = LLVMBuildFMul(b, y_2, DP2, "xmm2");
   LLVMValueRef xmm3 = LLVMBuildFMul(b, y_2, DP3, "xmm3");

   /*
    * x = _mm_add_ps(x, xmm1);
    * x = _mm_add_ps(x, xmm2);
    * x = _mm_add_ps(x, xmm3);
    */ 

   LLVMValueRef x_1 = LLVMBuildFAdd(b, x_abs, xmm1, "x_1");
   LLVMValueRef x_2 = LLVMBuildFAdd(b, x_1, xmm2, "x_2");
   LLVMValueRef x_3 = LLVMBuildFAdd(b, x_2, xmm3, "x_3");

   /*
    * Evaluate the first polynom  (0 <= x <= Pi/4)
    *
    * z = _mm_mul_ps(x,x);
    */
   LLVMValueRef z = LLVMBuildFMul(b, x_3, x_3, "z");

   /*
    * _PS_CONST(coscof_p0,  2.443315711809948E-005);
    * _PS_CONST(coscof_p1, -1.388731625493765E-003);
    * _PS_CONST(coscof_p2,  4.166664568298827E-002);
    */
   LLVMValueRef coscof_p0 = lp_build_const_v4sf(gallivm, 2.443315711809948E-005);
   LLVMValueRef coscof_p1 = lp_build_const_v4sf(gallivm, -1.388731625493765E-003);
   LLVMValueRef coscof_p2 = lp_build_const_v4sf(gallivm, 4.166664568298827E-002);

   /*
    * y = *(v4sf*)_ps_coscof_p0;
    * y = _mm_mul_ps(y, z);
    */
   LLVMValueRef y_3 = LLVMBuildFMul(b, z, coscof_p0, "y_3");
   LLVMValueRef y_4 = LLVMBuildFAdd(b, y_3, coscof_p1, "y_4");
   LLVMValueRef y_5 = LLVMBuildFMul(b, y_4, z, "y_5");
   LLVMValueRef y_6 = LLVMBuildFAdd(b, y_5, coscof_p2, "y_6");
   LLVMValueRef y_7 = LLVMBuildFMul(b, y_6, z, "y_7");
   LLVMValueRef y_8 = LLVMBuildFMul(b, y_7, z, "y_8");


   /*
    * tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
    * y = _mm_sub_ps(y, tmp);
    * y = _mm_add_ps(y, *(v4sf*)_ps_1);
    */ 
   LLVMValueRef half = lp_build_const_v4sf(gallivm, 0.5);
   LLVMValueRef tmp = LLVMBuildFMul(b, z, half, "tmp");
   LLVMValueRef y_9 = LLVMBuildFSub(b, y_8, tmp, "y_8");
   LLVMValueRef one = lp_build_const_v4sf(gallivm, 1.0);
   LLVMValueRef y_10 = LLVMBuildFAdd(b, y_9, one, "y_9");

   /*
    * _PS_CONST(sincof_p0, -1.9515295891E-4);
    * _PS_CONST(sincof_p1,  8.3321608736E-3);
    * _PS_CONST(sincof_p2, -1.6666654611E-1);
    */
   LLVMValueRef sincof_p0 = lp_build_const_v4sf(gallivm, -1.9515295891E-4);
   LLVMValueRef sincof_p1 = lp_build_const_v4sf(gallivm, 8.3321608736E-3);
   LLVMValueRef sincof_p2 = lp_build_const_v4sf(gallivm, -1.6666654611E-1);

   /*
    * Evaluate the second polynom  (Pi/4 <= x <= 0)
    *
    * y2 = *(v4sf*)_ps_sincof_p0;
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_mul_ps(y2, x);
    * y2 = _mm_add_ps(y2, x);
    */

   LLVMValueRef y2_3 = LLVMBuildFMul(b, z, sincof_p0, "y2_3");
   LLVMValueRef y2_4 = LLVMBuildFAdd(b, y2_3, sincof_p1, "y2_4");
   LLVMValueRef y2_5 = LLVMBuildFMul(b, y2_4, z, "y2_5");
   LLVMValueRef y2_6 = LLVMBuildFAdd(b, y2_5, sincof_p2, "y2_6");
   LLVMValueRef y2_7 = LLVMBuildFMul(b, y2_6, z, "y2_7");
   LLVMValueRef y2_8 = LLVMBuildFMul(b, y2_7, x_3, "y2_8");
   LLVMValueRef y2_9 = LLVMBuildFAdd(b, y2_8, x_3, "y2_9");

   /*
    * select the correct result from the two polynoms
    * xmm3 = poly_mask;
    * y2 = _mm_and_ps(xmm3, y2); //, xmm3);
    * y = _mm_andnot_ps(xmm3, y);
    * y = _mm_add_ps(y,y2);
    */
   LLVMValueRef y2_i = LLVMBuildBitCast(b, y2_9, v4si, "y2_i");
   LLVMValueRef y_i = LLVMBuildBitCast(b, y_10, v4si, "y_i");
   LLVMValueRef y2_and = LLVMBuildAnd(b, y2_i, poly_mask, "y2_and");
   LLVMValueRef inv = lp_build_const_v4si(bld->gallivm, ~0);
   LLVMValueRef poly_mask_inv = LLVMBuildXor(b, poly_mask, inv, "poly_mask_inv");
   LLVMValueRef y_and = LLVMBuildAnd(b, y_i, poly_mask_inv, "y_and");
   LLVMValueRef y_combine = LLVMBuildAdd(b, y_and, y2_and, "y_combine");

   /*
    * update the sign
    * y = _mm_xor_ps(y, sign_bit);
    */
   LLVMValueRef y_sign = LLVMBuildXor(b, y_combine, sign_bit_1, "y_sin");
   LLVMValueRef y_result = LLVMBuildBitCast(b, y_sign, v4sf, "y_result");
   return y_result;
d1131 1
a1131 1
 * Generate cos(a) using SSE2
d1134 2
a1135 2
lp_build_cos(struct lp_build_context *bld,
             LLVMValueRef a)
d1137 5
a1141 25
   LLVMBuilderRef builder = bld->gallivm->builder;
   struct gallivm_state *gallivm = bld->gallivm;
   struct lp_type int_type = lp_int_type(bld->type);
   LLVMBuilderRef b = builder;
   LLVMTypeRef v4sf = LLVMVectorType(LLVMFloatTypeInContext(bld->gallivm->context), 4);
   LLVMTypeRef v4si = LLVMVectorType(LLVMInt32TypeInContext(bld->gallivm->context), 4);

   /*
    *  take the absolute value,
    *  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
    */

   LLVMValueRef inv_sig_mask = lp_build_const_v4si(bld->gallivm, ~0x80000000);
   LLVMValueRef a_v4si = LLVMBuildBitCast(b, a, v4si, "a_v4si");

   LLVMValueRef absi = LLVMBuildAnd(b, a_v4si, inv_sig_mask, "absi");
   LLVMValueRef x_abs = LLVMBuildBitCast(b, absi, v4sf, "x_abs");

   /*
    * scale by 4/Pi
    * y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);
    */
   
   LLVMValueRef FOPi = lp_build_const_v4sf(gallivm, 1.27323954473516);
   LLVMValueRef scale_y = LLVMBuildFMul(b, x_abs, FOPi, "scale_y");
d1143 2
a1144 6
   /*
    * store the integer part of y in mm0
    * emm2 = _mm_cvttps_epi32(y);
    */
   
   LLVMValueRef emm2_i = LLVMBuildFPToSI(b, scale_y, v4si, "emm2_i");
d1146 1
a1146 176
   /*
    * j=(j+1) & (~1) (see the cephes sources)
    * emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
    */

   LLVMValueRef all_one = lp_build_const_v4si(bld->gallivm, 1);
   LLVMValueRef emm2_add =  LLVMBuildAdd(b, emm2_i, all_one, "emm2_add");
   /*
    * emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
    */
   LLVMValueRef inv_one = lp_build_const_v4si(bld->gallivm, ~1);
   LLVMValueRef emm2_and =  LLVMBuildAnd(b, emm2_add, inv_one, "emm2_and");

   /*
    * y = _mm_cvtepi32_ps(emm2);
    */
   LLVMValueRef y_2 = LLVMBuildSIToFP(b, emm2_and, v4sf, "y_2");


   /*
    * emm2 = _mm_sub_epi32(emm2, *(v4si*)_pi32_2);
    */
   LLVMValueRef const_2 = lp_build_const_v4si(bld->gallivm, 2);
   LLVMValueRef emm2_2 = LLVMBuildSub(b, emm2_and, const_2, "emm2_2");


   /* get the swap sign flag
    * emm0 = _mm_andnot_si128(emm2, *(v4si*)_pi32_4);
    */
   LLVMValueRef inv = lp_build_const_v4si(bld->gallivm, ~0);
   LLVMValueRef emm0_not = LLVMBuildXor(b, emm2_2, inv, "emm0_not");
   LLVMValueRef pi32_4 = lp_build_const_v4si(bld->gallivm, 4);
   LLVMValueRef emm0_and =  LLVMBuildAnd(b, emm0_not, pi32_4, "emm0_and");
   
   /*
    * emm2 = _mm_slli_epi32(emm0, 29);
    */  
   LLVMValueRef const_29 = lp_build_const_v4si(bld->gallivm, 29);
   LLVMValueRef sign_bit = LLVMBuildShl(b, emm0_and, const_29, "sign_bit");

   /*
    * get the polynom selection mask 
    * there is one polynom for 0 <= x <= Pi/4
    * and another one for Pi/4<x<=Pi/2
    * Both branches will be computed.
    *  
    * emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
    * emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
    */

   LLVMValueRef pi32_2 = lp_build_const_v4si(bld->gallivm, 2);
   LLVMValueRef emm2_3 =  LLVMBuildAnd(b, emm2_2, pi32_2, "emm2_3");
   LLVMValueRef poly_mask = lp_build_compare(bld->gallivm,
                                             int_type, PIPE_FUNC_EQUAL,
   				             emm2_3, lp_build_const_v4si(bld->gallivm, 0));

   /*
    * _PS_CONST(minus_cephes_DP1, -0.78515625);
    * _PS_CONST(minus_cephes_DP2, -2.4187564849853515625e-4);
    * _PS_CONST(minus_cephes_DP3, -3.77489497744594108e-8);
    */
   LLVMValueRef DP1 = lp_build_const_v4sf(gallivm, -0.78515625);
   LLVMValueRef DP2 = lp_build_const_v4sf(gallivm, -2.4187564849853515625e-4);
   LLVMValueRef DP3 = lp_build_const_v4sf(gallivm, -3.77489497744594108e-8);

   /*
    * The magic pass: "Extended precision modular arithmetic" 
    * x = ((x - y * DP1) - y * DP2) - y * DP3; 
    * xmm1 = _mm_mul_ps(y, xmm1);
    * xmm2 = _mm_mul_ps(y, xmm2);
    * xmm3 = _mm_mul_ps(y, xmm3);
    */
   LLVMValueRef xmm1 = LLVMBuildFMul(b, y_2, DP1, "xmm1");
   LLVMValueRef xmm2 = LLVMBuildFMul(b, y_2, DP2, "xmm2");
   LLVMValueRef xmm3 = LLVMBuildFMul(b, y_2, DP3, "xmm3");

   /*
    * x = _mm_add_ps(x, xmm1);
    * x = _mm_add_ps(x, xmm2);
    * x = _mm_add_ps(x, xmm3);
    */ 

   LLVMValueRef x_1 = LLVMBuildFAdd(b, x_abs, xmm1, "x_1");
   LLVMValueRef x_2 = LLVMBuildFAdd(b, x_1, xmm2, "x_2");
   LLVMValueRef x_3 = LLVMBuildFAdd(b, x_2, xmm3, "x_3");

   /*
    * Evaluate the first polynom  (0 <= x <= Pi/4)
    *
    * z = _mm_mul_ps(x,x);
    */
   LLVMValueRef z = LLVMBuildFMul(b, x_3, x_3, "z");

   /*
    * _PS_CONST(coscof_p0,  2.443315711809948E-005);
    * _PS_CONST(coscof_p1, -1.388731625493765E-003);
    * _PS_CONST(coscof_p2,  4.166664568298827E-002);
    */
   LLVMValueRef coscof_p0 = lp_build_const_v4sf(gallivm, 2.443315711809948E-005);
   LLVMValueRef coscof_p1 = lp_build_const_v4sf(gallivm, -1.388731625493765E-003);
   LLVMValueRef coscof_p2 = lp_build_const_v4sf(gallivm, 4.166664568298827E-002);

   /*
    * y = *(v4sf*)_ps_coscof_p0;
    * y = _mm_mul_ps(y, z);
    */
   LLVMValueRef y_3 = LLVMBuildFMul(b, z, coscof_p0, "y_3");
   LLVMValueRef y_4 = LLVMBuildFAdd(b, y_3, coscof_p1, "y_4");
   LLVMValueRef y_5 = LLVMBuildFMul(b, y_4, z, "y_5");
   LLVMValueRef y_6 = LLVMBuildFAdd(b, y_5, coscof_p2, "y_6");
   LLVMValueRef y_7 = LLVMBuildFMul(b, y_6, z, "y_7");
   LLVMValueRef y_8 = LLVMBuildFMul(b, y_7, z, "y_8");


   /*
    * tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
    * y = _mm_sub_ps(y, tmp);
    * y = _mm_add_ps(y, *(v4sf*)_ps_1);
    */ 
   LLVMValueRef half = lp_build_const_v4sf(gallivm, 0.5);
   LLVMValueRef tmp = LLVMBuildFMul(b, z, half, "tmp");
   LLVMValueRef y_9 = LLVMBuildFSub(b, y_8, tmp, "y_8");
   LLVMValueRef one = lp_build_const_v4sf(gallivm, 1.0);
   LLVMValueRef y_10 = LLVMBuildFAdd(b, y_9, one, "y_9");

   /*
    * _PS_CONST(sincof_p0, -1.9515295891E-4);
    * _PS_CONST(sincof_p1,  8.3321608736E-3);
    * _PS_CONST(sincof_p2, -1.6666654611E-1);
    */
   LLVMValueRef sincof_p0 = lp_build_const_v4sf(gallivm, -1.9515295891E-4);
   LLVMValueRef sincof_p1 = lp_build_const_v4sf(gallivm, 8.3321608736E-3);
   LLVMValueRef sincof_p2 = lp_build_const_v4sf(gallivm, -1.6666654611E-1);

   /*
    * Evaluate the second polynom  (Pi/4 <= x <= 0)
    *
    * y2 = *(v4sf*)_ps_sincof_p0;
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
    * y2 = _mm_mul_ps(y2, z);
    * y2 = _mm_mul_ps(y2, x);
    * y2 = _mm_add_ps(y2, x);
    */

   LLVMValueRef y2_3 = LLVMBuildFMul(b, z, sincof_p0, "y2_3");
   LLVMValueRef y2_4 = LLVMBuildFAdd(b, y2_3, sincof_p1, "y2_4");
   LLVMValueRef y2_5 = LLVMBuildFMul(b, y2_4, z, "y2_5");
   LLVMValueRef y2_6 = LLVMBuildFAdd(b, y2_5, sincof_p2, "y2_6");
   LLVMValueRef y2_7 = LLVMBuildFMul(b, y2_6, z, "y2_7");
   LLVMValueRef y2_8 = LLVMBuildFMul(b, y2_7, x_3, "y2_8");
   LLVMValueRef y2_9 = LLVMBuildFAdd(b, y2_8, x_3, "y2_9");

   /*
    * select the correct result from the two polynoms
    * xmm3 = poly_mask;
    * y2 = _mm_and_ps(xmm3, y2); //, xmm3);
    * y = _mm_andnot_ps(xmm3, y);
    * y = _mm_add_ps(y,y2);
    */
   LLVMValueRef y2_i = LLVMBuildBitCast(b, y2_9, v4si, "y2_i");
   LLVMValueRef y_i = LLVMBuildBitCast(b, y_10, v4si, "y_i");
   LLVMValueRef y2_and = LLVMBuildAnd(b, y2_i, poly_mask, "y2_and");
   LLVMValueRef poly_mask_inv = LLVMBuildXor(b, poly_mask, inv, "poly_mask_inv");
   LLVMValueRef y_and = LLVMBuildAnd(b, y_i, poly_mask_inv, "y_and");
   LLVMValueRef y_combine = LLVMBuildAdd(b, y_and, y2_and, "y_combine");

   /*
    * update the sign
    * y = _mm_xor_ps(y, sign_bit);
    */
   LLVMValueRef y_sign = LLVMBuildXor(b, y_combine, sign_bit, "y_sin");
   LLVMValueRef y_result = LLVMBuildBitCast(b, y_sign, v4sf, "y_result");
   return y_result;
d1159 1
a1159 2
   if (gallivm_debug & GALLIVM_DEBUG_PERF &&
       LLVMIsConstant(x) && LLVMIsConstant(y)) {
a1161 1
   }
d1175 1
a1175 4
   LLVMValueRef log2e = lp_build_const_vec(bld->gallivm, bld->type,
                                           1.4426950408889634);

   assert(lp_check_value(bld->type, x));
d1189 1
a1189 4
   LLVMValueRef log2 = lp_build_const_vec(bld->gallivm, bld->type,
                                          0.69314718055994529);

   assert(lp_check_value(bld->type, x));
d1195 4
a1212 2
   assert(lp_check_value(bld->type, x));

d1214 1
a1214 2
   if (gallivm_debug & GALLIVM_DEBUG_PERF &&
       LLVMIsConstant(x)) {
a1216 1
   }
d1219 1
a1219 4
      LLVMValueRef coeff;

      coeff = lp_build_const_vec(bld->gallivm, type, coeffs[i]);

d1234 1
a1234 1
 * Minimax polynomial fit of 2**x, in range [0, 1[
d1238 1
a1238 6
   0.999999999690134838155,
   0.583974334321735217258,
   0.164553105719676828492,
   0.0292811063701710962255,
   0.00354944426657875141846,
   0.000296253726543423377365
d1240 1
a1240 5
   1.00000001502262084505,
   0.563586057338685991394,
   0.150436017652442413623,
   0.0243220604213317927308,
   0.0025359088446580436489
d1242 1
a1242 4
   0.999925218562710312959,
   0.695833540494823811697,
   0.226067155427249155588,
   0.0780245226406372992967
d1244 1
a1244 3
   1.00172476321474503578,
   0.657636275736077639316,
   0.33718943461968720704
a1257 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d1259 2
a1260 2
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
a1266 2
   assert(lp_check_value(bld->type, x));

d1269 1
a1269 2
      if (gallivm_debug & GALLIVM_DEBUG_PERF &&
          LLVMIsConstant(x)) {
a1271 1
      }
d1275 2
a1276 2
      x = lp_build_min(bld, x, lp_build_const_vec(bld->gallivm, type,  129.0));
      x = lp_build_max(bld, x, lp_build_const_vec(bld->gallivm, type, -126.99999));
d1278 3
a1280 2
      /* ipart = floor(x) */
      ipart = lp_build_floor(bld, x);
d1283 2
a1284 1
      fpart = LLVMBuildFSub(builder, x, ipart, "");
d1289 3
a1291 6
      ipart = LLVMBuildFPToSI(builder, ipart, int_vec_type, "");
      expipart = LLVMBuildAdd(builder, ipart,
                              lp_build_const_int_vec(bld->gallivm, type, 127), "");
      expipart = LLVMBuildShl(builder, expipart,
                              lp_build_const_int_vec(bld->gallivm, type, 23), "");
      expipart = LLVMBuildBitCast(builder, expipart, vec_type, "");
d1298 1
a1298 1
      res = LLVMBuildFMul(builder, expipart, expfpart, "");
a1322 71
 * Extract the exponent of a IEEE-754 floating point value.
 *
 * Optionally apply an integer bias.
 *
 * Result is an integer value with
 *
 *   ifloor(log2(x)) + bias
 */
LLVMValueRef
lp_build_extract_exponent(struct lp_build_context *bld,
                          LLVMValueRef x,
                          int bias)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   unsigned mantissa = lp_mantissa(type);
   LLVMValueRef res;

   assert(type.floating);

   assert(lp_check_value(bld->type, x));

   x = LLVMBuildBitCast(builder, x, bld->int_vec_type, "");

   res = LLVMBuildLShr(builder, x,
                       lp_build_const_int_vec(bld->gallivm, type, mantissa), "");
   res = LLVMBuildAnd(builder, res,
                      lp_build_const_int_vec(bld->gallivm, type, 255), "");
   res = LLVMBuildSub(builder, res,
                      lp_build_const_int_vec(bld->gallivm, type, 127 - bias), "");

   return res;
}


/**
 * Extract the mantissa of the a floating.
 *
 * Result is a floating point value with
 *
 *   x / floor(log2(x))
 */
LLVMValueRef
lp_build_extract_mantissa(struct lp_build_context *bld,
                          LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   unsigned mantissa = lp_mantissa(type);
   LLVMValueRef mantmask = lp_build_const_int_vec(bld->gallivm, type,
                                                  (1ULL << mantissa) - 1);
   LLVMValueRef one = LLVMConstBitCast(bld->one, bld->int_vec_type);
   LLVMValueRef res;

   assert(lp_check_value(bld->type, x));

   assert(type.floating);

   x = LLVMBuildBitCast(builder, x, bld->int_vec_type, "");

   /* res = x / 2**ipart */
   res = LLVMBuildAnd(builder, x, mantmask, "");
   res = LLVMBuildOr(builder, res, one, "");
   res = LLVMBuildBitCast(builder, res, bld->vec_type, "");

   return res;
}



/**
d1329 1
a1329 6
   3.11578814719469302614,
   -3.32419399085241980044,
   2.59883907202499966007,
   -1.23152682416275988241,
   0.318212422185251071475,
   -0.0344359067839062357313
d1331 1
a1331 5
   2.8882704548164776201,
   -2.52074962577807006663,
   1.48116647521213171641,
   -0.465725644288844778798,
   0.0596515482674574969533
d1333 1
a1333 4
   2.61761038894603480148,
   -1.75647175389045657003,
   0.688243882994381274313,
   -0.107254423828329604454
d1335 1
a1335 3
   2.28330284476918490682,
   -1.04913055217340124191,
   0.204446009836232697516
a1351 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d1353 2
a1354 2
   LLVMTypeRef vec_type = lp_build_vec_type(bld->gallivm, type);
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, type);
d1356 2
a1357 2
   LLVMValueRef expmask = lp_build_const_int_vec(bld->gallivm, type, 0x7f800000);
   LLVMValueRef mantmask = lp_build_const_int_vec(bld->gallivm, type, 0x007fffff);
a1366 2
   assert(lp_check_value(bld->type, x));

d1369 1
a1369 2
      if (gallivm_debug & GALLIVM_DEBUG_PERF &&
          LLVMIsConstant(x)) {
a1371 1
      }
d1375 1
a1375 1
      i = LLVMBuildBitCast(builder, x, int_vec_type, "");
d1378 1
a1378 1
      exp = LLVMBuildAnd(builder, i, expmask, "");
d1382 3
a1384 3
      logexp = LLVMBuildLShr(builder, exp, lp_build_const_int_vec(bld->gallivm, type, 23), "");
      logexp = LLVMBuildSub(builder, logexp, lp_build_const_int_vec(bld->gallivm, type, 127), "");
      logexp = LLVMBuildSIToFP(builder, logexp, vec_type, "");
d1389 3
a1391 3
      mant = LLVMBuildAnd(builder, i, mantmask, "");
      mant = LLVMBuildOr(builder, mant, one, "");
      mant = LLVMBuildBitCast(builder, mant, vec_type, "");
d1397 1
a1397 1
      logmant = LLVMBuildFMul(builder, logmant, LLVMBuildFSub(builder, mant, bld->one, ""), "");
d1399 1
a1399 1
      res = LLVMBuildFAdd(builder, logmant, logexp, "");
d1402 1
a1402 2
   if(p_exp) {
      exp = LLVMBuildBitCast(builder, exp, vec_type, "");
a1403 1
   }
a1419 61
}


/**
 * Faster (and less accurate) log2.
 *
 *    log2(x) = floor(log2(x)) - 1 + x / 2**floor(log2(x))
 *
 * Piece-wise linear approximation, with exact results when x is a
 * power of two.
 *
 * See http://www.flipcode.com/archives/Fast_log_Function.shtml
 */
LLVMValueRef
lp_build_fast_log2(struct lp_build_context *bld,
                   LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef ipart;
   LLVMValueRef fpart;

   assert(lp_check_value(bld->type, x));

   assert(bld->type.floating);

   /* ipart = floor(log2(x)) - 1 */
   ipart = lp_build_extract_exponent(bld, x, -1);
   ipart = LLVMBuildSIToFP(builder, ipart, bld->vec_type, "");

   /* fpart = x / 2**ipart */
   fpart = lp_build_extract_mantissa(bld, x);

   /* ipart + fpart */
   return LLVMBuildFAdd(builder, ipart, fpart, "");
}


/**
 * Fast implementation of iround(log2(x)).
 *
 * Not an approximation -- it should give accurate results all the time.
 */
LLVMValueRef
lp_build_ilog2(struct lp_build_context *bld,
               LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef sqrt2 = lp_build_const_vec(bld->gallivm, bld->type, M_SQRT2);
   LLVMValueRef ipart;

   assert(bld->type.floating);

   assert(lp_check_value(bld->type, x));

   /* x * 2^(0.5)   i.e., add 0.5 to the log2(x) */
   x = LLVMBuildFMul(builder, x, sqrt2, "");

   /* ipart = floor(log2(x) + 0.5)  */
   ipart = lp_build_extract_exponent(bld, x, 0);

   return ipart;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a47 2
#include <float.h>

a60 1
#include "lp_bld_bitarit.h"
a61 1
#include "lp_bld_flow.h"
d64 1
a64 1
#define EXP_POLY_DEGREE 5
d66 1
a66 1
#define LOG_POLY_DEGREE 4
d78 1
a80 1
   unsigned intr_size = 0;
d88 3
a90 7
   if (type.floating && util_cpu_caps.has_sse) {
      if (type.width == 32) {
         if (type.length == 1) {
            intrinsic = "llvm.x86.sse.min.ss";
            intr_size = 128;
         }
         else if (type.length <= 4 || !util_cpu_caps.has_avx) {
d92 1
a92 13
            intr_size = 128;
         }
         else {
            intrinsic = "llvm.x86.avx.min.ps.256";
            intr_size = 256;
         }
      }
      if (type.width == 64 && util_cpu_caps.has_sse2) {
         if (type.length == 1) {
            intrinsic = "llvm.x86.sse2.min.sd";
            intr_size = 128;
         }
         else if (type.length == 2 || !util_cpu_caps.has_avx) {
a93 23
            intr_size = 128;
         }
         else {
            intrinsic = "llvm.x86.avx.min.pd.256";
            intr_size = 256;
         }
      }
   }
   else if (type.floating && util_cpu_caps.has_altivec) {
      if (type.width == 32 && type.length == 4) {
         intrinsic = "llvm.ppc.altivec.vminfp";
         intr_size = 128;
      }
   } else if (util_cpu_caps.has_sse2 && type.length >= 2) {
      intr_size = 128;
      if ((type.width == 8 || type.width == 16) &&
          (type.width * type.length <= 64) &&
          (gallivm_debug & GALLIVM_DEBUG_PERF)) {
         debug_printf("%s: inefficient code, bogus shuffle due to packing\n",
                      __FUNCTION__);
         }
      if (type.width == 8 && !type.sign) {
         intrinsic = "llvm.x86.sse2.pminu.b";
d95 4
a98 5
      else if (type.width == 16 && type.sign) {
         intrinsic = "llvm.x86.sse2.pmins.w";
      }
      if (util_cpu_caps.has_sse4_1) {
         if (type.width == 8 && type.sign) {
d100 1
a100 2
         }
         if (type.width == 16 && !type.sign) {
d102 3
a104 2
         }
         if (type.width == 32 && !type.sign) {
d106 1
a106 2
        }
         if (type.width == 32 && type.sign) {
a107 1
         }
a108 27
   } else if (util_cpu_caps.has_altivec) {
     intr_size = 128;
     if (type.width == 8) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vminub";
       } else {
         intrinsic = "llvm.ppc.altivec.vminsb";
       }
     } else if (type.width == 16) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vminuh";
       } else {
         intrinsic = "llvm.ppc.altivec.vminsh";
       }
     } else if (type.width == 32) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vminuw";
       } else {
         intrinsic = "llvm.ppc.altivec.vminsw";
       }
     }
   }

   if(intrinsic) {
      return lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                 type,
                                                 intr_size, a, b);
d111 3
d128 1
a130 1
   unsigned intr_size = 0;
d138 3
a140 7
   if (type.floating && util_cpu_caps.has_sse) {
      if (type.width == 32) {
         if (type.length == 1) {
            intrinsic = "llvm.x86.sse.max.ss";
            intr_size = 128;
         }
         else if (type.length <= 4 || !util_cpu_caps.has_avx) {
d142 1
a142 13
            intr_size = 128;
         }
         else {
            intrinsic = "llvm.x86.avx.max.ps.256";
            intr_size = 256;
         }
      }
      if (type.width == 64 && util_cpu_caps.has_sse2) {
         if (type.length == 1) {
            intrinsic = "llvm.x86.sse2.max.sd";
            intr_size = 128;
         }
         else if (type.length == 2 || !util_cpu_caps.has_avx) {
a143 24
            intr_size = 128;
         }
         else {
            intrinsic = "llvm.x86.avx.max.pd.256";
            intr_size = 256;
         }
      }
   }
   else if (type.floating && util_cpu_caps.has_altivec) {
      if (type.width == 32 || type.length == 4) {
         intrinsic = "llvm.ppc.altivec.vmaxfp";
         intr_size = 128;
      }
   } else if (util_cpu_caps.has_sse2 && type.length >= 2) {
      intr_size = 128;
      if ((type.width == 8 || type.width == 16) &&
          (type.width * type.length <= 64) &&
          (gallivm_debug & GALLIVM_DEBUG_PERF)) {
         debug_printf("%s: inefficient code, bogus shuffle due to packing\n",
                      __FUNCTION__);
         }
      if (type.width == 8 && !type.sign) {
         intrinsic = "llvm.x86.sse2.pmaxu.b";
         intr_size = 128;
d145 4
a148 5
      else if (type.width == 16 && type.sign) {
         intrinsic = "llvm.x86.sse2.pmaxs.w";
      }
      if (util_cpu_caps.has_sse4_1) {
         if (type.width == 8 && type.sign) {
d150 1
a150 2
         }
         if (type.width == 16 && !type.sign) {
d152 3
a154 2
         }
         if (type.width == 32 && !type.sign) {
d156 1
a156 2
        }
         if (type.width == 32 && type.sign) {
a157 1
         }
a158 27
   } else if (util_cpu_caps.has_altivec) {
     intr_size = 128;
     if (type.width == 8) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vmaxub";
       } else {
         intrinsic = "llvm.ppc.altivec.vmaxsb";
       }
     } else if (type.width == 16) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vmaxuh";
       } else {
         intrinsic = "llvm.ppc.altivec.vmaxsh";
       }
     } else if (type.width == 32) {
       if (!type.sign) {
         intrinsic = "llvm.ppc.altivec.vmaxuw";
       } else {
         intrinsic = "llvm.ppc.altivec.vmaxsw";
       }
     }
   }

   if(intrinsic) {
      return lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                 type,
                                                 intr_size, a, b);
d161 3
d234 7
a240 13
      if (type.width * type.length == 128 &&
          !type.floating && !type.fixed) {
         if(util_cpu_caps.has_sse2) {
           if(type.width == 8)
             intrinsic = type.sign ? "llvm.x86.sse2.padds.b" : "llvm.x86.sse2.paddus.b";
           if(type.width == 16)
             intrinsic = type.sign ? "llvm.x86.sse2.padds.w" : "llvm.x86.sse2.paddus.w";
         } else if (util_cpu_caps.has_altivec) {
           if(type.width == 8)
              intrinsic = type.sign ? "llvm.ppc.altivec.vaddsbs" : "llvm.ppc.altivec.vaddubs";
           if(type.width == 16)
              intrinsic = type.sign ? "llvm.ppc.altivec.vaddshs" : "llvm.ppc.altivec.vadduhs";
         }
a246 4
   /* TODO: handle signed case */
   if(type.norm && !type.floating && !type.fixed && !type.sign)
      a = lp_build_min_simple(bld, a, lp_build_comp(bld, b));

d268 1
a268 3
/** Return the scalar sum of the elements of a.
 * Should avoid this operation whenever possible.
 */
d270 2
a271 2
lp_build_horizontal_add(struct lp_build_context *bld,
                        LLVMValueRef a)
d276 1
a276 4
   unsigned i, length;
   LLVMValueRef shuffles1[LP_MAX_VECTOR_LENGTH / 2];
   LLVMValueRef shuffles2[LP_MAX_VECTOR_LENGTH / 2];
   LLVMValueRef vecres, elem2;
a285 33
   /*
    * for byte vectors can do much better with psadbw.
    * Using repeated shuffle/adds here. Note with multiple vectors
    * this can be done more efficiently as outlined in the intel
    * optimization manual.
    * Note: could cause data rearrangement if used with smaller element
    * sizes.
    */

   vecres = a;
   length = type.length / 2;
   while (length > 1) {
      LLVMValueRef vec1, vec2;
      for (i = 0; i < length; i++) {
         shuffles1[i] = lp_build_const_int32(bld->gallivm, i);
         shuffles2[i] = lp_build_const_int32(bld->gallivm, i + length);
      }
      vec1 = LLVMBuildShuffleVector(builder, vecres, vecres,
                                    LLVMConstVector(shuffles1, length), "");
      vec2 = LLVMBuildShuffleVector(builder, vecres, vecres,
                                    LLVMConstVector(shuffles2, length), "");
      if (type.floating) {
         vecres = LLVMBuildFAdd(builder, vec1, vec2, "");
      }
      else {
         vecres = LLVMBuildAdd(builder, vec1, vec2, "");
      }
      length = length >> 1;
   }

   /* always have vector of size 2 here */
   assert(length == 1);

d287 1
a287 3
   res = LLVMBuildExtractElement(builder, vecres, index, "");
   index = lp_build_const_int32(bld->gallivm, 1);
   elem2 = LLVMBuildExtractElement(builder, vecres, index, "");
d289 13
a301 4
   if (type.floating)
      res = LLVMBuildFAdd(builder, res, elem2, "");
    else
      res = LLVMBuildAdd(builder, res, elem2, "");
a305 139
/**
 * Return the horizontal sums of 4 float vectors as a float4 vector.
 * This uses the technique as outlined in Intel Optimization Manual.
 */
static LLVMValueRef
lp_build_horizontal_add4x4f(struct lp_build_context *bld,
                            LLVMValueRef src[4])
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef shuffles[4];
   LLVMValueRef tmp[4];
   LLVMValueRef sumtmp[2], shuftmp[2];

   /* lower half of regs */
   shuffles[0] = lp_build_const_int32(gallivm, 0);
   shuffles[1] = lp_build_const_int32(gallivm, 1);
   shuffles[2] = lp_build_const_int32(gallivm, 4);
   shuffles[3] = lp_build_const_int32(gallivm, 5);
   tmp[0] = LLVMBuildShuffleVector(builder, src[0], src[1],
                                   LLVMConstVector(shuffles, 4), "");
   tmp[2] = LLVMBuildShuffleVector(builder, src[2], src[3],
                                   LLVMConstVector(shuffles, 4), "");

   /* upper half of regs */
   shuffles[0] = lp_build_const_int32(gallivm, 2);
   shuffles[1] = lp_build_const_int32(gallivm, 3);
   shuffles[2] = lp_build_const_int32(gallivm, 6);
   shuffles[3] = lp_build_const_int32(gallivm, 7);
   tmp[1] = LLVMBuildShuffleVector(builder, src[0], src[1],
                                   LLVMConstVector(shuffles, 4), "");
   tmp[3] = LLVMBuildShuffleVector(builder, src[2], src[3],
                                   LLVMConstVector(shuffles, 4), "");

   sumtmp[0] = LLVMBuildFAdd(builder, tmp[0], tmp[1], "");
   sumtmp[1] = LLVMBuildFAdd(builder, tmp[2], tmp[3], "");

   shuffles[0] = lp_build_const_int32(gallivm, 0);
   shuffles[1] = lp_build_const_int32(gallivm, 2);
   shuffles[2] = lp_build_const_int32(gallivm, 4);
   shuffles[3] = lp_build_const_int32(gallivm, 6);
   shuftmp[0] = LLVMBuildShuffleVector(builder, sumtmp[0], sumtmp[1],
                                       LLVMConstVector(shuffles, 4), "");

   shuffles[0] = lp_build_const_int32(gallivm, 1);
   shuffles[1] = lp_build_const_int32(gallivm, 3);
   shuffles[2] = lp_build_const_int32(gallivm, 5);
   shuffles[3] = lp_build_const_int32(gallivm, 7);
   shuftmp[1] = LLVMBuildShuffleVector(builder, sumtmp[0], sumtmp[1],
                                       LLVMConstVector(shuffles, 4), "");

   return LLVMBuildFAdd(builder, shuftmp[0], shuftmp[1], "");
}


/*
 * partially horizontally add 2-4 float vectors with length nx4,
 * i.e. only four adjacent values in each vector will be added,
 * assuming values are really grouped in 4 which also determines
 * output order.
 *
 * Return a vector of the same length as the initial vectors,
 * with the excess elements (if any) being undefined.
 * The element order is independent of number of input vectors.
 * For 3 vectors x0x1x2x3x4x5x6x7, y0y1y2y3y4y5y6y7, z0z1z2z3z4z5z6z7
 * the output order thus will be
 * sumx0-x3,sumy0-y3,sumz0-z3,undef,sumx4-x7,sumy4-y7,sumz4z7,undef
 */
LLVMValueRef
lp_build_hadd_partial4(struct lp_build_context *bld,
                       LLVMValueRef vectors[],
                       unsigned num_vecs)
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef ret_vec;
   LLVMValueRef tmp[4];
   const char *intrinsic = NULL;

   assert(num_vecs >= 2 && num_vecs <= 4);
   assert(bld->type.floating);

   /* only use this with at least 2 vectors, as it is sort of expensive
    * (depending on cpu) and we always need two horizontal adds anyway,
    * so a shuffle/add approach might be better.
    */

   tmp[0] = vectors[0];
   tmp[1] = vectors[1];

   tmp[2] = num_vecs > 2 ? vectors[2] : vectors[0];
   tmp[3] = num_vecs > 3 ? vectors[3] : vectors[0];

   if (util_cpu_caps.has_sse3 && bld->type.width == 32 &&
       bld->type.length == 4) {
      intrinsic = "llvm.x86.sse3.hadd.ps";
   }
   else if (util_cpu_caps.has_avx && bld->type.width == 32 &&
            bld->type.length == 8) {
      intrinsic = "llvm.x86.avx.hadd.ps.256";
   }
   if (intrinsic) {
      tmp[0] = lp_build_intrinsic_binary(builder, intrinsic,
                                       lp_build_vec_type(gallivm, bld->type),
                                       tmp[0], tmp[1]);
      if (num_vecs > 2) {
         tmp[1] = lp_build_intrinsic_binary(builder, intrinsic,
                                          lp_build_vec_type(gallivm, bld->type),
                                          tmp[2], tmp[3]);
      }
      else {
         tmp[1] = tmp[0];
      }
      return lp_build_intrinsic_binary(builder, intrinsic,
                                       lp_build_vec_type(gallivm, bld->type),
                                       tmp[0], tmp[1]);
   }

   if (bld->type.length == 4) {
      ret_vec = lp_build_horizontal_add4x4f(bld, tmp);
   }
   else {
      LLVMValueRef partres[LP_MAX_VECTOR_LENGTH/4];
      unsigned j;
      unsigned num_iter = bld->type.length / 4;
      struct lp_type parttype = bld->type;
      parttype.length = 4;
      for (j = 0; j < num_iter; j++) {
         LLVMValueRef partsrc[4];
         unsigned i;
         for (i = 0; i < 4; i++) {
            partsrc[i] = lp_build_extract_range(gallivm, tmp[i], j*4, 4);
         }
         partres[j] = lp_build_horizontal_add4x4f(bld, partsrc);
      }
      ret_vec = lp_build_concat(gallivm, partres, parttype, num_iter);
   }
   return ret_vec;
}
d335 7
a341 13
      if (type.width * type.length == 128 &&
          !type.floating && !type.fixed) {
         if (util_cpu_caps.has_sse2) {
           if(type.width == 8)
              intrinsic = type.sign ? "llvm.x86.sse2.psubs.b" : "llvm.x86.sse2.psubus.b";
           if(type.width == 16)
              intrinsic = type.sign ? "llvm.x86.sse2.psubs.w" : "llvm.x86.sse2.psubus.w";
         } else if (util_cpu_caps.has_altivec) {
           if(type.width == 8)
              intrinsic = type.sign ? "llvm.ppc.altivec.vsubsbs" : "llvm.ppc.altivec.vsububs";
           if(type.width == 16)
              intrinsic = type.sign ? "llvm.ppc.altivec.vsubshs" : "llvm.ppc.altivec.vsubuhs";
         }
a347 4
   /* TODO: handle signed case */
   if(type.norm && !type.floating && !type.fixed && !type.sign)
      a = lp_build_max_simple(bld, a, b);

a365 1

d367 1
a367 4
 * Normalized multiplication.
 *
 * There are several approaches for (using 8-bit normalized multiplication as
 * an example):
d375 1
a375 1
 *     which is the fastest method that satisfies the following OpenGL criteria of
d391 1
a391 1
 *     must be used.
d400 1
a400 3
 *     achieving the exact results.
 *
 *
d408 3
a410 3
lp_build_mul_norm(struct gallivm_state *gallivm,
                  struct lp_type wide_type,
                  LLVMValueRef a, LLVMValueRef b)
d413 1
a413 3
   struct lp_build_context bld;
   unsigned n;
   LLVMValueRef half;
d416 3
a418 3
   assert(!wide_type.floating);
   assert(lp_check_value(wide_type, a));
   assert(lp_check_value(wide_type, b));
d420 7
a426 15
   lp_build_context_init(&bld, gallivm, wide_type);

   n = wide_type.width / 2;
   if (wide_type.sign) {
      --n;
   }

   /*
    * TODO: for 16bits normalized SSE2 vectors we could consider using PMULHUW
    * http://ssp.impulsetrain.com/2011/07/03/multiplying-normalized-16-bit-numbers-with-sse2/
    */

   /*
    * a*b / (2**n - 1) ~= (a*b + (a*b >> n) + half) >> n
    */
d428 3
d432 2
a433 1
   ab = LLVMBuildAdd(builder, ab, lp_build_shr_imm(&bld, ab, n), "");
d435 3
a437 14
   /*
    * half = sgn(ab) * 0.5 * (2 ** n) = sgn(ab) * (1 << (n - 1))
    */

   half = lp_build_const_int_vec(gallivm, wide_type, 1 << (n - 1));
   if (wide_type.sign) {
      LLVMValueRef minus_half = LLVMBuildNeg(builder, half, "");
      LLVMValueRef sign = lp_build_shr_imm(&bld, ab, wide_type.width - 1);
      half = lp_build_select(&bld, sign, minus_half, half);
   }
   ab = LLVMBuildAdd(builder, ab, half, "");

   /* Final division */
   ab = lp_build_shr_imm(&bld, ab, n);
d442 1
d470 4
a473 3
   if (!type.floating && !type.fixed && type.norm) {
      struct lp_type wide_type = lp_wider_type(type);
      LLVMValueRef al, ah, bl, bh, abl, abh, ab;
d475 2
a476 2
      lp_build_unpack2(bld->gallivm, type, wide_type, a, &al, &ah);
      lp_build_unpack2(bld->gallivm, type, wide_type, b, &bl, &bh);
d478 3
a480 3
      /* PMULLW, PSRLW, PADDW */
      abl = lp_build_mul_norm(bld->gallivm, wide_type, al, bl);
      abh = lp_build_mul_norm(bld->gallivm, wide_type, ah, bh);
d482 4
a485 1
      ab = lp_build_pack2(bld->gallivm, wide_type, type, abl, abh);
d487 2
a488 1
      return ab;
d556 1
a556 1
          * Power of two multiplication by directly manipulating the exponent.
d615 1
a615 3
   if(((util_cpu_caps.has_sse && type.width == 32 && type.length == 4) ||
       (util_cpu_caps.has_avx && type.width == 32 && type.length == 8)) &&
      type.floating)
d628 1
a628 4
 * Linear interpolation helper.
 *
 * @@param normalized whether we are interpolating normalized values,
 *        encoded in normalized integers, twice as wide.
d636 1
a636 2
                     LLVMValueRef v1,
                     unsigned flags)
a637 1
   unsigned half_width = bld->type.width/2;
d648 1
a648 28
   if (flags & LP_BLD_LERP_WIDE_NORMALIZED) {
      if (!bld->type.sign) {
         if (!(flags & LP_BLD_LERP_PRESCALED_WEIGHTS)) {
            /*
             * Scale x from [0, 2**n - 1] to [0, 2**n] by adding the
             * most-significant-bit to the lowest-significant-bit, so that
             * later we can just divide by 2**n instead of 2**n - 1.
             */

            x = lp_build_add(bld, x, lp_build_shr_imm(bld, x, half_width - 1));
         }

         /* (x * delta) >> n */
         res = lp_build_mul(bld, x, delta);
         res = lp_build_shr_imm(bld, res, half_width);
      } else {
         /*
          * The rescaling trick above doesn't work for signed numbers, so
          * use the 2**n - 1 divison approximation in lp_build_mul_norm
          * instead.
          */
         assert(!(flags & LP_BLD_LERP_PRESCALED_WEIGHTS));
         res = lp_build_mul_norm(bld->gallivm, bld->type, x, delta);
      }
   } else {
      assert(!(flags & LP_BLD_LERP_PRESCALED_WEIGHTS));
      res = lp_build_mul(bld, x, delta);
   }
d652 1
a652 3
   if (((flags & LP_BLD_LERP_WIDE_NORMALIZED) && !bld->type.sign) ||
       bld->type.fixed) {
      /* We need to mask out the high order bits when lerping 8bit normalized colors stored on 16bits */
d654 2
a655 2
       * but it will be wrong for true fixed point use cases. Basically we need
       * a more powerful lp_type, capable of further distinguishing the values
d657 1
a657 1
      res = LLVMBuildAnd(builder, res, lp_build_const_int_vec(bld->gallivm, bld->type, (1 << half_width) - 1), "");
d671 1
a671 2
              LLVMValueRef v1,
              unsigned flags)
d673 1
a680 2
   assert(!(flags & LP_BLD_LERP_WIDE_NORMALIZED));

d685 1
d688 1
d691 2
a692 2
       * Create a wider integer type, enough to hold the
       * intermediate result of the multiplication.
d695 1
a695 1
      wide_type.sign   = type.sign;
d706 11
d720 2
a721 4
      flags |= LP_BLD_LERP_WIDE_NORMALIZED;

      resl = lp_build_lerp_simple(&wide_bld, xl, v0l, v1l, flags);
      resh = lp_build_lerp_simple(&wide_bld, xh, v0h, v1h, flags);
d725 1
a725 1
      res = lp_build_lerp_simple(bld, x, v0, v1, flags);
a731 5
/**
 * Bilinear interpolation.
 *
 * Values indices are in v_{yx}.
 */
d739 1
a739 2
                 LLVMValueRef v11,
                 unsigned flags)
d741 3
a743 24
   LLVMValueRef v0 = lp_build_lerp(bld, x, v00, v01, flags);
   LLVMValueRef v1 = lp_build_lerp(bld, x, v10, v11, flags);
   return lp_build_lerp(bld, y, v0, v1, flags);
}


LLVMValueRef
lp_build_lerp_3d(struct lp_build_context *bld,
                 LLVMValueRef x,
                 LLVMValueRef y,
                 LLVMValueRef z,
                 LLVMValueRef v000,
                 LLVMValueRef v001,
                 LLVMValueRef v010,
                 LLVMValueRef v011,
                 LLVMValueRef v100,
                 LLVMValueRef v101,
                 LLVMValueRef v110,
                 LLVMValueRef v111,
                 unsigned flags)
{
   LLVMValueRef v0 = lp_build_lerp_2d(bld, x, y, v000, v001, v010, v011, flags);
   LLVMValueRef v1 = lp_build_lerp_2d(bld, x, y, v100, v101, v110, v111, flags);
   return lp_build_lerp(bld, z, v0, v1, flags);
d765 3
a767 6
   if (bld->type.norm) {
      if (!bld->type.sign) {
         if (a == bld->zero || b == bld->zero) {
            return bld->zero;
         }
      }
d799 4
a802 8
      if (!bld->type.sign) {
         if (a == bld->zero) {
            return b;
         }
         if (b == bld->zero) {
            return a;
         }
      }
a865 6
   else if (type.width*type.length == 256 && util_cpu_caps.has_ssse3 &&
            (gallivm_debug & GALLIVM_DEBUG_PERF) &&
            (type.width == 8 || type.width == 16 || type.width == 32)) {
      debug_printf("%s: inefficient code, should split vectors manually\n",
                   __FUNCTION__);
   }
a927 2
      /* signed int/norm/fixed point */
      /* could use psign with sse3 and appropriate vectors here */
d994 3
a996 2
static boolean
arch_rounding_available(const struct lp_type type)
d998 4
a1001 17
   if ((util_cpu_caps.has_sse4_1 &&
       (type.length == 1 || type.width*type.length == 128)) ||
       (util_cpu_caps.has_avx && type.width*type.length == 256))
      return TRUE;
   else if ((util_cpu_caps.has_altivec &&
            (type.width == 32 && type.length == 4)))
      return TRUE;

   return FALSE;
}

enum lp_build_round_mode
{
   LP_BUILD_ROUND_NEAREST = 0,
   LP_BUILD_ROUND_FLOOR = 1,
   LP_BUILD_ROUND_CEIL = 2,
   LP_BUILD_ROUND_TRUNCATE = 3
d1004 1
d1014 1
a1014 1
                     enum lp_build_round_mode mode)
d1059 1
a1059 16
      if (type.width * type.length == 128) {
         switch(type.width) {
         case 32:
            intrinsic = "llvm.x86.sse41.round.ps";
            break;
         case 64:
            intrinsic = "llvm.x86.sse41.round.pd";
            break;
         default:
            assert(0);
            return bld->undef;
         }
      }
      else {
         assert(type.width * type.length == 256);
         assert(util_cpu_caps.has_avx);
d1061 10
a1070 11
         switch(type.width) {
         case 32:
            intrinsic = "llvm.x86.avx.round.ps.256";
            break;
         case 64:
            intrinsic = "llvm.x86.avx.round.pd.256";
            break;
         default:
            assert(0);
            return bld->undef;
         }
d1119 3
a1121 6
      if (type.width* type.length == 128) {
         intrinsic = "llvm.x86.sse2.cvtps2dq";
      }
      else {
         assert(type.width*type.length == 256);
         assert(util_cpu_caps.has_avx);
a1122 2
         intrinsic = "llvm.x86.avx.cvt.ps2dq.256";
      }
a1130 45
/*
 */
static INLINE LLVMValueRef
lp_build_round_altivec(struct lp_build_context *bld,
                       LLVMValueRef a,
                       enum lp_build_round_mode mode)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;
   const char *intrinsic = NULL;

   assert(type.floating);

   assert(lp_check_value(type, a));
   assert(util_cpu_caps.has_altivec);

   switch (mode) {
   case LP_BUILD_ROUND_NEAREST:
      intrinsic = "llvm.ppc.altivec.vrfin";
      break;
   case LP_BUILD_ROUND_FLOOR:
      intrinsic = "llvm.ppc.altivec.vrfim";
      break;
   case LP_BUILD_ROUND_CEIL:
      intrinsic = "llvm.ppc.altivec.vrfip";
      break;
   case LP_BUILD_ROUND_TRUNCATE:
      intrinsic = "llvm.ppc.altivec.vrfiz";
      break;
   }

   return lp_build_intrinsic_unary(builder, intrinsic, bld->vec_type, a);
}

static INLINE LLVMValueRef
lp_build_round_arch(struct lp_build_context *bld,
                    LLVMValueRef a,
                    enum lp_build_round_mode mode)
{
   if (util_cpu_caps.has_sse4_1)
     return lp_build_round_sse41(bld, a, mode);
   else /* (util_cpu_caps.has_altivec) */
     return lp_build_round_altivec(bld, a, mode);
}

d1146 3
a1148 2
   if (arch_rounding_available(type)) {
      return lp_build_round_arch(bld, a, LP_BUILD_ROUND_TRUNCATE);
d1151 6
a1156 31
      const struct lp_type type = bld->type;
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 2^24);
      LLVMValueRef trunc, res, anosign, mask;
      LLVMTypeRef int_vec_type = bld->int_vec_type;
      LLVMTypeRef vec_type = bld->vec_type;

      assert(type.width == 32); /* might want to handle doubles at some point */

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      /* round by truncation */
      trunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      res = LLVMBuildSIToFP(builder, trunc, vec_type, "floor.trunc");

      /* mask out sign bit */
      anosign = lp_build_abs(bld, a);
      /*
       * mask out all values if anosign > 2^24
       * This should work both for large ints (all rounding is no-op for them
       * because such floats are always exact) as well as special cases like
       * NaNs, Infs (taking advantage of the fact they use max exponent).
       * (2^24 is arbitrary anything between 2^24 and 2^31 should work.)
       */
      anosign = LLVMBuildBitCast(builder, anosign, int_vec_type, "");
      cmpval = LLVMBuildBitCast(builder, cmpval, int_vec_type, "");
      mask = lp_build_cmp(&intbld, PIPE_FUNC_GREATER, anosign, cmpval);
      return lp_build_select(bld, mask, a, res);
d1177 3
a1179 2
   if (arch_rounding_available(type)) {
      return lp_build_round_arch(bld, a, LP_BUILD_ROUND_NEAREST);
d1182 2
a1183 14
      const struct lp_type type = bld->type;
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 2^24);
      LLVMValueRef res, anosign, mask;
      LLVMTypeRef int_vec_type = bld->int_vec_type;
      LLVMTypeRef vec_type = bld->vec_type;

      assert(type.width == 32); /* might want to handle doubles at some point */

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

d1186 1
a1186 14

      /* mask out sign bit */
      anosign = lp_build_abs(bld, a);
      /*
       * mask out all values if anosign > 2^24
       * This should work both for large ints (all rounding is no-op for them
       * because such floats are always exact) as well as special cases like
       * NaNs, Infs (taking advantage of the fact they use max exponent).
       * (2^24 is arbitrary anything between 2^24 and 2^31 should work.)
       */
      anosign = LLVMBuildBitCast(builder, anosign, int_vec_type, "");
      cmpval = LLVMBuildBitCast(builder, cmpval, int_vec_type, "");
      mask = lp_build_cmp(&intbld, PIPE_FUNC_GREATER, anosign, cmpval);
      return lp_build_select(bld, mask, a, res);
d1206 3
a1208 2
   if (arch_rounding_available(type)) {
      return lp_build_round_arch(bld, a, LP_BUILD_ROUND_FLOOR);
d1211 5
a1215 46
      const struct lp_type type = bld->type;
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 2^24);
      LLVMValueRef trunc, res, anosign, mask;
      LLVMTypeRef int_vec_type = bld->int_vec_type;
      LLVMTypeRef vec_type = bld->vec_type;

      assert(type.width == 32); /* might want to handle doubles at some point */

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      /* round by truncation */
      trunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      res = LLVMBuildSIToFP(builder, trunc, vec_type, "floor.trunc");

      if (type.sign) {
         LLVMValueRef tmp;

         /*
          * fix values if rounding is wrong (for non-special cases)
          * - this is the case if trunc > a
          */
         mask = lp_build_cmp(bld, PIPE_FUNC_GREATER, res, a);
         /* tmp = trunc > a ? 1.0 : 0.0 */
         tmp = LLVMBuildBitCast(builder, bld->one, int_vec_type, "");
         tmp = lp_build_and(&intbld, mask, tmp);
         tmp = LLVMBuildBitCast(builder, tmp, vec_type, "");
         res = lp_build_sub(bld, res, tmp);
      }

      /* mask out sign bit */
      anosign = lp_build_abs(bld, a);
      /*
       * mask out all values if anosign > 2^24
       * This should work both for large ints (all rounding is no-op for them
       * because such floats are always exact) as well as special cases like
       * NaNs, Infs (taking advantage of the fact they use max exponent).
       * (2^24 is arbitrary anything between 2^24 and 2^31 should work.)
       */
      anosign = LLVMBuildBitCast(builder, anosign, int_vec_type, "");
      cmpval = LLVMBuildBitCast(builder, cmpval, int_vec_type, "");
      mask = lp_build_cmp(&intbld, PIPE_FUNC_GREATER, anosign, cmpval);
      return lp_build_select(bld, mask, a, res);
d1235 3
a1237 2
   if (arch_rounding_available(type)) {
      return lp_build_round_arch(bld, a, LP_BUILD_ROUND_CEIL);
d1240 5
a1244 42
      const struct lp_type type = bld->type;
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 2^24);
      LLVMValueRef trunc, res, anosign, mask, tmp;
      LLVMTypeRef int_vec_type = bld->int_vec_type;
      LLVMTypeRef vec_type = bld->vec_type;

      assert(type.width == 32); /* might want to handle doubles at some point */

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      /* round by truncation */
      trunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      trunc = LLVMBuildSIToFP(builder, trunc, vec_type, "ceil.trunc");

      /*
       * fix values if rounding is wrong (for non-special cases)
       * - this is the case if trunc < a
       */
      mask = lp_build_cmp(bld, PIPE_FUNC_LESS, trunc, a);
      /* tmp = trunc < a ? 1.0 : 0.0 */
      tmp = LLVMBuildBitCast(builder, bld->one, int_vec_type, "");
      tmp = lp_build_and(&intbld, mask, tmp);
      tmp = LLVMBuildBitCast(builder, tmp, vec_type, "");
      res = lp_build_add(bld, trunc, tmp);

      /* mask out sign bit */
      anosign = lp_build_abs(bld, a);
      /*
       * mask out all values if anosign > 2^24
       * This should work both for large ints (all rounding is no-op for them
       * because such floats are always exact) as well as special cases like
       * NaNs, Infs (taking advantage of the fact they use max exponent).
       * (2^24 is arbitrary anything between 2^24 and 2^31 should work.)
       */
      anosign = LLVMBuildBitCast(builder, anosign, int_vec_type, "");
      cmpval = LLVMBuildBitCast(builder, cmpval, int_vec_type, "");
      mask = lp_build_cmp(&intbld, PIPE_FUNC_GREATER, anosign, cmpval);
      return lp_build_select(bld, mask, a, res);
a1262 28
 * Prevent returning a fractional part of 1.0 for very small negative values of
 * 'a' by clamping against 0.99999(9).
 */
static inline LLVMValueRef
clamp_fract(struct lp_build_context *bld, LLVMValueRef fract)
{
   LLVMValueRef max;

   /* this is the largest number smaller than 1.0 representable as float */
   max = lp_build_const_vec(bld->gallivm, bld->type,
                            1.0 - 1.0/(1LL << (lp_mantissa(bld->type) + 1)));
   return lp_build_min(bld, fract, max);
}


/**
 * Same as lp_build_fract, but guarantees that the result is always smaller
 * than one.
 */
LLVMValueRef
lp_build_fract_safe(struct lp_build_context *bld,
                    LLVMValueRef a)
{
   return clamp_fract(bld, lp_build_fract(bld, a));
}


/**
d1301 2
a1302 3
   if ((util_cpu_caps.has_sse2 &&
       ((type.width == 32) && (type.length == 1 || type.length == 4))) ||
       (util_cpu_caps.has_avx && type.width == 32 && type.length == 8)) {
d1305 3
a1307 2
   if (arch_rounding_available(type)) {
      res = lp_build_round_arch(bld, a, LP_BUILD_ROUND_NEAREST);
d1356 32
a1387 20
   res = a;
   if (type.sign) {
      if (arch_rounding_available(type)) {
         res = lp_build_round_arch(bld, a, LP_BUILD_ROUND_FLOOR);
      }
      else {
         struct lp_type inttype;
         struct lp_build_context intbld;
         LLVMValueRef trunc, itrunc, mask;

         assert(type.floating);
         assert(lp_check_value(type, a));

         inttype = type;
         inttype.floating = 0;
         lp_build_context_init(&intbld, bld->gallivm, inttype);

         /* round by truncation */
         itrunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
         trunc = LLVMBuildSIToFP(builder, itrunc, bld->vec_type, "ifloor.trunc");
d1389 1
a1389 9
         /*
          * fix values if rounding is wrong (for non-special cases)
          * - this is the case if trunc > a
          * The results of doing this with NaNs, very large values etc.
          * are undefined but this seems to be the case anyway.
          */
         mask = lp_build_cmp(bld, PIPE_FUNC_GREATER, trunc, a);
         /* cheapie minus one with mask since the mask is minus one / zero */
         return lp_build_add(&intbld, itrunc, mask);
d1417 3
a1419 2
   if (arch_rounding_available(type)) {
      res = lp_build_round_arch(bld, a, LP_BUILD_ROUND_CEIL);
d1422 3
a1424 14
      struct lp_type inttype;
      struct lp_build_context intbld;
      LLVMValueRef trunc, itrunc, mask;

      assert(type.floating);
      assert(lp_check_value(type, a));

      inttype = type;
      inttype.floating = 0;
      lp_build_context_init(&intbld, bld->gallivm, inttype);

      /* round by truncation */
      itrunc = LLVMBuildFPToSI(builder, a, int_vec_type, "");
      trunc = LLVMBuildSIToFP(builder, itrunc, bld->vec_type, "iceil.trunc");
d1426 25
a1450 9
      /*
       * fix values if rounding is wrong (for non-special cases)
       * - this is the case if trunc < a
       * The results of doing this with NaNs, very large values etc.
       * are undefined but this seems to be the case anyway.
       */
      mask = lp_build_cmp(bld, PIPE_FUNC_LESS, trunc, a);
      /* cheapie plus one with mask since the mask is minus one / zero */
      return lp_build_sub(&intbld, itrunc, mask);
d1464 1
a1464 1
 * strategy (floor() vs ifloor()) that results in less redundant work is used.
d1479 2
a1480 1
   if (arch_rounding_available(type)) {
a1500 15
/**
 * Same as lp_build_ifloor_fract, but guarantees that the fractional part is
 * always smaller than one.
 */
void
lp_build_ifloor_fract_safe(struct lp_build_context *bld,
                           LLVMValueRef a,
                           LLVMValueRef *out_ipart,
                           LLVMValueRef *out_fpart)
{
   lp_build_ifloor_fract(bld, a, out_ipart, out_fpart);
   *out_fpart = clamp_fract(bld, *out_fpart);
}


d1513 1
d1516 1
a1516 6
   if (type.length == 1) {
      util_snprintf(intrinsic, sizeof intrinsic, "llvm.sqrt.f%u", type.width);
   }
   else {
      util_snprintf(intrinsic, sizeof intrinsic, "llvm.sqrt.v%uf%u", type.length, type.width);
   }
d1580 1
a1580 1
    *   dependent
d1587 1
a1587 2
   if (FALSE && ((util_cpu_caps.has_sse && type.width == 32 && type.length == 4) ||
         (util_cpu_caps.has_avx && type.width == 32 && type.length == 8))){
a1590 8
      const char *intrinsic = NULL;

      if (type.length == 4) {
         intrinsic = "llvm.x86.sse.rcp.ps";
      }
      else {
         intrinsic = "llvm.x86.avx.rcp.ps.256";
      }
d1592 1
a1592 1
      res = lp_build_intrinsic_unary(builder, intrinsic, bld->vec_type, a);
d1610 2
a1611 1
 * See also Intel 64 and IA-32 Architectures Optimization Manual.
d1634 1
a1634 2
 * Generate 1/sqrt(a).
 * Result is undefined for values < 0, infinity for +0.
d1647 2
a1648 5
   /*
    * This should be faster but all denormals will end up as infinity.
    */
   if (0 && lp_build_fast_rsqrt_available(type)) {
      const unsigned num_iterations = 1;
d1652 1
a1652 2
      /* rsqrt(1.0) != 1.0 here */
      res = lp_build_fast_rsqrt(bld, a);
d1654 2
a1655 28
      if (num_iterations) {
         /*
          * Newton-Raphson will result in NaN instead of infinity for zero,
          * and NaN instead of zero for infinity.
          * Also, need to ensure rsqrt(1.0) == 1.0.
          * All numbers smaller than FLT_MIN will result in +infinity
          * (rsqrtps treats all denormals as zero).
          */
         /*
          * Certain non-c99 compilers don't know INFINITY and might not support
          * hacks to evaluate it at compile time neither.
          */
         const unsigned posinf_int = 0x7F800000;
         LLVMValueRef cmp;
         LLVMValueRef flt_min = lp_build_const_vec(bld->gallivm, type, FLT_MIN);
         LLVMValueRef inf = lp_build_const_int_vec(bld->gallivm, type, posinf_int);

         inf = LLVMBuildBitCast(builder, inf, lp_build_vec_type(bld->gallivm, type), "");

         for (i = 0; i < num_iterations; ++i) {
            res = lp_build_rsqrt_refine(bld, a, res);
         }
         cmp = lp_build_compare(bld->gallivm, type, PIPE_FUNC_LESS, a, flt_min);
         res = lp_build_select(bld, cmp, inf, res);
         cmp = lp_build_compare(bld->gallivm, type, PIPE_FUNC_EQUAL, a, inf);
         res = lp_build_select(bld, cmp, bld->zero, res);
         cmp = lp_build_compare(bld->gallivm, type, PIPE_FUNC_EQUAL, a, bld->one);
         res = lp_build_select(bld, cmp, bld->one, res);
d1664 3
a1666 9
/**
 * If there's a fast (inaccurate) rsqrt instruction available
 * (caller may want to avoid to call rsqrt_fast if it's not available,
 * i.e. for calculating x^0.5 it may do rsqrt_fast(x) * x but if
 * unavailable it would result in sqrt/div/mul so obviously
 * much better to just call sqrt, skipping both div and mul).
 */
boolean
lp_build_fast_rsqrt_available(struct lp_type type)
d1668 3
a1670 7
   assert(type.floating);

   if ((util_cpu_caps.has_sse && type.width == 32 && type.length == 4) ||
       (util_cpu_caps.has_avx && type.width == 32 && type.length == 8)) {
      return true;
   }
   return false;
d1673 2
a1674 10

/**
 * Generate 1/sqrt(a).
 * Result is undefined for values < 0, infinity for +0.
 * Precision is limited, only ~10 bits guaranteed
 * (rsqrt 1.0 may not be 1.0, denorms may be flushed to 0).
 */
LLVMValueRef
lp_build_fast_rsqrt(struct lp_build_context *bld,
                    LLVMValueRef a)
d1676 3
a1678 20
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_type type = bld->type;

   assert(lp_check_value(type, a));

   if (lp_build_fast_rsqrt_available(type)) {
      const char *intrinsic = NULL;

      if (type.length == 4) {
         intrinsic = "llvm.x86.sse.rsqrt.ps";
      }
      else {
         intrinsic = "llvm.x86.avx.rsqrt.ps.256";
      }
      return lp_build_intrinsic_unary(builder, intrinsic, bld->vec_type, a);
   }
   else {
      debug_printf("%s: emulating fast rsqrt with rcp/sqrt\n", __FUNCTION__);
   }
   return lp_build_rcp(bld, lp_build_sqrt(bld, a));
d1689 1
a1690 1
   LLVMBuilderRef builder = gallivm->builder;
d1693 2
d1701 2
a1702 2
   LLVMValueRef inv_sig_mask = lp_build_const_int_vec(gallivm, bld->type, ~0x80000000);
   LLVMValueRef a_v4si = LLVMBuildBitCast(b, a, bld->int_vec_type, "a_v4si");
d1705 1
a1705 1
   LLVMValueRef x_abs = LLVMBuildBitCast(b, absi, bld->vec_type, "x_abs");
d1711 1
a1711 1
   LLVMValueRef sig_mask = lp_build_const_int_vec(gallivm, bld->type, 0x80000000);
d1719 1
a1719 1
   LLVMValueRef FOPi = lp_build_const_vec(gallivm, bld->type, 1.27323954473516);
d1727 1
a1727 1
   LLVMValueRef emm2_i = LLVMBuildFPToSI(b, scale_y, bld->int_vec_type, "emm2_i");
d1734 1
a1734 1
   LLVMValueRef all_one = lp_build_const_int_vec(gallivm, bld->type, 1);
d1739 1
a1739 1
   LLVMValueRef inv_one = lp_build_const_int_vec(gallivm, bld->type, ~1);
d1745 1
a1745 1
   LLVMValueRef y_2 = LLVMBuildSIToFP(b, emm2_and, bld->vec_type, "y_2");
d1750 1
a1750 1
   LLVMValueRef pi32_4 = lp_build_const_int_vec(gallivm, bld->type, 4);
d1756 1
a1756 1
   LLVMValueRef const_29 = lp_build_const_int_vec(gallivm, bld->type, 29);
d1769 1
a1769 1
   LLVMValueRef pi32_2 = lp_build_const_int_vec(gallivm, bld->type, 2);
d1771 1
a1771 1
   LLVMValueRef poly_mask = lp_build_compare(gallivm,
d1773 1
a1773 1
                                             emm2_3, lp_build_const_int_vec(gallivm, bld->type, 0));
d1784 3
a1786 3
   LLVMValueRef DP1 = lp_build_const_vec(gallivm, bld->type, -0.78515625);
   LLVMValueRef DP2 = lp_build_const_vec(gallivm, bld->type, -2.4187564849853515625e-4);
   LLVMValueRef DP3 = lp_build_const_vec(gallivm, bld->type, -3.77489497744594108e-8);
d1821 3
a1823 3
   LLVMValueRef coscof_p0 = lp_build_const_vec(gallivm, bld->type, 2.443315711809948E-005);
   LLVMValueRef coscof_p1 = lp_build_const_vec(gallivm, bld->type, -1.388731625493765E-003);
   LLVMValueRef coscof_p2 = lp_build_const_vec(gallivm, bld->type, 4.166664568298827E-002);
d1842 1
a1842 1
   LLVMValueRef half = lp_build_const_vec(gallivm, bld->type, 0.5);
d1845 1
a1845 1
   LLVMValueRef one = lp_build_const_vec(gallivm, bld->type, 1.0);
d1853 3
a1855 3
   LLVMValueRef sincof_p0 = lp_build_const_vec(gallivm, bld->type, -1.9515295891E-4);
   LLVMValueRef sincof_p1 = lp_build_const_vec(gallivm, bld->type, 8.3321608736E-3);
   LLVMValueRef sincof_p2 = lp_build_const_vec(gallivm, bld->type, -1.6666654611E-1);
d1883 1
a1883 1
    * y = _mm_or_ps(y,y2);
d1885 2
a1886 2
   LLVMValueRef y2_i = LLVMBuildBitCast(b, y2_9, bld->int_vec_type, "y2_i");
   LLVMValueRef y_i = LLVMBuildBitCast(b, y_10, bld->int_vec_type, "y_i");
d1888 2
a1889 1
   LLVMValueRef poly_mask_inv = LLVMBuildNot(b, poly_mask, "poly_mask_inv");
d1891 1
a1891 1
   LLVMValueRef y_combine = LLVMBuildOr(b, y_and, y2_and, "y_combine");
d1898 1
a1898 1
   LLVMValueRef y_result = LLVMBuildBitCast(b, y_sign, bld->vec_type, "y_result");
d1910 1
a1911 1
   LLVMBuilderRef builder = gallivm->builder;
d1914 2
d1922 2
a1923 2
   LLVMValueRef inv_sig_mask = lp_build_const_int_vec(gallivm, bld->type, ~0x80000000);
   LLVMValueRef a_v4si = LLVMBuildBitCast(b, a, bld->int_vec_type, "a_v4si");
d1926 1
a1926 1
   LLVMValueRef x_abs = LLVMBuildBitCast(b, absi, bld->vec_type, "x_abs");
d1933 1
a1933 1
   LLVMValueRef FOPi = lp_build_const_vec(gallivm, bld->type, 1.27323954473516);
d1941 1
a1941 1
   LLVMValueRef emm2_i = LLVMBuildFPToSI(b, scale_y, bld->int_vec_type, "emm2_i");
d1948 1
a1948 1
   LLVMValueRef all_one = lp_build_const_int_vec(gallivm, bld->type, 1);
d1953 1
a1953 1
   LLVMValueRef inv_one = lp_build_const_int_vec(gallivm, bld->type, ~1);
d1959 1
a1959 1
   LLVMValueRef y_2 = LLVMBuildSIToFP(b, emm2_and, bld->vec_type, "y_2");
d1965 1
a1965 1
   LLVMValueRef const_2 = lp_build_const_int_vec(gallivm, bld->type, 2);
d1972 1
a1972 1
   LLVMValueRef inv = lp_build_const_int_vec(gallivm, bld->type, ~0);
d1974 1
a1974 1
   LLVMValueRef pi32_4 = lp_build_const_int_vec(gallivm, bld->type, 4);
d1980 1
a1980 1
   LLVMValueRef const_29 = lp_build_const_int_vec(gallivm, bld->type, 29);
d1993 1
a1993 1
   LLVMValueRef pi32_2 = lp_build_const_int_vec(gallivm, bld->type, 2);
d1995 1
a1995 1
   LLVMValueRef poly_mask = lp_build_compare(gallivm,
d1997 1
a1997 1
   				             emm2_3, lp_build_const_int_vec(gallivm, bld->type, 0));
d2004 3
a2006 3
   LLVMValueRef DP1 = lp_build_const_vec(gallivm, bld->type, -0.78515625);
   LLVMValueRef DP2 = lp_build_const_vec(gallivm, bld->type, -2.4187564849853515625e-4);
   LLVMValueRef DP3 = lp_build_const_vec(gallivm, bld->type, -3.77489497744594108e-8);
d2041 3
a2043 3
   LLVMValueRef coscof_p0 = lp_build_const_vec(gallivm, bld->type, 2.443315711809948E-005);
   LLVMValueRef coscof_p1 = lp_build_const_vec(gallivm, bld->type, -1.388731625493765E-003);
   LLVMValueRef coscof_p2 = lp_build_const_vec(gallivm, bld->type, 4.166664568298827E-002);
d2062 1
a2062 1
   LLVMValueRef half = lp_build_const_vec(gallivm, bld->type, 0.5);
d2065 1
a2065 1
   LLVMValueRef one = lp_build_const_vec(gallivm, bld->type, 1.0);
d2073 3
a2075 3
   LLVMValueRef sincof_p0 = lp_build_const_vec(gallivm, bld->type, -1.9515295891E-4);
   LLVMValueRef sincof_p1 = lp_build_const_vec(gallivm, bld->type, 8.3321608736E-3);
   LLVMValueRef sincof_p2 = lp_build_const_vec(gallivm, bld->type, -1.6666654611E-1);
d2103 1
a2103 1
    * y = _mm_or_ps(y,y2);
d2105 2
a2106 2
   LLVMValueRef y2_i = LLVMBuildBitCast(b, y2_9, bld->int_vec_type, "y2_i");
   LLVMValueRef y_i = LLVMBuildBitCast(b, y_10, bld->int_vec_type, "y_i");
d2108 1
a2108 1
   LLVMValueRef poly_mask_inv = LLVMBuildNot(b, poly_mask, "poly_mask_inv");
d2110 1
a2110 1
   LLVMValueRef y_combine = LLVMBuildOr(b, y_and, y2_and, "y_combine");
d2117 1
a2117 1
   LLVMValueRef y_result = LLVMBuildBitCast(b, y_sign, bld->vec_type, "y_result");
d2154 1
a2154 1
   return lp_build_exp2(bld, lp_build_mul(bld, log2e, x));
d2171 1
a2171 1
   return lp_build_mul(bld, log2, lp_build_log2(bld, x));
d2179 1
a2179 1
LLVMValueRef
d2186 1
a2186 2
   LLVMValueRef even = NULL, odd = NULL;
   LLVMValueRef x2;
a2197 8
   /*
    * Calculate odd and even terms seperately to decrease data dependency
    * Ex:
    *     c[0] + x^2 * c[2] + x^4 * c[4] ...
    *     + x * (c[1] + x^2 * c[3] + x^4 * c[5]) ...
    */
   x2 = lp_build_mul(bld, x, x);

d2203 4
a2206 11
      if (i % 2 == 0) {
         if (even)
            even = lp_build_add(bld, coeff, lp_build_mul(bld, x2, even));
         else
            even = coeff;
      } else {
         if (odd)
            odd = lp_build_add(bld, coeff, lp_build_mul(bld, x2, odd));
         else
            odd = coeff;
      }
d2209 2
a2210 4
   if (odd)
      return lp_build_add(bld, lp_build_mul(bld, odd, x), even);
   else if (even)
      return even;
d2221 6
a2226 6
   0.999999925063526176901,
   0.693153073200168932794,
   0.240153617044375388211,
   0.0558263180532956664775,
   0.00898934009049466391101,
   0.00187757667519147912699
d2228 5
a2232 5
   1.00000259337069434683,
   0.693003834469974940458,
   0.24144275689150793076,
   0.0520114606103070150235,
   0.0135341679161270268764
d2258 1
d2281 2
d2284 1
a2284 1
      lp_build_ifloor_fract(bld, x, &ipart, &fpart);
d2289 1
d2397 1
a2397 1
 * Minimax polynomial fit of log2((1.0 + sqrt(x))/(1.0 - sqrt(x)))/sqrt(x) ,for x in range of [0, 1/9[
d2402 13
a2414 7
#if LOG_POLY_DEGREE == 5
   2.88539008148777786488L,
   0.961796878841293367824L,
   0.577058946784739859012L,
   0.412914355135828735411L,
   0.308591899232910175289L,
   0.352376952300281371868L,
d2416 4
a2419 5
   2.88539009343309178325L,
   0.961791550404184197881L,
   0.577440339438736392009L,
   0.403343858251329912514L,
   0.406718052498846252698L,
d2421 3
a2423 4
   2.88538959748872753838L,
   0.961932915889597772928L,
   0.571118517972136195241L,
   0.493997535084709500285L,
d2429 1
a2431 2
 * http://en.wikipedia.org/wiki/Logarithm#Calculation
 * http://www.nezumi.demon.co.uk/consult/logx.htm
a2449 2
   LLVMValueRef y = NULL;
   LLVMValueRef z = NULL;
a2467 6
      /* 
       * We don't explicitly handle denormalized numbers. They will yield a
       * result in the neighbourhood of -127, which appears to be adequate
       * enough.
       */

d2481 1
a2481 1
      /* mant = 1 + (float) mantissa(x) */
d2486 1
a2486 11
      /* y = (mant - 1) / (mant + 1) */
      y = lp_build_div(bld,
         lp_build_sub(bld, mant, bld->one),
         lp_build_add(bld, mant, bld->one)
      );

      /* z = y^2 */
      z = lp_build_mul(bld, y, y);

      /* compute P(z) */
      logmant = lp_build_polynomial(bld, z, lp_build_log2_polynomial,
d2489 2
a2490 2
      /* logmant = y * P(z) */
      logmant = lp_build_mul(bld, y, logmant);
d2492 1
a2492 1
      res = lp_build_add(bld, logmant, logexp);
a2575 21
}

LLVMValueRef
lp_build_mod(struct lp_build_context *bld,
             LLVMValueRef x,
             LLVMValueRef y)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef res;
   const struct lp_type type = bld->type;

   assert(lp_check_value(type, x));
   assert(lp_check_value(type, y));

   if (type.floating)
      res = LLVMBuildFRem(builder, x, y, "");
   else if (type.sign)
      res = LLVMBuildSRem(builder, x, y, "");
   else
      res = LLVMBuildURem(builder, x, y, "");
   return res;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a66 11
#if defined(PIPE_ARCH_SSE)
#include <xmmintrin.h>
#endif

#ifndef _MM_DENORMALS_ZERO_MASK
#define _MM_DENORMALS_ZERO_MASK 0x0040
#endif

#ifndef _MM_FLUSH_ZERO_MASK
#define _MM_FLUSH_ZERO_MASK 0x8000
#endif
a75 2
 * NaN's are handled according to the behavior specified by the
 * nan_behavior argument.
d80 1
a80 2
                    LLVMValueRef b,
                    enum gallivm_nan_behavior nan_behavior)
a122 4
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
         debug_printf("%s: altivec doesn't support nan return nan behavior\n",
                      __FUNCTION__);
      }
d134 1
a134 1
      }
d150 1
a150 1
         }
d156 20
a175 20
      intr_size = 128;
      if (type.width == 8) {
         if (!type.sign) {
            intrinsic = "llvm.ppc.altivec.vminub";
         } else {
            intrinsic = "llvm.ppc.altivec.vminsb";
         }
      } else if (type.width == 16) {
         if (!type.sign) {
            intrinsic = "llvm.ppc.altivec.vminuh";
         } else {
            intrinsic = "llvm.ppc.altivec.vminsh";
         }
      } else if (type.width == 32) {
         if (!type.sign) {
            intrinsic = "llvm.ppc.altivec.vminuw";
         } else {
            intrinsic = "llvm.ppc.altivec.vminsw";
         }
      }
d179 3
a181 26
      /* We need to handle nan's for floating point numbers. If one of the
       * inputs is nan the other should be returned (required by both D3D10+
       * and OpenCL).
       * The sse intrinsics return the second operator in case of nan by
       * default so we need to special code to handle those.
       */
      if (util_cpu_caps.has_sse && type.floating &&
          nan_behavior != GALLIVM_NAN_BEHAVIOR_UNDEFINED &&
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
         LLVMValueRef isnan, max;
         max = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                   type,
                                                   intr_size, a, b);
         if (nan_behavior == GALLIVM_NAN_RETURN_OTHER) {
            isnan = lp_build_isnan(bld, b);
            return lp_build_select(bld, isnan, a, max);
         } else {
            assert(nan_behavior == GALLIVM_NAN_RETURN_NAN);
            isnan = lp_build_isnan(bld, a);
            return lp_build_select(bld, isnan, a, max);
         }
      } else {
         return lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                    type,
                                                    intr_size, a, b);
      }
d184 2
a185 32
   if (type.floating) {
      switch (nan_behavior) {
      case GALLIVM_NAN_RETURN_NAN: {
         LLVMValueRef isnan = lp_build_isnan(bld, b);
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
         cond = LLVMBuildXor(bld->gallivm->builder, cond, isnan, "");
         return lp_build_select(bld, cond, a, b);
      }
         break;
      case GALLIVM_NAN_RETURN_OTHER: {
         LLVMValueRef isnan = lp_build_isnan(bld, a);
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
         cond = LLVMBuildXor(bld->gallivm->builder, cond, isnan, "");
         return lp_build_select(bld, cond, a, b);
      }
         break;
      case GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN:
         cond = lp_build_cmp_ordered(bld, PIPE_FUNC_LESS, a, b);
         return lp_build_select(bld, cond, a, b);
      case GALLIVM_NAN_BEHAVIOR_UNDEFINED:
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
         return lp_build_select(bld, cond, a, b);
         break;
      default:
         assert(0);
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
         return lp_build_select(bld, cond, a, b);
      }
   } else {
      cond = lp_build_cmp(bld, PIPE_FUNC_LESS, a, b);
      return lp_build_select(bld, cond, a, b);
   }
a191 2
 * NaN's are handled according to the behavior specified by the
 * nan_behavior argument.
d196 1
a196 2
                    LLVMValueRef b,
                    enum gallivm_nan_behavior nan_behavior)
a238 4
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
         debug_printf("%s: altivec doesn't support nan return nan behavior\n",
                      __FUNCTION__);
      }
d296 3
a298 20
      if (util_cpu_caps.has_sse && type.floating &&
          nan_behavior != GALLIVM_NAN_BEHAVIOR_UNDEFINED &&
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
         LLVMValueRef isnan, min;
         min = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                   type,
                                                   intr_size, a, b);
         if (nan_behavior == GALLIVM_NAN_RETURN_OTHER) {
            isnan = lp_build_isnan(bld, b);
            return lp_build_select(bld, isnan, a, min);
         } else {
            assert(nan_behavior == GALLIVM_NAN_RETURN_NAN);
            isnan = lp_build_isnan(bld, a);
            return lp_build_select(bld, isnan, a, min);
         }
      } else {
         return lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                    type,
                                                    intr_size, a, b);
      }
d301 2
a302 32
   if (type.floating) {
      switch (nan_behavior) {
      case GALLIVM_NAN_RETURN_NAN: {
         LLVMValueRef isnan = lp_build_isnan(bld, b);
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
         cond = LLVMBuildXor(bld->gallivm->builder, cond, isnan, "");
         return lp_build_select(bld, cond, a, b);
      }
         break;
      case GALLIVM_NAN_RETURN_OTHER: {
         LLVMValueRef isnan = lp_build_isnan(bld, a);
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
         cond = LLVMBuildXor(bld->gallivm->builder, cond, isnan, "");
         return lp_build_select(bld, cond, a, b);
      }
         break;
      case GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN:
         cond = lp_build_cmp_ordered(bld, PIPE_FUNC_GREATER, a, b);
         return lp_build_select(bld, cond, a, b);
      case GALLIVM_NAN_BEHAVIOR_UNDEFINED:
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
         return lp_build_select(bld, cond, a, b);
         break;
      default:
         assert(0);
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
         return lp_build_select(bld, cond, a, b);
      }
   } else {
      cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, a, b);
      return lp_build_select(bld, cond, a, b);
   }
d392 1
a392 1
      a = lp_build_min_simple(bld, a, lp_build_comp(bld, b), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
d407 1
a407 1
      res = lp_build_min_simple(bld, res, bld->one, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
d673 1
a673 1
      a = lp_build_max_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
d687 1
a687 1
      res = lp_build_max_simple(bld, res, bld->zero, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
d1147 1
a1147 1
 * Do checks for special cases but not for nans.
d1175 1
a1175 1
   return lp_build_min_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
a1179 35
 * Generate min(a, b)
 * NaN's are handled according to the behavior specified by the
 * nan_behavior argument.
 */
LLVMValueRef
lp_build_min_ext(struct lp_build_context *bld,
                 LLVMValueRef a,
                 LLVMValueRef b,
                 enum gallivm_nan_behavior nan_behavior)
{
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, b));

   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if(a == b)
      return a;

   if (bld->type.norm) {
      if (!bld->type.sign) {
         if (a == bld->zero || b == bld->zero) {
            return bld->zero;
         }
      }
      if(a == bld->one)
         return b;
      if(b == bld->one)
         return a;
   }

   return lp_build_min_simple(bld, a, b, nan_behavior);
}

/**
d1181 1
a1181 1
 * Do checks for special cases, but NaN behavior is undefined.
d1210 1
a1210 1
   return lp_build_max_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
a1214 37
 * Generate max(a, b)
 * Checks for special cases.
 * NaN's are handled according to the behavior specified by the
 * nan_behavior argument.
 */
LLVMValueRef
lp_build_max_ext(struct lp_build_context *bld,
                  LLVMValueRef a,
                  LLVMValueRef b,
                  enum gallivm_nan_behavior nan_behavior)
{
   assert(lp_check_value(bld->type, a));
   assert(lp_check_value(bld->type, b));

   if(a == bld->undef || b == bld->undef)
      return bld->undef;

   if(a == b)
      return a;

   if(bld->type.norm) {
      if(a == bld->one || b == bld->one)
         return bld->one;
      if (!bld->type.sign) {
         if (a == bld->zero) {
            return b;
         }
         if (b == bld->zero) {
            return a;
         }
      }
   }

   return lp_build_max_simple(bld, a, b, nan_behavior);
}

/**
a1215 1
 * NaN behavior (for any of a, min, max) is undefined.
a1234 14
 * Generate clamp(a, 0, 1)
 * A NaN will get converted to zero.
 */
LLVMValueRef
lp_build_clamp_zero_one_nanzero(struct lp_build_context *bld,
                                LLVMValueRef a)
{
   a = lp_build_max_ext(bld, a, bld->zero, GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
   a = lp_build_min(bld, a, bld->one);
   return a;
}


/**
d2407 1
a2407 6
 * Generate sin(a) or cos(a) using polynomial approximation.
 * TODO: it might be worth recognizing sin and cos using same source
 * (i.e. d3d10 sincos opcode). Obviously doing both at the same time
 * would be way cheaper than calculating (nearly) everything twice...
 * Not sure it's common enough to be worth bothering however, scs
 * opcode could also benefit from calculating both though.
d2409 3
a2411 4
static LLVMValueRef
lp_build_sin_or_cos(struct lp_build_context *bld,
                    LLVMValueRef a,
                    boolean cos)
d2414 1
a2414 1
   LLVMBuilderRef b = gallivm->builder;
d2416 1
d2430 7
d2440 1
a2440 1

d2448 1
a2448 1

d2469 9
a2477 2
   LLVMValueRef const_2 = lp_build_const_int_vec(gallivm, bld->type, 2);
   LLVMValueRef const_4 = lp_build_const_int_vec(gallivm, bld->type, 4);
d2479 1
a2479 1
   LLVMValueRef sign_mask = lp_build_const_int_vec(gallivm, bld->type, 0x80000000);
d2482 1
a2482 16
    * Argument used for poly selection and sign bit determination
    * is different for sin vs. cos.
    */
   LLVMValueRef emm2_2 = cos ? LLVMBuildSub(b, emm2_and, const_2, "emm2_2") :
                               emm2_and;

   LLVMValueRef sign_bit = cos ? LLVMBuildShl(b, LLVMBuildAnd(b, const_4,
                                                              LLVMBuildNot(b, emm2_2, ""), ""),
                                              const_29, "sign_bit") :
                                 LLVMBuildAnd(b, LLVMBuildXor(b, a_v4si,
                                                              LLVMBuildShl(b, emm2_add,
                                                                           const_29, ""), ""),
                                              sign_mask, "sign_bit");

   /*
    * get the polynom selection mask
d2486 1
a2486 1
    *
d2491 2
a2492 1
   LLVMValueRef emm2_3 =  LLVMBuildAnd(b, emm2_2, const_2, "emm2_3");
d2496 4
d2511 2
a2512 2
    * The magic pass: "Extended precision modular arithmetic"
    * x = ((x - y * DP1) - y * DP2) - y * DP3;
d2525 1
a2525 1
    */
d2563 1
a2563 1
    */
d2618 1
a2618 1
   LLVMValueRef y_sign = LLVMBuildXor(b, y_combine, sign_bit, "y_sign");
a2619 10

   LLVMValueRef isfinite = lp_build_isfinite(bld, a);

   /* clamp output to be within [-1, 1] */
   y_result = lp_build_clamp(bld, y_result,
                             lp_build_const_vec(bld->gallivm, bld->type,  -1.f),
                             lp_build_const_vec(bld->gallivm, bld->type,  1.f));
   /* If a is -inf, inf or NaN then return NaN */
   y_result = lp_build_select(bld, isfinite, y_result,
                              lp_build_const_vec(bld->gallivm, bld->type,  NAN));
d2625 1
a2625 1
 * Generate sin(a)
d2628 1
a2628 1
lp_build_sin(struct lp_build_context *bld,
d2631 185
a2815 2
   return lp_build_sin_or_cos(bld, a, FALSE);
}
d2817 13
d2831 7
a2837 8
/**
 * Generate cos(a)
 */
LLVMValueRef
lp_build_cos(struct lp_build_context *bld,
             LLVMValueRef a)
{
   return lp_build_sin_or_cos(bld, a, TRUE);
a2878 1
 * Behavior is undefined with infs, 0s and nans
a2892 16
/**
 * Generate log(x) that handles edge cases (infs, 0s and nans)
 */
LLVMValueRef
lp_build_log_safe(struct lp_build_context *bld,
                  LLVMValueRef x)
{
   /* log(2) */
   LLVMValueRef log2 = lp_build_const_vec(bld->gallivm, bld->type,
                                          0.69314718055994529);

   assert(lp_check_value(bld->type, x));

   return lp_build_mul(bld, log2, lp_build_log2_safe(bld, x));
}

d2958 1
a2958 1
   1.000000000000000000000, /*XXX: was 0.999999925063526176901, recompute others */
d2985 6
a2990 3
LLVMValueRef
lp_build_exp2(struct lp_build_context *bld,
              LLVMValueRef x)
d3003 7
d3011 1
a3011 6
   /* TODO: optimize the constant case */
   if (gallivm_debug & GALLIVM_DEBUG_PERF &&
       LLVMIsConstant(x)) {
      debug_printf("%s: inefficient/imprecise constant arithmetic\n",
                   __FUNCTION__);
   }
d3013 2
a3014 1
   assert(type.floating && type.width == 32);
d3016 4
a3019 5
   /* We want to preserve NaN and make sure than for exp2 if x > 128,
    * the result is INF  and if it's smaller than -126.9 the result is 0 */
   x = lp_build_min_ext(bld, lp_build_const_vec(bld->gallivm, type,  128.0), x,
                        GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
   x = lp_build_max(bld, lp_build_const_vec(bld->gallivm, type, -126.99999), x);
d3021 8
a3028 3
   /* ipart = floor(x) */
   /* fpart = x - ipart */
   lp_build_ifloor_fract(bld, x, &ipart, &fpart);
d3030 3
d3034 2
d3037 2
a3038 6
   /* expipart = (float) (1 << ipart) */
   expipart = LLVMBuildAdd(builder, ipart,
                           lp_build_const_int_vec(bld->gallivm, type, 127), "");
   expipart = LLVMBuildShl(builder, expipart,
                           lp_build_const_int_vec(bld->gallivm, type, 23), "");
   expipart = LLVMBuildBitCast(builder, expipart, vec_type, "");
d3040 2
d3043 3
a3045 4
   expfpart = lp_build_polynomial(bld, fpart, lp_build_exp2_polynomial,
                                  Elements(lp_build_exp2_polynomial));

   res = LLVMBuildFMul(builder, expipart, expfpart, "");
d3048 6
a3057 1

a3161 11
 *
 * If handle_edge_cases is true the function will perform computations
 * to match the required D3D10+ behavior for each of the edge cases.
 * That means that if input is:
 * - less than zero (to and including -inf) then NaN will be returned
 * - equal to zero (-denorm, -0, +0 or +denorm), then -inf will be returned
 * - +infinity, then +infinity will be returned
 * - NaN, then NaN will be returned
 *
 * Those checks are fairly expensive so if you don't need them make sure
 * handle_edge_cases is false.
d3168 1
a3168 2
                     LLVMValueRef *p_log2,
                     boolean handle_edge_cases)
a3240 23

      if (type.floating && handle_edge_cases) {
         LLVMValueRef negmask, infmask,  zmask;
         negmask = lp_build_cmp(bld, PIPE_FUNC_LESS, x,
                                lp_build_const_vec(bld->gallivm, type,  0.0f));
         zmask = lp_build_cmp(bld, PIPE_FUNC_EQUAL, x,
                              lp_build_const_vec(bld->gallivm, type,  0.0f));
         infmask = lp_build_cmp(bld, PIPE_FUNC_GEQUAL, x,
                                lp_build_const_vec(bld->gallivm, type,  INFINITY));

         /* If x is qual to inf make sure we return inf */
         res = lp_build_select(bld, infmask,
                               lp_build_const_vec(bld->gallivm, type,  INFINITY),
                               res);
         /* If x is qual to 0, return -inf */
         res = lp_build_select(bld, zmask,
                               lp_build_const_vec(bld->gallivm, type,  -INFINITY),
                               res);
         /* If x is nan or less than 0, return nan */
         res = lp_build_select(bld, negmask,
                               lp_build_const_vec(bld->gallivm, type,  NAN),
                               res);
      }
a3255 5
/*
 * log2 implementation which doesn't have special code to
 * handle edge cases (-inf, 0, inf, NaN). It's faster but
 * the results for those cases are undefined.
 */
d3261 1
a3261 15
   lp_build_log2_approx(bld, x, NULL, NULL, &res, FALSE);
   return res;
}

/*
 * Version of log2 which handles all edge cases.
 * Look at documentation of lp_build_log2_approx for
 * description of the behavior for each of the edge cases.
 */
LLVMValueRef
lp_build_log2_safe(struct lp_build_context *bld,
                   LLVMValueRef x)
{
   LLVMValueRef res;
   lp_build_log2_approx(bld, x, NULL, NULL, &res, TRUE);
a3344 140
}


/*
 * For floating inputs it creates and returns a mask
 * which is all 1's for channels which are NaN.
 * Channels inside x which are not NaN will be 0.
 */
LLVMValueRef
lp_build_isnan(struct lp_build_context *bld,
               LLVMValueRef x)
{
   LLVMValueRef mask;
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, bld->type);

   assert(bld->type.floating);
   assert(lp_check_value(bld->type, x));

   mask = LLVMBuildFCmp(bld->gallivm->builder, LLVMRealOEQ, x, x,
                        "isnotnan");
   mask = LLVMBuildNot(bld->gallivm->builder, mask, "");
   mask = LLVMBuildSExt(bld->gallivm->builder, mask, int_vec_type, "isnan");
   return mask;
}

/* Returns all 1's for floating point numbers that are
 * finite numbers and returns all zeros for -inf,
 * inf and nan's */
LLVMValueRef
lp_build_isfinite(struct lp_build_context *bld,
                  LLVMValueRef x)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(bld->gallivm, bld->type);
   struct lp_type int_type = lp_int_type(bld->type);
   LLVMValueRef intx = LLVMBuildBitCast(builder, x, int_vec_type, "");
   LLVMValueRef infornan32 = lp_build_const_int_vec(bld->gallivm, bld->type,
                                                    0x7f800000);

   if (!bld->type.floating) {
      return lp_build_const_int_vec(bld->gallivm, bld->type, 0);
   }
   assert(bld->type.floating);
   assert(lp_check_value(bld->type, x));
   assert(bld->type.width == 32);

   intx = LLVMBuildAnd(builder, intx, infornan32, "");
   return lp_build_compare(bld->gallivm, int_type, PIPE_FUNC_NOTEQUAL,
                           intx, infornan32);
}

/*
 * Returns true if the number is nan or inf and false otherwise.
 * The input has to be a floating point vector.
 */
LLVMValueRef
lp_build_is_inf_or_nan(struct gallivm_state *gallivm,
                       const struct lp_type type,
                       LLVMValueRef x)
{
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type int_type = lp_int_type(type);
   LLVMValueRef const0 = lp_build_const_int_vec(gallivm, int_type,
                                                0x7f800000);
   LLVMValueRef ret;

   assert(type.floating);

   ret = LLVMBuildBitCast(builder, x, lp_build_vec_type(gallivm, int_type), "");
   ret = LLVMBuildAnd(builder, ret, const0, "");
   ret = lp_build_compare(gallivm, int_type, PIPE_FUNC_EQUAL,
                          ret, const0);

   return ret;
}


LLVMValueRef
lp_build_fpstate_get(struct gallivm_state *gallivm)
{
   if (util_cpu_caps.has_sse) {
      LLVMBuilderRef builder = gallivm->builder;
      LLVMValueRef mxcsr_ptr = lp_build_alloca(
         gallivm,
         LLVMInt32TypeInContext(gallivm->context),
         "mxcsr_ptr");
      LLVMValueRef mxcsr_ptr8 = LLVMBuildPointerCast(builder, mxcsr_ptr,
          LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0), "");
      lp_build_intrinsic(builder,
                         "llvm.x86.sse.stmxcsr",
                         LLVMVoidTypeInContext(gallivm->context),
                         &mxcsr_ptr8, 1);
      return mxcsr_ptr;
   }
   return 0;
}

void
lp_build_fpstate_set_denorms_zero(struct gallivm_state *gallivm,
                                  boolean zero)
{
   if (util_cpu_caps.has_sse) {
      /* turn on DAZ (64) | FTZ (32768) = 32832 if available */
      int daz_ftz = _MM_FLUSH_ZERO_MASK;

      LLVMBuilderRef builder = gallivm->builder;
      LLVMValueRef mxcsr_ptr = lp_build_fpstate_get(gallivm);
      LLVMValueRef mxcsr =
         LLVMBuildLoad(builder, mxcsr_ptr, "mxcsr");

      if (util_cpu_caps.has_daz) {
         /* Enable denormals are zero mode */
         daz_ftz |= _MM_DENORMALS_ZERO_MASK;
      }
      if (zero) {
         mxcsr = LLVMBuildOr(builder, mxcsr,
                             LLVMConstInt(LLVMTypeOf(mxcsr), daz_ftz, 0), "");
      } else {
         mxcsr = LLVMBuildAnd(builder, mxcsr,
                              LLVMConstInt(LLVMTypeOf(mxcsr), ~daz_ftz, 0), "");
      }

      LLVMBuildStore(builder, mxcsr, mxcsr_ptr);
      lp_build_fpstate_set(gallivm, mxcsr_ptr);
   }
}

void
lp_build_fpstate_set(struct gallivm_state *gallivm,
                     LLVMValueRef mxcsr_ptr)
{
   if (util_cpu_caps.has_sse) {
      LLVMBuilderRef builder = gallivm->builder;
      mxcsr_ptr = LLVMBuildPointerCast(builder, mxcsr_ptr,
                     LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0), "");
      lp_build_intrinsic(builder,
                         "llvm.x86.sse.ldmxcsr",
                         LLVMVoidTypeInContext(gallivm->context),
                         &mxcsr_ptr, 1);
   }
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d137 1
a137 2
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN ||
          nan_behavior == GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN) {
d205 3
a207 4
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN &&
          nan_behavior != GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN) {
         LLVMValueRef isnan, min;
         min = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
d212 1
a212 1
            return lp_build_select(bld, isnan, a, min);
d216 1
a216 1
            return lp_build_select(bld, isnan, a, min);
a243 3
      case GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN:
         cond = lp_build_cmp(bld, PIPE_FUNC_LESS, b, a);
         return lp_build_select(bld, cond, b, a);
d313 1
a313 2
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN ||
          nan_behavior == GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN) {
d376 3
a378 4
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN &&
          nan_behavior != GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN) {
         LLVMValueRef isnan, max;
         max = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
d383 1
a383 1
            return lp_build_select(bld, isnan, a, max);
d387 1
a387 1
            return lp_build_select(bld, isnan, a, max);
a414 3
      case GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN:
         cond = lp_build_cmp(bld, PIPE_FUNC_GREATER, b, a);
         return lp_build_select(bld, cond, b, a);
d515 3
a517 14
   if(type.norm && !type.floating && !type.fixed) {
      if (type.sign) {
         uint64_t sign = (uint64_t)1 << (type.width - 1);
         LLVMValueRef max_val = lp_build_const_int_vec(bld->gallivm, type, sign - 1);
         LLVMValueRef min_val = lp_build_const_int_vec(bld->gallivm, type, sign);
         /* a_clamp_max is the maximum a for positive b,
            a_clamp_min is the minimum a for negative b. */
         LLVMValueRef a_clamp_max = lp_build_min_simple(bld, a, LLVMBuildSub(builder, max_val, b, ""), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
         LLVMValueRef a_clamp_min = lp_build_max_simple(bld, a, LLVMBuildSub(builder, min_val, b, ""), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
         a = lp_build_select(bld, lp_build_cmp(bld, PIPE_FUNC_GREATER, b, bld->zero), a_clamp_max, a_clamp_min);
      } else {
         a = lp_build_min_simple(bld, a, lp_build_comp(bld, b), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
      }
   }
d796 3
a798 14
   if(type.norm && !type.floating && !type.fixed) {
      if (type.sign) {
         uint64_t sign = (uint64_t)1 << (type.width - 1);
         LLVMValueRef max_val = lp_build_const_int_vec(bld->gallivm, type, sign - 1);
         LLVMValueRef min_val = lp_build_const_int_vec(bld->gallivm, type, sign);
         /* a_clamp_max is the maximum a for negative b,
            a_clamp_min is the minimum a for positive b. */
         LLVMValueRef a_clamp_max = lp_build_min_simple(bld, a, LLVMBuildAdd(builder, max_val, b, ""), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
         LLVMValueRef a_clamp_min = lp_build_max_simple(bld, a, LLVMBuildAdd(builder, min_val, b, ""), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
         a = lp_build_select(bld, lp_build_cmp(bld, PIPE_FUNC_GREATER, b, bld->zero), a_clamp_min, a_clamp_max);
      } else {
         a = lp_build_max_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
      }
   }
d1066 1
a1066 1
   if(a == bld->one && type.floating)
d1502 1
d1506 1
d1855 1
a1855 1
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 1<<24);
d1910 1
a1910 1
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 1<<24);
d1963 1
a1963 1
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 1<<24);
d2032 1
a2032 1
      LLVMValueRef cmpval = lp_build_const_vec(bld->gallivm, type, 1<<24);
d3045 1
d3058 2
a3059 3
                        GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN);
   x = lp_build_max_ext(bld, lp_build_const_vec(bld->gallivm, type, -126.99999),
                        x, GALLIVM_NAN_RETURN_NAN_FIRST_NONNAN);
d3065 2
d3074 1
d3079 1
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d137 2
a138 1
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
d206 4
a209 3
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
         LLVMValueRef isnan, max;
         max = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
d214 1
a214 1
            return lp_build_select(bld, isnan, a, max);
d218 1
a218 1
            return lp_build_select(bld, isnan, a, max);
d246 3
d318 2
a319 1
      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
d382 4
a385 3
          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
         LLVMValueRef isnan, min;
         min = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
d390 1
a390 1
            return lp_build_select(bld, isnan, a, min);
d394 1
a394 1
            return lp_build_select(bld, isnan, a, min);
d422 3
d525 14
a538 3
   /* TODO: handle signed case */
   if(type.norm && !type.floating && !type.fixed && !type.sign)
      a = lp_build_min_simple(bld, a, lp_build_comp(bld, b), GALLIVM_NAN_BEHAVIOR_UNDEFINED);
d817 14
a830 3
   /* TODO: handle signed case */
   if(type.norm && !type.floating && !type.fixed && !type.sign)
      a = lp_build_max_simple(bld, a, b, GALLIVM_NAN_BEHAVIOR_UNDEFINED);
d1098 1
a1098 1
   if(a == bld->one)
a1533 1
#if HAVE_LLVM >= 0x0207
a1536 1
#endif
a3074 1

d3087 3
a3089 2
                        GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
   x = lp_build_max(bld, lp_build_const_vec(bld->gallivm, type, -126.99999), x);
a3094 2


a3101 1

a3105 1

@


