head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.10
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.09.07.15.20.06;	author jsg;	state Exp;
branches;
next	1.6;
commitid	7kimTMT4YlQauAIU;

1.6
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2014.04.20.10.53.26;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.13.59.36;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2012.07.13.13.00.28;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.43;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.00.45;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.06.16;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.43.23;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 **************************************************************************/


/**
 * The purpose of this module is to expose LLVM functionality not available
 * through the C++ bindings.
 */


#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS
#endif

#ifndef __STDC_CONSTANT_MACROS
#define __STDC_CONSTANT_MACROS
#endif

// Undef these vars just to silence warnings
#undef PACKAGE_BUGREPORT
#undef PACKAGE_NAME
#undef PACKAGE_STRING
#undef PACKAGE_TARNAME
#undef PACKAGE_VERSION


#include <stddef.h>

#include <llvm-c/Core.h>
#include <llvm-c/ExecutionEngine.h>
#include <llvm/Target/TargetOptions.h>
#include <llvm/ExecutionEngine/ExecutionEngine.h>
#if HAVE_LLVM >= 0x0301
#include <llvm/ADT/Triple.h>
#include <llvm/ExecutionEngine/JITMemoryManager.h>
#endif
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/PrettyStackTrace.h>

#if HAVE_LLVM >= 0x0300
#include <llvm/Support/TargetSelect.h>
#else /* HAVE_LLVM < 0x0300 */
#include <llvm/Target/TargetSelect.h>
#endif /* HAVE_LLVM < 0x0300 */

#if HAVE_LLVM >= 0x0303
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/CBindingWrapping.h>
#endif

#if HAVE_LLVM >= 0x0305
#include <llvm/Support/Host.h>
#endif

#include "pipe/p_config.h"
#include "util/u_debug.h"
#include "util/u_cpu_detect.h"

#include "lp_bld_misc.h"

namespace {

class LLVMEnsureMultithreaded {
public:
   LLVMEnsureMultithreaded()
   {
#if HAVE_LLVM < 0x0303
      if (!llvm::llvm_is_multithreaded()) {
         llvm::llvm_start_multithreaded();
      }
#else
      if (!LLVMIsMultithreaded()) {
         LLVMStartMultithreaded();
      }
#endif
   }
};

static LLVMEnsureMultithreaded lLVMEnsureMultithreaded;

}

extern "C" void
lp_set_target_options(void)
{
#if HAVE_LLVM <= 0x0300
#if defined(DEBUG)
#if HAVE_LLVM >= 0x0207
   llvm::JITEmitDebugInfo = true;
#endif
#endif

   /*
    * LLVM revision 123367 switched the default stack alignment to 16 bytes on
    * Linux (and several other Unices in later revisions), to match recent gcc
    * versions.
    *
    * However our drivers can be loaded by old binary applications, still
    * maintaining a 4 bytes stack alignment.  Therefore we must tell LLVM here
    * to only assume a 4 bytes alignment for backwards compatibility.
    */
#if defined(PIPE_ARCH_X86)
#if HAVE_LLVM == 0x0300
   llvm::StackAlignmentOverride = 4;
#else
   llvm::StackAlignment = 4;
#endif
#endif

#if defined(DEBUG) || defined(PROFILE)
   llvm::NoFramePointerElim = true;
#if HAVE_LLVM >= 0x0208
   llvm::NoFramePointerElimNonLeaf = true;
#endif
#endif

   llvm::NoExcessFPPrecision = false;

   /* XXX: Investigate this */
#if 0
   llvm::UnsafeFPMath = true;
#endif
#endif  /* HAVE_LLVM <= 0x0300 */

#if HAVE_LLVM < 0x0209
   /*
    * LLVM will generate MMX instructions for vectors <= 64 bits, leading to
    * innefficient code, and in 32bit systems, to the corruption of the FPU
    * stack given that it expects the user to generate the EMMS instructions.
    *
    * See also:
    * - http://llvm.org/bugs/show_bug.cgi?id=3287
    * - http://l4.me.uk/post/2009/06/07/llvm-wrinkle-3-configuration-what-configuration/
    *
    * The -disable-mmx global option can be specified only once  since we
    * dynamically link against LLVM it will reside in a separate shared object,
    * which may or not be delete when this shared object is, so we use the
    * llvm::DisablePrettyStackTrace variable (which we set below and should
    * reside in the same shared library) to determine whether the -disable-mmx
    * option has been set or not.
    *
    * Thankfully this ugly hack is not necessary on LLVM 2.9 onwards.
    */
   if (!llvm::DisablePrettyStackTrace) {
      static boolean first = TRUE;
      static const char* options[] = {
         "prog",
         "-disable-mmx"
      };
      assert(first);
      llvm::cl::ParseCommandLineOptions(2, const_cast<char**>(options));
      first = FALSE;
   }
#endif

#if HAVE_LLVM < 0x0304
   /*
    * By default LLVM adds a signal handler to output a pretty stack trace.
    * This signal handler is never removed, causing problems when unloading the
    * shared object where the gallium driver resides.
    */
   llvm::DisablePrettyStackTrace = true;
#endif

   // If we have a native target, initialize it to ensure it is linked in and
   // usable by the JIT.
   llvm::InitializeNativeTarget();

#if HAVE_LLVM >= 0x0208
   llvm::InitializeNativeTargetAsmPrinter();
#elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   LLVMInitializeX86AsmPrinter();
#elif defined(PIPE_ARCH_ARM)
   LLVMInitializeARMAsmPrinter();
#elif defined(PIPE_ARCH_PPC)
   LLVMInitializePowerPCAsmPrinter();
#endif

#if HAVE_LLVM >= 0x0207
#  if HAVE_LLVM >= 0x0301
   llvm::InitializeNativeTargetDisassembler();
#  elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   LLVMInitializeX86Disassembler();
#  elif defined(PIPE_ARCH_ARM)
   LLVMInitializeARMDisassembler();
#  endif
#endif
}


extern "C" void
lp_func_delete_body(LLVMValueRef FF)
{
   llvm::Function *func = llvm::unwrap<llvm::Function>(FF);
   func->deleteBody();
}


extern "C"
LLVMValueRef
lp_build_load_volatile(LLVMBuilderRef B, LLVMValueRef PointerVal,
                       const char *Name)
{
   return llvm::wrap(llvm::unwrap(B)->CreateLoad(llvm::unwrap(PointerVal), true, Name));
}


extern "C"
void
lp_set_load_alignment(LLVMValueRef Inst,
                       unsigned Align)
{
   llvm::unwrap<llvm::LoadInst>(Inst)->setAlignment(Align);
}

extern "C"
void
lp_set_store_alignment(LLVMValueRef Inst,
		       unsigned Align)
{
   llvm::unwrap<llvm::StoreInst>(Inst)->setAlignment(Align);
}


#if HAVE_LLVM >= 0x301

/**
 * Same as LLVMCreateJITCompilerForModule, but:
 * - allows using MCJIT and enabling AVX feature where available.
 * - set target options
 *
 * See also:
 * - llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp
 * - llvm/tools/lli/lli.cpp
 * - http://markmail.org/message/ttkuhvgj4cxxy2on#query:+page:1+mid:aju2dggerju3ivd3+state:results
 */
extern "C"
LLVMBool
lp_build_create_jit_compiler_for_module(LLVMExecutionEngineRef *OutJIT,
                                        LLVMModuleRef M,
                                        unsigned OptLevel,
                                        int useMCJIT,
                                        char **OutError)
{
   using namespace llvm;

   std::string Error;
#if HAVE_LLVM >= 0x0306
   EngineBuilder builder(std::unique_ptr<Module>(unwrap(M)));
#else
   EngineBuilder builder(unwrap(M));
#endif

   /**
    * LLVM 3.1+ haven't more "extern unsigned llvm::StackAlignmentOverride" and
    * friends for configuring code generation options, like stack alignment.
    */
   TargetOptions options;
#if defined(PIPE_ARCH_X86)
   options.StackAlignmentOverride = 4;
#if HAVE_LLVM < 0x0304
   options.RealignStack = true;
#endif
#endif

#if defined(DEBUG)
   options.JITEmitDebugInfo = true;
#endif

#if defined(DEBUG) || defined(PROFILE)
#if HAVE_LLVM < 0x0304
   options.NoFramePointerElimNonLeaf = true;
#endif
   options.NoFramePointerElim = true;
#endif

   builder.setEngineKind(EngineKind::JIT)
          .setErrorStr(&Error)
          .setTargetOptions(options)
          .setOptLevel((CodeGenOpt::Level)OptLevel);

   if (useMCJIT) {
       builder.setUseMCJIT(true);
   }

   llvm::SmallVector<std::string, 1> MAttrs;
   if (util_cpu_caps.has_avx) {
      /*
       * AVX feature is not automatically detected from CPUID by the X86 target
       * yet, because the old (yet default) JIT engine is not capable of
       * emitting the opcodes. On newer llvm versions it is and at least some
       * versions (tested with 3.3) will emit avx opcodes without this anyway.
       */
      MAttrs.push_back("+avx");
      if (util_cpu_caps.has_f16c) {
         MAttrs.push_back("+f16c");
      }
      builder.setMAttrs(MAttrs);
   }
   builder.setJITMemoryManager(JITMemoryManager::CreateDefaultMemManager());

#if HAVE_LLVM >= 0x0305
   StringRef MCPU = llvm::sys::getHostCPUName();
   /*
    * The cpu bits are no longer set automatically, so need to set mcpu manually.
    * Note that the MAttrs set above will be sort of ignored (since we should
    * not set any which would not be set by specifying the cpu anyway).
    * It ought to be safe though since getHostCPUName() should include bits
    * not only from the cpu but environment as well (for instance if it's safe
    * to use avx instructions which need OS support). According to
    * http://llvm.org/bugs/show_bug.cgi?id=19429 however if I understand this
    * right it may be necessary to specify older cpu (or disable mattrs) though
    * when not using MCJIT so no instructions are generated which the old JIT
    * can't handle. Not entirely sure if we really need to do anything yet.
    */
   builder.setMCPU(MCPU);
#endif

   ExecutionEngine *JIT;

#if HAVE_LLVM >= 0x0302
   JIT = builder.create();
#else
   /*
    * Workaround http://llvm.org/PR12833
    */
   StringRef MArch = "";
   StringRef MCPU = "";
   Triple TT(unwrap(M)->getTargetTriple());
   JIT = builder.create(builder.selectTarget(TT, MArch, MCPU, MAttrs));
#endif
   if (JIT) {
      *OutJIT = wrap(JIT);
      return 0;
   }
   *OutError = strdup(Error.c_str());
   return 1;
}

#endif /* HAVE_LLVM >= 0x301 */
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d57 1
a58 1
#if HAVE_LLVM < 0x0306
a59 2
#else
#include <llvm/ExecutionEngine/SectionMemoryManager.h>
a61 1
#include <llvm/Support/Host.h>
d64 1
d66 3
d70 1
d74 5
d92 5
d100 1
d111 70
d194 1
d196 7
d204 2
d207 14
d244 1
a244 1
                       unsigned Align)
d250 1
a250 247
#if HAVE_LLVM < 0x0306
typedef llvm::JITMemoryManager BaseMemoryManager;
#else
typedef llvm::RTDyldMemoryManager BaseMemoryManager;
#endif


/*
 * Delegating is tedious but the default manager class is hidden in an
 * anonymous namespace in LLVM, so we cannot just derive from it to change
 * its behavior.
 */
class DelegatingJITMemoryManager : public BaseMemoryManager {

   protected:
      virtual BaseMemoryManager *mgr() const = 0;

   public:
#if HAVE_LLVM < 0x0306
      /*
       * From JITMemoryManager
       */
      virtual void setMemoryWritable() {
         mgr()->setMemoryWritable();
      }
      virtual void setMemoryExecutable() {
         mgr()->setMemoryExecutable();
      }
      virtual void setPoisonMemory(bool poison) {
         mgr()->setPoisonMemory(poison);
      }
      virtual void AllocateGOT() {
         mgr()->AllocateGOT();
         /*
          * isManagingGOT() is not virtual in base class so we can't delegate.
          * Instead we mirror the value of HasGOT in our instance.
          */
         HasGOT = mgr()->isManagingGOT();
      }
      virtual uint8_t *getGOTBase() const {
         return mgr()->getGOTBase();
      }
      virtual uint8_t *startFunctionBody(const llvm::Function *F,
                                         uintptr_t &ActualSize) {
         return mgr()->startFunctionBody(F, ActualSize);
      }
      virtual uint8_t *allocateStub(const llvm::GlobalValue *F,
                                    unsigned StubSize,
                                    unsigned Alignment) {
         return mgr()->allocateStub(F, StubSize, Alignment);
      }
      virtual void endFunctionBody(const llvm::Function *F,
                                   uint8_t *FunctionStart,
                                   uint8_t *FunctionEnd) {
         mgr()->endFunctionBody(F, FunctionStart, FunctionEnd);
      }
      virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) {
         return mgr()->allocateSpace(Size, Alignment);
      }
      virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) {
         return mgr()->allocateGlobal(Size, Alignment);
      }
      virtual void deallocateFunctionBody(void *Body) {
         mgr()->deallocateFunctionBody(Body);
      }
#if HAVE_LLVM < 0x0304
      virtual uint8_t *startExceptionTable(const llvm::Function *F,
                                           uintptr_t &ActualSize) {
         return mgr()->startExceptionTable(F, ActualSize);
      }
      virtual void endExceptionTable(const llvm::Function *F,
                                     uint8_t *TableStart,
                                     uint8_t *TableEnd,
                                     uint8_t *FrameRegister) {
         mgr()->endExceptionTable(F, TableStart, TableEnd,
                                  FrameRegister);
      }
      virtual void deallocateExceptionTable(void *ET) {
         mgr()->deallocateExceptionTable(ET);
      }
#endif
      virtual bool CheckInvariants(std::string &s) {
         return mgr()->CheckInvariants(s);
      }
      virtual size_t GetDefaultCodeSlabSize() {
         return mgr()->GetDefaultCodeSlabSize();
      }
      virtual size_t GetDefaultDataSlabSize() {
         return mgr()->GetDefaultDataSlabSize();
      }
      virtual size_t GetDefaultStubSlabSize() {
         return mgr()->GetDefaultStubSlabSize();
      }
      virtual unsigned GetNumCodeSlabs() {
         return mgr()->GetNumCodeSlabs();
      }
      virtual unsigned GetNumDataSlabs() {
         return mgr()->GetNumDataSlabs();
      }
      virtual unsigned GetNumStubSlabs() {
         return mgr()->GetNumStubSlabs();
      }
#endif

      /*
       * From RTDyldMemoryManager
       */
#if HAVE_LLVM >= 0x0304
      virtual uint8_t *allocateCodeSection(uintptr_t Size,
                                           unsigned Alignment,
                                           unsigned SectionID,
                                           llvm::StringRef SectionName) {
         return mgr()->allocateCodeSection(Size, Alignment, SectionID,
                                           SectionName);
      }
#else
      virtual uint8_t *allocateCodeSection(uintptr_t Size,
                                           unsigned Alignment,
                                           unsigned SectionID) {
         return mgr()->allocateCodeSection(Size, Alignment, SectionID);
      }
#endif
      virtual uint8_t *allocateDataSection(uintptr_t Size,
                                           unsigned Alignment,
                                           unsigned SectionID,
#if HAVE_LLVM >= 0x0304
                                           llvm::StringRef SectionName,
#endif
                                           bool IsReadOnly) {
         return mgr()->allocateDataSection(Size, Alignment, SectionID,
#if HAVE_LLVM >= 0x0304
                                           SectionName,
#endif
                                           IsReadOnly);
      }
#if HAVE_LLVM >= 0x0304
      virtual void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) {
         mgr()->registerEHFrames(Addr, LoadAddr, Size);
      }
      virtual void deregisterEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) {
         mgr()->deregisterEHFrames(Addr, LoadAddr, Size);
      }
#else
      virtual void registerEHFrames(llvm::StringRef SectionData) {
         mgr()->registerEHFrames(SectionData);
      }
#endif
      virtual void *getPointerToNamedFunction(const std::string &Name,
                                              bool AbortOnFailure=true) {
         return mgr()->getPointerToNamedFunction(Name, AbortOnFailure);
      }
#if HAVE_LLVM <= 0x0303
      virtual bool applyPermissions(std::string *ErrMsg = 0) {
         return mgr()->applyPermissions(ErrMsg);
      }
#else
      virtual bool finalizeMemory(std::string *ErrMsg = 0) {
         return mgr()->finalizeMemory(ErrMsg);
      }
#endif
};


/*
 * Delegate memory management to one shared manager for more efficient use
 * of memory than creating a separate pool for each LLVM engine.
 * Keep generated code until freeGeneratedCode() is called, instead of when
 * memory manager is destroyed, which happens during engine destruction.
 * This allows additional memory savings as we don't have to keep the engine
 * around in order to use the code.
 * All methods are delegated to the shared manager except destruction and
 * deallocating code.  For the latter we just remember what needs to be
 * deallocated later.  The shared manager is deleted once it is empty.
 */
class ShaderMemoryManager : public DelegatingJITMemoryManager {

   BaseMemoryManager *TheMM;

   struct GeneratedCode {
      typedef std::vector<void *> Vec;
      Vec FunctionBody, ExceptionTable;
      BaseMemoryManager *TheMM;

      GeneratedCode(BaseMemoryManager *MM) {
         TheMM = MM;
      }

      ~GeneratedCode() {
         /*
          * Deallocate things as previously requested and
          * free shared manager when no longer used.
          */
#if HAVE_LLVM < 0x0306
         Vec::iterator i;

         assert(TheMM);
         for ( i = FunctionBody.begin(); i != FunctionBody.end(); ++i )
            TheMM->deallocateFunctionBody(*i);
#if HAVE_LLVM < 0x0304
         for ( i = ExceptionTable.begin(); i != ExceptionTable.end(); ++i )
            TheMM->deallocateExceptionTable(*i);
#endif /* HAVE_LLVM < 0x0304 */
#endif /* HAVE_LLVM < 0x0306 */
      }
   };

   GeneratedCode *code;

   BaseMemoryManager *mgr() const {
      return TheMM;
   }

   public:

      ShaderMemoryManager(BaseMemoryManager* MM) {
         TheMM = MM;
         code = new GeneratedCode(MM);
      }

      virtual ~ShaderMemoryManager() {
         /*
          * 'code' is purposely not deleted.  It is the user's responsibility
          * to call getGeneratedCode() and freeGeneratedCode().
          */
      }

      struct lp_generated_code *getGeneratedCode() {
         return (struct lp_generated_code *) code;
      }

      static void freeGeneratedCode(struct lp_generated_code *code) {
         delete (GeneratedCode *) code;
      }

#if HAVE_LLVM < 0x0304
      virtual void deallocateExceptionTable(void *ET) {
         // remember for later deallocation
         code->ExceptionTable.push_back(ET);
      }
#endif

      virtual void deallocateFunctionBody(void *Body) {
         // remember for later deallocation
         code->FunctionBody.push_back(Body);
      }
};

a264 1
                                        lp_generated_code **OutCode,
a265 1
                                        LLVMMCJITMemoryManagerRef CMM,
d295 1
a295 3
   /* XXX: Workaround http://llvm.org/PR21435 */
#if defined(DEBUG) || defined(PROFILE) || \
    (HAVE_LLVM >= 0x0303 && (defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)))
a307 1
#if HAVE_LLVM < 0x0306
a308 9
#endif
#ifdef _WIN32
       /*
        * MCJIT works on Windows, but currently only through ELF object format.
        */
       std::string targetTriple = llvm::sys::getProcessTriple();
       targetTriple.append("-elf");
       unwrap(M)->setTargetTriple(targetTriple);
#endif
d325 1
d344 1
a344 14
   ShaderMemoryManager *MM;
   if (useMCJIT) {
#if HAVE_LLVM > 0x0303
       BaseMemoryManager* JMM = reinterpret_cast<BaseMemoryManager*>(CMM);
       MM = new ShaderMemoryManager(JMM);
       *OutCode = MM->getGeneratedCode();

       builder.setMCJITMemoryManager(MM);
#endif
   } else {
#if HAVE_LLVM < 0x0306
       BaseMemoryManager* JMM = reinterpret_cast<BaseMemoryManager*>(CMM);
       MM = new ShaderMemoryManager(JMM);
       *OutCode = MM->getGeneratedCode();
d346 2
a347 1
       builder.setJITMemoryManager(MM);
d349 7
a355 1
       assert(0);
a356 5
   }

   ExecutionEngine *JIT;

   JIT = builder.create();
a360 3
   lp_free_generated_code(*OutCode);
   *OutCode = 0;
   delete MM;
d365 1
a365 27

extern "C"
void
lp_free_generated_code(struct lp_generated_code *code)
{
   ShaderMemoryManager::freeGeneratedCode(code);
}

extern "C"
LLVMMCJITMemoryManagerRef
lp_get_default_memory_manager()
{
   BaseMemoryManager *mm;
#if HAVE_LLVM < 0x0306
   mm = llvm::JITMemoryManager::CreateDefaultMemManager();
#else
   mm = new llvm::SectionMemoryManager();
#endif
   return reinterpret_cast<LLVMMCJITMemoryManagerRef>(mm);
}

extern "C"
void
lp_free_memory_manager(LLVMMCJITMemoryManagerRef memorymgr)
{
   delete reinterpret_cast<BaseMemoryManager*>(memorymgr);
}
@


1.7
log
@Merge Mesa 10.2.7
@
text
@a56 1
#if HAVE_LLVM >= 0x0301
d58 1
d60 2
d64 1
a66 1
#if HAVE_LLVM >= 0x0300
a67 3
#else /* HAVE_LLVM < 0x0300 */
#include <llvm/Target/TargetSelect.h>
#endif /* HAVE_LLVM < 0x0300 */
a68 1
#if HAVE_LLVM >= 0x0303
a71 1
#endif
a84 5
#if HAVE_LLVM < 0x0303
      if (!llvm::llvm_is_multithreaded()) {
         llvm::llvm_start_multithreaded();
      }
#else
a87 1
#endif
a97 70
#if HAVE_LLVM <= 0x0300
#if defined(DEBUG)
#if HAVE_LLVM >= 0x0207
   llvm::JITEmitDebugInfo = true;
#endif
#endif

   /*
    * LLVM revision 123367 switched the default stack alignment to 16 bytes on
    * Linux (and several other Unices in later revisions), to match recent gcc
    * versions.
    *
    * However our drivers can be loaded by old binary applications, still
    * maintaining a 4 bytes stack alignment.  Therefore we must tell LLVM here
    * to only assume a 4 bytes alignment for backwards compatibility.
    */
#if defined(PIPE_ARCH_X86)
#if HAVE_LLVM == 0x0300
   llvm::StackAlignmentOverride = 4;
#else
   llvm::StackAlignment = 4;
#endif
#endif

#if defined(DEBUG) || defined(PROFILE)
   llvm::NoFramePointerElim = true;
#if HAVE_LLVM >= 0x0208
   llvm::NoFramePointerElimNonLeaf = true;
#endif
#endif

   llvm::NoExcessFPPrecision = false;

   /* XXX: Investigate this */
#if 0
   llvm::UnsafeFPMath = true;
#endif
#endif  /* HAVE_LLVM <= 0x0300 */

#if HAVE_LLVM < 0x0209
   /*
    * LLVM will generate MMX instructions for vectors <= 64 bits, leading to
    * innefficient code, and in 32bit systems, to the corruption of the FPU
    * stack given that it expects the user to generate the EMMS instructions.
    *
    * See also:
    * - http://llvm.org/bugs/show_bug.cgi?id=3287
    * - http://l4.me.uk/post/2009/06/07/llvm-wrinkle-3-configuration-what-configuration/
    *
    * The -disable-mmx global option can be specified only once  since we
    * dynamically link against LLVM it will reside in a separate shared object,
    * which may or not be delete when this shared object is, so we use the
    * llvm::DisablePrettyStackTrace variable (which we set below and should
    * reside in the same shared library) to determine whether the -disable-mmx
    * option has been set or not.
    *
    * Thankfully this ugly hack is not necessary on LLVM 2.9 onwards.
    */
   if (!llvm::DisablePrettyStackTrace) {
      static boolean first = TRUE;
      static const char* options[] = {
         "prog",
         "-disable-mmx"
      };
      assert(first);
      llvm::cl::ParseCommandLineOptions(2, const_cast<char**>(options));
      first = FALSE;
   }
#endif

a110 1
#if HAVE_LLVM >= 0x0208
a111 7
#elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   LLVMInitializeX86AsmPrinter();
#elif defined(PIPE_ARCH_ARM)
   LLVMInitializeARMAsmPrinter();
#elif defined(PIPE_ARCH_PPC)
   LLVMInitializePowerPCAsmPrinter();
#endif
a112 2
#if HAVE_LLVM >= 0x0207
#  if HAVE_LLVM >= 0x0301
a113 14
#  elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   LLVMInitializeX86Disassembler();
#  elif defined(PIPE_ARCH_ARM)
   LLVMInitializeARMDisassembler();
#  endif
#endif
}


extern "C" void
lp_func_delete_body(LLVMValueRef FF)
{
   llvm::Function *func = llvm::unwrap<llvm::Function>(FF);
   func->deleteBody();
d137 1
a137 1
		       unsigned Align)
d143 247
a389 1
#if HAVE_LLVM >= 0x301
d404 1
d406 1
d436 3
a438 1
#if defined(DEBUG) || defined(PROFILE)
d451 1
d453 9
d469 2
a470 2
       * emitting the opcodes.  But as we're using MCJIT here, it is safe to
       * add set this attribute.
a477 1
   builder.setJITMemoryManager(JITMemoryManager::CreateDefaultMemManager());
d479 2
a480 4
   ExecutionEngine *JIT;
#if 0
   JIT = builder.create();
#else
d482 10
a491 1
    * Workaround http://llvm.org/bugs/show_bug.cgi?id=12833
d493 1
a493 4
   StringRef MArch = "";
   StringRef MCPU = "";
   Triple TT(unwrap(M)->getTargetTriple());
   JIT = builder.create(builder.selectTarget(TT, MArch, MCPU, MAttrs));
d495 25
d524 3
d531 27
a557 1
#endif /* HAVE_LLVM >= 0x301 */
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d269 3
d273 1
@


1.5
log
@backport a Mesa patch for the recently updated ports llvm

commit 749cb8909714fed57b0213f4ad92def3bb24f153
Author: Vinson Lee <vlee@@freedesktop.org>
Date:   Sun Nov 3 20:27:13 2013 -0800

    gallivm: Remove llvm::DisablePrettyStackTrace for LLVM >= 3.4.

    LLVM 3.4 r193971 removed llvm::DisablePrettyStackTrace and made the
    pretty stack trace opt-in rather than opt-out.

    The default value of DisablePrettyStackTrace has changed to true in LLVM
    3.4 and newer.

    Signed-off-by: Vinson Lee <vlee@@freedesktop.org>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=60929
    Reviewed-by: Tom Stellard <thomas.stellard@@amd.com>
    Reviewed-by: Brian Paul <brianp@@vmware.com>
@
text
@d278 1
d281 1
d288 1
d290 1
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d177 1
d184 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d29 6
d43 10
d57 4
a60 1
#include <llvm/ExecutionEngine/JITEventListener.h>
d64 12
d78 3
d82 1
d84 8
a91 16
/**
 * Register the engine with oprofile.
 *
 * This allows to see the LLVM IR function names in oprofile output.
 *
 * To actually work LLVM needs to be built with the --with-oprofile configure
 * option.
 *
 * Also a oprofile:oprofile user:group is necessary. Which is not created by
 * default on some distributions.
 */
extern "C" void
lp_register_oprofile_jit_event_listener(LLVMExecutionEngineRef EE)
{
#if HAVE_LLVM >= 0x0301
   llvm::unwrap(EE)->RegisterJITEventListener(llvm::JITEventListener::createOProfileJITEventListener());
d93 3
a95 1
   llvm::unwrap(EE)->RegisterJITEventListener(llvm::createOProfileJITEventListener());
d97 5
a103 1

d124 1
a124 1
#if HAVE_LLVM >= 0x0300
d133 3
d183 24
d226 108
@


1.2
log
@Lets gallium a chance to build with our llvm port
@
text
@a48 60
#if (defined(PIPE_OS_WINDOWS) && !defined(PIPE_CC_MSVC)) || defined(PIPE_OS_EMBDDED)

#include "llvm/Support/raw_ostream.h"

class raw_debug_ostream :
   public llvm::raw_ostream
{
   uint64_t pos;

   void write_impl(const char *Ptr, size_t Size);
   uint64_t current_pos() { return pos; }
   uint64_t current_pos() const { return pos; }

#if HAVE_LLVM >= 0x207
   uint64_t preferred_buffer_size() { return 512; }
#else
   size_t preferred_buffer_size() { return 512; }
#endif
};


void
raw_debug_ostream::write_impl(const char *Ptr, size_t Size)
{
   if (Size > 0) {
      char *lastPtr = (char *)&Ptr[Size];
      char last = *lastPtr;
      *lastPtr = 0;
      _debug_printf("%*s", Size, Ptr);
      *lastPtr = last;
      pos += Size;
   }
}


/**
 * Same as LLVMDumpValue, but through our debugging channels.
 */
extern "C" void
lp_debug_dump_value(LLVMValueRef value)
{
   raw_debug_ostream os;
   llvm::unwrap(value)->print(os);
   os.flush();
}


#else


extern "C" void
lp_debug_dump_value(LLVMValueRef value)
{
   LLVMDumpValue(value);
}


#endif


d91 3
d96 1
d139 1
a146 1
#endif
@


1.1
log
@Initial revision
@
text
@d123 3
d127 1
d134 1
d164 1
a194 1
#endif
d202 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a28 6
/**
 * The purpose of this module is to expose LLVM functionality not available
 * through the C++ bindings.
 */


a36 10
// Undef these vars just to silence warnings
#undef PACKAGE_BUGREPORT
#undef PACKAGE_NAME
#undef PACKAGE_STRING
#undef PACKAGE_TARNAME
#undef PACKAGE_VERSION


#include <stddef.h>

d41 1
a41 4
#if HAVE_LLVM >= 0x0301
#include <llvm/ADT/Triple.h>
#include <llvm/ExecutionEngine/JITMemoryManager.h>
#endif
a44 12
#if HAVE_LLVM >= 0x0300
#include <llvm/Support/TargetSelect.h>
#else /* HAVE_LLVM < 0x0300 */
#include <llvm/Target/TargetSelect.h>
#endif /* HAVE_LLVM < 0x0300 */

#if HAVE_LLVM >= 0x0303
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/CBindingWrapping.h>
#endif

a46 1
#include "util/u_cpu_detect.h"
a47 1
#include "lp_bld_misc.h"
d49 8
a56 1
namespace {
d58 6
a63 8
class LLVMEnsureMultithreaded {
public:
   LLVMEnsureMultithreaded()
   {
#if HAVE_LLVM < 0x0303
      if (!llvm::llvm_is_multithreaded()) {
         llvm::llvm_start_multithreaded();
      }
d65 1
a65 3
      if (!LLVMIsMultithreaded()) {
         LLVMStartMultithreaded();
      }
d67 13
d81 26
a106 1
};
a107 1
static LLVMEnsureMultithreaded lLVMEnsureMultithreaded;
d109 15
d126 1
a129 1
#if HAVE_LLVM <= 0x0300
a145 3
#if HAVE_LLVM == 0x0300
   llvm::StackAlignmentOverride = 4;
#else
a147 1
#endif
a150 3
#if HAVE_LLVM >= 0x0208
   llvm::NoFramePointerElimNonLeaf = true;
#endif
a158 1
#endif  /* HAVE_LLVM <= 0x0300 */
a196 24

   // If we have a native target, initialize it to ensure it is linked in and
   // usable by the JIT.
   llvm::InitializeNativeTarget();

#if HAVE_LLVM >= 0x0208
   llvm::InitializeNativeTargetAsmPrinter();
#elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   LLVMInitializeX86AsmPrinter();
#elif defined(PIPE_ARCH_ARM)
   LLVMInitializeARMAsmPrinter();
#elif defined(PIPE_ARCH_PPC)
   LLVMInitializePowerPCAsmPrinter();
#endif

#if HAVE_LLVM >= 0x0207
#  if HAVE_LLVM >= 0x0301
   llvm::InitializeNativeTargetDisassembler();
#  elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   LLVMInitializeX86Disassembler();
#  elif defined(PIPE_ARCH_ARM)
   LLVMInitializeARMDisassembler();
#  endif
#endif
a215 108

extern "C"
void
lp_set_load_alignment(LLVMValueRef Inst,
                       unsigned Align)
{
   llvm::unwrap<llvm::LoadInst>(Inst)->setAlignment(Align);
}

extern "C"
void
lp_set_store_alignment(LLVMValueRef Inst,
		       unsigned Align)
{
   llvm::unwrap<llvm::StoreInst>(Inst)->setAlignment(Align);
}


#if HAVE_LLVM >= 0x301

/**
 * Same as LLVMCreateJITCompilerForModule, but:
 * - allows using MCJIT and enabling AVX feature where available.
 * - set target options
 *
 * See also:
 * - llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp
 * - llvm/tools/lli/lli.cpp
 * - http://markmail.org/message/ttkuhvgj4cxxy2on#query:+page:1+mid:aju2dggerju3ivd3+state:results
 */
extern "C"
LLVMBool
lp_build_create_jit_compiler_for_module(LLVMExecutionEngineRef *OutJIT,
                                        LLVMModuleRef M,
                                        unsigned OptLevel,
                                        int useMCJIT,
                                        char **OutError)
{
   using namespace llvm;

   std::string Error;
   EngineBuilder builder(unwrap(M));

   /**
    * LLVM 3.1+ haven't more "extern unsigned llvm::StackAlignmentOverride" and
    * friends for configuring code generation options, like stack alignment.
    */
   TargetOptions options;
#if defined(PIPE_ARCH_X86)
   options.StackAlignmentOverride = 4;
   options.RealignStack = true;
#endif

#if defined(DEBUG)
   options.JITEmitDebugInfo = true;
#endif

#if defined(DEBUG) || defined(PROFILE)
   options.NoFramePointerElimNonLeaf = true;
   options.NoFramePointerElim = true;
#endif

   builder.setEngineKind(EngineKind::JIT)
          .setErrorStr(&Error)
          .setTargetOptions(options)
          .setOptLevel((CodeGenOpt::Level)OptLevel);

   if (useMCJIT) {
       builder.setUseMCJIT(true);
   }

   llvm::SmallVector<std::string, 1> MAttrs;
   if (util_cpu_caps.has_avx) {
      /*
       * AVX feature is not automatically detected from CPUID by the X86 target
       * yet, because the old (yet default) JIT engine is not capable of
       * emitting the opcodes.  But as we're using MCJIT here, it is safe to
       * add set this attribute.
       */
      MAttrs.push_back("+avx");
      if (util_cpu_caps.has_f16c) {
         MAttrs.push_back("+f16c");
      }
      builder.setMAttrs(MAttrs);
   }
   builder.setJITMemoryManager(JITMemoryManager::CreateDefaultMemManager());

   ExecutionEngine *JIT;
#if 0
   JIT = builder.create();
#else
   /*
    * Workaround http://llvm.org/bugs/show_bug.cgi?id=12833
    */
   StringRef MArch = "";
   StringRef MCPU = "";
   Triple TT(unwrap(M)->getTargetTriple());
   JIT = builder.create(builder.selectTarget(TT, MArch, MCPU, MAttrs));
#endif
   if (JIT) {
      *OutJIT = wrap(JIT);
      return 0;
   }
   *OutError = strdup(Error.c_str());
   return 1;
}

#endif /* HAVE_LLVM >= 0x301 */
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a176 1
#if HAVE_LLVM < 0x0304
a182 1
#endif
a275 1
#if HAVE_LLVM < 0x0304
a277 1
#endif
a283 1
#if HAVE_LLVM < 0x0304
a284 1
#endif
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@a268 3
#if HAVE_LLVM >= 0x0306
   EngineBuilder builder(std::unique_ptr<Module>(unwrap(M)));
#else
a269 1
#endif
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d57 1
a58 1
#if HAVE_LLVM < 0x0306
a59 2
#else
#include <llvm/ExecutionEngine/SectionMemoryManager.h>
a61 1
#include <llvm/Support/Host.h>
d64 1
d66 3
d70 1
d74 1
d88 5
d96 1
d107 70
d190 1
d192 7
d200 2
d203 14
d240 1
a240 1
                       unsigned Align)
d246 1
a246 247
#if HAVE_LLVM < 0x0306
typedef llvm::JITMemoryManager BaseMemoryManager;
#else
typedef llvm::RTDyldMemoryManager BaseMemoryManager;
#endif


/*
 * Delegating is tedious but the default manager class is hidden in an
 * anonymous namespace in LLVM, so we cannot just derive from it to change
 * its behavior.
 */
class DelegatingJITMemoryManager : public BaseMemoryManager {

   protected:
      virtual BaseMemoryManager *mgr() const = 0;

   public:
#if HAVE_LLVM < 0x0306
      /*
       * From JITMemoryManager
       */
      virtual void setMemoryWritable() {
         mgr()->setMemoryWritable();
      }
      virtual void setMemoryExecutable() {
         mgr()->setMemoryExecutable();
      }
      virtual void setPoisonMemory(bool poison) {
         mgr()->setPoisonMemory(poison);
      }
      virtual void AllocateGOT() {
         mgr()->AllocateGOT();
         /*
          * isManagingGOT() is not virtual in base class so we can't delegate.
          * Instead we mirror the value of HasGOT in our instance.
          */
         HasGOT = mgr()->isManagingGOT();
      }
      virtual uint8_t *getGOTBase() const {
         return mgr()->getGOTBase();
      }
      virtual uint8_t *startFunctionBody(const llvm::Function *F,
                                         uintptr_t &ActualSize) {
         return mgr()->startFunctionBody(F, ActualSize);
      }
      virtual uint8_t *allocateStub(const llvm::GlobalValue *F,
                                    unsigned StubSize,
                                    unsigned Alignment) {
         return mgr()->allocateStub(F, StubSize, Alignment);
      }
      virtual void endFunctionBody(const llvm::Function *F,
                                   uint8_t *FunctionStart,
                                   uint8_t *FunctionEnd) {
         mgr()->endFunctionBody(F, FunctionStart, FunctionEnd);
      }
      virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) {
         return mgr()->allocateSpace(Size, Alignment);
      }
      virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) {
         return mgr()->allocateGlobal(Size, Alignment);
      }
      virtual void deallocateFunctionBody(void *Body) {
         mgr()->deallocateFunctionBody(Body);
      }
#if HAVE_LLVM < 0x0304
      virtual uint8_t *startExceptionTable(const llvm::Function *F,
                                           uintptr_t &ActualSize) {
         return mgr()->startExceptionTable(F, ActualSize);
      }
      virtual void endExceptionTable(const llvm::Function *F,
                                     uint8_t *TableStart,
                                     uint8_t *TableEnd,
                                     uint8_t *FrameRegister) {
         mgr()->endExceptionTable(F, TableStart, TableEnd,
                                  FrameRegister);
      }
      virtual void deallocateExceptionTable(void *ET) {
         mgr()->deallocateExceptionTable(ET);
      }
#endif
      virtual bool CheckInvariants(std::string &s) {
         return mgr()->CheckInvariants(s);
      }
      virtual size_t GetDefaultCodeSlabSize() {
         return mgr()->GetDefaultCodeSlabSize();
      }
      virtual size_t GetDefaultDataSlabSize() {
         return mgr()->GetDefaultDataSlabSize();
      }
      virtual size_t GetDefaultStubSlabSize() {
         return mgr()->GetDefaultStubSlabSize();
      }
      virtual unsigned GetNumCodeSlabs() {
         return mgr()->GetNumCodeSlabs();
      }
      virtual unsigned GetNumDataSlabs() {
         return mgr()->GetNumDataSlabs();
      }
      virtual unsigned GetNumStubSlabs() {
         return mgr()->GetNumStubSlabs();
      }
#endif

      /*
       * From RTDyldMemoryManager
       */
#if HAVE_LLVM >= 0x0304
      virtual uint8_t *allocateCodeSection(uintptr_t Size,
                                           unsigned Alignment,
                                           unsigned SectionID,
                                           llvm::StringRef SectionName) {
         return mgr()->allocateCodeSection(Size, Alignment, SectionID,
                                           SectionName);
      }
#else
      virtual uint8_t *allocateCodeSection(uintptr_t Size,
                                           unsigned Alignment,
                                           unsigned SectionID) {
         return mgr()->allocateCodeSection(Size, Alignment, SectionID);
      }
#endif
      virtual uint8_t *allocateDataSection(uintptr_t Size,
                                           unsigned Alignment,
                                           unsigned SectionID,
#if HAVE_LLVM >= 0x0304
                                           llvm::StringRef SectionName,
#endif
                                           bool IsReadOnly) {
         return mgr()->allocateDataSection(Size, Alignment, SectionID,
#if HAVE_LLVM >= 0x0304
                                           SectionName,
#endif
                                           IsReadOnly);
      }
#if HAVE_LLVM >= 0x0304
      virtual void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) {
         mgr()->registerEHFrames(Addr, LoadAddr, Size);
      }
      virtual void deregisterEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) {
         mgr()->deregisterEHFrames(Addr, LoadAddr, Size);
      }
#else
      virtual void registerEHFrames(llvm::StringRef SectionData) {
         mgr()->registerEHFrames(SectionData);
      }
#endif
      virtual void *getPointerToNamedFunction(const std::string &Name,
                                              bool AbortOnFailure=true) {
         return mgr()->getPointerToNamedFunction(Name, AbortOnFailure);
      }
#if HAVE_LLVM <= 0x0303
      virtual bool applyPermissions(std::string *ErrMsg = 0) {
         return mgr()->applyPermissions(ErrMsg);
      }
#else
      virtual bool finalizeMemory(std::string *ErrMsg = 0) {
         return mgr()->finalizeMemory(ErrMsg);
      }
#endif
};


/*
 * Delegate memory management to one shared manager for more efficient use
 * of memory than creating a separate pool for each LLVM engine.
 * Keep generated code until freeGeneratedCode() is called, instead of when
 * memory manager is destroyed, which happens during engine destruction.
 * This allows additional memory savings as we don't have to keep the engine
 * around in order to use the code.
 * All methods are delegated to the shared manager except destruction and
 * deallocating code.  For the latter we just remember what needs to be
 * deallocated later.  The shared manager is deleted once it is empty.
 */
class ShaderMemoryManager : public DelegatingJITMemoryManager {

   BaseMemoryManager *TheMM;

   struct GeneratedCode {
      typedef std::vector<void *> Vec;
      Vec FunctionBody, ExceptionTable;
      BaseMemoryManager *TheMM;

      GeneratedCode(BaseMemoryManager *MM) {
         TheMM = MM;
      }

      ~GeneratedCode() {
         /*
          * Deallocate things as previously requested and
          * free shared manager when no longer used.
          */
#if HAVE_LLVM < 0x0306
         Vec::iterator i;

         assert(TheMM);
         for ( i = FunctionBody.begin(); i != FunctionBody.end(); ++i )
            TheMM->deallocateFunctionBody(*i);
#if HAVE_LLVM < 0x0304
         for ( i = ExceptionTable.begin(); i != ExceptionTable.end(); ++i )
            TheMM->deallocateExceptionTable(*i);
#endif /* HAVE_LLVM < 0x0304 */
#endif /* HAVE_LLVM < 0x0306 */
      }
   };

   GeneratedCode *code;

   BaseMemoryManager *mgr() const {
      return TheMM;
   }

   public:

      ShaderMemoryManager(BaseMemoryManager* MM) {
         TheMM = MM;
         code = new GeneratedCode(MM);
      }

      virtual ~ShaderMemoryManager() {
         /*
          * 'code' is purposely not deleted.  It is the user's responsibility
          * to call getGeneratedCode() and freeGeneratedCode().
          */
      }

      struct lp_generated_code *getGeneratedCode() {
         return (struct lp_generated_code *) code;
      }

      static void freeGeneratedCode(struct lp_generated_code *code) {
         delete (GeneratedCode *) code;
      }

#if HAVE_LLVM < 0x0304
      virtual void deallocateExceptionTable(void *ET) {
         // remember for later deallocation
         code->ExceptionTable.push_back(ET);
      }
#endif

      virtual void deallocateFunctionBody(void *Body) {
         // remember for later deallocation
         code->FunctionBody.push_back(Body);
      }
};

a260 1
                                        lp_generated_code **OutCode,
a261 1
                                        LLVMMCJITMemoryManagerRef CMM,
d291 1
a291 3
   /* XXX: Workaround http://llvm.org/PR21435 */
#if defined(DEBUG) || defined(PROFILE) || \
    (HAVE_LLVM >= 0x0303 && (defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)))
a303 1
#if HAVE_LLVM < 0x0306
a304 9
#endif
#ifdef _WIN32
       /*
        * MCJIT works on Windows, but currently only through ELF object format.
        */
       std::string targetTriple = llvm::sys::getProcessTriple();
       targetTriple.append("-elf");
       unwrap(M)->setTargetTriple(targetTriple);
#endif
d312 2
a313 2
       * emitting the opcodes. On newer llvm versions it is and at least some
       * versions (tested with 3.3) will emit avx opcodes without this anyway.
d321 1
d323 4
a326 2
#if HAVE_LLVM >= 0x0305
   StringRef MCPU = llvm::sys::getHostCPUName();
d328 1
a328 10
    * The cpu bits are no longer set automatically, so need to set mcpu manually.
    * Note that the MAttrs set above will be sort of ignored (since we should
    * not set any which would not be set by specifying the cpu anyway).
    * It ought to be safe though since getHostCPUName() should include bits
    * not only from the cpu but environment as well (for instance if it's safe
    * to use avx instructions which need OS support). According to
    * http://llvm.org/bugs/show_bug.cgi?id=19429 however if I understand this
    * right it may be necessary to specify older cpu (or disable mattrs) though
    * when not using MCJIT so no instructions are generated which the old JIT
    * can't handle. Not entirely sure if we really need to do anything yet.
d330 4
a333 1
   builder.setMCPU(MCPU);
a334 25

   ShaderMemoryManager *MM;
   if (useMCJIT) {
#if HAVE_LLVM > 0x0303
       BaseMemoryManager* JMM = reinterpret_cast<BaseMemoryManager*>(CMM);
       MM = new ShaderMemoryManager(JMM);
       *OutCode = MM->getGeneratedCode();

       builder.setMCJITMemoryManager(MM);
#endif
   } else {
#if HAVE_LLVM < 0x0306
       BaseMemoryManager* JMM = reinterpret_cast<BaseMemoryManager*>(CMM);
       MM = new ShaderMemoryManager(JMM);
       *OutCode = MM->getGeneratedCode();

       builder.setJITMemoryManager(MM);
#else
       assert(0);
#endif
   }

   ExecutionEngine *JIT;

   JIT = builder.create();
a338 3
   lp_free_generated_code(*OutCode);
   *OutCode = 0;
   delete MM;
d343 1
a343 27

extern "C"
void
lp_free_generated_code(struct lp_generated_code *code)
{
   ShaderMemoryManager::freeGeneratedCode(code);
}

extern "C"
LLVMMCJITMemoryManagerRef
lp_get_default_memory_manager()
{
   BaseMemoryManager *mm;
#if HAVE_LLVM < 0x0306
   mm = llvm::JITMemoryManager::CreateDefaultMemManager();
#else
   mm = new llvm::SectionMemoryManager();
#endif
   return reinterpret_cast<LLVMMCJITMemoryManagerRef>(mm);
}

extern "C"
void
lp_free_memory_manager(LLVMMCJITMemoryManagerRef memorymgr)
{
   delete reinterpret_cast<BaseMemoryManager*>(memorymgr);
}
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a56 1
#if HAVE_LLVM >= 0x0301
d58 1
d60 2
d64 1
a66 1
#if HAVE_LLVM >= 0x0300
a67 3
#else /* HAVE_LLVM < 0x0300 */
#include <llvm/Target/TargetSelect.h>
#endif /* HAVE_LLVM < 0x0300 */
a68 1
#if HAVE_LLVM >= 0x0303
a71 5
#endif

#if HAVE_LLVM >= 0x0305
#include <llvm/Support/Host.h>
#endif
a84 5
#if HAVE_LLVM < 0x0303
      if (!llvm::llvm_is_multithreaded()) {
         llvm::llvm_start_multithreaded();
      }
#else
a87 1
#endif
a97 70
#if HAVE_LLVM <= 0x0300
#if defined(DEBUG)
#if HAVE_LLVM >= 0x0207
   llvm::JITEmitDebugInfo = true;
#endif
#endif

   /*
    * LLVM revision 123367 switched the default stack alignment to 16 bytes on
    * Linux (and several other Unices in later revisions), to match recent gcc
    * versions.
    *
    * However our drivers can be loaded by old binary applications, still
    * maintaining a 4 bytes stack alignment.  Therefore we must tell LLVM here
    * to only assume a 4 bytes alignment for backwards compatibility.
    */
#if defined(PIPE_ARCH_X86)
#if HAVE_LLVM == 0x0300
   llvm::StackAlignmentOverride = 4;
#else
   llvm::StackAlignment = 4;
#endif
#endif

#if defined(DEBUG) || defined(PROFILE)
   llvm::NoFramePointerElim = true;
#if HAVE_LLVM >= 0x0208
   llvm::NoFramePointerElimNonLeaf = true;
#endif
#endif

   llvm::NoExcessFPPrecision = false;

   /* XXX: Investigate this */
#if 0
   llvm::UnsafeFPMath = true;
#endif
#endif  /* HAVE_LLVM <= 0x0300 */

#if HAVE_LLVM < 0x0209
   /*
    * LLVM will generate MMX instructions for vectors <= 64 bits, leading to
    * innefficient code, and in 32bit systems, to the corruption of the FPU
    * stack given that it expects the user to generate the EMMS instructions.
    *
    * See also:
    * - http://llvm.org/bugs/show_bug.cgi?id=3287
    * - http://l4.me.uk/post/2009/06/07/llvm-wrinkle-3-configuration-what-configuration/
    *
    * The -disable-mmx global option can be specified only once  since we
    * dynamically link against LLVM it will reside in a separate shared object,
    * which may or not be delete when this shared object is, so we use the
    * llvm::DisablePrettyStackTrace variable (which we set below and should
    * reside in the same shared library) to determine whether the -disable-mmx
    * option has been set or not.
    *
    * Thankfully this ugly hack is not necessary on LLVM 2.9 onwards.
    */
   if (!llvm::DisablePrettyStackTrace) {
      static boolean first = TRUE;
      static const char* options[] = {
         "prog",
         "-disable-mmx"
      };
      assert(first);
      llvm::cl::ParseCommandLineOptions(2, const_cast<char**>(options));
      first = FALSE;
   }
#endif

a110 1
#if HAVE_LLVM >= 0x0208
a111 7
#elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   LLVMInitializeX86AsmPrinter();
#elif defined(PIPE_ARCH_ARM)
   LLVMInitializeARMAsmPrinter();
#elif defined(PIPE_ARCH_PPC)
   LLVMInitializePowerPCAsmPrinter();
#endif
a112 2
#if HAVE_LLVM >= 0x0207
#  if HAVE_LLVM >= 0x0301
a113 14
#  elif defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
   LLVMInitializeX86Disassembler();
#  elif defined(PIPE_ARCH_ARM)
   LLVMInitializeARMDisassembler();
#  endif
#endif
}


extern "C" void
lp_func_delete_body(LLVMValueRef FF)
{
   llvm::Function *func = llvm::unwrap<llvm::Function>(FF);
   func->deleteBody();
d137 1
a137 1
		       unsigned Align)
d143 247
a389 1
#if HAVE_LLVM >= 0x301
d404 1
d406 1
d436 3
a438 1
#if defined(DEBUG) || defined(PROFILE)
d451 1
d453 9
a477 1
   builder.setJITMemoryManager(JITMemoryManager::CreateDefaultMemManager());
d496 21
a518 1
#if HAVE_LLVM >= 0x0302
a519 9
#else
   /*
    * Workaround http://llvm.org/PR12833
    */
   StringRef MArch = "";
   StringRef MCPU = "";
   Triple TT(unwrap(M)->getTargetTriple());
   JIT = builder.create(builder.selectTarget(TT, MArch, MCPU, MAttrs));
#endif
d524 3
d531 27
a557 1
#endif /* HAVE_LLVM >= 0x301 */
@


