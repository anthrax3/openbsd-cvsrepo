head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.36;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.01;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.43;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.17;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.25;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * @@file
 * Texture sampling.
 *
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 */

#ifndef LP_BLD_SAMPLE_H
#define LP_BLD_SAMPLE_H


#include "pipe/p_format.h"
#include "util/u_debug.h"
#include "gallivm/lp_bld.h"
#include "gallivm/lp_bld_type.h"
#include "gallivm/lp_bld_swizzle.h"


struct pipe_resource;
struct pipe_sampler_view;
struct pipe_sampler_state;
struct util_format_description;
struct lp_type;
struct lp_build_context;


/**
 * Helper struct holding all derivatives needed for sampling
 */
struct lp_derivatives
{
   LLVMValueRef ddx[3];
   LLVMValueRef ddy[3];
};


enum lp_sampler_lod_property {
   LP_SAMPLER_LOD_SCALAR,
   LP_SAMPLER_LOD_PER_ELEMENT,
   LP_SAMPLER_LOD_PER_QUAD
};


/**
 * Texture static state.
 *
 * These are the bits of state from pipe_resource/pipe_sampler_view that
 * are embedded in the generated code.
 */
struct lp_static_texture_state
{
   /* pipe_sampler_view's state */
   enum pipe_format format;
   unsigned swizzle_r:3;     /**< PIPE_SWIZZLE_* */
   unsigned swizzle_g:3;
   unsigned swizzle_b:3;
   unsigned swizzle_a:3;

   /* pipe_texture's state */
   unsigned target:4;        /**< PIPE_TEXTURE_* */
   unsigned pot_width:1;     /**< is the width a power of two? */
   unsigned pot_height:1;
   unsigned pot_depth:1;
   unsigned level_zero_only:1;
};


/**
 * Sampler static state.
 *
 * These are the bits of state from pipe_sampler_state that
 * are embedded in the generated code.
 */
struct lp_static_sampler_state
{
   /* pipe_sampler_state's state */
   unsigned wrap_s:3;
   unsigned wrap_t:3;
   unsigned wrap_r:3;
   unsigned min_img_filter:2;
   unsigned min_mip_filter:2;
   unsigned mag_img_filter:2;
   unsigned compare_mode:1;
   unsigned compare_func:3;
   unsigned normalized_coords:1;
   unsigned min_max_lod_equal:1;  /**< min_lod == max_lod ? */
   unsigned lod_bias_non_zero:1;
   unsigned apply_min_lod:1;  /**< min_lod > 0 ? */
   unsigned apply_max_lod:1;  /**< max_lod < last_level ? */
   unsigned seamless_cube_map:1;

   /* Hacks */
   unsigned force_nearest_s:1;
   unsigned force_nearest_t:1;
};


/**
 * Sampler dynamic state.
 *
 * These are the bits of state from pipe_resource/pipe_sampler_view
 * as well as from sampler state that are computed at runtime.
 *
 * There are obtained through callbacks, as we don't want to tie the texture
 * sampling code generation logic to any particular texture layout or pipe
 * driver.
 */
struct lp_sampler_dynamic_state
{
   /* First callbacks for sampler view state */

   /** Obtain the base texture width (or number of elements) (returns int32) */
   LLVMValueRef
   (*width)( const struct lp_sampler_dynamic_state *state,
             struct gallivm_state *gallivm,
             unsigned texture_unit);

   /** Obtain the base texture height (returns int32) */
   LLVMValueRef
   (*height)( const struct lp_sampler_dynamic_state *state,
              struct gallivm_state *gallivm,
              unsigned texture_unit);

   /** Obtain the base texture depth (or array size) (returns int32) */
   LLVMValueRef
   (*depth)( const struct lp_sampler_dynamic_state *state,
             struct gallivm_state *gallivm,
             unsigned texture_unit);

   /** Obtain the first mipmap level (base level) (returns int32) */
   LLVMValueRef
   (*first_level)( const struct lp_sampler_dynamic_state *state,
                   struct gallivm_state *gallivm,
                   unsigned texture_unit);

   /** Obtain the number of mipmap levels minus one (returns int32) */
   LLVMValueRef
   (*last_level)( const struct lp_sampler_dynamic_state *state,
                  struct gallivm_state *gallivm,
                  unsigned texture_unit);

   /** Obtain stride in bytes between image rows/blocks (returns int32) */
   LLVMValueRef
   (*row_stride)( const struct lp_sampler_dynamic_state *state,
                  struct gallivm_state *gallivm,
                  unsigned texture_unit);

   /** Obtain stride in bytes between image slices (returns int32) */
   LLVMValueRef
   (*img_stride)( const struct lp_sampler_dynamic_state *state,
                  struct gallivm_state *gallivm,
                  unsigned texture_unit);

   /** Obtain pointer to base of texture */
   LLVMValueRef
   (*base_ptr)( const struct lp_sampler_dynamic_state *state,
                struct gallivm_state *gallivm,
                unsigned texture_unit);

   /** Obtain pointer to array of mipmap offsets */
   LLVMValueRef
   (*mip_offsets)( const struct lp_sampler_dynamic_state *state,
                   struct gallivm_state *gallivm,
                   unsigned texture_unit);

   /* These are callbacks for sampler state */

   /** Obtain texture min lod (returns float) */
   LLVMValueRef
   (*min_lod)(const struct lp_sampler_dynamic_state *state,
              struct gallivm_state *gallivm, unsigned sampler_unit);

   /** Obtain texture max lod (returns float) */
   LLVMValueRef
   (*max_lod)(const struct lp_sampler_dynamic_state *state,
              struct gallivm_state *gallivm, unsigned sampler_unit);

   /** Obtain texture lod bias (returns float) */
   LLVMValueRef
   (*lod_bias)(const struct lp_sampler_dynamic_state *state,
               struct gallivm_state *gallivm, unsigned sampler_unit);

   /** Obtain texture border color (returns ptr to float[4]) */
   LLVMValueRef
   (*border_color)(const struct lp_sampler_dynamic_state *state,
                   struct gallivm_state *gallivm, unsigned sampler_unit);
};


/**
 * Keep all information for sampling code generation in a single place.
 */
struct lp_build_sample_context
{
   struct gallivm_state *gallivm;

   const struct lp_static_texture_state *static_texture_state;
   const struct lp_static_sampler_state *static_sampler_state;

   struct lp_sampler_dynamic_state *dynamic_state;

   const struct util_format_description *format_desc;

   /* See texture_dims() */
   unsigned dims;

   /** SIMD vector width */
   unsigned vector_width;

   /** number of mipmaps (valid are 1, length/4, length) */
   unsigned num_mips;

   /** number of lod values (valid are 1, length/4, length) */
   unsigned num_lods;

   /** regular scalar float type */
   struct lp_type float_type;
   struct lp_build_context float_bld;

   /** float vector type */
   struct lp_build_context float_vec_bld;

   /** regular scalar int type */
   struct lp_type int_type;
   struct lp_build_context int_bld;

   /** Incoming coordinates type and build context */
   struct lp_type coord_type;
   struct lp_build_context coord_bld;

   /** Signed integer coordinates */
   struct lp_type int_coord_type;
   struct lp_build_context int_coord_bld;

   /** Unsigned integer texture size */
   struct lp_type int_size_in_type;
   struct lp_build_context int_size_in_bld;

   /** Float incoming texture size */
   struct lp_type float_size_in_type;
   struct lp_build_context float_size_in_bld;

   /** Unsigned integer texture size (might be per quad) */
   struct lp_type int_size_type;
   struct lp_build_context int_size_bld;

   /** Float texture size (might be per quad) */
   struct lp_type float_size_type;
   struct lp_build_context float_size_bld;

   /** Output texels type and build context */
   struct lp_type texel_type;
   struct lp_build_context texel_bld;

   /** Float level type */
   struct lp_type levelf_type;
   struct lp_build_context levelf_bld;

   /** Int level type */
   struct lp_type leveli_type;
   struct lp_build_context leveli_bld;

   /** Float lod type */
   struct lp_type lodf_type;
   struct lp_build_context lodf_bld;

   /** Int lod type */
   struct lp_type lodi_type;
   struct lp_build_context lodi_bld;

   /* Common dynamic state values */
   LLVMValueRef row_stride_array;
   LLVMValueRef img_stride_array;
   LLVMValueRef base_ptr;
   LLVMValueRef mip_offsets;

   /** Integer vector with texture width, height, depth */
   LLVMValueRef int_size;

   LLVMValueRef border_color_clamped;
};



/**
 * We only support a few wrap modes in lp_build_sample_wrap_linear_int() at
 * this time.  Return whether the given mode is supported by that function.
 */
static INLINE boolean
lp_is_simple_wrap_mode(unsigned mode)
{
   switch (mode) {
   case PIPE_TEX_WRAP_REPEAT:
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      return TRUE;
   default:
      return FALSE;
   }
}


static INLINE void
apply_sampler_swizzle(struct lp_build_sample_context *bld,
                      LLVMValueRef *texel)
{
   unsigned char swizzles[4];

   swizzles[0] = bld->static_texture_state->swizzle_r;
   swizzles[1] = bld->static_texture_state->swizzle_g;
   swizzles[2] = bld->static_texture_state->swizzle_b;
   swizzles[3] = bld->static_texture_state->swizzle_a;

   lp_build_swizzle_soa_inplace(&bld->texel_bld, texel, swizzles);
}

/*
 * not really dimension as such, this indicates the amount of
 * "normal" texture coords subject to minification, wrapping etc.
 */
static INLINE unsigned
texture_dims(enum pipe_texture_target tex)
{
   switch (tex) {
   case PIPE_TEXTURE_1D:
   case PIPE_TEXTURE_1D_ARRAY:
   case PIPE_BUFFER:
      return 1;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_2D_ARRAY:
   case PIPE_TEXTURE_RECT:
   case PIPE_TEXTURE_CUBE:
      return 2;
   case PIPE_TEXTURE_CUBE_ARRAY:
      assert(0);
      return 2;
   case PIPE_TEXTURE_3D:
      return 3;
   default:
      assert(0 && "bad texture target in texture_dims()");
      return 2;
   }
}


boolean
lp_sampler_wrap_mode_uses_border_color(unsigned mode,
                                       unsigned min_img_filter,
                                       unsigned mag_img_filter);

/**
 * Derive the sampler static state.
 */
void
lp_sampler_static_sampler_state(struct lp_static_sampler_state *state,
                                const struct pipe_sampler_state *sampler);


void
lp_sampler_static_texture_state(struct lp_static_texture_state *state,
                                const struct pipe_sampler_view *view);


void
lp_build_lod_selector(struct lp_build_sample_context *bld,
                      unsigned texture_index,
                      unsigned sampler_index,
                      LLVMValueRef s,
                      LLVMValueRef t,
                      LLVMValueRef r,
                      LLVMValueRef cube_rho,
                      const struct lp_derivatives *derivs,
                      LLVMValueRef lod_bias, /* optional */
                      LLVMValueRef explicit_lod, /* optional */
                      unsigned mip_filter,
                      LLVMValueRef *out_lod_ipart,
                      LLVMValueRef *out_lod_fpart,
                      LLVMValueRef *out_lod_positive);

void
lp_build_nearest_mip_level(struct lp_build_sample_context *bld,
                           unsigned texture_unit,
                           LLVMValueRef lod,
                           LLVMValueRef *level_out,
                           LLVMValueRef *out_of_bounds);

void
lp_build_linear_mip_levels(struct lp_build_sample_context *bld,
                           unsigned texture_unit,
                           LLVMValueRef lod_ipart,
                           LLVMValueRef *lod_fpart_inout,
                           LLVMValueRef *level0_out,
                           LLVMValueRef *level1_out);

LLVMValueRef
lp_build_get_mipmap_level(struct lp_build_sample_context *bld,
                          LLVMValueRef level);


LLVMValueRef
lp_build_get_mip_offsets(struct lp_build_sample_context *bld,
                         LLVMValueRef level);


void
lp_build_mipmap_level_sizes(struct lp_build_sample_context *bld,
                            LLVMValueRef ilevel,
                            LLVMValueRef *out_size_vec,
                            LLVMValueRef *row_stride_vec,
                            LLVMValueRef *img_stride_vec);


void
lp_build_extract_image_sizes(struct lp_build_sample_context *bld,
                             struct lp_build_context *size_bld,
                             struct lp_type coord_type,
                             LLVMValueRef size,
                             LLVMValueRef *out_width,
                             LLVMValueRef *out_height,
                             LLVMValueRef *out_depth);


void
lp_build_unnormalized_coords(struct lp_build_sample_context *bld,
                             LLVMValueRef flt_size,
                             LLVMValueRef *s,
                             LLVMValueRef *t,
                             LLVMValueRef *r);


void
lp_build_cube_lookup(struct lp_build_sample_context *bld,
                     LLVMValueRef *coords,
                     const struct lp_derivatives *derivs_in, /* optional */
                     LLVMValueRef *rho,
                     struct lp_derivatives *derivs_out, /* optional */
                     boolean need_derivs);


void
lp_build_cube_new_coords(struct lp_build_context *ivec_bld,
                         LLVMValueRef face,
                         LLVMValueRef x0,
                         LLVMValueRef x1,
                         LLVMValueRef y0,
                         LLVMValueRef y1,
                         LLVMValueRef max_coord,
                         LLVMValueRef new_faces[4],
                         LLVMValueRef new_xcoords[4][2],
                         LLVMValueRef new_ycoords[4][2]);


void
lp_build_sample_partial_offset(struct lp_build_context *bld,
                               unsigned block_length,
                               LLVMValueRef coord,
                               LLVMValueRef stride,
                               LLVMValueRef *out_offset,
                               LLVMValueRef *out_i);


void
lp_build_sample_offset(struct lp_build_context *bld,
                       const struct util_format_description *format_desc,
                       LLVMValueRef x,
                       LLVMValueRef y,
                       LLVMValueRef z,
                       LLVMValueRef y_stride,
                       LLVMValueRef z_stride,
                       LLVMValueRef *out_offset,
                       LLVMValueRef *out_i,
                       LLVMValueRef *out_j);


void
lp_build_sample_soa(struct gallivm_state *gallivm,
                    const struct lp_static_texture_state *static_texture_state,
                    const struct lp_static_sampler_state *static_sampler_state,
                    struct lp_sampler_dynamic_state *dynamic_texture_state,
                    struct lp_type fp_type,
                    boolean is_fetch,
                    unsigned texture_index,
                    unsigned sampler_index,
                    const LLVMValueRef *coords,
                    const LLVMValueRef *offsets,
                    const struct lp_derivatives *derivs,
                    LLVMValueRef lod_bias,
                    LLVMValueRef explicit_lod,
                    enum lp_sampler_lod_property lod_property,
                    LLVMValueRef texel_out[4]);


void
lp_build_coord_repeat_npot_linear(struct lp_build_sample_context *bld,
                                  LLVMValueRef coord_f,
                                  LLVMValueRef length_i,
                                  LLVMValueRef length_f,
                                  LLVMValueRef *coord0_i,
                                  LLVMValueRef *weight_f);


void
lp_build_size_query_soa(struct gallivm_state *gallivm,
                        const struct lp_static_texture_state *static_state,
                        struct lp_sampler_dynamic_state *dynamic_state,
                        struct lp_type int_type,
                        unsigned texture_unit,
                        unsigned target,
                        boolean is_sviewinfo,
                        enum lp_sampler_lod_property lod_property,
                        LLVMValueRef explicit_lod,
                        LLVMValueRef *sizes_out);

void
lp_build_sample_nop(struct gallivm_state *gallivm, 
                    struct lp_type type,
                    const LLVMValueRef *coords,
                    LLVMValueRef texel_out[4]);


LLVMValueRef
lp_build_minify(struct lp_build_context *bld,
                LLVMValueRef base_size,
                LLVMValueRef level,
                boolean lod_scalar);


#endif /* LP_BLD_SAMPLE_H */
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d359 1
d361 1
a367 15
   }
}

static INLINE boolean
has_layer_coord(enum pipe_texture_target tex)
{
   switch (tex) {
   case PIPE_TEXTURE_1D_ARRAY:
   case PIPE_TEXTURE_2D_ARRAY:
   /* cube is not layered but 3rd coord (after cube mapping) behaves the same */
   case PIPE_TEXTURE_CUBE:
   case PIPE_TEXTURE_CUBE_ARRAY:
      return TRUE;
   default:
      return FALSE;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a358 1
      return 2;
a359 1
      assert(0);
d366 15
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d64 7
d117 1
d237 4
a240 1
   /** number of lod values (valid are 1, length/4, length) */
d290 8
d306 2
d360 3
d403 2
a404 1
                      LLVMValueRef *out_lod_fpart);
d410 2
a411 1
                           LLVMValueRef *level_out);
d459 2
a460 7
                     LLVMValueRef s,
                     LLVMValueRef t,
                     LLVMValueRef r,
                     const struct lp_derivatives *derivs, /* optional */
                     LLVMValueRef *face,
                     LLVMValueRef *face_s,
                     LLVMValueRef *face_t,
d462 1
d467 13
d515 1
a515 1
                    boolean scalar_lod,
d534 3
a536 1
                        boolean need_nr_mips,
d550 2
a551 1
                LLVMValueRef level);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d55 11
a65 1
 * Sampler static state.
d67 1
a67 1
 * These are the bits of state from pipe_resource and pipe_sampler_state that
d70 1
a70 1
struct lp_sampler_static_state
d80 1
a80 1
   unsigned target:3;        /**< PIPE_TEXTURE_* */
d84 3
d88 8
d110 4
d120 2
a121 2
 * These are the bits of state from pipe_resource and pipe_sampler_state that
 * are computed in runtime.
d129 1
d131 1
a131 1
   /** Obtain the base texture width (returns int32) */
d135 1
a135 1
             unsigned unit);
d141 1
a141 1
              unsigned unit);
d143 1
a143 1
   /** Obtain the base texture depth (returns int32) */
d147 1
a147 1
             unsigned unit);
d153 1
a153 1
                   unsigned unit);
d159 1
a159 1
                  unsigned unit);
d165 1
a165 1
                  unsigned unit);
d171 1
a171 1
                  unsigned unit);
d173 1
a173 1
   /** Obtain pointer to array of pointers to mimpap levels */
d175 1
a175 1
   (*data_ptr)( const struct lp_sampler_dynamic_state *state,
d177 9
a185 1
                unsigned unit);
d190 1
a190 1
              struct gallivm_state *gallivm, unsigned unit);
d195 1
a195 1
              struct gallivm_state *gallivm, unsigned unit);
d200 1
a200 1
               struct gallivm_state *gallivm, unsigned unit);
d205 1
a205 1
                   struct gallivm_state *gallivm, unsigned unit);
d216 2
a217 1
   const struct lp_sampler_static_state *static_state;
d226 6
d239 1
a239 1
   /** regular scalar float type */
d252 8
d263 1
a263 1
   /** Unsigned integer texture size */
d271 8
a279 3
   LLVMValueRef width;
   LLVMValueRef height;
   LLVMValueRef depth;
d282 2
a283 1
   LLVMValueRef data_array;
d314 4
a317 4
   swizzles[0] = bld->static_state->swizzle_r;
   swizzles[1] = bld->static_state->swizzle_g;
   swizzles[2] = bld->static_state->swizzle_b;
   swizzles[3] = bld->static_state->swizzle_a;
d322 4
a325 1

d331 2
d335 1
d357 7
a363 3
lp_sampler_static_state(struct lp_sampler_static_state *state,
                        const struct pipe_sampler_view *view,
                        const struct pipe_sampler_state *sampler);
d368 7
a374 3
                      unsigned unit,
                      const LLVMValueRef ddx[4],
                      const LLVMValueRef ddy[4],
d383 1
a383 1
                           unsigned unit,
d389 1
a389 1
                           unsigned unit,
d399 1
d401 2
a402 2
lp_build_get_const_mipmap_level(struct lp_build_sample_context *bld,
                                int level);
d415 1
a415 1
                             struct lp_type size_type,
d436 1
d439 3
a441 1
                     LLVMValueRef *face_t);
d468 3
a470 2
                    const struct lp_sampler_static_state *static_state,
                    struct lp_sampler_dynamic_state *dynamic_state,
d472 3
a474 2
                    unsigned unit,
                    unsigned num_coords,
d476 2
a477 2
                    const LLVMValueRef *ddx,
                    const LLVMValueRef *ddy,
d480 1
d483 20
d504 3
a506 1
lp_build_sample_nop(struct gallivm_state *gallivm, struct lp_type type,
d508 6
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d123 6
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 5
a43 1
#include <llvm-c/Core.h>
d45 3
a47 1
struct pipe_texture;
d57 1
a57 1
 * These are the bits of state from pipe_texture and pipe_sampler_state that
d62 7
d70 2
a71 3
   enum pipe_format format;
   unsigned target:2;
   unsigned pot_width:1;
d85 4
a88 2
   float lod_bias, min_lod, max_lod;
   float border_color[4];
d95 1
a95 1
 * These are the bits of state from pipe_texture and pipe_sampler_state that
d105 1
a105 1
   /** Obtain the base texture width. */
d107 2
a108 2
   (*width)( struct lp_sampler_dynamic_state *state,
             LLVMBuilderRef builder,
d111 1
a111 1
   /** Obtain the base texture height. */
d113 2
a114 2
   (*height)( struct lp_sampler_dynamic_state *state,
              LLVMBuilderRef builder,
d117 1
a117 1
   /** Obtain the base texture depth. */
d119 2
a120 2
   (*depth)( struct lp_sampler_dynamic_state *state,
             LLVMBuilderRef builder,
d123 7
a129 1
   /** Obtain the number of mipmap levels (minus one). */
d131 2
a132 2
   (*last_level)( struct lp_sampler_dynamic_state *state,
                  LLVMBuilderRef builder,
d135 1
d137 3
a139 3
   (*stride)( struct lp_sampler_dynamic_state *state,
              LLVMBuilderRef builder,
              unsigned unit);
d141 1
d143 2
a144 2
   (*data_ptr)( struct lp_sampler_dynamic_state *state,
                LLVMBuilderRef builder,
d147 79
d229 57
d291 1
a291 1
                        const struct pipe_texture *texture,
d295 29
d325 2
a326 6
lp_build_gather(LLVMBuilderRef builder,
                unsigned length,
                unsigned src_width,
                unsigned dst_width,
                LLVMValueRef base_ptr,
                LLVMValueRef offsets);
d329 46
a374 1
LLVMValueRef
d379 1
d381 4
a384 1
                       LLVMValueRef data_ptr);
d388 1
a388 1
lp_build_sample_soa(LLVMBuilderRef builder,
d395 5
a399 2
                    LLVMValueRef lodbias,
                    LLVMValueRef *texel);
d401 3
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d39 1
a39 5
#include "pipe/p_format.h"
#include "util/u_debug.h"
#include "gallivm/lp_bld.h"
#include "gallivm/lp_bld_type.h"
#include "gallivm/lp_bld_swizzle.h"
d41 1
a41 3

struct pipe_resource;
struct pipe_sampler_view;
d51 1
a51 1
 * These are the bits of state from pipe_resource and pipe_sampler_state that
d56 1
a56 1
   /* pipe_sampler_view's state */
d58 2
a59 8
   unsigned swizzle_r:3;     /**< PIPE_SWIZZLE_* */
   unsigned swizzle_g:3;
   unsigned swizzle_b:3;
   unsigned swizzle_a:3;

   /* pipe_texture's state */
   unsigned target:3;        /**< PIPE_TEXTURE_* */
   unsigned pot_width:1;     /**< is the width a power of two? */
d73 2
a74 4
   unsigned min_max_lod_equal:1;  /**< min_lod == max_lod ? */
   unsigned lod_bias_non_zero:1;
   unsigned apply_min_lod:1;  /**< min_lod > 0 ? */
   unsigned apply_max_lod:1;  /**< max_lod < last_level ? */
d81 1
a81 1
 * These are the bits of state from pipe_resource and pipe_sampler_state that
d91 1
a91 1
   /** Obtain the base texture width (returns int32) */
d93 2
a94 2
   (*width)( const struct lp_sampler_dynamic_state *state,
             struct gallivm_state *gallivm,
d97 1
a97 1
   /** Obtain the base texture height (returns int32) */
d99 2
a100 2
   (*height)( const struct lp_sampler_dynamic_state *state,
              struct gallivm_state *gallivm,
d103 1
a103 1
   /** Obtain the base texture depth (returns int32) */
d105 2
a106 2
   (*depth)( const struct lp_sampler_dynamic_state *state,
             struct gallivm_state *gallivm,
d109 1
a109 1
   /** Obtain the number of mipmap levels minus one (returns int32) */
d111 2
a112 2
   (*last_level)( const struct lp_sampler_dynamic_state *state,
                  struct gallivm_state *gallivm,
a114 1
   /** Obtain stride in bytes between image rows/blocks (returns int32) */
d116 3
a118 3
   (*row_stride)( const struct lp_sampler_dynamic_state *state,
                  struct gallivm_state *gallivm,
                  unsigned unit);
a119 1
   /** Obtain stride in bytes between image slices (returns int32) */
d121 2
a122 8
   (*img_stride)( const struct lp_sampler_dynamic_state *state,
                  struct gallivm_state *gallivm,
                  unsigned unit);

   /** Obtain pointer to array of pointers to mimpap levels */
   LLVMValueRef
   (*data_ptr)( const struct lp_sampler_dynamic_state *state,
                struct gallivm_state *gallivm,
a124 79
   /** Obtain texture min lod (returns float) */
   LLVMValueRef
   (*min_lod)(const struct lp_sampler_dynamic_state *state,
              struct gallivm_state *gallivm, unsigned unit);

   /** Obtain texture max lod (returns float) */
   LLVMValueRef
   (*max_lod)(const struct lp_sampler_dynamic_state *state,
              struct gallivm_state *gallivm, unsigned unit);

   /** Obtain texture lod bias (returns float) */
   LLVMValueRef
   (*lod_bias)(const struct lp_sampler_dynamic_state *state,
               struct gallivm_state *gallivm, unsigned unit);

   /** Obtain texture border color (returns ptr to float[4]) */
   LLVMValueRef
   (*border_color)(const struct lp_sampler_dynamic_state *state,
                   struct gallivm_state *gallivm, unsigned unit);
};


/**
 * Keep all information for sampling code generation in a single place.
 */
struct lp_build_sample_context
{
   struct gallivm_state *gallivm;

   const struct lp_sampler_static_state *static_state;

   struct lp_sampler_dynamic_state *dynamic_state;

   const struct util_format_description *format_desc;

   /* See texture_dims() */
   unsigned dims;

   /** regular scalar float type */
   struct lp_type float_type;
   struct lp_build_context float_bld;

   /** float vector type */
   struct lp_build_context float_vec_bld;

   /** regular scalar float type */
   struct lp_type int_type;
   struct lp_build_context int_bld;

   /** Incoming coordinates type and build context */
   struct lp_type coord_type;
   struct lp_build_context coord_bld;

   /** Signed integer coordinates */
   struct lp_type int_coord_type;
   struct lp_build_context int_coord_bld;

   /** Unsigned integer texture size */
   struct lp_type int_size_type;
   struct lp_build_context int_size_bld;

   /** Unsigned integer texture size */
   struct lp_type float_size_type;
   struct lp_build_context float_size_bld;

   /** Output texels type and build context */
   struct lp_type texel_type;
   struct lp_build_context texel_bld;

   /* Common dynamic state values */
   LLVMValueRef width;
   LLVMValueRef height;
   LLVMValueRef depth;
   LLVMValueRef row_stride_array;
   LLVMValueRef img_stride_array;
   LLVMValueRef data_array;

   /** Integer vector with texture width, height, depth */
   LLVMValueRef int_size;
a127 57

/**
 * We only support a few wrap modes in lp_build_sample_wrap_linear_int() at
 * this time.  Return whether the given mode is supported by that function.
 */
static INLINE boolean
lp_is_simple_wrap_mode(unsigned mode)
{
   switch (mode) {
   case PIPE_TEX_WRAP_REPEAT:
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      return TRUE;
   default:
      return FALSE;
   }
}


static INLINE void
apply_sampler_swizzle(struct lp_build_sample_context *bld,
                      LLVMValueRef *texel)
{
   unsigned char swizzles[4];

   swizzles[0] = bld->static_state->swizzle_r;
   swizzles[1] = bld->static_state->swizzle_g;
   swizzles[2] = bld->static_state->swizzle_b;
   swizzles[3] = bld->static_state->swizzle_a;

   lp_build_swizzle_soa_inplace(&bld->texel_bld, texel, swizzles);
}


static INLINE unsigned
texture_dims(enum pipe_texture_target tex)
{
   switch (tex) {
   case PIPE_TEXTURE_1D:
      return 1;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
   case PIPE_TEXTURE_CUBE:
      return 2;
   case PIPE_TEXTURE_3D:
      return 3;
   default:
      assert(0 && "bad texture target in texture_dims()");
      return 2;
   }
}


boolean
lp_sampler_wrap_mode_uses_border_color(unsigned mode,
                                       unsigned min_img_filter,
                                       unsigned mag_img_filter);

d133 1
a133 1
                        const struct pipe_sampler_view *view,
d137 7
a143 10
void
lp_build_lod_selector(struct lp_build_sample_context *bld,
                      unsigned unit,
                      const LLVMValueRef ddx[4],
                      const LLVMValueRef ddy[4],
                      LLVMValueRef lod_bias, /* optional */
                      LLVMValueRef explicit_lod, /* optional */
                      unsigned mip_filter,
                      LLVMValueRef *out_lod_ipart,
                      LLVMValueRef *out_lod_fpart);
a144 17
void
lp_build_nearest_mip_level(struct lp_build_sample_context *bld,
                           unsigned unit,
                           LLVMValueRef lod,
                           LLVMValueRef *level_out);

void
lp_build_linear_mip_levels(struct lp_build_sample_context *bld,
                           unsigned unit,
                           LLVMValueRef lod_ipart,
                           LLVMValueRef *lod_fpart_inout,
                           LLVMValueRef *level0_out,
                           LLVMValueRef *level1_out);

LLVMValueRef
lp_build_get_mipmap_level(struct lp_build_sample_context *bld,
                          LLVMValueRef level);
a146 50
lp_build_get_const_mipmap_level(struct lp_build_sample_context *bld,
                                int level);


void
lp_build_mipmap_level_sizes(struct lp_build_sample_context *bld,
                            LLVMValueRef ilevel,
                            LLVMValueRef *out_size_vec,
                            LLVMValueRef *row_stride_vec,
                            LLVMValueRef *img_stride_vec);


void
lp_build_extract_image_sizes(struct lp_build_sample_context *bld,
                             struct lp_type size_type,
                             struct lp_type coord_type,
                             LLVMValueRef size,
                             LLVMValueRef *out_width,
                             LLVMValueRef *out_height,
                             LLVMValueRef *out_depth);


void
lp_build_unnormalized_coords(struct lp_build_sample_context *bld,
                             LLVMValueRef flt_size,
                             LLVMValueRef *s,
                             LLVMValueRef *t,
                             LLVMValueRef *r);


void
lp_build_cube_lookup(struct lp_build_sample_context *bld,
                     LLVMValueRef s,
                     LLVMValueRef t,
                     LLVMValueRef r,
                     LLVMValueRef *face,
                     LLVMValueRef *face_s,
                     LLVMValueRef *face_t);


void
lp_build_sample_partial_offset(struct lp_build_context *bld,
                               unsigned block_length,
                               LLVMValueRef coord,
                               LLVMValueRef stride,
                               LLVMValueRef *out_offset,
                               LLVMValueRef *out_i);


void
a150 1
                       LLVMValueRef z,
d152 1
a152 4
                       LLVMValueRef z_stride,
                       LLVMValueRef *out_offset,
                       LLVMValueRef *out_i,
                       LLVMValueRef *out_j);
d156 1
a156 1
lp_build_sample_soa(struct gallivm_state *gallivm,
d163 2
a164 5
                    const LLVMValueRef *ddx,
                    const LLVMValueRef *ddy,
                    LLVMValueRef lod_bias,
                    LLVMValueRef explicit_lod,
                    LLVMValueRef texel_out[4]);
a165 3
void
lp_build_sample_nop(struct gallivm_state *gallivm, struct lp_type type,
                    LLVMValueRef texel_out[4]);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d55 1
a55 11
 * Helper struct holding all derivatives needed for sampling
 */
struct lp_derivatives
{
   LLVMValueRef ddx[3];
   LLVMValueRef ddy[3];
};


/**
 * Texture static state.
d57 1
a57 1
 * These are the bits of state from pipe_resource/pipe_sampler_view that
d60 1
a60 1
struct lp_static_texture_state
d70 1
a70 1
   unsigned target:4;        /**< PIPE_TEXTURE_* */
a73 3
   unsigned level_zero_only:1;
};

a74 8
/**
 * Sampler static state.
 *
 * These are the bits of state from pipe_sampler_state that
 * are embedded in the generated code.
 */
struct lp_static_sampler_state
{
a88 4

   /* Hacks */
   unsigned force_nearest_s:1;
   unsigned force_nearest_t:1;
d95 2
a96 2
 * These are the bits of state from pipe_resource/pipe_sampler_view
 * as well as from sampler state that are computed at runtime.
a103 1
   /* First callbacks for sampler view state */
d105 1
a105 1
   /** Obtain the base texture width (or number of elements) (returns int32) */
d109 1
a109 1
             unsigned texture_unit);
d115 1
a115 1
              unsigned texture_unit);
d117 1
a117 1
   /** Obtain the base texture depth (or array size) (returns int32) */
d121 1
a121 7
             unsigned texture_unit);

   /** Obtain the first mipmap level (base level) (returns int32) */
   LLVMValueRef
   (*first_level)( const struct lp_sampler_dynamic_state *state,
                   struct gallivm_state *gallivm,
                   unsigned texture_unit);
d127 1
a127 1
                  unsigned texture_unit);
d133 1
a133 1
                  unsigned texture_unit);
d139 1
a139 1
                  unsigned texture_unit);
d141 1
a141 1
   /** Obtain pointer to base of texture */
d143 1
a143 1
   (*base_ptr)( const struct lp_sampler_dynamic_state *state,
d145 1
a145 9
                unsigned texture_unit);

   /** Obtain pointer to array of mipmap offsets */
   LLVMValueRef
   (*mip_offsets)( const struct lp_sampler_dynamic_state *state,
                   struct gallivm_state *gallivm,
                   unsigned texture_unit);

   /* These are callbacks for sampler state */
d150 1
a150 1
              struct gallivm_state *gallivm, unsigned sampler_unit);
d155 1
a155 1
              struct gallivm_state *gallivm, unsigned sampler_unit);
d160 1
a160 1
               struct gallivm_state *gallivm, unsigned sampler_unit);
d165 1
a165 1
                   struct gallivm_state *gallivm, unsigned sampler_unit);
d176 1
a176 2
   const struct lp_static_texture_state *static_texture_state;
   const struct lp_static_sampler_state *static_sampler_state;
a184 6
   /** SIMD vector width */
   unsigned vector_width;

   /** number of lod values (valid are 1, length/4, length) */
   unsigned num_lods;

d192 1
a192 1
   /** regular scalar int type */
a204 8
   struct lp_type int_size_in_type;
   struct lp_build_context int_size_in_bld;

   /** Float incoming texture size */
   struct lp_type float_size_in_type;
   struct lp_build_context float_size_in_bld;

   /** Unsigned integer texture size (might be per quad) */
d208 1
a208 1
   /** Float texture size (might be per quad) */
a215 8
   /** Float level type */
   struct lp_type levelf_type;
   struct lp_build_context levelf_bld;

   /** Int level type */
   struct lp_type leveli_type;
   struct lp_build_context leveli_bld;

d217 3
d222 1
a222 2
   LLVMValueRef base_ptr;
   LLVMValueRef mip_offsets;
d253 4
a256 4
   swizzles[0] = bld->static_texture_state->swizzle_r;
   swizzles[1] = bld->static_texture_state->swizzle_g;
   swizzles[2] = bld->static_texture_state->swizzle_b;
   swizzles[3] = bld->static_texture_state->swizzle_a;
d261 1
a261 4
/*
 * not really dimension as such, this indicates the amount of
 * "normal" texture coords subject to minification, wrapping etc.
 */
a266 2
   case PIPE_TEXTURE_1D_ARRAY:
   case PIPE_BUFFER:
a268 1
   case PIPE_TEXTURE_2D_ARRAY:
d290 3
a292 7
lp_sampler_static_sampler_state(struct lp_static_sampler_state *state,
                                const struct pipe_sampler_state *sampler);


void
lp_sampler_static_texture_state(struct lp_static_texture_state *state,
                                const struct pipe_sampler_view *view);
d297 3
a299 7
                      unsigned texture_index,
                      unsigned sampler_index,
                      LLVMValueRef s,
                      LLVMValueRef t,
                      LLVMValueRef r,
                      LLVMValueRef cube_rho,
                      const struct lp_derivatives *derivs,
d308 1
a308 1
                           unsigned texture_unit,
d314 1
a314 1
                           unsigned texture_unit,
a323 1

d325 2
a326 2
lp_build_get_mip_offsets(struct lp_build_sample_context *bld,
                         LLVMValueRef level);
d339 1
a339 1
                             struct lp_build_context *size_bld,
a359 1
                     const struct lp_derivatives *derivs, /* optional */
d362 1
a362 3
                     LLVMValueRef *face_t,
                     LLVMValueRef *rho,
                     boolean need_derivs);
d389 2
a390 3
                    const struct lp_static_texture_state *static_texture_state,
                    const struct lp_static_sampler_state *static_sampler_state,
                    struct lp_sampler_dynamic_state *dynamic_texture_state,
d392 2
a393 3
                    boolean is_fetch,
                    unsigned texture_index,
                    unsigned sampler_index,
d395 2
a396 2
                    const LLVMValueRef *offsets,
                    const struct lp_derivatives *derivs,
a398 1
                    boolean scalar_lod,
a400 10

void
lp_build_coord_repeat_npot_linear(struct lp_build_sample_context *bld,
                                  LLVMValueRef coord_f,
                                  LLVMValueRef length_i,
                                  LLVMValueRef length_f,
                                  LLVMValueRef *coord0_i,
                                  LLVMValueRef *weight_f);


d402 1
a402 13
lp_build_size_query_soa(struct gallivm_state *gallivm,
                        const struct lp_static_texture_state *static_state,
                        struct lp_sampler_dynamic_state *dynamic_state,
                        struct lp_type int_type,
                        unsigned texture_unit,
                        boolean need_nr_mips,
                        LLVMValueRef explicit_lod,
                        LLVMValueRef *sizes_out);

void
lp_build_sample_nop(struct gallivm_state *gallivm, 
                    struct lp_type type,
                    const LLVMValueRef *coords,
a403 6


LLVMValueRef
lp_build_minify(struct lp_build_context *bld,
                LLVMValueRef base_size,
                LLVMValueRef level);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a63 7
enum lp_sampler_lod_property {
   LP_SAMPLER_LOD_SCALAR,
   LP_SAMPLER_LOD_PER_ELEMENT,
   LP_SAMPLER_LOD_PER_QUAD
};


a109 1
   unsigned seamless_cube_map:1;
d229 1
a229 4
   /** number of mipmaps (valid are 1, length/4, length) */
   unsigned num_mips;

   /** number of lod values (valid are 1, length/4, length) */
a278 8
   /** Float lod type */
   struct lp_type lodf_type;
   struct lp_build_context lodf_bld;

   /** Int lod type */
   struct lp_type lodi_type;
   struct lp_build_context lodi_bld;

a286 2

   LLVMValueRef border_color_clamped;
a338 3
   case PIPE_TEXTURE_CUBE_ARRAY:
      assert(0);
      return 2;
d379 1
a379 2
                      LLVMValueRef *out_lod_fpart,
                      LLVMValueRef *out_lod_positive);
d385 1
a385 2
                           LLVMValueRef *level_out,
                           LLVMValueRef *out_of_bounds);
d433 7
a439 2
                     LLVMValueRef *coords,
                     const struct lp_derivatives *derivs_in, /* optional */
a440 1
                     struct lp_derivatives *derivs_out, /* optional */
a444 13
lp_build_cube_new_coords(struct lp_build_context *ivec_bld,
                         LLVMValueRef face,
                         LLVMValueRef x0,
                         LLVMValueRef x1,
                         LLVMValueRef y0,
                         LLVMValueRef y1,
                         LLVMValueRef max_coord,
                         LLVMValueRef new_faces[4],
                         LLVMValueRef new_xcoords[4][2],
                         LLVMValueRef new_ycoords[4][2]);


void
d480 1
a480 1
                    enum lp_sampler_lod_property lod_property,
d499 1
a499 3
                        unsigned target,
                        boolean is_sviewinfo,
                        enum lp_sampler_lod_property lod_property,
d513 1
a513 2
                LLVMValueRef level,
                boolean lod_scalar);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d359 1
d361 1
a367 15
   }
}

static INLINE boolean
has_layer_coord(enum pipe_texture_target tex)
{
   switch (tex) {
   case PIPE_TEXTURE_1D_ARRAY:
   case PIPE_TEXTURE_2D_ARRAY:
   /* cube is not layered but 3rd coord (after cube mapping) behaves the same */
   case PIPE_TEXTURE_CUBE:
   case PIPE_TEXTURE_CUBE_ARRAY:
      return TRUE;
   default:
      return FALSE;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a358 1
      return 2;
a359 1
      assert(0);
d366 15
@


