head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.34;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.53;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.42;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.13;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.21;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * @@file
 * Helper functions for type conversions.
 *
 * We want to use the fastest type for a given computation whenever feasible.
 * The other side of this is that we need to be able convert between several
 * types accurately and efficiently.
 *
 * Conversion between types of different bit width is quite complex since a 
 *
 * To remember there are a few invariants in type conversions:
 *
 * - register width must remain constant:
 *
 *     src_type.width * src_type.length == dst_type.width * dst_type.length
 *
 * - total number of elements must remain constant:
 *
 *     src_type.length * num_srcs == dst_type.length * num_dsts
 *
 * It is not always possible to do the conversion both accurately and
 * efficiently, usually due to lack of adequate machine instructions. In these
 * cases it is important not to cut shortcuts here and sacrifice accuracy, as
 * there this functions can be used anywhere. In the future we might have a
 * precision parameter which can gauge the accuracy vs efficiency compromise,
 * but for now if the data conversion between two stages happens to be the
 * bottleneck, then most likely should just avoid converting at all and run
 * both stages with the same type.
 *
 * Make sure to run lp_test_conv unit test after any change to this file.
 *
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 */


#include "util/u_debug.h"
#include "util/u_math.h"
#include "util/u_half.h"
#include "util/u_cpu_detect.h"

#include "lp_bld_type.h"
#include "lp_bld_const.h"
#include "lp_bld_arit.h"
#include "lp_bld_bitarit.h"
#include "lp_bld_pack.h"
#include "lp_bld_conv.h"
#include "lp_bld_logic.h"
#include "lp_bld_intr.h"
#include "lp_bld_printf.h"
#include "lp_bld_format.h"



/**
 * Converts int16 half-float to float32
 * Note this can be performed in 1 instruction if vcvtph2ps exists (f16c/cvt16)
 * [llvm.x86.vcvtph2ps / _mm_cvtph_ps]
 *
 * @@param src           value to convert
 *
 */
LLVMValueRef
lp_build_half_to_float(struct gallivm_state *gallivm,
                       LLVMValueRef src)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef src_type = LLVMTypeOf(src);
   unsigned src_length = LLVMGetTypeKind(src_type) == LLVMVectorTypeKind ?
                            LLVMGetVectorSize(src_type) : 1;

   struct lp_type f32_type = lp_type_float_vec(32, 32 * src_length);
   struct lp_type i32_type = lp_type_int_vec(32, 32 * src_length);
   LLVMTypeRef int_vec_type = lp_build_vec_type(gallivm, i32_type);
   LLVMValueRef h;

   if (util_cpu_caps.has_f16c && HAVE_LLVM >= 0x0301 &&
       (src_length == 4 || src_length == 8)) {
      const char *intrinsic = NULL;
      if (src_length == 4) {
         src = lp_build_pad_vector(gallivm, src, 8);
         intrinsic = "llvm.x86.vcvtph2ps.128";
      }
      else {
         intrinsic = "llvm.x86.vcvtph2ps.256";
      }
      return lp_build_intrinsic_unary(builder, intrinsic,
                                      lp_build_vec_type(gallivm, f32_type), src);
   }

   /* Convert int16 vector to int32 vector by zero ext (might generate bad code) */
   h = LLVMBuildZExt(builder, src, int_vec_type, "");
   return lp_build_smallfloat_to_float(gallivm, f32_type, h, 10, 5, 0, true);
}


/**
 * Converts float32 to int16 half-float
 * Note this can be performed in 1 instruction if vcvtps2ph exists (f16c/cvt16)
 * [llvm.x86.vcvtps2ph / _mm_cvtps_ph]
 *
 * @@param src           value to convert
 *
 * Convert float32 to half floats, preserving Infs and NaNs,
 * with rounding towards zero (trunc).
 */
LLVMValueRef
lp_build_float_to_half(struct gallivm_state *gallivm,
                       LLVMValueRef src)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef f32_vec_type = LLVMTypeOf(src);
   unsigned length = LLVMGetTypeKind(f32_vec_type) == LLVMVectorTypeKind
                   ? LLVMGetVectorSize(f32_vec_type) : 1;
   struct lp_type i32_type = lp_type_int_vec(32, 32 * length);
   struct lp_type i16_type = lp_type_int_vec(16, 16 * length);
   LLVMValueRef result;

   if (util_cpu_caps.has_f16c && HAVE_LLVM >= 0x0301 &&
       (length == 4 || length == 8)) {
      struct lp_type i168_type = lp_type_int_vec(16, 16 * 8);
      unsigned mode = 3; /* same as LP_BUILD_ROUND_TRUNCATE */
      LLVMTypeRef i32t = LLVMInt32TypeInContext(gallivm->context);
      const char *intrinsic = NULL;
      if (length == 4) {
         intrinsic = "llvm.x86.vcvtps2ph.128";
      }
      else {
         intrinsic = "llvm.x86.vcvtps2ph.256";
      }
      result = lp_build_intrinsic_binary(builder, intrinsic,
                                         lp_build_vec_type(gallivm, i168_type),
                                         src, LLVMConstInt(i32t, mode, 0));
      if (length == 4) {
         result = lp_build_extract_range(gallivm, result, 0, 4);
      }
   }

   else {
      result = lp_build_float_to_smallfloat(gallivm, i32_type, src, 10, 5, 0, true);
      /* Convert int32 vector to int16 vector by trunc (might generate bad code) */
      result = LLVMBuildTrunc(builder, result, lp_build_vec_type(gallivm, i16_type), "");
   }

   /*
    * Debugging code.
    */
   if (0) {
     LLVMTypeRef i32t = LLVMInt32TypeInContext(gallivm->context);
     LLVMTypeRef i16t = LLVMInt16TypeInContext(gallivm->context);
     LLVMTypeRef f32t = LLVMFloatTypeInContext(gallivm->context);
     LLVMValueRef ref_result = LLVMGetUndef(LLVMVectorType(i16t, length));
     unsigned i;

     LLVMTypeRef func_type = LLVMFunctionType(i16t, &f32t, 1, 0);
     LLVMValueRef func = lp_build_const_int_pointer(gallivm, func_to_pointer((func_pointer)util_float_to_half));
     func = LLVMBuildBitCast(builder, func, LLVMPointerType(func_type, 0), "util_float_to_half");

     for (i = 0; i < length; ++i) {
        LLVMValueRef index = LLVMConstInt(i32t, i, 0);
        LLVMValueRef f32 = LLVMBuildExtractElement(builder, src, index, "");
#if 0
        /* XXX: not really supported by backends */
        LLVMValueRef f16 = lp_build_intrinsic_unary(builder, "llvm.convert.to.fp16", i16t, f32);
#else
        LLVMValueRef f16 = LLVMBuildCall(builder, func, &f32, 1, "");
#endif
        ref_result = LLVMBuildInsertElement(builder, ref_result, f16, index, "");
     }

     lp_build_print_value(gallivm, "src  = ", src);
     lp_build_print_value(gallivm, "llvm = ", result);
     lp_build_print_value(gallivm, "util = ", ref_result);
     lp_build_printf(gallivm, "\n");
  }

   return result;
}


/**
 * Special case for converting clamped IEEE-754 floats to unsigned norms.
 *
 * The mathematical voodoo below may seem excessive but it is actually
 * paramount we do it this way for several reasons. First, there is no single
 * precision FP to unsigned integer conversion Intel SSE instruction. Second,
 * secondly, even if there was, since the FP's mantissa takes only a fraction
 * of register bits the typically scale and cast approach would require double
 * precision for accurate results, and therefore half the throughput
 *
 * Although the result values can be scaled to an arbitrary bit width specified
 * by dst_width, the actual result type will have the same width.
 *
 * Ex: src = { float, float, float, float }
 * return { i32, i32, i32, i32 } where each value is in [0, 2^dst_width-1].
 */
LLVMValueRef
lp_build_clamped_float_to_unsigned_norm(struct gallivm_state *gallivm,
                                        struct lp_type src_type,
                                        unsigned dst_width,
                                        LLVMValueRef src)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(gallivm, src_type);
   LLVMValueRef res;
   unsigned mantissa;

   assert(src_type.floating);
   assert(dst_width <= src_type.width);
   src_type.sign = FALSE;

   mantissa = lp_mantissa(src_type);

   if (dst_width <= mantissa) {
      /*
       * Apply magic coefficients that will make the desired result to appear
       * in the lowest significant bits of the mantissa, with correct rounding.
       *
       * This only works if the destination width fits in the mantissa.
       */

      unsigned long long ubound;
      unsigned long long mask;
      double scale;
      double bias;

      ubound = (1ULL << dst_width);
      mask = ubound - 1;
      scale = (double)mask/ubound;
      bias = (double)(1ULL << (mantissa - dst_width));

      res = LLVMBuildFMul(builder, src, lp_build_const_vec(gallivm, src_type, scale), "");
      /* instead of fadd/and could (with sse2) just use lp_build_iround */
      res = LLVMBuildFAdd(builder, res, lp_build_const_vec(gallivm, src_type, bias), "");
      res = LLVMBuildBitCast(builder, res, int_vec_type, "");
      res = LLVMBuildAnd(builder, res,
                         lp_build_const_int_vec(gallivm, src_type, mask), "");
   }
   else if (dst_width == (mantissa + 1)) {
      /*
       * The destination width matches exactly what can be represented in
       * floating point (i.e., mantissa + 1 bits). Even so correct rounding
       * still needs to be applied (only for numbers in [0.5-1.0] would
       * conversion using truncation after scaling be sufficient).
       */
      double scale;
      struct lp_build_context uf32_bld;

      lp_build_context_init(&uf32_bld, gallivm, src_type);
      scale = (double)((1ULL << dst_width) - 1);

      res = LLVMBuildFMul(builder, src,
                          lp_build_const_vec(gallivm, src_type, scale), "");
      res = lp_build_iround(&uf32_bld, res);
   }
   else {
      /*
       * The destination exceeds what can be represented in the floating point.
       * So multiply by the largest power two we get away with, and when
       * subtract the most significant bit to rescale to normalized values.
       *
       * The largest power of two factor we can get away is
       * (1 << (src_type.width - 1)), because we need to use signed . In theory it
       * should be (1 << (src_type.width - 2)), but IEEE 754 rules states
       * INT_MIN should be returned in FPToSI, which is the correct result for
       * values near 1.0!
       *
       * This means we get (src_type.width - 1) correct bits for values near 0.0,
       * and (mantissa + 1) correct bits for values near 1.0. Equally or more
       * important, we also get exact results for 0.0 and 1.0.
       */

      unsigned n = MIN2(src_type.width - 1, dst_width);

      double scale = (double)(1ULL << n);
      unsigned lshift = dst_width - n;
      unsigned rshift = n;
      LLVMValueRef lshifted;
      LLVMValueRef rshifted;

      res = LLVMBuildFMul(builder, src,
                          lp_build_const_vec(gallivm, src_type, scale), "");
      res = LLVMBuildFPToSI(builder, res, int_vec_type, "");

      /*
       * Align the most significant bit to its final place.
       *
       * This will cause 1.0 to overflow to 0, but the later adjustment will
       * get it right.
       */
      if (lshift) {
         lshifted = LLVMBuildShl(builder, res,
                                 lp_build_const_int_vec(gallivm, src_type,
                                                        lshift), "");
      } else {
         lshifted = res;
      }

      /*
       * Align the most significant bit to the right.
       */
      rshifted =  LLVMBuildLShr(builder, res,
                                lp_build_const_int_vec(gallivm, src_type, rshift),
                                "");

      /*
       * Subtract the MSB to the LSB, therefore re-scaling from
       * (1 << dst_width) to ((1 << dst_width) - 1).
       */

      res = LLVMBuildSub(builder, lshifted, rshifted, "");
   }

   return res;
}


/**
 * Inverse of lp_build_clamped_float_to_unsigned_norm above.
 * Ex: src = { i32, i32, i32, i32 } with values in range [0, 2^src_width-1]
 * return {float, float, float, float} with values in range [0, 1].
 */
LLVMValueRef
lp_build_unsigned_norm_to_float(struct gallivm_state *gallivm,
                                unsigned src_width,
                                struct lp_type dst_type,
                                LLVMValueRef src)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef vec_type = lp_build_vec_type(gallivm, dst_type);
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(gallivm, dst_type);
   LLVMValueRef bias_;
   LLVMValueRef res;
   unsigned mantissa;
   unsigned n;
   unsigned long long ubound;
   unsigned long long mask;
   double scale;
   double bias;

   assert(dst_type.floating);

   mantissa = lp_mantissa(dst_type);

   if (src_width <= (mantissa + 1)) {
      /*
       * The source width matches fits what can be represented in floating
       * point (i.e., mantissa + 1 bits). So do a straight multiplication
       * followed by casting. No further rounding is necessary.
       */

      scale = 1.0/(double)((1ULL << src_width) - 1);
      res = LLVMBuildSIToFP(builder, src, vec_type, "");
      res = LLVMBuildFMul(builder, res,
                          lp_build_const_vec(gallivm, dst_type, scale), "");
      return res;
   }
   else {
      /*
       * The source width exceeds what can be represented in floating
       * point. So truncate the incoming values.
       */

      n = MIN2(mantissa, src_width);

      ubound = ((unsigned long long)1 << n);
      mask = ubound - 1;
      scale = (double)ubound/mask;
      bias = (double)((unsigned long long)1 << (mantissa - n));

      res = src;

      if (src_width > mantissa) {
         int shift = src_width - mantissa;
         res = LLVMBuildLShr(builder, res,
                             lp_build_const_int_vec(gallivm, dst_type, shift), "");
      }

      bias_ = lp_build_const_vec(gallivm, dst_type, bias);

      res = LLVMBuildOr(builder,
                        res,
                        LLVMBuildBitCast(builder, bias_, int_vec_type, ""), "");

      res = LLVMBuildBitCast(builder, res, vec_type, "");

      res = LLVMBuildFSub(builder, res, bias_, "");
      res = LLVMBuildFMul(builder, res, lp_build_const_vec(gallivm, dst_type, scale), "");
   }

   return res;
}


/**
 * Pick a suitable num_dsts for lp_build_conv to ensure optimal cases are used.
 *
 * Returns the number of dsts created from src
 */
int lp_build_conv_auto(struct gallivm_state *gallivm,
                       struct lp_type src_type,
                       struct lp_type* dst_type,
                       const LLVMValueRef *src,
                       unsigned num_srcs,
                       LLVMValueRef *dst)
{
   int i;
   int num_dsts = num_srcs;

   if (src_type.floating == dst_type->floating &&
       src_type.width == dst_type->width &&
       src_type.length == dst_type->length &&
       src_type.fixed == dst_type->fixed &&
       src_type.norm == dst_type->norm &&
       src_type.sign == dst_type->sign)
      return num_dsts;

   /* Special case 4x4f -> 1x16ub or 2x8f -> 1x16ub
    */
   if (src_type.floating == 1 &&
       src_type.fixed    == 0 &&
       src_type.sign     == 1 &&
       src_type.norm     == 0 &&
       src_type.width    == 32 &&

       dst_type->floating == 0 &&
       dst_type->fixed    == 0 &&
       dst_type->sign     == 0 &&
       dst_type->norm     == 1 &&
       dst_type->width    == 8)
   {
      /* Special case 4x4f --> 1x16ub */
      if (src_type.length == 4 &&
          util_cpu_caps.has_sse2)
      {
         num_dsts = (num_srcs + 3) / 4;
         dst_type->length = num_srcs * 4 >= 16 ? 16 : num_srcs * 4;

         lp_build_conv(gallivm, src_type, *dst_type, src, num_srcs, dst, num_dsts);
         return num_dsts;
      }

      /* Special case 2x8f --> 1x16ub */
      if (src_type.length == 8 &&
          util_cpu_caps.has_avx)
      {
         num_dsts = (num_srcs + 1) / 2;
         dst_type->length = num_srcs * 8 >= 16 ? 16 : num_srcs * 8;

         lp_build_conv(gallivm, src_type, *dst_type, src, num_srcs, dst, num_dsts);
         return num_dsts;
      }
   }

   /* lp_build_resize does not support M:N */
   if (src_type.width == dst_type->width) {
      lp_build_conv(gallivm, src_type, *dst_type, src, num_srcs, dst, num_dsts);
   } else {
      for (i = 0; i < num_srcs; ++i) {
         lp_build_conv(gallivm, src_type, *dst_type, &src[i], 1, &dst[i], 1);
      }
   }

   return num_dsts;
}


/**
 * Generic type conversion.
 *
 * TODO: Take a precision argument, or even better, add a new precision member
 * to the lp_type union.
 */
void
lp_build_conv(struct gallivm_state *gallivm,
              struct lp_type src_type,
              struct lp_type dst_type,
              const LLVMValueRef *src, unsigned num_srcs,
              LLVMValueRef *dst, unsigned num_dsts)
{
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type tmp_type;
   LLVMValueRef tmp[LP_MAX_VECTOR_LENGTH];
   unsigned num_tmps;
   unsigned i;

   /* We must not loose or gain channels. Only precision */
   assert(src_type.length * num_srcs == dst_type.length * num_dsts);

   assert(src_type.length <= LP_MAX_VECTOR_LENGTH);
   assert(dst_type.length <= LP_MAX_VECTOR_LENGTH);
   assert(num_srcs <= LP_MAX_VECTOR_LENGTH);
   assert(num_dsts <= LP_MAX_VECTOR_LENGTH);

   tmp_type = src_type;
   for(i = 0; i < num_srcs; ++i) {
      assert(lp_check_value(src_type, src[i]));
      tmp[i] = src[i];
   }
   num_tmps = num_srcs;


   /* Special case 4x4f --> 1x16ub, 2x4f -> 1x8ub, 1x4f -> 1x4ub
    */
   if (src_type.floating == 1 &&
       src_type.fixed    == 0 &&
       src_type.sign     == 1 &&
       src_type.norm     == 0 &&
       src_type.width    == 32 &&
       src_type.length   == 4 &&

       dst_type.floating == 0 &&
       dst_type.fixed    == 0 &&
       dst_type.sign     == 0 &&
       dst_type.norm     == 1 &&
       dst_type.width    == 8 &&

       ((dst_type.length == 16 && 4 * num_dsts == num_srcs) ||
        (num_dsts == 1 && dst_type.length * num_srcs == 16 && num_srcs != 3)) &&

       util_cpu_caps.has_sse2)
   {
      struct lp_build_context bld;
      struct lp_type int16_type, int32_type;
      struct lp_type dst_type_ext = dst_type;
      LLVMValueRef const_255f;
      unsigned i, j;

      lp_build_context_init(&bld, gallivm, src_type);

      dst_type_ext.length = 16;
      int16_type = int32_type = dst_type_ext;

      int16_type.width *= 2;
      int16_type.length /= 2;
      int16_type.sign = 1;

      int32_type.width *= 4;
      int32_type.length /= 4;
      int32_type.sign = 1;

      const_255f = lp_build_const_vec(gallivm, src_type, 255.0f);

      for (i = 0; i < num_dsts; ++i, src += 4) {
         LLVMValueRef lo, hi;

         for (j = 0; j < dst_type.length / 4; ++j) {
            tmp[j] = LLVMBuildFMul(builder, src[j], const_255f, "");
            tmp[j] = lp_build_iround(&bld, tmp[j]);
         }

         if (num_srcs == 1) {
            tmp[1] = tmp[0];
         }

         /* relying on clamping behavior of sse2 intrinsics here */
         lo = lp_build_pack2(gallivm, int32_type, int16_type, tmp[0], tmp[1]);

         if (num_srcs < 4) {
            hi = lo;
         }
         else {
            hi = lp_build_pack2(gallivm, int32_type, int16_type, tmp[2], tmp[3]);
         }
         dst[i] = lp_build_pack2(gallivm, int16_type, dst_type_ext, lo, hi);
      }
      if (num_srcs < 4) {
         dst[0] = lp_build_extract_range(gallivm, dst[0], 0, dst_type.length);
      }

      return; 
   }

   /* Special case 2x8f --> 1x16ub, 1x8f ->1x8ub
    */
   else if (src_type.floating == 1 &&
      src_type.fixed    == 0 &&
      src_type.sign     == 1 &&
      src_type.norm     == 0 &&
      src_type.width    == 32 &&
      src_type.length   == 8 &&

      dst_type.floating == 0 &&
      dst_type.fixed    == 0 &&
      dst_type.sign     == 0 &&
      dst_type.norm     == 1 &&
      dst_type.width    == 8 &&

      ((dst_type.length == 16 && 2 * num_dsts == num_srcs) ||
       (num_dsts == 1 && dst_type.length * num_srcs == 8)) &&

      util_cpu_caps.has_avx) {

      struct lp_build_context bld;
      struct lp_type int16_type, int32_type;
      struct lp_type dst_type_ext = dst_type;
      LLVMValueRef const_255f;
      unsigned i;

      lp_build_context_init(&bld, gallivm, src_type);

      dst_type_ext.length = 16;
      int16_type = int32_type = dst_type_ext;

      int16_type.width *= 2;
      int16_type.length /= 2;
      int16_type.sign = 1;

      int32_type.width *= 4;
      int32_type.length /= 4;
      int32_type.sign = 1;

      const_255f = lp_build_const_vec(gallivm, src_type, 255.0f);

      for (i = 0; i < num_dsts; ++i, src += 2) {
         LLVMValueRef lo, hi, a, b;

         a = LLVMBuildFMul(builder, src[0], const_255f, "");
         a = lp_build_iround(&bld, a);
         tmp[0] = lp_build_extract_range(gallivm, a, 0, 4);
         tmp[1] = lp_build_extract_range(gallivm, a, 4, 4);
         /* relying on clamping behavior of sse2 intrinsics here */
         lo = lp_build_pack2(gallivm, int32_type, int16_type, tmp[0], tmp[1]);

         if (num_srcs == 1) {
            hi = lo;
         }
         else {
            b = LLVMBuildFMul(builder, src[1], const_255f, "");
            b = lp_build_iround(&bld, b);
            tmp[2] = lp_build_extract_range(gallivm, b, 0, 4);
            tmp[3] = lp_build_extract_range(gallivm, b, 4, 4);
            hi = lp_build_pack2(gallivm, int32_type, int16_type, tmp[2], tmp[3]);

         }
         dst[i] = lp_build_pack2(gallivm, int16_type, dst_type_ext, lo, hi);
      }

      if (num_srcs == 1) {
         dst[0] = lp_build_extract_range(gallivm, dst[0], 0, dst_type.length);
      }

      return;
   }

   /* Special case -> 16bit half-float
    */
   else if (dst_type.floating && dst_type.width == 16)
   {
      /* Only support src as 32bit float currently */
      assert(src_type.floating && src_type.width == 32);

      for(i = 0; i < num_tmps; ++i)
         dst[i] = lp_build_float_to_half(gallivm, tmp[i]);

      return;
   }

   /* Pre convert half-floats to floats
    */
   else if (src_type.floating && src_type.width == 16)
   {
      for(i = 0; i < num_tmps; ++i)
         tmp[i] = lp_build_half_to_float(gallivm, tmp[i]);

      tmp_type.width = 32;
   }

   /*
    * Clamp if necessary
    */

   if(memcmp(&src_type, &dst_type, sizeof src_type) != 0) {
      struct lp_build_context bld;
      double src_min = lp_const_min(src_type);
      double dst_min = lp_const_min(dst_type);
      double src_max = lp_const_max(src_type);
      double dst_max = lp_const_max(dst_type);
      LLVMValueRef thres;

      lp_build_context_init(&bld, gallivm, tmp_type);

      if(src_min < dst_min) {
         if(dst_min == 0.0)
            thres = bld.zero;
         else
            thres = lp_build_const_vec(gallivm, src_type, dst_min);
         for(i = 0; i < num_tmps; ++i)
            tmp[i] = lp_build_max(&bld, tmp[i], thres);
      }

      if(src_max > dst_max) {
         if(dst_max == 1.0)
            thres = bld.one;
         else
            thres = lp_build_const_vec(gallivm, src_type, dst_max);
         for(i = 0; i < num_tmps; ++i)
            tmp[i] = lp_build_min(&bld, tmp[i], thres);
      }
   }

   /*
    * Scale to the narrowest range
    */

   if(dst_type.floating) {
      /* Nothing to do */
   }
   else if(tmp_type.floating) {
      if(!dst_type.fixed && !dst_type.sign && dst_type.norm) {
         for(i = 0; i < num_tmps; ++i) {
            tmp[i] = lp_build_clamped_float_to_unsigned_norm(gallivm,
                                                             tmp_type,
                                                             dst_type.width,
                                                             tmp[i]);
         }
         tmp_type.floating = FALSE;
      }
      else {
         double dst_scale = lp_const_scale(dst_type);

         if (dst_scale != 1.0) {
            LLVMValueRef scale = lp_build_const_vec(gallivm, tmp_type, dst_scale);
            for(i = 0; i < num_tmps; ++i)
               tmp[i] = LLVMBuildFMul(builder, tmp[i], scale, "");
         }

         /*
          * these functions will use fptosi in some form which won't work
          * with 32bit uint dst. Causes lp_test_conv failures though.
          */
         if (0)
            assert(dst_type.sign || dst_type.width < 32);

         if (dst_type.sign && dst_type.norm && !dst_type.fixed) {
            struct lp_build_context bld;

            lp_build_context_init(&bld, gallivm, tmp_type);
            for(i = 0; i < num_tmps; ++i) {
               tmp[i] = lp_build_iround(&bld, tmp[i]);
            }
            tmp_type.floating = FALSE;
         }
         else {
            LLVMTypeRef tmp_vec_type;

            tmp_type.floating = FALSE;
            tmp_vec_type = lp_build_vec_type(gallivm, tmp_type);
            for(i = 0; i < num_tmps; ++i) {
#if 0
               if(dst_type.sign)
                  tmp[i] = LLVMBuildFPToSI(builder, tmp[i], tmp_vec_type, "");
               else
                  tmp[i] = LLVMBuildFPToUI(builder, tmp[i], tmp_vec_type, "");
#else
              /* FIXME: there is no SSE counterpart for LLVMBuildFPToUI */
               tmp[i] = LLVMBuildFPToSI(builder, tmp[i], tmp_vec_type, "");
#endif
            }
         }
      }
   }
   else {
      unsigned src_shift = lp_const_shift(src_type);
      unsigned dst_shift = lp_const_shift(dst_type);
      unsigned src_offset = lp_const_offset(src_type);
      unsigned dst_offset = lp_const_offset(dst_type);

      /* Compensate for different offsets */
      if (dst_offset > src_offset && src_type.width > dst_type.width) {
         for (i = 0; i < num_tmps; ++i) {
            LLVMValueRef shifted;
            LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type, src_shift - 1);
            if(src_type.sign)
               shifted = LLVMBuildAShr(builder, tmp[i], shift, "");
            else
               shifted = LLVMBuildLShr(builder, tmp[i], shift, "");

            tmp[i] = LLVMBuildSub(builder, tmp[i], shifted, "");
         }
      }

      if(src_shift > dst_shift) {
         LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type,
                                                     src_shift - dst_shift);
         for(i = 0; i < num_tmps; ++i)
            if(src_type.sign)
               tmp[i] = LLVMBuildAShr(builder, tmp[i], shift, "");
            else
               tmp[i] = LLVMBuildLShr(builder, tmp[i], shift, "");
      }
   }

   /*
    * Truncate or expand bit width
    *
    * No data conversion should happen here, although the sign bits are
    * crucial to avoid bad clamping.
    */

   {
      struct lp_type new_type;

      new_type = tmp_type;
      new_type.sign   = dst_type.sign;
      new_type.width  = dst_type.width;
      new_type.length = dst_type.length;

      lp_build_resize(gallivm, tmp_type, new_type, tmp, num_srcs, tmp, num_dsts);

      tmp_type = new_type;
      num_tmps = num_dsts;
   }

   /*
    * Scale to the widest range
    */

   if(src_type.floating) {
      /* Nothing to do */
   }
   else if(!src_type.floating && dst_type.floating) {
      if(!src_type.fixed && !src_type.sign && src_type.norm) {
         for(i = 0; i < num_tmps; ++i) {
            tmp[i] = lp_build_unsigned_norm_to_float(gallivm,
                                                     src_type.width,
                                                     dst_type,
                                                     tmp[i]);
         }
         tmp_type.floating = TRUE;
      }
      else {
         double src_scale = lp_const_scale(src_type);
         LLVMTypeRef tmp_vec_type;

         /* Use an equally sized integer for intermediate computations */
         tmp_type.floating = TRUE;
         tmp_type.sign = TRUE;
         tmp_vec_type = lp_build_vec_type(gallivm, tmp_type);
         for(i = 0; i < num_tmps; ++i) {
#if 0
            if(dst_type.sign)
               tmp[i] = LLVMBuildSIToFP(builder, tmp[i], tmp_vec_type, "");
            else
               tmp[i] = LLVMBuildUIToFP(builder, tmp[i], tmp_vec_type, "");
#else
            /* FIXME: there is no SSE counterpart for LLVMBuildUIToFP */
            tmp[i] = LLVMBuildSIToFP(builder, tmp[i], tmp_vec_type, "");
#endif
          }

          if (src_scale != 1.0) {
             LLVMValueRef scale = lp_build_const_vec(gallivm, tmp_type, 1.0/src_scale);
             for(i = 0; i < num_tmps; ++i)
                tmp[i] = LLVMBuildFMul(builder, tmp[i], scale, "");
          }

          /* the formula above will produce value below -1.0 for most negative
           * value but everything seems happy with that hence disable for now */
          if (0 && !src_type.fixed && src_type.norm && src_type.sign) {
             struct lp_build_context bld;

             lp_build_context_init(&bld, gallivm, dst_type);
             for(i = 0; i < num_tmps; ++i) {
                tmp[i] = lp_build_max(&bld, tmp[i],
                                      lp_build_const_vec(gallivm, dst_type, -1.0f));
             }
          }
      }
    }
    else {
       unsigned src_shift = lp_const_shift(src_type);
       unsigned dst_shift = lp_const_shift(dst_type);
       unsigned src_offset = lp_const_offset(src_type);
       unsigned dst_offset = lp_const_offset(dst_type);

       if (src_shift < dst_shift) {
          LLVMValueRef pre_shift[LP_MAX_VECTOR_LENGTH];
          LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type, dst_shift - src_shift);

          for (i = 0; i < num_tmps; ++i) {
             pre_shift[i] = tmp[i];
             tmp[i] = LLVMBuildShl(builder, tmp[i], shift, "");
          }

          /* Compensate for different offsets */
          if (dst_offset > src_offset) {
             for (i = 0; i < num_tmps; ++i) {
                tmp[i] = LLVMBuildSub(builder, tmp[i], pre_shift[i], "");
             }
          }
       }
    }

   for(i = 0; i < num_dsts; ++i) {
      dst[i] = tmp[i];
      assert(lp_check_value(dst_type, dst[i]));
   }
}


/**
 * Bit mask conversion.
 *
 * This will convert the integer masks that match the given types.
 *
 * The mask values should 0 or -1, i.e., all bits either set to zero or one.
 * Any other value will likely cause unpredictable results.
 *
 * This is basically a very trimmed down version of lp_build_conv.
 */
void
lp_build_conv_mask(struct gallivm_state *gallivm,
                   struct lp_type src_type,
                   struct lp_type dst_type,
                   const LLVMValueRef *src, unsigned num_srcs,
                   LLVMValueRef *dst, unsigned num_dsts)
{

   /* We must not loose or gain channels. Only precision */
   assert(src_type.length * num_srcs == dst_type.length * num_dsts);

   /*
    * Drop
    *
    * We assume all values are 0 or -1
    */

   src_type.floating = FALSE;
   src_type.fixed = FALSE;
   src_type.sign = TRUE;
   src_type.norm = FALSE;

   dst_type.floating = FALSE;
   dst_type.fixed = FALSE;
   dst_type.sign = TRUE;
   dst_type.norm = FALSE;

   /*
    * Truncate or expand bit width
    */

   lp_build_resize(gallivm, src_type, dst_type, src, num_srcs, dst, num_dsts);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d104 1
a104 1
   if (util_cpu_caps.has_f16c &&
d146 1
a146 1
   if (util_cpu_caps.has_f16c &&
a794 2
      struct lp_build_context bld;
      lp_build_context_init(&bld, gallivm, tmp_type);
d797 1
a797 2
      /* sscaled -> unorm and similar would cause negative shift count, skip */
      if (dst_offset > src_offset && src_type.width > dst_type.width && src_shift > 0) {
d800 5
a805 1
            shifted = lp_build_shr_imm(&bld, tmp[i], src_shift - 1);
d811 2
d814 4
a817 1
            tmp[i] = lp_build_shr_imm(&bld, tmp[i], src_shift - dst_shift);
a902 2
       struct lp_build_context bld;
       lp_build_context_init(&bld, gallivm, tmp_type);
d906 1
d908 3
a910 15
          if (dst_shift - src_shift < dst_type.width) {
             for (i = 0; i < num_tmps; ++i) {
                pre_shift[i] = tmp[i];
                tmp[i] = lp_build_shl_imm(&bld, tmp[i], dst_shift - src_shift);
             }
          }
          else {
             /*
              * This happens for things like sscaled -> unorm conversions. Shift
              * counts equal to bit width cause undefined results, so hack around it.
              */
             for (i = 0; i < num_tmps; ++i) {
                pre_shift[i] = tmp[i];
                tmp[i] = lp_build_zero(gallivm, dst_type);
             }
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d104 1
a104 1
   if (util_cpu_caps.has_f16c && HAVE_LLVM >= 0x0301 &&
d146 1
a146 1
   if (util_cpu_caps.has_f16c && HAVE_LLVM >= 0x0301 &&
d795 2
d799 2
a800 1
      if (dst_offset > src_offset && src_type.width > dst_type.width) {
a802 5
            LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type, src_shift - 1);
            if(src_type.sign)
               shifted = LLVMBuildAShr(builder, tmp[i], shift, "");
            else
               shifted = LLVMBuildLShr(builder, tmp[i], shift, "");
d804 1
a809 2
         LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type,
                                                     src_shift - dst_shift);
d811 1
a811 4
            if(src_type.sign)
               tmp[i] = LLVMBuildAShr(builder, tmp[i], shift, "");
            else
               tmp[i] = LLVMBuildLShr(builder, tmp[i], shift, "");
d897 2
a901 1
          LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type, dst_shift - src_shift);
d903 15
a917 3
          for (i = 0; i < num_tmps; ++i) {
             pre_shift[i] = tmp[i];
             tmp[i] = LLVMBuildShl(builder, tmp[i], shift, "");
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d260 1
d269 3
a271 2
       * floating point (i.e., mantissa + 1 bits). So do a straight
       * multiplication followed by casting. No further rounding is necessary.
a272 1

d274 1
d276 1
d281 1
a281 1
      res = LLVMBuildFPToSI(builder, res, int_vec_type, "");
a747 1
         LLVMTypeRef tmp_vec_type;
d755 22
a776 4
         /* Use an equally sized integer for intermediate computations */
         tmp_type.floating = FALSE;
         tmp_vec_type = lp_build_vec_type(gallivm, tmp_type);
         for(i = 0; i < num_tmps; ++i) {
d778 6
a783 1
            if(dst_type.sign)
a784 5
            else
               tmp[i] = LLVMBuildFPToUI(builder, tmp[i], tmp_vec_type, "");
#else
           /* FIXME: there is no SSE counterpart for LLVMBuildFPToUI */
            tmp[i] = LLVMBuildFPToSI(builder, tmp[i], tmp_vec_type, "");
d786 1
d883 12
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d66 1
d72 1
d75 131
d326 1
a326 1
      rshifted =  LLVMBuildAShr(builder, res,
d420 73
d527 1
a527 1
   /* Special case 4x4f --> 1x16ub 
d541 3
a543 1
       dst_type.length   == 16 &&
d547 18
a564 1
      int i;
d566 3
a568 3
      for (i = 0; i < num_dsts; i++, src += 4) {
         struct lp_type int16_type = dst_type;
         struct lp_type int32_type = dst_type;
a569 23
         LLVMValueRef src_int0;
         LLVMValueRef src_int1;
         LLVMValueRef src_int2;
         LLVMValueRef src_int3;
         LLVMTypeRef int16_vec_type;
         LLVMTypeRef int32_vec_type;
         LLVMTypeRef src_vec_type;
         LLVMTypeRef dst_vec_type;
         LLVMValueRef const_255f;
         LLVMValueRef a, b, c, d;

         int16_type.width *= 2;
         int16_type.length /= 2;
         int16_type.sign = 1;

         int32_type.width *= 4;
         int32_type.length /= 4;
         int32_type.sign = 1;

         src_vec_type   = lp_build_vec_type(gallivm, src_type);
         dst_vec_type   = lp_build_vec_type(gallivm, dst_type);
         int16_vec_type = lp_build_vec_type(gallivm, int16_type);
         int32_vec_type = lp_build_vec_type(gallivm, int32_type);
d571 4
a574 1
         const_255f = lp_build_const_vec(gallivm, src_type, 255.0f);
d576 2
a577 21
         a = LLVMBuildFMul(builder, src[0], const_255f, "");
         b = LLVMBuildFMul(builder, src[1], const_255f, "");
         c = LLVMBuildFMul(builder, src[2], const_255f, "");
         d = LLVMBuildFMul(builder, src[3], const_255f, "");

         {
            struct lp_build_context bld;

            bld.gallivm = gallivm;
            bld.type = src_type;
            bld.vec_type = src_vec_type;
            bld.int_elem_type = lp_build_elem_type(gallivm, int32_type);
            bld.int_vec_type = int32_vec_type;
            bld.undef = lp_build_undef(gallivm, src_type);
            bld.zero = lp_build_zero(gallivm, src_type);
            bld.one = lp_build_one(gallivm, src_type);

            src_int0 = lp_build_iround(&bld, a);
            src_int1 = lp_build_iround(&bld, b);
            src_int2 = lp_build_iround(&bld, c);
            src_int3 = lp_build_iround(&bld, d);
d579 1
d581 12
a592 3
         lo = lp_build_pack2(gallivm, int32_type, int16_type, src_int0, src_int1);
         hi = lp_build_pack2(gallivm, int32_type, int16_type, src_int2, src_int3);
         dst[i] = lp_build_pack2(gallivm, int16_type, dst_type, lo, hi);
d594 1
d598 95
d772 16
a788 1
      /* FIXME: compensate different offsets too */
d868 2
d871 2
a872 2
       /* FIXME: compensate different offsets too */
       if(src_shift < dst_shift) {
d874 3
a876 1
          for(i = 0; i < num_tmps; ++i)
d878 8
d902 1
a902 1
 * Any other value will likely cause in unpredictable results.
a912 2
   /* Register width must remain constant */
   assert(src_type.width * src_type.length == dst_type.width * dst_type.length);
d937 1
a937 12
   if(src_type.width > dst_type.width) {
      assert(num_dsts == 1);
      dst[0] = lp_build_pack(gallivm, src_type, dst_type, TRUE, src, num_srcs);
   }
   else if(src_type.width < dst_type.width) {
      assert(num_srcs == 1);
      lp_build_unpack(gallivm, src_type, dst_type, src[0], dst, num_dsts);
   }
   else {
      assert(num_srcs == num_dsts);
      memcpy(dst, src, num_dsts * sizeof *dst);
   }
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d234 10
a243 5
   /* Special-case int8->float, though most cases could be handled
    * this way:
    */
   if (src_width == 8) {
      scale = 1.0/255.0;
d249 7
d257 4
a260 1
   mantissa = lp_mantissa(dst_type);
d262 1
a262 1
   n = MIN2(mantissa, src_width);
d264 5
a268 12
   ubound = ((unsigned long long)1 << n);
   mask = ubound - 1;
   scale = (double)ubound/mask;
   bias = (double)((unsigned long long)1 << (mantissa - n));

   res = src;

   if(src_width > mantissa) {
      int shift = src_width - mantissa;
      res = LLVMBuildLShr(builder, res,
                          lp_build_const_int_vec(gallivm, dst_type, shift), "");
   }
d270 1
a270 1
   bias_ = lp_build_const_vec(gallivm, dst_type, bias);
d272 3
a274 3
   res = LLVMBuildOr(builder,
                     res,
                     LLVMBuildBitCast(builder, bias_, int_vec_type, ""), "");
d276 1
a276 1
   res = LLVMBuildBitCast(builder, res, vec_type, "");
d278 3
a280 2
   res = LLVMBuildFSub(builder, res, bias_, "");
   res = LLVMBuildFMul(builder, res, lp_build_const_vec(gallivm, dst_type, scale), "");
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d66 1
d87 3
d92 1
a92 1
lp_build_clamped_float_to_unsigned_norm(LLVMBuilderRef builder,
d97 2
a98 1
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(src_type);
a100 5
   unsigned n;
   unsigned long long ubound;
   unsigned long long mask;
   double scale;
   double bias;
d103 2
d108 34
a141 2
   /* We cannot carry more bits than the mantissa */
   n = MIN2(mantissa, dst_width);
d143 22
a164 7
   /* This magic coefficients will make the desired result to appear in the
    * lowest significant bits of the mantissa.
    */
   ubound = ((unsigned long long)1 << n);
   mask = ubound - 1;
   scale = (double)mask/ubound;
   bias = (double)((unsigned long long)1 << (mantissa - n));
d166 15
a180 12
   res = LLVMBuildMul(builder, src, lp_build_const_scalar(src_type, scale), "");
   res = LLVMBuildAdd(builder, res, lp_build_const_scalar(src_type, bias), "");
   res = LLVMBuildBitCast(builder, res, int_vec_type, "");

   if(dst_width > n) {
      int shift = dst_width - n;
      res = LLVMBuildShl(builder, res, lp_build_int_const_scalar(src_type, shift), "");

      /* TODO: Fill in the empty lower bits for additional precision? */
      /* YES: this fixes progs/trivial/tri-z-eq.c.
       * Otherwise vertex Z=1.0 values get converted to something like
       * 0xfffffb00 and the test for equality with 0xffffffff fails.
d182 6
a187 7
#if 0
      {
         LLVMValueRef msb;
         msb = LLVMBuildLShr(builder, res, lp_build_int_const_scalar(src_type, dst_width - 1), "");
         msb = LLVMBuildShl(builder, msb, lp_build_int_const_scalar(src_type, shift), "");
         msb = LLVMBuildSub(builder, msb, lp_build_int_const_scalar(src_type, 1), "");
         res = LLVMBuildOr(builder, res, msb, "");
d189 14
a202 7
#elif 0
      while(shift > 0) {
         res = LLVMBuildOr(builder, res, LLVMBuildLShr(builder, res, lp_build_int_const_scalar(src_type, n), ""), "");
         shift -= n;
         n *= 2;
      }
#endif
a203 2
   else
      res = LLVMBuildAnd(builder, res, lp_build_int_const_scalar(src_type, mask), "");
d211 2
d215 1
a215 1
lp_build_unsigned_norm_to_float(LLVMBuilderRef builder,
d220 3
a222 2
   LLVMTypeRef vec_type = lp_build_vec_type(dst_type);
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(dst_type);
d232 13
d258 2
a259 1
      res = LLVMBuildLShr(builder, res, lp_build_int_const_scalar(dst_type, shift), "");
d262 1
a262 1
   bias_ = lp_build_const_scalar(dst_type, bias);
d270 2
a271 2
   res = LLVMBuildSub(builder, res, bias_, "");
   res = LLVMBuildMul(builder, res, lp_build_const_scalar(dst_type, scale), "");
d284 1
a284 1
lp_build_conv(LLVMBuilderRef builder,
d290 1
a295 3
   /* Register width must remain constant */
   assert(src_type.width * src_type.length == dst_type.width * dst_type.length);

d301 2
d305 2
a306 1
   for(i = 0; i < num_srcs; ++i)
d308 1
d311 81
d404 1
a404 1
      lp_build_context_init(&bld, builder, tmp_type);
d410 1
a410 1
            thres = lp_build_const_scalar(src_type, dst_min);
d419 1
a419 1
            thres = lp_build_const_scalar(src_type, dst_max);
d435 1
a435 1
            tmp[i] = lp_build_clamped_float_to_unsigned_norm(builder,
d447 1
a447 1
            LLVMValueRef scale = lp_build_const_scalar(tmp_type, dst_scale);
d449 1
a449 1
               tmp[i] = LLVMBuildMul(builder, tmp[i], scale, "");
d454 1
a454 1
         tmp_vec_type = lp_build_vec_type(tmp_type);
d474 2
a475 1
         LLVMValueRef shift = lp_build_int_const_scalar(tmp_type, src_shift - dst_shift);
d486 3
d491 2
a492 1
   assert(!tmp_type.floating || tmp_type.width == dst_type.width);
d494 6
a499 7
   if(tmp_type.width > dst_type.width) {
      assert(num_dsts == 1);
      tmp[0] = lp_build_pack(builder, tmp_type, dst_type, TRUE, tmp, num_tmps);
      tmp_type.width = dst_type.width;
      tmp_type.length = dst_type.length;
      num_tmps = 1;
   }
d501 1
a501 5
   if(tmp_type.width < dst_type.width) {
      assert(num_tmps == 1);
      lp_build_unpack(builder, tmp_type, dst_type, tmp[0], tmp, num_dsts);
      tmp_type.width = dst_type.width;
      tmp_type.length = dst_type.length;
a504 4
   assert(tmp_type.width == dst_type.width);
   assert(tmp_type.length == dst_type.length);
   assert(num_tmps == num_dsts);

d515 1
a515 1
            tmp[i] = lp_build_unsigned_norm_to_float(builder,
d529 1
a529 1
         tmp_vec_type = lp_build_vec_type(tmp_type);
d543 1
a543 1
             LLVMValueRef scale = lp_build_const_scalar(tmp_type, 1.0/src_scale);
d545 1
a545 1
                tmp[i] = LLVMBuildMul(builder, tmp[i], scale, "");
d555 1
a555 1
          LLVMValueRef shift = lp_build_int_const_scalar(tmp_type, dst_shift - src_shift);
d561 1
a561 1
   for(i = 0; i < num_dsts; ++i)
d563 2
d579 1
a579 1
lp_build_conv_mask(LLVMBuilderRef builder,
d613 1
a613 1
      dst[0] = lp_build_pack(builder, src_type, dst_type, TRUE, src, num_srcs);
d617 1
a617 1
      lp_build_unpack(builder, src_type, dst_type, src[0], dst, num_dsts);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a65 1
#include "util/u_cpu_detect.h"
a85 3
 *
 * Ex: src = { float, float, float, float }
 * return { i32, i32, i32, i32 } where each value is in [0, 2^dst_width-1].
d88 1
a88 1
lp_build_clamped_float_to_unsigned_norm(struct gallivm_state *gallivm,
d93 1
a93 2
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(gallivm, src_type);
d96 5
a102 2
   assert(dst_width <= src_type.width);
   src_type.sign = FALSE;
d106 2
a107 7
   if (dst_width <= mantissa) {
      /*
       * Apply magic coefficients that will make the desired result to appear
       * in the lowest significant bits of the mantissa, with correct rounding.
       *
       * This only works if the destination width fits in the mantissa.
       */
d109 7
a115 26
      unsigned long long ubound;
      unsigned long long mask;
      double scale;
      double bias;

      ubound = (1ULL << dst_width);
      mask = ubound - 1;
      scale = (double)mask/ubound;
      bias = (double)(1ULL << (mantissa - dst_width));

      res = LLVMBuildFMul(builder, src, lp_build_const_vec(gallivm, src_type, scale), "");
      res = LLVMBuildFAdd(builder, res, lp_build_const_vec(gallivm, src_type, bias), "");
      res = LLVMBuildBitCast(builder, res, int_vec_type, "");
      res = LLVMBuildAnd(builder, res,
                         lp_build_const_int_vec(gallivm, src_type, mask), "");
   }
   else if (dst_width == (mantissa + 1)) {
      /*
       * The destination width matches exactly what can be represented in
       * floating point (i.e., mantissa + 1 bits). So do a straight
       * multiplication followed by casting. No further rounding is necessary.
       */

      double scale;

      scale = (double)((1ULL << dst_width) - 1);
d117 12
a128 19
      res = LLVMBuildFMul(builder, src,
                          lp_build_const_vec(gallivm, src_type, scale), "");
      res = LLVMBuildFPToSI(builder, res, int_vec_type, "");
   }
   else {
      /*
       * The destination exceeds what can be represented in the floating point.
       * So multiply by the largest power two we get away with, and when
       * subtract the most significant bit to rescale to normalized values.
       *
       * The largest power of two factor we can get away is
       * (1 << (src_type.width - 1)), because we need to use signed . In theory it
       * should be (1 << (src_type.width - 2)), but IEEE 754 rules states
       * INT_MIN should be returned in FPToSI, which is the correct result for
       * values near 1.0!
       *
       * This means we get (src_type.width - 1) correct bits for values near 0.0,
       * and (mantissa + 1) correct bits for values near 1.0. Equally or more
       * important, we also get exact results for 0.0 and 1.0.
d130 13
a142 25

      unsigned n = MIN2(src_type.width - 1, dst_width);

      double scale = (double)(1ULL << n);
      unsigned lshift = dst_width - n;
      unsigned rshift = n;
      LLVMValueRef lshifted;
      LLVMValueRef rshifted;

      res = LLVMBuildFMul(builder, src,
                          lp_build_const_vec(gallivm, src_type, scale), "");
      res = LLVMBuildFPToSI(builder, res, int_vec_type, "");

      /*
       * Align the most significant bit to its final place.
       *
       * This will cause 1.0 to overflow to 0, but the later adjustment will
       * get it right.
       */
      if (lshift) {
         lshifted = LLVMBuildShl(builder, res,
                                 lp_build_const_int_vec(gallivm, src_type,
                                                        lshift), "");
      } else {
         lshifted = res;
d144 1
a144 14

      /*
       * Align the most significant bit to the right.
       */
      rshifted =  LLVMBuildAShr(builder, res,
                                lp_build_const_int_vec(gallivm, src_type, rshift),
                                "");

      /*
       * Subtract the MSB to the LSB, therefore re-scaling from
       * (1 << dst_width) to ((1 << dst_width) - 1).
       */

      res = LLVMBuildSub(builder, lshifted, rshifted, "");
d146 2
a154 2
 * Ex: src = { i32, i32, i32, i32 } with values in range [0, 2^src_width-1]
 * return {float, float, float, float} with values in range [0, 1].
d157 1
a157 1
lp_build_unsigned_norm_to_float(struct gallivm_state *gallivm,
d162 2
a163 3
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef vec_type = lp_build_vec_type(gallivm, dst_type);
   LLVMTypeRef int_vec_type = lp_build_int_vec_type(gallivm, dst_type);
a172 13
   assert(dst_type.floating);

   /* Special-case int8->float, though most cases could be handled
    * this way:
    */
   if (src_width == 8) {
      scale = 1.0/255.0;
      res = LLVMBuildSIToFP(builder, src, vec_type, "");
      res = LLVMBuildFMul(builder, res,
                          lp_build_const_vec(gallivm, dst_type, scale), "");
      return res;
   }

d186 1
a186 2
      res = LLVMBuildLShr(builder, res,
                          lp_build_const_int_vec(gallivm, dst_type, shift), "");
d189 1
a189 1
   bias_ = lp_build_const_vec(gallivm, dst_type, bias);
d197 2
a198 2
   res = LLVMBuildFSub(builder, res, bias_, "");
   res = LLVMBuildFMul(builder, res, lp_build_const_vec(gallivm, dst_type, scale), "");
d211 1
a211 1
lp_build_conv(struct gallivm_state *gallivm,
a216 1
   LLVMBuilderRef builder = gallivm->builder;
d222 3
a229 2
   assert(num_srcs <= LP_MAX_VECTOR_LENGTH);
   assert(num_dsts <= LP_MAX_VECTOR_LENGTH);
d232 1
a232 2
   for(i = 0; i < num_srcs; ++i) {
      assert(lp_check_value(src_type, src[i]));
a233 1
   }
a235 81

   /* Special case 4x4f --> 1x16ub 
    */
   if (src_type.floating == 1 &&
       src_type.fixed    == 0 &&
       src_type.sign     == 1 &&
       src_type.norm     == 0 &&
       src_type.width    == 32 &&
       src_type.length   == 4 &&

       dst_type.floating == 0 &&
       dst_type.fixed    == 0 &&
       dst_type.sign     == 0 &&
       dst_type.norm     == 1 &&
       dst_type.width    == 8 &&
       dst_type.length   == 16 &&

       util_cpu_caps.has_sse2)
   {
      int i;

      for (i = 0; i < num_dsts; i++, src += 4) {
         struct lp_type int16_type = dst_type;
         struct lp_type int32_type = dst_type;
         LLVMValueRef lo, hi;
         LLVMValueRef src_int0;
         LLVMValueRef src_int1;
         LLVMValueRef src_int2;
         LLVMValueRef src_int3;
         LLVMTypeRef int16_vec_type;
         LLVMTypeRef int32_vec_type;
         LLVMTypeRef src_vec_type;
         LLVMTypeRef dst_vec_type;
         LLVMValueRef const_255f;
         LLVMValueRef a, b, c, d;

         int16_type.width *= 2;
         int16_type.length /= 2;
         int16_type.sign = 1;

         int32_type.width *= 4;
         int32_type.length /= 4;
         int32_type.sign = 1;

         src_vec_type   = lp_build_vec_type(gallivm, src_type);
         dst_vec_type   = lp_build_vec_type(gallivm, dst_type);
         int16_vec_type = lp_build_vec_type(gallivm, int16_type);
         int32_vec_type = lp_build_vec_type(gallivm, int32_type);

         const_255f = lp_build_const_vec(gallivm, src_type, 255.0f);

         a = LLVMBuildFMul(builder, src[0], const_255f, "");
         b = LLVMBuildFMul(builder, src[1], const_255f, "");
         c = LLVMBuildFMul(builder, src[2], const_255f, "");
         d = LLVMBuildFMul(builder, src[3], const_255f, "");

         {
            struct lp_build_context bld;

            bld.gallivm = gallivm;
            bld.type = src_type;
            bld.vec_type = src_vec_type;
            bld.int_elem_type = lp_build_elem_type(gallivm, int32_type);
            bld.int_vec_type = int32_vec_type;
            bld.undef = lp_build_undef(gallivm, src_type);
            bld.zero = lp_build_zero(gallivm, src_type);
            bld.one = lp_build_one(gallivm, src_type);

            src_int0 = lp_build_iround(&bld, a);
            src_int1 = lp_build_iround(&bld, b);
            src_int2 = lp_build_iround(&bld, c);
            src_int3 = lp_build_iround(&bld, d);
         }
         /* relying on clamping behavior of sse2 intrinsics here */
         lo = lp_build_pack2(gallivm, int32_type, int16_type, src_int0, src_int1);
         hi = lp_build_pack2(gallivm, int32_type, int16_type, src_int2, src_int3);
         dst[i] = lp_build_pack2(gallivm, int16_type, dst_type, lo, hi);
      }
      return; 
   }

d248 1
a248 1
      lp_build_context_init(&bld, gallivm, tmp_type);
d254 1
a254 1
            thres = lp_build_const_vec(gallivm, src_type, dst_min);
d263 1
a263 1
            thres = lp_build_const_vec(gallivm, src_type, dst_max);
d279 1
a279 1
            tmp[i] = lp_build_clamped_float_to_unsigned_norm(gallivm,
d291 1
a291 1
            LLVMValueRef scale = lp_build_const_vec(gallivm, tmp_type, dst_scale);
d293 1
a293 1
               tmp[i] = LLVMBuildFMul(builder, tmp[i], scale, "");
d298 1
a298 1
         tmp_vec_type = lp_build_vec_type(gallivm, tmp_type);
d318 1
a318 2
         LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type,
                                                     src_shift - dst_shift);
a328 3
    *
    * No data conversion should happen here, although the sign bits are
    * crucial to avoid bad clamping.
d331 1
a331 2
   {
      struct lp_type new_type;
d333 7
a339 6
      new_type = tmp_type;
      new_type.sign   = dst_type.sign;
      new_type.width  = dst_type.width;
      new_type.length = dst_type.length;

      lp_build_resize(gallivm, tmp_type, new_type, tmp, num_srcs, tmp, num_dsts);
d341 5
a345 1
      tmp_type = new_type;
d349 4
d363 1
a363 1
            tmp[i] = lp_build_unsigned_norm_to_float(gallivm,
d377 1
a377 1
         tmp_vec_type = lp_build_vec_type(gallivm, tmp_type);
d391 1
a391 1
             LLVMValueRef scale = lp_build_const_vec(gallivm, tmp_type, 1.0/src_scale);
d393 1
a393 1
                tmp[i] = LLVMBuildFMul(builder, tmp[i], scale, "");
d403 1
a403 1
          LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type, dst_shift - src_shift);
d409 1
a409 1
   for(i = 0; i < num_dsts; ++i) {
a410 2
      assert(lp_check_value(dst_type, dst[i]));
   }
d425 1
a425 1
lp_build_conv_mask(struct gallivm_state *gallivm,
d459 1
a459 1
      dst[0] = lp_build_pack(gallivm, src_type, dst_type, TRUE, src, num_srcs);
d463 1
a463 1
      lp_build_unpack(gallivm, src_type, dst_type, src[0], dst, num_dsts);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a65 1
#include "util/u_half.h"
a70 1
#include "lp_bld_bitarit.h"
a72 131
#include "lp_bld_logic.h"
#include "lp_bld_intr.h"
#include "lp_bld_printf.h"
#include "lp_bld_format.h"



/**
 * Converts int16 half-float to float32
 * Note this can be performed in 1 instruction if vcvtph2ps exists (f16c/cvt16)
 * [llvm.x86.vcvtph2ps / _mm_cvtph_ps]
 *
 * @@param src           value to convert
 *
 */
LLVMValueRef
lp_build_half_to_float(struct gallivm_state *gallivm,
                       LLVMValueRef src)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef src_type = LLVMTypeOf(src);
   unsigned src_length = LLVMGetTypeKind(src_type) == LLVMVectorTypeKind ?
                            LLVMGetVectorSize(src_type) : 1;

   struct lp_type f32_type = lp_type_float_vec(32, 32 * src_length);
   struct lp_type i32_type = lp_type_int_vec(32, 32 * src_length);
   LLVMTypeRef int_vec_type = lp_build_vec_type(gallivm, i32_type);
   LLVMValueRef h;

   if (util_cpu_caps.has_f16c && HAVE_LLVM >= 0x0301 &&
       (src_length == 4 || src_length == 8)) {
      const char *intrinsic = NULL;
      if (src_length == 4) {
         src = lp_build_pad_vector(gallivm, src, 8);
         intrinsic = "llvm.x86.vcvtph2ps.128";
      }
      else {
         intrinsic = "llvm.x86.vcvtph2ps.256";
      }
      return lp_build_intrinsic_unary(builder, intrinsic,
                                      lp_build_vec_type(gallivm, f32_type), src);
   }

   /* Convert int16 vector to int32 vector by zero ext (might generate bad code) */
   h = LLVMBuildZExt(builder, src, int_vec_type, "");
   return lp_build_smallfloat_to_float(gallivm, f32_type, h, 10, 5, 0, true);
}


/**
 * Converts float32 to int16 half-float
 * Note this can be performed in 1 instruction if vcvtps2ph exists (f16c/cvt16)
 * [llvm.x86.vcvtps2ph / _mm_cvtps_ph]
 *
 * @@param src           value to convert
 *
 * Convert float32 to half floats, preserving Infs and NaNs,
 * with rounding towards zero (trunc).
 */
LLVMValueRef
lp_build_float_to_half(struct gallivm_state *gallivm,
                       LLVMValueRef src)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef f32_vec_type = LLVMTypeOf(src);
   unsigned length = LLVMGetTypeKind(f32_vec_type) == LLVMVectorTypeKind
                   ? LLVMGetVectorSize(f32_vec_type) : 1;
   struct lp_type i32_type = lp_type_int_vec(32, 32 * length);
   struct lp_type i16_type = lp_type_int_vec(16, 16 * length);
   LLVMValueRef result;

   if (util_cpu_caps.has_f16c && HAVE_LLVM >= 0x0301 &&
       (length == 4 || length == 8)) {
      struct lp_type i168_type = lp_type_int_vec(16, 16 * 8);
      unsigned mode = 3; /* same as LP_BUILD_ROUND_TRUNCATE */
      LLVMTypeRef i32t = LLVMInt32TypeInContext(gallivm->context);
      const char *intrinsic = NULL;
      if (length == 4) {
         intrinsic = "llvm.x86.vcvtps2ph.128";
      }
      else {
         intrinsic = "llvm.x86.vcvtps2ph.256";
      }
      result = lp_build_intrinsic_binary(builder, intrinsic,
                                         lp_build_vec_type(gallivm, i168_type),
                                         src, LLVMConstInt(i32t, mode, 0));
      if (length == 4) {
         result = lp_build_extract_range(gallivm, result, 0, 4);
      }
   }

   else {
      result = lp_build_float_to_smallfloat(gallivm, i32_type, src, 10, 5, 0, true);
      /* Convert int32 vector to int16 vector by trunc (might generate bad code) */
      result = LLVMBuildTrunc(builder, result, lp_build_vec_type(gallivm, i16_type), "");
   }

   /*
    * Debugging code.
    */
   if (0) {
     LLVMTypeRef i32t = LLVMInt32TypeInContext(gallivm->context);
     LLVMTypeRef i16t = LLVMInt16TypeInContext(gallivm->context);
     LLVMTypeRef f32t = LLVMFloatTypeInContext(gallivm->context);
     LLVMValueRef ref_result = LLVMGetUndef(LLVMVectorType(i16t, length));
     unsigned i;

     LLVMTypeRef func_type = LLVMFunctionType(i16t, &f32t, 1, 0);
     LLVMValueRef func = lp_build_const_int_pointer(gallivm, func_to_pointer((func_pointer)util_float_to_half));
     func = LLVMBuildBitCast(builder, func, LLVMPointerType(func_type, 0), "util_float_to_half");

     for (i = 0; i < length; ++i) {
        LLVMValueRef index = LLVMConstInt(i32t, i, 0);
        LLVMValueRef f32 = LLVMBuildExtractElement(builder, src, index, "");
#if 0
        /* XXX: not really supported by backends */
        LLVMValueRef f16 = lp_build_intrinsic_unary(builder, "llvm.convert.to.fp16", i16t, f32);
#else
        LLVMValueRef f16 = LLVMBuildCall(builder, func, &f32, 1, "");
#endif
        ref_result = LLVMBuildInsertElement(builder, ref_result, f16, index, "");
     }

     lp_build_print_value(gallivm, "src  = ", src);
     lp_build_print_value(gallivm, "llvm = ", result);
     lp_build_print_value(gallivm, "util = ", ref_result);
     lp_build_printf(gallivm, "\n");
  }

   return result;
}
d193 1
a193 1
      rshifted =  LLVMBuildLShr(builder, res,
d234 5
a238 10
   mantissa = lp_mantissa(dst_type);

   if (src_width <= (mantissa + 1)) {
      /*
       * The source width matches fits what can be represented in floating
       * point (i.e., mantissa + 1 bits). So do a straight multiplication
       * followed by casting. No further rounding is necessary.
       */

      scale = 1.0/(double)((1ULL << src_width) - 1);
a243 5
   else {
      /*
       * The source width exceeds what can be represented in floating
       * point. So truncate the incoming values.
       */
d245 1
a245 8
      n = MIN2(mantissa, src_width);

      ubound = ((unsigned long long)1 << n);
      mask = ubound - 1;
      scale = (double)ubound/mask;
      bias = (double)((unsigned long long)1 << (mantissa - n));

      res = src;
d247 1
a247 7
      if (src_width > mantissa) {
         int shift = src_width - mantissa;
         res = LLVMBuildLShr(builder, res,
                             lp_build_const_int_vec(gallivm, dst_type, shift), "");
      }

      bias_ = lp_build_const_vec(gallivm, dst_type, bias);
d249 4
a252 3
      res = LLVMBuildOr(builder,
                        res,
                        LLVMBuildBitCast(builder, bias_, int_vec_type, ""), "");
d254 1
a254 1
      res = LLVMBuildBitCast(builder, res, vec_type, "");
d256 4
a259 2
      res = LLVMBuildFSub(builder, res, bias_, "");
      res = LLVMBuildFMul(builder, res, lp_build_const_vec(gallivm, dst_type, scale), "");
d262 1
a262 2
   return res;
}
d264 3
d268 1
a268 14
/**
 * Pick a suitable num_dsts for lp_build_conv to ensure optimal cases are used.
 *
 * Returns the number of dsts created from src
 */
int lp_build_conv_auto(struct gallivm_state *gallivm,
                       struct lp_type src_type,
                       struct lp_type* dst_type,
                       const LLVMValueRef *src,
                       unsigned num_srcs,
                       LLVMValueRef *dst)
{
   int i;
   int num_dsts = num_srcs;
d270 2
a271 7
   if (src_type.floating == dst_type->floating &&
       src_type.width == dst_type->width &&
       src_type.length == dst_type->length &&
       src_type.fixed == dst_type->fixed &&
       src_type.norm == dst_type->norm &&
       src_type.sign == dst_type->sign)
      return num_dsts;
d273 1
a273 47
   /* Special case 4x4f -> 1x16ub or 2x8f -> 1x16ub
    */
   if (src_type.floating == 1 &&
       src_type.fixed    == 0 &&
       src_type.sign     == 1 &&
       src_type.norm     == 0 &&
       src_type.width    == 32 &&

       dst_type->floating == 0 &&
       dst_type->fixed    == 0 &&
       dst_type->sign     == 0 &&
       dst_type->norm     == 1 &&
       dst_type->width    == 8)
   {
      /* Special case 4x4f --> 1x16ub */
      if (src_type.length == 4 &&
          util_cpu_caps.has_sse2)
      {
         num_dsts = (num_srcs + 3) / 4;
         dst_type->length = num_srcs * 4 >= 16 ? 16 : num_srcs * 4;

         lp_build_conv(gallivm, src_type, *dst_type, src, num_srcs, dst, num_dsts);
         return num_dsts;
      }

      /* Special case 2x8f --> 1x16ub */
      if (src_type.length == 8 &&
          util_cpu_caps.has_avx)
      {
         num_dsts = (num_srcs + 1) / 2;
         dst_type->length = num_srcs * 8 >= 16 ? 16 : num_srcs * 8;

         lp_build_conv(gallivm, src_type, *dst_type, src, num_srcs, dst, num_dsts);
         return num_dsts;
      }
   }

   /* lp_build_resize does not support M:N */
   if (src_type.width == dst_type->width) {
      lp_build_conv(gallivm, src_type, *dst_type, src, num_srcs, dst, num_dsts);
   } else {
      for (i = 0; i < num_srcs; ++i) {
         lp_build_conv(gallivm, src_type, *dst_type, &src[i], 1, &dst[i], 1);
      }
   }

   return num_dsts;
d312 1
a312 1
   /* Special case 4x4f --> 1x16ub, 2x4f -> 1x8ub, 1x4f -> 1x4ub
d326 1
a326 3

       ((dst_type.length == 16 && 4 * num_dsts == num_srcs) ||
        (num_dsts == 1 && dst_type.length * num_srcs == 16 && num_srcs != 3)) &&
d330 1
a330 14
      struct lp_build_context bld;
      struct lp_type int16_type, int32_type;
      struct lp_type dst_type_ext = dst_type;
      LLVMValueRef const_255f;
      unsigned i, j;

      lp_build_context_init(&bld, gallivm, src_type);

      dst_type_ext.length = 16;
      int16_type = int32_type = dst_type_ext;

      int16_type.width *= 2;
      int16_type.length /= 2;
      int16_type.sign = 1;
d332 3
a334 7
      int32_type.width *= 4;
      int32_type.length /= 4;
      int32_type.sign = 1;

      const_255f = lp_build_const_vec(gallivm, src_type, 255.0f);

      for (i = 0; i < num_dsts; ++i, src += 4) {
d336 23
d360 1
a360 4
         for (j = 0; j < dst_type.length / 4; ++j) {
            tmp[j] = LLVMBuildFMul(builder, src[j], const_255f, "");
            tmp[j] = lp_build_iround(&bld, tmp[j]);
         }
d362 21
a382 2
         if (num_srcs == 1) {
            tmp[1] = tmp[0];
a383 1

d385 3
a387 12
         lo = lp_build_pack2(gallivm, int32_type, int16_type, tmp[0], tmp[1]);

         if (num_srcs < 4) {
            hi = lo;
         }
         else {
            hi = lp_build_pack2(gallivm, int32_type, int16_type, tmp[2], tmp[3]);
         }
         dst[i] = lp_build_pack2(gallivm, int16_type, dst_type_ext, lo, hi);
      }
      if (num_srcs < 4) {
         dst[0] = lp_build_extract_range(gallivm, dst[0], 0, dst_type.length);
a388 1

a391 95
   /* Special case 2x8f --> 1x16ub, 1x8f ->1x8ub
    */
   else if (src_type.floating == 1 &&
      src_type.fixed    == 0 &&
      src_type.sign     == 1 &&
      src_type.norm     == 0 &&
      src_type.width    == 32 &&
      src_type.length   == 8 &&

      dst_type.floating == 0 &&
      dst_type.fixed    == 0 &&
      dst_type.sign     == 0 &&
      dst_type.norm     == 1 &&
      dst_type.width    == 8 &&

      ((dst_type.length == 16 && 2 * num_dsts == num_srcs) ||
       (num_dsts == 1 && dst_type.length * num_srcs == 8)) &&

      util_cpu_caps.has_avx) {

      struct lp_build_context bld;
      struct lp_type int16_type, int32_type;
      struct lp_type dst_type_ext = dst_type;
      LLVMValueRef const_255f;
      unsigned i;

      lp_build_context_init(&bld, gallivm, src_type);

      dst_type_ext.length = 16;
      int16_type = int32_type = dst_type_ext;

      int16_type.width *= 2;
      int16_type.length /= 2;
      int16_type.sign = 1;

      int32_type.width *= 4;
      int32_type.length /= 4;
      int32_type.sign = 1;

      const_255f = lp_build_const_vec(gallivm, src_type, 255.0f);

      for (i = 0; i < num_dsts; ++i, src += 2) {
         LLVMValueRef lo, hi, a, b;

         a = LLVMBuildFMul(builder, src[0], const_255f, "");
         a = lp_build_iround(&bld, a);
         tmp[0] = lp_build_extract_range(gallivm, a, 0, 4);
         tmp[1] = lp_build_extract_range(gallivm, a, 4, 4);
         /* relying on clamping behavior of sse2 intrinsics here */
         lo = lp_build_pack2(gallivm, int32_type, int16_type, tmp[0], tmp[1]);

         if (num_srcs == 1) {
            hi = lo;
         }
         else {
            b = LLVMBuildFMul(builder, src[1], const_255f, "");
            b = lp_build_iround(&bld, b);
            tmp[2] = lp_build_extract_range(gallivm, b, 0, 4);
            tmp[3] = lp_build_extract_range(gallivm, b, 4, 4);
            hi = lp_build_pack2(gallivm, int32_type, int16_type, tmp[2], tmp[3]);

         }
         dst[i] = lp_build_pack2(gallivm, int16_type, dst_type_ext, lo, hi);
      }

      if (num_srcs == 1) {
         dst[0] = lp_build_extract_range(gallivm, dst[0], 0, dst_type.length);
      }

      return;
   }

   /* Special case -> 16bit half-float
    */
   else if (dst_type.floating && dst_type.width == 16)
   {
      /* Only support src as 32bit float currently */
      assert(src_type.floating && src_type.width == 32);

      for(i = 0; i < num_tmps; ++i)
         dst[i] = lp_build_float_to_half(gallivm, tmp[i]);

      return;
   }

   /* Pre convert half-floats to floats
    */
   else if (src_type.floating && src_type.width == 16)
   {
      for(i = 0; i < num_tmps; ++i)
         tmp[i] = lp_build_half_to_float(gallivm, tmp[i]);

      tmp_type.width = 32;
   }

a470 16
      unsigned src_offset = lp_const_offset(src_type);
      unsigned dst_offset = lp_const_offset(dst_type);

      /* Compensate for different offsets */
      if (dst_offset > src_offset && src_type.width > dst_type.width) {
         for (i = 0; i < num_tmps; ++i) {
            LLVMValueRef shifted;
            LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type, src_shift - 1);
            if(src_type.sign)
               shifted = LLVMBuildAShr(builder, tmp[i], shift, "");
            else
               shifted = LLVMBuildLShr(builder, tmp[i], shift, "");

            tmp[i] = LLVMBuildSub(builder, tmp[i], shifted, "");
         }
      }
d472 1
a551 2
       unsigned src_offset = lp_const_offset(src_type);
       unsigned dst_offset = lp_const_offset(dst_type);
d553 2
a554 2
       if (src_shift < dst_shift) {
          LLVMValueRef pre_shift[LP_MAX_VECTOR_LENGTH];
d556 1
a556 3

          for (i = 0; i < num_tmps; ++i) {
             pre_shift[i] = tmp[i];
a557 8
          }

          /* Compensate for different offsets */
          if (dst_offset > src_offset) {
             for (i = 0; i < num_tmps; ++i) {
                tmp[i] = LLVMBuildSub(builder, tmp[i], pre_shift[i], "");
             }
          }
d574 1
a574 1
 * Any other value will likely cause unpredictable results.
d585 2
d611 12
a622 1
   lp_build_resize(gallivm, src_type, dst_type, src, num_srcs, dst, num_dsts);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a259 1
      /* instead of fadd/and could (with sse2) just use lp_build_iround */
d268 2
a269 3
       * floating point (i.e., mantissa + 1 bits). Even so correct rounding
       * still needs to be applied (only for numbers in [0.5-1.0] would
       * conversion using truncation after scaling be sufficient).
d271 1
a272 1
      struct lp_build_context uf32_bld;
a273 1
      lp_build_context_init(&uf32_bld, gallivm, src_type);
d278 1
a278 1
      res = lp_build_iround(&uf32_bld, res);
d745 1
d753 4
a756 22
         /*
          * these functions will use fptosi in some form which won't work
          * with 32bit uint dst. Causes lp_test_conv failures though.
          */
         if (0)
            assert(dst_type.sign || dst_type.width < 32);

         if (dst_type.sign && dst_type.norm && !dst_type.fixed) {
            struct lp_build_context bld;

            lp_build_context_init(&bld, gallivm, tmp_type);
            for(i = 0; i < num_tmps; ++i) {
               tmp[i] = lp_build_iround(&bld, tmp[i]);
            }
            tmp_type.floating = FALSE;
         }
         else {
            LLVMTypeRef tmp_vec_type;

            tmp_type.floating = FALSE;
            tmp_vec_type = lp_build_vec_type(gallivm, tmp_type);
            for(i = 0; i < num_tmps; ++i) {
d758 4
a761 4
               if(dst_type.sign)
                  tmp[i] = LLVMBuildFPToSI(builder, tmp[i], tmp_vec_type, "");
               else
                  tmp[i] = LLVMBuildFPToUI(builder, tmp[i], tmp_vec_type, "");
d763 2
a764 2
              /* FIXME: there is no SSE counterpart for LLVMBuildFPToUI */
               tmp[i] = LLVMBuildFPToSI(builder, tmp[i], tmp_vec_type, "");
a765 1
            }
a861 12
          }

          /* the formula above will produce value below -1.0 for most negative
           * value but everything seems happy with that hence disable for now */
          if (0 && !src_type.fixed && src_type.norm && src_type.sign) {
             struct lp_build_context bld;

             lp_build_context_init(&bld, gallivm, dst_type);
             for(i = 0; i < num_tmps; ++i) {
                tmp[i] = lp_build_max(&bld, tmp[i],
                                      lp_build_const_vec(gallivm, dst_type, -1.0f));
             }
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d104 1
a104 1
   if (util_cpu_caps.has_f16c &&
d146 1
a146 1
   if (util_cpu_caps.has_f16c &&
a794 2
      struct lp_build_context bld;
      lp_build_context_init(&bld, gallivm, tmp_type);
d797 1
a797 2
      /* sscaled -> unorm and similar would cause negative shift count, skip */
      if (dst_offset > src_offset && src_type.width > dst_type.width && src_shift > 0) {
d800 5
a805 1
            shifted = lp_build_shr_imm(&bld, tmp[i], src_shift - 1);
d811 2
d814 4
a817 1
            tmp[i] = lp_build_shr_imm(&bld, tmp[i], src_shift - dst_shift);
a902 2
       struct lp_build_context bld;
       lp_build_context_init(&bld, gallivm, tmp_type);
d906 1
d908 3
a910 15
          if (dst_shift - src_shift < dst_type.width) {
             for (i = 0; i < num_tmps; ++i) {
                pre_shift[i] = tmp[i];
                tmp[i] = lp_build_shl_imm(&bld, tmp[i], dst_shift - src_shift);
             }
          }
          else {
             /*
              * This happens for things like sscaled -> unorm conversions. Shift
              * counts equal to bit width cause undefined results, so hack around it.
              */
             for (i = 0; i < num_tmps; ++i) {
                pre_shift[i] = tmp[i];
                tmp[i] = lp_build_zero(gallivm, dst_type);
             }
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d104 1
a104 1
   if (util_cpu_caps.has_f16c && HAVE_LLVM >= 0x0301 &&
d146 1
a146 1
   if (util_cpu_caps.has_f16c && HAVE_LLVM >= 0x0301 &&
d795 2
d799 2
a800 1
      if (dst_offset > src_offset && src_type.width > dst_type.width) {
a802 5
            LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type, src_shift - 1);
            if(src_type.sign)
               shifted = LLVMBuildAShr(builder, tmp[i], shift, "");
            else
               shifted = LLVMBuildLShr(builder, tmp[i], shift, "");
d804 1
a809 2
         LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type,
                                                     src_shift - dst_shift);
d811 1
a811 4
            if(src_type.sign)
               tmp[i] = LLVMBuildAShr(builder, tmp[i], shift, "");
            else
               tmp[i] = LLVMBuildLShr(builder, tmp[i], shift, "");
d897 2
a901 1
          LLVMValueRef shift = lp_build_const_int_vec(gallivm, tmp_type, dst_shift - src_shift);
d903 15
a917 3
          for (i = 0; i < num_tmps; ++i) {
             pre_shift[i] = tmp[i];
             tmp[i] = LLVMBuildShl(builder, tmp[i], shift, "");
@


