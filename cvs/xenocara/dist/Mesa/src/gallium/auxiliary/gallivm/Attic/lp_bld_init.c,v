head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.35;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.43;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.15;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.23;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "pipe/p_config.h"
#include "pipe/p_compiler.h"
#include "util/u_cpu_detect.h"
#include "util/u_debug.h"
#include "util/u_memory.h"
#include "util/u_simple_list.h"
#include "lp_bld.h"
#include "lp_bld_debug.h"
#include "lp_bld_misc.h"
#include "lp_bld_init.h"

#include <llvm-c/Analysis.h>
#include <llvm-c/Transforms/Scalar.h>
#include <llvm-c/BitWriter.h>


/**
 * AVX is supported in:
 * - standard JIT from LLVM 3.2 onwards
 * - MC-JIT from LLVM 3.1
 *   - MC-JIT supports limited OSes (MacOSX and Linux)
 * - standard JIT in LLVM 3.1, with backports
 */
#if defined(PIPE_ARCH_PPC_64) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_ARM) || defined(PIPE_ARCH_AARCH64)
#  define USE_MCJIT 1
#  define HAVE_AVX 0
#elif HAVE_LLVM >= 0x0302 || (HAVE_LLVM == 0x0301 && defined(HAVE_JIT_AVX_SUPPORT))
#  define USE_MCJIT 0
#  define HAVE_AVX 1
#elif HAVE_LLVM == 0x0301 && (defined(PIPE_OS_LINUX) || defined(PIPE_OS_APPLE))
#  define USE_MCJIT 1
#  define HAVE_AVX 1
#else
#  define USE_MCJIT 0
#  define HAVE_AVX 0
#endif


#if USE_MCJIT
void LLVMLinkInMCJIT();
#endif


#ifdef DEBUG
unsigned gallivm_debug = 0;

static const struct debug_named_value lp_bld_debug_flags[] = {
   { "tgsi",   GALLIVM_DEBUG_TGSI, NULL },
   { "ir",     GALLIVM_DEBUG_IR, NULL },
   { "asm",    GALLIVM_DEBUG_ASM, NULL },
   { "nopt",   GALLIVM_DEBUG_NO_OPT, NULL },
   { "perf",   GALLIVM_DEBUG_PERF, NULL },
   { "no_brilinear", GALLIVM_DEBUG_NO_BRILINEAR, NULL },
   { "no_rho_approx", GALLIVM_DEBUG_NO_RHO_APPROX, NULL },
   { "no_quad_lod", GALLIVM_DEBUG_NO_QUAD_LOD, NULL },
   { "gc",     GALLIVM_DEBUG_GC, NULL },
   DEBUG_NAMED_VALUE_END
};

DEBUG_GET_ONCE_FLAGS_OPTION(gallivm_debug, "GALLIVM_DEBUG", lp_bld_debug_flags, 0)
#endif


static boolean gallivm_initialized = FALSE;

unsigned lp_native_vector_width;


/*
 * Optimization values are:
 * - 0: None (-O0)
 * - 1: Less (-O1)
 * - 2: Default (-O2, -Os)
 * - 3: Aggressive (-O3)
 *
 * See also CodeGenOpt::Level in llvm/Target/TargetMachine.h
 */
enum LLVM_CodeGenOpt_Level {
#if HAVE_LLVM >= 0x207
   None,        // -O0
   Less,        // -O1
   Default,     // -O2, -Os
   Aggressive   // -O3
#else
   Default,
   None,
   Aggressive
#endif
};


#if HAVE_LLVM <= 0x0206
/**
 * LLVM 2.6 permits only one ExecutionEngine to be created.  So use the
 * same gallivm state everywhere.
 */
static struct gallivm_state *GlobalGallivm = NULL;
#endif


/**
 * Create the LLVM (optimization) pass manager and install
 * relevant optimization passes.
 * \return  TRUE for success, FALSE for failure
 */
static boolean
create_pass_manager(struct gallivm_state *gallivm)
{
   assert(!gallivm->passmgr);
   assert(gallivm->target);

   gallivm->passmgr = LLVMCreateFunctionPassManager(gallivm->provider);
   if (!gallivm->passmgr)
      return FALSE;

   LLVMAddTargetData(gallivm->target, gallivm->passmgr);

   if ((gallivm_debug & GALLIVM_DEBUG_NO_OPT) == 0) {
      /* These are the passes currently listed in llvm-c/Transforms/Scalar.h,
       * but there are more on SVN.
       * TODO: Add more passes.
       */
      LLVMAddScalarReplAggregatesPass(gallivm->passmgr);
      LLVMAddLICMPass(gallivm->passmgr);
      LLVMAddCFGSimplificationPass(gallivm->passmgr);
      LLVMAddReassociatePass(gallivm->passmgr);

      if (HAVE_LLVM >= 0x207 && sizeof(void*) == 4) {
         /* For LLVM >= 2.7 and 32-bit build, use this order of passes to
          * avoid generating bad code.
          * Test with piglit glsl-vs-sqrt-zero test.
          */
         LLVMAddConstantPropagationPass(gallivm->passmgr);
         LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
      }
      else {
         LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
         LLVMAddConstantPropagationPass(gallivm->passmgr);
      }

      if (util_cpu_caps.has_sse4_1) {
         /* FIXME: There is a bug in this pass, whereby the combination
          * of fptosi and sitofp (necessary for trunc/floor/ceil/round
          * implementation) somehow becomes invalid code.
          */
         LLVMAddInstructionCombiningPass(gallivm->passmgr);
      }
      LLVMAddGVNPass(gallivm->passmgr);
   }
   else {
      /* We need at least this pass to prevent the backends to fail in
       * unexpected ways.
       */
      LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
   }

   return TRUE;
}


/**
 * Free gallivm object's LLVM allocations, but not the gallivm object itself.
 */
static void
free_gallivm_state(struct gallivm_state *gallivm)
{
#if HAVE_LLVM >= 0x207 /* XXX or 0x208? */
   /* This leads to crashes w/ some versions of LLVM */
   LLVMModuleRef mod;
   char *error;

   if (gallivm->engine && gallivm->provider)
      LLVMRemoveModuleProvider(gallivm->engine, gallivm->provider,
                               &mod, &error);
#endif

   if (gallivm->passmgr) {
      LLVMDisposePassManager(gallivm->passmgr);
   }

#if 0
   /* XXX this seems to crash with all versions of LLVM */
   if (gallivm->provider)
      LLVMDisposeModuleProvider(gallivm->provider);
#endif

   if (HAVE_LLVM >= 0x207 && gallivm->engine) {
      /* This will already destroy any associated module */
      LLVMDisposeExecutionEngine(gallivm->engine);
   } else {
      LLVMDisposeModule(gallivm->module);
   }

#if !USE_MCJIT
   /* Don't free the TargetData, it's owned by the exec engine */
#else
   if (gallivm->target) {
      LLVMDisposeTargetData(gallivm->target);
   }
#endif

   /* Never free the LLVM context.
    */
#if 0
   if (gallivm->context)
      LLVMContextDispose(gallivm->context);
#endif

   if (gallivm->builder)
      LLVMDisposeBuilder(gallivm->builder);

   gallivm->engine = NULL;
   gallivm->target = NULL;
   gallivm->module = NULL;
   gallivm->provider = NULL;
   gallivm->passmgr = NULL;
   gallivm->context = NULL;
   gallivm->builder = NULL;
}


static boolean
init_gallivm_engine(struct gallivm_state *gallivm)
{
   if (1) {
      /* We can only create one LLVMExecutionEngine (w/ LLVM 2.6 anyway) */
      enum LLVM_CodeGenOpt_Level optlevel;
      char *error = NULL;
      int ret;

      if (gallivm_debug & GALLIVM_DEBUG_NO_OPT) {
         optlevel = None;
      }
      else {
         optlevel = Default;
      }

#if HAVE_LLVM >= 0x0301
      ret = lp_build_create_jit_compiler_for_module(&gallivm->engine,
                                                    gallivm->module,
                                                    (unsigned) optlevel,
                                                    USE_MCJIT,
                                                    &error);
#else
      ret = LLVMCreateJITCompiler(&gallivm->engine, gallivm->provider,
                                  (unsigned) optlevel, &error);
#endif
      if (ret) {
         _debug_printf("%s\n", error);
         LLVMDisposeMessage(error);
         goto fail;
      }
   }

   LLVMAddModuleProvider(gallivm->engine, gallivm->provider);//new

#if !USE_MCJIT
   gallivm->target = LLVMGetExecutionEngineTargetData(gallivm->engine);
   if (!gallivm->target)
      goto fail;
#else
   if (0) {
       /*
        * Dump the data layout strings.
        */

       LLVMTargetDataRef target = LLVMGetExecutionEngineTargetData(gallivm->engine);
       char *data_layout;
       char *engine_data_layout;

       data_layout = LLVMCopyStringRepOfTargetData(gallivm->target);
       engine_data_layout = LLVMCopyStringRepOfTargetData(target);

       if (1) {
          debug_printf("module target data = %s\n", data_layout);
          debug_printf("engine target data = %s\n", engine_data_layout);
       }

       free(data_layout);
       free(engine_data_layout);
   }
#endif

   return TRUE;

fail:
   return FALSE;
}


/**
 * Singleton
 *
 * We must never free LLVM contexts, because LLVM has several global caches
 * which pointing/derived from objects owned by the context, causing false
 * memory leaks and false cache hits when these objects are destroyed.
 *
 * TODO: For thread safety on multi-threaded OpenGL we should use one LLVM
 * context per thread, and put them in a pool when threads are destroyed.
 */
static LLVMContextRef gallivm_context = NULL;


/**
 * Allocate gallivm LLVM objects.
 * \return  TRUE for success, FALSE for failure
 */
static boolean
init_gallivm_state(struct gallivm_state *gallivm)
{
   assert(!gallivm->context);
   assert(!gallivm->module);
   assert(!gallivm->provider);

   lp_build_init();

   if (!gallivm_context) {
      gallivm_context = LLVMContextCreate();
   }
   gallivm->context = gallivm_context;
   if (!gallivm->context)
      goto fail;

   gallivm->module = LLVMModuleCreateWithNameInContext("gallivm",
                                                       gallivm->context);
   if (!gallivm->module)
      goto fail;

   gallivm->provider =
      LLVMCreateModuleProviderForExistingModule(gallivm->module);
   if (!gallivm->provider)
      goto fail;

   gallivm->builder = LLVMCreateBuilderInContext(gallivm->context);
   if (!gallivm->builder)
      goto fail;

   /* FIXME: MC-JIT only allows compiling one module at a time, and it must be
    * complete when MC-JIT is created. So defer the MC-JIT engine creation for
    * now.
    */
#if !USE_MCJIT
   if (!init_gallivm_engine(gallivm)) {
      goto fail;
   }
#else
   /*
    * MC-JIT engine compiles the module immediately on creation, so we can't
    * obtain the target data from it.  Instead we create a target data layout
    * from a string.
    *
    * The produced layout strings are not precisely the same, but should make
    * no difference for the kind of optimization passes we run.
    *
    * For reference this is the layout string on x64:
    *
    *   e-p:64:64:64-S128-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f16:16:16-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-f128:128:128-n8:16:32:64
    *
    * See also:
    * - http://llvm.org/docs/LangRef.html#datalayout
    */

   {
      const unsigned pointer_size = 8 * sizeof(void *);
      char layout[512];
      util_snprintf(layout, sizeof layout, "%c-p:%u:%u:%u-i64:64:64-a0:0:%u-s0:%u:%u",
#ifdef PIPE_ARCH_LITTLE_ENDIAN
                    'e', // little endian
#else
                    'E', // big endian
#endif
                    pointer_size, pointer_size, pointer_size, // pointer size, abi alignment, preferred alignment
                    pointer_size, // aggregate preferred alignment
                    pointer_size, pointer_size); // stack objects abi alignment, preferred alignment

      gallivm->target = LLVMCreateTargetData(layout);
      if (!gallivm->target) {
         return FALSE;
      }
   }
#endif

   if (!create_pass_manager(gallivm))
      goto fail;

   return TRUE;

fail:
   free_gallivm_state(gallivm);
   return FALSE;
}


void
lp_build_init(void)
{
   if (gallivm_initialized)
      return;

#ifdef DEBUG
   gallivm_debug = debug_get_option_gallivm_debug();
#endif

   lp_set_target_options();

#if USE_MCJIT
   LLVMLinkInMCJIT();
#else
   LLVMLinkInJIT();
#endif

   util_cpu_detect();

   /* AMD Bulldozer AVX's throughput is the same as SSE2; and because using
    * 8-wide vector needs more floating ops than 4-wide (due to padding), it is
    * actually more efficient to use 4-wide vectors on this processor.
    *
    * See also:
    * - http://www.anandtech.com/show/4955/the-bulldozer-review-amd-fx8150-tested/2
    */
   if (HAVE_AVX &&
       util_cpu_caps.has_avx &&
       util_cpu_caps.has_intel) {
      lp_native_vector_width = 256;
   } else {
      /* Leave it at 128, even when no SIMD extensions are available.
       * Really needs to be a multiple of 128 so can fit 4 floats.
       */
      lp_native_vector_width = 128;
   }
 
   lp_native_vector_width = debug_get_num_option("LP_NATIVE_VECTOR_WIDTH",
                                                 lp_native_vector_width);

   if (lp_native_vector_width <= 128) {
      /* Hide AVX support, as often LLVM AVX intrinsics are only guarded by
       * "util_cpu_caps.has_avx" predicate, and lack the
       * "lp_native_vector_width > 128" predicate. And also to ensure a more
       * consistent behavior, allowing one to test SSE2 on AVX machines.
       * XXX: should not play games with util_cpu_caps directly as it might
       * get used for other things outside llvm too.
       */
      util_cpu_caps.has_avx = 0;
      util_cpu_caps.has_avx2 = 0;
   }

   if (!HAVE_AVX) {
      /*
       * note these instructions are VEX-only, so can only emit if we use
       * avx (don't want to base it on has_avx & has_f16c later as that would
       * omit it unnecessarily on amd cpus, see above).
       */
      util_cpu_caps.has_f16c = 0;
      util_cpu_caps.has_xop = 0;
   }

#ifdef PIPE_ARCH_PPC_64
   /* Set the NJ bit in VSCR to 0 so denormalized values are handled as
    * specified by IEEE standard (PowerISA 2.06 - Section 6.3). This guarantees
    * that some rounding and half-float to float handling does not round
    * incorrectly to 0.
    * XXX: should eventually follow same logic on all platforms.
    * Right now denorms get explicitly disabled (but elsewhere) for x86,
    * whereas ppc64 explicitly enables them...
    */
   if (util_cpu_caps.has_altivec) {
      unsigned short mask[] = { 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
                                0xFFFF, 0xFFFF, 0xFFFE, 0xFFFF };
      __asm (
        "mfvscr %%v1\n"
        "vand   %0,%%v1,%0\n"
        "mtvscr %0"
        :
        : "r" (*mask)
      );
   }
#endif

   gallivm_initialized = TRUE;

#if 0
   /* For simulating less capable machines */
   util_cpu_caps.has_sse3 = 0;
   util_cpu_caps.has_ssse3 = 0;
   util_cpu_caps.has_sse4_1 = 0;
   util_cpu_caps.has_avx = 0;
   util_cpu_caps.has_f16c = 0;
#endif
}



/**
 * Create a new gallivm_state object.
 * Note that we return a singleton.
 */
struct gallivm_state *
gallivm_create(void)
{
   struct gallivm_state *gallivm;

#if HAVE_LLVM <= 0x206
   if (GlobalGallivm) {
      return GlobalGallivm;
   }
#endif

   gallivm = CALLOC_STRUCT(gallivm_state);
   if (gallivm) {
      if (!init_gallivm_state(gallivm)) {
         FREE(gallivm);
         gallivm = NULL;
      }
   }

#if HAVE_LLVM <= 0x206
   GlobalGallivm = gallivm;
#endif

   return gallivm;
}


/**
 * Destroy a gallivm_state object.
 */
void
gallivm_destroy(struct gallivm_state *gallivm)
{
#if HAVE_LLVM <= 0x0206
   /* No-op: don't destroy the singleton */
   (void) gallivm;
#else
   free_gallivm_state(gallivm);
   FREE(gallivm);
#endif
}


/**
 * Validate and optimze a function.
 */
static void
gallivm_optimize_function(struct gallivm_state *gallivm,
                          LLVMValueRef func)
{
   if (0) {
      debug_printf("optimizing %s...\n", LLVMGetValueName(func));
   }

   assert(gallivm->passmgr);

   /* Apply optimizations to LLVM IR */
   LLVMRunFunctionPassManager(gallivm->passmgr, func);

   if (0) {
      if (gallivm_debug & GALLIVM_DEBUG_IR) {
         /* Print the LLVM IR to stderr */
         lp_debug_dump_value(func);
         debug_printf("\n");
      }
   }
}


/**
 * Validate a function.
 */
void
gallivm_verify_function(struct gallivm_state *gallivm,
                        LLVMValueRef func)
{
   /* Verify the LLVM IR.  If invalid, dump and abort */
#ifdef DEBUG
   if (LLVMVerifyFunction(func, LLVMPrintMessageAction)) {
      lp_debug_dump_value(func);
      assert(0);
      return;
   }
#endif

   gallivm_optimize_function(gallivm, func);

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      /* Print the LLVM IR to stderr */
      lp_debug_dump_value(func);
      debug_printf("\n");
   }
}


void
gallivm_compile_module(struct gallivm_state *gallivm)
{
#if HAVE_LLVM > 0x206
   assert(!gallivm->compiled);
#endif

   /* Dump byte code to a file */
   if (0) {
      LLVMWriteBitcodeToFile(gallivm->module, "llvmpipe.bc");
      debug_printf("llvmpipe.bc written\n");
      debug_printf("Invoke as \"llc -o - llvmpipe.bc\"\n");
   }

#if USE_MCJIT
   assert(!gallivm->engine);
   if (!init_gallivm_engine(gallivm)) {
      assert(0);
   }
#endif
   assert(gallivm->engine);

   ++gallivm->compiled;
}



func_pointer
gallivm_jit_function(struct gallivm_state *gallivm,
                     LLVMValueRef func)
{
   void *code;
   func_pointer jit_func;

   assert(gallivm->compiled);
   assert(gallivm->engine);

   code = LLVMGetPointerToGlobal(gallivm->engine, func);
   assert(code);
   jit_func = pointer_to_func(code);

   if (gallivm_debug & GALLIVM_DEBUG_ASM) {
      lp_disassemble(func, code);
   }

#if defined(PROFILE)
   lp_profile(func, code);
#endif

   /* Free the function body to save memory */
   lp_func_delete_body(func);

   return jit_func;
}


/**
 * Free the function (and its machine code).
 */
void
gallivm_free_function(struct gallivm_state *gallivm,
                      LLVMValueRef func,
                      const void *code)
{
#if !USE_MCJIT
   if (code) {
      LLVMFreeMachineCodeForFunction(gallivm->engine, func);
   }

   LLVMDeleteFunction(func);
#endif
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a34 1
#include "os/os_time.h"
d45 8
a52 2
/* Only MCJIT is available as of LLVM SVN r216982 */
#if HAVE_LLVM >= 0x0306
d54 5
a58 1
#elif defined(PIPE_ARCH_PPC_64) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_ARM) || defined(PIPE_ARCH_AARCH64)
d60 1
d63 1
d66 1
d71 1
d107 1
d112 5
d120 9
a136 1
   char *td_str;
d140 1
a140 1
   gallivm->passmgr = LLVMCreateFunctionPassManagerForModule(gallivm->module);
a143 1
   // Old versions of LLVM get the DataLayout from the pass manager.
a145 5
   // New ones from the Module.
   td_str = LLVMCopyStringRepOfTargetData(gallivm->target);
   LLVMSetDataLayout(gallivm->module, td_str);
   free(td_str);

d155 21
a175 3
      LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
      LLVMAddConstantPropagationPass(gallivm->passmgr);
      LLVMAddInstructionCombiningPass(gallivm->passmgr);
d190 1
a190 2
 * Free gallivm object's LLVM allocations, but not any generated code
 * nor the gallivm object itself.
d192 2
a193 2
void
gallivm_free_ir(struct gallivm_state *gallivm)
d195 10
d209 7
a215 1
   if (gallivm->engine) {
d218 1
a218 1
   } else if (gallivm->module) {
d230 7
a239 2
   /* The LLVMContext should be owned by the parent of gallivm. */

d243 1
a249 15
/**
 * Free LLVM-generated code.  Should be done AFTER gallivm_free_ir().
 */
static void
gallivm_free_code(struct gallivm_state *gallivm)
{
   assert(!gallivm->module);
   assert(!gallivm->engine);
   lp_free_generated_code(gallivm->code);
   gallivm->code = NULL;
   lp_free_memory_manager(gallivm->memorymgr);
   gallivm->memorymgr = NULL;
}


d254 1
d266 1
a267 1
                                                    &gallivm->code,
a268 1
                                                    gallivm->memorymgr,
d272 4
d283 2
d320 13
d337 1
a337 2
init_gallivm_state(struct gallivm_state *gallivm, const char *name,
                   LLVMContextRef context)
d341 1
d343 1
a343 4
   if (!lp_build_init())
      return FALSE;

   gallivm->context = context;
d345 4
d352 1
a352 1
   gallivm->module = LLVMModuleCreateWithNameInContext(name,
d357 5
a365 4
   gallivm->memorymgr = lp_get_default_memory_manager();
   if (!gallivm->memorymgr)
      goto fail;

d417 1
a417 2
   gallivm_free_ir(gallivm);
   gallivm_free_code(gallivm);
d422 1
a422 1
boolean
d426 1
a426 1
      return TRUE;
d449 2
a450 1
   if (util_cpu_caps.has_avx &&
d475 10
a516 2

   return TRUE;
d523 1
d526 1
a526 1
gallivm_create(const char *name, LLVMContextRef context)
d530 6
d538 1
a538 1
      if (!init_gallivm_state(gallivm, name, context)) {
d544 4
d558 5
a562 2
   gallivm_free_ir(gallivm);
   gallivm_free_code(gallivm);
d564 27
a595 1
 * Verification is only done with debug builds.
d610 2
a619 4
/**
 * Compile a module.
 * This does IR optimization on all functions in the module.
 */
d623 1
a623 3
   LLVMValueRef func;
   int64_t time_begin;

d625 1
a625 27

   if (gallivm->builder) {
      LLVMDisposeBuilder(gallivm->builder);
      gallivm->builder = NULL;
   }

   if (gallivm_debug & GALLIVM_DEBUG_PERF)
      time_begin = os_time_get();

   /* Run optimization passes */
   LLVMInitializeFunctionPassManager(gallivm->passmgr);
   func = LLVMGetFirstFunction(gallivm->module);
   while (func) {
      if (0) {
         debug_printf("optimizing func %s...\n", LLVMGetValueName(func));
      }
      LLVMRunFunctionPassManager(gallivm->passmgr, func);
      func = LLVMGetNextFunction(func);
   }
   LLVMFinalizeFunctionPassManager(gallivm->passmgr);

   if (gallivm_debug & GALLIVM_DEBUG_PERF) {
      int64_t time_end = os_time_get();
      int time_msec = (int)(time_end - time_begin) / 1000;
      debug_printf("optimizing module %s took %d msec\n",
                   lp_get_module_id(gallivm->module), time_msec);
   }
d669 3
d673 18
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d35 1
d46 2
a47 8
/**
 * AVX is supported in:
 * - standard JIT from LLVM 3.2 onwards
 * - MC-JIT from LLVM 3.1
 *   - MC-JIT supports limited OSes (MacOSX and Linux)
 * - standard JIT in LLVM 3.1, with backports
 */
#if defined(PIPE_ARCH_PPC_64) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_ARM) || defined(PIPE_ARCH_AARCH64)
d49 1
a49 5
#  define HAVE_AVX 0
#elif HAVE_LLVM >= 0x0302 || (HAVE_LLVM == 0x0301 && defined(HAVE_JIT_AVX_SUPPORT))
#  define USE_MCJIT 0
#  define HAVE_AVX 1
#elif HAVE_LLVM == 0x0301 && (defined(PIPE_OS_LINUX) || defined(PIPE_OS_APPLE))
a50 1
#  define HAVE_AVX 1
a52 1
#  define HAVE_AVX 0
a54 1

a58 1

a93 1
#if HAVE_LLVM >= 0x207
a97 5
#else
   Default,
   None,
   Aggressive
#endif
a100 9
#if HAVE_LLVM <= 0x0206
/**
 * LLVM 2.6 permits only one ExecutionEngine to be created.  So use the
 * same gallivm state everywhere.
 */
static struct gallivm_state *GlobalGallivm = NULL;
#endif


d109 1
d113 1
a113 1
   gallivm->passmgr = LLVMCreateFunctionPassManager(gallivm->provider);
d117 1
d120 5
d134 3
a136 21

      if (HAVE_LLVM >= 0x207 && sizeof(void*) == 4) {
         /* For LLVM >= 2.7 and 32-bit build, use this order of passes to
          * avoid generating bad code.
          * Test with piglit glsl-vs-sqrt-zero test.
          */
         LLVMAddConstantPropagationPass(gallivm->passmgr);
         LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
      }
      else {
         LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
         LLVMAddConstantPropagationPass(gallivm->passmgr);
      }

      if (util_cpu_caps.has_sse4_1) {
         /* FIXME: There is a bug in this pass, whereby the combination
          * of fptosi and sitofp (necessary for trunc/floor/ceil/round
          * implementation) somehow becomes invalid code.
          */
         LLVMAddInstructionCombiningPass(gallivm->passmgr);
      }
d151 2
a152 1
 * Free gallivm object's LLVM allocations, but not the gallivm object itself.
d154 2
a155 2
static void
free_gallivm_state(struct gallivm_state *gallivm)
a156 10
#if HAVE_LLVM >= 0x207 /* XXX or 0x208? */
   /* This leads to crashes w/ some versions of LLVM */
   LLVMModuleRef mod;
   char *error;

   if (gallivm->engine && gallivm->provider)
      LLVMRemoveModuleProvider(gallivm->engine, gallivm->provider,
                               &mod, &error);
#endif

d161 1
a161 7
#if 0
   /* XXX this seems to crash with all versions of LLVM */
   if (gallivm->provider)
      LLVMDisposeModuleProvider(gallivm->provider);
#endif

   if (HAVE_LLVM >= 0x207 && gallivm->engine) {
d164 1
a164 1
   } else {
a175 7
   /* Never free the LLVM context.
    */
#if 0
   if (gallivm->context)
      LLVMContextDispose(gallivm->context);
#endif

d179 2
a183 1
   gallivm->provider = NULL;
d190 15
a208 1
      /* We can only create one LLVMExecutionEngine (w/ LLVM 2.6 anyway) */
a219 1
#if HAVE_LLVM >= 0x0301
d221 1
d223 1
a226 4
#else
      ret = LLVMCreateJITCompiler(&gallivm->engine, gallivm->provider,
                                  (unsigned) optlevel, &error);
#endif
a233 2
   LLVMAddModuleProvider(gallivm->engine, gallivm->provider);//new

a268 13
 * Singleton
 *
 * We must never free LLVM contexts, because LLVM has several global caches
 * which pointing/derived from objects owned by the context, causing false
 * memory leaks and false cache hits when these objects are destroyed.
 *
 * TODO: For thread safety on multi-threaded OpenGL we should use one LLVM
 * context per thread, and put them in a pool when threads are destroyed.
 */
static LLVMContextRef gallivm_context = NULL;


/**
d273 2
a274 1
init_gallivm_state(struct gallivm_state *gallivm)
a277 1
   assert(!gallivm->provider);
d279 4
a282 1
   lp_build_init();
a283 4
   if (!gallivm_context) {
      gallivm_context = LLVMContextCreate();
   }
   gallivm->context = gallivm_context;
d287 1
a287 1
   gallivm->module = LLVMModuleCreateWithNameInContext("gallivm",
d292 2
a293 3
   gallivm->provider =
      LLVMCreateModuleProviderForExistingModule(gallivm->module);
   if (!gallivm->provider)
d296 2
a297 2
   gallivm->builder = LLVMCreateBuilderInContext(gallivm->context);
   if (!gallivm->builder)
d351 2
a352 1
   free_gallivm_state(gallivm);
d357 1
a357 1
void
d361 1
a361 1
      return;
d384 1
a384 2
   if (HAVE_AVX &&
       util_cpu_caps.has_avx &&
a408 10
   if (!HAVE_AVX) {
      /*
       * note these instructions are VEX-only, so can only emit if we use
       * avx (don't want to base it on has_avx & has_f16c later as that would
       * omit it unnecessarily on amd cpus, see above).
       */
      util_cpu_caps.has_f16c = 0;
      util_cpu_caps.has_xop = 0;
   }

d441 2
a448 1
 * Note that we return a singleton.
d451 1
a451 1
gallivm_create(void)
a454 6
#if HAVE_LLVM <= 0x206
   if (GlobalGallivm) {
      return GlobalGallivm;
   }
#endif

d457 1
a457 1
      if (!init_gallivm_state(gallivm)) {
a462 4
#if HAVE_LLVM <= 0x206
   GlobalGallivm = gallivm;
#endif

d473 2
a474 5
#if HAVE_LLVM <= 0x0206
   /* No-op: don't destroy the singleton */
   (void) gallivm;
#else
   free_gallivm_state(gallivm);
a475 27
#endif
}


/**
 * Validate and optimze a function.
 */
static void
gallivm_optimize_function(struct gallivm_state *gallivm,
                          LLVMValueRef func)
{
   if (0) {
      debug_printf("optimizing %s...\n", LLVMGetValueName(func));
   }

   assert(gallivm->passmgr);

   /* Apply optimizations to LLVM IR */
   LLVMRunFunctionPassManager(gallivm->passmgr, func);

   if (0) {
      if (gallivm_debug & GALLIVM_DEBUG_IR) {
         /* Print the LLVM IR to stderr */
         lp_debug_dump_value(func);
         debug_printf("\n");
      }
   }
d481 1
a495 2
   gallivm_optimize_function(gallivm, func);

d504 4
d511 3
a513 1
#if HAVE_LLVM > 0x206
d515 27
a541 1
#endif
a584 3
   /* Free the function body to save memory */
   lp_func_delete_body(func);

a585 18
}


/**
 * Free the function (and its machine code).
 */
void
gallivm_free_function(struct gallivm_state *gallivm,
                      LLVMValueRef func,
                      const void *code)
{
#if !USE_MCJIT
   if (code) {
      LLVMFreeMachineCodeForFunction(gallivm->engine, func);
   }

   LLVMDeleteFunction(func);
#endif
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d83 1
d464 1
a464 1
      /* Hide AVX support, as often LLVM AVX instrinsics are only guarded by
d468 2
d472 1
d482 1
d487 1
a487 1
    * specified by IEEE standard (PowerISA 2.06 - Section 6.3). This garantees
d490 3
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d29 1
d35 1
d37 1
d40 1
d42 28
d82 1
d93 2
d119 1
d121 2
a122 6
 * LLVM 2.6 permits only one ExecutionEngine to be created.  This is it.
 */
static LLVMExecutionEngineRef GlobalEngine = NULL;

/**
 * Same gallivm state shared by all contexts.
d125 1
a125 10




extern void
lp_register_oprofile_jit_event_listener(LLVMExecutionEngineRef EE);

extern void
lp_set_target_options(void);

d137 1
d150 2
d153 1
d204 4
d214 4
a217 5
   if (gallivm->passmgr)
      LLVMDisposePassManager(gallivm->passmgr);

#if HAVE_LLVM >= 0x207
   if (gallivm->module)
d219 1
a219 1
#endif
d221 6
a226 4
#if 0
   /* Don't free the exec engine, it's a global/singleton */
   if (gallivm->engine)
      LLVMDisposeExecutionEngine(gallivm->engine);
d229 2
a231 4
   /* Don't free the TargetData, it's owned by the exec engine */
   LLVMDisposeTargetData(gallivm->target);
#endif

d234 1
a248 4
/**
 * Allocate gallivm LLVM objects.
 * \return  TRUE for success, FALSE for failure
 */
d250 1
a250 1
init_gallivm_state(struct gallivm_state *gallivm)
d252 1
a252 21
   assert(!gallivm->context);
   assert(!gallivm->module);
   assert(!gallivm->provider);

   lp_build_init();

   gallivm->context = LLVMContextCreate();
   if (!gallivm->context)
      goto fail;

   gallivm->module = LLVMModuleCreateWithNameInContext("gallivm",
                                                       gallivm->context);
   if (!gallivm->module)
      goto fail;

   gallivm->provider =
      LLVMCreateModuleProviderForExistingModule(gallivm->module);
   if (!gallivm->provider)
      goto fail;

   if (!GlobalEngine) {
d256 1
d265 11
a275 2
      if (LLVMCreateJITCompiler(&GlobalEngine, gallivm->provider,
                                (unsigned) optlevel, &error)) {
a279 4

#if defined(DEBUG) || defined(PROFILE)
      lp_register_oprofile_jit_event_listener(GlobalEngine);
#endif
a281 2
   gallivm->engine = GlobalEngine;

d284 1
d288 17
d306 4
a309 6
   if (!create_pass_manager(gallivm))
      goto fail;

   gallivm->builder = LLVMCreateBuilderInContext(gallivm->context);
   if (!gallivm->builder)
      goto fail;
a313 1
   free_gallivm_state(gallivm);
d318 11
a328 10
struct callback
{
   garbage_collect_callback_func func;
   void *cb_data;
   struct callback *prev, *next;
};


/** list of all garbage collector callbacks */
static struct callback callback_list = {NULL, NULL, NULL, NULL};
d332 2
a333 2
 * Register a function with gallivm which will be called when we
 * do garbage collection.
d335 2
a336 3
void
gallivm_register_garbage_collector_callback(garbage_collect_callback_func func,
                                            void *cb_data)
d338 3
a340 1
   struct callback *cb;
d342 1
a342 3
   if (!callback_list.prev) {
      make_empty_list(&callback_list);
   }
d344 2
a345 4
   /* see if already in list */
   foreach(cb, &callback_list) {
      if (cb->func == func && cb->cb_data == cb_data)
         return;
d347 3
d351 4
a354 8
   /* add to list */
   cb = CALLOC_STRUCT(callback);
   if (cb) {
      cb->func = func;
      cb->cb_data = cb_data;
      insert_at_head(&callback_list, cb);
   }
}
d356 4
d361 3
a363 8
/**
 * Remove a callback.
 */
void
gallivm_remove_garbage_collector_callback(garbage_collect_callback_func func,
                                          void *cb_data)
{
   struct callback *cb;
d365 41
a405 6
   /* search list */
   foreach(cb, &callback_list) {
      if (cb->func == func && cb->cb_data == cb_data) {
         /* found, remove it */
         remove_from_list(cb);
         return;
d408 1
a408 1
}
d410 2
d413 1
a413 12
/**
 * Call the callback functions (which are typically in the
 * draw module and llvmpipe driver.
 */
static void
call_garbage_collector_callbacks(void)
{
   struct callback *cb;
   foreach(cb, &callback_list) {
      cb->func(cb->cb_data);
   }
}
d415 3
a417 18


/**
 * Other gallium components using gallivm should call this periodically
 * to let us do garbage collection (or at least try to free memory
 * accumulated by the LLVM libraries).
 */
void
gallivm_garbage_collect(struct gallivm_state *gallivm)
{
   if (gallivm->context) {
      if (gallivm_debug & GALLIVM_DEBUG_GC)
         debug_printf("***** Doing LLVM garbage collection\n");

      call_garbage_collector_callbacks();
      free_gallivm_state(gallivm);
      init_gallivm_state(gallivm);
   }
d433 3
a435 2
   LLVMInitializeNativeTarget();

d437 1
d440 18
d459 40
d506 2
d520 13
a532 7
   if (!GlobalGallivm) {
      GlobalGallivm = CALLOC_STRUCT(gallivm_state);
      if (GlobalGallivm) {
         if (!init_gallivm_state(GlobalGallivm)) {
            FREE(GlobalGallivm);
            GlobalGallivm = NULL;
         }
d535 6
a540 1
   return GlobalGallivm;
d550 1
d553 4
d560 77
d638 32
a669 5
/* 
 * Hack to allow the linking of release LLVM static libraries on a debug build.
 *
 * See also:
 * - http://social.msdn.microsoft.com/Forums/en-US/vclanguage/thread/7234ea2b-0042-42ed-b4e2-5d8644dfb57d
d671 11
a681 4
#if defined(_MSC_VER) && defined(_DEBUG)
#include <crtdefs.h>
_CRTIMP void __cdecl
_invalid_parameter_noinfo(void) {}
d683 1
@


1.1
log
@Initial revision
@
text
@d33 1
a224 1
   assert(gallivm_initialized);
d229 2
d296 1
d300 2
a301 3
#define MAX_CALLBACKS 32
static struct callback Callbacks[MAX_CALLBACKS];
static unsigned NumCallbacks = 0;
d312 5
a316 1
   unsigned i;
d318 3
a320 3
   for (i = 0; i < NumCallbacks; i++) {
      if (Callbacks[i].func == func && Callbacks[i].cb_data == cb_data) {
         /* already in list: no-op */
a321 1
      }
d324 6
a329 5
   assert(NumCallbacks < MAX_CALLBACKS);
   if (NumCallbacks < MAX_CALLBACKS) {
      Callbacks[NumCallbacks].func = func;
      Callbacks[NumCallbacks].cb_data = cb_data;
      NumCallbacks++;
d341 1
a341 1
   unsigned i;
d343 5
a347 7
   for (i = 0; i < NumCallbacks; i++) {
      if (Callbacks[i].func == func && Callbacks[i].cb_data == cb_data) {
         /* found, now remove it */
         NumCallbacks--;
         for ( ; i < NumCallbacks; i++) {
            Callbacks[i] = Callbacks[i + 1];
         }
d361 3
a363 4
   unsigned i;

   for (i = 0; i < NumCallbacks; i++) {
      Callbacks[i].func(Callbacks[i].cb_data);
d391 3
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a28 1
#include "pipe/p_config.h"
a32 2
#include "util/u_simple_list.h"
#include "lp_bld.h"
a33 1
#include "lp_bld_misc.h"
a35 1
#include <llvm-c/Analysis.h>
a36 28
#include <llvm-c/BitWriter.h>


/**
 * AVX is supported in:
 * - standard JIT from LLVM 3.2 onwards
 * - MC-JIT from LLVM 3.1
 *   - MC-JIT supports limited OSes (MacOSX and Linux)
 * - standard JIT in LLVM 3.1, with backports
 */
#if defined(PIPE_ARCH_PPC_64) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_ARM) || defined(PIPE_ARCH_AARCH64)
#  define USE_MCJIT 1
#  define HAVE_AVX 0
#elif HAVE_LLVM >= 0x0302 || (HAVE_LLVM == 0x0301 && defined(HAVE_JIT_AVX_SUPPORT))
#  define USE_MCJIT 0
#  define HAVE_AVX 1
#elif HAVE_LLVM == 0x0301 && (defined(PIPE_OS_LINUX) || defined(PIPE_OS_APPLE))
#  define USE_MCJIT 1
#  define HAVE_AVX 1
#else
#  define USE_MCJIT 0
#  define HAVE_AVX 0
#endif


#if USE_MCJIT
void LLVMLinkInMCJIT();
#endif
a48 1
   { "no_rho_approx", GALLIVM_DEBUG_NO_RHO_APPROX, NULL },
a58 2
unsigned lp_native_vector_width;

a82 1
#if HAVE_LLVM <= 0x0206
d84 6
a89 2
 * LLVM 2.6 permits only one ExecutionEngine to be created.  So use the
 * same gallivm state everywhere.
d92 10
a101 1
#endif
a112 1
   assert(gallivm->target);
a124 2
      LLVMAddScalarReplAggregatesPass(gallivm->passmgr);
      LLVMAddLICMPass(gallivm->passmgr);
a125 1
      LLVMAddReassociatePass(gallivm->passmgr);
a175 4
   if (gallivm->passmgr) {
      LLVMDisposePassManager(gallivm->passmgr);
   }

d182 11
a192 2
   if (HAVE_LLVM >= 0x207 && gallivm->engine) {
      /* This will already destroy any associated module */
d194 1
a194 3
   } else {
      LLVMDisposeModule(gallivm->module);
   }
d196 1
a196 1
#if !USE_MCJIT
d198 1
a198 4
#else
   if (gallivm->target) {
      LLVMDisposeTargetData(gallivm->target);
   }
a200 3
   /* Never free the LLVM context.
    */
#if 0
a202 1
#endif
d217 4
d222 1
a222 1
init_gallivm_engine(struct gallivm_state *gallivm)
d224 20
a243 1
   if (1) {
a246 1
      int ret;
d255 2
a256 11
#if HAVE_LLVM >= 0x0301
      ret = lp_build_create_jit_compiler_for_module(&gallivm->engine,
                                                    gallivm->module,
                                                    (unsigned) optlevel,
                                                    USE_MCJIT,
                                                    &error);
#else
      ret = LLVMCreateJITCompiler(&gallivm->engine, gallivm->provider,
                                  (unsigned) optlevel, &error);
#endif
      if (ret) {
d261 4
d267 2
a270 1
#if !USE_MCJIT
a273 17
#else
   if (0) {
       /*
        * Dump the data layout strings.
        */

       LLVMTargetDataRef target = LLVMGetExecutionEngineTargetData(gallivm->engine);
       char *data_layout;
       char *engine_data_layout;

       data_layout = LLVMCopyStringRepOfTargetData(gallivm->target);
       engine_data_layout = LLVMCopyStringRepOfTargetData(target);

       if (1) {
          debug_printf("module target data = %s\n", data_layout);
          debug_printf("engine target data = %s\n", engine_data_layout);
       }
d275 6
a280 4
       free(data_layout);
       free(engine_data_layout);
   }
#endif
d285 1
d290 12
d303 2
a304 8
 * Singleton
 *
 * We must never free LLVM contexts, because LLVM has several global caches
 * which pointing/derived from objects owned by the context, causing false
 * memory leaks and false cache hits when these objects are destroyed.
 *
 * TODO: For thread safety on multi-threaded OpenGL we should use one LLVM
 * context per thread, and put them in a pool when threads are destroyed.
d306 20
a325 1
static LLVMContextRef gallivm_context = NULL;
d329 1
a329 2
 * Allocate gallivm LLVM objects.
 * \return  TRUE for success, FALSE for failure
d331 3
a333 2
static boolean
init_gallivm_state(struct gallivm_state *gallivm)
d335 1
a335 3
   assert(!gallivm->context);
   assert(!gallivm->module);
   assert(!gallivm->provider);
d337 9
a345 4
   lp_build_init();

   if (!gallivm_context) {
      gallivm_context = LLVMContextCreate();
d347 1
a347 3
   gallivm->context = gallivm_context;
   if (!gallivm->context)
      goto fail;
a348 4
   gallivm->module = LLVMModuleCreateWithNameInContext("gallivm",
                                                       gallivm->context);
   if (!gallivm->module)
      goto fail;
d350 8
a357 8
   gallivm->provider =
      LLVMCreateModuleProviderForExistingModule(gallivm->module);
   if (!gallivm->provider)
      goto fail;

   gallivm->builder = LLVMCreateBuilderInContext(gallivm->context);
   if (!gallivm->builder)
      goto fail;
d359 2
a360 7
   /* FIXME: MC-JIT only allows compiling one module at a time, and it must be
    * complete when MC-JIT is created. So defer the MC-JIT engine creation for
    * now.
    */
#if !USE_MCJIT
   if (!init_gallivm_engine(gallivm)) {
      goto fail;
d362 1
a362 36
#else
   /*
    * MC-JIT engine compiles the module immediately on creation, so we can't
    * obtain the target data from it.  Instead we create a target data layout
    * from a string.
    *
    * The produced layout strings are not precisely the same, but should make
    * no difference for the kind of optimization passes we run.
    *
    * For reference this is the layout string on x64:
    *
    *   e-p:64:64:64-S128-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f16:16:16-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-f128:128:128-n8:16:32:64
    *
    * See also:
    * - http://llvm.org/docs/LangRef.html#datalayout
    */

   {
      const unsigned pointer_size = 8 * sizeof(void *);
      char layout[512];
      util_snprintf(layout, sizeof layout, "%c-p:%u:%u:%u-i64:64:64-a0:0:%u-s0:%u:%u",
#ifdef PIPE_ARCH_LITTLE_ENDIAN
                    'e', // little endian
#else
                    'E', // big endian
#endif
                    pointer_size, pointer_size, pointer_size, // pointer size, abi alignment, preferred alignment
                    pointer_size, // aggregate preferred alignment
                    pointer_size, pointer_size); // stack objects abi alignment, preferred alignment

      gallivm->target = LLVMCreateTargetData(layout);
      if (!gallivm->target) {
         return FALSE;
      }
   }
#endif
a363 2
   if (!create_pass_manager(gallivm))
      goto fail;
a364 1
   return TRUE;
d366 16
a381 3
fail:
   free_gallivm_state(gallivm);
   return FALSE;
a387 3
   if (gallivm_initialized)
      return;

d394 2
a395 3
#if USE_MCJIT
   LLVMLinkInMCJIT();
#else
a396 1
#endif
a398 18

   /* AMD Bulldozer AVX's throughput is the same as SSE2; and because using
    * 8-wide vector needs more floating ops than 4-wide (due to padding), it is
    * actually more efficient to use 4-wide vectors on this processor.
    *
    * See also:
    * - http://www.anandtech.com/show/4955/the-bulldozer-review-amd-fx8150-tested/2
    */
   if (HAVE_AVX &&
       util_cpu_caps.has_avx &&
       util_cpu_caps.has_intel) {
      lp_native_vector_width = 256;
   } else {
      /* Leave it at 128, even when no SIMD extensions are available.
       * Really needs to be a multiple of 128 so can fit 4 floats.
       */
      lp_native_vector_width = 128;
   }
a399 40
   lp_native_vector_width = debug_get_num_option("LP_NATIVE_VECTOR_WIDTH",
                                                 lp_native_vector_width);

   if (lp_native_vector_width <= 128) {
      /* Hide AVX support, as often LLVM AVX instrinsics are only guarded by
       * "util_cpu_caps.has_avx" predicate, and lack the
       * "lp_native_vector_width > 128" predicate. And also to ensure a more
       * consistent behavior, allowing one to test SSE2 on AVX machines.
       */
      util_cpu_caps.has_avx = 0;
   }

   if (!HAVE_AVX) {
      /*
       * note these instructions are VEX-only, so can only emit if we use
       * avx (don't want to base it on has_avx & has_f16c later as that would
       * omit it unnecessarily on amd cpus, see above).
       */
      util_cpu_caps.has_f16c = 0;
   }

#ifdef PIPE_ARCH_PPC_64
   /* Set the NJ bit in VSCR to 0 so denormalized values are handled as
    * specified by IEEE standard (PowerISA 2.06 - Section 6.3). This garantees
    * that some rounding and half-float to float handling does not round
    * incorrectly to 0.
    */
   if (util_cpu_caps.has_altivec) {
      unsigned short mask[] = { 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
                                0xFFFF, 0xFFFF, 0xFFFE, 0xFFFF };
      __asm (
        "mfvscr %%v1\n"
        "vand   %0,%%v1,%0\n"
        "mtvscr %0"
        :
        : "r" (*mask)
      );
   }
#endif

a406 2
   util_cpu_caps.has_avx = 0;
   util_cpu_caps.has_f16c = 0;
d419 7
a425 13
   struct gallivm_state *gallivm;

#if HAVE_LLVM <= 0x206
   if (GlobalGallivm) {
      return GlobalGallivm;
   }
#endif

   gallivm = CALLOC_STRUCT(gallivm_state);
   if (gallivm) {
      if (!init_gallivm_state(gallivm)) {
         FREE(gallivm);
         gallivm = NULL;
d428 1
a428 6

#if HAVE_LLVM <= 0x206
   GlobalGallivm = gallivm;
#endif

   return gallivm;
a437 1
#if HAVE_LLVM <= 0x0206
a439 4
#else
   free_gallivm_state(gallivm);
   FREE(gallivm);
#endif
a442 10
/**
 * Validate and optimze a function.
 */
static void
gallivm_optimize_function(struct gallivm_state *gallivm,
                          LLVMValueRef func)
{
   if (0) {
      debug_printf("optimizing %s...\n", LLVMGetValueName(func));
   }
d444 5
a448 99
   assert(gallivm->passmgr);

   /* Apply optimizations to LLVM IR */
   LLVMRunFunctionPassManager(gallivm->passmgr, func);

   if (0) {
      if (gallivm_debug & GALLIVM_DEBUG_IR) {
         /* Print the LLVM IR to stderr */
         lp_debug_dump_value(func);
         debug_printf("\n");
      }
   }
}


/**
 * Validate a function.
 */
void
gallivm_verify_function(struct gallivm_state *gallivm,
                        LLVMValueRef func)
{
   /* Verify the LLVM IR.  If invalid, dump and abort */
#ifdef DEBUG
   if (LLVMVerifyFunction(func, LLVMPrintMessageAction)) {
      lp_debug_dump_value(func);
      assert(0);
      return;
   }
#endif

   gallivm_optimize_function(gallivm, func);

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      /* Print the LLVM IR to stderr */
      lp_debug_dump_value(func);
      debug_printf("\n");
   }
}


void
gallivm_compile_module(struct gallivm_state *gallivm)
{
#if HAVE_LLVM > 0x206
   assert(!gallivm->compiled);
#endif

   /* Dump byte code to a file */
   if (0) {
      LLVMWriteBitcodeToFile(gallivm->module, "llvmpipe.bc");
      debug_printf("llvmpipe.bc written\n");
      debug_printf("Invoke as \"llc -o - llvmpipe.bc\"\n");
   }

#if USE_MCJIT
   assert(!gallivm->engine);
   if (!init_gallivm_engine(gallivm)) {
      assert(0);
   }
#endif
   assert(gallivm->engine);

   ++gallivm->compiled;
}



func_pointer
gallivm_jit_function(struct gallivm_state *gallivm,
                     LLVMValueRef func)
{
   void *code;
   func_pointer jit_func;

   assert(gallivm->compiled);
   assert(gallivm->engine);

   code = LLVMGetPointerToGlobal(gallivm->engine, func);
   assert(code);
   jit_func = pointer_to_func(code);

   if (gallivm_debug & GALLIVM_DEBUG_ASM) {
      lp_disassemble(func, code);
   }

#if defined(PROFILE)
   lp_profile(func, code);
#endif

   /* Free the function body to save memory */
   lp_func_delete_body(func);

   return jit_func;
}


/**
 * Free the function (and its machine code).
d450 4
a453 11
void
gallivm_free_function(struct gallivm_state *gallivm,
                      LLVMValueRef func,
                      const void *code)
{
#if !USE_MCJIT
   if (code) {
      LLVMFreeMachineCodeForFunction(gallivm->engine, func);
   }

   LLVMDeleteFunction(func);
a454 1
}
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a82 1
   { "no_quad_lod", GALLIVM_DEBUG_NO_QUAD_LOD, NULL },
d463 1
a463 1
      /* Hide AVX support, as often LLVM AVX intrinsics are only guarded by
a466 2
       * XXX: should not play games with util_cpu_caps directly as it might
       * get used for other things outside llvm too.
a468 1
      util_cpu_caps.has_avx2 = 0;
a477 1
      util_cpu_caps.has_xop = 0;
d482 1
a482 1
    * specified by IEEE standard (PowerISA 2.06 - Section 6.3). This guarantees
a484 3
    * XXX: should eventually follow same logic on all platforms.
    * Right now denorms get explicitly disabled (but elsewhere) for x86,
    * whereas ppc64 explicitly enables them...
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a34 1
#include "os/os_time.h"
d45 8
a52 2
/* Only MCJIT is available as of LLVM SVN r216982 */
#if HAVE_LLVM >= 0x0306
d54 5
a58 1
#elif defined(PIPE_ARCH_PPC_64) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_ARM) || defined(PIPE_ARCH_AARCH64)
d60 1
d63 1
d66 1
d71 1
d107 1
d112 5
d120 9
a136 1
   char *td_str;
d140 1
a140 1
   gallivm->passmgr = LLVMCreateFunctionPassManagerForModule(gallivm->module);
a143 1
   // Old versions of LLVM get the DataLayout from the pass manager.
a145 5
   // New ones from the Module.
   td_str = LLVMCopyStringRepOfTargetData(gallivm->target);
   LLVMSetDataLayout(gallivm->module, td_str);
   free(td_str);

d155 21
a175 3
      LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
      LLVMAddConstantPropagationPass(gallivm->passmgr);
      LLVMAddInstructionCombiningPass(gallivm->passmgr);
d190 1
a190 2
 * Free gallivm object's LLVM allocations, but not any generated code
 * nor the gallivm object itself.
d192 2
a193 2
void
gallivm_free_ir(struct gallivm_state *gallivm)
d195 10
d209 7
a215 1
   if (gallivm->engine) {
d218 1
a218 1
   } else if (gallivm->module) {
d230 7
a239 2
   /* The LLVMContext should be owned by the parent of gallivm. */

d243 1
a249 15
/**
 * Free LLVM-generated code.  Should be done AFTER gallivm_free_ir().
 */
static void
gallivm_free_code(struct gallivm_state *gallivm)
{
   assert(!gallivm->module);
   assert(!gallivm->engine);
   lp_free_generated_code(gallivm->code);
   gallivm->code = NULL;
   lp_free_memory_manager(gallivm->memorymgr);
   gallivm->memorymgr = NULL;
}


d254 1
d266 1
a267 1
                                                    &gallivm->code,
a268 1
                                                    gallivm->memorymgr,
d272 4
d283 2
d320 13
d337 1
a337 2
init_gallivm_state(struct gallivm_state *gallivm, const char *name,
                   LLVMContextRef context)
d341 1
d343 1
a343 4
   if (!lp_build_init())
      return FALSE;

   gallivm->context = context;
d345 4
d352 1
a352 1
   gallivm->module = LLVMModuleCreateWithNameInContext(name,
d357 5
a365 4
   gallivm->memorymgr = lp_get_default_memory_manager();
   if (!gallivm->memorymgr)
      goto fail;

d417 1
a417 2
   gallivm_free_ir(gallivm);
   gallivm_free_code(gallivm);
d422 1
a422 1
boolean
d426 1
a426 1
      return TRUE;
d449 2
a450 1
   if (util_cpu_caps.has_avx &&
d475 10
a516 2

   return TRUE;
d523 1
d526 1
a526 1
gallivm_create(const char *name, LLVMContextRef context)
d530 6
d538 1
a538 1
      if (!init_gallivm_state(gallivm, name, context)) {
d544 4
d558 5
a562 2
   gallivm_free_ir(gallivm);
   gallivm_free_code(gallivm);
d564 27
a595 1
 * Verification is only done with debug builds.
d610 2
a619 4
/**
 * Compile a module.
 * This does IR optimization on all functions in the module.
 */
d623 1
a623 3
   LLVMValueRef func;
   int64_t time_begin;

d625 1
a625 27

   if (gallivm->builder) {
      LLVMDisposeBuilder(gallivm->builder);
      gallivm->builder = NULL;
   }

   if (gallivm_debug & GALLIVM_DEBUG_PERF)
      time_begin = os_time_get();

   /* Run optimization passes */
   LLVMInitializeFunctionPassManager(gallivm->passmgr);
   func = LLVMGetFirstFunction(gallivm->module);
   while (func) {
      if (0) {
         debug_printf("optimizing func %s...\n", LLVMGetValueName(func));
      }
      LLVMRunFunctionPassManager(gallivm->passmgr, func);
      func = LLVMGetNextFunction(func);
   }
   LLVMFinalizeFunctionPassManager(gallivm->passmgr);

   if (gallivm_debug & GALLIVM_DEBUG_PERF) {
      int64_t time_end = os_time_get();
      int time_msec = (int)(time_end - time_begin) / 1000;
      debug_printf("optimizing module %s took %d msec\n",
                   lp_get_module_id(gallivm->module), time_msec);
   }
d669 3
d673 18
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d35 1
d46 2
a47 8
/**
 * AVX is supported in:
 * - standard JIT from LLVM 3.2 onwards
 * - MC-JIT from LLVM 3.1
 *   - MC-JIT supports limited OSes (MacOSX and Linux)
 * - standard JIT in LLVM 3.1, with backports
 */
#if defined(PIPE_ARCH_PPC_64) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_ARM) || defined(PIPE_ARCH_AARCH64)
d49 1
a49 5
#  define HAVE_AVX 0
#elif HAVE_LLVM >= 0x0302 || (HAVE_LLVM == 0x0301 && defined(HAVE_JIT_AVX_SUPPORT))
#  define USE_MCJIT 0
#  define HAVE_AVX 1
#elif HAVE_LLVM == 0x0301 && (defined(PIPE_OS_LINUX) || defined(PIPE_OS_APPLE))
a50 1
#  define HAVE_AVX 1
a52 1
#  define HAVE_AVX 0
a54 1

a58 1

a93 1
#if HAVE_LLVM >= 0x207
a97 5
#else
   Default,
   None,
   Aggressive
#endif
a100 9
#if HAVE_LLVM <= 0x0206
/**
 * LLVM 2.6 permits only one ExecutionEngine to be created.  So use the
 * same gallivm state everywhere.
 */
static struct gallivm_state *GlobalGallivm = NULL;
#endif


d109 1
d113 1
a113 1
   gallivm->passmgr = LLVMCreateFunctionPassManager(gallivm->provider);
d117 1
d120 5
d134 3
a136 21

      if (HAVE_LLVM >= 0x207 && sizeof(void*) == 4) {
         /* For LLVM >= 2.7 and 32-bit build, use this order of passes to
          * avoid generating bad code.
          * Test with piglit glsl-vs-sqrt-zero test.
          */
         LLVMAddConstantPropagationPass(gallivm->passmgr);
         LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
      }
      else {
         LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
         LLVMAddConstantPropagationPass(gallivm->passmgr);
      }

      if (util_cpu_caps.has_sse4_1) {
         /* FIXME: There is a bug in this pass, whereby the combination
          * of fptosi and sitofp (necessary for trunc/floor/ceil/round
          * implementation) somehow becomes invalid code.
          */
         LLVMAddInstructionCombiningPass(gallivm->passmgr);
      }
d151 2
a152 1
 * Free gallivm object's LLVM allocations, but not the gallivm object itself.
d154 2
a155 2
static void
free_gallivm_state(struct gallivm_state *gallivm)
a156 10
#if HAVE_LLVM >= 0x207 /* XXX or 0x208? */
   /* This leads to crashes w/ some versions of LLVM */
   LLVMModuleRef mod;
   char *error;

   if (gallivm->engine && gallivm->provider)
      LLVMRemoveModuleProvider(gallivm->engine, gallivm->provider,
                               &mod, &error);
#endif

d161 1
a161 7
#if 0
   /* XXX this seems to crash with all versions of LLVM */
   if (gallivm->provider)
      LLVMDisposeModuleProvider(gallivm->provider);
#endif

   if (HAVE_LLVM >= 0x207 && gallivm->engine) {
d164 1
a164 1
   } else {
a175 7
   /* Never free the LLVM context.
    */
#if 0
   if (gallivm->context)
      LLVMContextDispose(gallivm->context);
#endif

d179 2
a183 1
   gallivm->provider = NULL;
d190 15
a208 1
      /* We can only create one LLVMExecutionEngine (w/ LLVM 2.6 anyway) */
a219 1
#if HAVE_LLVM >= 0x0301
d221 1
d223 1
a226 4
#else
      ret = LLVMCreateJITCompiler(&gallivm->engine, gallivm->provider,
                                  (unsigned) optlevel, &error);
#endif
a233 2
   LLVMAddModuleProvider(gallivm->engine, gallivm->provider);//new

a268 13
 * Singleton
 *
 * We must never free LLVM contexts, because LLVM has several global caches
 * which pointing/derived from objects owned by the context, causing false
 * memory leaks and false cache hits when these objects are destroyed.
 *
 * TODO: For thread safety on multi-threaded OpenGL we should use one LLVM
 * context per thread, and put them in a pool when threads are destroyed.
 */
static LLVMContextRef gallivm_context = NULL;


/**
d273 2
a274 1
init_gallivm_state(struct gallivm_state *gallivm)
a277 1
   assert(!gallivm->provider);
d279 4
a282 1
   lp_build_init();
a283 4
   if (!gallivm_context) {
      gallivm_context = LLVMContextCreate();
   }
   gallivm->context = gallivm_context;
d287 1
a287 1
   gallivm->module = LLVMModuleCreateWithNameInContext("gallivm",
d292 2
a293 3
   gallivm->provider =
      LLVMCreateModuleProviderForExistingModule(gallivm->module);
   if (!gallivm->provider)
d296 2
a297 2
   gallivm->builder = LLVMCreateBuilderInContext(gallivm->context);
   if (!gallivm->builder)
d351 2
a352 1
   free_gallivm_state(gallivm);
d357 1
a357 1
void
d361 1
a361 1
      return;
d384 1
a384 2
   if (HAVE_AVX &&
       util_cpu_caps.has_avx &&
a408 10
   if (!HAVE_AVX) {
      /*
       * note these instructions are VEX-only, so can only emit if we use
       * avx (don't want to base it on has_avx & has_f16c later as that would
       * omit it unnecessarily on amd cpus, see above).
       */
      util_cpu_caps.has_f16c = 0;
      util_cpu_caps.has_xop = 0;
   }

d441 2
a448 1
 * Note that we return a singleton.
d451 1
a451 1
gallivm_create(void)
a454 6
#if HAVE_LLVM <= 0x206
   if (GlobalGallivm) {
      return GlobalGallivm;
   }
#endif

d457 1
a457 1
      if (!init_gallivm_state(gallivm)) {
a462 4
#if HAVE_LLVM <= 0x206
   GlobalGallivm = gallivm;
#endif

d473 2
a474 5
#if HAVE_LLVM <= 0x0206
   /* No-op: don't destroy the singleton */
   (void) gallivm;
#else
   free_gallivm_state(gallivm);
a475 27
#endif
}


/**
 * Validate and optimze a function.
 */
static void
gallivm_optimize_function(struct gallivm_state *gallivm,
                          LLVMValueRef func)
{
   if (0) {
      debug_printf("optimizing %s...\n", LLVMGetValueName(func));
   }

   assert(gallivm->passmgr);

   /* Apply optimizations to LLVM IR */
   LLVMRunFunctionPassManager(gallivm->passmgr, func);

   if (0) {
      if (gallivm_debug & GALLIVM_DEBUG_IR) {
         /* Print the LLVM IR to stderr */
         lp_debug_dump_value(func);
         debug_printf("\n");
      }
   }
d481 1
a495 2
   gallivm_optimize_function(gallivm, func);

d504 4
d511 3
a513 1
#if HAVE_LLVM > 0x206
d515 27
a541 1
#endif
a584 3
   /* Free the function body to save memory */
   lp_func_delete_body(func);

a585 18
}


/**
 * Free the function (and its machine code).
 */
void
gallivm_free_function(struct gallivm_state *gallivm,
                      LLVMValueRef func,
                      const void *code)
{
#if !USE_MCJIT
   if (code) {
      LLVMFreeMachineCodeForFunction(gallivm->engine, func);
   }

   LLVMDeleteFunction(func);
#endif
@


