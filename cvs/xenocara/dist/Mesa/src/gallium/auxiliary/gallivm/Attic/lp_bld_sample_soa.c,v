head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.26;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.36;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.10.06;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.43;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.19;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.27;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * @@file
 * Texture sampling -- SoA.
 *
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 * @@author Brian Paul <brianp@@vmware.com>
 */

#include "pipe/p_defines.h"
#include "pipe/p_state.h"
#include "pipe/p_shader_tokens.h"
#include "util/u_debug.h"
#include "util/u_dump.h"
#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_format.h"
#include "util/u_cpu_detect.h"
#include "util/u_format_rgb9e5.h"
#include "lp_bld_debug.h"
#include "lp_bld_type.h"
#include "lp_bld_const.h"
#include "lp_bld_conv.h"
#include "lp_bld_arit.h"
#include "lp_bld_bitarit.h"
#include "lp_bld_logic.h"
#include "lp_bld_printf.h"
#include "lp_bld_swizzle.h"
#include "lp_bld_flow.h"
#include "lp_bld_gather.h"
#include "lp_bld_format.h"
#include "lp_bld_sample.h"
#include "lp_bld_sample_aos.h"
#include "lp_bld_struct.h"
#include "lp_bld_quad.h"
#include "lp_bld_pack.h"


/**
 * Generate code to fetch a texel from a texture at int coords (x, y, z).
 * The computation depends on whether the texture is 1D, 2D or 3D.
 * The result, texel, will be float vectors:
 *   texel[0] = red values
 *   texel[1] = green values
 *   texel[2] = blue values
 *   texel[3] = alpha values
 */
static void
lp_build_sample_texel_soa(struct lp_build_sample_context *bld,
                          LLVMValueRef width,
                          LLVMValueRef height,
                          LLVMValueRef depth,
                          LLVMValueRef x,
                          LLVMValueRef y,
                          LLVMValueRef z,
                          LLVMValueRef y_stride,
                          LLVMValueRef z_stride,
                          LLVMValueRef data_ptr,
                          LLVMValueRef mipoffsets,
                          LLVMValueRef texel_out[4])
{
   const struct lp_static_sampler_state *static_state = bld->static_sampler_state;
   const unsigned dims = bld->dims;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef offset;
   LLVMValueRef i, j;
   LLVMValueRef use_border = NULL;

   /* use_border = x < 0 || x >= width || y < 0 || y >= height */
   if (lp_sampler_wrap_mode_uses_border_color(static_state->wrap_s,
                                              static_state->min_img_filter,
                                              static_state->mag_img_filter)) {
      LLVMValueRef b1, b2;
      b1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, x, int_coord_bld->zero);
      b2 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, x, width);
      use_border = LLVMBuildOr(builder, b1, b2, "b1_or_b2");
   }

   if (dims >= 2 &&
       lp_sampler_wrap_mode_uses_border_color(static_state->wrap_t,
                                              static_state->min_img_filter,
                                              static_state->mag_img_filter)) {
      LLVMValueRef b1, b2;
      b1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, y, int_coord_bld->zero);
      b2 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, y, height);
      if (use_border) {
         use_border = LLVMBuildOr(builder, use_border, b1, "ub_or_b1");
         use_border = LLVMBuildOr(builder, use_border, b2, "ub_or_b2");
      }
      else {
         use_border = LLVMBuildOr(builder, b1, b2, "b1_or_b2");
      }
   }

   if (dims == 3 &&
       lp_sampler_wrap_mode_uses_border_color(static_state->wrap_r,
                                              static_state->min_img_filter,
                                              static_state->mag_img_filter)) {
      LLVMValueRef b1, b2;
      b1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, z, int_coord_bld->zero);
      b2 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, z, depth);
      if (use_border) {
         use_border = LLVMBuildOr(builder, use_border, b1, "ub_or_b1");
         use_border = LLVMBuildOr(builder, use_border, b2, "ub_or_b2");
      }
      else {
         use_border = LLVMBuildOr(builder, b1, b2, "b1_or_b2");
      }
   }

   /* convert x,y,z coords to linear offset from start of texture, in bytes */
   lp_build_sample_offset(&bld->int_coord_bld,
                          bld->format_desc,
                          x, y, z, y_stride, z_stride,
                          &offset, &i, &j);
   if (mipoffsets) {
      offset = lp_build_add(&bld->int_coord_bld, offset, mipoffsets);
   }

   if (use_border) {
      /* If we can sample the border color, it means that texcoords may
       * lie outside the bounds of the texture image.  We need to do
       * something to prevent reading out of bounds and causing a segfault.
       *
       * Simply AND the texture coords with !use_border.  This will cause
       * coords which are out of bounds to become zero.  Zero's guaranteed
       * to be inside the texture image.
       */
      offset = lp_build_andnot(&bld->int_coord_bld, offset, use_border);
   }

   lp_build_fetch_rgba_soa(bld->gallivm,
                           bld->format_desc,
                           bld->texel_type,
                           data_ptr, offset,
                           i, j,
                           texel_out);

   /*
    * Note: if we find an app which frequently samples the texture border
    * we might want to implement a true conditional here to avoid sampling
    * the texture whenever possible (since that's quite a bit of code).
    * Ex:
    *   if (use_border) {
    *      texel = border_color;
    *   }
    *   else {
    *      texel = sample_texture(coord);
    *   }
    * As it is now, we always sample the texture, then selectively replace
    * the texel color results with the border color.
    */

   if (use_border) {
      /* select texel color or border color depending on use_border. */
      const struct util_format_description *format_desc = bld->format_desc;
      int chan;
      struct lp_type border_type = bld->texel_type;
      border_type.length = 4;
      /*
       * Only replace channels which are actually present. The others should
       * get optimized away eventually by sampler_view swizzle anyway but it's
       * easier too.
       */
      for (chan = 0; chan < 4; chan++) {
         unsigned chan_s;
         /* reverse-map channel... */
         for (chan_s = 0; chan_s < 4; chan_s++) {
            if (chan_s == format_desc->swizzle[chan]) {
               break;
            }
         }
         if (chan_s <= 3) {
            /* use the already clamped color */
            LLVMValueRef idx = lp_build_const_int32(bld->gallivm, chan);
            LLVMValueRef border_chan;

            border_chan = lp_build_extract_broadcast(bld->gallivm,
                                                     border_type,
                                                     bld->texel_type,
                                                     bld->border_color_clamped,
                                                     idx);
            texel_out[chan] = lp_build_select(&bld->texel_bld, use_border,
                                              border_chan, texel_out[chan]);
         }
      }
   }
}


/**
 * Helper to compute the mirror function for the PIPE_WRAP_MIRROR modes.
 */
static LLVMValueRef
lp_build_coord_mirror(struct lp_build_sample_context *bld,
                      LLVMValueRef coord)
{
   struct lp_build_context *coord_bld = &bld->coord_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMValueRef fract, flr, isOdd;

   lp_build_ifloor_fract(coord_bld, coord, &flr, &fract);

   /* isOdd = flr & 1 */
   isOdd = LLVMBuildAnd(bld->gallivm->builder, flr, int_coord_bld->one, "");

   /* make coord positive or negative depending on isOdd */
   coord = lp_build_set_sign(coord_bld, fract, isOdd);

   /* convert isOdd to float */
   isOdd = lp_build_int_to_float(coord_bld, isOdd);

   /* add isOdd to coord */
   coord = lp_build_add(coord_bld, coord, isOdd);

   return coord;
}


/**
 * Helper to compute the first coord and the weight for
 * linear wrap repeat npot textures
 */
void
lp_build_coord_repeat_npot_linear(struct lp_build_sample_context *bld,
                                  LLVMValueRef coord_f,
                                  LLVMValueRef length_i,
                                  LLVMValueRef length_f,
                                  LLVMValueRef *coord0_i,
                                  LLVMValueRef *weight_f)
{
   struct lp_build_context *coord_bld = &bld->coord_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMValueRef half = lp_build_const_vec(bld->gallivm, coord_bld->type, 0.5);
   LLVMValueRef length_minus_one = lp_build_sub(int_coord_bld, length_i,
                                                int_coord_bld->one);
   LLVMValueRef mask;
   /* wrap with normalized floats is just fract */
   coord_f = lp_build_fract(coord_bld, coord_f);
   /* mul by size and subtract 0.5 */
   coord_f = lp_build_mul(coord_bld, coord_f, length_f);
   coord_f = lp_build_sub(coord_bld, coord_f, half);
   /*
    * we avoided the 0.5/length division before the repeat wrap,
    * now need to fix up edge cases with selects
    */
   /* convert to int, compute lerp weight */
   lp_build_ifloor_fract(coord_bld, coord_f, coord0_i, weight_f);
   mask = lp_build_compare(int_coord_bld->gallivm, int_coord_bld->type,
                           PIPE_FUNC_LESS, *coord0_i, int_coord_bld->zero);
   *coord0_i = lp_build_select(int_coord_bld, mask, length_minus_one, *coord0_i);
}


/**
 * Build LLVM code for texture wrap mode for linear filtering.
 * \param x0_out  returns first integer texcoord
 * \param x1_out  returns second integer texcoord
 * \param weight_out  returns linear interpolation weight
 */
static void
lp_build_sample_wrap_linear(struct lp_build_sample_context *bld,
                            LLVMValueRef coord,
                            LLVMValueRef length,
                            LLVMValueRef length_f,
                            LLVMValueRef offset,
                            boolean is_pot,
                            unsigned wrap_mode,
                            LLVMValueRef *x0_out,
                            LLVMValueRef *x1_out,
                            LLVMValueRef *weight_out)
{
   struct lp_build_context *coord_bld = &bld->coord_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef half = lp_build_const_vec(bld->gallivm, coord_bld->type, 0.5);
   LLVMValueRef length_minus_one = lp_build_sub(int_coord_bld, length, int_coord_bld->one);
   LLVMValueRef coord0, coord1, weight;

   switch(wrap_mode) {
   case PIPE_TEX_WRAP_REPEAT:
      if (is_pot) {
         /* mul by size and subtract 0.5 */
         coord = lp_build_mul(coord_bld, coord, length_f);
         coord = lp_build_sub(coord_bld, coord, half);
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            coord = lp_build_add(coord_bld, coord, offset);
         }
         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
         coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
         /* repeat wrap */
         coord0 = LLVMBuildAnd(builder, coord0, length_minus_one, "");
         coord1 = LLVMBuildAnd(builder, coord1, length_minus_one, "");
      }
      else {
         LLVMValueRef mask;
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            offset = lp_build_div(coord_bld, offset, length_f);
            coord = lp_build_add(coord_bld, coord, offset);
         }
         lp_build_coord_repeat_npot_linear(bld, coord,
                                           length, length_f,
                                           &coord0, &weight);
         mask = lp_build_compare(int_coord_bld->gallivm, int_coord_bld->type,
                                 PIPE_FUNC_NOTEQUAL, coord0, length_minus_one);
         coord1 = LLVMBuildAnd(builder,
                               lp_build_add(int_coord_bld, coord0, int_coord_bld->one),
                               mask, "");
      }
      break;

   case PIPE_TEX_WRAP_CLAMP:
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }

      /* clamp to [0, length] */
      coord = lp_build_clamp(coord_bld, coord, coord_bld->zero, length_f);

      coord = lp_build_sub(coord_bld, coord, half);

      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
      coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
      break;

   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      {
         struct lp_build_context abs_coord_bld = bld->coord_bld;
         abs_coord_bld.type.sign = FALSE;

         if (bld->static_sampler_state->normalized_coords) {
            /* mul by tex size */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            coord = lp_build_add(coord_bld, coord, offset);
         }

         /* clamp to length max */
         coord = lp_build_min(coord_bld, coord, length_f);
         /* subtract 0.5 */
         coord = lp_build_sub(coord_bld, coord, half);
         /* clamp to [0, length - 0.5] */
         coord = lp_build_max(coord_bld, coord, coord_bld->zero);
         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(&abs_coord_bld, coord, &coord0, &weight);
         coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
         /* coord1 = min(coord1, length-1) */
         coord1 = lp_build_min(int_coord_bld, coord1, length_minus_one);
         break;
      }

   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
      /* was: clamp to [-0.5, length + 0.5], then sub 0.5 */
      /* can skip clamp (though might not work for very large coord values */
      coord = lp_build_sub(coord_bld, coord, half);
      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
      coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
      break;

   case PIPE_TEX_WRAP_MIRROR_REPEAT:
      /* compute mirror function */
      coord = lp_build_coord_mirror(bld, coord);

      /* scale coord to length */
      coord = lp_build_mul(coord_bld, coord, length_f);
      coord = lp_build_sub(coord_bld, coord, half);
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }

      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
      coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);

      /* coord0 = max(coord0, 0) */
      coord0 = lp_build_max(int_coord_bld, coord0, int_coord_bld->zero);
      /* coord1 = min(coord1, length-1) */
      coord1 = lp_build_min(int_coord_bld, coord1, length_minus_one);
      break;

   case PIPE_TEX_WRAP_MIRROR_CLAMP:
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
      coord = lp_build_abs(coord_bld, coord);

      /* clamp to [0, length] */
      coord = lp_build_min(coord_bld, coord, length_f);

      coord = lp_build_sub(coord_bld, coord, half);

      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
      coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
      break;

   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
      {
         struct lp_build_context abs_coord_bld = bld->coord_bld;
         abs_coord_bld.type.sign = FALSE;

         if (bld->static_sampler_state->normalized_coords) {
            /* scale coord to length */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            coord = lp_build_add(coord_bld, coord, offset);
         }
         coord = lp_build_abs(coord_bld, coord);

         /* clamp to length max */
         coord = lp_build_min(coord_bld, coord, length_f);
         /* subtract 0.5 */
         coord = lp_build_sub(coord_bld, coord, half);
         /* clamp to [0, length - 0.5] */
         coord = lp_build_max(coord_bld, coord, coord_bld->zero);

         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(&abs_coord_bld, coord, &coord0, &weight);
         coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
         /* coord1 = min(coord1, length-1) */
         coord1 = lp_build_min(int_coord_bld, coord1, length_minus_one);
      }
      break;

   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER:
      {
         if (bld->static_sampler_state->normalized_coords) {
            /* scale coord to length */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            coord = lp_build_add(coord_bld, coord, offset);
         }
         coord = lp_build_abs(coord_bld, coord);

         /* was: clamp to [-0.5, length + 0.5] then sub 0.5 */
         /* skip clamp - always positive, and other side
            only potentially matters for very large coords */
         coord = lp_build_sub(coord_bld, coord, half);

         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
         coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
      }
      break;

   default:
      assert(0);
      coord0 = NULL;
      coord1 = NULL;
      weight = NULL;
   }

   *x0_out = coord0;
   *x1_out = coord1;
   *weight_out = weight;
}


/**
 * Build LLVM code for texture wrap mode for nearest filtering.
 * \param coord  the incoming texcoord (nominally in [0,1])
 * \param length  the texture size along one dimension, as int vector
 * \param length_f  the texture size along one dimension, as float vector
 * \param offset  texel offset along one dimension (as int vector)
 * \param is_pot  if TRUE, length is a power of two
 * \param wrap_mode  one of PIPE_TEX_WRAP_x
 */
static LLVMValueRef
lp_build_sample_wrap_nearest(struct lp_build_sample_context *bld,
                             LLVMValueRef coord,
                             LLVMValueRef length,
                             LLVMValueRef length_f,
                             LLVMValueRef offset,
                             boolean is_pot,
                             unsigned wrap_mode)
{
   struct lp_build_context *coord_bld = &bld->coord_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef length_minus_one = lp_build_sub(int_coord_bld, length, int_coord_bld->one);
   LLVMValueRef icoord;
   
   switch(wrap_mode) {
   case PIPE_TEX_WRAP_REPEAT:
      if (is_pot) {
         coord = lp_build_mul(coord_bld, coord, length_f);
         icoord = lp_build_ifloor(coord_bld, coord);
         if (offset) {
            icoord = lp_build_add(int_coord_bld, icoord, offset);
         }
         icoord = LLVMBuildAnd(builder, icoord, length_minus_one, "");
      }
      else {
          if (offset) {
             offset = lp_build_int_to_float(coord_bld, offset);
             offset = lp_build_div(coord_bld, offset, length_f);
             coord = lp_build_add(coord_bld, coord, offset);
          }
          /* take fraction, unnormalize */
          coord = lp_build_fract_safe(coord_bld, coord);
          coord = lp_build_mul(coord_bld, coord, length_f);
          icoord = lp_build_itrunc(coord_bld, coord);
      }
      break;

   case PIPE_TEX_WRAP_CLAMP:
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }

      /* floor */
      /* use itrunc instead since we clamp to 0 anyway */
      icoord = lp_build_itrunc(coord_bld, coord);
      if (offset) {
         icoord = lp_build_add(int_coord_bld, icoord, offset);
      }

      /* clamp to [0, length - 1]. */
      icoord = lp_build_clamp(int_coord_bld, icoord, int_coord_bld->zero,
                              length_minus_one);
      break;

   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }
      /* no clamp necessary, border masking will handle this */
      icoord = lp_build_ifloor(coord_bld, coord);
      if (offset) {
         icoord = lp_build_add(int_coord_bld, icoord, offset);
      }
      break;

   case PIPE_TEX_WRAP_MIRROR_REPEAT:
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         offset = lp_build_div(coord_bld, offset, length_f);
         coord = lp_build_add(coord_bld, coord, offset);
      }
      /* compute mirror function */
      coord = lp_build_coord_mirror(bld, coord);

      /* scale coord to length */
      assert(bld->static_sampler_state->normalized_coords);
      coord = lp_build_mul(coord_bld, coord, length_f);

      /* itrunc == ifloor here */
      icoord = lp_build_itrunc(coord_bld, coord);

      /* clamp to [0, length - 1] */
      icoord = lp_build_min(int_coord_bld, icoord, length_minus_one);
      break;

   case PIPE_TEX_WRAP_MIRROR_CLAMP:
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
      coord = lp_build_abs(coord_bld, coord);

      /* itrunc == ifloor here */
      icoord = lp_build_itrunc(coord_bld, coord);

      /* clamp to [0, length - 1] */
      icoord = lp_build_min(int_coord_bld, icoord, length_minus_one);
      break;

   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER:
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
      coord = lp_build_abs(coord_bld, coord);

      /* itrunc == ifloor here */
      icoord = lp_build_itrunc(coord_bld, coord);
      break;

   default:
      assert(0);
      icoord = NULL;
   }

   return icoord;
}


/**
 * Do shadow test/comparison.
 * \param p shadow ref value
 * \param texel  the texel to compare against
 */
static LLVMValueRef
lp_build_sample_comparefunc(struct lp_build_sample_context *bld,
                            LLVMValueRef p,
                            LLVMValueRef texel)
{
   struct lp_build_context *texel_bld = &bld->texel_bld;
   LLVMValueRef res;

   if (0) {
      //lp_build_print_value(bld->gallivm, "shadow cmp coord", p);
      lp_build_print_value(bld->gallivm, "shadow cmp texel", texel);
   }

   /* result = (p FUNC texel) ? 1 : 0 */
   /*
    * honor d3d10 floating point rules here, which state that comparisons
    * are ordered except NOT_EQUAL which is unordered.
    */
   if (bld->static_sampler_state->compare_func != PIPE_FUNC_NOTEQUAL) {
      res = lp_build_cmp_ordered(texel_bld, bld->static_sampler_state->compare_func,
                                 p, texel);
   }
   else {
      res = lp_build_cmp(texel_bld, bld->static_sampler_state->compare_func,
                         p, texel);
   }
   return res;
}


/**
 * Generate code to sample a mipmap level with nearest filtering.
 * If sampling a cube texture, r = cube face in [0,5].
 */
static void
lp_build_sample_image_nearest(struct lp_build_sample_context *bld,
                              LLVMValueRef size,
                              LLVMValueRef row_stride_vec,
                              LLVMValueRef img_stride_vec,
                              LLVMValueRef data_ptr,
                              LLVMValueRef mipoffsets,
                              LLVMValueRef *coords,
                              const LLVMValueRef *offsets,
                              LLVMValueRef colors_out[4])
{
   const unsigned dims = bld->dims;
   LLVMValueRef width_vec;
   LLVMValueRef height_vec;
   LLVMValueRef depth_vec;
   LLVMValueRef flt_size;
   LLVMValueRef flt_width_vec;
   LLVMValueRef flt_height_vec;
   LLVMValueRef flt_depth_vec;
   LLVMValueRef x, y = NULL, z = NULL;

   lp_build_extract_image_sizes(bld,
                                &bld->int_size_bld,
                                bld->int_coord_type,
                                size,
                                &width_vec, &height_vec, &depth_vec);

   flt_size = lp_build_int_to_float(&bld->float_size_bld, size);

   lp_build_extract_image_sizes(bld,
                                &bld->float_size_bld,
                                bld->coord_type,
                                flt_size,
                                &flt_width_vec, &flt_height_vec, &flt_depth_vec);

   /*
    * Compute integer texcoords.
    */
   x = lp_build_sample_wrap_nearest(bld, coords[0], width_vec,
                                    flt_width_vec, offsets[0],
                                    bld->static_texture_state->pot_width,
                                    bld->static_sampler_state->wrap_s);
   lp_build_name(x, "tex.x.wrapped");

   if (dims >= 2) {
      y = lp_build_sample_wrap_nearest(bld, coords[1], height_vec,
                                       flt_height_vec, offsets[1],
                                       bld->static_texture_state->pot_height,
                                       bld->static_sampler_state->wrap_t);
      lp_build_name(y, "tex.y.wrapped");

      if (dims == 3) {
         z = lp_build_sample_wrap_nearest(bld, coords[2], depth_vec,
                                          flt_depth_vec, offsets[2],
                                          bld->static_texture_state->pot_depth,
                                          bld->static_sampler_state->wrap_r);
         lp_build_name(z, "tex.z.wrapped");
      }
   }
   if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
       bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
       bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
      z = coords[2];
      lp_build_name(z, "tex.z.layer");
   }

   /*
    * Get texture colors.
    */
   lp_build_sample_texel_soa(bld,
                             width_vec, height_vec, depth_vec,
                             x, y, z,
                             row_stride_vec, img_stride_vec,
                             data_ptr, mipoffsets, colors_out);

   if (bld->static_sampler_state->compare_mode != PIPE_TEX_COMPARE_NONE) {
      LLVMValueRef cmpval;
      cmpval = lp_build_sample_comparefunc(bld, coords[4], colors_out[0]);
      /* this is really just a AND 1.0, cmpval but llvm is clever enough */
      colors_out[0] = lp_build_select(&bld->texel_bld, cmpval,
                                      bld->texel_bld.one, bld->texel_bld.zero);
      colors_out[1] = colors_out[2] = colors_out[3] = colors_out[0];
   }

}


/**
 * Like a lerp, but inputs are 0/~0 masks, so can simplify slightly.
 */
static LLVMValueRef
lp_build_masklerp(struct lp_build_context *bld,
                 LLVMValueRef weight,
                 LLVMValueRef mask0,
                 LLVMValueRef mask1)
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef weight2;

   weight2 = lp_build_sub(bld, bld->one, weight);
   weight = LLVMBuildBitCast(builder, weight,
                              lp_build_int_vec_type(gallivm, bld->type), "");
   weight2 = LLVMBuildBitCast(builder, weight2,
                              lp_build_int_vec_type(gallivm, bld->type), "");
   weight = LLVMBuildAnd(builder, weight, mask1, "");
   weight2 = LLVMBuildAnd(builder, weight2, mask0, "");
   weight = LLVMBuildBitCast(builder, weight, bld->vec_type, "");
   weight2 = LLVMBuildBitCast(builder, weight2, bld->vec_type, "");
   return lp_build_add(bld, weight, weight2);
}

/**
 * Like a 2d lerp, but inputs are 0/~0 masks, so can simplify slightly.
 */
static LLVMValueRef
lp_build_masklerp2d(struct lp_build_context *bld,
                    LLVMValueRef weight0,
                    LLVMValueRef weight1,
                    LLVMValueRef mask00,
                    LLVMValueRef mask01,
                    LLVMValueRef mask10,
                    LLVMValueRef mask11)
{
   LLVMValueRef val0 = lp_build_masklerp(bld, weight0, mask00, mask01);
   LLVMValueRef val1 = lp_build_masklerp(bld, weight0, mask10, mask11);
   return lp_build_lerp(bld, weight1, val0, val1, 0);
}

/*
 * this is a bit excessive code for something OpenGL just recommends
 * but does not require.
 */
#define ACCURATE_CUBE_CORNERS 1

/**
 * Generate code to sample a mipmap level with linear filtering.
 * If sampling a cube texture, r = cube face in [0,5].
 * If linear_mask is present, only pixels having their mask set
 * will receive linear filtering, the rest will use nearest.
 */
static void
lp_build_sample_image_linear(struct lp_build_sample_context *bld,
                             LLVMValueRef size,
                             LLVMValueRef linear_mask,
                             LLVMValueRef row_stride_vec,
                             LLVMValueRef img_stride_vec,
                             LLVMValueRef data_ptr,
                             LLVMValueRef mipoffsets,
                             LLVMValueRef *coords,
                             const LLVMValueRef *offsets,
                             LLVMValueRef colors_out[4])
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   struct lp_build_context *ivec_bld = &bld->int_coord_bld;
   struct lp_build_context *coord_bld = &bld->coord_bld;
   const unsigned dims = bld->dims;
   LLVMValueRef width_vec;
   LLVMValueRef height_vec;
   LLVMValueRef depth_vec;
   LLVMValueRef flt_size;
   LLVMValueRef flt_width_vec;
   LLVMValueRef flt_height_vec;
   LLVMValueRef flt_depth_vec;
   LLVMValueRef fall_off[4], have_corners;
   LLVMValueRef z1 = NULL;
   LLVMValueRef z00 = NULL, z01 = NULL, z10 = NULL, z11 = NULL;
   LLVMValueRef x00 = NULL, x01 = NULL, x10 = NULL, x11 = NULL;
   LLVMValueRef y00 = NULL, y01 = NULL, y10 = NULL, y11 = NULL;
   LLVMValueRef s_fpart, t_fpart = NULL, r_fpart = NULL;
   LLVMValueRef xs[4], ys[4], zs[4];
   LLVMValueRef neighbors[2][2][4];
   int chan, texel_index;
   boolean seamless_cube_filter, accurate_cube_corners;

   seamless_cube_filter = bld->static_texture_state->target == PIPE_TEXTURE_CUBE &&
                          bld->static_sampler_state->seamless_cube_map;
   accurate_cube_corners = ACCURATE_CUBE_CORNERS && seamless_cube_filter;

   lp_build_extract_image_sizes(bld,
                                &bld->int_size_bld,
                                bld->int_coord_type,
                                size,
                                &width_vec, &height_vec, &depth_vec);

   flt_size = lp_build_int_to_float(&bld->float_size_bld, size);

   lp_build_extract_image_sizes(bld,
                                &bld->float_size_bld,
                                bld->coord_type,
                                flt_size,
                                &flt_width_vec, &flt_height_vec, &flt_depth_vec);

   /*
    * Compute integer texcoords.
    */

   if (!seamless_cube_filter) {
      lp_build_sample_wrap_linear(bld, coords[0], width_vec,
                                  flt_width_vec, offsets[0],
                                  bld->static_texture_state->pot_width,
                                  bld->static_sampler_state->wrap_s,
                                  &x00, &x01, &s_fpart);
      lp_build_name(x00, "tex.x0.wrapped");
      lp_build_name(x01, "tex.x1.wrapped");
      x10 = x00;
      x11 = x01;

      if (dims >= 2) {
         lp_build_sample_wrap_linear(bld, coords[1], height_vec,
                                     flt_height_vec, offsets[1],
                                     bld->static_texture_state->pot_height,
                                     bld->static_sampler_state->wrap_t,
                                     &y00, &y10, &t_fpart);
         lp_build_name(y00, "tex.y0.wrapped");
         lp_build_name(y10, "tex.y1.wrapped");
         y01 = y00;
         y11 = y10;

         if (dims == 3) {
            lp_build_sample_wrap_linear(bld, coords[2], depth_vec,
                                        flt_depth_vec, offsets[2],
                                        bld->static_texture_state->pot_depth,
                                        bld->static_sampler_state->wrap_r,
                                        &z00, &z1, &r_fpart);
            z01 = z10 = z11 = z00;
            lp_build_name(z00, "tex.z0.wrapped");
            lp_build_name(z1, "tex.z1.wrapped");
         }
      }
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
          bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
          bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
         z00 = z01 = z10 = z11 = z1 = coords[2];  /* cube face or layer */
         lp_build_name(z00, "tex.z0.layer");
         lp_build_name(z1, "tex.z1.layer");
      }
   }
   else {
      struct lp_build_if_state edge_if;
      LLVMTypeRef int1t;
      LLVMValueRef new_faces[4], new_xcoords[4][2], new_ycoords[4][2];
      LLVMValueRef coord, have_edge, have_corner;
      LLVMValueRef fall_off_ym_notxm, fall_off_ym_notxp, fall_off_x, fall_off_y;
      LLVMValueRef fall_off_yp_notxm, fall_off_yp_notxp;
      LLVMValueRef x0, x1, y0, y1, y0_clamped, y1_clamped;
      LLVMValueRef face = coords[2];
      LLVMValueRef half = lp_build_const_vec(bld->gallivm, coord_bld->type, 0.5f);
      LLVMValueRef length_minus_one = lp_build_sub(ivec_bld, width_vec, ivec_bld->one);
      /* XXX drop height calcs. Could (should) do this without seamless filtering too */
      height_vec = width_vec;
      flt_height_vec = flt_width_vec;

      /* XXX the overflow logic is actually sort of duplicated with trilinear,
       * since an overflow in one mip should also have a corresponding overflow
       * in another.
       */
      /* should always have normalized coords, and offsets are undefined */
      assert(bld->static_sampler_state->normalized_coords);
      coord = lp_build_mul(coord_bld, coords[0], flt_width_vec);
      /* instead of clamp, build mask if overflowed */
      coord = lp_build_sub(coord_bld, coord, half);
      /* convert to int, compute lerp weight */
      /* not ideal with AVX (and no AVX2) */
      lp_build_ifloor_fract(coord_bld, coord, &x0, &s_fpart);
      x1 = lp_build_add(ivec_bld, x0, ivec_bld->one);
      coord = lp_build_mul(coord_bld, coords[1], flt_height_vec);
      coord = lp_build_sub(coord_bld, coord, half);
      lp_build_ifloor_fract(coord_bld, coord, &y0, &t_fpart);
      y1 = lp_build_add(ivec_bld, y0, ivec_bld->one);

      fall_off[0] = lp_build_cmp(ivec_bld, PIPE_FUNC_LESS, x0, ivec_bld->zero);
      fall_off[1] = lp_build_cmp(ivec_bld, PIPE_FUNC_GREATER, x1, length_minus_one);
      fall_off[2] = lp_build_cmp(ivec_bld, PIPE_FUNC_LESS, y0, ivec_bld->zero);
      fall_off[3] = lp_build_cmp(ivec_bld, PIPE_FUNC_GREATER, y1, length_minus_one);

      fall_off_x = lp_build_or(ivec_bld, fall_off[0], fall_off[1]);
      fall_off_y = lp_build_or(ivec_bld, fall_off[2], fall_off[3]);
      have_edge = lp_build_or(ivec_bld, fall_off_x, fall_off_y);
      have_edge = lp_build_any_true_range(ivec_bld, ivec_bld->type.length, have_edge);

      /* needed for accurate corner filtering branch later, rely on 0 init */
      int1t = LLVMInt1TypeInContext(bld->gallivm->context);
      have_corners = lp_build_alloca(bld->gallivm, int1t, "have_corner");

      for (texel_index = 0; texel_index < 4; texel_index++) {
         xs[texel_index] = lp_build_alloca(bld->gallivm, ivec_bld->vec_type, "xs");
         ys[texel_index] = lp_build_alloca(bld->gallivm, ivec_bld->vec_type, "ys");
         zs[texel_index] = lp_build_alloca(bld->gallivm, ivec_bld->vec_type, "zs");
      }

      lp_build_if(&edge_if, bld->gallivm, have_edge);

      have_corner = lp_build_and(ivec_bld, fall_off_x, fall_off_y);
      have_corner = lp_build_any_true_range(ivec_bld, ivec_bld->type.length, have_corner);
      LLVMBuildStore(builder, have_corner, have_corners);

      /*
       * Need to feed clamped values here for cheap corner handling,
       * but only for y coord (as when falling off both edges we only
       * fall off the x one) - this should be sufficient.
       */
      y0_clamped = lp_build_max(ivec_bld, y0, ivec_bld->zero);
      y1_clamped = lp_build_min(ivec_bld, y1, length_minus_one);

      /*
       * Get all possible new coords.
       */
      lp_build_cube_new_coords(ivec_bld, face,
                               x0, x1, y0_clamped, y1_clamped,
                               length_minus_one,
                               new_faces, new_xcoords, new_ycoords);

      /* handle fall off x-, x+ direction */
      /* determine new coords, face (not both fall_off vars can be true at same time) */
      x00 = lp_build_select(ivec_bld, fall_off[0], new_xcoords[0][0], x0);
      y00 = lp_build_select(ivec_bld, fall_off[0], new_ycoords[0][0], y0_clamped);
      x10 = lp_build_select(ivec_bld, fall_off[0], new_xcoords[0][1], x0);
      y10 = lp_build_select(ivec_bld, fall_off[0], new_ycoords[0][1], y1_clamped);
      x01 = lp_build_select(ivec_bld, fall_off[1], new_xcoords[1][0], x1);
      y01 = lp_build_select(ivec_bld, fall_off[1], new_ycoords[1][0], y0_clamped);
      x11 = lp_build_select(ivec_bld, fall_off[1], new_xcoords[1][1], x1);
      y11 = lp_build_select(ivec_bld, fall_off[1], new_ycoords[1][1], y1_clamped);

      z00 = z10 = lp_build_select(ivec_bld, fall_off[0], new_faces[0], face);
      z01 = z11 = lp_build_select(ivec_bld, fall_off[1], new_faces[1], face);

      /* handle fall off y-, y+ direction */
      /*
       * Cheap corner logic: just hack up things so a texel doesn't fall
       * off both sides (which means filter weights will be wrong but we'll only
       * use valid texels in the filter).
       * This means however (y) coords must additionally be clamped (see above).
       * This corner handling should be fully OpenGL (but not d3d10) compliant.
       */
      fall_off_ym_notxm = lp_build_andnot(ivec_bld, fall_off[2], fall_off[0]);
      fall_off_ym_notxp = lp_build_andnot(ivec_bld, fall_off[2], fall_off[1]);
      fall_off_yp_notxm = lp_build_andnot(ivec_bld, fall_off[3], fall_off[0]);
      fall_off_yp_notxp = lp_build_andnot(ivec_bld, fall_off[3], fall_off[1]);

      x00 = lp_build_select(ivec_bld, fall_off_ym_notxm, new_xcoords[2][0], x00);
      y00 = lp_build_select(ivec_bld, fall_off_ym_notxm, new_ycoords[2][0], y00);
      x01 = lp_build_select(ivec_bld, fall_off_ym_notxp, new_xcoords[2][1], x01);
      y01 = lp_build_select(ivec_bld, fall_off_ym_notxp, new_ycoords[2][1], y01);
      x10 = lp_build_select(ivec_bld, fall_off_yp_notxm, new_xcoords[3][0], x10);
      y10 = lp_build_select(ivec_bld, fall_off_yp_notxm, new_ycoords[3][0], y10);
      x11 = lp_build_select(ivec_bld, fall_off_yp_notxp, new_xcoords[3][1], x11);
      y11 = lp_build_select(ivec_bld, fall_off_yp_notxp, new_ycoords[3][1], y11);

      z00 = lp_build_select(ivec_bld, fall_off_ym_notxm, new_faces[2], z00);
      z01 = lp_build_select(ivec_bld, fall_off_ym_notxp, new_faces[2], z01);
      z10 = lp_build_select(ivec_bld, fall_off_yp_notxm, new_faces[3], z10);
      z11 = lp_build_select(ivec_bld, fall_off_yp_notxp, new_faces[3], z11);

      LLVMBuildStore(builder, x00, xs[0]);
      LLVMBuildStore(builder, x01, xs[1]);
      LLVMBuildStore(builder, x10, xs[2]);
      LLVMBuildStore(builder, x11, xs[3]);
      LLVMBuildStore(builder, y00, ys[0]);
      LLVMBuildStore(builder, y01, ys[1]);
      LLVMBuildStore(builder, y10, ys[2]);
      LLVMBuildStore(builder, y11, ys[3]);
      LLVMBuildStore(builder, z00, zs[0]);
      LLVMBuildStore(builder, z01, zs[1]);
      LLVMBuildStore(builder, z10, zs[2]);
      LLVMBuildStore(builder, z11, zs[3]);

      lp_build_else(&edge_if);

      LLVMBuildStore(builder, x0, xs[0]);
      LLVMBuildStore(builder, x1, xs[1]);
      LLVMBuildStore(builder, x0, xs[2]);
      LLVMBuildStore(builder, x1, xs[3]);
      LLVMBuildStore(builder, y0, ys[0]);
      LLVMBuildStore(builder, y0, ys[1]);
      LLVMBuildStore(builder, y1, ys[2]);
      LLVMBuildStore(builder, y1, ys[3]);
      LLVMBuildStore(builder, face, zs[0]);
      LLVMBuildStore(builder, face, zs[1]);
      LLVMBuildStore(builder, face, zs[2]);
      LLVMBuildStore(builder, face, zs[3]);

      lp_build_endif(&edge_if);

      x00 = LLVMBuildLoad(builder, xs[0], "");
      x01 = LLVMBuildLoad(builder, xs[1], "");
      x10 = LLVMBuildLoad(builder, xs[2], "");
      x11 = LLVMBuildLoad(builder, xs[3], "");
      y00 = LLVMBuildLoad(builder, ys[0], "");
      y01 = LLVMBuildLoad(builder, ys[1], "");
      y10 = LLVMBuildLoad(builder, ys[2], "");
      y11 = LLVMBuildLoad(builder, ys[3], "");
      z00 = LLVMBuildLoad(builder, zs[0], "");
      z01 = LLVMBuildLoad(builder, zs[1], "");
      z10 = LLVMBuildLoad(builder, zs[2], "");
      z11 = LLVMBuildLoad(builder, zs[3], "");
   }

   if (linear_mask) {
      /*
       * Whack filter weights into place. Whatever texel had more weight is
       * the one which should have been selected by nearest filtering hence
       * just use 100% weight for it.
       */
      struct lp_build_context *c_bld = &bld->coord_bld;
      LLVMValueRef w1_mask, w1_weight;
      LLVMValueRef half = lp_build_const_vec(bld->gallivm, c_bld->type, 0.5f);

      w1_mask = lp_build_cmp(c_bld, PIPE_FUNC_GREATER, s_fpart, half);
      /* this select is really just a "and" */
      w1_weight = lp_build_select(c_bld, w1_mask, c_bld->one, c_bld->zero);
      s_fpart = lp_build_select(c_bld, linear_mask, s_fpart, w1_weight);
      if (dims >= 2) {
         w1_mask = lp_build_cmp(c_bld, PIPE_FUNC_GREATER, t_fpart, half);
         w1_weight = lp_build_select(c_bld, w1_mask, c_bld->one, c_bld->zero);
         t_fpart = lp_build_select(c_bld, linear_mask, t_fpart, w1_weight);
         if (dims == 3) {
            w1_mask = lp_build_cmp(c_bld, PIPE_FUNC_GREATER, r_fpart, half);
            w1_weight = lp_build_select(c_bld, w1_mask, c_bld->one, c_bld->zero);
            r_fpart = lp_build_select(c_bld, linear_mask, r_fpart, w1_weight);
         }
      }
   }

   /*
    * Get texture colors.
    */
   /* get x0/x1 texels */
   lp_build_sample_texel_soa(bld,
                             width_vec, height_vec, depth_vec,
                             x00, y00, z00,
                             row_stride_vec, img_stride_vec,
                             data_ptr, mipoffsets, neighbors[0][0]);
   lp_build_sample_texel_soa(bld,
                             width_vec, height_vec, depth_vec,
                             x01, y01, z01,
                             row_stride_vec, img_stride_vec,
                             data_ptr, mipoffsets, neighbors[0][1]);

   if (dims == 1) {
      if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE) {
         /* Interpolate two samples from 1D image to produce one color */
         for (chan = 0; chan < 4; chan++) {
            colors_out[chan] = lp_build_lerp(&bld->texel_bld, s_fpart,
                                             neighbors[0][0][chan],
                                             neighbors[0][1][chan],
                                             0);
         }
      }
      else {
         LLVMValueRef cmpval0, cmpval1;
         cmpval0 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][0][0]);
         cmpval1 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][1][0]);
         /* simplified lerp, AND mask with weight and add */
         colors_out[0] = lp_build_masklerp(&bld->texel_bld, s_fpart,
                                           cmpval0, cmpval1);
         colors_out[1] = colors_out[2] = colors_out[3] = colors_out[0];
      }
   }
   else {
      /* 2D/3D texture */
      struct lp_build_if_state corner_if;
      LLVMValueRef colors0[4], colorss[4];

      /* get x0/x1 texels at y1 */
      lp_build_sample_texel_soa(bld,
                                width_vec, height_vec, depth_vec,
                                x10, y10, z10,
                                row_stride_vec, img_stride_vec,
                                data_ptr, mipoffsets, neighbors[1][0]);
      lp_build_sample_texel_soa(bld,
                                width_vec, height_vec, depth_vec,
                                x11, y11, z11,
                                row_stride_vec, img_stride_vec,
                                data_ptr, mipoffsets, neighbors[1][1]);

      /*
       * To avoid having to duplicate linear_mask / fetch code use
       * another branch (with corner condition though edge would work
       * as well) here.
       */
      if (accurate_cube_corners) {
         LLVMValueRef w00, w01, w10, w11, wx0, wy0;
         LLVMValueRef c_weight, c00, c01, c10, c11;
         LLVMValueRef have_corner, one_third, tmp;

         colorss[0] = lp_build_alloca(bld->gallivm, coord_bld->vec_type, "cs");
         colorss[1] = lp_build_alloca(bld->gallivm, coord_bld->vec_type, "cs");
         colorss[2] = lp_build_alloca(bld->gallivm, coord_bld->vec_type, "cs");
         colorss[3] = lp_build_alloca(bld->gallivm, coord_bld->vec_type, "cs");

         have_corner = LLVMBuildLoad(builder, have_corners, "");

         lp_build_if(&corner_if, bld->gallivm, have_corner);

         /*
          * we can't use standard 2d lerp as we need per-element weight
          * in case of corners, so just calculate bilinear result as
          * w00*s00 + w01*s01 + w10*s10 + w11*s11.
          * (This is actually less work than using 2d lerp, 7 vs. 9 instructions,
          * however calculating the weights needs another 6, so actually probably
          * not slower than 2d lerp only for 4 channels as weights only need
          * to be calculated once - of course fixing the weights has additional cost.)
          */
         wx0 = lp_build_sub(coord_bld, coord_bld->one, s_fpart);
         wy0 = lp_build_sub(coord_bld, coord_bld->one, t_fpart);
         w00 = lp_build_mul(coord_bld, wx0, wy0);
         w01 = lp_build_mul(coord_bld, s_fpart, wy0);
         w10 = lp_build_mul(coord_bld, wx0, t_fpart);
         w11 = lp_build_mul(coord_bld, s_fpart, t_fpart);

         /* find corner weight */
         c00 = lp_build_and(ivec_bld, fall_off[0], fall_off[2]);
         c_weight = lp_build_select(coord_bld, c00, w00, coord_bld->zero);
         c01 = lp_build_and(ivec_bld, fall_off[1], fall_off[2]);
         c_weight = lp_build_select(coord_bld, c01, w01, c_weight);
         c10 = lp_build_and(ivec_bld, fall_off[0], fall_off[3]);
         c_weight = lp_build_select(coord_bld, c10, w10, c_weight);
         c11 = lp_build_and(ivec_bld, fall_off[1], fall_off[3]);
         c_weight = lp_build_select(coord_bld, c11, w11, c_weight);

         /*
          * add 1/3 of the corner weight to each of the 3 other samples
          * and null out corner weight
          */
         one_third = lp_build_const_vec(bld->gallivm, coord_bld->type, 1.0f/3.0f);
         c_weight = lp_build_mul(coord_bld, c_weight, one_third);
         w00 = lp_build_add(coord_bld, w00, c_weight);
         c00 = LLVMBuildBitCast(builder, c00, coord_bld->vec_type, "");
         w00 = lp_build_andnot(coord_bld, w00, c00);
         w01 = lp_build_add(coord_bld, w01, c_weight);
         c01 = LLVMBuildBitCast(builder, c01, coord_bld->vec_type, "");
         w01 = lp_build_andnot(coord_bld, w01, c01);
         w10 = lp_build_add(coord_bld, w10, c_weight);
         c10 = LLVMBuildBitCast(builder, c10, coord_bld->vec_type, "");
         w10 = lp_build_andnot(coord_bld, w10, c10);
         w11 = lp_build_add(coord_bld, w11, c_weight);
         c11 = LLVMBuildBitCast(builder, c11, coord_bld->vec_type, "");
         w11 = lp_build_andnot(coord_bld, w11, c11);

         if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE) {
            for (chan = 0; chan < 4; chan++) {
               colors0[chan] = lp_build_mul(coord_bld, w00, neighbors[0][0][chan]);
               tmp = lp_build_mul(coord_bld, w01, neighbors[0][1][chan]);
               colors0[chan] = lp_build_add(coord_bld, tmp, colors0[chan]);
               tmp = lp_build_mul(coord_bld, w10, neighbors[1][0][chan]);
               colors0[chan] = lp_build_add(coord_bld, tmp, colors0[chan]);
               tmp = lp_build_mul(coord_bld, w11, neighbors[1][1][chan]);
               colors0[chan] = lp_build_add(coord_bld, tmp, colors0[chan]);
            }
         }
         else {
            LLVMValueRef cmpval00, cmpval01, cmpval10, cmpval11;
            cmpval00 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][0][0]);
            cmpval01 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][1][0]);
            cmpval10 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][0][0]);
            cmpval11 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][1][0]);
            /* inputs to interpolation are just masks so just add masked weights together */
            cmpval00 = LLVMBuildBitCast(builder, cmpval00, coord_bld->vec_type, "");
            cmpval01 = LLVMBuildBitCast(builder, cmpval01, coord_bld->vec_type, "");
            cmpval10 = LLVMBuildBitCast(builder, cmpval10, coord_bld->vec_type, "");
            cmpval11 = LLVMBuildBitCast(builder, cmpval11, coord_bld->vec_type, "");
            colors0[0] = lp_build_and(coord_bld, w00, cmpval00);
            tmp = lp_build_and(coord_bld, w01, cmpval01);
            colors0[0] = lp_build_add(coord_bld, tmp, colors0[0]);
            tmp = lp_build_and(coord_bld, w10, cmpval10);
            colors0[0] = lp_build_add(coord_bld, tmp, colors0[0]);
            tmp = lp_build_and(coord_bld, w11, cmpval11);
            colors0[0] = lp_build_add(coord_bld, tmp, colors0[0]);
            colors0[1] = colors0[2] = colors0[3] = colors0[0];
         }

         LLVMBuildStore(builder, colors0[0], colorss[0]);
         LLVMBuildStore(builder, colors0[1], colorss[1]);
         LLVMBuildStore(builder, colors0[2], colorss[2]);
         LLVMBuildStore(builder, colors0[3], colorss[3]);

         lp_build_else(&corner_if);
      }

      if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE) {
         /* Bilinear interpolate the four samples from the 2D image / 3D slice */
         for (chan = 0; chan < 4; chan++) {
            colors0[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                             s_fpart, t_fpart,
                                             neighbors[0][0][chan],
                                             neighbors[0][1][chan],
                                             neighbors[1][0][chan],
                                             neighbors[1][1][chan],
                                             0);
         }
      }
      else {
         LLVMValueRef cmpval00, cmpval01, cmpval10, cmpval11;
         cmpval00 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][0][0]);
         cmpval01 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][1][0]);
         cmpval10 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][0][0]);
         cmpval11 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][1][0]);
         colors0[0] = lp_build_masklerp2d(&bld->texel_bld, s_fpart, t_fpart,
                                          cmpval00, cmpval01, cmpval10, cmpval11);
         colors0[1] = colors0[2] = colors0[3] = colors0[0];
      }

      if (accurate_cube_corners) {
         LLVMBuildStore(builder, colors0[0], colorss[0]);
         LLVMBuildStore(builder, colors0[1], colorss[1]);
         LLVMBuildStore(builder, colors0[2], colorss[2]);
         LLVMBuildStore(builder, colors0[3], colorss[3]);

         lp_build_endif(&corner_if);

         colors0[0] = LLVMBuildLoad(builder, colorss[0], "");
         colors0[1] = LLVMBuildLoad(builder, colorss[1], "");
         colors0[2] = LLVMBuildLoad(builder, colorss[2], "");
         colors0[3] = LLVMBuildLoad(builder, colorss[3], "");
      }

      if (dims == 3) {
         LLVMValueRef neighbors1[2][2][4];
         LLVMValueRef colors1[4];

         /* get x0/x1/y0/y1 texels at z1 */
         lp_build_sample_texel_soa(bld,
                                   width_vec, height_vec, depth_vec,
                                   x00, y00, z1,
                                   row_stride_vec, img_stride_vec,
                                   data_ptr, mipoffsets, neighbors1[0][0]);
         lp_build_sample_texel_soa(bld,
                                   width_vec, height_vec, depth_vec,
                                   x01, y01, z1,
                                   row_stride_vec, img_stride_vec,
                                   data_ptr, mipoffsets, neighbors1[0][1]);
         lp_build_sample_texel_soa(bld,
                                   width_vec, height_vec, depth_vec,
                                   x10, y10, z1,
                                   row_stride_vec, img_stride_vec,
                                   data_ptr, mipoffsets, neighbors1[1][0]);
         lp_build_sample_texel_soa(bld,
                                   width_vec, height_vec, depth_vec,
                                   x11, y11, z1,
                                   row_stride_vec, img_stride_vec,
                                   data_ptr, mipoffsets, neighbors1[1][1]);

         if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE) {
            /* Bilinear interpolate the four samples from the second Z slice */
            for (chan = 0; chan < 4; chan++) {
               colors1[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                                s_fpart, t_fpart,
                                                neighbors1[0][0][chan],
                                                neighbors1[0][1][chan],
                                                neighbors1[1][0][chan],
                                                neighbors1[1][1][chan],
                                                0);
            }
            /* Linearly interpolate the two samples from the two 3D slices */
            for (chan = 0; chan < 4; chan++) {
               colors_out[chan] = lp_build_lerp(&bld->texel_bld,
                                                r_fpart,
                                                colors0[chan], colors1[chan],
                                                0);
            }
         }
         else {
            LLVMValueRef cmpval00, cmpval01, cmpval10, cmpval11;
            cmpval00 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][0][0]);
            cmpval01 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][1][0]);
            cmpval10 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][0][0]);
            cmpval11 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][1][0]);
            colors1[0] = lp_build_masklerp2d(&bld->texel_bld, s_fpart, t_fpart,
                                             cmpval00, cmpval01, cmpval10, cmpval11);
            /* Linearly interpolate the two samples from the two 3D slices */
            colors_out[0] = lp_build_lerp(&bld->texel_bld,
                                             r_fpart,
                                             colors0[0], colors1[0],
                                             0);
            colors_out[1] = colors_out[2] = colors_out[3] = colors_out[0];
         }
      }
      else {
         /* 2D tex */
         for (chan = 0; chan < 4; chan++) {
            colors_out[chan] = colors0[chan];
         }
      }
   }
}


/**
 * Sample the texture/mipmap using given image filter and mip filter.
 * ilevel0 and ilevel1 indicate the two mipmap levels to sample
 * from (vectors or scalars).
 * If we're using nearest miplevel sampling the '1' values will be null/unused.
 */
static void
lp_build_sample_mipmap(struct lp_build_sample_context *bld,
                       unsigned img_filter,
                       unsigned mip_filter,
                       LLVMValueRef *coords,
                       const LLVMValueRef *offsets,
                       LLVMValueRef ilevel0,
                       LLVMValueRef ilevel1,
                       LLVMValueRef lod_fpart,
                       LLVMValueRef *colors_out)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef size0 = NULL;
   LLVMValueRef size1 = NULL;
   LLVMValueRef row_stride0_vec = NULL;
   LLVMValueRef row_stride1_vec = NULL;
   LLVMValueRef img_stride0_vec = NULL;
   LLVMValueRef img_stride1_vec = NULL;
   LLVMValueRef data_ptr0 = NULL;
   LLVMValueRef data_ptr1 = NULL;
   LLVMValueRef mipoff0 = NULL;
   LLVMValueRef mipoff1 = NULL;
   LLVMValueRef colors0[4], colors1[4];
   unsigned chan;

   /* sample the first mipmap level */
   lp_build_mipmap_level_sizes(bld, ilevel0,
                               &size0,
                               &row_stride0_vec, &img_stride0_vec);
   if (bld->num_mips == 1) {
      data_ptr0 = lp_build_get_mipmap_level(bld, ilevel0);
   }
   else {
      /* This path should work for num_lods 1 too but slightly less efficient */
      data_ptr0 = bld->base_ptr;
      mipoff0 = lp_build_get_mip_offsets(bld, ilevel0);
   }
   if (img_filter == PIPE_TEX_FILTER_NEAREST) {
      lp_build_sample_image_nearest(bld, size0,
                                    row_stride0_vec, img_stride0_vec,
                                    data_ptr0, mipoff0, coords, offsets,
                                    colors0);
   }
   else {
      assert(img_filter == PIPE_TEX_FILTER_LINEAR);
      lp_build_sample_image_linear(bld, size0, NULL,
                                   row_stride0_vec, img_stride0_vec,
                                   data_ptr0, mipoff0, coords, offsets,
                                   colors0);
   }

   /* Store the first level's colors in the output variables */
   for (chan = 0; chan < 4; chan++) {
       LLVMBuildStore(builder, colors0[chan], colors_out[chan]);
   }

   if (mip_filter == PIPE_TEX_MIPFILTER_LINEAR) {
      struct lp_build_if_state if_ctx;
      LLVMValueRef need_lerp;

      /* need_lerp = lod_fpart > 0 */
      if (bld->num_lods == 1) {
         need_lerp = LLVMBuildFCmp(builder, LLVMRealUGT,
                                   lod_fpart, bld->lodf_bld.zero,
                                   "need_lerp");
      }
      else {
         /*
          * We'll do mip filtering if any of the quads (or individual
          * pixel in case of per-pixel lod) need it.
          * It might be better to split the vectors here and only fetch/filter
          * quads which need it (if there's one lod per quad).
          */
         need_lerp = lp_build_compare(bld->gallivm, bld->lodf_bld.type,
                                      PIPE_FUNC_GREATER,
                                      lod_fpart, bld->lodf_bld.zero);
         need_lerp = lp_build_any_true_range(&bld->lodi_bld, bld->num_lods, need_lerp);
      }

      lp_build_if(&if_ctx, bld->gallivm, need_lerp);
      {
         /*
          * We unfortunately need to clamp lod_fpart here since we can get
          * negative values which would screw up filtering if not all
          * lod_fpart values have same sign.
          */
         lod_fpart = lp_build_max(&bld->lodf_bld, lod_fpart,
                                  bld->lodf_bld.zero);
         /* sample the second mipmap level */
         lp_build_mipmap_level_sizes(bld, ilevel1,
                                     &size1,
                                     &row_stride1_vec, &img_stride1_vec);
         if (bld->num_mips == 1) {
            data_ptr1 = lp_build_get_mipmap_level(bld, ilevel1);
         }
         else {
            data_ptr1 = bld->base_ptr;
            mipoff1 = lp_build_get_mip_offsets(bld, ilevel1);
         }
         if (img_filter == PIPE_TEX_FILTER_NEAREST) {
            lp_build_sample_image_nearest(bld, size1,
                                          row_stride1_vec, img_stride1_vec,
                                          data_ptr1, mipoff1, coords, offsets,
                                          colors1);
         }
         else {
            lp_build_sample_image_linear(bld, size1, NULL,
                                         row_stride1_vec, img_stride1_vec,
                                         data_ptr1, mipoff1, coords, offsets,
                                         colors1);
         }

         /* interpolate samples from the two mipmap levels */

         if (bld->num_lods != bld->coord_type.length)
            lod_fpart = lp_build_unpack_broadcast_aos_scalars(bld->gallivm,
                                                              bld->lodf_bld.type,
                                                              bld->texel_bld.type,
                                                              lod_fpart);

         for (chan = 0; chan < 4; chan++) {
            colors0[chan] = lp_build_lerp(&bld->texel_bld, lod_fpart,
                                          colors0[chan], colors1[chan],
                                          0);
            LLVMBuildStore(builder, colors0[chan], colors_out[chan]);
         }
      }
      lp_build_endif(&if_ctx);
   }
}


/**
 * Sample the texture/mipmap using given mip filter, and using
 * both nearest and linear filtering at the same time depending
 * on linear_mask.
 * lod can be per quad but linear_mask is always per pixel.
 * ilevel0 and ilevel1 indicate the two mipmap levels to sample
 * from (vectors or scalars).
 * If we're using nearest miplevel sampling the '1' values will be null/unused.
 */
static void
lp_build_sample_mipmap_both(struct lp_build_sample_context *bld,
                            LLVMValueRef linear_mask,
                            unsigned mip_filter,
                            LLVMValueRef *coords,
                            const LLVMValueRef *offsets,
                            LLVMValueRef ilevel0,
                            LLVMValueRef ilevel1,
                            LLVMValueRef lod_fpart,
                            LLVMValueRef lod_positive,
                            LLVMValueRef *colors_out)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef size0 = NULL;
   LLVMValueRef size1 = NULL;
   LLVMValueRef row_stride0_vec = NULL;
   LLVMValueRef row_stride1_vec = NULL;
   LLVMValueRef img_stride0_vec = NULL;
   LLVMValueRef img_stride1_vec = NULL;
   LLVMValueRef data_ptr0 = NULL;
   LLVMValueRef data_ptr1 = NULL;
   LLVMValueRef mipoff0 = NULL;
   LLVMValueRef mipoff1 = NULL;
   LLVMValueRef colors0[4], colors1[4];
   unsigned chan;

   /* sample the first mipmap level */
   lp_build_mipmap_level_sizes(bld, ilevel0,
                               &size0,
                               &row_stride0_vec, &img_stride0_vec);
   if (bld->num_mips == 1) {
      data_ptr0 = lp_build_get_mipmap_level(bld, ilevel0);
   }
   else {
      /* This path should work for num_lods 1 too but slightly less efficient */
      data_ptr0 = bld->base_ptr;
      mipoff0 = lp_build_get_mip_offsets(bld, ilevel0);
   }

   lp_build_sample_image_linear(bld, size0, linear_mask,
                                row_stride0_vec, img_stride0_vec,
                                data_ptr0, mipoff0, coords, offsets,
                                colors0);

   /* Store the first level's colors in the output variables */
   for (chan = 0; chan < 4; chan++) {
       LLVMBuildStore(builder, colors0[chan], colors_out[chan]);
   }

   if (mip_filter == PIPE_TEX_MIPFILTER_LINEAR) {
      struct lp_build_if_state if_ctx;
      LLVMValueRef need_lerp;

      /*
       * We'll do mip filtering if any of the quads (or individual
       * pixel in case of per-pixel lod) need it.
       * Note using lod_positive here not lod_fpart since it may be the same
       * condition as that used in the outer "if" in the caller hence llvm
       * should be able to merge the branches in this case.
       */
      need_lerp = lp_build_any_true_range(&bld->lodi_bld, bld->num_lods, lod_positive);

      lp_build_if(&if_ctx, bld->gallivm, need_lerp);
      {
         /*
          * We unfortunately need to clamp lod_fpart here since we can get
          * negative values which would screw up filtering if not all
          * lod_fpart values have same sign.
          */
         lod_fpart = lp_build_max(&bld->lodf_bld, lod_fpart,
                                  bld->lodf_bld.zero);
         /* sample the second mipmap level */
         lp_build_mipmap_level_sizes(bld, ilevel1,
                                     &size1,
                                     &row_stride1_vec, &img_stride1_vec);
         if (bld->num_mips == 1) {
            data_ptr1 = lp_build_get_mipmap_level(bld, ilevel1);
         }
         else {
            data_ptr1 = bld->base_ptr;
            mipoff1 = lp_build_get_mip_offsets(bld, ilevel1);
         }

         lp_build_sample_image_linear(bld, size1, linear_mask,
                                      row_stride1_vec, img_stride1_vec,
                                      data_ptr1, mipoff1, coords, offsets,
                                      colors1);

         /* interpolate samples from the two mipmap levels */

         if (bld->num_lods != bld->coord_type.length)
            lod_fpart = lp_build_unpack_broadcast_aos_scalars(bld->gallivm,
                                                              bld->lodf_bld.type,
                                                              bld->texel_bld.type,
                                                              lod_fpart);

         for (chan = 0; chan < 4; chan++) {
            colors0[chan] = lp_build_lerp(&bld->texel_bld, lod_fpart,
                                          colors0[chan], colors1[chan],
                                          0);
            LLVMBuildStore(builder, colors0[chan], colors_out[chan]);
         }
      }
      lp_build_endif(&if_ctx);
   }
}


/**
 * Build (per-coord) layer value.
 * Either clamp layer to valid values or fill in optional out_of_bounds
 * value and just return value unclamped.
 */
static LLVMValueRef
lp_build_layer_coord(struct lp_build_sample_context *bld,
                     unsigned texture_unit,
                     LLVMValueRef layer,
                     LLVMValueRef *out_of_bounds)
{
   LLVMValueRef num_layers;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;

   num_layers = bld->dynamic_state->depth(bld->dynamic_state,
                                          bld->gallivm, texture_unit);

   if (out_of_bounds) {
      LLVMValueRef out1, out;
      num_layers = lp_build_broadcast_scalar(int_coord_bld, num_layers);
      out = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, layer, int_coord_bld->zero);
      out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, layer, num_layers);
      *out_of_bounds = lp_build_or(int_coord_bld, out, out1);
      return layer;
   }
   else {
      LLVMValueRef maxlayer;
      maxlayer = lp_build_sub(&bld->int_bld, num_layers, bld->int_bld.one);
      maxlayer = lp_build_broadcast_scalar(int_coord_bld, maxlayer);
      return lp_build_clamp(int_coord_bld, layer, int_coord_bld->zero, maxlayer);
   }
}


/**
 * Calculate cube face, lod, mip levels.
 */
static void
lp_build_sample_common(struct lp_build_sample_context *bld,
                       unsigned texture_index,
                       unsigned sampler_index,
                       LLVMValueRef *coords,
                       const struct lp_derivatives *derivs, /* optional */
                       LLVMValueRef lod_bias, /* optional */
                       LLVMValueRef explicit_lod, /* optional */
                       LLVMValueRef *lod_pos_or_zero,
                       LLVMValueRef *lod_fpart,
                       LLVMValueRef *ilevel0,
                       LLVMValueRef *ilevel1)
{
   const unsigned mip_filter = bld->static_sampler_state->min_mip_filter;
   const unsigned min_filter = bld->static_sampler_state->min_img_filter;
   const unsigned mag_filter = bld->static_sampler_state->mag_img_filter;
   const unsigned target = bld->static_texture_state->target;
   LLVMValueRef first_level, cube_rho = NULL;
   LLVMValueRef lod_ipart = NULL;
   struct lp_derivatives cube_derivs;

   /*
   printf("%s mip %d  min %d  mag %d\n", __FUNCTION__,
          mip_filter, min_filter, mag_filter);
   */

   /*
    * Choose cube face, recompute texcoords for the chosen face and
    * compute rho here too (as it requires transform of derivatives).
    */
   if (target == PIPE_TEXTURE_CUBE) {
      boolean need_derivs;
      need_derivs = ((min_filter != mag_filter ||
                      mip_filter != PIPE_TEX_MIPFILTER_NONE) &&
                      !bld->static_sampler_state->min_max_lod_equal &&
                      !explicit_lod);
      lp_build_cube_lookup(bld, coords, derivs, &cube_rho, &cube_derivs, need_derivs);
      derivs = &cube_derivs;
   }
   else if (target == PIPE_TEXTURE_1D_ARRAY ||
            target == PIPE_TEXTURE_2D_ARRAY) {
      coords[2] = lp_build_iround(&bld->coord_bld, coords[2]);
      coords[2] = lp_build_layer_coord(bld, texture_index, coords[2], NULL);
   }

   if (bld->static_sampler_state->compare_mode != PIPE_TEX_COMPARE_NONE) {
      /*
       * Clamp p coords to [0,1] for fixed function depth texture format here.
       * Technically this is not entirely correct for unorm depth as the ref value
       * should be converted to the depth format (quantization!) and comparison
       * then done in texture format. This would actually help performance (since
       * only need to do it once and could save the per-sample conversion of texels
       * to floats instead), but it would need more messy code (would need to push
       * at least some bits down to actual fetch so conversion could be skipped,
       * and would have ugly interaction with border color, would need to convert
       * border color to that format too or do some other tricks to make it work).
       */
      const struct util_format_description *format_desc = bld->format_desc;
      unsigned chan_type;
      /* not entirely sure we couldn't end up with non-valid swizzle here */
      chan_type = format_desc->swizzle[0] <= UTIL_FORMAT_SWIZZLE_W ?
                     format_desc->channel[format_desc->swizzle[0]].type :
                     UTIL_FORMAT_TYPE_FLOAT;
      if (chan_type != UTIL_FORMAT_TYPE_FLOAT) {
         coords[4] = lp_build_clamp(&bld->coord_bld, coords[4],
                                    bld->coord_bld.zero, bld->coord_bld.one);
      }
   }

   /*
    * Compute the level of detail (float).
    */
   if (min_filter != mag_filter ||
       mip_filter != PIPE_TEX_MIPFILTER_NONE) {
      /* Need to compute lod either to choose mipmap levels or to
       * distinguish between minification/magnification with one mipmap level.
       */
      lp_build_lod_selector(bld, texture_index, sampler_index,
                            coords[0], coords[1], coords[2], cube_rho,
                            derivs, lod_bias, explicit_lod,
                            mip_filter,
                            &lod_ipart, lod_fpart, lod_pos_or_zero);
   } else {
      lod_ipart = bld->lodi_bld.zero;
      *lod_pos_or_zero = bld->lodi_bld.zero;
   }

   if (bld->num_lods != bld->num_mips) {
      /* only makes sense if there's just a single mip level */
      assert(bld->num_mips == 1);
      lod_ipart = lp_build_extract_range(bld->gallivm, lod_ipart, 0, 1);
   }

   /*
    * Compute integer mipmap level(s) to fetch texels from: ilevel0, ilevel1
    */
   switch (mip_filter) {
   default:
      assert(0 && "bad mip_filter value in lp_build_sample_soa()");
      /* fall-through */
   case PIPE_TEX_MIPFILTER_NONE:
      /* always use mip level 0 */
      if (HAVE_LLVM == 0x0207 && target == PIPE_TEXTURE_CUBE) {
         /* XXX this is a work-around for an apparent bug in LLVM 2.7.
          * We should be able to set ilevel0 = const(0) but that causes
          * bad x86 code to be emitted.
          */
         assert(lod_ipart);
         lp_build_nearest_mip_level(bld, texture_index, lod_ipart, ilevel0, NULL);
      }
      else {
         first_level = bld->dynamic_state->first_level(bld->dynamic_state,
                                                       bld->gallivm, texture_index);
         first_level = lp_build_broadcast_scalar(&bld->leveli_bld, first_level);
         *ilevel0 = first_level;
      }
      break;
   case PIPE_TEX_MIPFILTER_NEAREST:
      assert(lod_ipart);
      lp_build_nearest_mip_level(bld, texture_index, lod_ipart, ilevel0, NULL);
      break;
   case PIPE_TEX_MIPFILTER_LINEAR:
      assert(lod_ipart);
      assert(*lod_fpart);
      lp_build_linear_mip_levels(bld, texture_index,
                                 lod_ipart, lod_fpart,
                                 ilevel0, ilevel1);
      break;
   }
}

static void
lp_build_clamp_border_color(struct lp_build_sample_context *bld,
                            unsigned sampler_unit)
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef border_color_ptr =
      bld->dynamic_state->border_color(bld->dynamic_state,
                                        gallivm, sampler_unit);
   LLVMValueRef border_color;
   const struct util_format_description *format_desc = bld->format_desc;
   struct lp_type vec4_type = bld->texel_type;
   struct lp_build_context vec4_bld;
   LLVMValueRef min_clamp = NULL;
   LLVMValueRef max_clamp = NULL;

   /*
    * For normalized format need to clamp border color (technically
    * probably should also quantize the data). Really sucks doing this
    * here but can't avoid at least for now since this is part of
    * sampler state and texture format is part of sampler_view state.
    * GL expects also expects clamping for uint/sint formats too so
    * do that as well (d3d10 can't end up here with uint/sint since it
    * only supports them with ld).
    */
   vec4_type.length = 4;
   lp_build_context_init(&vec4_bld, gallivm, vec4_type);

   /*
    * Vectorized clamping of border color. Loading is a bit of a hack since
    * we just cast the pointer to float array to pointer to vec4
    * (int or float).
    */
   border_color_ptr = lp_build_array_get_ptr(gallivm, border_color_ptr,
                                             lp_build_const_int32(gallivm, 0));
   border_color_ptr = LLVMBuildBitCast(builder, border_color_ptr,
                                       LLVMPointerType(vec4_bld.vec_type, 0), "");
   border_color = LLVMBuildLoad(builder, border_color_ptr, "");
   /* we don't have aligned type in the dynamic state unfortunately */
   lp_set_load_alignment(border_color, 4);

   /*
    * Instead of having some incredibly complex logic which will try to figure out
    * clamping necessary for each channel, simply use the first channel, and treat
    * mixed signed/unsigned normalized formats specially.
    * (Mixed non-normalized, which wouldn't work at all here, do not exist for a
    * good reason.)
    */
   if (format_desc->layout == UTIL_FORMAT_LAYOUT_PLAIN) {
      int chan;
      /* d/s needs special handling because both present means just sampling depth */
      if (util_format_is_depth_and_stencil(format_desc->format)) {
         chan = format_desc->swizzle[0];
      }
      else {
         chan = util_format_get_first_non_void_channel(format_desc->format);
      }
      if (chan >= 0 && chan <= UTIL_FORMAT_SWIZZLE_W) {
         unsigned chan_type = format_desc->channel[chan].type;
         unsigned chan_norm = format_desc->channel[chan].normalized;
         unsigned chan_pure = format_desc->channel[chan].pure_integer;
         if (chan_type == UTIL_FORMAT_TYPE_SIGNED) {
            if (chan_norm) {
               min_clamp = lp_build_const_vec(gallivm, vec4_type, -1.0F);
               max_clamp = vec4_bld.one;
            }
            else if (chan_pure) {
               /*
                * Border color was stored as int, hence need min/max clamp
                * only if chan has less than 32 bits..
                */
               unsigned chan_size = format_desc->channel[chan].size;
               if (chan_size < 32) {
                  min_clamp = lp_build_const_int_vec(gallivm, vec4_type,
                                                     0 - (1 << (chan_size - 1)));
                  max_clamp = lp_build_const_int_vec(gallivm, vec4_type,
                                                     (1 << (chan_size - 1)) - 1);
               }
            }
            /* TODO: no idea about non-pure, non-normalized! */
         }
         else if (chan_type == UTIL_FORMAT_TYPE_UNSIGNED) {
            if (chan_norm) {
               min_clamp = vec4_bld.zero;
               max_clamp = vec4_bld.one;
            }
            /*
             * Need a ugly hack here, because we don't have Z32_FLOAT_X8X24
             * we use Z32_FLOAT_S8X24 to imply sampling depth component
             * and ignoring stencil, which will blow up here if we try to
             * do a uint clamp in a float texel build...
             * And even if we had that format, mesa st also thinks using z24s8
             * means depth sampling ignoring stencil.
             */
            else if (chan_pure) {
               /*
                * Border color was stored as uint, hence never need min
                * clamp, and only need max clamp if chan has less than 32 bits.
                */
               unsigned chan_size = format_desc->channel[chan].size;
               if (chan_size < 32) {
                  max_clamp = lp_build_const_int_vec(gallivm, vec4_type,
                                                     (1 << chan_size) - 1);
               }
               /* TODO: no idea about non-pure, non-normalized! */
            }
         }
         else if (chan_type == UTIL_FORMAT_TYPE_FIXED) {
            /* TODO: I have no idea what clamp this would need if any! */
         }
      }
      /* mixed plain formats (or different pure size) */
      switch (format_desc->format) {
      case PIPE_FORMAT_B10G10R10A2_UINT:
      case PIPE_FORMAT_R10G10B10A2_UINT:
      {
         unsigned max10 = (1 << 10) - 1;
         max_clamp = lp_build_const_aos(gallivm, vec4_type, max10, max10,
                                        max10, (1 << 2) - 1, NULL);
      }
         break;
      case PIPE_FORMAT_R10SG10SB10SA2U_NORM:
         min_clamp = lp_build_const_aos(gallivm, vec4_type, -1.0F, -1.0F,
                                        -1.0F, 0.0F, NULL);
         max_clamp = vec4_bld.one;
         break;
      case PIPE_FORMAT_R8SG8SB8UX8U_NORM:
      case PIPE_FORMAT_R5SG5SB6U_NORM:
         min_clamp = lp_build_const_aos(gallivm, vec4_type, -1.0F, -1.0F,
                                        0.0F, 0.0F, NULL);
         max_clamp = vec4_bld.one;
         break;
      default:
         break;
      }
   }
   else {
      /* cannot figure this out from format description */
      if (format_desc->layout == UTIL_FORMAT_LAYOUT_S3TC) {
         /* s3tc formats are always unorm */
         min_clamp = vec4_bld.zero;
         max_clamp = vec4_bld.one;
      }
      else if (format_desc->layout == UTIL_FORMAT_LAYOUT_RGTC ||
               format_desc->layout == UTIL_FORMAT_LAYOUT_ETC) {
         switch (format_desc->format) {
         case PIPE_FORMAT_RGTC1_UNORM:
         case PIPE_FORMAT_RGTC2_UNORM:
         case PIPE_FORMAT_LATC1_UNORM:
         case PIPE_FORMAT_LATC2_UNORM:
         case PIPE_FORMAT_ETC1_RGB8:
            min_clamp = vec4_bld.zero;
            max_clamp = vec4_bld.one;
            break;
         case PIPE_FORMAT_RGTC1_SNORM:
         case PIPE_FORMAT_RGTC2_SNORM:
         case PIPE_FORMAT_LATC1_SNORM:
         case PIPE_FORMAT_LATC2_SNORM:
            min_clamp = lp_build_const_vec(gallivm, vec4_type, -1.0F);
            max_clamp = vec4_bld.one;
            break;
         default:
            assert(0);
            break;
         }
      }
      /*
       * all others from subsampled/other group, though we don't care
       * about yuv (and should not have any from zs here)
       */
      else if (format_desc->colorspace != UTIL_FORMAT_COLORSPACE_YUV){
         switch (format_desc->format) {
         case PIPE_FORMAT_R8G8_B8G8_UNORM:
         case PIPE_FORMAT_G8R8_G8B8_UNORM:
         case PIPE_FORMAT_G8R8_B8R8_UNORM:
         case PIPE_FORMAT_R8G8_R8B8_UNORM:
         case PIPE_FORMAT_R1_UNORM: /* doesn't make sense but ah well */
            min_clamp = vec4_bld.zero;
            max_clamp = vec4_bld.one;
            break;
         case PIPE_FORMAT_R8G8Bx_SNORM:
            min_clamp = lp_build_const_vec(gallivm, vec4_type, -1.0F);
            max_clamp = vec4_bld.one;
            break;
            /*
             * Note smallfloat formats usually don't need clamping
             * (they still have infinite range) however this is not
             * true for r11g11b10 and r9g9b9e5, which can't represent
             * negative numbers (and additionally r9g9b9e5 can't represent
             * very large numbers). d3d10 seems happy without clamping in
             * this case, but gl spec is pretty clear: "for floating
             * point and integer formats, border values are clamped to
             * the representable range of the format" so do that here.
             */
         case PIPE_FORMAT_R11G11B10_FLOAT:
            min_clamp = vec4_bld.zero;
            break;
         case PIPE_FORMAT_R9G9B9E5_FLOAT:
            min_clamp = vec4_bld.zero;
            max_clamp = lp_build_const_vec(gallivm, vec4_type, MAX_RGB9E5);
            break;
         default:
            assert(0);
            break;
         }
      }
   }

   if (min_clamp) {
      border_color = lp_build_max(&vec4_bld, border_color, min_clamp);
   }
   if (max_clamp) {
      border_color = lp_build_min(&vec4_bld, border_color, max_clamp);
   }

   bld->border_color_clamped = border_color;
}


/**
 * General texture sampling codegen.
 * This function handles texture sampling for all texture targets (1D,
 * 2D, 3D, cube) and all filtering modes.
 */
static void
lp_build_sample_general(struct lp_build_sample_context *bld,
                        unsigned sampler_unit,
                        LLVMValueRef *coords,
                        const LLVMValueRef *offsets,
                        LLVMValueRef lod_positive,
                        LLVMValueRef lod_fpart,
                        LLVMValueRef ilevel0,
                        LLVMValueRef ilevel1,
                        LLVMValueRef *colors_out)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   const struct lp_static_sampler_state *sampler_state = bld->static_sampler_state;
   const unsigned mip_filter = sampler_state->min_mip_filter;
   const unsigned min_filter = sampler_state->min_img_filter;
   const unsigned mag_filter = sampler_state->mag_img_filter;
   LLVMValueRef texels[4];
   unsigned chan;

   /* if we need border color, (potentially) clamp it now */
   if (lp_sampler_wrap_mode_uses_border_color(sampler_state->wrap_s,
                                              min_filter,
                                              mag_filter) ||
       (bld->dims > 1 &&
           lp_sampler_wrap_mode_uses_border_color(sampler_state->wrap_t,
                                                  min_filter,
                                                  mag_filter)) ||
       (bld->dims > 2 &&
           lp_sampler_wrap_mode_uses_border_color(sampler_state->wrap_r,
                                                  min_filter,
                                                  mag_filter))) {
      lp_build_clamp_border_color(bld, sampler_unit);
   }


   /*
    * Get/interpolate texture colors.
    */

   for (chan = 0; chan < 4; ++chan) {
     texels[chan] = lp_build_alloca(bld->gallivm, bld->texel_bld.vec_type, "");
     lp_build_name(texels[chan], "sampler%u_texel_%c_var", sampler_unit, "xyzw"[chan]);
   }

   if (min_filter == mag_filter) {
      /* no need to distinguish between minification and magnification */
      lp_build_sample_mipmap(bld, min_filter, mip_filter,
                             coords, offsets,
                             ilevel0, ilevel1, lod_fpart,
                             texels);
   }
   else {
      /*
       * Could also get rid of the if-logic and always use mipmap_both, both
       * for the single lod and multi-lod case if nothing really uses this.
       */
      if (bld->num_lods == 1) {
         /* Emit conditional to choose min image filter or mag image filter
          * depending on the lod being > 0 or <= 0, respectively.
          */
         struct lp_build_if_state if_ctx;

         lod_positive = LLVMBuildTrunc(builder, lod_positive,
                                       LLVMInt1TypeInContext(bld->gallivm->context), "");

         lp_build_if(&if_ctx, bld->gallivm, lod_positive);
         {
            /* Use the minification filter */
            lp_build_sample_mipmap(bld, min_filter, mip_filter,
                                   coords, offsets,
                                   ilevel0, ilevel1, lod_fpart,
                                   texels);
         }
         lp_build_else(&if_ctx);
         {
            /* Use the magnification filter */
            lp_build_sample_mipmap(bld, mag_filter, PIPE_TEX_MIPFILTER_NONE,
                                   coords, offsets,
                                   ilevel0, NULL, NULL,
                                   texels);
         }
         lp_build_endif(&if_ctx);
      }
      else {
         LLVMValueRef need_linear, linear_mask;
         unsigned mip_filter_for_nearest;
         struct lp_build_if_state if_ctx;

         if (min_filter == PIPE_TEX_FILTER_LINEAR) {
            linear_mask = lod_positive;
            mip_filter_for_nearest = PIPE_TEX_MIPFILTER_NONE;
         }
         else {
            linear_mask = lp_build_not(&bld->lodi_bld, lod_positive);
            mip_filter_for_nearest = mip_filter;
         }
         need_linear = lp_build_any_true_range(&bld->lodi_bld, bld->num_lods,
                                               linear_mask);

         if (bld->num_lods != bld->coord_type.length) {
            linear_mask = lp_build_unpack_broadcast_aos_scalars(bld->gallivm,
                                                                bld->lodi_type,
                                                                bld->int_coord_type,
                                                                linear_mask);
         }

         lp_build_if(&if_ctx, bld->gallivm, need_linear);
         {
            /*
             * Do sampling with both filters simultaneously. This means using
             * a linear filter and doing some tricks (with weights) for the pixels
             * which need nearest filter.
             * Note that it's probably rare some pixels need nearest and some
             * linear filter but the fixups required for the nearest pixels
             * aren't all that complicated so just always run a combined path
             * if at least some pixels require linear.
             */
            lp_build_sample_mipmap_both(bld, linear_mask, mip_filter,
                                        coords, offsets,
                                        ilevel0, ilevel1,
                                        lod_fpart, lod_positive,
                                        texels);
         }
         lp_build_else(&if_ctx);
         {
            /*
             * All pixels require just nearest filtering, which is way
             * cheaper than linear, hence do a separate path for that.
             */
            lp_build_sample_mipmap(bld, PIPE_TEX_FILTER_NEAREST,
                                   mip_filter_for_nearest,
                                   coords, offsets,
                                   ilevel0, ilevel1, lod_fpart,
                                   texels);
         }
         lp_build_endif(&if_ctx);
      }
   }

   for (chan = 0; chan < 4; ++chan) {
     colors_out[chan] = LLVMBuildLoad(builder, texels[chan], "");
     lp_build_name(colors_out[chan], "sampler%u_texel_%c", sampler_unit, "xyzw"[chan]);
   }
}


/**
 * Texel fetch function.
 * In contrast to general sampling there is no filtering, no coord minification,
 * lod (if any) is always explicit uint, coords are uints (in terms of texel units)
 * directly to be applied to the selected mip level (after adding texel offsets).
 * This function handles texel fetch for all targets where texel fetch is supported
 * (no cube maps, but 1d, 2d, 3d are supported, arrays and buffers should be too).
 */
static void
lp_build_fetch_texel(struct lp_build_sample_context *bld,
                     unsigned texture_unit,
                     const LLVMValueRef *coords,
                     LLVMValueRef explicit_lod,
                     const LLVMValueRef *offsets,
                     LLVMValueRef *colors_out)
{
   struct lp_build_context *perquadi_bld = &bld->lodi_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   unsigned dims = bld->dims, chan;
   unsigned target = bld->static_texture_state->target;
   boolean out_of_bound_ret_zero = TRUE;
   LLVMValueRef size, ilevel;
   LLVMValueRef row_stride_vec = NULL, img_stride_vec = NULL;
   LLVMValueRef x = coords[0], y = coords[1], z = coords[2];
   LLVMValueRef width, height, depth, i, j;
   LLVMValueRef offset, out_of_bounds, out1;

   out_of_bounds = int_coord_bld->zero;

   if (explicit_lod && bld->static_texture_state->target != PIPE_BUFFER) {
      if (bld->num_mips != int_coord_bld->type.length) {
         ilevel = lp_build_pack_aos_scalars(bld->gallivm, int_coord_bld->type,
                                            perquadi_bld->type, explicit_lod, 0);
      }
      else {
         ilevel = explicit_lod;
      }
      lp_build_nearest_mip_level(bld, texture_unit, ilevel, &ilevel,
                                 out_of_bound_ret_zero ? &out_of_bounds : NULL);
   }
   else {
      assert(bld->num_mips == 1);
      if (bld->static_texture_state->target != PIPE_BUFFER) {
         ilevel = bld->dynamic_state->first_level(bld->dynamic_state,
                                                  bld->gallivm, texture_unit);
      }
      else {
         ilevel = lp_build_const_int32(bld->gallivm, 0);
      }
   }
   lp_build_mipmap_level_sizes(bld, ilevel,
                               &size,
                               &row_stride_vec, &img_stride_vec);
   lp_build_extract_image_sizes(bld, &bld->int_size_bld, int_coord_bld->type,
                                size, &width, &height, &depth);

   if (target == PIPE_TEXTURE_1D_ARRAY ||
       target == PIPE_TEXTURE_2D_ARRAY) {
      if (out_of_bound_ret_zero) {
         z = lp_build_layer_coord(bld, texture_unit, z, &out1);
         out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
      }
      else {
         z = lp_build_layer_coord(bld, texture_unit, z, NULL);
      }
   }

   /* This is a lot like border sampling */
   if (offsets[0]) {
      /*
       * coords are really unsigned, offsets are signed, but I don't think
       * exceeding 31 bits is possible
       */
      x = lp_build_add(int_coord_bld, x, offsets[0]);
   }
   out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, x, int_coord_bld->zero);
   out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
   out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, x, width);
   out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);

   if (dims >= 2) {
      if (offsets[1]) {
         y = lp_build_add(int_coord_bld, y, offsets[1]);
      }
      out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, y, int_coord_bld->zero);
      out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
      out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, y, height);
      out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);

      if (dims >= 3) {
         if (offsets[2]) {
            z = lp_build_add(int_coord_bld, z, offsets[2]);
         }
         out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, z, int_coord_bld->zero);
         out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
         out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, z, depth);
         out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
      }
   }

   lp_build_sample_offset(int_coord_bld,
                          bld->format_desc,
                          x, y, z, row_stride_vec, img_stride_vec,
                          &offset, &i, &j);

   if (bld->static_texture_state->target != PIPE_BUFFER) {
      offset = lp_build_add(int_coord_bld, offset,
                            lp_build_get_mip_offsets(bld, ilevel));
   }

   offset = lp_build_andnot(int_coord_bld, offset, out_of_bounds);

   lp_build_fetch_rgba_soa(bld->gallivm,
                           bld->format_desc,
                           bld->texel_type,
                           bld->base_ptr, offset,
                           i, j,
                           colors_out);

   if (out_of_bound_ret_zero) {
      /*
       * Only needed for ARB_robust_buffer_access_behavior and d3d10.
       * Could use min/max above instead of out-of-bounds comparisons
       * if we don't care about the result returned for out-of-bounds.
       */
      for (chan = 0; chan < 4; chan++) {
         colors_out[chan] = lp_build_select(&bld->texel_bld, out_of_bounds,
                                            bld->texel_bld.zero, colors_out[chan]);
      }
   }
}


/**
 * Just set texels to white instead of actually sampling the texture.
 * For debugging.
 */
void
lp_build_sample_nop(struct gallivm_state *gallivm,
                    struct lp_type type,
                    const LLVMValueRef *coords,
                    LLVMValueRef texel_out[4])
{
   LLVMValueRef one = lp_build_one(gallivm, type);
   unsigned chan;

   for (chan = 0; chan < 4; chan++) {
      texel_out[chan] = one;
   }  
}


/**
 * Build texture sampling code.
 * 'texel' will return a vector of four LLVMValueRefs corresponding to
 * R, G, B, A.
 * \param type  vector float type to use for coords, etc.
 * \param is_fetch  if this is a texel fetch instruction.
 * \param derivs  partial derivatives of (s,t,r,q) with respect to x and y
 */
void
lp_build_sample_soa(struct gallivm_state *gallivm,
                    const struct lp_static_texture_state *static_texture_state,
                    const struct lp_static_sampler_state *static_sampler_state,
                    struct lp_sampler_dynamic_state *dynamic_state,
                    struct lp_type type,
                    boolean is_fetch,
                    unsigned texture_index,
                    unsigned sampler_index,
                    const LLVMValueRef *coords,
                    const LLVMValueRef *offsets,
                    const struct lp_derivatives *derivs, /* optional */
                    LLVMValueRef lod_bias, /* optional */
                    LLVMValueRef explicit_lod, /* optional */
                    enum lp_sampler_lod_property lod_property,
                    LLVMValueRef texel_out[4])
{
   unsigned target = static_texture_state->target;
   unsigned dims = texture_dims(target);
   unsigned num_quads = type.length / 4;
   unsigned mip_filter, min_img_filter, mag_img_filter, i;
   struct lp_build_sample_context bld;
   struct lp_static_sampler_state derived_sampler_state = *static_sampler_state;
   LLVMTypeRef i32t = LLVMInt32TypeInContext(gallivm->context);
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef tex_width, newcoords[5];

   if (0) {
      enum pipe_format fmt = static_texture_state->format;
      debug_printf("Sample from %s\n", util_format_name(fmt));
   }

   if (static_texture_state->format == PIPE_FORMAT_NONE) {
      /*
       * If there's nothing bound, format is NONE, and we must return
       * all zero as mandated by d3d10 in this case.
       */
      unsigned chan;
      LLVMValueRef zero = lp_build_const_vec(gallivm, type, 0.0F);
      for (chan = 0; chan < 4; chan++) {
         texel_out[chan] = zero;
      }
      return;
   }

   assert(type.floating);

   /* Setup our build context */
   memset(&bld, 0, sizeof bld);
   bld.gallivm = gallivm;
   bld.static_sampler_state = &derived_sampler_state;
   bld.static_texture_state = static_texture_state;
   bld.dynamic_state = dynamic_state;
   bld.format_desc = util_format_description(static_texture_state->format);
   bld.dims = dims;

   bld.vector_width = lp_type_width(type);

   bld.float_type = lp_type_float(32);
   bld.int_type = lp_type_int(32);
   bld.coord_type = type;
   bld.int_coord_type = lp_int_type(type);
   bld.float_size_in_type = lp_type_float(32);
   bld.float_size_in_type.length = dims > 1 ? 4 : 1;
   bld.int_size_in_type = lp_int_type(bld.float_size_in_type);
   bld.texel_type = type;

   /* always using the first channel hopefully should be safe,
    * if not things WILL break in other places anyway.
    */
   if (bld.format_desc->colorspace == UTIL_FORMAT_COLORSPACE_RGB &&
       bld.format_desc->channel[0].pure_integer) {
      if (bld.format_desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
         bld.texel_type = lp_type_int_vec(type.width, type.width * type.length);
      }
      else if (bld.format_desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED) {
         bld.texel_type = lp_type_uint_vec(type.width, type.width * type.length);
      }
   }
   else if (util_format_has_stencil(bld.format_desc) &&
       !util_format_has_depth(bld.format_desc)) {
      /* for stencil only formats, sample stencil (uint) */
      bld.texel_type = lp_type_int_vec(type.width, type.width * type.length);
   }

   if (!static_texture_state->level_zero_only) {
      derived_sampler_state.min_mip_filter = static_sampler_state->min_mip_filter;
   } else {
      derived_sampler_state.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
   }
   mip_filter = derived_sampler_state.min_mip_filter;

   if (0) {
      debug_printf("  .min_mip_filter = %u\n", derived_sampler_state.min_mip_filter);
   }

   if (static_texture_state->target == PIPE_TEXTURE_CUBE ||
       static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY)
   {
      /*
       * Seamless filtering ignores wrap modes.
       * Setting to CLAMP_TO_EDGE is correct for nearest filtering, for
       * bilinear it's not correct but way better than using for instance repeat.
       * Note we even set this for non-seamless. Technically GL allows any wrap
       * mode, which made sense when supporting true borders (can get seamless
       * effect with border and CLAMP_TO_BORDER), but gallium doesn't support
       * borders and d3d9 requires wrap modes to be ignored and it's a pain to fix
       * up the sampler state (as it makes it texture dependent).
       */
      derived_sampler_state.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
      derived_sampler_state.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   }

   min_img_filter = derived_sampler_state.min_img_filter;
   mag_img_filter = derived_sampler_state.mag_img_filter;


   /*
    * This is all a bit complicated different paths are chosen for performance
    * reasons.
    * Essentially, there can be 1 lod per element, 1 lod per quad or 1 lod for
    * everything (the last two options are equivalent for 4-wide case).
    * If there's per-quad lod but we split to 4-wide so we can use AoS, per-quad
    * lod is calculated then the lod value extracted afterwards so making this
    * case basically the same as far as lod handling is concerned for the
    * further sample/filter code as the 1 lod for everything case.
    * Different lod handling mostly shows up when building mipmap sizes
    * (lp_build_mipmap_level_sizes() and friends) and also in filtering
    * (getting the fractional part of the lod to the right texels).
    */

   /*
    * There are other situations where at least the multiple int lods could be
    * avoided like min and max lod being equal.
    */
   bld.num_mips = bld.num_lods = 1;

   if ((gallivm_debug & GALLIVM_DEBUG_NO_QUAD_LOD) &&
       (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) &&
       (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
       (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
      /*
       * special case for using per-pixel lod even for implicit lod,
       * which is generally never required (ok by APIs) except to please
       * some (somewhat broken imho) tests (because per-pixel face selection
       * can cause derivatives to be different for pixels outside the primitive
       * due to the major axis division even if pre-project derivatives are
       * looking normal).
       */
      bld.num_mips = type.length;
      bld.num_lods = type.length;
   }
   else if (lod_property == LP_SAMPLER_LOD_PER_ELEMENT ||
       (explicit_lod || lod_bias || derivs)) {
      if ((is_fetch && target != PIPE_BUFFER) ||
          (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
         bld.num_mips = type.length;
         bld.num_lods = type.length;
      }
      else if (!is_fetch && min_img_filter != mag_img_filter) {
         bld.num_mips = 1;
         bld.num_lods = type.length;
      }
   }
   /* TODO: for true scalar_lod should only use 1 lod value */
   else if ((is_fetch && explicit_lod && target != PIPE_BUFFER) ||
            (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
      bld.num_mips = num_quads;
      bld.num_lods = num_quads;
   }
   else if (!is_fetch && min_img_filter != mag_img_filter) {
      bld.num_mips = 1;
      bld.num_lods = num_quads;
   }


   bld.lodf_type = type;
   /* we want native vector size to be able to use our intrinsics */
   if (bld.num_lods != type.length) {
      /* TODO: this currently always has to be per-quad or per-element */
      bld.lodf_type.length = type.length > 4 ? ((type.length + 15) / 16) * 4 : 1;
   }
   bld.lodi_type = lp_int_type(bld.lodf_type);
   bld.levelf_type = bld.lodf_type;
   if (bld.num_mips == 1) {
      bld.levelf_type.length = 1;
   }
   bld.leveli_type = lp_int_type(bld.levelf_type);
   bld.float_size_type = bld.float_size_in_type;
   /* Note: size vectors may not be native. They contain minified w/h/d/_ values,
    * with per-element lod that is w0/h0/d0/_/w1/h1/d1_/... so up to 8x4f32 */
   if (bld.num_mips > 1) {
      bld.float_size_type.length = bld.num_mips == type.length ?
                                      bld.num_mips * bld.float_size_in_type.length :
                                      type.length;
   }
   bld.int_size_type = lp_int_type(bld.float_size_type);

   lp_build_context_init(&bld.float_bld, gallivm, bld.float_type);
   lp_build_context_init(&bld.float_vec_bld, gallivm, type);
   lp_build_context_init(&bld.int_bld, gallivm, bld.int_type);
   lp_build_context_init(&bld.coord_bld, gallivm, bld.coord_type);
   lp_build_context_init(&bld.int_coord_bld, gallivm, bld.int_coord_type);
   lp_build_context_init(&bld.int_size_in_bld, gallivm, bld.int_size_in_type);
   lp_build_context_init(&bld.float_size_in_bld, gallivm, bld.float_size_in_type);
   lp_build_context_init(&bld.int_size_bld, gallivm, bld.int_size_type);
   lp_build_context_init(&bld.float_size_bld, gallivm, bld.float_size_type);
   lp_build_context_init(&bld.texel_bld, gallivm, bld.texel_type);
   lp_build_context_init(&bld.levelf_bld, gallivm, bld.levelf_type);
   lp_build_context_init(&bld.leveli_bld, gallivm, bld.leveli_type);
   lp_build_context_init(&bld.lodf_bld, gallivm, bld.lodf_type);
   lp_build_context_init(&bld.lodi_bld, gallivm, bld.lodi_type);

   /* Get the dynamic state */
   tex_width = dynamic_state->width(dynamic_state, gallivm, texture_index);
   bld.row_stride_array = dynamic_state->row_stride(dynamic_state, gallivm, texture_index);
   bld.img_stride_array = dynamic_state->img_stride(dynamic_state, gallivm, texture_index);
   bld.base_ptr = dynamic_state->base_ptr(dynamic_state, gallivm, texture_index);
   bld.mip_offsets = dynamic_state->mip_offsets(dynamic_state, gallivm, texture_index);
   /* Note that mip_offsets is an array[level] of offsets to texture images */

   /* width, height, depth as single int vector */
   if (dims <= 1) {
      bld.int_size = tex_width;
   }
   else {
      bld.int_size = LLVMBuildInsertElement(builder, bld.int_size_in_bld.undef,
                                            tex_width, LLVMConstInt(i32t, 0, 0), "");
      if (dims >= 2) {
         LLVMValueRef tex_height =
            dynamic_state->height(dynamic_state, gallivm, texture_index);
         bld.int_size = LLVMBuildInsertElement(builder, bld.int_size,
                                               tex_height, LLVMConstInt(i32t, 1, 0), "");
         if (dims >= 3) {
            LLVMValueRef tex_depth =
               dynamic_state->depth(dynamic_state, gallivm, texture_index);
            bld.int_size = LLVMBuildInsertElement(builder, bld.int_size,
                                                  tex_depth, LLVMConstInt(i32t, 2, 0), "");
         }
      }
   }

   for (i = 0; i < 5; i++) {
      newcoords[i] = coords[i];
   }

   if (0) {
      /* For debug: no-op texture sampling */
      lp_build_sample_nop(gallivm,
                          bld.texel_type,
                          newcoords,
                          texel_out);
   }

   else if (is_fetch) {
      lp_build_fetch_texel(&bld, texture_index, newcoords,
                           explicit_lod, offsets,
                           texel_out);
   }

   else {
      LLVMValueRef lod_fpart = NULL, lod_positive = NULL;
      LLVMValueRef ilevel0 = NULL, ilevel1 = NULL;
      boolean use_aos = util_format_fits_8unorm(bld.format_desc) &&
                        /* not sure this is strictly needed or simply impossible */
                        derived_sampler_state.compare_mode == PIPE_TEX_COMPARE_NONE &&
                        lp_is_simple_wrap_mode(derived_sampler_state.wrap_s);

      use_aos &= bld.num_lods <= num_quads ||
                 derived_sampler_state.min_img_filter ==
                    derived_sampler_state.mag_img_filter;
      if (dims > 1) {
         use_aos &= lp_is_simple_wrap_mode(derived_sampler_state.wrap_t);
         if (dims > 2) {
            use_aos &= lp_is_simple_wrap_mode(derived_sampler_state.wrap_r);
         }
      }
      if (static_texture_state->target == PIPE_TEXTURE_CUBE &&
          derived_sampler_state.seamless_cube_map &&
          (derived_sampler_state.min_img_filter == PIPE_TEX_FILTER_LINEAR ||
           derived_sampler_state.mag_img_filter == PIPE_TEX_FILTER_LINEAR)) {
         /* theoretically possible with AoS filtering but not implemented (complex!) */
         use_aos = 0;
      }

      if ((gallivm_debug & GALLIVM_DEBUG_PERF) &&
          !use_aos && util_format_fits_8unorm(bld.format_desc)) {
         debug_printf("%s: using floating point linear filtering for %s\n",
                      __FUNCTION__, bld.format_desc->short_name);
         debug_printf("  min_img %d  mag_img %d  mip %d  target %d  seamless %d"
                      "  wraps %d  wrapt %d  wrapr %d\n",
                      derived_sampler_state.min_img_filter,
                      derived_sampler_state.mag_img_filter,
                      derived_sampler_state.min_mip_filter,
                      static_texture_state->target,
                      derived_sampler_state.seamless_cube_map,
                      derived_sampler_state.wrap_s,
                      derived_sampler_state.wrap_t,
                      derived_sampler_state.wrap_r);
      }

      lp_build_sample_common(&bld, texture_index, sampler_index,
                             newcoords,
                             derivs, lod_bias, explicit_lod,
                             &lod_positive, &lod_fpart,
                             &ilevel0, &ilevel1);

      /*
       * we only try 8-wide sampling with soa as it appears to
       * be a loss with aos with AVX (but it should work, except
       * for conformance if min_filter != mag_filter if num_lods > 1).
       * (It should be faster if we'd support avx2)
       */
      if (num_quads == 1 || !use_aos) {
         if (use_aos) {
            /* do sampling/filtering with fixed pt arithmetic */
            lp_build_sample_aos(&bld, sampler_index,
                                newcoords[0], newcoords[1],
                                newcoords[2],
                                offsets, lod_positive, lod_fpart,
                                ilevel0, ilevel1,
                                texel_out);
         }

         else {
            lp_build_sample_general(&bld, sampler_index,
                                    newcoords, offsets,
                                    lod_positive, lod_fpart,
                                    ilevel0, ilevel1,
                                    texel_out);
         }
      }
      else {
         unsigned j;
         struct lp_build_sample_context bld4;
         struct lp_type type4 = type;
         unsigned i;
         LLVMValueRef texelout4[4];
         LLVMValueRef texelouttmp[4][LP_MAX_VECTOR_LENGTH/16];

         type4.length = 4;

         /* Setup our build context */
         memset(&bld4, 0, sizeof bld4);
         bld4.gallivm = bld.gallivm;
         bld4.static_texture_state = bld.static_texture_state;
         bld4.static_sampler_state = bld.static_sampler_state;
         bld4.dynamic_state = bld.dynamic_state;
         bld4.format_desc = bld.format_desc;
         bld4.dims = bld.dims;
         bld4.row_stride_array = bld.row_stride_array;
         bld4.img_stride_array = bld.img_stride_array;
         bld4.base_ptr = bld.base_ptr;
         bld4.mip_offsets = bld.mip_offsets;
         bld4.int_size = bld.int_size;

         bld4.vector_width = lp_type_width(type4);

         bld4.float_type = lp_type_float(32);
         bld4.int_type = lp_type_int(32);
         bld4.coord_type = type4;
         bld4.int_coord_type = lp_int_type(type4);
         bld4.float_size_in_type = lp_type_float(32);
         bld4.float_size_in_type.length = dims > 1 ? 4 : 1;
         bld4.int_size_in_type = lp_int_type(bld4.float_size_in_type);
         bld4.texel_type = bld.texel_type;
         bld4.texel_type.length = 4;

         bld4.num_mips = bld4.num_lods = 1;
         if ((gallivm_debug & GALLIVM_DEBUG_NO_QUAD_LOD) &&
             (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) &&
             (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
             (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
            bld4.num_mips = type4.length;
            bld4.num_lods = type4.length;
         }
         if (lod_property == LP_SAMPLER_LOD_PER_ELEMENT &&
             (explicit_lod || lod_bias || derivs)) {
            if ((is_fetch && target != PIPE_BUFFER) ||
                (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
               bld4.num_mips = type4.length;
               bld4.num_lods = type4.length;
            }
            else if (!is_fetch && min_img_filter != mag_img_filter) {
               bld4.num_mips = 1;
               bld4.num_lods = type4.length;
            }
         }

         /* we want native vector size to be able to use our intrinsics */
         bld4.lodf_type = type4;
         if (bld4.num_lods != type4.length) {
            bld4.lodf_type.length = 1;
         }
         bld4.lodi_type = lp_int_type(bld4.lodf_type);
         bld4.levelf_type = type4;
         if (bld4.num_mips != type4.length) {
            bld4.levelf_type.length = 1;
         }
         bld4.leveli_type = lp_int_type(bld4.levelf_type);
         bld4.float_size_type = bld4.float_size_in_type;
         if (bld4.num_mips > 1) {
            bld4.float_size_type.length = bld4.num_mips == type4.length ?
                                            bld4.num_mips * bld4.float_size_in_type.length :
                                            type4.length;
         }
         bld4.int_size_type = lp_int_type(bld4.float_size_type);

         lp_build_context_init(&bld4.float_bld, gallivm, bld4.float_type);
         lp_build_context_init(&bld4.float_vec_bld, gallivm, type4);
         lp_build_context_init(&bld4.int_bld, gallivm, bld4.int_type);
         lp_build_context_init(&bld4.coord_bld, gallivm, bld4.coord_type);
         lp_build_context_init(&bld4.int_coord_bld, gallivm, bld4.int_coord_type);
         lp_build_context_init(&bld4.int_size_in_bld, gallivm, bld4.int_size_in_type);
         lp_build_context_init(&bld4.float_size_in_bld, gallivm, bld4.float_size_in_type);
         lp_build_context_init(&bld4.int_size_bld, gallivm, bld4.int_size_type);
         lp_build_context_init(&bld4.float_size_bld, gallivm, bld4.float_size_type);
         lp_build_context_init(&bld4.texel_bld, gallivm, bld4.texel_type);
         lp_build_context_init(&bld4.levelf_bld, gallivm, bld4.levelf_type);
         lp_build_context_init(&bld4.leveli_bld, gallivm, bld4.leveli_type);
         lp_build_context_init(&bld4.lodf_bld, gallivm, bld4.lodf_type);
         lp_build_context_init(&bld4.lodi_bld, gallivm, bld4.lodi_type);

         for (i = 0; i < num_quads; i++) {
            LLVMValueRef s4, t4, r4;
            LLVMValueRef lod_positive4, lod_fpart4 = NULL;
            LLVMValueRef ilevel04, ilevel14 = NULL;
            LLVMValueRef offsets4[4] = { NULL };
            unsigned num_lods = bld4.num_lods;

            s4 = lp_build_extract_range(gallivm, newcoords[0], 4*i, 4);
            t4 = lp_build_extract_range(gallivm, newcoords[1], 4*i, 4);
            r4 = lp_build_extract_range(gallivm, newcoords[2], 4*i, 4);

            if (offsets[0]) {
               offsets4[0] = lp_build_extract_range(gallivm, offsets[0], 4*i, 4);
               if (dims > 1) {
                  offsets4[1] = lp_build_extract_range(gallivm, offsets[1], 4*i, 4);
                  if (dims > 2) {
                     offsets4[2] = lp_build_extract_range(gallivm, offsets[2], 4*i, 4);
                  }
               }
            }
            lod_positive4 = lp_build_extract_range(gallivm, lod_positive, num_lods * i, num_lods);
            ilevel04 = bld.num_mips == 1 ? ilevel0 :
                          lp_build_extract_range(gallivm, ilevel0, num_lods * i, num_lods);
            if (mip_filter == PIPE_TEX_MIPFILTER_LINEAR) {
               ilevel14 = lp_build_extract_range(gallivm, ilevel1, num_lods * i, num_lods);
               lod_fpart4 = lp_build_extract_range(gallivm, lod_fpart, num_lods * i, num_lods);
            }

            if (use_aos) {
               /* do sampling/filtering with fixed pt arithmetic */
               lp_build_sample_aos(&bld4, sampler_index,
                                   s4, t4, r4, offsets4,
                                   lod_positive4, lod_fpart4,
                                   ilevel04, ilevel14,
                                   texelout4);
            }

            else {
               /* this path is currently unreachable and hence might break easily... */
               LLVMValueRef newcoords4[5];
               newcoords4[0] = s4;
               newcoords4[1] = t4;
               newcoords4[2] = r4;
               newcoords4[3] = lp_build_extract_range(gallivm, newcoords[3], 4*i, 4);
               newcoords4[4] = lp_build_extract_range(gallivm, newcoords[4], 4*i, 4);

               lp_build_sample_general(&bld4, sampler_index,
                                       newcoords4, offsets4,
                                       lod_positive4, lod_fpart4,
                                       ilevel04, ilevel14,
                                       texelout4);
            }
            for (j = 0; j < 4; j++) {
               texelouttmp[j][i] = texelout4[j];
            }
         }

         for (j = 0; j < 4; j++) {
            texel_out[j] = lp_build_concat(gallivm, texelouttmp[j], type4, num_quads);
         }
      }
   }

   if (target != PIPE_BUFFER) {
      apply_sampler_swizzle(&bld, texel_out);
   }

   /*
    * texel type can be a (32bit) int/uint (for pure int formats only),
    * however we are expected to always return floats (storage is untyped).
    */
   if (!bld.texel_type.floating) {
      unsigned chan;
      for (chan = 0; chan < 4; chan++) {
         texel_out[chan] = LLVMBuildBitCast(builder, texel_out[chan],
                                            lp_build_vec_type(gallivm, type), "");
      }
   }
}

void
lp_build_size_query_soa(struct gallivm_state *gallivm,
                        const struct lp_static_texture_state *static_state,
                        struct lp_sampler_dynamic_state *dynamic_state,
                        struct lp_type int_type,
                        unsigned texture_unit,
                        unsigned target,
                        boolean is_sviewinfo,
                        enum lp_sampler_lod_property lod_property,
                        LLVMValueRef explicit_lod,
                        LLVMValueRef *sizes_out)
{
   LLVMValueRef lod, level, size;
   LLVMValueRef first_level = NULL;
   int dims, i;
   boolean has_array;
   unsigned num_lods = 1;
   struct lp_build_context bld_int_vec4;

   if (static_state->format == PIPE_FORMAT_NONE) {
      /*
       * If there's nothing bound, format is NONE, and we must return
       * all zero as mandated by d3d10 in this case.
       */
      unsigned chan;
      LLVMValueRef zero = lp_build_const_vec(gallivm, int_type, 0.0F);
      for (chan = 0; chan < 4; chan++) {
         sizes_out[chan] = zero;
      }
      return;
   }

   /*
    * Do some sanity verification about bound texture and shader dcl target.
    * Not entirely sure what's possible but assume array/non-array
    * always compatible (probably not ok for OpenGL but d3d10 has no
    * distinction of arrays at the resource level).
    * Everything else looks bogus (though not entirely sure about rect/2d).
    * Currently disabled because it causes assertion failures if there's
    * nothing bound (or rather a dummy texture, not that this case would
    * return the right values).
    */
   if (0 && static_state->target != target) {
      if (static_state->target == PIPE_TEXTURE_1D)
         assert(target == PIPE_TEXTURE_1D_ARRAY);
      else if (static_state->target == PIPE_TEXTURE_1D_ARRAY)
         assert(target == PIPE_TEXTURE_1D);
      else if (static_state->target == PIPE_TEXTURE_2D)
         assert(target == PIPE_TEXTURE_2D_ARRAY);
      else if (static_state->target == PIPE_TEXTURE_2D_ARRAY)
         assert(target == PIPE_TEXTURE_2D);
      else if (static_state->target == PIPE_TEXTURE_CUBE)
         assert(target == PIPE_TEXTURE_CUBE_ARRAY);
      else if (static_state->target == PIPE_TEXTURE_CUBE_ARRAY)
         assert(target == PIPE_TEXTURE_CUBE);
      else
         assert(0);
   }

   dims = texture_dims(target);

   switch (target) {
   case PIPE_TEXTURE_1D_ARRAY:
   case PIPE_TEXTURE_2D_ARRAY:
      has_array = TRUE;
      break;
   default:
      has_array = FALSE;
      break;
   }

   assert(!int_type.floating);

   lp_build_context_init(&bld_int_vec4, gallivm, lp_type_int_vec(32, 128));

   if (explicit_lod) {
      /* FIXME: this needs to honor per-element lod */
      lod = LLVMBuildExtractElement(gallivm->builder, explicit_lod, lp_build_const_int32(gallivm, 0), "");
      first_level = dynamic_state->first_level(dynamic_state, gallivm, texture_unit);
      level = LLVMBuildAdd(gallivm->builder, lod, first_level, "level");
      lod = lp_build_broadcast_scalar(&bld_int_vec4, level);
   } else {
      lod = bld_int_vec4.zero;
   }

   size = bld_int_vec4.undef;

   size = LLVMBuildInsertElement(gallivm->builder, size,
                                 dynamic_state->width(dynamic_state, gallivm, texture_unit),
                                 lp_build_const_int32(gallivm, 0), "");

   if (dims >= 2) {
      size = LLVMBuildInsertElement(gallivm->builder, size,
                                    dynamic_state->height(dynamic_state, gallivm, texture_unit),
                                    lp_build_const_int32(gallivm, 1), "");
   }

   if (dims >= 3) {
      size = LLVMBuildInsertElement(gallivm->builder, size,
                                    dynamic_state->depth(dynamic_state, gallivm, texture_unit),
                                    lp_build_const_int32(gallivm, 2), "");
   }

   size = lp_build_minify(&bld_int_vec4, size, lod, TRUE);

   if (has_array)
      size = LLVMBuildInsertElement(gallivm->builder, size,
                                    dynamic_state->depth(dynamic_state, gallivm, texture_unit),
                                    lp_build_const_int32(gallivm, dims), "");

   /*
    * d3d10 requires zero for x/y/z values (but not w, i.e. mip levels)
    * if level is out of bounds (note this can't cover unbound texture
    * here, which also requires returning zero).
    */
   if (explicit_lod && is_sviewinfo) {
      LLVMValueRef last_level, out, out1;
      struct lp_build_context leveli_bld;

      /* everything is scalar for now */
      lp_build_context_init(&leveli_bld, gallivm, lp_type_int_vec(32, 32));
      last_level = dynamic_state->last_level(dynamic_state, gallivm, texture_unit);

      out = lp_build_cmp(&leveli_bld, PIPE_FUNC_LESS, level, first_level);
      out1 = lp_build_cmp(&leveli_bld, PIPE_FUNC_GREATER, level, last_level);
      out = lp_build_or(&leveli_bld, out, out1);
      if (num_lods == 1) {
         out = lp_build_broadcast_scalar(&bld_int_vec4, out);
      }
      else {
         /* TODO */
         assert(0);
      }
      size = lp_build_andnot(&bld_int_vec4, size, out);
   }
   for (i = 0; i < dims + (has_array ? 1 : 0); i++) {
      sizes_out[i] = lp_build_extract_broadcast(gallivm, bld_int_vec4.type, int_type,
                                                size,
                                                lp_build_const_int32(gallivm, i));
   }
   if (is_sviewinfo) {
      for (; i < 4; i++) {
         sizes_out[i] = lp_build_const_vec(gallivm, int_type, 0.0);
      }
   }

   /*
    * if there's no explicit_lod (buffers, rects) queries requiring nr of
    * mips would be illegal.
    */
   if (is_sviewinfo && explicit_lod) {
      struct lp_build_context bld_int_scalar;
      LLVMValueRef num_levels;
      lp_build_context_init(&bld_int_scalar, gallivm, lp_type_int(32));

      if (static_state->level_zero_only) {
         num_levels = bld_int_scalar.one;
      }
      else {
         LLVMValueRef last_level;

         last_level = dynamic_state->last_level(dynamic_state, gallivm, texture_unit);
         num_levels = lp_build_sub(&bld_int_scalar, last_level, first_level);
         num_levels = lp_build_add(&bld_int_scalar, num_levels, bld_int_scalar.one);
      }
      sizes_out[3] = lp_build_broadcast(gallivm, lp_build_vec_type(gallivm, int_type),
                                        num_levels);
   }
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d755 4
a758 8
   if (has_layer_coord(bld->static_texture_state->target)) {
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
         /* add cube layer to face */
         z = lp_build_add(&bld->int_coord_bld, coords[2], coords[3]);
      }
      else {
         z = coords[2];
      }
d871 1
a871 2
   seamless_cube_filter = (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
                           bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) &&
d926 4
a929 9
      if (has_layer_coord(bld->static_texture_state->target)) {
         if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
            /* add cube layer to face */
            z00 = z01 = z10 = z11 = z1 =
               lp_build_add(&bld->int_coord_bld, coords[2], coords[3]);
         }
         else {
            z00 = z01 = z10 = z11 = z1 = coords[2];  /* cube face or layer */
         }
a1049 8
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
         /* now can add cube layer to face (per sample) */
         z00 = lp_build_add(ivec_bld, z00, coords[3]);
         z01 = lp_build_add(ivec_bld, z01, coords[3]);
         z10 = lp_build_add(ivec_bld, z10, coords[3]);
         z11 = lp_build_add(ivec_bld, z11, coords[3]);
      }

d1073 4
a1076 13
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
         LLVMValueRef cube_layer = lp_build_add(ivec_bld, face, coords[3]);
         LLVMBuildStore(builder, cube_layer, zs[0]);
         LLVMBuildStore(builder, cube_layer, zs[1]);
         LLVMBuildStore(builder, cube_layer, zs[2]);
         LLVMBuildStore(builder, cube_layer, zs[3]);
      }
      else {
         LLVMBuildStore(builder, face, zs[0]);
         LLVMBuildStore(builder, face, zs[1]);
         LLVMBuildStore(builder, face, zs[2]);
         LLVMBuildStore(builder, face, zs[3]);
      }
a1646 1
                     boolean is_cube_array,
a1657 1
      assert(!is_cube_array);
d1666 1
a1666 3
      LLVMValueRef s = is_cube_array ? lp_build_const_int32(bld->gallivm, 6) :
                                       bld->int_bld.one;
      maxlayer = lp_build_sub(&bld->int_bld, num_layers, s);
d1706 1
a1706 1
   if (target == PIPE_TEXTURE_CUBE || target == PIPE_TEXTURE_CUBE_ARRAY) {
a1713 8
      if (target == PIPE_TEXTURE_CUBE_ARRAY) {
         /* calculate cube layer coord now */
         LLVMValueRef layer = lp_build_iround(&bld->coord_bld, coords[3]);
         LLVMValueRef six = lp_build_const_int_vec(bld->gallivm, bld->int_coord_type, 6);
         layer = lp_build_mul(&bld->int_coord_bld, layer, six);
         coords[3] = lp_build_layer_coord(bld, texture_index, TRUE, layer, NULL);
         /* because of seamless filtering can't add it to face (coords[2]) here. */
      }
d1718 1
a1718 1
      coords[2] = lp_build_layer_coord(bld, texture_index, FALSE, coords[2], NULL);
d1778 14
a1791 4
      first_level = bld->dynamic_state->first_level(bld->dynamic_state,
                                                    bld->gallivm, texture_index);
      first_level = lp_build_broadcast_scalar(&bld->leveli_bld, first_level);
      *ilevel0 = first_level;
d2236 1
a2236 1
         z = lp_build_layer_coord(bld, texture_unit, FALSE, z, &out1);
d2240 1
a2240 1
         z = lp_build_layer_coord(bld, texture_unit, FALSE, z, NULL);
d2476 1
a2476 2
       (static_texture_state->target == PIPE_TEXTURE_CUBE ||
        static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) &&
d2614 1
a2614 2
      if ((static_texture_state->target == PIPE_TEXTURE_CUBE ||
           static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) &&
a2643 7
      if (use_aos && static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
         /* The aos path doesn't do seamless filtering so simply add cube layer
          * to face now.
          */
         newcoords[2] = lp_build_add(&bld.int_coord_bld, newcoords[2], newcoords[3]);
      }

d2708 1
a2708 2
             (static_texture_state->target == PIPE_TEXTURE_CUBE ||
              static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) &&
a2903 1
   case PIPE_TEXTURE_CUBE_ARRAY:
d2945 3
a2947 12
   if (has_array) {
      LLVMValueRef layers = dynamic_state->depth(dynamic_state, gallivm, texture_unit);
      if (target == PIPE_TEXTURE_CUBE_ARRAY) {
         /*
          * It looks like GL wants number of cubes, d3d10.1 has it undefined?
          * Could avoid this by passing in number of cubes instead of total
          * number of layers (might make things easier elsewhere too).
          */
         LLVMValueRef six = lp_build_const_int32(gallivm, 6);
         layers = LLVMBuildSDiv(gallivm->builder, layers, six, "");
      }
      size = LLVMBuildInsertElement(gallivm->builder, size, layers,
a2948 1
   }
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d755 8
a762 4
   if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
       bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
       bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
      z = coords[2];
d875 2
a876 1
   seamless_cube_filter = bld->static_texture_state->target == PIPE_TEXTURE_CUBE &&
d931 9
a939 4
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
          bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
          bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
         z00 = z01 = z10 = z11 = z1 = coords[2];  /* cube face or layer */
d1060 8
d1091 13
a1103 4
      LLVMBuildStore(builder, face, zs[0]);
      LLVMBuildStore(builder, face, zs[1]);
      LLVMBuildStore(builder, face, zs[2]);
      LLVMBuildStore(builder, face, zs[3]);
d1674 1
d1686 1
d1695 3
a1697 1
      maxlayer = lp_build_sub(&bld->int_bld, num_layers, bld->int_bld.one);
d1737 1
a1737 1
   if (target == PIPE_TEXTURE_CUBE) {
d1745 8
d1757 1
a1757 1
      coords[2] = lp_build_layer_coord(bld, texture_index, coords[2], NULL);
d1817 4
a1820 14
      if (HAVE_LLVM == 0x0207 && target == PIPE_TEXTURE_CUBE) {
         /* XXX this is a work-around for an apparent bug in LLVM 2.7.
          * We should be able to set ilevel0 = const(0) but that causes
          * bad x86 code to be emitted.
          */
         assert(lod_ipart);
         lp_build_nearest_mip_level(bld, texture_index, lod_ipart, ilevel0, NULL);
      }
      else {
         first_level = bld->dynamic_state->first_level(bld->dynamic_state,
                                                       bld->gallivm, texture_index);
         first_level = lp_build_broadcast_scalar(&bld->leveli_bld, first_level);
         *ilevel0 = first_level;
      }
d2265 1
a2265 1
         z = lp_build_layer_coord(bld, texture_unit, z, &out1);
d2269 1
a2269 1
         z = lp_build_layer_coord(bld, texture_unit, z, NULL);
d2505 2
a2506 1
       (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
d2644 2
a2645 1
      if (static_texture_state->target == PIPE_TEXTURE_CUBE &&
d2675 7
d2746 2
a2747 1
             (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
d2943 1
d2985 12
a2996 3
   if (has_array)
      size = LLVMBuildInsertElement(gallivm->builder, size,
                                    dynamic_state->depth(dynamic_state, gallivm, texture_unit),
d2998 1
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d45 1
a75 1
                          unsigned sampler_unit,
d182 2
a183 4
      /* select texel color or border color depending on use_border */
      LLVMValueRef border_color_ptr = 
         bld->dynamic_state->border_color(bld->dynamic_state,
                                          bld->gallivm, sampler_unit);
d185 7
d193 19
a211 9
         LLVMValueRef border_chan =
            lp_build_array_get(bld->gallivm, border_color_ptr,
                               lp_build_const_int32(bld->gallivm, chan));
         LLVMValueRef border_chan_vec =
            lp_build_broadcast_scalar(&bld->float_vec_bld, border_chan);

         if (!bld->texel_type.floating) {
            border_chan_vec = LLVMBuildBitCast(builder, border_chan_vec,
                                               bld->texel_bld.vec_type, "");
a212 2
         texel_out[chan] = lp_build_select(&bld->texel_bld, use_border,
                                           border_chan_vec, texel_out[chan]);
d658 35
a697 1
                              unsigned sampler_unit,
d703 1
a703 3
                              LLVMValueRef s,
                              LLVMValueRef t,
                              LLVMValueRef r,
d734 2
a735 1
   x = lp_build_sample_wrap_nearest(bld, s, width_vec, flt_width_vec, offsets[0],
d741 2
a742 1
      y = lp_build_sample_wrap_nearest(bld, t, height_vec, flt_height_vec, offsets[1],
d748 2
a749 1
         z = lp_build_sample_wrap_nearest(bld, r, depth_vec, flt_depth_vec, offsets[2],
d758 1
a758 1
      z = r;
d765 1
a765 1
   lp_build_sample_texel_soa(bld, sampler_unit,
d770 53
d825 5
d834 2
a838 1
                             unsigned sampler_unit,
d840 1
d845 1
a845 3
                             LLVMValueRef s,
                             LLVMValueRef t,
                             LLVMValueRef r,
d849 3
d860 5
a864 1
   LLVMValueRef x0, y0 = NULL, z0 = NULL, x1, y1 = NULL, z1 = NULL;
d866 1
d868 6
a873 1
   int chan;
a891 6
   lp_build_sample_wrap_linear(bld, s, width_vec, flt_width_vec, offsets[0],
                               bld->static_texture_state->pot_width,
                               bld->static_sampler_state->wrap_s,
                               &x0, &x1, &s_fpart);
   lp_build_name(x0, "tex.x0.wrapped");
   lp_build_name(x1, "tex.x1.wrapped");
d893 10
a902 7
   if (dims >= 2) {
      lp_build_sample_wrap_linear(bld, t, height_vec, flt_height_vec, offsets[1],
                                  bld->static_texture_state->pot_height,
                                  bld->static_sampler_state->wrap_t,
                                  &y0, &y1, &t_fpart);
      lp_build_name(y0, "tex.y0.wrapped");
      lp_build_name(y1, "tex.y1.wrapped");
d904 28
a931 7
      if (dims == 3) {
         lp_build_sample_wrap_linear(bld, r, depth_vec, flt_depth_vec, offsets[2],
                                     bld->static_texture_state->pot_depth,
                                     bld->static_sampler_state->wrap_r,
                                     &z0, &z1, &r_fpart);
         lp_build_name(z0, "tex.z0.wrapped");
         lp_build_name(z1, "tex.z1.wrapped");
d934 158
a1091 6
   if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
       bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
       bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
      z0 = z1 = r;  /* cube face or array layer */
      lp_build_name(z0, "tex.z0.layer");
      lp_build_name(z1, "tex.z1.layer");
d1094 25
d1124 1
a1124 1
   lp_build_sample_texel_soa(bld, sampler_unit,
d1126 1
a1126 1
                             x0, y0, z0,
d1129 1
a1129 1
   lp_build_sample_texel_soa(bld, sampler_unit,
d1131 1
a1131 1
                             x1, y0, z0,
d1136 17
a1152 6
      /* Interpolate two samples from 1D image to produce one color */
      for (chan = 0; chan < 4; chan++) {
         colors_out[chan] = lp_build_lerp(&bld->texel_bld, s_fpart,
                                          neighbors[0][0][chan],
                                          neighbors[0][1][chan],
                                          0);
d1157 2
a1158 1
      LLVMValueRef colors0[4];
d1161 1
a1161 1
      lp_build_sample_texel_soa(bld, sampler_unit,
d1163 1
a1163 1
                                x0, y1, z0,
d1166 1
a1166 1
      lp_build_sample_texel_soa(bld, sampler_unit,
d1168 1
a1168 1
                                x1, y1, z0,
d1172 139
a1310 9
      /* Bilinear interpolate the four samples from the 2D image / 3D slice */
      for (chan = 0; chan < 4; chan++) {
         colors0[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                          s_fpart, t_fpart,
                                          neighbors[0][0][chan],
                                          neighbors[0][1][chan],
                                          neighbors[1][0][chan],
                                          neighbors[1][1][chan],
                                          0);
d1318 1
a1318 1
         lp_build_sample_texel_soa(bld, sampler_unit,
d1320 1
a1320 1
                                   x0, y0, z1,
d1323 1
a1323 1
         lp_build_sample_texel_soa(bld, sampler_unit,
d1325 1
a1325 1
                                   x1, y0, z1,
d1328 1
a1328 1
         lp_build_sample_texel_soa(bld, sampler_unit,
d1330 1
a1330 1
                                   x0, y1, z1,
d1333 1
a1333 1
         lp_build_sample_texel_soa(bld, sampler_unit,
d1335 1
a1335 1
                                   x1, y1, z1,
d1339 18
a1356 9
         /* Bilinear interpolate the four samples from the second Z slice */
         for (chan = 0; chan < 4; chan++) {
            colors1[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                             s_fpart, t_fpart,
                                             neighbors1[0][0][chan],
                                             neighbors1[0][1][chan],
                                             neighbors1[1][0][chan],
                                             neighbors1[1][1][chan],
                                             0);
d1358 10
a1367 4

         /* Linearly interpolate the two samples from the two 3D slices */
         for (chan = 0; chan < 4; chan++) {
            colors_out[chan] = lp_build_lerp(&bld->texel_bld,
d1369 1
a1369 1
                                             colors0[chan], colors1[chan],
d1371 1
d1386 2
a1387 2
 * data0_ptr and data1_ptr point to the two mipmap levels to sample
 * from.  width0/1_vec, height0/1_vec, depth0/1_vec indicate their sizes.
a1391 1
                       unsigned sampler_unit,
d1394 1
a1394 3
                       LLVMValueRef s,
                       LLVMValueRef t,
                       LLVMValueRef r,
d1419 1
a1419 1
   if (bld->num_lods == 1) {
d1428 1
a1428 2
      lp_build_sample_image_nearest(bld, sampler_unit,
                                    size0,
d1430 1
a1430 1
                                    data_ptr0, mipoff0, s, t, r, offsets,
d1435 1
a1435 2
      lp_build_sample_image_linear(bld, sampler_unit,
                                   size0,
d1437 1
a1437 1
                                   data_ptr0, mipoff0, s, t, r, offsets,
d1453 1
a1453 1
                                   lod_fpart, bld->levelf_bld.zero,
d1461 1
a1461 1
          * quads which need it.
d1463 8
d1476 2
a1477 10
         lod_fpart = lp_build_max(&bld->levelf_bld, lod_fpart,
                                  bld->levelf_bld.zero);
         need_lerp = lp_build_compare(bld->gallivm, bld->levelf_bld.type,
                                      PIPE_FUNC_GREATER,
                                      lod_fpart, bld->levelf_bld.zero);
         need_lerp = lp_build_any_true_range(&bld->leveli_bld, bld->num_lods, need_lerp);
      }

      lp_build_if(&if_ctx, bld->gallivm, need_lerp);
      {
d1482 1
a1482 1
         if (bld->num_lods == 1) {
d1490 1
a1490 2
            lp_build_sample_image_nearest(bld, sampler_unit,
                                          size1,
d1492 1
a1492 1
                                          data_ptr1, mipoff1, s, t, r, offsets,
d1496 1
a1496 2
            lp_build_sample_image_linear(bld, sampler_unit,
                                         size1,
d1498 1
a1498 1
                                         data_ptr1, mipoff1, s, t, r, offsets,
d1506 1
a1506 1
                                                              bld->levelf_bld.type,
d1523 120
a1642 1
 * Clamp layer coord to valid values.
d1647 2
a1648 1
                     LLVMValueRef layer)
d1650 2
a1651 1
   LLVMValueRef maxlayer;
d1653 2
a1654 6
   maxlayer = bld->dynamic_state->depth(bld->dynamic_state,
                                        bld->gallivm, texture_unit);
   maxlayer = lp_build_sub(&bld->int_bld, maxlayer, bld->int_bld.one);
   maxlayer = lp_build_broadcast_scalar(&bld->int_coord_bld, maxlayer);
   return lp_build_clamp(&bld->int_coord_bld, layer,
                         bld->int_coord_bld.zero, maxlayer);
d1656 14
d1680 1
a1680 3
                       LLVMValueRef *s,
                       LLVMValueRef *t,
                       LLVMValueRef *r,
d1684 1
a1684 1
                       LLVMValueRef *lod_ipart,
d1694 2
a1706 1
      LLVMValueRef face, face_s, face_t;
d1712 31
a1742 14
      lp_build_cube_lookup(bld, *s, *t, *r, derivs, &face, &face_s, &face_t,
                           &cube_rho, need_derivs);
      *s = face_s; /* vec */
      *t = face_t; /* vec */
      /* use 'r' to indicate cube face */
      *r = face; /* vec */
   }
   else if (target == PIPE_TEXTURE_1D_ARRAY) {
      *r = lp_build_iround(&bld->coord_bld, *t);
      *r = lp_build_layer_coord(bld, texture_index, *r);
   }
   else if (target == PIPE_TEXTURE_2D_ARRAY) {
      *r = lp_build_iround(&bld->coord_bld, *r);
      *r = lp_build_layer_coord(bld, texture_index, *r);
d1754 1
a1754 1
                            *s, *t, *r, cube_rho,
d1757 1
a1757 1
                            lod_ipart, lod_fpart);
d1759 8
a1766 1
      *lod_ipart = bld->leveli_bld.zero;
d1783 2
a1784 2
         assert(*lod_ipart);
         lp_build_nearest_mip_level(bld, texture_index, *lod_ipart, ilevel0);
d1794 2
a1795 2
      assert(*lod_ipart);
      lp_build_nearest_mip_level(bld, texture_index, *lod_ipart, ilevel0);
d1798 1
a1798 1
      assert(*lod_ipart);
d1801 1
a1801 1
                                 *lod_ipart, lod_fpart,
d1807 219
d2034 1
a2034 3
                        LLVMValueRef s,
                        LLVMValueRef t,
                        LLVMValueRef r,
d2036 1
a2036 1
                        LLVMValueRef lod_ipart,
a2041 1
   struct lp_build_context *int_bld = &bld->int_bld;
d2043 4
a2046 3
   const unsigned mip_filter = bld->static_sampler_state->min_mip_filter;
   const unsigned min_filter = bld->static_sampler_state->min_img_filter;
   const unsigned mag_filter = bld->static_sampler_state->mag_img_filter;
d2050 16
d2077 2
a2078 3
      lp_build_sample_mipmap(bld, sampler_unit,
                             min_filter, mip_filter,
                             s, t, r, offsets,
d2083 3
a2085 2
      /* Emit conditional to choose min image filter or mag image filter
       * depending on the lod being > 0 or <= 0, respectively.
d2087 5
a2091 2
      struct lp_build_if_state if_ctx;
      LLVMValueRef minify;
d2093 2
a2094 16
      /*
       * XXX this should to all lods into account, if some are min
       * some max probably could hack up the coords/weights in the linear
       * path with selects to work for nearest.
       * If that's just two quads sitting next to each other it seems
       * quite ok to do the same filtering method on both though, at
       * least unless we have explicit lod (and who uses different
       * min/mag filter with that?)
       */
      if (bld->num_lods > 1)
         lod_ipart = LLVMBuildExtractElement(builder, lod_ipart,
                                             lp_build_const_int32(bld->gallivm, 0), "");

      /* minify = lod >= 0.0 */
      minify = LLVMBuildICmp(builder, LLVMIntSGE,
                             lod_ipart, int_bld->zero, "");
d2096 17
a2112 8
      lp_build_if(&if_ctx, bld->gallivm, minify);
      {
         /* Use the minification filter */
         lp_build_sample_mipmap(bld, sampler_unit,
                                min_filter, mip_filter,
                                s, t, r, offsets,
                                ilevel0, ilevel1, lod_fpart,
                                texels);
d2114 53
a2166 8
      lp_build_else(&if_ctx);
      {
         /* Use the magnification filter */
         lp_build_sample_mipmap(bld, sampler_unit,
                                mag_filter, PIPE_TEX_MIPFILTER_NONE,
                                s, t, r, offsets,
                                ilevel0, NULL, NULL,
                                texels);
a2167 1
      lp_build_endif(&if_ctx);
d2193 1
a2193 1
   struct lp_build_context *perquadi_bld = &bld->leveli_bld;
d2197 1
d2204 2
d2207 1
a2207 1
      if (bld->num_lods != int_coord_bld->type.length) {
d2214 2
a2215 1
      lp_build_nearest_mip_level(bld, texture_unit, ilevel, &ilevel);
d2218 8
a2225 2
      bld->num_lods = 1;
      ilevel = lp_build_const_int32(bld->gallivm, 0);
d2235 3
a2237 2
      if (target == PIPE_TEXTURE_1D_ARRAY) {
         z = lp_build_layer_coord(bld, texture_unit, y);
d2240 1
a2240 1
         z = lp_build_layer_coord(bld, texture_unit, z);
d2246 4
a2249 1
      /* XXX coords are really unsigned, offsets are signed */
d2252 2
a2253 1
   out_of_bounds = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, x, int_coord_bld->zero);
d2296 1
a2296 1
   if (0) {
d2298 1
a2298 1
       * Not needed except for ARB_robust_buffer_access_behavior.
a2299 1
       * (in fact cast to unsigned and min only is sufficient)
a2310 54
 * Do shadow test/comparison.
 * \param coords  incoming texcoords
 * \param texel  the texel to compare against (use the X channel)
 * Ideally this should really be done per-sample.
 */
static void
lp_build_sample_compare(struct lp_build_sample_context *bld,
                        const LLVMValueRef *coords,
                        LLVMValueRef texel[4])
{
   struct lp_build_context *texel_bld = &bld->texel_bld;
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef res, p;
   const unsigned chan = 0;

   if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE)
      return;

   if (bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY ||
       bld->static_texture_state->target == PIPE_TEXTURE_CUBE) {
      p = coords[3];
   }
   else {
      p = coords[2];
   }

   /* debug code */
   if (0) {
      LLVMValueRef indx = lp_build_const_int32(bld->gallivm, 0);
      LLVMValueRef coord = LLVMBuildExtractElement(builder, p, indx, "");
      LLVMValueRef tex = LLVMBuildExtractElement(builder, texel[chan], indx, "");
      lp_build_printf(bld->gallivm, "shadow compare coord %f to texture %f\n",
                      coord, tex);
   }

   /* Clamp p coords to [0,1] */
   p = lp_build_clamp(&bld->coord_bld, p,
                      bld->coord_bld.zero,
                      bld->coord_bld.one);

   /* result = (p FUNC texel) ? 1 : 0 */
   res = lp_build_cmp(texel_bld, bld->static_sampler_state->compare_func,
                      p, texel[chan]);
   res = lp_build_select(texel_bld, res, texel_bld->one, texel_bld->zero);

   /* XXX returning result for default GL_DEPTH_TEXTURE_MODE = GL_LUMINANCE */
   texel[0] =
   texel[1] =
   texel[2] = res;
   texel[3] = texel_bld->one;
}


/**
d2351 1
a2351 1
                    boolean scalar_lod,
d2354 2
a2355 1
   unsigned dims = texture_dims(static_texture_state->target);
d2357 1
a2357 1
   unsigned mip_filter;
d2362 1
a2362 4
   LLVMValueRef tex_width;
   LLVMValueRef s;
   LLVMValueRef t;
   LLVMValueRef r;
d2369 13
d2433 21
d2472 15
a2486 3
   if (explicit_lod && !scalar_lod &&
       ((is_fetch && bld.static_texture_state->target != PIPE_BUFFER) ||
        (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)))
d2488 13
d2502 1
a2502 1
   else if ((is_fetch && explicit_lod && bld.static_texture_state->target != PIPE_BUFFER ) ||
d2504 1
d2507 3
a2509 2
   else {
      bld.num_lods = 1;
d2512 2
a2513 1
   bld.levelf_type = type;
d2516 7
a2522 1
      bld.levelf_type.length = type.length > 4 ? ((type.length + 15) / 16) * 4 : 1;
d2528 3
a2530 3
   if (bld.num_lods > 1) {
      bld.float_size_type.length = bld.num_lods == type.length ?
                                      bld.num_lods * bld.float_size_in_type.length :
d2547 2
a2557 4
   s = coords[0];
   t = coords[1];
   r = coords[2];

d2579 4
d2587 1
a2587 1
                          coords,
d2592 1
a2592 1
      lp_build_fetch_texel(&bld, texture_index, coords,
d2598 1
a2598 1
      LLVMValueRef lod_ipart = NULL, lod_fpart = NULL;
d2601 20
a2620 2
                        lp_is_simple_wrap_mode(static_sampler_state->wrap_s) &&
                        lp_is_simple_wrap_mode(static_sampler_state->wrap_t);
d2626 10
a2635 6
         debug_printf("  min_img %d  mag_img %d  mip %d  wraps %d  wrapt %d\n",
                      static_sampler_state->min_img_filter,
                      static_sampler_state->mag_img_filter,
                      static_sampler_state->min_mip_filter,
                      static_sampler_state->wrap_s,
                      static_sampler_state->wrap_t);
d2639 1
a2639 1
                             &s, &t, &r,
d2641 1
a2641 1
                             &lod_ipart, &lod_fpart,
d2646 2
a2647 1
       * be a loss with aos with AVX (but it should work).
a2650 12

         if (num_quads > 1) {
            if (mip_filter == PIPE_TEX_MIPFILTER_NONE) {
               LLVMValueRef index0 = lp_build_const_int32(gallivm, 0);
               /*
                * These parameters are the same for all quads,
                * could probably simplify.
                */
               lod_ipart = LLVMBuildExtractElement(builder, lod_ipart, index0, "");
               ilevel0 = LLVMBuildExtractElement(builder, ilevel0, index0, "");
            }
         }
d2654 3
a2656 2
                                s, t, r, offsets,
                                lod_ipart, lod_fpart,
d2663 2
a2664 2
                                    s, t, r, offsets,
                                    lod_ipart, lod_fpart,
a2703 4
         bld4.levelf_type = type4;
         /* we want native vector size to be able to use our intrinsics */
         bld4.levelf_type.length = 1;
         bld4.leveli_type = lp_int_type(bld4.levelf_type);
d2705 6
a2710 3
         if (explicit_lod && !scalar_lod &&
             ((is_fetch && bld.static_texture_state->target != PIPE_BUFFER) ||
              (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)))
d2712 13
a2724 2
         else
            bld4.num_lods = 1;
a2725 1
         bld4.levelf_type = type4;
d2727 1
d2729 5
d2738 3
a2740 3
         if (bld4.num_lods > 1) {
            bld4.float_size_type.length = bld4.num_lods == type4.length ?
                                            bld4.num_lods * bld4.float_size_in_type.length :
d2757 2
d2762 1
a2762 1
            LLVMValueRef lod_ipart4, lod_fpart4 = NULL;
d2767 3
a2769 3
            s4 = lp_build_extract_range(gallivm, s, 4*i, 4);
            t4 = lp_build_extract_range(gallivm, t, 4*i, 4);
            r4 = lp_build_extract_range(gallivm, r, 4*i, 4);
d2780 3
a2782 2
            lod_ipart4 = lp_build_extract_range(gallivm, lod_ipart, num_lods * i, num_lods);
            ilevel04 = lp_build_extract_range(gallivm, ilevel0, num_lods * i, num_lods);
d2792 1
a2792 1
                                   lod_ipart4, lod_fpart4,
d2798 8
d2807 2
a2808 2
                                       s4, t4, r4, offsets4,
                                       lod_ipart4, lod_fpart4,
a2820 2

      lp_build_sample_compare(&bld, coords, texel_out);
d2823 1
a2823 1
   if (static_texture_state->target != PIPE_BUFFER) {
d2846 3
a2848 1
                        boolean need_nr_mips,
d2852 1
a2852 2
   LLVMValueRef lod;
   LLVMValueRef size;
d2856 42
a2897 1
   struct lp_build_context bld_int_vec;
d2899 1
a2899 1
   dims = texture_dims(static_state->target);
d2901 1
a2901 1
   switch (static_state->target) {
d2913 1
a2913 1
   lp_build_context_init(&bld_int_vec, gallivm, lp_type_int_vec(32, 128));
d2919 2
a2920 3
      lod = lp_build_broadcast_scalar(&bld_int_vec,
                                      LLVMBuildAdd(gallivm->builder, lod, first_level, "lod"));

d2922 1
a2922 1
      lod = bld_int_vec.zero;
d2925 1
a2925 6
   if (need_nr_mips) {
      size = bld_int_vec.zero;
   }
   else {
      size = bld_int_vec.undef;
   }
d2943 1
a2943 1
   size = lp_build_minify(&bld_int_vec, size, lod);
d2951 3
a2953 2
    * XXX for out-of-bounds lod, should set size to zero vector here
    * (for dx10-style only, i.e. need_nr_mips)
d2955 20
a2974 1

d2976 1
a2976 1
      sizes_out[i] = lp_build_extract_broadcast(gallivm, bld_int_vec.type, int_type,
d2980 5
d2990 1
a2990 1
   if (need_nr_mips && explicit_lod) {
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d38 1
d44 1
d61 1
d75 1
a75 1
                          unsigned unit,
d85 1
d88 1
a88 1
   const struct lp_sampler_static_state *static_state = bld->static_state;
d143 3
d185 1
a185 1
                                          bld->gallivm, unit);
d193 5
d235 35
d280 1
a295 6
      /* mul by size and subtract 0.5 */
      coord = lp_build_mul(coord_bld, coord, length_f);
      coord = lp_build_sub(coord_bld, coord, half);
      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
      /* repeat wrap */
d297 9
d307 1
a311 2
         /* Add a bias to the texcoord to handle negative coords */
         LLVMValueRef bias = lp_build_mul_imm(int_coord_bld, length, 1024);
d313 9
a321 3
         coord0 = LLVMBuildAdd(builder, coord0, bias, "");
         coord0 = LLVMBuildURem(builder, coord0, length, "");
         mask = lp_build_compare(bld->gallivm, int_coord_bld->type,
d324 2
a325 2
                              lp_build_add(int_coord_bld, coord0, int_coord_bld->one),
                              mask, "");
d330 1
a330 1
      if (bld->static_state->normalized_coords) {
d334 4
d354 1
a354 1
         if (bld->static_state->normalized_coords) {
d358 5
d378 7
a384 13
      {
         LLVMValueRef min;
         if (bld->static_state->normalized_coords) {
            /* scale coord to length */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }
         /* was: clamp to [-0.5, length + 0.5], then sub 0.5 */
         coord = lp_build_sub(coord_bld, coord, half);
         min = lp_build_const_vec(bld->gallivm, coord_bld->type, -1.0F);
         coord = lp_build_clamp(coord_bld, coord, min, length_f);
         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
         coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
d386 6
d401 4
d417 1
a417 3
      coord = lp_build_abs(coord_bld, coord);

      if (bld->static_state->normalized_coords) {
d421 5
a438 1
         LLVMValueRef min, max;
a440 1
         coord = lp_build_abs(coord_bld, coord);
d442 1
a442 1
         if (bld->static_state->normalized_coords) {
d446 5
d452 3
a454 5
         /* clamp to [0.5, length - 0.5] */
         min = half;
         max = lp_build_sub(coord_bld, length_f, min);
         coord = lp_build_clamp(coord_bld, coord, min, max);

d456 2
d462 2
d469 1
a469 3
         coord = lp_build_abs(coord_bld, coord);

         if (bld->static_state->normalized_coords) {
d473 5
d480 2
a481 1
         /* skip -0.5 clamp (always positive), do sub first */
a482 1
         coord = lp_build_min(coord_bld, coord, length_f);
d507 2
d517 1
d529 6
a534 3
      coord = lp_build_mul(coord_bld, coord, length_f);
      icoord = lp_build_ifloor(coord_bld, coord);
      if (is_pot)
d536 1
d538 9
a546 4
         /* Add a bias to the texcoord to handle negative coords */
         LLVMValueRef bias = lp_build_mul_imm(int_coord_bld, length, 1024);
         icoord = LLVMBuildAdd(builder, icoord, bias, "");
         icoord = LLVMBuildURem(builder, icoord, length, "");
d552 1
a552 1
      if (bld->static_state->normalized_coords) {
d560 3
d570 8
a577 15
      /* Note: this is the same as CLAMP_TO_EDGE, except min = -min */
      {
         LLVMValueRef min, max;

         if (bld->static_state->normalized_coords) {
            /* scale coord to length */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }

         icoord = lp_build_ifloor(coord_bld, coord);

         /* clamp to [-1, length] */
         min = lp_build_negate(int_coord_bld, int_coord_bld->one);
         max = length;
         icoord = lp_build_clamp(int_coord_bld, icoord, min, max);
d582 5
d591 1
a591 1
      assert(bld->static_state->normalized_coords);
d603 1
a603 3
      coord = lp_build_abs(coord_bld, coord);

      if (bld->static_state->normalized_coords) {
d607 5
d621 1
a621 3
      coord = lp_build_abs(coord_bld, coord);

      if (bld->static_state->normalized_coords) {
d625 5
a632 3

      /* clamp to [0, length] */
      icoord = lp_build_min(int_coord_bld, icoord, length);
d650 1
a650 1
                              unsigned unit,
d655 1
d659 1
d670 1
a670 1
   LLVMValueRef x, y, z;
d673 1
a673 1
                                bld->int_size_type,
d681 1
a681 1
                                bld->float_size_type,
d689 3
a691 3
   x = lp_build_sample_wrap_nearest(bld, s, width_vec, flt_width_vec,
                                    bld->static_state->pot_width,
                                    bld->static_state->wrap_s);
d695 3
a697 3
      y = lp_build_sample_wrap_nearest(bld, t, height_vec, flt_height_vec,
                                       bld->static_state->pot_height,
                                       bld->static_state->wrap_t);
d701 3
a703 3
         z = lp_build_sample_wrap_nearest(bld, r, depth_vec, flt_depth_vec,
                                          bld->static_state->pot_depth,
                                          bld->static_state->wrap_r);
a705 6
      else if (bld->static_state->target == PIPE_TEXTURE_CUBE) {
         z = r;
      }
      else {
         z = NULL;
      }
d707 5
a711 2
   else {
      y = z = NULL;
d717 1
a717 1
   lp_build_sample_texel_soa(bld, unit,
d721 1
a721 1
                             data_ptr, colors_out);
d731 1
a731 1
                             unsigned unit,
d736 1
d740 1
d751 2
a752 2
   LLVMValueRef x0, y0, z0, x1, y1, z1;
   LLVMValueRef s_fpart, t_fpart, r_fpart;
d757 1
a757 1
                                bld->int_size_type,
d765 1
a765 1
                                bld->float_size_type,
d773 3
a775 3
   lp_build_sample_wrap_linear(bld, s, width_vec, flt_width_vec,
                               bld->static_state->pot_width,
                               bld->static_state->wrap_s,
d781 3
a783 3
      lp_build_sample_wrap_linear(bld, t, height_vec, flt_height_vec,
                                  bld->static_state->pot_height,
                                  bld->static_state->wrap_t,
d789 3
a791 3
         lp_build_sample_wrap_linear(bld, r, depth_vec, flt_depth_vec,
                                     bld->static_state->pot_depth,
                                     bld->static_state->wrap_r,
a795 8
      else if (bld->static_state->target == PIPE_TEXTURE_CUBE) {
         z0 = z1 = r;  /* cube face */
         r_fpart = NULL;
      }
      else {
         z0 = z1 = NULL;
         r_fpart = NULL;
      }
d797 6
a802 3
   else {
      y0 = y1 = t_fpart = NULL;
      z0 = z1 = r_fpart = NULL;
d805 1
d810 1
a810 1
   lp_build_sample_texel_soa(bld, unit,
d814 2
a815 2
                             data_ptr, neighbors[0][0]);
   lp_build_sample_texel_soa(bld, unit,
d819 1
a819 1
                             data_ptr, neighbors[0][1]);
d826 2
a827 1
                                          neighbors[0][1][chan]);
d835 1
a835 1
      lp_build_sample_texel_soa(bld, unit,
d839 2
a840 2
                                data_ptr, neighbors[1][0]);
      lp_build_sample_texel_soa(bld, unit,
d844 1
a844 1
                                data_ptr, neighbors[1][1]);
d853 2
a854 1
                                          neighbors[1][1][chan]);
d862 1
a862 1
         lp_build_sample_texel_soa(bld, unit,
d866 2
a867 2
                                   data_ptr, neighbors1[0][0]);
         lp_build_sample_texel_soa(bld, unit,
d871 2
a872 2
                                   data_ptr, neighbors1[0][1]);
         lp_build_sample_texel_soa(bld, unit,
d876 2
a877 2
                                   data_ptr, neighbors1[1][0]);
         lp_build_sample_texel_soa(bld, unit,
d881 1
a881 1
                                   data_ptr, neighbors1[1][1]);
d890 2
a891 1
                                             neighbors1[1][1][chan]);
d898 2
a899 1
                                             colors0[chan], colors1[chan]);
d920 1
a920 1
                       unsigned unit,
d926 1
d941 2
d950 8
a957 1
   data_ptr0 = lp_build_get_mipmap_level(bld, ilevel0);
d959 1
a959 1
      lp_build_sample_image_nearest(bld, unit,
d962 1
a962 1
                                    data_ptr0, s, t, r,
d967 1
a967 1
      lp_build_sample_image_linear(bld, unit,
d970 1
a970 1
                                   data_ptr0, s, t, r,
d984 24
a1007 4
      need_lerp = LLVMBuildFCmp(builder, LLVMRealUGT,
                                lod_fpart,
                                bld->float_bld.zero,
                                "need_lerp");
d1015 7
a1021 1
         data_ptr1 = lp_build_get_mipmap_level(bld, ilevel1);
d1023 1
a1023 1
            lp_build_sample_image_nearest(bld, unit,
d1026 1
a1026 1
                                          data_ptr1, s, t, r,
d1030 1
a1030 1
            lp_build_sample_image_linear(bld, unit,
d1033 1
a1033 1
                                         data_ptr1, s, t, r,
d1039 5
a1043 1
         lod_fpart = lp_build_broadcast_scalar(&bld->texel_bld, lod_fpart);
d1047 2
a1048 1
                                          colors0[chan], colors1[chan]);
d1057 19
d1078 1
a1078 3
 * General texture sampling codegen.
 * This function handles texture sampling for all texture targets (1D,
 * 2D, 3D, cube) and all filtering modes.
d1081 13
a1093 10
lp_build_sample_general(struct lp_build_sample_context *bld,
                        unsigned unit,
                        LLVMValueRef s,
                        LLVMValueRef t,
                        LLVMValueRef r,
                        const LLVMValueRef *ddx,
                        const LLVMValueRef *ddy,
                        LLVMValueRef lod_bias, /* optional */
                        LLVMValueRef explicit_lod, /* optional */
                        LLVMValueRef *colors_out)
d1095 5
a1099 12
   struct lp_build_context *int_bld = &bld->int_bld;
   LLVMBuilderRef builder = bld->gallivm->builder;
   const unsigned mip_filter = bld->static_state->min_mip_filter;
   const unsigned min_filter = bld->static_state->min_img_filter;
   const unsigned mag_filter = bld->static_state->mag_img_filter;
   LLVMValueRef lod_ipart = NULL, lod_fpart = NULL;
   LLVMValueRef ilevel0, ilevel1 = NULL;
   LLVMValueRef face_ddx[4], face_ddy[4];
   LLVMValueRef texels[4];
   LLVMValueRef first_level;
   LLVMValueRef i32t_zero = lp_build_const_int32(bld->gallivm, 0);
   unsigned chan;
d1107 2
a1108 1
    * Choose cube face, recompute texcoords and derivatives for the chosen face.
d1110 1
a1110 1
   if (bld->static_state->target == PIPE_TEXTURE_CUBE) {
d1112 9
a1120 3
      lp_build_cube_lookup(bld, s, t, r, &face, &face_s, &face_t);
      s = face_s; /* vec */
      t = face_t; /* vec */
d1122 9
a1130 13
      r = lp_build_broadcast_scalar(&bld->int_coord_bld, face); /* vec */

      /* recompute ddx, ddy using the new (s,t) face texcoords */
      face_ddx[0] = lp_build_scalar_ddx(&bld->coord_bld, s);
      face_ddx[1] = lp_build_scalar_ddx(&bld->coord_bld, t);
      face_ddx[2] = NULL;
      face_ddx[3] = NULL;
      face_ddy[0] = lp_build_scalar_ddy(&bld->coord_bld, s);
      face_ddy[1] = lp_build_scalar_ddy(&bld->coord_bld, t);
      face_ddy[2] = NULL;
      face_ddy[3] = NULL;
      ddx = face_ddx;
      ddy = face_ddy;
d1141 3
a1143 2
      lp_build_lod_selector(bld, unit, ddx, ddy,
                            lod_bias, explicit_lod,
d1145 1
a1145 1
                            &lod_ipart, &lod_fpart);
d1147 1
a1147 1
      lod_ipart = i32t_zero;
d1159 1
a1159 1
      if (bld->static_state->target == PIPE_TEXTURE_CUBE) {
d1164 2
a1165 2
         assert(lod_ipart);
         lp_build_nearest_mip_level(bld, unit, lod_ipart, &ilevel0);
d1169 3
a1171 2
                                                       bld->gallivm, unit);
         ilevel0 = first_level;
d1175 2
a1176 2
      assert(lod_ipart);
      lp_build_nearest_mip_level(bld, unit, lod_ipart, &ilevel0);
d1179 5
a1183 5
      assert(lod_ipart);
      assert(lod_fpart);
      lp_build_linear_mip_levels(bld, unit,
                                 lod_ipart, &lod_fpart,
                                 &ilevel0, &ilevel1);
d1186 27
d1220 1
a1220 1
     lp_build_name(texels[chan], "sampler%u_texel_%c_var", unit, "xyzw"[chan]);
d1224 2
a1225 2
      /* no need to distinquish between minification and magnification */
      lp_build_sample_mipmap(bld, unit,
d1227 1
a1227 1
                             s, t, r,
d1238 13
d1258 1
a1258 1
         lp_build_sample_mipmap(bld, unit,
d1260 1
a1260 1
                                s, t, r,
d1267 1
a1267 1
         lp_build_sample_mipmap(bld, unit,
d1269 1
a1269 1
                                s, t, r,
d1278 120
a1397 1
     lp_build_name(colors_out[chan], "sampler%u_texel_%c", unit, "xyzw"[chan]);
d1404 1
a1404 1
 * \param p  the texcoord Z (aka R, aka P) component
d1406 1
d1410 1
a1410 1
                        LLVMValueRef p,
d1415 1
a1415 1
   LLVMValueRef res;
d1418 1
a1418 1
   if (bld->static_state->compare_mode == PIPE_TEX_COMPARE_NONE)
d1421 8
d1444 1
a1444 1
   res = lp_build_cmp(texel_bld, bld->static_state->compare_func,
d1461 3
a1463 1
lp_build_sample_nop(struct gallivm_state *gallivm, struct lp_type type,
d1480 2
a1481 2
 * \param ddx  partial derivatives of (s,t,r,q) with respect to x
 * \param ddy  partial derivatives of (s,t,r,q) with respect to y
d1485 2
a1486 1
                    const struct lp_sampler_static_state *static_state,
d1489 3
a1491 2
                    unsigned unit,
                    unsigned num_coords,
d1493 2
a1494 2
                    const LLVMValueRef ddx[4],
                    const LLVMValueRef ddy[4],
d1497 1
d1500 3
a1502 1
   unsigned dims = texture_dims(static_state->target);
d1504 1
d1507 1
a1510 1
   struct lp_type float_vec_type;
d1513 1
a1513 1
      enum pipe_format fmt = static_state->format;
d1522 2
a1523 1
   bld.static_state = static_state;
d1525 1
a1525 1
   bld.format_desc = util_format_description(static_state->format);
d1528 2
d1534 3
a1536 3
   bld.float_size_type = lp_type_float(32);
   bld.float_size_type.length = dims > 1 ? 4 : 1;
   bld.int_size_type = lp_int_type(bld.float_size_type);
d1539 75
a1613 1
   float_vec_type = lp_type_float_vec(32);
d1616 1
a1616 1
   lp_build_context_init(&bld.float_vec_bld, gallivm, float_vec_type);
d1620 2
d1625 2
d1629 6
a1634 7
   bld.width = dynamic_state->width(dynamic_state, gallivm, unit);
   bld.height = dynamic_state->height(dynamic_state, gallivm, unit);
   bld.depth = dynamic_state->depth(dynamic_state, gallivm, unit);
   bld.row_stride_array = dynamic_state->row_stride(dynamic_state, gallivm, unit);
   bld.img_stride_array = dynamic_state->img_stride(dynamic_state, gallivm, unit);
   bld.data_array = dynamic_state->data_ptr(dynamic_state, gallivm, unit);
   /* Note that data_array is an array[level] of pointers to texture images */
d1642 1
a1642 1
      bld.int_size = bld.width;
d1645 2
a1646 2
      bld.int_size = LLVMBuildInsertElement(builder, bld.int_size_bld.undef,
                                            bld.width, LLVMConstInt(i32t, 0, 0), "");
d1648 2
d1651 1
a1651 1
                                               bld.height, LLVMConstInt(i32t, 1, 0), "");
d1653 2
d1656 1
a1656 1
                                                  bld.depth, LLVMConstInt(i32t, 2, 0), "");
d1663 4
a1666 1
      lp_build_sample_nop(gallivm, bld.texel_type, texel_out);
d1668 5
a1672 7
   else if (util_format_fits_8unorm(bld.format_desc) &&
            lp_is_simple_wrap_mode(static_state->wrap_s) &&
            lp_is_simple_wrap_mode(static_state->wrap_t)) {
      /* do sampling/filtering with fixed pt arithmetic */
      lp_build_sample_aos(&bld, unit, s, t, r, ddx, ddy,
                          lod_bias, explicit_lod,
                          texel_out);
d1676 6
d1683 1
a1683 1
          util_format_fits_8unorm(bld.format_desc)) {
d1687 191
a1877 5
                      static_state->min_img_filter,
                      static_state->mag_img_filter,
                      static_state->min_mip_filter,
                      static_state->wrap_s,
                      static_state->wrap_t);
d1879 2
d1882 27
a1908 3
      lp_build_sample_general(&bld, unit, s, t, r, ddx, ddy,
                              lod_bias, explicit_lod,
                              texel_out);
d1911 3
a1913 1
   lp_build_sample_compare(&bld, r, texel_out);
d1915 74
a1988 1
   apply_sampler_swizzle(&bld, texel_out);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a189 2

   apply_sampler_swizzle(bld, texel_out);
d835 8
a842 8
   LLVMValueRef size0;
   LLVMValueRef size1;
   LLVMValueRef row_stride0_vec;
   LLVMValueRef row_stride1_vec;
   LLVMValueRef img_stride0_vec;
   LLVMValueRef img_stride1_vec;
   LLVMValueRef data_ptr0;
   LLVMValueRef data_ptr1;
d946 1
d1013 3
a1015 1
         ilevel0 = i32t_zero;
d1074 1
a1074 1
                                i32t_zero, NULL, NULL,
d1114 5
d1277 2
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d33 1
a42 1
#include "util/u_cpu_detect.h"
d48 1
d50 1
d52 2
a53 1
#include "lp_bld_pack.h"
d56 3
d62 3
a64 59
 * Keep all information for sampling code generation in a single place.
 */
struct lp_build_sample_context
{
   LLVMBuilderRef builder;

   const struct lp_sampler_static_state *static_state;

   struct lp_sampler_dynamic_state *dynamic_state;

   const struct util_format_description *format_desc;

   /** Incoming coordinates type and build context */
   struct lp_type coord_type;
   struct lp_build_context coord_bld;

   /** Unsigned integer coordinates */
   struct lp_type uint_coord_type;
   struct lp_build_context uint_coord_bld;

   /** Signed integer coordinates */
   struct lp_type int_coord_type;
   struct lp_build_context int_coord_bld;

   /** Output texels type and build context */
   struct lp_type texel_type;
   struct lp_build_context texel_bld;
};


/**
 * Does the given texture wrap mode allow sampling the texture border color?
 * XXX maybe move this into gallium util code.
 */
static boolean
wrap_mode_uses_border_color(unsigned mode)
{
   switch (mode) {
   case PIPE_TEX_WRAP_REPEAT:
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
   case PIPE_TEX_WRAP_MIRROR_REPEAT:
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
      return FALSE;
   case PIPE_TEX_WRAP_CLAMP:
   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
   case PIPE_TEX_WRAP_MIRROR_CLAMP:
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER:
      return TRUE;
   default:
      assert(0 && "unexpected wrap mode");
      return FALSE;
   }
}



/**
 * Gen code to fetch a texel from a texture at int coords (x, y).
 * The result, texel, will be:
d72 1
d75 1
d78 1
d80 1
d82 1
a82 1
                          LLVMValueRef *texel)
d84 2
d87 1
d89 1
a89 1
   LLVMValueRef packed;
d93 3
a95 1
   if (wrap_mode_uses_border_color(bld->static_state->wrap_s)) {
d99 1
a99 1
      use_border = LLVMBuildOr(bld->builder, b1, b2, "b1_or_b2");
d102 4
a105 1
   if (wrap_mode_uses_border_color(bld->static_state->wrap_t)) {
d110 18
a127 2
         use_border = LLVMBuildOr(bld->builder, use_border, b1, "ub_or_b1");
         use_border = LLVMBuildOr(bld->builder, use_border, b2, "ub_or_b2");
d130 1
a130 1
         use_border = LLVMBuildOr(bld->builder, b1, b2, "b1_or_b2");
d134 25
a173 23
   /* convert x,y coords to linear offset from start of texture, in bytes */
   offset = lp_build_sample_offset(&bld->uint_coord_bld,
                                   bld->format_desc,
                                   x, y, y_stride,
                                   data_ptr);

   assert(bld->format_desc->block.width == 1);
   assert(bld->format_desc->block.height == 1);
   assert(bld->format_desc->block.bits <= bld->texel_type.width);

   /* gather the texels from the texture */
   packed = lp_build_gather(bld->builder,
                            bld->texel_type.length,
                            bld->format_desc->block.bits,
                            bld->texel_type.width,
                            data_ptr, offset);

   /* convert texels to float rgba */
   lp_build_unpack_rgba_soa(bld->builder,
                            bld->format_desc,
                            bld->texel_type,
                            packed, texel);

d176 3
d182 6
a187 4
            lp_build_const_scalar(bld->texel_type,
                                  bld->static_state->border_color[chan]);
         texel[chan] = lp_build_select(&bld->texel_bld, use_border,
                                       border_chan, texel[chan]);
a189 11
}


static LLVMValueRef
lp_build_sample_packed(struct lp_build_sample_context *bld,
                       LLVMValueRef x,
                       LLVMValueRef y,
                       LLVMValueRef y_stride,
                       LLVMValueRef data_ptr)
{
   LLVMValueRef offset;
d191 1
a191 14
   offset = lp_build_sample_offset(&bld->uint_coord_bld,
                                   bld->format_desc,
                                   x, y, y_stride,
                                   data_ptr);

   assert(bld->format_desc->block.width == 1);
   assert(bld->format_desc->block.height == 1);
   assert(bld->format_desc->block.bits <= bld->texel_type.width);

   return lp_build_gather(bld->builder,
                          bld->texel_type.length,
                          bld->format_desc->block.bits,
                          bld->texel_type.width,
                          data_ptr, offset);
d206 1
a206 5
   /* fract = coord - floor(coord) */
   fract = lp_build_sub(coord_bld, coord, lp_build_floor(coord_bld, coord));

   /* flr = ifloor(coord); */
   flr = lp_build_ifloor(coord_bld, coord);
d209 1
a209 1
   isOdd = LLVMBuildAnd(bld->builder, flr, int_coord_bld->one, "");
a224 75
 * We only support a few wrap modes in lp_build_sample_wrap_int() at this time.
 * Return whether the given mode is supported by that function.
 */
static boolean
is_simple_wrap_mode(unsigned mode)
{
   switch (mode) {
   case PIPE_TEX_WRAP_REPEAT:
   case PIPE_TEX_WRAP_CLAMP:
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      return TRUE;
   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
   default:
      return FALSE;
   }
}


/**
 * Build LLVM code for texture wrap mode, for scaled integer texcoords.
 * \param coord  the incoming texcoord (s,t,r or q) scaled to the texture size
 * \param length  the texture size along one dimension
 * \param is_pot  if TRUE, length is a power of two
 * \param wrap_mode  one of PIPE_TEX_WRAP_x
 */
static LLVMValueRef
lp_build_sample_wrap_int(struct lp_build_sample_context *bld,
                         LLVMValueRef coord,
                         LLVMValueRef length,
                         boolean is_pot,
                         unsigned wrap_mode)
{
   struct lp_build_context *uint_coord_bld = &bld->uint_coord_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMValueRef length_minus_one;

   length_minus_one = lp_build_sub(uint_coord_bld, length, uint_coord_bld->one);

   switch(wrap_mode) {
   case PIPE_TEX_WRAP_REPEAT:
      if(is_pot)
         coord = LLVMBuildAnd(bld->builder, coord, length_minus_one, "");
      else
         /* Signed remainder won't give the right results for negative
          * dividends but unsigned remainder does.*/
         coord = LLVMBuildURem(bld->builder, coord, length, "");
      break;

   case PIPE_TEX_WRAP_CLAMP:
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
      coord = lp_build_max(int_coord_bld, coord, int_coord_bld->zero);
      coord = lp_build_min(int_coord_bld, coord, length_minus_one);
      break;

   case PIPE_TEX_WRAP_MIRROR_REPEAT:
   case PIPE_TEX_WRAP_MIRROR_CLAMP:
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER:
      /* FIXME */
      _debug_printf("llvmpipe: failed to translate texture wrap mode %s\n",
                    util_dump_tex_wrap(wrap_mode, TRUE));
      coord = lp_build_max(uint_coord_bld, coord, uint_coord_bld->zero);
      coord = lp_build_min(uint_coord_bld, coord, length_minus_one);
      break;

   default:
      assert(0);
   }

   return coord;
}


/**
d234 1
d243 3
a245 6
   struct lp_build_context *uint_coord_bld = &bld->uint_coord_bld;
   LLVMValueRef two = lp_build_const_scalar(coord_bld->type, 2.0);
   LLVMValueRef half = lp_build_const_scalar(coord_bld->type, 0.5);
   LLVMValueRef length_f = lp_build_int_to_float(coord_bld, length);
   LLVMValueRef length_minus_one = lp_build_sub(uint_coord_bld, length, uint_coord_bld->one);
   LLVMValueRef length_f_minus_one = lp_build_sub(coord_bld, length_f, coord_bld->one);
d253 2
a254 5
      /* convert to int */
      coord0 = lp_build_ifloor(coord_bld, coord);
      coord1 = lp_build_add(uint_coord_bld, coord0, uint_coord_bld->one);
      /* compute lerp weight */
      weight = lp_build_fract(coord_bld, coord);
d257 3
a259 2
         coord0 = LLVMBuildAnd(bld->builder, coord0, length_minus_one, "");
         coord1 = LLVMBuildAnd(bld->builder, coord1, length_minus_one, "");
d262 10
a271 4
         /* Signed remainder won't give the right results for negative
          * dividends but unsigned remainder does.*/
         coord0 = LLVMBuildURem(bld->builder, coord0, length, "");
         coord1 = LLVMBuildURem(bld->builder, coord1, length, "");
d277 1
d280 9
a288 8
      weight = lp_build_fract(coord_bld, coord);
      coord0 = lp_build_clamp(coord_bld, coord, coord_bld->zero,
                              length_f_minus_one);
      coord1 = lp_build_add(coord_bld, coord, coord_bld->one);
      coord1 = lp_build_clamp(coord_bld, coord1, coord_bld->zero,
                              length_f_minus_one);
      coord0 = lp_build_ifloor(coord_bld, coord0);
      coord1 = lp_build_ifloor(coord_bld, coord1);
d292 11
a302 5
      if (bld->static_state->normalized_coords) {
         /* clamp to [0,1] */
         coord = lp_build_clamp(coord_bld, coord, coord_bld->zero, coord_bld->one);
         /* mul by tex size and subtract 0.5 */
         coord = lp_build_mul(coord_bld, coord, length_f);
d304 8
a312 17
      else {
         LLVMValueRef min, max;
         /* clamp to [0.5, length - 0.5] */
         min = lp_build_const_scalar(coord_bld->type, 0.5F);
         max = lp_build_sub(coord_bld, length_f, min);
         coord = lp_build_clamp(coord_bld, coord, min, max);
      }
      /* compute lerp weight */
      weight = lp_build_fract(coord_bld, coord);
      /* coord0 = floor(coord); */
      coord0 = lp_build_ifloor(coord_bld, coord);
      coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
      /* coord0 = max(coord0, 0) */
      coord0 = lp_build_max(int_coord_bld, coord0, int_coord_bld->zero);
      /* coord1 = min(coord1, length-1) */
      coord1 = lp_build_min(int_coord_bld, coord1, length_minus_one);
      break;
d316 1
a316 1
         LLVMValueRef min, max;
d318 1
a318 9
            /* min = -1.0 / (2 * length) = -0.5 / length */
            min = lp_build_mul(coord_bld,
                               lp_build_const_scalar(coord_bld->type, -0.5F),
                               lp_build_rcp(coord_bld, length_f));
            /* max = 1.0 - min */
            max = lp_build_sub(coord_bld, coord_bld->one, min);
            /* coord = clamp(coord, min, max) */
            coord = lp_build_clamp(coord_bld, coord, min, max);
            /* scale coord to length (and sub 0.5?) */
a319 1
            coord = lp_build_sub(coord_bld, coord, half);
d321 6
a326 11
         else {
            /* clamp to [-0.5, length + 0.5] */
            min = lp_build_const_scalar(coord_bld->type, -0.5F);
            max = lp_build_sub(coord_bld, length_f, min);
            coord = lp_build_clamp(coord_bld, coord, min, max);
            coord = lp_build_sub(coord_bld, coord, half);
         }
         /* compute lerp weight */
         weight = lp_build_fract(coord_bld, coord);
         /* convert to int */
         coord0 = lp_build_ifloor(coord_bld, coord);
d339 2
a340 5
      /* compute lerp weight */
      weight = lp_build_fract(coord_bld, coord);

      /* convert to int coords */
      coord0 = lp_build_ifloor(coord_bld, coord);
d350 1
a350 6
      {
         LLVMValueRef min, max;
         /* min = 1.0 / (2 * length) */
         min = lp_build_rcp(coord_bld, lp_build_mul(coord_bld, two, length_f));
         /* max = 1.0 - min */
         max = lp_build_sub(coord_bld, coord_bld->one, min);
d352 2
a353 2
         coord = lp_build_abs(coord_bld, coord);
         coord = lp_build_clamp(coord_bld, coord, min, max);
a354 4
         if(0)coord = lp_build_sub(coord_bld, coord, half);
         weight = lp_build_fract(coord_bld, coord);
         coord0 = lp_build_ifloor(coord_bld, coord);
         coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
d356 9
d370 8
a377 4
         /* min = 1.0 / (2 * length) */
         min = lp_build_rcp(coord_bld, lp_build_mul(coord_bld, two, length_f));
         /* max = 1.0 - min */
         max = lp_build_sub(coord_bld, coord_bld->one, min);
d379 3
a381 1
         coord = lp_build_abs(coord_bld, coord);
d383 1
a383 1
         coord = lp_build_mul(coord_bld, coord, length_f);
d385 3
a387 2
         weight = lp_build_fract(coord_bld, coord);
         coord0 = lp_build_ifloor(coord_bld, coord);
d394 6
a399 7
         LLVMValueRef min, max;
         /* min = -1.0 / (2 * length) = -0.5 / length */
         min = lp_build_mul(coord_bld,
                            lp_build_const_scalar(coord_bld->type, -0.5F),
                            lp_build_rcp(coord_bld, length_f));
         /* max = 1.0 - min */
         max = lp_build_sub(coord_bld, coord_bld->one, min);
d401 2
a402 3
         coord = lp_build_abs(coord_bld, coord);
         coord = lp_build_clamp(coord_bld, coord, min, max);
         coord = lp_build_mul(coord_bld, coord, length_f);
d404 4
a407 2
         weight = lp_build_fract(coord_bld, coord);
         coord0 = lp_build_ifloor(coord_bld, coord);
d428 1
a428 1
 * \param length  the texture size along one dimension, as int
d436 1
d442 2
a443 5
   struct lp_build_context *uint_coord_bld = &bld->uint_coord_bld;
   LLVMValueRef two = lp_build_const_scalar(coord_bld->type, 2.0);
   LLVMValueRef length_f = lp_build_int_to_float(coord_bld, length);
   LLVMValueRef length_minus_one = lp_build_sub(uint_coord_bld, length, uint_coord_bld->one);
   LLVMValueRef length_f_minus_one = lp_build_sub(coord_bld, length_f, coord_bld->one);
d451 7
a457 5
         icoord = LLVMBuildAnd(bld->builder, icoord, length_minus_one, "");
      else
         /* Signed remainder won't give the right results for negative
          * dividends but unsigned remainder does.*/
         icoord = LLVMBuildURem(bld->builder, icoord, length, "");
d461 1
a461 1
      /* mul by size */
d463 1
d466 1
d468 4
a471 2
      icoord = lp_build_ifloor(coord_bld, coord);
      /* clamp to [0, size-1].  Note: int coord builder type */
a475 22
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      {
         LLVMValueRef min, max;
         if (bld->static_state->normalized_coords) {
            /* min = 1.0 / (2 * length) */
            min = lp_build_rcp(coord_bld, lp_build_mul(coord_bld, two, length_f));
            /* max = length - min */
            max = lp_build_sub(coord_bld, length_f, min);
            /* scale coord to length */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }
         else {
            /* clamp to [0.5, length - 0.5] */
            min = lp_build_const_scalar(coord_bld->type, 0.5F);
            max = lp_build_sub(coord_bld, length_f, min);
         }
         /* coord = clamp(coord, min, max) */
         coord = lp_build_clamp(coord_bld, coord, min, max);
         icoord = lp_build_ifloor(coord_bld, coord);
      }
      break;

d480 1
a481 6
            /* min = -1.0 / (2 * length) = -0.5 / length */
            min = lp_build_mul(coord_bld,
                               lp_build_const_scalar(coord_bld->type, -0.5F),
                               lp_build_rcp(coord_bld, length_f));
            /* max = length - min */
            max = lp_build_sub(coord_bld, length_f, min);
d485 1
a485 7
         else {
            /* clamp to [-0.5, length + 0.5] */
            min = lp_build_const_scalar(coord_bld->type, -0.5F);
            max = lp_build_sub(coord_bld, length_f, min);
         }
         /* coord = clamp(coord, min, max) */
         coord = lp_build_clamp(coord_bld, coord, min, max);
d487 5
d496 2
a497 6
      {
         LLVMValueRef min, max;
         /* min = 1.0 / (2 * length) */
         min = lp_build_rcp(coord_bld, lp_build_mul(coord_bld, two, length_f));
         /* max = length - min */
         max = lp_build_sub(coord_bld, length_f, min);
d499 3
a501 2
         /* compute mirror function */
         coord = lp_build_coord_mirror(bld, coord);
d503 2
a504 2
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
d506 2
a507 4
         /* coord = clamp(coord, min, max) */
         coord = lp_build_clamp(coord_bld, coord, min, max);
         icoord = lp_build_ifloor(coord_bld, coord);
      }
d511 1
a512 4
      coord = lp_build_mul(coord_bld, coord, length_f);
      coord = lp_build_clamp(coord_bld, coord, coord_bld->zero, length_f_minus_one);
      icoord = lp_build_ifloor(coord_bld, coord);
      break;
d514 2
a515 9
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
      {
         LLVMValueRef min, max;
         /* min = 1.0 / (2 * length) */
         min = lp_build_rcp(coord_bld, lp_build_mul(coord_bld, two, length_f));
         /* max = length - min */
         max = lp_build_sub(coord_bld, length_f, min);

         coord = lp_build_abs(coord_bld, coord);
a516 2
         coord = lp_build_clamp(coord_bld, coord, min, max);
         icoord = lp_build_ifloor(coord_bld, coord);
d518 6
d527 1
a527 7
      {
         LLVMValueRef min, max;
         /* min = 1.0 / (2 * length) */
         min = lp_build_rcp(coord_bld, lp_build_mul(coord_bld, two, length_f));
         min = lp_build_negate(coord_bld, min);
         /* max = length - min */
         max = lp_build_sub(coord_bld, length_f, min);
d529 2
a530 1
         coord = lp_build_abs(coord_bld, coord);
a531 2
         coord = lp_build_clamp(coord_bld, coord, min, max);
         icoord = lp_build_ifloor(coord_bld, coord);
d533 6
d551 2
a552 1
 * Sample 2D texture with nearest filtering.
d555 10
a564 8
lp_build_sample_2d_nearest_soa(struct lp_build_sample_context *bld,
                               LLVMValueRef s,
                               LLVMValueRef t,
                               LLVMValueRef width,
                               LLVMValueRef height,
                               LLVMValueRef stride,
                               LLVMValueRef data_ptr,
                               LLVMValueRef *texel)
d566 23
a588 1
   LLVMValueRef x, y;
d590 4
a593 1
   x = lp_build_sample_wrap_nearest(bld, s, width,
d596 1
a596 3
   y = lp_build_sample_wrap_nearest(bld, t, height,
                                    bld->static_state->pot_height,
                                    bld->static_state->wrap_t);
d598 22
a619 2
   lp_build_name(x, "tex.x.wrapped");
   lp_build_name(y, "tex.y.wrapped");
d621 8
a628 1
   lp_build_sample_texel_soa(bld, width, height, x, y, stride, data_ptr, texel);
d633 2
a634 1
 * Sample 2D texture with bilinear filtering.
d637 10
a646 8
lp_build_sample_2d_linear_soa(struct lp_build_sample_context *bld,
                              LLVMValueRef s,
                              LLVMValueRef t,
                              LLVMValueRef width,
                              LLVMValueRef height,
                              LLVMValueRef stride,
                              LLVMValueRef data_ptr,
                              LLVMValueRef *texel)
d648 10
a657 4
   LLVMValueRef s_fpart;
   LLVMValueRef t_fpart;
   LLVMValueRef x0, x1;
   LLVMValueRef y0, y1;
d659 1
a659 52
   unsigned chan;

   lp_build_sample_wrap_linear(bld, s, width, bld->static_state->pot_width,
                               bld->static_state->wrap_s, &x0, &x1, &s_fpart);
   lp_build_sample_wrap_linear(bld, t, height, bld->static_state->pot_height,
                               bld->static_state->wrap_t, &y0, &y1, &t_fpart);

   lp_build_sample_texel_soa(bld, width, height, x0, y0, stride, data_ptr, neighbors[0][0]);
   lp_build_sample_texel_soa(bld, width, height, x1, y0, stride, data_ptr, neighbors[0][1]);
   lp_build_sample_texel_soa(bld, width, height, x0, y1, stride, data_ptr, neighbors[1][0]);
   lp_build_sample_texel_soa(bld, width, height, x1, y1, stride, data_ptr, neighbors[1][1]);

   /* TODO: Don't interpolate missing channels */
   for(chan = 0; chan < 4; ++chan) {
      texel[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                     s_fpart, t_fpart,
                                     neighbors[0][0][chan],
                                     neighbors[0][1][chan],
                                     neighbors[1][0][chan],
                                     neighbors[1][1][chan]);
   }
}


static void
lp_build_rgba8_to_f32_soa(LLVMBuilderRef builder,
                          struct lp_type dst_type,
                          LLVMValueRef packed,
                          LLVMValueRef *rgba)
{
   LLVMValueRef mask = lp_build_int_const_scalar(dst_type, 0xff);
   unsigned chan;

   /* Decode the input vector components */
   for (chan = 0; chan < 4; ++chan) {
      unsigned start = chan*8;
      unsigned stop = start + 8;
      LLVMValueRef input;

      input = packed;

      if(start)
         input = LLVMBuildLShr(builder, input, lp_build_int_const_scalar(dst_type, start), "");

      if(stop < 32)
         input = LLVMBuildAnd(builder, input, mask, "");

      input = lp_build_unsigned_norm_to_float(builder, 8, dst_type, input);

      rgba[chan] = input;
   }
}
d661 13
a673 79

static void
lp_build_sample_2d_linear_aos(struct lp_build_sample_context *bld,
                              LLVMValueRef s,
                              LLVMValueRef t,
                              LLVMValueRef width,
                              LLVMValueRef height,
                              LLVMValueRef stride,
                              LLVMValueRef data_ptr,
                              LLVMValueRef *texel)
{
   LLVMBuilderRef builder = bld->builder;
   struct lp_build_context i32, h16, u8n;
   LLVMTypeRef i32_vec_type, h16_vec_type, u8n_vec_type;
   LLVMValueRef i32_c8, i32_c128, i32_c255;
   LLVMValueRef s_ipart, s_fpart, s_fpart_lo, s_fpart_hi;
   LLVMValueRef t_ipart, t_fpart, t_fpart_lo, t_fpart_hi;
   LLVMValueRef x0, x1;
   LLVMValueRef y0, y1;
   LLVMValueRef neighbors[2][2];
   LLVMValueRef neighbors_lo[2][2];
   LLVMValueRef neighbors_hi[2][2];
   LLVMValueRef packed, packed_lo, packed_hi;
   LLVMValueRef unswizzled[4];

   lp_build_context_init(&i32, builder, lp_type_int(32));
   lp_build_context_init(&h16, builder, lp_type_ufixed(16));
   lp_build_context_init(&u8n, builder, lp_type_unorm(8));

   i32_vec_type = lp_build_vec_type(i32.type);
   h16_vec_type = lp_build_vec_type(h16.type);
   u8n_vec_type = lp_build_vec_type(u8n.type);

   if (bld->static_state->normalized_coords) {
      LLVMTypeRef coord_vec_type = lp_build_vec_type(bld->coord_type);
      LLVMValueRef fp_width = LLVMBuildSIToFP(bld->builder, width, coord_vec_type, "");
      LLVMValueRef fp_height = LLVMBuildSIToFP(bld->builder, height, coord_vec_type, "");
      s = lp_build_mul(&bld->coord_bld, s, fp_width);
      t = lp_build_mul(&bld->coord_bld, t, fp_height);
   }

   /* scale coords by 256 (8 fractional bits) */
   s = lp_build_mul_imm(&bld->coord_bld, s, 256);
   t = lp_build_mul_imm(&bld->coord_bld, t, 256);

   /* convert float to int */
   s = LLVMBuildFPToSI(builder, s, i32_vec_type, "");
   t = LLVMBuildFPToSI(builder, t, i32_vec_type, "");

   /* subtract 0.5 (add -128) */
   i32_c128 = lp_build_int_const_scalar(i32.type, -128);
   s = LLVMBuildAdd(builder, s, i32_c128, "");
   t = LLVMBuildAdd(builder, t, i32_c128, "");

   /* compute floor (shift right 8) */
   i32_c8 = lp_build_int_const_scalar(i32.type, 8);
   s_ipart = LLVMBuildAShr(builder, s, i32_c8, "");
   t_ipart = LLVMBuildAShr(builder, t, i32_c8, "");

   /* compute fractional part (AND with 0xff) */
   i32_c255 = lp_build_int_const_scalar(i32.type, 255);
   s_fpart = LLVMBuildAnd(builder, s, i32_c255, "");
   t_fpart = LLVMBuildAnd(builder, t, i32_c255, "");

   x0 = s_ipart;
   y0 = t_ipart;

   x1 = lp_build_add(&bld->int_coord_bld, x0, bld->int_coord_bld.one);
   y1 = lp_build_add(&bld->int_coord_bld, y0, bld->int_coord_bld.one);

   x0 = lp_build_sample_wrap_int(bld, x0, width,  bld->static_state->pot_width,
                                 bld->static_state->wrap_s);
   y0 = lp_build_sample_wrap_int(bld, y0, height, bld->static_state->pot_height,
                                 bld->static_state->wrap_t);

   x1 = lp_build_sample_wrap_int(bld, x1, width,  bld->static_state->pot_width,
                                 bld->static_state->wrap_s);
   y1 = lp_build_sample_wrap_int(bld, y1, height, bld->static_state->pot_height,
                                 bld->static_state->wrap_t);
d676 1
a676 15
    * Transform 4 x i32 in
    *
    *   s_fpart = {s0, s1, s2, s3}
    *
    * into 8 x i16
    *
    *   s_fpart = {00, s0, 00, s1, 00, s2, 00, s3}
    *
    * into two 8 x i16
    *
    *   s_fpart_lo = {s0, s0, s0, s0, s1, s1, s1, s1}
    *   s_fpart_hi = {s2, s2, s2, s2, s3, s3, s3, s3}
    *
    * and likewise for t_fpart. There is no risk of loosing precision here
    * since the fractional parts only use the lower 8bits.
d678 35
a712 32

   s_fpart = LLVMBuildBitCast(builder, s_fpart, h16_vec_type, "");
   t_fpart = LLVMBuildBitCast(builder, t_fpart, h16_vec_type, "");

   {
      LLVMTypeRef elem_type = LLVMInt32Type();
      LLVMValueRef shuffles_lo[LP_MAX_VECTOR_LENGTH];
      LLVMValueRef shuffles_hi[LP_MAX_VECTOR_LENGTH];
      LLVMValueRef shuffle_lo;
      LLVMValueRef shuffle_hi;
      unsigned i, j;

      for(j = 0; j < h16.type.length; j += 4) {
         unsigned subindex = util_cpu_caps.little_endian ? 0 : 1;
         LLVMValueRef index;

         index = LLVMConstInt(elem_type, j/2 + subindex, 0);
         for(i = 0; i < 4; ++i)
            shuffles_lo[j + i] = index;

         index = LLVMConstInt(elem_type, h16.type.length/2 + j/2 + subindex, 0);
         for(i = 0; i < 4; ++i)
            shuffles_hi[j + i] = index;
      }

      shuffle_lo = LLVMConstVector(shuffles_lo, h16.type.length);
      shuffle_hi = LLVMConstVector(shuffles_hi, h16.type.length);

      s_fpart_lo = LLVMBuildShuffleVector(builder, s_fpart, h16.undef, shuffle_lo, "");
      t_fpart_lo = LLVMBuildShuffleVector(builder, t_fpart, h16.undef, shuffle_lo, "");
      s_fpart_hi = LLVMBuildShuffleVector(builder, s_fpart, h16.undef, shuffle_hi, "");
      t_fpart_hi = LLVMBuildShuffleVector(builder, t_fpart, h16.undef, shuffle_hi, "");
d716 1
a716 14
    * Fetch the pixels as 4 x 32bit (rgba order might differ):
    *
    *   rgba0 rgba1 rgba2 rgba3
    *
    * bit cast them into 16 x u8
    *
    *   r0 g0 b0 a0 r1 g1 b1 a1 r2 g2 b2 a2 r3 g3 b3 a3
    *
    * unpack them into two 8 x i16:
    *
    *   r0 g0 b0 a0 r1 g1 b1 a1
    *   r2 g2 b2 a2 r3 g3 b3 a3
    *
    * The higher 8 bits of the resulting elements will be zero.
d718 11
d730 23
a752 14
   neighbors[0][0] = lp_build_sample_packed(bld, x0, y0, stride, data_ptr);
   neighbors[0][1] = lp_build_sample_packed(bld, x1, y0, stride, data_ptr);
   neighbors[1][0] = lp_build_sample_packed(bld, x0, y1, stride, data_ptr);
   neighbors[1][1] = lp_build_sample_packed(bld, x1, y1, stride, data_ptr);

   neighbors[0][0] = LLVMBuildBitCast(builder, neighbors[0][0], u8n_vec_type, "");
   neighbors[0][1] = LLVMBuildBitCast(builder, neighbors[0][1], u8n_vec_type, "");
   neighbors[1][0] = LLVMBuildBitCast(builder, neighbors[1][0], u8n_vec_type, "");
   neighbors[1][1] = LLVMBuildBitCast(builder, neighbors[1][1], u8n_vec_type, "");

   lp_build_unpack2(builder, u8n.type, h16.type, neighbors[0][0], &neighbors_lo[0][0], &neighbors_hi[0][0]);
   lp_build_unpack2(builder, u8n.type, h16.type, neighbors[0][1], &neighbors_lo[0][1], &neighbors_hi[0][1]);
   lp_build_unpack2(builder, u8n.type, h16.type, neighbors[1][0], &neighbors_lo[1][0], &neighbors_hi[1][0]);
   lp_build_unpack2(builder, u8n.type, h16.type, neighbors[1][1], &neighbors_lo[1][1], &neighbors_hi[1][1]);
d754 45
a798 3
   /*
    * Linear interpolate with 8.8 fixed point.
    */
d800 14
a813 29
   packed_lo = lp_build_lerp_2d(&h16,
                                s_fpart_lo, t_fpart_lo,
                                neighbors_lo[0][0],
                                neighbors_lo[0][1],
                                neighbors_lo[1][0],
                                neighbors_lo[1][1]);

   packed_hi = lp_build_lerp_2d(&h16,
                                s_fpart_hi, t_fpart_hi,
                                neighbors_hi[0][0],
                                neighbors_hi[0][1],
                                neighbors_hi[1][0],
                                neighbors_hi[1][1]);

   packed = lp_build_pack2(builder, h16.type, u8n.type, packed_lo, packed_hi);

   /*
    * Convert to SoA and swizzle.
    */

   packed = LLVMBuildBitCast(builder, packed, i32_vec_type, "");

   lp_build_rgba8_to_f32_soa(bld->builder,
                             bld->texel_type,
                             packed, unswizzled);

   lp_build_format_swizzle_soa(bld->format_desc,
                               bld->texel_type, unswizzled,
                               texel);
d817 6
d824 11
a834 3
lp_build_sample_compare(struct lp_build_sample_context *bld,
                        LLVMValueRef p,
                        LLVMValueRef *texel)
d836 10
a845 2
   struct lp_build_context *texel_bld = &bld->texel_bld;
   LLVMValueRef res;
d848 20
a867 2
   if(bld->static_state->compare_mode == PIPE_TEX_COMPARE_NONE)
      return;
d869 3
a871 11
   /* TODO: Compare before swizzling, to avoid redundant computations */
   res = NULL;
   for(chan = 0; chan < 4; ++chan) {
      LLVMValueRef cmp;
      cmp = lp_build_cmp(texel_bld, bld->static_state->compare_func, p, texel[chan]);
      cmp = lp_build_select(texel_bld, cmp, texel_bld->one, texel_bld->zero);

      if(res)
         res = lp_build_add(texel_bld, res, cmp);
      else
         res = cmp;
d874 31
a904 2
   assert(res);
   res = lp_build_mul(texel_bld, res, lp_build_const_scalar(texel_bld->type, 0.25));
d906 1
a906 5
   /* XXX returning result for default GL_DEPTH_TEXTURE_MODE = GL_LUMINANCE */
   for(chan = 0; chan < 3; ++chan)
      texel[chan] = res;
   texel[3] = texel_bld->one;
}
d908 1
d910 7
a916 14
static int
texture_dims(enum pipe_texture_target tex)
{
   switch (tex) {
   case PIPE_TEXTURE_1D:
      return 1;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_CUBE:
      return 2;
   case PIPE_TEXTURE_3D:
      return 3;
   default:
      assert(0 && "bad texture target in texture_dims()");
      return 2;
d921 1
d923 3
a925 7
 * Generate code to compute texture level of detail (lambda).
 * \param s  vector of texcoord s values
 * \param t  vector of texcoord t values
 * \param r  vector of texcoord r values
 * \param width  scalar int texture width
 * \param height  scalar int texture height
 * \param depth  scalar int texture depth
d927 23
a949 8
static LLVMValueRef
lp_build_lod_selector(struct lp_build_sample_context *bld,
                      LLVMValueRef s,
                      LLVMValueRef t,
                      LLVMValueRef r,
                      LLVMValueRef width,
                      LLVMValueRef height,
                      LLVMValueRef depth)
d951 4
a954 3
{
   const int dims = texture_dims(bld->static_state->target);
   struct lp_build_context *coord_bld = &bld->coord_bld;
d956 23
a978 16
   LLVMValueRef lod_bias = lp_build_const_scalar(bld->coord_bld.type,
                                                 bld->static_state->lod_bias);
   LLVMValueRef min_lod = lp_build_const_scalar(bld->coord_bld.type,
                                                bld->static_state->min_lod);
   LLVMValueRef max_lod = lp_build_const_scalar(bld->coord_bld.type,
                                                bld->static_state->max_lod);

   LLVMValueRef index0 = LLVMConstInt(LLVMInt32Type(), 0, 0);
   LLVMValueRef index1 = LLVMConstInt(LLVMInt32Type(), 1, 0);
   LLVMValueRef index2 = LLVMConstInt(LLVMInt32Type(), 2, 0);

   LLVMValueRef s0, s1, s2;
   LLVMValueRef t0, t1, t2;
   LLVMValueRef r0, r1, r2;
   LLVMValueRef dsdx, dsdy, dtdx, dtdy, drdx, drdy;
   LLVMValueRef rho, lod;
d981 1
a981 7
    * dsdx = abs(s[1] - s[0]);
    * dsdy = abs(s[2] - s[0]);
    * dtdx = abs(t[1] - t[0]);
    * dtdy = abs(t[2] - t[0]);
    * drdx = abs(r[1] - r[0]);
    * drdy = abs(r[2] - r[0]);
    * XXX we're assuming a four-element quad in 2x2 layout here.
d983 11
a993 18
   s0 = LLVMBuildExtractElement(bld->builder, s, index0, "s0");
   s1 = LLVMBuildExtractElement(bld->builder, s, index1, "s1");
   s2 = LLVMBuildExtractElement(bld->builder, s, index2, "s2");
   dsdx = lp_build_abs(coord_bld, lp_build_sub(coord_bld, s1, s0));
   dsdy = lp_build_abs(coord_bld, lp_build_sub(coord_bld, s2, s0));
   if (dims > 1) {
      t0 = LLVMBuildExtractElement(bld->builder, t, index0, "t0");
      t1 = LLVMBuildExtractElement(bld->builder, t, index1, "t1");
      t2 = LLVMBuildExtractElement(bld->builder, t, index2, "t2");
      dtdx = lp_build_abs(coord_bld, lp_build_sub(coord_bld, t1, t0));
      dtdy = lp_build_abs(coord_bld, lp_build_sub(coord_bld, t2, t0));
      if (dims > 2) {
         r0 = LLVMBuildExtractElement(bld->builder, r, index0, "r0");
         r1 = LLVMBuildExtractElement(bld->builder, r, index1, "r1");
         r2 = LLVMBuildExtractElement(bld->builder, r, index2, "r2");
         drdx = lp_build_abs(coord_bld, lp_build_sub(coord_bld, r1, r0));
         drdy = lp_build_abs(coord_bld, lp_build_sub(coord_bld, r2, r0));
      }
d996 2
a997 2
   /* Compute rho = max of all partial derivatives scaled by texture size.
    * XXX this can be vectorized somewhat
d999 13
a1011 14
   rho = lp_build_mul(coord_bld,
                       lp_build_max(coord_bld, dsdx, dsdy),
                       lp_build_int_to_float(coord_bld, width));
   if (dims > 1) {
      LLVMValueRef max;
      max = lp_build_mul(coord_bld,
                         lp_build_max(coord_bld, dtdx, dtdy),
                         lp_build_int_to_float(coord_bld, height));
      rho = lp_build_max(coord_bld, rho, max);
      if (dims > 2) {
         max = lp_build_mul(coord_bld,
                            lp_build_max(coord_bld, drdx, drdy),
                            lp_build_int_to_float(coord_bld, depth));
         rho = lp_build_max(coord_bld, rho, max);
d1013 15
d1030 3
a1032 2
   /* compute lod = log2(rho) */
   lod = lp_build_log2(coord_bld, rho);
d1034 23
a1056 2
   /* add lod bias */
   lod = lp_build_add(coord_bld, lod, lod_bias);
d1058 20
a1077 2
   /* clamp lod */
   lod = lp_build_clamp(coord_bld, lod, min_lod, max_lod);
d1079 4
a1082 1
   return lod;
d1087 3
a1089 4
 * For PIPE_TEX_MIPFILTER_NEAREST, convert float LOD to integer
 * mipmap level index.
 * \param lod  scalar float texture level of detail
 * \param level_out  returns integer 
d1092 3
a1094 4
lp_build_nearest_mip_level(struct lp_build_sample_context *bld,
                           unsigned unit,
                           LLVMValueRef lod,
                           LLVMValueRef *level_out)
d1096 7
a1102 3
   struct lp_build_context *coord_bld = &bld->coord_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMValueRef last_level, level;
d1104 8
a1111 2
   last_level = bld->dynamic_state->last_level(bld->dynamic_state,
                                               bld->builder, unit);
d1113 4
a1116 2
   /* convert float lod to integer */
   level = lp_build_iround(coord_bld, lod);
d1118 5
a1122 4
   /* clamp level to legal range of levels */
   *level_out = lp_build_clamp(int_coord_bld, level,
                               int_coord_bld->zero,
                               last_level);
d1127 2
a1128 3
 * For PIPE_TEX_MIPFILTER_LINEAR, convert float LOD to integer to
 * two (adjacent) mipmap level indexes.  Later, we'll sample from those
 * two mipmap levels and interpolate between them.
d1130 3
a1132 7
static void
lp_build_linear_mip_levels(struct lp_build_sample_context *bld,
                           unsigned unit,
                           LLVMValueRef lod,
                           LLVMValueRef *level0_out,
                           LLVMValueRef *level1_out,
                           LLVMValueRef *weight_out)
d1134 2
a1135 17
   struct lp_build_context *coord_bld = &bld->coord_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMValueRef last_level, level;

   last_level = bld->dynamic_state->last_level(bld->dynamic_state,
                                               bld->builder, unit);

   /* convert float lod to integer */
   level = lp_build_ifloor(coord_bld, lod);

   /* compute level 0 and clamp to legal range of levels */
   *level0_out = lp_build_clamp(int_coord_bld, level,
                                int_coord_bld->zero,
                                last_level);
   /* compute level 1 and clamp to legal range of levels */
   *level1_out = lp_build_add(int_coord_bld, *level0_out, int_coord_bld->one);
   *level1_out = lp_build_min(int_coord_bld, *level1_out, int_coord_bld->zero);
d1137 3
a1139 1
   *weight_out = lp_build_fract(coord_bld, lod);
a1142 1

d1147 3
d1152 1
a1152 1
lp_build_sample_soa(LLVMBuilderRef builder,
d1159 5
a1163 2
                    LLVMValueRef lodbias,
                    LLVMValueRef *texel)
d1165 1
d1167 2
a1168 4
   LLVMValueRef width;
   LLVMValueRef height;
   LLVMValueRef stride;
   LLVMValueRef data_ptr;
d1172 6
d1179 1
a1179 3
   (void) lp_build_lod_selector;   /* temporary to silence warning */
   (void) lp_build_nearest_mip_level;
   (void) lp_build_linear_mip_levels;
d1183 1
a1183 1
   bld.builder = builder;
d1187 4
a1191 1
   bld.uint_coord_type = lp_uint_type(type);
d1193 3
d1197 11
a1207 4
   lp_build_context_init(&bld.coord_bld, builder, bld.coord_type);
   lp_build_context_init(&bld.uint_coord_bld, builder, bld.uint_coord_type);
   lp_build_context_init(&bld.int_coord_bld, builder, bld.int_coord_type);
   lp_build_context_init(&bld.texel_bld, builder, bld.texel_type);
d1210 7
a1216 4
   width = dynamic_state->width(dynamic_state, builder, unit);
   height = dynamic_state->height(dynamic_state, builder, unit);
   stride = dynamic_state->stride(dynamic_state, builder, unit);
   data_ptr = dynamic_state->data_ptr(dynamic_state, builder, unit);
d1222 28
a1249 24
   width = lp_build_broadcast_scalar(&bld.uint_coord_bld, width);
   height = lp_build_broadcast_scalar(&bld.uint_coord_bld, height);
   stride = lp_build_broadcast_scalar(&bld.uint_coord_bld, stride);

   if(static_state->target == PIPE_TEXTURE_1D)
      t = bld.coord_bld.zero;

   switch (static_state->min_img_filter) {
   case PIPE_TEX_FILTER_NEAREST:
      lp_build_sample_2d_nearest_soa(&bld, s, t, width, height,
                                     stride, data_ptr, texel);
      break;
   case PIPE_TEX_FILTER_LINEAR:
      if(lp_format_is_rgba8(bld.format_desc) &&
         is_simple_wrap_mode(static_state->wrap_s) &&
         is_simple_wrap_mode(static_state->wrap_t))
         lp_build_sample_2d_linear_aos(&bld, s, t, width, height,
                                       stride, data_ptr, texel);
      else
         lp_build_sample_2d_linear_soa(&bld, s, t, width, height,
                                       stride, data_ptr, texel);
      break;
   default:
      assert(0);
d1252 17
a1268 2
   /* FIXME: respect static_state->min_mip_filter */;
   /* FIXME: respect static_state->mag_img_filter */;
d1270 1
a1270 1
   lp_build_sample_compare(&bld, r, texel);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a32 1
 * @@author Brian Paul <brianp@@vmware.com>
d42 1
a47 1
#include "lp_bld_bitarit.h"
a48 1
#include "lp_bld_printf.h"
d50 1
a50 2
#include "lp_bld_flow.h"
#include "lp_bld_gather.h"
a52 3
#include "lp_bld_sample_aos.h"
#include "lp_bld_struct.h"
#include "lp_bld_quad.h"
d56 59
a114 3
 * Generate code to fetch a texel from a texture at int coords (x, y, z).
 * The computation depends on whether the texture is 1D, 2D or 3D.
 * The result, texel, will be float vectors:
a121 1
                          unsigned unit,
a123 1
                          LLVMValueRef depth,
a125 1
                          LLVMValueRef z,
a126 1
                          LLVMValueRef z_stride,
d128 1
a128 1
                          LLVMValueRef texel_out[4])
a129 2
   const struct lp_sampler_static_state *static_state = bld->static_state;
   const unsigned dims = bld->dims;
a130 1
   LLVMBuilderRef builder = bld->gallivm->builder;
d132 1
a132 1
   LLVMValueRef i, j;
d136 1
a136 3
   if (lp_sampler_wrap_mode_uses_border_color(static_state->wrap_s,
                                              static_state->min_img_filter,
                                              static_state->mag_img_filter)) {
d140 1
a140 1
      use_border = LLVMBuildOr(builder, b1, b2, "b1_or_b2");
d143 1
a143 4
   if (dims >= 2 &&
       lp_sampler_wrap_mode_uses_border_color(static_state->wrap_t,
                                              static_state->min_img_filter,
                                              static_state->mag_img_filter)) {
d148 2
a149 18
         use_border = LLVMBuildOr(builder, use_border, b1, "ub_or_b1");
         use_border = LLVMBuildOr(builder, use_border, b2, "ub_or_b2");
      }
      else {
         use_border = LLVMBuildOr(builder, b1, b2, "b1_or_b2");
      }
   }

   if (dims == 3 &&
       lp_sampler_wrap_mode_uses_border_color(static_state->wrap_r,
                                              static_state->min_img_filter,
                                              static_state->mag_img_filter)) {
      LLVMValueRef b1, b2;
      b1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, z, int_coord_bld->zero);
      b2 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, z, depth);
      if (use_border) {
         use_border = LLVMBuildOr(builder, use_border, b1, "ub_or_b1");
         use_border = LLVMBuildOr(builder, use_border, b2, "ub_or_b2");
d152 1
a152 1
         use_border = LLVMBuildOr(builder, b1, b2, "b1_or_b2");
a155 25
   /* convert x,y,z coords to linear offset from start of texture, in bytes */
   lp_build_sample_offset(&bld->int_coord_bld,
                          bld->format_desc,
                          x, y, z, y_stride, z_stride,
                          &offset, &i, &j);

   if (use_border) {
      /* If we can sample the border color, it means that texcoords may
       * lie outside the bounds of the texture image.  We need to do
       * something to prevent reading out of bounds and causing a segfault.
       *
       * Simply AND the texture coords with !use_border.  This will cause
       * coords which are out of bounds to become zero.  Zero's guaranteed
       * to be inside the texture image.
       */
      offset = lp_build_andnot(&bld->int_coord_bld, offset, use_border);
   }

   lp_build_fetch_rgba_soa(bld->gallivm,
                           bld->format_desc,
                           bld->texel_type,
                           data_ptr, offset,
                           i, j,
                           texel_out);

d171 23
a195 3
      LLVMValueRef border_color_ptr = 
         bld->dynamic_state->border_color(bld->dynamic_state,
                                          bld->gallivm, unit);
d199 4
a202 6
            lp_build_array_get(bld->gallivm, border_color_ptr,
                               lp_build_const_int32(bld->gallivm, chan));
         LLVMValueRef border_chan_vec =
            lp_build_broadcast_scalar(&bld->float_vec_bld, border_chan);
         texel_out[chan] = lp_build_select(&bld->texel_bld, use_border,
                                           border_chan_vec, texel_out[chan]);
d205 11
d217 14
a230 1
   apply_sampler_swizzle(bld, texel_out);
d245 5
a249 1
   lp_build_ifloor_fract(coord_bld, coord, &flr, &fract);
d252 1
a252 1
   isOdd = LLVMBuildAnd(bld->gallivm->builder, flr, int_coord_bld->one, "");
d268 75
a351 1
                            LLVMValueRef length_f,
d360 6
a365 3
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef half = lp_build_const_vec(bld->gallivm, coord_bld->type, 0.5);
   LLVMValueRef length_minus_one = lp_build_sub(int_coord_bld, length, int_coord_bld->one);
d373 5
a377 2
      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
d380 2
a381 3
         coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
         coord0 = LLVMBuildAnd(builder, coord0, length_minus_one, "");
         coord1 = LLVMBuildAnd(builder, coord1, length_minus_one, "");
d384 4
a387 10
         /* Add a bias to the texcoord to handle negative coords */
         LLVMValueRef bias = lp_build_mul_imm(int_coord_bld, length, 1024);
         LLVMValueRef mask;
         coord0 = LLVMBuildAdd(builder, coord0, bias, "");
         coord0 = LLVMBuildURem(builder, coord0, length, "");
         mask = lp_build_compare(bld->gallivm, int_coord_bld->type,
                                 PIPE_FUNC_NOTEQUAL, coord0, length_minus_one);
         coord1 = LLVMBuildAnd(builder,
                              lp_build_add(int_coord_bld, coord0, int_coord_bld->one),
                              mask, "");
a392 1
         /* scale coord to length */
d395 8
a402 9

      /* clamp to [0, length] */
      coord = lp_build_clamp(coord_bld, coord, coord_bld->zero, length_f);

      coord = lp_build_sub(coord_bld, coord, half);

      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
      coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
d406 5
a410 11
      {
         struct lp_build_context abs_coord_bld = bld->coord_bld;
         abs_coord_bld.type.sign = FALSE;

         if (bld->static_state->normalized_coords) {
            /* mul by tex size */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }
         /* clamp to length max */
         coord = lp_build_min(coord_bld, coord, length_f);
         /* subtract 0.5 */
a411 8
         /* clamp to [0, length - 0.5] */
         coord = lp_build_max(coord_bld, coord, coord_bld->zero);
         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(&abs_coord_bld, coord, &coord0, &weight);
         coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
         /* coord1 = min(coord1, length-1) */
         coord1 = lp_build_min(int_coord_bld, coord1, length_minus_one);
         break;
d413 17
d433 1
a433 1
         LLVMValueRef min;
d435 9
a443 1
            /* scale coord to length */
d445 8
d454 4
a457 6
         /* was: clamp to [-0.5, length + 0.5], then sub 0.5 */
         coord = lp_build_sub(coord_bld, coord, half);
         min = lp_build_const_vec(bld->gallivm, coord_bld->type, -1.0F);
         coord = lp_build_clamp(coord_bld, coord, min, length_f);
         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
d470 5
a474 2
      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
d484 6
a489 1
      coord = lp_build_abs(coord_bld, coord);
d491 2
a492 2
      if (bld->static_state->normalized_coords) {
         /* scale coord to length */
d494 4
a498 9

      /* clamp to [0, length] */
      coord = lp_build_min(coord_bld, coord, length_f);

      coord = lp_build_sub(coord_bld, coord, half);

      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
      coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
d504 5
a508 2
         struct lp_build_context abs_coord_bld = bld->coord_bld;
         abs_coord_bld.type.sign = FALSE;
a509 9

         if (bld->static_state->normalized_coords) {
            /* scale coord to length */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }

         /* clamp to [0.5, length - 0.5] */
         min = half;
         max = lp_build_sub(coord_bld, length_f, min);
d511 1
a511 1

d513 2
a514 3

         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(&abs_coord_bld, coord, &coord0, &weight);
d521 8
d530 2
a531 8

         if (bld->static_state->normalized_coords) {
            /* scale coord to length */
            coord = lp_build_mul(coord_bld, coord, length_f);
         }

         /* was: clamp to [-0.5, length + 0.5] then sub 0.5 */
         /* skip -0.5 clamp (always positive), do sub first */
d533 2
a534 4
         coord = lp_build_min(coord_bld, coord, length_f);

         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
d555 1
a555 1
 * \param length  the texture size along one dimension, as int vector
a562 1
                             LLVMValueRef length_f,
d568 5
a572 2
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef length_minus_one = lp_build_sub(int_coord_bld, length, int_coord_bld->one);
d580 5
a584 7
         icoord = LLVMBuildAnd(builder, icoord, length_minus_one, "");
      else {
         /* Add a bias to the texcoord to handle negative coords */
         LLVMValueRef bias = lp_build_mul_imm(int_coord_bld, length, 1024);
         icoord = LLVMBuildAdd(builder, icoord, bias, "");
         icoord = LLVMBuildURem(builder, icoord, length, "");
      }
d588 1
a588 1
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
a589 1
         /* scale coord to length */
a591 1

d593 2
a594 4
      /* use itrunc instead since we clamp to 0 anyway */
      icoord = lp_build_itrunc(coord_bld, coord);

      /* clamp to [0, length - 1]. */
d599 22
a624 1

d626 6
d635 7
a641 1

a642 5

         /* clamp to [-1, length] */
         min = lp_build_negate(int_coord_bld, int_coord_bld->one);
         max = length;
         icoord = lp_build_clamp(int_coord_bld, icoord, min, max);
d647 6
a652 2
      /* compute mirror function */
      coord = lp_build_coord_mirror(bld, coord);
d654 2
a655 3
      /* scale coord to length */
      assert(bld->static_state->normalized_coords);
      coord = lp_build_mul(coord_bld, coord, length_f);
d657 2
a658 2
      /* itrunc == ifloor here */
      icoord = lp_build_itrunc(coord_bld, coord);
d660 4
a663 2
      /* clamp to [0, length - 1] */
      icoord = lp_build_min(int_coord_bld, icoord, length_minus_one);
d667 6
d674 6
a679 1
      coord = lp_build_abs(coord_bld, coord);
d681 1
a681 2
      if (bld->static_state->normalized_coords) {
         /* scale coord to length */
d683 2
a685 6

      /* itrunc == ifloor here */
      icoord = lp_build_itrunc(coord_bld, coord);

      /* clamp to [0, length - 1] */
      icoord = lp_build_min(int_coord_bld, icoord, length_minus_one);
d689 7
a695 1
      coord = lp_build_abs(coord_bld, coord);
d697 1
a697 2
      if (bld->static_state->normalized_coords) {
         /* scale coord to length */
d699 2
a701 6

      /* itrunc == ifloor here */
      icoord = lp_build_itrunc(coord_bld, coord);

      /* clamp to [0, length] */
      icoord = lp_build_min(int_coord_bld, icoord, length);
d714 1
a714 2
 * Generate code to sample a mipmap level with nearest filtering.
 * If sampling a cube texture, r = cube face in [0,5].
d717 8
a724 10
lp_build_sample_image_nearest(struct lp_build_sample_context *bld,
                              unsigned unit,
                              LLVMValueRef size,
                              LLVMValueRef row_stride_vec,
                              LLVMValueRef img_stride_vec,
                              LLVMValueRef data_ptr,
                              LLVMValueRef s,
                              LLVMValueRef t,
                              LLVMValueRef r,
                              LLVMValueRef colors_out[4])
d726 1
a726 23
   const unsigned dims = bld->dims;
   LLVMValueRef width_vec;
   LLVMValueRef height_vec;
   LLVMValueRef depth_vec;
   LLVMValueRef flt_size;
   LLVMValueRef flt_width_vec;
   LLVMValueRef flt_height_vec;
   LLVMValueRef flt_depth_vec;
   LLVMValueRef x, y, z;

   lp_build_extract_image_sizes(bld,
                                bld->int_size_type,
                                bld->int_coord_type,
                                size,
                                &width_vec, &height_vec, &depth_vec);

   flt_size = lp_build_int_to_float(&bld->float_size_bld, size);

   lp_build_extract_image_sizes(bld,
                                bld->float_size_type,
                                bld->coord_type,
                                flt_size,
                                &flt_width_vec, &flt_height_vec, &flt_depth_vec);
d728 1
a728 4
   /*
    * Compute integer texcoords.
    */
   x = lp_build_sample_wrap_nearest(bld, s, width_vec, flt_width_vec,
d731 4
d736 1
d738 1
a738 31
   if (dims >= 2) {
      y = lp_build_sample_wrap_nearest(bld, t, height_vec, flt_height_vec,
                                       bld->static_state->pot_height,
                                       bld->static_state->wrap_t);
      lp_build_name(y, "tex.y.wrapped");

      if (dims == 3) {
         z = lp_build_sample_wrap_nearest(bld, r, depth_vec, flt_depth_vec,
                                          bld->static_state->pot_depth,
                                          bld->static_state->wrap_r);
         lp_build_name(z, "tex.z.wrapped");
      }
      else if (bld->static_state->target == PIPE_TEXTURE_CUBE) {
         z = r;
      }
      else {
         z = NULL;
      }
   }
   else {
      y = z = NULL;
   }

   /*
    * Get texture colors.
    */
   lp_build_sample_texel_soa(bld, unit,
                             width_vec, height_vec, depth_vec,
                             x, y, z,
                             row_stride_vec, img_stride_vec,
                             data_ptr, colors_out);
d743 1
a743 2
 * Generate code to sample a mipmap level with linear filtering.
 * If sampling a cube texture, r = cube face in [0,5].
d746 8
a753 10
lp_build_sample_image_linear(struct lp_build_sample_context *bld,
                             unsigned unit,
                             LLVMValueRef size,
                             LLVMValueRef row_stride_vec,
                             LLVMValueRef img_stride_vec,
                             LLVMValueRef data_ptr,
                             LLVMValueRef s,
                             LLVMValueRef t,
                             LLVMValueRef r,
                             LLVMValueRef colors_out[4])
d755 4
a758 10
   const unsigned dims = bld->dims;
   LLVMValueRef width_vec;
   LLVMValueRef height_vec;
   LLVMValueRef depth_vec;
   LLVMValueRef flt_size;
   LLVMValueRef flt_width_vec;
   LLVMValueRef flt_height_vec;
   LLVMValueRef flt_depth_vec;
   LLVMValueRef x0, y0, z0, x1, y1, z1;
   LLVMValueRef s_fpart, t_fpart, r_fpart;
d760 52
a811 1
   int chan;
d813 79
a891 13
   lp_build_extract_image_sizes(bld,
                                bld->int_size_type,
                                bld->int_coord_type,
                                size,
                                &width_vec, &height_vec, &depth_vec);

   flt_size = lp_build_int_to_float(&bld->float_size_bld, size);

   lp_build_extract_image_sizes(bld,
                                bld->float_size_type,
                                bld->coord_type,
                                flt_size,
                                &flt_width_vec, &flt_height_vec, &flt_depth_vec);
d894 15
a908 1
    * Compute integer texcoords.
d910 32
a941 35
   lp_build_sample_wrap_linear(bld, s, width_vec, flt_width_vec,
                               bld->static_state->pot_width,
                               bld->static_state->wrap_s,
                               &x0, &x1, &s_fpart);
   lp_build_name(x0, "tex.x0.wrapped");
   lp_build_name(x1, "tex.x1.wrapped");

   if (dims >= 2) {
      lp_build_sample_wrap_linear(bld, t, height_vec, flt_height_vec,
                                  bld->static_state->pot_height,
                                  bld->static_state->wrap_t,
                                  &y0, &y1, &t_fpart);
      lp_build_name(y0, "tex.y0.wrapped");
      lp_build_name(y1, "tex.y1.wrapped");

      if (dims == 3) {
         lp_build_sample_wrap_linear(bld, r, depth_vec, flt_depth_vec,
                                     bld->static_state->pot_depth,
                                     bld->static_state->wrap_r,
                                     &z0, &z1, &r_fpart);
         lp_build_name(z0, "tex.z0.wrapped");
         lp_build_name(z1, "tex.z1.wrapped");
      }
      else if (bld->static_state->target == PIPE_TEXTURE_CUBE) {
         z0 = z1 = r;  /* cube face */
         r_fpart = NULL;
      }
      else {
         z0 = z1 = NULL;
         r_fpart = NULL;
      }
   }
   else {
      y0 = y1 = t_fpart = NULL;
      z0 = z1 = r_fpart = NULL;
d945 33
a977 1
    * Get texture colors.
a978 11
   /* get x0/x1 texels */
   lp_build_sample_texel_soa(bld, unit,
                             width_vec, height_vec, depth_vec,
                             x0, y0, z0,
                             row_stride_vec, img_stride_vec,
                             data_ptr, neighbors[0][0]);
   lp_build_sample_texel_soa(bld, unit,
                             width_vec, height_vec, depth_vec,
                             x1, y0, z0,
                             row_stride_vec, img_stride_vec,
                             data_ptr, neighbors[0][1]);
d980 19
a998 23
   if (dims == 1) {
      /* Interpolate two samples from 1D image to produce one color */
      for (chan = 0; chan < 4; chan++) {
         colors_out[chan] = lp_build_lerp(&bld->texel_bld, s_fpart,
                                          neighbors[0][0][chan],
                                          neighbors[0][1][chan]);
      }
   }
   else {
      /* 2D/3D texture */
      LLVMValueRef colors0[4];

      /* get x0/x1 texels at y1 */
      lp_build_sample_texel_soa(bld, unit,
                                width_vec, height_vec, depth_vec,
                                x0, y1, z0,
                                row_stride_vec, img_stride_vec,
                                data_ptr, neighbors[1][0]);
      lp_build_sample_texel_soa(bld, unit,
                                width_vec, height_vec, depth_vec,
                                x1, y1, z0,
                                row_stride_vec, img_stride_vec,
                                data_ptr, neighbors[1][1]);
d1000 1
a1000 45
      /* Bilinear interpolate the four samples from the 2D image / 3D slice */
      for (chan = 0; chan < 4; chan++) {
         colors0[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                          s_fpart, t_fpart,
                                          neighbors[0][0][chan],
                                          neighbors[0][1][chan],
                                          neighbors[1][0][chan],
                                          neighbors[1][1][chan]);
      }

      if (dims == 3) {
         LLVMValueRef neighbors1[2][2][4];
         LLVMValueRef colors1[4];

         /* get x0/x1/y0/y1 texels at z1 */
         lp_build_sample_texel_soa(bld, unit,
                                   width_vec, height_vec, depth_vec,
                                   x0, y0, z1,
                                   row_stride_vec, img_stride_vec,
                                   data_ptr, neighbors1[0][0]);
         lp_build_sample_texel_soa(bld, unit,
                                   width_vec, height_vec, depth_vec,
                                   x1, y0, z1,
                                   row_stride_vec, img_stride_vec,
                                   data_ptr, neighbors1[0][1]);
         lp_build_sample_texel_soa(bld, unit,
                                   width_vec, height_vec, depth_vec,
                                   x0, y1, z1,
                                   row_stride_vec, img_stride_vec,
                                   data_ptr, neighbors1[1][0]);
         lp_build_sample_texel_soa(bld, unit,
                                   width_vec, height_vec, depth_vec,
                                   x1, y1, z1,
                                   row_stride_vec, img_stride_vec,
                                   data_ptr, neighbors1[1][1]);

         /* Bilinear interpolate the four samples from the second Z slice */
         for (chan = 0; chan < 4; chan++) {
            colors1[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                             s_fpart, t_fpart,
                                             neighbors1[0][0][chan],
                                             neighbors1[0][1][chan],
                                             neighbors1[1][0][chan],
                                             neighbors1[1][1][chan]);
         }
d1002 7
a1008 14
         /* Linearly interpolate the two samples from the two 3D slices */
         for (chan = 0; chan < 4; chan++) {
            colors_out[chan] = lp_build_lerp(&bld->texel_bld,
                                             r_fpart,
                                             colors0[chan], colors1[chan]);
         }
      }
      else {
         /* 2D tex */
         for (chan = 0; chan < 4; chan++) {
            colors_out[chan] = colors0[chan];
         }
      }
   }
a1011 6
/**
 * Sample the texture/mipmap using given image filter and mip filter.
 * data0_ptr and data1_ptr point to the two mipmap levels to sample
 * from.  width0/1_vec, height0/1_vec, depth0/1_vec indicate their sizes.
 * If we're using nearest miplevel sampling the '1' values will be null/unused.
 */
d1013 3
a1015 11
lp_build_sample_mipmap(struct lp_build_sample_context *bld,
                       unsigned unit,
                       unsigned img_filter,
                       unsigned mip_filter,
                       LLVMValueRef s,
                       LLVMValueRef t,
                       LLVMValueRef r,
                       LLVMValueRef ilevel0,
                       LLVMValueRef ilevel1,
                       LLVMValueRef lod_fpart,
                       LLVMValueRef *colors_out)
d1017 2
a1018 10
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef size0;
   LLVMValueRef size1;
   LLVMValueRef row_stride0_vec;
   LLVMValueRef row_stride1_vec;
   LLVMValueRef img_stride0_vec;
   LLVMValueRef img_stride1_vec;
   LLVMValueRef data_ptr0;
   LLVMValueRef data_ptr1;
   LLVMValueRef colors0[4], colors1[4];
d1021 2
a1022 20
   /* sample the first mipmap level */
   lp_build_mipmap_level_sizes(bld, ilevel0,
                               &size0,
                               &row_stride0_vec, &img_stride0_vec);
   data_ptr0 = lp_build_get_mipmap_level(bld, ilevel0);
   if (img_filter == PIPE_TEX_FILTER_NEAREST) {
      lp_build_sample_image_nearest(bld, unit,
                                    size0,
                                    row_stride0_vec, img_stride0_vec,
                                    data_ptr0, s, t, r,
                                    colors0);
   }
   else {
      assert(img_filter == PIPE_TEX_FILTER_LINEAR);
      lp_build_sample_image_linear(bld, unit,
                                   size0,
                                   row_stride0_vec, img_stride0_vec,
                                   data_ptr0, s, t, r,
                                   colors0);
   }
d1024 11
a1034 3
   /* Store the first level's colors in the output variables */
   for (chan = 0; chan < 4; chan++) {
       LLVMBuildStore(builder, colors0[chan], colors_out[chan]);
d1037 2
a1038 9
   if (mip_filter == PIPE_TEX_MIPFILTER_LINEAR) {
      struct lp_build_if_state if_ctx;
      LLVMValueRef need_lerp;

      /* need_lerp = lod_fpart > 0 */
      need_lerp = LLVMBuildFCmp(builder, LLVMRealUGT,
                                lod_fpart,
                                bld->float_bld.zero,
                                "need_lerp");
d1040 5
a1044 21
      lp_build_if(&if_ctx, bld->gallivm, need_lerp);
      {
         /* sample the second mipmap level */
         lp_build_mipmap_level_sizes(bld, ilevel1,
                                     &size1,
                                     &row_stride1_vec, &img_stride1_vec);
         data_ptr1 = lp_build_get_mipmap_level(bld, ilevel1);
         if (img_filter == PIPE_TEX_FILTER_NEAREST) {
            lp_build_sample_image_nearest(bld, unit,
                                          size1,
                                          row_stride1_vec, img_stride1_vec,
                                          data_ptr1, s, t, r,
                                          colors1);
         }
         else {
            lp_build_sample_image_linear(bld, unit,
                                         size1,
                                         row_stride1_vec, img_stride1_vec,
                                         data_ptr1, s, t, r,
                                         colors1);
         }
a1045 1
         /* interpolate samples from the two mipmap levels */
d1047 14
a1060 9
         lod_fpart = lp_build_broadcast_scalar(&bld->texel_bld, lod_fpart);

         for (chan = 0; chan < 4; chan++) {
            colors0[chan] = lp_build_lerp(&bld->texel_bld, lod_fpart,
                                          colors0[chan], colors1[chan]);
            LLVMBuildStore(builder, colors0[chan], colors_out[chan]);
         }
      }
      lp_build_endif(&if_ctx);
a1064 1

d1066 7
a1072 3
 * General texture sampling codegen.
 * This function handles texture sampling for all texture targets (1D,
 * 2D, 3D, cube) and all filtering modes.
d1074 9
a1082 11
static void
lp_build_sample_general(struct lp_build_sample_context *bld,
                        unsigned unit,
                        LLVMValueRef s,
                        LLVMValueRef t,
                        LLVMValueRef r,
                        const LLVMValueRef *ddx,
                        const LLVMValueRef *ddy,
                        LLVMValueRef lod_bias, /* optional */
                        LLVMValueRef explicit_lod, /* optional */
                        LLVMValueRef *colors_out)
d1084 2
a1085 11
   struct lp_build_context *int_bld = &bld->int_bld;
   LLVMBuilderRef builder = bld->gallivm->builder;
   const unsigned mip_filter = bld->static_state->min_mip_filter;
   const unsigned min_filter = bld->static_state->min_img_filter;
   const unsigned mag_filter = bld->static_state->mag_img_filter;
   LLVMValueRef lod_ipart = NULL, lod_fpart = NULL;
   LLVMValueRef ilevel0, ilevel1 = NULL;
   LLVMValueRef face_ddx[4], face_ddy[4];
   LLVMValueRef texels[4];
   LLVMValueRef i32t_zero = lp_build_const_int32(bld->gallivm, 0);
   unsigned chan;
d1087 16
a1102 4
   /*
   printf("%s mip %d  min %d  mag %d\n", __FUNCTION__,
          mip_filter, min_filter, mag_filter);
   */
d1105 7
a1111 1
    * Choose cube face, recompute texcoords and derivatives for the chosen face.
d1113 18
a1130 19
   if (bld->static_state->target == PIPE_TEXTURE_CUBE) {
      LLVMValueRef face, face_s, face_t;
      lp_build_cube_lookup(bld, s, t, r, &face, &face_s, &face_t);
      s = face_s; /* vec */
      t = face_t; /* vec */
      /* use 'r' to indicate cube face */
      r = lp_build_broadcast_scalar(&bld->int_coord_bld, face); /* vec */

      /* recompute ddx, ddy using the new (s,t) face texcoords */
      face_ddx[0] = lp_build_scalar_ddx(&bld->coord_bld, s);
      face_ddx[1] = lp_build_scalar_ddx(&bld->coord_bld, t);
      face_ddx[2] = NULL;
      face_ddx[3] = NULL;
      face_ddy[0] = lp_build_scalar_ddy(&bld->coord_bld, s);
      face_ddy[1] = lp_build_scalar_ddy(&bld->coord_bld, t);
      face_ddy[2] = NULL;
      face_ddy[3] = NULL;
      ddx = face_ddx;
      ddy = face_ddy;
d1133 2
a1134 18
   /*
    * Compute the level of detail (float).
    */
   if (min_filter != mag_filter ||
       mip_filter != PIPE_TEX_MIPFILTER_NONE) {
      /* Need to compute lod either to choose mipmap levels or to
       * distinguish between minification/magnification with one mipmap level.
       */
      lp_build_lod_selector(bld, unit, ddx, ddy,
                            lod_bias, explicit_lod,
                            mip_filter,
                            &lod_ipart, &lod_fpart);
   } else {
      lod_ipart = i32t_zero;
   }

   /*
    * Compute integer mipmap level(s) to fetch texels from: ilevel0, ilevel1
d1136 14
a1149 13
   switch (mip_filter) {
   default:
      assert(0 && "bad mip_filter value in lp_build_sample_soa()");
      /* fall-through */
   case PIPE_TEX_MIPFILTER_NONE:
      /* always use mip level 0 */
      if (bld->static_state->target == PIPE_TEXTURE_CUBE) {
         /* XXX this is a work-around for an apparent bug in LLVM 2.7.
          * We should be able to set ilevel0 = const(0) but that causes
          * bad x86 code to be emitted.
          */
         assert(lod_ipart);
         lp_build_nearest_mip_level(bld, unit, lod_ipart, &ilevel0);
a1150 15
      else {
         ilevel0 = i32t_zero;
      }
      break;
   case PIPE_TEX_MIPFILTER_NEAREST:
      assert(lod_ipart);
      lp_build_nearest_mip_level(bld, unit, lod_ipart, &ilevel0);
      break;
   case PIPE_TEX_MIPFILTER_LINEAR:
      assert(lod_ipart);
      assert(lod_fpart);
      lp_build_linear_mip_levels(bld, unit,
                                 lod_ipart, &lod_fpart,
                                 &ilevel0, &ilevel1);
      break;
d1153 2
a1154 3
   /*
    * Get/interpolate texture colors.
    */
d1156 2
a1157 23
   for (chan = 0; chan < 4; ++chan) {
     texels[chan] = lp_build_alloca(bld->gallivm, bld->texel_bld.vec_type, "");
     lp_build_name(texels[chan], "sampler%u_texel_%c_var", unit, "xyzw"[chan]);
   }

   if (min_filter == mag_filter) {
      /* no need to distinquish between minification and magnification */
      lp_build_sample_mipmap(bld, unit,
                             min_filter, mip_filter,
                             s, t, r,
                             ilevel0, ilevel1, lod_fpart,
                             texels);
   }
   else {
      /* Emit conditional to choose min image filter or mag image filter
       * depending on the lod being > 0 or <= 0, respectively.
       */
      struct lp_build_if_state if_ctx;
      LLVMValueRef minify;

      /* minify = lod >= 0.0 */
      minify = LLVMBuildICmp(builder, LLVMIntSGE,
                             lod_ipart, int_bld->zero, "");
d1159 2
a1160 20
      lp_build_if(&if_ctx, bld->gallivm, minify);
      {
         /* Use the minification filter */
         lp_build_sample_mipmap(bld, unit,
                                min_filter, mip_filter,
                                s, t, r,
                                ilevel0, ilevel1, lod_fpart,
                                texels);
      }
      lp_build_else(&if_ctx);
      {
         /* Use the magnification filter */
         lp_build_sample_mipmap(bld, unit,
                                mag_filter, PIPE_TEX_MIPFILTER_NONE,
                                s, t, r,
                                i32t_zero, NULL, NULL,
                                texels);
      }
      lp_build_endif(&if_ctx);
   }
d1162 1
a1162 4
   for (chan = 0; chan < 4; ++chan) {
     colors_out[chan] = LLVMBuildLoad(builder, texels[chan], "");
     lp_build_name(colors_out[chan], "sampler%u_texel_%c", unit, "xyzw"[chan]);
   }
d1167 4
a1170 3
 * Do shadow test/comparison.
 * \param p  the texcoord Z (aka R, aka P) component
 * \param texel  the texel to compare against (use the X channel)
d1173 4
a1176 3
lp_build_sample_compare(struct lp_build_sample_context *bld,
                        LLVMValueRef p,
                        LLVMValueRef texel[4])
d1178 3
a1180 7
   struct lp_build_context *texel_bld = &bld->texel_bld;
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef res;
   const unsigned chan = 0;

   if (bld->static_state->compare_mode == PIPE_TEX_COMPARE_NONE)
      return;
d1182 2
a1183 8
   /* debug code */
   if (0) {
      LLVMValueRef indx = lp_build_const_int32(bld->gallivm, 0);
      LLVMValueRef coord = LLVMBuildExtractElement(builder, p, indx, "");
      LLVMValueRef tex = LLVMBuildExtractElement(builder, texel[chan], indx, "");
      lp_build_printf(bld->gallivm, "shadow compare coord %f to texture %f\n",
                      coord, tex);
   }
d1185 2
a1186 4
   /* result = (p FUNC texel) ? 1 : 0 */
   res = lp_build_cmp(texel_bld, bld->static_state->compare_func,
                      p, texel[chan]);
   res = lp_build_select(texel_bld, res, texel_bld->one, texel_bld->zero);
d1188 4
a1191 5
   /* XXX returning result for default GL_DEPTH_TEXTURE_MODE = GL_LUMINANCE */
   texel[0] =
   texel[1] =
   texel[2] = res;
   texel[3] = texel_bld->one;
d1196 3
a1198 2
 * Just set texels to white instead of actually sampling the texture.
 * For debugging.
d1200 7
a1206 3
void
lp_build_sample_nop(struct gallivm_state *gallivm, struct lp_type type,
                    LLVMValueRef texel_out[4])
d1208 17
a1224 2
   LLVMValueRef one = lp_build_one(gallivm, type);
   unsigned chan;
d1226 1
a1226 3
   for (chan = 0; chan < 4; chan++) {
      texel_out[chan] = one;
   }  
d1230 1
a1234 3
 * \param type  vector float type to use for coords, etc.
 * \param ddx  partial derivatives of (s,t,r,q) with respect to x
 * \param ddy  partial derivatives of (s,t,r,q) with respect to y
d1237 1
a1237 1
lp_build_sample_soa(struct gallivm_state *gallivm,
d1244 2
a1245 5
                    const LLVMValueRef ddx[4],
                    const LLVMValueRef ddy[4],
                    LLVMValueRef lod_bias, /* optional */
                    LLVMValueRef explicit_lod, /* optional */
                    LLVMValueRef texel_out[4])
a1246 1
   unsigned dims = texture_dims(static_state->target);
d1248 4
a1251 2
   LLVMTypeRef i32t = LLVMInt32TypeInContext(gallivm->context);
   LLVMBuilderRef builder = gallivm->builder;
a1254 6
   struct lp_type float_vec_type;

   if (0) {
      enum pipe_format fmt = static_state->format;
      debug_printf("Sample from %s\n", util_format_name(fmt));
   }
d1256 3
a1258 1
   assert(type.floating);
d1262 1
a1262 1
   bld.gallivm = gallivm;
a1265 4
   bld.dims = dims;

   bld.float_type = lp_type_float(32);
   bld.int_type = lp_type_int(32);
d1267 1
a1268 3
   bld.float_size_type = lp_type_float(32);
   bld.float_size_type.length = dims > 1 ? 4 : 1;
   bld.int_size_type = lp_int_type(bld.float_size_type);
d1270 4
a1273 11

   float_vec_type = lp_type_float_vec(32);

   lp_build_context_init(&bld.float_bld, gallivm, bld.float_type);
   lp_build_context_init(&bld.float_vec_bld, gallivm, float_vec_type);
   lp_build_context_init(&bld.int_bld, gallivm, bld.int_type);
   lp_build_context_init(&bld.coord_bld, gallivm, bld.coord_type);
   lp_build_context_init(&bld.int_coord_bld, gallivm, bld.int_coord_type);
   lp_build_context_init(&bld.int_size_bld, gallivm, bld.int_size_type);
   lp_build_context_init(&bld.float_size_bld, gallivm, bld.float_size_type);
   lp_build_context_init(&bld.texel_bld, gallivm, bld.texel_type);
d1276 4
a1279 7
   bld.width = dynamic_state->width(dynamic_state, gallivm, unit);
   bld.height = dynamic_state->height(dynamic_state, gallivm, unit);
   bld.depth = dynamic_state->depth(dynamic_state, gallivm, unit);
   bld.row_stride_array = dynamic_state->row_stride(dynamic_state, gallivm, unit);
   bld.img_stride_array = dynamic_state->img_stride(dynamic_state, gallivm, unit);
   bld.data_array = dynamic_state->data_ptr(dynamic_state, gallivm, unit);
   /* Note that data_array is an array[level] of pointers to texture images */
d1285 24
a1308 15
   /* width, height, depth as single int vector */
   if (dims <= 1) {
      bld.int_size = bld.width;
   }
   else {
      bld.int_size = LLVMBuildInsertElement(builder, bld.int_size_bld.undef,
                                            bld.width, LLVMConstInt(i32t, 0, 0), "");
      if (dims >= 2) {
         bld.int_size = LLVMBuildInsertElement(builder, bld.int_size,
                                               bld.height, LLVMConstInt(i32t, 1, 0), "");
         if (dims >= 3) {
            bld.int_size = LLVMBuildInsertElement(builder, bld.int_size,
                                                  bld.depth, LLVMConstInt(i32t, 2, 0), "");
         }
      }
d1311 2
a1312 30
   if (0) {
      /* For debug: no-op texture sampling */
      lp_build_sample_nop(gallivm, bld.texel_type, texel_out);
   }
   else if (util_format_fits_8unorm(bld.format_desc) &&
            lp_is_simple_wrap_mode(static_state->wrap_s) &&
            lp_is_simple_wrap_mode(static_state->wrap_t)) {
      /* do sampling/filtering with fixed pt arithmetic */
      lp_build_sample_aos(&bld, unit, s, t, r, ddx, ddy,
                          lod_bias, explicit_lod,
                          texel_out);
   }

   else {
      if ((gallivm_debug & GALLIVM_DEBUG_PERF) &&
          util_format_fits_8unorm(bld.format_desc)) {
         debug_printf("%s: using floating point linear filtering for %s\n",
                      __FUNCTION__, bld.format_desc->short_name);
         debug_printf("  min_img %d  mag_img %d  mip %d  wraps %d  wrapt %d\n",
                      static_state->min_img_filter,
                      static_state->mag_img_filter,
                      static_state->min_mip_filter,
                      static_state->wrap_s,
                      static_state->wrap_t);
      }

      lp_build_sample_general(&bld, unit, s, t, r, ddx, ddy,
                              lod_bias, explicit_lod,
                              texel_out);
   }
d1314 1
a1314 1
   lp_build_sample_compare(&bld, r, texel_out);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a37 1
#include "pipe/p_shader_tokens.h"
a42 1
#include "util/u_cpu_detect.h"
a58 1
#include "lp_bld_pack.h"
d72 1
a72 1
                          unsigned sampler_unit,
a81 1
                          LLVMValueRef mipoffsets,
d84 1
a84 1
   const struct lp_static_sampler_state *static_state = bld->static_sampler_state;
a138 3
   if (mipoffsets) {
      offset = lp_build_add(&bld->int_coord_bld, offset, mipoffsets);
   }
d178 1
a178 1
                                          bld->gallivm, sampler_unit);
a185 5

         if (!bld->texel_type.floating) {
            border_chan_vec = LLVMBuildBitCast(builder, border_chan_vec,
                                               bld->texel_bld.vec_type, "");
         }
d190 2
a224 35
 * Helper to compute the first coord and the weight for
 * linear wrap repeat npot textures
 */
void
lp_build_coord_repeat_npot_linear(struct lp_build_sample_context *bld,
                                  LLVMValueRef coord_f,
                                  LLVMValueRef length_i,
                                  LLVMValueRef length_f,
                                  LLVMValueRef *coord0_i,
                                  LLVMValueRef *weight_f)
{
   struct lp_build_context *coord_bld = &bld->coord_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   LLVMValueRef half = lp_build_const_vec(bld->gallivm, coord_bld->type, 0.5);
   LLVMValueRef length_minus_one = lp_build_sub(int_coord_bld, length_i,
                                                int_coord_bld->one);
   LLVMValueRef mask;
   /* wrap with normalized floats is just fract */
   coord_f = lp_build_fract(coord_bld, coord_f);
   /* mul by size and subtract 0.5 */
   coord_f = lp_build_mul(coord_bld, coord_f, length_f);
   coord_f = lp_build_sub(coord_bld, coord_f, half);
   /*
    * we avoided the 0.5/length division before the repeat wrap,
    * now need to fix up edge cases with selects
    */
   /* convert to int, compute lerp weight */
   lp_build_ifloor_fract(coord_bld, coord_f, coord0_i, weight_f);
   mask = lp_build_compare(int_coord_bld->gallivm, int_coord_bld->type,
                           PIPE_FUNC_LESS, *coord0_i, int_coord_bld->zero);
   *coord0_i = lp_build_select(int_coord_bld, mask, length_minus_one, *coord0_i);
}


/**
a234 1
                            LLVMValueRef offset,
d250 6
a256 9
         /* mul by size and subtract 0.5 */
         coord = lp_build_mul(coord_bld, coord, length_f);
         coord = lp_build_sub(coord_bld, coord, half);
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            coord = lp_build_add(coord_bld, coord, offset);
         }
         /* convert to int, compute lerp weight */
         lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
a257 1
         /* repeat wrap */
d262 2
d265 3
a267 9
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            offset = lp_build_div(coord_bld, offset, length_f);
            coord = lp_build_add(coord_bld, coord, offset);
         }
         lp_build_coord_repeat_npot_linear(bld, coord,
                                           length, length_f,
                                           &coord0, &weight);
         mask = lp_build_compare(int_coord_bld->gallivm, int_coord_bld->type,
d270 2
a271 2
                               lp_build_add(int_coord_bld, coord0, int_coord_bld->one),
                               mask, "");
d276 1
a276 1
      if (bld->static_sampler_state->normalized_coords) {
a279 4
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
d296 1
a296 1
         if (bld->static_sampler_state->normalized_coords) {
a299 5
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            coord = lp_build_add(coord_bld, coord, offset);
         }

d315 13
a327 7
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
a328 6
      /* was: clamp to [-0.5, length + 0.5], then sub 0.5 */
      /* can skip clamp (though might not work for very large coord values */
      coord = lp_build_sub(coord_bld, coord, half);
      /* convert to int, compute lerp weight */
      lp_build_ifloor_fract(coord_bld, coord, &coord0, &weight);
      coord1 = lp_build_add(int_coord_bld, coord0, int_coord_bld->one);
a337 4
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
d350 3
a352 1
      if (bld->static_sampler_state->normalized_coords) {
a355 5
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
      coord = lp_build_abs(coord_bld, coord);
d369 1
d372 1
d374 1
a374 1
         if (bld->static_sampler_state->normalized_coords) {
a377 5
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            coord = lp_build_add(coord_bld, coord, offset);
         }
         coord = lp_build_abs(coord_bld, coord);
d379 5
a383 3
         /* clamp to length max */
         coord = lp_build_min(coord_bld, coord, length_f);
         /* subtract 0.5 */
a384 2
         /* clamp to [0, length - 0.5] */
         coord = lp_build_max(coord_bld, coord, coord_bld->zero);
a388 2
         /* coord1 = min(coord1, length-1) */
         coord1 = lp_build_min(int_coord_bld, coord1, length_minus_one);
d394 3
a396 1
         if (bld->static_sampler_state->normalized_coords) {
a399 5
         if (offset) {
            offset = lp_build_int_to_float(coord_bld, offset);
            coord = lp_build_add(coord_bld, coord, offset);
         }
         coord = lp_build_abs(coord_bld, coord);
d402 1
a402 2
         /* skip clamp - always positive, and other side
            only potentially matters for very large coords */
d404 1
a428 2
 * \param length_f  the texture size along one dimension, as float vector
 * \param offset  texel offset along one dimension (as int vector)
a436 1
                             LLVMValueRef offset,
d448 3
a450 6
      if (is_pot) {
         coord = lp_build_mul(coord_bld, coord, length_f);
         icoord = lp_build_ifloor(coord_bld, coord);
         if (offset) {
            icoord = lp_build_add(int_coord_bld, icoord, offset);
         }
a451 1
      }
d453 4
a456 9
          if (offset) {
             offset = lp_build_int_to_float(coord_bld, offset);
             offset = lp_build_div(coord_bld, offset, length_f);
             coord = lp_build_add(coord_bld, coord, offset);
          }
          /* take fraction, unnormalize */
          coord = lp_build_fract_safe(coord_bld, coord);
          coord = lp_build_mul(coord_bld, coord, length_f);
          icoord = lp_build_itrunc(coord_bld, coord);
d462 1
a462 1
      if (bld->static_sampler_state->normalized_coords) {
a469 3
      if (offset) {
         icoord = lp_build_add(int_coord_bld, icoord, offset);
      }
d477 15
a491 8
      if (bld->static_sampler_state->normalized_coords) {
         /* scale coord to length */
         coord = lp_build_mul(coord_bld, coord, length_f);
      }
      /* no clamp necessary, border masking will handle this */
      icoord = lp_build_ifloor(coord_bld, coord);
      if (offset) {
         icoord = lp_build_add(int_coord_bld, icoord, offset);
a495 5
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         offset = lp_build_div(coord_bld, offset, length_f);
         coord = lp_build_add(coord_bld, coord, offset);
      }
d500 1
a500 1
      assert(bld->static_sampler_state->normalized_coords);
d512 3
a514 1
      if (bld->static_sampler_state->normalized_coords) {
a517 5
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
      coord = lp_build_abs(coord_bld, coord);
d527 3
a529 1
      if (bld->static_sampler_state->normalized_coords) {
a532 5
      if (offset) {
         offset = lp_build_int_to_float(coord_bld, offset);
         coord = lp_build_add(coord_bld, coord, offset);
      }
      coord = lp_build_abs(coord_bld, coord);
d536 3
d556 1
a556 1
                              unsigned sampler_unit,
a560 1
                              LLVMValueRef mipoffsets,
a563 1
                              const LLVMValueRef *offsets,
d574 1
a574 1
   LLVMValueRef x, y = NULL, z = NULL;
d577 1
a577 1
                                &bld->int_size_bld,
d585 1
a585 1
                                &bld->float_size_bld,
d593 3
a595 3
   x = lp_build_sample_wrap_nearest(bld, s, width_vec, flt_width_vec, offsets[0],
                                    bld->static_texture_state->pot_width,
                                    bld->static_sampler_state->wrap_s);
d599 3
a601 3
      y = lp_build_sample_wrap_nearest(bld, t, height_vec, flt_height_vec, offsets[1],
                                       bld->static_texture_state->pot_height,
                                       bld->static_sampler_state->wrap_t);
d605 3
a607 3
         z = lp_build_sample_wrap_nearest(bld, r, depth_vec, flt_depth_vec, offsets[2],
                                          bld->static_texture_state->pot_depth,
                                          bld->static_sampler_state->wrap_r);
d610 6
d617 2
a618 5
   if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
       bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
       bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
      z = r;
      lp_build_name(z, "tex.z.layer");
d624 1
a624 1
   lp_build_sample_texel_soa(bld, sampler_unit,
d628 1
a628 1
                             data_ptr, mipoffsets, colors_out);
d638 1
a638 1
                             unsigned sampler_unit,
a642 1
                             LLVMValueRef mipoffsets,
a645 1
                             const LLVMValueRef *offsets,
d656 2
a657 2
   LLVMValueRef x0, y0 = NULL, z0 = NULL, x1, y1 = NULL, z1 = NULL;
   LLVMValueRef s_fpart, t_fpart = NULL, r_fpart = NULL;
d662 1
a662 1
                                &bld->int_size_bld,
d670 1
a670 1
                                &bld->float_size_bld,
d678 3
a680 3
   lp_build_sample_wrap_linear(bld, s, width_vec, flt_width_vec, offsets[0],
                               bld->static_texture_state->pot_width,
                               bld->static_sampler_state->wrap_s,
d686 3
a688 3
      lp_build_sample_wrap_linear(bld, t, height_vec, flt_height_vec, offsets[1],
                                  bld->static_texture_state->pot_height,
                                  bld->static_sampler_state->wrap_t,
d694 3
a696 3
         lp_build_sample_wrap_linear(bld, r, depth_vec, flt_depth_vec, offsets[2],
                                     bld->static_texture_state->pot_depth,
                                     bld->static_sampler_state->wrap_r,
d701 8
d710 3
a712 6
   if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
       bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
       bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
      z0 = z1 = r;  /* cube face or array layer */
      lp_build_name(z0, "tex.z0.layer");
      lp_build_name(z1, "tex.z1.layer");
a714 1

d719 1
a719 1
   lp_build_sample_texel_soa(bld, sampler_unit,
d723 2
a724 2
                             data_ptr, mipoffsets, neighbors[0][0]);
   lp_build_sample_texel_soa(bld, sampler_unit,
d728 1
a728 1
                             data_ptr, mipoffsets, neighbors[0][1]);
d735 1
a735 2
                                          neighbors[0][1][chan],
                                          0);
d743 1
a743 1
      lp_build_sample_texel_soa(bld, sampler_unit,
d747 2
a748 2
                                data_ptr, mipoffsets, neighbors[1][0]);
      lp_build_sample_texel_soa(bld, sampler_unit,
d752 1
a752 1
                                data_ptr, mipoffsets, neighbors[1][1]);
d761 1
a761 2
                                          neighbors[1][1][chan],
                                          0);
d769 1
a769 1
         lp_build_sample_texel_soa(bld, sampler_unit,
d773 2
a774 2
                                   data_ptr, mipoffsets, neighbors1[0][0]);
         lp_build_sample_texel_soa(bld, sampler_unit,
d778 2
a779 2
                                   data_ptr, mipoffsets, neighbors1[0][1]);
         lp_build_sample_texel_soa(bld, sampler_unit,
d783 2
a784 2
                                   data_ptr, mipoffsets, neighbors1[1][0]);
         lp_build_sample_texel_soa(bld, sampler_unit,
d788 1
a788 1
                                   data_ptr, mipoffsets, neighbors1[1][1]);
d797 1
a797 2
                                             neighbors1[1][1][chan],
                                             0);
d804 1
a804 2
                                             colors0[chan], colors1[chan],
                                             0);
d825 1
a825 1
                       unsigned sampler_unit,
a830 1
                       const LLVMValueRef *offsets,
d837 8
a844 10
   LLVMValueRef size0 = NULL;
   LLVMValueRef size1 = NULL;
   LLVMValueRef row_stride0_vec = NULL;
   LLVMValueRef row_stride1_vec = NULL;
   LLVMValueRef img_stride0_vec = NULL;
   LLVMValueRef img_stride1_vec = NULL;
   LLVMValueRef data_ptr0 = NULL;
   LLVMValueRef data_ptr1 = NULL;
   LLVMValueRef mipoff0 = NULL;
   LLVMValueRef mipoff1 = NULL;
d852 1
a852 8
   if (bld->num_lods == 1) {
      data_ptr0 = lp_build_get_mipmap_level(bld, ilevel0);
   }
   else {
      /* This path should work for num_lods 1 too but slightly less efficient */
      data_ptr0 = bld->base_ptr;
      mipoff0 = lp_build_get_mip_offsets(bld, ilevel0);
   }
d854 1
a854 1
      lp_build_sample_image_nearest(bld, sampler_unit,
d857 1
a857 1
                                    data_ptr0, mipoff0, s, t, r, offsets,
d862 1
a862 1
      lp_build_sample_image_linear(bld, sampler_unit,
d865 1
a865 1
                                   data_ptr0, mipoff0, s, t, r, offsets,
d879 4
a882 24
      if (bld->num_lods == 1) {
         need_lerp = LLVMBuildFCmp(builder, LLVMRealUGT,
                                   lod_fpart, bld->levelf_bld.zero,
                                   "need_lerp");
      }
      else {
         /*
          * We'll do mip filtering if any of the quads (or individual
          * pixel in case of per-pixel lod) need it.
          * It might be better to split the vectors here and only fetch/filter
          * quads which need it.
          */
         /*
          * We unfortunately need to clamp lod_fpart here since we can get
          * negative values which would screw up filtering if not all
          * lod_fpart values have same sign.
          */
         lod_fpart = lp_build_max(&bld->levelf_bld, lod_fpart,
                                  bld->levelf_bld.zero);
         need_lerp = lp_build_compare(bld->gallivm, bld->levelf_bld.type,
                                      PIPE_FUNC_GREATER,
                                      lod_fpart, bld->levelf_bld.zero);
         need_lerp = lp_build_any_true_range(&bld->leveli_bld, bld->num_lods, need_lerp);
      }
d890 1
a890 7
         if (bld->num_lods == 1) {
            data_ptr1 = lp_build_get_mipmap_level(bld, ilevel1);
         }
         else {
            data_ptr1 = bld->base_ptr;
            mipoff1 = lp_build_get_mip_offsets(bld, ilevel1);
         }
d892 1
a892 1
            lp_build_sample_image_nearest(bld, sampler_unit,
d895 1
a895 1
                                          data_ptr1, mipoff1, s, t, r, offsets,
d899 1
a899 1
            lp_build_sample_image_linear(bld, sampler_unit,
d902 1
a902 1
                                         data_ptr1, mipoff1, s, t, r, offsets,
d908 1
a908 5
         if (bld->num_lods != bld->coord_type.length)
            lod_fpart = lp_build_unpack_broadcast_aos_scalars(bld->gallivm,
                                                              bld->levelf_bld.type,
                                                              bld->texel_bld.type,
                                                              lod_fpart);
d912 1
a912 2
                                          colors0[chan], colors1[chan],
                                          0);
a920 19
/**
 * Clamp layer coord to valid values.
 */
static LLVMValueRef
lp_build_layer_coord(struct lp_build_sample_context *bld,
                     unsigned texture_unit,
                     LLVMValueRef layer)
{
   LLVMValueRef maxlayer;

   maxlayer = bld->dynamic_state->depth(bld->dynamic_state,
                                        bld->gallivm, texture_unit);
   maxlayer = lp_build_sub(&bld->int_bld, maxlayer, bld->int_bld.one);
   maxlayer = lp_build_broadcast_scalar(&bld->int_coord_bld, maxlayer);
   return lp_build_clamp(&bld->int_coord_bld, layer,
                         bld->int_coord_bld.zero, maxlayer);

}

d923 3
a925 1
 * Calculate cube face, lod, mip levels.
d928 10
a937 13
lp_build_sample_common(struct lp_build_sample_context *bld,
                       unsigned texture_index,
                       unsigned sampler_index,
                       LLVMValueRef *s,
                       LLVMValueRef *t,
                       LLVMValueRef *r,
                       const struct lp_derivatives *derivs, /* optional */
                       LLVMValueRef lod_bias, /* optional */
                       LLVMValueRef explicit_lod, /* optional */
                       LLVMValueRef *lod_ipart,
                       LLVMValueRef *lod_fpart,
                       LLVMValueRef *ilevel0,
                       LLVMValueRef *ilevel1)
d939 11
a949 5
   const unsigned mip_filter = bld->static_sampler_state->min_mip_filter;
   const unsigned min_filter = bld->static_sampler_state->min_img_filter;
   const unsigned mag_filter = bld->static_sampler_state->mag_img_filter;
   const unsigned target = bld->static_texture_state->target;
   LLVMValueRef first_level, cube_rho = NULL;
d957 1
a957 2
    * Choose cube face, recompute texcoords for the chosen face and
    * compute rho here too (as it requires transform of derivatives).
d959 1
a959 1
   if (target == PIPE_TEXTURE_CUBE) {
d961 3
a963 9
      boolean need_derivs;
      need_derivs = ((min_filter != mag_filter ||
                      mip_filter != PIPE_TEX_MIPFILTER_NONE) &&
                      !bld->static_sampler_state->min_max_lod_equal &&
                      !explicit_lod);
      lp_build_cube_lookup(bld, *s, *t, *r, derivs, &face, &face_s, &face_t,
                           &cube_rho, need_derivs);
      *s = face_s; /* vec */
      *t = face_t; /* vec */
d965 13
a977 9
      *r = face; /* vec */
   }
   else if (target == PIPE_TEXTURE_1D_ARRAY) {
      *r = lp_build_iround(&bld->coord_bld, *t);
      *r = lp_build_layer_coord(bld, texture_index, *r);
   }
   else if (target == PIPE_TEXTURE_2D_ARRAY) {
      *r = lp_build_iround(&bld->coord_bld, *r);
      *r = lp_build_layer_coord(bld, texture_index, *r);
d988 2
a989 3
      lp_build_lod_selector(bld, texture_index, sampler_index,
                            *s, *t, *r, cube_rho,
                            derivs, lod_bias, explicit_lod,
d991 1
a991 1
                            lod_ipart, lod_fpart);
d993 1
a993 1
      *lod_ipart = bld->leveli_bld.zero;
d1005 1
a1005 1
      if (HAVE_LLVM == 0x0207 && target == PIPE_TEXTURE_CUBE) {
d1010 2
a1011 2
         assert(*lod_ipart);
         lp_build_nearest_mip_level(bld, texture_index, *lod_ipart, ilevel0);
d1014 1
a1014 4
         first_level = bld->dynamic_state->first_level(bld->dynamic_state,
                                                       bld->gallivm, texture_index);
         first_level = lp_build_broadcast_scalar(&bld->leveli_bld, first_level);
         *ilevel0 = first_level;
d1018 2
a1019 2
      assert(*lod_ipart);
      lp_build_nearest_mip_level(bld, texture_index, *lod_ipart, ilevel0);
d1022 5
a1026 5
      assert(*lod_ipart);
      assert(*lod_fpart);
      lp_build_linear_mip_levels(bld, texture_index,
                                 *lod_ipart, lod_fpart,
                                 ilevel0, ilevel1);
a1028 27
}

/**
 * General texture sampling codegen.
 * This function handles texture sampling for all texture targets (1D,
 * 2D, 3D, cube) and all filtering modes.
 */
static void
lp_build_sample_general(struct lp_build_sample_context *bld,
                        unsigned sampler_unit,
                        LLVMValueRef s,
                        LLVMValueRef t,
                        LLVMValueRef r,
                        const LLVMValueRef *offsets,
                        LLVMValueRef lod_ipart,
                        LLVMValueRef lod_fpart,
                        LLVMValueRef ilevel0,
                        LLVMValueRef ilevel1,
                        LLVMValueRef *colors_out)
{
   struct lp_build_context *int_bld = &bld->int_bld;
   LLVMBuilderRef builder = bld->gallivm->builder;
   const unsigned mip_filter = bld->static_sampler_state->min_mip_filter;
   const unsigned min_filter = bld->static_sampler_state->min_img_filter;
   const unsigned mag_filter = bld->static_sampler_state->mag_img_filter;
   LLVMValueRef texels[4];
   unsigned chan;
d1036 1
a1036 1
     lp_build_name(texels[chan], "sampler%u_texel_%c_var", sampler_unit, "xyzw"[chan]);
d1040 2
a1041 2
      /* no need to distinguish between minification and magnification */
      lp_build_sample_mipmap(bld, sampler_unit,
d1043 1
a1043 1
                             s, t, r, offsets,
a1053 13
      /*
       * XXX this should to all lods into account, if some are min
       * some max probably could hack up the coords/weights in the linear
       * path with selects to work for nearest.
       * If that's just two quads sitting next to each other it seems
       * quite ok to do the same filtering method on both though, at
       * least unless we have explicit lod (and who uses different
       * min/mag filter with that?)
       */
      if (bld->num_lods > 1)
         lod_ipart = LLVMBuildExtractElement(builder, lod_ipart,
                                             lp_build_const_int32(bld->gallivm, 0), "");

d1061 1
a1061 1
         lp_build_sample_mipmap(bld, sampler_unit,
d1063 1
a1063 1
                                s, t, r, offsets,
d1070 1
a1070 1
         lp_build_sample_mipmap(bld, sampler_unit,
d1072 2
a1073 2
                                s, t, r, offsets,
                                ilevel0, NULL, NULL,
d1081 1
a1081 120
     lp_build_name(colors_out[chan], "sampler%u_texel_%c", sampler_unit, "xyzw"[chan]);
   }
}


/**
 * Texel fetch function.
 * In contrast to general sampling there is no filtering, no coord minification,
 * lod (if any) is always explicit uint, coords are uints (in terms of texel units)
 * directly to be applied to the selected mip level (after adding texel offsets).
 * This function handles texel fetch for all targets where texel fetch is supported
 * (no cube maps, but 1d, 2d, 3d are supported, arrays and buffers should be too).
 */
static void
lp_build_fetch_texel(struct lp_build_sample_context *bld,
                     unsigned texture_unit,
                     const LLVMValueRef *coords,
                     LLVMValueRef explicit_lod,
                     const LLVMValueRef *offsets,
                     LLVMValueRef *colors_out)
{
   struct lp_build_context *perquadi_bld = &bld->leveli_bld;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
   unsigned dims = bld->dims, chan;
   unsigned target = bld->static_texture_state->target;
   LLVMValueRef size, ilevel;
   LLVMValueRef row_stride_vec = NULL, img_stride_vec = NULL;
   LLVMValueRef x = coords[0], y = coords[1], z = coords[2];
   LLVMValueRef width, height, depth, i, j;
   LLVMValueRef offset, out_of_bounds, out1;

   if (explicit_lod && bld->static_texture_state->target != PIPE_BUFFER) {
      if (bld->num_lods != int_coord_bld->type.length) {
         ilevel = lp_build_pack_aos_scalars(bld->gallivm, int_coord_bld->type,
                                            perquadi_bld->type, explicit_lod, 0);
      }
      else {
         ilevel = explicit_lod;
      }
      lp_build_nearest_mip_level(bld, texture_unit, ilevel, &ilevel);
   }
   else {
      bld->num_lods = 1;
      ilevel = lp_build_const_int32(bld->gallivm, 0);
   }
   lp_build_mipmap_level_sizes(bld, ilevel,
                               &size,
                               &row_stride_vec, &img_stride_vec);
   lp_build_extract_image_sizes(bld, &bld->int_size_bld, int_coord_bld->type,
                                size, &width, &height, &depth);

   if (target == PIPE_TEXTURE_1D_ARRAY ||
       target == PIPE_TEXTURE_2D_ARRAY) {
      if (target == PIPE_TEXTURE_1D_ARRAY) {
         z = lp_build_layer_coord(bld, texture_unit, y);
      }
      else {
         z = lp_build_layer_coord(bld, texture_unit, z);
      }
   }

   /* This is a lot like border sampling */
   if (offsets[0]) {
      /* XXX coords are really unsigned, offsets are signed */
      x = lp_build_add(int_coord_bld, x, offsets[0]);
   }
   out_of_bounds = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, x, int_coord_bld->zero);
   out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, x, width);
   out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);

   if (dims >= 2) {
      if (offsets[1]) {
         y = lp_build_add(int_coord_bld, y, offsets[1]);
      }
      out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, y, int_coord_bld->zero);
      out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
      out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, y, height);
      out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);

      if (dims >= 3) {
         if (offsets[2]) {
            z = lp_build_add(int_coord_bld, z, offsets[2]);
         }
         out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, z, int_coord_bld->zero);
         out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
         out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, z, depth);
         out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
      }
   }

   lp_build_sample_offset(int_coord_bld,
                          bld->format_desc,
                          x, y, z, row_stride_vec, img_stride_vec,
                          &offset, &i, &j);

   if (bld->static_texture_state->target != PIPE_BUFFER) {
      offset = lp_build_add(int_coord_bld, offset,
                            lp_build_get_mip_offsets(bld, ilevel));
   }

   offset = lp_build_andnot(int_coord_bld, offset, out_of_bounds);

   lp_build_fetch_rgba_soa(bld->gallivm,
                           bld->format_desc,
                           bld->texel_type,
                           bld->base_ptr, offset,
                           i, j,
                           colors_out);

   if (0) {
      /*
       * Not needed except for ARB_robust_buffer_access_behavior.
       * Could use min/max above instead of out-of-bounds comparisons
       * (in fact cast to unsigned and min only is sufficient)
       * if we don't care about the result returned for out-of-bounds.
       */
      for (chan = 0; chan < 4; chan++) {
         colors_out[chan] = lp_build_select(&bld->texel_bld, out_of_bounds,
                                            bld->texel_bld.zero, colors_out[chan]);
      }
d1088 1
a1088 1
 * \param coords  incoming texcoords
a1089 1
 * Ideally this should really be done per-sample.
d1093 1
a1093 1
                        const LLVMValueRef *coords,
d1098 1
a1098 1
   LLVMValueRef res, p;
d1101 1
a1101 1
   if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE)
a1103 8
   if (bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY ||
       bld->static_texture_state->target == PIPE_TEXTURE_CUBE) {
      p = coords[3];
   }
   else {
      p = coords[2];
   }

a1112 5
   /* Clamp p coords to [0,1] */
   p = lp_build_clamp(&bld->coord_bld, p,
                      bld->coord_bld.zero,
                      bld->coord_bld.one);

d1114 1
a1114 1
   res = lp_build_cmp(texel_bld, bld->static_sampler_state->compare_func,
d1131 1
a1131 3
lp_build_sample_nop(struct gallivm_state *gallivm,
                    struct lp_type type,
                    const LLVMValueRef *coords,
d1148 2
a1149 2
 * \param is_fetch  if this is a texel fetch instruction.
 * \param derivs  partial derivatives of (s,t,r,q) with respect to x and y
d1153 1
a1153 2
                    const struct lp_static_texture_state *static_texture_state,
                    const struct lp_static_sampler_state *static_sampler_state,
d1156 2
a1157 3
                    boolean is_fetch,
                    unsigned texture_index,
                    unsigned sampler_index,
d1159 2
a1160 2
                    const LLVMValueRef *offsets,
                    const struct lp_derivatives *derivs, /* optional */
a1162 1
                    boolean scalar_lod,
d1165 1
a1165 3
   unsigned dims = texture_dims(static_texture_state->target);
   unsigned num_quads = type.length / 4;
   unsigned mip_filter;
a1166 1
   struct lp_static_sampler_state derived_sampler_state = *static_sampler_state;
a1168 1
   LLVMValueRef tex_width;
d1172 1
d1175 1
a1175 1
      enum pipe_format fmt = static_texture_state->format;
d1184 1
a1184 2
   bld.static_sampler_state = &derived_sampler_state;
   bld.static_texture_state = static_texture_state;
d1186 1
a1186 1
   bld.format_desc = util_format_description(static_texture_state->format);
a1188 2
   bld.vector_width = lp_type_width(type);

d1193 3
a1195 3
   bld.float_size_in_type = lp_type_float(32);
   bld.float_size_in_type.length = dims > 1 ? 4 : 1;
   bld.int_size_in_type = lp_int_type(bld.float_size_in_type);
d1198 1
a1198 75
   /* always using the first channel hopefully should be safe,
    * if not things WILL break in other places anyway.
    */
   if (bld.format_desc->colorspace == UTIL_FORMAT_COLORSPACE_RGB &&
       bld.format_desc->channel[0].pure_integer) {
      if (bld.format_desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
         bld.texel_type = lp_type_int_vec(type.width, type.width * type.length);
      }
      else if (bld.format_desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED) {
         bld.texel_type = lp_type_uint_vec(type.width, type.width * type.length);
      }
   }
   else if (util_format_has_stencil(bld.format_desc) &&
       !util_format_has_depth(bld.format_desc)) {
      /* for stencil only formats, sample stencil (uint) */
      bld.texel_type = lp_type_int_vec(type.width, type.width * type.length);
   }

   if (!static_texture_state->level_zero_only) {
      derived_sampler_state.min_mip_filter = static_sampler_state->min_mip_filter;
   } else {
      derived_sampler_state.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
   }
   mip_filter = derived_sampler_state.min_mip_filter;

   if (0) {
      debug_printf("  .min_mip_filter = %u\n", derived_sampler_state.min_mip_filter);
   }

   /*
    * This is all a bit complicated different paths are chosen for performance
    * reasons.
    * Essentially, there can be 1 lod per element, 1 lod per quad or 1 lod for
    * everything (the last two options are equivalent for 4-wide case).
    * If there's per-quad lod but we split to 4-wide so we can use AoS, per-quad
    * lod is calculated then the lod value extracted afterwards so making this
    * case basically the same as far as lod handling is concerned for the
    * further sample/filter code as the 1 lod for everything case.
    * Different lod handling mostly shows up when building mipmap sizes
    * (lp_build_mipmap_level_sizes() and friends) and also in filtering
    * (getting the fractional part of the lod to the right texels).
    */

   /*
    * There are other situations where at least the multiple int lods could be
    * avoided like min and max lod being equal.
    */
   if (explicit_lod && !scalar_lod &&
       ((is_fetch && bld.static_texture_state->target != PIPE_BUFFER) ||
        (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)))
      bld.num_lods = type.length;
   /* TODO: for true scalar_lod should only use 1 lod value */
   else if ((is_fetch && explicit_lod && bld.static_texture_state->target != PIPE_BUFFER ) ||
            (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
      bld.num_lods = num_quads;
   }
   else {
      bld.num_lods = 1;
   }

   bld.levelf_type = type;
   /* we want native vector size to be able to use our intrinsics */
   if (bld.num_lods != type.length) {
      bld.levelf_type.length = type.length > 4 ? ((type.length + 15) / 16) * 4 : 1;
   }
   bld.leveli_type = lp_int_type(bld.levelf_type);
   bld.float_size_type = bld.float_size_in_type;
   /* Note: size vectors may not be native. They contain minified w/h/d/_ values,
    * with per-element lod that is w0/h0/d0/_/w1/h1/d1_/... so up to 8x4f32 */
   if (bld.num_lods > 1) {
      bld.float_size_type.length = bld.num_lods == type.length ?
                                      bld.num_lods * bld.float_size_in_type.length :
                                      type.length;
   }
   bld.int_size_type = lp_int_type(bld.float_size_type);
d1201 1
a1201 1
   lp_build_context_init(&bld.float_vec_bld, gallivm, type);
a1204 2
   lp_build_context_init(&bld.int_size_in_bld, gallivm, bld.int_size_in_type);
   lp_build_context_init(&bld.float_size_in_bld, gallivm, bld.float_size_in_type);
a1207 2
   lp_build_context_init(&bld.levelf_bld, gallivm, bld.levelf_type);
   lp_build_context_init(&bld.leveli_bld, gallivm, bld.leveli_type);
d1210 7
a1216 6
   tex_width = dynamic_state->width(dynamic_state, gallivm, texture_index);
   bld.row_stride_array = dynamic_state->row_stride(dynamic_state, gallivm, texture_index);
   bld.img_stride_array = dynamic_state->img_stride(dynamic_state, gallivm, texture_index);
   bld.base_ptr = dynamic_state->base_ptr(dynamic_state, gallivm, texture_index);
   bld.mip_offsets = dynamic_state->mip_offsets(dynamic_state, gallivm, texture_index);
   /* Note that mip_offsets is an array[level] of offsets to texture images */
d1224 1
a1224 1
      bld.int_size = tex_width;
d1227 2
a1228 2
      bld.int_size = LLVMBuildInsertElement(builder, bld.int_size_in_bld.undef,
                                            tex_width, LLVMConstInt(i32t, 0, 0), "");
a1229 2
         LLVMValueRef tex_height =
            dynamic_state->height(dynamic_state, gallivm, texture_index);
d1231 1
a1231 1
                                               tex_height, LLVMConstInt(i32t, 1, 0), "");
a1232 2
            LLVMValueRef tex_depth =
               dynamic_state->depth(dynamic_state, gallivm, texture_index);
d1234 1
a1234 1
                                                  tex_depth, LLVMConstInt(i32t, 2, 0), "");
d1241 8
a1248 3
      lp_build_sample_nop(gallivm,
                          bld.texel_type,
                          coords,
a1251 6
   else if (is_fetch) {
      lp_build_fetch_texel(&bld, texture_index, coords,
                           explicit_lod, offsets,
                           texel_out);
   }

a1252 6
      LLVMValueRef lod_ipart = NULL, lod_fpart = NULL;
      LLVMValueRef ilevel0 = NULL, ilevel1 = NULL;
      boolean use_aos = util_format_fits_8unorm(bld.format_desc) &&
                        lp_is_simple_wrap_mode(static_sampler_state->wrap_s) &&
                        lp_is_simple_wrap_mode(static_sampler_state->wrap_t);

d1254 1
a1254 1
          !use_aos && util_format_fits_8unorm(bld.format_desc)) {
d1258 5
a1262 173
                      static_sampler_state->min_img_filter,
                      static_sampler_state->mag_img_filter,
                      static_sampler_state->min_mip_filter,
                      static_sampler_state->wrap_s,
                      static_sampler_state->wrap_t);
      }

      lp_build_sample_common(&bld, texture_index, sampler_index,
                             &s, &t, &r,
                             derivs, lod_bias, explicit_lod,
                             &lod_ipart, &lod_fpart,
                             &ilevel0, &ilevel1);

      /*
       * we only try 8-wide sampling with soa as it appears to
       * be a loss with aos with AVX (but it should work).
       * (It should be faster if we'd support avx2)
       */
      if (num_quads == 1 || !use_aos) {

         if (num_quads > 1) {
            if (mip_filter == PIPE_TEX_MIPFILTER_NONE) {
               LLVMValueRef index0 = lp_build_const_int32(gallivm, 0);
               /*
                * These parameters are the same for all quads,
                * could probably simplify.
                */
               lod_ipart = LLVMBuildExtractElement(builder, lod_ipart, index0, "");
               ilevel0 = LLVMBuildExtractElement(builder, ilevel0, index0, "");
            }
         }
         if (use_aos) {
            /* do sampling/filtering with fixed pt arithmetic */
            lp_build_sample_aos(&bld, sampler_index,
                                s, t, r, offsets,
                                lod_ipart, lod_fpart,
                                ilevel0, ilevel1,
                                texel_out);
         }

         else {
            lp_build_sample_general(&bld, sampler_index,
                                    s, t, r, offsets,
                                    lod_ipart, lod_fpart,
                                    ilevel0, ilevel1,
                                    texel_out);
         }
      }
      else {
         unsigned j;
         struct lp_build_sample_context bld4;
         struct lp_type type4 = type;
         unsigned i;
         LLVMValueRef texelout4[4];
         LLVMValueRef texelouttmp[4][LP_MAX_VECTOR_LENGTH/16];

         type4.length = 4;

         /* Setup our build context */
         memset(&bld4, 0, sizeof bld4);
         bld4.gallivm = bld.gallivm;
         bld4.static_texture_state = bld.static_texture_state;
         bld4.static_sampler_state = bld.static_sampler_state;
         bld4.dynamic_state = bld.dynamic_state;
         bld4.format_desc = bld.format_desc;
         bld4.dims = bld.dims;
         bld4.row_stride_array = bld.row_stride_array;
         bld4.img_stride_array = bld.img_stride_array;
         bld4.base_ptr = bld.base_ptr;
         bld4.mip_offsets = bld.mip_offsets;
         bld4.int_size = bld.int_size;

         bld4.vector_width = lp_type_width(type4);

         bld4.float_type = lp_type_float(32);
         bld4.int_type = lp_type_int(32);
         bld4.coord_type = type4;
         bld4.int_coord_type = lp_int_type(type4);
         bld4.float_size_in_type = lp_type_float(32);
         bld4.float_size_in_type.length = dims > 1 ? 4 : 1;
         bld4.int_size_in_type = lp_int_type(bld4.float_size_in_type);
         bld4.texel_type = bld.texel_type;
         bld4.texel_type.length = 4;
         bld4.levelf_type = type4;
         /* we want native vector size to be able to use our intrinsics */
         bld4.levelf_type.length = 1;
         bld4.leveli_type = lp_int_type(bld4.levelf_type);

         if (explicit_lod && !scalar_lod &&
             ((is_fetch && bld.static_texture_state->target != PIPE_BUFFER) ||
              (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)))
            bld4.num_lods = type4.length;
         else
            bld4.num_lods = 1;

         bld4.levelf_type = type4;
         /* we want native vector size to be able to use our intrinsics */
         if (bld4.num_lods != type4.length) {
            bld4.levelf_type.length = 1;
         }
         bld4.leveli_type = lp_int_type(bld4.levelf_type);
         bld4.float_size_type = bld4.float_size_in_type;
         if (bld4.num_lods > 1) {
            bld4.float_size_type.length = bld4.num_lods == type4.length ?
                                            bld4.num_lods * bld4.float_size_in_type.length :
                                            type4.length;
         }
         bld4.int_size_type = lp_int_type(bld4.float_size_type);

         lp_build_context_init(&bld4.float_bld, gallivm, bld4.float_type);
         lp_build_context_init(&bld4.float_vec_bld, gallivm, type4);
         lp_build_context_init(&bld4.int_bld, gallivm, bld4.int_type);
         lp_build_context_init(&bld4.coord_bld, gallivm, bld4.coord_type);
         lp_build_context_init(&bld4.int_coord_bld, gallivm, bld4.int_coord_type);
         lp_build_context_init(&bld4.int_size_in_bld, gallivm, bld4.int_size_in_type);
         lp_build_context_init(&bld4.float_size_in_bld, gallivm, bld4.float_size_in_type);
         lp_build_context_init(&bld4.int_size_bld, gallivm, bld4.int_size_type);
         lp_build_context_init(&bld4.float_size_bld, gallivm, bld4.float_size_type);
         lp_build_context_init(&bld4.texel_bld, gallivm, bld4.texel_type);
         lp_build_context_init(&bld4.levelf_bld, gallivm, bld4.levelf_type);
         lp_build_context_init(&bld4.leveli_bld, gallivm, bld4.leveli_type);

         for (i = 0; i < num_quads; i++) {
            LLVMValueRef s4, t4, r4;
            LLVMValueRef lod_ipart4, lod_fpart4 = NULL;
            LLVMValueRef ilevel04, ilevel14 = NULL;
            LLVMValueRef offsets4[4] = { NULL };
            unsigned num_lods = bld4.num_lods;

            s4 = lp_build_extract_range(gallivm, s, 4*i, 4);
            t4 = lp_build_extract_range(gallivm, t, 4*i, 4);
            r4 = lp_build_extract_range(gallivm, r, 4*i, 4);

            if (offsets[0]) {
               offsets4[0] = lp_build_extract_range(gallivm, offsets[0], 4*i, 4);
               if (dims > 1) {
                  offsets4[1] = lp_build_extract_range(gallivm, offsets[1], 4*i, 4);
                  if (dims > 2) {
                     offsets4[2] = lp_build_extract_range(gallivm, offsets[2], 4*i, 4);
                  }
               }
            }
            lod_ipart4 = lp_build_extract_range(gallivm, lod_ipart, num_lods * i, num_lods);
            ilevel04 = lp_build_extract_range(gallivm, ilevel0, num_lods * i, num_lods);
            if (mip_filter == PIPE_TEX_MIPFILTER_LINEAR) {
               ilevel14 = lp_build_extract_range(gallivm, ilevel1, num_lods * i, num_lods);
               lod_fpart4 = lp_build_extract_range(gallivm, lod_fpart, num_lods * i, num_lods);
            }

            if (use_aos) {
               /* do sampling/filtering with fixed pt arithmetic */
               lp_build_sample_aos(&bld4, sampler_index,
                                   s4, t4, r4, offsets4,
                                   lod_ipart4, lod_fpart4,
                                   ilevel04, ilevel14,
                                   texelout4);
            }

            else {
               lp_build_sample_general(&bld4, sampler_index,
                                       s4, t4, r4, offsets4,
                                       lod_ipart4, lod_fpart4,
                                       ilevel04, ilevel14,
                                       texelout4);
            }
            for (j = 0; j < 4; j++) {
               texelouttmp[j][i] = texelout4[j];
            }
         }

         for (j = 0; j < 4; j++) {
            texel_out[j] = lp_build_concat(gallivm, texelouttmp[j], type4, num_quads);
         }
d1265 3
a1267 1
      lp_build_sample_compare(&bld, coords, texel_out);
d1270 1
a1270 124
   if (static_texture_state->target != PIPE_BUFFER) {
      apply_sampler_swizzle(&bld, texel_out);
   }

   /*
    * texel type can be a (32bit) int/uint (for pure int formats only),
    * however we are expected to always return floats (storage is untyped).
    */
   if (!bld.texel_type.floating) {
      unsigned chan;
      for (chan = 0; chan < 4; chan++) {
         texel_out[chan] = LLVMBuildBitCast(builder, texel_out[chan],
                                            lp_build_vec_type(gallivm, type), "");
      }
   }
}

void
lp_build_size_query_soa(struct gallivm_state *gallivm,
                        const struct lp_static_texture_state *static_state,
                        struct lp_sampler_dynamic_state *dynamic_state,
                        struct lp_type int_type,
                        unsigned texture_unit,
                        boolean need_nr_mips,
                        LLVMValueRef explicit_lod,
                        LLVMValueRef *sizes_out)
{
   LLVMValueRef lod;
   LLVMValueRef size;
   LLVMValueRef first_level = NULL;
   int dims, i;
   boolean has_array;
   struct lp_build_context bld_int_vec;

   dims = texture_dims(static_state->target);

   switch (static_state->target) {
   case PIPE_TEXTURE_1D_ARRAY:
   case PIPE_TEXTURE_2D_ARRAY:
      has_array = TRUE;
      break;
   default:
      has_array = FALSE;
      break;
   }

   assert(!int_type.floating);

   lp_build_context_init(&bld_int_vec, gallivm, lp_type_int_vec(32, 128));

   if (explicit_lod) {
      /* FIXME: this needs to honor per-element lod */
      lod = LLVMBuildExtractElement(gallivm->builder, explicit_lod, lp_build_const_int32(gallivm, 0), "");
      first_level = dynamic_state->first_level(dynamic_state, gallivm, texture_unit);
      lod = lp_build_broadcast_scalar(&bld_int_vec,
                                      LLVMBuildAdd(gallivm->builder, lod, first_level, "lod"));

   } else {
      lod = bld_int_vec.zero;
   }

   if (need_nr_mips) {
      size = bld_int_vec.zero;
   }
   else {
      size = bld_int_vec.undef;
   }

   size = LLVMBuildInsertElement(gallivm->builder, size,
                                 dynamic_state->width(dynamic_state, gallivm, texture_unit),
                                 lp_build_const_int32(gallivm, 0), "");

   if (dims >= 2) {
      size = LLVMBuildInsertElement(gallivm->builder, size,
                                    dynamic_state->height(dynamic_state, gallivm, texture_unit),
                                    lp_build_const_int32(gallivm, 1), "");
   }

   if (dims >= 3) {
      size = LLVMBuildInsertElement(gallivm->builder, size,
                                    dynamic_state->depth(dynamic_state, gallivm, texture_unit),
                                    lp_build_const_int32(gallivm, 2), "");
   }

   size = lp_build_minify(&bld_int_vec, size, lod);

   if (has_array)
      size = LLVMBuildInsertElement(gallivm->builder, size,
                                    dynamic_state->depth(dynamic_state, gallivm, texture_unit),
                                    lp_build_const_int32(gallivm, dims), "");

   /*
    * XXX for out-of-bounds lod, should set size to zero vector here
    * (for dx10-style only, i.e. need_nr_mips)
    */

   for (i = 0; i < dims + (has_array ? 1 : 0); i++) {
      sizes_out[i] = lp_build_extract_broadcast(gallivm, bld_int_vec.type, int_type,
                                                size,
                                                lp_build_const_int32(gallivm, i));
   }

   /*
    * if there's no explicit_lod (buffers, rects) queries requiring nr of
    * mips would be illegal.
    */
   if (need_nr_mips && explicit_lod) {
      struct lp_build_context bld_int_scalar;
      LLVMValueRef num_levels;
      lp_build_context_init(&bld_int_scalar, gallivm, lp_type_int(32));

      if (static_state->level_zero_only) {
         num_levels = bld_int_scalar.one;
      }
      else {
         LLVMValueRef last_level;

         last_level = dynamic_state->last_level(dynamic_state, gallivm, texture_unit);
         num_levels = lp_build_sub(&bld_int_scalar, last_level, first_level);
         num_levels = lp_build_add(&bld_int_scalar, num_levels, bld_int_scalar.one);
      }
      sizes_out[3] = lp_build_broadcast(gallivm, lp_build_vec_type(gallivm, int_type),
                                        num_levels);
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a44 1
#include "util/u_format_rgb9e5.h"
d75 1
d182 4
a185 2
      /* select texel color or border color depending on use_border. */
      const struct util_format_description *format_desc = bld->format_desc;
a186 7
      struct lp_type border_type = bld->texel_type;
      border_type.length = 4;
      /*
       * Only replace channels which are actually present. The others should
       * get optimized away eventually by sampler_view swizzle anyway but it's
       * easier too.
       */
d188 9
a196 19
         unsigned chan_s;
         /* reverse-map channel... */
         for (chan_s = 0; chan_s < 4; chan_s++) {
            if (chan_s == format_desc->swizzle[chan]) {
               break;
            }
         }
         if (chan_s <= 3) {
            /* use the already clamped color */
            LLVMValueRef idx = lp_build_const_int32(bld->gallivm, chan);
            LLVMValueRef border_chan;

            border_chan = lp_build_extract_broadcast(bld->gallivm,
                                                     border_type,
                                                     bld->texel_type,
                                                     bld->border_color_clamped,
                                                     idx);
            texel_out[chan] = lp_build_select(&bld->texel_bld, use_border,
                                              border_chan, texel_out[chan]);
d198 2
a644 35
 * Do shadow test/comparison.
 * \param p shadow ref value
 * \param texel  the texel to compare against
 */
static LLVMValueRef
lp_build_sample_comparefunc(struct lp_build_sample_context *bld,
                            LLVMValueRef p,
                            LLVMValueRef texel)
{
   struct lp_build_context *texel_bld = &bld->texel_bld;
   LLVMValueRef res;

   if (0) {
      //lp_build_print_value(bld->gallivm, "shadow cmp coord", p);
      lp_build_print_value(bld->gallivm, "shadow cmp texel", texel);
   }

   /* result = (p FUNC texel) ? 1 : 0 */
   /*
    * honor d3d10 floating point rules here, which state that comparisons
    * are ordered except NOT_EQUAL which is unordered.
    */
   if (bld->static_sampler_state->compare_func != PIPE_FUNC_NOTEQUAL) {
      res = lp_build_cmp_ordered(texel_bld, bld->static_sampler_state->compare_func,
                                 p, texel);
   }
   else {
      res = lp_build_cmp(texel_bld, bld->static_sampler_state->compare_func,
                         p, texel);
   }
   return res;
}


/**
d650 1
d656 3
a658 1
                              LLVMValueRef *coords,
d689 1
a689 2
   x = lp_build_sample_wrap_nearest(bld, coords[0], width_vec,
                                    flt_width_vec, offsets[0],
d695 1
a695 2
      y = lp_build_sample_wrap_nearest(bld, coords[1], height_vec,
                                       flt_height_vec, offsets[1],
d701 1
a701 2
         z = lp_build_sample_wrap_nearest(bld, coords[2], depth_vec,
                                          flt_depth_vec, offsets[2],
d710 1
a710 1
      z = coords[2];
d717 1
a717 1
   lp_build_sample_texel_soa(bld,
a721 53

   if (bld->static_sampler_state->compare_mode != PIPE_TEX_COMPARE_NONE) {
      LLVMValueRef cmpval;
      cmpval = lp_build_sample_comparefunc(bld, coords[4], colors_out[0]);
      /* this is really just a AND 1.0, cmpval but llvm is clever enough */
      colors_out[0] = lp_build_select(&bld->texel_bld, cmpval,
                                      bld->texel_bld.one, bld->texel_bld.zero);
      colors_out[1] = colors_out[2] = colors_out[3] = colors_out[0];
   }

}


/**
 * Like a lerp, but inputs are 0/~0 masks, so can simplify slightly.
 */
static LLVMValueRef
lp_build_masklerp(struct lp_build_context *bld,
                 LLVMValueRef weight,
                 LLVMValueRef mask0,
                 LLVMValueRef mask1)
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef weight2;

   weight2 = lp_build_sub(bld, bld->one, weight);
   weight = LLVMBuildBitCast(builder, weight,
                              lp_build_int_vec_type(gallivm, bld->type), "");
   weight2 = LLVMBuildBitCast(builder, weight2,
                              lp_build_int_vec_type(gallivm, bld->type), "");
   weight = LLVMBuildAnd(builder, weight, mask1, "");
   weight2 = LLVMBuildAnd(builder, weight2, mask0, "");
   weight = LLVMBuildBitCast(builder, weight, bld->vec_type, "");
   weight2 = LLVMBuildBitCast(builder, weight2, bld->vec_type, "");
   return lp_build_add(bld, weight, weight2);
}

/**
 * Like a 2d lerp, but inputs are 0/~0 masks, so can simplify slightly.
 */
static LLVMValueRef
lp_build_masklerp2d(struct lp_build_context *bld,
                    LLVMValueRef weight0,
                    LLVMValueRef weight1,
                    LLVMValueRef mask00,
                    LLVMValueRef mask01,
                    LLVMValueRef mask10,
                    LLVMValueRef mask11)
{
   LLVMValueRef val0 = lp_build_masklerp(bld, weight0, mask00, mask01);
   LLVMValueRef val1 = lp_build_masklerp(bld, weight0, mask10, mask11);
   return lp_build_lerp(bld, weight1, val0, val1, 0);
a723 5
/*
 * this is a bit excessive code for something OpenGL just recommends
 * but does not require.
 */
#define ACCURATE_CUBE_CORNERS 1
a727 2
 * If linear_mask is present, only pixels having their mask set
 * will receive linear filtering, the rest will use nearest.
d731 1
a732 1
                             LLVMValueRef linear_mask,
d737 3
a739 1
                             LLVMValueRef *coords,
a742 3
   LLVMBuilderRef builder = bld->gallivm->builder;
   struct lp_build_context *ivec_bld = &bld->int_coord_bld;
   struct lp_build_context *coord_bld = &bld->coord_bld;
d751 1
a751 5
   LLVMValueRef fall_off[4], have_corners;
   LLVMValueRef z1 = NULL;
   LLVMValueRef z00 = NULL, z01 = NULL, z10 = NULL, z11 = NULL;
   LLVMValueRef x00 = NULL, x01 = NULL, x10 = NULL, x11 = NULL;
   LLVMValueRef y00 = NULL, y01 = NULL, y10 = NULL, y11 = NULL;
a752 1
   LLVMValueRef xs[4], ys[4], zs[4];
d754 1
a754 6
   int chan, texel_index;
   boolean seamless_cube_filter, accurate_cube_corners;

   seamless_cube_filter = bld->static_texture_state->target == PIPE_TEXTURE_CUBE &&
                          bld->static_sampler_state->seamless_cube_map;
   accurate_cube_corners = ACCURATE_CUBE_CORNERS && seamless_cube_filter;
d773 6
d780 7
a786 10
   if (!seamless_cube_filter) {
      lp_build_sample_wrap_linear(bld, coords[0], width_vec,
                                  flt_width_vec, offsets[0],
                                  bld->static_texture_state->pot_width,
                                  bld->static_sampler_state->wrap_s,
                                  &x00, &x01, &s_fpart);
      lp_build_name(x00, "tex.x0.wrapped");
      lp_build_name(x01, "tex.x1.wrapped");
      x10 = x00;
      x11 = x01;
d788 7
a794 28
      if (dims >= 2) {
         lp_build_sample_wrap_linear(bld, coords[1], height_vec,
                                     flt_height_vec, offsets[1],
                                     bld->static_texture_state->pot_height,
                                     bld->static_sampler_state->wrap_t,
                                     &y00, &y10, &t_fpart);
         lp_build_name(y00, "tex.y0.wrapped");
         lp_build_name(y10, "tex.y1.wrapped");
         y01 = y00;
         y11 = y10;

         if (dims == 3) {
            lp_build_sample_wrap_linear(bld, coords[2], depth_vec,
                                        flt_depth_vec, offsets[2],
                                        bld->static_texture_state->pot_depth,
                                        bld->static_sampler_state->wrap_r,
                                        &z00, &z1, &r_fpart);
            z01 = z10 = z11 = z00;
            lp_build_name(z00, "tex.z0.wrapped");
            lp_build_name(z1, "tex.z1.wrapped");
         }
      }
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
          bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
          bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
         z00 = z01 = z10 = z11 = z1 = coords[2];  /* cube face or layer */
         lp_build_name(z00, "tex.z0.layer");
         lp_build_name(z1, "tex.z1.layer");
d797 6
a802 158
   else {
      struct lp_build_if_state edge_if;
      LLVMTypeRef int1t;
      LLVMValueRef new_faces[4], new_xcoords[4][2], new_ycoords[4][2];
      LLVMValueRef coord, have_edge, have_corner;
      LLVMValueRef fall_off_ym_notxm, fall_off_ym_notxp, fall_off_x, fall_off_y;
      LLVMValueRef fall_off_yp_notxm, fall_off_yp_notxp;
      LLVMValueRef x0, x1, y0, y1, y0_clamped, y1_clamped;
      LLVMValueRef face = coords[2];
      LLVMValueRef half = lp_build_const_vec(bld->gallivm, coord_bld->type, 0.5f);
      LLVMValueRef length_minus_one = lp_build_sub(ivec_bld, width_vec, ivec_bld->one);
      /* XXX drop height calcs. Could (should) do this without seamless filtering too */
      height_vec = width_vec;
      flt_height_vec = flt_width_vec;

      /* XXX the overflow logic is actually sort of duplicated with trilinear,
       * since an overflow in one mip should also have a corresponding overflow
       * in another.
       */
      /* should always have normalized coords, and offsets are undefined */
      assert(bld->static_sampler_state->normalized_coords);
      coord = lp_build_mul(coord_bld, coords[0], flt_width_vec);
      /* instead of clamp, build mask if overflowed */
      coord = lp_build_sub(coord_bld, coord, half);
      /* convert to int, compute lerp weight */
      /* not ideal with AVX (and no AVX2) */
      lp_build_ifloor_fract(coord_bld, coord, &x0, &s_fpart);
      x1 = lp_build_add(ivec_bld, x0, ivec_bld->one);
      coord = lp_build_mul(coord_bld, coords[1], flt_height_vec);
      coord = lp_build_sub(coord_bld, coord, half);
      lp_build_ifloor_fract(coord_bld, coord, &y0, &t_fpart);
      y1 = lp_build_add(ivec_bld, y0, ivec_bld->one);

      fall_off[0] = lp_build_cmp(ivec_bld, PIPE_FUNC_LESS, x0, ivec_bld->zero);
      fall_off[1] = lp_build_cmp(ivec_bld, PIPE_FUNC_GREATER, x1, length_minus_one);
      fall_off[2] = lp_build_cmp(ivec_bld, PIPE_FUNC_LESS, y0, ivec_bld->zero);
      fall_off[3] = lp_build_cmp(ivec_bld, PIPE_FUNC_GREATER, y1, length_minus_one);

      fall_off_x = lp_build_or(ivec_bld, fall_off[0], fall_off[1]);
      fall_off_y = lp_build_or(ivec_bld, fall_off[2], fall_off[3]);
      have_edge = lp_build_or(ivec_bld, fall_off_x, fall_off_y);
      have_edge = lp_build_any_true_range(ivec_bld, ivec_bld->type.length, have_edge);

      /* needed for accurate corner filtering branch later, rely on 0 init */
      int1t = LLVMInt1TypeInContext(bld->gallivm->context);
      have_corners = lp_build_alloca(bld->gallivm, int1t, "have_corner");

      for (texel_index = 0; texel_index < 4; texel_index++) {
         xs[texel_index] = lp_build_alloca(bld->gallivm, ivec_bld->vec_type, "xs");
         ys[texel_index] = lp_build_alloca(bld->gallivm, ivec_bld->vec_type, "ys");
         zs[texel_index] = lp_build_alloca(bld->gallivm, ivec_bld->vec_type, "zs");
      }

      lp_build_if(&edge_if, bld->gallivm, have_edge);

      have_corner = lp_build_and(ivec_bld, fall_off_x, fall_off_y);
      have_corner = lp_build_any_true_range(ivec_bld, ivec_bld->type.length, have_corner);
      LLVMBuildStore(builder, have_corner, have_corners);

      /*
       * Need to feed clamped values here for cheap corner handling,
       * but only for y coord (as when falling off both edges we only
       * fall off the x one) - this should be sufficient.
       */
      y0_clamped = lp_build_max(ivec_bld, y0, ivec_bld->zero);
      y1_clamped = lp_build_min(ivec_bld, y1, length_minus_one);

      /*
       * Get all possible new coords.
       */
      lp_build_cube_new_coords(ivec_bld, face,
                               x0, x1, y0_clamped, y1_clamped,
                               length_minus_one,
                               new_faces, new_xcoords, new_ycoords);

      /* handle fall off x-, x+ direction */
      /* determine new coords, face (not both fall_off vars can be true at same time) */
      x00 = lp_build_select(ivec_bld, fall_off[0], new_xcoords[0][0], x0);
      y00 = lp_build_select(ivec_bld, fall_off[0], new_ycoords[0][0], y0_clamped);
      x10 = lp_build_select(ivec_bld, fall_off[0], new_xcoords[0][1], x0);
      y10 = lp_build_select(ivec_bld, fall_off[0], new_ycoords[0][1], y1_clamped);
      x01 = lp_build_select(ivec_bld, fall_off[1], new_xcoords[1][0], x1);
      y01 = lp_build_select(ivec_bld, fall_off[1], new_ycoords[1][0], y0_clamped);
      x11 = lp_build_select(ivec_bld, fall_off[1], new_xcoords[1][1], x1);
      y11 = lp_build_select(ivec_bld, fall_off[1], new_ycoords[1][1], y1_clamped);

      z00 = z10 = lp_build_select(ivec_bld, fall_off[0], new_faces[0], face);
      z01 = z11 = lp_build_select(ivec_bld, fall_off[1], new_faces[1], face);

      /* handle fall off y-, y+ direction */
      /*
       * Cheap corner logic: just hack up things so a texel doesn't fall
       * off both sides (which means filter weights will be wrong but we'll only
       * use valid texels in the filter).
       * This means however (y) coords must additionally be clamped (see above).
       * This corner handling should be fully OpenGL (but not d3d10) compliant.
       */
      fall_off_ym_notxm = lp_build_andnot(ivec_bld, fall_off[2], fall_off[0]);
      fall_off_ym_notxp = lp_build_andnot(ivec_bld, fall_off[2], fall_off[1]);
      fall_off_yp_notxm = lp_build_andnot(ivec_bld, fall_off[3], fall_off[0]);
      fall_off_yp_notxp = lp_build_andnot(ivec_bld, fall_off[3], fall_off[1]);

      x00 = lp_build_select(ivec_bld, fall_off_ym_notxm, new_xcoords[2][0], x00);
      y00 = lp_build_select(ivec_bld, fall_off_ym_notxm, new_ycoords[2][0], y00);
      x01 = lp_build_select(ivec_bld, fall_off_ym_notxp, new_xcoords[2][1], x01);
      y01 = lp_build_select(ivec_bld, fall_off_ym_notxp, new_ycoords[2][1], y01);
      x10 = lp_build_select(ivec_bld, fall_off_yp_notxm, new_xcoords[3][0], x10);
      y10 = lp_build_select(ivec_bld, fall_off_yp_notxm, new_ycoords[3][0], y10);
      x11 = lp_build_select(ivec_bld, fall_off_yp_notxp, new_xcoords[3][1], x11);
      y11 = lp_build_select(ivec_bld, fall_off_yp_notxp, new_ycoords[3][1], y11);

      z00 = lp_build_select(ivec_bld, fall_off_ym_notxm, new_faces[2], z00);
      z01 = lp_build_select(ivec_bld, fall_off_ym_notxp, new_faces[2], z01);
      z10 = lp_build_select(ivec_bld, fall_off_yp_notxm, new_faces[3], z10);
      z11 = lp_build_select(ivec_bld, fall_off_yp_notxp, new_faces[3], z11);

      LLVMBuildStore(builder, x00, xs[0]);
      LLVMBuildStore(builder, x01, xs[1]);
      LLVMBuildStore(builder, x10, xs[2]);
      LLVMBuildStore(builder, x11, xs[3]);
      LLVMBuildStore(builder, y00, ys[0]);
      LLVMBuildStore(builder, y01, ys[1]);
      LLVMBuildStore(builder, y10, ys[2]);
      LLVMBuildStore(builder, y11, ys[3]);
      LLVMBuildStore(builder, z00, zs[0]);
      LLVMBuildStore(builder, z01, zs[1]);
      LLVMBuildStore(builder, z10, zs[2]);
      LLVMBuildStore(builder, z11, zs[3]);

      lp_build_else(&edge_if);

      LLVMBuildStore(builder, x0, xs[0]);
      LLVMBuildStore(builder, x1, xs[1]);
      LLVMBuildStore(builder, x0, xs[2]);
      LLVMBuildStore(builder, x1, xs[3]);
      LLVMBuildStore(builder, y0, ys[0]);
      LLVMBuildStore(builder, y0, ys[1]);
      LLVMBuildStore(builder, y1, ys[2]);
      LLVMBuildStore(builder, y1, ys[3]);
      LLVMBuildStore(builder, face, zs[0]);
      LLVMBuildStore(builder, face, zs[1]);
      LLVMBuildStore(builder, face, zs[2]);
      LLVMBuildStore(builder, face, zs[3]);

      lp_build_endif(&edge_if);

      x00 = LLVMBuildLoad(builder, xs[0], "");
      x01 = LLVMBuildLoad(builder, xs[1], "");
      x10 = LLVMBuildLoad(builder, xs[2], "");
      x11 = LLVMBuildLoad(builder, xs[3], "");
      y00 = LLVMBuildLoad(builder, ys[0], "");
      y01 = LLVMBuildLoad(builder, ys[1], "");
      y10 = LLVMBuildLoad(builder, ys[2], "");
      y11 = LLVMBuildLoad(builder, ys[3], "");
      z00 = LLVMBuildLoad(builder, zs[0], "");
      z01 = LLVMBuildLoad(builder, zs[1], "");
      z10 = LLVMBuildLoad(builder, zs[2], "");
      z11 = LLVMBuildLoad(builder, zs[3], "");
a804 25
   if (linear_mask) {
      /*
       * Whack filter weights into place. Whatever texel had more weight is
       * the one which should have been selected by nearest filtering hence
       * just use 100% weight for it.
       */
      struct lp_build_context *c_bld = &bld->coord_bld;
      LLVMValueRef w1_mask, w1_weight;
      LLVMValueRef half = lp_build_const_vec(bld->gallivm, c_bld->type, 0.5f);

      w1_mask = lp_build_cmp(c_bld, PIPE_FUNC_GREATER, s_fpart, half);
      /* this select is really just a "and" */
      w1_weight = lp_build_select(c_bld, w1_mask, c_bld->one, c_bld->zero);
      s_fpart = lp_build_select(c_bld, linear_mask, s_fpart, w1_weight);
      if (dims >= 2) {
         w1_mask = lp_build_cmp(c_bld, PIPE_FUNC_GREATER, t_fpart, half);
         w1_weight = lp_build_select(c_bld, w1_mask, c_bld->one, c_bld->zero);
         t_fpart = lp_build_select(c_bld, linear_mask, t_fpart, w1_weight);
         if (dims == 3) {
            w1_mask = lp_build_cmp(c_bld, PIPE_FUNC_GREATER, r_fpart, half);
            w1_weight = lp_build_select(c_bld, w1_mask, c_bld->one, c_bld->zero);
            r_fpart = lp_build_select(c_bld, linear_mask, r_fpart, w1_weight);
         }
      }
   }
d810 1
a810 1
   lp_build_sample_texel_soa(bld,
d812 1
a812 1
                             x00, y00, z00,
d815 1
a815 1
   lp_build_sample_texel_soa(bld,
d817 1
a817 1
                             x01, y01, z01,
d822 6
a827 17
      if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE) {
         /* Interpolate two samples from 1D image to produce one color */
         for (chan = 0; chan < 4; chan++) {
            colors_out[chan] = lp_build_lerp(&bld->texel_bld, s_fpart,
                                             neighbors[0][0][chan],
                                             neighbors[0][1][chan],
                                             0);
         }
      }
      else {
         LLVMValueRef cmpval0, cmpval1;
         cmpval0 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][0][0]);
         cmpval1 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][1][0]);
         /* simplified lerp, AND mask with weight and add */
         colors_out[0] = lp_build_masklerp(&bld->texel_bld, s_fpart,
                                           cmpval0, cmpval1);
         colors_out[1] = colors_out[2] = colors_out[3] = colors_out[0];
d832 1
a832 2
      struct lp_build_if_state corner_if;
      LLVMValueRef colors0[4], colorss[4];
d835 1
a835 1
      lp_build_sample_texel_soa(bld,
d837 1
a837 1
                                x10, y10, z10,
d840 1
a840 1
      lp_build_sample_texel_soa(bld,
d842 1
a842 1
                                x11, y11, z11,
d846 9
a854 139
      /*
       * To avoid having to duplicate linear_mask / fetch code use
       * another branch (with corner condition though edge would work
       * as well) here.
       */
      if (accurate_cube_corners) {
         LLVMValueRef w00, w01, w10, w11, wx0, wy0;
         LLVMValueRef c_weight, c00, c01, c10, c11;
         LLVMValueRef have_corner, one_third, tmp;

         colorss[0] = lp_build_alloca(bld->gallivm, coord_bld->vec_type, "cs");
         colorss[1] = lp_build_alloca(bld->gallivm, coord_bld->vec_type, "cs");
         colorss[2] = lp_build_alloca(bld->gallivm, coord_bld->vec_type, "cs");
         colorss[3] = lp_build_alloca(bld->gallivm, coord_bld->vec_type, "cs");

         have_corner = LLVMBuildLoad(builder, have_corners, "");

         lp_build_if(&corner_if, bld->gallivm, have_corner);

         /*
          * we can't use standard 2d lerp as we need per-element weight
          * in case of corners, so just calculate bilinear result as
          * w00*s00 + w01*s01 + w10*s10 + w11*s11.
          * (This is actually less work than using 2d lerp, 7 vs. 9 instructions,
          * however calculating the weights needs another 6, so actually probably
          * not slower than 2d lerp only for 4 channels as weights only need
          * to be calculated once - of course fixing the weights has additional cost.)
          */
         wx0 = lp_build_sub(coord_bld, coord_bld->one, s_fpart);
         wy0 = lp_build_sub(coord_bld, coord_bld->one, t_fpart);
         w00 = lp_build_mul(coord_bld, wx0, wy0);
         w01 = lp_build_mul(coord_bld, s_fpart, wy0);
         w10 = lp_build_mul(coord_bld, wx0, t_fpart);
         w11 = lp_build_mul(coord_bld, s_fpart, t_fpart);

         /* find corner weight */
         c00 = lp_build_and(ivec_bld, fall_off[0], fall_off[2]);
         c_weight = lp_build_select(coord_bld, c00, w00, coord_bld->zero);
         c01 = lp_build_and(ivec_bld, fall_off[1], fall_off[2]);
         c_weight = lp_build_select(coord_bld, c01, w01, c_weight);
         c10 = lp_build_and(ivec_bld, fall_off[0], fall_off[3]);
         c_weight = lp_build_select(coord_bld, c10, w10, c_weight);
         c11 = lp_build_and(ivec_bld, fall_off[1], fall_off[3]);
         c_weight = lp_build_select(coord_bld, c11, w11, c_weight);

         /*
          * add 1/3 of the corner weight to each of the 3 other samples
          * and null out corner weight
          */
         one_third = lp_build_const_vec(bld->gallivm, coord_bld->type, 1.0f/3.0f);
         c_weight = lp_build_mul(coord_bld, c_weight, one_third);
         w00 = lp_build_add(coord_bld, w00, c_weight);
         c00 = LLVMBuildBitCast(builder, c00, coord_bld->vec_type, "");
         w00 = lp_build_andnot(coord_bld, w00, c00);
         w01 = lp_build_add(coord_bld, w01, c_weight);
         c01 = LLVMBuildBitCast(builder, c01, coord_bld->vec_type, "");
         w01 = lp_build_andnot(coord_bld, w01, c01);
         w10 = lp_build_add(coord_bld, w10, c_weight);
         c10 = LLVMBuildBitCast(builder, c10, coord_bld->vec_type, "");
         w10 = lp_build_andnot(coord_bld, w10, c10);
         w11 = lp_build_add(coord_bld, w11, c_weight);
         c11 = LLVMBuildBitCast(builder, c11, coord_bld->vec_type, "");
         w11 = lp_build_andnot(coord_bld, w11, c11);

         if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE) {
            for (chan = 0; chan < 4; chan++) {
               colors0[chan] = lp_build_mul(coord_bld, w00, neighbors[0][0][chan]);
               tmp = lp_build_mul(coord_bld, w01, neighbors[0][1][chan]);
               colors0[chan] = lp_build_add(coord_bld, tmp, colors0[chan]);
               tmp = lp_build_mul(coord_bld, w10, neighbors[1][0][chan]);
               colors0[chan] = lp_build_add(coord_bld, tmp, colors0[chan]);
               tmp = lp_build_mul(coord_bld, w11, neighbors[1][1][chan]);
               colors0[chan] = lp_build_add(coord_bld, tmp, colors0[chan]);
            }
         }
         else {
            LLVMValueRef cmpval00, cmpval01, cmpval10, cmpval11;
            cmpval00 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][0][0]);
            cmpval01 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][1][0]);
            cmpval10 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][0][0]);
            cmpval11 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][1][0]);
            /* inputs to interpolation are just masks so just add masked weights together */
            cmpval00 = LLVMBuildBitCast(builder, cmpval00, coord_bld->vec_type, "");
            cmpval01 = LLVMBuildBitCast(builder, cmpval01, coord_bld->vec_type, "");
            cmpval10 = LLVMBuildBitCast(builder, cmpval10, coord_bld->vec_type, "");
            cmpval11 = LLVMBuildBitCast(builder, cmpval11, coord_bld->vec_type, "");
            colors0[0] = lp_build_and(coord_bld, w00, cmpval00);
            tmp = lp_build_and(coord_bld, w01, cmpval01);
            colors0[0] = lp_build_add(coord_bld, tmp, colors0[0]);
            tmp = lp_build_and(coord_bld, w10, cmpval10);
            colors0[0] = lp_build_add(coord_bld, tmp, colors0[0]);
            tmp = lp_build_and(coord_bld, w11, cmpval11);
            colors0[0] = lp_build_add(coord_bld, tmp, colors0[0]);
            colors0[1] = colors0[2] = colors0[3] = colors0[0];
         }

         LLVMBuildStore(builder, colors0[0], colorss[0]);
         LLVMBuildStore(builder, colors0[1], colorss[1]);
         LLVMBuildStore(builder, colors0[2], colorss[2]);
         LLVMBuildStore(builder, colors0[3], colorss[3]);

         lp_build_else(&corner_if);
      }

      if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE) {
         /* Bilinear interpolate the four samples from the 2D image / 3D slice */
         for (chan = 0; chan < 4; chan++) {
            colors0[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                             s_fpart, t_fpart,
                                             neighbors[0][0][chan],
                                             neighbors[0][1][chan],
                                             neighbors[1][0][chan],
                                             neighbors[1][1][chan],
                                             0);
         }
      }
      else {
         LLVMValueRef cmpval00, cmpval01, cmpval10, cmpval11;
         cmpval00 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][0][0]);
         cmpval01 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][1][0]);
         cmpval10 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][0][0]);
         cmpval11 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][1][0]);
         colors0[0] = lp_build_masklerp2d(&bld->texel_bld, s_fpart, t_fpart,
                                          cmpval00, cmpval01, cmpval10, cmpval11);
         colors0[1] = colors0[2] = colors0[3] = colors0[0];
      }

      if (accurate_cube_corners) {
         LLVMBuildStore(builder, colors0[0], colorss[0]);
         LLVMBuildStore(builder, colors0[1], colorss[1]);
         LLVMBuildStore(builder, colors0[2], colorss[2]);
         LLVMBuildStore(builder, colors0[3], colorss[3]);

         lp_build_endif(&corner_if);

         colors0[0] = LLVMBuildLoad(builder, colorss[0], "");
         colors0[1] = LLVMBuildLoad(builder, colorss[1], "");
         colors0[2] = LLVMBuildLoad(builder, colorss[2], "");
         colors0[3] = LLVMBuildLoad(builder, colorss[3], "");
d862 1
a862 1
         lp_build_sample_texel_soa(bld,
d864 1
a864 1
                                   x00, y00, z1,
d867 1
a867 1
         lp_build_sample_texel_soa(bld,
d869 1
a869 1
                                   x01, y01, z1,
d872 1
a872 1
         lp_build_sample_texel_soa(bld,
d874 1
a874 1
                                   x10, y10, z1,
d877 1
a877 1
         lp_build_sample_texel_soa(bld,
d879 1
a879 1
                                   x11, y11, z1,
d883 9
a891 18
         if (bld->static_sampler_state->compare_mode == PIPE_TEX_COMPARE_NONE) {
            /* Bilinear interpolate the four samples from the second Z slice */
            for (chan = 0; chan < 4; chan++) {
               colors1[chan] = lp_build_lerp_2d(&bld->texel_bld,
                                                s_fpart, t_fpart,
                                                neighbors1[0][0][chan],
                                                neighbors1[0][1][chan],
                                                neighbors1[1][0][chan],
                                                neighbors1[1][1][chan],
                                                0);
            }
            /* Linearly interpolate the two samples from the two 3D slices */
            for (chan = 0; chan < 4; chan++) {
               colors_out[chan] = lp_build_lerp(&bld->texel_bld,
                                                r_fpart,
                                                colors0[chan], colors1[chan],
                                                0);
            }
d893 4
a896 10
         else {
            LLVMValueRef cmpval00, cmpval01, cmpval10, cmpval11;
            cmpval00 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][0][0]);
            cmpval01 = lp_build_sample_comparefunc(bld, coords[4], neighbors[0][1][0]);
            cmpval10 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][0][0]);
            cmpval11 = lp_build_sample_comparefunc(bld, coords[4], neighbors[1][1][0]);
            colors1[0] = lp_build_masklerp2d(&bld->texel_bld, s_fpart, t_fpart,
                                             cmpval00, cmpval01, cmpval10, cmpval11);
            /* Linearly interpolate the two samples from the two 3D slices */
            colors_out[0] = lp_build_lerp(&bld->texel_bld,
d898 1
a898 1
                                             colors0[0], colors1[0],
a899 1
            colors_out[1] = colors_out[2] = colors_out[3] = colors_out[0];
d914 2
a915 2
 * ilevel0 and ilevel1 indicate the two mipmap levels to sample
 * from (vectors or scalars).
d920 1
d923 3
a925 1
                       LLVMValueRef *coords,
d950 1
a950 1
   if (bld->num_mips == 1) {
d959 2
a960 1
      lp_build_sample_image_nearest(bld, size0,
d962 1
a962 1
                                    data_ptr0, mipoff0, coords, offsets,
d967 2
a968 1
      lp_build_sample_image_linear(bld, size0, NULL,
d970 1
a970 1
                                   data_ptr0, mipoff0, coords, offsets,
d986 1
a986 1
                                   lod_fpart, bld->lodf_bld.zero,
d994 6
a999 1
          * quads which need it (if there's one lod per quad).
d1001 3
a1003 1
         need_lerp = lp_build_compare(bld->gallivm, bld->lodf_bld.type,
d1005 2
a1006 2
                                      lod_fpart, bld->lodf_bld.zero);
         need_lerp = lp_build_any_true_range(&bld->lodi_bld, bld->num_lods, need_lerp);
a1010 7
         /*
          * We unfortunately need to clamp lod_fpart here since we can get
          * negative values which would screw up filtering if not all
          * lod_fpart values have same sign.
          */
         lod_fpart = lp_build_max(&bld->lodf_bld, lod_fpart,
                                  bld->lodf_bld.zero);
d1015 1
a1015 1
         if (bld->num_mips == 1) {
d1023 2
a1024 1
            lp_build_sample_image_nearest(bld, size1,
d1026 1
a1026 1
                                          data_ptr1, mipoff1, coords, offsets,
d1030 2
a1031 1
            lp_build_sample_image_linear(bld, size1, NULL,
d1033 1
a1033 1
                                         data_ptr1, mipoff1, coords, offsets,
d1041 1
a1041 1
                                                              bld->lodf_bld.type,
d1058 1
a1058 120
 * Sample the texture/mipmap using given mip filter, and using
 * both nearest and linear filtering at the same time depending
 * on linear_mask.
 * lod can be per quad but linear_mask is always per pixel.
 * ilevel0 and ilevel1 indicate the two mipmap levels to sample
 * from (vectors or scalars).
 * If we're using nearest miplevel sampling the '1' values will be null/unused.
 */
static void
lp_build_sample_mipmap_both(struct lp_build_sample_context *bld,
                            LLVMValueRef linear_mask,
                            unsigned mip_filter,
                            LLVMValueRef *coords,
                            const LLVMValueRef *offsets,
                            LLVMValueRef ilevel0,
                            LLVMValueRef ilevel1,
                            LLVMValueRef lod_fpart,
                            LLVMValueRef lod_positive,
                            LLVMValueRef *colors_out)
{
   LLVMBuilderRef builder = bld->gallivm->builder;
   LLVMValueRef size0 = NULL;
   LLVMValueRef size1 = NULL;
   LLVMValueRef row_stride0_vec = NULL;
   LLVMValueRef row_stride1_vec = NULL;
   LLVMValueRef img_stride0_vec = NULL;
   LLVMValueRef img_stride1_vec = NULL;
   LLVMValueRef data_ptr0 = NULL;
   LLVMValueRef data_ptr1 = NULL;
   LLVMValueRef mipoff0 = NULL;
   LLVMValueRef mipoff1 = NULL;
   LLVMValueRef colors0[4], colors1[4];
   unsigned chan;

   /* sample the first mipmap level */
   lp_build_mipmap_level_sizes(bld, ilevel0,
                               &size0,
                               &row_stride0_vec, &img_stride0_vec);
   if (bld->num_mips == 1) {
      data_ptr0 = lp_build_get_mipmap_level(bld, ilevel0);
   }
   else {
      /* This path should work for num_lods 1 too but slightly less efficient */
      data_ptr0 = bld->base_ptr;
      mipoff0 = lp_build_get_mip_offsets(bld, ilevel0);
   }

   lp_build_sample_image_linear(bld, size0, linear_mask,
                                row_stride0_vec, img_stride0_vec,
                                data_ptr0, mipoff0, coords, offsets,
                                colors0);

   /* Store the first level's colors in the output variables */
   for (chan = 0; chan < 4; chan++) {
       LLVMBuildStore(builder, colors0[chan], colors_out[chan]);
   }

   if (mip_filter == PIPE_TEX_MIPFILTER_LINEAR) {
      struct lp_build_if_state if_ctx;
      LLVMValueRef need_lerp;

      /*
       * We'll do mip filtering if any of the quads (or individual
       * pixel in case of per-pixel lod) need it.
       * Note using lod_positive here not lod_fpart since it may be the same
       * condition as that used in the outer "if" in the caller hence llvm
       * should be able to merge the branches in this case.
       */
      need_lerp = lp_build_any_true_range(&bld->lodi_bld, bld->num_lods, lod_positive);

      lp_build_if(&if_ctx, bld->gallivm, need_lerp);
      {
         /*
          * We unfortunately need to clamp lod_fpart here since we can get
          * negative values which would screw up filtering if not all
          * lod_fpart values have same sign.
          */
         lod_fpart = lp_build_max(&bld->lodf_bld, lod_fpart,
                                  bld->lodf_bld.zero);
         /* sample the second mipmap level */
         lp_build_mipmap_level_sizes(bld, ilevel1,
                                     &size1,
                                     &row_stride1_vec, &img_stride1_vec);
         if (bld->num_mips == 1) {
            data_ptr1 = lp_build_get_mipmap_level(bld, ilevel1);
         }
         else {
            data_ptr1 = bld->base_ptr;
            mipoff1 = lp_build_get_mip_offsets(bld, ilevel1);
         }

         lp_build_sample_image_linear(bld, size1, linear_mask,
                                      row_stride1_vec, img_stride1_vec,
                                      data_ptr1, mipoff1, coords, offsets,
                                      colors1);

         /* interpolate samples from the two mipmap levels */

         if (bld->num_lods != bld->coord_type.length)
            lod_fpart = lp_build_unpack_broadcast_aos_scalars(bld->gallivm,
                                                              bld->lodf_bld.type,
                                                              bld->texel_bld.type,
                                                              lod_fpart);

         for (chan = 0; chan < 4; chan++) {
            colors0[chan] = lp_build_lerp(&bld->texel_bld, lod_fpart,
                                          colors0[chan], colors1[chan],
                                          0);
            LLVMBuildStore(builder, colors0[chan], colors_out[chan]);
         }
      }
      lp_build_endif(&if_ctx);
   }
}


/**
 * Build (per-coord) layer value.
 * Either clamp layer to valid values or fill in optional out_of_bounds
 * value and just return value unclamped.
d1063 1
a1063 2
                     LLVMValueRef layer,
                     LLVMValueRef *out_of_bounds)
d1065 1
a1065 2
   LLVMValueRef num_layers;
   struct lp_build_context *int_coord_bld = &bld->int_coord_bld;
d1067 6
a1072 2
   num_layers = bld->dynamic_state->depth(bld->dynamic_state,
                                          bld->gallivm, texture_unit);
a1073 14
   if (out_of_bounds) {
      LLVMValueRef out1, out;
      num_layers = lp_build_broadcast_scalar(int_coord_bld, num_layers);
      out = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, layer, int_coord_bld->zero);
      out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_GEQUAL, layer, num_layers);
      *out_of_bounds = lp_build_or(int_coord_bld, out, out1);
      return layer;
   }
   else {
      LLVMValueRef maxlayer;
      maxlayer = lp_build_sub(&bld->int_bld, num_layers, bld->int_bld.one);
      maxlayer = lp_build_broadcast_scalar(int_coord_bld, maxlayer);
      return lp_build_clamp(int_coord_bld, layer, int_coord_bld->zero, maxlayer);
   }
d1084 3
a1086 1
                       LLVMValueRef *coords,
d1090 1
a1090 1
                       LLVMValueRef *lod_pos_or_zero,
a1099 2
   LLVMValueRef lod_ipart = NULL;
   struct lp_derivatives cube_derivs;
d1111 1
d1117 14
a1130 31
      lp_build_cube_lookup(bld, coords, derivs, &cube_rho, &cube_derivs, need_derivs);
      derivs = &cube_derivs;
   }
   else if (target == PIPE_TEXTURE_1D_ARRAY ||
            target == PIPE_TEXTURE_2D_ARRAY) {
      coords[2] = lp_build_iround(&bld->coord_bld, coords[2]);
      coords[2] = lp_build_layer_coord(bld, texture_index, coords[2], NULL);
   }

   if (bld->static_sampler_state->compare_mode != PIPE_TEX_COMPARE_NONE) {
      /*
       * Clamp p coords to [0,1] for fixed function depth texture format here.
       * Technically this is not entirely correct for unorm depth as the ref value
       * should be converted to the depth format (quantization!) and comparison
       * then done in texture format. This would actually help performance (since
       * only need to do it once and could save the per-sample conversion of texels
       * to floats instead), but it would need more messy code (would need to push
       * at least some bits down to actual fetch so conversion could be skipped,
       * and would have ugly interaction with border color, would need to convert
       * border color to that format too or do some other tricks to make it work).
       */
      const struct util_format_description *format_desc = bld->format_desc;
      unsigned chan_type;
      /* not entirely sure we couldn't end up with non-valid swizzle here */
      chan_type = format_desc->swizzle[0] <= UTIL_FORMAT_SWIZZLE_W ?
                     format_desc->channel[format_desc->swizzle[0]].type :
                     UTIL_FORMAT_TYPE_FLOAT;
      if (chan_type != UTIL_FORMAT_TYPE_FLOAT) {
         coords[4] = lp_build_clamp(&bld->coord_bld, coords[4],
                                    bld->coord_bld.zero, bld->coord_bld.one);
      }
d1142 1
a1142 1
                            coords[0], coords[1], coords[2], cube_rho,
d1145 1
a1145 1
                            &lod_ipart, lod_fpart, lod_pos_or_zero);
d1147 1
a1147 8
      lod_ipart = bld->lodi_bld.zero;
      *lod_pos_or_zero = bld->lodi_bld.zero;
   }

   if (bld->num_lods != bld->num_mips) {
      /* only makes sense if there's just a single mip level */
      assert(bld->num_mips == 1);
      lod_ipart = lp_build_extract_range(bld->gallivm, lod_ipart, 0, 1);
d1164 2
a1165 2
         assert(lod_ipart);
         lp_build_nearest_mip_level(bld, texture_index, lod_ipart, ilevel0, NULL);
d1175 2
a1176 2
      assert(lod_ipart);
      lp_build_nearest_mip_level(bld, texture_index, lod_ipart, ilevel0, NULL);
d1179 1
a1179 1
      assert(lod_ipart);
d1182 1
a1182 1
                                 lod_ipart, lod_fpart,
a1187 219
static void
lp_build_clamp_border_color(struct lp_build_sample_context *bld,
                            unsigned sampler_unit)
{
   struct gallivm_state *gallivm = bld->gallivm;
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef border_color_ptr =
      bld->dynamic_state->border_color(bld->dynamic_state,
                                        gallivm, sampler_unit);
   LLVMValueRef border_color;
   const struct util_format_description *format_desc = bld->format_desc;
   struct lp_type vec4_type = bld->texel_type;
   struct lp_build_context vec4_bld;
   LLVMValueRef min_clamp = NULL;
   LLVMValueRef max_clamp = NULL;

   /*
    * For normalized format need to clamp border color (technically
    * probably should also quantize the data). Really sucks doing this
    * here but can't avoid at least for now since this is part of
    * sampler state and texture format is part of sampler_view state.
    * GL expects also expects clamping for uint/sint formats too so
    * do that as well (d3d10 can't end up here with uint/sint since it
    * only supports them with ld).
    */
   vec4_type.length = 4;
   lp_build_context_init(&vec4_bld, gallivm, vec4_type);

   /*
    * Vectorized clamping of border color. Loading is a bit of a hack since
    * we just cast the pointer to float array to pointer to vec4
    * (int or float).
    */
   border_color_ptr = lp_build_array_get_ptr(gallivm, border_color_ptr,
                                             lp_build_const_int32(gallivm, 0));
   border_color_ptr = LLVMBuildBitCast(builder, border_color_ptr,
                                       LLVMPointerType(vec4_bld.vec_type, 0), "");
   border_color = LLVMBuildLoad(builder, border_color_ptr, "");
   /* we don't have aligned type in the dynamic state unfortunately */
   lp_set_load_alignment(border_color, 4);

   /*
    * Instead of having some incredibly complex logic which will try to figure out
    * clamping necessary for each channel, simply use the first channel, and treat
    * mixed signed/unsigned normalized formats specially.
    * (Mixed non-normalized, which wouldn't work at all here, do not exist for a
    * good reason.)
    */
   if (format_desc->layout == UTIL_FORMAT_LAYOUT_PLAIN) {
      int chan;
      /* d/s needs special handling because both present means just sampling depth */
      if (util_format_is_depth_and_stencil(format_desc->format)) {
         chan = format_desc->swizzle[0];
      }
      else {
         chan = util_format_get_first_non_void_channel(format_desc->format);
      }
      if (chan >= 0 && chan <= UTIL_FORMAT_SWIZZLE_W) {
         unsigned chan_type = format_desc->channel[chan].type;
         unsigned chan_norm = format_desc->channel[chan].normalized;
         unsigned chan_pure = format_desc->channel[chan].pure_integer;
         if (chan_type == UTIL_FORMAT_TYPE_SIGNED) {
            if (chan_norm) {
               min_clamp = lp_build_const_vec(gallivm, vec4_type, -1.0F);
               max_clamp = vec4_bld.one;
            }
            else if (chan_pure) {
               /*
                * Border color was stored as int, hence need min/max clamp
                * only if chan has less than 32 bits..
                */
               unsigned chan_size = format_desc->channel[chan].size;
               if (chan_size < 32) {
                  min_clamp = lp_build_const_int_vec(gallivm, vec4_type,
                                                     0 - (1 << (chan_size - 1)));
                  max_clamp = lp_build_const_int_vec(gallivm, vec4_type,
                                                     (1 << (chan_size - 1)) - 1);
               }
            }
            /* TODO: no idea about non-pure, non-normalized! */
         }
         else if (chan_type == UTIL_FORMAT_TYPE_UNSIGNED) {
            if (chan_norm) {
               min_clamp = vec4_bld.zero;
               max_clamp = vec4_bld.one;
            }
            /*
             * Need a ugly hack here, because we don't have Z32_FLOAT_X8X24
             * we use Z32_FLOAT_S8X24 to imply sampling depth component
             * and ignoring stencil, which will blow up here if we try to
             * do a uint clamp in a float texel build...
             * And even if we had that format, mesa st also thinks using z24s8
             * means depth sampling ignoring stencil.
             */
            else if (chan_pure) {
               /*
                * Border color was stored as uint, hence never need min
                * clamp, and only need max clamp if chan has less than 32 bits.
                */
               unsigned chan_size = format_desc->channel[chan].size;
               if (chan_size < 32) {
                  max_clamp = lp_build_const_int_vec(gallivm, vec4_type,
                                                     (1 << chan_size) - 1);
               }
               /* TODO: no idea about non-pure, non-normalized! */
            }
         }
         else if (chan_type == UTIL_FORMAT_TYPE_FIXED) {
            /* TODO: I have no idea what clamp this would need if any! */
         }
      }
      /* mixed plain formats (or different pure size) */
      switch (format_desc->format) {
      case PIPE_FORMAT_B10G10R10A2_UINT:
      case PIPE_FORMAT_R10G10B10A2_UINT:
      {
         unsigned max10 = (1 << 10) - 1;
         max_clamp = lp_build_const_aos(gallivm, vec4_type, max10, max10,
                                        max10, (1 << 2) - 1, NULL);
      }
         break;
      case PIPE_FORMAT_R10SG10SB10SA2U_NORM:
         min_clamp = lp_build_const_aos(gallivm, vec4_type, -1.0F, -1.0F,
                                        -1.0F, 0.0F, NULL);
         max_clamp = vec4_bld.one;
         break;
      case PIPE_FORMAT_R8SG8SB8UX8U_NORM:
      case PIPE_FORMAT_R5SG5SB6U_NORM:
         min_clamp = lp_build_const_aos(gallivm, vec4_type, -1.0F, -1.0F,
                                        0.0F, 0.0F, NULL);
         max_clamp = vec4_bld.one;
         break;
      default:
         break;
      }
   }
   else {
      /* cannot figure this out from format description */
      if (format_desc->layout == UTIL_FORMAT_LAYOUT_S3TC) {
         /* s3tc formats are always unorm */
         min_clamp = vec4_bld.zero;
         max_clamp = vec4_bld.one;
      }
      else if (format_desc->layout == UTIL_FORMAT_LAYOUT_RGTC ||
               format_desc->layout == UTIL_FORMAT_LAYOUT_ETC) {
         switch (format_desc->format) {
         case PIPE_FORMAT_RGTC1_UNORM:
         case PIPE_FORMAT_RGTC2_UNORM:
         case PIPE_FORMAT_LATC1_UNORM:
         case PIPE_FORMAT_LATC2_UNORM:
         case PIPE_FORMAT_ETC1_RGB8:
            min_clamp = vec4_bld.zero;
            max_clamp = vec4_bld.one;
            break;
         case PIPE_FORMAT_RGTC1_SNORM:
         case PIPE_FORMAT_RGTC2_SNORM:
         case PIPE_FORMAT_LATC1_SNORM:
         case PIPE_FORMAT_LATC2_SNORM:
            min_clamp = lp_build_const_vec(gallivm, vec4_type, -1.0F);
            max_clamp = vec4_bld.one;
            break;
         default:
            assert(0);
            break;
         }
      }
      /*
       * all others from subsampled/other group, though we don't care
       * about yuv (and should not have any from zs here)
       */
      else if (format_desc->colorspace != UTIL_FORMAT_COLORSPACE_YUV){
         switch (format_desc->format) {
         case PIPE_FORMAT_R8G8_B8G8_UNORM:
         case PIPE_FORMAT_G8R8_G8B8_UNORM:
         case PIPE_FORMAT_G8R8_B8R8_UNORM:
         case PIPE_FORMAT_R8G8_R8B8_UNORM:
         case PIPE_FORMAT_R1_UNORM: /* doesn't make sense but ah well */
            min_clamp = vec4_bld.zero;
            max_clamp = vec4_bld.one;
            break;
         case PIPE_FORMAT_R8G8Bx_SNORM:
            min_clamp = lp_build_const_vec(gallivm, vec4_type, -1.0F);
            max_clamp = vec4_bld.one;
            break;
            /*
             * Note smallfloat formats usually don't need clamping
             * (they still have infinite range) however this is not
             * true for r11g11b10 and r9g9b9e5, which can't represent
             * negative numbers (and additionally r9g9b9e5 can't represent
             * very large numbers). d3d10 seems happy without clamping in
             * this case, but gl spec is pretty clear: "for floating
             * point and integer formats, border values are clamped to
             * the representable range of the format" so do that here.
             */
         case PIPE_FORMAT_R11G11B10_FLOAT:
            min_clamp = vec4_bld.zero;
            break;
         case PIPE_FORMAT_R9G9B9E5_FLOAT:
            min_clamp = vec4_bld.zero;
            max_clamp = lp_build_const_vec(gallivm, vec4_type, MAX_RGB9E5);
            break;
         default:
            assert(0);
            break;
         }
      }
   }

   if (min_clamp) {
      border_color = lp_build_max(&vec4_bld, border_color, min_clamp);
   }
   if (max_clamp) {
      border_color = lp_build_min(&vec4_bld, border_color, max_clamp);
   }

   bld->border_color_clamped = border_color;
}


d1196 3
a1198 1
                        LLVMValueRef *coords,
d1200 1
a1200 1
                        LLVMValueRef lod_positive,
d1206 1
d1208 3
a1210 4
   const struct lp_static_sampler_state *sampler_state = bld->static_sampler_state;
   const unsigned mip_filter = sampler_state->min_mip_filter;
   const unsigned min_filter = sampler_state->min_img_filter;
   const unsigned mag_filter = sampler_state->mag_img_filter;
a1213 16
   /* if we need border color, (potentially) clamp it now */
   if (lp_sampler_wrap_mode_uses_border_color(sampler_state->wrap_s,
                                              min_filter,
                                              mag_filter) ||
       (bld->dims > 1 &&
           lp_sampler_wrap_mode_uses_border_color(sampler_state->wrap_t,
                                                  min_filter,
                                                  mag_filter)) ||
       (bld->dims > 2 &&
           lp_sampler_wrap_mode_uses_border_color(sampler_state->wrap_r,
                                                  min_filter,
                                                  mag_filter))) {
      lp_build_clamp_border_color(bld, sampler_unit);
   }


d1225 3
a1227 2
      lp_build_sample_mipmap(bld, min_filter, mip_filter,
                             coords, offsets,
d1232 6
d1239 7
a1245 2
       * Could also get rid of the if-logic and always use mipmap_both, both
       * for the single lod and multi-lod case if nothing really uses this.
d1247 7
a1253 5
      if (bld->num_lods == 1) {
         /* Emit conditional to choose min image filter or mag image filter
          * depending on the lod being > 0 or <= 0, respectively.
          */
         struct lp_build_if_state if_ctx;
d1255 8
a1262 20
         lod_positive = LLVMBuildTrunc(builder, lod_positive,
                                       LLVMInt1TypeInContext(bld->gallivm->context), "");

         lp_build_if(&if_ctx, bld->gallivm, lod_positive);
         {
            /* Use the minification filter */
            lp_build_sample_mipmap(bld, min_filter, mip_filter,
                                   coords, offsets,
                                   ilevel0, ilevel1, lod_fpart,
                                   texels);
         }
         lp_build_else(&if_ctx);
         {
            /* Use the magnification filter */
            lp_build_sample_mipmap(bld, mag_filter, PIPE_TEX_MIPFILTER_NONE,
                                   coords, offsets,
                                   ilevel0, NULL, NULL,
                                   texels);
         }
         lp_build_endif(&if_ctx);
d1264 8
a1271 53
      else {
         LLVMValueRef need_linear, linear_mask;
         unsigned mip_filter_for_nearest;
         struct lp_build_if_state if_ctx;

         if (min_filter == PIPE_TEX_FILTER_LINEAR) {
            linear_mask = lod_positive;
            mip_filter_for_nearest = PIPE_TEX_MIPFILTER_NONE;
         }
         else {
            linear_mask = lp_build_not(&bld->lodi_bld, lod_positive);
            mip_filter_for_nearest = mip_filter;
         }
         need_linear = lp_build_any_true_range(&bld->lodi_bld, bld->num_lods,
                                               linear_mask);

         if (bld->num_lods != bld->coord_type.length) {
            linear_mask = lp_build_unpack_broadcast_aos_scalars(bld->gallivm,
                                                                bld->lodi_type,
                                                                bld->int_coord_type,
                                                                linear_mask);
         }

         lp_build_if(&if_ctx, bld->gallivm, need_linear);
         {
            /*
             * Do sampling with both filters simultaneously. This means using
             * a linear filter and doing some tricks (with weights) for the pixels
             * which need nearest filter.
             * Note that it's probably rare some pixels need nearest and some
             * linear filter but the fixups required for the nearest pixels
             * aren't all that complicated so just always run a combined path
             * if at least some pixels require linear.
             */
            lp_build_sample_mipmap_both(bld, linear_mask, mip_filter,
                                        coords, offsets,
                                        ilevel0, ilevel1,
                                        lod_fpart, lod_positive,
                                        texels);
         }
         lp_build_else(&if_ctx);
         {
            /*
             * All pixels require just nearest filtering, which is way
             * cheaper than linear, hence do a separate path for that.
             */
            lp_build_sample_mipmap(bld, PIPE_TEX_FILTER_NEAREST,
                                   mip_filter_for_nearest,
                                   coords, offsets,
                                   ilevel0, ilevel1, lod_fpart,
                                   texels);
         }
         lp_build_endif(&if_ctx);
d1273 1
d1299 1
a1299 1
   struct lp_build_context *perquadi_bld = &bld->lodi_bld;
a1302 1
   boolean out_of_bound_ret_zero = TRUE;
a1308 2
   out_of_bounds = int_coord_bld->zero;

d1310 1
a1310 1
      if (bld->num_mips != int_coord_bld->type.length) {
d1317 1
a1317 2
      lp_build_nearest_mip_level(bld, texture_unit, ilevel, &ilevel,
                                 out_of_bound_ret_zero ? &out_of_bounds : NULL);
d1320 2
a1321 8
      assert(bld->num_mips == 1);
      if (bld->static_texture_state->target != PIPE_BUFFER) {
         ilevel = bld->dynamic_state->first_level(bld->dynamic_state,
                                                  bld->gallivm, texture_unit);
      }
      else {
         ilevel = lp_build_const_int32(bld->gallivm, 0);
      }
d1331 2
a1332 3
      if (out_of_bound_ret_zero) {
         z = lp_build_layer_coord(bld, texture_unit, z, &out1);
         out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
d1335 1
a1335 1
         z = lp_build_layer_coord(bld, texture_unit, z, NULL);
d1341 1
a1341 4
      /*
       * coords are really unsigned, offsets are signed, but I don't think
       * exceeding 31 bits is possible
       */
d1344 1
a1344 2
   out1 = lp_build_cmp(int_coord_bld, PIPE_FUNC_LESS, x, int_coord_bld->zero);
   out_of_bounds = lp_build_or(int_coord_bld, out_of_bounds, out1);
d1387 1
a1387 1
   if (out_of_bound_ret_zero) {
d1389 1
a1389 1
       * Only needed for ARB_robust_buffer_access_behavior and d3d10.
d1391 1
d1403 54
d1497 1
a1497 1
                    enum lp_sampler_lod_property lod_property,
d1500 1
a1500 2
   unsigned target = static_texture_state->target;
   unsigned dims = texture_dims(target);
d1502 1
a1502 1
   unsigned mip_filter, min_img_filter, mag_img_filter, i;
d1507 4
a1510 1
   LLVMValueRef tex_width, newcoords[5];
a1516 13
   if (static_texture_state->format == PIPE_FORMAT_NONE) {
      /*
       * If there's nothing bound, format is NONE, and we must return
       * all zero as mandated by d3d10 in this case.
       */
      unsigned chan;
      LLVMValueRef zero = lp_build_const_vec(gallivm, type, 0.0F);
      for (chan = 0; chan < 4; chan++) {
         texel_out[chan] = zero;
      }
      return;
   }

a1567 21
   if (static_texture_state->target == PIPE_TEXTURE_CUBE ||
       static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY)
   {
      /*
       * Seamless filtering ignores wrap modes.
       * Setting to CLAMP_TO_EDGE is correct for nearest filtering, for
       * bilinear it's not correct but way better than using for instance repeat.
       * Note we even set this for non-seamless. Technically GL allows any wrap
       * mode, which made sense when supporting true borders (can get seamless
       * effect with border and CLAMP_TO_BORDER), but gallium doesn't support
       * borders and d3d9 requires wrap modes to be ignored and it's a pain to fix
       * up the sampler state (as it makes it texture dependent).
       */
      derived_sampler_state.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
      derived_sampler_state.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   }

   min_img_filter = derived_sampler_state.min_img_filter;
   mag_img_filter = derived_sampler_state.mag_img_filter;


d1586 3
a1588 15
   bld.num_mips = bld.num_lods = 1;

   if ((gallivm_debug & GALLIVM_DEBUG_NO_QUAD_LOD) &&
       (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) &&
       (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
       (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
      /*
       * special case for using per-pixel lod even for implicit lod,
       * which is generally never required (ok by APIs) except to please
       * some (somewhat broken imho) tests (because per-pixel face selection
       * can cause derivatives to be different for pixels outside the primitive
       * due to the major axis division even if pre-project derivatives are
       * looking normal).
       */
      bld.num_mips = type.length;
a1589 13
   }
   else if (lod_property == LP_SAMPLER_LOD_PER_ELEMENT ||
       (explicit_lod || lod_bias || derivs)) {
      if ((is_fetch && target != PIPE_BUFFER) ||
          (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
         bld.num_mips = type.length;
         bld.num_lods = type.length;
      }
      else if (!is_fetch && min_img_filter != mag_img_filter) {
         bld.num_mips = 1;
         bld.num_lods = type.length;
      }
   }
d1591 1
a1591 1
   else if ((is_fetch && explicit_lod && target != PIPE_BUFFER) ||
a1592 1
      bld.num_mips = num_quads;
d1595 2
a1596 3
   else if (!is_fetch && min_img_filter != mag_img_filter) {
      bld.num_mips = 1;
      bld.num_lods = num_quads;
d1599 1
a1599 2

   bld.lodf_type = type;
d1602 1
a1602 7
      /* TODO: this currently always has to be per-quad or per-element */
      bld.lodf_type.length = type.length > 4 ? ((type.length + 15) / 16) * 4 : 1;
   }
   bld.lodi_type = lp_int_type(bld.lodf_type);
   bld.levelf_type = bld.lodf_type;
   if (bld.num_mips == 1) {
      bld.levelf_type.length = 1;
d1608 3
a1610 3
   if (bld.num_mips > 1) {
      bld.float_size_type.length = bld.num_mips == type.length ?
                                      bld.num_mips * bld.float_size_in_type.length :
a1626 2
   lp_build_context_init(&bld.lodf_bld, gallivm, bld.lodf_type);
   lp_build_context_init(&bld.lodi_bld, gallivm, bld.lodi_type);
d1636 4
a1660 4
   for (i = 0; i < 5; i++) {
      newcoords[i] = coords[i];
   }

d1665 1
a1665 1
                          newcoords,
d1670 1
a1670 1
      lp_build_fetch_texel(&bld, texture_index, newcoords,
d1676 1
a1676 1
      LLVMValueRef lod_fpart = NULL, lod_positive = NULL;
d1679 2
a1680 20
                        /* not sure this is strictly needed or simply impossible */
                        derived_sampler_state.compare_mode == PIPE_TEX_COMPARE_NONE &&
                        lp_is_simple_wrap_mode(derived_sampler_state.wrap_s);

      use_aos &= bld.num_lods <= num_quads ||
                 derived_sampler_state.min_img_filter ==
                    derived_sampler_state.mag_img_filter;
      if (dims > 1) {
         use_aos &= lp_is_simple_wrap_mode(derived_sampler_state.wrap_t);
         if (dims > 2) {
            use_aos &= lp_is_simple_wrap_mode(derived_sampler_state.wrap_r);
         }
      }
      if (static_texture_state->target == PIPE_TEXTURE_CUBE &&
          derived_sampler_state.seamless_cube_map &&
          (derived_sampler_state.min_img_filter == PIPE_TEX_FILTER_LINEAR ||
           derived_sampler_state.mag_img_filter == PIPE_TEX_FILTER_LINEAR)) {
         /* theoretically possible with AoS filtering but not implemented (complex!) */
         use_aos = 0;
      }
d1686 6
a1691 10
         debug_printf("  min_img %d  mag_img %d  mip %d  target %d  seamless %d"
                      "  wraps %d  wrapt %d  wrapr %d\n",
                      derived_sampler_state.min_img_filter,
                      derived_sampler_state.mag_img_filter,
                      derived_sampler_state.min_mip_filter,
                      static_texture_state->target,
                      derived_sampler_state.seamless_cube_map,
                      derived_sampler_state.wrap_s,
                      derived_sampler_state.wrap_t,
                      derived_sampler_state.wrap_r);
d1695 1
a1695 1
                             newcoords,
d1697 1
a1697 1
                             &lod_positive, &lod_fpart,
d1702 1
a1702 2
       * be a loss with aos with AVX (but it should work, except
       * for conformance if min_filter != mag_filter if num_lods > 1).
d1706 12
d1721 2
a1722 3
                                newcoords[0], newcoords[1],
                                newcoords[2],
                                offsets, lod_positive, lod_fpart,
d1729 2
a1730 2
                                    newcoords, offsets,
                                    lod_positive, lod_fpart,
d1770 4
d1775 3
a1777 6
         bld4.num_mips = bld4.num_lods = 1;
         if ((gallivm_debug & GALLIVM_DEBUG_NO_QUAD_LOD) &&
             (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) &&
             (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
             (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
            bld4.num_mips = type4.length;
d1779 2
a1780 13
         }
         if (lod_property == LP_SAMPLER_LOD_PER_ELEMENT &&
             (explicit_lod || lod_bias || derivs)) {
            if ((is_fetch && target != PIPE_BUFFER) ||
                (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
               bld4.num_mips = type4.length;
               bld4.num_lods = type4.length;
            }
            else if (!is_fetch && min_img_filter != mag_img_filter) {
               bld4.num_mips = 1;
               bld4.num_lods = type4.length;
            }
         }
d1782 1
a1783 1
         bld4.lodf_type = type4;
a1784 5
            bld4.lodf_type.length = 1;
         }
         bld4.lodi_type = lp_int_type(bld4.lodf_type);
         bld4.levelf_type = type4;
         if (bld4.num_mips != type4.length) {
d1789 3
a1791 3
         if (bld4.num_mips > 1) {
            bld4.float_size_type.length = bld4.num_mips == type4.length ?
                                            bld4.num_mips * bld4.float_size_in_type.length :
a1807 2
         lp_build_context_init(&bld4.lodf_bld, gallivm, bld4.lodf_type);
         lp_build_context_init(&bld4.lodi_bld, gallivm, bld4.lodi_type);
d1811 1
a1811 1
            LLVMValueRef lod_positive4, lod_fpart4 = NULL;
d1816 3
a1818 3
            s4 = lp_build_extract_range(gallivm, newcoords[0], 4*i, 4);
            t4 = lp_build_extract_range(gallivm, newcoords[1], 4*i, 4);
            r4 = lp_build_extract_range(gallivm, newcoords[2], 4*i, 4);
d1829 2
a1830 3
            lod_positive4 = lp_build_extract_range(gallivm, lod_positive, num_lods * i, num_lods);
            ilevel04 = bld.num_mips == 1 ? ilevel0 :
                          lp_build_extract_range(gallivm, ilevel0, num_lods * i, num_lods);
d1840 1
a1840 1
                                   lod_positive4, lod_fpart4,
a1845 8
               /* this path is currently unreachable and hence might break easily... */
               LLVMValueRef newcoords4[5];
               newcoords4[0] = s4;
               newcoords4[1] = t4;
               newcoords4[2] = r4;
               newcoords4[3] = lp_build_extract_range(gallivm, newcoords[3], 4*i, 4);
               newcoords4[4] = lp_build_extract_range(gallivm, newcoords[4], 4*i, 4);

d1847 2
a1848 2
                                       newcoords4, offsets4,
                                       lod_positive4, lod_fpart4,
d1861 2
d1865 1
a1865 1
   if (target != PIPE_BUFFER) {
d1888 1
a1888 3
                        unsigned target,
                        boolean is_sviewinfo,
                        enum lp_sampler_lod_property lod_property,
d1892 2
a1893 1
   LLVMValueRef lod, level, size;
d1897 1
a1897 42
   unsigned num_lods = 1;
   struct lp_build_context bld_int_vec4;

   if (static_state->format == PIPE_FORMAT_NONE) {
      /*
       * If there's nothing bound, format is NONE, and we must return
       * all zero as mandated by d3d10 in this case.
       */
      unsigned chan;
      LLVMValueRef zero = lp_build_const_vec(gallivm, int_type, 0.0F);
      for (chan = 0; chan < 4; chan++) {
         sizes_out[chan] = zero;
      }
      return;
   }

   /*
    * Do some sanity verification about bound texture and shader dcl target.
    * Not entirely sure what's possible but assume array/non-array
    * always compatible (probably not ok for OpenGL but d3d10 has no
    * distinction of arrays at the resource level).
    * Everything else looks bogus (though not entirely sure about rect/2d).
    * Currently disabled because it causes assertion failures if there's
    * nothing bound (or rather a dummy texture, not that this case would
    * return the right values).
    */
   if (0 && static_state->target != target) {
      if (static_state->target == PIPE_TEXTURE_1D)
         assert(target == PIPE_TEXTURE_1D_ARRAY);
      else if (static_state->target == PIPE_TEXTURE_1D_ARRAY)
         assert(target == PIPE_TEXTURE_1D);
      else if (static_state->target == PIPE_TEXTURE_2D)
         assert(target == PIPE_TEXTURE_2D_ARRAY);
      else if (static_state->target == PIPE_TEXTURE_2D_ARRAY)
         assert(target == PIPE_TEXTURE_2D);
      else if (static_state->target == PIPE_TEXTURE_CUBE)
         assert(target == PIPE_TEXTURE_CUBE_ARRAY);
      else if (static_state->target == PIPE_TEXTURE_CUBE_ARRAY)
         assert(target == PIPE_TEXTURE_CUBE);
      else
         assert(0);
   }
d1899 1
a1899 1
   dims = texture_dims(target);
d1901 1
a1901 1
   switch (target) {
d1913 1
a1913 1
   lp_build_context_init(&bld_int_vec4, gallivm, lp_type_int_vec(32, 128));
d1919 3
a1921 2
      level = LLVMBuildAdd(gallivm->builder, lod, first_level, "level");
      lod = lp_build_broadcast_scalar(&bld_int_vec4, level);
d1923 1
a1923 1
      lod = bld_int_vec4.zero;
d1926 6
a1931 1
   size = bld_int_vec4.undef;
d1949 1
a1949 1
   size = lp_build_minify(&bld_int_vec4, size, lod, TRUE);
d1957 2
a1958 3
    * d3d10 requires zero for x/y/z values (but not w, i.e. mip levels)
    * if level is out of bounds (note this can't cover unbound texture
    * here, which also requires returning zero).
d1960 1
a1960 20
   if (explicit_lod && is_sviewinfo) {
      LLVMValueRef last_level, out, out1;
      struct lp_build_context leveli_bld;

      /* everything is scalar for now */
      lp_build_context_init(&leveli_bld, gallivm, lp_type_int_vec(32, 32));
      last_level = dynamic_state->last_level(dynamic_state, gallivm, texture_unit);

      out = lp_build_cmp(&leveli_bld, PIPE_FUNC_LESS, level, first_level);
      out1 = lp_build_cmp(&leveli_bld, PIPE_FUNC_GREATER, level, last_level);
      out = lp_build_or(&leveli_bld, out, out1);
      if (num_lods == 1) {
         out = lp_build_broadcast_scalar(&bld_int_vec4, out);
      }
      else {
         /* TODO */
         assert(0);
      }
      size = lp_build_andnot(&bld_int_vec4, size, out);
   }
d1962 1
a1962 1
      sizes_out[i] = lp_build_extract_broadcast(gallivm, bld_int_vec4.type, int_type,
a1965 5
   if (is_sviewinfo) {
      for (; i < 4; i++) {
         sizes_out[i] = lp_build_const_vec(gallivm, int_type, 0.0);
      }
   }
d1971 1
a1971 1
   if (is_sviewinfo && explicit_lod) {
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d755 4
a758 8
   if (has_layer_coord(bld->static_texture_state->target)) {
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
         /* add cube layer to face */
         z = lp_build_add(&bld->int_coord_bld, coords[2], coords[3]);
      }
      else {
         z = coords[2];
      }
d871 1
a871 2
   seamless_cube_filter = (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
                           bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) &&
d926 4
a929 9
      if (has_layer_coord(bld->static_texture_state->target)) {
         if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
            /* add cube layer to face */
            z00 = z01 = z10 = z11 = z1 =
               lp_build_add(&bld->int_coord_bld, coords[2], coords[3]);
         }
         else {
            z00 = z01 = z10 = z11 = z1 = coords[2];  /* cube face or layer */
         }
a1049 8
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
         /* now can add cube layer to face (per sample) */
         z00 = lp_build_add(ivec_bld, z00, coords[3]);
         z01 = lp_build_add(ivec_bld, z01, coords[3]);
         z10 = lp_build_add(ivec_bld, z10, coords[3]);
         z11 = lp_build_add(ivec_bld, z11, coords[3]);
      }

d1073 4
a1076 13
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
         LLVMValueRef cube_layer = lp_build_add(ivec_bld, face, coords[3]);
         LLVMBuildStore(builder, cube_layer, zs[0]);
         LLVMBuildStore(builder, cube_layer, zs[1]);
         LLVMBuildStore(builder, cube_layer, zs[2]);
         LLVMBuildStore(builder, cube_layer, zs[3]);
      }
      else {
         LLVMBuildStore(builder, face, zs[0]);
         LLVMBuildStore(builder, face, zs[1]);
         LLVMBuildStore(builder, face, zs[2]);
         LLVMBuildStore(builder, face, zs[3]);
      }
a1646 1
                     boolean is_cube_array,
a1657 1
      assert(!is_cube_array);
d1666 1
a1666 3
      LLVMValueRef s = is_cube_array ? lp_build_const_int32(bld->gallivm, 6) :
                                       bld->int_bld.one;
      maxlayer = lp_build_sub(&bld->int_bld, num_layers, s);
d1706 1
a1706 1
   if (target == PIPE_TEXTURE_CUBE || target == PIPE_TEXTURE_CUBE_ARRAY) {
a1713 8
      if (target == PIPE_TEXTURE_CUBE_ARRAY) {
         /* calculate cube layer coord now */
         LLVMValueRef layer = lp_build_iround(&bld->coord_bld, coords[3]);
         LLVMValueRef six = lp_build_const_int_vec(bld->gallivm, bld->int_coord_type, 6);
         layer = lp_build_mul(&bld->int_coord_bld, layer, six);
         coords[3] = lp_build_layer_coord(bld, texture_index, TRUE, layer, NULL);
         /* because of seamless filtering can't add it to face (coords[2]) here. */
      }
d1718 1
a1718 1
      coords[2] = lp_build_layer_coord(bld, texture_index, FALSE, coords[2], NULL);
d1778 14
a1791 4
      first_level = bld->dynamic_state->first_level(bld->dynamic_state,
                                                    bld->gallivm, texture_index);
      first_level = lp_build_broadcast_scalar(&bld->leveli_bld, first_level);
      *ilevel0 = first_level;
d2236 1
a2236 1
         z = lp_build_layer_coord(bld, texture_unit, FALSE, z, &out1);
d2240 1
a2240 1
         z = lp_build_layer_coord(bld, texture_unit, FALSE, z, NULL);
d2476 1
a2476 2
       (static_texture_state->target == PIPE_TEXTURE_CUBE ||
        static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) &&
d2614 1
a2614 2
      if ((static_texture_state->target == PIPE_TEXTURE_CUBE ||
           static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) &&
a2643 7
      if (use_aos && static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) {
         /* The aos path doesn't do seamless filtering so simply add cube layer
          * to face now.
          */
         newcoords[2] = lp_build_add(&bld.int_coord_bld, newcoords[2], newcoords[3]);
      }

d2708 1
a2708 2
             (static_texture_state->target == PIPE_TEXTURE_CUBE ||
              static_texture_state->target == PIPE_TEXTURE_CUBE_ARRAY) &&
a2903 1
   case PIPE_TEXTURE_CUBE_ARRAY:
d2945 3
a2947 12
   if (has_array) {
      LLVMValueRef layers = dynamic_state->depth(dynamic_state, gallivm, texture_unit);
      if (target == PIPE_TEXTURE_CUBE_ARRAY) {
         /*
          * It looks like GL wants number of cubes, d3d10.1 has it undefined?
          * Could avoid this by passing in number of cubes instead of total
          * number of layers (might make things easier elsewhere too).
          */
         LLVMValueRef six = lp_build_const_int32(gallivm, 6);
         layers = LLVMBuildSDiv(gallivm->builder, layers, six, "");
      }
      size = LLVMBuildInsertElement(gallivm->builder, size, layers,
a2948 1
   }
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d755 8
a762 4
   if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
       bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
       bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
      z = coords[2];
d875 2
a876 1
   seamless_cube_filter = bld->static_texture_state->target == PIPE_TEXTURE_CUBE &&
d931 9
a939 4
      if (bld->static_texture_state->target == PIPE_TEXTURE_CUBE ||
          bld->static_texture_state->target == PIPE_TEXTURE_1D_ARRAY ||
          bld->static_texture_state->target == PIPE_TEXTURE_2D_ARRAY) {
         z00 = z01 = z10 = z11 = z1 = coords[2];  /* cube face or layer */
d1060 8
d1091 13
a1103 4
      LLVMBuildStore(builder, face, zs[0]);
      LLVMBuildStore(builder, face, zs[1]);
      LLVMBuildStore(builder, face, zs[2]);
      LLVMBuildStore(builder, face, zs[3]);
d1674 1
d1686 1
d1695 3
a1697 1
      maxlayer = lp_build_sub(&bld->int_bld, num_layers, bld->int_bld.one);
d1737 1
a1737 1
   if (target == PIPE_TEXTURE_CUBE) {
d1745 8
d1757 1
a1757 1
      coords[2] = lp_build_layer_coord(bld, texture_index, coords[2], NULL);
d1817 4
a1820 14
      if (HAVE_LLVM == 0x0207 && target == PIPE_TEXTURE_CUBE) {
         /* XXX this is a work-around for an apparent bug in LLVM 2.7.
          * We should be able to set ilevel0 = const(0) but that causes
          * bad x86 code to be emitted.
          */
         assert(lod_ipart);
         lp_build_nearest_mip_level(bld, texture_index, lod_ipart, ilevel0, NULL);
      }
      else {
         first_level = bld->dynamic_state->first_level(bld->dynamic_state,
                                                       bld->gallivm, texture_index);
         first_level = lp_build_broadcast_scalar(&bld->leveli_bld, first_level);
         *ilevel0 = first_level;
      }
d2265 1
a2265 1
         z = lp_build_layer_coord(bld, texture_unit, z, &out1);
d2269 1
a2269 1
         z = lp_build_layer_coord(bld, texture_unit, z, NULL);
d2505 2
a2506 1
       (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
d2644 2
a2645 1
      if (static_texture_state->target == PIPE_TEXTURE_CUBE &&
d2675 7
d2746 2
a2747 1
             (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
d2943 1
d2985 12
a2996 3
   if (has_array)
      size = LLVMBuildInsertElement(gallivm->builder, size,
                                    dynamic_state->depth(dynamic_state, gallivm, texture_unit),
d2998 1
@


