head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.30;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.07;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.52;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.10;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.17;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "pipe/p_context.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"

#include "id_context.h"
#include "id_objects.h"


static void
identity_destroy(struct pipe_context *_pipe)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->destroy(pipe);

   FREE(id_pipe);
}

static void
identity_draw_vbo(struct pipe_context *_pipe,
                  const struct pipe_draw_info *info)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->draw_vbo(pipe, info);
}

static struct pipe_query *
identity_create_query(struct pipe_context *_pipe,
                      unsigned query_type)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_query(pipe,
                             query_type);
}

static void
identity_destroy_query(struct pipe_context *_pipe,
                       struct pipe_query *query)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->destroy_query(pipe,
                       query);
}

static void
identity_begin_query(struct pipe_context *_pipe,
                     struct pipe_query *query)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->begin_query(pipe,
                     query);
}

static void
identity_end_query(struct pipe_context *_pipe,
                   struct pipe_query *query)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->end_query(pipe,
                   query);
}

static boolean
identity_get_query_result(struct pipe_context *_pipe,
                          struct pipe_query *query,
                          boolean wait,
                          union pipe_query_result *result)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->get_query_result(pipe,
                                 query,
                                 wait,
                                 result);
}

static void *
identity_create_blend_state(struct pipe_context *_pipe,
                            const struct pipe_blend_state *blend)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_blend_state(pipe,
                                   blend);
}

static void
identity_bind_blend_state(struct pipe_context *_pipe,
                          void *blend)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_blend_state(pipe,
                              blend);
}

static void
identity_delete_blend_state(struct pipe_context *_pipe,
                            void *blend)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->delete_blend_state(pipe,
                            blend);
}

static void *
identity_create_sampler_state(struct pipe_context *_pipe,
                              const struct pipe_sampler_state *sampler)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_sampler_state(pipe,
                                     sampler);
}

static void
identity_bind_sampler_states(struct pipe_context *_pipe,
                             unsigned shader,
                             unsigned start,
                             unsigned num_samplers,
                             void **samplers)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_sampler_states(pipe, shader, start, num_samplers, samplers);
}

static void
identity_delete_sampler_state(struct pipe_context *_pipe,
                              void *sampler)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->delete_sampler_state(pipe,
                              sampler);
}

static void *
identity_create_rasterizer_state(struct pipe_context *_pipe,
                                 const struct pipe_rasterizer_state *rasterizer)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_rasterizer_state(pipe,
                                        rasterizer);
}

static void
identity_bind_rasterizer_state(struct pipe_context *_pipe,
                               void *rasterizer)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_rasterizer_state(pipe,
                               rasterizer);
}

static void
identity_delete_rasterizer_state(struct pipe_context *_pipe,
                                 void *rasterizer)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->delete_rasterizer_state(pipe,
                                 rasterizer);
}

static void *
identity_create_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                          const struct pipe_depth_stencil_alpha_state *depth_stencil_alpha)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_depth_stencil_alpha_state(pipe,
                                                 depth_stencil_alpha);
}

static void
identity_bind_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                        void *depth_stencil_alpha)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_depth_stencil_alpha_state(pipe,
                                        depth_stencil_alpha);
}

static void
identity_delete_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                          void *depth_stencil_alpha)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->delete_depth_stencil_alpha_state(pipe,
                                          depth_stencil_alpha);
}

static void *
identity_create_fs_state(struct pipe_context *_pipe,
                         const struct pipe_shader_state *fs)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_fs_state(pipe,
                                fs);
}

static void
identity_bind_fs_state(struct pipe_context *_pipe,
                       void *fs)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_fs_state(pipe,
                       fs);
}

static void
identity_delete_fs_state(struct pipe_context *_pipe,
                         void *fs)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->delete_fs_state(pipe,
                         fs);
}

static void *
identity_create_vs_state(struct pipe_context *_pipe,
                         const struct pipe_shader_state *vs)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_vs_state(pipe,
                                vs);
}

static void
identity_bind_vs_state(struct pipe_context *_pipe,
                       void *vs)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_vs_state(pipe,
                       vs);
}

static void
identity_delete_vs_state(struct pipe_context *_pipe,
                         void *vs)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->delete_vs_state(pipe,
                         vs);
}


static void *
identity_create_vertex_elements_state(struct pipe_context *_pipe,
                                      unsigned num_elements,
                                      const struct pipe_vertex_element *vertex_elements)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_vertex_elements_state(pipe,
                                             num_elements,
                                             vertex_elements);
}

static void
identity_bind_vertex_elements_state(struct pipe_context *_pipe,
                                    void *velems)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_vertex_elements_state(pipe,
                                    velems);
}

static void
identity_delete_vertex_elements_state(struct pipe_context *_pipe,
                                      void *velems)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->delete_vertex_elements_state(pipe,
                                      velems);
}

static void
identity_set_blend_color(struct pipe_context *_pipe,
                         const struct pipe_blend_color *blend_color)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->set_blend_color(pipe,
                         blend_color);
}

static void
identity_set_stencil_ref(struct pipe_context *_pipe,
                         const struct pipe_stencil_ref *stencil_ref)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->set_stencil_ref(pipe,
                         stencil_ref);
}

static void
identity_set_clip_state(struct pipe_context *_pipe,
                        const struct pipe_clip_state *clip)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->set_clip_state(pipe,
                        clip);
}

static void
identity_set_sample_mask(struct pipe_context *_pipe,
                         unsigned sample_mask)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->set_sample_mask(pipe,
                         sample_mask);
}

static void
identity_set_constant_buffer(struct pipe_context *_pipe,
                             uint shader,
                             uint index,
                             struct pipe_constant_buffer *_cb)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_constant_buffer cb;

   /* XXX hmm? unwrap the input state */
   if (_cb) {
      cb = *_cb;
      cb.buffer = identity_resource_unwrap(_cb->buffer);
   }

   pipe->set_constant_buffer(pipe,
                             shader,
                             index,
                             _cb ? &cb : NULL);
}

static void
identity_set_framebuffer_state(struct pipe_context *_pipe,
                               const struct pipe_framebuffer_state *_state)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_framebuffer_state unwrapped_state;
   struct pipe_framebuffer_state *state = NULL;
   unsigned i;

   /* unwrap the input state */
   if (_state) {
      memcpy(&unwrapped_state, _state, sizeof(unwrapped_state));
      for(i = 0; i < _state->nr_cbufs; i++)
         unwrapped_state.cbufs[i] = identity_surface_unwrap(_state->cbufs[i]);
      for (; i < PIPE_MAX_COLOR_BUFS; i++)
         unwrapped_state.cbufs[i] = NULL;
      unwrapped_state.zsbuf = identity_surface_unwrap(_state->zsbuf);
      state = &unwrapped_state;
   }

   pipe->set_framebuffer_state(pipe,
                               state);
}

static void
identity_set_polygon_stipple(struct pipe_context *_pipe,
                             const struct pipe_poly_stipple *poly_stipple)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->set_polygon_stipple(pipe,
                             poly_stipple);
}

static void
identity_set_scissor_states(struct pipe_context *_pipe,
                            unsigned start_slot,
                            unsigned num_scissors,
                            const struct pipe_scissor_state *scissor)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->set_scissor_states(pipe, start_slot, num_scissors, scissor);
}

static void
identity_set_viewport_states(struct pipe_context *_pipe,
                             unsigned start_slot,
                             unsigned num_viewports,
                             const struct pipe_viewport_state *viewport)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->set_viewport_states(pipe, start_slot, num_viewports, viewport);
}

static void
identity_set_sampler_views(struct pipe_context *_pipe,
                           unsigned shader,
                           unsigned start,
                           unsigned num,
                           struct pipe_sampler_view **_views)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
   unsigned i;

   for (i = 0; i < num; i++)
      unwrapped_views[i] = identity_sampler_view_unwrap(_views[i]);

   pipe->set_sampler_views(pipe, shader, start, num, unwrapped_views);
}

static void
identity_set_vertex_buffers(struct pipe_context *_pipe,
                            unsigned start_slot, unsigned num_buffers,
                            const struct pipe_vertex_buffer *_buffers)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_vertex_buffer unwrapped_buffers[PIPE_MAX_SHADER_INPUTS];
   struct pipe_vertex_buffer *buffers = NULL;
   unsigned i;

   if (num_buffers) {
      memcpy(unwrapped_buffers, _buffers, num_buffers * sizeof(*_buffers));
      for (i = 0; i < num_buffers; i++)
         unwrapped_buffers[i].buffer = identity_resource_unwrap(_buffers[i].buffer);
      buffers = unwrapped_buffers;
   }

   pipe->set_vertex_buffers(pipe,
                            start_slot, num_buffers,
                            buffers);
}

static void
identity_set_index_buffer(struct pipe_context *_pipe,
                          const struct pipe_index_buffer *_ib)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_index_buffer unwrapped_ib, *ib = NULL;

   if (_ib) {
      unwrapped_ib = *_ib;
      unwrapped_ib.buffer = identity_resource_unwrap(_ib->buffer);
      ib = &unwrapped_ib;
   }

   pipe->set_index_buffer(pipe, ib);
}

static void
identity_resource_copy_region(struct pipe_context *_pipe,
                              struct pipe_resource *_dst,
                              unsigned dst_level,
                              unsigned dstx,
                              unsigned dsty,
                              unsigned dstz,
                              struct pipe_resource *_src,
                              unsigned src_level,
                              const struct pipe_box *src_box)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_resource *id_resource_dst = identity_resource(_dst);
   struct identity_resource *id_resource_src = identity_resource(_src);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_resource *dst = id_resource_dst->resource;
   struct pipe_resource *src = id_resource_src->resource;

   pipe->resource_copy_region(pipe,
                              dst,
                              dst_level,
                              dstx,
                              dsty,
                              dstz,
                              src,
                              src_level,
                              src_box);
}

static void
identity_blit(struct pipe_context *_pipe,
              const struct pipe_blit_info *info)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_blit_info blit = *info;

   blit.src.resource = identity_resource(blit.src.resource)->resource;
   blit.dst.resource = identity_resource(blit.dst.resource)->resource;

   pipe->blit(pipe, &blit);
}

static void
identity_flush_resource(struct pipe_context *_pipe,
                        struct pipe_resource *resource)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->flush_resource(pipe, resource);
}

static void
identity_clear(struct pipe_context *_pipe,
               unsigned buffers,
               const union pipe_color_union *color,
               double depth,
               unsigned stencil)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->clear(pipe,
               buffers,
               color,
               depth,
               stencil);
}

static void
identity_clear_render_target(struct pipe_context *_pipe,
                             struct pipe_surface *_dst,
                             const union pipe_color_union *color,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_surface *id_surface_dst = identity_surface(_dst);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_surface *dst = id_surface_dst->surface;

   pipe->clear_render_target(pipe,
                             dst,
                             color,
                             dstx,
                             dsty,
                             width,
                             height);
}
static void
identity_clear_depth_stencil(struct pipe_context *_pipe,
                             struct pipe_surface *_dst,
                             unsigned clear_flags,
                             double depth,
                             unsigned stencil,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_surface *id_surface_dst = identity_surface(_dst);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_surface *dst = id_surface_dst->surface;

   pipe->clear_depth_stencil(pipe,
                             dst,
                             clear_flags,
                             depth,
                             stencil,
                             dstx,
                             dsty,
                             width,
                             height);

}

static void
identity_flush(struct pipe_context *_pipe,
               struct pipe_fence_handle **fence,
               unsigned flags)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->flush(pipe, fence, flags);
}

static struct pipe_sampler_view *
identity_context_create_sampler_view(struct pipe_context *_pipe,
                                     struct pipe_resource *_resource,
                                     const struct pipe_sampler_view *templ)
{
   struct identity_context *id_context = identity_context(_pipe);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *pipe = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;
   struct pipe_sampler_view *result;

   result = pipe->create_sampler_view(pipe,
                                      resource,
                                      templ);

   if (result)
      return identity_sampler_view_create(id_context, id_resource, result);
   return NULL;
}

static void
identity_context_sampler_view_destroy(struct pipe_context *_pipe,
                                      struct pipe_sampler_view *_view)
{
   identity_sampler_view_destroy(identity_context(_pipe),
                                 identity_sampler_view(_view));
}

static struct pipe_surface *
identity_context_create_surface(struct pipe_context *_pipe,
                                struct pipe_resource *_resource,
                                const struct pipe_surface *templ)
{
   struct identity_context *id_context = identity_context(_pipe);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *pipe = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;
   struct pipe_surface *result;

   result = pipe->create_surface(pipe,
                                 resource,
                                 templ);

   if (result)
      return identity_surface_create(id_context, id_resource, result);
   return NULL;
}

static void
identity_context_surface_destroy(struct pipe_context *_pipe,
                                 struct pipe_surface *_surf)
{
   identity_surface_destroy(identity_context(_pipe),
                            identity_surface(_surf));
}

static void *
identity_context_transfer_map(struct pipe_context *_context,
                              struct pipe_resource *_resource,
                              unsigned level,
                              unsigned usage,
                              const struct pipe_box *box,
                              struct pipe_transfer **transfer)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *context = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;
   struct pipe_transfer *result;
   void *map;

   map = context->transfer_map(context,
                               resource,
                               level,
                               usage,
                               box, &result);

   if (!map)
      return NULL;

   *transfer = identity_transfer_map(id_context, id_resource, result);
   return *transfer ? map : NULL;
}

static void
identity_context_transfer_flush_region(struct pipe_context *_context,
                                       struct pipe_transfer *_transfer,
                                       const struct pipe_box *box)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_transfer *id_transfer = identity_transfer(_transfer);
   struct pipe_context *context = id_context->pipe;
   struct pipe_transfer *transfer = id_transfer->transfer;

   context->transfer_flush_region(context,
                                  transfer,
                                  box);
}


static void
identity_context_transfer_unmap(struct pipe_context *_context,
                                struct pipe_transfer *_transfer)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_transfer *id_transfer = identity_transfer(_transfer);
   struct pipe_context *context = id_context->pipe;
   struct pipe_transfer *transfer = id_transfer->transfer;

   context->transfer_unmap(context,
                           transfer);

   identity_transfer_destroy(identity_context(_context),
                             identity_transfer(_transfer));
}


static void 
identity_context_transfer_inline_write(struct pipe_context *_context,
                                       struct pipe_resource *_resource,
                                       unsigned level,
                                       unsigned usage,
                                       const struct pipe_box *box,
                                       const void *data,
                                       unsigned stride,
                                       unsigned layer_stride)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *context = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;

   context->transfer_inline_write(context,
                                  resource,
                                  level,
                                  usage,
                                  box,
                                  data,
                                  stride,
                                  layer_stride);
}


struct pipe_context *
identity_context_create(struct pipe_screen *_screen, struct pipe_context *pipe)
{
   struct identity_context *id_pipe;
   (void)identity_screen(_screen);

   id_pipe = CALLOC_STRUCT(identity_context);
   if (!id_pipe) {
      return NULL;
   }

   id_pipe->base.screen = _screen;
   id_pipe->base.priv = pipe->priv; /* expose wrapped data */
   id_pipe->base.draw = NULL;

   id_pipe->base.destroy = identity_destroy;
   id_pipe->base.draw_vbo = identity_draw_vbo;
   id_pipe->base.create_query = identity_create_query;
   id_pipe->base.destroy_query = identity_destroy_query;
   id_pipe->base.begin_query = identity_begin_query;
   id_pipe->base.end_query = identity_end_query;
   id_pipe->base.get_query_result = identity_get_query_result;
   id_pipe->base.create_blend_state = identity_create_blend_state;
   id_pipe->base.bind_blend_state = identity_bind_blend_state;
   id_pipe->base.delete_blend_state = identity_delete_blend_state;
   id_pipe->base.create_sampler_state = identity_create_sampler_state;
   id_pipe->base.bind_sampler_states = identity_bind_sampler_states;
   id_pipe->base.delete_sampler_state = identity_delete_sampler_state;
   id_pipe->base.create_rasterizer_state = identity_create_rasterizer_state;
   id_pipe->base.bind_rasterizer_state = identity_bind_rasterizer_state;
   id_pipe->base.delete_rasterizer_state = identity_delete_rasterizer_state;
   id_pipe->base.create_depth_stencil_alpha_state = identity_create_depth_stencil_alpha_state;
   id_pipe->base.bind_depth_stencil_alpha_state = identity_bind_depth_stencil_alpha_state;
   id_pipe->base.delete_depth_stencil_alpha_state = identity_delete_depth_stencil_alpha_state;
   id_pipe->base.create_fs_state = identity_create_fs_state;
   id_pipe->base.bind_fs_state = identity_bind_fs_state;
   id_pipe->base.delete_fs_state = identity_delete_fs_state;
   id_pipe->base.create_vs_state = identity_create_vs_state;
   id_pipe->base.bind_vs_state = identity_bind_vs_state;
   id_pipe->base.delete_vs_state = identity_delete_vs_state;
   id_pipe->base.create_vertex_elements_state = identity_create_vertex_elements_state;
   id_pipe->base.bind_vertex_elements_state = identity_bind_vertex_elements_state;
   id_pipe->base.delete_vertex_elements_state = identity_delete_vertex_elements_state;
   id_pipe->base.set_blend_color = identity_set_blend_color;
   id_pipe->base.set_stencil_ref = identity_set_stencil_ref;
   id_pipe->base.set_clip_state = identity_set_clip_state;
   id_pipe->base.set_sample_mask = identity_set_sample_mask;
   id_pipe->base.set_constant_buffer = identity_set_constant_buffer;
   id_pipe->base.set_framebuffer_state = identity_set_framebuffer_state;
   id_pipe->base.set_polygon_stipple = identity_set_polygon_stipple;
   id_pipe->base.set_scissor_states = identity_set_scissor_states;
   id_pipe->base.set_viewport_states = identity_set_viewport_states;
   id_pipe->base.set_sampler_views = identity_set_sampler_views;
   id_pipe->base.set_vertex_buffers = identity_set_vertex_buffers;
   id_pipe->base.set_index_buffer = identity_set_index_buffer;
   id_pipe->base.resource_copy_region = identity_resource_copy_region;
   id_pipe->base.clear = identity_clear;
   id_pipe->base.clear_render_target = identity_clear_render_target;
   id_pipe->base.clear_depth_stencil = identity_clear_depth_stencil;
   id_pipe->base.flush = identity_flush;
   id_pipe->base.create_surface = identity_context_create_surface;
   id_pipe->base.surface_destroy = identity_context_surface_destroy;
   id_pipe->base.create_sampler_view = identity_context_create_sampler_view;
   id_pipe->base.sampler_view_destroy = identity_context_sampler_view_destroy;
   id_pipe->base.transfer_map = identity_context_transfer_map;
   id_pipe->base.transfer_unmap = identity_context_transfer_unmap;
   id_pipe->base.transfer_flush_region = identity_context_transfer_flush_region;
   id_pipe->base.transfer_inline_write = identity_context_transfer_inline_write;
   id_pipe->base.blit = identity_blit;
   id_pipe->base.flush_resource = identity_flush_resource;

   id_pipe->pipe = pipe;

   return &id_pipe->base;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d60 1
a60 2
                      unsigned query_type,
                      unsigned index)
d66 1
a66 2
                             query_type,
                             index);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d60 2
a61 1
                      unsigned query_type)
d67 2
a68 1
                             query_type);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d171 1
a171 34
   /* remove this when we have pipe->bind_sampler_states(..., start, ...) */
   assert(start == 0);

   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->bind_vertex_sampler_states(pipe, num_samplers, samplers);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->bind_geometry_sampler_states(pipe, num_samplers, samplers);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->bind_fragment_sampler_states(pipe, num_samplers, samplers);
      break;
   default:
      debug_error("Unexpected shader in identity_bind_sampler_states()");
   }
}

static void
identity_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                      unsigned num_samplers,
                                      void **samplers)
{
   identity_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
                                0, num_samplers, samplers);
}

static void
identity_bind_vertex_sampler_states(struct pipe_context *_pipe,
                                    unsigned num_samplers,
                                    void **samplers)
{
   identity_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
                                0, num_samplers, samplers);
d488 1
a488 2
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SAMPLERS];
   struct pipe_sampler_view **views = NULL;
d491 2
a492 2
   /* remove this when we have pipe->set_sampler_views(..., start, ...) */
   assert(start == 0);
d494 1
a494 38
   if (_views) {
      for (i = 0; i < num; i++)
         unwrapped_views[i] = identity_sampler_view_unwrap(_views[i]);
      for (; i < PIPE_MAX_SAMPLERS; i++)
         unwrapped_views[i] = NULL;

      views = unwrapped_views;
   }

   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->set_vertex_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->set_geometry_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->set_fragment_sampler_views(pipe, num, views);
      break;
   default:
      debug_error("Unexpected shader in identity_set_sampler_views()");
   }
}

static void
identity_set_fragment_sampler_views(struct pipe_context *_pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **_views)
{
   identity_set_sampler_views(_pipe, PIPE_SHADER_FRAGMENT, 0, num, _views);
}

static void
identity_set_vertex_sampler_views(struct pipe_context *_pipe,
                                  unsigned num,
                                  struct pipe_sampler_view **_views)
{
   identity_set_sampler_views(_pipe, PIPE_SHADER_VERTEX, 0, num, _views);
d581 10
d833 1
a833 2
   id_pipe->base.bind_fragment_sampler_states = identity_bind_fragment_sampler_states;
   id_pipe->base.bind_vertex_sampler_states = identity_bind_vertex_sampler_states;
d859 1
a859 2
   id_pipe->base.set_fragment_sampler_views = identity_set_fragment_sampler_views;
   id_pipe->base.set_vertex_sampler_views = identity_set_vertex_sampler_views;
d876 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d106 1
a106 1
                          void *result)
d162 28
d194 2
a195 6
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_fragment_sampler_states(pipe,
                                      num_samplers,
                                      samplers);
d203 2
a204 6
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_vertex_sampler_states(pipe,
                                    num_samplers,
                                    samplers);
d434 1
a434 1
                             struct pipe_resource *_resource)
d438 1
a438 2
   struct pipe_resource *unwrapped_resource;
   struct pipe_resource *resource = NULL;
d441 3
a443 3
   if (_resource) {
      unwrapped_resource = identity_resource_unwrap(_resource);
      resource = unwrapped_resource;
d449 1
a449 1
                             resource);
d489 4
a492 2
identity_set_scissor_state(struct pipe_context *_pipe,
                           const struct pipe_scissor_state *scissor)
d497 1
a497 2
   pipe->set_scissor_state(pipe,
                           scissor);
d501 4
a504 2
identity_set_viewport_state(struct pipe_context *_pipe,
                            const struct pipe_viewport_state *viewport)
d509 1
a509 2
   pipe->set_viewport_state(pipe,
                            viewport);
d513 5
a517 3
identity_set_fragment_sampler_views(struct pipe_context *_pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **_views)
d525 3
d537 21
a557 1
   pipe->set_fragment_sampler_views(pipe, num, views);
d565 1
a565 16
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_VERTEX_SAMPLERS];
   struct pipe_sampler_view **views = NULL;
   unsigned i;

   if (_views) {
      for (i = 0; i < num; i++)
         unwrapped_views[i] = identity_sampler_view_unwrap(_views[i]);
      for (; i < PIPE_MAX_VERTEX_SAMPLERS; i++)
         unwrapped_views[i] = NULL;

      views = unwrapped_views;
   }

   pipe->set_vertex_sampler_views(pipe, num, views);
d570 1
a570 1
                            unsigned num_buffers,
d587 1
a587 1
                            num_buffers,
d638 14
d654 1
a654 1
               const float *rgba,
d663 1
a663 1
               rgba,
d671 1
a671 1
                             const float *rgba,
d682 1
a682 1
                             rgba,
d716 2
a717 1
               struct pipe_fence_handle **fence)
d722 1
a722 2
   pipe->flush(pipe,
               fence);
d781 2
a782 2
static struct pipe_transfer *
identity_context_get_transfer(struct pipe_context *_context,
d786 2
a787 1
                              const struct pipe_box *box)
d794 1
d796 5
a800 5
   result = context->get_transfer(context,
                                  resource,
                                  level,
                                  usage,
                                  box);
d802 2
a803 4
   if (result)
      return identity_transfer_create(id_context, id_resource, result);
   return NULL;
}
d805 2
a806 6
static void
identity_context_transfer_destroy(struct pipe_context *_pipe,
                                  struct pipe_transfer *_transfer)
{
   identity_transfer_destroy(identity_context(_pipe),
                             identity_transfer(_transfer));
a808 15
static void *
identity_context_transfer_map(struct pipe_context *_context,
                              struct pipe_transfer *_transfer)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_transfer *id_transfer = identity_transfer(_transfer);
   struct pipe_context *context = id_context->pipe;
   struct pipe_transfer *transfer = id_transfer->transfer;

   return context->transfer_map(context,
                                transfer);
}



d836 3
a867 13
static void identity_redefine_user_buffer(struct pipe_context *_context,
                                          struct pipe_resource *_resource,
                                          unsigned offset, unsigned size)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *context = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;

   context->redefine_user_buffer(context, resource, offset, size);
}


a878 1
   id_pipe->base.winsys = NULL;
d919 2
a920 2
   id_pipe->base.set_scissor_state = identity_set_scissor_state;
   id_pipe->base.set_viewport_state = identity_set_viewport_state;
a933 2
   id_pipe->base.get_transfer = identity_context_get_transfer;
   id_pipe->base.transfer_destroy = identity_context_transfer_destroy;
d938 1
a938 1
   id_pipe->base.redefine_user_buffer = identity_redefine_user_buffer;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a670 1
               unsigned flags,
a676 1
               flags,
a679 17
static unsigned int
identity_is_resource_referenced(struct pipe_context *_pipe,
                                struct pipe_resource *_resource,
                                unsigned level,
                                int layer)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_resource *resource = id_resource->resource;

   return pipe->is_resource_referenced(pipe,
                                       resource,
                                       level,
                                       layer);
}

d839 13
a914 1
   id_pipe->base.is_resource_referenced = identity_is_resource_referenced;
d925 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
d45 1
a45 1
   free(id_pipe);
d49 2
a50 4
identity_draw_arrays(struct pipe_context *_pipe,
                     unsigned prim,
                     unsigned start,
                     unsigned count)
d55 1
a55 50
   pipe->draw_arrays(pipe,
                     prim,
                     start,
                     count);
}

static void
identity_draw_elements(struct pipe_context *_pipe,
                       struct pipe_buffer *_indexBuffer,
                       unsigned indexSize,
                       unsigned prim,
                       unsigned start,
                       unsigned count)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_buffer *id_buffer = identity_buffer(_indexBuffer);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_buffer *indexBuffer = id_buffer->buffer;

   pipe->draw_elements(pipe,
                       indexBuffer,
                       indexSize,
                       prim,
                       start,
                       count);
}

static void
identity_draw_range_elements(struct pipe_context *_pipe,
                             struct pipe_buffer *_indexBuffer,
                             unsigned indexSize,
                             unsigned minIndex,
                             unsigned maxIndex,
                             unsigned mode,
                             unsigned start,
                             unsigned count)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_buffer *id_buffer = identity_buffer(_indexBuffer);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_buffer *indexBuffer = id_buffer->buffer;

   pipe->draw_range_elements(pipe,
                             indexBuffer,
                             indexSize,
                             minIndex,
                             maxIndex,
                             mode,
                             start,
                             count);
d106 1
a106 1
                          uint64_t *result)
d330 36
d400 11
d414 1
a414 1
                             struct pipe_buffer *_buffer)
d418 2
a419 2
   struct pipe_buffer *unwrapped_buffer;
   struct pipe_buffer *buffer = NULL;
d422 3
a424 3
   if (_buffer) {
      unwrapped_buffer = identity_buffer_unwrap(_buffer);
      buffer = unwrapped_buffer;
d430 1
a430 1
                             buffer);
d492 3
a494 3
identity_set_fragment_sampler_textures(struct pipe_context *_pipe,
                                       unsigned num_textures,
                                       struct pipe_texture **_textures)
d498 2
a499 2
   struct pipe_texture *unwrapped_textures[PIPE_MAX_SAMPLERS];
   struct pipe_texture **textures = NULL;
d502 3
a504 3
   if (_textures) {
      for (i = 0; i < num_textures; i++)
         unwrapped_textures[i] = identity_texture_unwrap(_textures[i]);
d506 1
a506 1
         unwrapped_textures[i] = NULL;
d508 1
a508 1
      textures = unwrapped_textures;
d511 1
a511 3
   pipe->set_fragment_sampler_textures(pipe,
                                       num_textures,
                                       textures);
d515 3
a517 3
identity_set_vertex_sampler_textures(struct pipe_context *_pipe,
                                     unsigned num_textures,
                                     struct pipe_texture **_textures)
d521 2
a522 2
   struct pipe_texture *unwrapped_textures[PIPE_MAX_VERTEX_SAMPLERS];
   struct pipe_texture **textures = NULL;
d525 3
a527 3
   if (_textures) {
      for (i = 0; i < num_textures; i++)
         unwrapped_textures[i] = identity_texture_unwrap(_textures[i]);
d529 1
a529 1
         unwrapped_textures[i] = NULL;
d531 1
a531 1
      textures = unwrapped_textures;
d534 1
a534 3
   pipe->set_vertex_sampler_textures(pipe,
                                     num_textures,
                                     textures);
d551 1
a551 1
         unwrapped_buffers[i].buffer = identity_buffer_unwrap(_buffers[i].buffer);
d561 2
a562 3
identity_set_vertex_elements(struct pipe_context *_pipe,
                             unsigned num_elements,
                             const struct pipe_vertex_element *vertex_elements)
d566 1
d568 5
a572 4
   pipe->set_vertex_elements(pipe,
                             num_elements,
                             vertex_elements);
}
d574 1
a574 27
static void
identity_surface_copy(struct pipe_context *_pipe,
                      struct pipe_surface *_dst,
                      unsigned dstx,
                      unsigned dsty,
                      struct pipe_surface *_src,
                      unsigned srcx,
                      unsigned srcy,
                      unsigned width,
                      unsigned height)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_surface *id_surface_dst = identity_surface(_dst);
   struct identity_surface *id_surface_src = identity_surface(_src);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_surface *dst = id_surface_dst->surface;
   struct pipe_surface *src = id_surface_src->surface;

   pipe->surface_copy(pipe,
                      dst,
                      dstx,
                      dsty,
                      src,
                      srcx,
                      srcy,
                      width,
                      height);
d578 26
a603 20
identity_surface_fill(struct pipe_context *_pipe,
                      struct pipe_surface *_dst,
                      unsigned dstx,
                      unsigned dsty,
                      unsigned width,
                      unsigned height,
                      unsigned value)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_surface *id_surface_dst = identity_surface(_dst);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_surface *dst = id_surface_dst->surface;

   pipe->surface_fill(pipe,
                      dst,
                      dstx,
                      dsty,
                      width,
                      height,
                      value);
d624 46
d683 4
a686 4
identity_is_texture_referenced(struct pipe_context *_pipe,
                               struct pipe_texture *_texture,
                               unsigned face,
                               unsigned level)
d689 1
a689 1
   struct identity_texture *id_texture = identity_texture(_texture);
d691 104
a794 1
   struct pipe_texture *texture = id_texture->texture;
d796 2
a797 4
   return pipe->is_texture_referenced(pipe,
                                      texture,
                                      face,
                                      level);
d800 41
a840 3
static unsigned int
identity_is_buffer_referenced(struct pipe_context *_pipe,
                              struct pipe_buffer *_buffer)
d842 4
a845 4
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_buffer *id_buffer = identity_buffer(_buffer);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_buffer *buffer = id_buffer->buffer;
d847 8
a854 2
   return pipe->is_buffer_referenced(pipe,
                                     buffer);
d857 1
d875 1
a875 3
   id_pipe->base.draw_arrays = identity_draw_arrays;
   id_pipe->base.draw_elements = identity_draw_elements;
   id_pipe->base.draw_range_elements = identity_draw_range_elements;
d900 3
d906 1
d912 2
a913 2
   id_pipe->base.set_fragment_sampler_textures = identity_set_fragment_sampler_textures;
   id_pipe->base.set_vertex_sampler_textures = identity_set_vertex_sampler_textures;
d915 2
a916 3
   id_pipe->base.set_vertex_elements = identity_set_vertex_elements;
   id_pipe->base.surface_copy = identity_surface_copy;
   id_pipe->base.surface_fill = identity_surface_fill;
d918 2
d921 11
a931 2
   id_pipe->base.is_texture_referenced = identity_is_texture_referenced;
   id_pipe->base.is_buffer_referenced = identity_is_buffer_referenced;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a30 1
#include "util/u_inlines.h"
d44 1
a44 1
   FREE(id_pipe);
d48 4
a51 2
identity_draw_vbo(struct pipe_context *_pipe,
                  const struct pipe_draw_info *info)
d56 50
a105 1
   pipe->draw_vbo(pipe, info);
d156 1
a156 1
                          void *result)
a379 36

static void *
identity_create_vertex_elements_state(struct pipe_context *_pipe,
                                      unsigned num_elements,
                                      const struct pipe_vertex_element *vertex_elements)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   return pipe->create_vertex_elements_state(pipe,
                                             num_elements,
                                             vertex_elements);
}

static void
identity_bind_vertex_elements_state(struct pipe_context *_pipe,
                                    void *velems)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->bind_vertex_elements_state(pipe,
                                    velems);
}

static void
identity_delete_vertex_elements_state(struct pipe_context *_pipe,
                                      void *velems)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->delete_vertex_elements_state(pipe,
                                      velems);
}

a413 11
identity_set_sample_mask(struct pipe_context *_pipe,
                         unsigned sample_mask)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->set_sample_mask(pipe,
                         sample_mask);
}

static void
d417 1
a417 1
                             struct pipe_resource *_resource)
d421 2
a422 2
   struct pipe_resource *unwrapped_resource;
   struct pipe_resource *resource = NULL;
d425 3
a427 3
   if (_resource) {
      unwrapped_resource = identity_resource_unwrap(_resource);
      resource = unwrapped_resource;
d433 1
a433 1
                             resource);
d495 3
a497 3
identity_set_fragment_sampler_views(struct pipe_context *_pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **_views)
d501 2
a502 2
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SAMPLERS];
   struct pipe_sampler_view **views = NULL;
d505 3
a507 3
   if (_views) {
      for (i = 0; i < num; i++)
         unwrapped_views[i] = identity_sampler_view_unwrap(_views[i]);
d509 1
a509 1
         unwrapped_views[i] = NULL;
d511 1
a511 1
      views = unwrapped_views;
d514 3
a516 1
   pipe->set_fragment_sampler_views(pipe, num, views);
d520 3
a522 3
identity_set_vertex_sampler_views(struct pipe_context *_pipe,
                                  unsigned num,
                                  struct pipe_sampler_view **_views)
d526 2
a527 2
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_VERTEX_SAMPLERS];
   struct pipe_sampler_view **views = NULL;
d530 3
a532 3
   if (_views) {
      for (i = 0; i < num; i++)
         unwrapped_views[i] = identity_sampler_view_unwrap(_views[i]);
d534 1
a534 1
         unwrapped_views[i] = NULL;
d536 1
a536 1
      views = unwrapped_views;
d539 3
a541 1
   pipe->set_vertex_sampler_views(pipe, num, views);
d558 1
a558 1
         unwrapped_buffers[i].buffer = identity_resource_unwrap(_buffers[i].buffer);
d568 3
a570 2
identity_set_index_buffer(struct pipe_context *_pipe,
                          const struct pipe_index_buffer *_ib)
a573 1
   struct pipe_index_buffer unwrapped_ib, *ib = NULL;
d575 22
a596 5
   if (_ib) {
      unwrapped_ib = *_ib;
      unwrapped_ib.buffer = identity_resource_unwrap(_ib->buffer);
      ib = &unwrapped_ib;
   }
d598 9
a606 1
   pipe->set_index_buffer(pipe, ib);
d610 20
a629 26
identity_resource_copy_region(struct pipe_context *_pipe,
                              struct pipe_resource *_dst,
                              unsigned dst_level,
                              unsigned dstx,
                              unsigned dsty,
                              unsigned dstz,
                              struct pipe_resource *_src,
                              unsigned src_level,
                              const struct pipe_box *src_box)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_resource *id_resource_dst = identity_resource(_dst);
   struct identity_resource *id_resource_src = identity_resource(_src);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_resource *dst = id_resource_dst->resource;
   struct pipe_resource *src = id_resource_src->resource;

   pipe->resource_copy_region(pipe,
                              dst,
                              dst_level,
                              dstx,
                              dsty,
                              dstz,
                              src,
                              src_level,
                              src_box);
a649 46
identity_clear_render_target(struct pipe_context *_pipe,
                             struct pipe_surface *_dst,
                             const float *rgba,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_surface *id_surface_dst = identity_surface(_dst);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_surface *dst = id_surface_dst->surface;

   pipe->clear_render_target(pipe,
                             dst,
                             rgba,
                             dstx,
                             dsty,
                             width,
                             height);
}
static void
identity_clear_depth_stencil(struct pipe_context *_pipe,
                             struct pipe_surface *_dst,
                             unsigned clear_flags,
                             double depth,
                             unsigned stencil,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct identity_surface *id_surface_dst = identity_surface(_dst);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_surface *dst = id_surface_dst->surface;

   pipe->clear_depth_stencil(pipe,
                             dst,
                             clear_flags,
                             depth,
                             stencil,
                             dstx,
                             dsty,
                             width,
                             height);

}

static void
d663 4
a666 4
identity_is_resource_referenced(struct pipe_context *_pipe,
                                struct pipe_resource *_resource,
                                unsigned level,
                                int layer)
d669 1
a669 1
   struct identity_resource *id_resource = identity_resource(_resource);
d671 1
a671 1
   struct pipe_resource *resource = id_resource->resource;
d673 4
a676 4
   return pipe->is_resource_referenced(pipe,
                                       resource,
                                       level,
                                       layer);
d679 3
a681 4
static struct pipe_sampler_view *
identity_context_create_sampler_view(struct pipe_context *_pipe,
                                     struct pipe_resource *_resource,
                                     const struct pipe_sampler_view *templ)
d683 4
a686 50
   struct identity_context *id_context = identity_context(_pipe);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *pipe = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;
   struct pipe_sampler_view *result;

   result = pipe->create_sampler_view(pipe,
                                      resource,
                                      templ);

   if (result)
      return identity_sampler_view_create(id_context, id_resource, result);
   return NULL;
}

static void
identity_context_sampler_view_destroy(struct pipe_context *_pipe,
                                      struct pipe_sampler_view *_view)
{
   identity_sampler_view_destroy(identity_context(_pipe),
                                 identity_sampler_view(_view));
}

static struct pipe_surface *
identity_context_create_surface(struct pipe_context *_pipe,
                                struct pipe_resource *_resource,
                                const struct pipe_surface *templ)
{
   struct identity_context *id_context = identity_context(_pipe);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *pipe = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;
   struct pipe_surface *result;

   result = pipe->create_surface(pipe,
                                 resource,
                                 templ);

   if (result)
      return identity_surface_create(id_context, id_resource, result);
   return NULL;
}

static void
identity_context_surface_destroy(struct pipe_context *_pipe,
                                 struct pipe_surface *_surf)
{
   identity_surface_destroy(identity_context(_pipe),
                            identity_surface(_surf));
}
d688 2
a689 43
static struct pipe_transfer *
identity_context_get_transfer(struct pipe_context *_context,
                              struct pipe_resource *_resource,
                              unsigned level,
                              unsigned usage,
                              const struct pipe_box *box)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *context = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;
   struct pipe_transfer *result;

   result = context->get_transfer(context,
                                  resource,
                                  level,
                                  usage,
                                  box);

   if (result)
      return identity_transfer_create(id_context, id_resource, result);
   return NULL;
}

static void
identity_context_transfer_destroy(struct pipe_context *_pipe,
                                  struct pipe_transfer *_transfer)
{
   identity_transfer_destroy(identity_context(_pipe),
                             identity_transfer(_transfer));
}

static void *
identity_context_transfer_map(struct pipe_context *_context,
                              struct pipe_transfer *_transfer)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_transfer *id_transfer = identity_transfer(_transfer);
   struct pipe_context *context = id_context->pipe;
   struct pipe_transfer *transfer = id_transfer->transfer;

   return context->transfer_map(context,
                                transfer);
a691 58


static void
identity_context_transfer_flush_region(struct pipe_context *_context,
                                       struct pipe_transfer *_transfer,
                                       const struct pipe_box *box)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_transfer *id_transfer = identity_transfer(_transfer);
   struct pipe_context *context = id_context->pipe;
   struct pipe_transfer *transfer = id_transfer->transfer;

   context->transfer_flush_region(context,
                                  transfer,
                                  box);
}


static void
identity_context_transfer_unmap(struct pipe_context *_context,
                                struct pipe_transfer *_transfer)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_transfer *id_transfer = identity_transfer(_transfer);
   struct pipe_context *context = id_context->pipe;
   struct pipe_transfer *transfer = id_transfer->transfer;

   context->transfer_unmap(context,
                           transfer);
}


static void 
identity_context_transfer_inline_write(struct pipe_context *_context,
                                       struct pipe_resource *_resource,
                                       unsigned level,
                                       unsigned usage,
                                       const struct pipe_box *box,
                                       const void *data,
                                       unsigned stride,
                                       unsigned layer_stride)
{
   struct identity_context *id_context = identity_context(_context);
   struct identity_resource *id_resource = identity_resource(_resource);
   struct pipe_context *context = id_context->pipe;
   struct pipe_resource *resource = id_resource->resource;

   context->transfer_inline_write(context,
                                  resource,
                                  level,
                                  usage,
                                  box,
                                  data,
                                  stride,
                                  layer_stride);
}


d709 3
a711 1
   id_pipe->base.draw_vbo = identity_draw_vbo;
a735 3
   id_pipe->base.create_vertex_elements_state = identity_create_vertex_elements_state;
   id_pipe->base.bind_vertex_elements_state = identity_bind_vertex_elements_state;
   id_pipe->base.delete_vertex_elements_state = identity_delete_vertex_elements_state;
a738 1
   id_pipe->base.set_sample_mask = identity_set_sample_mask;
d744 2
a745 2
   id_pipe->base.set_fragment_sampler_views = identity_set_fragment_sampler_views;
   id_pipe->base.set_vertex_sampler_views = identity_set_vertex_sampler_views;
d747 3
a749 2
   id_pipe->base.set_index_buffer = identity_set_index_buffer;
   id_pipe->base.resource_copy_region = identity_resource_copy_region;
a750 2
   id_pipe->base.clear_render_target = identity_clear_render_target;
   id_pipe->base.clear_depth_stencil = identity_clear_depth_stencil;
d752 2
a753 11
   id_pipe->base.is_resource_referenced = identity_is_resource_referenced;
   id_pipe->base.create_surface = identity_context_create_surface;
   id_pipe->base.surface_destroy = identity_context_surface_destroy;
   id_pipe->base.create_sampler_view = identity_context_create_sampler_view;
   id_pipe->base.sampler_view_destroy = identity_context_sampler_view_destroy;
   id_pipe->base.get_transfer = identity_context_get_transfer;
   id_pipe->base.transfer_destroy = identity_context_transfer_destroy;
   id_pipe->base.transfer_map = identity_context_transfer_map;
   id_pipe->base.transfer_unmap = identity_context_transfer_unmap;
   id_pipe->base.transfer_flush_region = identity_context_transfer_flush_region;
   id_pipe->base.transfer_inline_write = identity_context_transfer_inline_write;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d106 1
a106 1
                          union pipe_query_result *result)
d162 3
a164 5
identity_bind_sampler_states(struct pipe_context *_pipe,
                             unsigned shader,
                             unsigned start,
                             unsigned num_samplers,
                             void **samplers)
d169 3
a171 25
   /* remove this when we have pipe->bind_sampler_states(..., start, ...) */
   assert(start == 0);

   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->bind_vertex_sampler_states(pipe, num_samplers, samplers);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->bind_geometry_sampler_states(pipe, num_samplers, samplers);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->bind_fragment_sampler_states(pipe, num_samplers, samplers);
      break;
   default:
      debug_error("Unexpected shader in identity_bind_sampler_states()");
   }
}

static void
identity_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                      unsigned num_samplers,
                                      void **samplers)
{
   identity_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
                                0, num_samplers, samplers);
d179 6
a184 2
   identity_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
                                0, num_samplers, samplers);
d414 1
a414 1
                             struct pipe_constant_buffer *_cb)
d418 2
a419 1
   struct pipe_constant_buffer cb;
d422 3
a424 3
   if (_cb) {
      cb = *_cb;
      cb.buffer = identity_resource_unwrap(_cb->buffer);
d430 1
a430 1
                             _cb ? &cb : NULL);
d470 2
a471 4
identity_set_scissor_states(struct pipe_context *_pipe,
                            unsigned start_slot,
                            unsigned num_scissors,
                            const struct pipe_scissor_state *scissor)
d476 2
a477 1
   pipe->set_scissor_states(pipe, start_slot, num_scissors, scissor);
d481 2
a482 4
identity_set_viewport_states(struct pipe_context *_pipe,
                             unsigned start_slot,
                             unsigned num_viewports,
                             const struct pipe_viewport_state *viewport)
d487 2
a488 1
   pipe->set_viewport_states(pipe, start_slot, num_viewports, viewport);
d492 3
a494 5
identity_set_sampler_views(struct pipe_context *_pipe,
                           unsigned shader,
                           unsigned start,
                           unsigned num,
                           struct pipe_sampler_view **_views)
a501 3
   /* remove this when we have pipe->set_sampler_views(..., start, ...) */
   assert(start == 0);

d511 1
a511 21
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->set_vertex_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->set_geometry_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->set_fragment_sampler_views(pipe, num, views);
      break;
   default:
      debug_error("Unexpected shader in identity_set_sampler_views()");
   }
}

static void
identity_set_fragment_sampler_views(struct pipe_context *_pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **_views)
{
   identity_set_sampler_views(_pipe, PIPE_SHADER_FRAGMENT, 0, num, _views);
d519 16
a534 1
   identity_set_sampler_views(_pipe, PIPE_SHADER_VERTEX, 0, num, _views);
d539 1
a539 1
                            unsigned start_slot, unsigned num_buffers,
d556 1
a556 1
                            start_slot, num_buffers,
a606 14
identity_blit(struct pipe_context *_pipe,
              const struct pipe_blit_info *info)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;
   struct pipe_blit_info blit = *info;

   blit.src.resource = identity_resource(blit.src.resource)->resource;
   blit.dst.resource = identity_resource(blit.dst.resource)->resource;

   pipe->blit(pipe, &blit);
}

static void
d609 1
a609 1
               const union pipe_color_union *color,
d618 1
a618 1
               color,
d626 1
a626 1
                             const union pipe_color_union *color,
d637 1
a637 1
                             color,
d671 2
a672 2
               struct pipe_fence_handle **fence,
               unsigned flags)
d677 20
a696 1
   pipe->flush(pipe, fence, flags);
d755 2
a756 2
static void *
identity_context_transfer_map(struct pipe_context *_context,
d760 1
a760 2
                              const struct pipe_box *box,
                              struct pipe_transfer **transfer)
a766 1
   void *map;
d768 5
a772 5
   map = context->transfer_map(context,
                               resource,
                               level,
                               usage,
                               box, &result);
d774 21
a794 2
   if (!map)
      return NULL;
d796 2
a797 2
   *transfer = identity_transfer_map(id_context, id_resource, result);
   return *transfer ? map : NULL;
d800 2
a828 3

   identity_transfer_destroy(identity_context(_context),
                             identity_transfer(_transfer));
d869 1
d910 2
a911 2
   id_pipe->base.set_scissor_states = identity_set_scissor_states;
   id_pipe->base.set_viewport_states = identity_set_viewport_states;
d921 1
d926 2
a931 1
   id_pipe->base.blit = identity_blit;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d171 34
a204 1
   pipe->bind_sampler_states(pipe, shader, start, num_samplers, samplers);
d521 2
a522 1
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
d525 2
a526 2
   for (i = 0; i < num; i++)
      unwrapped_views[i] = identity_sampler_view_unwrap(_views[i]);
d528 38
a565 1
   pipe->set_sampler_views(pipe, shader, start, num, unwrapped_views);
a651 10
identity_flush_resource(struct pipe_context *_pipe,
                        struct pipe_resource *resource)
{
   struct identity_context *id_pipe = identity_context(_pipe);
   struct pipe_context *pipe = id_pipe->pipe;

   pipe->flush_resource(pipe, resource);
}

static void
d894 2
a895 1
   id_pipe->base.bind_sampler_states = identity_bind_sampler_states;
d921 2
a922 1
   id_pipe->base.set_sampler_views = identity_set_sampler_views;
a938 1
   id_pipe->base.flush_resource = identity_flush_resource;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d60 1
a60 2
                      unsigned query_type,
                      unsigned index)
d66 1
a66 2
                             query_type,
                             index);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d60 2
a61 1
                      unsigned query_type)
d67 2
a68 1
                             query_type);
@


