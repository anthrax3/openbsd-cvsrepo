head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.29;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.10;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.07;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.51;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.04;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.11;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "pipe/p_context.h"

#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"

#include "glhd_context.h"
#include "glhd_objects.h"


static void
galahad_context_destroy(struct pipe_context *_pipe)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->destroy(pipe);

   FREE(glhd_pipe);
}

static void
galahad_context_draw_vbo(struct pipe_context *_pipe,
                 const struct pipe_draw_info *info)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   /* XXX we should check that all bound resources are unmapped
    * before drawing.
    */

   pipe->draw_vbo(pipe, info);
}

static struct pipe_query *
galahad_context_create_query(struct pipe_context *_pipe,
                      unsigned query_type)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   if (query_type == PIPE_QUERY_OCCLUSION_COUNTER &&
      !pipe->screen->get_param(pipe->screen, PIPE_CAP_OCCLUSION_QUERY)) {
      glhd_error("Occlusion query requested but not supported");
   }

   if (query_type == PIPE_QUERY_TIME_ELAPSED &&
      !pipe->screen->get_param(pipe->screen, PIPE_CAP_QUERY_TIME_ELAPSED)) {
      glhd_error("Timer query requested but not supported");
   }

   return pipe->create_query(pipe,
                             query_type);
}

static void
galahad_context_destroy_query(struct pipe_context *_pipe,
                       struct pipe_query *query)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->destroy_query(pipe,
                       query);
}

static void
galahad_context_begin_query(struct pipe_context *_pipe,
                     struct pipe_query *query)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->begin_query(pipe,
                     query);
}

static void
galahad_context_end_query(struct pipe_context *_pipe,
                   struct pipe_query *query)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->end_query(pipe,
                   query);
}

static boolean
galahad_context_get_query_result(struct pipe_context *_pipe,
                          struct pipe_query *query,
                          boolean wait,
                          union pipe_query_result *result)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   return pipe->get_query_result(pipe,
                                 query,
                                 wait,
                                 result);
}

static void *
galahad_context_create_blend_state(struct pipe_context *_pipe,
                            const struct pipe_blend_state *blend)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   if (blend->logicop_enable) {
      if (blend->rt[0].blend_enable) {
         glhd_warn("Blending enabled for render target 0, but logicops "
            "are enabled");
      }
   }

   return pipe->create_blend_state(pipe,
                                   blend);
}

static void
galahad_context_bind_blend_state(struct pipe_context *_pipe,
                          void *blend)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->bind_blend_state(pipe,
                              blend);
}

static void
galahad_context_delete_blend_state(struct pipe_context *_pipe,
                            void *blend)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->delete_blend_state(pipe,
                            blend);
}

static void *
galahad_context_create_sampler_state(struct pipe_context *_pipe,
                              const struct pipe_sampler_state *sampler)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   return pipe->create_sampler_state(pipe,
                                     sampler);
}

static void
galahad_context_bind_sampler_states(struct pipe_context *_pipe,
                                    unsigned shader,
                                    unsigned start,
                                    unsigned num_samplers,
                                    void **samplers)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   if (num_samplers > PIPE_MAX_SAMPLERS) {
      glhd_error("%u samplers requested, "
         "but only %u are permitted by API",
         num_samplers, PIPE_MAX_SAMPLERS);
   }

   pipe->bind_sampler_states(pipe, shader, start, num_samplers, samplers);
}

static void
galahad_context_delete_sampler_state(struct pipe_context *_pipe,
                              void *sampler)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->delete_sampler_state(pipe,
                              sampler);
}

static void *
galahad_context_create_rasterizer_state(struct pipe_context *_pipe,
                                 const struct pipe_rasterizer_state *rasterizer)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   if (rasterizer->point_quad_rasterization) {
       if (rasterizer->point_smooth) {
           glhd_warn("Point smoothing requested but ignored");
       }
   } else {
       if (rasterizer->sprite_coord_enable) {
           glhd_warn("Point sprites requested but ignored");
       }
   }

   return pipe->create_rasterizer_state(pipe,
                                        rasterizer);
}

static void
galahad_context_bind_rasterizer_state(struct pipe_context *_pipe,
                               void *rasterizer)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->bind_rasterizer_state(pipe,
                               rasterizer);
}

static void
galahad_context_delete_rasterizer_state(struct pipe_context *_pipe,
                                 void *rasterizer)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->delete_rasterizer_state(pipe,
                                 rasterizer);
}

static void *
galahad_context_create_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                          const struct pipe_depth_stencil_alpha_state *depth_stencil_alpha)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   return pipe->create_depth_stencil_alpha_state(pipe,
                                                 depth_stencil_alpha);
}

static void
galahad_context_bind_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                        void *depth_stencil_alpha)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->bind_depth_stencil_alpha_state(pipe,
                                        depth_stencil_alpha);
}

static void
galahad_context_delete_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                          void *depth_stencil_alpha)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->delete_depth_stencil_alpha_state(pipe,
                                          depth_stencil_alpha);
}

#define GLHD_SHADER_STATE(shader_type) \
   static void * \
   galahad_context_create_##shader_type##_state(struct pipe_context *_pipe, \
                            const struct pipe_shader_state *state) \
   { \
      struct galahad_context *glhd_pipe = galahad_context(_pipe); \
      struct pipe_context *pipe = glhd_pipe->pipe; \
      return pipe->create_##shader_type##_state(pipe, state); \
   } \
   \
   static void \
   galahad_context_bind_##shader_type##_state(struct pipe_context *_pipe, \
                                              void *state) \
   { \
      struct galahad_context *glhd_pipe = galahad_context(_pipe); \
      struct pipe_context *pipe = glhd_pipe->pipe; \
      pipe->bind_##shader_type##_state(pipe, state); \
   } \
   \
   static void \
   galahad_context_delete_##shader_type##_state(struct pipe_context *_pipe, \
                                                void *state) \
   { \
      struct galahad_context *glhd_pipe = galahad_context(_pipe); \
      struct pipe_context *pipe = glhd_pipe->pipe; \
      pipe->delete_##shader_type##_state(pipe, state); \
   }

GLHD_SHADER_STATE(fs)
GLHD_SHADER_STATE(vs)
GLHD_SHADER_STATE(gs)

#undef GLHD_SHADER_STATE

static void *
galahad_context_create_vertex_elements_state(struct pipe_context *_pipe,
                                      unsigned num_elements,
                                      const struct pipe_vertex_element *vertex_elements)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   /* XXX check if stride lines up with element size, at least for floats */

   return pipe->create_vertex_elements_state(pipe,
                                             num_elements,
                                             vertex_elements);
}

static void
galahad_context_bind_vertex_elements_state(struct pipe_context *_pipe,
                                    void *velems)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->bind_vertex_elements_state(pipe,
                                    velems);
}

static void
galahad_context_delete_vertex_elements_state(struct pipe_context *_pipe,
                                      void *velems)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->delete_vertex_elements_state(pipe,
                                      velems);
}

static void
galahad_context_set_blend_color(struct pipe_context *_pipe,
                         const struct pipe_blend_color *blend_color)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_blend_color(pipe,
                         blend_color);
}

static void
galahad_context_set_stencil_ref(struct pipe_context *_pipe,
                         const struct pipe_stencil_ref *stencil_ref)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_stencil_ref(pipe,
                         stencil_ref);
}

static void
galahad_context_set_clip_state(struct pipe_context *_pipe,
                        const struct pipe_clip_state *clip)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_clip_state(pipe,
                        clip);
}

static void
galahad_context_set_sample_mask(struct pipe_context *_pipe,
                         unsigned sample_mask)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_sample_mask(pipe,
                         sample_mask);
}

static void
galahad_context_set_constant_buffer(struct pipe_context *_pipe,
                             uint shader,
                             uint index,
                             struct pipe_constant_buffer *_cb)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_constant_buffer cb;

   if (shader >= PIPE_SHADER_TYPES) {
      glhd_error("Unknown shader type %u", shader);
   }

   if (index &&
      index >=
         pipe->screen->get_shader_param(pipe->screen, shader, PIPE_SHADER_CAP_MAX_CONST_BUFFERS)) {
      glhd_error("Access to constant buffer %u requested, "
         "but only %d are supported",
         index,
         pipe->screen->get_shader_param(pipe->screen, shader, PIPE_SHADER_CAP_MAX_CONST_BUFFERS));
   }

   /* XXX hmm? unwrap the input state */
   if (_cb) {
      cb = *_cb;
      cb.buffer = galahad_resource_unwrap(_cb->buffer);
   }

   pipe->set_constant_buffer(pipe,
                             shader,
                             index,
                             _cb ? &cb : NULL);
}

static void
galahad_context_set_framebuffer_state(struct pipe_context *_pipe,
                               const struct pipe_framebuffer_state *_state)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_framebuffer_state unwrapped_state;
   struct pipe_framebuffer_state *state = NULL;
   unsigned i;

   if (_state->nr_cbufs > PIPE_MAX_COLOR_BUFS) {
      glhd_error("%d render targets bound, but only %d are permitted by API",
         _state->nr_cbufs, PIPE_MAX_COLOR_BUFS);
   } else if (_state->nr_cbufs >
      pipe->screen->get_param(pipe->screen, PIPE_CAP_MAX_RENDER_TARGETS)) {
      glhd_warn("%d render targets bound, but only %d are supported",
         _state->nr_cbufs,
         pipe->screen->get_param(pipe->screen, PIPE_CAP_MAX_RENDER_TARGETS));
   }

   /* unwrap the input state */
   if (_state) {
      memcpy(&unwrapped_state, _state, sizeof(unwrapped_state));
      for(i = 0; i < _state->nr_cbufs; i++)
         unwrapped_state.cbufs[i] = galahad_surface_unwrap(_state->cbufs[i]);
      for (; i < PIPE_MAX_COLOR_BUFS; i++)
         unwrapped_state.cbufs[i] = NULL;
      unwrapped_state.zsbuf = galahad_surface_unwrap(_state->zsbuf);
      state = &unwrapped_state;
   }

   pipe->set_framebuffer_state(pipe,
                               state);
}

static void
galahad_context_set_polygon_stipple(struct pipe_context *_pipe,
                             const struct pipe_poly_stipple *poly_stipple)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_polygon_stipple(pipe,
                             poly_stipple);
}

static void
galahad_context_set_scissor_states(struct pipe_context *_pipe,
                                   unsigned start_slot,
                                   unsigned num_scissors,
                           const struct pipe_scissor_state *scissor)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_scissor_states(pipe, start_slot, num_scissors,
                            scissor);
}

static void
galahad_context_set_viewport_states(struct pipe_context *_pipe,
                                    unsigned start_slot,
                                    unsigned num_viewports,
                            const struct pipe_viewport_state *viewport)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_viewport_states(pipe, start_slot, num_viewports,
                             viewport);
}

static void
galahad_context_set_sampler_views(struct pipe_context *_pipe,
                                  unsigned shader,
                                  unsigned start,
                                  unsigned num,
                                  struct pipe_sampler_view **_views)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
   unsigned i;

   for (i = 0; i < num; i++)
      unwrapped_views[i] = galahad_sampler_view_unwrap(_views[i]);

   pipe->set_sampler_views(pipe, shader, start, num, unwrapped_views);
}

static void
galahad_context_set_vertex_buffers(struct pipe_context *_pipe,
                            unsigned start_slot, unsigned num_buffers,
                            const struct pipe_vertex_buffer *_buffers)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_vertex_buffer unwrapped_buffers[PIPE_MAX_SHADER_INPUTS];
   struct pipe_vertex_buffer *buffers = NULL;
   unsigned i;

   if (num_buffers && _buffers) {
      memcpy(unwrapped_buffers, _buffers, num_buffers * sizeof(*_buffers));
      for (i = 0; i < num_buffers; i++)
         unwrapped_buffers[i].buffer = galahad_resource_unwrap(_buffers[i].buffer);
      buffers = unwrapped_buffers;
   }

   pipe->set_vertex_buffers(pipe,
                            start_slot, num_buffers,
                            buffers);
}

static void
galahad_context_set_index_buffer(struct pipe_context *_pipe,
                         const struct pipe_index_buffer *_ib)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_index_buffer unwrapped_ib, *ib = NULL;

   if (_ib) {
      if (_ib->buffer || _ib->user_buffer) {
         switch (_ib->index_size) {
         case 1:
         case 2:
         case 4:
            break;
         default:
            glhd_warn("unrecognized index size %d", _ib->index_size);
            break;
         }
      }
      else if (_ib->offset || _ib->index_size) {
         glhd_warn("non-indexed state with index offset %d and index size %d",
               _ib->offset, _ib->index_size);
      }

      unwrapped_ib = *_ib;
      unwrapped_ib.buffer = galahad_resource_unwrap(_ib->buffer);
      ib = &unwrapped_ib;
   }

   pipe->set_index_buffer(pipe, ib);
}

static INLINE struct pipe_stream_output_target *
galahad_context_create_stream_output_target(struct pipe_context *_pipe,
                                            struct pipe_resource *_res,
                                            unsigned buffer_offset,
                                            unsigned buffer_size)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct galahad_resource *glhd_resource_res = galahad_resource(_res);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_resource *res = glhd_resource_res->resource;

   return pipe->create_stream_output_target(pipe,
                                            res, buffer_offset, buffer_size);
}

static INLINE void
galahad_context_stream_output_target_destroy(
   struct pipe_context *_pipe,
   struct pipe_stream_output_target *target)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->stream_output_target_destroy(pipe, target);
}

static INLINE void
galahad_context_set_stream_output_targets(struct pipe_context *_pipe,
                                          unsigned num_targets,
                                          struct pipe_stream_output_target **tgs,
                                          const unsigned *offsets)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_stream_output_targets(pipe, num_targets, tgs, offsets);
}

static void
galahad_context_resource_copy_region(struct pipe_context *_pipe,
                                     struct pipe_resource *_dst,
                                     unsigned dst_level,
                                     unsigned dstx,
                                     unsigned dsty,
                                     unsigned dstz,
                                     struct pipe_resource *_src,
                                     unsigned src_level,
                                     const struct pipe_box *src_box)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct galahad_resource *glhd_resource_dst = galahad_resource(_dst);
   struct galahad_resource *glhd_resource_src = galahad_resource(_src);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_resource *dst = glhd_resource_dst->resource;
   struct pipe_resource *src = glhd_resource_src->resource;

   if (_dst->format != _src->format) {
      const struct util_format_description *src_desc =
         util_format_description(_src->format);
      const struct util_format_description *dst_desc =
         util_format_description(_dst->format);
      if (!util_is_format_compatible(src_desc, dst_desc))
         glhd_warn("Format mismatch: Source is %s, destination is %s",
            src_desc->short_name,
            dst_desc->short_name);
   }

   if ((_src->target == PIPE_BUFFER && _dst->target != PIPE_BUFFER) ||
       (_src->target != PIPE_BUFFER && _dst->target == PIPE_BUFFER)) {
      glhd_warn("Resource target mismatch: Source is %i, destination is %i",
                _src->target, _dst->target);
   }

   pipe->resource_copy_region(pipe,
                              dst,
                              dst_level,
                              dstx,
                              dsty,
                              dstz,
                              src,
                              src_level,
                              src_box);
}

static void
galahad_context_blit(struct pipe_context *_pipe,
                     const struct pipe_blit_info *_info)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_blit_info info = *_info;

   info.dst.resource = galahad_resource_unwrap(info.dst.resource);
   info.src.resource = galahad_resource_unwrap(info.src.resource);

   if (info.dst.box.width < 0 ||
       info.dst.box.height < 0)
      glhd_error("Destination dimensions are negative");

   if (info.filter != PIPE_TEX_FILTER_NEAREST &&
       info.src.resource->target != PIPE_TEXTURE_3D &&
       info.dst.box.depth != info.src.box.depth)
      glhd_error("Filtering in z-direction on non-3D texture");

   if (util_format_is_depth_or_stencil(info.dst.format) !=
       util_format_is_depth_or_stencil(info.src.format))
      glhd_error("Invalid format conversion: %s <- %s\n",
                 util_format_name(info.dst.format),
                 util_format_name(info.src.format));

   pipe->blit(pipe, &info);
}

static void
galahad_context_flush_resource(struct pipe_context *_pipe,
                               struct pipe_resource *_res)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct galahad_resource *glhd_resource_res = galahad_resource(_res);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_resource *res = glhd_resource_res->resource;

   pipe->flush_resource(pipe, res);
}

static void
galahad_context_clear(struct pipe_context *_pipe,
               unsigned buffers,
               const union pipe_color_union *color,
               double depth,
               unsigned stencil)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->clear(pipe,
               buffers,
               color,
               depth,
               stencil);
}

static void
galahad_context_clear_render_target(struct pipe_context *_pipe,
                             struct pipe_surface *_dst,
                             const union pipe_color_union *color,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct galahad_surface *glhd_surface_dst = galahad_surface(_dst);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_surface *dst = glhd_surface_dst->surface;

   pipe->clear_render_target(pipe,
                             dst,
                             color,
                             dstx,
                             dsty,
                             width,
                             height);
}
static void
galahad_context_clear_depth_stencil(struct pipe_context *_pipe,
                             struct pipe_surface *_dst,
                             unsigned clear_flags,
                             double depth,
                             unsigned stencil,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct galahad_surface *glhd_surface_dst = galahad_surface(_dst);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_surface *dst = glhd_surface_dst->surface;

   pipe->clear_depth_stencil(pipe,
                             dst,
                             clear_flags,
                             depth,
                             stencil,
                             dstx,
                             dsty,
                             width,
                             height);

}

static void
galahad_context_flush(struct pipe_context *_pipe,
                      struct pipe_fence_handle **fence,
                      unsigned flags)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->flush(pipe, fence, flags);
}

static struct pipe_sampler_view *
galahad_context_create_sampler_view(struct pipe_context *_pipe,
                                     struct pipe_resource *_resource,
                                     const struct pipe_sampler_view *templ)
{
   struct galahad_context *glhd_context = galahad_context(_pipe);
   struct galahad_resource *glhd_resource = galahad_resource(_resource);
   struct pipe_context *pipe = glhd_context->pipe;
   struct pipe_resource *resource = glhd_resource->resource;
   struct pipe_sampler_view *result;

   result = pipe->create_sampler_view(pipe,
                                      resource,
                                      templ);

   if (result)
      return galahad_sampler_view_create(glhd_context, glhd_resource, result);
   return NULL;
}

static void
galahad_context_sampler_view_destroy(struct pipe_context *_pipe,
                                      struct pipe_sampler_view *_view)
{
   galahad_sampler_view_destroy(galahad_context(_pipe),
                                 galahad_sampler_view(_view));
}

static struct pipe_surface *
galahad_context_create_surface(struct pipe_context *_pipe,
                                struct pipe_resource *_resource,
                                const struct pipe_surface *templ)
{
   struct galahad_context *glhd_context = galahad_context(_pipe);
   struct galahad_resource *glhd_resource = galahad_resource(_resource);
   struct pipe_context *pipe = glhd_context->pipe;
   struct pipe_resource *resource = glhd_resource->resource;
   struct pipe_surface *result;

   result = pipe->create_surface(pipe,
                                 resource,
                                 templ);

   if (result)
      return galahad_surface_create(glhd_context, glhd_resource, result);
   return NULL;
}

static void
galahad_context_surface_destroy(struct pipe_context *_pipe,
                                struct pipe_surface *_surface)
{
   galahad_surface_destroy(galahad_context(_pipe),
                           galahad_surface(_surface));
}


static void *
galahad_context_transfer_map(struct pipe_context *_context,
                             struct pipe_resource *_resource,
                             unsigned level,
                             unsigned usage,
                             const struct pipe_box *box,
                             struct pipe_transfer **transfer)
{
   struct galahad_context *glhd_context = galahad_context(_context);
   struct galahad_resource *glhd_resource = galahad_resource(_resource);
   struct pipe_context *context = glhd_context->pipe;
   struct pipe_resource *resource = glhd_resource->resource;
   struct pipe_transfer *result;
   void *map;

   map = context->transfer_map(context,
                               resource,
                               level,
                               usage,
                               box, &result);
   if (!map)
      return NULL;

   glhd_resource->map_count++;

   *transfer = galahad_transfer_create(glhd_context, glhd_resource, result);
   return *transfer ? map : NULL;
}

static void
galahad_context_transfer_flush_region(struct pipe_context *_context,
                                       struct pipe_transfer *_transfer,
                                       const struct pipe_box *box)
{
   struct galahad_context *glhd_context = galahad_context(_context);
   struct galahad_transfer *glhd_transfer = galahad_transfer(_transfer);
   struct pipe_context *context = glhd_context->pipe;
   struct pipe_transfer *transfer = glhd_transfer->transfer;

   context->transfer_flush_region(context,
                                  transfer,
                                  box);
}

static void
galahad_context_transfer_unmap(struct pipe_context *_context,
                                struct pipe_transfer *_transfer)
{
   struct galahad_context *glhd_context = galahad_context(_context);
   struct galahad_transfer *glhd_transfer = galahad_transfer(_transfer);
   struct pipe_context *context = glhd_context->pipe;
   struct pipe_transfer *transfer = glhd_transfer->transfer;
   struct galahad_resource *glhd_resource = galahad_resource(_transfer->resource);

   if (glhd_resource->map_count < 1) {
      glhd_warn("context::transfer_unmap() called too many times"
                " (count = %d)\n", glhd_resource->map_count);      
   }

   glhd_resource->map_count--;

   context->transfer_unmap(context,
                           transfer);

   galahad_transfer_destroy(galahad_context(_context),
                             galahad_transfer(_transfer));
}


static void
galahad_context_transfer_inline_write(struct pipe_context *_context,
                                       struct pipe_resource *_resource,
                                       unsigned level,
                                       unsigned usage,
                                       const struct pipe_box *box,
                                       const void *data,
                                       unsigned stride,
                                       unsigned slice_stride)
{
   struct galahad_context *glhd_context = galahad_context(_context);
   struct galahad_resource *glhd_resource = galahad_resource(_resource);
   struct pipe_context *context = glhd_context->pipe;
   struct pipe_resource *resource = glhd_resource->resource;

   context->transfer_inline_write(context,
                                  resource,
                                  level,
                                  usage,
                                  box,
                                  data,
                                  stride,
                                  slice_stride);
}


static void
galahad_context_render_condition(struct pipe_context *_context,
                                 struct pipe_query *query,
                                 boolean condition,
                                 uint mode)
{
   struct galahad_context *glhd_context = galahad_context(_context);
   struct pipe_context *context = glhd_context->pipe;

   context->render_condition(context, query, condition, mode);
}


struct pipe_context *
galahad_context_create(struct pipe_screen *_screen, struct pipe_context *pipe)
{
   struct galahad_context *glhd_pipe;
   (void)galahad_screen(_screen);

   glhd_pipe = CALLOC_STRUCT(galahad_context);
   if (!glhd_pipe) {
      return NULL;
   }

   glhd_pipe->base.screen = _screen;
   glhd_pipe->base.priv = pipe->priv; /* expose wrapped data */
   glhd_pipe->base.draw = NULL;

   glhd_pipe->base.destroy = galahad_context_destroy;

#define GLHD_PIPE_INIT(_member) \
   glhd_pipe->base . _member = pipe -> _member ? galahad_context_ ## _member : NULL

   GLHD_PIPE_INIT(draw_vbo);
   GLHD_PIPE_INIT(render_condition);
   GLHD_PIPE_INIT(create_query);
   GLHD_PIPE_INIT(destroy_query);
   GLHD_PIPE_INIT(begin_query);
   GLHD_PIPE_INIT(end_query);
   GLHD_PIPE_INIT(get_query_result);
   GLHD_PIPE_INIT(create_blend_state);
   GLHD_PIPE_INIT(bind_blend_state);
   GLHD_PIPE_INIT(delete_blend_state);
   GLHD_PIPE_INIT(create_sampler_state);
   GLHD_PIPE_INIT(bind_sampler_states);
   GLHD_PIPE_INIT(delete_sampler_state);
   GLHD_PIPE_INIT(create_rasterizer_state);
   GLHD_PIPE_INIT(bind_rasterizer_state);
   GLHD_PIPE_INIT(delete_rasterizer_state);
   GLHD_PIPE_INIT(create_depth_stencil_alpha_state);
   GLHD_PIPE_INIT(bind_depth_stencil_alpha_state);
   GLHD_PIPE_INIT(delete_depth_stencil_alpha_state);
   GLHD_PIPE_INIT(create_fs_state);
   GLHD_PIPE_INIT(bind_fs_state);
   GLHD_PIPE_INIT(delete_fs_state);
   GLHD_PIPE_INIT(create_vs_state);
   GLHD_PIPE_INIT(bind_vs_state);
   GLHD_PIPE_INIT(delete_vs_state);
   GLHD_PIPE_INIT(create_gs_state);
   GLHD_PIPE_INIT(bind_gs_state);
   GLHD_PIPE_INIT(delete_gs_state);
   GLHD_PIPE_INIT(create_vertex_elements_state);
   GLHD_PIPE_INIT(bind_vertex_elements_state);
   GLHD_PIPE_INIT(delete_vertex_elements_state);
   GLHD_PIPE_INIT(set_blend_color);
   GLHD_PIPE_INIT(set_stencil_ref);
   GLHD_PIPE_INIT(set_sample_mask);
   GLHD_PIPE_INIT(set_clip_state);
   GLHD_PIPE_INIT(set_constant_buffer);
   GLHD_PIPE_INIT(set_framebuffer_state);
   GLHD_PIPE_INIT(set_polygon_stipple);
   GLHD_PIPE_INIT(set_scissor_states);
   GLHD_PIPE_INIT(set_viewport_states);
   GLHD_PIPE_INIT(set_sampler_views);
   //GLHD_PIPE_INIT(set_shader_resources);
   GLHD_PIPE_INIT(set_vertex_buffers);
   GLHD_PIPE_INIT(set_index_buffer);
   GLHD_PIPE_INIT(create_stream_output_target);
   GLHD_PIPE_INIT(stream_output_target_destroy);
   GLHD_PIPE_INIT(set_stream_output_targets);
   GLHD_PIPE_INIT(resource_copy_region);
   GLHD_PIPE_INIT(blit);
   GLHD_PIPE_INIT(flush_resource);
   GLHD_PIPE_INIT(clear);
   GLHD_PIPE_INIT(clear_render_target);
   GLHD_PIPE_INIT(clear_depth_stencil);
   GLHD_PIPE_INIT(flush);
   GLHD_PIPE_INIT(create_sampler_view);
   GLHD_PIPE_INIT(sampler_view_destroy);
   GLHD_PIPE_INIT(create_surface);
   GLHD_PIPE_INIT(surface_destroy);
   GLHD_PIPE_INIT(transfer_map);
   GLHD_PIPE_INIT(transfer_flush_region);
   GLHD_PIPE_INIT(transfer_unmap);
   GLHD_PIPE_INIT(transfer_inline_write);
   //GLHD_PIPE_INIT(texture_barrier);
   //GLHD_PIPE_INIT(create_video_decoder);
   //GLHD_PIPE_INIT(create_video_buffer);
   //GLHD_PIPE_INIT(create_compute_state);
   //GLHD_PIPE_INIT(bind_compute_state);
   //GLHD_PIPE_INIT(delete_compute_state);
   //GLHD_PIPE_INIT(set_compute_resources);
   //GLHD_PIPE_INIT(set_global_binding);
   //GLHD_PIPE_INIT(launch_grid);

#undef GLHD_PIPE_INIT

   glhd_pipe->pipe = pipe;

   return &glhd_pipe->base;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d52 1
a52 1
                         const struct pipe_draw_info *info)
d61 1
a61 8
   if (info->indirect) {
      struct pipe_draw_info info_unwrapped = *info;
      info_unwrapped.indirect = galahad_resource_unwrap(info->indirect);
      pipe->draw_vbo(pipe, &info_unwrapped);
   }
   else {
      pipe->draw_vbo(pipe, info);
   }
d66 1
a66 2
                             unsigned query_type,
                             unsigned index)
d82 1
a82 2
                             query_type,
                             index);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d52 1
a52 1
                 const struct pipe_draw_info *info)
d61 8
a68 1
   pipe->draw_vbo(pipe, info);
d73 2
a74 1
                      unsigned query_type)
d90 2
a91 1
                             query_type);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d200 1
a200 22
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->bind_vertex_sampler_states(pipe, num_samplers, samplers);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->bind_fragment_sampler_states(pipe, num_samplers, samplers);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->bind_geometry_sampler_states(pipe, num_samplers, samplers);
      break;
   default:
      assert(0);
   }
}

static void
galahad_context_bind_vertex_sampler_states(struct pipe_context *_pipe,
                                           unsigned num_samplers,
                                           void **samplers)
{
   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
                                       0, num_samplers, samplers);
a203 19
galahad_context_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                             unsigned num_samplers,
                                             void **samplers)
{
   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
                                       0, num_samplers, samplers);
}

static void
galahad_context_bind_geometry_sampler_states(struct pipe_context *_pipe,
                                             unsigned num_samplers,
                                             void **samplers)
{
   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_GEOMETRY,
                                       0, num_samplers, samplers);
}


static void
d521 1
a521 2
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SAMPLERS];
   struct pipe_sampler_view **views = NULL;
d524 2
a525 41
   if (_views) {
      for (i = 0; i < num; i++)
         unwrapped_views[i] = galahad_sampler_view_unwrap(_views[i]);
      for (; i < PIPE_MAX_SAMPLERS; i++)
         unwrapped_views[i] = NULL;

      views = unwrapped_views;
   }

   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->set_vertex_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->set_fragment_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->set_geometry_sampler_views(pipe, num, views);
      break;
   default:
      assert(0);
   }
}

static void
galahad_context_set_vertex_sampler_views(struct pipe_context *_pipe,
                                         unsigned num,
                                         struct pipe_sampler_view **_views)
{
   galahad_context_set_sampler_views(_pipe, PIPE_SHADER_VERTEX,
                                     0, num, _views);
}

static void
galahad_context_set_fragment_sampler_views(struct pipe_context *_pipe,
                                           unsigned num,
                                           struct pipe_sampler_view **_views)
{
   galahad_context_set_sampler_views(_pipe, PIPE_SHADER_FRAGMENT,
                                     0, num, _views);
}
d527 1
a527 7
static void
galahad_context_set_geometry_sampler_views(struct pipe_context *_pipe,
                                           unsigned num,
                                           struct pipe_sampler_view **_views)
{
   galahad_context_set_sampler_views(_pipe, PIPE_SHADER_GEOMETRY,
                                     0, num, _views);
d616 1
a616 1
                                          unsigned append_bitmask)
d621 1
a621 1
   pipe->set_stream_output_targets(pipe, num_targets, tgs, append_bitmask);
d700 12
d981 1
a981 4
   GLHD_PIPE_INIT(bind_fragment_sampler_states);
   GLHD_PIPE_INIT(bind_vertex_sampler_states);
   GLHD_PIPE_INIT(bind_geometry_sampler_states);
   //GLHD_PIPE_INIT(bind_compute_sampler_states);
d1010 1
a1010 4
   GLHD_PIPE_INIT(set_fragment_sampler_views);
   GLHD_PIPE_INIT(set_vertex_sampler_views);
   GLHD_PIPE_INIT(set_geometry_sampler_views);
   //GLHD_PIPE_INIT(set_compute_sampler_views);
d1019 1
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d40 1
a40 1
galahad_destroy(struct pipe_context *_pipe)
d51 1
a51 1
galahad_draw_vbo(struct pipe_context *_pipe,
d65 1
a65 1
galahad_create_query(struct pipe_context *_pipe,
d77 1
a77 1
      !pipe->screen->get_param(pipe->screen, PIPE_CAP_TIMER_QUERY)) {
d86 1
a86 1
galahad_destroy_query(struct pipe_context *_pipe,
d97 1
a97 1
galahad_begin_query(struct pipe_context *_pipe,
d108 1
a108 1
galahad_end_query(struct pipe_context *_pipe,
d119 1
a119 1
galahad_get_query_result(struct pipe_context *_pipe,
d122 1
a122 1
                          void *result)
d134 1
a134 1
galahad_create_blend_state(struct pipe_context *_pipe,
d152 1
a152 1
galahad_bind_blend_state(struct pipe_context *_pipe,
d163 1
a163 1
galahad_delete_blend_state(struct pipe_context *_pipe,
d174 1
a174 1
galahad_create_sampler_state(struct pipe_context *_pipe,
d185 5
a189 3
galahad_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                      unsigned num_samplers,
                                      void **samplers)
d195 1
a195 1
      glhd_error("%u fragment samplers requested, "
d200 13
a212 3
   pipe->bind_fragment_sampler_states(pipe,
                                      num_samplers,
                                      samplers);
d216 3
a218 3
galahad_bind_vertex_sampler_states(struct pipe_context *_pipe,
                                    unsigned num_samplers,
                                    void **samplers)
d220 3
a222 2
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
d224 8
a231 5
   if (num_samplers > PIPE_MAX_VERTEX_SAMPLERS) {
      glhd_error("%u vertex samplers requested, "
         "but only %u are permitted by API",
         num_samplers, PIPE_MAX_VERTEX_SAMPLERS);
   }
d233 7
a239 3
   pipe->bind_vertex_sampler_states(pipe,
                                    num_samplers,
                                    samplers);
d242 1
d244 1
a244 1
galahad_delete_sampler_state(struct pipe_context *_pipe,
d255 1
a255 1
galahad_create_rasterizer_state(struct pipe_context *_pipe,
d276 1
a276 1
galahad_bind_rasterizer_state(struct pipe_context *_pipe,
d287 1
a287 1
galahad_delete_rasterizer_state(struct pipe_context *_pipe,
d298 1
a298 1
galahad_create_depth_stencil_alpha_state(struct pipe_context *_pipe,
d309 1
a309 1
galahad_bind_depth_stencil_alpha_state(struct pipe_context *_pipe,
d320 1
a320 1
galahad_delete_depth_stencil_alpha_state(struct pipe_context *_pipe,
d330 31
a360 65
static void *
galahad_create_fs_state(struct pipe_context *_pipe,
                         const struct pipe_shader_state *fs)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   return pipe->create_fs_state(pipe,
                                fs);
}

static void
galahad_bind_fs_state(struct pipe_context *_pipe,
                       void *fs)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->bind_fs_state(pipe,
                       fs);
}

static void
galahad_delete_fs_state(struct pipe_context *_pipe,
                         void *fs)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->delete_fs_state(pipe,
                         fs);
}

static void *
galahad_create_vs_state(struct pipe_context *_pipe,
                         const struct pipe_shader_state *vs)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   return pipe->create_vs_state(pipe,
                                vs);
}

static void
galahad_bind_vs_state(struct pipe_context *_pipe,
                       void *vs)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->bind_vs_state(pipe,
                       vs);
}

static void
galahad_delete_vs_state(struct pipe_context *_pipe,
                         void *vs)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->delete_vs_state(pipe,
                         vs);
}
d362 1
d365 1
a365 1
galahad_create_vertex_elements_state(struct pipe_context *_pipe,
d380 1
a380 1
galahad_bind_vertex_elements_state(struct pipe_context *_pipe,
d391 1
a391 1
galahad_delete_vertex_elements_state(struct pipe_context *_pipe,
d402 1
a402 1
galahad_set_blend_color(struct pipe_context *_pipe,
d413 1
a413 1
galahad_set_stencil_ref(struct pipe_context *_pipe,
d424 1
a424 1
galahad_set_clip_state(struct pipe_context *_pipe,
d435 1
a435 1
galahad_set_sample_mask(struct pipe_context *_pipe,
d446 1
a446 1
galahad_set_constant_buffer(struct pipe_context *_pipe,
d449 1
a449 1
                             struct pipe_resource *_resource)
d453 1
a453 2
   struct pipe_resource *unwrapped_resource;
   struct pipe_resource *resource = NULL;
d469 3
a471 3
   if (_resource) {
      unwrapped_resource = galahad_resource_unwrap(_resource);
      resource = unwrapped_resource;
d477 1
a477 1
                             resource);
d481 1
a481 1
galahad_set_framebuffer_state(struct pipe_context *_pipe,
d516 1
a516 1
galahad_set_polygon_stipple(struct pipe_context *_pipe,
d527 3
a529 1
galahad_set_scissor_state(struct pipe_context *_pipe,
d535 2
a536 2
   pipe->set_scissor_state(pipe,
                           scissor);
d540 3
a542 1
galahad_set_viewport_state(struct pipe_context *_pipe,
d548 2
a549 2
   pipe->set_viewport_state(pipe,
                            viewport);
d553 5
a557 3
galahad_set_fragment_sampler_views(struct pipe_context *_pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **_views)
d574 13
a586 1
   pipe->set_fragment_sampler_views(pipe, num, views);
d590 3
a592 3
galahad_set_vertex_sampler_views(struct pipe_context *_pipe,
                                  unsigned num,
                                  struct pipe_sampler_view **_views)
d594 3
a596 5
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_VERTEX_SAMPLERS];
   struct pipe_sampler_view **views = NULL;
   unsigned i;
d598 8
a605 5
   if (_views) {
      for (i = 0; i < num; i++)
         unwrapped_views[i] = galahad_sampler_view_unwrap(_views[i]);
      for (; i < PIPE_MAX_VERTEX_SAMPLERS; i++)
         unwrapped_views[i] = NULL;
d607 7
a613 4
      views = unwrapped_views;
   }

   pipe->set_vertex_sampler_views(pipe, num, views);
d617 2
a618 2
galahad_set_vertex_buffers(struct pipe_context *_pipe,
                            unsigned num_buffers,
d627 1
a627 1
   if (num_buffers) {
d635 1
a635 1
                            num_buffers,
d640 1
a640 1
galahad_set_index_buffer(struct pipe_context *_pipe,
d647 15
a661 10
   if (_ib->buffer) {
      switch (_ib->index_size) {
      case 1:
      case 2:
      case 4:
         break;
      default:
         glhd_warn("index buffer %p has unrecognized index size %d",
                   (void *) _ib->buffer, _ib->index_size);
         break;
a662 5
   }
   else if (_ib->offset || _ib->index_size) {
      glhd_warn("non-indexed state with index offset %d and index size %d",
            _ib->offset, _ib->index_size);
   }
a663 1
   if (_ib) {
d672 38
d711 9
a719 9
galahad_resource_copy_region(struct pipe_context *_pipe,
                              struct pipe_resource *_dst,
                              unsigned dst_level,
                              unsigned dstx,
                              unsigned dsty,
                              unsigned dstz,
                              struct pipe_resource *_src,
                              unsigned src_level,
                              const struct pipe_box *src_box)
d729 8
a736 3
      glhd_warn("Format mismatch: Source is %s, destination is %s",
         util_format_short_name(_src->format),
         util_format_short_name(_dst->format));
d757 30
a786 1
galahad_clear(struct pipe_context *_pipe,
d788 1
a788 1
               const float *rgba,
d797 1
a797 1
               rgba,
d803 1
a803 1
galahad_clear_render_target(struct pipe_context *_pipe,
d805 1
a805 1
                             const float *rgba,
d816 1
a816 1
                             rgba,
d823 1
a823 1
galahad_clear_depth_stencil(struct pipe_context *_pipe,
d849 3
a851 2
galahad_flush(struct pipe_context *_pipe,
               struct pipe_fence_handle **fence)
d856 1
a856 2
   pipe->flush(pipe,
               fence);
d916 7
a922 7

static struct pipe_transfer *
galahad_context_get_transfer(struct pipe_context *_context,
                              struct pipe_resource *_resource,
                              unsigned level,
                              unsigned usage,
                              const struct pipe_box *box)
d929 1
d931 7
a937 29
   result = context->get_transfer(context,
                                  resource,
                                  level,
                                  usage,
                                  box);

   if (result)
      return galahad_transfer_create(glhd_context, glhd_resource, result);
   return NULL;
}

static void
galahad_context_transfer_destroy(struct pipe_context *_pipe,
                                  struct pipe_transfer *_transfer)
{
   galahad_transfer_destroy(galahad_context(_pipe),
                             galahad_transfer(_transfer));
}

static void *
galahad_context_transfer_map(struct pipe_context *_context,
                              struct pipe_transfer *_transfer)
{
   struct galahad_context *glhd_context = galahad_context(_context);
   struct galahad_transfer *glhd_transfer = galahad_transfer(_transfer);
   struct pipe_context *context = glhd_context->pipe;
   struct pipe_transfer *transfer = glhd_transfer->transfer;

   struct galahad_resource *glhd_resource = galahad_resource(_transfer->resource);
d941 2
a942 2
   return context->transfer_map(context,
                                transfer);
a944 2


a959 1

d979 3
d1011 5
a1015 3
static void galahad_redefine_user_buffer(struct pipe_context *_context,
                                         struct pipe_resource *_resource,
                                         unsigned offset, unsigned size)
a1017 1
   struct galahad_resource *glhd_resource = galahad_resource(_resource);
a1018 1
   struct pipe_resource *resource = glhd_resource->resource;
d1020 1
a1020 1
   context->redefine_user_buffer(context, resource, offset, size);
a1034 1
   glhd_pipe->base.winsys = NULL;
d1039 83
a1121 58
   glhd_pipe->base.destroy = galahad_destroy;
   glhd_pipe->base.draw_vbo = galahad_draw_vbo;
   glhd_pipe->base.create_query = galahad_create_query;
   glhd_pipe->base.destroy_query = galahad_destroy_query;
   glhd_pipe->base.begin_query = galahad_begin_query;
   glhd_pipe->base.end_query = galahad_end_query;
   glhd_pipe->base.get_query_result = galahad_get_query_result;
   glhd_pipe->base.create_blend_state = galahad_create_blend_state;
   glhd_pipe->base.bind_blend_state = galahad_bind_blend_state;
   glhd_pipe->base.delete_blend_state = galahad_delete_blend_state;
   glhd_pipe->base.create_sampler_state = galahad_create_sampler_state;
   glhd_pipe->base.bind_fragment_sampler_states = galahad_bind_fragment_sampler_states;
   glhd_pipe->base.bind_vertex_sampler_states = galahad_bind_vertex_sampler_states;
   glhd_pipe->base.delete_sampler_state = galahad_delete_sampler_state;
   glhd_pipe->base.create_rasterizer_state = galahad_create_rasterizer_state;
   glhd_pipe->base.bind_rasterizer_state = galahad_bind_rasterizer_state;
   glhd_pipe->base.delete_rasterizer_state = galahad_delete_rasterizer_state;
   glhd_pipe->base.create_depth_stencil_alpha_state = galahad_create_depth_stencil_alpha_state;
   glhd_pipe->base.bind_depth_stencil_alpha_state = galahad_bind_depth_stencil_alpha_state;
   glhd_pipe->base.delete_depth_stencil_alpha_state = galahad_delete_depth_stencil_alpha_state;
   glhd_pipe->base.create_fs_state = galahad_create_fs_state;
   glhd_pipe->base.bind_fs_state = galahad_bind_fs_state;
   glhd_pipe->base.delete_fs_state = galahad_delete_fs_state;
   glhd_pipe->base.create_vs_state = galahad_create_vs_state;
   glhd_pipe->base.bind_vs_state = galahad_bind_vs_state;
   glhd_pipe->base.delete_vs_state = galahad_delete_vs_state;
   glhd_pipe->base.create_vertex_elements_state = galahad_create_vertex_elements_state;
   glhd_pipe->base.bind_vertex_elements_state = galahad_bind_vertex_elements_state;
   glhd_pipe->base.delete_vertex_elements_state = galahad_delete_vertex_elements_state;
   glhd_pipe->base.set_blend_color = galahad_set_blend_color;
   glhd_pipe->base.set_stencil_ref = galahad_set_stencil_ref;
   glhd_pipe->base.set_clip_state = galahad_set_clip_state;
   glhd_pipe->base.set_sample_mask = galahad_set_sample_mask;
   glhd_pipe->base.set_constant_buffer = galahad_set_constant_buffer;
   glhd_pipe->base.set_framebuffer_state = galahad_set_framebuffer_state;
   glhd_pipe->base.set_polygon_stipple = galahad_set_polygon_stipple;
   glhd_pipe->base.set_scissor_state = galahad_set_scissor_state;
   glhd_pipe->base.set_viewport_state = galahad_set_viewport_state;
   glhd_pipe->base.set_fragment_sampler_views = galahad_set_fragment_sampler_views;
   glhd_pipe->base.set_vertex_sampler_views = galahad_set_vertex_sampler_views;
   glhd_pipe->base.set_vertex_buffers = galahad_set_vertex_buffers;
   glhd_pipe->base.set_index_buffer = galahad_set_index_buffer;
   glhd_pipe->base.resource_copy_region = galahad_resource_copy_region;
   glhd_pipe->base.clear = galahad_clear;
   glhd_pipe->base.clear_render_target = galahad_clear_render_target;
   glhd_pipe->base.clear_depth_stencil = galahad_clear_depth_stencil;
   glhd_pipe->base.flush = galahad_flush;
   glhd_pipe->base.create_sampler_view = galahad_context_create_sampler_view;
   glhd_pipe->base.sampler_view_destroy = galahad_context_sampler_view_destroy;
   glhd_pipe->base.create_surface = galahad_context_create_surface;
   glhd_pipe->base.surface_destroy = galahad_context_surface_destroy;
   glhd_pipe->base.get_transfer = galahad_context_get_transfer;
   glhd_pipe->base.transfer_destroy = galahad_context_transfer_destroy;
   glhd_pipe->base.transfer_map = galahad_context_transfer_map;
   glhd_pipe->base.transfer_unmap = galahad_context_transfer_unmap;
   glhd_pipe->base.transfer_flush_region = galahad_context_transfer_flush_region;
   glhd_pipe->base.transfer_inline_write = galahad_context_transfer_inline_write;
   glhd_pipe->base.redefine_user_buffer = galahad_redefine_user_buffer;
a1123 2

   glhd_warn("Created context %p", (void *) glhd_pipe);
@


1.1
log
@Initial revision
@
text
@d384 2
d688 6
a769 1
               unsigned flags,
a775 1
               flags,
a778 17
static unsigned int
galahad_is_resource_referenced(struct pipe_context *_pipe,
                                struct pipe_resource *_resource,
                                unsigned level,
                                int layer)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct galahad_resource *glhd_resource = galahad_resource(_resource);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_resource *resource = glhd_resource->resource;

   return pipe->is_resource_referenced(pipe,
                                       resource,
                                       level,
                                       layer);
}

d952 13
a1027 1
   glhd_pipe->base.is_resource_referenced = galahad_is_resource_referenced;
d1038 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d40 1
a40 1
galahad_context_destroy(struct pipe_context *_pipe)
d51 1
a51 1
galahad_context_draw_vbo(struct pipe_context *_pipe,
d65 1
a65 1
galahad_context_create_query(struct pipe_context *_pipe,
d77 1
a77 1
      !pipe->screen->get_param(pipe->screen, PIPE_CAP_QUERY_TIME_ELAPSED)) {
d86 1
a86 1
galahad_context_destroy_query(struct pipe_context *_pipe,
d97 1
a97 1
galahad_context_begin_query(struct pipe_context *_pipe,
d108 1
a108 1
galahad_context_end_query(struct pipe_context *_pipe,
d119 1
a119 1
galahad_context_get_query_result(struct pipe_context *_pipe,
d122 1
a122 1
                          union pipe_query_result *result)
d134 1
a134 1
galahad_context_create_blend_state(struct pipe_context *_pipe,
d152 1
a152 1
galahad_context_bind_blend_state(struct pipe_context *_pipe,
d163 1
a163 1
galahad_context_delete_blend_state(struct pipe_context *_pipe,
d174 1
a174 1
galahad_context_create_sampler_state(struct pipe_context *_pipe,
d185 3
a187 5
galahad_context_bind_sampler_states(struct pipe_context *_pipe,
                                    unsigned shader,
                                    unsigned start,
                                    unsigned num_samplers,
                                    void **samplers)
d193 1
a193 1
      glhd_error("%u samplers requested, "
d198 3
a200 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->bind_vertex_sampler_states(pipe, num_samplers, samplers);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->bind_fragment_sampler_states(pipe, num_samplers, samplers);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->bind_geometry_sampler_states(pipe, num_samplers, samplers);
      break;
   default:
      assert(0);
   }
d204 3
a206 3
galahad_context_bind_vertex_sampler_states(struct pipe_context *_pipe,
                                           unsigned num_samplers,
                                           void **samplers)
d208 2
a209 3
   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
                                       0, num_samplers, samplers);
}
d211 5
a215 8
static void
galahad_context_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                             unsigned num_samplers,
                                             void **samplers)
{
   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
                                       0, num_samplers, samplers);
}
d217 3
a219 7
static void
galahad_context_bind_geometry_sampler_states(struct pipe_context *_pipe,
                                             unsigned num_samplers,
                                             void **samplers)
{
   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_GEOMETRY,
                                       0, num_samplers, samplers);
a221 1

d223 1
a223 1
galahad_context_delete_sampler_state(struct pipe_context *_pipe,
d234 1
a234 1
galahad_context_create_rasterizer_state(struct pipe_context *_pipe,
d255 1
a255 1
galahad_context_bind_rasterizer_state(struct pipe_context *_pipe,
d266 1
a266 1
galahad_context_delete_rasterizer_state(struct pipe_context *_pipe,
d277 1
a277 1
galahad_context_create_depth_stencil_alpha_state(struct pipe_context *_pipe,
d288 1
a288 1
galahad_context_bind_depth_stencil_alpha_state(struct pipe_context *_pipe,
d299 1
a299 1
galahad_context_delete_depth_stencil_alpha_state(struct pipe_context *_pipe,
d309 61
a369 27
#define GLHD_SHADER_STATE(shader_type) \
   static void * \
   galahad_context_create_##shader_type##_state(struct pipe_context *_pipe, \
                            const struct pipe_shader_state *state) \
   { \
      struct galahad_context *glhd_pipe = galahad_context(_pipe); \
      struct pipe_context *pipe = glhd_pipe->pipe; \
      return pipe->create_##shader_type##_state(pipe, state); \
   } \
   \
   static void \
   galahad_context_bind_##shader_type##_state(struct pipe_context *_pipe, \
                                              void *state) \
   { \
      struct galahad_context *glhd_pipe = galahad_context(_pipe); \
      struct pipe_context *pipe = glhd_pipe->pipe; \
      pipe->bind_##shader_type##_state(pipe, state); \
   } \
   \
   static void \
   galahad_context_delete_##shader_type##_state(struct pipe_context *_pipe, \
                                                void *state) \
   { \
      struct galahad_context *glhd_pipe = galahad_context(_pipe); \
      struct pipe_context *pipe = glhd_pipe->pipe; \
      pipe->delete_##shader_type##_state(pipe, state); \
   }
d371 3
a373 3
GLHD_SHADER_STATE(fs)
GLHD_SHADER_STATE(vs)
GLHD_SHADER_STATE(gs)
a374 1
#undef GLHD_SHADER_STATE
d377 1
a377 1
galahad_context_create_vertex_elements_state(struct pipe_context *_pipe,
a383 2
   /* XXX check if stride lines up with element size, at least for floats */

d390 1
a390 1
galahad_context_bind_vertex_elements_state(struct pipe_context *_pipe,
d401 1
a401 1
galahad_context_delete_vertex_elements_state(struct pipe_context *_pipe,
d412 1
a412 1
galahad_context_set_blend_color(struct pipe_context *_pipe,
d423 1
a423 1
galahad_context_set_stencil_ref(struct pipe_context *_pipe,
d434 1
a434 1
galahad_context_set_clip_state(struct pipe_context *_pipe,
d445 1
a445 1
galahad_context_set_sample_mask(struct pipe_context *_pipe,
d456 1
a456 1
galahad_context_set_constant_buffer(struct pipe_context *_pipe,
d459 1
a459 1
                             struct pipe_constant_buffer *_cb)
d463 2
a464 1
   struct pipe_constant_buffer cb;
d480 3
a482 3
   if (_cb) {
      cb = *_cb;
      cb.buffer = galahad_resource_unwrap(_cb->buffer);
d488 1
a488 1
                             _cb ? &cb : NULL);
d492 1
a492 1
galahad_context_set_framebuffer_state(struct pipe_context *_pipe,
d527 1
a527 1
galahad_context_set_polygon_stipple(struct pipe_context *_pipe,
d538 1
a538 3
galahad_context_set_scissor_states(struct pipe_context *_pipe,
                                   unsigned start_slot,
                                   unsigned num_scissors,
d544 2
a545 2
   pipe->set_scissor_states(pipe, start_slot, num_scissors,
                            scissor);
d549 1
a549 3
galahad_context_set_viewport_states(struct pipe_context *_pipe,
                                    unsigned start_slot,
                                    unsigned num_viewports,
d555 2
a556 2
   pipe->set_viewport_states(pipe, start_slot, num_viewports,
                             viewport);
d560 3
a562 5
galahad_context_set_sampler_views(struct pipe_context *_pipe,
                                  unsigned shader,
                                  unsigned start,
                                  unsigned num,
                                  struct pipe_sampler_view **_views)
d579 1
a579 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->set_vertex_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->set_fragment_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->set_geometry_sampler_views(pipe, num, views);
      break;
   default:
      assert(0);
   }
d583 3
a585 3
galahad_context_set_vertex_sampler_views(struct pipe_context *_pipe,
                                         unsigned num,
                                         struct pipe_sampler_view **_views)
d587 11
a597 3
   galahad_context_set_sampler_views(_pipe, PIPE_SHADER_VERTEX,
                                     0, num, _views);
}
d599 2
a600 8
static void
galahad_context_set_fragment_sampler_views(struct pipe_context *_pipe,
                                           unsigned num,
                                           struct pipe_sampler_view **_views)
{
   galahad_context_set_sampler_views(_pipe, PIPE_SHADER_FRAGMENT,
                                     0, num, _views);
}
d602 1
a602 7
static void
galahad_context_set_geometry_sampler_views(struct pipe_context *_pipe,
                                           unsigned num,
                                           struct pipe_sampler_view **_views)
{
   galahad_context_set_sampler_views(_pipe, PIPE_SHADER_GEOMETRY,
                                     0, num, _views);
d606 2
a607 2
galahad_context_set_vertex_buffers(struct pipe_context *_pipe,
                            unsigned start_slot, unsigned num_buffers,
d616 1
a616 1
   if (num_buffers && _buffers) {
d624 1
a624 1
                            start_slot, num_buffers,
d629 1
a629 1
galahad_context_set_index_buffer(struct pipe_context *_pipe,
d636 10
a645 15
   if (_ib) {
      if (_ib->buffer || _ib->user_buffer) {
         switch (_ib->index_size) {
         case 1:
         case 2:
         case 4:
            break;
         default:
            glhd_warn("unrecognized index size %d", _ib->index_size);
            break;
         }
      }
      else if (_ib->offset || _ib->index_size) {
         glhd_warn("non-indexed state with index offset %d and index size %d",
               _ib->offset, _ib->index_size);
d647 5
d653 1
a661 38
static INLINE struct pipe_stream_output_target *
galahad_context_create_stream_output_target(struct pipe_context *_pipe,
                                            struct pipe_resource *_res,
                                            unsigned buffer_offset,
                                            unsigned buffer_size)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct galahad_resource *glhd_resource_res = galahad_resource(_res);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_resource *res = glhd_resource_res->resource;

   return pipe->create_stream_output_target(pipe,
                                            res, buffer_offset, buffer_size);
}

static INLINE void
galahad_context_stream_output_target_destroy(
   struct pipe_context *_pipe,
   struct pipe_stream_output_target *target)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->stream_output_target_destroy(pipe, target);
}

static INLINE void
galahad_context_set_stream_output_targets(struct pipe_context *_pipe,
                                          unsigned num_targets,
                                          struct pipe_stream_output_target **tgs,
                                          unsigned append_bitmask)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;

   pipe->set_stream_output_targets(pipe, num_targets, tgs, append_bitmask);
}

d663 9
a671 9
galahad_context_resource_copy_region(struct pipe_context *_pipe,
                                     struct pipe_resource *_dst,
                                     unsigned dst_level,
                                     unsigned dstx,
                                     unsigned dsty,
                                     unsigned dstz,
                                     struct pipe_resource *_src,
                                     unsigned src_level,
                                     const struct pipe_box *src_box)
d681 3
a683 14
      const struct util_format_description *src_desc =
         util_format_description(_src->format);
      const struct util_format_description *dst_desc =
         util_format_description(_dst->format);
      if (!util_is_format_compatible(src_desc, dst_desc))
         glhd_warn("Format mismatch: Source is %s, destination is %s",
            src_desc->short_name,
            dst_desc->short_name);
   }

   if ((_src->target == PIPE_BUFFER && _dst->target != PIPE_BUFFER) ||
       (_src->target != PIPE_BUFFER && _dst->target == PIPE_BUFFER)) {
      glhd_warn("Resource target mismatch: Source is %i, destination is %i",
                _src->target, _dst->target);
d698 1
a698 30
galahad_context_blit(struct pipe_context *_pipe,
                     const struct pipe_blit_info *_info)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_blit_info info = *_info;

   info.dst.resource = galahad_resource_unwrap(info.dst.resource);
   info.src.resource = galahad_resource_unwrap(info.src.resource);

   if (info.dst.box.width < 0 ||
       info.dst.box.height < 0)
      glhd_error("Destination dimensions are negative");

   if (info.filter != PIPE_TEX_FILTER_NEAREST &&
       info.src.resource->target != PIPE_TEXTURE_3D &&
       info.dst.box.depth != info.src.box.depth)
      glhd_error("Filtering in z-direction on non-3D texture");

   if (util_format_is_depth_or_stencil(info.dst.format) !=
       util_format_is_depth_or_stencil(info.src.format))
      glhd_error("Invalid format conversion: %s <- %s\n",
                 util_format_name(info.dst.format),
                 util_format_name(info.src.format));

   pipe->blit(pipe, &info);
}

static void
galahad_context_clear(struct pipe_context *_pipe,
d700 1
a700 1
               const union pipe_color_union *color,
d709 1
a709 1
               color,
d715 1
a715 1
galahad_context_clear_render_target(struct pipe_context *_pipe,
d717 1
a717 1
                             const union pipe_color_union *color,
d728 1
a728 1
                             color,
d735 1
a735 1
galahad_context_clear_depth_stencil(struct pipe_context *_pipe,
d761 3
a763 3
galahad_context_flush(struct pipe_context *_pipe,
                      struct pipe_fence_handle **fence,
                      unsigned flags)
d768 20
a787 1
   pipe->flush(pipe, fence, flags);
d847 7
a853 7
static void *
galahad_context_transfer_map(struct pipe_context *_context,
                             struct pipe_resource *_resource,
                             unsigned level,
                             unsigned usage,
                             const struct pipe_box *box,
                             struct pipe_transfer **transfer)
a859 1
   void *map;
d861 29
a889 7
   map = context->transfer_map(context,
                               resource,
                               level,
                               usage,
                               box, &result);
   if (!map)
      return NULL;
d893 2
a894 2
   *transfer = galahad_transfer_create(glhd_context, glhd_resource, result);
   return *transfer ? map : NULL;
d897 2
d914 1
a933 3

   galahad_transfer_destroy(galahad_context(_context),
                             galahad_transfer(_transfer));
a962 13
static void
galahad_context_render_condition(struct pipe_context *_context,
                                 struct pipe_query *query,
                                 boolean condition,
                                 uint mode)
{
   struct galahad_context *glhd_context = galahad_context(_context);
   struct pipe_context *context = glhd_context->pipe;

   context->render_condition(context, query, condition, mode);
}


d974 1
d979 58
a1036 1
   glhd_pipe->base.destroy = galahad_context_destroy;
d1038 1
a1038 79
#define GLHD_PIPE_INIT(_member) \
   glhd_pipe->base . _member = pipe -> _member ? galahad_context_ ## _member : NULL

   GLHD_PIPE_INIT(draw_vbo);
   GLHD_PIPE_INIT(render_condition);
   GLHD_PIPE_INIT(create_query);
   GLHD_PIPE_INIT(destroy_query);
   GLHD_PIPE_INIT(begin_query);
   GLHD_PIPE_INIT(end_query);
   GLHD_PIPE_INIT(get_query_result);
   GLHD_PIPE_INIT(create_blend_state);
   GLHD_PIPE_INIT(bind_blend_state);
   GLHD_PIPE_INIT(delete_blend_state);
   GLHD_PIPE_INIT(create_sampler_state);
   GLHD_PIPE_INIT(bind_fragment_sampler_states);
   GLHD_PIPE_INIT(bind_vertex_sampler_states);
   GLHD_PIPE_INIT(bind_geometry_sampler_states);
   //GLHD_PIPE_INIT(bind_compute_sampler_states);
   GLHD_PIPE_INIT(delete_sampler_state);
   GLHD_PIPE_INIT(create_rasterizer_state);
   GLHD_PIPE_INIT(bind_rasterizer_state);
   GLHD_PIPE_INIT(delete_rasterizer_state);
   GLHD_PIPE_INIT(create_depth_stencil_alpha_state);
   GLHD_PIPE_INIT(bind_depth_stencil_alpha_state);
   GLHD_PIPE_INIT(delete_depth_stencil_alpha_state);
   GLHD_PIPE_INIT(create_fs_state);
   GLHD_PIPE_INIT(bind_fs_state);
   GLHD_PIPE_INIT(delete_fs_state);
   GLHD_PIPE_INIT(create_vs_state);
   GLHD_PIPE_INIT(bind_vs_state);
   GLHD_PIPE_INIT(delete_vs_state);
   GLHD_PIPE_INIT(create_gs_state);
   GLHD_PIPE_INIT(bind_gs_state);
   GLHD_PIPE_INIT(delete_gs_state);
   GLHD_PIPE_INIT(create_vertex_elements_state);
   GLHD_PIPE_INIT(bind_vertex_elements_state);
   GLHD_PIPE_INIT(delete_vertex_elements_state);
   GLHD_PIPE_INIT(set_blend_color);
   GLHD_PIPE_INIT(set_stencil_ref);
   GLHD_PIPE_INIT(set_sample_mask);
   GLHD_PIPE_INIT(set_clip_state);
   GLHD_PIPE_INIT(set_constant_buffer);
   GLHD_PIPE_INIT(set_framebuffer_state);
   GLHD_PIPE_INIT(set_polygon_stipple);
   GLHD_PIPE_INIT(set_scissor_states);
   GLHD_PIPE_INIT(set_viewport_states);
   GLHD_PIPE_INIT(set_fragment_sampler_views);
   GLHD_PIPE_INIT(set_vertex_sampler_views);
   GLHD_PIPE_INIT(set_geometry_sampler_views);
   //GLHD_PIPE_INIT(set_compute_sampler_views);
   //GLHD_PIPE_INIT(set_shader_resources);
   GLHD_PIPE_INIT(set_vertex_buffers);
   GLHD_PIPE_INIT(set_index_buffer);
   GLHD_PIPE_INIT(create_stream_output_target);
   GLHD_PIPE_INIT(stream_output_target_destroy);
   GLHD_PIPE_INIT(set_stream_output_targets);
   GLHD_PIPE_INIT(resource_copy_region);
   GLHD_PIPE_INIT(blit);
   GLHD_PIPE_INIT(clear);
   GLHD_PIPE_INIT(clear_render_target);
   GLHD_PIPE_INIT(clear_depth_stencil);
   GLHD_PIPE_INIT(flush);
   GLHD_PIPE_INIT(create_sampler_view);
   GLHD_PIPE_INIT(sampler_view_destroy);
   GLHD_PIPE_INIT(create_surface);
   GLHD_PIPE_INIT(surface_destroy);
   GLHD_PIPE_INIT(transfer_map);
   GLHD_PIPE_INIT(transfer_flush_region);
   GLHD_PIPE_INIT(transfer_unmap);
   GLHD_PIPE_INIT(transfer_inline_write);
   //GLHD_PIPE_INIT(texture_barrier);
   //GLHD_PIPE_INIT(create_video_decoder);
   //GLHD_PIPE_INIT(create_video_buffer);
   //GLHD_PIPE_INIT(create_compute_state);
   //GLHD_PIPE_INIT(bind_compute_state);
   //GLHD_PIPE_INIT(delete_compute_state);
   //GLHD_PIPE_INIT(set_compute_resources);
   //GLHD_PIPE_INIT(set_global_binding);
   //GLHD_PIPE_INIT(launch_grid);
d1040 1
a1040 3
#undef GLHD_PIPE_INIT

   glhd_pipe->pipe = pipe;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d200 22
a221 1
   pipe->bind_sampler_states(pipe, shader, start, num_samplers, samplers);
d225 19
d561 2
a562 1
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
d565 41
a605 2
   for (i = 0; i < num; i++)
      unwrapped_views[i] = galahad_sampler_view_unwrap(_views[i]);
d607 7
a613 1
   pipe->set_sampler_views(pipe, shader, start, num, unwrapped_views);
d702 1
a702 1
                                          const unsigned *offsets)
d707 1
a707 1
   pipe->set_stream_output_targets(pipe, num_targets, tgs, offsets);
a785 12
galahad_context_flush_resource(struct pipe_context *_pipe,
                               struct pipe_resource *_res)
{
   struct galahad_context *glhd_pipe = galahad_context(_pipe);
   struct galahad_resource *glhd_resource_res = galahad_resource(_res);
   struct pipe_context *pipe = glhd_pipe->pipe;
   struct pipe_resource *res = glhd_resource_res->resource;

   pipe->flush_resource(pipe, res);
}

static void
d1055 4
a1058 1
   GLHD_PIPE_INIT(bind_sampler_states);
d1087 4
a1090 1
   GLHD_PIPE_INIT(set_sampler_views);
a1098 1
   GLHD_PIPE_INIT(flush_resource);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d52 1
a52 1
                         const struct pipe_draw_info *info)
d61 1
a61 8
   if (info->indirect) {
      struct pipe_draw_info info_unwrapped = *info;
      info_unwrapped.indirect = galahad_resource_unwrap(info->indirect);
      pipe->draw_vbo(pipe, &info_unwrapped);
   }
   else {
      pipe->draw_vbo(pipe, info);
   }
d66 1
a66 2
                             unsigned query_type,
                             unsigned index)
d82 1
a82 2
                             query_type,
                             index);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d52 1
a52 1
                 const struct pipe_draw_info *info)
d61 8
a68 1
   pipe->draw_vbo(pipe, info);
d73 2
a74 1
                      unsigned query_type)
d90 2
a91 1
                             query_type);
@


