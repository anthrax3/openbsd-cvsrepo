head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.10;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.07;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.51;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.04;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.11;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * 2010 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "pipe/p_screen.h"
#include "pipe/p_state.h"
#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_format.h"

#include "glhd_public.h"
#include "glhd_screen.h"
#include "glhd_context.h"
#include "glhd_objects.h"

DEBUG_GET_ONCE_BOOL_OPTION(galahad, "GALLIUM_GALAHAD", FALSE)

static void
galahad_screen_destroy(struct pipe_screen *_screen)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   screen->destroy(screen);

   FREE(glhd_screen);
}

static const char *
galahad_screen_get_name(struct pipe_screen *_screen)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->get_name(screen);
}

static const char *
galahad_screen_get_vendor(struct pipe_screen *_screen)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->get_vendor(screen);
}

static int
galahad_screen_get_param(struct pipe_screen *_screen,
                          enum pipe_cap param)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->get_param(screen,
                            param);
}

static int
galahad_screen_get_shader_param(struct pipe_screen *_screen,
                          unsigned shader, enum pipe_shader_cap param)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->get_shader_param(screen, shader,
                            param);
}

static float
galahad_screen_get_paramf(struct pipe_screen *_screen,
                           enum pipe_capf param)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->get_paramf(screen,
                             param);
}

static boolean
galahad_screen_is_format_supported(struct pipe_screen *_screen,
                                    enum pipe_format format,
                                    enum pipe_texture_target target,
                                    unsigned sample_count,
                                    unsigned tex_usage)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   if (target >= PIPE_MAX_TEXTURE_TYPES) {
      glhd_warn("Received bogus texture target %d", target);
   }

   return screen->is_format_supported(screen,
                                      format,
                                      target,
                                      sample_count,
                                      tex_usage);
}

static struct pipe_context *
galahad_screen_context_create(struct pipe_screen *_screen,
                               void *priv)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;
   struct pipe_context *result;

   result = screen->context_create(screen, priv);
   if (result)
      return galahad_context_create(_screen, result);
   return NULL;
}

static struct pipe_resource *
galahad_screen_resource_create(struct pipe_screen *_screen,
                                const struct pipe_resource *templat)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;
   struct pipe_resource *result;

   glhd_check("%u", templat->width0, >= 1);
   glhd_check("%u", templat->height0, >= 1);
   glhd_check("%u", templat->depth0, >= 1);
   glhd_check("%u", templat->array_size, >= 1);

   if (templat->target == PIPE_BUFFER) {
      glhd_check("%u", templat->last_level, == 0);
      glhd_check("%u", templat->height0, == 1);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_1D) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_2d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, == 1);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_2D) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_2d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_CUBE) {
      unsigned max_texture_cube_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_cube_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_cube_levels - 1)));
      glhd_check("%u", templat->height0, == templat->width0);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 6);
   } else if (templat->target == PIPE_TEXTURE_RECT) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, == 0);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_3D) {
      unsigned max_texture_3d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_3D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_3d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_3d_levels - 1)));
      glhd_check("%u", templat->height0, <= (1 << (max_texture_3d_levels - 1)));
      glhd_check("%u", templat->depth0,  <= (1 << (max_texture_3d_levels - 1)));
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_1D_ARRAY) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_2d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, == 1);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, <= screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS));
   } else if (templat->target == PIPE_TEXTURE_2D_ARRAY) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_2d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, <= screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS));
   } else {
      glhd_warn("Received bogus resource target %d", templat->target);
   }

   if(templat->target != PIPE_TEXTURE_RECT && templat->target != PIPE_BUFFER && !screen->get_param(screen, PIPE_CAP_NPOT_TEXTURES))
   {
      if(!util_is_power_of_two(templat->width0) || !util_is_power_of_two(templat->height0))
         glhd_warn("Requested NPOT (%ux%u) non-rectangle texture without NPOT support", templat->width0, templat->height0);
   }

   if (templat->target != PIPE_BUFFER &&
       !screen->is_format_supported(screen, templat->format, templat->target, templat->nr_samples, templat->bind)) {
      glhd_warn("Requested format=%s target=%u samples=%u bind=0x%x unsupported",
         util_format_name(templat->format), templat->target, templat->nr_samples, templat->bind);
   }

   result = screen->resource_create(screen,
                                    templat);

   if (result)
      return galahad_resource_create(glhd_screen, result);
   return NULL;
}

static struct pipe_resource *
galahad_screen_resource_from_handle(struct pipe_screen *_screen,
                                     const struct pipe_resource *templ,
                                     struct winsys_handle *handle)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;
   struct pipe_resource *result;

   /* TODO trace call */

   result = screen->resource_from_handle(screen, templ, handle);

   result = galahad_resource_create(galahad_screen(_screen), result);

   return result;
}

static boolean
galahad_screen_resource_get_handle(struct pipe_screen *_screen,
                                    struct pipe_resource *_resource,
                                    struct winsys_handle *handle)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct galahad_resource *glhd_resource = galahad_resource(_resource);
   struct pipe_screen *screen = glhd_screen->screen;
   struct pipe_resource *resource = glhd_resource->resource;

   /* TODO trace call */

   return screen->resource_get_handle(screen, resource, handle);
}



static void
galahad_screen_resource_destroy(struct pipe_screen *screen,
                                 struct pipe_resource *_resource)
{
   galahad_resource_destroy(galahad_resource(_resource));
}


static void
galahad_screen_flush_frontbuffer(struct pipe_screen *_screen,
                                  struct pipe_resource *_resource,
                                  unsigned level, unsigned layer,
                                  void *context_private,
                                  struct pipe_box *sub_box)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct galahad_resource *glhd_resource = galahad_resource(_resource);
   struct pipe_screen *screen = glhd_screen->screen;
   struct pipe_resource *resource = glhd_resource->resource;

   screen->flush_frontbuffer(screen,
                             resource,
                             level, layer,
                             context_private, sub_box);
}

static void
galahad_screen_fence_reference(struct pipe_screen *_screen,
                                struct pipe_fence_handle **ptr,
                                struct pipe_fence_handle *fence)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   screen->fence_reference(screen,
                           ptr,
                           fence);
}

static boolean
galahad_screen_fence_signalled(struct pipe_screen *_screen,
                                struct pipe_fence_handle *fence)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->fence_signalled(screen,
                                  fence);
}

static boolean
galahad_screen_fence_finish(struct pipe_screen *_screen,
                             struct pipe_fence_handle *fence,
                             uint64_t timeout)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->fence_finish(screen,
                               fence,
                               timeout);
}

static uint64_t
galahad_screen_get_timestamp(struct pipe_screen *_screen)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->get_timestamp(screen);
}

struct pipe_screen *
galahad_screen_create(struct pipe_screen *screen)
{
   struct galahad_screen *glhd_screen;

   if (!debug_get_option_galahad())
      return screen;

   glhd_screen = CALLOC_STRUCT(galahad_screen);
   if (!glhd_screen) {
      return screen;
   }

#define GLHD_SCREEN_INIT(_member) \
   glhd_screen->base . _member = screen -> _member ? galahad_screen_ ## _member : NULL

   GLHD_SCREEN_INIT(destroy);
   GLHD_SCREEN_INIT(get_name);
   GLHD_SCREEN_INIT(get_vendor);
   GLHD_SCREEN_INIT(get_param);
   GLHD_SCREEN_INIT(get_shader_param);
   //GLHD_SCREEN_INIT(get_video_param);
   //GLHD_SCREEN_INIT(get_compute_param);
   GLHD_SCREEN_INIT(get_paramf);
   GLHD_SCREEN_INIT(is_format_supported);
   //GLHD_SCREEN_INIT(is_video_format_supported);
   GLHD_SCREEN_INIT(context_create);
   GLHD_SCREEN_INIT(resource_create);
   GLHD_SCREEN_INIT(resource_from_handle);
   GLHD_SCREEN_INIT(resource_get_handle);
   GLHD_SCREEN_INIT(resource_destroy);
   GLHD_SCREEN_INIT(flush_frontbuffer);
   GLHD_SCREEN_INIT(fence_reference);
   GLHD_SCREEN_INIT(fence_signalled);
   GLHD_SCREEN_INIT(fence_finish);
   GLHD_SCREEN_INIT(get_timestamp);

#undef GLHD_SCREEN_INIT

   glhd_screen->screen = screen;

   return &glhd_screen->base;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a178 7
   } else if (templat->target == PIPE_TEXTURE_CUBE_ARRAY) {
      unsigned max_texture_cube_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_cube_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_cube_levels - 1)));
      glhd_check("%u", templat->height0, == templat->width0);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, % 6 == 0);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d179 7
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d278 2
a279 1
                                  void *context_private)
d289 1
a289 1
                             context_private);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d34 1
d96 1
a96 1
                           enum pipe_cap param)
d148 60
a207 1
   if (templat->target >= PIPE_MAX_TEXTURE_TYPES)
d209 1
d217 5
a221 17
   if(templat->target == PIPE_TEXTURE_RECT && templat->last_level)
      glhd_warn("Rectangle textures cannot have mipmaps, but last_level = %u", templat->last_level);

   if(templat->target == PIPE_BUFFER && templat->last_level)
      glhd_warn("Buffers cannot have mipmaps, but last_level = %u", templat->last_level);

   if(templat->target != PIPE_TEXTURE_3D && templat->depth0 != 1)
      glhd_warn("Only 3D textures can have depth != 1, but received target %u and depth %u", templat->target, templat->depth0);

   if(templat->target == PIPE_TEXTURE_1D && templat->height0 != 1)
     glhd_warn("1D textures must have height 1 but got asked for height %u", templat->height0);

   if(templat->target == PIPE_BUFFER && templat->height0 != 1)
     glhd_warn("Buffers must have height 1 but got asked for height %u", templat->height0);

   if(templat->target == PIPE_TEXTURE_CUBE && templat->width0 != templat->height0)
      glhd_warn("Cube maps must be square, but got asked for %ux%u", templat->width0, templat->height0);
a273 22
static struct pipe_resource *
galahad_screen_user_buffer_create(struct pipe_screen *_screen,
                                   void *ptr,
                                   unsigned bytes,
                                   unsigned usage)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;
   struct pipe_resource *result;

   result = screen->user_buffer_create(screen,
                                       ptr,
                                       bytes,
                                       usage);

   if (result)
      return galahad_resource_create(glhd_screen, result);
   return NULL;
}



d328 9
d350 23
a372 1
   glhd_screen->base.winsys = NULL;
d374 1
a374 17
   glhd_screen->base.destroy = galahad_screen_destroy;
   glhd_screen->base.get_name = galahad_screen_get_name;
   glhd_screen->base.get_vendor = galahad_screen_get_vendor;
   glhd_screen->base.get_param = galahad_screen_get_param;
   glhd_screen->base.get_shader_param = galahad_screen_get_shader_param;
   glhd_screen->base.get_paramf = galahad_screen_get_paramf;
   glhd_screen->base.is_format_supported = galahad_screen_is_format_supported;
   glhd_screen->base.context_create = galahad_screen_context_create;
   glhd_screen->base.resource_create = galahad_screen_resource_create;
   glhd_screen->base.resource_from_handle = galahad_screen_resource_from_handle;
   glhd_screen->base.resource_get_handle = galahad_screen_resource_get_handle;
   glhd_screen->base.resource_destroy = galahad_screen_resource_destroy;
   glhd_screen->base.user_buffer_create = galahad_screen_user_buffer_create;
   glhd_screen->base.flush_frontbuffer = galahad_screen_flush_frontbuffer;
   glhd_screen->base.fence_reference = galahad_screen_fence_reference;
   glhd_screen->base.fence_signalled = galahad_screen_fence_signalled;
   glhd_screen->base.fence_finish = galahad_screen_fence_finish;
a376 2

   glhd_warn("Created screen %p", (void *) glhd_screen);
@


1.1
log
@Initial revision
@
text
@d109 1
a109 2
                                    unsigned tex_usage,
                                    unsigned geom_flags)
d122 1
a122 2
                                      tex_usage,
                                      geom_flags);
d277 1
a277 1
static int
d279 1
a279 2
                                struct pipe_fence_handle *fence,
                                unsigned flags)
d285 1
a285 2
                                  fence,
                                  flags);
d288 1
a288 1
static int
d291 1
a291 1
                             unsigned flags)
d298 1
a298 1
                               flags);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a33 1
#include "util/u_format.h"
d95 1
a95 1
                           enum pipe_capf param)
d109 2
a110 1
                                    unsigned tex_usage)
d123 2
a124 1
                                      tex_usage);
d149 1
a149 60
   glhd_check("%u", templat->width0, >= 1);
   glhd_check("%u", templat->height0, >= 1);
   glhd_check("%u", templat->depth0, >= 1);
   glhd_check("%u", templat->array_size, >= 1);

   if (templat->target == PIPE_BUFFER) {
      glhd_check("%u", templat->last_level, == 0);
      glhd_check("%u", templat->height0, == 1);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_1D) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_2d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, == 1);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_2D) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_2d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_CUBE) {
      unsigned max_texture_cube_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_cube_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_cube_levels - 1)));
      glhd_check("%u", templat->height0, == templat->width0);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 6);
   } else if (templat->target == PIPE_TEXTURE_RECT) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, == 0);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_3D) {
      unsigned max_texture_3d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_3D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_3d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_3d_levels - 1)));
      glhd_check("%u", templat->height0, <= (1 << (max_texture_3d_levels - 1)));
      glhd_check("%u", templat->depth0,  <= (1 << (max_texture_3d_levels - 1)));
      glhd_check("%u", templat->array_size, == 1);
   } else if (templat->target == PIPE_TEXTURE_1D_ARRAY) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_2d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, == 1);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, <= screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS));
   } else if (templat->target == PIPE_TEXTURE_2D_ARRAY) {
      unsigned max_texture_2d_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_2d_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->height0, <= (1 << (max_texture_2d_levels - 1)));
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, <= screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS));
   } else {
a150 1
   }
d158 17
a174 5
   if (templat->target != PIPE_BUFFER &&
       !screen->is_format_supported(screen, templat->format, templat->target, templat->nr_samples, templat->bind)) {
      glhd_warn("Requested format=%s target=%u samples=%u bind=0x%x unsupported",
         util_format_name(templat->format), templat->target, templat->nr_samples, templat->bind);
   }
d227 22
d279 1
a279 1
static boolean
d281 2
a282 1
                                struct pipe_fence_handle *fence)
d288 2
a289 1
                                  fence);
d292 1
a292 1
static boolean
d295 1
a295 1
                             uint64_t timeout)
d302 1
a302 10
                               timeout);
}

static uint64_t
galahad_screen_get_timestamp(struct pipe_screen *_screen)
{
   struct galahad_screen *glhd_screen = galahad_screen(_screen);
   struct pipe_screen *screen = glhd_screen->screen;

   return screen->get_timestamp(screen);
d318 1
a318 2
#define GLHD_SCREEN_INIT(_member) \
   glhd_screen->base . _member = screen -> _member ? galahad_screen_ ## _member : NULL
d320 17
a336 20
   GLHD_SCREEN_INIT(destroy);
   GLHD_SCREEN_INIT(get_name);
   GLHD_SCREEN_INIT(get_vendor);
   GLHD_SCREEN_INIT(get_param);
   GLHD_SCREEN_INIT(get_shader_param);
   //GLHD_SCREEN_INIT(get_video_param);
   //GLHD_SCREEN_INIT(get_compute_param);
   GLHD_SCREEN_INIT(get_paramf);
   GLHD_SCREEN_INIT(is_format_supported);
   //GLHD_SCREEN_INIT(is_video_format_supported);
   GLHD_SCREEN_INIT(context_create);
   GLHD_SCREEN_INIT(resource_create);
   GLHD_SCREEN_INIT(resource_from_handle);
   GLHD_SCREEN_INIT(resource_get_handle);
   GLHD_SCREEN_INIT(resource_destroy);
   GLHD_SCREEN_INIT(flush_frontbuffer);
   GLHD_SCREEN_INIT(fence_reference);
   GLHD_SCREEN_INIT(fence_signalled);
   GLHD_SCREEN_INIT(fence_finish);
   GLHD_SCREEN_INIT(get_timestamp);
d338 1
a338 1
#undef GLHD_SCREEN_INIT
d340 1
a340 1
   glhd_screen->screen = screen;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d278 1
a278 2
                                  void *context_private,
                                  struct pipe_box *sub_box)
d288 1
a288 1
                             context_private, sub_box);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a178 7
   } else if (templat->target == PIPE_TEXTURE_CUBE_ARRAY) {
      unsigned max_texture_cube_levels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS);
      glhd_check("%u", templat->last_level, < max_texture_cube_levels);
      glhd_check("%u", templat->width0,  <= (1 << (max_texture_cube_levels - 1)));
      glhd_check("%u", templat->height0, == templat->width0);
      glhd_check("%u", templat->depth0,  == 1);
      glhd_check("%u", templat->array_size, % 6 == 0);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d179 7
@


