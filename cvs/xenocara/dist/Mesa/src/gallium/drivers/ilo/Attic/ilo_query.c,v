head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.11.17;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.17;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.33.53;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.07.14;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.44.24;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2012-2013 LunarG, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#include "intel_winsys.h"

#include "ilo_3d.h"
#include "ilo_context.h"
#include "ilo_cp.h"
#include "ilo_query.h"

static const struct {
   const char *name;

   void (*begin)(struct ilo_context *ilo, struct ilo_query *q);
   void (*end)(struct ilo_context *ilo, struct ilo_query *q);
   void (*process)(struct ilo_context *ilo, struct ilo_query *q);
} query_info[PIPE_QUERY_TYPES] = {
#define INFO(prefix, desc) {        \
   .name = desc,                    \
   .begin = prefix ## _begin_query, \
   .end = prefix ## _end_query,     \
   .process = prefix ## _process_query, \
}
#define INFOX(prefix, desc) { desc, NULL, NULL, NULL, }

   [PIPE_QUERY_OCCLUSION_COUNTER]      = INFO(ilo_3d, "occlusion counter"),
   [PIPE_QUERY_OCCLUSION_PREDICATE]    = INFOX(ilo_3d, "occlusion pred."),
   [PIPE_QUERY_TIMESTAMP]              = INFO(ilo_3d, "timestamp"),
   [PIPE_QUERY_TIMESTAMP_DISJOINT]     = INFOX(ilo_3d, "timestamp disjoint"),
   [PIPE_QUERY_TIME_ELAPSED]           = INFO(ilo_3d, "time elapsed"),
   [PIPE_QUERY_PRIMITIVES_GENERATED]   = INFO(ilo_3d, "primitives generated"),
   [PIPE_QUERY_PRIMITIVES_EMITTED]     = INFO(ilo_3d, "primitives emitted"),
   [PIPE_QUERY_SO_STATISTICS]          = INFOX(ilo_3d, "so statistics"),
   [PIPE_QUERY_SO_OVERFLOW_PREDICATE]  = INFOX(ilo_3d, "so overflow pred."),
   [PIPE_QUERY_GPU_FINISHED]           = INFOX(ilo_3d, "gpu finished"),
   [PIPE_QUERY_PIPELINE_STATISTICS]    = INFOX(ilo_3d, "pipeline statistics"),

#undef INFO
#undef INFOX
};

static inline struct ilo_query *
ilo_query(struct pipe_query *query)
{
   return (struct ilo_query *) query;
}

static struct pipe_query *
ilo_create_query(struct pipe_context *pipe, unsigned query_type)
{
   struct ilo_query *q;

   switch (query_type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
   case PIPE_QUERY_TIMESTAMP:
   case PIPE_QUERY_TIME_ELAPSED:
   case PIPE_QUERY_PRIMITIVES_GENERATED:
   case PIPE_QUERY_PRIMITIVES_EMITTED:
      break;
   default:
      return NULL;
   }

   q = CALLOC_STRUCT(ilo_query);
   if (!q)
      return NULL;

   q->type = query_type;
   list_inithead(&q->list);

   return (struct pipe_query *) q;
}

static void
ilo_destroy_query(struct pipe_context *pipe, struct pipe_query *query)
{
   struct ilo_query *q = ilo_query(query);

   if (q->bo)
      intel_bo_unreference(q->bo);

   FREE(q);
}

static void
ilo_begin_query(struct pipe_context *pipe, struct pipe_query *query)
{
   struct ilo_context *ilo = ilo_context(pipe);
   struct ilo_query *q = ilo_query(query);

   q->active = true;

   query_info[q->type].begin(ilo, q);
}

static void
ilo_end_query(struct pipe_context *pipe, struct pipe_query *query)
{
   struct ilo_context *ilo = ilo_context(pipe);
   struct ilo_query *q = ilo_query(query);

   query_info[q->type].end(ilo, q);

   /*
    * some queries such as timestamp query does not require a call to
    * begin_query() so q->active is always false
    */
   q->active = false;
}

/**
 * The type (union pipe_query_result) indicates only the size of the buffer.
 * Callers expect the result to be "serialized".
 */
static void
serialize_query_data(unsigned type, const union pipe_query_result *data,
                     void *buf)
{
   switch (type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
   case PIPE_QUERY_TIMESTAMP:
   case PIPE_QUERY_TIME_ELAPSED:
   case PIPE_QUERY_PRIMITIVES_GENERATED:
   case PIPE_QUERY_PRIMITIVES_EMITTED:
      {
         uint64_t *r = buf;
         r[0] = data->u64;
      }
      break;
   default:
      memset(buf, 0, sizeof(union pipe_query_result));
      break;
   }
}

static boolean
ilo_get_query_result(struct pipe_context *pipe, struct pipe_query *query,
                     boolean wait, union pipe_query_result *result)
{
   struct ilo_context *ilo = ilo_context(pipe);
   struct ilo_query *q = ilo_query(query);

   if (q->active)
      return false;

   if (q->bo) {
      if (intel_bo_references(ilo->cp->bo, q->bo))
         ilo_cp_flush(ilo->cp);

      if (!wait && intel_bo_is_busy(q->bo))
         return false;

      query_info[q->type].process(ilo, q);
   }

   if (result)
      serialize_query_data(q->type, &q->data, (void *) result);

   return true;
}

/**
 * Allocate a query bo for reading hardware statistics.
 *
 * \param reg_count specifies how many registers need to be read.
 * \param repeat_count specifies how many times the registers are read.  If
 *        zero or negative, a 4KB bo is allocated.
 */
bool
ilo_query_alloc_bo(struct ilo_query *q, int reg_count, int repeat_count,
                   struct intel_winsys *winsys)
{
   const char *name;
   int reg_total;

   name = query_info[q->type].name;

   reg_total = reg_count * repeat_count;
   if (reg_total <= 0)
      reg_total = 4096 / sizeof(uint64_t);

   /* (re-)allocate the bo */
   if (q->reg_total < reg_total) {
      /* registers are 64-bit */
      const int size = reg_total * sizeof(uint64_t);

      if (q->bo)
         intel_bo_unreference(q->bo);

      q->bo = intel_winsys_alloc_buffer(winsys, name, size, 0);
      q->reg_total = (q->bo) ? reg_total : 0;
   }

   /* avoid partial reads */
   if (reg_count)
      q->reg_total -= q->reg_total % reg_count;

   q->reg_read = 0;

   return (q->bo != NULL);
}

/**
 * Initialize query-related functions.
 */
void
ilo_init_query_functions(struct ilo_context *ilo)
{
   ilo->base.create_query = ilo_create_query;
   ilo->base.destroy_query = ilo_destroy_query;
   ilo->base.begin_query = ilo_begin_query;
   ilo->base.end_query = ilo_end_query;
   ilo->base.get_query_result = ilo_get_query_result;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d60 1
a60 1
   [PIPE_QUERY_PIPELINE_STATISTICS]    = INFO(ilo_3d, "pipeline statistics"),
a82 1
   case PIPE_QUERY_PIPELINE_STATISTICS:
a153 16
   case PIPE_QUERY_PIPELINE_STATISTICS:
      {
         uint64_t *r = buf;
         r[0] = data->pipeline_statistics.ia_vertices;
         r[1] = data->pipeline_statistics.ia_primitives;
         r[2] = data->pipeline_statistics.vs_invocations;
         r[3] = data->pipeline_statistics.gs_invocations;
         r[4] = data->pipeline_statistics.gs_primitives;
         r[5] = data->pipeline_statistics.c_invocations;
         r[6] = data->pipeline_statistics.c_primitives;
         r[7] = data->pipeline_statistics.ps_invocations;
         r[8] = data->pipeline_statistics.hs_invocations;
         r[9] = data->pipeline_statistics.ds_invocations;
         r[10] = data->pipeline_statistics.cs_invocations;
      }
      break;
d171 2
a172 2
      if (intel_bo_has_reloc(ilo->cp->bo, q->bo))
         ilo_cp_flush(ilo->cp, "syncing for queries");
d214 1
a214 2
      q->bo = intel_winsys_alloc_buffer(winsys,
            name, size, INTEL_DOMAIN_INSTRUCTION);
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d30 1
a32 1
#include "ilo_draw.h"
d36 2
a37 1
   bool (*init)(struct ilo_context *ilo, struct ilo_query *q);
d41 20
a60 20
} ilo_query_table[PIPE_QUERY_TYPES] = {
#define INFO(mod) {                    \
   .init = ilo_init_ ## mod ## _query,         \
   .begin = ilo_begin_ ## mod ## _query,       \
   .end = ilo_end_ ## mod ## _query,           \
   .process = ilo_process_ ## mod ## _query,   \
}
#define INFOX(prefix) { NULL, NULL, NULL, NULL, }

   [PIPE_QUERY_OCCLUSION_COUNTER]      = INFO(draw),
   [PIPE_QUERY_OCCLUSION_PREDICATE]    = INFOX(draw),
   [PIPE_QUERY_TIMESTAMP]              = INFO(draw),
   [PIPE_QUERY_TIMESTAMP_DISJOINT]     = INFOX(draw),
   [PIPE_QUERY_TIME_ELAPSED]           = INFO(draw),
   [PIPE_QUERY_PRIMITIVES_GENERATED]   = INFO(draw),
   [PIPE_QUERY_PRIMITIVES_EMITTED]     = INFO(draw),
   [PIPE_QUERY_SO_STATISTICS]          = INFOX(draw),
   [PIPE_QUERY_SO_OVERFLOW_PREDICATE]  = INFOX(draw),
   [PIPE_QUERY_GPU_FINISHED]           = INFOX(draw),
   [PIPE_QUERY_PIPELINE_STATISTICS]    = INFO(draw),
d73 1
a73 1
ilo_create_query(struct pipe_context *pipe, unsigned query_type, unsigned index)
a93 2
   q->index = index;

a95 5
   if (!ilo_query_table[q->type].init(ilo_context(pipe), q)) {
      FREE(q);
      return NULL;
   }

d113 1
a115 5
   if (q->active)
      return;

   util_query_clear_result(&q->result, q->type);
   q->used = 0;
d118 1
a118 1
   ilo_query_table[q->type].begin(ilo_context(pipe), q);
d124 1
d127 1
a127 7
   if (!q->active) {
      /* require ilo_begin_query() first */
      if (q->in_pairs)
         return;

      ilo_begin_query(pipe, query);
   }
d129 4
a133 2

   ilo_query_table[q->type].end(ilo_context(pipe), q);
d137 2
a138 2
 * Serialize the result.  The size of \p buf is
 * sizeof(union pipe_query_result).
d141 2
a142 1
query_serialize(const struct ilo_query *q, void *buf)
d144 1
a144 1
   switch (q->type) {
d151 2
a152 2
         uint64_t *dst = buf;
         dst[0] = q->result.u64;
d157 12
a168 15
         const struct pipe_query_data_pipeline_statistics *stats =
            &q->result.pipeline_statistics;
         uint64_t *dst = buf;

         dst[0] = stats->ia_vertices;
         dst[1] = stats->ia_primitives;
         dst[2] = stats->vs_invocations;
         dst[3] = stats->gs_invocations;
         dst[4] = stats->gs_primitives;
         dst[5] = stats->c_invocations;
         dst[6] = stats->c_primitives;
         dst[7] = stats->ps_invocations;
         dst[8] = stats->hs_invocations;
         dst[9] = stats->ds_invocations;
         dst[10] = stats->cs_invocations;
d181 1
d188 2
a189 4
      struct ilo_cp *cp = ilo_context(pipe)->cp;

      if (ilo_builder_has_reloc(&cp->builder, q->bo))
         ilo_cp_submit(cp, "syncing for queries");
d193 2
a196 2
   ilo_query_table[q->type].process(ilo_context(pipe), q);

d198 1
a198 1
      query_serialize(q, (void *) result);
d201 42
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@a29 1
#include "ilo_3d.h"
d32 1
d36 1
a36 2
   const char *name;

d40 20
a59 20
} query_info[PIPE_QUERY_TYPES] = {
#define INFO(prefix, desc) {        \
   .name = desc,                    \
   .begin = prefix ## _begin_query, \
   .end = prefix ## _end_query,     \
   .process = prefix ## _process_query, \
}
#define INFOX(prefix, desc) { desc, NULL, NULL, NULL, }

   [PIPE_QUERY_OCCLUSION_COUNTER]      = INFO(ilo_3d, "occlusion counter"),
   [PIPE_QUERY_OCCLUSION_PREDICATE]    = INFOX(ilo_3d, "occlusion pred."),
   [PIPE_QUERY_TIMESTAMP]              = INFO(ilo_3d, "timestamp"),
   [PIPE_QUERY_TIMESTAMP_DISJOINT]     = INFOX(ilo_3d, "timestamp disjoint"),
   [PIPE_QUERY_TIME_ELAPSED]           = INFO(ilo_3d, "time elapsed"),
   [PIPE_QUERY_PRIMITIVES_GENERATED]   = INFO(ilo_3d, "primitives generated"),
   [PIPE_QUERY_PRIMITIVES_EMITTED]     = INFO(ilo_3d, "primitives emitted"),
   [PIPE_QUERY_SO_STATISTICS]          = INFOX(ilo_3d, "so statistics"),
   [PIPE_QUERY_SO_OVERFLOW_PREDICATE]  = INFOX(ilo_3d, "so overflow pred."),
   [PIPE_QUERY_GPU_FINISHED]           = INFOX(ilo_3d, "gpu finished"),
   [PIPE_QUERY_PIPELINE_STATISTICS]    = INFO(ilo_3d, "pipeline statistics"),
d72 1
a72 1
ilo_create_query(struct pipe_context *pipe, unsigned query_type)
d93 2
d97 5
a118 1
   struct ilo_context *ilo = ilo_context(pipe);
d121 5
d128 1
a128 1
   query_info[q->type].begin(ilo, q);
a133 1
   struct ilo_context *ilo = ilo_context(pipe);
d136 7
a142 1
   query_info[q->type].end(ilo, q);
a143 4
   /*
    * some queries such as timestamp query does not require a call to
    * begin_query() so q->active is always false
    */
d145 2
d150 2
a151 2
 * The type (union pipe_query_result) indicates only the size of the buffer.
 * Callers expect the result to be "serialized".
d154 1
a154 2
serialize_query_data(unsigned type, const union pipe_query_result *data,
                     void *buf)
d156 1
a156 1
   switch (type) {
d163 2
a164 2
         uint64_t *r = buf;
         r[0] = data->u64;
d169 15
a183 12
         uint64_t *r = buf;
         r[0] = data->pipeline_statistics.ia_vertices;
         r[1] = data->pipeline_statistics.ia_primitives;
         r[2] = data->pipeline_statistics.vs_invocations;
         r[3] = data->pipeline_statistics.gs_invocations;
         r[4] = data->pipeline_statistics.gs_primitives;
         r[5] = data->pipeline_statistics.c_invocations;
         r[6] = data->pipeline_statistics.c_primitives;
         r[7] = data->pipeline_statistics.ps_invocations;
         r[8] = data->pipeline_statistics.hs_invocations;
         r[9] = data->pipeline_statistics.ds_invocations;
         r[10] = data->pipeline_statistics.cs_invocations;
a195 1
   struct ilo_context *ilo = ilo_context(pipe);
d202 4
a205 2
      if (intel_bo_has_reloc(ilo->cp->bo, q->bo))
         ilo_cp_flush(ilo->cp, "syncing for queries");
d209 1
d211 1
a211 2
      query_info[q->type].process(ilo, q);
   }
d214 1
a214 1
      serialize_query_data(q->type, &q->data, (void *) result);
a216 42
}

/**
 * Allocate a query bo for reading hardware statistics.
 *
 * \param reg_count specifies how many registers need to be read.
 * \param repeat_count specifies how many times the registers are read.  If
 *        zero or negative, a 4KB bo is allocated.
 */
bool
ilo_query_alloc_bo(struct ilo_query *q, int reg_count, int repeat_count,
                   struct intel_winsys *winsys)
{
   const char *name;
   int reg_total;

   name = query_info[q->type].name;

   reg_total = reg_count * repeat_count;
   if (reg_total <= 0)
      reg_total = 4096 / sizeof(uint64_t);

   /* (re-)allocate the bo */
   if (q->reg_total < reg_total) {
      /* registers are 64-bit */
      const int size = reg_total * sizeof(uint64_t);

      if (q->bo)
         intel_bo_unreference(q->bo);

      q->bo = intel_winsys_alloc_buffer(winsys,
            name, size, INTEL_DOMAIN_INSTRUCTION);
      q->reg_total = (q->bo) ? reg_total : 0;
   }

   /* avoid partial reads */
   if (reg_count)
      q->reg_total -= q->reg_total % reg_count;

   q->reg_read = 0;

   return (q->bo != NULL);
@


