head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.11.13;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.13;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.33.53;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.07.13;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.44.20;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2012-2013 LunarG, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#include "intel_reg.h" /* for MI_xxx */
#include "intel_winsys.h"

#include "ilo_cp.h"

/* the size of the private space */
static const int ilo_cp_private = 2;

/**
 * Dump the contents of the parser bo.  This can only be called in the flush
 * callback.
 */
void
ilo_cp_dump(struct ilo_cp *cp)
{
   ilo_printf("dumping %d bytes\n", cp->used * 4);
   if (cp->used)
      intel_winsys_decode_commands(cp->winsys, cp->bo, cp->used * 4);
}

/**
 * Save the command parser state for rewind.
 *
 * Note that this cannot rewind a flush, and the caller must make sure
 * that does not happend.
 */
void
ilo_cp_setjmp(struct ilo_cp *cp, struct ilo_cp_jmp_buf *jmp)
{
   jmp->id = pointer_to_intptr(cp->bo);

   jmp->size = cp->size;
   jmp->used = cp->used;
   jmp->stolen = cp->stolen;
   /* save reloc count to rewind ilo_cp_write_bo() */
   jmp->reloc_count = intel_bo_get_reloc_count(cp->bo);
}

/**
 * Rewind to the saved state.
 */
void
ilo_cp_longjmp(struct ilo_cp *cp, const struct ilo_cp_jmp_buf *jmp)
{
   if (jmp->id != pointer_to_intptr(cp->bo)) {
      assert(!"invalid use of CP longjmp");
      return;
   }

   cp->size = jmp->size;
   cp->used = jmp->used;
   cp->stolen = jmp->stolen;
   intel_bo_clear_relocs(cp->bo, jmp->reloc_count);
}

/**
 * Clear the parser buffer.
 */
static void
ilo_cp_clear_buffer(struct ilo_cp *cp)
{
   cp->cmd_cur = 0;
   cp->cmd_end = 0;

   cp->used = 0;
   cp->stolen = 0;

   /*
    * Recalculate cp->size.  This is needed not only because cp->stolen is
    * reset above, but also that ilo_cp_private are added to cp->size in
    * ilo_cp_end_buffer().
    */
   cp->size = cp->bo_size - ilo_cp_private;
}

/**
 * Add MI_BATCH_BUFFER_END to the private space of the parser buffer.
 */
static void
ilo_cp_end_buffer(struct ilo_cp *cp)
{
   /* make the private space available */
   cp->size += ilo_cp_private;

   assert(cp->used + 2 <= cp->size);

   cp->ptr[cp->used++] = MI_BATCH_BUFFER_END;

   /*
    * From the Sandy Bridge PRM, volume 1 part 1, page 107:
    *
    *     "The batch buffer must be QWord aligned and a multiple of QWords in
    *      length."
    */
   if (cp->used & 1)
      cp->ptr[cp->used++] = MI_NOOP;
}

/**
 * Upload the parser buffer to the bo.
 */
static int
ilo_cp_upload_buffer(struct ilo_cp *cp)
{
   int err;

   if (!cp->sys) {
      intel_bo_unmap(cp->bo);
      return 0;
   }

   err = intel_bo_pwrite(cp->bo, 0, cp->used * 4, cp->ptr);
   if (likely(!err && cp->stolen)) {
      const int offset = cp->bo_size - cp->stolen;

      err = intel_bo_pwrite(cp->bo, offset * 4,
            cp->stolen * 4, &cp->ptr[offset]);
   }

   return err;
}

/**
 * Reallocate the parser bo.
 */
static void
ilo_cp_realloc_bo(struct ilo_cp *cp)
{
   struct intel_bo *bo;

   /*
    * allocate the new bo before unreferencing the old one so that they
    * won't point at the same address, which is needed for jmpbuf
    */
   bo = intel_winsys_alloc_buffer(cp->winsys,
         "batch buffer", cp->bo_size * 4, 0);
   if (unlikely(!bo)) {
      /* reuse the old one */
      bo = cp->bo;
      intel_bo_reference(bo);
   }

   if (cp->bo)
      intel_bo_unreference(cp->bo);
   cp->bo = bo;

   if (!cp->sys) {
      intel_bo_map(cp->bo, true);
      cp->ptr = intel_bo_get_virtual(cp->bo);
   }
}

/**
 * Execute the parser bo.
 */
static int
ilo_cp_exec_bo(struct ilo_cp *cp)
{
   const bool do_exec = !(ilo_debug & ILO_DEBUG_NOHW);
   struct intel_context *ctx;
   unsigned long flags;
   int err;

   switch (cp->ring) {
   case ILO_CP_RING_RENDER:
      ctx = cp->render_ctx;
      flags = INTEL_EXEC_RENDER;
      break;
   case ILO_CP_RING_BLT:
      ctx = NULL;
      flags = INTEL_EXEC_BLT;
      break;
   default:
      ctx = NULL;
      flags = 0;
      break;
   }

   flags |= cp->one_off_flags;

   if (likely(do_exec))
      err = intel_bo_exec(cp->bo, cp->used * 4, ctx, flags);
   else
      err = 0;

   cp->one_off_flags = 0;

   return err;
}

/**
 * Flush the command parser and execute the commands.  When the parser buffer
 * is empty, the callback is not invoked.
 */
void
ilo_cp_flush(struct ilo_cp *cp)
{
   int err;

   ilo_cp_set_owner(cp, NULL, 0);

   /* sanity check */
   assert(cp->bo_size == cp->size + cp->stolen + ilo_cp_private);

   if (!cp->used) {
      /* return the space stolen and etc. */
      ilo_cp_clear_buffer(cp);

      return;
   }

   ilo_cp_end_buffer(cp);

   /* upload and execute */
   err = ilo_cp_upload_buffer(cp);
   if (likely(!err))
      err = ilo_cp_exec_bo(cp);

   if (likely(!err && cp->flush_callback))
      cp->flush_callback(cp, cp->flush_callback_data);

   ilo_cp_clear_buffer(cp);
   ilo_cp_realloc_bo(cp);
}

/**
 * Destroy the command parser.
 */
void
ilo_cp_destroy(struct ilo_cp *cp)
{
   if (cp->bo) {
      if (!cp->sys)
         intel_bo_unmap(cp->bo);

      intel_bo_unreference(cp->bo);
   }

   if (cp->render_ctx)
      intel_winsys_destroy_context(cp->winsys, cp->render_ctx);

   FREE(cp->sys);
   FREE(cp);
}

/**
 * Create a command parser.
 */
struct ilo_cp *
ilo_cp_create(struct intel_winsys *winsys, bool direct_map)
{
   struct ilo_cp *cp;

   cp = CALLOC_STRUCT(ilo_cp);
   if (!cp)
      return NULL;

   cp->winsys = winsys;
   cp->render_ctx = intel_winsys_create_context(winsys);

   cp->ring = ILO_CP_RING_RENDER;
   cp->no_implicit_flush = false;

   cp->bo_size = 8192;

   if (!direct_map) {
      cp->sys = MALLOC(cp->bo_size * 4);
      if (!cp->sys) {
         FREE(cp);
         return NULL;
      }

      cp->ptr = cp->sys;
   }

   ilo_cp_realloc_bo(cp);
   if (!cp->bo) {
      FREE(cp->sys);
      FREE(cp);
      return NULL;
   }

   ilo_cp_clear_buffer(cp);

   return cp;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d28 1
a28 1
#include "genhw/genhw.h"
a32 3
#define MI_NOOP             GEN_MI_CMD(MI_NOOP)
#define MI_BATCH_BUFFER_END GEN_MI_CMD(MI_BATCH_BUFFER_END)

d45 1
a45 1
      intel_winsys_decode_bo(cp->winsys, cp->bo, cp->used * 4);
d80 1
a80 1
   intel_bo_truncate_relocs(cp->bo, jmp->reloc_count);
d163 1
a163 1
         "batch buffer", cp->bo_size * 4, INTEL_DOMAIN_CPU);
d174 4
a177 2
   if (!cp->sys)
      cp->ptr = intel_bo_map(cp->bo, true);
d187 2
d191 13
a203 3
   if (likely(do_exec)) {
      err = intel_winsys_submit_bo(cp->winsys, cp->ring,
            cp->bo, cp->used * 4, cp->render_ctx, cp->one_off_flags);
d205 6
a210 1
   else {
a211 1
   }
d223 1
a223 1
ilo_cp_flush_internal(struct ilo_cp *cp)
d266 2
a267 1
   intel_winsys_destroy_context(cp->winsys, cp->render_ctx);
d277 1
a277 1
ilo_cp_create(struct intel_winsys *winsys, int size, bool direct_map)
a286 4
   if (!cp->render_ctx) {
      FREE(cp);
      return NULL;
   }
d288 1
a288 1
   cp->ring = INTEL_RING_RENDER;
d291 1
a291 1
   cp->bo_size = size;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d28 1
a30 2
#include "ilo_builder_mi.h"
#include "ilo_shader.h"
d33 2
a34 1
static const struct ilo_cp_owner ilo_cp_default_owner;
d36 23
a58 2
static void
ilo_cp_release_owner(struct ilo_cp *cp)
d60 1
a60 2
   if (cp->owner != &ilo_cp_default_owner) {
      const struct ilo_cp_owner *owner = cp->owner;
d62 6
a67 1
      cp->owner = &ilo_cp_default_owner;
d69 9
a77 2
      assert(ilo_cp_space(cp) >= owner->reserve);
      owner->release(cp, owner->data);
d79 5
d87 1
a87 10
 * Set the parser owner.  If this is a new owner or a new ring, the old owner
 * is released and the new owner's own() is called.  The parser may implicitly
 * submit if there is a ring change.
 *
 * own() is called before \p owner owns the parser.  It must make sure there
 * is more space than \p owner->reserve when it returns.  Calling
 * ilo_cp_submit() is allowed.
 *
 * release() will be called after \p owner loses the parser.  That may happen
 * just before the parser submits and ilo_cp_submit() is not allowed.
d89 2
a90 3
void
ilo_cp_set_owner(struct ilo_cp *cp, enum intel_ring_type ring,
                 const struct ilo_cp_owner *owner)
d92 5
a96 2
   if (!owner)
      owner = &ilo_cp_default_owner;
d98 16
a113 4
   if (cp->ring != ring) {
      ilo_cp_submit(cp, "ring change");
      cp->ring = ring;
   }
d115 1
a115 2
   if (cp->owner != owner) {
      ilo_cp_release_owner(cp);
d117 1
a117 1
      owner->own(cp, owner->data);
d119 8
a126 3
      assert(ilo_cp_space(cp) >= owner->reserve);
      cp->owner = owner;
   }
d129 5
a133 2
static struct intel_bo *
ilo_cp_end_batch(struct ilo_cp *cp, unsigned *used)
d135 6
a140 1
   struct intel_bo *bo;
d142 3
a144 1
   ilo_cp_release_owner(cp);
d146 2
a147 3
   if (!ilo_builder_batch_used(&cp->builder)) {
      ilo_builder_batch_discard(&cp->builder);
      return NULL;
d150 10
a159 3
   /* see ilo_cp_space() */
   assert(ilo_builder_batch_space(&cp->builder) >= 2);
   gen6_mi_batch_buffer_end(&cp->builder);
d161 11
a171 1
   bo = ilo_builder_end(&cp->builder, used);
d173 3
a175 3
   /* we have to assume that kernel uploads also failed */
   if (!bo)
      ilo_shader_cache_invalidate(cp->shader_cache);
d177 2
a178 1
   return bo;
d182 1
a182 2
 * Flush the command parser and execute the commands.  When the parser buffer
 * is empty, the callback is not invoked.
d184 2
a185 2
void
ilo_cp_submit_internal(struct ilo_cp *cp)
a187 2
   struct intel_bo *bo;
   unsigned used;
a189 4
   bo = ilo_cp_end_batch(cp, &used);
   if (!bo)
      return;

d192 1
a192 1
            bo, used, cp->render_ctx, cp->one_off_flags);
d200 16
a215 5
   if (!err) {
      if (cp->last_submitted_bo)
         intel_bo_unreference(cp->last_submitted_bo);
      cp->last_submitted_bo = bo;
      intel_bo_reference(cp->last_submitted_bo);
d217 3
a219 2
      if (ilo_debug & ILO_DEBUG_BATCH)
         ilo_builder_decode(&cp->builder);
d221 1
a221 2
      if (cp->submit_callback)
         cp->submit_callback(cp, cp->submit_callback_data);
d224 12
a235 1
   ilo_builder_begin(&cp->builder);
d244 6
a249 1
   ilo_builder_reset(&cp->builder);
d252 2
d261 1
a261 3
ilo_cp_create(const struct ilo_dev_info *dev,
              struct intel_winsys *winsys,
              struct ilo_shader_cache *shc)
a269 1
   cp->shader_cache = shc;
d277 3
a279 1
   cp->owner = &ilo_cp_default_owner;
d281 6
a286 1
   ilo_builder_init(&cp->builder, dev, winsys);
d288 7
a294 2
   if (!ilo_builder_begin(&cp->builder)) {
      ilo_cp_destroy(cp);
d297 2
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@a27 1
#include "genhw/genhw.h"
d30 2
d34 1
a34 2
#define MI_NOOP             GEN_MI_CMD(MI_NOOP)
#define MI_BATCH_BUFFER_END GEN_MI_CMD(MI_BATCH_BUFFER_END)
d36 7
a42 2
/* the size of the private space */
static const int ilo_cp_private = 2;
d44 3
a46 10
/**
 * Dump the contents of the parser bo.  This can only be called in the flush
 * callback.
 */
void
ilo_cp_dump(struct ilo_cp *cp)
{
   ilo_printf("dumping %d bytes\n", cp->used * 4);
   if (cp->used)
      intel_winsys_decode_bo(cp->winsys, cp->bo, cp->used * 4);
d50 3
a52 1
 * Save the command parser state for rewind.
d54 6
a59 2
 * Note that this cannot rewind a flush, and the caller must make sure
 * that does not happend.
d62 2
a63 1
ilo_cp_setjmp(struct ilo_cp *cp, struct ilo_cp_jmp_buf *jmp)
d65 2
a66 1
   jmp->id = pointer_to_intptr(cp->bo);
d68 3
a70 16
   jmp->size = cp->size;
   jmp->used = cp->used;
   jmp->stolen = cp->stolen;
   /* save reloc count to rewind ilo_cp_write_bo() */
   jmp->reloc_count = intel_bo_get_reloc_count(cp->bo);
}

/**
 * Rewind to the saved state.
 */
void
ilo_cp_longjmp(struct ilo_cp *cp, const struct ilo_cp_jmp_buf *jmp)
{
   if (jmp->id != pointer_to_intptr(cp->bo)) {
      assert(!"invalid use of CP longjmp");
      return;
d73 2
a74 17
   cp->size = jmp->size;
   cp->used = jmp->used;
   cp->stolen = jmp->stolen;
   intel_bo_truncate_relocs(cp->bo, jmp->reloc_count);
}

/**
 * Clear the parser buffer.
 */
static void
ilo_cp_clear_buffer(struct ilo_cp *cp)
{
   cp->cmd_cur = 0;
   cp->cmd_end = 0;

   cp->used = 0;
   cp->stolen = 0;
d76 1
a76 7
   /*
    * Recalculate cp->size.  This is needed not only because cp->stolen is
    * reset above, but also that ilo_cp_private are added to cp->size in
    * ilo_cp_end_buffer().
    */
   cp->size = cp->bo_size - ilo_cp_private;
}
d78 3
a80 21
/**
 * Add MI_BATCH_BUFFER_END to the private space of the parser buffer.
 */
static void
ilo_cp_end_buffer(struct ilo_cp *cp)
{
   /* make the private space available */
   cp->size += ilo_cp_private;

   assert(cp->used + 2 <= cp->size);

   cp->ptr[cp->used++] = MI_BATCH_BUFFER_END;

   /*
    * From the Sandy Bridge PRM, volume 1 part 1, page 107:
    *
    *     "The batch buffer must be QWord aligned and a multiple of QWords in
    *      length."
    */
   if (cp->used & 1)
      cp->ptr[cp->used++] = MI_NOOP;
d83 2
a84 5
/**
 * Upload the parser buffer to the bo.
 */
static int
ilo_cp_upload_buffer(struct ilo_cp *cp)
d86 1
a86 1
   int err;
d88 1
a88 4
   if (!cp->sys) {
      intel_bo_unmap(cp->bo);
      return 0;
   }
d90 3
a92 6
   err = intel_bo_pwrite(cp->bo, 0, cp->used * 4, cp->ptr);
   if (likely(!err && cp->stolen)) {
      const int offset = cp->bo_size - cp->stolen;

      err = intel_bo_pwrite(cp->bo, offset * 4,
            cp->stolen * 4, &cp->ptr[offset]);
d95 3
a97 10
   return err;
}

/**
 * Reallocate the parser bo.
 */
static void
ilo_cp_realloc_bo(struct ilo_cp *cp)
{
   struct intel_bo *bo;
d99 1
a99 11
   /*
    * allocate the new bo before unreferencing the old one so that they
    * won't point at the same address, which is needed for jmpbuf
    */
   bo = intel_winsys_alloc_buffer(cp->winsys,
         "batch buffer", cp->bo_size * 4, INTEL_DOMAIN_CPU);
   if (unlikely(!bo)) {
      /* reuse the old one */
      bo = cp->bo;
      intel_bo_reference(bo);
   }
d101 3
a103 3
   if (cp->bo)
      intel_bo_unreference(cp->bo);
   cp->bo = bo;
d105 1
a105 2
   if (!cp->sys)
      cp->ptr = intel_bo_map(cp->bo, true);
d109 2
a110 1
 * Execute the parser bo.
d112 2
a113 2
static int
ilo_cp_exec_bo(struct ilo_cp *cp)
d116 2
d120 4
d126 1
a126 1
            cp->bo, cp->used * 4, cp->render_ctx, cp->one_off_flags);
d134 5
a138 16
   return err;
}

/**
 * Flush the command parser and execute the commands.  When the parser buffer
 * is empty, the callback is not invoked.
 */
void
ilo_cp_flush_internal(struct ilo_cp *cp)
{
   int err;

   ilo_cp_set_owner(cp, NULL, 0);

   /* sanity check */
   assert(cp->bo_size == cp->size + cp->stolen + ilo_cp_private);
d140 2
a141 3
   if (!cp->used) {
      /* return the space stolen and etc. */
      ilo_cp_clear_buffer(cp);
d143 2
a144 1
      return;
d147 1
a147 12
   ilo_cp_end_buffer(cp);

   /* upload and execute */
   err = ilo_cp_upload_buffer(cp);
   if (likely(!err))
      err = ilo_cp_exec_bo(cp);

   if (likely(!err && cp->flush_callback))
      cp->flush_callback(cp, cp->flush_callback_data);

   ilo_cp_clear_buffer(cp);
   ilo_cp_realloc_bo(cp);
d156 1
a156 6
   if (cp->bo) {
      if (!cp->sys)
         intel_bo_unmap(cp->bo);

      intel_bo_unreference(cp->bo);
   }
a158 2

   FREE(cp->sys);
d166 3
a168 1
ilo_cp_create(struct intel_winsys *winsys, int size, bool direct_map)
d177 1
d185 1
a185 3
   cp->no_implicit_flush = false;

   cp->bo_size = size;
d187 1
a187 6
   if (!direct_map) {
      cp->sys = MALLOC(cp->bo_size * 4);
      if (!cp->sys) {
         FREE(cp);
         return NULL;
      }
d189 2
a190 7
      cp->ptr = cp->sys;
   }

   ilo_cp_realloc_bo(cp);
   if (!cp->bo) {
      FREE(cp->sys);
      FREE(cp);
a192 2

   ilo_cp_clear_buffer(cp);
@


