head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.11.13;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.13;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.33.53;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.07.13;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.44.20;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2012-2013 LunarG, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#ifndef ILO_CP_H
#define ILO_CP_H

#include "intel_winsys.h"

#include "ilo_common.h"

struct ilo_cp;

enum ilo_cp_ring {
   ILO_CP_RING_RENDER,
   ILO_CP_RING_BLT,

   ILO_CP_RING_COUNT,
};

typedef void (*ilo_cp_callback)(struct ilo_cp *cp, void *data);

struct ilo_cp_owner {
   ilo_cp_callback release_callback;
   void *release_data;
};

/**
 * Command parser.
 */
struct ilo_cp {
   struct intel_winsys *winsys;
   struct intel_context *render_ctx;

   ilo_cp_callback flush_callback;
   void *flush_callback_data;

   const struct ilo_cp_owner *owner;
   int owner_reserve;

   enum ilo_cp_ring ring;
   bool no_implicit_flush;
   unsigned one_off_flags;

   int bo_size;
   struct intel_bo *bo;
   uint32_t *sys;

   uint32_t *ptr;
   int size, used, stolen;

   int cmd_cur, cmd_end;
};

/**
 * Jump buffer to save command parser state for rewind.
 */
struct ilo_cp_jmp_buf {
   intptr_t id;
   int size, used, stolen;
   int reloc_count;
};

struct ilo_cp *
ilo_cp_create(struct intel_winsys *winsys, bool direct_map);

void
ilo_cp_destroy(struct ilo_cp *cp);

void
ilo_cp_flush(struct ilo_cp *cp);

void
ilo_cp_dump(struct ilo_cp *cp);

void
ilo_cp_setjmp(struct ilo_cp *cp, struct ilo_cp_jmp_buf *jmp);

void
ilo_cp_longjmp(struct ilo_cp *cp, const struct ilo_cp_jmp_buf *jmp);

/**
 * Return true if the parser buffer is empty.
 */
static inline bool
ilo_cp_empty(struct ilo_cp *cp)
{
   return !cp->used;
}

/**
 * Return the remaining space (in dwords) in the parser buffer.
 */
static inline int
ilo_cp_space(struct ilo_cp *cp)
{
   return cp->size - cp->used;
}

/**
 * Internal function called by functions that flush implicitly.
 */
static inline void
ilo_cp_implicit_flush(struct ilo_cp *cp)
{
   if (cp->no_implicit_flush) {
      assert(!"unexpected command parser flush");
      /* discard the commands */
      cp->used = 0;
   }

   ilo_cp_flush(cp);
}

/**
 * Set the ring buffer.
 */
static inline void
ilo_cp_set_ring(struct ilo_cp *cp, enum ilo_cp_ring ring)
{
   if (cp->ring != ring) {
      ilo_cp_implicit_flush(cp);
      cp->ring = ring;
   }
}

/**
 * Assert that no function should flush implicitly.
 */
static inline void
ilo_cp_assert_no_implicit_flush(struct ilo_cp *cp, bool enable)
{
   cp->no_implicit_flush = enable;
}

/**
 * Set one-off flags.  They will be cleared after flushing.
 */
static inline void
ilo_cp_set_one_off_flags(struct ilo_cp *cp, unsigned flags)
{
   cp->one_off_flags |= flags;
}

/**
 * Set flush callback.  The callback is invoked after the bo has been
 * successfully executed, and before the bo is reallocated.
 */
static inline void
ilo_cp_set_flush_callback(struct ilo_cp *cp, ilo_cp_callback callback,
                          void *data)
{
   cp->flush_callback = callback;
   cp->flush_callback_data = data;
}

/**
 * Set the parser owner.  If this is a new owner, the previous owner is
 * notified and the space it reserved is reclaimed.
 *
 * \return true if this is a new owner
 */
static inline bool
ilo_cp_set_owner(struct ilo_cp *cp, const struct ilo_cp_owner *owner,
                 int reserve)
{
   const bool new_owner = (cp->owner != owner);

   /* release current owner */
   if (new_owner && cp->owner) {
      const bool no_implicit_flush = cp->no_implicit_flush;

      /* reclaim the reserved space */
      cp->size += cp->owner_reserve;
      cp->owner_reserve = 0;

      /* invoke the release callback */
      cp->no_implicit_flush = true;
      cp->owner->release_callback(cp, cp->owner->release_data);
      cp->no_implicit_flush = no_implicit_flush;

      cp->owner = NULL;
   }

   if (cp->owner_reserve != reserve) {
      const int extra = reserve - cp->owner_reserve;

      if (cp->used > cp->size - extra) {
         ilo_cp_implicit_flush(cp);
         assert(cp->used <= cp->size - reserve);

         cp->size -= reserve;
         cp->owner_reserve = reserve;
      }
      else {
         cp->size -= extra;
         cp->owner_reserve += extra;
      }
   }

   /* set owner last because of the possible flush above */
   cp->owner = owner;

   return new_owner;
}

/**
 * Begin writing a command.
 */
static inline void
ilo_cp_begin(struct ilo_cp *cp, int cmd_size)
{
   if (cp->used + cmd_size > cp->size) {
      ilo_cp_implicit_flush(cp);
      assert(cp->used + cmd_size <= cp->size);
   }

   assert(cp->cmd_cur == cp->cmd_end);
   cp->cmd_cur = cp->used;
   cp->cmd_end = cp->cmd_cur + cmd_size;
   cp->used = cp->cmd_end;
}

/**
 * Begin writing data to a space stolen from the top of the parser buffer.
 *
 * \param desc informative description of the data to be written
 * \param data_size in dwords
 * \param align in dwords
 * \param bo_offset in bytes to the stolen space
 */
static inline void
ilo_cp_steal(struct ilo_cp *cp, const char *desc,
             int data_size, int align, uint32_t *bo_offset)
{
   int pad, steal;

   if (!align)
      align = 1;

   pad = (cp->bo_size - cp->stolen - data_size) % align;
   steal = data_size + pad;

   /* flush if there is not enough space after stealing */
   if (cp->used > cp->size - steal) {
      ilo_cp_implicit_flush(cp);

      pad = (cp->bo_size - cp->stolen - data_size) % align;
      steal = data_size + steal;

      assert(cp->used <= cp->size - steal);
   }

   cp->size -= steal;
   cp->stolen += steal;

   assert(cp->cmd_cur == cp->cmd_end);
   cp->cmd_cur = cp->bo_size - cp->stolen;
   cp->cmd_end = cp->cmd_cur + data_size;

   /* offset in cp->bo */
   if (bo_offset)
      *bo_offset = cp->cmd_cur * 4;
}

/**
 * Write a dword to the parser buffer.  This function must be enclosed by
 * ilo_cp_begin()/ilo_cp_steal() and ilo_cp_end().
 */
static inline void
ilo_cp_write(struct ilo_cp *cp, uint32_t val)
{
   assert(cp->cmd_cur < cp->cmd_end);
   cp->ptr[cp->cmd_cur++] = val;
}

/**
 * Write multiple dwords to the parser buffer.
 */
static inline void
ilo_cp_write_multi(struct ilo_cp *cp, const void *vals, int num_vals)
{
   assert(cp->cmd_cur + num_vals <= cp->cmd_end);
   memcpy(cp->ptr + cp->cmd_cur, vals, num_vals * 4);
   cp->cmd_cur += num_vals;
}

/**
 * Write a bo to the parser buffer.  In addition to writing the offset of the
 * bo to the buffer, it also emits a relocation.
 */
static inline void
ilo_cp_write_bo(struct ilo_cp *cp, uint32_t val, struct intel_bo *bo,
                uint32_t read_domains, uint32_t write_domain)
{
   if (bo) {
      intel_bo_emit_reloc(cp->bo, cp->cmd_cur * 4,
            bo, val, read_domains, write_domain);

      ilo_cp_write(cp, val + intel_bo_get_offset(bo));
   }
   else {
      ilo_cp_write(cp, val);
   }
}

/**
 * End a command.  Every ilo_cp_begin() or ilo_cp_steal() must have a
 * matching ilo_cp_end().
 */
static inline void
ilo_cp_end(struct ilo_cp *cp)
{
   assert(cp->cmd_cur == cp->cmd_end);
}

/**
 * A variant of ilo_cp_steal() where the data are written via the returned
 * pointer.
 *
 * \return ptr pointer where the data are written to.  It is valid until any
 *             change is made to the parser.
 */
static inline void *
ilo_cp_steal_ptr(struct ilo_cp *cp, const char *desc,
                 int data_size, int align, uint32_t *bo_offset)
{
   void *ptr;

   ilo_cp_steal(cp, desc, data_size, align, bo_offset);

   ptr = &cp->ptr[cp->cmd_cur];
   cp->cmd_cur = cp->cmd_end;

   ilo_cp_end(cp);

   return ptr;
}

#endif /* ILO_CP_H */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d37 7
d64 1
a64 1
   enum intel_ring_type ring;
d88 1
a88 1
ilo_cp_create(struct intel_winsys *winsys, int size, bool direct_map);
d94 1
a94 15
ilo_cp_flush_internal(struct ilo_cp *cp);

static inline void
ilo_cp_flush(struct ilo_cp *cp, const char *reason)
{
   if (ilo_debug & ILO_DEBUG_FLUSH) {
      ilo_printf("cp flushed for %s with %d+%d DWords (%.1f%%) because of %s\n",
            (cp->ring == INTEL_RING_RENDER) ? "render" : "other",
             cp->used, cp->stolen,
             (float) (100 * (cp->used + cp->stolen)) / cp->bo_size,
             reason);
   }

   ilo_cp_flush_internal(cp);
}
d135 1
a135 1
   ilo_cp_flush(cp, "out of space (implicit)");
d142 1
a142 1
ilo_cp_set_ring(struct ilo_cp *cp, enum intel_ring_type ring)
d319 3
a321 1
   uint64_t presumed_offset;
d323 1
a323 3
   if (bo) {
      intel_bo_add_reloc(cp->bo, cp->cmd_cur * 4, bo, val,
            read_domains, write_domain, &presumed_offset);
d326 1
a326 1
      presumed_offset = 0;
a327 5

   /* 32-bit addressing */
   assert(presumed_offset == (uint64_t) ((uint32_t) presumed_offset));

   ilo_cp_write(cp, (uint32_t) presumed_offset);
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a32 1
#include "ilo_builder.h"
a35 1
struct ilo_shader_cache;
a38 4
/**
 * Parser owners are notified when they gain or lose the ownership of the
 * parser.  This gives owners a chance to emit prolog or epilog.
 */
d40 2
a41 9
   ilo_cp_callback own;
   ilo_cp_callback release;
   void *data;

   /*
    * Space reserved for release().  This can be modified at any time, as long
    * as it is never increased by more than ilo_cp_space().
    */
   int reserve;
a48 1
   struct ilo_shader_cache *shader_cache;
d51 2
a52 2
   ilo_cp_callback submit_callback;
   void *submit_callback_data;
a53 1
   enum intel_ring_type ring;
d55 1
d57 2
d61 17
a77 2
   struct ilo_builder builder;
   struct intel_bo *last_submitted_bo;
d81 1
a81 3
ilo_cp_create(const struct ilo_dev_info *dev,
              struct intel_winsys *winsys,
              struct ilo_shader_cache *shc);
d87 1
a87 1
ilo_cp_submit_internal(struct ilo_cp *cp);
d90 1
a90 1
ilo_cp_submit(struct ilo_cp *cp, const char *reason)
d92 6
a97 4
   if (ilo_debug & ILO_DEBUG_SUBMIT) {
      ilo_printf("submit batch buffer to %s ring because of %s: ",
            (cp->ring == INTEL_RING_RENDER) ? "render" : "unknown", reason);
      ilo_builder_batch_print_stats(&cp->builder);
d100 1
a100 1
   ilo_cp_submit_internal(cp);
d104 16
a119 2
ilo_cp_set_owner(struct ilo_cp *cp, enum intel_ring_type ring,
                 const struct ilo_cp_owner *owner);
d127 17
a143 2
   const int space = ilo_builder_batch_space(&cp->builder);
   const int mi_batch_buffer_end_space = 2;
d145 11
a155 1
   assert(space >= cp->owner->reserve + mi_batch_buffer_end_space);
d157 7
a163 1
   return space - cp->owner->reserve - mi_batch_buffer_end_space;
d167 1
a167 1
 * Set one-off flags.  They will be cleared after submission.
d176 2
a177 2
 * Set submit callback.  The callback is invoked after the bo has been
 * successfully submitted, and before the bo is reallocated.
d180 1
a180 1
ilo_cp_set_submit_callback(struct ilo_cp *cp, ilo_cp_callback callback,
d183 190
a372 2
   cp->submit_callback = callback;
   cp->submit_callback_data = data;
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d33 1
d37 1
d41 4
d46 9
a54 2
   ilo_cp_callback release_callback;
   void *release_data;
d62 1
d65 2
a66 2
   ilo_cp_callback flush_callback;
   void *flush_callback_data;
d68 1
a69 1
   int owner_reserve;
a70 2
   enum intel_ring_type ring;
   bool no_implicit_flush;
d73 2
a74 17
   int bo_size;
   struct intel_bo *bo;
   uint32_t *sys;

   uint32_t *ptr;
   int size, used, stolen;

   int cmd_cur, cmd_end;
};

/**
 * Jump buffer to save command parser state for rewind.
 */
struct ilo_cp_jmp_buf {
   intptr_t id;
   int size, used, stolen;
   int reloc_count;
d78 3
a80 1
ilo_cp_create(struct intel_winsys *winsys, int size, bool direct_map);
d86 1
a86 1
ilo_cp_flush_internal(struct ilo_cp *cp);
d89 1
a89 1
ilo_cp_flush(struct ilo_cp *cp, const char *reason)
d91 4
a94 6
   if (ilo_debug & ILO_DEBUG_FLUSH) {
      ilo_printf("cp flushed for %s with %d+%d DWords (%.1f%%) because of %s\n",
            (cp->ring == INTEL_RING_RENDER) ? "render" : "other",
             cp->used, cp->stolen,
             (float) (100 * (cp->used + cp->stolen)) / cp->bo_size,
             reason);
d97 1
a97 1
   ilo_cp_flush_internal(cp);
d101 2
a102 16
ilo_cp_dump(struct ilo_cp *cp);

void
ilo_cp_setjmp(struct ilo_cp *cp, struct ilo_cp_jmp_buf *jmp);

void
ilo_cp_longjmp(struct ilo_cp *cp, const struct ilo_cp_jmp_buf *jmp);

/**
 * Return true if the parser buffer is empty.
 */
static inline bool
ilo_cp_empty(struct ilo_cp *cp)
{
   return !cp->used;
}
d110 2
a111 17
   return cp->size - cp->used;
}

/**
 * Internal function called by functions that flush implicitly.
 */
static inline void
ilo_cp_implicit_flush(struct ilo_cp *cp)
{
   if (cp->no_implicit_flush) {
      assert(!"unexpected command parser flush");
      /* discard the commands */
      cp->used = 0;
   }

   ilo_cp_flush(cp, "out of space (implicit)");
}
d113 1
a113 11
/**
 * Set the ring buffer.
 */
static inline void
ilo_cp_set_ring(struct ilo_cp *cp, enum intel_ring_type ring)
{
   if (cp->ring != ring) {
      ilo_cp_implicit_flush(cp);
      cp->ring = ring;
   }
}
d115 1
a115 7
/**
 * Assert that no function should flush implicitly.
 */
static inline void
ilo_cp_assert_no_implicit_flush(struct ilo_cp *cp, bool enable)
{
   cp->no_implicit_flush = enable;
d119 1
a119 1
 * Set one-off flags.  They will be cleared after flushing.
d128 2
a129 2
 * Set flush callback.  The callback is invoked after the bo has been
 * successfully executed, and before the bo is reallocated.
d132 1
a132 1
ilo_cp_set_flush_callback(struct ilo_cp *cp, ilo_cp_callback callback,
d135 2
a136 190
   cp->flush_callback = callback;
   cp->flush_callback_data = data;
}

/**
 * Set the parser owner.  If this is a new owner, the previous owner is
 * notified and the space it reserved is reclaimed.
 *
 * \return true if this is a new owner
 */
static inline bool
ilo_cp_set_owner(struct ilo_cp *cp, const struct ilo_cp_owner *owner,
                 int reserve)
{
   const bool new_owner = (cp->owner != owner);

   /* release current owner */
   if (new_owner && cp->owner) {
      const bool no_implicit_flush = cp->no_implicit_flush;

      /* reclaim the reserved space */
      cp->size += cp->owner_reserve;
      cp->owner_reserve = 0;

      /* invoke the release callback */
      cp->no_implicit_flush = true;
      cp->owner->release_callback(cp, cp->owner->release_data);
      cp->no_implicit_flush = no_implicit_flush;

      cp->owner = NULL;
   }

   if (cp->owner_reserve != reserve) {
      const int extra = reserve - cp->owner_reserve;

      if (cp->used > cp->size - extra) {
         ilo_cp_implicit_flush(cp);
         assert(cp->used <= cp->size - reserve);

         cp->size -= reserve;
         cp->owner_reserve = reserve;
      }
      else {
         cp->size -= extra;
         cp->owner_reserve += extra;
      }
   }

   /* set owner last because of the possible flush above */
   cp->owner = owner;

   return new_owner;
}

/**
 * Begin writing a command.
 */
static inline void
ilo_cp_begin(struct ilo_cp *cp, int cmd_size)
{
   if (cp->used + cmd_size > cp->size) {
      ilo_cp_implicit_flush(cp);
      assert(cp->used + cmd_size <= cp->size);
   }

   assert(cp->cmd_cur == cp->cmd_end);
   cp->cmd_cur = cp->used;
   cp->cmd_end = cp->cmd_cur + cmd_size;
   cp->used = cp->cmd_end;
}

/**
 * Begin writing data to a space stolen from the top of the parser buffer.
 *
 * \param desc informative description of the data to be written
 * \param data_size in dwords
 * \param align in dwords
 * \param bo_offset in bytes to the stolen space
 */
static inline void
ilo_cp_steal(struct ilo_cp *cp, const char *desc,
             int data_size, int align, uint32_t *bo_offset)
{
   int pad, steal;

   if (!align)
      align = 1;

   pad = (cp->bo_size - cp->stolen - data_size) % align;
   steal = data_size + pad;

   /* flush if there is not enough space after stealing */
   if (cp->used > cp->size - steal) {
      ilo_cp_implicit_flush(cp);

      pad = (cp->bo_size - cp->stolen - data_size) % align;
      steal = data_size + steal;

      assert(cp->used <= cp->size - steal);
   }

   cp->size -= steal;
   cp->stolen += steal;

   assert(cp->cmd_cur == cp->cmd_end);
   cp->cmd_cur = cp->bo_size - cp->stolen;
   cp->cmd_end = cp->cmd_cur + data_size;

   /* offset in cp->bo */
   if (bo_offset)
      *bo_offset = cp->cmd_cur * 4;
}

/**
 * Write a dword to the parser buffer.  This function must be enclosed by
 * ilo_cp_begin()/ilo_cp_steal() and ilo_cp_end().
 */
static inline void
ilo_cp_write(struct ilo_cp *cp, uint32_t val)
{
   assert(cp->cmd_cur < cp->cmd_end);
   cp->ptr[cp->cmd_cur++] = val;
}

/**
 * Write multiple dwords to the parser buffer.
 */
static inline void
ilo_cp_write_multi(struct ilo_cp *cp, const void *vals, int num_vals)
{
   assert(cp->cmd_cur + num_vals <= cp->cmd_end);
   memcpy(cp->ptr + cp->cmd_cur, vals, num_vals * 4);
   cp->cmd_cur += num_vals;
}

/**
 * Write a bo to the parser buffer.  In addition to writing the offset of the
 * bo to the buffer, it also emits a relocation.
 */
static inline void
ilo_cp_write_bo(struct ilo_cp *cp, uint32_t val, struct intel_bo *bo,
                uint32_t read_domains, uint32_t write_domain)
{
   uint64_t presumed_offset;

   if (bo) {
      intel_bo_add_reloc(cp->bo, cp->cmd_cur * 4, bo, val,
            read_domains, write_domain, &presumed_offset);
   }
   else {
      presumed_offset = 0;
   }

   /* 32-bit addressing */
   assert(presumed_offset == (uint64_t) ((uint32_t) presumed_offset));

   ilo_cp_write(cp, (uint32_t) presumed_offset);
}

/**
 * End a command.  Every ilo_cp_begin() or ilo_cp_steal() must have a
 * matching ilo_cp_end().
 */
static inline void
ilo_cp_end(struct ilo_cp *cp)
{
   assert(cp->cmd_cur == cp->cmd_end);
}

/**
 * A variant of ilo_cp_steal() where the data are written via the returned
 * pointer.
 *
 * \return ptr pointer where the data are written to.  It is valid until any
 *             change is made to the parser.
 */
static inline void *
ilo_cp_steal_ptr(struct ilo_cp *cp, const char *desc,
                 int data_size, int align, uint32_t *bo_offset)
{
   void *ptr;

   ilo_cp_steal(cp, desc, data_size, align, bo_offset);

   ptr = &cp->ptr[cp->cmd_cur];
   cp->cmd_cur = cp->cmd_end;

   ilo_cp_end(cp);

   return ptr;
@


