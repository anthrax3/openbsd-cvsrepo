head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.11.13;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.13;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.33.53;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.07.13;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.44.20;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2012-2013 LunarG, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#include "util/u_upload_mgr.h"
#include "intel_chipset.h"

#include "ilo_3d.h"
#include "ilo_blit.h"
#include "ilo_blitter.h"
#include "ilo_cp.h"
#include "ilo_gpgpu.h"
#include "ilo_query.h"
#include "ilo_resource.h"
#include "ilo_screen.h"
#include "ilo_shader.h"
#include "ilo_state.h"
#include "ilo_transfer.h"
#include "ilo_video.h"
#include "ilo_context.h"

static void
ilo_context_cp_flushed(struct ilo_cp *cp, void *data)
{
   struct ilo_context *ilo = ilo_context(data);

   if (ilo->last_cp_bo)
      intel_bo_unreference(ilo->last_cp_bo);

   /* remember the just flushed bo, on which fences could wait */
   ilo->last_cp_bo = cp->bo;
   intel_bo_reference(ilo->last_cp_bo);

   ilo_3d_cp_flushed(ilo->hw3d);
}

static void
ilo_flush(struct pipe_context *pipe,
          struct pipe_fence_handle **f,
          unsigned flags)
{
   struct ilo_context *ilo = ilo_context(pipe);

   if (f) {
      struct ilo_fence *fence;

      fence = CALLOC_STRUCT(ilo_fence);
      if (fence) {
         pipe_reference_init(&fence->reference, 1);

         /* reference the batch bo that we want to wait on */
         if (ilo_cp_empty(ilo->cp))
            fence->bo = ilo->last_cp_bo;
         else
            fence->bo = ilo->cp->bo;

         if (fence->bo)
            intel_bo_reference(fence->bo);
      }

      *f = (struct pipe_fence_handle *) fence;
   }

   ilo_cp_flush(ilo->cp);
}

static void
ilo_context_destroy(struct pipe_context *pipe)
{
   struct ilo_context *ilo = ilo_context(pipe);

   ilo_cleanup_states(ilo);

   if (ilo->last_cp_bo)
      intel_bo_unreference(ilo->last_cp_bo);

   if (ilo->uploader)
      u_upload_destroy(ilo->uploader);

   if (ilo->blitter)
      ilo_blitter_destroy(ilo->blitter);
   if (ilo->hw3d)
      ilo_3d_destroy(ilo->hw3d);
   if (ilo->shader_cache)
      ilo_shader_cache_destroy(ilo->shader_cache);
   if (ilo->cp)
      ilo_cp_destroy(ilo->cp);

   util_slab_destroy(&ilo->transfer_mempool);

   FREE(ilo);
}

static struct pipe_context *
ilo_context_create(struct pipe_screen *screen, void *priv)
{
   struct ilo_screen *is = ilo_screen(screen);
   struct ilo_context *ilo;

   ilo = CALLOC_STRUCT(ilo_context);
   if (!ilo)
      return NULL;

   ilo->winsys = is->winsys;
   ilo->dev = &is->dev;

   /*
    * initialize first, otherwise it may not be safe to call
    * ilo_context_destroy() on errors
    */
   util_slab_create(&ilo->transfer_mempool,
         sizeof(struct ilo_transfer), 64, UTIL_SLAB_SINGLETHREADED);

   ilo->cp = ilo_cp_create(ilo->winsys, is->dev.has_llc);
   ilo->shader_cache = ilo_shader_cache_create();
   if (ilo->cp)
      ilo->hw3d = ilo_3d_create(ilo->cp, ilo->dev);

   if (!ilo->cp || !ilo->shader_cache || !ilo->hw3d) {
      ilo_context_destroy(&ilo->base);
      return NULL;
   }

   ilo->uploader = u_upload_create(&ilo->base, 1024 * 1024, 16,
         PIPE_BIND_CONSTANT_BUFFER | PIPE_BIND_INDEX_BUFFER);
   if (!ilo->uploader) {
      ilo_context_destroy(&ilo->base);
      return NULL;
   }

   ilo_cp_set_flush_callback(ilo->cp,
         ilo_context_cp_flushed, (void *) ilo);

   ilo->base.screen = screen;
   ilo->base.priv = priv;

   ilo->base.destroy = ilo_context_destroy;
   ilo->base.flush = ilo_flush;

   ilo_init_3d_functions(ilo);
   ilo_init_query_functions(ilo);
   ilo_init_state_functions(ilo);
   ilo_init_blit_functions(ilo);
   ilo_init_transfer_functions(ilo);
   ilo_init_video_functions(ilo);
   ilo_init_gpgpu_functions(ilo);

   ilo_init_states(ilo);

   /* this must be called last as u_blitter is a client of the pipe context */
   ilo->blitter = ilo_blitter_create(ilo);
   if (!ilo->blitter) {
      ilo_context_destroy(&ilo->base);
      return NULL;
   }

   return &ilo->base;
}

/**
 * Initialize context-related functions.
 */
void
ilo_init_context_functions(struct ilo_screen *is)
{
   is->base.context_create = ilo_context_create;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d29 1
d87 1
a87 2
   ilo_cp_flush(ilo->cp,
         (flags & PIPE_FLUSH_END_OF_FRAME) ? "frame end" : "user request");
a121 1
   int cp_size;
d137 1
a137 6
   /* 8192 DWords */
   cp_size = 8192;
   if (cp_size * 4 > is->dev.max_batch_size)
      cp_size = is->dev.max_batch_size / 4;

   ilo->cp = ilo_cp_create(ilo->winsys, cp_size, is->dev.has_llc);
d147 7
d173 1
a173 11
   /*
    * These must be called last as u_upload/u_blitter are clients of the pipe
    * context.
    */
   ilo->uploader = u_upload_create(&ilo->base, 1024 * 1024, 16,
         PIPE_BIND_CONSTANT_BUFFER | PIPE_BIND_INDEX_BUFFER);
   if (!ilo->uploader) {
      ilo_context_destroy(&ilo->base);
      return NULL;
   }

@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d30 1
a33 1
#include "ilo_draw.h"
a35 1
#include "ilo_render.h"
d45 1
a45 1
ilo_context_cp_submitted(struct ilo_cp *cp, void *data)
d49 8
a56 2
   /* builder buffers are reallocated */
   ilo_render_invalidate_builder(ilo->render);
a65 3
   ilo_cp_submit(ilo->cp,
         (flags & PIPE_FLUSH_END_OF_FRAME) ? "frame end" : "user request");

d67 1
a67 4
      *f = (struct pipe_fence_handle *)
         ilo_fence_create(pipe->screen, ilo->cp->last_submitted_bo);
   }
}
d69 13
a81 7
static void
ilo_render_condition(struct pipe_context *pipe,
                     struct pipe_query *query,
                     boolean condition,
                     uint mode)
{
   struct ilo_context *ilo = ilo_context(pipe);
d83 1
a83 25
   /* reference count? */
   ilo->render_condition.query = query;
   ilo->render_condition.condition = condition;
   ilo->render_condition.mode = mode;
}

bool
ilo_skip_rendering(struct ilo_context *ilo)
{
   uint64_t result;
   bool wait;

   if (!ilo->render_condition.query)
      return false;

   switch (ilo->render_condition.mode) {
   case PIPE_RENDER_COND_WAIT:
   case PIPE_RENDER_COND_BY_REGION_WAIT:
      wait = true;
      break;
   case PIPE_RENDER_COND_NO_WAIT:
   case PIPE_RENDER_COND_BY_REGION_NO_WAIT:
   default:
      wait = false;
      break;
d86 2
a87 5
   if (ilo->base.get_query_result(&ilo->base, ilo->render_condition.query,
            wait, (union pipe_query_result *) &result))
      return ((bool) result == ilo->render_condition.condition);
   else
      return false;
d95 4
a98 1
   ilo_state_vector_cleanup(&ilo->state_vector);
d105 2
a106 2
   if (ilo->render)
      ilo_render_destroy(ilo->render);
d122 1
d138 6
a144 1
   ilo->cp = ilo_cp_create(ilo->dev, ilo->winsys, ilo->shader_cache);
d146 1
a146 1
      ilo->render = ilo_render_create(&ilo->cp->builder);
d148 1
a148 1
   if (!ilo->cp || !ilo->shader_cache || !ilo->render) {
d153 2
a154 2
   ilo_cp_set_submit_callback(ilo->cp,
         ilo_context_cp_submitted, (void *) ilo);
a160 1
   ilo->base.render_condition = ilo_render_condition;
d162 1
a162 1
   ilo_init_draw_functions(ilo);
d170 1
a170 2
   ilo_init_draw(ilo);
   ilo_state_vector_init(ilo->dev, &ilo->state_vector);
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@a29 1
#include "ilo_3d.h"
d33 1
d36 1
d46 1
a46 1
ilo_context_cp_flushed(struct ilo_cp *cp, void *data)
d50 2
a51 8
   if (ilo->last_cp_bo)
      intel_bo_unreference(ilo->last_cp_bo);

   /* remember the just flushed bo, on which fences could wait */
   ilo->last_cp_bo = cp->bo;
   intel_bo_reference(ilo->last_cp_bo);

   ilo_3d_cp_flushed(ilo->hw3d);
d61 3
d65 4
a68 1
      struct ilo_fence *fence;
d70 7
a76 13
      fence = CALLOC_STRUCT(ilo_fence);
      if (fence) {
         pipe_reference_init(&fence->reference, 1);

         /* reference the batch bo that we want to wait on */
         if (ilo_cp_empty(ilo->cp))
            fence->bo = ilo->last_cp_bo;
         else
            fence->bo = ilo->cp->bo;

         if (fence->bo)
            intel_bo_reference(fence->bo);
      }
d78 25
a102 1
      *f = (struct pipe_fence_handle *) fence;
d105 5
a109 2
   ilo_cp_flush(ilo->cp,
         (flags & PIPE_FLUSH_END_OF_FRAME) ? "frame end" : "user request");
d117 1
a117 4
   ilo_cleanup_states(ilo);

   if (ilo->last_cp_bo)
      intel_bo_unreference(ilo->last_cp_bo);
d124 2
a125 2
   if (ilo->hw3d)
      ilo_3d_destroy(ilo->hw3d);
a140 1
   int cp_size;
a155 6
   /* 8192 DWords */
   cp_size = 8192;
   if (cp_size * 4 > is->dev.max_batch_size)
      cp_size = is->dev.max_batch_size / 4;

   ilo->cp = ilo_cp_create(ilo->winsys, cp_size, is->dev.has_llc);
d157 1
d159 1
a159 1
      ilo->hw3d = ilo_3d_create(ilo->cp, ilo->dev);
d161 1
a161 1
   if (!ilo->cp || !ilo->shader_cache || !ilo->hw3d) {
d166 2
a167 2
   ilo_cp_set_flush_callback(ilo->cp,
         ilo_context_cp_flushed, (void *) ilo);
d174 1
d176 1
a176 1
   ilo_init_3d_functions(ilo);
d184 2
a185 1
   ilo_init_states(ilo);
@


