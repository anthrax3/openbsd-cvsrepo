head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.33;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.09.07.15.20.06;	author jsg;	state Exp;
branches;
next	1.4;
commitid	7kimTMT4YlQauAIU;

1.4
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.01.00;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.19;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.02.52;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.08.17;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.45.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2010 Jerome Glisse <glisse@@freedesktop.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include "r600_pipe.h"
#include "util/u_surface.h"
#include "util/u_blitter.h"
#include "util/u_format.h"
#include "evergreend.h"

enum r600_blitter_op /* bitmask */
{
	R600_SAVE_FRAGMENT_STATE = 1,
	R600_SAVE_TEXTURES       = 2,
	R600_SAVE_FRAMEBUFFER    = 4,
	R600_DISABLE_RENDER_COND = 8,

	R600_CLEAR         = R600_SAVE_FRAGMENT_STATE,

	R600_CLEAR_SURFACE = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER,

	R600_COPY_BUFFER   = R600_DISABLE_RENDER_COND,

	R600_COPY_TEXTURE  = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES |
			     R600_DISABLE_RENDER_COND,

	R600_BLIT          = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES |
			     R600_DISABLE_RENDER_COND,

	R600_DECOMPRESS    = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_DISABLE_RENDER_COND,

	R600_COLOR_RESOLVE = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_DISABLE_RENDER_COND
};

static void r600_blitter_begin(struct pipe_context *ctx, enum r600_blitter_op op)
{
	struct r600_context *rctx = (struct r600_context *)ctx;

	r600_suspend_nontimer_queries(&rctx->b);

	util_blitter_save_vertex_buffer_slot(rctx->blitter, rctx->vertex_buffer_state.vb);
	util_blitter_save_vertex_elements(rctx->blitter, rctx->vertex_fetch_shader.cso);
	util_blitter_save_vertex_shader(rctx->blitter, rctx->vs_shader);
	util_blitter_save_geometry_shader(rctx->blitter, rctx->gs_shader);
	util_blitter_save_so_targets(rctx->blitter, rctx->b.streamout.num_targets,
				     (struct pipe_stream_output_target**)rctx->b.streamout.targets);
	util_blitter_save_rasterizer(rctx->blitter, rctx->rasterizer_state.cso);

	if (op & R600_SAVE_FRAGMENT_STATE) {
		util_blitter_save_viewport(rctx->blitter, &rctx->viewport[0].state);
		util_blitter_save_scissor(rctx->blitter, &rctx->scissor[0].scissor);
		util_blitter_save_fragment_shader(rctx->blitter, rctx->ps_shader);
		util_blitter_save_blend(rctx->blitter, rctx->blend_state.cso);
		util_blitter_save_depth_stencil_alpha(rctx->blitter, rctx->dsa_state.cso);
		util_blitter_save_stencil_ref(rctx->blitter, &rctx->stencil_ref.pipe_state);
                util_blitter_save_sample_mask(rctx->blitter, rctx->sample_mask.sample_mask);
	}

	if (op & R600_SAVE_FRAMEBUFFER)
		util_blitter_save_framebuffer(rctx->blitter, &rctx->framebuffer.state);

	if (op & R600_SAVE_TEXTURES) {
		util_blitter_save_fragment_sampler_states(
			rctx->blitter, util_last_bit(rctx->samplers[PIPE_SHADER_FRAGMENT].states.enabled_mask),
			(void**)rctx->samplers[PIPE_SHADER_FRAGMENT].states.states);

		util_blitter_save_fragment_sampler_views(
			rctx->blitter, util_last_bit(rctx->samplers[PIPE_SHADER_FRAGMENT].views.enabled_mask),
			(struct pipe_sampler_view**)rctx->samplers[PIPE_SHADER_FRAGMENT].views.views);
	}

	if ((op & R600_DISABLE_RENDER_COND) && rctx->b.current_render_cond) {
           util_blitter_save_render_condition(rctx->blitter,
                                              rctx->b.current_render_cond,
                                              rctx->b.current_render_cond_cond,
                                              rctx->b.current_render_cond_mode);
        }
}

static void r600_blitter_end(struct pipe_context *ctx)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
        r600_resume_nontimer_queries(&rctx->b);
}

static unsigned u_max_sample(struct pipe_resource *r)
{
	return r->nr_samples ? r->nr_samples - 1 : 0;
}

static void r600_blit_decompress_depth(struct pipe_context *ctx,
				       struct r600_texture *texture,
				       struct r600_texture *staging,
				       unsigned first_level, unsigned last_level,
				       unsigned first_layer, unsigned last_layer,
				       unsigned first_sample, unsigned last_sample)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	unsigned layer, level, sample, checked_last_layer, max_layer, max_sample;
	struct r600_texture *flushed_depth_texture = staging ?
			staging : texture->flushed_depth_texture;
	const struct util_format_description *desc =
		util_format_description(texture->resource.b.b.format);
	float depth;

	if (!staging && !texture->dirty_level_mask)
		return;

	max_sample = u_max_sample(&texture->resource.b.b);

	/* XXX Decompressing MSAA depth textures is broken on R6xx.
	 * There is also a hardlock if CMASK and FMASK are not present.
	 * Just skip this until we find out how to fix it. */
	if (rctx->b.chip_class == R600 && max_sample > 0) {
		texture->dirty_level_mask = 0;
		return;
	}

	if (rctx->b.family == CHIP_RV610 || rctx->b.family == CHIP_RV630 ||
	    rctx->b.family == CHIP_RV620 || rctx->b.family == CHIP_RV635)
		depth = 0.0f;
	else
		depth = 1.0f;

	/* Enable decompression in DB_RENDER_CONTROL */
	rctx->db_misc_state.flush_depthstencil_through_cb = true;
	rctx->db_misc_state.copy_depth = util_format_has_depth(desc);
	rctx->db_misc_state.copy_stencil = util_format_has_stencil(desc);
	rctx->db_misc_state.copy_sample = first_sample;
	rctx->db_misc_state.atom.dirty = true;

	for (level = first_level; level <= last_level; level++) {
		if (!staging && !(texture->dirty_level_mask & (1 << level)))
			continue;

		/* The smaller the mipmap level, the less layers there are
		 * as far as 3D textures are concerned. */
		max_layer = util_max_layer(&texture->resource.b.b, level);
		checked_last_layer = last_layer < max_layer ? last_layer : max_layer;

		for (layer = first_layer; layer <= checked_last_layer; layer++) {
			for (sample = first_sample; sample <= last_sample; sample++) {
				struct pipe_surface *zsurf, *cbsurf, surf_tmpl;

				if (sample != rctx->db_misc_state.copy_sample) {
					rctx->db_misc_state.copy_sample = sample;
					rctx->db_misc_state.atom.dirty = true;
				}

				surf_tmpl.format = texture->resource.b.b.format;
				surf_tmpl.u.tex.level = level;
				surf_tmpl.u.tex.first_layer = layer;
				surf_tmpl.u.tex.last_layer = layer;

				zsurf = ctx->create_surface(ctx, &texture->resource.b.b, &surf_tmpl);

				surf_tmpl.format = flushed_depth_texture->resource.b.b.format;
				cbsurf = ctx->create_surface(ctx,
						&flushed_depth_texture->resource.b.b, &surf_tmpl);

				r600_blitter_begin(ctx, R600_DECOMPRESS);
				util_blitter_custom_depth_stencil(rctx->blitter, zsurf, cbsurf, 1 << sample,
								  rctx->custom_dsa_flush, depth);
				r600_blitter_end(ctx);

				pipe_surface_reference(&zsurf, NULL);
				pipe_surface_reference(&cbsurf, NULL);
			}
		}

		/* The texture will always be dirty if some layers or samples aren't flushed.
		 * I don't think this case occurs often though. */
		if (!staging &&
		    first_layer == 0 && last_layer == max_layer &&
		    first_sample == 0 && last_sample == max_sample) {
			texture->dirty_level_mask &= ~(1 << level);
		}
	}

	/* reenable compression in DB_RENDER_CONTROL */
	rctx->db_misc_state.flush_depthstencil_through_cb = false;
	rctx->db_misc_state.atom.dirty = true;
}

static void r600_blit_decompress_depth_in_place(struct r600_context *rctx,
                                                struct r600_texture *texture,
                                                unsigned first_level, unsigned last_level,
                                                unsigned first_layer, unsigned last_layer)
{
	struct pipe_surface *zsurf, surf_tmpl = {{0}};
	unsigned layer, max_layer, checked_last_layer, level;

	/* Enable decompression in DB_RENDER_CONTROL */
	rctx->db_misc_state.flush_depthstencil_in_place = true;
	rctx->db_misc_state.atom.dirty = true;

	surf_tmpl.format = texture->resource.b.b.format;

	for (level = first_level; level <= last_level; level++) {
		if (!(texture->dirty_level_mask & (1 << level)))
			continue;

		surf_tmpl.u.tex.level = level;

		/* The smaller the mipmap level, the less layers there are
		 * as far as 3D textures are concerned. */
		max_layer = util_max_layer(&texture->resource.b.b, level);
		checked_last_layer = last_layer < max_layer ? last_layer : max_layer;

		for (layer = first_layer; layer <= checked_last_layer; layer++) {
			surf_tmpl.u.tex.first_layer = layer;
			surf_tmpl.u.tex.last_layer = layer;

			zsurf = rctx->b.b.create_surface(&rctx->b.b, &texture->resource.b.b, &surf_tmpl);

			r600_blitter_begin(&rctx->b.b, R600_DECOMPRESS);
			util_blitter_custom_depth_stencil(rctx->blitter, zsurf, NULL, ~0,
							  rctx->custom_dsa_flush, 1.0f);
			r600_blitter_end(&rctx->b.b);

			pipe_surface_reference(&zsurf, NULL);
		}

		/* The texture will always be dirty if some layers or samples aren't flushed.
		 * I don't think this case occurs often though. */
		if (first_layer == 0 && last_layer == max_layer) {
			texture->dirty_level_mask &= ~(1 << level);
		}
	}

	/* Disable decompression in DB_RENDER_CONTROL */
	rctx->db_misc_state.flush_depthstencil_in_place = false;
	rctx->db_misc_state.atom.dirty = true;
}

void r600_decompress_depth_textures(struct r600_context *rctx,
			       struct r600_samplerview_state *textures)
{
	unsigned i;
	unsigned depth_texture_mask = textures->compressed_depthtex_mask;

	while (depth_texture_mask) {
		struct pipe_sampler_view *view;
		struct r600_texture *tex;

		i = u_bit_scan(&depth_texture_mask);

		view = &textures->views[i]->base;
		assert(view);

		tex = (struct r600_texture *)view->texture;
		assert(tex->is_depth && !tex->is_flushing_texture);

		if (rctx->b.chip_class >= EVERGREEN ||
		    r600_can_read_depth(tex)) {
			r600_blit_decompress_depth_in_place(rctx, tex,
						   view->u.tex.first_level, view->u.tex.last_level,
						   0, util_max_layer(&tex->resource.b.b, view->u.tex.first_level));
		} else {
			r600_blit_decompress_depth(&rctx->b.b, tex, NULL,
						   view->u.tex.first_level, view->u.tex.last_level,
						   0, util_max_layer(&tex->resource.b.b, view->u.tex.first_level),
						   0, u_max_sample(&tex->resource.b.b));
		}
	}
}

static void r600_blit_decompress_color(struct pipe_context *ctx,
		struct r600_texture *rtex,
		unsigned first_level, unsigned last_level,
		unsigned first_layer, unsigned last_layer)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	unsigned layer, level, checked_last_layer, max_layer;

	if (!rtex->dirty_level_mask)
		return;

	for (level = first_level; level <= last_level; level++) {
		if (!(rtex->dirty_level_mask & (1 << level)))
			continue;

		/* The smaller the mipmap level, the less layers there are
		 * as far as 3D textures are concerned. */
		max_layer = util_max_layer(&rtex->resource.b.b, level);
		checked_last_layer = last_layer < max_layer ? last_layer : max_layer;

		for (layer = first_layer; layer <= checked_last_layer; layer++) {
			struct pipe_surface *cbsurf, surf_tmpl;

			surf_tmpl.format = rtex->resource.b.b.format;
			surf_tmpl.u.tex.level = level;
			surf_tmpl.u.tex.first_layer = layer;
			surf_tmpl.u.tex.last_layer = layer;
			cbsurf = ctx->create_surface(ctx, &rtex->resource.b.b, &surf_tmpl);

			r600_blitter_begin(ctx, R600_DECOMPRESS);
			util_blitter_custom_color(rctx->blitter, cbsurf,
				rtex->fmask.size ? rctx->custom_blend_decompress : rctx->custom_blend_fastclear);
			r600_blitter_end(ctx);

			pipe_surface_reference(&cbsurf, NULL);
		}

		/* The texture will always be dirty if some layers aren't flushed.
		 * I don't think this case occurs often though. */
		if (first_layer == 0 && last_layer == max_layer) {
			rtex->dirty_level_mask &= ~(1 << level);
		}
	}
}

void r600_decompress_color_textures(struct r600_context *rctx,
				    struct r600_samplerview_state *textures)
{
	unsigned i;
	unsigned mask = textures->compressed_colortex_mask;

	while (mask) {
		struct pipe_sampler_view *view;
		struct r600_texture *tex;

		i = u_bit_scan(&mask);

		view = &textures->views[i]->base;
		assert(view);

		tex = (struct r600_texture *)view->texture;
		assert(tex->cmask.size);

		r600_blit_decompress_color(&rctx->b.b, tex,
					   view->u.tex.first_level, view->u.tex.last_level,
					   0, util_max_layer(&tex->resource.b.b, view->u.tex.first_level));
	}
}

/* Helper for decompressing a portion of a color or depth resource before
 * blitting if any decompression is needed.
 * The driver doesn't decompress resources automatically while u_blitter is
 * rendering. */
static bool r600_decompress_subresource(struct pipe_context *ctx,
					struct pipe_resource *tex,
					unsigned level,
					unsigned first_layer, unsigned last_layer)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct r600_texture *rtex = (struct r600_texture*)tex;

	if (rtex->is_depth && !rtex->is_flushing_texture) {
		if (rctx->b.chip_class >= EVERGREEN ||
		    r600_can_read_depth(rtex)) {
			r600_blit_decompress_depth_in_place(rctx, rtex,
						   level, level,
						   first_layer, last_layer);
		} else {
			if (!r600_init_flushed_depth_texture(ctx, tex, NULL))
				return false; /* error */

			r600_blit_decompress_depth(ctx, rtex, NULL,
						   level, level,
						   first_layer, last_layer,
						   0, u_max_sample(tex));
		}
	} else if (rtex->cmask.size) {
		r600_blit_decompress_color(ctx, rtex, level, level,
					   first_layer, last_layer);
	}
	return true;
}

static void r600_clear(struct pipe_context *ctx, unsigned buffers,
		       const union pipe_color_union *color,
		       double depth, unsigned stencil)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_framebuffer_state *fb = &rctx->framebuffer.state;

	if (buffers & PIPE_CLEAR_COLOR && rctx->b.chip_class >= EVERGREEN) {
		evergreen_do_fast_color_clear(&rctx->b, fb, &rctx->framebuffer.atom,
					      &buffers, color);
	}

	if (buffers & PIPE_CLEAR_COLOR) {
		int i;

		/* These buffers cannot use fast clear, make sure to disable expansion. */
		for (i = 0; i < fb->nr_cbufs; i++) {
			struct r600_texture *tex;

			/* If not clearing this buffer, skip. */
			if (!(buffers & (PIPE_CLEAR_COLOR0 << i)))
				continue;

			if (!fb->cbufs[i])
				continue;

			tex = (struct r600_texture *)fb->cbufs[i]->texture;
			if (tex->fmask.size == 0)
				tex->dirty_level_mask &= ~(1 << fb->cbufs[i]->u.tex.level);
		}
	}

	/* if hyperz enabled just clear hyperz */
	if (fb->zsbuf && (buffers & PIPE_CLEAR_DEPTH)) {
		struct r600_texture *rtex;
		unsigned level = fb->zsbuf->u.tex.level;

		rtex = (struct r600_texture*)fb->zsbuf->texture;

		/* We can't use hyperz fast clear if each slice of a texture
		 * array are clear to different value. To simplify code just
		 * disable fast clear for texture array.
		 */
		/* Only use htile for first level */
		if (rtex->htile_buffer && !level &&
		    util_max_layer(&rtex->resource.b.b, level) == 0) {
			if (rtex->depth_clear_value != depth) {
				rtex->depth_clear_value = depth;
				rctx->db_state.atom.dirty = true;
			}
			rctx->db_misc_state.htile_clear = true;
			rctx->db_misc_state.atom.dirty = true;
		}
	}

	r600_blitter_begin(ctx, R600_CLEAR);
	util_blitter_clear(rctx->blitter, fb->width, fb->height, 1,
			   buffers, color, depth, stencil);
	r600_blitter_end(ctx);

	/* disable fast clear */
	if (rctx->db_misc_state.htile_clear) {
		rctx->db_misc_state.htile_clear = false;
		rctx->db_misc_state.atom.dirty = true;
	}
}

static void r600_clear_render_target(struct pipe_context *ctx,
				     struct pipe_surface *dst,
				     const union pipe_color_union *color,
				     unsigned dstx, unsigned dsty,
				     unsigned width, unsigned height)
{
	struct r600_context *rctx = (struct r600_context *)ctx;

	r600_blitter_begin(ctx, R600_CLEAR_SURFACE);
	util_blitter_clear_render_target(rctx->blitter, dst, color,
					 dstx, dsty, width, height);
	r600_blitter_end(ctx);
}

static void r600_clear_depth_stencil(struct pipe_context *ctx,
				     struct pipe_surface *dst,
				     unsigned clear_flags,
				     double depth,
				     unsigned stencil,
				     unsigned dstx, unsigned dsty,
				     unsigned width, unsigned height)
{
	struct r600_context *rctx = (struct r600_context *)ctx;

	r600_blitter_begin(ctx, R600_CLEAR_SURFACE);
	util_blitter_clear_depth_stencil(rctx->blitter, dst, clear_flags, depth, stencil,
					 dstx, dsty, width, height);
	r600_blitter_end(ctx);
}

static void r600_copy_buffer(struct pipe_context *ctx, struct pipe_resource *dst, unsigned dstx,
			     struct pipe_resource *src, const struct pipe_box *src_box)
{
	struct r600_context *rctx = (struct r600_context*)ctx;

	if (rctx->screen->b.has_cp_dma) {
		r600_cp_dma_copy_buffer(rctx, dst, dstx, src, src_box->x, src_box->width);
	}
	else if (rctx->screen->b.has_streamout &&
		 /* Require 4-byte alignment. */
		 dstx % 4 == 0 && src_box->x % 4 == 0 && src_box->width % 4 == 0) {

		r600_blitter_begin(ctx, R600_COPY_BUFFER);
		util_blitter_copy_buffer(rctx->blitter, dst, dstx, src, src_box->x, src_box->width);
		r600_blitter_end(ctx);
	} else {
		util_resource_copy_region(ctx, dst, 0, dstx, 0, 0, src, 0, src_box);
	}

	/* The index buffer (VGT) doesn't seem to see the result of the copying.
	 * Can we somehow flush the index buffer cache? Starting a new IB seems
	 * to do the trick. */
	if (rctx->b.chip_class <= R700)
		rctx->b.rings.gfx.flush(ctx, RADEON_FLUSH_ASYNC, NULL);
}

/**
 * Global buffers are not really resources, they are are actually offsets
 * into a single global resource (r600_screen::global_pool).  The means
 * they don't have their own cs_buf handle, so they cannot be passed
 * to r600_copy_buffer() and must be handled separately.
 *
 * XXX: It should be possible to implement this function using
 * r600_copy_buffer() by passing the memory_pool resource as both src
 * and dst and updating dstx and src_box to point to the correct offsets.
 * This would likely perform better than the current implementation.
 */
static void r600_copy_global_buffer(struct pipe_context *ctx,
				    struct pipe_resource *dst, unsigned
				    dstx, struct pipe_resource *src,
				    const struct pipe_box *src_box)
{
	struct pipe_box dst_box; struct pipe_transfer *src_pxfer,
	*dst_pxfer;

	u_box_1d(dstx, src_box->width, &dst_box);
	void *src_ptr = ctx->transfer_map(ctx, src, 0, PIPE_TRANSFER_READ,
					  src_box, &src_pxfer);
	void *dst_ptr = ctx->transfer_map(ctx, dst, 0, PIPE_TRANSFER_WRITE,
					  &dst_box, &dst_pxfer);
	memcpy(dst_ptr, src_ptr, src_box->width);

	ctx->transfer_unmap(ctx, src_pxfer);
	ctx->transfer_unmap(ctx, dst_pxfer);
}

static void r600_clear_buffer(struct pipe_context *ctx, struct pipe_resource *dst,
			      unsigned offset, unsigned size, unsigned value)
{
	struct r600_context *rctx = (struct r600_context*)ctx;

	if (rctx->screen->b.has_cp_dma &&
	    rctx->b.chip_class >= EVERGREEN &&
	    offset % 4 == 0 && size % 4 == 0) {
		evergreen_cp_dma_clear_buffer(rctx, dst, offset, size, value);
	} else if (rctx->screen->b.has_streamout && offset % 4 == 0 && size % 4 == 0) {
		union pipe_color_union clear_value;
		clear_value.ui[0] = value;

		r600_blitter_begin(ctx, R600_DISABLE_RENDER_COND);
		util_blitter_clear_buffer(rctx->blitter, dst, offset, size,
					  1, &clear_value);
		r600_blitter_end(ctx);
	} else {
		uint32_t *map = r600_buffer_map_sync_with_rings(&rctx->b, r600_resource(dst),
								 PIPE_TRANSFER_WRITE);
		size /= 4;
		for (unsigned i = 0; i < size; i++)
			*map++ = value;
	}
}

static bool util_format_is_subsampled_2x1_32bpp(enum pipe_format format)
{
	const struct util_format_description *desc = util_format_description(format);

	return desc->layout == UTIL_FORMAT_LAYOUT_SUBSAMPLED &&
	       desc->block.width == 2 &&
	       desc->block.height == 1 &&
	       desc->block.bits == 32;
}

static void r600_resource_copy_region(struct pipe_context *ctx,
				      struct pipe_resource *dst,
				      unsigned dst_level,
				      unsigned dstx, unsigned dsty, unsigned dstz,
				      struct pipe_resource *src,
				      unsigned src_level,
				      const struct pipe_box *src_box)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_surface *dst_view, dst_templ;
	struct pipe_sampler_view src_templ, *src_view;
	unsigned dst_width, dst_height, src_width0, src_height0, src_widthFL, src_heightFL;
	unsigned src_force_level = 0;
	struct pipe_box sbox, dstbox;

	/* Handle buffers first. */
	if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
		if ((src->bind & PIPE_BIND_GLOBAL) ||
					(dst->bind & PIPE_BIND_GLOBAL)) {
			r600_copy_global_buffer(ctx, dst, dstx, src, src_box);
		} else {
			r600_copy_buffer(ctx, dst, dstx, src, src_box);
		}
		return;
	}

	assert(u_max_sample(dst) == u_max_sample(src));

	/* The driver doesn't decompress resources automatically while
	 * u_blitter is rendering. */
	if (!r600_decompress_subresource(ctx, src, src_level,
					 src_box->z, src_box->z + src_box->depth - 1)) {
		return; /* error */
	}

	dst_width = u_minify(dst->width0, dst_level);
        dst_height = u_minify(dst->height0, dst_level);
	src_width0 = src->width0;
	src_height0 = src->height0;
        src_widthFL = u_minify(src->width0, src_level);
        src_heightFL = u_minify(src->height0, src_level);

	util_blitter_default_dst_texture(&dst_templ, dst, dst_level, dstz);
	util_blitter_default_src_texture(&src_templ, src, src_level);

	if (util_format_is_compressed(src->format)) {
		unsigned blocksize = util_format_get_blocksize(src->format);

		if (blocksize == 8)
			src_templ.format = PIPE_FORMAT_R16G16B16A16_UINT; /* 64-bit block */
		else
			src_templ.format = PIPE_FORMAT_R32G32B32A32_UINT; /* 128-bit block */
		dst_templ.format = src_templ.format;

		dst_width = util_format_get_nblocksx(dst->format, dst_width);
		dst_height = util_format_get_nblocksy(dst->format, dst_height);
		src_width0 = util_format_get_nblocksx(src->format, src_width0);
		src_height0 = util_format_get_nblocksy(src->format, src_height0);
		src_widthFL = util_format_get_nblocksx(src->format, src_widthFL);
		src_heightFL = util_format_get_nblocksy(src->format, src_heightFL);

		dstx = util_format_get_nblocksx(dst->format, dstx);
		dsty = util_format_get_nblocksy(dst->format, dsty);

		sbox.x = util_format_get_nblocksx(src->format, src_box->x);
		sbox.y = util_format_get_nblocksy(src->format, src_box->y);
		sbox.z = src_box->z;
		sbox.width = util_format_get_nblocksx(src->format, src_box->width);
		sbox.height = util_format_get_nblocksy(src->format, src_box->height);
		sbox.depth = src_box->depth;
		src_box = &sbox;

		src_force_level = src_level;
	} else if (!util_blitter_is_copy_supported(rctx->blitter, dst, src)) {
		if (util_format_is_subsampled_2x1_32bpp(src->format)) {

			src_templ.format = PIPE_FORMAT_R8G8B8A8_UINT;
			dst_templ.format = PIPE_FORMAT_R8G8B8A8_UINT;

			dst_width = util_format_get_nblocksx(dst->format, dst_width);
			src_width0 = util_format_get_nblocksx(src->format, src_width0);
			src_widthFL = util_format_get_nblocksx(src->format, src_widthFL);

			dstx = util_format_get_nblocksx(dst->format, dstx);

			sbox = *src_box;
			sbox.x = util_format_get_nblocksx(src->format, src_box->x);
			sbox.width = util_format_get_nblocksx(src->format, src_box->width);
			src_box = &sbox;
		} else {
			unsigned blocksize = util_format_get_blocksize(src->format);

			switch (blocksize) {
			case 1:
				dst_templ.format = PIPE_FORMAT_R8_UNORM;
				src_templ.format = PIPE_FORMAT_R8_UNORM;
				break;
                        case 2:
				dst_templ.format = PIPE_FORMAT_R8G8_UNORM;
				src_templ.format = PIPE_FORMAT_R8G8_UNORM;
				break;
			case 4:
				dst_templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
				src_templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
				break;
                        case 8:
                                dst_templ.format = PIPE_FORMAT_R16G16B16A16_UINT;
                                src_templ.format = PIPE_FORMAT_R16G16B16A16_UINT;
                                break;
                        case 16:
                                dst_templ.format = PIPE_FORMAT_R32G32B32A32_UINT;
                                src_templ.format = PIPE_FORMAT_R32G32B32A32_UINT;
                                break;
			default:
				fprintf(stderr, "Unhandled format %s with blocksize %u\n",
					util_format_short_name(src->format), blocksize);
				assert(0);
			}
		}
	}

	dst_view = r600_create_surface_custom(ctx, dst, &dst_templ, dst_width, dst_height);

	if (rctx->b.chip_class >= EVERGREEN) {
		src_view = evergreen_create_sampler_view_custom(ctx, src, &src_templ,
								src_width0, src_height0,
								src_force_level);
	} else {
		src_view = r600_create_sampler_view_custom(ctx, src, &src_templ,
							   src_widthFL, src_heightFL);
	}

        u_box_3d(dstx, dsty, dstz, abs(src_box->width), abs(src_box->height),
                 abs(src_box->depth), &dstbox);

	/* Copy. */
	r600_blitter_begin(ctx, R600_COPY_TEXTURE);
	util_blitter_blit_generic(rctx->blitter, dst_view, &dstbox,
				  src_view, src_box, src_width0, src_height0,
				  PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL);
	r600_blitter_end(ctx);

	pipe_surface_reference(&dst_view, NULL);
	pipe_sampler_view_reference(&src_view, NULL);
}

/* For MSAA integer resolving to work, we change the format to NORM using this function. */
static enum pipe_format int_to_norm_format(enum pipe_format format)
{
	switch (format) {
#define REPLACE_FORMAT_SIGN(format,sign) \
	case PIPE_FORMAT_##format##_##sign##INT: \
		return PIPE_FORMAT_##format##_##sign##NORM
#define REPLACE_FORMAT(format) \
		REPLACE_FORMAT_SIGN(format, U); \
		REPLACE_FORMAT_SIGN(format, S)

	REPLACE_FORMAT_SIGN(B10G10R10A2, U);
	REPLACE_FORMAT(R8);
	REPLACE_FORMAT(R8G8);
	REPLACE_FORMAT(R8G8B8X8);
	REPLACE_FORMAT(R8G8B8A8);
	REPLACE_FORMAT(A8);
	REPLACE_FORMAT(I8);
	REPLACE_FORMAT(L8);
	REPLACE_FORMAT(L8A8);
	REPLACE_FORMAT(R16);
	REPLACE_FORMAT(R16G16);
	REPLACE_FORMAT(R16G16B16X16);
	REPLACE_FORMAT(R16G16B16A16);
	REPLACE_FORMAT(A16);
	REPLACE_FORMAT(I16);
	REPLACE_FORMAT(L16);
	REPLACE_FORMAT(L16A16);

#undef REPLACE_FORMAT
#undef REPLACE_FORMAT_SIGN
	default:
		return format;
	}
}

static bool do_hardware_msaa_resolve(struct pipe_context *ctx,
				     const struct pipe_blit_info *info)
{
	struct r600_context *rctx = (struct r600_context*)ctx;
	struct r600_texture *dst = (struct r600_texture*)info->dst.resource;
	unsigned dst_width = u_minify(info->dst.resource->width0, info->dst.level);
	unsigned dst_height = u_minify(info->dst.resource->height0, info->dst.level);
	enum pipe_format format = int_to_norm_format(info->dst.format);
	unsigned sample_mask =
		rctx->b.chip_class == CAYMAN ? ~0 :
		((1ull << MAX2(1, info->src.resource->nr_samples)) - 1);

	if (info->src.resource->nr_samples > 1 &&
	    info->dst.resource->nr_samples <= 1 &&
	    util_max_layer(info->src.resource, 0) == 0 &&
	    util_max_layer(info->dst.resource, info->dst.level) == 0 &&
	    info->dst.format == info->src.format &&
	    !util_format_is_pure_integer(format) &&
	    !util_format_is_depth_or_stencil(format) &&
	    !info->scissor_enable &&
	    (info->mask & PIPE_MASK_RGBA) == PIPE_MASK_RGBA &&
	    dst_width == info->src.resource->width0 &&
	    dst_height == info->src.resource->height0 &&
	    info->dst.box.x == 0 &&
	    info->dst.box.y == 0 &&
	    info->dst.box.width == dst_width &&
	    info->dst.box.height == dst_height &&
	    info->dst.box.depth == 1 &&
	    info->src.box.x == 0 &&
	    info->src.box.y == 0 &&
	    info->src.box.width == dst_width &&
	    info->src.box.height == dst_height &&
	    info->src.box.depth == 1 &&
	    dst->surface.level[info->dst.level].mode >= RADEON_SURF_MODE_1D &&
	    (!dst->cmask.size || !dst->dirty_level_mask) /* dst cannot be fast-cleared */) {
		r600_blitter_begin(ctx, R600_COLOR_RESOLVE);
		util_blitter_custom_resolve_color(rctx->blitter,
						  info->dst.resource, info->dst.level,
						  info->dst.box.z,
						  info->src.resource, info->src.box.z,
						  sample_mask, rctx->custom_blend_resolve,
						  format);
		r600_blitter_end(ctx);
		return true;
	}
	return false;
}

static void r600_blit(struct pipe_context *ctx,
                      const struct pipe_blit_info *info)
{
	struct r600_context *rctx = (struct r600_context*)ctx;

	if (do_hardware_msaa_resolve(ctx, info)) {
		return;
	}

	assert(util_blitter_is_blit_supported(rctx->blitter, info));

	/* The driver doesn't decompress resources automatically while
	 * u_blitter is rendering. */
	if (!r600_decompress_subresource(ctx, info->src.resource, info->src.level,
					 info->src.box.z,
					 info->src.box.z + info->src.box.depth - 1)) {
		return; /* error */
	}

	r600_blitter_begin(ctx, R600_BLIT);
	util_blitter_blit(rctx->blitter, info);
	r600_blitter_end(ctx);
}

static void r600_flush_resource(struct pipe_context *ctx,
				struct pipe_resource *res)
{
	struct r600_texture *rtex = (struct r600_texture*)res;

	assert(res->target != PIPE_BUFFER);

	if (!rtex->is_depth && rtex->cmask.size) {
		r600_blit_decompress_color(ctx, rtex, 0, res->last_level,
					   0, util_max_layer(res, 0));
	}
}

void r600_init_blit_functions(struct r600_context *rctx)
{
	rctx->b.b.clear = r600_clear;
	rctx->b.b.clear_render_target = r600_clear_render_target;
	rctx->b.b.clear_depth_stencil = r600_clear_depth_stencil;
	rctx->b.b.resource_copy_region = r600_resource_copy_region;
	rctx->b.b.blit = r600_blit;
	rctx->b.b.flush_resource = r600_flush_resource;
	rctx->b.clear_buffer = r600_clear_buffer;
	rctx->b.blit_decompress_depth = r600_blit_decompress_depth;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a23 2
#include "compute_memory_pool.h"
#include "evergreen_compute.h"
d25 1
d45 2
a46 1
	R600_BLIT          = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES,
d50 1
a50 1
	R600_COLOR_RESOLVE = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER
d434 1
a434 2
                   fb->zsbuf->u.tex.first_layer == 0 &&
                   fb->zsbuf->u.tex.last_layer == util_max_layer(&rtex->resource.b.b, level)) {
d445 1
a445 2
	util_blitter_clear(rctx->blitter, fb->width, fb->height,
			   util_framebuffer_get_num_layers(fb),
d517 5
d528 2
a529 3
	struct r600_context *rctx = (struct r600_context*)ctx;
	struct compute_memory_pool *pool = rctx->screen->global_pool;
	struct pipe_box new_src_box = *src_box;
d531 6
a536 21
	if (src->bind & PIPE_BIND_GLOBAL) {
		struct r600_resource_global *rsrc =
			(struct r600_resource_global *)src;
		struct compute_memory_item *item = rsrc->chunk;

		if (is_item_in_pool(item)) {
			new_src_box.x += 4 * item->start_in_dw;
			src = (struct pipe_resource *)pool->bo;
		} else {
			if (item->real_buffer == NULL) {
				item->real_buffer = (struct r600_resource*)
					r600_compute_buffer_alloc_vram(pool->screen,
								       item->size_in_dw * 4);
			}
			src = (struct pipe_resource*)item->real_buffer;
		}
	}
	if (dst->bind & PIPE_BIND_GLOBAL) {
		struct r600_resource_global *rdst =
			(struct r600_resource_global *)dst;
		struct compute_memory_item *item = rdst->chunk;
d538 2
a539 14
		if (is_item_in_pool(item)) {
			dstx += 4 * item->start_in_dw;
			dst = (struct pipe_resource *)pool->bo;
		} else {
			if (item->real_buffer == NULL) {
				item->real_buffer = (struct r600_resource*)
					r600_compute_buffer_alloc_vram(pool->screen,
								       item->size_in_dw * 4);
			}
			dst = (struct pipe_resource*)item->real_buffer;
		}
	}

	r600_copy_buffer(ctx, dst, dstx, src, &new_src_box);
d568 17
a584 7
void r600_resource_copy_region(struct pipe_context *ctx,
			       struct pipe_resource *dst,
			       unsigned dst_level,
			       unsigned dstx, unsigned dsty, unsigned dstz,
			       struct pipe_resource *src,
			       unsigned src_level,
			       const struct pipe_box *src_box)
d652 1
a652 1
		if (util_format_is_subsampled_422(src->format)) {
d795 1
a795 2
		r600_blitter_begin(ctx, R600_COLOR_RESOLVE |
				   (info->render_condition_enable ? 0 : R600_DISABLE_RENDER_COND));
d827 1
a827 6
	if (rctx->screen->b.debug_flags & DBG_FORCE_DMA &&
	    util_try_blit_via_copy_region(ctx, info))
		return;

	r600_blitter_begin(ctx, R600_BLIT |
			   (info->render_condition_enable ? 0 : R600_DISABLE_RENDER_COND));
@


1.5
log
@Merge Mesa 10.2.7
@
text
@d24 2
a26 1
#include "util/u_blitter.h"
d46 1
a46 2
	R600_BLIT          = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES |
			     R600_DISABLE_RENDER_COND,
d50 1
a50 1
	R600_COLOR_RESOLVE = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_DISABLE_RENDER_COND
d434 2
a435 1
		    util_max_layer(&rtex->resource.b.b, level) == 0) {
d446 2
a447 1
	util_blitter_clear(rctx->blitter, fb->width, fb->height, 1,
a518 5
 *
 * XXX: It should be possible to implement this function using
 * r600_copy_buffer() by passing the memory_pool resource as both src
 * and dst and updating dstx and src_box to point to the correct offsets.
 * This would likely perform better than the current implementation.
d525 3
a527 2
	struct pipe_box dst_box; struct pipe_transfer *src_pxfer,
	*dst_pxfer;
d529 21
a549 6
	u_box_1d(dstx, src_box->width, &dst_box);
	void *src_ptr = ctx->transfer_map(ctx, src, 0, PIPE_TRANSFER_READ,
					  src_box, &src_pxfer);
	void *dst_ptr = ctx->transfer_map(ctx, dst, 0, PIPE_TRANSFER_WRITE,
					  &dst_box, &dst_pxfer);
	memcpy(dst_ptr, src_ptr, src_box->width);
d551 14
a564 2
	ctx->transfer_unmap(ctx, src_pxfer);
	ctx->transfer_unmap(ctx, dst_pxfer);
d593 7
a599 17
static bool util_format_is_subsampled_2x1_32bpp(enum pipe_format format)
{
	const struct util_format_description *desc = util_format_description(format);

	return desc->layout == UTIL_FORMAT_LAYOUT_SUBSAMPLED &&
	       desc->block.width == 2 &&
	       desc->block.height == 1 &&
	       desc->block.bits == 32;
}

static void r600_resource_copy_region(struct pipe_context *ctx,
				      struct pipe_resource *dst,
				      unsigned dst_level,
				      unsigned dstx, unsigned dsty, unsigned dstz,
				      struct pipe_resource *src,
				      unsigned src_level,
				      const struct pipe_box *src_box)
d667 1
a667 1
		if (util_format_is_subsampled_2x1_32bpp(src->format)) {
d810 2
a811 1
		r600_blitter_begin(ctx, R600_COLOR_RESOLVE);
d843 6
a848 1
	r600_blitter_begin(ctx, R600_BLIT);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d433 2
a434 1
		if (rtex->htile_buffer && !level && rtex->surface.array_size == 1) {
d841 1
a841 1
					   0, res->array_size - 1);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d27 1
d57 1
a57 1
	r600_suspend_nontimer_queries(rctx);
d62 3
a64 2
	util_blitter_save_so_targets(rctx->blitter, rctx->streamout.num_targets,
				     (struct pipe_stream_output_target**)rctx->streamout.targets);
d68 2
a69 2
		util_blitter_save_viewport(rctx->blitter, &rctx->viewport.state);
		util_blitter_save_scissor(rctx->blitter, &rctx->scissor.scissor);
d90 1
a90 1
	if ((op & R600_DISABLE_RENDER_COND) && rctx->current_render_cond) {
d92 3
a94 3
                                              rctx->current_render_cond,
                                              rctx->current_render_cond_cond,
                                              rctx->current_render_cond_mode);
d101 1
a101 1
        r600_resume_nontimer_queries(rctx);
d109 6
a114 6
void r600_blit_decompress_depth(struct pipe_context *ctx,
		struct r600_texture *texture,
		struct r600_texture *staging,
		unsigned first_level, unsigned last_level,
		unsigned first_layer, unsigned last_layer,
		unsigned first_sample, unsigned last_sample)
d132 1
a132 1
	if (rctx->chip_class == R600 && max_sample > 0) {
d137 2
a138 2
	if (rctx->family == CHIP_RV610 || rctx->family == CHIP_RV630 ||
	    rctx->family == CHIP_RV620 || rctx->family == CHIP_RV635)
a175 3
				surf_tmpl.u.tex.level = level;
				surf_tmpl.u.tex.first_layer = layer;
				surf_tmpl.u.tex.last_layer = layer;
d232 1
a232 1
			zsurf = rctx->context.create_surface(&rctx->context, &texture->resource.b.b, &surf_tmpl);
d234 1
a234 1
			r600_blitter_begin(&rctx->context, R600_DECOMPRESS);
d237 1
a237 1
			r600_blitter_end(&rctx->context);
d272 1
a272 1
		if (rctx->chip_class >= EVERGREEN ||
d278 1
a278 1
			r600_blit_decompress_depth(&rctx->context, tex, NULL,
d316 2
a317 1
			util_blitter_custom_color(rctx->blitter, cbsurf, rctx->custom_blend_decompress);
d347 1
a347 1
		assert(tex->cmask_size && tex->fmask_size);
d349 1
a349 1
		r600_blit_decompress_color(&rctx->context, tex,
d368 1
a368 1
		if (rctx->chip_class >= EVERGREEN ||
d382 1
a382 1
	} else if (rtex->fmask_size && rtex->cmask_size) {
a388 81
static boolean is_simple_msaa_resolve(const struct pipe_blit_info *info)
{
	unsigned dst_width = u_minify(info->dst.resource->width0, info->dst.level);
	unsigned dst_height = u_minify(info->dst.resource->height0, info->dst.level);
	struct r600_texture *dst = (struct r600_texture*)info->dst.resource;
	unsigned dst_tile_mode = dst->surface.level[info->dst.level].mode;

	return info->dst.resource->format == info->src.resource->format &&
		info->dst.resource->format == info->dst.format &&
		info->src.resource->format == info->src.format &&
		!info->scissor_enable &&
		info->mask == PIPE_MASK_RGBA &&
		dst_width == info->src.resource->width0 &&
		dst_height == info->src.resource->height0 &&
		info->dst.box.x == 0 &&
		info->dst.box.y == 0 &&
		info->dst.box.width == dst_width &&
		info->dst.box.height == dst_height &&
		info->src.box.x == 0 &&
		info->src.box.y == 0 &&
		info->src.box.width == dst_width &&
		info->src.box.height == dst_height &&
		/* Dst must be tiled. If it's not, we have to use a temporary
		 * resource which is tiled. */
		dst_tile_mode >= RADEON_SURF_MODE_1D;
}

static void r600_clear_buffer(struct pipe_context *ctx, struct pipe_resource *dst,
			      unsigned offset, unsigned size, unsigned char value);

static void evergreen_set_clear_color(struct pipe_surface *cbuf,
				      const union pipe_color_union *color)
{
	unsigned *clear_value = ((struct r600_texture *)cbuf->texture)->color_clear_value;
	union util_color uc;

	memset(&uc, 0, sizeof(uc));

	if (util_format_is_pure_uint(cbuf->format)) {
		util_format_write_4ui(cbuf->format, color->ui, 0, &uc, 0, 0, 0, 1, 1);
	} else if (util_format_is_pure_sint(cbuf->format)) {
		util_format_write_4i(cbuf->format, color->i, 0, &uc, 0, 0, 0, 1, 1);
	} else {
		util_pack_color(color->f, cbuf->format, &uc);
	}

	memcpy(clear_value, &uc, 2 * sizeof(uint32_t));
}

static bool can_fast_clear_color(struct pipe_context *ctx)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_framebuffer_state *fb = &rctx->framebuffer.state;
	int i;

	if (rctx->chip_class < EVERGREEN) {
		return false;
	}

	for (i = 0; i < fb->nr_cbufs; i++) {
		struct r600_texture *tex = (struct r600_texture *)fb->cbufs[i]->texture;

		if (tex->cmask_size == 0) {
			return false;
		}

		/* 128-bit formats are unuspported */
		if (util_format_get_blocksizebits(fb->cbufs[i]->format) > 64) {
			return false;
		}

		/* the clear is allowed if all layers are bound */
		if (fb->cbufs[i]->u.tex.first_layer != 0 ||
		    fb->cbufs[i]->u.tex.last_layer != util_max_layer(&tex->resource.b.b, 0)) {
			return false;
		}
	}

	return true;
}

d396 6
a401 2
	/* fast color clear on AA framebuffers (EG+) */
	if ((buffers & PIPE_CLEAR_COLOR) && can_fast_clear_color(ctx)) {
d404 1
d406 1
a406 1
			struct r600_texture *tex = (struct r600_texture *)fb->cbufs[i]->texture;
d408 10
a417 4
			evergreen_set_clear_color(fb->cbufs[i], color);
			r600_clear_buffer(ctx, fb->cbufs[i]->texture,
					tex->cmask_offset, tex->cmask_size, 0);
			tex->dirty_level_mask |= 1 << fb->cbufs[i]->u.tex.level;
a418 6

		rctx->framebuffer.atom.dirty = true;

		buffers &= ~PIPE_CLEAR_COLOR;
		if (!buffers)
			return;
d433 3
a435 3
		if (rtex->htile && !level && rtex->surface.array_size == 1) {
			if (rtex->depth_clear != depth) {
				rtex->depth_clear = depth;
d444 1
a444 1
	util_blitter_clear(rctx->blitter, fb->width, fb->height,
d485 2
a486 2
void r600_copy_buffer(struct pipe_context *ctx, struct pipe_resource *dst, unsigned dstx,
		      struct pipe_resource *src, const struct pipe_box *src_box)
d490 1
a490 1
	if (rctx->screen->has_cp_dma) {
d493 1
a493 1
	else if (rctx->screen->has_streamout &&
a496 4
		/* Flush both resources. */
		r600_flag_resource_cache_flush(rctx, src);
		r600_flag_resource_cache_flush(rctx, dst);

a499 3

		/* Flush the dst in case the 3D engine has been prefetching the resource. */
		r600_flag_resource_cache_flush(rctx, dst);
d503 36
d542 1
a542 1
			      unsigned offset, unsigned size, unsigned char value)
a544 1
	uint32_t v = value;
d546 2
a547 2
	if (rctx->screen->has_cp_dma &&
	    rctx->chip_class >= EVERGREEN &&
d549 2
a550 4
		uint32_t clear_value = v | (v << 8) | (v << 16) | (v << 24);

		evergreen_cp_dma_clear_buffer(rctx, dst, offset, size, clear_value);
	} else if (rctx->screen->has_streamout && offset % 4 == 0 && size % 4 == 0) {
d552 1
a552 4

		clear_value.ui[0] = v | (v << 8) | (v << 16) | (v << 24);

		r600_flag_resource_cache_flush(rctx, dst);
a557 3

		/* Flush again in case the 3D engine has been prefetching the resource. */
		r600_flag_resource_cache_flush(rctx, dst);
d559 5
a563 3
		char *map = r600_buffer_mmap_sync_with_rings(rctx, r600_resource(dst),
							     PIPE_TRANSFER_WRITE);
		memset(map + offset, value, size);
a566 9
void r600_screen_clear_buffer(struct r600_screen *rscreen, struct pipe_resource *dst,
			      unsigned offset, unsigned size, unsigned char value)
{
	pipe_mutex_lock(rscreen->aux_context_lock);
	r600_clear_buffer(rscreen->aux_context, dst, offset, size, value);
	rscreen->aux_context->flush(rscreen->aux_context, NULL, 0);
	pipe_mutex_unlock(rscreen->aux_context_lock);
}

d589 1
d594 6
a599 1
		r600_copy_buffer(ctx, dst, dstx, src, src_box);
d648 3
a650 2
	} else if (!util_blitter_is_copy_supported(rctx->blitter, dst, src,
						   PIPE_MASK_RGBAZS)) {
d700 1
a700 1
	if (rctx->chip_class >= EVERGREEN) {
d702 2
a703 1
								src_width0, src_height0);
d716 1
a716 2
				  PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL,
				  TRUE);
d759 2
a760 2
static void r600_msaa_color_resolve(struct pipe_context *ctx,
			      const struct pipe_blit_info *info)
d762 5
a766 4
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_screen *screen = ctx->screen;
	struct pipe_resource *tmp, templ;
	struct pipe_blit_info blit;
d768 1
a768 1
		rctx->chip_class == CAYMAN ? ~0 :
d771 23
a793 5
	assert(info->src.level == 0);
	assert(info->src.box.depth == 1);
	assert(info->dst.box.depth == 1);

	if (is_simple_msaa_resolve(info)) {
d800 1
a800 1
                                                  int_to_norm_format(info->dst.format));
d802 1
a802 1
		return;
d804 1
a804 35

	/* resolve into a temporary texture, then blit */
	templ.target = PIPE_TEXTURE_2D;
	templ.format = info->src.resource->format;
	templ.width0 = info->src.resource->width0;
	templ.height0 = info->src.resource->height0;
	templ.depth0 = 1;
	templ.array_size = 1;
	templ.last_level = 0;
	templ.nr_samples = 0;
	templ.usage = PIPE_USAGE_STATIC;
	templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
	templ.flags = R600_RESOURCE_FLAG_FORCE_TILING; /* dst must not have a linear layout */

	tmp = screen->resource_create(screen, &templ);

	/* resolve */
	r600_blitter_begin(ctx, R600_COLOR_RESOLVE);
	util_blitter_custom_resolve_color(rctx->blitter,
					  tmp, 0, 0,
					  info->src.resource, info->src.box.z,
					  sample_mask, rctx->custom_blend_resolve,
                                          int_to_norm_format(tmp->format));
	r600_blitter_end(ctx);

	/* blit */
	blit = *info;
	blit.src.resource = tmp;
	blit.src.box.z = 0;

	r600_blitter_begin(ctx, R600_BLIT);
	util_blitter_blit(rctx->blitter, &blit);
	r600_blitter_end(ctx);

	pipe_resource_reference(&tmp, NULL);
d812 1
a812 7
	assert(util_blitter_is_blit_supported(rctx->blitter, info));

	if (info->src.resource->nr_samples > 1 &&
	    info->dst.resource->nr_samples <= 1 &&
	    !util_format_is_depth_or_stencil(info->src.resource->format) &&
	    !util_format_is_pure_integer(int_to_norm_format(info->src.resource->format))) {
		r600_msaa_color_resolve(ctx, info);
d816 2
d831 13
d846 8
a853 5
	rctx->context.clear = r600_clear;
	rctx->context.clear_render_target = r600_clear_render_target;
	rctx->context.clear_depth_stencil = r600_clear_depth_stencil;
	rctx->context.resource_copy_region = r600_resource_copy_region;
	rctx->context.blit = r600_blit;
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a22 3
#include <util/u_surface.h>
#include <util/u_blitter.h>
#include <util/u_format.h>
d24 3
d30 4
a33 3
	R600_SAVE_TEXTURES      = 1,
	R600_SAVE_FRAMEBUFFER   = 2,
	R600_DISABLE_RENDER_COND = 4,
d35 1
a35 1
	R600_CLEAR         = 0,
d37 1
a37 1
	R600_CLEAR_SURFACE = R600_SAVE_FRAMEBUFFER,
d39 6
a44 1
	R600_COPY          = R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES |
d47 3
a49 1
	R600_DECOMPRESS    = R600_SAVE_FRAMEBUFFER | R600_DISABLE_RENDER_COND,
d54 1
a54 1
	struct r600_pipe_context *rctx = (struct r600_pipe_context *)ctx;
d56 1
a56 2
	rctx->blit = true;
	r600_context_queries_suspend(&rctx->ctx);
d58 15
a72 4
	util_blitter_save_blend(rctx->blitter, rctx->states[R600_PIPE_STATE_BLEND]);
	util_blitter_save_depth_stencil_alpha(rctx->blitter, rctx->states[R600_PIPE_STATE_DSA]);
	if (rctx->states[R600_PIPE_STATE_STENCIL_REF]) {
		util_blitter_save_stencil_ref(rctx->blitter, &rctx->stencil_ref);
a73 13
	util_blitter_save_rasterizer(rctx->blitter, rctx->states[R600_PIPE_STATE_RASTERIZER]);
	util_blitter_save_fragment_shader(rctx->blitter, rctx->ps_shader);
	util_blitter_save_vertex_shader(rctx->blitter, rctx->vs_shader);
	util_blitter_save_vertex_elements(rctx->blitter, rctx->vertex_elements);
	if (rctx->states[R600_PIPE_STATE_VIEWPORT]) {
		util_blitter_save_viewport(rctx->blitter, &rctx->viewport);
	}
	if (rctx->states[R600_PIPE_STATE_CLIP]) {
		util_blitter_save_clip(rctx->blitter, &rctx->clip);
	}
	util_blitter_save_vertex_buffers(rctx->blitter,
					 rctx->vbuf_mgr->nr_vertex_buffers,
					 rctx->vbuf_mgr->vertex_buffer);
d76 1
a76 1
		util_blitter_save_framebuffer(rctx->blitter, &rctx->framebuffer);
d80 2
a81 2
			rctx->blitter, rctx->ps_samplers.n_samplers,
			(void**)rctx->ps_samplers.samplers);
d84 2
a85 2
			rctx->blitter, rctx->ps_samplers.n_views,
			(struct pipe_sampler_view**)rctx->ps_samplers.views);
d89 6
a94 4
		rctx->saved_render_cond = rctx->current_render_cond;
		rctx->saved_render_cond_mode = rctx->current_render_cond_mode;
		rctx->context.render_condition(&rctx->context, NULL, 0);
	}
d96 4
d102 1
a102 1
static void r600_blitter_end(struct pipe_context *ctx)
d104 1
a104 9
	struct r600_pipe_context *rctx = (struct r600_pipe_context *)ctx;
	if (rctx->saved_render_cond) {
		rctx->context.render_condition(&rctx->context,
					       rctx->saved_render_cond,
					       rctx->saved_render_cond_mode);
		rctx->saved_render_cond = NULL;
	}
	r600_context_queries_resume(&rctx->ctx, FALSE);
	rctx->blit = false;
d107 6
a112 1
void r600_blit_uncompress_depth(struct pipe_context *ctx, struct r600_resource_texture *texture)
d114 7
a120 4
	struct r600_pipe_context *rctx = (struct r600_pipe_context *)ctx;
	struct pipe_surface *zsurf, *cbsurf, surf_tmpl;
	int level = 0;
	float depth = 1.0f;
d122 1
a122 1
	if (!texture->dirty_db)
d125 9
a133 12
	surf_tmpl.format = texture->resource.b.b.b.format;
	surf_tmpl.u.tex.level = level;
	surf_tmpl.u.tex.first_layer = 0;
	surf_tmpl.u.tex.last_layer = 0;
	surf_tmpl.usage = PIPE_BIND_DEPTH_STENCIL;

	zsurf = ctx->create_surface(ctx, &texture->resource.b.b.b, &surf_tmpl);

	surf_tmpl.format = ((struct pipe_resource*)texture->flushed_depth_texture)->format;
	surf_tmpl.usage = PIPE_BIND_RENDER_TARGET;
	cbsurf = ctx->create_surface(ctx,
			(struct pipe_resource*)texture->flushed_depth_texture, &surf_tmpl);
d138 2
d141 6
a146 3
	r600_blitter_begin(ctx, R600_DECOMPRESS);
	util_blitter_custom_depth_stencil(rctx->blitter, zsurf, cbsurf, rctx->custom_dsa_flush, depth);
	r600_blitter_end(ctx);
d148 3
a150 2
	pipe_surface_reference(&zsurf, NULL);
	pipe_surface_reference(&cbsurf, NULL);
d152 50
a201 1
	texture->dirty_db = FALSE;
d204 4
a207 1
void r600_flush_depth_textures(struct r600_pipe_context *rctx)
d209 8
a216 1
	unsigned int i;
d218 5
a222 1
	/* FIXME: This handles fragment shader textures only. */
d224 25
a248 3
	for (i = 0; i < rctx->ps_samplers.n_views; ++i) {
		struct r600_pipe_sampler_view *view;
		struct r600_resource_texture *tex;
d250 44
a293 2
		view = rctx->ps_samplers.views[i];
		if (!view) continue;
d295 5
a299 2
		tex = (struct r600_resource_texture *)view->base.texture;
		if (!tex->depth)
d302 86
a387 2
		if (tex->is_flushing_texture)
			continue;
d389 44
a432 1
		r600_blit_uncompress_depth(&rctx->context, tex);
d435 8
a442 4
	/* also check CB here */
	for (i = 0; i < rctx->framebuffer.nr_cbufs; i++) {
		struct r600_resource_texture *tex;
		tex = (struct r600_resource_texture *)rctx->framebuffer.cbufs[i]->texture;
d444 3
a446 2
		if (!tex->depth)
			continue;
d448 2
a449 2
		if (tex->is_flushing_texture)
			continue;
d451 14
a464 1
		r600_blit_uncompress_depth(&rctx->context, tex);
d466 2
d471 2
a472 1
			const float *rgba, double depth, unsigned stencil)
d474 44
a517 2
	struct r600_pipe_context *rctx = (struct r600_pipe_context *)ctx;
	struct pipe_framebuffer_state *fb = &rctx->framebuffer;
d521 1
a521 2
				fb->nr_cbufs, buffers, rgba, depth,
				stencil);
d523 6
d533 1
a533 1
				     const float *rgba,
d537 1
a537 1
	struct r600_pipe_context *rctx = (struct r600_pipe_context *)ctx;
d540 1
a540 1
	util_blitter_clear_render_target(rctx->blitter, dst, rgba,
d553 1
a553 1
	struct r600_pipe_context *rctx = (struct r600_pipe_context *)ctx;
d561 4
d566 20
a585 16

/* Copy a block of pixels from one surface to another using HW. */
static void r600_hw_copy_region(struct pipe_context *ctx,
				struct pipe_resource *dst,
				unsigned dst_level,
				unsigned dstx, unsigned dsty, unsigned dstz,
				struct pipe_resource *src,
				unsigned src_level,
				const struct pipe_box *src_box)
{
	struct r600_pipe_context *rctx = (struct r600_pipe_context *)ctx;

	r600_blitter_begin(ctx, R600_COPY);
	util_blitter_copy_region(rctx->blitter, dst, dst_level, dstx, dsty, dstz,
				 src, src_level, src_box, TRUE);
	r600_blitter_end(ctx);
d588 5
a592 5
struct texture_orig_info {
	unsigned format;
	unsigned width0;
	unsigned height0;
};
d594 26
a619 25
static void r600_compressed_to_blittable(struct pipe_resource *tex,
				   unsigned level,
				   struct texture_orig_info *orig)
{
	struct r600_resource_texture *rtex = (struct r600_resource_texture*)tex;
	unsigned pixsize = util_format_get_blocksize(tex->format);
	int new_format;
	int new_height, new_width;

	orig->format = tex->format;
	orig->width0 = tex->width0;
	orig->height0 = tex->height0;

	if (pixsize == 8)
		new_format = PIPE_FORMAT_R16G16B16A16_UNORM; /* 64-bit block */
	else
		new_format = PIPE_FORMAT_R32G32B32A32_UNORM; /* 128-bit block */

	new_width = util_format_get_nblocksx(tex->format, orig->width0);
	new_height = util_format_get_nblocksy(tex->format, orig->height0);

	rtex->force_int_type = true;
	tex->width0 = new_width;
	tex->height0 = new_height;
	tex->format = new_format;
d621 7
d630 1
a630 3
static void r600_reset_blittable_to_compressed(struct pipe_resource *tex,
					 unsigned level,
					 struct texture_orig_info *orig)
d632 1
a632 2
	struct r600_resource_texture *rtex = (struct r600_resource_texture*)tex;
	rtex->force_int_type = false;
d634 4
a637 3
	tex->format = orig->format;
	tex->width0 = orig->width0;
	tex->height0 = orig->height0;
d648 5
a652 5
	struct r600_resource_texture *rsrc = (struct r600_resource_texture*)src;
	struct texture_orig_info orig_info[2];
	struct pipe_box sbox;
	const struct pipe_box *psbox;
	boolean restore_orig[2];
d654 1
a654 1
	/* Fallback for buffers. */
d656 1
a656 2
		util_resource_copy_region(ctx, dst, dst_level, dstx, dsty, dstz,
                                          src, src_level, src_box);
d660 1
a660 2
	if (rsrc->depth && !rsrc->is_flushing_texture)
		r600_texture_depth_flush(ctx, src, FALSE);
d662 16
a677 1
	restore_orig[0] = restore_orig[1] = FALSE;
d680 20
a699 4
		r600_compressed_to_blittable(src, src_level, &orig_info[0]);
		restore_orig[0] = TRUE;
		sbox.x = util_format_get_nblocksx(orig_info[0].format, src_box->x);
		sbox.y = util_format_get_nblocksy(orig_info[0].format, src_box->y);
d701 2
a702 2
		sbox.width = util_format_get_nblocksx(orig_info[0].format, src_box->width);
		sbox.height = util_format_get_nblocksy(orig_info[0].format, src_box->height);
d704 62
a765 3
		psbox=&sbox;
	} else
		psbox=src_box;
d767 73
a839 6
	if (util_format_is_compressed(dst->format)) {
		r600_compressed_to_blittable(dst, dst_level, &orig_info[1]);
		restore_orig[1] = TRUE;
		/* translate the dst box as well */
		dstx = util_format_get_nblocksx(orig_info[1].format, dstx);
		dsty = util_format_get_nblocksy(orig_info[1].format, dsty);
d842 50
a891 2
	r600_hw_copy_region(ctx, dst, dst_level, dstx, dsty, dstz,
			    src, src_level, psbox);
d893 7
a899 2
	if (restore_orig[0])
		r600_reset_blittable_to_compressed(src, src_level, &orig_info[0]);
d901 3
a903 2
	if (restore_orig[1])
		r600_reset_blittable_to_compressed(dst, dst_level, &orig_info[1]);
d906 1
a906 1
void r600_init_blit_functions(struct r600_pipe_context *rctx)
d912 1
a912 16
}

void r600_blit_push_depth(struct pipe_context *ctx, struct r600_resource_texture *texture)
{
	struct pipe_box sbox;

	sbox.x = sbox.y = sbox.z = 0;
	sbox.width = texture->resource.b.b.b.width0;
	sbox.height = texture->resource.b.b.b.height0;
	/* XXX that might be wrong */
	sbox.depth = 1;

	r600_hw_copy_region(ctx, (struct pipe_resource *)texture, 0,
			    0, 0, 0,
			    (struct pipe_resource *)texture->flushed_depth_texture, 0,
			    &sbox);
@


1.1
log
@Initial revision
@
text
@d30 12
a41 3
	R600_CLEAR         = 1,
	R600_CLEAR_SURFACE = 2,
	R600_COPY          = 4
d48 1
d66 3
a68 1
	util_blitter_save_vertex_buffers(rctx->blitter, rctx->nvertex_buffer, rctx->vertex_buffer);
d70 1
a70 3
	rctx->vertex_elements = NULL;

	if (op & (R600_CLEAR_SURFACE | R600_COPY))
d73 1
a73 1
	if (op & R600_COPY) {
d83 6
d94 8
a101 1
	r600_context_queries_resume(&rctx->ctx);
d104 1
a104 1
int r600_blit_uncompress_depth(struct pipe_context *ctx, struct r600_resource_texture *texture)
d110 5
a114 1
	surf_tmpl.format = texture->resource.base.b.format;
d120 1
a120 1
	zsurf = ctx->create_surface(ctx, &texture->resource.base.b, &surf_tmpl);
d131 1
a131 1
	r600_blitter_begin(ctx, R600_CLEAR_SURFACE);
d138 6
d145 32
a176 1
	return 0;
d241 46
d295 8
a302 4
	boolean is_depth;
	/* there is something wrong with depth resource copies at the moment so avoid them for now */
	is_depth = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 0) != 0;
	if (is_depth)
d304 38
a341 4
					  src, src_level, src_box);
	else
		r600_hw_copy_region(ctx, dst, dst_level, dstx, dsty, dstz,
				    src, src_level, src_box);
d350 16
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d23 3
a26 3
#include "util/u_surface.h"
#include "util/u_blitter.h"
#include "util/u_format.h"
d30 3
a32 20
	R600_SAVE_FRAGMENT_STATE = 1,
	R600_SAVE_TEXTURES       = 2,
	R600_SAVE_FRAMEBUFFER    = 4,
	R600_DISABLE_RENDER_COND = 8,

	R600_CLEAR         = R600_SAVE_FRAGMENT_STATE,

	R600_CLEAR_SURFACE = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER,

	R600_COPY_BUFFER   = R600_DISABLE_RENDER_COND,

	R600_COPY_TEXTURE  = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES |
			     R600_DISABLE_RENDER_COND,

	R600_BLIT          = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES |
			     R600_DISABLE_RENDER_COND,

	R600_DECOMPRESS    = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_DISABLE_RENDER_COND,

	R600_COLOR_RESOLVE = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_DISABLE_RENDER_COND
d37 1
a37 1
	struct r600_context *rctx = (struct r600_context *)ctx;
d39 1
a39 1
	r600_suspend_nontimer_queries(rctx);
d41 7
a47 2
	util_blitter_save_vertex_buffer_slot(rctx->blitter, rctx->vertex_buffer_state.vb);
	util_blitter_save_vertex_elements(rctx->blitter, rctx->vertex_fetch_shader.cso);
d49 6
a54 12
	util_blitter_save_so_targets(rctx->blitter, rctx->streamout.num_targets,
				     (struct pipe_stream_output_target**)rctx->streamout.targets);
	util_blitter_save_rasterizer(rctx->blitter, rctx->rasterizer_state.cso);

	if (op & R600_SAVE_FRAGMENT_STATE) {
		util_blitter_save_viewport(rctx->blitter, &rctx->viewport.state);
		util_blitter_save_scissor(rctx->blitter, &rctx->scissor.scissor);
		util_blitter_save_fragment_shader(rctx->blitter, rctx->ps_shader);
		util_blitter_save_blend(rctx->blitter, rctx->blend_state.cso);
		util_blitter_save_depth_stencil_alpha(rctx->blitter, rctx->dsa_state.cso);
		util_blitter_save_stencil_ref(rctx->blitter, &rctx->stencil_ref.pipe_state);
                util_blitter_save_sample_mask(rctx->blitter, rctx->sample_mask.sample_mask);
d56 1
d58 1
a58 2
	if (op & R600_SAVE_FRAMEBUFFER)
		util_blitter_save_framebuffer(rctx->blitter, &rctx->framebuffer.state);
d60 4
a63 1
	if (op & R600_SAVE_TEXTURES) {
d65 2
a66 2
			rctx->blitter, util_last_bit(rctx->samplers[PIPE_SHADER_FRAGMENT].states.enabled_mask),
			(void**)rctx->samplers[PIPE_SHADER_FRAGMENT].states.states);
d69 2
a70 2
			rctx->blitter, util_last_bit(rctx->samplers[PIPE_SHADER_FRAGMENT].views.enabled_mask),
			(struct pipe_sampler_view**)rctx->samplers[PIPE_SHADER_FRAGMENT].views.views);
a72 6
	if ((op & R600_DISABLE_RENDER_COND) && rctx->current_render_cond) {
           util_blitter_save_render_condition(rctx->blitter,
                                              rctx->current_render_cond,
                                              rctx->current_render_cond_cond,
                                              rctx->current_render_cond_mode);
        }
d77 2
a78 7
	struct r600_context *rctx = (struct r600_context *)ctx;
        r600_resume_nontimer_queries(rctx);
}

static unsigned u_max_sample(struct pipe_resource *r)
{
	return r->nr_samples ? r->nr_samples - 1 : 0;
d81 1
a81 6
void r600_blit_decompress_depth(struct pipe_context *ctx,
		struct r600_texture *texture,
		struct r600_texture *staging,
		unsigned first_level, unsigned last_level,
		unsigned first_layer, unsigned last_layer,
		unsigned first_sample, unsigned last_sample)
d83 16
a98 20
	struct r600_context *rctx = (struct r600_context *)ctx;
	unsigned layer, level, sample, checked_last_layer, max_layer, max_sample;
	struct r600_texture *flushed_depth_texture = staging ?
			staging : texture->flushed_depth_texture;
	const struct util_format_description *desc =
		util_format_description(texture->resource.b.b.format);
	float depth;

	if (!staging && !texture->dirty_level_mask)
		return;

	max_sample = u_max_sample(&texture->resource.b.b);

	/* XXX Decompressing MSAA depth textures is broken on R6xx.
	 * There is also a hardlock if CMASK and FMASK are not present.
	 * Just skip this until we find out how to fix it. */
	if (rctx->chip_class == R600 && max_sample > 0) {
		texture->dirty_level_mask = 0;
		return;
	}
a102 2
	else
		depth = 1.0f;
d104 3
a106 204
	/* Enable decompression in DB_RENDER_CONTROL */
	rctx->db_misc_state.flush_depthstencil_through_cb = true;
	rctx->db_misc_state.copy_depth = util_format_has_depth(desc);
	rctx->db_misc_state.copy_stencil = util_format_has_stencil(desc);
	rctx->db_misc_state.copy_sample = first_sample;
	rctx->db_misc_state.atom.dirty = true;

	for (level = first_level; level <= last_level; level++) {
		if (!staging && !(texture->dirty_level_mask & (1 << level)))
			continue;

		/* The smaller the mipmap level, the less layers there are
		 * as far as 3D textures are concerned. */
		max_layer = util_max_layer(&texture->resource.b.b, level);
		checked_last_layer = last_layer < max_layer ? last_layer : max_layer;

		for (layer = first_layer; layer <= checked_last_layer; layer++) {
			for (sample = first_sample; sample <= last_sample; sample++) {
				struct pipe_surface *zsurf, *cbsurf, surf_tmpl;

				if (sample != rctx->db_misc_state.copy_sample) {
					rctx->db_misc_state.copy_sample = sample;
					rctx->db_misc_state.atom.dirty = true;
				}

				surf_tmpl.format = texture->resource.b.b.format;
				surf_tmpl.u.tex.level = level;
				surf_tmpl.u.tex.first_layer = layer;
				surf_tmpl.u.tex.last_layer = layer;

				zsurf = ctx->create_surface(ctx, &texture->resource.b.b, &surf_tmpl);

				surf_tmpl.format = flushed_depth_texture->resource.b.b.format;
				surf_tmpl.u.tex.level = level;
				surf_tmpl.u.tex.first_layer = layer;
				surf_tmpl.u.tex.last_layer = layer;
				cbsurf = ctx->create_surface(ctx,
						&flushed_depth_texture->resource.b.b, &surf_tmpl);

				r600_blitter_begin(ctx, R600_DECOMPRESS);
				util_blitter_custom_depth_stencil(rctx->blitter, zsurf, cbsurf, 1 << sample,
								  rctx->custom_dsa_flush, depth);
				r600_blitter_end(ctx);

				pipe_surface_reference(&zsurf, NULL);
				pipe_surface_reference(&cbsurf, NULL);
			}
		}

		/* The texture will always be dirty if some layers or samples aren't flushed.
		 * I don't think this case occurs often though. */
		if (!staging &&
		    first_layer == 0 && last_layer == max_layer &&
		    first_sample == 0 && last_sample == max_sample) {
			texture->dirty_level_mask &= ~(1 << level);
		}
	}

	/* reenable compression in DB_RENDER_CONTROL */
	rctx->db_misc_state.flush_depthstencil_through_cb = false;
	rctx->db_misc_state.atom.dirty = true;
}

static void r600_blit_decompress_depth_in_place(struct r600_context *rctx,
                                                struct r600_texture *texture,
                                                unsigned first_level, unsigned last_level,
                                                unsigned first_layer, unsigned last_layer)
{
	struct pipe_surface *zsurf, surf_tmpl = {{0}};
	unsigned layer, max_layer, checked_last_layer, level;

	/* Enable decompression in DB_RENDER_CONTROL */
	rctx->db_misc_state.flush_depthstencil_in_place = true;
	rctx->db_misc_state.atom.dirty = true;

	surf_tmpl.format = texture->resource.b.b.format;

	for (level = first_level; level <= last_level; level++) {
		if (!(texture->dirty_level_mask & (1 << level)))
			continue;

		surf_tmpl.u.tex.level = level;

		/* The smaller the mipmap level, the less layers there are
		 * as far as 3D textures are concerned. */
		max_layer = util_max_layer(&texture->resource.b.b, level);
		checked_last_layer = last_layer < max_layer ? last_layer : max_layer;

		for (layer = first_layer; layer <= checked_last_layer; layer++) {
			surf_tmpl.u.tex.first_layer = layer;
			surf_tmpl.u.tex.last_layer = layer;

			zsurf = rctx->context.create_surface(&rctx->context, &texture->resource.b.b, &surf_tmpl);

			r600_blitter_begin(&rctx->context, R600_DECOMPRESS);
			util_blitter_custom_depth_stencil(rctx->blitter, zsurf, NULL, ~0,
							  rctx->custom_dsa_flush, 1.0f);
			r600_blitter_end(&rctx->context);

			pipe_surface_reference(&zsurf, NULL);
		}

		/* The texture will always be dirty if some layers or samples aren't flushed.
		 * I don't think this case occurs often though. */
		if (first_layer == 0 && last_layer == max_layer) {
			texture->dirty_level_mask &= ~(1 << level);
		}
	}

	/* Disable decompression in DB_RENDER_CONTROL */
	rctx->db_misc_state.flush_depthstencil_in_place = false;
	rctx->db_misc_state.atom.dirty = true;
}

void r600_decompress_depth_textures(struct r600_context *rctx,
			       struct r600_samplerview_state *textures)
{
	unsigned i;
	unsigned depth_texture_mask = textures->compressed_depthtex_mask;

	while (depth_texture_mask) {
		struct pipe_sampler_view *view;
		struct r600_texture *tex;

		i = u_bit_scan(&depth_texture_mask);

		view = &textures->views[i]->base;
		assert(view);

		tex = (struct r600_texture *)view->texture;
		assert(tex->is_depth && !tex->is_flushing_texture);

		if (rctx->chip_class >= EVERGREEN ||
		    r600_can_read_depth(tex)) {
			r600_blit_decompress_depth_in_place(rctx, tex,
						   view->u.tex.first_level, view->u.tex.last_level,
						   0, util_max_layer(&tex->resource.b.b, view->u.tex.first_level));
		} else {
			r600_blit_decompress_depth(&rctx->context, tex, NULL,
						   view->u.tex.first_level, view->u.tex.last_level,
						   0, util_max_layer(&tex->resource.b.b, view->u.tex.first_level),
						   0, u_max_sample(&tex->resource.b.b));
		}
	}
}

static void r600_blit_decompress_color(struct pipe_context *ctx,
		struct r600_texture *rtex,
		unsigned first_level, unsigned last_level,
		unsigned first_layer, unsigned last_layer)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	unsigned layer, level, checked_last_layer, max_layer;

	if (!rtex->dirty_level_mask)
		return;

	for (level = first_level; level <= last_level; level++) {
		if (!(rtex->dirty_level_mask & (1 << level)))
			continue;

		/* The smaller the mipmap level, the less layers there are
		 * as far as 3D textures are concerned. */
		max_layer = util_max_layer(&rtex->resource.b.b, level);
		checked_last_layer = last_layer < max_layer ? last_layer : max_layer;

		for (layer = first_layer; layer <= checked_last_layer; layer++) {
			struct pipe_surface *cbsurf, surf_tmpl;

			surf_tmpl.format = rtex->resource.b.b.format;
			surf_tmpl.u.tex.level = level;
			surf_tmpl.u.tex.first_layer = layer;
			surf_tmpl.u.tex.last_layer = layer;
			cbsurf = ctx->create_surface(ctx, &rtex->resource.b.b, &surf_tmpl);

			r600_blitter_begin(ctx, R600_DECOMPRESS);
			util_blitter_custom_color(rctx->blitter, cbsurf, rctx->custom_blend_decompress);
			r600_blitter_end(ctx);

			pipe_surface_reference(&cbsurf, NULL);
		}

		/* The texture will always be dirty if some layers aren't flushed.
		 * I don't think this case occurs often though. */
		if (first_layer == 0 && last_layer == max_layer) {
			rtex->dirty_level_mask &= ~(1 << level);
		}
	}
}

void r600_decompress_color_textures(struct r600_context *rctx,
				    struct r600_samplerview_state *textures)
{
	unsigned i;
	unsigned mask = textures->compressed_colortex_mask;

	while (mask) {
		struct pipe_sampler_view *view;
		struct r600_texture *tex;

		i = u_bit_scan(&mask);

		view = &textures->views[i]->base;
		assert(view);
d108 2
a109 2
		tex = (struct r600_texture *)view->texture;
		assert(tex->cmask_size && tex->fmask_size);
a110 5
		r600_blit_decompress_color(&rctx->context, tex,
					   view->u.tex.first_level, view->u.tex.last_level,
					   0, util_max_layer(&tex->resource.b.b, view->u.tex.first_level));
	}
}
d112 1
a112 113
/* Helper for decompressing a portion of a color or depth resource before
 * blitting if any decompression is needed.
 * The driver doesn't decompress resources automatically while u_blitter is
 * rendering. */
static bool r600_decompress_subresource(struct pipe_context *ctx,
					struct pipe_resource *tex,
					unsigned level,
					unsigned first_layer, unsigned last_layer)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct r600_texture *rtex = (struct r600_texture*)tex;

	if (rtex->is_depth && !rtex->is_flushing_texture) {
		if (rctx->chip_class >= EVERGREEN ||
		    r600_can_read_depth(rtex)) {
			r600_blit_decompress_depth_in_place(rctx, rtex,
						   level, level,
						   first_layer, last_layer);
		} else {
			if (!r600_init_flushed_depth_texture(ctx, tex, NULL))
				return false; /* error */

			r600_blit_decompress_depth(ctx, rtex, NULL,
						   level, level,
						   first_layer, last_layer,
						   0, u_max_sample(tex));
		}
	} else if (rtex->fmask_size && rtex->cmask_size) {
		r600_blit_decompress_color(ctx, rtex, level, level,
					   first_layer, last_layer);
	}
	return true;
}

static boolean is_simple_msaa_resolve(const struct pipe_blit_info *info)
{
	unsigned dst_width = u_minify(info->dst.resource->width0, info->dst.level);
	unsigned dst_height = u_minify(info->dst.resource->height0, info->dst.level);
	struct r600_texture *dst = (struct r600_texture*)info->dst.resource;
	unsigned dst_tile_mode = dst->surface.level[info->dst.level].mode;

	return info->dst.resource->format == info->src.resource->format &&
		info->dst.resource->format == info->dst.format &&
		info->src.resource->format == info->src.format &&
		!info->scissor_enable &&
		info->mask == PIPE_MASK_RGBA &&
		dst_width == info->src.resource->width0 &&
		dst_height == info->src.resource->height0 &&
		info->dst.box.x == 0 &&
		info->dst.box.y == 0 &&
		info->dst.box.width == dst_width &&
		info->dst.box.height == dst_height &&
		info->src.box.x == 0 &&
		info->src.box.y == 0 &&
		info->src.box.width == dst_width &&
		info->src.box.height == dst_height &&
		/* Dst must be tiled. If it's not, we have to use a temporary
		 * resource which is tiled. */
		dst_tile_mode >= RADEON_SURF_MODE_1D;
}

static void r600_clear_buffer(struct pipe_context *ctx, struct pipe_resource *dst,
			      unsigned offset, unsigned size, unsigned char value);

static void evergreen_set_clear_color(struct pipe_surface *cbuf,
				      const union pipe_color_union *color)
{
	unsigned *clear_value = ((struct r600_texture *)cbuf->texture)->color_clear_value;
	union util_color uc;

	memset(&uc, 0, sizeof(uc));

	if (util_format_is_pure_uint(cbuf->format)) {
		util_format_write_4ui(cbuf->format, color->ui, 0, &uc, 0, 0, 0, 1, 1);
	} else if (util_format_is_pure_sint(cbuf->format)) {
		util_format_write_4i(cbuf->format, color->i, 0, &uc, 0, 0, 0, 1, 1);
	} else {
		util_pack_color(color->f, cbuf->format, &uc);
	}

	memcpy(clear_value, &uc, 2 * sizeof(uint32_t));
}

static bool can_fast_clear_color(struct pipe_context *ctx)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_framebuffer_state *fb = &rctx->framebuffer.state;
	int i;

	if (rctx->chip_class < EVERGREEN) {
		return false;
	}

	for (i = 0; i < fb->nr_cbufs; i++) {
		struct r600_texture *tex = (struct r600_texture *)fb->cbufs[i]->texture;

		if (tex->cmask_size == 0) {
			return false;
		}

		/* 128-bit formats are unuspported */
		if (util_format_get_blocksizebits(fb->cbufs[i]->format) > 64) {
			return false;
		}

		/* the clear is allowed if all layers are bound */
		if (fb->cbufs[i]->u.tex.first_layer != 0 ||
		    fb->cbufs[i]->u.tex.last_layer != util_max_layer(&tex->resource.b.b, 0)) {
			return false;
		}
	}

	return true;
d116 1
a116 2
		       const union pipe_color_union *color,
		       double depth, unsigned stencil)
d118 2
a119 44
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_framebuffer_state *fb = &rctx->framebuffer.state;

	/* fast color clear on AA framebuffers (EG+) */
	if ((buffers & PIPE_CLEAR_COLOR) && can_fast_clear_color(ctx)) {
		int i;

		for (i = 0; i < fb->nr_cbufs; i++) {
			struct r600_texture *tex = (struct r600_texture *)fb->cbufs[i]->texture;

			evergreen_set_clear_color(fb->cbufs[i], color);
			r600_clear_buffer(ctx, fb->cbufs[i]->texture,
					tex->cmask_offset, tex->cmask_size, 0);
			tex->dirty_level_mask |= 1 << fb->cbufs[i]->u.tex.level;
		}

		rctx->framebuffer.atom.dirty = true;

		buffers &= ~PIPE_CLEAR_COLOR;
		if (!buffers)
			return;
	}

	/* if hyperz enabled just clear hyperz */
	if (fb->zsbuf && (buffers & PIPE_CLEAR_DEPTH)) {
		struct r600_texture *rtex;
		unsigned level = fb->zsbuf->u.tex.level;

		rtex = (struct r600_texture*)fb->zsbuf->texture;

		/* We can't use hyperz fast clear if each slice of a texture
		 * array are clear to different value. To simplify code just
		 * disable fast clear for texture array.
		 */
		/* Only use htile for first level */
		if (rtex->htile && !level && rtex->surface.array_size == 1) {
			if (rtex->depth_clear != depth) {
				rtex->depth_clear = depth;
				rctx->db_state.atom.dirty = true;
			}
			rctx->db_misc_state.htile_clear = true;
			rctx->db_misc_state.atom.dirty = true;
		}
	}
d123 2
a124 1
			   buffers, color, depth, stencil);
a125 6

	/* disable fast clear */
	if (rctx->db_misc_state.htile_clear) {
		rctx->db_misc_state.htile_clear = false;
		rctx->db_misc_state.atom.dirty = true;
	}
d130 1
a130 1
				     const union pipe_color_union *color,
d134 1
a134 1
	struct r600_context *rctx = (struct r600_context *)ctx;
d137 1
a137 1
	util_blitter_clear_render_target(rctx->blitter, dst, color,
d150 1
a150 1
	struct r600_context *rctx = (struct r600_context *)ctx;
a157 32
void r600_copy_buffer(struct pipe_context *ctx, struct pipe_resource *dst, unsigned dstx,
		      struct pipe_resource *src, const struct pipe_box *src_box)
{
	struct r600_context *rctx = (struct r600_context*)ctx;

	if (rctx->screen->has_cp_dma) {
		r600_cp_dma_copy_buffer(rctx, dst, dstx, src, src_box->x, src_box->width);
	}
	else if (rctx->screen->has_streamout &&
		 /* Require 4-byte alignment. */
		 dstx % 4 == 0 && src_box->x % 4 == 0 && src_box->width % 4 == 0) {

		/* Flush both resources. */
		r600_flag_resource_cache_flush(rctx, src);
		r600_flag_resource_cache_flush(rctx, dst);

		r600_blitter_begin(ctx, R600_COPY_BUFFER);
		util_blitter_copy_buffer(rctx->blitter, dst, dstx, src, src_box->x, src_box->width);
		r600_blitter_end(ctx);

		/* Flush the dst in case the 3D engine has been prefetching the resource. */
		r600_flag_resource_cache_flush(rctx, dst);
	} else {
		util_resource_copy_region(ctx, dst, 0, dstx, 0, 0, src, 0, src_box);
	}
}

static void r600_clear_buffer(struct pipe_context *ctx, struct pipe_resource *dst,
			      unsigned offset, unsigned size, unsigned char value)
{
	struct r600_context *rctx = (struct r600_context*)ctx;
	uint32_t v = value;
a158 26
	if (rctx->screen->has_cp_dma &&
	    rctx->chip_class >= EVERGREEN &&
	    offset % 4 == 0 && size % 4 == 0) {
		uint32_t clear_value = v | (v << 8) | (v << 16) | (v << 24);

		evergreen_cp_dma_clear_buffer(rctx, dst, offset, size, clear_value);
	} else if (rctx->screen->has_streamout && offset % 4 == 0 && size % 4 == 0) {
		union pipe_color_union clear_value;

		clear_value.ui[0] = v | (v << 8) | (v << 16) | (v << 24);

		r600_flag_resource_cache_flush(rctx, dst);

		r600_blitter_begin(ctx, R600_DISABLE_RENDER_COND);
		util_blitter_clear_buffer(rctx->blitter, dst, offset, size,
					  1, &clear_value);
		r600_blitter_end(ctx);

		/* Flush again in case the 3D engine has been prefetching the resource. */
		r600_flag_resource_cache_flush(rctx, dst);
	} else {
		char *map = r600_buffer_mmap_sync_with_rings(rctx, r600_resource(dst),
							     PIPE_TRANSFER_WRITE);
		memset(map + offset, value, size);
	}
}
d160 15
a174 17
void r600_screen_clear_buffer(struct r600_screen *rscreen, struct pipe_resource *dst,
			      unsigned offset, unsigned size, unsigned char value)
{
	pipe_mutex_lock(rscreen->aux_context_lock);
	r600_clear_buffer(rscreen->aux_context, dst, offset, size, value);
	rscreen->aux_context->flush(rscreen->aux_context, NULL, 0);
	pipe_mutex_unlock(rscreen->aux_context_lock);
}

static bool util_format_is_subsampled_2x1_32bpp(enum pipe_format format)
{
	const struct util_format_description *desc = util_format_description(format);

	return desc->layout == UTIL_FORMAT_LAYOUT_SUBSAMPLED &&
	       desc->block.width == 2 &&
	       desc->block.height == 1 &&
	       desc->block.bits == 32;
d185 9
a193 256
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_surface *dst_view, dst_templ;
	struct pipe_sampler_view src_templ, *src_view;
	unsigned dst_width, dst_height, src_width0, src_height0, src_widthFL, src_heightFL;
	struct pipe_box sbox, dstbox;

	/* Handle buffers first. */
	if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
		r600_copy_buffer(ctx, dst, dstx, src, src_box);
		return;
	}

	assert(u_max_sample(dst) == u_max_sample(src));

	/* The driver doesn't decompress resources automatically while
	 * u_blitter is rendering. */
	if (!r600_decompress_subresource(ctx, src, src_level,
					 src_box->z, src_box->z + src_box->depth - 1)) {
		return; /* error */
	}

	dst_width = u_minify(dst->width0, dst_level);
        dst_height = u_minify(dst->height0, dst_level);
	src_width0 = src->width0;
	src_height0 = src->height0;
        src_widthFL = u_minify(src->width0, src_level);
        src_heightFL = u_minify(src->height0, src_level);

	util_blitter_default_dst_texture(&dst_templ, dst, dst_level, dstz);
	util_blitter_default_src_texture(&src_templ, src, src_level);

	if (util_format_is_compressed(src->format)) {
		unsigned blocksize = util_format_get_blocksize(src->format);

		if (blocksize == 8)
			src_templ.format = PIPE_FORMAT_R16G16B16A16_UINT; /* 64-bit block */
		else
			src_templ.format = PIPE_FORMAT_R32G32B32A32_UINT; /* 128-bit block */
		dst_templ.format = src_templ.format;

		dst_width = util_format_get_nblocksx(dst->format, dst_width);
		dst_height = util_format_get_nblocksy(dst->format, dst_height);
		src_width0 = util_format_get_nblocksx(src->format, src_width0);
		src_height0 = util_format_get_nblocksy(src->format, src_height0);
		src_widthFL = util_format_get_nblocksx(src->format, src_widthFL);
		src_heightFL = util_format_get_nblocksy(src->format, src_heightFL);

		dstx = util_format_get_nblocksx(dst->format, dstx);
		dsty = util_format_get_nblocksy(dst->format, dsty);

		sbox.x = util_format_get_nblocksx(src->format, src_box->x);
		sbox.y = util_format_get_nblocksy(src->format, src_box->y);
		sbox.z = src_box->z;
		sbox.width = util_format_get_nblocksx(src->format, src_box->width);
		sbox.height = util_format_get_nblocksy(src->format, src_box->height);
		sbox.depth = src_box->depth;
		src_box = &sbox;
	} else if (!util_blitter_is_copy_supported(rctx->blitter, dst, src,
						   PIPE_MASK_RGBAZS)) {
		if (util_format_is_subsampled_2x1_32bpp(src->format)) {

			src_templ.format = PIPE_FORMAT_R8G8B8A8_UINT;
			dst_templ.format = PIPE_FORMAT_R8G8B8A8_UINT;

			dst_width = util_format_get_nblocksx(dst->format, dst_width);
			src_width0 = util_format_get_nblocksx(src->format, src_width0);
			src_widthFL = util_format_get_nblocksx(src->format, src_widthFL);

			dstx = util_format_get_nblocksx(dst->format, dstx);

			sbox = *src_box;
			sbox.x = util_format_get_nblocksx(src->format, src_box->x);
			sbox.width = util_format_get_nblocksx(src->format, src_box->width);
			src_box = &sbox;
		} else {
			unsigned blocksize = util_format_get_blocksize(src->format);

			switch (blocksize) {
			case 1:
				dst_templ.format = PIPE_FORMAT_R8_UNORM;
				src_templ.format = PIPE_FORMAT_R8_UNORM;
				break;
                        case 2:
				dst_templ.format = PIPE_FORMAT_R8G8_UNORM;
				src_templ.format = PIPE_FORMAT_R8G8_UNORM;
				break;
			case 4:
				dst_templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
				src_templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
				break;
                        case 8:
                                dst_templ.format = PIPE_FORMAT_R16G16B16A16_UINT;
                                src_templ.format = PIPE_FORMAT_R16G16B16A16_UINT;
                                break;
                        case 16:
                                dst_templ.format = PIPE_FORMAT_R32G32B32A32_UINT;
                                src_templ.format = PIPE_FORMAT_R32G32B32A32_UINT;
                                break;
			default:
				fprintf(stderr, "Unhandled format %s with blocksize %u\n",
					util_format_short_name(src->format), blocksize);
				assert(0);
			}
		}
	}

	dst_view = r600_create_surface_custom(ctx, dst, &dst_templ, dst_width, dst_height);

	if (rctx->chip_class >= EVERGREEN) {
		src_view = evergreen_create_sampler_view_custom(ctx, src, &src_templ,
								src_width0, src_height0);
	} else {
		src_view = r600_create_sampler_view_custom(ctx, src, &src_templ,
							   src_widthFL, src_heightFL);
	}

        u_box_3d(dstx, dsty, dstz, abs(src_box->width), abs(src_box->height),
                 abs(src_box->depth), &dstbox);

	/* Copy. */
	r600_blitter_begin(ctx, R600_COPY_TEXTURE);
	util_blitter_blit_generic(rctx->blitter, dst_view, &dstbox,
				  src_view, src_box, src_width0, src_height0,
				  PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL,
				  TRUE);
	r600_blitter_end(ctx);

	pipe_surface_reference(&dst_view, NULL);
	pipe_sampler_view_reference(&src_view, NULL);
}

/* For MSAA integer resolving to work, we change the format to NORM using this function. */
static enum pipe_format int_to_norm_format(enum pipe_format format)
{
	switch (format) {
#define REPLACE_FORMAT_SIGN(format,sign) \
	case PIPE_FORMAT_##format##_##sign##INT: \
		return PIPE_FORMAT_##format##_##sign##NORM
#define REPLACE_FORMAT(format) \
		REPLACE_FORMAT_SIGN(format, U); \
		REPLACE_FORMAT_SIGN(format, S)

	REPLACE_FORMAT_SIGN(B10G10R10A2, U);
	REPLACE_FORMAT(R8);
	REPLACE_FORMAT(R8G8);
	REPLACE_FORMAT(R8G8B8X8);
	REPLACE_FORMAT(R8G8B8A8);
	REPLACE_FORMAT(A8);
	REPLACE_FORMAT(I8);
	REPLACE_FORMAT(L8);
	REPLACE_FORMAT(L8A8);
	REPLACE_FORMAT(R16);
	REPLACE_FORMAT(R16G16);
	REPLACE_FORMAT(R16G16B16X16);
	REPLACE_FORMAT(R16G16B16A16);
	REPLACE_FORMAT(A16);
	REPLACE_FORMAT(I16);
	REPLACE_FORMAT(L16);
	REPLACE_FORMAT(L16A16);

#undef REPLACE_FORMAT
#undef REPLACE_FORMAT_SIGN
	default:
		return format;
	}
}

static void r600_msaa_color_resolve(struct pipe_context *ctx,
			      const struct pipe_blit_info *info)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_screen *screen = ctx->screen;
	struct pipe_resource *tmp, templ;
	struct pipe_blit_info blit;
	unsigned sample_mask =
		rctx->chip_class == CAYMAN ? ~0 :
		((1ull << MAX2(1, info->src.resource->nr_samples)) - 1);

	assert(info->src.level == 0);
	assert(info->src.box.depth == 1);
	assert(info->dst.box.depth == 1);

	if (is_simple_msaa_resolve(info)) {
		r600_blitter_begin(ctx, R600_COLOR_RESOLVE);
		util_blitter_custom_resolve_color(rctx->blitter,
						  info->dst.resource, info->dst.level,
						  info->dst.box.z,
						  info->src.resource, info->src.box.z,
						  sample_mask, rctx->custom_blend_resolve,
                                                  int_to_norm_format(info->dst.format));
		r600_blitter_end(ctx);
		return;
	}

	/* resolve into a temporary texture, then blit */
	templ.target = PIPE_TEXTURE_2D;
	templ.format = info->src.resource->format;
	templ.width0 = info->src.resource->width0;
	templ.height0 = info->src.resource->height0;
	templ.depth0 = 1;
	templ.array_size = 1;
	templ.last_level = 0;
	templ.nr_samples = 0;
	templ.usage = PIPE_USAGE_STATIC;
	templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
	templ.flags = R600_RESOURCE_FLAG_FORCE_TILING; /* dst must not have a linear layout */

	tmp = screen->resource_create(screen, &templ);

	/* resolve */
	r600_blitter_begin(ctx, R600_COLOR_RESOLVE);
	util_blitter_custom_resolve_color(rctx->blitter,
					  tmp, 0, 0,
					  info->src.resource, info->src.box.z,
					  sample_mask, rctx->custom_blend_resolve,
                                          int_to_norm_format(tmp->format));
	r600_blitter_end(ctx);

	/* blit */
	blit = *info;
	blit.src.resource = tmp;
	blit.src.box.z = 0;

	r600_blitter_begin(ctx, R600_BLIT);
	util_blitter_blit(rctx->blitter, &blit);
	r600_blitter_end(ctx);

	pipe_resource_reference(&tmp, NULL);
}

static void r600_blit(struct pipe_context *ctx,
                      const struct pipe_blit_info *info)
{
	struct r600_context *rctx = (struct r600_context*)ctx;

	assert(util_blitter_is_blit_supported(rctx->blitter, info));

	if (info->src.resource->nr_samples > 1 &&
	    info->dst.resource->nr_samples <= 1 &&
	    !util_format_is_depth_or_stencil(info->src.resource->format) &&
	    !util_format_is_pure_integer(int_to_norm_format(info->src.resource->format))) {
		r600_msaa_color_resolve(ctx, info);
		return;
	}

	/* The driver doesn't decompress resources automatically while
	 * u_blitter is rendering. */
	if (!r600_decompress_subresource(ctx, info->src.resource, info->src.level,
					 info->src.box.z,
					 info->src.box.z + info->src.box.depth - 1)) {
		return; /* error */
	}

	r600_blitter_begin(ctx, R600_BLIT);
	util_blitter_blit(rctx->blitter, info);
	r600_blitter_end(ctx);
d196 1
a196 1
void r600_init_blit_functions(struct r600_context *rctx)
a201 1
	rctx->context.blit = r600_blit;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a26 1
#include "evergreend.h"
d56 1
a56 1
	r600_suspend_nontimer_queries(&rctx->b);
d61 2
a62 3
	util_blitter_save_geometry_shader(rctx->blitter, rctx->gs_shader);
	util_blitter_save_so_targets(rctx->blitter, rctx->b.streamout.num_targets,
				     (struct pipe_stream_output_target**)rctx->b.streamout.targets);
d66 2
a67 2
		util_blitter_save_viewport(rctx->blitter, &rctx->viewport[0].state);
		util_blitter_save_scissor(rctx->blitter, &rctx->scissor[0].scissor);
d88 1
a88 1
	if ((op & R600_DISABLE_RENDER_COND) && rctx->b.current_render_cond) {
d90 3
a92 3
                                              rctx->b.current_render_cond,
                                              rctx->b.current_render_cond_cond,
                                              rctx->b.current_render_cond_mode);
d99 1
a99 1
        r600_resume_nontimer_queries(&rctx->b);
d107 6
a112 6
static void r600_blit_decompress_depth(struct pipe_context *ctx,
				       struct r600_texture *texture,
				       struct r600_texture *staging,
				       unsigned first_level, unsigned last_level,
				       unsigned first_layer, unsigned last_layer,
				       unsigned first_sample, unsigned last_sample)
d130 1
a130 1
	if (rctx->b.chip_class == R600 && max_sample > 0) {
d135 2
a136 2
	if (rctx->b.family == CHIP_RV610 || rctx->b.family == CHIP_RV630 ||
	    rctx->b.family == CHIP_RV620 || rctx->b.family == CHIP_RV635)
d174 3
d233 1
a233 1
			zsurf = rctx->b.b.create_surface(&rctx->b.b, &texture->resource.b.b, &surf_tmpl);
d235 1
a235 1
			r600_blitter_begin(&rctx->b.b, R600_DECOMPRESS);
d238 1
a238 1
			r600_blitter_end(&rctx->b.b);
d273 1
a273 1
		if (rctx->b.chip_class >= EVERGREEN ||
d279 1
a279 1
			r600_blit_decompress_depth(&rctx->b.b, tex, NULL,
d317 1
a317 2
			util_blitter_custom_color(rctx->blitter, cbsurf,
				rtex->fmask.size ? rctx->custom_blend_decompress : rctx->custom_blend_fastclear);
d347 1
a347 1
		assert(tex->cmask.size);
d349 1
a349 1
		r600_blit_decompress_color(&rctx->b.b, tex,
d368 1
a368 1
		if (rctx->b.chip_class >= EVERGREEN ||
d382 1
a382 1
	} else if (rtex->cmask.size) {
d389 81
d477 2
a478 6
	if (buffers & PIPE_CLEAR_COLOR && rctx->b.chip_class >= EVERGREEN) {
		evergreen_do_fast_color_clear(&rctx->b, fb, &rctx->framebuffer.atom,
					      &buffers, color);
	}

	if (buffers & PIPE_CLEAR_COLOR) {
a480 1
		/* These buffers cannot use fast clear, make sure to disable expansion. */
d482 1
a482 1
			struct r600_texture *tex;
d484 4
a487 10
			/* If not clearing this buffer, skip. */
			if (!(buffers & (PIPE_CLEAR_COLOR0 << i)))
				continue;

			if (!fb->cbufs[i])
				continue;

			tex = (struct r600_texture *)fb->cbufs[i]->texture;
			if (tex->fmask.size == 0)
				tex->dirty_level_mask &= ~(1 << fb->cbufs[i]->u.tex.level);
d489 6
d509 3
a511 3
		if (rtex->htile_buffer && !level && rtex->surface.array_size == 1) {
			if (rtex->depth_clear_value != depth) {
				rtex->depth_clear_value = depth;
d520 1
a520 1
	util_blitter_clear(rctx->blitter, fb->width, fb->height, 1,
d561 2
a562 2
static void r600_copy_buffer(struct pipe_context *ctx, struct pipe_resource *dst, unsigned dstx,
			     struct pipe_resource *src, const struct pipe_box *src_box)
d566 1
a566 1
	if (rctx->screen->b.has_cp_dma) {
d569 1
a569 1
	else if (rctx->screen->b.has_streamout &&
d573 4
d580 3
a585 36

	/* The index buffer (VGT) doesn't seem to see the result of the copying.
	 * Can we somehow flush the index buffer cache? Starting a new IB seems
	 * to do the trick. */
	if (rctx->b.chip_class <= R700)
		rctx->b.rings.gfx.flush(ctx, RADEON_FLUSH_ASYNC, NULL);
}

/**
 * Global buffers are not really resources, they are are actually offsets
 * into a single global resource (r600_screen::global_pool).  The means
 * they don't have their own cs_buf handle, so they cannot be passed
 * to r600_copy_buffer() and must be handled separately.
 *
 * XXX: It should be possible to implement this function using
 * r600_copy_buffer() by passing the memory_pool resource as both src
 * and dst and updating dstx and src_box to point to the correct offsets.
 * This would likely perform better than the current implementation.
 */
static void r600_copy_global_buffer(struct pipe_context *ctx,
				    struct pipe_resource *dst, unsigned
				    dstx, struct pipe_resource *src,
				    const struct pipe_box *src_box)
{
	struct pipe_box dst_box; struct pipe_transfer *src_pxfer,
	*dst_pxfer;

	u_box_1d(dstx, src_box->width, &dst_box);
	void *src_ptr = ctx->transfer_map(ctx, src, 0, PIPE_TRANSFER_READ,
					  src_box, &src_pxfer);
	void *dst_ptr = ctx->transfer_map(ctx, dst, 0, PIPE_TRANSFER_WRITE,
					  &dst_box, &dst_pxfer);
	memcpy(dst_ptr, src_ptr, src_box->width);

	ctx->transfer_unmap(ctx, src_pxfer);
	ctx->transfer_unmap(ctx, dst_pxfer);
d589 1
a589 1
			      unsigned offset, unsigned size, unsigned value)
d592 1
d594 2
a595 2
	if (rctx->screen->b.has_cp_dma &&
	    rctx->b.chip_class >= EVERGREEN &&
d597 4
a600 2
		evergreen_cp_dma_clear_buffer(rctx, dst, offset, size, value);
	} else if (rctx->screen->b.has_streamout && offset % 4 == 0 && size % 4 == 0) {
d602 4
a605 1
		clear_value.ui[0] = value;
d611 3
d615 3
a617 5
		uint32_t *map = r600_buffer_map_sync_with_rings(&rctx->b, r600_resource(dst),
								 PIPE_TRANSFER_WRITE);
		size /= 4;
		for (unsigned i = 0; i < size; i++)
			*map++ = value;
d621 9
a651 1
	unsigned src_force_level = 0;
d656 1
a656 6
		if ((src->bind & PIPE_BIND_GLOBAL) ||
					(dst->bind & PIPE_BIND_GLOBAL)) {
			r600_copy_global_buffer(ctx, dst, dstx, src, src_box);
		} else {
			r600_copy_buffer(ctx, dst, dstx, src, src_box);
		}
d705 2
a706 3

		src_force_level = src_level;
	} else if (!util_blitter_is_copy_supported(rctx->blitter, dst, src)) {
d756 1
a756 1
	if (rctx->b.chip_class >= EVERGREEN) {
d758 1
a758 2
								src_width0, src_height0,
								src_force_level);
d771 2
a772 1
				  PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL);
d815 2
a816 2
static bool do_hardware_msaa_resolve(struct pipe_context *ctx,
				     const struct pipe_blit_info *info)
d818 4
a821 5
	struct r600_context *rctx = (struct r600_context*)ctx;
	struct r600_texture *dst = (struct r600_texture*)info->dst.resource;
	unsigned dst_width = u_minify(info->dst.resource->width0, info->dst.level);
	unsigned dst_height = u_minify(info->dst.resource->height0, info->dst.level);
	enum pipe_format format = int_to_norm_format(info->dst.format);
d823 1
a823 1
		rctx->b.chip_class == CAYMAN ? ~0 :
d826 5
a830 23
	if (info->src.resource->nr_samples > 1 &&
	    info->dst.resource->nr_samples <= 1 &&
	    util_max_layer(info->src.resource, 0) == 0 &&
	    util_max_layer(info->dst.resource, info->dst.level) == 0 &&
	    info->dst.format == info->src.format &&
	    !util_format_is_pure_integer(format) &&
	    !util_format_is_depth_or_stencil(format) &&
	    !info->scissor_enable &&
	    (info->mask & PIPE_MASK_RGBA) == PIPE_MASK_RGBA &&
	    dst_width == info->src.resource->width0 &&
	    dst_height == info->src.resource->height0 &&
	    info->dst.box.x == 0 &&
	    info->dst.box.y == 0 &&
	    info->dst.box.width == dst_width &&
	    info->dst.box.height == dst_height &&
	    info->dst.box.depth == 1 &&
	    info->src.box.x == 0 &&
	    info->src.box.y == 0 &&
	    info->src.box.width == dst_width &&
	    info->src.box.height == dst_height &&
	    info->src.box.depth == 1 &&
	    dst->surface.level[info->dst.level].mode >= RADEON_SURF_MODE_1D &&
	    (!dst->cmask.size || !dst->dirty_level_mask) /* dst cannot be fast-cleared */) {
d837 1
a837 1
						  format);
d839 1
a839 1
		return true;
d841 35
a875 1
	return false;
d883 7
a889 1
	if (do_hardware_msaa_resolve(ctx, info)) {
a892 2
	assert(util_blitter_is_blit_supported(rctx->blitter, info));

a905 13
static void r600_flush_resource(struct pipe_context *ctx,
				struct pipe_resource *res)
{
	struct r600_texture *rtex = (struct r600_texture*)res;

	assert(res->target != PIPE_BUFFER);

	if (!rtex->is_depth && rtex->cmask.size) {
		r600_blit_decompress_color(ctx, rtex, 0, res->last_level,
					   0, res->array_size - 1);
	}
}

d908 5
a912 8
	rctx->b.b.clear = r600_clear;
	rctx->b.b.clear_render_target = r600_clear_render_target;
	rctx->b.b.clear_depth_stencil = r600_clear_depth_stencil;
	rctx->b.b.resource_copy_region = r600_resource_copy_region;
	rctx->b.b.blit = r600_blit;
	rctx->b.b.flush_resource = r600_flush_resource;
	rctx->b.clear_buffer = r600_clear_buffer;
	rctx->b.blit_decompress_depth = r600_blit_decompress_depth;
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@d433 1
a433 2
		if (rtex->htile_buffer && !level &&
		    util_max_layer(&rtex->resource.b.b, level) == 0) {
d840 1
a840 1
					   0, util_max_layer(res, 0));
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a23 2
#include "compute_memory_pool.h"
#include "evergreen_compute.h"
d25 1
d45 2
a46 1
	R600_BLIT          = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES,
d50 1
a50 1
	R600_COLOR_RESOLVE = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER
d434 1
a434 2
                   fb->zsbuf->u.tex.first_layer == 0 &&
                   fb->zsbuf->u.tex.last_layer == util_max_layer(&rtex->resource.b.b, level)) {
d445 1
a445 2
	util_blitter_clear(rctx->blitter, fb->width, fb->height,
			   util_framebuffer_get_num_layers(fb),
d517 5
d528 2
a529 3
	struct r600_context *rctx = (struct r600_context*)ctx;
	struct compute_memory_pool *pool = rctx->screen->global_pool;
	struct pipe_box new_src_box = *src_box;
d531 6
a536 21
	if (src->bind & PIPE_BIND_GLOBAL) {
		struct r600_resource_global *rsrc =
			(struct r600_resource_global *)src;
		struct compute_memory_item *item = rsrc->chunk;

		if (is_item_in_pool(item)) {
			new_src_box.x += 4 * item->start_in_dw;
			src = (struct pipe_resource *)pool->bo;
		} else {
			if (item->real_buffer == NULL) {
				item->real_buffer = (struct r600_resource*)
					r600_compute_buffer_alloc_vram(pool->screen,
								       item->size_in_dw * 4);
			}
			src = (struct pipe_resource*)item->real_buffer;
		}
	}
	if (dst->bind & PIPE_BIND_GLOBAL) {
		struct r600_resource_global *rdst =
			(struct r600_resource_global *)dst;
		struct compute_memory_item *item = rdst->chunk;
d538 2
a539 14
		if (is_item_in_pool(item)) {
			dstx += 4 * item->start_in_dw;
			dst = (struct pipe_resource *)pool->bo;
		} else {
			if (item->real_buffer == NULL) {
				item->real_buffer = (struct r600_resource*)
					r600_compute_buffer_alloc_vram(pool->screen,
								       item->size_in_dw * 4);
			}
			dst = (struct pipe_resource*)item->real_buffer;
		}
	}

	r600_copy_buffer(ctx, dst, dstx, src, &new_src_box);
d568 17
a584 7
void r600_resource_copy_region(struct pipe_context *ctx,
			       struct pipe_resource *dst,
			       unsigned dst_level,
			       unsigned dstx, unsigned dsty, unsigned dstz,
			       struct pipe_resource *src,
			       unsigned src_level,
			       const struct pipe_box *src_box)
d652 1
a652 1
		if (util_format_is_subsampled_422(src->format)) {
d795 1
a795 2
		r600_blitter_begin(ctx, R600_COLOR_RESOLVE |
				   (info->render_condition_enable ? 0 : R600_DISABLE_RENDER_COND));
d827 1
a827 6
	if (rctx->screen->b.debug_flags & DBG_FORCE_DMA &&
	    util_try_blit_via_copy_region(ctx, info))
		return;

	r600_blitter_begin(ctx, R600_BLIT |
			   (info->render_condition_enable ? 0 : R600_DISABLE_RENDER_COND));
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d24 2
a26 1
#include "util/u_blitter.h"
d46 1
a46 2
	R600_BLIT          = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_SAVE_TEXTURES |
			     R600_DISABLE_RENDER_COND,
d50 1
a50 1
	R600_COLOR_RESOLVE = R600_SAVE_FRAGMENT_STATE | R600_SAVE_FRAMEBUFFER | R600_DISABLE_RENDER_COND
d434 2
a435 1
		    util_max_layer(&rtex->resource.b.b, level) == 0) {
d446 2
a447 1
	util_blitter_clear(rctx->blitter, fb->width, fb->height, 1,
a518 5
 *
 * XXX: It should be possible to implement this function using
 * r600_copy_buffer() by passing the memory_pool resource as both src
 * and dst and updating dstx and src_box to point to the correct offsets.
 * This would likely perform better than the current implementation.
d525 3
a527 2
	struct pipe_box dst_box; struct pipe_transfer *src_pxfer,
	*dst_pxfer;
d529 21
a549 6
	u_box_1d(dstx, src_box->width, &dst_box);
	void *src_ptr = ctx->transfer_map(ctx, src, 0, PIPE_TRANSFER_READ,
					  src_box, &src_pxfer);
	void *dst_ptr = ctx->transfer_map(ctx, dst, 0, PIPE_TRANSFER_WRITE,
					  &dst_box, &dst_pxfer);
	memcpy(dst_ptr, src_ptr, src_box->width);
d551 14
a564 2
	ctx->transfer_unmap(ctx, src_pxfer);
	ctx->transfer_unmap(ctx, dst_pxfer);
d593 7
a599 17
static bool util_format_is_subsampled_2x1_32bpp(enum pipe_format format)
{
	const struct util_format_description *desc = util_format_description(format);

	return desc->layout == UTIL_FORMAT_LAYOUT_SUBSAMPLED &&
	       desc->block.width == 2 &&
	       desc->block.height == 1 &&
	       desc->block.bits == 32;
}

static void r600_resource_copy_region(struct pipe_context *ctx,
				      struct pipe_resource *dst,
				      unsigned dst_level,
				      unsigned dstx, unsigned dsty, unsigned dstz,
				      struct pipe_resource *src,
				      unsigned src_level,
				      const struct pipe_box *src_box)
d667 1
a667 1
		if (util_format_is_subsampled_2x1_32bpp(src->format)) {
d810 2
a811 1
		r600_blitter_begin(ctx, R600_COLOR_RESOLVE);
d843 6
a848 1
	r600_blitter_begin(ctx, R600_BLIT);
@


