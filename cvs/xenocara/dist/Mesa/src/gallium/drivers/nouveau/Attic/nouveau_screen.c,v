head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.38;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.32;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.00;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.34;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.42;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@#include "pipe/p_defines.h"
#include "pipe/p_screen.h"
#include "pipe/p_state.h"

#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_format.h"
#include "util/u_format_s3tc.h"
#include "util/u_string.h"

#include "os/os_time.h"

#include <stdio.h>
#include <errno.h>
#include <stdlib.h>

#include <nouveau_drm.h>

#include "nouveau_winsys.h"
#include "nouveau_screen.h"
#include "nouveau_fence.h"
#include "nouveau_mm.h"
#include "nouveau_buffer.h"

/* XXX this should go away */
#include "state_tracker/drm_driver.h"

int nouveau_mesa_debug = 0;

static const char *
nouveau_screen_get_name(struct pipe_screen *pscreen)
{
	struct nouveau_device *dev = nouveau_screen(pscreen)->device;
	static char buffer[128];

	util_snprintf(buffer, sizeof(buffer), "NV%02X", dev->chipset);
	return buffer;
}

static const char *
nouveau_screen_get_vendor(struct pipe_screen *pscreen)
{
	return "nouveau";
}

static uint64_t
nouveau_screen_get_timestamp(struct pipe_screen *pscreen)
{
	int64_t cpu_time = os_time_get() * 1000;

        /* getparam of PTIMER_TIME takes about x10 as long (several usecs) */

	return cpu_time + nouveau_screen(pscreen)->cpu_gpu_time_delta;
}

static void
nouveau_screen_fence_ref(struct pipe_screen *pscreen,
			 struct pipe_fence_handle **ptr,
			 struct pipe_fence_handle *pfence)
{
	nouveau_fence_ref(nouveau_fence(pfence), (struct nouveau_fence **)ptr);
}

static boolean
nouveau_screen_fence_signalled(struct pipe_screen *screen,
                               struct pipe_fence_handle *pfence)
{
        return nouveau_fence_signalled(nouveau_fence(pfence));
}

static boolean
nouveau_screen_fence_finish(struct pipe_screen *screen,
			    struct pipe_fence_handle *pfence,
                            uint64_t timeout)
{
	return nouveau_fence_wait(nouveau_fence(pfence));
}


struct nouveau_bo *
nouveau_screen_bo_from_handle(struct pipe_screen *pscreen,
			      struct winsys_handle *whandle,
			      unsigned *out_stride)
{
	struct nouveau_device *dev = nouveau_screen(pscreen)->device;
	struct nouveau_bo *bo = 0;
	int ret;

	if (whandle->type != DRM_API_HANDLE_TYPE_SHARED &&
	    whandle->type != DRM_API_HANDLE_TYPE_FD) {
		debug_printf("%s: attempt to import unsupported handle type %d\n",
			     __FUNCTION__, whandle->type);
		return NULL;
	}

	if (whandle->type == DRM_API_HANDLE_TYPE_SHARED)
		ret = nouveau_bo_name_ref(dev, whandle->handle, &bo);
	else
		ret = nouveau_bo_prime_handle_ref(dev, whandle->handle, &bo);

	if (ret) {
		debug_printf("%s: ref name 0x%08x failed with %d\n",
			     __FUNCTION__, whandle->handle, ret);
		return NULL;
	}

	*out_stride = whandle->stride;
	return bo;
}


boolean
nouveau_screen_bo_get_handle(struct pipe_screen *pscreen,
			     struct nouveau_bo *bo,
			     unsigned stride,
			     struct winsys_handle *whandle)
{
	whandle->stride = stride;

	if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) {
		return nouveau_bo_name_get(bo, &whandle->handle) == 0;
	} else if (whandle->type == DRM_API_HANDLE_TYPE_KMS) {
		whandle->handle = bo->handle;
		return TRUE;
	} else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
		return nouveau_bo_set_prime(bo, (int *)&whandle->handle) == 0;
	} else {
		return FALSE;
	}
}

int
nouveau_screen_init(struct nouveau_screen *screen, struct nouveau_device *dev)
{
	struct pipe_screen *pscreen = &screen->base;
	struct nv04_fifo nv04_data = { .vram = 0xbeef0201, .gart = 0xbeef0202 };
	struct nvc0_fifo nvc0_data = { };
	uint64_t time;
	int size, ret;
	void *data;
	union nouveau_bo_config mm_config;

	char *nv_dbg = getenv("NOUVEAU_MESA_DEBUG");
	if (nv_dbg)
	   nouveau_mesa_debug = atoi(nv_dbg);

	/*
	 * this is initialized to 1 in nouveau_drm_screen_create after screen
	 * is fully constructed and added to the global screen list.
	 */
	screen->refcount = -1;

	if (dev->chipset < 0xc0) {
		data = &nv04_data;
		size = sizeof(nv04_data);
	} else {
		data = &nvc0_data;
		size = sizeof(nvc0_data);
	}

	ret = nouveau_object_new(&dev->object, 0, NOUVEAU_FIFO_CHANNEL_CLASS,
				 data, size, &screen->channel);
	if (ret)
		return ret;
	screen->device = dev;

	ret = nouveau_client_new(screen->device, &screen->client);
	if (ret)
		return ret;
	ret = nouveau_pushbuf_new(screen->client, screen->channel,
				  4, 512 * 1024, 1,
				  &screen->pushbuf);
	if (ret)
		return ret;

        /* getting CPU time first appears to be more accurate */
        screen->cpu_gpu_time_delta = os_time_get();

        ret = nouveau_getparam(dev, NOUVEAU_GETPARAM_PTIMER_TIME, &time);
        if (!ret)
           screen->cpu_gpu_time_delta = time - screen->cpu_gpu_time_delta * 1000;

	pscreen->get_name = nouveau_screen_get_name;
	pscreen->get_vendor = nouveau_screen_get_vendor;

	pscreen->get_timestamp = nouveau_screen_get_timestamp;

	pscreen->fence_reference = nouveau_screen_fence_ref;
	pscreen->fence_signalled = nouveau_screen_fence_signalled;
	pscreen->fence_finish = nouveau_screen_fence_finish;

	util_format_s3tc_init();

	screen->lowmem_bindings = PIPE_BIND_GLOBAL; /* gallium limit */
	screen->vidmem_bindings =
		PIPE_BIND_RENDER_TARGET | PIPE_BIND_DEPTH_STENCIL |
		PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT | PIPE_BIND_CURSOR |
		PIPE_BIND_SAMPLER_VIEW |
		PIPE_BIND_SHADER_RESOURCE | PIPE_BIND_COMPUTE_RESOURCE |
		PIPE_BIND_GLOBAL;
	screen->sysmem_bindings =
		PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_STREAM_OUTPUT;

	memset(&mm_config, 0, sizeof(mm_config));

	screen->mm_GART = nouveau_mm_create(dev,
					    NOUVEAU_BO_GART | NOUVEAU_BO_MAP,
					    &mm_config);
	screen->mm_VRAM = nouveau_mm_create(dev, NOUVEAU_BO_VRAM, &mm_config);
	return 0;
}

void
nouveau_screen_fini(struct nouveau_screen *screen)
{
	nouveau_mm_destroy(screen->mm_GART);
	nouveau_mm_destroy(screen->mm_VRAM);

	nouveau_pushbuf_del(&screen->pushbuf);

	nouveau_client_del(&screen->client);
	nouveau_object_del(&screen->channel);

	nouveau_device_del(&screen->device);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d197 1
a197 2
		PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT |
		PIPE_BIND_CURSOR |
d202 1
a202 2
		PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_STREAM_OUTPUT |
		PIPE_BIND_COMMAND_ARGS_BUFFER;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d197 2
a198 1
		PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT | PIPE_BIND_CURSOR |
d203 2
a204 1
		PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_STREAM_OUTPUT;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d17 1
a17 1
#include <libdrm/nouveau_drm.h>
d88 13
a100 2
 
	ret = nouveau_bo_name_ref(dev, whandle->handle, &bo);
d120 1
a120 1
	if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) { 
d125 2
d146 6
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d11 2
d15 3
a18 2
#include "nouveau/nouveau_bo.h"
#include "nouveau/nouveau_mm.h"
d22 2
d27 2
a28 1
#include "util/u_simple_screen.h"
d46 2
a47 48


struct nouveau_bo *
nouveau_screen_bo_new(struct pipe_screen *pscreen, unsigned alignment,
		      unsigned usage, unsigned bind, unsigned size)
{
	struct nouveau_device *dev = nouveau_screen(pscreen)->device;
	struct nouveau_bo *bo = NULL;
	uint32_t flags = NOUVEAU_BO_MAP, tile_mode = 0, tile_flags = 0;
	int ret;

	if (bind & PIPE_BIND_VERTEX_BUFFER)
		flags |= nouveau_screen(pscreen)->vertex_buffer_flags;
	else if (bind & PIPE_BIND_INDEX_BUFFER)
		flags |= nouveau_screen(pscreen)->index_buffer_flags;

	if (bind & (PIPE_BIND_RENDER_TARGET |
			PIPE_BIND_DEPTH_STENCIL |
			PIPE_BIND_SCANOUT |
			PIPE_BIND_DISPLAY_TARGET |
			PIPE_BIND_SAMPLER_VIEW))
	{
		/* TODO: this may be incorrect or suboptimal */
		if (!(bind & PIPE_BIND_SCANOUT))
			flags |= NOUVEAU_BO_GART;
		if (usage != PIPE_USAGE_DYNAMIC)
			flags |= NOUVEAU_BO_VRAM;

		if (dev->chipset == 0x50 || dev->chipset >= 0x80) {
			if (bind & PIPE_BIND_DEPTH_STENCIL)
				tile_flags = 0x2800;
			else
				tile_flags = 0x7000;
		}
	}

	ret = nouveau_bo_new_tile(dev, flags, alignment, size,
				  tile_mode, tile_flags, &bo);
	if (ret)
		return NULL;

	return bo;
}

void *
nouveau_screen_bo_map(struct pipe_screen *pscreen,
		      struct nouveau_bo *bo,
		      unsigned map_flags)
d49 1
a49 1
	int ret;
d51 1
a51 5
	ret = nouveau_bo_map(bo, map_flags);
	if (ret) {
		debug_printf("map failed: %d\n", ret);
		return NULL;
	}
d53 1
a53 37
	return bo->map;
}

void *
nouveau_screen_bo_map_range(struct pipe_screen *pscreen, struct nouveau_bo *bo,
			    unsigned offset, unsigned length, unsigned flags)
{
	int ret;

	ret = nouveau_bo_map_range(bo, offset, length, flags);
	if (ret) {
		nouveau_bo_unmap(bo);
		if (!(flags & NOUVEAU_BO_NOWAIT) || ret != -EBUSY)
			debug_printf("map_range failed: %d\n", ret);
		return NULL;
	}

	return (char *)bo->map - offset; /* why gallium? why? */
}

void
nouveau_screen_bo_map_flush_range(struct pipe_screen *pscreen, struct nouveau_bo *bo,
				  unsigned offset, unsigned length)
{
	nouveau_bo_map_flush(bo, offset, length);
}

void
nouveau_screen_bo_unmap(struct pipe_screen *pscreen, struct nouveau_bo *bo)
{
	nouveau_bo_unmap(bo);
}

void
nouveau_screen_bo_release(struct pipe_screen *pscreen, struct nouveau_bo *bo)
{
	nouveau_bo_ref(NULL, &bo);
d76 1
a76 1
        return nouveau_fence_wait(nouveau_fence(pfence));
d89 1
a89 1
	ret = nouveau_bo_handle_ref(dev, whandle->handle, &bo);
d110 1
a110 1
		return nouveau_bo_handle_get(bo, &whandle->handle) == 0;
d123 18
a140 1
	int ret;
d142 2
a143 2
	ret = nouveau_channel_alloc(dev, 0xbeef0201, 0xbeef0202,
				    512*1024, &screen->channel);
d148 16
d167 2
d175 12
d189 2
a190 2
					    0x000);
	screen->mm_VRAM = nouveau_mm_create(dev, NOUVEAU_BO_VRAM, 0x000);
a196 2
	struct pipe_winsys *ws = screen->base.winsys;

d200 4
a203 1
	nouveau_channel_free(&screen->channel);
d205 1
a205 2
	if (ws)
		ws->destroy(ws);
a206 1

@


1.2
log
@Merge Mesa 7.10.3
@
text
@d15 1
d18 1
a83 14
struct nouveau_bo *
nouveau_screen_bo_user(struct pipe_screen *pscreen, void *ptr, unsigned bytes)
{
	struct nouveau_device *dev = nouveau_screen(pscreen)->device;
	struct nouveau_bo *bo = NULL;
	int ret;

	ret = nouveau_bo_user(dev, ptr, bytes, &bo);
	if (ret)
		return NULL;

	return bo;
}

d141 1
a141 1
	*ptr = pfence;
d144 1
a144 1
static int
d146 1
a146 2
			       struct pipe_fence_handle *pfence,
			       unsigned flags)
d148 1
a148 1
	return 0;
d151 1
a151 1
static int
d154 1
a154 1
			    unsigned flags)
d156 1
a156 1
	return 0;
a198 20

unsigned int
nouveau_reference_flags(struct nouveau_bo *bo)
{
	uint32_t bo_flags;
	int flags = 0;

	bo_flags = nouveau_bo_pending(bo);
	if (bo_flags & NOUVEAU_BO_RD)
		flags |= PIPE_REFERENCED_FOR_READ;
	if (bo_flags & NOUVEAU_BO_WR)
		flags |= PIPE_REFERENCED_FOR_WRITE;

	return flags;
}





d220 4
d231 4
d236 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d7 3
d18 4
d28 1
a28 1
	snprintf(buffer, sizeof(buffer), "NV%02X", dev->chipset);
a37 11
static struct pipe_buffer *
nouveau_screen_bo_skel(struct pipe_screen *pscreen, struct nouveau_bo *bo,
		       unsigned alignment, unsigned usage, unsigned size)
{
	struct pipe_buffer *pb;

	pb = CALLOC(1, sizeof(struct pipe_buffer)+sizeof(struct nouveau_bo *));
	if (!pb) {
		nouveau_bo_ref(NULL, &bo);
		return NULL;
	}
a38 8
	pipe_reference_init(&pb->reference, 1);
	pb->screen = pscreen;
	pb->alignment = alignment;
	pb->usage = usage;
	pb->size = size;
	*(struct nouveau_bo **)(pb + 1) = bo;
	return pb;
}
d40 1
a40 1
static struct pipe_buffer *
d42 1
a42 1
		      unsigned usage, unsigned size)
d49 13
a61 14
	if (usage & NOUVEAU_BUFFER_USAGE_TRANSFER)
		flags |= NOUVEAU_BO_GART;
	else
	if (usage & PIPE_BUFFER_USAGE_VERTEX) {
		if (pscreen->get_param(pscreen, NOUVEAU_CAP_HW_VTXBUF))
			flags |= NOUVEAU_BO_GART;
	} else
	if (usage & PIPE_BUFFER_USAGE_INDEX) {
		if (pscreen->get_param(pscreen, NOUVEAU_CAP_HW_IDXBUF))
			flags |= NOUVEAU_BO_GART;
	}

	if (usage & PIPE_BUFFER_USAGE_PIXEL) {
		if (usage & NOUVEAU_BUFFER_USAGE_TEXTURE)
d63 1
a63 1
		if (!(usage & PIPE_BUFFER_USAGE_CPU_READ_WRITE))
d67 1
a67 1
			if (usage & NOUVEAU_BUFFER_USAGE_ZETA)
d79 1
a79 1
	return nouveau_screen_bo_skel(pscreen, bo, alignment, usage, size);
d82 1
a82 1
static struct pipe_buffer *
d93 1
a93 1
	return nouveau_screen_bo_skel(pscreen, bo, 0, 0, bytes);
d96 4
a99 2
static inline uint32_t
nouveau_screen_map_flags(unsigned pipe)
a100 23
	uint32_t flags = 0;

	if (pipe & PIPE_BUFFER_USAGE_CPU_READ)
		flags |= NOUVEAU_BO_RD;
	if (pipe & PIPE_BUFFER_USAGE_CPU_WRITE)
		flags |= NOUVEAU_BO_WR;
	if (pipe & PIPE_BUFFER_USAGE_DISCARD)
		flags |= NOUVEAU_BO_INVAL;
	if (pipe & PIPE_BUFFER_USAGE_DONTBLOCK)
		flags |= NOUVEAU_BO_NOWAIT;
	else
	if (pipe & 0 /*PIPE_BUFFER_USAGE_UNSYNCHRONIZED*/)
		flags |= NOUVEAU_BO_NOSYNC;

	return flags;
}

static void *
nouveau_screen_bo_map(struct pipe_screen *pscreen, struct pipe_buffer *pb,
		      unsigned usage)
{
	struct nouveau_bo *bo = nouveau_bo(pb);
	struct nouveau_screen *nscreen = nouveau_screen(pscreen);
d103 1
a103 10
	if (nscreen->pre_pipebuffer_map_callback) {
		ret = nscreen->pre_pipebuffer_map_callback(pscreen, pb, usage);
		if (ret) {
			debug_printf("pre_pipebuffer_map_callback failed %d\n",
				ret);
			return NULL;
		}
	}

	ret = nouveau_bo_map(bo, nouveau_screen_map_flags(usage));
d112 4
a115 7
static void *
nouveau_screen_bo_map_range(struct pipe_screen *pscreen, struct pipe_buffer *pb,
			    unsigned offset, unsigned length, unsigned usage)
{
	struct nouveau_bo *bo = nouveau_bo(pb);
	struct nouveau_screen *nscreen = nouveau_screen(pscreen);
	uint32_t flags = nouveau_screen_map_flags(usage);
a117 9
	if (nscreen->pre_pipebuffer_map_callback) {
		ret = nscreen->pre_pipebuffer_map_callback(pscreen, pb, usage);
		if (ret) {
			debug_printf("pre_pipebuffer_map_callback failed %d\n",
				ret);
			return NULL;
		}
	}

d129 3
a131 3
static void
nouveau_screen_bo_map_flush(struct pipe_screen *pscreen, struct pipe_buffer *pb,
			    unsigned offset, unsigned length)
a132 2
	struct nouveau_bo *bo = nouveau_bo(pb);

d136 2
a137 2
static void
nouveau_screen_bo_unmap(struct pipe_screen *pscreen, struct pipe_buffer *pb)
a138 2
	struct nouveau_bo *bo = nouveau_bo(pb);

d142 2
a143 2
static void
nouveau_screen_bo_del(struct pipe_buffer *pb)
a144 2
	struct nouveau_bo *bo = nouveau_bo(pb);

a145 1
	FREE(pb);
d172 60
d239 1
a239 1
				    &screen->channel);
a246 8
	pscreen->buffer_create = nouveau_screen_bo_new;
	pscreen->user_buffer_create = nouveau_screen_bo_user;
	pscreen->buffer_map = nouveau_screen_bo_map;
	pscreen->buffer_map_range = nouveau_screen_bo_map_range;
	pscreen->buffer_flush_mapped_range = nouveau_screen_bo_map_flush;
	pscreen->buffer_unmap = nouveau_screen_bo_unmap;
	pscreen->buffer_destroy = nouveau_screen_bo_del;

d251 2
d261 2
a262 1
	ws->destroy(ws);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a6 3
#include "util/u_format.h"
#include "util/u_format_s3tc.h"
#include "util/u_string.h"
a14 4
/* XXX this should go away */
#include "state_tracker/drm_driver.h"
#include "util/u_simple_screen.h"

d21 1
a21 1
	util_snprintf(buffer, sizeof(buffer), "NV%02X", dev->chipset);
d31 11
d43 8
d52 1
a52 1
struct nouveau_bo *
d54 1
a54 1
		      unsigned usage, unsigned bind, unsigned size)
d61 14
a74 13
	if (bind & PIPE_BIND_VERTEX_BUFFER)
		flags |= nouveau_screen(pscreen)->vertex_buffer_flags;
	else if (bind & PIPE_BIND_INDEX_BUFFER)
		flags |= nouveau_screen(pscreen)->index_buffer_flags;

	if (bind & (PIPE_BIND_RENDER_TARGET |
			PIPE_BIND_DEPTH_STENCIL |
			PIPE_BIND_SCANOUT |
			PIPE_BIND_DISPLAY_TARGET |
			PIPE_BIND_SAMPLER_VIEW))
	{
		/* TODO: this may be incorrect or suboptimal */
		if (!(bind & PIPE_BIND_SCANOUT))
d76 1
a76 1
		if (usage != PIPE_USAGE_DYNAMIC)
d80 1
a80 1
			if (bind & PIPE_BIND_DEPTH_STENCIL)
d92 1
a92 1
	return bo;
d95 1
a95 1
struct nouveau_bo *
d106 1
a106 1
	return bo;
d109 2
a110 4
void *
nouveau_screen_bo_map(struct pipe_screen *pscreen,
		      struct nouveau_bo *bo,
		      unsigned map_flags)
d112 23
d137 10
a146 1
	ret = nouveau_bo_map(bo, map_flags);
d155 7
a161 4
void *
nouveau_screen_bo_map_range(struct pipe_screen *pscreen, struct nouveau_bo *bo,
			    unsigned offset, unsigned length, unsigned flags)
{
d164 9
d184 3
a186 3
void
nouveau_screen_bo_map_flush_range(struct pipe_screen *pscreen, struct nouveau_bo *bo,
				  unsigned offset, unsigned length)
d188 2
d193 2
a194 2
void
nouveau_screen_bo_unmap(struct pipe_screen *pscreen, struct nouveau_bo *bo)
d196 2
d201 2
a202 2
void
nouveau_screen_bo_release(struct pipe_screen *pscreen, struct nouveau_bo *bo)
d204 2
d207 1
a233 60

struct nouveau_bo *
nouveau_screen_bo_from_handle(struct pipe_screen *pscreen,
			      struct winsys_handle *whandle,
			      unsigned *out_stride)
{
	struct nouveau_device *dev = nouveau_screen(pscreen)->device;
	struct nouveau_bo *bo = 0;
	int ret;
 
	ret = nouveau_bo_handle_ref(dev, whandle->handle, &bo);
	if (ret) {
		debug_printf("%s: ref name 0x%08x failed with %d\n",
			     __FUNCTION__, whandle->handle, ret);
		return NULL;
	}

	*out_stride = whandle->stride;
	return bo;
}


boolean
nouveau_screen_bo_get_handle(struct pipe_screen *pscreen,
			     struct nouveau_bo *bo,
			     unsigned stride,
			     struct winsys_handle *whandle)
{
	whandle->stride = stride;

	if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) { 
		return nouveau_bo_handle_get(bo, &whandle->handle) == 0;
	} else if (whandle->type == DRM_API_HANDLE_TYPE_KMS) {
		whandle->handle = bo->handle;
		return TRUE;
	} else {
		return FALSE;
	}
}


unsigned int
nouveau_reference_flags(struct nouveau_bo *bo)
{
	uint32_t bo_flags;
	int flags = 0;

	bo_flags = nouveau_bo_pending(bo);
	if (bo_flags & NOUVEAU_BO_RD)
		flags |= PIPE_REFERENCED_FOR_READ;
	if (bo_flags & NOUVEAU_BO_WR)
		flags |= PIPE_REFERENCED_FOR_WRITE;

	return flags;
}





d241 1
a241 1
				    512*1024, &screen->channel);
d249 8
a260 2
	util_format_s3tc_init();

d269 1
a269 2
	if (ws)
		ws->destroy(ws);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a10 2
#include "os/os_time.h"

a12 3
#include <stdlib.h>

#include <libdrm/nouveau_drm.h>
d14 1
a16 3
#include "nouveau_fence.h"
#include "nouveau_mm.h"
#include "nouveau_buffer.h"
d20 1
a20 2

int nouveau_mesa_debug = 0;
d38 5
a42 2
static uint64_t
nouveau_screen_get_timestamp(struct pipe_screen *pscreen)
d44 4
a47 1
	int64_t cpu_time = os_time_get() * 1000;
d49 24
a72 1
        /* getparam of PTIMER_TIME takes about x10 as long (several usecs) */
d74 72
a145 1
	return cpu_time + nouveau_screen(pscreen)->cpu_gpu_time_delta;
d153 1
a153 1
	nouveau_fence_ref(nouveau_fence(pfence), (struct nouveau_fence **)ptr);
d156 1
a156 1
static boolean
d158 2
a159 1
                               struct pipe_fence_handle *pfence)
d161 1
a161 1
        return nouveau_fence_signalled(nouveau_fence(pfence));
d164 1
a164 1
static boolean
d167 1
a167 1
                            uint64_t timeout)
d169 1
a169 1
	return nouveau_fence_wait(nouveau_fence(pfence));
d182 1
a182 1
	ret = nouveau_bo_name_ref(dev, whandle->handle, &bo);
d203 1
a203 1
		return nouveau_bo_name_get(bo, &whandle->handle) == 0;
d212 20
d236 1
a236 18
	struct nv04_fifo nv04_data = { .vram = 0xbeef0201, .gart = 0xbeef0202 };
	struct nvc0_fifo nvc0_data = { };
	uint64_t time;
	int size, ret;
	void *data;
	union nouveau_bo_config mm_config;

	char *nv_dbg = getenv("NOUVEAU_MESA_DEBUG");
	if (nv_dbg)
	   nouveau_mesa_debug = atoi(nv_dbg);

	if (dev->chipset < 0xc0) {
		data = &nv04_data;
		size = sizeof(nv04_data);
	} else {
		data = &nvc0_data;
		size = sizeof(nvc0_data);
	}
d238 2
a239 2
	ret = nouveau_object_new(&dev->object, 0, NOUVEAU_FIFO_CHANNEL_CLASS,
				 data, size, &screen->channel);
a243 16
	ret = nouveau_client_new(screen->device, &screen->client);
	if (ret)
		return ret;
	ret = nouveau_pushbuf_new(screen->client, screen->channel,
				  4, 512 * 1024, 1,
				  &screen->pushbuf);
	if (ret)
		return ret;

        /* getting CPU time first appears to be more accurate */
        screen->cpu_gpu_time_delta = os_time_get();

        ret = nouveau_getparam(dev, NOUVEAU_GETPARAM_PTIMER_TIME, &time);
        if (!ret)
           screen->cpu_gpu_time_delta = time - screen->cpu_gpu_time_delta * 1000;

a246 2
	pscreen->get_timestamp = nouveau_screen_get_timestamp;

a252 16
	screen->lowmem_bindings = PIPE_BIND_GLOBAL; /* gallium limit */
	screen->vidmem_bindings =
		PIPE_BIND_RENDER_TARGET | PIPE_BIND_DEPTH_STENCIL |
		PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT | PIPE_BIND_CURSOR |
		PIPE_BIND_SAMPLER_VIEW |
		PIPE_BIND_SHADER_RESOURCE | PIPE_BIND_COMPUTE_RESOURCE |
		PIPE_BIND_GLOBAL;
	screen->sysmem_bindings =
		PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_STREAM_OUTPUT;

	memset(&mm_config, 0, sizeof(mm_config));

	screen->mm_GART = nouveau_mm_create(dev,
					    NOUVEAU_BO_GART | NOUVEAU_BO_MAP,
					    &mm_config);
	screen->mm_VRAM = nouveau_mm_create(dev, NOUVEAU_BO_VRAM, &mm_config);
d259 5
a263 4
	nouveau_mm_destroy(screen->mm_GART);
	nouveau_mm_destroy(screen->mm_VRAM);

	nouveau_pushbuf_del(&screen->pushbuf);
a264 5
	nouveau_client_del(&screen->client);
	nouveau_object_del(&screen->channel);

	nouveau_device_del(&screen->device);
}
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d17 1
a17 1
#include <nouveau_drm.h>
d88 2
a89 13

	if (whandle->type != DRM_API_HANDLE_TYPE_SHARED &&
	    whandle->type != DRM_API_HANDLE_TYPE_FD) {
		debug_printf("%s: attempt to import unsupported handle type %d\n",
			     __FUNCTION__, whandle->type);
		return NULL;
	}

	if (whandle->type == DRM_API_HANDLE_TYPE_SHARED)
		ret = nouveau_bo_name_ref(dev, whandle->handle, &bo);
	else
		ret = nouveau_bo_prime_handle_ref(dev, whandle->handle, &bo);

d109 1
a109 1
	if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) {
a113 2
	} else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
		return nouveau_bo_set_prime(bo, (int *)&whandle->handle) == 0;
a132 6

	/*
	 * this is initialized to 1 in nouveau_drm_screen_create after screen
	 * is fully constructed and added to the global screen list.
	 */
	screen->refcount = -1;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d197 1
a197 2
		PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT |
		PIPE_BIND_CURSOR |
d202 1
a202 2
		PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_STREAM_OUTPUT |
		PIPE_BIND_COMMAND_ARGS_BUFFER;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d197 2
a198 1
		PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT | PIPE_BIND_CURSOR |
d203 2
a204 1
		PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_STREAM_OUTPUT;
@


