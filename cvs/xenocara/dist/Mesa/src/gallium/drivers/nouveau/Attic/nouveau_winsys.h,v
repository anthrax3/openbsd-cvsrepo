head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.39;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.33;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.00;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@#ifndef NOUVEAU_WINSYS_H
#define NOUVEAU_WINSYS_H

#include <stdint.h>
#include <inttypes.h>

#include "pipe/p_defines.h"

#include <nouveau.h>

#ifndef NV04_PFIFO_MAX_PACKET_LEN
#define NV04_PFIFO_MAX_PACKET_LEN 2047
#endif

#define NOUVEAU_MIN_BUFFER_MAP_ALIGN      64
#define NOUVEAU_MIN_BUFFER_MAP_ALIGN_MASK (NOUVEAU_MIN_BUFFER_MAP_ALIGN - 1)

static INLINE uint32_t
PUSH_AVAIL(struct nouveau_pushbuf *push)
{
   return push->end - push->cur;
}

static INLINE boolean
PUSH_SPACE(struct nouveau_pushbuf *push, uint32_t size)
{
   if (PUSH_AVAIL(push) < size)
      return nouveau_pushbuf_space(push, size, 0, 0) == 0;
   return TRUE;
}

static INLINE void
PUSH_DATA(struct nouveau_pushbuf *push, uint32_t data)
{
   *push->cur++ = data;
}

static INLINE void
PUSH_DATAp(struct nouveau_pushbuf *push, const void *data, uint32_t size)
{
   memcpy(push->cur, data, size * 4);
   push->cur += size;
}

static INLINE void
PUSH_DATAf(struct nouveau_pushbuf *push, float f)
{
   union { float f; uint32_t i; } u;
   u.f = f;
   PUSH_DATA(push, u.i);
}

static INLINE void
PUSH_KICK(struct nouveau_pushbuf *push)
{
   nouveau_pushbuf_kick(push, push->channel);
}


#define NOUVEAU_RESOURCE_FLAG_LINEAR   (PIPE_RESOURCE_FLAG_DRV_PRIV << 0)
#define NOUVEAU_RESOURCE_FLAG_DRV_PRIV (PIPE_RESOURCE_FLAG_DRV_PRIV << 1)

static INLINE uint32_t
nouveau_screen_transfer_flags(unsigned pipe)
{
	uint32_t flags = 0;

	if (!(pipe & PIPE_TRANSFER_UNSYNCHRONIZED)) {
		if (pipe & PIPE_TRANSFER_READ)
			flags |= NOUVEAU_BO_RD;
		if (pipe & PIPE_TRANSFER_WRITE)
			flags |= NOUVEAU_BO_WR;
		if (pipe & PIPE_TRANSFER_DONTBLOCK)
			flags |= NOUVEAU_BO_NOBLOCK;
	}

	return flags;
}

extern struct pipe_screen *
nv30_screen_create(struct nouveau_device *);

extern struct pipe_screen *
nv50_screen_create(struct nouveau_device *);

extern struct pipe_screen *
nvc0_screen_create(struct nouveau_device *);

#endif
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d9 1
a9 1
#include <libdrm/nouveau.h>
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d5 2
d9 1
a9 8
#include "nouveau/nouveau_bo.h"
#include "nouveau/nouveau_channel.h"
#include "nouveau/nouveau_device.h"
#include "nouveau/nouveau_grobj.h"
#include "nouveau/nouveau_notifier.h"
#ifndef NOUVEAU_NVC0
#include "nouveau/nv04_pushbuf.h"
#endif
d15 48
d68 8
a75 10
	if (pipe & PIPE_TRANSFER_READ)
		flags |= NOUVEAU_BO_RD;
	if (pipe & PIPE_TRANSFER_WRITE)
		flags |= NOUVEAU_BO_WR;
	if (pipe & PIPE_TRANSFER_DISCARD)
		flags |= NOUVEAU_BO_INVAL;
	if (pipe & PIPE_TRANSFER_UNSYNCHRONIZED)
		flags |= NOUVEAU_BO_NOSYNC;
	else if (pipe & PIPE_TRANSFER_DONTBLOCK)
		flags |= NOUVEAU_BO_NOWAIT;
d81 1
a81 1
nvfx_screen_create(struct pipe_winsys *ws, struct nouveau_device *);
d84 1
a84 1
nv50_screen_create(struct pipe_winsys *ws, struct nouveau_device *);
d87 1
a87 1
nvc0_screen_create(struct pipe_winsys *ws, struct nouveau_device *);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d12 1
a12 1
#include "nouveau/nouveau_resource.h"
d14 1
d44 3
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a4 1
#include "util/u_simple_screen.h"
a8 1
#include "nouveau/nouveau_class.h"
d13 1
a13 1
#include "nouveau/nouveau_pushbuf.h"
d15 19
a33 2
#define NOUVEAU_CAP_HW_VTXBUF (0xbeef0000)
#define NOUVEAU_CAP_HW_IDXBUF (0xbeef0001)
d35 2
a36 11
#define NOUVEAU_TEXTURE_USAGE_LINEAR (1 << 16)

#define NOUVEAU_BUFFER_USAGE_TEXTURE  (1 << 16)
#define NOUVEAU_BUFFER_USAGE_ZETA     (1 << 17)
#define NOUVEAU_BUFFER_USAGE_TRANSFER (1 << 18)

/* use along with GPU_WRITE for 2D-only writes */
#define NOUVEAU_BUFFER_USAGE_NO_RENDER (1 << 19)

extern struct pipe_screen *
nv30_screen_create(struct pipe_winsys *ws, struct nouveau_device *);
d39 1
a39 1
nv40_screen_create(struct pipe_winsys *ws, struct nouveau_device *);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d5 1
d10 1
d15 1
a15 1
#include "nouveau/nv04_pushbuf.h"
d17 2
a18 19
#ifndef NV04_PFIFO_MAX_PACKET_LEN
#define NV04_PFIFO_MAX_PACKET_LEN 2047
#endif

static INLINE uint32_t
nouveau_screen_transfer_flags(unsigned pipe)
{
	uint32_t flags = 0;

	if (pipe & PIPE_TRANSFER_READ)
		flags |= NOUVEAU_BO_RD;
	if (pipe & PIPE_TRANSFER_WRITE)
		flags |= NOUVEAU_BO_WR;
	if (pipe & PIPE_TRANSFER_DISCARD)
		flags |= NOUVEAU_BO_INVAL;
	if (pipe & PIPE_TRANSFER_UNSYNCHRONIZED)
		flags |= NOUVEAU_BO_NOSYNC;
	else if (pipe & PIPE_TRANSFER_DONTBLOCK)
		flags |= NOUVEAU_BO_NOWAIT;
d20 11
a30 2
	return flags;
}
d33 1
a33 1
nvfx_screen_create(struct pipe_winsys *ws, struct nouveau_device *);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a4 2
#include <inttypes.h>

d7 7
a13 1
#include <libdrm/nouveau.h>
a18 48
#define NOUVEAU_MIN_BUFFER_MAP_ALIGN      64
#define NOUVEAU_MIN_BUFFER_MAP_ALIGN_MASK (NOUVEAU_MIN_BUFFER_MAP_ALIGN - 1)

static INLINE uint32_t
PUSH_AVAIL(struct nouveau_pushbuf *push)
{
   return push->end - push->cur;
}

static INLINE boolean
PUSH_SPACE(struct nouveau_pushbuf *push, uint32_t size)
{
   if (PUSH_AVAIL(push) < size)
      return nouveau_pushbuf_space(push, size, 0, 0) == 0;
   return TRUE;
}

static INLINE void
PUSH_DATA(struct nouveau_pushbuf *push, uint32_t data)
{
   *push->cur++ = data;
}

static INLINE void
PUSH_DATAp(struct nouveau_pushbuf *push, const void *data, uint32_t size)
{
   memcpy(push->cur, data, size * 4);
   push->cur += size;
}

static INLINE void
PUSH_DATAf(struct nouveau_pushbuf *push, float f)
{
   union { float f; uint32_t i; } u;
   u.f = f;
   PUSH_DATA(push, u.i);
}

static INLINE void
PUSH_KICK(struct nouveau_pushbuf *push)
{
   nouveau_pushbuf_kick(push, push->channel);
}


#define NOUVEAU_RESOURCE_FLAG_LINEAR   (PIPE_RESOURCE_FLAG_DRV_PRIV << 0)
#define NOUVEAU_RESOURCE_FLAG_DRV_PRIV (PIPE_RESOURCE_FLAG_DRV_PRIV << 1)

d24 10
a33 8
	if (!(pipe & PIPE_TRANSFER_UNSYNCHRONIZED)) {
		if (pipe & PIPE_TRANSFER_READ)
			flags |= NOUVEAU_BO_RD;
		if (pipe & PIPE_TRANSFER_WRITE)
			flags |= NOUVEAU_BO_WR;
		if (pipe & PIPE_TRANSFER_DONTBLOCK)
			flags |= NOUVEAU_BO_NOBLOCK;
	}
d39 1
a39 4
nv30_screen_create(struct nouveau_device *);

extern struct pipe_screen *
nv50_screen_create(struct nouveau_device *);
d42 1
a42 1
nvc0_screen_create(struct nouveau_device *);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d9 1
a9 1
#include <nouveau.h>
@


