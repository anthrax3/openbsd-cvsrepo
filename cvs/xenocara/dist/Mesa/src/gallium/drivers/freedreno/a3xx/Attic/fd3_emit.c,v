head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.2
	OPENBSD_5_6_BASE:1.1.1.3
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.1.1.2.0.2
	OPENBSD_5_5_BASE:1.1.1.2
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.29;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.11.05;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.05;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.01.19.03.03.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.51;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.59;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.08;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/* -*- mode: C; c-file-style: "k&r"; tab-width 4; indent-tabs-mode: t; -*- */

/*
 * Copyright (C) 2013 Rob Clark <robclark@@freedesktop.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Rob Clark <robclark@@freedesktop.org>
 */

#include "pipe/p_state.h"
#include "util/u_string.h"
#include "util/u_memory.h"
#include "util/u_helpers.h"
#include "util/u_format.h"

#include "freedreno_resource.h"

#include "fd3_emit.h"
#include "fd3_blend.h"
#include "fd3_context.h"
#include "fd3_program.h"
#include "fd3_rasterizer.h"
#include "fd3_texture.h"
#include "fd3_util.h"
#include "fd3_zsa.h"

/* regid:          base const register
 * prsc or dwords: buffer containing constant values
 * sizedwords:     size of const value buffer
 */
void
fd3_emit_constant(struct fd_ringbuffer *ring,
		enum adreno_state_block sb,
		uint32_t regid, uint32_t offset, uint32_t sizedwords,
		const uint32_t *dwords, struct pipe_resource *prsc)
{
	uint32_t i, sz;
	enum adreno_state_src src;

	if (prsc) {
		sz = 0;
		src = SS_INDIRECT;
	} else {
		sz = sizedwords;
		src = SS_DIRECT;
	}

	/* we have this sometimes, not others.. perhaps we could be clever
	 * and figure out actually when we need to invalidate cache:
	 */
	OUT_PKT0(ring, REG_A3XX_UCHE_CACHE_INVALIDATE0_REG, 2);
	OUT_RING(ring, A3XX_UCHE_CACHE_INVALIDATE0_REG_ADDR(0));
	OUT_RING(ring, A3XX_UCHE_CACHE_INVALIDATE1_REG_ADDR(0) |
			A3XX_UCHE_CACHE_INVALIDATE1_REG_OPCODE(INVALIDATE) |
			A3XX_UCHE_CACHE_INVALIDATE1_REG_ENTIRE_CACHE);

	OUT_PKT3(ring, CP_LOAD_STATE, 2 + sz);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(regid/2) |
			CP_LOAD_STATE_0_STATE_SRC(src) |
			CP_LOAD_STATE_0_STATE_BLOCK(sb) |
			CP_LOAD_STATE_0_NUM_UNIT(sizedwords/2));
	if (prsc) {
		struct fd_bo *bo = fd_resource(prsc)->bo;
		OUT_RELOC(ring, bo, offset,
				CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS));
	} else {
		OUT_RING(ring, CP_LOAD_STATE_1_EXT_SRC_ADDR(0) |
				CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS));
		dwords = (uint32_t *)&((uint8_t *)dwords)[offset];
	}
	for (i = 0; i < sz; i++) {
		OUT_RING(ring, dwords[i]);
	}
}

static void
emit_constants(struct fd_ringbuffer *ring,
		enum adreno_state_block sb,
		struct fd_constbuf_stateobj *constbuf,
		struct fd3_shader_stateobj *shader)
{
	uint32_t enabled_mask = constbuf->enabled_mask;
	uint32_t base = 0;
	unsigned i;

	// XXX TODO only emit dirty consts.. but we need to keep track if
	// they are clobbered by a clear, gmem2mem, or mem2gmem..
	constbuf->dirty_mask = enabled_mask;

	/* emit user constants: */
	while (enabled_mask) {
		unsigned index = ffs(enabled_mask) - 1;
		struct pipe_constant_buffer *cb = &constbuf->cb[index];
		unsigned size = align(cb->buffer_size, 4) / 4; /* size in dwords */

		// I expect that size should be a multiple of vec4's:
		assert(size == align(size, 4));

		/* gallium could have const-buffer still bound, even though the
		 * shader is not using it.  Writing consts above constlen (or
		 * rather, HLSQ_{VS,FS}_CONTROL_REG.CONSTLENGTH) will cause a
		 * hang.
		 */
		if ((base / 4) >= shader->constlen)
			break;

		if (constbuf->dirty_mask & (1 << index)) {
			fd3_emit_constant(ring, sb, base,
					cb->buffer_offset, size,
					cb->user_buffer, cb->buffer);
			constbuf->dirty_mask &= ~(1 << index);
		}

		base += size;
		enabled_mask &= ~(1 << index);
	}

	/* emit shader immediates: */
	if (shader) {
		for (i = 0; i < shader->immediates_count; i++) {
			fd3_emit_constant(ring, sb,
					4 * (shader->first_immediate + i),
					0, 4, shader->immediates[i].val, NULL);
		}
	}
}

#define VERT_TEX_OFF    0
#define FRAG_TEX_OFF    16
#define BASETABLE_SZ    14

static void
emit_textures(struct fd_ringbuffer *ring,
		enum adreno_state_block sb,
		struct fd_texture_stateobj *tex)
{
	static const unsigned tex_off[] = {
			[SB_VERT_TEX] = VERT_TEX_OFF,
			[SB_FRAG_TEX] = FRAG_TEX_OFF,
	};
	static const enum adreno_state_block mipaddr[] = {
			[SB_VERT_TEX] = SB_VERT_MIPADDR,
			[SB_FRAG_TEX] = SB_FRAG_MIPADDR,
	};
	unsigned i, j;

	assert(tex->num_samplers == tex->num_textures);  // TODO check..

	if (!tex->num_samplers)
		return;

	/* output sampler state: */
	OUT_PKT3(ring, CP_LOAD_STATE, 2 + (2 * tex->num_samplers));
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(tex_off[sb]) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(sb) |
			CP_LOAD_STATE_0_NUM_UNIT(tex->num_samplers));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_SHADER) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	for (i = 0; i < tex->num_samplers; i++) {
		struct fd3_sampler_stateobj *sampler =
				fd3_sampler_stateobj(tex->samplers[i]);
		OUT_RING(ring, sampler->texsamp0);
		OUT_RING(ring, sampler->texsamp1);
	}

	/* emit texture state: */
	OUT_PKT3(ring, CP_LOAD_STATE, 2 + (4 * tex->num_textures));
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(tex_off[sb]) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(sb) |
			CP_LOAD_STATE_0_NUM_UNIT(tex->num_textures));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	for (i = 0; i < tex->num_textures; i++) {
		struct fd3_pipe_sampler_view *view =
				fd3_pipe_sampler_view(tex->textures[i]);
		OUT_RING(ring, view->texconst0);
		OUT_RING(ring, view->texconst1);
		OUT_RING(ring, view->texconst2 |
				A3XX_TEX_CONST_2_INDX(BASETABLE_SZ * i));
		OUT_RING(ring, view->texconst3);
	}

	/* emit mipaddrs: */
	OUT_PKT3(ring, CP_LOAD_STATE, 2 + (BASETABLE_SZ * tex->num_textures));
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(BASETABLE_SZ * tex_off[sb]) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(mipaddr[sb]) |
			CP_LOAD_STATE_0_NUM_UNIT(BASETABLE_SZ * tex->num_textures));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	for (i = 0; i < tex->num_textures; i++) {
		struct fd3_pipe_sampler_view *view =
				fd3_pipe_sampler_view(tex->textures[i]);
		OUT_RELOC(ring, view->tex_resource->bo, 0, 0);
		/* I think each entry is a ptr to mipmap level.. for now, just
		 * pad w/ null's until I get around to actually implementing
		 * mipmap support..
		 */
		for (j = 1; j < BASETABLE_SZ; j++) {
			OUT_RING(ring, 0x00000000);
		}
	}
}

static void
emit_cache_flush(struct fd_ringbuffer *ring)
{
	OUT_PKT3(ring, CP_EVENT_WRITE, 1);
	OUT_RING(ring, CACHE_FLUSH);

	OUT_PKT3(ring, CP_DRAW_INDX, 3);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, DRAW(DI_PT_POINTLIST, DI_SRC_SEL_AUTO_INDEX,
			INDEX_SIZE_IGN, IGNORE_VISIBILITY));
	OUT_RING(ring, 0);					/* NumIndices */

	OUT_PKT3(ring, CP_NOP, 4);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);

	OUT_PKT3(ring, CP_WAIT_FOR_IDLE, 1);
	OUT_RING(ring, 0x00000000);
}

/* emit texture state for mem->gmem restore operation.. eventually it would
 * be good to get rid of this and use normal CSO/etc state for more of these
 * special cases, but for now the compiler is not sufficient..
 */
void
fd3_emit_gmem_restore_tex(struct fd_ringbuffer *ring, struct pipe_surface *psurf)
{
	struct fd_resource *rsc = fd_resource(psurf->texture);

	/* output sampler state: */
	OUT_PKT3(ring, CP_LOAD_STATE, 4);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(FRAG_TEX_OFF) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(SB_FRAG_TEX) |
			CP_LOAD_STATE_0_NUM_UNIT(1));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_SHADER) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	OUT_RING(ring, A3XX_TEX_SAMP_0_XY_MAG(A3XX_TEX_NEAREST) |
			A3XX_TEX_SAMP_0_XY_MIN(A3XX_TEX_NEAREST) |
			A3XX_TEX_SAMP_0_WRAP_S(A3XX_TEX_CLAMP_TO_EDGE) |
			A3XX_TEX_SAMP_0_WRAP_T(A3XX_TEX_CLAMP_TO_EDGE) |
			A3XX_TEX_SAMP_0_WRAP_R(A3XX_TEX_REPEAT));
	OUT_RING(ring, 0x00000000);

	/* emit texture state: */
	OUT_PKT3(ring, CP_LOAD_STATE, 6);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(FRAG_TEX_OFF) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(SB_FRAG_TEX) |
			CP_LOAD_STATE_0_NUM_UNIT(1));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	OUT_RING(ring, A3XX_TEX_CONST_0_FMT(fd3_pipe2tex(psurf->format)) |
			0x40000000 | // XXX
			fd3_tex_swiz(psurf->format,  PIPE_SWIZZLE_BLUE, PIPE_SWIZZLE_GREEN,
					PIPE_SWIZZLE_RED, PIPE_SWIZZLE_ALPHA));
	OUT_RING(ring, A3XX_TEX_CONST_1_FETCHSIZE(fd3_pipe2fetchsize(psurf->format)) |
			A3XX_TEX_CONST_1_WIDTH(psurf->width) |
			A3XX_TEX_CONST_1_HEIGHT(psurf->height));
	OUT_RING(ring, A3XX_TEX_CONST_2_PITCH(rsc->pitch * rsc->cpp) |
			A3XX_TEX_CONST_2_INDX(0));
	OUT_RING(ring, 0x00000000);

	/* emit mipaddrs: */
	OUT_PKT3(ring, CP_LOAD_STATE, 3);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(BASETABLE_SZ * FRAG_TEX_OFF) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(SB_FRAG_MIPADDR) |
			CP_LOAD_STATE_0_NUM_UNIT(1));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	OUT_RELOC(ring, rsc->bo, 0, 0);
}

void
fd3_emit_vertex_bufs(struct fd_ringbuffer *ring,
		struct fd_program_stateobj *prog,
		struct fd3_vertex_buf *vbufs, uint32_t n)
{
	struct fd3_shader_stateobj *vp = prog->vp;
	uint32_t i;

	n = MIN2(n, vp->inputs_count);

	for (i = 0; i < n; i++) {
		struct pipe_resource *prsc = vbufs[i].prsc;
		struct fd_resource *rsc = fd_resource(prsc);
		enum a3xx_vtx_fmt fmt = fd3_pipe2vtx(vbufs[i].format);
		bool switchnext = (i != (n - 1));
		uint32_t fs = util_format_get_blocksize(vbufs[i].format);

		OUT_PKT0(ring, REG_A3XX_VFD_FETCH(i), 2);
		OUT_RING(ring, A3XX_VFD_FETCH_INSTR_0_FETCHSIZE(fs - 1) |
				A3XX_VFD_FETCH_INSTR_0_BUFSTRIDE(vbufs[i].stride) |
				COND(switchnext, A3XX_VFD_FETCH_INSTR_0_SWITCHNEXT) |
				A3XX_VFD_FETCH_INSTR_0_INDEXCODE(i) |
				A3XX_VFD_FETCH_INSTR_0_STEPRATE(1));
		OUT_RELOC(ring, rsc->bo, vbufs[i].offset, 0);

		OUT_PKT0(ring, REG_A3XX_VFD_DECODE_INSTR(i), 1);
		OUT_RING(ring, A3XX_VFD_DECODE_INSTR_CONSTFILL |
				A3XX_VFD_DECODE_INSTR_WRITEMASK(vp->inputs[i].compmask) |
				A3XX_VFD_DECODE_INSTR_FORMAT(fmt) |
				A3XX_VFD_DECODE_INSTR_REGID(vp->inputs[i].regid) |
				A3XX_VFD_DECODE_INSTR_SHIFTCNT(fs) |
				A3XX_VFD_DECODE_INSTR_LASTCOMPVALID |
				COND(switchnext, A3XX_VFD_DECODE_INSTR_SWITCHNEXT));
	}
}

void
fd3_emit_state(struct fd_context *ctx, uint32_t dirty)
{
	struct fd_ringbuffer *ring = ctx->ring;

	if (dirty & FD_DIRTY_SAMPLE_MASK) {
		OUT_PKT0(ring, REG_A3XX_RB_MSAA_CONTROL, 1);
		OUT_RING(ring, A3XX_RB_MSAA_CONTROL_DISABLE |
				A3XX_RB_MSAA_CONTROL_SAMPLES(MSAA_ONE) |
				A3XX_RB_MSAA_CONTROL_SAMPLE_MASK(ctx->sample_mask));
	}

	if (dirty & (FD_DIRTY_ZSA | FD_DIRTY_STENCIL_REF)) {
		struct fd3_zsa_stateobj *zsa = fd3_zsa_stateobj(ctx->zsa);
		struct pipe_stencil_ref *sr = &ctx->stencil_ref;

		fd3_emit_rbrc_draw_state(ring, zsa->rb_render_control);

		OUT_PKT0(ring, REG_A3XX_RB_DEPTH_CONTROL, 1);
		OUT_RING(ring, zsa->rb_depth_control);

		OUT_PKT0(ring, REG_A3XX_RB_STENCIL_CONTROL, 1);
		OUT_RING(ring, zsa->rb_stencil_control);

		OUT_PKT0(ring, REG_A3XX_RB_STENCILREFMASK, 2);
		OUT_RING(ring, zsa->rb_stencilrefmask |
				A3XX_RB_STENCILREFMASK_STENCILREF(sr->ref_value[0]));
		OUT_RING(ring, zsa->rb_stencilrefmask_bf |
				A3XX_RB_STENCILREFMASK_BF_STENCILREF(sr->ref_value[1]));
	}

	if (dirty & FD_DIRTY_RASTERIZER) {
		struct fd3_rasterizer_stateobj *rasterizer =
				fd3_rasterizer_stateobj(ctx->rasterizer);

		OUT_PKT0(ring, REG_A3XX_GRAS_SU_MODE_CONTROL, 1);
		OUT_RING(ring, rasterizer->gras_su_mode_control);

		OUT_PKT0(ring, REG_A3XX_GRAS_SU_POINT_MINMAX, 2);
		OUT_RING(ring, rasterizer->gras_su_point_minmax);
		OUT_RING(ring, rasterizer->gras_su_point_size);

		OUT_PKT0(ring, REG_A3XX_GRAS_SU_POLY_OFFSET_SCALE, 2);
		OUT_RING(ring, rasterizer->gras_su_poly_offset_scale);
		OUT_RING(ring, rasterizer->gras_su_poly_offset_offset);

		OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
		OUT_RING(ring, rasterizer->gras_cl_clip_cntl);
	}

	if (dirty & (FD_DIRTY_RASTERIZER | FD_DIRTY_PROG)) {
		struct fd3_rasterizer_stateobj *rasterizer =
				fd3_rasterizer_stateobj(ctx->rasterizer);
		struct fd3_shader_stateobj *fp = ctx->prog.fp;
		uint32_t stride_in_vpc;

		stride_in_vpc = align(fp->total_in, 4) / 4;
		if (stride_in_vpc > 0)
			stride_in_vpc = MAX2(stride_in_vpc, 2);

		OUT_PKT0(ring, REG_A3XX_PC_PRIM_VTX_CNTL, 1);
		OUT_RING(ring, rasterizer->pc_prim_vtx_cntl |
				A3XX_PC_PRIM_VTX_CNTL_STRIDE_IN_VPC(stride_in_vpc));
	}

	if (dirty & FD_DIRTY_SCISSOR) {
		struct pipe_scissor_state *scissor = fd_context_get_scissor(ctx);

		OUT_PKT0(ring, REG_A3XX_GRAS_SC_WINDOW_SCISSOR_TL, 2);
		OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_TL_X(scissor->minx) |
				A3XX_GRAS_SC_WINDOW_SCISSOR_TL_Y(scissor->miny));
		OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_BR_X(scissor->maxx - 1) |
				A3XX_GRAS_SC_WINDOW_SCISSOR_BR_Y(scissor->maxy - 1));

		ctx->max_scissor.minx = MIN2(ctx->max_scissor.minx, scissor->minx);
		ctx->max_scissor.miny = MIN2(ctx->max_scissor.miny, scissor->miny);
		ctx->max_scissor.maxx = MAX2(ctx->max_scissor.maxx, scissor->maxx);
		ctx->max_scissor.maxy = MAX2(ctx->max_scissor.maxy, scissor->maxy);
	}

	if (dirty & FD_DIRTY_VIEWPORT) {
		OUT_PKT0(ring, REG_A3XX_GRAS_CL_VPORT_XOFFSET, 6);
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_XOFFSET(ctx->viewport.translate[0] - 0.5));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_XSCALE(ctx->viewport.scale[0]));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_YOFFSET(ctx->viewport.translate[1] - 0.5));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_YSCALE(ctx->viewport.scale[1]));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZOFFSET(ctx->viewport.translate[2]));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZSCALE(ctx->viewport.scale[2]));
	}

	if (dirty & FD_DIRTY_PROG)
		fd3_program_emit(ring, &ctx->prog);

	if (dirty & (FD_DIRTY_PROG | FD_DIRTY_CONSTBUF)) {
		struct fd_program_stateobj *prog = &ctx->prog;

		emit_constants(ring,  SB_VERT_SHADER,
				&ctx->constbuf[PIPE_SHADER_VERTEX],
				(prog->dirty & FD_SHADER_DIRTY_VP) ? prog->vp : NULL);
		emit_constants(ring, SB_FRAG_SHADER,
				&ctx->constbuf[PIPE_SHADER_FRAGMENT],
				(prog->dirty & FD_SHADER_DIRTY_FP) ? prog->fp : NULL);
	}

	if (dirty & FD_DIRTY_BLEND) {
		struct fd3_blend_stateobj *blend = fd3_blend_stateobj(ctx->blend);
		uint32_t i;

		for (i = 0; i < ARRAY_SIZE(blend->rb_mrt); i++) {
			OUT_PKT0(ring, REG_A3XX_RB_MRT_CONTROL(i), 1);
			OUT_RING(ring, blend->rb_mrt[i].control);

			OUT_PKT0(ring, REG_A3XX_RB_MRT_BLEND_CONTROL(i), 1);
			OUT_RING(ring, blend->rb_mrt[i].blend_control);
		}
	}

	if (dirty & FD_DIRTY_VERTTEX)
		emit_textures(ring, SB_VERT_TEX, &ctx->verttex);

	if (dirty & FD_DIRTY_FRAGTEX)
		emit_textures(ring, SB_FRAG_TEX, &ctx->fragtex);

	ctx->dirty &= ~dirty;
}

/* emit setup at begin of new cmdstream buffer (don't rely on previous
 * state, there could have been a context switch between ioctls):
 */
void
fd3_emit_restore(struct fd_context *ctx)
{
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	struct fd_ringbuffer *ring = ctx->ring;
	int i;

	OUT_PKT3(ring, CP_REG_RMW, 3);
	OUT_RING(ring, REG_A3XX_RBBM_CLOCK_CTL);
	OUT_RING(ring, 0xfffcffff);
	OUT_RING(ring, 0x00000000);

	OUT_PKT3(ring, CP_INVALIDATE_STATE, 1);
	OUT_RING(ring, 0x00007fff);

	OUT_PKT0(ring, REG_A3XX_SP_VS_PVT_MEM_CTRL_REG, 3);
	OUT_RING(ring, 0x08000001);                  /* SP_VS_PVT_MEM_CTRL_REG */
	OUT_RELOC(ring, fd3_ctx->vs_pvt_mem, 0, 0);  /* SP_VS_PVT_MEM_ADDR_REG */
	OUT_RING(ring, 0x00000000);                  /* SP_VS_PVT_MEM_SIZE_REG */

	OUT_PKT0(ring, REG_A3XX_SP_FS_PVT_MEM_CTRL_REG, 3);
	OUT_RING(ring, 0x08000001);                  /* SP_FS_PVT_MEM_CTRL_REG */
	OUT_RELOC(ring, fd3_ctx->fs_pvt_mem, 0, 0);  /* SP_FS_PVT_MEM_ADDR_REG */
	OUT_RING(ring, 0x00000000);                  /* SP_FS_PVT_MEM_SIZE_REG */

	OUT_PKT0(ring, REG_A3XX_PC_VERTEX_REUSE_BLOCK_CNTL, 1);
	OUT_RING(ring, 0x0000000b);                  /* PC_VERTEX_REUSE_BLOCK_CNTL */

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(0));

	OUT_PKT0(ring, REG_A3XX_RB_MSAA_CONTROL, 2);
	OUT_RING(ring, A3XX_RB_MSAA_CONTROL_DISABLE |
			A3XX_RB_MSAA_CONTROL_SAMPLES(MSAA_ONE) |
			A3XX_RB_MSAA_CONTROL_SAMPLE_MASK(0xffff));
	OUT_RING(ring, 0x00000000);        /* UNKNOWN_20C3 */

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_GB_CLIP_ADJ, 1);
	OUT_RING(ring, A3XX_GRAS_CL_GB_CLIP_ADJ_HORZ(0) |
			A3XX_GRAS_CL_GB_CLIP_ADJ_VERT(0));

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0C81, 1);
	OUT_RING(ring, 0x00000001);        /* UNKNOWN_0C81 */

	OUT_PKT0(ring, REG_A3XX_TPL1_TP_VS_TEX_OFFSET, 1);
	OUT_RING(ring, A3XX_TPL1_TP_VS_TEX_OFFSET_SAMPLEROFFSET(VERT_TEX_OFF) |
			A3XX_TPL1_TP_VS_TEX_OFFSET_MEMOBJOFFSET(VERT_TEX_OFF) |
			A3XX_TPL1_TP_VS_TEX_OFFSET_BASETABLEPTR(BASETABLE_SZ * VERT_TEX_OFF));

	OUT_PKT0(ring, REG_A3XX_TPL1_TP_FS_TEX_OFFSET, 1);
	OUT_RING(ring, A3XX_TPL1_TP_FS_TEX_OFFSET_SAMPLEROFFSET(FRAG_TEX_OFF) |
			A3XX_TPL1_TP_FS_TEX_OFFSET_MEMOBJOFFSET(FRAG_TEX_OFF) |
			A3XX_TPL1_TP_FS_TEX_OFFSET_BASETABLEPTR(BASETABLE_SZ * FRAG_TEX_OFF));

	OUT_PKT0(ring, REG_A3XX_VPC_VARY_CYLWRAP_ENABLE_0, 2);
	OUT_RING(ring, 0x00000000);        /* VPC_VARY_CYLWRAP_ENABLE_0 */
	OUT_RING(ring, 0x00000000);        /* VPC_VARY_CYLWRAP_ENABLE_1 */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0E43, 1);
	OUT_RING(ring, 0x00000001);        /* UNKNOWN_0E43 */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0F03, 1);
	OUT_RING(ring, 0x00000001);        /* UNKNOWN_0F03 */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0EE0, 1);
	OUT_RING(ring, 0x00000003);        /* UNKNOWN_0EE0 */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0C3D, 1);
	OUT_RING(ring, 0x00000001);        /* UNKNOWN_0C3D */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0E00, 1);
	OUT_RING(ring, 0x00000000);        /* UNKNOWN_0E00 */

	OUT_PKT0(ring, REG_A3XX_HLSQ_CONST_VSPRESV_RANGE_REG, 2);
	OUT_RING(ring, A3XX_HLSQ_CONST_VSPRESV_RANGE_REG_STARTENTRY(0) |
			A3XX_HLSQ_CONST_VSPRESV_RANGE_REG_ENDENTRY(0));
	OUT_RING(ring, A3XX_HLSQ_CONST_FSPRESV_RANGE_REG_STARTENTRY(0) |
			A3XX_HLSQ_CONST_FSPRESV_RANGE_REG_ENDENTRY(0));

	OUT_PKT0(ring, REG_A3XX_UCHE_CACHE_MODE_CONTROL_REG, 1);
	OUT_RING(ring, 0x00000001);        /* UCHE_CACHE_MODE_CONTROL_REG */

	OUT_PKT0(ring, REG_A3XX_VSC_SIZE_ADDRESS, 1);
	OUT_RELOC(ring, fd3_ctx->vsc_size_mem, 0, 0); /* VSC_SIZE_ADDRESS */

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
	OUT_RING(ring, 0x00000000);                  /* GRAS_CL_CLIP_CNTL */

	OUT_PKT0(ring, REG_A3XX_GRAS_SU_POINT_MINMAX, 2);
	OUT_RING(ring, 0xffc00010);        /* GRAS_SU_POINT_MINMAX */
	OUT_RING(ring, 0x00000008);        /* GRAS_SU_POINT_SIZE */

	OUT_PKT0(ring, REG_A3XX_PC_RESTART_INDEX, 1);
	OUT_RING(ring, 0xffffffff);        /* PC_RESTART_INDEX */

	OUT_PKT0(ring, REG_A3XX_PA_SC_WINDOW_OFFSET, 1);
	OUT_RING(ring, A3XX_PA_SC_WINDOW_OFFSET_X(0) |
			A3XX_PA_SC_WINDOW_OFFSET_Y(0));

	OUT_PKT0(ring, REG_A3XX_RB_BLEND_RED, 4);
	OUT_RING(ring, 0x00000000);        /* RB_BLEND_RED */
	OUT_RING(ring, 0x00000000);        /* RB_BLEND_GREEN */
	OUT_RING(ring, 0x00000000);        /* RB_BLEND_BLUE */
	OUT_RING(ring, 0x3c0000ff);        /* RB_BLEND_ALPHA */

	for (i = 0; i < 6; i++) {
		OUT_PKT0(ring, REG_A3XX_GRAS_CL_USER_PLANE(i), 4);
		OUT_RING(ring, 0x00000000);    /* GRAS_CL_USER_PLANE[i].X */
		OUT_RING(ring, 0x00000000);    /* GRAS_CL_USER_PLANE[i].Y */
		OUT_RING(ring, 0x00000000);    /* GRAS_CL_USER_PLANE[i].Z */
		OUT_RING(ring, 0x00000000);    /* GRAS_CL_USER_PLANE[i].W */
	}

	emit_cache_flush(ring);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.5
@
text
@d84 1
a84 1
				CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS), 0);
d215 1
a215 1
		OUT_RELOC(ring, view->tex_resource->bo, 0, 0, 0);
d282 3
a284 3
			fd3_tex_swiz(psurf->format,  PIPE_SWIZZLE_RED, PIPE_SWIZZLE_GREEN,
					PIPE_SWIZZLE_BLUE, PIPE_SWIZZLE_ALPHA));
	OUT_RING(ring, A3XX_TEX_CONST_1_FETCHSIZE(TFETCH_DISABLE) |
d299 1
a299 1
	OUT_RELOC(ring, rsc->bo, 0, 0, 0);
d325 1
a325 1
		OUT_RELOC(ring, rsc->bo, vbufs[i].offset, 0, 0);
d484 1
a484 1
	OUT_RELOC(ring, fd3_ctx->vs_pvt_mem, 0,0,0); /* SP_VS_PVT_MEM_ADDR_REG */
d489 1
a489 1
	OUT_RELOC(ring, fd3_ctx->fs_pvt_mem, 0,0,0); /* SP_FS_PVT_MEM_ADDR_REG */
d539 2
a540 2
	OUT_PKT0(ring, REG_A3XX_HLSQ_PERFCOUNTER0_SELECT, 1);
	OUT_RING(ring, 0x00000000);        /* HLSQ_PERFCOUNTER0_SELECT */
d552 1
a552 1
	OUT_RELOC(ring, fd3_ctx->vsc_size_mem, 0, 0, 0); /* VSC_SIZE_ADDRESS */
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d67 9
d99 1
a99 1
		struct fd3_shader_variant *shader)
a101 1
	uint32_t first_immediate;
a108 7
	/* in particular, with binning shader and a unneeded consts no
	 * longer referenced, we could end up w/ constlen that is smaller
	 * than first_immediate.  In that case truncate the user consts
	 * early to avoid HLSQ lockup caused by writing too many consts
	 */
	first_immediate = MIN2(shader->first_immediate, shader->constlen);

d118 4
a121 2
		/* gallium could leave const buffers bound above what the
		 * current shader uses.. don't let that confuse us.
d123 1
a123 1
		if (base >= (4 * first_immediate))
a126 4
			/* and even if the start of the const buffer is before
			 * first_immediate, the end may not be:
			 */
			size = MIN2(size, (4 * first_immediate) - base);
d140 3
a142 5
			base = 4 * (shader->first_immediate + i);
			if (base >= (4 * shader->constlen))
				break;
			fd3_emit_constant(ring, sb, base,
				0, 4, shader->immediates[i].val, NULL);
d149 1
a149 1
#define BASETABLE_SZ    A3XX_MAX_MIP_LEVELS
d166 18
a183 17
	if (tex->num_samplers > 0) {
		/* output sampler state: */
		OUT_PKT3(ring, CP_LOAD_STATE, 2 + (2 * tex->num_samplers));
		OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(tex_off[sb]) |
				CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
				CP_LOAD_STATE_0_STATE_BLOCK(sb) |
				CP_LOAD_STATE_0_NUM_UNIT(tex->num_samplers));
		OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_SHADER) |
				CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
		for (i = 0; i < tex->num_samplers; i++) {
			static const struct fd3_sampler_stateobj dummy_sampler = {};
			const struct fd3_sampler_stateobj *sampler = tex->samplers[i] ?
					fd3_sampler_stateobj(tex->samplers[i]) :
					&dummy_sampler;
			OUT_RING(ring, sampler->texsamp0);
			OUT_RING(ring, sampler->texsamp1);
		}
d186 17
a202 20
	if (tex->num_textures > 0) {
		/* emit texture state: */
		OUT_PKT3(ring, CP_LOAD_STATE, 2 + (4 * tex->num_textures));
		OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(tex_off[sb]) |
				CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
				CP_LOAD_STATE_0_STATE_BLOCK(sb) |
				CP_LOAD_STATE_0_NUM_UNIT(tex->num_textures));
		OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
				CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
		for (i = 0; i < tex->num_textures; i++) {
			static const struct fd3_pipe_sampler_view dummy_view = {};
			const struct fd3_pipe_sampler_view *view = tex->textures[i] ?
					fd3_pipe_sampler_view(tex->textures[i]) :
					&dummy_view;
			OUT_RING(ring, view->texconst0);
			OUT_RING(ring, view->texconst1);
			OUT_RING(ring, view->texconst2 |
					A3XX_TEX_CONST_2_INDX(BASETABLE_SZ * i));
			OUT_RING(ring, view->texconst3);
		}
d204 18
a221 24
		/* emit mipaddrs: */
		OUT_PKT3(ring, CP_LOAD_STATE, 2 + (BASETABLE_SZ * tex->num_textures));
		OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(BASETABLE_SZ * tex_off[sb]) |
				CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
				CP_LOAD_STATE_0_STATE_BLOCK(mipaddr[sb]) |
				CP_LOAD_STATE_0_NUM_UNIT(BASETABLE_SZ * tex->num_textures));
		OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
				CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
		for (i = 0; i < tex->num_textures; i++) {
			static const struct fd3_pipe_sampler_view dummy_view = {};
			const struct fd3_pipe_sampler_view *view = tex->textures[i] ?
					fd3_pipe_sampler_view(tex->textures[i]) :
					&dummy_view;
			struct fd_resource *rsc = view->tex_resource;

			for (j = 0; j < view->mipaddrs; j++) {
				struct fd_resource_slice *slice = fd_resource_slice(rsc, j);
				OUT_RELOC(ring, rsc->bo, slice->offset, 0, 0);
			}

			/* pad the remaining entries w/ null: */
			for (; j < BASETABLE_SZ; j++) {
				OUT_RING(ring, 0x00000000);
			}
a231 1
	/* probably only really needed on a320: */
d234 1
a234 1
	OUT_RING(ring, DRAW(1, DI_SRC_SEL_AUTO_INDEX,
d243 3
a255 1
	enum pipe_format format = fd3_gmem_restore_format(psurf->format);
d281 2
a282 2
			A3XX_TEX_CONST_0_TYPE(A3XX_TEX_2D) |
			fd3_tex_swiz(format,  PIPE_SWIZZLE_RED, PIPE_SWIZZLE_GREEN,
d287 1
a287 1
	OUT_RING(ring, A3XX_TEX_CONST_2_PITCH(rsc->slices[0].pitch * rsc->cpp) |
d304 1
a304 1
		struct fd3_shader_variant *vp,
d307 2
a308 2
	uint32_t i, j, last = 0;
	uint32_t total_in = 0;
d312 23
a334 36
	for (i = 0; i < n; i++)
		if (vp->inputs[i].compmask)
			last = i;

	for (i = 0, j = 0; i <= last; i++) {
		if (vp->inputs[i].compmask) {
			struct pipe_resource *prsc = vbufs[i].prsc;
			struct fd_resource *rsc = fd_resource(prsc);
			enum pipe_format pfmt = vbufs[i].format;
			enum a3xx_vtx_fmt fmt = fd3_pipe2vtx(pfmt);
			bool switchnext = (i != last);
			uint32_t fs = util_format_get_blocksize(pfmt);

			debug_assert(fmt != ~0);

			OUT_PKT0(ring, REG_A3XX_VFD_FETCH(j), 2);
			OUT_RING(ring, A3XX_VFD_FETCH_INSTR_0_FETCHSIZE(fs - 1) |
					A3XX_VFD_FETCH_INSTR_0_BUFSTRIDE(vbufs[i].stride) |
					COND(switchnext, A3XX_VFD_FETCH_INSTR_0_SWITCHNEXT) |
					A3XX_VFD_FETCH_INSTR_0_INDEXCODE(j) |
					A3XX_VFD_FETCH_INSTR_0_STEPRATE(1));
			OUT_RELOC(ring, rsc->bo, vbufs[i].offset, 0, 0);

			OUT_PKT0(ring, REG_A3XX_VFD_DECODE_INSTR(j), 1);
			OUT_RING(ring, A3XX_VFD_DECODE_INSTR_CONSTFILL |
					A3XX_VFD_DECODE_INSTR_WRITEMASK(vp->inputs[i].compmask) |
					A3XX_VFD_DECODE_INSTR_FORMAT(fmt) |
					A3XX_VFD_DECODE_INSTR_SWAP(fd3_pipe2swap(pfmt)) |
					A3XX_VFD_DECODE_INSTR_REGID(vp->inputs[i].regid) |
					A3XX_VFD_DECODE_INSTR_SHIFTCNT(fs) |
					A3XX_VFD_DECODE_INSTR_LASTCOMPVALID |
					COND(switchnext, A3XX_VFD_DECODE_INSTR_SWITCHNEXT));

			total_in += vp->inputs[i].ncomp;
			j++;
		}
a335 9

	OUT_PKT0(ring, REG_A3XX_VFD_CONTROL_0, 2);
	OUT_RING(ring, A3XX_VFD_CONTROL_0_TOTALATTRTOVS(total_in) |
			A3XX_VFD_CONTROL_0_PACKETSIZE(2) |
			A3XX_VFD_CONTROL_0_STRMDECINSTRCNT(j) |
			A3XX_VFD_CONTROL_0_STRMFETCHINSTRCNT(j));
	OUT_RING(ring, A3XX_VFD_CONTROL_1_MAXSTORAGE(1) | // XXX
			A3XX_VFD_CONTROL_1_REGID4VTX(regid(63,0)) |
			A3XX_VFD_CONTROL_1_REGID4INST(regid(63,0)));
d339 1
a339 3
fd3_emit_state(struct fd_context *ctx, struct fd_ringbuffer *ring,
		struct fd_program_stateobj *prog, uint32_t dirty,
		struct fd3_shader_key key)
d341 1
a341 7
	struct fd3_shader_variant *vp;
	struct fd3_shader_variant *fp;

	fp = fd3_shader_variant(prog->fp, key);
	vp = fd3_shader_variant(prog->vp, key);

	emit_marker(ring, 5);
a349 19
	if ((dirty & (FD_DIRTY_ZSA | FD_DIRTY_PROG)) && !key.binning_pass) {
		uint32_t val = fd3_zsa_stateobj(ctx->zsa)->rb_render_control;

		val |= COND(fp->frag_face, A3XX_RB_RENDER_CONTROL_FACENESS);
		val |= COND(fp->frag_coord, A3XX_RB_RENDER_CONTROL_XCOORD |
				A3XX_RB_RENDER_CONTROL_YCOORD |
				A3XX_RB_RENDER_CONTROL_ZCOORD |
				A3XX_RB_RENDER_CONTROL_WCOORD);

		/* I suppose if we needed to (which I don't *think* we need
		 * to), we could emit this for binning pass too.  But we
		 * would need to keep a different patch-list for binning
		 * vs render pass.
		 */

		OUT_PKT0(ring, REG_A3XX_RB_RENDER_CONTROL, 1);
		OUT_RINGP(ring, val, &fd3_context(ctx)->rbrc_patches);
	}

d354 4
a357 2
		OUT_PKT0(ring, REG_A3XX_RB_ALPHA_REF, 1);
		OUT_RING(ring, zsa->rb_alpha_ref);
a368 10
	if (dirty & (FD_DIRTY_ZSA | FD_DIRTY_PROG)) {
		uint32_t val = fd3_zsa_stateobj(ctx->zsa)->rb_depth_control;
		if (fp->writes_pos) {
			val |= A3XX_RB_DEPTH_CONTROL_FRAG_WRITES_Z;
			val |= A3XX_RB_DEPTH_CONTROL_EARLY_Z_DISABLE;
		}
		OUT_PKT0(ring, REG_A3XX_RB_DEPTH_CONTROL, 1);
		OUT_RING(ring, val);
	}

a382 1
	}
a383 6
	if (dirty & (FD_DIRTY_RASTERIZER | FD_DIRTY_PROG)) {
		uint32_t val = fd3_rasterizer_stateobj(ctx->rasterizer)
				->gras_cl_clip_cntl;
		val |= COND(fp->writes_pos, A3XX_GRAS_CL_CLIP_CNTL_ZCLIP_DISABLE);
		val |= COND(fp->frag_coord, A3XX_GRAS_CL_CLIP_CNTL_ZCOORD |
				A3XX_GRAS_CL_CLIP_CNTL_WCOORD);
d385 1
a385 1
		OUT_RING(ring, val);
d389 4
a392 2
		uint32_t val = fd3_rasterizer_stateobj(ctx->rasterizer)
				->pc_prim_vtx_cntl;
d394 3
a396 8
		if (!key.binning_pass) {
			uint32_t stride_in_vpc = align(fp->total_in, 4) / 4;
			if (stride_in_vpc > 0)
				stride_in_vpc = MAX2(stride_in_vpc, 2);
			val |= A3XX_PC_PRIM_VTX_CNTL_STRIDE_IN_VPC(stride_in_vpc);
		}

		val |= COND(vp->writes_psize, A3XX_PC_PRIM_VTX_CNTL_PSIZE);
d399 2
a400 1
		OUT_RING(ring, val);
d428 2
a429 4
	if (dirty & FD_DIRTY_PROG) {
		fd_wfi(ctx, ring);
		fd3_program_emit(ring, prog, key);
	}
d431 2
a432 2
	OUT_PKT3(ring, CP_EVENT_WRITE, 1);
	OUT_RING(ring, HLSQ_FLUSH);
a433 4
	if ((dirty & (FD_DIRTY_PROG | FD_DIRTY_CONSTBUF)) &&
			/* evil hack to deal sanely with clear path: */
			(prog == &ctx->prog)) {
		fd_wfi(ctx, ring);
d436 4
a439 6
				(prog->dirty & FD_SHADER_DIRTY_VP) ? vp : NULL);
		if (!key.binning_pass) {
			emit_constants(ring, SB_FRAG_SHADER,
					&ctx->constbuf[PIPE_SHADER_FRAGMENT],
					(prog->dirty & FD_SHADER_DIRTY_FP) ? fp : NULL);
		}
d442 1
a442 1
	if ((dirty & FD_DIRTY_BLEND) && ctx->blend) {
d455 5
a459 29
	if (dirty & FD_DIRTY_BLEND_COLOR) {
		struct pipe_blend_color *bcolor = &ctx->blend_color;
		OUT_PKT0(ring, REG_A3XX_RB_BLEND_RED, 4);
		OUT_RING(ring, A3XX_RB_BLEND_RED_UINT(bcolor->color[0] * 255.0) |
				A3XX_RB_BLEND_RED_FLOAT(bcolor->color[0]));
		OUT_RING(ring, A3XX_RB_BLEND_GREEN_UINT(bcolor->color[1] * 255.0) |
				A3XX_RB_BLEND_GREEN_FLOAT(bcolor->color[1]));
		OUT_RING(ring, A3XX_RB_BLEND_BLUE_UINT(bcolor->color[2] * 255.0) |
				A3XX_RB_BLEND_BLUE_FLOAT(bcolor->color[2]));
		OUT_RING(ring, A3XX_RB_BLEND_ALPHA_UINT(bcolor->color[3] * 255.0) |
				A3XX_RB_BLEND_ALPHA_FLOAT(bcolor->color[3]));
	}

	if (dirty & (FD_DIRTY_VERTTEX | FD_DIRTY_FRAGTEX))
		fd_wfi(ctx, ring);

	if (dirty & FD_DIRTY_VERTTEX) {
		if (vp->has_samp)
			emit_textures(ring, SB_VERT_TEX, &ctx->verttex);
		else
			dirty &= ~FD_DIRTY_VERTTEX;
	}

	if (dirty & FD_DIRTY_FRAGTEX) {
		if (fp->has_samp)
			emit_textures(ring, SB_FRAG_TEX, &ctx->fragtex);
		else
			dirty &= ~FD_DIRTY_FRAGTEX;
	}
d474 4
a477 6
	if (ctx->screen->gpu_id == 320) {
		OUT_PKT3(ring, CP_REG_RMW, 3);
		OUT_RING(ring, REG_A3XX_RBBM_CLOCK_CTL);
		OUT_RING(ring, 0xfffcffff);
		OUT_RING(ring, 0x00000000);
	}
d482 1
a482 1
	OUT_PKT0(ring, REG_A3XX_SP_VS_PVT_MEM_PARAM_REG, 3);
d487 1
a487 1
	OUT_PKT0(ring, REG_A3XX_SP_FS_PVT_MEM_PARAM_REG, 3);
d504 1
a504 1
	OUT_RING(ring, 0x00000000);        /* RB_ALPHA_REF */
d510 2
a511 2
	OUT_PKT0(ring, REG_A3XX_GRAS_TSE_DEBUG_ECO, 1);
	OUT_RING(ring, 0x00000001);        /* GRAS_TSE_DEBUG_ECO */
d548 5
a552 5
	OUT_PKT0(ring, REG_A3XX_UCHE_CACHE_INVALIDATE0_REG, 2);
	OUT_RING(ring, A3XX_UCHE_CACHE_INVALIDATE0_REG_ADDR(0));
	OUT_RING(ring, A3XX_UCHE_CACHE_INVALIDATE1_REG_ADDR(0) |
			A3XX_UCHE_CACHE_INVALIDATE1_REG_OPCODE(INVALIDATE) |
			A3XX_UCHE_CACHE_INVALIDATE1_REG_ENTIRE_CACHE);
d564 3
a566 3
	OUT_PKT0(ring, REG_A3XX_RB_WINDOW_OFFSET, 1);
	OUT_RING(ring, A3XX_RB_WINDOW_OFFSET_X(0) |
			A3XX_RB_WINDOW_OFFSET_Y(0));
d569 4
a572 8
	OUT_RING(ring, A3XX_RB_BLEND_RED_UINT(0) |
			A3XX_RB_BLEND_RED_FLOAT(0.0));
	OUT_RING(ring, A3XX_RB_BLEND_GREEN_UINT(0) |
			A3XX_RB_BLEND_GREEN_FLOAT(0.0));
	OUT_RING(ring, A3XX_RB_BLEND_BLUE_UINT(0) |
			A3XX_RB_BLEND_BLUE_FLOAT(0.0));
	OUT_RING(ring, A3XX_RB_BLEND_ALPHA_UINT(0xff) |
			A3XX_RB_BLEND_ALPHA_FLOAT(1.0));
a581 3
	OUT_PKT0(ring, REG_A3XX_PC_VSTREAM_CONTROL, 1);
	OUT_RING(ring, 0x00000000);

a582 3
	fd_wfi(ctx, ring);

	ctx->needs_rb_fbd = true;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d90 1
a90 1
		struct ir3_shader_variant *shader)
d95 1
d101 2
a102 2
	/* in particular, with binning shader we may end up with unused
	 * consts, ie. we could end up w/ constlen that is smaller
d140 4
a143 13
		int size = shader->immediates_count;
		base = shader->first_immediate;

		/* truncate size to avoid writing constants that shader
		 * does not use:
		 */
		size = MIN2(size + base, shader->constlen) - base;

		/* convert out of vec4: */
		base *= 4;
		size *= 4;

		if (size > 0) {
d145 1
a145 1
				0, size, shader->immediates[0].val, NULL);
d155 3
a157 2
emit_textures(struct fd_context *ctx, struct fd_ringbuffer *ring,
		enum adreno_state_block sb, struct fd_texture_stateobj *tex)
d167 1
a167 12
	static const uint32_t bcolor_reg[] = {
			[SB_VERT_TEX] = REG_A3XX_TPL1_TP_VS_BORDER_COLOR_BASE_ADDR,
			[SB_FRAG_TEX] = REG_A3XX_TPL1_TP_FS_BORDER_COLOR_BASE_ADDR,
	};
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	unsigned i, j, off;
	void *ptr;

	u_upload_alloc(fd3_ctx->border_color_uploader,
			0, 2 * PIPE_MAX_SAMPLERS * BORDERCOLOR_SIZE, &off,
			&fd3_ctx->border_color_buf,
			&ptr);
a182 9
			uint16_t *bcolor = (uint16_t *)((uint8_t *)ptr +
					(BORDERCOLOR_SIZE * tex_off[sb]) +
					(BORDERCOLOR_SIZE * i));

			bcolor[0] = util_float_to_half(sampler->base.border_color.f[2]);
			bcolor[1] = util_float_to_half(sampler->base.border_color.f[1]);
			bcolor[2] = util_float_to_half(sampler->base.border_color.f[0]);
			bcolor[3] = util_float_to_half(sampler->base.border_color.f[3]);

d218 1
a218 3
			static const struct fd3_pipe_sampler_view dummy_view = {
					.base.u.tex.first_level = 1,
			};
a222 2
			unsigned start = view->base.u.tex.first_level;
			unsigned end   = view->base.u.tex.last_level;
d224 2
a225 3
			for (j = 0; j < (end - start + 1); j++) {
				struct fd_resource_slice *slice =
						fd_resource_slice(rsc, j + start);
d235 7
d243 6
a248 2
	OUT_PKT0(ring, bcolor_reg[sb], 1);
	OUT_RELOC(ring, fd_resource(fd3_ctx->border_color_buf)->bo, off, 0, 0);
d250 5
a254 1
	u_upload_unmap(fd3_ctx->border_color_uploader);
a259 3
 *
 * Also, for using normal state, not quite sure how to handle the special
 * case format (fd3_gmem_restore_format()) stuff for restoring depth/stencil.
a264 3
	unsigned lvl = psurf->u.tex.level;
	struct fd_resource_slice *slice = &rsc->slices[lvl];
	uint32_t layer_offset = slice->size0 * psurf->u.tex.first_layer;
a266 2
	debug_assert(psurf->u.tex.first_layer == psurf->u.tex.last_layer);

d290 1
a290 1
	OUT_RING(ring, A3XX_TEX_CONST_0_FMT(fd3_pipe2tex(format)) |
d297 1
a297 1
	OUT_RING(ring, A3XX_TEX_CONST_2_PITCH(slice->pitch * rsc->cpp) |
d309 1
a309 1
	OUT_RELOC(ring, rsc->bo, layer_offset, 0, 0);
d313 3
a315 1
fd3_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd3_emit *emit)
d319 2
a320 7
	const struct fd_vertex_state *vtx = emit->vtx;
	struct ir3_shader_variant *vp = fd3_emit_get_vp(emit);
	unsigned n = MIN2(vtx->vtx->num_elements, vp->inputs_count);

	/* hw doesn't like to be configured for zero vbo's, it seems: */
	if (vtx->vtx->num_elements == 0)
		return;
d328 3
a330 5
			struct pipe_vertex_element *elem = &vtx->vtx->pipe[i];
			const struct pipe_vertex_buffer *vb =
					&vtx->vertexbuf.vb[elem->vertex_buffer_index];
			struct fd_resource *rsc = fd_resource(vb->buffer);
			enum pipe_format pfmt = elem->src_format;
a332 1
			bool isint = util_format_is_pure_integer(pfmt);
d339 1
a339 1
					A3XX_VFD_FETCH_INSTR_0_BUFSTRIDE(vb->stride) |
d343 1
a343 1
			OUT_RELOC(ring, rsc->bo, vb->buffer_offset + elem->src_offset, 0, 0);
a352 1
					COND(isint, A3XX_VFD_DECODE_INSTR_INT) |
d372 2
a373 1
		struct fd3_emit *emit)
d375 5
a379 3
	struct ir3_shader_variant *vp = fd3_emit_get_vp(emit);
	struct ir3_shader_variant *fp = fd3_emit_get_fp(emit);
	uint32_t dirty = emit->dirty;
d390 1
a390 1
	if ((dirty & (FD_DIRTY_ZSA | FD_DIRTY_PROG)) && !emit->key.binning_pass) {
a431 3
		if (fp->has_kill) {
			val |= A3XX_RB_DEPTH_CONTROL_EARLY_Z_DISABLE;
		}
d462 1
a462 7
	/* NOTE: since primitive_restart is not actually part of any
	 * state object, we need to make sure that we always emit
	 * PRIM_VTX_CNTL.. either that or be more clever and detect
	 * when it changes.
	 */
	if (emit->info) {
		const struct pipe_draw_info *info = emit->info;
d466 1
a466 1
		if (!emit->key.binning_pass) {
a472 4
		if (info->indexed && info->primitive_restart) {
			val |= A3XX_PC_PRIM_VTX_CNTL_PRIMITIVE_RESTART;
		}

a494 1
		fd_wfi(ctx, ring);
d504 4
a507 2
	if (dirty & FD_DIRTY_PROG)
		fd3_program_emit(ring, emit);
a508 2
	/* TODO we should not need this or fd_wfi() before emit_constants():
	 */
d514 1
a514 1
			(emit->prog == &ctx->prog)) {
d518 2
a519 2
				(emit->prog->dirty & FD_SHADER_DIRTY_VP) ? vp : NULL);
		if (!emit->key.binning_pass) {
d522 1
a522 1
					(emit->prog->dirty & FD_SHADER_DIRTY_FP) ? fp : NULL);
d526 1
a526 1
	if ((dirty & (FD_DIRTY_BLEND | FD_DIRTY_FRAMEBUFFER)) && ctx->blend) {
a530 3
			bool is_float = util_format_is_float(
					pipe_surface_format(ctx->framebuffer.cbufs[i]));

d535 1
a535 2
			OUT_RING(ring, blend->rb_mrt[i].blend_control |
					COND(!is_float, A3XX_RB_MRT_BLEND_CONTROL_CLAMP_ENABLE));
d557 1
a557 1
			emit_textures(ctx, ring, SB_VERT_TEX, &ctx->verttex);
d564 1
a564 1
			emit_textures(ctx, ring, SB_FRAG_TEX, &ctx->fragtex);
a588 1
	fd_wfi(ctx, ring);
d699 1
a699 16
	fd_event_write(ctx, ring, CACHE_FLUSH);

	if (is_a3xx_p0(ctx->screen)) {
		OUT_PKT3(ring, CP_DRAW_INDX, 3);
		OUT_RING(ring, 0x00000000);
		OUT_RING(ring, DRAW(1, DI_SRC_SEL_AUTO_INDEX,
				INDEX_SIZE_IGN, IGNORE_VISIBILITY));
		OUT_RING(ring, 0);					/* NumIndices */
	}

	OUT_PKT3(ring, CP_NOP, 4);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);

@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d90 1
a90 1
		struct fd3_shader_variant *shader)
a94 1
	unsigned i;
d100 2
a101 2
	/* in particular, with binning shader and a unneeded consts no
	 * longer referenced, we could end up w/ constlen that is smaller
d139 13
a151 4
		for (i = 0; i < shader->immediates_count; i++) {
			base = 4 * (shader->first_immediate + i);
			if (base >= (4 * shader->constlen))
				break;
d153 1
a153 1
				0, 4, shader->immediates[i].val, NULL);
d163 2
a164 3
emit_textures(struct fd_ringbuffer *ring,
		enum adreno_state_block sb,
		struct fd_texture_stateobj *tex)
d174 12
a185 1
	unsigned i, j;
d201 9
d245 3
a247 1
			static const struct fd3_pipe_sampler_view dummy_view = {};
d252 2
d255 3
a257 2
			for (j = 0; j < view->mipaddrs; j++) {
				struct fd_resource_slice *slice = fd_resource_slice(rsc, j);
a266 7
}

static void
emit_cache_flush(struct fd_ringbuffer *ring)
{
	OUT_PKT3(ring, CP_EVENT_WRITE, 1);
	OUT_RING(ring, CACHE_FLUSH);
d268 2
a269 6
	/* probably only really needed on a320: */
	OUT_PKT3(ring, CP_DRAW_INDX, 3);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, DRAW(1, DI_SRC_SEL_AUTO_INDEX,
			INDEX_SIZE_IGN, IGNORE_VISIBILITY));
	OUT_RING(ring, 0);					/* NumIndices */
d271 1
a271 5
	OUT_PKT3(ring, CP_NOP, 4);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
d277 3
d285 3
d290 2
d315 1
a315 1
	OUT_RING(ring, A3XX_TEX_CONST_0_FMT(fd3_pipe2tex(psurf->format)) |
d322 1
a322 1
	OUT_RING(ring, A3XX_TEX_CONST_2_PITCH(rsc->slices[0].pitch * rsc->cpp) |
d334 1
a334 1
	OUT_RELOC(ring, rsc->bo, 0, 0, 0);
d338 1
a338 3
fd3_emit_vertex_bufs(struct fd_ringbuffer *ring,
		struct fd3_shader_variant *vp,
		struct fd3_vertex_buf *vbufs, uint32_t n)
d342 7
a348 2

	n = MIN2(n, vp->inputs_count);
d356 5
a360 3
			struct pipe_resource *prsc = vbufs[i].prsc;
			struct fd_resource *rsc = fd_resource(prsc);
			enum pipe_format pfmt = vbufs[i].format;
d363 1
d370 1
a370 1
					A3XX_VFD_FETCH_INSTR_0_BUFSTRIDE(vbufs[i].stride) |
d374 1
a374 1
			OUT_RELOC(ring, rsc->bo, vbufs[i].offset, 0, 0);
d384 1
d404 1
a404 2
		struct fd_program_stateobj *prog, uint32_t dirty,
		struct fd3_shader_key key)
d406 3
a408 5
	struct fd3_shader_variant *vp;
	struct fd3_shader_variant *fp;

	fp = fd3_shader_variant(prog->fp, key);
	vp = fd3_shader_variant(prog->vp, key);
d419 1
a419 1
	if ((dirty & (FD_DIRTY_ZSA | FD_DIRTY_PROG)) && !key.binning_pass) {
d461 3
d494 7
a500 1
	if (dirty & (FD_DIRTY_RASTERIZER | FD_DIRTY_PROG)) {
d504 1
a504 1
		if (!key.binning_pass) {
d511 4
d537 1
d547 2
a548 4
	if (dirty & FD_DIRTY_PROG) {
		fd_wfi(ctx, ring);
		fd3_program_emit(ring, prog, key);
	}
d550 2
d557 1
a557 1
			(prog == &ctx->prog)) {
d561 2
a562 2
				(prog->dirty & FD_SHADER_DIRTY_VP) ? vp : NULL);
		if (!key.binning_pass) {
d565 1
a565 1
					(prog->dirty & FD_SHADER_DIRTY_FP) ? fp : NULL);
d569 1
a569 1
	if ((dirty & FD_DIRTY_BLEND) && ctx->blend) {
d574 3
d581 2
a582 1
			OUT_RING(ring, blend->rb_mrt[i].blend_control);
d604 1
a604 1
			emit_textures(ring, SB_VERT_TEX, &ctx->verttex);
d611 1
a611 1
			emit_textures(ring, SB_FRAG_TEX, &ctx->fragtex);
d636 1
d747 16
a762 1
	emit_cache_flush(ring);
@


