head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.2
	OPENBSD_5_6_BASE:1.1.1.3
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.1.1.2.0.2
	OPENBSD_5_5_BASE:1.1.1.2
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.29;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.11.05;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.05;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.01.19.03.03.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.51;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.00;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.09;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/* -*- mode: C; c-file-style: "k&r"; tab-width 4; indent-tabs-mode: t; -*- */

/*
 * Copyright (C) 2013 Rob Clark <robclark@@freedesktop.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Rob Clark <robclark@@freedesktop.org>
 */

#include "pipe/p_state.h"
#include "util/u_string.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_format.h"

#include "freedreno_state.h"
#include "freedreno_resource.h"

#include "fd3_gmem.h"
#include "fd3_context.h"
#include "fd3_emit.h"
#include "fd3_program.h"
#include "fd3_util.h"
#include "fd3_zsa.h"


static void
emit_mrt(struct fd_ringbuffer *ring, unsigned nr_bufs,
		struct pipe_surface **bufs, uint32_t *bases, uint32_t bin_w)
{
	enum a3xx_tile_mode tile_mode;
	unsigned i;

	if (bin_w) {
		tile_mode = TILE_32X32;
	} else {
		tile_mode = LINEAR;
	}

	for (i = 0; i < 4; i++) {
		enum a3xx_color_fmt format = 0;
		enum a3xx_color_swap swap = WZYX;
		struct fd_resource *res = NULL;
		uint32_t stride = 0;
		uint32_t base = 0;

		if (i < nr_bufs) {
			struct pipe_surface *psurf = bufs[i];

			res = fd_resource(psurf->texture);
			format = fd3_pipe2color(psurf->format);
			swap = fd3_pipe2swap(psurf->format);

			if (bin_w) {
				stride = bin_w * res->cpp;

				if (bases) {
					base = bases[i] * res->cpp;
				}
			} else {
				stride = res->pitch * res->cpp;
			}
		}

		OUT_PKT0(ring, REG_A3XX_RB_MRT_BUF_INFO(i), 2);
		OUT_RING(ring, A3XX_RB_MRT_BUF_INFO_COLOR_FORMAT(format) |
				A3XX_RB_MRT_BUF_INFO_COLOR_TILE_MODE(tile_mode) |
				A3XX_RB_MRT_BUF_INFO_COLOR_BUF_PITCH(stride) |
				A3XX_RB_MRT_BUF_INFO_COLOR_SWAP(swap));
		if (bin_w || (i >= nr_bufs)) {
			OUT_RING(ring, A3XX_RB_MRT_BUF_BASE_COLOR_BUF_BASE(base));
		} else {
			OUT_RELOCS(ring, res->bo, 0, 0, -1);
		}

		OUT_PKT0(ring, REG_A3XX_SP_FS_IMAGE_OUTPUT_REG(i), 1);
		OUT_RING(ring, A3XX_SP_FS_IMAGE_OUTPUT_REG_MRTFORMAT(format));
	}
}

static uint32_t
depth_base(struct fd_gmem_stateobj *gmem)
{
	return align(gmem->bin_w * gmem->bin_h, 0x4000);
}

/* transfer from gmem to system memory (ie. normal RAM) */

static void
emit_gmem2mem_surf(struct fd_ringbuffer *ring,
		enum adreno_rb_copy_control_mode mode,
		uint32_t base, struct pipe_surface *psurf)
{
	struct fd_resource *rsc = fd_resource(psurf->texture);

	OUT_PKT0(ring, REG_A3XX_RB_COPY_CONTROL, 4);
	OUT_RING(ring, A3XX_RB_COPY_CONTROL_MSAA_RESOLVE(MSAA_ONE) |
			A3XX_RB_COPY_CONTROL_MODE(mode) |
			A3XX_RB_COPY_CONTROL_GMEM_BASE(base));
	OUT_RELOCS(ring, rsc->bo, 0, 0, -1);    /* RB_COPY_DEST_BASE */
	OUT_RING(ring, A3XX_RB_COPY_DEST_PITCH_PITCH(rsc->pitch * rsc->cpp));
	OUT_RING(ring, A3XX_RB_COPY_DEST_INFO_TILE(LINEAR) |
			A3XX_RB_COPY_DEST_INFO_FORMAT(fd3_pipe2color(psurf->format)) |
			A3XX_RB_COPY_DEST_INFO_COMPONENT_ENABLE(0xf) |
			A3XX_RB_COPY_DEST_INFO_ENDIAN(ENDIAN_NONE) |
			A3XX_RB_COPY_DEST_INFO_SWAP(fd3_pipe2swap(psurf->format)));

	OUT_PKT3(ring, CP_DRAW_INDX, 3);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, DRAW(DI_PT_RECTLIST, DI_SRC_SEL_AUTO_INDEX,
			INDEX_SIZE_IGN, IGNORE_VISIBILITY));
	OUT_RING(ring, 2);					/* NumIndices */
}

static void
fd3_emit_tile_gmem2mem(struct fd_context *ctx, uint32_t xoff, uint32_t yoff,
		uint32_t bin_w, uint32_t bin_h)
{
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	struct fd_ringbuffer *ring = ctx->ring;
	struct pipe_framebuffer_state *pfb = &ctx->framebuffer;

	OUT_PKT0(ring, REG_A3XX_RB_DEPTH_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_DEPTH_CONTROL_ZFUNC(FUNC_NEVER));

	OUT_PKT0(ring, REG_A3XX_RB_STENCIL_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_STENCIL_CONTROL_FUNC(FUNC_NEVER) |
			A3XX_RB_STENCIL_CONTROL_FAIL(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZPASS(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZFAIL(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_FUNC_BF(FUNC_NEVER) |
			A3XX_RB_STENCIL_CONTROL_FAIL_BF(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZPASS_BF(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZFAIL_BF(STENCIL_KEEP));

	OUT_PKT0(ring, REG_A3XX_RB_STENCILREFMASK, 2);
	OUT_RING(ring, 0xff000000 |
			A3XX_RB_STENCILREFMASK_STENCILREF(0) |
			A3XX_RB_STENCILREFMASK_STENCILMASK(0) |
			A3XX_RB_STENCILREFMASK_STENCILWRITEMASK(0xff));
	OUT_RING(ring, 0xff000000 |
			A3XX_RB_STENCILREFMASK_STENCILREF(0) |
			A3XX_RB_STENCILREFMASK_STENCILMASK(0) |
			A3XX_RB_STENCILREFMASK_STENCILWRITEMASK(0xff));

	OUT_PKT0(ring, REG_A3XX_GRAS_SU_MODE_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SU_MODE_CONTROL_LINEHALFWIDTH(0));

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
	OUT_RING(ring, 0x00000000);   /* GRAS_CL_CLIP_CNTL */

	OUT_PKT0(ring, REG_A3XX_RB_MODE_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_MODE_CONTROL_RENDER_MODE(RB_RESOLVE_PASS) |
			A3XX_RB_MODE_CONTROL_MARB_CACHE_SPLIT_MODE);

	fd3_emit_rbrc_draw_state(ring,
			A3XX_RB_RENDER_CONTROL_DISABLE_COLOR_PIPE |
			A3XX_RB_RENDER_CONTROL_ALPHA_TEST_FUNC(FUNC_NEVER));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RESOLVE_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(1));

	OUT_PKT0(ring, REG_A3XX_PC_PRIM_VTX_CNTL, 1);
	OUT_RING(ring, A3XX_PC_PRIM_VTX_CNTL_STRIDE_IN_VPC(0) |
			A3XX_PC_PRIM_VTX_CNTL_POLYMODE_FRONT_PTYPE(PC_DRAW_TRIANGLES) |
			A3XX_PC_PRIM_VTX_CNTL_POLYMODE_BACK_PTYPE(PC_DRAW_TRIANGLES) |
			A3XX_PC_PRIM_VTX_CNTL_PROVOKING_VTX_LAST);

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_WINDOW_SCISSOR_TL, 2);
	OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_TL_X(0) |
			A3XX_GRAS_SC_WINDOW_SCISSOR_TL_Y(0));
	OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_BR_X(pfb->width - 1) |
			A3XX_GRAS_SC_WINDOW_SCISSOR_BR_Y(pfb->height - 1));

	OUT_PKT0(ring, REG_A3XX_VFD_INDEX_MIN, 4);
	OUT_RING(ring, 0);            /* VFD_INDEX_MIN */
	OUT_RING(ring, 2);            /* VFD_INDEX_MAX */
	OUT_RING(ring, 0);            /* VFD_INSTANCEID_OFFSET */
	OUT_RING(ring, 0);            /* VFD_INDEX_OFFSET */

	fd3_program_emit(ring, &ctx->solid_prog);

	fd3_emit_vertex_bufs(ring, &ctx->solid_prog, (struct fd3_vertex_buf[]) {
			{ .prsc = fd3_ctx->solid_vbuf, .stride = 12, .format = PIPE_FORMAT_R32G32B32_FLOAT },
		}, 1);

	if (ctx->resolve & (FD_BUFFER_DEPTH | FD_BUFFER_STENCIL)) {
		uint32_t base = depth_base(&ctx->gmem) *
				fd_resource(pfb->cbufs[0]->texture)->cpp;
		emit_gmem2mem_surf(ring, RB_COPY_DEPTH_STENCIL, base, pfb->zsbuf);
	}

	if (ctx->resolve & FD_BUFFER_COLOR) {
		emit_gmem2mem_surf(ring, RB_COPY_RESOLVE, 0, pfb->cbufs[0]);
	}

	OUT_PKT0(ring, REG_A3XX_RB_MODE_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_MODE_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_RB_MODE_CONTROL_MARB_CACHE_SPLIT_MODE);

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(0));
}

/* transfer from system memory to gmem */

static void
emit_mem2gmem_surf(struct fd_ringbuffer *ring, uint32_t base,
		struct pipe_surface *psurf, uint32_t bin_w)
{
	emit_mrt(ring, 1, &psurf, &base, bin_w);

	fd3_emit_gmem_restore_tex(ring, psurf);

	OUT_PKT3(ring, CP_DRAW_INDX, 3);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, DRAW(DI_PT_RECTLIST, DI_SRC_SEL_AUTO_INDEX,
			INDEX_SIZE_IGN, IGNORE_VISIBILITY));
	OUT_RING(ring, 2);					/* NumIndices */
}

static void
fd3_emit_tile_mem2gmem(struct fd_context *ctx, uint32_t xoff, uint32_t yoff,
		uint32_t bin_w, uint32_t bin_h)
{
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	struct fd_gmem_stateobj *gmem = &ctx->gmem;
	struct fd_ringbuffer *ring = ctx->ring;
	struct pipe_framebuffer_state *pfb = &ctx->framebuffer;
	float x0, y0, x1, y1;
	unsigned i;

	/* write texture coordinates to vertexbuf: */
	x0 = ((float)xoff) / ((float)pfb->width);
	x1 = ((float)xoff + bin_w) / ((float)pfb->width);
	y0 = ((float)yoff) / ((float)pfb->height);
	y1 = ((float)yoff + bin_h) / ((float)pfb->height);

	OUT_PKT3(ring, CP_MEM_WRITE, 5);
	OUT_RELOC(ring, fd_resource(fd3_ctx->blit_texcoord_vbuf)->bo, 0, 0);
	OUT_RING(ring, fui(x0));
	OUT_RING(ring, fui(y0));
	OUT_RING(ring, fui(x1));
	OUT_RING(ring, fui(y1));

	for (i = 0; i < 4; i++) {
		OUT_PKT0(ring, REG_A3XX_RB_MRT_CONTROL(i), 1);
		OUT_RING(ring, A3XX_RB_MRT_CONTROL_ROP_CODE(12) |
				A3XX_RB_MRT_CONTROL_DITHER_MODE(DITHER_DISABLE) |
				A3XX_RB_MRT_CONTROL_COMPONENT_ENABLE(0xf));

		OUT_PKT0(ring, REG_A3XX_RB_MRT_BLEND_CONTROL(i), 1);
		OUT_RING(ring, A3XX_RB_MRT_BLEND_CONTROL_RGB_SRC_FACTOR(FACTOR_ONE) |
				A3XX_RB_MRT_BLEND_CONTROL_RGB_BLEND_OPCODE(BLEND_DST_PLUS_SRC) |
				A3XX_RB_MRT_BLEND_CONTROL_RGB_DEST_FACTOR(FACTOR_ZERO) |
				A3XX_RB_MRT_BLEND_CONTROL_ALPHA_SRC_FACTOR(FACTOR_ONE) |
				A3XX_RB_MRT_BLEND_CONTROL_ALPHA_BLEND_OPCODE(BLEND_DST_PLUS_SRC) |
				A3XX_RB_MRT_BLEND_CONTROL_ALPHA_DEST_FACTOR(FACTOR_ZERO) |
				A3XX_RB_MRT_BLEND_CONTROL_CLAMP_ENABLE);
	}

	fd3_emit_rbrc_tile_state(ring,
			A3XX_RB_RENDER_CONTROL_BIN_WIDTH(gmem->bin_w));

	OUT_PKT0(ring, REG_A3XX_RB_DEPTH_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_DEPTH_CONTROL_ZFUNC(FUNC_LESS));

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
	OUT_RING(ring, A3XX_GRAS_CL_CLIP_CNTL_IJ_PERSP_CENTER);   /* GRAS_CL_CLIP_CNTL */

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_VPORT_XOFFSET, 6);
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_XOFFSET((float)bin_w/2.0 - 0.5));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_XSCALE((float)bin_w/2.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_YOFFSET((float)bin_h/2.0 - 0.5));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_YSCALE(-(float)bin_h/2.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZOFFSET(0.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZSCALE(1.0));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_WINDOW_SCISSOR_TL, 2);
	OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_TL_X(0) |
			A3XX_GRAS_SC_WINDOW_SCISSOR_TL_Y(0));
	OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_BR_X(bin_w - 1) |
			A3XX_GRAS_SC_WINDOW_SCISSOR_BR_Y(bin_h - 1));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_SCREEN_SCISSOR_TL, 2);
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_TL_X(0) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_TL_Y(0));
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_BR_X(bin_w - 1) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_BR_Y(bin_h - 1));

	OUT_PKT0(ring, REG_A3XX_RB_STENCIL_CONTROL, 1);
	OUT_RING(ring, 0x2 |
			A3XX_RB_STENCIL_CONTROL_FUNC(FUNC_ALWAYS) |
			A3XX_RB_STENCIL_CONTROL_FAIL(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZPASS(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZFAIL(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_FUNC_BF(FUNC_ALWAYS) |
			A3XX_RB_STENCIL_CONTROL_FAIL_BF(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZPASS_BF(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZFAIL_BF(STENCIL_KEEP));

	fd3_emit_rbrc_draw_state(ring,
			A3XX_RB_RENDER_CONTROL_ALPHA_TEST_FUNC(FUNC_ALWAYS));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(1));

	OUT_PKT0(ring, REG_A3XX_PC_PRIM_VTX_CNTL, 1);
	OUT_RING(ring, A3XX_PC_PRIM_VTX_CNTL_STRIDE_IN_VPC(2) |
			A3XX_PC_PRIM_VTX_CNTL_POLYMODE_FRONT_PTYPE(PC_DRAW_TRIANGLES) |
			A3XX_PC_PRIM_VTX_CNTL_POLYMODE_BACK_PTYPE(PC_DRAW_TRIANGLES) |
			A3XX_PC_PRIM_VTX_CNTL_PROVOKING_VTX_LAST);

	OUT_PKT0(ring, REG_A3XX_VFD_INDEX_MIN, 4);
	OUT_RING(ring, 0);            /* VFD_INDEX_MIN */
	OUT_RING(ring, 2);            /* VFD_INDEX_MAX */
	OUT_RING(ring, 0);            /* VFD_INSTANCEID_OFFSET */
	OUT_RING(ring, 0);            /* VFD_INDEX_OFFSET */

	fd3_program_emit(ring, &ctx->blit_prog);

	fd3_emit_vertex_bufs(ring, &ctx->blit_prog, (struct fd3_vertex_buf[]) {
			{ .prsc = fd3_ctx->blit_texcoord_vbuf, .stride = 8, .format = PIPE_FORMAT_R32G32_FLOAT },
			{ .prsc = fd3_ctx->solid_vbuf, .stride = 12, .format = PIPE_FORMAT_R32G32B32_FLOAT },
		}, 2);

	/* for gmem pitch/base calculations, we need to use the non-
	 * truncated tile sizes:
	 */
	bin_w = gmem->bin_w;
	bin_h = gmem->bin_h;

	if (ctx->restore & (FD_BUFFER_DEPTH | FD_BUFFER_STENCIL))
		emit_mem2gmem_surf(ring, depth_base(gmem), pfb->zsbuf, bin_w);

	if (ctx->restore & FD_BUFFER_COLOR)
		emit_mem2gmem_surf(ring, 0, pfb->cbufs[0], bin_w);

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(0));
}

static void
update_vsc_pipe(struct fd_context *ctx)
{
	struct fd_ringbuffer *ring = ctx->ring;
	struct fd_gmem_stateobj *gmem = &ctx->gmem;
	struct fd_bo *bo = fd3_context(ctx)->vsc_pipe_mem;
	int i;

	/* since we aren't using binning, just try to assign all bins
	 * to same pipe for now:
	 */
	OUT_PKT0(ring, REG_A3XX_VSC_PIPE(0), 3);
	OUT_RING(ring, A3XX_VSC_PIPE_CONFIG_X(0) |
			A3XX_VSC_PIPE_CONFIG_Y(0) |
			A3XX_VSC_PIPE_CONFIG_W(gmem->nbins_x) |
			A3XX_VSC_PIPE_CONFIG_H(gmem->nbins_y));
	OUT_RELOC(ring, bo, 0, 0);              /* VSC_PIPE[0].DATA_ADDRESS */
	OUT_RING(ring, fd_bo_size(bo) - 32);    /* VSC_PIPE[0].DATA_LENGTH */

	for (i = 1; i < 8; i++) {
		OUT_PKT0(ring, REG_A3XX_VSC_PIPE(i), 3);
		OUT_RING(ring, A3XX_VSC_PIPE_CONFIG_X(0) |
				A3XX_VSC_PIPE_CONFIG_Y(0) |
				A3XX_VSC_PIPE_CONFIG_W(0) |
				A3XX_VSC_PIPE_CONFIG_H(0));
		OUT_RING(ring, 0x00000000);         /* VSC_PIPE[i].DATA_ADDRESS */
		OUT_RING(ring, 0x00000000);         /* VSC_PIPE[i].DATA_LENGTH */
	}
}

/* for rendering directly to system memory: */
static void
fd3_emit_sysmem_prep(struct fd_context *ctx)
{
	struct pipe_framebuffer_state *pfb = &ctx->framebuffer;
	struct fd_resource *rsc = fd_resource(pfb->cbufs[0]->texture);
	struct fd_ringbuffer *ring = ctx->ring;

	fd3_emit_restore(ctx);

	OUT_PKT0(ring, REG_A3XX_RB_WINDOW_SIZE, 1);
	OUT_RING(ring, A3XX_RB_WINDOW_SIZE_WIDTH(pfb->width) |
			A3XX_RB_WINDOW_SIZE_HEIGHT(pfb->height));

	emit_mrt(ring, pfb->nr_cbufs, pfb->cbufs, NULL, 0);

	fd3_emit_rbrc_tile_state(ring,
			A3XX_RB_RENDER_CONTROL_BIN_WIDTH(rsc->pitch));

	/* setup scissor/offset for current tile: */
	OUT_PKT0(ring, REG_A3XX_PA_SC_WINDOW_OFFSET, 1);
	OUT_RING(ring, A3XX_PA_SC_WINDOW_OFFSET_X(0) |
			A3XX_PA_SC_WINDOW_OFFSET_Y(0));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_SCREEN_SCISSOR_TL, 2);
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_TL_X(0) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_TL_Y(0));
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_BR_X(pfb->width - 1) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_BR_Y(pfb->height - 1));

	OUT_PKT0(ring, REG_A3XX_RB_MODE_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_MODE_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_RB_MODE_CONTROL_GMEM_BYPASS |
			A3XX_RB_MODE_CONTROL_MARB_CACHE_SPLIT_MODE);
}

/* before first tile */
static void
fd3_emit_tile_init(struct fd_context *ctx)
{
	struct fd_ringbuffer *ring = ctx->ring;
	struct fd_gmem_stateobj *gmem = &ctx->gmem;

	fd3_emit_restore(ctx);

	/* note: use gmem->bin_w/h, the bin_w/h parameters may be truncated
	 * at the right and bottom edge tiles
	 */
	OUT_PKT0(ring, REG_A3XX_VSC_BIN_SIZE, 1);
	OUT_RING(ring, A3XX_VSC_BIN_SIZE_WIDTH(gmem->bin_w) |
			A3XX_VSC_BIN_SIZE_HEIGHT(gmem->bin_h));

	/* TODO we only need to do this if gmem stateobj changes.. or in
	 * particular if the # of bins changes..
	 */
	update_vsc_pipe(ctx);
}

/* before mem2gmem */
static void
fd3_emit_tile_prep(struct fd_context *ctx, uint32_t xoff, uint32_t yoff,
		uint32_t bin_w, uint32_t bin_h)
{
	struct fd_ringbuffer *ring = ctx->ring;
	struct pipe_framebuffer_state *pfb = &ctx->framebuffer;
	struct fd_gmem_stateobj *gmem = &ctx->gmem;
	uint32_t reg;


	OUT_PKT0(ring, REG_A3XX_RB_DEPTH_INFO, 2);
	reg = A3XX_RB_DEPTH_INFO_DEPTH_BASE(depth_base(gmem));
	if (pfb->zsbuf) {
		reg |= A3XX_RB_DEPTH_INFO_DEPTH_FORMAT(fd_pipe2depth(pfb->zsbuf->format));
	}
	OUT_RING(ring, reg);
	if (pfb->zsbuf) {
		uint32_t cpp = util_format_get_blocksize(pfb->zsbuf->format);
		OUT_RING(ring, A3XX_RB_DEPTH_PITCH(cpp * gmem->bin_w));
	} else {
		OUT_RING(ring, 0x00000000);
	}

	OUT_PKT0(ring, REG_A3XX_RB_WINDOW_SIZE, 1);
	OUT_RING(ring, A3XX_RB_WINDOW_SIZE_WIDTH(pfb->width) |
			A3XX_RB_WINDOW_SIZE_HEIGHT(pfb->height));

	OUT_PKT0(ring, REG_A3XX_RB_MODE_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_MODE_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_RB_MODE_CONTROL_MARB_CACHE_SPLIT_MODE);
}

/* before IB to rendering cmds: */
static void
fd3_emit_tile_renderprep(struct fd_context *ctx, uint32_t xoff, uint32_t yoff,
		uint32_t bin_w, uint32_t bin_h)
{
	struct fd_ringbuffer *ring = ctx->ring;
	struct fd_gmem_stateobj *gmem = &ctx->gmem;
	struct pipe_framebuffer_state *pfb = &ctx->framebuffer;

	uint32_t x1 = xoff;
	uint32_t y1 = yoff;
	uint32_t x2 = xoff + bin_w - 1;
	uint32_t y2 = yoff + bin_h - 1;

	OUT_PKT3(ring, CP_SET_BIN, 3);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, CP_SET_BIN_1_X1(x1) | CP_SET_BIN_1_Y1(y1));
	OUT_RING(ring, CP_SET_BIN_2_X2(x2) | CP_SET_BIN_2_Y2(y2));

	emit_mrt(ring, pfb->nr_cbufs, pfb->cbufs, NULL, gmem->bin_w);

	fd3_emit_rbrc_tile_state(ring,
			A3XX_RB_RENDER_CONTROL_ENABLE_GMEM |
			A3XX_RB_RENDER_CONTROL_BIN_WIDTH(gmem->bin_w));

	/* setup scissor/offset for current tile: */
	OUT_PKT0(ring, REG_A3XX_PA_SC_WINDOW_OFFSET, 1);
	OUT_RING(ring, A3XX_PA_SC_WINDOW_OFFSET_X(xoff) |
			A3XX_PA_SC_WINDOW_OFFSET_Y(yoff));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_SCREEN_SCISSOR_TL, 2);
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_TL_X(x1) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_TL_Y(y1));
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_BR_X(x2) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_BR_Y(y2));
}

void
fd3_gmem_init(struct pipe_context *pctx)
{
	struct fd_context *ctx = fd_context(pctx);

	ctx->emit_sysmem_prep = fd3_emit_sysmem_prep;
	ctx->emit_tile_init = fd3_emit_tile_init;
	ctx->emit_tile_prep = fd3_emit_tile_prep;
	ctx->emit_tile_mem2gmem = fd3_emit_tile_mem2gmem;
	ctx->emit_tile_renderprep = fd3_emit_tile_renderprep;
	ctx->emit_tile_gmem2mem = fd3_emit_tile_gmem2mem;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.5
@
text
@d92 1
a92 1
			OUT_RELOCW(ring, res->bo, 0, 0, -1);
d119 1
a119 1
	OUT_RELOCW(ring, rsc->bo, 0, 0, -1);    /* RB_COPY_DEST_BASE */
a170 8
	OUT_PKT0(ring, REG_A3XX_GRAS_CL_VPORT_XOFFSET, 6);
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_XOFFSET((float)pfb->width/2.0 - 0.5));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_XSCALE((float)pfb->width/2.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_YOFFSET((float)pfb->height/2.0 - 0.5));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_YSCALE(-(float)pfb->height/2.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZOFFSET(0.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZSCALE(1.0));

d209 2
a210 6
		uint32_t base = 0;
		if (pfb->cbufs[0]) {
			struct fd_resource *rsc =
					fd_resource(pfb->cbufs[0]->texture);
			base = depth_base(&ctx->gmem) * rsc->cpp;
		}
d263 1
a263 1
	OUT_RELOC(ring, fd_resource(fd3_ctx->blit_texcoord_vbuf)->bo, 0, 0, 0);
d386 1
a386 1
	OUT_RELOC(ring, bo, 0, 0, 0);           /* VSC_PIPE[0].DATA_ADDRESS */
d405 1
a406 4
	uint32_t pitch = 0;

	if (pfb->cbufs[0])
		pitch = fd_resource(pfb->cbufs[0]->texture)->pitch;
d417 1
a417 1
			A3XX_RB_RENDER_CONTROL_BIN_WIDTH(pitch));
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a34 1
#include "freedreno_draw.h"
a44 5
static const struct fd3_shader_key key = {
		// XXX should set this based on render target format!  We don't
		// want half_precision if float32 render target!!!
		.half_precision = true,
};
d62 1
a62 2
		struct fd_resource *rsc = NULL;
		struct fd_resource_slice *slice = NULL;
d66 1
a66 1
		if ((i < nr_bufs) && bufs[i]) {
d69 1
a69 2
			rsc = fd_resource(psurf->texture);
			slice = &rsc->slices[psurf->u.tex.level];
d74 1
a74 1
				stride = bin_w * rsc->cpp;
d77 1
a77 1
					base = bases[i];
d80 1
a80 1
				stride = slice->pitch * rsc->cpp;
d92 1
a92 1
			OUT_RELOCW(ring, rsc->bo, slice->offset, 0, -1);
d101 1
a101 1
depth_base(struct fd_context *ctx)
d103 1
a103 183
	struct fd_gmem_stateobj *gmem = &ctx->gmem;
	struct pipe_framebuffer_state *pfb = &ctx->framebuffer;
	uint32_t cpp = 4;
	if (pfb->cbufs[0]) {
		struct fd_resource *rsc =
				fd_resource(pfb->cbufs[0]->texture);
		cpp = rsc->cpp;
	}
	return align(gmem->bin_w * gmem->bin_h * cpp, 0x4000);
}

static bool
use_hw_binning(struct fd_context *ctx)
{
	struct fd_gmem_stateobj *gmem = &ctx->gmem;

	/* workaround: combining scissor optimization and hw binning
	 * seems problematic.  Seems like we end up with a mismatch
	 * between binning pass and rendering pass, wrt. where the hw
	 * thinks the vertices belong.  And the blob driver doesn't
	 * seem to implement anything like scissor optimization, so
	 * not entirely sure what I might be missing.
	 *
	 * But scissor optimization is mainly for window managers,
	 * which don't have many vertices (and therefore doesn't
	 * benefit much from binning pass).
	 *
	 * So for now just disable binning if scissor optimization is
	 * used.
	 */
	if (gmem->minx || gmem->miny)
		return false;

	return fd_binning_enabled && ((gmem->nbins_x * gmem->nbins_y) > 2);
}

/* workaround for (hlsq?) lockup with hw binning on a3xx patchlevel 0 */
static void update_vsc_pipe(struct fd_context *ctx);
static void
emit_binning_workaround(struct fd_context *ctx)
{
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	struct fd_gmem_stateobj *gmem = &ctx->gmem;
	struct fd_ringbuffer *ring = ctx->ring;

	OUT_PKT0(ring, REG_A3XX_RB_MODE_CONTROL, 2);
	OUT_RING(ring, A3XX_RB_MODE_CONTROL_RENDER_MODE(RB_RESOLVE_PASS) |
			A3XX_RB_MODE_CONTROL_MARB_CACHE_SPLIT_MODE);
	OUT_RING(ring, A3XX_RB_RENDER_CONTROL_BIN_WIDTH(32) |
			A3XX_RB_RENDER_CONTROL_DISABLE_COLOR_PIPE |
			A3XX_RB_RENDER_CONTROL_ALPHA_TEST_FUNC(FUNC_NEVER));

	OUT_PKT0(ring, REG_A3XX_RB_COPY_CONTROL, 4);
	OUT_RING(ring, A3XX_RB_COPY_CONTROL_MSAA_RESOLVE(MSAA_ONE) |
			A3XX_RB_COPY_CONTROL_MODE(0) |
			A3XX_RB_COPY_CONTROL_GMEM_BASE(0));
	OUT_RELOCW(ring, fd_resource(fd3_ctx->solid_vbuf)->bo, 0x20, 0, -1);  /* RB_COPY_DEST_BASE */
	OUT_RING(ring, A3XX_RB_COPY_DEST_PITCH_PITCH(128));
	OUT_RING(ring, A3XX_RB_COPY_DEST_INFO_TILE(LINEAR) |
			A3XX_RB_COPY_DEST_INFO_FORMAT(RB_R8G8B8A8_UNORM) |
			A3XX_RB_COPY_DEST_INFO_SWAP(WZYX) |
			A3XX_RB_COPY_DEST_INFO_COMPONENT_ENABLE(0xf) |
			A3XX_RB_COPY_DEST_INFO_ENDIAN(ENDIAN_NONE));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RESOLVE_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(1));

	fd_wfi(ctx, ring);
	fd3_program_emit(ring, &ctx->solid_prog, key);
	fd3_emit_vertex_bufs(ring, fd3_shader_variant(ctx->solid_prog.vp, key),
			(struct fd3_vertex_buf[]) {{
				.prsc = fd3_ctx->solid_vbuf,
				.stride = 12,
				.format = PIPE_FORMAT_R32G32B32_FLOAT,
			}}, 1);

	OUT_PKT0(ring, REG_A3XX_HLSQ_CONTROL_0_REG, 4);
	OUT_RING(ring, A3XX_HLSQ_CONTROL_0_REG_FSTHREADSIZE(FOUR_QUADS) |
			A3XX_HLSQ_CONTROL_0_REG_FSSUPERTHREADENABLE |
			A3XX_HLSQ_CONTROL_0_REG_RESERVED2 |
			A3XX_HLSQ_CONTROL_0_REG_SPCONSTFULLUPDATE);
	OUT_RING(ring, A3XX_HLSQ_CONTROL_1_REG_VSTHREADSIZE(TWO_QUADS) |
			A3XX_HLSQ_CONTROL_1_REG_VSSUPERTHREADENABLE);
	OUT_RING(ring, A3XX_HLSQ_CONTROL_2_REG_PRIMALLOCTHRESHOLD(31));
	OUT_RING(ring, 0); /* HLSQ_CONTROL_3_REG */

	OUT_PKT0(ring, REG_A3XX_HLSQ_CONST_FSPRESV_RANGE_REG, 1);
	OUT_RING(ring, A3XX_HLSQ_CONST_FSPRESV_RANGE_REG_STARTENTRY(0x20) |
			A3XX_HLSQ_CONST_FSPRESV_RANGE_REG_ENDENTRY(0x20));

	OUT_PKT0(ring, REG_A3XX_RB_MSAA_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_MSAA_CONTROL_DISABLE |
			A3XX_RB_MSAA_CONTROL_SAMPLES(MSAA_ONE) |
			A3XX_RB_MSAA_CONTROL_SAMPLE_MASK(0xffff));

	OUT_PKT0(ring, REG_A3XX_RB_DEPTH_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_DEPTH_CONTROL_ZFUNC(FUNC_NEVER));

	OUT_PKT0(ring, REG_A3XX_RB_STENCIL_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_STENCIL_CONTROL_FUNC(FUNC_NEVER) |
			A3XX_RB_STENCIL_CONTROL_FAIL(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZPASS(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZFAIL(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_FUNC_BF(FUNC_NEVER) |
			A3XX_RB_STENCIL_CONTROL_FAIL_BF(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZPASS_BF(STENCIL_KEEP) |
			A3XX_RB_STENCIL_CONTROL_ZFAIL_BF(STENCIL_KEEP));

	OUT_PKT0(ring, REG_A3XX_GRAS_SU_MODE_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SU_MODE_CONTROL_LINEHALFWIDTH(0.0));

	OUT_PKT0(ring, REG_A3XX_VFD_INDEX_MIN, 4);
	OUT_RING(ring, 0);            /* VFD_INDEX_MIN */
	OUT_RING(ring, 2);            /* VFD_INDEX_MAX */
	OUT_RING(ring, 0);            /* VFD_INSTANCEID_OFFSET */
	OUT_RING(ring, 0);            /* VFD_INDEX_OFFSET */

	OUT_PKT0(ring, REG_A3XX_PC_PRIM_VTX_CNTL, 1);
	OUT_RING(ring, A3XX_PC_PRIM_VTX_CNTL_STRIDE_IN_VPC(0) |
			A3XX_PC_PRIM_VTX_CNTL_POLYMODE_FRONT_PTYPE(PC_DRAW_TRIANGLES) |
			A3XX_PC_PRIM_VTX_CNTL_POLYMODE_BACK_PTYPE(PC_DRAW_TRIANGLES) |
			A3XX_PC_PRIM_VTX_CNTL_PROVOKING_VTX_LAST);

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_WINDOW_SCISSOR_TL, 2);
	OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_TL_X(0) |
			A3XX_GRAS_SC_WINDOW_SCISSOR_TL_Y(1));
	OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_BR_X(0) |
			A3XX_GRAS_SC_WINDOW_SCISSOR_BR_Y(1));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_SCREEN_SCISSOR_TL, 2);
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_TL_X(0) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_TL_Y(0));
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_BR_X(31) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_BR_Y(0));

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_VPORT_XOFFSET, 6);
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_XOFFSET(0.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_XSCALE(1.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_YOFFSET(0.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_YSCALE(1.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZOFFSET(0.0));
	OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZSCALE(1.0));

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
	OUT_RING(ring, A3XX_GRAS_CL_CLIP_CNTL_CLIP_DISABLE |
			A3XX_GRAS_CL_CLIP_CNTL_ZFAR_CLIP_DISABLE |
			A3XX_GRAS_CL_CLIP_CNTL_VP_CLIP_CODE_IGNORE |
			A3XX_GRAS_CL_CLIP_CNTL_VP_XFORM_DISABLE |
			A3XX_GRAS_CL_CLIP_CNTL_PERSP_DIVISION_DISABLE);

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_GB_CLIP_ADJ, 1);
	OUT_RING(ring, A3XX_GRAS_CL_GB_CLIP_ADJ_HORZ(0) |
			A3XX_GRAS_CL_GB_CLIP_ADJ_VERT(0));

	OUT_PKT3(ring, CP_DRAW_INDX_2, 5);
	OUT_RING(ring, 0x00000000);   /* viz query info. */
	OUT_RING(ring, DRAW(DI_PT_RECTLIST, DI_SRC_SEL_IMMEDIATE,
			INDEX_SIZE_32_BIT, IGNORE_VISIBILITY));
	OUT_RING(ring, 2);            /* NumIndices */
	OUT_RING(ring, 2);
	OUT_RING(ring, 1);
	fd_reset_wfi(ctx);

	OUT_PKT0(ring, REG_A3XX_HLSQ_CONTROL_0_REG, 1);
	OUT_RING(ring, A3XX_HLSQ_CONTROL_0_REG_FSTHREADSIZE(TWO_QUADS));

	OUT_PKT0(ring, REG_A3XX_VFD_PERFCOUNTER0_SELECT, 1);
	OUT_RING(ring, 0x00000000);

	fd_wfi(ctx, ring);
	OUT_PKT0(ring, REG_A3XX_VSC_BIN_SIZE, 1);
	OUT_RING(ring, A3XX_VSC_BIN_SIZE_WIDTH(gmem->bin_w) |
			A3XX_VSC_BIN_SIZE_HEIGHT(gmem->bin_h));

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(0));

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
	OUT_RING(ring, 0x00000000);
d109 1
a109 1
emit_gmem2mem_surf(struct fd_context *ctx,
a112 1
	struct fd_ringbuffer *ring = ctx->ring;
a113 1
	struct fd_resource_slice *slice = &rsc->slices[psurf->u.tex.level];
d119 2
a120 2
	OUT_RELOCW(ring, rsc->bo, slice->offset, 0, -1);    /* RB_COPY_DEST_BASE */
	OUT_RING(ring, A3XX_RB_COPY_DEST_PITCH_PITCH(slice->pitch * rsc->cpp));
d127 5
a131 2
	fd_draw(ctx, ring, DI_PT_RECTLIST, IGNORE_VISIBILITY,
			DI_SRC_SEL_AUTO_INDEX, 2, INDEX_SIZE_IGN, 0, 0, NULL);
d135 2
a136 1
fd3_emit_tile_gmem2mem(struct fd_context *ctx, struct fd_tile *tile)
d183 3
a185 5
	OUT_PKT0(ring, REG_A3XX_RB_RENDER_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_RENDER_CONTROL_DISABLE_COLOR_PIPE |
			A3XX_RB_RENDER_CONTROL_ENABLE_GMEM |
			A3XX_RB_RENDER_CONTROL_ALPHA_TEST_FUNC(FUNC_NEVER) |
			A3XX_RB_RENDER_CONTROL_BIN_WIDTH(ctx->gmem.bin_w));
d210 5
a214 8
	fd_wfi(ctx, ring);
	fd3_program_emit(ring, &ctx->solid_prog, key);
	fd3_emit_vertex_bufs(ring, fd3_shader_variant(ctx->solid_prog.vp, key),
			(struct fd3_vertex_buf[]) {{
				.prsc = fd3_ctx->solid_vbuf,
				.stride = 12,
				.format = PIPE_FORMAT_R32G32B32_FLOAT,
			}}, 1);
d217 7
a223 2
		uint32_t base = depth_base(ctx);
		emit_gmem2mem_surf(ctx, RB_COPY_DEPTH_STENCIL, base, pfb->zsbuf);
d227 1
a227 1
		emit_gmem2mem_surf(ctx, RB_COPY_RESOLVE, 0, pfb->cbufs[0]);
d243 1
a243 1
emit_mem2gmem_surf(struct fd_context *ctx, uint32_t base,
a245 2
	struct fd_ringbuffer *ring = ctx->ring;

a247 1
	fd_wfi(ctx, ring);
d250 5
a254 2
	fd_draw(ctx, ring, DI_PT_RECTLIST, IGNORE_VISIBILITY,
			DI_SRC_SEL_AUTO_INDEX, 2, INDEX_SIZE_IGN, 0, 0, NULL);
d258 2
a259 1
fd3_emit_tile_mem2gmem(struct fd_context *ctx, struct fd_tile *tile)
a265 2
	unsigned bin_w = tile->bin_w;
	unsigned bin_h = tile->bin_h;
d269 4
a272 4
	x0 = ((float)tile->xoff) / ((float)pfb->width);
	x1 = ((float)tile->xoff + bin_w) / ((float)pfb->width);
	y0 = ((float)tile->yoff) / ((float)pfb->height);
	y1 = ((float)tile->yoff + bin_h) / ((float)pfb->height);
d275 1
a275 1
	OUT_RELOCW(ring, fd_resource(fd3_ctx->blit_texcoord_vbuf)->bo, 0, 0, 0);
d283 1
a283 1
		OUT_RING(ring, A3XX_RB_MRT_CONTROL_ROP_CODE(ROP_COPY) |
d297 1
a297 2
	OUT_PKT0(ring, REG_A3XX_RB_RENDER_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_RENDER_CONTROL_ALPHA_TEST_FUNC(FUNC_ALWAYS) |
d337 3
d357 6
a362 12
	fd_wfi(ctx, ring);
	fd3_program_emit(ring, &ctx->blit_prog, key);
	fd3_emit_vertex_bufs(ring, fd3_shader_variant(ctx->blit_prog.vp, key),
			(struct fd3_vertex_buf[]) {{
				.prsc = fd3_ctx->blit_texcoord_vbuf,
				.stride = 8,
				.format = PIPE_FORMAT_R32G32_FLOAT,
			}, {
				.prsc = fd3_ctx->solid_vbuf,
				.stride = 12,
				.format = PIPE_FORMAT_R32G32B32_FLOAT,
			}}, 2);
d371 1
a371 1
		emit_mem2gmem_surf(ctx, depth_base(ctx), pfb->zsbuf, bin_w);
d374 1
a374 1
		emit_mem2gmem_surf(ctx, 0, pfb->cbufs[0], bin_w);
d383 1
a383 1
patch_draws(struct fd_context *ctx, enum pc_di_vis_cull_mode vismode)
d385 15
a399 7
	unsigned i;
	for (i = 0; i < fd_patch_num_elements(&ctx->draw_patches); i++) {
		struct fd_cs_patch *patch = fd_patch_element(&ctx->draw_patches, i);
		*patch->cs = patch->val | DRAW(0, 0, 0, vismode);
	}
	util_dynarray_resize(&ctx->draw_patches, 0);
}
d401 8
a408 8
static void
patch_rbrc(struct fd_context *ctx, uint32_t val)
{
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	unsigned i;
	for (i = 0; i < fd_patch_num_elements(&fd3_ctx->rbrc_patches); i++) {
		struct fd_cs_patch *patch = fd_patch_element(&fd3_ctx->rbrc_patches, i);
		*patch->cs = patch->val | val;
a409 1
	util_dynarray_resize(&fd3_ctx->rbrc_patches, 0);
d421 1
a421 1
		pitch = fd_resource(pfb->cbufs[0]->texture)->slices[0].pitch;
d425 3
a427 3
	OUT_PKT0(ring, REG_A3XX_RB_FRAME_BUFFER_DIMENSION, 1);
	OUT_RING(ring, A3XX_RB_FRAME_BUFFER_DIMENSION_WIDTH(pfb->width) |
			A3XX_RB_FRAME_BUFFER_DIMENSION_HEIGHT(pfb->height));
d431 3
d435 3
a437 3
	OUT_PKT0(ring, REG_A3XX_RB_WINDOW_OFFSET, 1);
	OUT_RING(ring, A3XX_RB_WINDOW_OFFSET_X(0) |
			A3XX_RB_WINDOW_OFFSET_Y(0));
a448 155

	patch_draws(ctx, IGNORE_VISIBILITY);
	patch_rbrc(ctx, A3XX_RB_RENDER_CONTROL_BIN_WIDTH(pitch));
}

static void
update_vsc_pipe(struct fd_context *ctx)
{
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	struct fd_ringbuffer *ring = ctx->ring;
	int i;

	OUT_PKT0(ring, REG_A3XX_VSC_SIZE_ADDRESS, 1);
	OUT_RELOCW(ring, fd3_ctx->vsc_size_mem, 0, 0, 0); /* VSC_SIZE_ADDRESS */

	for (i = 0; i < 8; i++) {
		struct fd_vsc_pipe *pipe = &ctx->pipe[i];

		if (!pipe->bo) {
			pipe->bo = fd_bo_new(ctx->dev, 0x40000,
					DRM_FREEDRENO_GEM_TYPE_KMEM);
		}

		OUT_PKT0(ring, REG_A3XX_VSC_PIPE(i), 3);
		OUT_RING(ring, A3XX_VSC_PIPE_CONFIG_X(pipe->x) |
				A3XX_VSC_PIPE_CONFIG_Y(pipe->y) |
				A3XX_VSC_PIPE_CONFIG_W(pipe->w) |
				A3XX_VSC_PIPE_CONFIG_H(pipe->h));
		OUT_RELOCW(ring, pipe->bo, 0, 0, 0);       /* VSC_PIPE[i].DATA_ADDRESS */
		OUT_RING(ring, fd_bo_size(pipe->bo) - 32); /* VSC_PIPE[i].DATA_LENGTH */
	}
}

static void
emit_binning_pass(struct fd_context *ctx)
{
	struct fd_gmem_stateobj *gmem = &ctx->gmem;
	struct pipe_framebuffer_state *pfb = &ctx->framebuffer;
	struct fd_ringbuffer *ring = ctx->ring;
	int i;

	uint32_t x1 = gmem->minx;
	uint32_t y1 = gmem->miny;
	uint32_t x2 = gmem->minx + gmem->width - 1;
	uint32_t y2 = gmem->miny + gmem->height - 1;

	if (ctx->screen->gpu_id == 320) {
		emit_binning_workaround(ctx);

		OUT_PKT3(ring, CP_INVALIDATE_STATE, 1);
		OUT_RING(ring, 0x00007fff);
	}

	OUT_PKT0(ring, REG_A3XX_VSC_BIN_CONTROL, 1);
	OUT_RING(ring, A3XX_VSC_BIN_CONTROL_BINNING_ENABLE);

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_TILING_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(0));

	OUT_PKT0(ring, REG_A3XX_RB_FRAME_BUFFER_DIMENSION, 1);
	OUT_RING(ring, A3XX_RB_FRAME_BUFFER_DIMENSION_WIDTH(pfb->width) |
			A3XX_RB_FRAME_BUFFER_DIMENSION_HEIGHT(pfb->height));

	OUT_PKT0(ring, REG_A3XX_RB_RENDER_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_RENDER_CONTROL_ALPHA_TEST_FUNC(FUNC_NEVER) |
			A3XX_RB_RENDER_CONTROL_DISABLE_COLOR_PIPE |
			A3XX_RB_RENDER_CONTROL_BIN_WIDTH(gmem->bin_w));

	/* setup scissor/offset for whole screen: */
	OUT_PKT0(ring, REG_A3XX_RB_WINDOW_OFFSET, 1);
	OUT_RING(ring, A3XX_RB_WINDOW_OFFSET_X(x1) |
			A3XX_RB_WINDOW_OFFSET_Y(y1));

	OUT_PKT0(ring, REG_A3XX_RB_LRZ_VSC_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_LRZ_VSC_CONTROL_BINNING_ENABLE);

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_SCREEN_SCISSOR_TL, 2);
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_TL_X(x1) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_TL_Y(y1));
	OUT_RING(ring, A3XX_GRAS_SC_SCREEN_SCISSOR_BR_X(x2) |
			A3XX_GRAS_SC_SCREEN_SCISSOR_BR_Y(y2));

	OUT_PKT0(ring, REG_A3XX_RB_MODE_CONTROL, 1);
	OUT_RING(ring, A3XX_RB_MODE_CONTROL_RENDER_MODE(RB_TILING_PASS) |
			A3XX_RB_MODE_CONTROL_MARB_CACHE_SPLIT_MODE);

	for (i = 0; i < 4; i++) {
		OUT_PKT0(ring, REG_A3XX_RB_MRT_CONTROL(i), 1);
		OUT_RING(ring, A3XX_RB_MRT_CONTROL_ROP_CODE(ROP_CLEAR) |
				A3XX_RB_MRT_CONTROL_DITHER_MODE(DITHER_DISABLE) |
				A3XX_RB_MRT_CONTROL_COMPONENT_ENABLE(0));
	}

	OUT_PKT0(ring, REG_A3XX_PC_VSTREAM_CONTROL, 1);
	OUT_RING(ring, A3XX_PC_VSTREAM_CONTROL_SIZE(1) |
			A3XX_PC_VSTREAM_CONTROL_N(0));

	/* emit IB to binning drawcmds: */
	OUT_IB(ring, ctx->binning_start, ctx->binning_end);
	fd_reset_wfi(ctx);

	fd_wfi(ctx, ring);

	/* and then put stuff back the way it was: */

	OUT_PKT0(ring, REG_A3XX_VSC_BIN_CONTROL, 1);
	OUT_RING(ring, 0x00000000);

	OUT_PKT0(ring, REG_A3XX_SP_SP_CTRL_REG, 1);
	OUT_RING(ring, A3XX_SP_SP_CTRL_REG_RESOLVE |
			A3XX_SP_SP_CTRL_REG_CONSTMODE(1) |
			A3XX_SP_SP_CTRL_REG_SLEEPMODE(1) |
			A3XX_SP_SP_CTRL_REG_L0MODE(0));

	OUT_PKT0(ring, REG_A3XX_RB_LRZ_VSC_CONTROL, 1);
	OUT_RING(ring, 0x00000000);

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(0));

	OUT_PKT0(ring, REG_A3XX_RB_MODE_CONTROL, 2);
	OUT_RING(ring, A3XX_RB_MODE_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_RB_MODE_CONTROL_MARB_CACHE_SPLIT_MODE);
	OUT_RING(ring, A3XX_RB_RENDER_CONTROL_ENABLE_GMEM |
			A3XX_RB_RENDER_CONTROL_ALPHA_TEST_FUNC(FUNC_NEVER) |
			A3XX_RB_RENDER_CONTROL_BIN_WIDTH(gmem->bin_w));

	OUT_PKT3(ring, CP_EVENT_WRITE, 1);
	OUT_RING(ring, CACHE_FLUSH);

	if (ctx->screen->gpu_id == 320) {
		/* dummy-draw workaround: */
		OUT_PKT3(ring, CP_DRAW_INDX, 3);
		OUT_RING(ring, 0x00000000);
		OUT_RING(ring, DRAW(1, DI_SRC_SEL_AUTO_INDEX,
				INDEX_SIZE_IGN, IGNORE_VISIBILITY));
		OUT_RING(ring, 0);             /* NumIndices */
		fd_reset_wfi(ctx);
	}

	OUT_PKT3(ring, CP_NOP, 4);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);

	fd_wfi(ctx, ring);

	if (ctx->screen->gpu_id == 320) {
		emit_binning_workaround(ctx);
	}
a456 1
	uint32_t rb_render_control;
d467 3
a470 17

	if (use_hw_binning(ctx)) {
		/* mark the end of the binning cmds: */
		fd_ringmarker_mark(ctx->binning_end);

		/* emit hw binning pass: */
		emit_binning_pass(ctx);

		patch_draws(ctx, USE_VISIBILITY);
	} else {
		patch_draws(ctx, IGNORE_VISIBILITY);
	}

	rb_render_control = A3XX_RB_RENDER_CONTROL_ENABLE_GMEM |
			A3XX_RB_RENDER_CONTROL_BIN_WIDTH(gmem->bin_w);

	patch_rbrc(ctx, rb_render_control);
d475 2
a476 1
fd3_emit_tile_prep(struct fd_context *ctx, struct fd_tile *tile)
d483 1
d485 1
a485 1
	reg = A3XX_RB_DEPTH_INFO_DEPTH_BASE(depth_base(ctx));
d497 3
a499 7
	if (ctx->needs_rb_fbd) {
		fd_wfi(ctx, ring);
		OUT_PKT0(ring, REG_A3XX_RB_FRAME_BUFFER_DIMENSION, 1);
		OUT_RING(ring, A3XX_RB_FRAME_BUFFER_DIMENSION_WIDTH(pfb->width) |
				A3XX_RB_FRAME_BUFFER_DIMENSION_HEIGHT(pfb->height));
		ctx->needs_rb_fbd = false;
	}
d508 2
a509 1
fd3_emit_tile_renderprep(struct fd_context *ctx, struct fd_tile *tile)
a510 1
	struct fd3_context *fd3_ctx = fd3_context(ctx);
d515 4
a518 30
	uint32_t x1 = tile->xoff;
	uint32_t y1 = tile->yoff;
	uint32_t x2 = tile->xoff + tile->bin_w - 1;
	uint32_t y2 = tile->yoff + tile->bin_h - 1;

	if (use_hw_binning(ctx)) {
		struct fd_vsc_pipe *pipe = &ctx->pipe[tile->p];

		assert(pipe->w * pipe->h);

		OUT_PKT3(ring, CP_EVENT_WRITE, 1);
		OUT_RING(ring, HLSQ_FLUSH);

		OUT_WFI(ring);

		OUT_PKT0(ring, REG_A3XX_PC_VSTREAM_CONTROL, 1);
		OUT_RING(ring, A3XX_PC_VSTREAM_CONTROL_SIZE(pipe->w * pipe->h) |
				A3XX_PC_VSTREAM_CONTROL_N(tile->n));

		OUT_PKT3(ring, CP_EVENT_WRITE, 1);
		OUT_RING(ring, CACHE_FLUSH);

		OUT_PKT3(ring, CP_SET_BIN_DATA, 2);
		OUT_RELOC(ring, pipe->bo, 0, 0, 0);    /* BIN_DATA_ADDR <- VSC_PIPE[p].DATA_ADDRESS */
		OUT_RELOC(ring, fd3_ctx->vsc_size_mem, /* BIN_SIZE_ADDR <- VSC_SIZE_ADDRESS + (p * 4) */
				(tile->p * 4), 0, 0);
	} else {
		OUT_PKT0(ring, REG_A3XX_PC_VSTREAM_CONTROL, 1);
		OUT_RING(ring, 0x00000000);
	}
d527 4
d532 3
a534 3
	OUT_PKT0(ring, REG_A3XX_RB_WINDOW_OFFSET, 1);
	OUT_RING(ring, A3XX_RB_WINDOW_OFFSET_X(tile->xoff) |
			A3XX_RB_WINDOW_OFFSET_Y(tile->yoff));
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d46 1
a46 1
static const struct ir3_shader_key key = {
a71 1
		uint32_t layer_offset = 0;
a80 4
			debug_assert(psurf->u.tex.first_layer == psurf->u.tex.last_layer);

			layer_offset = slice->size0 * psurf->u.tex.first_layer;

d100 1
a100 2
			OUT_RELOCW(ring, rsc->bo,
					slice->offset + layer_offset, 0, -1);
a154 5
	struct fd3_emit emit = {
			.vtx = &fd3_ctx->solid_vbuf_state,
			.prog = &ctx->solid_prog,
			.key = key,
	};
d180 8
a187 2
	fd3_program_emit(ring, &emit);
	fd3_emit_vertex_bufs(ring, &emit);
a247 1
	fd_wfi(ctx, ring);
a305 3
	uint32_t layer_offset = slice->size0 * psurf->u.tex.first_layer;

	debug_assert(psurf->u.tex.first_layer == psurf->u.tex.last_layer);
d311 1
a311 2

	OUT_RELOCW(ring, rsc->bo, slice->offset + layer_offset, 0, -1);    /* RB_COPY_DEST_BASE */
a328 5
	struct fd3_emit emit = {
			.vtx = &fd3_ctx->solid_vbuf_state,
			.prog = &ctx->solid_prog,
			.key = key,
	};
a358 1
	fd_wfi(ctx, ring);
d400 8
a407 2
	fd3_program_emit(ring, &emit);
	fd3_emit_vertex_bufs(ring, &emit);
d438 1
a451 5
	struct fd3_emit emit = {
			.vtx = &fd3_ctx->blit_vbuf_state,
			.prog = &ctx->blit_prog,
			.key = key,
	};
a489 1
	fd_wfi(ctx, ring);
a495 1
	fd_wfi(ctx, ring);
d544 12
a555 2
	fd3_program_emit(ring, &emit);
	fd3_emit_vertex_bufs(ring, &emit);
d563 1
a563 1
	if (fd_gmem_needs_restore(ctx, tile, FD_BUFFER_DEPTH | FD_BUFFER_STENCIL))
d566 1
a566 1
	if (fd_gmem_needs_restore(ctx, tile, FD_BUFFER_COLOR))
d606 2
a607 5
	if (pfb->cbufs[0]) {
		struct pipe_surface *psurf = pfb->cbufs[0];
		unsigned lvl = psurf->u.tex.level;
		pitch = fd_resource(psurf->texture)->slices[lvl].pitch;
	}
d680 1
a680 1
		fd_wfi(ctx, ring);
d763 2
a764 2
	fd_event_write(ctx, ring, CACHE_FLUSH);
	fd_wfi(ctx, ring);
d880 4
a883 2
		fd_event_write(ctx, ring, HLSQ_FLUSH);
		fd_wfi(ctx, ring);
d889 2
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d46 1
a46 1
static const struct fd3_shader_key key = {
d72 1
d82 4
d105 2
a106 1
			OUT_RELOCW(ring, rsc->bo, slice->offset, 0, -1);
d161 5
d191 2
a192 8
	fd_wfi(ctx, ring);
	fd3_program_emit(ring, &ctx->solid_prog, key);
	fd3_emit_vertex_bufs(ring, fd3_shader_variant(ctx->solid_prog.vp, key),
			(struct fd3_vertex_buf[]) {{
				.prsc = fd3_ctx->solid_vbuf,
				.stride = 12,
				.format = PIPE_FORMAT_R32G32B32_FLOAT,
			}}, 1);
d253 1
d312 3
d320 2
a321 1
	OUT_RELOCW(ring, rsc->bo, slice->offset, 0, -1);    /* RB_COPY_DEST_BASE */
d339 5
d374 1
d416 2
a417 8
	fd_wfi(ctx, ring);
	fd3_program_emit(ring, &ctx->solid_prog, key);
	fd3_emit_vertex_bufs(ring, fd3_shader_variant(ctx->solid_prog.vp, key),
			(struct fd3_vertex_buf[]) {{
				.prsc = fd3_ctx->solid_vbuf,
				.stride = 12,
				.format = PIPE_FORMAT_R32G32B32_FLOAT,
			}}, 1);
a447 1
	fd_wfi(ctx, ring);
d461 5
d504 1
d511 1
d560 2
a561 12
	fd_wfi(ctx, ring);
	fd3_program_emit(ring, &ctx->blit_prog, key);
	fd3_emit_vertex_bufs(ring, fd3_shader_variant(ctx->blit_prog.vp, key),
			(struct fd3_vertex_buf[]) {{
				.prsc = fd3_ctx->blit_texcoord_vbuf,
				.stride = 8,
				.format = PIPE_FORMAT_R32G32_FLOAT,
			}, {
				.prsc = fd3_ctx->solid_vbuf,
				.stride = 12,
				.format = PIPE_FORMAT_R32G32B32_FLOAT,
			}}, 2);
d569 1
a569 1
	if (ctx->restore & (FD_BUFFER_DEPTH | FD_BUFFER_STENCIL))
d572 1
a572 1
	if (ctx->restore & FD_BUFFER_COLOR)
d612 5
a616 2
	if (pfb->cbufs[0])
		pitch = fd_resource(pfb->cbufs[0]->texture)->slices[0].pitch;
d689 1
a689 1

d772 2
a773 2
	OUT_PKT3(ring, CP_EVENT_WRITE, 1);
	OUT_RING(ring, CACHE_FLUSH);
d889 2
a890 4
		OUT_PKT3(ring, CP_EVENT_WRITE, 1);
		OUT_RING(ring, HLSQ_FLUSH);

		OUT_WFI(ring);
a895 2
		OUT_PKT3(ring, CP_EVENT_WRITE, 1);
		OUT_RING(ring, CACHE_FLUSH);
@


