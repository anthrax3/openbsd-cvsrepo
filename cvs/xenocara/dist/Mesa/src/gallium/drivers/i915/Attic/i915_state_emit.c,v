head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.13;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.10;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.52;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


#include "i915_reg.h"
#include "i915_context.h"
#include "i915_batch.h"
#include "i915_debug.h"
#include "i915_fpc.h"
#include "i915_resource.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "pipe/p_format.h"

#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"

struct i915_tracked_hw_state {
   const char *name;
   void (*validate)(struct i915_context *, unsigned *batch_space);
   void (*emit)(struct i915_context *);
   unsigned dirty, batch_space;
};


static void
validate_flush(struct i915_context *i915, unsigned *batch_space)
{
   *batch_space = i915->flush_dirty ? 1 : 0;
}

static void
emit_flush(struct i915_context *i915)
{
   /* Cache handling is very cheap atm. State handling can request to flushes:
    * - I915_FLUSH_CACHE which is a flush everything request and
    * - I915_PIPELINE_FLUSH which is specifically for the draw_offset flush.
    * Because the cache handling is so dumb, no explicit "invalidate map cache".
    * Also, the first is a strict superset of the latter, so the following logic
    * works. */
   if (i915->flush_dirty & I915_FLUSH_CACHE)
      OUT_BATCH(MI_FLUSH | FLUSH_MAP_CACHE);
   else if (i915->flush_dirty & I915_PIPELINE_FLUSH)
      OUT_BATCH(MI_FLUSH | INHIBIT_FLUSH_RENDER_CACHE);
}

uint32_t invariant_state[] = {
   _3DSTATE_AA_CMD | AA_LINE_ECAAR_WIDTH_ENABLE | AA_LINE_ECAAR_WIDTH_1_0 |
             AA_LINE_REGION_WIDTH_ENABLE | AA_LINE_REGION_WIDTH_1_0,

   _3DSTATE_DFLT_DIFFUSE_CMD, 0,

   _3DSTATE_DFLT_SPEC_CMD, 0,

   _3DSTATE_DFLT_Z_CMD, 0,

   _3DSTATE_COORD_SET_BINDINGS |
             CSB_TCB(0, 0) |
             CSB_TCB(1, 1) |
             CSB_TCB(2, 2) |
             CSB_TCB(3, 3) |
             CSB_TCB(4, 4) |
             CSB_TCB(5, 5) |
             CSB_TCB(6, 6) |
             CSB_TCB(7, 7),

   _3DSTATE_RASTER_RULES_CMD |
             ENABLE_POINT_RASTER_RULE |
             OGL_POINT_RASTER_RULE |
             ENABLE_LINE_STRIP_PROVOKE_VRTX |
             ENABLE_TRI_FAN_PROVOKE_VRTX |
             LINE_STRIP_PROVOKE_VRTX(1) |
             TRI_FAN_PROVOKE_VRTX(2) |
             ENABLE_TEXKILL_3D_4D |
             TEXKILL_4D,

   _3DSTATE_DEPTH_SUBRECT_DISABLE,

   /* disable indirect state for now
    */
   _3DSTATE_LOAD_INDIRECT | 0, 0};

static void
emit_invariant(struct i915_context *i915)
{
   i915_winsys_batchbuffer_write(i915->batch, invariant_state,
                                 Elements(invariant_state)*sizeof(uint32_t));
}

static void
validate_immediate(struct i915_context *i915, unsigned *batch_space)
{
   unsigned dirty = (1 << I915_IMMEDIATE_S0 | 1 << I915_IMMEDIATE_S1 |
                     1 << I915_IMMEDIATE_S2 | 1 << I915_IMMEDIATE_S3 |
                     1 << I915_IMMEDIATE_S3 | 1 << I915_IMMEDIATE_S4 |
                     1 << I915_IMMEDIATE_S5 | 1 << I915_IMMEDIATE_S6) &
                    i915->immediate_dirty;

   if (i915->immediate_dirty & (1 << I915_IMMEDIATE_S0) && i915->vbo)
      i915->validation_buffers[i915->num_validation_buffers++] = i915->vbo;

   *batch_space = 1 + util_bitcount(dirty);
}

static uint target_fixup(struct pipe_surface *p, int component)
{
   const struct
   {
      enum pipe_format format;
      uint hw_mask[4];
   } fixup_mask[] = {
      { PIPE_FORMAT_R8G8B8A8_UNORM, { S5_WRITEDISABLE_BLUE, S5_WRITEDISABLE_GREEN, S5_WRITEDISABLE_RED, S5_WRITEDISABLE_ALPHA}},
      { PIPE_FORMAT_R8G8B8X8_UNORM, { S5_WRITEDISABLE_BLUE, S5_WRITEDISABLE_GREEN, S5_WRITEDISABLE_RED, S5_WRITEDISABLE_ALPHA}},
      { PIPE_FORMAT_L8_UNORM,       { S5_WRITEDISABLE_RED | S5_WRITEDISABLE_GREEN | S5_WRITEDISABLE_BLUE, 0, 0, S5_WRITEDISABLE_ALPHA}},
      { PIPE_FORMAT_I8_UNORM,       { S5_WRITEDISABLE_RED | S5_WRITEDISABLE_GREEN | S5_WRITEDISABLE_BLUE, 0, 0, S5_WRITEDISABLE_ALPHA}},
      { PIPE_FORMAT_A8_UNORM,       { 0, 0, 0, S5_WRITEDISABLE_RED | S5_WRITEDISABLE_GREEN | S5_WRITEDISABLE_BLUE | S5_WRITEDISABLE_ALPHA}},
      { 0,                          { S5_WRITEDISABLE_RED, S5_WRITEDISABLE_GREEN, S5_WRITEDISABLE_BLUE, S5_WRITEDISABLE_ALPHA}}
   };
   int i = sizeof(fixup_mask) / sizeof(*fixup_mask) - 1;

   if (p)
      for(i = 0; fixup_mask[i].format != 0; i++)
         if (p->format == fixup_mask[i].format)
            return fixup_mask[i].hw_mask[component];

   /* Just return default masks */
   return fixup_mask[i].hw_mask[component];
}

static void emit_immediate_s5(struct i915_context *i915, uint imm)
{
   /* Fixup write mask for non-BGRA render targets */
   uint fixup_imm = imm & ~( S5_WRITEDISABLE_RED | S5_WRITEDISABLE_GREEN |
                             S5_WRITEDISABLE_BLUE | S5_WRITEDISABLE_ALPHA );
   struct pipe_surface *surf = i915->framebuffer.cbufs[0];

   if (imm & S5_WRITEDISABLE_RED)
      fixup_imm |= target_fixup(surf, 0);
   if (imm & S5_WRITEDISABLE_GREEN)
      fixup_imm |= target_fixup(surf, 1);
   if (imm & S5_WRITEDISABLE_BLUE)
      fixup_imm |= target_fixup(surf, 2);
   if (imm & S5_WRITEDISABLE_ALPHA)
      fixup_imm |= target_fixup(surf, 3);

   OUT_BATCH(fixup_imm);
}

static void emit_immediate_s6(struct i915_context *i915, uint imm)
{
   /* Fixup blend function for A8 dst buffers.
    * When we blend to an A8 buffer, the GPU thinks it's a G8 buffer,
    * and therefore we need to use the color factor for alphas. */
   uint srcRGB;

   if (i915->current.target_fixup_format == PIPE_FORMAT_A8_UNORM) {
      srcRGB = (imm >> S6_CBUF_SRC_BLEND_FACT_SHIFT) & BLENDFACT_MASK;
      if (srcRGB == BLENDFACT_DST_ALPHA)
         srcRGB = BLENDFACT_DST_COLR;
      else if (srcRGB == BLENDFACT_INV_DST_ALPHA)
         srcRGB = BLENDFACT_INV_DST_COLR;
      imm &= ~SRC_BLND_FACT(BLENDFACT_MASK);
      imm |= SRC_BLND_FACT(srcRGB);
   }

   OUT_BATCH(imm);
}

static void
emit_immediate(struct i915_context *i915)
{
   /* remove unwanted bits and S7 */
   unsigned dirty = (1 << I915_IMMEDIATE_S0 | 1 << I915_IMMEDIATE_S1 |
                     1 << I915_IMMEDIATE_S2 | 1 << I915_IMMEDIATE_S3 |
                     1 << I915_IMMEDIATE_S3 | 1 << I915_IMMEDIATE_S4 |
                     1 << I915_IMMEDIATE_S5 | 1 << I915_IMMEDIATE_S6) &
                    i915->immediate_dirty;
   int i, num = util_bitcount(dirty);
   assert(num && num <= I915_MAX_IMMEDIATE);

   OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
             dirty << 4 | (num - 1));

   if (i915->immediate_dirty & (1 << I915_IMMEDIATE_S0)) {
      if (i915->vbo)
         OUT_RELOC(i915->vbo, I915_USAGE_VERTEX,
                   i915->current.immediate[I915_IMMEDIATE_S0]);
      else
         OUT_BATCH(0);
   }

   for (i = 1; i < I915_MAX_IMMEDIATE; i++) {
      if (dirty & (1 << i)) {
         if (i == I915_IMMEDIATE_S5)
            emit_immediate_s5(i915, i915->current.immediate[i]);
         else if (i == I915_IMMEDIATE_S6)
            emit_immediate_s6(i915, i915->current.immediate[i]);
         else
            OUT_BATCH(i915->current.immediate[i]);
      }
   }
}

static void
validate_dynamic(struct i915_context *i915, unsigned *batch_space)
{
   *batch_space = util_bitcount(i915->dynamic_dirty & ((1 << I915_MAX_DYNAMIC) - 1));
}

static void
emit_dynamic(struct i915_context *i915)
{
   int i;
   for (i = 0; i < I915_MAX_DYNAMIC; i++) {
      if (i915->dynamic_dirty & (1 << i))
         OUT_BATCH(i915->current.dynamic[i]);
   }
}

static void
validate_static(struct i915_context *i915, unsigned *batch_space)
{
   *batch_space = 0;

   if (i915->current.cbuf_bo && (i915->static_dirty & I915_DST_BUF_COLOR)) {
      i915->validation_buffers[i915->num_validation_buffers++]
         = i915->current.cbuf_bo;
      *batch_space += 3;
   }

   if (i915->current.depth_bo && (i915->static_dirty & I915_DST_BUF_DEPTH)) {
      i915->validation_buffers[i915->num_validation_buffers++]
         = i915->current.depth_bo;
      *batch_space += 3;
   }

   if (i915->static_dirty & I915_DST_VARS)
      *batch_space += 2;

   if (i915->static_dirty & I915_DST_RECT)
      *batch_space += 5;
}

static void
emit_static(struct i915_context *i915)
{
   if (i915->current.cbuf_bo && (i915->static_dirty & I915_DST_BUF_COLOR)) {
      OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
      OUT_BATCH(i915->current.cbuf_flags);
      OUT_RELOC(i915->current.cbuf_bo,
                I915_USAGE_RENDER,
                0);
   }

   /* What happens if no zbuf??
    */
   if (i915->current.depth_bo && (i915->static_dirty & I915_DST_BUF_DEPTH)) {
      OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
      OUT_BATCH(i915->current.depth_flags);
      OUT_RELOC(i915->current.depth_bo,
                I915_USAGE_RENDER,
                0);
   }

   if (i915->static_dirty & I915_DST_VARS) {
      OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
      OUT_BATCH(i915->current.dst_buf_vars);
   }
}

static void
validate_map(struct i915_context *i915, unsigned *batch_space)
{
   const uint enabled = i915->current.sampler_enable_flags;
   uint unit;
   struct i915_texture *tex;

   *batch_space = i915->current.sampler_enable_nr ?
     2 + 3*i915->current.sampler_enable_nr : 0;

   for (unit = 0; unit < I915_TEX_UNITS; unit++) {
      if (enabled & (1 << unit)) {
         tex = i915_texture(i915->fragment_sampler_views[unit]->texture);
         i915->validation_buffers[i915->num_validation_buffers++] = tex->buffer;
      }
   }
}

static void
emit_map(struct i915_context *i915)
{
   const uint nr = i915->current.sampler_enable_nr;
   if (nr) {
      const uint enabled = i915->current.sampler_enable_flags;
      uint unit;
      uint count = 0;
      OUT_BATCH(_3DSTATE_MAP_STATE | (3 * nr));
      OUT_BATCH(enabled);
      for (unit = 0; unit < I915_TEX_UNITS; unit++) {
         if (enabled & (1 << unit)) {
            struct i915_texture *texture = i915_texture(i915->fragment_sampler_views[unit]->texture);
            struct i915_winsys_buffer *buf = texture->buffer;
            assert(buf);

            count++;

            OUT_RELOC(buf, I915_USAGE_SAMPLER, 0);
            OUT_BATCH(i915->current.texbuffer[unit][0]); /* MS3 */
            OUT_BATCH(i915->current.texbuffer[unit][1]); /* MS4 */
         }
      }
      assert(count == nr);
   }
}

static void
validate_sampler(struct i915_context *i915, unsigned *batch_space)
{
   *batch_space = i915->current.sampler_enable_nr ?
     2 + 3*i915->current.sampler_enable_nr : 0;
}

static void
emit_sampler(struct i915_context *i915)
{
   if (i915->current.sampler_enable_nr) {
      int i;

      OUT_BATCH( _3DSTATE_SAMPLER_STATE |
                 (3 * i915->current.sampler_enable_nr) );

      OUT_BATCH( i915->current.sampler_enable_flags );

      for (i = 0; i < I915_TEX_UNITS; i++) {
         if (i915->current.sampler_enable_flags & (1<<i)) {
            OUT_BATCH( i915->current.sampler[i][0] );
            OUT_BATCH( i915->current.sampler[i][1] );
            OUT_BATCH( i915->current.sampler[i][2] );
         }
      }
   }
}

static void
validate_constants(struct i915_context *i915, unsigned *batch_space)
{
   int nr = i915->fs->num_constants ?
      2 + 4*i915->fs->num_constants : 0;

   *batch_space = nr;
}

static void
emit_constants(struct i915_context *i915)
{
   /* Collate the user-defined constants with the fragment shader's
    * immediates according to the constant_flags[] array.
    */
   const uint nr = i915->fs->num_constants;

   assert(nr < I915_MAX_CONSTANT);
   if (nr) {
      uint i;

      OUT_BATCH( _3DSTATE_PIXEL_SHADER_CONSTANTS | (nr * 4) );
      OUT_BATCH((1 << nr) - 1);

      for (i = 0; i < nr; i++) {
         const uint *c;
         if (i915->fs->constant_flags[i] == I915_CONSTFLAG_USER) {
            /* grab user-defined constant */
            c = (uint *) i915_buffer(i915->constants[PIPE_SHADER_FRAGMENT])->data;
            c += 4 * i;
         }
         else {
            /* emit program constant */
            c = (uint *) i915->fs->constants[i];
         }
#if 0 /* debug */
         {
            float *f = (float *) c;
            printf("Const %2d: %f %f %f %f %s\n", i, f[0], f[1], f[2], f[3],
                   (i915->fs->constant_flags[i] == I915_CONSTFLAG_USER
                    ? "user" : "immediate"));
         }
#endif
         OUT_BATCH(*c++);
         OUT_BATCH(*c++);
         OUT_BATCH(*c++);
         OUT_BATCH(*c++);
      }
   }
}

static void
validate_program(struct i915_context *i915, unsigned *batch_space)
{
   uint additional_size = 0;

   additional_size += i915->current.target_fixup_format ? 3 : 0;

   /* we need more batch space if we want to emulate rgba framebuffers */
   *batch_space = i915->fs->decl_len + i915->fs->program_len + additional_size;
}

static void
emit_program(struct i915_context *i915)
{
   uint additional_size = 0;
   uint i;

   /* count how much additional space we'll need */
   validate_program(i915, &additional_size);
   additional_size -= i915->fs->decl_len + i915->fs->program_len;

   /* we should always have, at least, a pass-through program */
   assert(i915->fs->program_len > 0);

   /* output the declarations */
   {
      /* first word has the size, we have to adjust that */
      uint size = (i915->fs->decl[0]);
      size += additional_size;
      OUT_BATCH(size);
   }

   for (i = 1 ; i < i915->fs->decl_len; i++)
      OUT_BATCH(i915->fs->decl[i]);

   /* output the program */
   assert(i915->fs->program_len % 3 == 0);
   for (i = 0 ; i < i915->fs->program_len; i+=3) {
      OUT_BATCH(i915->fs->program[i]);
      OUT_BATCH(i915->fs->program[i+1]);
      OUT_BATCH(i915->fs->program[i+2]);
   }

   /* we emit an additional mov with swizzle to fake RGBA framebuffers */
   if (i915->current.target_fixup_format) {
      /* mov out_color, out_color.zyxw */
      OUT_BATCH(A0_MOV |
                (REG_TYPE_OC << A0_DEST_TYPE_SHIFT) |
                A0_DEST_CHANNEL_ALL |
                (REG_TYPE_OC << A0_SRC0_TYPE_SHIFT) |
                (T_DIFFUSE << A0_SRC0_NR_SHIFT));
      OUT_BATCH(i915->current.fixup_swizzle);
      OUT_BATCH(0);
   }
}

static void
emit_draw_rect(struct i915_context *i915)
{
   if (i915->static_dirty & I915_DST_RECT) {
      OUT_BATCH(_3DSTATE_DRAW_RECT_CMD);
      OUT_BATCH(DRAW_RECT_DIS_DEPTH_OFS);
      OUT_BATCH(i915->current.draw_offset);
      OUT_BATCH(i915->current.draw_size);
      OUT_BATCH(i915->current.draw_offset);
   }
}

static boolean
i915_validate_state(struct i915_context *i915, unsigned *batch_space)
{
   unsigned tmp;

   i915->num_validation_buffers = 0;
   if (i915->hardware_dirty & I915_HW_INVARIANT)
      *batch_space = Elements(invariant_state);
   else
      *batch_space = 0;

#if 0
static int counter_total = 0;
#define VALIDATE_ATOM(atom, hw_dirty) \
   if (i915->hardware_dirty & hw_dirty) { \
      static int counter_##atom = 0;\
      validate_##atom(i915, &tmp); \
      *batch_space += tmp;\
      counter_##atom += tmp;\
      counter_total += tmp;\
      printf("%s: \t%d/%d \t%2.2f\n",#atom, counter_##atom, counter_total, counter_##atom*100.f/counter_total);}
#else
#define VALIDATE_ATOM(atom, hw_dirty) \
   if (i915->hardware_dirty & hw_dirty) { \
      validate_##atom(i915, &tmp); \
      *batch_space += tmp; }
#endif
   VALIDATE_ATOM(flush, I915_HW_FLUSH);
   VALIDATE_ATOM(immediate, I915_HW_IMMEDIATE);
   VALIDATE_ATOM(dynamic, I915_HW_DYNAMIC);
   VALIDATE_ATOM(static, I915_HW_STATIC);
   VALIDATE_ATOM(map, I915_HW_MAP);
   VALIDATE_ATOM(sampler, I915_HW_SAMPLER);
   VALIDATE_ATOM(constants, I915_HW_CONSTANTS);
   VALIDATE_ATOM(program, I915_HW_PROGRAM);
#undef VALIDATE_ATOM

   if (i915->num_validation_buffers == 0)
      return TRUE;

   if (!i915_winsys_validate_buffers(i915->batch, i915->validation_buffers,
                                     i915->num_validation_buffers))
      return FALSE;

   return TRUE;
}

/* Push the state into the sarea and/or texture memory.
 */
void
i915_emit_hardware_state(struct i915_context *i915 )
{
   unsigned batch_space;
   uintptr_t save_ptr;

   assert(i915->dirty == 0);

   if (I915_DBG_ON(DBG_ATOMS))
      i915_dump_hardware_dirty(i915, __FUNCTION__);

   if (!i915_validate_state(i915, &batch_space)) {
      FLUSH_BATCH(NULL, I915_FLUSH_ASYNC);
      assert(i915_validate_state(i915, &batch_space));
   }

   if(!BEGIN_BATCH(batch_space)) {
      FLUSH_BATCH(NULL, I915_FLUSH_ASYNC);
      assert(i915_validate_state(i915, &batch_space));
      assert(BEGIN_BATCH(batch_space));
   }

   save_ptr = (uintptr_t)i915->batch->ptr;

#define EMIT_ATOM(atom, hw_dirty) \
   if (i915->hardware_dirty & hw_dirty) \
      emit_##atom(i915);
   EMIT_ATOM(flush, I915_HW_FLUSH);
   EMIT_ATOM(invariant, I915_HW_INVARIANT);
   EMIT_ATOM(immediate, I915_HW_IMMEDIATE);
   EMIT_ATOM(dynamic, I915_HW_DYNAMIC);
   EMIT_ATOM(static, I915_HW_STATIC);
   EMIT_ATOM(map, I915_HW_MAP);
   EMIT_ATOM(sampler, I915_HW_SAMPLER);
   EMIT_ATOM(constants, I915_HW_CONSTANTS);
   EMIT_ATOM(program, I915_HW_PROGRAM);
   EMIT_ATOM(draw_rect, I915_HW_STATIC);
#undef EMIT_ATOM

   I915_DBG(DBG_EMIT, "%s: used %d dwords, %d dwords reserved\n", __FUNCTION__,
            ((uintptr_t)i915->batch->ptr - save_ptr) / 4,
            batch_space);
   assert(((uintptr_t)i915->batch->ptr - save_ptr) / 4 == batch_space);

   i915->hardware_dirty = 0;
   i915->immediate_dirty = 0;
   i915->dynamic_dirty = 0;
   i915->static_dirty = 0;
   i915->flush_dirty = 0;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d131 64
d220 5
a224 15
         /* Fixup blend function for A8 dst buffers.
          * When we blend to an A8 buffer, the GPU thinks it's a G8 buffer,
          * and therefore we need to use the color factor for alphas. */
         if ((i == I915_IMMEDIATE_S6) &&
             (i915->current.target_fixup_format == PIPE_FORMAT_A8_UNORM)) {
            uint32_t imm = i915->current.immediate[i];
            uint32_t srcRGB = (imm >> S6_CBUF_SRC_BLEND_FACT_SHIFT) & BLENDFACT_MASK;
            if (srcRGB == BLENDFACT_DST_ALPHA)
               srcRGB = BLENDFACT_DST_COLR;
            else if (srcRGB == BLENDFACT_INV_DST_ALPHA)
               srcRGB = BLENDFACT_INV_DST_COLR;
            imm &= ~SRC_BLND_FACT(BLENDFACT_MASK);
            imm |= SRC_BLND_FACT(srcRGB);
            OUT_BATCH(imm);
         } else {
a225 1
         }
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d33 1
d134 1
a134 1
   /* remove unwatned bits and S7 */
d155 19
a173 2
      if (dirty & (1 << i))
         OUT_BATCH(i915->current.immediate[i]);
d320 1
a320 1
   *batch_space = i915->fs->num_constants ?
d322 2
d333 2
a367 36
static const struct
{
   enum pipe_format format;
   uint hw_swizzle;
} fixup_formats[] = {
   { PIPE_FORMAT_R8G8B8A8_UNORM, 0x21030000 /* BGRA */},
   { PIPE_FORMAT_L8_UNORM,       0x00030000 /* RRRA */},
   { PIPE_FORMAT_I8_UNORM,       0x00030000 /* RRRA */},
   { PIPE_FORMAT_A8_UNORM,       0x33330000 /* AAAA */},
   { PIPE_FORMAT_NONE,           0x00000000},
};

static uint need_target_fixup(struct pipe_surface* p)
{
   enum pipe_format f;
   /* if we don't have a surface bound yet, we don't need to fixup the shader */
   if (!p)
      return 0;

   f = p->format;
   for(int i=0; fixup_formats[i].format != PIPE_FORMAT_NONE; i++)
      if (fixup_formats[i].format == f)
         return 1;

   return 0;
}

static uint fixup_swizzle(enum pipe_format f)
{
   for(int i=0; fixup_formats[i].format != PIPE_FORMAT_NONE; i++)
      if (fixup_formats[i].format == f)
         return fixup_formats[i].hw_swizzle;

   return 0;
}

d371 3
a373 2
   struct pipe_surface *cbuf_surface = i915->framebuffer.cbufs[0];
   uint additional_size = need_target_fixup(cbuf_surface);
d376 1
a376 1
   *batch_space = i915->fs->program_len + 3 * additional_size;
d382 1
a382 2
   struct pipe_surface *cbuf_surface = i915->framebuffer.cbufs[0];
   uint target_fixup = need_target_fixup(cbuf_surface);
d385 4
d392 1
d395 2
a396 2
      uint size = (i915->fs->program[0]);
      size += target_fixup * 3;
d400 6
a405 2
   /* output the declarations of the program */
   for (i=1 ; i < i915->fs->program_len; i++) 
d407 3
d412 1
a412 1
   if (target_fixup) {
d419 1
a419 1
      OUT_BATCH(fixup_swizzle(cbuf_surface->format));
d447 11
d462 1
d497 1
a497 1
      FLUSH_BATCH(NULL);
d502 1
a502 1
      FLUSH_BATCH(NULL);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d37 1
d39 14
a52 1
static unsigned translate_format( enum pipe_format format )
d54 1
a54 9
   switch (format) {
   case PIPE_FORMAT_B8G8R8A8_UNORM:
      return COLOR_BUF_ARGB8888;
   case PIPE_FORMAT_B5G6R5_UNORM:
      return COLOR_BUF_RGB565;
   default:
      assert(0);
      return 0;
   }
d57 2
a58 1
static unsigned translate_depth_format( enum pipe_format zformat )
d60 10
a69 10
   switch (zformat) {
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
      return DEPTH_FRMT_24_FIXED_8_OTHER;
   case PIPE_FORMAT_Z16_UNORM:
      return DEPTH_FRMT_16_FIXED;
   default:
      assert(0);
      return 0;
   }
d72 35
d108 2
a109 6
/**
 * Examine framebuffer state to determine width, height.
 */
static boolean
framebuffer_size(const struct pipe_framebuffer_state *fb,
                 uint *width, uint *height)
d111 2
a112 14
   if (fb->cbufs[0]) {
      *width = fb->cbufs[0]->width;
      *height = fb->cbufs[0]->height;
      return TRUE;
   }
   else if (fb->zsbuf) {
      *width = fb->zsbuf->width;
      *height = fb->zsbuf->height;
      return TRUE;
   }
   else {
      *width = *height = 0;
      return FALSE;
   }
d115 2
a116 2
static inline uint32_t
buf_3d_tiling_bits(enum i915_winsys_buffer_tile tiling)
d118 5
a122 1
         uint32_t tiling_bits = 0;
d124 2
a125 8
         switch (tiling) {
         case I915_TILE_Y:
            tiling_bits |= BUF_3D_TILE_WALK_Y;
         case I915_TILE_X:
            tiling_bits |= BUF_3D_TILED_SURFACE;
         case I915_TILE_NONE:
            break;
         }
d127 1
a127 1
         return tiling_bits;
d130 2
a131 4
/* Push the state into the sarea and/or texture memory.
 */
void
i915_emit_hardware_state(struct i915_context *i915 )
d133 19
a151 18
   /* XXX: there must be an easier way */
   const unsigned dwords = ( 14 + 
                             7 + 
                             I915_MAX_DYNAMIC + 
                             8 + 
                             2 + I915_TEX_UNITS*3 + 
                             2 + I915_TEX_UNITS*3 +
                             2 + I915_MAX_CONSTANT*4 + 
#if 0
                             i915->current.program_len + 
#else
                             i915->fs->program_len + 
#endif
                             6 
                           ) * 3/2; /* plus 50% margin */
   const unsigned relocs = ( I915_TEX_UNITS +
                             3
                           ) * 3/2; /* plus 50% margin */
d153 5
a157 2
   uintptr_t save_ptr;
   size_t save_relocs;
d159 5
a163 2
   if (I915_DBG_ON(DBG_ATOMS))
      i915_dump_hardware_dirty(i915, __FUNCTION__);
d165 7
a171 3
   if(!BEGIN_BATCH(dwords, relocs)) {
      FLUSH_BATCH(NULL);
      assert(BEGIN_BATCH(dwords, relocs));
d173 1
d175 4
a178 2
   save_ptr = (uintptr_t)i915->batch->ptr;
   save_relocs = i915->batch->relocs;
d180 5
a184 7
   /* 14 dwords, 0 relocs */
   if (i915->hardware_dirty & I915_HW_INVARIENT)
   {
      OUT_BATCH(_3DSTATE_AA_CMD |
                AA_LINE_ECAAR_WIDTH_ENABLE |
                AA_LINE_ECAAR_WIDTH_1_0 |
                AA_LINE_REGION_WIDTH_ENABLE | AA_LINE_REGION_WIDTH_1_0);
d186 5
a190 2
      OUT_BATCH(_3DSTATE_DFLT_DIFFUSE_CMD);
      OUT_BATCH(0);
d192 2
a193 5
      OUT_BATCH(_3DSTATE_DFLT_SPEC_CMD);
      OUT_BATCH(0);
      
      OUT_BATCH(_3DSTATE_DFLT_Z_CMD);
      OUT_BATCH(0);
d195 3
a197 24
      OUT_BATCH(_3DSTATE_COORD_SET_BINDINGS |
                CSB_TCB(0, 0) |
                CSB_TCB(1, 1) |
                CSB_TCB(2, 2) |
                CSB_TCB(3, 3) |
                CSB_TCB(4, 4) | 
                CSB_TCB(5, 5) | 
                CSB_TCB(6, 6) | 
                CSB_TCB(7, 7));

      OUT_BATCH(_3DSTATE_RASTER_RULES_CMD |
                ENABLE_POINT_RASTER_RULE |
                OGL_POINT_RASTER_RULE |
                ENABLE_LINE_STRIP_PROVOKE_VRTX |
                ENABLE_TRI_FAN_PROVOKE_VRTX |
                LINE_STRIP_PROVOKE_VRTX(1) |
                TRI_FAN_PROVOKE_VRTX(2) | 
                ENABLE_TEXKILL_3D_4D | 
                TEXKILL_4D);

      /* Need to initialize this to zero.
       */
      OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(3) | (0));
      OUT_BATCH(0);
d199 26
a224 1
      OUT_BATCH(_3DSTATE_DEPTH_SUBRECT_DISABLE);
d226 15
a240 4
      /* disable indirect state for now
       */
      OUT_BATCH(_3DSTATE_LOAD_INDIRECT | 0);
      OUT_BATCH(0);
d242 1
d244 22
a265 33
   /* 7 dwords, 1 relocs */
   if (i915->hardware_dirty & I915_HW_IMMEDIATE)
   {
      OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | 
                I1_LOAD_S(0) |
                I1_LOAD_S(1) |
                I1_LOAD_S(2) |
                I1_LOAD_S(4) |
                I1_LOAD_S(5) |
                I1_LOAD_S(6) | 
                (5));
      
      if(i915->vbo)
         OUT_RELOC(i915->vbo,
                   I915_USAGE_VERTEX,
                   i915->current.immediate[I915_IMMEDIATE_S0]);
      else
         /* FIXME: we should not do this */
         OUT_BATCH(0);
      OUT_BATCH(i915->current.immediate[I915_IMMEDIATE_S1]);
      OUT_BATCH(i915->current.immediate[I915_IMMEDIATE_S2]);
      OUT_BATCH(i915->current.immediate[I915_IMMEDIATE_S4]);
      OUT_BATCH(i915->current.immediate[I915_IMMEDIATE_S5]);
      OUT_BATCH(i915->current.immediate[I915_IMMEDIATE_S6]);
   } 

#if 01
   /* I915_MAX_DYNAMIC dwords, 0 relocs */
   if (i915->hardware_dirty & I915_HW_DYNAMIC) 
   {
      int i;
      for (i = 0; i < I915_MAX_DYNAMIC; i++) {
         OUT_BATCH(i915->current.dynamic[i]);
d267 1
d269 1
a269 1
#endif
d271 6
a276 6
#if 01
   /* 8 dwords, 2 relocs */
   if (i915->hardware_dirty & I915_HW_STATIC)
   {
      struct pipe_surface *cbuf_surface = i915->framebuffer.cbufs[0];
      struct pipe_surface *depth_surface = i915->framebuffer.zsbuf;
d278 5
a282 14
      if (cbuf_surface) {
         struct i915_texture *tex = i915_texture(cbuf_surface->texture);
         assert(tex);

         OUT_BATCH(_3DSTATE_BUF_INFO_CMD);

         OUT_BATCH(BUF_3D_ID_COLOR_BACK |
                   BUF_3D_PITCH(tex->stride) |  /* pitch in bytes */
                   buf_3d_tiling_bits(tex->tiling));

         OUT_RELOC(tex->buffer,
                   I915_USAGE_RENDER,
                   0);
      }
d284 2
a285 20
      /* What happens if no zbuf??
       */
      if (depth_surface) {
         struct i915_texture *tex = i915_texture(depth_surface->texture);
         unsigned offset = i915_texture_offset(tex, depth_surface->u.tex.level,
                                               depth_surface->u.tex.first_layer);
         assert(tex);
         assert(offset == 0);

         OUT_BATCH(_3DSTATE_BUF_INFO_CMD);

         assert(tex);
         OUT_BATCH(BUF_3D_ID_DEPTH |
                   BUF_3D_PITCH(tex->stride) |  /* pitch in bytes */
                   buf_3d_tiling_bits(tex->tiling));

         OUT_RELOC(tex->buffer,
                   I915_USAGE_RENDER,
                   0);
      }
d287 1
a287 2
      {
         unsigned cformat, zformat = 0;
d289 6
a294 16
         if (cbuf_surface)
            cformat = cbuf_surface->format;
         else
            cformat = PIPE_FORMAT_B8G8R8A8_UNORM; /* arbitrary */
         cformat = translate_format(cformat);

         if (depth_surface) 
            zformat = translate_depth_format( i915->framebuffer.zsbuf->format );

         OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
         OUT_BATCH(DSTORG_HORT_BIAS(0x8) | /* .5 */
                   DSTORG_VERT_BIAS(0x8) | /* .5 */
                   LOD_PRECLAMP_OGL |
                   TEX_DEFAULT_COLOR_OGL |
                   cformat |
                   zformat );
d297 21
a317 1
#endif
d319 6
a324 26
#if 01
      /* texture images */
      /* 2 + I915_TEX_UNITS*3 dwords, I915_TEX_UNITS relocs */
      if (i915->hardware_dirty & (I915_HW_MAP | I915_HW_SAMPLER))
      {
         const uint nr = i915->current.sampler_enable_nr;
         if (nr) {
            const uint enabled = i915->current.sampler_enable_flags;
            uint unit;
            uint count = 0;
            OUT_BATCH(_3DSTATE_MAP_STATE | (3 * nr));
            OUT_BATCH(enabled);
            for (unit = 0; unit < I915_TEX_UNITS; unit++) {
               if (enabled & (1 << unit)) {
                  struct i915_texture *texture = i915_texture(i915->fragment_sampler_views[unit]->texture);
                  struct i915_winsys_buffer *buf = texture->buffer;
                  assert(buf);

                  count++;

                  OUT_RELOC(buf, I915_USAGE_SAMPLER, 0);
                  OUT_BATCH(i915->current.texbuffer[unit][0]); /* MS3 */
                  OUT_BATCH(i915->current.texbuffer[unit][1]); /* MS4 */
               }
            }
            assert(count == nr);
d326 16
d343 38
a380 1
#endif
d382 5
a386 7
#if 01
   /* samplers */
   /* 2 + I915_TEX_UNITS*3 dwords, 0 relocs */
   if (i915->hardware_dirty & I915_HW_SAMPLER) 
   {
      if (i915->current.sampler_enable_nr) {
         int i;
d388 3
a390 2
         OUT_BATCH( _3DSTATE_SAMPLER_STATE | 
                    (3 * i915->current.sampler_enable_nr) );
d392 6
a397 1
         OUT_BATCH( i915->current.sampler_enable_flags );
d399 2
a400 10
         for (i = 0; i < I915_TEX_UNITS; i++) {
            if (i915->current.sampler_enable_flags & (1<<i)) {
               OUT_BATCH( i915->current.sampler[i][0] );
               OUT_BATCH( i915->current.sampler[i][1] );
               OUT_BATCH( i915->current.sampler[i][2] );
            }
         }
      }
   }
#endif
a401 4
#if 01
   /* constants */
   /* 2 + I915_MAX_CONSTANT*4 dwords, 0 relocs */
   if (i915->hardware_dirty & I915_HW_CONSTANTS)
d403 20
a422 34
      /* Collate the user-defined constants with the fragment shader's
       * immediates according to the constant_flags[] array.
       */
      const uint nr = i915->fs->num_constants;
      if (nr) {
         uint i;

         OUT_BATCH( _3DSTATE_PIXEL_SHADER_CONSTANTS | (nr * 4) );
         OUT_BATCH( (1 << (nr - 1)) | ((1 << (nr - 1)) - 1) );

         for (i = 0; i < nr; i++) {
            const uint *c;
            if (i915->fs->constant_flags[i] == I915_CONSTFLAG_USER) {
               /* grab user-defined constant */
               c = (uint *) i915->current.constants[PIPE_SHADER_FRAGMENT][i];
            }
            else {
               /* emit program constant */
               c = (uint *) i915->fs->constants[i];
            }
#if 0 /* debug */
            {
               float *f = (float *) c;
               printf("Const %2d: %f %f %f %f %s\n", i, f[0], f[1], f[2], f[3],
                      (i915->fs->constant_flags[i] == I915_CONSTFLAG_USER
                       ? "user" : "immediate"));
            }
#endif
            OUT_BATCH(*c++);
            OUT_BATCH(*c++);
            OUT_BATCH(*c++);
            OUT_BATCH(*c++);
         }
      }
d424 1
a424 1
#endif
d426 9
a434 11
#if 01
   /* Fragment program */
   /* i915->current.program_len dwords, 0 relocs */
   if (i915->hardware_dirty & I915_HW_PROGRAM)
   {
      uint i;
      /* we should always have, at least, a pass-through program */
      assert(i915->fs->program_len > 0);
      for (i = 0; i < i915->fs->program_len; i++) {
         OUT_BATCH(i915->fs->program[i]);
      }
d436 1
a436 1
#endif
d438 4
a441 12
#if 01
   /* drawing surface size */
   /* 6 dwords, 0 relocs */
   if (i915->hardware_dirty & I915_HW_STATIC)
   {
      uint w, h;
      struct pipe_surface *cbuf_surface = i915->framebuffer.cbufs[0];
      struct i915_texture *tex = i915_texture(cbuf_surface->texture);
      unsigned x, y;
      int layer;
      uint32_t draw_offset;
      boolean ret;
d443 19
a461 2
      ret = framebuffer_size(&i915->framebuffer, &w, &h);
      assert(ret);
d463 2
a464 1
      layer = cbuf_surface->u.tex.first_layer;
d466 3
a468 2
      x = tex->image_offset[cbuf_surface->u.tex.level][layer].nblocksx;
      y = tex->image_offset[cbuf_surface->u.tex.level][layer].nblocksy;
d470 2
a471 1
      draw_offset = x | (y << 16);
d473 22
a494 7
      /* XXX flush only required when the draw_offset changes! */
      OUT_BATCH(MI_FLUSH | INHIBIT_FLUSH_RENDER_CACHE);
      OUT_BATCH(_3DSTATE_DRAW_RECT_CMD);
      OUT_BATCH(DRAW_RECT_DIS_DEPTH_OFS);
      OUT_BATCH(draw_offset);
      OUT_BATCH((w - 1 + x) | ((h - 1 + y) << 16));
      OUT_BATCH(draw_offset);
a495 1
#endif
d497 18
a514 1
   I915_DBG(DBG_EMIT, "%s: used %d dwords, %d relocs\n", __FUNCTION__,
d516 2
a517 1
            i915->batch->relocs - save_relocs);
d520 4
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d32 2
a33 1
#include "i915_reg.h"
d54 2
a55 1
   case PIPE_FORMAT_Z24S8_UNORM:
d89 16
d130 6
a135 4
#if 0
   debug_printf("i915_emit_hardware_state: %d dwords, %d relocs\n", dwords, relocs);
#endif
   
d141 3
d193 1
a193 1
   
d208 1
a208 1
                   INTEL_USAGE_VERTEX,
d219 2
a220 1
   
d229 3
a231 1
   
d239 1
a239 3
         unsigned ctile = BUF_3D_USE_FENCE;
         struct i915_texture *tex = (struct i915_texture *)
                                    cbuf_surface->texture;
a241 4
         if (tex && tex->sw_tiled) {
            ctile = BUF_3D_TILED_SURFACE;
         }

d246 1
a246 1
                   ctile);
d249 2
a250 2
                   INTEL_USAGE_RENDER,
                   cbuf_surface->offset);
d256 3
a258 3
         unsigned ztile = BUF_3D_USE_FENCE;
         struct i915_texture *tex = (struct i915_texture *)
                                    depth_surface->texture;
d260 1
a260 4

         if (tex && tex->sw_tiled) {
            ztile = BUF_3D_TILED_SURFACE;
         }
d267 1
a267 1
                   ztile);
d270 2
a271 2
                   INTEL_USAGE_RENDER,
                   depth_surface->offset);
d273 1
a273 1
   
d276 1
a276 1
      
d295 1
d311 2
a312 2
                  struct intel_buffer *buf = i915->texture[unit]->buffer;
                  uint offset = 0;
d317 1
a317 1
                  OUT_RELOC(buf, INTEL_USAGE_SAMPLER, offset);
d334 1
a334 1
         
d351 1
d354 1
a354 1
   if (i915->hardware_dirty & I915_HW_PROGRAM)
d391 1
d393 1
d405 1
d407 1
d410 1
d413 16
a428 3
      boolean k = framebuffer_size(&i915->framebuffer, &w, &h);
      (void)k;
      assert(k);
d430 2
d433 4
a436 5
      OUT_BATCH(0);
      OUT_BATCH(0);
      OUT_BATCH(((w - 1) & 0xffff) | ((h - 1) << 16));
      OUT_BATCH(0);
      OUT_BATCH(0);
d438 1
d440 3
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d32 1
a32 2
#include "i915_debug.h"
#include "i915_resource.h"
d53 1
a53 2
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
a86 16
static inline uint32_t
buf_3d_tiling_bits(enum i915_winsys_buffer_tile tiling)
{
         uint32_t tiling_bits = 0;

         switch (tiling) {
         case I915_TILE_Y:
            tiling_bits |= BUF_3D_TILE_WALK_Y;
         case I915_TILE_X:
            tiling_bits |= BUF_3D_TILED_SURFACE;
         case I915_TILE_NONE:
            break;
         }

         return tiling_bits;
}
d112 4
a115 6
   uintptr_t save_ptr;
   size_t save_relocs;

   if (I915_DBG_ON(DBG_ATOMS))
      i915_dump_hardware_dirty(i915, __FUNCTION__);

a120 3
   save_ptr = (uintptr_t)i915->batch->ptr;
   save_relocs = i915->batch->relocs;

d170 1
a170 1

d185 1
a185 1
                   I915_USAGE_VERTEX,
d196 1
a196 2

#if 01
d205 1
a205 3
#endif

#if 01
d213 3
a215 1
         struct i915_texture *tex = i915_texture(cbuf_surface->texture);
d218 4
d226 1
a226 1
                   buf_3d_tiling_bits(tex->tiling));
d229 2
a230 2
                   I915_USAGE_RENDER,
                   0);
d236 3
a238 3
         struct i915_texture *tex = i915_texture(depth_surface->texture);
         unsigned offset = i915_texture_offset(tex, depth_surface->u.tex.level,
                                               depth_surface->u.tex.first_layer);
d240 4
a243 1
         assert(offset == 0);
d250 1
a250 1
                   buf_3d_tiling_bits(tex->tiling));
d253 2
a254 2
                   I915_USAGE_RENDER,
                   0);
d256 1
a256 1

d259 1
a259 1

a277 1
#endif
d293 2
a294 2
                  struct i915_texture *texture = i915_texture(i915->fragment_sampler_views[unit]->texture);
                  struct i915_winsys_buffer *buf = texture->buffer;
d299 1
a299 1
                  OUT_RELOC(buf, I915_USAGE_SAMPLER, 0);
d316 1
a316 1

a332 1
#if 01
d335 1
a335 1
   if (i915->hardware_dirty & I915_HW_CONSTANTS)
a371 1
#endif
a372 1
#if 01
a383 1
#endif
a384 1
#if 01
a386 1
   if (i915->hardware_dirty & I915_HW_STATIC)
d389 3
a391 16
      struct pipe_surface *cbuf_surface = i915->framebuffer.cbufs[0];
      struct i915_texture *tex = i915_texture(cbuf_surface->texture);
      unsigned x, y;
      int layer;
      uint32_t draw_offset;
      boolean ret;

      ret = framebuffer_size(&i915->framebuffer, &w, &h);
      assert(ret);

      layer = cbuf_surface->u.tex.first_layer;

      x = tex->image_offset[cbuf_surface->u.tex.level][layer].nblocksx;
      y = tex->image_offset[cbuf_surface->u.tex.level][layer].nblocksy;

      draw_offset = x | (y << 16);
a392 2
      /* XXX flush only required when the draw_offset changes! */
      OUT_BATCH(MI_FLUSH | INHIBIT_FLUSH_RENDER_CACHE);
d394 5
a398 4
      OUT_BATCH(DRAW_RECT_DIS_DEPTH_OFS);
      OUT_BATCH(draw_offset);
      OUT_BATCH((w - 1 + x) | ((h - 1 + y) << 16));
      OUT_BATCH(draw_offset);
a399 1
#endif
a400 3
   I915_DBG(DBG_EMIT, "%s: used %d dwords, %d relocs\n", __FUNCTION__,
            ((uintptr_t)i915->batch->ptr - save_ptr) / 4,
            i915->batch->relocs - save_relocs);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a32 1
#include "i915_fpc.h"
a36 1
#include "pipe/p_format.h"
d38 1
a38 14
#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"

struct i915_tracked_hw_state {
   const char *name;
   void (*validate)(struct i915_context *, unsigned *batch_space);
   void (*emit)(struct i915_context *);
   unsigned dirty, batch_space;
};


static void
validate_flush(struct i915_context *i915, unsigned *batch_space)
d40 9
a48 1
   *batch_space = i915->flush_dirty ? 1 : 0;
d51 1
a51 2
static void
emit_flush(struct i915_context *i915)
d53 10
a62 10
   /* Cache handling is very cheap atm. State handling can request to flushes:
    * - I915_FLUSH_CACHE which is a flush everything request and
    * - I915_PIPELINE_FLUSH which is specifically for the draw_offset flush.
    * Because the cache handling is so dumb, no explicit "invalidate map cache".
    * Also, the first is a strict superset of the latter, so the following logic
    * works. */
   if (i915->flush_dirty & I915_FLUSH_CACHE)
      OUT_BATCH(MI_FLUSH | FLUSH_MAP_CACHE);
   else if (i915->flush_dirty & I915_PIPELINE_FLUSH)
      OUT_BATCH(MI_FLUSH | INHIBIT_FLUSH_RENDER_CACHE);
a64 35
uint32_t invariant_state[] = {
   _3DSTATE_AA_CMD | AA_LINE_ECAAR_WIDTH_ENABLE | AA_LINE_ECAAR_WIDTH_1_0 |
             AA_LINE_REGION_WIDTH_ENABLE | AA_LINE_REGION_WIDTH_1_0,

   _3DSTATE_DFLT_DIFFUSE_CMD, 0,

   _3DSTATE_DFLT_SPEC_CMD, 0,

   _3DSTATE_DFLT_Z_CMD, 0,

   _3DSTATE_COORD_SET_BINDINGS |
             CSB_TCB(0, 0) |
             CSB_TCB(1, 1) |
             CSB_TCB(2, 2) |
             CSB_TCB(3, 3) |
             CSB_TCB(4, 4) |
             CSB_TCB(5, 5) |
             CSB_TCB(6, 6) |
             CSB_TCB(7, 7),

   _3DSTATE_RASTER_RULES_CMD |
             ENABLE_POINT_RASTER_RULE |
             OGL_POINT_RASTER_RULE |
             ENABLE_LINE_STRIP_PROVOKE_VRTX |
             ENABLE_TRI_FAN_PROVOKE_VRTX |
             LINE_STRIP_PROVOKE_VRTX(1) |
             TRI_FAN_PROVOKE_VRTX(2) |
             ENABLE_TEXKILL_3D_4D |
             TEXKILL_4D,

   _3DSTATE_DEPTH_SUBRECT_DISABLE,

   /* disable indirect state for now
    */
   _3DSTATE_LOAD_INDIRECT | 0, 0};
d66 6
a71 2
static void
emit_invariant(struct i915_context *i915)
d73 14
a86 2
   i915_winsys_batchbuffer_write(i915->batch, invariant_state,
                                 Elements(invariant_state)*sizeof(uint32_t));
d89 2
a90 2
static void
validate_immediate(struct i915_context *i915, unsigned *batch_space)
d92 1
a92 5
   unsigned dirty = (1 << I915_IMMEDIATE_S0 | 1 << I915_IMMEDIATE_S1 |
                     1 << I915_IMMEDIATE_S2 | 1 << I915_IMMEDIATE_S3 |
                     1 << I915_IMMEDIATE_S3 | 1 << I915_IMMEDIATE_S4 |
                     1 << I915_IMMEDIATE_S5 | 1 << I915_IMMEDIATE_S6) &
                    i915->immediate_dirty;
d94 8
a101 2
   if (i915->immediate_dirty & (1 << I915_IMMEDIATE_S0) && i915->vbo)
      i915->validation_buffers[i915->num_validation_buffers++] = i915->vbo;
d103 1
a103 1
   *batch_space = 1 + util_bitcount(dirty);
d106 4
a109 2
static void
emit_immediate(struct i915_context *i915)
d111 18
a128 19
   /* remove unwanted bits and S7 */
   unsigned dirty = (1 << I915_IMMEDIATE_S0 | 1 << I915_IMMEDIATE_S1 |
                     1 << I915_IMMEDIATE_S2 | 1 << I915_IMMEDIATE_S3 |
                     1 << I915_IMMEDIATE_S3 | 1 << I915_IMMEDIATE_S4 |
                     1 << I915_IMMEDIATE_S5 | 1 << I915_IMMEDIATE_S6) &
                    i915->immediate_dirty;
   int i, num = util_bitcount(dirty);
   assert(num && num <= I915_MAX_IMMEDIATE);

   OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
             dirty << 4 | (num - 1));

   if (i915->immediate_dirty & (1 << I915_IMMEDIATE_S0)) {
      if (i915->vbo)
         OUT_RELOC(i915->vbo, I915_USAGE_VERTEX,
                   i915->current.immediate[I915_IMMEDIATE_S0]);
      else
         OUT_BATCH(0);
   }
d130 2
a131 22
   for (i = 1; i < I915_MAX_IMMEDIATE; i++) {
      if (dirty & (1 << i)) {
         /* Fixup blend function for A8 dst buffers.
          * When we blend to an A8 buffer, the GPU thinks it's a G8 buffer,
          * and therefore we need to use the color factor for alphas. */
         if ((i == I915_IMMEDIATE_S6) &&
             (i915->current.target_fixup_format == PIPE_FORMAT_A8_UNORM)) {
            uint32_t imm = i915->current.immediate[i];
            uint32_t srcRGB = (imm >> S6_CBUF_SRC_BLEND_FACT_SHIFT) & BLENDFACT_MASK;
            if (srcRGB == BLENDFACT_DST_ALPHA)
               srcRGB = BLENDFACT_DST_COLR;
            else if (srcRGB == BLENDFACT_INV_DST_ALPHA)
               srcRGB = BLENDFACT_INV_DST_COLR;
            imm &= ~SRC_BLND_FACT(BLENDFACT_MASK);
            imm |= SRC_BLND_FACT(srcRGB);
            OUT_BATCH(imm);
         } else {
            OUT_BATCH(i915->current.immediate[i]);
         }
      }
   }
}
d133 2
a134 5
static void
validate_dynamic(struct i915_context *i915, unsigned *batch_space)
{
   *batch_space = util_bitcount(i915->dynamic_dirty & ((1 << I915_MAX_DYNAMIC) - 1));
}
d136 3
a138 7
static void
emit_dynamic(struct i915_context *i915)
{
   int i;
   for (i = 0; i < I915_MAX_DYNAMIC; i++) {
      if (i915->dynamic_dirty & (1 << i))
         OUT_BATCH(i915->current.dynamic[i]);
a139 1
}
d141 2
a142 4
static void
validate_static(struct i915_context *i915, unsigned *batch_space)
{
   *batch_space = 0;
d144 7
a150 5
   if (i915->current.cbuf_bo && (i915->static_dirty & I915_DST_BUF_COLOR)) {
      i915->validation_buffers[i915->num_validation_buffers++]
         = i915->current.cbuf_bo;
      *batch_space += 3;
   }
d152 2
a153 5
   if (i915->current.depth_bo && (i915->static_dirty & I915_DST_BUF_DEPTH)) {
      i915->validation_buffers[i915->num_validation_buffers++]
         = i915->current.depth_bo;
      *batch_space += 3;
   }
d155 5
a159 2
   if (i915->static_dirty & I915_DST_VARS)
      *batch_space += 2;
d161 24
a184 3
   if (i915->static_dirty & I915_DST_RECT)
      *batch_space += 5;
}
d186 1
a186 26
static void
emit_static(struct i915_context *i915)
{
   if (i915->current.cbuf_bo && (i915->static_dirty & I915_DST_BUF_COLOR)) {
      OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
      OUT_BATCH(i915->current.cbuf_flags);
      OUT_RELOC(i915->current.cbuf_bo,
                I915_USAGE_RENDER,
                0);
   }

   /* What happens if no zbuf??
    */
   if (i915->current.depth_bo && (i915->static_dirty & I915_DST_BUF_DEPTH)) {
      OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
      OUT_BATCH(i915->current.depth_flags);
      OUT_RELOC(i915->current.depth_bo,
                I915_USAGE_RENDER,
                0);
   }

   if (i915->static_dirty & I915_DST_VARS) {
      OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
      OUT_BATCH(i915->current.dst_buf_vars);
   }
}
d188 4
a191 15
static void
validate_map(struct i915_context *i915, unsigned *batch_space)
{
   const uint enabled = i915->current.sampler_enable_flags;
   uint unit;
   struct i915_texture *tex;

   *batch_space = i915->current.sampler_enable_nr ?
     2 + 3*i915->current.sampler_enable_nr : 0;

   for (unit = 0; unit < I915_TEX_UNITS; unit++) {
      if (enabled & (1 << unit)) {
         tex = i915_texture(i915->fragment_sampler_views[unit]->texture);
         i915->validation_buffers[i915->num_validation_buffers++] = tex->buffer;
      }
a192 1
}
d194 33
a226 22
static void
emit_map(struct i915_context *i915)
{
   const uint nr = i915->current.sampler_enable_nr;
   if (nr) {
      const uint enabled = i915->current.sampler_enable_flags;
      uint unit;
      uint count = 0;
      OUT_BATCH(_3DSTATE_MAP_STATE | (3 * nr));
      OUT_BATCH(enabled);
      for (unit = 0; unit < I915_TEX_UNITS; unit++) {
         if (enabled & (1 << unit)) {
            struct i915_texture *texture = i915_texture(i915->fragment_sampler_views[unit]->texture);
            struct i915_winsys_buffer *buf = texture->buffer;
            assert(buf);

            count++;

            OUT_RELOC(buf, I915_USAGE_SAMPLER, 0);
            OUT_BATCH(i915->current.texbuffer[unit][0]); /* MS3 */
            OUT_BATCH(i915->current.texbuffer[unit][1]); /* MS4 */
         }
a227 1
      assert(count == nr);
d229 1
a229 1
}
d231 6
a236 6
static void
validate_sampler(struct i915_context *i915, unsigned *batch_space)
{
   *batch_space = i915->current.sampler_enable_nr ?
     2 + 3*i915->current.sampler_enable_nr : 0;
}
d238 14
a251 5
static void
emit_sampler(struct i915_context *i915)
{
   if (i915->current.sampler_enable_nr) {
      int i;
d253 20
a272 2
      OUT_BATCH( _3DSTATE_SAMPLER_STATE |
                 (3 * i915->current.sampler_enable_nr) );
d274 2
a275 1
      OUT_BATCH( i915->current.sampler_enable_flags );
d277 16
a292 6
      for (i = 0; i < I915_TEX_UNITS; i++) {
         if (i915->current.sampler_enable_flags & (1<<i)) {
            OUT_BATCH( i915->current.sampler[i][0] );
            OUT_BATCH( i915->current.sampler[i][1] );
            OUT_BATCH( i915->current.sampler[i][2] );
         }
d295 1
a295 1
}
d297 29
a325 5
static void
validate_constants(struct i915_context *i915, unsigned *batch_space)
{
   int nr = i915->fs->num_constants ?
      2 + 4*i915->fs->num_constants : 0;
d327 7
a333 2
   *batch_space = nr;
}
d335 2
a336 7
static void
emit_constants(struct i915_context *i915)
{
   /* Collate the user-defined constants with the fragment shader's
    * immediates according to the constant_flags[] array.
    */
   const uint nr = i915->fs->num_constants;
d338 1
a338 3
   assert(nr < I915_MAX_CONSTANT);
   if (nr) {
      uint i;
d340 10
a349 2
      OUT_BATCH( _3DSTATE_PIXEL_SHADER_CONSTANTS | (nr * 4) );
      OUT_BATCH((1 << nr) - 1);
d351 25
a375 11
      for (i = 0; i < nr; i++) {
         const uint *c;
         if (i915->fs->constant_flags[i] == I915_CONSTFLAG_USER) {
            /* grab user-defined constant */
            c = (uint *) i915_buffer(i915->constants[PIPE_SHADER_FRAGMENT])->data;
            c += 4 * i;
         }
         else {
            /* emit program constant */
            c = (uint *) i915->fs->constants[i];
         }
d377 11
a387 5
         {
            float *f = (float *) c;
            printf("Const %2d: %f %f %f %f %s\n", i, f[0], f[1], f[2], f[3],
                   (i915->fs->constant_flags[i] == I915_CONSTFLAG_USER
                    ? "user" : "immediate"));
d389 2
d392 11
a402 4
         OUT_BATCH(*c++);
         OUT_BATCH(*c++);
         OUT_BATCH(*c++);
         OUT_BATCH(*c++);
d405 1
a405 1
}
d407 12
a418 4
static void
validate_program(struct i915_context *i915, unsigned *batch_space)
{
   uint additional_size = 0;
d420 2
a421 1
   additional_size += i915->current.target_fixup_format ? 3 : 0;
d423 1
a423 3
   /* we need more batch space if we want to emulate rgba framebuffers */
   *batch_space = i915->fs->decl_len + i915->fs->program_len + additional_size;
}
d425 2
a426 5
static void
emit_program(struct i915_context *i915)
{
   uint additional_size = 0;
   uint i;
d428 1
a428 3
   /* count how much additional space we'll need */
   validate_program(i915, &additional_size);
   additional_size -= i915->fs->decl_len + i915->fs->program_len;
d430 2
a431 39
   /* we should always have, at least, a pass-through program */
   assert(i915->fs->program_len > 0);

   /* output the declarations */
   {
      /* first word has the size, we have to adjust that */
      uint size = (i915->fs->decl[0]);
      size += additional_size;
      OUT_BATCH(size);
   }

   for (i = 1 ; i < i915->fs->decl_len; i++)
      OUT_BATCH(i915->fs->decl[i]);

   /* output the program */
   assert(i915->fs->program_len % 3 == 0);
   for (i = 0 ; i < i915->fs->program_len; i+=3) {
      OUT_BATCH(i915->fs->program[i]);
      OUT_BATCH(i915->fs->program[i+1]);
      OUT_BATCH(i915->fs->program[i+2]);
   }

   /* we emit an additional mov with swizzle to fake RGBA framebuffers */
   if (i915->current.target_fixup_format) {
      /* mov out_color, out_color.zyxw */
      OUT_BATCH(A0_MOV |
                (REG_TYPE_OC << A0_DEST_TYPE_SHIFT) |
                A0_DEST_CHANNEL_ALL |
                (REG_TYPE_OC << A0_SRC0_TYPE_SHIFT) |
                (T_DIFFUSE << A0_SRC0_NR_SHIFT));
      OUT_BATCH(i915->current.fixup_swizzle);
      OUT_BATCH(0);
   }
}

static void
emit_draw_rect(struct i915_context *i915)
{
   if (i915->static_dirty & I915_DST_RECT) {
d434 3
a436 3
      OUT_BATCH(i915->current.draw_offset);
      OUT_BATCH(i915->current.draw_size);
      OUT_BATCH(i915->current.draw_offset);
a437 28
}

static boolean
i915_validate_state(struct i915_context *i915, unsigned *batch_space)
{
   unsigned tmp;

   i915->num_validation_buffers = 0;
   if (i915->hardware_dirty & I915_HW_INVARIANT)
      *batch_space = Elements(invariant_state);
   else
      *batch_space = 0;

#if 0
static int counter_total = 0;
#define VALIDATE_ATOM(atom, hw_dirty) \
   if (i915->hardware_dirty & hw_dirty) { \
      static int counter_##atom = 0;\
      validate_##atom(i915, &tmp); \
      *batch_space += tmp;\
      counter_##atom += tmp;\
      counter_total += tmp;\
      printf("%s: \t%d/%d \t%2.2f\n",#atom, counter_##atom, counter_total, counter_##atom*100.f/counter_total);}
#else
#define VALIDATE_ATOM(atom, hw_dirty) \
   if (i915->hardware_dirty & hw_dirty) { \
      validate_##atom(i915, &tmp); \
      *batch_space += tmp; }
a438 60
   VALIDATE_ATOM(flush, I915_HW_FLUSH);
   VALIDATE_ATOM(immediate, I915_HW_IMMEDIATE);
   VALIDATE_ATOM(dynamic, I915_HW_DYNAMIC);
   VALIDATE_ATOM(static, I915_HW_STATIC);
   VALIDATE_ATOM(map, I915_HW_MAP);
   VALIDATE_ATOM(sampler, I915_HW_SAMPLER);
   VALIDATE_ATOM(constants, I915_HW_CONSTANTS);
   VALIDATE_ATOM(program, I915_HW_PROGRAM);
#undef VALIDATE_ATOM

   if (i915->num_validation_buffers == 0)
      return TRUE;

   if (!i915_winsys_validate_buffers(i915->batch, i915->validation_buffers,
                                     i915->num_validation_buffers))
      return FALSE;

   return TRUE;
}

/* Push the state into the sarea and/or texture memory.
 */
void
i915_emit_hardware_state(struct i915_context *i915 )
{
   unsigned batch_space;
   uintptr_t save_ptr;

   assert(i915->dirty == 0);

   if (I915_DBG_ON(DBG_ATOMS))
      i915_dump_hardware_dirty(i915, __FUNCTION__);

   if (!i915_validate_state(i915, &batch_space)) {
      FLUSH_BATCH(NULL, I915_FLUSH_ASYNC);
      assert(i915_validate_state(i915, &batch_space));
   }

   if(!BEGIN_BATCH(batch_space)) {
      FLUSH_BATCH(NULL, I915_FLUSH_ASYNC);
      assert(i915_validate_state(i915, &batch_space));
      assert(BEGIN_BATCH(batch_space));
   }

   save_ptr = (uintptr_t)i915->batch->ptr;

#define EMIT_ATOM(atom, hw_dirty) \
   if (i915->hardware_dirty & hw_dirty) \
      emit_##atom(i915);
   EMIT_ATOM(flush, I915_HW_FLUSH);
   EMIT_ATOM(invariant, I915_HW_INVARIANT);
   EMIT_ATOM(immediate, I915_HW_IMMEDIATE);
   EMIT_ATOM(dynamic, I915_HW_DYNAMIC);
   EMIT_ATOM(static, I915_HW_STATIC);
   EMIT_ATOM(map, I915_HW_MAP);
   EMIT_ATOM(sampler, I915_HW_SAMPLER);
   EMIT_ATOM(constants, I915_HW_CONSTANTS);
   EMIT_ATOM(program, I915_HW_PROGRAM);
   EMIT_ATOM(draw_rect, I915_HW_STATIC);
#undef EMIT_ATOM
d440 1
a440 1
   I915_DBG(DBG_EMIT, "%s: used %d dwords, %d dwords reserved\n", __FUNCTION__,
d442 1
a442 2
            batch_space);
   assert(((uintptr_t)i915->batch->ptr - save_ptr) / 4 == batch_space);
a444 4
   i915->immediate_dirty = 0;
   i915->dynamic_dirty = 0;
   i915->static_dirty = 0;
   i915->flush_dirty = 0;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a130 64
static uint target_fixup(struct pipe_surface *p, int component)
{
   const struct
   {
      enum pipe_format format;
      uint hw_mask[4];
   } fixup_mask[] = {
      { PIPE_FORMAT_R8G8B8A8_UNORM, { S5_WRITEDISABLE_BLUE, S5_WRITEDISABLE_GREEN, S5_WRITEDISABLE_RED, S5_WRITEDISABLE_ALPHA}},
      { PIPE_FORMAT_R8G8B8X8_UNORM, { S5_WRITEDISABLE_BLUE, S5_WRITEDISABLE_GREEN, S5_WRITEDISABLE_RED, S5_WRITEDISABLE_ALPHA}},
      { PIPE_FORMAT_L8_UNORM,       { S5_WRITEDISABLE_RED | S5_WRITEDISABLE_GREEN | S5_WRITEDISABLE_BLUE, 0, 0, S5_WRITEDISABLE_ALPHA}},
      { PIPE_FORMAT_I8_UNORM,       { S5_WRITEDISABLE_RED | S5_WRITEDISABLE_GREEN | S5_WRITEDISABLE_BLUE, 0, 0, S5_WRITEDISABLE_ALPHA}},
      { PIPE_FORMAT_A8_UNORM,       { 0, 0, 0, S5_WRITEDISABLE_RED | S5_WRITEDISABLE_GREEN | S5_WRITEDISABLE_BLUE | S5_WRITEDISABLE_ALPHA}},
      { 0,                          { S5_WRITEDISABLE_RED, S5_WRITEDISABLE_GREEN, S5_WRITEDISABLE_BLUE, S5_WRITEDISABLE_ALPHA}}
   };
   int i = sizeof(fixup_mask) / sizeof(*fixup_mask) - 1;

   if (p)
      for(i = 0; fixup_mask[i].format != 0; i++)
         if (p->format == fixup_mask[i].format)
            return fixup_mask[i].hw_mask[component];

   /* Just return default masks */
   return fixup_mask[i].hw_mask[component];
}

static void emit_immediate_s5(struct i915_context *i915, uint imm)
{
   /* Fixup write mask for non-BGRA render targets */
   uint fixup_imm = imm & ~( S5_WRITEDISABLE_RED | S5_WRITEDISABLE_GREEN |
                             S5_WRITEDISABLE_BLUE | S5_WRITEDISABLE_ALPHA );
   struct pipe_surface *surf = i915->framebuffer.cbufs[0];

   if (imm & S5_WRITEDISABLE_RED)
      fixup_imm |= target_fixup(surf, 0);
   if (imm & S5_WRITEDISABLE_GREEN)
      fixup_imm |= target_fixup(surf, 1);
   if (imm & S5_WRITEDISABLE_BLUE)
      fixup_imm |= target_fixup(surf, 2);
   if (imm & S5_WRITEDISABLE_ALPHA)
      fixup_imm |= target_fixup(surf, 3);

   OUT_BATCH(fixup_imm);
}

static void emit_immediate_s6(struct i915_context *i915, uint imm)
{
   /* Fixup blend function for A8 dst buffers.
    * When we blend to an A8 buffer, the GPU thinks it's a G8 buffer,
    * and therefore we need to use the color factor for alphas. */
   uint srcRGB;

   if (i915->current.target_fixup_format == PIPE_FORMAT_A8_UNORM) {
      srcRGB = (imm >> S6_CBUF_SRC_BLEND_FACT_SHIFT) & BLENDFACT_MASK;
      if (srcRGB == BLENDFACT_DST_ALPHA)
         srcRGB = BLENDFACT_DST_COLR;
      else if (srcRGB == BLENDFACT_INV_DST_ALPHA)
         srcRGB = BLENDFACT_INV_DST_COLR;
      imm &= ~SRC_BLND_FACT(BLENDFACT_MASK);
      imm |= SRC_BLND_FACT(srcRGB);
   }

   OUT_BATCH(imm);
}

d156 15
a170 5
         if (i == I915_IMMEDIATE_S5)
            emit_immediate_s5(i915, i915->current.immediate[i]);
         else if (i == I915_IMMEDIATE_S6)
            emit_immediate_s6(i915, i915->current.immediate[i]);
         else
d172 1
@


