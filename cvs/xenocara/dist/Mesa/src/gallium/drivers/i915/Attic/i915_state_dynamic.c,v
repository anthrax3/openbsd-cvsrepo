head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.10;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.52;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "i915_batch.h"
#include "i915_state_inlines.h"
#include "i915_context.h"
#include "i915_reg.h"
#include "i915_state.h"

#include "util/u_memory.h"
#include "util/u_pack_color.h"


/* State that we have chosen to store in the DYNAMIC segment of the
 * i915 indirect state mechanism.
 *
 * Can't cache these in the way we do the static state, as there is no
 * start/size in the command packet, instead an 'end' value that gets
 * incremented.
 *
 * Additionally, there seems to be a requirement to re-issue the full
 * (active) state every time a 4kb boundary is crossed.
 */

static INLINE void set_dynamic(struct i915_context *i915,
                               unsigned offset,
                               const unsigned state)
{
   if (i915->current.dynamic[offset] == state)
      return;

   i915->current.dynamic[offset] = state;
   i915->dynamic_dirty |= 1 << offset;
   i915->hardware_dirty |= I915_HW_DYNAMIC;
}



static INLINE void set_dynamic_array(struct i915_context *i915,
                                     unsigned offset,
                                     const unsigned *src,
                                     unsigned dwords)
{
   unsigned i;

   if (!memcmp(src, &i915->current.dynamic[offset], dwords * 4))
      return;

   for (i = 0; i < dwords; i++) {
      i915->current.dynamic[offset + i] = src[i];
      i915->dynamic_dirty |= 1 << (offset + i);
   }

   i915->hardware_dirty |= I915_HW_DYNAMIC;
}



/***********************************************************************
 * Modes4: stencil masks and logicop
 */
static void upload_MODES4(struct i915_context *i915)
{
   unsigned modes4 = 0;

   /* I915_NEW_STENCIL
    */
   modes4 |= i915->depth_stencil->stencil_modes4;

   /* I915_NEW_BLEND
     */
   modes4 |= i915->blend->modes4;

   set_dynamic(i915, I915_DYNAMIC_MODES4, modes4);
}

const struct i915_tracked_state i915_upload_MODES4 = {
   "MODES4",
   upload_MODES4,
   I915_NEW_BLEND | I915_NEW_DEPTH_STENCIL
};



/***********************************************************************
 */
static void upload_BFO(struct i915_context *i915)
{
   unsigned bfo[2];
   bfo[0] = i915->depth_stencil->bfo[0];
   bfo[1] = i915->depth_stencil->bfo[1];
   /* I don't get it only allowed to set a ref mask when the enable bit is set? */
   if (bfo[0] & BFO_ENABLE_STENCIL_REF) {
      bfo[0] |= i915->stencil_ref.ref_value[1] << BFO_STENCIL_REF_SHIFT;
   }

   set_dynamic_array(i915, I915_DYNAMIC_BFO_0, bfo, 2);
}

const struct i915_tracked_state i915_upload_BFO = {
   "BFO",
   upload_BFO,
   I915_NEW_DEPTH_STENCIL
};



/***********************************************************************
 */
static void upload_BLENDCOLOR(struct i915_context *i915)
{
   unsigned bc[2];

   memset(bc, 0, sizeof(bc));

   /* I915_NEW_BLEND
    */
   {
      const float *color = i915->blend_color.color;

      bc[0] = _3DSTATE_CONST_BLEND_COLOR_CMD;
      bc[1] = pack_ui32_float4(color[0],
                               color[1],
                               color[2],
                               color[3]);
   }

   set_dynamic_array(i915, I915_DYNAMIC_BC_0, bc, 2);
}

const struct i915_tracked_state i915_upload_BLENDCOLOR = {
   "BLENDCOLOR",
   upload_BLENDCOLOR,
   I915_NEW_BLEND
};



/***********************************************************************
 */
static void upload_IAB(struct i915_context *i915)
{
   unsigned iab = i915->blend->iab;

   set_dynamic(i915, I915_DYNAMIC_IAB, iab);
}

const struct i915_tracked_state i915_upload_IAB = {
   "IAB",
   upload_IAB,
   I915_NEW_BLEND
};



/***********************************************************************
 */
static void upload_DEPTHSCALE(struct i915_context *i915)
{
   set_dynamic_array(i915, I915_DYNAMIC_DEPTHSCALE_0,
                     &i915->rasterizer->ds[0].u, 2);
}

const struct i915_tracked_state i915_upload_DEPTHSCALE = {
   "DEPTHSCALE",
   upload_DEPTHSCALE,
   I915_NEW_RASTERIZER
};



/***********************************************************************
 * Polygon stipple
 *
 * The i915 supports a 4x4 stipple natively, GL wants 32x32.
 * Fortunately stipple is usually a repeating pattern.
 *
 * XXX: does stipple pattern need to be adjusted according to
 * the window position?
 *
 * XXX: possibly need workaround for conform paths test.
 */
static void upload_STIPPLE(struct i915_context *i915)
{
   unsigned st[2];

   st[0] = _3DSTATE_STIPPLE;
   st[1] = 0;

   /* I915_NEW_RASTERIZER
    */
   st[1] |= i915->rasterizer->st;

   /* I915_NEW_STIPPLE
    */
   {
      const ubyte *mask = (const ubyte *)i915->poly_stipple.stipple;
      ubyte p[4];

      p[0] = mask[12] & 0xf;
      p[1] = mask[8] & 0xf;
      p[2] = mask[4] & 0xf;
      p[3] = mask[0] & 0xf;

      /* Not sure what to do about fallbacks, so for now just dont:
       */
      st[1] |= ((p[0] << 0) |
                (p[1] << 4) |
                (p[2] << 8) |
                (p[3] << 12));
   }

   set_dynamic_array(i915, I915_DYNAMIC_STP_0, st, 2);
}

const struct i915_tracked_state i915_upload_STIPPLE = {
   "STIPPLE",
   upload_STIPPLE,
   I915_NEW_RASTERIZER | I915_NEW_STIPPLE
};



/***********************************************************************
 * Scissor enable
 */
static void upload_SCISSOR_ENABLE( struct i915_context *i915 )
{
   set_dynamic(i915, I915_DYNAMIC_SC_ENA_0, i915->rasterizer->sc[0]);
}

const struct i915_tracked_state i915_upload_SCISSOR_ENABLE = {
   "SCISSOR ENABLE",
   upload_SCISSOR_ENABLE,
   I915_NEW_RASTERIZER
};



/***********************************************************************
 * Scissor rect
 */
static void upload_SCISSOR_RECT(struct i915_context *i915)
{
   unsigned x1 = i915->scissor.minx;
   unsigned y1 = i915->scissor.miny;
   unsigned x2 = i915->scissor.maxx - 1;
   unsigned y2 = i915->scissor.maxy - 1;
   unsigned sc[3];

   sc[0] = _3DSTATE_SCISSOR_RECT_0_CMD;
   sc[1] = (y1 << 16) | (x1 & 0xffff);
   sc[2] = (y2 << 16) | (x2 & 0xffff);

   set_dynamic_array(i915, I915_DYNAMIC_SC_RECT_0, sc, 3);
}

const struct i915_tracked_state i915_upload_SCISSOR_RECT = {
   "SCISSOR RECT",
   upload_SCISSOR_RECT,
   I915_NEW_SCISSOR
};



/***********************************************************************
 */
static const struct i915_tracked_state *atoms[] = {
   &i915_upload_MODES4,
   &i915_upload_BFO,
   &i915_upload_BLENDCOLOR,
   &i915_upload_IAB,
   &i915_upload_DEPTHSCALE,
   &i915_upload_STIPPLE,
   &i915_upload_SCISSOR_ENABLE,
   &i915_upload_SCISSOR_RECT
};

/* These will be dynamic indirect state commands, but for now just end
 * up on the batch buffer with everything else.
 */
static void update_dynamic(struct i915_context *i915)
{
   int i;

   for (i = 0; i < Elements(atoms); i++)
      if (i915->dirty & atoms[i]->dirty)
         atoms[i]->update(i915);
}

struct i915_tracked_state i915_hw_dynamic = {
   "dynamic",
   update_dynamic,
   ~0 /* all state atoms, becuase we do internal checking */
};
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d49 18
a66 4
static INLINE void set_dynamic_indirect(struct i915_context *i915,
                                        unsigned offset,
                                        const unsigned *src,
                                        unsigned dwords)
d73 1
a73 1
   for (i = 0; i < dwords; i++)
d75 2
d98 1
a98 6
   /* Always, so that we know when state is in-active:
    */
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_MODES4,
                        &modes4,
                        1);
d121 1
a121 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_BFO_0,
                        &(bfo[0]),
                        2);
d152 1
a152 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_BC_0,
                        bc,
                        2);
d169 1
a169 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_IAB,
                        &iab,
                        1);
d184 2
a185 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_DEPTHSCALE_0,
                        &(i915->rasterizer->ds[0].u),
                        2);
d237 1
a237 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_STP_0,
                        &st[0],
                        2);
d253 1
a253 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_SC_ENA_0,
                        &(i915->rasterizer->sc[0]),
                        1);
d271 2
a272 2
   unsigned x2 = i915->scissor.maxx;
   unsigned y2 = i915->scissor.maxy;
d279 1
a279 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_SC_RECT_0,
                        &sc[0],
                        3);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d2 1
a2 1
 * 
d5 1
a5 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d25 1
a25 1
 * 
d33 1
a33 1
#include "util/u_math.h"
a36 1
#define FILE_DEBUG_FLAG DEBUG_STATE
d39 1
a39 1
 * i915 indirect state mechanism.  
d49 4
a52 4
static INLINE void set_dynamic_indirect( struct i915_context *i915,
					 unsigned offset,
					 const unsigned *src,
					 unsigned dwords )
d56 3
d66 1
d68 1
a68 1
 * Modes4: stencil masks and logicop 
d70 1
a70 1
static void upload_MODES4( struct i915_context *i915 )
d74 2
a75 1
   /* I915_NEW_STENCIL */
d77 3
a79 1
   /* I915_NEW_BLEND */
d82 1
a82 1
   /* Always, so that we know when state is in-active: 
d84 4
a87 4
   set_dynamic_indirect( i915, 
			 I915_DYNAMIC_MODES4,
			 &modes4,
			 1 );
d91 3
a93 2
   I915_NEW_BLEND | I915_NEW_DEPTH_STENCIL,
   upload_MODES4
a97 1

d100 1
a100 2

static void upload_BFO( struct i915_context *i915 )
d109 5
a113 4
   set_dynamic_indirect( i915,
			 I915_DYNAMIC_BFO_0,
			 &(bfo[0]),
			 2 );
d117 3
a119 2
   I915_NEW_DEPTH_STENCIL,
   upload_BFO
d123 1
d126 1
a126 3


static void upload_BLENDCOLOR( struct i915_context *i915 )
d130 1
a130 1
   memset( bc, 0, sizeof(bc) );
d132 1
a132 1
   /* I915_NEW_BLEND {_COLOR} 
d138 4
a141 4
      bc[1] = pack_ui32_float4( color[0],
				color[1],
				color[2], 
				color[3] );
d144 4
a147 4
   set_dynamic_indirect( i915, 
			 I915_DYNAMIC_BC_0,
			 bc,
			 2 );
d151 3
a153 2
   I915_NEW_BLEND,
   upload_BLENDCOLOR
d156 2
d160 1
a160 3


static void upload_IAB( struct i915_context *i915 )
d164 4
a167 5

   set_dynamic_indirect( i915,
			 I915_DYNAMIC_IAB,
			 &iab,
			 1 );
d171 3
a173 2
   I915_NEW_BLEND,
   upload_IAB
d177 1
d180 1
a180 4



static void upload_DEPTHSCALE( struct i915_context *i915 )
d182 4
a185 4
   set_dynamic_indirect( i915,
			 I915_DYNAMIC_DEPTHSCALE_0,
			 &(i915->rasterizer->ds[0].u),
			 2 );
d189 3
a191 2
   I915_NEW_RASTERIZER,
   upload_DEPTHSCALE
d205 1
a205 1
 * XXX: possibly need workaround for conform paths test. 
d207 1
a207 2

static void upload_STIPPLE( struct i915_context *i915 )
a217 1

d232 3
a234 3
		(p[1] << 4) |
		(p[2] << 8) | 
		(p[3] << 12));
d237 4
a240 5

   set_dynamic_indirect( i915, 
			 I915_DYNAMIC_STP_0,
			 &st[0],
			 2 );
a242 1

d244 3
a246 2
   I915_NEW_RASTERIZER | I915_NEW_STIPPLE,
   upload_STIPPLE
d252 1
a252 1
 * Scissor.
d256 4
a259 4
   set_dynamic_indirect( i915,
			 I915_DYNAMIC_SC_ENA_0,
			 &(i915->rasterizer->sc[0]),
			 1 );
d263 3
a265 2
   I915_NEW_RASTERIZER,
   upload_SCISSOR_ENABLE
d270 4
a273 1
static void upload_SCISSOR_RECT( struct i915_context *i915 )
d280 1
a280 1
 
d285 4
a288 4
   set_dynamic_indirect( i915, 
			 I915_DYNAMIC_SC_RECT_0,
			 &sc[0],
			 3 );
a290 1

d292 3
a294 2
   I915_NEW_SCISSOR,
   upload_SCISSOR_RECT
d299 2
a300 3



d315 1
a315 1
void i915_update_dynamic( struct i915_context *i915 )
d321 1
a321 1
	 atoms[i]->update( i915 );
d324 5
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d2 1
a2 1
 *
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 1
a17 1
 *
d25 1
a25 1
 *
d33 1
a33 1

d37 1
d40 1
a40 1
 * i915 indirect state mechanism.
d50 4
a53 4
static INLINE void set_dynamic_indirect(struct i915_context *i915,
                                        unsigned offset,
                                        const unsigned *src,
                                        unsigned dwords)
a56 3
   if (!memcmp(src, &i915->current.dynamic[offset], dwords * 4))
      return;

a63 1

d65 1
a65 1
 * Modes4: stencil masks and logicop
d67 1
a67 1
static void upload_MODES4(struct i915_context *i915)
d71 1
a71 2
   /* I915_NEW_STENCIL
    */
d73 1
a73 3

   /* I915_NEW_BLEND
     */
d76 1
a76 1
   /* Always, so that we know when state is in-active:
d78 4
a81 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_MODES4,
                        &modes4,
                        1);
d85 2
a86 3
   "MODES4",
   upload_MODES4,
   I915_NEW_BLEND | I915_NEW_DEPTH_STENCIL
d91 1
d94 2
a95 1
static void upload_BFO(struct i915_context *i915)
d104 4
a107 5

   set_dynamic_indirect(i915,
                        I915_DYNAMIC_BFO_0,
                        &(bfo[0]),
                        2);
d111 2
a112 3
   "BFO",
   upload_BFO,
   I915_NEW_DEPTH_STENCIL
a115 1

d118 3
a120 1
static void upload_BLENDCOLOR(struct i915_context *i915)
d124 1
a124 1
   memset(bc, 0, sizeof(bc));
d126 1
a126 1
   /* I915_NEW_BLEND
d132 4
a135 4
      bc[1] = pack_ui32_float4(color[0],
                               color[1],
                               color[2],
                               color[3]);
d138 4
a141 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_BC_0,
                        bc,
                        2);
d145 2
a146 3
   "BLENDCOLOR",
   upload_BLENDCOLOR,
   I915_NEW_BLEND
d149 2
d153 1
a153 3
/***********************************************************************
 */
static void upload_IAB(struct i915_context *i915)
d157 5
a161 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_IAB,
                        &iab,
                        1);
d165 2
a166 3
   "IAB",
   upload_IAB,
   I915_NEW_BLEND
a169 1

d172 4
a175 1
static void upload_DEPTHSCALE(struct i915_context *i915)
d177 4
a180 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_DEPTHSCALE_0,
                        &(i915->rasterizer->ds[0].u),
                        2);
d184 2
a185 3
   "DEPTHSCALE",
   upload_DEPTHSCALE,
   I915_NEW_RASTERIZER
d199 1
a199 1
 * XXX: possibly need workaround for conform paths test.
d201 2
a202 1
static void upload_STIPPLE(struct i915_context *i915)
d213 1
d228 3
a230 3
                (p[1] << 4) |
                (p[2] << 8) |
                (p[3] << 12));
d233 5
a237 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_STP_0,
                        &st[0],
                        2);
d240 1
d242 2
a243 3
   "STIPPLE",
   upload_STIPPLE,
   I915_NEW_RASTERIZER | I915_NEW_STIPPLE
d249 1
a249 1
 * Scissor enable
d253 4
a256 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_SC_ENA_0,
                        &(i915->rasterizer->sc[0]),
                        1);
d260 2
a261 3
   "SCISSOR ENABLE",
   upload_SCISSOR_ENABLE,
   I915_NEW_RASTERIZER
d266 1
a266 4
/***********************************************************************
 * Scissor rect
 */
static void upload_SCISSOR_RECT(struct i915_context *i915)
d273 1
a273 1

d278 4
a281 4
   set_dynamic_indirect(i915,
                        I915_DYNAMIC_SC_RECT_0,
                        &sc[0],
                        3);
d284 1
d286 2
a287 3
   "SCISSOR RECT",
   upload_SCISSOR_RECT,
   I915_NEW_SCISSOR
d292 3
a294 2
/***********************************************************************
 */
d309 1
a309 1
static void update_dynamic(struct i915_context *i915)
d315 1
a315 1
         atoms[i]->update(i915);
a317 5
struct i915_tracked_state i915_hw_dynamic = {
   "dynamic",
   update_dynamic,
   ~0 /* all state atoms, becuase we do internal checking */
};
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d49 4
a52 18
static INLINE void set_dynamic(struct i915_context *i915,
                               unsigned offset,
                               const unsigned state)
{
   if (i915->current.dynamic[offset] == state)
      return;

   i915->current.dynamic[offset] = state;
   i915->dynamic_dirty |= 1 << offset;
   i915->hardware_dirty |= I915_HW_DYNAMIC;
}



static INLINE void set_dynamic_array(struct i915_context *i915,
                                     unsigned offset,
                                     const unsigned *src,
                                     unsigned dwords)
d59 1
a59 1
   for (i = 0; i < dwords; i++) {
a60 2
      i915->dynamic_dirty |= 1 << (offset + i);
   }
d82 6
a87 1
   set_dynamic(i915, I915_DYNAMIC_MODES4, modes4);
d110 4
a113 1
   set_dynamic_array(i915, I915_DYNAMIC_BFO_0, bfo, 2);
d144 4
a147 1
   set_dynamic_array(i915, I915_DYNAMIC_BC_0, bc, 2);
d164 4
a167 1
   set_dynamic(i915, I915_DYNAMIC_IAB, iab);
d182 4
a185 2
   set_dynamic_array(i915, I915_DYNAMIC_DEPTHSCALE_0,
                     &i915->rasterizer->ds[0].u, 2);
d237 4
a240 1
   set_dynamic_array(i915, I915_DYNAMIC_STP_0, st, 2);
d256 4
a259 1
   set_dynamic(i915, I915_DYNAMIC_SC_ENA_0, i915->rasterizer->sc[0]);
d277 2
a278 2
   unsigned x2 = i915->scissor.maxx - 1;
   unsigned y2 = i915->scissor.maxy - 1;
d285 4
a288 1
   set_dynamic_array(i915, I915_DYNAMIC_SC_RECT_0, sc, 3);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


