head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.13;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.10;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.52;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.09;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.16;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "i915_surface.h"
#include "i915_resource.h"
#include "i915_state.h"
#include "i915_blit.h"
#include "i915_reg.h"
#include "i915_screen.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_math.h"
#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_pack_color.h"
#include "util/u_surface.h"

/*
 * surface functions using the render engine
 */

static void
i915_util_blitter_save_states(struct i915_context *i915)
{
   util_blitter_save_blend(i915->blitter, (void *)i915->blend);
   util_blitter_save_depth_stencil_alpha(i915->blitter, (void *)i915->depth_stencil);
   util_blitter_save_stencil_ref(i915->blitter, &i915->stencil_ref);
   util_blitter_save_rasterizer(i915->blitter, (void *)i915->rasterizer);
   util_blitter_save_fragment_shader(i915->blitter, i915->fs);
   util_blitter_save_vertex_shader(i915->blitter, i915->vs);
   util_blitter_save_viewport(i915->blitter, &i915->viewport);
   util_blitter_save_scissor(i915->blitter, &i915->scissor);
   util_blitter_save_vertex_elements(i915->blitter, i915->velems);
   util_blitter_save_vertex_buffer_slot(i915->blitter,
                                    i915->vertex_buffers);

   util_blitter_save_framebuffer(i915->blitter, &i915->framebuffer);

   util_blitter_save_fragment_sampler_states(i915->blitter,
                                             i915->num_samplers,
                                             (void**)i915->fragment_sampler);
   util_blitter_save_fragment_sampler_views(i915->blitter,
                                            i915->num_fragment_sampler_views,
                                            i915->fragment_sampler_views);
}

static void
i915_surface_copy_render(struct pipe_context *pipe,
                         struct pipe_resource *dst, unsigned dst_level,
                         unsigned dstx, unsigned dsty, unsigned dstz,
                         struct pipe_resource *src, unsigned src_level,
                         const struct pipe_box *src_box)
{
   struct i915_context *i915 = i915_context(pipe);

   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }

   if (!util_blitter_is_copy_supported(i915->blitter, dst, src)) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }

   i915_util_blitter_save_states(i915);

   util_blitter_copy_texture(i915->blitter, dst, dst_level, dstx, dsty, dstz,
                            src, src_level, src_box);
}

static void
i915_clear_render_target_render(struct pipe_context *pipe,
                                struct pipe_surface *dst,
                                const union pipe_color_union *color,
                                unsigned dstx, unsigned dsty,
                                unsigned width, unsigned height)
{
   struct i915_context *i915 = i915_context(pipe);
   struct pipe_framebuffer_state fb_state;

   util_blitter_save_framebuffer(i915->blitter, &i915->framebuffer);

   fb_state.width = dst->width;
   fb_state.height = dst->height;
   fb_state.nr_cbufs = 1;
   fb_state.cbufs[0] = dst;
   fb_state.zsbuf = NULL;
   pipe->set_framebuffer_state(pipe, &fb_state);

   if (i915->dirty)
      i915_update_derived(i915);

   i915_clear_emit(pipe, PIPE_CLEAR_COLOR, color, 0.0, 0x0,
                   dstx, dsty, width, height);

   pipe->set_framebuffer_state(pipe, &i915->blitter->saved_fb_state);
   util_unreference_framebuffer_state(&i915->blitter->saved_fb_state);
   i915->blitter->saved_fb_state.nr_cbufs = ~0;
}

static void
i915_clear_depth_stencil_render(struct pipe_context *pipe,
                                struct pipe_surface *dst,
                                unsigned clear_flags,
                                double depth,
                                unsigned stencil,
                                unsigned dstx, unsigned dsty,
                                unsigned width, unsigned height)
{
   struct i915_context *i915 = i915_context(pipe);
   struct pipe_framebuffer_state fb_state;

   util_blitter_save_framebuffer(i915->blitter, &i915->framebuffer);

   fb_state.width = dst->width;
   fb_state.height = dst->height;
   fb_state.nr_cbufs = 0;
   fb_state.zsbuf = dst;
   pipe->set_framebuffer_state(pipe, &fb_state);

   if (i915->dirty)
      i915_update_derived(i915);

   i915_clear_emit(pipe, clear_flags & PIPE_CLEAR_DEPTHSTENCIL,
                   NULL, depth, stencil,
                   dstx, dsty, width, height);

   pipe->set_framebuffer_state(pipe, &i915->blitter->saved_fb_state);
   util_unreference_framebuffer_state(&i915->blitter->saved_fb_state);
   i915->blitter->saved_fb_state.nr_cbufs = ~0;
}

/*
 * surface functions using the blitter
 */

/* Assumes all values are within bounds -- no checking at this level -
 * do it higher up if required.
 */
static void
i915_surface_copy_blitter(struct pipe_context *pipe,
                          struct pipe_resource *dst, unsigned dst_level,
                          unsigned dstx, unsigned dsty, unsigned dstz,
                          struct pipe_resource *src, unsigned src_level,
                          const struct pipe_box *src_box)
{
   struct i915_texture *dst_tex = i915_texture(dst);
   struct i915_texture *src_tex = i915_texture(src);
   struct pipe_resource *dpt = &dst_tex->b.b;
   struct pipe_resource *spt = &src_tex->b.b;
   unsigned dst_offset, src_offset;  /* in bytes */

   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }

   /* XXX cannot copy 3d regions at this time */
   assert(src_box->depth == 1);
   if (dst->target != PIPE_TEXTURE_CUBE &&
       dst->target != PIPE_TEXTURE_3D)
      assert(dstz == 0);
   dst_offset = i915_texture_offset(dst_tex, dst_level, dstz);

   if (src->target != PIPE_TEXTURE_CUBE &&
       src->target != PIPE_TEXTURE_3D)
      assert(src_box->z == 0);
   src_offset = i915_texture_offset(src_tex, src_level, src_box->z);

   assert( util_format_get_blocksize(dpt->format) == util_format_get_blocksize(spt->format) );
   assert( util_format_get_blockwidth(dpt->format) == util_format_get_blockwidth(spt->format) );
   assert( util_format_get_blockheight(dpt->format) == util_format_get_blockheight(spt->format) );
   assert( util_format_get_blockwidth(dpt->format) == 1 );
   assert( util_format_get_blockheight(dpt->format) == 1 );

   i915_copy_blit( i915_context(pipe),
                   util_format_get_blocksize(dpt->format),
                   (unsigned short) src_tex->stride, src_tex->buffer, src_offset,
                   (unsigned short) dst_tex->stride, dst_tex->buffer, dst_offset,
                   (short) src_box->x, (short) src_box->y, (short) dstx, (short) dsty,
                   (short) src_box->width, (short) src_box->height );
}

static void
i915_blit(struct pipe_context *pipe, const struct pipe_blit_info *blit_info)
{
   struct i915_context *i915 = i915_context(pipe);
   struct pipe_blit_info info = *blit_info;

   if (util_try_blit_via_copy_region(pipe, &info)) {
      return; /* done */
   }

   if (info.mask & PIPE_MASK_S) {
      debug_printf("i915: cannot blit stencil, skipping\n");
      info.mask &= ~PIPE_MASK_S;
   }

   if (!util_blitter_is_blit_supported(i915->blitter, &info)) {
      debug_printf("i915: blit unsupported %s -> %s\n",
                   util_format_short_name(info.src.resource->format),
                   util_format_short_name(info.dst.resource->format));
      return;
   }

   i915_util_blitter_save_states(i915);

   util_blitter_blit(i915->blitter, &info);
}

static void
i915_flush_resource(struct pipe_context *ctx, struct pipe_resource *resource)
{
}

static void
i915_clear_render_target_blitter(struct pipe_context *pipe,
                                 struct pipe_surface *dst,
                                 const union pipe_color_union *color,
                                 unsigned dstx, unsigned dsty,
                                 unsigned width, unsigned height)
{
   struct i915_texture *tex = i915_texture(dst->texture);
   struct pipe_resource *pt = &tex->b.b;
   union util_color uc;
   unsigned offset = i915_texture_offset(tex, dst->u.tex.level, dst->u.tex.first_layer);

   assert(util_format_get_blockwidth(pt->format) == 1);
   assert(util_format_get_blockheight(pt->format) == 1);

   util_pack_color(color->f, dst->format, &uc);
   i915_fill_blit( i915_context(pipe),
                   util_format_get_blocksize(pt->format),
                   XY_COLOR_BLT_WRITE_ALPHA | XY_COLOR_BLT_WRITE_RGB,
                   (unsigned short) tex->stride,
                   tex->buffer, offset,
                   (short) dstx, (short) dsty,
                   (short) width, (short) height,
                   uc.ui[0] );
}

static void
i915_clear_depth_stencil_blitter(struct pipe_context *pipe,
                                 struct pipe_surface *dst,
                                 unsigned clear_flags,
                                 double depth,
                                 unsigned stencil,
                                 unsigned dstx, unsigned dsty,
                                 unsigned width, unsigned height)
{
   struct i915_texture *tex = i915_texture(dst->texture);
   struct pipe_resource *pt = &tex->b.b;
   unsigned packedds;
   unsigned mask = 0;
   unsigned offset = i915_texture_offset(tex, dst->u.tex.level, dst->u.tex.first_layer);

   assert(util_format_get_blockwidth(pt->format) == 1);
   assert(util_format_get_blockheight(pt->format) == 1);

   packedds = util_pack_z_stencil(dst->format, depth, stencil);

   if (clear_flags & PIPE_CLEAR_DEPTH)
      mask |= XY_COLOR_BLT_WRITE_RGB;
   /* XXX presumably this does read-modify-write
      (otherwise this won't work anyway). Hence will only want to
      do it if really have stencil and it isn't cleared */
   if ((clear_flags & PIPE_CLEAR_STENCIL) ||
       (dst->format != PIPE_FORMAT_Z24_UNORM_S8_UINT))
      mask |= XY_COLOR_BLT_WRITE_ALPHA;

   i915_fill_blit( i915_context(pipe),
                   util_format_get_blocksize(pt->format),
                   mask,
                   (unsigned short) tex->stride,
                   tex->buffer, offset,
                   (short) dstx, (short) dsty,
                   (short) width, (short) height,
                   packedds );
}

/*
 * Screen surface functions
 */


static struct pipe_surface *
i915_create_surface(struct pipe_context *ctx,
                    struct pipe_resource *pt,
                    const struct pipe_surface *surf_tmpl)
{
   struct pipe_surface *ps;

   assert(surf_tmpl->u.tex.first_layer == surf_tmpl->u.tex.last_layer);
   if (pt->target != PIPE_TEXTURE_CUBE &&
       pt->target != PIPE_TEXTURE_3D)
      assert(surf_tmpl->u.tex.first_layer == 0);

   ps = CALLOC_STRUCT(pipe_surface);
   if (ps) {
      /* could subclass pipe_surface and store offset as it used to do */
      pipe_reference_init(&ps->reference, 1);
      pipe_resource_reference(&ps->texture, pt);
      ps->format = surf_tmpl->format;
      ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
      ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
      ps->u.tex.level = surf_tmpl->u.tex.level;
      ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
      ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
      ps->context = ctx;
   }
   return ps;
}

static void
i915_surface_destroy(struct pipe_context *ctx,
                     struct pipe_surface *surf)
{
   pipe_resource_reference(&surf->texture, NULL);
   FREE(surf);
}


void
i915_init_surface_functions(struct i915_context *i915)
{
   if (i915_screen(i915->base.screen)->debug.use_blitter) {
      i915->base.resource_copy_region = i915_surface_copy_blitter;
      i915->base.clear_render_target = i915_clear_render_target_blitter;
      i915->base.clear_depth_stencil = i915_clear_depth_stencil_blitter;
   } else {
      i915->base.resource_copy_region = i915_surface_copy_render;
      i915->base.clear_render_target = i915_clear_render_target_render;
      i915->base.clear_depth_stencil = i915_clear_depth_stencil_render;
   }
   i915->base.blit = i915_blit;
   i915->base.flush_resource = i915_flush_resource;
   i915->base.create_surface = i915_create_surface;
   i915->base.surface_destroy = i915_surface_destroy;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a41 6
static struct pipe_surface *
i915_create_surface_custom(struct pipe_context *ctx,
                           struct pipe_resource *pt,
                           const struct pipe_surface *surf_tmpl,
                           unsigned width0,
                           unsigned height0);
d70 1
a70 1
#
a78 12
   unsigned src_width0 = src->width0;
   unsigned src_height0 = src->height0;
   unsigned dst_width0 = dst->width0;
   unsigned dst_height0 = dst->height0;
   struct pipe_box dstbox;
   struct pipe_sampler_view src_templ, *src_view;
   struct pipe_surface dst_templ, *dst_view;

   /* Fallback for buffers and npot. */
   if ((dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) ||
       !util_is_power_of_two(src_width0) || !util_is_power_of_two(src_height0))
      goto fallback;
d80 6
a85 2
   util_blitter_default_dst_texture(&dst_templ, dst, dst_level, dstz);
   util_blitter_default_src_texture(&src_templ, src, src_level);
d87 5
a91 2
   if (!util_blitter_is_copy_supported(i915->blitter, dst, src))
      goto fallback;
d95 3
a97 15
   dst_view = i915_create_surface_custom(pipe, dst, &dst_templ, dst_width0, dst_height0);
   src_view = i915_create_sampler_view_custom(pipe, src, &src_templ, src_width0, src_height0);

   u_box_3d(dstx, dsty, dstz, abs(src_box->width), abs(src_box->height),
            abs(src_box->depth), &dstbox);

   util_blitter_blit_generic(i915->blitter, dst_view, &dstbox,
                             src_view, src_box, src_width0, src_height0,
                             PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL);
   return;

fallback:
   util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                             src, src_level, src_box);
 }
d317 3
a319 5
i915_create_surface_custom(struct pipe_context *ctx,
                           struct pipe_resource *pt,
                           const struct pipe_surface *surf_tmpl,
                           unsigned width0,
                           unsigned height0)
d334 2
a335 2
      ps->width = u_minify(width0, surf_tmpl->u.tex.level);
      ps->height = u_minify(height0, surf_tmpl->u.tex.level);
a341 9
}

static struct pipe_surface *
i915_create_surface(struct pipe_context *ctx,
                    struct pipe_resource *pt,
                    const struct pipe_surface *surf_tmpl)
{
   return i915_create_surface_custom(ctx, pt, surf_tmpl,
                                     pt->width0, pt->height0);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d42 6
d76 1
a76 1

d85 12
d98 2
a99 6
   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }
d101 2
a102 5
   if (!util_blitter_is_copy_supported(i915->blitter, dst, src)) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }
d106 15
a120 3
   util_blitter_copy_texture(i915->blitter, dst, dst_level, dstx, dsty, dstz,
                            src, src_level, src_box);
}
d340 5
a344 3
i915_create_surface(struct pipe_context *ctx,
                    struct pipe_resource *pt,
                    const struct pipe_surface *surf_tmpl)
d359 2
a360 2
      ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
      ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
d367 9
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d65 1
a65 1
                                             (void**)i915->sampler);
d87 1
a87 2
   if (!util_blitter_is_copy_supported(i915->blitter, dst, src,
                                       PIPE_MASK_RGBAZS)) {
d96 1
a96 1
                            src, src_level, src_box, PIPE_MASK_RGBAZS, TRUE);
d242 5
d269 1
a269 1
                   uc.ui );
d366 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d47 25
d87 6
a92 11
   util_blitter_save_blend(i915->blitter, (void *)i915->blend);
   util_blitter_save_depth_stencil_alpha(i915->blitter, (void *)i915->depth_stencil);
   util_blitter_save_stencil_ref(i915->blitter, &i915->stencil_ref);
   util_blitter_save_rasterizer(i915->blitter, (void *)i915->rasterizer);
   util_blitter_save_fragment_shader(i915->blitter, i915->saved_fs);
   util_blitter_save_vertex_shader(i915->blitter, i915->saved_vs);
   util_blitter_save_viewport(i915->blitter, &i915->viewport);
   util_blitter_save_clip(i915->blitter, &i915->saved_clip);
   util_blitter_save_vertex_elements(i915->blitter, i915->saved_velems);
   util_blitter_save_vertex_buffers(i915->blitter, i915->saved_nr_vertex_buffers,
                                    i915->saved_vertex_buffers);
d94 1
a94 8
   util_blitter_save_framebuffer(i915->blitter, &i915->framebuffer);

   util_blitter_save_fragment_sampler_states(i915->blitter,
                                             i915->saved_nr_samplers,
                                             i915->saved_samplers);
   util_blitter_save_fragment_sampler_views(i915->blitter,
                                            i915->saved_nr_sampler_views,
                                            i915->saved_sampler_views);
d96 2
a97 2
   util_blitter_copy_region(i915->blitter, dst, dst_level, dstx, dsty, dstz,
                            src, src_level, src_box, TRUE);
d103 1
a103 1
                                const float *rgba,
d122 1
a122 1
   i915_clear_emit(pipe, PIPE_CLEAR_COLOR, rgba, 0.0, 0x0,
d216 27
d245 1
a245 1
                                 const float *rgba,
d257 1
a257 1
   util_pack_color(rgba, dst->format, &uc);
d294 1
a294 1
       (dst->format != PIPE_FORMAT_Z24_UNORM_S8_USCALED))
a334 1
      ps->usage = surf_tmpl->usage;
d361 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d30 1
d40 1
d42 110
d157 5
a161 5
i915_surface_copy(struct pipe_context *pipe,
                  struct pipe_resource *dst, unsigned dst_level,
                  unsigned dstx, unsigned dsty, unsigned dstz,
                  struct pipe_resource *src, unsigned src_level,
                  const struct pipe_box *src_box)
d169 7
a187 1
   assert( dst != src );
a201 1

d203 5
a207 5
i915_clear_render_target(struct pipe_context *pipe,
                         struct pipe_surface *dst,
                         const float *rgba,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
d229 7
a235 7
i915_clear_depth_stencil(struct pipe_context *pipe,
                         struct pipe_surface *dst,
                         unsigned clear_flags,
                         double depth,
                         unsigned stencil,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
d313 9
a321 3
   i915->base.resource_copy_region = i915_surface_copy;
   i915->base.clear_render_target = i915_clear_render_target;
   i915->base.clear_depth_stencil = i915_clear_depth_stencil;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d28 2
a29 1
#include "i915_context.h"
d31 2
d34 2
d37 2
d46 22
a67 9
		  struct pipe_surface *dst,
		  unsigned dstx, unsigned dsty,
		  struct pipe_surface *src,
		  unsigned srcx, unsigned srcy, unsigned width, unsigned height)
{
   struct i915_texture *dst_tex = (struct i915_texture *)dst->texture;
   struct i915_texture *src_tex = (struct i915_texture *)src->texture;
   struct pipe_texture *dpt = &dst_tex->base;
   struct pipe_texture *spt = &src_tex->base;
a76 1
                   FALSE,
d78 4
a81 3
                   (unsigned short) src_tex->stride, src_tex->buffer, src->offset,
                   (unsigned short) dst_tex->stride, dst_tex->buffer, dst->offset,
                   (short) srcx, (short) srcy, (short) dstx, (short) dsty, (short) width, (short) height );
d86 5
a90 4
i915_surface_fill(struct pipe_context *pipe,
		  struct pipe_surface *dst,
		  unsigned dstx, unsigned dsty,
		  unsigned width, unsigned height, unsigned value)
d92 4
a95 2
   struct i915_texture *tex = (struct i915_texture *)dst->texture;
   struct pipe_texture *pt = &tex->base;
d100 1
d103 1
d105 1
a105 1
                   tex->buffer, dst->offset,
d108 82
a189 1
                   value );
d196 5
a200 2
   i915->base.surface_copy = i915_surface_copy;
   i915->base.surface_fill = i915_surface_fill;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d28 1
a28 2
#include "i915_surface.h"
#include "i915_resource.h"
a29 2
#include "i915_reg.h"
#include "i915_screen.h"
a30 2
#include "util/u_inlines.h"
#include "util/u_math.h"
a31 2
#include "util/u_memory.h"
#include "util/u_pack_color.h"
d39 9
a47 22
                  struct pipe_resource *dst, unsigned dst_level,
                  unsigned dstx, unsigned dsty, unsigned dstz,
                  struct pipe_resource *src, unsigned src_level,
                  const struct pipe_box *src_box)
{
   struct i915_texture *dst_tex = i915_texture(dst);
   struct i915_texture *src_tex = i915_texture(src);
   struct pipe_resource *dpt = &dst_tex->b.b;
   struct pipe_resource *spt = &src_tex->b.b;
   unsigned dst_offset, src_offset;  /* in bytes */

   /* XXX cannot copy 3d regions at this time */
   assert(src_box->depth == 1);
   if (dst->target != PIPE_TEXTURE_CUBE &&
       dst->target != PIPE_TEXTURE_3D)
      assert(dstz == 0);
   dst_offset = i915_texture_offset(dst_tex, dst_level, dstz);

   if (src->target != PIPE_TEXTURE_CUBE &&
       src->target != PIPE_TEXTURE_3D)
      assert(src_box->z == 0);
   src_offset = i915_texture_offset(src_tex, src_level, src_box->z);
d57 1
d59 3
a61 4
                   (unsigned short) src_tex->stride, src_tex->buffer, src_offset,
                   (unsigned short) dst_tex->stride, dst_tex->buffer, dst_offset,
                   (short) src_box->x, (short) src_box->y, (short) dstx, (short) dsty,
                   (short) src_box->width, (short) src_box->height );
d66 4
a69 5
i915_clear_render_target(struct pipe_context *pipe,
                         struct pipe_surface *dst,
                         const float *rgba,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
d71 2
a72 4
   struct i915_texture *tex = i915_texture(dst->texture);
   struct pipe_resource *pt = &tex->b.b;
   union util_color uc;
   unsigned offset = i915_texture_offset(tex, dst->u.tex.level, dst->u.tex.first_layer);
a76 1
   util_pack_color(rgba, dst->format, &uc);
a78 1
                   XY_COLOR_BLT_WRITE_ALPHA | XY_COLOR_BLT_WRITE_RGB,
d80 1
a80 1
                   tex->buffer, offset,
d83 1
a83 82
                   uc.ui );
}

static void
i915_clear_depth_stencil(struct pipe_context *pipe,
                         struct pipe_surface *dst,
                         unsigned clear_flags,
                         double depth,
                         unsigned stencil,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
{
   struct i915_texture *tex = i915_texture(dst->texture);
   struct pipe_resource *pt = &tex->b.b;
   unsigned packedds;
   unsigned mask = 0;
   unsigned offset = i915_texture_offset(tex, dst->u.tex.level, dst->u.tex.first_layer);

   assert(util_format_get_blockwidth(pt->format) == 1);
   assert(util_format_get_blockheight(pt->format) == 1);

   packedds = util_pack_z_stencil(dst->format, depth, stencil);

   if (clear_flags & PIPE_CLEAR_DEPTH)
      mask |= XY_COLOR_BLT_WRITE_RGB;
   /* XXX presumably this does read-modify-write
      (otherwise this won't work anyway). Hence will only want to
      do it if really have stencil and it isn't cleared */
   if ((clear_flags & PIPE_CLEAR_STENCIL) ||
       (dst->format != PIPE_FORMAT_Z24_UNORM_S8_USCALED))
      mask |= XY_COLOR_BLT_WRITE_ALPHA;

   i915_fill_blit( i915_context(pipe),
                   util_format_get_blocksize(pt->format),
                   mask,
                   (unsigned short) tex->stride,
                   tex->buffer, offset,
                   (short) dstx, (short) dsty,
                   (short) width, (short) height,
                   packedds );
}

/*
 * Screen surface functions
 */


static struct pipe_surface *
i915_create_surface(struct pipe_context *ctx,
                    struct pipe_resource *pt,
                    const struct pipe_surface *surf_tmpl)
{
   struct pipe_surface *ps;

   assert(surf_tmpl->u.tex.first_layer == surf_tmpl->u.tex.last_layer);
   if (pt->target != PIPE_TEXTURE_CUBE &&
       pt->target != PIPE_TEXTURE_3D)
      assert(surf_tmpl->u.tex.first_layer == 0);

   ps = CALLOC_STRUCT(pipe_surface);
   if (ps) {
      /* could subclass pipe_surface and store offset as it used to do */
      pipe_reference_init(&ps->reference, 1);
      pipe_resource_reference(&ps->texture, pt);
      ps->format = surf_tmpl->format;
      ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
      ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
      ps->u.tex.level = surf_tmpl->u.tex.level;
      ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
      ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
      ps->usage = surf_tmpl->usage;
      ps->context = ctx;
   }
   return ps;
}

static void
i915_surface_destroy(struct pipe_context *ctx,
                     struct pipe_surface *surf)
{
   pipe_resource_reference(&surf->texture, NULL);
   FREE(surf);
d90 2
a91 5
   i915->base.resource_copy_region = i915_surface_copy;
   i915->base.clear_render_target = i915_clear_render_target;
   i915->base.clear_depth_stencil = i915_clear_depth_stencil;
   i915->base.create_surface = i915_create_surface;
   i915->base.surface_destroy = i915_surface_destroy;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a29 1
#include "i915_state.h"
a38 1
#include "util/u_surface.h"
a39 123
/*
 * surface functions using the render engine
 */

static void
i915_util_blitter_save_states(struct i915_context *i915)
{
   util_blitter_save_blend(i915->blitter, (void *)i915->blend);
   util_blitter_save_depth_stencil_alpha(i915->blitter, (void *)i915->depth_stencil);
   util_blitter_save_stencil_ref(i915->blitter, &i915->stencil_ref);
   util_blitter_save_rasterizer(i915->blitter, (void *)i915->rasterizer);
   util_blitter_save_fragment_shader(i915->blitter, i915->fs);
   util_blitter_save_vertex_shader(i915->blitter, i915->vs);
   util_blitter_save_viewport(i915->blitter, &i915->viewport);
   util_blitter_save_scissor(i915->blitter, &i915->scissor);
   util_blitter_save_vertex_elements(i915->blitter, i915->velems);
   util_blitter_save_vertex_buffer_slot(i915->blitter,
                                    i915->vertex_buffers);

   util_blitter_save_framebuffer(i915->blitter, &i915->framebuffer);

   util_blitter_save_fragment_sampler_states(i915->blitter,
                                             i915->num_samplers,
                                             (void**)i915->sampler);
   util_blitter_save_fragment_sampler_views(i915->blitter,
                                            i915->num_fragment_sampler_views,
                                            i915->fragment_sampler_views);
}

static void
i915_surface_copy_render(struct pipe_context *pipe,
                         struct pipe_resource *dst, unsigned dst_level,
                         unsigned dstx, unsigned dsty, unsigned dstz,
                         struct pipe_resource *src, unsigned src_level,
                         const struct pipe_box *src_box)
{
   struct i915_context *i915 = i915_context(pipe);

   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }

   if (!util_blitter_is_copy_supported(i915->blitter, dst, src,
                                       PIPE_MASK_RGBAZS)) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }

   i915_util_blitter_save_states(i915);

   util_blitter_copy_texture(i915->blitter, dst, dst_level, dstx, dsty, dstz,
                            src, src_level, src_box, PIPE_MASK_RGBAZS, TRUE);
}

static void
i915_clear_render_target_render(struct pipe_context *pipe,
                                struct pipe_surface *dst,
                                const union pipe_color_union *color,
                                unsigned dstx, unsigned dsty,
                                unsigned width, unsigned height)
{
   struct i915_context *i915 = i915_context(pipe);
   struct pipe_framebuffer_state fb_state;

   util_blitter_save_framebuffer(i915->blitter, &i915->framebuffer);

   fb_state.width = dst->width;
   fb_state.height = dst->height;
   fb_state.nr_cbufs = 1;
   fb_state.cbufs[0] = dst;
   fb_state.zsbuf = NULL;
   pipe->set_framebuffer_state(pipe, &fb_state);

   if (i915->dirty)
      i915_update_derived(i915);

   i915_clear_emit(pipe, PIPE_CLEAR_COLOR, color, 0.0, 0x0,
                   dstx, dsty, width, height);

   pipe->set_framebuffer_state(pipe, &i915->blitter->saved_fb_state);
   util_unreference_framebuffer_state(&i915->blitter->saved_fb_state);
   i915->blitter->saved_fb_state.nr_cbufs = ~0;
}

static void
i915_clear_depth_stencil_render(struct pipe_context *pipe,
                                struct pipe_surface *dst,
                                unsigned clear_flags,
                                double depth,
                                unsigned stencil,
                                unsigned dstx, unsigned dsty,
                                unsigned width, unsigned height)
{
   struct i915_context *i915 = i915_context(pipe);
   struct pipe_framebuffer_state fb_state;

   util_blitter_save_framebuffer(i915->blitter, &i915->framebuffer);

   fb_state.width = dst->width;
   fb_state.height = dst->height;
   fb_state.nr_cbufs = 0;
   fb_state.zsbuf = dst;
   pipe->set_framebuffer_state(pipe, &fb_state);

   if (i915->dirty)
      i915_update_derived(i915);

   i915_clear_emit(pipe, clear_flags & PIPE_CLEAR_DEPTHSTENCIL,
                   NULL, depth, stencil,
                   dstx, dsty, width, height);

   pipe->set_framebuffer_state(pipe, &i915->blitter->saved_fb_state);
   util_unreference_framebuffer_state(&i915->blitter->saved_fb_state);
   i915->blitter->saved_fb_state.nr_cbufs = ~0;
}

/*
 * surface functions using the blitter
 */
d45 5
a49 5
i915_surface_copy_blitter(struct pipe_context *pipe,
                          struct pipe_resource *dst, unsigned dst_level,
                          unsigned dstx, unsigned dsty, unsigned dstz,
                          struct pipe_resource *src, unsigned src_level,
                          const struct pipe_box *src_box)
a56 7
   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }

d69 1
a83 26
static void
i915_blit(struct pipe_context *pipe, const struct pipe_blit_info *blit_info)
{
   struct i915_context *i915 = i915_context(pipe);
   struct pipe_blit_info info = *blit_info;

   if (util_try_blit_via_copy_region(pipe, &info)) {
      return; /* done */
   }

   if (info.mask & PIPE_MASK_S) {
      debug_printf("i915: cannot blit stencil, skipping\n");
      info.mask &= ~PIPE_MASK_S;
   }

   if (!util_blitter_is_blit_supported(i915->blitter, &info)) {
      debug_printf("i915: blit unsupported %s -> %s\n",
                   util_format_short_name(info.src.resource->format),
                   util_format_short_name(info.dst.resource->format));
      return;
   }

   i915_util_blitter_save_states(i915);

   util_blitter_blit(i915->blitter, &info);
}
d86 5
a90 5
i915_clear_render_target_blitter(struct pipe_context *pipe,
                                 struct pipe_surface *dst,
                                 const union pipe_color_union *color,
                                 unsigned dstx, unsigned dsty,
                                 unsigned width, unsigned height)
d100 1
a100 1
   util_pack_color(color->f, dst->format, &uc);
d112 7
a118 7
i915_clear_depth_stencil_blitter(struct pipe_context *pipe,
                                 struct pipe_surface *dst,
                                 unsigned clear_flags,
                                 double depth,
                                 unsigned stencil,
                                 unsigned dstx, unsigned dsty,
                                 unsigned width, unsigned height)
d137 1
a137 1
       (dst->format != PIPE_FORMAT_Z24_UNORM_S8_UINT))
d178 1
d196 3
a198 10
   if (i915_screen(i915->base.screen)->debug.use_blitter) {
      i915->base.resource_copy_region = i915_surface_copy_blitter;
      i915->base.clear_render_target = i915_clear_render_target_blitter;
      i915->base.clear_depth_stencil = i915_clear_depth_stencil_blitter;
   } else {
      i915->base.resource_copy_region = i915_surface_copy_render;
      i915->base.clear_render_target = i915_clear_render_target_render;
      i915->base.clear_depth_stencil = i915_clear_depth_stencil_render;
   }
   i915->base.blit = i915_blit;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d65 1
a65 1
                                             (void**)i915->fragment_sampler);
d87 2
a88 1
   if (!util_blitter_is_copy_supported(i915->blitter, dst, src)) {
d97 1
a97 1
                            src, src_level, src_box);
a242 5
i915_flush_resource(struct pipe_context *ctx, struct pipe_resource *resource)
{
}

static void
d265 1
a265 1
                   uc.ui[0] );
a361 1
   i915->base.flush_resource = i915_flush_resource;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a41 6
static struct pipe_surface *
i915_create_surface_custom(struct pipe_context *ctx,
                           struct pipe_resource *pt,
                           const struct pipe_surface *surf_tmpl,
                           unsigned width0,
                           unsigned height0);
d70 1
a70 1
#
a78 12
   unsigned src_width0 = src->width0;
   unsigned src_height0 = src->height0;
   unsigned dst_width0 = dst->width0;
   unsigned dst_height0 = dst->height0;
   struct pipe_box dstbox;
   struct pipe_sampler_view src_templ, *src_view;
   struct pipe_surface dst_templ, *dst_view;

   /* Fallback for buffers and npot. */
   if ((dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) ||
       !util_is_power_of_two(src_width0) || !util_is_power_of_two(src_height0))
      goto fallback;
d80 6
a85 2
   util_blitter_default_dst_texture(&dst_templ, dst, dst_level, dstz);
   util_blitter_default_src_texture(&src_templ, src, src_level);
d87 5
a91 2
   if (!util_blitter_is_copy_supported(i915->blitter, dst, src))
      goto fallback;
d95 3
a97 15
   dst_view = i915_create_surface_custom(pipe, dst, &dst_templ, dst_width0, dst_height0);
   src_view = i915_create_sampler_view_custom(pipe, src, &src_templ, src_width0, src_height0);

   u_box_3d(dstx, dsty, dstz, abs(src_box->width), abs(src_box->height),
            abs(src_box->depth), &dstbox);

   util_blitter_blit_generic(i915->blitter, dst_view, &dstbox,
                             src_view, src_box, src_width0, src_height0,
                             PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL);
   return;

fallback:
   util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                             src, src_level, src_box);
 }
d317 3
a319 5
i915_create_surface_custom(struct pipe_context *ctx,
                           struct pipe_resource *pt,
                           const struct pipe_surface *surf_tmpl,
                           unsigned width0,
                           unsigned height0)
d334 2
a335 2
      ps->width = u_minify(width0, surf_tmpl->u.tex.level);
      ps->height = u_minify(height0, surf_tmpl->u.tex.level);
a341 9
}

static struct pipe_surface *
i915_create_surface(struct pipe_context *ctx,
                    struct pipe_resource *pt,
                    const struct pipe_surface *surf_tmpl)
{
   return i915_create_surface_custom(ctx, pt, surf_tmpl,
                                     pt->width0, pt->height0);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d42 6
d76 1
a76 1

d85 12
d98 2
a99 6
   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }
d101 2
a102 5
   if (!util_blitter_is_copy_supported(i915->blitter, dst, src)) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }
d106 15
a120 3
   util_blitter_copy_texture(i915->blitter, dst, dst_level, dstx, dsty, dstz,
                            src, src_level, src_box);
}
d340 5
a344 3
i915_create_surface(struct pipe_context *ctx,
                    struct pipe_resource *pt,
                    const struct pipe_surface *surf_tmpl)
d359 2
a360 2
      ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
      ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
d367 9
@


