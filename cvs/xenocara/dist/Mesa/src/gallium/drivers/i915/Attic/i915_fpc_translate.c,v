head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.10
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.12;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.08;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.52;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


#include <stdarg.h>

#include "i915_reg.h"
#include "i915_context.h"
#include "i915_fpc.h"
#include "i915_debug_private.h"

#include "pipe/p_shader_tokens.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_string.h"
#include "tgsi/tgsi_parse.h"
#include "tgsi/tgsi_dump.h"

#include "draw/draw_vertex.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/**
 * Simple pass-through fragment shader to use when we don't have
 * a real shader (or it fails to compile for some reason).
 */
static unsigned passthrough_decl[] =
{
   _3DSTATE_PIXEL_SHADER_PROGRAM | ((2*3)-1),

   /* declare input color:
    */
   (D0_DCL |
    (REG_TYPE_T << D0_TYPE_SHIFT) |
    (T_DIFFUSE << D0_NR_SHIFT) |
    D0_CHANNEL_ALL),
   0,
   0,
};

static unsigned passthrough_program[] =
{
   /* move to output color:
    */
   (A0_MOV |
    (REG_TYPE_OC << A0_DEST_TYPE_SHIFT) |
    A0_DEST_CHANNEL_ALL |
    (REG_TYPE_T << A0_SRC0_TYPE_SHIFT) |
    (T_DIFFUSE << A0_SRC0_NR_SHIFT)),
   0x01230000,			/* .xyzw */
   0
};


/* 1, -1/3!, 1/5!, -1/7! */
static const float scs_sin_constants[4] = { 1.0,
   -1.0f / (3 * 2 * 1),
   1.0f / (5 * 4 * 3 * 2 * 1),
   -1.0f / (7 * 6 * 5 * 4 * 3 * 2 * 1)
};

/* 1, -1/2!, 1/4!, -1/6! */
static const float scs_cos_constants[4] = { 1.0,
   -1.0f / (2 * 1),
   1.0f / (4 * 3 * 2 * 1),
   -1.0f / (6 * 5 * 4 * 3 * 2 * 1)
};

/* 2*pi, -(2*pi)^3/3!, (2*pi)^5/5!, -(2*pi)^7/7! */
static const float sin_constants[4] = { 2.0 * M_PI,
   -8.0f * M_PI * M_PI * M_PI / (3 * 2 * 1),
   32.0f * M_PI * M_PI * M_PI * M_PI * M_PI / (5 * 4 * 3 * 2 * 1),
   -128.0f * M_PI * M_PI * M_PI * M_PI * M_PI * M_PI * M_PI / (7 * 6 * 5 * 4 * 3 * 2 * 1)
};

/* 1, -(2*pi)^2/2!, (2*pi)^4/4!, -(2*pi)^6/6! */
static const float cos_constants[4] = { 1.0,
   -4.0f * M_PI * M_PI / (2 * 1),
   16.0f * M_PI * M_PI * M_PI * M_PI / (4 * 3 * 2 * 1),
   -64.0f * M_PI * M_PI * M_PI * M_PI * M_PI * M_PI / (6 * 5 * 4 * 3 * 2 * 1)
};



/**
 * component-wise negation of ureg
 */
static INLINE int
negate(int reg, int x, int y, int z, int w)
{
   /* Another neat thing about the UREG representation */
   return reg ^ (((x & 1) << UREG_CHANNEL_X_NEGATE_SHIFT) |
                 ((y & 1) << UREG_CHANNEL_Y_NEGATE_SHIFT) |
                 ((z & 1) << UREG_CHANNEL_Z_NEGATE_SHIFT) |
                 ((w & 1) << UREG_CHANNEL_W_NEGATE_SHIFT));
}


/**
 * In the event of a translation failure, we'll generate a simple color
 * pass-through program.
 */
static void
i915_use_passthrough_shader(struct i915_fragment_shader *fs)
{
   fs->program = (uint *) MALLOC(sizeof(passthrough_program));
   fs->decl = (uint *) MALLOC(sizeof(passthrough_decl));
   if (fs->program) {
      memcpy(fs->program, passthrough_program, sizeof(passthrough_program));
      memcpy(fs->decl, passthrough_decl, sizeof(passthrough_decl));
      fs->program_len = Elements(passthrough_program);
      fs->decl_len = Elements(passthrough_decl);
   }
   fs->num_constants = 0;
}


void
i915_program_error(struct i915_fp_compile *p, const char *msg, ...)
{
   va_list args;
   char buffer[1024];

   debug_printf("i915_program_error: ");
   va_start( args, msg );
   util_vsnprintf( buffer, sizeof(buffer), msg, args );
   va_end( args );
   debug_printf("%s", buffer);
   debug_printf("\n");

   p->error = 1;
}

static uint get_mapping(struct i915_fragment_shader* fs, int unit)
{
   int i;
   for (i = 0; i < I915_TEX_UNITS; i++)
   {
      if (fs->generic_mapping[i] == -1) {
         fs->generic_mapping[i] = unit;
         return i;
      }
      if (fs->generic_mapping[i] == unit)
         return i;
   }
   debug_printf("Exceeded max generics\n");
   return 0;
}

/**
 * Construct a ureg for the given source register.  Will emit
 * constants, apply swizzling and negation as needed.
 */
static uint
src_vector(struct i915_fp_compile *p,
           const struct i915_full_src_register *source,
           struct i915_fragment_shader *fs)
{
   uint index = source->Register.Index;
   uint src = 0, sem_name, sem_ind;

   switch (source->Register.File) {
   case TGSI_FILE_TEMPORARY:
      if (source->Register.Index >= I915_MAX_TEMPORARY) {
         i915_program_error(p, "Exceeded max temporary reg");
         return 0;
      }
      src = UREG(REG_TYPE_R, index);
      break;
   case TGSI_FILE_INPUT:
      /* XXX: Packing COL1, FOGC into a single attribute works for
       * texenv programs, but will fail for real fragment programs
       * that use these attributes and expect them to be a full 4
       * components wide.  Could use a texcoord to pass these
       * attributes if necessary, but that won't work in the general
       * case.
       * 
       * We also use a texture coordinate to pass wpos when possible.
       */

      sem_name = p->shader->info.input_semantic_name[index];
      sem_ind = p->shader->info.input_semantic_index[index];

      switch (sem_name) {
      case TGSI_SEMANTIC_POSITION:
         {
            /* for fragcoord */
            int real_tex_unit = get_mapping(fs, I915_SEMANTIC_POS);
            src = i915_emit_decl(p, REG_TYPE_T, T_TEX0 + real_tex_unit, D0_CHANNEL_ALL);
            break;
         }
      case TGSI_SEMANTIC_COLOR:
         if (sem_ind == 0) {
            src = i915_emit_decl(p, REG_TYPE_T, T_DIFFUSE, D0_CHANNEL_ALL);
         }
         else {
            /* secondary color */
            assert(sem_ind == 1);
            src = i915_emit_decl(p, REG_TYPE_T, T_SPECULAR, D0_CHANNEL_XYZ);
            src = swizzle(src, X, Y, Z, ONE);
         }
         break;
      case TGSI_SEMANTIC_FOG:
         src = i915_emit_decl(p, REG_TYPE_T, T_FOG_W, D0_CHANNEL_W);
         src = swizzle(src, W, W, W, W);
         break;
      case TGSI_SEMANTIC_GENERIC:
         {
            int real_tex_unit = get_mapping(fs, sem_ind);
            src = i915_emit_decl(p, REG_TYPE_T, T_TEX0 + real_tex_unit, D0_CHANNEL_ALL);
            break;
         }
      case TGSI_SEMANTIC_FACE:
         {
            /* for back/front faces */
            int real_tex_unit = get_mapping(fs, I915_SEMANTIC_FACE);
            src = i915_emit_decl(p, REG_TYPE_T, T_TEX0 + real_tex_unit, D0_CHANNEL_X);
            break;
         }
      default:
         i915_program_error(p, "Bad source->Index");
         return 0;
      }
      break;

   case TGSI_FILE_IMMEDIATE:
      assert(index < p->num_immediates);
      index = p->immediates_map[index];
      /* fall-through */
   case TGSI_FILE_CONSTANT:
      src = UREG(REG_TYPE_CONST, index);
      break;

   default:
      i915_program_error(p, "Bad source->File");
      return 0;
   }

   src = swizzle(src,
		 source->Register.SwizzleX,
		 source->Register.SwizzleY,
		 source->Register.SwizzleZ,
		 source->Register.SwizzleW);

   /* There's both negate-all-components and per-component negation.
    * Try to handle both here.
    */
   {
      int n = source->Register.Negate;
      src = negate(src, n, n, n, n);
   }

   /* no abs() */
#if 0
   /* XXX assertions disabled to allow arbfplight.c to run */
   /* XXX enable these assertions, or fix things */
   assert(!source->Register.Absolute);
#endif
   if (source->Register.Absolute)
      debug_printf("Unhandled absolute value\n");

   return src;
}


/**
 * Construct a ureg for a destination register.
 */
static uint
get_result_vector(struct i915_fp_compile *p,
                  const struct i915_full_dst_register *dest)
{
   switch (dest->Register.File) {
   case TGSI_FILE_OUTPUT:
      {
         uint sem_name = p->shader->info.output_semantic_name[dest->Register.Index];
         switch (sem_name) {
         case TGSI_SEMANTIC_POSITION:
            return UREG(REG_TYPE_OD, 0);
         case TGSI_SEMANTIC_COLOR:
            return UREG(REG_TYPE_OC, 0);
         default:
            i915_program_error(p, "Bad inst->DstReg.Index/semantics");
            return 0;
         }
      }
   case TGSI_FILE_TEMPORARY:
      return UREG(REG_TYPE_R, dest->Register.Index);
   default:
      i915_program_error(p, "Bad inst->DstReg.File");
      return 0;
   }
}


/**
 * Compute flags for saturation and writemask.
 */
static uint
get_result_flags(const struct i915_full_instruction *inst)
{
   const uint writeMask
      = inst->Dst[0].Register.WriteMask;
   uint flags = 0x0;

   if (inst->Instruction.Saturate == TGSI_SAT_ZERO_ONE)
      flags |= A0_DEST_SATURATE;

   if (writeMask & TGSI_WRITEMASK_X)
      flags |= A0_DEST_CHANNEL_X;
   if (writeMask & TGSI_WRITEMASK_Y)
      flags |= A0_DEST_CHANNEL_Y;
   if (writeMask & TGSI_WRITEMASK_Z)
      flags |= A0_DEST_CHANNEL_Z;
   if (writeMask & TGSI_WRITEMASK_W)
      flags |= A0_DEST_CHANNEL_W;

   return flags;
}


/**
 * Convert TGSI_TEXTURE_x token to DO_SAMPLE_TYPE_x token
 */
static uint
translate_tex_src_target(struct i915_fp_compile *p, uint tex)
{
   switch (tex) {
   case TGSI_TEXTURE_SHADOW1D:
      /* fall-through */
   case TGSI_TEXTURE_1D:
      return D0_SAMPLE_TYPE_2D;

   case TGSI_TEXTURE_SHADOW2D:
      /* fall-through */
   case TGSI_TEXTURE_2D:
      return D0_SAMPLE_TYPE_2D;

   case TGSI_TEXTURE_SHADOWRECT:
      /* fall-through */
   case TGSI_TEXTURE_RECT:
      return D0_SAMPLE_TYPE_2D;

   case TGSI_TEXTURE_3D:
      return D0_SAMPLE_TYPE_VOLUME;

   case TGSI_TEXTURE_CUBE:
      return D0_SAMPLE_TYPE_CUBE;

   default:
      i915_program_error(p, "TexSrc type");
      return 0;
   }
}

/**
 * Return the number of coords needed to access a given TGSI_TEXTURE_*
 */
uint
i915_num_coords(uint tex)
{
   switch (tex) {
   case TGSI_TEXTURE_SHADOW1D:
   case TGSI_TEXTURE_1D:
      return 1;

   case TGSI_TEXTURE_SHADOW2D:
   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_SHADOWRECT:
   case TGSI_TEXTURE_RECT:
      return 2;

   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_CUBE:
      return 3;

   default:
      debug_printf("Unknown texture target for num coords");
      return 2;
   }
}


/**
 * Generate texel lookup instruction.
 */
static void
emit_tex(struct i915_fp_compile *p,
         const struct i915_full_instruction *inst,
         uint opcode,
         struct i915_fragment_shader* fs)
{
   uint texture = inst->Texture.Texture;
   uint unit = inst->Src[1].Register.Index;
   uint tex = translate_tex_src_target( p, texture );
   uint sampler = i915_emit_decl(p, REG_TYPE_S, unit, tex);
   uint coord = src_vector( p, &inst->Src[0], fs);

   i915_emit_texld( p,
                    get_result_vector( p, &inst->Dst[0] ),
                    get_result_flags( inst ),
                    sampler,
                    coord,
                    opcode,
                    i915_num_coords(texture) );
}


/**
 * Generate a simple arithmetic instruction
 * \param opcode  the i915 opcode
 * \param numArgs  the number of input/src arguments
 */
static void
emit_simple_arith(struct i915_fp_compile *p,
                  const struct i915_full_instruction *inst,
                  uint opcode, uint numArgs,
                  struct i915_fragment_shader *fs)
{
   uint arg1, arg2, arg3;

   assert(numArgs <= 3);

   arg1 = (numArgs < 1) ? 0 : src_vector( p, &inst->Src[0], fs );
   arg2 = (numArgs < 2) ? 0 : src_vector( p, &inst->Src[1], fs );
   arg3 = (numArgs < 3) ? 0 : src_vector( p, &inst->Src[2], fs );

   i915_emit_arith( p,
                    opcode,
                    get_result_vector( p, &inst->Dst[0]),
                    get_result_flags( inst ), 0,
                    arg1,
                    arg2,
                    arg3 );
}


/** As above, but swap the first two src regs */
static void
emit_simple_arith_swap2(struct i915_fp_compile *p,
                        const struct i915_full_instruction *inst,
                        uint opcode, uint numArgs,
                        struct i915_fragment_shader *fs)
{
   struct i915_full_instruction inst2;

   assert(numArgs == 2);

   /* transpose first two registers */
   inst2 = *inst;
   inst2.Src[0] = inst->Src[1];
   inst2.Src[1] = inst->Src[0];

   emit_simple_arith(p, &inst2, opcode, numArgs, fs);
}

/*
 * Translate TGSI instruction to i915 instruction.
 *
 * Possible concerns:
 *
 * DDX, DDY -- return 0
 * SIN, COS -- could use another taylor step?
 * LIT      -- results seem a little different to sw mesa
 * LOG      -- different to mesa on negative numbers, but this is conformant.
 */
static void
i915_translate_instruction(struct i915_fp_compile *p,
                           const struct i915_full_instruction *inst,
                           struct i915_fragment_shader *fs)
{
   uint writemask;
   uint src0, src1, src2, flags;
   uint tmp = 0;

   switch (inst->Instruction.Opcode) {
   case TGSI_OPCODE_ABS:
      src0 = src_vector(p, &inst->Src[0], fs);
      i915_emit_arith(p,
                      A0_MAX,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      src0, negate(src0, 1, 1, 1, 1), 0);
      break;

   case TGSI_OPCODE_ADD:
      emit_simple_arith(p, inst, A0_ADD, 2, fs);
      break;

   case TGSI_OPCODE_CEIL:
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);
      flags = get_result_flags(inst);
      i915_emit_arith(p,
                      A0_FLR,
                      tmp,
                      flags & A0_DEST_CHANNEL_ALL, 0,
                      negate(src0, 1, 1, 1, 1), 0, 0);
      i915_emit_arith(p,
                      A0_MOV,
                      get_result_vector(p, &inst->Dst[0]),
                      flags, 0,
                      negate(tmp, 1, 1, 1, 1), 0, 0);
      break;

   case TGSI_OPCODE_CMP:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      src2 = src_vector(p, &inst->Src[2], fs);
      i915_emit_arith(p, A0_CMP,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst),
                      0, src0, src2, src1);   /* NOTE: order of src2, src1 */
      break;

   case TGSI_OPCODE_COS:
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_X, 0,
                      src0, i915_emit_const1f(p, 1.0f / (float) (M_PI * 2.0)), 0);

      i915_emit_arith(p, A0_MOD, tmp, A0_DEST_CHANNEL_X, 0, tmp, 0, 0);

      /* 
       * t0.xy = MUL x.xx11, x.x111  ; x^2, x, 1, 1
       * t0 = MUL t0.xyxy t0.xx11 ; x^4, x^3, x^2, 1
       * t0 = MUL t0.xxz1 t0.z111    ; x^6 x^4 x^2 1
       * result = DP4 t0, cos_constants
       */
      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_XY, 0,
                      swizzle(tmp, X, X, ONE, ONE),
                      swizzle(tmp, X, ONE, ONE, ONE), 0);

      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_XYZ, 0,
                      swizzle(tmp, X, Y, X, ONE),
                      swizzle(tmp, X, X, ONE, ONE), 0);

      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_XYZ, 0,
                      swizzle(tmp, X, X, Z, ONE),
                      swizzle(tmp, Z, ONE, ONE, ONE), 0);

      i915_emit_arith(p,
                      A0_DP4,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(tmp, ONE, Z, Y, X),
                      i915_emit_const4fv(p, cos_constants), 0);
      break;

  case TGSI_OPCODE_DDX:
  case TGSI_OPCODE_DDY:
      /* XXX We just output 0 here */
      debug_printf("Punting DDX/DDX\n");
      src0 = get_result_vector(p, &inst->Dst[0]);
      i915_emit_arith(p,
                      A0_MOV,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, ZERO, ZERO, ZERO, ZERO), 0, 0);
      break;

  case TGSI_OPCODE_DP2:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);

      i915_emit_arith(p,
                      A0_DP3,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, X, Y, ZERO, ZERO), src1, 0);
      break;

   case TGSI_OPCODE_DP3:
      emit_simple_arith(p, inst, A0_DP3, 2, fs);
      break;

   case TGSI_OPCODE_DP4:
      emit_simple_arith(p, inst, A0_DP4, 2, fs);
      break;

   case TGSI_OPCODE_DPH:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);

      i915_emit_arith(p,
                      A0_DP4,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, X, Y, Z, ONE), src1, 0);
      break;

   case TGSI_OPCODE_DST:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);

      /* result[0] = 1    * 1;
       * result[1] = a[1] * b[1];
       * result[2] = a[2] * 1;
       * result[3] = 1    * b[3];
       */
      i915_emit_arith(p,
                      A0_MUL,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, ONE, Y, Z, ONE),
                      swizzle(src1, ONE, Y, ONE, W), 0);
      break;

   case TGSI_OPCODE_END:
      /* no-op */
      break;

   case TGSI_OPCODE_EX2:
      src0 = src_vector(p, &inst->Src[0], fs);

      i915_emit_arith(p,
                      A0_EXP,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, X, X, X, X), 0, 0);
      break;

   case TGSI_OPCODE_FLR:
      emit_simple_arith(p, inst, A0_FLR, 1, fs);
      break;

   case TGSI_OPCODE_FRC:
      emit_simple_arith(p, inst, A0_FRC, 1, fs);
      break;

   case TGSI_OPCODE_KILL_IF:
      /* kill if src[0].x < 0 || src[0].y < 0 ... */
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);

      i915_emit_texld(p,
                      tmp,                   /* dest reg: a dummy reg */
                      A0_DEST_CHANNEL_ALL,   /* dest writemask */
                      0,                     /* sampler */
                      src0,                  /* coord*/
                      T0_TEXKILL,            /* opcode */
                      1);                    /* num_coord */
      break;

   case TGSI_OPCODE_KILL:
      /* unconditional kill */
      tmp = i915_get_utemp(p);

      i915_emit_texld(p,
                      tmp,                                   /* dest reg: a dummy reg */
                      A0_DEST_CHANNEL_ALL,                   /* dest writemask */
                      0,                                     /* sampler */
                      negate(swizzle(0, ONE, ONE, ONE, ONE), 1, 1, 1, 1), /* coord */
                      T0_TEXKILL,                            /* opcode */
                      1);                                    /* num_coord */
      break;

   case TGSI_OPCODE_LG2:
      src0 = src_vector(p, &inst->Src[0], fs);

      i915_emit_arith(p,
                      A0_LOG,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, X, X, X, X), 0, 0);
      break;

   case TGSI_OPCODE_LIT:
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);

      /* tmp = max( a.xyzw, a.00zw )
       * XXX: Clamp tmp.w to -128..128
       * tmp.y = log(tmp.y)
       * tmp.y = tmp.w * tmp.y
       * tmp.y = exp(tmp.y)
       * result = cmp (a.11-x1, a.1x01, a.1xy1 )
       */
      i915_emit_arith(p, A0_MAX, tmp, A0_DEST_CHANNEL_ALL, 0,
                      src0, swizzle(src0, ZERO, ZERO, Z, W), 0);

      i915_emit_arith(p, A0_LOG, tmp, A0_DEST_CHANNEL_Y, 0,
                      swizzle(tmp, Y, Y, Y, Y), 0, 0);

      i915_emit_arith(p, A0_MUL, tmp, A0_DEST_CHANNEL_Y, 0,
                      swizzle(tmp, ZERO, Y, ZERO, ZERO),
                      swizzle(tmp, ZERO, W, ZERO, ZERO), 0);

      i915_emit_arith(p, A0_EXP, tmp, A0_DEST_CHANNEL_Y, 0,
                      swizzle(tmp, Y, Y, Y, Y), 0, 0);

      i915_emit_arith(p, A0_CMP,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      negate(swizzle(tmp, ONE, ONE, X, ONE), 0, 0, 1, 0),
                      swizzle(tmp, ONE, X, ZERO, ONE),
                      swizzle(tmp, ONE, X, Y, ONE));

      break;

   case TGSI_OPCODE_LRP:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      src2 = src_vector(p, &inst->Src[2], fs);
      flags = get_result_flags(inst);
      tmp = i915_get_utemp(p);

      /* b*a + c*(1-a)
       *
       * b*a + c - ca 
       *
       * tmp = b*a + c, 
       * result = (-c)*a + tmp 
       */
      i915_emit_arith(p, A0_MAD, tmp,
                      flags & A0_DEST_CHANNEL_ALL, 0, src1, src0, src2);

      i915_emit_arith(p, A0_MAD,
                      get_result_vector(p, &inst->Dst[0]),
                      flags, 0, negate(src2, 1, 1, 1, 1), src0, tmp);
      break;

   case TGSI_OPCODE_MAD:
      emit_simple_arith(p, inst, A0_MAD, 3, fs);
      break;

   case TGSI_OPCODE_MAX:
      emit_simple_arith(p, inst, A0_MAX, 2, fs);
      break;

   case TGSI_OPCODE_MIN:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      tmp = i915_get_utemp(p);
      flags = get_result_flags(inst);

      i915_emit_arith(p,
                      A0_MAX,
                      tmp, flags & A0_DEST_CHANNEL_ALL, 0,
                      negate(src0, 1, 1, 1, 1),
                      negate(src1, 1, 1, 1, 1), 0);

      i915_emit_arith(p,
                      A0_MOV,
                      get_result_vector(p, &inst->Dst[0]),
                      flags, 0, negate(tmp, 1, 1, 1, 1), 0, 0);
      break;

   case TGSI_OPCODE_MOV:
      emit_simple_arith(p, inst, A0_MOV, 1, fs);
      break;

   case TGSI_OPCODE_MUL:
      emit_simple_arith(p, inst, A0_MUL, 2, fs);
      break;

   case TGSI_OPCODE_NOP:
      break;

   case TGSI_OPCODE_POW:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      tmp = i915_get_utemp(p);
      flags = get_result_flags(inst);

      /* XXX: masking on intermediate values, here and elsewhere.
       */
      i915_emit_arith(p,
                      A0_LOG,
                      tmp, A0_DEST_CHANNEL_X, 0,
                      swizzle(src0, X, X, X, X), 0, 0);

      i915_emit_arith(p, A0_MUL, tmp, A0_DEST_CHANNEL_X, 0, tmp, src1, 0);

      i915_emit_arith(p,
                      A0_EXP,
                      get_result_vector(p, &inst->Dst[0]),
                      flags, 0, swizzle(tmp, X, X, X, X), 0, 0);
      break;

   case TGSI_OPCODE_RET:
      /* XXX: no-op? */
      break;

   case TGSI_OPCODE_RCP:
      src0 = src_vector(p, &inst->Src[0], fs);

      i915_emit_arith(p,
                      A0_RCP,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, X, X, X, X), 0, 0);
      break;

   case TGSI_OPCODE_RSQ:
      src0 = src_vector(p, &inst->Src[0], fs);

      i915_emit_arith(p,
                      A0_RSQ,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, X, X, X, X), 0, 0);
      break;

   case TGSI_OPCODE_SCS:
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);

      /* 
       * t0.xy = MUL x.xx11, x.x1111  ; x^2, x, 1, 1
       * t0 = MUL t0.xyxy t0.xx11 ; x^4, x^3, x^2, x
       * t1 = MUL t0.xyyw t0.yz11    ; x^7 x^5 x^3 x
       * scs.x = DP4 t1, scs_sin_constants
       * t1 = MUL t0.xxz1 t0.z111    ; x^6 x^4 x^2 1
       * scs.y = DP4 t1, scs_cos_constants
       */
      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_XY, 0,
                      swizzle(src0, X, X, ONE, ONE),
                      swizzle(src0, X, ONE, ONE, ONE), 0);

      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_ALL, 0,
                      swizzle(tmp, X, Y, X, Y),
                      swizzle(tmp, X, X, ONE, ONE), 0);

      writemask = inst->Dst[0].Register.WriteMask;

      if (writemask & TGSI_WRITEMASK_Y) {
         uint tmp1;

         if (writemask & TGSI_WRITEMASK_X)
            tmp1 = i915_get_utemp(p);
         else
            tmp1 = tmp;

         i915_emit_arith(p,
                         A0_MUL,
                         tmp1, A0_DEST_CHANNEL_ALL, 0,
                         swizzle(tmp, X, Y, Y, W),
                         swizzle(tmp, X, Z, ONE, ONE), 0);

         i915_emit_arith(p,
                         A0_DP4,
                         get_result_vector(p, &inst->Dst[0]),
                         A0_DEST_CHANNEL_Y, 0,
                         swizzle(tmp1, W, Z, Y, X),
                         i915_emit_const4fv(p, scs_sin_constants), 0);
      }

      if (writemask & TGSI_WRITEMASK_X) {
         i915_emit_arith(p,
                         A0_MUL,
                         tmp, A0_DEST_CHANNEL_XYZ, 0,
                         swizzle(tmp, X, X, Z, ONE),
                         swizzle(tmp, Z, ONE, ONE, ONE), 0);

         i915_emit_arith(p,
                         A0_DP4,
                         get_result_vector(p, &inst->Dst[0]),
                         A0_DEST_CHANNEL_X, 0,
                         swizzle(tmp, ONE, Z, Y, X),
                         i915_emit_const4fv(p, scs_cos_constants), 0);
      }
      break;

   case TGSI_OPCODE_SEQ:
      /* if we're both >= and <= then we're == */
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_SGE,
                      tmp, A0_DEST_CHANNEL_ALL, 0,
                      src0,
                      src1, 0);

      i915_emit_arith(p,
                      A0_SGE,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      src1,
                      src0, 0);

      i915_emit_arith(p,
                      A0_MUL,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      get_result_vector(p, &inst->Dst[0]),
                      tmp, 0);

      break;

   case TGSI_OPCODE_SGE:
      emit_simple_arith(p, inst, A0_SGE, 2, fs);
      break;

   case TGSI_OPCODE_SIN:
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_X, 0,
                      src0, i915_emit_const1f(p, 1.0f / (float) (M_PI * 2.0)), 0);

      i915_emit_arith(p, A0_MOD, tmp, A0_DEST_CHANNEL_X, 0, tmp, 0, 0);

      /* 
       * t0.xy = MUL x.xx11, x.x1111  ; x^2, x, 1, 1
       * t0 = MUL t0.xyxy t0.xx11 ; x^4, x^3, x^2, x
       * t1 = MUL t0.xyyw t0.yz11    ; x^7 x^5 x^3 x
       * result = DP4 t1.wzyx, sin_constants
       */
      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_XY, 0,
                      swizzle(tmp, X, X, ONE, ONE),
                      swizzle(tmp, X, ONE, ONE, ONE), 0);

      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_ALL, 0,
                      swizzle(tmp, X, Y, X, Y),
                      swizzle(tmp, X, X, ONE, ONE), 0);

      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_ALL, 0,
                      swizzle(tmp, X, Y, Y, W),
                      swizzle(tmp, X, Z, ONE, ONE), 0);

      i915_emit_arith(p,
                      A0_DP4,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(tmp, W, Z, Y, X),
                      i915_emit_const4fv(p, sin_constants), 0);
      break;

   case TGSI_OPCODE_SLE:
      /* like SGE, but swap reg0, reg1 */
      emit_simple_arith_swap2(p, inst, A0_SGE, 2, fs);
      break;

   case TGSI_OPCODE_SLT:
      emit_simple_arith(p, inst, A0_SLT, 2, fs);
      break;

   case TGSI_OPCODE_SGT:
      /* like SLT, but swap reg0, reg1 */
      emit_simple_arith_swap2(p, inst, A0_SLT, 2, fs);
      break;

   case TGSI_OPCODE_SNE:
      /* if we're < or > then we're != */
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_SLT,
                      tmp,
                      A0_DEST_CHANNEL_ALL, 0,
                      src0,
                      src1, 0);

      i915_emit_arith(p,
                      A0_SLT,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      src1,
                      src0, 0);

      i915_emit_arith(p,
                      A0_ADD,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      get_result_vector(p, &inst->Dst[0]),
                      tmp, 0);
      break;

   case TGSI_OPCODE_SSG:
      /* compute (src>0) - (src<0) */
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_SLT,
                      tmp,
                      A0_DEST_CHANNEL_ALL, 0,
                      src0,
                      swizzle(src0, ZERO, ZERO, ZERO, ZERO), 0);

      i915_emit_arith(p,
                      A0_SLT,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      swizzle(src0, ZERO, ZERO, ZERO, ZERO),
                      src0, 0);

      i915_emit_arith(p,
                      A0_ADD,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      get_result_vector(p, &inst->Dst[0]),
                      negate(tmp, 1, 1, 1, 1), 0);
      break;

   case TGSI_OPCODE_SUB:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);

      i915_emit_arith(p,
                      A0_ADD,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      src0, negate(src1, 1, 1, 1, 1), 0);
      break;

   case TGSI_OPCODE_TEX:
      emit_tex(p, inst, T0_TEXLD, fs);
      break;

   case TGSI_OPCODE_TRUNC:
      emit_simple_arith(p, inst, A0_TRC, 1, fs);
      break;

   case TGSI_OPCODE_TXB:
      emit_tex(p, inst, T0_TEXLDB, fs);
      break;

   case TGSI_OPCODE_TXP:
      emit_tex(p, inst, T0_TEXLDP, fs);
      break;

   case TGSI_OPCODE_XPD:
      /* Cross product:
       *      result.x = src0.y * src1.z - src0.z * src1.y;
       *      result.y = src0.z * src1.x - src0.x * src1.z;
       *      result.z = src0.x * src1.y - src0.y * src1.x;
       *      result.w = undef;
       */
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_ALL, 0,
                      swizzle(src0, Z, X, Y, ONE),
                      swizzle(src1, Y, Z, X, ONE), 0);

      i915_emit_arith(p,
                      A0_MAD,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, Y, Z, X, ONE),
                      swizzle(src1, Z, X, Y, ONE),
                      negate(tmp, 1, 1, 1, 0));
      break;

   default:
      i915_program_error(p, "bad opcode %d", inst->Instruction.Opcode);
      p->error = 1;
      return;
   }

   i915_release_utemps(p);
}


static void i915_translate_token(struct i915_fp_compile *p,
                                 const union i915_full_token *token,
                                 struct i915_fragment_shader *fs)
{
   struct i915_fragment_shader *ifs = p->shader;
   switch( token->Token.Type ) {
   case TGSI_TOKEN_TYPE_PROPERTY:
      /*
       * We only support one cbuf, but we still need to ignore the property
       * correctly so we don't hit the assert at the end of the switch case.
       */
      assert(token->FullProperty.Property.PropertyName ==
             TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS);
      break;

   case TGSI_TOKEN_TYPE_DECLARATION:
      if (token->FullDeclaration.Declaration.File
               == TGSI_FILE_CONSTANT) {
         uint i;
         for (i = token->FullDeclaration.Range.First;
              i <= token->FullDeclaration.Range.Last;
              i++) {
            assert(ifs->constant_flags[i] == 0x0);
            ifs->constant_flags[i] = I915_CONSTFLAG_USER;
            ifs->num_constants = MAX2(ifs->num_constants, i + 1);
         }
      }
      else if (token->FullDeclaration.Declaration.File
               == TGSI_FILE_TEMPORARY) {
         uint i;
         for (i = token->FullDeclaration.Range.First;
              i <= token->FullDeclaration.Range.Last;
              i++) {
            if (i >= I915_MAX_TEMPORARY)
               debug_printf("Too many temps (%d)\n",i);
            else
               /* XXX just use shader->info->file_mask[TGSI_FILE_TEMPORARY] */
               p->temp_flag |= (1 << i); /* mark temp as used */
         }
      }
      break;

   case TGSI_TOKEN_TYPE_IMMEDIATE:
      {
         const struct tgsi_full_immediate *imm
            = &token->FullImmediate;
         const uint pos = p->num_immediates++;
         uint j;
         assert( imm->Immediate.NrTokens <= 4 + 1 );
         for (j = 0; j < imm->Immediate.NrTokens - 1; j++) {
            p->immediates[pos][j] = imm->u[j].Float;
         }
      }
      break;

   case TGSI_TOKEN_TYPE_INSTRUCTION:
      if (p->first_instruction) {
         /* resolve location of immediates */
         uint i, j;
         for (i = 0; i < p->num_immediates; i++) {
            /* find constant slot for this immediate */
            for (j = 0; j < I915_MAX_CONSTANT; j++) {
               if (ifs->constant_flags[j] == 0x0) {
                  memcpy(ifs->constants[j],
                         p->immediates[i],
                         4 * sizeof(float));
                  /*printf("immediate %d maps to const %d\n", i, j);*/
                  ifs->constant_flags[j] = 0xf;  /* all four comps used */
                  p->immediates_map[i] = j;
                  ifs->num_constants = MAX2(ifs->num_constants, j + 1);
                  break;
               }
            }
         }

         p->first_instruction = FALSE;
      }

      i915_translate_instruction(p, &token->FullInstruction, fs);
      break;

   default:
      assert( 0 );
   }

}

/**
 * Translate TGSI fragment shader into i915 hardware instructions.
 * \param p  the translation state
 * \param tokens  the TGSI token array
 */
static void
i915_translate_instructions(struct i915_fp_compile *p,
                            const struct i915_token_list *tokens,
                            struct i915_fragment_shader *fs)
{
   int i;
   for(i = 0; i<tokens->NumTokens; i++) {
      i915_translate_token(p, &tokens->Tokens[i], fs);
   }
}


static struct i915_fp_compile *
i915_init_compile(struct i915_context *i915,
                  struct i915_fragment_shader *ifs)
{
   struct i915_fp_compile *p = CALLOC_STRUCT(i915_fp_compile);
   int i;

   p->shader = ifs;

   /* Put new constants at end of const buffer, growing downward.
    * The problem is we don't know how many user-defined constants might
    * be specified with pipe->set_constant_buffer().
    * Should pre-scan the user's program to determine the highest-numbered
    * constant referenced.
    */
   ifs->num_constants = 0;
   memset(ifs->constant_flags, 0, sizeof(ifs->constant_flags));

   memset(&p->register_phases, 0, sizeof(p->register_phases));

   for (i = 0; i < I915_TEX_UNITS; i++)
      ifs->generic_mapping[i] = -1;

   p->first_instruction = TRUE;

   p->nr_tex_indirect = 1;      /* correct? */
   p->nr_tex_insn = 0;
   p->nr_alu_insn = 0;
   p->nr_decl_insn = 0;

   p->csr = p->program;
   p->decl = p->declarations;
   p->decl_s = 0;
   p->decl_t = 0;
   p->temp_flag = ~0x0 << I915_MAX_TEMPORARY;
   p->utemp_flag = ~0x7;

   /* initialize the first program word */
   *(p->decl++) = _3DSTATE_PIXEL_SHADER_PROGRAM;

   return p;
}


/* Copy compile results to the fragment program struct and destroy the
 * compilation context.
 */
static void
i915_fini_compile(struct i915_context *i915, struct i915_fp_compile *p)
{
   struct i915_fragment_shader *ifs = p->shader;
   unsigned long program_size = (unsigned long) (p->csr - p->program);
   unsigned long decl_size = (unsigned long) (p->decl - p->declarations);

   if (p->nr_tex_indirect > I915_MAX_TEX_INDIRECT)
      debug_printf("Exceeded max nr indirect texture lookups\n");

   if (p->nr_tex_insn > I915_MAX_TEX_INSN)
      i915_program_error(p, "Exceeded max TEX instructions");

   if (p->nr_alu_insn > I915_MAX_ALU_INSN)
      i915_program_error(p, "Exceeded max ALU instructions");

   if (p->nr_decl_insn > I915_MAX_DECL_INSN)
      i915_program_error(p, "Exceeded max DECL instructions");

   if (p->error) {
      p->NumNativeInstructions = 0;
      p->NumNativeAluInstructions = 0;
      p->NumNativeTexInstructions = 0;
      p->NumNativeTexIndirections = 0;

      i915_use_passthrough_shader(ifs);
   }
   else {
      p->NumNativeInstructions
         = p->nr_alu_insn + p->nr_tex_insn + p->nr_decl_insn;
      p->NumNativeAluInstructions = p->nr_alu_insn;
      p->NumNativeTexInstructions = p->nr_tex_insn;
      p->NumNativeTexIndirections = p->nr_tex_indirect;

      /* patch in the program length */
      p->declarations[0] |= program_size + decl_size - 2;

      /* Copy compilation results to fragment program struct: 
       */
      assert(!ifs->decl);
      assert(!ifs->program);

      ifs->decl
         = (uint *) MALLOC(decl_size * sizeof(uint));
      ifs->program
         = (uint *) MALLOC(program_size * sizeof(uint));

      if (ifs->decl) {
         ifs->decl_len = decl_size;

         memcpy(ifs->decl,
                p->declarations,
                decl_size * sizeof(uint));
      }

      if (ifs->program) {
         ifs->program_len = program_size;

         memcpy(ifs->program,
                p->program,
                program_size * sizeof(uint));
      }
   }

   /* Release the compilation struct: 
    */
   FREE(p);
}





/**
 * Rather than trying to intercept and jiggle depth writes during
 * emit, just move the value into its correct position at the end of
 * the program:
 */
static void
i915_fixup_depth_write(struct i915_fp_compile *p)
{
   /* XXX assuming pos/depth is always in output[0] */
   if (p->shader->info.output_semantic_name[0] == TGSI_SEMANTIC_POSITION) {
      const uint depth = UREG(REG_TYPE_OD, 0);

      i915_emit_arith(p,
                      A0_MOV,                     /* opcode */
                      depth,                      /* dest reg */
                      A0_DEST_CHANNEL_W,          /* write mask */
                      0,                          /* saturate? */
                      swizzle(depth, X, Y, Z, Z), /* src0 */
                      0, 0 /* src1, src2 */);
   }
}


void
i915_translate_fragment_program( struct i915_context *i915,
                                 struct i915_fragment_shader *fs)
{
   struct i915_fp_compile *p;
   const struct tgsi_token *tokens = fs->state.tokens;
   struct i915_token_list* i_tokens;

#if 0
   tgsi_dump(tokens, 0);
#endif

   /* hw doesn't seem to like empty frag programs, even when the depth write
    * fixup gets emitted below - may that one is fishy, too? */
   if (fs->info.num_instructions == 1) {
      i915_use_passthrough_shader(fs);

      return;
   }

   p = i915_init_compile(i915, fs);

   i_tokens = i915_optimize(tokens);
   i915_translate_instructions(p, i_tokens, fs);
   i915_fixup_depth_write(p);

   i915_fini_compile(i915, p);
   i915_optimize_free(i_tokens);

#if 0
   i915_disassemble_program(NULL, fs->program, fs->program_len);
#endif
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d34 1
d183 1
a183 1
           struct i915_fragment_shader* fs)
d385 2
a386 2
static uint
texture_num_coords(struct i915_fp_compile *p, uint tex)
d404 1
a404 1
      i915_program_error(p, "Num coords");
d431 1
a431 1
                    texture_num_coords(p, texture) );
d444 1
a444 1
                  struct i915_fragment_shader* fs)
d469 1
a469 1
                        struct i915_fragment_shader* fs)
d1112 1
a1112 1
                                 const union i915_full_token* token,
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d44 3
d52 1
a52 1
static unsigned passthrough[] = 
d58 3
a60 3
   (D0_DCL | 
    (REG_TYPE_T << D0_TYPE_SHIFT) | 
    (T_DIFFUSE << D0_NR_SHIFT) | 
d64 1
d66 2
d70 3
a72 3
   (A0_MOV | 
    (REG_TYPE_OC << A0_DEST_TYPE_SHIFT) | 
    A0_DEST_CHANNEL_ALL | 
d81 1
a81 1
static const float sin_constants[4] = { 1.0,
d88 1
a88 1
static const float cos_constants[4] = { 1.0,
d94 14
d131 2
a132 1
   fs->program = (uint *) MALLOC(sizeof(passthrough));
d134 4
a137 2
      memcpy(fs->program, passthrough, sizeof(passthrough));
      fs->program_len = Elements(passthrough);
d150 1
a150 1
   va_start( args, msg );  
d181 1
a181 1
           const struct tgsi_full_src_register *source,
d211 6
a216 6
         debug_printf("SKIP SEM POS\n");
         /*
         assert(p->wpos_tex != -1);
         src = i915_emit_decl(p, REG_TYPE_T, p->wpos_tex, D0_CHANNEL_ALL);
         */
         break;
d238 7
a269 1

d284 3
d296 1
a296 1
                  const struct tgsi_full_dst_register *dest)
d325 1
a325 1
get_result_flags(const struct tgsi_full_instruction *inst)
d381 27
d414 1
a414 1
         const struct tgsi_full_instruction *inst,
d429 2
a430 1
                    opcode);
d441 1
a441 1
                  const struct tgsi_full_instruction *inst,
d466 1
a466 1
                        const struct tgsi_full_instruction *inst,
d470 1
a470 1
   struct tgsi_full_instruction inst2;
a481 5

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

d487 1
d491 1
a491 1
 */ 
d494 1
a494 1
                           const struct tgsi_full_instruction *inst,
d515 16
d535 1
a535 1
      i915_emit_arith(p, A0_CMP, 
d537 1
a537 1
                      get_result_flags(inst), 
a551 7
      /* By choosing different taylor constants, could get rid of this mul:
       */
      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_X, 0,
                      tmp, i915_emit_const1f(p, (float) (M_PI * 2.0)), 0);

d553 1
a553 1
       * t0.xy = MUL x.xx11, x.x1111  ; x^2, x, 1, 1
d584 12
d665 1
a665 1
   case TGSI_OPCODE_KIL:
d675 2
a676 1
                      T0_TEXKILL);           /* opcode */
d679 11
a689 2
   case TGSI_OPCODE_KILP:
      assert(0); /* not tested yet */
d791 3
d814 1
a814 1
      
d818 1
a818 1
      
d847 1
a847 1
       * scs.x = DP4 t1, sin_constants
d849 1
a849 1
       * scs.y = DP4 t1, cos_constants
d884 1
a884 1
                         i915_emit_const4fv(p, sin_constants), 0);
d899 1
a899 1
                         i915_emit_const4fv(p, cos_constants), 0);
a945 7
      /* By choosing different taylor constants, could get rid of this mul:
       */
      i915_emit_arith(p,
                      A0_MUL,
                      tmp, A0_DEST_CHANNEL_X, 0,
                      tmp, i915_emit_const1f(p, (float) (M_PI * 2.0)), 0);

d1110 3
a1112 9
/**
 * Translate TGSI fragment shader into i915 hardware instructions.
 * \param p  the translation state
 * \param tokens  the TGSI token array
 */
static void
i915_translate_instructions(struct i915_fp_compile *p,
                            const struct tgsi_token *tokens,
                            struct i915_fragment_shader *fs)
d1115 9
a1123 1
   struct tgsi_parse_context parse;
d1125 10
a1134 26
   tgsi_parse_init( &parse, tokens );

   while( !tgsi_parse_end_of_tokens( &parse ) ) {

      tgsi_parse_token( &parse );

      switch( parse.FullToken.Token.Type ) {
      case TGSI_TOKEN_TYPE_PROPERTY:
         /*
          * We only support one cbuf, but we still need to ignore the property
          * correctly so we don't hit the assert at the end of the switch case.
          */
         assert(parse.FullToken.FullProperty.Property.PropertyName ==
                TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS);
         break;
      case TGSI_TOKEN_TYPE_DECLARATION:
         if (parse.FullToken.FullDeclaration.Declaration.File
                  == TGSI_FILE_CONSTANT) {
            uint i;
            for (i = parse.FullToken.FullDeclaration.Range.First;
                 i <= parse.FullToken.FullDeclaration.Range.Last;
                 i++) {
               assert(ifs->constant_flags[i] == 0x0);
               ifs->constant_flags[i] = I915_CONSTFLAG_USER;
               ifs->num_constants = MAX2(ifs->num_constants, i + 1);
            }
d1136 10
a1145 7
         else if (parse.FullToken.FullDeclaration.Declaration.File
                  == TGSI_FILE_TEMPORARY) {
            uint i;
            for (i = parse.FullToken.FullDeclaration.Range.First;
                 i <= parse.FullToken.FullDeclaration.Range.Last;
                 i++) {
               assert(i < I915_MAX_TEMPORARY);
a1147 1
            }
d1149 2
a1150 1
         break;
d1152 9
a1160 10
      case TGSI_TOKEN_TYPE_IMMEDIATE:
         {
            const struct tgsi_full_immediate *imm
               = &parse.FullToken.FullImmediate;
            const uint pos = p->num_immediates++;
            uint j;
            assert( imm->Immediate.NrTokens <= 4 + 1 );
            for (j = 0; j < imm->Immediate.NrTokens - 1; j++) {
               p->immediates[pos][j] = imm->u[j].Float;
            }
d1162 2
a1163 1
         break;
d1165 16
a1180 17
      case TGSI_TOKEN_TYPE_INSTRUCTION:
         if (p->first_instruction) {
            /* resolve location of immediates */
            uint i, j;
            for (i = 0; i < p->num_immediates; i++) {
               /* find constant slot for this immediate */
               for (j = 0; j < I915_MAX_CONSTANT; j++) {
                  if (ifs->constant_flags[j] == 0x0) {
                     memcpy(ifs->constants[j],
                            p->immediates[i],
                            4 * sizeof(float));
                     /*printf("immediate %d maps to const %d\n", i, j);*/
                     ifs->constant_flags[j] = 0xf;  /* all four comps used */
                     p->immediates_map[i] = j;
                     ifs->num_constants = MAX2(ifs->num_constants, j + 1);
                     break;
                  }
a1182 2

            p->first_instruction = FALSE;
d1185 2
a1186 2
         i915_translate_instruction(p, &parse.FullToken.FullInstruction, fs);
         break;
d1188 2
a1189 3
      default:
         assert( 0 );
      }
d1191 3
a1193 1
   } /* while */
d1195 16
a1210 1
   tgsi_parse_free (&parse);
d1232 2
a1250 2
   p->wpos_tex = -1;

d1269 1
a1269 1
      i915_program_error(p, "Exceeded max nr indirect texture lookups");
d1300 1
d1302 3
d1306 10
a1315 1
         = (uint *) MALLOC((program_size + decl_size) * sizeof(uint));
d1317 1
a1317 1
         ifs->program_len = program_size + decl_size;
d1320 1
a1320 5
                p->declarations, 
                decl_size * sizeof(uint));

         memcpy(ifs->program + decl_size, 
                p->program, 
a1330 34
/**
 * Find an unused texture coordinate slot to use for fragment WPOS.
 * Update p->fp->wpos_tex with the result (-1 if no used texcoord slot is found).
 */
static void
i915_find_wpos_space(struct i915_fp_compile *p)
{
#if 0
   const uint inputs
      = p->shader->inputs_read | (1 << TGSI_ATTRIB_POS); /*XXX hack*/
   uint i;

   p->wpos_tex = -1;

   if (inputs & (1 << TGSI_ATTRIB_POS)) {
      for (i = 0; i < I915_TEX_UNITS; i++) {
	 if ((inputs & (1 << (TGSI_ATTRIB_TEX0 + i))) == 0) {
	    p->wpos_tex = i;
	    return;
	 }
      }

      i915_program_error(p, "No free texcoord for wpos value");
   }
#else
   if (p->shader->info.input_semantic_name[0] == TGSI_SEMANTIC_POSITION) {
      /* frag shader using the fragment position input */
#if 0
      assert(0);
#endif
   }
#endif
}

d1363 1
a1377 1
   i915_find_wpos_space(p);
d1379 2
a1380 1
   i915_translate_instructions(p, tokens, fs);
d1384 5
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d136 15
a150 1

d158 2
a159 1
           const struct tgsi_full_src_register *source)
d210 5
a214 3
         /* usually a texcoord */
         src = i915_emit_decl(p, REG_TYPE_T, T_TEX0 + sem_ind, D0_CHANNEL_ALL);
         break;
d356 2
a357 1
         uint opcode)
d363 1
a363 1
   uint coord = src_vector( p, &inst->Src[0]);
d382 2
a383 1
                  uint opcode, uint numArgs)
d389 3
a391 3
   arg1 = (numArgs < 1) ? 0 : src_vector( p, &inst->Src[0] );
   arg2 = (numArgs < 2) ? 0 : src_vector( p, &inst->Src[1] );
   arg3 = (numArgs < 3) ? 0 : src_vector( p, &inst->Src[2] );
d407 2
a408 1
                        uint opcode, uint numArgs)
d419 1
a419 1
   emit_simple_arith(p, &inst2, opcode, numArgs);
d438 2
a439 1
                           const struct tgsi_full_instruction *inst)
d447 1
a447 1
      src0 = src_vector(p, &inst->Src[0]);
d456 1
a456 1
      emit_simple_arith(p, inst, A0_ADD, 2);
d460 3
a462 3
      src0 = src_vector(p, &inst->Src[0]);
      src1 = src_vector(p, &inst->Src[1]);
      src2 = src_vector(p, &inst->Src[2]);
d470 1
a470 1
      src0 = src_vector(p, &inst->Src[0]);
d519 11
d531 1
a531 1
      emit_simple_arith(p, inst, A0_DP3, 2);
d535 1
a535 1
      emit_simple_arith(p, inst, A0_DP4, 2);
d539 2
a540 2
      src0 = src_vector(p, &inst->Src[0]);
      src1 = src_vector(p, &inst->Src[1]);
d550 2
a551 2
      src0 = src_vector(p, &inst->Src[0]);
      src1 = src_vector(p, &inst->Src[1]);
d571 1
a571 1
      src0 = src_vector(p, &inst->Src[0]);
d581 1
a581 1
      emit_simple_arith(p, inst, A0_FLR, 1);
d585 1
a585 1
      emit_simple_arith(p, inst, A0_FRC, 1);
d590 1
a590 1
      src0 = src_vector(p, &inst->Src[0]);
d606 1
a606 1
      src0 = src_vector(p, &inst->Src[0]);
d616 1
a616 1
      src0 = src_vector(p, &inst->Src[0]);
d649 3
a651 3
      src0 = src_vector(p, &inst->Src[0]);
      src1 = src_vector(p, &inst->Src[1]);
      src2 = src_vector(p, &inst->Src[2]);
d671 1
a671 1
      emit_simple_arith(p, inst, A0_MAD, 3);
d675 1
a675 1
      emit_simple_arith(p, inst, A0_MAX, 2);
d679 2
a680 2
      src0 = src_vector(p, &inst->Src[0]);
      src1 = src_vector(p, &inst->Src[1]);
d697 1
a697 1
      emit_simple_arith(p, inst, A0_MOV, 1);
d701 1
a701 1
      emit_simple_arith(p, inst, A0_MUL, 2);
d705 2
a706 2
      src0 = src_vector(p, &inst->Src[0]);
      src1 = src_vector(p, &inst->Src[1]);
d730 1
a730 1
      src0 = src_vector(p, &inst->Src[0]);
d735 1
a735 1
                         get_result_flags(inst), 0,
d740 1
a740 1
      src0 = src_vector(p, &inst->Src[0]);
d750 1
a750 1
      src0 = src_vector(p, &inst->Src[0]);
d813 26
a838 2
   case TGSI_OPCODE_SGE:
      emit_simple_arith(p, inst, A0_SGE, 2);
d841 2
a842 3
   case TGSI_OPCODE_SLE:
      /* like SGE, but swap reg0, reg1 */
      emit_simple_arith_swap2(p, inst, A0_SGE, 2);
d846 1
a846 1
      src0 = src_vector(p, &inst->Src[0]);
d895 5
d901 1
a901 1
      emit_simple_arith(p, inst, A0_SLT, 2);
d906 56
a961 1
      emit_simple_arith_swap2(p, inst, A0_SLT, 2);
d965 2
a966 2
      src0 = src_vector(p, &inst->Src[0]);
      src1 = src_vector(p, &inst->Src[1]);
d976 5
a980 1
      emit_tex(p, inst, T0_TEXLD);
d984 1
a984 1
      emit_tex(p, inst, T0_TEXLDB);
d988 1
a988 1
      emit_tex(p, inst, T0_TEXLDP);
d998 2
a999 2
      src0 = src_vector(p, &inst->Src[0]);
      src1 = src_vector(p, &inst->Src[1]);
d1034 2
a1035 1
                            const struct tgsi_token *tokens)
d1047 8
d1116 1
a1116 1
         i915_translate_instruction(p, &parse.FullToken.FullInstruction);
d1134 1
d1147 3
d1301 1
a1301 1
   struct i915_fp_compile *p = i915_init_compile(i915, fs);
a1303 2
   i915_find_wpos_space(p);

d1308 12
a1319 1
   i915_translate_instructions(p, tokens);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a43 3
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
d49 1
a49 1
static unsigned passthrough_decl[] =
d55 3
a57 3
   (D0_DCL |
    (REG_TYPE_T << D0_TYPE_SHIFT) |
    (T_DIFFUSE << D0_NR_SHIFT) |
a60 1
};
a61 2
static unsigned passthrough_program[] =
{
d64 3
a66 3
   (A0_MOV |
    (REG_TYPE_OC << A0_DEST_TYPE_SHIFT) |
    A0_DEST_CHANNEL_ALL |
d75 1
a75 1
static const float scs_sin_constants[4] = { 1.0,
d82 1
a82 1
static const float scs_cos_constants[4] = { 1.0,
a87 14
/* 2*pi, -(2*pi)^3/3!, (2*pi)^5/5!, -(2*pi)^7/7! */
static const float sin_constants[4] = { 2.0 * M_PI,
   -8.0f * M_PI * M_PI * M_PI / (3 * 2 * 1),
   32.0f * M_PI * M_PI * M_PI * M_PI * M_PI / (5 * 4 * 3 * 2 * 1),
   -128.0f * M_PI * M_PI * M_PI * M_PI * M_PI * M_PI * M_PI / (7 * 6 * 5 * 4 * 3 * 2 * 1)
};

/* 1, -(2*pi)^2/2!, (2*pi)^4/4!, -(2*pi)^6/6! */
static const float cos_constants[4] = { 1.0,
   -4.0f * M_PI * M_PI / (2 * 1),
   16.0f * M_PI * M_PI * M_PI * M_PI / (4 * 3 * 2 * 1),
   -64.0f * M_PI * M_PI * M_PI * M_PI * M_PI * M_PI / (6 * 5 * 4 * 3 * 2 * 1)
};

d111 1
a111 2
   fs->program = (uint *) MALLOC(sizeof(passthrough_program));
   fs->decl = (uint *) MALLOC(sizeof(passthrough_decl));
d113 2
a114 4
      memcpy(fs->program, passthrough_program, sizeof(passthrough_program));
      memcpy(fs->decl, passthrough_decl, sizeof(passthrough_decl));
      fs->program_len = Elements(passthrough_program);
      fs->decl_len = Elements(passthrough_decl);
d127 1
a127 1
   va_start( args, msg );
d136 1
a136 15
static uint get_mapping(struct i915_fragment_shader* fs, int unit)
{
   int i;
   for (i = 0; i < I915_TEX_UNITS; i++)
   {
      if (fs->generic_mapping[i] == -1) {
         fs->generic_mapping[i] = unit;
         return i;
      }
      if (fs->generic_mapping[i] == unit)
         return i;
   }
   debug_printf("Exceeded max generics\n");
   return 0;
}
d144 1
a144 2
           const struct i915_full_src_register *source,
           struct i915_fragment_shader* fs)
d173 6
a178 6
         {
            /* for fragcoord */
            int real_tex_unit = get_mapping(fs, I915_SEMANTIC_POS);
            src = i915_emit_decl(p, REG_TYPE_T, T_TEX0 + real_tex_unit, D0_CHANNEL_ALL);
            break;
         }
d195 3
a197 12
         {
            int real_tex_unit = get_mapping(fs, sem_ind);
            src = i915_emit_decl(p, REG_TYPE_T, T_TEX0 + real_tex_unit, D0_CHANNEL_ALL);
            break;
         }
      case TGSI_SEMANTIC_FACE:
         {
            /* for back/front faces */
            int real_tex_unit = get_mapping(fs, I915_SEMANTIC_FACE);
            src = i915_emit_decl(p, REG_TYPE_T, T_TEX0 + real_tex_unit, D0_CHANNEL_X);
            break;
         }
d223 1
a237 3
   if (source->Register.Absolute)
      debug_printf("Unhandled absolute value\n");

d247 1
a247 1
                  const struct i915_full_dst_register *dest)
d276 1
a276 1
get_result_flags(const struct i915_full_instruction *inst)
a331 27
/**
 * Return the number of coords needed to access a given TGSI_TEXTURE_*
 */
static uint
texture_num_coords(struct i915_fp_compile *p, uint tex)
{
   switch (tex) {
   case TGSI_TEXTURE_SHADOW1D:
   case TGSI_TEXTURE_1D:
      return 1;

   case TGSI_TEXTURE_SHADOW2D:
   case TGSI_TEXTURE_2D:
   case TGSI_TEXTURE_SHADOWRECT:
   case TGSI_TEXTURE_RECT:
      return 2;

   case TGSI_TEXTURE_3D:
   case TGSI_TEXTURE_CUBE:
      return 3;

   default:
      i915_program_error(p, "Num coords");
      return 2;
   }
}

d338 2
a339 3
         const struct i915_full_instruction *inst,
         uint opcode,
         struct i915_fragment_shader* fs)
d345 1
a345 1
   uint coord = src_vector( p, &inst->Src[0], fs);
d352 1
a352 2
                    opcode,
                    texture_num_coords(p, texture) );
d363 2
a364 3
                  const struct i915_full_instruction *inst,
                  uint opcode, uint numArgs,
                  struct i915_fragment_shader* fs)
d370 3
a372 3
   arg1 = (numArgs < 1) ? 0 : src_vector( p, &inst->Src[0], fs );
   arg2 = (numArgs < 2) ? 0 : src_vector( p, &inst->Src[1], fs );
   arg3 = (numArgs < 3) ? 0 : src_vector( p, &inst->Src[2], fs );
d387 2
a388 3
                        const struct i915_full_instruction *inst,
                        uint opcode, uint numArgs,
                        struct i915_fragment_shader* fs)
d390 1
a390 1
   struct i915_full_instruction inst2;
d399 1
a399 1
   emit_simple_arith(p, &inst2, opcode, numArgs, fs);
d402 5
a411 1
 * DDX, DDY -- return 0
d415 1
a415 1
 */
d418 1
a418 2
                           const struct i915_full_instruction *inst,
                           struct i915_fragment_shader *fs)
d426 1
a426 1
      src0 = src_vector(p, &inst->Src[0], fs);
d435 1
a435 17
      emit_simple_arith(p, inst, A0_ADD, 2, fs);
      break;

   case TGSI_OPCODE_CEIL:
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);
      flags = get_result_flags(inst);
      i915_emit_arith(p,
                      A0_FLR,
                      tmp,
                      flags & A0_DEST_CHANNEL_ALL, 0,
                      negate(src0, 1, 1, 1, 1), 0, 0);
      i915_emit_arith(p,
                      A0_MOV,
                      get_result_vector(p, &inst->Dst[0]),
                      flags, 0,
                      negate(tmp, 1, 1, 1, 1), 0, 0);
d439 4
a442 4
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      src2 = src_vector(p, &inst->Src[2], fs);
      i915_emit_arith(p, A0_CMP,
d444 1
a444 1
                      get_result_flags(inst),
d449 1
a449 1
      src0 = src_vector(p, &inst->Src[0], fs);
d459 7
d467 1
a467 1
       * t0.xy = MUL x.xx11, x.x111  ; x^2, x, 1, 1
a497 23
  case TGSI_OPCODE_DDX:
  case TGSI_OPCODE_DDY:
      /* XXX We just output 0 here */
      debug_printf("Punting DDX/DDX\n");
      src0 = get_result_vector(p, &inst->Dst[0]);
      i915_emit_arith(p,
                      A0_MOV,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, ZERO, ZERO, ZERO, ZERO), 0, 0);
      break;

  case TGSI_OPCODE_DP2:
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);

      i915_emit_arith(p,
                      A0_DP3,
                      get_result_vector(p, &inst->Dst[0]),
                      get_result_flags(inst), 0,
                      swizzle(src0, X, Y, ZERO, ZERO), src1, 0);
      break;

d499 1
a499 1
      emit_simple_arith(p, inst, A0_DP3, 2, fs);
d503 1
a503 1
      emit_simple_arith(p, inst, A0_DP4, 2, fs);
d507 2
a508 2
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
d518 2
a519 2
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
d539 1
a539 1
      src0 = src_vector(p, &inst->Src[0], fs);
d549 1
a549 1
      emit_simple_arith(p, inst, A0_FLR, 1, fs);
d553 1
a553 1
      emit_simple_arith(p, inst, A0_FRC, 1, fs);
d556 1
a556 1
   case TGSI_OPCODE_KILL_IF:
d558 1
a558 1
      src0 = src_vector(p, &inst->Src[0], fs);
d566 1
a566 2
                      T0_TEXKILL,            /* opcode */
                      1);                    /* num_coord */
d569 2
a570 11
   case TGSI_OPCODE_KILL:
      /* unconditional kill */
      tmp = i915_get_utemp(p);

      i915_emit_texld(p,
                      tmp,                                   /* dest reg: a dummy reg */
                      A0_DEST_CHANNEL_ALL,                   /* dest writemask */
                      0,                                     /* sampler */
                      negate(swizzle(0, ONE, ONE, ONE, ONE), 1, 1, 1, 1), /* coord */
                      T0_TEXKILL,                            /* opcode */
                      1);                                    /* num_coord */
d574 1
a574 1
      src0 = src_vector(p, &inst->Src[0], fs);
d584 1
a584 1
      src0 = src_vector(p, &inst->Src[0], fs);
d617 3
a619 3
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      src2 = src_vector(p, &inst->Src[2], fs);
d639 1
a639 1
      emit_simple_arith(p, inst, A0_MAD, 3, fs);
d643 1
a643 1
      emit_simple_arith(p, inst, A0_MAX, 2, fs);
d647 2
a648 2
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
d665 1
a665 1
      emit_simple_arith(p, inst, A0_MOV, 1, fs);
d669 1
a669 4
      emit_simple_arith(p, inst, A0_MUL, 2, fs);
      break;

   case TGSI_OPCODE_NOP:
d673 2
a674 2
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
d692 1
a692 1

d696 1
a696 1

d698 1
a698 1
      src0 = src_vector(p, &inst->Src[0], fs);
d703 1
a703 1
                      get_result_flags(inst), 0,
d708 1
a708 1
      src0 = src_vector(p, &inst->Src[0], fs);
d718 1
a718 1
      src0 = src_vector(p, &inst->Src[0], fs);
d725 1
a725 1
       * scs.x = DP4 t1, scs_sin_constants
d727 1
a727 1
       * scs.y = DP4 t1, scs_cos_constants
d762 1
a762 1
                         i915_emit_const4fv(p, scs_sin_constants), 0);
d777 1
a777 1
                         i915_emit_const4fv(p, scs_cos_constants), 0);
d781 2
a782 26
   case TGSI_OPCODE_SEQ:
      /* if we're both >= and <= then we're == */
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_SGE,
                      tmp, A0_DEST_CHANNEL_ALL, 0,
                      src0,
                      src1, 0);

      i915_emit_arith(p,
                      A0_SGE,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      src1,
                      src0, 0);

      i915_emit_arith(p,
                      A0_MUL,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      get_result_vector(p, &inst->Dst[0]),
                      tmp, 0);

d785 3
a787 2
   case TGSI_OPCODE_SGE:
      emit_simple_arith(p, inst, A0_SGE, 2, fs);
d791 1
a791 1
      src0 = src_vector(p, &inst->Src[0], fs);
d801 7
a839 5
   case TGSI_OPCODE_SLE:
      /* like SGE, but swap reg0, reg1 */
      emit_simple_arith_swap2(p, inst, A0_SGE, 2, fs);
      break;

d841 1
a841 1
      emit_simple_arith(p, inst, A0_SLT, 2, fs);
d846 1
a846 56
      emit_simple_arith_swap2(p, inst, A0_SLT, 2, fs);
      break;

   case TGSI_OPCODE_SNE:
      /* if we're < or > then we're != */
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_SLT,
                      tmp,
                      A0_DEST_CHANNEL_ALL, 0,
                      src0,
                      src1, 0);

      i915_emit_arith(p,
                      A0_SLT,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      src1,
                      src0, 0);

      i915_emit_arith(p,
                      A0_ADD,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      get_result_vector(p, &inst->Dst[0]),
                      tmp, 0);
      break;

   case TGSI_OPCODE_SSG:
      /* compute (src>0) - (src<0) */
      src0 = src_vector(p, &inst->Src[0], fs);
      tmp = i915_get_utemp(p);

      i915_emit_arith(p,
                      A0_SLT,
                      tmp,
                      A0_DEST_CHANNEL_ALL, 0,
                      src0,
                      swizzle(src0, ZERO, ZERO, ZERO, ZERO), 0);

      i915_emit_arith(p,
                      A0_SLT,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      swizzle(src0, ZERO, ZERO, ZERO, ZERO),
                      src0, 0);

      i915_emit_arith(p,
                      A0_ADD,
                      get_result_vector(p, &inst->Dst[0]),
                      A0_DEST_CHANNEL_ALL, 0,
                      get_result_vector(p, &inst->Dst[0]),
                      negate(tmp, 1, 1, 1, 1), 0);
d850 2
a851 2
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
d861 1
a861 5
      emit_tex(p, inst, T0_TEXLD, fs);
      break;

   case TGSI_OPCODE_TRUNC:
      emit_simple_arith(p, inst, A0_TRC, 1, fs);
d865 1
a865 1
      emit_tex(p, inst, T0_TEXLDB, fs);
d869 1
a869 1
      emit_tex(p, inst, T0_TEXLDP, fs);
d879 2
a880 2
      src0 = src_vector(p, &inst->Src[0], fs);
      src1 = src_vector(p, &inst->Src[1], fs);
d908 8
a915 3
static void i915_translate_token(struct i915_fp_compile *p,
                                 const union i915_full_token* token,
                                 struct i915_fragment_shader *fs)
d918 7
a924 9
   switch( token->Token.Type ) {
   case TGSI_TOKEN_TYPE_PROPERTY:
      /*
       * We only support one cbuf, but we still need to ignore the property
       * correctly so we don't hit the assert at the end of the switch case.
       */
      assert(token->FullProperty.Property.PropertyName ==
             TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS);
      break;
d926 12
a937 10
   case TGSI_TOKEN_TYPE_DECLARATION:
      if (token->FullDeclaration.Declaration.File
               == TGSI_FILE_CONSTANT) {
         uint i;
         for (i = token->FullDeclaration.Range.First;
              i <= token->FullDeclaration.Range.Last;
              i++) {
            assert(ifs->constant_flags[i] == 0x0);
            ifs->constant_flags[i] = I915_CONSTFLAG_USER;
            ifs->num_constants = MAX2(ifs->num_constants, i + 1);
d939 7
a945 10
      }
      else if (token->FullDeclaration.Declaration.File
               == TGSI_FILE_TEMPORARY) {
         uint i;
         for (i = token->FullDeclaration.Range.First;
              i <= token->FullDeclaration.Range.Last;
              i++) {
            if (i >= I915_MAX_TEMPORARY)
               debug_printf("Too many temps (%d)\n",i);
            else
d948 1
d950 1
a950 2
      }
      break;
d952 10
a961 9
   case TGSI_TOKEN_TYPE_IMMEDIATE:
      {
         const struct tgsi_full_immediate *imm
            = &token->FullImmediate;
         const uint pos = p->num_immediates++;
         uint j;
         assert( imm->Immediate.NrTokens <= 4 + 1 );
         for (j = 0; j < imm->Immediate.NrTokens - 1; j++) {
            p->immediates[pos][j] = imm->u[j].Float;
d963 1
a963 2
      }
      break;
d965 17
a981 16
   case TGSI_TOKEN_TYPE_INSTRUCTION:
      if (p->first_instruction) {
         /* resolve location of immediates */
         uint i, j;
         for (i = 0; i < p->num_immediates; i++) {
            /* find constant slot for this immediate */
            for (j = 0; j < I915_MAX_CONSTANT; j++) {
               if (ifs->constant_flags[j] == 0x0) {
                  memcpy(ifs->constants[j],
                         p->immediates[i],
                         4 * sizeof(float));
                  /*printf("immediate %d maps to const %d\n", i, j);*/
                  ifs->constant_flags[j] = 0xf;  /* all four comps used */
                  p->immediates_map[i] = j;
                  ifs->num_constants = MAX2(ifs->num_constants, j + 1);
                  break;
d984 2
d988 5
a992 1
         p->first_instruction = FALSE;
d995 1
a995 6
      i915_translate_instruction(p, &token->FullInstruction, fs);
      break;

   default:
      assert( 0 );
   }
d997 1
a997 16
}

/**
 * Translate TGSI fragment shader into i915 hardware instructions.
 * \param p  the translation state
 * \param tokens  the TGSI token array
 */
static void
i915_translate_instructions(struct i915_fp_compile *p,
                            const struct i915_token_list *tokens,
                            struct i915_fragment_shader *fs)
{
   int i;
   for(i = 0; i<tokens->NumTokens; i++) {
      i915_translate_token(p, &tokens->Tokens[i], fs);
   }
a1005 1
   int i;
a1017 5
   memset(&p->register_phases, 0, sizeof(p->register_phases));

   for (i = 0; i < I915_TEX_UNITS; i++)
      ifs->generic_mapping[i] = -1;

d1032 2
d1052 1
a1052 1
      debug_printf("Exceeded max nr indirect texture lookups\n");
a1082 1
      assert(!ifs->decl);
a1083 3

      ifs->decl
         = (uint *) MALLOC(decl_size * sizeof(uint));
d1085 3
a1087 1
         = (uint *) MALLOC(program_size * sizeof(uint));
d1089 2
a1090 5
      if (ifs->decl) {
         ifs->decl_len = decl_size;

         memcpy(ifs->decl,
                p->declarations,
a1091 4
      }

      if (ifs->program) {
         ifs->program_len = program_size;
d1093 2
a1094 2
         memcpy(ifs->program,
                p->program,
d1105 34
d1169 1
a1169 1
   struct i915_fp_compile *p;
d1171 2
a1172 1
   struct i915_token_list* i_tokens;
d1178 1
a1178 12
   /* hw doesn't seem to like empty frag programs, even when the depth write
    * fixup gets emitted below - may that one is fishy, too? */
   if (fs->info.num_instructions == 1) {
      i915_use_passthrough_shader(fs);

      return;
   }

   p = i915_init_compile(i915, fs);

   i_tokens = i915_optimize(tokens);
   i915_translate_instructions(p, i_tokens, fs);
a1181 5
   i915_optimize_free(i_tokens);

#if 0
   i915_disassemble_program(NULL, fs->program, fs->program_len);
#endif
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a33 1
#include "i915_debug_private.h"
d182 1
a182 1
           struct i915_fragment_shader *fs)
d384 2
a385 2
uint
i915_num_coords(uint tex)
d403 1
a403 1
      debug_printf("Unknown texture target for num coords");
d430 1
a430 1
                    i915_num_coords(texture) );
d443 1
a443 1
                  struct i915_fragment_shader *fs)
d468 1
a468 1
                        struct i915_fragment_shader *fs)
d1111 1
a1111 1
                                 const union i915_full_token *token,
@


