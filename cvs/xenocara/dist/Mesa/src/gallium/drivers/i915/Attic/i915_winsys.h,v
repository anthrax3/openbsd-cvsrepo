head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.30;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.15;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2013.09.05.14.00.13;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.11;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.07.09;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.44.16;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright Â© 2009 Jakob Bornecrantz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#ifndef I915_WINSYS_H
#define I915_WINSYS_H

#include "pipe/p_compiler.h"

struct i915_winsys;
struct i915_winsys_buffer;
struct i915_winsys_batchbuffer;
struct pipe_resource;
struct pipe_fence_handle;
struct winsys_handle;

enum i915_winsys_buffer_usage
{
   /* use on textures */
   I915_USAGE_RENDER    = 0x01,
   I915_USAGE_SAMPLER   = 0x02,
   I915_USAGE_2D_TARGET = 0x04,
   I915_USAGE_2D_SOURCE = 0x08,
   /* use on vertex */
   I915_USAGE_VERTEX    = 0x10
};

enum i915_winsys_buffer_type
{
   I915_NEW_TEXTURE,
   I915_NEW_SCANOUT, /**< a texture used for scanning out from */
   I915_NEW_VERTEX
};

/* These need to be in sync with the definitions of libdrm-intel! */
enum i915_winsys_buffer_tile
{
   I915_TILE_NONE,
   I915_TILE_X,
   I915_TILE_Y
};

enum i915_winsys_flush_flags
{
   I915_FLUSH_ASYNC = 0,
   I915_FLUSH_END_OF_FRAME = 1
};

struct i915_winsys_batchbuffer {

   struct i915_winsys *iws;

   /**
    * Values exported to speed up the writing the batchbuffer,
    * instead of having to go trough a accesor function for
    * each dword written.
    */
   /*{@@*/
   uint8_t *map;
   uint8_t *ptr;
   size_t size;

   size_t relocs;
   /*@@}*/
};

struct i915_winsys {

   unsigned pci_id; /**< PCI ID for the device */

   /**
    * Batchbuffer functions.
    */
   /*@@{*/
   /**
    * Create a new batchbuffer.
    */
   struct i915_winsys_batchbuffer *
      (*batchbuffer_create)(struct i915_winsys *iws);

   /**
    * Validate buffers for usage in this batchbuffer.
    * Does space-checking and asorted other book-keeping.
    *
    * @@batch
    * @@buffers array to buffers to validate
    * @@num_of_buffers size of the passed array
    */
   boolean (*validate_buffers)(struct i915_winsys_batchbuffer *batch,
			       struct i915_winsys_buffer **buffers,
			       int num_of_buffers);

   /**
    * Emit a relocation to a buffer.
    * Target position in batchbuffer is the same as ptr.
    *
    * @@batch
    * @@reloc buffer address to be inserted into target.
    * @@usage how is the hardware going to use the buffer.
    * @@offset add this to the reloc buffers address
    * @@target buffer where to write the address, null for batchbuffer.
    * @@fenced relocation needs a fence.
    */
   int (*batchbuffer_reloc)(struct i915_winsys_batchbuffer *batch,
                            struct i915_winsys_buffer *reloc,
                            enum i915_winsys_buffer_usage usage,
                            unsigned offset, boolean fenced);

   /**
    * Flush a bufferbatch.
    */
   void (*batchbuffer_flush)(struct i915_winsys_batchbuffer *batch,
                             struct pipe_fence_handle **fence,
                             enum i915_winsys_flush_flags flags);

   /**
    * Destroy a batchbuffer.
    */
   void (*batchbuffer_destroy)(struct i915_winsys_batchbuffer *batch);
   /*@@}*/


   /**
    * Buffer functions.
    */
   /*@@{*/
   /**
    * Create a buffer.
    */
   struct i915_winsys_buffer *
      (*buffer_create)(struct i915_winsys *iws,
                       unsigned size,
                       enum i915_winsys_buffer_type type);

   /**
    * Create a tiled buffer.
    *
    * *stride, height are in bytes. The winsys tries to allocate the buffer with
    * the tiling mode provide in *tiling. If tiling is no possible, *tiling will
    * be set to I915_TILE_NONE. The calculated stride (incorporateing hw/kernel
    * requirements) is always returned in *stride.
    */
   struct i915_winsys_buffer *
      (*buffer_create_tiled)(struct i915_winsys *iws,
                             unsigned *stride, unsigned height,
                             enum i915_winsys_buffer_tile *tiling,
                             enum i915_winsys_buffer_type type);

   /**
    * Creates a buffer from a handle.
    * Used to implement pipe_screen::resource_from_handle.
    * Also provides the stride information needed for the
    * texture via the stride argument.
    */
   struct i915_winsys_buffer *
      (*buffer_from_handle)(struct i915_winsys *iws,
                            struct winsys_handle *whandle,
                            enum i915_winsys_buffer_tile *tiling,
                            unsigned *stride);

   /**
    * Used to implement pipe_screen::resource_get_handle.
    * The winsys might need the stride information.
    */
   boolean (*buffer_get_handle)(struct i915_winsys *iws,
                                struct i915_winsys_buffer *buffer,
                                struct winsys_handle *whandle,
                                unsigned stride);

   /**
    * Map a buffer.
    */
   void *(*buffer_map)(struct i915_winsys *iws,
                       struct i915_winsys_buffer *buffer,
                       boolean write);

   /**
    * Unmap a buffer.
    */
   void (*buffer_unmap)(struct i915_winsys *iws,
                        struct i915_winsys_buffer *buffer);

   /**
    * Write to a buffer.
    *
    * Arguments follows pipe_buffer_write.
    */
   int (*buffer_write)(struct i915_winsys *iws,
                       struct i915_winsys_buffer *dst,
                       size_t offset,
                       size_t size,
                       const void *data);

   void (*buffer_destroy)(struct i915_winsys *iws,
                          struct i915_winsys_buffer *buffer);

   /**
    * Check if a buffer is busy.
    */
   boolean (*buffer_is_busy)(struct i915_winsys *iws,
                             struct i915_winsys_buffer *buffer);
   /*@@}*/


   /**
    * Fence functions.
    */
   /*@@{*/
   /**
    * Reference fence and set ptr to fence.
    */
   void (*fence_reference)(struct i915_winsys *iws,
                           struct pipe_fence_handle **ptr,
                           struct pipe_fence_handle *fence);

   /**
    * Check if a fence has finished.
    */
   int (*fence_signalled)(struct i915_winsys *iws,
                          struct pipe_fence_handle *fence);

   /**
    * Wait on a fence to finish.
    */
   int (*fence_finish)(struct i915_winsys *iws,
                       struct pipe_fence_handle *fence);
   /*@@}*/


   /**
    * Destroy the winsys.
    */
   void (*destroy)(struct i915_winsys *iws);
};

#endif
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a249 5
   /**
    * Retrieve the aperture size (in MiB) of the device.
    */
   int (*aperture_size)(struct i915_winsys *iws);

@


1.3
log
@Merge Mesa 9.2.0
@
text
@d250 5
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d64 6
d111 1
a111 1
	 		       struct i915_winsys_buffer **buffers,
d134 2
a135 1
                             struct pipe_fence_handle **fence);
@


1.1
log
@Initial revision
@
text
@a78 1
   size_t max_relocs;
d97 12
d117 1
d122 1
a122 1
                            unsigned offset, bool fenced);
d210 6
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a63 6
enum i915_winsys_flush_flags
{
   I915_FLUSH_ASYNC = 0,
   I915_FLUSH_END_OF_FRAME = 1
};

d79 1
a97 12
    * Validate buffers for usage in this batchbuffer.
    * Does space-checking and asorted other book-keeping.
    *
    * @@batch
    * @@buffers array to buffers to validate
    * @@num_of_buffers size of the passed array
    */
   boolean (*validate_buffers)(struct i915_winsys_batchbuffer *batch,
			       struct i915_winsys_buffer **buffers,
			       int num_of_buffers);

   /**
a105 1
    * @@fenced relocation needs a fence.
d110 1
a110 1
                            unsigned offset, boolean fenced);
d116 1
a116 2
                             struct pipe_fence_handle **fence,
                             enum i915_winsys_flush_flags flags);
a197 6

   /**
    * Check if a buffer is busy.
    */
   boolean (*buffer_is_busy)(struct i915_winsys *iws,
                             struct i915_winsys_buffer *buffer);
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a249 5
   /**
    * Retrieve the aperture size (in MiB) of the device.
    */
   int (*aperture_size)(struct i915_winsys *iws);

@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d250 5
@


