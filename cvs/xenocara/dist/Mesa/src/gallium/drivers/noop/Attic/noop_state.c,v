head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.37;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.08;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.59;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2010 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include <stdio.h>
#include <errno.h>
#include "pipe/p_defines.h"
#include "pipe/p_state.h"
#include "pipe/p_context.h"
#include "pipe/p_screen.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_transfer.h"

static void noop_draw_vbo(struct pipe_context *ctx, const struct pipe_draw_info *info)
{
}

static void noop_set_blend_color(struct pipe_context *ctx,
					const struct pipe_blend_color *state)
{
}

static void *noop_create_blend_state(struct pipe_context *ctx,
					const struct pipe_blend_state *state)
{
	struct pipe_blend_state *nstate = CALLOC_STRUCT(pipe_blend_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static void *noop_create_dsa_state(struct pipe_context *ctx,
				   const struct pipe_depth_stencil_alpha_state *state)
{
	struct pipe_depth_stencil_alpha_state *nstate = CALLOC_STRUCT(pipe_depth_stencil_alpha_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static void *noop_create_rs_state(struct pipe_context *ctx,
					const struct pipe_rasterizer_state *state)
{
	struct pipe_rasterizer_state *nstate = CALLOC_STRUCT(pipe_rasterizer_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static void *noop_create_sampler_state(struct pipe_context *ctx,
					const struct pipe_sampler_state *state)
{
	struct pipe_sampler_state *nstate = CALLOC_STRUCT(pipe_sampler_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static struct pipe_sampler_view *noop_create_sampler_view(struct pipe_context *ctx,
							struct pipe_resource *texture,
							const struct pipe_sampler_view *state)
{
	struct pipe_sampler_view *sampler_view = CALLOC_STRUCT(pipe_sampler_view);

	if (sampler_view == NULL)
		return NULL;
	/* initialize base object */
	pipe_resource_reference(&sampler_view->texture, texture);
	pipe_reference_init(&sampler_view->reference, 1);
	sampler_view->context = ctx;
	return sampler_view;
}

static struct pipe_surface *noop_create_surface(struct pipe_context *ctx,
						struct pipe_resource *texture,
						const struct pipe_surface *surf_tmpl)
{
	struct pipe_surface *surface = CALLOC_STRUCT(pipe_surface);

	if (surface == NULL)
		return NULL;
	pipe_reference_init(&surface->reference, 1);
	pipe_resource_reference(&surface->texture, texture);
	surface->context = ctx;
	surface->format = surf_tmpl->format;
	surface->width = texture->width0;
	surface->height = texture->height0;
	surface->texture = texture;
	surface->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
	surface->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
	surface->u.tex.level = surf_tmpl->u.tex.level;

	return surface;
}

static void noop_set_sampler_views(struct pipe_context *ctx, unsigned shader,
                                   unsigned start, unsigned count,
                                   struct pipe_sampler_view **views)
{
}

static void noop_bind_sampler_states(struct pipe_context *ctx, unsigned shader,
                                     unsigned start, unsigned count,
                                     void **states)
{
}

static void noop_set_clip_state(struct pipe_context *ctx,
				const struct pipe_clip_state *state)
{
}

static void noop_set_polygon_stipple(struct pipe_context *ctx,
					 const struct pipe_poly_stipple *state)
{
}

static void noop_set_sample_mask(struct pipe_context *pipe, unsigned sample_mask)
{
}

static void noop_set_scissor_states(struct pipe_context *ctx,
                                    unsigned start_slot,
                                    unsigned num_scissors,
                                    const struct pipe_scissor_state *state)
{
}

static void noop_set_stencil_ref(struct pipe_context *ctx,
				const struct pipe_stencil_ref *state)
{
}

static void noop_set_viewport_states(struct pipe_context *ctx,
                                     unsigned start_slot,
                                     unsigned num_viewports,
                                     const struct pipe_viewport_state *state)
{
}

static void noop_set_framebuffer_state(struct pipe_context *ctx,
					const struct pipe_framebuffer_state *state)
{
}

static void noop_set_constant_buffer(struct pipe_context *ctx,
					uint shader, uint index,
					struct pipe_constant_buffer *cb)
{
}


static void noop_sampler_view_destroy(struct pipe_context *ctx,
				struct pipe_sampler_view *state)
{
	pipe_resource_reference(&state->texture, NULL);
	FREE(state);
}


static void noop_surface_destroy(struct pipe_context *ctx,
				 struct pipe_surface *surface)
{
	pipe_resource_reference(&surface->texture, NULL);
	FREE(surface);
}

static void noop_bind_state(struct pipe_context *ctx, void *state)
{
}

static void noop_delete_state(struct pipe_context *ctx, void *state)
{
	FREE(state);
}

static void noop_delete_vertex_element(struct pipe_context *ctx, void *state)
{
	FREE(state);
}


static void noop_set_index_buffer(struct pipe_context *ctx,
					const struct pipe_index_buffer *ib)
{
}

static void noop_set_vertex_buffers(struct pipe_context *ctx,
				    unsigned start_slot, unsigned count,
				    const struct pipe_vertex_buffer *buffers)
{
}

static void *noop_create_vertex_elements(struct pipe_context *ctx,
					unsigned count,
					const struct pipe_vertex_element *state)
{
	struct pipe_vertex_element *nstate = CALLOC_STRUCT(pipe_vertex_element);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static void *noop_create_shader_state(struct pipe_context *ctx,
					const struct pipe_shader_state *state)
{
	struct pipe_shader_state *nstate = CALLOC_STRUCT(pipe_shader_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static struct pipe_stream_output_target *noop_create_stream_output_target(
      struct pipe_context *ctx,
      struct pipe_resource *res,
      unsigned buffer_offset,
      unsigned buffer_size)
{
   struct pipe_stream_output_target *t = CALLOC_STRUCT(pipe_stream_output_target);
   if (!t)
      return NULL;

   pipe_reference_init(&t->reference, 1);
   pipe_resource_reference(&t->buffer, res);
   t->buffer_offset = buffer_offset;
   t->buffer_size = buffer_size;
   return t;
}

static void noop_stream_output_target_destroy(struct pipe_context *ctx,
                                      struct pipe_stream_output_target *t)
{
   pipe_resource_reference(&t->buffer, NULL);
   FREE(t);
}

static void noop_set_stream_output_targets(struct pipe_context *ctx,
                           unsigned num_targets,
                           struct pipe_stream_output_target **targets,
                           const unsigned *offsets)
{
}

void noop_init_state_functions(struct pipe_context *ctx);

void noop_init_state_functions(struct pipe_context *ctx)
{
	ctx->create_blend_state = noop_create_blend_state;
	ctx->create_depth_stencil_alpha_state = noop_create_dsa_state;
	ctx->create_fs_state = noop_create_shader_state;
	ctx->create_rasterizer_state = noop_create_rs_state;
	ctx->create_sampler_state = noop_create_sampler_state;
	ctx->create_sampler_view = noop_create_sampler_view;
	ctx->create_surface = noop_create_surface;
	ctx->create_vertex_elements_state = noop_create_vertex_elements;
	ctx->create_vs_state = noop_create_shader_state;
	ctx->bind_blend_state = noop_bind_state;
	ctx->bind_depth_stencil_alpha_state = noop_bind_state;
	ctx->bind_sampler_states = noop_bind_sampler_states;
	ctx->bind_fs_state = noop_bind_state;
	ctx->bind_rasterizer_state = noop_bind_state;
	ctx->bind_vertex_elements_state = noop_bind_state;
	ctx->bind_vs_state = noop_bind_state;
	ctx->delete_blend_state = noop_delete_state;
	ctx->delete_depth_stencil_alpha_state = noop_delete_state;
	ctx->delete_fs_state = noop_delete_state;
	ctx->delete_rasterizer_state = noop_delete_state;
	ctx->delete_sampler_state = noop_delete_state;
	ctx->delete_vertex_elements_state = noop_delete_vertex_element;
	ctx->delete_vs_state = noop_delete_state;
	ctx->set_blend_color = noop_set_blend_color;
	ctx->set_clip_state = noop_set_clip_state;
	ctx->set_constant_buffer = noop_set_constant_buffer;
	ctx->set_sampler_views = noop_set_sampler_views;
	ctx->set_framebuffer_state = noop_set_framebuffer_state;
	ctx->set_polygon_stipple = noop_set_polygon_stipple;
	ctx->set_sample_mask = noop_set_sample_mask;
	ctx->set_scissor_states = noop_set_scissor_states;
	ctx->set_stencil_ref = noop_set_stencil_ref;
	ctx->set_vertex_buffers = noop_set_vertex_buffers;
	ctx->set_index_buffer = noop_set_index_buffer;
	ctx->set_viewport_states = noop_set_viewport_states;
	ctx->sampler_view_destroy = noop_sampler_view_destroy;
	ctx->surface_destroy = noop_surface_destroy;
	ctx->draw_vbo = noop_draw_vbo;
	ctx->create_stream_output_target = noop_create_stream_output_target;
	ctx->stream_output_target_destroy = noop_stream_output_target_destroy;
	ctx->set_stream_output_targets = noop_set_stream_output_targets;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d127 3
a129 2
static void noop_set_vs_sampler_view(struct pipe_context *ctx, unsigned count,
					struct pipe_sampler_view **views)
d133 3
a135 6
static void noop_set_ps_sampler_view(struct pipe_context *ctx, unsigned count,
					struct pipe_sampler_view **views)
{
}

static void noop_bind_sampler(struct pipe_context *ctx, unsigned count, void **states)
d277 1
a277 1
                           unsigned append_bitmask)
d296 1
a296 1
	ctx->bind_fragment_sampler_states = noop_bind_sampler;
a299 1
	ctx->bind_vertex_sampler_states = noop_bind_sampler;
d311 1
a311 1
	ctx->set_fragment_sampler_views = noop_set_ps_sampler_view;
a318 1
	ctx->set_vertex_sampler_views = noop_set_vs_sampler_view;
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d25 6
a30 6
#include <pipe/p_defines.h>
#include <pipe/p_state.h>
#include <pipe/p_context.h>
#include <pipe/p_screen.h>
#include <util/u_memory.h>
#include <util/u_inlines.h>
a118 1
	surface->usage = surf_tmpl->usage;
d126 1
d155 4
a158 2
static void noop_set_scissor_state(struct pipe_context *ctx,
					const struct pipe_scissor_state *state)
d167 4
a170 2
static void noop_set_viewport_state(struct pipe_context *ctx,
					const struct pipe_viewport_state *state)
d181 1
a181 1
					struct pipe_resource *buffer)
d221 3
a223 2
static void noop_set_vertex_buffers(struct pipe_context *ctx, unsigned count,
					const struct pipe_vertex_buffer *buffers)
d252 31
d318 1
a318 1
	ctx->set_scissor_state = noop_set_scissor_state;
d323 1
a323 1
	ctx->set_viewport_state = noop_set_viewport_state;
d327 3
a329 1
	ctx->redefine_user_buffer = u_default_redefine_user_buffer;
@


1.1
log
@Initial revision
@
text
@d31 1
d291 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d25 6
a30 7
#include "pipe/p_defines.h"
#include "pipe/p_state.h"
#include "pipe/p_context.h"
#include "pipe/p_screen.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_transfer.h"
d118 1
a125 1

d154 2
a155 4
static void noop_set_scissor_states(struct pipe_context *ctx,
                                    unsigned start_slot,
                                    unsigned num_scissors,
                                    const struct pipe_scissor_state *state)
d164 2
a165 4
static void noop_set_viewport_states(struct pipe_context *ctx,
                                     unsigned start_slot,
                                     unsigned num_viewports,
                                     const struct pipe_viewport_state *state)
d176 1
a176 1
					struct pipe_constant_buffer *cb)
d216 2
a217 3
static void noop_set_vertex_buffers(struct pipe_context *ctx,
				    unsigned start_slot, unsigned count,
				    const struct pipe_vertex_buffer *buffers)
a245 31
static struct pipe_stream_output_target *noop_create_stream_output_target(
      struct pipe_context *ctx,
      struct pipe_resource *res,
      unsigned buffer_offset,
      unsigned buffer_size)
{
   struct pipe_stream_output_target *t = CALLOC_STRUCT(pipe_stream_output_target);
   if (!t)
      return NULL;

   pipe_reference_init(&t->reference, 1);
   pipe_resource_reference(&t->buffer, res);
   t->buffer_offset = buffer_offset;
   t->buffer_size = buffer_size;
   return t;
}

static void noop_stream_output_target_destroy(struct pipe_context *ctx,
                                      struct pipe_stream_output_target *t)
{
   pipe_resource_reference(&t->buffer, NULL);
   FREE(t);
}

static void noop_set_stream_output_targets(struct pipe_context *ctx,
                           unsigned num_targets,
                           struct pipe_stream_output_target **targets,
                           unsigned append_bitmask)
{
}

d281 1
a281 1
	ctx->set_scissor_states = noop_set_scissor_states;
d286 1
a286 1
	ctx->set_viewport_states = noop_set_viewport_states;
a289 3
	ctx->create_stream_output_target = noop_create_stream_output_target;
	ctx->stream_output_target_destroy = noop_stream_output_target_destroy;
	ctx->set_stream_output_targets = noop_set_stream_output_targets;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d127 2
a128 3
static void noop_set_sampler_views(struct pipe_context *ctx, unsigned shader,
                                   unsigned start, unsigned count,
                                   struct pipe_sampler_view **views)
d132 6
a137 3
static void noop_bind_sampler_states(struct pipe_context *ctx, unsigned shader,
                                     unsigned start, unsigned count,
                                     void **states)
d279 1
a279 1
                           const unsigned *offsets)
d298 1
a298 1
	ctx->bind_sampler_states = noop_bind_sampler_states;
d302 1
d314 1
a314 1
	ctx->set_sampler_views = noop_set_sampler_views;
d322 1
@


