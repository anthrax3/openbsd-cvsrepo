head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.07.29.05.47.25;	author mpi;	state Exp;
branches;
next	1.7;
commitid	7LgDWgovbCk9WPgF;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.56;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.06;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.00;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.45.09;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2009 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "r300_context.h"
#include "r300_emit.h"
#include "r300_texture.h"
#include "r300_reg.h"

#include "util/u_format.h"
#include "util/u_half.h"
#include "util/u_pack_color.h"
#include "util/u_surface.h"

enum r300_blitter_op /* bitmask */
{
    R300_STOP_QUERY         = 1,
    R300_SAVE_TEXTURES      = 2,
    R300_SAVE_FRAMEBUFFER   = 4,
    R300_IGNORE_RENDER_COND = 8,

    R300_CLEAR         = R300_STOP_QUERY,

    R300_CLEAR_SURFACE = R300_STOP_QUERY | R300_SAVE_FRAMEBUFFER,

    R300_COPY          = R300_STOP_QUERY | R300_SAVE_FRAMEBUFFER |
                         R300_SAVE_TEXTURES | R300_IGNORE_RENDER_COND,

    R300_BLIT          = R300_STOP_QUERY | R300_SAVE_FRAMEBUFFER |
                         R300_SAVE_TEXTURES | R300_IGNORE_RENDER_COND,

    R300_DECOMPRESS    = R300_STOP_QUERY | R300_IGNORE_RENDER_COND,
};

static void r300_blitter_begin(struct r300_context* r300, enum r300_blitter_op op)
{
    if ((op & R300_STOP_QUERY) && r300->query_current) {
        r300->blitter_saved_query = r300->query_current;
        r300_stop_query(r300);
    }

    /* Yeah we have to save all those states to ensure the blitter operation
     * is really transparent. The states will be restored by the blitter once
     * copying is done. */
    util_blitter_save_blend(r300->blitter, r300->blend_state.state);
    util_blitter_save_depth_stencil_alpha(r300->blitter, r300->dsa_state.state);
    util_blitter_save_stencil_ref(r300->blitter, &(r300->stencil_ref));
    util_blitter_save_rasterizer(r300->blitter, r300->rs_state.state);
    util_blitter_save_fragment_shader(r300->blitter, r300->fs.state);
    util_blitter_save_vertex_shader(r300->blitter, r300->vs_state.state);
    util_blitter_save_viewport(r300->blitter, &r300->viewport);
    util_blitter_save_scissor(r300->blitter, r300->scissor_state.state);
    util_blitter_save_sample_mask(r300->blitter, *(unsigned*)r300->sample_mask.state);
    util_blitter_save_vertex_buffer_slot(r300->blitter, r300->vertex_buffer);
    util_blitter_save_vertex_elements(r300->blitter, r300->velems);

    if (op & R300_SAVE_FRAMEBUFFER) {
        util_blitter_save_framebuffer(r300->blitter, r300->fb_state.state);
    }

    if (op & R300_SAVE_TEXTURES) {
        struct r300_textures_state* state =
            (struct r300_textures_state*)r300->textures_state.state;

        util_blitter_save_fragment_sampler_states(
            r300->blitter, state->sampler_state_count,
            (void**)state->sampler_states);

        util_blitter_save_fragment_sampler_views(
            r300->blitter, state->sampler_view_count,
            (struct pipe_sampler_view**)state->sampler_views);
    }

    if (op & R300_IGNORE_RENDER_COND) {
        /* Save the flag. */
        r300->blitter_saved_skip_rendering = r300->skip_rendering+1;
        r300->skip_rendering = FALSE;
    } else {
        r300->blitter_saved_skip_rendering = 0;
    }
}

static void r300_blitter_end(struct r300_context *r300)
{
    if (r300->blitter_saved_query) {
        r300_resume_query(r300, r300->blitter_saved_query);
        r300->blitter_saved_query = NULL;
    }

    if (r300->blitter_saved_skip_rendering) {
        /* Restore the flag. */
        r300->skip_rendering = r300->blitter_saved_skip_rendering-1;
    }
}

static uint32_t r300_depth_clear_cb_value(enum pipe_format format,
                                          const float* rgba)
{
    union util_color uc;
    util_pack_color(rgba, format, &uc);

    if (util_format_get_blocksizebits(format) == 32)
        return uc.ui[0];
    else
        return uc.us | (uc.us << 16);
}

static boolean r300_cbzb_clear_allowed(struct r300_context *r300,
                                       unsigned clear_buffers)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;

    /* Only color clear allowed, and only one colorbuffer. */
    if ((clear_buffers & ~PIPE_CLEAR_COLOR) != 0 || fb->nr_cbufs != 1 || !fb->cbufs[0])
        return FALSE;

    return r300_surface(fb->cbufs[0])->cbzb_allowed;
}

static boolean r300_fast_zclear_allowed(struct r300_context *r300,
                                        unsigned clear_buffers)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;

    return r300_resource(fb->zsbuf->texture)->tex.zmask_dwords[fb->zsbuf->u.tex.level] != 0;
}

static boolean r300_hiz_clear_allowed(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;

    return r300_resource(fb->zsbuf->texture)->tex.hiz_dwords[fb->zsbuf->u.tex.level] != 0;
}

static uint32_t r300_depth_clear_value(enum pipe_format format,
                                       double depth, unsigned stencil)
{
    switch (format) {
        case PIPE_FORMAT_Z16_UNORM:
        case PIPE_FORMAT_X8Z24_UNORM:
            return util_pack_z(format, depth);

        case PIPE_FORMAT_S8_UINT_Z24_UNORM:
            return util_pack_z_stencil(format, depth, stencil);

        default:
            assert(0);
            return 0;
    }
}

static uint32_t r300_hiz_clear_value(double depth)
{
    uint32_t r = (uint32_t)(CLAMP(depth, 0, 1) * 255.5);
    assert(r <= 255);
    return r | (r << 8) | (r << 16) | (r << 24);
}

static void r300_set_clear_color(struct r300_context *r300,
                                 const union pipe_color_union *color)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    union util_color uc;

    memset(&uc, 0, sizeof(uc));
    util_pack_color(color->f,
                    r300_get_hw_format(fb->cbufs[0]->format, PIPE_BIND_RENDER_TARGET),
                    &uc);

    if (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
        fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16X16_FLOAT) {
        /* (0,1,2,3) maps to (B,G,R,A) */
        r300->color_clear_value_gb = uc.h[0] | ((uint32_t)uc.h[1] << 16);
        r300->color_clear_value_ar = uc.h[2] | ((uint32_t)uc.h[3] << 16);
    } else {
        r300->color_clear_value = uc.ui[0];
    }
}

DEBUG_GET_ONCE_BOOL_OPTION(hyperz, "RADEON_HYPERZ", FALSE)

/* Clear currently bound buffers. */
static void r300_clear(struct pipe_context* pipe,
                       unsigned buffers,
                       const union pipe_color_union *color,
                       double depth,
                       unsigned stencil)
{
    /* My notes about Zbuffer compression:
     *
     * 1) The zbuffer must be micro-tiled and whole microtiles must be
     *    written if compression is enabled. If microtiling is disabled,
     *    it locks up.
     *
     * 2) There is ZMASK RAM which contains a compressed zbuffer.
     *    Each dword of the Z Mask contains compression information
     *    for 16 4x4 pixel tiles, that is 2 bits for each tile.
     *    On chips with 2 Z pipes, every other dword maps to a different
     *    pipe. On newer chipsets, there is a new compression mode
     *    with 8x8 pixel tiles per 2 bits.
     *
     * 3) The FASTFILL bit has nothing to do with filling. It only tells hw
     *    it should look in the ZMASK RAM first before fetching from a real
     *    zbuffer.
     *
     * 4) If a pixel is in a cleared state, ZB_DEPTHCLEARVALUE is returned
     *    during zbuffer reads instead of the value that is actually stored
     *    in the zbuffer memory. A pixel is in a cleared state when its ZMASK
     *    is equal to 0. Therefore, if you clear ZMASK with zeros, you may
     *    leave the zbuffer memory uninitialized, but then you must enable
     *    compression, so that the ZMASK RAM is actually used.
     *
     * 5) Each 4x4 (or 8x8) tile is automatically decompressed and recompressed
     *    during zbuffer updates. A special decompressing operation should be
     *    used to fully decompress a zbuffer, which basically just stores all
     *    compressed tiles in ZMASK to the zbuffer memory.
     *
     * 6) For a 16-bit zbuffer, compression causes a hung with one or
     *    two samples and should not be used.
     *
     * 7) FORCE_COMPRESSED_STENCIL_VALUE should be enabled for stencil clears
     *    to avoid needless decompression.
     *
     * 8) Fastfill must not be used if reading of compressed Z data is disabled
     *    and writing of compressed Z data is enabled (RD/WR_COMP_ENABLE),
     *    i.e. it cannot be used to compress the zbuffer.
     *
     * 9) ZB_CB_CLEAR does not interact with zbuffer compression in any way.
     *
     * - Marek
     */

    struct r300_context* r300 = r300_context(pipe);
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_hyperz_state *hyperz =
        (struct r300_hyperz_state*)r300->hyperz_state.state;
    uint32_t width = fb->width;
    uint32_t height = fb->height;
    uint32_t hyperz_dcv = hyperz->zb_depthclearvalue;

    /* Use fast Z clear.
     * The zbuffer must be in micro-tiled mode, otherwise it locks up. */
    if (buffers & PIPE_CLEAR_DEPTHSTENCIL) {
        boolean zmask_clear, hiz_clear;

        /* If both depth and stencil are present, they must be cleared together. */
        if (fb->zsbuf->texture->format == PIPE_FORMAT_S8_UINT_Z24_UNORM &&
            (buffers & PIPE_CLEAR_DEPTHSTENCIL) != PIPE_CLEAR_DEPTHSTENCIL) {
            zmask_clear = FALSE;
            hiz_clear = FALSE;
        } else {
            zmask_clear = r300_fast_zclear_allowed(r300, buffers);
            hiz_clear = r300_hiz_clear_allowed(r300);
        }

        /* If we need Hyper-Z. */
        if (zmask_clear || hiz_clear) {
            /* Try to obtain the access to Hyper-Z buffers if we don't have one. */
            if (!r300->hyperz_enabled &&
                (r300->screen->caps.is_r500 || debug_get_option_hyperz())) {
                r300->hyperz_enabled =
                    r300->rws->cs_request_feature(r300->cs,
                                                RADEON_FID_R300_HYPERZ_ACCESS,
                                                TRUE);
                if (r300->hyperz_enabled) {
                   /* Need to emit HyperZ buffer regs for the first time. */
                   r300_mark_fb_state_dirty(r300, R300_CHANGED_HYPERZ_FLAG);
                }
            }

            /* Setup Hyper-Z clears. */
            if (r300->hyperz_enabled) {
                if (zmask_clear) {
                    hyperz_dcv = hyperz->zb_depthclearvalue =
                        r300_depth_clear_value(fb->zsbuf->format, depth, stencil);

                    r300_mark_atom_dirty(r300, &r300->zmask_clear);
                    r300_mark_atom_dirty(r300, &r300->gpu_flush);
                    buffers &= ~PIPE_CLEAR_DEPTHSTENCIL;
                }

                if (hiz_clear) {
                    r300->hiz_clear_value = r300_hiz_clear_value(depth);
                    r300_mark_atom_dirty(r300, &r300->hiz_clear);
                    r300_mark_atom_dirty(r300, &r300->gpu_flush);
                }
                r300->num_z_clears++;
            }
        }
    }

    /* Use fast color clear for an AA colorbuffer.
     * The CMASK is shared between all colorbuffers, so we use it
     * if there is only one colorbuffer bound. */
    if ((buffers & PIPE_CLEAR_COLOR) && fb->nr_cbufs == 1 && fb->cbufs[0] &&
        r300_resource(fb->cbufs[0]->texture)->tex.cmask_dwords) {
        /* Try to obtain the access to the CMASK if we don't have one. */
        if (!r300->cmask_access) {
            r300->cmask_access =
                r300->rws->cs_request_feature(r300->cs,
                                              RADEON_FID_R300_CMASK_ACCESS,
                                              TRUE);
        }

        /* Setup the clear. */
        if (r300->cmask_access) {
            /* Pair the resource with the CMASK to avoid other resources
             * accessing it. */
            if (!r300->screen->cmask_resource) {
                pipe_mutex_lock(r300->screen->cmask_mutex);
                /* Double checking (first unlocked, then locked). */
                if (!r300->screen->cmask_resource) {
                    /* Don't reference this, so that the texture can be
                     * destroyed while set in cmask_resource.
                     * Then in texture_destroy, we set cmask_resource to NULL. */
                    r300->screen->cmask_resource = fb->cbufs[0]->texture;
                }
                pipe_mutex_unlock(r300->screen->cmask_mutex);
            }

            if (r300->screen->cmask_resource == fb->cbufs[0]->texture) {
                r300_set_clear_color(r300, color);
                r300_mark_atom_dirty(r300, &r300->cmask_clear);
                r300_mark_atom_dirty(r300, &r300->gpu_flush);
                buffers &= ~PIPE_CLEAR_COLOR;
            }
        }
    }
    /* Enable CBZB clear. */
    else if (r300_cbzb_clear_allowed(r300, buffers)) {
        struct r300_surface *surf = r300_surface(fb->cbufs[0]);

        hyperz->zb_depthclearvalue =
                r300_depth_clear_cb_value(surf->base.format, color->f);

        width = surf->cbzb_width;
        height = surf->cbzb_height;

        r300->cbzb_clear = TRUE;
        r300_mark_fb_state_dirty(r300, R300_CHANGED_HYPERZ_FLAG);
    }

    /* Clear. */
    if (buffers) {
        /* Clear using the blitter. */
        r300_blitter_begin(r300, R300_CLEAR);
        util_blitter_clear(r300->blitter, width, height, 1,
                           buffers, color, depth, stencil);
        r300_blitter_end(r300);
    } else if (r300->zmask_clear.dirty ||
               r300->hiz_clear.dirty ||
               r300->cmask_clear.dirty) {
        /* Just clear zmask and hiz now, this does not use the standard draw
         * procedure. */
        /* Calculate zmask_clear and hiz_clear atom sizes. */
        unsigned dwords =
            r300->gpu_flush.size +
            (r300->zmask_clear.dirty ? r300->zmask_clear.size : 0) +
            (r300->hiz_clear.dirty ? r300->hiz_clear.size : 0) +
            (r300->cmask_clear.dirty ? r300->cmask_clear.size : 0) +
            r300_get_num_cs_end_dwords(r300);

        /* Reserve CS space. */
        if (dwords > (RADEON_MAX_CMDBUF_DWORDS - r300->cs->cdw)) {
            r300_flush(&r300->context, RADEON_FLUSH_ASYNC, NULL);
        }

        /* Emit clear packets. */
        r300_emit_gpu_flush(r300, r300->gpu_flush.size, r300->gpu_flush.state);
        r300->gpu_flush.dirty = FALSE;

        if (r300->zmask_clear.dirty) {
            r300_emit_zmask_clear(r300, r300->zmask_clear.size,
                                  r300->zmask_clear.state);
            r300->zmask_clear.dirty = FALSE;
        }
        if (r300->hiz_clear.dirty) {
            r300_emit_hiz_clear(r300, r300->hiz_clear.size,
                                r300->hiz_clear.state);
            r300->hiz_clear.dirty = FALSE;
        }
        if (r300->cmask_clear.dirty) {
            r300_emit_cmask_clear(r300, r300->cmask_clear.size,
                                  r300->cmask_clear.state);
            r300->cmask_clear.dirty = FALSE;
        }
    } else {
        assert(0);
    }

    /* Disable CBZB clear. */
    if (r300->cbzb_clear) {
        r300->cbzb_clear = FALSE;
        hyperz->zb_depthclearvalue = hyperz_dcv;
        r300_mark_fb_state_dirty(r300, R300_CHANGED_HYPERZ_FLAG);
    }

    /* Enable fastfill and/or hiz.
     *
     * If we cleared zmask/hiz, it's in use now. The Hyper-Z state update
     * looks if zmask/hiz is in use and programs hardware accordingly. */
    if (r300->zmask_in_use || r300->hiz_in_use) {
        r300_mark_atom_dirty(r300, &r300->hyperz_state);
    }
}

/* Clear a region of a color surface to a constant value. */
static void r300_clear_render_target(struct pipe_context *pipe,
                                     struct pipe_surface *dst,
                                     const union pipe_color_union *color,
                                     unsigned dstx, unsigned dsty,
                                     unsigned width, unsigned height)
{
    struct r300_context *r300 = r300_context(pipe);

    r300_blitter_begin(r300, R300_CLEAR_SURFACE);
    util_blitter_clear_render_target(r300->blitter, dst, color,
                                     dstx, dsty, width, height);
    r300_blitter_end(r300);
}

/* Clear a region of a depth stencil surface. */
static void r300_clear_depth_stencil(struct pipe_context *pipe,
                                     struct pipe_surface *dst,
                                     unsigned clear_flags,
                                     double depth,
                                     unsigned stencil,
                                     unsigned dstx, unsigned dsty,
                                     unsigned width, unsigned height)
{
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;

    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        if (fb->zsbuf->texture == dst->texture) {
            r300_decompress_zmask(r300);
        }
    }

    /* XXX Do not decompress ZMask of the currently-set zbuffer. */
    r300_blitter_begin(r300, R300_CLEAR_SURFACE);
    util_blitter_clear_depth_stencil(r300->blitter, dst, clear_flags, depth, stencil,
                                     dstx, dsty, width, height);
    r300_blitter_end(r300);
}

void r300_decompress_zmask(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;

    if (!r300->zmask_in_use || r300->locked_zbuffer)
        return;

    r300->zmask_decompress = TRUE;
    r300_mark_atom_dirty(r300, &r300->hyperz_state);

    r300_blitter_begin(r300, R300_DECOMPRESS);
    util_blitter_custom_clear_depth(r300->blitter, fb->width, fb->height, 0,
                                    r300->dsa_decompress_zmask);
    r300_blitter_end(r300);

    r300->zmask_decompress = FALSE;
    r300->zmask_in_use = FALSE;
    r300_mark_atom_dirty(r300, &r300->hyperz_state);
}

void r300_decompress_zmask_locked_unsafe(struct r300_context *r300)
{
    struct pipe_framebuffer_state fb;

    memset(&fb, 0, sizeof(fb));
    fb.width = r300->locked_zbuffer->width;
    fb.height = r300->locked_zbuffer->height;
    fb.zsbuf = r300->locked_zbuffer;

    r300->context.set_framebuffer_state(&r300->context, &fb);
    r300_decompress_zmask(r300);
}

void r300_decompress_zmask_locked(struct r300_context *r300)
{
    struct pipe_framebuffer_state saved_fb;

    memset(&saved_fb, 0, sizeof(saved_fb));
    util_copy_framebuffer_state(&saved_fb, r300->fb_state.state);
    r300_decompress_zmask_locked_unsafe(r300);
    r300->context.set_framebuffer_state(&r300->context, &saved_fb);
    util_unreference_framebuffer_state(&saved_fb);

    pipe_surface_reference(&r300->locked_zbuffer, NULL);
}

bool r300_is_blit_supported(enum pipe_format format)
{
    const struct util_format_description *desc =
        util_format_description(format);

    return desc->layout == UTIL_FORMAT_LAYOUT_PLAIN ||
           desc->layout == UTIL_FORMAT_LAYOUT_S3TC ||
           desc->layout == UTIL_FORMAT_LAYOUT_RGTC;
}

/* Copy a block of pixels from one surface to another. */
static void r300_resource_copy_region(struct pipe_context *pipe,
                                      struct pipe_resource *dst,
                                      unsigned dst_level,
                                      unsigned dstx, unsigned dsty, unsigned dstz,
                                      struct pipe_resource *src,
                                      unsigned src_level,
                                      const struct pipe_box *src_box)
{
    struct pipe_screen *screen = pipe->screen;
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    unsigned src_width0 = r300_resource(src)->tex.width0;
    unsigned src_height0 = r300_resource(src)->tex.height0;
    unsigned dst_width0 = r300_resource(dst)->tex.width0;
    unsigned dst_height0 = r300_resource(dst)->tex.height0;
    unsigned layout;
    struct pipe_box box, dstbox;
    struct pipe_sampler_view src_templ, *src_view;
    struct pipe_surface dst_templ, *dst_view;

    /* Fallback for buffers. */
    if ((dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) ||
        !r300_is_blit_supported(dst->format)) {
        util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                  src, src_level, src_box);
        return;
    }

    /* Can't read MSAA textures. */
    if (src->nr_samples > 1 || dst->nr_samples > 1) {
        return;
    }

    /* The code below changes the texture format so that the copy can be done
     * on hardware. E.g. depth-stencil surfaces are copied as RGBA
     * colorbuffers. */

    util_blitter_default_dst_texture(&dst_templ, dst, dst_level, dstz);
    util_blitter_default_src_texture(&src_templ, src, src_level);

    layout = util_format_description(dst_templ.format)->layout;

    /* Handle non-renderable plain formats. */
    if (layout == UTIL_FORMAT_LAYOUT_PLAIN &&
        (!screen->is_format_supported(screen, src_templ.format, src->target,
                                      src->nr_samples,
                                      PIPE_BIND_SAMPLER_VIEW) ||
         !screen->is_format_supported(screen, dst_templ.format, dst->target,
                                      dst->nr_samples,
                                      PIPE_BIND_RENDER_TARGET))) {
        switch (util_format_get_blocksize(dst_templ.format)) {
            case 1:
                dst_templ.format = PIPE_FORMAT_I8_UNORM;
                break;
            case 2:
                dst_templ.format = PIPE_FORMAT_B4G4R4A4_UNORM;
                break;
            case 4:
                dst_templ.format = PIPE_FORMAT_B8G8R8A8_UNORM;
                break;
            case 8:
                dst_templ.format = PIPE_FORMAT_R16G16B16A16_UNORM;
                break;
            default:
                debug_printf("r300: copy_region: Unhandled format: %s. Falling back to software.\n"
                             "r300: copy_region: Software fallback doesn't work for tiled textures.\n",
                             util_format_short_name(dst_templ.format));
        }
        src_templ.format = dst_templ.format;
    }

    /* Handle compressed formats. */
    if (layout == UTIL_FORMAT_LAYOUT_S3TC ||
        layout == UTIL_FORMAT_LAYOUT_RGTC) {
        assert(src_templ.format == dst_templ.format);

        box = *src_box;
        src_box = &box;

        dst_width0 = align(dst_width0, 4);
        dst_height0 = align(dst_height0, 4);
        src_width0 = align(src_width0, 4);
        src_height0 = align(src_height0, 4);
        box.width = align(box.width, 4);
        box.height = align(box.height, 4);

        switch (util_format_get_blocksize(dst_templ.format)) {
        case 8:
            /* one 4x4 pixel block has 8 bytes.
             * we set 1 pixel = 4 bytes ===> 1 block corrensponds to 2 pixels. */
            dst_templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
            dst_width0 = dst_width0 / 2;
            src_width0 = src_width0 / 2;
            dstx /= 2;
            box.x /= 2;
            box.width /= 2;
            break;
        case 16:
            /* one 4x4 pixel block has 16 bytes.
             * we set 1 pixel = 4 bytes ===> 1 block corresponds to 4 pixels. */
            dst_templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
            break;
        }
        src_templ.format = dst_templ.format;

        dst_height0 = dst_height0 / 4;
        src_height0 = src_height0 / 4;
        dsty /= 4;
        box.y /= 4;
        box.height /= 4;
    }

    /* Fallback for textures. */
    if (!screen->is_format_supported(screen, dst_templ.format,
                                     dst->target, dst->nr_samples,
                                     PIPE_BIND_RENDER_TARGET) ||
	!screen->is_format_supported(screen, src_templ.format,
                                     src->target, src->nr_samples,
                                     PIPE_BIND_SAMPLER_VIEW)) {
        assert(0 && "this shouldn't happen, update r300_is_blit_supported");
        util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                  src, src_level, src_box);
        return;
    }

    /* Decompress ZMASK. */
    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        if (fb->zsbuf->texture == src ||
            fb->zsbuf->texture == dst) {
            r300_decompress_zmask(r300);
        }
    }

    dst_view = r300_create_surface_custom(pipe, dst, &dst_templ, dst_width0, dst_height0);
    src_view = r300_create_sampler_view_custom(pipe, src, &src_templ, src_width0, src_height0);

    u_box_3d(dstx, dsty, dstz, abs(src_box->width), abs(src_box->height),
             abs(src_box->depth), &dstbox);

    r300_blitter_begin(r300, R300_COPY);
    util_blitter_blit_generic(r300->blitter, dst_view, &dstbox,
                              src_view, src_box, src_width0, src_height0,
                              PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL);
    r300_blitter_end(r300);

    pipe_surface_reference(&dst_view, NULL);
    pipe_sampler_view_reference(&src_view, NULL);
}

static boolean r300_is_simple_msaa_resolve(const struct pipe_blit_info *info)
{
    unsigned dst_width = u_minify(info->dst.resource->width0, info->dst.level);
    unsigned dst_height = u_minify(info->dst.resource->height0, info->dst.level);

    return info->dst.resource->format == info->src.resource->format &&
           info->dst.resource->format == info->dst.format &&
           info->src.resource->format == info->src.format &&
           !info->scissor_enable &&
           info->mask == PIPE_MASK_RGBA &&
           dst_width == info->src.resource->width0 &&
           dst_height == info->src.resource->height0 &&
           info->dst.box.x == 0 &&
           info->dst.box.y == 0 &&
           info->dst.box.width == dst_width &&
           info->dst.box.height == dst_height &&
           info->src.box.x == 0 &&
           info->src.box.y == 0 &&
           info->src.box.width == dst_width &&
           info->src.box.height == dst_height &&
           (r300_resource(info->dst.resource)->tex.microtile != RADEON_LAYOUT_LINEAR ||
            r300_resource(info->dst.resource)->tex.macrotile[info->dst.level] != RADEON_LAYOUT_LINEAR);
}

static void r300_simple_msaa_resolve(struct pipe_context *pipe,
                                     struct pipe_resource *dst,
                                     unsigned dst_level,
                                     unsigned dst_layer,
                                     struct pipe_resource *src,
                                     enum pipe_format format)
{
    struct r300_context *r300 = r300_context(pipe);
    struct r300_surface *srcsurf, *dstsurf;
    struct pipe_surface surf_tmpl;
    struct r300_aa_state *aa = (struct r300_aa_state*)r300->aa_state.state;

    memset(&surf_tmpl, 0, sizeof(surf_tmpl));
    surf_tmpl.format = format;
    srcsurf = r300_surface(pipe->create_surface(pipe, src, &surf_tmpl));

    surf_tmpl.format = format;
    surf_tmpl.u.tex.level = dst_level;
    surf_tmpl.u.tex.first_layer =
    surf_tmpl.u.tex.last_layer = dst_layer;
    dstsurf = r300_surface(pipe->create_surface(pipe, dst, &surf_tmpl));

    /* COLORPITCH should contain the tiling info of the resolve buffer.
     * The tiling of the AA buffer isn't programmable anyway. */
    srcsurf->pitch &= ~(R300_COLOR_TILE(1) | R300_COLOR_MICROTILE(3));
    srcsurf->pitch |= dstsurf->pitch & (R300_COLOR_TILE(1) | R300_COLOR_MICROTILE(3));

    /* Enable AA resolve. */
    aa->dest = dstsurf;
    r300->aa_state.size = 8;
    r300_mark_atom_dirty(r300, &r300->aa_state);

    /* Resolve the surface. */
    r300_blitter_begin(r300, R300_CLEAR_SURFACE);
    util_blitter_custom_color(r300->blitter, &srcsurf->base, NULL);
    r300_blitter_end(r300);

    /* Disable AA resolve. */
    aa->dest = NULL;
    r300->aa_state.size = 4;
    r300_mark_atom_dirty(r300, &r300->aa_state);

    pipe_surface_reference((struct pipe_surface**)&srcsurf, NULL);
    pipe_surface_reference((struct pipe_surface**)&dstsurf, NULL);
}

static void r300_msaa_resolve(struct pipe_context *pipe,
                              const struct pipe_blit_info *info)
{
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_screen *screen = pipe->screen;
    struct pipe_resource *tmp, templ;
    struct pipe_blit_info blit;

    assert(info->src.level == 0);
    assert(info->src.box.z == 0);
    assert(info->src.box.depth == 1);
    assert(info->dst.box.depth == 1);

    if (r300_is_simple_msaa_resolve(info)) {
        r300_simple_msaa_resolve(pipe, info->dst.resource, info->dst.level,
                                 info->dst.box.z, info->src.resource,
                                 info->src.format);
        return;
    }

    /* resolve into a temporary texture, then blit */
    memset(&templ, 0, sizeof(templ));
    templ.target = PIPE_TEXTURE_2D;
    templ.format = info->src.resource->format;
    templ.width0 = info->src.resource->width0;
    templ.height0 = info->src.resource->height0;
    templ.depth0 = 1;
    templ.array_size = 1;
    templ.usage = PIPE_USAGE_DEFAULT;
    templ.flags = R300_RESOURCE_FORCE_MICROTILING;

    tmp = screen->resource_create(screen, &templ);

    /* resolve */
    r300_simple_msaa_resolve(pipe, tmp, 0, 0, info->src.resource,
                             info->src.format);

    /* blit */
    blit = *info;
    blit.src.resource = tmp;
    blit.src.box.z = 0;

    r300_blitter_begin(r300, R300_BLIT);
    util_blitter_blit(r300->blitter, &blit);
    r300_blitter_end(r300);

    pipe_resource_reference(&tmp, NULL);
}

static void r300_blit(struct pipe_context *pipe,
                      const struct pipe_blit_info *blit)
{
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct pipe_blit_info info = *blit;

    /* MSAA resolve. */
    if (info.src.resource->nr_samples > 1 &&
        info.dst.resource->nr_samples <= 1 &&
        !util_format_is_depth_or_stencil(info.src.resource->format)) {
        r300_msaa_resolve(pipe, &info);
        return;
    }

    /* Can't read MSAA textures. */
    if (info.src.resource->nr_samples > 1) {
        return;
    }

    /* Blit a combined depth-stencil resource as color.
     * S8Z24 is the only supported stencil format. */
    if ((info.mask & PIPE_MASK_S) &&
        info.src.format == PIPE_FORMAT_S8_UINT_Z24_UNORM &&
        info.dst.format == PIPE_FORMAT_S8_UINT_Z24_UNORM) {
        if (info.dst.resource->nr_samples > 1) {
            /* Cannot do that with MSAA buffers. */
            info.mask &= ~PIPE_MASK_S;
            if (!(info.mask & PIPE_MASK_Z)) {
                return;
            }
        } else {
            /* Single-sample buffer. */
            info.src.format = PIPE_FORMAT_B8G8R8A8_UNORM;
            info.dst.format = PIPE_FORMAT_B8G8R8A8_UNORM;
            if (info.mask & PIPE_MASK_Z) {
                info.mask = PIPE_MASK_RGBA; /* depth+stencil */
            } else {
                info.mask = PIPE_MASK_B; /* stencil only */
            }
        }
    }

    /* Decompress ZMASK. */
    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        if (fb->zsbuf->texture == info.src.resource ||
            fb->zsbuf->texture == info.dst.resource) {
            r300_decompress_zmask(r300);
        }
    }

    r300_blitter_begin(r300, R300_BLIT);
    util_blitter_blit(r300->blitter, &info);
    r300_blitter_end(r300);
}

static void r300_flush_resource(struct pipe_context *ctx,
				struct pipe_resource *resource)
{
}

void r300_init_blit_functions(struct r300_context *r300)
{
    r300->context.clear = r300_clear;
    r300->context.clear_render_target = r300_clear_render_target;
    r300->context.clear_depth_stencil = r300_clear_depth_stencil;
    r300->context.resource_copy_region = r300_resource_copy_region;
    r300->context.blit = r300_blit;
    r300->context.flush_resource = r300_flush_resource;
}
@


1.8
log
@Make the Gallium r300 works on big-endian architectures.

Diff provided by Michel Daenzer [0] as a possible solution for a
regression introduced in Mesa 9 [1].  This diff allows macppc
users to use OpenGL accelerated appplications (i.e. GNOME3).

As disucssed during c2k15 we won't try to keep this patch during
the next Mesa update.

[0] https://bugs.freedesktop.org/show_bug.cgi?id=71789
[1] http://lists.freedesktop.org/archives/mesa-dev/2013-December/050218.html

Tested by myself and ajacoutot@@, regression test and ok jsg@@
@
text
@@


1.7
log
@Merge Mesa 10.2.9
@
text
@d188 3
a190 1
    util_pack_color(color->f, fb->cbufs[0]->format, &uc);
@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d48 1
a48 1
                         R300_SAVE_TEXTURES,
d682 1
a682 3
    return info->src.resource->nr_samples > 1 &&
           info->dst.resource->nr_samples <= 1 &&
           info->dst.resource->format == info->src.resource->format &&
d789 1
a789 1
    r300_blitter_begin(r300, R300_BLIT | R300_IGNORE_RENDER_COND);
d806 1
d848 1
a848 2
    r300_blitter_begin(r300, R300_BLIT |
		       (info.render_condition_enable ? 0 : R300_IGNORE_RENDER_COND));
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d48 1
a48 1
                         R300_SAVE_TEXTURES | R300_IGNORE_RENDER_COND,
d682 3
a684 1
    return info->dst.resource->format == info->src.resource->format &&
d791 1
a791 1
    r300_blitter_begin(r300, R300_BLIT);
a807 1
        info.dst.resource->nr_samples <= 1 &&
d849 2
a850 1
    r300_blitter_begin(r300, R300_BLIT);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d121 1
a121 1
        return uc.ui;
d133 1
a133 1
    if (clear_buffers != PIPE_CLEAR_COLOR || fb->nr_cbufs != 1)
d196 1
a196 1
        r300->color_clear_value = uc.ui;
d316 1
a316 1
    if ((buffers & PIPE_CLEAR_COLOR) && fb->nr_cbufs == 1 &&
d368 1
a368 3
        util_blitter_clear(r300->blitter,
                           width,
                           height,
d670 1
a670 2
                              PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL,
                              FALSE);
d775 1
a775 1
    templ.usage = PIPE_USAGE_STATIC;
d853 5
d865 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d26 1
d29 1
d47 3
d70 3
a72 1
    util_blitter_save_clip(r300->blitter, (struct pipe_clip_state*)r300->clip_state.state);
a73 2
    util_blitter_save_vertex_buffers(r300->blitter, r300->vbuf_mgr->nr_vertex_buffers,
                                     r300->vbuf_mgr->vertex_buffer);
d139 2
a140 1
static boolean r300_fast_zclear_allowed(struct r300_context *r300)
d164 1
a164 1
        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d180 22
d205 1
a205 1
                       const float* rgba,
d262 1
a262 1
    /* Enable fast Z clear.
d267 9
a275 2
        zmask_clear = r300_fast_zclear_allowed(r300);
        hiz_clear = r300_hiz_clear_allowed(r300);
a278 2
            r300->num_z_clears++;

d280 2
a281 1
            if (!r300->hyperz_enabled) {
d284 1
a284 1
                                                RADEON_FID_HYPERZ_RAM_ACCESS,
a293 3
                DBG(r300, DBG_HYPERZ, "r300: Clear memory: %s%s\n",
                    zmask_clear ? "ZMASK " : "", hiz_clear ? "HIZ" : "");

d299 1
d306 1
d308 1
d313 37
d351 1
a351 1
    if (r300_cbzb_clear_allowed(r300, buffers)) {
d355 1
a355 1
                r300_depth_clear_cb_value(surf->base.format, rgba);
d371 1
a371 2
                           fb->nr_cbufs,
                           buffers, rgba, depth, stencil);
d373 3
a375 1
    } else if (r300->zmask_clear.dirty || r300->hiz_clear.dirty) {
d380 1
d383 1
d392 3
d405 5
d433 1
a433 1
                                     const float *rgba,
d440 1
a440 1
    util_blitter_clear_render_target(r300->blitter, dst, rgba,
d483 1
a483 1
    util_blitter_clear_depth_custom(r300->blitter, fb->width, fb->height, 0,
d494 3
a496 1
    struct pipe_framebuffer_state fb = {0};
a498 1
    fb.nr_cbufs = 0;
d507 1
a507 1
    struct pipe_framebuffer_state saved_fb = {0};
d509 1
d518 1
a518 8
/* Copy a block of pixels from one surface to another using HW. */
static void r300_hw_copy_region(struct pipe_context* pipe,
                                struct pipe_resource *dst,
                                unsigned dst_level,
                                unsigned dstx, unsigned dsty, unsigned dstz,
                                struct pipe_resource *src,
                                unsigned src_level,
                                const struct pipe_box *src_box)
d520 2
a521 1
    struct r300_context* r300 = r300_context(pipe);
d523 3
a525 4
    r300_blitter_begin(r300, R300_COPY);
    util_blitter_copy_region(r300->blitter, dst, dst_level, dstx, dsty, dstz,
                             src, src_level, src_box, TRUE);
    r300_blitter_end(r300);
d537 1
d541 8
a548 7
    struct pipe_resource old_src = *src;
    struct pipe_resource old_dst = *dst;
    struct pipe_resource new_src = old_src;
    struct pipe_resource new_dst = old_dst;
    const struct util_format_description *desc =
            util_format_description(dst->format);
    struct pipe_box box;
d551 2
a552 1
    if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
d558 3
a560 5
    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        if (fb->zsbuf->texture == src ||
            fb->zsbuf->texture == dst) {
            r300_decompress_zmask(r300);
        }
d563 9
d573 8
a580 11
    if (desc->layout == UTIL_FORMAT_LAYOUT_PLAIN &&
        (desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB ||
         !pipe->screen->is_format_supported(pipe->screen,
                                            src->format, src->target,
                                            src->nr_samples,
                                            PIPE_BIND_SAMPLER_VIEW) ||
         !pipe->screen->is_format_supported(pipe->screen,
                                            dst->format, dst->target,
                                            dst->nr_samples,
                                            PIPE_BIND_RENDER_TARGET))) {
        switch (util_format_get_blocksize(old_dst.format)) {
d582 1
a582 1
                new_dst.format = PIPE_FORMAT_I8_UNORM;
d585 1
a585 1
                new_dst.format = PIPE_FORMAT_B4G4R4A4_UNORM;
d588 1
a588 1
                new_dst.format = PIPE_FORMAT_B8G8R8A8_UNORM;
d591 1
a591 1
                new_dst.format = PIPE_FORMAT_R16G16B16A16_UNORM;
d594 3
a596 3
                debug_printf("r300: surface_copy: Unhandled format: %s. Falling back to software.\n"
                             "r300: surface_copy: Software fallback doesn't work for tiled textures.\n",
                             util_format_short_name(dst->format));
d598 1
a598 1
        new_src.format = new_dst.format;
d602 15
a616 3
    if (desc->layout == UTIL_FORMAT_LAYOUT_S3TC ||
        desc->layout == UTIL_FORMAT_LAYOUT_RGTC) {
        switch (util_format_get_blocksize(old_dst.format)) {
d618 8
a625 3
            /* 1 pixel = 4 bits,
             * we set 1 pixel = 2 bytes ===> 4 times larger pixels. */
            new_dst.format = PIPE_FORMAT_B4G4R4A4_UNORM;
d628 3
a630 3
            /* 1 pixel = 8 bits,
             * we set 1 pixel = 4 bytes ===> 4 times larger pixels. */
            new_dst.format = PIPE_FORMAT_B8G8R8A8_UNORM;
d633 1
d635 2
a636 5
        /* Since the pixels are 4 times larger, we must decrease
         * the image size and the coordinates 4 times. */
        new_src.format = new_dst.format;
        new_dst.height0 = (new_dst.height0 + 3) / 4;
        new_src.height0 = (new_src.height0 + 3) / 4;
a637 1
        box = *src_box;
d639 210
a848 2
        box.height = (box.height + 3) / 4;
        src_box = &box;
d851 3
a853 12
    if (old_src.format != new_src.format)
        r300_resource_set_properties(pipe->screen, src, 0, &new_src);
    if (old_dst.format != new_dst.format)
        r300_resource_set_properties(pipe->screen, dst, 0, &new_dst);

    r300_hw_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                        src, src_level, src_box);

    if (old_src.format != new_src.format)
        r300_resource_set_properties(pipe->screen, src, 0, &old_src);
    if (old_dst.format != new_dst.format)
        r300_resource_set_properties(pipe->screen, dst, 0, &old_dst);
d862 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a24 1
#include "r300_hyperz.h"
a25 1
#include "r300_winsys.h"
d29 1
d67 2
a68 2
    util_blitter_save_vertex_buffers(r300->blitter, r300->vertex_buffer_count,
                                     r300->vertex_buffer);
d70 1
a70 1
    if (op & R300_SAVE_FRAMEBUFFER)
d72 1
d134 16
d167 7
d181 1
a181 6
    /* My notes about fastfill:
     *
     * 1) Only the zbuffer is cleared.
     *
     * 2) The zbuffer must be micro-tiled and whole microtiles must be
     *    written. If microtiling is disabled, it locks up.
d183 26
a208 4
     * 3) There is Z Mask RAM which contains a compressed zbuffer and
     *    it interacts with fastfill. We should figure out how to use it
     *    to get more performance.
     *    This is what we know about the Z Mask:
d210 1
a210 9
     *       Each dword of the Z Mask contains compression information
     *       for 16 4x4 pixel blocks, that is 2 bits for each block.
     *       On chips with 2 Z pipes, every other dword maps to a different
     *       pipe.
     *
     * 4) ZB_DEPTHCLEARVALUE is used to clear the zbuffer and the Z Mask must
     *    be equal to 0. (clear the Z Mask RAM with zeros)
     *
     * 5) For 16-bit zbuffer, compression causes a hung with one or
d213 1
a213 1
     * 6) FORCE_COMPRESSED_STENCIL_VALUE should be enabled for stencil clears
d216 1
a216 1
     * 7) Fastfill must not be used if reading of compressed Z data is disabled
d220 1
a220 1
     * 8) ZB_CB_CLEAR does not interact with fastfill in any way.
a229 2
    struct r300_texture *zstex =
            fb->zsbuf ? r300_texture(fb->zsbuf->texture) : NULL;
a231 1
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
d236 40
a275 8
    if ((buffers & PIPE_CLEAR_DEPTHSTENCIL) && can_hyperz) {
        hyperz_dcv = hyperz->zb_depthclearvalue =
            r300_depth_clear_value(fb->zsbuf->format, depth, stencil);

        r300_mark_fb_state_dirty(r300, R300_CHANGED_ZCLEAR_FLAG);
        if (zstex->zmask_mem[fb->zsbuf->u.tex.level]) {
            r300_mark_atom_dirty(r300, &r300->zmask_clear);
            buffers &= ~PIPE_CLEAR_DEPTHSTENCIL;
a276 2
        if (zstex->hiz_mem[fb->zsbuf->u.tex.level])
            r300_mark_atom_dirty(r300, &r300->hiz_clear);
d290 1
a290 1
        r300_mark_fb_state_dirty(r300, R300_CHANGED_CBZB_FLAG);
d303 2
a304 2
    } else if (r300->zmask_clear.dirty) {
        /* Just clear zmask and hiz now, this does not use a standard draw
a305 2
        unsigned dwords;

d307 4
a310 4
        r300_update_hyperz_state(r300);
        dwords = r300->zmask_clear.size +
                 (r300->hiz_clear.dirty ? r300->hiz_clear.size : 0) +
                 r300_get_num_cs_end_dwords(r300);
d313 2
a314 2
        if (dwords > (R300_MAX_CMDBUF_DWORDS - r300->cs->cdw)) {
            r300->context.flush(&r300->context, 0, NULL);
d318 5
a322 3
        r300_emit_zmask_clear(r300, r300->zmask_clear.size,
                              r300->zmask_clear.state);
        r300->zmask_clear.dirty = FALSE;
d336 1
a336 1
        r300_mark_fb_state_dirty(r300, R300_CHANGED_CBZB_FLAG);
d342 2
a343 4
     * looks if zmask/hiz is in use and enables fastfill accordingly. */
    if (zstex &&
        (zstex->zmask_in_use[fb->zsbuf->u.tex.level] ||
         zstex->hiz_in_use[fb->zsbuf->u.tex.level])) {
d373 8
d382 1
d389 1
a389 5
/* Flush a depth stencil buffer. */
void r300_flush_depth_stencil(struct pipe_context *pipe,
                              struct pipe_resource *dst,
                              unsigned level,
                              unsigned layer)
d391 2
a392 3
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_surface *dstsurf, surf_tmpl;
    struct r300_texture *tex = r300_texture(dst);
d394 1
a394 3
    if (!tex->zmask_mem[level])
        return;
    if (!tex->zmask_in_use[level])
d397 2
a398 6
    surf_tmpl.format = dst->format;
    surf_tmpl.usage = PIPE_BIND_DEPTH_STENCIL;
    surf_tmpl.u.tex.level = level;
    surf_tmpl.u.tex.first_layer = layer;
    surf_tmpl.u.tex.last_layer = layer;
    dstsurf = pipe->create_surface(pipe, dst, &surf_tmpl);
a399 1
    r300->z_decomp_rd = TRUE;
d401 2
a402 1
    util_blitter_flush_depth_stencil(r300->blitter, dstsurf);
a403 1
    r300->z_decomp_rd = FALSE;
d405 27
a431 1
    tex->zmask_in_use[level] = FALSE;
a445 2

    /* Do a copy */
d460 37
a496 10
    enum pipe_format old_format = dst->format;
    enum pipe_format new_format = old_format;
    boolean is_depth;
    if (!pipe->screen->is_format_supported(pipe->screen,
                                           old_format, src->target,
                                           src->nr_samples,
                                           PIPE_BIND_RENDER_TARGET |
                                           PIPE_BIND_SAMPLER_VIEW, 0) &&
        util_format_is_plain(old_format)) {
        switch (util_format_get_blocksize(old_format)) {
d498 1
a498 1
                new_format = PIPE_FORMAT_I8_UNORM;
d501 1
a501 1
                new_format = PIPE_FORMAT_B4G4R4A4_UNORM;
d504 1
a504 1
                new_format = PIPE_FORMAT_B8G8R8A8_UNORM;
d507 1
a507 1
                new_format = PIPE_FORMAT_R16G16B16A16_UNORM;
d512 1
a512 1
                             util_format_short_name(old_format));
d514 1
d517 32
a548 10
    is_depth = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 0) != 0;
    if (is_depth) {
        r300_flush_depth_stencil(pipe, src, src_level, src_box->z);
    }
    if (old_format != new_format) {
        r300_texture_reinterpret_format(pipe->screen,
                                        dst, new_format);
        r300_texture_reinterpret_format(pipe->screen,
                                        src, new_format);
    }
d553 4
a556 6
    if (old_format != new_format) {
        r300_texture_reinterpret_format(pipe->screen,
                                        dst, old_format);
        r300_texture_reinterpret_format(pipe->screen,
                                        src, old_format);
    }
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a22 1
#include "r300_blit.h"
d24 2
d27 1
d30 1
d32 1
a32 1
static void r300_blitter_save_states(struct r300_context* r300)
d34 25
d63 1
a63 1
    util_blitter_save_fragment_shader(r300->blitter, r300->fs);
d66 83
a148 1
    util_blitter_save_clip(r300->blitter, &r300->clip);
d152 12
a163 26
void r300_clear(struct pipe_context* pipe,
                unsigned buffers,
                const float* rgba,
                double depth,
                unsigned stencil)
{
    /* XXX Implement fastfill.
     *
     * If fastfill is enabled, a few facts should be considered:
     *
     * 1) Zbuffer must be micro-tiled and whole microtiles must be
     *    written.
     *
     * 2) ZB_DEPTHCLEARVALUE is used to clear a zbuffer and Z Mask must be
     *    equal to 0.
     *
     * 3) RB3D_COLOR_CLEAR_VALUE is used to clear a colorbuffer and
     *    RB3D_COLOR_CHANNEL_MASK must be equal to 0.
     *
     * 4) ZB_CB_CLEAR can be used to make the ZB units help in clearing
     *    the colorbuffer. The color clear value is supplied through both
     *    RB3D_COLOR_CLEAR_VALUE and ZB_DEPTHCLEARVALUE, and the colorbuffer
     *    must be set in ZB_DEPTHOFFSET and ZB_DEPTHPITCH in addition to
     *    RB3D_COLOROFFSET and RB3D_COLORPITCH. It's obvious that the zbuffer
     *    will not be cleared and multiple render targets cannot be cleared
     *    this way either.
d165 14
a178 1
     * 5) For 16-bit integer buffering, compression causes a hung with one or
d181 4
a184 1
     * 6) Fastfill must not be used if reading of compressed Z data is disabled
d187 2
a188 2
     *    (what the hell does that mean and how does it fit in clearing
     *    the buffers?)
d194 1
a194 1
    struct pipe_framebuffer_state* fb =
d196 103
d300 22
a321 1
    r300_blitter_save_states(r300);
d323 29
a351 5
    util_blitter_clear(r300->blitter,
                       fb->width,
                       fb->height,
                       fb->nr_cbufs,
                       buffers, rgba, depth, stencil);
d355 7
a361 6
static void r300_hw_copy(struct pipe_context* pipe,
                         struct pipe_surface* dst,
                         unsigned dstx, unsigned dsty,
                         struct pipe_surface* src,
                         unsigned srcx, unsigned srcy,
                         unsigned width, unsigned height)
a363 8
    struct r300_textures_state* state =
        (struct r300_textures_state*)r300->textures_state.state;

    /* Yeah we have to save all those states to ensure this blitter operation
     * is really transparent. The states will be restored by the blitter once
     * copying is done. */
    r300_blitter_save_states(r300);
    util_blitter_save_framebuffer(r300->blitter, r300->fb_state.state);
d365 1
a365 6
    util_blitter_save_fragment_sampler_states(
        r300->blitter, state->sampler_count, (void**)state->sampler_states);

    util_blitter_save_fragment_sampler_textures(
        r300->blitter, state->texture_count,
        (struct pipe_texture**)state->textures);
d368 3
a370 2
    util_blitter_copy(r300->blitter,
                      dst, dstx, dsty, src, srcx, srcy, width, height, TRUE);
d374 7
a380 6
void r300_surface_copy(struct pipe_context* pipe,
                       struct pipe_surface* dst,
                       unsigned dstx, unsigned dsty,
                       struct pipe_surface* src,
                       unsigned srcx, unsigned srcy,
                       unsigned width, unsigned height)
d382 1
a382 1
    enum pipe_format old_format = dst->texture->format;
d384 1
a384 3

    assert(dst->texture->format == src->texture->format);

d386 5
a390 3
                                           old_format, src->texture->target,
                                           PIPE_TEXTURE_USAGE_RENDER_TARGET |
                                           PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
d401 3
d407 1
a407 1
                             util_format_name(old_format));
d411 4
a415 3
        dst->format = new_format;
        src->format = new_format;

d417 1
a417 1
                                        dst->texture, new_format);
d419 1
a419 1
                                        src->texture, new_format);
d422 2
a423 1
    r300_hw_copy(pipe, dst, dstx, dsty, src, srcx, srcy, width, height);
a425 3
        dst->format = old_format;
        src->format = old_format;

d427 1
a427 1
                                        dst->texture, old_format);
d429 1
a429 1
                                        src->texture, old_format);
d433 1
a433 6
/* Fill a region of a surface with a constant value. */
void r300_surface_fill(struct pipe_context* pipe,
                       struct pipe_surface* dst,
                       unsigned dstx, unsigned dsty,
                       unsigned width, unsigned height,
                       unsigned value)
d435 4
a438 7
    struct r300_context* r300 = r300_context(pipe);

    r300_blitter_save_states(r300);
    util_blitter_save_framebuffer(r300->blitter, r300->fb_state.state);

    util_blitter_fill(r300->blitter,
                      dst, dstx, dsty, width, height, value);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d23 1
a24 2
#include "r300_emit.h"
#include "r300_hyperz.h"
a25 1
#include "r300_winsys.h"
a27 1
#include "util/u_pack_color.h"
d29 1
a29 1
enum r300_blitter_op /* bitmask */
a30 25
    R300_STOP_QUERY         = 1,
    R300_SAVE_TEXTURES      = 2,
    R300_SAVE_FRAMEBUFFER   = 4,
    R300_IGNORE_RENDER_COND = 8,

    R300_CLEAR         = R300_STOP_QUERY,

    R300_CLEAR_SURFACE = R300_STOP_QUERY | R300_SAVE_FRAMEBUFFER,

    R300_COPY          = R300_STOP_QUERY | R300_SAVE_FRAMEBUFFER |
                         R300_SAVE_TEXTURES | R300_IGNORE_RENDER_COND,

    R300_DECOMPRESS    = R300_STOP_QUERY | R300_IGNORE_RENDER_COND,
};

static void r300_blitter_begin(struct r300_context* r300, enum r300_blitter_op op)
{
    if ((op & R300_STOP_QUERY) && r300->query_current) {
        r300->blitter_saved_query = r300->query_current;
        r300_stop_query(r300);
    }

    /* Yeah we have to save all those states to ensure the blitter operation
     * is really transparent. The states will be restored by the blitter once
     * copying is done. */
d35 1
a35 1
    util_blitter_save_fragment_shader(r300->blitter, r300->fs.state);
d38 1
a38 83
    util_blitter_save_clip(r300->blitter, (struct pipe_clip_state*)r300->clip_state.state);
    util_blitter_save_vertex_elements(r300->blitter, r300->velems);
    util_blitter_save_vertex_buffers(r300->blitter, r300->vertex_buffer_count,
                                     r300->vertex_buffer);

    if (op & R300_SAVE_FRAMEBUFFER)
        util_blitter_save_framebuffer(r300->blitter, r300->fb_state.state);

    if (op & R300_SAVE_TEXTURES) {
        struct r300_textures_state* state =
            (struct r300_textures_state*)r300->textures_state.state;

        util_blitter_save_fragment_sampler_states(
            r300->blitter, state->sampler_state_count,
            (void**)state->sampler_states);

        util_blitter_save_fragment_sampler_views(
            r300->blitter, state->sampler_view_count,
            (struct pipe_sampler_view**)state->sampler_views);
    }

    if (op & R300_IGNORE_RENDER_COND) {
        /* Save the flag. */
        r300->blitter_saved_skip_rendering = r300->skip_rendering+1;
        r300->skip_rendering = FALSE;
    } else {
        r300->blitter_saved_skip_rendering = 0;
    }
}

static void r300_blitter_end(struct r300_context *r300)
{
    if (r300->blitter_saved_query) {
        r300_resume_query(r300, r300->blitter_saved_query);
        r300->blitter_saved_query = NULL;
    }

    if (r300->blitter_saved_skip_rendering) {
        /* Restore the flag. */
        r300->skip_rendering = r300->blitter_saved_skip_rendering-1;
    }
}

static uint32_t r300_depth_clear_cb_value(enum pipe_format format,
                                          const float* rgba)
{
    union util_color uc;
    util_pack_color(rgba, format, &uc);

    if (util_format_get_blocksizebits(format) == 32)
        return uc.ui;
    else
        return uc.us | (uc.us << 16);
}

static boolean r300_cbzb_clear_allowed(struct r300_context *r300,
                                       unsigned clear_buffers)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;

    /* Only color clear allowed, and only one colorbuffer. */
    if (clear_buffers != PIPE_CLEAR_COLOR || fb->nr_cbufs != 1)
        return FALSE;

    return r300_surface(fb->cbufs[0])->cbzb_allowed;
}

static uint32_t r300_depth_clear_value(enum pipe_format format,
                                       double depth, unsigned stencil)
{
    switch (format) {
        case PIPE_FORMAT_Z16_UNORM:
        case PIPE_FORMAT_X8Z24_UNORM:
            return util_pack_z(format, depth);

        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
            return util_pack_z_stencil(format, depth, stencil);

        default:
            assert(0);
            return 0;
    }
d42 26
a67 12
static void r300_clear(struct pipe_context* pipe,
                       unsigned buffers,
                       const float* rgba,
                       double depth,
                       unsigned stencil)
{
    /* My notes about fastfill:
     *
     * 1) Only the zbuffer is cleared.
     *
     * 2) The zbuffer must be micro-tiled and whole microtiles must be
     *    written. If microtiling is disabled, it locks up.
d69 1
a69 14
     * 3) There is Z Mask RAM which contains a compressed zbuffer and
     *    it interacts with fastfill. We should figure out how to use it
     *    to get more performance.
     *    This is what we know about the Z Mask:
     *
     *       Each dword of the Z Mask contains compression information
     *       for 16 4x4 pixel blocks, that is 2 bits for each block.
     *       On chips with 2 Z pipes, every other dword maps to a different
     *       pipe.
     *
     * 4) ZB_DEPTHCLEARVALUE is used to clear the zbuffer and the Z Mask must
     *    be equal to 0. (clear the Z Mask RAM with zeros)
     *
     * 5) For 16-bit zbuffer, compression causes a hung with one or
d72 1
a72 4
     * 6) FORCE_COMPRESSED_STENCIL_VALUE should be enabled for stencil clears
     *    to avoid needless decompression.
     *
     * 7) Fastfill must not be used if reading of compressed Z data is disabled
d75 2
a76 2
     *
     * 8) ZB_CB_CLEAR does not interact with fastfill in any way.
d82 1
a82 1
    struct pipe_framebuffer_state *fb =
a83 76
    struct r300_hyperz_state *hyperz =
        (struct r300_hyperz_state*)r300->hyperz_state.state;
    struct r300_texture *zstex =
            fb->zsbuf ? r300_texture(fb->zsbuf->texture) : NULL;
    uint32_t width = fb->width;
    uint32_t height = fb->height;
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
    uint32_t hyperz_dcv = hyperz->zb_depthclearvalue;

    /* Enable fast Z clear.
     * The zbuffer must be in micro-tiled mode, otherwise it locks up. */
    if ((buffers & PIPE_CLEAR_DEPTHSTENCIL) && can_hyperz) {
        hyperz_dcv = hyperz->zb_depthclearvalue =
            r300_depth_clear_value(fb->zsbuf->format, depth, stencil);

        r300_mark_fb_state_dirty(r300, R300_CHANGED_ZCLEAR_FLAG);
        if (zstex->zmask_mem[fb->zsbuf->u.tex.level]) {
            r300_mark_atom_dirty(r300, &r300->zmask_clear);
            buffers &= ~PIPE_CLEAR_DEPTHSTENCIL;
        }
        if (zstex->hiz_mem[fb->zsbuf->u.tex.level])
            r300_mark_atom_dirty(r300, &r300->hiz_clear);
    }

    /* Enable CBZB clear. */
    if (r300_cbzb_clear_allowed(r300, buffers)) {
        struct r300_surface *surf = r300_surface(fb->cbufs[0]);

        hyperz->zb_depthclearvalue =
                r300_depth_clear_cb_value(surf->base.format, rgba);

        width = surf->cbzb_width;
        height = surf->cbzb_height;

        r300->cbzb_clear = TRUE;
        r300_mark_fb_state_dirty(r300, R300_CHANGED_CBZB_FLAG);
    }

    /* Clear. */
    if (buffers) {
        /* Clear using the blitter. */
        r300_blitter_begin(r300, R300_CLEAR);
        util_blitter_clear(r300->blitter,
                           width,
                           height,
                           fb->nr_cbufs,
                           buffers, rgba, depth, stencil);
        r300_blitter_end(r300);
    } else if (r300->zmask_clear.dirty) {
        /* Just clear zmask and hiz now, this does not use a standard draw
         * procedure. */
        unsigned dwords;

        /* Calculate zmask_clear and hiz_clear atom sizes. */
        r300_update_hyperz_state(r300);
        dwords = r300->zmask_clear.size +
                 (r300->hiz_clear.dirty ? r300->hiz_clear.size : 0) +
                 r300_get_num_cs_end_dwords(r300);

        /* Reserve CS space. */
        if (dwords > (R300_MAX_CMDBUF_DWORDS - r300->cs->cdw)) {
            r300->context.flush(&r300->context, 0, NULL);
        }

        /* Emit clear packets. */
        r300_emit_zmask_clear(r300, r300->zmask_clear.size,
                              r300->zmask_clear.state);
        r300->zmask_clear.dirty = FALSE;
        if (r300->hiz_clear.dirty) {
            r300_emit_hiz_clear(r300, r300->hiz_clear.size,
                                r300->hiz_clear.state);
            r300->hiz_clear.dirty = FALSE;
        }
    } else {
        assert(0);
    }
d85 1
a85 6
    /* Disable CBZB clear. */
    if (r300->cbzb_clear) {
        r300->cbzb_clear = FALSE;
        hyperz->zb_depthclearvalue = hyperz_dcv;
        r300_mark_fb_state_dirty(r300, R300_CHANGED_CBZB_FLAG);
    }
d87 5
a91 9
    /* Enable fastfill and/or hiz.
     *
     * If we cleared zmask/hiz, it's in use now. The Hyper-Z state update
     * looks if zmask/hiz is in use and enables fastfill accordingly. */
    if (zstex &&
        (zstex->zmask_in_use[fb->zsbuf->u.tex.level] ||
         zstex->hiz_in_use[fb->zsbuf->u.tex.level])) {
        r300_mark_atom_dirty(r300, &r300->hyperz_state);
    }
d94 7
a100 6
/* Clear a region of a color surface to a constant value. */
static void r300_clear_render_target(struct pipe_context *pipe,
                                     struct pipe_surface *dst,
                                     const float *rgba,
                                     unsigned dstx, unsigned dsty,
                                     unsigned width, unsigned height)
d102 3
a104 1
    struct r300_context *r300 = r300_context(pipe);
d106 5
a110 5
    r300_blitter_begin(r300, R300_CLEAR_SURFACE);
    util_blitter_clear_render_target(r300->blitter, dst, rgba,
                                     dstx, dsty, width, height);
    r300_blitter_end(r300);
}
d112 2
a113 58
/* Clear a region of a depth stencil surface. */
static void r300_clear_depth_stencil(struct pipe_context *pipe,
                                     struct pipe_surface *dst,
                                     unsigned clear_flags,
                                     double depth,
                                     unsigned stencil,
                                     unsigned dstx, unsigned dsty,
                                     unsigned width, unsigned height)
{
    struct r300_context *r300 = r300_context(pipe);

    r300_blitter_begin(r300, R300_CLEAR_SURFACE);
    util_blitter_clear_depth_stencil(r300->blitter, dst, clear_flags, depth, stencil,
                                     dstx, dsty, width, height);
    r300_blitter_end(r300);
}

/* Flush a depth stencil buffer. */
void r300_flush_depth_stencil(struct pipe_context *pipe,
                              struct pipe_resource *dst,
                              unsigned level,
                              unsigned layer)
{
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_surface *dstsurf, surf_tmpl;
    struct r300_texture *tex = r300_texture(dst);

    if (!tex->zmask_mem[level])
        return;
    if (!tex->zmask_in_use[level])
        return;

    surf_tmpl.format = dst->format;
    surf_tmpl.usage = PIPE_BIND_DEPTH_STENCIL;
    surf_tmpl.u.tex.level = level;
    surf_tmpl.u.tex.first_layer = layer;
    surf_tmpl.u.tex.last_layer = layer;
    dstsurf = pipe->create_surface(pipe, dst, &surf_tmpl);

    r300->z_decomp_rd = TRUE;
    r300_blitter_begin(r300, R300_DECOMPRESS);
    util_blitter_flush_depth_stencil(r300->blitter, dstsurf);
    r300_blitter_end(r300);
    r300->z_decomp_rd = FALSE;

    tex->zmask_in_use[level] = FALSE;
}

/* Copy a block of pixels from one surface to another using HW. */
static void r300_hw_copy_region(struct pipe_context* pipe,
                                struct pipe_resource *dst,
                                unsigned dst_level,
                                unsigned dstx, unsigned dsty, unsigned dstz,
                                struct pipe_resource *src,
                                unsigned src_level,
                                const struct pipe_box *src_box)
{
    struct r300_context* r300 = r300_context(pipe);
d115 3
a117 1
    r300_blitter_begin(r300, R300_COPY);
d120 2
a121 3
    util_blitter_copy_region(r300->blitter, dst, dst_level, dstx, dsty, dstz,
                             src, src_level, src_box, TRUE);
    r300_blitter_end(r300);
d125 6
a130 7
static void r300_resource_copy_region(struct pipe_context *pipe,
                                      struct pipe_resource *dst,
                                      unsigned dst_level,
                                      unsigned dstx, unsigned dsty, unsigned dstz,
                                      struct pipe_resource *src,
                                      unsigned src_level,
                                      const struct pipe_box *src_box)
d132 1
a132 1
    enum pipe_format old_format = dst->format;
d134 3
a136 1
    boolean is_depth;
d138 3
a140 5
                                           old_format, src->target,
                                           src->nr_samples,
                                           PIPE_BIND_RENDER_TARGET |
                                           PIPE_BIND_SAMPLER_VIEW, 0) &&
        util_format_is_plain(old_format)) {
a150 3
            case 8:
                new_format = PIPE_FORMAT_R16G16B16A16_UNORM;
                break;
d154 1
a154 1
                             util_format_short_name(old_format));
a157 4
    is_depth = util_format_get_component_bits(src->format, UTIL_FORMAT_COLORSPACE_ZS, 0) != 0;
    if (is_depth) {
        r300_flush_depth_stencil(pipe, src, src_level, src_box->z);
    }
d159 3
d163 1
a163 1
                                        dst, new_format);
d165 1
a165 1
                                        src, new_format);
d168 1
a168 2
    r300_hw_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                        src, src_level, src_box);
d171 3
d175 1
a175 1
                                        dst, old_format);
d177 1
a177 1
                                        src, old_format);
d181 6
a186 1
void r300_init_blit_functions(struct r300_context *r300)
d188 7
a194 4
    r300->context.clear = r300_clear;
    r300->context.clear_render_target = r300_clear_render_target;
    r300->context.clear_depth_stencil = r300_clear_depth_stencil;
    r300->context.resource_copy_region = r300_resource_copy_region;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d25 1
d27 1
a27 1
#include "r300_reg.h"
a29 1
#include "util/u_half.h"
a30 1
#include "util/u_surface.h"
a45 3
    R300_BLIT          = R300_STOP_QUERY | R300_SAVE_FRAMEBUFFER |
                         R300_SAVE_TEXTURES | R300_IGNORE_RENDER_COND,

d66 1
a66 3
    util_blitter_save_scissor(r300->blitter, r300->scissor_state.state);
    util_blitter_save_sample_mask(r300->blitter, *(unsigned*)r300->sample_mask.state);
    util_blitter_save_vertex_buffer_slot(r300->blitter, r300->vertex_buffer);
d68 2
d71 1
a71 1
    if (op & R300_SAVE_FRAMEBUFFER) {
a72 1
    }
a133 17
static boolean r300_fast_zclear_allowed(struct r300_context *r300,
                                        unsigned clear_buffers)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;

    return r300_resource(fb->zsbuf->texture)->tex.zmask_dwords[fb->zsbuf->u.tex.level] != 0;
}

static boolean r300_hiz_clear_allowed(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;

    return r300_resource(fb->zsbuf->texture)->tex.hiz_dwords[fb->zsbuf->u.tex.level] != 0;
}

d142 1
a142 1
        case PIPE_FORMAT_S8_UINT_Z24_UNORM:
a150 29
static uint32_t r300_hiz_clear_value(double depth)
{
    uint32_t r = (uint32_t)(CLAMP(depth, 0, 1) * 255.5);
    assert(r <= 255);
    return r | (r << 8) | (r << 16) | (r << 24);
}

static void r300_set_clear_color(struct r300_context *r300,
                                 const union pipe_color_union *color)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    union util_color uc;

    memset(&uc, 0, sizeof(uc));
    util_pack_color(color->f, fb->cbufs[0]->format, &uc);

    if (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
        fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16X16_FLOAT) {
        /* (0,1,2,3) maps to (B,G,R,A) */
        r300->color_clear_value_gb = uc.h[0] | ((uint32_t)uc.h[1] << 16);
        r300->color_clear_value_ar = uc.h[2] | ((uint32_t)uc.h[3] << 16);
    } else {
        r300->color_clear_value = uc.ui;
    }
}

DEBUG_GET_ONCE_BOOL_OPTION(hyperz, "RADEON_HYPERZ", FALSE)

d154 1
a154 1
                       const union pipe_color_union *color,
d158 6
a163 1
    /* My notes about Zbuffer compression:
d165 4
a168 26
     * 1) The zbuffer must be micro-tiled and whole microtiles must be
     *    written if compression is enabled. If microtiling is disabled,
     *    it locks up.
     *
     * 2) There is ZMASK RAM which contains a compressed zbuffer.
     *    Each dword of the Z Mask contains compression information
     *    for 16 4x4 pixel tiles, that is 2 bits for each tile.
     *    On chips with 2 Z pipes, every other dword maps to a different
     *    pipe. On newer chipsets, there is a new compression mode
     *    with 8x8 pixel tiles per 2 bits.
     *
     * 3) The FASTFILL bit has nothing to do with filling. It only tells hw
     *    it should look in the ZMASK RAM first before fetching from a real
     *    zbuffer.
     *
     * 4) If a pixel is in a cleared state, ZB_DEPTHCLEARVALUE is returned
     *    during zbuffer reads instead of the value that is actually stored
     *    in the zbuffer memory. A pixel is in a cleared state when its ZMASK
     *    is equal to 0. Therefore, if you clear ZMASK with zeros, you may
     *    leave the zbuffer memory uninitialized, but then you must enable
     *    compression, so that the ZMASK RAM is actually used.
     *
     * 5) Each 4x4 (or 8x8) tile is automatically decompressed and recompressed
     *    during zbuffer updates. A special decompressing operation should be
     *    used to fully decompress a zbuffer, which basically just stores all
     *    compressed tiles in ZMASK to the zbuffer memory.
d170 9
a178 1
     * 6) For a 16-bit zbuffer, compression causes a hung with one or
d181 1
a181 1
     * 7) FORCE_COMPRESSED_STENCIL_VALUE should be enabled for stencil clears
d184 1
a184 1
     * 8) Fastfill must not be used if reading of compressed Z data is disabled
d188 1
a188 1
     * 9) ZB_CB_CLEAR does not interact with zbuffer compression in any way.
d198 2
d202 1
d205 1
a205 1
    /* Use fast Z clear.
d207 8
a214 46
    if (buffers & PIPE_CLEAR_DEPTHSTENCIL) {
        boolean zmask_clear, hiz_clear;

        /* If both depth and stencil are present, they must be cleared together. */
        if (fb->zsbuf->texture->format == PIPE_FORMAT_S8_UINT_Z24_UNORM &&
            (buffers & PIPE_CLEAR_DEPTHSTENCIL) != PIPE_CLEAR_DEPTHSTENCIL) {
            zmask_clear = FALSE;
            hiz_clear = FALSE;
        } else {
            zmask_clear = r300_fast_zclear_allowed(r300, buffers);
            hiz_clear = r300_hiz_clear_allowed(r300);
        }

        /* If we need Hyper-Z. */
        if (zmask_clear || hiz_clear) {
            /* Try to obtain the access to Hyper-Z buffers if we don't have one. */
            if (!r300->hyperz_enabled &&
                (r300->screen->caps.is_r500 || debug_get_option_hyperz())) {
                r300->hyperz_enabled =
                    r300->rws->cs_request_feature(r300->cs,
                                                RADEON_FID_R300_HYPERZ_ACCESS,
                                                TRUE);
                if (r300->hyperz_enabled) {
                   /* Need to emit HyperZ buffer regs for the first time. */
                   r300_mark_fb_state_dirty(r300, R300_CHANGED_HYPERZ_FLAG);
                }
            }

            /* Setup Hyper-Z clears. */
            if (r300->hyperz_enabled) {
                if (zmask_clear) {
                    hyperz_dcv = hyperz->zb_depthclearvalue =
                        r300_depth_clear_value(fb->zsbuf->format, depth, stencil);

                    r300_mark_atom_dirty(r300, &r300->zmask_clear);
                    r300_mark_atom_dirty(r300, &r300->gpu_flush);
                    buffers &= ~PIPE_CLEAR_DEPTHSTENCIL;
                }

                if (hiz_clear) {
                    r300->hiz_clear_value = r300_hiz_clear_value(depth);
                    r300_mark_atom_dirty(r300, &r300->hiz_clear);
                    r300_mark_atom_dirty(r300, &r300->gpu_flush);
                }
                r300->num_z_clears++;
            }
d216 2
a219 37
    /* Use fast color clear for an AA colorbuffer.
     * The CMASK is shared between all colorbuffers, so we use it
     * if there is only one colorbuffer bound. */
    if ((buffers & PIPE_CLEAR_COLOR) && fb->nr_cbufs == 1 &&
        r300_resource(fb->cbufs[0]->texture)->tex.cmask_dwords) {
        /* Try to obtain the access to the CMASK if we don't have one. */
        if (!r300->cmask_access) {
            r300->cmask_access =
                r300->rws->cs_request_feature(r300->cs,
                                              RADEON_FID_R300_CMASK_ACCESS,
                                              TRUE);
        }

        /* Setup the clear. */
        if (r300->cmask_access) {
            /* Pair the resource with the CMASK to avoid other resources
             * accessing it. */
            if (!r300->screen->cmask_resource) {
                pipe_mutex_lock(r300->screen->cmask_mutex);
                /* Double checking (first unlocked, then locked). */
                if (!r300->screen->cmask_resource) {
                    /* Don't reference this, so that the texture can be
                     * destroyed while set in cmask_resource.
                     * Then in texture_destroy, we set cmask_resource to NULL. */
                    r300->screen->cmask_resource = fb->cbufs[0]->texture;
                }
                pipe_mutex_unlock(r300->screen->cmask_mutex);
            }

            if (r300->screen->cmask_resource == fb->cbufs[0]->texture) {
                r300_set_clear_color(r300, color);
                r300_mark_atom_dirty(r300, &r300->cmask_clear);
                r300_mark_atom_dirty(r300, &r300->gpu_flush);
                buffers &= ~PIPE_CLEAR_COLOR;
            }
        }
    }
d221 1
a221 1
    else if (r300_cbzb_clear_allowed(r300, buffers)) {
d225 1
a225 1
                r300_depth_clear_cb_value(surf->base.format, color->f);
d231 1
a231 1
        r300_mark_fb_state_dirty(r300, R300_CHANGED_HYPERZ_FLAG);
d241 2
a242 1
                           buffers, color, depth, stencil);
d244 2
a245 4
    } else if (r300->zmask_clear.dirty ||
               r300->hiz_clear.dirty ||
               r300->cmask_clear.dirty) {
        /* Just clear zmask and hiz now, this does not use the standard draw
d247 2
d250 4
a253 6
        unsigned dwords =
            r300->gpu_flush.size +
            (r300->zmask_clear.dirty ? r300->zmask_clear.size : 0) +
            (r300->hiz_clear.dirty ? r300->hiz_clear.size : 0) +
            (r300->cmask_clear.dirty ? r300->cmask_clear.size : 0) +
            r300_get_num_cs_end_dwords(r300);
d256 2
a257 2
        if (dwords > (RADEON_MAX_CMDBUF_DWORDS - r300->cs->cdw)) {
            r300_flush(&r300->context, RADEON_FLUSH_ASYNC, NULL);
d261 3
a263 8
        r300_emit_gpu_flush(r300, r300->gpu_flush.size, r300->gpu_flush.state);
        r300->gpu_flush.dirty = FALSE;

        if (r300->zmask_clear.dirty) {
            r300_emit_zmask_clear(r300, r300->zmask_clear.size,
                                  r300->zmask_clear.state);
            r300->zmask_clear.dirty = FALSE;
        }
a268 5
        if (r300->cmask_clear.dirty) {
            r300_emit_cmask_clear(r300, r300->cmask_clear.size,
                                  r300->cmask_clear.state);
            r300->cmask_clear.dirty = FALSE;
        }
d277 1
a277 1
        r300_mark_fb_state_dirty(r300, R300_CHANGED_HYPERZ_FLAG);
d283 4
a286 2
     * looks if zmask/hiz is in use and programs hardware accordingly. */
    if (r300->zmask_in_use || r300->hiz_in_use) {
d294 1
a294 1
                                     const union pipe_color_union *color,
d301 1
a301 1
    util_blitter_clear_render_target(r300->blitter, dst, color,
a315 2
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
a316 7
    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        if (fb->zsbuf->texture == dst->texture) {
            r300_decompress_zmask(r300);
        }
    }

    /* XXX Do not decompress ZMask of the currently-set zbuffer. */
d323 5
a327 1
void r300_decompress_zmask(struct r300_context *r300)
d329 3
a331 2
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
d333 3
a335 1
    if (!r300->zmask_in_use || r300->locked_zbuffer)
d338 6
a343 2
    r300->zmask_decompress = TRUE;
    r300_mark_atom_dirty(r300, &r300->hyperz_state);
d345 1
d347 1
a347 2
    util_blitter_custom_clear_depth(r300->blitter, fb->width, fb->height, 0,
                                    r300->dsa_decompress_zmask);
d349 1
d351 1
a351 3
    r300->zmask_decompress = FALSE;
    r300->zmask_in_use = FALSE;
    r300_mark_atom_dirty(r300, &r300->hyperz_state);
d354 8
a361 1
void r300_decompress_zmask_locked_unsafe(struct r300_context *r300)
d363 1
a363 1
    struct pipe_framebuffer_state fb;
d365 1
a365 4
    memset(&fb, 0, sizeof(fb));
    fb.width = r300->locked_zbuffer->width;
    fb.height = r300->locked_zbuffer->height;
    fb.zsbuf = r300->locked_zbuffer;
d367 4
a370 25
    r300->context.set_framebuffer_state(&r300->context, &fb);
    r300_decompress_zmask(r300);
}

void r300_decompress_zmask_locked(struct r300_context *r300)
{
    struct pipe_framebuffer_state saved_fb;

    memset(&saved_fb, 0, sizeof(saved_fb));
    util_copy_framebuffer_state(&saved_fb, r300->fb_state.state);
    r300_decompress_zmask_locked_unsafe(r300);
    r300->context.set_framebuffer_state(&r300->context, &saved_fb);
    util_unreference_framebuffer_state(&saved_fb);

    pipe_surface_reference(&r300->locked_zbuffer, NULL);
}

bool r300_is_blit_supported(enum pipe_format format)
{
    const struct util_format_description *desc =
        util_format_description(format);

    return desc->layout == UTIL_FORMAT_LAYOUT_PLAIN ||
           desc->layout == UTIL_FORMAT_LAYOUT_S3TC ||
           desc->layout == UTIL_FORMAT_LAYOUT_RGTC;
d382 10
a391 44
    struct pipe_screen *screen = pipe->screen;
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    unsigned src_width0 = r300_resource(src)->tex.width0;
    unsigned src_height0 = r300_resource(src)->tex.height0;
    unsigned dst_width0 = r300_resource(dst)->tex.width0;
    unsigned dst_height0 = r300_resource(dst)->tex.height0;
    unsigned layout;
    struct pipe_box box, dstbox;
    struct pipe_sampler_view src_templ, *src_view;
    struct pipe_surface dst_templ, *dst_view;

    /* Fallback for buffers. */
    if ((dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) ||
        !r300_is_blit_supported(dst->format)) {
        util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                  src, src_level, src_box);
        return;
    }

    /* Can't read MSAA textures. */
    if (src->nr_samples > 1 || dst->nr_samples > 1) {
        return;
    }

    /* The code below changes the texture format so that the copy can be done
     * on hardware. E.g. depth-stencil surfaces are copied as RGBA
     * colorbuffers. */

    util_blitter_default_dst_texture(&dst_templ, dst, dst_level, dstz);
    util_blitter_default_src_texture(&src_templ, src, src_level);

    layout = util_format_description(dst_templ.format)->layout;

    /* Handle non-renderable plain formats. */
    if (layout == UTIL_FORMAT_LAYOUT_PLAIN &&
        (!screen->is_format_supported(screen, src_templ.format, src->target,
                                      src->nr_samples,
                                      PIPE_BIND_SAMPLER_VIEW) ||
         !screen->is_format_supported(screen, dst_templ.format, dst->target,
                                      dst->nr_samples,
                                      PIPE_BIND_RENDER_TARGET))) {
        switch (util_format_get_blocksize(dst_templ.format)) {
d393 1
a393 1
                dst_templ.format = PIPE_FORMAT_I8_UNORM;
d396 1
a396 1
                dst_templ.format = PIPE_FORMAT_B4G4R4A4_UNORM;
d399 1
a399 1
                dst_templ.format = PIPE_FORMAT_B8G8R8A8_UNORM;
d402 1
a402 1
                dst_templ.format = PIPE_FORMAT_R16G16B16A16_UNORM;
d405 3
a407 3
                debug_printf("r300: copy_region: Unhandled format: %s. Falling back to software.\n"
                             "r300: copy_region: Software fallback doesn't work for tiled textures.\n",
                             util_format_short_name(dst_templ.format));
a408 1
        src_templ.format = dst_templ.format;
d411 3
a413 52
    /* Handle compressed formats. */
    if (layout == UTIL_FORMAT_LAYOUT_S3TC ||
        layout == UTIL_FORMAT_LAYOUT_RGTC) {
        assert(src_templ.format == dst_templ.format);

        box = *src_box;
        src_box = &box;

        dst_width0 = align(dst_width0, 4);
        dst_height0 = align(dst_height0, 4);
        src_width0 = align(src_width0, 4);
        src_height0 = align(src_height0, 4);
        box.width = align(box.width, 4);
        box.height = align(box.height, 4);

        switch (util_format_get_blocksize(dst_templ.format)) {
        case 8:
            /* one 4x4 pixel block has 8 bytes.
             * we set 1 pixel = 4 bytes ===> 1 block corrensponds to 2 pixels. */
            dst_templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
            dst_width0 = dst_width0 / 2;
            src_width0 = src_width0 / 2;
            dstx /= 2;
            box.x /= 2;
            box.width /= 2;
            break;
        case 16:
            /* one 4x4 pixel block has 16 bytes.
             * we set 1 pixel = 4 bytes ===> 1 block corresponds to 4 pixels. */
            dst_templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
            break;
        }
        src_templ.format = dst_templ.format;

        dst_height0 = dst_height0 / 4;
        src_height0 = src_height0 / 4;
        dsty /= 4;
        box.y /= 4;
        box.height /= 4;
    }

    /* Fallback for textures. */
    if (!screen->is_format_supported(screen, dst_templ.format,
                                     dst->target, dst->nr_samples,
                                     PIPE_BIND_RENDER_TARGET) ||
	!screen->is_format_supported(screen, src_templ.format,
                                     src->target, src->nr_samples,
                                     PIPE_BIND_SAMPLER_VIEW)) {
        assert(0 && "this shouldn't happen, update r300_is_blit_supported");
        util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                  src, src_level, src_box);
        return;
d415 5
a419 7

    /* Decompress ZMASK. */
    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        if (fb->zsbuf->texture == src ||
            fb->zsbuf->texture == dst) {
            r300_decompress_zmask(r300);
        }
d422 2
a423 77
    dst_view = r300_create_surface_custom(pipe, dst, &dst_templ, dst_width0, dst_height0);
    src_view = r300_create_sampler_view_custom(pipe, src, &src_templ, src_width0, src_height0);

    u_box_3d(dstx, dsty, dstz, abs(src_box->width), abs(src_box->height),
             abs(src_box->depth), &dstbox);

    r300_blitter_begin(r300, R300_COPY);
    util_blitter_blit_generic(r300->blitter, dst_view, &dstbox,
                              src_view, src_box, src_width0, src_height0,
                              PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL,
                              FALSE);
    r300_blitter_end(r300);

    pipe_surface_reference(&dst_view, NULL);
    pipe_sampler_view_reference(&src_view, NULL);
}

static boolean r300_is_simple_msaa_resolve(const struct pipe_blit_info *info)
{
    unsigned dst_width = u_minify(info->dst.resource->width0, info->dst.level);
    unsigned dst_height = u_minify(info->dst.resource->height0, info->dst.level);

    return info->dst.resource->format == info->src.resource->format &&
           info->dst.resource->format == info->dst.format &&
           info->src.resource->format == info->src.format &&
           !info->scissor_enable &&
           info->mask == PIPE_MASK_RGBA &&
           dst_width == info->src.resource->width0 &&
           dst_height == info->src.resource->height0 &&
           info->dst.box.x == 0 &&
           info->dst.box.y == 0 &&
           info->dst.box.width == dst_width &&
           info->dst.box.height == dst_height &&
           info->src.box.x == 0 &&
           info->src.box.y == 0 &&
           info->src.box.width == dst_width &&
           info->src.box.height == dst_height &&
           (r300_resource(info->dst.resource)->tex.microtile != RADEON_LAYOUT_LINEAR ||
            r300_resource(info->dst.resource)->tex.macrotile[info->dst.level] != RADEON_LAYOUT_LINEAR);
}

static void r300_simple_msaa_resolve(struct pipe_context *pipe,
                                     struct pipe_resource *dst,
                                     unsigned dst_level,
                                     unsigned dst_layer,
                                     struct pipe_resource *src,
                                     enum pipe_format format)
{
    struct r300_context *r300 = r300_context(pipe);
    struct r300_surface *srcsurf, *dstsurf;
    struct pipe_surface surf_tmpl;
    struct r300_aa_state *aa = (struct r300_aa_state*)r300->aa_state.state;

    memset(&surf_tmpl, 0, sizeof(surf_tmpl));
    surf_tmpl.format = format;
    srcsurf = r300_surface(pipe->create_surface(pipe, src, &surf_tmpl));

    surf_tmpl.format = format;
    surf_tmpl.u.tex.level = dst_level;
    surf_tmpl.u.tex.first_layer =
    surf_tmpl.u.tex.last_layer = dst_layer;
    dstsurf = r300_surface(pipe->create_surface(pipe, dst, &surf_tmpl));

    /* COLORPITCH should contain the tiling info of the resolve buffer.
     * The tiling of the AA buffer isn't programmable anyway. */
    srcsurf->pitch &= ~(R300_COLOR_TILE(1) | R300_COLOR_MICROTILE(3));
    srcsurf->pitch |= dstsurf->pitch & (R300_COLOR_TILE(1) | R300_COLOR_MICROTILE(3));

    /* Enable AA resolve. */
    aa->dest = dstsurf;
    r300->aa_state.size = 8;
    r300_mark_atom_dirty(r300, &r300->aa_state);

    /* Resolve the surface. */
    r300_blitter_begin(r300, R300_CLEAR_SURFACE);
    util_blitter_custom_color(r300->blitter, &srcsurf->base, NULL);
    r300_blitter_end(r300);
d425 5
a429 72
    /* Disable AA resolve. */
    aa->dest = NULL;
    r300->aa_state.size = 4;
    r300_mark_atom_dirty(r300, &r300->aa_state);

    pipe_surface_reference((struct pipe_surface**)&srcsurf, NULL);
    pipe_surface_reference((struct pipe_surface**)&dstsurf, NULL);
}

static void r300_msaa_resolve(struct pipe_context *pipe,
                              const struct pipe_blit_info *info)
{
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_screen *screen = pipe->screen;
    struct pipe_resource *tmp, templ;
    struct pipe_blit_info blit;

    assert(info->src.level == 0);
    assert(info->src.box.z == 0);
    assert(info->src.box.depth == 1);
    assert(info->dst.box.depth == 1);

    if (r300_is_simple_msaa_resolve(info)) {
        r300_simple_msaa_resolve(pipe, info->dst.resource, info->dst.level,
                                 info->dst.box.z, info->src.resource,
                                 info->src.format);
        return;
    }

    /* resolve into a temporary texture, then blit */
    memset(&templ, 0, sizeof(templ));
    templ.target = PIPE_TEXTURE_2D;
    templ.format = info->src.resource->format;
    templ.width0 = info->src.resource->width0;
    templ.height0 = info->src.resource->height0;
    templ.depth0 = 1;
    templ.array_size = 1;
    templ.usage = PIPE_USAGE_STATIC;
    templ.flags = R300_RESOURCE_FORCE_MICROTILING;

    tmp = screen->resource_create(screen, &templ);

    /* resolve */
    r300_simple_msaa_resolve(pipe, tmp, 0, 0, info->src.resource,
                             info->src.format);

    /* blit */
    blit = *info;
    blit.src.resource = tmp;
    blit.src.box.z = 0;

    r300_blitter_begin(r300, R300_BLIT);
    util_blitter_blit(r300->blitter, &blit);
    r300_blitter_end(r300);

    pipe_resource_reference(&tmp, NULL);
}

static void r300_blit(struct pipe_context *pipe,
                      const struct pipe_blit_info *blit)
{
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct pipe_blit_info info = *blit;

    /* MSAA resolve. */
    if (info.src.resource->nr_samples > 1 &&
        info.dst.resource->nr_samples <= 1 &&
        !util_format_is_depth_or_stencil(info.src.resource->format)) {
        r300_msaa_resolve(pipe, &info);
        return;
a430 40

    /* Can't read MSAA textures. */
    if (info.src.resource->nr_samples > 1) {
        return;
    }

    /* Blit a combined depth-stencil resource as color.
     * S8Z24 is the only supported stencil format. */
    if ((info.mask & PIPE_MASK_S) &&
        info.src.format == PIPE_FORMAT_S8_UINT_Z24_UNORM &&
        info.dst.format == PIPE_FORMAT_S8_UINT_Z24_UNORM) {
        if (info.dst.resource->nr_samples > 1) {
            /* Cannot do that with MSAA buffers. */
            info.mask &= ~PIPE_MASK_S;
            if (!(info.mask & PIPE_MASK_Z)) {
                return;
            }
        } else {
            /* Single-sample buffer. */
            info.src.format = PIPE_FORMAT_B8G8R8A8_UNORM;
            info.dst.format = PIPE_FORMAT_B8G8R8A8_UNORM;
            if (info.mask & PIPE_MASK_Z) {
                info.mask = PIPE_MASK_RGBA; /* depth+stencil */
            } else {
                info.mask = PIPE_MASK_B; /* stencil only */
            }
        }
    }

    /* Decompress ZMASK. */
    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        if (fb->zsbuf->texture == info.src.resource ||
            fb->zsbuf->texture == info.dst.resource) {
            r300_decompress_zmask(r300);
        }
    }

    r300_blitter_begin(r300, R300_BLIT);
    util_blitter_blit(r300->blitter, &info);
    r300_blitter_end(r300);
a438 1
    r300->context.blit = r300_blit;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d121 1
a121 1
        return uc.ui[0];
d133 1
a133 1
    if ((clear_buffers & ~PIPE_CLEAR_COLOR) != 0 || fb->nr_cbufs != 1 || !fb->cbufs[0])
d196 1
a196 1
        r300->color_clear_value = uc.ui[0];
d316 1
a316 1
    if ((buffers & PIPE_CLEAR_COLOR) && fb->nr_cbufs == 1 && fb->cbufs[0] &&
d368 3
a370 1
        util_blitter_clear(r300->blitter, width, height, 1,
d672 2
a673 1
                              PIPE_MASK_RGBAZS, PIPE_TEX_FILTER_NEAREST, NULL);
d778 1
a778 1
    templ.usage = PIPE_USAGE_DEFAULT;
a855 5
static void r300_flush_resource(struct pipe_context *ctx,
				struct pipe_resource *resource)
{
}

a862 1
    r300->context.flush_resource = r300_flush_resource;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d48 1
a48 1
                         R300_SAVE_TEXTURES,
d682 1
a682 3
    return info->src.resource->nr_samples > 1 &&
           info->dst.resource->nr_samples <= 1 &&
           info->dst.resource->format == info->src.resource->format &&
d789 1
a789 1
    r300_blitter_begin(r300, R300_BLIT | R300_IGNORE_RENDER_COND);
d806 1
d848 1
a848 2
    r300_blitter_begin(r300, R300_BLIT |
		       (info.render_condition_enable ? 0 : R300_IGNORE_RENDER_COND));
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d48 1
a48 1
                         R300_SAVE_TEXTURES | R300_IGNORE_RENDER_COND,
d682 3
a684 1
    return info->dst.resource->format == info->src.resource->format &&
d791 1
a791 1
    r300_blitter_begin(r300, R300_BLIT);
a807 1
        info.dst.resource->nr_samples <= 1 &&
d849 2
a850 1
    r300_blitter_begin(r300, R300_BLIT);
@


