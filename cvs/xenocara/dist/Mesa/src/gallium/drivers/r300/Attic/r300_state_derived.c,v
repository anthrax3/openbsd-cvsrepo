head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.2
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.07.29.05.47.25;	author mpi;	state Exp;
branches;
next	1.5;
commitid	7LgDWgovbCk9WPgF;

1.5
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.58;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.03;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.07;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2009 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "draw/draw_context.h"

#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_pack_color.h"

#include "r300_context.h"
#include "r300_fs.h"
#include "r300_screen.h"
#include "r300_shader_semantics.h"
#include "r300_state_inlines.h"
#include "r300_texture.h"
#include "r300_vs.h"

/* r300_state_derived: Various bits of state which are dependent upon
 * currently bound CSO data. */

enum r300_rs_swizzle {
    SWIZ_XYZW = 0,
    SWIZ_X001,
    SWIZ_XY01,
    SWIZ_0001,
};

enum r300_rs_col_write_type {
    WRITE_COLOR = 0,
    WRITE_FACE
};

static void r300_draw_emit_attrib(struct r300_context* r300,
                                  enum attrib_emit emit,
                                  enum interp_mode interp,
                                  int index)
{
    struct r300_vertex_shader* vs = r300->vs_state.state;
    struct tgsi_shader_info* info = &vs->info;
    int output;

    output = draw_find_shader_output(r300->draw,
                                     info->output_semantic_name[index],
                                     info->output_semantic_index[index]);
    draw_emit_vertex_attr(&r300->vertex_info, emit, interp, output);
}

static void r300_draw_emit_all_attribs(struct r300_context* r300)
{
    struct r300_vertex_shader* vs = r300->vs_state.state;
    struct r300_shader_semantics* vs_outputs = &vs->outputs;
    int i, gen_count;

    /* Position. */
    if (vs_outputs->pos != ATTR_UNUSED) {
        r300_draw_emit_attrib(r300, EMIT_4F, INTERP_PERSPECTIVE,
                              vs_outputs->pos);
    } else {
        assert(0);
    }

    /* Point size. */
    if (vs_outputs->psize != ATTR_UNUSED) {
        r300_draw_emit_attrib(r300, EMIT_1F_PSIZE, INTERP_POS,
                              vs_outputs->psize);
    }

    /* Colors. */
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        if (vs_outputs->color[i] != ATTR_UNUSED) {
            r300_draw_emit_attrib(r300, EMIT_4F, INTERP_LINEAR,
                                  vs_outputs->color[i]);
        }
    }

    /* Back-face colors. */
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        if (vs_outputs->bcolor[i] != ATTR_UNUSED) {
            r300_draw_emit_attrib(r300, EMIT_4F, INTERP_LINEAR,
                                  vs_outputs->bcolor[i]);
        }
    }

    /* Texture coordinates. */
    /* Only 8 generic vertex attributes can be used. If there are more,
     * they won't be rasterized. */
    gen_count = 0;
    for (i = 0; i < ATTR_GENERIC_COUNT && gen_count < 8; i++) {
        if (vs_outputs->generic[i] != ATTR_UNUSED &&
            !(r300->sprite_coord_enable & (1 << i))) {
            r300_draw_emit_attrib(r300, EMIT_4F, INTERP_PERSPECTIVE,
                                  vs_outputs->generic[i]);
            gen_count++;
        }
    }

    /* Fog coordinates. */
    if (gen_count < 8 && vs_outputs->fog != ATTR_UNUSED) {
        r300_draw_emit_attrib(r300, EMIT_4F, INTERP_PERSPECTIVE,
                              vs_outputs->fog);
        gen_count++;
    }

    /* WPOS. */
    if (r300_fs(r300)->shader->inputs.wpos != ATTR_UNUSED && gen_count < 8) {
        DBG(r300, DBG_SWTCL, "draw_emit_attrib: WPOS, index: %i\n",
            vs_outputs->wpos);
        r300_draw_emit_attrib(r300, EMIT_4F, INTERP_PERSPECTIVE,
                              vs_outputs->wpos);
    }
}

/* Update the PSC tables for SW TCL, using Draw. */
static void r300_swtcl_vertex_psc(struct r300_context *r300)
{
    struct r300_vertex_stream_state *vstream = r300->vertex_stream_state.state;
    struct vertex_info *vinfo = &r300->vertex_info;
    uint16_t type, swizzle;
    enum pipe_format format;
    unsigned i, attrib_count;
    int* vs_output_tab = r300->stream_loc_notcl;

    memset(vstream, 0, sizeof(struct r300_vertex_stream_state));

    /* For each Draw attribute, route it to the fragment shader according
     * to the vs_output_tab. */
    attrib_count = vinfo->num_attribs;
    DBG(r300, DBG_SWTCL, "r300: attrib count: %d\n", attrib_count);
    for (i = 0; i < attrib_count; i++) {
        if (vs_output_tab[i] == -1) {
            assert(0);
            abort();
        }

        format = draw_translate_vinfo_format(vinfo->attrib[i].emit);

        DBG(r300, DBG_SWTCL,
            "r300: swtcl_vertex_psc [%i] <- %s\n",
            vs_output_tab[i], util_format_short_name(format));

        /* Obtain the type of data in this attribute. */
        type = r300_translate_vertex_data_type(format);
        if (type == R300_INVALID_FORMAT) {
            fprintf(stderr, "r300: Bad vertex format %s.\n",
                    util_format_short_name(format));
            assert(0);
            abort();
        }

        type |= vs_output_tab[i] << R300_DST_VEC_LOC_SHIFT;

        /* Obtain the swizzle for this attribute. Note that the default
         * swizzle in the hardware is not XYZW! */
        swizzle = r300_translate_vertex_data_swizzle(format);

        /* Add the attribute to the PSC table. */
        if (i & 1) {
            vstream->vap_prog_stream_cntl[i >> 1] |= type << 16;
            vstream->vap_prog_stream_cntl_ext[i >> 1] |= swizzle << 16;
        } else {
            vstream->vap_prog_stream_cntl[i >> 1] |= type;
            vstream->vap_prog_stream_cntl_ext[i >> 1] |= swizzle;
        }
    }

    /* Set the last vector in the PSC. */
    if (i) {
        i -= 1;
    }
    vstream->vap_prog_stream_cntl[i >> 1] |=
        (R300_LAST_VEC << (i & 1 ? 16 : 0));

    vstream->count = (i >> 1) + 1;
    r300_mark_atom_dirty(r300, &r300->vertex_stream_state);
    r300->vertex_stream_state.size = (1 + vstream->count) * 2;
}

static void r300_rs_col(struct r300_rs_block* rs, int id, int ptr,
                        enum r300_rs_swizzle swiz)
{
    rs->ip[id] |= R300_RS_COL_PTR(ptr);
    if (swiz == SWIZ_0001) {
        rs->ip[id] |= R300_RS_COL_FMT(R300_RS_COL_FMT_0001);
    } else {
        rs->ip[id] |= R300_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
    }
    rs->inst[id] |= R300_RS_INST_COL_ID(id);
}

static void r300_rs_col_write(struct r300_rs_block* rs, int id, int fp_offset,
                              enum r300_rs_col_write_type type)
{
    assert(type == WRITE_COLOR);
    rs->inst[id] |= R300_RS_INST_COL_CN_WRITE |
                    R300_RS_INST_COL_ADDR(fp_offset);
}

static void r300_rs_tex(struct r300_rs_block* rs, int id, int ptr,
                        enum r300_rs_swizzle swiz)
{
    if (swiz == SWIZ_X001) {
        rs->ip[id] |= R300_RS_TEX_PTR(ptr) |
                      R300_RS_SEL_S(R300_RS_SEL_C0) |
                      R300_RS_SEL_T(R300_RS_SEL_K0) |
                      R300_RS_SEL_R(R300_RS_SEL_K0) |
                      R300_RS_SEL_Q(R300_RS_SEL_K1);
    } else if (swiz == SWIZ_XY01) {
        rs->ip[id] |= R300_RS_TEX_PTR(ptr) |
                      R300_RS_SEL_S(R300_RS_SEL_C0) |
                      R300_RS_SEL_T(R300_RS_SEL_C1) |
                      R300_RS_SEL_R(R300_RS_SEL_K0) |
                      R300_RS_SEL_Q(R300_RS_SEL_K1);
    } else {
        rs->ip[id] |= R300_RS_TEX_PTR(ptr) |
                      R300_RS_SEL_S(R300_RS_SEL_C0) |
                      R300_RS_SEL_T(R300_RS_SEL_C1) |
                      R300_RS_SEL_R(R300_RS_SEL_C2) |
                      R300_RS_SEL_Q(R300_RS_SEL_C3);
    }
    rs->inst[id] |= R300_RS_INST_TEX_ID(id);
}

static void r300_rs_tex_write(struct r300_rs_block* rs, int id, int fp_offset)
{
    rs->inst[id] |= R300_RS_INST_TEX_CN_WRITE |
                    R300_RS_INST_TEX_ADDR(fp_offset);
}

static void r500_rs_col(struct r300_rs_block* rs, int id, int ptr,
                        enum r300_rs_swizzle swiz)
{
    rs->ip[id] |= R500_RS_COL_PTR(ptr);
    if (swiz == SWIZ_0001) {
        rs->ip[id] |= R500_RS_COL_FMT(R300_RS_COL_FMT_0001);
    } else {
        rs->ip[id] |= R500_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
    }
    rs->inst[id] |= R500_RS_INST_COL_ID(id);
}

static void r500_rs_col_write(struct r300_rs_block* rs, int id, int fp_offset,
                              enum r300_rs_col_write_type type)
{
    if (type == WRITE_FACE)
        rs->inst[id] |= R500_RS_INST_COL_CN_WRITE_BACKFACE |
                        R500_RS_INST_COL_ADDR(fp_offset);
    else
        rs->inst[id] |= R500_RS_INST_COL_CN_WRITE |
                        R500_RS_INST_COL_ADDR(fp_offset);

}

static void r500_rs_tex(struct r300_rs_block* rs, int id, int ptr,
			enum r300_rs_swizzle swiz)
{
    if (swiz == SWIZ_X001) {
        rs->ip[id] |= R500_RS_SEL_S(ptr) |
                      R500_RS_SEL_T(R500_RS_IP_PTR_K0) |
                      R500_RS_SEL_R(R500_RS_IP_PTR_K0) |
                      R500_RS_SEL_Q(R500_RS_IP_PTR_K1);
    } else if (swiz == SWIZ_XY01) {
        rs->ip[id] |= R500_RS_SEL_S(ptr) |
                      R500_RS_SEL_T(ptr + 1) |
                      R500_RS_SEL_R(R500_RS_IP_PTR_K0) |
                      R500_RS_SEL_Q(R500_RS_IP_PTR_K1);
    } else {
        rs->ip[id] |= R500_RS_SEL_S(ptr) |
                      R500_RS_SEL_T(ptr + 1) |
                      R500_RS_SEL_R(ptr + 2) |
                      R500_RS_SEL_Q(ptr + 3);
    }
    rs->inst[id] |= R500_RS_INST_TEX_ID(id);
}

static void r500_rs_tex_write(struct r300_rs_block* rs, int id, int fp_offset)
{
    rs->inst[id] |= R500_RS_INST_TEX_CN_WRITE |
                    R500_RS_INST_TEX_ADDR(fp_offset);
}

/* Set up the RS block.
 *
 * This is the part of the chipset that is responsible for linking vertex
 * and fragment shaders and stuffed texture coordinates.
 *
 * The rasterizer reads data from VAP, which produces vertex shader outputs,
 * and GA, which produces stuffed texture coordinates. VAP outputs have
 * precedence over GA. All outputs must be rasterized otherwise it locks up.
 * If there are more outputs rasterized than is set in VAP/GA, it locks up
 * too. The funky part is that this info has been pretty much obtained by trial
 * and error. */
static void r300_update_rs_block(struct r300_context *r300)
{
    struct r300_vertex_shader *vs = r300->vs_state.state;
    struct r300_shader_semantics *vs_outputs = &vs->outputs;
    struct r300_shader_semantics *fs_inputs = &r300_fs(r300)->shader->inputs;
    struct r300_rs_block rs = {0};
    int i, col_count = 0, tex_count = 0, fp_offset = 0, count, loc = 0, tex_ptr = 0;
    int gen_offset = 0;
    void (*rX00_rs_col)(struct r300_rs_block*, int, int, enum r300_rs_swizzle);
    void (*rX00_rs_col_write)(struct r300_rs_block*, int, int, enum r300_rs_col_write_type);
    void (*rX00_rs_tex)(struct r300_rs_block*, int, int, enum r300_rs_swizzle);
    void (*rX00_rs_tex_write)(struct r300_rs_block*, int, int);
    boolean any_bcolor_used = vs_outputs->bcolor[0] != ATTR_UNUSED ||
                              vs_outputs->bcolor[1] != ATTR_UNUSED;
    int *stream_loc_notcl = r300->stream_loc_notcl;
    uint32_t stuffing_enable = 0;

    if (r300->screen->caps.is_r500) {
        rX00_rs_col       = r500_rs_col;
        rX00_rs_col_write = r500_rs_col_write;
        rX00_rs_tex       = r500_rs_tex;
        rX00_rs_tex_write = r500_rs_tex_write;
    } else {
        rX00_rs_col       = r300_rs_col;
        rX00_rs_col_write = r300_rs_col_write;
        rX00_rs_tex       = r300_rs_tex;
        rX00_rs_tex_write = r300_rs_tex_write;
    }

    /* 0x5555 copied from classic, which means:
     * Select user color 0 for COLOR0 up to COLOR7.
     * What the hell does that mean? */
    rs.vap_vtx_state_cntl = 0x5555;

    /* The position is always present in VAP. */
    rs.vap_vsm_vtx_assm |= R300_INPUT_CNTL_POS;
    rs.vap_out_vtx_fmt[0] |= R300_VAP_OUTPUT_VTX_FMT_0__POS_PRESENT;
    stream_loc_notcl[loc++] = 0;

    /* Set up the point size in VAP. */
    if (vs_outputs->psize != ATTR_UNUSED) {
        rs.vap_out_vtx_fmt[0] |= R300_VAP_OUTPUT_VTX_FMT_0__PT_SIZE_PRESENT;
        stream_loc_notcl[loc++] = 1;
    }

    /* Set up and rasterize colors. */
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        if (vs_outputs->color[i] != ATTR_UNUSED || any_bcolor_used ||
            vs_outputs->color[1] != ATTR_UNUSED) {
            /* Set up the color in VAP. */
            rs.vap_vsm_vtx_assm |= R300_INPUT_CNTL_COLOR;
            rs.vap_out_vtx_fmt[0] |=
                    R300_VAP_OUTPUT_VTX_FMT_0__COLOR_0_PRESENT << i;
            stream_loc_notcl[loc++] = 2 + i;

            /* Rasterize it. */
            rX00_rs_col(&rs, col_count, col_count, SWIZ_XYZW);

            /* Write it to the FS input register if it's needed by the FS. */
            if (fs_inputs->color[i] != ATTR_UNUSED) {
                rX00_rs_col_write(&rs, col_count, fp_offset, WRITE_COLOR);
                fp_offset++;

                DBG(r300, DBG_RS,
                    "r300: Rasterized color %i written to FS.\n", i);
            } else {
                DBG(r300, DBG_RS, "r300: Rasterized color %i unused.\n", i);
            }
            col_count++;
        } else {
            /* Skip the FS input register, leave it uninitialized. */
            /* If we try to set it to (0,0,0,1), it will lock up. */
            if (fs_inputs->color[i] != ATTR_UNUSED) {
                fp_offset++;

                DBG(r300, DBG_RS, "r300: FS input color %i unassigned%s.\n",
                    i);
            }
        }
    }

    /* Set up back-face colors. The rasterizer will do the color selection
     * automatically. */
    if (any_bcolor_used) {
        if (r300->two_sided_color) {
            /* Rasterize as back-face colors. */
            for (i = 0; i < ATTR_COLOR_COUNT; i++) {
                rs.vap_vsm_vtx_assm |= R300_INPUT_CNTL_COLOR;
                rs.vap_out_vtx_fmt[0] |= R300_VAP_OUTPUT_VTX_FMT_0__COLOR_0_PRESENT << (2+i);
                stream_loc_notcl[loc++] = 4 + i;
            }
        } else {
            /* Rasterize two fake texcoords to prevent from the two-sided color
             * selection. */
            /* XXX Consider recompiling the vertex shader to save 2 RS units. */
            for (i = 0; i < 2; i++) {
                rs.vap_vsm_vtx_assm |= (R300_INPUT_CNTL_TC0 << tex_count);
                rs.vap_out_vtx_fmt[1] |= (4 << (3 * tex_count));
                stream_loc_notcl[loc++] = 6 + tex_count;

                /* Rasterize it. */
                rX00_rs_tex(&rs, tex_count, tex_ptr, SWIZ_XYZW);
                tex_count++;
                tex_ptr += 4;
            }
        }
    }

    /* gl_FrontFacing.
     * Note that we can use either the two-sided color selection based on
     * the front and back vertex shader colors, or gl_FrontFacing,
     * but not both! It locks up otherwise.
     *
     * In Direct3D 9, the two-sided color selection can be used
     * with shaders 2.0 only, while gl_FrontFacing can be used
     * with shaders 3.0 only. The hardware apparently hasn't been designed
     * to support both at the same time. */
    if (r300->screen->caps.is_r500 && fs_inputs->face != ATTR_UNUSED &&
        !(any_bcolor_used && r300->two_sided_color)) {
        rX00_rs_col(&rs, col_count, col_count, SWIZ_XYZW);
        rX00_rs_col_write(&rs, col_count, fp_offset, WRITE_FACE);
        fp_offset++;
        col_count++;
        DBG(r300, DBG_RS, "r300: Rasterized FACE written to FS.\n");
    } else if (fs_inputs->face != ATTR_UNUSED) {
        fprintf(stderr, "r300: ERROR: FS input FACE unassigned.\n");
    }

    /* Re-use color varyings for texcoords if possible.
     *
     * The colors are interpolated as 20-bit floats (reduced precision),
     * Use this hack only if there are too many generic varyings.
     * (number of generic varyings + fog + wpos > 8) */
    if (r300->screen->caps.is_r500 && !any_bcolor_used && !r300->flatshade &&
	fs_inputs->face == ATTR_UNUSED &&
        vs_outputs->num_generic + (vs_outputs->fog != ATTR_UNUSED) +
        (fs_inputs->wpos != ATTR_UNUSED) > 8) {
	for (i = 0; i < ATTR_GENERIC_COUNT && col_count < 2; i++) {
	    /* Cannot use color varyings for sprite coords. */
	    if (fs_inputs->generic[i] != ATTR_UNUSED &&
		(r300->sprite_coord_enable & (1 << i))) {
		break;
	    }

	    if (vs_outputs->generic[i] != ATTR_UNUSED) {
		/* Set up the color in VAP. */
		rs.vap_vsm_vtx_assm |= R300_INPUT_CNTL_COLOR;
		rs.vap_out_vtx_fmt[0] |=
			R300_VAP_OUTPUT_VTX_FMT_0__COLOR_0_PRESENT << col_count;
		stream_loc_notcl[loc++] = 2 + col_count;

		/* Rasterize it. */
		rX00_rs_col(&rs, col_count, col_count, SWIZ_XYZW);

		/* Write it to the FS input register if it's needed by the FS. */
		if (fs_inputs->generic[i] != ATTR_UNUSED) {
		    rX00_rs_col_write(&rs, col_count, fp_offset, WRITE_COLOR);
		    fp_offset++;

		    DBG(r300, DBG_RS,
			"r300: Rasterized generic %i redirected to color %i and written to FS.\n",
		        i, col_count);
		} else {
		    DBG(r300, DBG_RS, "r300: Rasterized generic %i redirected to color %i unused.\n",
		        i, col_count);
		}
		col_count++;
	    } else {
		/* Skip the FS input register, leave it uninitialized. */
		/* If we try to set it to (0,0,0,1), it will lock up. */
		if (fs_inputs->generic[i] != ATTR_UNUSED) {
		    fp_offset++;

		    DBG(r300, DBG_RS, "r300: FS input generic %i unassigned%s.\n", i);
		}
	    }
	}
	gen_offset = i;
    }

    /* Rasterize texture coordinates. */
    for (i = gen_offset; i < ATTR_GENERIC_COUNT && tex_count < 8; i++) {
	boolean sprite_coord = false;

	if (fs_inputs->generic[i] != ATTR_UNUSED) {
	    sprite_coord = !!(r300->sprite_coord_enable & (1 << i));
	}

        if (vs_outputs->generic[i] != ATTR_UNUSED || sprite_coord) {
            if (!sprite_coord) {
                /* Set up the texture coordinates in VAP. */
                rs.vap_vsm_vtx_assm |= (R300_INPUT_CNTL_TC0 << tex_count);
                rs.vap_out_vtx_fmt[1] |= (4 << (3 * tex_count));
                stream_loc_notcl[loc++] = 6 + tex_count;
            } else
                stuffing_enable |=
                    R300_GB_TEX_ST << (R300_GB_TEX0_SOURCE_SHIFT + (tex_count*2));

            /* Rasterize it. */
            rX00_rs_tex(&rs, tex_count, tex_ptr,
			sprite_coord ? SWIZ_XY01 : SWIZ_XYZW);

            /* Write it to the FS input register if it's needed by the FS. */
            if (fs_inputs->generic[i] != ATTR_UNUSED) {
                rX00_rs_tex_write(&rs, tex_count, fp_offset);
                fp_offset++;

                DBG(r300, DBG_RS,
                    "r300: Rasterized generic %i written to FS%s in texcoord %d.\n",
                    i, sprite_coord ? " (sprite coord)" : "", tex_count);
            } else {
                DBG(r300, DBG_RS,
                    "r300: Rasterized generic %i unused%s.\n",
                    i, sprite_coord ? " (sprite coord)" : "");
            }
            tex_count++;
            tex_ptr += sprite_coord ? 2 : 4;
        } else {
            /* Skip the FS input register, leave it uninitialized. */
            /* If we try to set it to (0,0,0,1), it will lock up. */
            if (fs_inputs->generic[i] != ATTR_UNUSED) {
                fp_offset++;

                DBG(r300, DBG_RS, "r300: FS input generic %i unassigned%s.\n",
                    i, sprite_coord ? " (sprite coord)" : "");
            }
        }
    }

    for (; i < ATTR_GENERIC_COUNT; i++) {
        if (fs_inputs->generic[i] != ATTR_UNUSED) {
            fprintf(stderr, "r300: ERROR: FS input generic %i unassigned, "
                    "not enough hardware slots (it's not a bug, do not "
                    "report it).\n", i);
        }
    }

    /* Rasterize fog coordinates. */
    if (vs_outputs->fog != ATTR_UNUSED && tex_count < 8) {
        /* Set up the fog coordinates in VAP. */
        rs.vap_vsm_vtx_assm |= (R300_INPUT_CNTL_TC0 << tex_count);
        rs.vap_out_vtx_fmt[1] |= (4 << (3 * tex_count));
        stream_loc_notcl[loc++] = 6 + tex_count;

        /* Rasterize it. */
        rX00_rs_tex(&rs, tex_count, tex_ptr, SWIZ_X001);

        /* Write it to the FS input register if it's needed by the FS. */
        if (fs_inputs->fog != ATTR_UNUSED) {
            rX00_rs_tex_write(&rs, tex_count, fp_offset);
            fp_offset++;

            DBG(r300, DBG_RS, "r300: Rasterized fog written to FS.\n");
        } else {
            DBG(r300, DBG_RS, "r300: Rasterized fog unused.\n");
        }
        tex_count++;
        tex_ptr += 4;
    } else {
        /* Skip the FS input register, leave it uninitialized. */
        /* If we try to set it to (0,0,0,1), it will lock up. */
        if (fs_inputs->fog != ATTR_UNUSED) {
            fp_offset++;

            if (tex_count < 8) {
                DBG(r300, DBG_RS, "r300: FS input fog unassigned.\n");
            } else {
                fprintf(stderr, "r300: ERROR: FS input fog unassigned, "
                        "not enough hardware slots. (it's not a bug, "
                        "do not report it)\n");
            }
        }
    }

    /* Rasterize WPOS. */
    /* Don't set it in VAP if the FS doesn't need it. */
    if (fs_inputs->wpos != ATTR_UNUSED && tex_count < 8) {
        /* Set up the WPOS coordinates in VAP. */
        rs.vap_vsm_vtx_assm |= (R300_INPUT_CNTL_TC0 << tex_count);
        rs.vap_out_vtx_fmt[1] |= (4 << (3 * tex_count));
        stream_loc_notcl[loc++] = 6 + tex_count;

        /* Rasterize it. */
        rX00_rs_tex(&rs, tex_count, tex_ptr, SWIZ_XYZW);

        /* Write it to the FS input register. */
        rX00_rs_tex_write(&rs, tex_count, fp_offset);

        DBG(r300, DBG_RS, "r300: Rasterized WPOS written to FS.\n");

        fp_offset++;
        tex_count++;
        tex_ptr += 4;
    } else {
        if (fs_inputs->wpos != ATTR_UNUSED && tex_count >= 8) {
            fprintf(stderr, "r300: ERROR: FS input WPOS unassigned, "
                    "not enough hardware slots. (it's not a bug, do not "
                    "report it)\n");
        }
    }

    /* Invalidate the rest of the no-TCL (GA) stream locations. */
    for (; loc < 16;) {
        stream_loc_notcl[loc++] = -1;
    }

    /* Rasterize at least one color, or bad things happen. */
    if (col_count == 0 && tex_count == 0) {
        rX00_rs_col(&rs, 0, 0, SWIZ_0001);
        col_count++;

        DBG(r300, DBG_RS, "r300: Rasterized color 0 to prevent lockups.\n");
    }

    DBG(r300, DBG_RS, "r300: --- Rasterizer status ---: colors: %i, "
        "generics: %i.\n", col_count, tex_count);

    rs.count = MIN2(tex_ptr, 32) | (col_count << R300_IC_COUNT_SHIFT) |
        R300_HIRES_EN;

    count = MAX3(col_count, tex_count, 1);
    rs.inst_count = count - 1;

    /* set the GB enable flags */
    if (r300->sprite_coord_enable)
	stuffing_enable |= R300_GB_POINT_STUFF_ENABLE;

    rs.gb_enable = stuffing_enable;

    /* Now, after all that, see if we actually need to update the state. */
    if (memcmp(r300->rs_block_state.state, &rs, sizeof(struct r300_rs_block))) {
        memcpy(r300->rs_block_state.state, &rs, sizeof(struct r300_rs_block));
        r300->rs_block_state.size = 13 + count*2;
    }
}

static void rgba_to_bgra(float color[4])
{
    float x = color[0];
    color[0] = color[2];
    color[2] = x;
}

static uint32_t r300_get_border_color(enum pipe_format format,
                                      const float border[4],
                                      boolean is_r500)
{
    const struct util_format_description *desc;
    float border_swizzled[4] = {0};
    union util_color uc = {0};

    desc = util_format_description(format);

    /* Do depth formats first. */
    if (util_format_is_depth_or_stencil(format)) {
        switch (format) {
        case PIPE_FORMAT_Z16_UNORM:
            return util_pack_z(PIPE_FORMAT_Z16_UNORM, border[0]);
        case PIPE_FORMAT_X8Z24_UNORM:
        case PIPE_FORMAT_S8_UINT_Z24_UNORM:
            if (is_r500) {
                return util_pack_z(PIPE_FORMAT_X8Z24_UNORM, border[0]);
            } else {
                return util_pack_z(PIPE_FORMAT_Z16_UNORM, border[0]) << 16;
            }
        default:
            assert(0);
            return 0;
        }
    }

    /* Apply inverse swizzle of the format. */
    util_format_unswizzle_4f(border_swizzled, border, desc->swizzle);

    /* Compressed formats. */
    if (util_format_is_compressed(format)) {
        switch (format) {
        case PIPE_FORMAT_RGTC1_SNORM:
        case PIPE_FORMAT_LATC1_SNORM:
            border_swizzled[0] = border_swizzled[0] < 0 ?
                                 border_swizzled[0]*0.5+1 :
                                 border_swizzled[0]*0.5;
            /* Pass through. */

        case PIPE_FORMAT_RGTC1_UNORM:
        case PIPE_FORMAT_LATC1_UNORM:
            /* Add 1/32 to round the border color instead of truncating. */
            /* The Y component is used for the border color. */
            border_swizzled[1] = border_swizzled[0] + 1.0f/32;
            util_pack_color(border_swizzled, PIPE_FORMAT_B4G4R4A4_UNORM, &uc);
            return uc.ui[0];
        case PIPE_FORMAT_RGTC2_SNORM:
        case PIPE_FORMAT_LATC2_SNORM:
            util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SNORM, &uc);
            return uc.ui[0];
        case PIPE_FORMAT_RGTC2_UNORM:
        case PIPE_FORMAT_LATC2_UNORM:
            util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
            return uc.ui[0];
        case PIPE_FORMAT_DXT1_SRGB:
        case PIPE_FORMAT_DXT1_SRGBA:
        case PIPE_FORMAT_DXT3_SRGBA:
        case PIPE_FORMAT_DXT5_SRGBA:
            util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_SRGB, &uc);
            return uc.ui[0];
        default:
            util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
            return uc.ui[0];
        }
    }

    switch (desc->channel[0].size) {
        case 2:
            rgba_to_bgra(border_swizzled);
            util_pack_color(border_swizzled, PIPE_FORMAT_B2G3R3_UNORM, &uc);
            break;

        case 4:
            rgba_to_bgra(border_swizzled);
            util_pack_color(border_swizzled, PIPE_FORMAT_B4G4R4A4_UNORM, &uc);
            break;

        case 5:
            rgba_to_bgra(border_swizzled);
            if (desc->channel[1].size == 5) {
                util_pack_color(border_swizzled, PIPE_FORMAT_B5G5R5A1_UNORM, &uc);
            } else if (desc->channel[1].size == 6) {
                util_pack_color(border_swizzled, PIPE_FORMAT_B5G6R5_UNORM, &uc);
            } else {
                assert(0);
            }
            break;

        default:
        case 8:
            if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
                util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SNORM, &uc);
            } else if (desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
                if (desc->nr_channels == 2) {
                    border_swizzled[3] = border_swizzled[1];
                    util_pack_color(border_swizzled, PIPE_FORMAT_L8A8_SRGB, &uc);
                } else {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SRGB, &uc);
                }
            } else {
                util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
            }
            break;

        case 10:
            util_pack_color(border_swizzled, PIPE_FORMAT_R10G10B10A2_UNORM, &uc);
            break;

        case 16:
            if (desc->nr_channels <= 2) {
                if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_FLOAT, &uc);
                } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_SNORM, &uc);
                } else {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_UNORM, &uc);
                }
            } else {
                if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SNORM, &uc);
                } else {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
                }
            }
            break;

        case 32:
            if (desc->nr_channels == 1) {
                util_pack_color(border_swizzled, PIPE_FORMAT_R32_FLOAT, &uc);
            } else {
                util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
            }
            break;
    }

    return uc.ui[0];
}

static void r300_merge_textures_and_samplers(struct r300_context* r300)
{
    struct r300_textures_state *state =
        (struct r300_textures_state*)r300->textures_state.state;
    struct r300_texture_sampler_state *texstate;
    struct r300_sampler_state *sampler;
    struct r300_sampler_view *view;
    struct r300_resource *tex;
    unsigned base_level, min_level, level_count, i, j, size;
    unsigned count = MIN2(state->sampler_view_count,
                          state->sampler_state_count);
    boolean has_us_format = r300->screen->caps.has_us_format;

    /* The KIL opcode fix, see below. */
    if (!count && !r300->screen->caps.is_r500)
        count = 1;

    state->tx_enable = 0;
    state->count = 0;
    size = 2;

    for (i = 0; i < count; i++) {
        if (state->sampler_views[i] && state->sampler_states[i]) {
            enum pipe_format format;

            state->tx_enable |= 1 << i;

            view = state->sampler_views[i];
            format = r300_get_hw_format(view->base.format, view->base.texture->bind);
            tex = r300_resource(view->base.texture);
            sampler = state->sampler_states[i];

            texstate = &state->regs[i];
            texstate->format = view->format;
            texstate->filter0 = sampler->filter0;
            texstate->filter1 = sampler->filter1;

            /* Set the border color. */
            texstate->border_color =
                r300_get_border_color(format,
                                      sampler->state.border_color.f,
                                      r300->screen->caps.is_r500);

            /* determine min/max levels */
            base_level = view->base.u.tex.first_level;
            min_level = sampler->min_lod;
            level_count = MIN3(sampler->max_lod,
                               tex->b.b.last_level - base_level,
                               view->base.u.tex.last_level - base_level);

            if (base_level + min_level) {
                unsigned offset;

                if (tex->tex.is_npot) {
                    /* Even though we do not implement mipmapping for NPOT
                     * textures, we should at least honor the minimum level
                     * which is allowed to be displayed. We do this by setting up
                     * an i-th mipmap level as the zero level. */
                    base_level += min_level;
                }
                offset = tex->tex.offset_in_bytes[base_level];

                r300_texture_setup_format_state(r300->screen, tex,
                                                format,
                                                base_level,
                                                view->width0_override,
		                                view->height0_override,
                                                &texstate->format);
                texstate->format.tile_config |= offset & 0xffffffe0;
                assert((offset & 0x1f) == 0);
            }

            /* Assign a texture cache region. */
            texstate->format.format1 |= view->texcache_region;

            /* Depth textures are kinda special. */
            if (util_format_is_depth_or_stencil(format)) {
                unsigned char depth_swizzle[4];

                if (!r300->screen->caps.is_r500 &&
                    util_format_get_blocksizebits(format) == 32) {
                    /* X24x8 is sampled as Y16X16 on r3xx-r4xx.
                     * The depth here is at the Y component. */
                    for (j = 0; j < 4; j++)
                        depth_swizzle[j] = UTIL_FORMAT_SWIZZLE_Y;
                } else {
                    for (j = 0; j < 4; j++)
                        depth_swizzle[j] = UTIL_FORMAT_SWIZZLE_X;
                }

                /* If compare mode is disabled, sampler view swizzles
                 * are stored in the format.
                 * Otherwise, the swizzles must be applied after the compare
                 * mode in the fragment shader. */
                if (sampler->state.compare_mode == PIPE_TEX_COMPARE_NONE) {
                    texstate->format.format1 |=
                        r300_get_swizzle_combined(depth_swizzle,
                                                  view->swizzle, FALSE);
                } else {
                    texstate->format.format1 |=
                        r300_get_swizzle_combined(depth_swizzle, 0, FALSE);
                }
            }

            if (r300->screen->caps.dxtc_swizzle &&
                util_format_is_compressed(format)) {
                texstate->filter1 |= R400_DXTC_SWIZZLE_ENABLE;
            }

            /* to emulate 1D textures through 2D ones correctly */
            if (tex->b.b.target == PIPE_TEXTURE_1D) {
                texstate->filter0 &= ~R300_TX_WRAP_T_MASK;
                texstate->filter0 |= R300_TX_WRAP_T(R300_TX_CLAMP_TO_EDGE);
            }

            /* The hardware doesn't like CLAMP and CLAMP_TO_BORDER
             * for the 3rd coordinate if the texture isn't 3D. */
            if (tex->b.b.target != PIPE_TEXTURE_3D) {
                texstate->filter0 &= ~R300_TX_WRAP_R_MASK;
            }

            if (tex->tex.is_npot) {
                /* NPOT textures don't support mip filter, unfortunately.
                 * This prevents incorrect rendering. */
                texstate->filter0 &= ~R300_TX_MIN_FILTER_MIP_MASK;

                /* Mask out the mirrored flag. */
                if (texstate->filter0 & R300_TX_WRAP_S(R300_TX_MIRRORED)) {
                    texstate->filter0 &= ~R300_TX_WRAP_S(R300_TX_MIRRORED);
                }
                if (texstate->filter0 & R300_TX_WRAP_T(R300_TX_MIRRORED)) {
                    texstate->filter0 &= ~R300_TX_WRAP_T(R300_TX_MIRRORED);
                }

                /* Change repeat to clamp-to-edge.
                 * (the repeat bit has a value of 0, no masking needed). */
                if ((texstate->filter0 & R300_TX_WRAP_S_MASK) ==
                    R300_TX_WRAP_S(R300_TX_REPEAT)) {
                    texstate->filter0 |= R300_TX_WRAP_S(R300_TX_CLAMP_TO_EDGE);
                }
                if ((texstate->filter0 & R300_TX_WRAP_T_MASK) ==
                    R300_TX_WRAP_T(R300_TX_REPEAT)) {
                    texstate->filter0 |= R300_TX_WRAP_T(R300_TX_CLAMP_TO_EDGE);
                }
            } else {
                /* the MAX_MIP level is the largest (finest) one */
                texstate->format.format0 |= R300_TX_NUM_LEVELS(level_count);
                texstate->filter0 |= R300_TX_MAX_MIP_LEVEL(min_level);
            }

            /* Float textures only support nearest and mip-nearest filtering. */
            if (util_format_is_float(format)) {
                /* No MAG linear filtering. */
                if ((texstate->filter0 & R300_TX_MAG_FILTER_MASK) ==
                    R300_TX_MAG_FILTER_LINEAR) {
                    texstate->filter0 &= ~R300_TX_MAG_FILTER_MASK;
                    texstate->filter0 |= R300_TX_MAG_FILTER_NEAREST;
                }
                /* No MIN linear filtering. */
                if ((texstate->filter0 & R300_TX_MIN_FILTER_MASK) ==
                    R300_TX_MIN_FILTER_LINEAR) {
                    texstate->filter0 &= ~R300_TX_MIN_FILTER_MASK;
                    texstate->filter0 |= R300_TX_MIN_FILTER_NEAREST;
                }
                /* No mipmap linear filtering. */
                if ((texstate->filter0 & R300_TX_MIN_FILTER_MIP_MASK) ==
                    R300_TX_MIN_FILTER_MIP_LINEAR) {
                    texstate->filter0 &= ~R300_TX_MIN_FILTER_MIP_MASK;
                    texstate->filter0 |= R300_TX_MIN_FILTER_MIP_NEAREST;
                }
                /* No anisotropic filtering. */
                texstate->filter0 &= ~R300_TX_MAX_ANISO_MASK;
                texstate->filter1 &= ~R500_TX_MAX_ANISO_MASK;
                texstate->filter1 &= ~R500_TX_ANISO_HIGH_QUALITY;
            }

            texstate->filter0 |= i << 28;

            size += 16 + (has_us_format ? 2 : 0);
            state->count = i+1;
        } else {
            /* For the KIL opcode to work on r3xx-r4xx, the texture unit
             * assigned to this opcode (it's always the first one) must be
             * enabled. Otherwise the opcode doesn't work.
             *
             * In order to not depend on the fragment shader, we just make
             * the first unit enabled all the time. */
            if (i == 0 && !r300->screen->caps.is_r500) {
                pipe_sampler_view_reference(
                        (struct pipe_sampler_view**)&state->sampler_views[i],
                        &r300->texkill_sampler->base);

                state->tx_enable |= 1 << i;

                texstate = &state->regs[i];

                /* Just set some valid state. */
                texstate->format = r300->texkill_sampler->format;
                texstate->filter0 =
                        r300_translate_tex_filters(PIPE_TEX_FILTER_NEAREST,
                                                   PIPE_TEX_FILTER_NEAREST,
                                                   PIPE_TEX_FILTER_NEAREST,
                                                   FALSE);
                texstate->filter1 = 0;
                texstate->border_color = 0;

                texstate->filter0 |= i << 28;
                size += 16 + (has_us_format ? 2 : 0);
                state->count = i+1;
            }
        }
    }

    r300->textures_state.size = size;

    /* Pick a fragment shader based on either the texture compare state
     * or the uses_pitch flag or some other external state. */
    if (count &&
        r300->fs_status == FRAGMENT_SHADER_VALID) {
        r300->fs_status = FRAGMENT_SHADER_MAYBE_DIRTY;
    }
}

static void r300_decompress_depth_textures(struct r300_context *r300)
{
    struct r300_textures_state *state =
        (struct r300_textures_state*)r300->textures_state.state;
    struct pipe_resource *tex;
    unsigned count = MIN2(state->sampler_view_count,
                          state->sampler_state_count);
    unsigned i;

    if (!r300->locked_zbuffer) {
        return;
    }

    for (i = 0; i < count; i++) {
        if (state->sampler_views[i] && state->sampler_states[i]) {
            tex = state->sampler_views[i]->base.texture;

            if (tex == r300->locked_zbuffer->texture) {
                r300_decompress_zmask_locked(r300);
                return;
            }
        }
    }
}

static void r300_validate_fragment_shader(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb = r300->fb_state.state;

    if (r300->fs.state && r300->fs_status != FRAGMENT_SHADER_VALID) {
        /* Pick the fragment shader based on external states.
         * Then mark the state dirty if the fragment shader is either dirty
         * or the function r300_pick_fragment_shader changed the shader. */
        if (r300_pick_fragment_shader(r300) ||
            r300->fs_status == FRAGMENT_SHADER_DIRTY) {
            /* Mark the state atom as dirty. */
            r300_mark_fs_code_dirty(r300);

            /* Does Multiwrite need to be changed? */
            if (fb->nr_cbufs > 1) {
                boolean new_multiwrite =
                    r300_fragment_shader_writes_all(r300_fs(r300));

                if (r300->fb_multiwrite != new_multiwrite) {
                    r300->fb_multiwrite = new_multiwrite;
                    r300_mark_fb_state_dirty(r300, R300_CHANGED_MULTIWRITE);
                }
            }
        }
        r300->fs_status = FRAGMENT_SHADER_VALID;
    }
}

void r300_update_derived_state(struct r300_context* r300)
{
    if (r300->textures_state.dirty) {
        r300_decompress_depth_textures(r300);
        r300_merge_textures_and_samplers(r300);
    }

    r300_validate_fragment_shader(r300);

    if (r300->rs_block_state.dirty) {
        r300_update_rs_block(r300);

        if (r300->draw) {
            memset(&r300->vertex_info, 0, sizeof(struct vertex_info));
            r300_draw_emit_all_attribs(r300);
            draw_compute_vertex_size(&r300->vertex_info);
            r300_swtcl_vertex_psc(r300);
        }
    }

    r300_update_hyperz_state(r300);
}
@


1.6
log
@Make the Gallium r300 works on big-endian architectures.

Diff provided by Michel Daenzer [0] as a possible solution for a
regression introduced in Mesa 9 [1].  This diff allows macppc
users to use OpenGL accelerated appplications (i.e. GNOME3).

As disucssed during c2k15 we won't try to keep this patch during
the next Mesa update.

[0] https://bugs.freedesktop.org/show_bug.cgi?id=71789
[1] http://lists.freedesktop.org/archives/mesa-dev/2013-December/050218.html

Tested by myself and ajacoutot@@, regression test and ok jsg@@
@
text
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d818 2
d823 1
d834 1
a834 1
                r300_get_border_color(view->base.format,
d858 1
a858 1
                                                view->base.format,
d871 1
a871 1
            if (util_format_is_depth_or_stencil(view->base.format)) {
d875 1
a875 1
                    util_format_get_blocksizebits(view->base.format) == 32) {
d900 1
a900 1
                util_format_is_compressed(view->base.format)) {
d946 1
a946 1
            if (util_format_is_float(view->base.format)) {
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d702 1
a702 1
            return uc.ui;
d706 1
a706 1
            return uc.ui;
d710 1
a710 1
            return uc.ui;
d716 1
a716 1
            return uc.ui;
d719 1
a719 1
            return uc.ui;
d792 1
a792 1
    return uc.ui;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d319 1
d440 52
d493 1
a493 1
    for (i = 0; i < ATTR_GENERIC_COUNT && tex_count < 8; i++) {
a660 1
    unsigned i;
d671 1
a671 1
        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d684 1
a684 16
    for (i = 0; i < 4; i++) {
        switch (desc->swizzle[i]) {
        case UTIL_FORMAT_SWIZZLE_X:
            border_swizzled[0] = border[i];
            break;
        case UTIL_FORMAT_SWIZZLE_Y:
            border_swizzled[1] = border[i];
            break;
        case UTIL_FORMAT_SWIZZLE_Z:
            border_swizzled[2] = border[i];
            break;
        case UTIL_FORMAT_SWIZZLE_W:
            border_swizzled[3] = border[i];
            break;
        }
    }
d711 6
d747 12
a758 4
            if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED)
               util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SNORM, &uc);
            else
               util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
d832 1
a832 1
                                      sampler->state.border_color,
d839 1
a839 1
                               tex->b.b.b.last_level - base_level,
d852 1
a852 2
                offset = tex->tex_offset +
                         tex->tex.offset_in_bytes[base_level];
d855 1
d857 2
a861 3
            } else {
                texstate->format.tile_config |= tex->tex_offset & 0xffffffe0;
                assert((tex->tex_offset & 0x1f) == 0);
d868 1
a868 1
            if (util_format_is_depth_or_stencil(tex->b.b.b.format)) {
d872 1
a872 1
                    util_format_get_blocksizebits(tex->b.b.b.format) == 32) {
d897 1
a897 1
                util_format_is_compressed(tex->b.b.b.format)) {
d902 1
a902 1
            if (tex->b.b.b.target == PIPE_TEXTURE_1D) {
d909 1
a909 1
            if (tex->b.b.b.target != PIPE_TEXTURE_3D) {
d943 1
a943 1
            if (util_format_is_float(tex->b.b.b.format)) {
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a31 1
#include "r300_hyperz.h"
a33 1
#include "r300_state_derived.h"
d441 1
a441 1
	bool sprite_coord = false;
d491 2
a492 1
                    "not enough hardware slots.\n", i);
d527 2
a528 1
                        "not enough hardware slots.\n");
d555 2
a556 1
                    "not enough hardware slots.\n");
d595 7
d635 1
a635 1
            border_swizzled[2] = border[i];
d641 1
a641 1
            border_swizzled[0] = border[i];
d651 27
a677 2
        util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
        return uc.ui;
d681 5
d687 1
d692 1
d704 4
a707 1
            util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
d711 1
a711 1
            util_pack_color(border_swizzled, PIPE_FORMAT_B10G10R10A2_UNORM, &uc);
d716 19
a734 2
                border_swizzled[0] = border_swizzled[2];
                util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_UNORM, &uc);
d736 1
a736 1
                util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
d751 2
a752 2
    struct r300_texture *tex;
    unsigned min_level, max_level, i, j, size;
d755 1
d770 1
a770 1
            tex = r300_texture(view->base.texture);
d785 21
a805 12
            max_level = MIN3(sampler->max_lod + view->base.u.tex.first_level,
                             tex->desc.b.b.last_level, view->base.u.tex.last_level);
            min_level = MIN2(sampler->min_lod + view->base.u.tex.first_level,
                             max_level);

            if (tex->desc.is_npot && min_level > 0) {
                /* Even though we do not implement mipmapping for NPOT
                 * textures, we should at least honor the minimum level
                 * which is allowed to be displayed. We do this by setting up
                 * an i-th mipmap level as the zero level. */
                r300_texture_setup_format_state(r300->screen, &tex->desc,
                                                min_level,
d807 5
a811 3
                texstate->format.tile_config |=
                        tex->desc.offset_in_bytes[min_level] & 0xffffffe0;
                assert((tex->desc.offset_in_bytes[min_level] & 0x1f) == 0);
d818 1
a818 1
            if (util_format_is_depth_or_stencil(tex->desc.b.b.format)) {
d822 1
a822 1
                    util_format_get_blocksizebits(tex->desc.b.b.format) == 32) {
d847 1
a847 1
                util_format_is_compressed(tex->desc.b.b.format)) {
d852 1
a852 1
            if (tex->desc.b.b.target == PIPE_TEXTURE_1D) {
d859 1
a859 1
            if (tex->desc.b.b.target != PIPE_TEXTURE_3D) {
d863 1
a863 1
            if (tex->desc.is_npot) {
d888 1
a888 1
                texstate->format.format0 |= R300_TX_NUM_LEVELS(max_level);
d892 26
d920 1
a920 1
            size += 16;
d949 1
a949 1
                size += 16;
d958 4
a961 5
     * or the uses_pitch flag. */
    if (r300->fs.state && count) {
        if (r300_pick_fragment_shader(r300)) {
            r300_mark_fs_code_dirty(r300);
        }
d965 1
a965 2
/* We can't use compressed zbuffers as samplers. */
static void r300_flush_depth_textures(struct r300_context *r300)
d969 1
a969 1
    unsigned i, level;
d972 1
d974 1
a974 1
    if (r300->z_decomp_rd)
d976 1
d978 1
a978 1
    for (i = 0; i < count; i++)
d980 1
a980 1
            struct pipe_resource *tex = state->sampler_views[i]->base.texture;
d982 4
a985 14
            if (tex->target == PIPE_TEXTURE_3D ||
                tex->target == PIPE_TEXTURE_CUBE)
                continue;

            /* Ignore non-depth textures.
             * Also ignore reinterpreted depth textures, e.g. resource_copy. */
            if (!util_format_is_depth_or_stencil(tex->format))
                continue;

            for (level = 0; level <= tex->last_level; level++)
                if (r300_texture(tex)->zmask_in_use[level]) {
                    /* We don't handle 3D textures and cubemaps yet. */
                    r300_flush_depth_stencil(&r300->context, tex, level, 0);
                 }
d987 29
a1019 2
    r300_flush_depth_textures(r300);

d1021 1
d1024 2
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d28 1
d32 1
d37 1
d43 12
d98 7
a104 1
    /* XXX Back-face colors. */
d107 2
d110 3
a112 2
    for (i = 0; i < ATTR_GENERIC_COUNT; i++) {
        if (vs_outputs->generic[i] != ATTR_UNUSED) {
d120 1
a120 1
    if (vs_outputs->fog != ATTR_UNUSED) {
d126 6
a131 51
    /* XXX magic */
    assert(gen_count <= 8);
}

/* Update the PSC tables. */
/* XXX move this function into r300_state.c after TCL-bypass gets removed
 * XXX because this one is dependent only on vertex elements. */
static void r300_vertex_psc(struct r300_context* r300)
{
    struct r300_vertex_shader* vs = r300->vs_state.state;
    struct r300_vertex_stream_state *vformat =
        (struct r300_vertex_stream_state*)r300->vertex_stream_state.state;
    uint16_t type, swizzle;
    enum pipe_format format;
    unsigned i;
    int identity[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
    int* stream_tab;

    memset(vformat, 0, sizeof(struct r300_vertex_stream_state));

    stream_tab = identity;

    /* Vertex shaders have no semantics on their inputs,
     * so PSC should just route stuff based on the vertex elements,
     * and not on attrib information. */
    DBG(r300, DBG_DRAW, "r300: vs expects %d attribs, routing %d elements"
            " in psc\n",
            vs->info.num_inputs,
            r300->vertex_element_count);

    for (i = 0; i < r300->vertex_element_count; i++) {
        format = r300->vertex_element[i].src_format;

        type = r300_translate_vertex_data_type(format) |
            (stream_tab[i] << R300_DST_VEC_LOC_SHIFT);
        swizzle = r300_translate_vertex_data_swizzle(format);

        if (i & 1) {
            vformat->vap_prog_stream_cntl[i >> 1] |= type << 16;
            vformat->vap_prog_stream_cntl_ext[i >> 1] |= swizzle << 16;
        } else {
            vformat->vap_prog_stream_cntl[i >> 1] |= type;
            vformat->vap_prog_stream_cntl_ext[i >> 1] |= swizzle;
        }
    }

    assert(i <= 15);

    /* Set the last vector in the PSC. */
    if (i) {
        i -= 1;
a132 5
    vformat->vap_prog_stream_cntl[i >> 1] |=
        (R300_LAST_VEC << (i & 1 ? 16 : 0));

    vformat->count = (i >> 1) + 1;
    r300->vertex_stream_state.size = (1 + vformat->count) * 2;
d136 1
a136 1
static void r300_swtcl_vertex_psc(struct r300_context* r300)
d138 2
a139 4
    struct r300_vertex_shader* vs = r300->vs_state.state;
    struct r300_vertex_stream_state *vformat =
        (struct r300_vertex_stream_state*)r300->vertex_stream_state.state;
    struct vertex_info* vinfo = &r300->vertex_info;
d143 1
a143 1
    int* vs_output_tab = vs->stream_loc_notcl;
d145 1
a145 1
    memset(vformat, 0, sizeof(struct r300_vertex_stream_state));
d150 1
a150 1
    DBG(r300, DBG_DRAW, "r300: attrib count: %d\n", attrib_count);
d152 4
a155 5
        DBG(r300, DBG_DRAW, "r300: attrib: offset %d, interp %d, size %d,"
               " vs_output_tab %d\n", vinfo->attrib[i].src_index,
               vinfo->attrib[i].interp_mode, vinfo->attrib[i].emit,
               vs_output_tab[i]);
    }
d157 1
a157 3
    for (i = 0; i < attrib_count; i++) {
        /* Make sure we have a proper destination for our attribute. */
        assert(vs_output_tab[i] != -1);
d159 3
a161 1
        format = draw_translate_vinfo_format(vinfo->attrib[i].emit);
d164 9
a172 2
        type = r300_translate_vertex_data_type(format) |
            vs_output_tab[i] << R300_DST_VEC_LOC_SHIFT;
d180 2
a181 2
            vformat->vap_prog_stream_cntl[i >> 1] |= type << 16;
            vformat->vap_prog_stream_cntl_ext[i >> 1] |= swizzle << 16;
d183 2
a184 2
            vformat->vap_prog_stream_cntl[i >> 1] |= type;
            vformat->vap_prog_stream_cntl_ext[i >> 1] |= swizzle;
d192 1
a192 1
    vformat->vap_prog_stream_cntl[i >> 1] |=
d195 3
a197 2
    vformat->count = (i >> 1) + 1;
    r300->vertex_stream_state.size = (1 + vformat->count) * 2;
d201 1
a201 1
                        boolean swizzle_0001)
d204 1
a204 1
    if (swizzle_0001) {
d212 2
a213 1
static void r300_rs_col_write(struct r300_rs_block* rs, int id, int fp_offset)
d215 1
d221 1
a221 1
                        boolean swizzle_X001)
d223 2
a224 2
    if (swizzle_X001) {
        rs->ip[id] |= R300_RS_TEX_PTR(ptr*4) |
d229 6
d236 1
a236 1
        rs->ip[id] |= R300_RS_TEX_PTR(ptr*4) |
d252 1
a252 1
                        boolean swizzle_0001)
d255 1
a255 1
    if (swizzle_0001) {
d263 2
a264 1
static void r500_rs_col_write(struct r300_rs_block* rs, int id, int fp_offset)
d266 7
a272 2
    rs->inst[id] |= R500_RS_INST_COL_CN_WRITE |
                    R500_RS_INST_COL_ADDR(fp_offset);
d276 1
a276 1
                        boolean swizzle_X001)
d278 2
a279 4
    int rs_tex_comp = ptr*4;

    if (swizzle_X001) {
        rs->ip[id] |= R500_RS_SEL_S(rs_tex_comp) |
d283 5
d289 4
a292 4
        rs->ip[id] |= R500_RS_SEL_S(rs_tex_comp) |
                      R500_RS_SEL_T(rs_tex_comp + 1) |
                      R500_RS_SEL_R(rs_tex_comp + 2) |
                      R500_RS_SEL_Q(rs_tex_comp + 3);
d305 19
a323 12
 * This is the part of the chipset that actually does the rasterization
 * of vertices into fragments. This is also the part of the chipset that
 * locks up if any part of it is even slightly wrong. */
static void r300_update_rs_block(struct r300_context* r300,
                                 struct r300_shader_semantics* vs_outputs,
                                 struct r300_shader_semantics* fs_inputs)
{
    struct r300_rs_block rs = { { 0 } };
    int i, col_count = 0, tex_count = 0, fp_offset = 0, count;
    void (*rX00_rs_col)(struct r300_rs_block*, int, int, boolean);
    void (*rX00_rs_col_write)(struct r300_rs_block*, int, int);
    void (*rX00_rs_tex)(struct r300_rs_block*, int, int, boolean);
d327 2
d330 1
a330 1
    if (r300_screen(r300->context.screen)->caps->is_r500) {
d342 17
a358 1
    /* Rasterize colors. */
d362 8
a369 3
            /* Always rasterize if it's written by the VS,
             * otherwise it locks up. */
            rX00_rs_col(&rs, col_count, i, FALSE);
d371 1
a371 1
            /* Write it to the FS input register if it's used by the FS. */
d373 1
a373 1
                rX00_rs_col_write(&rs, col_count, fp_offset);
d375 5
d387 3
d394 47
d442 2
a443 5
    for (i = 0; i < ATTR_GENERIC_COUNT; i++) {
        if (vs_outputs->generic[i] != ATTR_UNUSED) {
            /* Always rasterize if it's written by the VS,
             * otherwise it locks up. */
            rX00_rs_tex(&rs, tex_count, tex_count, FALSE);
d445 19
a463 1
            /* Write it to the FS input register if it's used by the FS. */
d467 8
d477 1
d483 3
d490 7
d498 8
a505 4
    if (vs_outputs->fog != ATTR_UNUSED) {
        /* Always rasterize if it's written by the VS,
         * otherwise it locks up. */
        rX00_rs_tex(&rs, tex_count, tex_count, TRUE);
d507 1
a507 1
        /* Write it to the FS input register if it's used by the FS. */
d511 4
d517 1
d523 7
d534 11
a544 3
    /* If the FS doesn't need it, it's not written by the VS. */
    if (fs_inputs->wpos != ATTR_UNUSED) {
        rX00_rs_tex(&rs, tex_count, tex_count, FALSE);
d547 2
d551 11
d566 1
a566 1
        rX00_rs_col(&rs, 0, 0, TRUE);
d568 2
d572 4
a575 1
    rs.count = (tex_count*4) | (col_count << R300_IC_COUNT_SHIFT) |
d581 6
d590 1
a590 1
        r300->rs_block_state.size = 5 + count*2;
d594 3
a596 2
/* Update the shader-dependant states. */
static void r300_update_derived_shader_state(struct r300_context* r300)
d598 4
a601 8
    struct r300_vertex_shader* vs = r300->vs_state.state;
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
    struct r300_vap_output_state *vap_out =
        (struct r300_vap_output_state*)r300->vap_output_state.state;

    /* XXX Mmm, delicious hax */
    memset(&r300->vertex_info, 0, sizeof(struct vertex_info));
    memcpy(vap_out, vs->hwfmt, sizeof(uint)*4);
d603 1
a603 1
    r300_update_rs_block(r300, &vs->outputs, &r300->fs->inputs);
d605 16
a620 6
    if (r300screen->caps->has_tcl) {
        r300_vertex_psc(r300);
    } else {
        r300_draw_emit_all_attribs(r300);
        draw_compute_vertex_size(&r300->vertex_info);
        r300_swtcl_vertex_psc(r300);
a621 1
}
d623 17
a639 4
static boolean r300_dsa_writes_depth_stencil(struct r300_dsa_state* dsa)
{
    /* We are interested only in the cases when a new depth or stencil value
     * can be written and changed. */
d641 20
a660 7
    /* We might optionally check for [Z func: never] and inspect the stencil
     * state in a similar fashion, but it's not terribly important. */
    return (dsa->z_buffer_control & R300_Z_WRITE_ENABLE) ||
           (dsa->stencil_ref_mask & R300_STENCILWRITEMASK_MASK) ||
           ((dsa->z_buffer_control & R500_STENCIL_REFMASK_FRONT_BACK) &&
            (dsa->stencil_ref_bf & R300_STENCILWRITEMASK_MASK));
}
d662 17
a678 53
static boolean r300_dsa_alpha_test_enabled(struct r300_dsa_state* dsa)
{
    /* We are interested only in the cases when alpha testing can kill
     * a fragment. */
    uint32_t af = dsa->alpha_function;

    return (af & R300_FG_ALPHA_FUNC_ENABLE) &&
           (af & R300_FG_ALPHA_FUNC_ALWAYS) != R300_FG_ALPHA_FUNC_ALWAYS;
}

static void r300_update_ztop(struct r300_context* r300)
{
    struct r300_ztop_state* ztop_state =
        (struct r300_ztop_state*)r300->ztop_state.state;

    /* This is important enough that I felt it warranted a comment.
     *
     * According to the docs, these are the conditions where ZTOP must be
     * disabled:
     * 1) Alpha testing enabled
     * 2) Texture kill instructions in fragment shader
     * 3) Chroma key culling enabled
     * 4) W-buffering enabled
     *
     * The docs claim that for the first three cases, if no ZS writes happen,
     * then ZTOP can be used.
     *
     * (3) will never apply since we do not support chroma-keyed operations.
     * (4) will need to be re-examined (and this comment updated) if/when
     * Hyper-Z becomes supported.
     *
     * Additionally, the following conditions require disabled ZTOP:
     * 5) Depth writes in fragment shader
     * 6) Outstanding occlusion queries
     *
     * This register causes stalls all the way from SC to CB when changed,
     * but it is buffered on-chip so it does not hurt to write it if it has
     * not changed.
     *
     * ~C.
     */

    /* ZS writes */
    if (r300_dsa_writes_depth_stencil(r300->dsa_state.state) &&
           (r300_dsa_alpha_test_enabled(r300->dsa_state.state) ||/* (1) */
            r300->fs->info.uses_kill)) {                         /* (2) */
        ztop_state->z_buffer_top = R300_ZTOP_DISABLE;
    } else if (r300_fragment_shader_writes_depth(r300->fs)) {    /* (5) */
        ztop_state->z_buffer_top = R300_ZTOP_DISABLE;
    } else if (r300->query_current) {                            /* (6) */
        ztop_state->z_buffer_top = R300_ZTOP_DISABLE;
    } else {
        ztop_state->z_buffer_top = R300_ZTOP_ENABLE;
d681 1
a681 1
    r300->ztop_state.dirty = TRUE;
d690 1
d692 7
a698 2
    unsigned min_level, max_level, i, size;
    unsigned count = MIN2(state->texture_count, state->sampler_count);
d701 1
d705 1
a705 1
        if (state->textures[i] && state->sampler_states[i]) {
d708 2
a709 1
            tex = state->textures[i];
d713 65
a777 6
            memcpy(texstate->format, &tex->state, sizeof(uint32_t)*3);
            texstate->filter[0] = sampler->filter0;
            texstate->filter[1] = sampler->filter1;
            texstate->border_color = sampler->border_color;
            texstate->tile_config = R300_TXO_MACRO_TILE(tex->macrotile) |
                                    R300_TXO_MICRO_TILE(tex->microtile);
d780 9
a788 3
            if (tex->tex.target == PIPE_TEXTURE_1D) {
                texstate->filter[0] &= ~R300_TX_WRAP_T_MASK;
                texstate->filter[0] |= R300_TX_WRAP_T(R300_TX_CLAMP_TO_EDGE);
d791 1
a791 1
            if (tex->is_npot) {
d794 20
a813 1
                texstate->filter[0] &= ~R300_TX_MIN_FILTER_MIP_MASK;
a814 1
                /* determine min/max levels */
d816 2
a817 4
                max_level = MIN2(sampler->max_lod, tex->tex.last_level);
                min_level = MIN2(sampler->min_lod, max_level);
                texstate->format[0] |= R300_TX_NUM_LEVELS(max_level);
                texstate->filter[0] |= R300_TX_MAX_MIP_LEVEL(min_level);
d820 1
a820 1
            texstate->filter[0] |= i << 28;
d824 30
d858 41
d903 1
a903 5
    if (r300->rs_block_state.dirty ||
        r300->vertex_stream_state.dirty || /* XXX put updating this state out of this file */
        r300->rs_state.dirty) {  /* XXX and remove this one (tcl_bypass dependency) */
        r300_update_derived_shader_state(r300);
    }
d909 12
a920 1
    r300_update_ztop(r300);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a27 1
#include "util/u_pack_color.h"
a30 1
#include "r300_hyperz.h"
a34 1
#include "r300_texture.h"
a39 12
enum r300_rs_swizzle {
    SWIZ_XYZW = 0,
    SWIZ_X001,
    SWIZ_XY01,
    SWIZ_0001,
};

enum r300_rs_col_write_type {
    WRITE_COLOR = 0,
    WRITE_FACE
};

d83 1
a83 7
    /* Back-face colors. */
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        if (vs_outputs->bcolor[i] != ATTR_UNUSED) {
            r300_draw_emit_attrib(r300, EMIT_4F, INTERP_LINEAR,
                                  vs_outputs->bcolor[i]);
        }
    }
a85 2
    /* Only 8 generic vertex attributes can be used. If there are more,
     * they won't be rasterized. */
d87 2
a88 3
    for (i = 0; i < ATTR_GENERIC_COUNT && gen_count < 8; i++) {
        if (vs_outputs->generic[i] != ATTR_UNUSED &&
            !(r300->sprite_coord_enable & (1 << i))) {
d96 1
a96 1
    if (gen_count < 8 && vs_outputs->fog != ATTR_UNUSED) {
d102 51
a152 6
    /* WPOS. */
    if (r300_fs(r300)->shader->inputs.wpos != ATTR_UNUSED && gen_count < 8) {
        DBG(r300, DBG_SWTCL, "draw_emit_attrib: WPOS, index: %i\n",
            vs_outputs->wpos);
        r300_draw_emit_attrib(r300, EMIT_4F, INTERP_PERSPECTIVE,
                              vs_outputs->wpos);
d154 5
d162 1
a162 1
static void r300_swtcl_vertex_psc(struct r300_context *r300)
d164 4
a167 2
    struct r300_vertex_stream_state *vstream = r300->vertex_stream_state.state;
    struct vertex_info *vinfo = &r300->vertex_info;
d171 1
a171 1
    int* vs_output_tab = r300->stream_loc_notcl;
d173 1
a173 1
    memset(vstream, 0, sizeof(struct r300_vertex_stream_state));
d178 1
a178 1
    DBG(r300, DBG_SWTCL, "r300: attrib count: %d\n", attrib_count);
d180 9
a188 4
        if (vs_output_tab[i] == -1) {
            assert(0);
            abort();
        }
a191 4
        DBG(r300, DBG_SWTCL,
            "r300: swtcl_vertex_psc [%i] <- %s\n",
            vs_output_tab[i], util_format_short_name(format));

d193 2
a194 9
        type = r300_translate_vertex_data_type(format);
        if (type == R300_INVALID_FORMAT) {
            fprintf(stderr, "r300: Bad vertex format %s.\n",
                    util_format_short_name(format));
            assert(0);
            abort();
        }

        type |= vs_output_tab[i] << R300_DST_VEC_LOC_SHIFT;
d202 2
a203 2
            vstream->vap_prog_stream_cntl[i >> 1] |= type << 16;
            vstream->vap_prog_stream_cntl_ext[i >> 1] |= swizzle << 16;
d205 2
a206 2
            vstream->vap_prog_stream_cntl[i >> 1] |= type;
            vstream->vap_prog_stream_cntl_ext[i >> 1] |= swizzle;
d214 1
a214 1
    vstream->vap_prog_stream_cntl[i >> 1] |=
d217 2
a218 3
    vstream->count = (i >> 1) + 1;
    r300_mark_atom_dirty(r300, &r300->vertex_stream_state);
    r300->vertex_stream_state.size = (1 + vstream->count) * 2;
d222 1
a222 1
                        enum r300_rs_swizzle swiz)
d225 1
a225 1
    if (swiz == SWIZ_0001) {
d233 1
a233 2
static void r300_rs_col_write(struct r300_rs_block* rs, int id, int fp_offset,
                              enum r300_rs_col_write_type type)
a234 1
    assert(type == WRITE_COLOR);
d240 1
a240 1
                        enum r300_rs_swizzle swiz)
d242 2
a243 2
    if (swiz == SWIZ_X001) {
        rs->ip[id] |= R300_RS_TEX_PTR(ptr) |
a247 6
    } else if (swiz == SWIZ_XY01) {
        rs->ip[id] |= R300_RS_TEX_PTR(ptr) |
                      R300_RS_SEL_S(R300_RS_SEL_C0) |
                      R300_RS_SEL_T(R300_RS_SEL_C1) |
                      R300_RS_SEL_R(R300_RS_SEL_K0) |
                      R300_RS_SEL_Q(R300_RS_SEL_K1);
d249 1
a249 1
        rs->ip[id] |= R300_RS_TEX_PTR(ptr) |
d265 1
a265 1
                        enum r300_rs_swizzle swiz)
d268 1
a268 1
    if (swiz == SWIZ_0001) {
d276 1
a276 2
static void r500_rs_col_write(struct r300_rs_block* rs, int id, int fp_offset,
                              enum r300_rs_col_write_type type)
d278 2
a279 7
    if (type == WRITE_FACE)
        rs->inst[id] |= R500_RS_INST_COL_CN_WRITE_BACKFACE |
                        R500_RS_INST_COL_ADDR(fp_offset);
    else
        rs->inst[id] |= R500_RS_INST_COL_CN_WRITE |
                        R500_RS_INST_COL_ADDR(fp_offset);

d283 1
a283 1
			enum r300_rs_swizzle swiz)
d285 4
a288 2
    if (swiz == SWIZ_X001) {
        rs->ip[id] |= R500_RS_SEL_S(ptr) |
a291 5
    } else if (swiz == SWIZ_XY01) {
        rs->ip[id] |= R500_RS_SEL_S(ptr) |
                      R500_RS_SEL_T(ptr + 1) |
                      R500_RS_SEL_R(R500_RS_IP_PTR_K0) |
                      R500_RS_SEL_Q(R500_RS_IP_PTR_K1);
d293 4
a296 4
        rs->ip[id] |= R500_RS_SEL_S(ptr) |
                      R500_RS_SEL_T(ptr + 1) |
                      R500_RS_SEL_R(ptr + 2) |
                      R500_RS_SEL_Q(ptr + 3);
d309 12
a320 19
 * This is the part of the chipset that is responsible for linking vertex
 * and fragment shaders and stuffed texture coordinates.
 *
 * The rasterizer reads data from VAP, which produces vertex shader outputs,
 * and GA, which produces stuffed texture coordinates. VAP outputs have
 * precedence over GA. All outputs must be rasterized otherwise it locks up.
 * If there are more outputs rasterized than is set in VAP/GA, it locks up
 * too. The funky part is that this info has been pretty much obtained by trial
 * and error. */
static void r300_update_rs_block(struct r300_context *r300)
{
    struct r300_vertex_shader *vs = r300->vs_state.state;
    struct r300_shader_semantics *vs_outputs = &vs->outputs;
    struct r300_shader_semantics *fs_inputs = &r300_fs(r300)->shader->inputs;
    struct r300_rs_block rs = {0};
    int i, col_count = 0, tex_count = 0, fp_offset = 0, count, loc = 0, tex_ptr = 0;
    void (*rX00_rs_col)(struct r300_rs_block*, int, int, enum r300_rs_swizzle);
    void (*rX00_rs_col_write)(struct r300_rs_block*, int, int, enum r300_rs_col_write_type);
    void (*rX00_rs_tex)(struct r300_rs_block*, int, int, enum r300_rs_swizzle);
a323 2
    int *stream_loc_notcl = r300->stream_loc_notcl;
    uint32_t stuffing_enable = 0;
d325 1
a325 1
    if (r300->screen->caps.is_r500) {
d337 1
a337 17
    /* 0x5555 copied from classic, which means:
     * Select user color 0 for COLOR0 up to COLOR7.
     * What the hell does that mean? */
    rs.vap_vtx_state_cntl = 0x5555;

    /* The position is always present in VAP. */
    rs.vap_vsm_vtx_assm |= R300_INPUT_CNTL_POS;
    rs.vap_out_vtx_fmt[0] |= R300_VAP_OUTPUT_VTX_FMT_0__POS_PRESENT;
    stream_loc_notcl[loc++] = 0;

    /* Set up the point size in VAP. */
    if (vs_outputs->psize != ATTR_UNUSED) {
        rs.vap_out_vtx_fmt[0] |= R300_VAP_OUTPUT_VTX_FMT_0__PT_SIZE_PRESENT;
        stream_loc_notcl[loc++] = 1;
    }

    /* Set up and rasterize colors. */
d341 3
a343 8
            /* Set up the color in VAP. */
            rs.vap_vsm_vtx_assm |= R300_INPUT_CNTL_COLOR;
            rs.vap_out_vtx_fmt[0] |=
                    R300_VAP_OUTPUT_VTX_FMT_0__COLOR_0_PRESENT << i;
            stream_loc_notcl[loc++] = 2 + i;

            /* Rasterize it. */
            rX00_rs_col(&rs, col_count, col_count, SWIZ_XYZW);
d345 1
a345 1
            /* Write it to the FS input register if it's needed by the FS. */
d347 1
a347 1
                rX00_rs_col_write(&rs, col_count, fp_offset, WRITE_COLOR);
a348 5

                DBG(r300, DBG_RS,
                    "r300: Rasterized color %i written to FS.\n", i);
            } else {
                DBG(r300, DBG_RS, "r300: Rasterized color %i unused.\n", i);
a355 3

                DBG(r300, DBG_RS, "r300: FS input color %i unassigned%s.\n",
                    i);
a359 47
    /* Set up back-face colors. The rasterizer will do the color selection
     * automatically. */
    if (any_bcolor_used) {
        if (r300->two_sided_color) {
            /* Rasterize as back-face colors. */
            for (i = 0; i < ATTR_COLOR_COUNT; i++) {
                rs.vap_vsm_vtx_assm |= R300_INPUT_CNTL_COLOR;
                rs.vap_out_vtx_fmt[0] |= R300_VAP_OUTPUT_VTX_FMT_0__COLOR_0_PRESENT << (2+i);
                stream_loc_notcl[loc++] = 4 + i;
            }
        } else {
            /* Rasterize two fake texcoords to prevent from the two-sided color
             * selection. */
            /* XXX Consider recompiling the vertex shader to save 2 RS units. */
            for (i = 0; i < 2; i++) {
                rs.vap_vsm_vtx_assm |= (R300_INPUT_CNTL_TC0 << tex_count);
                rs.vap_out_vtx_fmt[1] |= (4 << (3 * tex_count));
                stream_loc_notcl[loc++] = 6 + tex_count;

                /* Rasterize it. */
                rX00_rs_tex(&rs, tex_count, tex_ptr, SWIZ_XYZW);
                tex_count++;
                tex_ptr += 4;
            }
        }
    }

    /* gl_FrontFacing.
     * Note that we can use either the two-sided color selection based on
     * the front and back vertex shader colors, or gl_FrontFacing,
     * but not both! It locks up otherwise.
     *
     * In Direct3D 9, the two-sided color selection can be used
     * with shaders 2.0 only, while gl_FrontFacing can be used
     * with shaders 3.0 only. The hardware apparently hasn't been designed
     * to support both at the same time. */
    if (r300->screen->caps.is_r500 && fs_inputs->face != ATTR_UNUSED &&
        !(any_bcolor_used && r300->two_sided_color)) {
        rX00_rs_col(&rs, col_count, col_count, SWIZ_XYZW);
        rX00_rs_col_write(&rs, col_count, fp_offset, WRITE_FACE);
        fp_offset++;
        col_count++;
        DBG(r300, DBG_RS, "r300: Rasterized FACE written to FS.\n");
    } else if (fs_inputs->face != ATTR_UNUSED) {
        fprintf(stderr, "r300: ERROR: FS input FACE unassigned.\n");
    }

d361 5
a365 2
    for (i = 0; i < ATTR_GENERIC_COUNT && tex_count < 8; i++) {
	bool sprite_coord = false;
d367 1
a367 19
	if (fs_inputs->generic[i] != ATTR_UNUSED) {
	    sprite_coord = !!(r300->sprite_coord_enable & (1 << i));
	}

        if (vs_outputs->generic[i] != ATTR_UNUSED || sprite_coord) {
            if (!sprite_coord) {
                /* Set up the texture coordinates in VAP. */
                rs.vap_vsm_vtx_assm |= (R300_INPUT_CNTL_TC0 << tex_count);
                rs.vap_out_vtx_fmt[1] |= (4 << (3 * tex_count));
                stream_loc_notcl[loc++] = 6 + tex_count;
            } else
                stuffing_enable |=
                    R300_GB_TEX_ST << (R300_GB_TEX0_SOURCE_SHIFT + (tex_count*2));

            /* Rasterize it. */
            rX00_rs_tex(&rs, tex_count, tex_ptr,
			sprite_coord ? SWIZ_XY01 : SWIZ_XYZW);

            /* Write it to the FS input register if it's needed by the FS. */
a370 8

                DBG(r300, DBG_RS,
                    "r300: Rasterized generic %i written to FS%s in texcoord %d.\n",
                    i, sprite_coord ? " (sprite coord)" : "", tex_count);
            } else {
                DBG(r300, DBG_RS,
                    "r300: Rasterized generic %i unused%s.\n",
                    i, sprite_coord ? " (sprite coord)" : "");
a372 1
            tex_ptr += sprite_coord ? 2 : 4;
a377 3

                DBG(r300, DBG_RS, "r300: FS input generic %i unassigned%s.\n",
                    i, sprite_coord ? " (sprite coord)" : "");
a381 7
    for (; i < ATTR_GENERIC_COUNT; i++) {
        if (fs_inputs->generic[i] != ATTR_UNUSED) {
            fprintf(stderr, "r300: ERROR: FS input generic %i unassigned, "
                    "not enough hardware slots.\n", i);
        }
    }

d383 4
a386 8
    if (vs_outputs->fog != ATTR_UNUSED && tex_count < 8) {
        /* Set up the fog coordinates in VAP. */
        rs.vap_vsm_vtx_assm |= (R300_INPUT_CNTL_TC0 << tex_count);
        rs.vap_out_vtx_fmt[1] |= (4 << (3 * tex_count));
        stream_loc_notcl[loc++] = 6 + tex_count;

        /* Rasterize it. */
        rX00_rs_tex(&rs, tex_count, tex_ptr, SWIZ_X001);
d388 1
a388 1
        /* Write it to the FS input register if it's needed by the FS. */
a391 4

            DBG(r300, DBG_RS, "r300: Rasterized fog written to FS.\n");
        } else {
            DBG(r300, DBG_RS, "r300: Rasterized fog unused.\n");
a393 1
        tex_ptr += 4;
a398 7

            if (tex_count < 8) {
                DBG(r300, DBG_RS, "r300: FS input fog unassigned.\n");
            } else {
                fprintf(stderr, "r300: ERROR: FS input fog unassigned, "
                        "not enough hardware slots.\n");
            }
d403 3
a405 11
    /* Don't set it in VAP if the FS doesn't need it. */
    if (fs_inputs->wpos != ATTR_UNUSED && tex_count < 8) {
        /* Set up the WPOS coordinates in VAP. */
        rs.vap_vsm_vtx_assm |= (R300_INPUT_CNTL_TC0 << tex_count);
        rs.vap_out_vtx_fmt[1] |= (4 << (3 * tex_count));
        stream_loc_notcl[loc++] = 6 + tex_count;

        /* Rasterize it. */
        rX00_rs_tex(&rs, tex_count, tex_ptr, SWIZ_XYZW);

        /* Write it to the FS input register. */
a407 2
        DBG(r300, DBG_RS, "r300: Rasterized WPOS written to FS.\n");

a409 11
        tex_ptr += 4;
    } else {
        if (fs_inputs->wpos != ATTR_UNUSED && tex_count >= 8) {
            fprintf(stderr, "r300: ERROR: FS input WPOS unassigned, "
                    "not enough hardware slots.\n");
        }
    }

    /* Invalidate the rest of the no-TCL (GA) stream locations. */
    for (; loc < 16;) {
        stream_loc_notcl[loc++] = -1;
d414 1
a414 1
        rX00_rs_col(&rs, 0, 0, SWIZ_0001);
a415 2

        DBG(r300, DBG_RS, "r300: Rasterized color 0 to prevent lockups.\n");
d418 1
a418 4
    DBG(r300, DBG_RS, "r300: --- Rasterizer status ---: colors: %i, "
        "generics: %i.\n", col_count, tex_count);

    rs.count = MIN2(tex_ptr, 32) | (col_count << R300_IC_COUNT_SHIFT) |
a423 6
    /* set the GB enable flags */
    if (r300->sprite_coord_enable)
	stuffing_enable |= R300_GB_POINT_STUFF_ENABLE;

    rs.gb_enable = stuffing_enable;

d427 1
a427 1
        r300->rs_block_state.size = 13 + count*2;
d431 2
a432 3
static uint32_t r300_get_border_color(enum pipe_format format,
                                      const float border[4],
                                      boolean is_r500)
d434 8
a441 4
    const struct util_format_description *desc;
    float border_swizzled[4] = {0};
    unsigned i;
    union util_color uc = {0};
d443 1
a443 1
    desc = util_format_description(format);
d445 6
a450 16
    /* Do depth formats first. */
    if (util_format_is_depth_or_stencil(format)) {
        switch (format) {
        case PIPE_FORMAT_Z16_UNORM:
            return util_pack_z(PIPE_FORMAT_Z16_UNORM, border[0]);
        case PIPE_FORMAT_X8Z24_UNORM:
        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
            if (is_r500) {
                return util_pack_z(PIPE_FORMAT_X8Z24_UNORM, border[0]);
            } else {
                return util_pack_z(PIPE_FORMAT_Z16_UNORM, border[0]) << 16;
            }
        default:
            assert(0);
            return 0;
        }
d452 6
d459 22
a480 17
    /* Apply inverse swizzle of the format. */
    for (i = 0; i < 4; i++) {
        switch (desc->swizzle[i]) {
        case UTIL_FORMAT_SWIZZLE_X:
            border_swizzled[2] = border[i];
            break;
        case UTIL_FORMAT_SWIZZLE_Y:
            border_swizzled[1] = border[i];
            break;
        case UTIL_FORMAT_SWIZZLE_Z:
            border_swizzled[0] = border[i];
            break;
        case UTIL_FORMAT_SWIZZLE_W:
            border_swizzled[3] = border[i];
            break;
        }
    }
d482 26
a507 20
    /* Compressed formats. */
    if (util_format_is_compressed(format)) {
        util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
        return uc.ui;
    }

    switch (desc->channel[0].size) {
        case 4:
            util_pack_color(border_swizzled, PIPE_FORMAT_B4G4R4A4_UNORM, &uc);
            break;

        case 5:
            if (desc->channel[1].size == 5) {
                util_pack_color(border_swizzled, PIPE_FORMAT_B5G5R5A1_UNORM, &uc);
            } else if (desc->channel[1].size == 6) {
                util_pack_color(border_swizzled, PIPE_FORMAT_B5G6R5_UNORM, &uc);
            } else {
                assert(0);
            }
            break;
d509 11
a519 17
        default:
        case 8:
            util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
            break;

        case 10:
            util_pack_color(border_swizzled, PIPE_FORMAT_B10G10R10A2_UNORM, &uc);
            break;

        case 16:
            if (desc->nr_channels <= 2) {
                border_swizzled[0] = border_swizzled[2];
                util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_UNORM, &uc);
            } else {
                util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
            }
            break;
d522 1
a522 1
    return uc.ui;
a530 1
    struct r300_sampler_view *view;
d532 2
a533 7
    unsigned min_level, max_level, i, j, size;
    unsigned count = MIN2(state->sampler_view_count,
                          state->sampler_state_count);

    /* The KIL opcode fix, see below. */
    if (!count && !r300->screen->caps.is_r500)
        count = 1;
a535 1
    state->count = 0;
d539 1
a539 1
        if (state->sampler_views[i] && state->sampler_states[i]) {
d542 1
a542 2
            view = state->sampler_views[i];
            tex = r300_texture(view->base.texture);
d546 6
a551 65
            texstate->format = view->format;
            texstate->filter0 = sampler->filter0;
            texstate->filter1 = sampler->filter1;

            /* Set the border color. */
            texstate->border_color =
                r300_get_border_color(view->base.format,
                                      sampler->state.border_color,
                                      r300->screen->caps.is_r500);

            /* determine min/max levels */
            max_level = MIN3(sampler->max_lod + view->base.u.tex.first_level,
                             tex->desc.b.b.last_level, view->base.u.tex.last_level);
            min_level = MIN2(sampler->min_lod + view->base.u.tex.first_level,
                             max_level);

            if (tex->desc.is_npot && min_level > 0) {
                /* Even though we do not implement mipmapping for NPOT
                 * textures, we should at least honor the minimum level
                 * which is allowed to be displayed. We do this by setting up
                 * an i-th mipmap level as the zero level. */
                r300_texture_setup_format_state(r300->screen, &tex->desc,
                                                min_level,
                                                &texstate->format);
                texstate->format.tile_config |=
                        tex->desc.offset_in_bytes[min_level] & 0xffffffe0;
                assert((tex->desc.offset_in_bytes[min_level] & 0x1f) == 0);
            }

            /* Assign a texture cache region. */
            texstate->format.format1 |= view->texcache_region;

            /* Depth textures are kinda special. */
            if (util_format_is_depth_or_stencil(tex->desc.b.b.format)) {
                unsigned char depth_swizzle[4];

                if (!r300->screen->caps.is_r500 &&
                    util_format_get_blocksizebits(tex->desc.b.b.format) == 32) {
                    /* X24x8 is sampled as Y16X16 on r3xx-r4xx.
                     * The depth here is at the Y component. */
                    for (j = 0; j < 4; j++)
                        depth_swizzle[j] = UTIL_FORMAT_SWIZZLE_Y;
                } else {
                    for (j = 0; j < 4; j++)
                        depth_swizzle[j] = UTIL_FORMAT_SWIZZLE_X;
                }

                /* If compare mode is disabled, sampler view swizzles
                 * are stored in the format.
                 * Otherwise, the swizzles must be applied after the compare
                 * mode in the fragment shader. */
                if (sampler->state.compare_mode == PIPE_TEX_COMPARE_NONE) {
                    texstate->format.format1 |=
                        r300_get_swizzle_combined(depth_swizzle,
                                                  view->swizzle, FALSE);
                } else {
                    texstate->format.format1 |=
                        r300_get_swizzle_combined(depth_swizzle, 0, FALSE);
                }
            }

            if (r300->screen->caps.dxtc_swizzle &&
                util_format_is_compressed(tex->desc.b.b.format)) {
                texstate->filter1 |= R400_DXTC_SWIZZLE_ENABLE;
            }
d554 3
a556 9
            if (tex->desc.b.b.target == PIPE_TEXTURE_1D) {
                texstate->filter0 &= ~R300_TX_WRAP_T_MASK;
                texstate->filter0 |= R300_TX_WRAP_T(R300_TX_CLAMP_TO_EDGE);
            }

            /* The hardware doesn't like CLAMP and CLAMP_TO_BORDER
             * for the 3rd coordinate if the texture isn't 3D. */
            if (tex->desc.b.b.target != PIPE_TEXTURE_3D) {
                texstate->filter0 &= ~R300_TX_WRAP_R_MASK;
d559 1
a559 1
            if (tex->desc.is_npot) {
d562 1
a562 20
                texstate->filter0 &= ~R300_TX_MIN_FILTER_MIP_MASK;

                /* Mask out the mirrored flag. */
                if (texstate->filter0 & R300_TX_WRAP_S(R300_TX_MIRRORED)) {
                    texstate->filter0 &= ~R300_TX_WRAP_S(R300_TX_MIRRORED);
                }
                if (texstate->filter0 & R300_TX_WRAP_T(R300_TX_MIRRORED)) {
                    texstate->filter0 &= ~R300_TX_WRAP_T(R300_TX_MIRRORED);
                }

                /* Change repeat to clamp-to-edge.
                 * (the repeat bit has a value of 0, no masking needed). */
                if ((texstate->filter0 & R300_TX_WRAP_S_MASK) ==
                    R300_TX_WRAP_S(R300_TX_REPEAT)) {
                    texstate->filter0 |= R300_TX_WRAP_S(R300_TX_CLAMP_TO_EDGE);
                }
                if ((texstate->filter0 & R300_TX_WRAP_T_MASK) ==
                    R300_TX_WRAP_T(R300_TX_REPEAT)) {
                    texstate->filter0 |= R300_TX_WRAP_T(R300_TX_CLAMP_TO_EDGE);
                }
d564 1
d566 4
a569 2
                texstate->format.format0 |= R300_TX_NUM_LEVELS(max_level);
                texstate->filter0 |= R300_TX_MAX_MIP_LEVEL(min_level);
d572 1
a572 1
            texstate->filter0 |= i << 28;
a575 30
        } else {
            /* For the KIL opcode to work on r3xx-r4xx, the texture unit
             * assigned to this opcode (it's always the first one) must be
             * enabled. Otherwise the opcode doesn't work.
             *
             * In order to not depend on the fragment shader, we just make
             * the first unit enabled all the time. */
            if (i == 0 && !r300->screen->caps.is_r500) {
                pipe_sampler_view_reference(
                        (struct pipe_sampler_view**)&state->sampler_views[i],
                        &r300->texkill_sampler->base);

                state->tx_enable |= 1 << i;

                texstate = &state->regs[i];

                /* Just set some valid state. */
                texstate->format = r300->texkill_sampler->format;
                texstate->filter0 =
                        r300_translate_tex_filters(PIPE_TEX_FILTER_NEAREST,
                                                   PIPE_TEX_FILTER_NEAREST,
                                                   PIPE_TEX_FILTER_NEAREST,
                                                   FALSE);
                texstate->filter1 = 0;
                texstate->border_color = 0;

                texstate->filter0 |= i << 28;
                size += 16;
                state->count = i+1;
            }
a579 41

    /* Pick a fragment shader based on either the texture compare state
     * or the uses_pitch flag. */
    if (r300->fs.state && count) {
        if (r300_pick_fragment_shader(r300)) {
            r300_mark_fs_code_dirty(r300);
        }
    }
}

/* We can't use compressed zbuffers as samplers. */
static void r300_flush_depth_textures(struct r300_context *r300)
{
    struct r300_textures_state *state =
        (struct r300_textures_state*)r300->textures_state.state;
    unsigned i, level;
    unsigned count = MIN2(state->sampler_view_count,
                          state->sampler_state_count);

    if (r300->z_decomp_rd)
        return;

    for (i = 0; i < count; i++)
        if (state->sampler_views[i] && state->sampler_states[i]) {
            struct pipe_resource *tex = state->sampler_views[i]->base.texture;

            if (tex->target == PIPE_TEXTURE_3D ||
                tex->target == PIPE_TEXTURE_CUBE)
                continue;

            /* Ignore non-depth textures.
             * Also ignore reinterpreted depth textures, e.g. resource_copy. */
            if (!util_format_is_depth_or_stencil(tex->format))
                continue;

            for (level = 0; level <= tex->last_level; level++)
                if (r300_texture(tex)->zmask_in_use[level]) {
                    /* We don't handle 3D textures and cubemaps yet. */
                    r300_flush_depth_stencil(&r300->context, tex, level, 0);
                 }
        }
d584 5
a588 1
    r300_flush_depth_textures(r300);
d594 1
a594 12
    if (r300->rs_block_state.dirty) {
        r300_update_rs_block(r300);

        if (r300->draw) {
            memset(&r300->vertex_info, 0, sizeof(struct vertex_info));
            r300_draw_emit_all_attribs(r300);
            draw_compute_vertex_size(&r300->vertex_info);
            r300_swtcl_vertex_psc(r300);
        }
    }

    r300_update_hyperz_state(r300);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d32 1
d35 1
a320 1
    int gen_offset = 0;
a440 52
    /* Re-use color varyings for texcoords if possible.
     *
     * The colors are interpolated as 20-bit floats (reduced precision),
     * Use this hack only if there are too many generic varyings.
     * (number of generic varyings + fog + wpos > 8) */
    if (r300->screen->caps.is_r500 && !any_bcolor_used && !r300->flatshade &&
	fs_inputs->face == ATTR_UNUSED &&
        vs_outputs->num_generic + (vs_outputs->fog != ATTR_UNUSED) +
        (fs_inputs->wpos != ATTR_UNUSED) > 8) {
	for (i = 0; i < ATTR_GENERIC_COUNT && col_count < 2; i++) {
	    /* Cannot use color varyings for sprite coords. */
	    if (fs_inputs->generic[i] != ATTR_UNUSED &&
		(r300->sprite_coord_enable & (1 << i))) {
		break;
	    }

	    if (vs_outputs->generic[i] != ATTR_UNUSED) {
		/* Set up the color in VAP. */
		rs.vap_vsm_vtx_assm |= R300_INPUT_CNTL_COLOR;
		rs.vap_out_vtx_fmt[0] |=
			R300_VAP_OUTPUT_VTX_FMT_0__COLOR_0_PRESENT << col_count;
		stream_loc_notcl[loc++] = 2 + col_count;

		/* Rasterize it. */
		rX00_rs_col(&rs, col_count, col_count, SWIZ_XYZW);

		/* Write it to the FS input register if it's needed by the FS. */
		if (fs_inputs->generic[i] != ATTR_UNUSED) {
		    rX00_rs_col_write(&rs, col_count, fp_offset, WRITE_COLOR);
		    fp_offset++;

		    DBG(r300, DBG_RS,
			"r300: Rasterized generic %i redirected to color %i and written to FS.\n",
		        i, col_count);
		} else {
		    DBG(r300, DBG_RS, "r300: Rasterized generic %i redirected to color %i unused.\n",
		        i, col_count);
		}
		col_count++;
	    } else {
		/* Skip the FS input register, leave it uninitialized. */
		/* If we try to set it to (0,0,0,1), it will lock up. */
		if (fs_inputs->generic[i] != ATTR_UNUSED) {
		    fp_offset++;

		    DBG(r300, DBG_RS, "r300: FS input generic %i unassigned%s.\n", i);
		}
	    }
	}
	gen_offset = i;
    }

d442 2
a443 2
    for (i = gen_offset; i < ATTR_GENERIC_COUNT && tex_count < 8; i++) {
	boolean sprite_coord = false;
d493 1
a493 2
                    "not enough hardware slots (it's not a bug, do not "
                    "report it).\n", i);
d528 1
a528 2
                        "not enough hardware slots. (it's not a bug, "
                        "do not report it)\n");
d555 1
a555 2
                    "not enough hardware slots. (it's not a bug, do not "
                    "report it)\n");
a593 7
static void rgba_to_bgra(float color[4])
{
    float x = color[0];
    color[0] = color[2];
    color[2] = x;
}

d600 1
d611 1
a611 1
        case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d624 16
a639 1
    util_format_unswizzle_4f(border_swizzled, border, desc->swizzle);
d643 2
a644 33
        switch (format) {
        case PIPE_FORMAT_RGTC1_SNORM:
        case PIPE_FORMAT_LATC1_SNORM:
            border_swizzled[0] = border_swizzled[0] < 0 ?
                                 border_swizzled[0]*0.5+1 :
                                 border_swizzled[0]*0.5;
            /* Pass through. */

        case PIPE_FORMAT_RGTC1_UNORM:
        case PIPE_FORMAT_LATC1_UNORM:
            /* Add 1/32 to round the border color instead of truncating. */
            /* The Y component is used for the border color. */
            border_swizzled[1] = border_swizzled[0] + 1.0f/32;
            util_pack_color(border_swizzled, PIPE_FORMAT_B4G4R4A4_UNORM, &uc);
            return uc.ui;
        case PIPE_FORMAT_RGTC2_SNORM:
        case PIPE_FORMAT_LATC2_SNORM:
            util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SNORM, &uc);
            return uc.ui;
        case PIPE_FORMAT_RGTC2_UNORM:
        case PIPE_FORMAT_LATC2_UNORM:
            util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
            return uc.ui;
        case PIPE_FORMAT_DXT1_SRGB:
        case PIPE_FORMAT_DXT1_SRGBA:
        case PIPE_FORMAT_DXT3_SRGBA:
        case PIPE_FORMAT_DXT5_SRGBA:
            util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_SRGB, &uc);
            return uc.ui;
        default:
            util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
            return uc.ui;
        }
a647 5
        case 2:
            rgba_to_bgra(border_swizzled);
            util_pack_color(border_swizzled, PIPE_FORMAT_B2G3R3_UNORM, &uc);
            break;

a648 1
            rgba_to_bgra(border_swizzled);
a652 1
            rgba_to_bgra(border_swizzled);
d664 1
a664 12
            if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
                util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SNORM, &uc);
            } else if (desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
                if (desc->nr_channels == 2) {
                    border_swizzled[3] = border_swizzled[1];
                    util_pack_color(border_swizzled, PIPE_FORMAT_L8A8_SRGB, &uc);
                } else {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SRGB, &uc);
                }
            } else {
                util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
            }
d668 1
a668 1
            util_pack_color(border_swizzled, PIPE_FORMAT_R10G10B10A2_UNORM, &uc);
d673 2
a674 19
                if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_FLOAT, &uc);
                } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_SNORM, &uc);
                } else {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_UNORM, &uc);
                }
            } else {
                if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_SNORM, &uc);
                } else {
                    util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
                }
            }
            break;

        case 32:
            if (desc->nr_channels == 1) {
                util_pack_color(border_swizzled, PIPE_FORMAT_R32_FLOAT, &uc);
d676 1
a676 1
                util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
d691 2
a692 2
    struct r300_resource *tex;
    unsigned base_level, min_level, level_count, i, j, size;
a694 1
    boolean has_us_format = r300->screen->caps.has_us_format;
d709 1
a709 1
            tex = r300_resource(view->base.texture);
d720 1
a720 1
                                      sampler->state.border_color.f,
d724 12
a735 23
            base_level = view->base.u.tex.first_level;
            min_level = sampler->min_lod;
            level_count = MIN3(sampler->max_lod,
                               tex->b.b.last_level - base_level,
                               view->base.u.tex.last_level - base_level);

            if (base_level + min_level) {
                unsigned offset;

                if (tex->tex.is_npot) {
                    /* Even though we do not implement mipmapping for NPOT
                     * textures, we should at least honor the minimum level
                     * which is allowed to be displayed. We do this by setting up
                     * an i-th mipmap level as the zero level. */
                    base_level += min_level;
                }
                offset = tex->tex.offset_in_bytes[base_level];

                r300_texture_setup_format_state(r300->screen, tex,
                                                view->base.format,
                                                base_level,
                                                view->width0_override,
		                                view->height0_override,
d737 3
a739 2
                texstate->format.tile_config |= offset & 0xffffffe0;
                assert((offset & 0x1f) == 0);
d746 1
a746 1
            if (util_format_is_depth_or_stencil(view->base.format)) {
d750 1
a750 1
                    util_format_get_blocksizebits(view->base.format) == 32) {
d775 1
a775 1
                util_format_is_compressed(view->base.format)) {
d780 1
a780 1
            if (tex->b.b.target == PIPE_TEXTURE_1D) {
d787 1
a787 1
            if (tex->b.b.target != PIPE_TEXTURE_3D) {
d791 1
a791 1
            if (tex->tex.is_npot) {
d816 1
a816 1
                texstate->format.format0 |= R300_TX_NUM_LEVELS(level_count);
a819 26
            /* Float textures only support nearest and mip-nearest filtering. */
            if (util_format_is_float(view->base.format)) {
                /* No MAG linear filtering. */
                if ((texstate->filter0 & R300_TX_MAG_FILTER_MASK) ==
                    R300_TX_MAG_FILTER_LINEAR) {
                    texstate->filter0 &= ~R300_TX_MAG_FILTER_MASK;
                    texstate->filter0 |= R300_TX_MAG_FILTER_NEAREST;
                }
                /* No MIN linear filtering. */
                if ((texstate->filter0 & R300_TX_MIN_FILTER_MASK) ==
                    R300_TX_MIN_FILTER_LINEAR) {
                    texstate->filter0 &= ~R300_TX_MIN_FILTER_MASK;
                    texstate->filter0 |= R300_TX_MIN_FILTER_NEAREST;
                }
                /* No mipmap linear filtering. */
                if ((texstate->filter0 & R300_TX_MIN_FILTER_MIP_MASK) ==
                    R300_TX_MIN_FILTER_MIP_LINEAR) {
                    texstate->filter0 &= ~R300_TX_MIN_FILTER_MIP_MASK;
                    texstate->filter0 |= R300_TX_MIN_FILTER_MIP_NEAREST;
                }
                /* No anisotropic filtering. */
                texstate->filter0 &= ~R300_TX_MAX_ANISO_MASK;
                texstate->filter1 &= ~R500_TX_MAX_ANISO_MASK;
                texstate->filter1 &= ~R500_TX_ANISO_HIGH_QUALITY;
            }

d822 1
a822 1
            size += 16 + (has_us_format ? 2 : 0);
d851 1
a851 1
                size += 16 + (has_us_format ? 2 : 0);
d860 5
a864 4
     * or the uses_pitch flag or some other external state. */
    if (count &&
        r300->fs_status == FRAGMENT_SHADER_VALID) {
        r300->fs_status = FRAGMENT_SHADER_MAYBE_DIRTY;
d868 2
a869 1
static void r300_decompress_depth_textures(struct r300_context *r300)
d873 1
a873 1
    struct pipe_resource *tex;
a875 1
    unsigned i;
d877 1
a877 1
    if (!r300->locked_zbuffer) {
a878 1
    }
d880 1
a880 1
    for (i = 0; i < count; i++) {
d882 1
a882 1
            tex = state->sampler_views[i]->base.texture;
d884 14
a897 4
            if (tex == r300->locked_zbuffer->texture) {
                r300_decompress_zmask_locked(r300);
                return;
            }
a898 1
    }
d901 1
a901 1
static void r300_validate_fragment_shader(struct r300_context *r300)
d903 1
a903 1
    struct pipe_framebuffer_state *fb = r300->fb_state.state;
a904 26
    if (r300->fs.state && r300->fs_status != FRAGMENT_SHADER_VALID) {
        /* Pick the fragment shader based on external states.
         * Then mark the state dirty if the fragment shader is either dirty
         * or the function r300_pick_fragment_shader changed the shader. */
        if (r300_pick_fragment_shader(r300) ||
            r300->fs_status == FRAGMENT_SHADER_DIRTY) {
            /* Mark the state atom as dirty. */
            r300_mark_fs_code_dirty(r300);

            /* Does Multiwrite need to be changed? */
            if (fb->nr_cbufs > 1) {
                boolean new_multiwrite =
                    r300_fragment_shader_writes_all(r300_fs(r300));

                if (r300->fb_multiwrite != new_multiwrite) {
                    r300->fb_multiwrite = new_multiwrite;
                    r300_mark_fb_state_dirty(r300, R300_CHANGED_MULTIWRITE);
                }
            }
        }
        r300->fs_status = FRAGMENT_SHADER_VALID;
    }
}

void r300_update_derived_state(struct r300_context* r300)
{
a905 1
        r300_decompress_depth_textures(r300);
a907 2

    r300_validate_fragment_shader(r300);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d702 1
a702 1
            return uc.ui[0];
d706 1
a706 1
            return uc.ui[0];
d710 1
a710 1
            return uc.ui[0];
d716 1
a716 1
            return uc.ui[0];
d719 1
a719 1
            return uc.ui[0];
d792 1
a792 1
    return uc.ui[0];
@


