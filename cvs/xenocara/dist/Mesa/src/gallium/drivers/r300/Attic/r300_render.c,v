head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2013.09.05.14.00.57;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.01;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.08.03;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.45.13;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2009 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2010 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

/* r300_render: Vertex and index buffer primitive emission. Contains both
 * HW TCL fastpath rendering, and SW TCL Draw-assisted rendering. */

#include "draw/draw_context.h"
#include "draw/draw_vbuf.h"

#include "util/u_inlines.h"

#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_upload_mgr.h"
#include "util/u_prim.h"

#include "r300_cs.h"
#include "r300_context.h"
#include "r300_screen_buffer.h"
#include "r300_emit.h"
#include "r300_reg.h"

#include <limits.h>

#define IMMD_DWORDS 32

static uint32_t r300_translate_primitive(unsigned prim)
{
    static const int prim_conv[] = {
        R300_VAP_VF_CNTL__PRIM_POINTS,
        R300_VAP_VF_CNTL__PRIM_LINES,
        R300_VAP_VF_CNTL__PRIM_LINE_LOOP,
        R300_VAP_VF_CNTL__PRIM_LINE_STRIP,
        R300_VAP_VF_CNTL__PRIM_TRIANGLES,
        R300_VAP_VF_CNTL__PRIM_TRIANGLE_STRIP,
        R300_VAP_VF_CNTL__PRIM_TRIANGLE_FAN,
        R300_VAP_VF_CNTL__PRIM_QUADS,
        R300_VAP_VF_CNTL__PRIM_QUAD_STRIP,
        R300_VAP_VF_CNTL__PRIM_POLYGON,
        -1,
        -1,
        -1,
        -1
    };
    unsigned hwprim = prim_conv[prim];

    assert(hwprim != -1);
    return hwprim;
}

static uint32_t r300_provoking_vertex_fixes(struct r300_context *r300,
                                            unsigned mode)
{
    struct r300_rs_state* rs = (struct r300_rs_state*)r300->rs_state.state;
    uint32_t color_control = rs->color_control;

    /* By default (see r300_state.c:r300_create_rs_state) color_control is
     * initialized to provoking the first vertex.
     *
     * Triangle fans must be reduced to the second vertex, not the first, in
     * Gallium flatshade-first mode, as per the GL spec.
     * (http://www.opengl.org/registry/specs/ARB/provoking_vertex.txt)
     *
     * Quads never provoke correctly in flatshade-first mode. The first
     * vertex is never considered as provoking, so only the second, third,
     * and fourth vertices can be selected, and both "third" and "last" modes
     * select the fourth vertex. This is probably due to D3D lacking quads.
     *
     * Similarly, polygons reduce to the first, not the last, vertex, when in
     * "last" mode, and all other modes start from the second vertex.
     *
     * ~ C.
     */

    if (rs->rs.flatshade_first) {
        switch (mode) {
            case PIPE_PRIM_TRIANGLE_FAN:
                color_control |= R300_GA_COLOR_CONTROL_PROVOKING_VERTEX_SECOND;
                break;
            case PIPE_PRIM_QUADS:
            case PIPE_PRIM_QUAD_STRIP:
            case PIPE_PRIM_POLYGON:
                color_control |= R300_GA_COLOR_CONTROL_PROVOKING_VERTEX_LAST;
                break;
            default:
                color_control |= R300_GA_COLOR_CONTROL_PROVOKING_VERTEX_FIRST;
                break;
        }
    } else {
        color_control |= R300_GA_COLOR_CONTROL_PROVOKING_VERTEX_LAST;
    }

    return color_control;
}

void r500_emit_index_bias(struct r300_context *r300, int index_bias)
{
    CS_LOCALS(r300);

    BEGIN_CS(2);
    OUT_CS_REG(R500_VAP_INDEX_OFFSET,
               (index_bias & 0xFFFFFF) | (index_bias < 0 ? 1<<24 : 0));
    END_CS;
}

static void r300_emit_draw_init(struct r300_context *r300, unsigned mode,
                                unsigned max_index)
{
    CS_LOCALS(r300);

    assert(max_index < (1 << 24));

    BEGIN_CS(5);
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
            r300_provoking_vertex_fixes(r300, mode));
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(max_index);
    OUT_CS(0);
    END_CS;
}

/* This function splits the index bias value into two parts:
 * - buffer_offset: the value that can be safely added to buffer offsets
 *   in r300_emit_vertex_arrays (it must yield a positive offset when added to
 *   a vertex buffer offset)
 * - index_offset: the value that must be manually subtracted from indices
 *   in an index buffer to achieve negative offsets. */
static void r300_split_index_bias(struct r300_context *r300, int index_bias,
                                  int *buffer_offset, int *index_offset)
{
    struct pipe_vertex_buffer *vb, *vbufs = r300->vertex_buffer;
    struct pipe_vertex_element *velem = r300->velems->velem;
    unsigned i, size;
    int max_neg_bias;

    if (index_bias < 0) {
        /* See how large index bias we may subtract. We must be careful
         * here because negative buffer offsets are not allowed
         * by the DRM API. */
        max_neg_bias = INT_MAX;
        for (i = 0; i < r300->velems->count; i++) {
            vb = &vbufs[velem[i].vertex_buffer_index];
            size = (vb->buffer_offset + velem[i].src_offset) / vb->stride;
            max_neg_bias = MIN2(max_neg_bias, size);
        }

        /* Now set the minimum allowed value. */
        *buffer_offset = MAX2(-max_neg_bias, index_bias);
    } else {
        /* A positive index bias is OK. */
        *buffer_offset = index_bias;
    }

    *index_offset = index_bias - *buffer_offset;
}

enum r300_prepare_flags {
    PREP_EMIT_STATES    = (1 << 0), /* call emit_dirty_state and friends? */
    PREP_VALIDATE_VBOS  = (1 << 1), /* validate VBOs? */
    PREP_EMIT_VARRAYS       = (1 << 2), /* call emit_vertex_arrays? */
    PREP_EMIT_VARRAYS_SWTCL = (1 << 3), /* call emit_vertex_arrays_swtcl? */
    PREP_INDEXED        = (1 << 4)  /* is this draw_elements? */
};

/**
 * Check if the requested number of dwords is available in the CS and
 * if not, flush.
 * \param r300          The context.
 * \param flags         See r300_prepare_flags.
 * \param cs_dwords     The number of dwords to reserve in CS.
 * \return TRUE if the CS was flushed
 */
static boolean r300_reserve_cs_dwords(struct r300_context *r300,
                                      enum r300_prepare_flags flags,
                                      unsigned cs_dwords)
{
    boolean flushed        = FALSE;
    boolean emit_states    = flags & PREP_EMIT_STATES;
    boolean emit_vertex_arrays       = flags & PREP_EMIT_VARRAYS;
    boolean emit_vertex_arrays_swtcl = flags & PREP_EMIT_VARRAYS_SWTCL;

    /* Add dirty state, index offset, and AOS. */
    if (emit_states)
        cs_dwords += r300_get_num_dirty_dwords(r300);

    if (r300->screen->caps.is_r500)
        cs_dwords += 2; /* emit_index_offset */

    if (emit_vertex_arrays)
        cs_dwords += 55; /* emit_vertex_arrays */

    if (emit_vertex_arrays_swtcl)
        cs_dwords += 7; /* emit_vertex_arrays_swtcl */

    cs_dwords += r300_get_num_cs_end_dwords(r300);

    /* Reserve requested CS space. */
    if (cs_dwords > (RADEON_MAX_CMDBUF_DWORDS - r300->cs->cdw)) {
        r300_flush(&r300->context, RADEON_FLUSH_ASYNC, NULL);
        flushed = TRUE;
    }

    return flushed;
}

/**
 * Validate buffers and emit dirty state.
 * \param r300          The context.
 * \param flags         See r300_prepare_flags.
 * \param index_buffer  The index buffer to validate. The parameter may be NULL.
 * \param buffer_offset The offset passed to emit_vertex_arrays.
 * \param index_bias    The index bias to emit.
 * \param instance_id   Index of instance to render
 * \return TRUE if rendering should be skipped
 */
static boolean r300_emit_states(struct r300_context *r300,
                                enum r300_prepare_flags flags,
                                struct pipe_resource *index_buffer,
                                int buffer_offset,
                                int index_bias, int instance_id)
{
    boolean emit_states    = flags & PREP_EMIT_STATES;
    boolean emit_vertex_arrays       = flags & PREP_EMIT_VARRAYS;
    boolean emit_vertex_arrays_swtcl = flags & PREP_EMIT_VARRAYS_SWTCL;
    boolean indexed        = flags & PREP_INDEXED;
    boolean validate_vbos  = flags & PREP_VALIDATE_VBOS;

    /* Validate buffers and emit dirty state if needed. */
    if (emit_states || (emit_vertex_arrays && validate_vbos)) {
        if (!r300_emit_buffer_validate(r300, validate_vbos,
                                       index_buffer)) {
           fprintf(stderr, "r300: CS space validation failed. "
                   "(not enough memory?) Skipping rendering.\n");
           return FALSE;
        }
    }

    if (emit_states)
        r300_emit_dirty_state(r300);

    if (r300->screen->caps.is_r500) {
        if (r300->screen->caps.has_tcl)
            r500_emit_index_bias(r300, index_bias);
        else
            r500_emit_index_bias(r300, 0);
    }

    if (emit_vertex_arrays &&
        (r300->vertex_arrays_dirty ||
         r300->vertex_arrays_indexed != indexed ||
         r300->vertex_arrays_offset != buffer_offset ||
         r300->vertex_arrays_instance_id != instance_id)) {
        r300_emit_vertex_arrays(r300, buffer_offset, indexed, instance_id);

        r300->vertex_arrays_dirty = FALSE;
        r300->vertex_arrays_indexed = indexed;
        r300->vertex_arrays_offset = buffer_offset;
        r300->vertex_arrays_instance_id = instance_id;
    }

    if (emit_vertex_arrays_swtcl)
        r300_emit_vertex_arrays_swtcl(r300, indexed);

    return TRUE;
}

/**
 * Check if the requested number of dwords is available in the CS and
 * if not, flush. Then validate buffers and emit dirty state.
 * \param r300          The context.
 * \param flags         See r300_prepare_flags.
 * \param index_buffer  The index buffer to validate. The parameter may be NULL.
 * \param cs_dwords     The number of dwords to reserve in CS.
 * \param buffer_offset The offset passed to emit_vertex_arrays.
 * \param index_bias    The index bias to emit.
 * \param instance_id The instance to render.
 * \return TRUE if rendering should be skipped
 */
static boolean r300_prepare_for_rendering(struct r300_context *r300,
                                          enum r300_prepare_flags flags,
                                          struct pipe_resource *index_buffer,
                                          unsigned cs_dwords,
                                          int buffer_offset,
                                          int index_bias,
                                          int instance_id)
{
    /* Make sure there is enough space in the command stream and emit states. */
    if (r300_reserve_cs_dwords(r300, flags, cs_dwords))
        flags |= PREP_EMIT_STATES;

    return r300_emit_states(r300, flags, index_buffer, buffer_offset,
                            index_bias, instance_id);
}

static boolean immd_is_good_idea(struct r300_context *r300,
                                 unsigned count)
{
    if (DBG_ON(r300, DBG_NO_IMMD)) {
        return FALSE;
    }

    if (count * r300->velems->vertex_size_dwords > IMMD_DWORDS) {
        return FALSE;
    }

    /* Buffers can only be used for read by r300 (except query buffers, but
     * those can't be bound by a state tracker as vertex buffers). */
    return TRUE;
}

/*****************************************************************************
 * The HWTCL draw functions.                                                 *
 ****************************************************************************/

static void r300_draw_arrays_immediate(struct r300_context *r300,
                                       const struct pipe_draw_info *info)
{
    struct pipe_vertex_element* velem;
    struct pipe_vertex_buffer* vbuf;
    unsigned vertex_element_count = r300->velems->count;
    unsigned i, v, vbi;

    /* Size of the vertex, in dwords. */
    unsigned vertex_size = r300->velems->vertex_size_dwords;

    /* The number of dwords for this draw operation. */
    unsigned dwords = 4 + info->count * vertex_size;

    /* Size of the vertex element, in dwords. */
    unsigned size[PIPE_MAX_ATTRIBS];

    /* Stride to the same attrib in the next vertex in the vertex buffer,
     * in dwords. */
    unsigned stride[PIPE_MAX_ATTRIBS];

    /* Mapped vertex buffers. */
    uint32_t* map[PIPE_MAX_ATTRIBS] = {0};
    uint32_t* mapelem[PIPE_MAX_ATTRIBS];

    CS_LOCALS(r300);

    if (!r300_prepare_for_rendering(r300, PREP_EMIT_STATES, NULL, dwords, 0, 0, -1))
        return;

    /* Calculate the vertex size, offsets, strides etc. and map the buffers. */
    for (i = 0; i < vertex_element_count; i++) {
        velem = &r300->velems->velem[i];
        size[i] = r300->velems->format_size[i] / 4;
        vbi = velem->vertex_buffer_index;
        vbuf = &r300->vertex_buffer[vbi];
        stride[i] = vbuf->stride / 4;

        /* Map the buffer. */
        if (!map[vbi]) {
            map[vbi] = (uint32_t*)r300->rws->buffer_map(
                r300_resource(vbuf->buffer)->cs_buf,
                r300->cs, PIPE_TRANSFER_READ | PIPE_TRANSFER_UNSYNCHRONIZED);
            map[vbi] += (vbuf->buffer_offset / 4) + stride[i] * info->start;
        }
        mapelem[i] = map[vbi] + (velem->src_offset / 4);
    }

    r300_emit_draw_init(r300, info->mode, info->count-1);

    BEGIN_CS(dwords);
    OUT_CS_REG(R300_VAP_VTX_SIZE, vertex_size);
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_IMMD_2, info->count * vertex_size);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_EMBEDDED | (info->count << 16) |
            r300_translate_primitive(info->mode));

    /* Emit vertices. */
    for (v = 0; v < info->count; v++) {
        for (i = 0; i < vertex_element_count; i++) {
            OUT_CS_TABLE(&mapelem[i][stride[i] * v], size[i]);
        }
    }
    END_CS;
}

static void r300_emit_draw_arrays(struct r300_context *r300,
                                  unsigned mode,
                                  unsigned count)
{
    boolean alt_num_verts = count > 65535;
    CS_LOCALS(r300);

    if (count >= (1 << 24)) {
        fprintf(stderr, "r300: Got a huge number of vertices: %i, "
                "refusing to render.\n", count);
        return;
    }

    r300_emit_draw_init(r300, mode, count-1);

    BEGIN_CS(2 + (alt_num_verts ? 2 : 0));
    if (alt_num_verts) {
        OUT_CS_REG(R500_VAP_ALT_NUM_VERTICES, count);
    }
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_VBUF_2, 0);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_LIST | (count << 16) |
           r300_translate_primitive(mode) |
           (alt_num_verts ? R500_VAP_VF_CNTL__USE_ALT_NUM_VERTS : 0));
    END_CS;
}

static void r300_emit_draw_elements(struct r300_context *r300,
                                    struct pipe_resource* indexBuffer,
                                    unsigned indexSize,
                                    unsigned max_index,
                                    unsigned mode,
                                    unsigned start,
                                    unsigned count,
                                    uint16_t *imm_indices3)
{
    uint32_t count_dwords, offset_dwords;
    boolean alt_num_verts = count > 65535;
    CS_LOCALS(r300);

    if (count >= (1 << 24)) {
        fprintf(stderr, "r300: Got a huge number of vertices: %i, "
                "refusing to render (max_index: %i).\n", count, max_index);
        return;
    }

    DBG(r300, DBG_DRAW, "r300: Indexbuf of %u indices, max %u\n",
        count, max_index);

    r300_emit_draw_init(r300, mode, max_index);

    /* If start is odd, render the first triangle with indices embedded
     * in the command stream. This will increase start by 3 and make it
     * even. We can then proceed without a fallback. */
    if (indexSize == 2 && (start & 1) &&
        mode == PIPE_PRIM_TRIANGLES) {
        BEGIN_CS(4);
        OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, 2);
        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (3 << 16) |
               R300_VAP_VF_CNTL__PRIM_TRIANGLES);
        OUT_CS(imm_indices3[1] << 16 | imm_indices3[0]);
        OUT_CS(imm_indices3[2]);
        END_CS;

        start += 3;
        count -= 3;
        if (!count)
           return;
    }

    offset_dwords = indexSize * start / sizeof(uint32_t);

    BEGIN_CS(8 + (alt_num_verts ? 2 : 0));
    if (alt_num_verts) {
        OUT_CS_REG(R500_VAP_ALT_NUM_VERTICES, count);
    }
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, 0);
    if (indexSize == 4) {
        count_dwords = count;
        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (count << 16) |
               R300_VAP_VF_CNTL__INDEX_SIZE_32bit |
               r300_translate_primitive(mode) |
               (alt_num_verts ? R500_VAP_VF_CNTL__USE_ALT_NUM_VERTS : 0));
    } else {
        count_dwords = (count + 1) / 2;
        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (count << 16) |
               r300_translate_primitive(mode) |
               (alt_num_verts ? R500_VAP_VF_CNTL__USE_ALT_NUM_VERTS : 0));
    }

    OUT_CS_PKT3(R300_PACKET3_INDX_BUFFER, 2);
    OUT_CS(R300_INDX_BUFFER_ONE_REG_WR | (R300_VAP_PORT_IDX0 >> 2) |
           (0 << R300_INDX_BUFFER_SKIP_SHIFT));
    OUT_CS(offset_dwords << 2);
    OUT_CS(count_dwords);
    OUT_CS_RELOC(r300_resource(indexBuffer));
    END_CS;
}

static void r300_draw_elements_immediate(struct r300_context *r300,
                                         const struct pipe_draw_info *info)
{
    const uint8_t *ptr1;
    const uint16_t *ptr2;
    const uint32_t *ptr4;
    unsigned index_size = r300->index_buffer.index_size;
    unsigned i, count_dwords = index_size == 4 ? info->count :
                                                 (info->count + 1) / 2;
    CS_LOCALS(r300);

    /* 19 dwords for r300_draw_elements_immediate. Give up if the function fails. */
    if (!r300_prepare_for_rendering(r300,
            PREP_EMIT_STATES | PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS |
            PREP_INDEXED, NULL, 2+count_dwords, 0, info->index_bias, -1))
        return;

    r300_emit_draw_init(r300, info->mode, info->max_index);

    BEGIN_CS(2 + count_dwords);
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, count_dwords);

    switch (index_size) {
    case 1:
        ptr1 = (uint8_t*)r300->index_buffer.user_buffer;
        ptr1 += info->start;

        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (info->count << 16) |
               r300_translate_primitive(info->mode));

        if (info->index_bias && !r300->screen->caps.is_r500) {
            for (i = 0; i < info->count-1; i += 2)
                OUT_CS(((ptr1[i+1] + info->index_bias) << 16) |
                        (ptr1[i]   + info->index_bias));

            if (info->count & 1)
                OUT_CS(ptr1[i] + info->index_bias);
        } else {
            for (i = 0; i < info->count-1; i += 2)
                OUT_CS(((ptr1[i+1]) << 16) |
                        (ptr1[i]  ));

            if (info->count & 1)
                OUT_CS(ptr1[i]);
        }
        break;

    case 2:
        ptr2 = (uint16_t*)r300->index_buffer.user_buffer;
        ptr2 += info->start;

        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (info->count << 16) |
               r300_translate_primitive(info->mode));

        if (info->index_bias && !r300->screen->caps.is_r500) {
            for (i = 0; i < info->count-1; i += 2)
                OUT_CS(((ptr2[i+1] + info->index_bias) << 16) |
                        (ptr2[i]   + info->index_bias));

            if (info->count & 1)
                OUT_CS(ptr2[i] + info->index_bias);
        } else {
            OUT_CS_TABLE(ptr2, count_dwords);
        }
        break;

    case 4:
        ptr4 = (uint32_t*)r300->index_buffer.user_buffer;
        ptr4 += info->start;

        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (info->count << 16) |
               R300_VAP_VF_CNTL__INDEX_SIZE_32bit |
               r300_translate_primitive(info->mode));

        if (info->index_bias && !r300->screen->caps.is_r500) {
            for (i = 0; i < info->count; i++)
                OUT_CS(ptr4[i] + info->index_bias);
        } else {
            OUT_CS_TABLE(ptr4, count_dwords);
        }
        break;
    }
    END_CS;
}

static void r300_draw_elements(struct r300_context *r300,
                               const struct pipe_draw_info *info,
                               int instance_id)
{
    struct pipe_resource *indexBuffer = r300->index_buffer.buffer;
    unsigned indexSize = r300->index_buffer.index_size;
    struct pipe_resource* orgIndexBuffer = indexBuffer;
    unsigned start = info->start;
    unsigned count = info->count;
    boolean alt_num_verts = r300->screen->caps.is_r500 &&
                            count > 65536;
    unsigned short_count;
    int buffer_offset = 0, index_offset = 0; /* for index bias emulation */
    uint16_t indices3[3];

    if (info->index_bias && !r300->screen->caps.is_r500) {
        r300_split_index_bias(r300, info->index_bias, &buffer_offset,
                              &index_offset);
    }

    r300_translate_index_buffer(r300, &r300->index_buffer, &indexBuffer,
                                &indexSize, index_offset, &start, count);

    /* Fallback for misaligned ushort indices. */
    if (indexSize == 2 && (start & 1) && indexBuffer) {
        /* If we got here, then orgIndexBuffer == indexBuffer. */
        uint16_t *ptr = r300->rws->buffer_map(r300_resource(orgIndexBuffer)->cs_buf,
                                              r300->cs,
                                              PIPE_TRANSFER_READ |
                                              PIPE_TRANSFER_UNSYNCHRONIZED);

        if (info->mode == PIPE_PRIM_TRIANGLES) {
           memcpy(indices3, ptr + start, 6);
        } else {
            /* Copy the mapped index buffer directly to the upload buffer.
             * The start index will be aligned simply from the fact that
             * every sub-buffer in the upload buffer is aligned. */
            r300_upload_index_buffer(r300, &indexBuffer, indexSize, &start,
                                     count, (uint8_t*)ptr);
        }
    } else {
        if (r300->index_buffer.user_buffer)
            r300_upload_index_buffer(r300, &indexBuffer, indexSize,
                                     &start, count,
                                     r300->index_buffer.user_buffer);
    }

    /* 19 dwords for emit_draw_elements. Give up if the function fails. */
    if (!r300_prepare_for_rendering(r300,
            PREP_EMIT_STATES | PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS |
            PREP_INDEXED, indexBuffer, 19, buffer_offset, info->index_bias,
            instance_id))
        goto done;

    if (alt_num_verts || count <= 65535) {
        r300_emit_draw_elements(r300, indexBuffer, indexSize,
                                info->max_index, info->mode, start, count,
                                indices3);
    } else {
        do {
            /* The maximum must be divisible by 4 and 3,
             * so that quad and triangle lists are split correctly.
             *
             * Strips, loops, and fans won't work. */
            short_count = MIN2(count, 65532);

            r300_emit_draw_elements(r300, indexBuffer, indexSize,
                                     info->max_index,
                                     info->mode, start, short_count, indices3);

            start += short_count;
            count -= short_count;

            /* 15 dwords for emit_draw_elements */
            if (count) {
                if (!r300_prepare_for_rendering(r300,
                        PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS | PREP_INDEXED,
                        indexBuffer, 19, buffer_offset, info->index_bias,
                        instance_id))
                    goto done;
            }
        } while (count);
    }

done:
    if (indexBuffer != orgIndexBuffer) {
        pipe_resource_reference( &indexBuffer, NULL );
    }
}

static void r300_draw_arrays(struct r300_context *r300,
                             const struct pipe_draw_info *info,
                             int instance_id)
{
    boolean alt_num_verts = r300->screen->caps.is_r500 &&
                            info->count > 65536;
    unsigned start = info->start;
    unsigned count = info->count;
    unsigned short_count;

    /* 9 spare dwords for emit_draw_arrays. Give up if the function fails. */
    if (!r300_prepare_for_rendering(r300,
                                    PREP_EMIT_STATES | PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS,
                                    NULL, 9, start, 0, instance_id))
        return;

    if (alt_num_verts || count <= 65535) {
        r300_emit_draw_arrays(r300, info->mode, count);
    } else {
        do {
            /* The maximum must be divisible by 4 and 3,
             * so that quad and triangle lists are split correctly.
             *
             * Strips, loops, and fans won't work. */
            short_count = MIN2(count, 65532);
            r300_emit_draw_arrays(r300, info->mode, short_count);

            start += short_count;
            count -= short_count;

            /* 9 spare dwords for emit_draw_arrays. Give up if the function fails. */
            if (count) {
                if (!r300_prepare_for_rendering(r300,
                                                PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS, NULL, 9,
                                                start, 0, instance_id))
                    return;
            }
        } while (count);
    }
}

static void r300_draw_arrays_instanced(struct r300_context *r300,
                                       const struct pipe_draw_info *info)
{
    int i;

    for (i = 0; i < info->instance_count; i++)
        r300_draw_arrays(r300, info, i);
}

static void r300_draw_elements_instanced(struct r300_context *r300,
                                         const struct pipe_draw_info *info)
{
    int i;

    for (i = 0; i < info->instance_count; i++)
        r300_draw_elements(r300, info, i);
}

static unsigned r300_max_vertex_count(struct r300_context *r300)
{
   unsigned i, nr = r300->velems->count;
   struct pipe_vertex_element *velems = r300->velems->velem;
   unsigned result = ~0;

   for (i = 0; i < nr; i++) {
      struct pipe_vertex_buffer *vb =
            &r300->vertex_buffer[velems[i].vertex_buffer_index];
      unsigned size, max_count, value;

      /* We're not interested in constant and per-instance attribs. */
      if (!vb->buffer ||
          !vb->stride ||
          velems[i].instance_divisor) {
         continue;
      }

      size = vb->buffer->width0;

      /* Subtract buffer_offset. */
      value = vb->buffer_offset;
      if (value >= size) {
         return 0;
      }
      size -= value;

      /* Subtract src_offset. */
      value = velems[i].src_offset;
      if (value >= size) {
         return 0;
      }
      size -= value;

      /* Subtract format_size. */
      value = r300->velems->format_size[i];
      if (value >= size) {
         return 0;
      }
      size -= value;

      /* Compute the max count. */
      max_count = 1 + size / vb->stride;
      result = MIN2(result, max_count);
   }
   return result;
}


static void r300_draw_vbo(struct pipe_context* pipe,
                          const struct pipe_draw_info *dinfo)
{
    struct r300_context* r300 = r300_context(pipe);
    struct pipe_draw_info info = *dinfo;

    info.indexed = info.indexed;

    if (r300->skip_rendering ||
        !u_trim_pipe_prim(info.mode, &info.count)) {
        return;
    }

    r300_update_derived_state(r300);

    /* Draw. */
    if (info.indexed) {
        unsigned max_count = r300_max_vertex_count(r300);

        if (!max_count) {
           fprintf(stderr, "r300: Skipping a draw command. There is a buffer "
                   " which is too small to be used for rendering.\n");
           return;
        }

        if (max_count == ~0) {
           /* There are no per-vertex vertex elements. Use the hardware maximum. */
           max_count = 0xffffff;
        }

        info.max_index = max_count - 1;
        info.start += r300->index_buffer.offset / r300->index_buffer.index_size;

        if (info.instance_count <= 1) {
            if (info.count <= 8 &&
                r300->index_buffer.user_buffer) {
                r300_draw_elements_immediate(r300, &info);
            } else {
                r300_draw_elements(r300, &info, -1);
            }
        } else {
            r300_draw_elements_instanced(r300, &info);
        }
    } else {
        if (info.instance_count <= 1) {
            if (immd_is_good_idea(r300, info.count)) {
                r300_draw_arrays_immediate(r300, &info);
            } else {
                r300_draw_arrays(r300, &info, -1);
            }
        } else {
            r300_draw_arrays_instanced(r300, &info);
        }
    }
}

/****************************************************************************
 * The rest of this file is for SW TCL rendering only. Please be polite and *
 * keep these functions separated so that they are easier to locate. ~C.    *
 ***************************************************************************/

/* SW TCL elements, using Draw. */
static void r300_swtcl_draw_vbo(struct pipe_context* pipe,
                                const struct pipe_draw_info *info)
{
    struct r300_context* r300 = r300_context(pipe);

    if (r300->skip_rendering) {
        return;
    }

    r300_update_derived_state(r300);

    draw_vbo(r300->draw, info);
    draw_flush(r300->draw);
}

/* Object for rendering using Draw. */
struct r300_render {
    /* Parent class */
    struct vbuf_render base;

    /* Pipe context */
    struct r300_context* r300;

    /* Vertex information */
    size_t vertex_size;
    unsigned prim;
    unsigned hwprim;

    /* VBO */
    size_t vbo_max_used;
    uint8_t *vbo_ptr;
};

static INLINE struct r300_render*
r300_render(struct vbuf_render* render)
{
    return (struct r300_render*)render;
}

static const struct vertex_info*
r300_render_get_vertex_info(struct vbuf_render* render)
{
    struct r300_render* r300render = r300_render(render);
    struct r300_context* r300 = r300render->r300;

    return &r300->vertex_info;
}

static boolean r300_render_allocate_vertices(struct vbuf_render* render,
                                             ushort vertex_size,
                                             ushort count)
{
    struct r300_render* r300render = r300_render(render);
    struct r300_context* r300 = r300render->r300;
    struct radeon_winsys *rws = r300->rws;
    size_t size = (size_t)vertex_size * (size_t)count;

    DBG(r300, DBG_DRAW, "r300: render_allocate_vertices (size: %d)\n", size);

    if (!r300->vbo || size + r300->draw_vbo_offset > r300->vbo->size) {
	pb_reference(&r300->vbo, NULL);
        r300->vbo_cs = NULL;
        r300render->vbo_ptr = NULL;

        r300->vbo = rws->buffer_create(rws,
                                       MAX2(R300_MAX_DRAW_VBO_SIZE, size),
                                       R300_BUFFER_ALIGNMENT, TRUE,
                                       RADEON_DOMAIN_GTT);
        if (!r300->vbo) {
            return FALSE;
        }
        r300->vbo_cs = rws->buffer_get_cs_handle(r300->vbo);
        r300->draw_vbo_offset = 0;
        r300render->vbo_ptr = rws->buffer_map(r300->vbo_cs, r300->cs,
                                              PIPE_TRANSFER_WRITE);
    }

    r300render->vertex_size = vertex_size;
    return TRUE;
}

static void* r300_render_map_vertices(struct vbuf_render* render)
{
    struct r300_render* r300render = r300_render(render);
    struct r300_context* r300 = r300render->r300;

    DBG(r300, DBG_DRAW, "r300: render_map_vertices\n");

    assert(r300render->vbo_ptr);
    return r300render->vbo_ptr + r300->draw_vbo_offset;
}

static void r300_render_unmap_vertices(struct vbuf_render* render,
                                             ushort min,
                                             ushort max)
{
    struct r300_render* r300render = r300_render(render);
    struct r300_context* r300 = r300render->r300;

    DBG(r300, DBG_DRAW, "r300: render_unmap_vertices\n");

    r300render->vbo_max_used = MAX2(r300render->vbo_max_used,
                                    r300render->vertex_size * (max + 1));
}

static void r300_render_release_vertices(struct vbuf_render* render)
{
    struct r300_render* r300render = r300_render(render);
    struct r300_context* r300 = r300render->r300;

    DBG(r300, DBG_DRAW, "r300: render_release_vertices\n");

    r300->draw_vbo_offset += r300render->vbo_max_used;
    r300render->vbo_max_used = 0;
}

static void r300_render_set_primitive(struct vbuf_render* render,
                                      unsigned prim)
{
    struct r300_render* r300render = r300_render(render);

    r300render->prim = prim;
    r300render->hwprim = r300_translate_primitive(prim);
}

static void r300_render_draw_arrays(struct vbuf_render* render,
                                    unsigned start,
                                    unsigned count)
{
    struct r300_render* r300render = r300_render(render);
    struct r300_context* r300 = r300render->r300;
    uint8_t* ptr;
    unsigned i;
    unsigned dwords = 6;

    CS_LOCALS(r300);
    (void) i; (void) ptr;

    assert(start == 0);
    assert(count < (1 << 16));

    DBG(r300, DBG_DRAW, "r300: render_draw_arrays (count: %d)\n", count);

    if (!r300_prepare_for_rendering(r300,
                                    PREP_EMIT_STATES | PREP_EMIT_VARRAYS_SWTCL,
                                    NULL, dwords, 0, 0, -1)) {
        return;
    }

    BEGIN_CS(dwords);
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
            r300_provoking_vertex_fixes(r300, r300render->prim));
    OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, count - 1);
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_VBUF_2, 0);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_LIST | (count << 16) |
           r300render->hwprim);
    END_CS;
}

static void r300_render_draw_elements(struct vbuf_render* render,
                                      const ushort* indices,
                                      uint count)
{
    struct r300_render* r300render = r300_render(render);
    struct r300_context* r300 = r300render->r300;
    unsigned max_index = (r300->vbo->size - r300->draw_vbo_offset) /
                         (r300render->r300->vertex_info.size * 4) - 1;
    struct pipe_resource *index_buffer = NULL;
    unsigned index_buffer_offset;

    CS_LOCALS(r300);
    DBG(r300, DBG_DRAW, "r300: render_draw_elements (count: %d)\n", count);

    u_upload_data(r300->uploader, 0, count * 2, indices,
                  &index_buffer_offset, &index_buffer);
    if (!index_buffer) {
        return;
    }

    if (!r300_prepare_for_rendering(r300,
                                    PREP_EMIT_STATES |
                                    PREP_EMIT_VARRAYS_SWTCL | PREP_INDEXED,
                                    index_buffer, 12, 0, 0, -1)) {
        pipe_resource_reference(&index_buffer, NULL);
        return;
    }

    BEGIN_CS(12);
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
               r300_provoking_vertex_fixes(r300, r300render->prim));
    OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, max_index);

    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, 0);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (count << 16) |
           r300render->hwprim);

    OUT_CS_PKT3(R300_PACKET3_INDX_BUFFER, 2);
    OUT_CS(R300_INDX_BUFFER_ONE_REG_WR | (R300_VAP_PORT_IDX0 >> 2));
    OUT_CS(index_buffer_offset);
    OUT_CS((count + 1) / 2);
    OUT_CS_RELOC(r300_resource(index_buffer));
    END_CS;

    pipe_resource_reference(&index_buffer, NULL);
}

static void r300_render_destroy(struct vbuf_render* render)
{
    FREE(render);
}

static struct vbuf_render* r300_render_create(struct r300_context* r300)
{
    struct r300_render* r300render = CALLOC_STRUCT(r300_render);

    r300render->r300 = r300;

    r300render->base.max_vertex_buffer_bytes = R300_MAX_DRAW_VBO_SIZE;
    r300render->base.max_indices = 16 * 1024;

    r300render->base.get_vertex_info = r300_render_get_vertex_info;
    r300render->base.allocate_vertices = r300_render_allocate_vertices;
    r300render->base.map_vertices = r300_render_map_vertices;
    r300render->base.unmap_vertices = r300_render_unmap_vertices;
    r300render->base.set_primitive = r300_render_set_primitive;
    r300render->base.draw_elements = r300_render_draw_elements;
    r300render->base.draw_arrays = r300_render_draw_arrays;
    r300render->base.release_vertices = r300_render_release_vertices;
    r300render->base.destroy = r300_render_destroy;

    return &r300render->base;
}

struct draw_stage* r300_draw_stage(struct r300_context* r300)
{
    struct vbuf_render* render;
    struct draw_stage* stage;

    render = r300_render_create(r300);

    if (!render) {
        return NULL;
    }

    stage = draw_vbuf_stage(r300->draw, render);

    if (!stage) {
        render->destroy(render);
        return NULL;
    }

    draw_set_render(r300->draw, render);

    return stage;
}

/****************************************************************************
 *                         End of SW TCL functions                          *
 ***************************************************************************/

/* This functions is used to draw a rectangle for the blitter module.
 *
 * If we rendered a quad, the pixels on the main diagonal
 * would be computed and stored twice, which makes the clear/copy codepaths
 * somewhat inefficient. Instead we use a rectangular point sprite. */
void r300_blitter_draw_rectangle(struct blitter_context *blitter,
                                 int x1, int y1, int x2, int y2,
                                 float depth,
                                 enum blitter_attrib_type type,
                                 const union pipe_color_union *attrib)
{
    struct r300_context *r300 = r300_context(util_blitter_get_pipe(blitter));
    unsigned last_sprite_coord_enable = r300->sprite_coord_enable;
    unsigned width = x2 - x1;
    unsigned height = y2 - y1;
    unsigned vertex_size =
            type == UTIL_BLITTER_ATTRIB_COLOR || !r300->draw ? 8 : 4;
    unsigned dwords = 13 + vertex_size +
                      (type == UTIL_BLITTER_ATTRIB_TEXCOORD ? 7 : 0);
    static const union pipe_color_union zeros;
    CS_LOCALS(r300);

    /* XXX workaround for a lockup in MSAA resolve on SWTCL chipsets, this
     * function most probably doesn't handle type=NONE correctly */
    if (!r300->screen->caps.has_tcl && type == UTIL_BLITTER_ATTRIB_NONE) {
        util_blitter_draw_rectangle(blitter, x1, y1, x2, y2, depth, type, attrib);
        return;
    }

    if (r300->skip_rendering)
        return;

    if (type == UTIL_BLITTER_ATTRIB_TEXCOORD)
        r300->sprite_coord_enable = 1;

    r300_update_derived_state(r300);

    /* Mark some states we don't care about as non-dirty. */
    r300->viewport_state.dirty = FALSE;

    if (!r300_prepare_for_rendering(r300, PREP_EMIT_STATES, NULL, dwords, 0, 0, -1))
        goto done;

    DBG(r300, DBG_DRAW, "r300: draw_rectangle\n");

    BEGIN_CS(dwords);
    /* Set up GA. */
    OUT_CS_REG(R300_GA_POINT_SIZE, (height * 6) | ((width * 6) << 16));

    if (type == UTIL_BLITTER_ATTRIB_TEXCOORD) {
        /* Set up the GA to generate texcoords. */
        OUT_CS_REG(R300_GB_ENABLE, R300_GB_POINT_STUFF_ENABLE |
                   (R300_GB_TEX_STR << R300_GB_TEX0_SOURCE_SHIFT));
        OUT_CS_REG_SEQ(R300_GA_POINT_S0, 4);
        OUT_CS_32F(attrib->f[0]);
        OUT_CS_32F(attrib->f[3]);
        OUT_CS_32F(attrib->f[2]);
        OUT_CS_32F(attrib->f[1]);
    }

    /* Set up VAP controls. */
    OUT_CS_REG(R300_VAP_CLIP_CNTL, R300_CLIP_DISABLE);
    OUT_CS_REG(R300_VAP_VTE_CNTL, R300_VTX_XY_FMT | R300_VTX_Z_FMT);
    OUT_CS_REG(R300_VAP_VTX_SIZE, vertex_size);
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(1);
    OUT_CS(0);

    /* Draw. */
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_IMMD_2, vertex_size);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_EMBEDDED | (1 << 16) |
           R300_VAP_VF_CNTL__PRIM_POINTS);

    OUT_CS_32F(x1 + width * 0.5f);
    OUT_CS_32F(y1 + height * 0.5f);
    OUT_CS_32F(depth);
    OUT_CS_32F(1);

    if (vertex_size == 8) {
        if (!attrib)
            attrib = &zeros;
        OUT_CS_TABLE(attrib->f, 4);
    }
    END_CS;

done:
    /* Restore the state. */
    r300_mark_atom_dirty(r300, &r300->rs_state);
    r300_mark_atom_dirty(r300, &r300->viewport_state);

    r300->sprite_coord_enable = last_sprite_coord_enable;
}

void r300_init_render_functions(struct r300_context *r300)
{
    /* Set draw functions based on presence of HW TCL. */
    if (r300->screen->caps.has_tcl) {
        r300->context.draw_vbo = r300_draw_vbo;
    } else {
        r300->context.draw_vbo = r300_swtcl_draw_vbo;
    }

    /* Plug in the two-sided stencil reference value fallback if needed. */
    if (!r300->screen->caps.is_r500)
        r300_plug_in_stencil_ref_fallback(r300);
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d787 2
d910 1
a910 1
                                       RADEON_DOMAIN_GTT, 0);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@a786 2
    info.indexed = info.indexed;

d908 1
a908 1
                                       RADEON_DOMAIN_GTT);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d127 1
a127 1
                                unsigned min_index, unsigned max_index)
d131 2
d138 1
a138 1
    OUT_CS(min_index);
d151 1
a151 1
    struct pipe_vertex_buffer *vb, *vbufs = r300->vbuf_mgr->real_vertex_buffer;
a317 6
    struct pipe_vertex_element* velem;
    struct pipe_resource *buf;
    boolean checked[PIPE_MAX_ATTRIBS] = {0};
    unsigned vertex_element_count = r300->velems->count;
    unsigned i, vbi;

a321 4
    if (r300->draw) {
        return FALSE;
    }

d326 2
a327 16
    /* We shouldn't map buffers referenced by CS, busy buffers,
     * and ones placed in VRAM. */
    for (i = 0; i < vertex_element_count; i++) {
        velem = &r300->velems->velem[i];
        vbi = velem->vertex_buffer_index;

        if (!checked[vbi]) {
            buf = r300->vbuf_mgr->real_vertex_buffer[vbi].buffer;

            if ((r300_resource(buf)->domain != RADEON_DOMAIN_GTT)) {
                return FALSE;
            }

            checked[vbi] = TRUE;
        }
    }
d370 1
a370 1
        vbuf = &r300->vbuf_mgr->real_vertex_buffer[vbi];
d376 1
a376 1
                r300_resource(vbuf->buffer)->buf,
d383 1
a383 1
    r300_emit_draw_init(r300, info->mode, 0, info->count-1);
a397 10

    /* Unmap buffers. */
    for (i = 0; i < vertex_element_count; i++) {
        vbi = r300->velems->velem[i].vertex_buffer_index;

        if (map[vbi]) {
            r300->rws->buffer_unmap(r300_resource(r300->vbuf_mgr->real_vertex_buffer[vbi].buffer)->buf);
            map[vbi] = NULL;
        }
    }
d413 1
a413 1
    r300_emit_draw_init(r300, mode, 0, count-1);
a428 1
                                    unsigned min_index,
d439 1
a439 1
    if (count >= (1 << 24) || max_index >= (1 << 24)) {
d445 2
a446 2
    DBG(r300, DBG_DRAW, "r300: Indexbuf of %u indices, min %u max %u\n",
        count, min_index, max_index);
d448 1
a448 1
    r300_emit_draw_init(r300, mode, min_index, max_index);
d501 3
a503 3
    uint8_t *ptr1;
    uint16_t *ptr2;
    uint32_t *ptr4;
d515 1
a515 1
    r300_emit_draw_init(r300, info->mode, info->min_index, info->max_index);
d522 1
a522 1
        ptr1 = r300_resource(r300->index_buffer.buffer)->b.user_ptr;
d546 1
a546 1
        ptr2 = (uint16_t*)r300_resource(r300->index_buffer.buffer)->b.user_ptr;
d565 1
a565 1
        ptr4 = (uint32_t*)r300_resource(r300->index_buffer.buffer)->b.user_ptr;
d599 2
a600 1
        r300_split_index_bias(r300, info->index_bias, &buffer_offset, &index_offset);
d603 2
a604 2
    r300_translate_index_buffer(r300, &indexBuffer, &indexSize, index_offset,
                                &start, count);
d607 1
a607 2
    if (indexSize == 2 && (start & 1) &&
        !r300_resource(indexBuffer)->b.user_ptr) {
d609 1
a609 1
        uint16_t *ptr = r300->rws->buffer_map(r300_resource(orgIndexBuffer)->buf,
a622 1
        r300->rws->buffer_unmap(r300_resource(orgIndexBuffer)->buf);
d624 1
a624 1
        if (r300_resource(indexBuffer)->b.user_ptr)
d627 1
a627 1
                                     r300_resource(indexBuffer)->b.user_ptr);
d638 1
a638 1
        r300_emit_draw_elements(r300, indexBuffer, indexSize, info->min_index,
d650 1
a650 1
                                     info->min_index, info->max_index,
d732 49
d787 1
a787 1
    info.indexed = info.indexed && r300->index_buffer.buffer;
a795 5
    /* Start the vbuf manager and update buffers if needed. */
    if (u_vbuf_draw_begin(r300->vbuf_mgr, &info) & U_VBUF_BUFFERS_UPDATED) {
        r300->vertex_arrays_dirty = TRUE;
    }

d798 15
a812 2
        info.start += r300->index_buffer.offset;
        info.max_index = MIN2(r300->vbuf_mgr->max_index, info.max_index);
d816 1
a816 1
                r300_resource(r300->index_buffer.buffer)->b.user_ptr) {
a834 2

    u_vbuf_draw_end(r300->vbuf_mgr);
a846 5
    struct pipe_transfer *vb_transfer[PIPE_MAX_ATTRIBS];
    struct pipe_transfer *ib_transfer = NULL;
    int i;
    void *indices = NULL;
    boolean indexed = info->indexed && r300->index_buffer.buffer;
a853 26
    r300_reserve_cs_dwords(r300,
            PREP_EMIT_STATES | PREP_EMIT_VARRAYS_SWTCL |
            (indexed ? PREP_INDEXED : 0),
            indexed ? 256 : 6);

    for (i = 0; i < r300->vbuf_mgr->nr_vertex_buffers; i++) {
        if (r300->vbuf_mgr->vertex_buffer[i].buffer) {
            void *buf = pipe_buffer_map(pipe,
                                  r300->vbuf_mgr->vertex_buffer[i].buffer,
                                  PIPE_TRANSFER_READ |
                                  PIPE_TRANSFER_UNSYNCHRONIZED,
                                  &vb_transfer[i]);
            draw_set_mapped_vertex_buffer(r300->draw, i, buf);
        }
    }

    if (indexed) {
        indices = pipe_buffer_map(pipe, r300->index_buffer.buffer,
                                  PIPE_TRANSFER_READ |
                                  PIPE_TRANSFER_UNSYNCHRONIZED, &ib_transfer);
    }

    draw_set_mapped_index_buffer(r300->draw, indices);

    r300->draw_vbo_locked = TRUE;
    r300->draw_first_emitted = FALSE;
a855 13
    r300->draw_vbo_locked = FALSE;

    for (i = 0; i < r300->vbuf_mgr->nr_vertex_buffers; i++) {
        if (r300->vbuf_mgr->vertex_buffer[i].buffer) {
            pipe_buffer_unmap(pipe, vb_transfer[i]);
            draw_set_mapped_vertex_buffer(r300->draw, i, NULL);
        }
    }

    if (indexed) {
        pipe_buffer_unmap(pipe, ib_transfer);
        draw_set_mapped_index_buffer(r300->draw, NULL);
    }
d873 1
a873 3
    void * vbo_ptr;

    struct pipe_transfer *vbo_transfer;
d892 2
a893 2
                                                   ushort vertex_size,
                                                   ushort count)
d897 1
a897 1
    struct pipe_screen* screen = r300->context.screen;
d902 13
a914 7
    if (size + r300->draw_vbo_offset > r300->draw_vbo_size)
    {
	pipe_resource_reference(&r300->vbo, NULL);
        r300->vbo = pipe_buffer_create(screen,
				       PIPE_BIND_VERTEX_BUFFER,
				       PIPE_USAGE_STREAM,
				       R300_MAX_DRAW_VBO_SIZE);
d916 2
a917 1
        r300->draw_vbo_size = R300_MAX_DRAW_VBO_SIZE;
d921 1
a921 2

    return (r300->vbo) ? TRUE : FALSE;
a928 2
    assert(!r300render->vbo_transfer);

a930 6
    r300render->vbo_ptr = pipe_buffer_map(&r300render->r300->context,
					  r300->vbo,
                                          PIPE_TRANSFER_WRITE |
                                          PIPE_TRANSFER_UNSYNCHRONIZED,
					  &r300render->vbo_transfer);

d932 1
a932 2

    return ((uint8_t*)r300render->vbo_ptr + r300->draw_vbo_offset);
a939 1
    struct pipe_context* context = &r300render->r300->context;
a941 2
    assert(r300render->vbo_transfer);

a945 3
    pipe_buffer_unmap(context, r300render->vbo_transfer);

    r300render->vbo_transfer = NULL;
d959 2
a960 2
static boolean r300_render_set_primitive(struct vbuf_render* render,
                                               unsigned prim)
a965 2

    return TRUE;
d981 3
d986 4
a989 10
    if (r300->draw_first_emitted) {
        if (!r300_prepare_for_rendering(r300,
                PREP_EMIT_STATES | PREP_EMIT_VARRAYS_SWTCL,
                NULL, dwords, 0, 0, -1))
            return;
    } else {
        if (!r300_emit_states(r300,
                PREP_EMIT_STATES | PREP_EMIT_VARRAYS_SWTCL,
                NULL, 0, 0, -1))
            return;
a999 2

    r300->draw_first_emitted = TRUE;
d1008 1
a1008 3
    int i;
    unsigned end_cs_dwords;
    unsigned max_index = (r300->draw_vbo_size - r300->draw_vbo_offset) /
d1010 2
a1011 2
    unsigned short_count;
    unsigned free_dwords;
d1016 18
a1033 36
    if (r300->draw_first_emitted) {
        if (!r300_prepare_for_rendering(r300,
                PREP_EMIT_STATES | PREP_EMIT_VARRAYS_SWTCL | PREP_INDEXED,
                NULL, 256, 0, 0, -1))
            return;
    } else {
        if (!r300_emit_states(r300,
                PREP_EMIT_STATES | PREP_EMIT_VARRAYS_SWTCL | PREP_INDEXED,
                NULL, 0, 0, -1))
            return;
    }

    /* Below we manage the CS space manually because there may be more
     * indices than it can fit in CS. */

    end_cs_dwords = r300_get_num_cs_end_dwords(r300);

    while (count) {
        free_dwords = RADEON_MAX_CMDBUF_DWORDS - r300->cs->cdw;

        short_count = MIN2(count, (free_dwords - end_cs_dwords - 6) * 2);

        BEGIN_CS(6 + (short_count+1)/2);
        OUT_CS_REG(R300_GA_COLOR_CONTROL,
                r300_provoking_vertex_fixes(r300, r300render->prim));
        OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, max_index);
        OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, (short_count+1)/2);
        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (short_count << 16) |
               r300render->hwprim);
        for (i = 0; i < short_count-1; i += 2) {
            OUT_CS(indices[i+1] << 16 | indices[i]);
        }
        if (short_count % 2) {
            OUT_CS(indices[short_count-1]);
        }
        END_CS;
d1035 3
a1037 10
        /* OK now subtract the emitted indices and see if we need to emit
         * another draw packet. */
        indices += short_count;
        count -= short_count;

        if (count) {
            if (!r300_prepare_for_rendering(r300,
                    PREP_EMIT_VARRAYS_SWTCL | PREP_INDEXED,
                    NULL, 256, 0, 0, -1))
                return;
d1039 6
a1044 3
            end_cs_dwords = r300_get_num_cs_end_dwords(r300);
        }
    }
d1046 1
a1046 1
    r300->draw_first_emitted = TRUE;
d1060 1
a1060 1
    r300render->base.max_vertex_buffer_bytes = 1024 * 1024;
a1098 6
void r300_draw_flush_vbuf(struct r300_context *r300)
{
    pipe_resource_reference(&r300->vbo, NULL);
    r300->draw_vbo_size = 0;
}

d1108 5
a1112 6
static void r300_blitter_draw_rectangle(struct blitter_context *blitter,
                                        unsigned x1, unsigned y1,
                                        unsigned x2, unsigned y2,
                                        float depth,
                                        enum blitter_attrib_type type,
                                        const float attrib[4])
d1122 1
a1122 1
    const float zeros[4] = {0, 0, 0, 0};
d1125 7
a1134 2
    r300->context.set_vertex_buffers(&r300->context, 0, NULL);

a1140 1
    r300->clip_state.dirty = FALSE;
d1157 4
a1160 4
        OUT_CS_32F(attrib[0]);
        OUT_CS_32F(attrib[3]);
        OUT_CS_32F(attrib[2]);
        OUT_CS_32F(attrib[1]);
d1183 2
a1184 2
            attrib = zeros;
        OUT_CS_TABLE(attrib, 4);
a1189 1
    r300_mark_atom_dirty(r300, &r300->clip_state);
a1195 46
static void r300_resource_resolve(struct pipe_context* pipe,
                                  struct pipe_resource* dest,
                                  unsigned dst_layer,
                                  struct pipe_resource* src,
                                  unsigned src_layer)
{
    struct r300_context* r300 = r300_context(pipe);
    struct pipe_surface* srcsurf, surf_tmpl;
    struct r300_aa_state *aa = (struct r300_aa_state*)r300->aa_state.state;
    float color[] = {0, 0, 0, 0};

    memset(&surf_tmpl, 0, sizeof(surf_tmpl));
    surf_tmpl.format = src->format;
    surf_tmpl.usage = 0; /* not really a surface hence no bind flags */
    surf_tmpl.u.tex.level = 0; /* msaa resources cannot have mipmaps */
    surf_tmpl.u.tex.first_layer = src_layer;
    surf_tmpl.u.tex.last_layer = src_layer;
    srcsurf = pipe->create_surface(pipe, src, &surf_tmpl);
    surf_tmpl.format = dest->format;
    surf_tmpl.u.tex.first_layer = dst_layer;
    surf_tmpl.u.tex.last_layer = dst_layer;

    DBG(r300, DBG_DRAW, "r300: Resolving resource...\n");

    /* Enable AA resolve. */
    aa->dest = r300_surface(pipe->create_surface(pipe, dest, &surf_tmpl));

    aa->aaresolve_ctl =
        R300_RB3D_AARESOLVE_CTL_AARESOLVE_MODE_RESOLVE |
        R300_RB3D_AARESOLVE_CTL_AARESOLVE_ALPHA_AVERAGE;
    r300->aa_state.size = 10;
    r300_mark_atom_dirty(r300, &r300->aa_state);

    /* Resolve the surface. */
    r300->context.clear_render_target(pipe,
        srcsurf, color, 0, 0, src->width0, src->height0);

    /* Disable AA resolve. */
    aa->aaresolve_ctl = 0;
    r300->aa_state.size = 4;
    r300_mark_atom_dirty(r300, &r300->aa_state);

    pipe_surface_reference((struct pipe_surface**)&srcsurf, NULL);
    pipe_surface_reference((struct pipe_surface**)&aa->dest, NULL);
}

a1203 3

    r300->context.resource_resolve = r300_resource_resolve;
    r300->blitter->draw_rectangle = r300_blitter_draw_rectangle;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a41 1
#include "r300_state_derived.h"
d49 20
a68 24
    switch (prim) {
        case PIPE_PRIM_POINTS:
            return R300_VAP_VF_CNTL__PRIM_POINTS;
        case PIPE_PRIM_LINES:
            return R300_VAP_VF_CNTL__PRIM_LINES;
        case PIPE_PRIM_LINE_LOOP:
            return R300_VAP_VF_CNTL__PRIM_LINE_LOOP;
        case PIPE_PRIM_LINE_STRIP:
            return R300_VAP_VF_CNTL__PRIM_LINE_STRIP;
        case PIPE_PRIM_TRIANGLES:
            return R300_VAP_VF_CNTL__PRIM_TRIANGLES;
        case PIPE_PRIM_TRIANGLE_STRIP:
            return R300_VAP_VF_CNTL__PRIM_TRIANGLE_STRIP;
        case PIPE_PRIM_TRIANGLE_FAN:
            return R300_VAP_VF_CNTL__PRIM_TRIANGLE_FAN;
        case PIPE_PRIM_QUADS:
            return R300_VAP_VF_CNTL__PRIM_QUADS;
        case PIPE_PRIM_QUAD_STRIP:
            return R300_VAP_VF_CNTL__PRIM_QUAD_STRIP;
        case PIPE_PRIM_POLYGON:
            return R300_VAP_VF_CNTL__PRIM_POLYGON;
        default:
            return 0;
    }
d126 14
d142 1
a142 1
 *   in r300_emit_aos (it must yield a positive offset when added to
d149 1
a149 1
    struct pipe_vertex_buffer *vb, *vbufs = r300->vertex_buffer;
d176 1
a176 1
    PREP_FIRST_DRAW     = (1 << 0), /* call emit_dirty_state and friends? */
d178 2
a179 2
    PREP_EMIT_AOS       = (1 << 2), /* call emit_aos? */
    PREP_EMIT_AOS_SWTCL = (1 << 3), /* call emit_aos_swtcl? */
d192 2
a193 2
                                   enum r300_prepare_flags flags,
                                   unsigned cs_dwords)
d196 3
a198 3
    boolean emit_states    = flags & PREP_FIRST_DRAW;
    boolean emit_vertex_arrays       = flags & PREP_EMIT_AOS;
    boolean emit_vertex_arrays_swtcl = flags & PREP_EMIT_AOS_SWTCL;
d204 1
a204 1
    if (r300->screen->caps.index_bias_supported)
d216 2
a217 2
    if (cs_dwords > (R300_MAX_CMDBUF_DWORDS - r300->cs->cdw)) {
        r300->context.flush(&r300->context, 0, NULL);
d229 1
a229 1
 * \param aos_offset    The offset passed to emit_aos.
d231 1
d237 2
a238 2
                                int aos_offset,
                                int index_bias)
d240 3
a242 3
    boolean emit_states    = flags & PREP_FIRST_DRAW;
    boolean emit_vertex_arrays       = flags & PREP_EMIT_AOS;
    boolean emit_vertex_arrays_swtcl = flags & PREP_EMIT_AOS_SWTCL;
d246 7
a252 19
    if (emit_states) {
        /* upload buffers first */
        if (r300->screen->caps.has_tcl && r300->any_user_vbs) {
            r300_upload_user_buffers(r300);
            r300->any_user_vbs = false;
        }

        if (r300->validate_buffers) {
            if (!r300_emit_buffer_validate(r300, validate_vbos,
                                           index_buffer)) {
                fprintf(stderr, "r300: CS space validation failed. "
                        "(not enough memory?) Skipping rendering.\n");
                return FALSE;
            }

            /* Consider the validation done only if everything was validated. */
            if (validate_vbos) {
                r300->validate_buffers = FALSE;
            }
d254 1
d256 1
a257 1
    }
d259 1
a259 1
    if (r300->screen->caps.index_bias_supported) {
d266 12
a277 2
    if (emit_vertex_arrays)
        r300_emit_aos(r300, aos_offset, indexed);
d280 1
a280 1
        r300_emit_aos_swtcl(r300, indexed);
d292 1
a292 1
 * \param aos_offset    The offset passed to emit_aos.
d294 1
d301 3
a303 2
                                          int aos_offset,
                                          int index_bias)
d305 1
d307 1
a307 1
        flags |= PREP_FIRST_DRAW;
d309 2
a310 1
    return r300_emit_states(r300, flags, index_buffer, aos_offset, index_bias);
d317 1
a317 1
    struct pipe_vertex_buffer* vbuf;
d341 1
a341 1
            vbuf = &r300->vertex_buffer[vbi];
d343 1
a343 1
            if (!(r300_buffer(vbuf->buffer)->domain & R300_DOMAIN_GTT)) {
a346 6
            if (r300_buffer_is_referenced(&r300->context,
                                          vbuf->buffer,
                                          R300_REF_CS | R300_REF_HW)) {
                /* It's a very bad idea to map it... */
                return FALSE;
            }
d357 2
a358 4
static void r300_emit_draw_arrays_immediate(struct r300_context *r300,
                                            unsigned mode,
                                            unsigned start,
                                            unsigned count)
d369 1
a369 1
    unsigned dwords = 9 + count * vertex_size;
d379 1
a379 1
    uint32_t* map[PIPE_MAX_ATTRIBS];
a380 1
    struct pipe_transfer* transfer[PIPE_MAX_ATTRIBS] = {0};
d384 1
a384 1
    if (!r300_prepare_for_rendering(r300, PREP_FIRST_DRAW, NULL, dwords, 0, 0))
d390 1
a390 1
        size[i] = r300->velems->hw_format_size[i] / 4;
d392 1
a392 1
        vbuf = &r300->vertex_buffer[vbi];
d396 5
a400 6
        if (!transfer[vbi]) {
            map[vbi] = (uint32_t*)pipe_buffer_map(&r300->context,
                                                  vbuf->buffer,
                                                  PIPE_TRANSFER_READ,
						  &transfer[vbi]);
            map[vbi] += (vbuf->buffer_offset / 4) + stride[i] * start;
d405 2
a407 2
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
            r300_provoking_vertex_fixes(r300, mode));
d409 3
a411 6
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(count - 1);
    OUT_CS(0);
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_IMMD_2, count * vertex_size);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_EMBEDDED | (count << 16) |
            r300_translate_primitive(mode));
d414 1
a414 1
    for (v = 0; v < count; v++) {
d425 3
a427 4
        if (transfer[vbi]) {
            vbuf = &r300->vertex_buffer[vbi];
            pipe_buffer_unmap(&r300->context, vbuf->buffer, transfer[vbi]);
            transfer[vbi] = NULL;
d445 3
a447 1
    BEGIN_CS(7 + (alt_num_verts ? 2 : 0));
a450 5
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
            r300_provoking_vertex_fixes(r300, mode));
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(count - 1);
    OUT_CS(0);
d461 2
a462 2
                                    unsigned minIndex,
                                    unsigned maxIndex,
d465 2
a466 1
                                    unsigned count)
d468 1
a468 2
    uint32_t count_dwords;
    uint32_t offset_dwords = indexSize * start / sizeof(uint32_t);
d472 1
a472 1
    if (count >= (1 << 24)) {
d474 1
a474 1
                "refusing to render.\n", count);
d478 23
a500 1
    maxIndex = MIN2(maxIndex, r300->vertex_buffer_max_index);
d502 1
a502 2
    DBG(r300, DBG_DRAW, "r300: Indexbuf of %u indices, min %u max %u\n",
        count, minIndex, maxIndex);
d504 1
a504 1
    BEGIN_CS(13 + (alt_num_verts ? 2 : 0));
a507 5
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
            r300_provoking_vertex_fixes(r300, mode));
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(maxIndex);
    OUT_CS(minIndex);
a521 5
    /* INDX_BUFFER is a truly special packet3.
     * Unlike most other packet3, where the offset is after the count,
     * the order is reversed, so the relocation ends up carrying the
     * size of the indexbuf instead of the offset.
     */
d526 4
a529 2
    OUT_CS_BUF_RELOC(indexBuffer, count_dwords,
                     r300_buffer(indexBuffer)->domain, 0);
d531 82
d616 3
a618 10
/* This is the fast-path drawing & emission for HW TCL. */
static void r300_draw_range_elements(struct pipe_context* pipe,
                                     struct pipe_resource* indexBuffer,
                                     unsigned indexSize,
                                     int indexBias,
                                     unsigned minIndex,
                                     unsigned maxIndex,
                                     unsigned mode,
                                     unsigned start,
                                     unsigned count)
d620 2
a621 1
    struct r300_context* r300 = r300_context(pipe);
d623 2
d626 1
a626 2
                            count > 65536 &&
                            r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0);
d629 1
a629 1
    unsigned new_offset;
d631 2
a632 2
    if (indexBias && !r300->screen->caps.index_bias_supported) {
        r300_split_index_bias(r300, indexBias, &buffer_offset, &index_offset);
d638 8
a645 2
    r300_update_derived_state(r300);
    r300_upload_index_buffer(r300, &indexBuffer, indexSize, start, count, &new_offset);
d647 16
a662 1
    start = new_offset;
d664 1
a664 1
    /* 15 dwords for emit_draw_elements. Give up if the function fails. */
d666 3
a668 2
            PREP_FIRST_DRAW | PREP_VALIDATE_VBOS | PREP_EMIT_AOS |
            PREP_INDEXED, indexBuffer, 15, buffer_offset, indexBias))
d672 3
a674 2
        r300_emit_draw_elements(r300, indexBuffer, indexSize,
				minIndex, maxIndex, mode, start, count);
d684 2
a685 2
                                     minIndex, maxIndex,
                                     mode, start, short_count);
d693 3
a695 2
                        PREP_VALIDATE_VBOS | PREP_EMIT_AOS | PREP_INDEXED,
                        indexBuffer, 15, buffer_offset, indexBias))
d707 3
a709 2
static void r300_draw_arrays(struct pipe_context* pipe, unsigned mode,
                             unsigned start, unsigned count)
a710 1
    struct r300_context* r300 = r300_context(pipe);
d712 3
a714 2
                            count > 65536 &&
                            r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0);
d717 5
a721 1
    r300_update_derived_state(r300);
d723 2
a724 2
    if (immd_is_good_idea(r300, count)) {
        r300_emit_draw_arrays_immediate(r300, mode, start, count);
d726 10
a735 5
        /* 9 spare dwords for emit_draw_arrays. Give up if the function fails. */
        if (!r300_prepare_for_rendering(r300,
                PREP_FIRST_DRAW | PREP_VALIDATE_VBOS | PREP_EMIT_AOS,
                NULL, 9, start, 0))
            return;
d737 8
a744 23
        if (alt_num_verts || count <= 65535) {
            r300_emit_draw_arrays(r300, mode, count);
        } else {
            do {
                /* The maximum must be divisible by 4 and 3,
                 * so that quad and triangle lists are split correctly.
                 *
                 * Strips, loops, and fans won't work. */
                short_count = MIN2(count, 65532);
                r300_emit_draw_arrays(r300, mode, short_count);

                start += short_count;
                count -= short_count;

                /* 9 spare dwords for emit_draw_arrays. Give up if the function fails. */
                if (count) {
                    if (!r300_prepare_for_rendering(r300,
                            PREP_VALIDATE_VBOS | PREP_EMIT_AOS, NULL, 9,
                            start, 0))
                        return;
                }
            } while (count);
        }
d748 18
d767 1
a767 1
                          const struct pipe_draw_info *info)
d770 1
a770 4
    unsigned count = info->count;
    boolean translate = FALSE;
    boolean indexed = info->indexed && r300->index_buffer.buffer;
    unsigned start_indexed = 0;
d772 1
a772 3
    if (r300->skip_rendering) {
        return;
    }
d774 2
a775 1
    if (!u_trim_pipe_prim(info->mode, &count)) {
d779 1
a779 15
    /* Index buffer range checking. */
    if (indexed) {
        assert(r300->index_buffer.offset % r300->index_buffer.index_size == 0);

        /* Compute start for draw_elements, taking the offset into account. */
        start_indexed =
            info->start +
            (r300->index_buffer.offset / r300->index_buffer.index_size);

        if ((start_indexed + count) * r300->index_buffer.index_size >
            r300->index_buffer.buffer->width0) {
            fprintf(stderr, "r300: Invalid index buffer range. Skipping rendering.\n");
            return;
        }
    }
d781 3
a783 4
    /* Set up fallback for incompatible vertex layout if needed. */
    if (r300->incompatible_vb_layout || r300->velems->incompatible_layout) {
        r300_begin_vertex_translate(r300);
        translate = TRUE;
d786 15
a800 10
    if (indexed) {
        r300_draw_range_elements(pipe,
                                 r300->index_buffer.buffer,
                                 r300->index_buffer.index_size,
                                 info->index_bias,
                                 info->min_index,
                                 info->max_index,
                                 info->mode,
                                 start_indexed,
                                 count);
d802 9
a810 4
        r300_draw_arrays(pipe,
                         info->mode,
                         info->start,
                         count);
d813 1
a813 3
    if (translate) {
        r300_end_vertex_translate(r300);
    }
a827 1
    unsigned count = info->count;
a835 4
    if (!u_trim_pipe_prim(info->mode, &count)) {
        return;
    }

d839 1
a839 1
            PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL |
d843 2
a844 2
    for (i = 0; i < r300->vertex_buffer_count; i++) {
        if (r300->vertex_buffer[i].buffer) {
d846 3
a848 2
                                  r300->vertex_buffer[i].buffer,
                                  PIPE_TRANSFER_READ,
d856 2
a857 1
                                  PIPE_TRANSFER_READ, &ib_transfer);
d868 3
a870 4
    for (i = 0; i < r300->vertex_buffer_count; i++) {
        if (r300->vertex_buffer[i].buffer) {
            pipe_buffer_unmap(pipe, r300->vertex_buffer[i].buffer,
                              vb_transfer[i]);
d876 1
a876 1
        pipe_buffer_unmap(pipe, r300->index_buffer.buffer, ib_transfer);
d932 1
a935 1
        r300->validate_buffers = TRUE;
d954 2
a955 1
                                          PIPE_TRANSFER_WRITE,
d977 1
a977 1
    pipe_buffer_unmap(context, r300->vbo, r300render->vbo_transfer);
d1021 2
a1022 2
                PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL,
                NULL, 6, 0, 0))
d1026 2
a1027 2
                PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL,
                NULL, 0, 0))
a1030 17
    /* Uncomment to dump all VBOs rendered through this interface.
     * Slow and noisy!
    ptr = pipe_buffer_map(&r300render->r300->context,
                          r300render->vbo, PIPE_TRANSFER_READ,
                          &r300render->vbo_transfer);

    for (i = 0; i < count; i++) {
        printf("r300: Vertex %d\n", i);
        draw_dump_emitted_vertex(&r300->vertex_info, ptr);
        ptr += r300->vertex_info.size * 4;
        printf("\n");
    }

    pipe_buffer_unmap(&r300render->r300->context, r300render->vbo,
        r300render->vbo_transfer);
    */

d1061 2
a1062 2
                PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL | PREP_INDEXED,
                NULL, 256, 0, 0))
d1066 2
a1067 2
                PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL | PREP_INDEXED,
                NULL, 0, 0))
d1077 1
a1077 1
        free_dwords = R300_MAX_CMDBUF_DWORDS - r300->cs->cdw;
d1103 2
a1104 2
                    PREP_EMIT_AOS_SWTCL | PREP_INDEXED,
                    NULL, 256, 0, 0))
d1125 1
a1125 2
    /* XXX find real numbers plz */
    r300render->base.max_vertex_buffer_bytes = 128 * 1024;
d1211 1
a1211 1
    if (!r300_prepare_for_rendering(r300, PREP_FIRST_DRAW, NULL, dwords, 0, 0))
d1295 1
a1295 1
    r300->aa_state.size = 12;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d3 1
d34 1
d39 1
a41 1
#include "r300_render.h"
d44 1
a44 2
/* r300_render: Vertex and index buffer primitive emission. */
#define R300_MAX_VBO_SIZE  (1024 * 1024)
d46 1
a46 2
/* XXX The DRM rejects VAP_ALT_NUM_VERTICES.. */
//#define ENABLE_ALT_NUM_VERTS
d48 1
a48 1
uint32_t r300_translate_primitive(unsigned prim)
d121 1
a121 4
/* Check if the requested number of dwords is available in the CS and
 * if not, flush. Return TRUE if the flush occured. */
static boolean r300_reserve_cs_space(struct r300_context *r300,
                                     unsigned dwords)
d123 85
a207 1
    if (!r300->winsys->check_cs(r300->winsys, dwords)) {
d209 1
a209 1
        return TRUE;
d211 87
a297 1
    return FALSE;
d301 1
a301 1
                                      unsigned count)
d303 41
a343 1
    return count <= 4;
d346 4
d357 2
a358 2
    unsigned vertex_element_count = r300->vertex_element_count;
    unsigned i, v, vbi, dw, elem_offset, dwords;
d361 1
a361 1
    unsigned vertex_size = 0;
d363 2
a364 2
    /* Offsets of the attribute, in dwords, from the start of the vertex. */
    unsigned offset[PIPE_MAX_ATTRIBS];
d371 1
a371 1
    unsigned stride[PIPE_MAX_ATTRIBS] = {0};
d374 3
a376 1
    uint32_t* map[PIPE_MAX_ATTRIBS] = {0};
d380 3
d385 2
a386 4
        velem = &r300->vertex_element[i];
        offset[i] = velem->src_offset / 4;
        size[i] = util_format_get_blocksize(velem->src_format) / 4;
        vertex_size += size[i];
d388 2
d392 2
a393 3
        if (!map[vbi]) {
            vbuf = &r300->vertex_buffer[vbi];
            map[vbi] = (uint32_t*)pipe_buffer_map(r300->context.screen,
d395 3
a397 3
                                                  PIPE_BUFFER_USAGE_CPU_READ);
            map[vbi] += vbuf->buffer_offset / 4;
            stride[vbi] = vbuf->stride / 4;
d399 1
a401 6
    dwords = 10 + count * vertex_size;

    r300_reserve_cs_space(r300, r300_get_num_dirty_dwords(r300) + dwords);
    r300_emit_buffer_validate(r300, FALSE, 0);
    r300_emit_dirty_state(r300);

d406 3
a408 2
    OUT_CS_REG(R300_VAP_VF_MIN_VTX_INDX, 0);
    OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, count - 1);
d416 1
a416 7
            velem = &r300->vertex_element[i];
            vbi = velem->vertex_buffer_index;
            elem_offset = offset[i] + stride[vbi] * (v + start);

            for (dw = 0; dw < size[i]; dw++) {
                OUT_CS(map[vbi][elem_offset + dw]);
            }
d423 1
a423 1
        vbi = r300->vertex_element[i].vertex_buffer_index;
d425 1
a425 1
        if (map[vbi]) {
d427 2
a428 2
            pipe_buffer_unmap(r300->context.screen, vbuf->buffer);
            map[vbi] = NULL;
a436 1
#if defined(ENABLE_ALT_NUM_VERTS)
a437 3
#else
    boolean alt_num_verts = FALSE;
#endif
d440 7
a447 2
        assert(count < (1 << 24));
        BEGIN_CS(10);
a448 2
    } else {
        BEGIN_CS(8);
d452 3
a454 2
    OUT_CS_REG(R300_VAP_VF_MIN_VTX_INDX, 0);
    OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, count - 1);
d463 1
a463 1
                                    struct pipe_buffer* indexBuffer,
a472 1
#if defined(ENABLE_ALT_NUM_VERTS)
a473 3
#else
    boolean alt_num_verts = FALSE;
#endif
d476 7
a482 2
    assert((start * indexSize)  % 4 == 0);
    assert(count < (1 << 24));
d487 1
a487 2
    maxIndex = MIN2(maxIndex, ((1 << 24) - 1));

a488 1
        BEGIN_CS(16);
a489 2
    } else {
        BEGIN_CS(14);
d493 3
a495 2
    OUT_CS_REG(R300_VAP_VF_MIN_VTX_INDX, minIndex);
    OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, maxIndex);
d519 2
a520 2
    OUT_CS_RELOC(indexBuffer, count_dwords,
        RADEON_GEM_DOMAIN_GTT, 0, 0);
a524 31
static void r300_shorten_ubyte_elts(struct r300_context* r300,
                                    struct pipe_buffer** elts,
                                    unsigned count)
{
    struct pipe_screen* screen = r300->context.screen;
    struct pipe_buffer* new_elts;
    unsigned char *in_map;
    unsigned short *out_map;
    unsigned i;

    new_elts = screen->buffer_create(screen, 32,
                                     PIPE_BUFFER_USAGE_INDEX |
                                     PIPE_BUFFER_USAGE_CPU_WRITE |
                                     PIPE_BUFFER_USAGE_GPU_READ,
                                     2 * count);

    in_map = pipe_buffer_map(screen, *elts, PIPE_BUFFER_USAGE_CPU_READ);
    out_map = pipe_buffer_map(screen, new_elts, PIPE_BUFFER_USAGE_CPU_WRITE);

    for (i = 0; i < count; i++) {
        *out_map = (unsigned short)*in_map;
        in_map++;
        out_map++;
    }

    pipe_buffer_unmap(screen, *elts);
    pipe_buffer_unmap(screen, new_elts);

    *elts = new_elts;
}

d526 9
a534 8
void r300_draw_range_elements(struct pipe_context* pipe,
                              struct pipe_buffer* indexBuffer,
                              unsigned indexSize,
                              unsigned minIndex,
                              unsigned maxIndex,
                              unsigned mode,
                              unsigned start,
                              unsigned count)
d537 4
a540 7
    struct pipe_buffer* orgIndexBuffer = indexBuffer;
#if defined(ENABLE_ALT_NUM_VERTS)
    boolean alt_num_verts = r300_screen(pipe->screen)->caps->is_r500 &&
                            count > 65536;
#else
    boolean alt_num_verts = FALSE;
#endif
d542 2
d545 2
a546 2
    if (!u_trim_pipe_prim(mode, &count)) {
        return;
d549 2
a550 4
    if (indexSize == 1) {
        r300_shorten_ubyte_elts(r300, &indexBuffer, count);
        indexSize = 2;
    }
d553 3
d557 5
a561 5
    /* 128 dwords for emit_aos and emit_draw_elements */
    r300_reserve_cs_space(r300, r300_get_num_dirty_dwords(r300) + 128);
    r300_emit_buffer_validate(r300, TRUE, indexBuffer);
    r300_emit_dirty_state(r300);
    r300_emit_aos(r300, 0);
d564 2
a565 2
        r300_emit_draw_elements(r300, indexBuffer, indexSize, minIndex,
                                maxIndex, mode, start, count);
d568 9
a576 3
            short_count = MIN2(count, 65534);
            r300_emit_draw_elements(r300, indexBuffer, indexSize, minIndex,
                                    maxIndex, mode, start, short_count);
d581 6
a586 5
            /* 16 spare dwords are enough for emit_draw_elements. */
            if (count && r300_reserve_cs_space(r300, 16)) {
                r300_emit_buffer_validate(r300, TRUE, indexBuffer);
                r300_emit_dirty_state(r300);
                r300_emit_aos(r300, 0);
d591 1
d593 1
a593 1
        pipe->screen->buffer_destroy(indexBuffer);
d597 2
a598 15
/* Simple helpers for context setup. Should probably be moved to util. */
void r300_draw_elements(struct pipe_context* pipe,
                        struct pipe_buffer* indexBuffer,
                        unsigned indexSize, unsigned mode,
                        unsigned start, unsigned count)
{
    struct r300_context *r300 = r300_context(pipe);

    pipe->draw_range_elements(pipe, indexBuffer, indexSize, 0,
                              r300->vertex_buffer_max_index,
                              mode, start, count);
}

void r300_draw_arrays(struct pipe_context* pipe, unsigned mode,
                      unsigned start, unsigned count)
d601 3
a603 6
#if defined(ENABLE_ALT_NUM_VERTS)
    boolean alt_num_verts = r300_screen(pipe->screen)->caps->is_r500 &&
                            count > 65536;
#else
    boolean alt_num_verts = FALSE;
#endif
a605 4
    if (!u_trim_pipe_prim(mode, &count)) {
        return;
    }

d611 5
a615 5
        /* Make sure there are at least 128 spare dwords in the command buffer.
         * (most of it being consumed by emit_aos) */
        r300_reserve_cs_space(r300, r300_get_num_dirty_dwords(r300) + 128);
        r300_emit_buffer_validate(r300, TRUE, 0);
        r300_emit_dirty_state(r300);
a617 1
            r300_emit_aos(r300, start);
d621 5
a625 2
                short_count = MIN2(count, 65535);
                r300_emit_aos(r300, start);
d631 6
a636 5
                /* Again, we emit both AOS and draw_arrays so there should be
                 * at least 128 spare dwords. */
                if (count && r300_reserve_cs_space(r300, 128)) {
                    r300_emit_buffer_validate(r300, TRUE, 0);
                    r300_emit_dirty_state(r300);
d643 2
a644 10
/****************************************************************************
 * The rest of this file is for SW TCL rendering only. Please be polite and *
 * keep these functions separated so that they are easier to locate. ~C.    *
 ***************************************************************************/

/* SW TCL arrays, using Draw. */
void r300_swtcl_draw_arrays(struct pipe_context* pipe,
                               unsigned mode,
                               unsigned start,
                               unsigned count)
d647 8
a654 1
    int i;
d656 1
a656 1
    if (!u_trim_pipe_prim(mode, &count)) {
d660 15
a674 15
    for (i = 0; i < r300->vertex_buffer_count; i++) {
        void* buf = pipe_buffer_map(pipe->screen,
                                    r300->vertex_buffer[i].buffer,
                                    PIPE_BUFFER_USAGE_CPU_READ);
        draw_set_mapped_vertex_buffer(r300->draw, i, buf);
    }

    draw_set_mapped_element_buffer(r300->draw, 0, NULL);

    draw_set_mapped_constant_buffer(r300->draw,
				    PIPE_SHADER_VERTEX,
                                    0,
				    r300->shader_constants[PIPE_SHADER_VERTEX].constants,
				    r300->shader_constants[PIPE_SHADER_VERTEX].count *
                (sizeof(float) * 4));
d676 22
a697 1
    draw_arrays(r300->draw, mode, start, count);
d699 2
a700 3
    for (i = 0; i < r300->vertex_buffer_count; i++) {
        pipe_buffer_unmap(pipe->screen, r300->vertex_buffer[i].buffer);
        draw_set_mapped_vertex_buffer(r300->draw, i, NULL);
d704 5
d710 2
a711 8
void r300_swtcl_draw_range_elements(struct pipe_context* pipe,
                                       struct pipe_buffer* indexBuffer,
                                       unsigned indexSize,
                                       unsigned minIndex,
                                       unsigned maxIndex,
                                       unsigned mode,
                                       unsigned start,
                                       unsigned count)
d714 3
d718 2
a719 1
    void* indices;
d721 1
a721 1
    if (!u_trim_pipe_prim(mode, &count)) {
d725 11
d737 13
a749 17
        void* buf = pipe_buffer_map(pipe->screen,
                                    r300->vertex_buffer[i].buffer,
                                    PIPE_BUFFER_USAGE_CPU_READ);
        draw_set_mapped_vertex_buffer(r300->draw, i, buf);
    }

    indices = pipe_buffer_map(pipe->screen, indexBuffer,
                              PIPE_BUFFER_USAGE_CPU_READ);
    draw_set_mapped_element_buffer_range(r300->draw, indexSize,
                                         minIndex, maxIndex, indices);

    draw_set_mapped_constant_buffer(r300->draw,
				    PIPE_SHADER_VERTEX,
                                    0,
            r300->shader_constants[PIPE_SHADER_VERTEX].constants,
            r300->shader_constants[PIPE_SHADER_VERTEX].count *
                (sizeof(float) * 4));
d751 7
a757 1
    draw_arrays(r300->draw, mode, start, count);
d760 5
a764 2
        pipe_buffer_unmap(pipe->screen, r300->vertex_buffer[i].buffer);
        draw_set_mapped_vertex_buffer(r300->draw, i, NULL);
d767 4
a770 3
    pipe_buffer_unmap(pipe->screen, indexBuffer);
    draw_set_mapped_element_buffer_range(r300->draw, 0, start,
                                         start + count - 1, NULL);
a786 3
    struct pipe_buffer* vbo;
    size_t vbo_size;
    size_t vbo_offset;
d789 2
a804 2
    r300_update_derived_state(r300);

d817 3
a819 1
    if (size + r300render->vbo_offset > r300render->vbo_size)
d821 7
a827 7
        pipe_buffer_reference(&r300->vbo, NULL);
        r300render->vbo = pipe_buffer_create(screen,
                                             64,
                                             PIPE_BUFFER_USAGE_VERTEX,
                                             R300_MAX_VBO_SIZE);
        r300render->vbo_offset = 0;
        r300render->vbo_size = R300_MAX_VBO_SIZE;
a830 2
    r300->vbo = r300render->vbo;
    r300->vbo_offset = r300render->vbo_offset;
d832 1
a832 1
    return (r300render->vbo) ? TRUE : FALSE;
d838 1
a838 1
    struct pipe_screen* screen = r300render->r300->context.screen;
d840 1
a840 2
    r300render->vbo_ptr = pipe_buffer_map(screen, r300render->vbo,
                                          PIPE_BUFFER_USAGE_CPU_WRITE);
d842 10
a851 1
    return ((uint8_t*)r300render->vbo_ptr + r300render->vbo_offset);
d859 6
a864 5
    struct pipe_screen* screen = r300render->r300->context.screen;
    CS_LOCALS(r300render->r300);
    BEGIN_CS(2);
    OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, max);
    END_CS;
d868 3
a870 1
    pipe_buffer_unmap(screen, r300render->vbo);
d876 1
d878 3
a880 1
    r300render->vbo_offset += r300render->vbo_max_used;
d896 2
a897 2
                                          unsigned start,
                                          unsigned count)
d901 3
d906 21
d928 6
a933 2
    r300_reserve_cs_space(r300, r300_get_num_dirty_dwords(r300) + 2);
    r300_emit_dirty_state(r300);
d935 3
a937 1
    DBG(r300, DBG_DRAW, "r300: Doing vbuf render, count %d\n", count);
d939 4
a942 1
    BEGIN_CS(2);
d947 2
d951 3
a953 3
static void r300_render_draw(struct vbuf_render* render,
                                   const ushort* indices,
                                   uint count)
d958 5
a962 1
    unsigned dwords = 2 + (count+1)/2;
d965 1
d967 36
a1002 2
    r300_reserve_cs_space(r300, r300_get_num_dirty_dwords(r300) + dwords);
    r300_emit_dirty_state(r300);
d1004 13
a1016 6
    BEGIN_CS(dwords);
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, (count+1)/2);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (count << 16) |
           r300render->hwprim);
    for (i = 0; i < count-1; i += 2) {
        OUT_CS(indices[i+1] << 16 | indices[i]);
d1018 2
a1019 4
    if (count % 2) {
        OUT_CS(indices[count-1]);
    }
    END_CS;
d1042 1
a1042 1
    r300render->base.draw = r300_render_draw;
a1046 4
    r300render->vbo = NULL;
    r300render->vbo_size = 0;
    r300render->vbo_offset = 0;

d1071 164
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a2 1
 * Copyright 2010 Marek Olšák <maraeo@@gmail.com>
a32 1
#include "util/u_upload_mgr.h"
a36 1
#include "r300_screen_buffer.h"
d39 1
d42 2
a43 1
#include <limits.h>
d45 2
a46 1
#define IMMD_DWORDS 32
d48 1
a48 1
static uint32_t r300_translate_primitive(unsigned prim)
d121 4
a124 1
void r500_emit_index_bias(struct r300_context *r300, int index_bias)
d126 1
a126 85
    CS_LOCALS(r300);

    BEGIN_CS(2);
    OUT_CS_REG(R500_VAP_INDEX_OFFSET,
               (index_bias & 0xFFFFFF) | (index_bias < 0 ? 1<<24 : 0));
    END_CS;
}

/* This function splits the index bias value into two parts:
 * - buffer_offset: the value that can be safely added to buffer offsets
 *   in r300_emit_aos (it must yield a positive offset when added to
 *   a vertex buffer offset)
 * - index_offset: the value that must be manually subtracted from indices
 *   in an index buffer to achieve negative offsets. */
static void r300_split_index_bias(struct r300_context *r300, int index_bias,
                                  int *buffer_offset, int *index_offset)
{
    struct pipe_vertex_buffer *vb, *vbufs = r300->vertex_buffer;
    struct pipe_vertex_element *velem = r300->velems->velem;
    unsigned i, size;
    int max_neg_bias;

    if (index_bias < 0) {
        /* See how large index bias we may subtract. We must be careful
         * here because negative buffer offsets are not allowed
         * by the DRM API. */
        max_neg_bias = INT_MAX;
        for (i = 0; i < r300->velems->count; i++) {
            vb = &vbufs[velem[i].vertex_buffer_index];
            size = (vb->buffer_offset + velem[i].src_offset) / vb->stride;
            max_neg_bias = MIN2(max_neg_bias, size);
        }

        /* Now set the minimum allowed value. */
        *buffer_offset = MAX2(-max_neg_bias, index_bias);
    } else {
        /* A positive index bias is OK. */
        *buffer_offset = index_bias;
    }

    *index_offset = index_bias - *buffer_offset;
}

enum r300_prepare_flags {
    PREP_FIRST_DRAW     = (1 << 0), /* call emit_dirty_state and friends? */
    PREP_VALIDATE_VBOS  = (1 << 1), /* validate VBOs? */
    PREP_EMIT_AOS       = (1 << 2), /* call emit_aos? */
    PREP_EMIT_AOS_SWTCL = (1 << 3), /* call emit_aos_swtcl? */
    PREP_INDEXED        = (1 << 4)  /* is this draw_elements? */
};

/**
 * Check if the requested number of dwords is available in the CS and
 * if not, flush.
 * \param r300          The context.
 * \param flags         See r300_prepare_flags.
 * \param cs_dwords     The number of dwords to reserve in CS.
 * \return TRUE if the CS was flushed
 */
static boolean r300_reserve_cs_dwords(struct r300_context *r300,
                                   enum r300_prepare_flags flags,
                                   unsigned cs_dwords)
{
    boolean flushed        = FALSE;
    boolean emit_states    = flags & PREP_FIRST_DRAW;
    boolean emit_vertex_arrays       = flags & PREP_EMIT_AOS;
    boolean emit_vertex_arrays_swtcl = flags & PREP_EMIT_AOS_SWTCL;

    /* Add dirty state, index offset, and AOS. */
    if (emit_states)
        cs_dwords += r300_get_num_dirty_dwords(r300);

    if (r300->screen->caps.index_bias_supported)
        cs_dwords += 2; /* emit_index_offset */

    if (emit_vertex_arrays)
        cs_dwords += 55; /* emit_vertex_arrays */

    if (emit_vertex_arrays_swtcl)
        cs_dwords += 7; /* emit_vertex_arrays_swtcl */

    cs_dwords += r300_get_num_cs_end_dwords(r300);

    /* Reserve requested CS space. */
    if (cs_dwords > (R300_MAX_CMDBUF_DWORDS - r300->cs->cdw)) {
d128 1
a128 1
        flushed = TRUE;
d130 1
a130 87

    return flushed;
}

/**
 * Validate buffers and emit dirty state.
 * \param r300          The context.
 * \param flags         See r300_prepare_flags.
 * \param index_buffer  The index buffer to validate. The parameter may be NULL.
 * \param aos_offset    The offset passed to emit_aos.
 * \param index_bias    The index bias to emit.
 * \return TRUE if rendering should be skipped
 */
static boolean r300_emit_states(struct r300_context *r300,
                                enum r300_prepare_flags flags,
                                struct pipe_resource *index_buffer,
                                int aos_offset,
                                int index_bias)
{
    boolean emit_states    = flags & PREP_FIRST_DRAW;
    boolean emit_vertex_arrays       = flags & PREP_EMIT_AOS;
    boolean emit_vertex_arrays_swtcl = flags & PREP_EMIT_AOS_SWTCL;
    boolean indexed        = flags & PREP_INDEXED;
    boolean validate_vbos  = flags & PREP_VALIDATE_VBOS;

    if (emit_states) {
        /* upload buffers first */
        if (r300->screen->caps.has_tcl && r300->any_user_vbs) {
            r300_upload_user_buffers(r300);
            r300->any_user_vbs = false;
        }

        if (r300->validate_buffers) {
            if (!r300_emit_buffer_validate(r300, validate_vbos,
                                           index_buffer)) {
                fprintf(stderr, "r300: CS space validation failed. "
                        "(not enough memory?) Skipping rendering.\n");
                return FALSE;
            }

            /* Consider the validation done only if everything was validated. */
            if (validate_vbos) {
                r300->validate_buffers = FALSE;
            }
        }

        r300_emit_dirty_state(r300);
    }

    if (r300->screen->caps.index_bias_supported) {
        if (r300->screen->caps.has_tcl)
            r500_emit_index_bias(r300, index_bias);
        else
            r500_emit_index_bias(r300, 0);
    }

    if (emit_vertex_arrays)
        r300_emit_aos(r300, aos_offset, indexed);

    if (emit_vertex_arrays_swtcl)
        r300_emit_aos_swtcl(r300, indexed);

    return TRUE;
}

/**
 * Check if the requested number of dwords is available in the CS and
 * if not, flush. Then validate buffers and emit dirty state.
 * \param r300          The context.
 * \param flags         See r300_prepare_flags.
 * \param index_buffer  The index buffer to validate. The parameter may be NULL.
 * \param cs_dwords     The number of dwords to reserve in CS.
 * \param aos_offset    The offset passed to emit_aos.
 * \param index_bias    The index bias to emit.
 * \return TRUE if rendering should be skipped
 */
static boolean r300_prepare_for_rendering(struct r300_context *r300,
                                          enum r300_prepare_flags flags,
                                          struct pipe_resource *index_buffer,
                                          unsigned cs_dwords,
                                          int aos_offset,
                                          int index_bias)
{
    if (r300_reserve_cs_dwords(r300, flags, cs_dwords))
        flags |= PREP_FIRST_DRAW;

    return r300_emit_states(r300, flags, index_buffer, aos_offset, index_bias);
d134 1
a134 1
                                 unsigned count)
d136 1
a136 41
    struct pipe_vertex_element* velem;
    struct pipe_vertex_buffer* vbuf;
    boolean checked[PIPE_MAX_ATTRIBS] = {0};
    unsigned vertex_element_count = r300->velems->count;
    unsigned i, vbi;

    if (DBG_ON(r300, DBG_NO_IMMD)) {
        return FALSE;
    }

    if (r300->draw) {
        return FALSE;
    }

    if (count * r300->velems->vertex_size_dwords > IMMD_DWORDS) {
        return FALSE;
    }

    /* We shouldn't map buffers referenced by CS, busy buffers,
     * and ones placed in VRAM. */
    for (i = 0; i < vertex_element_count; i++) {
        velem = &r300->velems->velem[i];
        vbi = velem->vertex_buffer_index;

        if (!checked[vbi]) {
            vbuf = &r300->vertex_buffer[vbi];

            if (!(r300_buffer(vbuf->buffer)->domain & R300_DOMAIN_GTT)) {
                return FALSE;
            }

            if (r300_buffer_is_referenced(&r300->context,
                                          vbuf->buffer,
                                          R300_REF_CS | R300_REF_HW)) {
                /* It's a very bad idea to map it... */
                return FALSE;
            }
            checked[vbi] = TRUE;
        }
    }
    return TRUE;
a138 4
/*****************************************************************************
 * The HWTCL draw functions.                                                 *
 ****************************************************************************/

d146 2
a147 2
    unsigned vertex_element_count = r300->velems->count;
    unsigned i, v, vbi;
d150 1
a150 1
    unsigned vertex_size = r300->velems->vertex_size_dwords;
d152 2
a153 2
    /* The number of dwords for this draw operation. */
    unsigned dwords = 9 + count * vertex_size;
d160 1
a160 1
    unsigned stride[PIPE_MAX_ATTRIBS];
d163 1
a163 3
    uint32_t* map[PIPE_MAX_ATTRIBS];
    uint32_t* mapelem[PIPE_MAX_ATTRIBS];
    struct pipe_transfer* transfer[PIPE_MAX_ATTRIBS] = {0};
a166 3
    if (!r300_prepare_for_rendering(r300, PREP_FIRST_DRAW, NULL, dwords, 0, 0))
        return;

d169 4
a172 2
        velem = &r300->velems->velem[i];
        size[i] = r300->velems->hw_format_size[i] / 4;
a173 2
        vbuf = &r300->vertex_buffer[vbi];
        stride[i] = vbuf->stride / 4;
d176 3
a178 2
        if (!transfer[vbi]) {
            map[vbi] = (uint32_t*)pipe_buffer_map(&r300->context,
d180 3
a182 3
                                                  PIPE_TRANSFER_READ,
						  &transfer[vbi]);
            map[vbi] += (vbuf->buffer_offset / 4) + stride[i] * start;
a183 1
        mapelem[i] = map[vbi] + (velem->src_offset / 4);
d186 6
d196 2
a197 3
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(count - 1);
    OUT_CS(0);
d205 7
a211 1
            OUT_CS_TABLE(&mapelem[i][stride[i] * v], size[i]);
d218 1
a218 1
        vbi = r300->velems->velem[i].vertex_buffer_index;
d220 1
a220 1
        if (transfer[vbi]) {
d222 2
a223 2
            pipe_buffer_unmap(&r300->context, vbuf->buffer, transfer[vbi]);
            transfer[vbi] = NULL;
d232 1
d234 3
a238 7
    if (count >= (1 << 24)) {
        fprintf(stderr, "r300: Got a huge number of vertices: %i, "
                "refusing to render.\n", count);
        return;
    }

    BEGIN_CS(7 + (alt_num_verts ? 2 : 0));
d240 2
d243 2
d248 2
a249 3
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(count - 1);
    OUT_CS(0);
d258 1
a258 1
                                    struct pipe_resource* indexBuffer,
d268 1
d270 3
d275 2
a276 7
    if (count >= (1 << 24)) {
        fprintf(stderr, "r300: Got a huge number of vertices: %i, "
                "refusing to render.\n", count);
        return;
    }

    maxIndex = MIN2(maxIndex, r300->vertex_buffer_max_index);
d281 2
a282 1
    BEGIN_CS(13 + (alt_num_verts ? 2 : 0));
d284 1
d286 2
d291 2
a292 3
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(maxIndex);
    OUT_CS(minIndex);
d316 2
a317 2
    OUT_CS_BUF_RELOC(indexBuffer, count_dwords,
                     r300_buffer(indexBuffer)->domain, 0);
d322 31
d354 8
a361 9
static void r300_draw_range_elements(struct pipe_context* pipe,
                                     struct pipe_resource* indexBuffer,
                                     unsigned indexSize,
                                     int indexBias,
                                     unsigned minIndex,
                                     unsigned maxIndex,
                                     unsigned mode,
                                     unsigned start,
                                     unsigned count)
d364 7
a370 4
    struct pipe_resource* orgIndexBuffer = indexBuffer;
    boolean alt_num_verts = r300->screen->caps.is_r500 &&
                            count > 65536 &&
                            r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0);
a371 2
    int buffer_offset = 0, index_offset = 0; /* for index bias emulation */
    unsigned new_offset;
d373 2
a374 2
    if (indexBias && !r300->screen->caps.index_bias_supported) {
        r300_split_index_bias(r300, indexBias, &buffer_offset, &index_offset);
d377 4
a380 2
    r300_translate_index_buffer(r300, &indexBuffer, &indexSize, index_offset,
                                &start, count);
a382 3
    r300_upload_index_buffer(r300, &indexBuffer, indexSize, start, count, &new_offset);

    start = new_offset;
d384 5
a388 5
    /* 15 dwords for emit_draw_elements. Give up if the function fails. */
    if (!r300_prepare_for_rendering(r300,
            PREP_FIRST_DRAW | PREP_VALIDATE_VBOS | PREP_EMIT_AOS |
            PREP_INDEXED, indexBuffer, 15, buffer_offset, indexBias))
        goto done;
d391 2
a392 2
        r300_emit_draw_elements(r300, indexBuffer, indexSize,
				minIndex, maxIndex, mode, start, count);
d395 3
a397 9
            /* The maximum must be divisible by 4 and 3,
             * so that quad and triangle lists are split correctly.
             *
             * Strips, loops, and fans won't work. */
            short_count = MIN2(count, 65532);

            r300_emit_draw_elements(r300, indexBuffer, indexSize,
                                     minIndex, maxIndex,
                                     mode, start, short_count);
d402 5
a406 6
            /* 15 dwords for emit_draw_elements */
            if (count) {
                if (!r300_prepare_for_rendering(r300,
                        PREP_VALIDATE_VBOS | PREP_EMIT_AOS | PREP_INDEXED,
                        indexBuffer, 15, buffer_offset, indexBias))
                    goto done;
a410 1
done:
d412 1
a412 1
        pipe_resource_reference( &indexBuffer, NULL );
d416 15
a430 2
static void r300_draw_arrays(struct pipe_context* pipe, unsigned mode,
                             unsigned start, unsigned count)
d433 6
a438 3
    boolean alt_num_verts = r300->screen->caps.is_r500 &&
                            count > 65536 &&
                            r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0);
d441 4
d450 5
a454 5
        /* 9 spare dwords for emit_draw_arrays. Give up if the function fails. */
        if (!r300_prepare_for_rendering(r300,
                PREP_FIRST_DRAW | PREP_VALIDATE_VBOS | PREP_EMIT_AOS,
                NULL, 9, start, 0))
            return;
d457 1
d461 2
a462 5
                /* The maximum must be divisible by 4 and 3,
                 * so that quad and triangle lists are split correctly.
                 *
                 * Strips, loops, and fans won't work. */
                short_count = MIN2(count, 65532);
d468 5
a472 6
                /* 9 spare dwords for emit_draw_arrays. Give up if the function fails. */
                if (count) {
                    if (!r300_prepare_for_rendering(r300,
                            PREP_VALIDATE_VBOS | PREP_EMIT_AOS, NULL, 9,
                            start, 0))
                        return;
d479 10
a488 2
static void r300_draw_vbo(struct pipe_context* pipe,
                          const struct pipe_draw_info *info)
d491 1
a491 4
    unsigned count = info->count;
    boolean translate = FALSE;
    boolean indexed = info->indexed && r300->index_buffer.buffer;
    unsigned start_indexed = 0;
d493 1
a493 1
    if (r300->skip_rendering) {
d497 15
a511 19
    if (!u_trim_pipe_prim(info->mode, &count)) {
        return;
    }

    /* Index buffer range checking. */
    if (indexed) {
        assert(r300->index_buffer.offset % r300->index_buffer.index_size == 0);

        /* Compute start for draw_elements, taking the offset into account. */
        start_indexed =
            info->start +
            (r300->index_buffer.offset / r300->index_buffer.index_size);

        if ((start_indexed + count) * r300->index_buffer.index_size >
            r300->index_buffer.buffer->width0) {
            fprintf(stderr, "r300: Invalid index buffer range. Skipping rendering.\n");
            return;
        }
    }
d513 1
a513 22
    /* Set up fallback for incompatible vertex layout if needed. */
    if (r300->incompatible_vb_layout || r300->velems->incompatible_layout) {
        r300_begin_vertex_translate(r300);
        translate = TRUE;
    }

    if (indexed) {
        r300_draw_range_elements(pipe,
                                 r300->index_buffer.buffer,
                                 r300->index_buffer.index_size,
                                 info->index_bias,
                                 info->min_index,
                                 info->max_index,
                                 info->mode,
                                 start_indexed,
                                 count);
    } else {
        r300_draw_arrays(pipe,
                         info->mode,
                         info->start,
                         count);
    }
d515 3
a517 2
    if (translate) {
        r300_end_vertex_translate(r300);
a520 5
/****************************************************************************
 * The rest of this file is for SW TCL rendering only. Please be polite and *
 * keep these functions separated so that they are easier to locate. ~C.    *
 ***************************************************************************/

d522 8
a529 2
static void r300_swtcl_draw_vbo(struct pipe_context* pipe,
                                const struct pipe_draw_info *info)
a531 3
    struct pipe_transfer *vb_transfer[PIPE_MAX_ATTRIBS];
    struct pipe_transfer *ib_transfer = NULL;
    unsigned count = info->count;
d533 1
a533 2
    void *indices = NULL;
    boolean indexed = info->indexed && r300->index_buffer.buffer;
d535 1
a535 1
    if (r300->skip_rendering) {
a538 11
    if (!u_trim_pipe_prim(info->mode, &count)) {
        return;
    }

    r300_update_derived_state(r300);

    r300_reserve_cs_dwords(r300,
            PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL |
            (indexed ? PREP_INDEXED : 0),
            indexed ? 256 : 6);

d540 17
a556 13
        if (r300->vertex_buffer[i].buffer) {
            void *buf = pipe_buffer_map(pipe,
                                  r300->vertex_buffer[i].buffer,
                                  PIPE_TRANSFER_READ,
                                  &vb_transfer[i]);
            draw_set_mapped_vertex_buffer(r300->draw, i, buf);
        }
    }

    if (indexed) {
        indices = pipe_buffer_map(pipe, r300->index_buffer.buffer,
                                  PIPE_TRANSFER_READ, &ib_transfer);
    }
d558 1
a558 7
    draw_set_mapped_index_buffer(r300->draw, indices);

    r300->draw_vbo_locked = TRUE;
    r300->draw_first_emitted = FALSE;
    draw_vbo(r300->draw, info);
    draw_flush(r300->draw);
    r300->draw_vbo_locked = FALSE;
d561 2
a562 5
        if (r300->vertex_buffer[i].buffer) {
            pipe_buffer_unmap(pipe, r300->vertex_buffer[i].buffer,
                              vb_transfer[i]);
            draw_set_mapped_vertex_buffer(r300->draw, i, NULL);
        }
d565 3
a567 4
    if (indexed) {
        pipe_buffer_unmap(pipe, r300->index_buffer.buffer, ib_transfer);
        draw_set_mapped_index_buffer(r300->draw, NULL);
    }
d584 3
a588 2

    struct pipe_transfer *vbo_transfer;
d603 2
d617 1
a617 3
    DBG(r300, DBG_DRAW, "r300: render_allocate_vertices (size: %d)\n", size);

    if (size + r300->draw_vbo_offset > r300->draw_vbo_size)
d619 7
a625 7
	pipe_resource_reference(&r300->vbo, NULL);
        r300->vbo = pipe_buffer_create(screen,
				       PIPE_BIND_VERTEX_BUFFER,
				       R300_MAX_DRAW_VBO_SIZE);
        r300->draw_vbo_offset = 0;
        r300->draw_vbo_size = R300_MAX_DRAW_VBO_SIZE;
        r300->validate_buffers = TRUE;
d629 2
d632 1
a632 1
    return (r300->vbo) ? TRUE : FALSE;
d638 1
a638 1
    struct r300_context* r300 = r300render->r300;
d640 2
a641 1
    assert(!r300render->vbo_transfer);
d643 1
a643 10
    DBG(r300, DBG_DRAW, "r300: render_map_vertices\n");

    r300render->vbo_ptr = pipe_buffer_map(&r300render->r300->context,
					  r300->vbo,
                                          PIPE_TRANSFER_WRITE,
					  &r300render->vbo_transfer);

    assert(r300render->vbo_ptr);

    return ((uint8_t*)r300render->vbo_ptr + r300->draw_vbo_offset);
d651 5
a655 6
    struct pipe_context* context = &r300render->r300->context;
    struct r300_context* r300 = r300render->r300;

    assert(r300render->vbo_transfer);

    DBG(r300, DBG_DRAW, "r300: render_unmap_vertices\n");
d659 1
a659 3
    pipe_buffer_unmap(context, r300->vbo, r300render->vbo_transfer);

    r300render->vbo_transfer = NULL;
a664 1
    struct r300_context* r300 = r300render->r300;
d666 1
a666 3
    DBG(r300, DBG_DRAW, "r300: render_release_vertices\n");

    r300->draw_vbo_offset += r300render->vbo_max_used;
d682 2
a683 2
                                    unsigned start,
                                    unsigned count)
a686 3
    uint8_t* ptr;
    unsigned i;
    unsigned dwords = 6;
a688 3
    (void) i; (void) ptr;

    DBG(r300, DBG_DRAW, "r300: render_draw_arrays (count: %d)\n", count);
d690 2
a691 11
    if (r300->draw_first_emitted) {
        if (!r300_prepare_for_rendering(r300,
                PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL,
                NULL, 6, 0, 0))
            return;
    } else {
        if (!r300_emit_states(r300,
                PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL,
                NULL, 0, 0))
            return;
    }
d693 1
a693 5
    /* Uncomment to dump all VBOs rendered through this interface.
     * Slow and noisy!
    ptr = pipe_buffer_map(&r300render->r300->context,
                          r300render->vbo, PIPE_TRANSFER_READ,
                          &r300render->vbo_transfer);
d695 1
a695 15
    for (i = 0; i < count; i++) {
        printf("r300: Vertex %d\n", i);
        draw_dump_emitted_vertex(&r300->vertex_info, ptr);
        ptr += r300->vertex_info.size * 4;
        printf("\n");
    }

    pipe_buffer_unmap(&r300render->r300->context, r300render->vbo,
        r300render->vbo_transfer);
    */

    BEGIN_CS(dwords);
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
            r300_provoking_vertex_fixes(r300, r300render->prim));
    OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, count - 1);
a699 2

    r300->draw_first_emitted = TRUE;
d702 3
a704 3
static void r300_render_draw_elements(struct vbuf_render* render,
                                      const ushort* indices,
                                      uint count)
d709 1
a709 5
    unsigned end_cs_dwords;
    unsigned max_index = (r300->draw_vbo_size - r300->draw_vbo_offset) /
                         (r300render->r300->vertex_info.size * 4) - 1;
    unsigned short_count;
    unsigned free_dwords;
a711 1
    DBG(r300, DBG_DRAW, "r300: render_draw_elements (count: %d)\n", count);
d713 2
a714 36
    if (r300->draw_first_emitted) {
        if (!r300_prepare_for_rendering(r300,
                PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL | PREP_INDEXED,
                NULL, 256, 0, 0))
            return;
    } else {
        if (!r300_emit_states(r300,
                PREP_FIRST_DRAW | PREP_EMIT_AOS_SWTCL | PREP_INDEXED,
                NULL, 0, 0))
            return;
    }

    /* Below we manage the CS space manually because there may be more
     * indices than it can fit in CS. */

    end_cs_dwords = r300_get_num_cs_end_dwords(r300);

    while (count) {
        free_dwords = R300_MAX_CMDBUF_DWORDS - r300->cs->cdw;

        short_count = MIN2(count, (free_dwords - end_cs_dwords - 6) * 2);

        BEGIN_CS(6 + (short_count+1)/2);
        OUT_CS_REG(R300_GA_COLOR_CONTROL,
                r300_provoking_vertex_fixes(r300, r300render->prim));
        OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, max_index);
        OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, (short_count+1)/2);
        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (short_count << 16) |
               r300render->hwprim);
        for (i = 0; i < short_count-1; i += 2) {
            OUT_CS(indices[i+1] << 16 | indices[i]);
        }
        if (short_count % 2) {
            OUT_CS(indices[short_count-1]);
        }
        END_CS;
d716 9
a724 13
        /* OK now subtract the emitted indices and see if we need to emit
         * another draw packet. */
        indices += short_count;
        count -= short_count;

        if (count) {
            if (!r300_prepare_for_rendering(r300,
                    PREP_EMIT_AOS_SWTCL | PREP_INDEXED,
                    NULL, 256, 0, 0))
                return;

            end_cs_dwords = r300_get_num_cs_end_dwords(r300);
        }
d726 1
a726 2

    r300->draw_first_emitted = TRUE;
d749 1
a749 1
    r300render->base.draw_elements = r300_render_draw_elements;
d754 4
a781 164
}

void r300_draw_flush_vbuf(struct r300_context *r300)
{
    pipe_resource_reference(&r300->vbo, NULL);
    r300->draw_vbo_size = 0;
}

/****************************************************************************
 *                         End of SW TCL functions                          *
 ***************************************************************************/

/* This functions is used to draw a rectangle for the blitter module.
 *
 * If we rendered a quad, the pixels on the main diagonal
 * would be computed and stored twice, which makes the clear/copy codepaths
 * somewhat inefficient. Instead we use a rectangular point sprite. */
static void r300_blitter_draw_rectangle(struct blitter_context *blitter,
                                        unsigned x1, unsigned y1,
                                        unsigned x2, unsigned y2,
                                        float depth,
                                        enum blitter_attrib_type type,
                                        const float attrib[4])
{
    struct r300_context *r300 = r300_context(util_blitter_get_pipe(blitter));
    unsigned last_sprite_coord_enable = r300->sprite_coord_enable;
    unsigned width = x2 - x1;
    unsigned height = y2 - y1;
    unsigned vertex_size =
            type == UTIL_BLITTER_ATTRIB_COLOR || !r300->draw ? 8 : 4;
    unsigned dwords = 13 + vertex_size +
                      (type == UTIL_BLITTER_ATTRIB_TEXCOORD ? 7 : 0);
    const float zeros[4] = {0, 0, 0, 0};
    CS_LOCALS(r300);

    if (r300->skip_rendering)
        return;

    r300->context.set_vertex_buffers(&r300->context, 0, NULL);

    if (type == UTIL_BLITTER_ATTRIB_TEXCOORD)
        r300->sprite_coord_enable = 1;

    r300_update_derived_state(r300);

    /* Mark some states we don't care about as non-dirty. */
    r300->clip_state.dirty = FALSE;
    r300->viewport_state.dirty = FALSE;

    if (!r300_prepare_for_rendering(r300, PREP_FIRST_DRAW, NULL, dwords, 0, 0))
        goto done;

    DBG(r300, DBG_DRAW, "r300: draw_rectangle\n");

    BEGIN_CS(dwords);
    /* Set up GA. */
    OUT_CS_REG(R300_GA_POINT_SIZE, (height * 6) | ((width * 6) << 16));

    if (type == UTIL_BLITTER_ATTRIB_TEXCOORD) {
        /* Set up the GA to generate texcoords. */
        OUT_CS_REG(R300_GB_ENABLE, R300_GB_POINT_STUFF_ENABLE |
                   (R300_GB_TEX_STR << R300_GB_TEX0_SOURCE_SHIFT));
        OUT_CS_REG_SEQ(R300_GA_POINT_S0, 4);
        OUT_CS_32F(attrib[0]);
        OUT_CS_32F(attrib[3]);
        OUT_CS_32F(attrib[2]);
        OUT_CS_32F(attrib[1]);
    }

    /* Set up VAP controls. */
    OUT_CS_REG(R300_VAP_CLIP_CNTL, R300_CLIP_DISABLE);
    OUT_CS_REG(R300_VAP_VTE_CNTL, R300_VTX_XY_FMT | R300_VTX_Z_FMT);
    OUT_CS_REG(R300_VAP_VTX_SIZE, vertex_size);
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(1);
    OUT_CS(0);

    /* Draw. */
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_IMMD_2, vertex_size);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_EMBEDDED | (1 << 16) |
           R300_VAP_VF_CNTL__PRIM_POINTS);

    OUT_CS_32F(x1 + width * 0.5f);
    OUT_CS_32F(y1 + height * 0.5f);
    OUT_CS_32F(depth);
    OUT_CS_32F(1);

    if (vertex_size == 8) {
        if (!attrib)
            attrib = zeros;
        OUT_CS_TABLE(attrib, 4);
    }
    END_CS;

done:
    /* Restore the state. */
    r300_mark_atom_dirty(r300, &r300->clip_state);
    r300_mark_atom_dirty(r300, &r300->rs_state);
    r300_mark_atom_dirty(r300, &r300->viewport_state);

    r300->sprite_coord_enable = last_sprite_coord_enable;
}

static void r300_resource_resolve(struct pipe_context* pipe,
                                  struct pipe_resource* dest,
                                  unsigned dst_layer,
                                  struct pipe_resource* src,
                                  unsigned src_layer)
{
    struct r300_context* r300 = r300_context(pipe);
    struct pipe_surface* srcsurf, surf_tmpl;
    struct r300_aa_state *aa = (struct r300_aa_state*)r300->aa_state.state;
    float color[] = {0, 0, 0, 0};

    memset(&surf_tmpl, 0, sizeof(surf_tmpl));
    surf_tmpl.format = src->format;
    surf_tmpl.usage = 0; /* not really a surface hence no bind flags */
    surf_tmpl.u.tex.level = 0; /* msaa resources cannot have mipmaps */
    surf_tmpl.u.tex.first_layer = src_layer;
    surf_tmpl.u.tex.last_layer = src_layer;
    srcsurf = pipe->create_surface(pipe, src, &surf_tmpl);
    surf_tmpl.format = dest->format;
    surf_tmpl.u.tex.first_layer = dst_layer;
    surf_tmpl.u.tex.last_layer = dst_layer;

    DBG(r300, DBG_DRAW, "r300: Resolving resource...\n");

    /* Enable AA resolve. */
    aa->dest = r300_surface(pipe->create_surface(pipe, dest, &surf_tmpl));

    aa->aaresolve_ctl =
        R300_RB3D_AARESOLVE_CTL_AARESOLVE_MODE_RESOLVE |
        R300_RB3D_AARESOLVE_CTL_AARESOLVE_ALPHA_AVERAGE;
    r300->aa_state.size = 12;
    r300_mark_atom_dirty(r300, &r300->aa_state);

    /* Resolve the surface. */
    r300->context.clear_render_target(pipe,
        srcsurf, color, 0, 0, src->width0, src->height0);

    /* Disable AA resolve. */
    aa->aaresolve_ctl = 0;
    r300->aa_state.size = 4;
    r300_mark_atom_dirty(r300, &r300->aa_state);

    pipe_surface_reference((struct pipe_surface**)&srcsurf, NULL);
    pipe_surface_reference((struct pipe_surface**)&aa->dest, NULL);
}

void r300_init_render_functions(struct r300_context *r300)
{
    /* Set draw functions based on presence of HW TCL. */
    if (r300->screen->caps.has_tcl) {
        r300->context.draw_vbo = r300_draw_vbo;
    } else {
        r300->context.draw_vbo = r300_swtcl_draw_vbo;
    }

    r300->context.resource_resolve = r300_resource_resolve;
    r300->blitter->draw_rectangle = r300_blitter_draw_rectangle;

    /* Plug in the two-sided stencil reference value fallback if needed. */
    if (!r300->screen->caps.is_r500)
        r300_plug_in_stencil_ref_fallback(r300);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d42 1
d50 24
a73 20
    static const int prim_conv[] = {
        R300_VAP_VF_CNTL__PRIM_POINTS,
        R300_VAP_VF_CNTL__PRIM_LINES,
        R300_VAP_VF_CNTL__PRIM_LINE_LOOP,
        R300_VAP_VF_CNTL__PRIM_LINE_STRIP,
        R300_VAP_VF_CNTL__PRIM_TRIANGLES,
        R300_VAP_VF_CNTL__PRIM_TRIANGLE_STRIP,
        R300_VAP_VF_CNTL__PRIM_TRIANGLE_FAN,
        R300_VAP_VF_CNTL__PRIM_QUADS,
        R300_VAP_VF_CNTL__PRIM_QUAD_STRIP,
        R300_VAP_VF_CNTL__PRIM_POLYGON,
        -1,
        -1,
        -1,
        -1
    };
    unsigned hwprim = prim_conv[prim];

    assert(hwprim != -1);
    return hwprim;
a130 16
static void r300_emit_draw_init(struct r300_context *r300, unsigned mode,
                                unsigned max_index)
{
    CS_LOCALS(r300);

    assert(max_index < (1 << 24));

    BEGIN_CS(5);
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
            r300_provoking_vertex_fixes(r300, mode));
    OUT_CS_REG_SEQ(R300_VAP_VF_MAX_VTX_INDX, 2);
    OUT_CS(max_index);
    OUT_CS(0);
    END_CS;
}

d133 1
a133 1
 *   in r300_emit_vertex_arrays (it must yield a positive offset when added to
d167 1
a167 1
    PREP_EMIT_STATES    = (1 << 0), /* call emit_dirty_state and friends? */
d169 2
a170 2
    PREP_EMIT_VARRAYS       = (1 << 2), /* call emit_vertex_arrays? */
    PREP_EMIT_VARRAYS_SWTCL = (1 << 3), /* call emit_vertex_arrays_swtcl? */
d183 2
a184 2
                                      enum r300_prepare_flags flags,
                                      unsigned cs_dwords)
d187 3
a189 3
    boolean emit_states    = flags & PREP_EMIT_STATES;
    boolean emit_vertex_arrays       = flags & PREP_EMIT_VARRAYS;
    boolean emit_vertex_arrays_swtcl = flags & PREP_EMIT_VARRAYS_SWTCL;
d195 1
a195 1
    if (r300->screen->caps.is_r500)
d207 2
a208 2
    if (cs_dwords > (RADEON_MAX_CMDBUF_DWORDS - r300->cs->cdw)) {
        r300_flush(&r300->context, RADEON_FLUSH_ASYNC, NULL);
d220 1
a220 1
 * \param buffer_offset The offset passed to emit_vertex_arrays.
a221 1
 * \param instance_id   Index of instance to render
d227 2
a228 2
                                int buffer_offset,
                                int index_bias, int instance_id)
d230 3
a232 3
    boolean emit_states    = flags & PREP_EMIT_STATES;
    boolean emit_vertex_arrays       = flags & PREP_EMIT_VARRAYS;
    boolean emit_vertex_arrays_swtcl = flags & PREP_EMIT_VARRAYS_SWTCL;
d236 19
a254 7
    /* Validate buffers and emit dirty state if needed. */
    if (emit_states || (emit_vertex_arrays && validate_vbos)) {
        if (!r300_emit_buffer_validate(r300, validate_vbos,
                                       index_buffer)) {
           fprintf(stderr, "r300: CS space validation failed. "
                   "(not enough memory?) Skipping rendering.\n");
           return FALSE;
a255 1
    }
a256 1
    if (emit_states)
d258 1
d260 1
a260 1
    if (r300->screen->caps.is_r500) {
d267 2
a268 12
    if (emit_vertex_arrays &&
        (r300->vertex_arrays_dirty ||
         r300->vertex_arrays_indexed != indexed ||
         r300->vertex_arrays_offset != buffer_offset ||
         r300->vertex_arrays_instance_id != instance_id)) {
        r300_emit_vertex_arrays(r300, buffer_offset, indexed, instance_id);

        r300->vertex_arrays_dirty = FALSE;
        r300->vertex_arrays_indexed = indexed;
        r300->vertex_arrays_offset = buffer_offset;
        r300->vertex_arrays_instance_id = instance_id;
    }
d271 1
a271 1
        r300_emit_vertex_arrays_swtcl(r300, indexed);
d283 1
a283 1
 * \param buffer_offset The offset passed to emit_vertex_arrays.
a284 1
 * \param instance_id The instance to render.
d291 2
a292 3
                                          int buffer_offset,
                                          int index_bias,
                                          int instance_id)
a293 1
    /* Make sure there is enough space in the command stream and emit states. */
d295 1
a295 1
        flags |= PREP_EMIT_STATES;
d297 1
a297 2
    return r300_emit_states(r300, flags, index_buffer, buffer_offset,
                            index_bias, instance_id);
d303 6
d313 4
d321 22
a342 2
    /* Buffers can only be used for read by r300 (except query buffers, but
     * those can't be bound by a state tracker as vertex buffers). */
d350 4
a353 2
static void r300_draw_arrays_immediate(struct r300_context *r300,
                                       const struct pipe_draw_info *info)
d364 1
a364 1
    unsigned dwords = 4 + info->count * vertex_size;
d374 1
a374 1
    uint32_t* map[PIPE_MAX_ATTRIBS] = {0};
d376 1
d380 1
a380 1
    if (!r300_prepare_for_rendering(r300, PREP_EMIT_STATES, NULL, dwords, 0, 0, -1))
d386 1
a386 1
        size[i] = r300->velems->format_size[i] / 4;
d392 6
a397 5
        if (!map[vbi]) {
            map[vbi] = (uint32_t*)r300->rws->buffer_map(
                r300_resource(vbuf->buffer)->cs_buf,
                r300->cs, PIPE_TRANSFER_READ | PIPE_TRANSFER_UNSYNCHRONIZED);
            map[vbi] += (vbuf->buffer_offset / 4) + stride[i] * info->start;
a401 2
    r300_emit_draw_init(r300, info->mode, info->count-1);

d403 2
d406 6
a411 3
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_IMMD_2, info->count * vertex_size);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_EMBEDDED | (info->count << 16) |
            r300_translate_primitive(info->mode));
d414 1
a414 1
    for (v = 0; v < info->count; v++) {
d420 11
d446 1
a446 3
    r300_emit_draw_init(r300, mode, count-1);

    BEGIN_CS(2 + (alt_num_verts ? 2 : 0));
d450 5
d465 2
a466 1
                                    unsigned max_index,
d469 1
a469 2
                                    unsigned count,
                                    uint16_t *imm_indices3)
d471 2
a472 1
    uint32_t count_dwords, offset_dwords;
d478 1
a478 1
                "refusing to render (max_index: %i).\n", count, max_index);
d482 1
a482 4
    DBG(r300, DBG_DRAW, "r300: Indexbuf of %u indices, max %u\n",
        count, max_index);

    r300_emit_draw_init(r300, mode, max_index);
d484 2
a485 12
    /* If start is odd, render the first triangle with indices embedded
     * in the command stream. This will increase start by 3 and make it
     * even. We can then proceed without a fallback. */
    if (indexSize == 2 && (start & 1) &&
        mode == PIPE_PRIM_TRIANGLES) {
        BEGIN_CS(4);
        OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, 2);
        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (3 << 16) |
               R300_VAP_VF_CNTL__PRIM_TRIANGLES);
        OUT_CS(imm_indices3[1] << 16 | imm_indices3[0]);
        OUT_CS(imm_indices3[2]);
        END_CS;
d487 1
a487 9
        start += 3;
        count -= 3;
        if (!count)
           return;
    }

    offset_dwords = indexSize * start / sizeof(uint32_t);

    BEGIN_CS(8 + (alt_num_verts ? 2 : 0));
d491 5
d510 5
d519 2
a520 39
    OUT_CS(count_dwords);
    OUT_CS_RELOC(r300_resource(indexBuffer));
    END_CS;
}

static void r300_draw_elements_immediate(struct r300_context *r300,
                                         const struct pipe_draw_info *info)
{
    const uint8_t *ptr1;
    const uint16_t *ptr2;
    const uint32_t *ptr4;
    unsigned index_size = r300->index_buffer.index_size;
    unsigned i, count_dwords = index_size == 4 ? info->count :
                                                 (info->count + 1) / 2;
    CS_LOCALS(r300);

    /* 19 dwords for r300_draw_elements_immediate. Give up if the function fails. */
    if (!r300_prepare_for_rendering(r300,
            PREP_EMIT_STATES | PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS |
            PREP_INDEXED, NULL, 2+count_dwords, 0, info->index_bias, -1))
        return;

    r300_emit_draw_init(r300, info->mode, info->max_index);

    BEGIN_CS(2 + count_dwords);
    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, count_dwords);

    switch (index_size) {
    case 1:
        ptr1 = (uint8_t*)r300->index_buffer.user_buffer;
        ptr1 += info->start;

        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (info->count << 16) |
               r300_translate_primitive(info->mode));

        if (info->index_bias && !r300->screen->caps.is_r500) {
            for (i = 0; i < info->count-1; i += 2)
                OUT_CS(((ptr1[i+1] + info->index_bias) << 16) |
                        (ptr1[i]   + info->index_bias));
a521 47
            if (info->count & 1)
                OUT_CS(ptr1[i] + info->index_bias);
        } else {
            for (i = 0; i < info->count-1; i += 2)
                OUT_CS(((ptr1[i+1]) << 16) |
                        (ptr1[i]  ));

            if (info->count & 1)
                OUT_CS(ptr1[i]);
        }
        break;

    case 2:
        ptr2 = (uint16_t*)r300->index_buffer.user_buffer;
        ptr2 += info->start;

        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (info->count << 16) |
               r300_translate_primitive(info->mode));

        if (info->index_bias && !r300->screen->caps.is_r500) {
            for (i = 0; i < info->count-1; i += 2)
                OUT_CS(((ptr2[i+1] + info->index_bias) << 16) |
                        (ptr2[i]   + info->index_bias));

            if (info->count & 1)
                OUT_CS(ptr2[i] + info->index_bias);
        } else {
            OUT_CS_TABLE(ptr2, count_dwords);
        }
        break;

    case 4:
        ptr4 = (uint32_t*)r300->index_buffer.user_buffer;
        ptr4 += info->start;

        OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (info->count << 16) |
               R300_VAP_VF_CNTL__INDEX_SIZE_32bit |
               r300_translate_primitive(info->mode));

        if (info->index_bias && !r300->screen->caps.is_r500) {
            for (i = 0; i < info->count; i++)
                OUT_CS(ptr4[i] + info->index_bias);
        } else {
            OUT_CS_TABLE(ptr4, count_dwords);
        }
        break;
    }
d525 10
a534 3
static void r300_draw_elements(struct r300_context *r300,
                               const struct pipe_draw_info *info,
                               int instance_id)
d536 1
a536 2
    struct pipe_resource *indexBuffer = r300->index_buffer.buffer;
    unsigned indexSize = r300->index_buffer.index_size;
a537 2
    unsigned start = info->start;
    unsigned count = info->count;
d539 2
a540 1
                            count > 65536;
d543 5
a547 1
    uint16_t indices3[3];
d549 2
a550 15
    if (info->index_bias && !r300->screen->caps.is_r500) {
        r300_split_index_bias(r300, info->index_bias, &buffer_offset,
                              &index_offset);
    }

    r300_translate_index_buffer(r300, &r300->index_buffer, &indexBuffer,
                                &indexSize, index_offset, &start, count);

    /* Fallback for misaligned ushort indices. */
    if (indexSize == 2 && (start & 1) && indexBuffer) {
        /* If we got here, then orgIndexBuffer == indexBuffer. */
        uint16_t *ptr = r300->rws->buffer_map(r300_resource(orgIndexBuffer)->cs_buf,
                                              r300->cs,
                                              PIPE_TRANSFER_READ |
                                              PIPE_TRANSFER_UNSYNCHRONIZED);
d552 4
a555 15
        if (info->mode == PIPE_PRIM_TRIANGLES) {
           memcpy(indices3, ptr + start, 6);
        } else {
            /* Copy the mapped index buffer directly to the upload buffer.
             * The start index will be aligned simply from the fact that
             * every sub-buffer in the upload buffer is aligned. */
            r300_upload_index_buffer(r300, &indexBuffer, indexSize, &start,
                                     count, (uint8_t*)ptr);
        }
    } else {
        if (r300->index_buffer.user_buffer)
            r300_upload_index_buffer(r300, &indexBuffer, indexSize,
                                     &start, count,
                                     r300->index_buffer.user_buffer);
    }
d557 1
a557 1
    /* 19 dwords for emit_draw_elements. Give up if the function fails. */
d559 2
a560 3
            PREP_EMIT_STATES | PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS |
            PREP_INDEXED, indexBuffer, 19, buffer_offset, info->index_bias,
            instance_id))
d565 1
a565 2
                                info->max_index, info->mode, start, count,
                                indices3);
d575 2
a576 2
                                     info->max_index,
                                     info->mode, start, short_count, indices3);
d584 2
a585 3
                        PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS | PREP_INDEXED,
                        indexBuffer, 19, buffer_offset, info->index_bias,
                        instance_id))
d597 2
a598 3
static void r300_draw_arrays(struct r300_context *r300,
                             const struct pipe_draw_info *info,
                             int instance_id)
d600 1
d602 2
a603 3
                            info->count > 65536;
    unsigned start = info->start;
    unsigned count = info->count;
d606 1
a606 5
    /* 9 spare dwords for emit_draw_arrays. Give up if the function fails. */
    if (!r300_prepare_for_rendering(r300,
                                    PREP_EMIT_STATES | PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS,
                                    NULL, 9, start, 0, instance_id))
        return;
d608 2
a609 2
    if (alt_num_verts || count <= 65535) {
        r300_emit_draw_arrays(r300, info->mode, count);
d611 5
a615 7
        do {
            /* The maximum must be divisible by 4 and 3,
             * so that quad and triangle lists are split correctly.
             *
             * Strips, loops, and fans won't work. */
            short_count = MIN2(count, 65532);
            r300_emit_draw_arrays(r300, info->mode, short_count);
d617 23
a639 11
            start += short_count;
            count -= short_count;

            /* 9 spare dwords for emit_draw_arrays. Give up if the function fails. */
            if (count) {
                if (!r300_prepare_for_rendering(r300,
                                                PREP_VALIDATE_VBOS | PREP_EMIT_VARRAYS, NULL, 9,
                                                start, 0, instance_id))
                    return;
            }
        } while (count);
a642 67
static void r300_draw_arrays_instanced(struct r300_context *r300,
                                       const struct pipe_draw_info *info)
{
    int i;

    for (i = 0; i < info->instance_count; i++)
        r300_draw_arrays(r300, info, i);
}

static void r300_draw_elements_instanced(struct r300_context *r300,
                                         const struct pipe_draw_info *info)
{
    int i;

    for (i = 0; i < info->instance_count; i++)
        r300_draw_elements(r300, info, i);
}

static unsigned r300_max_vertex_count(struct r300_context *r300)
{
   unsigned i, nr = r300->velems->count;
   struct pipe_vertex_element *velems = r300->velems->velem;
   unsigned result = ~0;

   for (i = 0; i < nr; i++) {
      struct pipe_vertex_buffer *vb =
            &r300->vertex_buffer[velems[i].vertex_buffer_index];
      unsigned size, max_count, value;

      /* We're not interested in constant and per-instance attribs. */
      if (!vb->buffer ||
          !vb->stride ||
          velems[i].instance_divisor) {
         continue;
      }

      size = vb->buffer->width0;

      /* Subtract buffer_offset. */
      value = vb->buffer_offset;
      if (value >= size) {
         return 0;
      }
      size -= value;

      /* Subtract src_offset. */
      value = velems[i].src_offset;
      if (value >= size) {
         return 0;
      }
      size -= value;

      /* Subtract format_size. */
      value = r300->velems->format_size[i];
      if (value >= size) {
         return 0;
      }
      size -= value;

      /* Compute the max count. */
      max_count = 1 + size / vb->stride;
      result = MIN2(result, max_count);
   }
   return result;
}


d644 1
a644 1
                          const struct pipe_draw_info *dinfo)
d647 4
a650 1
    struct pipe_draw_info info = *dinfo;
d652 3
a654 1
    info.indexed = info.indexed;
d656 1
a656 2
    if (r300->skip_rendering ||
        !u_trim_pipe_prim(info.mode, &info.count)) {
d660 13
a672 10
    r300_update_derived_state(r300);

    /* Draw. */
    if (info.indexed) {
        unsigned max_count = r300_max_vertex_count(r300);

        if (!max_count) {
           fprintf(stderr, "r300: Skipping a draw command. There is a buffer "
                   " which is too small to be used for rendering.\n");
           return;
d674 1
d676 22
a697 4
        if (max_count == ~0) {
           /* There are no per-vertex vertex elements. Use the hardware maximum. */
           max_count = 0xffffff;
        }
d699 2
a700 23
        info.max_index = max_count - 1;
        info.start += r300->index_buffer.offset / r300->index_buffer.index_size;

        if (info.instance_count <= 1) {
            if (info.count <= 8 &&
                r300->index_buffer.user_buffer) {
                r300_draw_elements_immediate(r300, &info);
            } else {
                r300_draw_elements(r300, &info, -1);
            }
        } else {
            r300_draw_elements_instanced(r300, &info);
        }
    } else {
        if (info.instance_count <= 1) {
            if (immd_is_good_idea(r300, info.count)) {
                r300_draw_arrays_immediate(r300, &info);
            } else {
                r300_draw_arrays(r300, &info, -1);
            }
        } else {
            r300_draw_arrays_instanced(r300, &info);
        }
d714 6
d725 4
d731 24
d757 14
d788 3
a790 1
    uint8_t *vbo_ptr;
d809 2
a810 2
                                             ushort vertex_size,
                                             ushort count)
d814 1
a814 1
    struct radeon_winsys *rws = r300->rws;
d819 6
a824 13
    if (!r300->vbo || size + r300->draw_vbo_offset > r300->vbo->size) {
	pb_reference(&r300->vbo, NULL);
        r300->vbo_cs = NULL;
        r300render->vbo_ptr = NULL;

        r300->vbo = rws->buffer_create(rws,
                                       MAX2(R300_MAX_DRAW_VBO_SIZE, size),
                                       R300_BUFFER_ALIGNMENT, TRUE,
                                       RADEON_DOMAIN_GTT);
        if (!r300->vbo) {
            return FALSE;
        }
        r300->vbo_cs = rws->buffer_get_cs_handle(r300->vbo);
d826 2
a827 2
        r300render->vbo_ptr = rws->buffer_map(r300->vbo_cs, r300->cs,
                                              PIPE_TRANSFER_WRITE);
d831 2
a832 1
    return TRUE;
d840 2
d844 5
d850 2
a851 1
    return r300render->vbo_ptr + r300->draw_vbo_offset;
d859 1
d862 2
d868 3
d884 2
a885 2
static void r300_render_set_primitive(struct vbuf_render* render,
                                      unsigned prim)
d891 2
a907 3
    assert(start == 0);
    assert(count < (1 << 16));

d910 28
a937 5
    if (!r300_prepare_for_rendering(r300,
                                    PREP_EMIT_STATES | PREP_EMIT_VARRAYS_SWTCL,
                                    NULL, dwords, 0, 0, -1)) {
        return;
    }
d947 2
d957 3
a959 1
    unsigned max_index = (r300->vbo->size - r300->draw_vbo_offset) /
d961 2
a962 2
    struct pipe_resource *index_buffer = NULL;
    unsigned index_buffer_offset;
d967 47
a1013 5
    u_upload_data(r300->uploader, 0, count * 2, indices,
                  &index_buffer_offset, &index_buffer);
    if (!index_buffer) {
        return;
    }
d1015 2
a1016 6
    if (!r300_prepare_for_rendering(r300,
                                    PREP_EMIT_STATES |
                                    PREP_EMIT_VARRAYS_SWTCL | PREP_INDEXED,
                                    index_buffer, 12, 0, 0, -1)) {
        pipe_resource_reference(&index_buffer, NULL);
        return;
d1019 1
a1019 17
    BEGIN_CS(12);
    OUT_CS_REG(R300_GA_COLOR_CONTROL,
               r300_provoking_vertex_fixes(r300, r300render->prim));
    OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, max_index);

    OUT_CS_PKT3(R300_PACKET3_3D_DRAW_INDX_2, 0);
    OUT_CS(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (count << 16) |
           r300render->hwprim);

    OUT_CS_PKT3(R300_PACKET3_INDX_BUFFER, 2);
    OUT_CS(R300_INDX_BUFFER_ONE_REG_WR | (R300_VAP_PORT_IDX0 >> 2));
    OUT_CS(index_buffer_offset);
    OUT_CS((count + 1) / 2);
    OUT_CS_RELOC(r300_resource(index_buffer));
    END_CS;

    pipe_resource_reference(&index_buffer, NULL);
d1033 2
a1034 1
    r300render->base.max_vertex_buffer_bytes = R300_MAX_DRAW_VBO_SIZE;
d1073 6
d1088 6
a1093 5
void r300_blitter_draw_rectangle(struct blitter_context *blitter,
                                 int x1, int y1, int x2, int y2,
                                 float depth,
                                 enum blitter_attrib_type type,
                                 const union pipe_color_union *attrib)
d1103 1
a1103 1
    static const union pipe_color_union zeros;
d1106 1
a1106 4
    /* XXX workaround for a lockup in MSAA resolve on SWTCL chipsets, this
     * function most probably doesn't handle type=NONE correctly */
    if (!r300->screen->caps.has_tcl && type == UTIL_BLITTER_ATTRIB_NONE) {
        util_blitter_draw_rectangle(blitter, x1, y1, x2, y2, depth, type, attrib);
a1107 1
    }
d1109 1
a1109 2
    if (r300->skip_rendering)
        return;
d1117 1
d1120 1
a1120 1
    if (!r300_prepare_for_rendering(r300, PREP_EMIT_STATES, NULL, dwords, 0, 0, -1))
d1134 4
a1137 4
        OUT_CS_32F(attrib->f[0]);
        OUT_CS_32F(attrib->f[3]);
        OUT_CS_32F(attrib->f[2]);
        OUT_CS_32F(attrib->f[1]);
d1160 2
a1161 2
            attrib = &zeros;
        OUT_CS_TABLE(attrib->f, 4);
d1167 1
d1174 46
d1228 3
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d787 2
d910 1
a910 1
                                       RADEON_DOMAIN_GTT, 0);
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@a786 2
    info.indexed = info.indexed;

d908 1
a908 1
                                       RADEON_DOMAIN_GTT);
@


