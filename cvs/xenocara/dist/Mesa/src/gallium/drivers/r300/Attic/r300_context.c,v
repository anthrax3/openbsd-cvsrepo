head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.09.07.15.20.06;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.56;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.06;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.02.35;	author jsg;	state Exp;
branches;
next	;
commitid	dm8VnQHhowGHmemJ;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "draw/draw_context.h"

#include "util/u_memory.h"
#include "util/u_sampler.h"
#include "util/u_simple_list.h"
#include "util/u_upload_mgr.h"
#include "os/os_time.h"
#include "vl/vl_decoder.h"
#include "vl/vl_video_buffer.h"

#include "r300_cb.h"
#include "r300_context.h"
#include "r300_emit.h"
#include "r300_screen.h"
#include "r300_screen_buffer.h"
#include "compiler/radeon_regalloc.h"

#include <inttypes.h>

static void r300_release_referenced_objects(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_textures_state *textures =
            (struct r300_textures_state*)r300->textures_state.state;
    unsigned i;

    /* Framebuffer state. */
    util_unreference_framebuffer_state(fb);

    /* Textures. */
    for (i = 0; i < textures->sampler_view_count; i++)
        pipe_sampler_view_reference(
                (struct pipe_sampler_view**)&textures->sampler_views[i], NULL);

    /* The special dummy texture for texkill. */
    if (r300->texkill_sampler) {
        pipe_sampler_view_reference(
                (struct pipe_sampler_view**)&r300->texkill_sampler,
                NULL);
    }

    /* Manually-created vertex buffers. */
    pipe_resource_reference(&r300->dummy_vb.buffer, NULL);
    pb_reference(&r300->vbo, NULL);

    r300->context.delete_depth_stencil_alpha_state(&r300->context,
                                                   r300->dsa_decompress_zmask);
}

static void r300_destroy_context(struct pipe_context* context)
{
    struct r300_context* r300 = r300_context(context);

    if (r300->cs && r300->hyperz_enabled) {
        r300->rws->cs_request_feature(r300->cs, RADEON_FID_R300_HYPERZ_ACCESS, FALSE);
    }
    if (r300->cs && r300->cmask_access) {
        r300->rws->cs_request_feature(r300->cs, RADEON_FID_R300_CMASK_ACCESS, FALSE);
    }

    if (r300->blitter)
        util_blitter_destroy(r300->blitter);
    if (r300->draw)
        draw_destroy(r300->draw);

    if (r300->uploader)
        u_upload_destroy(r300->uploader);

    /* XXX: This function assumes r300->query_list was initialized */
    r300_release_referenced_objects(r300);

    if (r300->cs)
        r300->rws->cs_destroy(r300->cs);

    rc_destroy_regalloc_state(&r300->fs_regalloc_state);

    /* XXX: No way to tell if this was initialized or not? */
    util_slab_destroy(&r300->pool_transfers);

    /* Free the structs allocated in r300_setup_atoms() */
    if (r300->aa_state.state) {
        FREE(r300->aa_state.state);
        FREE(r300->blend_color_state.state);
        FREE(r300->clip_state.state);
        FREE(r300->fb_state.state);
        FREE(r300->gpu_flush.state);
        FREE(r300->hyperz_state.state);
        FREE(r300->invariant_state.state);
        FREE(r300->rs_block_state.state);
        FREE(r300->sample_mask.state);
        FREE(r300->scissor_state.state);
        FREE(r300->textures_state.state);
        FREE(r300->vap_invariant_state.state);
        FREE(r300->viewport_state.state);
        FREE(r300->ztop_state.state);
        FREE(r300->fs_constants.state);
        FREE(r300->vs_constants.state);
        if (!r300->screen->caps.has_tcl) {
            FREE(r300->vertex_stream_state.state);
        }
    }
    FREE(r300);
}

static void r300_flush_callback(void *data, unsigned flags,
				struct pipe_fence_handle **fence)
{
    struct r300_context* const cs_context_copy = data;

    r300_flush(&cs_context_copy->context, flags, fence);
}

#define R300_INIT_ATOM(atomname, atomsize) \
 do { \
    r300->atomname.name = #atomname; \
    r300->atomname.state = NULL; \
    r300->atomname.size = atomsize; \
    r300->atomname.emit = r300_emit_##atomname; \
    r300->atomname.dirty = FALSE; \
 } while (0)

#define R300_ALLOC_ATOM(atomname, statetype) \
do { \
    r300->atomname.state = CALLOC_STRUCT(statetype); \
    if (r300->atomname.state == NULL) \
        return FALSE; \
} while (0)

static boolean r300_setup_atoms(struct r300_context* r300)
{
    boolean is_rv350 = r300->screen->caps.is_rv350;
    boolean is_r500 = r300->screen->caps.is_r500;
    boolean has_tcl = r300->screen->caps.has_tcl;
    boolean drm_2_6_0 = r300->screen->info.drm_minor >= 6;

    /* Create the actual atom list.
     *
     * Some atoms never change size, others change every emit - those have
     * the size of 0 here.
     *
     * NOTE: The framebuffer state is split into these atoms:
     * - gpu_flush          (unpipelined regs)
     * - aa_state           (unpipelined regs)
     * - fb_state           (unpipelined regs)
     * - hyperz_state       (unpipelined regs followed by pipelined ones)
     * - fb_state_pipelined (pipelined regs)
     * The motivation behind this is to be able to emit a strict
     * subset of the regs, and to have reasonable register ordering. */
    /* SC, GB (unpipelined), RB3D (unpipelined), ZB (unpipelined). */
    R300_INIT_ATOM(gpu_flush, 9);
    R300_INIT_ATOM(aa_state, 4);
    R300_INIT_ATOM(fb_state, 0);
    R300_INIT_ATOM(hyperz_state, is_r500 || (is_rv350 && drm_2_6_0) ? 10 : 8);
    /* ZB (unpipelined), SC. */
    R300_INIT_ATOM(ztop_state, 2);
    /* ZB, FG. */
    R300_INIT_ATOM(dsa_state, is_r500 ? (drm_2_6_0 ? 10 : 8) : 6);
    /* RB3D. */
    R300_INIT_ATOM(blend_state, 8);
    R300_INIT_ATOM(blend_color_state, is_r500 ? 3 : 2);
    /* SC. */
    R300_INIT_ATOM(sample_mask, 2);
    R300_INIT_ATOM(scissor_state, 3);
    /* GB, FG, GA, SU, SC, RB3D. */
    R300_INIT_ATOM(invariant_state, 14 + (is_rv350 ? 4 : 0) + (is_r500 ? 4 : 0));
    /* VAP. */
    R300_INIT_ATOM(viewport_state, 9);
    R300_INIT_ATOM(pvs_flush, 2);
    R300_INIT_ATOM(vap_invariant_state, is_r500 ? 11 : 9);
    R300_INIT_ATOM(vertex_stream_state, 0);
    R300_INIT_ATOM(vs_state, 0);
    R300_INIT_ATOM(vs_constants, 0);
    R300_INIT_ATOM(clip_state, has_tcl ? 3 + (6 * 4) : 0);
    /* VAP, RS, GA, GB, SU, SC. */
    R300_INIT_ATOM(rs_block_state, 0);
    R300_INIT_ATOM(rs_state, 0);
    /* SC, US. */
    R300_INIT_ATOM(fb_state_pipelined, 8);
    /* US. */
    R300_INIT_ATOM(fs, 0);
    R300_INIT_ATOM(fs_rc_constant_state, 0);
    R300_INIT_ATOM(fs_constants, 0);
    /* TX. */
    R300_INIT_ATOM(texture_cache_inval, 2);
    R300_INIT_ATOM(textures_state, 0);
    /* Clear commands */
    R300_INIT_ATOM(hiz_clear, r300->screen->caps.hiz_ram > 0 ? 4 : 0);
    R300_INIT_ATOM(zmask_clear, r300->screen->caps.zmask_ram > 0 ? 4 : 0);
    R300_INIT_ATOM(cmask_clear, 4);
    /* ZB (unpipelined), SU. */
    R300_INIT_ATOM(query_start, 4);

    /* Replace emission functions for r500. */
    if (is_r500) {
        r300->fs.emit = r500_emit_fs;
        r300->fs_rc_constant_state.emit = r500_emit_fs_rc_constant_state;
        r300->fs_constants.emit = r500_emit_fs_constants;
    }

    /* Some non-CSO atoms need explicit space to store the state locally. */
    R300_ALLOC_ATOM(aa_state, r300_aa_state);
    R300_ALLOC_ATOM(blend_color_state, r300_blend_color_state);
    R300_ALLOC_ATOM(clip_state, r300_clip_state);
    R300_ALLOC_ATOM(hyperz_state, r300_hyperz_state);
    R300_ALLOC_ATOM(invariant_state, r300_invariant_state);
    R300_ALLOC_ATOM(textures_state, r300_textures_state);
    R300_ALLOC_ATOM(vap_invariant_state, r300_vap_invariant_state);
    R300_ALLOC_ATOM(viewport_state, r300_viewport_state);
    R300_ALLOC_ATOM(ztop_state, r300_ztop_state);
    R300_ALLOC_ATOM(fb_state, pipe_framebuffer_state);
    R300_ALLOC_ATOM(gpu_flush, pipe_framebuffer_state);
    r300->sample_mask.state = malloc(4);
    R300_ALLOC_ATOM(scissor_state, pipe_scissor_state);
    R300_ALLOC_ATOM(rs_block_state, r300_rs_block);
    R300_ALLOC_ATOM(fs_constants, r300_constant_buffer);
    R300_ALLOC_ATOM(vs_constants, r300_constant_buffer);
    if (!r300->screen->caps.has_tcl) {
        R300_ALLOC_ATOM(vertex_stream_state, r300_vertex_stream_state);
    }

    /* Some non-CSO atoms don't use the state pointer. */
    r300->fb_state_pipelined.allow_null_state = TRUE;
    r300->fs_rc_constant_state.allow_null_state = TRUE;
    r300->pvs_flush.allow_null_state = TRUE;
    r300->query_start.allow_null_state = TRUE;
    r300->texture_cache_inval.allow_null_state = TRUE;

    /* Some states must be marked as dirty here to properly set up
     * hardware in the first command stream. */
    r300_mark_atom_dirty(r300, &r300->invariant_state);
    r300_mark_atom_dirty(r300, &r300->pvs_flush);
    r300_mark_atom_dirty(r300, &r300->vap_invariant_state);
    r300_mark_atom_dirty(r300, &r300->texture_cache_inval);
    r300_mark_atom_dirty(r300, &r300->textures_state);

    return TRUE;
}

/* Not every state tracker calls every driver function before the first draw
 * call and we must initialize the command buffers somehow. */
static void r300_init_states(struct pipe_context *pipe)
{
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_blend_color bc = {{0}};
    struct pipe_clip_state cs = {{{0}}};
    struct pipe_scissor_state ss = {0};
    struct r300_gpu_flush *gpuflush =
            (struct r300_gpu_flush*)r300->gpu_flush.state;
    struct r300_vap_invariant_state *vap_invariant =
            (struct r300_vap_invariant_state*)r300->vap_invariant_state.state;
    struct r300_invariant_state *invariant =
            (struct r300_invariant_state*)r300->invariant_state.state;

    CB_LOCALS;

    pipe->set_blend_color(pipe, &bc);
    pipe->set_clip_state(pipe, &cs);
    pipe->set_scissor_states(pipe, 0, 1, &ss);
    pipe->set_sample_mask(pipe, ~0);

    /* Initialize the GPU flush. */
    {
        BEGIN_CB(gpuflush->cb_flush_clean, 6);

        /* Flush and free renderbuffer caches. */
        OUT_CB_REG(R300_RB3D_DSTCACHE_CTLSTAT,
            R300_RB3D_DSTCACHE_CTLSTAT_DC_FREE_FREE_3D_TAGS |
            R300_RB3D_DSTCACHE_CTLSTAT_DC_FLUSH_FLUSH_DIRTY_3D);
        OUT_CB_REG(R300_ZB_ZCACHE_CTLSTAT,
            R300_ZB_ZCACHE_CTLSTAT_ZC_FLUSH_FLUSH_AND_FREE |
            R300_ZB_ZCACHE_CTLSTAT_ZC_FREE_FREE);

        /* Wait until the GPU is idle.
         * This fixes random pixels sometimes appearing probably caused
         * by incomplete rendering. */
        OUT_CB_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
        END_CB;
    }

    /* Initialize the VAP invariant state. */
    {
        BEGIN_CB(vap_invariant->cb, r300->vap_invariant_state.size);
        OUT_CB_REG(VAP_PVS_VTX_TIMEOUT_REG, 0xffff);
        OUT_CB_REG_SEQ(R300_VAP_GB_VERT_CLIP_ADJ, 4);
        OUT_CB_32F(1.0);
        OUT_CB_32F(1.0);
        OUT_CB_32F(1.0);
        OUT_CB_32F(1.0);
        OUT_CB_REG(R300_VAP_PSC_SGN_NORM_CNTL, R300_SGN_NORM_NO_ZERO);

        if (r300->screen->caps.is_r500) {
            OUT_CB_REG(R500_VAP_TEX_TO_COLOR_CNTL, 0);
        }
        END_CB;
    }

    /* Initialize the invariant state. */
    {
        BEGIN_CB(invariant->cb, r300->invariant_state.size);
        OUT_CB_REG(R300_GB_SELECT, 0);
        OUT_CB_REG(R300_FG_FOG_BLEND, 0);
        OUT_CB_REG(R300_GA_OFFSET, 0);
        OUT_CB_REG(R300_SU_TEX_WRAP, 0);
        OUT_CB_REG(R300_SU_DEPTH_SCALE, 0x4B7FFFFF);
        OUT_CB_REG(R300_SU_DEPTH_OFFSET, 0);
        OUT_CB_REG(R300_SC_EDGERULE, 0x2DA49525);

        if (r300->screen->caps.is_rv350) {
            OUT_CB_REG(R500_RB3D_DISCARD_SRC_PIXEL_LTE_THRESHOLD, 0x01010101);
            OUT_CB_REG(R500_RB3D_DISCARD_SRC_PIXEL_GTE_THRESHOLD, 0xFEFEFEFE);
        }

        if (r300->screen->caps.is_r500) {
            OUT_CB_REG(R500_GA_COLOR_CONTROL_PS3, 0);
            OUT_CB_REG(R500_SU_TEX_WRAP_PS3, 0);
        }
        END_CB;
    }

    /* Initialize the hyperz state. */
    {
        struct r300_hyperz_state *hyperz =
            (struct r300_hyperz_state*)r300->hyperz_state.state;
        BEGIN_CB(&hyperz->cb_flush_begin, r300->hyperz_state.size);
        OUT_CB_REG(R300_ZB_ZCACHE_CTLSTAT,
                   R300_ZB_ZCACHE_CTLSTAT_ZC_FLUSH_FLUSH_AND_FREE);
        OUT_CB_REG(R300_ZB_BW_CNTL, 0);
        OUT_CB_REG(R300_ZB_DEPTHCLEARVALUE, 0);
        OUT_CB_REG(R300_SC_HYPERZ, R300_SC_HYPERZ_ADJ_2);

        if (r300->screen->caps.is_r500 ||
            (r300->screen->caps.is_rv350 &&
             r300->screen->info.drm_minor >= 6)) {
            OUT_CB_REG(R300_GB_Z_PEQ_CONFIG, 0);
        }
        END_CB;
    }
}

struct pipe_context* r300_create_context(struct pipe_screen* screen,
                                         void *priv)
{
    struct r300_context* r300 = CALLOC_STRUCT(r300_context);
    struct r300_screen* r300screen = r300_screen(screen);
    struct radeon_winsys *rws = r300screen->rws;

    if (!r300)
        return NULL;

    r300->rws = rws;
    r300->screen = r300screen;

    r300->context.screen = screen;
    r300->context.priv = priv;

    r300->context.destroy = r300_destroy_context;

    util_slab_create(&r300->pool_transfers,
                     sizeof(struct pipe_transfer), 64,
                     UTIL_SLAB_SINGLETHREADED);

    r300->cs = rws->cs_create(rws, RING_GFX, r300_flush_callback, r300, NULL);
    if (r300->cs == NULL)
        goto fail;

    if (!r300screen->caps.has_tcl) {
        /* Create a Draw. This is used for SW TCL. */
        r300->draw = draw_create(&r300->context);
        if (r300->draw == NULL)
            goto fail;
        /* Enable our renderer. */
        draw_set_rasterize_stage(r300->draw, r300_draw_stage(r300));
        /* Disable converting points/lines to triangles. */
        draw_wide_line_threshold(r300->draw, 10000000.f);
        draw_wide_point_threshold(r300->draw, 10000000.f);
        draw_wide_point_sprites(r300->draw, FALSE);
        draw_enable_line_stipple(r300->draw, TRUE);
        draw_enable_point_sprites(r300->draw, FALSE);
    }

    if (!r300_setup_atoms(r300))
        goto fail;

    r300_init_blit_functions(r300);
    r300_init_flush_functions(r300);
    r300_init_query_functions(r300);
    r300_init_state_functions(r300);
    r300_init_resource_functions(r300);
    r300_init_render_functions(r300);
    r300_init_states(&r300->context);

    r300->context.create_video_codec = vl_create_decoder;
    r300->context.create_video_buffer = vl_video_buffer_create;

    r300->uploader = u_upload_create(&r300->context, 256 * 1024, 4,
                                     PIPE_BIND_CUSTOM);

    r300->blitter = util_blitter_create(&r300->context);
    if (r300->blitter == NULL)
        goto fail;
    r300->blitter->draw_rectangle = r300_blitter_draw_rectangle;

    /* The KIL opcode needs the first texture unit to be enabled
     * on r3xx-r4xx. In order to calm down the CS checker, we bind this
     * dummy texture there. */
    if (!r300->screen->caps.is_r500) {
        struct pipe_resource *tex;
        struct pipe_resource rtempl = {{0}};
        struct pipe_sampler_view vtempl = {{0}};

        rtempl.target = PIPE_TEXTURE_2D;
        rtempl.format = PIPE_FORMAT_I8_UNORM;
        rtempl.usage = PIPE_USAGE_IMMUTABLE;
        rtempl.width0 = 1;
        rtempl.height0 = 1;
        rtempl.depth0 = 1;
        tex = screen->resource_create(screen, &rtempl);

        u_sampler_view_default_template(&vtempl, tex, tex->format);

        r300->texkill_sampler = (struct r300_sampler_view*)
            r300->context.create_sampler_view(&r300->context, tex, &vtempl);

        pipe_resource_reference(&tex, NULL);
    }

    if (r300screen->caps.has_tcl) {
        struct pipe_resource vb;
        memset(&vb, 0, sizeof(vb));
        vb.target = PIPE_BUFFER;
        vb.format = PIPE_FORMAT_R8_UNORM;
        vb.usage = PIPE_USAGE_DEFAULT;
        vb.width0 = sizeof(float) * 16;
        vb.height0 = 1;
        vb.depth0 = 1;

        r300->dummy_vb.buffer = screen->resource_create(screen, &vb);
        r300->context.set_vertex_buffers(&r300->context, 0, 1, &r300->dummy_vb);
    }

    {
        struct pipe_depth_stencil_alpha_state dsa;
        memset(&dsa, 0, sizeof(dsa));
        dsa.depth.writemask = 1;

        r300->dsa_decompress_zmask =
            r300->context.create_depth_stencil_alpha_state(&r300->context,
                                                           &dsa);
    }

    r300->hyperz_time_of_last_flush = os_time_get();

    /* Register allocator state */
    rc_init_regalloc_state(&r300->fs_regalloc_state);

    /* Print driver info. */
#ifdef DEBUG
    {
#else
    if (DBG_ON(r300, DBG_INFO)) {
#endif
        fprintf(stderr,
                "r300: DRM version: %d.%d.%d, Name: %s, ID: 0x%04x, GB: %d, Z: %d\n"
                "r300: GART size: %"PRIu64" MB, VRAM size: %"PRIu64" MB\n"
                "r300: AA compression RAM: %s, Z compression RAM: %s, HiZ RAM: %s\n",
                r300->screen->info.drm_major,
                r300->screen->info.drm_minor,
                r300->screen->info.drm_patchlevel,
                screen->get_name(screen),
                r300->screen->info.pci_id,
                r300->screen->info.r300_num_gb_pipes,
                r300->screen->info.r300_num_z_pipes,
                r300->screen->info.gart_size >> 20,
                r300->screen->info.vram_size >> 20,
                "YES", /* XXX really? */
                r300->screen->caps.zmask_ram ? "YES" : "NO",
                r300->screen->caps.hiz_ram ? "YES" : "NO");
    }

    return &r300->context;

fail:
    r300_destroy_context(&r300->context);
    return NULL;
}
@


1.6
log
@Merge Mesa 10.2.7
@
text
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d40 2
d487 1
a487 1
                "r300: GART size: %d MB, VRAM size: %d MB\n"
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d126 2
a127 1
static void r300_flush_callback(void *data, unsigned flags)
d131 1
a131 1
    r300_flush(&cs_context_copy->context, flags, NULL);
d383 1
a383 1
    r300->cs = rws->cs_create(rws, RING_GFX, NULL);
d413 1
a413 1
    r300->context.create_video_decoder = vl_create_decoder;
a423 2
    rws->cs_set_flush_callback(r300->cs, r300_flush_callback, r300);

d453 1
a453 1
        vb.usage = PIPE_USAGE_STATIC;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d30 2
d38 1
a38 20

static void r300_update_num_contexts(struct r300_screen *r300screen,
                                     int diff)
{
    pipe_mutex_lock(r300screen->num_contexts_mutex);
    if (diff > 0) {
        r300screen->num_contexts++;

        if (r300screen->num_contexts > 1)
            util_slab_set_thread_safety(&r300screen->pool_buffers,
                                        UTIL_SLAB_MULTITHREADED);
    } else {
        r300screen->num_contexts--;

        if (r300screen->num_contexts <= 1)
            util_slab_set_thread_safety(&r300screen->pool_buffers,
                                        UTIL_SLAB_SINGLETHREADED);
    }
    pipe_mutex_unlock(r300screen->num_contexts_mutex);
}
a45 1
    struct r300_query *query, *temp;
d64 2
a65 8
    pipe_resource_reference(&r300->dummy_vb, NULL);
    pipe_resource_reference(&r300->vbo, NULL);

    /* If there are any queries pending or not destroyed, remove them now. */
    foreach_s(query, temp, &r300->query_list) {
        remove_from_list(query);
        FREE(query);
    }
d76 4
a79 1
        r300->rws->cs_request_feature(r300->cs, RADEON_FID_HYPERZ_RAM_ACCESS, FALSE);
d87 2
a88 2
    if (r300->vbuf_mgr)
        u_vbuf_destroy(r300->vbuf_mgr);
d96 2
a100 2
    r300_update_num_contexts(r300->screen, -1);

d111 1
d154 1
a154 1
    boolean drm_2_6_0 = r300->rws->get_value(r300->rws, RADEON_VID_DRM_2_6_0);
d182 1
d185 1
a185 1
    R300_INIT_ATOM(invariant_state, 16 + (is_rv350 ? 4 : 0) + (is_r500 ? 4 : 0));
d193 1
a193 1
    R300_INIT_ATOM(clip_state, has_tcl ? 5 + (6 * 4) : 2);
d206 1
a206 1
    /* HiZ Clear */
a207 1
    /* zmask clear */
d209 1
d232 1
a266 2
    struct r300_clip_state *clip =
            (struct r300_clip_state*)r300->clip_state.state;
d277 3
a279 10
    pipe->set_scissor_state(pipe, &ss);

    /* Initialize the clip state. */
    if (r300->screen->caps.has_tcl) {
        pipe->set_clip_state(pipe, &cs);
    } else {
        BEGIN_CB(clip->cb, 2);
        OUT_CB_REG(R300_VAP_CLIP_CNTL, R300_CLIP_DISABLE);
        END_CB;
    }
a326 1
        OUT_CB_REG(R300_SC_SCREENDOOR, 0xffffff);
d353 1
a353 1
             r300->rws->get_value(r300->rws, RADEON_VID_DRM_2_6_0))) {
a369 2
    r300_update_num_contexts(r300screen, 1);

a372 1
    r300->context.winsys = (struct pipe_winsys*)rws;
a377 2
    make_empty_list(&r300->query_list);

d382 1
a382 1
    r300->cs = rws->cs_create(rws);
d396 3
d409 5
d415 2
a416 6
    r300->vbuf_mgr = u_vbuf_create(&r300->context, 1024 * 1024, 16,
                                       PIPE_BIND_VERTEX_BUFFER |
                                       PIPE_BIND_INDEX_BUFFER,
                                       U_VERTEX_FETCH_DWORD_ALIGNED);
    if (!r300->vbuf_mgr)
        goto fail;
d421 1
d423 1
a423 5
    /* Render functions must be initialized after blitter. */
    r300_init_render_functions(r300);
    r300_init_states(&r300->context);

    rws->cs_set_flush(r300->cs, r300_flush_callback, r300);
a434 1
        rtempl.bind = PIPE_BIND_SAMPLER_VIEW;
d449 1
a449 1
    {
d454 1
a454 2
        vb.bind = PIPE_BIND_VERTEX_BUFFER;
        vb.usage = PIPE_USAGE_IMMUTABLE;
d459 2
a460 1
        r300->dummy_vb = screen->resource_create(screen, &vb);
d475 3
d488 3
a490 3
                rws->get_value(rws, RADEON_VID_DRM_MAJOR),
                rws->get_value(rws, RADEON_VID_DRM_MINOR),
                rws->get_value(rws, RADEON_VID_DRM_PATCHLEVEL),
d492 5
a496 5
                rws->get_value(rws, RADEON_VID_PCI_ID),
                rws->get_value(rws, RADEON_VID_R300_GB_PIPES),
                rws->get_value(rws, RADEON_VID_R300_Z_PIPES),
                rws->get_value(rws, RADEON_VID_GART_SIZE) >> 20,
                rws->get_value(rws, RADEON_VID_VRAM_SIZE) >> 20,
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d29 1
a33 1
#include "r300_hyperz.h"
a35 5
#include "r300_winsys.h"

#ifdef HAVE_LLVM
#include "gallivm/lp_bld_init.h"
#endif
d40 1
d42 1
a42 1
        p_atomic_inc(&r300screen->num_contexts);
d48 1
a48 1
        p_atomic_dec(&r300screen->num_contexts);
d54 1
d81 1
a81 1
    /* The dummy VBO. */
a82 2

    /* The SWTCL VBO. */
a84 5
    /* Vertex buffers. */
    for (i = 0; i < r300->vertex_buffer_count; i++) {
        pipe_resource_reference(&r300->vertex_buffer[i].buffer, NULL);
    }

d90 3
d99 4
d105 1
a105 1
    if (r300->draw) {
d108 2
a109 12
#ifdef HAVE_LLVM
        gallivm_destroy(r300->gallivm);
#endif
    }

    if (r300->upload_vb)
        u_upload_destroy(r300->upload_vb);
    if (r300->upload_ib)
        u_upload_destroy(r300->upload_ib);

    if (r300->tran.translate_cache)
        translate_cache_destroy(r300->tran.translate_cache);
a113 3
    if (r300->zmask_mm)
        r300_hyperz_destroy_mm(r300);

d146 1
a146 1
void r300_flush_cb(void *data)
d150 1
a150 1
    cs_context_copy->context.flush(&cs_context_copy->context, 0, NULL);
d174 1
a174 4
    boolean drm_2_3_0 = r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0);
    boolean drm_2_6_0 = r300->rws->get_value(r300->rws, R300_VID_DRM_2_6_0);
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
    boolean has_hiz_ram = r300->screen->caps.hiz_ram > 0;
d197 1
a197 1
    R300_INIT_ATOM(dsa_state, is_r500 ? 8 : 6);
d204 1
a204 1
    R300_INIT_ATOM(invariant_state, 16 + (is_rv350 ? 4 : 0));
d208 1
a208 1
    R300_INIT_ATOM(vap_invariant_state, 9);
d217 1
a217 1
    R300_INIT_ATOM(fb_state_pipelined, 5 + (drm_2_3_0 ? 3 : 0));
d225 4
a228 7
    if (can_hyperz) {
        /* HiZ Clear */
        if (has_hiz_ram)
            R300_INIT_ATOM(hiz_clear, 0);
        /* zmask clear */
        R300_INIT_ATOM(zmask_clear, 0);
    }
d329 1
a329 1
        BEGIN_CB(vap_invariant->cb, 9);
d337 4
a348 1
        OUT_CB_REG(R300_GA_ROUND_MODE, 1);
d354 1
d360 5
d381 1
a381 1
             r300->rws->get_value(r300->rws, R300_VID_DRM_2_6_0))) {
d393 1
a393 1
    struct r300_winsys_screen *rws = r300screen->rws;
a420 4
#ifdef HAVE_LLVM
        r300->gallivm = gallivm_create();
        r300->draw = draw_create_gallivm(&r300->context, r300->gallivm);
#else
a421 1
#endif
d440 7
d453 1
d455 1
a455 25
    rws->cs_set_flush(r300->cs, r300_flush_cb, r300);

    /* setup hyper-z mm */
    if (r300->rws->get_value(r300->rws, R300_CAN_HYPERZ))
        if (!r300_hyperz_init_mm(r300))
            goto fail;

    r300->upload_ib = u_upload_create(&r300->context,
				      32 * 1024, 16,
				      PIPE_BIND_INDEX_BUFFER);

    if (r300->upload_ib == NULL)
        goto fail;

    r300->upload_vb = u_upload_create(&r300->context,
				      128 * 1024, 16,
				      PIPE_BIND_VERTEX_BUFFER);
    if (r300->upload_vb == NULL)
        goto fail;

    r300->tran.translate_cache = translate_cache_create();
    if (r300->tran.translate_cache == NULL)
        goto fail;

    r300_init_states(&r300->context);
d483 2
a484 1
        struct pipe_resource vb = {};
d496 36
d534 1
a534 1
 fail:
a536 27
}

void r300_finish(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb;
    unsigned i;

    /* This is a preliminary implementation of glFinish.
     *
     * The ideal implementation should use something like EmitIrqLocked and
     * WaitIrq, or better, real fences.
     */
    if (r300->fb_state.state) {
        fb = r300->fb_state.state;

        for (i = 0; i < fb->nr_cbufs; i++) {
            if (fb->cbufs[i]->texture) {
                r300->rws->buffer_wait(r300->rws,
                    r300_texture(fb->cbufs[i]->texture)->buffer);
                return;
            }
        }
        if (fb->zsbuf && fb->zsbuf->texture) {
            r300->rws->buffer_wait(r300->rws,
                r300_texture(fb->zsbuf->texture)->buffer);
        }
    }
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d26 1
d28 1
d30 1
a30 1
#include "r300_blit.h"
d33 1
a33 3
#include "r300_flush.h"
#include "r300_query.h"
#include "r300_render.h"
d35 2
a36 2
#include "r300_state_invariant.h"
#include "r300_texture.h"
d38 3
a40 1
#include "radeon_winsys.h"
d42 19
a60 1
static void r300_destroy_context(struct pipe_context* context)
d62 24
a85 2
    struct r300_context* r300 = r300_context(context);
    struct r300_query* query, * temp;
d87 2
a88 2
    util_blitter_destroy(r300->blitter);
    draw_destroy(r300->draw);
d90 4
a93 2
    /* Free the OQ BO. */
    context->screen->buffer_destroy(r300->oqbo);
a99 12

    FREE(r300->blend_color_state.state);
    FREE(r300->clip_state.state);
    FREE(r300->fb_state.state);
    FREE(r300->rs_block_state.state);
    FREE(r300->scissor_state.state);
    FREE(r300->textures_state.state);
    FREE(r300->vertex_stream_state.state);
    FREE(r300->vap_output_state.state);
    FREE(r300->viewport_state.state);
    FREE(r300->ztop_state.state);
    FREE(r300);
d102 1
a102 4
static unsigned int
r300_is_texture_referenced(struct pipe_context *pipe,
                           struct pipe_texture *texture,
                           unsigned face, unsigned level)
d104 1
a104 1
    struct pipe_buffer* buf = 0;
d106 9
a114 1
    r300_get_texture_buffer(pipe->screen, texture, &buf, NULL);
d116 44
a159 12
    return pipe->is_buffer_referenced(pipe, buf);
}

static unsigned int
r300_is_buffer_referenced(struct pipe_context *pipe,
                          struct pipe_buffer *buf)
{
    /* This only checks to see whether actual hardware buffers are
     * referenced. Since we use managed BOs and transfers, it's actually not
     * possible for pipe_buffers to ever reference the actual hardware, so
     * buffers are never referenced. */
    return 0;
d162 1
a162 1
static void r300_flush_cb(void *data)
d170 1
d176 8
a183 1
    insert_at_tail(&r300->atom_list, &r300->atomname);
d185 1
a185 1
static void r300_setup_atoms(struct r300_context* r300)
d187 7
a193 2
    boolean is_r500 = r300_screen(r300->context.screen)->caps->is_r500;
    boolean has_tcl = r300_screen(r300->context.screen)->caps->has_tcl;
d197 2
a198 2
     * Each atom is examined and emitted in the order it appears here, which
     * can affect performance and conformance if not handled with care.
d200 14
a213 4
     * Some atoms never change size, others change every emit - those have
     * the size of 0 here. */
    make_empty_list(&r300->atom_list);
    R300_INIT_ATOM(invariant_state, 71);
d215 3
d220 1
a220 4
    R300_INIT_ATOM(clip_state, has_tcl ? 5 + (6 * 4) : 2);
    R300_INIT_ATOM(dsa_state, is_r500 ? 8 : 6);
    R300_INIT_ATOM(fb_state, 0);
    R300_INIT_ATOM(rs_state, 0);
d222 3
d226 2
a227 1
    R300_INIT_ATOM(rs_block_state, 0);
a228 2
    R300_INIT_ATOM(vap_output_state, 6);
    R300_INIT_ATOM(pvs_flush, 2);
d230 12
d244 16
d262 137
a398 10
    r300->blend_color_state.state = CALLOC_STRUCT(r300_blend_color_state);
    r300->clip_state.state = CALLOC_STRUCT(pipe_clip_state);
    r300->fb_state.state = CALLOC_STRUCT(pipe_framebuffer_state);
    r300->rs_block_state.state = CALLOC_STRUCT(r300_rs_block);
    r300->scissor_state.state = CALLOC_STRUCT(pipe_scissor_state);
    r300->textures_state.state = CALLOC_STRUCT(r300_textures_state);
    r300->vertex_stream_state.state = CALLOC_STRUCT(r300_vertex_stream_state);
    r300->vap_output_state.state = CALLOC_STRUCT(r300_vap_output_state);
    r300->viewport_state.state = CALLOC_STRUCT(r300_viewport_state);
    r300->ztop_state.state = CALLOC_STRUCT(r300_ztop_state);
d406 1
a406 1
    struct radeon_winsys* radeon_winsys = r300screen->radeon_winsys;
d411 4
a414 1
    r300->winsys = radeon_winsys;
d416 1
a416 1
    r300->context.winsys = (struct pipe_winsys*)radeon_winsys;
d422 9
a430 12
    r300->context.clear = r300_clear;
    r300->context.surface_copy = r300_surface_copy;
    r300->context.surface_fill = r300_surface_fill;

    if (r300screen->caps->has_tcl) {
        r300->context.draw_arrays = r300_draw_arrays;
        r300->context.draw_elements = r300_draw_elements;
        r300->context.draw_range_elements = r300_draw_range_elements;
    } else {
        r300->context.draw_arrays = r300_swtcl_draw_arrays;
        r300->context.draw_elements = r300_draw_elements;
        r300->context.draw_range_elements = r300_swtcl_draw_range_elements;
d432 1
d434 4
d439 3
d444 3
a446 5
        /* Enable Draw's clipping. */
        draw_set_driver_clipping(r300->draw, FALSE);
        /* Force Draw to never do viewport transform, since we can do
         * transform in hardware, always. */
        draw_set_viewport_state(r300->draw, &r300_viewport_identity);
d449 2
a450 2
    r300->context.is_texture_referenced = r300_is_texture_referenced;
    r300->context.is_buffer_referenced = r300_is_buffer_referenced;
d452 9
a460 1
    r300_setup_atoms(r300);
d462 2
a463 4
    /* Open up the OQ BO. */
    r300->oqbo = screen->buffer_create(screen, 4096,
            PIPE_BUFFER_USAGE_VERTEX, 4096);
    make_empty_list(&r300->query_list);
d465 1
a465 1
    r300_init_flush_functions(r300);
d467 40
a506 1
    r300_init_query_functions(r300);
d508 1
a508 1
    /* r300_init_surface_functions(r300); */
d510 2
a511 1
    r300_init_state_functions(r300);
d513 2
a514 1
    r300->invariant_state.dirty = TRUE;
d516 9
a524 3
    r300->winsys->set_flush_cb(r300->winsys, r300_flush_cb, r300);
    r300->dirty_state = R300_NEW_KITCHEN_SINK;
    r300->dirty_hw++;
d526 2
a527 1
    r300->blitter = util_blitter_create(&r300->context);
d530 31
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a25 1
#include "util/u_sampler.h"
a26 1
#include "util/u_upload_mgr.h"
d28 1
a28 1
#include "r300_cb.h"
d31 3
a33 1
#include "r300_hyperz.h"
d35 2
a36 2
#include "r300_screen_buffer.h"
#include "r300_winsys.h"
d38 1
a38 3
#ifdef HAVE_LLVM
#include "gallivm/lp_bld_init.h"
#endif
d40 1
a40 2
static void r300_update_num_contexts(struct r300_screen *r300screen,
                                     int diff)
d42 2
a43 38
    if (diff > 0) {
        p_atomic_inc(&r300screen->num_contexts);

        if (r300screen->num_contexts > 1)
            util_slab_set_thread_safety(&r300screen->pool_buffers,
                                        UTIL_SLAB_MULTITHREADED);
    } else {
        p_atomic_dec(&r300screen->num_contexts);

        if (r300screen->num_contexts <= 1)
            util_slab_set_thread_safety(&r300screen->pool_buffers,
                                        UTIL_SLAB_SINGLETHREADED);
    }
}

static void r300_release_referenced_objects(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_textures_state *textures =
            (struct r300_textures_state*)r300->textures_state.state;
    struct r300_query *query, *temp;
    unsigned i;

    /* Framebuffer state. */
    util_unreference_framebuffer_state(fb);

    /* Textures. */
    for (i = 0; i < textures->sampler_view_count; i++)
        pipe_sampler_view_reference(
                (struct pipe_sampler_view**)&textures->sampler_views[i], NULL);

    /* The special dummy texture for texkill. */
    if (r300->texkill_sampler) {
        pipe_sampler_view_reference(
                (struct pipe_sampler_view**)&r300->texkill_sampler,
                NULL);
    }
d45 2
a46 2
    /* The dummy VBO. */
    pipe_resource_reference(&r300->dummy_vb, NULL);
d48 2
a49 7
    /* The SWTCL VBO. */
    pipe_resource_reference(&r300->vbo, NULL);

    /* Vertex buffers. */
    for (i = 0; i < r300->vertex_buffer_count; i++) {
        pipe_resource_reference(&r300->vertex_buffer[i].buffer, NULL);
    }
d56 12
d70 4
a73 1
static void r300_destroy_context(struct pipe_context* context)
d75 3
a77 1
    struct r300_context* r300 = r300_context(context);
d79 2
a80 9
    if (r300->blitter)
        util_blitter_destroy(r300->blitter);
    if (r300->draw) {
        draw_destroy(r300->draw);

#ifdef HAVE_LLVM
        gallivm_destroy(r300->gallivm);
#endif
    }
d82 9
a90 44
    if (r300->upload_vb)
        u_upload_destroy(r300->upload_vb);
    if (r300->upload_ib)
        u_upload_destroy(r300->upload_ib);

    if (r300->tran.translate_cache)
        translate_cache_destroy(r300->tran.translate_cache);

    /* XXX: This function assumes r300->query_list was initialized */
    r300_release_referenced_objects(r300);

    if (r300->zmask_mm)
        r300_hyperz_destroy_mm(r300);

    if (r300->cs)
        r300->rws->cs_destroy(r300->cs);

    /* XXX: No way to tell if this was initialized or not? */
    util_slab_destroy(&r300->pool_transfers);

    r300_update_num_contexts(r300->screen, -1);

    /* Free the structs allocated in r300_setup_atoms() */
    if (r300->aa_state.state) {
        FREE(r300->aa_state.state);
        FREE(r300->blend_color_state.state);
        FREE(r300->clip_state.state);
        FREE(r300->fb_state.state);
        FREE(r300->gpu_flush.state);
        FREE(r300->hyperz_state.state);
        FREE(r300->invariant_state.state);
        FREE(r300->rs_block_state.state);
        FREE(r300->scissor_state.state);
        FREE(r300->textures_state.state);
        FREE(r300->vap_invariant_state.state);
        FREE(r300->viewport_state.state);
        FREE(r300->ztop_state.state);
        FREE(r300->fs_constants.state);
        FREE(r300->vs_constants.state);
        if (!r300->screen->caps.has_tcl) {
            FREE(r300->vertex_stream_state.state);
        }
    }
    FREE(r300);
d93 1
a93 1
void r300_flush_cb(void *data)
a100 1
 do { \
d106 1
a106 8
 } while (0)

#define R300_ALLOC_ATOM(atomname, statetype) \
do { \
    r300->atomname.state = CALLOC_STRUCT(statetype); \
    if (r300->atomname.state == NULL) \
        return FALSE; \
} while (0)
d108 1
a108 1
static boolean r300_setup_atoms(struct r300_context* r300)
d110 2
a111 7
    boolean is_rv350 = r300->screen->caps.is_rv350;
    boolean is_r500 = r300->screen->caps.is_r500;
    boolean has_tcl = r300->screen->caps.has_tcl;
    boolean drm_2_3_0 = r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0);
    boolean drm_2_6_0 = r300->rws->get_value(r300->rws, R300_VID_DRM_2_6_0);
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
    boolean has_hiz_ram = r300->screen->caps.hiz_ram > 0;
d115 3
d119 3
a121 16
     * the size of 0 here.
     *
     * NOTE: The framebuffer state is split into these atoms:
     * - gpu_flush          (unpipelined regs)
     * - aa_state           (unpipelined regs)
     * - fb_state           (unpipelined regs)
     * - hyperz_state       (unpipelined regs followed by pipelined ones)
     * - fb_state_pipelined (pipelined regs)
     * The motivation behind this is to be able to emit a strict
     * subset of the regs, and to have reasonable register ordering. */
    /* SC, GB (unpipelined), RB3D (unpipelined), ZB (unpipelined). */
    R300_INIT_ATOM(gpu_flush, 9);
    R300_INIT_ATOM(aa_state, 4);
    R300_INIT_ATOM(fb_state, 0);
    R300_INIT_ATOM(hyperz_state, is_r500 || (is_rv350 && drm_2_6_0) ? 10 : 8);
    /* ZB (unpipelined), SC. */
a122 3
    /* ZB, FG. */
    R300_INIT_ATOM(dsa_state, is_r500 ? 8 : 6);
    /* RB3D. */
d125 4
a128 1
    /* SC. */
a129 3
    /* GB, FG, GA, SU, SC, RB3D. */
    R300_INIT_ATOM(invariant_state, 16 + (is_rv350 ? 4 : 0));
    /* VAP. */
d131 3
a134 2
    R300_INIT_ATOM(vap_invariant_state, 9);
    R300_INIT_ATOM(vertex_stream_state, 0);
a135 12
    R300_INIT_ATOM(vs_constants, 0);
    R300_INIT_ATOM(clip_state, has_tcl ? 5 + (6 * 4) : 2);
    /* VAP, RS, GA, GB, SU, SC. */
    R300_INIT_ATOM(rs_block_state, 0);
    R300_INIT_ATOM(rs_state, 0);
    /* SC, US. */
    R300_INIT_ATOM(fb_state_pipelined, 5 + (drm_2_3_0 ? 3 : 0));
    /* US. */
    R300_INIT_ATOM(fs, 0);
    R300_INIT_ATOM(fs_rc_constant_state, 0);
    R300_INIT_ATOM(fs_constants, 0);
    /* TX. */
a137 16
    if (can_hyperz) {
        /* HiZ Clear */
        if (has_hiz_ram)
            R300_INIT_ATOM(hiz_clear, 0);
        /* zmask clear */
        R300_INIT_ATOM(zmask_clear, 0);
    }
    /* ZB (unpipelined), SU. */
    R300_INIT_ATOM(query_start, 4);

    /* Replace emission functions for r500. */
    if (is_r500) {
        r300->fs.emit = r500_emit_fs;
        r300->fs_rc_constant_state.emit = r500_emit_fs_rc_constant_state;
        r300->fs_constants.emit = r500_emit_fs_constants;
    }
d140 10
a149 137
    R300_ALLOC_ATOM(aa_state, r300_aa_state);
    R300_ALLOC_ATOM(blend_color_state, r300_blend_color_state);
    R300_ALLOC_ATOM(clip_state, r300_clip_state);
    R300_ALLOC_ATOM(hyperz_state, r300_hyperz_state);
    R300_ALLOC_ATOM(invariant_state, r300_invariant_state);
    R300_ALLOC_ATOM(textures_state, r300_textures_state);
    R300_ALLOC_ATOM(vap_invariant_state, r300_vap_invariant_state);
    R300_ALLOC_ATOM(viewport_state, r300_viewport_state);
    R300_ALLOC_ATOM(ztop_state, r300_ztop_state);
    R300_ALLOC_ATOM(fb_state, pipe_framebuffer_state);
    R300_ALLOC_ATOM(gpu_flush, pipe_framebuffer_state);
    R300_ALLOC_ATOM(scissor_state, pipe_scissor_state);
    R300_ALLOC_ATOM(rs_block_state, r300_rs_block);
    R300_ALLOC_ATOM(fs_constants, r300_constant_buffer);
    R300_ALLOC_ATOM(vs_constants, r300_constant_buffer);
    if (!r300->screen->caps.has_tcl) {
        R300_ALLOC_ATOM(vertex_stream_state, r300_vertex_stream_state);
    }

    /* Some non-CSO atoms don't use the state pointer. */
    r300->fb_state_pipelined.allow_null_state = TRUE;
    r300->fs_rc_constant_state.allow_null_state = TRUE;
    r300->pvs_flush.allow_null_state = TRUE;
    r300->query_start.allow_null_state = TRUE;
    r300->texture_cache_inval.allow_null_state = TRUE;

    /* Some states must be marked as dirty here to properly set up
     * hardware in the first command stream. */
    r300_mark_atom_dirty(r300, &r300->invariant_state);
    r300_mark_atom_dirty(r300, &r300->pvs_flush);
    r300_mark_atom_dirty(r300, &r300->vap_invariant_state);
    r300_mark_atom_dirty(r300, &r300->texture_cache_inval);
    r300_mark_atom_dirty(r300, &r300->textures_state);

    return TRUE;
}

/* Not every state tracker calls every driver function before the first draw
 * call and we must initialize the command buffers somehow. */
static void r300_init_states(struct pipe_context *pipe)
{
    struct r300_context *r300 = r300_context(pipe);
    struct pipe_blend_color bc = {{0}};
    struct pipe_clip_state cs = {{{0}}};
    struct pipe_scissor_state ss = {0};
    struct r300_clip_state *clip =
            (struct r300_clip_state*)r300->clip_state.state;
    struct r300_gpu_flush *gpuflush =
            (struct r300_gpu_flush*)r300->gpu_flush.state;
    struct r300_vap_invariant_state *vap_invariant =
            (struct r300_vap_invariant_state*)r300->vap_invariant_state.state;
    struct r300_invariant_state *invariant =
            (struct r300_invariant_state*)r300->invariant_state.state;

    CB_LOCALS;

    pipe->set_blend_color(pipe, &bc);
    pipe->set_scissor_state(pipe, &ss);

    /* Initialize the clip state. */
    if (r300->screen->caps.has_tcl) {
        pipe->set_clip_state(pipe, &cs);
    } else {
        BEGIN_CB(clip->cb, 2);
        OUT_CB_REG(R300_VAP_CLIP_CNTL, R300_CLIP_DISABLE);
        END_CB;
    }

    /* Initialize the GPU flush. */
    {
        BEGIN_CB(gpuflush->cb_flush_clean, 6);

        /* Flush and free renderbuffer caches. */
        OUT_CB_REG(R300_RB3D_DSTCACHE_CTLSTAT,
            R300_RB3D_DSTCACHE_CTLSTAT_DC_FREE_FREE_3D_TAGS |
            R300_RB3D_DSTCACHE_CTLSTAT_DC_FLUSH_FLUSH_DIRTY_3D);
        OUT_CB_REG(R300_ZB_ZCACHE_CTLSTAT,
            R300_ZB_ZCACHE_CTLSTAT_ZC_FLUSH_FLUSH_AND_FREE |
            R300_ZB_ZCACHE_CTLSTAT_ZC_FREE_FREE);

        /* Wait until the GPU is idle.
         * This fixes random pixels sometimes appearing probably caused
         * by incomplete rendering. */
        OUT_CB_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
        END_CB;
    }

    /* Initialize the VAP invariant state. */
    {
        BEGIN_CB(vap_invariant->cb, 9);
        OUT_CB_REG(VAP_PVS_VTX_TIMEOUT_REG, 0xffff);
        OUT_CB_REG_SEQ(R300_VAP_GB_VERT_CLIP_ADJ, 4);
        OUT_CB_32F(1.0);
        OUT_CB_32F(1.0);
        OUT_CB_32F(1.0);
        OUT_CB_32F(1.0);
        OUT_CB_REG(R300_VAP_PSC_SGN_NORM_CNTL, R300_SGN_NORM_NO_ZERO);
        END_CB;
    }

    /* Initialize the invariant state. */
    {
        BEGIN_CB(invariant->cb, r300->invariant_state.size);
        OUT_CB_REG(R300_GB_SELECT, 0);
        OUT_CB_REG(R300_FG_FOG_BLEND, 0);
        OUT_CB_REG(R300_GA_ROUND_MODE, 1);
        OUT_CB_REG(R300_GA_OFFSET, 0);
        OUT_CB_REG(R300_SU_TEX_WRAP, 0);
        OUT_CB_REG(R300_SU_DEPTH_SCALE, 0x4B7FFFFF);
        OUT_CB_REG(R300_SU_DEPTH_OFFSET, 0);
        OUT_CB_REG(R300_SC_EDGERULE, 0x2DA49525);

        if (r300->screen->caps.is_rv350) {
            OUT_CB_REG(R500_RB3D_DISCARD_SRC_PIXEL_LTE_THRESHOLD, 0x01010101);
            OUT_CB_REG(R500_RB3D_DISCARD_SRC_PIXEL_GTE_THRESHOLD, 0xFEFEFEFE);
        }
        END_CB;
    }

    /* Initialize the hyperz state. */
    {
        struct r300_hyperz_state *hyperz =
            (struct r300_hyperz_state*)r300->hyperz_state.state;
        BEGIN_CB(&hyperz->cb_flush_begin, r300->hyperz_state.size);
        OUT_CB_REG(R300_ZB_ZCACHE_CTLSTAT,
                   R300_ZB_ZCACHE_CTLSTAT_ZC_FLUSH_FLUSH_AND_FREE);
        OUT_CB_REG(R300_ZB_BW_CNTL, 0);
        OUT_CB_REG(R300_ZB_DEPTHCLEARVALUE, 0);
        OUT_CB_REG(R300_SC_HYPERZ, R300_SC_HYPERZ_ADJ_2);

        if (r300->screen->caps.is_r500 ||
            (r300->screen->caps.is_rv350 &&
             r300->rws->get_value(r300->rws, R300_VID_DRM_2_6_0))) {
            OUT_CB_REG(R300_GB_Z_PEQ_CONFIG, 0);
        }
        END_CB;
    }
d157 1
a157 1
    struct r300_winsys_screen *rws = r300screen->rws;
d162 1
a162 4
    r300_update_num_contexts(r300screen, 1);

    r300->rws = rws;
    r300->screen = r300screen;
d164 1
a164 1
    r300->context.winsys = (struct pipe_winsys*)rws;
d170 12
a181 9
    make_empty_list(&r300->query_list);

    util_slab_create(&r300->pool_transfers,
                     sizeof(struct pipe_transfer), 64,
                     UTIL_SLAB_SINGLETHREADED);

    r300->cs = rws->cs_create(rws);
    if (r300->cs == NULL)
        goto fail;
a182 1
    if (!r300screen->caps.has_tcl) {
a183 4
#ifdef HAVE_LLVM
        r300->gallivm = gallivm_create();
        r300->draw = draw_create_gallivm(&r300->context, r300->gallivm);
#else
a184 3
#endif
        if (r300->draw == NULL)
            goto fail;
d187 5
a191 3
        /* Disable converting points/lines to triangles. */
        draw_wide_line_threshold(r300->draw, 10000000.f);
        draw_wide_point_threshold(r300->draw, 10000000.f);
d194 2
a195 2
    if (!r300_setup_atoms(r300))
        goto fail;
d197 1
a197 5
    r300_init_blit_functions(r300);
    r300_init_flush_functions(r300);
    r300_init_query_functions(r300);
    r300_init_state_functions(r300);
    r300_init_resource_functions(r300);
d199 4
a202 3
    r300->blitter = util_blitter_create(&r300->context);
    if (r300->blitter == NULL)
        goto fail;
d204 1
a204 2
    /* Render functions must be initialized after blitter. */
    r300_init_render_functions(r300);
d206 1
a206 1
    rws->cs_set_flush(r300->cs, r300_flush_cb, r300);
d208 1
a208 40
    /* setup hyper-z mm */
    if (r300->rws->get_value(r300->rws, R300_CAN_HYPERZ))
        if (!r300_hyperz_init_mm(r300))
            goto fail;

    r300->upload_ib = u_upload_create(&r300->context,
				      32 * 1024, 16,
				      PIPE_BIND_INDEX_BUFFER);

    if (r300->upload_ib == NULL)
        goto fail;

    r300->upload_vb = u_upload_create(&r300->context,
				      128 * 1024, 16,
				      PIPE_BIND_VERTEX_BUFFER);
    if (r300->upload_vb == NULL)
        goto fail;

    r300->tran.translate_cache = translate_cache_create();
    if (r300->tran.translate_cache == NULL)
        goto fail;

    r300_init_states(&r300->context);

    /* The KIL opcode needs the first texture unit to be enabled
     * on r3xx-r4xx. In order to calm down the CS checker, we bind this
     * dummy texture there. */
    if (!r300->screen->caps.is_r500) {
        struct pipe_resource *tex;
        struct pipe_resource rtempl = {{0}};
        struct pipe_sampler_view vtempl = {{0}};

        rtempl.target = PIPE_TEXTURE_2D;
        rtempl.format = PIPE_FORMAT_I8_UNORM;
        rtempl.bind = PIPE_BIND_SAMPLER_VIEW;
        rtempl.usage = PIPE_USAGE_IMMUTABLE;
        rtempl.width0 = 1;
        rtempl.height0 = 1;
        rtempl.depth0 = 1;
        tex = screen->resource_create(screen, &rtempl);
d210 1
a210 1
        u_sampler_view_default_template(&vtempl, tex, tex->format);
d212 1
a212 2
        r300->texkill_sampler = (struct r300_sampler_view*)
            r300->context.create_sampler_view(&r300->context, tex, &vtempl);
d214 3
a216 2
        pipe_resource_reference(&tex, NULL);
    }
d218 1
a218 12
    {
        struct pipe_resource vb = {};
        vb.target = PIPE_BUFFER;
        vb.format = PIPE_FORMAT_R8_UNORM;
        vb.bind = PIPE_BIND_VERTEX_BUFFER;
        vb.usage = PIPE_USAGE_IMMUTABLE;
        vb.width0 = sizeof(float) * 16;
        vb.height0 = 1;
        vb.depth0 = 1;

        r300->dummy_vb = screen->resource_create(screen, &vb);
    }
a220 31

 fail:
    r300_destroy_context(&r300->context);
    return NULL;
}

void r300_finish(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb;
    unsigned i;

    /* This is a preliminary implementation of glFinish.
     *
     * The ideal implementation should use something like EmitIrqLocked and
     * WaitIrq, or better, real fences.
     */
    if (r300->fb_state.state) {
        fb = r300->fb_state.state;

        for (i = 0; i < fb->nr_cbufs; i++) {
            if (fb->cbufs[i]->texture) {
                r300->rws->buffer_wait(r300->rws,
                    r300_texture(fb->cbufs[i]->texture)->buffer);
                return;
            }
        }
        if (fb->zsbuf && fb->zsbuf->texture) {
            r300->rws->buffer_wait(r300->rws,
                r300_texture(fb->zsbuf->texture)->buffer);
        }
    }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a28 3
#include "os/os_time.h"
#include "vl/vl_decoder.h"
#include "vl/vl_video_buffer.h"
d33 1
d36 23
a58 1
#include "compiler/radeon_regalloc.h"
d66 1
d84 10
a93 3
    /* Manually-created vertex buffers. */
    pipe_resource_reference(&r300->dummy_vb.buffer, NULL);
    pb_reference(&r300->vbo, NULL);
d95 5
a99 2
    r300->context.delete_depth_stencil_alpha_state(&r300->context,
                                                   r300->dsa_decompress_zmask);
a105 7
    if (r300->cs && r300->hyperz_enabled) {
        r300->rws->cs_request_feature(r300->cs, RADEON_FID_R300_HYPERZ_ACCESS, FALSE);
    }
    if (r300->cs && r300->cmask_access) {
        r300->rws->cs_request_feature(r300->cs, RADEON_FID_R300_CMASK_ACCESS, FALSE);
    }

d108 1
a108 1
    if (r300->draw)
d111 12
a122 2
    if (r300->uploader)
        u_upload_destroy(r300->uploader);
d127 3
a132 2
    rc_destroy_regalloc_state(&r300->fs_regalloc_state);

d136 2
a147 1
        FREE(r300->sample_mask.state);
d162 1
a162 1
static void r300_flush_callback(void *data, unsigned flags)
d166 1
a166 1
    r300_flush(&cs_context_copy->context, flags, NULL);
d190 4
a193 1
    boolean drm_2_6_0 = r300->screen->info.drm_minor >= 6;
d216 1
a216 1
    R300_INIT_ATOM(dsa_state, is_r500 ? (drm_2_6_0 ? 10 : 8) : 6);
a220 1
    R300_INIT_ATOM(sample_mask, 2);
d223 1
a223 1
    R300_INIT_ATOM(invariant_state, 14 + (is_rv350 ? 4 : 0) + (is_r500 ? 4 : 0));
d227 1
a227 1
    R300_INIT_ATOM(vap_invariant_state, is_r500 ? 11 : 9);
d231 1
a231 1
    R300_INIT_ATOM(clip_state, has_tcl ? 3 + (6 * 4) : 0);
d236 1
a236 1
    R300_INIT_ATOM(fb_state_pipelined, 8);
d244 7
a250 4
    /* Clear commands */
    R300_INIT_ATOM(hiz_clear, r300->screen->caps.hiz_ram > 0 ? 4 : 0);
    R300_INIT_ATOM(zmask_clear, r300->screen->caps.zmask_ram > 0 ? 4 : 0);
    R300_INIT_ATOM(cmask_clear, 4);
a272 1
    r300->sample_mask.state = malloc(4);
d307 2
d319 10
a328 3
    pipe->set_clip_state(pipe, &cs);
    pipe->set_scissor_states(pipe, 0, 1, &ss);
    pipe->set_sample_mask(pipe, ~0);
d351 1
a351 1
        BEGIN_CB(vap_invariant->cb, r300->vap_invariant_state.size);
a358 4

        if (r300->screen->caps.is_r500) {
            OUT_CB_REG(R500_VAP_TEX_TO_COLOR_CNTL, 0);
        }
d367 1
a377 5

        if (r300->screen->caps.is_r500) {
            OUT_CB_REG(R500_GA_COLOR_CONTROL_PS3, 0);
            OUT_CB_REG(R500_SU_TEX_WRAP_PS3, 0);
        }
d394 1
a394 1
             r300->screen->info.drm_minor >= 6)) {
d406 1
a406 1
    struct radeon_winsys *rws = r300screen->rws;
d411 2
d416 1
d422 2
d428 1
a428 1
    r300->cs = rws->cs_create(rws, RING_GFX, NULL);
d434 4
d439 1
a446 3
        draw_wide_point_sprites(r300->draw, FALSE);
        draw_enable_line_stipple(r300->draw, TRUE);
        draw_enable_point_sprites(r300->draw, FALSE);
d457 6
a463 1
    r300_init_states(&r300->context);
d465 10
a474 2
    r300->context.create_video_decoder = vl_create_decoder;
    r300->context.create_video_buffer = vl_video_buffer_create;
d476 2
a477 2
    r300->uploader = u_upload_create(&r300->context, 256 * 1024, 4,
                                     PIPE_BIND_CUSTOM);
d479 8
a486 2
    r300->blitter = util_blitter_create(&r300->context);
    if (r300->blitter == NULL)
a487 1
    r300->blitter->draw_rectangle = r300_blitter_draw_rectangle;
d489 1
a489 1
    rws->cs_set_flush_callback(r300->cs, r300_flush_callback, r300);
d501 1
d516 2
a517 3
    if (r300screen->caps.has_tcl) {
        struct pipe_resource vb;
        memset(&vb, 0, sizeof(vb));
d520 2
a521 1
        vb.usage = PIPE_USAGE_STATIC;
d526 1
a526 2
        r300->dummy_vb.buffer = screen->resource_create(screen, &vb);
        r300->context.set_vertex_buffers(&r300->context, 0, 1, &r300->dummy_vb);
d529 1
a529 4
    {
        struct pipe_depth_stencil_alpha_state dsa;
        memset(&dsa, 0, sizeof(dsa));
        dsa.depth.writemask = 1;
d531 4
a534 4
        r300->dsa_decompress_zmask =
            r300->context.create_depth_stencil_alpha_state(&r300->context,
                                                           &dsa);
    }
d536 4
a539 1
    r300->hyperz_time_of_last_flush = os_time_get();
d541 19
a559 25
    /* Register allocator state */
    rc_init_regalloc_state(&r300->fs_regalloc_state);

    /* Print driver info. */
#ifdef DEBUG
    {
#else
    if (DBG_ON(r300, DBG_INFO)) {
#endif
        fprintf(stderr,
                "r300: DRM version: %d.%d.%d, Name: %s, ID: 0x%04x, GB: %d, Z: %d\n"
                "r300: GART size: %d MB, VRAM size: %d MB\n"
                "r300: AA compression RAM: %s, Z compression RAM: %s, HiZ RAM: %s\n",
                r300->screen->info.drm_major,
                r300->screen->info.drm_minor,
                r300->screen->info.drm_patchlevel,
                screen->get_name(screen),
                r300->screen->info.pci_id,
                r300->screen->info.r300_num_gb_pipes,
                r300->screen->info.r300_num_z_pipes,
                r300->screen->info.gart_size >> 20,
                r300->screen->info.vram_size >> 20,
                "YES", /* XXX really? */
                r300->screen->caps.zmask_ram ? "YES" : "NO",
                r300->screen->caps.hiz_ram ? "YES" : "NO");
a560 6

    return &r300->context;

fail:
    r300_destroy_context(&r300->context);
    return NULL;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d126 1
a126 2
static void r300_flush_callback(void *data, unsigned flags,
				struct pipe_fence_handle **fence)
d130 1
a130 1
    r300_flush(&cs_context_copy->context, flags, fence);
d382 1
a382 1
    r300->cs = rws->cs_create(rws, RING_GFX, r300_flush_callback, r300, NULL);
d412 1
a412 1
    r300->context.create_video_codec = vl_create_decoder;
d423 2
d454 1
a454 1
        vb.usage = PIPE_USAGE_DEFAULT;
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@a39 2
#include <inttypes.h>

d485 1
a485 1
                "r300: GART size: %"PRIu64" MB, VRAM size: %"PRIu64" MB\n"
@


