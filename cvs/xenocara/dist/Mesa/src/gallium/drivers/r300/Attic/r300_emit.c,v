head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.57;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.06;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.01;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.45.10;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2009 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

/* r300_emit: Functions for emitting state. */

#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_mm.h"

#include "r300_context.h"
#include "r300_cb.h"
#include "r300_cs.h"
#include "r300_emit.h"
#include "r300_fs.h"
#include "r300_screen.h"
#include "r300_screen_buffer.h"
#include "r300_vs.h"

void r300_emit_blend_state(struct r300_context* r300,
                           unsigned size, void* state)
{
    struct r300_blend_state* blend = (struct r300_blend_state*)state;
    struct pipe_framebuffer_state* fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct pipe_surface *cb;
    CS_LOCALS(r300);

    cb = fb->nr_cbufs ? r300_get_nonnull_cb(fb, 0) : NULL;

    if (cb) {
        if (cb->format == PIPE_FORMAT_R16G16B16A16_FLOAT) {
            WRITE_CS_TABLE(blend->cb_noclamp, size);
        } else if (cb->format == PIPE_FORMAT_R16G16B16X16_FLOAT) {
            WRITE_CS_TABLE(blend->cb_noclamp_noalpha, size);
        } else {
            unsigned swz = r300_surface(cb)->colormask_swizzle;
            WRITE_CS_TABLE(blend->cb_clamp[swz], size);
        }
    } else {
        WRITE_CS_TABLE(blend->cb_no_readwrite, size);
    }
}

void r300_emit_blend_color_state(struct r300_context* r300,
                                 unsigned size, void* state)
{
    struct r300_blend_color_state* bc = (struct r300_blend_color_state*)state;
    CS_LOCALS(r300);

    WRITE_CS_TABLE(bc->cb, size);
}

void r300_emit_clip_state(struct r300_context* r300,
                          unsigned size, void* state)
{
    struct r300_clip_state* clip = (struct r300_clip_state*)state;
    CS_LOCALS(r300);

    WRITE_CS_TABLE(clip->cb, size);
}

void r300_emit_dsa_state(struct r300_context* r300, unsigned size, void* state)
{
    struct r300_dsa_state* dsa = (struct r300_dsa_state*)state;
    struct pipe_framebuffer_state* fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    boolean is_r500 = r300->screen->caps.is_r500;
    CS_LOCALS(r300);
    uint32_t alpha_func = dsa->alpha_function;

    /* Choose the alpha ref value between 8-bit (FG_ALPHA_FUNC.AM_VAL) and
     * 16-bit (FG_ALPHA_VALUE). */
    if (is_r500 && (alpha_func & R300_FG_ALPHA_FUNC_ENABLE)) {
        struct pipe_surface *cb = fb->nr_cbufs ? r300_get_nonnull_cb(fb, 0) : NULL;

        if (cb &&
            (cb->format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
             cb->format == PIPE_FORMAT_R16G16B16X16_FLOAT)) {
            alpha_func |= R500_FG_ALPHA_FUNC_FP16_ENABLE;
        } else {
            alpha_func |= R500_FG_ALPHA_FUNC_8BIT;
        }
    }

    /* Setup alpha-to-coverage. */
    if (r300->alpha_to_coverage && r300->msaa_enable) {
        /* Always set 3/6, it improves precision even for 2x and 4x MSAA. */
        alpha_func |= R300_FG_ALPHA_FUNC_MASK_ENABLE |
                      R300_FG_ALPHA_FUNC_CFG_3_OF_6;
    }

    BEGIN_CS(size);
    OUT_CS_REG(R300_FG_ALPHA_FUNC, alpha_func);
    OUT_CS_TABLE(fb->zsbuf ? &dsa->cb_begin : dsa->cb_zb_no_readwrite, size-2);
    END_CS;
}

static void get_rc_constant_state(
    float vec[4],
    struct r300_context * r300,
    struct rc_constant * constant)
{
    struct r300_textures_state* texstate = r300->textures_state.state;
    struct r300_resource *tex;

    assert(constant->Type == RC_CONSTANT_STATE);

    /* vec should either be (0, 0, 0, 1), which should be a relatively safe
     * RGBA or STRQ value, or it could be one of the RC_CONSTANT_STATE
     * state factors. */

    switch (constant->u.State[0]) {
        /* Factor for converting rectangle coords to
         * normalized coords. Should only show up on non-r500. */
        case RC_STATE_R300_TEXRECT_FACTOR:
            tex = r300_resource(texstate->sampler_views[constant->u.State[1]]->base.texture);
            vec[0] = 1.0 / tex->tex.width0;
            vec[1] = 1.0 / tex->tex.height0;
            vec[2] = 0;
            vec[3] = 1;
            break;

        case RC_STATE_R300_TEXSCALE_FACTOR:
            tex = r300_resource(texstate->sampler_views[constant->u.State[1]]->base.texture);
            /* Add a small number to the texture size to work around rounding errors in hw. */
            vec[0] = tex->b.b.width0  / (tex->tex.width0  + 0.001f);
            vec[1] = tex->b.b.height0 / (tex->tex.height0 + 0.001f);
            vec[2] = tex->b.b.depth0  / (tex->tex.depth0  + 0.001f);
            vec[3] = 1;
            break;

        case RC_STATE_R300_VIEWPORT_SCALE:
            vec[0] = r300->viewport.scale[0];
            vec[1] = r300->viewport.scale[1];
            vec[2] = r300->viewport.scale[2];
            vec[3] = 1;
            break;

        case RC_STATE_R300_VIEWPORT_OFFSET:
            vec[0] = r300->viewport.translate[0];
            vec[1] = r300->viewport.translate[1];
            vec[2] = r300->viewport.translate[2];
            vec[3] = 1;
            break;

        default:
            fprintf(stderr, "r300: Implementation error: "
                "Unknown RC_CONSTANT type %d\n", constant->u.State[0]);
            vec[0] = 0;
            vec[1] = 0;
            vec[2] = 0;
            vec[3] = 1;
    }
}

/* Convert a normal single-precision float into the 7.16 format
 * used by the R300 fragment shader.
 */
uint32_t pack_float24(float f)
{
    union {
        float fl;
        uint32_t u;
    } u;
    float mantissa;
    int exponent;
    uint32_t float24 = 0;

    if (f == 0.0)
        return 0;

    u.fl = f;

    mantissa = frexpf(f, &exponent);

    /* Handle -ve */
    if (mantissa < 0) {
        float24 |= (1 << 23);
        mantissa = mantissa * -1.0;
    }
    /* Handle exponent, bias of 63 */
    exponent += 62;
    float24 |= (exponent << 16);
    /* Kill 7 LSB of mantissa */
    float24 |= (u.u & 0x7FFFFF) >> 7;

    return float24;
}

void r300_emit_fs(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    CS_LOCALS(r300);

    WRITE_CS_TABLE(fs->shader->cb_code, fs->shader->cb_code_size);
}

void r300_emit_fs_constants(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    struct r300_constant_buffer *buf = (struct r300_constant_buffer*)state;
    unsigned count = fs->shader->externals_count;
    unsigned i, j;
    CS_LOCALS(r300);

    if (count == 0)
        return;

    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_PFS_PARAM_0_X, count * 4);
    if (buf->remap_table){
        for (i = 0; i < count; i++) {
            float *data = (float*)&buf->ptr[buf->remap_table[i]*4];
            for (j = 0; j < 4; j++)
                OUT_CS(pack_float24(data[j]));
        }
    } else {
        for (i = 0; i < count; i++)
            for (j = 0; j < 4; j++)
                OUT_CS(pack_float24(*(float*)&buf->ptr[i*4+j]));
    }

    END_CS;
}

void r300_emit_fs_rc_constant_state(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    struct rc_constant_list *constants = &fs->shader->code.constants;
    unsigned i;
    unsigned count = fs->shader->rc_state_count;
    unsigned first = fs->shader->externals_count;
    unsigned end = constants->Count;
    unsigned j;
    CS_LOCALS(r300);

    if (count == 0)
        return;

    BEGIN_CS(size);
    for(i = first; i < end; ++i) {
        if (constants->Constants[i].Type == RC_CONSTANT_STATE) {
            float data[4];

            get_rc_constant_state(data, r300, &constants->Constants[i]);

            OUT_CS_REG_SEQ(R300_PFS_PARAM_0_X + i * 16, 4);
            for (j = 0; j < 4; j++)
                OUT_CS(pack_float24(data[j]));
        }
    }
    END_CS;
}

void r500_emit_fs(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    CS_LOCALS(r300);

    WRITE_CS_TABLE(fs->shader->cb_code, fs->shader->cb_code_size);
}

void r500_emit_fs_constants(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    struct r300_constant_buffer *buf = (struct r300_constant_buffer*)state;
    unsigned count = fs->shader->externals_count;
    CS_LOCALS(r300);

    if (count == 0)
        return;

    BEGIN_CS(size);
    OUT_CS_REG(R500_GA_US_VECTOR_INDEX, R500_GA_US_VECTOR_INDEX_TYPE_CONST);
    OUT_CS_ONE_REG(R500_GA_US_VECTOR_DATA, count * 4);
    if (buf->remap_table){
        for (unsigned i = 0; i < count; i++) {
            uint32_t *data = &buf->ptr[buf->remap_table[i]*4];
            OUT_CS_TABLE(data, 4);
        }
    } else {
        OUT_CS_TABLE(buf->ptr, count * 4);
    }
    END_CS;
}

void r500_emit_fs_rc_constant_state(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    struct rc_constant_list *constants = &fs->shader->code.constants;
    unsigned i;
    unsigned count = fs->shader->rc_state_count;
    unsigned first = fs->shader->externals_count;
    unsigned end = constants->Count;
    CS_LOCALS(r300);

    if (count == 0)
        return;

    BEGIN_CS(size);
    for(i = first; i < end; ++i) {
        if (constants->Constants[i].Type == RC_CONSTANT_STATE) {
            float data[4];

            get_rc_constant_state(data, r300, &constants->Constants[i]);

            OUT_CS_REG(R500_GA_US_VECTOR_INDEX,
                       R500_GA_US_VECTOR_INDEX_TYPE_CONST |
                       (i & R500_GA_US_VECTOR_INDEX_MASK));
            OUT_CS_ONE_REG(R500_GA_US_VECTOR_DATA, 4);
            OUT_CS_TABLE(data, 4);
        }
    }
    END_CS;
}

void r300_emit_gpu_flush(struct r300_context *r300, unsigned size, void *state)
{
    struct r300_gpu_flush *gpuflush = (struct r300_gpu_flush*)state;
    struct pipe_framebuffer_state* fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    uint32_t height = fb->height;
    uint32_t width = fb->width;
    CS_LOCALS(r300);

    if (r300->cbzb_clear) {
        struct r300_surface *surf = r300_surface(fb->cbufs[0]);

        height = surf->cbzb_height;
        width = surf->cbzb_width;
    }

    DBG(r300, DBG_SCISSOR,
	"r300: Scissor width: %i, height: %i, CBZB clear: %s\n",
	width, height, r300->cbzb_clear ? "YES" : "NO");

    BEGIN_CS(size);

    /* Set up scissors.
     * By writing to the SC registers, SC & US assert idle. */
    OUT_CS_REG_SEQ(R300_SC_SCISSORS_TL, 2);
    if (r300->screen->caps.is_r500) {
        OUT_CS(0);
        OUT_CS(((width  - 1) << R300_SCISSORS_X_SHIFT) |
               ((height - 1) << R300_SCISSORS_Y_SHIFT));
    } else {
        OUT_CS((1440 << R300_SCISSORS_X_SHIFT) |
               (1440 << R300_SCISSORS_Y_SHIFT));
        OUT_CS(((width  + 1440-1) << R300_SCISSORS_X_SHIFT) |
               ((height + 1440-1) << R300_SCISSORS_Y_SHIFT));
    }

    /* Flush CB & ZB caches and wait until the 3D engine is idle and clean. */
    OUT_CS_TABLE(gpuflush->cb_flush_clean, 6);
    END_CS;
}

void r300_emit_aa_state(struct r300_context *r300, unsigned size, void *state)
{
    struct r300_aa_state *aa = (struct r300_aa_state*)state;
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG(R300_GB_AA_CONFIG, aa->aa_config);

    if (aa->dest) {
        OUT_CS_REG_SEQ(R300_RB3D_AARESOLVE_OFFSET, 3);
        OUT_CS(aa->dest->offset);
        OUT_CS(aa->dest->pitch & R300_RB3D_AARESOLVE_PITCH_MASK);
        OUT_CS(R300_RB3D_AARESOLVE_CTL_AARESOLVE_MODE_RESOLVE |
               R300_RB3D_AARESOLVE_CTL_AARESOLVE_ALPHA_AVERAGE);
        OUT_CS_RELOC(aa->dest);
    } else {
        OUT_CS_REG(R300_RB3D_AARESOLVE_CTL, 0);
    }

    END_CS;
}

void r300_emit_fb_state(struct r300_context* r300, unsigned size, void* state)
{
    struct pipe_framebuffer_state* fb = (struct pipe_framebuffer_state*)state;
    struct r300_surface* surf;
    unsigned i;
    uint32_t rb3d_cctl = 0;

    CS_LOCALS(r300);

    BEGIN_CS(size);

    if (r300->screen->caps.is_r500) {
        rb3d_cctl = R300_RB3D_CCTL_INDEPENDENT_COLORFORMAT_ENABLE_ENABLE;
    }
    /* NUM_MULTIWRITES replicates COLOR[0] to all colorbuffers. */
    if (fb->nr_cbufs && r300->fb_multiwrite) {
        rb3d_cctl |= R300_RB3D_CCTL_NUM_MULTIWRITES(fb->nr_cbufs);
    }
    if (r300->cmask_in_use) {
        rb3d_cctl |= R300_RB3D_CCTL_AA_COMPRESSION_ENABLE |
                     R300_RB3D_CCTL_CMASK_ENABLE;
    }

    OUT_CS_REG(R300_RB3D_CCTL, rb3d_cctl);

    /* Set up colorbuffers. */
    for (i = 0; i < fb->nr_cbufs; i++) {
        surf = r300_surface(r300_get_nonnull_cb(fb, i));

        OUT_CS_REG(R300_RB3D_COLOROFFSET0 + (4 * i), surf->offset);
        OUT_CS_RELOC(surf);

        OUT_CS_REG(R300_RB3D_COLORPITCH0 + (4 * i), surf->pitch);
        OUT_CS_RELOC(surf);

        if (r300->cmask_in_use && i == 0) {
            OUT_CS_REG(R300_RB3D_CMASK_OFFSET0, 0);
            OUT_CS_REG(R300_RB3D_CMASK_PITCH0, surf->pitch_cmask);
            OUT_CS_REG(R300_RB3D_COLOR_CLEAR_VALUE, r300->color_clear_value);
            if (r300->screen->caps.is_r500 && r300->screen->info.drm_minor >= 29) {
                OUT_CS_REG_SEQ(R500_RB3D_COLOR_CLEAR_VALUE_AR, 2);
                OUT_CS(r300->color_clear_value_ar);
                OUT_CS(r300->color_clear_value_gb);
            }
        }
    }

    /* Set up the ZB part of the CBZB clear. */
    if (r300->cbzb_clear) {
        surf = r300_surface(fb->cbufs[0]);

        OUT_CS_REG(R300_ZB_FORMAT, surf->cbzb_format);

        OUT_CS_REG(R300_ZB_DEPTHOFFSET, surf->cbzb_midpoint_offset);
        OUT_CS_RELOC(surf);

        OUT_CS_REG(R300_ZB_DEPTHPITCH, surf->cbzb_pitch);
        OUT_CS_RELOC(surf);

        DBG(r300, DBG_CBZB,
            "CBZB clearing cbuf %08x %08x\n", surf->cbzb_format,
            surf->cbzb_pitch);
    }
    /* Set up a zbuffer. */
    else if (fb->zsbuf) {
        surf = r300_surface(fb->zsbuf);

        OUT_CS_REG(R300_ZB_FORMAT, surf->format);

        OUT_CS_REG(R300_ZB_DEPTHOFFSET, surf->offset);
        OUT_CS_RELOC(surf);

        OUT_CS_REG(R300_ZB_DEPTHPITCH, surf->pitch);
        OUT_CS_RELOC(surf);

        if (r300->hyperz_enabled) {
            /* HiZ RAM. */
            OUT_CS_REG(R300_ZB_HIZ_OFFSET, 0);
            OUT_CS_REG(R300_ZB_HIZ_PITCH, surf->pitch_hiz);
            /* Z Mask RAM. (compressed zbuffer) */
            OUT_CS_REG(R300_ZB_ZMASK_OFFSET, 0);
            OUT_CS_REG(R300_ZB_ZMASK_PITCH, surf->pitch_zmask);
        }
    }

    END_CS;
}

void r300_emit_hyperz_state(struct r300_context *r300,
                            unsigned size, void *state)
{
    struct r300_hyperz_state *z = state;
    CS_LOCALS(r300);

    if (z->flush)
        WRITE_CS_TABLE(&z->cb_flush_begin, size);
    else
        WRITE_CS_TABLE(&z->cb_begin, size - 2);
}

void r300_emit_hyperz_end(struct r300_context *r300)
{
    struct r300_hyperz_state z =
            *(struct r300_hyperz_state*)r300->hyperz_state.state;

    z.flush = 1;
    z.zb_bw_cntl = 0;
    z.zb_depthclearvalue = 0;
    z.sc_hyperz = R300_SC_HYPERZ_ADJ_2;
    z.gb_z_peq_config = 0;

    r300_emit_hyperz_state(r300, r300->hyperz_state.size, &z);
}

#define R300_NIBBLES(x0, y0, x1, y1, x2, y2, d0y, d0x)  \
    (((x0) & 0xf) | (((y0) & 0xf) << 4) |		   \
    (((x1) & 0xf) << 8) | (((y1) & 0xf) << 12) |	   \
    (((x2) & 0xf) << 16) | (((y2) & 0xf) << 20) |	   \
    (((d0y) & 0xf) << 24) | (((d0x) & 0xf) << 28))

static unsigned r300_get_mspos(int index, unsigned *p)
{
    unsigned reg, i, distx, disty, dist;

    if (index == 0) {
        /* MSPOS0 contains positions for samples 0,1,2 as (X,Y) pairs of nibbles,
         * followed by a (Y,X) pair containing the minimum distance from the pixel
         * edge:
         *     X0, Y0, X1, Y1, X2, Y2, D0_Y, D0_X
         *
         * There is a quirk when setting D0_X. The value represents the distance
         * from the left edge of the pixel quad to the first sample in subpixels.
         * All values less than eight should use the actual value, but „7‟ should
         * be used for the distance „8‟. The hardware will convert 7 into 8 internally.
         */
        distx = 11;
        for (i = 0; i < 12; i += 2) {
            if (p[i] < distx)
                distx = p[i];
        }

        disty = 11;
        for (i = 1; i < 12; i += 2) {
            if (p[i] < disty)
                disty = p[i];
        }

        if (distx == 8)
            distx = 7;

        reg = R300_NIBBLES(p[0], p[1], p[2], p[3], p[4], p[5], disty, distx);
    } else {
        /* MSPOS1 contains positions for samples 3,4,5 as (X,Y) pairs of nibbles,
         * followed by the minimum distance from the pixel edge (not sure if X or Y):
         *     X3, Y3, X4, Y4, X5, Y5, D1
         */
        dist = 11;
        for (i = 0; i < 12; i++) {
            if (p[i] < dist)
                dist = p[i];
        }

        reg = R300_NIBBLES(p[6], p[7], p[8], p[9], p[10], p[11], dist, 0);
    }
    return reg;
}

void r300_emit_fb_state_pipelined(struct r300_context *r300,
                                  unsigned size, void *state)
{
    /* The sample coordinates are in the range [0,11], because
     * GB_TILE_CONFIG.SUBPIXEL is set to the 1/12 subpixel precision.
     *
     * Some sample coordinates reach to neighboring pixels and should not be used.
     * (e.g. Y=11)
     *
     * The unused samples must be set to the positions of other valid samples. */
    static unsigned sample_locs_1x[12] = {
        6,6,  6,6,  6,6,  6,6,  6,6,  6,6
    };
    static unsigned sample_locs_2x[12] = {
        3,9,  9,3,  9,3,  9,3,  9,3,  9,3
    };
    static unsigned sample_locs_4x[12] = {
        4,4,  8,8,  2,10,  10,2,  10,2,  10,2
    };
    static unsigned sample_locs_6x[12] = {
        3,1,  7,3,  11,5,  1,7,  5,9,  9,10
    };

    struct pipe_framebuffer_state* fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    unsigned i, num_cbufs = fb->nr_cbufs;
    unsigned mspos0, mspos1;
    CS_LOCALS(r300);

    /* If we use the multiwrite feature, the colorbuffers 2,3,4 must be
     * marked as UNUSED in the US block. */
    if (r300->fb_multiwrite) {
        num_cbufs = MIN2(num_cbufs, 1);
    }

    BEGIN_CS(size);

    /* Colorbuffer format in the US block.
     * (must be written after unpipelined regs) */
    OUT_CS_REG_SEQ(R300_US_OUT_FMT_0, 4);
    for (i = 0; i < num_cbufs; i++) {
        OUT_CS(r300_surface(r300_get_nonnull_cb(fb, i))->format);
    }
    for (; i < 1; i++) {
        OUT_CS(R300_US_OUT_FMT_C4_8 |
               R300_C0_SEL_B | R300_C1_SEL_G |
               R300_C2_SEL_R | R300_C3_SEL_A);
    }
    for (; i < 4; i++) {
        OUT_CS(R300_US_OUT_FMT_UNUSED);
    }

    /* Set sample positions. It depends on the framebuffer sample count.
     * These are pipelined regs and as such cannot be moved to the AA state.
     */
    switch (r300->num_samples) {
    default:
        mspos0 = r300_get_mspos(0, sample_locs_1x);
        mspos1 = r300_get_mspos(1, sample_locs_1x);
        break;
    case 2:
        mspos0 = r300_get_mspos(0, sample_locs_2x);
        mspos1 = r300_get_mspos(1, sample_locs_2x);
        break;
    case 4:
        mspos0 = r300_get_mspos(0, sample_locs_4x);
        mspos1 = r300_get_mspos(1, sample_locs_4x);
        break;
    case 6:
        mspos0 = r300_get_mspos(0, sample_locs_6x);
        mspos1 = r300_get_mspos(1, sample_locs_6x);
        break;
    }

    OUT_CS_REG_SEQ(R300_GB_MSPOS0, 2);
    OUT_CS(mspos0);
    OUT_CS(mspos1);
    END_CS;
}

void r300_emit_query_start(struct r300_context *r300, unsigned size, void*state)
{
    struct r300_query *query = r300->query_current;
    CS_LOCALS(r300);

    if (!query)
	return;

    BEGIN_CS(size);
    if (r300->screen->caps.family == CHIP_RV530) {
        OUT_CS_REG(RV530_FG_ZBREG_DEST, RV530_FG_ZBREG_DEST_PIPE_SELECT_ALL);
    } else {
        OUT_CS_REG(R300_SU_REG_DEST, R300_RASTER_PIPE_SELECT_ALL);
    }
    OUT_CS_REG(R300_ZB_ZPASS_DATA, 0);
    END_CS;
    query->begin_emitted = TRUE;
}

static void r300_emit_query_end_frag_pipes(struct r300_context *r300,
                                           struct r300_query *query)
{
    struct r300_capabilities* caps = &r300->screen->caps;
    uint32_t gb_pipes = r300->screen->info.r300_num_gb_pipes;
    CS_LOCALS(r300);

    assert(gb_pipes);

    BEGIN_CS(6 * gb_pipes + 2);
    /* I'm not so sure I like this switch, but it's hard to be elegant
     * when there's so many special cases...
     *
     * So here's the basic idea. For each pipe, enable writes to it only,
     * then put out the relocation for ZPASS_ADDR, taking into account a
     * 4-byte offset for each pipe. RV380 and older are special; they have
     * only two pipes, and the second pipe's enable is on bit 3, not bit 1,
     * so there's a chipset cap for that. */
    switch (gb_pipes) {
        case 4:
            /* pipe 3 only */
            OUT_CS_REG(R300_SU_REG_DEST, 1 << 3);
            OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 3) * 4);
            OUT_CS_RELOC(r300->query_current);
        case 3:
            /* pipe 2 only */
            OUT_CS_REG(R300_SU_REG_DEST, 1 << 2);
            OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 2) * 4);
            OUT_CS_RELOC(r300->query_current);
        case 2:
            /* pipe 1 only */
            /* As mentioned above, accomodate RV380 and older. */
            OUT_CS_REG(R300_SU_REG_DEST,
                    1 << (caps->high_second_pipe ? 3 : 1));
            OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 1) * 4);
            OUT_CS_RELOC(r300->query_current);
        case 1:
            /* pipe 0 only */
            OUT_CS_REG(R300_SU_REG_DEST, 1 << 0);
            OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 0) * 4);
            OUT_CS_RELOC(r300->query_current);
            break;
        default:
            fprintf(stderr, "r300: Implementation error: Chipset reports %d"
                    " pixel pipes!\n", gb_pipes);
            abort();
    }

    /* And, finally, reset it to normal... */
    OUT_CS_REG(R300_SU_REG_DEST, 0xF);
    END_CS;
}

static void rv530_emit_query_end_single_z(struct r300_context *r300,
                                          struct r300_query *query)
{
    CS_LOCALS(r300);

    BEGIN_CS(8);
    OUT_CS_REG(RV530_FG_ZBREG_DEST, RV530_FG_ZBREG_DEST_PIPE_SELECT_0);
    OUT_CS_REG(R300_ZB_ZPASS_ADDR, query->num_results * 4);
    OUT_CS_RELOC(r300->query_current);
    OUT_CS_REG(RV530_FG_ZBREG_DEST, RV530_FG_ZBREG_DEST_PIPE_SELECT_ALL);
    END_CS;
}

static void rv530_emit_query_end_double_z(struct r300_context *r300,
                                          struct r300_query *query)
{
    CS_LOCALS(r300);

    BEGIN_CS(14);
    OUT_CS_REG(RV530_FG_ZBREG_DEST, RV530_FG_ZBREG_DEST_PIPE_SELECT_0);
    OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 0) * 4);
    OUT_CS_RELOC(r300->query_current);
    OUT_CS_REG(RV530_FG_ZBREG_DEST, RV530_FG_ZBREG_DEST_PIPE_SELECT_1);
    OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 1) * 4);
    OUT_CS_RELOC(r300->query_current);
    OUT_CS_REG(RV530_FG_ZBREG_DEST, RV530_FG_ZBREG_DEST_PIPE_SELECT_ALL);
    END_CS;
}

void r300_emit_query_end(struct r300_context* r300)
{
    struct r300_capabilities *caps = &r300->screen->caps;
    struct r300_query *query = r300->query_current;

    if (!query)
	return;

    if (query->begin_emitted == FALSE)
        return;

    if (caps->family == CHIP_RV530) {
        if (r300->screen->info.r300_num_z_pipes == 2)
            rv530_emit_query_end_double_z(r300, query);
        else
            rv530_emit_query_end_single_z(r300, query);
    } else 
        r300_emit_query_end_frag_pipes(r300, query);

    query->begin_emitted = FALSE;
    query->num_results += query->num_pipes;

    /* XXX grab all the results and reset the counter. */
    if (query->num_results >= query->buf->size / 4 - 4) {
        query->num_results = (query->buf->size / 4) / 2;
        fprintf(stderr, "r300: Rewinding OQBO...\n");
    }
}

void r300_emit_invariant_state(struct r300_context *r300,
                               unsigned size, void *state)
{
    CS_LOCALS(r300);
    WRITE_CS_TABLE(state, size);
}

void r300_emit_rs_state(struct r300_context* r300, unsigned size, void* state)
{
    struct r300_rs_state* rs = state;
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_TABLE(rs->cb_main, RS_STATE_MAIN_SIZE);
    if (rs->polygon_offset_enable) {
        if (r300->zbuffer_bpp == 16) {
            OUT_CS_TABLE(rs->cb_poly_offset_zb16, 5);
        } else {
            OUT_CS_TABLE(rs->cb_poly_offset_zb24, 5);
        }
    }
    END_CS;
}

void r300_emit_rs_block_state(struct r300_context* r300,
                              unsigned size, void* state)
{
    struct r300_rs_block* rs = (struct r300_rs_block*)state;
    unsigned i;
    /* It's the same for both INST and IP tables */
    unsigned count = (rs->inst_count & R300_RS_INST_COUNT_MASK) + 1;
    CS_LOCALS(r300);

    if (DBG_ON(r300, DBG_RS_BLOCK)) {
        r500_dump_rs_block(rs);

        fprintf(stderr, "r300: RS emit:\n");

        for (i = 0; i < count; i++)
            fprintf(stderr, "    : ip %d: 0x%08x\n", i, rs->ip[i]);

        for (i = 0; i < count; i++)
            fprintf(stderr, "    : inst %d: 0x%08x\n", i, rs->inst[i]);

        fprintf(stderr, "    : count: 0x%08x inst_count: 0x%08x\n",
            rs->count, rs->inst_count);
    }

    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_VAP_VTX_STATE_CNTL, 2);
    OUT_CS(rs->vap_vtx_state_cntl);
    OUT_CS(rs->vap_vsm_vtx_assm);
    OUT_CS_REG_SEQ(R300_VAP_OUTPUT_VTX_FMT_0, 2);
    OUT_CS(rs->vap_out_vtx_fmt[0]);
    OUT_CS(rs->vap_out_vtx_fmt[1]);
    OUT_CS_REG_SEQ(R300_GB_ENABLE, 1);
    OUT_CS(rs->gb_enable);

    if (r300->screen->caps.is_r500) {
        OUT_CS_REG_SEQ(R500_RS_IP_0, count);
    } else {
        OUT_CS_REG_SEQ(R300_RS_IP_0, count);
    }
    OUT_CS_TABLE(rs->ip, count);

    OUT_CS_REG_SEQ(R300_RS_COUNT, 2);
    OUT_CS(rs->count);
    OUT_CS(rs->inst_count);

    if (r300->screen->caps.is_r500) {
        OUT_CS_REG_SEQ(R500_RS_INST_0, count);
    } else {
        OUT_CS_REG_SEQ(R300_RS_INST_0, count);
    }
    OUT_CS_TABLE(rs->inst, count);
    END_CS;
}

void r300_emit_sample_mask(struct r300_context *r300,
                           unsigned size, void *state)
{
    unsigned mask = (*(unsigned*)state) & ((1 << 6)-1);
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG(R300_SC_SCREENDOOR,
               mask | (mask << 6) | (mask << 12) | (mask << 18));
    END_CS;
}

void r300_emit_scissor_state(struct r300_context* r300,
                             unsigned size, void* state)
{
    struct pipe_scissor_state* scissor = (struct pipe_scissor_state*)state;
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_SC_CLIPRECT_TL_0, 2);
    if (r300->screen->caps.is_r500) {
        OUT_CS((scissor->minx << R300_CLIPRECT_X_SHIFT) |
               (scissor->miny << R300_CLIPRECT_Y_SHIFT));
        OUT_CS(((scissor->maxx - 1) << R300_CLIPRECT_X_SHIFT) |
               ((scissor->maxy - 1) << R300_CLIPRECT_Y_SHIFT));
    } else {
        OUT_CS(((scissor->minx + 1440) << R300_CLIPRECT_X_SHIFT) |
               ((scissor->miny + 1440) << R300_CLIPRECT_Y_SHIFT));
        OUT_CS(((scissor->maxx + 1440-1) << R300_CLIPRECT_X_SHIFT) |
               ((scissor->maxy + 1440-1) << R300_CLIPRECT_Y_SHIFT));
    }
    END_CS;
}

void r300_emit_textures_state(struct r300_context *r300,
                              unsigned size, void *state)
{
    struct r300_textures_state *allstate = (struct r300_textures_state*)state;
    struct r300_texture_sampler_state *texstate;
    struct r300_resource *tex;
    unsigned i;
    boolean has_us_format = r300->screen->caps.has_us_format;
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG(R300_TX_ENABLE, allstate->tx_enable);

    for (i = 0; i < allstate->count; i++) {
        if ((1 << i) & allstate->tx_enable) {
            texstate = &allstate->regs[i];
            tex = r300_resource(allstate->sampler_views[i]->base.texture);

            OUT_CS_REG(R300_TX_FILTER0_0 + (i * 4), texstate->filter0);
            OUT_CS_REG(R300_TX_FILTER1_0 + (i * 4), texstate->filter1);
            OUT_CS_REG(R300_TX_BORDER_COLOR_0 + (i * 4),
                       texstate->border_color);

            OUT_CS_REG(R300_TX_FORMAT0_0 + (i * 4), texstate->format.format0);
            OUT_CS_REG(R300_TX_FORMAT1_0 + (i * 4), texstate->format.format1);
            OUT_CS_REG(R300_TX_FORMAT2_0 + (i * 4), texstate->format.format2);

            OUT_CS_REG(R300_TX_OFFSET_0 + (i * 4), texstate->format.tile_config);
            OUT_CS_RELOC(tex);

            if (has_us_format) {
                OUT_CS_REG(R500_US_FORMAT0_0 + (i * 4),
                           texstate->format.us_format0);
            }
        }
    }
    END_CS;
}

void r300_emit_vertex_arrays(struct r300_context* r300, int offset,
                             boolean indexed, int instance_id)
{
    struct pipe_vertex_buffer *vbuf = r300->vertex_buffer;
    struct pipe_vertex_element *velem = r300->velems->velem;
    struct r300_resource *buf;
    int i;
    unsigned vertex_array_count = r300->velems->count;
    unsigned packet_size = (vertex_array_count * 3 + 1) / 2;
    struct pipe_vertex_buffer *vb1, *vb2;
    unsigned *hw_format_size = r300->velems->format_size;
    unsigned size1, size2, offset1, offset2, stride1, stride2;
    CS_LOCALS(r300);

    BEGIN_CS(2 + packet_size + vertex_array_count * 2);
    OUT_CS_PKT3(R300_PACKET3_3D_LOAD_VBPNTR, packet_size);
    OUT_CS(vertex_array_count | (!indexed ? R300_VC_FORCE_PREFETCH : 0));

    if (instance_id == -1) {
        /* Non-instanced arrays. This ignores instance_divisor and instance_id. */
        for (i = 0; i < vertex_array_count - 1; i += 2) {
            vb1 = &vbuf[velem[i].vertex_buffer_index];
            vb2 = &vbuf[velem[i+1].vertex_buffer_index];
            size1 = hw_format_size[i];
            size2 = hw_format_size[i+1];

            OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride) |
                   R300_VBPNTR_SIZE1(size2) | R300_VBPNTR_STRIDE1(vb2->stride));
            OUT_CS(vb1->buffer_offset + velem[i].src_offset   + offset * vb1->stride);
            OUT_CS(vb2->buffer_offset + velem[i+1].src_offset + offset * vb2->stride);
        }

        if (vertex_array_count & 1) {
            vb1 = &vbuf[velem[i].vertex_buffer_index];
            size1 = hw_format_size[i];

            OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride));
            OUT_CS(vb1->buffer_offset + velem[i].src_offset + offset * vb1->stride);
        }

        for (i = 0; i < vertex_array_count; i++) {
            buf = r300_resource(vbuf[velem[i].vertex_buffer_index].buffer);
            OUT_CS_RELOC(buf);
        }
    } else {
        /* Instanced arrays. */
        for (i = 0; i < vertex_array_count - 1; i += 2) {
            vb1 = &vbuf[velem[i].vertex_buffer_index];
            vb2 = &vbuf[velem[i+1].vertex_buffer_index];
            size1 = hw_format_size[i];
            size2 = hw_format_size[i+1];

            if (velem[i].instance_divisor) {
                stride1 = 0;
                offset1 = vb1->buffer_offset + velem[i].src_offset +
                          (instance_id / velem[i].instance_divisor) * vb1->stride;
            } else {
                stride1 = vb1->stride;
                offset1 = vb1->buffer_offset + velem[i].src_offset + offset * vb1->stride;
            }
            if (velem[i+1].instance_divisor) {
                stride2 = 0;
                offset2 = vb2->buffer_offset + velem[i+1].src_offset +
                          (instance_id / velem[i+1].instance_divisor) * vb2->stride;
            } else {
                stride2 = vb2->stride;
                offset2 = vb2->buffer_offset + velem[i+1].src_offset + offset * vb2->stride;
            }

            OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(stride1) |
                   R300_VBPNTR_SIZE1(size2) | R300_VBPNTR_STRIDE1(stride2));
            OUT_CS(offset1);
            OUT_CS(offset2);
        }

        if (vertex_array_count & 1) {
            vb1 = &vbuf[velem[i].vertex_buffer_index];
            size1 = hw_format_size[i];

            if (velem[i].instance_divisor) {
                stride1 = 0;
                offset1 = vb1->buffer_offset + velem[i].src_offset +
                          (instance_id / velem[i].instance_divisor) * vb1->stride;
            } else {
                stride1 = vb1->stride;
                offset1 = vb1->buffer_offset + velem[i].src_offset + offset * vb1->stride;
            }

            OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(stride1));
            OUT_CS(offset1);
        }

        for (i = 0; i < vertex_array_count; i++) {
            buf = r300_resource(vbuf[velem[i].vertex_buffer_index].buffer);
            OUT_CS_RELOC(buf);
        }
    }
    END_CS;
}

void r300_emit_vertex_arrays_swtcl(struct r300_context *r300, boolean indexed)
{
    CS_LOCALS(r300);

    DBG(r300, DBG_SWTCL, "r300: Preparing vertex buffer %p for render, "
            "vertex size %d\n", r300->vbo,
            r300->vertex_info.size);
    /* Set the pointer to our vertex buffer. The emitted values are this:
     * PACKET3 [3D_LOAD_VBPNTR]
     * COUNT   [1]
     * FORMAT  [size | stride << 8]
     * OFFSET  [offset into BO]
     * VBPNTR  [relocated BO]
     */
    BEGIN_CS(7);
    OUT_CS_PKT3(R300_PACKET3_3D_LOAD_VBPNTR, 3);
    OUT_CS(1 | (!indexed ? R300_VC_FORCE_PREFETCH : 0));
    OUT_CS(r300->vertex_info.size |
            (r300->vertex_info.size << 8));
    OUT_CS(r300->draw_vbo_offset);
    OUT_CS(0);

    assert(r300->vbo_cs);
    OUT_CS(0xc0001000); /* PKT3_NOP */
    OUT_CS(r300->rws->cs_get_reloc(r300->cs, r300->vbo_cs) * 4);
    END_CS;
}

void r300_emit_vertex_stream_state(struct r300_context* r300,
                                   unsigned size, void* state)
{
    struct r300_vertex_stream_state *streams =
        (struct r300_vertex_stream_state*)state;
    unsigned i;
    CS_LOCALS(r300);

    if (DBG_ON(r300, DBG_PSC)) {
        fprintf(stderr, "r300: PSC emit:\n");

        for (i = 0; i < streams->count; i++) {
            fprintf(stderr, "    : prog_stream_cntl%d: 0x%08x\n", i,
                   streams->vap_prog_stream_cntl[i]);
        }

        for (i = 0; i < streams->count; i++) {
            fprintf(stderr, "    : prog_stream_cntl_ext%d: 0x%08x\n", i,
                   streams->vap_prog_stream_cntl_ext[i]);
        }
    }

    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_VAP_PROG_STREAM_CNTL_0, streams->count);
    OUT_CS_TABLE(streams->vap_prog_stream_cntl, streams->count);
    OUT_CS_REG_SEQ(R300_VAP_PROG_STREAM_CNTL_EXT_0, streams->count);
    OUT_CS_TABLE(streams->vap_prog_stream_cntl_ext, streams->count);
    END_CS;
}

void r300_emit_pvs_flush(struct r300_context* r300, unsigned size, void* state)
{
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0x0);
    END_CS;
}

void r300_emit_vap_invariant_state(struct r300_context *r300,
                                   unsigned size, void *state)
{
    CS_LOCALS(r300);
    WRITE_CS_TABLE(state, size);
}

void r300_emit_vs_state(struct r300_context* r300, unsigned size, void* state)
{
    struct r300_vertex_shader* vs = (struct r300_vertex_shader*)state;
    struct r300_vertex_program_code* code = &vs->code;
    struct r300_screen* r300screen = r300->screen;
    unsigned instruction_count = code->length / 4;

    unsigned vtx_mem_size = r300screen->caps.is_r500 ? 128 : 72;
    unsigned input_count = MAX2(util_bitcount(code->InputsRead), 1);
    unsigned output_count = MAX2(util_bitcount(code->OutputsWritten), 1);
    unsigned temp_count = MAX2(code->num_temporaries, 1);

    unsigned pvs_num_slots = MIN3(vtx_mem_size / input_count,
                                  vtx_mem_size / output_count, 10);
    unsigned pvs_num_controllers = MIN2(vtx_mem_size / temp_count, 5);

    CS_LOCALS(r300);

    BEGIN_CS(size);

    /* R300_VAP_PVS_CODE_CNTL_0
     * R300_VAP_PVS_CONST_CNTL
     * R300_VAP_PVS_CODE_CNTL_1
     * See the r5xx docs for instructions on how to use these. */
    OUT_CS_REG(R300_VAP_PVS_CODE_CNTL_0, R300_PVS_FIRST_INST(0) |
	       R300_PVS_XYZW_VALID_INST(instruction_count - 1) |
	       R300_PVS_LAST_INST(instruction_count - 1));
    OUT_CS_REG(R300_VAP_PVS_CODE_CNTL_1, instruction_count - 1);

    OUT_CS_REG(R300_VAP_PVS_VECTOR_INDX_REG, 0);
    OUT_CS_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, code->length);
    OUT_CS_TABLE(code->body.d, code->length);

    OUT_CS_REG(R300_VAP_CNTL, R300_PVS_NUM_SLOTS(pvs_num_slots) |
            R300_PVS_NUM_CNTLRS(pvs_num_controllers) |
            R300_PVS_NUM_FPUS(r300screen->caps.num_vert_fpus) |
            R300_PVS_VF_MAX_VTX_NUM(12) |
            (r300screen->caps.is_r500 ? R500_TCL_STATE_OPTIMIZATION : 0));

    /* Emit flow control instructions.  Even if there are no fc instructions,
     * we still need to write the registers to make sure they are cleared. */
    OUT_CS_REG(R300_VAP_PVS_FLOW_CNTL_OPC, code->fc_ops);
    if (r300screen->caps.is_r500) {
        OUT_CS_REG_SEQ(R500_VAP_PVS_FLOW_CNTL_ADDRS_LW_0, R300_VS_MAX_FC_OPS * 2);
        OUT_CS_TABLE(code->fc_op_addrs.r500, R300_VS_MAX_FC_OPS * 2);
    } else {
        OUT_CS_REG_SEQ(R300_VAP_PVS_FLOW_CNTL_ADDRS_0, R300_VS_MAX_FC_OPS);
        OUT_CS_TABLE(code->fc_op_addrs.r300, R300_VS_MAX_FC_OPS);
    }
    OUT_CS_REG_SEQ(R300_VAP_PVS_FLOW_CNTL_LOOP_INDEX_0, R300_VS_MAX_FC_OPS);
    OUT_CS_TABLE(code->fc_loop_index, R300_VS_MAX_FC_OPS);

    END_CS;
}

void r300_emit_vs_constants(struct r300_context* r300,
                            unsigned size, void *state)
{
    unsigned count =
        ((struct r300_vertex_shader*)r300->vs_state.state)->externals_count;
    struct r300_constant_buffer *buf = (struct r300_constant_buffer*)state;
    struct r300_vertex_shader *vs = (struct r300_vertex_shader*)r300->vs_state.state;
    unsigned i;
    int imm_first = vs->externals_count;
    int imm_end = vs->code.constants.Count;
    int imm_count = vs->immediates_count;
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG(R300_VAP_PVS_CONST_CNTL,
               R300_PVS_CONST_BASE_OFFSET(buf->buffer_base) |
               R300_PVS_MAX_CONST_ADDR(MAX2(imm_end - 1, 0)));
    if (vs->externals_count) {
        OUT_CS_REG(R300_VAP_PVS_VECTOR_INDX_REG,
                   (r300->screen->caps.is_r500 ?
                   R500_PVS_CONST_START : R300_PVS_CONST_START) + buf->buffer_base);
        OUT_CS_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, count * 4);
        if (buf->remap_table){
            for (i = 0; i < count; i++) {
                uint32_t *data = &buf->ptr[buf->remap_table[i]*4];
                OUT_CS_TABLE(data, 4);
            }
        } else {
            OUT_CS_TABLE(buf->ptr, count * 4);
        }
    }

    /* Emit immediates. */
    if (imm_count) {
        OUT_CS_REG(R300_VAP_PVS_VECTOR_INDX_REG,
                   (r300->screen->caps.is_r500 ?
                   R500_PVS_CONST_START : R300_PVS_CONST_START) +
                   buf->buffer_base + imm_first);
        OUT_CS_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, imm_count * 4);
        for (i = imm_first; i < imm_end; i++) {
            const float *data = vs->code.constants.Constants[i].u.Immediate;
            OUT_CS_TABLE(data, 4);
        }
    }
    END_CS;
}

void r300_emit_viewport_state(struct r300_context* r300,
                              unsigned size, void* state)
{
    struct r300_viewport_state* viewport = (struct r300_viewport_state*)state;
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_SE_VPORT_XSCALE, 6);
    OUT_CS_TABLE(&viewport->xscale, 6);
    OUT_CS_REG(R300_VAP_VTE_CNTL, viewport->vte_control);
    END_CS;
}

void r300_emit_hiz_clear(struct r300_context *r300, unsigned size, void *state)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_resource* tex;
    CS_LOCALS(r300);

    tex = r300_resource(fb->zsbuf->texture);

    BEGIN_CS(size);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_HIZ, 2);
    OUT_CS(0);
    OUT_CS(tex->tex.hiz_dwords[fb->zsbuf->u.tex.level]);
    OUT_CS(r300->hiz_clear_value);
    END_CS;

    /* Mark the current zbuffer's hiz ram as in use. */
    r300->hiz_in_use = TRUE;
    r300->hiz_func = HIZ_FUNC_NONE;
    r300_mark_atom_dirty(r300, &r300->hyperz_state);
}

void r300_emit_zmask_clear(struct r300_context *r300, unsigned size, void *state)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_resource *tex;
    CS_LOCALS(r300);

    tex = r300_resource(fb->zsbuf->texture);

    BEGIN_CS(size);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_ZMASK, 2);
    OUT_CS(0);
    OUT_CS(tex->tex.zmask_dwords[fb->zsbuf->u.tex.level]);
    OUT_CS(0);
    END_CS;

    /* Mark the current zbuffer's zmask as in use. */
    r300->zmask_in_use = TRUE;
    r300_mark_atom_dirty(r300, &r300->hyperz_state);
}

void r300_emit_cmask_clear(struct r300_context *r300, unsigned size, void *state)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_resource *tex;
    CS_LOCALS(r300);

    tex = r300_resource(fb->cbufs[0]->texture);

    BEGIN_CS(size);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_CMASK, 2);
    OUT_CS(0);
    OUT_CS(tex->tex.cmask_dwords);
    OUT_CS(0);
    END_CS;

    /* Mark the current zbuffer's zmask as in use. */
    r300->cmask_in_use = TRUE;
    r300_mark_fb_state_dirty(r300, R300_CHANGED_CMASK_ENABLE);
}

void r300_emit_ztop_state(struct r300_context* r300,
                          unsigned size, void* state)
{
    struct r300_ztop_state* ztop = (struct r300_ztop_state*)state;
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG(R300_ZB_ZTOP, ztop->z_buffer_top);
    END_CS;
}

void r300_emit_texture_cache_inval(struct r300_context* r300, unsigned size, void* state)
{
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG(R300_TX_INVALTAGS, 0);
    END_CS;
}

boolean r300_emit_buffer_validate(struct r300_context *r300,
                                  boolean do_validate_vertex_buffers,
                                  struct pipe_resource *index_buffer)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_aa_state *aa = (struct r300_aa_state*)r300->aa_state.state;
    struct r300_textures_state *texstate =
        (struct r300_textures_state*)r300->textures_state.state;
    struct r300_resource *tex;
    unsigned i;
    boolean flushed = FALSE;

validate:
    if (r300->fb_state.dirty) {
        /* Color buffers... */
        for (i = 0; i < fb->nr_cbufs; i++) {
            if (!fb->cbufs[i])
                continue;
            tex = r300_resource(fb->cbufs[i]->texture);
            assert(tex && tex->buf && "cbuf is marked, but NULL!");
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf,
                                    RADEON_USAGE_READWRITE,
                                    r300_surface(fb->cbufs[i])->domain,
                                    tex->b.b.nr_samples > 1 ?
                                    RADEON_PRIO_COLOR_BUFFER_MSAA :
                                    RADEON_PRIO_COLOR_BUFFER);
        }
        /* ...depth buffer... */
        if (fb->zsbuf) {
            tex = r300_resource(fb->zsbuf->texture);
            assert(tex && tex->buf && "zsbuf is marked, but NULL!");
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf,
                                    RADEON_USAGE_READWRITE,
                                    r300_surface(fb->zsbuf)->domain,
                                    tex->b.b.nr_samples > 1 ?
                                    RADEON_PRIO_DEPTH_BUFFER_MSAA :
                                    RADEON_PRIO_DEPTH_BUFFER);
        }
    }
    /* The AA resolve buffer. */
    if (r300->aa_state.dirty) {
        if (aa->dest) {
            r300->rws->cs_add_reloc(r300->cs, aa->dest->cs_buf,
                                    RADEON_USAGE_WRITE,
                                    aa->dest->domain,
                                    RADEON_PRIO_COLOR_BUFFER);
        }
    }
    if (r300->textures_state.dirty) {
        /* ...textures... */
        for (i = 0; i < texstate->count; i++) {
            if (!(texstate->tx_enable & (1 << i))) {
                continue;
            }

            tex = r300_resource(texstate->sampler_views[i]->base.texture);
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf, RADEON_USAGE_READ,
                                    tex->domain, RADEON_PRIO_SHADER_TEXTURE_RO);
        }
    }
    /* ...occlusion query buffer... */
    if (r300->query_current)
        r300->rws->cs_add_reloc(r300->cs, r300->query_current->cs_buf,
                                RADEON_USAGE_WRITE, RADEON_DOMAIN_GTT,
                                RADEON_PRIO_MIN);
    /* ...vertex buffer for SWTCL path... */
    if (r300->vbo_cs)
        r300->rws->cs_add_reloc(r300->cs, r300->vbo_cs,
                                RADEON_USAGE_READ, RADEON_DOMAIN_GTT,
                                RADEON_PRIO_MIN);
    /* ...vertex buffers for HWTCL path... */
    if (do_validate_vertex_buffers && r300->vertex_arrays_dirty) {
        struct pipe_vertex_buffer *vbuf = r300->vertex_buffer;
        struct pipe_vertex_buffer *last = r300->vertex_buffer +
                                      r300->nr_vertex_buffers;
        struct pipe_resource *buf;

        for (; vbuf != last; vbuf++) {
            buf = vbuf->buffer;
            if (!buf)
                continue;

            r300->rws->cs_add_reloc(r300->cs, r300_resource(buf)->cs_buf,
                                    RADEON_USAGE_READ,
                                    r300_resource(buf)->domain,
                                    RADEON_PRIO_SHADER_BUFFER_RO);
        }
    }
    /* ...and index buffer for HWTCL path. */
    if (index_buffer)
        r300->rws->cs_add_reloc(r300->cs, r300_resource(index_buffer)->cs_buf,
                                RADEON_USAGE_READ,
                                r300_resource(index_buffer)->domain,
                                RADEON_PRIO_MIN);

    /* Now do the validation (flush is called inside cs_validate on failure). */
    if (!r300->rws->cs_validate(r300->cs)) {
        /* Ooops, an infinite loop, give up. */
        if (flushed)
            return FALSE;

        flushed = TRUE;
        goto validate;
    }

    return TRUE;
}

unsigned r300_get_num_dirty_dwords(struct r300_context *r300)
{
    struct r300_atom* atom;
    unsigned dwords = 0;

    foreach_dirty_atom(r300, atom) {
        if (atom->dirty) {
            dwords += atom->size;
        }
    }

    /* let's reserve some more, just in case */
    dwords += 32;

    return dwords;
}

unsigned r300_get_num_cs_end_dwords(struct r300_context *r300)
{
    unsigned dwords = 0;

    /* Emitted in flush. */
    dwords += 26; /* emit_query_end */
    dwords += r300->hyperz_state.size + 2; /* emit_hyperz_end + zcache flush */
    if (r300->screen->caps.is_r500)
        dwords += 2; /* emit_index_bias */
    if (r300->screen->info.drm_minor >= 6)
        dwords += 3; /* MSPOS */

    return dwords;
}

/* Emit all dirty state. */
void r300_emit_dirty_state(struct r300_context* r300)
{
    struct r300_atom *atom;

    foreach_dirty_atom(r300, atom) {
        if (atom->dirty) {
            atom->emit(r300, atom->size, atom->state);
            atom->dirty = FALSE;
        }
    }

    r300->first_dirty = NULL;
    r300->last_dirty = NULL;
    r300->dirty_hw++;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a1138 1
            (r300->clip_halfz ? R300_DX_CLIP_SPACE_DEF : 0) |
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1139 1
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d45 1
d48 4
a51 2
    if (fb->nr_cbufs) {
        if (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT) {
d53 1
a53 1
        } else if (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16X16_FLOAT) {
d56 1
a56 1
            unsigned swz = r300_surface(fb->cbufs[0])->colormask_swizzle;
d94 5
a98 3
        if (fb->nr_cbufs &&
            (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
             fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16X16_FLOAT)) {
d427 1
a427 1
        surf = r300_surface(fb->cbufs[i]);
d608 1
a608 1
        OUT_CS(r300_surface(fb->cbufs[i])->format);
d1051 2
a1052 2
    cs_winsys->cs_write_reloc(cs_copy, r300->vbo_cs);
    CS_USED_DW(2);
d1318 2
d1324 4
a1327 1
                                    r300_surface(fb->cbufs[i])->domain);
d1335 4
a1338 1
                                    r300_surface(fb->zsbuf)->domain);
d1346 2
a1347 1
                                    aa->dest->domain);
d1359 1
a1359 1
                                    tex->domain);
d1365 2
a1366 1
                                RADEON_USAGE_WRITE, RADEON_DOMAIN_GTT);
d1370 2
a1371 1
                                RADEON_USAGE_READ, RADEON_DOMAIN_GTT);
d1386 2
a1387 1
                                    r300_resource(buf)->domain);
d1394 2
a1395 1
                                r300_resource(index_buffer)->domain);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d48 1
a48 1
        if (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT)
d50 6
a55 2
        else
            WRITE_CS_TABLE(blend->cb_clamp, size);
d84 1
d86 13
d100 5
a104 10
    if (fb->zsbuf) {
        if (fb->nr_cbufs && fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT)
            WRITE_CS_TABLE(&dsa->cb_begin_fp16, size);
        else
            WRITE_CS_TABLE(&dsa->cb_begin, size);
    } else {
        if (fb->nr_cbufs && fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT)
            WRITE_CS_TABLE(dsa->cb_fp16_zb_no_readwrite, size);
        else
            WRITE_CS_TABLE(dsa->cb_zb_no_readwrite, size);
d106 5
d141 3
a143 3
            vec[0] = tex->b.b.b.width0  / (tex->tex.width0  + 0.001f);
            vec[1] = tex->b.b.b.height0 / (tex->tex.height0 + 0.001f);
            vec[2] = tex->b.b.b.depth0  / (tex->tex.depth0  + 0.001f);
d382 5
a386 1
        OUT_CS_REG(R300_RB3D_AARESOLVE_OFFSET, aa->dest->offset);
d388 2
a389 1
        OUT_CS_REG(R300_RB3D_AARESOLVE_PITCH, aa->dest->pitch);
a391 1
    OUT_CS_REG(R300_RB3D_AARESOLVE_CTL, aa->aaresolve_ctl);
a405 2
    /* NUM_MULTIWRITES replicates COLOR[0] to all colorbuffers, which is not
     * what we usually want. */
d409 1
d413 4
d429 11
a477 13
    /* Set up a dummy zbuffer. Otherwise occlusion queries won't work.
     * Use the first colorbuffer, we will disable writes in the DSA state
     * so as not to corrupt it. */
    } else if (fb->nr_cbufs) {
        surf = r300_surface(fb->cbufs[0]);

        OUT_CS_REG(R300_ZB_FORMAT, R300_DEPTHFORMAT_16BIT_INT_Z);

        OUT_CS_REG(R300_ZB_DEPTHOFFSET, 0);
        OUT_CS_RELOC(surf);

        OUT_CS_REG(R300_ZB_DEPTHPITCH, 4 | R300_DEPTHMICROTILE_TILED_SQUARE);
        OUT_CS_RELOC(surf);
d509 53
d565 20
d614 20
a633 28
    /* Multisampling. Depends on framebuffer sample count.
     * These are pipelined regs and as such cannot be moved
     * to the AA state. */
    mspos0 = 0x66666666;
    mspos1 = 0x6666666;

    if (fb->nr_cbufs && fb->cbufs[0]->texture->nr_samples > 1) {
        /* Subsample placement. These may not be optimal. */
        switch (fb->cbufs[0]->texture->nr_samples) {
        case 2:
            mspos0 = 0x33996633;
            mspos1 = 0x6666663;
            break;
        case 3:
            mspos0 = 0x33936933;
            mspos1 = 0x6666663;
            break;
        case 4:
            mspos0 = 0x33939933;
            mspos1 = 0x3966663;
            break;
        case 6:
            mspos0 = 0x22a2aa22;
            mspos1 = 0x2a65672;
            break;
        default:
            debug_printf("r300: Bad number of multisamples!\n");
        }
d651 1
a651 1
    if (r300->screen->caps.family == CHIP_FAMILY_RV530) {
d665 1
d668 1
a668 1
    assert(caps->num_frag_pipes);
d670 1
a670 1
    BEGIN_CS(6 * caps->num_frag_pipes + 2);
d679 1
a679 1
    switch (caps->num_frag_pipes) {
d705 1
a705 1
                    " pixel pipes!\n", caps->num_frag_pipes);
d754 2
a755 2
    if (caps->family == CHIP_FAMILY_RV530) {
        if (caps->num_z_pipes == 2)
d766 2
a767 2
    if (query->num_results >= query->buffer_size / 4 - 4) {
        query->num_results = (query->buffer_size / 4) / 2;
d850 12
d926 1
a926 1
    struct pipe_vertex_buffer *vbuf = r300->vbuf_mgr->real_vertex_buffer;
d1044 4
a1047 1
    OUT_CS_RELOC(r300_resource(r300->vbo));
d1136 9
a1144 13
    /* Emit flow control instructions. */
    if (code->num_fc_ops) {

        OUT_CS_REG(R300_VAP_PVS_FLOW_CNTL_OPC, code->fc_ops);
        if (r300screen->caps.is_r500) {
            OUT_CS_REG_SEQ(R500_VAP_PVS_FLOW_CNTL_ADDRS_LW_0, code->num_fc_ops * 2);
            OUT_CS_TABLE(code->fc_op_addrs.r500, code->num_fc_ops * 2);
        } else {
            OUT_CS_REG_SEQ(R300_VAP_PVS_FLOW_CNTL_ADDRS_0, code->num_fc_ops);
            OUT_CS_TABLE(code->fc_op_addrs.r300, code->num_fc_ops);
        }
        OUT_CS_REG_SEQ(R300_VAP_PVS_FLOW_CNTL_LOOP_INDEX_0, code->num_fc_ops);
        OUT_CS_TABLE(code->fc_loop_index, code->num_fc_ops);
d1146 2
d1255 21
d1302 1
d1315 2
a1316 1
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf, 0,
d1323 2
a1324 1
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf, 0,
d1328 8
d1344 2
a1345 1
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf, tex->domain, 0);
d1351 1
a1351 1
                                0, r300->query_current->domain);
d1353 3
a1355 3
    if (r300->vbo)
        r300->rws->cs_add_reloc(r300->cs, r300_resource(r300->vbo)->cs_buf,
                                r300_resource(r300->vbo)->domain, 0);
d1358 3
a1360 3
        struct pipe_vertex_buffer *vbuf = r300->vbuf_mgr->real_vertex_buffer;
        struct pipe_vertex_buffer *last = r300->vbuf_mgr->real_vertex_buffer +
                                      r300->vbuf_mgr->nr_real_vertex_buffers;
d1362 1
d1369 2
a1370 1
                                    r300_resource(buf)->domain, 0);
d1376 2
a1377 1
                                r300_resource(index_buffer)->domain, 0);
d1417 3
a1419 1
        dwords += 2;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a28 1
#include "util/u_simple_list.h"
d48 4
a51 1
        WRITE_CS_TABLE(blend->cb, size);
d83 4
a86 1
        WRITE_CS_TABLE(&dsa->cb_begin, size);
d88 4
a91 1
        WRITE_CS_TABLE(dsa->cb_no_readwrite, size);
d101 1
a101 1
    struct r300_texture *tex;
d113 3
a115 3
            tex = r300_texture(texstate->sampler_views[constant->u.State[1]]->base.texture);
            vec[0] = 1.0 / tex->desc.width0;
            vec[1] = 1.0 / tex->desc.height0;
d121 1
a121 1
            tex = r300_texture(texstate->sampler_views[constant->u.State[1]]->base.texture);
d123 3
a125 3
            vec[0] = tex->desc.b.b.width0  / (tex->desc.width0  + 0.001f);
            vec[1] = tex->desc.b.b.height0 / (tex->desc.height0 + 0.001f);
            vec[2] = tex->desc.b.b.depth0  / (tex->desc.depth0  + 0.001f);
d364 3
a366 5
        OUT_CS_REG_SEQ(R300_RB3D_AARESOLVE_OFFSET, 1);
        OUT_CS_RELOC(aa->dest->cs_buffer, aa->dest->offset, 0, aa->dest->domain);

        OUT_CS_REG_SEQ(R300_RB3D_AARESOLVE_PITCH, 1);
        OUT_CS_RELOC(aa->dest->cs_buffer, aa->dest->pitch, 0, aa->dest->domain);
d378 2
a379 1
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
d387 4
a390 4
        OUT_CS_REG(R300_RB3D_CCTL,
            R300_RB3D_CCTL_INDEPENDENT_COLORFORMAT_ENABLE_ENABLE);
    } else {
        OUT_CS_REG(R300_RB3D_CCTL, 0);
d393 2
d399 2
a400 2
        OUT_CS_REG_SEQ(R300_RB3D_COLOROFFSET0 + (4 * i), 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->offset, 0, surf->domain);
d402 2
a403 2
        OUT_CS_REG_SEQ(R300_RB3D_COLORPITCH0 + (4 * i), 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->pitch, 0, surf->domain);
d412 2
a413 2
        OUT_CS_REG_SEQ(R300_ZB_DEPTHOFFSET, 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->cbzb_midpoint_offset, 0, surf->domain);
d415 2
a416 2
        OUT_CS_REG_SEQ(R300_ZB_DEPTHPITCH, 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->cbzb_pitch, 0, surf->domain);
d428 2
a429 2
        OUT_CS_REG_SEQ(R300_ZB_DEPTHOFFSET, 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->offset, 0, surf->domain);
d431 2
a432 2
        OUT_CS_REG_SEQ(R300_ZB_DEPTHPITCH, 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->pitch, 0, surf->domain);
d434 1
a434 7
        if (can_hyperz) {
            uint32_t surf_pitch;
            struct r300_texture *tex;
            int level = surf->base.u.tex.level;
            tex = r300_texture(surf->base.texture);

            surf_pitch = surf->pitch & R300_DEPTHPITCH_MASK;
d436 2
a437 9
            if (r300->screen->caps.hiz_ram) {
                if (tex->hiz_mem[level]) {
                    OUT_CS_REG(R300_ZB_HIZ_OFFSET, tex->hiz_mem[level]->ofs << 2);
                    OUT_CS_REG(R300_ZB_HIZ_PITCH, surf_pitch);
                } else {
                    OUT_CS_REG(R300_ZB_HIZ_OFFSET, 0);
                    OUT_CS_REG(R300_ZB_HIZ_PITCH, 0);
                }
            }
d439 2
a440 7
            if (tex->zmask_mem[level]) {
                OUT_CS_REG(R300_ZB_ZMASK_OFFSET, tex->zmask_mem[level]->ofs << 2);
                OUT_CS_REG(R300_ZB_ZMASK_PITCH, surf_pitch);
            } else {
                OUT_CS_REG(R300_ZB_ZMASK_OFFSET, 0);
                OUT_CS_REG(R300_ZB_ZMASK_PITCH, 0);
            }
a446 4
        unsigned tiling =
            r300->rws->get_value(r300->rws, R300_VID_SQUARE_TILING_SUPPORT) ?
            R300_DEPTHMICROTILE_TILED_SQUARE :
            R300_DEPTHMICROTILE_TILED;
d450 2
a451 2
        OUT_CS_REG_SEQ(R300_ZB_DEPTHOFFSET, 1);
        OUT_CS_RELOC(surf->cs_buffer, 0, 0, surf->domain);
d453 2
a454 2
        OUT_CS_REG_SEQ(R300_ZB_DEPTHPITCH, 1);
        OUT_CS_RELOC(surf->cs_buffer, 4 | tiling, 0, surf->domain);
d465 1
d491 2
a492 1
    unsigned i;
d495 6
d506 1
a506 1
    for (i = 0; i < fb->nr_cbufs; i++) {
d521 24
a544 26
    if (r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0)) {
        unsigned mspos0 = 0x66666666;
        unsigned mspos1 = 0x6666666;

        if (fb->nr_cbufs && fb->cbufs[0]->texture->nr_samples > 1) {
            /* Subsample placement. These may not be optimal. */
            switch (fb->cbufs[0]->texture->nr_samples) {
                case 2:
                    mspos0 = 0x33996633;
                    mspos1 = 0x6666663;
                    break;
                case 3:
                    mspos0 = 0x33936933;
                    mspos1 = 0x6666663;
                    break;
                case 4:
                    mspos0 = 0x33939933;
                    mspos1 = 0x3966663;
                    break;
                case 6:
                    mspos0 = 0x22a2aa22;
                    mspos1 = 0x2a65672;
                    break;
                default:
                    debug_printf("r300: Bad number of multisamples!\n");
            }
d546 1
d548 3
a550 4
        OUT_CS_REG_SEQ(R300_GB_MSPOS0, 2);
        OUT_CS(mspos0);
        OUT_CS(mspos1);
    }
a570 1
    query->flushed = FALSE;
a576 1
    struct r300_winsys_cs_buffer *buf = r300->query_current->cs_buffer;
d594 2
a595 3
            OUT_CS_REG_SEQ(R300_ZB_ZPASS_ADDR, 1);
            OUT_CS_RELOC(buf, (query->num_results + 3) * 4,
                    0, query->domain);
d599 2
a600 3
            OUT_CS_REG_SEQ(R300_ZB_ZPASS_ADDR, 1);
            OUT_CS_RELOC(buf, (query->num_results + 2) * 4,
                    0, query->domain);
d606 2
a607 3
            OUT_CS_REG_SEQ(R300_ZB_ZPASS_ADDR, 1);
            OUT_CS_RELOC(buf, (query->num_results + 1) * 4,
                    0, query->domain);
d611 2
a612 3
            OUT_CS_REG_SEQ(R300_ZB_ZPASS_ADDR, 1);
            OUT_CS_RELOC(buf, (query->num_results + 0) * 4,
                    0, query->domain);
a627 1
    struct r300_winsys_cs_buffer *buf = r300->query_current->cs_buffer;
d632 2
a633 2
    OUT_CS_REG_SEQ(R300_ZB_ZPASS_ADDR, 1);
    OUT_CS_RELOC(buf, query->num_results * 4, 0, query->domain);
a640 1
    struct r300_winsys_cs_buffer *buf = r300->query_current->cs_buffer;
d645 2
a646 2
    OUT_CS_REG_SEQ(R300_ZB_ZPASS_ADDR, 1);
    OUT_CS_RELOC(buf, (query->num_results + 0) * 4, 0, query->domain);
d648 2
a649 2
    OUT_CS_REG_SEQ(R300_ZB_ZPASS_ADDR, 1);
    OUT_CS_RELOC(buf, (query->num_results + 1) * 4, 0, query->domain);
d788 1
a788 1
    struct r300_texture *tex;
d790 1
d799 1
a799 1
            tex = r300_texture(allstate->sampler_views[i]->base.texture);
d810 7
a816 3
            OUT_CS_REG_SEQ(R300_TX_OFFSET_0 + (i * 4), 1);
            OUT_CS_TEX_RELOC(tex, texstate->format.tile_config, tex->domain,
                             0);
d822 2
a823 1
static void r300_update_aos_cb(struct r300_context *r300, unsigned packet_size)
d825 1
a825 1
    struct pipe_vertex_buffer *vb1, *vb2, *vbuf = r300->vertex_buffer;
d827 1
a827 2
    unsigned *hw_format_size = r300->velems->hw_format_size;
    unsigned size1, size2, aos_count = r300->velems->count;
d829 5
a833 35
    CB_LOCALS;

    BEGIN_CB(r300->aos_cb, packet_size);
    for (i = 0; i < aos_count - 1; i += 2) {
        vb1 = &vbuf[velem[i].vertex_buffer_index];
        vb2 = &vbuf[velem[i+1].vertex_buffer_index];
        size1 = hw_format_size[i];
        size2 = hw_format_size[i+1];

        OUT_CB(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride) |
               R300_VBPNTR_SIZE1(size2) | R300_VBPNTR_STRIDE1(vb2->stride));
        OUT_CB(vb1->buffer_offset + velem[i].src_offset);
        OUT_CB(vb2->buffer_offset + velem[i+1].src_offset);
    }

    if (aos_count & 1) {
        vb1 = &vbuf[velem[i].vertex_buffer_index];
        size1 = hw_format_size[i];

        OUT_CB(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride));
        OUT_CB(vb1->buffer_offset + velem[i].src_offset);
    }
    END_CB;

    r300->aos_dirty = FALSE;
}

void r300_emit_aos(struct r300_context* r300, int offset, boolean indexed)
{
    struct pipe_vertex_buffer *vbuf = r300->vertex_buffer;
    struct pipe_vertex_element *velem = r300->velems->velem;
    struct r300_buffer *buf;
    int i;
    unsigned aos_count = r300->velems->count;
    unsigned packet_size = (aos_count * 3 + 1) / 2;
d836 1
a836 1
    BEGIN_CS(2 + packet_size + aos_count * 2);
d838 1
a838 1
    OUT_CS(aos_count | (!indexed ? R300_VC_FORCE_PREFETCH : 0));
d840 3
a842 11
    if (!offset) {
        if (r300->aos_dirty) {
            r300_update_aos_cb(r300, packet_size);
        }
        OUT_CS_TABLE(r300->aos_cb, packet_size);
    } else {
        struct pipe_vertex_buffer *vb1, *vb2;
        unsigned *hw_format_size = r300->velems->hw_format_size;
        unsigned size1, size2;

        for (i = 0; i < aos_count - 1; i += 2) {
d854 1
a854 1
        if (aos_count & 1) {
a860 1
    }
d862 56
a917 3
    for (i = 0; i < aos_count; i++) {
        buf = r300_buffer(vbuf[velem[i].vertex_buffer_index].buffer);
        OUT_CS_BUF_RELOC_NO_OFFSET(&buf->b.b, buf->domain, 0);
d922 1
a922 1
void r300_emit_aos_swtcl(struct r300_context *r300, boolean indexed)
d942 2
a943 1
    OUT_CS_BUF_RELOC(r300->vbo, 0, r300_buffer(r300->vbo)->domain, 0);
a1109 24
static void r300_emit_hiz_line_clear(struct r300_context *r300, int start, uint16_t count, uint32_t val)
{
    CS_LOCALS(r300);
    BEGIN_CS(4);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_HIZ, 2);
    OUT_CS(start);
    OUT_CS(count);
    OUT_CS(val);
    END_CS;
}

static void r300_emit_zmask_line_clear(struct r300_context *r300, int start, uint16_t count, uint32_t val)
{
    CS_LOCALS(r300);
    BEGIN_CS(4);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_ZMASK, 2);
    OUT_CS(start);
    OUT_CS(count);
    OUT_CS(val);
    END_CS;
}

#define ALIGN_DIVUP(x, y) (((x) + (y) - 1) / (y))

d1114 2
a1115 6
    struct r300_hyperz_state *z =
        (struct r300_hyperz_state*)r300->hyperz_state.state;
    struct r300_screen* r300screen = r300->screen;
    uint32_t stride, offset = 0, height, offset_shift;
    struct r300_texture* tex;
    int i;
d1117 1
a1117 1
    tex = r300_texture(fb->zsbuf->texture);
d1119 6
a1124 21
    offset = tex->hiz_mem[fb->zsbuf->u.tex.level]->ofs;
    stride = tex->desc.stride_in_pixels[fb->zsbuf->u.tex.level];

    /* convert from pixels to 4x4 blocks */
    stride = ALIGN_DIVUP(stride, 4);

    stride = ALIGN_DIVUP(stride, r300screen->caps.num_frag_pipes);    
    /* there are 4 blocks per dwords */
    stride = ALIGN_DIVUP(stride, 4);

    height = ALIGN_DIVUP(fb->zsbuf->height, 4);

    offset_shift = 2;
    offset_shift += (r300screen->caps.num_frag_pipes / 2);

    for (i = 0; i < height; i++) {
        offset = i * stride;
        offset <<= offset_shift;
        r300_emit_hiz_line_clear(r300, offset, stride, 0xffffffff);
    }
    z->current_func = -1;
d1127 3
a1129 1
    tex->hiz_in_use[fb->zsbuf->u.tex.level] = TRUE;
d1136 2
a1137 5
    struct r300_screen* r300screen = r300->screen;
    uint32_t stride, offset = 0;
    struct r300_texture* tex;
    uint32_t i, height;
    int mult, offset_shift;
d1139 1
a1139 2
    tex = r300_texture(fb->zsbuf->texture);
    stride = tex->desc.stride_in_pixels[fb->zsbuf->u.tex.level];
d1141 6
a1146 24
    offset = tex->zmask_mem[fb->zsbuf->u.tex.level]->ofs;

    if (r300->z_compression == RV350_Z_COMPRESS_88)
        mult = 8;
    else
        mult = 4;

    height = ALIGN_DIVUP(fb->zsbuf->height, mult);

    offset_shift = 4;
    offset_shift += (r300screen->caps.num_frag_pipes / 2);
    stride = ALIGN_DIVUP(stride, r300screen->caps.num_frag_pipes);

    /* okay have width in pixels - divide by block width */
    stride = ALIGN_DIVUP(stride, mult);
    /* have width in blocks - divide by number of fragment pipes screen width */
    /* 16 blocks per dword */
    stride = ALIGN_DIVUP(stride, 16);

    for (i = 0; i < height; i++) {
        offset = i * stride;
        offset <<= offset_shift;
        r300_emit_zmask_line_clear(r300, offset, stride, 0x0);//0xffffffff);
    }
d1149 2
a1150 1
    tex->zmask_in_use[fb->zsbuf->u.tex.level] = TRUE;
d1177 1
a1177 1
    struct pipe_framebuffer_state* fb =
d1181 1
a1181 4
    struct r300_texture* tex;
    struct pipe_vertex_buffer *vbuf = r300->vertex_buffer;
    struct pipe_vertex_element *velem = r300->velems->velem;
    struct pipe_resource *pbuf;
d1183 1
d1185 23
a1207 2
    /* Clean out BOs. */
    r300->rws->cs_reset_buffers(r300->cs);
d1209 2
a1210 18
    /* Color buffers... */
    for (i = 0; i < fb->nr_cbufs; i++) {
        tex = r300_texture(fb->cbufs[i]->texture);
        assert(tex && tex->buffer && "cbuf is marked, but NULL!");
        r300->rws->cs_add_buffer(r300->cs, tex->cs_buffer, 0,
                                 r300_surface(fb->cbufs[i])->domain);
    }
    /* ...depth buffer... */
    if (fb->zsbuf) {
        tex = r300_texture(fb->zsbuf->texture);
        assert(tex && tex->buffer && "zsbuf is marked, but NULL!");
        r300->rws->cs_add_buffer(r300->cs, tex->cs_buffer, 0,
                                 r300_surface(fb->zsbuf)->domain);
    }
    /* ...textures... */
    for (i = 0; i < texstate->count; i++) {
        if (!(texstate->tx_enable & (1 << i))) {
            continue;
a1211 3

        tex = r300_texture(texstate->sampler_views[i]->base.texture);
        r300->rws->cs_add_buffer(r300->cs, tex->cs_buffer, tex->domain, 0);
d1215 2
a1216 2
        r300->rws->cs_add_buffer(r300->cs, r300->query_current->cs_buffer,
                                 0, r300->query_current->domain);
d1219 2
a1220 2
        r300->rws->cs_add_buffer(r300->cs, r300_buffer(r300->vbo)->cs_buf,
                                 r300_buffer(r300->vbo)->domain, 0);
d1222 8
a1229 4
    if (do_validate_vertex_buffers) {
        for (i = 0; i < r300->velems->count; i++) {
            pbuf = vbuf[velem[i].vertex_buffer_index].buffer;
            if (!pbuf)
d1232 2
a1233 2
            r300->rws->cs_add_buffer(r300->cs, r300_buffer(pbuf)->cs_buf,
                                     r300_buffer(pbuf)->domain, 0);
d1238 2
a1239 2
        r300->rws->cs_add_buffer(r300->cs, r300_buffer(index_buffer)->cs_buf,
                                 r300_buffer(index_buffer)->domain, 0);
d1241 1
d1243 6
a1248 1
        return FALSE;
d1278 1
a1278 1
    if (r300->screen->caps.index_bias_supported)
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d28 1
d32 1
d37 1
a47 3
    BEGIN_CS(size);
    OUT_CS_REG(R300_RB3D_ROPCNTL, blend->rop);
    OUT_CS_REG_SEQ(R300_RB3D_CBLEND, 3);
d49 1
a49 3
        OUT_CS(blend->blend_control);
        OUT_CS(blend->alpha_blend_control);
        OUT_CS(blend->color_channel_mask);
d51 1
a51 4
        OUT_CS(0);
        OUT_CS(0);
        OUT_CS(0);
        /* XXX also disable fastfill here once it's supported */
a52 2
    OUT_CS_REG(R300_RB3D_DITHER_CTL, blend->dither);
    END_CS;
a58 1
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
d61 1
a61 11
    if (r300screen->caps->is_r500) {
        BEGIN_CS(size);
        OUT_CS_REG_SEQ(R500_RB3D_CONSTANT_COLOR_AR, 2);
        OUT_CS(bc->blend_color_red_alpha);
        OUT_CS(bc->blend_color_green_blue);
        END_CS;
    } else {
        BEGIN_CS(size);
        OUT_CS_REG(R300_RB3D_BLEND_COLOR, bc->blend_color);
        END_CS;
    }
d67 1
a67 3
    struct pipe_clip_state* clip = (struct pipe_clip_state*)state;
    int i;
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
d70 1
a70 21
    if (r300screen->caps->has_tcl) {
        BEGIN_CS(size);
        OUT_CS_REG(R300_VAP_PVS_VECTOR_INDX_REG,
                (r300screen->caps->is_r500 ?
                 R500_PVS_UCP_START : R300_PVS_UCP_START));
        OUT_CS_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, 6 * 4);
        for (i = 0; i < 6; i++) {
            OUT_CS_32F(clip->ucp[i][0]);
            OUT_CS_32F(clip->ucp[i][1]);
            OUT_CS_32F(clip->ucp[i][2]);
            OUT_CS_32F(clip->ucp[i][3]);
        }
        OUT_CS_REG(R300_VAP_CLIP_CNTL, ((1 << clip->nr) - 1) |
                R300_PS_UCP_MODE_CLIP_AS_TRIFAN);
        END_CS;
    } else {
        BEGIN_CS(size);
        OUT_CS_REG(R300_VAP_CLIP_CNTL, R300_CLIP_DISABLE);
        END_CS;
    }

a75 1
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
a77 1
    struct pipe_stencil_ref stencil_ref = r300->stencil_ref;
a79 4
    BEGIN_CS(size);
    OUT_CS_REG(R300_FG_ALPHA_FUNC, dsa->alpha_function);
    OUT_CS_REG_SEQ(R300_ZB_CNTL, 3);

d81 1
a81 2
        OUT_CS(dsa->z_buffer_control);
        OUT_CS(dsa->z_stencil_control);
d83 1
a83 2
        OUT_CS(0);
        OUT_CS(0);
a84 7

    OUT_CS(dsa->stencil_ref_mask | stencil_ref.ref_value[0]);

    if (r300screen->caps->is_r500) {
        OUT_CS_REG(R500_ZB_STENCILREFMASK_BF, dsa->stencil_ref_bf | stencil_ref.ref_value[1]);
    }
    END_CS;
d87 2
a88 1
static const float * get_shader_constant(
d90 1
a90 2
    struct rc_constant * constant,
    struct r300_constant_buffer * externals)
d92 4
a95 6
    struct r300_viewport_state* viewport =
        (struct r300_viewport_state*)r300->viewport_state.state;
    struct r300_textures_state* texstate =
        (struct r300_textures_state*)r300->textures_state.state;
    static float vec[4] = { 0.0, 0.0, 0.0, 1.0 };
    struct pipe_texture *tex;
d97 3
a99 16
    switch(constant->Type) {
        case RC_CONSTANT_EXTERNAL:
            return externals->constants[constant->u.External];

        case RC_CONSTANT_IMMEDIATE:
            return constant->u.Immediate;

        case RC_CONSTANT_STATE:
            switch (constant->u.State[0]) {
                /* Factor for converting rectangle coords to
                 * normalized coords. Should only show up on non-r500. */
                case RC_STATE_R300_TEXRECT_FACTOR:
                    tex = &texstate->textures[constant->u.State[1]]->tex;
                    vec[0] = 1.0 / tex->width0;
                    vec[1] = 1.0 / tex->height0;
                    break;
d101 10
a110 5
                /* Texture compare-fail value. Shouldn't ever show up, but if
                 * it does, we'll be ready. */
                case RC_STATE_SHADOW_AMBIENT:
                    vec[3] = 0;
                    break;
d112 8
a119 5
                case RC_STATE_R300_VIEWPORT_SCALE:
                    vec[0] = viewport->xscale;
                    vec[1] = viewport->yscale;
                    vec[2] = viewport->zscale;
                    break;
d121 6
a126 5
                case RC_STATE_R300_VIEWPORT_OFFSET:
                    vec[0] = viewport->xoffset;
                    vec[1] = viewport->yoffset;
                    vec[2] = viewport->zoffset;
                    break;
d128 5
a132 4
                default:
                    debug_printf("r300: Implementation error: "
                        "Unknown RC_CONSTANT type %d\n", constant->u.State[0]);
            }
d136 6
a141 2
            debug_printf("r300: Implementation error: "
                "Unhandled constant type %d\n", constant->Type);
a142 5

    /* This should either be (0, 0, 0, 1), which should be a relatively safe
     * RGBA or STRQ value, or it could be one of the RC_CONSTANT_STATE
     * state factors. */
    return vec;
d148 1
a148 1
static uint32_t pack_float24(float f)
d179 1
a179 2
void r300_emit_fragment_program_code(struct r300_context* r300,
                                     struct rX00_fragment_program_code* generic_code)
d181 1
a181 2
    struct r300_fragment_program_code * code = &generic_code->code.r300;
    int i;
d184 2
a185 3
    BEGIN_CS(15 +
             code->alu.length * 4 +
             (code->tex.length ? (1 + code->tex.length) : 0));
d187 7
a193 3
    OUT_CS_REG(R300_US_CONFIG, code->config);
    OUT_CS_REG(R300_US_PIXSIZE, code->pixsize);
    OUT_CS_REG(R300_US_CODE_OFFSET, code->code_offset);
d195 2
a196 3
    OUT_CS_REG_SEQ(R300_US_CODE_ADDR_0, 4);
    for(i = 0; i < 4; ++i)
        OUT_CS(code->code_addr[i]);
d198 13
a210 3
    OUT_CS_REG_SEQ(R300_US_ALU_RGB_INST_0, code->alu.length);
    for (i = 0; i < code->alu.length; i++)
        OUT_CS(code->alu.inst[i].rgb_inst);
d212 2
a213 3
    OUT_CS_REG_SEQ(R300_US_ALU_RGB_ADDR_0, code->alu.length);
    for (i = 0; i < code->alu.length; i++)
        OUT_CS(code->alu.inst[i].rgb_addr);
d215 10
a224 3
    OUT_CS_REG_SEQ(R300_US_ALU_ALPHA_INST_0, code->alu.length);
    for (i = 0; i < code->alu.length; i++)
        OUT_CS(code->alu.inst[i].alpha_inst);
d226 2
a227 3
    OUT_CS_REG_SEQ(R300_US_ALU_ALPHA_ADDR_0, code->alu.length);
    for (i = 0; i < code->alu.length; i++)
        OUT_CS(code->alu.inst[i].alpha_addr);
d229 11
a239 4
    if (code->tex.length) {
        OUT_CS_REG_SEQ(R300_US_TEX_INST_0, code->tex.length);
        for(i = 0; i < code->tex.length; ++i)
            OUT_CS(code->tex.inst[i]);
d241 7
d249 1
a249 1
    END_CS;
d252 1
a252 2
void r300_emit_fs_constant_buffer(struct r300_context* r300,
                                  struct rc_constant_list* constants)
d254 3
a256 1
    int i;
d259 1
a259 1
    if (constants->Count == 0)
d262 10
a271 10
    BEGIN_CS(constants->Count * 4 + 1);
    OUT_CS_REG_SEQ(R300_PFS_PARAM_0_X, constants->Count * 4);
    for(i = 0; i < constants->Count; ++i) {
        const float * data = get_shader_constant(r300,
                                                 &constants->Constants[i],
                                                 &r300->shader_constants[PIPE_SHADER_FRAGMENT]);
        OUT_CS(pack_float24(data[0]));
        OUT_CS(pack_float24(data[1]));
        OUT_CS(pack_float24(data[2]));
        OUT_CS(pack_float24(data[3]));
d276 1
a276 2
static void r300_emit_fragment_depth_config(struct r300_context* r300,
                                            struct r300_fragment_shader* fs)
d278 6
d286 16
a301 7
    BEGIN_CS(4);
    if (r300_fragment_shader_writes_depth(fs)) {
        OUT_CS_REG(R300_FG_DEPTH_SRC, R300_FG_DEPTH_SRC_SHADER);
        OUT_CS_REG(R300_US_W_FMT, R300_W_FMT_W24 | R300_W_SRC_US);
    } else {
        OUT_CS_REG(R300_FG_DEPTH_SRC, R300_FG_DEPTH_SRC_SCAN);
        OUT_CS_REG(R300_US_W_FMT, R300_W_FMT_W0 | R300_W_SRC_US);
d306 1
a306 2
void r500_emit_fragment_program_code(struct r300_context* r300,
                                     struct rX00_fragment_program_code* generic_code)
d308 5
a312 2
    struct r500_fragment_program_code * code = &generic_code->code.r500;
    int i;
d315 5
a319 19
    BEGIN_CS(13 +
             ((code->inst_end + 1) * 6));
    OUT_CS_REG(R500_US_CONFIG, R500_ZERO_TIMES_ANYTHING_EQUALS_ZERO);
    OUT_CS_REG(R500_US_PIXSIZE, code->max_temp_idx);
    OUT_CS_REG(R500_US_CODE_RANGE,
               R500_US_CODE_RANGE_ADDR(0) | R500_US_CODE_RANGE_SIZE(code->inst_end));
    OUT_CS_REG(R500_US_CODE_OFFSET, 0);
    OUT_CS_REG(R500_US_CODE_ADDR,
               R500_US_CODE_START_ADDR(0) | R500_US_CODE_END_ADDR(code->inst_end));

    OUT_CS_REG(R500_GA_US_VECTOR_INDEX, R500_GA_US_VECTOR_INDEX_TYPE_INSTR);
    OUT_CS_ONE_REG(R500_GA_US_VECTOR_DATA, (code->inst_end + 1) * 6);
    for (i = 0; i <= code->inst_end; i++) {
        OUT_CS(code->inst[i].inst0);
        OUT_CS(code->inst[i].inst1);
        OUT_CS(code->inst[i].inst2);
        OUT_CS(code->inst[i].inst3);
        OUT_CS(code->inst[i].inst4);
        OUT_CS(code->inst[i].inst5);
d322 22
d347 1
a347 2
void r500_emit_fs_constant_buffer(struct r300_context* r300,
                                  struct rc_constant_list* constants)
d349 1
a349 1
    int i;
d352 6
a357 2
    if (constants->Count == 0)
        return;
d359 2
a360 11
    BEGIN_CS(constants->Count * 4 + 3);
    OUT_CS_REG(R500_GA_US_VECTOR_INDEX, R500_GA_US_VECTOR_INDEX_TYPE_CONST);
    OUT_CS_ONE_REG(R500_GA_US_VECTOR_DATA, constants->Count * 4);
    for (i = 0; i < constants->Count; i++) {
        const float * data = get_shader_constant(r300,
                                                 &constants->Constants[i],
                                                 &r300->shader_constants[PIPE_SHADER_FRAGMENT]);
        OUT_CS_32F(data[0]);
        OUT_CS_32F(data[1]);
        OUT_CS_32F(data[2]);
        OUT_CS_32F(data[3]);
d362 2
d370 3
a372 4
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
    struct r300_texture* tex;
    struct pipe_surface* surf;
    int i;
d377 5
a381 18
    /* Flush and free renderbuffer caches. */
    OUT_CS_REG(R300_RB3D_DSTCACHE_CTLSTAT,
        R300_RB3D_DSTCACHE_CTLSTAT_DC_FREE_FREE_3D_TAGS |
        R300_RB3D_DSTCACHE_CTLSTAT_DC_FLUSH_FLUSH_DIRTY_3D);
    OUT_CS_REG(R300_ZB_ZCACHE_CTLSTAT,
        R300_ZB_ZCACHE_CTLSTAT_ZC_FLUSH_FLUSH_AND_FREE |
        R300_ZB_ZCACHE_CTLSTAT_ZC_FREE_FREE);

    /* Set the number of colorbuffers. */
    if (fb->nr_cbufs > 1) {
        if (r300screen->caps->is_r500) {
            OUT_CS_REG(R300_RB3D_CCTL,
                R300_RB3D_CCTL_NUM_MULTIWRITES(fb->nr_cbufs) |
                R300_RB3D_CCTL_INDEPENDENT_COLORFORMAT_ENABLE_ENABLE);
        } else {
            OUT_CS_REG(R300_RB3D_CCTL,
                R300_RB3D_CCTL_NUM_MULTIWRITES(fb->nr_cbufs));
        }
d383 1
a383 1
        OUT_CS_REG(R300_RB3D_CCTL, 0x0);
d388 1
a388 3
        surf = fb->cbufs[i];
        tex = (struct r300_texture*)surf->texture;
        assert(tex && tex->buffer && "cbuf is marked, but NULL!");
d391 1
a391 1
        OUT_CS_RELOC(tex->buffer, surf->offset, 0, RADEON_GEM_DOMAIN_VRAM, 0);
d394 2
a395 2
        OUT_CS_RELOC(tex->buffer, tex->fb_state.colorpitch[surf->level],
                     0, RADEON_GEM_DOMAIN_VRAM, 0);
d397 15
a411 4
        OUT_CS_REG(R300_US_OUT_FMT_0 + (4 * i), tex->fb_state.us_out_fmt);
    }
    for (; i < 4; i++) {
        OUT_CS_REG(R300_US_OUT_FMT_0 + (4 * i), R300_US_OUT_FMT_UNUSED);
d413 3
d417 1
a417 5
    /* Set up a zbuffer. */
    if (fb->zsbuf) {
        surf = fb->zsbuf;
        tex = (struct r300_texture*)surf->texture;
        assert(tex && tex->buffer && "zsbuf is marked, but NULL!");
d420 4
a423 1
        OUT_CS_RELOC(tex->buffer, surf->offset, 0, RADEON_GEM_DOMAIN_VRAM, 0);
d425 40
a464 1
        OUT_CS_REG(R300_ZB_FORMAT, tex->fb_state.zb_format);
d467 1
a467 2
        OUT_CS_RELOC(tex->buffer, tex->fb_state.depthpitch[surf->level],
                     0, RADEON_GEM_DOMAIN_VRAM, 0);
a469 2
    OUT_CS_REG(R300_GA_POINT_MINMAX,
        (MAX2(fb->width, fb->height) * 6) << R300_GA_POINT_MINMAX_MAX_SHIFT);
d473 89
a561 1
static void r300_emit_query_start(struct r300_context *r300)
a562 1
    struct r300_capabilities *caps = r300_screen(r300->context.screen)->caps;
d569 2
a570 2
    BEGIN_CS(4);
    if (caps->family == CHIP_FAMILY_RV530) {
d578 1
d581 2
a582 3

static void r300_emit_query_finish(struct r300_context *r300,
                                   struct r300_query *query)
d584 2
a585 1
    struct r300_capabilities* caps = r300_screen(r300->context.screen)->caps;
d604 2
a605 2
            OUT_CS_RELOC(r300->oqbo, query->offset + (sizeof(uint32_t) * 3),
                    0, RADEON_GEM_DOMAIN_GTT, 0);
d610 2
a611 2
            OUT_CS_RELOC(r300->oqbo, query->offset + (sizeof(uint32_t) * 2),
                    0, RADEON_GEM_DOMAIN_GTT, 0);
d618 2
a619 2
            OUT_CS_RELOC(r300->oqbo, query->offset + (sizeof(uint32_t) * 1),
                    0, RADEON_GEM_DOMAIN_GTT, 0);
d624 2
a625 2
            OUT_CS_RELOC(r300->oqbo, query->offset + (sizeof(uint32_t) * 0),
                    0, RADEON_GEM_DOMAIN_GTT, 0);
d628 1
a628 1
            debug_printf("r300: Implementation error: Chipset reports %d"
d630 1
a630 1
            assert(0);
d638 2
a639 2
static void rv530_emit_query_single(struct r300_context *r300,
                                    struct r300_query *query)
d641 1
d647 1
a647 1
    OUT_CS_RELOC(r300->oqbo, query->offset, 0, RADEON_GEM_DOMAIN_GTT, 0);
d652 2
a653 2
static void rv530_emit_query_double(struct r300_context *r300,
                                    struct r300_query *query)
d655 1
d661 1
a661 1
    OUT_CS_RELOC(r300->oqbo, query->offset, 0, RADEON_GEM_DOMAIN_GTT, 0);
d664 1
a664 1
    OUT_CS_RELOC(r300->oqbo, query->offset + sizeof(uint32_t), 0, RADEON_GEM_DOMAIN_GTT, 0);
d671 1
a671 1
    struct r300_capabilities *caps = r300_screen(r300->context.screen)->caps;
d682 1
a682 1
            rv530_emit_query_double(r300, query);
d684 1
a684 1
            rv530_emit_query_single(r300, query);
d686 17
a702 1
        r300_emit_query_finish(r300, query);
d707 1
a707 2
    struct r300_rs_state* rs = (struct r300_rs_state*)state;
    float scale, offset;
d711 1
a711 7
    OUT_CS_REG(R300_VAP_CNTL_STATUS, rs->vap_control_status);

    OUT_CS_REG(R300_GB_AA_CONFIG, rs->antialiasing_config);

    OUT_CS_REG(R300_GA_POINT_SIZE, rs->point_size);
    OUT_CS_REG(R300_GA_LINE_CNTL, rs->line_control);

d713 4
a716 10
        scale = rs->depth_scale * 12;
        offset = rs->depth_offset;

        switch (r300->zbuffer_bpp) {
            case 16:
                offset *= 4;
                break;
            case 24:
                offset *= 2;
                break;
a717 6

        OUT_CS_REG_SEQ(R300_SU_POLY_OFFSET_FRONT_SCALE, 4);
        OUT_CS_32F(scale);
        OUT_CS_32F(offset);
        OUT_CS_32F(scale);
        OUT_CS_32F(offset);
a718 7

    OUT_CS_REG_SEQ(R300_SU_POLY_OFFSET_ENABLE, 2);
    OUT_CS(rs->polygon_offset_enable);
    OUT_CS(rs->cull_mode);
    OUT_CS_REG(R300_GA_LINE_STIPPLE_CONFIG, rs->line_stipple_config);
    OUT_CS_REG(R300_GA_LINE_STIPPLE_VALUE, rs->line_stipple_value);
    OUT_CS_REG(R300_GA_POLY_MODE, rs->polygon_mode);
a726 1
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
d731 14
a744 1
    DBG(r300, DBG_DRAW, "r300: RS emit:\n");
d747 10
a756 1
    if (r300screen->caps->is_r500) {
d761 1
a761 4
    for (i = 0; i < count; i++) {
        OUT_CS(rs->ip[i]);
        DBG(r300, DBG_DRAW, "    : ip %d: 0x%08x\n", i, rs->ip[i]);
    }
d767 1
a767 1
    if (r300screen->caps->is_r500) {
d772 1
a772 8
    for (i = 0; i < count; i++) {
        OUT_CS(rs->inst[i]);
        DBG(r300, DBG_DRAW, "    : inst %d: 0x%08x\n", i, rs->inst[i]);
    }

    DBG(r300, DBG_DRAW, "    : count: 0x%08x inst_count: 0x%08x\n",
        rs->count, rs->inst_count);

a778 3
    unsigned minx, miny, maxx, maxy;
    uint32_t top_left, bottom_right;
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
a779 2
    struct pipe_framebuffer_state* fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
d782 7
a788 34
    minx = miny = 0;
    maxx = fb->width;
    maxy = fb->height;

    if (((struct r300_rs_state*)r300->rs_state.state)->rs.scissor) {
        minx = MAX2(minx, scissor->minx);
        miny = MAX2(miny, scissor->miny);
        maxx = MIN2(maxx, scissor->maxx);
        maxy = MIN2(maxy, scissor->maxy);
    }

    /* Special case for zero-area scissor.
     *
     * We can't allow the variables maxx and maxy to be zero because they are
     * subtracted from later in the code, which would cause emitting ~0 and
     * making the kernel checker angry.
     *
     * Let's consider we change maxx and maxy to 1, which is effectively
     * a one-pixel area. We must then change minx and miny to a number which is
     * greater than 1 to get the zero area back. */
    if (!maxx || !maxy) {
        minx = 2;
        miny = 2;
        maxx = 1;
        maxy = 1;
    }

    if (r300screen->caps->is_r500) {
        top_left =
            (minx << R300_SCISSORS_X_SHIFT) |
            (miny << R300_SCISSORS_Y_SHIFT);
        bottom_right =
            ((maxx - 1) << R300_SCISSORS_X_SHIFT) |
            ((maxy - 1) << R300_SCISSORS_Y_SHIFT);
d790 4
a793 7
        /* Offset of 1440 in non-R500 chipsets. */
        top_left =
            ((minx + 1440) << R300_SCISSORS_X_SHIFT) |
            ((miny + 1440) << R300_SCISSORS_Y_SHIFT);
        bottom_right =
            (((maxx - 1) + 1440) << R300_SCISSORS_X_SHIFT) |
            (((maxy - 1) + 1440) << R300_SCISSORS_Y_SHIFT);
a794 5

    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_SC_SCISSORS_TL, 2);
    OUT_CS(top_left);
    OUT_CS(bottom_right);
d803 1
d813 1
d815 2
a816 2
            OUT_CS_REG(R300_TX_FILTER0_0 + (i * 4), texstate->filter[0]);
            OUT_CS_REG(R300_TX_FILTER1_0 + (i * 4), texstate->filter[1]);
d820 3
a822 3
            OUT_CS_REG(R300_TX_FORMAT0_0 + (i * 4), texstate->format[0]);
            OUT_CS_REG(R300_TX_FORMAT1_0 + (i * 4), texstate->format[1]);
            OUT_CS_REG(R300_TX_FORMAT2_0 + (i * 4), texstate->format[2]);
d825 2
a826 2
            OUT_CS_RELOC(allstate->textures[i]->buffer, texstate->tile_config,
                         RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0, 0);
d832 1
a832 1
void r300_emit_aos(struct r300_context* r300, unsigned offset)
d835 3
a837 1
    struct pipe_vertex_element *velem = r300->vertex_element;
d839 1
a839 7
    unsigned size1, size2, aos_count = r300->vertex_element_count;
    unsigned packet_size = (aos_count * 3 + 1) / 2;
    CS_LOCALS(r300);

    BEGIN_CS(2 + packet_size + aos_count * 2);
    OUT_CS_PKT3(R300_PACKET3_3D_LOAD_VBPNTR, packet_size);
    OUT_CS(aos_count);
d841 1
d845 2
a846 2
        size1 = util_format_get_blocksize(velem[i].src_format);
        size2 = util_format_get_blocksize(velem[i+1].src_format);
d848 1
a848 1
        OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride) |
d850 2
a851 2
        OUT_CS(vb1->buffer_offset + velem[i].src_offset   + offset * vb1->stride);
        OUT_CS(vb2->buffer_offset + velem[i+1].src_offset + offset * vb2->stride);
d856 1
a856 1
        size1 = util_format_get_blocksize(velem[i].src_format);
d858 51
a908 2
        OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride));
        OUT_CS(vb1->buffer_offset + velem[i].src_offset + offset * vb1->stride);
d912 2
a913 2
        OUT_CS_RELOC_NO_OFFSET(vbuf[velem[i].vertex_buffer_index].buffer,
                               RADEON_GEM_DOMAIN_GTT, 0, 0);
d918 24
d950 13
a962 1
    DBG(r300, DBG_DRAW, "r300: PSC emit:\n");
d966 1
a966 5
    for (i = 0; i < streams->count; i++) {
        OUT_CS(streams->vap_prog_stream_cntl[i]);
        DBG(r300, DBG_DRAW, "    : prog_stream_cntl%d: 0x%08x\n", i,
               streams->vap_prog_stream_cntl[i]);
    }
d968 1
a968 5
    for (i = 0; i < streams->count; i++) {
        OUT_CS(streams->vap_prog_stream_cntl_ext[i]);
        DBG(r300, DBG_DRAW, "    : prog_stream_cntl_ext%d: 0x%08x\n", i,
               streams->vap_prog_stream_cntl_ext[i]);
    }
d972 1
a972 2
void r300_emit_vap_output_state(struct r300_context* r300,
                               unsigned size, void* state)
a973 2
    struct r300_vap_output_state *vap_out_state =
        (struct r300_vap_output_state*)state;
a975 2
    DBG(r300, DBG_DRAW, "r300: VAP emit:\n");

d977 1
a977 6
    OUT_CS_REG_SEQ(R300_VAP_VTX_STATE_CNTL, 2);
    OUT_CS(vap_out_state->vap_vtx_state_cntl);
    OUT_CS(vap_out_state->vap_vsm_vtx_assm);
    OUT_CS_REG_SEQ(R300_VAP_OUTPUT_VTX_FMT_0, 2);
    OUT_CS(vap_out_state->vap_out_vtx_fmt[0]);
    OUT_CS(vap_out_state->vap_out_vtx_fmt[1]);
d981 2
a982 1
void r300_emit_pvs_flush(struct r300_context* r300, unsigned size, void* state)
d985 1
a985 4

    BEGIN_CS(size);
    OUT_CS_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0x0);
    END_CS;
d992 1
a992 1
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
a993 1
    unsigned i;
d995 1
a995 1
    unsigned vtx_mem_size = r300screen->caps->is_r500 ? 128 : 72;
d1002 1
a1002 1
    unsigned pvs_num_controllers = MIN2(vtx_mem_size / temp_count, 6);
d1006 1
a1006 5
    if (!r300screen->caps->has_tcl) {
        debug_printf("r300: Implementation error: emit_vertex_shader called,"
                " but has_tcl is FALSE!\n");
        return;
    }
a1007 1
    BEGIN_CS(size);
d1012 4
a1015 6
    OUT_CS_REG_SEQ(R300_VAP_PVS_CODE_CNTL_0, 3);
    OUT_CS(R300_PVS_FIRST_INST(0) |
            R300_PVS_XYZW_VALID_INST(instruction_count - 1) |
            R300_PVS_LAST_INST(instruction_count - 1));
    OUT_CS(R300_PVS_MAX_CONST_ADDR(code->constants.Count - 1));
    OUT_CS(instruction_count - 1);
d1019 1
a1019 3
    for (i = 0; i < code->length; i++) {
        OUT_CS(code->body.d[i]);
    }
d1023 1
a1023 1
            R300_PVS_NUM_FPUS(r300screen->caps->num_vert_fpus) |
d1025 17
a1041 1
            (r300screen->caps->is_r500 ? R500_TCL_STATE_OPTIMIZATION : 0));
d1045 2
a1046 2
void r300_emit_vs_constant_buffer(struct r300_context* r300,
                                  struct rc_constant_list* constants)
d1048 8
a1055 2
    int i;
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
d1058 17
a1074 4
    if (!r300screen->caps->has_tcl) {
        debug_printf("r300: Implementation error: emit_vertex_shader called,"
        " but has_tcl is FALSE!\n");
        return;
d1077 11
a1087 16
    if (constants->Count == 0)
        return;

    BEGIN_CS(constants->Count * 4 + 3);
    OUT_CS_REG(R300_VAP_PVS_VECTOR_INDX_REG,
               (r300screen->caps->is_r500 ?
               R500_PVS_CONST_START : R300_PVS_CONST_START));
    OUT_CS_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, constants->Count * 4);
    for (i = 0; i < constants->Count; i++) {
        const float * data = get_shader_constant(r300,
                                                 &constants->Constants[i],
                                                 &r300->shader_constants[PIPE_SHADER_VERTEX]);
        OUT_CS_32F(data[0]);
        OUT_CS_32F(data[1]);
        OUT_CS_32F(data[2]);
        OUT_CS_32F(data[3]);
d1098 110
a1207 10
     BEGIN_CS(size);
     OUT_CS_REG_SEQ(R300_SE_VPORT_XSCALE, 6);
     OUT_CS_32F(viewport->xscale);
     OUT_CS_32F(viewport->xoffset);
     OUT_CS_32F(viewport->yscale);
     OUT_CS_32F(viewport->yoffset);
     OUT_CS_32F(viewport->zscale);
     OUT_CS_32F(viewport->zoffset);
     OUT_CS_REG(R300_VAP_VTE_CNTL, viewport->vte_control);
     END_CS;
d1230 3
a1232 3
void r300_emit_buffer_validate(struct r300_context *r300,
                               boolean do_validate_vertex_buffers,
                               struct pipe_buffer *index_buffer)
d1240 2
a1241 2
    struct pipe_vertex_element *velem = r300->vertex_element;
    struct pipe_buffer *pbuf;
a1242 1
    boolean invalid = FALSE;
d1245 1
a1245 1
    r300->winsys->reset_bos(r300->winsys);
a1246 1
validate:
d1249 1
a1249 1
        tex = (struct r300_texture*)fb->cbufs[i]->texture;
d1251 2
a1252 5
        if (!r300->winsys->add_buffer(r300->winsys, tex->buffer,
                    0, RADEON_GEM_DOMAIN_VRAM)) {
            r300->context.flush(&r300->context, 0, NULL);
            goto validate;
        }
d1256 1
a1256 1
        tex = (struct r300_texture*)fb->zsbuf->texture;
d1258 2
a1259 5
        if (!r300->winsys->add_buffer(r300->winsys, tex->buffer,
                    0, RADEON_GEM_DOMAIN_VRAM)) {
            r300->context.flush(&r300->context, 0, NULL);
            goto validate;
        }
d1263 1
a1263 2
        tex = texstate->textures[i];
        if (!tex || !texstate->sampler_states[i])
a1264 4
        if (!r300->winsys->add_buffer(r300->winsys, tex->buffer,
                    RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0)) {
            r300->context.flush(&r300->context, 0, NULL);
            goto validate;
d1266 3
d1271 3
a1273 7
    if (r300->dirty_state & R300_NEW_QUERY) {
        if (!r300->winsys->add_buffer(r300->winsys, r300->oqbo,
                    0, RADEON_GEM_DOMAIN_GTT)) {
            r300->context.flush(&r300->context, 0, NULL);
            goto validate;
        }
    }
d1275 3
a1277 7
    if (r300->vbo) {
        if (!r300->winsys->add_buffer(r300->winsys, r300->vbo,
                    RADEON_GEM_DOMAIN_GTT, 0)) {
            r300->context.flush(&r300->context, 0, NULL);
            goto validate;
        }
    }
d1280 1
a1280 1
        for (i = 0; i < r300->vertex_element_count; i++) {
d1282 2
d1285 2
a1286 5
            if (!r300->winsys->add_buffer(r300->winsys, pbuf,
                                          RADEON_GEM_DOMAIN_GTT, 0)) {
                r300->context.flush(&r300->context, 0, NULL);
                goto validate;
            }
d1290 6
a1295 6
    if (index_buffer) {
        if (!r300->winsys->add_buffer(r300->winsys, index_buffer,
                                      RADEON_GEM_DOMAIN_GTT, 0)) {
            r300->context.flush(&r300->context, 0, NULL);
            goto validate;
        }
d1298 1
a1298 10
    if (!r300->winsys->validate(r300->winsys)) {
        r300->context.flush(&r300->context, 0, NULL);
        if (invalid) {
            /* Well, hell. */
            debug_printf("r300: Stuck in validation loop, gonna quit now.");
            exit(1);
        }
        invalid = TRUE;
        goto validate;
    }
d1306 2
a1307 2
    foreach(atom, &r300->atom_list) {
        if (atom->dirty || atom->always_dirty) {
d1312 15
a1326 2
    /* XXX This is the compensation for the non-atomized states. */
    dwords += 1024;
d1334 1
a1334 7
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
    struct r300_atom* atom;

    if (r300->dirty_state & R300_NEW_QUERY) {
        r300_emit_query_start(r300);
        r300->dirty_state &= ~R300_NEW_QUERY;
    }
d1336 2
a1337 2
    foreach(atom, &r300->atom_list) {
        if (atom->dirty || atom->always_dirty) {
d1343 2
a1344 34
    if (r300->dirty_state & R300_NEW_FRAGMENT_SHADER) {
        r300_emit_fragment_depth_config(r300, r300->fs);
        if (r300screen->caps->is_r500) {
            r500_emit_fragment_program_code(r300, &r300->fs->shader->code);
        } else {
            r300_emit_fragment_program_code(r300, &r300->fs->shader->code);
        }
        r300->dirty_state &= ~R300_NEW_FRAGMENT_SHADER;
    }

    if (r300->dirty_state & R300_NEW_FRAGMENT_SHADER_CONSTANTS) {
        if (r300screen->caps->is_r500) {
            r500_emit_fs_constant_buffer(r300,
                                         &r300->fs->shader->code.constants);
        } else {
            r300_emit_fs_constant_buffer(r300,
                                         &r300->fs->shader->code.constants);
        }
        r300->dirty_state &= ~R300_NEW_FRAGMENT_SHADER_CONSTANTS;
    }

    if (r300->dirty_state & R300_NEW_VERTEX_SHADER_CONSTANTS) {
        struct r300_vertex_shader* vs = r300->vs_state.state;
        r300_emit_vs_constant_buffer(r300, &vs->code.constants);
        r300->dirty_state &= ~R300_NEW_VERTEX_SHADER_CONSTANTS;
    }

    /* XXX
    assert(r300->dirty_state == 0);
    */

    /* Finally, emit the VBO. */
    /* r300_emit_vertex_buffer(r300); */

@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a27 1
#include "util/u_mm.h"
a30 1
#include "r300_cb.h"
a34 1
#include "r300_screen_buffer.h"
d45 3
d49 3
a51 1
        WRITE_CS_TABLE(blend->cb, size);
d53 4
a56 1
        WRITE_CS_TABLE(blend->cb_no_readwrite, size);
d58 2
d66 1
d69 11
a79 1
    WRITE_CS_TABLE(bc->cb, size);
d85 3
a87 1
    struct r300_clip_state* clip = (struct r300_clip_state*)state;
d90 21
a110 1
    WRITE_CS_TABLE(clip->cb, size);
d116 1
d119 1
d122 4
d127 2
a128 1
        WRITE_CS_TABLE(&dsa->cb_begin, size);
d130 2
a131 1
        WRITE_CS_TABLE(dsa->cb_no_readwrite, size);
d133 7
d142 1
a142 2
static void get_rc_constant_state(
    float vec[4],
d144 2
a145 1
    struct rc_constant * constant)
d147 6
a152 2
    struct r300_textures_state* texstate = r300->textures_state.state;
    struct r300_texture *tex;
d154 16
a169 1
    assert(constant->Type == RC_CONSTANT_STATE);
d171 5
a175 3
    /* vec should either be (0, 0, 0, 1), which should be a relatively safe
     * RGBA or STRQ value, or it could be one of the RC_CONSTANT_STATE
     * state factors. */
d177 5
a181 10
    switch (constant->u.State[0]) {
        /* Factor for converting rectangle coords to
         * normalized coords. Should only show up on non-r500. */
        case RC_STATE_R300_TEXRECT_FACTOR:
            tex = r300_texture(texstate->sampler_views[constant->u.State[1]]->base.texture);
            vec[0] = 1.0 / tex->desc.width0;
            vec[1] = 1.0 / tex->desc.height0;
            vec[2] = 0;
            vec[3] = 1;
            break;
d183 5
a187 8
        case RC_STATE_R300_TEXSCALE_FACTOR:
            tex = r300_texture(texstate->sampler_views[constant->u.State[1]]->base.texture);
            /* Add a small number to the texture size to work around rounding errors in hw. */
            vec[0] = tex->desc.b.b.width0  / (tex->desc.width0  + 0.001f);
            vec[1] = tex->desc.b.b.height0 / (tex->desc.height0 + 0.001f);
            vec[2] = tex->desc.b.b.depth0  / (tex->desc.depth0  + 0.001f);
            vec[3] = 1;
            break;
d189 4
a192 12
        case RC_STATE_R300_VIEWPORT_SCALE:
            vec[0] = r300->viewport.scale[0];
            vec[1] = r300->viewport.scale[1];
            vec[2] = r300->viewport.scale[2];
            vec[3] = 1;
            break;

        case RC_STATE_R300_VIEWPORT_OFFSET:
            vec[0] = r300->viewport.translate[0];
            vec[1] = r300->viewport.translate[1];
            vec[2] = r300->viewport.translate[2];
            vec[3] = 1;
d196 2
a197 6
            fprintf(stderr, "r300: Implementation error: "
                "Unknown RC_CONSTANT type %d\n", constant->u.State[0]);
            vec[0] = 0;
            vec[1] = 0;
            vec[2] = 0;
            vec[3] = 1;
d199 5
d209 1
a209 1
uint32_t pack_float24(float f)
d240 2
a241 1
void r300_emit_fs(struct r300_context* r300, unsigned size, void *state)
d243 2
a244 1
    struct r300_fragment_shader *fs = r300_fs(r300);
d247 3
a249 2
    WRITE_CS_TABLE(fs->shader->cb_code, fs->shader->cb_code_size);
}
d251 3
a253 7
void r300_emit_fs_constants(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    struct r300_constant_buffer *buf = (struct r300_constant_buffer*)state;
    unsigned count = fs->shader->externals_count;
    unsigned i, j;
    CS_LOCALS(r300);
d255 3
a257 2
    if (count == 0)
        return;
d259 3
a261 13
    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_PFS_PARAM_0_X, count * 4);
    if (buf->remap_table){
        for (i = 0; i < count; i++) {
            float *data = (float*)&buf->ptr[buf->remap_table[i]*4];
            for (j = 0; j < 4; j++)
                OUT_CS(pack_float24(data[j]));
        }
    } else {
        for (i = 0; i < count; i++)
            for (j = 0; j < 4; j++)
                OUT_CS(pack_float24(*(float*)&buf->ptr[i*4+j]));
    }
d263 3
a265 2
    END_CS;
}
d267 3
a269 10
void r300_emit_fs_rc_constant_state(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    struct rc_constant_list *constants = &fs->shader->code.constants;
    unsigned i;
    unsigned count = fs->shader->rc_state_count;
    unsigned first = fs->shader->externals_count;
    unsigned end = constants->Count;
    unsigned j;
    CS_LOCALS(r300);
d271 3
a273 2
    if (count == 0)
        return;
d275 4
a278 11
    BEGIN_CS(size);
    for(i = first; i < end; ++i) {
        if (constants->Constants[i].Type == RC_CONSTANT_STATE) {
            float data[4];

            get_rc_constant_state(data, r300, &constants->Constants[i]);

            OUT_CS_REG_SEQ(R300_PFS_PARAM_0_X + i * 16, 4);
            for (j = 0; j < 4; j++)
                OUT_CS(pack_float24(data[j]));
        }
d280 1
d284 2
a285 1
void r500_emit_fs(struct r300_context* r300, unsigned size, void *state)
d287 1
a287 11
    struct r300_fragment_shader *fs = r300_fs(r300);
    CS_LOCALS(r300);

    WRITE_CS_TABLE(fs->shader->cb_code, fs->shader->cb_code_size);
}

void r500_emit_fs_constants(struct r300_context* r300, unsigned size, void *state)
{
    struct r300_fragment_shader *fs = r300_fs(r300);
    struct r300_constant_buffer *buf = (struct r300_constant_buffer*)state;
    unsigned count = fs->shader->externals_count;
d290 1
a290 1
    if (count == 0)
d293 10
a302 10
    BEGIN_CS(size);
    OUT_CS_REG(R500_GA_US_VECTOR_INDEX, R500_GA_US_VECTOR_INDEX_TYPE_CONST);
    OUT_CS_ONE_REG(R500_GA_US_VECTOR_DATA, count * 4);
    if (buf->remap_table){
        for (unsigned i = 0; i < count; i++) {
            uint32_t *data = &buf->ptr[buf->remap_table[i]*4];
            OUT_CS_TABLE(data, 4);
        }
    } else {
        OUT_CS_TABLE(buf->ptr, count * 4);
d307 2
a308 1
void r500_emit_fs_rc_constant_state(struct r300_context* r300, unsigned size, void *state)
a309 6
    struct r300_fragment_shader *fs = r300_fs(r300);
    struct rc_constant_list *constants = &fs->shader->code.constants;
    unsigned i;
    unsigned count = fs->shader->rc_state_count;
    unsigned first = fs->shader->externals_count;
    unsigned end = constants->Count;
d312 7
a318 16
    if (count == 0)
        return;

    BEGIN_CS(size);
    for(i = first; i < end; ++i) {
        if (constants->Constants[i].Type == RC_CONSTANT_STATE) {
            float data[4];

            get_rc_constant_state(data, r300, &constants->Constants[i]);

            OUT_CS_REG(R500_GA_US_VECTOR_INDEX,
                       R500_GA_US_VECTOR_INDEX_TYPE_CONST |
                       (i & R500_GA_US_VECTOR_INDEX_MASK));
            OUT_CS_ONE_REG(R500_GA_US_VECTOR_DATA, 4);
            OUT_CS_TABLE(data, 4);
        }
d323 2
a324 1
void r300_emit_gpu_flush(struct r300_context *r300, unsigned size, void *state)
d326 2
a327 5
    struct r300_gpu_flush *gpuflush = (struct r300_gpu_flush*)state;
    struct pipe_framebuffer_state* fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    uint32_t height = fb->height;
    uint32_t width = fb->width;
d330 19
a348 5
    if (r300->cbzb_clear) {
        struct r300_surface *surf = r300_surface(fb->cbufs[0]);

        height = surf->cbzb_height;
        width = surf->cbzb_width;
a350 22
    DBG(r300, DBG_SCISSOR,
	"r300: Scissor width: %i, height: %i, CBZB clear: %s\n",
	width, height, r300->cbzb_clear ? "YES" : "NO");

    BEGIN_CS(size);

    /* Set up scissors.
     * By writing to the SC registers, SC & US assert idle. */
    OUT_CS_REG_SEQ(R300_SC_SCISSORS_TL, 2);
    if (r300->screen->caps.is_r500) {
        OUT_CS(0);
        OUT_CS(((width  - 1) << R300_SCISSORS_X_SHIFT) |
               ((height - 1) << R300_SCISSORS_Y_SHIFT));
    } else {
        OUT_CS((1440 << R300_SCISSORS_X_SHIFT) |
               (1440 << R300_SCISSORS_Y_SHIFT));
        OUT_CS(((width  + 1440-1) << R300_SCISSORS_X_SHIFT) |
               ((height + 1440-1) << R300_SCISSORS_Y_SHIFT));
    }

    /* Flush CB & ZB caches and wait until the 3D engine is idle and clean. */
    OUT_CS_TABLE(gpuflush->cb_flush_clean, 6);
d354 2
a355 1
void r300_emit_aa_state(struct r300_context *r300, unsigned size, void *state)
d357 1
a357 1
    struct r300_aa_state *aa = (struct r300_aa_state*)state;
d360 2
a361 2
    BEGIN_CS(size);
    OUT_CS_REG(R300_GB_AA_CONFIG, aa->aa_config);
d363 11
a373 6
    if (aa->dest) {
        OUT_CS_REG_SEQ(R300_RB3D_AARESOLVE_OFFSET, 1);
        OUT_CS_RELOC(aa->dest->cs_buffer, aa->dest->offset, 0, aa->dest->domain);

        OUT_CS_REG_SEQ(R300_RB3D_AARESOLVE_PITCH, 1);
        OUT_CS_RELOC(aa->dest->cs_buffer, aa->dest->pitch, 0, aa->dest->domain);
a374 2

    OUT_CS_REG(R300_RB3D_AARESOLVE_CTL, aa->aaresolve_ctl);
d381 4
a384 3
    struct r300_surface* surf;
    unsigned i;
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
d389 18
a406 5
    /* NUM_MULTIWRITES replicates COLOR[0] to all colorbuffers, which is not
     * what we usually want. */
    if (r300->screen->caps.is_r500) {
        OUT_CS_REG(R300_RB3D_CCTL,
            R300_RB3D_CCTL_INDEPENDENT_COLORFORMAT_ENABLE_ENABLE);
d408 1
a408 1
        OUT_CS_REG(R300_RB3D_CCTL, 0);
d413 3
a415 1
        surf = r300_surface(fb->cbufs[i]);
d418 1
a418 1
        OUT_CS_RELOC(surf->cs_buffer, surf->offset, 0, surf->domain);
d421 7
a427 1
        OUT_CS_RELOC(surf->cs_buffer, surf->pitch, 0, surf->domain);
a429 16
    /* Set up the ZB part of the CBZB clear. */
    if (r300->cbzb_clear) {
        surf = r300_surface(fb->cbufs[0]);

        OUT_CS_REG(R300_ZB_FORMAT, surf->cbzb_format);

        OUT_CS_REG_SEQ(R300_ZB_DEPTHOFFSET, 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->cbzb_midpoint_offset, 0, surf->domain);

        OUT_CS_REG_SEQ(R300_ZB_DEPTHPITCH, 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->cbzb_pitch, 0, surf->domain);

        DBG(r300, DBG_CBZB,
            "CBZB clearing cbuf %08x %08x\n", surf->cbzb_format,
            surf->cbzb_pitch);
    }
d431 4
a434 4
    else if (fb->zsbuf) {
        surf = r300_surface(fb->zsbuf);

        OUT_CS_REG(R300_ZB_FORMAT, surf->format);
d437 1
a437 4
        OUT_CS_RELOC(surf->cs_buffer, surf->offset, 0, surf->domain);

        OUT_CS_REG_SEQ(R300_ZB_DEPTHPITCH, 1);
        OUT_CS_RELOC(surf->cs_buffer, surf->pitch, 0, surf->domain);
d439 1
a439 40
        if (can_hyperz) {
            uint32_t surf_pitch;
            struct r300_texture *tex;
            int level = surf->base.u.tex.level;
            tex = r300_texture(surf->base.texture);

            surf_pitch = surf->pitch & R300_DEPTHPITCH_MASK;
            /* HiZ RAM. */
            if (r300->screen->caps.hiz_ram) {
                if (tex->hiz_mem[level]) {
                    OUT_CS_REG(R300_ZB_HIZ_OFFSET, tex->hiz_mem[level]->ofs << 2);
                    OUT_CS_REG(R300_ZB_HIZ_PITCH, surf_pitch);
                } else {
                    OUT_CS_REG(R300_ZB_HIZ_OFFSET, 0);
                    OUT_CS_REG(R300_ZB_HIZ_PITCH, 0);
                }
            }
            /* Z Mask RAM. (compressed zbuffer) */
            if (tex->zmask_mem[level]) {
                OUT_CS_REG(R300_ZB_ZMASK_OFFSET, tex->zmask_mem[level]->ofs << 2);
                OUT_CS_REG(R300_ZB_ZMASK_PITCH, surf_pitch);
            } else {
                OUT_CS_REG(R300_ZB_ZMASK_OFFSET, 0);
                OUT_CS_REG(R300_ZB_ZMASK_PITCH, 0);
            }
        }
    /* Set up a dummy zbuffer. Otherwise occlusion queries won't work.
     * Use the first colorbuffer, we will disable writes in the DSA state
     * so as not to corrupt it. */
    } else if (fb->nr_cbufs) {
        surf = r300_surface(fb->cbufs[0]);
        unsigned tiling =
            r300->rws->get_value(r300->rws, R300_VID_SQUARE_TILING_SUPPORT) ?
            R300_DEPTHMICROTILE_TILED_SQUARE :
            R300_DEPTHMICROTILE_TILED;

        OUT_CS_REG(R300_ZB_FORMAT, R300_DEPTHFORMAT_16BIT_INT_Z);

        OUT_CS_REG_SEQ(R300_ZB_DEPTHOFFSET, 1);
        OUT_CS_RELOC(surf->cs_buffer, 0, 0, surf->domain);
d442 2
a443 1
        OUT_CS_RELOC(surf->cs_buffer, 4 | tiling, 0, surf->domain);
d446 2
d451 1
a451 89
void r300_emit_hyperz_state(struct r300_context *r300,
                            unsigned size, void *state)
{
    struct r300_hyperz_state *z = state;
    CS_LOCALS(r300);
    if (z->flush)
        WRITE_CS_TABLE(&z->cb_flush_begin, size);
    else
        WRITE_CS_TABLE(&z->cb_begin, size - 2);
}

void r300_emit_hyperz_end(struct r300_context *r300)
{
    struct r300_hyperz_state z =
            *(struct r300_hyperz_state*)r300->hyperz_state.state;

    z.flush = 1;
    z.zb_bw_cntl = 0;
    z.zb_depthclearvalue = 0;
    z.sc_hyperz = R300_SC_HYPERZ_ADJ_2;
    z.gb_z_peq_config = 0;

    r300_emit_hyperz_state(r300, r300->hyperz_state.size, &z);
}

void r300_emit_fb_state_pipelined(struct r300_context *r300,
                                  unsigned size, void *state)
{
    struct pipe_framebuffer_state* fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    unsigned i;
    CS_LOCALS(r300);

    BEGIN_CS(size);

    /* Colorbuffer format in the US block.
     * (must be written after unpipelined regs) */
    OUT_CS_REG_SEQ(R300_US_OUT_FMT_0, 4);
    for (i = 0; i < fb->nr_cbufs; i++) {
        OUT_CS(r300_surface(fb->cbufs[i])->format);
    }
    for (; i < 1; i++) {
        OUT_CS(R300_US_OUT_FMT_C4_8 |
               R300_C0_SEL_B | R300_C1_SEL_G |
               R300_C2_SEL_R | R300_C3_SEL_A);
    }
    for (; i < 4; i++) {
        OUT_CS(R300_US_OUT_FMT_UNUSED);
    }

    /* Multisampling. Depends on framebuffer sample count.
     * These are pipelined regs and as such cannot be moved
     * to the AA state. */
    if (r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0)) {
        unsigned mspos0 = 0x66666666;
        unsigned mspos1 = 0x6666666;

        if (fb->nr_cbufs && fb->cbufs[0]->texture->nr_samples > 1) {
            /* Subsample placement. These may not be optimal. */
            switch (fb->cbufs[0]->texture->nr_samples) {
                case 2:
                    mspos0 = 0x33996633;
                    mspos1 = 0x6666663;
                    break;
                case 3:
                    mspos0 = 0x33936933;
                    mspos1 = 0x6666663;
                    break;
                case 4:
                    mspos0 = 0x33939933;
                    mspos1 = 0x3966663;
                    break;
                case 6:
                    mspos0 = 0x22a2aa22;
                    mspos1 = 0x2a65672;
                    break;
                default:
                    debug_printf("r300: Bad number of multisamples!\n");
            }
        }

        OUT_CS_REG_SEQ(R300_GB_MSPOS0, 2);
        OUT_CS(mspos0);
        OUT_CS(mspos1);
    }
    END_CS;
}

void r300_emit_query_start(struct r300_context *r300, unsigned size, void*state)
d453 1
d460 2
a461 2
    BEGIN_CS(size);
    if (r300->screen->caps.family == CHIP_FAMILY_RV530) {
a468 1
    query->flushed = FALSE;
d471 3
a473 2
static void r300_emit_query_end_frag_pipes(struct r300_context *r300,
                                           struct r300_query *query)
d475 1
a475 2
    struct r300_capabilities* caps = &r300->screen->caps;
    struct r300_winsys_cs_buffer *buf = r300->query_current->cs_buffer;
d494 2
a495 2
            OUT_CS_RELOC(buf, (query->num_results + 3) * 4,
                    0, query->domain);
d500 2
a501 2
            OUT_CS_RELOC(buf, (query->num_results + 2) * 4,
                    0, query->domain);
d508 2
a509 2
            OUT_CS_RELOC(buf, (query->num_results + 1) * 4,
                    0, query->domain);
d514 2
a515 2
            OUT_CS_RELOC(buf, (query->num_results + 0) * 4,
                    0, query->domain);
d518 1
a518 1
            fprintf(stderr, "r300: Implementation error: Chipset reports %d"
d520 1
a520 1
            abort();
d528 2
a529 2
static void rv530_emit_query_end_single_z(struct r300_context *r300,
                                          struct r300_query *query)
a530 1
    struct r300_winsys_cs_buffer *buf = r300->query_current->cs_buffer;
d536 1
a536 1
    OUT_CS_RELOC(buf, query->num_results * 4, 0, query->domain);
d541 2
a542 2
static void rv530_emit_query_end_double_z(struct r300_context *r300,
                                          struct r300_query *query)
a543 1
    struct r300_winsys_cs_buffer *buf = r300->query_current->cs_buffer;
d549 1
a549 1
    OUT_CS_RELOC(buf, (query->num_results + 0) * 4, 0, query->domain);
d552 1
a552 1
    OUT_CS_RELOC(buf, (query->num_results + 1) * 4, 0, query->domain);
d559 1
a559 1
    struct r300_capabilities *caps = &r300->screen->caps;
d570 1
a570 1
            rv530_emit_query_end_double_z(r300, query);
d572 1
a572 1
            rv530_emit_query_end_single_z(r300, query);
d574 1
a574 17
        r300_emit_query_end_frag_pipes(r300, query);

    query->begin_emitted = FALSE;
    query->num_results += query->num_pipes;

    /* XXX grab all the results and reset the counter. */
    if (query->num_results >= query->buffer_size / 4 - 4) {
        query->num_results = (query->buffer_size / 4) / 2;
        fprintf(stderr, "r300: Rewinding OQBO...\n");
    }
}

void r300_emit_invariant_state(struct r300_context *r300,
                               unsigned size, void *state)
{
    CS_LOCALS(r300);
    WRITE_CS_TABLE(state, size);
d579 2
a580 1
    struct r300_rs_state* rs = state;
d584 7
a590 1
    OUT_CS_TABLE(rs->cb_main, RS_STATE_MAIN_SIZE);
d592 10
a601 4
        if (r300->zbuffer_bpp == 16) {
            OUT_CS_TABLE(rs->cb_poly_offset_zb16, 5);
        } else {
            OUT_CS_TABLE(rs->cb_poly_offset_zb24, 5);
d603 6
d610 7
d625 1
d630 1
a630 14
    if (DBG_ON(r300, DBG_RS_BLOCK)) {
        r500_dump_rs_block(rs);

        fprintf(stderr, "r300: RS emit:\n");

        for (i = 0; i < count; i++)
            fprintf(stderr, "    : ip %d: 0x%08x\n", i, rs->ip[i]);

        for (i = 0; i < count; i++)
            fprintf(stderr, "    : inst %d: 0x%08x\n", i, rs->inst[i]);

        fprintf(stderr, "    : count: 0x%08x inst_count: 0x%08x\n",
            rs->count, rs->inst_count);
    }
d633 1
a633 10
    OUT_CS_REG_SEQ(R300_VAP_VTX_STATE_CNTL, 2);
    OUT_CS(rs->vap_vtx_state_cntl);
    OUT_CS(rs->vap_vsm_vtx_assm);
    OUT_CS_REG_SEQ(R300_VAP_OUTPUT_VTX_FMT_0, 2);
    OUT_CS(rs->vap_out_vtx_fmt[0]);
    OUT_CS(rs->vap_out_vtx_fmt[1]);
    OUT_CS_REG_SEQ(R300_GB_ENABLE, 1);
    OUT_CS(rs->gb_enable);

    if (r300->screen->caps.is_r500) {
d638 4
a641 1
    OUT_CS_TABLE(rs->ip, count);
d647 1
a647 1
    if (r300->screen->caps.is_r500) {
d652 8
a659 1
    OUT_CS_TABLE(rs->inst, count);
d666 3
d670 2
d674 34
a707 7
    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_SC_CLIPRECT_TL_0, 2);
    if (r300->screen->caps.is_r500) {
        OUT_CS((scissor->minx << R300_CLIPRECT_X_SHIFT) |
               (scissor->miny << R300_CLIPRECT_Y_SHIFT));
        OUT_CS(((scissor->maxx - 1) << R300_CLIPRECT_X_SHIFT) |
               ((scissor->maxy - 1) << R300_CLIPRECT_Y_SHIFT));
d709 7
a715 4
        OUT_CS(((scissor->minx + 1440) << R300_CLIPRECT_X_SHIFT) |
               ((scissor->miny + 1440) << R300_CLIPRECT_Y_SHIFT));
        OUT_CS(((scissor->maxx + 1440-1) << R300_CLIPRECT_X_SHIFT) |
               ((scissor->maxy + 1440-1) << R300_CLIPRECT_Y_SHIFT));
d717 5
a729 1
    struct r300_texture *tex;
a738 1
            tex = r300_texture(allstate->sampler_views[i]->base.texture);
d740 2
a741 2
            OUT_CS_REG(R300_TX_FILTER0_0 + (i * 4), texstate->filter0);
            OUT_CS_REG(R300_TX_FILTER1_0 + (i * 4), texstate->filter1);
d745 3
a747 3
            OUT_CS_REG(R300_TX_FORMAT0_0 + (i * 4), texstate->format.format0);
            OUT_CS_REG(R300_TX_FORMAT1_0 + (i * 4), texstate->format.format1);
            OUT_CS_REG(R300_TX_FORMAT2_0 + (i * 4), texstate->format.format2);
d750 2
a751 2
            OUT_CS_TEX_RELOC(tex, texstate->format.tile_config, tex->domain,
                             0);
d757 1
a757 1
static void r300_update_aos_cb(struct r300_context *r300, unsigned packet_size)
d760 1
a760 3
    struct pipe_vertex_element *velem = r300->velems->velem;
    unsigned *hw_format_size = r300->velems->hw_format_size;
    unsigned size1, size2, aos_count = r300->velems->count;
d762 7
a768 1
    CB_LOCALS;
a769 1
    BEGIN_CB(r300->aos_cb, packet_size);
d773 2
a774 2
        size1 = hw_format_size[i];
        size2 = hw_format_size[i+1];
d776 1
a776 1
        OUT_CB(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride) |
d778 2
a779 2
        OUT_CB(vb1->buffer_offset + velem[i].src_offset);
        OUT_CB(vb2->buffer_offset + velem[i+1].src_offset);
d784 1
a784 1
        size1 = hw_format_size[i];
d786 2
a787 51
        OUT_CB(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride));
        OUT_CB(vb1->buffer_offset + velem[i].src_offset);
    }
    END_CB;

    r300->aos_dirty = FALSE;
}

void r300_emit_aos(struct r300_context* r300, int offset, boolean indexed)
{
    struct pipe_vertex_buffer *vbuf = r300->vertex_buffer;
    struct pipe_vertex_element *velem = r300->velems->velem;
    struct r300_buffer *buf;
    int i;
    unsigned aos_count = r300->velems->count;
    unsigned packet_size = (aos_count * 3 + 1) / 2;
    CS_LOCALS(r300);

    BEGIN_CS(2 + packet_size + aos_count * 2);
    OUT_CS_PKT3(R300_PACKET3_3D_LOAD_VBPNTR, packet_size);
    OUT_CS(aos_count | (!indexed ? R300_VC_FORCE_PREFETCH : 0));

    if (!offset) {
        if (r300->aos_dirty) {
            r300_update_aos_cb(r300, packet_size);
        }
        OUT_CS_TABLE(r300->aos_cb, packet_size);
    } else {
        struct pipe_vertex_buffer *vb1, *vb2;
        unsigned *hw_format_size = r300->velems->hw_format_size;
        unsigned size1, size2;

        for (i = 0; i < aos_count - 1; i += 2) {
            vb1 = &vbuf[velem[i].vertex_buffer_index];
            vb2 = &vbuf[velem[i+1].vertex_buffer_index];
            size1 = hw_format_size[i];
            size2 = hw_format_size[i+1];

            OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride) |
                   R300_VBPNTR_SIZE1(size2) | R300_VBPNTR_STRIDE1(vb2->stride));
            OUT_CS(vb1->buffer_offset + velem[i].src_offset   + offset * vb1->stride);
            OUT_CS(vb2->buffer_offset + velem[i+1].src_offset + offset * vb2->stride);
        }

        if (aos_count & 1) {
            vb1 = &vbuf[velem[i].vertex_buffer_index];
            size1 = hw_format_size[i];

            OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(vb1->stride));
            OUT_CS(vb1->buffer_offset + velem[i].src_offset + offset * vb1->stride);
        }
d791 2
a792 2
        buf = r300_buffer(vbuf[velem[i].vertex_buffer_index].buffer);
        OUT_CS_BUF_RELOC_NO_OFFSET(&buf->b.b, buf->domain, 0);
a796 24
void r300_emit_aos_swtcl(struct r300_context *r300, boolean indexed)
{
    CS_LOCALS(r300);

    DBG(r300, DBG_SWTCL, "r300: Preparing vertex buffer %p for render, "
            "vertex size %d\n", r300->vbo,
            r300->vertex_info.size);
    /* Set the pointer to our vertex buffer. The emitted values are this:
     * PACKET3 [3D_LOAD_VBPNTR]
     * COUNT   [1]
     * FORMAT  [size | stride << 8]
     * OFFSET  [offset into BO]
     * VBPNTR  [relocated BO]
     */
    BEGIN_CS(7);
    OUT_CS_PKT3(R300_PACKET3_3D_LOAD_VBPNTR, 3);
    OUT_CS(1 | (!indexed ? R300_VC_FORCE_PREFETCH : 0));
    OUT_CS(r300->vertex_info.size |
            (r300->vertex_info.size << 8));
    OUT_CS(r300->draw_vbo_offset);
    OUT_CS_BUF_RELOC(r300->vbo, 0, r300_buffer(r300->vbo)->domain, 0);
    END_CS;
}

d805 1
a805 13
    if (DBG_ON(r300, DBG_PSC)) {
        fprintf(stderr, "r300: PSC emit:\n");

        for (i = 0; i < streams->count; i++) {
            fprintf(stderr, "    : prog_stream_cntl%d: 0x%08x\n", i,
                   streams->vap_prog_stream_cntl[i]);
        }

        for (i = 0; i < streams->count; i++) {
            fprintf(stderr, "    : prog_stream_cntl_ext%d: 0x%08x\n", i,
                   streams->vap_prog_stream_cntl_ext[i]);
        }
    }
d809 5
a813 1
    OUT_CS_TABLE(streams->vap_prog_stream_cntl, streams->count);
d815 5
a819 1
    OUT_CS_TABLE(streams->vap_prog_stream_cntl_ext, streams->count);
d823 2
a824 1
void r300_emit_pvs_flush(struct r300_context* r300, unsigned size, void* state)
d826 2
d830 2
d833 6
a838 1
    OUT_CS_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0x0);
d842 1
a842 2
void r300_emit_vap_invariant_state(struct r300_context *r300,
                                   unsigned size, void *state)
d845 4
a848 1
    WRITE_CS_TABLE(state, size);
d855 1
a855 1
    struct r300_screen* r300screen = r300->screen;
d857 1
d859 1
a859 1
    unsigned vtx_mem_size = r300screen->caps.is_r500 ? 128 : 72;
d866 1
a866 1
    unsigned pvs_num_controllers = MIN2(vtx_mem_size / temp_count, 5);
d870 6
a876 1

d881 6
a886 4
    OUT_CS_REG(R300_VAP_PVS_CODE_CNTL_0, R300_PVS_FIRST_INST(0) |
	       R300_PVS_XYZW_VALID_INST(instruction_count - 1) |
	       R300_PVS_LAST_INST(instruction_count - 1));
    OUT_CS_REG(R300_VAP_PVS_CODE_CNTL_1, instruction_count - 1);
d890 3
a892 1
    OUT_CS_TABLE(code->body.d, code->length);
d896 1
a896 1
            R300_PVS_NUM_FPUS(r300screen->caps.num_vert_fpus) |
d898 1
a898 17
            (r300screen->caps.is_r500 ? R500_TCL_STATE_OPTIMIZATION : 0));

    /* Emit flow control instructions. */
    if (code->num_fc_ops) {

        OUT_CS_REG(R300_VAP_PVS_FLOW_CNTL_OPC, code->fc_ops);
        if (r300screen->caps.is_r500) {
            OUT_CS_REG_SEQ(R500_VAP_PVS_FLOW_CNTL_ADDRS_LW_0, code->num_fc_ops * 2);
            OUT_CS_TABLE(code->fc_op_addrs.r500, code->num_fc_ops * 2);
        } else {
            OUT_CS_REG_SEQ(R300_VAP_PVS_FLOW_CNTL_ADDRS_0, code->num_fc_ops);
            OUT_CS_TABLE(code->fc_op_addrs.r300, code->num_fc_ops);
        }
        OUT_CS_REG_SEQ(R300_VAP_PVS_FLOW_CNTL_LOOP_INDEX_0, code->num_fc_ops);
        OUT_CS_TABLE(code->fc_loop_index, code->num_fc_ops);
    }

d902 2
a903 2
void r300_emit_vs_constants(struct r300_context* r300,
                            unsigned size, void *state)
d905 2
a906 8
    unsigned count =
        ((struct r300_vertex_shader*)r300->vs_state.state)->externals_count;
    struct r300_constant_buffer *buf = (struct r300_constant_buffer*)state;
    struct r300_vertex_shader *vs = (struct r300_vertex_shader*)r300->vs_state.state;
    unsigned i;
    int imm_first = vs->externals_count;
    int imm_end = vs->code.constants.Count;
    int imm_count = vs->immediates_count;
d909 4
a912 17
    BEGIN_CS(size);
    OUT_CS_REG(R300_VAP_PVS_CONST_CNTL,
               R300_PVS_CONST_BASE_OFFSET(buf->buffer_base) |
               R300_PVS_MAX_CONST_ADDR(MAX2(imm_end - 1, 0)));
    if (vs->externals_count) {
        OUT_CS_REG(R300_VAP_PVS_VECTOR_INDX_REG,
                   (r300->screen->caps.is_r500 ?
                   R500_PVS_CONST_START : R300_PVS_CONST_START) + buf->buffer_base);
        OUT_CS_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, count * 4);
        if (buf->remap_table){
            for (i = 0; i < count; i++) {
                uint32_t *data = &buf->ptr[buf->remap_table[i]*4];
                OUT_CS_TABLE(data, 4);
            }
        } else {
            OUT_CS_TABLE(buf->ptr, count * 4);
        }
d915 16
a930 11
    /* Emit immediates. */
    if (imm_count) {
        OUT_CS_REG(R300_VAP_PVS_VECTOR_INDX_REG,
                   (r300->screen->caps.is_r500 ?
                   R500_PVS_CONST_START : R300_PVS_CONST_START) +
                   buf->buffer_base + imm_first);
        OUT_CS_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, imm_count * 4);
        for (i = imm_first; i < imm_end; i++) {
            const float *data = vs->code.constants.Constants[i].u.Immediate;
            OUT_CS_TABLE(data, 4);
        }
d941 10
a950 110
    BEGIN_CS(size);
    OUT_CS_REG_SEQ(R300_SE_VPORT_XSCALE, 6);
    OUT_CS_TABLE(&viewport->xscale, 6);
    OUT_CS_REG(R300_VAP_VTE_CNTL, viewport->vte_control);
    END_CS;
}

static void r300_emit_hiz_line_clear(struct r300_context *r300, int start, uint16_t count, uint32_t val)
{
    CS_LOCALS(r300);
    BEGIN_CS(4);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_HIZ, 2);
    OUT_CS(start);
    OUT_CS(count);
    OUT_CS(val);
    END_CS;
}

static void r300_emit_zmask_line_clear(struct r300_context *r300, int start, uint16_t count, uint32_t val)
{
    CS_LOCALS(r300);
    BEGIN_CS(4);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_ZMASK, 2);
    OUT_CS(start);
    OUT_CS(count);
    OUT_CS(val);
    END_CS;
}

#define ALIGN_DIVUP(x, y) (((x) + (y) - 1) / (y))

void r300_emit_hiz_clear(struct r300_context *r300, unsigned size, void *state)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_hyperz_state *z =
        (struct r300_hyperz_state*)r300->hyperz_state.state;
    struct r300_screen* r300screen = r300->screen;
    uint32_t stride, offset = 0, height, offset_shift;
    struct r300_texture* tex;
    int i;

    tex = r300_texture(fb->zsbuf->texture);

    offset = tex->hiz_mem[fb->zsbuf->u.tex.level]->ofs;
    stride = tex->desc.stride_in_pixels[fb->zsbuf->u.tex.level];

    /* convert from pixels to 4x4 blocks */
    stride = ALIGN_DIVUP(stride, 4);

    stride = ALIGN_DIVUP(stride, r300screen->caps.num_frag_pipes);    
    /* there are 4 blocks per dwords */
    stride = ALIGN_DIVUP(stride, 4);

    height = ALIGN_DIVUP(fb->zsbuf->height, 4);

    offset_shift = 2;
    offset_shift += (r300screen->caps.num_frag_pipes / 2);

    for (i = 0; i < height; i++) {
        offset = i * stride;
        offset <<= offset_shift;
        r300_emit_hiz_line_clear(r300, offset, stride, 0xffffffff);
    }
    z->current_func = -1;

    /* Mark the current zbuffer's hiz ram as in use. */
    tex->hiz_in_use[fb->zsbuf->u.tex.level] = TRUE;
}

void r300_emit_zmask_clear(struct r300_context *r300, unsigned size, void *state)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_screen* r300screen = r300->screen;
    uint32_t stride, offset = 0;
    struct r300_texture* tex;
    uint32_t i, height;
    int mult, offset_shift;

    tex = r300_texture(fb->zsbuf->texture);
    stride = tex->desc.stride_in_pixels[fb->zsbuf->u.tex.level];

    offset = tex->zmask_mem[fb->zsbuf->u.tex.level]->ofs;

    if (r300->z_compression == RV350_Z_COMPRESS_88)
        mult = 8;
    else
        mult = 4;

    height = ALIGN_DIVUP(fb->zsbuf->height, mult);

    offset_shift = 4;
    offset_shift += (r300screen->caps.num_frag_pipes / 2);
    stride = ALIGN_DIVUP(stride, r300screen->caps.num_frag_pipes);

    /* okay have width in pixels - divide by block width */
    stride = ALIGN_DIVUP(stride, mult);
    /* have width in blocks - divide by number of fragment pipes screen width */
    /* 16 blocks per dword */
    stride = ALIGN_DIVUP(stride, 16);

    for (i = 0; i < height; i++) {
        offset = i * stride;
        offset <<= offset_shift;
        r300_emit_zmask_line_clear(r300, offset, stride, 0x0);//0xffffffff);
    }

    /* Mark the current zbuffer's zmask as in use. */
    tex->zmask_in_use[fb->zsbuf->u.tex.level] = TRUE;
d973 3
a975 3
boolean r300_emit_buffer_validate(struct r300_context *r300,
                                  boolean do_validate_vertex_buffers,
                                  struct pipe_resource *index_buffer)
d983 2
a984 2
    struct pipe_vertex_element *velem = r300->velems->velem;
    struct pipe_resource *pbuf;
d986 1
d989 1
a989 1
    r300->rws->cs_reset_buffers(r300->cs);
d991 1
d994 1
a994 1
        tex = r300_texture(fb->cbufs[i]->texture);
d996 5
a1000 2
        r300->rws->cs_add_buffer(r300->cs, tex->cs_buffer, 0,
                                 r300_surface(fb->cbufs[i])->domain);
d1004 1
a1004 1
        tex = r300_texture(fb->zsbuf->texture);
d1006 5
a1010 2
        r300->rws->cs_add_buffer(r300->cs, tex->cs_buffer, 0,
                                 r300_surface(fb->zsbuf)->domain);
d1014 2
a1015 1
        if (!(texstate->tx_enable & (1 << i))) {
d1017 4
a1021 3

        tex = r300_texture(texstate->sampler_views[i]->base.texture);
        r300->rws->cs_add_buffer(r300->cs, tex->cs_buffer, tex->domain, 0);
d1024 7
a1030 3
    if (r300->query_current)
        r300->rws->cs_add_buffer(r300->cs, r300->query_current->cs_buffer,
                                 0, r300->query_current->domain);
d1032 7
a1038 3
    if (r300->vbo)
        r300->rws->cs_add_buffer(r300->cs, r300_buffer(r300->vbo)->cs_buf,
                                 r300_buffer(r300->vbo)->domain, 0);
d1041 1
a1041 1
        for (i = 0; i < r300->velems->count; i++) {
a1042 2
            if (!pbuf)
                continue;
d1044 5
a1048 2
            r300->rws->cs_add_buffer(r300->cs, r300_buffer(pbuf)->cs_buf,
                                     r300_buffer(pbuf)->domain, 0);
d1052 7
a1058 3
    if (index_buffer)
        r300->rws->cs_add_buffer(r300->cs, r300_buffer(index_buffer)->cs_buf,
                                 r300_buffer(index_buffer)->domain, 0);
d1060 9
a1068 2
    if (!r300->rws->cs_validate(r300->cs)) {
        return FALSE;
a1069 2

    return TRUE;
d1077 2
a1078 2
    foreach_dirty_atom(r300, atom) {
        if (atom->dirty) {
d1083 2
a1084 15
    /* let's reserve some more, just in case */
    dwords += 32;

    return dwords;
}

unsigned r300_get_num_cs_end_dwords(struct r300_context *r300)
{
    unsigned dwords = 0;

    /* Emitted in flush. */
    dwords += 26; /* emit_query_end */
    dwords += r300->hyperz_state.size + 2; /* emit_hyperz_end + zcache flush */
    if (r300->screen->caps.index_bias_supported)
        dwords += 2;
d1092 7
a1098 1
    struct r300_atom *atom;
d1100 2
a1101 2
    foreach_dirty_atom(r300, atom) {
        if (atom->dirty) {
d1107 34
a1140 2
    r300->first_dirty = NULL;
    r300->last_dirty = NULL;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d29 1
d49 1
a49 8
        if (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT) {
            WRITE_CS_TABLE(blend->cb_noclamp, size);
        } else if (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16X16_FLOAT) {
            WRITE_CS_TABLE(blend->cb_noclamp_noalpha, size);
        } else {
            unsigned swz = r300_surface(fb->cbufs[0])->colormask_swizzle;
            WRITE_CS_TABLE(blend->cb_clamp[swz], size);
        }
a77 1
    boolean is_r500 = r300->screen->caps.is_r500;
a78 1
    uint32_t alpha_func = dsa->alpha_function;
d80 4
a83 10
    /* Choose the alpha ref value between 8-bit (FG_ALPHA_FUNC.AM_VAL) and
     * 16-bit (FG_ALPHA_VALUE). */
    if (is_r500 && (alpha_func & R300_FG_ALPHA_FUNC_ENABLE)) {
        if (fb->nr_cbufs &&
            (fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
             fb->cbufs[0]->format == PIPE_FORMAT_R16G16B16X16_FLOAT)) {
            alpha_func |= R500_FG_ALPHA_FUNC_FP16_ENABLE;
        } else {
            alpha_func |= R500_FG_ALPHA_FUNC_8BIT;
        }
a84 12

    /* Setup alpha-to-coverage. */
    if (r300->alpha_to_coverage && r300->msaa_enable) {
        /* Always set 3/6, it improves precision even for 2x and 4x MSAA. */
        alpha_func |= R300_FG_ALPHA_FUNC_MASK_ENABLE |
                      R300_FG_ALPHA_FUNC_CFG_3_OF_6;
    }

    BEGIN_CS(size);
    OUT_CS_REG(R300_FG_ALPHA_FUNC, alpha_func);
    OUT_CS_TABLE(fb->zsbuf ? &dsa->cb_begin : dsa->cb_zb_no_readwrite, size-2);
    END_CS;
d93 1
a93 1
    struct r300_resource *tex;
d105 3
a107 3
            tex = r300_resource(texstate->sampler_views[constant->u.State[1]]->base.texture);
            vec[0] = 1.0 / tex->tex.width0;
            vec[1] = 1.0 / tex->tex.height0;
d113 1
a113 1
            tex = r300_resource(texstate->sampler_views[constant->u.State[1]]->base.texture);
d115 3
a117 3
            vec[0] = tex->b.b.width0  / (tex->tex.width0  + 0.001f);
            vec[1] = tex->b.b.height0 / (tex->tex.height0 + 0.001f);
            vec[2] = tex->b.b.depth0  / (tex->tex.depth0  + 0.001f);
d356 5
a360 8
        OUT_CS_REG_SEQ(R300_RB3D_AARESOLVE_OFFSET, 3);
        OUT_CS(aa->dest->offset);
        OUT_CS(aa->dest->pitch & R300_RB3D_AARESOLVE_PITCH_MASK);
        OUT_CS(R300_RB3D_AARESOLVE_CTL_AARESOLVE_MODE_RESOLVE |
               R300_RB3D_AARESOLVE_CTL_AARESOLVE_ALPHA_AVERAGE);
        OUT_CS_RELOC(aa->dest);
    } else {
        OUT_CS_REG(R300_RB3D_AARESOLVE_CTL, 0);
d363 1
d372 1
a372 2
    uint32_t rb3d_cctl = 0;

d377 2
d380 4
a383 5
        rb3d_cctl = R300_RB3D_CCTL_INDEPENDENT_COLORFORMAT_ENABLE_ENABLE;
    }
    /* NUM_MULTIWRITES replicates COLOR[0] to all colorbuffers. */
    if (fb->nr_cbufs && r300->fb_multiwrite) {
        rb3d_cctl |= R300_RB3D_CCTL_NUM_MULTIWRITES(fb->nr_cbufs);
a384 6
    if (r300->cmask_in_use) {
        rb3d_cctl |= R300_RB3D_CCTL_AA_COMPRESSION_ENABLE |
                     R300_RB3D_CCTL_CMASK_ENABLE;
    }

    OUT_CS_REG(R300_RB3D_CCTL, rb3d_cctl);
d390 2
a391 5
        OUT_CS_REG(R300_RB3D_COLOROFFSET0 + (4 * i), surf->offset);
        OUT_CS_RELOC(surf);

        OUT_CS_REG(R300_RB3D_COLORPITCH0 + (4 * i), surf->pitch);
        OUT_CS_RELOC(surf);
d393 2
a394 10
        if (r300->cmask_in_use && i == 0) {
            OUT_CS_REG(R300_RB3D_CMASK_OFFSET0, 0);
            OUT_CS_REG(R300_RB3D_CMASK_PITCH0, surf->pitch_cmask);
            OUT_CS_REG(R300_RB3D_COLOR_CLEAR_VALUE, r300->color_clear_value);
            if (r300->screen->caps.is_r500 && r300->screen->info.drm_minor >= 29) {
                OUT_CS_REG_SEQ(R500_RB3D_COLOR_CLEAR_VALUE_AR, 2);
                OUT_CS(r300->color_clear_value_ar);
                OUT_CS(r300->color_clear_value_gb);
            }
        }
d403 2
a404 2
        OUT_CS_REG(R300_ZB_DEPTHOFFSET, surf->cbzb_midpoint_offset);
        OUT_CS_RELOC(surf);
d406 2
a407 2
        OUT_CS_REG(R300_ZB_DEPTHPITCH, surf->cbzb_pitch);
        OUT_CS_RELOC(surf);
d419 2
a420 2
        OUT_CS_REG(R300_ZB_DEPTHOFFSET, surf->offset);
        OUT_CS_RELOC(surf);
d422 2
a423 2
        OUT_CS_REG(R300_ZB_DEPTHPITCH, surf->pitch);
        OUT_CS_RELOC(surf);
d425 7
a431 1
        if (r300->hyperz_enabled) {
d433 9
a441 2
            OUT_CS_REG(R300_ZB_HIZ_OFFSET, 0);
            OUT_CS_REG(R300_ZB_HIZ_PITCH, surf->pitch_hiz);
d443 7
a449 2
            OUT_CS_REG(R300_ZB_ZMASK_OFFSET, 0);
            OUT_CS_REG(R300_ZB_ZMASK_PITCH, surf->pitch_zmask);
d451 17
a477 1

a497 53
#define R300_NIBBLES(x0, y0, x1, y1, x2, y2, d0y, d0x)  \
    (((x0) & 0xf) | (((y0) & 0xf) << 4) |		   \
    (((x1) & 0xf) << 8) | (((y1) & 0xf) << 12) |	   \
    (((x2) & 0xf) << 16) | (((y2) & 0xf) << 20) |	   \
    (((d0y) & 0xf) << 24) | (((d0x) & 0xf) << 28))

static unsigned r300_get_mspos(int index, unsigned *p)
{
    unsigned reg, i, distx, disty, dist;

    if (index == 0) {
        /* MSPOS0 contains positions for samples 0,1,2 as (X,Y) pairs of nibbles,
         * followed by a (Y,X) pair containing the minimum distance from the pixel
         * edge:
         *     X0, Y0, X1, Y1, X2, Y2, D0_Y, D0_X
         *
         * There is a quirk when setting D0_X. The value represents the distance
         * from the left edge of the pixel quad to the first sample in subpixels.
         * All values less than eight should use the actual value, but „7‟ should
         * be used for the distance „8‟. The hardware will convert 7 into 8 internally.
         */
        distx = 11;
        for (i = 0; i < 12; i += 2) {
            if (p[i] < distx)
                distx = p[i];
        }

        disty = 11;
        for (i = 1; i < 12; i += 2) {
            if (p[i] < disty)
                disty = p[i];
        }

        if (distx == 8)
            distx = 7;

        reg = R300_NIBBLES(p[0], p[1], p[2], p[3], p[4], p[5], disty, distx);
    } else {
        /* MSPOS1 contains positions for samples 3,4,5 as (X,Y) pairs of nibbles,
         * followed by the minimum distance from the pixel edge (not sure if X or Y):
         *     X3, Y3, X4, Y4, X5, Y5, D1
         */
        dist = 11;
        for (i = 0; i < 12; i++) {
            if (p[i] < dist)
                dist = p[i];
        }

        reg = R300_NIBBLES(p[6], p[7], p[8], p[9], p[10], p[11], dist, 0);
    }
    return reg;
}

a500 20
    /* The sample coordinates are in the range [0,11], because
     * GB_TILE_CONFIG.SUBPIXEL is set to the 1/12 subpixel precision.
     *
     * Some sample coordinates reach to neighboring pixels and should not be used.
     * (e.g. Y=11)
     *
     * The unused samples must be set to the positions of other valid samples. */
    static unsigned sample_locs_1x[12] = {
        6,6,  6,6,  6,6,  6,6,  6,6,  6,6
    };
    static unsigned sample_locs_2x[12] = {
        3,9,  9,3,  9,3,  9,3,  9,3,  9,3
    };
    static unsigned sample_locs_4x[12] = {
        4,4,  8,8,  2,10,  10,2,  10,2,  10,2
    };
    static unsigned sample_locs_6x[12] = {
        3,1,  7,3,  11,5,  1,7,  5,9,  9,10
    };

d503 1
a503 2
    unsigned i, num_cbufs = fb->nr_cbufs;
    unsigned mspos0, mspos1;
a505 6
    /* If we use the multiwrite feature, the colorbuffers 2,3,4 must be
     * marked as UNUSED in the US block. */
    if (r300->fb_multiwrite) {
        num_cbufs = MIN2(num_cbufs, 1);
    }

d511 1
a511 1
    for (i = 0; i < num_cbufs; i++) {
d523 35
a557 25
    /* Set sample positions. It depends on the framebuffer sample count.
     * These are pipelined regs and as such cannot be moved to the AA state.
     */
    switch (r300->num_samples) {
    default:
        mspos0 = r300_get_mspos(0, sample_locs_1x);
        mspos1 = r300_get_mspos(1, sample_locs_1x);
        break;
    case 2:
        mspos0 = r300_get_mspos(0, sample_locs_2x);
        mspos1 = r300_get_mspos(1, sample_locs_2x);
        break;
    case 4:
        mspos0 = r300_get_mspos(0, sample_locs_4x);
        mspos1 = r300_get_mspos(1, sample_locs_4x);
        break;
    case 6:
        mspos0 = r300_get_mspos(0, sample_locs_6x);
        mspos1 = r300_get_mspos(1, sample_locs_6x);
        break;
    }

    OUT_CS_REG_SEQ(R300_GB_MSPOS0, 2);
    OUT_CS(mspos0);
    OUT_CS(mspos1);
d570 1
a570 1
    if (r300->screen->caps.family == CHIP_RV530) {
d578 1
d585 1
a585 1
    uint32_t gb_pipes = r300->screen->info.r300_num_gb_pipes;
d588 1
a588 1
    assert(gb_pipes);
d590 1
a590 1
    BEGIN_CS(6 * gb_pipes + 2);
d599 1
a599 1
    switch (gb_pipes) {
d603 3
a605 2
            OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 3) * 4);
            OUT_CS_RELOC(r300->query_current);
d609 3
a611 2
            OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 2) * 4);
            OUT_CS_RELOC(r300->query_current);
d617 3
a619 2
            OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 1) * 4);
            OUT_CS_RELOC(r300->query_current);
d623 3
a625 2
            OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 0) * 4);
            OUT_CS_RELOC(r300->query_current);
d629 1
a629 1
                    " pixel pipes!\n", gb_pipes);
d641 1
d646 2
a647 2
    OUT_CS_REG(R300_ZB_ZPASS_ADDR, query->num_results * 4);
    OUT_CS_RELOC(r300->query_current);
d655 1
d660 2
a661 2
    OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 0) * 4);
    OUT_CS_RELOC(r300->query_current);
d663 2
a664 2
    OUT_CS_REG(R300_ZB_ZPASS_ADDR, (query->num_results + 1) * 4);
    OUT_CS_RELOC(r300->query_current);
d680 2
a681 2
    if (caps->family == CHIP_RV530) {
        if (r300->screen->info.r300_num_z_pipes == 2)
d692 2
a693 2
    if (query->num_results >= query->buf->size / 4 - 4) {
        query->num_results = (query->buf->size / 4) / 2;
a775 12
void r300_emit_sample_mask(struct r300_context *r300,
                           unsigned size, void *state)
{
    unsigned mask = (*(unsigned*)state) & ((1 << 6)-1);
    CS_LOCALS(r300);

    BEGIN_CS(size);
    OUT_CS_REG(R300_SC_SCREENDOOR,
               mask | (mask << 6) | (mask << 12) | (mask << 18));
    END_CS;
}

d803 1
a803 1
    struct r300_resource *tex;
a804 1
    boolean has_us_format = r300->screen->caps.has_us_format;
d813 1
a813 1
            tex = r300_resource(allstate->sampler_views[i]->base.texture);
d824 3
a826 7
            OUT_CS_REG(R300_TX_OFFSET_0 + (i * 4), texstate->format.tile_config);
            OUT_CS_RELOC(tex);

            if (has_us_format) {
                OUT_CS_REG(R500_US_FORMAT0_0 + (i * 4),
                           texstate->format.us_format0);
            }
d832 35
a866 2
void r300_emit_vertex_arrays(struct r300_context* r300, int offset,
                             boolean indexed, int instance_id)
d870 1
a870 1
    struct r300_resource *buf;
d872 2
a873 5
    unsigned vertex_array_count = r300->velems->count;
    unsigned packet_size = (vertex_array_count * 3 + 1) / 2;
    struct pipe_vertex_buffer *vb1, *vb2;
    unsigned *hw_format_size = r300->velems->format_size;
    unsigned size1, size2, offset1, offset2, stride1, stride2;
d876 1
a876 1
    BEGIN_CS(2 + packet_size + vertex_array_count * 2);
d878 1
a878 1
    OUT_CS(vertex_array_count | (!indexed ? R300_VC_FORCE_PREFETCH : 0));
d880 11
a890 3
    if (instance_id == -1) {
        /* Non-instanced arrays. This ignores instance_divisor and instance_id. */
        for (i = 0; i < vertex_array_count - 1; i += 2) {
d902 1
a902 1
        if (vertex_array_count & 1) {
d909 1
d911 3
a913 56
        for (i = 0; i < vertex_array_count; i++) {
            buf = r300_resource(vbuf[velem[i].vertex_buffer_index].buffer);
            OUT_CS_RELOC(buf);
        }
    } else {
        /* Instanced arrays. */
        for (i = 0; i < vertex_array_count - 1; i += 2) {
            vb1 = &vbuf[velem[i].vertex_buffer_index];
            vb2 = &vbuf[velem[i+1].vertex_buffer_index];
            size1 = hw_format_size[i];
            size2 = hw_format_size[i+1];

            if (velem[i].instance_divisor) {
                stride1 = 0;
                offset1 = vb1->buffer_offset + velem[i].src_offset +
                          (instance_id / velem[i].instance_divisor) * vb1->stride;
            } else {
                stride1 = vb1->stride;
                offset1 = vb1->buffer_offset + velem[i].src_offset + offset * vb1->stride;
            }
            if (velem[i+1].instance_divisor) {
                stride2 = 0;
                offset2 = vb2->buffer_offset + velem[i+1].src_offset +
                          (instance_id / velem[i+1].instance_divisor) * vb2->stride;
            } else {
                stride2 = vb2->stride;
                offset2 = vb2->buffer_offset + velem[i+1].src_offset + offset * vb2->stride;
            }

            OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(stride1) |
                   R300_VBPNTR_SIZE1(size2) | R300_VBPNTR_STRIDE1(stride2));
            OUT_CS(offset1);
            OUT_CS(offset2);
        }

        if (vertex_array_count & 1) {
            vb1 = &vbuf[velem[i].vertex_buffer_index];
            size1 = hw_format_size[i];

            if (velem[i].instance_divisor) {
                stride1 = 0;
                offset1 = vb1->buffer_offset + velem[i].src_offset +
                          (instance_id / velem[i].instance_divisor) * vb1->stride;
            } else {
                stride1 = vb1->stride;
                offset1 = vb1->buffer_offset + velem[i].src_offset + offset * vb1->stride;
            }

            OUT_CS(R300_VBPNTR_SIZE0(size1) | R300_VBPNTR_STRIDE0(stride1));
            OUT_CS(offset1);
        }

        for (i = 0; i < vertex_array_count; i++) {
            buf = r300_resource(vbuf[velem[i].vertex_buffer_index].buffer);
            OUT_CS_RELOC(buf);
        }
d918 1
a918 1
void r300_emit_vertex_arrays_swtcl(struct r300_context *r300, boolean indexed)
d938 1
a938 5
    OUT_CS(0);

    assert(r300->vbo_cs);
    cs_winsys->cs_write_reloc(cs_copy, r300->vbo_cs);
    CS_USED_DW(2);
d1027 13
a1039 9
    /* Emit flow control instructions.  Even if there are no fc instructions,
     * we still need to write the registers to make sure they are cleared. */
    OUT_CS_REG(R300_VAP_PVS_FLOW_CNTL_OPC, code->fc_ops);
    if (r300screen->caps.is_r500) {
        OUT_CS_REG_SEQ(R500_VAP_PVS_FLOW_CNTL_ADDRS_LW_0, R300_VS_MAX_FC_OPS * 2);
        OUT_CS_TABLE(code->fc_op_addrs.r500, R300_VS_MAX_FC_OPS * 2);
    } else {
        OUT_CS_REG_SEQ(R300_VAP_PVS_FLOW_CNTL_ADDRS_0, R300_VS_MAX_FC_OPS);
        OUT_CS_TABLE(code->fc_op_addrs.r300, R300_VS_MAX_FC_OPS);
a1040 2
    OUT_CS_REG_SEQ(R300_VAP_PVS_FLOW_CNTL_LOOP_INDEX_0, R300_VS_MAX_FC_OPS);
    OUT_CS_TABLE(code->fc_loop_index, R300_VS_MAX_FC_OPS);
d1105 1
a1105 1
void r300_emit_hiz_clear(struct r300_context *r300, unsigned size, void *state)
a1106 3
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_resource* tex;
d1108 1
a1108 4

    tex = r300_resource(fb->zsbuf->texture);

    BEGIN_CS(size);
d1110 3
a1112 3
    OUT_CS(0);
    OUT_CS(tex->tex.hiz_dwords[fb->zsbuf->u.tex.level]);
    OUT_CS(r300->hiz_clear_value);
d1114 1
d1116 9
a1124 4
    /* Mark the current zbuffer's hiz ram as in use. */
    r300->hiz_in_use = TRUE;
    r300->hiz_func = HIZ_FUNC_NONE;
    r300_mark_atom_dirty(r300, &r300->hyperz_state);
d1127 3
a1129 1
void r300_emit_zmask_clear(struct r300_context *r300, unsigned size, void *state)
d1133 20
a1152 2
    struct r300_resource *tex;
    CS_LOCALS(r300);
d1154 2
a1155 1
    tex = r300_resource(fb->zsbuf->texture);
d1157 6
a1162 6
    BEGIN_CS(size);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_ZMASK, 2);
    OUT_CS(0);
    OUT_CS(tex->tex.zmask_dwords[fb->zsbuf->u.tex.level]);
    OUT_CS(0);
    END_CS;
d1164 2
a1165 3
    /* Mark the current zbuffer's zmask as in use. */
    r300->zmask_in_use = TRUE;
    r300_mark_atom_dirty(r300, &r300->hyperz_state);
d1168 1
a1168 1
void r300_emit_cmask_clear(struct r300_context *r300, unsigned size, void *state)
d1172 15
a1186 2
    struct r300_resource *tex;
    CS_LOCALS(r300);
d1188 1
a1188 1
    tex = r300_resource(fb->cbufs[0]->texture);
d1190 15
a1204 6
    BEGIN_CS(size);
    OUT_CS_PKT3(R300_PACKET3_3D_CLEAR_CMASK, 2);
    OUT_CS(0);
    OUT_CS(tex->tex.cmask_dwords);
    OUT_CS(0);
    END_CS;
d1207 1
a1207 2
    r300->cmask_in_use = TRUE;
    r300_mark_fb_state_dirty(r300, R300_CHANGED_CMASK_ENABLE);
d1234 1
a1234 1
    struct pipe_framebuffer_state *fb =
a1235 1
    struct r300_aa_state *aa = (struct r300_aa_state*)r300->aa_state.state;
d1238 4
a1241 1
    struct r300_resource *tex;
a1242 1
    boolean flushed = FALSE;
d1244 21
a1264 17
validate:
    if (r300->fb_state.dirty) {
        /* Color buffers... */
        for (i = 0; i < fb->nr_cbufs; i++) {
            tex = r300_resource(fb->cbufs[i]->texture);
            assert(tex && tex->buf && "cbuf is marked, but NULL!");
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf,
                                    RADEON_USAGE_READWRITE,
                                    r300_surface(fb->cbufs[i])->domain);
        }
        /* ...depth buffer... */
        if (fb->zsbuf) {
            tex = r300_resource(fb->zsbuf->texture);
            assert(tex && tex->buf && "zsbuf is marked, but NULL!");
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf,
                                    RADEON_USAGE_READWRITE,
                                    r300_surface(fb->zsbuf)->domain);
a1265 15
    }
    /* The AA resolve buffer. */
    if (r300->aa_state.dirty) {
        if (aa->dest) {
            r300->rws->cs_add_reloc(r300->cs, aa->dest->cs_buf,
                                    RADEON_USAGE_WRITE,
                                    aa->dest->domain);
        }
    }
    if (r300->textures_state.dirty) {
        /* ...textures... */
        for (i = 0; i < texstate->count; i++) {
            if (!(texstate->tx_enable & (1 << i))) {
                continue;
            }
d1267 2
a1268 4
            tex = r300_resource(texstate->sampler_views[i]->base.texture);
            r300->rws->cs_add_reloc(r300->cs, tex->cs_buf, RADEON_USAGE_READ,
                                    tex->domain);
        }
d1272 2
a1273 2
        r300->rws->cs_add_reloc(r300->cs, r300->query_current->cs_buf,
                                RADEON_USAGE_WRITE, RADEON_DOMAIN_GTT);
d1275 3
a1277 3
    if (r300->vbo_cs)
        r300->rws->cs_add_reloc(r300->cs, r300->vbo_cs,
                                RADEON_USAGE_READ, RADEON_DOMAIN_GTT);
d1279 4
a1282 9
    if (do_validate_vertex_buffers && r300->vertex_arrays_dirty) {
        struct pipe_vertex_buffer *vbuf = r300->vertex_buffer;
        struct pipe_vertex_buffer *last = r300->vertex_buffer +
                                      r300->nr_vertex_buffers;
        struct pipe_resource *buf;

        for (; vbuf != last; vbuf++) {
            buf = vbuf->buffer;
            if (!buf)
d1285 2
a1286 3
            r300->rws->cs_add_reloc(r300->cs, r300_resource(buf)->cs_buf,
                                    RADEON_USAGE_READ,
                                    r300_resource(buf)->domain);
d1291 2
a1292 3
        r300->rws->cs_add_reloc(r300->cs, r300_resource(index_buffer)->cs_buf,
                                RADEON_USAGE_READ,
                                r300_resource(index_buffer)->domain);
a1293 1
    /* Now do the validation (flush is called inside cs_validate on failure). */
d1295 1
a1295 6
        /* Ooops, an infinite loop, give up. */
        if (flushed)
            return FALSE;

        flushed = TRUE;
        goto validate;
d1325 2
a1326 4
    if (r300->screen->caps.is_r500)
        dwords += 2; /* emit_index_bias */
    if (r300->screen->info.drm_minor >= 6)
        dwords += 3; /* MSPOS */
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a44 1
    struct pipe_surface *cb;
d47 2
a48 4
    cb = fb->nr_cbufs ? r300_get_nonnull_cb(fb, 0) : NULL;

    if (cb) {
        if (cb->format == PIPE_FORMAT_R16G16B16A16_FLOAT) {
d50 1
a50 1
        } else if (cb->format == PIPE_FORMAT_R16G16B16X16_FLOAT) {
d53 1
a53 1
            unsigned swz = r300_surface(cb)->colormask_swizzle;
d91 3
a93 5
        struct pipe_surface *cb = fb->nr_cbufs ? r300_get_nonnull_cb(fb, 0) : NULL;

        if (cb &&
            (cb->format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
             cb->format == PIPE_FORMAT_R16G16B16X16_FLOAT)) {
d422 1
a422 1
        surf = r300_surface(r300_get_nonnull_cb(fb, i));
d603 1
a603 1
        OUT_CS(r300_surface(r300_get_nonnull_cb(fb, i))->format);
d1046 2
a1047 2
    OUT_CS(0xc0001000); /* PKT3_NOP */
    OUT_CS(r300->rws->cs_get_reloc(r300->cs, r300->vbo_cs) * 4);
a1312 2
            if (!fb->cbufs[i])
                continue;
d1317 1
a1317 4
                                    r300_surface(fb->cbufs[i])->domain,
                                    tex->b.b.nr_samples > 1 ?
                                    RADEON_PRIO_COLOR_BUFFER_MSAA :
                                    RADEON_PRIO_COLOR_BUFFER);
d1325 1
a1325 4
                                    r300_surface(fb->zsbuf)->domain,
                                    tex->b.b.nr_samples > 1 ?
                                    RADEON_PRIO_DEPTH_BUFFER_MSAA :
                                    RADEON_PRIO_DEPTH_BUFFER);
d1333 1
a1333 2
                                    aa->dest->domain,
                                    RADEON_PRIO_COLOR_BUFFER);
d1345 1
a1345 1
                                    tex->domain, RADEON_PRIO_SHADER_TEXTURE_RO);
d1351 1
a1351 2
                                RADEON_USAGE_WRITE, RADEON_DOMAIN_GTT,
                                RADEON_PRIO_MIN);
d1355 1
a1355 2
                                RADEON_USAGE_READ, RADEON_DOMAIN_GTT,
                                RADEON_PRIO_MIN);
d1370 1
a1370 2
                                    r300_resource(buf)->domain,
                                    RADEON_PRIO_SHADER_BUFFER_RO);
d1377 1
a1377 2
                                r300_resource(index_buffer)->domain,
                                RADEON_PRIO_MIN);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a1138 1
            (r300->clip_halfz ? R300_DX_CLIP_SPACE_DEF : 0) |
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d1139 1
@


