head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.07.29.05.47.25;	author mpi;	state Exp;
branches;
next	1.7;
commitid	7LgDWgovbCk9WPgF;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.58;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.03;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.07;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.05;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.45.15;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2010 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

/* Always include headers in the reverse order!! ~ M. */
#include "r300_texture.h"

#include "r300_context.h"
#include "r300_reg.h"
#include "r300_texture_desc.h"
#include "r300_transfer.h"
#include "r300_screen.h"

#include "util/u_format.h"
#include "util/u_format_s3tc.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_mm.h"

#include "pipe/p_screen.h"

unsigned r300_get_swizzle_combined(const unsigned char *swizzle_format,
                                   const unsigned char *swizzle_view,
                                   boolean dxtc_swizzle)
{
    unsigned i;
    unsigned char swizzle[4];
    unsigned result = 0;
    const uint32_t swizzle_shift[4] = {
        R300_TX_FORMAT_R_SHIFT,
        R300_TX_FORMAT_G_SHIFT,
        R300_TX_FORMAT_B_SHIFT,
        R300_TX_FORMAT_A_SHIFT
    };
    uint32_t swizzle_bit[4] = {
        dxtc_swizzle ? R300_TX_FORMAT_Z : R300_TX_FORMAT_X,
        R300_TX_FORMAT_Y,
        dxtc_swizzle ? R300_TX_FORMAT_X : R300_TX_FORMAT_Z,
        R300_TX_FORMAT_W
    };

    if (swizzle_view) {
        /* Combine two sets of swizzles. */
        util_format_compose_swizzles(swizzle_format, swizzle_view, swizzle);
    } else {
        memcpy(swizzle, swizzle_format, 4);
    }

    /* Get swizzle. */
    for (i = 0; i < 4; i++) {
        switch (swizzle[i]) {
            case UTIL_FORMAT_SWIZZLE_Y:
                result |= swizzle_bit[1] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_Z:
                result |= swizzle_bit[2] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_W:
                result |= swizzle_bit[3] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_0:
                result |= R300_TX_FORMAT_ZERO << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_1:
                result |= R300_TX_FORMAT_ONE << swizzle_shift[i];
                break;
            default: /* UTIL_FORMAT_SWIZZLE_X */
                result |= swizzle_bit[0] << swizzle_shift[i];
        }
    }
    return result;
}


enum pipe_format r300_get_hw_format(enum pipe_format api_format,
                                    unsigned bind)
{
    if (bind & (PIPE_BIND_RENDER_TARGET | PIPE_BIND_SCANOUT | PIPE_BIND_SHARED) &&
        !(bind & (PIPE_BIND_TRANSFER_READ | PIPE_BIND_TRANSFER_WRITE))) {
        switch (api_format) {
        case PIPE_FORMAT_A8R8G8B8_UNORM:
           return PIPE_FORMAT_B8G8R8A8_UNORM;
        case PIPE_FORMAT_X8R8G8B8_UNORM:
           return PIPE_FORMAT_B8G8R8X8_UNORM;
        default:
           break;
        }
    }

    return api_format;
}

/* Translate a pipe_format into a useful texture format for sampling.
 *
 * Some special formats are translated directly using R300_EASY_TX_FORMAT,
 * but the majority of them is translated in a generic way, automatically
 * supporting all the formats hw can support.
 *
 * R300_EASY_TX_FORMAT swizzles the texture.
 * Note the signature of R300_EASY_TX_FORMAT:
 *   R300_EASY_TX_FORMAT(B, G, R, A, FORMAT);
 *
 * The FORMAT specifies how the texture sampler will treat the texture, and
 * makes available X, Y, Z, W, ZERO, and ONE for swizzling. */
uint32_t r300_translate_texformat(enum pipe_format format,
                                  const unsigned char *swizzle_view,
                                  boolean is_r500,
                                  boolean dxtc_swizzle)
{
    uint32_t result = 0;
    const struct util_format_description *desc;
    unsigned i;
    boolean uniform = TRUE;
    const uint32_t sign_bit[4] = {
        R300_TX_FORMAT_SIGNED_W,
        R300_TX_FORMAT_SIGNED_Z,
        R300_TX_FORMAT_SIGNED_Y,
        R300_TX_FORMAT_SIGNED_X,
    };

    desc = util_format_description(format);

    /* Colorspace (return non-RGB formats directly). */
    switch (desc->colorspace) {
        /* Depth stencil formats.
         * Swizzles are added in r300_merge_textures_and_samplers. */
        case UTIL_FORMAT_COLORSPACE_ZS:
            switch (format) {
                case PIPE_FORMAT_Z16_UNORM:
                    return R300_TX_FORMAT_X16;
                case PIPE_FORMAT_X8Z24_UNORM:
                case PIPE_FORMAT_S8_UINT_Z24_UNORM:
                    if (is_r500)
                        return R500_TX_FORMAT_Y8X24;
                    else
                        return R300_TX_FORMAT_Y16X16;
                default:
                    return ~0; /* Unsupported. */
            }

        /* YUV formats. */
        case UTIL_FORMAT_COLORSPACE_YUV:
            result |= R300_TX_FORMAT_YUV_TO_RGB;

            switch (format) {
                case PIPE_FORMAT_UYVY:
                    return R300_EASY_TX_FORMAT(X, Y, Z, ONE, YVYU422) | result;
                case PIPE_FORMAT_YUYV:
                    return R300_EASY_TX_FORMAT(X, Y, Z, ONE, VYUY422) | result;
                default:
                    return ~0; /* Unsupported/unknown. */
            }

        /* Add gamma correction. */
        case UTIL_FORMAT_COLORSPACE_SRGB:
            result |= R300_TX_FORMAT_GAMMA;
            break;

        default:
            switch (format) {
                /* Same as YUV but without the YUR->RGB conversion. */
                case PIPE_FORMAT_R8G8_B8G8_UNORM:
                    return R300_EASY_TX_FORMAT(X, Y, Z, ONE, YVYU422) | result;
                case PIPE_FORMAT_G8R8_G8B8_UNORM:
                    return R300_EASY_TX_FORMAT(X, Y, Z, ONE, VYUY422) | result;
                default:;
            }
    }

    /* Add swizzling. */
    /* The RGTC1_SNORM and LATC1_SNORM swizzle is done in the shader. */
    if (format != PIPE_FORMAT_RGTC1_SNORM &&
        format != PIPE_FORMAT_LATC1_SNORM) {
        if (util_format_is_compressed(format) &&
            dxtc_swizzle &&
            format != PIPE_FORMAT_RGTC2_UNORM &&
            format != PIPE_FORMAT_RGTC2_SNORM &&
            format != PIPE_FORMAT_LATC2_UNORM &&
            format != PIPE_FORMAT_LATC2_SNORM) {
            result |= r300_get_swizzle_combined(desc->swizzle, swizzle_view,
                                                TRUE);
        } else {
            result |= r300_get_swizzle_combined(desc->swizzle, swizzle_view,
                                                FALSE);
        }
    }

    /* S3TC formats. */
    if (desc->layout == UTIL_FORMAT_LAYOUT_S3TC) {
        if (!util_format_s3tc_enabled) {
            return ~0; /* Unsupported. */
        }

        switch (format) {
            case PIPE_FORMAT_DXT1_RGB:
            case PIPE_FORMAT_DXT1_RGBA:
            case PIPE_FORMAT_DXT1_SRGB:
            case PIPE_FORMAT_DXT1_SRGBA:
                return R300_TX_FORMAT_DXT1 | result;
            case PIPE_FORMAT_DXT3_RGBA:
            case PIPE_FORMAT_DXT3_SRGBA:
                return R300_TX_FORMAT_DXT3 | result;
            case PIPE_FORMAT_DXT5_RGBA:
            case PIPE_FORMAT_DXT5_SRGBA:
                return R300_TX_FORMAT_DXT5 | result;
            default:
                return ~0; /* Unsupported/unknown. */
        }
    }

    /* RGTC formats. */
    if (desc->layout == UTIL_FORMAT_LAYOUT_RGTC) {
        switch (format) {
            case PIPE_FORMAT_RGTC1_SNORM:
            case PIPE_FORMAT_LATC1_SNORM:
            case PIPE_FORMAT_LATC1_UNORM:
            case PIPE_FORMAT_RGTC1_UNORM:
                return R500_TX_FORMAT_ATI1N | result;

            case PIPE_FORMAT_RGTC2_SNORM:
            case PIPE_FORMAT_LATC2_SNORM:
                result |= sign_bit[1] | sign_bit[0];
            case PIPE_FORMAT_RGTC2_UNORM:
            case PIPE_FORMAT_LATC2_UNORM:
                return R400_TX_FORMAT_ATI2N | result;

            default:
                return ~0; /* Unsupported/unknown. */
        }
    }

    /* This is truly a special format.
     * It stores R8G8 and B is computed using sqrt(1 - R^2 - G^2)
     * in the sampler unit. Also known as D3DFMT_CxV8U8. */
    if (format == PIPE_FORMAT_R8G8Bx_SNORM) {
        return R300_TX_FORMAT_CxV8U8 | result;
    }

    /* Integer and fixed-point 16.16 textures are not supported. */
    for (i = 0; i < 4; i++) {
        if (desc->channel[i].type == UTIL_FORMAT_TYPE_FIXED ||
            ((desc->channel[i].type == UTIL_FORMAT_TYPE_SIGNED ||
              desc->channel[i].type == UTIL_FORMAT_TYPE_UNSIGNED) &&
             (!desc->channel[i].normalized ||
              desc->channel[i].pure_integer))) {
            return ~0; /* Unsupported/unknown. */
        }
    }

    /* Add sign. */
    for (i = 0; i < desc->nr_channels; i++) {
        if (desc->channel[i].type == UTIL_FORMAT_TYPE_SIGNED) {
            result |= sign_bit[i];
        }
    }

    /* See whether the components are of the same size. */
    for (i = 1; i < desc->nr_channels; i++) {
        uniform = uniform && desc->channel[0].size == desc->channel[i].size;
    }

    /* Non-uniform formats. */
    if (!uniform) {
        switch (desc->nr_channels) {
            case 3:
                if (desc->channel[0].size == 5 &&
                    desc->channel[1].size == 6 &&
                    desc->channel[2].size == 5) {
                    return R300_TX_FORMAT_Z5Y6X5 | result;
                }
                if (desc->channel[0].size == 5 &&
                    desc->channel[1].size == 5 &&
                    desc->channel[2].size == 6) {
                    return R300_TX_FORMAT_Z6Y5X5 | result;
                }
                if (desc->channel[0].size == 2 &&
                    desc->channel[1].size == 3 &&
                    desc->channel[2].size == 3) {
                    return R300_TX_FORMAT_Z3Y3X2 | result;
                }
                return ~0; /* Unsupported/unknown. */

            case 4:
                if (desc->channel[0].size == 5 &&
                    desc->channel[1].size == 5 &&
                    desc->channel[2].size == 5 &&
                    desc->channel[3].size == 1) {
                    return R300_TX_FORMAT_W1Z5Y5X5 | result;
                }
                if (desc->channel[0].size == 10 &&
                    desc->channel[1].size == 10 &&
                    desc->channel[2].size == 10 &&
                    desc->channel[3].size == 2) {
                    return R300_TX_FORMAT_W2Z10Y10X10 | result;
                }
        }
        return ~0; /* Unsupported/unknown. */
    }

    /* Find the first non-VOID channel. */
    for (i = 0; i < 4; i++) {
        if (desc->channel[i].type != UTIL_FORMAT_TYPE_VOID) {
            break;
        }
    }

    if (i == 4)
        return ~0; /* Unsupported/unknown. */

    /* And finally, uniform formats. */
    switch (desc->channel[i].type) {
        case UTIL_FORMAT_TYPE_UNSIGNED:
        case UTIL_FORMAT_TYPE_SIGNED:
            if (!desc->channel[i].normalized &&
                desc->colorspace != UTIL_FORMAT_COLORSPACE_SRGB) {
                return ~0;
            }

            switch (desc->channel[i].size) {
                case 4:
                    switch (desc->nr_channels) {
                        case 2:
                            return R300_TX_FORMAT_Y4X4 | result;
                        case 4:
                            return R300_TX_FORMAT_W4Z4Y4X4 | result;
                    }
                    return ~0;

                case 8:
                    switch (desc->nr_channels) {
                        case 1:
                            return R300_TX_FORMAT_X8 | result;
                        case 2:
                            return R300_TX_FORMAT_Y8X8 | result;
                        case 4:
                            return R300_TX_FORMAT_W8Z8Y8X8 | result;
                    }
                    return ~0;

                case 16:
                    switch (desc->nr_channels) {
                        case 1:
                            return R300_TX_FORMAT_X16 | result;
                        case 2:
                            return R300_TX_FORMAT_Y16X16 | result;
                        case 4:
                            return R300_TX_FORMAT_W16Z16Y16X16 | result;
                    }
            }
            return ~0;

        case UTIL_FORMAT_TYPE_FLOAT:
            switch (desc->channel[i].size) {
                case 16:
                    switch (desc->nr_channels) {
                        case 1:
                            return R300_TX_FORMAT_16F | result;
                        case 2:
                            return R300_TX_FORMAT_16F_16F | result;
                        case 4:
                            return R300_TX_FORMAT_16F_16F_16F_16F | result;
                    }
                    return ~0;

                case 32:
                    switch (desc->nr_channels) {
                        case 1:
                            return R300_TX_FORMAT_32F | result;
                        case 2:
                            return R300_TX_FORMAT_32F_32F | result;
                        case 4:
                            return R300_TX_FORMAT_32F_32F_32F_32F | result;
                    }
            }
    }

    return ~0; /* Unsupported/unknown. */
}

uint32_t r500_tx_format_msb_bit(enum pipe_format format)
{
    switch (format) {
        case PIPE_FORMAT_RGTC1_UNORM:
        case PIPE_FORMAT_RGTC1_SNORM:
        case PIPE_FORMAT_LATC1_UNORM:
        case PIPE_FORMAT_LATC1_SNORM:
        case PIPE_FORMAT_X8Z24_UNORM:
        case PIPE_FORMAT_S8_UINT_Z24_UNORM:
            return R500_TXFORMAT_MSB;
        default:
            return 0;
    }
}

/* Buffer formats. */

/* Colorbuffer formats. This is the unswizzled format of the RB3D block's
 * output. For the swizzling of the targets, check the shader's format. */
static uint32_t r300_translate_colorformat(enum pipe_format format)
{
    switch (format) {
        /* 8-bit buffers. */
        case PIPE_FORMAT_A8_UNORM:
        case PIPE_FORMAT_A8_SNORM:
        case PIPE_FORMAT_I8_UNORM:
        case PIPE_FORMAT_I8_SNORM:
        case PIPE_FORMAT_L8_UNORM:
        case PIPE_FORMAT_L8_SNORM:
        case PIPE_FORMAT_R8_UNORM:
        case PIPE_FORMAT_R8_SNORM:
            return R300_COLOR_FORMAT_I8;

        /* 16-bit buffers. */
        case PIPE_FORMAT_L8A8_UNORM:
        case PIPE_FORMAT_L8A8_SNORM:
        case PIPE_FORMAT_R8G8_UNORM:
        case PIPE_FORMAT_R8G8_SNORM:
        case PIPE_FORMAT_R8A8_UNORM:
        case PIPE_FORMAT_R8A8_SNORM:
        /* These formats work fine with UV88 if US_OUT_FMT is set correctly. */
        case PIPE_FORMAT_A16_UNORM:
        case PIPE_FORMAT_A16_SNORM:
        case PIPE_FORMAT_A16_FLOAT:
        case PIPE_FORMAT_L16_UNORM:
        case PIPE_FORMAT_L16_SNORM:
        case PIPE_FORMAT_L16_FLOAT:
        case PIPE_FORMAT_I16_UNORM:
        case PIPE_FORMAT_I16_SNORM:
        case PIPE_FORMAT_I16_FLOAT:
        case PIPE_FORMAT_R16_UNORM:
        case PIPE_FORMAT_R16_SNORM:
        case PIPE_FORMAT_R16_FLOAT:
            return R300_COLOR_FORMAT_UV88;

        case PIPE_FORMAT_B5G6R5_UNORM:
            return R300_COLOR_FORMAT_RGB565;

        case PIPE_FORMAT_B5G5R5A1_UNORM:
        case PIPE_FORMAT_B5G5R5X1_UNORM:
            return R300_COLOR_FORMAT_ARGB1555;

        case PIPE_FORMAT_B4G4R4A4_UNORM:
        case PIPE_FORMAT_B4G4R4X4_UNORM:
            return R300_COLOR_FORMAT_ARGB4444;

        /* 32-bit buffers. */
        case PIPE_FORMAT_A8R8G8B8_UNORM:
        /*case PIPE_FORMAT_A8R8G8B8_SNORM:*/
        case PIPE_FORMAT_B8G8R8A8_UNORM:
        /*case PIPE_FORMAT_B8G8R8A8_SNORM:*/
        case PIPE_FORMAT_B8G8R8X8_UNORM:
        /*case PIPE_FORMAT_B8G8R8X8_SNORM:*/
        case PIPE_FORMAT_X8R8G8B8_UNORM:
        /*case PIPE_FORMAT_X8R8G8B8_SNORM:*/
        case PIPE_FORMAT_R8G8B8A8_UNORM:
        case PIPE_FORMAT_R8G8B8A8_SNORM:
        case PIPE_FORMAT_R8G8B8X8_UNORM:
        case PIPE_FORMAT_R8G8B8X8_SNORM:
        /* These formats work fine with ARGB8888 if US_OUT_FMT is set
         * correctly. */
        case PIPE_FORMAT_R16G16_UNORM:
        case PIPE_FORMAT_R16G16_SNORM:
        case PIPE_FORMAT_R16G16_FLOAT:
        case PIPE_FORMAT_L16A16_UNORM:
        case PIPE_FORMAT_L16A16_SNORM:
        case PIPE_FORMAT_L16A16_FLOAT:
        case PIPE_FORMAT_R16A16_UNORM:
        case PIPE_FORMAT_R16A16_SNORM:
        case PIPE_FORMAT_R16A16_FLOAT:
        case PIPE_FORMAT_A32_FLOAT:
        case PIPE_FORMAT_L32_FLOAT:
        case PIPE_FORMAT_I32_FLOAT:
        case PIPE_FORMAT_R32_FLOAT:
            return R300_COLOR_FORMAT_ARGB8888;

        case PIPE_FORMAT_R10G10B10A2_UNORM:
        case PIPE_FORMAT_R10G10B10X2_SNORM:
        case PIPE_FORMAT_B10G10R10A2_UNORM:
        case PIPE_FORMAT_B10G10R10X2_UNORM:
            return R500_COLOR_FORMAT_ARGB2101010;  /* R5xx-only? */

        /* 64-bit buffers. */
        case PIPE_FORMAT_R16G16B16A16_UNORM:
        case PIPE_FORMAT_R16G16B16A16_SNORM:
        case PIPE_FORMAT_R16G16B16A16_FLOAT:
        case PIPE_FORMAT_R16G16B16X16_UNORM:
        case PIPE_FORMAT_R16G16B16X16_SNORM:
        case PIPE_FORMAT_R16G16B16X16_FLOAT:
        /* These formats work fine with ARGB16161616 if US_OUT_FMT is set
         * correctly. */
        case PIPE_FORMAT_R32G32_FLOAT:
        case PIPE_FORMAT_L32A32_FLOAT:
        case PIPE_FORMAT_R32A32_FLOAT:
            return R300_COLOR_FORMAT_ARGB16161616;

        /* 128-bit buffers. */
        case PIPE_FORMAT_R32G32B32A32_FLOAT:
        case PIPE_FORMAT_R32G32B32X32_FLOAT:
            return R300_COLOR_FORMAT_ARGB32323232;

        /* YUV buffers. */
        case PIPE_FORMAT_UYVY:
            return R300_COLOR_FORMAT_YVYU;
        case PIPE_FORMAT_YUYV:
            return R300_COLOR_FORMAT_VYUY;
        default:
            return ~0; /* Unsupported. */
    }
}

/* Depthbuffer and stencilbuffer. Thankfully, we only support two flavors. */
static uint32_t r300_translate_zsformat(enum pipe_format format)
{
    switch (format) {
        /* 16-bit depth, no stencil */
        case PIPE_FORMAT_Z16_UNORM:
            return R300_DEPTHFORMAT_16BIT_INT_Z;
        /* 24-bit depth, ignored stencil */
        case PIPE_FORMAT_X8Z24_UNORM:
        /* 24-bit depth, 8-bit stencil */
        case PIPE_FORMAT_S8_UINT_Z24_UNORM:
            return R300_DEPTHFORMAT_24BIT_INT_Z_8BIT_STENCIL;
        default:
            return ~0; /* Unsupported. */
    }
}

/* Shader output formats. This is essentially the swizzle from the shader
 * to the RB3D block.
 *
 * Note that formats are stored from C3 to C0. */
static uint32_t r300_translate_out_fmt(enum pipe_format format)
{
    uint32_t modifier = 0;
    unsigned i;
    const struct util_format_description *desc;
    boolean uniform_sign;

    desc = util_format_description(format);

    /* Find the first non-VOID channel. */
    for (i = 0; i < 4; i++) {
        if (desc->channel[i].type != UTIL_FORMAT_TYPE_VOID) {
            break;
        }
    }

    if (i == 4)
        return ~0; /* Unsupported/unknown. */

    /* Specifies how the shader output is written to the fog unit. */
    switch (desc->channel[i].type) {
    case UTIL_FORMAT_TYPE_FLOAT:
        switch (desc->channel[i].size) {
        case 32:
            switch (desc->nr_channels) {
            case 1:
                modifier |= R300_US_OUT_FMT_C_32_FP;
                break;
            case 2:
                modifier |= R300_US_OUT_FMT_C2_32_FP;
                break;
            case 4:
                modifier |= R300_US_OUT_FMT_C4_32_FP;
                break;
            }
            break;

        case 16:
            switch (desc->nr_channels) {
            case 1:
                modifier |= R300_US_OUT_FMT_C_16_FP;
                break;
            case 2:
                modifier |= R300_US_OUT_FMT_C2_16_FP;
                break;
            case 4:
                modifier |= R300_US_OUT_FMT_C4_16_FP;
                break;
            }
            break;
        }
        break;

    default:
        switch (desc->channel[i].size) {
        case 16:
            switch (desc->nr_channels) {
            case 1:
                modifier |= R300_US_OUT_FMT_C_16;
                break;
            case 2:
                modifier |= R300_US_OUT_FMT_C2_16;
                break;
            case 4:
                modifier |= R300_US_OUT_FMT_C4_16;
                break;
            }
            break;

        case 10:
            modifier |= R300_US_OUT_FMT_C4_10;
            break;

        default:
            /* C4_8 seems to be used for the formats whose pixel size
             * is <= 32 bits. */
            modifier |= R300_US_OUT_FMT_C4_8;
            break;
        }
    }

    /* Add sign. */
    uniform_sign = TRUE;
    for (i = 0; i < desc->nr_channels; i++)
        if (desc->channel[i].type != UTIL_FORMAT_TYPE_SIGNED)
            uniform_sign = FALSE;

    if (uniform_sign)
        modifier |= R300_OUT_SIGN(0xf);

    /* Add swizzles and return. */
    switch (format) {
        /*** Special cases (non-standard channel mapping) ***/

        /* X8
         * COLORFORMAT_I8 stores the Z component (C2). */
        case PIPE_FORMAT_A8_UNORM:
        case PIPE_FORMAT_A8_SNORM:
            return modifier | R300_C2_SEL_A;
        case PIPE_FORMAT_I8_UNORM:
        case PIPE_FORMAT_I8_SNORM:
        case PIPE_FORMAT_L8_UNORM:
        case PIPE_FORMAT_L8_SNORM:
        case PIPE_FORMAT_R8_UNORM:
        case PIPE_FORMAT_R8_SNORM:
            return modifier | R300_C2_SEL_R;

        /* X8Y8
         * COLORFORMAT_UV88 stores ZX (C2 and C0). */
        case PIPE_FORMAT_L8A8_SNORM:
        case PIPE_FORMAT_L8A8_UNORM:
        case PIPE_FORMAT_R8A8_SNORM:
        case PIPE_FORMAT_R8A8_UNORM:
            return modifier | R300_C0_SEL_A | R300_C2_SEL_R;
        case PIPE_FORMAT_R8G8_SNORM:
        case PIPE_FORMAT_R8G8_UNORM:
            return modifier | R300_C0_SEL_G | R300_C2_SEL_R;

        /* X32Y32
         * ARGB16161616 stores XZ for RG32F */
        case PIPE_FORMAT_R32G32_FLOAT:
            return modifier | R300_C0_SEL_R | R300_C2_SEL_G;

        /*** Generic cases (standard channel mapping) ***/

        /* BGRA outputs. */
        case PIPE_FORMAT_B5G6R5_UNORM:
        case PIPE_FORMAT_B5G5R5A1_UNORM:
        case PIPE_FORMAT_B5G5R5X1_UNORM:
        case PIPE_FORMAT_B4G4R4A4_UNORM:
        case PIPE_FORMAT_B4G4R4X4_UNORM:
        case PIPE_FORMAT_B8G8R8A8_UNORM:
        /*case PIPE_FORMAT_B8G8R8A8_SNORM:*/
        case PIPE_FORMAT_B8G8R8X8_UNORM:
        /*case PIPE_FORMAT_B8G8R8X8_SNORM:*/
        case PIPE_FORMAT_B10G10R10A2_UNORM:
        case PIPE_FORMAT_B10G10R10X2_UNORM:
            return modifier |
                R300_C0_SEL_B | R300_C1_SEL_G |
                R300_C2_SEL_R | R300_C3_SEL_A;

        /* ARGB outputs. */
        case PIPE_FORMAT_X8R8G8B8_UNORM:
        /*case PIPE_FORMAT_X8R8G8B8_SNORM:*/
        case PIPE_FORMAT_A8R8G8B8_UNORM:
        /*case PIPE_FORMAT_A8R8G8B8_SNORM:*/
        case PIPE_FORMAT_A16_UNORM:
        case PIPE_FORMAT_A16_SNORM:
        case PIPE_FORMAT_A16_FLOAT:
        case PIPE_FORMAT_A32_FLOAT:
            return modifier |
                R300_C0_SEL_A | R300_C1_SEL_R |
                R300_C2_SEL_G | R300_C3_SEL_B;

        /* RGBA outputs. */
        case PIPE_FORMAT_R8G8B8X8_UNORM:
        case PIPE_FORMAT_R8G8B8X8_SNORM:
        case PIPE_FORMAT_R8G8B8A8_UNORM:
        case PIPE_FORMAT_R8G8B8A8_SNORM:
        case PIPE_FORMAT_R10G10B10A2_UNORM:
        case PIPE_FORMAT_R10G10B10X2_SNORM:
        case PIPE_FORMAT_R16_UNORM:
        case PIPE_FORMAT_R16G16_UNORM:
        case PIPE_FORMAT_R16G16B16A16_UNORM:
        case PIPE_FORMAT_R16_SNORM:
        case PIPE_FORMAT_R16G16_SNORM:
        case PIPE_FORMAT_R16G16B16A16_SNORM:
        case PIPE_FORMAT_R16_FLOAT:
        case PIPE_FORMAT_R16G16_FLOAT:
        case PIPE_FORMAT_R16G16B16A16_FLOAT:
        case PIPE_FORMAT_R32_FLOAT:
        case PIPE_FORMAT_R32G32B32A32_FLOAT:
        case PIPE_FORMAT_R32G32B32X32_FLOAT:
        case PIPE_FORMAT_L16_UNORM:
        case PIPE_FORMAT_L16_SNORM:
        case PIPE_FORMAT_L16_FLOAT:
        case PIPE_FORMAT_L32_FLOAT:
        case PIPE_FORMAT_I16_UNORM:
        case PIPE_FORMAT_I16_SNORM:
        case PIPE_FORMAT_I16_FLOAT:
        case PIPE_FORMAT_I32_FLOAT:
        case PIPE_FORMAT_R16G16B16X16_UNORM:
        case PIPE_FORMAT_R16G16B16X16_SNORM:
        case PIPE_FORMAT_R16G16B16X16_FLOAT:
            return modifier |
                R300_C0_SEL_R | R300_C1_SEL_G |
                R300_C2_SEL_B | R300_C3_SEL_A;

        /* LA outputs. */
        case PIPE_FORMAT_L16A16_UNORM:
        case PIPE_FORMAT_L16A16_SNORM:
        case PIPE_FORMAT_L16A16_FLOAT:
        case PIPE_FORMAT_R16A16_UNORM:
        case PIPE_FORMAT_R16A16_SNORM:
        case PIPE_FORMAT_R16A16_FLOAT:
        case PIPE_FORMAT_L32A32_FLOAT:
        case PIPE_FORMAT_R32A32_FLOAT:
            return modifier |
                R300_C0_SEL_R | R300_C1_SEL_A;

        default:
            return ~0; /* Unsupported. */
    }
}

static uint32_t r300_translate_colormask_swizzle(enum pipe_format format)
{
    switch (format) {
    case PIPE_FORMAT_A8_UNORM:
    case PIPE_FORMAT_A8_SNORM:
    case PIPE_FORMAT_A16_UNORM:
    case PIPE_FORMAT_A16_SNORM:
    case PIPE_FORMAT_A16_FLOAT:
    case PIPE_FORMAT_A32_FLOAT:
        return COLORMASK_AAAA;

    case PIPE_FORMAT_I8_UNORM:
    case PIPE_FORMAT_I8_SNORM:
    case PIPE_FORMAT_L8_UNORM:
    case PIPE_FORMAT_L8_SNORM:
    case PIPE_FORMAT_R8_UNORM:
    case PIPE_FORMAT_R8_SNORM:
    case PIPE_FORMAT_R32_FLOAT:
    case PIPE_FORMAT_L32_FLOAT:
    case PIPE_FORMAT_I32_FLOAT:
        return COLORMASK_RRRR;

    case PIPE_FORMAT_L8A8_SNORM:
    case PIPE_FORMAT_L8A8_UNORM:
    case PIPE_FORMAT_R8A8_UNORM:
    case PIPE_FORMAT_R8A8_SNORM:
    case PIPE_FORMAT_L16A16_UNORM:
    case PIPE_FORMAT_L16A16_SNORM:
    case PIPE_FORMAT_L16A16_FLOAT:
    case PIPE_FORMAT_R16A16_UNORM:
    case PIPE_FORMAT_R16A16_SNORM:
    case PIPE_FORMAT_R16A16_FLOAT:
    case PIPE_FORMAT_L32A32_FLOAT:
    case PIPE_FORMAT_R32A32_FLOAT:
        return COLORMASK_ARRA;

    case PIPE_FORMAT_R8G8_SNORM:
    case PIPE_FORMAT_R8G8_UNORM:
    case PIPE_FORMAT_R16G16_UNORM:
    case PIPE_FORMAT_R16G16_SNORM:
    case PIPE_FORMAT_R16G16_FLOAT:
    case PIPE_FORMAT_R32G32_FLOAT:
        return COLORMASK_GRRG;

    case PIPE_FORMAT_A8R8G8B8_UNORM:
    /*case PIPE_FORMAT_A8R8G8B8_SNORM:*/
        return COLORMASK_ARGB;

    case PIPE_FORMAT_X8R8G8B8_UNORM:
    /*case PIPE_FORMAT_X8R8G8B8_SNORM:*/
        return COLORMASK_XRGB;

    case PIPE_FORMAT_B5G5R5X1_UNORM:
    case PIPE_FORMAT_B4G4R4X4_UNORM:
    case PIPE_FORMAT_B8G8R8X8_UNORM:
    /*case PIPE_FORMAT_B8G8R8X8_SNORM:*/
    case PIPE_FORMAT_B10G10R10X2_UNORM:
        return COLORMASK_BGRX;

    case PIPE_FORMAT_B5G6R5_UNORM:
    case PIPE_FORMAT_B5G5R5A1_UNORM:
    case PIPE_FORMAT_B4G4R4A4_UNORM:
    case PIPE_FORMAT_B8G8R8A8_UNORM:
    /*case PIPE_FORMAT_B8G8R8A8_SNORM:*/
    case PIPE_FORMAT_B10G10R10A2_UNORM:
        return COLORMASK_BGRA;

    case PIPE_FORMAT_R8G8B8X8_UNORM:
    /* RGBX_SNORM formats are broken for an unknown reason */
    /*case PIPE_FORMAT_R8G8B8X8_SNORM:*/
    /*case PIPE_FORMAT_R10G10B10X2_SNORM:*/
    case PIPE_FORMAT_R16G16B16X16_UNORM:
    /*case PIPE_FORMAT_R16G16B16X16_SNORM:*/
    case PIPE_FORMAT_R16G16B16X16_FLOAT:
    case PIPE_FORMAT_R32G32B32X32_FLOAT:
        return COLORMASK_RGBX;

    case PIPE_FORMAT_R8G8B8A8_UNORM:
    case PIPE_FORMAT_R8G8B8A8_SNORM:
    case PIPE_FORMAT_R10G10B10A2_UNORM:
    case PIPE_FORMAT_R16_UNORM:
    case PIPE_FORMAT_R16G16B16A16_UNORM:
    case PIPE_FORMAT_R16_SNORM:
    case PIPE_FORMAT_R16G16B16A16_SNORM:
    case PIPE_FORMAT_R16_FLOAT:
    case PIPE_FORMAT_R16G16B16A16_FLOAT:
    case PIPE_FORMAT_R32G32B32A32_FLOAT:
    case PIPE_FORMAT_L16_UNORM:
    case PIPE_FORMAT_L16_SNORM:
    case PIPE_FORMAT_L16_FLOAT:
    case PIPE_FORMAT_I16_UNORM:
    case PIPE_FORMAT_I16_SNORM:
    case PIPE_FORMAT_I16_FLOAT:
        return COLORMASK_RGBA;

    default:
        return ~0; /* Unsupported. */
    }
}

boolean r300_is_colorbuffer_format_supported(enum pipe_format format)
{
    return r300_translate_colorformat(format) != ~0 &&
           r300_translate_out_fmt(format) != ~0 &&
           r300_translate_colormask_swizzle(format) != ~0;
}

boolean r300_is_zs_format_supported(enum pipe_format format)
{
    return r300_translate_zsformat(format) != ~0;
}

boolean r300_is_sampler_format_supported(enum pipe_format format)
{
    return r300_translate_texformat(format, 0, TRUE, FALSE) != ~0;
}

void r300_texture_setup_format_state(struct r300_screen *screen,
                                     struct r300_resource *tex,
                                     enum pipe_format format,
                                     unsigned level,
                                     unsigned width0_override,
                                     unsigned height0_override,
                                     struct r300_texture_format_state *out)
{
    struct pipe_resource *pt = &tex->b.b;
    struct r300_texture_desc *desc = &tex->tex;
    boolean is_r500 = screen->caps.is_r500;
    unsigned width, height, depth;
    unsigned txwidth, txheight, txdepth;

    width = u_minify(width0_override, level);
    height = u_minify(height0_override, level);
    depth = u_minify(desc->depth0, level);

    txwidth = (width - 1) & 0x7ff;
    txheight = (height - 1) & 0x7ff;
    txdepth = util_logbase2(depth) & 0xf;

    /* Mask out all the fields we change. */
    out->format0 = 0;
    out->format1 &= ~R300_TX_FORMAT_TEX_COORD_TYPE_MASK;
    out->format2 &= R500_TXFORMAT_MSB;
    out->tile_config = 0;

    /* Set sampler state. */
    out->format0 =
        R300_TX_WIDTH(txwidth) |
        R300_TX_HEIGHT(txheight) |
        R300_TX_DEPTH(txdepth);

    if (desc->uses_stride_addressing) {
        unsigned stride =
            r300_stride_to_width(format, desc->stride_in_bytes[level]);
        /* rectangles love this */
        out->format0 |= R300_TX_PITCH_EN;
        out->format2 = (stride - 1) & 0x1fff;
    }

    if (pt->target == PIPE_TEXTURE_CUBE) {
        out->format1 |= R300_TX_FORMAT_CUBIC_MAP;
    }
    if (pt->target == PIPE_TEXTURE_3D) {
        out->format1 |= R300_TX_FORMAT_3D;
    }

    /* large textures on r500 */
    if (is_r500)
    {
        unsigned us_width = txwidth;
        unsigned us_height = txheight;
        unsigned us_depth = txdepth;

        if (width > 2048) {
            out->format2 |= R500_TXWIDTH_BIT11;
        }
        if (height > 2048) {
            out->format2 |= R500_TXHEIGHT_BIT11;
        }

        /* The US_FORMAT register fixes an R500 TX addressing bug.
         * Don't ask why it must be set like this. I don't know it either. */
        if (width > 2048) {
            us_width = (0x000007FF + us_width) >> 1;
            us_depth |= 0x0000000D;
        }
        if (height > 2048) {
            us_height = (0x000007FF + us_height) >> 1;
            us_depth |= 0x0000000E;
        }

        out->us_format0 =
            R300_TX_WIDTH(us_width) |
            R300_TX_HEIGHT(us_height) |
            R300_TX_DEPTH(us_depth);
    }

    out->tile_config = R300_TXO_MACRO_TILE(desc->macrotile[level]) |
                       R300_TXO_MICRO_TILE(desc->microtile);
}

static void r300_texture_setup_fb_state(struct r300_surface *surf)
{
    struct r300_resource *tex = r300_resource(surf->base.texture);
    unsigned level = surf->base.u.tex.level;
    unsigned stride =
      r300_stride_to_width(surf->base.format, tex->tex.stride_in_bytes[level]);

    /* Set framebuffer state. */
    if (util_format_is_depth_or_stencil(surf->base.format)) {
        surf->pitch =
                stride |
                R300_DEPTHMACROTILE(tex->tex.macrotile[level]) |
                R300_DEPTHMICROTILE(tex->tex.microtile);
        surf->format = r300_translate_zsformat(surf->base.format);
        surf->pitch_zmask = tex->tex.zmask_stride_in_pixels[level];
        surf->pitch_hiz = tex->tex.hiz_stride_in_pixels[level];
    } else {
        enum pipe_format hwformat = r300_get_hw_format(surf->base.format,
                                                       surf->base.texture->bind);

        surf->pitch =
                stride |
                r300_translate_colorformat(hwformat) |
                R300_COLOR_TILE(tex->tex.macrotile[level]) |
                R300_COLOR_MICROTILE(tex->tex.microtile);
        surf->format = r300_translate_out_fmt(hwformat);
        surf->colormask_swizzle =
            r300_translate_colormask_swizzle(hwformat);
        surf->pitch_cmask = tex->tex.cmask_stride_in_pixels;
    }
}

static void r300_texture_destroy(struct pipe_screen *screen,
                                 struct pipe_resource* texture)
{
    struct r300_screen *rscreen = r300_screen(screen);
    struct r300_resource* tex = (struct r300_resource*)texture;

    if (tex->tex.cmask_dwords) {
        pipe_mutex_lock(rscreen->cmask_mutex);
        if (texture == rscreen->cmask_resource) {
            rscreen->cmask_resource = NULL;
        }
        pipe_mutex_unlock(rscreen->cmask_mutex);
    }
    pb_reference(&tex->buf, NULL);
    FREE(tex);
}

boolean r300_resource_get_handle(struct pipe_screen* screen,
                                 struct pipe_resource *texture,
                                 struct winsys_handle *whandle)
{
    struct radeon_winsys *rws = r300_screen(screen)->rws;
    struct r300_resource* tex = (struct r300_resource*)texture;

    if (!tex) {
        return FALSE;
    }

    return rws->buffer_get_handle(tex->buf,
                                  tex->tex.stride_in_bytes[0], whandle);
}

static const struct u_resource_vtbl r300_texture_vtbl =
{
    NULL,                           /* get_handle */
    r300_texture_destroy,           /* resource_destroy */
    r300_texture_transfer_map,      /* transfer_map */
    NULL,                           /* transfer_flush_region */
    r300_texture_transfer_unmap,    /* transfer_unmap */
    NULL /* transfer_inline_write */
};

/* The common texture constructor. */
static struct r300_resource*
r300_texture_create_object(struct r300_screen *rscreen,
                           const struct pipe_resource *base,
                           enum radeon_bo_layout microtile,
                           enum radeon_bo_layout macrotile,
                           unsigned stride_in_bytes_override,
                           struct pb_buffer *buffer)
{
    struct radeon_winsys *rws = rscreen->rws;
    struct r300_resource *tex = NULL;

    tex = CALLOC_STRUCT(r300_resource);
    if (!tex) {
        goto fail;
    }

    pipe_reference_init(&tex->b.b.reference, 1);
    tex->b.b.screen = &rscreen->screen;
    tex->b.b.usage = base->usage;
    tex->b.b.bind = base->bind;
    tex->b.b.flags = base->flags;
    tex->b.vtbl = &r300_texture_vtbl;
    tex->tex.microtile = microtile;
    tex->tex.macrotile[0] = macrotile;
    tex->tex.stride_in_bytes_override = stride_in_bytes_override;
    tex->domain = (base->flags & R300_RESOURCE_FLAG_TRANSFER ||
                   base->usage == PIPE_USAGE_STAGING) ? RADEON_DOMAIN_GTT :
                  base->nr_samples > 1 ? RADEON_DOMAIN_VRAM :
                                         RADEON_DOMAIN_VRAM | RADEON_DOMAIN_GTT;
    tex->buf = buffer;

    r300_texture_desc_init(rscreen, tex, base);

    /* Figure out the ideal placement for the texture.. */
    if (tex->domain & RADEON_DOMAIN_VRAM &&
        tex->tex.size_in_bytes >= rscreen->info.vram_size) {
        tex->domain &= ~RADEON_DOMAIN_VRAM;
        tex->domain |= RADEON_DOMAIN_GTT;
    }
    if (tex->domain & RADEON_DOMAIN_GTT &&
        tex->tex.size_in_bytes >= rscreen->info.gart_size) {
        tex->domain &= ~RADEON_DOMAIN_GTT;
    }
    /* Just fail if the texture is too large. */
    if (!tex->domain) {
        goto fail;
    }

    /* Create the backing buffer if needed. */
    if (!tex->buf) {
        tex->buf = rws->buffer_create(rws, tex->tex.size_in_bytes, 2048, TRUE,
                                      tex->domain);

        if (!tex->buf) {
            goto fail;
        }
    }

    if (SCREEN_DBG_ON(rscreen, DBG_MSAA) && base->nr_samples > 1) {
        fprintf(stderr, "r300: %ix MSAA %s buffer created\n",
                base->nr_samples,
                util_format_is_depth_or_stencil(base->format) ? "depth" : "color");
    }

    tex->cs_buf = rws->buffer_get_cs_handle(tex->buf);

    rws->buffer_set_tiling(tex->buf, NULL,
            tex->tex.microtile, tex->tex.macrotile[0],
            0, 0, 0, 0, 0,
            tex->tex.stride_in_bytes[0], false);

    return tex;

fail:
    FREE(tex);
    if (buffer)
        pb_reference(&buffer, NULL);
    return NULL;
}

/* Create a new texture. */
struct pipe_resource *r300_texture_create(struct pipe_screen *screen,
                                          const struct pipe_resource *base)
{
    struct r300_screen *rscreen = r300_screen(screen);
    enum radeon_bo_layout microtile, macrotile;

    if ((base->flags & R300_RESOURCE_FLAG_TRANSFER) ||
        (base->bind & (PIPE_BIND_SCANOUT | PIPE_BIND_LINEAR))) {
        microtile = RADEON_LAYOUT_LINEAR;
        macrotile = RADEON_LAYOUT_LINEAR;
    } else {
        /* This will make the texture_create_function select the layout. */
        microtile = RADEON_LAYOUT_UNKNOWN;
        macrotile = RADEON_LAYOUT_UNKNOWN;
    }

    return (struct pipe_resource*)
           r300_texture_create_object(rscreen, base, microtile, macrotile,
                                      0, NULL);
}

struct pipe_resource *r300_texture_from_handle(struct pipe_screen *screen,
                                               const struct pipe_resource *base,
                                               struct winsys_handle *whandle)
{
    struct r300_screen *rscreen = r300_screen(screen);
    struct radeon_winsys *rws = rscreen->rws;
    struct pb_buffer *buffer;
    enum radeon_bo_layout microtile, macrotile;
    unsigned stride;

    /* Support only 2D textures without mipmaps */
    if ((base->target != PIPE_TEXTURE_2D &&
          base->target != PIPE_TEXTURE_RECT) ||
        base->depth0 != 1 ||
        base->last_level != 0) {
        return NULL;
    }

    buffer = rws->buffer_from_handle(rws, whandle, &stride);
    if (!buffer)
        return NULL;

    rws->buffer_get_tiling(buffer, &microtile, &macrotile, NULL, NULL, NULL,
                           NULL, NULL, NULL);

    /* Enforce a microtiled zbuffer. */
    if (util_format_is_depth_or_stencil(base->format) &&
        microtile == RADEON_LAYOUT_LINEAR) {
        switch (util_format_get_blocksize(base->format)) {
            case 4:
                microtile = RADEON_LAYOUT_TILED;
                break;

            case 2:
                microtile = RADEON_LAYOUT_SQUARETILED;
                break;
        }
    }

    return (struct pipe_resource*)
           r300_texture_create_object(rscreen, base, microtile, macrotile,
                                      stride, buffer);
}

/* Not required to implement u_resource_vtbl, consider moving to another file:
 */
struct pipe_surface* r300_create_surface_custom(struct pipe_context * ctx,
                                         struct pipe_resource* texture,
                                         const struct pipe_surface *surf_tmpl,
                                         unsigned width0_override,
					 unsigned height0_override)
{
    struct r300_resource* tex = r300_resource(texture);
    struct r300_surface* surface = CALLOC_STRUCT(r300_surface);
    unsigned level = surf_tmpl->u.tex.level;

    assert(surf_tmpl->u.tex.first_layer == surf_tmpl->u.tex.last_layer);

    if (surface) {
        uint32_t offset, tile_height;

        pipe_reference_init(&surface->base.reference, 1);
        pipe_resource_reference(&surface->base.texture, texture);
        surface->base.context = ctx;
        surface->base.format = surf_tmpl->format;
        surface->base.width = u_minify(width0_override, level);
        surface->base.height = u_minify(height0_override, level);
        surface->base.u.tex.level = level;
        surface->base.u.tex.first_layer = surf_tmpl->u.tex.first_layer;
        surface->base.u.tex.last_layer = surf_tmpl->u.tex.last_layer;

        surface->buf = tex->buf;
        surface->cs_buf = tex->cs_buf;

        /* Prefer VRAM if there are multiple domains to choose from. */
        surface->domain = tex->domain;
        if (surface->domain & RADEON_DOMAIN_VRAM)
            surface->domain &= ~RADEON_DOMAIN_GTT;

        surface->offset = r300_texture_get_offset(tex, level,
                                                  surf_tmpl->u.tex.first_layer);
        r300_texture_setup_fb_state(surface);

        /* Parameters for the CBZB clear. */
        surface->cbzb_allowed = tex->tex.cbzb_allowed[level];
        surface->cbzb_width = align(surface->base.width, 64);

        /* Height must be aligned to the size of a tile. */
        tile_height = r300_get_pixel_alignment(surface->base.format,
                                               tex->b.b.nr_samples,
                                               tex->tex.microtile,
                                               tex->tex.macrotile[level],
                                               DIM_HEIGHT, 0);

        surface->cbzb_height = align((surface->base.height + 1) / 2,
                                     tile_height);

        /* Offset must be aligned to 2K and must point at the beginning
         * of a scanline. */
        offset = surface->offset +
                 tex->tex.stride_in_bytes[level] * surface->cbzb_height;
        surface->cbzb_midpoint_offset = offset & ~2047;

        surface->cbzb_pitch = surface->pitch & 0x1ffffc;

        if (util_format_get_blocksizebits(surface->base.format) == 32)
            surface->cbzb_format = R300_DEPTHFORMAT_24BIT_INT_Z_8BIT_STENCIL;
        else
            surface->cbzb_format = R300_DEPTHFORMAT_16BIT_INT_Z;

        DBG(r300_context(ctx), DBG_CBZB,
            "CBZB Allowed: %s, Dim: %ix%i, Misalignment: %i, Micro: %s, Macro: %s\n",
            surface->cbzb_allowed ? "YES" : " NO",
            surface->cbzb_width, surface->cbzb_height,
            offset & 2047,
            tex->tex.microtile ? "YES" : " NO",
            tex->tex.macrotile[level] ? "YES" : " NO");
    }

    return &surface->base;
}

struct pipe_surface* r300_create_surface(struct pipe_context * ctx,
                                         struct pipe_resource* texture,
                                         const struct pipe_surface *surf_tmpl)
{
    return r300_create_surface_custom(ctx, texture, surf_tmpl,
                                      texture->width0,
                                      texture->height0);
}

/* Not required to implement u_resource_vtbl, consider moving to another file:
 */
void r300_surface_destroy(struct pipe_context *ctx, struct pipe_surface* s)
{
    pipe_resource_reference(&s->texture, NULL);
    FREE(s);
}
@


1.8
log
@Make the Gallium r300 works on big-endian architectures.

Diff provided by Michel Daenzer [0] as a possible solution for a
regression introduced in Mesa 9 [1].  This diff allows macppc
users to use OpenGL accelerated appplications (i.e. GNOME3).

As disucssed during c2k15 we won't try to keep this patch during
the next Mesa update.

[0] https://bugs.freedesktop.org/show_bug.cgi?id=71789
[1] http://lists.freedesktop.org/archives/mesa-dev/2013-December/050218.html

Tested by myself and ajacoutot@@, regression test and ok jsg@@
@
text
@@


1.7
log
@Merge Mesa 10.2.9
@
text
@d93 19
d466 2
d472 2
d693 4
d800 8
d974 3
d979 1
a979 1
                r300_translate_colorformat(surf->base.format) |
d982 1
a982 1
        surf->format = r300_translate_out_fmt(surf->base.format);
d984 1
a984 1
            r300_translate_colormask_swizzle(surf->base.format);
@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1045 1
a1045 1
                                      tex->domain, 0);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1045 1
a1045 1
                                      tex->domain);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d1063 1
a1063 1
            tex->tex.stride_in_bytes[0]);
d1082 1
a1082 1
        (base->bind & PIPE_BIND_SCANOUT)) {
d1118 2
a1119 1
    rws->buffer_get_tiling(buffer, &microtile, &macrotile, NULL, NULL, NULL, NULL, NULL);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a40 12
void util_format_combine_swizzles(unsigned char *dst,
                                  const unsigned char *swz1,
                                  const unsigned char *swz2)
{
    unsigned i;

    for (i = 0; i < 4; i++) {
        dst[i] = swz2[i] <= UTIL_FORMAT_SWIZZLE_W ?
                 swz1[swz2[i]] : swz2[i];
    }
}

d63 1
a63 1
        util_format_combine_swizzles(swizzle, swizzle_format, swizzle_view);
d132 1
a132 1
                case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d239 11
d388 1
a388 1
        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d418 2
d454 1
a454 1
        /*case PIPE_FORMAT_R8G8B8X8_SNORM:*/
d463 3
d475 1
d482 3
d489 1
d494 1
d517 1
a517 1
        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d639 2
d664 1
d680 1
a680 1
        /*case PIPE_FORMAT_R8G8B8X8_SNORM:*/
d696 1
d705 3
d716 3
d720 1
d729 92
d824 2
a825 1
           r300_translate_out_fmt(format) != ~0;
d840 1
d842 2
d846 1
a846 1
    struct pipe_resource *pt = &tex->b.b.b;
d852 2
a853 2
    width = u_minify(desc->width0, level);
    height = u_minify(desc->height0, level);
d873 2
d877 1
a877 1
        out->format2 = (desc->stride_in_pixels[level] - 1) & 0x1fff;
d926 2
d932 1
a932 1
                tex->tex.stride_in_pixels[level] |
d940 1
a940 1
                tex->tex.stride_in_pixels[level] |
d945 3
a950 18
void r300_resource_set_properties(struct pipe_screen *screen,
                                  struct pipe_resource *tex,
                                  unsigned offset,
                                  const struct pipe_resource *new_properties)
{
    struct r300_screen *rscreen = r300_screen(screen);
    struct r300_resource *res = r300_resource(tex);

    SCREEN_DBG(rscreen, DBG_TEX,
        "r300: texture_set_properties: %s -> %s\n",
        util_format_short_name(tex->format),
        util_format_short_name(new_properties->format));

    r300_texture_desc_init(rscreen, res, new_properties);
    res->tex_offset = offset;
    r300_texture_setup_format_state(rscreen, res, 0, &res->tx_format);
}

d954 1
d957 7
d972 1
a972 1
    struct radeon_winsys *rws = (struct radeon_winsys *)screen->winsys;
a986 2
    r300_texture_get_transfer,      /* get_transfer */
    r300_texture_transfer_destroy,  /* transfer_destroy */
d990 1
a990 1
    u_default_transfer_inline_write /* transfer_inline_write */
a999 1
                           unsigned max_buffer_size,
d1003 3
a1005 1
    struct r300_resource *tex = CALLOC_STRUCT(r300_resource);
d1007 1
a1007 3
        if (buffer)
            pb_reference(&buffer, NULL);
        return NULL;
d1010 6
a1015 6
    pipe_reference_init(&tex->b.b.b.reference, 1);
    tex->b.b.b.screen = &rscreen->screen;
    tex->b.b.b.usage = base->usage;
    tex->b.b.b.bind = base->bind;
    tex->b.b.b.flags = base->flags;
    tex->b.b.vtbl = &r300_texture_vtbl;
d1019 22
a1040 6
    tex->domain = base->flags & R300_RESOURCE_FLAG_TRANSFER ?
                  RADEON_DOMAIN_GTT :
                  RADEON_DOMAIN_VRAM | RADEON_DOMAIN_GTT;
    tex->buf_size = max_buffer_size;

    r300_resource_set_properties(&rscreen->screen, &tex->b.b.b, 0, base);
d1043 3
a1045 4
    if (!buffer) {
        tex->buf_size = tex->tex.size_in_bytes;
        tex->buf = rws->buffer_create(rws, tex->tex.size_in_bytes, 2048,
                                         base->bind, base->usage, tex->domain);
d1048 1
a1048 2
            FREE(tex);
            return NULL;
d1050 6
a1055 2
    } else {
        tex->buf = buffer;
d1062 1
d1066 6
d1093 1
a1093 1
                                      0, 0, NULL);
a1099 1
    struct radeon_winsys *rws = (struct radeon_winsys*)screen->winsys;
d1101 1
d1104 1
a1104 1
    unsigned stride, size;
d1114 1
a1114 1
    buffer = rws->buffer_from_handle(rws, whandle, &stride, &size);
d1118 1
a1118 1
    rws->buffer_get_tiling(buffer, &microtile, &macrotile);
d1136 1
a1136 1
                                      stride, size, buffer);
d1141 1
a1141 1
struct pipe_surface* r300_create_surface(struct pipe_context * ctx,
d1143 3
a1145 1
                                         const struct pipe_surface *surf_tmpl)
d1160 2
a1161 3
        surface->base.width = u_minify(texture->width0, level);
        surface->base.height = u_minify(texture->height0, level);
        surface->base.usage = surf_tmpl->usage;
d1183 2
a1184 2
        tile_height = r300_get_pixel_alignment(tex->b.b.b.format,
                                               tex->b.b.b.nr_samples,
d1215 9
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a31 1
#include "r300_winsys.h"
d41 12
d75 1
a75 4
        for (i = 0; i < 4; i++) {
            swizzle[i] = swizzle_view[i] <= UTIL_FORMAT_SWIZZLE_W ?
                         swizzle_format[swizzle_view[i]] : swizzle_view[i];
        }
d127 3
a130 3
        R300_TX_FORMAT_SIGNED_Y,
        R300_TX_FORMAT_SIGNED_Z,
        R300_TX_FORMAT_SIGNED_W,
d182 17
a198 2
    result |= r300_get_swizzle_combined(desc->swizzle, swizzle_view,
                    util_format_is_compressed(format) && dxtc_swizzle);
d223 18
a240 4
    /* Add sign. */
    for (i = 0; i < desc->nr_channels; i++) {
        if (desc->channel[i].type == UTIL_FORMAT_TYPE_SIGNED) {
            result |= sign_bit[i];
d251 4
a254 11
    /* RGTC formats. */
    if (desc->layout == UTIL_FORMAT_LAYOUT_RGTC) {
        switch (format) {
            case PIPE_FORMAT_RGTC1_UNORM:
            case PIPE_FORMAT_RGTC1_SNORM:
                return R500_TX_FORMAT_ATI1N | result;
            case PIPE_FORMAT_RGTC2_UNORM:
            case PIPE_FORMAT_RGTC2_SNORM:
                return R400_TX_FORMAT_ATI2N | result;
            default:
                return ~0; /* Unsupported/unknown. */
d277 5
d386 2
d405 1
d407 1
d409 1
d416 1
d419 13
d447 1
d453 13
d477 4
d523 1
a523 6
    static const uint32_t sign_bit[4] = {
        R300_OUT_SIGN(0x1),
        R300_OUT_SIGN(0x2),
        R300_OUT_SIGN(0x4),
        R300_OUT_SIGN(0x8),
    };
d538 30
a567 5
    if (desc->channel[i].type == UTIL_FORMAT_TYPE_FLOAT) {
        if (desc->channel[i].size == 32) {
            modifier |= R300_US_OUT_FMT_C4_32_FP;
        } else {
            modifier |= R300_US_OUT_FMT_C4_16_FP;
d569 23
a591 4
    } else {
        if (desc->channel[i].size == 16) {
            modifier |= R300_US_OUT_FMT_C4_16;
        } else {
d595 1
d600 7
a606 4
    for (i = 0; i < 4; i++)
        if (desc->channel[i].type == UTIL_FORMAT_TYPE_SIGNED) {
            modifier |= sign_bit[i];
        }
d610 4
a613 2
        /* 8-bit outputs, one channel.
         * COLORFORMAT_I8 stores the C2 component. */
d615 1
d618 1
d620 1
d625 3
a627 2
        /* 16-bit outputs, two channels.
         * COLORFORMAT_UV88 stores C2 and C0. */
d630 1
a631 1
        case PIPE_FORMAT_R8G8_SNORM:
d634 7
d648 1
d650 1
d656 9
d667 2
d672 2
d675 2
d678 2
d681 1
d683 8
d695 8
d725 1
a725 1
                                     struct r300_texture_desc *desc,
d729 2
a730 1
    struct pipe_resource *pt = &desc->b.b;
d732 10
d751 3
a753 3
        R300_TX_WIDTH((u_minify(desc->width0, level) - 1) & 0x7ff) |
        R300_TX_HEIGHT((u_minify(desc->height0, level) - 1) & 0x7ff) |
        R300_TX_DEPTH(util_logbase2(u_minify(desc->depth0, level)) & 0xf);
d771 5
a775 1
        if (desc->width0 > 2048) {
d778 1
a778 1
        if (desc->height0 > 2048) {
d781 16
d803 1
a803 2
static void r300_texture_setup_fb_state(struct r300_screen* screen,
                                        struct r300_texture* tex)
d805 2
a806 1
    unsigned i;
d809 8
a816 8
    if (util_format_is_depth_or_stencil(tex->desc.b.b.format)) {
        for (i = 0; i <= tex->desc.b.b.last_level; i++) {
            tex->fb_state.pitch[i] =
                tex->desc.stride_in_pixels[i] |
                R300_DEPTHMACROTILE(tex->desc.macrotile[i]) |
                R300_DEPTHMICROTILE(tex->desc.microtile);
        }
        tex->fb_state.format = r300_translate_zsformat(tex->desc.b.b.format);
d818 6
a823 8
        for (i = 0; i <= tex->desc.b.b.last_level; i++) {
            tex->fb_state.pitch[i] =
                tex->desc.stride_in_pixels[i] |
                r300_translate_colorformat(tex->desc.b.b.format) |
                R300_COLOR_TILE(tex->desc.macrotile[i]) |
                R300_COLOR_MICROTILE(tex->desc.microtile);
        }
        tex->fb_state.format = r300_translate_out_fmt(tex->desc.b.b.format);
d827 4
a830 3
void r300_texture_reinterpret_format(struct pipe_screen *screen,
                                     struct pipe_resource *tex,
                                     enum pipe_format new_format)
d832 2
a833 1
    struct r300_screen *r300screen = r300_screen(screen);
d835 2
a836 2
    SCREEN_DBG(r300screen, DBG_TEX,
        "r300: texture_reinterpret_format: %s -> %s\n",
d838 1
a838 17
        util_format_short_name(new_format));

    tex->format = new_format;

    r300_texture_setup_fb_state(r300_screen(screen), r300_texture(tex));
}

static unsigned r300_texture_is_referenced(struct pipe_context *context,
                                           struct pipe_resource *texture,
                                           unsigned level, int layer)
{
    struct r300_context *r300 = r300_context(context);
    struct r300_texture *rtex = (struct r300_texture *)texture;

    if (r300->rws->cs_is_buffer_referenced(r300->cs,
                                           rtex->cs_buffer, R300_REF_CS))
        return PIPE_REFERENCED_FOR_READ | PIPE_REFERENCED_FOR_WRITE;
d840 3
a842 1
    return PIPE_UNREFERENCED;
d848 1
a848 11
    struct r300_texture* tex = (struct r300_texture*)texture;
    struct r300_winsys_screen *rws = (struct r300_winsys_screen *)texture->screen->winsys;
    int i;

    rws->buffer_reference(rws, &tex->buffer, NULL);
    for (i = 0; i < R300_MAX_TEXTURE_LEVELS; i++) {
        if (tex->hiz_mem[i])
            u_mmFreeMem(tex->hiz_mem[i]);
        if (tex->zmask_mem[i])
            u_mmFreeMem(tex->zmask_mem[i]);
    }
d850 1
d854 3
a856 3
static boolean r300_texture_get_handle(struct pipe_screen* screen,
                                       struct pipe_resource *texture,
                                       struct winsys_handle *whandle)
d858 2
a859 2
    struct r300_winsys_screen *rws = (struct r300_winsys_screen *)screen->winsys;
    struct r300_texture* tex = (struct r300_texture*)texture;
d865 2
a866 2
    return rws->buffer_get_handle(rws, tex->buffer,
                                  tex->desc.stride_in_bytes[0], whandle);
d869 1
a869 1
struct u_resource_vtbl r300_texture_vtbl =
d871 8
a878 9
   r300_texture_get_handle,	      /* get_handle */
   r300_texture_destroy,	      /* resource_destroy */
   r300_texture_is_referenced,	      /* is_resource_referenced */
   r300_texture_get_transfer,	      /* get_transfer */
   r300_texture_transfer_destroy,     /* transfer_destroy */
   r300_texture_transfer_map,	      /* transfer_map */
   u_default_transfer_flush_region,   /* transfer_flush_region */
   r300_texture_transfer_unmap,	      /* transfer_unmap */
   u_default_transfer_inline_write    /* transfer_inline_write */
d882 1
a882 1
static struct r300_texture*
d885 2
a886 2
                           enum r300_buffer_tiling microtile,
                           enum r300_buffer_tiling macrotile,
d889 1
a889 1
                           struct r300_winsys_buffer *buffer)
d891 2
a892 2
    struct r300_winsys_screen *rws = rscreen->rws;
    struct r300_texture *tex = CALLOC_STRUCT(r300_texture);
d895 1
a895 1
            rws->buffer_reference(rws, &buffer, NULL);
d899 13
a911 13
    /* Initialize the descriptor. */
    if (!r300_texture_desc_init(rscreen, &tex->desc, base,
                                microtile, macrotile,
                                stride_in_bytes_override,
                                max_buffer_size)) {
        if (buffer)
            rws->buffer_reference(rws, &buffer, NULL);
        FREE(tex);
        return NULL;
    }
    /* Initialize the hardware state. */
    r300_texture_setup_format_state(rscreen, &tex->desc, 0, &tex->tx_format);
    r300_texture_setup_fb_state(rscreen, tex);
d913 1
a913 6
    tex->desc.b.vtbl = &r300_texture_vtbl;
    pipe_reference_init(&tex->desc.b.b.reference, 1);
    tex->domain = base->flags & R300_RESOURCE_FLAG_TRANSFER ?
                  R300_DOMAIN_GTT :
                  R300_DOMAIN_VRAM | R300_DOMAIN_GTT;
    tex->buffer = buffer;
d916 3
a918 2
    if (!tex->buffer) {
        tex->buffer = rws->buffer_create(rws, tex->desc.size_in_bytes, 2048,
d921 1
a921 1
        if (!tex->buffer) {
d925 2
d929 1
a929 1
    tex->cs_buffer = rws->buffer_get_cs_handle(rws, tex->buffer);
d931 3
a933 3
    rws->buffer_set_tiling(rws, tex->buffer,
            tex->desc.microtile, tex->desc.macrotile[0],
            tex->desc.stride_in_bytes[0]);
d943 1
a943 1
    enum r300_buffer_tiling microtile, macrotile;
d947 2
a948 2
        microtile = R300_BUFFER_LINEAR;
        macrotile = R300_BUFFER_LINEAR;
d950 3
a952 2
        microtile = R300_BUFFER_SELECT_LAYOUT;
        macrotile = R300_BUFFER_SELECT_LAYOUT;
d964 1
a964 1
    struct r300_winsys_screen *rws = (struct r300_winsys_screen*)screen->winsys;
d966 2
a967 2
    struct r300_winsys_buffer *buffer;
    enum r300_buffer_tiling microtile, macrotile;
d982 1
a982 1
    rws->buffer_get_tiling(rws, buffer, &microtile, &macrotile);
d986 1
a986 1
        microtile == R300_BUFFER_LINEAR) {
d989 1
a989 1
                microtile = R300_BUFFER_TILED;
d993 1
a993 2
                if (rws->get_value(rws, R300_VID_SQUARE_TILING_SUPPORT))
                    microtile = R300_BUFFER_SQUARETILED;
d1009 1
a1009 1
    struct r300_texture* tex = r300_texture(texture);
d1029 2
a1030 2
        surface->buffer = tex->buffer;
        surface->cs_buffer = tex->cs_buffer;
d1034 2
a1035 2
        if (surface->domain & R300_DOMAIN_VRAM)
            surface->domain &= ~R300_DOMAIN_GTT;
d1037 1
a1037 1
        surface->offset = r300_texture_get_offset(&tex->desc, level,
d1039 1
a1039 2
        surface->pitch = tex->fb_state.pitch[level];
        surface->format = tex->fb_state.format;
d1042 1
a1042 1
        surface->cbzb_allowed = tex->desc.cbzb_allowed[level];
d1046 4
a1049 4
        tile_height = r300_get_pixel_alignment(tex->desc.b.b.format,
                                               tex->desc.b.b.nr_samples,
                                               tex->desc.microtile,
                                               tex->desc.macrotile[level],
d1058 1
a1058 1
                 tex->desc.stride_in_bytes[level] * surface->cbzb_height;
d1073 2
a1074 2
            tex->desc.microtile ? "YES" : " NO",
            tex->desc.macrotile[level] ? "YES" : " NO");
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d24 9
a32 1
#include "pipe/p_screen.h"
d35 1
d38 1
d40 1
a40 4
#include "r300_context.h"
#include "r300_texture.h"
#include "r300_screen.h"
#include "r300_state_inlines.h"
d42 19
a60 1
#include "radeon_winsys.h"
d62 9
a70 2
#define TILE_WIDTH 0
#define TILE_HEIGHT 1
d72 24
a95 8
static const unsigned microblock_table[5][3][2] = {
    /*linear  tiled   square-tiled */
    {{32, 1}, {8, 4}, {0, 0}}, /*   8 bits per pixel */
    {{16, 1}, {8, 2}, {4, 4}}, /*  16 bits per pixel */
    {{ 8, 1}, {4, 2}, {0, 0}}, /*  32 bits per pixel */
    {{ 4, 1}, {0, 0}, {2, 2}}, /*  64 bits per pixel */
    {{ 2, 1}, {0, 0}, {0, 0}}  /* 128 bits per pixel */
};
d109 4
a112 1
static uint32_t r300_translate_texformat(enum pipe_format format)
d116 1
a116 1
    unsigned components = 0, i;
a117 12
    const uint32_t swizzle_shift[4] = {
        R300_TX_FORMAT_R_SHIFT,
        R300_TX_FORMAT_G_SHIFT,
        R300_TX_FORMAT_B_SHIFT,
        R300_TX_FORMAT_A_SHIFT
    };
    const uint32_t swizzle[4] = {
        R300_TX_FORMAT_X,
        R300_TX_FORMAT_Y,
        R300_TX_FORMAT_Z,
        R300_TX_FORMAT_W
    };
d129 2
a130 1
        /* Depth stencil formats. */
d134 1
a134 1
                    return R300_EASY_TX_FORMAT(X, X, X, X, X16);
d136 5
a140 2
                case PIPE_FORMAT_S8Z24_UNORM:
                    return R300_EASY_TX_FORMAT(X, X, X, X, W24_FP);
d163 9
a171 1
        default:;
d174 7
a180 24
    /* Add swizzle. */
    for (i = 0; i < 4; i++) {
        switch (desc->swizzle[i]) {
            case UTIL_FORMAT_SWIZZLE_X:
            case UTIL_FORMAT_SWIZZLE_NONE:
                result |= swizzle[0] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_Y:
                result |= swizzle[1] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_Z:
                result |= swizzle[2] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_W:
                result |= swizzle[3] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_0:
                result |= R300_TX_FORMAT_ZERO << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_1:
                result |= R300_TX_FORMAT_ONE << swizzle_shift[i];
                break;
            default:
                return ~0; /* Unsupported. */
a181 1
    }
a182 2
    /* Compressed formats. */
    if (desc->layout == UTIL_FORMAT_LAYOUT_COMPRESSED) {
d200 4
a203 4
    /* Get the number of components. */
    for (i = 0; i < 4; i++) {
        if (desc->channel[i].type != UTIL_FORMAT_TYPE_VOID) {
            ++components;
d207 18
a224 4
    /* Add sign. */
    for (i = 0; i < components; i++) {
        if (desc->channel[i].type == UTIL_FORMAT_TYPE_SIGNED) {
            result |= sign_bit[i];
d229 1
a229 1
    for (i = 1; i < components; i++) {
d235 1
a235 1
        switch (components) {
d266 10
d277 1
a277 1
    switch (desc->channel[0].type) {
d280 1
a280 1
            if (!desc->channel[0].normalized &&
d285 1
a285 1
            switch (desc->channel[0].size) {
d287 1
a287 1
                    switch (components) {
d296 1
a296 1
                    switch (components) {
d307 1
a307 1
                    switch (components) {
a317 2
/* XXX Enable float textures here. */
#if 0
d319 1
a319 1
            switch (desc->channel[0].size) {
d321 1
a321 1
                    switch (components) {
d332 1
a332 1
                    switch (components) {
a340 1
#endif
d346 13
a369 1
        case PIPE_FORMAT_L8_SRGB:
d375 5
d382 1
d384 1
d386 1
d388 1
a392 1
        case PIPE_FORMAT_B8G8R8A8_SRGB:
d394 2
a395 6
        case PIPE_FORMAT_B8G8R8X8_SRGB:
        case PIPE_FORMAT_A8R8G8B8_UNORM:
        case PIPE_FORMAT_A8R8G8B8_SRGB:
        case PIPE_FORMAT_X8R8G8B8_UNORM:
        case PIPE_FORMAT_X8R8G8B8_SRGB:
        case PIPE_FORMAT_A8B8G8R8_UNORM:
d397 1
a397 4
        case PIPE_FORMAT_A8B8G8R8_SRGB:
        case PIPE_FORMAT_X8B8G8R8_UNORM:
        case PIPE_FORMAT_X8B8G8R8_SRGB:
        case PIPE_FORMAT_R8SG8SB8UX8U_NORM:
d399 1
d401 2
d408 1
a408 1
        //case PIPE_FORMAT_R16G16B16A16_FLOAT: /* not in pipe_format */
a410 2
/* XXX Enable float textures here. */
#if 0
a413 1
#endif
d435 1
a435 1
        case PIPE_FORMAT_S8Z24_UNORM:
d460 10
d471 2
a472 7
    if (desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
        /* The gamma correction causes precision loss so we need
         * higher precision to maintain reasonable quality.
         * It has nothing to do with the colorbuffer format. */
        modifier |= R300_US_OUT_FMT_C4_10_GAMMA;
    } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {
        if (desc->channel[0].size == 32) {
d478 1
a478 1
        if (desc->channel[0].size == 16) {
d495 1
a495 1
        /* 8-bit outputs.
a500 1
        case PIPE_FORMAT_L8_SRGB:
d505 9
a513 1
        /* ARGB 32-bit outputs. */
d516 1
d518 1
a519 1
        case PIPE_FORMAT_B8G8R8A8_SRGB:
d521 1
a521 1
        case PIPE_FORMAT_B8G8R8X8_SRGB:
d526 2
a527 11
        /* BGRA 32-bit outputs. */
        case PIPE_FORMAT_A8R8G8B8_UNORM:
        case PIPE_FORMAT_A8R8G8B8_SRGB:
        case PIPE_FORMAT_X8R8G8B8_UNORM:
        case PIPE_FORMAT_X8R8G8B8_SRGB:
            return modifier |
                R300_C0_SEL_A | R300_C1_SEL_R |
                R300_C2_SEL_G | R300_C3_SEL_B;

        /* RGBA 32-bit outputs. */
        case PIPE_FORMAT_A8B8G8R8_UNORM:
a528 9
        case PIPE_FORMAT_A8B8G8R8_SRGB:
        case PIPE_FORMAT_X8B8G8R8_UNORM:
        case PIPE_FORMAT_X8B8G8R8_SRGB:
            return modifier |
                R300_C0_SEL_A | R300_C1_SEL_B |
                R300_C2_SEL_G | R300_C3_SEL_R;

        /* ABGR 32-bit outputs. */
        case PIPE_FORMAT_R8SG8SB8UX8U_NORM:
d530 1
a530 1
        /* RGBA high precision outputs (same swizzles as ABGR low precision) */
d533 1
a533 1
        //case PIPE_FORMAT_R16G16B16A16_FLOAT: /* not in pipe_format */
d557 1
a557 1
    return r300_translate_texformat(format) != ~0;
d560 13
a572 6
static void r300_setup_texture_state(struct r300_screen* screen, struct r300_texture* tex)
{
    struct r300_texture_format_state* state = &tex->state;
    struct pipe_texture *pt = &tex->tex;
    unsigned i;
    boolean is_r500 = screen->caps->is_r500;
d575 4
a578 2
    state->format0 = R300_TX_WIDTH((pt->width0 - 1) & 0x7ff) |
                     R300_TX_HEIGHT((pt->height0 - 1) & 0x7ff);
d580 1
a580 1
    if (tex->is_npot) {
d582 2
a583 5
        state->format0 |= R300_TX_PITCH_EN;
        state->format2 = (tex->pitch[0] - 1) & 0x1fff;
    } else {
        /* power of two textures (3D, mipmaps, and no pitch) */
        state->format0 |= R300_TX_DEPTH(util_logbase2(pt->depth0) & 0xf);
a585 1
    state->format1 = r300_translate_texformat(pt->format);
d587 1
a587 1
        state->format1 |= R300_TX_FORMAT_CUBIC_MAP;
d590 1
a590 1
        state->format1 |= R300_TX_FORMAT_3D;
d596 2
a597 2
        if (pt->width0 > 2048) {
            state->format2 |= R500_TXWIDTH_BIT11;
d599 2
a600 2
        if (pt->height0 > 2048) {
            state->format2 |= R500_TXHEIGHT_BIT11;
d604 8
a611 2
    SCREEN_DBG(screen, DBG_TEX, "r300: Set texture state (%dx%d, %d levels)\n",
               pt->width0, pt->height0, pt->last_level);
d614 6
a619 6
    if (util_format_is_depth_or_stencil(tex->tex.format)) {
        for (i = 0; i <= tex->tex.last_level; i++) {
            tex->fb_state.depthpitch[i] =
                tex->pitch[i] |
                R300_DEPTHMACROTILE(tex->mip_macrotile[i]) |
                R300_DEPTHMICROTILE(tex->microtile);
d621 1
a621 1
        tex->fb_state.zb_format = r300_translate_zsformat(tex->tex.format);
d623 6
a628 6
        for (i = 0; i <= tex->tex.last_level; i++) {
            tex->fb_state.colorpitch[i] =
                tex->pitch[i] |
                r300_translate_colorformat(tex->tex.format) |
                R300_COLOR_TILE(tex->mip_macrotile[i]) |
                R300_COLOR_MICROTILE(tex->microtile);
d630 1
a630 1
        tex->fb_state.us_out_fmt = r300_translate_out_fmt(tex->tex.format);
d635 1
a635 1
                                     struct pipe_texture *tex,
d640 4
a643 2
    SCREEN_DBG(r300screen, DBG_TEX, "r300: Reinterpreting format: %s -> %s\n",
               util_format_name(tex->format), util_format_name(new_format));
d647 1
a647 1
    r300_setup_texture_state(r300_screen(screen), (struct r300_texture*)tex);
d650 3
a652 2
unsigned r300_texture_get_offset(struct r300_texture* tex, unsigned level,
                                 unsigned zslice, unsigned face)
d654 2
a655 6
    unsigned offset = tex->offset[level];

    switch (tex->tex.target) {
        case PIPE_TEXTURE_3D:
            assert(face == 0);
            return offset + zslice * tex->layer_size[level];
d657 3
a659 3
        case PIPE_TEXTURE_CUBE:
            assert(zslice == 0);
            return offset + face * tex->layer_size[level];
d661 1
a661 4
        default:
            assert(zslice == 0 && face == 0);
            return offset;
    }
d664 2
a665 6
/**
 * Return the width (dim==TILE_WIDTH) or height (dim==TILE_HEIGHT) of one tile
 * of the given texture.
 */
static unsigned r300_texture_get_tile_size(struct r300_texture* tex,
                                           int dim, boolean macrotile)
d667 3
a669 4
    unsigned pixsize, tile_size;

    pixsize = util_format_get_blocksize(tex->tex.format);
    tile_size = microblock_table[util_logbase2(pixsize)][tex->microtile][dim];
d671 6
a676 2
    if (macrotile) {
        tile_size *= 8;
d679 1
a679 2
    assert(tile_size);
    return tile_size;
d682 3
a684 4
/* Return true if macrotiling should be enabled on the miplevel. */
static boolean r300_texture_macro_switch(struct r300_texture *tex,
                                         unsigned level,
                                         boolean rv350_mode)
d686 2
a687 1
    unsigned tile_width, width;
d689 2
a690 28
    tile_width = r300_texture_get_tile_size(tex, TILE_WIDTH, TRUE);
    width = u_minify(tex->tex.width0, level);

    /* See TX_FILTER1_n.MACRO_SWITCH. */
    if (rv350_mode) {
        return width >= tile_width;
    } else {
        return width > tile_width;
    }
}

/**
 * Return the stride, in bytes, of the texture images of the given texture
 * at the given level.
 */
unsigned r300_texture_get_stride(struct r300_screen* screen,
                                 struct r300_texture* tex, unsigned level)
{
    unsigned tile_width, width;

    if (tex->stride_override)
        return tex->stride_override;

    /* Check the level. */
    if (level > tex->tex.last_level) {
        SCREEN_DBG(screen, DBG_TEX, "%s: level (%u) > last_level (%u)\n",
                   __FUNCTION__, level, tex->tex.last_level);
        return 0;
d693 2
a694 11
    width = u_minify(tex->tex.width0, level);

    if (!util_format_is_compressed(tex->tex.format)) {
        tile_width = r300_texture_get_tile_size(tex, TILE_WIDTH,
                                                tex->mip_macrotile[level]);
        width = align(width, tile_width);

        return util_format_get_stride(tex->tex.format, width);
    } else {
        return align(util_format_get_stride(tex->tex.format, width), 32);
    }
d697 1
a697 2
static unsigned r300_texture_get_nblocksy(struct r300_texture* tex,
                                          unsigned level)
d699 10
a708 1
    unsigned height, tile_height;
d710 9
a718 13
    height = u_minify(tex->tex.height0, level);

    if (!util_format_is_compressed(tex->tex.format)) {
        tile_height = r300_texture_get_tile_size(tex, TILE_HEIGHT,
                                                 tex->mip_macrotile[level]);
        height = align(height, tile_height);
    }

    return util_format_get_nblocksy(tex->tex.format, height);
}

static void r300_setup_miptree(struct r300_screen* screen,
                               struct r300_texture* tex)
d720 2
a721 50
    struct pipe_texture* base = &tex->tex;
    unsigned stride, size, layer_size, nblocksy, i;
    boolean rv350_mode = screen->caps->family >= CHIP_FAMILY_RV350;

    SCREEN_DBG(screen, DBG_TEX, "r300: Making miptree for texture, format %s\n",
               util_format_name(base->format));

    for (i = 0; i <= base->last_level; i++) {
        /* Let's see if this miplevel can be macrotiled. */
        tex->mip_macrotile[i] = (tex->macrotile == R300_BUFFER_TILED &&
                                 r300_texture_macro_switch(tex, i, rv350_mode)) ?
                                 R300_BUFFER_TILED : R300_BUFFER_LINEAR;

        stride = r300_texture_get_stride(screen, tex, i);
        nblocksy = r300_texture_get_nblocksy(tex, i);
        layer_size = stride * nblocksy;

        if (base->target == PIPE_TEXTURE_CUBE)
            size = layer_size * 6;
        else
            size = layer_size * u_minify(base->depth0, i);

        tex->offset[i] = tex->size;
        tex->size = tex->offset[i] + size;
        tex->layer_size[i] = layer_size;
        tex->pitch[i] = stride / util_format_get_blocksize(base->format);

        SCREEN_DBG(screen, DBG_TEX, "r300: Texture miptree: Level %d "
                "(%dx%dx%d px, pitch %d bytes) %d bytes total, macrotiled %s\n",
                i, u_minify(base->width0, i), u_minify(base->height0, i),
                u_minify(base->depth0, i), stride, tex->size,
                tex->mip_macrotile[i] ? "TRUE" : "FALSE");
    }
}

static void r300_setup_flags(struct r300_texture* tex)
{
    tex->is_npot = !util_is_power_of_two(tex->tex.width0) ||
                   !util_is_power_of_two(tex->tex.height0);
}

/* Create a new texture. */
static struct pipe_texture*
    r300_texture_create(struct pipe_screen* screen,
                        const struct pipe_texture* template)
{
    struct r300_texture* tex = CALLOC_STRUCT(r300_texture);
    struct r300_screen* rscreen = r300_screen(screen);
    struct radeon_winsys* winsys = (struct radeon_winsys*)screen->winsys;

d723 2
d728 7
a734 17
    tex->tex = *template;
    pipe_reference_init(&tex->tex.reference, 1);
    tex->tex.screen = screen;

    r300_setup_flags(tex);
    r300_setup_miptree(rscreen, tex);
    r300_setup_texture_state(rscreen, tex);

    tex->buffer = screen->buffer_create(screen, 2048,
                                        PIPE_BUFFER_USAGE_PIXEL,
                                        tex->size);
    winsys->buffer_set_tiling(winsys, tex->buffer,
                              tex->pitch[0],
                              tex->microtile != R300_BUFFER_LINEAR,
                              tex->macrotile != R300_BUFFER_LINEAR);

    if (!tex->buffer) {
d738 15
d754 5
a758 2
    return (struct pipe_texture*)tex;
}
d760 1
a760 3
static void r300_texture_destroy(struct pipe_texture* texture)
{
    struct r300_texture* tex = (struct r300_texture*)texture;
d762 3
a764 1
    pipe_buffer_reference(&tex->buffer, NULL);
d766 1
a766 1
    FREE(tex);
d769 3
a771 6
static struct pipe_surface* r300_get_tex_surface(struct pipe_screen* screen,
                                                 struct pipe_texture* texture,
                                                 unsigned face,
                                                 unsigned level,
                                                 unsigned zslice,
                                                 unsigned flags)
d773 2
a774 3
    struct r300_texture* tex = (struct r300_texture*)texture;
    struct pipe_surface* surface = CALLOC_STRUCT(pipe_surface);
    unsigned offset;
d776 7
a782 14
    offset = r300_texture_get_offset(tex, level, zslice, face);

    if (surface) {
        pipe_reference_init(&surface->reference, 1);
        pipe_texture_reference(&surface->texture, texture);
        surface->format = texture->format;
        surface->width = u_minify(texture->width0, level);
        surface->height = u_minify(texture->height0, level);
        surface->offset = offset;
        surface->usage = flags;
        surface->zslice = zslice;
        surface->texture = texture;
        surface->face = face;
        surface->level = level;
d785 3
a787 7
    return surface;
}

static void r300_tex_surface_destroy(struct pipe_surface* s)
{
    pipe_texture_reference(&s->texture, NULL);
    FREE(s);
d790 3
a792 5
static struct pipe_texture*
    r300_texture_blanket(struct pipe_screen* screen,
                         const struct pipe_texture* base,
                         const unsigned* stride,
                         struct pipe_buffer* buffer)
d794 5
a798 2
    struct r300_texture* tex;
    struct r300_screen* rscreen = r300_screen(screen);
d801 2
a802 1
    if (base->target != PIPE_TEXTURE_2D ||
d808 2
a809 2
    tex = CALLOC_STRUCT(r300_texture);
    if (!tex) {
a810 1
    }
d812 9
a820 45
    tex->tex = *base;
    pipe_reference_init(&tex->tex.reference, 1);
    tex->tex.screen = screen;

    tex->stride_override = *stride;
    tex->pitch[0] = *stride / util_format_get_blocksize(base->format);

    r300_setup_flags(tex);
    r300_setup_texture_state(rscreen, tex);

    pipe_buffer_reference(&tex->buffer, buffer);

    return (struct pipe_texture*)tex;
}

static struct pipe_video_surface *
r300_video_surface_create(struct pipe_screen *screen,
                          enum pipe_video_chroma_format chroma_format,
                          unsigned width, unsigned height)
{
    struct r300_video_surface *r300_vsfc;
    struct pipe_texture template;

    assert(screen);
    assert(width && height);

    r300_vsfc = CALLOC_STRUCT(r300_video_surface);
    if (!r300_vsfc)
       return NULL;

    pipe_reference_init(&r300_vsfc->base.reference, 1);
    r300_vsfc->base.screen = screen;
    r300_vsfc->base.chroma_format = chroma_format;
    r300_vsfc->base.width = width;
    r300_vsfc->base.height = height;

    memset(&template, 0, sizeof(struct pipe_texture));
    template.target = PIPE_TEXTURE_2D;
    template.format = PIPE_FORMAT_B8G8R8X8_UNORM;
    template.last_level = 0;
    template.width0 = util_next_power_of_two(width);
    template.height0 = util_next_power_of_two(height);
    template.depth0 = 1;
    template.tex_usage = PIPE_TEXTURE_USAGE_SAMPLER |
                         PIPE_TEXTURE_USAGE_RENDER_TARGET;
d822 5
a826 5
    r300_vsfc->tex = screen->texture_create(screen, &template);
    if (!r300_vsfc->tex)
    {
        FREE(r300_vsfc);
        return NULL;
d829 3
a831 1
    return &r300_vsfc->base;
d834 11
a844 6
static void r300_video_surface_destroy(struct pipe_video_surface *vsfc)
{
    struct r300_video_surface *r300_vsfc = r300_video_surface(vsfc);
    pipe_texture_reference(&r300_vsfc->tex, NULL);
    FREE(r300_vsfc);
}
d846 2
a847 7
void r300_init_screen_texture_functions(struct pipe_screen* screen)
{
    screen->texture_create = r300_texture_create;
    screen->texture_destroy = r300_texture_destroy;
    screen->get_tex_surface = r300_get_tex_surface;
    screen->tex_surface_destroy = r300_tex_surface_destroy;
    screen->texture_blanket = r300_texture_blanket;
d849 43
a891 3
    screen->video_surface_create = r300_video_surface_create;
    screen->video_surface_destroy= r300_video_surface_destroy;
}
d893 1
a893 9
boolean r300_get_texture_buffer(struct pipe_screen* screen,
                                struct pipe_texture* texture,
                                struct pipe_buffer** buffer,
                                unsigned* stride)
{
    struct r300_texture* tex = (struct r300_texture*)texture;
    if (!tex) {
        return FALSE;
    }
d895 4
a898 1
    pipe_buffer_reference(buffer, tex->buffer);
d900 7
a906 2
    if (stride) {
        *stride = r300_texture_get_stride(r300_screen(screen), tex, 0);
d909 9
a917 1
    return TRUE;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d24 1
a24 9
/* Always include headers in the reverse order!! ~ M. */
#include "r300_texture.h"

#include "r300_context.h"
#include "r300_reg.h"
#include "r300_texture_desc.h"
#include "r300_transfer.h"
#include "r300_screen.h"
#include "r300_winsys.h"
a26 1
#include "util/u_format_s3tc.h"
a28 1
#include "util/u_mm.h"
d30 4
a33 1
#include "pipe/p_screen.h"
d35 1
a35 19
unsigned r300_get_swizzle_combined(const unsigned char *swizzle_format,
                                   const unsigned char *swizzle_view,
                                   boolean dxtc_swizzle)
{
    unsigned i;
    unsigned char swizzle[4];
    unsigned result = 0;
    const uint32_t swizzle_shift[4] = {
        R300_TX_FORMAT_R_SHIFT,
        R300_TX_FORMAT_G_SHIFT,
        R300_TX_FORMAT_B_SHIFT,
        R300_TX_FORMAT_A_SHIFT
    };
    uint32_t swizzle_bit[4] = {
        dxtc_swizzle ? R300_TX_FORMAT_Z : R300_TX_FORMAT_X,
        R300_TX_FORMAT_Y,
        dxtc_swizzle ? R300_TX_FORMAT_X : R300_TX_FORMAT_Z,
        R300_TX_FORMAT_W
    };
d37 2
a38 9
    if (swizzle_view) {
        /* Combine two sets of swizzles. */
        for (i = 0; i < 4; i++) {
            swizzle[i] = swizzle_view[i] <= UTIL_FORMAT_SWIZZLE_W ?
                         swizzle_format[swizzle_view[i]] : swizzle_view[i];
        }
    } else {
        memcpy(swizzle, swizzle_format, 4);
    }
d40 8
a47 24
    /* Get swizzle. */
    for (i = 0; i < 4; i++) {
        switch (swizzle[i]) {
            case UTIL_FORMAT_SWIZZLE_Y:
                result |= swizzle_bit[1] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_Z:
                result |= swizzle_bit[2] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_W:
                result |= swizzle_bit[3] << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_0:
                result |= R300_TX_FORMAT_ZERO << swizzle_shift[i];
                break;
            case UTIL_FORMAT_SWIZZLE_1:
                result |= R300_TX_FORMAT_ONE << swizzle_shift[i];
                break;
            default: /* UTIL_FORMAT_SWIZZLE_X */
                result |= swizzle_bit[0] << swizzle_shift[i];
        }
    }
    return result;
}
d61 1
a61 4
uint32_t r300_translate_texformat(enum pipe_format format,
                                  const unsigned char *swizzle_view,
                                  boolean is_r500,
                                  boolean dxtc_swizzle)
d65 1
a65 1
    unsigned i;
d67 12
d90 1
a90 2
        /* Depth stencil formats.
         * Swizzles are added in r300_merge_textures_and_samplers. */
d94 1
a94 1
                    return R300_TX_FORMAT_X16;
d96 2
a97 5
                case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
                    if (is_r500)
                        return R500_TX_FORMAT_Y8X24;
                    else
                        return R300_TX_FORMAT_Y16X16;
d120 1
a120 9
        default:
            switch (format) {
                /* Same as YUV but without the YUR->RGB conversion. */
                case PIPE_FORMAT_R8G8_B8G8_UNORM:
                    return R300_EASY_TX_FORMAT(X, Y, Z, ONE, YVYU422) | result;
                case PIPE_FORMAT_G8R8_G8B8_UNORM:
                    return R300_EASY_TX_FORMAT(X, Y, Z, ONE, VYUY422) | result;
                default:;
            }
d123 24
a146 7
    result |= r300_get_swizzle_combined(desc->swizzle, swizzle_view,
                    util_format_is_compressed(format) && dxtc_swizzle);

    /* S3TC formats. */
    if (desc->layout == UTIL_FORMAT_LAYOUT_S3TC) {
        if (!util_format_s3tc_enabled) {
            return ~0; /* Unsupported. */
d148 1
d150 2
d169 7
d177 1
a177 1
    for (i = 0; i < desc->nr_channels; i++) {
a182 21
    /* This is truly a special format.
     * It stores R8G8 and B is computed using sqrt(1 - R^2 - G^2)
     * in the sampler unit. Also known as D3DFMT_CxV8U8. */
    if (format == PIPE_FORMAT_R8G8Bx_SNORM) {
        return R300_TX_FORMAT_CxV8U8 | result;
    }

    /* RGTC formats. */
    if (desc->layout == UTIL_FORMAT_LAYOUT_RGTC) {
        switch (format) {
            case PIPE_FORMAT_RGTC1_UNORM:
            case PIPE_FORMAT_RGTC1_SNORM:
                return R500_TX_FORMAT_ATI1N | result;
            case PIPE_FORMAT_RGTC2_UNORM:
            case PIPE_FORMAT_RGTC2_SNORM:
                return R400_TX_FORMAT_ATI2N | result;
            default:
                return ~0; /* Unsupported/unknown. */
        }
    }

d184 1
a184 1
    for (i = 1; i < desc->nr_channels; i++) {
d190 1
a190 1
        switch (desc->nr_channels) {
a220 10
    /* Find the first non-VOID channel. */
    for (i = 0; i < 4; i++) {
        if (desc->channel[i].type != UTIL_FORMAT_TYPE_VOID) {
            break;
        }
    }

    if (i == 4)
        return ~0; /* Unsupported/unknown. */

d222 1
a222 1
    switch (desc->channel[i].type) {
d225 1
a225 1
            if (!desc->channel[i].normalized &&
d230 1
a230 1
            switch (desc->channel[i].size) {
d232 1
a232 1
                    switch (desc->nr_channels) {
d241 1
a241 1
                    switch (desc->nr_channels) {
d252 1
a252 1
                    switch (desc->nr_channels) {
d263 2
d266 1
a266 1
            switch (desc->channel[i].size) {
d268 1
a268 1
                    switch (desc->nr_channels) {
d279 1
a279 1
                    switch (desc->nr_channels) {
d288 1
a293 13
uint32_t r500_tx_format_msb_bit(enum pipe_format format)
{
    switch (format) {
        case PIPE_FORMAT_RGTC1_UNORM:
        case PIPE_FORMAT_RGTC1_SNORM:
        case PIPE_FORMAT_X8Z24_UNORM:
        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
            return R500_TXFORMAT_MSB;
        default:
            return 0;
    }
}

d305 1
a310 5
        case PIPE_FORMAT_L8A8_UNORM:
        case PIPE_FORMAT_R8G8_UNORM:
        case PIPE_FORMAT_R8G8_SNORM:
            return R300_COLOR_FORMAT_UV88;

a312 1

a313 1
        case PIPE_FORMAT_B5G5R5X1_UNORM:
a314 1

a315 1
        case PIPE_FORMAT_B4G4R4X4_UNORM:
d320 1
d322 6
a327 2
        /*case PIPE_FORMAT_B8G8R8X8_SNORM:*/
        case PIPE_FORMAT_R8G8B8A8_UNORM:
d329 4
a332 1
        case PIPE_FORMAT_R8G8B8X8_UNORM:
a333 1

a334 2
        case PIPE_FORMAT_R10G10B10X2_SNORM:
        case PIPE_FORMAT_B10G10R10A2_UNORM:
d340 1
a340 1
        case PIPE_FORMAT_R16G16B16A16_FLOAT:
d343 2
d348 1
d370 1
a370 1
        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
a394 10
    /* Find the first non-VOID channel. */
    for (i = 0; i < 4; i++) {
        if (desc->channel[i].type != UTIL_FORMAT_TYPE_VOID) {
            break;
        }
    }

    if (i == 4)
        return ~0; /* Unsupported/unknown. */

d396 7
a402 2
    if (desc->channel[i].type == UTIL_FORMAT_TYPE_FLOAT) {
        if (desc->channel[i].size == 32) {
d408 1
a408 1
        if (desc->channel[i].size == 16) {
d425 1
a425 1
        /* 8-bit outputs, one channel.
d431 1
d436 1
a436 9
        /* 16-bit outputs, two channels.
         * COLORFORMAT_UV88 stores C2 and C0. */
        case PIPE_FORMAT_L8A8_UNORM:
            return modifier | R300_C0_SEL_A | R300_C2_SEL_R;
        case PIPE_FORMAT_R8G8_UNORM:
        case PIPE_FORMAT_R8G8_SNORM:
            return modifier | R300_C0_SEL_G | R300_C2_SEL_R;

        /* BGRA outputs. */
a438 1
        case PIPE_FORMAT_B5G5R5X1_UNORM:
a439 1
        case PIPE_FORMAT_B4G4R4X4_UNORM:
d441 1
d443 1
a443 1
        case PIPE_FORMAT_B10G10R10A2_UNORM:
d448 11
a458 2
        /* RGBA outputs. */
        case PIPE_FORMAT_R8G8B8X8_UNORM:
d460 9
d470 1
a470 1
        case PIPE_FORMAT_R10G10B10X2_SNORM:
d473 1
a473 1
        case PIPE_FORMAT_R16G16B16A16_FLOAT:
d497 1
a497 1
    return r300_translate_texformat(format, 0, TRUE, FALSE) != ~0;
d500 6
a505 13
void r300_texture_setup_format_state(struct r300_screen *screen,
                                     struct r300_texture_desc *desc,
                                     unsigned level,
                                     struct r300_texture_format_state *out)
{
    struct pipe_resource *pt = &desc->b.b;
    boolean is_r500 = screen->caps.is_r500;

    /* Mask out all the fields we change. */
    out->format0 = 0;
    out->format1 &= ~R300_TX_FORMAT_TEX_COORD_TYPE_MASK;
    out->format2 &= R500_TXFORMAT_MSB;
    out->tile_config = 0;
d508 2
a509 4
    out->format0 =
        R300_TX_WIDTH((u_minify(desc->width0, level) - 1) & 0x7ff) |
        R300_TX_HEIGHT((u_minify(desc->height0, level) - 1) & 0x7ff) |
        R300_TX_DEPTH(util_logbase2(u_minify(desc->depth0, level)) & 0xf);
d511 1
a511 1
    if (desc->uses_stride_addressing) {
d513 5
a517 2
        out->format0 |= R300_TX_PITCH_EN;
        out->format2 = (desc->stride_in_pixels[level] - 1) & 0x1fff;
d520 1
d522 1
a522 1
        out->format1 |= R300_TX_FORMAT_CUBIC_MAP;
d525 1
a525 1
        out->format1 |= R300_TX_FORMAT_3D;
d531 2
a532 2
        if (desc->width0 > 2048) {
            out->format2 |= R500_TXWIDTH_BIT11;
d534 2
a535 2
        if (desc->height0 > 2048) {
            out->format2 |= R500_TXHEIGHT_BIT11;
d539 2
a540 8
    out->tile_config = R300_TXO_MACRO_TILE(desc->macrotile[level]) |
                       R300_TXO_MICRO_TILE(desc->microtile);
}

static void r300_texture_setup_fb_state(struct r300_screen* screen,
                                        struct r300_texture* tex)
{
    unsigned i;
d543 6
a548 6
    if (util_format_is_depth_or_stencil(tex->desc.b.b.format)) {
        for (i = 0; i <= tex->desc.b.b.last_level; i++) {
            tex->fb_state.pitch[i] =
                tex->desc.stride_in_pixels[i] |
                R300_DEPTHMACROTILE(tex->desc.macrotile[i]) |
                R300_DEPTHMICROTILE(tex->desc.microtile);
d550 1
a550 1
        tex->fb_state.format = r300_translate_zsformat(tex->desc.b.b.format);
d552 6
a557 6
        for (i = 0; i <= tex->desc.b.b.last_level; i++) {
            tex->fb_state.pitch[i] =
                tex->desc.stride_in_pixels[i] |
                r300_translate_colorformat(tex->desc.b.b.format) |
                R300_COLOR_TILE(tex->desc.macrotile[i]) |
                R300_COLOR_MICROTILE(tex->desc.microtile);
d559 1
a559 1
        tex->fb_state.format = r300_translate_out_fmt(tex->desc.b.b.format);
d564 1
a564 1
                                     struct pipe_resource *tex,
d569 2
a570 4
    SCREEN_DBG(r300screen, DBG_TEX,
        "r300: texture_reinterpret_format: %s -> %s\n",
        util_format_short_name(tex->format),
        util_format_short_name(new_format));
d574 41
a614 1
    r300_texture_setup_fb_state(r300_screen(screen), r300_texture(tex));
d617 4
a620 3
static unsigned r300_texture_is_referenced(struct pipe_context *context,
                                           struct pipe_resource *texture,
                                           unsigned level, int layer)
d622 1
a622 2
    struct r300_context *r300 = r300_context(context);
    struct r300_texture *rtex = (struct r300_texture *)texture;
d624 2
a625 3
    if (r300->rws->cs_is_buffer_referenced(r300->cs,
                                           rtex->cs_buffer, R300_REF_CS))
        return PIPE_REFERENCED_FOR_READ | PIPE_REFERENCED_FOR_WRITE;
d627 6
a632 1
    return PIPE_UNREFERENCED;
d635 6
a640 2
static void r300_texture_destroy(struct pipe_screen *screen,
                                 struct pipe_resource* texture)
d642 4
a645 3
    struct r300_texture* tex = (struct r300_texture*)texture;
    struct r300_winsys_screen *rws = (struct r300_winsys_screen *)texture->screen->winsys;
    int i;
d647 5
a651 6
    rws->buffer_reference(rws, &tex->buffer, NULL);
    for (i = 0; i < R300_MAX_TEXTURE_LEVELS; i++) {
        if (tex->hiz_mem[i])
            u_mmFreeMem(tex->hiz_mem[i]);
        if (tex->zmask_mem[i])
            u_mmFreeMem(tex->zmask_mem[i]);
d654 11
a664 1
    FREE(tex);
d667 2
a668 3
static boolean r300_texture_get_handle(struct pipe_screen* screen,
                                       struct pipe_resource *texture,
                                       struct winsys_handle *whandle)
d670 3
a672 2
    struct r300_winsys_screen *rws = (struct r300_winsys_screen *)screen->winsys;
    struct r300_texture* tex = (struct r300_texture*)texture;
d674 4
a677 2
    if (!tex) {
        return FALSE;
d680 1
a680 2
    return rws->buffer_get_handle(rws, tex->buffer,
                                  tex->desc.stride_in_bytes[0], whandle);
d683 2
a684 1
struct u_resource_vtbl r300_texture_vtbl =
d686 34
a719 10
   r300_texture_get_handle,	      /* get_handle */
   r300_texture_destroy,	      /* resource_destroy */
   r300_texture_is_referenced,	      /* is_resource_referenced */
   r300_texture_get_transfer,	      /* get_transfer */
   r300_texture_transfer_destroy,     /* transfer_destroy */
   r300_texture_transfer_map,	      /* transfer_map */
   u_default_transfer_flush_region,   /* transfer_flush_region */
   r300_texture_transfer_unmap,	      /* transfer_unmap */
   u_default_transfer_inline_write    /* transfer_inline_write */
};
d721 1
a721 9
/* The common texture constructor. */
static struct r300_texture*
r300_texture_create_object(struct r300_screen *rscreen,
                           const struct pipe_resource *base,
                           enum r300_buffer_tiling microtile,
                           enum r300_buffer_tiling macrotile,
                           unsigned stride_in_bytes_override,
                           unsigned max_buffer_size,
                           struct r300_winsys_buffer *buffer)
d723 13
a735 2
    struct r300_winsys_screen *rws = rscreen->rws;
    struct r300_texture *tex = CALLOC_STRUCT(r300_texture);
a736 2
        if (buffer)
            rws->buffer_reference(rws, &buffer, NULL);
d740 17
a756 7
    /* Initialize the descriptor. */
    if (!r300_texture_desc_init(rscreen, &tex->desc, base,
                                microtile, macrotile,
                                stride_in_bytes_override,
                                max_buffer_size)) {
        if (buffer)
            rws->buffer_reference(rws, &buffer, NULL);
a759 10
    /* Initialize the hardware state. */
    r300_texture_setup_format_state(rscreen, &tex->desc, 0, &tex->tx_format);
    r300_texture_setup_fb_state(rscreen, tex);

    tex->desc.b.vtbl = &r300_texture_vtbl;
    pipe_reference_init(&tex->desc.b.b.reference, 1);
    tex->domain = base->flags & R300_RESOURCE_FLAG_TRANSFER ?
                  R300_DOMAIN_GTT :
                  R300_DOMAIN_VRAM | R300_DOMAIN_GTT;
    tex->buffer = buffer;
d761 2
a762 4
    /* Create the backing buffer if needed. */
    if (!tex->buffer) {
        tex->buffer = rws->buffer_create(rws, tex->desc.size_in_bytes, 2048,
                                         base->bind, base->usage, tex->domain);
d764 3
a766 5
        if (!tex->buffer) {
            FREE(tex);
            return NULL;
        }
    }
d768 1
a768 1
    tex->cs_buffer = rws->buffer_get_cs_handle(rws, tex->buffer);
d770 1
a770 5
    rws->buffer_set_tiling(rws, tex->buffer,
            tex->desc.microtile, tex->desc.macrotile[0],
            tex->desc.stride_in_bytes[0]);

    return tex;
d773 6
a778 3
/* Create a new texture. */
struct pipe_resource *r300_texture_create(struct pipe_screen *screen,
                                          const struct pipe_resource *base)
d780 5
a784 2
    struct r300_screen *rscreen = r300_screen(screen);
    enum r300_buffer_tiling microtile, macrotile;
d786 12
a797 7
    if ((base->flags & R300_RESOURCE_FLAG_TRANSFER) ||
        (base->bind & PIPE_BIND_SCANOUT)) {
        microtile = R300_BUFFER_LINEAR;
        macrotile = R300_BUFFER_LINEAR;
    } else {
        microtile = R300_BUFFER_SELECT_LAYOUT;
        macrotile = R300_BUFFER_SELECT_LAYOUT;
d800 7
a806 3
    return (struct pipe_resource*)
           r300_texture_create_object(rscreen, base, microtile, macrotile,
                                      0, 0, NULL);
d809 5
a813 3
struct pipe_resource *r300_texture_from_handle(struct pipe_screen *screen,
                                               const struct pipe_resource *base,
                                               struct winsys_handle *whandle)
d815 2
a816 5
    struct r300_winsys_screen *rws = (struct r300_winsys_screen*)screen->winsys;
    struct r300_screen *rscreen = r300_screen(screen);
    struct r300_winsys_buffer *buffer;
    enum r300_buffer_tiling microtile, macrotile;
    unsigned stride, size;
d819 1
a819 2
    if ((base->target != PIPE_TEXTURE_2D &&
          base->target != PIPE_TEXTURE_RECT) ||
d825 2
a826 2
    buffer = rws->buffer_from_handle(rws, whandle, &stride, &size);
    if (!buffer)
d828 1
d830 45
a874 1
    rws->buffer_get_tiling(rws, buffer, &microtile, &macrotile);
d876 5
a880 13
    /* Enforce a microtiled zbuffer. */
    if (util_format_is_depth_or_stencil(base->format) &&
        microtile == R300_BUFFER_LINEAR) {
        switch (util_format_get_blocksize(base->format)) {
            case 4:
                microtile = R300_BUFFER_TILED;
                break;

            case 2:
                if (rws->get_value(rws, R300_VID_SQUARE_TILING_SUPPORT))
                    microtile = R300_BUFFER_SQUARETILED;
                break;
        }
d883 1
a883 3
    return (struct pipe_resource*)
           r300_texture_create_object(rscreen, base, microtile, macrotile,
                                      stride, size, buffer);
d886 6
a891 9
/* Not required to implement u_resource_vtbl, consider moving to another file:
 */
struct pipe_surface* r300_create_surface(struct pipe_context * ctx,
                                         struct pipe_resource* texture,
                                         const struct pipe_surface *surf_tmpl)
{
    struct r300_texture* tex = r300_texture(texture);
    struct r300_surface* surface = CALLOC_STRUCT(r300_surface);
    unsigned level = surf_tmpl->u.tex.level;
d893 7
a899 1
    assert(surf_tmpl->u.tex.first_layer == surf_tmpl->u.tex.last_layer);
d901 3
a903 2
    if (surface) {
        uint32_t offset, tile_height;
d905 9
a913 43
        pipe_reference_init(&surface->base.reference, 1);
        pipe_resource_reference(&surface->base.texture, texture);
        surface->base.context = ctx;
        surface->base.format = surf_tmpl->format;
        surface->base.width = u_minify(texture->width0, level);
        surface->base.height = u_minify(texture->height0, level);
        surface->base.usage = surf_tmpl->usage;
        surface->base.u.tex.level = level;
        surface->base.u.tex.first_layer = surf_tmpl->u.tex.first_layer;
        surface->base.u.tex.last_layer = surf_tmpl->u.tex.last_layer;

        surface->buffer = tex->buffer;
        surface->cs_buffer = tex->cs_buffer;

        /* Prefer VRAM if there are multiple domains to choose from. */
        surface->domain = tex->domain;
        if (surface->domain & R300_DOMAIN_VRAM)
            surface->domain &= ~R300_DOMAIN_GTT;

        surface->offset = r300_texture_get_offset(&tex->desc, level,
                                                  surf_tmpl->u.tex.first_layer);
        surface->pitch = tex->fb_state.pitch[level];
        surface->format = tex->fb_state.format;

        /* Parameters for the CBZB clear. */
        surface->cbzb_allowed = tex->desc.cbzb_allowed[level];
        surface->cbzb_width = align(surface->base.width, 64);

        /* Height must be aligned to the size of a tile. */
        tile_height = r300_get_pixel_alignment(tex->desc.b.b.format,
                                               tex->desc.b.b.nr_samples,
                                               tex->desc.microtile,
                                               tex->desc.macrotile[level],
                                               DIM_HEIGHT, 0);

        surface->cbzb_height = align((surface->base.height + 1) / 2,
                                     tile_height);

        /* Offset must be aligned to 2K and must point at the beginning
         * of a scanline. */
        offset = surface->offset +
                 tex->desc.stride_in_bytes[level] * surface->cbzb_height;
        surface->cbzb_midpoint_offset = offset & ~2047;
d915 1
a915 1
        surface->cbzb_pitch = surface->pitch & 0x1ffffc;
d917 2
a918 12
        if (util_format_get_blocksizebits(surface->base.format) == 32)
            surface->cbzb_format = R300_DEPTHFORMAT_24BIT_INT_Z_8BIT_STENCIL;
        else
            surface->cbzb_format = R300_DEPTHFORMAT_16BIT_INT_Z;

        DBG(r300_context(ctx), DBG_CBZB,
            "CBZB Allowed: %s, Dim: %ix%i, Misalignment: %i, Micro: %s, Macro: %s\n",
            surface->cbzb_allowed ? "YES" : " NO",
            surface->cbzb_width, surface->cbzb_height,
            offset & 2047,
            tex->desc.microtile ? "YES" : " NO",
            tex->desc.macrotile[level] ? "YES" : " NO");
d921 1
a921 9
    return &surface->base;
}

/* Not required to implement u_resource_vtbl, consider moving to another file:
 */
void r300_surface_destroy(struct pipe_context *ctx, struct pipe_surface* s)
{
    pipe_resource_reference(&s->texture, NULL);
    FREE(s);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d32 1
d64 4
a67 1
        util_format_compose_swizzles(swizzle_format, swizzle_view, swizzle);
d119 3
a122 3
        R300_TX_FORMAT_SIGNED_Z,
        R300_TX_FORMAT_SIGNED_Y,
        R300_TX_FORMAT_SIGNED_X,
d136 1
a136 1
                case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d174 2
a175 17
    /* Add swizzling. */
    /* The RGTC1_SNORM and LATC1_SNORM swizzle is done in the shader. */
    if (format != PIPE_FORMAT_RGTC1_SNORM &&
        format != PIPE_FORMAT_LATC1_SNORM) {
        if (util_format_is_compressed(format) &&
            dxtc_swizzle &&
            format != PIPE_FORMAT_RGTC2_UNORM &&
            format != PIPE_FORMAT_RGTC2_SNORM &&
            format != PIPE_FORMAT_LATC2_UNORM &&
            format != PIPE_FORMAT_LATC2_SNORM) {
            result |= r300_get_swizzle_combined(desc->swizzle, swizzle_view,
                                                TRUE);
        } else {
            result |= r300_get_swizzle_combined(desc->swizzle, swizzle_view,
                                                FALSE);
        }
    }
d200 4
a203 18
    /* RGTC formats. */
    if (desc->layout == UTIL_FORMAT_LAYOUT_RGTC) {
        switch (format) {
            case PIPE_FORMAT_RGTC1_SNORM:
            case PIPE_FORMAT_LATC1_SNORM:
            case PIPE_FORMAT_LATC1_UNORM:
            case PIPE_FORMAT_RGTC1_UNORM:
                return R500_TX_FORMAT_ATI1N | result;

            case PIPE_FORMAT_RGTC2_SNORM:
            case PIPE_FORMAT_LATC2_SNORM:
                result |= sign_bit[1] | sign_bit[0];
            case PIPE_FORMAT_RGTC2_UNORM:
            case PIPE_FORMAT_LATC2_UNORM:
                return R400_TX_FORMAT_ATI2N | result;

            default:
                return ~0; /* Unsupported/unknown. */
d214 11
a224 15
    /* Integer and fixed-point 16.16 textures are not supported. */
    for (i = 0; i < 4; i++) {
        if (desc->channel[i].type == UTIL_FORMAT_TYPE_FIXED ||
            ((desc->channel[i].type == UTIL_FORMAT_TYPE_SIGNED ||
              desc->channel[i].type == UTIL_FORMAT_TYPE_UNSIGNED) &&
             (!desc->channel[i].normalized ||
              desc->channel[i].pure_integer))) {
            return ~0; /* Unsupported/unknown. */
        }
    }

    /* Add sign. */
    for (i = 0; i < desc->nr_channels; i++) {
        if (desc->channel[i].type == UTIL_FORMAT_TYPE_SIGNED) {
            result |= sign_bit[i];
a246 5
                if (desc->channel[0].size == 2 &&
                    desc->channel[1].size == 3 &&
                    desc->channel[2].size == 3) {
                    return R300_TX_FORMAT_Z3Y3X2 | result;
                }
a350 2
        case PIPE_FORMAT_LATC1_UNORM:
        case PIPE_FORMAT_LATC1_SNORM:
d352 1
a352 1
        case PIPE_FORMAT_S8_UINT_Z24_UNORM:
a367 1
        case PIPE_FORMAT_A8_SNORM:
a368 1
        case PIPE_FORMAT_I8_SNORM:
a369 1
        case PIPE_FORMAT_L8_SNORM:
a375 1
        case PIPE_FORMAT_L8A8_SNORM:
a377 15
        case PIPE_FORMAT_R8A8_UNORM:
        case PIPE_FORMAT_R8A8_SNORM:
        /* These formats work fine with UV88 if US_OUT_FMT is set correctly. */
        case PIPE_FORMAT_A16_UNORM:
        case PIPE_FORMAT_A16_SNORM:
        case PIPE_FORMAT_A16_FLOAT:
        case PIPE_FORMAT_L16_UNORM:
        case PIPE_FORMAT_L16_SNORM:
        case PIPE_FORMAT_L16_FLOAT:
        case PIPE_FORMAT_I16_UNORM:
        case PIPE_FORMAT_I16_SNORM:
        case PIPE_FORMAT_I16_FLOAT:
        case PIPE_FORMAT_R16_UNORM:
        case PIPE_FORMAT_R16_SNORM:
        case PIPE_FORMAT_R16_FLOAT:
a392 1
        /*case PIPE_FORMAT_B8G8R8A8_SNORM:*/
a397 16
        case PIPE_FORMAT_R8G8B8X8_SNORM:
        /* These formats work fine with ARGB8888 if US_OUT_FMT is set
         * correctly. */
        case PIPE_FORMAT_R16G16_UNORM:
        case PIPE_FORMAT_R16G16_SNORM:
        case PIPE_FORMAT_R16G16_FLOAT:
        case PIPE_FORMAT_L16A16_UNORM:
        case PIPE_FORMAT_L16A16_SNORM:
        case PIPE_FORMAT_L16A16_FLOAT:
        case PIPE_FORMAT_R16A16_UNORM:
        case PIPE_FORMAT_R16A16_SNORM:
        case PIPE_FORMAT_R16A16_FLOAT:
        case PIPE_FORMAT_A32_FLOAT:
        case PIPE_FORMAT_L32_FLOAT:
        case PIPE_FORMAT_I32_FLOAT:
        case PIPE_FORMAT_R32_FLOAT:
a402 1
        case PIPE_FORMAT_B10G10R10X2_UNORM:
a408 8
        case PIPE_FORMAT_R16G16B16X16_UNORM:
        case PIPE_FORMAT_R16G16B16X16_SNORM:
        case PIPE_FORMAT_R16G16B16X16_FLOAT:
        /* These formats work fine with ARGB16161616 if US_OUT_FMT is set
         * correctly. */
        case PIPE_FORMAT_R32G32_FLOAT:
        case PIPE_FORMAT_L32A32_FLOAT:
        case PIPE_FORMAT_R32A32_FLOAT:
a412 1
        case PIPE_FORMAT_R32G32B32X32_FLOAT:
d435 1
a435 1
        case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d451 6
a456 1
    boolean uniform_sign;
d471 5
a475 30
    switch (desc->channel[i].type) {
    case UTIL_FORMAT_TYPE_FLOAT:
        switch (desc->channel[i].size) {
        case 32:
            switch (desc->nr_channels) {
            case 1:
                modifier |= R300_US_OUT_FMT_C_32_FP;
                break;
            case 2:
                modifier |= R300_US_OUT_FMT_C2_32_FP;
                break;
            case 4:
                modifier |= R300_US_OUT_FMT_C4_32_FP;
                break;
            }
            break;

        case 16:
            switch (desc->nr_channels) {
            case 1:
                modifier |= R300_US_OUT_FMT_C_16_FP;
                break;
            case 2:
                modifier |= R300_US_OUT_FMT_C2_16_FP;
                break;
            case 4:
                modifier |= R300_US_OUT_FMT_C4_16_FP;
                break;
            }
            break;
d477 4
a480 23
        break;

    default:
        switch (desc->channel[i].size) {
        case 16:
            switch (desc->nr_channels) {
            case 1:
                modifier |= R300_US_OUT_FMT_C_16;
                break;
            case 2:
                modifier |= R300_US_OUT_FMT_C2_16;
                break;
            case 4:
                modifier |= R300_US_OUT_FMT_C4_16;
                break;
            }
            break;

        case 10:
            modifier |= R300_US_OUT_FMT_C4_10;
            break;

        default:
a483 1
            break;
d488 4
a491 7
    uniform_sign = TRUE;
    for (i = 0; i < desc->nr_channels; i++)
        if (desc->channel[i].type != UTIL_FORMAT_TYPE_SIGNED)
            uniform_sign = FALSE;

    if (uniform_sign)
        modifier |= R300_OUT_SIGN(0xf);
d495 2
a496 4
        /*** Special cases (non-standard channel mapping) ***/

        /* X8
         * COLORFORMAT_I8 stores the Z component (C2). */
a497 1
        case PIPE_FORMAT_A8_SNORM:
a499 1
        case PIPE_FORMAT_I8_SNORM:
a500 1
        case PIPE_FORMAT_L8_SNORM:
d505 2
a506 3
        /* X8Y8
         * COLORFORMAT_UV88 stores ZX (C2 and C0). */
        case PIPE_FORMAT_L8A8_SNORM:
a507 2
        case PIPE_FORMAT_R8A8_SNORM:
        case PIPE_FORMAT_R8A8_UNORM:
d509 1
a510 1
        case PIPE_FORMAT_R8G8_UNORM:
a512 7
        /* X32Y32
         * ARGB16161616 stores XZ for RG32F */
        case PIPE_FORMAT_R32G32_FLOAT:
            return modifier | R300_C0_SEL_R | R300_C2_SEL_G;

        /*** Generic cases (standard channel mapping) ***/

a519 1
        /*case PIPE_FORMAT_B8G8R8A8_SNORM:*/
a520 1
        /*case PIPE_FORMAT_B8G8R8X8_SNORM:*/
a521 1
        case PIPE_FORMAT_B10G10R10X2_UNORM:
a525 9
        /* ARGB outputs. */
        case PIPE_FORMAT_A16_UNORM:
        case PIPE_FORMAT_A16_SNORM:
        case PIPE_FORMAT_A16_FLOAT:
        case PIPE_FORMAT_A32_FLOAT:
            return modifier |
                R300_C0_SEL_A | R300_C1_SEL_R |
                R300_C2_SEL_G | R300_C3_SEL_B;

a527 2
        case PIPE_FORMAT_R8G8B8X8_SNORM:
        case PIPE_FORMAT_R8G8B8A8_UNORM:
a530 2
        case PIPE_FORMAT_R16_UNORM:
        case PIPE_FORMAT_R16G16_UNORM:
a531 2
        case PIPE_FORMAT_R16_SNORM:
        case PIPE_FORMAT_R16G16_SNORM:
a532 2
        case PIPE_FORMAT_R16_FLOAT:
        case PIPE_FORMAT_R16G16_FLOAT:
a533 1
        case PIPE_FORMAT_R32_FLOAT:
a534 12
        case PIPE_FORMAT_R32G32B32X32_FLOAT:
        case PIPE_FORMAT_L16_UNORM:
        case PIPE_FORMAT_L16_SNORM:
        case PIPE_FORMAT_L16_FLOAT:
        case PIPE_FORMAT_L32_FLOAT:
        case PIPE_FORMAT_I16_UNORM:
        case PIPE_FORMAT_I16_SNORM:
        case PIPE_FORMAT_I16_FLOAT:
        case PIPE_FORMAT_I32_FLOAT:
        case PIPE_FORMAT_R16G16B16X16_UNORM:
        case PIPE_FORMAT_R16G16B16X16_SNORM:
        case PIPE_FORMAT_R16G16B16X16_FLOAT:
a538 12
        /* LA outputs. */
        case PIPE_FORMAT_L16A16_UNORM:
        case PIPE_FORMAT_L16A16_SNORM:
        case PIPE_FORMAT_L16A16_FLOAT:
        case PIPE_FORMAT_R16A16_UNORM:
        case PIPE_FORMAT_R16A16_SNORM:
        case PIPE_FORMAT_R16A16_FLOAT:
        case PIPE_FORMAT_L32A32_FLOAT:
        case PIPE_FORMAT_R32A32_FLOAT:
            return modifier |
                R300_C0_SEL_R | R300_C1_SEL_A;

a543 92
static uint32_t r300_translate_colormask_swizzle(enum pipe_format format)
{
    switch (format) {
    case PIPE_FORMAT_A8_UNORM:
    case PIPE_FORMAT_A8_SNORM:
    case PIPE_FORMAT_A16_UNORM:
    case PIPE_FORMAT_A16_SNORM:
    case PIPE_FORMAT_A16_FLOAT:
    case PIPE_FORMAT_A32_FLOAT:
        return COLORMASK_AAAA;

    case PIPE_FORMAT_I8_UNORM:
    case PIPE_FORMAT_I8_SNORM:
    case PIPE_FORMAT_L8_UNORM:
    case PIPE_FORMAT_L8_SNORM:
    case PIPE_FORMAT_R8_UNORM:
    case PIPE_FORMAT_R8_SNORM:
    case PIPE_FORMAT_R32_FLOAT:
    case PIPE_FORMAT_L32_FLOAT:
    case PIPE_FORMAT_I32_FLOAT:
        return COLORMASK_RRRR;

    case PIPE_FORMAT_L8A8_SNORM:
    case PIPE_FORMAT_L8A8_UNORM:
    case PIPE_FORMAT_R8A8_UNORM:
    case PIPE_FORMAT_R8A8_SNORM:
    case PIPE_FORMAT_L16A16_UNORM:
    case PIPE_FORMAT_L16A16_SNORM:
    case PIPE_FORMAT_L16A16_FLOAT:
    case PIPE_FORMAT_R16A16_UNORM:
    case PIPE_FORMAT_R16A16_SNORM:
    case PIPE_FORMAT_R16A16_FLOAT:
    case PIPE_FORMAT_L32A32_FLOAT:
    case PIPE_FORMAT_R32A32_FLOAT:
        return COLORMASK_ARRA;

    case PIPE_FORMAT_R8G8_SNORM:
    case PIPE_FORMAT_R8G8_UNORM:
    case PIPE_FORMAT_R16G16_UNORM:
    case PIPE_FORMAT_R16G16_SNORM:
    case PIPE_FORMAT_R16G16_FLOAT:
    case PIPE_FORMAT_R32G32_FLOAT:
        return COLORMASK_GRRG;

    case PIPE_FORMAT_B5G5R5X1_UNORM:
    case PIPE_FORMAT_B4G4R4X4_UNORM:
    case PIPE_FORMAT_B8G8R8X8_UNORM:
    /*case PIPE_FORMAT_B8G8R8X8_SNORM:*/
    case PIPE_FORMAT_B10G10R10X2_UNORM:
        return COLORMASK_BGRX;

    case PIPE_FORMAT_B5G6R5_UNORM:
    case PIPE_FORMAT_B5G5R5A1_UNORM:
    case PIPE_FORMAT_B4G4R4A4_UNORM:
    case PIPE_FORMAT_B8G8R8A8_UNORM:
    /*case PIPE_FORMAT_B8G8R8A8_SNORM:*/
    case PIPE_FORMAT_B10G10R10A2_UNORM:
        return COLORMASK_BGRA;

    case PIPE_FORMAT_R8G8B8X8_UNORM:
    /* RGBX_SNORM formats are broken for an unknown reason */
    /*case PIPE_FORMAT_R8G8B8X8_SNORM:*/
    /*case PIPE_FORMAT_R10G10B10X2_SNORM:*/
    case PIPE_FORMAT_R16G16B16X16_UNORM:
    /*case PIPE_FORMAT_R16G16B16X16_SNORM:*/
    case PIPE_FORMAT_R16G16B16X16_FLOAT:
    case PIPE_FORMAT_R32G32B32X32_FLOAT:
        return COLORMASK_RGBX;

    case PIPE_FORMAT_R8G8B8A8_UNORM:
    case PIPE_FORMAT_R8G8B8A8_SNORM:
    case PIPE_FORMAT_R10G10B10A2_UNORM:
    case PIPE_FORMAT_R16_UNORM:
    case PIPE_FORMAT_R16G16B16A16_UNORM:
    case PIPE_FORMAT_R16_SNORM:
    case PIPE_FORMAT_R16G16B16A16_SNORM:
    case PIPE_FORMAT_R16_FLOAT:
    case PIPE_FORMAT_R16G16B16A16_FLOAT:
    case PIPE_FORMAT_R32G32B32A32_FLOAT:
    case PIPE_FORMAT_L16_UNORM:
    case PIPE_FORMAT_L16_SNORM:
    case PIPE_FORMAT_L16_FLOAT:
    case PIPE_FORMAT_I16_UNORM:
    case PIPE_FORMAT_I16_SNORM:
    case PIPE_FORMAT_I16_FLOAT:
        return COLORMASK_RGBA;

    default:
        return ~0; /* Unsupported. */
    }
}

d547 1
a547 2
           r300_translate_out_fmt(format) != ~0 &&
           r300_translate_colormask_swizzle(format) != ~0;
d561 1
a561 2
                                     struct r300_resource *tex,
                                     enum pipe_format format,
a562 2
                                     unsigned width0_override,
                                     unsigned height0_override,
d565 1
a565 2
    struct pipe_resource *pt = &tex->b.b;
    struct r300_texture_desc *desc = &tex->tex;
a566 10
    unsigned width, height, depth;
    unsigned txwidth, txheight, txdepth;

    width = u_minify(width0_override, level);
    height = u_minify(height0_override, level);
    depth = u_minify(desc->depth0, level);

    txwidth = (width - 1) & 0x7ff;
    txheight = (height - 1) & 0x7ff;
    txdepth = util_logbase2(depth) & 0xf;
d576 3
a578 3
        R300_TX_WIDTH(txwidth) |
        R300_TX_HEIGHT(txheight) |
        R300_TX_DEPTH(txdepth);
a580 2
        unsigned stride =
            r300_stride_to_width(format, desc->stride_in_bytes[level]);
d583 1
a583 1
        out->format2 = (stride - 1) & 0x1fff;
d596 1
a596 5
        unsigned us_width = txwidth;
        unsigned us_height = txheight;
        unsigned us_depth = txdepth;

        if (width > 2048) {
d599 1
a599 1
        if (height > 2048) {
a601 16

        /* The US_FORMAT register fixes an R500 TX addressing bug.
         * Don't ask why it must be set like this. I don't know it either. */
        if (width > 2048) {
            us_width = (0x000007FF + us_width) >> 1;
            us_depth |= 0x0000000D;
        }
        if (height > 2048) {
            us_height = (0x000007FF + us_height) >> 1;
            us_depth |= 0x0000000E;
        }

        out->us_format0 =
            R300_TX_WIDTH(us_width) |
            R300_TX_HEIGHT(us_height) |
            R300_TX_DEPTH(us_depth);
d608 2
a609 1
static void r300_texture_setup_fb_state(struct r300_surface *surf)
d611 1
a611 4
    struct r300_resource *tex = r300_resource(surf->base.texture);
    unsigned level = surf->base.u.tex.level;
    unsigned stride =
      r300_stride_to_width(surf->base.format, tex->tex.stride_in_bytes[level]);
d614 8
a621 8
    if (util_format_is_depth_or_stencil(surf->base.format)) {
        surf->pitch =
                stride |
                R300_DEPTHMACROTILE(tex->tex.macrotile[level]) |
                R300_DEPTHMICROTILE(tex->tex.microtile);
        surf->format = r300_translate_zsformat(surf->base.format);
        surf->pitch_zmask = tex->tex.zmask_stride_in_pixels[level];
        surf->pitch_hiz = tex->tex.hiz_stride_in_pixels[level];
d623 8
a630 9
        surf->pitch =
                stride |
                r300_translate_colorformat(surf->base.format) |
                R300_COLOR_TILE(tex->tex.macrotile[level]) |
                R300_COLOR_MICROTILE(tex->tex.microtile);
        surf->format = r300_translate_out_fmt(surf->base.format);
        surf->colormask_swizzle =
            r300_translate_colormask_swizzle(surf->base.format);
        surf->pitch_cmask = tex->tex.cmask_stride_in_pixels;
d634 30
d667 11
a677 2
    struct r300_screen *rscreen = r300_screen(screen);
    struct r300_resource* tex = (struct r300_resource*)texture;
a678 8
    if (tex->tex.cmask_dwords) {
        pipe_mutex_lock(rscreen->cmask_mutex);
        if (texture == rscreen->cmask_resource) {
            rscreen->cmask_resource = NULL;
        }
        pipe_mutex_unlock(rscreen->cmask_mutex);
    }
    pb_reference(&tex->buf, NULL);
d682 3
a684 3
boolean r300_resource_get_handle(struct pipe_screen* screen,
                                 struct pipe_resource *texture,
                                 struct winsys_handle *whandle)
d686 2
a687 2
    struct radeon_winsys *rws = r300_screen(screen)->rws;
    struct r300_resource* tex = (struct r300_resource*)texture;
d693 2
a694 2
    return rws->buffer_get_handle(tex->buf,
                                  tex->tex.stride_in_bytes[0], whandle);
d697 1
a697 1
static const struct u_resource_vtbl r300_texture_vtbl =
d699 9
a707 6
    NULL,                           /* get_handle */
    r300_texture_destroy,           /* resource_destroy */
    r300_texture_transfer_map,      /* transfer_map */
    NULL,                           /* transfer_flush_region */
    r300_texture_transfer_unmap,    /* transfer_unmap */
    NULL /* transfer_inline_write */
d711 1
a711 1
static struct r300_resource*
d714 2
a715 2
                           enum radeon_bo_layout microtile,
                           enum radeon_bo_layout macrotile,
d717 2
a718 1
                           struct pb_buffer *buffer)
d720 2
a721 4
    struct radeon_winsys *rws = rscreen->rws;
    struct r300_resource *tex = NULL;

    tex = CALLOC_STRUCT(r300_resource);
d723 3
a725 1
        goto fail;
d728 9
a736 30
    pipe_reference_init(&tex->b.b.reference, 1);
    tex->b.b.screen = &rscreen->screen;
    tex->b.b.usage = base->usage;
    tex->b.b.bind = base->bind;
    tex->b.b.flags = base->flags;
    tex->b.vtbl = &r300_texture_vtbl;
    tex->tex.microtile = microtile;
    tex->tex.macrotile[0] = macrotile;
    tex->tex.stride_in_bytes_override = stride_in_bytes_override;
    tex->domain = (base->flags & R300_RESOURCE_FLAG_TRANSFER ||
                   base->usage == PIPE_USAGE_STAGING) ? RADEON_DOMAIN_GTT :
                  base->nr_samples > 1 ? RADEON_DOMAIN_VRAM :
                                         RADEON_DOMAIN_VRAM | RADEON_DOMAIN_GTT;
    tex->buf = buffer;

    r300_texture_desc_init(rscreen, tex, base);

    /* Figure out the ideal placement for the texture.. */
    if (tex->domain & RADEON_DOMAIN_VRAM &&
        tex->tex.size_in_bytes >= rscreen->info.vram_size) {
        tex->domain &= ~RADEON_DOMAIN_VRAM;
        tex->domain |= RADEON_DOMAIN_GTT;
    }
    if (tex->domain & RADEON_DOMAIN_GTT &&
        tex->tex.size_in_bytes >= rscreen->info.gart_size) {
        tex->domain &= ~RADEON_DOMAIN_GTT;
    }
    /* Just fail if the texture is too large. */
    if (!tex->domain) {
        goto fail;
d738 10
d750 3
a752 3
    if (!tex->buf) {
        tex->buf = rws->buffer_create(rws, tex->tex.size_in_bytes, 2048, TRUE,
                                      tex->domain);
d754 3
a756 2
        if (!tex->buf) {
            goto fail;
d760 1
a760 5
    if (SCREEN_DBG_ON(rscreen, DBG_MSAA) && base->nr_samples > 1) {
        fprintf(stderr, "r300: %ix MSAA %s buffer created\n",
                base->nr_samples,
                util_format_is_depth_or_stencil(base->format) ? "depth" : "color");
    }
d762 3
a764 6
    tex->cs_buf = rws->buffer_get_cs_handle(tex->buf);

    rws->buffer_set_tiling(tex->buf, NULL,
            tex->tex.microtile, tex->tex.macrotile[0],
            0, 0, 0, 0, 0,
            tex->tex.stride_in_bytes[0]);
a766 6

fail:
    FREE(tex);
    if (buffer)
        pb_reference(&buffer, NULL);
    return NULL;
d774 1
a774 1
    enum radeon_bo_layout microtile, macrotile;
d778 2
a779 2
        microtile = RADEON_LAYOUT_LINEAR;
        macrotile = RADEON_LAYOUT_LINEAR;
d781 2
a782 3
        /* This will make the texture_create_function select the layout. */
        microtile = RADEON_LAYOUT_UNKNOWN;
        macrotile = RADEON_LAYOUT_UNKNOWN;
d787 1
a787 1
                                      0, NULL);
d794 1
d796 3
a798 4
    struct radeon_winsys *rws = rscreen->rws;
    struct pb_buffer *buffer;
    enum radeon_bo_layout microtile, macrotile;
    unsigned stride;
d808 1
a808 1
    buffer = rws->buffer_from_handle(rws, whandle, &stride);
d812 1
a812 1
    rws->buffer_get_tiling(buffer, &microtile, &macrotile, NULL, NULL, NULL, NULL, NULL);
d816 1
a816 1
        microtile == RADEON_LAYOUT_LINEAR) {
d819 1
a819 1
                microtile = RADEON_LAYOUT_TILED;
d823 2
a824 1
                microtile = RADEON_LAYOUT_SQUARETILED;
d831 1
a831 1
                                      stride, buffer);
d836 1
a836 1
struct pipe_surface* r300_create_surface_custom(struct pipe_context * ctx,
d838 1
a838 3
                                         const struct pipe_surface *surf_tmpl,
                                         unsigned width0_override,
					 unsigned height0_override)
d840 1
a840 1
    struct r300_resource* tex = r300_resource(texture);
d853 3
a855 2
        surface->base.width = u_minify(width0_override, level);
        surface->base.height = u_minify(height0_override, level);
d860 2
a861 2
        surface->buf = tex->buf;
        surface->cs_buf = tex->cs_buf;
d865 2
a866 2
        if (surface->domain & RADEON_DOMAIN_VRAM)
            surface->domain &= ~RADEON_DOMAIN_GTT;
d868 1
a868 1
        surface->offset = r300_texture_get_offset(tex, level,
d870 2
a871 1
        r300_texture_setup_fb_state(surface);
d874 1
a874 1
        surface->cbzb_allowed = tex->tex.cbzb_allowed[level];
d878 4
a881 4
        tile_height = r300_get_pixel_alignment(surface->base.format,
                                               tex->b.b.nr_samples,
                                               tex->tex.microtile,
                                               tex->tex.macrotile[level],
d890 1
a890 1
                 tex->tex.stride_in_bytes[level] * surface->cbzb_height;
d905 2
a906 2
            tex->tex.microtile ? "YES" : " NO",
            tex->tex.macrotile[level] ? "YES" : " NO");
a909 9
}

struct pipe_surface* r300_create_surface(struct pipe_context * ctx,
                                         struct pipe_resource* texture,
                                         const struct pipe_surface *surf_tmpl)
{
    return r300_create_surface_custom(ctx, texture, surf_tmpl,
                                      texture->width0,
                                      texture->height0);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d1063 1
a1063 1
            tex->tex.stride_in_bytes[0], false);
d1082 1
a1082 1
        (base->bind & (PIPE_BIND_SCANOUT | PIPE_BIND_LINEAR))) {
d1118 1
a1118 2
    rws->buffer_get_tiling(buffer, &microtile, &macrotile, NULL, NULL, NULL,
                           NULL, NULL, NULL);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d1045 1
a1045 1
                                      tex->domain, 0);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d1045 1
a1045 1
                                      tex->domain);
@


