head	1.3;
access;
symbols
	OPENBSD_5_8:1.2.0.12
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.10
	OPENBSD_5_7_BASE:1.2
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.2.0.8
	OPENBSD_5_6_BASE:1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.2;
commitid	TnlogFl9nOv2eaRf;

1.2
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.59;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2009 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "r300_context.h"
#include "r300_reg.h"
#include "r300_fs.h"

#include "util/u_format.h"
#include "util/u_mm.h"

/*
  HiZ rules - taken from various docs 
   1. HiZ only works on depth values
   2. Cannot HiZ if stencil fail or zfail is !KEEP
   3. on R300/400, HiZ is disabled if depth test is EQUAL
   4. comparison changes without clears usually mean disabling HiZ
*/
/*****************************************************************************/
/* The HyperZ setup                                                          */
/*****************************************************************************/

static enum r300_hiz_func r300_get_hiz_func(struct r300_context *r300)
{
    struct r300_dsa_state *dsa = r300->dsa_state.state;

    switch (dsa->dsa.depth.func) {
    case PIPE_FUNC_NEVER:
    case PIPE_FUNC_EQUAL:
    case PIPE_FUNC_NOTEQUAL:
    case PIPE_FUNC_ALWAYS:
    default:
        /* Guess MAX for uncertain cases. */
    case PIPE_FUNC_LESS:
    case PIPE_FUNC_LEQUAL:
        return HIZ_FUNC_MAX;

    case PIPE_FUNC_GREATER:
    case PIPE_FUNC_GEQUAL:
        return HIZ_FUNC_MIN;
    }
}

/* Return what's used for the depth test (either minimum or maximum). */
static unsigned r300_get_sc_hz_max(struct r300_context *r300)
{
    struct r300_dsa_state *dsa = r300->dsa_state.state;
    unsigned func = dsa->dsa.depth.func;

    return func >= PIPE_FUNC_GREATER ? R300_SC_HYPERZ_MAX : R300_SC_HYPERZ_MIN;
}

static boolean r300_is_hiz_func_valid(struct r300_context *r300)
{
    struct r300_dsa_state *dsa = r300->dsa_state.state;
    unsigned func = dsa->dsa.depth.func;

    if (r300->hiz_func == HIZ_FUNC_NONE)
        return TRUE;

    /* func1 is less/lessthan */
    if (r300->hiz_func == HIZ_FUNC_MAX &&
        (func == PIPE_FUNC_GEQUAL || func == PIPE_FUNC_GREATER))
        return FALSE;

    /* func1 is greater/greaterthan */
    if (r300->hiz_func == HIZ_FUNC_MIN &&
        (func == PIPE_FUNC_LESS   || func == PIPE_FUNC_LEQUAL))
        return FALSE;

    return TRUE;
}

static boolean r300_dsa_stencil_op_not_keep(struct pipe_stencil_state *s)
{
    return s->enabled && (s->fail_op != PIPE_STENCIL_OP_KEEP ||
                          s->zfail_op != PIPE_STENCIL_OP_KEEP);
}

static boolean r300_hiz_allowed(struct r300_context *r300)
{
    struct r300_dsa_state *dsa = r300->dsa_state.state;
    struct r300_screen *r300screen = r300->screen;

    if (r300_fragment_shader_writes_depth(r300_fs(r300)))
        return FALSE;

    if (r300->query_current)
        return FALSE;

    /* If the depth function is inverted, HiZ must be disabled. */
    if (!r300_is_hiz_func_valid(r300))
        return FALSE;

    /* if stencil fail/zfail op is not KEEP */
    if (r300_dsa_stencil_op_not_keep(&dsa->dsa.stencil[0]) ||
        r300_dsa_stencil_op_not_keep(&dsa->dsa.stencil[1]))
        return FALSE;

    if (dsa->dsa.depth.enabled) {
        /* if depth func is EQUAL pre-r500 */
        if (dsa->dsa.depth.func == PIPE_FUNC_EQUAL && !r300screen->caps.is_r500)
            return FALSE;

        /* if depth func is NOTEQUAL */
        if (dsa->dsa.depth.func == PIPE_FUNC_NOTEQUAL)
            return FALSE;
    }
    return TRUE;
}

static void r300_update_hyperz(struct r300_context* r300)
{
    struct r300_hyperz_state *z =
        (struct r300_hyperz_state*)r300->hyperz_state.state;
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    struct r300_dsa_state *dsa = r300->dsa_state.state;
    struct r300_resource *zstex =
            fb->zsbuf ? r300_resource(fb->zsbuf->texture) : NULL;

    z->gb_z_peq_config = 0;
    z->zb_bw_cntl = 0;
    z->sc_hyperz = R300_SC_HYPERZ_ADJ_2;
    z->flush = 0;

    if (r300->cbzb_clear) {
        z->zb_bw_cntl |= R300_ZB_CB_CLEAR_CACHE_LINE_WRITE_ONLY;
        return;
    }

    if (!zstex || !r300->hyperz_enabled)
        return;

    /* Set the size of ZMASK tiles. */
    if (zstex->tex.zcomp8x8[fb->zsbuf->u.tex.level]) {
        z->gb_z_peq_config |= R300_GB_Z_PEQ_CONFIG_Z_PEQ_SIZE_8_8;
    }

    /* R500-specific features and optimizations. */
    if (r300->screen->caps.is_r500) {
        z->zb_bw_cntl |= R500_PEQ_PACKING_ENABLE |
                         R500_COVERED_PTR_MASKING_ENABLE;
    }

    /* Setup decompression if needed. No other HyperZ setting is required. */
    if (r300->zmask_decompress) {
        z->zb_bw_cntl |= R300_FAST_FILL_ENABLE |
                         R300_RD_COMP_ENABLE;
        return;
    }

    /* Do not set anything if depth and stencil tests are off. */
    if (!dsa->dsa.depth.enabled &&
        !dsa->dsa.stencil[0].enabled &&
        !dsa->dsa.stencil[1].enabled) {
        assert(!dsa->dsa.depth.writemask);
        return;
    }

    /* Zbuffer compression. */
    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        z->zb_bw_cntl |= R300_FAST_FILL_ENABLE |
                         R300_RD_COMP_ENABLE |
                         R300_WR_COMP_ENABLE;
    }

    /* HiZ. */
    if (r300->hiz_in_use && !r300->locked_zbuffer) {
        /* HiZ cannot be used under some circumstances. */
        if (!r300_hiz_allowed(r300)) {
            /* If writemask is disabled, the HiZ memory will not be changed,
             * so we can keep its content for later. */
            if (dsa->dsa.depth.writemask) {
                r300->hiz_in_use = FALSE;
            }
            return;
        }
        DBG(r300, DBG_HYPERZ, "r300: Z-func: %i\n", dsa->dsa.depth.func);

        /* Set the HiZ function if needed. */
        if (r300->hiz_func == HIZ_FUNC_NONE) {
            r300->hiz_func = r300_get_hiz_func(r300);
        }

        /* Setup the HiZ bits. */
        z->zb_bw_cntl |= R300_HIZ_ENABLE |
                (r300->hiz_func == HIZ_FUNC_MIN ? R300_HIZ_MIN : R300_HIZ_MAX);

        z->sc_hyperz |= R300_SC_HYPERZ_ENABLE |
                        r300_get_sc_hz_max(r300);

        if (r300->screen->caps.is_r500) {
            z->zb_bw_cntl |= R500_HIZ_EQUAL_REJECT_ENABLE;
        }
    }
}

/*****************************************************************************/
/* The ZTOP state                                                            */
/*****************************************************************************/

static boolean r300_dsa_writes_stencil(
        struct pipe_stencil_state *s)
{
    return s->enabled && s->writemask &&
           (s->fail_op  != PIPE_STENCIL_OP_KEEP ||
            s->zfail_op != PIPE_STENCIL_OP_KEEP ||
            s->zpass_op != PIPE_STENCIL_OP_KEEP);
}

static boolean r300_dsa_writes_depth_stencil(
        struct pipe_depth_stencil_alpha_state *dsa)
{
    /* We are interested only in the cases when a depth or stencil value
     * can be changed. */

    if (dsa->depth.enabled && dsa->depth.writemask &&
        dsa->depth.func != PIPE_FUNC_NEVER)
        return TRUE;

    if (r300_dsa_writes_stencil(&dsa->stencil[0]) ||
        r300_dsa_writes_stencil(&dsa->stencil[1]))
        return TRUE;

    return FALSE;
}

static boolean r300_dsa_alpha_test_enabled(
        struct pipe_depth_stencil_alpha_state *dsa)
{
    /* We are interested only in the cases when alpha testing can kill
     * a fragment. */

    return dsa->alpha.enabled && dsa->alpha.func != PIPE_FUNC_ALWAYS;
}

static void r300_update_ztop(struct r300_context* r300)
{
    struct r300_ztop_state* ztop_state =
        (struct r300_ztop_state*)r300->ztop_state.state;
    uint32_t old_ztop = ztop_state->z_buffer_top;

    /* This is important enough that I felt it warranted a comment.
     *
     * According to the docs, these are the conditions where ZTOP must be
     * disabled:
     * 1) Alpha testing enabled
     * 2) Texture kill instructions in fragment shader
     * 3) Chroma key culling enabled
     * 4) W-buffering enabled
     *
     * The docs claim that for the first three cases, if no ZS writes happen,
     * then ZTOP can be used.
     *
     * (3) will never apply since we do not support chroma-keyed operations.
     * (4) will need to be re-examined (and this comment updated) if/when
     * Hyper-Z becomes supported.
     *
     * Additionally, the following conditions require disabled ZTOP:
     * 5) Depth writes in fragment shader
     * 6) Outstanding occlusion queries
     *
     * This register causes stalls all the way from SC to CB when changed,
     * but it is buffered on-chip so it does not hurt to write it if it has
     * not changed.
     *
     * ~C.
     */

    /* ZS writes */
    if (r300_dsa_writes_depth_stencil(r300->dsa_state.state) &&
           (r300_dsa_alpha_test_enabled(r300->dsa_state.state) ||  /* (1) */
            r300_fs(r300)->shader->info.uses_kill)) {              /* (2) */
        ztop_state->z_buffer_top = R300_ZTOP_DISABLE;
    } else if (r300_fragment_shader_writes_depth(r300_fs(r300))) { /* (5) */
        ztop_state->z_buffer_top = R300_ZTOP_DISABLE;
    } else if (r300->query_current) {                              /* (6) */
        ztop_state->z_buffer_top = R300_ZTOP_DISABLE;
    } else {
        ztop_state->z_buffer_top = R300_ZTOP_ENABLE;
    }
    if (ztop_state->z_buffer_top != old_ztop)
        r300_mark_atom_dirty(r300, &r300->ztop_state);
}

void r300_update_hyperz_state(struct r300_context* r300)
{
    r300_update_ztop(r300);

    if (r300->hyperz_state.dirty) {
        r300_update_hyperz(r300);
    }
}
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.1
log
@Initial revision
@
text
@a24 1
#include "r300_hyperz.h"
a26 1
#include "r300_winsys.h"
d42 1
a42 1
static bool r300_get_sc_hz_max(struct r300_context *r300)
d44 26
a69 7
    struct r300_dsa_state *dsa_state = r300->dsa_state.state;
    int func = dsa_state->z_stencil_control & R300_ZS_MASK;
    int ret = R300_SC_HYPERZ_MIN;

    if (func >= R300_ZS_GEQUAL && func <= R300_ZS_ALWAYS)
       ret = R300_SC_HYPERZ_MAX;
    return ret;
d72 1
a72 1
static bool r300_zfunc_same_direction(int func1, int func2)
d74 6
d81 3
a83 4
    if ((func1 == R300_ZS_LESS || func1 == R300_ZS_LEQUAL) &&
        (func2 == R300_ZS_EQUAL || func2 == R300_ZS_GEQUAL ||
         func2 == R300_ZS_GREATER))
            return FALSE;
d86 3
a88 3
    if ((func1 == R300_ZS_GEQUAL || func1 == R300_ZS_GREATER) &&
        (func2 == R300_ZS_LESS || func2 == R300_ZS_LEQUAL))
            return FALSE;
a92 11
static int r300_get_hiz_min(struct r300_context *r300)
{
    struct r300_dsa_state *dsa_state = r300->dsa_state.state;
    int func = dsa_state->z_stencil_control & R300_ZS_MASK;
    int ret = R300_HIZ_MIN;

    if (func == R300_ZS_LESS || func == R300_ZS_LEQUAL)
       ret = R300_HIZ_MAX;
    return ret;
}

d95 2
a96 4
    if (s->enabled && (s->fail_op != PIPE_STENCIL_OP_KEEP ||
                       s->zfail_op != PIPE_STENCIL_OP_KEEP))
        return TRUE;
    return FALSE;
d99 1
a99 1
static boolean r300_can_hiz(struct r300_context *r300)
d101 2
a102 4
    struct r300_dsa_state *dsa_state = r300->dsa_state.state;
    struct pipe_depth_stencil_alpha_state *dsa = &dsa_state->dsa;
    struct r300_screen* r300screen = r300->screen;
    struct r300_hyperz_state *z = r300->hyperz_state.state;
d104 1
a104 2
    /* shader writes depth - no HiZ */
    if (r300_fragment_shader_writes_depth(r300_fs(r300))) /* (5) */
d109 5
d115 2
a116 2
    if (r300_dsa_stencil_op_not_keep(&dsa->stencil[0]) ||
        r300_dsa_stencil_op_not_keep(&dsa->stencil[1]))
d119 1
a119 1
    if (dsa->depth.enabled) {
d121 1
a121 1
        if (dsa->depth.func == PIPE_FUNC_EQUAL && !r300screen->caps.is_r500)
d123 1
d125 1
a125 1
        if (dsa->depth.func == PIPE_FUNC_NOTEQUAL)
a127 15
    /* depth comparison function - if just cleared save and return okay */
    if (z->current_func == -1) {
        int func = dsa_state->z_stencil_control & R300_ZS_MASK;
        if (func != 0 && func != 7)
            z->current_func = dsa_state->z_stencil_control & R300_ZS_MASK;
    } else {
        /* simple don't change */
        if (!r300_zfunc_same_direction(z->current_func,
                                       (dsa_state->z_stencil_control & R300_ZS_MASK))) {
            DBG(r300, DBG_HYPERZ,
                "z func changed direction - disabling hyper-z %d -> %d\n",
                z->current_func, dsa_state->z_stencil_control);
            return FALSE;
        }
    }    
d137 3
a139 4
    struct r300_texture *zstex =
            fb->zsbuf ? r300_texture(fb->zsbuf->texture) : NULL;
    boolean zmask_in_use = FALSE;
    boolean hiz_in_use = FALSE;
d151 1
a151 1
    if (!zstex)
d154 15
a168 1
    if (!r300->rws->get_value(r300->rws, R300_CAN_HYPERZ))
d170 1
d172 6
a177 6
    zmask_in_use = zstex->zmask_in_use[fb->zsbuf->u.tex.level];
    hiz_in_use = zstex->hiz_in_use[fb->zsbuf->u.tex.level];

    /* Z fastfill. */
    if (zmask_in_use) {
        z->zb_bw_cntl |= R300_FAST_FILL_ENABLE; /*  | R300_FORCE_COMPRESSED_STENCIL_VALUE_ENABLE;*/
d181 18
a198 9
    if (zmask_in_use && r300->z_compression) {
        z->zb_bw_cntl |= R300_RD_COMP_ENABLE;
        if (r300->z_decomp_rd == false)
            z->zb_bw_cntl |= R300_WR_COMP_ENABLE;
    }
    /* RV350 and up optimizations. */
    /* The section 10.4.9 in the docs is a lie. */
    if (r300->z_compression == RV350_Z_COMPRESS_88)
        z->gb_z_peq_config |= R300_GB_Z_PEQ_CONFIG_Z_PEQ_SIZE_8_8;
d200 3
a202 7
    if (hiz_in_use) {
        bool can_hiz = r300_can_hiz(r300);
        if (can_hiz) {
            z->zb_bw_cntl |= R300_HIZ_ENABLE;
            z->sc_hyperz |= R300_SC_HYPERZ_ENABLE;
            z->sc_hyperz |= r300_get_sc_hz_max(r300);
            z->zb_bw_cntl |= r300_get_hiz_min(r300);
a203 1
    }
d205 10
a214 7
    /* R500-specific features and optimizations. */
    if (r300->screen->caps.is_r500) {
        z->zb_bw_cntl |= R500_HIZ_FP_EXP_BITS_3;
        z->zb_bw_cntl |=
                R500_HIZ_EQUAL_REJECT_ENABLE |
                R500_PEQ_PACKING_ENABLE |
                R500_COVERED_PTR_MASKING_ENABLE;
a305 29
#define ALIGN_DIVUP(x, y) (((x) + (y) - 1) / (y))

static void r300_update_hiz_clear(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    uint32_t height;

    height = ALIGN_DIVUP(fb->zsbuf->height, 4);
    r300->hiz_clear.size = height * 4;
}

static void r300_update_zmask_clear(struct r300_context *r300)
{
    struct pipe_framebuffer_state *fb =
        (struct pipe_framebuffer_state*)r300->fb_state.state;
    uint32_t height;
    int mult;

    if (r300->z_compression == RV350_Z_COMPRESS_88)
        mult = 8;
    else
        mult = 4;

    height = ALIGN_DIVUP(fb->zsbuf->height, mult);

    r300->zmask_clear.size = height * 4;
}

d309 1
a312 96

    if (r300->hiz_clear.dirty) {
       r300_update_hiz_clear(r300);
    }
    if (r300->zmask_clear.dirty) {
       r300_update_zmask_clear(r300);
    }
}

void r300_hiz_alloc_block(struct r300_context *r300, struct r300_surface *surf)
{
    struct r300_texture *tex;
    uint32_t zsize, ndw;
    int level = surf->base.u.tex.level;

    tex = r300_texture(surf->base.texture);

    if (tex->hiz_mem[level])
        return;

    zsize = tex->desc.layer_size_in_bytes[level];
    zsize /= util_format_get_blocksize(tex->desc.b.b.format);
    ndw = ALIGN_DIVUP(zsize, 64);

    tex->hiz_mem[level] = u_mmAllocMem(r300->hiz_mm, ndw, 0, 0);
    return;
}

void r300_zmask_alloc_block(struct r300_context *r300, struct r300_surface *surf, int compress)
{
    int bsize = 256;
    uint32_t zsize, ndw;
    int level = surf->base.u.tex.level;
    struct r300_texture *tex;

    tex = r300_texture(surf->base.texture);

    /* We currently don't handle decompression for 3D textures and cubemaps
     * correctly. */
    if (tex->desc.b.b.target != PIPE_TEXTURE_1D &&
        tex->desc.b.b.target != PIPE_TEXTURE_2D &&
        tex->desc.b.b.target != PIPE_TEXTURE_RECT)
        return;

    /* Cannot flush zmask of 16-bit zbuffers. */
    if (util_format_get_blocksizebits(tex->desc.b.b.format) == 16)
        return;

    if (tex->zmask_mem[level])
        return;

    zsize = tex->desc.layer_size_in_bytes[level];
    zsize /= util_format_get_blocksize(tex->desc.b.b.format);

    /* each zmask dword represents 16 4x4 blocks - which is 256 pixels
       or 16 8x8 depending on the gb peq flag = 1024 pixels */
    if (compress == RV350_Z_COMPRESS_88)
        bsize = 1024;

    ndw = ALIGN_DIVUP(zsize, bsize);
    tex->zmask_mem[level] = u_mmAllocMem(r300->zmask_mm, ndw, 0, 0);
    return;
}

boolean r300_hyperz_init_mm(struct r300_context *r300)
{
    struct r300_screen* r300screen = r300->screen;
    int frag_pipes = r300screen->caps.num_frag_pipes;

    r300->zmask_mm = u_mmInit(0, r300screen->caps.zmask_ram * frag_pipes);
    if (!r300->zmask_mm)
      return FALSE;

    if (r300screen->caps.hiz_ram) {
      r300->hiz_mm = u_mmInit(0, r300screen->caps.hiz_ram * frag_pipes);
      if (!r300->hiz_mm) {
        u_mmDestroy(r300->zmask_mm);
        r300->zmask_mm = NULL;
        return FALSE;
      }
    }

    return TRUE;
}

void r300_hyperz_destroy_mm(struct r300_context *r300)
{
    struct r300_screen* r300screen = r300->screen;

    if (r300screen->caps.hiz_ram) {
      u_mmDestroy(r300->hiz_mm);
      r300->hiz_mm = NULL;
    }

    u_mmDestroy(r300->zmask_mm);
    r300->zmask_mm = NULL;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d25 1
d28 1
d44 1
a44 1
static enum r300_hiz_func r300_get_hiz_func(struct r300_context *r300)
d46 7
a52 26
    struct r300_dsa_state *dsa = r300->dsa_state.state;

    switch (dsa->dsa.depth.func) {
    case PIPE_FUNC_NEVER:
    case PIPE_FUNC_EQUAL:
    case PIPE_FUNC_NOTEQUAL:
    case PIPE_FUNC_ALWAYS:
    default:
        /* Guess MAX for uncertain cases. */
    case PIPE_FUNC_LESS:
    case PIPE_FUNC_LEQUAL:
        return HIZ_FUNC_MAX;

    case PIPE_FUNC_GREATER:
    case PIPE_FUNC_GEQUAL:
        return HIZ_FUNC_MIN;
    }
}

/* Return what's used for the depth test (either minimum or maximum). */
static unsigned r300_get_sc_hz_max(struct r300_context *r300)
{
    struct r300_dsa_state *dsa = r300->dsa_state.state;
    unsigned func = dsa->dsa.depth.func;

    return func >= PIPE_FUNC_GREATER ? R300_SC_HYPERZ_MAX : R300_SC_HYPERZ_MIN;
d55 1
a55 1
static boolean r300_is_hiz_func_valid(struct r300_context *r300)
a56 6
    struct r300_dsa_state *dsa = r300->dsa_state.state;
    unsigned func = dsa->dsa.depth.func;

    if (r300->hiz_func == HIZ_FUNC_NONE)
        return TRUE;

d58 4
a61 3
    if (r300->hiz_func == HIZ_FUNC_MAX &&
        (func == PIPE_FUNC_GEQUAL || func == PIPE_FUNC_GREATER))
        return FALSE;
d64 3
a66 3
    if (r300->hiz_func == HIZ_FUNC_MIN &&
        (func == PIPE_FUNC_LESS   || func == PIPE_FUNC_LEQUAL))
        return FALSE;
d71 11
d84 4
a87 2
    return s->enabled && (s->fail_op != PIPE_STENCIL_OP_KEEP ||
                          s->zfail_op != PIPE_STENCIL_OP_KEEP);
d90 1
a90 1
static boolean r300_hiz_allowed(struct r300_context *r300)
d92 4
a95 2
    struct r300_dsa_state *dsa = r300->dsa_state.state;
    struct r300_screen *r300screen = r300->screen;
d97 2
a98 1
    if (r300_fragment_shader_writes_depth(r300_fs(r300)))
a102 5

    /* If the depth function is inverted, HiZ must be disabled. */
    if (!r300_is_hiz_func_valid(r300))
        return FALSE;

d104 2
a105 2
    if (r300_dsa_stencil_op_not_keep(&dsa->dsa.stencil[0]) ||
        r300_dsa_stencil_op_not_keep(&dsa->dsa.stencil[1]))
d108 1
a108 1
    if (dsa->dsa.depth.enabled) {
d110 1
a110 1
        if (dsa->dsa.depth.func == PIPE_FUNC_EQUAL && !r300screen->caps.is_r500)
a111 1

d113 1
a113 1
        if (dsa->dsa.depth.func == PIPE_FUNC_NOTEQUAL)
d116 15
d140 4
a143 3
    struct r300_dsa_state *dsa = r300->dsa_state.state;
    struct r300_resource *zstex =
            fb->zsbuf ? r300_resource(fb->zsbuf->texture) : NULL;
d155 1
a155 1
    if (!zstex || !r300->hyperz_enabled)
d158 2
a159 10
    /* Set the size of ZMASK tiles. */
    if (zstex->tex.zcomp8x8[fb->zsbuf->u.tex.level]) {
        z->gb_z_peq_config |= R300_GB_Z_PEQ_CONFIG_Z_PEQ_SIZE_8_8;
    }

    /* R500-specific features and optimizations. */
    if (r300->screen->caps.is_r500) {
        z->zb_bw_cntl |= R500_PEQ_PACKING_ENABLE |
                         R500_COVERED_PTR_MASKING_ENABLE;
    }
d161 2
a162 6
    /* Setup decompression if needed. No other HyperZ setting is required. */
    if (r300->zmask_decompress) {
        z->zb_bw_cntl |= R300_FAST_FILL_ENABLE |
                         R300_RD_COMP_ENABLE;
        return;
    }
d164 3
a166 6
    /* Do not set anything if depth and stencil tests are off. */
    if (!dsa->dsa.depth.enabled &&
        !dsa->dsa.stencil[0].enabled &&
        !dsa->dsa.stencil[1].enabled) {
        assert(!dsa->dsa.depth.writemask);
        return;
d170 9
a178 18
    if (r300->zmask_in_use && !r300->locked_zbuffer) {
        z->zb_bw_cntl |= R300_FAST_FILL_ENABLE |
                         R300_RD_COMP_ENABLE |
                         R300_WR_COMP_ENABLE;
    }

    /* HiZ. */
    if (r300->hiz_in_use && !r300->locked_zbuffer) {
        /* HiZ cannot be used under some circumstances. */
        if (!r300_hiz_allowed(r300)) {
            /* If writemask is disabled, the HiZ memory will not be changed,
             * so we can keep its content for later. */
            if (dsa->dsa.depth.writemask) {
                r300->hiz_in_use = FALSE;
            }
            return;
        }
        DBG(r300, DBG_HYPERZ, "r300: Z-func: %i\n", dsa->dsa.depth.func);
d180 7
a186 3
        /* Set the HiZ function if needed. */
        if (r300->hiz_func == HIZ_FUNC_NONE) {
            r300->hiz_func = r300_get_hiz_func(r300);
d188 1
d190 7
a196 10
        /* Setup the HiZ bits. */
        z->zb_bw_cntl |= R300_HIZ_ENABLE |
                (r300->hiz_func == HIZ_FUNC_MIN ? R300_HIZ_MIN : R300_HIZ_MAX);

        z->sc_hyperz |= R300_SC_HYPERZ_ENABLE |
                        r300_get_sc_hz_max(r300);

        if (r300->screen->caps.is_r500) {
            z->zb_bw_cntl |= R500_HIZ_EQUAL_REJECT_ENABLE;
        }
d288 29
a319 1

d323 96
@

