head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.58;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.04;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.07;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2010 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "r300_texture_desc.h"
#include "r300_context.h"

#include "util/u_format.h"

/* Returns the number of pixels that the texture should be aligned to
 * in the given dimension. */
unsigned r300_get_pixel_alignment(enum pipe_format format,
                                  unsigned num_samples,
                                  enum radeon_bo_layout microtile,
                                  enum radeon_bo_layout macrotile,
                                  enum r300_dim dim, boolean is_rs690)
{
    static const unsigned table[2][5][3][2] =
    {
        {
    /* Macro: linear    linear    linear
       Micro: linear    tiled  square-tiled */
            {{ 32, 1}, { 8,  4}, { 0,  0}}, /*   8 bits per pixel */
            {{ 16, 1}, { 8,  2}, { 4,  4}}, /*  16 bits per pixel */
            {{  8, 1}, { 4,  2}, { 0,  0}}, /*  32 bits per pixel */
            {{  4, 1}, { 2,  2}, { 0,  0}}, /*  64 bits per pixel */
            {{  2, 1}, { 0,  0}, { 0,  0}}  /* 128 bits per pixel */
        },
        {
    /* Macro: tiled     tiled     tiled
       Micro: linear    tiled  square-tiled */
            {{256, 8}, {64, 32}, { 0,  0}}, /*   8 bits per pixel */
            {{128, 8}, {64, 16}, {32, 32}}, /*  16 bits per pixel */
            {{ 64, 8}, {32, 16}, { 0,  0}}, /*  32 bits per pixel */
            {{ 32, 8}, {16, 16}, { 0,  0}}, /*  64 bits per pixel */
            {{ 16, 8}, { 0,  0}, { 0,  0}}  /* 128 bits per pixel */
        }
    };

    unsigned tile = 0;
    unsigned pixsize = util_format_get_blocksize(format);

    assert(macrotile <= RADEON_LAYOUT_TILED);
    assert(microtile <= RADEON_LAYOUT_SQUARETILED);
    assert(pixsize <= 16);
    assert(dim <= DIM_HEIGHT);

    tile = table[macrotile][util_logbase2(pixsize)][microtile][dim];
    if (macrotile == 0 && is_rs690 && dim == DIM_WIDTH) {
        int align;
        int h_tile;
        h_tile = table[macrotile][util_logbase2(pixsize)][microtile][DIM_HEIGHT];
        align = 64 / (pixsize * h_tile);
        if (tile < align)
            tile = align;
    }

    assert(tile);
    return tile;
}

/* Return true if macrotiling should be enabled on the miplevel. */
static boolean r300_texture_macro_switch(struct r300_resource *tex,
                                         unsigned level,
                                         boolean rv350_mode,
                                         enum r300_dim dim)
{
    unsigned tile, texdim;

    if (tex->b.b.nr_samples > 1) {
        return TRUE;
    }

    tile = r300_get_pixel_alignment(tex->b.b.format, tex->b.b.nr_samples,
                                    tex->tex.microtile, RADEON_LAYOUT_TILED, dim, 0);
    if (dim == DIM_WIDTH) {
        texdim = u_minify(tex->tex.width0, level);
    } else {
        texdim = u_minify(tex->tex.height0, level);
    }

    /* See TX_FILTER1_n.MACRO_SWITCH. */
    if (rv350_mode) {
        return texdim >= tile;
    } else {
        return texdim > tile;
    }
}

/**
 * Return the stride, in bytes, of the texture image of the given texture
 * at the given level.
 */
static unsigned r300_texture_get_stride(struct r300_screen *screen,
                                        struct r300_resource *tex,
                                        unsigned level)
{
    unsigned tile_width, width, stride;
    boolean is_rs690 = (screen->caps.family == CHIP_RS600 ||
                        screen->caps.family == CHIP_RS690 ||
                        screen->caps.family == CHIP_RS740);

    if (tex->tex.stride_in_bytes_override)
        return tex->tex.stride_in_bytes_override;

    /* Check the level. */
    if (level > tex->b.b.last_level) {
        SCREEN_DBG(screen, DBG_TEX, "%s: level (%u) > last_level (%u)\n",
                   __FUNCTION__, level, tex->b.b.last_level);
        return 0;
    }

    width = u_minify(tex->tex.width0, level);

    if (util_format_is_plain(tex->b.b.format)) {
        tile_width = r300_get_pixel_alignment(tex->b.b.format,
                                              tex->b.b.nr_samples,
                                              tex->tex.microtile,
                                              tex->tex.macrotile[level],
                                              DIM_WIDTH, is_rs690);
        width = align(width, tile_width);

        stride = util_format_get_stride(tex->b.b.format, width);
        /* The alignment to 32 bytes is sort of implied by the layout... */
        return stride;
    } else {
        return align(util_format_get_stride(tex->b.b.format, width), is_rs690 ? 64 : 32);
    }
}

static unsigned r300_texture_get_nblocksy(struct r300_resource *tex,
                                          unsigned level,
                                          boolean *out_aligned_for_cbzb)
{
    unsigned height, tile_height;

    height = u_minify(tex->tex.height0, level);

    /* Mipmapped and 3D textures must have their height aligned to POT. */
    if ((tex->b.b.target != PIPE_TEXTURE_1D &&
         tex->b.b.target != PIPE_TEXTURE_2D &&
         tex->b.b.target != PIPE_TEXTURE_RECT) ||
        tex->b.b.last_level != 0) {
        height = util_next_power_of_two(height);
    }

    if (util_format_is_plain(tex->b.b.format)) {
        tile_height = r300_get_pixel_alignment(tex->b.b.format,
                                               tex->b.b.nr_samples,
                                               tex->tex.microtile,
                                               tex->tex.macrotile[level],
                                               DIM_HEIGHT, 0);
        height = align(height, tile_height);

        /* See if the CBZB clear can be used on the buffer,
         * taking the texture size into account. */
        if (out_aligned_for_cbzb) {
            if (tex->tex.macrotile[level]) {
                /* When clearing, the layer (width*height) is horizontally split
                 * into two, and the upper and lower halves are cleared by the CB
                 * and ZB units, respectively. Therefore, the number of macrotiles
                 * in the Y direction must be even. */

                /* Align the height so that there is an even number of macrotiles.
                 * Do so for 3 or more macrotiles in the Y direction. */
                if (level == 0 && tex->b.b.last_level == 0 &&
                    (tex->b.b.target == PIPE_TEXTURE_1D ||
                     tex->b.b.target == PIPE_TEXTURE_2D ||
                     tex->b.b.target == PIPE_TEXTURE_RECT) &&
                    height >= tile_height * 3) {
                    height = align(height, tile_height * 2);
                }

                *out_aligned_for_cbzb = height % (tile_height * 2) == 0;
            } else {
                *out_aligned_for_cbzb = FALSE;
            }
        }
    }

    return util_format_get_nblocksy(tex->b.b.format, height);
}

/* Get a width in pixels from a stride in bytes. */
unsigned r300_stride_to_width(enum pipe_format format,
                              unsigned stride_in_bytes)
{
    return (stride_in_bytes / util_format_get_blocksize(format)) *
            util_format_get_blockwidth(format);
}

static void r300_setup_miptree(struct r300_screen *screen,
                               struct r300_resource *tex,
                               boolean align_for_cbzb)
{
    struct pipe_resource *base = &tex->b.b;
    unsigned stride, size, layer_size, nblocksy, i;
    boolean rv350_mode = screen->caps.family >= CHIP_R350;
    boolean aligned_for_cbzb;

    tex->tex.size_in_bytes = 0;

    SCREEN_DBG(screen, DBG_TEXALLOC,
        "r300: Making miptree for texture, format %s\n",
        util_format_short_name(base->format));

    for (i = 0; i <= base->last_level; i++) {
        /* Let's see if this miplevel can be macrotiled. */
        tex->tex.macrotile[i] =
            (tex->tex.macrotile[0] == RADEON_LAYOUT_TILED &&
             r300_texture_macro_switch(tex, i, rv350_mode, DIM_WIDTH) &&
             r300_texture_macro_switch(tex, i, rv350_mode, DIM_HEIGHT)) ?
             RADEON_LAYOUT_TILED : RADEON_LAYOUT_LINEAR;

        stride = r300_texture_get_stride(screen, tex, i);

        /* Compute the number of blocks in Y, see if the CBZB clear can be
         * used on the texture. */
        aligned_for_cbzb = FALSE;
        if (align_for_cbzb && tex->tex.cbzb_allowed[i])
            nblocksy = r300_texture_get_nblocksy(tex, i, &aligned_for_cbzb);
        else
            nblocksy = r300_texture_get_nblocksy(tex, i, NULL);

        layer_size = stride * nblocksy;

        if (base->nr_samples > 1) {
            layer_size *= base->nr_samples;
        }

        if (base->target == PIPE_TEXTURE_CUBE)
            size = layer_size * 6;
        else
            size = layer_size * u_minify(tex->tex.depth0, i);

        tex->tex.offset_in_bytes[i] = tex->tex.size_in_bytes;
        tex->tex.size_in_bytes = tex->tex.offset_in_bytes[i] + size;
        tex->tex.layer_size_in_bytes[i] = layer_size;
        tex->tex.stride_in_bytes[i] = stride;
        tex->tex.cbzb_allowed[i] = tex->tex.cbzb_allowed[i] && aligned_for_cbzb;

        SCREEN_DBG(screen, DBG_TEXALLOC, "r300: Texture miptree: Level %d "
                "(%dx%dx%d px, pitch %d bytes) %d bytes total, macrotiled %s\n",
                i, u_minify(tex->tex.width0, i), u_minify(tex->tex.height0, i),
                u_minify(tex->tex.depth0, i), stride, tex->tex.size_in_bytes,
                tex->tex.macrotile[i] ? "TRUE" : "FALSE");
    }
}

static void r300_setup_flags(struct r300_resource *tex)
{
    tex->tex.uses_stride_addressing =
        !util_is_power_of_two(tex->b.b.width0) ||
        (tex->tex.stride_in_bytes_override &&
         r300_stride_to_width(tex->b.b.format,
                         tex->tex.stride_in_bytes_override) != tex->b.b.width0);

    tex->tex.is_npot =
        tex->tex.uses_stride_addressing ||
        !util_is_power_of_two(tex->b.b.height0) ||
        !util_is_power_of_two(tex->b.b.depth0);
}

static void r300_setup_cbzb_flags(struct r300_screen *rscreen,
                                  struct r300_resource *tex)
{
    unsigned i, bpp;
    boolean first_level_valid;

    bpp = util_format_get_blocksizebits(tex->b.b.format);

    /* 1) The texture must be point-sampled,
     * 2) The depth must be 16 or 32 bits.
     * 3) If the midpoint ZB offset is not aligned to 2048, it returns garbage
     *    with certain texture sizes. Macrotiling ensures the alignment. */
    first_level_valid = tex->b.b.nr_samples <= 1 &&
                       (bpp == 16 || bpp == 32) &&
                       tex->tex.macrotile[0];

    if (SCREEN_DBG_ON(rscreen, DBG_NO_CBZB))
        first_level_valid = FALSE;

    for (i = 0; i <= tex->b.b.last_level; i++)
        tex->tex.cbzb_allowed[i] = first_level_valid && tex->tex.macrotile[i];
}

static unsigned r300_pixels_to_dwords(unsigned stride,
                                      unsigned height,
                                      unsigned xblock, unsigned yblock)
{
    return (util_align_npot(stride, xblock) * align(height, yblock)) / (xblock * yblock);
}

static void r300_setup_hyperz_properties(struct r300_screen *screen,
                                         struct r300_resource *tex)
{
    /* The tile size of 1 DWORD in ZMASK RAM is:
     *
     * GPU    Pipes    4x4 mode   8x8 mode
     * ------------------------------------------
     * R580   4P/1Z    32x32      64x64
     * RV570  3P/1Z    48x16      96x32
     * RV530  1P/2Z    32x16      64x32
     *        1P/1Z    16x16      32x32
     */
    static unsigned zmask_blocks_x_per_dw[4] = {4, 8, 12, 8};
    static unsigned zmask_blocks_y_per_dw[4] = {4, 4,  4, 8};

    /* In HIZ RAM, one dword is always 8x8 pixels (each byte is 4x4 pixels),
     * but the blocks have very weird ordering.
     *
     * With 2 pipes and an image of size 8xY, where Y >= 1,
     * clearing 4 dwords clears blocks like this:
     *
     *    01012323
     *
     * where numbers correspond to dword indices. The blocks are interleaved
     * in the X direction, so the alignment must be 4x1 blocks (32x8 pixels).
     *
     * With 4 pipes and an image of size 8xY, where Y >= 4,
     * clearing 8 dwords clears blocks like this:
     *    01012323
     *    45456767
     *    01012323
     *    45456767
     * where numbers correspond to dword indices. The blocks are interleaved
     * in both directions, so the alignment must be 4x4 blocks (32x32 pixels)
     */
    static unsigned hiz_align_x[4] = {8, 32, 48, 32};
    static unsigned hiz_align_y[4] = {8, 8, 8, 32};

    if (util_format_is_depth_or_stencil(tex->b.b.format) &&
        util_format_get_blocksizebits(tex->b.b.format) == 32 &&
        tex->tex.microtile) {
        unsigned i, pipes;

        if (screen->caps.family == CHIP_RV530) {
            pipes = screen->info.r300_num_z_pipes;
        } else {
            pipes = screen->info.r300_num_gb_pipes;
        }

        for (i = 0; i <= tex->b.b.last_level; i++) {
            unsigned zcomp_numdw, zcompsize, hiz_numdw, stride, height;

            stride = r300_stride_to_width(tex->b.b.format,
                                          tex->tex.stride_in_bytes[i]);
            stride = align(stride, 16);
            height = u_minify(tex->b.b.height0, i);

            /* The 8x8 compression mode needs macrotiling. */
            zcompsize = screen->caps.z_compress == R300_ZCOMP_8X8 &&
                       tex->tex.macrotile[i] &&
                       tex->b.b.nr_samples <= 1 ? 8 : 4;

            /* Get the ZMASK buffer size in dwords. */
            zcomp_numdw = r300_pixels_to_dwords(stride, height,
                                zmask_blocks_x_per_dw[pipes-1] * zcompsize,
                                zmask_blocks_y_per_dw[pipes-1] * zcompsize);

            /* Check whether we have enough ZMASK memory. */
            if (util_format_get_blocksizebits(tex->b.b.format) == 32 &&
                zcomp_numdw <= screen->caps.zmask_ram * pipes) {
                tex->tex.zmask_dwords[i] = zcomp_numdw;
                tex->tex.zcomp8x8[i] = zcompsize == 8;

                tex->tex.zmask_stride_in_pixels[i] =
                    util_align_npot(stride, zmask_blocks_x_per_dw[pipes-1] * zcompsize);
            } else {
                tex->tex.zmask_dwords[i] = 0;
                tex->tex.zcomp8x8[i] = FALSE;
                tex->tex.zmask_stride_in_pixels[i] = 0;
            }

            /* Now setup HIZ. */
            stride = util_align_npot(stride, hiz_align_x[pipes-1]);
            height = align(height, hiz_align_y[pipes-1]);

            /* Get the HIZ buffer size in dwords. */
            hiz_numdw = (stride * height) / (8*8 * pipes);

            /* Check whether we have enough HIZ memory. */
            if (hiz_numdw <= screen->caps.hiz_ram * pipes) {
                tex->tex.hiz_dwords[i] = hiz_numdw;
                tex->tex.hiz_stride_in_pixels[i] = stride;
            } else {
                tex->tex.hiz_dwords[i] = 0;
                tex->tex.hiz_stride_in_pixels[i] = 0;
            }
        }
    }
}

static void r300_setup_cmask_properties(struct r300_screen *screen,
                                        struct r300_resource *tex)
{
    static unsigned cmask_align_x[4] = {16, 32, 48, 32};
    static unsigned cmask_align_y[4] = {16, 16, 16, 32};
    unsigned pipes, stride, cmask_num_dw, cmask_max_size;

    if (!screen->caps.has_cmask) {
        return;
    }

    /* We need an AA colorbuffer, no mipmaps. */
    if (tex->b.b.nr_samples <= 1 ||
        tex->b.b.last_level > 0 ||
        util_format_is_depth_or_stencil(tex->b.b.format)) {
        return;
    }

    /* FP16 AA needs R500 and a fairly new DRM. */
    if ((tex->b.b.format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
         tex->b.b.format == PIPE_FORMAT_R16G16B16X16_FLOAT) &&
        (!screen->caps.is_r500 || screen->info.drm_minor < 29)) {
        return;
    }

    if (SCREEN_DBG_ON(screen, DBG_NO_CMASK)) {
        return;
    }

    /* CMASK is part of raster pipes. The number of Z pipes doesn't matter. */
    pipes = screen->info.r300_num_gb_pipes;

    /* The single-pipe cards have 5120 dwords of CMASK RAM,
     * the other cards have 4096 dwords of CMASK RAM per pipe. */
    cmask_max_size = pipes == 1 ? 5120 : pipes * 4096;

    stride = r300_stride_to_width(tex->b.b.format,
                                  tex->tex.stride_in_bytes[0]);
    stride = align(stride, 16);

    /* Get the CMASK size in dwords. */
    cmask_num_dw = r300_pixels_to_dwords(stride, tex->b.b.height0,
                                         cmask_align_x[pipes-1],
                                         cmask_align_y[pipes-1]);

    /* Check the CMASK size against the CMASK memory limit. */
    if (cmask_num_dw <= cmask_max_size) {
        tex->tex.cmask_dwords = cmask_num_dw;
        tex->tex.cmask_stride_in_pixels =
            util_align_npot(stride, cmask_align_x[pipes-1]);
    }
}

static void r300_setup_tiling(struct r300_screen *screen,
                              struct r300_resource *tex)
{
    enum pipe_format format = tex->b.b.format;
    boolean rv350_mode = screen->caps.family >= CHIP_R350;
    boolean is_zb = util_format_is_depth_or_stencil(format);
    boolean dbg_no_tiling = SCREEN_DBG_ON(screen, DBG_NO_TILING);
    boolean force_microtiling =
        (tex->b.b.flags & R300_RESOURCE_FORCE_MICROTILING) != 0;

    if (tex->b.b.nr_samples > 1) {
        tex->tex.microtile = RADEON_LAYOUT_TILED;
        tex->tex.macrotile[0] = RADEON_LAYOUT_TILED;
        return;
    }

    tex->tex.microtile = RADEON_LAYOUT_LINEAR;
    tex->tex.macrotile[0] = RADEON_LAYOUT_LINEAR;

    if (tex->b.b.usage == PIPE_USAGE_STAGING) {
       return;
    }

    if (!util_format_is_plain(format)) {
        return;
    }

    /* If height == 1, disable microtiling except for zbuffer. */
    if (!force_microtiling && !is_zb &&
        (tex->b.b.height0 == 1 || dbg_no_tiling)) {
        return;
    }

    /* Set microtiling. */
    switch (util_format_get_blocksize(format)) {
        case 1:
        case 4:
        case 8:
            tex->tex.microtile = RADEON_LAYOUT_TILED;
            break;

        case 2:
            tex->tex.microtile = RADEON_LAYOUT_SQUARETILED;
            break;
    }

    if (dbg_no_tiling) {
        return;
    }

    /* Set macrotiling. */
    if (r300_texture_macro_switch(tex, 0, rv350_mode, DIM_WIDTH) &&
        r300_texture_macro_switch(tex, 0, rv350_mode, DIM_HEIGHT)) {
        tex->tex.macrotile[0] = RADEON_LAYOUT_TILED;
    }
}

static void r300_tex_print_info(struct r300_resource *tex,
                                const char *func)
{
    fprintf(stderr,
            "r300: %s: Macro: %s, Micro: %s, Pitch: %i, Dim: %ix%ix%i, "
            "LastLevel: %i, Size: %i, Format: %s, Samples: %i\n",
            func,
            tex->tex.macrotile[0] ? "YES" : " NO",
            tex->tex.microtile ? "YES" : " NO",
            r300_stride_to_width(tex->b.b.format, tex->tex.stride_in_bytes[0]),
            tex->b.b.width0, tex->b.b.height0, tex->b.b.depth0,
            tex->b.b.last_level, tex->tex.size_in_bytes,
            util_format_short_name(tex->b.b.format),
            tex->b.b.nr_samples);
}

void r300_texture_desc_init(struct r300_screen *rscreen,
                            struct r300_resource *tex,
                            const struct pipe_resource *base)
{
    tex->b.b.target = base->target;
    tex->b.b.format = base->format;
    tex->b.b.width0 = base->width0;
    tex->b.b.height0 = base->height0;
    tex->b.b.depth0 = base->depth0;
    tex->b.b.array_size = base->array_size;
    tex->b.b.last_level = base->last_level;
    tex->b.b.nr_samples = base->nr_samples;
    tex->tex.width0 = base->width0;
    tex->tex.height0 = base->height0;
    tex->tex.depth0 = base->depth0;

    /* There is a CB memory addressing hardware bug that limits the width
     * of the MSAA buffer in some cases in R520. In order to get around it,
     * the following code lowers the sample count depending on the format and
     * the width.
     *
     * The only catch is that all MSAA colorbuffers and a zbuffer which are
     * supposed to be used together should always be bound together. Only
     * then the correct minimum sample count of all bound buffers is used
     * for rendering. */
    if (rscreen->caps.is_r500) {
        /* FP16 6x MSAA buffers are limited to a width of 1360 pixels. */
        if ((tex->b.b.format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
             tex->b.b.format == PIPE_FORMAT_R16G16B16X16_FLOAT) &&
            tex->b.b.nr_samples == 6 && tex->b.b.width0 > 1360) {
            tex->b.b.nr_samples = 4;
        }

        /* FP16 4x MSAA buffers are limited to a width of 2048 pixels. */
        if ((tex->b.b.format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
             tex->b.b.format == PIPE_FORMAT_R16G16B16X16_FLOAT) &&
            tex->b.b.nr_samples == 4 && tex->b.b.width0 > 2048) {
            tex->b.b.nr_samples = 2;
        }
    }

    /* 32-bit 6x MSAA buffers are limited to a width of 2720 pixels.
     * This applies to all R300-R500 cards. */
    if (util_format_get_blocksizebits(tex->b.b.format) == 32 &&
        !util_format_is_depth_or_stencil(tex->b.b.format) &&
        tex->b.b.nr_samples == 6 && tex->b.b.width0 > 2720) {
        tex->b.b.nr_samples = 4;
    }

    r300_setup_flags(tex);

    /* Align a 3D NPOT texture to POT. */
    if (base->target == PIPE_TEXTURE_3D && tex->tex.is_npot) {
        tex->tex.width0 = util_next_power_of_two(tex->tex.width0);
        tex->tex.height0 = util_next_power_of_two(tex->tex.height0);
        tex->tex.depth0 = util_next_power_of_two(tex->tex.depth0);
    }

    /* Setup tiling. */
    if (tex->tex.microtile == RADEON_LAYOUT_UNKNOWN) {
        r300_setup_tiling(rscreen, tex);
    }

    r300_setup_cbzb_flags(rscreen, tex);

    /* Setup the miptree description. */
    r300_setup_miptree(rscreen, tex, TRUE);
    /* If the required buffer size is larger than the given max size,
     * try again without the alignment for the CBZB clear. */
    if (tex->buf && tex->tex.size_in_bytes > tex->buf->size) {
        r300_setup_miptree(rscreen, tex, FALSE);

        /* Make sure the buffer we got is large enough. */
        if (tex->tex.size_in_bytes > tex->buf->size) {
            fprintf(stderr,
                "r300: I got a pre-allocated buffer to use it as a texture "
                "storage, but the buffer is too small. I'll use the buffer "
                "anyway, because I can't crash here, but it's dangerous. "
                "This can be a DDX bug. Got: %iB, Need: %iB, Info:\n",
                tex->buf->size, tex->tex.size_in_bytes);
            r300_tex_print_info(tex, "texture_desc_init");
            /* Ooops, what now. Apps will break if we fail this,
             * so just pretend everything's okay. */
        }
    }

    r300_setup_hyperz_properties(rscreen, tex);
    r300_setup_cmask_properties(rscreen, tex);

    if (SCREEN_DBG_ON(rscreen, DBG_TEX))
        r300_tex_print_info(tex, "texture_desc_init");
}

unsigned r300_texture_get_offset(struct r300_resource *tex,
                                 unsigned level, unsigned layer)
{
    unsigned offset = tex->tex.offset_in_bytes[level];

    switch (tex->b.b.target) {
        case PIPE_TEXTURE_3D:
        case PIPE_TEXTURE_CUBE:
            return offset + layer * tex->tex.layer_size_in_bytes[level];

        default:
            assert(layer == 0);
            return offset;
    }
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d420 4
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a58 1
    static const unsigned aa_block[2] = {4, 8};
d67 8
a74 16
    if (num_samples > 1) {
        /* Multisampled textures have their own alignment scheme. */
        if (pixsize == 4)
            tile = aa_block[dim];
        /* XXX FP16 AA. */
    } else {
        /* Standard alignment. */
        tile = table[macrotile][util_logbase2(pixsize)][microtile][dim];
        if (macrotile == 0 && is_rs690 && dim == DIM_WIDTH) {
            int align;
            int h_tile;
            h_tile = table[macrotile][util_logbase2(pixsize)][microtile][DIM_HEIGHT];
            align = 64 / (pixsize * h_tile);
            if (tile < align)
                tile = align;
        }
d89 5
a93 1
    tile = r300_get_pixel_alignment(tex->b.b.b.format, tex->b.b.b.nr_samples,
d118 3
a120 3
    boolean is_rs690 = (screen->caps.family == CHIP_FAMILY_RS600 ||
                        screen->caps.family == CHIP_FAMILY_RS690 ||
                        screen->caps.family == CHIP_FAMILY_RS740);
d126 1
a126 1
    if (level > tex->b.b.b.last_level) {
d128 1
a128 1
                   __FUNCTION__, level, tex->b.b.b.last_level);
d134 3
a136 3
    if (util_format_is_plain(tex->b.b.b.format)) {
        tile_width = r300_get_pixel_alignment(tex->b.b.b.format,
                                              tex->b.b.b.nr_samples,
d142 1
a142 1
        stride = util_format_get_stride(tex->b.b.b.format, width);
d146 1
a146 1
        return align(util_format_get_stride(tex->b.b.b.format, width), is_rs690 ? 64 : 32);
d159 4
a162 4
    if ((tex->b.b.b.target != PIPE_TEXTURE_1D &&
         tex->b.b.b.target != PIPE_TEXTURE_2D &&
         tex->b.b.b.target != PIPE_TEXTURE_RECT) ||
        tex->b.b.b.last_level != 0) {
d166 3
a168 3
    if (util_format_is_plain(tex->b.b.b.format)) {
        tile_height = r300_get_pixel_alignment(tex->b.b.b.format,
                                               tex->b.b.b.nr_samples,
d185 4
a188 4
                if (level == 0 && tex->b.b.b.last_level == 0 &&
                    (tex->b.b.b.target == PIPE_TEXTURE_1D ||
                     tex->b.b.b.target == PIPE_TEXTURE_2D ||
                     tex->b.b.b.target == PIPE_TEXTURE_RECT) &&
d200 1
a200 1
    return util_format_get_nblocksy(tex->b.b.b.format, height);
d204 2
a205 2
static unsigned stride_to_width(enum pipe_format format,
                                unsigned stride_in_bytes)
d215 1
a215 1
    struct pipe_resource *base = &tex->b.b.b;
d217 1
a217 1
    boolean rv350_mode = screen->caps.family >= CHIP_FAMILY_R350;
d246 1
a246 1
        if (base->nr_samples) {
a258 1
        tex->tex.stride_in_pixels[i] = stride_to_width(tex->b.b.b.format, stride);
d272 1
a272 1
        !util_is_power_of_two(tex->b.b.b.width0) ||
d274 2
a275 2
         stride_to_width(tex->b.b.b.format,
                         tex->tex.stride_in_bytes_override) != tex->b.b.b.width0);
d279 2
a280 2
        !util_is_power_of_two(tex->b.b.b.height0) ||
        !util_is_power_of_two(tex->b.b.b.depth0);
d289 1
a289 1
    bpp = util_format_get_blocksizebits(tex->b.b.b.format);
d295 1
a295 1
    first_level_valid = tex->b.b.b.nr_samples <= 1 &&
d302 1
a302 1
    for (i = 0; i <= tex->b.b.b.last_level; i++)
d351 2
a352 2
    if (util_format_is_depth_or_stencil(tex->b.b.b.format) &&
        util_format_get_blocksizebits(tex->b.b.b.format) == 32 &&
d356 2
a357 2
        if (screen->caps.family == CHIP_FAMILY_RV530) {
            pipes = screen->caps.num_z_pipes;
d359 1
a359 1
            pipes = screen->caps.num_frag_pipes;
d362 1
a362 1
        for (i = 0; i <= tex->b.b.b.last_level; i++) {
d365 4
a368 2
            stride = align(tex->tex.stride_in_pixels[i], 16);
            height = u_minify(tex->b.b.b.height0, i);
d373 1
a373 1
                       tex->b.b.b.nr_samples <= 1 ? 8 : 4;
d381 1
a381 1
            if (util_format_get_blocksizebits(tex->b.b.b.format) == 32 &&
d413 49
d465 2
a466 2
    enum pipe_format format = tex->b.b.b.format;
    boolean rv350_mode = screen->caps.family >= CHIP_FAMILY_R350;
d469 8
d481 4
d490 2
a491 1
    if (!is_zb && (tex->b.b.b.height0 == 1 || dbg_no_tiling)) {
d524 1
a524 1
            "LastLevel: %i, Size: %i, Format: %s\n",
d528 5
a532 4
            tex->tex.stride_in_pixels[0],
            tex->b.b.b.width0, tex->b.b.b.height0, tex->b.b.b.depth0,
            tex->b.b.b.last_level, tex->tex.size_in_bytes,
            util_format_short_name(tex->b.b.b.format));
d539 8
a546 8
    tex->b.b.b.target = base->target;
    tex->b.b.b.format = base->format;
    tex->b.b.b.width0 = base->width0;
    tex->b.b.b.height0 = base->height0;
    tex->b.b.b.depth0 = base->depth0;
    tex->b.b.b.array_size = base->array_size;
    tex->b.b.b.last_level = base->last_level;
    tex->b.b.b.nr_samples = base->nr_samples;
d551 33
d602 1
a602 1
    /* If the required buffer size is larger the given max size,
d604 1
a604 1
    if (tex->buf_size && tex->tex.size_in_bytes > tex->buf_size) {
a605 3
    }

    r300_setup_hyperz_properties(rscreen, tex);
a606 1
    if (tex->buf_size) {
d608 1
a608 1
        if (tex->tex.size_in_bytes > tex->buf_size) {
d614 1
a614 1
                tex->buf_size, tex->tex.size_in_bytes);
d619 1
d621 2
a622 4
        tex->tex.buffer_size_in_bytes = tex->buf_size;
    } else {
        tex->tex.buffer_size_in_bytes = tex->tex.size_in_bytes;
    }
d633 1
a633 1
    switch (tex->b.b.b.target) {
@


1.1
log
@Initial revision
@
text
@a24 1

a25 1
#include "r300_winsys.h"
d33 2
a34 2
                                  enum r300_buffer_tiling microtile,
                                  enum r300_buffer_tiling macrotile,
d63 2
a64 2
    assert(macrotile <= R300_BUFFER_TILED);
    assert(microtile <= R300_BUFFER_SQUARETILED);
d91 1
a91 1
static boolean r300_texture_macro_switch(struct r300_texture_desc *desc,
d98 2
a99 2
    tile = r300_get_pixel_alignment(desc->b.b.format, desc->b.b.nr_samples,
                                    desc->microtile, R300_BUFFER_TILED, dim, 0);
d101 1
a101 1
        texdim = u_minify(desc->width0, level);
d103 1
a103 1
        texdim = u_minify(desc->height0, level);
d119 1
a119 1
                                        struct r300_texture_desc *desc,
d127 2
a128 2
    if (desc->stride_in_bytes_override)
        return desc->stride_in_bytes_override;
d131 1
a131 1
    if (level > desc->b.b.last_level) {
d133 1
a133 1
                   __FUNCTION__, level, desc->b.b.last_level);
d137 1
a137 1
    width = u_minify(desc->width0, level);
d139 5
a143 5
    if (util_format_is_plain(desc->b.b.format)) {
        tile_width = r300_get_pixel_alignment(desc->b.b.format,
                                              desc->b.b.nr_samples,
                                              desc->microtile,
                                              desc->macrotile[level],
d147 1
a147 1
        stride = util_format_get_stride(desc->b.b.format, width);
d151 1
a151 1
        return align(util_format_get_stride(desc->b.b.format, width), is_rs690 ? 64 : 32);
d155 1
a155 1
static unsigned r300_texture_get_nblocksy(struct r300_texture_desc *desc,
d161 9
a169 1
    height = u_minify(desc->height0, level);
d171 5
a175 5
    if (util_format_is_plain(desc->b.b.format)) {
        tile_height = r300_get_pixel_alignment(desc->b.b.format,
                                               desc->b.b.nr_samples,
                                               desc->microtile,
                                               desc->macrotile[level],
a178 8
        /* This is needed for the kernel checker, unfortunately. */
        if ((desc->b.b.target != PIPE_TEXTURE_1D &&
             desc->b.b.target != PIPE_TEXTURE_2D &&
             desc->b.b.target != PIPE_TEXTURE_RECT) ||
            desc->b.b.last_level != 0) {
            height = util_next_power_of_two(height);
        }

d182 1
a182 1
            if (desc->macrotile[level]) {
d190 4
a193 4
                if (level == 0 && desc->b.b.last_level == 0 &&
                    (desc->b.b.target == PIPE_TEXTURE_1D ||
                     desc->b.b.target == PIPE_TEXTURE_2D ||
                     desc->b.b.target == PIPE_TEXTURE_RECT) &&
d205 1
a205 24
    return util_format_get_nblocksy(desc->b.b.format, height);
}

static void r300_texture_3d_fix_mipmapping(struct r300_screen *screen,
                                           struct r300_texture_desc *desc)
{
    /* The kernels <= 2.6.34-rc4 compute the size of mipmapped 3D textures
     * incorrectly. This is a workaround to prevent CS from being rejected. */

    unsigned i, size;

    if (!screen->rws->get_value(screen->rws, R300_VID_DRM_2_3_0) &&
        desc->b.b.target == PIPE_TEXTURE_3D &&
        desc->b.b.last_level > 0) {
        size = 0;

        for (i = 0; i <= desc->b.b.last_level; i++) {
            size += desc->stride_in_bytes[i] *
                    r300_texture_get_nblocksy(desc, i, FALSE);
        }

        size *= desc->depth0;
        desc->size_in_bytes = size;
    }
d217 1
a217 1
                               struct r300_texture_desc *desc,
d220 1
a220 1
    struct pipe_resource *base = &desc->b.b;
d225 1
a225 1
    desc->size_in_bytes = 0;
d233 5
a237 5
        desc->macrotile[i] =
            (desc->macrotile[0] == R300_BUFFER_TILED &&
             r300_texture_macro_switch(desc, i, rv350_mode, DIM_WIDTH) &&
             r300_texture_macro_switch(desc, i, rv350_mode, DIM_HEIGHT)) ?
             R300_BUFFER_TILED : R300_BUFFER_LINEAR;
d239 1
a239 1
        stride = r300_texture_get_stride(screen, desc, i);
d244 2
a245 2
        if (align_for_cbzb && desc->cbzb_allowed[i])
            nblocksy = r300_texture_get_nblocksy(desc, i, &aligned_for_cbzb);
d247 1
a247 1
            nblocksy = r300_texture_get_nblocksy(desc, i, NULL);
d258 1
a258 1
            size = layer_size * u_minify(desc->depth0, i);
d260 6
a265 6
        desc->offset_in_bytes[i] = desc->size_in_bytes;
        desc->size_in_bytes = desc->offset_in_bytes[i] + size;
        desc->layer_size_in_bytes[i] = layer_size;
        desc->stride_in_bytes[i] = stride;
        desc->stride_in_pixels[i] = stride_to_width(desc->b.b.format, stride);
        desc->cbzb_allowed[i] = desc->cbzb_allowed[i] && aligned_for_cbzb;
d269 3
a271 3
                i, u_minify(desc->width0, i), u_minify(desc->height0, i),
                u_minify(desc->depth0, i), stride, desc->size_in_bytes,
                desc->macrotile[i] ? "TRUE" : "FALSE");
d275 1
a275 1
static void r300_setup_flags(struct r300_texture_desc *desc)
d277 5
a281 5
    desc->uses_stride_addressing =
        !util_is_power_of_two(desc->b.b.width0) ||
        (desc->stride_in_bytes_override &&
         stride_to_width(desc->b.b.format,
                         desc->stride_in_bytes_override) != desc->b.b.width0);
d283 4
a286 4
    desc->is_npot =
        desc->uses_stride_addressing ||
        !util_is_power_of_two(desc->b.b.height0) ||
        !util_is_power_of_two(desc->b.b.depth0);
d290 1
a290 1
                                  struct r300_texture_desc *desc)
d295 1
a295 1
    bpp = util_format_get_blocksizebits(desc->b.b.format);
d301 1
a301 1
    first_level_valid = desc->b.b.nr_samples <= 1 &&
d303 1
a303 1
                       desc->macrotile[0];
d308 107
a414 2
    for (i = 0; i <= desc->b.b.last_level; i++)
        desc->cbzb_allowed[i] = first_level_valid && desc->macrotile[i];
d418 1
a418 1
                              struct r300_texture_desc *desc)
d420 1
a420 2
    struct r300_winsys_screen *rws = screen->rws;
    enum pipe_format format = desc->b.b.format;
d425 3
d433 1
a433 1
    if (!is_zb && (desc->b.b.height0 == 1 || dbg_no_tiling)) {
d442 1
a442 1
            desc->microtile = R300_BUFFER_TILED;
d446 1
a446 3
            if (rws->get_value(rws, R300_VID_SQUARE_TILING_SUPPORT)) {
                desc->microtile = R300_BUFFER_SQUARETILED;
            }
d455 3
a457 3
    if (r300_texture_macro_switch(desc, 0, rv350_mode, DIM_WIDTH) &&
        r300_texture_macro_switch(desc, 0, rv350_mode, DIM_HEIGHT)) {
        desc->macrotile[0] = R300_BUFFER_TILED;
d461 1
a461 2
static void r300_tex_print_info(struct r300_screen *rscreen,
                                struct r300_texture_desc *desc,
d468 23
a490 22
            desc->macrotile[0] ? "YES" : " NO",
            desc->microtile ? "YES" : " NO",
            desc->stride_in_pixels[0],
            desc->b.b.width0, desc->b.b.height0, desc->b.b.depth0,
            desc->b.b.last_level, desc->size_in_bytes,
            util_format_short_name(desc->b.b.format));
}

boolean r300_texture_desc_init(struct r300_screen *rscreen,
                               struct r300_texture_desc *desc,
                               const struct pipe_resource *base,
                               enum r300_buffer_tiling microtile,
                               enum r300_buffer_tiling macrotile,
                               unsigned stride_in_bytes_override,
                               unsigned max_buffer_size)
{
    desc->b.b = *base;
    desc->b.b.screen = &rscreen->screen;
    desc->stride_in_bytes_override = stride_in_bytes_override;
    desc->width0 = base->width0;
    desc->height0 = base->height0;
    desc->depth0 = base->depth0;
d492 1
a492 1
    r300_setup_flags(desc);
d495 4
a498 4
    if (base->target == PIPE_TEXTURE_3D && desc->is_npot) {
        desc->width0 = util_next_power_of_two(desc->width0);
        desc->height0 = util_next_power_of_two(desc->height0);
        desc->depth0 = util_next_power_of_two(desc->depth0);
d502 2
a503 7
    if (microtile == R300_BUFFER_SELECT_LAYOUT ||
        macrotile == R300_BUFFER_SELECT_LAYOUT) {
        r300_setup_tiling(rscreen, desc);
    } else {
        desc->microtile = microtile;
        desc->macrotile[0] = macrotile;
        assert(desc->b.b.last_level == 0);
d506 1
a506 1
    r300_setup_cbzb_flags(rscreen, desc);
d509 1
a509 1
    r300_setup_miptree(rscreen, desc, TRUE);
d512 2
a513 2
    if (max_buffer_size && desc->size_in_bytes > max_buffer_size) {
        r300_setup_miptree(rscreen, desc, FALSE);
d516 1
a516 1
    r300_texture_3d_fix_mipmapping(rscreen, desc);
d518 1
a518 1
    if (max_buffer_size) {
d520 10
a529 6
        if (desc->size_in_bytes > max_buffer_size) {
            fprintf(stderr, "r300: texture_desc_init: The buffer is not "
                            "large enough. Got: %i, Need: %i, Info:\n",
                            max_buffer_size, desc->size_in_bytes);
            r300_tex_print_info(rscreen, desc, "texture_desc_init");
            return FALSE;
d532 1
a532 1
        desc->buffer_size_in_bytes = max_buffer_size;
d534 1
a534 1
        desc->buffer_size_in_bytes = desc->size_in_bytes;
d538 1
a538 3
        r300_tex_print_info(rscreen, desc, "texture_desc_init");

    return TRUE;
d541 1
a541 1
unsigned r300_texture_get_offset(struct r300_texture_desc *desc,
d544 1
a544 1
    unsigned offset = desc->offset_in_bytes[level];
d546 1
a546 1
    switch (desc->b.b.target) {
d549 1
a549 1
            return offset + layer * desc->layer_size_in_bytes[level];
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d25 1
d27 1
d35 2
a36 2
                                  enum radeon_bo_layout microtile,
                                  enum radeon_bo_layout macrotile,
d61 1
d65 2
a66 2
    assert(macrotile <= RADEON_LAYOUT_TILED);
    assert(microtile <= RADEON_LAYOUT_SQUARETILED);
d70 16
a85 8
    tile = table[macrotile][util_logbase2(pixsize)][microtile][dim];
    if (macrotile == 0 && is_rs690 && dim == DIM_WIDTH) {
        int align;
        int h_tile;
        h_tile = table[macrotile][util_logbase2(pixsize)][microtile][DIM_HEIGHT];
        align = 64 / (pixsize * h_tile);
        if (tile < align)
            tile = align;
d93 1
a93 1
static boolean r300_texture_macro_switch(struct r300_resource *tex,
d100 2
a101 6
    if (tex->b.b.nr_samples > 1) {
        return TRUE;
    }

    tile = r300_get_pixel_alignment(tex->b.b.format, tex->b.b.nr_samples,
                                    tex->tex.microtile, RADEON_LAYOUT_TILED, dim, 0);
d103 1
a103 1
        texdim = u_minify(tex->tex.width0, level);
d105 1
a105 1
        texdim = u_minify(tex->tex.height0, level);
d121 1
a121 1
                                        struct r300_resource *tex,
d125 3
a127 3
    boolean is_rs690 = (screen->caps.family == CHIP_RS600 ||
                        screen->caps.family == CHIP_RS690 ||
                        screen->caps.family == CHIP_RS740);
d129 2
a130 2
    if (tex->tex.stride_in_bytes_override)
        return tex->tex.stride_in_bytes_override;
d133 1
a133 1
    if (level > tex->b.b.last_level) {
d135 1
a135 1
                   __FUNCTION__, level, tex->b.b.last_level);
d139 1
a139 1
    width = u_minify(tex->tex.width0, level);
d141 5
a145 5
    if (util_format_is_plain(tex->b.b.format)) {
        tile_width = r300_get_pixel_alignment(tex->b.b.format,
                                              tex->b.b.nr_samples,
                                              tex->tex.microtile,
                                              tex->tex.macrotile[level],
d149 1
a149 1
        stride = util_format_get_stride(tex->b.b.format, width);
d153 1
a153 1
        return align(util_format_get_stride(tex->b.b.format, width), is_rs690 ? 64 : 32);
d157 1
a157 1
static unsigned r300_texture_get_nblocksy(struct r300_resource *tex,
d163 1
a163 1
    height = u_minify(tex->tex.height0, level);
d165 5
a169 13
    /* Mipmapped and 3D textures must have their height aligned to POT. */
    if ((tex->b.b.target != PIPE_TEXTURE_1D &&
         tex->b.b.target != PIPE_TEXTURE_2D &&
         tex->b.b.target != PIPE_TEXTURE_RECT) ||
        tex->b.b.last_level != 0) {
        height = util_next_power_of_two(height);
    }

    if (util_format_is_plain(tex->b.b.format)) {
        tile_height = r300_get_pixel_alignment(tex->b.b.format,
                                               tex->b.b.nr_samples,
                                               tex->tex.microtile,
                                               tex->tex.macrotile[level],
d173 8
d184 1
a184 1
            if (tex->tex.macrotile[level]) {
d192 4
a195 4
                if (level == 0 && tex->b.b.last_level == 0 &&
                    (tex->b.b.target == PIPE_TEXTURE_1D ||
                     tex->b.b.target == PIPE_TEXTURE_2D ||
                     tex->b.b.target == PIPE_TEXTURE_RECT) &&
d207 24
a230 1
    return util_format_get_nblocksy(tex->b.b.format, height);
d234 2
a235 2
unsigned r300_stride_to_width(enum pipe_format format,
                              unsigned stride_in_bytes)
d242 1
a242 1
                               struct r300_resource *tex,
d245 1
a245 1
    struct pipe_resource *base = &tex->b.b;
d247 1
a247 1
    boolean rv350_mode = screen->caps.family >= CHIP_R350;
d250 1
a250 1
    tex->tex.size_in_bytes = 0;
d258 5
a262 5
        tex->tex.macrotile[i] =
            (tex->tex.macrotile[0] == RADEON_LAYOUT_TILED &&
             r300_texture_macro_switch(tex, i, rv350_mode, DIM_WIDTH) &&
             r300_texture_macro_switch(tex, i, rv350_mode, DIM_HEIGHT)) ?
             RADEON_LAYOUT_TILED : RADEON_LAYOUT_LINEAR;
d264 1
a264 1
        stride = r300_texture_get_stride(screen, tex, i);
d269 2
a270 2
        if (align_for_cbzb && tex->tex.cbzb_allowed[i])
            nblocksy = r300_texture_get_nblocksy(tex, i, &aligned_for_cbzb);
d272 1
a272 1
            nblocksy = r300_texture_get_nblocksy(tex, i, NULL);
d276 1
a276 1
        if (base->nr_samples > 1) {
d283 1
a283 1
            size = layer_size * u_minify(tex->tex.depth0, i);
d285 6
a290 5
        tex->tex.offset_in_bytes[i] = tex->tex.size_in_bytes;
        tex->tex.size_in_bytes = tex->tex.offset_in_bytes[i] + size;
        tex->tex.layer_size_in_bytes[i] = layer_size;
        tex->tex.stride_in_bytes[i] = stride;
        tex->tex.cbzb_allowed[i] = tex->tex.cbzb_allowed[i] && aligned_for_cbzb;
d294 3
a296 3
                i, u_minify(tex->tex.width0, i), u_minify(tex->tex.height0, i),
                u_minify(tex->tex.depth0, i), stride, tex->tex.size_in_bytes,
                tex->tex.macrotile[i] ? "TRUE" : "FALSE");
d300 1
a300 1
static void r300_setup_flags(struct r300_resource *tex)
d302 5
a306 5
    tex->tex.uses_stride_addressing =
        !util_is_power_of_two(tex->b.b.width0) ||
        (tex->tex.stride_in_bytes_override &&
         r300_stride_to_width(tex->b.b.format,
                         tex->tex.stride_in_bytes_override) != tex->b.b.width0);
d308 4
a311 4
    tex->tex.is_npot =
        tex->tex.uses_stride_addressing ||
        !util_is_power_of_two(tex->b.b.height0) ||
        !util_is_power_of_two(tex->b.b.depth0);
d315 1
a315 1
                                  struct r300_resource *tex)
d320 1
a320 1
    bpp = util_format_get_blocksizebits(tex->b.b.format);
d326 1
a326 1
    first_level_valid = tex->b.b.nr_samples <= 1 &&
d328 1
a328 1
                       tex->tex.macrotile[0];
d333 2
a334 158
    for (i = 0; i <= tex->b.b.last_level; i++)
        tex->tex.cbzb_allowed[i] = first_level_valid && tex->tex.macrotile[i];
}

static unsigned r300_pixels_to_dwords(unsigned stride,
                                      unsigned height,
                                      unsigned xblock, unsigned yblock)
{
    return (util_align_npot(stride, xblock) * align(height, yblock)) / (xblock * yblock);
}

static void r300_setup_hyperz_properties(struct r300_screen *screen,
                                         struct r300_resource *tex)
{
    /* The tile size of 1 DWORD in ZMASK RAM is:
     *
     * GPU    Pipes    4x4 mode   8x8 mode
     * ------------------------------------------
     * R580   4P/1Z    32x32      64x64
     * RV570  3P/1Z    48x16      96x32
     * RV530  1P/2Z    32x16      64x32
     *        1P/1Z    16x16      32x32
     */
    static unsigned zmask_blocks_x_per_dw[4] = {4, 8, 12, 8};
    static unsigned zmask_blocks_y_per_dw[4] = {4, 4,  4, 8};

    /* In HIZ RAM, one dword is always 8x8 pixels (each byte is 4x4 pixels),
     * but the blocks have very weird ordering.
     *
     * With 2 pipes and an image of size 8xY, where Y >= 1,
     * clearing 4 dwords clears blocks like this:
     *
     *    01012323
     *
     * where numbers correspond to dword indices. The blocks are interleaved
     * in the X direction, so the alignment must be 4x1 blocks (32x8 pixels).
     *
     * With 4 pipes and an image of size 8xY, where Y >= 4,
     * clearing 8 dwords clears blocks like this:
     *    01012323
     *    45456767
     *    01012323
     *    45456767
     * where numbers correspond to dword indices. The blocks are interleaved
     * in both directions, so the alignment must be 4x4 blocks (32x32 pixels)
     */
    static unsigned hiz_align_x[4] = {8, 32, 48, 32};
    static unsigned hiz_align_y[4] = {8, 8, 8, 32};

    if (util_format_is_depth_or_stencil(tex->b.b.format) &&
        util_format_get_blocksizebits(tex->b.b.format) == 32 &&
        tex->tex.microtile) {
        unsigned i, pipes;

        if (screen->caps.family == CHIP_RV530) {
            pipes = screen->info.r300_num_z_pipes;
        } else {
            pipes = screen->info.r300_num_gb_pipes;
        }

        for (i = 0; i <= tex->b.b.last_level; i++) {
            unsigned zcomp_numdw, zcompsize, hiz_numdw, stride, height;

            stride = r300_stride_to_width(tex->b.b.format,
                                          tex->tex.stride_in_bytes[i]);
            stride = align(stride, 16);
            height = u_minify(tex->b.b.height0, i);

            /* The 8x8 compression mode needs macrotiling. */
            zcompsize = screen->caps.z_compress == R300_ZCOMP_8X8 &&
                       tex->tex.macrotile[i] &&
                       tex->b.b.nr_samples <= 1 ? 8 : 4;

            /* Get the ZMASK buffer size in dwords. */
            zcomp_numdw = r300_pixels_to_dwords(stride, height,
                                zmask_blocks_x_per_dw[pipes-1] * zcompsize,
                                zmask_blocks_y_per_dw[pipes-1] * zcompsize);

            /* Check whether we have enough ZMASK memory. */
            if (util_format_get_blocksizebits(tex->b.b.format) == 32 &&
                zcomp_numdw <= screen->caps.zmask_ram * pipes) {
                tex->tex.zmask_dwords[i] = zcomp_numdw;
                tex->tex.zcomp8x8[i] = zcompsize == 8;

                tex->tex.zmask_stride_in_pixels[i] =
                    util_align_npot(stride, zmask_blocks_x_per_dw[pipes-1] * zcompsize);
            } else {
                tex->tex.zmask_dwords[i] = 0;
                tex->tex.zcomp8x8[i] = FALSE;
                tex->tex.zmask_stride_in_pixels[i] = 0;
            }

            /* Now setup HIZ. */
            stride = util_align_npot(stride, hiz_align_x[pipes-1]);
            height = align(height, hiz_align_y[pipes-1]);

            /* Get the HIZ buffer size in dwords. */
            hiz_numdw = (stride * height) / (8*8 * pipes);

            /* Check whether we have enough HIZ memory. */
            if (hiz_numdw <= screen->caps.hiz_ram * pipes) {
                tex->tex.hiz_dwords[i] = hiz_numdw;
                tex->tex.hiz_stride_in_pixels[i] = stride;
            } else {
                tex->tex.hiz_dwords[i] = 0;
                tex->tex.hiz_stride_in_pixels[i] = 0;
            }
        }
    }
}

static void r300_setup_cmask_properties(struct r300_screen *screen,
                                        struct r300_resource *tex)
{
    static unsigned cmask_align_x[4] = {16, 32, 48, 32};
    static unsigned cmask_align_y[4] = {16, 16, 16, 32};
    unsigned pipes, stride, cmask_num_dw, cmask_max_size;

    /* We need an AA colorbuffer, no mipmaps. */
    if (tex->b.b.nr_samples <= 1 ||
        tex->b.b.last_level > 0 ||
        util_format_is_depth_or_stencil(tex->b.b.format)) {
        return;
    }

    /* FP16 AA needs R500 and a fairly new DRM. */
    if ((tex->b.b.format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
         tex->b.b.format == PIPE_FORMAT_R16G16B16X16_FLOAT) &&
        (!screen->caps.is_r500 || screen->info.drm_minor < 29)) {
        return;
    }

    if (SCREEN_DBG_ON(screen, DBG_NO_CMASK)) {
        return;
    }

    /* CMASK is part of raster pipes. The number of Z pipes doesn't matter. */
    pipes = screen->info.r300_num_gb_pipes;

    /* The single-pipe cards have 5120 dwords of CMASK RAM,
     * the other cards have 4096 dwords of CMASK RAM per pipe. */
    cmask_max_size = pipes == 1 ? 5120 : pipes * 4096;

    stride = r300_stride_to_width(tex->b.b.format,
                                  tex->tex.stride_in_bytes[0]);
    stride = align(stride, 16);

    /* Get the CMASK size in dwords. */
    cmask_num_dw = r300_pixels_to_dwords(stride, tex->b.b.height0,
                                         cmask_align_x[pipes-1],
                                         cmask_align_y[pipes-1]);

    /* Check the CMASK size against the CMASK memory limit. */
    if (cmask_num_dw <= cmask_max_size) {
        tex->tex.cmask_dwords = cmask_num_dw;
        tex->tex.cmask_stride_in_pixels =
            util_align_npot(stride, cmask_align_x[pipes-1]);
    }
d338 1
a338 1
                              struct r300_resource *tex)
d340 3
a342 2
    enum pipe_format format = tex->b.b.format;
    boolean rv350_mode = screen->caps.family >= CHIP_R350;
a344 15
    boolean force_microtiling =
        (tex->b.b.flags & R300_RESOURCE_FORCE_MICROTILING) != 0;

    if (tex->b.b.nr_samples > 1) {
        tex->tex.microtile = RADEON_LAYOUT_TILED;
        tex->tex.macrotile[0] = RADEON_LAYOUT_TILED;
        return;
    }

    tex->tex.microtile = RADEON_LAYOUT_LINEAR;
    tex->tex.macrotile[0] = RADEON_LAYOUT_LINEAR;

    if (tex->b.b.usage == PIPE_USAGE_STAGING) {
       return;
    }
d351 1
a351 2
    if (!force_microtiling && !is_zb &&
        (tex->b.b.height0 == 1 || dbg_no_tiling)) {
d360 1
a360 1
            tex->tex.microtile = RADEON_LAYOUT_TILED;
d364 3
a366 1
            tex->tex.microtile = RADEON_LAYOUT_SQUARETILED;
d375 3
a377 3
    if (r300_texture_macro_switch(tex, 0, rv350_mode, DIM_WIDTH) &&
        r300_texture_macro_switch(tex, 0, rv350_mode, DIM_HEIGHT)) {
        tex->tex.macrotile[0] = RADEON_LAYOUT_TILED;
d381 2
a382 1
static void r300_tex_print_info(struct r300_resource *tex,
d387 1
a387 1
            "LastLevel: %i, Size: %i, Format: %s, Samples: %i\n",
d389 22
a410 57
            tex->tex.macrotile[0] ? "YES" : " NO",
            tex->tex.microtile ? "YES" : " NO",
            r300_stride_to_width(tex->b.b.format, tex->tex.stride_in_bytes[0]),
            tex->b.b.width0, tex->b.b.height0, tex->b.b.depth0,
            tex->b.b.last_level, tex->tex.size_in_bytes,
            util_format_short_name(tex->b.b.format),
            tex->b.b.nr_samples);
}

void r300_texture_desc_init(struct r300_screen *rscreen,
                            struct r300_resource *tex,
                            const struct pipe_resource *base)
{
    tex->b.b.target = base->target;
    tex->b.b.format = base->format;
    tex->b.b.width0 = base->width0;
    tex->b.b.height0 = base->height0;
    tex->b.b.depth0 = base->depth0;
    tex->b.b.array_size = base->array_size;
    tex->b.b.last_level = base->last_level;
    tex->b.b.nr_samples = base->nr_samples;
    tex->tex.width0 = base->width0;
    tex->tex.height0 = base->height0;
    tex->tex.depth0 = base->depth0;

    /* There is a CB memory addressing hardware bug that limits the width
     * of the MSAA buffer in some cases in R520. In order to get around it,
     * the following code lowers the sample count depending on the format and
     * the width.
     *
     * The only catch is that all MSAA colorbuffers and a zbuffer which are
     * supposed to be used together should always be bound together. Only
     * then the correct minimum sample count of all bound buffers is used
     * for rendering. */
    if (rscreen->caps.is_r500) {
        /* FP16 6x MSAA buffers are limited to a width of 1360 pixels. */
        if ((tex->b.b.format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
             tex->b.b.format == PIPE_FORMAT_R16G16B16X16_FLOAT) &&
            tex->b.b.nr_samples == 6 && tex->b.b.width0 > 1360) {
            tex->b.b.nr_samples = 4;
        }

        /* FP16 4x MSAA buffers are limited to a width of 2048 pixels. */
        if ((tex->b.b.format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
             tex->b.b.format == PIPE_FORMAT_R16G16B16X16_FLOAT) &&
            tex->b.b.nr_samples == 4 && tex->b.b.width0 > 2048) {
            tex->b.b.nr_samples = 2;
        }
    }

    /* 32-bit 6x MSAA buffers are limited to a width of 2720 pixels.
     * This applies to all R300-R500 cards. */
    if (util_format_get_blocksizebits(tex->b.b.format) == 32 &&
        !util_format_is_depth_or_stencil(tex->b.b.format) &&
        tex->b.b.nr_samples == 6 && tex->b.b.width0 > 2720) {
        tex->b.b.nr_samples = 4;
    }
d412 1
a412 1
    r300_setup_flags(tex);
d415 4
a418 4
    if (base->target == PIPE_TEXTURE_3D && tex->tex.is_npot) {
        tex->tex.width0 = util_next_power_of_two(tex->tex.width0);
        tex->tex.height0 = util_next_power_of_two(tex->tex.height0);
        tex->tex.depth0 = util_next_power_of_two(tex->tex.depth0);
d422 7
a428 2
    if (tex->tex.microtile == RADEON_LAYOUT_UNKNOWN) {
        r300_setup_tiling(rscreen, tex);
d431 1
a431 1
    r300_setup_cbzb_flags(rscreen, tex);
d434 2
a435 2
    r300_setup_miptree(rscreen, tex, TRUE);
    /* If the required buffer size is larger than the given max size,
d437 5
a441 2
    if (tex->buf && tex->tex.size_in_bytes > tex->buf->size) {
        r300_setup_miptree(rscreen, tex, FALSE);
d443 1
d445 6
a450 10
        if (tex->tex.size_in_bytes > tex->buf->size) {
            fprintf(stderr,
                "r300: I got a pre-allocated buffer to use it as a texture "
                "storage, but the buffer is too small. I'll use the buffer "
                "anyway, because I can't crash here, but it's dangerous. "
                "This can be a DDX bug. Got: %iB, Need: %iB, Info:\n",
                tex->buf->size, tex->tex.size_in_bytes);
            r300_tex_print_info(tex, "texture_desc_init");
            /* Ooops, what now. Apps will break if we fail this,
             * so just pretend everything's okay. */
d452 4
d458 2
a459 2
    r300_setup_hyperz_properties(rscreen, tex);
    r300_setup_cmask_properties(rscreen, tex);
d461 1
a461 2
    if (SCREEN_DBG_ON(rscreen, DBG_TEX))
        r300_tex_print_info(tex, "texture_desc_init");
d464 1
a464 1
unsigned r300_texture_get_offset(struct r300_resource *tex,
d467 1
a467 1
    unsigned offset = tex->tex.offset_in_bytes[level];
d469 1
a469 1
    switch (tex->b.b.target) {
d472 1
a472 1
            return offset + layer * tex->tex.layer_size_in_bytes[level];
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a419 4
    if (!screen->caps.has_cmask) {
        return;
    }

@


