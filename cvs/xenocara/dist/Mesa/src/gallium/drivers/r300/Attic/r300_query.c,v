head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2013.09.05.14.00.57;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.08.01;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.45.11;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2009 Corbin Simpson <MostAwesomeDude@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "util/u_memory.h"
#include "util/u_simple_list.h"

#include "r300_context.h"
#include "r300_screen.h"
#include "r300_emit.h"

#include <stdio.h>

static struct pipe_query *r300_create_query(struct pipe_context *pipe,
                                            unsigned query_type)
{
    struct r300_context *r300 = r300_context(pipe);
    struct r300_screen *r300screen = r300->screen;
    struct r300_query *q;

    if (query_type != PIPE_QUERY_OCCLUSION_COUNTER &&
        query_type != PIPE_QUERY_OCCLUSION_PREDICATE &&
        query_type != PIPE_QUERY_GPU_FINISHED) {
        return NULL;
    }

    q = CALLOC_STRUCT(r300_query);
    if (!q)
        return NULL;

    q->type = query_type;

    if (query_type == PIPE_QUERY_GPU_FINISHED) {
        return (struct pipe_query*)q;
    }

    if (r300screen->caps.family == CHIP_RV530)
        q->num_pipes = r300screen->info.r300_num_z_pipes;
    else
        q->num_pipes = r300screen->info.r300_num_gb_pipes;

    q->buf = r300->rws->buffer_create(r300->rws, 4096, 4096, TRUE,
                                      RADEON_DOMAIN_GTT);
    if (!q->buf) {
        FREE(q);
        return NULL;
    }
    q->cs_buf = r300->rws->buffer_get_cs_handle(q->buf);

    return (struct pipe_query*)q;
}

static void r300_destroy_query(struct pipe_context* pipe,
                               struct pipe_query* query)
{
    struct r300_query* q = r300_query(query);

    pb_reference(&q->buf, NULL);
    FREE(query);
}

void r300_resume_query(struct r300_context *r300,
                       struct r300_query *query)
{
    r300->query_current = query;
    r300_mark_atom_dirty(r300, &r300->query_start);
}

static void r300_begin_query(struct pipe_context* pipe,
                             struct pipe_query* query)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_query* q = r300_query(query);

    if (q->type == PIPE_QUERY_GPU_FINISHED)
        return;

    if (r300->query_current != NULL) {
        fprintf(stderr, "r300: begin_query: "
                "Some other query has already been started.\n");
        assert(0);
        return;
    }

    q->num_results = 0;
    r300_resume_query(r300, q);
}

void r300_stop_query(struct r300_context *r300)
{
    r300_emit_query_end(r300);
    r300->query_current = NULL;
}

static void r300_end_query(struct pipe_context* pipe,
	                   struct pipe_query* query)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_query *q = r300_query(query);

    if (q->type == PIPE_QUERY_GPU_FINISHED) {
        pb_reference(&q->buf, NULL);
        r300_flush(pipe, RADEON_FLUSH_ASYNC,
                   (struct pipe_fence_handle**)&q->buf);
        return;
    }

    if (q != r300->query_current) {
        fprintf(stderr, "r300: end_query: Got invalid query.\n");
        assert(0);
        return;
    }

    r300_stop_query(r300);
}

static boolean r300_get_query_result(struct pipe_context* pipe,
                                     struct pipe_query* query,
                                     boolean wait,
                                     union pipe_query_result *vresult)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_query *q = r300_query(query);
    unsigned i;
    uint32_t temp, *map;

    if (q->type == PIPE_QUERY_GPU_FINISHED) {
        if (wait) {
            r300->rws->buffer_wait(q->buf, RADEON_USAGE_READWRITE);
            vresult->b = TRUE;
        } else {
            vresult->b = !r300->rws->buffer_is_busy(q->buf, RADEON_USAGE_READWRITE);
        }
        return vresult->b;
    }

    map = r300->rws->buffer_map(q->cs_buf, r300->cs,
                                PIPE_TRANSFER_READ |
                                (!wait ? PIPE_TRANSFER_DONTBLOCK : 0));
    if (!map)
        return FALSE;

    /* Sum up the results. */
    temp = 0;
    for (i = 0; i < q->num_results; i++) {
        /* Convert little endian values written by GPU to CPU byte order */
        temp += util_le32_to_cpu(*map);
        map++;
    }

    r300->rws->buffer_unmap(q->cs_buf);

    if (q->type == PIPE_QUERY_OCCLUSION_PREDICATE) {
        vresult->b = temp != 0;
    } else {
        vresult->u64 = temp;
    }
    return TRUE;
}

static void r300_render_condition(struct pipe_context *pipe,
                                  struct pipe_query *query,
                                  boolean condition,
                                  uint mode)
{
    struct r300_context *r300 = r300_context(pipe);
    union pipe_query_result result;
    boolean wait;

    r300->skip_rendering = FALSE;

    if (query) {
        wait = mode == PIPE_RENDER_COND_WAIT ||
               mode == PIPE_RENDER_COND_BY_REGION_WAIT;

        if (r300_get_query_result(pipe, query, wait, &result)) {
            if (r300_query(query)->type == PIPE_QUERY_OCCLUSION_PREDICATE) {
                r300->skip_rendering = condition == result.b;
            } else {
                r300->skip_rendering = condition == !!result.u64;
            }
        }
    }
}

void r300_init_query_functions(struct r300_context* r300)
{
    r300->context.create_query = r300_create_query;
    r300->context.destroy_query = r300_destroy_query;
    r300->context.begin_query = r300_begin_query;
    r300->context.end_query = r300_end_query;
    r300->context.get_query_result = r300_get_query_result;
    r300->context.render_condition = r300_render_condition;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d33 1
a33 2
                                            unsigned query_type,
                                            unsigned index)
d61 1
a61 1
                                      RADEON_DOMAIN_GTT, 0);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d33 2
a34 1
                                            unsigned query_type)
d62 1
a62 1
                                      RADEON_DOMAIN_GTT);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d39 3
a41 1
    if (query_type != PIPE_QUERY_OCCLUSION_COUNTER) {
a49 2
    q->domain = RADEON_DOMAIN_GTT;
    q->buffer_size = 4096;
d51 6
a56 2
    if (r300screen->caps.family == CHIP_FAMILY_RV530)
        q->num_pipes = r300screen->caps.num_z_pipes;
d58 1
a58 1
        q->num_pipes = r300screen->caps.num_frag_pipes;
d60 6
a65 6
    insert_at_tail(&r300->query_list, q);

    /* Open up the occlusion query buffer. */
    q->buf = r300->rws->buffer_create(r300->rws, q->buffer_size, 4096,
                                         PIPE_BIND_CUSTOM, PIPE_USAGE_STREAM,
                                         q->domain);
a76 1
    remove_from_list(q);
d93 3
d119 7
d138 1
a138 1
                                     void* vresult)
d145 11
a155 1
    map = r300->rws->buffer_map(q->buf, r300->cs,
d169 1
a169 1
    r300->rws->buffer_unmap(q->buf);
d171 5
a175 1
    *((uint64_t*)vresult) = temp;
d181 1
d185 1
a185 1
    uint64_t result = 0;
d195 5
a199 1
            r300->skip_rendering = result == 0;
d204 2
a205 1
void r300_init_query_functions(struct r300_context* r300) {
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a28 1
#include "r300_winsys.h"
d48 1
a48 1
    q->domain = R300_DOMAIN_GTT;
d59 1
a59 1
    q->buffer = r300->rws->buffer_create(r300->rws, q->buffer_size, 4096,
d62 1
a62 1
    q->cs_buffer = r300->rws->buffer_get_cs_handle(r300->rws, q->buffer);
a69 1
    struct r300_context *r300 = r300_context(pipe);
d72 1
a72 1
    r300->rws->buffer_reference(r300->rws, &q->buffer, NULL);
d129 1
a129 1
    unsigned flags, i;
a130 4
    uint64_t *result = (uint64_t*)vresult;

    if (!q->flushed)
        pipe->flush(pipe, 0, NULL);
d132 3
a134 3
    flags = PIPE_TRANSFER_READ | (!wait ? PIPE_TRANSFER_DONTBLOCK : 0);

    map = r300->rws->buffer_map(r300->rws, q->buffer, r300->cs, flags);
d141 2
a142 1
        temp += *map;
d146 1
a146 1
    r300->rws->buffer_unmap(r300->rws, q->buffer);
d148 1
a148 1
    *result = temp;
d160 2
d166 1
a166 3
        if (!r300_get_query_result(pipe, query, wait, &result)) {
            r300->skip_rendering = FALSE;
        } else {
a168 2
    } else {
        r300->skip_rendering = FALSE;
a171 41
/***************************************************************************
 * Fake occlusion queries (for debugging)
 ***************************************************************************/

static unsigned r300_fake_query;

static struct pipe_query *r300_fake_create_query(struct pipe_context *pipe,
                                                 unsigned query_type)
{
    return (struct pipe_query*)&r300_fake_query;
}

static void r300_fake_destroy_query(struct pipe_context* pipe,
                                    struct pipe_query* query)
{
}

static void r300_fake_begin_query(struct pipe_context* pipe,
                                  struct pipe_query* query)
{
}

static void r300_fake_end_query(struct pipe_context* pipe,
                                struct pipe_query* query)
{
}

static boolean r300_fake_get_query_result(struct pipe_context* pipe,
                                          struct pipe_query* query,
                                          boolean wait, void* vresult)
{
    uint64_t *result = (uint64_t*)vresult;
    *result = 1000000;
    return TRUE;
}

static void r300_fake_render_condition(struct pipe_context *pipe,
                                       struct pipe_query *query, uint mode)
{
}

d173 6
a178 15
    if (DBG_ON(r300, DBG_FAKE_OCC)) {
        r300->context.create_query = r300_fake_create_query;
        r300->context.destroy_query = r300_fake_destroy_query;
        r300->context.begin_query = r300_fake_begin_query;
        r300->context.end_query = r300_fake_end_query;
        r300->context.get_query_result = r300_fake_get_query_result;
        r300->context.render_condition = r300_fake_render_condition;
    } else {
        r300->context.create_query = r300_create_query;
        r300->context.destroy_query = r300_destroy_query;
        r300->context.begin_query = r300_begin_query;
        r300->context.end_query = r300_end_query;
        r300->context.get_query_result = r300_get_query_result;
        r300->context.render_condition = r300_render_condition;
    }
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a27 1
#include "r300_cs.h"
d29 3
a31 2
#include "r300_query.h"
#include "r300_reg.h"
d37 6
a42 3
    struct r300_screen *r300screen = r300_screen(r300->context.screen);
    unsigned query_size;
    struct r300_query *q, *qptr;
d45 2
d49 2
a50 3
    assert(q->type == PIPE_QUERY_OCCLUSION_COUNTER);

    q->active = FALSE;
d52 2
a53 2
    if (r300screen->caps->family == CHIP_FAMILY_RV530)
	query_size = r300screen->caps->num_z_pipes * sizeof(uint32_t);
d55 1
a55 1
	query_size = r300screen->caps->num_frag_pipes * sizeof(uint32_t);
a56 4
    if (!is_empty_list(&r300->query_list)) {
        qptr = last_elem(&r300->query_list);
        q->offset = qptr->offset + query_size;
    }
d59 5
a63 4
    /* XXX */
    if (q->offset >= 4096) {
        q->offset = 0;
    }
d71 2
a72 1
    struct r300_query* q = (struct r300_query*)query;
d74 1
d79 7
a88 1
    uint32_t* map;
d90 1
a90 1
    struct r300_query* q = (struct r300_query*)query;
d92 6
a97 1
    assert(r300->query_current == NULL);
d99 8
a106 9
    map = pipe->screen->buffer_map(pipe->screen, r300->oqbo,
            PIPE_BUFFER_USAGE_CPU_WRITE);
    map += q->offset / 4;
    *map = ~0U;
    pipe->screen->buffer_unmap(pipe->screen, r300->oqbo);

    q->flushed = FALSE;
    r300->query_current = q;
    r300->dirty_state |= R300_NEW_QUERY;
d113 7
d121 1
a121 2
    r300_emit_query_end(r300);
    r300->query_current = NULL;
d127 1
a127 1
                                     uint64_t* result)
d130 4
a133 6
    struct r300_screen* r300screen = r300_screen(r300->context.screen);
    struct r300_query *q = (struct r300_query*)query;
    unsigned flags = PIPE_BUFFER_USAGE_CPU_READ;
    uint32_t* map;
    uint32_t temp = 0;
    unsigned i, num_results;
d135 1
a135 1
    if (q->flushed == FALSE)
a136 3
    if (!wait) {
        flags |= PIPE_BUFFER_USAGE_DONTBLOCK;
    }
d138 3
a140 1
    map = pipe->screen->buffer_map(pipe->screen, r300->oqbo, flags);
a142 6
    map += q->offset / 4;

    if (r300screen->caps->family == CHIP_FAMILY_RV530)
        num_results = r300screen->caps->num_z_pipes;
    else
        num_results = r300screen->caps->num_frag_pipes;
d144 3
a146 10
    for (i = 0; i < num_results; i++) {
        if (*map == ~0U) {
            /* Looks like our results aren't ready yet. */
            if (wait) {
                debug_printf("r300: Despite waiting, OQ results haven't"
                        " come in yet.\n");
            }
            temp = ~0U;
            break;
        }
a149 1
    pipe->screen->buffer_unmap(pipe->screen, r300->oqbo);
d151 25
a175 3
    if (temp == ~0U) {
        /* Our results haven't been written yet... */
        return FALSE;
d177 28
d206 6
a211 1
    *result = temp;
d215 5
d221 15
a235 5
    r300->context.create_query = r300_create_query;
    r300->context.destroy_query = r300_destroy_query;
    r300->context.begin_query = r300_begin_query;
    r300->context.end_query = r300_end_query;
    r300->context.get_query_result = r300_get_query_result;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d28 1
d30 2
a31 3
#include "r300_winsys.h"

#include <stdio.h>
d37 3
a39 6
    struct r300_screen *r300screen = r300->screen;
    struct r300_query *q;

    if (query_type != PIPE_QUERY_OCCLUSION_COUNTER) {
        return NULL;
    }
a41 2
    if (!q)
        return NULL;
d44 3
a46 2
    q->domain = R300_DOMAIN_GTT;
    q->buffer_size = 4096;
d48 2
a49 2
    if (r300screen->caps.family == CHIP_FAMILY_RV530)
        q->num_pipes = r300screen->caps.num_z_pipes;
d51 1
a51 1
        q->num_pipes = r300screen->caps.num_frag_pipes;
d53 4
d59 4
a62 5
    /* Open up the occlusion query buffer. */
    q->buffer = r300->rws->buffer_create(r300->rws, q->buffer_size, 4096,
                                         PIPE_BIND_CUSTOM, PIPE_USAGE_STREAM,
                                         q->domain);
    q->cs_buffer = r300->rws->buffer_get_cs_handle(r300->rws, q->buffer);
d70 1
a70 2
    struct r300_context *r300 = r300_context(pipe);
    struct r300_query* q = r300_query(query);
a71 1
    r300->rws->buffer_reference(r300->rws, &q->buffer, NULL);
a75 7
void r300_resume_query(struct r300_context *r300,
                       struct r300_query *query)
{
    r300->query_current = query;
    r300_mark_atom_dirty(r300, &r300->query_start);
}

d79 1
d81 1
a81 1
    struct r300_query* q = r300_query(query);
d83 1
a83 6
    if (r300->query_current != NULL) {
        fprintf(stderr, "r300: begin_query: "
                "Some other query has already been started.\n");
        assert(0);
        return;
    }
d85 9
a93 8
    q->num_results = 0;
    r300_resume_query(r300, q);
}

void r300_stop_query(struct r300_context *r300)
{
    r300_emit_query_end(r300);
    r300->query_current = NULL;
a99 1
    struct r300_query *q = r300_query(query);
d101 2
a102 7
    if (q != r300->query_current) {
        fprintf(stderr, "r300: end_query: Got invalid query.\n");
        assert(0);
        return;
    }

    r300_stop_query(r300);
d108 1
a108 1
                                     void* vresult)
d111 6
a116 4
    struct r300_query *q = r300_query(query);
    unsigned flags, i;
    uint32_t temp, *map;
    uint64_t *result = (uint64_t*)vresult;
d118 1
a118 1
    if (!q->flushed)
d120 3
d124 1
a124 3
    flags = PIPE_TRANSFER_READ | (!wait ? PIPE_TRANSFER_DONTBLOCK : 0);

    map = r300->rws->buffer_map(r300->rws, q->buffer, r300->cs, flags);
d127 6
d134 10
a143 3
    /* Sum up the results. */
    temp = 0;
    for (i = 0; i < q->num_results; i++) {
d147 1
d149 4
a152 1
    r300->rws->buffer_unmap(r300->rws, q->buffer);
a157 63
static void r300_render_condition(struct pipe_context *pipe,
                                  struct pipe_query *query,
                                  uint mode)
{
    struct r300_context *r300 = r300_context(pipe);
    uint64_t result = 0;
    boolean wait;

    if (query) {
        wait = mode == PIPE_RENDER_COND_WAIT ||
               mode == PIPE_RENDER_COND_BY_REGION_WAIT;

        if (!r300_get_query_result(pipe, query, wait, &result)) {
            r300->skip_rendering = FALSE;
        } else {
            r300->skip_rendering = result == 0;
        }
    } else {
        r300->skip_rendering = FALSE;
    }
}

/***************************************************************************
 * Fake occlusion queries (for debugging)
 ***************************************************************************/

static unsigned r300_fake_query;

static struct pipe_query *r300_fake_create_query(struct pipe_context *pipe,
                                                 unsigned query_type)
{
    return (struct pipe_query*)&r300_fake_query;
}

static void r300_fake_destroy_query(struct pipe_context* pipe,
                                    struct pipe_query* query)
{
}

static void r300_fake_begin_query(struct pipe_context* pipe,
                                  struct pipe_query* query)
{
}

static void r300_fake_end_query(struct pipe_context* pipe,
                                struct pipe_query* query)
{
}

static boolean r300_fake_get_query_result(struct pipe_context* pipe,
                                          struct pipe_query* query,
                                          boolean wait, void* vresult)
{
    uint64_t *result = (uint64_t*)vresult;
    *result = 1000000;
    return TRUE;
}

static void r300_fake_render_condition(struct pipe_context *pipe,
                                       struct pipe_query *query, uint mode)
{
}

d159 5
a163 15
    if (DBG_ON(r300, DBG_FAKE_OCC)) {
        r300->context.create_query = r300_fake_create_query;
        r300->context.destroy_query = r300_fake_destroy_query;
        r300->context.begin_query = r300_fake_begin_query;
        r300->context.end_query = r300_fake_end_query;
        r300->context.get_query_result = r300_fake_get_query_result;
        r300->context.render_condition = r300_fake_render_condition;
    } else {
        r300->context.create_query = r300_create_query;
        r300->context.destroy_query = r300_destroy_query;
        r300->context.begin_query = r300_begin_query;
        r300->context.end_query = r300_end_query;
        r300->context.get_query_result = r300_get_query_result;
        r300->context.render_condition = r300_render_condition;
    }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d29 1
d40 1
a40 3
    if (query_type != PIPE_QUERY_OCCLUSION_COUNTER &&
        query_type != PIPE_QUERY_OCCLUSION_PREDICATE &&
        query_type != PIPE_QUERY_GPU_FINISHED) {
d49 2
d52 4
a55 3
    if (query_type == PIPE_QUERY_GPU_FINISHED) {
        return (struct pipe_query*)q;
    }
d57 1
a57 4
    if (r300screen->caps.family == CHIP_RV530)
        q->num_pipes = r300screen->info.r300_num_z_pipes;
    else
        q->num_pipes = r300screen->info.r300_num_gb_pipes;
d59 5
a63 7
    q->buf = r300->rws->buffer_create(r300->rws, 4096, 4096, TRUE,
                                      RADEON_DOMAIN_GTT);
    if (!q->buf) {
        FREE(q);
        return NULL;
    }
    q->cs_buf = r300->rws->buffer_get_cs_handle(q->buf);
d71 1
d74 2
a75 1
    pb_reference(&q->buf, NULL);
a91 3
    if (q->type == PIPE_QUERY_GPU_FINISHED)
        return;

a114 7
    if (q->type == PIPE_QUERY_GPU_FINISHED) {
        pb_reference(&q->buf, NULL);
        r300_flush(pipe, RADEON_FLUSH_ASYNC,
                   (struct pipe_fence_handle**)&q->buf);
        return;
    }

d127 1
a127 1
                                     union pipe_query_result *vresult)
d131 1
a131 1
    unsigned i;
d133 1
d135 4
a138 9
    if (q->type == PIPE_QUERY_GPU_FINISHED) {
        if (wait) {
            r300->rws->buffer_wait(q->buf, RADEON_USAGE_READWRITE);
            vresult->b = TRUE;
        } else {
            vresult->b = !r300->rws->buffer_is_busy(q->buf, RADEON_USAGE_READWRITE);
        }
        return vresult->b;
    }
d140 1
a140 3
    map = r300->rws->buffer_map(q->cs_buf, r300->cs,
                                PIPE_TRANSFER_READ |
                                (!wait ? PIPE_TRANSFER_DONTBLOCK : 0));
d147 1
a147 2
        /* Convert little endian values written by GPU to CPU byte order */
        temp += util_le32_to_cpu(*map);
d151 1
a151 1
    r300->rws->buffer_unmap(q->cs_buf);
d153 1
a153 5
    if (q->type == PIPE_QUERY_OCCLUSION_PREDICATE) {
        vresult->b = temp != 0;
    } else {
        vresult->u64 = temp;
    }
a158 1
                                  boolean condition,
d162 1
a162 1
    union pipe_query_result result;
a164 2
    r300->skip_rendering = FALSE;

d169 4
a172 6
        if (r300_get_query_result(pipe, query, wait, &result)) {
            if (r300_query(query)->type == PIPE_QUERY_OCCLUSION_PREDICATE) {
                r300->skip_rendering = condition == result.b;
            } else {
                r300->skip_rendering = condition == !!result.u64;
            }
d174 2
d179 14
a192 1
void r300_init_query_functions(struct r300_context* r300)
d194 42
a235 6
    r300->context.create_query = r300_create_query;
    r300->context.destroy_query = r300_destroy_query;
    r300->context.begin_query = r300_begin_query;
    r300->context.end_query = r300_end_query;
    r300->context.get_query_result = r300_get_query_result;
    r300->context.render_condition = r300_render_condition;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d33 1
a33 2
                                            unsigned query_type,
                                            unsigned index)
d61 1
a61 1
                                      RADEON_DOMAIN_GTT, 0);
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d33 2
a34 1
                                            unsigned query_type)
d62 1
a62 1
                                      RADEON_DOMAIN_GTT);
@


