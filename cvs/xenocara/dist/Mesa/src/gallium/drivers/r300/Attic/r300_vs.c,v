head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.14.00.59;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.04;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2009 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2009 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "r300_vs.h"

#include "r300_context.h"
#include "r300_screen.h"
#include "r300_tgsi_to_rc.h"
#include "r300_reg.h"

#include "tgsi/tgsi_dump.h"
#include "tgsi/tgsi_parse.h"
#include "tgsi/tgsi_ureg.h"

#include "compiler/radeon_compiler.h"

/* Convert info about VS output semantics into r300_shader_semantics. */
static void r300_shader_read_vs_outputs(
    struct r300_context *r300,
    struct tgsi_shader_info* info,
    struct r300_shader_semantics* vs_outputs)
{
    int i;
    unsigned index;

    r300_shader_semantics_reset(vs_outputs);

    for (i = 0; i < info->num_outputs; i++) {
        index = info->output_semantic_index[i];

        switch (info->output_semantic_name[i]) {
            case TGSI_SEMANTIC_POSITION:
                assert(index == 0);
                vs_outputs->pos = i;
                break;

            case TGSI_SEMANTIC_PSIZE:
                assert(index == 0);
                vs_outputs->psize = i;
                break;

            case TGSI_SEMANTIC_COLOR:
                assert(index < ATTR_COLOR_COUNT);
                vs_outputs->color[index] = i;
                break;

            case TGSI_SEMANTIC_BCOLOR:
                assert(index < ATTR_COLOR_COUNT);
                vs_outputs->bcolor[index] = i;
                break;

            case TGSI_SEMANTIC_GENERIC:
                assert(index < ATTR_GENERIC_COUNT);
                vs_outputs->generic[index] = i;
                vs_outputs->num_generic++;
                break;

            case TGSI_SEMANTIC_FOG:
                assert(index == 0);
                vs_outputs->fog = i;
                break;

            case TGSI_SEMANTIC_EDGEFLAG:
                assert(index == 0);
                fprintf(stderr, "r300 VP: cannot handle edgeflag output.\n");
                break;

            case TGSI_SEMANTIC_CLIPVERTEX:
                assert(index == 0);
                /* Draw does clip vertex for us. */
                if (r300->screen->caps.has_tcl) {
                    fprintf(stderr, "r300 VP: cannot handle clip vertex output.\n");
                }
                break;

            default:
                fprintf(stderr, "r300 VP: unknown vertex output semantic: %i.\n",
                        info->output_semantic_name[i]);
        }
    }

    /* WPOS is a straight copy of POSITION and it's always emitted. */
    vs_outputs->wpos = i;
}

static void set_vertex_inputs_outputs(struct r300_vertex_program_compiler * c)
{
    struct r300_vertex_shader * vs = c->UserData;
    struct r300_shader_semantics* outputs = &vs->outputs;
    struct tgsi_shader_info* info = &vs->info;
    int i, reg = 0;
    boolean any_bcolor_used = outputs->bcolor[0] != ATTR_UNUSED ||
                              outputs->bcolor[1] != ATTR_UNUSED;

    /* Fill in the input mapping */
    for (i = 0; i < info->num_inputs; i++)
        c->code->inputs[i] = i;

    /* Position. */
    if (outputs->pos != ATTR_UNUSED) {
        c->code->outputs[outputs->pos] = reg++;
    } else {
        assert(0);
    }

    /* Point size. */
    if (outputs->psize != ATTR_UNUSED) {
        c->code->outputs[outputs->psize] = reg++;
    }

    /* If we're writing back facing colors we need to send
     * four colors to make front/back face colors selection work.
     * If the vertex program doesn't write all 4 colors, lets
     * pretend it does by skipping output index reg so the colors
     * get written into appropriate output vectors.
     */

    /* Colors. */
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        if (outputs->color[i] != ATTR_UNUSED) {
            c->code->outputs[outputs->color[i]] = reg++;
        } else if (any_bcolor_used ||
                   outputs->color[1] != ATTR_UNUSED) {
            reg++;
        }
    }

    /* Back-face colors. */
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        if (outputs->bcolor[i] != ATTR_UNUSED) {
            c->code->outputs[outputs->bcolor[i]] = reg++;
        } else if (any_bcolor_used) {
            reg++;
        }
    }

    /* Texture coordinates. */
    for (i = 0; i < ATTR_GENERIC_COUNT; i++) {
        if (outputs->generic[i] != ATTR_UNUSED) {
            c->code->outputs[outputs->generic[i]] = reg++;
        }
    }

    /* Fog coordinates. */
    if (outputs->fog != ATTR_UNUSED) {
        c->code->outputs[outputs->fog] = reg++;
    }

    /* WPOS. */
    c->code->outputs[outputs->wpos] = reg++;
}

void r300_init_vs_outputs(struct r300_context *r300,
                          struct r300_vertex_shader *vs)
{
    tgsi_scan_shader(vs->state.tokens, &vs->info);
    r300_shader_read_vs_outputs(r300, &vs->info, &vs->outputs);
}

static void r300_dummy_vertex_shader(
    struct r300_context* r300,
    struct r300_vertex_shader* shader)
{
    struct ureg_program *ureg;
    struct ureg_dst dst;
    struct ureg_src imm;

    /* Make a simple vertex shader which outputs (0, 0, 0, 1),
     * effectively rendering nothing. */
    ureg = ureg_create(TGSI_PROCESSOR_VERTEX);
    dst = ureg_DECL_output(ureg, TGSI_SEMANTIC_POSITION, 0);
    imm = ureg_imm4f(ureg, 0, 0, 0, 1);

    ureg_MOV(ureg, dst, imm);
    ureg_END(ureg);

    shader->state.tokens = tgsi_dup_tokens(ureg_finalize(ureg));
    ureg_destroy(ureg);

    shader->dummy = TRUE;
    r300_init_vs_outputs(r300, shader);
    r300_translate_vertex_shader(r300, shader);
}

void r300_translate_vertex_shader(struct r300_context *r300,
                                  struct r300_vertex_shader *vs)
{
    struct r300_vertex_program_compiler compiler;
    struct tgsi_to_rc ttr;
    unsigned i;

    /* Setup the compiler */
    memset(&compiler, 0, sizeof(compiler));
    rc_init(&compiler.Base, NULL);

    DBG_ON(r300, DBG_VP) ? compiler.Base.Debug |= RC_DBG_LOG : 0;
    DBG_ON(r300, DBG_P_STAT) ? compiler.Base.Debug |= RC_DBG_STATS : 0;
    compiler.code = &vs->code;
    compiler.UserData = vs;
    compiler.Base.is_r500 = r300->screen->caps.is_r500;
    compiler.Base.disable_optimizations = DBG_ON(r300, DBG_NO_OPT);
    compiler.Base.has_half_swizzles = FALSE;
    compiler.Base.has_presub = FALSE;
    compiler.Base.has_omod = FALSE;
    compiler.Base.max_temp_regs = 32;
    compiler.Base.max_constants = 256;
    compiler.Base.max_alu_insts = r300->screen->caps.is_r500 ? 1024 : 256;

    if (compiler.Base.Debug & RC_DBG_LOG) {
        DBG(r300, DBG_VP, "r300: Initial vertex program\n");
        tgsi_dump(vs->state.tokens, 0);
    }

    /* Translate TGSI to our internal representation */
    ttr.compiler = &compiler.Base;
    ttr.info = &vs->info;
    ttr.use_half_swizzles = FALSE;

    r300_tgsi_to_rc(&ttr, vs->state.tokens);

    if (ttr.error) {
        fprintf(stderr, "r300 VP: Cannot translate a shader. "
                "Using a dummy shader instead.\n");
        r300_dummy_vertex_shader(r300, vs);
        return;
    }

    if (compiler.Base.Program.Constants.Count > 200) {
        compiler.Base.remove_unused_constants = TRUE;
    }

    compiler.RequiredOutputs = ~(~0 << (vs->info.num_outputs + 1));
    compiler.SetHwInputOutput = &set_vertex_inputs_outputs;

    /* Insert the WPOS output. */
    rc_copy_output(&compiler.Base, 0, vs->outputs.wpos);

    /* Invoke the compiler */
    r3xx_compile_vertex_program(&compiler);
    if (compiler.Base.Error) {
        fprintf(stderr, "r300 VP: Compiler error:\n%sUsing a dummy shader"
                " instead.\n", compiler.Base.ErrorMsg);

        if (vs->dummy) {
            fprintf(stderr, "r300 VP: Cannot compile the dummy shader! "
                    "Giving up...\n");
            abort();
        }

        rc_destroy(&compiler.Base);
        r300_dummy_vertex_shader(r300, vs);
        return;
    }

    /* Initialize numbers of constants for each type. */
    vs->externals_count = 0;
    for (i = 0;
         i < vs->code.constants.Count &&
         vs->code.constants.Constants[i].Type == RC_CONSTANT_EXTERNAL; i++) {
        vs->externals_count = i+1;
    }
    for (; i < vs->code.constants.Count; i++) {
        assert(vs->code.constants.Constants[i].Type == RC_CONSTANT_IMMEDIATE);
    }
    vs->immediates_count = vs->code.constants.Count - vs->externals_count;

    /* And, finally... */
    rc_destroy(&compiler.Base);
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d35 1
a35 1
#include "radeon_compiler.h"
d39 1
d75 1
d88 8
d173 2
a174 1
void r300_init_vs_outputs(struct r300_vertex_shader *vs)
d177 1
a177 1
    r300_shader_read_vs_outputs(&vs->info, &vs->outputs);
d201 1
a201 1
    r300_init_vs_outputs(shader);
d214 1
a214 1
    rc_init(&compiler.Base);
d224 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d229 7
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a24 1
#include "r300_fs.h"
d33 1
a36 2
#include "util/u_math.h"

d83 1
a83 2
                fprintf(stderr, "r300 VP: cannot handle edgeflag output\n");
                assert(0);
d85 1
d87 2
a88 50
                assert(0);
        }
    }
}

static void r300_shader_vap_output_fmt(struct r300_vertex_shader* vs)
{
    struct r300_shader_semantics* vs_outputs = &vs->outputs;
    uint32_t* hwfmt = vs->hwfmt;
    int i, gen_count;
    boolean any_bcolor_used = vs_outputs->bcolor[0] != ATTR_UNUSED ||
                              vs_outputs->bcolor[1] != ATTR_UNUSED;

    /* Do the actual vertex_info setup.
     *
     * vertex_info has four uints of hardware-specific data in it.
     * vinfo.hwfmt[0] is R300_VAP_VTX_STATE_CNTL
     * vinfo.hwfmt[1] is R300_VAP_VSM_VTX_ASSM
     * vinfo.hwfmt[2] is R300_VAP_OUTPUT_VTX_FMT_0
     * vinfo.hwfmt[3] is R300_VAP_OUTPUT_VTX_FMT_1 */

    hwfmt[0] = 0x5555; /* XXX this is classic Mesa bonghits */

    /* Position. */
    if (vs_outputs->pos != ATTR_UNUSED) {
        hwfmt[1] |= R300_INPUT_CNTL_POS;
        hwfmt[2] |= R300_VAP_OUTPUT_VTX_FMT_0__POS_PRESENT;
    } else {
        assert(0);
    }

    /* Point size. */
    if (vs_outputs->psize != ATTR_UNUSED) {
        hwfmt[2] |= R300_VAP_OUTPUT_VTX_FMT_0__PT_SIZE_PRESENT;
    }

    /* Colors. */
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        if (vs_outputs->color[i] != ATTR_UNUSED || any_bcolor_used ||
            vs_outputs->color[1] != ATTR_UNUSED) {
            hwfmt[1] |= R300_INPUT_CNTL_COLOR;
            hwfmt[2] |= R300_VAP_OUTPUT_VTX_FMT_0__COLOR_0_PRESENT << i;
        }
    }

    /* Back-face colors. */
    if (any_bcolor_used) {
        for (i = 0; i < ATTR_COLOR_COUNT; i++) {
            hwfmt[1] |= R300_INPUT_CNTL_COLOR;
            hwfmt[2] |= R300_VAP_OUTPUT_VTX_FMT_0__COLOR_0_PRESENT << (2+i);
d92 2
a93 84
    /* Texture coordinates. */
    gen_count = 0;
    for (i = 0; i < ATTR_GENERIC_COUNT; i++) {
        if (vs_outputs->generic[i] != ATTR_UNUSED) {
            hwfmt[1] |= (R300_INPUT_CNTL_TC0 << gen_count);
            hwfmt[3] |= (4 << (3 * gen_count));
            gen_count++;
        }
    }

    /* Fog coordinates. */
    if (vs_outputs->fog != ATTR_UNUSED) {
        hwfmt[1] |= (R300_INPUT_CNTL_TC0 << gen_count);
        hwfmt[3] |= (4 << (3 * gen_count));
        gen_count++;
    }

    /* XXX magic */
    assert(gen_count <= 8);

    /* WPOS. */
    vs->wpos_tex_output = gen_count;
}

/* Sets up stream mapping to equivalent VS outputs if TCL is bypassed
 * or isn't present. */
static void r300_stream_locations_notcl(
    struct r300_shader_semantics* vs_outputs,
    int* stream_loc)
{
    int i, tabi = 0, gen_count;
    boolean any_bcolor_used = vs_outputs->bcolor[0] != ATTR_UNUSED ||
                              vs_outputs->bcolor[1] != ATTR_UNUSED;

    /* Position. */
    stream_loc[tabi++] = 0;

    /* Point size. */
    if (vs_outputs->psize != ATTR_UNUSED) {
        stream_loc[tabi++] = 1;
    }

    /* Colors. */
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        if (vs_outputs->color[i] != ATTR_UNUSED || any_bcolor_used ||
            vs_outputs->color[1] != ATTR_UNUSED) {
            stream_loc[tabi++] = 2 + i;
        }
    }

    /* Back-face colors. */
    if (any_bcolor_used) {
        for (i = 0; i < ATTR_COLOR_COUNT; i++) {
            stream_loc[tabi++] = 4 + i;
        }
    }

    /* Texture coordinates. */
    gen_count = 0;
    for (i = 0; i < ATTR_GENERIC_COUNT; i++) {
        if (vs_outputs->generic[i] != ATTR_UNUSED) {
            assert(tabi < 16);
            stream_loc[tabi++] = 6 + gen_count;
            gen_count++;
        }
    }

    /* Fog coordinates. */
    if (vs_outputs->fog != ATTR_UNUSED) {
        assert(tabi < 16);
        stream_loc[tabi++] = 6 + gen_count;
        gen_count++;
    }

    /* WPOS. */
    if (vs_outputs->wpos != ATTR_UNUSED) {
        assert(tabi < 16);
        stream_loc[tabi++] = 6 + gen_count;
        gen_count++;
    }

    for (; tabi < 16;) {
        stream_loc[tabi++] = -1;
    }
d160 7
a166 3
    if (outputs->wpos != ATTR_UNUSED) {
        c->code->outputs[outputs->wpos] = reg++;
    }
d169 3
a171 2
static void r300_insert_wpos(struct r300_vertex_program_compiler* c,
                             struct r300_shader_semantics* outputs)
d173 12
a184 1
    int i, lastOutput = 0;
d186 2
a187 10
    /* Find the max output index. */
    lastOutput = MAX2(lastOutput, outputs->psize);
    for (i = 0; i < ATTR_COLOR_COUNT; i++) {
        lastOutput = MAX2(lastOutput, outputs->color[i]);
        lastOutput = MAX2(lastOutput, outputs->bcolor[i]);
    }
    for (i = 0; i < ATTR_GENERIC_COUNT; i++) {
        lastOutput = MAX2(lastOutput, outputs->generic[i]);
    }
    lastOutput = MAX2(lastOutput, outputs->fog);
d189 3
a191 4
    /* Set WPOS after the last output. */
    lastOutput++;
    rc_copy_output(&c->Base, 0, lastOutput); /* out[lastOutput] = out[0]; */
    outputs->wpos = lastOutput;
d194 2
a195 2
void r300_translate_vertex_shader(struct r300_context* r300,
                                  struct r300_vertex_shader* vs)
d199 1
a199 3

    /* Initialize. */
    r300_shader_read_vs_outputs(&vs->info, &vs->outputs);
d202 1
d205 2
a206 1
    compiler.Base.Debug = DBG_ON(r300, DBG_VP);
d209 7
d217 2
a218 2
    if (compiler.Base.Debug) {
        debug_printf("r300: Initial vertex program\n");
d229 5
a233 1
    compiler.RequiredOutputs = ~(~0 << (vs->info.num_outputs+1));
d237 1
a237 4
    r300_insert_wpos(&compiler, &vs->outputs);

    r300_shader_vap_output_fmt(vs);
    r300_stream_locations_notcl(&vs->outputs, vs->stream_loc_notcl);
d242 12
a253 3
        /* XXX We should fallback using Draw. */
        fprintf(stderr, "r300 VP: Compiler error\n");
        abort();
d256 12
a269 28
    vs->translated = TRUE;
}

boolean r300_vertex_shader_setup_wpos(struct r300_context* r300)
{
    struct r300_vertex_shader* vs = r300->vs_state.state;
    int tex_output = vs->wpos_tex_output;
    uint32_t tex_fmt = R300_INPUT_CNTL_TC0 << tex_output;
    uint32_t* hwfmt = vs->hwfmt;

    if (r300->fs->inputs.wpos != ATTR_UNUSED) {
        /* Enable WPOS in VAP. */
        if (!(hwfmt[1] & tex_fmt)) {
            hwfmt[1] |= tex_fmt;
            hwfmt[3] |= (4 << (3 * tex_output));

            assert(tex_output < 8);
            return TRUE;
        }
    } else {
        /* Disable WPOS in VAP. */
        if (hwfmt[1] & tex_fmt) {
            hwfmt[1] &= ~tex_fmt;
            hwfmt[3] &= ~(4 << (3 * tex_output));
            return TRUE;
        }
    }
    return FALSE;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d25 1
a33 1
#include "tgsi/tgsi_ureg.h"
d37 2
d85 2
a86 1
                fprintf(stderr, "r300 VP: cannot handle edgeflag output.\n");
d88 45
d134 72
a205 3
            default:
                fprintf(stderr, "r300 VP: unknown vertex output semantic: %i.\n",
                        info->output_semantic_name[i]);
d209 17
a225 2
    /* WPOS is a straight copy of POSITION and it's always emitted. */
    vs_outputs->wpos = i;
d292 3
a294 1
    c->code->outputs[outputs->wpos] = reg++;
d297 2
a298 1
void r300_init_vs_outputs(struct r300_vertex_shader *vs)
d300 1
a300 3
    tgsi_scan_shader(vs->state.tokens, &vs->info);
    r300_shader_read_vs_outputs(&vs->info, &vs->outputs);
}
d302 10
a311 16
static void r300_dummy_vertex_shader(
    struct r300_context* r300,
    struct r300_vertex_shader* shader)
{
    struct ureg_program *ureg;
    struct ureg_dst dst;
    struct ureg_src imm;

    /* Make a simple vertex shader which outputs (0, 0, 0, 1),
     * effectively rendering nothing. */
    ureg = ureg_create(TGSI_PROCESSOR_VERTEX);
    dst = ureg_DECL_output(ureg, TGSI_SEMANTIC_POSITION, 0);
    imm = ureg_imm4f(ureg, 0, 0, 0, 1);

    ureg_MOV(ureg, dst, imm);
    ureg_END(ureg);
d313 4
a316 6
    shader->state.tokens = tgsi_dup_tokens(ureg_finalize(ureg));
    ureg_destroy(ureg);

    shader->dummy = TRUE;
    r300_init_vs_outputs(shader);
    r300_translate_vertex_shader(r300, shader);
d319 2
a320 2
void r300_translate_vertex_shader(struct r300_context *r300,
                                  struct r300_vertex_shader *vs)
d324 3
a326 1
    unsigned i;
a328 1
    memset(&compiler, 0, sizeof(compiler));
d331 1
a331 2
    DBG_ON(r300, DBG_VP) ? compiler.Base.Debug |= RC_DBG_LOG : 0;
    DBG_ON(r300, DBG_P_STAT) ? compiler.Base.Debug |= RC_DBG_STATS : 0;
a333 7
    compiler.Base.is_r500 = r300->screen->caps.is_r500;
    compiler.Base.disable_optimizations = DBG_ON(r300, DBG_NO_OPT);
    compiler.Base.has_half_swizzles = FALSE;
    compiler.Base.has_presub = FALSE;
    compiler.Base.max_temp_regs = 32;
    compiler.Base.max_constants = 256;
    compiler.Base.max_alu_insts = r300->screen->caps.is_r500 ? 1024 : 256;
d335 2
a336 2
    if (compiler.Base.Debug & RC_DBG_LOG) {
        DBG(r300, DBG_VP, "r300: Initial vertex program\n");
d347 1
a347 5
    if (compiler.Base.Program.Constants.Count > 200) {
        compiler.Base.remove_unused_constants = TRUE;
    }

    compiler.RequiredOutputs = ~(~0 << (vs->info.num_outputs + 1));
d351 4
a354 1
    rc_copy_output(&compiler.Base, 0, vs->outputs.wpos);
d359 4
a362 2
        fprintf(stderr, "r300 VP: Compiler error:\n%sUsing a dummy shader"
                " instead.\n", compiler.Base.ErrorMsg);
d364 4
a367 5
        if (vs->dummy) {
            fprintf(stderr, "r300 VP: Cannot compile the dummy shader! "
                    "Giving up...\n");
            abort();
        }
d369 12
a380 4
        rc_destroy(&compiler.Base);
        r300_dummy_vertex_shader(r300, vs);
        return;
    }
d382 10
a391 9
    /* Initialize numbers of constants for each type. */
    vs->externals_count = 0;
    for (i = 0;
         i < vs->code.constants.Count &&
         vs->code.constants.Constants[i].Type == RC_CONSTANT_EXTERNAL; i++) {
        vs->externals_count = i+1;
    }
    for (; i < vs->code.constants.Count; i++) {
        assert(vs->code.constants.Constants[i].Type == RC_CONSTANT_IMMEDIATE);
d393 1
a393 4
    vs->immediates_count = vs->code.constants.Count - vs->externals_count;

    /* And, finally... */
    rc_destroy(&compiler.Base);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d35 1
a35 1
#include "compiler/radeon_compiler.h"
a38 1
    struct r300_context *r300,
a73 1
                vs_outputs->num_generic++;
a85 8
            case TGSI_SEMANTIC_CLIPVERTEX:
                assert(index == 0);
                /* Draw does clip vertex for us. */
                if (r300->screen->caps.has_tcl) {
                    fprintf(stderr, "r300 VP: cannot handle clip vertex output.\n");
                }
                break;

d163 1
a163 2
void r300_init_vs_outputs(struct r300_context *r300,
                          struct r300_vertex_shader *vs)
d166 1
a166 1
    r300_shader_read_vs_outputs(r300, &vs->info, &vs->outputs);
d190 1
a190 1
    r300_init_vs_outputs(r300, shader);
d203 1
a203 1
    rc_init(&compiler.Base, NULL);
a212 1
    compiler.Base.has_omod = FALSE;
a227 7

    if (ttr.error) {
        fprintf(stderr, "r300 VP: Cannot translate a shader. "
                "Using a dummy shader instead.\n");
        r300_dummy_vertex_shader(r300, vs);
        return;
    }
@


