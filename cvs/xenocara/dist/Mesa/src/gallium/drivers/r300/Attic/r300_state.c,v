head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.07.29.05.47.25;	author mpi;	state Exp;
branches;
next	1.7;
commitid	7LgDWgovbCk9WPgF;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.58;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.02;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.07;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.04;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.45.14;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2009 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "draw/draw_context.h"

#include "util/u_framebuffer.h"
#include "util/u_half.h"
#include "util/u_helpers.h"
#include "util/u_math.h"
#include "util/u_mm.h"
#include "util/u_memory.h"
#include "util/u_pack_color.h"
#include "util/u_transfer.h"

#include "tgsi/tgsi_parse.h"

#include "pipe/p_config.h"

#include "r300_cb.h"
#include "r300_context.h"
#include "r300_emit.h"
#include "r300_reg.h"
#include "r300_screen.h"
#include "r300_screen_buffer.h"
#include "r300_state_inlines.h"
#include "r300_fs.h"
#include "r300_texture.h"
#include "r300_vs.h"

/* r300_state: Functions used to intialize state context by translating
 * Gallium state objects into semi-native r300 state objects. */

#define UPDATE_STATE(cso, atom) \
    if (cso != atom.state) { \
        atom.state = cso;    \
        r300_mark_atom_dirty(r300, &(atom));   \
    }

static boolean blend_discard_if_src_alpha_0(unsigned srcRGB, unsigned srcA,
                                            unsigned dstRGB, unsigned dstA)
{
    /* If the blend equation is ADD or REVERSE_SUBTRACT,
     * SRC_ALPHA == 0, and the following state is set, the colorbuffer
     * will not be changed.
     * Notice that the dst factors are the src factors inverted. */
    return (srcRGB == PIPE_BLENDFACTOR_SRC_ALPHA ||
            srcRGB == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE ||
            srcRGB == PIPE_BLENDFACTOR_ZERO) &&
           (srcA == PIPE_BLENDFACTOR_SRC_COLOR ||
            srcA == PIPE_BLENDFACTOR_SRC_ALPHA ||
            srcA == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE ||
            srcA == PIPE_BLENDFACTOR_ZERO) &&
           (dstRGB == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
            dstRGB == PIPE_BLENDFACTOR_ONE) &&
           (dstA == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
            dstA == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
            dstA == PIPE_BLENDFACTOR_ONE);
}

static boolean blend_discard_if_src_alpha_1(unsigned srcRGB, unsigned srcA,
                                            unsigned dstRGB, unsigned dstA)
{
    /* If the blend equation is ADD or REVERSE_SUBTRACT,
     * SRC_ALPHA == 1, and the following state is set, the colorbuffer
     * will not be changed.
     * Notice that the dst factors are the src factors inverted. */
    return (srcRGB == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
            srcRGB == PIPE_BLENDFACTOR_ZERO) &&
           (srcA == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
            srcA == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
            srcA == PIPE_BLENDFACTOR_ZERO) &&
           (dstRGB == PIPE_BLENDFACTOR_SRC_ALPHA ||
            dstRGB == PIPE_BLENDFACTOR_ONE) &&
           (dstA == PIPE_BLENDFACTOR_SRC_COLOR ||
            dstA == PIPE_BLENDFACTOR_SRC_ALPHA ||
            dstA == PIPE_BLENDFACTOR_ONE);
}

static boolean blend_discard_if_src_color_0(unsigned srcRGB, unsigned srcA,
                                            unsigned dstRGB, unsigned dstA)
{
    /* If the blend equation is ADD or REVERSE_SUBTRACT,
     * SRC_COLOR == (0,0,0), and the following state is set, the colorbuffer
     * will not be changed.
     * Notice that the dst factors are the src factors inverted. */
    return (srcRGB == PIPE_BLENDFACTOR_SRC_COLOR ||
            srcRGB == PIPE_BLENDFACTOR_ZERO) &&
           (srcA == PIPE_BLENDFACTOR_ZERO) &&
           (dstRGB == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
            dstRGB == PIPE_BLENDFACTOR_ONE) &&
           (dstA == PIPE_BLENDFACTOR_ONE);
}

static boolean blend_discard_if_src_color_1(unsigned srcRGB, unsigned srcA,
                                            unsigned dstRGB, unsigned dstA)
{
    /* If the blend equation is ADD or REVERSE_SUBTRACT,
     * SRC_COLOR == (1,1,1), and the following state is set, the colorbuffer
     * will not be changed.
     * Notice that the dst factors are the src factors inverted. */
    return (srcRGB == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
            srcRGB == PIPE_BLENDFACTOR_ZERO) &&
           (srcA == PIPE_BLENDFACTOR_ZERO) &&
           (dstRGB == PIPE_BLENDFACTOR_SRC_COLOR ||
            dstRGB == PIPE_BLENDFACTOR_ONE) &&
           (dstA == PIPE_BLENDFACTOR_ONE);
}

static boolean blend_discard_if_src_alpha_color_0(unsigned srcRGB, unsigned srcA,
                                                  unsigned dstRGB, unsigned dstA)
{
    /* If the blend equation is ADD or REVERSE_SUBTRACT,
     * SRC_ALPHA_COLOR == (0,0,0,0), and the following state is set,
     * the colorbuffer will not be changed.
     * Notice that the dst factors are the src factors inverted. */
    return (srcRGB == PIPE_BLENDFACTOR_SRC_COLOR ||
            srcRGB == PIPE_BLENDFACTOR_SRC_ALPHA ||
            srcRGB == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE ||
            srcRGB == PIPE_BLENDFACTOR_ZERO) &&
           (srcA == PIPE_BLENDFACTOR_SRC_COLOR ||
            srcA == PIPE_BLENDFACTOR_SRC_ALPHA ||
            srcA == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE ||
            srcA == PIPE_BLENDFACTOR_ZERO) &&
           (dstRGB == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
            dstRGB == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
            dstRGB == PIPE_BLENDFACTOR_ONE) &&
           (dstA == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
            dstA == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
            dstA == PIPE_BLENDFACTOR_ONE);
}

static boolean blend_discard_if_src_alpha_color_1(unsigned srcRGB, unsigned srcA,
                                                  unsigned dstRGB, unsigned dstA)
{
    /* If the blend equation is ADD or REVERSE_SUBTRACT,
     * SRC_ALPHA_COLOR == (1,1,1,1), and the following state is set,
     * the colorbuffer will not be changed.
     * Notice that the dst factors are the src factors inverted. */
    return (srcRGB == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
            srcRGB == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
            srcRGB == PIPE_BLENDFACTOR_ZERO) &&
           (srcA == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
            srcA == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
            srcA == PIPE_BLENDFACTOR_ZERO) &&
           (dstRGB == PIPE_BLENDFACTOR_SRC_COLOR ||
            dstRGB == PIPE_BLENDFACTOR_SRC_ALPHA ||
            dstRGB == PIPE_BLENDFACTOR_ONE) &&
           (dstA == PIPE_BLENDFACTOR_SRC_COLOR ||
            dstA == PIPE_BLENDFACTOR_SRC_ALPHA ||
            dstA == PIPE_BLENDFACTOR_ONE);
}

static unsigned blend_discard_conditionally(unsigned eqRGB, unsigned eqA,
                                            unsigned dstRGB, unsigned dstA,
                                            unsigned srcRGB, unsigned srcA)
{
    unsigned blend_control = 0;

    /* Optimization: discard pixels which don't change the colorbuffer.
     *
     * The code below is non-trivial and some math is involved.
     *
     * Discarding pixels must be disabled when FP16 AA is enabled.
     * This is a hardware bug. Also, this implementation wouldn't work
     * with FP blending enabled and equation clamping disabled.
     *
     * Equations other than ADD are rarely used and therefore won't be
     * optimized. */
    if ((eqRGB == PIPE_BLEND_ADD || eqRGB == PIPE_BLEND_REVERSE_SUBTRACT) &&
        (eqA == PIPE_BLEND_ADD || eqA == PIPE_BLEND_REVERSE_SUBTRACT)) {
        /* ADD: X+Y
         * REVERSE_SUBTRACT: Y-X
         *
         * The idea is:
         * If X = src*srcFactor = 0 and Y = dst*dstFactor = 1,
         * then CB will not be changed.
         *
         * Given the srcFactor and dstFactor variables, we can derive
         * what src and dst should be equal to and discard appropriate
         * pixels.
         */
        if (blend_discard_if_src_alpha_0(srcRGB, srcA, dstRGB, dstA)) {
            blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_0;
        } else if (blend_discard_if_src_alpha_1(srcRGB, srcA,
                                                dstRGB, dstA)) {
            blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_1;
        } else if (blend_discard_if_src_color_0(srcRGB, srcA,
                                                dstRGB, dstA)) {
            blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_0;
        } else if (blend_discard_if_src_color_1(srcRGB, srcA,
                                                dstRGB, dstA)) {
            blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_1;
        } else if (blend_discard_if_src_alpha_color_0(srcRGB, srcA,
                                                      dstRGB, dstA)) {
            blend_control |=
                R300_DISCARD_SRC_PIXELS_SRC_ALPHA_COLOR_0;
        } else if (blend_discard_if_src_alpha_color_1(srcRGB, srcA,
                                                      dstRGB, dstA)) {
            blend_control |=
                R300_DISCARD_SRC_PIXELS_SRC_ALPHA_COLOR_1;
        }
    }
    return blend_control;
}

/* The hardware colormask is clunky a must be swizzled depending on the format.
 * This was figured out by trial-and-error. */
static unsigned argb_cmask(unsigned mask)
{
   return ((mask & (PIPE_MASK_R | PIPE_MASK_G | PIPE_MASK_B)) << 1) |
          ((mask & PIPE_MASK_A) >> 3);
}

static unsigned bgra_cmask(unsigned mask)
{
    return ((mask & PIPE_MASK_R) << 2) |
           ((mask & PIPE_MASK_B) >> 2) |
           (mask & (PIPE_MASK_G | PIPE_MASK_A));
}

static unsigned rgba_cmask(unsigned mask)
{
    return mask & PIPE_MASK_RGBA;
}

static unsigned rrrr_cmask(unsigned mask)
{
    return (mask & PIPE_MASK_R) |
           ((mask & PIPE_MASK_R) << 1) |
           ((mask & PIPE_MASK_R) << 2) |
           ((mask & PIPE_MASK_R) << 3);
}

static unsigned aaaa_cmask(unsigned mask)
{
    return ((mask & PIPE_MASK_A) >> 3) |
           ((mask & PIPE_MASK_A) >> 2) |
           ((mask & PIPE_MASK_A) >> 1) |
           (mask & PIPE_MASK_A);
}

static unsigned grrg_cmask(unsigned mask)
{
    return ((mask & PIPE_MASK_R) << 1) |
           ((mask & PIPE_MASK_R) << 2) |
           ((mask & PIPE_MASK_G) >> 1) |
           ((mask & PIPE_MASK_G) << 2);
}

static unsigned arra_cmask(unsigned mask)
{
    return ((mask & PIPE_MASK_R) << 1) |
           ((mask & PIPE_MASK_R) << 2) |
           ((mask & PIPE_MASK_A) >> 3) |
           (mask & PIPE_MASK_A);
}

static unsigned blend_read_enable(unsigned eqRGB, unsigned eqA,
                                  unsigned dstRGB, unsigned dstA,
                                  unsigned srcRGB, unsigned srcA,
                                  boolean src_alpha_optz)
{
    unsigned blend_control = 0;

    /* Optimization: some operations do not require the destination color.
     *
     * When SRC_ALPHA_SATURATE is used, colorbuffer reads must be enabled,
     * otherwise blending gives incorrect results. It seems to be
     * a hardware bug. */
    if (eqRGB == PIPE_BLEND_MIN || eqA == PIPE_BLEND_MIN ||
        eqRGB == PIPE_BLEND_MAX || eqA == PIPE_BLEND_MAX ||
        dstRGB != PIPE_BLENDFACTOR_ZERO ||
        dstA != PIPE_BLENDFACTOR_ZERO ||
        srcRGB == PIPE_BLENDFACTOR_DST_COLOR ||
        srcRGB == PIPE_BLENDFACTOR_DST_ALPHA ||
        srcRGB == PIPE_BLENDFACTOR_INV_DST_COLOR ||
        srcRGB == PIPE_BLENDFACTOR_INV_DST_ALPHA ||
        srcA == PIPE_BLENDFACTOR_DST_COLOR ||
        srcA == PIPE_BLENDFACTOR_DST_ALPHA ||
        srcA == PIPE_BLENDFACTOR_INV_DST_COLOR ||
        srcA == PIPE_BLENDFACTOR_INV_DST_ALPHA ||
        srcRGB == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE) {
        /* Enable reading from the colorbuffer. */
        blend_control |= R300_READ_ENABLE;

        if (src_alpha_optz) {
            /* Optimization: Depending on incoming pixels, we can
             * conditionally disable the reading in hardware... */
            if (eqRGB != PIPE_BLEND_MIN && eqA != PIPE_BLEND_MIN &&
                eqRGB != PIPE_BLEND_MAX && eqA != PIPE_BLEND_MAX) {
                /* Disable reading if SRC_ALPHA == 0. */
                if ((dstRGB == PIPE_BLENDFACTOR_SRC_ALPHA ||
                     dstRGB == PIPE_BLENDFACTOR_ZERO) &&
                    (dstA == PIPE_BLENDFACTOR_SRC_COLOR ||
                     dstA == PIPE_BLENDFACTOR_SRC_ALPHA ||
                     dstA == PIPE_BLENDFACTOR_ZERO) &&
                    (srcRGB != PIPE_BLENDFACTOR_DST_COLOR &&
                     srcRGB != PIPE_BLENDFACTOR_DST_ALPHA &&
                     srcRGB != PIPE_BLENDFACTOR_INV_DST_COLOR &&
                     srcRGB != PIPE_BLENDFACTOR_INV_DST_ALPHA)) {
                     blend_control |= R500_SRC_ALPHA_0_NO_READ;
                }

                /* Disable reading if SRC_ALPHA == 1. */
                if ((dstRGB == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
                     dstRGB == PIPE_BLENDFACTOR_ZERO) &&
                    (dstA == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
                     dstA == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
                     dstA == PIPE_BLENDFACTOR_ZERO) &&
                    (srcRGB != PIPE_BLENDFACTOR_DST_COLOR &&
                     srcRGB != PIPE_BLENDFACTOR_DST_ALPHA &&
                     srcRGB != PIPE_BLENDFACTOR_INV_DST_COLOR &&
                     srcRGB != PIPE_BLENDFACTOR_INV_DST_ALPHA)) {
                     blend_control |= R500_SRC_ALPHA_1_NO_READ;
                }
            }
        }
    }
    return blend_control;
}

/* Create a new blend state based on the CSO blend state.
 *
 * This encompasses alpha blending, logic/raster ops, and blend dithering. */
static void* r300_create_blend_state(struct pipe_context* pipe,
                                     const struct pipe_blend_state* state)
{
    struct r300_screen* r300screen = r300_screen(pipe->screen);
    struct r300_blend_state* blend = CALLOC_STRUCT(r300_blend_state);
    uint32_t blend_control = 0;       /* R300_RB3D_CBLEND: 0x4e04 */
    uint32_t blend_control_noclamp = 0;    /* R300_RB3D_CBLEND: 0x4e04 */
    uint32_t blend_control_noalpha = 0;    /* R300_RB3D_CBLEND: 0x4e04 */
    uint32_t blend_control_noalpha_noclamp = 0;    /* R300_RB3D_CBLEND: 0x4e04 */
    uint32_t alpha_blend_control = 0; /* R300_RB3D_ABLEND: 0x4e08 */
    uint32_t alpha_blend_control_noclamp = 0; /* R300_RB3D_ABLEND: 0x4e08 */
    uint32_t alpha_blend_control_noalpha = 0; /* R300_RB3D_ABLEND: 0x4e08 */
    uint32_t alpha_blend_control_noalpha_noclamp = 0; /* R300_RB3D_ABLEND: 0x4e08 */
    uint32_t rop = 0;                 /* R300_RB3D_ROPCNTL: 0x4e18 */
    uint32_t dither = 0;              /* R300_RB3D_DITHER_CTL: 0x4e50 */
    int i;

    const unsigned eqRGB = state->rt[0].rgb_func;
    const unsigned srcRGB = state->rt[0].rgb_src_factor;
    const unsigned dstRGB = state->rt[0].rgb_dst_factor;

    const unsigned eqA = state->rt[0].alpha_func;
    const unsigned srcA = state->rt[0].alpha_src_factor;
    const unsigned dstA = state->rt[0].alpha_dst_factor;

    unsigned srcRGBX = srcRGB;
    unsigned dstRGBX = dstRGB;
    CB_LOCALS;

    blend->state = *state;

    /* force DST_ALPHA to ONE where we can */
    switch (srcRGBX) {
    case PIPE_BLENDFACTOR_DST_ALPHA:
        srcRGBX = PIPE_BLENDFACTOR_ONE;
        break;
    case PIPE_BLENDFACTOR_INV_DST_ALPHA:
        srcRGBX = PIPE_BLENDFACTOR_ZERO;
        break;
    }

    switch (dstRGBX) {
    case PIPE_BLENDFACTOR_DST_ALPHA:
        dstRGBX = PIPE_BLENDFACTOR_ONE;
        break;
    case PIPE_BLENDFACTOR_INV_DST_ALPHA:
        dstRGBX = PIPE_BLENDFACTOR_ZERO;
        break;
    }

    /* Get blending register values. */
    if (state->rt[0].blend_enable) {
        unsigned blend_eq, blend_eq_noclamp;

        /* despite the name, ALPHA_BLEND_ENABLE has nothing to do with alpha,
         * this is just the crappy D3D naming */
        blend_control = blend_control_noclamp =
            R300_ALPHA_BLEND_ENABLE |
            ( r300_translate_blend_factor(srcRGB) << R300_SRC_BLEND_SHIFT) |
            ( r300_translate_blend_factor(dstRGB) << R300_DST_BLEND_SHIFT);

        blend_control_noalpha = blend_control_noalpha_noclamp =
            R300_ALPHA_BLEND_ENABLE |
            ( r300_translate_blend_factor(srcRGBX) << R300_SRC_BLEND_SHIFT) |
            ( r300_translate_blend_factor(dstRGBX) << R300_DST_BLEND_SHIFT);

        blend_eq = r300_translate_blend_function(eqRGB, TRUE);
        blend_eq_noclamp = r300_translate_blend_function(eqRGB, FALSE);

        blend_control |= blend_eq;
        blend_control_noalpha |= blend_eq;
        blend_control_noclamp |= blend_eq_noclamp;
        blend_control_noalpha_noclamp |= blend_eq_noclamp;

        /* Optimization: some operations do not require the destination color. */
        blend_control |= blend_read_enable(eqRGB, eqA, dstRGB, dstA,
                                           srcRGB, srcA, r300screen->caps.is_r500);
        blend_control_noclamp |= blend_read_enable(eqRGB, eqA, dstRGB, dstA,
                                                   srcRGB, srcA, FALSE);
        blend_control_noalpha |= blend_read_enable(eqRGB, eqA, dstRGBX, dstA,
                                                   srcRGBX, srcA, r300screen->caps.is_r500);
        blend_control_noalpha_noclamp |= blend_read_enable(eqRGB, eqA, dstRGBX, dstA,
                                                           srcRGBX, srcA, FALSE);

        /* Optimization: discard pixels which don't change the colorbuffer.
         * It cannot be used with FP16 AA. */
        blend_control |= blend_discard_conditionally(eqRGB, eqA, dstRGB, dstA,
                                                     srcRGB, srcA);
        blend_control_noalpha |= blend_discard_conditionally(eqRGB, eqA, dstRGBX, dstA,
                                                             srcRGBX, srcA);

        /* separate alpha */
        if (srcA != srcRGB || dstA != dstRGB || eqA != eqRGB) {
            blend_control |= R300_SEPARATE_ALPHA_ENABLE;
            blend_control_noclamp |= R300_SEPARATE_ALPHA_ENABLE;

            alpha_blend_control = alpha_blend_control_noclamp =
                (r300_translate_blend_factor(srcA) << R300_SRC_BLEND_SHIFT) |
                (r300_translate_blend_factor(dstA) << R300_DST_BLEND_SHIFT);
            alpha_blend_control |= r300_translate_blend_function(eqA, TRUE);
            alpha_blend_control_noclamp |= r300_translate_blend_function(eqA, FALSE);
        }
        if (srcA != srcRGBX || dstA != dstRGBX || eqA != eqRGB) {
            blend_control_noalpha |= R300_SEPARATE_ALPHA_ENABLE;
            blend_control_noalpha_noclamp |= R300_SEPARATE_ALPHA_ENABLE;

            alpha_blend_control_noalpha = alpha_blend_control_noalpha_noclamp =
                (r300_translate_blend_factor(srcA) << R300_SRC_BLEND_SHIFT) |
                (r300_translate_blend_factor(dstA) << R300_DST_BLEND_SHIFT);
            alpha_blend_control_noalpha |= r300_translate_blend_function(eqA, TRUE);
            alpha_blend_control_noalpha_noclamp |= r300_translate_blend_function(eqA, FALSE);
        }
    }

    /* PIPE_LOGICOP_* don't need to be translated, fortunately. */
    if (state->logicop_enable) {
        rop = R300_RB3D_ROPCNTL_ROP_ENABLE |
                (state->logicop_func) << R300_RB3D_ROPCNTL_ROP_SHIFT;
    }

    /* Neither fglrx nor classic r300 ever set this, regardless of dithering
     * state. Since it's an optional implementation detail, we can leave it
     * out and never dither.
     *
     * This could be revisited if we ever get quality or conformance hints.
     *
    if (state->dither) {
        dither = R300_RB3D_DITHER_CTL_DITHER_MODE_LUT |
                        R300_RB3D_DITHER_CTL_ALPHA_DITHER_MODE_LUT;
    }
    */

    /* Build a command buffer. */
    {
        unsigned (*func[COLORMASK_NUM_SWIZZLES])(unsigned) = {
            argb_cmask,
            argb_cmask,
            bgra_cmask,
            rgba_cmask,
            rrrr_cmask,
            aaaa_cmask,
            grrg_cmask,
            arra_cmask,
            bgra_cmask,
            rgba_cmask
        };

        for (i = 0; i < COLORMASK_NUM_SWIZZLES; i++) {
            boolean has_alpha = i != COLORMASK_RGBX && i != COLORMASK_BGRX &&
                i != COLORMASK_XRGB;

            BEGIN_CB(blend->cb_clamp[i], 8);
            OUT_CB_REG(R300_RB3D_ROPCNTL, rop);
            OUT_CB_REG_SEQ(R300_RB3D_CBLEND, 3);
            OUT_CB(has_alpha ? blend_control : blend_control_noalpha);
            OUT_CB(has_alpha ? alpha_blend_control : alpha_blend_control_noalpha);
            OUT_CB(func[i](state->rt[0].colormask));
            OUT_CB_REG(R300_RB3D_DITHER_CTL, dither);
            END_CB;
        }
    }

    /* Build a command buffer (for RGBA16F). */
    BEGIN_CB(blend->cb_noclamp, 8);
    OUT_CB_REG(R300_RB3D_ROPCNTL, rop);
    OUT_CB_REG_SEQ(R300_RB3D_CBLEND, 3);
    OUT_CB(blend_control_noclamp);
    OUT_CB(alpha_blend_control_noclamp);
    OUT_CB(rgba_cmask(state->rt[0].colormask));
    OUT_CB_REG(R300_RB3D_DITHER_CTL, dither);
    END_CB;

    /* Build a command buffer (for RGB16F). */
    BEGIN_CB(blend->cb_noclamp_noalpha, 8);
    OUT_CB_REG(R300_RB3D_ROPCNTL, rop);
    OUT_CB_REG_SEQ(R300_RB3D_CBLEND, 3);
    OUT_CB(blend_control_noalpha_noclamp);
    OUT_CB(alpha_blend_control_noalpha_noclamp);
    OUT_CB(rgba_cmask(state->rt[0].colormask));
    OUT_CB_REG(R300_RB3D_DITHER_CTL, dither);
    END_CB;

    /* The same as above, but with no colorbuffer reads and writes. */
    BEGIN_CB(blend->cb_no_readwrite, 8);
    OUT_CB_REG(R300_RB3D_ROPCNTL, rop);
    OUT_CB_REG_SEQ(R300_RB3D_CBLEND, 3);
    OUT_CB(0);
    OUT_CB(0);
    OUT_CB(0);
    OUT_CB_REG(R300_RB3D_DITHER_CTL, dither);
    END_CB;

    return (void*)blend;
}

/* Bind blend state. */
static void r300_bind_blend_state(struct pipe_context* pipe,
                                  void* state)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_blend_state *blend  = (struct r300_blend_state*)state;
    boolean last_alpha_to_one = r300->alpha_to_one;
    boolean last_alpha_to_coverage = r300->alpha_to_coverage;

    UPDATE_STATE(state, r300->blend_state);

    if (!blend)
        return;

    r300->alpha_to_one = blend->state.alpha_to_one;
    r300->alpha_to_coverage = blend->state.alpha_to_coverage;

    if (r300->alpha_to_one != last_alpha_to_one && r300->msaa_enable &&
        r300->fs_status == FRAGMENT_SHADER_VALID) {
        r300->fs_status = FRAGMENT_SHADER_MAYBE_DIRTY;
    }

    if (r300->alpha_to_coverage != last_alpha_to_coverage &&
        r300->msaa_enable) {
        r300_mark_atom_dirty(r300, &r300->dsa_state);
    }
}

/* Free blend state. */
static void r300_delete_blend_state(struct pipe_context* pipe,
                                    void* state)
{
    FREE(state);
}

/* Convert float to 10bit integer */
static unsigned float_to_fixed10(float f)
{
    return CLAMP((unsigned)(f * 1023.9f), 0, 1023);
}

/* Set blend color.
 * Setup both R300 and R500 registers, figure out later which one to write. */
static void r300_set_blend_color(struct pipe_context* pipe,
                                 const struct pipe_blend_color* color)
{
    struct r300_context* r300 = r300_context(pipe);
    struct pipe_framebuffer_state *fb = r300->fb_state.state;
    struct r300_blend_color_state *state =
        (struct r300_blend_color_state*)r300->blend_color_state.state;
    struct pipe_blend_color c;
    struct pipe_surface *cb;
    float tmp;
    CB_LOCALS;

    state->state = *color; /* Save it, so that we can reuse it in set_fb_state */
    c = *color;
    cb = fb->nr_cbufs ? r300_get_nonnull_cb(fb, 0) : NULL;

    /* The blend color is dependent on the colorbuffer format. */
    if (cb) {
        switch (cb->format) {
        case PIPE_FORMAT_R8_UNORM:
        case PIPE_FORMAT_L8_UNORM:
        case PIPE_FORMAT_I8_UNORM:
            c.color[1] = c.color[0];
            break;

        case PIPE_FORMAT_A8_UNORM:
            c.color[1] = c.color[3];
            break;

        case PIPE_FORMAT_R8G8_UNORM:
            c.color[2] = c.color[1];
            break;

        case PIPE_FORMAT_L8A8_UNORM:
        case PIPE_FORMAT_R8A8_UNORM:
            c.color[2] = c.color[3];
            break;

        case PIPE_FORMAT_R8G8B8A8_UNORM:
        case PIPE_FORMAT_R8G8B8X8_UNORM:
            tmp = c.color[0];
            c.color[0] = c.color[2];
            c.color[2] = tmp;
            break;

        default:;
        }
    }

    if (r300->screen->caps.is_r500) {
        BEGIN_CB(state->cb, 3);
        OUT_CB_REG_SEQ(R500_RB3D_CONSTANT_COLOR_AR, 2);

        switch (cb ? cb->format : 0) {
        case PIPE_FORMAT_R16G16B16A16_FLOAT:
        case PIPE_FORMAT_R16G16B16X16_FLOAT:
            OUT_CB(util_float_to_half(c.color[2]) |
                   (util_float_to_half(c.color[3]) << 16));
            OUT_CB(util_float_to_half(c.color[0]) |
                   (util_float_to_half(c.color[1]) << 16));
            break;

        default:
            OUT_CB(float_to_fixed10(c.color[0]) |
                   (float_to_fixed10(c.color[3]) << 16));
            OUT_CB(float_to_fixed10(c.color[2]) |
                   (float_to_fixed10(c.color[1]) << 16));
        }

        END_CB;
    } else {
        union util_color uc;
        util_pack_color(c.color, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);

        BEGIN_CB(state->cb, 2);
        OUT_CB_REG(R300_RB3D_BLEND_COLOR, uc.ui[0]);
        END_CB;
    }

    r300_mark_atom_dirty(r300, &r300->blend_color_state);
}

static void r300_set_clip_state(struct pipe_context* pipe,
                                const struct pipe_clip_state* state)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_clip_state *clip =
            (struct r300_clip_state*)r300->clip_state.state;
    CB_LOCALS;

    if (r300->screen->caps.has_tcl) {
        BEGIN_CB(clip->cb, r300->clip_state.size);
        OUT_CB_REG(R300_VAP_PVS_VECTOR_INDX_REG,
                   (r300->screen->caps.is_r500 ?
                    R500_PVS_UCP_START : R300_PVS_UCP_START));
        OUT_CB_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, 6 * 4);
        OUT_CB_TABLE(state->ucp, 6 * 4);
        END_CB;

        r300_mark_atom_dirty(r300, &r300->clip_state);
    } else {
        draw_set_clip_state(r300->draw, state);
    }
}

/* Create a new depth, stencil, and alpha state based on the CSO dsa state.
 *
 * This contains the depth buffer, stencil buffer, alpha test, and such.
 * On the Radeon, depth and stencil buffer setup are intertwined, which is
 * the reason for some of the strange-looking assignments across registers. */
static void* r300_create_dsa_state(struct pipe_context* pipe,
                          const struct pipe_depth_stencil_alpha_state* state)
{
    boolean is_r500 = r300_screen(pipe->screen)->caps.is_r500;
    struct r300_dsa_state* dsa = CALLOC_STRUCT(r300_dsa_state);
    CB_LOCALS;
    uint32_t alpha_value_fp16 = 0;
    uint32_t z_buffer_control = 0;
    uint32_t z_stencil_control = 0;
    uint32_t stencil_ref_mask = 0;
    uint32_t stencil_ref_bf = 0;

    dsa->dsa = *state;

    /* Depth test setup. - separate write mask depth for decomp flush */
    if (state->depth.writemask) {
        z_buffer_control |= R300_Z_WRITE_ENABLE;
    }

    if (state->depth.enabled) {
        z_buffer_control |= R300_Z_ENABLE;

        z_stencil_control |=
            (r300_translate_depth_stencil_function(state->depth.func) <<
                R300_Z_FUNC_SHIFT);
    }

    /* Stencil buffer setup. */
    if (state->stencil[0].enabled) {
        z_buffer_control |= R300_STENCIL_ENABLE;
        z_stencil_control |=
            (r300_translate_depth_stencil_function(state->stencil[0].func) <<
                R300_S_FRONT_FUNC_SHIFT) |
            (r300_translate_stencil_op(state->stencil[0].fail_op) <<
                R300_S_FRONT_SFAIL_OP_SHIFT) |
            (r300_translate_stencil_op(state->stencil[0].zpass_op) <<
                R300_S_FRONT_ZPASS_OP_SHIFT) |
            (r300_translate_stencil_op(state->stencil[0].zfail_op) <<
                R300_S_FRONT_ZFAIL_OP_SHIFT);

        stencil_ref_mask =
                (state->stencil[0].valuemask << R300_STENCILMASK_SHIFT) |
                (state->stencil[0].writemask << R300_STENCILWRITEMASK_SHIFT);

        if (state->stencil[1].enabled) {
            dsa->two_sided = TRUE;

            z_buffer_control |= R300_STENCIL_FRONT_BACK;
            z_stencil_control |=
            (r300_translate_depth_stencil_function(state->stencil[1].func) <<
                R300_S_BACK_FUNC_SHIFT) |
            (r300_translate_stencil_op(state->stencil[1].fail_op) <<
                R300_S_BACK_SFAIL_OP_SHIFT) |
            (r300_translate_stencil_op(state->stencil[1].zpass_op) <<
                R300_S_BACK_ZPASS_OP_SHIFT) |
            (r300_translate_stencil_op(state->stencil[1].zfail_op) <<
                R300_S_BACK_ZFAIL_OP_SHIFT);

            stencil_ref_bf =
                (state->stencil[1].valuemask << R300_STENCILMASK_SHIFT) |
                (state->stencil[1].writemask << R300_STENCILWRITEMASK_SHIFT);

            if (is_r500) {
                z_buffer_control |= R500_STENCIL_REFMASK_FRONT_BACK;
            } else {
                dsa->two_sided_stencil_ref =
                  (state->stencil[0].valuemask != state->stencil[1].valuemask ||
                   state->stencil[0].writemask != state->stencil[1].writemask);
            }
        }
    }

    /* Alpha test setup. */
    if (state->alpha.enabled) {
        dsa->alpha_function =
            r300_translate_alpha_function(state->alpha.func) |
            R300_FG_ALPHA_FUNC_ENABLE;

        dsa->alpha_function |= float_to_ubyte(state->alpha.ref_value);
        alpha_value_fp16 = util_float_to_half(state->alpha.ref_value);
    }

    BEGIN_CB(&dsa->cb_begin, 8);
    OUT_CB_REG_SEQ(R300_ZB_CNTL, 3);
    OUT_CB(z_buffer_control);
    OUT_CB(z_stencil_control);
    OUT_CB(stencil_ref_mask);
    OUT_CB_REG(R500_ZB_STENCILREFMASK_BF, stencil_ref_bf);
    OUT_CB_REG(R500_FG_ALPHA_VALUE, alpha_value_fp16);
    END_CB;

    BEGIN_CB(dsa->cb_zb_no_readwrite, 8);
    OUT_CB_REG_SEQ(R300_ZB_CNTL, 3);
    OUT_CB(0);
    OUT_CB(0);
    OUT_CB(0);
    OUT_CB_REG(R500_ZB_STENCILREFMASK_BF, 0);
    OUT_CB_REG(R500_FG_ALPHA_VALUE, alpha_value_fp16);
    END_CB;

    return (void*)dsa;
}

static void r300_dsa_inject_stencilref(struct r300_context *r300)
{
    struct r300_dsa_state *dsa =
            (struct r300_dsa_state*)r300->dsa_state.state;

    if (!dsa)
        return;

    dsa->stencil_ref_mask =
        (dsa->stencil_ref_mask & ~R300_STENCILREF_MASK) |
        r300->stencil_ref.ref_value[0];
    dsa->stencil_ref_bf =
        (dsa->stencil_ref_bf & ~R300_STENCILREF_MASK) |
        r300->stencil_ref.ref_value[1];
}

/* Bind DSA state. */
static void r300_bind_dsa_state(struct pipe_context* pipe,
                                void* state)
{
    struct r300_context* r300 = r300_context(pipe);

    if (!state) {
        return;
    }

    UPDATE_STATE(state, r300->dsa_state);

    r300_mark_atom_dirty(r300, &r300->hyperz_state); /* Will be updated before the emission. */
    r300_dsa_inject_stencilref(r300);
}

/* Free DSA state. */
static void r300_delete_dsa_state(struct pipe_context* pipe,
                                  void* state)
{
    FREE(state);
}

static void r300_set_stencil_ref(struct pipe_context* pipe,
                                 const struct pipe_stencil_ref* sr)
{
    struct r300_context* r300 = r300_context(pipe);

    r300->stencil_ref = *sr;

    r300_dsa_inject_stencilref(r300);
    r300_mark_atom_dirty(r300, &r300->dsa_state);
}

static void r300_tex_set_tiling_flags(struct r300_context *r300,
                                      struct r300_resource *tex,
                                      unsigned level)
{
    /* Check if the macrotile flag needs to be changed.
     * Skip changing the flags otherwise. */
    if (tex->tex.macrotile[tex->surface_level] !=
        tex->tex.macrotile[level]) {
        r300->rws->buffer_set_tiling(tex->buf, r300->cs,
                tex->tex.microtile, tex->tex.macrotile[level],
                0, 0, 0, 0, 0,
                tex->tex.stride_in_bytes[0], false);

        tex->surface_level = level;
    }
}

/* This switcheroo is needed just because of goddamned MACRO_SWITCH. */
static void r300_fb_set_tiling_flags(struct r300_context *r300,
                               const struct pipe_framebuffer_state *state)
{
    unsigned i;

    /* Set tiling flags for new surfaces. */
    for (i = 0; i < state->nr_cbufs; i++) {
        if (!state->cbufs[i])
            continue;

        r300_tex_set_tiling_flags(r300,
                                  r300_resource(state->cbufs[i]->texture),
                                  state->cbufs[i]->u.tex.level);
    }
    if (state->zsbuf) {
        r300_tex_set_tiling_flags(r300,
                                  r300_resource(state->zsbuf->texture),
                                  state->zsbuf->u.tex.level);
    }
}

static void r300_print_fb_surf_info(struct pipe_surface *surf, unsigned index,
                                    const char *binding)
{
    struct pipe_resource *tex = surf->texture;
    struct r300_resource *rtex = r300_resource(tex);

    fprintf(stderr,
            "r300:   %s[%i] Dim: %ix%i, Firstlayer: %i, "
            "Lastlayer: %i, Level: %i, Format: %s\n"

            "r300:     TEX: Macro: %s, Micro: %s, "
            "Dim: %ix%ix%i, LastLevel: %i, Format: %s\n",

            binding, index, surf->width, surf->height,
            surf->u.tex.first_layer, surf->u.tex.last_layer, surf->u.tex.level,
            util_format_short_name(surf->format),

            rtex->tex.macrotile[0] ? "YES" : " NO",
            rtex->tex.microtile ? "YES" : " NO",
            tex->width0, tex->height0, tex->depth0,
            tex->last_level, util_format_short_name(surf->format));
}

void r300_mark_fb_state_dirty(struct r300_context *r300,
                              enum r300_fb_state_change change)
{
    struct pipe_framebuffer_state *state = r300->fb_state.state;

    r300_mark_atom_dirty(r300, &r300->gpu_flush);
    r300_mark_atom_dirty(r300, &r300->fb_state);

    /* What is marked as dirty depends on the enum r300_fb_state_change. */
    if (change == R300_CHANGED_FB_STATE) {
        r300_mark_atom_dirty(r300, &r300->aa_state);
        r300_mark_atom_dirty(r300, &r300->dsa_state); /* for AlphaRef */
        r300_set_blend_color(&r300->context, r300->blend_color_state.state);
    }

    if (change == R300_CHANGED_FB_STATE ||
        change == R300_CHANGED_HYPERZ_FLAG) {
        r300_mark_atom_dirty(r300, &r300->hyperz_state);
    }

    if (change == R300_CHANGED_FB_STATE ||
        change == R300_CHANGED_MULTIWRITE) {
        r300_mark_atom_dirty(r300, &r300->fb_state_pipelined);
    }

    /* Now compute the fb_state atom size. */
    r300->fb_state.size = 2 + (8 * state->nr_cbufs);

    if (r300->cbzb_clear)
        r300->fb_state.size += 10;
    else if (state->zsbuf) {
        r300->fb_state.size += 10;
        if (r300->hyperz_enabled)
            r300->fb_state.size += 8;
    }

    if (r300->cmask_in_use) {
        r300->fb_state.size += 6;
        if (r300->screen->caps.is_r500 && r300->screen->info.drm_minor >= 29) {
            r300->fb_state.size += 3;
        }
    }

    /* The size of the rest of atoms stays the same. */
}

static unsigned r300_get_num_samples(struct r300_context *r300)
{
    struct pipe_framebuffer_state* fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    unsigned i, num_samples;

    if (!fb->nr_cbufs && !fb->zsbuf)
        return 1;

    num_samples = 6;

    for (i = 0; i < fb->nr_cbufs; i++)
        if (fb->cbufs[i])
            num_samples = MIN2(num_samples, fb->cbufs[i]->texture->nr_samples);

    if (fb->zsbuf)
        num_samples = MIN2(num_samples, fb->zsbuf->texture->nr_samples);

    if (!num_samples)
        num_samples = 1;

    return num_samples;
}

static void
r300_set_framebuffer_state(struct pipe_context* pipe,
                           const struct pipe_framebuffer_state* state)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_aa_state *aa = (struct r300_aa_state*)r300->aa_state.state;
    struct pipe_framebuffer_state *current_state = r300->fb_state.state;
    unsigned max_width, max_height, i;
    uint32_t zbuffer_bpp = 0;
    boolean unlock_zbuffer = FALSE;

    if (r300->screen->caps.is_r500) {
        max_width = max_height = 4096;
    } else if (r300->screen->caps.is_r400) {
        max_width = max_height = 4021;
    } else {
        max_width = max_height = 2560;
    }

    if (state->width > max_width || state->height > max_height) {
        fprintf(stderr, "r300: Implementation error: Render targets are too "
        "big in %s, refusing to bind framebuffer state!\n", __FUNCTION__);
        return;
    }

    if (current_state->zsbuf && r300->zmask_in_use && !r300->locked_zbuffer) {
        /* There is a zmask in use, what are we gonna do? */
        if (state->zsbuf) {
            if (!pipe_surface_equal(current_state->zsbuf, state->zsbuf)) {
                /* Decompress the currently bound zbuffer before we bind another one. */
                r300_decompress_zmask(r300);
                r300->hiz_in_use = FALSE;
            }
        } else {
            /* We don't bind another zbuffer, so lock the current one. */
            pipe_surface_reference(&r300->locked_zbuffer, current_state->zsbuf);
        }
    } else if (r300->locked_zbuffer) {
        /* We have a locked zbuffer now, what are we gonna do? */
        if (state->zsbuf) {
            if (!pipe_surface_equal(r300->locked_zbuffer, state->zsbuf)) {
                /* We are binding some other zbuffer, so decompress the locked one,
                 * it gets unlocked automatically. */
                r300_decompress_zmask_locked_unsafe(r300);
                r300->hiz_in_use = FALSE;
            } else {
                /* We are binding the locked zbuffer again, so unlock it. */
                unlock_zbuffer = TRUE;
            }
        }
    }
    assert(state->zsbuf || (r300->locked_zbuffer && !unlock_zbuffer) || !r300->zmask_in_use);

    /* If zsbuf is set from NULL to non-NULL or vice versa.. */
    if (!!current_state->zsbuf != !!state->zsbuf) {
        r300_mark_atom_dirty(r300, &r300->dsa_state);
    }

    util_copy_framebuffer_state(r300->fb_state.state, state);

    /* Remove trailing NULL colorbuffers. */
    while (current_state->nr_cbufs && !current_state->cbufs[current_state->nr_cbufs-1])
        current_state->nr_cbufs--;

    /* Set whether CMASK can be used. */
    r300->cmask_in_use =
        state->nr_cbufs == 1 && state->cbufs[0] &&
        r300->screen->cmask_resource == state->cbufs[0]->texture;

    /* Need to reset clamping or colormask. */
    r300_mark_atom_dirty(r300, &r300->blend_state);

    /* Re-swizzle the blend color. */
    r300_set_blend_color(pipe, &((struct r300_blend_color_state*)r300->blend_color_state.state)->state);

    if (r300->screen->info.drm_minor < 12) {
       /* The tiling flags are dependent on the surface miplevel, unfortunately.
        * This workarounds a bad design decision in old kernels which were
        * rewriting tile fields in registers. */
        r300_fb_set_tiling_flags(r300, state);
    }

    if (unlock_zbuffer) {
        pipe_surface_reference(&r300->locked_zbuffer, NULL);
    }

    r300_mark_fb_state_dirty(r300, R300_CHANGED_FB_STATE);

    if (state->zsbuf) {
        switch (util_format_get_blocksize(state->zsbuf->format)) {
        case 2:
            zbuffer_bpp = 16;
            break;
        case 4:
            zbuffer_bpp = 24;
            break;
        }

        /* Polygon offset depends on the zbuffer bit depth. */
        if (r300->zbuffer_bpp != zbuffer_bpp) {
            r300->zbuffer_bpp = zbuffer_bpp;

            if (r300->polygon_offset_enabled)
                r300_mark_atom_dirty(r300, &r300->rs_state);
        }
    }

    r300->num_samples = r300_get_num_samples(r300);

    /* Set up AA config. */
    if (r300->num_samples > 1) {
        switch (r300->num_samples) {
        case 2:
            aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE |
                            R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_2;
            break;
        case 4:
            aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE |
                            R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_4;
            break;
        case 6:
            aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE |
                            R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_6;
            break;
        }
    } else {
        aa->aa_config = 0;
    }

    if (DBG_ON(r300, DBG_FB)) {
        fprintf(stderr, "r300: set_framebuffer_state:\n");
        for (i = 0; i < state->nr_cbufs; i++) {
            if (state->cbufs[i])
                r300_print_fb_surf_info(state->cbufs[i], i, "CB");
        }
        if (state->zsbuf) {
            r300_print_fb_surf_info(state->zsbuf, 0, "ZB");
        }
    }
}

/* Create fragment shader state. */
static void* r300_create_fs_state(struct pipe_context* pipe,
                                  const struct pipe_shader_state* shader)
{
    struct r300_fragment_shader* fs = NULL;

    fs = (struct r300_fragment_shader*)CALLOC_STRUCT(r300_fragment_shader);

    /* Copy state directly into shader. */
    fs->state = *shader;
    fs->state.tokens = tgsi_dup_tokens(shader->tokens);

    return (void*)fs;
}

void r300_mark_fs_code_dirty(struct r300_context *r300)
{
    struct r300_fragment_shader* fs = r300_fs(r300);

    r300_mark_atom_dirty(r300, &r300->fs);
    r300_mark_atom_dirty(r300, &r300->fs_rc_constant_state);
    r300_mark_atom_dirty(r300, &r300->fs_constants);
    r300->fs.size = fs->shader->cb_code_size;

    if (r300->screen->caps.is_r500) {
        r300->fs_rc_constant_state.size = fs->shader->rc_state_count * 7;
        r300->fs_constants.size = fs->shader->externals_count * 4 + 3;
    } else {
        r300->fs_rc_constant_state.size = fs->shader->rc_state_count * 5;
        r300->fs_constants.size = fs->shader->externals_count * 4 + 1;
    }

    ((struct r300_constant_buffer*)r300->fs_constants.state)->remap_table =
            fs->shader->code.constants_remap_table;
}

/* Bind fragment shader state. */
static void r300_bind_fs_state(struct pipe_context* pipe, void* shader)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_fragment_shader* fs = (struct r300_fragment_shader*)shader;

    if (fs == NULL) {
        r300->fs.state = NULL;
        return;
    }

    r300->fs.state = fs;
    r300->fs_status = FRAGMENT_SHADER_DIRTY;

    r300_mark_atom_dirty(r300, &r300->rs_block_state); /* Will be updated before the emission. */
}

/* Delete fragment shader state. */
static void r300_delete_fs_state(struct pipe_context* pipe, void* shader)
{
    struct r300_fragment_shader* fs = (struct r300_fragment_shader*)shader;
    struct r300_fragment_shader_code *tmp, *ptr = fs->first;

    while (ptr) {
        tmp = ptr;
        ptr = ptr->next;
        rc_constants_destroy(&tmp->code.constants);
        FREE(tmp->cb_code);
        FREE(tmp);
    }
    FREE((void*)fs->state.tokens);
    FREE(shader);
}

static void r300_set_polygon_stipple(struct pipe_context* pipe,
                                     const struct pipe_poly_stipple* state)
{
    /* XXX no idea how to set this up, but not terribly important */
}

/* Create a new rasterizer state based on the CSO rasterizer state.
 *
 * This is a very large chunk of state, and covers most of the graphics
 * backend (GB), geometry assembly (GA), and setup unit (SU) blocks.
 *
 * In a not entirely unironic sidenote, this state has nearly nothing to do
 * with the actual block on the Radeon called the rasterizer (RS). */
static void* r300_create_rs_state(struct pipe_context* pipe,
                                  const struct pipe_rasterizer_state* state)
{
    struct r300_rs_state* rs = CALLOC_STRUCT(r300_rs_state);
    uint32_t vap_control_status;    /* R300_VAP_CNTL_STATUS: 0x2140 */
    uint32_t vap_clip_cntl;         /* R300_VAP_CLIP_CNTL: 0x221C */
    uint32_t point_size;            /* R300_GA_POINT_SIZE: 0x421c */
    uint32_t point_minmax;          /* R300_GA_POINT_MINMAX: 0x4230 */
    uint32_t line_control;          /* R300_GA_LINE_CNTL: 0x4234 */
    uint32_t polygon_offset_enable; /* R300_SU_POLY_OFFSET_ENABLE: 0x42b4 */
    uint32_t cull_mode;             /* R300_SU_CULL_MODE: 0x42b8 */
    uint32_t line_stipple_config;   /* R300_GA_LINE_STIPPLE_CONFIG: 0x4328 */
    uint32_t line_stipple_value;    /* R300_GA_LINE_STIPPLE_VALUE: 0x4260 */
    uint32_t polygon_mode;          /* R300_GA_POLY_MODE: 0x4288 */
    uint32_t clip_rule;             /* R300_SC_CLIP_RULE: 0x43D0 */
    uint32_t round_mode;            /* R300_GA_ROUND_MODE: 0x428c */

    /* Point sprites texture coordinates, 0: lower left, 1: upper right */
    float point_texcoord_left = 0;  /* R300_GA_POINT_S0: 0x4200 */
    float point_texcoord_bottom = 0;/* R300_GA_POINT_T0: 0x4204 */
    float point_texcoord_right = 1; /* R300_GA_POINT_S1: 0x4208 */
    float point_texcoord_top = 0;   /* R300_GA_POINT_T1: 0x420c */
    boolean vclamp = !r300_context(pipe)->screen->caps.is_r500;
    CB_LOCALS;

    /* Copy rasterizer state. */
    rs->rs = *state;
    rs->rs_draw = *state;

    rs->rs.sprite_coord_enable = state->point_quad_rasterization *
                                 state->sprite_coord_enable;

    /* Override some states for Draw. */
    rs->rs_draw.sprite_coord_enable = 0; /* We can do this in HW. */
    rs->rs_draw.offset_point = 0;
    rs->rs_draw.offset_line = 0;
    rs->rs_draw.offset_tri = 0;
    rs->rs_draw.offset_clamp = 0;

#ifdef PIPE_ARCH_LITTLE_ENDIAN
    vap_control_status = R300_VC_NO_SWAP;
#else
    vap_control_status = R300_VC_32BIT_SWAP;
#endif

    /* If no TCL engine is present, turn off the HW TCL. */
    if (!r300_screen(pipe->screen)->caps.has_tcl) {
        vap_control_status |= R300_VAP_TCL_BYPASS;
    }

    /* Point size width and height. */
    point_size =
        pack_float_16_6x(state->point_size) |
        (pack_float_16_6x(state->point_size) << R300_POINTSIZE_X_SHIFT);

    /* Point size clamping. */
    if (state->point_size_per_vertex) {
        /* Per-vertex point size.
         * Clamp to [0, max FB size] */
        float min_psiz = util_get_min_point_size(state);
        float max_psiz = pipe->screen->get_paramf(pipe->screen,
                                        PIPE_CAPF_MAX_POINT_WIDTH);
        point_minmax =
            (pack_float_16_6x(min_psiz) << R300_GA_POINT_MINMAX_MIN_SHIFT) |
            (pack_float_16_6x(max_psiz) << R300_GA_POINT_MINMAX_MAX_SHIFT);
    } else {
        /* We cannot disable the point-size vertex output,
         * so clamp it. */
        float psiz = state->point_size;
        point_minmax =
            (pack_float_16_6x(psiz) << R300_GA_POINT_MINMAX_MIN_SHIFT) |
            (pack_float_16_6x(psiz) << R300_GA_POINT_MINMAX_MAX_SHIFT);
    }

    /* Line control. */
    line_control = pack_float_16_6x(state->line_width) |
        R300_GA_LINE_CNTL_END_TYPE_COMP;

    /* Enable polygon mode */
    polygon_mode = 0;
    if (state->fill_front != PIPE_POLYGON_MODE_FILL ||
        state->fill_back != PIPE_POLYGON_MODE_FILL) {
        polygon_mode = R300_GA_POLY_MODE_DUAL;
    }

    /* Front face */
    if (state->front_ccw) 
        cull_mode = R300_FRONT_FACE_CCW;
    else
        cull_mode = R300_FRONT_FACE_CW;

    /* Polygon offset */
    polygon_offset_enable = 0;
    if (util_get_offset(state, state->fill_front)) {
       polygon_offset_enable |= R300_FRONT_ENABLE;
    }
    if (util_get_offset(state, state->fill_back)) {
       polygon_offset_enable |= R300_BACK_ENABLE;
    }

    rs->polygon_offset_enable = polygon_offset_enable != 0;

    /* Polygon mode */
    if (polygon_mode) {
       polygon_mode |=
          r300_translate_polygon_mode_front(state->fill_front);
       polygon_mode |=
          r300_translate_polygon_mode_back(state->fill_back);
    }

    if (state->cull_face & PIPE_FACE_FRONT) {
        cull_mode |= R300_CULL_FRONT;
    }
    if (state->cull_face & PIPE_FACE_BACK) {
        cull_mode |= R300_CULL_BACK;
    }

    if (state->line_stipple_enable) {
        line_stipple_config =
            R300_GA_LINE_STIPPLE_CONFIG_LINE_RESET_LINE |
            (fui((float)state->line_stipple_factor) &
                R300_GA_LINE_STIPPLE_CONFIG_STIPPLE_SCALE_MASK);
        /* XXX this might need to be scaled up */
        line_stipple_value = state->line_stipple_pattern;
    } else {
        line_stipple_config = 0;
        line_stipple_value = 0;
    }

    if (state->flatshade) {
        rs->color_control = R300_SHADE_MODEL_FLAT;
    } else {
        rs->color_control = R300_SHADE_MODEL_SMOOTH;
    }

    clip_rule = state->scissor ? 0xAAAA : 0xFFFF;

    /* Point sprites coord mode */
    if (rs->rs.sprite_coord_enable) {
        switch (state->sprite_coord_mode) {
            case PIPE_SPRITE_COORD_UPPER_LEFT:
                point_texcoord_top = 0.0f;
                point_texcoord_bottom = 1.0f;
                break;
            case PIPE_SPRITE_COORD_LOWER_LEFT:
                point_texcoord_top = 1.0f;
                point_texcoord_bottom = 0.0f;
                break;
        }
    }

    if (r300_screen(pipe->screen)->caps.has_tcl) {
       vap_clip_cntl = (state->clip_plane_enable & 63) |
                       R300_PS_UCP_MODE_CLIP_AS_TRIFAN;
    } else {
       vap_clip_cntl = R300_CLIP_DISABLE;
    }

    /* Vertex color clamping. FP20 means no clamping. */
    round_mode =
      R300_GA_ROUND_MODE_GEOMETRY_ROUND_NEAREST |
      (!vclamp ? (R300_GA_ROUND_MODE_RGB_CLAMP_FP20 |
                  R300_GA_ROUND_MODE_ALPHA_CLAMP_FP20) : 0);

    /* Build the main command buffer. */
    BEGIN_CB(rs->cb_main, RS_STATE_MAIN_SIZE);
    OUT_CB_REG(R300_VAP_CNTL_STATUS, vap_control_status);
    OUT_CB_REG(R300_VAP_CLIP_CNTL, vap_clip_cntl);
    OUT_CB_REG(R300_GA_POINT_SIZE, point_size);
    OUT_CB_REG_SEQ(R300_GA_POINT_MINMAX, 2);
    OUT_CB(point_minmax);
    OUT_CB(line_control);
    OUT_CB_REG_SEQ(R300_SU_POLY_OFFSET_ENABLE, 2);
    OUT_CB(polygon_offset_enable);
    rs->cull_mode_index = 11;
    OUT_CB(cull_mode);
    OUT_CB_REG(R300_GA_LINE_STIPPLE_CONFIG, line_stipple_config);
    OUT_CB_REG(R300_GA_LINE_STIPPLE_VALUE, line_stipple_value);
    OUT_CB_REG(R300_GA_POLY_MODE, polygon_mode);
    OUT_CB_REG(R300_GA_ROUND_MODE, round_mode);
    OUT_CB_REG(R300_SC_CLIP_RULE, clip_rule);
    OUT_CB_REG_SEQ(R300_GA_POINT_S0, 4);
    OUT_CB_32F(point_texcoord_left);
    OUT_CB_32F(point_texcoord_bottom);
    OUT_CB_32F(point_texcoord_right);
    OUT_CB_32F(point_texcoord_top);
    END_CB;

    /* Build the two command buffers for polygon offset setup. */
    if (polygon_offset_enable) {
        float scale = state->offset_scale * 12;
        float offset = state->offset_units * 4;

        BEGIN_CB(rs->cb_poly_offset_zb16, 5);
        OUT_CB_REG_SEQ(R300_SU_POLY_OFFSET_FRONT_SCALE, 4);
        OUT_CB_32F(scale);
        OUT_CB_32F(offset);
        OUT_CB_32F(scale);
        OUT_CB_32F(offset);
        END_CB;

        offset = state->offset_units * 2;

        BEGIN_CB(rs->cb_poly_offset_zb24, 5);
        OUT_CB_REG_SEQ(R300_SU_POLY_OFFSET_FRONT_SCALE, 4);
        OUT_CB_32F(scale);
        OUT_CB_32F(offset);
        OUT_CB_32F(scale);
        OUT_CB_32F(offset);
        END_CB;
    }

    return (void*)rs;
}

/* Bind rasterizer state. */
static void r300_bind_rs_state(struct pipe_context* pipe, void* state)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_rs_state* rs = (struct r300_rs_state*)state;
    int last_sprite_coord_enable = r300->sprite_coord_enable;
    boolean last_two_sided_color = r300->two_sided_color;
    boolean last_msaa_enable = r300->msaa_enable;
    boolean last_flatshade = r300->flatshade;

    if (r300->draw && rs) {
        draw_set_rasterizer_state(r300->draw, &rs->rs_draw, state);
    }

    if (rs) {
        r300->polygon_offset_enabled = rs->polygon_offset_enable;
        r300->sprite_coord_enable = rs->rs.sprite_coord_enable;
        r300->two_sided_color = rs->rs.light_twoside;
        r300->msaa_enable = rs->rs.multisample;
        r300->flatshade = rs->rs.flatshade;
    } else {
        r300->polygon_offset_enabled = FALSE;
        r300->sprite_coord_enable = 0;
        r300->two_sided_color = FALSE;
        r300->msaa_enable = FALSE;
        r300->flatshade = FALSE;
    }

    UPDATE_STATE(state, r300->rs_state);
    r300->rs_state.size = RS_STATE_MAIN_SIZE + (r300->polygon_offset_enabled ? 5 : 0);

    if (last_sprite_coord_enable != r300->sprite_coord_enable ||
        last_two_sided_color != r300->two_sided_color ||
        last_flatshade != r300->flatshade) {
        r300_mark_atom_dirty(r300, &r300->rs_block_state);
    }

    if (last_msaa_enable != r300->msaa_enable) {
        if (r300->alpha_to_coverage) {
            r300_mark_atom_dirty(r300, &r300->dsa_state);
        }

        if (r300->alpha_to_one &&
            r300->fs_status == FRAGMENT_SHADER_VALID) {
            r300->fs_status = FRAGMENT_SHADER_MAYBE_DIRTY;
        }
    }
}

/* Free rasterizer state. */
static void r300_delete_rs_state(struct pipe_context* pipe, void* state)
{
    FREE(state);
}

static void*
        r300_create_sampler_state(struct pipe_context* pipe,
                                  const struct pipe_sampler_state* state)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_sampler_state* sampler = CALLOC_STRUCT(r300_sampler_state);
    boolean is_r500 = r300->screen->caps.is_r500;
    int lod_bias;

    sampler->state = *state;

    /* r300 doesn't handle CLAMP and MIRROR_CLAMP correctly when either MAG
     * or MIN filter is NEAREST. Since texwrap produces same results
     * for CLAMP and CLAMP_TO_EDGE, we use them instead. */
    if (sampler->state.min_img_filter == PIPE_TEX_FILTER_NEAREST ||
        sampler->state.mag_img_filter == PIPE_TEX_FILTER_NEAREST) {
        /* Wrap S. */
        if (sampler->state.wrap_s == PIPE_TEX_WRAP_CLAMP)
            sampler->state.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
        else if (sampler->state.wrap_s == PIPE_TEX_WRAP_MIRROR_CLAMP)
            sampler->state.wrap_s = PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE;

        /* Wrap T. */
        if (sampler->state.wrap_t == PIPE_TEX_WRAP_CLAMP)
            sampler->state.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
        else if (sampler->state.wrap_t == PIPE_TEX_WRAP_MIRROR_CLAMP)
            sampler->state.wrap_t = PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE;

        /* Wrap R. */
        if (sampler->state.wrap_r == PIPE_TEX_WRAP_CLAMP)
            sampler->state.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
        else if (sampler->state.wrap_r == PIPE_TEX_WRAP_MIRROR_CLAMP)
            sampler->state.wrap_r = PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE;
    }

    sampler->filter0 |=
        (r300_translate_wrap(sampler->state.wrap_s) << R300_TX_WRAP_S_SHIFT) |
        (r300_translate_wrap(sampler->state.wrap_t) << R300_TX_WRAP_T_SHIFT) |
        (r300_translate_wrap(sampler->state.wrap_r) << R300_TX_WRAP_R_SHIFT);

    sampler->filter0 |= r300_translate_tex_filters(state->min_img_filter,
                                                   state->mag_img_filter,
                                                   state->min_mip_filter,
                                                   state->max_anisotropy > 1);

    sampler->filter0 |= r300_anisotropy(state->max_anisotropy);

    /* Unfortunately, r300-r500 don't support floating-point mipmap lods. */
    /* We must pass these to the merge function to clamp them properly. */
    sampler->min_lod = (unsigned)MAX2(state->min_lod, 0);
    sampler->max_lod = (unsigned)MAX2(ceilf(state->max_lod), 0);

    lod_bias = CLAMP((int)(state->lod_bias * 32 + 1), -(1 << 9), (1 << 9) - 1);

    sampler->filter1 |= (lod_bias << R300_LOD_BIAS_SHIFT) & R300_LOD_BIAS_MASK;

    /* This is very high quality anisotropic filtering for R5xx.
     * It's good for benchmarking the performance of texturing but
     * in practice we don't want to slow down the driver because it's
     * a pretty good performance killer. Feel free to play with it. */
    if (DBG_ON(r300, DBG_ANISOHQ) && is_r500) {
        sampler->filter1 |= r500_anisotropy(state->max_anisotropy);
    }

    /* R500-specific fixups and optimizations */
    if (r300->screen->caps.is_r500) {
        sampler->filter1 |= R500_BORDER_FIX;
    }

    return (void*)sampler;
}

static void r300_bind_sampler_states(struct pipe_context* pipe,
                                     unsigned shader,
                                     unsigned start, unsigned count,
                                     void** states)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_textures_state* state =
        (struct r300_textures_state*)r300->textures_state.state;
    unsigned tex_units = r300->screen->caps.num_tex_units;

    assert(start == 0);

    if (shader != PIPE_SHADER_FRAGMENT)
       return;

    if (count > tex_units)
       return;

    memcpy(state->sampler_states, states, sizeof(void*) * count);
    state->sampler_state_count = count;

    r300_mark_atom_dirty(r300, &r300->textures_state);
}

static void r300_delete_sampler_state(struct pipe_context* pipe, void* state)
{
    FREE(state);
}

static uint32_t r300_assign_texture_cache_region(unsigned index, unsigned num)
{
    /* This looks like a hack, but I believe it's suppose to work like
     * that. To illustrate how this works, let's assume you have 5 textures.
     * From docs, 5 and the successive numbers are:
     *
     * FOURTH_1     = 5
     * FOURTH_2     = 6
     * FOURTH_3     = 7
     * EIGHTH_0     = 8
     * EIGHTH_1     = 9
     *
     * First 3 textures will get 3/4 of size of the cache, divived evenly
     * between them. The last 1/4 of the cache must be divided between
     * the last 2 textures, each will therefore get 1/8 of the cache.
     * Why not just to use "5 + texture_index" ?
     *
     * This simple trick works for all "num" <= 16.
     */
    if (num <= 1)
        return R300_TX_CACHE(R300_TX_CACHE_WHOLE);
    else
        return R300_TX_CACHE(num + index);
}

static void r300_set_sampler_views(struct pipe_context* pipe, unsigned shader,
                                   unsigned start, unsigned count,
                                   struct pipe_sampler_view** views)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_textures_state* state =
        (struct r300_textures_state*)r300->textures_state.state;
    struct r300_resource *texture;
    unsigned i, real_num_views = 0, view_index = 0;
    unsigned tex_units = r300->screen->caps.num_tex_units;
    boolean dirty_tex = FALSE;

    if (shader != PIPE_SHADER_FRAGMENT)
       return;

    assert(start == 0);  /* non-zero not handled yet */

    if (count > tex_units) {
        return;
    }

    /* Calculate the real number of views. */
    for (i = 0; i < count; i++) {
        if (views[i])
            real_num_views++;
    }

    for (i = 0; i < count; i++) {
        pipe_sampler_view_reference(
                (struct pipe_sampler_view**)&state->sampler_views[i],
                views[i]);

        if (!views[i]) {
            continue;
        }

        /* A new sampler view (= texture)... */
        dirty_tex = TRUE;

        /* Set the texrect factor in the fragment shader.
             * Needed for RECT and NPOT fallback. */
        texture = r300_resource(views[i]->texture);
        if (texture->tex.is_npot) {
            r300_mark_atom_dirty(r300, &r300->fs_rc_constant_state);
        }

        state->sampler_views[i]->texcache_region =
                r300_assign_texture_cache_region(view_index, real_num_views);
        view_index++;
    }

    for (i = count; i < tex_units; i++) {
        if (state->sampler_views[i]) {
            pipe_sampler_view_reference(
                    (struct pipe_sampler_view**)&state->sampler_views[i],
                    NULL);
        }
    }

    state->sampler_view_count = count;

    r300_mark_atom_dirty(r300, &r300->textures_state);

    if (dirty_tex) {
        r300_mark_atom_dirty(r300, &r300->texture_cache_inval);
    }
}

struct pipe_sampler_view *
r300_create_sampler_view_custom(struct pipe_context *pipe,
                         struct pipe_resource *texture,
                         const struct pipe_sampler_view *templ,
                         unsigned width0_override,
                         unsigned height0_override)
{
    struct r300_sampler_view *view = CALLOC_STRUCT(r300_sampler_view);
    struct r300_resource *tex = r300_resource(texture);
    boolean is_r500 = r300_screen(pipe->screen)->caps.is_r500;
    boolean dxtc_swizzle = r300_screen(pipe->screen)->caps.dxtc_swizzle;

    if (view) {
        enum pipe_format format = r300_get_hw_format(templ->format, texture->bind);
        unsigned hwformat;

        view->base = *templ;
        view->base.reference.count = 1;
        view->base.context = pipe;
        view->base.texture = NULL;
        pipe_resource_reference(&view->base.texture, texture);

	view->width0_override = width0_override;
	view->height0_override = height0_override;
        view->swizzle[0] = templ->swizzle_r;
        view->swizzle[1] = templ->swizzle_g;
        view->swizzle[2] = templ->swizzle_b;
        view->swizzle[3] = templ->swizzle_a;

        hwformat = r300_translate_texformat(format,
                                            view->swizzle,
                                            is_r500,
                                            dxtc_swizzle);

        if (hwformat == ~0) {
            fprintf(stderr, "r300: Ooops. Got unsupported format %s in %s.\n",
                    util_format_short_name(format), __func__);
        }
        assert(hwformat != ~0);

	r300_texture_setup_format_state(r300_screen(pipe->screen), tex,
					format, 0,
	                                width0_override, height0_override,
					&view->format);
        view->format.format1 |= hwformat;
        if (is_r500) {
            view->format.format2 |= r500_tx_format_msb_bit(format);
        }
    }

    return (struct pipe_sampler_view*)view;
}

static struct pipe_sampler_view *
r300_create_sampler_view(struct pipe_context *pipe,
                         struct pipe_resource *texture,
                         const struct pipe_sampler_view *templ)
{
    return r300_create_sampler_view_custom(pipe, texture, templ,
                                           r300_resource(texture)->tex.width0,
                                           r300_resource(texture)->tex.height0);
}


static void
r300_sampler_view_destroy(struct pipe_context *pipe,
                          struct pipe_sampler_view *view)
{
   pipe_resource_reference(&view->texture, NULL);
   FREE(view);
}

static void r300_set_sample_mask(struct pipe_context *pipe,
                                 unsigned mask)
{
    struct r300_context* r300 = r300_context(pipe);

    *((unsigned*)r300->sample_mask.state) = mask;

    r300_mark_atom_dirty(r300, &r300->sample_mask);
}

static void r300_set_scissor_states(struct pipe_context* pipe,
                                    unsigned start_slot,
                                    unsigned num_scissors,
                                    const struct pipe_scissor_state* state)
{
    struct r300_context* r300 = r300_context(pipe);

    memcpy(r300->scissor_state.state, state,
        sizeof(struct pipe_scissor_state));

    r300_mark_atom_dirty(r300, &r300->scissor_state);
}

static void r300_set_viewport_states(struct pipe_context* pipe,
                                     unsigned start_slot,
                                     unsigned num_viewports,
                                     const struct pipe_viewport_state* state)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_viewport_state* viewport =
        (struct r300_viewport_state*)r300->viewport_state.state;

    r300->viewport = *state;

    if (r300->draw) {
        draw_set_viewport_states(r300->draw, start_slot, num_viewports, state);
        viewport->vte_control = R300_VTX_XY_FMT | R300_VTX_Z_FMT;
        return;
    }

    /* Do the transform in HW. */
    viewport->vte_control = R300_VTX_W0_FMT;

    if (state->scale[0] != 1.0f) {
        viewport->xscale = state->scale[0];
        viewport->vte_control |= R300_VPORT_X_SCALE_ENA;
    }
    if (state->scale[1] != 1.0f) {
        viewport->yscale = state->scale[1];
        viewport->vte_control |= R300_VPORT_Y_SCALE_ENA;
    }
    if (state->scale[2] != 1.0f) {
        viewport->zscale = state->scale[2];
        viewport->vte_control |= R300_VPORT_Z_SCALE_ENA;
    }
    if (state->translate[0] != 0.0f) {
        viewport->xoffset = state->translate[0];
        viewport->vte_control |= R300_VPORT_X_OFFSET_ENA;
    }
    if (state->translate[1] != 0.0f) {
        viewport->yoffset = state->translate[1];
        viewport->vte_control |= R300_VPORT_Y_OFFSET_ENA;
    }
    if (state->translate[2] != 0.0f) {
        viewport->zoffset = state->translate[2];
        viewport->vte_control |= R300_VPORT_Z_OFFSET_ENA;
    }

    r300_mark_atom_dirty(r300, &r300->viewport_state);
    if (r300->fs.state && r300_fs(r300)->shader &&
        r300_fs(r300)->shader->inputs.wpos != ATTR_UNUSED) {
        r300_mark_atom_dirty(r300, &r300->fs_rc_constant_state);
    }
}

static void r300_set_vertex_buffers_hwtcl(struct pipe_context* pipe,
                                    unsigned start_slot, unsigned count,
                                    const struct pipe_vertex_buffer* buffers)
{
    struct r300_context* r300 = r300_context(pipe);

    util_set_vertex_buffers_count(r300->vertex_buffer,
                                  &r300->nr_vertex_buffers,
                                  buffers, start_slot, count);

    /* There must be at least one vertex buffer set, otherwise it locks up. */
    if (!r300->nr_vertex_buffers) {
        util_set_vertex_buffers_count(r300->vertex_buffer,
                                      &r300->nr_vertex_buffers,
                                      &r300->dummy_vb, 0, 1);
    }

    r300->vertex_arrays_dirty = TRUE;
}

static void r300_set_vertex_buffers_swtcl(struct pipe_context* pipe,
                                    unsigned start_slot, unsigned count,
                                    const struct pipe_vertex_buffer* buffers)
{
    struct r300_context* r300 = r300_context(pipe);
    unsigned i;

    util_set_vertex_buffers_count(r300->vertex_buffer,
                                  &r300->nr_vertex_buffers,
                                  buffers, start_slot, count);
    draw_set_vertex_buffers(r300->draw, start_slot, count, buffers);

    if (!buffers)
        return;

    for (i = 0; i < count; i++) {
        if (buffers[i].user_buffer) {
            draw_set_mapped_vertex_buffer(r300->draw, start_slot + i,
                                          buffers[i].user_buffer, ~0);
        } else if (buffers[i].buffer) {
            draw_set_mapped_vertex_buffer(r300->draw, start_slot + i,
                                          r300_resource(buffers[i].buffer)->malloced_buffer, ~0);
        }
    }
}

static void r300_set_index_buffer_hwtcl(struct pipe_context* pipe,
                                        const struct pipe_index_buffer *ib)
{
    struct r300_context* r300 = r300_context(pipe);

    if (ib) {
        pipe_resource_reference(&r300->index_buffer.buffer, ib->buffer);
        memcpy(&r300->index_buffer, ib, sizeof(*ib));
    } else {
        pipe_resource_reference(&r300->index_buffer.buffer, NULL);
    }
}

static void r300_set_index_buffer_swtcl(struct pipe_context* pipe,
                                        const struct pipe_index_buffer *ib)
{
    struct r300_context* r300 = r300_context(pipe);

    if (ib) {
        const void *buf = NULL;
        if (ib->user_buffer) {
            buf = ib->user_buffer;
        } else if (ib->buffer) {
            buf = r300_resource(ib->buffer)->malloced_buffer;
        }
        draw_set_indexes(r300->draw,
                         (const ubyte *) buf + ib->offset,
                         ib->index_size, ~0);
    }
}

/* Initialize the PSC tables. */
static void r300_vertex_psc(struct r300_vertex_element_state *velems)
{
    struct r300_vertex_stream_state *vstream = &velems->vertex_stream;
    uint16_t type, swizzle;
    enum pipe_format format;
    unsigned i;

    /* Vertex shaders have no semantics on their inputs,
     * so PSC should just route stuff based on the vertex elements,
     * and not on attrib information. */
    for (i = 0; i < velems->count; i++) {
        format = velems->velem[i].src_format;

        type = r300_translate_vertex_data_type(format);
        if (type == R300_INVALID_FORMAT) {
            fprintf(stderr, "r300: Bad vertex format %s.\n",
                    util_format_short_name(format));
            assert(0);
            abort();
        }

        type |= i << R300_DST_VEC_LOC_SHIFT;
        swizzle = r300_translate_vertex_data_swizzle(format);

        if (i & 1) {
            vstream->vap_prog_stream_cntl[i >> 1] |= type << 16;
            vstream->vap_prog_stream_cntl_ext[i >> 1] |= swizzle << 16;
        } else {
            vstream->vap_prog_stream_cntl[i >> 1] |= type;
            vstream->vap_prog_stream_cntl_ext[i >> 1] |= swizzle;
        }
    }

    /* Set the last vector in the PSC. */
    if (i) {
        i -= 1;
    }
    vstream->vap_prog_stream_cntl[i >> 1] |=
        (R300_LAST_VEC << (i & 1 ? 16 : 0));

    vstream->count = (i >> 1) + 1;
}

static void* r300_create_vertex_elements_state(struct pipe_context* pipe,
                                               unsigned count,
                                               const struct pipe_vertex_element* attribs)
{
    struct r300_vertex_element_state *velems;
    unsigned i;
    struct pipe_vertex_element dummy_attrib = {0};

    /* R300 Programmable Stream Control (PSC) doesn't support 0 vertex elements. */
    if (!count) {
        dummy_attrib.src_format = PIPE_FORMAT_R8G8B8A8_UNORM;
        attribs = &dummy_attrib;
        count = 1;
    } else if (count > 16) {
        fprintf(stderr, "r300: More than 16 vertex elements are not supported,"
                " requested %i, using 16.\n", count);
        count = 16;
    }

    velems = CALLOC_STRUCT(r300_vertex_element_state);
    if (!velems)
        return NULL;

    velems->count = count;
    memcpy(velems->velem, attribs, sizeof(struct pipe_vertex_element) * count);

    if (r300_screen(pipe->screen)->caps.has_tcl) {
        /* Setup PSC.
         * The unused components will be replaced by (..., 0, 1). */
        r300_vertex_psc(velems);

        for (i = 0; i < count; i++) {
            velems->format_size[i] =
                align(util_format_get_blocksize(velems->velem[i].src_format), 4);
            velems->vertex_size_dwords += velems->format_size[i] / 4;
        }
    }

    return velems;
}

static void r300_bind_vertex_elements_state(struct pipe_context *pipe,
                                            void *state)
{
    struct r300_context *r300 = r300_context(pipe);
    struct r300_vertex_element_state *velems = state;

    if (velems == NULL) {
        return;
    }

    r300->velems = velems;

    if (r300->draw) {
        draw_set_vertex_elements(r300->draw, velems->count, velems->velem);
        return;
    }

    UPDATE_STATE(&velems->vertex_stream, r300->vertex_stream_state);
    r300->vertex_stream_state.size = (1 + velems->vertex_stream.count) * 2;
    r300->vertex_arrays_dirty = TRUE;
}

static void r300_delete_vertex_elements_state(struct pipe_context *pipe, void *state)
{
    FREE(state);
}

static void* r300_create_vs_state(struct pipe_context* pipe,
                                  const struct pipe_shader_state* shader)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_vertex_shader* vs = CALLOC_STRUCT(r300_vertex_shader);

    /* Copy state directly into shader. */
    vs->state = *shader;
    vs->state.tokens = tgsi_dup_tokens(shader->tokens);

    if (r300->screen->caps.has_tcl) {
        r300_init_vs_outputs(r300, vs);
        r300_translate_vertex_shader(r300, vs);
    } else {
        r300_draw_init_vertex_shader(r300, vs);
    }

    return vs;
}

static void r300_bind_vs_state(struct pipe_context* pipe, void* shader)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_vertex_shader* vs = (struct r300_vertex_shader*)shader;

    if (vs == NULL) {
        r300->vs_state.state = NULL;
        return;
    }
    if (vs == r300->vs_state.state) {
        return;
    }
    r300->vs_state.state = vs;

    /* The majority of the RS block bits is dependent on the vertex shader. */
    r300_mark_atom_dirty(r300, &r300->rs_block_state); /* Will be updated before the emission. */

    if (r300->screen->caps.has_tcl) {
        unsigned fc_op_dwords = r300->screen->caps.is_r500 ? 3 : 2;
        r300_mark_atom_dirty(r300, &r300->vs_state);
        r300->vs_state.size = vs->code.length + 9 +
			(R300_VS_MAX_FC_OPS * fc_op_dwords + 4);

        r300_mark_atom_dirty(r300, &r300->vs_constants);
        r300->vs_constants.size =
                2 +
                (vs->externals_count ? vs->externals_count * 4 + 3 : 0) +
                (vs->immediates_count ? vs->immediates_count * 4 + 3 : 0);

        ((struct r300_constant_buffer*)r300->vs_constants.state)->remap_table =
                vs->code.constants_remap_table;

        r300_mark_atom_dirty(r300, &r300->pvs_flush);
    } else {
        draw_bind_vertex_shader(r300->draw,
                (struct draw_vertex_shader*)vs->draw_vs);
    }
}

static void r300_delete_vs_state(struct pipe_context* pipe, void* shader)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_vertex_shader* vs = (struct r300_vertex_shader*)shader;

    if (r300->screen->caps.has_tcl) {
        rc_constants_destroy(&vs->code.constants);
        FREE(vs->code.constants_remap_table);
    } else {
        draw_delete_vertex_shader(r300->draw,
                (struct draw_vertex_shader*)vs->draw_vs);
    }

    FREE((void*)vs->state.tokens);
    FREE(shader);
}

static void r300_set_constant_buffer(struct pipe_context *pipe,
                                     uint shader, uint index,
                                     struct pipe_constant_buffer *cb)
{
    struct r300_context* r300 = r300_context(pipe);
    struct r300_constant_buffer *cbuf;
    uint32_t *mapped;

    if (!cb || (!cb->buffer && !cb->user_buffer))
        return;

    switch (shader) {
        case PIPE_SHADER_VERTEX:
            cbuf = (struct r300_constant_buffer*)r300->vs_constants.state;
            break;
        case PIPE_SHADER_FRAGMENT:
            cbuf = (struct r300_constant_buffer*)r300->fs_constants.state;
            break;
        default:
            return;
    }


    if (cb->user_buffer)
        mapped = (uint32_t*)cb->user_buffer;
    else {
        struct r300_resource *rbuf = r300_resource(cb->buffer);

        if (rbuf && rbuf->malloced_buffer)
            mapped = (uint32_t*)rbuf->malloced_buffer;
        else
            return;
    }

    if (shader == PIPE_SHADER_FRAGMENT ||
        (shader == PIPE_SHADER_VERTEX && r300->screen->caps.has_tcl)) {
        cbuf->ptr = mapped;
    }

    if (shader == PIPE_SHADER_VERTEX) {
        if (r300->screen->caps.has_tcl) {
            struct r300_vertex_shader *vs =
                    (struct r300_vertex_shader*)r300->vs_state.state;

            if (!vs) {
                cbuf->buffer_base = 0;
                return;
            }

            cbuf->buffer_base = r300->vs_const_base;
            r300->vs_const_base += vs->code.constants.Count;
            if (r300->vs_const_base > R500_MAX_PVS_CONST_VECS) {
                r300->vs_const_base = vs->code.constants.Count;
                cbuf->buffer_base = 0;
                r300_mark_atom_dirty(r300, &r300->pvs_flush);
            }
            r300_mark_atom_dirty(r300, &r300->vs_constants);
        } else if (r300->draw) {
            draw_set_mapped_constant_buffer(r300->draw, PIPE_SHADER_VERTEX,
                0, mapped, cb->buffer_size);
        }
    } else if (shader == PIPE_SHADER_FRAGMENT) {
        r300_mark_atom_dirty(r300, &r300->fs_constants);
    }
}

static void r300_texture_barrier(struct pipe_context *pipe)
{
    struct r300_context *r300 = r300_context(pipe);

    r300_mark_atom_dirty(r300, &r300->gpu_flush);
    r300_mark_atom_dirty(r300, &r300->texture_cache_inval);
}

static void r300_memory_barrier(struct pipe_context *pipe, unsigned flags)
{
}

void r300_init_state_functions(struct r300_context* r300)
{
    r300->context.create_blend_state = r300_create_blend_state;
    r300->context.bind_blend_state = r300_bind_blend_state;
    r300->context.delete_blend_state = r300_delete_blend_state;

    r300->context.set_blend_color = r300_set_blend_color;

    r300->context.set_clip_state = r300_set_clip_state;
    r300->context.set_sample_mask = r300_set_sample_mask;

    r300->context.set_constant_buffer = r300_set_constant_buffer;

    r300->context.create_depth_stencil_alpha_state = r300_create_dsa_state;
    r300->context.bind_depth_stencil_alpha_state = r300_bind_dsa_state;
    r300->context.delete_depth_stencil_alpha_state = r300_delete_dsa_state;

    r300->context.set_stencil_ref = r300_set_stencil_ref;

    r300->context.set_framebuffer_state = r300_set_framebuffer_state;

    r300->context.create_fs_state = r300_create_fs_state;
    r300->context.bind_fs_state = r300_bind_fs_state;
    r300->context.delete_fs_state = r300_delete_fs_state;

    r300->context.set_polygon_stipple = r300_set_polygon_stipple;

    r300->context.create_rasterizer_state = r300_create_rs_state;
    r300->context.bind_rasterizer_state = r300_bind_rs_state;
    r300->context.delete_rasterizer_state = r300_delete_rs_state;

    r300->context.create_sampler_state = r300_create_sampler_state;
    r300->context.bind_sampler_states = r300_bind_sampler_states;
    r300->context.delete_sampler_state = r300_delete_sampler_state;

    r300->context.set_sampler_views = r300_set_sampler_views;
    r300->context.create_sampler_view = r300_create_sampler_view;
    r300->context.sampler_view_destroy = r300_sampler_view_destroy;

    r300->context.set_scissor_states = r300_set_scissor_states;

    r300->context.set_viewport_states = r300_set_viewport_states;

    if (r300->screen->caps.has_tcl) {
        r300->context.set_vertex_buffers = r300_set_vertex_buffers_hwtcl;
        r300->context.set_index_buffer = r300_set_index_buffer_hwtcl;
    } else {
        r300->context.set_vertex_buffers = r300_set_vertex_buffers_swtcl;
        r300->context.set_index_buffer = r300_set_index_buffer_swtcl;
    }

    r300->context.create_vertex_elements_state = r300_create_vertex_elements_state;
    r300->context.bind_vertex_elements_state = r300_bind_vertex_elements_state;
    r300->context.delete_vertex_elements_state = r300_delete_vertex_elements_state;

    r300->context.create_vs_state = r300_create_vs_state;
    r300->context.bind_vs_state = r300_bind_vs_state;
    r300->context.delete_vs_state = r300_delete_vs_state;

    r300->context.texture_barrier = r300_texture_barrier;
    r300->context.memory_barrier = r300_memory_barrier;
}
@


1.8
log
@Make the Gallium r300 works on big-endian architectures.

Diff provided by Michel Daenzer [0] as a possible solution for a
regression introduced in Mesa 9 [1].  This diff allows macppc
users to use OpenGL accelerated appplications (i.e. GNOME3).

As disucssed during c2k15 we won't try to keep this patch during
the next Mesa update.

[0] https://bugs.freedesktop.org/show_bug.cgi?id=71789
[1] http://lists.freedesktop.org/archives/mesa-dev/2013-December/050218.html

Tested by myself and ajacoutot@@, regression test and ok jsg@@
@
text
@@


1.7
log
@Merge Mesa 10.2.9
@
text
@d228 6
d480 2
d493 2
a494 1
            boolean has_alpha = i != COLORMASK_RGBX && i != COLORMASK_BGRX;
d1679 1
d1695 1
a1695 1
        hwformat = r300_translate_texformat(templ->format,
d1702 1
a1702 1
                    util_format_short_name(templ->format), __func__);
d1707 1
a1707 1
					templ->format, 0,
d1712 1
a1712 1
            view->format.format2 |= r500_tx_format_msb_bit(templ->format);
@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d945 24
d1076 1
a1076 1
    r300->num_samples = util_framebuffer_get_num_samples(state);
a1416 1
    boolean last_clip_halfz = r300->clip_halfz;
a1427 1
        r300->clip_halfz = rs->rs.clip_halfz;
a1433 1
        r300->clip_halfz = FALSE;
a1453 4
    }

    if (r300->screen->caps.has_tcl && last_clip_halfz != r300->clip_halfz) {
        r300_mark_atom_dirty(r300, &r300->vs_state);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a944 24
static unsigned r300_get_num_samples(struct r300_context *r300)
{
    struct pipe_framebuffer_state* fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    unsigned i, num_samples;

    if (!fb->nr_cbufs && !fb->zsbuf)
        return 1;

    num_samples = 6;

    for (i = 0; i < fb->nr_cbufs; i++)
        if (fb->cbufs[i])
            num_samples = MIN2(num_samples, fb->cbufs[i]->texture->nr_samples);

    if (fb->zsbuf)
        num_samples = MIN2(num_samples, fb->zsbuf->texture->nr_samples);

    if (!num_samples)
        num_samples = 1;

    return num_samples;
}

d1052 1
a1052 1
    r300->num_samples = r300_get_num_samples(r300);
d1393 1
d1405 1
d1412 1
d1433 4
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d582 1
a582 1
    enum pipe_format format = fb->nr_cbufs ? fb->cbufs[0]->format : 0;
d588 1
d591 2
a592 2
    if (fb->nr_cbufs) {
        switch (format) {
d627 1
a627 1
        switch (format) {
d649 1
a649 1
        OUT_CB_REG(R300_RB3D_BLEND_COLOR, uc.ui);
d848 1
a848 1
                tex->tex.stride_in_bytes[0]);
d862 3
d957 2
a958 1
        num_samples = MIN2(num_samples, fb->cbufs[i]->texture->nr_samples);
d975 1
a975 1
    struct pipe_framebuffer_state *old_state = r300->fb_state.state;
d994 1
a994 1
    if (old_state->zsbuf && r300->zmask_in_use && !r300->locked_zbuffer) {
d997 1
a997 1
            if (!pipe_surface_equal(old_state->zsbuf, state->zsbuf)) {
d1004 1
a1004 1
            pipe_surface_reference(&r300->locked_zbuffer, old_state->zsbuf);
d1022 11
d1035 1
a1035 1
        state->nr_cbufs == 1 &&
a1043 5
    /* If zsbuf is set from NULL to non-NULL or vice versa.. */
    if (!!old_state->zsbuf != !!state->zsbuf) {
        r300_mark_atom_dirty(r300, &r300->dsa_state);
    }

a1050 2
    util_copy_framebuffer_state(r300->fb_state.state, state);

d1101 2
a1102 1
            r300_print_fb_surf_info(state->cbufs[i], i, "CB");
d1536 2
a1537 1
                                     unsigned count,
d1545 7
a1551 3
    if (count > tex_units) {
        return;
    }
a1558 6
static void r300_lacks_vertex_textures(struct pipe_context* pipe,
                                       unsigned count,
                                       void** states)
{
}

d1589 3
a1591 3
static void r300_set_fragment_sampler_views(struct pipe_context* pipe,
                                            unsigned count,
                                            struct pipe_sampler_view** views)
d1601 5
d2142 4
d2178 1
a2178 2
    r300->context.bind_fragment_sampler_states = r300_bind_sampler_states;
    r300->context.bind_vertex_sampler_states = r300_lacks_vertex_textures;
d2181 1
a2181 1
    r300->context.set_fragment_sampler_views = r300_set_fragment_sampler_views;
d2206 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d28 1
d173 55
a229 2
    /* Gallium uses RGBA color ordering while R300 expects BGRA. */

d235 101
d346 2
d350 2
a351 1
    uint32_t color_channel_mask = 0;  /* R300_RB3D_COLOR_CHANNEL_MASK: 0x4e0c */
d354 12
d370 22
a391 9
    if (state->rt[0].blend_enable)
    {
        unsigned eqRGB = state->rt[0].rgb_func;
        unsigned srcRGB = state->rt[0].rgb_src_factor;
        unsigned dstRGB = state->rt[0].rgb_dst_factor;

        unsigned eqA = state->rt[0].alpha_func;
        unsigned srcA = state->rt[0].alpha_src_factor;
        unsigned dstA = state->rt[0].alpha_dst_factor;
a398 4
        blend_control |=
            r300_translate_blend_function(eqRGB, TRUE);
        blend_control_noclamp |=
            r300_translate_blend_function(eqRGB, FALSE);
d400 22
a421 47
        /* Optimization: some operations do not require the destination color.
         *
         * When SRC_ALPHA_SATURATE is used, colorbuffer reads must be enabled,
         * otherwise blending gives incorrect results. It seems to be
         * a hardware bug. */
        if (eqRGB == PIPE_BLEND_MIN || eqA == PIPE_BLEND_MIN ||
            eqRGB == PIPE_BLEND_MAX || eqA == PIPE_BLEND_MAX ||
            dstRGB != PIPE_BLENDFACTOR_ZERO ||
            dstA != PIPE_BLENDFACTOR_ZERO ||
            srcRGB == PIPE_BLENDFACTOR_DST_COLOR ||
            srcRGB == PIPE_BLENDFACTOR_DST_ALPHA ||
            srcRGB == PIPE_BLENDFACTOR_INV_DST_COLOR ||
            srcRGB == PIPE_BLENDFACTOR_INV_DST_ALPHA ||
            srcA == PIPE_BLENDFACTOR_DST_COLOR ||
            srcA == PIPE_BLENDFACTOR_DST_ALPHA ||
            srcA == PIPE_BLENDFACTOR_INV_DST_COLOR ||
            srcA == PIPE_BLENDFACTOR_INV_DST_ALPHA ||
            srcRGB == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE) {
            /* Enable reading from the colorbuffer. */
            blend_control |= R300_READ_ENABLE;
            blend_control_noclamp |= R300_READ_ENABLE;

            if (r300screen->caps.is_r500) {
                /* Optimization: Depending on incoming pixels, we can
                 * conditionally disable the reading in hardware... */
                if (eqRGB != PIPE_BLEND_MIN && eqA != PIPE_BLEND_MIN &&
                    eqRGB != PIPE_BLEND_MAX && eqA != PIPE_BLEND_MAX) {
                    /* Disable reading if SRC_ALPHA == 0. */
                    if ((dstRGB == PIPE_BLENDFACTOR_SRC_ALPHA ||
                         dstRGB == PIPE_BLENDFACTOR_ZERO) &&
                        (dstA == PIPE_BLENDFACTOR_SRC_COLOR ||
                         dstA == PIPE_BLENDFACTOR_SRC_ALPHA ||
                         dstA == PIPE_BLENDFACTOR_ZERO)) {
                         blend_control |= R500_SRC_ALPHA_0_NO_READ;
                    }

                    /* Disable reading if SRC_ALPHA == 1. */
                    if ((dstRGB == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
                         dstRGB == PIPE_BLENDFACTOR_ZERO) &&
                        (dstA == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
                         dstA == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
                         dstA == PIPE_BLENDFACTOR_ZERO)) {
                         blend_control |= R500_SRC_ALPHA_1_NO_READ;
                    }
                }
            }
        }
d424 5
a428 43
         *
         * The code below is non-trivial and some math is involved.
         *
         * Discarding pixels must be disabled when FP16 AA is enabled.
         * This is a hardware bug. Also, this implementation wouldn't work
         * with FP blending enabled and equation clamping disabled.
         *
         * Equations other than ADD are rarely used and therefore won't be
         * optimized. */
        if ((eqRGB == PIPE_BLEND_ADD || eqRGB == PIPE_BLEND_REVERSE_SUBTRACT) &&
            (eqA == PIPE_BLEND_ADD || eqA == PIPE_BLEND_REVERSE_SUBTRACT)) {
            /* ADD: X+Y
             * REVERSE_SUBTRACT: Y-X
             *
             * The idea is:
             * If X = src*srcFactor = 0 and Y = dst*dstFactor = 1,
             * then CB will not be changed.
             *
             * Given the srcFactor and dstFactor variables, we can derive
             * what src and dst should be equal to and discard appropriate
             * pixels.
             */
            if (blend_discard_if_src_alpha_0(srcRGB, srcA, dstRGB, dstA)) {
                blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_0;
            } else if (blend_discard_if_src_alpha_1(srcRGB, srcA,
                                                    dstRGB, dstA)) {
                blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_1;
            } else if (blend_discard_if_src_color_0(srcRGB, srcA,
                                                    dstRGB, dstA)) {
                blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_0;
            } else if (blend_discard_if_src_color_1(srcRGB, srcA,
                                                    dstRGB, dstA)) {
                blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_1;
            } else if (blend_discard_if_src_alpha_color_0(srcRGB, srcA,
                                                          dstRGB, dstA)) {
                blend_control |=
                    R300_DISCARD_SRC_PIXELS_SRC_ALPHA_COLOR_0;
            } else if (blend_discard_if_src_alpha_color_1(srcRGB, srcA,
                                                          dstRGB, dstA)) {
                blend_control |=
                    R300_DISCARD_SRC_PIXELS_SRC_ALPHA_COLOR_1;
            }
        }
d434 1
d438 12
a449 4
            alpha_blend_control |=
                r300_translate_blend_function(eqA, TRUE);
            alpha_blend_control_noclamp |=
                r300_translate_blend_function(eqA, FALSE);
a458 14
    /* Color channel masks for all MRTs. */
    color_channel_mask = bgra_cmask(state->rt[0].colormask);
    if (r300screen->caps.is_r500 && state->independent_blend_enable) {
        if (state->rt[1].blend_enable) {
            color_channel_mask |= bgra_cmask(state->rt[1].colormask) << 4;
        }
        if (state->rt[2].blend_enable) {
            color_channel_mask |= bgra_cmask(state->rt[2].colormask) << 8;
        }
        if (state->rt[3].blend_enable) {
            color_channel_mask |= bgra_cmask(state->rt[3].colormask) << 12;
        }
    }

d472 28
a499 1
    BEGIN_CB(blend->cb_clamp, 8);
d502 3
a504 3
    OUT_CB(blend_control);
    OUT_CB(alpha_blend_control);
    OUT_CB(color_channel_mask);
d508 2
a509 2
    /* Build a command buffer. */
    BEGIN_CB(blend->cb_noclamp, 8);
d512 3
a514 3
    OUT_CB(blend_control_noclamp);
    OUT_CB(alpha_blend_control_noclamp);
    OUT_CB(color_channel_mask);
d536 3
d541 16
d583 1
d607 1
d611 7
d628 1
a662 2
    clip->clip = *state;

a663 2
        r300->clip_state.size = 2 + !!state->nr * 3 + state->nr * 4;

d665 1
a665 2
        if (state->nr) {
           OUT_CB_REG(R300_VAP_PVS_VECTOR_INDX_REG,
d668 2
a669 5
           OUT_CB_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, state->nr * 4);
           OUT_CB_TABLE(state->ucp, state->nr * 4);
        }
        OUT_CB_REG(R300_VAP_CLIP_CNTL, ((1 << state->nr) - 1) |
                   R300_PS_UCP_MODE_CLIP_AS_TRIFAN);
a677 7
static void
r300_set_sample_mask(struct pipe_context *pipe,
                     unsigned sample_mask)
{
}


d683 2
a684 3
static void*
        r300_create_dsa_state(struct pipe_context* pipe,
                              const struct pipe_depth_stencil_alpha_state* state)
d686 1
a686 1
    struct r300_capabilities *caps = &r300_screen(pipe->screen)->caps;
d689 5
d699 1
a699 1
        dsa->z_buffer_control |= R300_Z_WRITE_ENABLE;
d703 1
a703 1
        dsa->z_buffer_control |= R300_Z_ENABLE;
d705 1
a705 1
        dsa->z_stencil_control |=
a707 4
    } else {
        /* We must enable depth test, otherwise occlusion queries won't work. */
        dsa->z_buffer_control |= R300_Z_ENABLE;
        dsa->z_stencil_control |= R300_ZS_ALWAYS;
d712 2
a713 2
        dsa->z_buffer_control |= R300_STENCIL_ENABLE;
        dsa->z_stencil_control |=
d723 1
a723 1
        dsa->stencil_ref_mask =
d730 2
a731 2
            dsa->z_buffer_control |= R300_STENCIL_FRONT_BACK;
            dsa->z_stencil_control |=
d741 1
a741 1
            dsa->stencil_ref_bf =
d745 2
a746 2
            if (caps->is_r500) {
                dsa->z_buffer_control |= R500_STENCIL_REFMASK_FRONT_BACK;
d762 1
a762 7
        dsa->alpha_value = util_float_to_half(state->alpha.ref_value);

        if (caps->is_r500) {
            dsa->alpha_function_fp16 = dsa->alpha_function |
                                       R500_FG_ALPHA_FUNC_FP16_ENABLE;
            dsa->alpha_function |= R500_FG_ALPHA_FUNC_8BIT;
        }
d765 1
a765 2
    BEGIN_CB(&dsa->cb_begin, 10);
    OUT_CB_REG(R300_FG_ALPHA_FUNC, dsa->alpha_function);
d767 5
a771 5
    OUT_CB(dsa->z_buffer_control);
    OUT_CB(dsa->z_stencil_control);
    OUT_CB(dsa->stencil_ref_mask);
    OUT_CB_REG(R500_ZB_STENCILREFMASK_BF, dsa->stencil_ref_bf);
    OUT_CB_REG(R500_FG_ALPHA_VALUE, dsa->alpha_value);
d774 1
a774 2
    BEGIN_CB(&dsa->cb_begin_fp16, 10);
    OUT_CB_REG(R300_FG_ALPHA_FUNC, dsa->alpha_function_fp16);
a775 14
    OUT_CB(dsa->z_buffer_control);
    OUT_CB(dsa->z_stencil_control);
    OUT_CB(dsa->stencil_ref_mask);
    OUT_CB_REG(R500_ZB_STENCILREFMASK_BF, dsa->stencil_ref_bf);
    OUT_CB_REG(R500_FG_ALPHA_VALUE, dsa->alpha_value);
    END_CB;

    /* We must enable depth test, otherwise occlusion queries won't work.
     * We setup a dummy zbuffer to silent the CS checker, see emit_fb_state. */
    BEGIN_CB(dsa->cb_zb_no_readwrite, 10);
    OUT_CB_REG(R300_FG_ALPHA_FUNC, dsa->alpha_function);
    OUT_CB_REG_SEQ(R300_ZB_CNTL, 3);
    OUT_CB(R300_Z_ENABLE);
    OUT_CB(R300_ZS_ALWAYS);
d777 1
a777 9
    OUT_CB_REG(R500_ZB_STENCILREFMASK_BF, 0);
    OUT_CB_REG(R500_FG_ALPHA_VALUE, dsa->alpha_value);
    END_CB;

    BEGIN_CB(dsa->cb_fp16_zb_no_readwrite, 10);
    OUT_CB_REG(R300_FG_ALPHA_FUNC, dsa->alpha_function_fp16);
    OUT_CB_REG_SEQ(R300_ZB_CNTL, 3);
    OUT_CB(R300_Z_ENABLE);
    OUT_CB(R300_ZS_ALWAYS);
d780 1
a780 1
    OUT_CB_REG(R500_FG_ALPHA_VALUE, dsa->alpha_value);
d846 1
d882 1
a882 1
            "r300:     TEX: Macro: %s, Micro: %s, Pitch: %i, "
a890 1
            rtex->tex.stride_in_pixels[0],
d892 1
a892 1
            tex->last_level, util_format_short_name(tex->format));
d923 1
a923 1
    if (r300->cbzb_clear) {
d925 1
a925 1
    } else if (state->zsbuf) {
d929 7
a935 2
    } else if (state->nr_cbufs) {
        r300->fb_state.size += 10;
d941 23
d1017 5
d1025 3
d1033 6
a1038 2
    /* The tiling flags are dependent on the surface miplevel, unfortunately. */
    r300_fb_set_tiling_flags(r300, state);
d1049 1
a1049 1
        switch (util_format_get_blocksize(state->zsbuf->texture->format)) {
d1067 2
d1070 2
a1071 4
    if (state->nr_cbufs && state->cbufs[0]->texture->nr_samples > 1) {
        aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE;

        switch (state->cbufs[0]->texture->nr_samples) {
d1073 2
a1074 4
            aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_2;
            break;
        case 3:
            aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_3;
d1077 2
a1078 1
            aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_4;
d1081 2
a1082 1
            aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_6;
a1186 1
    float psiz;
d1188 1
d1205 1
a1205 1
    boolean vclamp = state->clamp_vertex_color;
d1217 4
d1242 3
a1244 2
        psiz = pipe->screen->get_paramf(pipe->screen,
                                        PIPE_CAP_MAX_POINT_WIDTH);
d1246 2
a1247 1
            pack_float_16_6x(psiz) << R300_GA_POINT_MINMAX_MAX_SHIFT;
d1251 1
a1251 1
        psiz = state->point_size;
d1334 7
d1350 1
d1357 1
a1357 1
    rs->cull_mode_index = 9;
d1405 2
a1406 1
    boolean last_frag_clamp = r300->frag_clamp;
d1416 2
a1417 1
        r300->frag_clamp = rs->rs.clamp_fragment_color;
d1422 2
a1423 1
        r300->frag_clamp = FALSE;
d1430 2
a1431 1
        last_two_sided_color != r300->two_sided_color) {
d1435 9
a1443 3
    if (last_frag_clamp != r300->frag_clamp &&
        r300->fs_status == FRAGMENT_SHADER_VALID) {
        r300->fs_status = FRAGMENT_SHADER_MAYBE_DIRTY;
d1643 2
a1644 2
static struct pipe_sampler_view *
r300_create_sampler_view(struct pipe_context *pipe,
d1646 3
a1648 1
                         const struct pipe_sampler_view *templ)
d1664 2
d1682 4
a1685 1
        view->format = tex->tx_format;
d1695 11
d1714 14
a1727 2
static void r300_set_scissor_state(struct pipe_context* pipe,
                                   const struct pipe_scissor_state* state)
d1737 4
a1740 2
static void r300_set_viewport_state(struct pipe_context* pipe,
                                    const struct pipe_viewport_state* state)
d1749 1
a1749 1
        draw_set_viewport_state(r300->draw, state);
d1789 2
a1790 2
static void r300_set_vertex_buffers(struct pipe_context* pipe,
                                    unsigned count,
d1794 4
a1797 2
    unsigned i;
    struct pipe_vertex_buffer dummy_vb = {0};
d1800 4
a1803 4
    if (!count) {
        dummy_vb.buffer = r300->dummy_vb;
        buffers = &dummy_vb;
        count = 1;
d1806 2
a1807 1
    u_vbuf_set_vertex_buffers(r300->vbuf_mgr, count, buffers);
d1809 22
a1830 6
    if (r300->screen->caps.has_tcl) {
        /* HW TCL. */
        for (i = 0; i < count; i++) {
            if (buffers[i].buffer &&
		!r300_resource(buffers[i].buffer)->b.user_ptr) {
            }
a1831 4
        r300->vertex_arrays_dirty = TRUE;
    } else {
        /* SW TCL. */
        draw_set_vertex_buffers(r300->draw, count, buffers);
d1835 2
a1836 2
static void r300_set_index_buffer(struct pipe_context* pipe,
                                  const struct pipe_index_buffer *ib)
d1840 1
a1840 3
    if (ib && ib->buffer) {
        assert(ib->offset % ib->index_size == 0);

d1842 2
a1843 4
        memcpy(&r300->index_buffer, ib, sizeof(r300->index_buffer));
        r300->index_buffer.offset /= r300->index_buffer.index_size;
    }
    else {
a1844 1
        memset(&r300->index_buffer, 0, sizeof(r300->index_buffer));
d1846 6
d1853 10
a1862 2
    if (!r300->screen->caps.has_tcl) {
        draw_set_index_buffer(r300->draw, ib);
a1913 1
    struct r300_context *r300 = r300_context(pipe);
d1934 1
a1934 3
    velems->vmgr_elements =
        u_vbuf_create_vertex_elements(r300->vbuf_mgr, count, attribs,
                                          velems->velem);
a1962 2
    u_vbuf_bind_vertex_elements(r300->vbuf_mgr, state, velems->vmgr_elements);

a1974 4
    struct r300_context *r300 = r300_context(pipe);
    struct r300_vertex_element_state *velems = state;

    u_vbuf_destroy_vertex_elements(r300->vbuf_mgr, velems->vmgr_elements);
d1989 1
a1989 1
        r300_init_vs_outputs(vs);
d1992 1
a1992 1
        r300_draw_init_vertex_shader(r300->draw, vs);
d2018 2
a2019 3
        r300->vs_state.size =
                vs->code.length + 9 +
        (vs->code.num_fc_ops ? vs->code.num_fc_ops * fc_op_dwords + 4 : 0);
d2044 1
a2044 2
        if (vs->code.constants_remap_table)
            FREE(vs->code.constants_remap_table);
d2056 1
a2056 1
                                     struct pipe_resource *buf)
a2059 1
    struct r300_resource *rbuf = r300_resource(buf);
d2062 3
a2075 2
    if (buf == NULL || buf->width0 == 0)
        return;
d2077 10
a2086 6
    if (rbuf->b.user_ptr)
        mapped = (uint32_t*)rbuf->b.user_ptr;
    else if (rbuf->constant_buffer)
        mapped = (uint32_t*)rbuf->constant_buffer;
    else
        return;
d2113 1
a2113 1
                0, mapped, buf->width0);
d2168 1
a2168 1
    r300->context.set_scissor_state = r300_set_scissor_state;
d2170 1
a2170 1
    r300->context.set_viewport_state = r300_set_viewport_state;
d2172 7
a2178 3
    r300->context.set_vertex_buffers = r300_set_vertex_buffers;
    r300->context.set_index_buffer = r300_set_index_buffer;
    r300->context.redefine_user_buffer = u_default_redefine_user_buffer;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d27 1
d32 1
a47 2
#include "r300_winsys.h"
#include "r300_hyperz.h"
d190 1
d192 1
d198 2
d212 2
a213 2
        blend_control = R300_ALPHA_BLEND_ENABLE |
            r300_translate_blend_function(eqRGB) |
d216 4
d241 1
d317 2
a318 2
            alpha_blend_control =
                r300_translate_blend_function(eqA) |
d321 4
d361 1
a361 1
    BEGIN_CB(blend->cb, 8);
d370 10
d421 2
a422 1
    struct r300_blend_color_state* state =
d424 2
d428 28
a456 1
        /* XXX if FP16 blending is enabled, we should use the FP16 format */
d459 16
a474 4
        OUT_CB(float_to_fixed10(color->color[0]) |
               (float_to_fixed10(color->color[3]) << 16));
        OUT_CB(float_to_fixed10(color->color[2]) |
               (float_to_fixed10(color->color[1]) << 16));
d478 1
a478 1
        util_pack_color(color->color, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
d510 1
a510 2
                R300_PS_UCP_MODE_CLIP_AS_TRIFAN |
                (state->depth_clamp ? R300_CLIP_DISABLE : 0));
a608 1
        /* We could use 10bit alpha ref but who needs that? */
d610 1
d612 3
a614 1
        if (caps->is_r500)
d616 1
d619 1
a619 1
    BEGIN_CB(&dsa->cb_begin, 8);
d626 11
d641 1
a641 1
    BEGIN_CB(dsa->cb_no_readwrite, 8);
d648 11
d715 2
a716 1
                                      struct r300_texture *tex, unsigned level)
d720 5
a724 11
    if (tex->desc.macrotile[tex->surface_level] !=
        tex->desc.macrotile[level]) {
        /* Tiling determines how DRM treats the buffer data.
         * We must flush CS when changing it if the buffer is referenced. */
        if (r300->rws->cs_is_buffer_referenced(r300->cs,
                                               tex->cs_buffer, R300_REF_CS))
            r300->context.flush(&r300->context, 0, NULL);

        r300->rws->buffer_set_tiling(r300->rws, tex->buffer,
                tex->desc.microtile, tex->desc.macrotile[level],
                tex->desc.stride_in_bytes[0]);
d739 1
a739 1
                                  r300_texture(state->cbufs[i]->texture),
d744 1
a744 1
                                  r300_texture(state->zsbuf->texture),
d753 1
a753 1
    struct r300_texture *rtex = r300_texture(tex);
d766 3
a768 3
            rtex->desc.macrotile[0] ? "YES" : " NO",
            rtex->desc.microtile ? "YES" : " NO",
            rtex->desc.stride_in_pixels[0],
a776 1
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
a777 1
    /* What is marked as dirty depends on the enum r300_fb_state_change. */
a779 1
    r300_mark_atom_dirty(r300, &r300->hyperz_state);
d781 1
d784 11
d805 2
a806 2
        if (can_hyperz)
            r300->fb_state.size += r300->screen->caps.hiz_ram ? 8 : 4;
d815 2
a816 2
    r300_set_framebuffer_state(struct pipe_context* pipe,
                               const struct pipe_framebuffer_state* state)
a820 1
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
d823 1
a823 1
    int blocksize;
d839 25
a863 3
    /* If nr_cbufs is changed from zero to non-zero or vice versa... */
    if (!!old_state->nr_cbufs != !!state->nr_cbufs) {
        r300_mark_atom_dirty(r300, &r300->blend_state);
d865 5
d880 4
a884 1
    r300->validate_buffers = TRUE;
a885 2
    r300->z_compression = false;
    
d887 1
a887 2
        blocksize = util_format_get_blocksize(state->zsbuf->texture->format);
        switch (blocksize) {
a894 25
        if (can_hyperz) {
            struct r300_surface *zs_surf = r300_surface(state->zsbuf);
            struct r300_texture *tex;
            int compress = r300->screen->caps.is_rv350 ? RV350_Z_COMPRESS_88 : R300_Z_COMPRESS_44;
            int level = zs_surf->base.u.tex.level;

            tex = r300_texture(zs_surf->base.texture);

            /* work out whether we can support hiz on this buffer */
            r300_hiz_alloc_block(r300, zs_surf);
        
            /* work out whether we can support zmask features on this buffer */
            r300_zmask_alloc_block(r300, zs_surf, compress);

            if (tex->zmask_mem[level]) {
                /* compression causes hangs on 16-bit */
                if (zbuffer_bpp == 24)
                    r300->z_compression = compress;
            }
            DBG(r300, DBG_HYPERZ,
                "hyper-z features: hiz: %d @@ %08x z-compression: %d z-fastfill: %d @@ %08x\n", tex->hiz_mem[level] ? 1 : 0,
                tex->hiz_mem[level] ? tex->hiz_mem[level]->ofs : 0xdeadbeef,
                r300->z_compression, tex->zmask_mem[level] ? 1 : 0,
                tex->zmask_mem[level] ? tex->zmask_mem[level]->ofs : 0xdeadbeef);
        }
d906 16
a921 20
    if (r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0)) {
        if (state->nr_cbufs && state->cbufs[0]->texture->nr_samples > 1) {
            aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE;

            switch (state->cbufs[0]->texture->nr_samples) {
                case 2:
                    aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_2;
                    break;
                case 3:
                    aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_3;
                    break;
                case 4:
                    aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_4;
                    break;
                case 6:
                    aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_6;
                    break;
            }
        } else {
            aa->aa_config = 0;
d923 2
d986 1
a986 2
    r300_pick_fragment_shader(r300);
    r300_mark_fs_code_dirty(r300);
d1036 1
d1043 1
d1166 6
d1186 1
d1229 1
d1239 1
d1244 1
d1254 5
d1310 1
a1310 1
                                                   state->max_anisotropy > 0);
d1401 1
a1401 1
    struct r300_texture *texture;
d1430 2
a1431 2
        texture = r300_texture(views[i]->texture);
        if (texture->desc.is_npot) {
a1450 1
    r300->validate_buffers = TRUE;
d1463 1
a1463 1
    struct r300_texture *tex = r300_texture(texture);
d1468 2
d1481 11
d1493 1
a1493 4
        view->format.format1 |= r300_translate_texformat(templ->format,
                                                         view->swizzle,
                                                         is_r500,
                                                         dxtc_swizzle);
d1565 2
a1566 1
    if (r300->fs.state && r300_fs(r300)->shader->inputs.wpos != ATTR_UNUSED) {
d1576 1
a1576 3
    struct pipe_vertex_buffer *vbo;
    unsigned i, max_index = (1 << 24) - 1;
    boolean any_user_buffer = FALSE;
a1581 1
        dummy_vb.max_index = r300->dummy_vb->width0 / 4;
d1586 1
a1586 5
    if (count == r300->vertex_buffer_count &&
        memcmp(r300->vertex_buffer, buffers,
            sizeof(struct pipe_vertex_buffer) * count) == 0) {
        return;
    }
a1589 3
        r300->incompatible_vb_layout = FALSE;

        /* Check if the strides and offsets are aligned to the size of DWORD. */
d1591 2
a1592 6
            if (buffers[i].buffer) {
                if (buffers[i].stride % 4 != 0 ||
                    buffers[i].buffer_offset % 4 != 0) {
                    r300->incompatible_vb_layout = TRUE;
                    break;
                }
d1595 1
a1595 31

        for (i = 0; i < count; i++) {
            /* Why, yes, I AM casting away constness. How did you know? */
            vbo = (struct pipe_vertex_buffer*)&buffers[i];

            /* Skip NULL buffers */
            if (!buffers[i].buffer) {
                continue;
            }

            if (r300_buffer_is_user_buffer(vbo->buffer)) {
                any_user_buffer = TRUE;
            }

            /* The stride of zero means we will be fetching only the first
             * vertex, so don't care about max_index. */
            if (!vbo->stride)
                continue;

            if (vbo->max_index == ~0) {
                vbo->max_index =
                        (vbo->buffer->width0 - vbo->buffer_offset) / vbo->stride;
            }

            max_index = MIN2(vbo->max_index, max_index);
        }

        r300->any_user_vbs = any_user_buffer;
        r300->vertex_buffer_max_index = max_index;
        r300->aos_dirty = TRUE;
        r300->validate_buffers = TRUE;
a1599 14

    /* Common code. */
    for (i = 0; i < count; i++) {
        /* Reference our buffer. */
        pipe_resource_reference(&r300->vertex_buffer[i].buffer, buffers[i].buffer);
    }
    for (; i < r300->vertex_buffer_count; i++) {
        /* Dereference any old buffers. */
        pipe_resource_reference(&r300->vertex_buffer[i].buffer, NULL);
    }

    memcpy(r300->vertex_buffer, buffers,
        sizeof(struct pipe_vertex_buffer) * count);
    r300->vertex_buffer_count = count;
d1607 3
a1609 1
    if (ib) {
d1612 1
d1619 1
a1619 4
    if (r300->screen->caps.has_tcl) {
        r300->validate_buffers = TRUE;
    }
    else {
a1631 6
    if (velems->count > 16) {
        fprintf(stderr, "r300: More than 16 vertex elements are not supported,"
                " requested %i, using 16.\n", velems->count);
        velems->count = 16;
    }

d1636 1
a1636 1
        format = velems->hw_format[i];
a1667 3
#define FORMAT_REPLACE(what, withwhat) \
    case PIPE_FORMAT_##what: *format = PIPE_FORMAT_##withwhat; break

d1672 1
a1674 1
    enum pipe_format *format;
d1682 4
a1687 1
    assert(count <= PIPE_MAX_ATTRIBS);
d1689 2
a1690 44
    if (velems != NULL) {
        velems->count = count;
        memcpy(velems->velem, attribs, sizeof(struct pipe_vertex_element) * count);

        if (r300_screen(pipe->screen)->caps.has_tcl) {
            /* Set the best hw format in case the original format is not
             * supported by hw. */
            for (i = 0; i < count; i++) {
                velems->hw_format[i] = velems->velem[i].src_format;
                format = &velems->hw_format[i];

                /* This is basically the list of unsupported formats.
                 * For now we don't care about the alignment, that's going to
                 * be sorted out after the PSC setup. */
                switch (*format) {
                    FORMAT_REPLACE(R64_FLOAT,           R32_FLOAT);
                    FORMAT_REPLACE(R64G64_FLOAT,        R32G32_FLOAT);
                    FORMAT_REPLACE(R64G64B64_FLOAT,     R32G32B32_FLOAT);
                    FORMAT_REPLACE(R64G64B64A64_FLOAT,  R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_UNORM,           R32_FLOAT);
                    FORMAT_REPLACE(R32G32_UNORM,        R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_UNORM,     R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_UNORM,  R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_USCALED,         R32_FLOAT);
                    FORMAT_REPLACE(R32G32_USCALED,      R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_USCALED,   R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_USCALED,R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_SNORM,           R32_FLOAT);
                    FORMAT_REPLACE(R32G32_SNORM,        R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_SNORM,     R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_SNORM,  R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_SSCALED,         R32_FLOAT);
                    FORMAT_REPLACE(R32G32_SSCALED,      R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_SSCALED,   R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_SSCALED,R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_FIXED,           R32_FLOAT);
                    FORMAT_REPLACE(R32G32_FIXED,        R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_FIXED,     R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_FIXED,  R32G32B32A32_FLOAT);
d1692 9
a1700 2
                    default:;
                }
d1702 4
a1705 21
                velems->incompatible_layout =
                        velems->incompatible_layout ||
                        velems->velem[i].src_format != velems->hw_format[i] ||
                        velems->velem[i].src_offset % 4 != 0;
            }

            /* Now setup PSC.
             * The unused components will be replaced by (..., 0, 1). */
            r300_vertex_psc(velems);

            /* Align the formats to the size of DWORD.
             * We only care about the blocksizes of the formats since
             * swizzles are already set up.
             * Also compute the vertex size. */
            for (i = 0; i < count; i++) {
                /* This is OK because we check for aligned strides too
                 * elsewhere. */
                velems->hw_format_size[i] =
                    align(util_format_get_blocksize(velems->hw_format[i]), 4);
                velems->vertex_size_dwords += velems->hw_format_size[i] / 4;
            }
d1708 1
d1724 2
d1733 1
a1733 1
    r300->aos_dirty = TRUE;
d1738 5
a1742 1
   FREE(state);
d1829 1
d1843 8
a1850 2
    if (buf == NULL || buf->width0 == 0 ||
        (mapped = (uint32_t*)r300_buffer(buf)->constant_buffer) == NULL) {
a1851 1
    }
a1854 1
        assert((buf->width0 % (4 * sizeof(float))) == 0);
d1885 8
d1939 1
d1948 2
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d26 1
d28 1
d36 1
d38 1
d41 1
d44 1
d46 2
a47 2

#include "radeon_winsys.h"
d55 1
a55 1
        atom.dirty = TRUE;   \
d189 6
d208 1
a208 1
        blend->blend_control = R300_ALPHA_BLEND_ENABLE |
d232 1
a232 1
            blend->blend_control |= R300_READ_ENABLE;
d234 1
a234 1
            if (r300_screen(r300_context(pipe)->context.screen)->caps->is_r500) {
d245 1
a245 1
                         blend->blend_control |= R500_SRC_ALPHA_0_NO_READ;
d254 1
a254 1
                         blend->blend_control |= R500_SRC_ALPHA_1_NO_READ;
d284 1
a284 1
                blend->blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_0;
d287 1
a287 1
                blend->blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_1;
d290 1
a290 1
                blend->blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_0;
d293 1
a293 1
                blend->blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_1;
d296 1
a296 1
                blend->blend_control |=
d300 1
a300 1
                blend->blend_control |=
d307 2
a308 2
            blend->blend_control |= R300_SEPARATE_ALPHA_ENABLE;
            blend->alpha_blend_control =
d317 1
a317 1
        blend->rop = R300_RB3D_ROPCNTL_ROP_ENABLE |
d322 2
a323 2
    blend->color_channel_mask = bgra_cmask(state->rt[0].colormask);
    if (r300screen->caps->is_r500 && state->independent_blend_enable) {
d325 1
a325 1
            blend->color_channel_mask |= bgra_cmask(state->rt[1].colormask) << 4;
d328 1
a328 1
            blend->color_channel_mask |= bgra_cmask(state->rt[2].colormask) << 8;
d331 1
a331 1
            blend->color_channel_mask |= bgra_cmask(state->rt[3].colormask) << 12;
d335 6
d342 2
a343 2
        blend->dither = R300_RB3D_DITHER_CTL_DITHER_MODE_LUT |
                R300_RB3D_DITHER_CTL_ALPHA_DITHER_MODE_LUT;
d345 21
a397 1
    struct r300_screen* r300screen = r300_screen(pipe->screen);
d400 1
a400 1
    union util_color uc;
d402 12
a413 2
    util_pack_color(color->color, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
    state->blend_color = uc.ui;
d415 4
a418 7
    /* XXX if FP16 blending is enabled, we should use the FP16 format */
    state->blend_color_red_alpha =
        float_to_fixed10(color->color[0]) |
        (float_to_fixed10(color->color[3]) << 16);
    state->blend_color_green_blue =
        float_to_fixed10(color->color[2]) |
        (float_to_fixed10(color->color[1]) << 16);
d420 1
a420 2
    r300->blend_color_state.size = r300screen->caps->is_r500 ? 3 : 2;
    r300->blend_color_state.dirty = TRUE;
d427 21
d449 1
a449 5
    r300->clip = *state;

    if (r300_screen(pipe->screen)->caps->has_tcl) {
        memcpy(r300->clip_state.state, state, sizeof(struct pipe_clip_state));
        r300->clip_state.size = 29;
a450 1
        draw_flush(r300->draw);
a451 1
        r300->clip_state.size = 2;
d453 1
d455 4
a458 1
    r300->clip_state.dirty = TRUE;
d461 1
d471 1
a471 2
    struct r300_capabilities *caps =
        r300_screen(r300_context(pipe)->context.screen)->caps;
d473 8
a481 1
    /* Depth test setup. */
a484 4
        if (state->depth.writemask) {
            dsa->z_buffer_control |= R300_Z_WRITE_ENABLE;
        }

d488 4
d512 2
d525 5
a529 2
            if (caps->is_r500)
            {
d531 4
a534 5
                dsa->stencil_ref_bf =
                    (state->stencil[1].valuemask <<
                    R300_STENCILMASK_SHIFT) |
                    (state->stencil[1].writemask <<
                    R300_STENCILWRITEMASK_SHIFT);
d552 20
d575 16
d597 4
d602 3
d618 1
d620 24
a643 1
    r300->dsa_state.dirty = TRUE;
d647 47
a693 18
static void r300_fb_update_tiling_flags(struct r300_context *r300,
                               const struct pipe_framebuffer_state *old_state,
                               const struct pipe_framebuffer_state *new_state)
{
    struct r300_texture *tex;
    unsigned i, j, level;

    /* Reset tiling flags for old surfaces to default values. */
    for (i = 0; i < old_state->nr_cbufs; i++) {
        for (j = 0; j < new_state->nr_cbufs; j++) {
            if (old_state->cbufs[i]->texture == new_state->cbufs[j]->texture) {
                break;
            }
        }
        /* If not binding the surface again... */
        if (j != new_state->nr_cbufs) {
            continue;
        }
d695 4
a698 1
        tex = (struct r300_texture*)old_state->cbufs[i]->texture;
d700 3
a702 18
        if (tex) {
            r300->winsys->buffer_set_tiling(r300->winsys, tex->buffer,
                                            tex->pitch[0],
                                            tex->microtile != 0,
                                            tex->macrotile != 0);
        }
    }
    if (old_state->zsbuf &&
        (!new_state->zsbuf ||
         old_state->zsbuf->texture != new_state->zsbuf->texture)) {
        tex = (struct r300_texture*)old_state->zsbuf->texture;

        if (tex) {
            r300->winsys->buffer_set_tiling(r300->winsys, tex->buffer,
                                            tex->pitch[0],
                                            tex->microtile != 0,
                                            tex->macrotile != 0);
        }
d705 11
a715 18
    /* Set tiling flags for new surfaces. */
    for (i = 0; i < new_state->nr_cbufs; i++) {
        tex = (struct r300_texture*)new_state->cbufs[i]->texture;
        level = new_state->cbufs[i]->level;

        r300->winsys->buffer_set_tiling(r300->winsys, tex->buffer,
                                        tex->pitch[level],
                                        tex->microtile != 0,
                                        tex->mip_macrotile[level] != 0);
    }
    if (new_state->zsbuf) {
        tex = (struct r300_texture*)new_state->zsbuf->texture;
        level = new_state->zsbuf->level;

        r300->winsys->buffer_set_tiling(r300->winsys, tex->buffer,
                                        tex->pitch[level],
                                        tex->microtile != 0,
                                        tex->mip_macrotile[level] != 0);
d717 2
d726 4
a729 2
    struct r300_screen* r300screen = r300_screen(pipe->screen);
    unsigned max_width, max_height;
d731 1
d733 1
a733 8

    if (state->nr_cbufs > 4) {
        debug_printf("r300: Implementation error: Too many MRTs in %s, "
            "refusing to bind framebuffer state!\n", __FUNCTION__);
        return;
    }

    if (r300screen->caps->is_r500) {
d735 1
a735 1
    } else if (r300screen->caps->is_r400) {
d742 1
a742 1
        debug_printf("r300: Implementation error: Render targets are too "
d747 54
d802 7
a808 2
    if (r300->draw) {
        draw_flush(r300->draw);
d811 23
a833 6
    memcpy(r300->fb_state.state, state, sizeof(struct pipe_framebuffer_state));

    r300->fb_state.size = (10 * state->nr_cbufs) + (2 * (4 - state->nr_cbufs)) +
                          (state->zsbuf ? 10 : 0) + 8;

    r300_fb_update_tiling_flags(r300, r300->fb_state.state, state);
d835 4
a838 15
    /* XXX wait what */
    r300->blend_state.dirty = TRUE;
    r300->dsa_state.dirty = TRUE;
    r300->fb_state.dirty = TRUE;
    r300->scissor_state.dirty = TRUE;

    /* Polygon offset depends on the zbuffer bit depth. */
    if (state->zsbuf && r300->polygon_offset_enabled) {
        switch (util_format_get_blocksize(state->zsbuf->texture->format)) {
            case 2:
                zbuffer_bpp = 16;
                break;
            case 4:
                zbuffer_bpp = 24;
                break;
d840 2
a841 4

        if (r300->zbuffer_bpp != zbuffer_bpp) {
            r300->zbuffer_bpp = zbuffer_bpp;
            r300->rs_state.dirty = TRUE;
d858 19
a876 2
    tgsi_scan_shader(shader->tokens, &fs->info);
    r300_shader_read_fs_inputs(&fs->info, &fs->inputs);
d878 2
a879 1
    return (void*)fs;
d889 1
a889 1
        r300->fs = NULL;
d893 1
a893 1
    r300->fs = fs;
d895 1
d897 1
a897 7
    r300->rs_block_state.dirty = TRUE; /* Will be updated before the emission. */

    if (r300->vs_state.state && r300_vertex_shader_setup_wpos(r300)) {
        r300->vap_output_state.dirty = TRUE;
    }

    r300->dirty_state |= R300_NEW_FRAGMENT_SHADER | R300_NEW_FRAGMENT_SHADER_CONSTANTS;
d910 1
a932 1
    struct r300_screen* r300screen = r300_screen(pipe->screen);
d934 18
d953 1
a953 1
    /* Copy rasterizer state for Draw. */
d955 7
d964 1
a964 1
    rs->vap_control_status = R300_VC_NO_SWAP;
d966 1
a966 1
    rs->vap_control_status = R300_VC_32BIT_SWAP;
d969 3
a971 4
    /* If bypassing TCL, or if no TCL engine is present, turn off the HW TCL.
     * Else, enable HW TCL and force Draw's TCL off. */
    if (!r300screen->caps->has_tcl) {
        rs->vap_control_status |= R300_VAP_TCL_BYPASS;
d974 3
a976 1
    rs->point_size = pack_float_16_6x(state->point_size) |
d979 19
a997 1
    rs->line_control = pack_float_16_6x(state->line_width) |
d1001 4
a1004 3
    if (state->fill_cw != PIPE_POLYGON_MODE_FILL ||
        state->fill_ccw != PIPE_POLYGON_MODE_FILL) {
        rs->polygon_mode = R300_GA_POLY_MODE_DUAL;
d1007 5
a1011 3
    /* Radeons don't think in "CW/CCW", they think in "front/back". */
    if (state->front_winding == PIPE_WINDING_CW) {
        rs->cull_mode = R300_FRONT_FACE_CW;
d1013 8
a1020 7
        /* Polygon offset */
        if (state->offset_cw) {
            rs->polygon_offset_enable |= R300_FRONT_ENABLE;
        }
        if (state->offset_ccw) {
            rs->polygon_offset_enable |= R300_BACK_ENABLE;
        }
d1022 1
a1022 9
        /* Polygon mode */
        if (rs->polygon_mode) {
            rs->polygon_mode |=
                r300_translate_polygon_mode_front(state->fill_cw);
            rs->polygon_mode |=
                r300_translate_polygon_mode_back(state->fill_ccw);
        }
    } else {
        rs->cull_mode = R300_FRONT_FACE_CCW;
d1024 7
a1030 7
        /* Polygon offset */
        if (state->offset_ccw) {
            rs->polygon_offset_enable |= R300_FRONT_ENABLE;
        }
        if (state->offset_cw) {
            rs->polygon_offset_enable |= R300_BACK_ENABLE;
        }
d1032 2
a1033 10
        /* Polygon mode */
        if (rs->polygon_mode) {
            rs->polygon_mode |=
                r300_translate_polygon_mode_front(state->fill_ccw);
            rs->polygon_mode |=
                r300_translate_polygon_mode_back(state->fill_cw);
        }
    }
    if (state->front_winding & state->cull_mode) {
        rs->cull_mode |= R300_CULL_FRONT;
d1035 2
a1036 7
    if (~(state->front_winding) & state->cull_mode) {
        rs->cull_mode |= R300_CULL_BACK;
    }

    if (rs->polygon_offset_enable) {
        rs->depth_offset = state->offset_units;
        rs->depth_scale = state->offset_scale;
d1040 1
a1040 1
        rs->line_stipple_config =
d1045 4
a1048 1
        rs->line_stipple_value = state->line_stipple_pattern;
d1057 62
d1127 2
d1130 2
a1131 3
    if (r300->draw) {
        draw_flush(r300->draw);
        draw_set_rasterizer_state(r300->draw, &rs->rs, state);
d1135 3
a1137 1
        r300->polygon_offset_enabled = rs->rs.offset_cw || rs->rs.offset_ccw;
d1140 2
d1145 1
a1145 1
    r300->rs_state.size = 17 + (r300->polygon_offset_enabled ? 5 : 0);
d1147 3
a1149 7
    /* XXX Why is this still needed, dammit!? */
    r300->scissor_state.dirty = TRUE;
    r300->viewport_state.dirty = TRUE;

    /* XXX Clean these up when we move to atom emits */
    if (r300->fs && r300->fs->inputs.wpos != ATTR_UNUSED) {
        r300->dirty_state |= R300_NEW_FRAGMENT_SHADER_CONSTANTS;
d1165 1
a1166 1
    union util_color uc;
d1170 24
d1195 3
a1197 3
        (r300_translate_wrap(state->wrap_s) << R300_TX_WRAP_S_SHIFT) |
        (r300_translate_wrap(state->wrap_t) << R300_TX_WRAP_T_SHIFT) |
        (r300_translate_wrap(state->wrap_r) << R300_TX_WRAP_R_SHIFT);
d1204 2
d1208 2
a1209 2
    sampler->min_lod = MAX2((unsigned)state->min_lod, 0);
    sampler->max_lod = MAX2((unsigned)ceilf(state->max_lod), 0);
d1211 1
a1211 1
    lod_bias = CLAMP((int)(state->lod_bias * 32), -(1 << 9), (1 << 9) - 1);
d1213 1
a1213 1
    sampler->filter1 |= lod_bias << R300_LOD_BIAS_SHIFT;
d1215 7
a1221 4
    sampler->filter1 |= r300_anisotropy(state->max_anisotropy);

    util_pack_color(state->border_color, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
    sampler->border_color = uc.ui;
d1224 1
a1224 1
    if (r300_screen(r300->context.screen)->caps->is_r500) {
d1238 1
d1240 1
a1240 1
    if (count > 8) {
d1245 1
a1245 1
    state->sampler_count = count;
d1247 1
a1247 9
    r300->textures_state.dirty = TRUE;

    /* Pick a fragment shader based on the texture compare state. */
    if (r300->fs && count) {
        if (r300_pick_fragment_shader(r300)) {
            r300->dirty_state |= R300_NEW_FRAGMENT_SHADER |
                                 R300_NEW_FRAGMENT_SHADER_CONSTANTS;
        }
    }
d1261 28
a1288 3
static void r300_set_sampler_textures(struct pipe_context* pipe,
                                      unsigned count,
                                      struct pipe_texture** texture)
d1293 3
a1295 2
    unsigned i;
    boolean is_r500 = r300_screen(r300->context.screen)->caps->is_r500;
d1298 1
a1298 2
    /* XXX magic num */
    if (count > 8) {
d1302 1
d1304 21
a1324 11
        if (state->textures[i] != (struct r300_texture*)texture[i]) {
            pipe_texture_reference((struct pipe_texture**)&state->textures[i],
                                   texture[i]);
            dirty_tex = TRUE;

            /* R300-specific - set the texrect factor in the fragment shader */
            if (!is_r500 && state->textures[i]->is_npot) {
                /* XXX It would be nice to re-emit just 1 constant,
                 * XXX not all of them */
                r300->dirty_state |= R300_NEW_FRAGMENT_SHADER_CONSTANTS;
            }
d1326 4
d1332 5
a1336 4
    for (i = count; i < 8; i++) {
        if (state->textures[i]) {
            pipe_texture_reference((struct pipe_texture**)&state->textures[i],
                NULL);
d1340 1
a1340 1
    state->texture_count = count;
d1342 2
a1343 1
    r300->textures_state.dirty = TRUE;
d1346 34
a1379 1
        r300->texture_cache_inval.dirty = TRUE;
d1381 10
d1401 1
a1401 1
    r300->scissor_state.dirty = TRUE;
d1413 6
d1447 3
a1449 3
    r300->viewport_state.dirty = TRUE;
    if (r300->fs && r300->fs->inputs.wpos != ATTR_UNUSED) {
        r300->dirty_state |= R300_NEW_FRAGMENT_SHADER_CONSTANTS;
d1458 78
a1535 1
    unsigned i, max_index = ~0;
d1539 16
d1556 5
a1560 2
    for (i = 0; i < count; i++) {
        max_index = MIN2(buffers[i].max_index, max_index);
d1562 29
d1592 11
a1602 2
    r300->vertex_buffer_count = count;
    r300->vertex_buffer_max_index = max_index;
d1604 3
a1606 5
    if (r300->draw) {
        draw_flush(r300->draw);
        draw_set_vertex_buffers(r300->draw, count, buffers);
    } else {
        r300->vertex_stream_state.dirty = TRUE;
d1608 4
d1614 6
a1619 1
static boolean r300_validate_aos(struct r300_context *r300)
d1621 67
a1687 3
    struct pipe_vertex_buffer *vbuf = r300->vertex_buffer;
    struct pipe_vertex_element *velem = r300->vertex_element;
    int i;
d1689 15
a1703 5
    /* Check if formats and strides are aligned to the size of DWORD. */
    for (i = 0; i < r300->vertex_element_count; i++) {
        if (vbuf[velem[i].vertex_buffer_index].stride % 4 != 0 ||
            util_format_get_blocksize(velem[i].src_format) % 4 != 0) {
            return FALSE;
d1706 1
a1706 1
    return TRUE;
d1709 2
a1710 3
static void r300_set_vertex_elements(struct pipe_context* pipe,
                                    unsigned count,
                                    const struct pipe_vertex_element* elements)
d1712 6
a1717 1
    struct r300_context* r300 = r300_context(pipe);
d1719 1
a1719 4
    memcpy(r300->vertex_element,
           elements,
           sizeof(struct pipe_vertex_element) * count);
    r300->vertex_element_count = count;
d1722 2
a1723 2
        draw_flush(r300->draw);
        draw_set_vertex_elements(r300->draw, count, elements);
d1726 8
a1733 5
    if (!r300_validate_aos(r300)) {
        /* XXX We should fallback using draw. */
        assert(0);
        abort();
    }
d1740 1
d1742 3
a1744 7
    if (r300_screen(pipe->screen)->caps->has_tcl) {
        struct r300_vertex_shader* vs = CALLOC_STRUCT(r300_vertex_shader);
        /* Copy state directly into shader. */
        vs->state = *shader;
        vs->state.tokens = tgsi_dup_tokens(shader->tokens);

        tgsi_scan_shader(shader->tokens, &vs->info);
d1746 3
a1748 1
        return (void*)vs;
d1750 1
a1750 1
        return draw_create_vertex_shader(r300->draw, shader);
d1752 2
d1759 1
d1761 8
a1768 9
    if (r300_screen(pipe->screen)->caps->has_tcl) {
        struct r300_vertex_shader* vs = (struct r300_vertex_shader*)shader;

        if (vs == NULL) {
            r300->vs_state.state = NULL;
            return;
        } else if (!vs->translated) {
            r300_translate_vertex_shader(r300, vs);
        }
d1770 2
a1771 2
        UPDATE_STATE(shader, r300->vs_state);
        r300->vs_state.size = vs->code.length + 9;
d1773 12
a1784 4
        r300->rs_block_state.dirty = TRUE; /* Will be updated before the emission. */
        r300->vap_output_state.dirty = TRUE;
        r300->vertex_stream_state.dirty = TRUE; /* XXX needed for TCL bypass */
        r300->pvs_flush.dirty = TRUE;
d1786 2
a1787 3
        if (r300->fs) {
            r300_vertex_shader_setup_wpos(r300);
        }
d1789 1
a1789 1
        r300->dirty_state |= R300_NEW_VERTEX_SHADER_CONSTANTS;
a1790 1
        draw_flush(r300->draw);
d1792 1
a1792 1
                (struct draw_vertex_shader*)shader);
d1799 1
d1801 1
a1801 3
    if (r300_screen(pipe->screen)->caps->has_tcl) {
        struct r300_vertex_shader* vs = (struct r300_vertex_shader*)shader;

d1803 2
a1804 2
        FREE((void*)vs->state.tokens);
        FREE(shader);
d1807 1
a1807 1
                (struct draw_vertex_shader*)shader);
d1809 3
d1816 1
a1816 1
                                     struct pipe_buffer *buf)
d1819 2
a1820 3
    struct r300_screen *r300screen = r300_screen(pipe->screen);
    void *mapped;
    int max_size = 0;
a1821 10
    if (buf == NULL || buf->size == 0 ||
        (mapped = pipe_buffer_map(pipe->screen, buf, PIPE_BUFFER_USAGE_CPU_READ)) == NULL)
    {
        r300->shader_constants[shader].count = 0;
        return;
    }

    assert((buf->size % 4 * sizeof(float)) == 0);

    /* Check the size of the constant buffer. */
d1824 1
a1824 1
            max_size = 256;
d1827 1
a1827 8
            if (r300screen->caps->is_r500) {
                max_size = 256;
            /* XXX Implement emission of r400's extended constant buffer. */
            /*} else if (r300screen->caps->is_r400) {
                max_size = 64;*/
            } else {
                max_size = 32;
            }
d1830 1
a1830 1
            assert(0);
d1833 3
a1835 5
    /* XXX Subtract immediates and RC_STATE_* variables. */
    if (buf->size > (sizeof(float) * 4 * max_size)) {
        debug_printf("r300: Max size of the constant buffer is "
                      "%i*4 floats.\n", max_size);
        abort();
d1838 5
a1842 3
    memcpy(r300->shader_constants[shader].constants, mapped, buf->size);
    r300->shader_constants[shader].count = buf->size / (4 * sizeof(float));
    pipe_buffer_unmap(pipe->screen, buf);
d1845 23
a1867 2
        r300->dirty_state |= R300_NEW_VERTEX_SHADER_CONSTANTS;
        r300->pvs_flush.dirty = TRUE;
a1868 2
    else if (shader == PIPE_SHADER_FRAGMENT)
        r300->dirty_state |= R300_NEW_FRAGMENT_SHADER_CONSTANTS;
d1880 1
d1907 3
a1909 1
    r300->context.set_fragment_sampler_textures = r300_set_sampler_textures;
d1916 5
a1920 1
    r300->context.set_vertex_elements = r300_set_vertex_elements;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a25 1
#include "util/u_framebuffer.h"
a26 1
#include "util/u_mm.h"
a33 1
#include "r300_cb.h"
a34 1
#include "r300_emit.h"
a36 1
#include "r300_screen_buffer.h"
a38 1
#include "r300_texture.h"
d40 2
a41 2
#include "r300_winsys.h"
#include "r300_hyperz.h"
d49 1
a49 1
        r300_mark_atom_dirty(r300, &(atom));   \
a182 6
    uint32_t blend_control = 0;       /* R300_RB3D_CBLEND: 0x4e04 */
    uint32_t alpha_blend_control = 0; /* R300_RB3D_ABLEND: 0x4e08 */
    uint32_t color_channel_mask = 0;  /* R300_RB3D_COLOR_CHANNEL_MASK: 0x4e0c */
    uint32_t rop = 0;                 /* R300_RB3D_ROPCNTL: 0x4e18 */
    uint32_t dither = 0;              /* R300_RB3D_DITHER_CTL: 0x4e50 */
    CB_LOCALS;
d196 1
a196 1
        blend_control = R300_ALPHA_BLEND_ENABLE |
d220 1
a220 1
            blend_control |= R300_READ_ENABLE;
d222 1
a222 1
            if (r300screen->caps.is_r500) {
d233 1
a233 1
                         blend_control |= R500_SRC_ALPHA_0_NO_READ;
d242 1
a242 1
                         blend_control |= R500_SRC_ALPHA_1_NO_READ;
d272 1
a272 1
                blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_0;
d275 1
a275 1
                blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_1;
d278 1
a278 1
                blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_0;
d281 1
a281 1
                blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_1;
d284 1
a284 1
                blend_control |=
d288 1
a288 1
                blend_control |=
d295 2
a296 2
            blend_control |= R300_SEPARATE_ALPHA_ENABLE;
            alpha_blend_control =
d305 1
a305 1
        rop = R300_RB3D_ROPCNTL_ROP_ENABLE |
d310 2
a311 2
    color_channel_mask = bgra_cmask(state->rt[0].colormask);
    if (r300screen->caps.is_r500 && state->independent_blend_enable) {
d313 1
a313 1
            color_channel_mask |= bgra_cmask(state->rt[1].colormask) << 4;
d316 1
a316 1
            color_channel_mask |= bgra_cmask(state->rt[2].colormask) << 8;
d319 1
a319 1
            color_channel_mask |= bgra_cmask(state->rt[3].colormask) << 12;
a322 6
    /* Neither fglrx nor classic r300 ever set this, regardless of dithering
     * state. Since it's an optional implementation detail, we can leave it
     * out and never dither.
     *
     * This could be revisited if we ever get quality or conformance hints.
     *
d324 2
a325 2
        dither = R300_RB3D_DITHER_CTL_DITHER_MODE_LUT |
                        R300_RB3D_DITHER_CTL_ALPHA_DITHER_MODE_LUT;
a326 21
    */

    /* Build a command buffer. */
    BEGIN_CB(blend->cb, 8);
    OUT_CB_REG(R300_RB3D_ROPCNTL, rop);
    OUT_CB_REG_SEQ(R300_RB3D_CBLEND, 3);
    OUT_CB(blend_control);
    OUT_CB(alpha_blend_control);
    OUT_CB(color_channel_mask);
    OUT_CB_REG(R300_RB3D_DITHER_CTL, dither);
    END_CB;

    /* The same as above, but with no colorbuffer reads and writes. */
    BEGIN_CB(blend->cb_no_readwrite, 8);
    OUT_CB_REG(R300_RB3D_ROPCNTL, rop);
    OUT_CB_REG_SEQ(R300_RB3D_CBLEND, 3);
    OUT_CB(0);
    OUT_CB(0);
    OUT_CB(0);
    OUT_CB_REG(R300_RB3D_DITHER_CTL, dither);
    END_CB;
d359 1
d362 1
a362 1
    CB_LOCALS;
d364 2
a365 12
    if (r300->screen->caps.is_r500) {
        /* XXX if FP16 blending is enabled, we should use the FP16 format */
        BEGIN_CB(state->cb, 3);
        OUT_CB_REG_SEQ(R500_RB3D_CONSTANT_COLOR_AR, 2);
        OUT_CB(float_to_fixed10(color->color[0]) |
               (float_to_fixed10(color->color[3]) << 16));
        OUT_CB(float_to_fixed10(color->color[2]) |
               (float_to_fixed10(color->color[1]) << 16));
        END_CB;
    } else {
        union util_color uc;
        util_pack_color(color->color, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
d367 7
a373 4
        BEGIN_CB(state->cb, 2);
        OUT_CB_REG(R300_RB3D_BLEND_COLOR, uc.ui);
        END_CB;
    }
d375 2
a376 1
    r300_mark_atom_dirty(r300, &r300->blend_color_state);
a382 21
    struct r300_clip_state *clip =
            (struct r300_clip_state*)r300->clip_state.state;
    CB_LOCALS;

    clip->clip = *state;

    if (r300->screen->caps.has_tcl) {
        r300->clip_state.size = 2 + !!state->nr * 3 + state->nr * 4;

        BEGIN_CB(clip->cb, r300->clip_state.size);
        if (state->nr) {
           OUT_CB_REG(R300_VAP_PVS_VECTOR_INDX_REG,
                   (r300->screen->caps.is_r500 ?
                    R500_PVS_UCP_START : R300_PVS_UCP_START));
           OUT_CB_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, state->nr * 4);
           OUT_CB_TABLE(state->ucp, state->nr * 4);
        }
        OUT_CB_REG(R300_VAP_CLIP_CNTL, ((1 << state->nr) - 1) |
                R300_PS_UCP_MODE_CLIP_AS_TRIFAN |
                (state->depth_clamp ? R300_CLIP_DISABLE : 0));
        END_CB;
d384 5
a388 1
        r300_mark_atom_dirty(r300, &r300->clip_state);
d390 1
d392 1
a393 1
}
d395 1
a395 4
static void
r300_set_sample_mask(struct pipe_context *pipe,
                     unsigned sample_mask)
{
a397 1

d407 2
a408 1
    struct r300_capabilities *caps = &r300_screen(pipe->screen)->caps;
a409 8
    CB_LOCALS;

    dsa->dsa = *state;

    /* Depth test setup. - separate write mask depth for decomp flush */
    if (state->depth.writemask) {
        dsa->z_buffer_control |= R300_Z_WRITE_ENABLE;
    }
d411 1
d415 4
a421 4
    } else {
        /* We must enable depth test, otherwise occlusion queries won't work. */
        dsa->z_buffer_control |= R300_Z_ENABLE;
        dsa->z_stencil_control |= R300_ZS_ALWAYS;
a441 2
            dsa->two_sided = TRUE;

d453 2
a454 5
            dsa->stencil_ref_bf =
                (state->stencil[1].valuemask << R300_STENCILMASK_SHIFT) |
                (state->stencil[1].writemask << R300_STENCILWRITEMASK_SHIFT);

            if (caps->is_r500) {
d456 5
a460 4
            } else {
                dsa->two_sided_stencil_ref =
                  (state->stencil[0].valuemask != state->stencil[1].valuemask ||
                   state->stencil[0].writemask != state->stencil[1].writemask);
a477 20
    BEGIN_CB(&dsa->cb_begin, 8);
    OUT_CB_REG(R300_FG_ALPHA_FUNC, dsa->alpha_function);
    OUT_CB_REG_SEQ(R300_ZB_CNTL, 3);
    OUT_CB(dsa->z_buffer_control);
    OUT_CB(dsa->z_stencil_control);
    OUT_CB(dsa->stencil_ref_mask);
    OUT_CB_REG(R500_ZB_STENCILREFMASK_BF, dsa->stencil_ref_bf);
    END_CB;

    /* We must enable depth test, otherwise occlusion queries won't work.
     * We setup a dummy zbuffer to silent the CS checker, see emit_fb_state. */
    BEGIN_CB(dsa->cb_no_readwrite, 8);
    OUT_CB_REG(R300_FG_ALPHA_FUNC, dsa->alpha_function);
    OUT_CB_REG_SEQ(R300_ZB_CNTL, 3);
    OUT_CB(R300_Z_ENABLE);
    OUT_CB(R300_ZS_ALWAYS);
    OUT_CB(0);
    OUT_CB_REG(R500_ZB_STENCILREFMASK_BF, 0);
    END_CB;

a480 16
static void r300_dsa_inject_stencilref(struct r300_context *r300)
{
    struct r300_dsa_state *dsa =
            (struct r300_dsa_state*)r300->dsa_state.state;

    if (!dsa)
        return;

    dsa->stencil_ref_mask =
        (dsa->stencil_ref_mask & ~R300_STENCILREF_MASK) |
        r300->stencil_ref.ref_value[0];
    dsa->stencil_ref_bf =
        (dsa->stencil_ref_bf & ~R300_STENCILREF_MASK) |
        r300->stencil_ref.ref_value[1];
}

a486 4
    if (!state) {
        return;
    }

a487 3

    r300_mark_atom_dirty(r300, &r300->hyperz_state); /* Will be updated before the emission. */
    r300_dsa_inject_stencilref(r300);
a500 1

d502 1
a502 24

    r300_dsa_inject_stencilref(r300);
    r300_mark_atom_dirty(r300, &r300->dsa_state);
}

static void r300_tex_set_tiling_flags(struct r300_context *r300,
                                      struct r300_texture *tex, unsigned level)
{
    /* Check if the macrotile flag needs to be changed.
     * Skip changing the flags otherwise. */
    if (tex->desc.macrotile[tex->surface_level] !=
        tex->desc.macrotile[level]) {
        /* Tiling determines how DRM treats the buffer data.
         * We must flush CS when changing it if the buffer is referenced. */
        if (r300->rws->cs_is_buffer_referenced(r300->cs,
                                               tex->cs_buffer, R300_REF_CS))
            r300->context.flush(&r300->context, 0, NULL);

        r300->rws->buffer_set_tiling(r300->rws, tex->buffer,
                tex->desc.microtile, tex->desc.macrotile[level],
                tex->desc.stride_in_bytes[0]);

        tex->surface_level = level;
    }
d506 18
a523 4
static void r300_fb_set_tiling_flags(struct r300_context *r300,
                               const struct pipe_framebuffer_state *state)
{
    unsigned i;
d525 1
a525 12
    /* Set tiling flags for new surfaces. */
    for (i = 0; i < state->nr_cbufs; i++) {
        r300_tex_set_tiling_flags(r300,
                                  r300_texture(state->cbufs[i]->texture),
                                  state->cbufs[i]->u.tex.level);
    }
    if (state->zsbuf) {
        r300_tex_set_tiling_flags(r300,
                                  r300_texture(state->zsbuf->texture),
                                  state->zsbuf->u.tex.level);
    }
}
d527 18
a544 38
static void r300_print_fb_surf_info(struct pipe_surface *surf, unsigned index,
                                    const char *binding)
{
    struct pipe_resource *tex = surf->texture;
    struct r300_texture *rtex = r300_texture(tex);

    fprintf(stderr,
            "r300:   %s[%i] Dim: %ix%i, Firstlayer: %i, "
            "Lastlayer: %i, Level: %i, Format: %s\n"

            "r300:     TEX: Macro: %s, Micro: %s, Pitch: %i, "
            "Dim: %ix%ix%i, LastLevel: %i, Format: %s\n",

            binding, index, surf->width, surf->height,
            surf->u.tex.first_layer, surf->u.tex.last_layer, surf->u.tex.level,
            util_format_short_name(surf->format),

            rtex->desc.macrotile[0] ? "YES" : " NO",
            rtex->desc.microtile ? "YES" : " NO",
            rtex->desc.stride_in_pixels[0],
            tex->width0, tex->height0, tex->depth0,
            tex->last_level, util_format_short_name(tex->format));
}

void r300_mark_fb_state_dirty(struct r300_context *r300,
                              enum r300_fb_state_change change)
{
    struct pipe_framebuffer_state *state = r300->fb_state.state;
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);

    /* What is marked as dirty depends on the enum r300_fb_state_change. */
    r300_mark_atom_dirty(r300, &r300->gpu_flush);
    r300_mark_atom_dirty(r300, &r300->fb_state);
    r300_mark_atom_dirty(r300, &r300->hyperz_state);

    if (change == R300_CHANGED_FB_STATE) {
        r300_mark_atom_dirty(r300, &r300->aa_state);
        r300_mark_atom_dirty(r300, &r300->fb_state_pipelined);
d547 18
a564 11
    /* Now compute the fb_state atom size. */
    r300->fb_state.size = 2 + (8 * state->nr_cbufs);

    if (r300->cbzb_clear) {
        r300->fb_state.size += 10;
    } else if (state->zsbuf) {
        r300->fb_state.size += 10;
        if (can_hyperz)
            r300->fb_state.size += r300->screen->caps.hiz_ram ? 8 : 4;
    } else if (state->nr_cbufs) {
        r300->fb_state.size += 10;
a565 2

    /* The size of the rest of atoms stays the same. */
d573 2
a574 4
    struct r300_aa_state *aa = (struct r300_aa_state*)r300->aa_state.state;
    struct pipe_framebuffer_state *old_state = r300->fb_state.state;
    boolean can_hyperz = r300->rws->get_value(r300->rws, R300_CAN_HYPERZ);
    unsigned max_width, max_height, i;
a575 1
    int blocksize;
d577 8
a584 1
    if (r300->screen->caps.is_r500) {
d586 1
a586 1
    } else if (r300->screen->caps.is_r400) {
d593 1
a593 1
        fprintf(stderr, "r300: Implementation error: Render targets are too "
a597 54
    /* If nr_cbufs is changed from zero to non-zero or vice versa... */
    if (!!old_state->nr_cbufs != !!state->nr_cbufs) {
        r300_mark_atom_dirty(r300, &r300->blend_state);
    }
    /* If zsbuf is set from NULL to non-NULL or vice versa.. */
    if (!!old_state->zsbuf != !!state->zsbuf) {
        r300_mark_atom_dirty(r300, &r300->dsa_state);
    }

    /* The tiling flags are dependent on the surface miplevel, unfortunately. */
    r300_fb_set_tiling_flags(r300, state);

    util_copy_framebuffer_state(r300->fb_state.state, state);

    r300_mark_fb_state_dirty(r300, R300_CHANGED_FB_STATE);
    r300->validate_buffers = TRUE;

    r300->z_compression = false;
    
    if (state->zsbuf) {
        blocksize = util_format_get_blocksize(state->zsbuf->texture->format);
        switch (blocksize) {
        case 2:
            zbuffer_bpp = 16;
            break;
        case 4:
            zbuffer_bpp = 24;
            break;
        }
        if (can_hyperz) {
            struct r300_surface *zs_surf = r300_surface(state->zsbuf);
            struct r300_texture *tex;
            int compress = r300->screen->caps.is_rv350 ? RV350_Z_COMPRESS_88 : R300_Z_COMPRESS_44;
            int level = zs_surf->base.u.tex.level;

            tex = r300_texture(zs_surf->base.texture);

            /* work out whether we can support hiz on this buffer */
            r300_hiz_alloc_block(r300, zs_surf);
        
            /* work out whether we can support zmask features on this buffer */
            r300_zmask_alloc_block(r300, zs_surf, compress);

            if (tex->zmask_mem[level]) {
                /* compression causes hangs on 16-bit */
                if (zbuffer_bpp == 24)
                    r300->z_compression = compress;
            }
            DBG(r300, DBG_HYPERZ,
                "hyper-z features: hiz: %d @@ %08x z-compression: %d z-fastfill: %d @@ %08x\n", tex->hiz_mem[level] ? 1 : 0,
                tex->hiz_mem[level] ? tex->hiz_mem[level]->ofs : 0xdeadbeef,
                r300->z_compression, tex->zmask_mem[level] ? 1 : 0,
                tex->zmask_mem[level] ? tex->zmask_mem[level]->ofs : 0xdeadbeef);
        }
d599 10
a608 3
        /* Polygon offset depends on the zbuffer bit depth. */
        if (r300->zbuffer_bpp != zbuffer_bpp) {
            r300->zbuffer_bpp = zbuffer_bpp;
d610 5
a614 4
            if (r300->polygon_offset_enabled)
                r300_mark_atom_dirty(r300, &r300->rs_state);
        }
    }
d616 9
a624 21
    /* Set up AA config. */
    if (r300->rws->get_value(r300->rws, R300_VID_DRM_2_3_0)) {
        if (state->nr_cbufs && state->cbufs[0]->texture->nr_samples > 1) {
            aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE;

            switch (state->cbufs[0]->texture->nr_samples) {
                case 2:
                    aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_2;
                    break;
                case 3:
                    aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_3;
                    break;
                case 4:
                    aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_4;
                    break;
                case 6:
                    aa->aa_config |= R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_6;
                    break;
            }
        } else {
            aa->aa_config = 0;
a625 1
    }
d627 3
a629 7
    if (DBG_ON(r300, DBG_FB)) {
        fprintf(stderr, "r300: set_framebuffer_state:\n");
        for (i = 0; i < state->nr_cbufs; i++) {
            r300_print_fb_surf_info(state->cbufs[i], i, "CB");
        }
        if (state->zsbuf) {
            r300_print_fb_surf_info(state->zsbuf, 0, "ZB");
d646 3
a651 21
void r300_mark_fs_code_dirty(struct r300_context *r300)
{
    struct r300_fragment_shader* fs = r300_fs(r300);

    r300_mark_atom_dirty(r300, &r300->fs);
    r300_mark_atom_dirty(r300, &r300->fs_rc_constant_state);
    r300_mark_atom_dirty(r300, &r300->fs_constants);
    r300->fs.size = fs->shader->cb_code_size;

    if (r300->screen->caps.is_r500) {
        r300->fs_rc_constant_state.size = fs->shader->rc_state_count * 7;
        r300->fs_constants.size = fs->shader->externals_count * 4 + 3;
    } else {
        r300->fs_rc_constant_state.size = fs->shader->rc_state_count * 5;
        r300->fs_constants.size = fs->shader->externals_count * 4 + 1;
    }

    ((struct r300_constant_buffer*)r300->fs_constants.state)->remap_table =
            fs->shader->code.constants_remap_table;
}

d659 1
a659 1
        r300->fs.state = NULL;
d663 1
a663 1
    r300->fs.state = fs;
a664 1
    r300_mark_fs_code_dirty(r300);
d666 7
a672 1
    r300_mark_atom_dirty(r300, &r300->rs_block_state); /* Will be updated before the emission. */
a684 1
        FREE(tmp->cb_code);
d707 1
a708 18
    float psiz;
    uint32_t vap_control_status;    /* R300_VAP_CNTL_STATUS: 0x2140 */
    uint32_t point_size;            /* R300_GA_POINT_SIZE: 0x421c */
    uint32_t point_minmax;          /* R300_GA_POINT_MINMAX: 0x4230 */
    uint32_t line_control;          /* R300_GA_LINE_CNTL: 0x4234 */
    uint32_t polygon_offset_enable; /* R300_SU_POLY_OFFSET_ENABLE: 0x42b4 */
    uint32_t cull_mode;             /* R300_SU_CULL_MODE: 0x42b8 */
    uint32_t line_stipple_config;   /* R300_GA_LINE_STIPPLE_CONFIG: 0x4328 */
    uint32_t line_stipple_value;    /* R300_GA_LINE_STIPPLE_VALUE: 0x4260 */
    uint32_t polygon_mode;          /* R300_GA_POLY_MODE: 0x4288 */
    uint32_t clip_rule;             /* R300_SC_CLIP_RULE: 0x43D0 */

    /* Point sprites texture coordinates, 0: lower left, 1: upper right */
    float point_texcoord_left = 0;  /* R300_GA_POINT_S0: 0x4200 */
    float point_texcoord_bottom = 0;/* R300_GA_POINT_T0: 0x4204 */
    float point_texcoord_right = 1; /* R300_GA_POINT_S1: 0x4208 */
    float point_texcoord_top = 0;   /* R300_GA_POINT_T1: 0x420c */
    CB_LOCALS;
d710 1
a710 1
    /* Copy rasterizer state. */
a711 7
    rs->rs_draw = *state;

    rs->rs.sprite_coord_enable = state->point_quad_rasterization *
                                 state->sprite_coord_enable;

    /* Override some states for Draw. */
    rs->rs_draw.sprite_coord_enable = 0; /* We can do this in HW. */
d714 1
a714 1
    vap_control_status = R300_VC_NO_SWAP;
d716 1
a716 1
    vap_control_status = R300_VC_32BIT_SWAP;
d719 4
a722 3
    /* If no TCL engine is present, turn off the HW TCL. */
    if (!r300_screen(pipe->screen)->caps.has_tcl) {
        vap_control_status |= R300_VAP_TCL_BYPASS;
d725 1
a725 3
    /* Point size width and height. */
    point_size =
        pack_float_16_6x(state->point_size) |
d728 1
a728 19
    /* Point size clamping. */
    if (state->point_size_per_vertex) {
        /* Per-vertex point size.
         * Clamp to [0, max FB size] */
        psiz = pipe->screen->get_paramf(pipe->screen,
                                        PIPE_CAP_MAX_POINT_WIDTH);
        point_minmax =
            pack_float_16_6x(psiz) << R300_GA_POINT_MINMAX_MAX_SHIFT;
    } else {
        /* We cannot disable the point-size vertex output,
         * so clamp it. */
        psiz = state->point_size;
        point_minmax =
            (pack_float_16_6x(psiz) << R300_GA_POINT_MINMAX_MIN_SHIFT) |
            (pack_float_16_6x(psiz) << R300_GA_POINT_MINMAX_MAX_SHIFT);
    }

    /* Line control. */
    line_control = pack_float_16_6x(state->line_width) |
d732 3
a734 4
    polygon_mode = 0;
    if (state->fill_front != PIPE_POLYGON_MODE_FILL ||
        state->fill_back != PIPE_POLYGON_MODE_FILL) {
        polygon_mode = R300_GA_POLY_MODE_DUAL;
d737 29
a765 5
    /* Front face */
    if (state->front_ccw) 
        cull_mode = R300_FRONT_FACE_CCW;
    else
        cull_mode = R300_FRONT_FACE_CW;
d767 7
a773 4
    /* Polygon offset */
    polygon_offset_enable = 0;
    if (util_get_offset(state, state->fill_front)) {
       polygon_offset_enable |= R300_FRONT_ENABLE;
d775 2
a776 2
    if (util_get_offset(state, state->fill_back)) {
       polygon_offset_enable |= R300_BACK_ENABLE;
d778 2
a779 9

    rs->polygon_offset_enable = polygon_offset_enable != 0;

    /* Polygon mode */
    if (polygon_mode) {
       polygon_mode |=
          r300_translate_polygon_mode_front(state->fill_front);
       polygon_mode |=
          r300_translate_polygon_mode_back(state->fill_back);
d782 3
a784 5
    if (state->cull_face & PIPE_FACE_FRONT) {
        cull_mode |= R300_CULL_FRONT;
    }
    if (state->cull_face & PIPE_FACE_BACK) {
        cull_mode |= R300_CULL_BACK;
d788 1
a788 1
        line_stipple_config =
d793 1
a793 4
        line_stipple_value = state->line_stipple_pattern;
    } else {
        line_stipple_config = 0;
        line_stipple_value = 0;
a801 62
    clip_rule = state->scissor ? 0xAAAA : 0xFFFF;

    /* Point sprites coord mode */
    if (rs->rs.sprite_coord_enable) {
        switch (state->sprite_coord_mode) {
            case PIPE_SPRITE_COORD_UPPER_LEFT:
                point_texcoord_top = 0.0f;
                point_texcoord_bottom = 1.0f;
                break;
            case PIPE_SPRITE_COORD_LOWER_LEFT:
                point_texcoord_top = 1.0f;
                point_texcoord_bottom = 0.0f;
                break;
        }
    }

    /* Build the main command buffer. */
    BEGIN_CB(rs->cb_main, RS_STATE_MAIN_SIZE);
    OUT_CB_REG(R300_VAP_CNTL_STATUS, vap_control_status);
    OUT_CB_REG(R300_GA_POINT_SIZE, point_size);
    OUT_CB_REG_SEQ(R300_GA_POINT_MINMAX, 2);
    OUT_CB(point_minmax);
    OUT_CB(line_control);
    OUT_CB_REG_SEQ(R300_SU_POLY_OFFSET_ENABLE, 2);
    OUT_CB(polygon_offset_enable);
    rs->cull_mode_index = 9;
    OUT_CB(cull_mode);
    OUT_CB_REG(R300_GA_LINE_STIPPLE_CONFIG, line_stipple_config);
    OUT_CB_REG(R300_GA_LINE_STIPPLE_VALUE, line_stipple_value);
    OUT_CB_REG(R300_GA_POLY_MODE, polygon_mode);
    OUT_CB_REG(R300_SC_CLIP_RULE, clip_rule);
    OUT_CB_REG_SEQ(R300_GA_POINT_S0, 4);
    OUT_CB_32F(point_texcoord_left);
    OUT_CB_32F(point_texcoord_bottom);
    OUT_CB_32F(point_texcoord_right);
    OUT_CB_32F(point_texcoord_top);
    END_CB;

    /* Build the two command buffers for polygon offset setup. */
    if (polygon_offset_enable) {
        float scale = state->offset_scale * 12;
        float offset = state->offset_units * 4;

        BEGIN_CB(rs->cb_poly_offset_zb16, 5);
        OUT_CB_REG_SEQ(R300_SU_POLY_OFFSET_FRONT_SCALE, 4);
        OUT_CB_32F(scale);
        OUT_CB_32F(offset);
        OUT_CB_32F(scale);
        OUT_CB_32F(offset);
        END_CB;

        offset = state->offset_units * 2;

        BEGIN_CB(rs->cb_poly_offset_zb24, 5);
        OUT_CB_REG_SEQ(R300_SU_POLY_OFFSET_FRONT_SCALE, 4);
        OUT_CB_32F(scale);
        OUT_CB_32F(offset);
        OUT_CB_32F(scale);
        OUT_CB_32F(offset);
        END_CB;
    }

a809 2
    int last_sprite_coord_enable = r300->sprite_coord_enable;
    boolean last_two_sided_color = r300->two_sided_color;
d811 3
a813 2
    if (r300->draw && rs) {
        draw_set_rasterizer_state(r300->draw, &rs->rs_draw, state);
d817 1
a817 3
        r300->polygon_offset_enabled = rs->polygon_offset_enable;
        r300->sprite_coord_enable = rs->rs.sprite_coord_enable;
        r300->two_sided_color = rs->rs.light_twoside;
a819 2
        r300->sprite_coord_enable = 0;
        r300->two_sided_color = FALSE;
d823 1
a823 1
    r300->rs_state.size = RS_STATE_MAIN_SIZE + (r300->polygon_offset_enabled ? 5 : 0);
d825 7
a831 3
    if (last_sprite_coord_enable != r300->sprite_coord_enable ||
        last_two_sided_color != r300->two_sided_color) {
        r300_mark_atom_dirty(r300, &r300->rs_block_state);
a846 1
    boolean is_r500 = r300->screen->caps.is_r500;
d848 1
a851 24
    /* r300 doesn't handle CLAMP and MIRROR_CLAMP correctly when either MAG
     * or MIN filter is NEAREST. Since texwrap produces same results
     * for CLAMP and CLAMP_TO_EDGE, we use them instead. */
    if (sampler->state.min_img_filter == PIPE_TEX_FILTER_NEAREST ||
        sampler->state.mag_img_filter == PIPE_TEX_FILTER_NEAREST) {
        /* Wrap S. */
        if (sampler->state.wrap_s == PIPE_TEX_WRAP_CLAMP)
            sampler->state.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
        else if (sampler->state.wrap_s == PIPE_TEX_WRAP_MIRROR_CLAMP)
            sampler->state.wrap_s = PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE;

        /* Wrap T. */
        if (sampler->state.wrap_t == PIPE_TEX_WRAP_CLAMP)
            sampler->state.wrap_t = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
        else if (sampler->state.wrap_t == PIPE_TEX_WRAP_MIRROR_CLAMP)
            sampler->state.wrap_t = PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE;

        /* Wrap R. */
        if (sampler->state.wrap_r == PIPE_TEX_WRAP_CLAMP)
            sampler->state.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
        else if (sampler->state.wrap_r == PIPE_TEX_WRAP_MIRROR_CLAMP)
            sampler->state.wrap_r = PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE;
    }

d853 3
a855 3
        (r300_translate_wrap(sampler->state.wrap_s) << R300_TX_WRAP_S_SHIFT) |
        (r300_translate_wrap(sampler->state.wrap_t) << R300_TX_WRAP_T_SHIFT) |
        (r300_translate_wrap(sampler->state.wrap_r) << R300_TX_WRAP_R_SHIFT);
a861 2
    sampler->filter0 |= r300_anisotropy(state->max_anisotropy);

d864 4
a867 2
    sampler->min_lod = (unsigned)MAX2(state->min_lod, 0);
    sampler->max_lod = (unsigned)MAX2(ceilf(state->max_lod), 0);
d869 1
a869 1
    lod_bias = CLAMP((int)(state->lod_bias * 32 + 1), -(1 << 9), (1 << 9) - 1);
d871 1
a871 1
    sampler->filter1 |= (lod_bias << R300_LOD_BIAS_SHIFT) & R300_LOD_BIAS_MASK;
d873 2
a874 7
    /* This is very high quality anisotropic filtering for R5xx.
     * It's good for benchmarking the performance of texturing but
     * in practice we don't want to slow down the driver because it's
     * a pretty good performance killer. Feel free to play with it. */
    if (DBG_ON(r300, DBG_ANISOHQ) && is_r500) {
        sampler->filter1 |= r500_anisotropy(state->max_anisotropy);
    }
d877 1
a877 1
    if (r300->screen->caps.is_r500) {
a890 1
    unsigned tex_units = r300->screen->caps.num_tex_units;
d892 1
a892 1
    if (count > tex_units) {
d897 1
a897 1
    state->sampler_state_count = count;
d899 9
a907 1
    r300_mark_atom_dirty(r300, &r300->textures_state);
d921 3
a923 28
static uint32_t r300_assign_texture_cache_region(unsigned index, unsigned num)
{
    /* This looks like a hack, but I believe it's suppose to work like
     * that. To illustrate how this works, let's assume you have 5 textures.
     * From docs, 5 and the successive numbers are:
     *
     * FOURTH_1     = 5
     * FOURTH_2     = 6
     * FOURTH_3     = 7
     * EIGHTH_0     = 8
     * EIGHTH_1     = 9
     *
     * First 3 textures will get 3/4 of size of the cache, divived evenly
     * between them. The last 1/4 of the cache must be divided between
     * the last 2 textures, each will therefore get 1/8 of the cache.
     * Why not just to use "5 + texture_index" ?
     *
     * This simple trick works for all "num" <= 16.
     */
    if (num <= 1)
        return R300_TX_CACHE(R300_TX_CACHE_WHOLE);
    else
        return R300_TX_CACHE(num + index);
}

static void r300_set_fragment_sampler_views(struct pipe_context* pipe,
                                            unsigned count,
                                            struct pipe_sampler_view** views)
d928 2
a929 3
    struct r300_texture *texture;
    unsigned i, real_num_views = 0, view_index = 0;
    unsigned tex_units = r300->screen->caps.num_tex_units;
d932 2
a933 1
    if (count > tex_units) {
a936 1
    /* Calculate the real number of views. */
d938 11
a948 21
        if (views[i])
            real_num_views++;
    }

    for (i = 0; i < count; i++) {
        pipe_sampler_view_reference(
                (struct pipe_sampler_view**)&state->sampler_views[i],
                views[i]);

        if (!views[i]) {
            continue;
        }

        /* A new sampler view (= texture)... */
        dirty_tex = TRUE;

        /* Set the texrect factor in the fragment shader.
             * Needed for RECT and NPOT fallback. */
        texture = r300_texture(views[i]->texture);
        if (texture->desc.is_npot) {
            r300_mark_atom_dirty(r300, &r300->fs_rc_constant_state);
a949 4

        state->sampler_views[i]->texcache_region =
                r300_assign_texture_cache_region(view_index, real_num_views);
        view_index++;
d952 4
a955 5
    for (i = count; i < tex_units; i++) {
        if (state->sampler_views[i]) {
            pipe_sampler_view_reference(
                    (struct pipe_sampler_view**)&state->sampler_views[i],
                    NULL);
d959 1
a959 1
    state->sampler_view_count = count;
d961 1
a961 2
    r300_mark_atom_dirty(r300, &r300->textures_state);
    r300->validate_buffers = TRUE;
d964 1
a964 34
        r300_mark_atom_dirty(r300, &r300->texture_cache_inval);
    }
}

static struct pipe_sampler_view *
r300_create_sampler_view(struct pipe_context *pipe,
                         struct pipe_resource *texture,
                         const struct pipe_sampler_view *templ)
{
    struct r300_sampler_view *view = CALLOC_STRUCT(r300_sampler_view);
    struct r300_texture *tex = r300_texture(texture);
    boolean is_r500 = r300_screen(pipe->screen)->caps.is_r500;
    boolean dxtc_swizzle = r300_screen(pipe->screen)->caps.dxtc_swizzle;

    if (view) {
        view->base = *templ;
        view->base.reference.count = 1;
        view->base.context = pipe;
        view->base.texture = NULL;
        pipe_resource_reference(&view->base.texture, texture);

        view->swizzle[0] = templ->swizzle_r;
        view->swizzle[1] = templ->swizzle_g;
        view->swizzle[2] = templ->swizzle_b;
        view->swizzle[3] = templ->swizzle_a;

        view->format = tex->tx_format;
        view->format.format1 |= r300_translate_texformat(templ->format,
                                                         view->swizzle,
                                                         is_r500,
                                                         dxtc_swizzle);
        if (is_r500) {
            view->format.format2 |= r500_tx_format_msb_bit(templ->format);
        }
a965 10

    return (struct pipe_sampler_view*)view;
}

static void
r300_sampler_view_destroy(struct pipe_context *pipe,
                          struct pipe_sampler_view *view)
{
   pipe_resource_reference(&view->texture, NULL);
   FREE(view);
d976 1
a976 1
    r300_mark_atom_dirty(r300, &r300->scissor_state);
a987 6
    if (r300->draw) {
        draw_set_viewport_state(r300->draw, state);
        viewport->vte_control = R300_VTX_XY_FMT | R300_VTX_Z_FMT;
        return;
    }

d1016 3
a1018 3
    r300_mark_atom_dirty(r300, &r300->viewport_state);
    if (r300->fs.state && r300_fs(r300)->shader->inputs.wpos != ATTR_UNUSED) {
        r300_mark_atom_dirty(r300, &r300->fs_rc_constant_state);
d1027 1
a1027 18
    struct pipe_vertex_buffer *vbo;
    unsigned i, max_index = (1 << 24) - 1;
    boolean any_user_buffer = FALSE;
    struct pipe_vertex_buffer dummy_vb = {0};

    /* There must be at least one vertex buffer set, otherwise it locks up. */
    if (!count) {
        dummy_vb.buffer = r300->dummy_vb;
        dummy_vb.max_index = r300->dummy_vb->width0 / 4;
        buffers = &dummy_vb;
        count = 1;
    }

    if (count == r300->vertex_buffer_count &&
        memcmp(r300->vertex_buffer, buffers,
            sizeof(struct pipe_vertex_buffer) * count) == 0) {
        return;
    }
d1029 2
a1030 49
    if (r300->screen->caps.has_tcl) {
        /* HW TCL. */
        r300->incompatible_vb_layout = FALSE;

        /* Check if the strides and offsets are aligned to the size of DWORD. */
        for (i = 0; i < count; i++) {
            if (buffers[i].buffer) {
                if (buffers[i].stride % 4 != 0 ||
                    buffers[i].buffer_offset % 4 != 0) {
                    r300->incompatible_vb_layout = TRUE;
                    break;
                }
            }
        }

        for (i = 0; i < count; i++) {
            /* Why, yes, I AM casting away constness. How did you know? */
            vbo = (struct pipe_vertex_buffer*)&buffers[i];

            /* Skip NULL buffers */
            if (!buffers[i].buffer) {
                continue;
            }

            if (r300_buffer_is_user_buffer(vbo->buffer)) {
                any_user_buffer = TRUE;
            }

            /* The stride of zero means we will be fetching only the first
             * vertex, so don't care about max_index. */
            if (!vbo->stride)
                continue;

            if (vbo->max_index == ~0) {
                vbo->max_index =
                        (vbo->buffer->width0 - vbo->buffer_offset) / vbo->stride;
            }

            max_index = MIN2(vbo->max_index, max_index);
        }

        r300->any_user_vbs = any_user_buffer;
        r300->vertex_buffer_max_index = max_index;
        r300->aos_dirty = TRUE;
        r300->validate_buffers = TRUE;
    } else {
        /* SW TCL. */
        draw_set_vertex_buffers(r300->draw, count, buffers);
    }
a1031 1
    /* Common code. */
d1033 1
a1033 6
        /* Reference our buffer. */
        pipe_resource_reference(&r300->vertex_buffer[i].buffer, buffers[i].buffer);
    }
    for (; i < r300->vertex_buffer_count; i++) {
        /* Dereference any old buffers. */
        pipe_resource_reference(&r300->vertex_buffer[i].buffer, NULL);
a1035 2
    memcpy(r300->vertex_buffer, buffers,
        sizeof(struct pipe_vertex_buffer) * count);
d1037 1
a1037 1
}
d1039 5
a1043 19
static void r300_set_index_buffer(struct pipe_context* pipe,
                                  const struct pipe_index_buffer *ib)
{
    struct r300_context* r300 = r300_context(pipe);

    if (ib) {
        pipe_resource_reference(&r300->index_buffer.buffer, ib->buffer);
        memcpy(&r300->index_buffer, ib, sizeof(r300->index_buffer));
    }
    else {
        pipe_resource_reference(&r300->index_buffer.buffer, NULL);
        memset(&r300->index_buffer, 0, sizeof(r300->index_buffer));
    }

    if (r300->screen->caps.has_tcl) {
        r300->validate_buffers = TRUE;
    }
    else {
        draw_set_index_buffer(r300->draw, ib);
d1047 1
a1047 2
/* Initialize the PSC tables. */
static void r300_vertex_psc(struct r300_vertex_element_state *velems)
d1049 3
a1051 4
    struct r300_vertex_stream_state *vstream = &velems->vertex_stream;
    uint16_t type, swizzle;
    enum pipe_format format;
    unsigned i;
d1053 5
a1057 29
    if (velems->count > 16) {
        fprintf(stderr, "r300: More than 16 vertex elements are not supported,"
                " requested %i, using 16.\n", velems->count);
        velems->count = 16;
    }

    /* Vertex shaders have no semantics on their inputs,
     * so PSC should just route stuff based on the vertex elements,
     * and not on attrib information. */
    for (i = 0; i < velems->count; i++) {
        format = velems->hw_format[i];

        type = r300_translate_vertex_data_type(format);
        if (type == R300_INVALID_FORMAT) {
            fprintf(stderr, "r300: Bad vertex format %s.\n",
                    util_format_short_name(format));
            assert(0);
            abort();
        }

        type |= i << R300_DST_VEC_LOC_SHIFT;
        swizzle = r300_translate_vertex_data_swizzle(format);

        if (i & 1) {
            vstream->vap_prog_stream_cntl[i >> 1] |= type << 16;
            vstream->vap_prog_stream_cntl_ext[i >> 1] |= swizzle << 16;
        } else {
            vstream->vap_prog_stream_cntl[i >> 1] |= type;
            vstream->vap_prog_stream_cntl_ext[i >> 1] |= swizzle;
d1060 1
a1060 9

    /* Set the last vector in the PSC. */
    if (i) {
        i -= 1;
    }
    vstream->vap_prog_stream_cntl[i >> 1] |=
        (R300_LAST_VEC << (i & 1 ? 16 : 0));

    vstream->count = (i >> 1) + 1;
d1063 3
a1065 6
#define FORMAT_REPLACE(what, withwhat) \
    case PIPE_FORMAT_##what: *format = PIPE_FORMAT_##withwhat; break

static void* r300_create_vertex_elements_state(struct pipe_context* pipe,
                                               unsigned count,
                                               const struct pipe_vertex_element* attribs)
d1067 1
a1067 4
    struct r300_vertex_element_state *velems;
    unsigned i;
    enum pipe_format *format;
    struct pipe_vertex_element dummy_attrib = {0};
d1069 4
a1072 53
    /* R300 Programmable Stream Control (PSC) doesn't support 0 vertex elements. */
    if (!count) {
        dummy_attrib.src_format = PIPE_FORMAT_R8G8B8A8_UNORM;
        attribs = &dummy_attrib;
        count = 1;
    }

    assert(count <= PIPE_MAX_ATTRIBS);
    velems = CALLOC_STRUCT(r300_vertex_element_state);
    if (velems != NULL) {
        velems->count = count;
        memcpy(velems->velem, attribs, sizeof(struct pipe_vertex_element) * count);

        if (r300_screen(pipe->screen)->caps.has_tcl) {
            /* Set the best hw format in case the original format is not
             * supported by hw. */
            for (i = 0; i < count; i++) {
                velems->hw_format[i] = velems->velem[i].src_format;
                format = &velems->hw_format[i];

                /* This is basically the list of unsupported formats.
                 * For now we don't care about the alignment, that's going to
                 * be sorted out after the PSC setup. */
                switch (*format) {
                    FORMAT_REPLACE(R64_FLOAT,           R32_FLOAT);
                    FORMAT_REPLACE(R64G64_FLOAT,        R32G32_FLOAT);
                    FORMAT_REPLACE(R64G64B64_FLOAT,     R32G32B32_FLOAT);
                    FORMAT_REPLACE(R64G64B64A64_FLOAT,  R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_UNORM,           R32_FLOAT);
                    FORMAT_REPLACE(R32G32_UNORM,        R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_UNORM,     R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_UNORM,  R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_USCALED,         R32_FLOAT);
                    FORMAT_REPLACE(R32G32_USCALED,      R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_USCALED,   R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_USCALED,R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_SNORM,           R32_FLOAT);
                    FORMAT_REPLACE(R32G32_SNORM,        R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_SNORM,     R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_SNORM,  R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_SSCALED,         R32_FLOAT);
                    FORMAT_REPLACE(R32G32_SSCALED,      R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_SSCALED,   R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_SSCALED,R32G32B32A32_FLOAT);

                    FORMAT_REPLACE(R32_FIXED,           R32_FLOAT);
                    FORMAT_REPLACE(R32G32_FIXED,        R32G32_FLOAT);
                    FORMAT_REPLACE(R32G32B32_FIXED,     R32G32B32_FLOAT);
                    FORMAT_REPLACE(R32G32B32A32_FIXED,  R32G32B32A32_FLOAT);
d1074 3
a1076 37
                    default:;
                }

                velems->incompatible_layout =
                        velems->incompatible_layout ||
                        velems->velem[i].src_format != velems->hw_format[i] ||
                        velems->velem[i].src_offset % 4 != 0;
            }

            /* Now setup PSC.
             * The unused components will be replaced by (..., 0, 1). */
            r300_vertex_psc(velems);

            /* Align the formats to the size of DWORD.
             * We only care about the blocksizes of the formats since
             * swizzles are already set up.
             * Also compute the vertex size. */
            for (i = 0; i < count; i++) {
                /* This is OK because we check for aligned strides too
                 * elsewhere. */
                velems->hw_format_size[i] =
                    align(util_format_get_blocksize(velems->hw_format[i]), 4);
                velems->vertex_size_dwords += velems->hw_format_size[i] / 4;
            }
        }
    }
    return velems;
}

static void r300_bind_vertex_elements_state(struct pipe_context *pipe,
                                            void *state)
{
    struct r300_context *r300 = r300_context(pipe);
    struct r300_vertex_element_state *velems = state;

    if (velems == NULL) {
        return;
d1079 4
a1082 5
    r300->velems = velems;

    if (r300->draw) {
        draw_set_vertex_elements(r300->draw, velems->count, velems->velem);
        return;
a1083 9

    UPDATE_STATE(&velems->vertex_stream, r300->vertex_stream_state);
    r300->vertex_stream_state.size = (1 + velems->vertex_stream.count) * 2;
    r300->aos_dirty = TRUE;
}

static void r300_delete_vertex_elements_state(struct pipe_context *pipe, void *state)
{
   FREE(state);
a1089 1
    struct r300_vertex_shader* vs = CALLOC_STRUCT(r300_vertex_shader);
d1091 7
a1097 3
    /* Copy state directly into shader. */
    vs->state = *shader;
    vs->state.tokens = tgsi_dup_tokens(shader->tokens);
d1099 1
a1099 3
    if (r300->screen->caps.has_tcl) {
        r300_init_vs_outputs(vs);
        r300_translate_vertex_shader(r300, vs);
d1101 1
a1101 1
        r300_draw_init_vertex_shader(r300->draw, vs);
a1102 2

    return vs;
a1107 1
    struct r300_vertex_shader* vs = (struct r300_vertex_shader*)shader;
d1109 9
a1117 8
    if (vs == NULL) {
        r300->vs_state.state = NULL;
        return;
    }
    if (vs == r300->vs_state.state) {
        return;
    }
    r300->vs_state.state = vs;
d1119 2
a1120 2
    /* The majority of the RS block bits is dependent on the vertex shader. */
    r300_mark_atom_dirty(r300, &r300->rs_block_state); /* Will be updated before the emission. */
d1122 4
a1125 12
    if (r300->screen->caps.has_tcl) {
        unsigned fc_op_dwords = r300->screen->caps.is_r500 ? 3 : 2;
        r300_mark_atom_dirty(r300, &r300->vs_state);
        r300->vs_state.size =
                vs->code.length + 9 +
        (vs->code.num_fc_ops ? vs->code.num_fc_ops * fc_op_dwords + 4 : 0);

        r300_mark_atom_dirty(r300, &r300->vs_constants);
        r300->vs_constants.size =
                2 +
                (vs->externals_count ? vs->externals_count * 4 + 3 : 0) +
                (vs->immediates_count ? vs->immediates_count * 4 + 3 : 0);
d1127 3
a1129 2
        ((struct r300_constant_buffer*)r300->vs_constants.state)->remap_table =
                vs->code.constants_remap_table;
d1131 1
a1131 1
        r300_mark_atom_dirty(r300, &r300->pvs_flush);
d1133 1
d1135 1
a1135 1
                (struct draw_vertex_shader*)vs->draw_vs);
a1141 1
    struct r300_vertex_shader* vs = (struct r300_vertex_shader*)shader;
d1143 3
a1145 1
    if (r300->screen->caps.has_tcl) {
d1147 2
a1148 2
        if (vs->code.constants_remap_table)
            FREE(vs->code.constants_remap_table);
d1151 1
a1151 1
                (struct draw_vertex_shader*)vs->draw_vs);
a1152 3

    FREE((void*)vs->state.tokens);
    FREE(shader);
d1157 1
a1157 1
                                     struct pipe_resource *buf)
d1160 3
a1162 2
    struct r300_constant_buffer *cbuf;
    uint32_t *mapped;
d1164 10
d1176 1
a1176 1
            cbuf = (struct r300_constant_buffer*)r300->vs_constants.state;
d1179 8
a1186 1
            cbuf = (struct r300_constant_buffer*)r300->fs_constants.state;
d1189 1
a1189 1
            return;
d1192 5
a1196 3
    if (buf == NULL || buf->width0 == 0 ||
        (mapped = (uint32_t*)r300_buffer(buf)->constant_buffer) == NULL) {
        return;
d1199 3
a1201 5
    if (shader == PIPE_SHADER_FRAGMENT ||
        (shader == PIPE_SHADER_VERTEX && r300->screen->caps.has_tcl)) {
        assert((buf->width0 % (4 * sizeof(float))) == 0);
        cbuf->ptr = mapped;
    }
d1204 2
a1205 23
        if (r300->screen->caps.has_tcl) {
            struct r300_vertex_shader *vs =
                    (struct r300_vertex_shader*)r300->vs_state.state;

            if (!vs) {
                cbuf->buffer_base = 0;
                return;
            }

            cbuf->buffer_base = r300->vs_const_base;
            r300->vs_const_base += vs->code.constants.Count;
            if (r300->vs_const_base > R500_MAX_PVS_CONST_VECS) {
                r300->vs_const_base = vs->code.constants.Count;
                cbuf->buffer_base = 0;
                r300_mark_atom_dirty(r300, &r300->pvs_flush);
            }
            r300_mark_atom_dirty(r300, &r300->vs_constants);
        } else if (r300->draw) {
            draw_set_mapped_constant_buffer(r300->draw, PIPE_SHADER_VERTEX,
                0, mapped, buf->width0);
        }
    } else if (shader == PIPE_SHADER_FRAGMENT) {
        r300_mark_atom_dirty(r300, &r300->fs_constants);
d1207 2
a1219 1
    r300->context.set_sample_mask = r300_set_sample_mask;
d1246 1
a1246 3
    r300->context.set_fragment_sampler_views = r300_set_fragment_sampler_views;
    r300->context.create_sampler_view = r300_create_sampler_view;
    r300->context.sampler_view_destroy = r300_sampler_view_destroy;
d1253 1
a1253 5
    r300->context.set_index_buffer = r300_set_index_buffer;

    r300->context.create_vertex_elements_state = r300_create_vertex_elements_state;
    r300->context.bind_vertex_elements_state = r300_bind_vertex_elements_state;
    r300->context.delete_vertex_elements_state = r300_delete_vertex_elements_state;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a26 2
#include "util/u_half.h"
#include "util/u_helpers.h"
a30 1
#include "util/u_transfer.h"
d46 2
d172 1
a172 3
static unsigned blend_discard_conditionally(unsigned eqRGB, unsigned eqA,
                                            unsigned dstRGB, unsigned dstA,
                                            unsigned srcRGB, unsigned srcA)
d174 1
a174 48
    unsigned blend_control = 0;

    /* Optimization: discard pixels which don't change the colorbuffer.
     *
     * The code below is non-trivial and some math is involved.
     *
     * Discarding pixels must be disabled when FP16 AA is enabled.
     * This is a hardware bug. Also, this implementation wouldn't work
     * with FP blending enabled and equation clamping disabled.
     *
     * Equations other than ADD are rarely used and therefore won't be
     * optimized. */
    if ((eqRGB == PIPE_BLEND_ADD || eqRGB == PIPE_BLEND_REVERSE_SUBTRACT) &&
        (eqA == PIPE_BLEND_ADD || eqA == PIPE_BLEND_REVERSE_SUBTRACT)) {
        /* ADD: X+Y
         * REVERSE_SUBTRACT: Y-X
         *
         * The idea is:
         * If X = src*srcFactor = 0 and Y = dst*dstFactor = 1,
         * then CB will not be changed.
         *
         * Given the srcFactor and dstFactor variables, we can derive
         * what src and dst should be equal to and discard appropriate
         * pixels.
         */
        if (blend_discard_if_src_alpha_0(srcRGB, srcA, dstRGB, dstA)) {
            blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_0;
        } else if (blend_discard_if_src_alpha_1(srcRGB, srcA,
                                                dstRGB, dstA)) {
            blend_control |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_1;
        } else if (blend_discard_if_src_color_0(srcRGB, srcA,
                                                dstRGB, dstA)) {
            blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_0;
        } else if (blend_discard_if_src_color_1(srcRGB, srcA,
                                                dstRGB, dstA)) {
            blend_control |= R300_DISCARD_SRC_PIXELS_SRC_COLOR_1;
        } else if (blend_discard_if_src_alpha_color_0(srcRGB, srcA,
                                                      dstRGB, dstA)) {
            blend_control |=
                R300_DISCARD_SRC_PIXELS_SRC_ALPHA_COLOR_0;
        } else if (blend_discard_if_src_alpha_color_1(srcRGB, srcA,
                                                      dstRGB, dstA)) {
            blend_control |=
                R300_DISCARD_SRC_PIXELS_SRC_ALPHA_COLOR_1;
        }
    }
    return blend_control;
}
a175 4
/* The hardware colormask is clunky a must be swizzled depending on the format.
 * This was figured out by trial-and-error. */
static unsigned bgra_cmask(unsigned mask)
{
a180 101
static unsigned rgba_cmask(unsigned mask)
{
    return mask & PIPE_MASK_RGBA;
}

static unsigned rrrr_cmask(unsigned mask)
{
    return (mask & PIPE_MASK_R) |
           ((mask & PIPE_MASK_R) << 1) |
           ((mask & PIPE_MASK_R) << 2) |
           ((mask & PIPE_MASK_R) << 3);
}

static unsigned aaaa_cmask(unsigned mask)
{
    return ((mask & PIPE_MASK_A) >> 3) |
           ((mask & PIPE_MASK_A) >> 2) |
           ((mask & PIPE_MASK_A) >> 1) |
           (mask & PIPE_MASK_A);
}

static unsigned grrg_cmask(unsigned mask)
{
    return ((mask & PIPE_MASK_R) << 1) |
           ((mask & PIPE_MASK_R) << 2) |
           ((mask & PIPE_MASK_G) >> 1) |
           ((mask & PIPE_MASK_G) << 2);
}

static unsigned arra_cmask(unsigned mask)
{
    return ((mask & PIPE_MASK_R) << 1) |
           ((mask & PIPE_MASK_R) << 2) |
           ((mask & PIPE_MASK_A) >> 3) |
           (mask & PIPE_MASK_A);
}

static unsigned blend_read_enable(unsigned eqRGB, unsigned eqA,
                                  unsigned dstRGB, unsigned dstA,
                                  unsigned srcRGB, unsigned srcA,
                                  boolean src_alpha_optz)
{
    unsigned blend_control = 0;

    /* Optimization: some operations do not require the destination color.
     *
     * When SRC_ALPHA_SATURATE is used, colorbuffer reads must be enabled,
     * otherwise blending gives incorrect results. It seems to be
     * a hardware bug. */
    if (eqRGB == PIPE_BLEND_MIN || eqA == PIPE_BLEND_MIN ||
        eqRGB == PIPE_BLEND_MAX || eqA == PIPE_BLEND_MAX ||
        dstRGB != PIPE_BLENDFACTOR_ZERO ||
        dstA != PIPE_BLENDFACTOR_ZERO ||
        srcRGB == PIPE_BLENDFACTOR_DST_COLOR ||
        srcRGB == PIPE_BLENDFACTOR_DST_ALPHA ||
        srcRGB == PIPE_BLENDFACTOR_INV_DST_COLOR ||
        srcRGB == PIPE_BLENDFACTOR_INV_DST_ALPHA ||
        srcA == PIPE_BLENDFACTOR_DST_COLOR ||
        srcA == PIPE_BLENDFACTOR_DST_ALPHA ||
        srcA == PIPE_BLENDFACTOR_INV_DST_COLOR ||
        srcA == PIPE_BLENDFACTOR_INV_DST_ALPHA ||
        srcRGB == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE) {
        /* Enable reading from the colorbuffer. */
        blend_control |= R300_READ_ENABLE;

        if (src_alpha_optz) {
            /* Optimization: Depending on incoming pixels, we can
             * conditionally disable the reading in hardware... */
            if (eqRGB != PIPE_BLEND_MIN && eqA != PIPE_BLEND_MIN &&
                eqRGB != PIPE_BLEND_MAX && eqA != PIPE_BLEND_MAX) {
                /* Disable reading if SRC_ALPHA == 0. */
                if ((dstRGB == PIPE_BLENDFACTOR_SRC_ALPHA ||
                     dstRGB == PIPE_BLENDFACTOR_ZERO) &&
                    (dstA == PIPE_BLENDFACTOR_SRC_COLOR ||
                     dstA == PIPE_BLENDFACTOR_SRC_ALPHA ||
                     dstA == PIPE_BLENDFACTOR_ZERO) &&
                    (srcRGB != PIPE_BLENDFACTOR_DST_COLOR &&
                     srcRGB != PIPE_BLENDFACTOR_DST_ALPHA &&
                     srcRGB != PIPE_BLENDFACTOR_INV_DST_COLOR &&
                     srcRGB != PIPE_BLENDFACTOR_INV_DST_ALPHA)) {
                     blend_control |= R500_SRC_ALPHA_0_NO_READ;
                }

                /* Disable reading if SRC_ALPHA == 1. */
                if ((dstRGB == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
                     dstRGB == PIPE_BLENDFACTOR_ZERO) &&
                    (dstA == PIPE_BLENDFACTOR_INV_SRC_COLOR ||
                     dstA == PIPE_BLENDFACTOR_INV_SRC_ALPHA ||
                     dstA == PIPE_BLENDFACTOR_ZERO) &&
                    (srcRGB != PIPE_BLENDFACTOR_DST_COLOR &&
                     srcRGB != PIPE_BLENDFACTOR_DST_ALPHA &&
                     srcRGB != PIPE_BLENDFACTOR_INV_DST_COLOR &&
                     srcRGB != PIPE_BLENDFACTOR_INV_DST_ALPHA)) {
                     blend_control |= R500_SRC_ALPHA_1_NO_READ;
                }
            }
        }
    }
    return blend_control;
}

a189 3
    uint32_t blend_control_noclamp = 0;    /* R300_RB3D_CBLEND: 0x4e04 */
    uint32_t blend_control_noalpha = 0;    /* R300_RB3D_CBLEND: 0x4e04 */
    uint32_t blend_control_noalpha_noclamp = 0;    /* R300_RB3D_CBLEND: 0x4e04 */
d191 1
a191 3
    uint32_t alpha_blend_control_noclamp = 0; /* R300_RB3D_ABLEND: 0x4e08 */
    uint32_t alpha_blend_control_noalpha = 0; /* R300_RB3D_ABLEND: 0x4e08 */
    uint32_t alpha_blend_control_noalpha_noclamp = 0; /* R300_RB3D_ABLEND: 0x4e08 */
a193 12
    int i;

    const unsigned eqRGB = state->rt[0].rgb_func;
    const unsigned srcRGB = state->rt[0].rgb_src_factor;
    const unsigned dstRGB = state->rt[0].rgb_dst_factor;

    const unsigned eqA = state->rt[0].alpha_func;
    const unsigned srcA = state->rt[0].alpha_src_factor;
    const unsigned dstA = state->rt[0].alpha_dst_factor;

    unsigned srcRGBX = srcRGB;
    unsigned dstRGBX = dstRGB;
d196 9
a204 24
    blend->state = *state;

    /* force DST_ALPHA to ONE where we can */
    switch (srcRGBX) {
    case PIPE_BLENDFACTOR_DST_ALPHA:
        srcRGBX = PIPE_BLENDFACTOR_ONE;
        break;
    case PIPE_BLENDFACTOR_INV_DST_ALPHA:
        srcRGBX = PIPE_BLENDFACTOR_ZERO;
        break;
    }

    switch (dstRGBX) {
    case PIPE_BLENDFACTOR_DST_ALPHA:
        dstRGBX = PIPE_BLENDFACTOR_ONE;
        break;
    case PIPE_BLENDFACTOR_INV_DST_ALPHA:
        dstRGBX = PIPE_BLENDFACTOR_ZERO;
        break;
    }

    /* Get blending register values. */
    if (state->rt[0].blend_enable) {
        unsigned blend_eq, blend_eq_noclamp;
d208 2
a209 2
        blend_control = blend_control_noclamp =
            R300_ALPHA_BLEND_ENABLE |
d213 46
a258 22
        blend_control_noalpha = blend_control_noalpha_noclamp =
            R300_ALPHA_BLEND_ENABLE |
            ( r300_translate_blend_factor(srcRGBX) << R300_SRC_BLEND_SHIFT) |
            ( r300_translate_blend_factor(dstRGBX) << R300_DST_BLEND_SHIFT);

        blend_eq = r300_translate_blend_function(eqRGB, TRUE);
        blend_eq_noclamp = r300_translate_blend_function(eqRGB, FALSE);

        blend_control |= blend_eq;
        blend_control_noalpha |= blend_eq;
        blend_control_noclamp |= blend_eq_noclamp;
        blend_control_noalpha_noclamp |= blend_eq_noclamp;

        /* Optimization: some operations do not require the destination color. */
        blend_control |= blend_read_enable(eqRGB, eqA, dstRGB, dstA,
                                           srcRGB, srcA, r300screen->caps.is_r500);
        blend_control_noclamp |= blend_read_enable(eqRGB, eqA, dstRGB, dstA,
                                                   srcRGB, srcA, FALSE);
        blend_control_noalpha |= blend_read_enable(eqRGB, eqA, dstRGBX, dstA,
                                                   srcRGBX, srcA, r300screen->caps.is_r500);
        blend_control_noalpha_noclamp |= blend_read_enable(eqRGB, eqA, dstRGBX, dstA,
                                                           srcRGBX, srcA, FALSE);
d261 43
a303 5
         * It cannot be used with FP16 AA. */
        blend_control |= blend_discard_conditionally(eqRGB, eqA, dstRGB, dstA,
                                                     srcRGB, srcA);
        blend_control_noalpha |= blend_discard_conditionally(eqRGB, eqA, dstRGBX, dstA,
                                                             srcRGBX, srcA);
d308 2
a309 13
            blend_control_noclamp |= R300_SEPARATE_ALPHA_ENABLE;

            alpha_blend_control = alpha_blend_control_noclamp =
                (r300_translate_blend_factor(srcA) << R300_SRC_BLEND_SHIFT) |
                (r300_translate_blend_factor(dstA) << R300_DST_BLEND_SHIFT);
            alpha_blend_control |= r300_translate_blend_function(eqA, TRUE);
            alpha_blend_control_noclamp |= r300_translate_blend_function(eqA, FALSE);
        }
        if (srcA != srcRGBX || dstA != dstRGBX || eqA != eqRGB) {
            blend_control_noalpha |= R300_SEPARATE_ALPHA_ENABLE;
            blend_control_noalpha_noclamp |= R300_SEPARATE_ALPHA_ENABLE;

            alpha_blend_control_noalpha = alpha_blend_control_noalpha_noclamp =
a311 2
            alpha_blend_control_noalpha |= r300_translate_blend_function(eqA, TRUE);
            alpha_blend_control_noalpha_noclamp |= r300_translate_blend_function(eqA, FALSE);
d321 14
d348 1
a348 38
    {
        unsigned (*func[COLORMASK_NUM_SWIZZLES])(unsigned) = {
            bgra_cmask,
            rgba_cmask,
            rrrr_cmask,
            aaaa_cmask,
            grrg_cmask,
            arra_cmask,
            bgra_cmask,
            rgba_cmask
        };

        for (i = 0; i < COLORMASK_NUM_SWIZZLES; i++) {
            boolean has_alpha = i != COLORMASK_RGBX && i != COLORMASK_BGRX;

            BEGIN_CB(blend->cb_clamp[i], 8);
            OUT_CB_REG(R300_RB3D_ROPCNTL, rop);
            OUT_CB_REG_SEQ(R300_RB3D_CBLEND, 3);
            OUT_CB(has_alpha ? blend_control : blend_control_noalpha);
            OUT_CB(has_alpha ? alpha_blend_control : alpha_blend_control_noalpha);
            OUT_CB(func[i](state->rt[0].colormask));
            OUT_CB_REG(R300_RB3D_DITHER_CTL, dither);
            END_CB;
        }
    }

    /* Build a command buffer (for RGBA16F). */
    BEGIN_CB(blend->cb_noclamp, 8);
    OUT_CB_REG(R300_RB3D_ROPCNTL, rop);
    OUT_CB_REG_SEQ(R300_RB3D_CBLEND, 3);
    OUT_CB(blend_control_noclamp);
    OUT_CB(alpha_blend_control_noclamp);
    OUT_CB(rgba_cmask(state->rt[0].colormask));
    OUT_CB_REG(R300_RB3D_DITHER_CTL, dither);
    END_CB;

    /* Build a command buffer (for RGB16F). */
    BEGIN_CB(blend->cb_noclamp_noalpha, 8);
d351 3
a353 3
    OUT_CB(blend_control_noalpha_noclamp);
    OUT_CB(alpha_blend_control_noalpha_noclamp);
    OUT_CB(rgba_cmask(state->rt[0].colormask));
a374 3
    struct r300_blend_state *blend  = (struct r300_blend_state*)state;
    boolean last_alpha_to_one = r300->alpha_to_one;
    boolean last_alpha_to_coverage = r300->alpha_to_coverage;
a376 16

    if (!blend)
        return;

    r300->alpha_to_one = blend->state.alpha_to_one;
    r300->alpha_to_coverage = blend->state.alpha_to_coverage;

    if (r300->alpha_to_one != last_alpha_to_one && r300->msaa_enable &&
        r300->fs_status == FRAGMENT_SHADER_VALID) {
        r300->fs_status = FRAGMENT_SHADER_MAYBE_DIRTY;
    }

    if (r300->alpha_to_coverage != last_alpha_to_coverage &&
        r300->msaa_enable) {
        r300_mark_atom_dirty(r300, &r300->dsa_state);
    }
d398 1
a398 2
    struct pipe_framebuffer_state *fb = r300->fb_state.state;
    struct r300_blend_color_state *state =
a399 3
    struct pipe_blend_color c;
    enum pipe_format format = fb->nr_cbufs ? fb->cbufs[0]->format : 0;
    float tmp;
a401 36
    state->state = *color; /* Save it, so that we can reuse it in set_fb_state */
    c = *color;

    /* The blend color is dependent on the colorbuffer format. */
    if (fb->nr_cbufs) {
        switch (format) {
        case PIPE_FORMAT_R8_UNORM:
        case PIPE_FORMAT_L8_UNORM:
        case PIPE_FORMAT_I8_UNORM:
            c.color[1] = c.color[0];
            break;

        case PIPE_FORMAT_A8_UNORM:
            c.color[1] = c.color[3];
            break;

        case PIPE_FORMAT_R8G8_UNORM:
            c.color[2] = c.color[1];
            break;

        case PIPE_FORMAT_L8A8_UNORM:
        case PIPE_FORMAT_R8A8_UNORM:
            c.color[2] = c.color[3];
            break;

        case PIPE_FORMAT_R8G8B8A8_UNORM:
        case PIPE_FORMAT_R8G8B8X8_UNORM:
            tmp = c.color[0];
            c.color[0] = c.color[2];
            c.color[2] = tmp;
            break;

        default:;
        }
    }

d403 1
d406 4
a409 17

        switch (format) {
        case PIPE_FORMAT_R16G16B16A16_FLOAT:
        case PIPE_FORMAT_R16G16B16X16_FLOAT:
            OUT_CB(util_float_to_half(c.color[2]) |
                   (util_float_to_half(c.color[3]) << 16));
            OUT_CB(util_float_to_half(c.color[0]) |
                   (util_float_to_half(c.color[1]) << 16));
            break;

        default:
            OUT_CB(float_to_fixed10(c.color[0]) |
                   (float_to_fixed10(c.color[3]) << 16));
            OUT_CB(float_to_fixed10(c.color[2]) |
                   (float_to_fixed10(c.color[1]) << 16));
        }

d413 1
a413 1
        util_pack_color(c.color, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
d431 2
d434 2
d437 2
a438 1
        OUT_CB_REG(R300_VAP_PVS_VECTOR_INDX_REG,
d441 6
a446 2
        OUT_CB_ONE_REG(R300_VAP_PVS_UPLOAD_DATA, 6 * 4);
        OUT_CB_TABLE(state->ucp, 6 * 4);
d455 7
d467 3
a469 2
static void* r300_create_dsa_state(struct pipe_context* pipe,
                          const struct pipe_depth_stencil_alpha_state* state)
d471 1
a471 1
    boolean is_r500 = r300_screen(pipe->screen)->caps.is_r500;
a473 5
    uint32_t alpha_value_fp16 = 0;
    uint32_t z_buffer_control = 0;
    uint32_t z_stencil_control = 0;
    uint32_t stencil_ref_mask = 0;
    uint32_t stencil_ref_bf = 0;
d479 1
a479 1
        z_buffer_control |= R300_Z_WRITE_ENABLE;
d483 1
a483 1
        z_buffer_control |= R300_Z_ENABLE;
d485 1
a485 1
        z_stencil_control |=
d488 4
d496 2
a497 2
        z_buffer_control |= R300_STENCIL_ENABLE;
        z_stencil_control |=
d507 1
a507 1
        stencil_ref_mask =
d514 2
a515 2
            z_buffer_control |= R300_STENCIL_FRONT_BACK;
            z_stencil_control |=
d525 1
a525 1
            stencil_ref_bf =
d529 2
a530 2
            if (is_r500) {
                z_buffer_control |= R500_STENCIL_REFMASK_FRONT_BACK;
d545 1
d547 3
a549 1
        alpha_value_fp16 = util_float_to_half(state->alpha.ref_value);
d553 1
d555 4
a558 5
    OUT_CB(z_buffer_control);
    OUT_CB(z_stencil_control);
    OUT_CB(stencil_ref_mask);
    OUT_CB_REG(R500_ZB_STENCILREFMASK_BF, stencil_ref_bf);
    OUT_CB_REG(R500_FG_ALPHA_VALUE, alpha_value_fp16);
d561 4
a564 1
    BEGIN_CB(dsa->cb_zb_no_readwrite, 8);
d566 2
a567 2
    OUT_CB(0);
    OUT_CB(0);
a569 1
    OUT_CB_REG(R500_FG_ALPHA_VALUE, alpha_value_fp16);
d626 1
a626 2
                                      struct r300_resource *tex,
                                      unsigned level)
d630 11
a640 6
    if (tex->tex.macrotile[tex->surface_level] !=
        tex->tex.macrotile[level]) {
        r300->rws->buffer_set_tiling(tex->buf, r300->cs,
                tex->tex.microtile, tex->tex.macrotile[level],
                0, 0, 0, 0, 0,
                tex->tex.stride_in_bytes[0]);
d655 1
a655 1
                                  r300_resource(state->cbufs[i]->texture),
d660 1
a660 1
                                  r300_resource(state->zsbuf->texture),
d669 1
a669 1
    struct r300_resource *rtex = r300_resource(tex);
d675 1
a675 1
            "r300:     TEX: Macro: %s, Micro: %s, "
d682 3
a684 2
            rtex->tex.macrotile[0] ? "YES" : " NO",
            rtex->tex.microtile ? "YES" : " NO",
d686 1
a686 1
            tex->last_level, util_format_short_name(surf->format));
d693 1
d695 1
d698 1
a699 1
    /* What is marked as dirty depends on the enum r300_fb_state_change. */
a701 11
        r300_mark_atom_dirty(r300, &r300->dsa_state); /* for AlphaRef */
        r300_set_blend_color(&r300->context, r300->blend_color_state.state);
    }

    if (change == R300_CHANGED_FB_STATE ||
        change == R300_CHANGED_HYPERZ_FLAG) {
        r300_mark_atom_dirty(r300, &r300->hyperz_state);
    }

    if (change == R300_CHANGED_FB_STATE ||
        change == R300_CHANGED_MULTIWRITE) {
d708 1
a708 1
    if (r300->cbzb_clear)
d710 5
a714 1
    else if (state->zsbuf) {
a715 9
        if (r300->hyperz_enabled)
            r300->fb_state.size += 8;
    }

    if (r300->cmask_in_use) {
        r300->fb_state.size += 6;
        if (r300->screen->caps.is_r500 && r300->screen->info.drm_minor >= 29) {
            r300->fb_state.size += 3;
        }
a720 23
static unsigned r300_get_num_samples(struct r300_context *r300)
{
    struct pipe_framebuffer_state* fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    unsigned i, num_samples;

    if (!fb->nr_cbufs && !fb->zsbuf)
        return 1;

    num_samples = 6;

    for (i = 0; i < fb->nr_cbufs; i++)
        num_samples = MIN2(num_samples, fb->cbufs[i]->texture->nr_samples);

    if (fb->zsbuf)
        num_samples = MIN2(num_samples, fb->zsbuf->texture->nr_samples);

    if (!num_samples)
        num_samples = 1;

    return num_samples;
}

d722 2
a723 2
r300_set_framebuffer_state(struct pipe_context* pipe,
                           const struct pipe_framebuffer_state* state)
d728 1
d731 1
a731 1
    boolean unlock_zbuffer = FALSE;
d747 3
a749 25
    if (old_state->zsbuf && r300->zmask_in_use && !r300->locked_zbuffer) {
        /* There is a zmask in use, what are we gonna do? */
        if (state->zsbuf) {
            if (!pipe_surface_equal(old_state->zsbuf, state->zsbuf)) {
                /* Decompress the currently bound zbuffer before we bind another one. */
                r300_decompress_zmask(r300);
                r300->hiz_in_use = FALSE;
            }
        } else {
            /* We don't bind another zbuffer, so lock the current one. */
            pipe_surface_reference(&r300->locked_zbuffer, old_state->zsbuf);
        }
    } else if (r300->locked_zbuffer) {
        /* We have a locked zbuffer now, what are we gonna do? */
        if (state->zsbuf) {
            if (!pipe_surface_equal(r300->locked_zbuffer, state->zsbuf)) {
                /* We are binding some other zbuffer, so decompress the locked one,
                 * it gets unlocked automatically. */
                r300_decompress_zmask_locked_unsafe(r300);
                r300->hiz_in_use = FALSE;
            } else {
                /* We are binding the locked zbuffer again, so unlock it. */
                unlock_zbuffer = TRUE;
            }
        }
a750 13
    assert(state->zsbuf || (r300->locked_zbuffer && !unlock_zbuffer) || !r300->zmask_in_use);

    /* Set whether CMASK can be used. */
    r300->cmask_in_use =
        state->nr_cbufs == 1 &&
        r300->screen->cmask_resource == state->cbufs[0]->texture;

    /* Need to reset clamping or colormask. */
    r300_mark_atom_dirty(r300, &r300->blend_state);

    /* Re-swizzle the blend color. */
    r300_set_blend_color(pipe, &((struct r300_blend_color_state*)r300->blend_color_state.state)->state);

d756 2
a757 6
    if (r300->screen->info.drm_minor < 12) {
       /* The tiling flags are dependent on the surface miplevel, unfortunately.
        * This workarounds a bad design decision in old kernels which were
        * rewriting tile fields in registers. */
        r300_fb_set_tiling_flags(r300, state);
    }
a760 4
    if (unlock_zbuffer) {
        pipe_surface_reference(&r300->locked_zbuffer, NULL);
    }

d762 1
d764 2
d767 2
a768 1
        switch (util_format_get_blocksize(state->zsbuf->format)) {
d776 25
a810 2
    r300->num_samples = r300_get_num_samples(r300);

d812 20
a831 14
    if (r300->num_samples > 1) {
        switch (r300->num_samples) {
        case 2:
            aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE |
                            R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_2;
            break;
        case 4:
            aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE |
                            R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_4;
            break;
        case 6:
            aa->aa_config = R300_GB_AA_CONFIG_AA_ENABLE |
                            R300_GB_AA_CONFIG_NUM_AA_SUBSAMPLES_6;
            break;
a832 2
    } else {
        aa->aa_config = 0;
d894 2
a895 1
    r300->fs_status = FRAGMENT_SHADER_DIRTY;
d934 1
a935 1
    uint32_t vap_clip_cntl;         /* R300_VAP_CLIP_CNTL: 0x221C */
a944 1
    uint32_t round_mode;            /* R300_GA_ROUND_MODE: 0x428c */
a950 1
    boolean vclamp = !r300_context(pipe)->screen->caps.is_r500;
a961 4
    rs->rs_draw.offset_point = 0;
    rs->rs_draw.offset_line = 0;
    rs->rs_draw.offset_tri = 0;
    rs->rs_draw.offset_clamp = 0;
d983 2
a984 3
        float min_psiz = util_get_min_point_size(state);
        float max_psiz = pipe->screen->get_paramf(pipe->screen,
                                        PIPE_CAPF_MAX_POINT_WIDTH);
d986 1
a986 2
            (pack_float_16_6x(min_psiz) << R300_GA_POINT_MINMAX_MIN_SHIFT) |
            (pack_float_16_6x(max_psiz) << R300_GA_POINT_MINMAX_MAX_SHIFT);
d990 1
a990 1
        float psiz = state->point_size;
a1072 13
    if (r300_screen(pipe->screen)->caps.has_tcl) {
       vap_clip_cntl = (state->clip_plane_enable & 63) |
                       R300_PS_UCP_MODE_CLIP_AS_TRIFAN;
    } else {
       vap_clip_cntl = R300_CLIP_DISABLE;
    }

    /* Vertex color clamping. FP20 means no clamping. */
    round_mode =
      R300_GA_ROUND_MODE_GEOMETRY_ROUND_NEAREST |
      (!vclamp ? (R300_GA_ROUND_MODE_RGB_CLAMP_FP20 |
                  R300_GA_ROUND_MODE_ALPHA_CLAMP_FP20) : 0);

a1075 1
    OUT_CB_REG(R300_VAP_CLIP_CNTL, vap_clip_cntl);
d1082 1
a1082 1
    rs->cull_mode_index = 11;
a1086 1
    OUT_CB_REG(R300_GA_ROUND_MODE, round_mode);
a1128 2
    boolean last_msaa_enable = r300->msaa_enable;
    boolean last_flatshade = r300->flatshade;
a1137 2
        r300->msaa_enable = rs->rs.multisample;
        r300->flatshade = rs->rs.flatshade;
a1141 2
        r300->msaa_enable = FALSE;
        r300->flatshade = FALSE;
d1148 1
a1148 2
        last_two_sided_color != r300->two_sided_color ||
        last_flatshade != r300->flatshade) {
a1150 11

    if (last_msaa_enable != r300->msaa_enable) {
        if (r300->alpha_to_coverage) {
            r300_mark_atom_dirty(r300, &r300->dsa_state);
        }

        if (r300->alpha_to_one &&
            r300->fs_status == FRAGMENT_SHADER_VALID) {
            r300->fs_status = FRAGMENT_SHADER_MAYBE_DIRTY;
        }
    }
d1202 1
a1202 1
                                                   state->max_anisotropy > 1);
d1293 1
a1293 1
    struct r300_resource *texture;
d1322 2
a1323 2
        texture = r300_resource(views[i]->texture);
        if (texture->tex.is_npot) {
d1343 1
d1350 2
a1351 2
struct pipe_sampler_view *
r300_create_sampler_view_custom(struct pipe_context *pipe,
d1353 1
a1353 3
                         const struct pipe_sampler_view *templ,
                         unsigned width0_override,
                         unsigned height0_override)
d1356 1
a1356 1
    struct r300_resource *tex = r300_resource(texture);
a1360 2
        unsigned hwformat;

a1366 2
	view->width0_override = width0_override;
	view->height0_override = height0_override;
d1372 5
a1376 16
        hwformat = r300_translate_texformat(templ->format,
                                            view->swizzle,
                                            is_r500,
                                            dxtc_swizzle);

        if (hwformat == ~0) {
            fprintf(stderr, "r300: Ooops. Got unsupported format %s in %s.\n",
                    util_format_short_name(templ->format), __func__);
        }
        assert(hwformat != ~0);

	r300_texture_setup_format_state(r300_screen(pipe->screen), tex,
					templ->format, 0,
	                                width0_override, height0_override,
					&view->format);
        view->format.format1 |= hwformat;
a1384 11
static struct pipe_sampler_view *
r300_create_sampler_view(struct pipe_context *pipe,
                         struct pipe_resource *texture,
                         const struct pipe_sampler_view *templ)
{
    return r300_create_sampler_view_custom(pipe, texture, templ,
                                           r300_resource(texture)->tex.width0,
                                           r300_resource(texture)->tex.height0);
}


d1393 2
a1394 14
static void r300_set_sample_mask(struct pipe_context *pipe,
                                 unsigned mask)
{
    struct r300_context* r300 = r300_context(pipe);

    *((unsigned*)r300->sample_mask.state) = mask;

    r300_mark_atom_dirty(r300, &r300->sample_mask);
}

static void r300_set_scissor_states(struct pipe_context* pipe,
                                    unsigned start_slot,
                                    unsigned num_scissors,
                                    const struct pipe_scissor_state* state)
d1404 2
a1405 4
static void r300_set_viewport_states(struct pipe_context* pipe,
                                     unsigned start_slot,
                                     unsigned num_viewports,
                                     const struct pipe_viewport_state* state)
d1414 1
a1414 1
        draw_set_viewport_states(r300->draw, start_slot, num_viewports, state);
d1448 1
a1448 2
    if (r300->fs.state && r300_fs(r300)->shader &&
        r300_fs(r300)->shader->inputs.wpos != ATTR_UNUSED) {
d1453 2
a1454 2
static void r300_set_vertex_buffers_hwtcl(struct pipe_context* pipe,
                                    unsigned start_slot, unsigned count,
d1458 4
d1463 7
a1469 3
    util_set_vertex_buffers_count(r300->vertex_buffer,
                                  &r300->nr_vertex_buffers,
                                  buffers, start_slot, count);
d1471 4
a1474 5
    /* There must be at least one vertex buffer set, otherwise it locks up. */
    if (!r300->nr_vertex_buffers) {
        util_set_vertex_buffers_count(r300->vertex_buffer,
                                      &r300->nr_vertex_buffers,
                                      &r300->dummy_vb, 0, 1);
d1477 27
a1503 2
    r300->vertex_arrays_dirty = TRUE;
}
d1505 9
a1513 6
static void r300_set_vertex_buffers_swtcl(struct pipe_context* pipe,
                                    unsigned start_slot, unsigned count,
                                    const struct pipe_vertex_buffer* buffers)
{
    struct r300_context* r300 = r300_context(pipe);
    unsigned i;
d1515 2
a1516 4
    util_set_vertex_buffers_count(r300->vertex_buffer,
                                  &r300->nr_vertex_buffers,
                                  buffers, start_slot, count);
    draw_set_vertex_buffers(r300->draw, start_slot, count, buffers);
d1518 8
a1525 2
    if (!buffers)
        return;
d1527 1
d1529 6
a1534 7
        if (buffers[i].user_buffer) {
            draw_set_mapped_vertex_buffer(r300->draw, start_slot + i,
                                          buffers[i].user_buffer, ~0);
        } else if (buffers[i].buffer) {
            draw_set_mapped_vertex_buffer(r300->draw, start_slot + i,
                                          r300_resource(buffers[i].buffer)->malloced_buffer, ~0);
        }
d1536 4
d1542 2
a1543 2
static void r300_set_index_buffer_hwtcl(struct pipe_context* pipe,
                                        const struct pipe_index_buffer *ib)
d1549 3
a1551 2
        memcpy(&r300->index_buffer, ib, sizeof(*ib));
    } else {
d1553 1
a1554 1
}
d1556 5
a1560 15
static void r300_set_index_buffer_swtcl(struct pipe_context* pipe,
                                        const struct pipe_index_buffer *ib)
{
    struct r300_context* r300 = r300_context(pipe);

    if (ib) {
        const void *buf = NULL;
        if (ib->user_buffer) {
            buf = ib->user_buffer;
        } else if (ib->buffer) {
            buf = r300_resource(ib->buffer)->malloced_buffer;
        }
        draw_set_indexes(r300->draw,
                         (const ubyte *) buf + ib->offset,
                         ib->index_size, ~0);
d1572 6
d1582 1
a1582 1
        format = velems->velem[i].src_format;
d1614 3
d1623 1
a1630 4
    } else if (count > 16) {
        fprintf(stderr, "r300: More than 16 vertex elements are not supported,"
                " requested %i, using 16.\n", count);
        count = 16;
d1633 1
d1635 44
a1678 2
    if (!velems)
        return NULL;
d1680 2
a1681 2
    velems->count = count;
    memcpy(velems->velem, attribs, sizeof(struct pipe_vertex_element) * count);
d1683 5
a1687 4
    if (r300_screen(pipe->screen)->caps.has_tcl) {
        /* Setup PSC.
         * The unused components will be replaced by (..., 0, 1). */
        r300_vertex_psc(velems);
d1689 15
a1703 4
        for (i = 0; i < count; i++) {
            velems->format_size[i] =
                align(util_format_get_blocksize(velems->velem[i].src_format), 4);
            velems->vertex_size_dwords += velems->format_size[i] / 4;
a1705 1

d1728 1
a1728 1
    r300->vertex_arrays_dirty = TRUE;
d1733 1
a1733 1
    FREE(state);
d1747 1
a1747 1
        r300_init_vs_outputs(r300, vs);
d1750 1
a1750 1
        r300_draw_init_vertex_shader(r300, vs);
d1776 3
a1778 2
        r300->vs_state.size = vs->code.length + 9 +
			(R300_VS_MAX_FC_OPS * fc_op_dwords + 4);
d1803 2
a1804 1
        FREE(vs->code.constants_remap_table);
d1816 1
a1816 1
                                     struct pipe_constant_buffer *cb)
a1821 3
    if (!cb || (!cb->buffer && !cb->user_buffer))
        return;

d1833 3
a1835 10

    if (cb->user_buffer)
        mapped = (uint32_t*)cb->user_buffer;
    else {
        struct r300_resource *rbuf = r300_resource(cb->buffer);

        if (rbuf && rbuf->malloced_buffer)
            mapped = (uint32_t*)rbuf->malloced_buffer;
        else
            return;
d1840 1
d1864 1
a1864 1
                0, mapped, cb->buffer_size);
a1870 8
static void r300_texture_barrier(struct pipe_context *pipe)
{
    struct r300_context *r300 = r300_context(pipe);

    r300_mark_atom_dirty(r300, &r300->gpu_flush);
    r300_mark_atom_dirty(r300, &r300->texture_cache_inval);
}

d1911 1
a1911 1
    r300->context.set_scissor_states = r300_set_scissor_states;
d1913 1
a1913 1
    r300->context.set_viewport_states = r300_set_viewport_states;
d1915 2
a1916 7
    if (r300->screen->caps.has_tcl) {
        r300->context.set_vertex_buffers = r300_set_vertex_buffers_hwtcl;
        r300->context.set_index_buffer = r300_set_index_buffer_hwtcl;
    } else {
        r300->context.set_vertex_buffers = r300_set_vertex_buffers_swtcl;
        r300->context.set_index_buffer = r300_set_index_buffer_swtcl;
    }
a1924 2

    r300->context.texture_barrier = r300_texture_barrier;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d582 1
a582 1
    struct pipe_surface *cb;
a587 1
    cb = fb->nr_cbufs ? r300_get_nonnull_cb(fb, 0) : NULL;
d590 2
a591 2
    if (cb) {
        switch (cb->format) {
d626 1
a626 1
        switch (cb ? cb->format : 0) {
d648 1
a648 1
        OUT_CB_REG(R300_RB3D_BLEND_COLOR, uc.ui[0]);
d847 1
a847 1
                tex->tex.stride_in_bytes[0], false);
a860 3
        if (!state->cbufs[i])
            continue;

d953 1
a953 2
        if (fb->cbufs[i])
            num_samples = MIN2(num_samples, fb->cbufs[i]->texture->nr_samples);
d970 1
a970 1
    struct pipe_framebuffer_state *current_state = r300->fb_state.state;
d989 1
a989 1
    if (current_state->zsbuf && r300->zmask_in_use && !r300->locked_zbuffer) {
d992 1
a992 1
            if (!pipe_surface_equal(current_state->zsbuf, state->zsbuf)) {
d999 1
a999 1
            pipe_surface_reference(&r300->locked_zbuffer, current_state->zsbuf);
a1016 11
    /* If zsbuf is set from NULL to non-NULL or vice versa.. */
    if (!!current_state->zsbuf != !!state->zsbuf) {
        r300_mark_atom_dirty(r300, &r300->dsa_state);
    }

    util_copy_framebuffer_state(r300->fb_state.state, state);

    /* Remove trailing NULL colorbuffers. */
    while (current_state->nr_cbufs && !current_state->cbufs[current_state->nr_cbufs-1])
        current_state->nr_cbufs--;

d1019 1
a1019 1
        state->nr_cbufs == 1 && state->cbufs[0] &&
d1028 5
d1040 2
d1092 1
a1092 2
            if (state->cbufs[i])
                r300_print_fb_surf_info(state->cbufs[i], i, "CB");
d1526 1
a1526 2
                                     unsigned shader,
                                     unsigned start, unsigned count,
d1534 3
a1536 7
    assert(start == 0);

    if (shader != PIPE_SHADER_FRAGMENT)
       return;

    if (count > tex_units)
       return;
d1544 6
d1580 3
a1582 3
static void r300_set_sampler_views(struct pipe_context* pipe, unsigned shader,
                                   unsigned start, unsigned count,
                                   struct pipe_sampler_view** views)
a1591 5
    if (shader != PIPE_SHADER_FRAGMENT)
       return;

    assert(start == 0);  /* non-zero not handled yet */

a2127 4
static void r300_memory_barrier(struct pipe_context *pipe, unsigned flags)
{
}

d2160 2
a2161 1
    r300->context.bind_sampler_states = r300_bind_sampler_states;
d2164 1
a2164 1
    r300->context.set_sampler_views = r300_set_sampler_views;
a2188 1
    r300->context.memory_barrier = r300_memory_barrier;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d945 24
d1076 1
a1076 1
    r300->num_samples = util_framebuffer_get_num_samples(state);
a1416 1
    boolean last_clip_halfz = r300->clip_halfz;
a1427 1
        r300->clip_halfz = rs->rs.clip_halfz;
a1433 1
        r300->clip_halfz = FALSE;
a1453 4
    }

    if (r300->screen->caps.has_tcl && last_clip_halfz != r300->clip_halfz) {
        r300_mark_atom_dirty(r300, &r300->vs_state);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a944 24
static unsigned r300_get_num_samples(struct r300_context *r300)
{
    struct pipe_framebuffer_state* fb =
            (struct pipe_framebuffer_state*)r300->fb_state.state;
    unsigned i, num_samples;

    if (!fb->nr_cbufs && !fb->zsbuf)
        return 1;

    num_samples = 6;

    for (i = 0; i < fb->nr_cbufs; i++)
        if (fb->cbufs[i])
            num_samples = MIN2(num_samples, fb->cbufs[i]->texture->nr_samples);

    if (fb->zsbuf)
        num_samples = MIN2(num_samples, fb->zsbuf->texture->nr_samples);

    if (!num_samples)
        num_samples = 1;

    return num_samples;
}

d1052 1
a1052 1
    r300->num_samples = r300_get_num_samples(r300);
d1393 1
d1405 1
d1412 1
d1433 4
@


