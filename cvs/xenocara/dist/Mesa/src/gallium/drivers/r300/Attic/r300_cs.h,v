head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.57;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.06;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

/**
 * This file contains macros for immediate command submission.
 */

#ifndef R300_CS_H
#define R300_CS_H

#include "r300_reg.h"
#include "r300_context.h"

/* Yes, I know macros are ugly. However, they are much prettier than the code
 * that they neatly hide away, and don't have the cost of function setup,so
 * we're going to use them. */

/**
 * Command submission setup.
 */

#define CS_LOCALS(context) \
    struct radeon_winsys_cs *cs_copy = (context)->cs; \
    struct radeon_winsys *cs_winsys = (context)->rws; \
    int cs_count = 0; (void) cs_count; (void) cs_winsys;

#ifdef DEBUG

#define BEGIN_CS(size) do { \
    assert(size <= (RADEON_MAX_CMDBUF_DWORDS - cs_copy->cdw)); \
    cs_count = size; \
} while (0)

#define END_CS do { \
    if (cs_count != 0) \
        debug_printf("r300: Warning: cs_count off by %d at (%s, %s:%i)\n", \
                     cs_count, __FUNCTION__, __FILE__, __LINE__); \
    cs_count = 0; \
} while (0)

#define CS_USED_DW(x) cs_count -= (x)

#else

#define BEGIN_CS(size)
#define END_CS
#define CS_USED_DW(x)

#endif

/**
 * Writing pure DWORDs.
 */

#define OUT_CS(value) do { \
    cs_copy->buf[cs_copy->cdw++] = (value); \
    CS_USED_DW(1); \
} while (0)

#define OUT_CS_32F(value) \
    OUT_CS(fui(value))

#define OUT_CS_REG(register, value) do { \
    OUT_CS(CP_PACKET0(register, 0)); \
    OUT_CS(value); \
} while (0)

/* Note: This expects count to be the number of registers,
 * not the actual packet0 count! */
#define OUT_CS_REG_SEQ(register, count) \
    OUT_CS(CP_PACKET0((register), ((count) - 1)))

#define OUT_CS_ONE_REG(register, count) \
    OUT_CS(CP_PACKET0((register), ((count) - 1)) | RADEON_ONE_REG_WR)

#define OUT_CS_PKT3(op, count) \
    OUT_CS(CP_PACKET3(op, count))

#define OUT_CS_TABLE(values, count) do { \
    memcpy(cs_copy->buf + cs_copy->cdw, (values), (count) * 4); \
    cs_copy->cdw += (count); \
    CS_USED_DW(count); \
} while (0)


/**
 * Writing relocations.
 */

#define OUT_CS_RELOC(r) do { \
    assert((r)); \
    assert((r)->cs_buf); \
    OUT_CS(0xc0001000); /* PKT3_NOP */ \
    OUT_CS(cs_winsys->cs_get_reloc(cs_copy, (r)->cs_buf) * 4); \
} while (0)


/**
 * Command buffer emission.
 */

#define WRITE_CS_TABLE(values, count) do { \
    assert(cs_count == 0); \
    memcpy(cs_copy->buf + cs_copy->cdw, (values), (count) * 4); \
    cs_copy->cdw += (count); \
} while (0)

#endif /* R300_CS_H */
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d112 2
a113 2
    cs_winsys->cs_write_reloc(cs_copy, (r)->cs_buf); \
    CS_USED_DW(2); \
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d99 2
a100 2
    memcpy(cs_copy->buf + cs_copy->cdw, values, count * 4); \
    cs_copy->cdw += count; \
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a31 1
#include "r300_winsys.h"
a36 6
#ifdef DEBUG
#define CS_DEBUG(x) x
#else
#define CS_DEBUG(x)
#endif

d42 2
a43 2
    struct r300_winsys_cs *cs_copy = (context)->cs; \
    struct r300_winsys_screen *cs_winsys = (context)->rws; \
d46 2
d49 2
a50 2
    assert(size <= (R300_MAX_CMDBUF_DWORDS - cs_copy->cdw)); \
    CS_DEBUG(cs_count = size;) \
a52 1
#ifdef DEBUG
d59 3
d63 2
d66 2
a69 1

d76 1
a76 1
    CS_DEBUG(cs_count--;) \
d101 1
a101 1
    CS_DEBUG(cs_count -= count;) \
d109 5
a113 21
#define OUT_CS_RELOC(bo, offset, rd, wd) do { \
    assert(bo); \
    OUT_CS(offset); \
    cs_winsys->cs_write_reloc(cs_copy, bo, rd, wd); \
    CS_DEBUG(cs_count -= 2;) \
} while (0)

#define OUT_CS_BUF_RELOC(bo, offset, rd, wd) do { \
    assert(bo); \
    OUT_CS_RELOC(r300_buffer(bo)->cs_buf, offset, rd, wd); \
} while (0)

#define OUT_CS_TEX_RELOC(tex, offset, rd, wd) do { \
    assert(tex); \
    OUT_CS_RELOC(tex->cs_buffer, offset, rd, wd); \
} while (0)

#define OUT_CS_BUF_RELOC_NO_OFFSET(bo, rd, wd) do { \
    assert(bo); \
    cs_winsys->cs_write_reloc(cs_copy, r300_buffer(bo)->cs_buf, rd, wd); \
    CS_DEBUG(cs_count -= 2;) \
d122 1
a122 1
    CS_DEBUG(assert(cs_count == 0);) \
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d23 4
a29 2
#include "util/u_math.h"

d31 2
a32 2

#include "radeon_winsys.h"
d38 9
a46 1
#define MAX_CS_SIZE 64 * 1024 / 4
d48 4
a51 2
#define VERY_VERBOSE_CS 1
#define VERY_VERBOSE_REGISTERS 1
d53 4
a56 4
/* XXX stolen from radeon_drm.h */
#define RADEON_GEM_DOMAIN_CPU  0x1
#define RADEON_GEM_DOMAIN_GTT  0x2
#define RADEON_GEM_DOMAIN_VRAM 0x4
d58 10
a67 5
/* XXX stolen from radeon_reg.h */
#define RADEON_CP_PACKET0 0x0

#define CP_PACKET0(register, count) \
    (RADEON_CP_PACKET0 | ((count) << 16) | ((register) >> 2))
a68 4
#define CS_LOCALS(context) \
    struct r300_context* const cs_context_copy = (context); \
    struct radeon_winsys* cs_winsys = cs_context_copy->winsys; \
    int cs_count = 0; (void) cs_count;
d70 3
a72 13
#define CHECK_CS(size) \
    assert(cs_winsys->check_cs(cs_winsys, (size)))

#define BEGIN_CS(size) do { \
    CHECK_CS(size); \
    if (VERY_VERBOSE_CS) { \
        DBG(cs_context_copy, DBG_CS, "r300: BEGIN_CS, count %d, in %s (%s:%d)\n", \
                size, __FUNCTION__, __FILE__, __LINE__); \
    } \
    cs_winsys->begin_cs(cs_winsys, (size), \
            __FILE__, __FUNCTION__, __LINE__); \
    cs_count = size; \
} while (0)
d75 2
a76 5
    if (VERY_VERBOSE_CS || VERY_VERBOSE_REGISTERS) { \
        DBG(cs_context_copy, DBG_CS, "r300: writing %08x\n", value); \
    } \
    cs_winsys->write_cs_dword(cs_winsys, (value)); \
    cs_count--; \
d79 2
a80 7
#define OUT_CS_32F(value) do { \
    if (VERY_VERBOSE_CS || VERY_VERBOSE_REGISTERS) { \
        DBG(cs_context_copy, DBG_CS, "r300: writing %f\n", value); \
    } \
    cs_winsys->write_cs_dword(cs_winsys, fui(value)); \
    cs_count--; \
} while (0)
d83 2
a84 7
    if (VERY_VERBOSE_REGISTERS) \
        DBG(cs_context_copy, DBG_CS, "r300: writing 0x%08X to register 0x%04X\n", \
            value, register); \
    assert(register); \
    cs_winsys->write_cs_dword(cs_winsys, CP_PACKET0(register, 0)); \
    cs_winsys->write_cs_dword(cs_winsys, value); \
    cs_count -= 2; \
d89 13
a101 7
#define OUT_CS_REG_SEQ(register, count) do { \
    if (VERY_VERBOSE_REGISTERS) \
        DBG(cs_context_copy, DBG_CS, "r300: writing register sequence of %d to 0x%04X\n", \
            count, register); \
    assert(register); \
    cs_winsys->write_cs_dword(cs_winsys, CP_PACKET0((register), ((count) - 1))); \
    cs_count--; \
d104 6
a109 4
#define OUT_CS_RELOC(bo, offset, rd, wd, flags) do { \
    DBG(cs_context_copy, DBG_CS, "r300: writing relocation for buffer %p, offset %d, " \
            "domains (%d, %d, %d)\n", \
        bo, offset, rd, wd, flags); \
d111 3
a113 3
    cs_winsys->write_cs_dword(cs_winsys, offset); \
    cs_winsys->write_cs_reloc(cs_winsys, bo, rd, wd, flags); \
    cs_count -= 3; \
d116 1
a116 4
#define OUT_CS_RELOC_NO_OFFSET(bo, rd, wd, flags) do { \
    DBG(cs_context_copy, DBG_CS, "r300: writing relocation for buffer %p, " \
            "domains (%d, %d, %d)\n", \
        bo, rd, wd, flags); \
d118 1
a118 2
    cs_winsys->write_cs_reloc(cs_winsys, bo, rd, wd, flags); \
    cs_count -= 2; \
d121 3
a123 8
#define END_CS do { \
    if (VERY_VERBOSE_CS) { \
        DBG(cs_context_copy, DBG_CS, "r300: END_CS in %s (%s:%d)\n", __FUNCTION__, \
                __FILE__, __LINE__); \
    } \
    if (cs_count != 0) \
        debug_printf("r300: Warning: cs_count off by %d\n", cs_count); \
    cs_winsys->end_cs(cs_winsys, __FILE__, __FUNCTION__, __LINE__); \
d126 4
a129 17
#define FLUSH_CS do { \
    if (VERY_VERBOSE_CS) { \
        DBG(cs_context_copy, DBG_CS, "r300: FLUSH_CS in %s (%s:%d)\n\n", __FUNCTION__, \
                __FILE__, __LINE__); \
    } \
    cs_winsys->flush_cs(cs_winsys); \
} while (0)

#define RADEON_ONE_REG_WR        (1 << 15)

#define OUT_CS_ONE_REG(register, count) do { \
    if (VERY_VERBOSE_REGISTERS) \
        DBG(cs_context_copy, DBG_CS, "r300: writing data sequence of %d to 0x%04X\n", \
            count, register); \
    assert(register); \
    cs_winsys->write_cs_dword(cs_winsys, CP_PACKET0((register), ((count) - 1)) | RADEON_ONE_REG_WR); \
    cs_count--; \
a131 2
#define CP_PACKET3(op, count) \
    (RADEON_CP_PACKET3 | (op) | ((count) << 16))
d133 3
a135 4
#define OUT_CS_PKT3(op, count) do { \
    cs_winsys->write_cs_dword(cs_winsys, CP_PACKET3(op, count)); \
    cs_count--; \
} while (0)
d137 4
a140 8
#define OUT_CS_INDEX_RELOC(bo, offset, count, rd, wd, flags) do { \
    DBG(cs_context_copy, DBG_CS, "r300: writing relocation for index buffer %p," \
            "offset %d\n", bo, offset); \
    assert(bo); \
    cs_winsys->write_cs_dword(cs_winsys, offset); \
    cs_winsys->write_cs_dword(cs_winsys, count); \
    cs_winsys->write_cs_reloc(cs_winsys, bo, rd, wd, flags); \
    cs_count -= 4; \
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a22 4
/**
 * This file contains macros for immediate command submission.
 */

d26 2
d29 2
a30 2
#include "r300_context.h"
#include "r300_winsys.h"
d36 15
a50 9
#ifdef DEBUG
#define CS_DEBUG(x) x
#else
#define CS_DEBUG(x)
#endif

/**
 * Command submission setup.
 */
d53 6
a58 3
    struct r300_winsys_cs *cs_copy = (context)->cs; \
    struct r300_winsys_screen *cs_winsys = (context)->rws; \
    int cs_count = 0; (void) cs_count; (void) cs_winsys;
d61 8
a68 2
    assert(size <= (R300_MAX_CMDBUF_DWORDS - cs_copy->cdw)); \
    CS_DEBUG(cs_count = size;) \
a70 16
#ifdef DEBUG
#define END_CS do { \
    if (cs_count != 0) \
        debug_printf("r300: Warning: cs_count off by %d at (%s, %s:%i)\n", \
                     cs_count, __FUNCTION__, __FILE__, __LINE__); \
    cs_count = 0; \
} while (0)
#else
#define END_CS
#endif


/**
 * Writing pure DWORDs.
 */

d72 5
a76 2
    cs_copy->buf[cs_copy->cdw++] = (value); \
    CS_DEBUG(cs_count--;) \
d79 7
a85 2
#define OUT_CS_32F(value) \
    OUT_CS(fui(value))
d88 7
a94 2
    OUT_CS(CP_PACKET0(register, 0)); \
    OUT_CS(value); \
d99 8
a106 2
#define OUT_CS_REG_SEQ(register, count) \
    OUT_CS(CP_PACKET0((register), ((count) - 1)))
d108 8
a115 10
#define OUT_CS_ONE_REG(register, count) \
    OUT_CS(CP_PACKET0((register), ((count) - 1)) | RADEON_ONE_REG_WR)

#define OUT_CS_PKT3(op, count) \
    OUT_CS(CP_PACKET3(op, count))

#define OUT_CS_TABLE(values, count) do { \
    memcpy(cs_copy->buf + cs_copy->cdw, values, count * 4); \
    cs_copy->cdw += count; \
    CS_DEBUG(cs_count -= count;) \
d118 4
a121 6

/**
 * Writing relocations.
 */

#define OUT_CS_RELOC(bo, offset, rd, wd) do { \
d123 2
a124 3
    OUT_CS(offset); \
    cs_winsys->cs_write_reloc(cs_copy, bo, rd, wd); \
    CS_DEBUG(cs_count -= 2;) \
d127 8
a134 3
#define OUT_CS_BUF_RELOC(bo, offset, rd, wd) do { \
    assert(bo); \
    OUT_CS_RELOC(r300_buffer(bo)->cs_buf, offset, rd, wd); \
d137 6
a142 3
#define OUT_CS_TEX_RELOC(tex, offset, rd, wd) do { \
    assert(tex); \
    OUT_CS_RELOC(tex->cs_buffer, offset, rd, wd); \
d145 9
a153 4
#define OUT_CS_BUF_RELOC_NO_OFFSET(bo, rd, wd) do { \
    assert(bo); \
    cs_winsys->cs_write_reloc(cs_copy, r300_buffer(bo)->cs_buf, rd, wd); \
    CS_DEBUG(cs_count -= 2;) \
d156 2
d159 4
a162 3
/**
 * Command buffer emission.
 */
d164 8
a171 4
#define WRITE_CS_TABLE(values, count) do { \
    CS_DEBUG(assert(cs_count == 0);) \
    memcpy(cs_copy->buf + cs_copy->cdw, (values), (count) * 4); \
    cs_copy->cdw += (count); \
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d32 1
d38 6
d49 2
a50 2
    struct radeon_winsys_cs *cs_copy = (context)->cs; \
    struct radeon_winsys *cs_winsys = (context)->rws; \
a52 2
#ifdef DEBUG

d54 2
a55 2
    assert(size <= (RADEON_MAX_CMDBUF_DWORDS - cs_copy->cdw)); \
    cs_count = size; \
d58 1
a64 3

#define CS_USED_DW(x) cs_count -= (x)

a65 2

#define BEGIN_CS(size)
d67 1
a67 1
#define CS_USED_DW(x)
a68 1
#endif
d76 1
a76 1
    CS_USED_DW(1); \
d99 3
a101 3
    memcpy(cs_copy->buf + cs_copy->cdw, (values), (count) * 4); \
    cs_copy->cdw += (count); \
    CS_USED_DW(count); \
d109 21
a129 5
#define OUT_CS_RELOC(r) do { \
    assert((r)); \
    assert((r)->cs_buf); \
    cs_winsys->cs_write_reloc(cs_copy, (r)->cs_buf); \
    CS_USED_DW(2); \
d138 1
a138 1
    assert(cs_count == 0); \
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d112 2
a113 2
    OUT_CS(0xc0001000); /* PKT3_NOP */ \
    OUT_CS(cs_winsys->cs_get_reloc(cs_copy, (r)->cs_buf) * 4); \
@


