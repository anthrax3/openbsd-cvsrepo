head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.32;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.22.09.30.33;	author jsg;	state Exp;
branches;
next	1.7;
commitid	yhStanAcs6cSYmBc;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.58;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.01;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.07;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.04;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.45.14;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@@gmail.com>
 * Copyright 2010 Marek Olšák <maraeo@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "util/u_format.h"
#include "util/u_format_s3tc.h"
#include "util/u_memory.h"
#include "os/os_time.h"
#include "vl/vl_decoder.h"
#include "vl/vl_video_buffer.h"

#include "r300_context.h"
#include "r300_texture.h"
#include "r300_screen_buffer.h"
#include "r300_state_inlines.h"
#include "r300_public.h"

#include "draw/draw_context.h"

/* Return the identifier behind whom the brave coders responsible for this
 * amalgamation of code, sweat, and duct tape, routinely obscure their names.
 *
 * ...I should have just put "Corbin Simpson", but I'm not that cool.
 *
 * (Or egotistical. Yet.) */
static const char* r300_get_vendor(struct pipe_screen* pscreen)
{
    return "X.Org R300 Project";
}

static const char* chip_families[] = {
    "unknown",
    "ATI R300",
    "ATI R350",
    "ATI RV350",
    "ATI RV370",
    "ATI RV380",
    "ATI RS400",
    "ATI RC410",
    "ATI RS480",
    "ATI R420",
    "ATI R423",
    "ATI R430",
    "ATI R480",
    "ATI R481",
    "ATI RV410",
    "ATI RS600",
    "ATI RS690",
    "ATI RS740",
    "ATI RV515",
    "ATI R520",
    "ATI RV530",
    "ATI R580",
    "ATI RV560",
    "ATI RV570"
};

static const char* r300_get_name(struct pipe_screen* pscreen)
{
    struct r300_screen* r300screen = r300_screen(pscreen);

    return chip_families[r300screen->caps.family];
}

static int r300_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
{
    struct r300_screen* r300screen = r300_screen(pscreen);
    boolean is_r500 = r300screen->caps.is_r500;

    switch (param) {
        /* Supported features (boolean caps). */
        case PIPE_CAP_NPOT_TEXTURES:
        case PIPE_CAP_MIXED_FRAMEBUFFER_SIZES:
        case PIPE_CAP_TWO_SIDED_STENCIL:
        case PIPE_CAP_ANISOTROPIC_FILTER:
        case PIPE_CAP_POINT_SPRITE:
        case PIPE_CAP_OCCLUSION_QUERY:
        case PIPE_CAP_TEXTURE_SHADOW_MAP:
        case PIPE_CAP_TEXTURE_MIRROR_CLAMP:
        case PIPE_CAP_BLEND_EQUATION_SEPARATE:
        case PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR:
        case PIPE_CAP_TGSI_FS_COORD_ORIGIN_UPPER_LEFT:
        case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
        case PIPE_CAP_CONDITIONAL_RENDER:
        case PIPE_CAP_TEXTURE_BARRIER:
        case PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS:
        case PIPE_CAP_USER_INDEX_BUFFERS:
        case PIPE_CAP_USER_CONSTANT_BUFFERS:
        case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
        case PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT:
            return 1;

        case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
            return R300_BUFFER_ALIGNMENT;

        case PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT:
            return 16;

        case PIPE_CAP_GLSL_FEATURE_LEVEL:
            return 120;

        /* r300 cannot do swizzling of compressed textures. Supported otherwise. */
        case PIPE_CAP_TEXTURE_SWIZZLE:
            return util_format_s3tc_enabled ? r300screen->caps.dxtc_swizzle : 1;

        /* We don't support color clamping on r500, so that we can use color
         * intepolators for generic varyings. */
        case PIPE_CAP_VERTEX_COLOR_CLAMPED:
            return !is_r500;

        /* Supported on r500 only. */
        case PIPE_CAP_VERTEX_COLOR_UNCLAMPED:
        case PIPE_CAP_MIXED_COLORBUFFER_FORMATS:
        case PIPE_CAP_SM3:
            return is_r500 ? 1 : 0;

        /* Unsupported features. */
        case PIPE_CAP_QUERY_TIME_ELAPSED:
        case PIPE_CAP_QUERY_PIPELINE_STATISTICS:
        case PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS:
        case PIPE_CAP_INDEP_BLEND_ENABLE:
        case PIPE_CAP_INDEP_BLEND_FUNC:
        case PIPE_CAP_DEPTH_CLIP_DISABLE:
        case PIPE_CAP_SHADER_STENCIL_EXPORT:
        case PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS:
        case PIPE_CAP_TGSI_INSTANCEID:
        case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
        case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
        case PIPE_CAP_SEAMLESS_CUBE_MAP:
        case PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE:
        case PIPE_CAP_MIN_TEXEL_OFFSET:
        case PIPE_CAP_MAX_TEXEL_OFFSET:
        case PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET:
        case PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET:
        case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
        case PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS:
        case PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS:
        case PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES:
        case PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS:
        case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
        case PIPE_CAP_FRAGMENT_COLOR_CLAMPED:
        case PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION:
        case PIPE_CAP_COMPUTE:
        case PIPE_CAP_START_INSTANCE:
        case PIPE_CAP_QUERY_TIMESTAMP:
        case PIPE_CAP_TEXTURE_MULTISAMPLE:
        case PIPE_CAP_CUBE_MAP_ARRAY:
        case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
        case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
        case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
        case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
        case PIPE_CAP_TGSI_VS_LAYER:
        case PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS:
        case PIPE_CAP_TEXTURE_GATHER_SM5:
        case PIPE_CAP_TEXTURE_QUERY_LOD:
        case PIPE_CAP_FAKE_SW_MSAA:
        case PIPE_CAP_SAMPLE_SHADING:
            return 0;

        /* SWTCL-only features. */
        case PIPE_CAP_PRIMITIVE_RESTART:
        case PIPE_CAP_USER_VERTEX_BUFFERS:
            return !r300screen->caps.has_tcl;

        /* HWTCL-only features / limitations. */
        case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
        case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
        case PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY:
            return r300screen->caps.has_tcl;
	case PIPE_CAP_TGSI_TEXCOORD:
            return 0;

        /* Texturing. */
        case PIPE_CAP_MAX_TEXTURE_2D_LEVELS:
        case PIPE_CAP_MAX_TEXTURE_3D_LEVELS:
        case PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS:
            /* 13 == 4096, 12 == 2048 */
            return is_r500 ? 13 : 12;

        /* Render targets. */
        case PIPE_CAP_MAX_RENDER_TARGETS:
            return 4;
	case PIPE_CAP_ENDIANNESS:
            return PIPE_ENDIAN_LITTLE;

        case PIPE_CAP_MAX_VIEWPORTS:
            return 1;

        case PIPE_CAP_VENDOR_ID:
                return 0x1002;
        case PIPE_CAP_DEVICE_ID:
                return r300screen->info.pci_id;
        case PIPE_CAP_ACCELERATED:
                return 1;
        case PIPE_CAP_VIDEO_MEMORY:
                return r300screen->info.vram_size >> 20;
        case PIPE_CAP_UMA:
                return 0;
    }
    return 0;
}

static int r300_get_shader_param(struct pipe_screen *pscreen, unsigned shader, enum pipe_shader_cap param)
{
   struct r300_screen* r300screen = r300_screen(pscreen);
   boolean is_r400 = r300screen->caps.is_r400;
   boolean is_r500 = r300screen->caps.is_r500;

   switch (shader) {
    case PIPE_SHADER_FRAGMENT:
        switch (param)
        {
        case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
            return is_r500 || is_r400 ? 512 : 96;
        case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
            return is_r500 || is_r400 ? 512 : 64;
        case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
            return is_r500 || is_r400 ? 512 : 32;
        case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
            return is_r500 ? 511 : 4;
        case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
            return is_r500 ? 64 : 0; /* Actually unlimited on r500. */
            /* Fragment shader limits. */
        case PIPE_SHADER_CAP_MAX_INPUTS:
            /* 2 colors + 8 texcoords are always supported
             * (minus fog and wpos).
             *
             * R500 has the ability to turn 3rd and 4th color into
             * additional texcoords but there is no two-sided color
             * selection then. However the facing bit can be used instead. */
            return 10;
        case PIPE_SHADER_CAP_MAX_CONSTS:
            return is_r500 ? 256 : 32;
        case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
            return 1;
        case PIPE_SHADER_CAP_MAX_TEMPS:
            return is_r500 ? 128 : is_r400 ? 64 : 32;
        case PIPE_SHADER_CAP_MAX_PREDS:
            return is_r500 ? 1 : 0;
        case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
        case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
           return r300screen->caps.num_tex_units;
        case PIPE_SHADER_CAP_MAX_ADDRS:
        case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
        case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
        case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
        case PIPE_SHADER_CAP_SUBROUTINES:
        case PIPE_SHADER_CAP_INTEGERS:
            return 0;
        case PIPE_SHADER_CAP_PREFERRED_IR:
            return PIPE_SHADER_IR_TGSI;
        }
        break;
    case PIPE_SHADER_VERTEX:
        switch (param)
        {
        case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
        case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
        case PIPE_SHADER_CAP_SUBROUTINES:
            return 0;
        default:;
        }

        if (!r300screen->caps.has_tcl) {
            return draw_get_shader_param(shader, param);
        }

        switch (param)
        {
        case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
        case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
            return is_r500 ? 1024 : 256;
        case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
            return is_r500 ? 4 : 0; /* For loops; not sure about conditionals. */
        case PIPE_SHADER_CAP_MAX_INPUTS:
            return 16;
        case PIPE_SHADER_CAP_MAX_CONSTS:
            return 256;
        case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
            return 1;
        case PIPE_SHADER_CAP_MAX_TEMPS:
            return 32;
        case PIPE_SHADER_CAP_MAX_ADDRS:
            return 1; /* XXX guessed */
        case PIPE_SHADER_CAP_MAX_PREDS:
            return is_r500 ? 4 : 0; /* XXX guessed. */
        case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
            return 1;
        case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
        case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
        case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
        case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
        case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
        case PIPE_SHADER_CAP_SUBROUTINES:
        case PIPE_SHADER_CAP_INTEGERS:
        case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
        case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
            return 0;
        case PIPE_SHADER_CAP_PREFERRED_IR:
            return PIPE_SHADER_IR_TGSI;
        }
        break;
    }
    return 0;
}

static float r300_get_paramf(struct pipe_screen* pscreen,
                             enum pipe_capf param)
{
    struct r300_screen* r300screen = r300_screen(pscreen);

    switch (param) {
        case PIPE_CAPF_MAX_LINE_WIDTH:
        case PIPE_CAPF_MAX_LINE_WIDTH_AA:
        case PIPE_CAPF_MAX_POINT_WIDTH:
        case PIPE_CAPF_MAX_POINT_WIDTH_AA:
            /* The maximum dimensions of the colorbuffer are our practical
             * rendering limits. 2048 pixels should be enough for anybody. */
            if (r300screen->caps.is_r500) {
                return 4096.0f;
            } else if (r300screen->caps.is_r400) {
                return 4021.0f;
            } else {
                return 2560.0f;
            }
        case PIPE_CAPF_MAX_TEXTURE_ANISOTROPY:
            return 16.0f;
        case PIPE_CAPF_MAX_TEXTURE_LOD_BIAS:
            return 16.0f;
        case PIPE_CAPF_GUARD_BAND_LEFT:
        case PIPE_CAPF_GUARD_BAND_TOP:
        case PIPE_CAPF_GUARD_BAND_RIGHT:
        case PIPE_CAPF_GUARD_BAND_BOTTOM:
            /* XXX I don't know what these should be but the least we can do is
             * silence the potential error message */
            return 0.0f;
        default:
            debug_printf("r300: Warning: Unknown CAP %d in get_paramf.\n",
                         param);
            return 0.0f;
    }
}

static int r300_get_video_param(struct pipe_screen *screen,
				enum pipe_video_profile profile,
				enum pipe_video_entrypoint entrypoint,
				enum pipe_video_cap param)
{
   switch (param) {
      case PIPE_VIDEO_CAP_SUPPORTED:
         return vl_profile_supported(screen, profile, entrypoint);
      case PIPE_VIDEO_CAP_NPOT_TEXTURES:
         return 0;
      case PIPE_VIDEO_CAP_MAX_WIDTH:
      case PIPE_VIDEO_CAP_MAX_HEIGHT:
         return vl_video_buffer_max_size(screen);
      case PIPE_VIDEO_CAP_PREFERED_FORMAT:
         return PIPE_FORMAT_NV12;
      case PIPE_VIDEO_CAP_PREFERS_INTERLACED:
         return false;
      case PIPE_VIDEO_CAP_SUPPORTS_INTERLACED:
         return false;
      case PIPE_VIDEO_CAP_SUPPORTS_PROGRESSIVE:
         return true;
      case PIPE_VIDEO_CAP_MAX_LEVEL:
         return vl_level_supported(screen, profile);
      default:
         return 0;
   }
}

/**
 * Whether the format matches:
 *   PIPE_FORMAT_?10?10?10?2_UNORM
 */
static INLINE boolean
util_format_is_rgba1010102_variant(const struct util_format_description *desc)
{
   static const unsigned size[4] = {10, 10, 10, 2};
   unsigned chan;

   if (desc->block.width != 1 ||
       desc->block.height != 1 ||
       desc->block.bits != 32)
      return FALSE;

   for (chan = 0; chan < 4; ++chan) {
      if(desc->channel[chan].type != UTIL_FORMAT_TYPE_UNSIGNED &&
         desc->channel[chan].type != UTIL_FORMAT_TYPE_VOID)
         return FALSE;
      if (desc->channel[chan].size != size[chan])
         return FALSE;
   }

   return TRUE;
}

static boolean r300_is_format_supported(struct pipe_screen* screen,
                                        enum pipe_format format,
                                        enum pipe_texture_target target,
                                        unsigned sample_count,
                                        unsigned usage)
{
    uint32_t retval = 0;
    boolean drm_2_8_0 = r300_screen(screen)->info.drm_minor >= 8;
    boolean is_r500 = r300_screen(screen)->caps.is_r500;
    boolean is_r400 = r300_screen(screen)->caps.is_r400;
    boolean is_color2101010 = format == PIPE_FORMAT_R10G10B10A2_UNORM ||
                              format == PIPE_FORMAT_R10G10B10X2_SNORM ||
                              format == PIPE_FORMAT_B10G10R10A2_UNORM ||
                              format == PIPE_FORMAT_R10SG10SB10SA2U_NORM;
    boolean is_ati1n = format == PIPE_FORMAT_RGTC1_UNORM ||
                       format == PIPE_FORMAT_RGTC1_SNORM ||
                       format == PIPE_FORMAT_LATC1_UNORM ||
                       format == PIPE_FORMAT_LATC1_SNORM;
    boolean is_ati2n = format == PIPE_FORMAT_RGTC2_UNORM ||
                       format == PIPE_FORMAT_RGTC2_SNORM ||
                       format == PIPE_FORMAT_LATC2_UNORM ||
                       format == PIPE_FORMAT_LATC2_SNORM;
    boolean is_x16f_xy16f = format == PIPE_FORMAT_R16_FLOAT ||
                            format == PIPE_FORMAT_R16G16_FLOAT ||
                            format == PIPE_FORMAT_A16_FLOAT ||
                            format == PIPE_FORMAT_L16_FLOAT ||
                            format == PIPE_FORMAT_L16A16_FLOAT ||
                            format == PIPE_FORMAT_R16A16_FLOAT ||
                            format == PIPE_FORMAT_I16_FLOAT;
    boolean is_half_float = format == PIPE_FORMAT_R16_FLOAT ||
                            format == PIPE_FORMAT_R16G16_FLOAT ||
                            format == PIPE_FORMAT_R16G16B16_FLOAT ||
                            format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
                            format == PIPE_FORMAT_R16G16B16X16_FLOAT;
    const struct util_format_description *desc;

    if (!util_format_is_supported(format, usage))
       return FALSE;

    /* Check multisampling support. */
    switch (sample_count) {
        case 0:
        case 1:
            break;
        case 2:
        case 4:
        case 6:
            /* We need DRM 2.8.0. */
            if (!drm_2_8_0) {
                return FALSE;
            }
            /* No texturing and scanout. */
            if (usage & (PIPE_BIND_SAMPLER_VIEW |
                         PIPE_BIND_DISPLAY_TARGET |
                         PIPE_BIND_SCANOUT)) {
                return FALSE;
            }

            desc = util_format_description(format);

            if (is_r500) {
                /* Only allow depth/stencil, RGBA8, RGBA1010102, RGBA16F. */
                if (!util_format_is_depth_or_stencil(format) &&
                    !util_format_is_rgba8_variant(desc) &&
                    !util_format_is_rgba1010102_variant(desc) &&
                    format != PIPE_FORMAT_R16G16B16A16_FLOAT &&
                    format != PIPE_FORMAT_R16G16B16X16_FLOAT) {
                    return FALSE;
                }
            } else {
                /* Only allow depth/stencil, RGBA8. */
                if (!util_format_is_depth_or_stencil(format) &&
                    !util_format_is_rgba8_variant(desc)) {
                    return FALSE;
                }
            }
            break;
        default:
            return FALSE;
    }

    /* Check sampler format support. */
    if ((usage & PIPE_BIND_SAMPLER_VIEW) &&
        /* these two are broken for an unknown reason */
        format != PIPE_FORMAT_R8G8B8X8_SNORM &&
        format != PIPE_FORMAT_R16G16B16X16_SNORM &&
        /* ATI1N is r5xx-only. */
        (is_r500 || !is_ati1n) &&
        /* ATI2N is supported on r4xx-r5xx. */
        (is_r400 || is_r500 || !is_ati2n) &&
        /* R16F and RG16F texture support was added in as late as DRM 2.8.0 */
        (drm_2_8_0 || !is_x16f_xy16f) &&
        r300_is_sampler_format_supported(format)) {
        retval |= PIPE_BIND_SAMPLER_VIEW;
    }

    /* Check colorbuffer format support. */
    if ((usage & (PIPE_BIND_RENDER_TARGET |
                  PIPE_BIND_DISPLAY_TARGET |
                  PIPE_BIND_SCANOUT |
                  PIPE_BIND_SHARED)) &&
        /* 2101010 cannot be rendered to on non-r5xx. */
        (!is_color2101010 || (is_r500 && drm_2_8_0)) &&
        r300_is_colorbuffer_format_supported(format)) {
        retval |= usage &
            (PIPE_BIND_RENDER_TARGET |
             PIPE_BIND_DISPLAY_TARGET |
             PIPE_BIND_SCANOUT |
             PIPE_BIND_SHARED);
    }

    /* Check depth-stencil format support. */
    if (usage & PIPE_BIND_DEPTH_STENCIL &&
        r300_is_zs_format_supported(format)) {
        retval |= PIPE_BIND_DEPTH_STENCIL;
    }

    /* Check vertex buffer format support. */
    if (usage & PIPE_BIND_VERTEX_BUFFER) {
        if (r300_screen(screen)->caps.has_tcl) {
            /* Half float is supported on >= R400. */
            if ((is_r400 || is_r500 || !is_half_float) &&
                r300_translate_vertex_data_type(format) != R300_INVALID_FORMAT) {
                retval |= PIPE_BIND_VERTEX_BUFFER;
            }
        } else {
            /* SW TCL */
            if (!util_format_is_pure_integer(format)) {
                retval |= PIPE_BIND_VERTEX_BUFFER;
            }
        }
    }

    /* Transfers are always supported. */
    if (usage & PIPE_BIND_TRANSFER_READ)
        retval |= PIPE_BIND_TRANSFER_READ;
    if (usage & PIPE_BIND_TRANSFER_WRITE)
        retval |= PIPE_BIND_TRANSFER_WRITE;

    return retval == usage;
}

static void r300_destroy_screen(struct pipe_screen* pscreen)
{
    struct r300_screen* r300screen = r300_screen(pscreen);
    struct radeon_winsys *rws = radeon_winsys(pscreen);

    if (rws && !rws->unref(rws))
      return;

    pipe_mutex_destroy(r300screen->cmask_mutex);

    if (rws)
      rws->destroy(rws);

    FREE(r300screen);
}

static void r300_fence_reference(struct pipe_screen *screen,
                                 struct pipe_fence_handle **ptr,
                                 struct pipe_fence_handle *fence)
{
    struct radeon_winsys *rws = r300_screen(screen)->rws;

    rws->fence_reference(ptr, fence);
}

static boolean r300_fence_signalled(struct pipe_screen *screen,
                                    struct pipe_fence_handle *fence)
{
    struct radeon_winsys *rws = r300_screen(screen)->rws;

    return rws->fence_wait(rws, fence, 0);
}

static boolean r300_fence_finish(struct pipe_screen *screen,
                                 struct pipe_fence_handle *fence,
                                 uint64_t timeout)
{
    struct radeon_winsys *rws = r300_screen(screen)->rws;

    return rws->fence_wait(rws, fence, timeout);
}

struct pipe_screen* r300_screen_create(struct radeon_winsys *rws)
{
    struct r300_screen *r300screen = CALLOC_STRUCT(r300_screen);

    if (!r300screen) {
        FREE(r300screen);
        return NULL;
    }

    rws->query_info(rws, &r300screen->info);

    r300_init_debug(r300screen);
    r300_parse_chipset(r300screen->info.pci_id, &r300screen->caps);

    if (SCREEN_DBG_ON(r300screen, DBG_NO_ZMASK))
        r300screen->caps.zmask_ram = 0;
    if (SCREEN_DBG_ON(r300screen, DBG_NO_HIZ))
        r300screen->caps.hiz_ram = 0;

    if (r300screen->info.drm_minor < 8)
        r300screen->caps.has_us_format = FALSE;

    r300screen->rws = rws;
    r300screen->screen.destroy = r300_destroy_screen;
    r300screen->screen.get_name = r300_get_name;
    r300screen->screen.get_vendor = r300_get_vendor;
    r300screen->screen.get_param = r300_get_param;
    r300screen->screen.get_shader_param = r300_get_shader_param;
    r300screen->screen.get_paramf = r300_get_paramf;
    r300screen->screen.get_video_param = r300_get_video_param;
    r300screen->screen.is_format_supported = r300_is_format_supported;
    r300screen->screen.is_video_format_supported = vl_video_buffer_is_format_supported;
    r300screen->screen.context_create = r300_create_context;
    r300screen->screen.fence_reference = r300_fence_reference;
    r300screen->screen.fence_signalled = r300_fence_signalled;
    r300screen->screen.fence_finish = r300_fence_finish;

    r300_init_screen_resource_functions(r300screen);

    util_format_s3tc_init();
    pipe_mutex_init(r300screen->cmask_mutex);

    return &r300screen->screen;
}
@


1.8
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.7
log
@Merge Mesa 10.2.9
@
text
@d207 11
@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a109 1
        case PIPE_CAP_CLIP_HALFZ:
a158 1
        case PIPE_CAP_MAX_VERTEX_STREAMS:
d171 1
a171 1
        case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
a176 6
        case PIPE_CAP_TEXTURE_GATHER_OFFSETS:
        case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
        case PIPE_CAP_DRAW_INDIRECT:
        case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
        case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
        case PIPE_CAP_SAMPLER_VIEW_TARGET:
a206 14

        case PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE:
            return 2048;

        case PIPE_CAP_VENDOR_ID:
                return 0x1002;
        case PIPE_CAP_DEVICE_ID:
                return r300screen->info.pci_id;
        case PIPE_CAP_ACCELERATED:
                return 1;
        case PIPE_CAP_VIDEO_MEMORY:
                return r300screen->info.vram_size >> 20;
        case PIPE_CAP_UMA:
                return 0;
d240 2
a241 4
        case PIPE_SHADER_CAP_MAX_OUTPUTS:
            return 4;
        case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
            return (is_r500 ? 256 : 32) * sizeof(float[4]);
d251 1
a259 1
        case PIPE_SHADER_CAP_DOUBLES:
d288 2
a289 4
        case PIPE_SHADER_CAP_MAX_OUTPUTS:
            return 10;
        case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
            return 256 * sizeof(float[4]);
d294 2
a310 1
        case PIPE_SHADER_CAP_DOUBLES:
a410 38
static bool r300_is_blending_supported(struct r300_screen *rscreen,
                                       enum pipe_format format)
{
    int c;
    const struct util_format_description *desc =
        util_format_description(format);

    if (desc->layout != UTIL_FORMAT_LAYOUT_PLAIN)
        return false;

    c = util_format_get_first_non_void_channel(format);

    /* RGBA16F */
    if (rscreen->caps.is_r500 &&
        desc->nr_channels == 4 &&
        desc->channel[c].size == 16 &&
        desc->channel[c].type == UTIL_FORMAT_TYPE_FLOAT)
        return true;

    if (desc->channel[c].normalized &&
        desc->channel[c].type == UTIL_FORMAT_TYPE_UNSIGNED &&
        desc->channel[c].size >= 4 &&
        desc->channel[c].size <= 10) {
        /* RGB10_A2, RGBA8, RGB5_A1, RGBA4, RGB565 */
        if (desc->nr_channels >= 3)
            return true;

        if (format == PIPE_FORMAT_R8G8_UNORM)
            return true;

        /* R8, I8, L8, A8 */
        if (desc->nr_channels == 1)
            return true;
    }

    return false;
}

a423 1
                              format == PIPE_FORMAT_B10G10R10X2_UNORM ||
d511 1
a511 2
                  PIPE_BIND_SHARED |
                  PIPE_BIND_BLENDABLE)) &&
a519 4

        if (r300_is_blending_supported(r300_screen(screen), format)) {
            retval |= usage & PIPE_BIND_BLENDABLE;
        }
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d110 1
d160 1
d173 1
a173 1
        case PIPE_CAP_TGSI_VS_LAYER:
d179 6
d215 14
d262 4
a265 2
        case PIPE_SHADER_CAP_MAX_CONSTS:
            return is_r500 ? 256 : 32;
a274 1
        case PIPE_SHADER_CAP_MAX_ADDRS:
d283 1
d312 4
a315 2
        case PIPE_SHADER_CAP_MAX_CONSTS:
            return 256;
a319 2
        case PIPE_SHADER_CAP_MAX_ADDRS:
            return 1; /* XXX guessed */
d335 1
d436 38
d487 1
d575 2
a576 1
                  PIPE_BIND_SHARED)) &&
d585 4
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d92 1
d109 1
a149 1
        case PIPE_CAP_SCALED_RESOLVE:
d152 2
d157 2
d171 6
a192 2
        case PIPE_CAP_MAX_COMBINED_SAMPLERS:
            return r300screen->caps.num_tex_units;
d204 3
d249 1
d269 1
d310 1
d359 1
d364 1
a364 1
         return vl_profile_supported(screen, profile);
d378 2
a461 5
            /* Only support R500, because I didn't test older chipsets,
             * but MSAA should work there too. */
            if (!is_r500 && !debug_get_bool_option("RADEON_MSAA", FALSE)) {
                return FALSE;
            }
d558 3
d573 3
a575 2
    pb_reference((struct pb_buffer**)ptr,
                             (struct pb_buffer*)fence);
a581 1
    struct pb_buffer *rfence = (struct pb_buffer*)fence;
d583 1
a583 1
    return !rws->buffer_is_busy(rfence, RADEON_USAGE_READWRITE);
a590 17
    struct pb_buffer *rfence = (struct pb_buffer*)fence;

    if (timeout != PIPE_TIMEOUT_INFINITE) {
        int64_t start_time = os_time_get();

        /* Convert to microseconds. */
        timeout /= 1000;

        /* Wait in a loop. */
        while (rws->buffer_is_busy(rfence, RADEON_USAGE_READWRITE)) {
            if (os_time_get() - start_time >= timeout) {
                return FALSE;
            }
            os_time_sleep(10);
        }
        return TRUE;
    }
d592 1
a592 2
    rws->buffer_wait(rfence, RADEON_USAGE_READWRITE);
    return TRUE;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d28 2
d51 1
a92 16
        case PIPE_CAP_GLSL:
            /* I'll be frank. This is a lie.
             *
             * We don't truly support GLSL on any of this driver's chipsets.
             * To be fair, no chipset supports the full GLSL specification
             * to the best of our knowledge, but some of the less esoteric
             * features are still missing here.
             *
             * Rather than cripple ourselves intentionally, I'm going to set
             * this flag, and as Gallium's interface continues to change, I
             * hope that this single monolithic GLSL enable can slowly get
             * split down into many different pieces and the state tracker
             * will handle fallbacks transparently, like it should.
             *
             * ~ C.
             */
a97 1
        case PIPE_CAP_TEXTURE_MIRROR_REPEAT:
d102 6
d110 9
d123 5
d129 1
a129 1
        case PIPE_CAP_FRAGMENT_COLOR_CLAMP_CONTROL:
d135 3
a137 2
        case PIPE_CAP_TIMER_QUERY:
        case PIPE_CAP_DUAL_SOURCE_BLEND:
d140 1
a140 2
        case PIPE_CAP_DEPTH_CLAMP:
        case PIPE_CAP_DEPTHSTENCIL_CLEAR_SEPARATE:
d142 1
a142 1
        case PIPE_CAP_ARRAY_TEXTURES:
a145 1
        case PIPE_CAP_MAX_VERTEX_TEXTURE_UNITS:
d148 18
a168 1
        case PIPE_CAP_STREAM_OUTPUT:
d170 1
d173 8
a181 1
        case PIPE_CAP_MAX_TEXTURE_IMAGE_UNITS:
d193 2
a194 5

        default:
            debug_printf("r300: Warning: Unknown CAP %d in get_param.\n",
                         param);
            return 0;
d196 1
d205 1
a205 2
   switch (shader)
    {
a233 2
        case PIPE_SHADER_CAP_MAX_ADDRS:
            return 0;
d236 3
d240 1
a240 1
            return 0;
a244 1
            return 0;
d246 1
d248 2
d253 8
a269 3
        case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
        case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
            return 0;
d284 4
d289 1
a289 1
            return 0;
a292 3
            return 0;
        case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
            return 1;
d294 2
d297 2
a298 2
        default:
            break;
a300 2
    default:
        break;
d305 2
a306 1
static float r300_get_paramf(struct pipe_screen* pscreen, enum pipe_cap param)
d311 4
a314 4
        case PIPE_CAP_MAX_LINE_WIDTH:
        case PIPE_CAP_MAX_LINE_WIDTH_AA:
        case PIPE_CAP_MAX_POINT_WIDTH:
        case PIPE_CAP_MAX_POINT_WIDTH_AA:
d324 1
a324 1
        case PIPE_CAP_MAX_TEXTURE_ANISOTROPY:
d326 1
a326 1
        case PIPE_CAP_MAX_TEXTURE_LOD_BIAS:
d328 4
a331 4
        case PIPE_CAP_GUARD_BAND_LEFT:
        case PIPE_CAP_GUARD_BAND_TOP:
        case PIPE_CAP_GUARD_BAND_RIGHT:
        case PIPE_CAP_GUARD_BAND_BOTTOM:
d342 51
a398 1
    struct radeon_winsys *rws = r300_screen(screen)->rws;
d400 1
a400 1
    boolean drm_2_8_0 = rws->get_value(rws, RADEON_VID_DRM_2_8_0);
d420 1
d425 3
a427 1
                            format == PIPE_FORMAT_R16G16B16A16_FLOAT;
a437 1
        case 3:
d440 13
a452 5
            return FALSE;
#if 0
            if (usage != PIPE_BIND_RENDER_TARGET ||
                !util_format_is_rgba8_variant(
                    util_format_description(format))) {
d455 19
a473 1
#endif
d481 3
d516 13
a528 5
    if (usage & PIPE_BIND_VERTEX_BUFFER &&
        /* Half float is supported on >= RV350. */
        (is_r400 || is_r500 || !is_half_float) &&
        r300_translate_vertex_data_type(format) != R300_INVALID_FORMAT) {
        retval |= PIPE_BIND_VERTEX_BUFFER;
d545 1
a545 2
    util_slab_destroy(&r300screen->pool_buffers);
    pipe_mutex_destroy(r300screen->num_contexts_mutex);
d567 1
a567 1
    return !rws->buffer_is_busy(rfence);
d584 1
a584 1
        while (rws->buffer_is_busy(rfence)) {
d593 1
a593 1
    rws->buffer_wait(rfence);
d606 1
a606 3
    r300screen->caps.pci_id = rws->get_value(rws, RADEON_VID_PCI_ID);
    r300screen->caps.num_frag_pipes = rws->get_value(rws, RADEON_VID_R300_GB_PIPES);
    r300screen->caps.num_z_pipes = rws->get_value(rws, RADEON_VID_R300_Z_PIPES);
d609 1
a609 1
    r300_parse_chipset(&r300screen->caps);
d616 1
a616 1
    if (!rws->get_value(rws, RADEON_VID_DRM_2_8_0))
a618 6
    pipe_mutex_init(r300screen->num_contexts_mutex);

    util_slab_create(&r300screen->pool_buffers,
                     sizeof(struct r300_resource), 64,
                     UTIL_SLAB_SINGLETHREADED);

a619 1
    r300screen->screen.winsys = (struct pipe_winsys*)rws;
d626 1
d628 1
a629 1

d637 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d27 1
a32 1
#include "r300_winsys.h"
a36 4
#ifdef HAVE_LLVM
#include "gallivm/lp_bld_init.h"
#endif

a50 1
    "ATI R360",
d54 3
a62 4
    "ATI RS400",
    "ATI RC410",
    "ATI RS480",
    "ATI RS482",
a83 1
    boolean is_r400 = r300screen->caps.is_r400;
a85 3
    /* XXX extended shader capabilities of r400 unimplemented */
    is_r400 = FALSE;

d113 3
d117 2
d122 7
a128 1
        /* Unsupported features (boolean caps). */
d133 1
a133 1
        case PIPE_CAP_DEPTH_CLAMP: /* XXX implemented, but breaks Regnum Online */
d136 10
d148 1
a148 1
            return 0;
a153 2
        case PIPE_CAP_MAX_VERTEX_TEXTURE_UNITS:
            return 0;
a163 10
        /* General shader limits and features. */
        case PIPE_CAP_SM3:
            return is_r500 ? 1 : 0;
        /* Fragment coordinate conventions. */
        case PIPE_CAP_TGSI_FS_COORD_ORIGIN_UPPER_LEFT:
        case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
	    return 1;
        case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
        case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
            return 0;
a176 3
   /* XXX extended shader capabilities of r400 unimplemented */
   is_r400 = FALSE;

d309 1
a309 2
                                        unsigned usage,
                                        unsigned geom_flags)
d311 1
d313 1
d321 3
a323 1
                       format == PIPE_FORMAT_RGTC1_SNORM;
d325 9
a333 1
                       format == PIPE_FORMAT_RGTC2_SNORM;
d339 3
d370 2
d382 1
a382 1
        (is_r500 || !is_color2101010) &&
d417 1
a417 1
    struct r300_winsys_screen *rws = r300_winsys_screen(pscreen);
d420 1
d432 2
a433 7
    struct r300_fence **oldf = (struct r300_fence**)ptr;
    struct r300_fence *newf = (struct r300_fence*)fence;

    if (pipe_reference(&(*oldf)->reference, &newf->reference))
        FREE(*oldf);

    *ptr = fence;
d436 2
a437 3
static int r300_fence_signalled(struct pipe_screen *screen,
                                struct pipe_fence_handle *fence,
                                unsigned flags)
d439 2
a440 1
    struct r300_fence *rfence = (struct r300_fence*)fence;
d442 1
a442 1
    return rfence->signalled ? 0 : 1; /* 0 == success */
d445 25
a469 9
static int r300_fence_finish(struct pipe_screen *screen,
                             struct pipe_fence_handle *fence,
                             unsigned flags)
{
    struct r300_fence *rfence = (struct r300_fence*)fence;

    r300_finish(rfence->ctx);
    rfence->signalled = TRUE;
    return 0; /* 0 == success */
d472 1
a472 1
struct pipe_screen* r300_screen_create(struct r300_winsys_screen *rws)
d481 3
a483 3
    r300screen->caps.pci_id = rws->get_value(rws, R300_VID_PCI_ID);
    r300screen->caps.num_frag_pipes = rws->get_value(rws, R300_VID_GB_PIPES);
    r300screen->caps.num_z_pipes = rws->get_value(rws, R300_VID_Z_PIPES);
d488 9
a496 3
    r300screen->caps.index_bias_supported =
            r300screen->caps.is_r500 &&
            rws->get_value(rws, R300_VID_DRM_2_3_0);
d499 1
a499 1
                     sizeof(struct r300_buffer), 64,
a519 4

#ifdef HAVE_LLVM
    lp_build_init();
#endif
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d3 1
a23 1
#include "util/u_inlines.h"
d25 1
a26 1
#include "util/u_simple_screen.h"
a28 1
#include "r300_screen.h"
d30 6
d37 3
a39 2
#include "radeon_winsys.h"
#include "r300_winsys.h"
d53 25
a77 25
    "R300",
    "R350",
    "R360",
    "RV350",
    "RV370",
    "RV380",
    "R420",
    "R423",
    "R430",
    "R480",
    "R481",
    "RV410",
    "RS400",
    "RC410",
    "RS480",
    "RS482",
    "RS600",
    "RS690",
    "RS740",
    "RV515",
    "R520",
    "RV530",
    "R580",
    "RV560",
    "RV570"
d84 1
a84 1
    return chip_families[r300screen->caps->family];
d87 1
a87 1
static int r300_get_param(struct pipe_screen* pscreen, int param)
d90 5
d97 1
a97 4
        case PIPE_CAP_MAX_TEXTURE_IMAGE_UNITS:
        case PIPE_CAP_MAX_COMBINED_SAMPLERS:
            /* XXX I'm told this goes up to 16 */
            return 8;
a98 3
            /* XXX enable now to get GL2.1 API,
             * figure out later how to emulate this */
            return 1;
a99 5
            if (r300screen->caps->is_r500) {
                return 1;
            } else {
                return 0;
            }
a115 3
            return 1;
        case PIPE_CAP_DUAL_SOURCE_BLEND:
            return 0;
a116 1
            return 1;
a117 3
            return 1;
        case PIPE_CAP_MAX_RENDER_TARGETS:
            return 4;
a118 1
            return 1;
a119 11
            return 1;
        case PIPE_CAP_MAX_TEXTURE_2D_LEVELS:
        case PIPE_CAP_MAX_TEXTURE_3D_LEVELS:
        case PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS:
            if (r300screen->caps->is_r500) {
                /* 13 == 4096 */
                return 13;
            } else {
                /* 12 == 2048 */
                return 12;
            }
a120 1
            return 1;
a121 5
            return 1;
        case PIPE_CAP_MAX_VERTEX_TEXTURE_UNITS:
            return 0;
        case PIPE_CAP_TGSI_CONT_SUPPORTED:
            return 0;
d124 6
a129 10
        case PIPE_CAP_SM3:
            if (r300screen->caps->is_r500) {
                return 1;
            } else {
                return 0;
            }
        case PIPE_CAP_MAX_CONST_BUFFERS:
            return 1;
        case PIPE_CAP_MAX_CONST_BUFFER_SIZE:
            return 256;
d131 6
d138 6
a143 1
        case PIPE_CAP_INDEP_BLEND_FUNC:
d145 14
d166 57
a222 2
            debug_printf("r300: Implementation error: Bad param %d\n",
                param);
d224 45
d270 1
d273 1
a273 1
static float r300_get_paramf(struct pipe_screen* pscreen, int param)
d284 1
a284 1
            if (r300screen->caps->is_r500) {
d286 1
a286 1
            } else if (r300screen->caps->is_r400) {
d295 7
d303 2
a304 2
            debug_printf("r300: Implementation error: Bad paramf %d\n",
                param);
d312 1
d317 35
a351 9
    boolean is_r500 = r300_screen(screen)->caps->is_r500;
    boolean is_z24 = format == PIPE_FORMAT_X8Z24_UNORM ||
                     format == PIPE_FORMAT_S8Z24_UNORM;
    boolean is_color2101010 = format == PIPE_FORMAT_R10G10B10A2_UNORM;

    if (target >= PIPE_MAX_TEXTURE_TYPES) {
        debug_printf("r300: Implementation error: Received bogus texture "
            "target %d in %s\n", target, __FUNCTION__);
        return FALSE;
d355 5
a359 3
    if ((usage & PIPE_TEXTURE_USAGE_SAMPLER) &&
        /* Z24 cannot be sampled from on non-r5xx. */
        (is_r500 || !is_z24) &&
d361 1
a361 1
        retval |= PIPE_TEXTURE_USAGE_SAMPLER;
d365 4
a368 3
    if ((usage & (PIPE_TEXTURE_USAGE_RENDER_TARGET |
                  PIPE_TEXTURE_USAGE_DISPLAY_TARGET |
                  PIPE_TEXTURE_USAGE_PRIMARY)) &&
d373 4
a376 3
            (PIPE_TEXTURE_USAGE_RENDER_TARGET |
             PIPE_TEXTURE_USAGE_DISPLAY_TARGET |
             PIPE_TEXTURE_USAGE_PRIMARY);
d380 1
a380 1
    if (usage & PIPE_TEXTURE_USAGE_DEPTH_STENCIL &&
d382 1
a382 1
        retval |= PIPE_TEXTURE_USAGE_DEPTH_STENCIL;
d385 14
d402 6
a407 25
static struct pipe_transfer*
r300_get_tex_transfer(struct pipe_screen *screen,
                      struct pipe_texture *texture,
                      unsigned face, unsigned level, unsigned zslice,
                      enum pipe_transfer_usage usage, unsigned x, unsigned y,
                      unsigned w, unsigned h)
{
    struct r300_texture *tex = (struct r300_texture *)texture;
    struct r300_transfer *trans;
    struct r300_screen *rscreen = r300_screen(screen);
    unsigned offset;

    offset = r300_texture_get_offset(tex, level, zslice, face);  /* in bytes */

    trans = CALLOC_STRUCT(r300_transfer);
    if (trans) {
        pipe_texture_reference(&trans->transfer.texture, texture);
        trans->transfer.x = x;
        trans->transfer.y = y;
        trans->transfer.width = w;
        trans->transfer.height = h;
        trans->transfer.stride = r300_texture_get_stride(rscreen, tex, level);
        trans->transfer.usage = usage;
        trans->transfer.zslice = zslice;
        trans->transfer.face = face;
d409 2
a410 4
        trans->offset = offset;
    }
    return &trans->transfer;
}
d412 1
a412 5
static void
r300_tex_transfer_destroy(struct pipe_transfer *trans)
{
   pipe_texture_reference(&trans->texture, NULL);
   FREE(trans);
d415 3
a417 2
static void* r300_transfer_map(struct pipe_screen* screen,
                              struct pipe_transfer* transfer)
d419 2
a420 3
    struct r300_texture* tex = (struct r300_texture*)transfer->texture;
    char* map;
    enum pipe_format format = tex->tex.format;
d422 2
a423 2
    map = pipe_buffer_map(screen, tex->buffer,
                          pipe_transfer_buffer_flags(transfer));
d425 1
a425 7
    if (!map) {
        return NULL;
    }

    return map + r300_transfer(transfer)->offset +
        transfer->y / util_format_get_blockheight(format) * transfer->stride +
        transfer->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);
d428 3
a430 2
static void r300_transfer_unmap(struct pipe_screen* screen,
                                struct pipe_transfer* transfer)
d432 3
a434 2
    struct r300_texture* tex = (struct r300_texture*)transfer->texture;
    pipe_buffer_unmap(screen, tex->buffer);
d437 9
a445 6
static void r300_destroy_screen(struct pipe_screen* pscreen)
{
    struct r300_screen* r300screen = r300_screen(pscreen);

    FREE(r300screen->caps);
    FREE(r300screen);
d448 1
a448 1
struct pipe_screen* r300_create_screen(struct radeon_winsys* radeon_winsys)
d450 1
a450 2
    struct r300_screen* r300screen = CALLOC_STRUCT(r300_screen);
    struct r300_capabilities* caps = CALLOC_STRUCT(r300_capabilities);
d452 1
a452 1
    if (!r300screen || !caps) {
a453 1
        FREE(caps);
d457 3
a459 3
    caps->pci_id = radeon_winsys->pci_id;
    caps->num_frag_pipes = radeon_winsys->gb_pipes;
    caps->num_z_pipes = radeon_winsys->z_pipes;
d462 9
a470 1
    r300_parse_chipset(caps);
d472 2
a473 3
    r300screen->caps = caps;
    r300screen->radeon_winsys = radeon_winsys;
    r300screen->screen.winsys = (struct pipe_winsys*)radeon_winsys;
d478 1
a481 4
    r300screen->screen.get_tex_transfer = r300_get_tex_transfer;
    r300screen->screen.tex_transfer_destroy = r300_tex_transfer_destroy;
    r300screen->screen.transfer_map = r300_transfer_map;
    r300screen->screen.transfer_unmap = r300_transfer_unmap;
d483 11
a493 2
    r300_init_screen_texture_functions(&r300screen->screen);
    u_simple_screen_init(&r300screen->screen);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a2 1
 * Copyright 2010 Marek Olšák <maraeo@@gmail.com>
d23 1
a24 1
#include "util/u_format_s3tc.h"
d26 1
d29 1
d31 2
a32 2
#include "r300_screen_buffer.h"
#include "r300_state_inlines.h"
a33 7
#include "r300_public.h"

#include "draw/draw_context.h"

#ifdef HAVE_LLVM
#include "gallivm/lp_bld_init.h"
#endif
d47 25
a71 25
    "ATI R300",
    "ATI R350",
    "ATI R360",
    "ATI RV350",
    "ATI RV370",
    "ATI RV380",
    "ATI R420",
    "ATI R423",
    "ATI R430",
    "ATI R480",
    "ATI R481",
    "ATI RV410",
    "ATI RS400",
    "ATI RC410",
    "ATI RS480",
    "ATI RS482",
    "ATI RS600",
    "ATI RS690",
    "ATI RS740",
    "ATI RV515",
    "ATI R520",
    "ATI RV530",
    "ATI R580",
    "ATI RV560",
    "ATI RV570"
d78 1
a78 1
    return chip_families[r300screen->caps.family];
d81 1
a81 1
static int r300_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
a83 5
    boolean is_r400 = r300screen->caps.is_r400;
    boolean is_r500 = r300screen->caps.is_r500;

    /* XXX extended shader capabilities of r400 unimplemented */
    is_r400 = FALSE;
d86 4
a89 1
        /* Supported features (boolean caps). */
d91 3
d95 5
d116 3
d120 1
d122 3
d126 1
d128 11
d140 1
d142 5
d149 10
a158 6
        case PIPE_CAP_TEXTURE_SWIZZLE:
            return util_format_s3tc_enabled ? r300screen->caps.dxtc_swizzle : 1;

        /* Unsupported features (boolean caps). */
        case PIPE_CAP_TIMER_QUERY:
        case PIPE_CAP_DUAL_SOURCE_BLEND:
d160 1
a161 5
        case PIPE_CAP_DEPTH_CLAMP: /* XXX implemented, but breaks Regnum Online */
        case PIPE_CAP_DEPTHSTENCIL_CLEAR_SEPARATE:
        case PIPE_CAP_SHADER_STENCIL_EXPORT:
        case PIPE_CAP_STREAM_OUTPUT:
        case PIPE_CAP_PRIMITIVE_RESTART:
a162 21

        /* Texturing. */
        case PIPE_CAP_MAX_TEXTURE_IMAGE_UNITS:
        case PIPE_CAP_MAX_COMBINED_SAMPLERS:
            return r300screen->caps.num_tex_units;
        case PIPE_CAP_MAX_VERTEX_TEXTURE_UNITS:
            return 0;
        case PIPE_CAP_MAX_TEXTURE_2D_LEVELS:
        case PIPE_CAP_MAX_TEXTURE_3D_LEVELS:
        case PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS:
            /* 13 == 4096, 12 == 2048 */
            return is_r500 ? 13 : 12;

        /* Render targets. */
        case PIPE_CAP_MAX_RENDER_TARGETS:
            return 4;

        /* General shader limits and features. */
        case PIPE_CAP_SM3:
            return is_r500 ? 1 : 0;
        /* Fragment coordinate conventions. */
d170 2
a171 57
            debug_printf("r300: Warning: Unknown CAP %d in get_param.\n",
                         param);
            return 0;
    }
}

static int r300_get_shader_param(struct pipe_screen *pscreen, unsigned shader, enum pipe_shader_cap param)
{
   struct r300_screen* r300screen = r300_screen(pscreen);
   boolean is_r400 = r300screen->caps.is_r400;
   boolean is_r500 = r300screen->caps.is_r500;

   /* XXX extended shader capabilities of r400 unimplemented */
   is_r400 = FALSE;

   switch (shader)
    {
    case PIPE_SHADER_FRAGMENT:
        switch (param)
        {
        case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
            return is_r500 || is_r400 ? 512 : 96;
        case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
            return is_r500 || is_r400 ? 512 : 64;
        case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
            return is_r500 || is_r400 ? 512 : 32;
        case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
            return is_r500 ? 511 : 4;
        case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
            return is_r500 ? 64 : 0; /* Actually unlimited on r500. */
            /* Fragment shader limits. */
        case PIPE_SHADER_CAP_MAX_INPUTS:
            /* 2 colors + 8 texcoords are always supported
             * (minus fog and wpos).
             *
             * R500 has the ability to turn 3rd and 4th color into
             * additional texcoords but there is no two-sided color
             * selection then. However the facing bit can be used instead. */
            return 10;
        case PIPE_SHADER_CAP_MAX_CONSTS:
            return is_r500 ? 256 : 32;
        case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
            return 1;
        case PIPE_SHADER_CAP_MAX_TEMPS:
            return is_r500 ? 128 : is_r400 ? 64 : 32;
        case PIPE_SHADER_CAP_MAX_ADDRS:
            return 0;
        case PIPE_SHADER_CAP_MAX_PREDS:
            return is_r500 ? 1 : 0;
        case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
            return 0;
        case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
            return 0;
        case PIPE_SHADER_CAP_SUBROUTINES:
a172 45
        }
        break;
    case PIPE_SHADER_VERTEX:
        if (!r300screen->caps.has_tcl) {
            return draw_get_shader_param(shader, param);
        }

        switch (param)
        {
        case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
        case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
            return is_r500 ? 1024 : 256;
        case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
        case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
            return 0;
        case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
            return is_r500 ? 4 : 0; /* For loops; not sure about conditionals. */
        case PIPE_SHADER_CAP_MAX_INPUTS:
            return 16;
        case PIPE_SHADER_CAP_MAX_CONSTS:
            return 256;
        case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
            return 1;
        case PIPE_SHADER_CAP_MAX_TEMPS:
            return 32;
        case PIPE_SHADER_CAP_MAX_ADDRS:
            return 1; /* XXX guessed */
        case PIPE_SHADER_CAP_MAX_PREDS:
            return is_r500 ? 4 : 0; /* XXX guessed. */
        case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
            return 0;
        case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
        case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
            return 0;
        case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
            return 1;
        case PIPE_SHADER_CAP_SUBROUTINES:
            return 0;
        default:
            break;
        }
        break;
    default:
        break;
a173 1
    return 0;
d176 1
a176 1
static float r300_get_paramf(struct pipe_screen* pscreen, enum pipe_cap param)
d187 1
a187 1
            if (r300screen->caps.is_r500) {
d189 1
a189 1
            } else if (r300screen->caps.is_r400) {
a197 7
        case PIPE_CAP_GUARD_BAND_LEFT:
        case PIPE_CAP_GUARD_BAND_TOP:
        case PIPE_CAP_GUARD_BAND_RIGHT:
        case PIPE_CAP_GUARD_BAND_BOTTOM:
            /* XXX I don't know what these should be but the least we can do is
             * silence the potential error message */
            return 0.0f;
d199 2
a200 2
            debug_printf("r300: Warning: Unknown CAP %d in get_paramf.\n",
                         param);
a207 1
                                        unsigned sample_count,
d212 9
a220 35
    boolean is_r500 = r300_screen(screen)->caps.is_r500;
    boolean is_r400 = r300_screen(screen)->caps.is_r400;
    boolean is_color2101010 = format == PIPE_FORMAT_R10G10B10A2_UNORM ||
                              format == PIPE_FORMAT_R10G10B10X2_SNORM ||
                              format == PIPE_FORMAT_B10G10R10A2_UNORM ||
                              format == PIPE_FORMAT_R10SG10SB10SA2U_NORM;
    boolean is_ati1n = format == PIPE_FORMAT_RGTC1_UNORM ||
                       format == PIPE_FORMAT_RGTC1_SNORM;
    boolean is_ati2n = format == PIPE_FORMAT_RGTC2_UNORM ||
                       format == PIPE_FORMAT_RGTC2_SNORM;
    boolean is_half_float = format == PIPE_FORMAT_R16_FLOAT ||
                            format == PIPE_FORMAT_R16G16_FLOAT ||
                            format == PIPE_FORMAT_R16G16B16_FLOAT ||
                            format == PIPE_FORMAT_R16G16B16A16_FLOAT;

    /* Check multisampling support. */
    switch (sample_count) {
        case 0:
        case 1:
            break;
        case 2:
        case 3:
        case 4:
        case 6:
            return FALSE;
#if 0
            if (usage != PIPE_BIND_RENDER_TARGET ||
                !util_format_is_rgba8_variant(
                    util_format_description(format))) {
                return FALSE;
            }
#endif
            break;
        default:
            return FALSE;
d224 3
a226 5
    if ((usage & PIPE_BIND_SAMPLER_VIEW) &&
        /* ATI1N is r5xx-only. */
        (is_r500 || !is_ati1n) &&
        /* ATI2N is supported on r4xx-r5xx. */
        (is_r400 || is_r500 || !is_ati2n) &&
d228 1
a228 1
        retval |= PIPE_BIND_SAMPLER_VIEW;
d232 3
a234 4
    if ((usage & (PIPE_BIND_RENDER_TARGET |
                  PIPE_BIND_DISPLAY_TARGET |
                  PIPE_BIND_SCANOUT |
                  PIPE_BIND_SHARED)) &&
d239 3
a241 4
            (PIPE_BIND_RENDER_TARGET |
             PIPE_BIND_DISPLAY_TARGET |
             PIPE_BIND_SCANOUT |
             PIPE_BIND_SHARED);
d245 1
a245 1
    if (usage & PIPE_BIND_DEPTH_STENCIL &&
d247 1
a247 1
        retval |= PIPE_BIND_DEPTH_STENCIL;
d250 30
a279 6
    /* Check vertex buffer format support. */
    if (usage & PIPE_BIND_VERTEX_BUFFER &&
        /* Half float is supported on >= RV350. */
        (is_r400 || is_r500 || !is_half_float) &&
        r300_translate_vertex_data_type(format) != R300_INVALID_FORMAT) {
        retval |= PIPE_BIND_VERTEX_BUFFER;
d281 2
d284 5
a288 7
    /* Transfers are always supported. */
    if (usage & PIPE_BIND_TRANSFER_READ)
        retval |= PIPE_BIND_TRANSFER_READ;
    if (usage & PIPE_BIND_TRANSFER_WRITE)
        retval |= PIPE_BIND_TRANSFER_WRITE;

    return retval == usage;
d291 2
a292 1
static void r300_destroy_screen(struct pipe_screen* pscreen)
d294 3
a296 2
    struct r300_screen* r300screen = r300_screen(pscreen);
    struct r300_winsys_screen *rws = r300_winsys_screen(pscreen);
d298 2
a299 1
    util_slab_destroy(&r300screen->pool_buffers);
d301 3
a303 2
    if (rws)
      rws->destroy(rws);
d305 3
a307 1
    FREE(r300screen);
d310 2
a311 3
static void r300_fence_reference(struct pipe_screen *screen,
                                 struct pipe_fence_handle **ptr,
                                 struct pipe_fence_handle *fence)
d313 2
a314 7
    struct r300_fence **oldf = (struct r300_fence**)ptr;
    struct r300_fence *newf = (struct r300_fence*)fence;

    if (pipe_reference(&(*oldf)->reference, &newf->reference))
        FREE(*oldf);

    *ptr = fence;
d317 1
a317 3
static int r300_fence_signalled(struct pipe_screen *screen,
                                struct pipe_fence_handle *fence,
                                unsigned flags)
d319 1
a319 1
    struct r300_fence *rfence = (struct r300_fence*)fence;
d321 2
a322 1
    return rfence->signalled ? 0 : 1; /* 0 == success */
d325 1
a325 12
static int r300_fence_finish(struct pipe_screen *screen,
                             struct pipe_fence_handle *fence,
                             unsigned flags)
{
    struct r300_fence *rfence = (struct r300_fence*)fence;

    r300_finish(rfence->ctx);
    rfence->signalled = TRUE;
    return 0; /* 0 == success */
}

struct pipe_screen* r300_screen_create(struct r300_winsys_screen *rws)
d327 2
a328 1
    struct r300_screen *r300screen = CALLOC_STRUCT(r300_screen);
d330 1
a330 1
    if (!r300screen) {
d332 1
d336 3
a338 3
    r300screen->caps.pci_id = rws->get_value(rws, R300_VID_PCI_ID);
    r300screen->caps.num_frag_pipes = rws->get_value(rws, R300_VID_GB_PIPES);
    r300screen->caps.num_z_pipes = rws->get_value(rws, R300_VID_Z_PIPES);
d341 1
a341 9
    r300_parse_chipset(&r300screen->caps);

    r300screen->caps.index_bias_supported =
            r300screen->caps.is_r500 &&
            rws->get_value(rws, R300_VID_DRM_2_3_0);

    util_slab_create(&r300screen->pool_buffers,
                     sizeof(struct r300_buffer), 64,
                     UTIL_SLAB_SINGLETHREADED);
d343 3
a345 2
    r300screen->rws = rws;
    r300screen->screen.winsys = (struct pipe_winsys*)rws;
a349 1
    r300screen->screen.get_shader_param = r300_get_shader_param;
d353 4
d358 2
a359 11
    r300screen->screen.fence_reference = r300_fence_reference;
    r300screen->screen.fence_signalled = r300_fence_signalled;
    r300screen->screen.fence_finish = r300_fence_finish;

    r300_init_screen_resource_functions(r300screen);

    util_format_s3tc_init();

#ifdef HAVE_LLVM
    lp_build_init();
#endif
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a26 3
#include "os/os_time.h"
#include "vl/vl_decoder.h"
#include "vl/vl_video_buffer.h"
d32 1
d37 4
a52 1
    "unknown",
d55 1
a58 3
    "ATI RS400",
    "ATI RC410",
    "ATI RS480",
d65 4
d90 1
d93 3
d100 16
d121 1
a122 9
        case PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR:
        case PIPE_CAP_TGSI_FS_COORD_ORIGIN_UPPER_LEFT:
        case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
        case PIPE_CAP_CONDITIONAL_RENDER:
        case PIPE_CAP_TEXTURE_BARRIER:
        case PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS:
        case PIPE_CAP_USER_INDEX_BUFFERS:
        case PIPE_CAP_USER_CONSTANT_BUFFERS:
        case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
a123 11

        case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
            return R300_BUFFER_ALIGNMENT;

        case PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT:
            return 16;

        case PIPE_CAP_GLSL_FEATURE_LEVEL:
            return 120;

        /* r300 cannot do swizzling of compressed textures. Supported otherwise. */
d127 3
a129 15
        /* We don't support color clamping on r500, so that we can use color
         * intepolators for generic varyings. */
        case PIPE_CAP_VERTEX_COLOR_CLAMPED:
            return !is_r500;

        /* Supported on r500 only. */
        case PIPE_CAP_VERTEX_COLOR_UNCLAMPED:
        case PIPE_CAP_MIXED_COLORBUFFER_FORMATS:
        case PIPE_CAP_SM3:
            return is_r500 ? 1 : 0;

        /* Unsupported features. */
        case PIPE_CAP_QUERY_TIME_ELAPSED:
        case PIPE_CAP_QUERY_PIPELINE_STATISTICS:
        case PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS:
d132 2
a133 1
        case PIPE_CAP_DEPTH_CLIP_DISABLE:
d135 1
a135 27
        case PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS:
        case PIPE_CAP_TGSI_INSTANCEID:
        case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
        case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
        case PIPE_CAP_SEAMLESS_CUBE_MAP:
        case PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE:
        case PIPE_CAP_SCALED_RESOLVE:
        case PIPE_CAP_MIN_TEXEL_OFFSET:
        case PIPE_CAP_MAX_TEXEL_OFFSET:
        case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
        case PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS:
        case PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS:
        case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
        case PIPE_CAP_FRAGMENT_COLOR_CLAMPED:
        case PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION:
        case PIPE_CAP_COMPUTE:
        case PIPE_CAP_START_INSTANCE:
        case PIPE_CAP_QUERY_TIMESTAMP:
        case PIPE_CAP_TEXTURE_MULTISAMPLE:
        case PIPE_CAP_CUBE_MAP_ARRAY:
        case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
        case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
        case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
        case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
            return 0;

        /* SWTCL-only features. */
a136 9
        case PIPE_CAP_USER_VERTEX_BUFFERS:
            return !r300screen->caps.has_tcl;

        /* HWTCL-only features / limitations. */
        case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
        case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
        case PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY:
            return r300screen->caps.has_tcl;
	case PIPE_CAP_TGSI_TEXCOORD:
d140 1
d143 2
d154 15
a168 2
	case PIPE_CAP_ENDIANNESS:
            return PIPE_ENDIAN_LITTLE;
a169 1
    return 0;
d178 5
a182 1
   switch (shader) {
d211 2
a214 3
        case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
           return r300screen->caps.num_tex_units;
        case PIPE_SHADER_CAP_MAX_ADDRS:
d216 1
a216 1
        case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
d221 1
a222 1
        case PIPE_SHADER_CAP_INTEGERS:
a223 2
        case PIPE_SHADER_CAP_PREFERRED_IR:
            return PIPE_SHADER_IR_TGSI;
a226 8
        switch (param)
        {
        case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
        case PIPE_SHADER_CAP_SUBROUTINES:
            return 0;
        default:;
        }

d236 3
a252 4
        case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
            return 1;
        case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
        case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
d254 1
a254 1
        case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
d258 3
a261 2
        case PIPE_SHADER_CAP_INTEGERS:
        case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
d263 2
a264 2
        case PIPE_SHADER_CAP_PREFERRED_IR:
            return PIPE_SHADER_IR_TGSI;
d267 2
d273 1
a273 2
static float r300_get_paramf(struct pipe_screen* pscreen,
                             enum pipe_capf param)
d278 4
a281 4
        case PIPE_CAPF_MAX_LINE_WIDTH:
        case PIPE_CAPF_MAX_LINE_WIDTH_AA:
        case PIPE_CAPF_MAX_POINT_WIDTH:
        case PIPE_CAPF_MAX_POINT_WIDTH_AA:
d291 1
a291 1
        case PIPE_CAPF_MAX_TEXTURE_ANISOTROPY:
d293 1
a293 1
        case PIPE_CAPF_MAX_TEXTURE_LOD_BIAS:
d295 4
a298 4
        case PIPE_CAPF_GUARD_BAND_LEFT:
        case PIPE_CAPF_GUARD_BAND_TOP:
        case PIPE_CAPF_GUARD_BAND_RIGHT:
        case PIPE_CAPF_GUARD_BAND_BOTTOM:
a308 51
static int r300_get_video_param(struct pipe_screen *screen,
				enum pipe_video_profile profile,
				enum pipe_video_cap param)
{
   switch (param) {
      case PIPE_VIDEO_CAP_SUPPORTED:
         return vl_profile_supported(screen, profile);
      case PIPE_VIDEO_CAP_NPOT_TEXTURES:
         return 0;
      case PIPE_VIDEO_CAP_MAX_WIDTH:
      case PIPE_VIDEO_CAP_MAX_HEIGHT:
         return vl_video_buffer_max_size(screen);
      case PIPE_VIDEO_CAP_PREFERED_FORMAT:
         return PIPE_FORMAT_NV12;
      case PIPE_VIDEO_CAP_PREFERS_INTERLACED:
         return false;
      case PIPE_VIDEO_CAP_SUPPORTS_INTERLACED:
         return false;
      case PIPE_VIDEO_CAP_SUPPORTS_PROGRESSIVE:
         return true;
      default:
         return 0;
   }
}

/**
 * Whether the format matches:
 *   PIPE_FORMAT_?10?10?10?2_UNORM
 */
static INLINE boolean
util_format_is_rgba1010102_variant(const struct util_format_description *desc)
{
   static const unsigned size[4] = {10, 10, 10, 2};
   unsigned chan;

   if (desc->block.width != 1 ||
       desc->block.height != 1 ||
       desc->block.bits != 32)
      return FALSE;

   for (chan = 0; chan < 4; ++chan) {
      if(desc->channel[chan].type != UTIL_FORMAT_TYPE_UNSIGNED &&
         desc->channel[chan].type != UTIL_FORMAT_TYPE_VOID)
         return FALSE;
      if (desc->channel[chan].size != size[chan])
         return FALSE;
   }

   return TRUE;
}

d313 2
a314 1
                                        unsigned usage)
a316 1
    boolean drm_2_8_0 = r300_screen(screen)->info.drm_minor >= 8;
d324 1
a324 3
                       format == PIPE_FORMAT_RGTC1_SNORM ||
                       format == PIPE_FORMAT_LATC1_UNORM ||
                       format == PIPE_FORMAT_LATC1_SNORM;
d326 1
a326 10
                       format == PIPE_FORMAT_RGTC2_SNORM ||
                       format == PIPE_FORMAT_LATC2_UNORM ||
                       format == PIPE_FORMAT_LATC2_SNORM;
    boolean is_x16f_xy16f = format == PIPE_FORMAT_R16_FLOAT ||
                            format == PIPE_FORMAT_R16G16_FLOAT ||
                            format == PIPE_FORMAT_A16_FLOAT ||
                            format == PIPE_FORMAT_L16_FLOAT ||
                            format == PIPE_FORMAT_L16A16_FLOAT ||
                            format == PIPE_FORMAT_R16A16_FLOAT ||
                            format == PIPE_FORMAT_I16_FLOAT;
d330 1
a330 6
                            format == PIPE_FORMAT_R16G16B16A16_FLOAT ||
                            format == PIPE_FORMAT_R16G16B16X16_FLOAT;
    const struct util_format_description *desc;

    if (!util_format_is_supported(format, usage))
       return FALSE;
d338 1
d341 5
a345 13
            /* We need DRM 2.8.0. */
            if (!drm_2_8_0) {
                return FALSE;
            }
            /* Only support R500, because I didn't test older chipsets,
             * but MSAA should work there too. */
            if (!is_r500 && !debug_get_bool_option("RADEON_MSAA", FALSE)) {
                return FALSE;
            }
            /* No texturing and scanout. */
            if (usage & (PIPE_BIND_SAMPLER_VIEW |
                         PIPE_BIND_DISPLAY_TARGET |
                         PIPE_BIND_SCANOUT)) {
d348 1
a348 19

            desc = util_format_description(format);

            if (is_r500) {
                /* Only allow depth/stencil, RGBA8, RGBA1010102, RGBA16F. */
                if (!util_format_is_depth_or_stencil(format) &&
                    !util_format_is_rgba8_variant(desc) &&
                    !util_format_is_rgba1010102_variant(desc) &&
                    format != PIPE_FORMAT_R16G16B16A16_FLOAT &&
                    format != PIPE_FORMAT_R16G16B16X16_FLOAT) {
                    return FALSE;
                }
            } else {
                /* Only allow depth/stencil, RGBA8. */
                if (!util_format_is_depth_or_stencil(format) &&
                    !util_format_is_rgba8_variant(desc)) {
                    return FALSE;
                }
            }
a355 3
        /* these two are broken for an unknown reason */
        format != PIPE_FORMAT_R8G8B8X8_SNORM &&
        format != PIPE_FORMAT_R16G16B16X16_SNORM &&
a359 2
        /* R16F and RG16F texture support was added in as late as DRM 2.8.0 */
        (drm_2_8_0 || !is_x16f_xy16f) &&
d370 1
a370 1
        (!is_color2101010 || (is_r500 && drm_2_8_0)) &&
d386 5
a390 13
    if (usage & PIPE_BIND_VERTEX_BUFFER) {
        if (r300_screen(screen)->caps.has_tcl) {
            /* Half float is supported on >= R400. */
            if ((is_r400 || is_r500 || !is_half_float) &&
                r300_translate_vertex_data_type(format) != R300_INVALID_FORMAT) {
                retval |= PIPE_BIND_VERTEX_BUFFER;
            }
        } else {
            /* SW TCL */
            if (!util_format_is_pure_integer(format)) {
                retval |= PIPE_BIND_VERTEX_BUFFER;
            }
        }
d405 1
a405 1
    struct radeon_winsys *rws = radeon_winsys(pscreen);
d407 1
a407 1
    pipe_mutex_destroy(r300screen->cmask_mutex);
d419 7
a425 2
    pb_reference((struct pb_buffer**)ptr,
                             (struct pb_buffer*)fence);
d428 3
a430 2
static boolean r300_fence_signalled(struct pipe_screen *screen,
                                    struct pipe_fence_handle *fence)
d432 1
a432 2
    struct radeon_winsys *rws = r300_screen(screen)->rws;
    struct pb_buffer *rfence = (struct pb_buffer*)fence;
d434 1
a434 1
    return !rws->buffer_is_busy(rfence, RADEON_USAGE_READWRITE);
d437 5
a441 22
static boolean r300_fence_finish(struct pipe_screen *screen,
                                 struct pipe_fence_handle *fence,
                                 uint64_t timeout)
{
    struct radeon_winsys *rws = r300_screen(screen)->rws;
    struct pb_buffer *rfence = (struct pb_buffer*)fence;

    if (timeout != PIPE_TIMEOUT_INFINITE) {
        int64_t start_time = os_time_get();

        /* Convert to microseconds. */
        timeout /= 1000;

        /* Wait in a loop. */
        while (rws->buffer_is_busy(rfence, RADEON_USAGE_READWRITE)) {
            if (os_time_get() - start_time >= timeout) {
                return FALSE;
            }
            os_time_sleep(10);
        }
        return TRUE;
    }
d443 3
a445 2
    rws->buffer_wait(rfence, RADEON_USAGE_READWRITE);
    return TRUE;
d448 1
a448 1
struct pipe_screen* r300_screen_create(struct radeon_winsys *rws)
d457 3
a459 1
    rws->query_info(rws, &r300screen->info);
d462 1
a462 6
    r300_parse_chipset(r300screen->info.pci_id, &r300screen->caps);

    if (SCREEN_DBG_ON(r300screen, DBG_NO_ZMASK))
        r300screen->caps.zmask_ram = 0;
    if (SCREEN_DBG_ON(r300screen, DBG_NO_HIZ))
        r300screen->caps.hiz_ram = 0;
d464 7
a470 2
    if (r300screen->info.drm_minor < 8)
        r300screen->caps.has_us_format = FALSE;
d473 1
a479 1
    r300screen->screen.get_video_param = r300_get_video_param;
a480 1
    r300screen->screen.is_video_format_supported = vl_video_buffer_is_format_supported;
d482 1
d490 4
a493 1
    pipe_mutex_init(r300screen->cmask_mutex);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a91 1
        case PIPE_CAP_MIXED_FRAMEBUFFER_SIZES:
a107 1
        case PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT:
d148 1
a150 2
        case PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET:
        case PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET:
a153 2
        case PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES:
        case PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS:
a165 6
        case PIPE_CAP_TGSI_VS_LAYER:
        case PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS:
        case PIPE_CAP_TEXTURE_GATHER_SM5:
        case PIPE_CAP_TEXTURE_QUERY_LOD:
        case PIPE_CAP_FAKE_SW_MSAA:
        case PIPE_CAP_SAMPLE_SHADING:
d182 2
a194 3

        case PIPE_CAP_MAX_VIEWPORTS:
            return 1;
a236 1
        case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
a255 1
        case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
a295 1
        case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
a343 1
				enum pipe_video_entrypoint entrypoint,
d348 1
a348 1
         return vl_profile_supported(screen, profile, entrypoint);
a361 2
      case PIPE_VIDEO_CAP_MAX_LEVEL:
         return vl_level_supported(screen, profile);
d444 5
a544 3
    if (rws && !rws->unref(rws))
      return;

d557 2
a558 3
    struct radeon_winsys *rws = r300_screen(screen)->rws;

    rws->fence_reference(ptr, fence);
d565 1
d567 1
a567 1
    return rws->fence_wait(rws, fence, 0);
d575 17
d593 2
a594 1
    return rws->fence_wait(rws, fence, timeout);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a109 1
        case PIPE_CAP_CLIP_HALFZ:
a158 1
        case PIPE_CAP_MAX_VERTEX_STREAMS:
d171 1
a171 1
        case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
a176 6
        case PIPE_CAP_TEXTURE_GATHER_OFFSETS:
        case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
        case PIPE_CAP_DRAW_INDIRECT:
        case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
        case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
        case PIPE_CAP_SAMPLER_VIEW_TARGET:
a206 14

        case PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE:
            return 2048;

        case PIPE_CAP_VENDOR_ID:
                return 0x1002;
        case PIPE_CAP_DEVICE_ID:
                return r300screen->info.pci_id;
        case PIPE_CAP_ACCELERATED:
                return 1;
        case PIPE_CAP_VIDEO_MEMORY:
                return r300screen->info.vram_size >> 20;
        case PIPE_CAP_UMA:
                return 0;
d240 2
a241 4
        case PIPE_SHADER_CAP_MAX_OUTPUTS:
            return 4;
        case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
            return (is_r500 ? 256 : 32) * sizeof(float[4]);
d251 1
a259 1
        case PIPE_SHADER_CAP_DOUBLES:
d288 2
a289 4
        case PIPE_SHADER_CAP_MAX_OUTPUTS:
            return 10;
        case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
            return 256 * sizeof(float[4]);
d294 2
a310 1
        case PIPE_SHADER_CAP_DOUBLES:
a410 38
static bool r300_is_blending_supported(struct r300_screen *rscreen,
                                       enum pipe_format format)
{
    int c;
    const struct util_format_description *desc =
        util_format_description(format);

    if (desc->layout != UTIL_FORMAT_LAYOUT_PLAIN)
        return false;

    c = util_format_get_first_non_void_channel(format);

    /* RGBA16F */
    if (rscreen->caps.is_r500 &&
        desc->nr_channels == 4 &&
        desc->channel[c].size == 16 &&
        desc->channel[c].type == UTIL_FORMAT_TYPE_FLOAT)
        return true;

    if (desc->channel[c].normalized &&
        desc->channel[c].type == UTIL_FORMAT_TYPE_UNSIGNED &&
        desc->channel[c].size >= 4 &&
        desc->channel[c].size <= 10) {
        /* RGB10_A2, RGBA8, RGB5_A1, RGBA4, RGB565 */
        if (desc->nr_channels >= 3)
            return true;

        if (format == PIPE_FORMAT_R8G8_UNORM)
            return true;

        /* R8, I8, L8, A8 */
        if (desc->nr_channels == 1)
            return true;
    }

    return false;
}

a423 1
                              format == PIPE_FORMAT_B10G10R10X2_UNORM ||
d511 1
a511 2
                  PIPE_BIND_SHARED |
                  PIPE_BIND_BLENDABLE)) &&
a519 4

        if (r300_is_blending_supported(r300_screen(screen), format)) {
            retval |= usage & PIPE_BIND_BLENDABLE;
        }
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d110 1
d160 1
d173 1
a173 1
        case PIPE_CAP_TGSI_VS_LAYER:
d179 6
d215 14
d262 4
a265 2
        case PIPE_SHADER_CAP_MAX_CONSTS:
            return is_r500 ? 256 : 32;
a274 1
        case PIPE_SHADER_CAP_MAX_ADDRS:
d283 1
d312 4
a315 2
        case PIPE_SHADER_CAP_MAX_CONSTS:
            return 256;
a319 2
        case PIPE_SHADER_CAP_MAX_ADDRS:
            return 1; /* XXX guessed */
d335 1
d436 38
d487 1
d575 2
a576 1
                  PIPE_BIND_SHARED)) &&
d585 4
@


