head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.00.49;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.54;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@
#ifndef __NVC0_WINSYS_H__
#define __NVC0_WINSYS_H__

#include <stdint.h>
#include <unistd.h>

#include "pipe/p_defines.h"

#include "nouveau/nouveau_winsys.h"
#include "nouveau/nouveau_buffer.h"

#ifndef NV04_PFIFO_MAX_PACKET_LEN
#define NV04_PFIFO_MAX_PACKET_LEN 2047
#endif


static INLINE void
nv50_add_bufctx_resident_bo(struct nouveau_bufctx *bufctx, int bin,
                            unsigned flags, struct nouveau_bo *bo)
{
   nouveau_bufctx_refn(bufctx, bin, bo, flags)->priv = NULL;
}

static INLINE void
nvc0_add_resident(struct nouveau_bufctx *bufctx, int bin,
                  struct nv04_resource *res, unsigned flags)
{
   struct nouveau_bufref *ref =
      nouveau_bufctx_refn(bufctx, bin, res->bo, flags | res->domain);
   ref->priv = res;
   ref->priv_data = flags;
}

#define BCTX_REFN_bo(ctx, bin, fl, bo) \
   nv50_add_bufctx_resident_bo(ctx, NVC0_BIND_##bin, fl, bo);

#define BCTX_REFN(bctx, bin, res, acc) \
   nvc0_add_resident(bctx, NVC0_BIND_##bin, res, NOUVEAU_BO_##acc)

static INLINE void
PUSH_REFN(struct nouveau_pushbuf *push, struct nouveau_bo *bo, uint32_t flags)
{
   struct nouveau_pushbuf_refn ref = { bo, flags };
   nouveau_pushbuf_refn(push, &ref, 1);
}


#define SUBC_3D(m) 0, (m)
#define NVC0_3D(n) SUBC_3D(NVC0_3D_##n)
#define NVE4_3D(n) SUBC_3D(NVE4_3D_##n)

#define SUBC_COMPUTE(m) 1, (m)
#define NVC0_COMPUTE(n) SUBC_COMPUTE(NVC0_COMPUTE_##n)
#define NVE4_COMPUTE(n) SUBC_COMPUTE(NVE4_COMPUTE_##n)

#define SUBC_M2MF(m) 2, (m)
#define SUBC_P2MF(m) 2, (m)
#define NVC0_M2MF(n) SUBC_M2MF(NVC0_M2MF_##n)
#define NVE4_P2MF(n) SUBC_P2MF(NVE4_P2MF_##n)

#define SUBC_2D(m) 3, (m)
#define NVC0_2D(n) SUBC_2D(NVC0_2D_##n)

#define SUBC_COPY(m) 4, (m)
#define NVE4_COPY(m) SUBC_COPY(NVE4_COPY_##n)

#define SUBC_SW(m) 7, (m)

static INLINE uint32_t
NVC0_FIFO_PKHDR_SQ(int subc, int mthd, unsigned size)
{
   return 0x20000000 | (size << 16) | (subc << 13) | (mthd >> 2);
}

static INLINE uint32_t
NVC0_FIFO_PKHDR_NI(int subc, int mthd, unsigned size)
{
   return 0x60000000 | (size << 16) | (subc << 13) | (mthd >> 2);
}

static INLINE uint32_t
NVC0_FIFO_PKHDR_IL(int subc, int mthd, uint8_t data)
{
   return 0x80000000 | (data << 16) | (subc << 13) | (mthd >> 2);
}

static INLINE uint32_t
NVC0_FIFO_PKHDR_1I(int subc, int mthd, unsigned size)
{
   return 0xa0000000 | (size << 16) | (subc << 13) | (mthd >> 2);
}


static INLINE uint8_t
nouveau_bo_memtype(const struct nouveau_bo *bo)
{
   return bo->config.nvc0.memtype;
}


static INLINE void
PUSH_DATAh(struct nouveau_pushbuf *push, uint64_t data)
{
   *push->cur++ = (uint32_t)(data >> 32);
}

static INLINE void
BEGIN_NVC0(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
{
#ifndef NVC0_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NVC0_FIFO_PKHDR_SQ(subc, mthd, size));
}

static INLINE void
BEGIN_NIC0(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
{
#ifndef NVC0_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NVC0_FIFO_PKHDR_NI(subc, mthd, size));
}

static INLINE void
BEGIN_1IC0(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
{
#ifndef NVC0_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NVC0_FIFO_PKHDR_1I(subc, mthd, size));
}

static INLINE void
IMMED_NVC0(struct nouveau_pushbuf *push, int subc, int mthd, uint8_t data)
{
#ifndef NVC0_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, 1);
#endif
   PUSH_DATA (push, NVC0_FIFO_PKHDR_IL(subc, mthd, data));
}

#endif /* __NVC0_WINSYS_H__ */
@


1.2
log
@Merge Mesa 9.2.0
@
text
@@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d7 1
d10 2
a11 9
#include "nouveau/nouveau_bo.h"
#include "nouveau/nouveau_channel.h"
#include "nouveau/nouveau_grobj.h"
#include "nouveau/nouveau_device.h"
#include "nouveau/nouveau_resource.h"
#include "nouveau/nouveau_pushbuf.h"
#include "nouveau/nouveau_reloc.h"

#include "nvc0_resource.h" /* OUT_RESRC */
a16 3
#define NVC0_SUBCH_3D 1
#define NVC0_SUBCH_2D 2
#define NVC0_SUBCH_MF 3
d18 38
a55 1
#define NVC0_MF_(n) NVC0_M2MF_##n
d57 4
a60 3
#define RING_3D(n) ((NVC0_SUBCH_3D << 13) | (NVC0_3D_##n >> 2))
#define RING_2D(n) ((NVC0_SUBCH_2D << 13) | (NVC0_2D_##n >> 2))
#define RING_MF(n) ((NVC0_SUBCH_MF << 13) | (NVC0_MF_(n) >> 2))
d62 2
a63 3
#define RING_3D_(m) ((NVC0_SUBCH_3D << 13) | ((m) >> 2))
#define RING_2D_(m) ((NVC0_SUBCH_2D << 13) | ((m) >> 2))
#define RING_MF_(m) ((NVC0_SUBCH_MF << 13) | ((m) >> 2))
d65 2
a66 1
#define RING_GR(gr, m) (((gr)->subc << 13) | ((m) >> 2))
d68 1
a68 1
int nouveau_pushbuf_flush(struct nouveau_channel *, unsigned min);
d70 2
a71 2
static inline uint32_t
nouveau_bo_tile_layout(struct nouveau_bo *bo)
d73 1
a73 1
   return bo->tile_flags & NOUVEAU_BO_TILE_LAYOUT_MASK;
d76 8
a83 3
static INLINE void
nouveau_bo_validate(struct nouveau_channel *chan,
                    struct nouveau_bo *bo, unsigned flags)
d85 1
a85 1
   nouveau_reloc_emit(chan, NULL, 0, NULL, bo, 0, 0, flags, 0, 0);
d88 2
a89 3
/* incremental methods */
static INLINE void
BEGIN_RING(struct nouveau_channel *chan, uint32_t mthd, unsigned size)
d91 1
a91 2
   WAIT_RING(chan, size + 1);
   OUT_RING (chan, (0x2 << 28) | (size << 16) | mthd);
d94 3
a96 3
/* non-incremental */
static INLINE void
BEGIN_RING_NI(struct nouveau_channel *chan, uint32_t mthd, unsigned size)
d98 1
a98 2
   WAIT_RING(chan, size + 1);
   OUT_RING (chan, (0x6 << 28) | (size << 16) | mthd);
d101 1
a101 1
/* increment-once */
d103 1
a103 1
BEGIN_RING_1I(struct nouveau_channel *chan, uint32_t mthd, unsigned size)
d105 1
a105 2
   WAIT_RING(chan, size + 1);
   OUT_RING (chan, (0xa << 28) | (size << 16) | mthd);
a107 1
/* inline-data */
d109 1
a109 1
IMMED_RING(struct nouveau_channel *chan, uint32_t mthd, unsigned data)
d111 4
a114 2
   WAIT_RING(chan, 1);
   OUT_RING (chan, (0x8 << 28) | (data << 16) | mthd);
d117 2
a118 3
static INLINE int
OUT_RESRCh(struct nouveau_channel *chan, struct nv04_resource *res,
           unsigned delta, unsigned flags)
d120 4
a123 1
   return OUT_RELOCh(chan, res->bo, res->offset + delta, res->domain | flags);
d126 2
a127 3
static INLINE int
OUT_RESRCl(struct nouveau_channel *chan, struct nv04_resource *res,
           unsigned delta, unsigned flags)
d129 4
a132 3
   if (flags & NOUVEAU_BO_WR)
      res->status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
   return OUT_RELOCl(chan, res->bo, res->offset + delta, res->domain | flags);
d136 1
a136 1
BIND_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr, unsigned s)
d138 4
a141 13
   struct nouveau_subchannel *subc = &gr->channel->subc[s];

   assert(s < 8);
   if (subc->gr) {
      assert(subc->gr->bound != NOUVEAU_GROBJ_BOUND_EXPLICIT);
      subc->gr->bound = NOUVEAU_GROBJ_UNBOUND;
   }
   subc->gr = gr;
   subc->gr->subc = s;
   subc->gr->bound = NOUVEAU_GROBJ_BOUND_EXPLICIT;

   BEGIN_RING(chan, RING_GR(gr, 0x0000), 1);
   OUT_RING  (chan, gr->grclass);
d144 1
a144 1
#endif
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d7 1
d9 7
a15 1
#include "pipe/p_defines.h"
d17 1
a17 2
#include "nouveau/nouveau_winsys.h"
#include "nouveau/nouveau_buffer.h"
d23 3
d27 1
a27 38
static INLINE void
nv50_add_bufctx_resident_bo(struct nouveau_bufctx *bufctx, int bin,
                            unsigned flags, struct nouveau_bo *bo)
{
   nouveau_bufctx_refn(bufctx, bin, bo, flags)->priv = NULL;
}

static INLINE void
nvc0_add_resident(struct nouveau_bufctx *bufctx, int bin,
                  struct nv04_resource *res, unsigned flags)
{
   struct nouveau_bufref *ref =
      nouveau_bufctx_refn(bufctx, bin, res->bo, flags | res->domain);
   ref->priv = res;
   ref->priv_data = flags;
}

#define BCTX_REFN_bo(ctx, bin, fl, bo) \
   nv50_add_bufctx_resident_bo(ctx, NVC0_BIND_##bin, fl, bo);

#define BCTX_REFN(bctx, bin, res, acc) \
   nvc0_add_resident(bctx, NVC0_BIND_##bin, res, NOUVEAU_BO_##acc)

static INLINE void
PUSH_REFN(struct nouveau_pushbuf *push, struct nouveau_bo *bo, uint32_t flags)
{
   struct nouveau_pushbuf_refn ref = { bo, flags };
   nouveau_pushbuf_refn(push, &ref, 1);
}


#define SUBC_3D(m) 0, (m)
#define NVC0_3D(n) SUBC_3D(NVC0_3D_##n)
#define NVE4_3D(n) SUBC_3D(NVE4_3D_##n)

#define SUBC_COMPUTE(m) 1, (m)
#define NVC0_COMPUTE(n) SUBC_COMPUTE(NVC0_COMPUTE_##n)
#define NVE4_COMPUTE(n) SUBC_COMPUTE(NVE4_COMPUTE_##n)
d29 3
a31 4
#define SUBC_M2MF(m) 2, (m)
#define SUBC_P2MF(m) 2, (m)
#define NVC0_M2MF(n) SUBC_M2MF(NVC0_M2MF_##n)
#define NVE4_P2MF(n) SUBC_P2MF(NVE4_P2MF_##n)
d33 3
a35 2
#define SUBC_2D(m) 3, (m)
#define NVC0_2D(n) SUBC_2D(NVC0_2D_##n)
d37 1
a37 2
#define SUBC_COPY(m) 4, (m)
#define NVE4_COPY(m) SUBC_COPY(NVE4_COPY_##n)
d39 1
a39 1
#define SUBC_SW(m) 7, (m)
d41 2
a42 2
static INLINE uint32_t
NVC0_FIFO_PKHDR_SQ(int subc, int mthd, unsigned size)
d44 1
a44 1
   return 0x20000000 | (size << 16) | (subc << 13) | (mthd >> 2);
d47 3
a49 2
static INLINE uint32_t
NVC0_FIFO_PKHDR_NI(int subc, int mthd, unsigned size)
d51 1
a51 1
   return 0x60000000 | (size << 16) | (subc << 13) | (mthd >> 2);
d54 3
a56 2
static INLINE uint32_t
NVC0_FIFO_PKHDR_IL(int subc, int mthd, uint8_t data)
d58 2
a59 1
   return 0x80000000 | (data << 16) | (subc << 13) | (mthd >> 2);
d62 3
a64 2
static INLINE uint32_t
NVC0_FIFO_PKHDR_1I(int subc, int mthd, unsigned size)
d66 2
a67 1
   return 0xa0000000 | (size << 16) | (subc << 13) | (mthd >> 2);
d70 3
a72 3

static INLINE uint8_t
nouveau_bo_memtype(const struct nouveau_bo *bo)
d74 2
a75 1
   return bo->config.nvc0.memtype;
d78 1
a78 1

d80 1
a80 1
PUSH_DATAh(struct nouveau_pushbuf *push, uint64_t data)
d82 2
a83 1
   *push->cur++ = (uint32_t)(data >> 32);
d86 3
a88 2
static INLINE void
BEGIN_NVC0(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
d90 1
a90 4
#ifndef NVC0_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NVC0_FIFO_PKHDR_SQ(subc, mthd, size));
d93 3
a95 2
static INLINE void
BEGIN_NIC0(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
d97 3
a99 4
#ifndef NVC0_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NVC0_FIFO_PKHDR_NI(subc, mthd, size));
d103 1
a103 1
BEGIN_1IC0(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
d105 13
a117 4
#ifndef NVC0_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NVC0_FIFO_PKHDR_1I(subc, mthd, size));
a119 5
static INLINE void
IMMED_NVC0(struct nouveau_pushbuf *push, int subc, int mthd, uint8_t data)
{
#ifndef NVC0_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, 1);
a120 4
   PUSH_DATA (push, NVC0_FIFO_PKHDR_IL(subc, mthd, data));
}

#endif /* __NVC0_WINSYS_H__ */
@

