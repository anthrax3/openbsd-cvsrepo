head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.00.47;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.50;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2010 Christoph Bumiller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "pipe/p_defines.h"

#include "nvc0_context.h"

#include "nv50/codegen/nv50_ir_driver.h"
#include "nve4_compute.h"

/* NOTE: Using a[0x270] in FP may cause an error even if we're using less than
 * 124 scalar varying values.
 */
static uint32_t
nvc0_shader_input_address(unsigned sn, unsigned si, unsigned ubase)
{
   switch (sn) {
   case NV50_SEMANTIC_TESSFACTOR:   return 0x000 + si * 0x4;
   case TGSI_SEMANTIC_PRIMID:       return 0x060;
   case TGSI_SEMANTIC_PSIZE:        return 0x06c;
   case TGSI_SEMANTIC_POSITION:     return 0x070;
   case TGSI_SEMANTIC_GENERIC:      return ubase + si * 0x10;
   case TGSI_SEMANTIC_FOG:          return 0x2e8;
   case TGSI_SEMANTIC_COLOR:        return 0x280 + si * 0x10;
   case TGSI_SEMANTIC_BCOLOR:       return 0x2a0 + si * 0x10;
   case NV50_SEMANTIC_CLIPDISTANCE: return 0x2c0 + si * 0x4;
   case TGSI_SEMANTIC_CLIPDIST:     return 0x2c0 + si * 0x10;
   case TGSI_SEMANTIC_CLIPVERTEX:   return 0x270;
   case TGSI_SEMANTIC_PCOORD:       return 0x2e0;
   case NV50_SEMANTIC_TESSCOORD:    return 0x2f0;
   case TGSI_SEMANTIC_INSTANCEID:   return 0x2f8;
   case TGSI_SEMANTIC_VERTEXID:     return 0x2fc;
   case TGSI_SEMANTIC_TEXCOORD:     return 0x300 + si * 0x10;
   case TGSI_SEMANTIC_FACE:         return 0x3fc;
   case NV50_SEMANTIC_INVOCATIONID: return ~0;
   default:
      assert(!"invalid TGSI input semantic");
      return ~0;
   }
}

static uint32_t
nvc0_shader_output_address(unsigned sn, unsigned si, unsigned ubase)
{
   switch (sn) {
   case NV50_SEMANTIC_TESSFACTOR:    return 0x000 + si * 0x4;
   case TGSI_SEMANTIC_PRIMID:        return 0x060;
   case NV50_SEMANTIC_LAYER:         return 0x064;
   case NV50_SEMANTIC_VIEWPORTINDEX: return 0x068;
   case TGSI_SEMANTIC_PSIZE:         return 0x06c;
   case TGSI_SEMANTIC_POSITION:      return 0x070;
   case TGSI_SEMANTIC_GENERIC:       return ubase + si * 0x10;
   case TGSI_SEMANTIC_FOG:           return 0x2e8;
   case TGSI_SEMANTIC_COLOR:         return 0x280 + si * 0x10;
   case TGSI_SEMANTIC_BCOLOR:        return 0x2a0 + si * 0x10;
   case NV50_SEMANTIC_CLIPDISTANCE:  return 0x2c0 + si * 0x4;
   case TGSI_SEMANTIC_CLIPDIST:      return 0x2c0 + si * 0x10;
   case TGSI_SEMANTIC_CLIPVERTEX:    return 0x270;
   case TGSI_SEMANTIC_TEXCOORD:      return 0x300 + si * 0x10;
   case TGSI_SEMANTIC_EDGEFLAG:      return ~0;
   default:
      assert(!"invalid TGSI output semantic");
      return ~0;
   }
}

static int
nvc0_vp_assign_input_slots(struct nv50_ir_prog_info *info)
{
   unsigned i, c, n;

   for (n = 0, i = 0; i < info->numInputs; ++i) {
      switch (info->in[i].sn) {
      case TGSI_SEMANTIC_INSTANCEID: /* for SM4 only, in TGSI they're SVs */
      case TGSI_SEMANTIC_VERTEXID:
         info->in[i].mask = 0x1;
         info->in[i].slot[0] =
            nvc0_shader_input_address(info->in[i].sn, 0, 0) / 4;
         continue;
      default:
         break;
      }
      for (c = 0; c < 4; ++c)
         info->in[i].slot[c] = (0x80 + n * 0x10 + c * 0x4) / 4;
      ++n;
   }

   return 0;
}

static int
nvc0_sp_assign_input_slots(struct nv50_ir_prog_info *info)
{
   unsigned ubase = MAX2(0x80, 0x20 + info->numPatchConstants * 0x10);
   unsigned offset;
   unsigned i, c;

   for (i = 0; i < info->numInputs; ++i) {
      offset = nvc0_shader_input_address(info->in[i].sn,
                                         info->in[i].si, ubase);
      if (info->in[i].patch && offset >= 0x20)
         offset = 0x20 + info->in[i].si * 0x10;

      if (info->in[i].sn == NV50_SEMANTIC_TESSCOORD)
         info->in[i].mask &= 3;

      for (c = 0; c < 4; ++c)
         info->in[i].slot[c] = (offset + c * 0x4) / 4;
   }

   return 0;
}

static int
nvc0_fp_assign_output_slots(struct nv50_ir_prog_info *info)
{
   unsigned count = info->prop.fp.numColourResults * 4;
   unsigned i, c;

   for (i = 0; i < info->numOutputs; ++i)
      if (info->out[i].sn == TGSI_SEMANTIC_COLOR)
         for (c = 0; c < 4; ++c)
            info->out[i].slot[c] = info->out[i].si * 4 + c;

   if (info->io.sampleMask < PIPE_MAX_SHADER_OUTPUTS)
      info->out[info->io.sampleMask].slot[0] = count++;
   else
   if (info->target >= 0xe0)
      count++; /* on Kepler, depth is always last colour reg + 2 */

   if (info->io.fragDepth < PIPE_MAX_SHADER_OUTPUTS)
      info->out[info->io.fragDepth].slot[2] = count;

   return 0;
}

static int
nvc0_sp_assign_output_slots(struct nv50_ir_prog_info *info)
{
   unsigned ubase = MAX2(0x80, 0x20 + info->numPatchConstants * 0x10);
   unsigned offset;
   unsigned i, c;

   for (i = 0; i < info->numOutputs; ++i) {
      offset = nvc0_shader_output_address(info->out[i].sn,
                                          info->out[i].si, ubase);
      if (info->out[i].patch && offset >= 0x20)
         offset = 0x20 + info->out[i].si * 0x10;

      for (c = 0; c < 4; ++c)
         info->out[i].slot[c] = (offset + c * 0x4) / 4;
   }

   return 0;
}

static int
nvc0_program_assign_varying_slots(struct nv50_ir_prog_info *info)
{
   int ret;

   if (info->type == PIPE_SHADER_VERTEX)
      ret = nvc0_vp_assign_input_slots(info);
   else
      ret = nvc0_sp_assign_input_slots(info);
   if (ret)
      return ret;

   if (info->type == PIPE_SHADER_FRAGMENT)
      ret = nvc0_fp_assign_output_slots(info);
   else
      ret = nvc0_sp_assign_output_slots(info);
   return ret;
}

static INLINE void
nvc0_vtgp_hdr_update_oread(struct nvc0_program *vp, uint8_t slot)
{
   uint8_t min = (vp->hdr[4] >> 12) & 0xff;
   uint8_t max = (vp->hdr[4] >> 24);

   min = MIN2(min, slot);
   max = MAX2(max, slot);

   vp->hdr[4] = (max << 24) | (min << 12);
}

/* Common part of header generation for VP, TCP, TEP and GP. */
static int
nvc0_vtgp_gen_header(struct nvc0_program *vp, struct nv50_ir_prog_info *info)
{
   unsigned i, c, a;

   for (i = 0; i < info->numInputs; ++i) {
      if (info->in[i].patch)
         continue;
      for (c = 0; c < 4; ++c) {
         a = info->in[i].slot[c];
         if (info->in[i].mask & (1 << c)) {
            if (info->in[i].sn != NV50_SEMANTIC_TESSCOORD)
               vp->hdr[5 + a / 32] |= 1 << (a % 32);
            else
               nvc0_vtgp_hdr_update_oread(vp, info->in[i].slot[c]);
         }
      }
   }

   for (i = 0; i < info->numOutputs; ++i) {
      if (info->out[i].patch)
         continue;
      for (c = 0; c < 4; ++c) {
         if (!(info->out[i].mask & (1 << c)))
            continue;
         assert(info->out[i].slot[c] >= 0x40 / 4);
         a = info->out[i].slot[c] - 0x40 / 4;
         vp->hdr[13 + a / 32] |= 1 << (a % 32);
         if (info->out[i].oread)
            nvc0_vtgp_hdr_update_oread(vp, info->out[i].slot[c]);
      }
   }

   for (i = 0; i < info->numSysVals; ++i) {
      switch (info->sv[i].sn) {
      case TGSI_SEMANTIC_PRIMID:
         vp->hdr[5] |= 1 << 24;
         break;
      case TGSI_SEMANTIC_INSTANCEID:
         vp->hdr[10] |= 1 << 30;
         break;
      case TGSI_SEMANTIC_VERTEXID:
         vp->hdr[10] |= 1 << 31;
         break;
      default:
         break;
      }
   }

   vp->vp.clip_enable = info->io.clipDistanceMask;
   for (i = 0; i < 8; ++i)
      if (info->io.cullDistanceMask & (1 << i))
         vp->vp.clip_mode |= 1 << (i * 4);

   if (info->io.genUserClip < 0)
      vp->vp.num_ucps = PIPE_MAX_CLIP_PLANES + 1; /* prevent rebuilding */

   return 0;
}

static int
nvc0_vp_gen_header(struct nvc0_program *vp, struct nv50_ir_prog_info *info)
{
   vp->hdr[0] = 0x20061 | (1 << 10);
   vp->hdr[4] = 0xff000;

   vp->hdr[18] = info->io.clipDistanceMask;

   return nvc0_vtgp_gen_header(vp, info);
}

#if defined(PIPE_SHADER_HULL) || defined(PIPE_SHADER_DOMAIN)
static void
nvc0_tp_get_tess_mode(struct nvc0_program *tp, struct nv50_ir_prog_info *info)
{
   if (info->prop.tp.outputPrim == PIPE_PRIM_MAX) {
      tp->tp.tess_mode = ~0;
      return;
   }
   switch (info->prop.tp.domain) {
   case PIPE_PRIM_LINES:
      tp->tp.tess_mode = NVC0_3D_TESS_MODE_PRIM_ISOLINES;
      break;
   case PIPE_PRIM_TRIANGLES:
      tp->tp.tess_mode = NVC0_3D_TESS_MODE_PRIM_TRIANGLES;
      if (info->prop.tp.winding > 0)
         tp->tp.tess_mode |= NVC0_3D_TESS_MODE_CW;
      break;
   case PIPE_PRIM_QUADS:
      tp->tp.tess_mode = NVC0_3D_TESS_MODE_PRIM_QUADS;
      break;
   default:
      tp->tp.tess_mode = ~0;
      return;
   }
   if (info->prop.tp.outputPrim != PIPE_PRIM_POINTS)
      tp->tp.tess_mode |= NVC0_3D_TESS_MODE_CONNECTED;

   switch (info->prop.tp.partitioning) {
   case PIPE_TESS_PART_INTEGER:
   case PIPE_TESS_PART_POW2:
      tp->tp.tess_mode |= NVC0_3D_TESS_MODE_SPACING_EQUAL;
      break;
   case PIPE_TESS_PART_FRACT_ODD:
      tp->tp.tess_mode |= NVC0_3D_TESS_MODE_SPACING_FRACTIONAL_ODD;
      break;
   case PIPE_TESS_PART_FRACT_EVEN:
      tp->tp.tess_mode |= NVC0_3D_TESS_MODE_SPACING_FRACTIONAL_EVEN;
      break;
   default:
      assert(!"invalid tessellator partitioning");
      break;
   }
}
#endif

#ifdef PIPE_SHADER_HULL
static int
nvc0_tcp_gen_header(struct nvc0_program *tcp, struct nv50_ir_prog_info *info)
{
   unsigned opcs = 6; /* output patch constants (at least the TessFactors) */

   tcp->tp.input_patch_size = info->prop.tp.inputPatchSize;

   if (info->numPatchConstants)
      opcs = 8 + info->numPatchConstants * 4;

   tcp->hdr[0] = 0x20061 | (2 << 10);

   tcp->hdr[1] = opcs << 24;
   tcp->hdr[2] = info->prop.tp.outputPatchSize << 24;

   tcp->hdr[4] = 0xff000; /* initial min/max parallel output read address */

   nvc0_vtgp_gen_header(tcp, info);

   nvc0_tp_get_tess_mode(tcp, info);

   return 0;
}
#endif

#ifdef PIPE_SHADER_DOMAIN
static int
nvc0_tep_gen_header(struct nvc0_program *tep, struct nv50_ir_prog_info *info)
{
   tep->tp.input_patch_size = ~0;

   tep->hdr[0] = 0x20061 | (3 << 10);
   tep->hdr[4] = 0xff000;

   nvc0_vtgp_gen_header(tep, info);

   nvc0_tp_get_tess_mode(tep, info);

   tep->hdr[18] |= 0x3 << 12; /* ? */

   return 0;
}
#endif

static int
nvc0_gp_gen_header(struct nvc0_program *gp, struct nv50_ir_prog_info *info)
{
   gp->hdr[0] = 0x20061 | (4 << 10);

   gp->hdr[2] = MIN2(info->prop.gp.instanceCount, 32) << 24;

   switch (info->prop.gp.outputPrim) {
   case PIPE_PRIM_POINTS:
      gp->hdr[3] = 0x01000000;
      gp->hdr[0] |= 0xf0000000;
      break;
   case PIPE_PRIM_LINE_STRIP:
      gp->hdr[3] = 0x06000000;
      gp->hdr[0] |= 0x10000000;
      break;
   case PIPE_PRIM_TRIANGLE_STRIP:
      gp->hdr[3] = 0x07000000;
      gp->hdr[0] |= 0x10000000;
      break;
   default:
      assert(0);
      break;
   }

   gp->hdr[4] = info->prop.gp.maxVertices & 0x1ff;

   return nvc0_vtgp_gen_header(gp, info);
}

#define NVC0_INTERP_FLAT          (1 << 0)
#define NVC0_INTERP_PERSPECTIVE   (2 << 0)
#define NVC0_INTERP_LINEAR        (3 << 0)
#define NVC0_INTERP_CENTROID      (1 << 2)

static uint8_t
nvc0_hdr_interp_mode(const struct nv50_ir_varying *var)
{
   if (var->linear)
      return NVC0_INTERP_LINEAR;
   if (var->flat)
      return NVC0_INTERP_FLAT;
   return NVC0_INTERP_PERSPECTIVE;
}

static int
nvc0_fp_gen_header(struct nvc0_program *fp, struct nv50_ir_prog_info *info)
{
   unsigned i, c, a, m;

   /* just 00062 on Kepler */
   fp->hdr[0] = 0x20062 | (5 << 10);
   fp->hdr[5] = 0x80000000; /* getting a trap if FRAG_COORD_UMASK.w = 0 */

   if (info->prop.fp.usesDiscard)
      fp->hdr[0] |= 0x8000;
   if (info->prop.fp.numColourResults > 1)
      fp->hdr[0] |= 0x4000;
   if (info->io.sampleMask < PIPE_MAX_SHADER_OUTPUTS)
      fp->hdr[19] |= 0x1;
   if (info->prop.fp.writesDepth) {
      fp->hdr[19] |= 0x2;
      fp->flags[0] = 0x11; /* deactivate ZCULL */
   }

   for (i = 0; i < info->numInputs; ++i) {
      m = nvc0_hdr_interp_mode(&info->in[i]);
      for (c = 0; c < 4; ++c) {
         if (!(info->in[i].mask & (1 << c)))
            continue;
         a = info->in[i].slot[c];
         if (info->in[i].slot[0] >= (0x060 / 4) &&
             info->in[i].slot[0] <= (0x07c / 4)) {
            fp->hdr[5] |= 1 << (24 + (a - 0x060 / 4));
         } else
         if (info->in[i].slot[0] >= (0x2c0 / 4) &&
             info->in[i].slot[0] <= (0x2fc / 4)) {
            fp->hdr[14] |= (1 << (a - 0x280 / 4)) & 0x07ff0000;
         } else {
            if (info->in[i].slot[c] < (0x040 / 4) ||
                info->in[i].slot[c] > (0x380 / 4))
               continue;
            a *= 2;
            if (info->in[i].slot[0] >= (0x300 / 4))
               a -= 32;
            fp->hdr[4 + a / 32] |= m << (a % 32);
         }
      }
   }

   for (i = 0; i < info->numOutputs; ++i) {
      if (info->out[i].sn == TGSI_SEMANTIC_COLOR)
         fp->hdr[18] |= info->out[i].mask << info->out[i].slot[0];
   }

   fp->fp.early_z = info->prop.fp.earlyFragTests;

   return 0;
}

static struct nvc0_transform_feedback_state *
nvc0_program_create_tfb_state(const struct nv50_ir_prog_info *info,
                              const struct pipe_stream_output_info *pso)
{
   struct nvc0_transform_feedback_state *tfb;
   unsigned b, i, c;

   tfb = MALLOC_STRUCT(nvc0_transform_feedback_state);
   if (!tfb)
      return NULL;
   for (b = 0; b < 4; ++b) {
      tfb->stride[b] = pso->stride[b] * 4;
      tfb->varying_count[b] = 0;
   }
   memset(tfb->varying_index, 0xff, sizeof(tfb->varying_index)); /* = skip */

   for (i = 0; i < pso->num_outputs; ++i) {
      unsigned s = pso->output[i].start_component;
      unsigned p = pso->output[i].dst_offset;
      b = pso->output[i].output_buffer;

      for (c = 0; c < pso->output[i].num_components; ++c)
         tfb->varying_index[b][p++] =
            info->out[pso->output[i].register_index].slot[s + c];

      tfb->varying_count[b] = MAX2(tfb->varying_count[b], p);
   }
   for (b = 0; b < 4; ++b) // zero unused indices (looks nicer)
      for (c = tfb->varying_count[b]; c & 3; ++c)
         tfb->varying_index[b][c] = 0;

   return tfb;
}

#ifdef DEBUG
static void
nvc0_program_dump(struct nvc0_program *prog)
{
   unsigned pos;

   if (prog->type != PIPE_SHADER_COMPUTE) {
      for (pos = 0; pos < sizeof(prog->hdr) / sizeof(prog->hdr[0]); ++pos)
         debug_printf("HDR[%02lx] = 0x%08x\n",
                      pos * sizeof(prog->hdr[0]), prog->hdr[pos]);
   }
   debug_printf("shader binary code (0x%x bytes):", prog->code_size);
   for (pos = 0; pos < prog->code_size / 4; ++pos) {
      if ((pos % 8) == 0)
         debug_printf("\n");
      debug_printf("%08x ", prog->code[pos]);
   }
   debug_printf("\n");
}
#endif

boolean
nvc0_program_translate(struct nvc0_program *prog, uint16_t chipset)
{
   struct nv50_ir_prog_info *info;
   int ret;

   info = CALLOC_STRUCT(nv50_ir_prog_info);
   if (!info)
      return FALSE;

   info->type = prog->type;
   info->target = chipset;
   info->bin.sourceRep = NV50_PROGRAM_IR_TGSI;
   info->bin.source = (void *)prog->pipe.tokens;

   info->io.genUserClip = prog->vp.num_ucps;
   info->io.ucpBase = 256;
   info->io.ucpCBSlot = 15;

   if (prog->type == PIPE_SHADER_COMPUTE) {
      if (chipset >= NVISA_GK104_CHIPSET) {
         info->io.resInfoCBSlot = 0;
         info->io.texBindBase = NVE4_CP_INPUT_TEX(0);
         info->io.suInfoBase = NVE4_CP_INPUT_SUF(0);
         info->prop.cp.gridInfoBase = NVE4_CP_INPUT_GRID_INFO(0);
      }
      info->io.msInfoCBSlot = 0;
      info->io.msInfoBase = NVE4_CP_INPUT_MS_OFFSETS;
   } else {
      if (chipset >= NVISA_GK104_CHIPSET) {
         info->io.resInfoCBSlot = 15;
         info->io.texBindBase = 0x20;
         info->io.suInfoBase = 0; /* TODO */
      }
      info->io.msInfoCBSlot = 15;
      info->io.msInfoBase = 0; /* TODO */
   }

   info->assignSlots = nvc0_program_assign_varying_slots;

#ifdef DEBUG
   info->optLevel = debug_get_num_option("NV50_PROG_OPTIMIZE", 3);
   info->dbgFlags = debug_get_num_option("NV50_PROG_DEBUG", 0);
#else
   info->optLevel = 3;
#endif

   ret = nv50_ir_generate_code(info);
   if (ret) {
      NOUVEAU_ERR("shader translation failed: %i\n", ret);
      goto out;
   }
   if (prog->type != PIPE_SHADER_COMPUTE)
      FREE(info->bin.syms);

   prog->code = info->bin.code;
   prog->code_size = info->bin.codeSize;
   prog->immd_data = info->immd.buf;
   prog->immd_size = info->immd.bufSize;
   prog->relocs = info->bin.relocData;
   prog->num_gprs = MAX2(4, (info->bin.maxGPR + 1));
   prog->num_barriers = info->numBarriers;

   prog->vp.need_vertex_id = info->io.vertexId < PIPE_MAX_SHADER_INPUTS;

   if (info->io.edgeFlagOut < PIPE_MAX_ATTRIBS)
      info->out[info->io.edgeFlagOut].mask = 0; /* for headergen */
   prog->vp.edgeflag = info->io.edgeFlagIn;

   switch (prog->type) {
   case PIPE_SHADER_VERTEX:
      ret = nvc0_vp_gen_header(prog, info);
      break;
#ifdef PIPE_SHADER_HULL
   case PIPE_SHADER_HULL:
      ret = nvc0_tcp_gen_header(prog, info);
      break;
#endif
#ifdef PIPE_SHADER_DOMAIN
   case PIPE_SHADER_DOMAIN:
      ret = nvc0_tep_gen_header(prog, info);
      break;
#endif
   case PIPE_SHADER_GEOMETRY:
      ret = nvc0_gp_gen_header(prog, info);
      break;
   case PIPE_SHADER_FRAGMENT:
      ret = nvc0_fp_gen_header(prog, info);
      break;
   case PIPE_SHADER_COMPUTE:
      prog->cp.syms = info->bin.syms;
      prog->cp.num_syms = info->bin.numSyms;
      break;
   default:
      ret = -1;
      NOUVEAU_ERR("unknown program type: %u\n", prog->type);
      break;
   }
   if (ret)
      goto out;

   if (info->bin.tlsSpace) {
      assert(info->bin.tlsSpace < (1 << 24));
      prog->hdr[0] |= 1 << 26;
      prog->hdr[1] |= info->bin.tlsSpace; /* l[] size */
      prog->need_tls = TRUE;
   }
   /* TODO: factor 2 only needed where joinat/precont is used,
    *       and we only have to count non-uniform branches
    */
   /*
   if ((info->maxCFDepth * 2) > 16) {
      prog->hdr[2] |= (((info->maxCFDepth * 2) + 47) / 48) * 0x200;
      prog->need_tls = TRUE;
   }
   */
   if (info->io.globalAccess)
      prog->hdr[0] |= 1 << 16;

   if (prog->pipe.stream_output.num_outputs)
      prog->tfb = nvc0_program_create_tfb_state(info,
                                                &prog->pipe.stream_output);

out:
   FREE(info);
   return !ret;
}

boolean
nvc0_program_upload_code(struct nvc0_context *nvc0, struct nvc0_program *prog)
{
   struct nvc0_screen *screen = nvc0->screen;
   const boolean is_cp = prog->type == PIPE_SHADER_COMPUTE;
   int ret;
   uint32_t size = prog->code_size + (is_cp ? 0 : NVC0_SHADER_HEADER_SIZE);
   uint32_t lib_pos = screen->lib_code->start;
   uint32_t code_pos;

   /* c[] bindings need to be aligned to 0x100, but we could use relocations
    * to save space. */
   if (prog->immd_size) {
      prog->immd_base = size;
      size = align(size, 0x40);
      size += prog->immd_size + 0xc0; /* add 0xc0 for align 0x40 -> 0x100 */
   }
   /* On Fermi, SP_START_ID must be aligned to 0x40.
    * On Kepler, the first instruction must be aligned to 0x80 because
    * latency information is expected only at certain positions.
    */
   if (screen->base.class_3d >= NVE4_3D_CLASS)
      size = size + (is_cp ? 0x40 : 0x70);
   size = align(size, 0x40);

   ret = nouveau_heap_alloc(screen->text_heap, size, prog, &prog->mem);
   if (ret) {
      struct nouveau_heap *heap = screen->text_heap;
      struct nouveau_heap *iter;
      for (iter = heap; iter && iter->next != heap; iter = iter->next) {
         struct nvc0_program *evict = iter->priv;
         if (evict)
            nouveau_heap_free(&evict->mem);
      }
      debug_printf("WARNING: out of code space, evicting all shaders.\n");
      ret = nouveau_heap_alloc(heap, size, prog, &prog->mem);
      if (ret) {
         NOUVEAU_ERR("shader too large (0x%x) to fit in code space ?\n", size);
         return FALSE;
      }
      IMMED_NVC0(nvc0->base.pushbuf, NVC0_3D(SERIALIZE), 0);
   }
   prog->code_base = prog->mem->start;
   prog->immd_base = align(prog->mem->start + prog->immd_base, 0x100);
   assert((prog->immd_size == 0) || (prog->immd_base + prog->immd_size <=
                                     prog->mem->start + prog->mem->size));

   if (!is_cp) {
      if (screen->base.class_3d >= NVE4_3D_CLASS) {
         switch (prog->mem->start & 0xff) {
         case 0x40: prog->code_base += 0x70; break;
         case 0x80: prog->code_base += 0x30; break;
         case 0xc0: prog->code_base += 0x70; break;
         default:
            prog->code_base += 0x30;
            assert((prog->mem->start & 0xff) == 0x00);
            break;
         }
      }
      code_pos = prog->code_base + NVC0_SHADER_HEADER_SIZE;
   } else {
      if (screen->base.class_3d >= NVE4_3D_CLASS) {
         if (prog->mem->start & 0x40)
            prog->code_base += 0x40;
         assert((prog->code_base & 0x7f) == 0x00);
      }
      code_pos = prog->code_base;
   }

   if (prog->relocs)
      nv50_ir_relocate_code(prog->relocs, prog->code, code_pos, lib_pos, 0);

#ifdef DEBUG
   if (debug_get_bool_option("NV50_PROG_DEBUG", FALSE))
      nvc0_program_dump(prog);
#endif

   if (!is_cp)
      nvc0->base.push_data(&nvc0->base, screen->text, prog->code_base,
                           NOUVEAU_BO_VRAM, NVC0_SHADER_HEADER_SIZE, prog->hdr);
   nvc0->base.push_data(&nvc0->base, screen->text, code_pos,
                        NOUVEAU_BO_VRAM, prog->code_size, prog->code);
   if (prog->immd_size)
      nvc0->base.push_data(&nvc0->base,
                           screen->text, prog->immd_base, NOUVEAU_BO_VRAM,
                           prog->immd_size, prog->immd_data);

   BEGIN_NVC0(nvc0->base.pushbuf, NVC0_3D(MEM_BARRIER), 1);
   PUSH_DATA (nvc0->base.pushbuf, 0x1011);

   return TRUE;
}

/* Upload code for builtin functions like integer division emulation. */
void
nvc0_program_library_upload(struct nvc0_context *nvc0)
{
   struct nvc0_screen *screen = nvc0->screen;
   int ret;
   uint32_t size;
   const uint32_t *code;

   if (screen->lib_code)
      return;

   nv50_ir_get_target_library(screen->base.device->chipset, &code, &size);
   if (!size)
      return;

   ret = nouveau_heap_alloc(screen->text_heap, align(size, 0x100), NULL,
                            &screen->lib_code);
   if (ret)
      return;

   nvc0->base.push_data(&nvc0->base,
                        screen->text, screen->lib_code->start, NOUVEAU_BO_VRAM,
                        size, code);
   /* no need for a memory barrier, will be emitted with first program */
}

void
nvc0_program_destroy(struct nvc0_context *nvc0, struct nvc0_program *prog)
{
   const struct pipe_shader_state pipe = prog->pipe;
   const ubyte type = prog->type;

   if (prog->mem)
      nouveau_heap_free(&prog->mem);
   if (prog->code)
      FREE(prog->code); /* may be 0 for hardcoded shaders */
   FREE(prog->immd_data);
   FREE(prog->relocs);
   if (prog->type == PIPE_SHADER_COMPUTE && prog->cp.syms)
      FREE(prog->cp.syms);
   if (prog->tfb) {
      if (nvc0->state.tfb == prog->tfb)
         nvc0->state.tfb = NULL;
      FREE(prog->tfb);
   }

   memset(prog, 0, sizeof(*prog));

   prog->pipe = pipe;
   prog->type = type;
}

uint32_t
nvc0_program_symbol_offset(const struct nvc0_program *prog, uint32_t label)
{
   const struct nv50_ir_prog_symbol *syms =
      (const struct nv50_ir_prog_symbol *)prog->cp.syms;
   unsigned base = 0;
   unsigned i;
   if (prog->type != PIPE_SHADER_COMPUTE)
      base = NVC0_SHADER_HEADER_SIZE;
   for (i = 0; i < prog->cp.num_syms; ++i)
      if (syms[i].label == label)
         return prog->code_base + base + syms[i].offset;
   return prog->code_base; /* no symbols or symbol not found */
}
@


1.2
log
@Merge Mesa 9.2.0
@
text
@@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d17 4
a20 4
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
a22 1
#include "pipe/p_shader_tokens.h"
d25 4
a28 3
#include "tgsi/tgsi_parse.h"
#include "tgsi/tgsi_util.h"
#include "tgsi/tgsi_dump.h"
d30 55
a84 2
#include "nvc0_context.h"
#include "nvc0_pc.h"
d86 2
a87 2
static unsigned
nvc0_tgsi_src_mask(const struct tgsi_full_instruction *inst, int c)
d89 1
a89 1
   unsigned mask = inst->Dst[0].Register.WriteMask;
d91 8
a98 50
   switch (inst->Instruction.Opcode) {
   case TGSI_OPCODE_COS:
   case TGSI_OPCODE_SIN:
      return (mask & 0x8) | ((mask & 0x7) ? 0x1 : 0x0);
   case TGSI_OPCODE_DP3:
      return 0x7;
   case TGSI_OPCODE_DP4:
   case TGSI_OPCODE_DPH:
   case TGSI_OPCODE_KIL: /* WriteMask ignored */
      return 0xf;
   case TGSI_OPCODE_DST:
      return mask & (c ? 0xa : 0x6);
   case TGSI_OPCODE_EX2:
   case TGSI_OPCODE_EXP:
   case TGSI_OPCODE_LG2:
   case TGSI_OPCODE_LOG:
   case TGSI_OPCODE_POW:
   case TGSI_OPCODE_RCP:
   case TGSI_OPCODE_RSQ:
   case TGSI_OPCODE_SCS:
      return 0x1;
   case TGSI_OPCODE_IF:
      return 0x1;
   case TGSI_OPCODE_LIT:
      return 0xb;
   case TGSI_OPCODE_TEX:
   case TGSI_OPCODE_TXB:
   case TGSI_OPCODE_TXL:
   case TGSI_OPCODE_TXP:
   {
      const struct tgsi_instruction_texture *tex;

      assert(inst->Instruction.Texture);
      tex = &inst->Texture;

      mask = 0x7;
      if (inst->Instruction.Opcode != TGSI_OPCODE_TEX &&
          inst->Instruction.Opcode != TGSI_OPCODE_TXD)
         mask |= 0x8; /* bias, lod or proj */

      switch (tex->Texture) {
      case TGSI_TEXTURE_1D:
         mask &= 0x9;
         break;
      case TGSI_TEXTURE_SHADOW1D:
         mask &= 0x5;
         break;
      case TGSI_TEXTURE_2D:
         mask &= 0xb;
         break;
d102 3
a104 12
   }
  	   return mask;
   case TGSI_OPCODE_XPD:
   {
      unsigned x = 0;
      if (mask & 1) x |= 0x6;
      if (mask & 2) x |= 0x5;
      if (mask & 4) x |= 0x3;
      return x;
   }
   default:
      break;
d107 1
a107 1
   return mask;
d110 2
a111 2
static void
nvc0_indirect_inputs(struct nvc0_translation_info *ti, int id)
d113 12
a124 1
   int i, c;
a125 1
   for (i = 0; i < PIPE_MAX_SHADER_INPUTS; ++i)
d127 2
a128 1
         ti->input_access[i][c] = id;
d130 1
a130 1
   ti->indirect_inputs = TRUE;
d133 2
a134 2
static void
nvc0_indirect_outputs(struct nvc0_translation_info *ti, int id)
d136 2
a137 1
   int i, c;
d139 13
a151 3
   for (i = 0; i < PIPE_MAX_SHADER_OUTPUTS; ++i)
      for (c = 0; c < 4; ++c)
         ti->output_access[i][c] = id;
d153 1
a153 1
   ti->indirect_outputs = TRUE;
d156 2
a157 2
static INLINE unsigned
nvc0_system_value_location(unsigned sn, unsigned si, boolean *is_input)
d159 12
a170 29
   /* NOTE: locations 0xfxx indicate special regs */
   switch (sn) {
      /*
   case TGSI_SEMANTIC_VERTEXID:
      *is_input = TRUE;
      return 0x2fc;
      */
   case TGSI_SEMANTIC_PRIMID:
      *is_input = TRUE;
      return 0x60;
      /*
   case TGSI_SEMANTIC_LAYER_INDEX:
      return 0x64;
   case TGSI_SEMANTIC_VIEWPORT_INDEX:
      return 0x68;
      */
   case TGSI_SEMANTIC_INSTANCEID:
      *is_input = TRUE;
      return 0x2f8;
   case TGSI_SEMANTIC_FACE:
      *is_input = TRUE;
      return 0x3fc;
      /*
   case TGSI_SEMANTIC_INVOCATIONID:
      return 0xf11;
      */
   default:
      assert(0);
      return 0x000;
a171 1
}
d173 1
a173 46
static INLINE unsigned
nvc0_varying_location(unsigned sn, unsigned si)
{
   switch (sn) {
   case TGSI_SEMANTIC_POSITION:
      return 0x70;
   case TGSI_SEMANTIC_COLOR:
      return 0x280 + (si * 16); /* are these hard-wired ? */
   case TGSI_SEMANTIC_BCOLOR:
      return 0x2a0 + (si * 16);
   case TGSI_SEMANTIC_FOG:
      return 0x270;
   case TGSI_SEMANTIC_PSIZE:
      return 0x6c;
      /*
   case TGSI_SEMANTIC_PNTC:
      return 0x2e0;
      */
   case TGSI_SEMANTIC_GENERIC:
      /* We'd really like to distinguish between TEXCOORD and GENERIC here,
       * since only 0x300 to 0x37c can be replaced by sprite coordinates.
       * Also, gl_PointCoord should be a system value and must be assigned to
       * address 0x2e0. For now, let's cheat:
       */
      assert(si < 31);
      if (si <= 7)
         return 0x300 + si * 16;
      if (si == 9)
         return 0x2e0;
      return 0x80 + ((si - 8) * 16);
   case TGSI_SEMANTIC_NORMAL:
      return 0x360;
   case TGSI_SEMANTIC_PRIMID:
      return 0x40;
   case TGSI_SEMANTIC_FACE:
      return 0x3fc;
   case TGSI_SEMANTIC_EDGEFLAG: /* doesn't exist, set value like for an sreg */
      return 0xf00;
      /*
   case TGSI_SEMANTIC_CLIP_DISTANCE:
      return 0x2c0 + (si * 4);
      */
   default:
      assert(0);
      return 0x000;
   }
d176 2
a177 2
static INLINE unsigned
nvc0_interp_mode(const struct tgsi_full_declaration *decl)
d179 1
a179 1
   unsigned mode;
d181 2
a182 2
   if (decl->Declaration.Interpolate == TGSI_INTERPOLATE_CONSTANT)
      mode = NVC0_INTERP_FLAT;
d184 6
a189 2
   if (decl->Declaration.Interpolate == TGSI_INTERPOLATE_PERSPECTIVE)
      mode = NVC0_INTERP_PERSPECTIVE;
d191 2
a192 9
   if (decl->Declaration.Semantic && decl->Semantic.Name == TGSI_SEMANTIC_COLOR)
      mode = NVC0_INTERP_PERSPECTIVE;
   else
      mode = NVC0_INTERP_LINEAR;

   if (decl->Declaration.Centroid)
      mode |= NVC0_INTERP_CENTROID;

   return mode;
d195 2
a196 3
static void
prog_immediate(struct nvc0_translation_info *ti,
               const struct tgsi_full_immediate *imm)
d198 2
a199 2
   int c;
   unsigned n = ti->immd32_nr++;
d201 2
a202 1
   assert(ti->immd32_nr <= ti->scan.immediate_count);
d204 1
a204 4
   for (c = 0; c < 4; ++c)
      ti->immd32[n * 4 + c] = imm->u[c].Uint;

   ti->immd32_ty[n] = imm->Immediate.DataType;
d207 3
a209 3
static boolean
prog_decl(struct nvc0_translation_info *ti,
          const struct tgsi_full_declaration *decl)
d211 12
a222 22
   unsigned i, c;
   unsigned sn = TGSI_SEMANTIC_GENERIC;
   unsigned si = 0;
   const unsigned first = decl->Range.First;
   const unsigned last = decl->Range.Last;

   if (decl->Declaration.Semantic) {
      sn = decl->Semantic.Name;
      si = decl->Semantic.Index;
   }
   
   switch (decl->Declaration.File) {
   case TGSI_FILE_INPUT:
      for (i = first; i <= last; ++i) {
         if (ti->prog->type == PIPE_SHADER_VERTEX) {
            for (c = 0; c < 4; ++c)
               ti->input_loc[i][c] = 0x80 + i * 16 + c * 4;
         } else {
            for (c = 0; c < 4; ++c)
               ti->input_loc[i][c] = nvc0_varying_location(sn, si) + c * 4;
            /* for sprite coordinates: */
            ti->prog->fp.in_pos[i] = ti->input_loc[i][0] / 4;
a223 2
         if (ti->prog->type == PIPE_SHADER_FRAGMENT)
            ti->interp_mode[i] = nvc0_interp_mode(decl);
d225 13
a237 21
      break;
   case TGSI_FILE_OUTPUT:
      for (i = first; i <= last; ++i, ++si) {
         if (ti->prog->type == PIPE_SHADER_FRAGMENT) {
            si = i;
            if (i == ti->fp_depth_output) {
               ti->output_loc[i][2] = (ti->scan.num_outputs - 1) * 4;
            } else {
               if (i > ti->fp_depth_output)
                  si -= 1;
               for (c = 0; c < 4; ++c)
                  ti->output_loc[i][c] = si * 4 + c;
            }
         } else {
            if (sn == TGSI_SEMANTIC_EDGEFLAG)
               ti->edgeflag_out = i;
            for (c = 0; c < 4; ++c)
               ti->output_loc[i][c] = nvc0_varying_location(sn, si) + c * 4;
            /* for TFB_VARYING_LOCS: */
            ti->prog->vp.out_pos[i] = ti->output_loc[i][0] / 4;
         }
a238 19
      break;
   case TGSI_FILE_SYSTEM_VALUE:
      i = first;
      ti->sysval_loc[i] = nvc0_system_value_location(sn, si, &ti->sysval_in[i]);
      assert(first == last);
      break;
   case TGSI_FILE_TEMPORARY:
      ti->temp128_nr = MAX2(ti->temp128_nr, last + 1);
      break;
   case TGSI_FILE_NULL:
   case TGSI_FILE_CONSTANT:
   case TGSI_FILE_SAMPLER:
   case TGSI_FILE_ADDRESS:
   case TGSI_FILE_IMMEDIATE:
   case TGSI_FILE_PREDICATE:
      break;
   default:
      NOUVEAU_ERR("unhandled TGSI_FILE %d\n", decl->Declaration.File);
      return FALSE;
a239 2
   return TRUE;
}
d241 14
a254 13
static void
prog_inst(struct nvc0_translation_info *ti,
          const struct tgsi_full_instruction *inst, int id)
{
   const struct tgsi_dst_register *dst;
   const struct tgsi_src_register *src;
   int s, c, k;
   unsigned mask;

   if (inst->Instruction.Opcode == TGSI_OPCODE_BGNSUB) {
      ti->subr[ti->num_subrs].first_insn = id - 1;
      ti->subr[ti->num_subrs].id = ti->num_subrs + 1; /* id 0 is main program */
      ++ti->num_subrs;
d257 4
a260 2
   if (inst->Dst[0].Register.File == TGSI_FILE_OUTPUT) {
      dst = &inst->Dst[0].Register;
d262 5
a266 7
      for (c = 0; c < 4; ++c) {
         if (dst->Indirect)
            nvc0_indirect_outputs(ti, id);
         if (!(dst->WriteMask & (1 << c)))
            continue;
         ti->output_access[dst->Index][c] = id;
      }
d268 5
a272 18
      if (inst->Instruction.Opcode == TGSI_OPCODE_MOV &&
          inst->Src[0].Register.File == TGSI_FILE_INPUT &&
          dst->Index == ti->edgeflag_out)
         ti->prog->vp.edgeflag = inst->Src[0].Register.Index;
   } else
   if (inst->Dst[0].Register.File == TGSI_FILE_TEMPORARY) {
      if (inst->Dst[0].Register.Indirect)
         ti->require_stores = TRUE;
   }

   for (s = 0; s < inst->Instruction.NumSrcRegs; ++s) {
      src = &inst->Src[s].Register;
      if (src->File == TGSI_FILE_TEMPORARY)
         if (inst->Src[s].Register.Indirect)
            ti->require_stores = TRUE;
      if (src->File != TGSI_FILE_INPUT)
         continue;
      mask = nvc0_tgsi_src_mask(inst, s);
d274 1
a274 2
      if (inst->Src[s].Register.Indirect)
         nvc0_indirect_inputs(ti, id);
d276 1
a276 8
      for (c = 0; c < 4; ++c) {
         if (!(mask & (1 << c)))
            continue;
         k = tgsi_util_get_full_src_register_swizzle(&inst->Src[s], c);
         if (k <= TGSI_SWIZZLE_W)
            ti->input_access[src->Index][k] = id;
      }
   }
d279 1
a279 3
/* Probably should introduce something like struct tgsi_function_declaration
 * instead of trying to guess inputs/outputs.
 */
d281 1
a281 2
prog_subroutine_inst(struct nvc0_subroutine *subr,
                     const struct tgsi_full_instruction *inst)
d283 19
a301 18
   const struct tgsi_dst_register *dst;
   const struct tgsi_src_register *src;
   int s, c, k;
   unsigned mask;

   for (s = 0; s < inst->Instruction.NumSrcRegs; ++s) {
      src = &inst->Src[s].Register;
      if (src->File != TGSI_FILE_TEMPORARY)
         continue;
      mask = nvc0_tgsi_src_mask(inst, s);

      for (c = 0; c < 4; ++c) {
         k = tgsi_util_get_full_src_register_swizzle(&inst->Src[s], c);

         if ((mask & (1 << c)) && k < TGSI_SWIZZLE_W)
            if (!(subr->retv[src->Index / 32][k] & (1 << (src->Index % 32))))
               subr->argv[src->Index / 32][k] |= 1 << (src->Index % 32);
      }
d303 2
d306 14
a319 6
   if (inst->Dst[0].Register.File == TGSI_FILE_TEMPORARY) {
      dst = &inst->Dst[0].Register;

      for (c = 0; c < 4; ++c)
         if (dst->WriteMask & (1 << c))
            subr->retv[dst->Index / 32][c] |= 1 << (dst->Index % 32);
d322 1
d324 1
d326 1
a326 1
nvc0_vp_gp_gen_header(struct nvc0_program *vp, struct nvc0_translation_info *ti)
d328 1
a328 2
   int i, c;
   unsigned a;
d330 11
a340 5
   for (a = 0x80/4, i = 0; i <= ti->scan.file_max[TGSI_FILE_INPUT]; ++i) {
      for (c = 0; c < 4; ++c, ++a)
         if (ti->input_access[i][c])
            vp->hdr[5 + a / 32] |= 1 << (a % 32); /* VP_ATTR_EN */
   }
d342 1
a342 10
   for (i = 0; i <= ti->scan.file_max[TGSI_FILE_OUTPUT]; ++i) {
      a = (ti->output_loc[i][0] - 0x40) / 4;
      if (ti->output_loc[i][0] >= 0xf00)
         continue;
      for (c = 0; c < 4; ++c, ++a) {
         if (!ti->output_access[i][c])
            continue;
         vp->hdr[13 + a / 32] |= 1 << (a % 32); /* VP_EXPORT_EN */
      }
   }
d344 1
a344 5
   for (i = 0; i < TGSI_SEMANTIC_COUNT; ++i) {
      a = ti->sysval_loc[i] / 4;
      if (a > 0 && a < (0xf00 / 4))
         vp->hdr[(ti->sysval_in[i] ? 5 : 13) + a / 32] |= 1 << (a % 32);
   }
d348 1
d350 1
d352 1
a352 1
nvc0_vp_gen_header(struct nvc0_program *vp, struct nvc0_translation_info *ti)
d354 8
a361 2
   vp->hdr[0] = 0x20461;
   vp->hdr[4] = 0xff000;
d363 1
a363 1
   vp->hdr[18] = (1 << vp->vp.num_ucps) - 1;
d365 1
a365 1
   return nvc0_vp_gp_gen_header(vp, ti);
d367 1
d370 1
a370 1
nvc0_gp_gen_header(struct nvc0_program *gp, struct nvc0_translation_info *ti)
d372 1
a372 25
   unsigned invocations = 1;
   unsigned max_output_verts, output_prim;
   unsigned i;

   gp->hdr[0] = 0x21061;

   for (i = 0; i < ti->scan.num_properties; ++i) {
      switch (ti->scan.properties[i].name) {
      case TGSI_PROPERTY_GS_OUTPUT_PRIM:
         output_prim = ti->scan.properties[i].data[0];
         break;
      case TGSI_PROPERTY_GS_MAX_OUTPUT_VERTICES:
         max_output_verts = ti->scan.properties[i].data[0];
         assert(max_output_verts < 512);
         break;
         /*
      case TGSI_PROPERTY_GS_INVOCATIONS:
         invocations = ti->scan.properties[i].data[0];
         assert(invocations <= 32);
         break;
         */
      default:
         break;
      }
   }
d374 1
a374 1
   gp->hdr[2] = MIN2(invocations, 32) << 24;
d376 1
a376 1
   switch (output_prim) {
d394 1
a394 1
   gp->hdr[4] = max_output_verts & 0x1ff;
d396 16
a411 1
   return nvc0_vp_gp_gen_header(gp, ti);
d415 1
a415 1
nvc0_fp_gen_header(struct nvc0_program *fp, struct nvc0_translation_info *ti)
d417 4
a420 4
   int i, c;
   unsigned a, m;
   
   fp->hdr[0] = 0x21462;
d423 1
a423 1
   if (ti->scan.uses_kill)
d425 5
a429 1
   if (ti->scan.writes_z) {
d431 1
a431 5
      if (ti->scan.num_outputs > 2)
         fp->hdr[0] |= 0x4000; /* FP_MULTIPLE_COLOR_OUTPUTS */
   } else {
   if (ti->scan.num_outputs > 1)
      fp->hdr[0] |= 0x4000; /* FP_MULTIPLE_COLOR_OUTPUTS */
d434 2
a435 2
   for (i = 0; i <= ti->scan.file_max[TGSI_FILE_INPUT]; ++i) {
      m = ti->interp_mode[i] & 3;
d437 1
a437 1
         if (!ti->input_access[i][c])
d439 15
a453 9
         a = ti->input_loc[i][c] / 2;
         if (ti->input_loc[i][c] >= 0x2c0)
            a -= 32;
         if (ti->input_loc[i][0] == 0x70)
            fp->hdr[5] |= 1 << (28 + c); /* FRAG_COORD_UMASK */
         else
         if (ti->input_loc[i][0] == 0x2e0)
            fp->hdr[14] |= 1 << (24 + c); /* POINT_COORD */
         else
d455 1
d459 3
a461 3
   for (i = 0; i <= ti->scan.file_max[TGSI_FILE_OUTPUT]; ++i) {
      if (i != ti->fp_depth_output)
         fp->hdr[18] |= 0xf << ti->output_loc[i][0];
d464 1
a464 5
   for (i = 0; i < TGSI_SEMANTIC_COUNT; ++i) {
      a = ti->sysval_loc[i] / 2;
      if ((a > 0) && (a < 0xf00 / 2))
         fp->hdr[4 + a / 32] |= NVC0_INTERP_FLAT << (a % 32);
   }
d469 3
a471 2
static boolean
nvc0_prog_scan(struct nvc0_translation_info *ti)
d473 11
a483 4
   struct nvc0_program *prog = ti->prog;
   struct tgsi_parse_context parse;
   int ret;
   unsigned i;
d485 4
a488 3
#if NV50_DEBUG & NV50_DEBUG_SHADER
   tgsi_dump(prog->pipe.tokens, 0);
#endif
d490 3
a492 1
   tgsi_scan_shader(prog->pipe.tokens, &ti->scan);
d494 1
a494 5
   if (ti->prog->type == PIPE_SHADER_FRAGMENT) {
      ti->fp_depth_output = 255;
      for (i = 0; i < ti->scan.num_outputs; ++i)
         if (ti->scan.output_semantic_name[i] == TGSI_SEMANTIC_POSITION)
            ti->fp_depth_output = i;
d496 6
d503 5
a507 2
   ti->subr =
      CALLOC(ti->scan.opcode_count[TGSI_OPCODE_BGNSUB], sizeof(ti->subr[0]));
d509 14
a522 2
   ti->immd32 = (uint32_t *)MALLOC(ti->scan.immediate_count * 16);
   ti->immd32_ty = (ubyte *)MALLOC(ti->scan.immediate_count * sizeof(ubyte));
d524 5
a528 1
   ti->insns = MALLOC(ti->scan.num_instructions * sizeof(ti->insns[0]));
d530 3
a532 3
   tgsi_parse_init(&parse, prog->pipe.tokens);
   while (!tgsi_parse_end_of_tokens(&parse)) {
      tgsi_parse_token(&parse);
d534 23
a556 13
      switch (parse.FullToken.Token.Type) {
      case TGSI_TOKEN_TYPE_IMMEDIATE:
         prog_immediate(ti, &parse.FullToken.FullImmediate);
         break;
      case TGSI_TOKEN_TYPE_DECLARATION:
         prog_decl(ti, &parse.FullToken.FullDeclaration);
         break;
      case TGSI_TOKEN_TYPE_INSTRUCTION:
         ti->insns[ti->num_insns] = parse.FullToken.FullInstruction;
         prog_inst(ti, &parse.FullToken.FullInstruction, ++ti->num_insns);
         break;
      default:
         break;
d558 2
d562 13
a574 4
   for (i = 0; i < ti->num_subrs; ++i) {
      unsigned pc = ti->subr[i].id;
      while (ti->insns[pc].Instruction.Opcode != TGSI_OPCODE_ENDSUB)
         prog_subroutine_inst(&ti->subr[i], &ti->insns[pc++]);
d576 16
d595 1
a595 7
      ti->input_file = NV_FILE_MEM_A;
      ti->output_file = NV_FILE_MEM_V;
      ret = nvc0_vp_gen_header(prog, ti);
      break;
      /*
   case PIPE_SHADER_TESSELLATION_CONTROL:
      ret = nvc0_tcp_gen_header(ti);
d597 3
a599 2
   case PIPE_SHADER_TESSELLATION_EVALUATION:
      ret = nvc0_tep_gen_header(ti);
d601 6
d608 1
a608 1
      ret = nvc0_gp_gen_header(ti);
a609 1
      */
d611 5
a615 10
      ti->input_file = NV_FILE_MEM_V;
      ti->output_file = NV_FILE_GPR;

      if (ti->scan.writes_z)
         prog->flags[0] = 0x11; /* ? */
      else
      if (!ti->scan.uses_kill && !ti->global_stores)
         prog->fp.early_z = 1;

      ret = nvc0_fp_gen_header(prog, ti);
a617 1
      assert(!"unsupported program type");
d619 1
d622 2
d625 2
a626 1
   if (ti->require_stores) {
d628 2
a629 1
      prog->hdr[1] |= ti->temp128_nr * 16; /* l[] size */
d631 15
d647 3
a649 2
   assert(!ret);
   return ret;
d653 1
a653 1
nvc0_program_translate(struct nvc0_program *prog)
d655 2
a656 1
   struct nvc0_translation_info *ti;
d658 62
d721 2
a722 2
   ti = CALLOC_STRUCT(nvc0_translation_info);
   ti->prog = prog;
d724 4
a727 1
   ti->edgeflag_out = PIPE_MAX_SHADER_OUTPUTS;
d729 9
a737 1
   prog->vp.edgeflag = PIPE_MAX_ATTRIBS;
d739 14
a752 2
   if (prog->type == PIPE_SHADER_VERTEX && prog->vp.num_ucps)
      ti->append_ucp = TRUE;
d754 6
a759 5
   ret = nvc0_prog_scan(ti);
   if (ret) {
      NOUVEAU_ERR("unsupported shader program\n");
      goto out;
   }
d761 2
a762 1
   ret = nvc0_generate_code(ti);
d764 1
a764 8
      NOUVEAU_ERR("shader translation failed\n");

#if NV50_DEBUG & NV50_DEBUG_SHADER
   unsigned i;
   for (i = 0; i < sizeof(prog->hdr) / sizeof(prog->hdr[0]); ++i)
      debug_printf("HDR[%02lx] = 0x%08x\n",
                   i * sizeof(prog->hdr[0]), prog->hdr[i]);
#endif
d766 4
a769 11
out:
   if (ti->immd32)
      FREE(ti->immd32);
   if (ti->immd32_ty)
      FREE(ti->immd32_ty);
   if (ti->insns)
      FREE(ti->insns);
   if (ti->subr)
      FREE(ti->subr);
   FREE(ti);
   return ret ? FALSE : TRUE;
d775 2
a776 2
   if (prog->res)
      nouveau_resource_free(&prog->res);
d778 2
d781 10
a790 3
      FREE(prog->code);
   if (prog->relocs)
      FREE(prog->relocs);
d792 1
a792 1
   memset(prog->hdr, 0, sizeof(prog->hdr));
d794 17
a810 1
   prog->translated = FALSE;
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d17 4
a20 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d23 1
d26 4
d31 1
d33 4
a36 2
#include "nv50/codegen/nv50_ir_driver.h"
#include "nve4_compute.h"
d38 63
a100 25
/* NOTE: Using a[0x270] in FP may cause an error even if we're using less than
 * 124 scalar varying values.
 */
static uint32_t
nvc0_shader_input_address(unsigned sn, unsigned si, unsigned ubase)
{
   switch (sn) {
   case NV50_SEMANTIC_TESSFACTOR:   return 0x000 + si * 0x4;
   case TGSI_SEMANTIC_PRIMID:       return 0x060;
   case TGSI_SEMANTIC_PSIZE:        return 0x06c;
   case TGSI_SEMANTIC_POSITION:     return 0x070;
   case TGSI_SEMANTIC_GENERIC:      return ubase + si * 0x10;
   case TGSI_SEMANTIC_FOG:          return 0x2e8;
   case TGSI_SEMANTIC_COLOR:        return 0x280 + si * 0x10;
   case TGSI_SEMANTIC_BCOLOR:       return 0x2a0 + si * 0x10;
   case NV50_SEMANTIC_CLIPDISTANCE: return 0x2c0 + si * 0x4;
   case TGSI_SEMANTIC_CLIPDIST:     return 0x2c0 + si * 0x10;
   case TGSI_SEMANTIC_CLIPVERTEX:   return 0x270;
   case TGSI_SEMANTIC_PCOORD:       return 0x2e0;
   case NV50_SEMANTIC_TESSCOORD:    return 0x2f0;
   case TGSI_SEMANTIC_INSTANCEID:   return 0x2f8;
   case TGSI_SEMANTIC_VERTEXID:     return 0x2fc;
   case TGSI_SEMANTIC_TEXCOORD:     return 0x300 + si * 0x10;
   case TGSI_SEMANTIC_FACE:         return 0x3fc;
   case NV50_SEMANTIC_INVOCATIONID: return ~0;
d102 1
a102 2
      assert(!"invalid TGSI input semantic");
      return ~0;
a103 1
}
d105 1
a105 23
static uint32_t
nvc0_shader_output_address(unsigned sn, unsigned si, unsigned ubase)
{
   switch (sn) {
   case NV50_SEMANTIC_TESSFACTOR:    return 0x000 + si * 0x4;
   case TGSI_SEMANTIC_PRIMID:        return 0x060;
   case NV50_SEMANTIC_LAYER:         return 0x064;
   case NV50_SEMANTIC_VIEWPORTINDEX: return 0x068;
   case TGSI_SEMANTIC_PSIZE:         return 0x06c;
   case TGSI_SEMANTIC_POSITION:      return 0x070;
   case TGSI_SEMANTIC_GENERIC:       return ubase + si * 0x10;
   case TGSI_SEMANTIC_FOG:           return 0x2e8;
   case TGSI_SEMANTIC_COLOR:         return 0x280 + si * 0x10;
   case TGSI_SEMANTIC_BCOLOR:        return 0x2a0 + si * 0x10;
   case NV50_SEMANTIC_CLIPDISTANCE:  return 0x2c0 + si * 0x4;
   case TGSI_SEMANTIC_CLIPDIST:      return 0x2c0 + si * 0x10;
   case TGSI_SEMANTIC_CLIPVERTEX:    return 0x270;
   case TGSI_SEMANTIC_TEXCOORD:      return 0x300 + si * 0x10;
   case TGSI_SEMANTIC_EDGEFLAG:      return ~0;
   default:
      assert(!"invalid TGSI output semantic");
      return ~0;
   }
d108 2
a109 2
static int
nvc0_vp_assign_input_slots(struct nv50_ir_prog_info *info)
d111 1
a111 1
   unsigned i, c, n;
d113 1
a113 11
   for (n = 0, i = 0; i < info->numInputs; ++i) {
      switch (info->in[i].sn) {
      case TGSI_SEMANTIC_INSTANCEID: /* for SM4 only, in TGSI they're SVs */
      case TGSI_SEMANTIC_VERTEXID:
         info->in[i].mask = 0x1;
         info->in[i].slot[0] =
            nvc0_shader_input_address(info->in[i].sn, 0, 0) / 4;
         continue;
      default:
         break;
      }
d115 1
a115 3
         info->in[i].slot[c] = (0x80 + n * 0x10 + c * 0x4) / 4;
      ++n;
   }
d117 1
a117 1
   return 0;
d120 2
a121 2
static int
nvc0_sp_assign_input_slots(struct nv50_ir_prog_info *info)
d123 1
a123 3
   unsigned ubase = MAX2(0x80, 0x20 + info->numPatchConstants * 0x10);
   unsigned offset;
   unsigned i, c;
d125 3
a127 5
   for (i = 0; i < info->numInputs; ++i) {
      offset = nvc0_shader_input_address(info->in[i].sn,
                                         info->in[i].si, ubase);
      if (info->in[i].patch && offset >= 0x20)
         offset = 0x20 + info->in[i].si * 0x10;
d129 2
a130 2
      if (info->in[i].sn == NV50_SEMANTIC_TESSCOORD)
         info->in[i].mask &= 3;
d132 32
a163 2
      for (c = 0; c < 4; ++c)
         info->in[i].slot[c] = (offset + c * 0x4) / 4;
d165 1
d167 46
a212 1
   return 0;
d215 2
a216 2
static int
nvc0_fp_assign_output_slots(struct nv50_ir_prog_info *info)
d218 1
a218 2
   unsigned count = info->prop.fp.numColourResults * 4;
   unsigned i, c;
d220 8
a227 7
   for (i = 0; i < info->numOutputs; ++i)
      if (info->out[i].sn == TGSI_SEMANTIC_COLOR)
         for (c = 0; c < 4; ++c)
            info->out[i].slot[c] = info->out[i].si * 4 + c;

   if (info->io.sampleMask < PIPE_MAX_SHADER_OUTPUTS)
      info->out[info->io.sampleMask].slot[0] = count++;
d229 1
a229 2
   if (info->target >= 0xe0)
      count++; /* on Kepler, depth is always last colour reg + 2 */
d231 2
a232 2
   if (info->io.fragDepth < PIPE_MAX_SHADER_OUTPUTS)
      info->out[info->io.fragDepth].slot[2] = count;
d234 1
a234 1
   return 0;
d237 3
a239 2
static int
nvc0_sp_assign_output_slots(struct nv50_ir_prog_info *info)
d241 2
a242 3
   unsigned ubase = MAX2(0x80, 0x20 + info->numPatchConstants * 0x10);
   unsigned offset;
   unsigned i, c;
d244 1
a244 5
   for (i = 0; i < info->numOutputs; ++i) {
      offset = nvc0_shader_output_address(info->out[i].sn,
                                          info->out[i].si, ubase);
      if (info->out[i].patch && offset >= 0x20)
         offset = 0x20 + info->out[i].si * 0x10;
d246 2
a247 3
      for (c = 0; c < 4; ++c)
         info->out[i].slot[c] = (offset + c * 0x4) / 4;
   }
d249 1
a249 1
   return 0;
d252 3
a254 2
static int
nvc0_program_assign_varying_slots(struct nv50_ir_prog_info *info)
d256 69
a324 14
   int ret;

   if (info->type == PIPE_SHADER_VERTEX)
      ret = nvc0_vp_assign_input_slots(info);
   else
      ret = nvc0_sp_assign_input_slots(info);
   if (ret)
      return ret;

   if (info->type == PIPE_SHADER_FRAGMENT)
      ret = nvc0_fp_assign_output_slots(info);
   else
      ret = nvc0_sp_assign_output_slots(info);
   return ret;
d327 3
a329 2
static INLINE void
nvc0_vtgp_hdr_update_oread(struct nvc0_program *vp, uint8_t slot)
d331 10
a340 5
   uint8_t min = (vp->hdr[4] >> 12) & 0xff;
   uint8_t max = (vp->hdr[4] >> 24);

   min = MIN2(min, slot);
   max = MAX2(max, slot);
d342 2
a343 8
   vp->hdr[4] = (max << 24) | (min << 12);
}

/* Common part of header generation for VP, TCP, TEP and GP. */
static int
nvc0_vtgp_gen_header(struct nvc0_program *vp, struct nv50_ir_prog_info *info)
{
   unsigned i, c, a;
a344 3
   for (i = 0; i < info->numInputs; ++i) {
      if (info->in[i].patch)
         continue;
d346 5
a350 7
         a = info->in[i].slot[c];
         if (info->in[i].mask & (1 << c)) {
            if (info->in[i].sn != NV50_SEMANTIC_TESSCOORD)
               vp->hdr[5 + a / 32] |= 1 << (a % 32);
            else
               nvc0_vtgp_hdr_update_oread(vp, info->in[i].slot[c]);
         }
a351 1
   }
d353 16
a368 2
   for (i = 0; i < info->numOutputs; ++i) {
      if (info->out[i].patch)
d370 5
d376 1
a376 1
         if (!(info->out[i].mask & (1 << c)))
d378 3
a380 5
         assert(info->out[i].slot[c] >= 0x40 / 4);
         a = info->out[i].slot[c] - 0x40 / 4;
         vp->hdr[13 + a / 32] |= 1 << (a % 32);
         if (info->out[i].oread)
            nvc0_vtgp_hdr_update_oread(vp, info->out[i].slot[c]);
a382 26

   for (i = 0; i < info->numSysVals; ++i) {
      switch (info->sv[i].sn) {
      case TGSI_SEMANTIC_PRIMID:
         vp->hdr[5] |= 1 << 24;
         break;
      case TGSI_SEMANTIC_INSTANCEID:
         vp->hdr[10] |= 1 << 30;
         break;
      case TGSI_SEMANTIC_VERTEXID:
         vp->hdr[10] |= 1 << 31;
         break;
      default:
         break;
      }
   }

   vp->vp.clip_enable = info->io.clipDistanceMask;
   for (i = 0; i < 8; ++i)
      if (info->io.cullDistanceMask & (1 << i))
         vp->vp.clip_mode |= 1 << (i * 4);

   if (info->io.genUserClip < 0)
      vp->vp.num_ucps = PIPE_MAX_CLIP_PLANES + 1; /* prevent rebuilding */

   return 0;
d385 6
a390 2
static int
nvc0_vp_gen_header(struct nvc0_program *vp, struct nv50_ir_prog_info *info)
d392 10
a401 2
   vp->hdr[0] = 0x20061 | (1 << 10);
   vp->hdr[4] = 0xff000;
d403 2
a404 1
   vp->hdr[18] = info->io.clipDistanceMask;
d406 5
a410 2
   return nvc0_vtgp_gen_header(vp, info);
}
d412 2
a413 26
#if defined(PIPE_SHADER_HULL) || defined(PIPE_SHADER_DOMAIN)
static void
nvc0_tp_get_tess_mode(struct nvc0_program *tp, struct nv50_ir_prog_info *info)
{
   if (info->prop.tp.outputPrim == PIPE_PRIM_MAX) {
      tp->tp.tess_mode = ~0;
      return;
   }
   switch (info->prop.tp.domain) {
   case PIPE_PRIM_LINES:
      tp->tp.tess_mode = NVC0_3D_TESS_MODE_PRIM_ISOLINES;
      break;
   case PIPE_PRIM_TRIANGLES:
      tp->tp.tess_mode = NVC0_3D_TESS_MODE_PRIM_TRIANGLES;
      if (info->prop.tp.winding > 0)
         tp->tp.tess_mode |= NVC0_3D_TESS_MODE_CW;
      break;
   case PIPE_PRIM_QUADS:
      tp->tp.tess_mode = NVC0_3D_TESS_MODE_PRIM_QUADS;
      break;
   default:
      tp->tp.tess_mode = ~0;
      return;
   }
   if (info->prop.tp.outputPrim != PIPE_PRIM_POINTS)
      tp->tp.tess_mode |= NVC0_3D_TESS_MODE_CONNECTED;
d415 3
a417 14
   switch (info->prop.tp.partitioning) {
   case PIPE_TESS_PART_INTEGER:
   case PIPE_TESS_PART_POW2:
      tp->tp.tess_mode |= NVC0_3D_TESS_MODE_SPACING_EQUAL;
      break;
   case PIPE_TESS_PART_FRACT_ODD:
      tp->tp.tess_mode |= NVC0_3D_TESS_MODE_SPACING_FRACTIONAL_ODD;
      break;
   case PIPE_TESS_PART_FRACT_EVEN:
      tp->tp.tess_mode |= NVC0_3D_TESS_MODE_SPACING_FRACTIONAL_EVEN;
      break;
   default:
      assert(!"invalid tessellator partitioning");
      break;
a419 1
#endif
a420 1
#ifdef PIPE_SHADER_HULL
d422 1
a422 1
nvc0_tcp_gen_header(struct nvc0_program *tcp, struct nv50_ir_prog_info *info)
d424 2
a425 1
   unsigned opcs = 6; /* output patch constants (at least the TessFactors) */
d427 5
a431 1
   tcp->tp.input_patch_size = info->prop.tp.inputPatchSize;
d433 10
a442 2
   if (info->numPatchConstants)
      opcs = 8 + info->numPatchConstants * 4;
d444 5
a448 10
   tcp->hdr[0] = 0x20061 | (2 << 10);

   tcp->hdr[1] = opcs << 24;
   tcp->hdr[2] = info->prop.tp.outputPatchSize << 24;

   tcp->hdr[4] = 0xff000; /* initial min/max parallel output read address */

   nvc0_vtgp_gen_header(tcp, info);

   nvc0_tp_get_tess_mode(tcp, info);
a451 1
#endif
a452 1
#ifdef PIPE_SHADER_DOMAIN
d454 1
a454 1
nvc0_tep_gen_header(struct nvc0_program *tep, struct nv50_ir_prog_info *info)
d456 2
a457 6
   tep->tp.input_patch_size = ~0;

   tep->hdr[0] = 0x20061 | (3 << 10);
   tep->hdr[4] = 0xff000;

   nvc0_vtgp_gen_header(tep, info);
d459 1
a459 1
   nvc0_tp_get_tess_mode(tep, info);
d461 1
a461 3
   tep->hdr[18] |= 0x3 << 12; /* ? */

   return 0;
a462 1
#endif
d465 1
a465 1
nvc0_gp_gen_header(struct nvc0_program *gp, struct nv50_ir_prog_info *info)
d467 25
a491 1
   gp->hdr[0] = 0x20061 | (4 << 10);
d493 1
a493 1
   gp->hdr[2] = MIN2(info->prop.gp.instanceCount, 32) << 24;
d495 1
a495 1
   switch (info->prop.gp.outputPrim) {
d513 1
a513 1
   gp->hdr[4] = info->prop.gp.maxVertices & 0x1ff;
d515 1
a515 16
   return nvc0_vtgp_gen_header(gp, info);
}

#define NVC0_INTERP_FLAT          (1 << 0)
#define NVC0_INTERP_PERSPECTIVE   (2 << 0)
#define NVC0_INTERP_LINEAR        (3 << 0)
#define NVC0_INTERP_CENTROID      (1 << 2)

static uint8_t
nvc0_hdr_interp_mode(const struct nv50_ir_varying *var)
{
   if (var->linear)
      return NVC0_INTERP_LINEAR;
   if (var->flat)
      return NVC0_INTERP_FLAT;
   return NVC0_INTERP_PERSPECTIVE;
d519 1
a519 1
nvc0_fp_gen_header(struct nvc0_program *fp, struct nv50_ir_prog_info *info)
d521 4
a524 4
   unsigned i, c, a, m;

   /* just 00062 on Kepler */
   fp->hdr[0] = 0x20062 | (5 << 10);
d527 1
a527 1
   if (info->prop.fp.usesDiscard)
d529 1
a529 5
   if (info->prop.fp.numColourResults > 1)
      fp->hdr[0] |= 0x4000;
   if (info->io.sampleMask < PIPE_MAX_SHADER_OUTPUTS)
      fp->hdr[19] |= 0x1;
   if (info->prop.fp.writesDepth) {
d531 5
a535 1
      fp->flags[0] = 0x11; /* deactivate ZCULL */
d538 2
a539 2
   for (i = 0; i < info->numInputs; ++i) {
      m = nvc0_hdr_interp_mode(&info->in[i]);
d541 1
a541 1
         if (!(info->in[i].mask & (1 << c)))
d543 9
a551 15
         a = info->in[i].slot[c];
         if (info->in[i].slot[0] >= (0x060 / 4) &&
             info->in[i].slot[0] <= (0x07c / 4)) {
            fp->hdr[5] |= 1 << (24 + (a - 0x060 / 4));
         } else
         if (info->in[i].slot[0] >= (0x2c0 / 4) &&
             info->in[i].slot[0] <= (0x2fc / 4)) {
            fp->hdr[14] |= (1 << (a - 0x280 / 4)) & 0x07ff0000;
         } else {
            if (info->in[i].slot[c] < (0x040 / 4) ||
                info->in[i].slot[c] > (0x380 / 4))
               continue;
            a *= 2;
            if (info->in[i].slot[0] >= (0x300 / 4))
               a -= 32;
a552 1
         }
d556 3
a558 3
   for (i = 0; i < info->numOutputs; ++i) {
      if (info->out[i].sn == TGSI_SEMANTIC_COLOR)
         fp->hdr[18] |= info->out[i].mask << info->out[i].slot[0];
d561 5
a565 1
   fp->fp.early_z = info->prop.fp.earlyFragTests;
d570 2
a571 3
static struct nvc0_transform_feedback_state *
nvc0_program_create_tfb_state(const struct nv50_ir_prog_info *info,
                              const struct pipe_stream_output_info *pso)
d573 4
a576 2
   struct nvc0_transform_feedback_state *tfb;
   unsigned b, i, c;
d578 3
a580 8
   tfb = MALLOC_STRUCT(nvc0_transform_feedback_state);
   if (!tfb)
      return NULL;
   for (b = 0; b < 4; ++b) {
      tfb->stride[b] = pso->stride[b] * 4;
      tfb->varying_count[b] = 0;
   }
   memset(tfb->varying_index, 0xff, sizeof(tfb->varying_index)); /* = skip */
d582 1
a582 4
   for (i = 0; i < pso->num_outputs; ++i) {
      unsigned s = pso->output[i].start_component;
      unsigned p = pso->output[i].dst_offset;
      b = pso->output[i].output_buffer;
d584 5
a588 5
      for (c = 0; c < pso->output[i].num_components; ++c)
         tfb->varying_index[b][p++] =
            info->out[pso->output[i].register_index].slot[s + c];

      tfb->varying_count[b] = MAX2(tfb->varying_count[b], p);
a589 6
   for (b = 0; b < 4; ++b) // zero unused indices (looks nicer)
      for (c = tfb->varying_count[b]; c & 3; ++c)
         tfb->varying_index[b][c] = 0;

   return tfb;
}
d591 2
a592 5
#ifdef DEBUG
static void
nvc0_program_dump(struct nvc0_program *prog)
{
   unsigned pos;
d594 2
a595 14
   if (prog->type != PIPE_SHADER_COMPUTE) {
      for (pos = 0; pos < sizeof(prog->hdr) / sizeof(prog->hdr[0]); ++pos)
         debug_printf("HDR[%02lx] = 0x%08x\n",
                      pos * sizeof(prog->hdr[0]), prog->hdr[pos]);
   }
   debug_printf("shader binary code (0x%x bytes):", prog->code_size);
   for (pos = 0; pos < prog->code_size / 4; ++pos) {
      if ((pos % 8) == 0)
         debug_printf("\n");
      debug_printf("%08x ", prog->code[pos]);
   }
   debug_printf("\n");
}
#endif
d597 1
a597 5
boolean
nvc0_program_translate(struct nvc0_program *prog, uint16_t chipset)
{
   struct nv50_ir_prog_info *info;
   int ret;
d599 3
a601 3
   info = CALLOC_STRUCT(nv50_ir_prog_info);
   if (!info)
      return FALSE;
d603 13
a615 15
   info->type = prog->type;
   info->target = chipset;
   info->bin.sourceRep = NV50_PROGRAM_IR_TGSI;
   info->bin.source = (void *)prog->pipe.tokens;

   info->io.genUserClip = prog->vp.num_ucps;
   info->io.ucpBase = 256;
   info->io.ucpCBSlot = 15;

   if (prog->type == PIPE_SHADER_COMPUTE) {
      if (chipset >= NVISA_GK104_CHIPSET) {
         info->io.resInfoCBSlot = 0;
         info->io.texBindBase = NVE4_CP_INPUT_TEX(0);
         info->io.suInfoBase = NVE4_CP_INPUT_SUF(0);
         info->prop.cp.gridInfoBase = NVE4_CP_INPUT_GRID_INFO(0);
a616 10
      info->io.msInfoCBSlot = 0;
      info->io.msInfoBase = NVE4_CP_INPUT_MS_OFFSETS;
   } else {
      if (chipset >= NVISA_GK104_CHIPSET) {
         info->io.resInfoCBSlot = 15;
         info->io.texBindBase = 0x20;
         info->io.suInfoBase = 0; /* TODO */
      }
      info->io.msInfoCBSlot = 15;
      info->io.msInfoBase = 0; /* TODO */
d619 4
a622 13
   info->assignSlots = nvc0_program_assign_varying_slots;

#ifdef DEBUG
   info->optLevel = debug_get_num_option("NV50_PROG_OPTIMIZE", 3);
   info->dbgFlags = debug_get_num_option("NV50_PROG_DEBUG", 0);
#else
   info->optLevel = 3;
#endif

   ret = nv50_ir_generate_code(info);
   if (ret) {
      NOUVEAU_ERR("shader translation failed: %i\n", ret);
      goto out;
a623 16
   if (prog->type != PIPE_SHADER_COMPUTE)
      FREE(info->bin.syms);

   prog->code = info->bin.code;
   prog->code_size = info->bin.codeSize;
   prog->immd_data = info->immd.buf;
   prog->immd_size = info->immd.bufSize;
   prog->relocs = info->bin.relocData;
   prog->num_gprs = MAX2(4, (info->bin.maxGPR + 1));
   prog->num_barriers = info->numBarriers;

   prog->vp.need_vertex_id = info->io.vertexId < PIPE_MAX_SHADER_INPUTS;

   if (info->io.edgeFlagOut < PIPE_MAX_ATTRIBS)
      info->out[info->io.edgeFlagOut].mask = 0; /* for headergen */
   prog->vp.edgeflag = info->io.edgeFlagIn;
d627 7
a633 1
      ret = nvc0_vp_gen_header(prog, info);
d635 2
a636 3
#ifdef PIPE_SHADER_HULL
   case PIPE_SHADER_HULL:
      ret = nvc0_tcp_gen_header(prog, info);
a637 6
#endif
#ifdef PIPE_SHADER_DOMAIN
   case PIPE_SHADER_DOMAIN:
      ret = nvc0_tep_gen_header(prog, info);
      break;
#endif
d639 1
a639 1
      ret = nvc0_gp_gen_header(prog, info);
d641 1
d643 10
a652 5
      ret = nvc0_fp_gen_header(prog, info);
      break;
   case PIPE_SHADER_COMPUTE:
      prog->cp.syms = info->bin.syms;
      prog->cp.num_syms = info->bin.numSyms;
d655 1
a656 1
      NOUVEAU_ERR("unknown program type: %u\n", prog->type);
a658 2
   if (ret)
      goto out;
d660 1
a660 2
   if (info->bin.tlsSpace) {
      assert(info->bin.tlsSpace < (1 << 24));
d662 1
a662 2
      prog->hdr[1] |= info->bin.tlsSpace; /* l[] size */
      prog->need_tls = TRUE;
a663 15
   /* TODO: factor 2 only needed where joinat/precont is used,
    *       and we only have to count non-uniform branches
    */
   /*
   if ((info->maxCFDepth * 2) > 16) {
      prog->hdr[2] |= (((info->maxCFDepth * 2) + 47) / 48) * 0x200;
      prog->need_tls = TRUE;
   }
   */
   if (info->io.globalAccess)
      prog->hdr[0] |= 1 << 16;

   if (prog->pipe.stream_output.num_outputs)
      prog->tfb = nvc0_program_create_tfb_state(info,
                                                &prog->pipe.stream_output);
d665 2
a666 3
out:
   FREE(info);
   return !ret;
d670 1
a670 1
nvc0_program_upload_code(struct nvc0_context *nvc0, struct nvc0_program *prog)
d672 1
a672 2
   struct nvc0_screen *screen = nvc0->screen;
   const boolean is_cp = prog->type == PIPE_SHADER_COMPUTE;
a673 62
   uint32_t size = prog->code_size + (is_cp ? 0 : NVC0_SHADER_HEADER_SIZE);
   uint32_t lib_pos = screen->lib_code->start;
   uint32_t code_pos;

   /* c[] bindings need to be aligned to 0x100, but we could use relocations
    * to save space. */
   if (prog->immd_size) {
      prog->immd_base = size;
      size = align(size, 0x40);
      size += prog->immd_size + 0xc0; /* add 0xc0 for align 0x40 -> 0x100 */
   }
   /* On Fermi, SP_START_ID must be aligned to 0x40.
    * On Kepler, the first instruction must be aligned to 0x80 because
    * latency information is expected only at certain positions.
    */
   if (screen->base.class_3d >= NVE4_3D_CLASS)
      size = size + (is_cp ? 0x40 : 0x70);
   size = align(size, 0x40);

   ret = nouveau_heap_alloc(screen->text_heap, size, prog, &prog->mem);
   if (ret) {
      struct nouveau_heap *heap = screen->text_heap;
      struct nouveau_heap *iter;
      for (iter = heap; iter && iter->next != heap; iter = iter->next) {
         struct nvc0_program *evict = iter->priv;
         if (evict)
            nouveau_heap_free(&evict->mem);
      }
      debug_printf("WARNING: out of code space, evicting all shaders.\n");
      ret = nouveau_heap_alloc(heap, size, prog, &prog->mem);
      if (ret) {
         NOUVEAU_ERR("shader too large (0x%x) to fit in code space ?\n", size);
         return FALSE;
      }
      IMMED_NVC0(nvc0->base.pushbuf, NVC0_3D(SERIALIZE), 0);
   }
   prog->code_base = prog->mem->start;
   prog->immd_base = align(prog->mem->start + prog->immd_base, 0x100);
   assert((prog->immd_size == 0) || (prog->immd_base + prog->immd_size <=
                                     prog->mem->start + prog->mem->size));

   if (!is_cp) {
      if (screen->base.class_3d >= NVE4_3D_CLASS) {
         switch (prog->mem->start & 0xff) {
         case 0x40: prog->code_base += 0x70; break;
         case 0x80: prog->code_base += 0x30; break;
         case 0xc0: prog->code_base += 0x70; break;
         default:
            prog->code_base += 0x30;
            assert((prog->mem->start & 0xff) == 0x00);
            break;
         }
      }
      code_pos = prog->code_base + NVC0_SHADER_HEADER_SIZE;
   } else {
      if (screen->base.class_3d >= NVE4_3D_CLASS) {
         if (prog->mem->start & 0x40)
            prog->code_base += 0x40;
         assert((prog->code_base & 0x7f) == 0x00);
      }
      code_pos = prog->code_base;
   }
d675 2
a676 2
   if (prog->relocs)
      nv50_ir_relocate_code(prog->relocs, prog->code, code_pos, lib_pos, 0);
d678 1
a678 4
#ifdef DEBUG
   if (debug_get_bool_option("NV50_PROG_DEBUG", FALSE))
      nvc0_program_dump(prog);
#endif
d680 1
a680 9
   if (!is_cp)
      nvc0->base.push_data(&nvc0->base, screen->text, prog->code_base,
                           NOUVEAU_BO_VRAM, NVC0_SHADER_HEADER_SIZE, prog->hdr);
   nvc0->base.push_data(&nvc0->base, screen->text, code_pos,
                        NOUVEAU_BO_VRAM, prog->code_size, prog->code);
   if (prog->immd_size)
      nvc0->base.push_data(&nvc0->base,
                           screen->text, prog->immd_base, NOUVEAU_BO_VRAM,
                           prog->immd_size, prog->immd_data);
d682 2
a683 2
   BEGIN_NVC0(nvc0->base.pushbuf, NVC0_3D(MEM_BARRIER), 1);
   PUSH_DATA (nvc0->base.pushbuf, 0x1011);
d685 5
a689 2
   return TRUE;
}
d691 3
a693 8
/* Upload code for builtin functions like integer division emulation. */
void
nvc0_program_library_upload(struct nvc0_context *nvc0)
{
   struct nvc0_screen *screen = nvc0->screen;
   int ret;
   uint32_t size;
   const uint32_t *code;
d695 6
a700 2
   if (screen->lib_code)
      return;
d702 11
a712 13
   nv50_ir_get_target_library(screen->base.device->chipset, &code, &size);
   if (!size)
      return;

   ret = nouveau_heap_alloc(screen->text_heap, align(size, 0x100), NULL,
                            &screen->lib_code);
   if (ret)
      return;

   nvc0->base.push_data(&nvc0->base,
                        screen->text, screen->lib_code->start, NOUVEAU_BO_VRAM,
                        size, code);
   /* no need for a memory barrier, will be emitted with first program */
d718 2
a719 2
   const struct pipe_shader_state pipe = prog->pipe;
   const ubyte type = prog->type;
a720 2
   if (prog->mem)
      nouveau_heap_free(&prog->mem);
d722 3
a724 10
      FREE(prog->code); /* may be 0 for hardcoded shaders */
   FREE(prog->immd_data);
   FREE(prog->relocs);
   if (prog->type == PIPE_SHADER_COMPUTE && prog->cp.syms)
      FREE(prog->cp.syms);
   if (prog->tfb) {
      if (nvc0->state.tfb == prog->tfb)
         nvc0->state.tfb = NULL;
      FREE(prog->tfb);
   }
d726 1
a726 1
   memset(prog, 0, sizeof(*prog));
d728 1
a728 17
   prog->pipe = pipe;
   prog->type = type;
}

uint32_t
nvc0_program_symbol_offset(const struct nvc0_program *prog, uint32_t label)
{
   const struct nv50_ir_prog_symbol *syms =
      (const struct nv50_ir_prog_symbol *)prog->cp.syms;
   unsigned base = 0;
   unsigned i;
   if (prog->type != PIPE_SHADER_COMPUTE)
      base = NVC0_SHADER_HEADER_SIZE;
   for (i = 0; i < prog->cp.num_syms; ++i)
      if (syms[i].label == label)
         return prog->code_base + base + syms[i].offset;
   return prog->code_base; /* no symbols or symbol not found */
@

