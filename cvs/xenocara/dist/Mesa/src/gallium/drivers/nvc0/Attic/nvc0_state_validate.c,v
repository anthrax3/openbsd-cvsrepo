head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.10.05.09.53.51;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.05.14.00.48;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.52;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.10.05.09.21.45;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@
#include "util/u_math.h"

#include "nvc0_context.h"

#if 0
static void
nvc0_validate_zcull(struct nvc0_context *nvc0)
{
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    struct pipe_framebuffer_state *fb = &nvc0->framebuffer;
    struct nv50_surface *sf = nv50_surface(fb->zsbuf);
    struct nv50_miptree *mt = nv50_miptree(sf->base.texture);
    struct nouveau_bo *bo = mt->base.bo;
    uint32_t size;
    uint32_t offset = align(mt->total_size, 1 << 17);
    unsigned width, height;

    assert(mt->base.base.depth0 == 1 && mt->base.base.array_size < 2);

    size = mt->total_size * 2;

    height = align(fb->height, 32);
    width = fb->width % 224;
    if (width)
       width = fb->width + (224 - width);
    else
       width = fb->width;

    BEGIN_NVC0(push, NVC0_3D(ZCULL_REGION), 1);
    PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(ZCULL_ADDRESS_HIGH), 2);
    PUSH_DATAh(push, bo->offset + offset);
    PUSH_DATA (push, bo->offset + offset);
    offset += 1 << 17;
    BEGIN_NVC0(push, NVC0_3D(ZCULL_LIMIT_HIGH), 2);
    PUSH_DATAh(push, bo->offset + offset);
    PUSH_DATA (push, bo->offset + offset);
    BEGIN_NVC0(push, SUBC_3D(0x07e0), 2);
    PUSH_DATA (push, size);
    PUSH_DATA (push, size >> 16);
    BEGIN_NVC0(push, SUBC_3D(0x15c8), 1); /* bits 0x3 */
    PUSH_DATA (push, 2);
    BEGIN_NVC0(push, NVC0_3D(ZCULL_WIDTH), 4);
    PUSH_DATA (push, width);
    PUSH_DATA (push, height);
    PUSH_DATA (push, 1);
    PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(ZCULL_WINDOW_OFFSET_X), 2);
    PUSH_DATA (push, 0);
    PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(ZCULL_INVALIDATE), 1);
    PUSH_DATA (push, 0);
}
#endif

static void
nvc0_validate_fb(struct nvc0_context *nvc0)
{
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    struct pipe_framebuffer_state *fb = &nvc0->framebuffer;
    unsigned i;
    unsigned ms_mode = NVC0_3D_MULTISAMPLE_MODE_MS1;
    boolean serialize = FALSE;

    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_FB);

    BEGIN_NVC0(push, NVC0_3D(RT_CONTROL), 1);
    PUSH_DATA (push, (076543210 << 4) | fb->nr_cbufs);
    BEGIN_NVC0(push, NVC0_3D(SCREEN_SCISSOR_HORIZ), 2);
    PUSH_DATA (push, fb->width << 16);
    PUSH_DATA (push, fb->height << 16);

    for (i = 0; i < fb->nr_cbufs; ++i) {
        struct nv50_surface *sf = nv50_surface(fb->cbufs[i]);
        struct nv04_resource *res = nv04_resource(sf->base.texture);
        struct nouveau_bo *bo = res->bo;

        BEGIN_NVC0(push, NVC0_3D(RT_ADDRESS_HIGH(i)), 9);
        PUSH_DATAh(push, res->address + sf->offset);
        PUSH_DATA (push, res->address + sf->offset);
        if (likely(nouveau_bo_memtype(bo))) {
           struct nv50_miptree *mt = nv50_miptree(sf->base.texture);

           assert(sf->base.texture->target != PIPE_BUFFER);

           PUSH_DATA(push, sf->width);
           PUSH_DATA(push, sf->height);
           PUSH_DATA(push, nvc0_format_table[sf->base.format].rt);
           PUSH_DATA(push, (mt->layout_3d << 16) |
                    mt->level[sf->base.u.tex.level].tile_mode);
           PUSH_DATA(push, sf->base.u.tex.first_layer + sf->depth);
           PUSH_DATA(push, mt->layer_stride >> 2);
           PUSH_DATA(push, sf->base.u.tex.first_layer);

           ms_mode = mt->ms_mode;
        } else {
           if (res->base.target == PIPE_BUFFER) {
              PUSH_DATA(push, 262144);
              PUSH_DATA(push, 1);
           } else {
              PUSH_DATA(push, nv50_miptree(sf->base.texture)->level[0].pitch);
              PUSH_DATA(push, sf->height);
           }
           PUSH_DATA(push, nvc0_format_table[sf->base.format].rt);
           PUSH_DATA(push, 1 << 12);
           PUSH_DATA(push, 1);
           PUSH_DATA(push, 0);
           PUSH_DATA(push, 0);

           nvc0_resource_fence(res, NOUVEAU_BO_WR);

           assert(!fb->zsbuf);
        }

        if (res->status & NOUVEAU_BUFFER_STATUS_GPU_READING)
           serialize = TRUE;
        res->status |=  NOUVEAU_BUFFER_STATUS_GPU_WRITING;
        res->status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;

        /* only register for writing, otherwise we'd always serialize here */
        BCTX_REFN(nvc0->bufctx_3d, FB, res, WR);
    }

    if (fb->zsbuf) {
        struct nv50_miptree *mt = nv50_miptree(fb->zsbuf->texture);
        struct nv50_surface *sf = nv50_surface(fb->zsbuf);
        int unk = mt->base.base.target == PIPE_TEXTURE_2D;

        BEGIN_NVC0(push, NVC0_3D(ZETA_ADDRESS_HIGH), 5);
        PUSH_DATAh(push, mt->base.address + sf->offset);
        PUSH_DATA (push, mt->base.address + sf->offset);
        PUSH_DATA (push, nvc0_format_table[fb->zsbuf->format].rt);
        PUSH_DATA (push, mt->level[sf->base.u.tex.level].tile_mode);
        PUSH_DATA (push, mt->layer_stride >> 2);
        BEGIN_NVC0(push, NVC0_3D(ZETA_ENABLE), 1);
        PUSH_DATA (push, 1);
        BEGIN_NVC0(push, NVC0_3D(ZETA_HORIZ), 3);
        PUSH_DATA (push, sf->width);
        PUSH_DATA (push, sf->height);
        PUSH_DATA (push, (unk << 16) |
                   (sf->base.u.tex.first_layer + sf->depth));
        BEGIN_NVC0(push, NVC0_3D(ZETA_BASE_LAYER), 1);
        PUSH_DATA (push, sf->base.u.tex.first_layer);

        ms_mode = mt->ms_mode;

        if (mt->base.status & NOUVEAU_BUFFER_STATUS_GPU_READING)
           serialize = TRUE;
        mt->base.status |=  NOUVEAU_BUFFER_STATUS_GPU_WRITING;
        mt->base.status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;

        BCTX_REFN(nvc0->bufctx_3d, FB, &mt->base, WR);
    } else {
        BEGIN_NVC0(push, NVC0_3D(ZETA_ENABLE), 1);
        PUSH_DATA (push, 0);
    }

    IMMED_NVC0(push, NVC0_3D(MULTISAMPLE_MODE), ms_mode);

    if (serialize)
       IMMED_NVC0(push, NVC0_3D(SERIALIZE), 0);

    NOUVEAU_DRV_STAT(&nvc0->screen->base, gpu_serialize_count, serialize);
}

static void
nvc0_validate_blend_colour(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;

   BEGIN_NVC0(push, NVC0_3D(BLEND_COLOR(0)), 4);
   PUSH_DATAf(push, nvc0->blend_colour.color[0]);
   PUSH_DATAf(push, nvc0->blend_colour.color[1]);
   PUSH_DATAf(push, nvc0->blend_colour.color[2]);
   PUSH_DATAf(push, nvc0->blend_colour.color[3]);
}

static void
nvc0_validate_stencil_ref(struct nvc0_context *nvc0)
{
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    const ubyte *ref = &nvc0->stencil_ref.ref_value[0];

    IMMED_NVC0(push, NVC0_3D(STENCIL_FRONT_FUNC_REF), ref[0]);
    IMMED_NVC0(push, NVC0_3D(STENCIL_BACK_FUNC_REF), ref[1]);
}

static void
nvc0_validate_stipple(struct nvc0_context *nvc0)
{
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    unsigned i;

    BEGIN_NVC0(push, NVC0_3D(POLYGON_STIPPLE_PATTERN(0)), 32);
    for (i = 0; i < 32; ++i)
        PUSH_DATA(push, util_bswap32(nvc0->stipple.stipple[i]));
}

static void
nvc0_validate_scissor(struct nvc0_context *nvc0)
{
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    struct pipe_scissor_state *s = &nvc0->scissor;

    if (!(nvc0->dirty & NVC0_NEW_SCISSOR) &&
        nvc0->rast->pipe.scissor == nvc0->state.scissor)
       return;
    nvc0->state.scissor = nvc0->rast->pipe.scissor;

    BEGIN_NVC0(push, NVC0_3D(SCISSOR_HORIZ(0)), 2);
    if (nvc0->rast->pipe.scissor) {
       PUSH_DATA(push, (s->maxx << 16) | s->minx);
       PUSH_DATA(push, (s->maxy << 16) | s->miny);
    } else {
       PUSH_DATA(push, (0xffff << 16) | 0);
       PUSH_DATA(push, (0xffff << 16) | 0);
    }
}

static void
nvc0_validate_viewport(struct nvc0_context *nvc0)
{
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    struct pipe_viewport_state *vp = &nvc0->viewport;
    int x, y, w, h;
    float zmin, zmax;

    BEGIN_NVC0(push, NVC0_3D(VIEWPORT_TRANSLATE_X(0)), 3);
    PUSH_DATAf(push, vp->translate[0]);
    PUSH_DATAf(push, vp->translate[1]);
    PUSH_DATAf(push, vp->translate[2]);
    BEGIN_NVC0(push, NVC0_3D(VIEWPORT_SCALE_X(0)), 3);
    PUSH_DATAf(push, vp->scale[0]);
    PUSH_DATAf(push, vp->scale[1]);
    PUSH_DATAf(push, vp->scale[2]);

    /* now set the viewport rectangle to viewport dimensions for clipping */

    x = util_iround(MAX2(0.0f, vp->translate[0] - fabsf(vp->scale[0])));
    y = util_iround(MAX2(0.0f, vp->translate[1] - fabsf(vp->scale[1])));
    w = util_iround(vp->translate[0] + fabsf(vp->scale[0])) - x;
    h = util_iround(vp->translate[1] + fabsf(vp->scale[1])) - y;

    zmin = vp->translate[2] - fabsf(vp->scale[2]);
    zmax = vp->translate[2] + fabsf(vp->scale[2]);

    nvc0->vport_int[0] = (w << 16) | x;
    nvc0->vport_int[1] = (h << 16) | y;
    BEGIN_NVC0(push, NVC0_3D(VIEWPORT_HORIZ(0)), 2);
    PUSH_DATA (push, nvc0->vport_int[0]);
    PUSH_DATA (push, nvc0->vport_int[1]);
    BEGIN_NVC0(push, NVC0_3D(DEPTH_RANGE_NEAR(0)), 2);
    PUSH_DATAf(push, zmin);
    PUSH_DATAf(push, zmax);
}

static INLINE void
nvc0_upload_uclip_planes(struct nvc0_context *nvc0, unsigned s)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nouveau_bo *bo = nvc0->screen->uniform_bo;

   BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
   PUSH_DATA (push, 512);
   PUSH_DATAh(push, bo->offset + (5 << 16) + (s << 9));
   PUSH_DATA (push, bo->offset + (5 << 16) + (s << 9));
   BEGIN_1IC0(push, NVC0_3D(CB_POS), PIPE_MAX_CLIP_PLANES * 4 + 1);
   PUSH_DATA (push, 256);
   PUSH_DATAp(push, &nvc0->clip.ucp[0][0], PIPE_MAX_CLIP_PLANES * 4);
}

static INLINE void
nvc0_check_program_ucps(struct nvc0_context *nvc0,
                        struct nvc0_program *vp, uint8_t mask)
{
   const unsigned n = util_logbase2(mask) + 1;

   if (vp->vp.num_ucps >= n)
      return;
   nvc0_program_destroy(nvc0, vp);

   vp->vp.num_ucps = n;
   if (likely(vp == nvc0->vertprog))
      nvc0_vertprog_validate(nvc0);
   else
   if (likely(vp == nvc0->gmtyprog))
      nvc0_vertprog_validate(nvc0);
   else
      nvc0_tevlprog_validate(nvc0);
}

static void
nvc0_validate_clip(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nvc0_program *vp;
   unsigned stage;
   uint8_t clip_enable = nvc0->rast->pipe.clip_plane_enable;

   if (nvc0->gmtyprog) {
      stage = 3;
      vp = nvc0->gmtyprog;
   } else
   if (nvc0->tevlprog) {
      stage = 2;
      vp = nvc0->tevlprog;
   } else {
      stage = 0;
      vp = nvc0->vertprog;
   }

   if (clip_enable && vp->vp.num_ucps < PIPE_MAX_CLIP_PLANES)
      nvc0_check_program_ucps(nvc0, vp, clip_enable);

   if (nvc0->dirty & (NVC0_NEW_CLIP | (NVC0_NEW_VERTPROG << stage)))
      if (vp->vp.num_ucps > 0 && vp->vp.num_ucps <= PIPE_MAX_CLIP_PLANES)
         nvc0_upload_uclip_planes(nvc0, stage);

   clip_enable &= vp->vp.clip_enable;

   if (nvc0->state.clip_enable != clip_enable) {
      nvc0->state.clip_enable = clip_enable;
      IMMED_NVC0(push, NVC0_3D(CLIP_DISTANCE_ENABLE), clip_enable);
   }
   if (nvc0->state.clip_mode != vp->vp.clip_mode) {
      nvc0->state.clip_mode = vp->vp.clip_mode;
      BEGIN_NVC0(push, NVC0_3D(CLIP_DISTANCE_MODE), 1);
      PUSH_DATA (push, vp->vp.clip_mode);
   }
}

static void
nvc0_validate_blend(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;

   PUSH_SPACE(push, nvc0->blend->size);
   PUSH_DATAp(push, nvc0->blend->state, nvc0->blend->size);
}

static void
nvc0_validate_zsa(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;

   PUSH_SPACE(push, nvc0->zsa->size);
   PUSH_DATAp(push, nvc0->zsa->state, nvc0->zsa->size);
}

static void
nvc0_validate_rasterizer(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;

   PUSH_SPACE(push, nvc0->rast->size);
   PUSH_DATAp(push, nvc0->rast->state, nvc0->rast->size);
}

static void
nvc0_constbufs_validate(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   unsigned s;

   for (s = 0; s < 5; ++s) {
      while (nvc0->constbuf_dirty[s]) {
         int i = ffs(nvc0->constbuf_dirty[s]) - 1;
         nvc0->constbuf_dirty[s] &= ~(1 << i);

         if (nvc0->constbuf[s][i].user) {
            struct nouveau_bo *bo = nvc0->screen->uniform_bo;
            const unsigned base = s << 16;
            const unsigned size = nvc0->constbuf[s][0].size;
            assert(i == 0); /* we really only want OpenGL uniforms here */
            assert(nvc0->constbuf[s][0].u.data);

            if (nvc0->state.uniform_buffer_bound[s] < size) {
               nvc0->state.uniform_buffer_bound[s] = align(size, 0x100);

               BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
               PUSH_DATA (push, nvc0->state.uniform_buffer_bound[s]);
               PUSH_DATAh(push, bo->offset + base);
               PUSH_DATA (push, bo->offset + base);
               BEGIN_NVC0(push, NVC0_3D(CB_BIND(s)), 1);
               PUSH_DATA (push, (0 << 4) | 1);
            }
            nvc0_cb_push(&nvc0->base, bo, NOUVEAU_BO_VRAM,
                         base, nvc0->state.uniform_buffer_bound[s],
                         0, (size + 3) / 4,
                         nvc0->constbuf[s][0].u.data);
         } else {
            struct nv04_resource *res =
               nv04_resource(nvc0->constbuf[s][i].u.buf);
            if (res) {
               BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
               PUSH_DATA (push, nvc0->constbuf[s][i].size);
               PUSH_DATAh(push, res->address + nvc0->constbuf[s][i].offset);
               PUSH_DATA (push, res->address + nvc0->constbuf[s][i].offset);
               BEGIN_NVC0(push, NVC0_3D(CB_BIND(s)), 1);
               PUSH_DATA (push, (i << 4) | 1);

               BCTX_REFN(nvc0->bufctx_3d, CB(s, i), res, RD);
            } else {
               BEGIN_NVC0(push, NVC0_3D(CB_BIND(s)), 1);
               PUSH_DATA (push, (i << 4) | 0);
            }
            if (i == 0)
               nvc0->state.uniform_buffer_bound[s] = 0;
         }
      }
   }
}

static void
nvc0_validate_sample_mask(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;

   unsigned mask[4] =
   {
      nvc0->sample_mask & 0xffff,
      nvc0->sample_mask & 0xffff,
      nvc0->sample_mask & 0xffff,
      nvc0->sample_mask & 0xffff
   };

   BEGIN_NVC0(push, NVC0_3D(MSAA_MASK(0)), 4);
   PUSH_DATA (push, mask[0]);
   PUSH_DATA (push, mask[1]);
   PUSH_DATA (push, mask[2]);
   PUSH_DATA (push, mask[3]);
   BEGIN_NVC0(push, NVC0_3D(SAMPLE_SHADING), 1);
   PUSH_DATA (push, 0x01);
}

void
nvc0_validate_global_residents(struct nvc0_context *nvc0,
                               struct nouveau_bufctx *bctx, int bin)
{
   unsigned i;

   for (i = 0; i < nvc0->global_residents.size / sizeof(struct pipe_resource *);
        ++i) {
      struct pipe_resource *res = *util_dynarray_element(
         &nvc0->global_residents, struct pipe_resource *, i);
      if (res)
         nvc0_add_resident(bctx, bin, nv04_resource(res), NOUVEAU_BO_RDWR);
   }
}

static void
nvc0_validate_derived_1(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   boolean rasterizer_discard;

   if (nvc0->rast && nvc0->rast->pipe.rasterizer_discard) {
      rasterizer_discard = TRUE;
   } else {
      boolean zs = nvc0->zsa &&
         (nvc0->zsa->pipe.depth.enabled || nvc0->zsa->pipe.stencil[0].enabled);
      rasterizer_discard = !zs &&
         (!nvc0->fragprog || !nvc0->fragprog->hdr[18]);
   }

   if (rasterizer_discard != nvc0->state.rasterizer_discard) {
      nvc0->state.rasterizer_discard = rasterizer_discard;
      IMMED_NVC0(push, NVC0_3D(RASTERIZE_ENABLE), !rasterizer_discard);
   }
}

static void
nvc0_switch_pipe_context(struct nvc0_context *ctx_to)
{
   struct nvc0_context *ctx_from = ctx_to->screen->cur_ctx;
   unsigned s;

   if (ctx_from)
      ctx_to->state = ctx_from->state;

   ctx_to->dirty = ~0;

   for (s = 0; s < 5; ++s) {
      ctx_to->samplers_dirty[s] = ~0;
      ctx_to->textures_dirty[s] = ~0;
   }

   if (!ctx_to->vertex)
      ctx_to->dirty &= ~(NVC0_NEW_VERTEX | NVC0_NEW_ARRAYS);
   if (!ctx_to->idxbuf.buffer)
      ctx_to->dirty &= ~NVC0_NEW_IDXBUF;

   if (!ctx_to->vertprog)
      ctx_to->dirty &= ~NVC0_NEW_VERTPROG;
   if (!ctx_to->fragprog)
      ctx_to->dirty &= ~NVC0_NEW_FRAGPROG;

   if (!ctx_to->blend)
      ctx_to->dirty &= ~NVC0_NEW_BLEND;
   if (!ctx_to->rast)
      ctx_to->dirty &= ~(NVC0_NEW_RASTERIZER | NVC0_NEW_SCISSOR);
   if (!ctx_to->zsa)
      ctx_to->dirty &= ~NVC0_NEW_ZSA;

   ctx_to->screen->cur_ctx = ctx_to;
}

static struct state_validate {
    void (*func)(struct nvc0_context *);
    uint32_t states;
} validate_list[] = {
    { nvc0_validate_fb,            NVC0_NEW_FRAMEBUFFER },
    { nvc0_validate_blend,         NVC0_NEW_BLEND },
    { nvc0_validate_zsa,           NVC0_NEW_ZSA },
    { nvc0_validate_sample_mask,   NVC0_NEW_SAMPLE_MASK },
    { nvc0_validate_rasterizer,    NVC0_NEW_RASTERIZER },
    { nvc0_validate_blend_colour,  NVC0_NEW_BLEND_COLOUR },
    { nvc0_validate_stencil_ref,   NVC0_NEW_STENCIL_REF },
    { nvc0_validate_stipple,       NVC0_NEW_STIPPLE },
    { nvc0_validate_scissor,       NVC0_NEW_SCISSOR | NVC0_NEW_RASTERIZER },
    { nvc0_validate_viewport,      NVC0_NEW_VIEWPORT },
    { nvc0_vertprog_validate,      NVC0_NEW_VERTPROG },
    { nvc0_tctlprog_validate,      NVC0_NEW_TCTLPROG },
    { nvc0_tevlprog_validate,      NVC0_NEW_TEVLPROG },
    { nvc0_gmtyprog_validate,      NVC0_NEW_GMTYPROG },
    { nvc0_fragprog_validate,      NVC0_NEW_FRAGPROG },
    { nvc0_validate_derived_1,     NVC0_NEW_FRAGPROG | NVC0_NEW_ZSA |
                                   NVC0_NEW_RASTERIZER },
    { nvc0_validate_clip,          NVC0_NEW_CLIP | NVC0_NEW_RASTERIZER |
                                   NVC0_NEW_VERTPROG |
                                   NVC0_NEW_TEVLPROG |
                                   NVC0_NEW_GMTYPROG },
    { nvc0_constbufs_validate,     NVC0_NEW_CONSTBUF },
    { nvc0_validate_textures,      NVC0_NEW_TEXTURES },
    { nvc0_validate_samplers,      NVC0_NEW_SAMPLERS },
    { nve4_set_tex_handles,        NVC0_NEW_TEXTURES | NVC0_NEW_SAMPLERS },
    { nvc0_vertex_arrays_validate, NVC0_NEW_VERTEX | NVC0_NEW_ARRAYS },
    { nvc0_validate_surfaces,      NVC0_NEW_SURFACES },
    { nvc0_idxbuf_validate,        NVC0_NEW_IDXBUF },
    { nvc0_tfb_validate,           NVC0_NEW_TFB_TARGETS | NVC0_NEW_GMTYPROG }
};
#define validate_list_len (sizeof(validate_list) / sizeof(validate_list[0]))

boolean
nvc0_state_validate(struct nvc0_context *nvc0, uint32_t mask, unsigned words)
{
   uint32_t state_mask;
   int ret;
   unsigned i;

   if (nvc0->screen->cur_ctx != nvc0)
      nvc0_switch_pipe_context(nvc0);

   state_mask = nvc0->dirty & mask;

   if (state_mask) {
      for (i = 0; i < validate_list_len; ++i) {
         struct state_validate *validate = &validate_list[i];

         if (state_mask & validate->states)
            validate->func(nvc0);
      }
      nvc0->dirty &= ~state_mask;

      nvc0_bufctx_fence(nvc0, nvc0->bufctx_3d, FALSE);
   }

   nouveau_pushbuf_bufctx(nvc0->base.pushbuf, nvc0->bufctx_3d);
   ret = nouveau_pushbuf_validate(nvc0->base.pushbuf);
   if (unlikely(ret))
      return FALSE;

   if (unlikely(nvc0->state.flushed))
      nvc0_bufctx_fence(nvc0, nvc0->bufctx_3d, TRUE);

   return TRUE;
}
@


1.3
log
@Merge Mesa 9.2.1
@
text
@@


1.2
log
@Merge Mesa 9.2.0
@
text
@d248 2
d251 2
a252 2
    PUSH_DATA (push, (w << 16) | x);
    PUSH_DATA (push, (h << 16) | y);
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d6 1
d10 1
a10 1
    struct nouveau_channel *chan = nvc0->screen->base.channel;
d12 2
a13 2
    struct nvc0_surface *sf = nvc0_surface(fb->zsbuf);
    struct nvc0_miptree *mt = nvc0_miptree(sf->base.texture);
d30 5
a34 6
    MARK_RING (chan, 23, 4);
    BEGIN_RING(chan, RING_3D_(0x1590), 1); /* ZCULL_REGION_INDEX (bits 0x3f) */
    OUT_RING  (chan, 0);
    BEGIN_RING(chan, RING_3D_(0x07e8), 2); /* ZCULL_ADDRESS_A_HIGH */
    OUT_RELOCh(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
    OUT_RELOCl(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
d36 18
a53 18
    BEGIN_RING(chan, RING_3D_(0x07f0), 2); /* ZCULL_ADDRESS_B_HIGH */
    OUT_RELOCh(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
    OUT_RELOCl(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
    BEGIN_RING(chan, RING_3D_(0x07e0), 2);
    OUT_RING  (chan, size);
    OUT_RING  (chan, size >> 16);
    BEGIN_RING(chan, RING_3D_(0x15c8), 1); /* bits 0x3 */
    OUT_RING  (chan, 2);
    BEGIN_RING(chan, RING_3D_(0x07c0), 4); /* ZCULL dimensions */
    OUT_RING  (chan, width);
    OUT_RING  (chan, height);
    OUT_RING  (chan, 1);
    OUT_RING  (chan, 0);
    BEGIN_RING(chan, RING_3D_(0x15fc), 2);
    OUT_RING  (chan, 0); /* bits 0xffff */
    OUT_RING  (chan, 0); /* bits 0xffff */
    BEGIN_RING(chan, RING_3D_(0x1958), 1);
    OUT_RING  (chan, 0); /* bits ~0 */
d55 1
d60 1
a60 1
    struct nouveau_channel *chan = nvc0->screen->base.channel;
d63 1
d66 1
a66 1
    nvc0_bufctx_reset(nvc0, NVC0_BUFCTX_FRAME);
d68 42
a109 5
    BEGIN_RING(chan, RING_3D(RT_CONTROL), 1);
    OUT_RING  (chan, (076543210 << 4) | fb->nr_cbufs);
    BEGIN_RING(chan, RING_3D(SCREEN_SCISSOR_HORIZ), 2);
    OUT_RING  (chan, fb->width << 16);
    OUT_RING  (chan, fb->height << 16);
d111 1
a111 1
    MARK_RING(chan, 9 * fb->nr_cbufs, 2 * fb->nr_cbufs);
d113 2
a114 17
    for (i = 0; i < fb->nr_cbufs; ++i) {
        struct nvc0_miptree *mt = nvc0_miptree(fb->cbufs[i]->texture);
        struct nvc0_surface *sf = nvc0_surface(fb->cbufs[i]);
        struct nouveau_bo *bo = mt->base.bo;
        uint32_t offset = sf->offset;

        BEGIN_RING(chan, RING_3D(RT_ADDRESS_HIGH(i)), 9);
        OUT_RELOCh(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
        OUT_RELOCl(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
        OUT_RING  (chan, sf->width);
        OUT_RING  (chan, sf->height);
        OUT_RING  (chan, nvc0_format_table[sf->base.format].rt);
        OUT_RING  (chan, (mt->layout_3d << 16) |
                   mt->level[sf->base.u.tex.level].tile_mode);
        OUT_RING  (chan, sf->base.u.tex.first_layer + sf->depth);
        OUT_RING  (chan, mt->layer_stride >> 2);
        OUT_RING  (chan, sf->base.u.tex.first_layer);
d116 1
a116 1
        if (mt->base.status & NOUVEAU_BUFFER_STATUS_GPU_READING)
d118 2
a119 2
        mt->base.status |=  NOUVEAU_BUFFER_STATUS_GPU_WRITING;
        mt->base.status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;
d122 1
a122 2
        nvc0_bufctx_add_resident(nvc0, NVC0_BUFCTX_FRAME, &mt->base,
                                 NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
d126 2
a127 3
        struct nvc0_miptree *mt = nvc0_miptree(fb->zsbuf->texture);
        struct nvc0_surface *sf = nvc0_surface(fb->zsbuf);
        struct nouveau_bo *bo = mt->base.bo;
a128 1
        uint32_t offset = sf->offset;
d130 12
a141 13
        MARK_RING (chan, 12, 2);
        BEGIN_RING(chan, RING_3D(ZETA_ADDRESS_HIGH), 5);
        OUT_RELOCh(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
        OUT_RELOCl(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
        OUT_RING  (chan, nvc0_format_table[fb->zsbuf->format].rt);
        OUT_RING  (chan, mt->level[sf->base.u.tex.level].tile_mode);
        OUT_RING  (chan, mt->layer_stride >> 2);
        BEGIN_RING(chan, RING_3D(ZETA_ENABLE), 1);
        OUT_RING  (chan, 1);
        BEGIN_RING(chan, RING_3D(ZETA_HORIZ), 3);
        OUT_RING  (chan, sf->width);
        OUT_RING  (chan, sf->height);
        OUT_RING  (chan, (unk << 16) |
d143 4
a146 2
        BEGIN_RING(chan, RING_3D(ZETA_BASE_LAYER), 1);
        OUT_RING  (chan, sf->base.u.tex.first_layer);
d153 1
a153 2
        nvc0_bufctx_add_resident(nvc0, NVC0_BUFCTX_FRAME, &mt->base,
                                 NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
d155 2
a156 2
        BEGIN_RING(chan, RING_3D(ZETA_ENABLE), 1);
        OUT_RING  (chan, 0);
d159 6
a164 4
    if (serialize) {
       BEGIN_RING(chan, RING_3D(SERIALIZE), 1);
       OUT_RING  (chan, 0);
    }
d170 1
a170 1
    struct nouveau_channel *chan = nvc0->screen->base.channel;
d172 5
a176 5
    BEGIN_RING(chan, RING_3D(BLEND_COLOR(0)), 4);
    OUT_RINGf (chan, nvc0->blend_colour.color[0]);
    OUT_RINGf (chan, nvc0->blend_colour.color[1]);
    OUT_RINGf (chan, nvc0->blend_colour.color[2]);
    OUT_RINGf (chan, nvc0->blend_colour.color[3]);    
d182 1
a182 1
    struct nouveau_channel *chan = nvc0->screen->base.channel;
d185 2
a186 2
    IMMED_RING(chan, RING_3D(STENCIL_FRONT_FUNC_REF), ref[0]);
    IMMED_RING(chan, RING_3D(STENCIL_BACK_FUNC_REF), ref[1]);
d192 1
a192 1
    struct nouveau_channel *chan = nvc0->screen->base.channel;
d195 1
a195 1
    BEGIN_RING(chan, RING_3D(POLYGON_STIPPLE_PATTERN(0)), 32);
d197 1
a197 1
        OUT_RING(chan, util_bswap32(nvc0->stipple.stipple[i]));
d203 1
a203 1
    struct nouveau_channel *chan = nvc0->screen->base.channel;
d211 1
a211 1
    BEGIN_RING(chan, RING_3D(SCISSOR_HORIZ(0)), 2);
d213 2
a214 2
       OUT_RING(chan, (s->maxx << 16) | s->minx);
       OUT_RING(chan, (s->maxy << 16) | s->miny);
d216 2
a217 2
       OUT_RING(chan, (0xffff << 16) | 0);
       OUT_RING(chan, (0xffff << 16) | 0);
d224 1
a224 1
    struct nouveau_channel *chan = nvc0->screen->base.channel;
d229 8
a236 8
    BEGIN_RING(chan, RING_3D(VIEWPORT_TRANSLATE_X(0)), 3);
    OUT_RINGf (chan, vp->translate[0]);
    OUT_RINGf (chan, vp->translate[1]);
    OUT_RINGf (chan, vp->translate[2]);
    BEGIN_RING(chan, RING_3D(VIEWPORT_SCALE_X(0)), 3);
    OUT_RINGf (chan, vp->scale[0]);
    OUT_RINGf (chan, vp->scale[1]);
    OUT_RINGf (chan, vp->scale[2]);
d248 41
a288 6
    BEGIN_RING(chan, RING_3D(VIEWPORT_HORIZ(0)), 2);
    OUT_RING  (chan, (w << 16) | x);
    OUT_RING  (chan, (h << 16) | y);
    BEGIN_RING(chan, RING_3D(DEPTH_RANGE_NEAR(0)), 2);
    OUT_RINGf (chan, zmin);
    OUT_RINGf (chan, zmax);
d294 12
a305 9
   struct nouveau_channel *chan = nvc0->screen->base.channel;
   uint32_t clip;

   if (nvc0->clip.depth_clamp) {
      clip =
         NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK1_UNK1 |
         NVC0_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_NEAR |
         NVC0_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_FAR |
         NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK2;
d307 2
a308 1
      clip = NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK1_UNK1;
d311 2
a312 2
   BEGIN_RING(chan, RING_3D(VIEW_VOLUME_CLIP_CTRL), 1);
   OUT_RING  (chan, clip);
d314 14
a327 16
   if (nvc0->clip.nr) {
      struct nouveau_bo *bo = nvc0->screen->uniforms;

      MARK_RING (chan, 6 + nvc0->clip.nr * 4, 2);
      BEGIN_RING(chan, RING_3D(CB_SIZE), 3);
      OUT_RING  (chan, 256);
      OUT_RELOCh(chan, bo, 5 << 16, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);
      OUT_RELOCl(chan, bo, 5 << 16, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);
      BEGIN_RING_1I(chan, RING_3D(CB_POS), nvc0->clip.nr * 4 + 1);
      OUT_RING  (chan, 0);
      OUT_RINGp (chan, &nvc0->clip.ucp[0][0], nvc0->clip.nr * 4);

      BEGIN_RING(chan, RING_3D(VP_CLIP_DISTANCE_ENABLE), 1);
      OUT_RING  (chan, (1 << nvc0->clip.nr) - 1);
   } else {
      IMMED_RING(chan, RING_3D(VP_CLIP_DISTANCE_ENABLE), 0);
d334 1
a334 1
   struct nouveau_channel *chan = nvc0->screen->base.channel;
d336 2
a337 2
   WAIT_RING(chan, nvc0->blend->size);
   OUT_RINGp(chan, nvc0->blend->state, nvc0->blend->size);
d343 1
a343 1
   struct nouveau_channel *chan = nvc0->screen->base.channel;
d345 2
a346 2
   WAIT_RING(chan, nvc0->zsa->size);
   OUT_RINGp(chan, nvc0->zsa->state, nvc0->zsa->size);
d352 1
a352 1
   struct nouveau_channel *chan = nvc0->screen->base.channel;
d354 2
a355 2
   WAIT_RING(chan, nvc0->rast->size);
   OUT_RINGp(chan, nvc0->rast->state, nvc0->rast->size);
d361 1
a361 2
   struct nouveau_channel *chan = nvc0->screen->base.channel;
   struct nouveau_bo *bo;
a364 3
      struct nv04_resource *res;
      int i;

d366 1
a366 5
         unsigned base = 0;
         unsigned offset = 0, words = 0;
         boolean rebind = TRUE;

         i = ffs(nvc0->constbuf_dirty[s]) - 1;
d369 31
a399 8
         res = nv04_resource(nvc0->constbuf[s][i]);
         if (!res) {
            BEGIN_RING(chan, RING_3D(CB_BIND(s)), 1);
            OUT_RING  (chan, (i << 4) | 0);
            if (i == 0)
               nvc0->state.uniform_buffer_bound[s] = 0;
            continue;
         }
d401 1
a401 10
         if (!nouveau_resource_mapped_by_gpu(&res->base)) {
            if (i == 0) {
               base = s << 16;
               bo = nvc0->screen->uniforms;

               if (nvc0->state.uniform_buffer_bound[s] >= res->base.width0)
                  rebind = FALSE;
               else
                  nvc0->state.uniform_buffer_bound[s] =
                     align(res->base.width0, 0x100);
d403 2
a404 1
               bo = res->bo;
a405 10
#if 0
            nvc0_m2mf_push_linear(nvc0, bo, NOUVEAU_BO_VRAM,
                                  base, res->base.width0, res->data);
            BEGIN_RING(chan, RING_3D_(0x021c), 1);
            OUT_RING  (chan, 0x1111);
#else
            words = res->base.width0 / 4;
#endif
         } else {
            bo = res->bo;
d409 3
d413 4
a416 13
         if (bo != nvc0->screen->uniforms)
            nvc0_bufctx_add_resident(nvc0, NVC0_BUFCTX_CONSTANT, res,
                                     NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);

         if (rebind) {
            MARK_RING (chan, 4, 2);
            BEGIN_RING(chan, RING_3D(CB_SIZE), 3);
            OUT_RING  (chan, align(res->base.width0, 0x100));
            OUT_RELOCh(chan, bo, base, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);
            OUT_RELOCl(chan, bo, base, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);
            BEGIN_RING(chan, RING_3D(CB_BIND(s)), 1);
            OUT_RING  (chan, (i << 4) | 1);
         }
d418 22
a439 8
         while (words) {
            unsigned nr = AVAIL_RING(chan);

            if (nr < 16) {
               FIRE_RING(chan);
               continue;
            }
            nr = MIN2(MIN2(nr - 6, words), NV04_PFIFO_MAX_PACKET_LEN - 1);
d441 6
a446 13
            MARK_RING (chan, nr + 5, 2);
            BEGIN_RING(chan, RING_3D(CB_SIZE), 3);
            OUT_RING  (chan, align(res->base.width0, 0x100));
            OUT_RELOCh(chan, bo, base, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);
            OUT_RELOCl(chan, bo, base, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);
            BEGIN_RING_1I(chan, RING_3D(CB_POS), nr + 1);
            OUT_RING  (chan, offset);
            OUT_RINGp (chan, &res->data[offset], nr);

            offset += nr * 4;
            words -= nr;
         }
      }
d453 2
a454 2
   struct nouveau_channel *chan = nvc0->screen->base.channel;
   boolean early_z;
d456 8
a463 1
   early_z = nvc0->fragprog->fp.early_z && !nvc0->zsa->pipe.alpha.enabled;
d465 3
a467 3
   if (early_z != nvc0->state.early_z) {
      nvc0->state.early_z = early_z;
      IMMED_RING(chan, RING_3D(EARLY_FRAGMENT_TESTS), early_z);
d475 1
d482 5
d489 2
d500 1
a500 1
      ctx_to->dirty &= ~NVC0_NEW_RASTERIZER;
d514 1
a520 1
    { nvc0_validate_clip,          NVC0_NEW_CLIP },
d526 6
a531 1
    { nvc0_validate_derived_1,     NVC0_NEW_FRAGPROG | NVC0_NEW_ZSA },
d535 1
d537 3
a539 1
    { nvc0_tfb_validate,           NVC0_NEW_TFB | NVC0_NEW_TFB_BUFFERS }
d544 1
a544 1
nvc0_state_validate(struct nvc0_context *nvc0)
d546 2
d553 3
a555 1
   if (nvc0->dirty) {
d559 1
a559 1
         if (nvc0->dirty & validate->states)
d562 3
a564 1
      nvc0->dirty = 0;
d567 7
a573 1
   nvc0_bufctx_emit_relocs(nvc0);
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@a5 1
#if 0
d9 1
a9 1
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d11 2
a12 2
    struct nv50_surface *sf = nv50_surface(fb->zsbuf);
    struct nv50_miptree *mt = nv50_miptree(sf->base.texture);
d29 6
a34 5
    BEGIN_NVC0(push, NVC0_3D(ZCULL_REGION), 1);
    PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(ZCULL_ADDRESS_HIGH), 2);
    PUSH_DATAh(push, bo->offset + offset);
    PUSH_DATA (push, bo->offset + offset);
d36 18
a53 18
    BEGIN_NVC0(push, NVC0_3D(ZCULL_LIMIT_HIGH), 2);
    PUSH_DATAh(push, bo->offset + offset);
    PUSH_DATA (push, bo->offset + offset);
    BEGIN_NVC0(push, SUBC_3D(0x07e0), 2);
    PUSH_DATA (push, size);
    PUSH_DATA (push, size >> 16);
    BEGIN_NVC0(push, SUBC_3D(0x15c8), 1); /* bits 0x3 */
    PUSH_DATA (push, 2);
    BEGIN_NVC0(push, NVC0_3D(ZCULL_WIDTH), 4);
    PUSH_DATA (push, width);
    PUSH_DATA (push, height);
    PUSH_DATA (push, 1);
    PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(ZCULL_WINDOW_OFFSET_X), 2);
    PUSH_DATA (push, 0);
    PUSH_DATA (push, 0);
    BEGIN_NVC0(push, NVC0_3D(ZCULL_INVALIDATE), 1);
    PUSH_DATA (push, 0);
a54 1
#endif
d59 1
a59 1
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
a61 1
    unsigned ms_mode = NVC0_3D_MULTISAMPLE_MODE_MS1;
d64 1
a64 1
    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_FB);
d66 7
a72 5
    BEGIN_NVC0(push, NVC0_3D(RT_CONTROL), 1);
    PUSH_DATA (push, (076543210 << 4) | fb->nr_cbufs);
    BEGIN_NVC0(push, NVC0_3D(SCREEN_SCISSOR_HORIZ), 2);
    PUSH_DATA (push, fb->width << 16);
    PUSH_DATA (push, fb->height << 16);
d75 16
a90 35
        struct nv50_surface *sf = nv50_surface(fb->cbufs[i]);
        struct nv04_resource *res = nv04_resource(sf->base.texture);
        struct nouveau_bo *bo = res->bo;

        BEGIN_NVC0(push, NVC0_3D(RT_ADDRESS_HIGH(i)), 9);
        PUSH_DATAh(push, res->address + sf->offset);
        PUSH_DATA (push, res->address + sf->offset);
        if (likely(nouveau_bo_memtype(bo))) {
           struct nv50_miptree *mt = nv50_miptree(sf->base.texture);

           assert(sf->base.texture->target != PIPE_BUFFER);

           PUSH_DATA(push, sf->width);
           PUSH_DATA(push, sf->height);
           PUSH_DATA(push, nvc0_format_table[sf->base.format].rt);
           PUSH_DATA(push, (mt->layout_3d << 16) |
                    mt->level[sf->base.u.tex.level].tile_mode);
           PUSH_DATA(push, sf->base.u.tex.first_layer + sf->depth);
           PUSH_DATA(push, mt->layer_stride >> 2);
           PUSH_DATA(push, sf->base.u.tex.first_layer);

           ms_mode = mt->ms_mode;
        } else {
           if (res->base.target == PIPE_BUFFER) {
              PUSH_DATA(push, 262144);
              PUSH_DATA(push, 1);
           } else {
              PUSH_DATA(push, nv50_miptree(sf->base.texture)->level[0].pitch);
              PUSH_DATA(push, sf->height);
           }
           PUSH_DATA(push, nvc0_format_table[sf->base.format].rt);
           PUSH_DATA(push, 1 << 12);
           PUSH_DATA(push, 1);
           PUSH_DATA(push, 0);
           PUSH_DATA(push, 0);
d92 1
a92 6
           nvc0_resource_fence(res, NOUVEAU_BO_WR);

           assert(!fb->zsbuf);
        }

        if (res->status & NOUVEAU_BUFFER_STATUS_GPU_READING)
d94 2
a95 2
        res->status |=  NOUVEAU_BUFFER_STATUS_GPU_WRITING;
        res->status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;
d98 2
a99 1
        BCTX_REFN(nvc0->bufctx_3d, FB, res, WR);
d103 3
a105 2
        struct nv50_miptree *mt = nv50_miptree(fb->zsbuf->texture);
        struct nv50_surface *sf = nv50_surface(fb->zsbuf);
d107 1
d109 13
a121 12
        BEGIN_NVC0(push, NVC0_3D(ZETA_ADDRESS_HIGH), 5);
        PUSH_DATAh(push, mt->base.address + sf->offset);
        PUSH_DATA (push, mt->base.address + sf->offset);
        PUSH_DATA (push, nvc0_format_table[fb->zsbuf->format].rt);
        PUSH_DATA (push, mt->level[sf->base.u.tex.level].tile_mode);
        PUSH_DATA (push, mt->layer_stride >> 2);
        BEGIN_NVC0(push, NVC0_3D(ZETA_ENABLE), 1);
        PUSH_DATA (push, 1);
        BEGIN_NVC0(push, NVC0_3D(ZETA_HORIZ), 3);
        PUSH_DATA (push, sf->width);
        PUSH_DATA (push, sf->height);
        PUSH_DATA (push, (unk << 16) |
d123 2
a124 4
        BEGIN_NVC0(push, NVC0_3D(ZETA_BASE_LAYER), 1);
        PUSH_DATA (push, sf->base.u.tex.first_layer);

        ms_mode = mt->ms_mode;
d131 2
a132 1
        BCTX_REFN(nvc0->bufctx_3d, FB, &mt->base, WR);
d134 2
a135 2
        BEGIN_NVC0(push, NVC0_3D(ZETA_ENABLE), 1);
        PUSH_DATA (push, 0);
d138 4
a141 6
    IMMED_NVC0(push, NVC0_3D(MULTISAMPLE_MODE), ms_mode);

    if (serialize)
       IMMED_NVC0(push, NVC0_3D(SERIALIZE), 0);

    NOUVEAU_DRV_STAT(&nvc0->screen->base, gpu_serialize_count, serialize);
d147 1
a147 1
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d149 5
a153 5
   BEGIN_NVC0(push, NVC0_3D(BLEND_COLOR(0)), 4);
   PUSH_DATAf(push, nvc0->blend_colour.color[0]);
   PUSH_DATAf(push, nvc0->blend_colour.color[1]);
   PUSH_DATAf(push, nvc0->blend_colour.color[2]);
   PUSH_DATAf(push, nvc0->blend_colour.color[3]);
d159 1
a159 1
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d162 2
a163 2
    IMMED_NVC0(push, NVC0_3D(STENCIL_FRONT_FUNC_REF), ref[0]);
    IMMED_NVC0(push, NVC0_3D(STENCIL_BACK_FUNC_REF), ref[1]);
d169 1
a169 1
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d172 1
a172 1
    BEGIN_NVC0(push, NVC0_3D(POLYGON_STIPPLE_PATTERN(0)), 32);
d174 1
a174 1
        PUSH_DATA(push, util_bswap32(nvc0->stipple.stipple[i]));
d180 1
a180 1
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d188 1
a188 1
    BEGIN_NVC0(push, NVC0_3D(SCISSOR_HORIZ(0)), 2);
d190 2
a191 2
       PUSH_DATA(push, (s->maxx << 16) | s->minx);
       PUSH_DATA(push, (s->maxy << 16) | s->miny);
d193 2
a194 2
       PUSH_DATA(push, (0xffff << 16) | 0);
       PUSH_DATA(push, (0xffff << 16) | 0);
d201 1
a201 1
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d206 8
a213 8
    BEGIN_NVC0(push, NVC0_3D(VIEWPORT_TRANSLATE_X(0)), 3);
    PUSH_DATAf(push, vp->translate[0]);
    PUSH_DATAf(push, vp->translate[1]);
    PUSH_DATAf(push, vp->translate[2]);
    BEGIN_NVC0(push, NVC0_3D(VIEWPORT_SCALE_X(0)), 3);
    PUSH_DATAf(push, vp->scale[0]);
    PUSH_DATAf(push, vp->scale[1]);
    PUSH_DATAf(push, vp->scale[2]);
d225 6
a230 41
    BEGIN_NVC0(push, NVC0_3D(VIEWPORT_HORIZ(0)), 2);
    PUSH_DATA (push, (w << 16) | x);
    PUSH_DATA (push, (h << 16) | y);
    BEGIN_NVC0(push, NVC0_3D(DEPTH_RANGE_NEAR(0)), 2);
    PUSH_DATAf(push, zmin);
    PUSH_DATAf(push, zmax);
}

static INLINE void
nvc0_upload_uclip_planes(struct nvc0_context *nvc0, unsigned s)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nouveau_bo *bo = nvc0->screen->uniform_bo;

   BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
   PUSH_DATA (push, 512);
   PUSH_DATAh(push, bo->offset + (5 << 16) + (s << 9));
   PUSH_DATA (push, bo->offset + (5 << 16) + (s << 9));
   BEGIN_1IC0(push, NVC0_3D(CB_POS), PIPE_MAX_CLIP_PLANES * 4 + 1);
   PUSH_DATA (push, 256);
   PUSH_DATAp(push, &nvc0->clip.ucp[0][0], PIPE_MAX_CLIP_PLANES * 4);
}

static INLINE void
nvc0_check_program_ucps(struct nvc0_context *nvc0,
                        struct nvc0_program *vp, uint8_t mask)
{
   const unsigned n = util_logbase2(mask) + 1;

   if (vp->vp.num_ucps >= n)
      return;
   nvc0_program_destroy(nvc0, vp);

   vp->vp.num_ucps = n;
   if (likely(vp == nvc0->vertprog))
      nvc0_vertprog_validate(nvc0);
   else
   if (likely(vp == nvc0->gmtyprog))
      nvc0_vertprog_validate(nvc0);
   else
      nvc0_tevlprog_validate(nvc0);
d236 9
a244 12
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nvc0_program *vp;
   unsigned stage;
   uint8_t clip_enable = nvc0->rast->pipe.clip_plane_enable;

   if (nvc0->gmtyprog) {
      stage = 3;
      vp = nvc0->gmtyprog;
   } else
   if (nvc0->tevlprog) {
      stage = 2;
      vp = nvc0->tevlprog;
d246 1
a246 2
      stage = 0;
      vp = nvc0->vertprog;
d249 2
a250 2
   if (clip_enable && vp->vp.num_ucps < PIPE_MAX_CLIP_PLANES)
      nvc0_check_program_ucps(nvc0, vp, clip_enable);
d252 16
a267 14
   if (nvc0->dirty & (NVC0_NEW_CLIP | (NVC0_NEW_VERTPROG << stage)))
      if (vp->vp.num_ucps > 0 && vp->vp.num_ucps <= PIPE_MAX_CLIP_PLANES)
         nvc0_upload_uclip_planes(nvc0, stage);

   clip_enable &= vp->vp.clip_enable;

   if (nvc0->state.clip_enable != clip_enable) {
      nvc0->state.clip_enable = clip_enable;
      IMMED_NVC0(push, NVC0_3D(CLIP_DISTANCE_ENABLE), clip_enable);
   }
   if (nvc0->state.clip_mode != vp->vp.clip_mode) {
      nvc0->state.clip_mode = vp->vp.clip_mode;
      BEGIN_NVC0(push, NVC0_3D(CLIP_DISTANCE_MODE), 1);
      PUSH_DATA (push, vp->vp.clip_mode);
d274 1
a274 1
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d276 2
a277 2
   PUSH_SPACE(push, nvc0->blend->size);
   PUSH_DATAp(push, nvc0->blend->state, nvc0->blend->size);
d283 1
a283 1
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d285 2
a286 2
   PUSH_SPACE(push, nvc0->zsa->size);
   PUSH_DATAp(push, nvc0->zsa->state, nvc0->zsa->size);
d292 1
a292 1
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d294 2
a295 2
   PUSH_SPACE(push, nvc0->rast->size);
   PUSH_DATAp(push, nvc0->rast->state, nvc0->rast->size);
d301 2
a302 1
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d306 3
d310 5
a314 1
         int i = ffs(nvc0->constbuf_dirty[s]) - 1;
d317 8
a324 31
         if (nvc0->constbuf[s][i].user) {
            struct nouveau_bo *bo = nvc0->screen->uniform_bo;
            const unsigned base = s << 16;
            const unsigned size = nvc0->constbuf[s][0].size;
            assert(i == 0); /* we really only want OpenGL uniforms here */
            assert(nvc0->constbuf[s][0].u.data);

            if (nvc0->state.uniform_buffer_bound[s] < size) {
               nvc0->state.uniform_buffer_bound[s] = align(size, 0x100);

               BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
               PUSH_DATA (push, nvc0->state.uniform_buffer_bound[s]);
               PUSH_DATAh(push, bo->offset + base);
               PUSH_DATA (push, bo->offset + base);
               BEGIN_NVC0(push, NVC0_3D(CB_BIND(s)), 1);
               PUSH_DATA (push, (0 << 4) | 1);
            }
            nvc0_cb_push(&nvc0->base, bo, NOUVEAU_BO_VRAM,
                         base, nvc0->state.uniform_buffer_bound[s],
                         0, (size + 3) / 4,
                         nvc0->constbuf[s][0].u.data);
         } else {
            struct nv04_resource *res =
               nv04_resource(nvc0->constbuf[s][i].u.buf);
            if (res) {
               BEGIN_NVC0(push, NVC0_3D(CB_SIZE), 3);
               PUSH_DATA (push, nvc0->constbuf[s][i].size);
               PUSH_DATAh(push, res->address + nvc0->constbuf[s][i].offset);
               PUSH_DATA (push, res->address + nvc0->constbuf[s][i].offset);
               BEGIN_NVC0(push, NVC0_3D(CB_BIND(s)), 1);
               PUSH_DATA (push, (i << 4) | 1);
d326 10
a335 1
               BCTX_REFN(nvc0->bufctx_3d, CB(s, i), res, RD);
d337 1
a337 2
               BEGIN_NVC0(push, NVC0_3D(CB_BIND(s)), 1);
               PUSH_DATA (push, (i << 4) | 0);
d339 10
a351 3
      }
   }
}
d353 22
a374 4
static void
nvc0_validate_sample_mask(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d376 8
a383 22
   unsigned mask[4] =
   {
      nvc0->sample_mask & 0xffff,
      nvc0->sample_mask & 0xffff,
      nvc0->sample_mask & 0xffff,
      nvc0->sample_mask & 0xffff
   };

   BEGIN_NVC0(push, NVC0_3D(MSAA_MASK(0)), 4);
   PUSH_DATA (push, mask[0]);
   PUSH_DATA (push, mask[1]);
   PUSH_DATA (push, mask[2]);
   PUSH_DATA (push, mask[3]);
   BEGIN_NVC0(push, NVC0_3D(SAMPLE_SHADING), 1);
   PUSH_DATA (push, 0x01);
}

void
nvc0_validate_global_residents(struct nvc0_context *nvc0,
                               struct nouveau_bufctx *bctx, int bin)
{
   unsigned i;
d385 4
a388 6
   for (i = 0; i < nvc0->global_residents.size / sizeof(struct pipe_resource *);
        ++i) {
      struct pipe_resource *res = *util_dynarray_element(
         &nvc0->global_residents, struct pipe_resource *, i);
      if (res)
         nvc0_add_resident(bctx, bin, nv04_resource(res), NOUVEAU_BO_RDWR);
d395 2
a396 2
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   boolean rasterizer_discard;
d398 1
a398 8
   if (nvc0->rast && nvc0->rast->pipe.rasterizer_discard) {
      rasterizer_discard = TRUE;
   } else {
      boolean zs = nvc0->zsa &&
         (nvc0->zsa->pipe.depth.enabled || nvc0->zsa->pipe.stencil[0].enabled);
      rasterizer_discard = !zs &&
         (!nvc0->fragprog || !nvc0->fragprog->hdr[18]);
   }
d400 3
a402 3
   if (rasterizer_discard != nvc0->state.rasterizer_discard) {
      nvc0->state.rasterizer_discard = rasterizer_discard;
      IMMED_NVC0(push, NVC0_3D(RASTERIZE_ENABLE), !rasterizer_discard);
a409 1
   unsigned s;
a415 5
   for (s = 0; s < 5; ++s) {
      ctx_to->samplers_dirty[s] = ~0;
      ctx_to->textures_dirty[s] = ~0;
   }

a417 2
   if (!ctx_to->idxbuf.buffer)
      ctx_to->dirty &= ~NVC0_NEW_IDXBUF;
d427 1
a427 1
      ctx_to->dirty &= ~(NVC0_NEW_RASTERIZER | NVC0_NEW_SCISSOR);
a440 1
    { nvc0_validate_sample_mask,   NVC0_NEW_SAMPLE_MASK },
d447 1
d453 1
a453 6
    { nvc0_validate_derived_1,     NVC0_NEW_FRAGPROG | NVC0_NEW_ZSA |
                                   NVC0_NEW_RASTERIZER },
    { nvc0_validate_clip,          NVC0_NEW_CLIP | NVC0_NEW_RASTERIZER |
                                   NVC0_NEW_VERTPROG |
                                   NVC0_NEW_TEVLPROG |
                                   NVC0_NEW_GMTYPROG },
a456 1
    { nve4_set_tex_handles,        NVC0_NEW_TEXTURES | NVC0_NEW_SAMPLERS },
d458 1
a458 3
    { nvc0_validate_surfaces,      NVC0_NEW_SURFACES },
    { nvc0_idxbuf_validate,        NVC0_NEW_IDXBUF },
    { nvc0_tfb_validate,           NVC0_NEW_TFB_TARGETS | NVC0_NEW_GMTYPROG }
d463 1
a463 1
nvc0_state_validate(struct nvc0_context *nvc0, uint32_t mask, unsigned words)
a464 2
   uint32_t state_mask;
   int ret;
d470 1
a470 3
   state_mask = nvc0->dirty & mask;

   if (state_mask) {
d474 1
a474 1
         if (state_mask & validate->states)
d477 1
a477 3
      nvc0->dirty &= ~state_mask;

      nvc0_bufctx_fence(nvc0, nvc0->bufctx_3d, FALSE);
d480 1
a480 7
   nouveau_pushbuf_bufctx(nvc0->base.pushbuf, nvc0->bufctx_3d);
   ret = nouveau_pushbuf_validate(nvc0->base.pushbuf);
   if (unlikely(ret))
      return FALSE;

   if (unlikely(nvc0->state.flushed))
      nvc0_bufctx_fence(nvc0, nvc0->bufctx_3d, TRUE);
@


1.1.1.2
log
@Import Mesa 9.2.1
@
text
@a247 2
    nvc0->vport_int[0] = (w << 16) | x;
    nvc0->vport_int[1] = (h << 16) | y;
d249 2
a250 2
    PUSH_DATA (push, nvc0->vport_int[0]);
    PUSH_DATA (push, nvc0->vport_int[1]);
@


