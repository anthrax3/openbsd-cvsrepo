head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.00.48;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2010 Christoph Bumiller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "pipe/p_defines.h"
#include "util/u_helpers.h"
#include "util/u_inlines.h"
#include "util/u_transfer.h"

#include "tgsi/tgsi_parse.h"

#include "nvc0_stateobj.h"
#include "nvc0_context.h"

#include "nvc0_3d.xml.h"
#include "nv50/nv50_texture.xml.h"

#include "nouveau/nouveau_gldefs.h"

static INLINE uint32_t
nvc0_colormask(unsigned mask)
{
    uint32_t ret = 0;

    if (mask & PIPE_MASK_R)
        ret |= 0x0001;
    if (mask & PIPE_MASK_G)
        ret |= 0x0010;
    if (mask & PIPE_MASK_B)
        ret |= 0x0100;
    if (mask & PIPE_MASK_A)
        ret |= 0x1000;

    return ret;
}

#define NVC0_BLEND_FACTOR_CASE(a, b) \
   case PIPE_BLENDFACTOR_##a: return NV50_3D_BLEND_FACTOR_##b

static INLINE uint32_t
nvc0_blend_fac(unsigned factor)
{
   switch (factor) {
   NVC0_BLEND_FACTOR_CASE(ONE, ONE);
   NVC0_BLEND_FACTOR_CASE(SRC_COLOR, SRC_COLOR);
   NVC0_BLEND_FACTOR_CASE(SRC_ALPHA, SRC_ALPHA);
   NVC0_BLEND_FACTOR_CASE(DST_ALPHA, DST_ALPHA);
   NVC0_BLEND_FACTOR_CASE(DST_COLOR, DST_COLOR);
   NVC0_BLEND_FACTOR_CASE(SRC_ALPHA_SATURATE, SRC_ALPHA_SATURATE);
   NVC0_BLEND_FACTOR_CASE(CONST_COLOR, CONSTANT_COLOR);
   NVC0_BLEND_FACTOR_CASE(CONST_ALPHA, CONSTANT_ALPHA);
   NVC0_BLEND_FACTOR_CASE(SRC1_COLOR, SRC1_COLOR);
   NVC0_BLEND_FACTOR_CASE(SRC1_ALPHA, SRC1_ALPHA);
   NVC0_BLEND_FACTOR_CASE(ZERO, ZERO);
   NVC0_BLEND_FACTOR_CASE(INV_SRC_COLOR, ONE_MINUS_SRC_COLOR);
   NVC0_BLEND_FACTOR_CASE(INV_SRC_ALPHA, ONE_MINUS_SRC_ALPHA);
   NVC0_BLEND_FACTOR_CASE(INV_DST_ALPHA, ONE_MINUS_DST_ALPHA);
   NVC0_BLEND_FACTOR_CASE(INV_DST_COLOR, ONE_MINUS_DST_COLOR);
   NVC0_BLEND_FACTOR_CASE(INV_CONST_COLOR, ONE_MINUS_CONSTANT_COLOR);
   NVC0_BLEND_FACTOR_CASE(INV_CONST_ALPHA, ONE_MINUS_CONSTANT_ALPHA);
   NVC0_BLEND_FACTOR_CASE(INV_SRC1_COLOR, ONE_MINUS_SRC1_COLOR);
   NVC0_BLEND_FACTOR_CASE(INV_SRC1_ALPHA, ONE_MINUS_SRC1_ALPHA);
   default:
      return NV50_3D_BLEND_FACTOR_ZERO;
   }
}

static void *
nvc0_blend_state_create(struct pipe_context *pipe,
                        const struct pipe_blend_state *cso)
{
   struct nvc0_blend_stateobj *so = CALLOC_STRUCT(nvc0_blend_stateobj);
   int i;
   int r; /* reference */
   uint32_t ms;
   uint8_t blend_en = 0;
   boolean indep_masks = FALSE;
   boolean indep_funcs = FALSE;

   so->pipe = *cso;

   /* check which states actually have differing values */
   if (cso->independent_blend_enable) {
      for (r = 0; r < 8 && !cso->rt[r].blend_enable; ++r);
      blend_en |= 1 << r;
      for (i = r + 1; i < 8; ++i) {
         if (!cso->rt[i].blend_enable)
            continue;
         blend_en |= 1 << i;
         if (cso->rt[i].rgb_func != cso->rt[r].rgb_func ||
             cso->rt[i].rgb_src_factor != cso->rt[r].rgb_src_factor ||
             cso->rt[i].rgb_dst_factor != cso->rt[r].rgb_dst_factor ||
             cso->rt[i].alpha_func != cso->rt[r].alpha_func ||
             cso->rt[i].alpha_src_factor != cso->rt[r].alpha_src_factor ||
             cso->rt[i].alpha_dst_factor != cso->rt[r].alpha_dst_factor) {
            indep_funcs = TRUE;
            break;
         }
      }
      for (; i < 8; ++i)
         blend_en |= (cso->rt[i].blend_enable ? 1 : 0) << i;

      for (i = 1; i < 8; ++i) {
         if (cso->rt[i].colormask != cso->rt[0].colormask) {
            indep_masks = TRUE;
            break;
         }
      }
   } else {
      r = 0;
      if (cso->rt[0].blend_enable)
         blend_en = 0xff;
   }

   if (cso->logicop_enable) {
      SB_BEGIN_3D(so, LOGIC_OP_ENABLE, 2);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_logicop_func(cso->logicop_func));

      SB_IMMED_3D(so, MACRO_BLEND_ENABLES, 0);
   } else {
      SB_IMMED_3D(so, LOGIC_OP_ENABLE, 0);

      SB_IMMED_3D(so, BLEND_INDEPENDENT, indep_funcs);
      SB_IMMED_3D(so, MACRO_BLEND_ENABLES, blend_en);
      if (indep_funcs) {
         for (i = 0; i < 8; ++i) {
            if (cso->rt[i].blend_enable) {
               SB_BEGIN_3D(so, IBLEND_EQUATION_RGB(i), 6);
               SB_DATA    (so, nvgl_blend_eqn(cso->rt[i].rgb_func));
               SB_DATA    (so, nvc0_blend_fac(cso->rt[i].rgb_src_factor));
               SB_DATA    (so, nvc0_blend_fac(cso->rt[i].rgb_dst_factor));
               SB_DATA    (so, nvgl_blend_eqn(cso->rt[i].alpha_func));
               SB_DATA    (so, nvc0_blend_fac(cso->rt[i].alpha_src_factor));
               SB_DATA    (so, nvc0_blend_fac(cso->rt[i].alpha_dst_factor));
            }
         }
      } else
      if (blend_en) {
         SB_BEGIN_3D(so, BLEND_EQUATION_RGB, 5);
         SB_DATA    (so, nvgl_blend_eqn(cso->rt[r].rgb_func));
         SB_DATA    (so, nvc0_blend_fac(cso->rt[r].rgb_src_factor));
         SB_DATA    (so, nvc0_blend_fac(cso->rt[r].rgb_dst_factor));
         SB_DATA    (so, nvgl_blend_eqn(cso->rt[r].alpha_func));
         SB_DATA    (so, nvc0_blend_fac(cso->rt[r].alpha_src_factor));
         SB_BEGIN_3D(so, BLEND_FUNC_DST_ALPHA, 1);
         SB_DATA    (so, nvc0_blend_fac(cso->rt[r].alpha_dst_factor));
      }

      SB_IMMED_3D(so, COLOR_MASK_COMMON, !indep_masks);
      if (indep_masks) {
         SB_BEGIN_3D(so, COLOR_MASK(0), 8);
         for (i = 0; i < 8; ++i)
            SB_DATA(so, nvc0_colormask(cso->rt[i].colormask));
      } else {
         SB_BEGIN_3D(so, COLOR_MASK(0), 1);
         SB_DATA    (so, nvc0_colormask(cso->rt[0].colormask));
      }
   }

   ms = 0;
   if (cso->alpha_to_coverage)
      ms |= NVC0_3D_MULTISAMPLE_CTRL_ALPHA_TO_COVERAGE;
   if (cso->alpha_to_one)
      ms |= NVC0_3D_MULTISAMPLE_CTRL_ALPHA_TO_ONE;

   SB_BEGIN_3D(so, MULTISAMPLE_CTRL, 1);
   SB_DATA    (so, ms);

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return so;
}

static void
nvc0_blend_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->blend = hwcso;
    nvc0->dirty |= NVC0_NEW_BLEND;
}

static void
nvc0_blend_state_delete(struct pipe_context *pipe, void *hwcso)
{
    FREE(hwcso);
}

/* NOTE: ignoring line_last_pixel, using FALSE (set on screen init) */
static void *
nvc0_rasterizer_state_create(struct pipe_context *pipe,
                             const struct pipe_rasterizer_state *cso)
{
    struct nvc0_rasterizer_stateobj *so;
    uint32_t reg;

    so = CALLOC_STRUCT(nvc0_rasterizer_stateobj);
    if (!so)
        return NULL;
    so->pipe = *cso;

    /* Scissor enables are handled in scissor state, we will not want to
     * always emit 16 commands, one for each scissor rectangle, here.
     */
    
    SB_BEGIN_3D(so, SHADE_MODEL, 1);
    SB_DATA    (so, cso->flatshade ? NVC0_3D_SHADE_MODEL_FLAT :
                                     NVC0_3D_SHADE_MODEL_SMOOTH);
    SB_IMMED_3D(so, PROVOKING_VERTEX_LAST, !cso->flatshade_first);
    SB_IMMED_3D(so, VERTEX_TWO_SIDE_ENABLE, cso->light_twoside);

    SB_IMMED_3D(so, VERT_COLOR_CLAMP_EN, cso->clamp_vertex_color);
    SB_BEGIN_3D(so, FRAG_COLOR_CLAMP_EN, 1);
    SB_DATA    (so, cso->clamp_fragment_color ? 0x11111111 : 0x00000000);

    SB_IMMED_3D(so, MULTISAMPLE_ENABLE, cso->multisample);

    SB_IMMED_3D(so, LINE_SMOOTH_ENABLE, cso->line_smooth);
    if (cso->line_smooth)
       SB_BEGIN_3D(so, LINE_WIDTH_SMOOTH, 1);
    else
       SB_BEGIN_3D(so, LINE_WIDTH_ALIASED, 1);
    SB_DATA    (so, fui(cso->line_width));

    SB_IMMED_3D(so, LINE_STIPPLE_ENABLE, cso->line_stipple_enable);
    if (cso->line_stipple_enable) {
        SB_BEGIN_3D(so, LINE_STIPPLE_PATTERN, 1);
        SB_DATA    (so, (cso->line_stipple_pattern << 8) |
                         cso->line_stipple_factor);
                    
    }

    SB_IMMED_3D(so, VP_POINT_SIZE_EN, cso->point_size_per_vertex);
    if (!cso->point_size_per_vertex) {
       SB_BEGIN_3D(so, POINT_SIZE, 1);
       SB_DATA    (so, fui(cso->point_size));
    }

    reg = (cso->sprite_coord_mode == PIPE_SPRITE_COORD_UPPER_LEFT) ?
       NVC0_3D_POINT_COORD_REPLACE_COORD_ORIGIN_UPPER_LEFT :
       NVC0_3D_POINT_COORD_REPLACE_COORD_ORIGIN_LOWER_LEFT;

    SB_BEGIN_3D(so, POINT_COORD_REPLACE, 1);
    SB_DATA    (so, ((cso->sprite_coord_enable & 0xff) << 3) | reg);
    SB_IMMED_3D(so, POINT_SPRITE_ENABLE, cso->point_quad_rasterization);
    SB_IMMED_3D(so, POINT_SMOOTH_ENABLE, cso->point_smooth);

    SB_BEGIN_3D(so, MACRO_POLYGON_MODE_FRONT, 1);
    SB_DATA    (so, nvgl_polygon_mode(cso->fill_front));
    SB_BEGIN_3D(so, MACRO_POLYGON_MODE_BACK, 1);
    SB_DATA    (so, nvgl_polygon_mode(cso->fill_back));
    SB_IMMED_3D(so, POLYGON_SMOOTH_ENABLE, cso->poly_smooth);

    SB_BEGIN_3D(so, CULL_FACE_ENABLE, 3);
    SB_DATA    (so, cso->cull_face != PIPE_FACE_NONE);
    SB_DATA    (so, cso->front_ccw ? NVC0_3D_FRONT_FACE_CCW :
                                     NVC0_3D_FRONT_FACE_CW);
    switch (cso->cull_face) {
    case PIPE_FACE_FRONT_AND_BACK:
       SB_DATA(so, NVC0_3D_CULL_FACE_FRONT_AND_BACK);
       break;
    case PIPE_FACE_FRONT:
       SB_DATA(so, NVC0_3D_CULL_FACE_FRONT);
       break;
    case PIPE_FACE_BACK:
    default:
       SB_DATA(so, NVC0_3D_CULL_FACE_BACK);
       break;
    }

    SB_IMMED_3D(so, POLYGON_STIPPLE_ENABLE, cso->poly_stipple_enable);
    SB_BEGIN_3D(so, POLYGON_OFFSET_POINT_ENABLE, 3);
    SB_DATA    (so, cso->offset_point);
    SB_DATA    (so, cso->offset_line);
    SB_DATA    (so, cso->offset_tri);

    if (cso->offset_point || cso->offset_line || cso->offset_tri) {
        SB_BEGIN_3D(so, POLYGON_OFFSET_FACTOR, 1);
        SB_DATA    (so, fui(cso->offset_scale));
        SB_BEGIN_3D(so, POLYGON_OFFSET_UNITS, 1);
        SB_DATA    (so, fui(cso->offset_units * 2.0f));
        SB_BEGIN_3D(so, POLYGON_OFFSET_CLAMP, 1);
        SB_DATA    (so, fui(cso->offset_clamp));
    }

    if (cso->depth_clip)
       reg = NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK1_UNK1;
    else
       reg =
          NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK1_UNK1 |
          NVC0_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_NEAR |
          NVC0_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_FAR |
          NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK2;

    SB_BEGIN_3D(so, VIEW_VOLUME_CLIP_CTRL, 1);
    SB_DATA    (so, reg);

    assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
    return (void *)so;
}

static void
nvc0_rasterizer_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nvc0_context *nvc0 = nvc0_context(pipe);

   nvc0->rast = hwcso;
   nvc0->dirty |= NVC0_NEW_RASTERIZER;
}

static void
nvc0_rasterizer_state_delete(struct pipe_context *pipe, void *hwcso)
{
   FREE(hwcso);
}

static void *
nvc0_zsa_state_create(struct pipe_context *pipe,
                      const struct pipe_depth_stencil_alpha_state *cso)
{
   struct nvc0_zsa_stateobj *so = CALLOC_STRUCT(nvc0_zsa_stateobj);

   so->pipe = *cso;

   SB_IMMED_3D(so, DEPTH_TEST_ENABLE, cso->depth.enabled);
   if (cso->depth.enabled) {
      SB_IMMED_3D(so, DEPTH_WRITE_ENABLE, cso->depth.writemask);
      SB_BEGIN_3D(so, DEPTH_TEST_FUNC, 1);
      SB_DATA    (so, nvgl_comparison_op(cso->depth.func));
   }

   if (cso->stencil[0].enabled) {
      SB_BEGIN_3D(so, STENCIL_ENABLE, 5);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].fail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].zfail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].zpass_op));
      SB_DATA    (so, nvgl_comparison_op(cso->stencil[0].func));
      SB_BEGIN_3D(so, STENCIL_FRONT_FUNC_MASK, 2);
      SB_DATA    (so, cso->stencil[0].valuemask);
      SB_DATA    (so, cso->stencil[0].writemask);
   } else {
      SB_IMMED_3D(so, STENCIL_ENABLE, 0);
   }

   if (cso->stencil[1].enabled) {
      assert(cso->stencil[0].enabled);
      SB_BEGIN_3D(so, STENCIL_TWO_SIDE_ENABLE, 5);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].fail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].zfail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].zpass_op));
      SB_DATA    (so, nvgl_comparison_op(cso->stencil[1].func));
      SB_BEGIN_3D(so, STENCIL_BACK_MASK, 2);
      SB_DATA    (so, cso->stencil[1].writemask);
      SB_DATA    (so, cso->stencil[1].valuemask);
   } else
   if (cso->stencil[0].enabled) {
      SB_IMMED_3D(so, STENCIL_TWO_SIDE_ENABLE, 0);
   }

   SB_IMMED_3D(so, ALPHA_TEST_ENABLE, cso->alpha.enabled);
   if (cso->alpha.enabled) {
      SB_BEGIN_3D(so, ALPHA_TEST_REF, 2);
      SB_DATA    (so, fui(cso->alpha.ref_value));
      SB_DATA    (so, nvgl_comparison_op(cso->alpha.func));
   }

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return (void *)so;
}

static void
nvc0_zsa_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nvc0_context *nvc0 = nvc0_context(pipe);

   nvc0->zsa = hwcso;
   nvc0->dirty |= NVC0_NEW_ZSA;
}

static void
nvc0_zsa_state_delete(struct pipe_context *pipe, void *hwcso)
{
   FREE(hwcso);
}

/* ====================== SAMPLERS AND TEXTURES ================================
 */

#define NV50_TSC_WRAP_CASE(n) \
    case PIPE_TEX_WRAP_##n: return NV50_TSC_WRAP_##n

static INLINE unsigned
nv50_tsc_wrap_mode(unsigned wrap)
{
   switch (wrap) {
   NV50_TSC_WRAP_CASE(REPEAT);
   NV50_TSC_WRAP_CASE(MIRROR_REPEAT);
   NV50_TSC_WRAP_CASE(CLAMP_TO_EDGE);
   NV50_TSC_WRAP_CASE(CLAMP_TO_BORDER);
   NV50_TSC_WRAP_CASE(CLAMP);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP_TO_EDGE);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP_TO_BORDER);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP);
   default:
       NOUVEAU_ERR("unknown wrap mode: %d\n", wrap);
       return NV50_TSC_WRAP_REPEAT;
   }
}

static void
nvc0_sampler_state_delete(struct pipe_context *pipe, void *hwcso)
{
   unsigned s, i;

   for (s = 0; s < 5; ++s)
      for (i = 0; i < nvc0_context(pipe)->num_samplers[s]; ++i)
         if (nvc0_context(pipe)->samplers[s][i] == hwcso)
            nvc0_context(pipe)->samplers[s][i] = NULL;

   nvc0_screen_tsc_free(nvc0_context(pipe)->screen, nv50_tsc_entry(hwcso));

   FREE(hwcso);
}

static INLINE void
nvc0_stage_sampler_states_bind(struct nvc0_context *nvc0, int s,
                               unsigned nr, void **hwcso)
{
   unsigned i;

   for (i = 0; i < nr; ++i) {
      struct nv50_tsc_entry *old = nvc0->samplers[s][i];

      if (hwcso[i] == old)
         continue;
      nvc0->samplers_dirty[s] |= 1 << i;

      nvc0->samplers[s][i] = nv50_tsc_entry(hwcso[i]);
      if (old)
         nvc0_screen_tsc_unlock(nvc0->screen, old);
   }
   for (; i < nvc0->num_samplers[s]; ++i) {
      if (nvc0->samplers[s][i]) {
         nvc0_screen_tsc_unlock(nvc0->screen, nvc0->samplers[s][i]);
         nvc0->samplers[s][i] = NULL;
      }
   }

   nvc0->num_samplers[s] = nr;

   nvc0->dirty |= NVC0_NEW_SAMPLERS;
}

static void
nvc0_vp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
{
   nvc0_stage_sampler_states_bind(nvc0_context(pipe), 0, nr, s);
}

static void
nvc0_fp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
{
   nvc0_stage_sampler_states_bind(nvc0_context(pipe), 4, nr, s);
}

static void
nvc0_gp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
{
   nvc0_stage_sampler_states_bind(nvc0_context(pipe), 3, nr, s);
}

static void
nvc0_stage_sampler_states_bind_range(struct nvc0_context *nvc0,
                                     const unsigned s,
                                     unsigned start, unsigned nr, void **cso)
{
   const unsigned end = start + nr;
   int last_valid = -1;
   unsigned i;

   if (cso) {
      for (i = start; i < end; ++i) {
         const unsigned p = i - start;
         if (cso[p])
            last_valid = i;
         if (cso[p] == nvc0->samplers[s][i])
            continue;
         nvc0->samplers_dirty[s] |= 1 << i;

         if (nvc0->samplers[s][i])
            nvc0_screen_tsc_unlock(nvc0->screen, nvc0->samplers[s][i]);
         nvc0->samplers[s][i] = cso[p];
      }
   } else {
      for (i = start; i < end; ++i) {
         if (nvc0->samplers[s][i]) {
            nvc0_screen_tsc_unlock(nvc0->screen, nvc0->samplers[s][i]);
            nvc0->samplers[s][i] = NULL;
            nvc0->samplers_dirty[s] |= 1 << i;
         }
      }
   }

   if (nvc0->num_samplers[s] <= end) {
      if (last_valid < 0) {
         for (i = start; i && !nvc0->samplers[s][i - 1]; --i);
         nvc0->num_samplers[s] = i;
      } else {
         nvc0->num_samplers[s] = last_valid + 1;
      }
   }
}

static void
nvc0_cp_sampler_states_bind(struct pipe_context *pipe,
                            unsigned start, unsigned nr, void **cso)
{
   nvc0_stage_sampler_states_bind_range(nvc0_context(pipe), 5, start, nr, cso);

   nvc0_context(pipe)->dirty_cp |= NVC0_NEW_CP_SAMPLERS;
}

/* NOTE: only called when not referenced anywhere, won't be bound */
static void
nvc0_sampler_view_destroy(struct pipe_context *pipe,
                          struct pipe_sampler_view *view)
{
   pipe_resource_reference(&view->texture, NULL);

   nvc0_screen_tic_free(nvc0_context(pipe)->screen, nv50_tic_entry(view));

   FREE(nv50_tic_entry(view));
}

static INLINE void
nvc0_stage_set_sampler_views(struct nvc0_context *nvc0, int s,
                             unsigned nr,
                             struct pipe_sampler_view **views)
{
   unsigned i;

   for (i = 0; i < nr; ++i) {
      struct nv50_tic_entry *old = nv50_tic_entry(nvc0->textures[s][i]);

      if (views[i] == nvc0->textures[s][i])
         continue;
      nvc0->textures_dirty[s] |= 1 << i;

      if (old) {
         nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_TEX(s, i));
         nvc0_screen_tic_unlock(nvc0->screen, old);
      }

      pipe_sampler_view_reference(&nvc0->textures[s][i], views[i]);
   }

   for (i = nr; i < nvc0->num_textures[s]; ++i) {
      struct nv50_tic_entry *old = nv50_tic_entry(nvc0->textures[s][i]);
      if (old) {
         nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_TEX(s, i));
         nvc0_screen_tic_unlock(nvc0->screen, old);
         pipe_sampler_view_reference(&nvc0->textures[s][i], NULL);
      }
   }

   nvc0->num_textures[s] = nr;

   nvc0->dirty |= NVC0_NEW_TEXTURES;
}

static void
nvc0_vp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
{
   nvc0_stage_set_sampler_views(nvc0_context(pipe), 0, nr, views);
}

static void
nvc0_fp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
{
   nvc0_stage_set_sampler_views(nvc0_context(pipe), 4, nr, views);
}

static void
nvc0_gp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
{
   nvc0_stage_set_sampler_views(nvc0_context(pipe), 3, nr, views);
}

static void
nvc0_stage_set_sampler_views_range(struct nvc0_context *nvc0, const unsigned s,
                                   unsigned start, unsigned nr,
                                   struct pipe_sampler_view **views)
{
   struct nouveau_bufctx *bctx = (s == 5) ? nvc0->bufctx_cp : nvc0->bufctx_3d;
   const unsigned end = start + nr;
   const unsigned bin = (s == 5) ? NVC0_BIND_CP_TEX(0) : NVC0_BIND_TEX(s, 0);
   int last_valid = -1;
   unsigned i;

   if (views) {
      for (i = start; i < end; ++i) {
         const unsigned p = i - start;
         if (views[p])
            last_valid = i;
         if (views[p] == nvc0->textures[s][i])
            continue;
         nvc0->textures_dirty[s] |= 1 << i;

         if (nvc0->textures[s][i]) {
            struct nv50_tic_entry *old = nv50_tic_entry(nvc0->textures[s][i]);
            nouveau_bufctx_reset(bctx, bin + i);
            nvc0_screen_tic_unlock(nvc0->screen, old);
         }
         pipe_sampler_view_reference(&nvc0->textures[s][i], views[p]);
      }
   } else {
      for (i = start; i < end; ++i) {
         struct nv50_tic_entry *old = nv50_tic_entry(nvc0->textures[s][i]);
         if (!old)
            continue;
         nvc0->textures_dirty[s] |= 1 << i;

         nvc0_screen_tic_unlock(nvc0->screen, old);
         pipe_sampler_view_reference(&nvc0->textures[s][i], NULL);
         nouveau_bufctx_reset(bctx, bin + i);
      }
   }

   if (nvc0->num_textures[s] <= end) {
      if (last_valid < 0) {
         for (i = start; i && !nvc0->textures[s][i - 1]; --i);
         nvc0->num_textures[s] = i;
      } else {
         nvc0->num_textures[s] = last_valid + 1;
      }
   }
}

static void
nvc0_cp_set_sampler_views(struct pipe_context *pipe,
                          unsigned start, unsigned nr,
                          struct pipe_sampler_view **views)
{
   nvc0_stage_set_sampler_views_range(nvc0_context(pipe), 5, start, nr, views);

   nvc0_context(pipe)->dirty_cp |= NVC0_NEW_CP_TEXTURES;
}


/* ============================= SHADERS =======================================
 */

static void *
nvc0_sp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso, unsigned type)
{
   struct nvc0_program *prog;

   prog = CALLOC_STRUCT(nvc0_program);
   if (!prog)
      return NULL;

   prog->type = type;

   if (cso->tokens)
      prog->pipe.tokens = tgsi_dup_tokens(cso->tokens);

   if (cso->stream_output.num_outputs)
      prog->pipe.stream_output = cso->stream_output;

   return (void *)prog;
}

static void
nvc0_sp_state_delete(struct pipe_context *pipe, void *hwcso)
{
   struct nvc0_program *prog = (struct nvc0_program *)hwcso;

   nvc0_program_destroy(nvc0_context(pipe), prog);

   FREE((void *)prog->pipe.tokens);
   FREE(prog);
}

static void *
nvc0_vp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso)
{
   return nvc0_sp_state_create(pipe, cso, PIPE_SHADER_VERTEX);
}

static void
nvc0_vp_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->vertprog = hwcso;
    nvc0->dirty |= NVC0_NEW_VERTPROG;
}

static void *
nvc0_fp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso)
{
   return nvc0_sp_state_create(pipe, cso, PIPE_SHADER_FRAGMENT);
}

static void
nvc0_fp_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->fragprog = hwcso;
    nvc0->dirty |= NVC0_NEW_FRAGPROG;
}

static void *
nvc0_gp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso)
{
   return nvc0_sp_state_create(pipe, cso, PIPE_SHADER_GEOMETRY);
}

static void
nvc0_gp_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->gmtyprog = hwcso;
    nvc0->dirty |= NVC0_NEW_GMTYPROG;
}

static void *
nvc0_cp_state_create(struct pipe_context *pipe,
                     const struct pipe_compute_state *cso)
{
   struct nvc0_program *prog;

   prog = CALLOC_STRUCT(nvc0_program);
   if (!prog)
      return NULL;
   prog->type = PIPE_SHADER_COMPUTE;

   prog->cp.smem_size = cso->req_local_mem;
   prog->cp.lmem_size = cso->req_private_mem;
   prog->parm_size = cso->req_input_mem;

   prog->pipe.tokens = tgsi_dup_tokens((const struct tgsi_token *)cso->prog);

   return (void *)prog;
}

static void
nvc0_cp_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->compprog = hwcso;
    nvc0->dirty_cp |= NVC0_NEW_CP_PROGRAM;
}

static void
nvc0_set_constant_buffer(struct pipe_context *pipe, uint shader, uint index,
                         struct pipe_constant_buffer *cb)
{
   struct nvc0_context *nvc0 = nvc0_context(pipe);
   struct pipe_resource *res = cb ? cb->buffer : NULL;
   const unsigned s = nvc0_shader_stage(shader);
   const unsigned i = index;

   if (unlikely(shader == PIPE_SHADER_COMPUTE)) {
      assert(!cb || !cb->user_buffer);
      if (nvc0->constbuf[s][i].u.buf)
         nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_CB(i));

      nvc0->dirty_cp |= NVC0_NEW_CP_CONSTBUF;
   } else {
      if (nvc0->constbuf[s][i].user)
         nvc0->constbuf[s][i].u.buf = NULL;
      else
      if (nvc0->constbuf[s][i].u.buf)
         nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_CB(s, i));

      nvc0->dirty |= NVC0_NEW_CONSTBUF;
   }
   nvc0->constbuf_dirty[s] |= 1 << i;

   pipe_resource_reference(&nvc0->constbuf[s][i].u.buf, res);

   nvc0->constbuf[s][i].user = (cb && cb->user_buffer) ? TRUE : FALSE;
   if (nvc0->constbuf[s][i].user) {
      nvc0->constbuf[s][i].u.data = cb->user_buffer;
      nvc0->constbuf[s][i].size = cb->buffer_size;
   } else
   if (cb) {
      nvc0->constbuf[s][i].offset = cb->buffer_offset;
      nvc0->constbuf[s][i].size = align(cb->buffer_size, 0x100);
   }
}

/* =============================================================================
 */

static void
nvc0_set_blend_color(struct pipe_context *pipe,
                     const struct pipe_blend_color *bcol)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->blend_colour = *bcol;
    nvc0->dirty |= NVC0_NEW_BLEND_COLOUR;
}

static void
nvc0_set_stencil_ref(struct pipe_context *pipe,
                     const struct pipe_stencil_ref *sr)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->stencil_ref = *sr;
    nvc0->dirty |= NVC0_NEW_STENCIL_REF;
}

static void
nvc0_set_clip_state(struct pipe_context *pipe,
                    const struct pipe_clip_state *clip)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    memcpy(nvc0->clip.ucp, clip->ucp, sizeof(clip->ucp));

    nvc0->dirty |= NVC0_NEW_CLIP;
}

static void
nvc0_set_sample_mask(struct pipe_context *pipe, unsigned sample_mask)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->sample_mask = sample_mask;
    nvc0->dirty |= NVC0_NEW_SAMPLE_MASK;
}


static void
nvc0_set_framebuffer_state(struct pipe_context *pipe,
                           const struct pipe_framebuffer_state *fb)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);
    unsigned i;

    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_FB);

    for (i = 0; i < fb->nr_cbufs; ++i)
       pipe_surface_reference(&nvc0->framebuffer.cbufs[i], fb->cbufs[i]);
    for (; i < nvc0->framebuffer.nr_cbufs; ++i)
       pipe_surface_reference(&nvc0->framebuffer.cbufs[i], NULL);

    nvc0->framebuffer.nr_cbufs = fb->nr_cbufs;

    nvc0->framebuffer.width = fb->width;
    nvc0->framebuffer.height = fb->height;

    pipe_surface_reference(&nvc0->framebuffer.zsbuf, fb->zsbuf);

    nvc0->dirty |= NVC0_NEW_FRAMEBUFFER;
}

static void
nvc0_set_polygon_stipple(struct pipe_context *pipe,
                         const struct pipe_poly_stipple *stipple)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->stipple = *stipple;
    nvc0->dirty |= NVC0_NEW_STIPPLE;
}

static void
nvc0_set_scissor_states(struct pipe_context *pipe,
                        unsigned start_slot,
                        unsigned num_scissors,
                        const struct pipe_scissor_state *scissor)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->scissor = *scissor;
    nvc0->dirty |= NVC0_NEW_SCISSOR;
}

static void
nvc0_set_viewport_states(struct pipe_context *pipe,
                         unsigned start_slot,
                         unsigned num_viewports,
                         const struct pipe_viewport_state *vpt)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->viewport = *vpt;
    nvc0->dirty |= NVC0_NEW_VIEWPORT;
}

static void
nvc0_set_vertex_buffers(struct pipe_context *pipe,
                        unsigned start_slot, unsigned count,
                        const struct pipe_vertex_buffer *vb)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);
    unsigned i;

    util_set_vertex_buffers_count(nvc0->vtxbuf, &nvc0->num_vtxbufs, vb,
                                  start_slot, count);

    if (!vb) {
       nvc0->vbo_user &= ~(((1ull << count) - 1) << start_slot);
       nvc0->constant_vbos &= ~(((1ull << count) - 1) << start_slot);
       return;
    }

    for (i = 0; i < count; ++i) {
       unsigned dst_index = start_slot + i;

       if (vb[i].user_buffer) {
          nvc0->vbo_user |= 1 << dst_index;
          if (!vb[i].stride)
             nvc0->constant_vbos |= 1 << dst_index;
          else
             nvc0->constant_vbos &= ~(1 << dst_index);
       } else {
          nvc0->vbo_user &= ~(1 << dst_index);
          nvc0->constant_vbos &= ~(1 << dst_index);
       }
    }

    nvc0->dirty |= NVC0_NEW_ARRAYS;
    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_VTX);
}

static void
nvc0_set_index_buffer(struct pipe_context *pipe,
                      const struct pipe_index_buffer *ib)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    if (nvc0->idxbuf.buffer)
       nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_IDX);

    if (ib) {
       pipe_resource_reference(&nvc0->idxbuf.buffer, ib->buffer);
       nvc0->idxbuf.index_size = ib->index_size;
       if (ib->buffer) {
          nvc0->idxbuf.offset = ib->offset;
          nvc0->dirty |= NVC0_NEW_IDXBUF;
       } else {
          nvc0->idxbuf.user_buffer = ib->user_buffer;
          nvc0->dirty &= ~NVC0_NEW_IDXBUF;
       }
    } else {
       nvc0->dirty &= ~NVC0_NEW_IDXBUF;
       pipe_resource_reference(&nvc0->idxbuf.buffer, NULL);
    }
}

static void
nvc0_vertex_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->vertex = hwcso;
    nvc0->dirty |= NVC0_NEW_VERTEX;
}

static struct pipe_stream_output_target *
nvc0_so_target_create(struct pipe_context *pipe,
                      struct pipe_resource *res,
                      unsigned offset, unsigned size)
{
   struct nvc0_so_target *targ = MALLOC_STRUCT(nvc0_so_target);
   if (!targ)
      return NULL;

   targ->pq = pipe->create_query(pipe, NVC0_QUERY_TFB_BUFFER_OFFSET);
   if (!targ->pq) {
      FREE(targ);
      return NULL;
   }
   targ->clean = TRUE;

   targ->pipe.buffer_size = size;
   targ->pipe.buffer_offset = offset;
   targ->pipe.context = pipe;
   targ->pipe.buffer = NULL;
   pipe_resource_reference(&targ->pipe.buffer, res);
   pipe_reference_init(&targ->pipe.reference, 1);

   return &targ->pipe;
}

static void
nvc0_so_target_destroy(struct pipe_context *pipe,
                       struct pipe_stream_output_target *ptarg)
{
   struct nvc0_so_target *targ = nvc0_so_target(ptarg);
   pipe->destroy_query(pipe, targ->pq);
   pipe_resource_reference(&targ->pipe.buffer, NULL);
   FREE(targ);
}

static void
nvc0_set_transform_feedback_targets(struct pipe_context *pipe,
                                    unsigned num_targets,
                                    struct pipe_stream_output_target **targets,
                                    unsigned append_mask)
{
   struct nvc0_context *nvc0 = nvc0_context(pipe);
   unsigned i;
   boolean serialize = TRUE;

   assert(num_targets <= 4);

   for (i = 0; i < num_targets; ++i) {
      if (nvc0->tfbbuf[i] == targets[i] && (append_mask & (1 << i)))
         continue;
      nvc0->tfbbuf_dirty |= 1 << i;

      if (nvc0->tfbbuf[i] && nvc0->tfbbuf[i] != targets[i])
         nvc0_so_target_save_offset(pipe, nvc0->tfbbuf[i], i, &serialize);

      if (targets[i] && !(append_mask & (1 << i)))
         nvc0_so_target(targets[i])->clean = TRUE;

      pipe_so_target_reference(&nvc0->tfbbuf[i], targets[i]);
   }
   for (; i < nvc0->num_tfbbufs; ++i) {
      nvc0->tfbbuf_dirty |= 1 << i;
      nvc0_so_target_save_offset(pipe, nvc0->tfbbuf[i], i, &serialize);
      pipe_so_target_reference(&nvc0->tfbbuf[i], NULL);
   }
   nvc0->num_tfbbufs = num_targets;

   if (nvc0->tfbbuf_dirty)
      nvc0->dirty |= NVC0_NEW_TFB_TARGETS;
}

static void
nvc0_bind_surfaces_range(struct nvc0_context *nvc0, const unsigned t,
                         unsigned start, unsigned nr,
                         struct pipe_surface **psurfaces)
{
   const unsigned end = start + nr;
   const unsigned mask = ((1 << nr) - 1) << start;
   unsigned i;

   if (psurfaces) {
      for (i = start; i < end; ++i) {
         const unsigned p = i - start;
         if (psurfaces[p])
            nvc0->surfaces_valid[t] |= (1 << i);
         else
            nvc0->surfaces_valid[t] &= ~(1 << i);
         pipe_surface_reference(&nvc0->surfaces[t][i], psurfaces[p]);
      }
   } else {
      for (i = start; i < end; ++i)
         pipe_surface_reference(&nvc0->surfaces[t][i], NULL);
      nvc0->surfaces_valid[t] &= ~mask;
   }
   nvc0->surfaces_dirty[t] |= mask;

   if (t == 0)
      nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_SUF);
   else
      nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_SUF);
}

static void
nvc0_set_compute_resources(struct pipe_context *pipe,
                           unsigned start, unsigned nr,
                           struct pipe_surface **resources)
{
   nvc0_bind_surfaces_range(nvc0_context(pipe), 1, start, nr, resources);

   nvc0_context(pipe)->dirty_cp |= NVC0_NEW_CP_SURFACES;
}

static void
nvc0_set_shader_resources(struct pipe_context *pipe,
                          unsigned start, unsigned nr,
                          struct pipe_surface **resources)
{
   nvc0_bind_surfaces_range(nvc0_context(pipe), 0, start, nr, resources);

   nvc0_context(pipe)->dirty |= NVC0_NEW_SURFACES;
}

static INLINE void
nvc0_set_global_handle(uint32_t *phandle, struct pipe_resource *res)
{
   struct nv04_resource *buf = nv04_resource(res);
   if (buf) {
      uint64_t limit = (buf->address + buf->base.width0) - 1;
      if (limit < (1ULL << 32)) {
         *phandle = (uint32_t)buf->address;
      } else {
         NOUVEAU_ERR("Cannot map into TGSI_RESOURCE_GLOBAL: "
                     "resource not contained within 32-bit address space !\n");
         *phandle = 0;
      }
   } else {
      *phandle = 0;
   }
}

static void
nvc0_set_global_bindings(struct pipe_context *pipe,
                         unsigned start, unsigned nr,
                         struct pipe_resource **resources,
                         uint32_t **handles)
{
   struct nvc0_context *nvc0 = nvc0_context(pipe);
   struct pipe_resource **ptr;
   unsigned i;
   const unsigned end = start + nr;

   if (nvc0->global_residents.size <= (end * sizeof(struct pipe_resource *))) {
      const unsigned old_size = nvc0->global_residents.size;
      const unsigned req_size = end * sizeof(struct pipe_resource *);
      util_dynarray_resize(&nvc0->global_residents, req_size);
      memset((uint8_t *)nvc0->global_residents.data + old_size, 0,
             req_size - old_size);
   }

   if (resources) {
      ptr = util_dynarray_element(
         &nvc0->global_residents, struct pipe_resource *, start);
      for (i = 0; i < nr; ++i) {
         pipe_resource_reference(&ptr[i], resources[i]);
         nvc0_set_global_handle(handles[i], resources[i]);
      }
   } else {
      ptr = util_dynarray_element(
         &nvc0->global_residents, struct pipe_resource *, start);
      for (i = 0; i < nr; ++i)
         pipe_resource_reference(&ptr[i], NULL);
   }

   nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_GLOBAL);

   nvc0->dirty_cp = NVC0_NEW_CP_GLOBALS;
}

void
nvc0_init_state_functions(struct nvc0_context *nvc0)
{
   struct pipe_context *pipe = &nvc0->base.pipe;

   pipe->create_blend_state = nvc0_blend_state_create;
   pipe->bind_blend_state = nvc0_blend_state_bind;
   pipe->delete_blend_state = nvc0_blend_state_delete;

   pipe->create_rasterizer_state = nvc0_rasterizer_state_create;
   pipe->bind_rasterizer_state = nvc0_rasterizer_state_bind;
   pipe->delete_rasterizer_state = nvc0_rasterizer_state_delete;

   pipe->create_depth_stencil_alpha_state = nvc0_zsa_state_create;
   pipe->bind_depth_stencil_alpha_state = nvc0_zsa_state_bind;
   pipe->delete_depth_stencil_alpha_state = nvc0_zsa_state_delete;

   pipe->create_sampler_state = nv50_sampler_state_create;
   pipe->delete_sampler_state = nvc0_sampler_state_delete;
   pipe->bind_vertex_sampler_states   = nvc0_vp_sampler_states_bind;
   pipe->bind_fragment_sampler_states = nvc0_fp_sampler_states_bind;
   pipe->bind_geometry_sampler_states = nvc0_gp_sampler_states_bind;
   pipe->bind_compute_sampler_states = nvc0_cp_sampler_states_bind;

   pipe->create_sampler_view = nvc0_create_sampler_view;
   pipe->sampler_view_destroy = nvc0_sampler_view_destroy;
   pipe->set_vertex_sampler_views   = nvc0_vp_set_sampler_views;
   pipe->set_fragment_sampler_views = nvc0_fp_set_sampler_views;
   pipe->set_geometry_sampler_views = nvc0_gp_set_sampler_views;
   pipe->set_compute_sampler_views = nvc0_cp_set_sampler_views;

   pipe->create_vs_state = nvc0_vp_state_create;
   pipe->create_fs_state = nvc0_fp_state_create;
   pipe->create_gs_state = nvc0_gp_state_create;
   pipe->bind_vs_state = nvc0_vp_state_bind;
   pipe->bind_fs_state = nvc0_fp_state_bind;
   pipe->bind_gs_state = nvc0_gp_state_bind;
   pipe->delete_vs_state = nvc0_sp_state_delete;
   pipe->delete_fs_state = nvc0_sp_state_delete;
   pipe->delete_gs_state = nvc0_sp_state_delete;

   pipe->create_compute_state = nvc0_cp_state_create;
   pipe->bind_compute_state = nvc0_cp_state_bind;
   pipe->delete_compute_state = nvc0_sp_state_delete;

   pipe->set_blend_color = nvc0_set_blend_color;
   pipe->set_stencil_ref = nvc0_set_stencil_ref;
   pipe->set_clip_state = nvc0_set_clip_state;
   pipe->set_sample_mask = nvc0_set_sample_mask;
   pipe->set_constant_buffer = nvc0_set_constant_buffer;
   pipe->set_framebuffer_state = nvc0_set_framebuffer_state;
   pipe->set_polygon_stipple = nvc0_set_polygon_stipple;
   pipe->set_scissor_states = nvc0_set_scissor_states;
   pipe->set_viewport_states = nvc0_set_viewport_states;

   pipe->create_vertex_elements_state = nvc0_vertex_state_create;
   pipe->delete_vertex_elements_state = nvc0_vertex_state_delete;
   pipe->bind_vertex_elements_state = nvc0_vertex_state_bind;

   pipe->set_vertex_buffers = nvc0_set_vertex_buffers;
   pipe->set_index_buffer = nvc0_set_index_buffer;

   pipe->create_stream_output_target = nvc0_so_target_create;
   pipe->stream_output_target_destroy = nvc0_so_target_destroy;
   pipe->set_stream_output_targets = nvc0_set_transform_feedback_targets;

   pipe->set_global_binding = nvc0_set_global_bindings;
   pipe->set_compute_resources = nvc0_set_compute_resources;
   pipe->set_shader_resources = nvc0_set_shader_resources;
}

@


1.2
log
@Merge Mesa 9.2.0
@
text
@@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d17 4
a20 4
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
d24 1
d90 9
a98 2
    struct nvc0_blend_stateobj *so = CALLOC_STRUCT(nvc0_blend_stateobj);
    int i;
d100 20
a119 1
    so->pipe = *cso;
d121 11
a131 1
    SB_IMMED_3D(so, BLEND_INDEPENDENT, cso->independent_blend_enable);
d133 4
a136 2
    if (!cso->logicop_enable)
       SB_IMMED_3D(so, LOGIC_OP_ENABLE, 0);
d138 29
a166 26
    if (cso->logicop_enable) {
       SB_BEGIN_3D(so, LOGIC_OP_ENABLE, 2);
       SB_DATA    (so, 1);
       SB_DATA    (so, nvgl_logicop_func(cso->logicop_func));

       SB_IMMED_3D(so, BLEND_ENABLES, 0);
    } else
    if (!cso->independent_blend_enable) {
        SB_IMMED_3D(so, BLEND_ENABLES, cso->rt[0].blend_enable ? 0xff : 0);

        if (cso->rt[0].blend_enable) {
            SB_BEGIN_3D(so, BLEND_EQUATION_RGB, 5);
            SB_DATA    (so, nvgl_blend_eqn(cso->rt[0].rgb_func));
            SB_DATA    (so, nvc0_blend_fac(cso->rt[0].rgb_src_factor));
            SB_DATA    (so, nvc0_blend_fac(cso->rt[0].rgb_dst_factor));
            SB_DATA    (so, nvgl_blend_eqn(cso->rt[0].alpha_func));
            SB_DATA    (so, nvc0_blend_fac(cso->rt[0].alpha_src_factor));
            SB_BEGIN_3D(so, BLEND_FUNC_DST_ALPHA, 1);
            SB_DATA    (so, nvc0_blend_fac(cso->rt[0].alpha_dst_factor));
        }

        SB_IMMED_3D(so, COLOR_MASK_COMMON, 1);
        SB_BEGIN_3D(so, COLOR_MASK(0), 1);
        SB_DATA    (so, nvc0_colormask(cso->rt[0].colormask));
    } else {
        uint8_t en = 0;
d168 4
a171 18
        for (i = 0; i < 8; ++i) {
            if (!cso->rt[i].blend_enable)
                continue;
            en |= 1 << i;

            SB_BEGIN_3D(so, IBLEND_EQUATION_RGB(i), 6);
            SB_DATA    (so, nvgl_blend_eqn(cso->rt[i].rgb_func));
            SB_DATA    (so, nvc0_blend_fac(cso->rt[i].rgb_src_factor));
            SB_DATA    (so, nvc0_blend_fac(cso->rt[i].rgb_dst_factor));
            SB_DATA    (so, nvgl_blend_eqn(cso->rt[i].alpha_func));
            SB_DATA    (so, nvc0_blend_fac(cso->rt[i].alpha_src_factor));
            SB_DATA    (so, nvc0_blend_fac(cso->rt[i].alpha_dst_factor));
        }
        SB_IMMED_3D(so, BLEND_ENABLES, en);

        SB_IMMED_3D(so, COLOR_MASK_COMMON, 0);
        SB_BEGIN_3D(so, COLOR_MASK(0), 8);
        for (i = 0; i < 8; ++i)
d173 14
a186 1
    }
d188 2
a189 2
    assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
    return so;
d234 2
d266 1
a266 1
    SB_BEGIN_3D(so, POLYGON_MODE_FRONT, 1);
d268 1
a268 1
    SB_BEGIN_3D(so, POLYGON_MODE_BACK, 1);
d300 2
d304 12
d454 4
d462 2
a463 2
   for (; i < nvc0->num_samplers[s]; ++i)
      if (nvc0->samplers[s][i])
d465 3
d492 51
d564 7
a570 1
      if (old)
d572 1
d579 5
a583 5
      if (!old)
         continue;
      nvc0_screen_tic_unlock(nvc0->screen, old);

      pipe_sampler_view_reference(&nvc0->textures[s][i], NULL);
a587 2
   nvc0_bufctx_reset(nvc0, NVC0_BUFCTX_TEXTURES);

d615 61
d690 6
a695 1
   prog->pipe.tokens = tgsi_dup_tokens(cso->tokens);
d759 29
d790 1
a790 1
                         struct pipe_resource *res)
d793 8
d802 9
a810 11
   switch (shader) {
   case PIPE_SHADER_VERTEX: shader = 0; break;
      /*
   case PIPE_SHADER_TESSELLATION_CONTROL: shader = 1; break;
   case PIPE_SHADER_TESSELLATION_EVALUATION: shader = 2; break;
      */
   case PIPE_SHADER_GEOMETRY: shader = 3; break;
   case PIPE_SHADER_FRAGMENT: shader = 4; break;
   default:
      assert(0);
      break;
d812 1
d814 1
a814 3
   if (nvc0->constbuf[shader][index])
      nvc0_bufctx_del_resident(nvc0, NVC0_BUFCTX_CONSTANT,
			       nv04_resource(nvc0->constbuf[shader][index]));
d816 9
a824 5
   pipe_resource_reference(&nvc0->constbuf[shader][index], res);

   nvc0->constbuf_dirty[shader] |= 1 << index;

   nvc0->dirty |= NVC0_NEW_CONSTBUF;
a854 4
    const unsigned size = clip->nr * sizeof(clip->ucp[0]);

    memcpy(&nvc0->clip.ucp[0][0], &clip->ucp[0][0], size);
    nvc0->clip.nr = clip->nr;
d856 1
a856 1
    nvc0->clip.depth_clamp = clip->depth_clamp;
d876 15
a891 1
    nvc0->framebuffer = *fb;
d906 4
a909 2
nvc0_set_scissor_state(struct pipe_context *pipe,
                       const struct pipe_scissor_state *scissor)
d918 4
a921 2
nvc0_set_viewport_state(struct pipe_context *pipe,
                        const struct pipe_viewport_state *vpt)
d931 1
a931 1
                        unsigned count,
d937 2
a938 4
    for (i = 0; i < count; ++i)
       pipe_resource_reference(&nvc0->vtxbuf[i].buffer, vb[i].buffer);
    for (; i < nvc0->num_vtxbufs; ++i)
       pipe_resource_reference(&nvc0->vtxbuf[i].buffer, NULL);
d940 8
a947 2
    memcpy(nvc0->vtxbuf, vb, sizeof(*vb) * count);
    nvc0->num_vtxbufs = count;
d949 11
a959 1
    nvc0_bufctx_reset(nvc0, NVC0_BUFCTX_VERTEX);
d962 1
d971 3
d976 8
a983 2

       memcpy(&nvc0->idxbuf, ib, sizeof(nvc0->idxbuf));
d985 1
d999 4
a1002 3
static void *
nvc0_tfb_state_create(struct pipe_context *pipe,
                      const struct pipe_stream_output_state *pso)
d1004 3
a1006 3
   struct nvc0_transform_feedback_state *so;
   int n = 0;
   int i, c, b;
d1008 3
a1010 2
   so = MALLOC(sizeof(*so) + pso->num_outputs * 4 * sizeof(uint8_t));
   if (!so)
d1012 12
d1025 63
a1087 10
   for (b = 0; b < 4; ++b) {
      for (i = 0; i < pso->num_outputs; ++i) {
         if (pso->output_buffer[i] != b)
            continue;
         for (c = 0; c < 4; ++c) {
            if (!(pso->register_mask[i] & (1 << c)))
               continue;
            so->varying_count[b]++;
            so->varying_index[n++] = (pso->register_index[i] << 2) | c;
         }
d1089 4
a1092 1
      so->stride[b] = so->varying_count[b] * 4;
d1094 1
a1094 2
   if (pso->stride)
      so->stride[0] = pso->stride;
d1096 4
a1099 1
   return so;
d1103 3
a1105 1
nvc0_tfb_state_delete(struct pipe_context *pipe, void *hwcso)
d1107 3
a1109 1
   FREE(hwcso);
d1113 11
a1123 1
nvc0_tfb_state_bind(struct pipe_context *pipe, void *hwcso)
d1125 13
a1137 2
   nvc0_context(pipe)->tfb = hwcso;
   nvc0_context(pipe)->dirty |= NVC0_NEW_TFB;
d1141 4
a1144 4
nvc0_set_transform_feedback_buffers(struct pipe_context *pipe,
                                    struct pipe_resource **buffers,
                                    int *offsets,
                                    int num_buffers)
d1147 3
a1149 1
   int i;
d1151 7
a1157 1
   assert(num_buffers >= 0 && num_buffers <= 4); /* why signed ? */
d1159 12
a1170 4
   for (i = 0; i < num_buffers; ++i) {
       assert(offsets[i] >= 0);
       nvc0->tfb_offset[i] = offsets[i];
       pipe_resource_reference(&nvc0->tfbbuf[i], buffers[i]);
a1171 2
   for (; i < nvc0->num_tfbbufs; ++i)
      pipe_resource_reference(&nvc0->tfbbuf[i], NULL);
d1173 1
a1173 1
   nvc0->num_tfbbufs = num_buffers;
d1175 1
a1175 1
   nvc0->dirty |= NVC0_NEW_TFB_BUFFERS;
d1200 1
d1207 1
d1219 4
d1230 2
a1231 2
   pipe->set_scissor_state = nvc0_set_scissor_state;
   pipe->set_viewport_state = nvc0_set_viewport_state;
d1240 7
a1246 6
   pipe->create_stream_output_state = nvc0_tfb_state_create;
   pipe->delete_stream_output_state = nvc0_tfb_state_delete;
   pipe->bind_stream_output_state = nvc0_tfb_state_bind;
   pipe->set_stream_output_buffers = nvc0_set_transform_feedback_buffers;

   pipe->redefine_user_buffer = u_default_redefine_user_buffer;
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d17 4
a20 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a23 1
#include "util/u_helpers.h"
d89 2
a90 7
   struct nvc0_blend_stateobj *so = CALLOC_STRUCT(nvc0_blend_stateobj);
   int i;
   int r; /* reference */
   uint32_t ms;
   uint8_t blend_en = 0;
   boolean indep_masks = FALSE;
   boolean indep_funcs = FALSE;
d92 1
a92 1
   so->pipe = *cso;
d94 1
a94 20
   /* check which states actually have differing values */
   if (cso->independent_blend_enable) {
      for (r = 0; r < 8 && !cso->rt[r].blend_enable; ++r);
      blend_en |= 1 << r;
      for (i = r + 1; i < 8; ++i) {
         if (!cso->rt[i].blend_enable)
            continue;
         blend_en |= 1 << i;
         if (cso->rt[i].rgb_func != cso->rt[r].rgb_func ||
             cso->rt[i].rgb_src_factor != cso->rt[r].rgb_src_factor ||
             cso->rt[i].rgb_dst_factor != cso->rt[r].rgb_dst_factor ||
             cso->rt[i].alpha_func != cso->rt[r].alpha_func ||
             cso->rt[i].alpha_src_factor != cso->rt[r].alpha_src_factor ||
             cso->rt[i].alpha_dst_factor != cso->rt[r].alpha_dst_factor) {
            indep_funcs = TRUE;
            break;
         }
      }
      for (; i < 8; ++i)
         blend_en |= (cso->rt[i].blend_enable ? 1 : 0) << i;
d96 2
a97 11
      for (i = 1; i < 8; ++i) {
         if (cso->rt[i].colormask != cso->rt[0].colormask) {
            indep_masks = TRUE;
            break;
         }
      }
   } else {
      r = 0;
      if (cso->rt[0].blend_enable)
         blend_en = 0xff;
   }
d99 26
a124 4
   if (cso->logicop_enable) {
      SB_BEGIN_3D(so, LOGIC_OP_ENABLE, 2);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_logicop_func(cso->logicop_func));
d126 18
a143 34
      SB_IMMED_3D(so, MACRO_BLEND_ENABLES, 0);
   } else {
      SB_IMMED_3D(so, LOGIC_OP_ENABLE, 0);

      SB_IMMED_3D(so, BLEND_INDEPENDENT, indep_funcs);
      SB_IMMED_3D(so, MACRO_BLEND_ENABLES, blend_en);
      if (indep_funcs) {
         for (i = 0; i < 8; ++i) {
            if (cso->rt[i].blend_enable) {
               SB_BEGIN_3D(so, IBLEND_EQUATION_RGB(i), 6);
               SB_DATA    (so, nvgl_blend_eqn(cso->rt[i].rgb_func));
               SB_DATA    (so, nvc0_blend_fac(cso->rt[i].rgb_src_factor));
               SB_DATA    (so, nvc0_blend_fac(cso->rt[i].rgb_dst_factor));
               SB_DATA    (so, nvgl_blend_eqn(cso->rt[i].alpha_func));
               SB_DATA    (so, nvc0_blend_fac(cso->rt[i].alpha_src_factor));
               SB_DATA    (so, nvc0_blend_fac(cso->rt[i].alpha_dst_factor));
            }
         }
      } else
      if (blend_en) {
         SB_BEGIN_3D(so, BLEND_EQUATION_RGB, 5);
         SB_DATA    (so, nvgl_blend_eqn(cso->rt[r].rgb_func));
         SB_DATA    (so, nvc0_blend_fac(cso->rt[r].rgb_src_factor));
         SB_DATA    (so, nvc0_blend_fac(cso->rt[r].rgb_dst_factor));
         SB_DATA    (so, nvgl_blend_eqn(cso->rt[r].alpha_func));
         SB_DATA    (so, nvc0_blend_fac(cso->rt[r].alpha_src_factor));
         SB_BEGIN_3D(so, BLEND_FUNC_DST_ALPHA, 1);
         SB_DATA    (so, nvc0_blend_fac(cso->rt[r].alpha_dst_factor));
      }

      SB_IMMED_3D(so, COLOR_MASK_COMMON, !indep_masks);
      if (indep_masks) {
         SB_BEGIN_3D(so, COLOR_MASK(0), 8);
         for (i = 0; i < 8; ++i)
d145 1
a145 5
      } else {
         SB_BEGIN_3D(so, COLOR_MASK(0), 1);
         SB_DATA    (so, nvc0_colormask(cso->rt[0].colormask));
      }
   }
d147 2
a148 11
   ms = 0;
   if (cso->alpha_to_coverage)
      ms |= NVC0_3D_MULTISAMPLE_CTRL_ALPHA_TO_COVERAGE;
   if (cso->alpha_to_one)
      ms |= NVC0_3D_MULTISAMPLE_CTRL_ALPHA_TO_ONE;

   SB_BEGIN_3D(so, MULTISAMPLE_CTRL, 1);
   SB_DATA    (so, ms);

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return so;
a192 2
    SB_IMMED_3D(so, MULTISAMPLE_ENABLE, cso->multisample);

d223 1
a223 1
    SB_BEGIN_3D(so, MACRO_POLYGON_MODE_FRONT, 1);
d225 1
a225 1
    SB_BEGIN_3D(so, MACRO_POLYGON_MODE_BACK, 1);
a256 2
        SB_BEGIN_3D(so, POLYGON_OFFSET_CLAMP, 1);
        SB_DATA    (so, fui(cso->offset_clamp));
a258 12
    if (cso->depth_clip)
       reg = NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK1_UNK1;
    else
       reg =
          NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK1_UNK1 |
          NVC0_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_NEAR |
          NVC0_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_FAR |
          NVC0_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK2;

    SB_BEGIN_3D(so, VIEW_VOLUME_CLIP_CTRL, 1);
    SB_DATA    (so, reg);

a396 4
      if (hwcso[i] == old)
         continue;
      nvc0->samplers_dirty[s] |= 1 << i;

d401 2
a402 2
   for (; i < nvc0->num_samplers[s]; ++i) {
      if (nvc0->samplers[s][i]) {
a403 3
         nvc0->samplers[s][i] = NULL;
      }
   }
a427 51
static void
nvc0_stage_sampler_states_bind_range(struct nvc0_context *nvc0,
                                     const unsigned s,
                                     unsigned start, unsigned nr, void **cso)
{
   const unsigned end = start + nr;
   int last_valid = -1;
   unsigned i;

   if (cso) {
      for (i = start; i < end; ++i) {
         const unsigned p = i - start;
         if (cso[p])
            last_valid = i;
         if (cso[p] == nvc0->samplers[s][i])
            continue;
         nvc0->samplers_dirty[s] |= 1 << i;

         if (nvc0->samplers[s][i])
            nvc0_screen_tsc_unlock(nvc0->screen, nvc0->samplers[s][i]);
         nvc0->samplers[s][i] = cso[p];
      }
   } else {
      for (i = start; i < end; ++i) {
         if (nvc0->samplers[s][i]) {
            nvc0_screen_tsc_unlock(nvc0->screen, nvc0->samplers[s][i]);
            nvc0->samplers[s][i] = NULL;
            nvc0->samplers_dirty[s] |= 1 << i;
         }
      }
   }

   if (nvc0->num_samplers[s] <= end) {
      if (last_valid < 0) {
         for (i = start; i && !nvc0->samplers[s][i - 1]; --i);
         nvc0->num_samplers[s] = i;
      } else {
         nvc0->num_samplers[s] = last_valid + 1;
      }
   }
}

static void
nvc0_cp_sampler_states_bind(struct pipe_context *pipe,
                            unsigned start, unsigned nr, void **cso)
{
   nvc0_stage_sampler_states_bind_range(nvc0_context(pipe), 5, start, nr, cso);

   nvc0_context(pipe)->dirty_cp |= NVC0_NEW_CP_SAMPLERS;
}

d449 1
a449 7

      if (views[i] == nvc0->textures[s][i])
         continue;
      nvc0->textures_dirty[s] |= 1 << i;

      if (old) {
         nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_TEX(s, i));
a450 1
      }
d457 5
a461 5
      if (old) {
         nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_TEX(s, i));
         nvc0_screen_tic_unlock(nvc0->screen, old);
         pipe_sampler_view_reference(&nvc0->textures[s][i], NULL);
      }
d466 2
a494 61
static void
nvc0_stage_set_sampler_views_range(struct nvc0_context *nvc0, const unsigned s,
                                   unsigned start, unsigned nr,
                                   struct pipe_sampler_view **views)
{
   struct nouveau_bufctx *bctx = (s == 5) ? nvc0->bufctx_cp : nvc0->bufctx_3d;
   const unsigned end = start + nr;
   const unsigned bin = (s == 5) ? NVC0_BIND_CP_TEX(0) : NVC0_BIND_TEX(s, 0);
   int last_valid = -1;
   unsigned i;

   if (views) {
      for (i = start; i < end; ++i) {
         const unsigned p = i - start;
         if (views[p])
            last_valid = i;
         if (views[p] == nvc0->textures[s][i])
            continue;
         nvc0->textures_dirty[s] |= 1 << i;

         if (nvc0->textures[s][i]) {
            struct nv50_tic_entry *old = nv50_tic_entry(nvc0->textures[s][i]);
            nouveau_bufctx_reset(bctx, bin + i);
            nvc0_screen_tic_unlock(nvc0->screen, old);
         }
         pipe_sampler_view_reference(&nvc0->textures[s][i], views[p]);
      }
   } else {
      for (i = start; i < end; ++i) {
         struct nv50_tic_entry *old = nv50_tic_entry(nvc0->textures[s][i]);
         if (!old)
            continue;
         nvc0->textures_dirty[s] |= 1 << i;

         nvc0_screen_tic_unlock(nvc0->screen, old);
         pipe_sampler_view_reference(&nvc0->textures[s][i], NULL);
         nouveau_bufctx_reset(bctx, bin + i);
      }
   }

   if (nvc0->num_textures[s] <= end) {
      if (last_valid < 0) {
         for (i = start; i && !nvc0->textures[s][i - 1]; --i);
         nvc0->num_textures[s] = i;
      } else {
         nvc0->num_textures[s] = last_valid + 1;
      }
   }
}

static void
nvc0_cp_set_sampler_views(struct pipe_context *pipe,
                          unsigned start, unsigned nr,
                          struct pipe_sampler_view **views)
{
   nvc0_stage_set_sampler_views_range(nvc0_context(pipe), 5, start, nr, views);

   nvc0_context(pipe)->dirty_cp |= NVC0_NEW_CP_TEXTURES;
}


d509 1
a509 6

   if (cso->tokens)
      prog->pipe.tokens = tgsi_dup_tokens(cso->tokens);

   if (cso->stream_output.num_outputs)
      prog->pipe.stream_output = cso->stream_output;
a572 29
static void *
nvc0_cp_state_create(struct pipe_context *pipe,
                     const struct pipe_compute_state *cso)
{
   struct nvc0_program *prog;

   prog = CALLOC_STRUCT(nvc0_program);
   if (!prog)
      return NULL;
   prog->type = PIPE_SHADER_COMPUTE;

   prog->cp.smem_size = cso->req_local_mem;
   prog->cp.lmem_size = cso->req_private_mem;
   prog->parm_size = cso->req_input_mem;

   prog->pipe.tokens = tgsi_dup_tokens((const struct tgsi_token *)cso->prog);

   return (void *)prog;
}

static void
nvc0_cp_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nvc0_context *nvc0 = nvc0_context(pipe);

    nvc0->compprog = hwcso;
    nvc0->dirty_cp |= NVC0_NEW_CP_PROGRAM;
}

d575 1
a575 1
                         struct pipe_constant_buffer *cb)
a577 8
   struct pipe_resource *res = cb ? cb->buffer : NULL;
   const unsigned s = nvc0_shader_stage(shader);
   const unsigned i = index;

   if (unlikely(shader == PIPE_SHADER_COMPUTE)) {
      assert(!cb || !cb->user_buffer);
      if (nvc0->constbuf[s][i].u.buf)
         nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_CB(i));
d579 16
a594 7
      nvc0->dirty_cp |= NVC0_NEW_CP_CONSTBUF;
   } else {
      if (nvc0->constbuf[s][i].user)
         nvc0->constbuf[s][i].u.buf = NULL;
      else
      if (nvc0->constbuf[s][i].u.buf)
         nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_CB(s, i));
d596 1
a596 3
      nvc0->dirty |= NVC0_NEW_CONSTBUF;
   }
   nvc0->constbuf_dirty[s] |= 1 << i;
d598 1
a598 1
   pipe_resource_reference(&nvc0->constbuf[s][i].u.buf, res);
d600 1
a600 9
   nvc0->constbuf[s][i].user = (cb && cb->user_buffer) ? TRUE : FALSE;
   if (nvc0->constbuf[s][i].user) {
      nvc0->constbuf[s][i].u.data = cb->user_buffer;
      nvc0->constbuf[s][i].size = cb->buffer_size;
   } else
   if (cb) {
      nvc0->constbuf[s][i].offset = cb->buffer_offset;
      nvc0->constbuf[s][i].size = align(cb->buffer_size, 0x100);
   }
d631 4
d636 1
a636 1
    memcpy(nvc0->clip.ucp, clip->ucp, sizeof(clip->ucp));
a655 15
    unsigned i;

    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_FB);

    for (i = 0; i < fb->nr_cbufs; ++i)
       pipe_surface_reference(&nvc0->framebuffer.cbufs[i], fb->cbufs[i]);
    for (; i < nvc0->framebuffer.nr_cbufs; ++i)
       pipe_surface_reference(&nvc0->framebuffer.cbufs[i], NULL);

    nvc0->framebuffer.nr_cbufs = fb->nr_cbufs;

    nvc0->framebuffer.width = fb->width;
    nvc0->framebuffer.height = fb->height;

    pipe_surface_reference(&nvc0->framebuffer.zsbuf, fb->zsbuf);
d657 1
d672 2
a673 4
nvc0_set_scissor_states(struct pipe_context *pipe,
                        unsigned start_slot,
                        unsigned num_scissors,
                        const struct pipe_scissor_state *scissor)
d682 2
a683 4
nvc0_set_viewport_states(struct pipe_context *pipe,
                         unsigned start_slot,
                         unsigned num_viewports,
                         const struct pipe_viewport_state *vpt)
d693 1
a693 1
                        unsigned start_slot, unsigned count,
d699 4
a702 2
    util_set_vertex_buffers_count(nvc0->vtxbuf, &nvc0->num_vtxbufs, vb,
                                  start_slot, count);
d704 2
a705 8
    if (!vb) {
       nvc0->vbo_user &= ~(((1ull << count) - 1) << start_slot);
       nvc0->constant_vbos &= ~(((1ull << count) - 1) << start_slot);
       return;
    }

    for (i = 0; i < count; ++i) {
       unsigned dst_index = start_slot + i;
d707 1
a707 11
       if (vb[i].user_buffer) {
          nvc0->vbo_user |= 1 << dst_index;
          if (!vb[i].stride)
             nvc0->constant_vbos |= 1 << dst_index;
          else
             nvc0->constant_vbos &= ~(1 << dst_index);
       } else {
          nvc0->vbo_user &= ~(1 << dst_index);
          nvc0->constant_vbos &= ~(1 << dst_index);
       }
    }
a709 1
    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_VTX);
a717 3
    if (nvc0->idxbuf.buffer)
       nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_IDX);

d720 2
a721 8
       nvc0->idxbuf.index_size = ib->index_size;
       if (ib->buffer) {
          nvc0->idxbuf.offset = ib->offset;
          nvc0->dirty |= NVC0_NEW_IDXBUF;
       } else {
          nvc0->idxbuf.user_buffer = ib->user_buffer;
          nvc0->dirty &= ~NVC0_NEW_IDXBUF;
       }
a722 1
       nvc0->dirty &= ~NVC0_NEW_IDXBUF;
d736 3
a738 4
static struct pipe_stream_output_target *
nvc0_so_target_create(struct pipe_context *pipe,
                      struct pipe_resource *res,
                      unsigned offset, unsigned size)
d740 3
a742 3
   struct nvc0_so_target *targ = MALLOC_STRUCT(nvc0_so_target);
   if (!targ)
      return NULL;
d744 2
a745 3
   targ->pq = pipe->create_query(pipe, NVC0_QUERY_TFB_BUFFER_OFFSET);
   if (!targ->pq) {
      FREE(targ);
a746 2
   }
   targ->clean = TRUE;
d748 10
a757 73
   targ->pipe.buffer_size = size;
   targ->pipe.buffer_offset = offset;
   targ->pipe.context = pipe;
   targ->pipe.buffer = NULL;
   pipe_resource_reference(&targ->pipe.buffer, res);
   pipe_reference_init(&targ->pipe.reference, 1);

   return &targ->pipe;
}

static void
nvc0_so_target_destroy(struct pipe_context *pipe,
                       struct pipe_stream_output_target *ptarg)
{
   struct nvc0_so_target *targ = nvc0_so_target(ptarg);
   pipe->destroy_query(pipe, targ->pq);
   pipe_resource_reference(&targ->pipe.buffer, NULL);
   FREE(targ);
}

static void
nvc0_set_transform_feedback_targets(struct pipe_context *pipe,
                                    unsigned num_targets,
                                    struct pipe_stream_output_target **targets,
                                    unsigned append_mask)
{
   struct nvc0_context *nvc0 = nvc0_context(pipe);
   unsigned i;
   boolean serialize = TRUE;

   assert(num_targets <= 4);

   for (i = 0; i < num_targets; ++i) {
      if (nvc0->tfbbuf[i] == targets[i] && (append_mask & (1 << i)))
         continue;
      nvc0->tfbbuf_dirty |= 1 << i;

      if (nvc0->tfbbuf[i] && nvc0->tfbbuf[i] != targets[i])
         nvc0_so_target_save_offset(pipe, nvc0->tfbbuf[i], i, &serialize);

      if (targets[i] && !(append_mask & (1 << i)))
         nvc0_so_target(targets[i])->clean = TRUE;

      pipe_so_target_reference(&nvc0->tfbbuf[i], targets[i]);
   }
   for (; i < nvc0->num_tfbbufs; ++i) {
      nvc0->tfbbuf_dirty |= 1 << i;
      nvc0_so_target_save_offset(pipe, nvc0->tfbbuf[i], i, &serialize);
      pipe_so_target_reference(&nvc0->tfbbuf[i], NULL);
   }
   nvc0->num_tfbbufs = num_targets;

   if (nvc0->tfbbuf_dirty)
      nvc0->dirty |= NVC0_NEW_TFB_TARGETS;
}

static void
nvc0_bind_surfaces_range(struct nvc0_context *nvc0, const unsigned t,
                         unsigned start, unsigned nr,
                         struct pipe_surface **psurfaces)
{
   const unsigned end = start + nr;
   const unsigned mask = ((1 << nr) - 1) << start;
   unsigned i;

   if (psurfaces) {
      for (i = start; i < end; ++i) {
         const unsigned p = i - start;
         if (psurfaces[p])
            nvc0->surfaces_valid[t] |= (1 << i);
         else
            nvc0->surfaces_valid[t] &= ~(1 << i);
         pipe_surface_reference(&nvc0->surfaces[t][i], psurfaces[p]);
d759 1
a759 4
   } else {
      for (i = start; i < end; ++i)
         pipe_surface_reference(&nvc0->surfaces[t][i], NULL);
      nvc0->surfaces_valid[t] &= ~mask;
d761 2
a762 1
   nvc0->surfaces_dirty[t] |= mask;
d764 1
a764 4
   if (t == 0)
      nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_SUF);
   else
      nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_SUF);
d768 1
a768 3
nvc0_set_compute_resources(struct pipe_context *pipe,
                           unsigned start, unsigned nr,
                           struct pipe_surface **resources)
d770 1
a770 3
   nvc0_bind_surfaces_range(nvc0_context(pipe), 1, start, nr, resources);

   nvc0_context(pipe)->dirty_cp |= NVC0_NEW_CP_SURFACES;
d774 1
a774 11
nvc0_set_shader_resources(struct pipe_context *pipe,
                          unsigned start, unsigned nr,
                          struct pipe_surface **resources)
{
   nvc0_bind_surfaces_range(nvc0_context(pipe), 0, start, nr, resources);

   nvc0_context(pipe)->dirty |= NVC0_NEW_SURFACES;
}

static INLINE void
nvc0_set_global_handle(uint32_t *phandle, struct pipe_resource *res)
d776 2
a777 13
   struct nv04_resource *buf = nv04_resource(res);
   if (buf) {
      uint64_t limit = (buf->address + buf->base.width0) - 1;
      if (limit < (1ULL << 32)) {
         *phandle = (uint32_t)buf->address;
      } else {
         NOUVEAU_ERR("Cannot map into TGSI_RESOURCE_GLOBAL: "
                     "resource not contained within 32-bit address space !\n");
         *phandle = 0;
      }
   } else {
      *phandle = 0;
   }
d781 4
a784 4
nvc0_set_global_bindings(struct pipe_context *pipe,
                         unsigned start, unsigned nr,
                         struct pipe_resource **resources,
                         uint32_t **handles)
d787 1
a787 3
   struct pipe_resource **ptr;
   unsigned i;
   const unsigned end = start + nr;
d789 1
a789 7
   if (nvc0->global_residents.size <= (end * sizeof(struct pipe_resource *))) {
      const unsigned old_size = nvc0->global_residents.size;
      const unsigned req_size = end * sizeof(struct pipe_resource *);
      util_dynarray_resize(&nvc0->global_residents, req_size);
      memset((uint8_t *)nvc0->global_residents.data + old_size, 0,
             req_size - old_size);
   }
d791 4
a794 12
   if (resources) {
      ptr = util_dynarray_element(
         &nvc0->global_residents, struct pipe_resource *, start);
      for (i = 0; i < nr; ++i) {
         pipe_resource_reference(&ptr[i], resources[i]);
         nvc0_set_global_handle(handles[i], resources[i]);
      }
   } else {
      ptr = util_dynarray_element(
         &nvc0->global_residents, struct pipe_resource *, start);
      for (i = 0; i < nr; ++i)
         pipe_resource_reference(&ptr[i], NULL);
d796 2
d799 1
a799 1
   nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_GLOBAL);
d801 1
a801 1
   nvc0->dirty_cp = NVC0_NEW_CP_GLOBALS;
a825 1
   pipe->bind_compute_sampler_states = nvc0_cp_sampler_states_bind;
a831 1
   pipe->set_compute_sampler_views = nvc0_cp_set_sampler_views;
a842 4
   pipe->create_compute_state = nvc0_cp_state_create;
   pipe->bind_compute_state = nvc0_cp_state_bind;
   pipe->delete_compute_state = nvc0_sp_state_delete;

d850 2
a851 2
   pipe->set_scissor_states = nvc0_set_scissor_states;
   pipe->set_viewport_states = nvc0_set_viewport_states;
d860 6
a865 7
   pipe->create_stream_output_target = nvc0_so_target_create;
   pipe->stream_output_target_destroy = nvc0_so_target_destroy;
   pipe->set_stream_output_targets = nvc0_set_transform_feedback_targets;

   pipe->set_global_binding = nvc0_set_global_bindings;
   pipe->set_compute_resources = nvc0_set_compute_resources;
   pipe->set_shader_resources = nvc0_set_shader_resources;
@

