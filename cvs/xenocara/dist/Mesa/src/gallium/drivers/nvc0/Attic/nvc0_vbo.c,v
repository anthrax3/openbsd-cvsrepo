head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.00.49;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.53;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2010 Christoph Bumiller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#define NVC0_PUSH_EXPLICIT_SPACE_CHECKING

#include "pipe/p_context.h"
#include "pipe/p_state.h"
#include "util/u_inlines.h"
#include "util/u_format.h"
#include "translate/translate.h"

#include "nvc0_context.h"
#include "nvc0_resource.h"

#include "nvc0_3d.xml.h"

void
nvc0_vertex_state_delete(struct pipe_context *pipe,
                         void *hwcso)
{
   struct nvc0_vertex_stateobj *so = hwcso;

   if (so->translate)
      so->translate->release(so->translate);
   FREE(hwcso);
}

void *
nvc0_vertex_state_create(struct pipe_context *pipe,
                         unsigned num_elements,
                         const struct pipe_vertex_element *elements)
{
    struct nvc0_vertex_stateobj *so;
    struct translate_key transkey;
    unsigned i;
    unsigned src_offset_max = 0;

    so = MALLOC(sizeof(*so) +
                num_elements * sizeof(struct nvc0_vertex_element));
    if (!so)
        return NULL;
    so->num_elements = num_elements;
    so->instance_elts = 0;
    so->instance_bufs = 0;
    so->shared_slots = FALSE;
    so->need_conversion = FALSE;

    memset(so->vb_access_size, 0, sizeof(so->vb_access_size));

    for (i = 0; i < PIPE_MAX_ATTRIBS; ++i)
       so->min_instance_div[i] = 0xffffffff;

    transkey.nr_elements = 0;
    transkey.output_stride = 0;

    for (i = 0; i < num_elements; ++i) {
        const struct pipe_vertex_element *ve = &elements[i];
        const unsigned vbi = ve->vertex_buffer_index;
        unsigned size;
        enum pipe_format fmt = ve->src_format;

        so->element[i].pipe = elements[i];
        so->element[i].state = nvc0_format_table[fmt].vtx;

        if (!so->element[i].state) {
            switch (util_format_get_nr_components(fmt)) {
            case 1: fmt = PIPE_FORMAT_R32_FLOAT; break;
            case 2: fmt = PIPE_FORMAT_R32G32_FLOAT; break;
            case 3: fmt = PIPE_FORMAT_R32G32B32_FLOAT; break;
            case 4: fmt = PIPE_FORMAT_R32G32B32A32_FLOAT; break;
            default:
                assert(0);
                FREE(so);
                return NULL;
            }
            so->element[i].state = nvc0_format_table[fmt].vtx;
            so->need_conversion = TRUE;
        }
        size = util_format_get_blocksize(fmt);

        src_offset_max = MAX2(src_offset_max, ve->src_offset);

        if (so->vb_access_size[vbi] < (ve->src_offset + size))
           so->vb_access_size[vbi] = ve->src_offset + size;

        if (unlikely(ve->instance_divisor)) {
           so->instance_elts |= 1 << i;
           so->instance_bufs |= 1 << vbi;
           if (ve->instance_divisor < so->min_instance_div[vbi])
              so->min_instance_div[vbi] = ve->instance_divisor;
        }

        if (1) {
            unsigned ca;
            unsigned j = transkey.nr_elements++;

            ca = util_format_description(fmt)->channel[0].size / 8;
            if (ca != 1 && ca != 2)
               ca = 4;

            transkey.element[j].type = TRANSLATE_ELEMENT_NORMAL;
            transkey.element[j].input_format = ve->src_format;
            transkey.element[j].input_buffer = vbi;
            transkey.element[j].input_offset = ve->src_offset;
            transkey.element[j].instance_divisor = ve->instance_divisor;

            transkey.output_stride = align(transkey.output_stride, ca);
            transkey.element[j].output_format = fmt;
            transkey.element[j].output_offset = transkey.output_stride;
            transkey.output_stride += size;

            so->element[i].state_alt = so->element[i].state;
            so->element[i].state_alt |= transkey.element[j].output_offset << 7;
        }

        so->element[i].state |= i << NVC0_3D_VERTEX_ATTRIB_FORMAT_BUFFER__SHIFT;
    }
    transkey.output_stride = align(transkey.output_stride, 4);

    so->size = transkey.output_stride;
    so->translate = translate_create(&transkey);

    if (so->instance_elts || src_offset_max >= (1 << 14))
       return so;
    so->shared_slots = TRUE;

    for (i = 0; i < num_elements; ++i) {
       const unsigned b = elements[i].vertex_buffer_index;
       const unsigned s = elements[i].src_offset;
       so->element[i].state &= ~NVC0_3D_VERTEX_ATTRIB_FORMAT_BUFFER__MASK;
       so->element[i].state |= b << NVC0_3D_VERTEX_ATTRIB_FORMAT_BUFFER__SHIFT;
       so->element[i].state |= s << NVC0_3D_VERTEX_ATTRIB_FORMAT_OFFSET__SHIFT;
    }
    return so;
}

#define NVC0_3D_VERTEX_ATTRIB_INACTIVE                                       \
   NVC0_3D_VERTEX_ATTRIB_FORMAT_TYPE_FLOAT |                                 \
   NVC0_3D_VERTEX_ATTRIB_FORMAT_SIZE_32 | NVC0_3D_VERTEX_ATTRIB_FORMAT_CONST

#define VTX_ATTR(a, c, t, s)                            \
   ((NVC0_3D_VTX_ATTR_DEFINE_TYPE_##t) |                \
    (NVC0_3D_VTX_ATTR_DEFINE_SIZE_##s) |                \
    ((a) << NVC0_3D_VTX_ATTR_DEFINE_ATTR__SHIFT) |      \
    ((c) << NVC0_3D_VTX_ATTR_DEFINE_COMP__SHIFT))

static void
nvc0_set_constant_vertex_attrib(struct nvc0_context *nvc0, const unsigned a)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct pipe_vertex_element *ve = &nvc0->vertex->element[a].pipe;
   struct pipe_vertex_buffer *vb = &nvc0->vtxbuf[ve->vertex_buffer_index];
   uint32_t mode;
   const struct util_format_description *desc;
   void *dst;
   const void *src = (const uint8_t *)vb->user_buffer + ve->src_offset;
   assert(!vb->buffer);

   desc = util_format_description(ve->src_format);

   PUSH_SPACE(push, 6);
   BEGIN_NVC0(push, NVC0_3D(VTX_ATTR_DEFINE), 5);
   dst = &push->cur[1];
   if (desc->channel[0].pure_integer) {
      if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
         mode = VTX_ATTR(a, 4, SINT, 32);
         desc->unpack_rgba_sint(dst, 0, src, 0, 1, 1);
      } else {
         mode = VTX_ATTR(a, 4, UINT, 32);
         desc->unpack_rgba_uint(dst, 0, src, 0, 1, 1);
      }
   } else {
      mode = VTX_ATTR(a, 4, FLOAT, 32);
      desc->unpack_rgba_float(dst, 0, src, 0, 1, 1);
   }
   push->cur[0] = mode;
   push->cur += 5;
}

static INLINE void
nvc0_user_vbuf_range(struct nvc0_context *nvc0, int vbi,
                     uint32_t *base, uint32_t *size)
{
   if (unlikely(nvc0->vertex->instance_bufs & (1 << vbi))) {
      const uint32_t div = nvc0->vertex->min_instance_div[vbi];
      *base = nvc0->instance_off * nvc0->vtxbuf[vbi].stride;
      *size = (nvc0->instance_max / div) * nvc0->vtxbuf[vbi].stride +
         nvc0->vertex->vb_access_size[vbi];
   } else {
      /* NOTE: if there are user buffers, we *must* have index bounds */
      assert(nvc0->vb_elt_limit != ~0);
      *base = nvc0->vb_elt_first * nvc0->vtxbuf[vbi].stride;
      *size = nvc0->vb_elt_limit * nvc0->vtxbuf[vbi].stride +
         nvc0->vertex->vb_access_size[vbi];
   }
}

static INLINE void
nvc0_release_user_vbufs(struct nvc0_context *nvc0)
{
   if (nvc0->vbo_user) {
      nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_VTX_TMP);
      nouveau_scratch_done(&nvc0->base);
   }
}

static void
nvc0_update_user_vbufs(struct nvc0_context *nvc0)
{
   uint64_t address[PIPE_MAX_ATTRIBS];
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   int i;
   uint32_t written = 0;

   PUSH_SPACE(push, nvc0->vertex->num_elements * 8);
   for (i = 0; i < nvc0->vertex->num_elements; ++i) {
      struct pipe_vertex_element *ve = &nvc0->vertex->element[i].pipe;
      const unsigned b = ve->vertex_buffer_index;
      struct pipe_vertex_buffer *vb = &nvc0->vtxbuf[b];
      uint32_t base, size;

      if (!(nvc0->vbo_user & (1 << b)))
         continue;
      if (!vb->stride) {
         nvc0_set_constant_vertex_attrib(nvc0, i);
         continue;
      }
      nvc0_user_vbuf_range(nvc0, b, &base, &size);

      if (!(written & (1 << b))) {
         struct nouveau_bo *bo;
         const uint32_t bo_flags = NOUVEAU_BO_RD | NOUVEAU_BO_GART;
         written |= 1 << b;
         address[b] = nouveau_scratch_data(&nvc0->base, vb->user_buffer,
                                           base, size, &bo);
         if (bo)
            BCTX_REFN_bo(nvc0->bufctx_3d, VTX_TMP, bo_flags, bo);

         NOUVEAU_DRV_STAT(&nvc0->screen->base, user_buffer_upload_bytes, size);
      }

      BEGIN_1IC0(push, NVC0_3D(MACRO_VERTEX_ARRAY_SELECT), 5);
      PUSH_DATA (push, i);
      PUSH_DATAh(push, address[b] + base + size - 1);
      PUSH_DATA (push, address[b] + base + size - 1);
      PUSH_DATAh(push, address[b] + ve->src_offset);
      PUSH_DATA (push, address[b] + ve->src_offset);
   }
   nvc0->base.vbo_dirty = TRUE;
}

static void
nvc0_update_user_vbufs_shared(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   uint32_t mask = nvc0->vbo_user & ~nvc0->constant_vbos;

   PUSH_SPACE(push, nvc0->num_vtxbufs * 8);
   while (mask) {
      struct nouveau_bo *bo;
      const uint32_t bo_flags = NOUVEAU_BO_RD | NOUVEAU_BO_GART;
      uint64_t address;
      uint32_t base, size;
      const int b = ffs(mask) - 1;
      mask &= ~(1 << b);

      nvc0_user_vbuf_range(nvc0, b, &base, &size);

      address = nouveau_scratch_data(&nvc0->base, nvc0->vtxbuf[b].user_buffer,
                                     base, size, &bo);
      if (bo)
         BCTX_REFN_bo(nvc0->bufctx_3d, VTX_TMP, bo_flags, bo);

      BEGIN_1IC0(push, NVC0_3D(MACRO_VERTEX_ARRAY_SELECT), 5);
      PUSH_DATA (push, b);
      PUSH_DATAh(push, address + base + size - 1);
      PUSH_DATA (push, address + base + size - 1);
      PUSH_DATAh(push, address);
      PUSH_DATA (push, address);

      NOUVEAU_DRV_STAT(&nvc0->screen->base, user_buffer_upload_bytes, size);
   }

   mask = nvc0->state.constant_elts;
   while (mask) {
      int i = ffs(mask) - 1;
      mask &= ~(1 << i);
      nvc0_set_constant_vertex_attrib(nvc0, i);
   }
}

static void
nvc0_validate_vertex_buffers(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   const struct nvc0_vertex_stateobj *vertex = nvc0->vertex;
   uint32_t refd = 0;
   unsigned i;

   PUSH_SPACE(push, vertex->num_elements * 8);
   for (i = 0; i < vertex->num_elements; ++i) {
      const struct nvc0_vertex_element *ve;
      const struct pipe_vertex_buffer *vb;
      struct nv04_resource *res;
      unsigned b;
      unsigned limit, offset;

      if (nvc0->state.constant_elts & (1 << i))
         continue;
      ve = &vertex->element[i];
      b = ve->pipe.vertex_buffer_index;
      vb = &nvc0->vtxbuf[b];

      if (!vb->buffer) {
         if (vb->stride) {
            if (ve->pipe.instance_divisor) {
               BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_DIVISOR(i)), 1);
               PUSH_DATA (push, ve->pipe.instance_divisor);
            }
            BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 1);
            PUSH_DATA (push, (1 << 12) | vb->stride);
         }
         /* address/value set in nvc0_update_user_vbufs */
         continue;
      }
      res = nv04_resource(vb->buffer);
      offset = ve->pipe.src_offset + vb->buffer_offset;
      limit = vb->buffer->width0 - 1;

      if (unlikely(ve->pipe.instance_divisor)) {
         BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 4);
         PUSH_DATA (push, (1 << 12) | vb->stride);
         PUSH_DATAh(push, res->address + offset);
         PUSH_DATA (push, res->address + offset);
         PUSH_DATA (push, ve->pipe.instance_divisor);
      } else {
         BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 3);
         PUSH_DATA (push, (1 << 12) | vb->stride);
         PUSH_DATAh(push, res->address + offset);
         PUSH_DATA (push, res->address + offset);
      }
      BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_LIMIT_HIGH(i)), 2);
      PUSH_DATAh(push, res->address + limit);
      PUSH_DATA (push, res->address + limit);

      if (!(refd & (1 << b))) {
         refd |= 1 << b;
         BCTX_REFN(nvc0->bufctx_3d, VTX, res, RD);
      }
   }
   if (nvc0->vbo_user)
      nvc0_update_user_vbufs(nvc0);
}

static void
nvc0_validate_vertex_buffers_shared(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   unsigned b;
   const uint32_t mask = nvc0->vbo_user;

   PUSH_SPACE(push, nvc0->num_vtxbufs * 8);
   for (b = 0; b < nvc0->num_vtxbufs; ++b) {
      struct pipe_vertex_buffer *vb = &nvc0->vtxbuf[b];
      struct nv04_resource *buf;
      uint32_t offset, limit;

      if (mask & (1 << b)) {
         if (vb->stride) {
            BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(b)), 1);
            PUSH_DATA (push, NVC0_3D_VERTEX_ARRAY_FETCH_ENABLE | vb->stride);
         }
         /* address/value set in nvc0_update_user_vbufs_shared */
         continue;
      }
      buf = nv04_resource(vb->buffer);
      offset = vb->buffer_offset;
      limit = buf->base.width0 - 1;

      BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(b)), 3);
      PUSH_DATA (push, NVC0_3D_VERTEX_ARRAY_FETCH_ENABLE | vb->stride);
      PUSH_DATAh(push, buf->address + offset);
      PUSH_DATA (push, buf->address + offset);
      BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_LIMIT_HIGH(b)), 2);
      PUSH_DATAh(push, buf->address + limit);
      PUSH_DATA (push, buf->address + limit);

      BCTX_REFN(nvc0->bufctx_3d, VTX, buf, RD);
   }
   if (nvc0->vbo_user)
      nvc0_update_user_vbufs_shared(nvc0);
}

void
nvc0_vertex_arrays_validate(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nvc0_vertex_stateobj *vertex = nvc0->vertex;
   struct nvc0_vertex_element *ve;
   uint32_t const_vbos;
   unsigned i;
   uint8_t vbo_mode;
   boolean update_vertex;

   nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_VTX);

   if (unlikely(vertex->need_conversion) ||
       unlikely(nvc0->vertprog->vp.edgeflag < PIPE_MAX_ATTRIBS)) {
      vbo_mode = 3;
   } else {
      vbo_mode = (nvc0->vbo_user && nvc0->vbo_push_hint) ? 1 : 0;
   }
   const_vbos = vbo_mode ? 0 : nvc0->constant_vbos;

   update_vertex = (nvc0->dirty & NVC0_NEW_VERTEX) ||
      (const_vbos != nvc0->state.constant_vbos) ||
      (vbo_mode != nvc0->state.vbo_mode);

   if (update_vertex) {
      const unsigned n = MAX2(vertex->num_elements, nvc0->state.num_vtxelts);

      nvc0->state.constant_vbos = const_vbos;
      nvc0->state.constant_elts = 0;
      nvc0->state.num_vtxelts = vertex->num_elements;
      nvc0->state.vbo_mode = vbo_mode;

      if (unlikely(vbo_mode)) {
         if (unlikely(nvc0->state.instance_elts & 3)) {
            /* translate mode uses only 2 vertex buffers */
            nvc0->state.instance_elts &= ~3;
            PUSH_SPACE(push, 3);
            BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_PER_INSTANCE(0)), 2);
            PUSH_DATA (push, 0);
            PUSH_DATA (push, 0);
         }

         PUSH_SPACE(push, n * 2 + 4);

         BEGIN_NVC0(push, NVC0_3D(VERTEX_ATTRIB_FORMAT(0)), n);
         for (i = 0; i < vertex->num_elements; ++i)
            PUSH_DATA(push, vertex->element[i].state_alt);
         for (; i < n; ++i)
            PUSH_DATA(push, NVC0_3D_VERTEX_ATTRIB_INACTIVE);

         BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(0)), 1);
         PUSH_DATA (push, (1 << 12) | vertex->size);
         for (i = 1; i < n; ++i)
            IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 0);
      } else {
         uint32_t *restrict data;

         if (unlikely(vertex->instance_elts != nvc0->state.instance_elts)) {
            nvc0->state.instance_elts = vertex->instance_elts;
            assert(n); /* if (n == 0), both masks should be 0 */
            PUSH_SPACE(push, 3);
            BEGIN_NVC0(push, NVC0_3D(MACRO_VERTEX_ARRAY_PER_INSTANCE), 2);
            PUSH_DATA (push, n);
            PUSH_DATA (push, vertex->instance_elts);
         }

         PUSH_SPACE(push, n * 2 + 1);
         BEGIN_NVC0(push, NVC0_3D(VERTEX_ATTRIB_FORMAT(0)), n);
         data = push->cur;
         push->cur += n;
         for (i = 0; i < vertex->num_elements; ++i) {
            ve = &vertex->element[i];
            data[i] = ve->state;
            if (unlikely(const_vbos & (1 << ve->pipe.vertex_buffer_index))) {
               nvc0->state.constant_elts |= 1 << i;
               data[i] |= NVC0_3D_VERTEX_ATTRIB_FORMAT_CONST;
               IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 0);
            }
         }
         for (; i < n; ++i) {
            data[i] = NVC0_3D_VERTEX_ATTRIB_INACTIVE;
            IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 0);
         }
      }
   }
   if (nvc0->state.vbo_mode) /* using translate, don't set up arrays here */
      return;

   if (vertex->shared_slots)
      nvc0_validate_vertex_buffers_shared(nvc0);
   else
      nvc0_validate_vertex_buffers(nvc0);
}

void
nvc0_idxbuf_validate(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nv04_resource *buf = nv04_resource(nvc0->idxbuf.buffer);

   assert(buf);
   assert(nouveau_resource_mapped_by_gpu(&buf->base));

   PUSH_SPACE(push, 6);
   BEGIN_NVC0(push, NVC0_3D(INDEX_ARRAY_START_HIGH), 5);
   PUSH_DATAh(push, buf->address + nvc0->idxbuf.offset);
   PUSH_DATA (push, buf->address + nvc0->idxbuf.offset);
   PUSH_DATAh(push, buf->address + buf->base.width0 - 1);
   PUSH_DATA (push, buf->address + buf->base.width0 - 1);
   PUSH_DATA (push, nvc0->idxbuf.index_size >> 1);

   BCTX_REFN(nvc0->bufctx_3d, IDX, buf, RD);
}

#define NVC0_PRIM_GL_CASE(n) \
   case PIPE_PRIM_##n: return NVC0_3D_VERTEX_BEGIN_GL_PRIMITIVE_##n

static INLINE unsigned
nvc0_prim_gl(unsigned prim)
{
   switch (prim) {
   NVC0_PRIM_GL_CASE(POINTS);
   NVC0_PRIM_GL_CASE(LINES);
   NVC0_PRIM_GL_CASE(LINE_LOOP);
   NVC0_PRIM_GL_CASE(LINE_STRIP);
   NVC0_PRIM_GL_CASE(TRIANGLES);
   NVC0_PRIM_GL_CASE(TRIANGLE_STRIP);
   NVC0_PRIM_GL_CASE(TRIANGLE_FAN);
   NVC0_PRIM_GL_CASE(QUADS);
   NVC0_PRIM_GL_CASE(QUAD_STRIP);
   NVC0_PRIM_GL_CASE(POLYGON);
   NVC0_PRIM_GL_CASE(LINES_ADJACENCY);
   NVC0_PRIM_GL_CASE(LINE_STRIP_ADJACENCY);
   NVC0_PRIM_GL_CASE(TRIANGLES_ADJACENCY);
   NVC0_PRIM_GL_CASE(TRIANGLE_STRIP_ADJACENCY);
   /*
   NVC0_PRIM_GL_CASE(PATCHES); */
   default:
      return NVC0_3D_VERTEX_BEGIN_GL_PRIMITIVE_POINTS;
   }
}

static void
nvc0_draw_vbo_kick_notify(struct nouveau_pushbuf *push)
{
   struct nvc0_screen *screen = push->user_priv;

   nouveau_fence_update(&screen->base, TRUE);

   NOUVEAU_DRV_STAT(&screen->base, pushbuf_count, 1);
}

static void
nvc0_draw_arrays(struct nvc0_context *nvc0,
                 unsigned mode, unsigned start, unsigned count,
                 unsigned instance_count)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   unsigned prim;

   if (nvc0->state.index_bias) {
      PUSH_SPACE(push, 1);
      IMMED_NVC0(push, NVC0_3D(VB_ELEMENT_BASE), 0);
      nvc0->state.index_bias = 0;
   }

   prim = nvc0_prim_gl(mode);

   while (instance_count--) {
      PUSH_SPACE(push, 6);
      BEGIN_NVC0(push, NVC0_3D(VERTEX_BEGIN_GL), 1);
      PUSH_DATA (push, prim);
      BEGIN_NVC0(push, NVC0_3D(VERTEX_BUFFER_FIRST), 2);
      PUSH_DATA (push, start);
      PUSH_DATA (push, count);
      IMMED_NVC0(push, NVC0_3D(VERTEX_END_GL), 0);

      prim |= NVC0_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT;
   }
   NOUVEAU_DRV_STAT(&nvc0->screen->base, draw_calls_array, 1);
}

static void
nvc0_draw_elements_inline_u08(struct nouveau_pushbuf *push, const uint8_t *map,
                              unsigned start, unsigned count)
{
   map += start;

   if (count & 3) {
      unsigned i;
      PUSH_SPACE(push, 4);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U32), count & 3);
      for (i = 0; i < (count & 3); ++i)
         PUSH_DATA(push, *map++);
      count &= ~3;
   }
   while (count) {
      unsigned i, nr = MIN2(count, NV04_PFIFO_MAX_PACKET_LEN * 4) / 4;

      PUSH_SPACE(push, nr + 1);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U8), nr);
      for (i = 0; i < nr; ++i) {
         PUSH_DATA(push,
                  (map[3] << 24) | (map[2] << 16) | (map[1] << 8) | map[0]);
         map += 4;
      }
      count -= nr * 4;
   }
}

static void
nvc0_draw_elements_inline_u16(struct nouveau_pushbuf *push, const uint16_t *map,
                              unsigned start, unsigned count)
{
   map += start;

   if (count & 1) {
      count &= ~1;
      PUSH_SPACE(push, 2);
      BEGIN_NVC0(push, NVC0_3D(VB_ELEMENT_U32), 1);
      PUSH_DATA (push, *map++);
   }
   while (count) {
      unsigned i, nr = MIN2(count, NV04_PFIFO_MAX_PACKET_LEN * 2) / 2;

      PUSH_SPACE(push, nr + 1);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U16), nr);
      for (i = 0; i < nr; ++i) {
         PUSH_DATA(push, (map[1] << 16) | map[0]);
         map += 2;
      }
      count -= nr * 2;
   }
}

static void
nvc0_draw_elements_inline_u32(struct nouveau_pushbuf *push, const uint32_t *map,
                              unsigned start, unsigned count)
{
   map += start;

   while (count) {
      const unsigned nr = MIN2(count, NV04_PFIFO_MAX_PACKET_LEN);

      PUSH_SPACE(push, nr + 1);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U32), nr);
      PUSH_DATAp(push, map, nr);

      map += nr;
      count -= nr;
   }
}

static void
nvc0_draw_elements_inline_u32_short(struct nouveau_pushbuf *push,
                                    const uint32_t *map,
                                    unsigned start, unsigned count)
{
   map += start;

   if (count & 1) {
      count--;
      PUSH_SPACE(push, 1);
      BEGIN_NVC0(push, NVC0_3D(VB_ELEMENT_U32), 1);
      PUSH_DATA (push, *map++);
   }
   while (count) {
      unsigned i, nr = MIN2(count, NV04_PFIFO_MAX_PACKET_LEN * 2) / 2;

      PUSH_SPACE(push, nr + 1);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U16), nr);
      for (i = 0; i < nr; ++i) {
         PUSH_DATA(push, (map[1] << 16) | map[0]);
         map += 2;
      }
      count -= nr * 2;
   }
}

static void
nvc0_draw_elements(struct nvc0_context *nvc0, boolean shorten,
                   unsigned mode, unsigned start, unsigned count,
                   unsigned instance_count, int32_t index_bias)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   unsigned prim;
   const unsigned index_size = nvc0->idxbuf.index_size;

   prim = nvc0_prim_gl(mode);

   if (index_bias != nvc0->state.index_bias) {
      PUSH_SPACE(push, 2);
      BEGIN_NVC0(push, NVC0_3D(VB_ELEMENT_BASE), 1);
      PUSH_DATA (push, index_bias);
      nvc0->state.index_bias = index_bias;
   }

   if (nvc0->idxbuf.buffer) {
      PUSH_SPACE(push, 1);
      IMMED_NVC0(push, NVC0_3D(VERTEX_BEGIN_GL), prim);
      do {
         PUSH_SPACE(push, 7);
         BEGIN_NVC0(push, NVC0_3D(INDEX_BATCH_FIRST), 2);
         PUSH_DATA (push, start);
         PUSH_DATA (push, count);
         if (--instance_count) {
            BEGIN_NVC0(push, NVC0_3D(VERTEX_END_GL), 2);
            PUSH_DATA (push, 0);
            PUSH_DATA (push, prim | NVC0_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT);
         }
      } while (instance_count);
      IMMED_NVC0(push, NVC0_3D(VERTEX_END_GL), 0);
   } else {
      const void *data = nvc0->idxbuf.user_buffer;

      while (instance_count--) {
         PUSH_SPACE(push, 2);
         BEGIN_NVC0(push, NVC0_3D(VERTEX_BEGIN_GL), 1);
         PUSH_DATA (push, prim);
         switch (index_size) {
         case 1:
            nvc0_draw_elements_inline_u08(push, data, start, count);
            break;
         case 2:
            nvc0_draw_elements_inline_u16(push, data, start, count);
            break;
         case 4:
            if (shorten)
               nvc0_draw_elements_inline_u32_short(push, data, start, count);
            else
               nvc0_draw_elements_inline_u32(push, data, start, count);
            break;
         default:
            assert(0);
            return;
         }
         PUSH_SPACE(push, 1);
         IMMED_NVC0(push, NVC0_3D(VERTEX_END_GL), 0);

         prim |= NVC0_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT;
      }
   }
   NOUVEAU_DRV_STAT(&nvc0->screen->base, draw_calls_indexed, 1);
}

static void
nvc0_draw_stream_output(struct nvc0_context *nvc0,
                        const struct pipe_draw_info *info)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nvc0_so_target *so = nvc0_so_target(info->count_from_stream_output);
   struct nv04_resource *res = nv04_resource(so->pipe.buffer);
   unsigned mode = nvc0_prim_gl(info->mode);
   unsigned num_instances = info->instance_count;

   if (res->status & NOUVEAU_BUFFER_STATUS_GPU_WRITING) {
      res->status &= ~NOUVEAU_BUFFER_STATUS_GPU_WRITING;
      PUSH_SPACE(push, 2);
      IMMED_NVC0(push, NVC0_3D(SERIALIZE), 0);
      nvc0_query_fifo_wait(push, so->pq);
      IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FLUSH), 0);

      NOUVEAU_DRV_STAT(&nvc0->screen->base, gpu_serialize_count, 1);
   }

   while (num_instances--) {
      PUSH_SPACE(push, 8);
      BEGIN_NVC0(push, NVC0_3D(VERTEX_BEGIN_GL), 1);
      PUSH_DATA (push, mode);
      BEGIN_NVC0(push, NVC0_3D(DRAW_TFB_BASE), 1);
      PUSH_DATA (push, 0);
      BEGIN_NVC0(push, NVC0_3D(DRAW_TFB_STRIDE), 1);
      PUSH_DATA (push, so->stride);
      BEGIN_NVC0(push, NVC0_3D(DRAW_TFB_BYTES), 1);
      nvc0_query_pushbuf_submit(push, so->pq, 0x4);
      IMMED_NVC0(push, NVC0_3D(VERTEX_END_GL), 0);

      mode |= NVC0_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT;
   }
}

void
nvc0_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *info)
{
   struct nvc0_context *nvc0 = nvc0_context(pipe);
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;

   /* NOTE: caller must ensure that (min_index + index_bias) is >= 0 */
   nvc0->vb_elt_first = info->min_index + info->index_bias;
   nvc0->vb_elt_limit = info->max_index - info->min_index;
   nvc0->instance_off = info->start_instance;
   nvc0->instance_max = info->instance_count - 1;

   /* For picking only a few vertices from a large user buffer, push is better,
    * if index count is larger and we expect repeated vertices, suggest upload.
    */
   nvc0->vbo_push_hint =
      info->indexed && (nvc0->vb_elt_limit >= (info->count * 2));

   /* Check whether we want to switch vertex-submission mode. */
   if (nvc0->vbo_user && !(nvc0->dirty & (NVC0_NEW_ARRAYS | NVC0_NEW_VERTEX))) {
      if (nvc0->vbo_push_hint != !!nvc0->state.vbo_mode)
         if (nvc0->state.vbo_mode != 3)
            nvc0->dirty |= NVC0_NEW_ARRAYS;

      if (!(nvc0->dirty & NVC0_NEW_ARRAYS) && nvc0->state.vbo_mode == 0) {
         if (nvc0->vertex->shared_slots)
            nvc0_update_user_vbufs_shared(nvc0);
         else
            nvc0_update_user_vbufs(nvc0);
      }
   }

   /* 8 as minimum to avoid immediate double validation of new buffers */
   nvc0_state_validate(nvc0, ~0, 8);

   push->kick_notify = nvc0_draw_vbo_kick_notify;

   if (nvc0->state.vbo_mode) {
      nvc0_push_vbo(nvc0, info);
      push->kick_notify = nvc0_default_kick_notify;
      return;
   }

   /* space for base instance, flush, and prim restart */
   PUSH_SPACE(push, 8);

   if (nvc0->state.instance_base != info->start_instance) {
      nvc0->state.instance_base = info->start_instance;
      /* NOTE: this does not affect the shader input, should it ? */
      BEGIN_NVC0(push, NVC0_3D(VB_INSTANCE_BASE), 1);
      PUSH_DATA (push, info->start_instance);
   }

   if (nvc0->base.vbo_dirty) {
      IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FLUSH), 0);
      nvc0->base.vbo_dirty = FALSE;
   }

   if (info->indexed) {
      boolean shorten = info->max_index <= 65535;

      if (info->primitive_restart != nvc0->state.prim_restart) {
         if (info->primitive_restart) {
            BEGIN_NVC0(push, NVC0_3D(PRIM_RESTART_ENABLE), 2);
            PUSH_DATA (push, 1);
            PUSH_DATA (push, info->restart_index);

            if (info->restart_index > 65535)
               shorten = FALSE;
         } else {
            IMMED_NVC0(push, NVC0_3D(PRIM_RESTART_ENABLE), 0);
         }
         nvc0->state.prim_restart = info->primitive_restart;
      } else
      if (info->primitive_restart) {
         BEGIN_NVC0(push, NVC0_3D(PRIM_RESTART_INDEX), 1);
         PUSH_DATA (push, info->restart_index);

         if (info->restart_index > 65535)
            shorten = FALSE;
      }

      nvc0_draw_elements(nvc0, shorten,
                         info->mode, info->start, info->count,
                         info->instance_count, info->index_bias);
   } else
   if (unlikely(info->count_from_stream_output)) {
      nvc0_draw_stream_output(nvc0, info);
   } else {
      nvc0_draw_arrays(nvc0,
                       info->mode, info->start, info->count,
                       info->instance_count);
   }
   push->kick_notify = nvc0_default_kick_notify;

   nvc0_release_user_vbufs(nvc0);
}
@


1.2
log
@Merge Mesa 9.2.0
@
text
@@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d17 4
a20 4
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
d23 2
d55 1
d64 1
d67 5
d78 1
d92 1
d98 13
a110 1
        so->element[i].state |= i;
d113 1
d116 4
d126 1
d129 1
a129 1
            transkey.output_stride += (util_format_get_stride(fmt, 1) + 3) & ~3;
d131 2
a132 4
            if (unlikely(ve->instance_divisor)) {
               so->instance_elts |= 1 << i;
               so->instance_bufs |= 1 << vbi;
            }
d134 2
d137 1
d139 1
a140 2
    so->vtx_size = transkey.output_stride / 4;
    so->vtx_per_packet_max = NV04_PFIFO_MAX_PACKET_LEN / MAX2(so->vtx_size, 1);
d142 11
d167 1
a167 2
nvc0_emit_vtxattr(struct nvc0_context *nvc0, struct pipe_vertex_buffer *vb,
                  struct pipe_vertex_element *ve, unsigned attr)
d169 28
a196 16
   const void *data;
   struct nouveau_channel *chan = nvc0->screen->base.channel;
   struct nv04_resource *res = nv04_resource(vb->buffer);
   float v[4];
   int i;
   const unsigned nc = util_format_get_nr_components(ve->src_format);

   data = nouveau_resource_map_offset(&nvc0->base, res, vb->buffer_offset +
                                      ve->src_offset, NOUVEAU_BO_RD);

   util_format_read_4f(ve->src_format, v, 0, data, 0, 0, 0, 1, 1);

   BEGIN_RING(chan, RING_3D(VTX_ATTR_DEFINE), nc + 1);
   OUT_RING  (chan, VTX_ATTR(attr, nc, FLOAT, 32));
   for (i = 0; i < nc; ++i)
      OUT_RINGf(chan, v[i]);
d200 2
a201 2
nvc0_vbuf_range(struct nvc0_context *nvc0, int vbi,
                uint32_t *base, uint32_t *size)
d204 4
a207 3
      /* TODO: use min and max instance divisor to get a proper range */
      *base = 0;
      *size = nvc0->vtxbuf[vbi].buffer->width0;
d209 5
a213 4
      assert(nvc0->vbo_max_index != ~0);
      *base = nvc0->vbo_min_index * nvc0->vtxbuf[vbi].stride;
      *size = (nvc0->vbo_max_index -
               nvc0->vbo_min_index + 1) * nvc0->vtxbuf[vbi].stride;
d217 2
a218 2
static void
nvc0_prevalidate_vbufs(struct nvc0_context *nvc0)
d220 3
a222 34
   struct pipe_vertex_buffer *vb;
   struct nv04_resource *buf;
   int i;
   uint32_t base, size;

   nvc0->vbo_fifo = nvc0->vbo_user = 0;

   nvc0_bufctx_reset(nvc0, NVC0_BUFCTX_VERTEX);

   for (i = 0; i < nvc0->num_vtxbufs; ++i) {
      vb = &nvc0->vtxbuf[i];
      if (!vb->stride)
         continue;
      buf = nv04_resource(vb->buffer);

      /* NOTE: user buffers with temporary storage count as mapped by GPU */
      if (!nouveau_resource_mapped_by_gpu(vb->buffer)) {
         if (nvc0->vbo_push_hint) {
            nvc0->vbo_fifo = ~0;
            continue;
         } else {
            if (buf->status & NOUVEAU_BUFFER_STATUS_USER_MEMORY) {
               nvc0->vbo_user |= 1 << i;
               assert(vb->stride > vb->buffer_offset);
               nvc0_vbuf_range(nvc0, i, &base, &size);
               nouveau_user_buffer_upload(buf, base, size);
            } else {
               nouveau_buffer_migrate(&nvc0->base, buf, NOUVEAU_BO_GART);
            }
            nvc0->base.vbo_dirty = TRUE;
         }
      }
      nvc0_bufctx_add_resident(nvc0, NVC0_BUFCTX_VERTEX, buf, NOUVEAU_BO_RD);
      nouveau_buffer_adjust_score(&nvc0->base, buf, 1);
d229 2
a230 2
   struct nouveau_channel *chan = nvc0->screen->base.channel;
   uint32_t base, offset, size;
d234 1
d237 1
a237 1
      const int b = ve->vertex_buffer_index;
d239 1
a239 1
      struct nv04_resource *buf = nv04_resource(vb->buffer);
a242 1

d244 1
a244 1
         nvc0_emit_vtxattr(nvc0, vb, ve, i);
d247 1
a247 1
      nvc0_vbuf_range(nvc0, b, &base, &size);
d250 2
d253 6
a258 1
         nouveau_user_buffer_upload(buf, base, size);
a259 1
      offset = vb->buffer_offset + ve->src_offset;
d261 6
a266 7
      MARK_RING (chan, 6, 4);
      BEGIN_RING_1I(chan, RING_3D(VERTEX_ARRAY_SELECT), 5);
      OUT_RING  (chan, i);
      OUT_RESRCh(chan, buf, base + size - 1, NOUVEAU_BO_RD);
      OUT_RESRCl(chan, buf, base + size - 1, NOUVEAU_BO_RD);
      OUT_RESRCh(chan, buf, offset, NOUVEAU_BO_RD);
      OUT_RESRCl(chan, buf, offset, NOUVEAU_BO_RD);
d271 105
a375 2
static INLINE void
nvc0_release_user_vbufs(struct nvc0_context *nvc0)
d377 3
a379 1
   uint32_t vbo_user = nvc0->vbo_user;
d381 5
a385 3
   while (vbo_user) {
      int i = ffs(vbo_user) - 1;
      vbo_user &= ~(1 << i);
d387 21
a407 1
      nouveau_buffer_release_gpu_storage(nv04_resource(nvc0->vtxbuf[i].buffer));
d409 2
d416 1
a416 1
   struct nouveau_channel *chan = nvc0->screen->base.channel;
a417 1
   struct pipe_vertex_buffer *vb;
d419 1
d421 2
d424 5
a428 3
   if (unlikely(vertex->need_conversion || NVC0_USING_EDGEFLAG(nvc0))) {
      nvc0->vbo_fifo = ~0;
      nvc0->vbo_user = 0;
d430 1
a430 1
      nvc0_prevalidate_vbufs(nvc0);
d432 23
d456 1
a456 4
   BEGIN_RING(chan, RING_3D(VERTEX_ATTRIB_FORMAT(0)), vertex->num_elements);
   for (i = 0; i < vertex->num_elements; ++i) {
      ve = &vertex->element[i];
      vb = &nvc0->vtxbuf[ve->pipe.vertex_buffer_index];
d458 10
a467 2
      if (likely(vb->stride) || nvc0->vbo_fifo) {
         OUT_RING(chan, ve->state);
d469 1
a469 4
         OUT_RING(chan, ve->state | NVC0_3D_VERTEX_ATTRIB_FORMAT_CONST);
         nvc0->vbo_fifo &= ~(1 << i);
      }
   }
d471 8
a478 6
   for (i = 0; i < vertex->num_elements; ++i) {
      struct nv04_resource *res;
      unsigned size, offset;
      
      ve = &vertex->element[i];
      vb = &nvc0->vtxbuf[ve->pipe.vertex_buffer_index];
d480 16
a495 3
      if (unlikely(ve->pipe.instance_divisor)) {
         if (!(nvc0->state.instance_elts & (1 << i))) {
            IMMED_RING(chan, RING_3D(VERTEX_ARRAY_PER_INSTANCE(i)), 1);
a496 5
         BEGIN_RING(chan, RING_3D(VERTEX_ARRAY_DIVISOR(i)), 1);
         OUT_RING  (chan, ve->pipe.instance_divisor);
      } else
      if (unlikely(nvc0->state.instance_elts & (1 << i))) {
         IMMED_RING(chan, RING_3D(VERTEX_ARRAY_PER_INSTANCE(i)), 0);
d498 3
d502 5
a506 1
      res = nv04_resource(vb->buffer);
d508 5
a512 7
      if (nvc0->vbo_fifo || unlikely(vb->stride == 0)) {
         if (!nvc0->vbo_fifo)
            nvc0_emit_vtxattr(nvc0, vb, &ve->pipe, i);
         BEGIN_RING(chan, RING_3D(VERTEX_ARRAY_FETCH(i)), 1);
         OUT_RING  (chan, 0);
         continue;
      }
d514 2
a515 2
      size = vb->buffer->width0;
      offset = ve->pipe.src_offset + vb->buffer_offset;
d517 7
a523 16
      MARK_RING (chan, 8, 4);
      BEGIN_RING(chan, RING_3D(VERTEX_ARRAY_FETCH(i)), 1);
      OUT_RING  (chan, (1 << 12) | vb->stride);
      BEGIN_RING_1I(chan, RING_3D(VERTEX_ARRAY_SELECT), 5);
      OUT_RING  (chan, i);
      OUT_RESRCh(chan, res, size - 1, NOUVEAU_BO_RD);
      OUT_RESRCl(chan, res, size - 1, NOUVEAU_BO_RD);
      OUT_RESRCh(chan, res, offset, NOUVEAU_BO_RD);
      OUT_RESRCl(chan, res, offset, NOUVEAU_BO_RD);
   }
   for (; i < nvc0->state.num_vtxelts; ++i) {
      BEGIN_RING(chan, RING_3D(VERTEX_ATTRIB_FORMAT(i)), 1);
      OUT_RING  (chan, NVC0_3D_VERTEX_ATTRIB_INACTIVE);
      BEGIN_RING(chan, RING_3D(VERTEX_ARRAY_FETCH(i)), 1);
      OUT_RING  (chan, 0);
   }
d525 1
a525 2
   nvc0->state.num_vtxelts = vertex->num_elements;
   nvc0->state.instance_elts = vertex->instance_elts;
a552 1
      break;
d557 1
a557 1
nvc0_draw_vbo_flush_notify(struct nouveau_channel *chan)
d559 1
a559 1
   struct nvc0_screen *screen = chan->user_private;
d563 1
a563 1
   nvc0_bufctx_emit_relocs(screen->cur_ctx);
d571 1
a571 1
   struct nouveau_channel *chan = nvc0->screen->base.channel;
d574 6
d583 7
a589 6
      BEGIN_RING(chan, RING_3D(VERTEX_BEGIN_GL), 1);
      OUT_RING  (chan, prim);
      BEGIN_RING(chan, RING_3D(VERTEX_BUFFER_FIRST), 2);
      OUT_RING  (chan, start);
      OUT_RING  (chan, count);
      IMMED_RING(chan, RING_3D(VERTEX_END_GL), 0);
d593 1
d597 1
a597 1
nvc0_draw_elements_inline_u08(struct nouveau_channel *chan, uint8_t *map,
d604 2
a605 1
      BEGIN_RING_NI(chan, RING_3D(VB_ELEMENT_U32), count & 3);
d607 1
a607 1
         OUT_RING(chan, *map++);
d613 2
a614 1
      BEGIN_RING_NI(chan, RING_3D(VB_ELEMENT_U8), nr);
d616 1
a616 1
         OUT_RING(chan,
d625 1
a625 1
nvc0_draw_elements_inline_u16(struct nouveau_channel *chan, uint16_t *map,
d632 3
a634 2
      BEGIN_RING(chan, RING_3D(VB_ELEMENT_U32), 1);
      OUT_RING  (chan, *map++);
d639 2
a640 1
      BEGIN_RING_NI(chan, RING_3D(VB_ELEMENT_U16), nr);
d642 1
a642 1
         OUT_RING(chan, (map[1] << 16) | map[0]);
d650 1
a650 1
nvc0_draw_elements_inline_u32(struct nouveau_channel *chan, uint32_t *map,
d658 3
a660 2
      BEGIN_RING_NI(chan, RING_3D(VB_ELEMENT_U32), nr);
      OUT_RINGp    (chan, map, nr);
d668 2
a669 1
nvc0_draw_elements_inline_u32_short(struct nouveau_channel *chan, uint32_t *map,
d676 3
a678 2
      BEGIN_RING(chan, RING_3D(VB_ELEMENT_U32), 1);
      OUT_RING  (chan, *map++);
d683 2
a684 1
      BEGIN_RING_NI(chan, RING_3D(VB_ELEMENT_U16), nr);
d686 1
a686 1
         OUT_RING(chan, (map[1] << 16) | map[0]);
d698 1
a698 2
   struct nouveau_channel *chan = nvc0->screen->base.channel;
   void *data;
d705 3
a707 2
      BEGIN_RING(chan, RING_3D(VB_ELEMENT_BASE), 1);
      OUT_RING  (chan, index_bias);
d711 15
a725 25
   if (nouveau_resource_mapped_by_gpu(nvc0->idxbuf.buffer)) {
      struct nv04_resource *res = nv04_resource(nvc0->idxbuf.buffer);
      unsigned offset = nvc0->idxbuf.offset;
      unsigned limit = nvc0->idxbuf.buffer->width0 - 1;

      nouveau_buffer_adjust_score(&nvc0->base, res, 1);

      while (instance_count--) {
         MARK_RING (chan, 11, 4);
         BEGIN_RING(chan, RING_3D(VERTEX_BEGIN_GL), 1);
         OUT_RING  (chan, mode);
         BEGIN_RING(chan, RING_3D(INDEX_ARRAY_START_HIGH), 7);
         OUT_RESRCh(chan, res, offset, NOUVEAU_BO_RD);
         OUT_RESRCl(chan, res, offset, NOUVEAU_BO_RD);
         OUT_RESRCh(chan, res, limit, NOUVEAU_BO_RD);
         OUT_RESRCl(chan, res, limit, NOUVEAU_BO_RD);
         OUT_RING  (chan, index_size >> 1);
         OUT_RING  (chan, start);
         OUT_RING  (chan, count);
         IMMED_RING(chan, RING_3D(VERTEX_END_GL), 0);

         nvc0_resource_fence(res, NOUVEAU_BO_RD);

         mode |= NVC0_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT;
      }
d727 1
a727 5
      data = nouveau_resource_map_offset(&nvc0->base,
                                         nv04_resource(nvc0->idxbuf.buffer),
                                         nvc0->idxbuf.offset, NOUVEAU_BO_RD);
      if (!data)
         return;
d730 3
a732 2
         BEGIN_RING(chan, RING_3D(VERTEX_BEGIN_GL), 1);
         OUT_RING  (chan, prim);
d735 1
a735 1
            nvc0_draw_elements_inline_u08(chan, data, start, count);
d738 1
a738 1
            nvc0_draw_elements_inline_u16(chan, data, start, count);
d742 1
a742 1
               nvc0_draw_elements_inline_u32_short(chan, data, start, count);
d744 1
a744 1
               nvc0_draw_elements_inline_u32(chan, data, start, count);
d750 2
a751 1
         IMMED_RING(chan, RING_3D(VERTEX_END_GL), 0);
d756 37
d799 7
a805 1
   struct nouveau_channel *chan = nvc0->screen->base.channel;
d810 2
a811 3
   nvc0->vbo_push_hint = /* the 64 is heuristic */
      !(info->indexed &&
        ((info->max_index - info->min_index + 64) < info->count));
d813 5
a817 2
   nvc0->vbo_min_index = info->min_index;
   nvc0->vbo_max_index = info->max_index;
d819 7
a825 2
   if (nvc0->vbo_push_hint != !!nvc0->vbo_fifo)
      nvc0->dirty |= NVC0_NEW_ARRAYS;
d827 2
a828 4
   if (nvc0->vbo_user && !(nvc0->dirty & (NVC0_NEW_VERTEX | NVC0_NEW_ARRAYS)))
      nvc0_update_user_vbufs(nvc0);

   nvc0_state_validate(nvc0);
d830 1
a830 1
   chan->flush_notify = nvc0_draw_vbo_flush_notify;
d832 1
a832 1
   if (nvc0->vbo_fifo) {
d834 1
a834 1
      chan->flush_notify = nvc0_default_flush_notify;
d838 3
d844 2
a845 2
      BEGIN_RING(chan, RING_3D(VB_INSTANCE_BASE), 1);
      OUT_RING  (chan, info->start_instance);
d849 1
a849 2
      BEGIN_RING(chan, RING_3D(VERTEX_ARRAY_FLUSH), 1);
      OUT_RING  (chan, 0);
d853 1
a853 5
   if (!info->indexed) {
      nvc0_draw_arrays(nvc0,
                       info->mode, info->start, info->count,
                       info->instance_count);
   } else {
a855 2
      assert(nvc0->idxbuf.buffer);

d858 3
a860 3
            BEGIN_RING(chan, RING_3D(PRIM_RESTART_ENABLE), 2);
            OUT_RING  (chan, 1);
            OUT_RING  (chan, info->restart_index);
d865 1
a865 1
            IMMED_RING(chan, RING_3D(PRIM_RESTART_ENABLE), 0);
d870 2
a871 2
         BEGIN_RING(chan, RING_3D(PRIM_RESTART_INDEX), 1);
         OUT_RING  (chan, info->restart_index);
d880 7
d888 1
a888 1
   chan->flush_notify = nvc0_default_flush_notify;
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d17 4
a20 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a22 2
#define NVC0_PUSH_EXPLICIT_SPACE_CHECKING

a52 1
    unsigned src_offset_max = 0;
a60 1
    so->shared_slots = FALSE;
a62 5
    memset(so->vb_access_size, 0, sizeof(so->vb_access_size));

    for (i = 0; i < PIPE_MAX_ATTRIBS; ++i)
       so->min_instance_div[i] = 0xffffffff;

a68 1
        unsigned size;
a81 1
                FREE(so);
d87 1
a87 13
        size = util_format_get_blocksize(fmt);

        src_offset_max = MAX2(src_offset_max, ve->src_offset);

        if (so->vb_access_size[vbi] < (ve->src_offset + size))
           so->vb_access_size[vbi] = ve->src_offset + size;

        if (unlikely(ve->instance_divisor)) {
           so->instance_elts |= 1 << i;
           so->instance_bufs |= 1 << vbi;
           if (ve->instance_divisor < so->min_instance_div[vbi])
              so->min_instance_div[vbi] = ve->instance_divisor;
        }
a89 1
            unsigned ca;
a91 4
            ca = util_format_description(fmt)->channel[0].size / 8;
            if (ca != 1 && ca != 2)
               ca = 4;

a97 1
            transkey.output_stride = align(transkey.output_stride, ca);
d100 1
a100 1
            transkey.output_stride += size;
d102 4
a105 2
            so->element[i].state_alt = so->element[i].state;
            so->element[i].state_alt |= transkey.element[j].output_offset << 7;
a106 2

        so->element[i].state |= i << NVC0_3D_VERTEX_ATTRIB_FORMAT_BUFFER__SHIFT;
a107 1
    transkey.output_stride = align(transkey.output_stride, 4);
a108 1
    so->size = transkey.output_stride;
d110 2
a112 11
    if (so->instance_elts || src_offset_max >= (1 << 14))
       return so;
    so->shared_slots = TRUE;

    for (i = 0; i < num_elements; ++i) {
       const unsigned b = elements[i].vertex_buffer_index;
       const unsigned s = elements[i].src_offset;
       so->element[i].state &= ~NVC0_3D_VERTEX_ATTRIB_FORMAT_BUFFER__MASK;
       so->element[i].state |= b << NVC0_3D_VERTEX_ATTRIB_FORMAT_BUFFER__SHIFT;
       so->element[i].state |= s << NVC0_3D_VERTEX_ATTRIB_FORMAT_OFFSET__SHIFT;
    }
d127 2
a128 1
nvc0_set_constant_vertex_attrib(struct nvc0_context *nvc0, const unsigned a)
d130 16
a145 28
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct pipe_vertex_element *ve = &nvc0->vertex->element[a].pipe;
   struct pipe_vertex_buffer *vb = &nvc0->vtxbuf[ve->vertex_buffer_index];
   uint32_t mode;
   const struct util_format_description *desc;
   void *dst;
   const void *src = (const uint8_t *)vb->user_buffer + ve->src_offset;
   assert(!vb->buffer);

   desc = util_format_description(ve->src_format);

   PUSH_SPACE(push, 6);
   BEGIN_NVC0(push, NVC0_3D(VTX_ATTR_DEFINE), 5);
   dst = &push->cur[1];
   if (desc->channel[0].pure_integer) {
      if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED) {
         mode = VTX_ATTR(a, 4, SINT, 32);
         desc->unpack_rgba_sint(dst, 0, src, 0, 1, 1);
      } else {
         mode = VTX_ATTR(a, 4, UINT, 32);
         desc->unpack_rgba_uint(dst, 0, src, 0, 1, 1);
      }
   } else {
      mode = VTX_ATTR(a, 4, FLOAT, 32);
      desc->unpack_rgba_float(dst, 0, src, 0, 1, 1);
   }
   push->cur[0] = mode;
   push->cur += 5;
d149 2
a150 2
nvc0_user_vbuf_range(struct nvc0_context *nvc0, int vbi,
                     uint32_t *base, uint32_t *size)
d153 3
a155 4
      const uint32_t div = nvc0->vertex->min_instance_div[vbi];
      *base = nvc0->instance_off * nvc0->vtxbuf[vbi].stride;
      *size = (nvc0->instance_max / div) * nvc0->vtxbuf[vbi].stride +
         nvc0->vertex->vb_access_size[vbi];
d157 4
a160 5
      /* NOTE: if there are user buffers, we *must* have index bounds */
      assert(nvc0->vb_elt_limit != ~0);
      *base = nvc0->vb_elt_first * nvc0->vtxbuf[vbi].stride;
      *size = nvc0->vb_elt_limit * nvc0->vtxbuf[vbi].stride +
         nvc0->vertex->vb_access_size[vbi];
d164 2
a165 2
static INLINE void
nvc0_release_user_vbufs(struct nvc0_context *nvc0)
d167 34
a200 3
   if (nvc0->vbo_user) {
      nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_VTX_TMP);
      nouveau_scratch_done(&nvc0->base);
d207 2
a208 2
   uint64_t address[PIPE_MAX_ATTRIBS];
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
a211 1
   PUSH_SPACE(push, nvc0->vertex->num_elements * 8);
d214 1
a214 1
      const unsigned b = ve->vertex_buffer_index;
d216 1
a216 1
      uint32_t base, size;
d220 1
d222 1
a222 1
         nvc0_set_constant_vertex_attrib(nvc0, i);
d225 1
a225 1
      nvc0_user_vbuf_range(nvc0, b, &base, &size);
a227 2
         struct nouveau_bo *bo;
         const uint32_t bo_flags = NOUVEAU_BO_RD | NOUVEAU_BO_GART;
d229 1
a229 6
         address[b] = nouveau_scratch_data(&nvc0->base, vb->user_buffer,
                                           base, size, &bo);
         if (bo)
            BCTX_REFN_bo(nvc0->bufctx_3d, VTX_TMP, bo_flags, bo);

         NOUVEAU_DRV_STAT(&nvc0->screen->base, user_buffer_upload_bytes, size);
d231 1
d233 7
a239 6
      BEGIN_1IC0(push, NVC0_3D(MACRO_VERTEX_ARRAY_SELECT), 5);
      PUSH_DATA (push, i);
      PUSH_DATAh(push, address[b] + base + size - 1);
      PUSH_DATA (push, address[b] + base + size - 1);
      PUSH_DATAh(push, address[b] + ve->src_offset);
      PUSH_DATA (push, address[b] + ve->src_offset);
d244 2
a245 2
static void
nvc0_update_user_vbufs_shared(struct nvc0_context *nvc0)
d247 1
a247 2
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   uint32_t mask = nvc0->vbo_user & ~nvc0->constant_vbos;
d249 3
a251 55
   PUSH_SPACE(push, nvc0->num_vtxbufs * 8);
   while (mask) {
      struct nouveau_bo *bo;
      const uint32_t bo_flags = NOUVEAU_BO_RD | NOUVEAU_BO_GART;
      uint64_t address;
      uint32_t base, size;
      const int b = ffs(mask) - 1;
      mask &= ~(1 << b);

      nvc0_user_vbuf_range(nvc0, b, &base, &size);

      address = nouveau_scratch_data(&nvc0->base, nvc0->vtxbuf[b].user_buffer,
                                     base, size, &bo);
      if (bo)
         BCTX_REFN_bo(nvc0->bufctx_3d, VTX_TMP, bo_flags, bo);

      BEGIN_1IC0(push, NVC0_3D(MACRO_VERTEX_ARRAY_SELECT), 5);
      PUSH_DATA (push, b);
      PUSH_DATAh(push, address + base + size - 1);
      PUSH_DATA (push, address + base + size - 1);
      PUSH_DATAh(push, address);
      PUSH_DATA (push, address);

      NOUVEAU_DRV_STAT(&nvc0->screen->base, user_buffer_upload_bytes, size);
   }

   mask = nvc0->state.constant_elts;
   while (mask) {
      int i = ffs(mask) - 1;
      mask &= ~(1 << i);
      nvc0_set_constant_vertex_attrib(nvc0, i);
   }
}

static void
nvc0_validate_vertex_buffers(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   const struct nvc0_vertex_stateobj *vertex = nvc0->vertex;
   uint32_t refd = 0;
   unsigned i;

   PUSH_SPACE(push, vertex->num_elements * 8);
   for (i = 0; i < vertex->num_elements; ++i) {
      const struct nvc0_vertex_element *ve;
      const struct pipe_vertex_buffer *vb;
      struct nv04_resource *res;
      unsigned b;
      unsigned limit, offset;

      if (nvc0->state.constant_elts & (1 << i))
         continue;
      ve = &vertex->element[i];
      b = ve->pipe.vertex_buffer_index;
      vb = &nvc0->vtxbuf[b];
d253 1
a253 36
      if (!vb->buffer) {
         if (vb->stride) {
            if (ve->pipe.instance_divisor) {
               BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_DIVISOR(i)), 1);
               PUSH_DATA (push, ve->pipe.instance_divisor);
            }
            BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 1);
            PUSH_DATA (push, (1 << 12) | vb->stride);
         }
         /* address/value set in nvc0_update_user_vbufs */
         continue;
      }
      res = nv04_resource(vb->buffer);
      offset = ve->pipe.src_offset + vb->buffer_offset;
      limit = vb->buffer->width0 - 1;

      if (unlikely(ve->pipe.instance_divisor)) {
         BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 4);
         PUSH_DATA (push, (1 << 12) | vb->stride);
         PUSH_DATAh(push, res->address + offset);
         PUSH_DATA (push, res->address + offset);
         PUSH_DATA (push, ve->pipe.instance_divisor);
      } else {
         BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 3);
         PUSH_DATA (push, (1 << 12) | vb->stride);
         PUSH_DATAh(push, res->address + offset);
         PUSH_DATA (push, res->address + offset);
      }
      BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_LIMIT_HIGH(i)), 2);
      PUSH_DATAh(push, res->address + limit);
      PUSH_DATA (push, res->address + limit);

      if (!(refd & (1 << b))) {
         refd |= 1 << b;
         BCTX_REFN(nvc0->bufctx_3d, VTX, res, RD);
      }
a254 41
   if (nvc0->vbo_user)
      nvc0_update_user_vbufs(nvc0);
}

static void
nvc0_validate_vertex_buffers_shared(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   unsigned b;
   const uint32_t mask = nvc0->vbo_user;

   PUSH_SPACE(push, nvc0->num_vtxbufs * 8);
   for (b = 0; b < nvc0->num_vtxbufs; ++b) {
      struct pipe_vertex_buffer *vb = &nvc0->vtxbuf[b];
      struct nv04_resource *buf;
      uint32_t offset, limit;

      if (mask & (1 << b)) {
         if (vb->stride) {
            BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(b)), 1);
            PUSH_DATA (push, NVC0_3D_VERTEX_ARRAY_FETCH_ENABLE | vb->stride);
         }
         /* address/value set in nvc0_update_user_vbufs_shared */
         continue;
      }
      buf = nv04_resource(vb->buffer);
      offset = vb->buffer_offset;
      limit = buf->base.width0 - 1;

      BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(b)), 3);
      PUSH_DATA (push, NVC0_3D_VERTEX_ARRAY_FETCH_ENABLE | vb->stride);
      PUSH_DATAh(push, buf->address + offset);
      PUSH_DATA (push, buf->address + offset);
      BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_LIMIT_HIGH(b)), 2);
      PUSH_DATAh(push, buf->address + limit);
      PUSH_DATA (push, buf->address + limit);

      BCTX_REFN(nvc0->bufctx_3d, VTX, buf, RD);
   }
   if (nvc0->vbo_user)
      nvc0_update_user_vbufs_shared(nvc0);
d260 1
a260 1
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d262 1
a263 1
   uint32_t const_vbos;
a264 2
   uint8_t vbo_mode;
   boolean update_vertex;
d266 3
a268 5
   nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_VTX);

   if (unlikely(vertex->need_conversion) ||
       unlikely(nvc0->vertprog->vp.edgeflag < PIPE_MAX_ATTRIBS)) {
      vbo_mode = 3;
d270 1
a270 1
      vbo_mode = (nvc0->vbo_user && nvc0->vbo_push_hint) ? 1 : 0;
a271 1
   const_vbos = vbo_mode ? 0 : nvc0->constant_vbos;
d273 4
a276 21
   update_vertex = (nvc0->dirty & NVC0_NEW_VERTEX) ||
      (const_vbos != nvc0->state.constant_vbos) ||
      (vbo_mode != nvc0->state.vbo_mode);

   if (update_vertex) {
      const unsigned n = MAX2(vertex->num_elements, nvc0->state.num_vtxelts);

      nvc0->state.constant_vbos = const_vbos;
      nvc0->state.constant_elts = 0;
      nvc0->state.num_vtxelts = vertex->num_elements;
      nvc0->state.vbo_mode = vbo_mode;

      if (unlikely(vbo_mode)) {
         if (unlikely(nvc0->state.instance_elts & 3)) {
            /* translate mode uses only 2 vertex buffers */
            nvc0->state.instance_elts &= ~3;
            PUSH_SPACE(push, 3);
            BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_PER_INSTANCE(0)), 2);
            PUSH_DATA (push, 0);
            PUSH_DATA (push, 0);
         }
d278 2
a279 12
         PUSH_SPACE(push, n * 2 + 4);

         BEGIN_NVC0(push, NVC0_3D(VERTEX_ATTRIB_FORMAT(0)), n);
         for (i = 0; i < vertex->num_elements; ++i)
            PUSH_DATA(push, vertex->element[i].state_alt);
         for (; i < n; ++i)
            PUSH_DATA(push, NVC0_3D_VERTEX_ATTRIB_INACTIVE);

         BEGIN_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(0)), 1);
         PUSH_DATA (push, (1 << 12) | vertex->size);
         for (i = 1; i < n; ++i)
            IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 0);
d281 4
a284 1
         uint32_t *restrict data;
d286 6
a291 8
         if (unlikely(vertex->instance_elts != nvc0->state.instance_elts)) {
            nvc0->state.instance_elts = vertex->instance_elts;
            assert(n); /* if (n == 0), both masks should be 0 */
            PUSH_SPACE(push, 3);
            BEGIN_NVC0(push, NVC0_3D(MACRO_VERTEX_ARRAY_PER_INSTANCE), 2);
            PUSH_DATA (push, n);
            PUSH_DATA (push, vertex->instance_elts);
         }
d293 3
a295 16
         PUSH_SPACE(push, n * 2 + 1);
         BEGIN_NVC0(push, NVC0_3D(VERTEX_ATTRIB_FORMAT(0)), n);
         data = push->cur;
         push->cur += n;
         for (i = 0; i < vertex->num_elements; ++i) {
            ve = &vertex->element[i];
            data[i] = ve->state;
            if (unlikely(const_vbos & (1 << ve->pipe.vertex_buffer_index))) {
               nvc0->state.constant_elts |= 1 << i;
               data[i] |= NVC0_3D_VERTEX_ATTRIB_FORMAT_CONST;
               IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 0);
            }
         }
         for (; i < n; ++i) {
            data[i] = NVC0_3D_VERTEX_ATTRIB_INACTIVE;
            IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FETCH(i)), 0);
d297 5
a302 3
   }
   if (nvc0->state.vbo_mode) /* using translate, don't set up arrays here */
      return;
d304 1
a304 5
   if (vertex->shared_slots)
      nvc0_validate_vertex_buffers_shared(nvc0);
   else
      nvc0_validate_vertex_buffers(nvc0);
}
d306 7
a312 5
void
nvc0_idxbuf_validate(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nv04_resource *buf = nv04_resource(nvc0->idxbuf.buffer);
d314 2
a315 2
   assert(buf);
   assert(nouveau_resource_mapped_by_gpu(&buf->base));
d317 16
a332 7
   PUSH_SPACE(push, 6);
   BEGIN_NVC0(push, NVC0_3D(INDEX_ARRAY_START_HIGH), 5);
   PUSH_DATAh(push, buf->address + nvc0->idxbuf.offset);
   PUSH_DATA (push, buf->address + nvc0->idxbuf.offset);
   PUSH_DATAh(push, buf->address + buf->base.width0 - 1);
   PUSH_DATA (push, buf->address + buf->base.width0 - 1);
   PUSH_DATA (push, nvc0->idxbuf.index_size >> 1);
d334 2
a335 1
   BCTX_REFN(nvc0->bufctx_3d, IDX, buf, RD);
d363 1
d368 1
a368 1
nvc0_draw_vbo_kick_notify(struct nouveau_pushbuf *push)
d370 1
a370 1
   struct nvc0_screen *screen = push->user_priv;
d374 1
a374 1
   NOUVEAU_DRV_STAT(&screen->base, pushbuf_count, 1);
d382 1
a382 1
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
a384 6
   if (nvc0->state.index_bias) {
      PUSH_SPACE(push, 1);
      IMMED_NVC0(push, NVC0_3D(VB_ELEMENT_BASE), 0);
      nvc0->state.index_bias = 0;
   }

d388 6
a393 7
      PUSH_SPACE(push, 6);
      BEGIN_NVC0(push, NVC0_3D(VERTEX_BEGIN_GL), 1);
      PUSH_DATA (push, prim);
      BEGIN_NVC0(push, NVC0_3D(VERTEX_BUFFER_FIRST), 2);
      PUSH_DATA (push, start);
      PUSH_DATA (push, count);
      IMMED_NVC0(push, NVC0_3D(VERTEX_END_GL), 0);
a396 1
   NOUVEAU_DRV_STAT(&nvc0->screen->base, draw_calls_array, 1);
d400 1
a400 1
nvc0_draw_elements_inline_u08(struct nouveau_pushbuf *push, const uint8_t *map,
d407 1
a407 2
      PUSH_SPACE(push, 4);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U32), count & 3);
d409 1
a409 1
         PUSH_DATA(push, *map++);
d415 1
a415 2
      PUSH_SPACE(push, nr + 1);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U8), nr);
d417 1
a417 1
         PUSH_DATA(push,
d426 1
a426 1
nvc0_draw_elements_inline_u16(struct nouveau_pushbuf *push, const uint16_t *map,
d433 2
a434 3
      PUSH_SPACE(push, 2);
      BEGIN_NVC0(push, NVC0_3D(VB_ELEMENT_U32), 1);
      PUSH_DATA (push, *map++);
d439 1
a439 2
      PUSH_SPACE(push, nr + 1);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U16), nr);
d441 1
a441 1
         PUSH_DATA(push, (map[1] << 16) | map[0]);
d449 1
a449 1
nvc0_draw_elements_inline_u32(struct nouveau_pushbuf *push, const uint32_t *map,
d457 2
a458 3
      PUSH_SPACE(push, nr + 1);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U32), nr);
      PUSH_DATAp(push, map, nr);
d466 1
a466 2
nvc0_draw_elements_inline_u32_short(struct nouveau_pushbuf *push,
                                    const uint32_t *map,
d473 2
a474 3
      PUSH_SPACE(push, 1);
      BEGIN_NVC0(push, NVC0_3D(VB_ELEMENT_U32), 1);
      PUSH_DATA (push, *map++);
d479 1
a479 2
      PUSH_SPACE(push, nr + 1);
      BEGIN_NIC0(push, NVC0_3D(VB_ELEMENT_U16), nr);
d481 1
a481 1
         PUSH_DATA(push, (map[1] << 16) | map[0]);
d493 2
a494 1
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
d501 2
a502 3
      PUSH_SPACE(push, 2);
      BEGIN_NVC0(push, NVC0_3D(VB_ELEMENT_BASE), 1);
      PUSH_DATA (push, index_bias);
d506 25
a530 15
   if (nvc0->idxbuf.buffer) {
      PUSH_SPACE(push, 1);
      IMMED_NVC0(push, NVC0_3D(VERTEX_BEGIN_GL), prim);
      do {
         PUSH_SPACE(push, 7);
         BEGIN_NVC0(push, NVC0_3D(INDEX_BATCH_FIRST), 2);
         PUSH_DATA (push, start);
         PUSH_DATA (push, count);
         if (--instance_count) {
            BEGIN_NVC0(push, NVC0_3D(VERTEX_END_GL), 2);
            PUSH_DATA (push, 0);
            PUSH_DATA (push, prim | NVC0_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT);
         }
      } while (instance_count);
      IMMED_NVC0(push, NVC0_3D(VERTEX_END_GL), 0);
d532 5
a536 1
      const void *data = nvc0->idxbuf.user_buffer;
d539 2
a540 3
         PUSH_SPACE(push, 2);
         BEGIN_NVC0(push, NVC0_3D(VERTEX_BEGIN_GL), 1);
         PUSH_DATA (push, prim);
d543 1
a543 1
            nvc0_draw_elements_inline_u08(push, data, start, count);
d546 1
a546 1
            nvc0_draw_elements_inline_u16(push, data, start, count);
d550 1
a550 1
               nvc0_draw_elements_inline_u32_short(push, data, start, count);
d552 1
a552 1
               nvc0_draw_elements_inline_u32(push, data, start, count);
d558 1
a558 2
         PUSH_SPACE(push, 1);
         IMMED_NVC0(push, NVC0_3D(VERTEX_END_GL), 0);
a562 37
   NOUVEAU_DRV_STAT(&nvc0->screen->base, draw_calls_indexed, 1);
}

static void
nvc0_draw_stream_output(struct nvc0_context *nvc0,
                        const struct pipe_draw_info *info)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nvc0_so_target *so = nvc0_so_target(info->count_from_stream_output);
   struct nv04_resource *res = nv04_resource(so->pipe.buffer);
   unsigned mode = nvc0_prim_gl(info->mode);
   unsigned num_instances = info->instance_count;

   if (res->status & NOUVEAU_BUFFER_STATUS_GPU_WRITING) {
      res->status &= ~NOUVEAU_BUFFER_STATUS_GPU_WRITING;
      PUSH_SPACE(push, 2);
      IMMED_NVC0(push, NVC0_3D(SERIALIZE), 0);
      nvc0_query_fifo_wait(push, so->pq);
      IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FLUSH), 0);

      NOUVEAU_DRV_STAT(&nvc0->screen->base, gpu_serialize_count, 1);
   }

   while (num_instances--) {
      PUSH_SPACE(push, 8);
      BEGIN_NVC0(push, NVC0_3D(VERTEX_BEGIN_GL), 1);
      PUSH_DATA (push, mode);
      BEGIN_NVC0(push, NVC0_3D(DRAW_TFB_BASE), 1);
      PUSH_DATA (push, 0);
      BEGIN_NVC0(push, NVC0_3D(DRAW_TFB_STRIDE), 1);
      PUSH_DATA (push, so->stride);
      BEGIN_NVC0(push, NVC0_3D(DRAW_TFB_BYTES), 1);
      nvc0_query_pushbuf_submit(push, so->pq, 0x4);
      IMMED_NVC0(push, NVC0_3D(VERTEX_END_GL), 0);

      mode |= NVC0_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT;
   }
d569 1
a569 7
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;

   /* NOTE: caller must ensure that (min_index + index_bias) is >= 0 */
   nvc0->vb_elt_first = info->min_index + info->index_bias;
   nvc0->vb_elt_limit = info->max_index - info->min_index;
   nvc0->instance_off = info->start_instance;
   nvc0->instance_max = info->instance_count - 1;
d574 3
a576 2
   nvc0->vbo_push_hint =
      info->indexed && (nvc0->vb_elt_limit >= (info->count * 2));
d578 2
a579 5
   /* Check whether we want to switch vertex-submission mode. */
   if (nvc0->vbo_user && !(nvc0->dirty & (NVC0_NEW_ARRAYS | NVC0_NEW_VERTEX))) {
      if (nvc0->vbo_push_hint != !!nvc0->state.vbo_mode)
         if (nvc0->state.vbo_mode != 3)
            nvc0->dirty |= NVC0_NEW_ARRAYS;
d581 5
a585 7
      if (!(nvc0->dirty & NVC0_NEW_ARRAYS) && nvc0->state.vbo_mode == 0) {
         if (nvc0->vertex->shared_slots)
            nvc0_update_user_vbufs_shared(nvc0);
         else
            nvc0_update_user_vbufs(nvc0);
      }
   }
d587 1
a587 2
   /* 8 as minimum to avoid immediate double validation of new buffers */
   nvc0_state_validate(nvc0, ~0, 8);
d589 1
a589 1
   push->kick_notify = nvc0_draw_vbo_kick_notify;
d591 1
a591 1
   if (nvc0->state.vbo_mode) {
d593 1
a593 1
      push->kick_notify = nvc0_default_kick_notify;
a596 3
   /* space for base instance, flush, and prim restart */
   PUSH_SPACE(push, 8);

d600 2
a601 2
      BEGIN_NVC0(push, NVC0_3D(VB_INSTANCE_BASE), 1);
      PUSH_DATA (push, info->start_instance);
d605 2
a606 1
      IMMED_NVC0(push, NVC0_3D(VERTEX_ARRAY_FLUSH), 0);
d610 5
a614 1
   if (info->indexed) {
d617 2
d621 3
a623 3
            BEGIN_NVC0(push, NVC0_3D(PRIM_RESTART_ENABLE), 2);
            PUSH_DATA (push, 1);
            PUSH_DATA (push, info->restart_index);
d628 1
a628 1
            IMMED_NVC0(push, NVC0_3D(PRIM_RESTART_ENABLE), 0);
d633 2
a634 2
         BEGIN_NVC0(push, NVC0_3D(PRIM_RESTART_INDEX), 1);
         PUSH_DATA (push, info->restart_index);
a642 7
   } else
   if (unlikely(info->count_from_stream_output)) {
      nvc0_draw_stream_output(nvc0, info);
   } else {
      nvc0_draw_arrays(nvc0,
                       info->mode, info->start, info->count,
                       info->instance_count);
d644 1
a644 1
   push->kick_notify = nvc0_default_kick_notify;
@

