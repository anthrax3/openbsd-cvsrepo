head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.00.48;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@
#ifndef __NVC0_STATEOBJ_H__
#define __NVC0_STATEOBJ_H__

#include "pipe/p_state.h"

#define SB_BEGIN_3D(so, m, s)                                                  \
   (so)->state[(so)->size++] = NVC0_FIFO_PKHDR_SQ(NVC0_3D(m), s)

#define SB_IMMED_3D(so, m, d)                                                  \
   (so)->state[(so)->size++] = NVC0_FIFO_PKHDR_IL(NVC0_3D(m), d)

#define SB_DATA(so, u) (so)->state[(so)->size++] = (u)

#include "nv50/nv50_stateobj_tex.h"

struct nvc0_blend_stateobj {
   struct pipe_blend_state pipe;
   int size;
   uint32_t state[72];
};

struct nvc0_rasterizer_stateobj {
   struct pipe_rasterizer_state pipe;
   int size;
   uint32_t state[43];
};

struct nvc0_zsa_stateobj {
   struct pipe_depth_stencil_alpha_state pipe;
   int size;
   uint32_t state[26];
};

struct nvc0_constbuf {
   union {
      struct pipe_resource *buf;
      const void *data;
   } u;
   uint32_t size;
   uint32_t offset;
   boolean user; /* should only be TRUE if u.data is valid and non-NULL */
};

struct nvc0_vertex_element {
   struct pipe_vertex_element pipe;
   uint32_t state;
   uint32_t state_alt; /* buffer 0 and with source offset (for translate) */
};

struct nvc0_vertex_stateobj {
   uint32_t min_instance_div[PIPE_MAX_ATTRIBS];
   uint16_t vb_access_size[PIPE_MAX_ATTRIBS];
   struct translate *translate;
   unsigned num_elements;
   uint32_t instance_elts;
   uint32_t instance_bufs;
   boolean shared_slots;
   boolean need_conversion; /* e.g. VFETCH cannot convert f64 to f32 */
   unsigned size; /* size of vertex in bytes (when packed) */
   struct nvc0_vertex_element element[0];
};

struct nvc0_so_target {
   struct pipe_stream_output_target pipe;
   struct pipe_query *pq;
   unsigned stride;
   boolean clean;
};

static INLINE struct nvc0_so_target *
nvc0_so_target(struct pipe_stream_output_target *ptarg)
{
   return (struct nvc0_so_target *)ptarg;
}

#endif
@


1.2
log
@Merge Mesa 9.2.0
@
text
@@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d8 1
a8 2
   (so)->state[(so)->size++] =                                                 \
      (0x2 << 28) | ((s) << 16) | (NVC0_SUBCH_3D << 13) | ((NVC0_3D_##m) >> 2)
d11 1
a11 2
   (so)->state[(so)->size++] =                                                 \
      (0x8 << 28) | ((d) << 16) | (NVC0_SUBCH_3D << 13) | ((NVC0_3D_##m) >> 2)
d20 1
a20 1
   uint32_t state[70];
d26 1
a26 1
   uint32_t state[38];
d35 10
d48 1
d52 2
d58 1
d60 1
a60 2
   unsigned vtx_size;
   unsigned vtx_per_packet_max;
d64 5
a68 5
/* will have to lookup index -> location qualifier from nvc0_program */
struct nvc0_transform_feedback_state {
   uint32_t stride[4];
   uint8_t varying_count[4];
   uint8_t varying_index[0];
d70 6
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d8 2
a9 1
   (so)->state[(so)->size++] = NVC0_FIFO_PKHDR_SQ(NVC0_3D(m), s)
d12 2
a13 1
   (so)->state[(so)->size++] = NVC0_FIFO_PKHDR_IL(NVC0_3D(m), d)
d22 1
a22 1
   uint32_t state[72];
d28 1
a28 1
   uint32_t state[43];
a36 10
struct nvc0_constbuf {
   union {
      struct pipe_resource *buf;
      const void *data;
   } u;
   uint32_t size;
   uint32_t offset;
   boolean user; /* should only be TRUE if u.data is valid and non-NULL */
};

a39 1
   uint32_t state_alt; /* buffer 0 and with source offset (for translate) */
a42 2
   uint32_t min_instance_div[PIPE_MAX_ATTRIBS];
   uint16_t vb_access_size[PIPE_MAX_ATTRIBS];
a46 1
   boolean shared_slots;
d48 2
a49 1
   unsigned size; /* size of vertex in bytes (when packed) */
d53 5
a57 5
struct nvc0_so_target {
   struct pipe_stream_output_target pipe;
   struct pipe_query *pq;
   unsigned stride;
   boolean clean;
a58 6

static INLINE struct nvc0_so_target *
nvc0_so_target(struct pipe_stream_output_target *ptarg)
{
   return (struct nvc0_so_target *)ptarg;
}
@

