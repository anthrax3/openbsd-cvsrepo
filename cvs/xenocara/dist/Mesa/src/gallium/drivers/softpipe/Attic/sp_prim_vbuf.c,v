head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.01.05;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.52;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * Interface between 'draw' module's output and the softpipe rasterizer/setup
 * code.  When the 'draw' module has finished filling a vertex buffer, the
 * draw_arrays() functions below will be called.  Loop over the vertices and
 * call the point/line/tri setup functions.
 *
 * Authors
 *  Brian Paul
 */


#include "sp_context.h"
#include "sp_setup.h"
#include "sp_state.h"
#include "sp_prim_vbuf.h"
#include "draw/draw_context.h"
#include "draw/draw_vbuf.h"
#include "util/u_memory.h"
#include "util/u_prim.h"


#define SP_MAX_VBUF_INDEXES 1024
#define SP_MAX_VBUF_SIZE    4096

typedef const float (*cptrf4)[4];

/**
 * Subclass of vbuf_render.
 */
struct softpipe_vbuf_render
{
   struct vbuf_render base;
   struct softpipe_context *softpipe;
   struct setup_context *setup;

   uint prim;
   uint vertex_size;
   uint nr_vertices;
   uint vertex_buffer_size;
   void *vertex_buffer;
};


/** cast wrapper */
static struct softpipe_vbuf_render *
softpipe_vbuf_render(struct vbuf_render *vbr)
{
   return (struct softpipe_vbuf_render *) vbr;
}


/** This tells the draw module about our desired vertex layout */
static const struct vertex_info *
sp_vbuf_get_vertex_info(struct vbuf_render *vbr)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   return softpipe_get_vbuf_vertex_info(cvbr->softpipe);
}


static boolean
sp_vbuf_allocate_vertices(struct vbuf_render *vbr,
                          ushort vertex_size, ushort nr_vertices)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   unsigned size = vertex_size * nr_vertices;

   if (cvbr->vertex_buffer_size < size) {
      align_free(cvbr->vertex_buffer);
      cvbr->vertex_buffer = align_malloc(size, 16);
      cvbr->vertex_buffer_size = size;
   }

   cvbr->vertex_size = vertex_size;
   cvbr->nr_vertices = nr_vertices;
   
   return cvbr->vertex_buffer != NULL;
}


static void
sp_vbuf_release_vertices(struct vbuf_render *vbr)
{
   /* keep the old allocation for next time */
}


static void *
sp_vbuf_map_vertices(struct vbuf_render *vbr)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   return cvbr->vertex_buffer;
}


static void 
sp_vbuf_unmap_vertices(struct vbuf_render *vbr, 
                       ushort min_index,
                       ushort max_index )
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   assert( cvbr->vertex_buffer_size >= (max_index+1) * cvbr->vertex_size );
   (void) cvbr;
   /* do nothing */
}


static void
sp_vbuf_set_primitive(struct vbuf_render *vbr, unsigned prim)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   struct setup_context *setup_ctx = cvbr->setup;
   
   sp_setup_prepare( setup_ctx );

   cvbr->softpipe->reduced_prim = u_reduced_prim(prim);
   cvbr->prim = prim;
}


static INLINE cptrf4 get_vert( const void *vertex_buffer,
                               int index,
                               int stride )
{
   return (cptrf4)((char *)vertex_buffer + index * stride);
}


/**
 * draw elements / indexed primitives
 */
static void
sp_vbuf_draw_elements(struct vbuf_render *vbr, const ushort *indices, uint nr)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   struct softpipe_context *softpipe = cvbr->softpipe;
   const unsigned stride = softpipe->vertex_info_vbuf.size * sizeof(float);
   const void *vertex_buffer = cvbr->vertex_buffer;
   struct setup_context *setup = cvbr->setup;
   const boolean flatshade_first = softpipe->rasterizer->flatshade_first;
   unsigned i;

   switch (cvbr->prim) {
   case PIPE_PRIM_POINTS:
      for (i = 0; i < nr; i++) {
         sp_setup_point( setup,
                         get_vert(vertex_buffer, indices[i-0], stride) );
      }
      break;

   case PIPE_PRIM_LINES:
      for (i = 1; i < nr; i += 2) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, indices[i-1], stride),
                        get_vert(vertex_buffer, indices[i-0], stride) );
      }
      break;

   case PIPE_PRIM_LINE_STRIP:
      for (i = 1; i < nr; i ++) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, indices[i-1], stride),
                        get_vert(vertex_buffer, indices[i-0], stride) );
      }
      break;

   case PIPE_PRIM_LINE_LOOP:
      for (i = 1; i < nr; i ++) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, indices[i-1], stride),
                        get_vert(vertex_buffer, indices[i-0], stride) );
      }
      if (nr) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, indices[nr-1], stride),
                        get_vert(vertex_buffer, indices[0], stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLES:
      for (i = 2; i < nr; i += 3) {
         sp_setup_tri( setup,
                       get_vert(vertex_buffer, indices[i-2], stride),
                       get_vert(vertex_buffer, indices[i-1], stride),
                       get_vert(vertex_buffer, indices[i-0], stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLE_STRIP:
      if (flatshade_first) {
         for (i = 2; i < nr; i += 1) {
            /* emit first triangle vertex as first triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i+(i&1)-1], stride),
                          get_vert(vertex_buffer, indices[i-(i&1)], stride) );

         }
      }
      else {
         for (i = 2; i < nr; i += 1) {
            /* emit last triangle vertex as last triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i+(i&1)-2], stride),
                          get_vert(vertex_buffer, indices[i-(i&1)-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      break;

   case PIPE_PRIM_TRIANGLE_FAN:
      if (flatshade_first) {
         for (i = 2; i < nr; i += 1) {
            /* emit first non-spoke vertex as first vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[0], stride) );
         }
      }
      else {
         for (i = 2; i < nr; i += 1) {
            /* emit last non-spoke vertex as last vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[0], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      break;

   case PIPE_PRIM_QUADS:
      /* GL quads don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
         for (i = 3; i < nr; i += 4) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride) );

            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-1], stride) );
         }
      }
      else {
         /* emit last quad vertex as last triangle vertex */
         for (i = 3; i < nr; i += 4) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );

            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      break;

   case PIPE_PRIM_QUAD_STRIP:
      /* GL quad strips don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
         for (i = 3; i < nr; i += 2) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-3], stride) );
         }
      }
      else {
         /* emit last quad vertex as last triangle vertex */
         for (i = 3; i < nr; i += 2) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      break;

   case PIPE_PRIM_POLYGON:
      /* Almost same as tri fan but the _first_ vertex specifies the flat
       * shading color.
       */
      if (flatshade_first) { 
         /* emit first polygon  vertex as first triangle vertex */
         for (i = 2; i < nr; i += 1) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[0], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      else {
         /* emit first polygon  vertex as last triangle vertex */
         for (i = 2; i < nr; i += 1) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[0], stride) );
         }
      }
      break;

   default:
      assert(0);
   }
}


/**
 * This function is hit when the draw module is working in pass-through mode.
 * It's up to us to convert the vertex array into point/line/tri prims.
 */
static void
sp_vbuf_draw_arrays(struct vbuf_render *vbr, uint start, uint nr)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   struct softpipe_context *softpipe = cvbr->softpipe;
   struct setup_context *setup = cvbr->setup;
   const unsigned stride = softpipe->vertex_info_vbuf.size * sizeof(float);
   const void *vertex_buffer =
      (void *) get_vert(cvbr->vertex_buffer, start, stride);
   const boolean flatshade_first = softpipe->rasterizer->flatshade_first;
   unsigned i;

   switch (cvbr->prim) {
   case PIPE_PRIM_POINTS:
      for (i = 0; i < nr; i++) {
         sp_setup_point( setup,
                         get_vert(vertex_buffer, i-0, stride) );
      }
      break;

   case PIPE_PRIM_LINES:
      for (i = 1; i < nr; i += 2) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, i-1, stride),
                        get_vert(vertex_buffer, i-0, stride) );
      }
      break;

   case PIPE_PRIM_LINES_ADJACENCY:
      for (i = 3; i < nr; i += 4) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, i-2, stride),
                        get_vert(vertex_buffer, i-1, stride) );
      }
      break;

   case PIPE_PRIM_LINE_STRIP:
      for (i = 1; i < nr; i ++) {
         sp_setup_line( setup,
                     get_vert(vertex_buffer, i-1, stride),
                     get_vert(vertex_buffer, i-0, stride) );
      }
      break;

   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      for (i = 3; i < nr; i++) {
         sp_setup_line( setup,
                     get_vert(vertex_buffer, i-2, stride),
                     get_vert(vertex_buffer, i-1, stride) );
      }
      break;

   case PIPE_PRIM_LINE_LOOP:
      for (i = 1; i < nr; i ++) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, i-1, stride),
                        get_vert(vertex_buffer, i-0, stride) );
      }
      if (nr) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, nr-1, stride),
                        get_vert(vertex_buffer, 0, stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLES:
      for (i = 2; i < nr; i += 3) {
         sp_setup_tri( setup,
                       get_vert(vertex_buffer, i-2, stride),
                       get_vert(vertex_buffer, i-1, stride),
                       get_vert(vertex_buffer, i-0, stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLES_ADJACENCY:
      for (i = 5; i < nr; i += 6) {
         sp_setup_tri( setup,
                       get_vert(vertex_buffer, i-5, stride),
                       get_vert(vertex_buffer, i-3, stride),
                       get_vert(vertex_buffer, i-1, stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLE_STRIP:
      if (flatshade_first) {
         for (i = 2; i < nr; i++) {
            /* emit first triangle vertex as first triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i+(i&1)-1, stride),
                          get_vert(vertex_buffer, i-(i&1), stride) );
         }
      }
      else {
         for (i = 2; i < nr; i++) {
            /* emit last triangle vertex as last triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i+(i&1)-2, stride),
                          get_vert(vertex_buffer, i-(i&1)-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
         }
      }
      break;

   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      if (flatshade_first) {
         for (i = 5; i < nr; i += 2) {
            /* emit first triangle vertex as first triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-5, stride),
                          get_vert(vertex_buffer, i+(i&1)*2-3, stride),
                          get_vert(vertex_buffer, i-(i&1)*2-1, stride) );
         }
      }
      else {
         for (i = 5; i < nr; i += 2) {
            /* emit last triangle vertex as last triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i+(i&1)*2-5, stride),
                          get_vert(vertex_buffer, i-(i&1)*2-3, stride),
                          get_vert(vertex_buffer, i-1, stride) );
         }
      }
      break;

   case PIPE_PRIM_TRIANGLE_FAN:
      if (flatshade_first) {
         for (i = 2; i < nr; i += 1) {
            /* emit first non-spoke vertex as first vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, 0, stride)  );
         }
      }
      else {
         for (i = 2; i < nr; i += 1) {
            /* emit last non-spoke vertex as last vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, 0, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
         }
      }
      break;

   case PIPE_PRIM_QUADS:
      /* GL quads don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
         for (i = 3; i < nr; i += 4) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-2, stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-1, stride) );
         }
      }
      else {
         /* emit last quad vertex as last triangle vertex */
         for (i = 3; i < nr; i += 4) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-0, stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
         }
      }
      break;

   case PIPE_PRIM_QUAD_STRIP:
      /* GL quad strips don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
         for (i = 3; i < nr; i += 2) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-2, stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-3, stride) );
         }
      }
      else {
         /* emit last quad vertex as last triangle vertex */
         for (i = 3; i < nr; i += 2) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-0, stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-0, stride) );
         }
      }
      break;

   case PIPE_PRIM_POLYGON:
      /* Almost same as tri fan but the _first_ vertex specifies the flat
       * shading color.
       */
      if (flatshade_first) { 
         /* emit first polygon  vertex as first triangle vertex */
         for (i = 2; i < nr; i += 1) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, 0, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
         }
      }
      else {
         /* emit first polygon  vertex as last triangle vertex */
         for (i = 2; i < nr; i += 1) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, 0, stride) );
         }
      }
      break;

   default:
      assert(0);
   }
}

/*
 * FIXME: it is unclear if primitives_storage_needed (which is generally
 * the same as pipe query num_primitives_generated) should increase
 * if SO is disabled for d3d10, but for GL we definitely need to
 * increase num_primitives_generated and this is only called for active
 * SO. If it must not increase for d3d10 need to disambiguate the counters
 * in the driver and do some work for getting correct values, if it should
 * increase too should call this from outside streamout code.
 */
static void
sp_vbuf_so_info(struct vbuf_render *vbr, uint primitives, uint prim_generated)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   struct softpipe_context *softpipe = cvbr->softpipe;

   softpipe->so_stats.num_primitives_written += primitives;
   softpipe->so_stats.primitives_storage_needed += prim_generated;
}

static void
sp_vbuf_pipeline_statistics(
   struct vbuf_render *vbr, 
   const struct pipe_query_data_pipeline_statistics *stats)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   struct softpipe_context *softpipe = cvbr->softpipe;

   softpipe->pipeline_statistics.ia_vertices +=
      stats->ia_vertices;
   softpipe->pipeline_statistics.ia_primitives +=
      stats->ia_primitives;
   softpipe->pipeline_statistics.vs_invocations +=
      stats->vs_invocations;
   softpipe->pipeline_statistics.gs_invocations +=
      stats->gs_invocations;
   softpipe->pipeline_statistics.gs_primitives +=
      stats->gs_primitives;
   softpipe->pipeline_statistics.c_invocations +=
      stats->c_invocations;
}


static void
sp_vbuf_destroy(struct vbuf_render *vbr)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   if (cvbr->vertex_buffer)
      align_free(cvbr->vertex_buffer);
   sp_setup_destroy_context(cvbr->setup);
   FREE(cvbr);
}


/**
 * Create the post-transform vertex handler for the given context.
 */
struct vbuf_render *
sp_create_vbuf_backend(struct softpipe_context *sp)
{
   struct softpipe_vbuf_render *cvbr = CALLOC_STRUCT(softpipe_vbuf_render);

   assert(sp->draw);

   cvbr->base.max_indices = SP_MAX_VBUF_INDEXES;
   cvbr->base.max_vertex_buffer_bytes = SP_MAX_VBUF_SIZE;

   cvbr->base.get_vertex_info = sp_vbuf_get_vertex_info;
   cvbr->base.allocate_vertices = sp_vbuf_allocate_vertices;
   cvbr->base.map_vertices = sp_vbuf_map_vertices;
   cvbr->base.unmap_vertices = sp_vbuf_unmap_vertices;
   cvbr->base.set_primitive = sp_vbuf_set_primitive;
   cvbr->base.draw_elements = sp_vbuf_draw_elements;
   cvbr->base.draw_arrays = sp_vbuf_draw_arrays;
   cvbr->base.release_vertices = sp_vbuf_release_vertices;
   cvbr->base.set_stream_output_info = sp_vbuf_so_info;
   cvbr->base.pipeline_statistics = sp_vbuf_pipeline_statistics;
   cvbr->base.destroy = sp_vbuf_destroy;

   cvbr->softpipe = sp;

   cvbr->setup = sp_setup_create_context(cvbr->softpipe);

   return &cvbr->base;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d590 9
d600 1
a600 2
sp_vbuf_so_info(struct vbuf_render *vbr, uint primitives, uint vertices,
                uint prim_generated)
d606 1
a606 3
   softpipe->so_stats.primitives_storage_needed =
      vertices * 4 /*sizeof(float|int32)*/ * 4 /*x,y,z,w*/;
   softpipe->num_primitives_generated += prim_generated;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d135 1
a135 1
static boolean
a144 1
   return TRUE;
d383 8
d399 8
d429 9
d459 21
d591 2
a592 1
sp_vbuf_so_info(struct vbuf_render *vbr, uint primitives, uint vertices)
a595 1
   unsigned i;
d597 1
a597 5
   for (i = 0; i < softpipe->so_target.num_buffers; ++i) {
      softpipe->so_target.so_count[i] += vertices;
   }

   softpipe->so_stats.num_primitives_written = primitives;
d600 23
d659 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d79 1
a79 5





d107 1
d114 1
d122 1
a145 1

d161 1
a161 1
sp_vbuf_draw(struct vbuf_render *vbr, const ushort *indices, uint nr)
d167 2
a168 1
   struct setup_context *setup_ctx = cvbr->setup;
d174 2
a175 2
         sp_setup_point( setup_ctx,
                      get_vert(vertex_buffer, indices[i-0], stride) );
d181 3
a183 3
         sp_setup_line( setup_ctx,
                     get_vert(vertex_buffer, indices[i-1], stride),
                     get_vert(vertex_buffer, indices[i-0], stride) );
d189 3
a191 3
         sp_setup_line( setup_ctx,
                     get_vert(vertex_buffer, indices[i-1], stride),
                     get_vert(vertex_buffer, indices[i-0], stride) );
d197 3
a199 3
         sp_setup_line( setup_ctx,
                     get_vert(vertex_buffer, indices[i-1], stride),
                     get_vert(vertex_buffer, indices[i-0], stride) );
d202 3
a204 3
         sp_setup_line( setup_ctx,
                     get_vert(vertex_buffer, indices[nr-1], stride),
                     get_vert(vertex_buffer, indices[0], stride) );
d209 2
a210 11
      if (softpipe->rasterizer->flatshade_first) {
         for (i = 2; i < nr; i += 3) {
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-1], stride),
                       get_vert(vertex_buffer, indices[i-0], stride),
                       get_vert(vertex_buffer, indices[i-2], stride) );
         }
      }
      else {
         for (i = 2; i < nr; i += 3) {
            sp_setup_tri( setup_ctx,
a213 1
         }
d218 1
a218 1
      if (softpipe->rasterizer->flatshade_first) {
d220 6
a225 4
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i+(i&1)-1], stride),
                       get_vert(vertex_buffer, indices[i-(i&1)], stride),
                       get_vert(vertex_buffer, indices[i-2], stride) );
d230 5
a234 4
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i+(i&1)-2], stride),
                       get_vert(vertex_buffer, indices[i-(i&1)-1], stride),
                       get_vert(vertex_buffer, indices[i-0], stride) );
d240 1
a240 1
      if (softpipe->rasterizer->flatshade_first) {
d242 5
a246 4
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-0], stride),
                       get_vert(vertex_buffer, indices[0], stride),
                       get_vert(vertex_buffer, indices[i-1], stride) );
d251 5
a255 4
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[0], stride),
                       get_vert(vertex_buffer, indices[i-1], stride),
                       get_vert(vertex_buffer, indices[i-0], stride) );
d261 3
a263 1
      if (softpipe->rasterizer->flatshade_first) {
d265 9
a273 8
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-2], stride),
                       get_vert(vertex_buffer, indices[i-1], stride),
                       get_vert(vertex_buffer, indices[i-3], stride) );
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-1], stride),
                       get_vert(vertex_buffer, indices[i-0], stride),
                       get_vert(vertex_buffer, indices[i-3], stride) );
d277 1
d279 9
a287 9
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-3], stride),
                       get_vert(vertex_buffer, indices[i-2], stride),
                       get_vert(vertex_buffer, indices[i-0], stride) );

            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-2], stride),
                       get_vert(vertex_buffer, indices[i-1], stride),
                       get_vert(vertex_buffer, indices[i-0], stride) );
d293 3
a295 1
      if (softpipe->rasterizer->flatshade_first) {
d297 8
a304 8
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-0], stride),
                       get_vert(vertex_buffer, indices[i-1], stride),
                       get_vert(vertex_buffer, indices[i-3], stride));
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-2], stride),
                       get_vert(vertex_buffer, indices[i-0], stride),
                       get_vert(vertex_buffer, indices[i-3], stride) );
d308 1
d310 8
a317 8
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-3], stride),
                       get_vert(vertex_buffer, indices[i-2], stride),
                       get_vert(vertex_buffer, indices[i-0], stride) );
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, indices[i-1], stride),
                       get_vert(vertex_buffer, indices[i-3], stride),
                       get_vert(vertex_buffer, indices[i-0], stride) );
d324 1
a324 3
       * shading color.  Note that the first polygon vertex is passed as
       * the last triangle vertex here.
       * flatshade_first state makes no difference.
d326 17
a342 5
      for (i = 2; i < nr; i += 1) {
         sp_setup_tri( setup_ctx,
                    get_vert(vertex_buffer, indices[i-0], stride),
                    get_vert(vertex_buffer, indices[i-1], stride),
                    get_vert(vertex_buffer, indices[0], stride) );
d361 1
a361 1
   struct setup_context *setup_ctx = cvbr->setup;
d365 1
d371 2
a372 2
         sp_setup_point( setup_ctx,
                      get_vert(vertex_buffer, i-0, stride) );
d378 3
a380 3
         sp_setup_line( setup_ctx,
                     get_vert(vertex_buffer, i-1, stride),
                     get_vert(vertex_buffer, i-0, stride) );
d386 1
a386 1
         sp_setup_line( setup_ctx,
d394 3
a396 3
         sp_setup_line( setup_ctx,
                     get_vert(vertex_buffer, i-1, stride),
                     get_vert(vertex_buffer, i-0, stride) );
d399 3
a401 3
         sp_setup_line( setup_ctx,
                     get_vert(vertex_buffer, nr-1, stride),
                     get_vert(vertex_buffer, 0, stride) );
d406 2
a407 11
      if (softpipe->rasterizer->flatshade_first) {
         for (i = 2; i < nr; i += 3) {
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-1, stride),
                       get_vert(vertex_buffer, i-0, stride),
                       get_vert(vertex_buffer, i-2, stride) );
         }
      }
      else {
         for (i = 2; i < nr; i += 3) {
            sp_setup_tri( setup_ctx,
a410 1
         }
d415 1
a415 1
      if (softpipe->rasterizer->flatshade_first) {
d417 5
a421 4
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i+(i&1)-1, stride),
                       get_vert(vertex_buffer, i-(i&1), stride),
                       get_vert(vertex_buffer, i-2, stride) );
d426 5
a430 4
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i+(i&1)-2, stride),
                       get_vert(vertex_buffer, i-(i&1)-1, stride),
                       get_vert(vertex_buffer, i-0, stride) );
d436 1
a436 1
      if (softpipe->rasterizer->flatshade_first) {
d438 5
a442 4
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-0, stride),
                       get_vert(vertex_buffer, 0, stride),
                       get_vert(vertex_buffer, i-1, stride) );
d447 5
a451 4
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, 0, stride),
                       get_vert(vertex_buffer, i-1, stride),
                       get_vert(vertex_buffer, i-0, stride) );
d457 3
a459 1
      if (softpipe->rasterizer->flatshade_first) {
d461 8
a468 8
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-2, stride),
                       get_vert(vertex_buffer, i-1, stride),
                       get_vert(vertex_buffer, i-3, stride) );
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-1, stride),
                       get_vert(vertex_buffer, i-0, stride),
                       get_vert(vertex_buffer, i-3, stride) );
d472 1
d474 8
a481 8
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-3, stride),
                       get_vert(vertex_buffer, i-2, stride),
                       get_vert(vertex_buffer, i-0, stride) );
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-2, stride),
                       get_vert(vertex_buffer, i-1, stride),
                       get_vert(vertex_buffer, i-0, stride) );
d487 3
a489 1
      if (softpipe->rasterizer->flatshade_first) {
d491 8
a498 8
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-0, stride),
                       get_vert(vertex_buffer, i-1, stride),
                       get_vert(vertex_buffer, i-3, stride) );
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-2, stride),
                       get_vert(vertex_buffer, i-0, stride),
                       get_vert(vertex_buffer, i-3, stride) );
d502 1
d504 8
a511 8
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-3, stride),
                       get_vert(vertex_buffer, i-2, stride),
                       get_vert(vertex_buffer, i-0, stride) );
            sp_setup_tri( setup_ctx,
                       get_vert(vertex_buffer, i-1, stride),
                       get_vert(vertex_buffer, i-3, stride),
                       get_vert(vertex_buffer, i-0, stride) );
d518 1
a518 3
       * shading color.  Note that the first polygon vertex is passed as
       * the last triangle vertex here.
       * flatshade_first state makes no difference.
d520 17
a536 5
      for (i = 2; i < nr; i += 1) {
         sp_setup_tri( setup_ctx,
                    get_vert(vertex_buffer, i-1, stride),
                    get_vert(vertex_buffer, i-0, stride),
                    get_vert(vertex_buffer, 0, stride) );
d545 15
d566 1
a566 1
   if(cvbr->vertex_buffer)
d591 1
a591 1
   cvbr->base.draw = sp_vbuf_draw;
d594 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d79 5
a83 1
/** This tells the draw module about our desired vertex layout */
a110 1

a116 1

a123 1

d147 1
d163 1
a163 1
sp_vbuf_draw_elements(struct vbuf_render *vbr, const ushort *indices, uint nr)
d169 1
a169 2
   struct setup_context *setup = cvbr->setup;
   const boolean flatshade_first = softpipe->rasterizer->flatshade_first;
d175 2
a176 2
         sp_setup_point( setup,
                         get_vert(vertex_buffer, indices[i-0], stride) );
d182 3
a184 3
         sp_setup_line( setup,
                        get_vert(vertex_buffer, indices[i-1], stride),
                        get_vert(vertex_buffer, indices[i-0], stride) );
d190 3
a192 3
         sp_setup_line( setup,
                        get_vert(vertex_buffer, indices[i-1], stride),
                        get_vert(vertex_buffer, indices[i-0], stride) );
d198 3
a200 3
         sp_setup_line( setup,
                        get_vert(vertex_buffer, indices[i-1], stride),
                        get_vert(vertex_buffer, indices[i-0], stride) );
d203 3
a205 3
         sp_setup_line( setup,
                        get_vert(vertex_buffer, indices[nr-1], stride),
                        get_vert(vertex_buffer, indices[0], stride) );
d210 11
a220 2
      for (i = 2; i < nr; i += 3) {
         sp_setup_tri( setup,
d224 1
d229 1
a229 1
      if (flatshade_first) {
d231 4
a234 6
            /* emit first triangle vertex as first triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i+(i&1)-1], stride),
                          get_vert(vertex_buffer, indices[i-(i&1)], stride) );

d239 4
a242 5
            /* emit last triangle vertex as last triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i+(i&1)-2], stride),
                          get_vert(vertex_buffer, indices[i-(i&1)-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
d248 1
a248 1
      if (flatshade_first) {
d250 4
a253 5
            /* emit first non-spoke vertex as first vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[0], stride) );
d258 4
a261 5
            /* emit last non-spoke vertex as last vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[0], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
d267 1
a267 3
      /* GL quads don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
d269 8
a276 9
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride) );

            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-1], stride) );
a279 1
         /* emit last quad vertex as last triangle vertex */
d281 9
a289 9
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );

            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
d295 1
a295 3
      /* GL quad strips don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
d297 8
a304 8
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-3], stride) );
a307 1
         /* emit last quad vertex as last triangle vertex */
d309 8
a316 8
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
d323 3
a325 1
       * shading color.
d327 5
a331 17
      if (flatshade_first) { 
         /* emit first polygon  vertex as first triangle vertex */
         for (i = 2; i < nr; i += 1) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[0], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      else {
         /* emit first polygon  vertex as last triangle vertex */
         for (i = 2; i < nr; i += 1) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[0], stride) );
         }
d350 1
a350 1
   struct setup_context *setup = cvbr->setup;
a353 1
   const boolean flatshade_first = softpipe->rasterizer->flatshade_first;
d359 2
a360 2
         sp_setup_point( setup,
                         get_vert(vertex_buffer, i-0, stride) );
d366 3
a368 3
         sp_setup_line( setup,
                        get_vert(vertex_buffer, i-1, stride),
                        get_vert(vertex_buffer, i-0, stride) );
d374 1
a374 1
         sp_setup_line( setup,
d382 3
a384 3
         sp_setup_line( setup,
                        get_vert(vertex_buffer, i-1, stride),
                        get_vert(vertex_buffer, i-0, stride) );
d387 3
a389 3
         sp_setup_line( setup,
                        get_vert(vertex_buffer, nr-1, stride),
                        get_vert(vertex_buffer, 0, stride) );
d394 11
a404 2
      for (i = 2; i < nr; i += 3) {
         sp_setup_tri( setup,
d408 1
d413 1
a413 1
      if (flatshade_first) {
d415 4
a418 5
            /* emit first triangle vertex as first triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i+(i&1)-1, stride),
                          get_vert(vertex_buffer, i-(i&1), stride) );
d423 4
a426 5
            /* emit last triangle vertex as last triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i+(i&1)-2, stride),
                          get_vert(vertex_buffer, i-(i&1)-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
d432 1
a432 1
      if (flatshade_first) {
d434 4
a437 5
            /* emit first non-spoke vertex as first vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, 0, stride)  );
d442 4
a445 5
            /* emit last non-spoke vertex as last vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, 0, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
d451 1
a451 3
      /* GL quads don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
d453 8
a460 8
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-2, stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-1, stride) );
a463 1
         /* emit last quad vertex as last triangle vertex */
d465 8
a472 8
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-0, stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
d478 1
a478 3
      /* GL quad strips don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
d480 8
a487 8
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-2, stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-3, stride) );
a490 1
         /* emit last quad vertex as last triangle vertex */
d492 8
a499 8
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-0, stride) );
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-3, stride),
                          get_vert(vertex_buffer, i-0, stride) );
d506 3
a508 1
       * shading color.
d510 5
a514 17
      if (flatshade_first) { 
         /* emit first polygon  vertex as first triangle vertex */
         for (i = 2; i < nr; i += 1) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, 0, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
         }
      }
      else {
         /* emit first polygon  vertex as last triangle vertex */
         for (i = 2; i < nr; i += 1) {
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, 0, stride) );
         }
a522 15
static void
sp_vbuf_so_info(struct vbuf_render *vbr, uint primitives, uint vertices)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   struct softpipe_context *softpipe = cvbr->softpipe;
   unsigned i;

   for (i = 0; i < softpipe->so_target.num_buffers; ++i) {
      softpipe->so_target.so_count[i] += vertices;
   }

   softpipe->so_stats.num_primitives_written = primitives;
   softpipe->so_stats.primitives_storage_needed =
      vertices * 4 /*sizeof(float|int32)*/ * 4 /*x,y,z,w*/;
}
d529 1
a529 1
   if (cvbr->vertex_buffer)
d554 1
a554 1
   cvbr->base.draw_elements = sp_vbuf_draw_elements;
a556 1
   cvbr->base.set_stream_output_info = sp_vbuf_so_info;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d135 1
a135 1
static void
d145 1
a383 8
   case PIPE_PRIM_LINES_ADJACENCY:
      for (i = 3; i < nr; i += 4) {
         sp_setup_line( setup,
                        get_vert(vertex_buffer, i-2, stride),
                        get_vert(vertex_buffer, i-1, stride) );
      }
      break;

a391 8
   case PIPE_PRIM_LINE_STRIP_ADJACENCY:
      for (i = 3; i < nr; i++) {
         sp_setup_line( setup,
                     get_vert(vertex_buffer, i-2, stride),
                     get_vert(vertex_buffer, i-1, stride) );
      }
      break;

a413 9
   case PIPE_PRIM_TRIANGLES_ADJACENCY:
      for (i = 5; i < nr; i += 6) {
         sp_setup_tri( setup,
                       get_vert(vertex_buffer, i-5, stride),
                       get_vert(vertex_buffer, i-3, stride),
                       get_vert(vertex_buffer, i-1, stride) );
      }
      break;

a434 21
   case PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY:
      if (flatshade_first) {
         for (i = 5; i < nr; i += 2) {
            /* emit first triangle vertex as first triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i-5, stride),
                          get_vert(vertex_buffer, i+(i&1)*2-3, stride),
                          get_vert(vertex_buffer, i-(i&1)*2-1, stride) );
         }
      }
      else {
         for (i = 5; i < nr; i += 2) {
            /* emit last triangle vertex as last triangle vertex */
            sp_setup_tri( setup,
                          get_vert(vertex_buffer, i+(i&1)*2-5, stride),
                          get_vert(vertex_buffer, i-(i&1)*2-3, stride),
                          get_vert(vertex_buffer, i-1, stride) );
         }
      }
      break;

d546 1
a546 2
sp_vbuf_so_info(struct vbuf_render *vbr, uint primitives, uint vertices,
                uint prim_generated)
d550 1
d552 5
a556 1
   softpipe->so_stats.num_primitives_written += primitives;
a558 23
   softpipe->num_primitives_generated += prim_generated;
}

static void
sp_vbuf_pipeline_statistics(
   struct vbuf_render *vbr, 
   const struct pipe_query_data_pipeline_statistics *stats)
{
   struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
   struct softpipe_context *softpipe = cvbr->softpipe;

   softpipe->pipeline_statistics.ia_vertices +=
      stats->ia_vertices;
   softpipe->pipeline_statistics.ia_primitives +=
      stats->ia_primitives;
   softpipe->pipeline_statistics.vs_invocations +=
      stats->vs_invocations;
   softpipe->pipeline_statistics.gs_invocations +=
      stats->gs_invocations;
   softpipe->pipeline_statistics.gs_primitives +=
      stats->gs_primitives;
   softpipe->pipeline_statistics.c_invocations +=
      stats->c_invocations;
a594 1
   cvbr->base.pipeline_statistics = sp_vbuf_pipeline_statistics;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a589 9
/*
 * FIXME: it is unclear if primitives_storage_needed (which is generally
 * the same as pipe query num_primitives_generated) should increase
 * if SO is disabled for d3d10, but for GL we definitely need to
 * increase num_primitives_generated and this is only called for active
 * SO. If it must not increase for d3d10 need to disambiguate the counters
 * in the driver and do some work for getting correct values, if it should
 * increase too should call this from outside streamout code.
 */
d591 2
a592 1
sp_vbuf_so_info(struct vbuf_render *vbr, uint primitives, uint prim_generated)
d598 3
a600 1
   softpipe->so_stats.primitives_storage_needed += prim_generated;
@


