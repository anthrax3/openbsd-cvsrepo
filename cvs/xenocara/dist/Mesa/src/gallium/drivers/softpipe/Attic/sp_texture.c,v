head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.07;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.49;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.04;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2006 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  *   Michel DÃ¤nzer <daenzer@@vmware.com>
  */

#include "pipe/p_defines.h"
#include "util/u_inlines.h"

#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_transfer.h"

#include "sp_context.h"
#include "sp_flush.h"
#include "sp_texture.h"
#include "sp_screen.h"

#include "state_tracker/sw_winsys.h"


/**
 * Conventional allocation path for non-display textures:
 * Use a simple, maximally packed layout.
 */
static boolean
softpipe_resource_layout(struct pipe_screen *screen,
                         struct softpipe_resource *spr,
                         boolean allocate)
{
   struct pipe_resource *pt = &spr->base;
   unsigned level;
   unsigned width = pt->width0;
   unsigned height = pt->height0;
   unsigned depth = pt->depth0;
   uint64_t buffer_size = 0;

   for (level = 0; level <= pt->last_level; level++) {
      unsigned slices;

      if (pt->target == PIPE_TEXTURE_CUBE)
         slices = 6;
      else if (pt->target == PIPE_TEXTURE_3D)
         slices = depth;
      else
         slices = pt->array_size;

      spr->stride[level] = util_format_get_stride(pt->format, width);

      spr->level_offset[level] = buffer_size;

      buffer_size += (uint64_t) util_format_get_nblocksy(pt->format, height) *
                     slices * spr->stride[level];

      width  = u_minify(width, 1);
      height = u_minify(height, 1);
      depth = u_minify(depth, 1);
   }

   if (buffer_size > SP_MAX_TEXTURE_SIZE)
      return FALSE;

   if (allocate) {
      spr->data = align_malloc(buffer_size, 64);
      return spr->data != NULL;
   }
   else {
      return TRUE;
   }
}


/**
 * Check the size of the texture specified by 'res'.
 * \return TRUE if OK, FALSE if too large.
 */
static boolean
softpipe_can_create_resource(struct pipe_screen *screen,
                             const struct pipe_resource *res)
{
   struct softpipe_resource spr;
   memset(&spr, 0, sizeof(spr));
   spr.base = *res;
   return softpipe_resource_layout(screen, &spr, FALSE);
}


/**
 * Texture layout for simple color buffers.
 */
static boolean
softpipe_displaytarget_layout(struct pipe_screen *screen,
                              struct softpipe_resource *spr)
{
   struct sw_winsys *winsys = softpipe_screen(screen)->winsys;

   /* Round up the surface size to a multiple of the tile size?
    */
   spr->dt = winsys->displaytarget_create(winsys,
                                          spr->base.bind,
                                          spr->base.format,
                                          spr->base.width0, 
                                          spr->base.height0,
                                          64,
                                          &spr->stride[0] );

   return spr->dt != NULL;
}


/**
 * Create new pipe_resource given the template information.
 */
static struct pipe_resource *
softpipe_resource_create(struct pipe_screen *screen,
                         const struct pipe_resource *templat)
{
   struct softpipe_resource *spr = CALLOC_STRUCT(softpipe_resource);
   if (!spr)
      return NULL;

   assert(templat->format != PIPE_FORMAT_NONE);

   spr->base = *templat;
   pipe_reference_init(&spr->base.reference, 1);
   spr->base.screen = screen;

   spr->pot = (util_is_power_of_two(templat->width0) &&
               util_is_power_of_two(templat->height0) &&
               util_is_power_of_two(templat->depth0));

   if (spr->base.bind & (PIPE_BIND_DISPLAY_TARGET |
			 PIPE_BIND_SCANOUT |
			 PIPE_BIND_SHARED)) {
      if (!softpipe_displaytarget_layout(screen, spr))
         goto fail;
   }
   else {
      if (!softpipe_resource_layout(screen, spr, TRUE))
         goto fail;
   }
    
   return &spr->base;

 fail:
   FREE(spr);
   return NULL;
}


static void
softpipe_resource_destroy(struct pipe_screen *pscreen,
			  struct pipe_resource *pt)
{
   struct softpipe_screen *screen = softpipe_screen(pscreen);
   struct softpipe_resource *spr = softpipe_resource(pt);

   if (spr->dt) {
      /* display target */
      struct sw_winsys *winsys = screen->winsys;
      winsys->displaytarget_destroy(winsys, spr->dt);
   }
   else if (!spr->userBuffer) {
      /* regular texture */
      align_free(spr->data);
   }

   FREE(spr);
}


static struct pipe_resource *
softpipe_resource_from_handle(struct pipe_screen *screen,
                              const struct pipe_resource *templat,
                              struct winsys_handle *whandle)
{
   struct sw_winsys *winsys = softpipe_screen(screen)->winsys;
   struct softpipe_resource *spr = CALLOC_STRUCT(softpipe_resource);
   if (!spr)
      return NULL;

   spr->base = *templat;
   pipe_reference_init(&spr->base.reference, 1);
   spr->base.screen = screen;

   spr->pot = (util_is_power_of_two(templat->width0) &&
               util_is_power_of_two(templat->height0) &&
               util_is_power_of_two(templat->depth0));

   spr->dt = winsys->displaytarget_from_handle(winsys,
                                               templat,
                                               whandle,
                                               &spr->stride[0]);
   if (!spr->dt)
      goto fail;

   return &spr->base;

 fail:
   FREE(spr);
   return NULL;
}


static boolean
softpipe_resource_get_handle(struct pipe_screen *screen,
                             struct pipe_resource *pt,
                             struct winsys_handle *whandle)
{
   struct sw_winsys *winsys = softpipe_screen(screen)->winsys;
   struct softpipe_resource *spr = softpipe_resource(pt);

   assert(spr->dt);
   if (!spr->dt)
      return FALSE;

   return winsys->displaytarget_get_handle(winsys, spr->dt, whandle);
}


/**
 * Helper function to compute offset (in bytes) for a particular
 * texture level/face/slice from the start of the buffer.
 */
static unsigned
sp_get_tex_image_offset(const struct softpipe_resource *spr,
                        unsigned level, unsigned layer)
{
   const unsigned hgt = u_minify(spr->base.height0, level);
   const unsigned nblocksy = util_format_get_nblocksy(spr->base.format, hgt);
   unsigned offset = spr->level_offset[level];

   if (spr->base.target == PIPE_TEXTURE_CUBE ||
       spr->base.target == PIPE_TEXTURE_CUBE_ARRAY ||
       spr->base.target == PIPE_TEXTURE_3D ||
       spr->base.target == PIPE_TEXTURE_2D_ARRAY) {
      offset += layer * nblocksy * spr->stride[level];
   }
   else if (spr->base.target == PIPE_TEXTURE_1D_ARRAY) {
      offset += layer * spr->stride[level];
   }
   else {
      assert(layer == 0);
   }

   return offset;
}


/**
 * Get a pipe_surface "view" into a texture resource.
 */
static struct pipe_surface *
softpipe_create_surface(struct pipe_context *pipe,
                        struct pipe_resource *pt,
                        const struct pipe_surface *surf_tmpl)
{
   struct pipe_surface *ps;

   ps = CALLOC_STRUCT(pipe_surface);
   if (ps) {
      pipe_reference_init(&ps->reference, 1);
      pipe_resource_reference(&ps->texture, pt);
      ps->context = pipe;
      ps->format = surf_tmpl->format;
      if (pt->target != PIPE_BUFFER) {
         assert(surf_tmpl->u.tex.level <= pt->last_level);
         ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
         ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
         ps->u.tex.level = surf_tmpl->u.tex.level;
         ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
         ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
         if (ps->u.tex.first_layer != ps->u.tex.last_layer) {
            debug_printf("creating surface with multiple layers, rendering to first layer only\n");
         }
      }
      else {
         /* setting width as number of elements should get us correct renderbuffer width */
         ps->width = surf_tmpl->u.buf.last_element - surf_tmpl->u.buf.first_element + 1;
         ps->height = pt->height0;
         ps->u.buf.first_element = surf_tmpl->u.buf.first_element;
         ps->u.buf.last_element = surf_tmpl->u.buf.last_element;
         assert(ps->u.buf.first_element <= ps->u.buf.last_element);
         assert(ps->u.buf.last_element < ps->width);
      }
   }
   return ps;
}


/**
 * Free a pipe_surface which was created with softpipe_create_surface().
 */
static void 
softpipe_surface_destroy(struct pipe_context *pipe,
                         struct pipe_surface *surf)
{
   /* Effectively do the texture_update work here - if texture images
    * needed post-processing to put them into hardware layout, this is
    * where it would happen.  For softpipe, nothing to do.
    */
   assert(surf->texture);
   pipe_resource_reference(&surf->texture, NULL);
   FREE(surf);
}


/**
 * Geta pipe_transfer object which is used for moving data in/out of
 * a resource object.
 * \param pipe  rendering context
 * \param resource  the resource to transfer in/out of
 * \param level  which mipmap level
 * \param usage  bitmask of PIPE_TRANSFER_x flags
 * \param box  the 1D/2D/3D region of interest
 */
static void *
softpipe_transfer_map(struct pipe_context *pipe,
                      struct pipe_resource *resource,
                      unsigned level,
                      unsigned usage,
                      const struct pipe_box *box,
                      struct pipe_transfer **transfer)
{
   struct sw_winsys *winsys = softpipe_screen(pipe->screen)->winsys;
   struct softpipe_resource *spr = softpipe_resource(resource);
   struct softpipe_transfer *spt;
   struct pipe_transfer *pt;
   enum pipe_format format = resource->format;
   const unsigned hgt = u_minify(spr->base.height0, level);
   const unsigned nblocksy = util_format_get_nblocksy(format, hgt);
   uint8_t *map;

   assert(resource);
   assert(level <= resource->last_level);

   /* make sure the requested region is in the image bounds */
   assert(box->x + box->width <= (int) u_minify(resource->width0, level));
   if (resource->target == PIPE_TEXTURE_1D_ARRAY) {
      assert(box->y + box->height <= (int) resource->array_size);
   }
   else {
      assert(box->y + box->height <= (int) u_minify(resource->height0, level));
      if (resource->target == PIPE_TEXTURE_2D_ARRAY) {
         assert(box->z + box->depth <= (int) resource->array_size);
      }
      else if (resource->target == PIPE_TEXTURE_CUBE) {
         assert(box->z < 6);
      }
      else if (resource->target == PIPE_TEXTURE_CUBE_ARRAY) {
         assert(box->z <= (int) resource->array_size);
      }
      else {
         assert(box->z + box->depth <= (int) u_minify(resource->depth0, level));
      }
   }

   /*
    * Transfers, like other pipe operations, must happen in order, so flush the
    * context if necessary.
    */
   if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED)) {
      boolean read_only = !(usage & PIPE_TRANSFER_WRITE);
      boolean do_not_block = !!(usage & PIPE_TRANSFER_DONTBLOCK);
      if (!softpipe_flush_resource(pipe, resource,
                                   level, box->depth > 1 ? -1 : box->z,
                                   0, /* flush_flags */
                                   read_only,
                                   TRUE, /* cpu_access */
                                   do_not_block)) {
         /*
          * It would have blocked, but state tracker requested no to.
          */
         assert(do_not_block);
         return NULL;
      }
   }

   spt = CALLOC_STRUCT(softpipe_transfer);
   if (!spt)
      return NULL;

   pt = &spt->base;

   pipe_resource_reference(&pt->resource, resource);
   pt->level = level;
   pt->usage = usage;
   pt->box = *box;
   pt->stride = spr->stride[level];
   pt->layer_stride = pt->stride * nblocksy;

   spt->offset = sp_get_tex_image_offset(spr, level, box->z);

   spt->offset +=
         box->y / util_format_get_blockheight(format) * spt->base.stride +
         box->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);

   /* resources backed by display target treated specially:
    */
   if (spr->dt) {
      map = winsys->displaytarget_map(winsys, spr->dt, usage);
   }
   else {
      map = spr->data;
   }

   if (map == NULL) {
      pipe_resource_reference(&pt->resource, NULL);
      FREE(spt);
      return NULL;
   }

   *transfer = pt;
   return map + spt->offset;
}


/**
 * Unmap memory mapping for given pipe_transfer object.
 */
static void
softpipe_transfer_unmap(struct pipe_context *pipe,
                        struct pipe_transfer *transfer)
{
   struct softpipe_resource *spr;

   assert(transfer->resource);
   spr = softpipe_resource(transfer->resource);

   if (spr->dt) {
      /* display target */
      struct sw_winsys *winsys = softpipe_screen(pipe->screen)->winsys;
      winsys->displaytarget_unmap(winsys, spr->dt);
   }

   if (transfer->usage & PIPE_TRANSFER_WRITE) {
      /* Mark the texture as dirty to expire the tile caches. */
      spr->timestamp++;
   }

   pipe_resource_reference(&transfer->resource, NULL);
   FREE(transfer);
}

/**
 * Create buffer which wraps user-space data.
 */
struct pipe_resource *
softpipe_user_buffer_create(struct pipe_screen *screen,
                            void *ptr,
                            unsigned bytes,
			    unsigned bind_flags)
{
   struct softpipe_resource *spr;

   spr = CALLOC_STRUCT(softpipe_resource);
   if (!spr)
      return NULL;

   pipe_reference_init(&spr->base.reference, 1);
   spr->base.screen = screen;
   spr->base.format = PIPE_FORMAT_R8_UNORM; /* ?? */
   spr->base.bind = bind_flags;
   spr->base.usage = PIPE_USAGE_IMMUTABLE;
   spr->base.flags = 0;
   spr->base.width0 = bytes;
   spr->base.height0 = 1;
   spr->base.depth0 = 1;
   spr->base.array_size = 1;
   spr->userBuffer = TRUE;
   spr->data = ptr;

   return &spr->base;
}


void
softpipe_init_texture_funcs(struct pipe_context *pipe)
{
   pipe->transfer_map = softpipe_transfer_map;
   pipe->transfer_unmap = softpipe_transfer_unmap;

   pipe->transfer_flush_region = u_default_transfer_flush_region;
   pipe->transfer_inline_write = u_default_transfer_inline_write;

   pipe->create_surface = softpipe_create_surface;
   pipe->surface_destroy = softpipe_surface_destroy;
}


void
softpipe_init_screen_texture_funcs(struct pipe_screen *screen)
{
   screen->resource_create = softpipe_resource_create;
   screen->resource_destroy = softpipe_resource_destroy;
   screen->resource_from_handle = softpipe_resource_from_handle;
   screen->resource_get_handle = softpipe_resource_get_handle;
   screen->can_create_resource = softpipe_can_create_resource;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d66 1
a66 3
      unsigned slices, nblocksy;

      nblocksy = util_format_get_nblocksy(pt->format, height);
d69 2
a70 3
         assert(pt->array_size == 6);

      if (pt->target == PIPE_TEXTURE_3D)
d79 2
a80 9
      /* if row_stride * height > SP_MAX_TEXTURE_SIZE */
      if ((uint64_t)spr->stride[level] * nblocksy > SP_MAX_TEXTURE_SIZE) {
         /* image too large */
         return FALSE;
      }

      spr->img_stride[level] = spr->stride[level] * nblocksy;

      buffer_size += (uint64_t) spr->img_stride[level] * slices;
d256 2
d260 12
a271 1
   offset += layer * spr->img_stride[level];
d357 2
d417 1
a417 1
   pt->layer_stride = spr->img_stride[level];
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d66 3
a68 1
      unsigned slices;
d71 3
a73 2
         slices = 6;
      else if (pt->target == PIPE_TEXTURE_3D)
d82 9
a90 2
      buffer_size += (uint64_t) util_format_get_nblocksy(pt->format, height) *
                     slices * spr->stride[level];
a265 2
   const unsigned hgt = u_minify(spr->base.height0, level);
   const unsigned nblocksy = util_format_get_nblocksy(spr->base.format, hgt);
d268 1
a268 12
   if (spr->base.target == PIPE_TEXTURE_CUBE ||
       spr->base.target == PIPE_TEXTURE_CUBE_ARRAY ||
       spr->base.target == PIPE_TEXTURE_3D ||
       spr->base.target == PIPE_TEXTURE_2D_ARRAY) {
      offset += layer * nblocksy * spr->stride[level];
   }
   else if (spr->base.target == PIPE_TEXTURE_1D_ARRAY) {
      offset += layer * spr->stride[level];
   }
   else {
      assert(layer == 0);
   }
a353 2
   const unsigned hgt = u_minify(spr->base.height0, level);
   const unsigned nblocksy = util_format_get_nblocksy(format, hgt);
d412 1
a412 1
   pt->layer_stride = pt->stride * nblocksy;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d29 2
a30 2
  *   Keith Whitwell <keith@@tungstengraphics.com>
  *   Michel DÃ¤nzer <michel@@tungstengraphics.com>
d63 1
a63 1
   unsigned buffer_size = 0;
d79 2
a80 2
      buffer_size += (util_format_get_nblocksy(pt->format, height) *
                      slices * spr->stride[level]);
d91 1
a91 1
      spr->data = align_malloc(buffer_size, 16);
d131 1
a131 1
                                          16,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d55 2
a56 1
                         struct softpipe_resource *spr)
d87 2
a88 1
   spr->data = align_malloc(buffer_size, 16);
d90 22
a111 1
   return spr->data != NULL;
d166 1
a166 1
      if (!softpipe_resource_layout(screen, spr))
d261 1
a285 4
   unsigned level = surf_tmpl->u.tex.level;

   assert(level <= pt->last_level);
   assert(surf_tmpl->u.tex.first_layer == surf_tmpl->u.tex.last_layer);
d293 20
a312 7
      ps->width = u_minify(pt->width0, level);
      ps->height = u_minify(pt->height0, level);
      ps->usage = surf_tmpl->usage;

      ps->u.tex.level = level;
      ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
      ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
d344 2
a345 2
static struct pipe_transfer *
softpipe_get_transfer(struct pipe_context *pipe,
d349 2
a350 1
                      const struct pipe_box *box)
d352 1
d355 5
d365 1
a365 1
   assert(box->x + box->width <= u_minify(resource->width0, level));
d367 1
a367 1
      assert(box->y + box->height <= resource->array_size);
d370 1
a370 1
      assert(box->y + box->height <= u_minify(resource->height0, level));
d372 1
a372 1
         assert(box->z + box->depth <= resource->array_size);
d377 3
d381 1
a381 1
         assert(box->z + box->depth <= (u_minify(resource->depth0, level)));
d407 2
a408 18
   if (spt) {
      struct pipe_transfer *pt = &spt->base;
      enum pipe_format format = resource->format;
      const unsigned hgt = u_minify(spr->base.height0, level);
      const unsigned nblocksy = util_format_get_nblocksy(format, hgt);

      pipe_resource_reference(&pt->resource, resource);
      pt->level = level;
      pt->usage = usage;
      pt->box = *box;
      pt->stride = spr->stride[level];
      pt->layer_stride = pt->stride * nblocksy;

      spt->offset = sp_get_tex_image_offset(spr, level, box->z);
 
      spt->offset += 
         box->y / util_format_get_blockheight(format) * spt->base.stride +
         box->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);
d410 1
a410 4
      return pt;
   }
   return NULL;
}
d412 6
d419 1
a419 11
/**
 * Free a pipe_transfer object which was created with
 * softpipe_get_transfer().
 */
static void 
softpipe_transfer_destroy(struct pipe_context *pipe,
                          struct pipe_transfer *transfer)
{
   pipe_resource_reference(&transfer->resource, NULL);
   FREE(transfer);
}
d421 3
a424 12
/**
 * Create memory mapping for given pipe_transfer object.
 */
static void *
softpipe_transfer_map(struct pipe_context *pipe,
                      struct pipe_transfer *transfer)
{
   struct softpipe_transfer *spt = softpipe_transfer(transfer);
   struct softpipe_resource *spr = softpipe_resource(transfer->resource);
   struct sw_winsys *winsys = softpipe_screen(pipe->screen)->winsys;
   uint8_t *map;
   
d428 1
a428 1
      map = winsys->displaytarget_map(winsys, spr->dt, transfer->usage);
d434 3
a436 1
   if (map == NULL)
d438 4
a441 2
   else
      return map + spt->offset;
d467 3
d475 1
a475 1
static struct pipe_resource *
a506 2
   pipe->get_transfer = softpipe_get_transfer;
   pipe->transfer_destroy = softpipe_transfer_destroy;
d525 1
a525 2
   screen->user_buffer_create = softpipe_user_buffer_create;

@


1.2
log
@Merge Mesa 7.10.3
@
text
@d65 9
d79 1
a79 2
                      ((pt->target == PIPE_TEXTURE_CUBE) ? 6 : depth) *
                      spr->stride[level]);
d238 2
a239 1
       spr->base.target == PIPE_TEXTURE_3D) {
d242 3
d307 1
a307 1
 * \param sr  indicates cube face or 3D texture slice
d326 15
a340 2
   assert(box->y + box->height <= u_minify(resource->height0, level));
   assert(box->z + box->depth <= (u_minify(resource->depth0, level) + resource->array_size - 1));
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 1
d42 1
d45 2
a46 1
#include "sp_winsys.h"
d54 2
a55 2
softpipe_texture_layout(struct pipe_screen *screen,
                        struct softpipe_texture * spt)
d57 1
a57 1
   struct pipe_texture *pt = &spt->base;
d65 1
a65 1
      spt->stride[level] = util_format_get_stride(pt->format, width);
d67 1
a67 1
      spt->level_offset[level] = buffer_size;
d71 1
a71 1
                      spt->stride[level]);
d78 1
a78 3
   spt->buffer = screen->buffer_create(screen, 32,
                                       PIPE_BUFFER_USAGE_PIXEL,
                                       buffer_size);
d80 1
a80 1
   return spt->buffer != NULL;
d89 1
a89 1
                              struct softpipe_texture * spt)
d91 1
a91 3
   unsigned usage = (PIPE_BUFFER_USAGE_CPU_READ_WRITE |
                     PIPE_BUFFER_USAGE_GPU_READ_WRITE);
   unsigned tex_usage = spt->base.tex_usage;
d93 9
a101 7
   spt->buffer = screen->surface_buffer_create( screen, 
                                                spt->base.width0, 
                                                spt->base.height0,
                                                spt->base.format,
                                                usage,
                                                tex_usage,
                                                &spt->stride[0]);
d103 1
a103 1
   return spt->buffer != NULL;
d108 1
a108 1
 * Create new pipe_texture given the template information.
d110 3
a112 3
static struct pipe_texture *
softpipe_texture_create(struct pipe_screen *screen,
                        const struct pipe_texture *template)
d114 2
a115 2
   struct softpipe_texture *spt = CALLOC_STRUCT(softpipe_texture);
   if (!spt)
d118 14
a131 11
   spt->base = *template;
   pipe_reference_init(&spt->base.reference, 1);
   spt->base.screen = screen;

   spt->pot = (util_is_power_of_two(template->width0) &&
               util_is_power_of_two(template->height0) &&
               util_is_power_of_two(template->depth0));

   if (spt->base.tex_usage & (PIPE_TEXTURE_USAGE_DISPLAY_TARGET |
                              PIPE_TEXTURE_USAGE_PRIMARY)) {
      if (!softpipe_displaytarget_layout(screen, spt))
d135 1
a135 1
      if (!softpipe_texture_layout(screen, spt))
d139 1
a139 1
   return &spt->base;
d142 1
a142 1
   FREE(spt);
d147 15
a161 17
/**
 * Create a new pipe_texture which wraps an existing buffer.
 */
static struct pipe_texture *
softpipe_texture_blanket(struct pipe_screen * screen,
                         const struct pipe_texture *base,
                         const unsigned *stride,
                         struct pipe_buffer *buffer)
{
   struct softpipe_texture *spt;
   assert(screen);

   /* Only supports one type */
   if (base->target != PIPE_TEXTURE_2D ||
       base->last_level != 0 ||
       base->depth0 != 1) {
      return NULL;
d164 12
a175 2
   spt = CALLOC_STRUCT(softpipe_texture);
   if (!spt)
d178 30
a207 4
   spt->base = *base;
   pipe_reference_init(&spt->base.reference, 1);
   spt->base.screen = screen;
   spt->stride[0] = stride[0];
d209 3
a211 1
   pipe_buffer_reference(&spt->buffer, buffer);
d213 1
a213 1
   return &spt->base;
d217 7
a223 2
static void
softpipe_texture_destroy(struct pipe_texture *pt)
d225 3
a227 1
   struct softpipe_texture *spt = softpipe_texture(pt);
d229 9
a237 2
   pipe_buffer_reference(&spt->buffer, NULL);
   FREE(spt);
d242 1
a242 1
 * Get a pipe_surface "view" into a texture.
d245 3
a247 4
softpipe_get_tex_surface(struct pipe_screen *screen,
                         struct pipe_texture *pt,
                         unsigned face, unsigned level, unsigned zslice,
                         unsigned usage)
a248 1
   struct softpipe_texture *spt = softpipe_texture(pt);
d250 1
d253 1
d258 3
a260 2
      pipe_texture_reference(&ps->texture, pt);
      ps->format = pt->format;
d263 1
a263 2
      ps->offset = spt->level_offset[level];
      ps->usage = usage;
d265 3
a267 36
      /* Because we are softpipe, anything that the state tracker
       * thought was going to be done with the GPU will actually get
       * done with the CPU.  Let's adjust the flags to take that into
       * account.
       */
      if (ps->usage & PIPE_BUFFER_USAGE_GPU_WRITE) {
         /* GPU_WRITE means "render" and that can involve reads (blending) */
         ps->usage |= PIPE_BUFFER_USAGE_CPU_WRITE | PIPE_BUFFER_USAGE_CPU_READ;
      }

      if (ps->usage & PIPE_BUFFER_USAGE_GPU_READ)
         ps->usage |= PIPE_BUFFER_USAGE_CPU_READ;

      if (ps->usage & (PIPE_BUFFER_USAGE_CPU_WRITE |
                       PIPE_BUFFER_USAGE_GPU_WRITE)) {
         /* Mark the surface as dirty.  The tile cache will look for this. */
         spt->timestamp++;
         softpipe_screen(screen)->timestamp++;
      }

      ps->face = face;
      ps->level = level;
      ps->zslice = zslice;

      if (pt->target == PIPE_TEXTURE_CUBE) {
         ps->offset += face * util_format_get_nblocksy(pt->format, u_minify(pt->height0, level)) *
                       spt->stride[level];
      }
      else if (pt->target == PIPE_TEXTURE_3D) {
         ps->offset += zslice * util_format_get_nblocksy(pt->format, u_minify(pt->height0, level)) *
                       spt->stride[level];
      }
      else {
         assert(face == 0);
         assert(zslice == 0);
      }
d274 1
a274 1
 * Free a pipe_surface which was created with softpipe_get_tex_surface().
d277 2
a278 1
softpipe_tex_surface_destroy(struct pipe_surface *surf)
d285 1
a285 1
   pipe_texture_reference(&surf->texture, NULL);
d292 6
a297 9
 * a texture object.
 * \param face  one of PIPE_TEX_FACE_x or 0
 * \param level  texture mipmap level
 * \param zslice  2D slice of a 3D texture
 * \param usage  one of PIPE_TRANSFER_READ/WRITE/READ_WRITE
 * \param x  X position of region to read/write
 * \param y  Y position of region to read/write
 * \param width  width of region to read/write
 * \param height  height of region to read/write
d300 5
a304 5
softpipe_get_tex_transfer(struct pipe_screen *screen,
                          struct pipe_texture *texture,
                          unsigned face, unsigned level, unsigned zslice,
                          enum pipe_transfer_usage usage,
                          unsigned x, unsigned y, unsigned w, unsigned h)
d306 1
a306 1
   struct softpipe_texture *sptex = softpipe_texture(texture);
d309 2
a310 2
   assert(texture);
   assert(level <= texture->last_level);
d313 24
a336 2
   assert(x + w <= u_minify(texture->width0, level));
   assert(y + h <= u_minify(texture->height0, level));
d341 6
a346 7
      int nblocksy = util_format_get_nblocksy(texture->format, u_minify(texture->height0, level));
      pipe_texture_reference(&pt->texture, texture);
      pt->x = x;
      pt->y = y;
      pt->width = w;
      pt->height = h;
      pt->stride = sptex->stride[level];
d348 9
a356 3
      pt->face = face;
      pt->level = level;
      pt->zslice = zslice;
a357 12
      spt->offset = sptex->level_offset[level];

      if (texture->target == PIPE_TEXTURE_CUBE) {
         spt->offset += face * nblocksy * pt->stride;
      }
      else if (texture->target == PIPE_TEXTURE_3D) {
         spt->offset += zslice * nblocksy * pt->stride;
      }
      else {
         assert(face == 0);
         assert(zslice == 0);
      }
d366 1
a366 1
 * softpipe_get_tex_transfer().
d369 2
a370 1
softpipe_tex_transfer_destroy(struct pipe_transfer *transfer)
d372 1
a372 6
   /* Effectively do the texture_update work here - if texture images
    * needed post-processing to put them into hardware layout, this is
    * where it would happen.  For softpipe, nothing to do.
    */
   assert (transfer->texture);
   pipe_texture_reference(&transfer->texture, NULL);
d381 2
a382 2
softpipe_transfer_map( struct pipe_screen *screen,
                       struct pipe_transfer *transfer )
d384 13
a396 7
   ubyte *map, *xfer_map;
   struct softpipe_texture *spt;
   enum pipe_format format;

   assert(transfer->texture);
   spt = softpipe_texture(transfer->texture);
   format = transfer->texture->format;
a397 1
   map = pipe_buffer_map(screen, spt->buffer, pipe_transfer_buffer_flags(transfer));
d400 2
a401 16

   /* May want to different things here depending on read/write nature
    * of the map:
    */
   if (transfer->texture && (transfer->usage & PIPE_TRANSFER_WRITE)) {
      /* Do something to notify sharing contexts of a texture change.
       * In softpipe, that would mean flushing the texture cache.
       */
      softpipe_screen(screen)->timestamp++;
   }

   xfer_map = map + softpipe_transfer(transfer)->offset +
      transfer->y / util_format_get_blockheight(format) * transfer->stride +
      transfer->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);
   /*printf("map = %p  xfer map = %p\n", map, xfer_map);*/
   return xfer_map;
d409 1
a409 1
softpipe_transfer_unmap(struct pipe_screen *screen,
d412 1
a412 1
   struct softpipe_texture *spt;
d414 2
a415 2
   assert(transfer->texture);
   spt = softpipe_texture(transfer->texture);
d417 5
a421 1
   pipe_buffer_unmap( screen, spt->buffer );
d425 1
a425 1
      spt->timestamp++;
d429 8
a436 5

static struct pipe_video_surface*
softpipe_video_surface_create(struct pipe_screen *screen,
                              enum pipe_video_chroma_format chroma_format,
                              unsigned width, unsigned height)
d438 1
a438 5
   struct softpipe_video_surface *sp_vsfc;
   struct pipe_texture template;

   assert(screen);
   assert(width && height);
d440 2
a441 2
   sp_vsfc = CALLOC_STRUCT(softpipe_video_surface);
   if (!sp_vsfc)
d444 12
a455 22
   pipe_reference_init(&sp_vsfc->base.reference, 1);
   sp_vsfc->base.screen = screen;
   sp_vsfc->base.chroma_format = chroma_format;
   /*sp_vsfc->base.surface_format = PIPE_VIDEO_SURFACE_FORMAT_VUYA;*/
   sp_vsfc->base.width = width;
   sp_vsfc->base.height = height;

   memset(&template, 0, sizeof(struct pipe_texture));
   template.target = PIPE_TEXTURE_2D;
   template.format = PIPE_FORMAT_B8G8R8X8_UNORM;
   template.last_level = 0;
   /* vl_mpeg12_mc_renderer expects this when it's initialized with pot_buffers=true */
   template.width0 = util_next_power_of_two(width);
   template.height0 = util_next_power_of_two(height);
   template.depth0 = 1;
   template.tex_usage = PIPE_TEXTURE_USAGE_SAMPLER | PIPE_TEXTURE_USAGE_RENDER_TARGET;

   sp_vsfc->tex = screen->texture_create(screen, &template);
   if (!sp_vsfc->tex) {
      FREE(sp_vsfc);
      return NULL;
   }
d457 1
a457 1
   return &sp_vsfc->base;
d461 2
a462 2
static void
softpipe_video_surface_destroy(struct pipe_video_surface *vsfc)
d464 7
a470 1
   struct softpipe_video_surface *sp_vsfc = softpipe_video_surface(vsfc);
d472 2
a473 2
   pipe_texture_reference(&sp_vsfc->tex, NULL);
   FREE(sp_vsfc);
d480 5
a484 35
   screen->texture_create = softpipe_texture_create;
   screen->texture_blanket = softpipe_texture_blanket;
   screen->texture_destroy = softpipe_texture_destroy;

   screen->get_tex_surface = softpipe_get_tex_surface;
   screen->tex_surface_destroy = softpipe_tex_surface_destroy;

   screen->get_tex_transfer = softpipe_get_tex_transfer;
   screen->tex_transfer_destroy = softpipe_tex_transfer_destroy;
   screen->transfer_map = softpipe_transfer_map;
   screen->transfer_unmap = softpipe_transfer_unmap;

   screen->video_surface_create = softpipe_video_surface_create;
   screen->video_surface_destroy = softpipe_video_surface_destroy;
}


/**
 * Return pipe_buffer handle and stride for given texture object.
 * XXX used for???
 */
boolean
softpipe_get_texture_buffer( struct pipe_texture *texture,
                             struct pipe_buffer **buf,
                             unsigned *stride )
{
   struct softpipe_texture *tex = (struct softpipe_texture *) texture;

   if (!tex)
      return FALSE;

   pipe_buffer_reference(buf, tex->buffer);

   if (stride)
      *stride = tex->stride[0];
a485 1
   return TRUE;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a38 1
#include "util/u_transfer.h"
a40 1
#include "sp_flush.h"
d43 1
a43 2

#include "state_tracker/sw_winsys.h"
d51 2
a52 2
softpipe_resource_layout(struct pipe_screen *screen,
                         struct softpipe_resource *spr)
d54 1
a54 1
   struct pipe_resource *pt = &spr->base;
d62 1
a62 1
      spr->stride[level] = util_format_get_stride(pt->format, width);
d64 1
a64 1
      spr->level_offset[level] = buffer_size;
d68 1
a68 1
                      spr->stride[level]);
d75 3
a77 1
   spr->data = align_malloc(buffer_size, 16);
d79 1
a79 1
   return spr->data != NULL;
d88 1
a88 1
                              struct softpipe_resource *spr)
d90 3
a92 1
   struct sw_winsys *winsys = softpipe_screen(screen)->winsys;
d94 7
a100 9
   /* Round up the surface size to a multiple of the tile size?
    */
   spr->dt = winsys->displaytarget_create(winsys,
                                          spr->base.bind,
                                          spr->base.format,
                                          spr->base.width0, 
                                          spr->base.height0,
                                          16,
                                          &spr->stride[0] );
d102 1
a102 1
   return spr->dt != NULL;
d107 1
a107 1
 * Create new pipe_resource given the template information.
d109 3
a111 3
static struct pipe_resource *
softpipe_resource_create(struct pipe_screen *screen,
                         const struct pipe_resource *templat)
d113 2
a114 2
   struct softpipe_resource *spr = CALLOC_STRUCT(softpipe_resource);
   if (!spr)
d117 11
a127 14
   assert(templat->format != PIPE_FORMAT_NONE);

   spr->base = *templat;
   pipe_reference_init(&spr->base.reference, 1);
   spr->base.screen = screen;

   spr->pot = (util_is_power_of_two(templat->width0) &&
               util_is_power_of_two(templat->height0) &&
               util_is_power_of_two(templat->depth0));

   if (spr->base.bind & (PIPE_BIND_DISPLAY_TARGET |
			 PIPE_BIND_SCANOUT |
			 PIPE_BIND_SHARED)) {
      if (!softpipe_displaytarget_layout(screen, spr))
d131 1
a131 1
      if (!softpipe_resource_layout(screen, spr))
d135 1
a135 1
   return &spr->base;
d138 1
a138 1
   FREE(spr);
d143 17
a159 15
static void
softpipe_resource_destroy(struct pipe_screen *pscreen,
			  struct pipe_resource *pt)
{
   struct softpipe_screen *screen = softpipe_screen(pscreen);
   struct softpipe_resource *spr = softpipe_resource(pt);

   if (spr->dt) {
      /* display target */
      struct sw_winsys *winsys = screen->winsys;
      winsys->displaytarget_destroy(winsys, spr->dt);
   }
   else if (!spr->userBuffer) {
      /* regular texture */
      align_free(spr->data);
d162 2
a163 12
   FREE(spr);
}


static struct pipe_resource *
softpipe_resource_from_handle(struct pipe_screen *screen,
                              const struct pipe_resource *templat,
                              struct winsys_handle *whandle)
{
   struct sw_winsys *winsys = softpipe_screen(screen)->winsys;
   struct softpipe_resource *spr = CALLOC_STRUCT(softpipe_resource);
   if (!spr)
d166 4
a169 14
   spr->base = *templat;
   pipe_reference_init(&spr->base.reference, 1);
   spr->base.screen = screen;

   spr->pot = (util_is_power_of_two(templat->width0) &&
               util_is_power_of_two(templat->height0) &&
               util_is_power_of_two(templat->depth0));

   spr->dt = winsys->displaytarget_from_handle(winsys,
                                               templat,
                                               whandle,
                                               &spr->stride[0]);
   if (!spr->dt)
      goto fail;
d171 1
a171 1
   return &spr->base;
d173 1
a173 3
 fail:
   FREE(spr);
   return NULL;
d177 2
a178 23
static boolean
softpipe_resource_get_handle(struct pipe_screen *screen,
                             struct pipe_resource *pt,
                             struct winsys_handle *whandle)
{
   struct sw_winsys *winsys = softpipe_screen(screen)->winsys;
   struct softpipe_resource *spr = softpipe_resource(pt);

   assert(spr->dt);
   if (!spr->dt)
      return FALSE;

   return winsys->displaytarget_get_handle(winsys, spr->dt, whandle);
}


/**
 * Helper function to compute offset (in bytes) for a particular
 * texture level/face/slice from the start of the buffer.
 */
static unsigned
sp_get_tex_image_offset(const struct softpipe_resource *spr,
                        unsigned level, unsigned layer)
d180 1
a180 3
   const unsigned hgt = u_minify(spr->base.height0, level);
   const unsigned nblocksy = util_format_get_nblocksy(spr->base.format, hgt);
   unsigned offset = spr->level_offset[level];
d182 2
a183 9
   if (spr->base.target == PIPE_TEXTURE_CUBE ||
       spr->base.target == PIPE_TEXTURE_3D) {
      offset += layer * nblocksy * spr->stride[level];
   }
   else {
      assert(layer == 0);
   }

   return offset;
d188 1
a188 1
 * Get a pipe_surface "view" into a texture resource.
d191 4
a194 3
softpipe_create_surface(struct pipe_context *pipe,
                        struct pipe_resource *pt,
                        const struct pipe_surface *surf_tmpl)
d196 1
a197 1
   unsigned level = surf_tmpl->u.tex.level;
a199 1
   assert(surf_tmpl->u.tex.first_layer == surf_tmpl->u.tex.last_layer);
d204 2
a205 3
      pipe_resource_reference(&ps->texture, pt);
      ps->context = pipe;
      ps->format = surf_tmpl->format;
d208 2
a209 1
      ps->usage = surf_tmpl->usage;
d211 36
a246 3
      ps->u.tex.level = level;
      ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
      ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
d253 1
a253 1
 * Free a pipe_surface which was created with softpipe_create_surface().
d256 1
a256 2
softpipe_surface_destroy(struct pipe_context *pipe,
                         struct pipe_surface *surf)
d263 1
a263 1
   pipe_resource_reference(&surf->texture, NULL);
d270 9
a278 6
 * a resource object.
 * \param pipe  rendering context
 * \param resource  the resource to transfer in/out of
 * \param sr  indicates cube face or 3D texture slice
 * \param usage  bitmask of PIPE_TRANSFER_x flags
 * \param box  the 1D/2D/3D region of interest
d281 5
a285 5
softpipe_get_transfer(struct pipe_context *pipe,
                      struct pipe_resource *resource,
                      unsigned level,
                      unsigned usage,
                      const struct pipe_box *box)
d287 1
a287 1
   struct softpipe_resource *spr = softpipe_resource(resource);
d290 2
a291 2
   assert(resource);
   assert(level <= resource->last_level);
d294 2
a295 24
   assert(box->x + box->width <= u_minify(resource->width0, level));
   assert(box->y + box->height <= u_minify(resource->height0, level));
   assert(box->z + box->depth <= (u_minify(resource->depth0, level) + resource->array_size - 1));

   /*
    * Transfers, like other pipe operations, must happen in order, so flush the
    * context if necessary.
    */
   if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED)) {
      boolean read_only = !(usage & PIPE_TRANSFER_WRITE);
      boolean do_not_block = !!(usage & PIPE_TRANSFER_DONTBLOCK);
      if (!softpipe_flush_resource(pipe, resource,
                                   level, box->depth > 1 ? -1 : box->z,
                                   0, /* flush_flags */
                                   read_only,
                                   TRUE, /* cpu_access */
                                   do_not_block)) {
         /*
          * It would have blocked, but state tracker requested no to.
          */
         assert(do_not_block);
         return NULL;
      }
   }
d300 11
a310 3
      enum pipe_format format = resource->format;
      const unsigned hgt = u_minify(spr->base.height0, level);
      const unsigned nblocksy = util_format_get_nblocksy(format, hgt);
d312 1
a312 12
      pipe_resource_reference(&pt->resource, resource);
      pt->level = level;
      pt->usage = usage;
      pt->box = *box;
      pt->stride = spr->stride[level];
      pt->layer_stride = pt->stride * nblocksy;

      spt->offset = sp_get_tex_image_offset(spr, level, box->z);
 
      spt->offset += 
         box->y / util_format_get_blockheight(format) * spt->base.stride +
         box->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);
d314 10
d332 1
a332 1
 * softpipe_get_transfer().
d335 1
a335 2
softpipe_transfer_destroy(struct pipe_context *pipe,
                          struct pipe_transfer *transfer)
d337 6
a342 1
   pipe_resource_reference(&transfer->resource, NULL);
d351 2
a352 2
softpipe_transfer_map(struct pipe_context *pipe,
                      struct pipe_transfer *transfer)
d354 14
a367 6
   struct softpipe_transfer *spt = softpipe_transfer(transfer);
   struct softpipe_resource *spr = softpipe_resource(transfer->resource);
   struct sw_winsys *winsys = softpipe_screen(pipe->screen)->winsys;
   uint8_t *map;
   
   /* resources backed by display target treated specially:
d369 5
a373 5
   if (spr->dt) {
      map = winsys->displaytarget_map(winsys, spr->dt, transfer->usage);
   }
   else {
      map = spr->data;
d376 5
a380 4
   if (map == NULL)
      return NULL;
   else
      return map + spt->offset;
d388 1
a388 1
softpipe_transfer_unmap(struct pipe_context *pipe,
d391 1
a391 1
   struct softpipe_resource *spr;
d393 2
a394 2
   assert(transfer->resource);
   spr = softpipe_resource(transfer->resource);
d396 1
a396 5
   if (spr->dt) {
      /* display target */
      struct sw_winsys *winsys = softpipe_screen(pipe->screen)->winsys;
      winsys->displaytarget_unmap(winsys, spr->dt);
   }
d400 1
a400 1
      spr->timestamp++;
d404 5
a408 8
/**
 * Create buffer which wraps user-space data.
 */
static struct pipe_resource *
softpipe_user_buffer_create(struct pipe_screen *screen,
                            void *ptr,
                            unsigned bytes,
			    unsigned bind_flags)
d410 5
a414 1
   struct softpipe_resource *spr;
d416 2
a417 2
   spr = CALLOC_STRUCT(softpipe_resource);
   if (!spr)
d420 31
a450 12
   pipe_reference_init(&spr->base.reference, 1);
   spr->base.screen = screen;
   spr->base.format = PIPE_FORMAT_R8_UNORM; /* ?? */
   spr->base.bind = bind_flags;
   spr->base.usage = PIPE_USAGE_IMMUTABLE;
   spr->base.flags = 0;
   spr->base.width0 = bytes;
   spr->base.height0 = 1;
   spr->base.depth0 = 1;
   spr->base.array_size = 1;
   spr->userBuffer = TRUE;
   spr->data = ptr;
d452 2
a453 1
   return &spr->base;
d458 1
a458 1
softpipe_init_texture_funcs(struct pipe_context *pipe)
d460 6
a465 4
   pipe->get_transfer = softpipe_get_transfer;
   pipe->transfer_destroy = softpipe_transfer_destroy;
   pipe->transfer_map = softpipe_transfer_map;
   pipe->transfer_unmap = softpipe_transfer_unmap;
d467 4
a470 2
   pipe->transfer_flush_region = u_default_transfer_flush_region;
   pipe->transfer_inline_write = u_default_transfer_inline_write;
d472 2
a473 2
   pipe->create_surface = softpipe_create_surface;
   pipe->surface_destroy = softpipe_surface_destroy;
d477 8
a484 2
void
softpipe_init_screen_texture_funcs(struct pipe_screen *screen)
d486 9
a494 5
   screen->resource_create = softpipe_resource_create;
   screen->resource_destroy = softpipe_resource_destroy;
   screen->resource_from_handle = softpipe_resource_from_handle;
   screen->resource_get_handle = softpipe_resource_get_handle;
   screen->user_buffer_create = softpipe_user_buffer_create;
d496 1
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d55 1
a55 2
                         struct softpipe_resource *spr,
                         boolean allocate)
a64 9
      unsigned slices;

      if (pt->target == PIPE_TEXTURE_CUBE)
         slices = 6;
      else if (pt->target == PIPE_TEXTURE_3D)
         slices = depth;
      else
         slices = pt->array_size;

d70 2
a71 1
                      slices * spr->stride[level]);
d78 1
a78 2
   if (buffer_size > SP_MAX_TEXTURE_SIZE)
      return FALSE;
d80 1
a80 22
   if (allocate) {
      spr->data = align_malloc(buffer_size, 16);
      return spr->data != NULL;
   }
   else {
      return TRUE;
   }
}


/**
 * Check the size of the texture specified by 'res'.
 * \return TRUE if OK, FALSE if too large.
 */
static boolean
softpipe_can_create_resource(struct pipe_screen *screen,
                             const struct pipe_resource *res)
{
   struct softpipe_resource spr;
   memset(&spr, 0, sizeof(spr));
   spr.base = *res;
   return softpipe_resource_layout(screen, &spr, FALSE);
d135 1
a135 1
      if (!softpipe_resource_layout(screen, spr, TRUE))
d230 1
a230 3
       spr->base.target == PIPE_TEXTURE_CUBE_ARRAY ||
       spr->base.target == PIPE_TEXTURE_3D ||
       spr->base.target == PIPE_TEXTURE_2D_ARRAY) {
a232 3
   else if (spr->base.target == PIPE_TEXTURE_1D_ARRAY) {
      offset += layer * spr->stride[level];
   }
d250 4
d261 7
a267 20
      if (pt->target != PIPE_BUFFER) {
         assert(surf_tmpl->u.tex.level <= pt->last_level);
         ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
         ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
         ps->u.tex.level = surf_tmpl->u.tex.level;
         ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
         ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
         if (ps->u.tex.first_layer != ps->u.tex.last_layer) {
            debug_printf("creating surface with multiple layers, rendering to first layer only\n");
         }
      }
      else {
         /* setting width as number of elements should get us correct renderbuffer width */
         ps->width = surf_tmpl->u.buf.last_element - surf_tmpl->u.buf.first_element + 1;
         ps->height = pt->height0;
         ps->u.buf.first_element = surf_tmpl->u.buf.first_element;
         ps->u.buf.last_element = surf_tmpl->u.buf.last_element;
         assert(ps->u.buf.first_element <= ps->u.buf.last_element);
         assert(ps->u.buf.last_element < ps->width);
      }
d295 1
a295 1
 * \param level  which mipmap level
d299 2
a300 2
static void *
softpipe_transfer_map(struct pipe_context *pipe,
d304 1
a304 2
                      const struct pipe_box *box,
                      struct pipe_transfer **transfer)
a305 1
   struct sw_winsys *winsys = softpipe_screen(pipe->screen)->winsys;
a307 5
   struct pipe_transfer *pt;
   enum pipe_format format = resource->format;
   const unsigned hgt = u_minify(spr->base.height0, level);
   const unsigned nblocksy = util_format_get_nblocksy(format, hgt);
   uint8_t *map;
d313 3
a315 19
   assert(box->x + box->width <= (int) u_minify(resource->width0, level));
   if (resource->target == PIPE_TEXTURE_1D_ARRAY) {
      assert(box->y + box->height <= (int) resource->array_size);
   }
   else {
      assert(box->y + box->height <= (int) u_minify(resource->height0, level));
      if (resource->target == PIPE_TEXTURE_2D_ARRAY) {
         assert(box->z + box->depth <= (int) resource->array_size);
      }
      else if (resource->target == PIPE_TEXTURE_CUBE) {
         assert(box->z < 6);
      }
      else if (resource->target == PIPE_TEXTURE_CUBE_ARRAY) {
         assert(box->z <= (int) resource->array_size);
      }
      else {
         assert(box->z + box->depth <= (int) u_minify(resource->depth0, level));
      }
   }
d339 18
a356 2
   if (!spt)
      return NULL;
d358 4
a361 1
   pt = &spt->base;
a362 6
   pipe_resource_reference(&pt->resource, resource);
   pt->level = level;
   pt->usage = usage;
   pt->box = *box;
   pt->stride = spr->stride[level];
   pt->layer_stride = pt->stride * nblocksy;
d364 11
a374 1
   spt->offset = sp_get_tex_image_offset(spr, level, box->z);
a375 3
   spt->offset +=
         box->y / util_format_get_blockheight(format) * spt->base.stride +
         box->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);
d377 12
d392 1
a392 1
      map = winsys->displaytarget_map(winsys, spr->dt, usage);
d398 1
a398 3
   if (map == NULL) {
      pipe_resource_reference(&pt->resource, NULL);
      FREE(spt);
d400 2
a401 4
   }

   *transfer = pt;
   return map + spt->offset;
a426 3

   pipe_resource_reference(&transfer->resource, NULL);
   FREE(transfer);
d432 1
a432 1
struct pipe_resource *
d464 2
d484 2
a485 1
   screen->can_create_resource = softpipe_can_create_resource;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2006 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d29 2
a30 2
  *   Keith Whitwell <keithw@@vmware.com>
  *   Michel DÃ¤nzer <daenzer@@vmware.com>
d63 1
a63 1
   uint64_t buffer_size = 0;
d79 2
a80 2
      buffer_size += (uint64_t) util_format_get_nblocksy(pt->format, height) *
                     slices * spr->stride[level];
d91 1
a91 1
      spr->data = align_malloc(buffer_size, 64);
d131 1
a131 1
                                          64,
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d66 1
a66 3
      unsigned slices, nblocksy;

      nblocksy = util_format_get_nblocksy(pt->format, height);
d69 2
a70 3
         assert(pt->array_size == 6);

      if (pt->target == PIPE_TEXTURE_3D)
d79 2
a80 9
      /* if row_stride * height > SP_MAX_TEXTURE_SIZE */
      if ((uint64_t)spr->stride[level] * nblocksy > SP_MAX_TEXTURE_SIZE) {
         /* image too large */
         return FALSE;
      }

      spr->img_stride[level] = spr->stride[level] * nblocksy;

      buffer_size += (uint64_t) spr->img_stride[level] * slices;
d256 2
d260 12
a271 1
   offset += layer * spr->img_stride[level];
d357 2
d417 1
a417 1
   pt->layer_stride = spr->img_stride[level];
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d66 3
a68 1
      unsigned slices;
d71 3
a73 2
         slices = 6;
      else if (pt->target == PIPE_TEXTURE_3D)
d82 9
a90 2
      buffer_size += (uint64_t) util_format_get_nblocksy(pt->format, height) *
                     slices * spr->stride[level];
a265 2
   const unsigned hgt = u_minify(spr->base.height0, level);
   const unsigned nblocksy = util_format_get_nblocksy(spr->base.format, hgt);
d268 1
a268 12
   if (spr->base.target == PIPE_TEXTURE_CUBE ||
       spr->base.target == PIPE_TEXTURE_CUBE_ARRAY ||
       spr->base.target == PIPE_TEXTURE_3D ||
       spr->base.target == PIPE_TEXTURE_2D_ARRAY) {
      offset += layer * nblocksy * spr->stride[level];
   }
   else if (spr->base.target == PIPE_TEXTURE_1D_ARRAY) {
      offset += layer * spr->stride[level];
   }
   else {
      assert(layer == 0);
   }
a353 2
   const unsigned hgt = u_minify(spr->base.height0, level);
   const unsigned nblocksy = util_format_get_nblocksy(format, hgt);
d412 1
a412 1
   pt->layer_stride = pt->stride * nblocksy;
@


