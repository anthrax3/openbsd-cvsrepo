head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.07;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.56;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.49;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.04;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * Render target tile caching.
 *
 * Author:
 *    Brian Paul
 */

#include "util/u_inlines.h"
#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_tile.h"
#include "sp_tile_cache.h"

static struct softpipe_cached_tile *
sp_alloc_tile(struct softpipe_tile_cache *tc);


/**
 * Return the position in the cache for the tile that contains win pos (x,y).
 * We currently use a direct mapped cache so this is like a hack key.
 * At some point we should investige something more sophisticated, like
 * a LRU replacement policy.
 */
#define CACHE_POS(x, y) \
   (((x) + (y) * 5) % NUM_ENTRIES)



/**
 * Is the tile at (x,y) in cleared state?
 */
static INLINE uint
is_clear_flag_set(const uint *bitvec, union tile_address addr)
{
   int pos, bit;
   pos = addr.bits.y * (MAX_WIDTH / TILE_SIZE) + addr.bits.x;
   assert(pos / 32 < (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE) / 32);
   bit = bitvec[pos / 32] & (1 << (pos & 31));
   return bit;
}
   

/**
 * Mark the tile at (x,y) as not cleared.
 */
static INLINE void
clear_clear_flag(uint *bitvec, union tile_address addr)
{
   int pos;
   pos = addr.bits.y * (MAX_WIDTH / TILE_SIZE) + addr.bits.x;
   assert(pos / 32 < (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE) / 32);
   bitvec[pos / 32] &= ~(1 << (pos & 31));
}
   

struct softpipe_tile_cache *
sp_create_tile_cache( struct pipe_context *pipe )
{
   struct softpipe_tile_cache *tc;
   uint pos;
   int maxLevels, maxTexSize;

   /* sanity checking: max sure MAX_WIDTH/HEIGHT >= largest texture image */
   maxLevels = pipe->screen->get_param(pipe->screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
   maxTexSize = 1 << (maxLevels - 1);
   assert(MAX_WIDTH >= maxTexSize);

   assert(sizeof(union tile_address) == 4);

   assert((TILE_SIZE << TILE_ADDR_BITS) >= MAX_WIDTH);

   tc = CALLOC_STRUCT( softpipe_tile_cache );
   if (tc) {
      tc->pipe = pipe;
      for (pos = 0; pos < Elements(tc->tile_addrs); pos++) {
         tc->tile_addrs[pos].bits.invalid = 1;
      }
      tc->last_tile_addr.bits.invalid = 1;

      /* this allocation allows us to guarantee that allocation
       * failures are never fatal later
       */
      tc->tile = MALLOC_STRUCT( softpipe_cached_tile );
      if (!tc->tile)
      {
         FREE(tc);
         return NULL;
      }

      /* XXX this code prevents valgrind warnings about use of uninitialized
       * memory in programs that don't clear the surface before rendering.
       * However, it breaks clearing in other situations (such as in
       * progs/tests/drawbuffers, see bug 24402).
       */
#if 0
      /* set flags to indicate all the tiles are cleared */
      memset(tc->clear_flags, 255, sizeof(tc->clear_flags));
#endif
   }
   return tc;
}


void
sp_destroy_tile_cache(struct softpipe_tile_cache *tc)
{
   if (tc) {
      uint pos;

      for (pos = 0; pos < Elements(tc->entries); pos++) {
         /*assert(tc->entries[pos].x < 0);*/
         FREE( tc->entries[pos] );
      }
      FREE( tc->tile );

      if (tc->transfer) {
         tc->pipe->transfer_unmap(tc->pipe, tc->transfer);
      }

      FREE( tc );
   }
}


/**
 * Specify the surface to cache.
 */
void
sp_tile_cache_set_surface(struct softpipe_tile_cache *tc,
                          struct pipe_surface *ps)
{
   struct pipe_context *pipe = tc->pipe;

   if (tc->transfer_map) {
      if (ps == tc->surface)
         return;

      pipe->transfer_unmap(pipe, tc->transfer);
      tc->transfer = NULL;
      tc->transfer_map = NULL;
   }

   tc->surface = ps;

   if (ps) {
      if (ps->texture->target != PIPE_BUFFER) {
         tc->transfer_map = pipe_transfer_map(pipe, ps->texture,
                                              ps->u.tex.level, ps->u.tex.first_layer,
                                              PIPE_TRANSFER_READ_WRITE |
                                              PIPE_TRANSFER_UNSYNCHRONIZED,
                                              0, 0, ps->width, ps->height,
                                              &tc->transfer);
      }
      else {
         /* can't render to buffers */
         assert(0);
      }

      tc->depth_stencil = util_format_is_depth_or_stencil(ps->format);
   }
}


/**
 * Return the transfer being cached.
 */
struct pipe_surface *
sp_tile_cache_get_surface(struct softpipe_tile_cache *tc)
{
   return tc->surface;
}


/**
 * Set pixels in a tile to the given clear color/value, float.
 */
static void
clear_tile_rgba(struct softpipe_cached_tile *tile,
                enum pipe_format format,
                const union pipe_color_union *clear_value)
{
   if (clear_value->f[0] == 0.0 &&
       clear_value->f[1] == 0.0 &&
       clear_value->f[2] == 0.0 &&
       clear_value->f[3] == 0.0) {
      memset(tile->data.color, 0, sizeof(tile->data.color));
   }
   else {
      uint i, j;

      if (util_format_is_pure_uint(format)) {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.colorui128[i][j][0] = clear_value->ui[0];
               tile->data.colorui128[i][j][1] = clear_value->ui[1];
               tile->data.colorui128[i][j][2] = clear_value->ui[2];
               tile->data.colorui128[i][j][3] = clear_value->ui[3];
            }
         }
      } else if (util_format_is_pure_sint(format)) {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.colori128[i][j][0] = clear_value->i[0];
               tile->data.colori128[i][j][1] = clear_value->i[1];
               tile->data.colori128[i][j][2] = clear_value->i[2];
               tile->data.colori128[i][j][3] = clear_value->i[3];
            }
         }
      } else {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.color[i][j][0] = clear_value->f[0];
               tile->data.color[i][j][1] = clear_value->f[1];
               tile->data.color[i][j][2] = clear_value->f[2];
               tile->data.color[i][j][3] = clear_value->f[3];
            }
         }
      }
   }
}


/**
 * Set a tile to a solid value/color.
 */
static void
clear_tile(struct softpipe_cached_tile *tile,
           enum pipe_format format,
           uint64_t clear_value)
{
   uint i, j;

   switch (util_format_get_blocksize(format)) {
   case 1:
      memset(tile->data.any, (int) clear_value, TILE_SIZE * TILE_SIZE);
      break;
   case 2:
      if (clear_value == 0) {
         memset(tile->data.any, 0, 2 * TILE_SIZE * TILE_SIZE);
      }
      else {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.depth16[i][j] = (ushort) clear_value;
            }
         }
      }
      break;
   case 4:
      if (clear_value == 0) {
         memset(tile->data.any, 0, 4 * TILE_SIZE * TILE_SIZE);
      }
      else {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.depth32[i][j] = (uint) clear_value;
            }
         }
      }
      break;
   case 8:
      if (clear_value == 0) {
         memset(tile->data.any, 0, 8 * TILE_SIZE * TILE_SIZE);
      }
      else {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.depth64[i][j] = clear_value;
            }
         }
      }
      break;
   default:
      assert(0);
   }
}


/**
 * Actually clear the tiles which were flagged as being in a clear state.
 */
static void
sp_tile_cache_flush_clear(struct softpipe_tile_cache *tc)
{
   struct pipe_transfer *pt = tc->transfer;
   const uint w = tc->transfer->box.width;
   const uint h = tc->transfer->box.height;
   uint x, y;
   uint numCleared = 0;

   assert(pt->resource);
   if (!tc->tile)
      tc->tile = sp_alloc_tile(tc);

   /* clear the scratch tile to the clear value */
   if (tc->depth_stencil) {
      clear_tile(tc->tile, pt->resource->format, tc->clear_val);
   } else {
      clear_tile_rgba(tc->tile, pt->resource->format, &tc->clear_color);
   }

   /* push the tile to all positions marked as clear */
   for (y = 0; y < h; y += TILE_SIZE) {
      for (x = 0; x < w; x += TILE_SIZE) {
         union tile_address addr = tile_address(x, y);

         if (is_clear_flag_set(tc->clear_flags, addr)) {
            /* write the scratch tile to the surface */
            if (tc->depth_stencil) {
               pipe_put_tile_raw(pt, tc->transfer_map,
                                 x, y, TILE_SIZE, TILE_SIZE,
                                 tc->tile->data.any, 0/*STRIDE*/);
            }
            else {
               if (util_format_is_pure_uint(tc->surface->format)) {
                  pipe_put_tile_ui_format(pt, tc->transfer_map,
                                          x, y, TILE_SIZE, TILE_SIZE,
                                          pt->resource->format,
                                          (unsigned *) tc->tile->data.colorui128);
               } else if (util_format_is_pure_sint(tc->surface->format)) {
                  pipe_put_tile_i_format(pt, tc->transfer_map,
                                         x, y, TILE_SIZE, TILE_SIZE,
                                         pt->resource->format,
                                         (int *) tc->tile->data.colori128);
               } else {
                  pipe_put_tile_rgba(pt, tc->transfer_map,
                                     x, y, TILE_SIZE, TILE_SIZE,
                                     (float *) tc->tile->data.color);
               }
            }
            numCleared++;
         }
      }
   }

   /* reset all clear flags to zero */
   memset(tc->clear_flags, 0, sizeof(tc->clear_flags));

#if 0
   debug_printf("num cleared: %u\n", numCleared);
#endif
}

static void
sp_flush_tile(struct softpipe_tile_cache* tc, unsigned pos)
{
   if (!tc->tile_addrs[pos].bits.invalid) {
      if (tc->depth_stencil) {
         pipe_put_tile_raw(tc->transfer, tc->transfer_map,
                           tc->tile_addrs[pos].bits.x * TILE_SIZE,
                           tc->tile_addrs[pos].bits.y * TILE_SIZE,
                           TILE_SIZE, TILE_SIZE,
                           tc->entries[pos]->data.depth32, 0/*STRIDE*/);
      }
      else {
         if (util_format_is_pure_uint(tc->surface->format)) {
            pipe_put_tile_ui_format(tc->transfer, tc->transfer_map,
                                    tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                    tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                    TILE_SIZE, TILE_SIZE,
                                    tc->surface->format,
                                    (unsigned *) tc->entries[pos]->data.colorui128);
         } else if (util_format_is_pure_sint(tc->surface->format)) {
            pipe_put_tile_i_format(tc->transfer, tc->transfer_map,
                                   tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                   tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                   TILE_SIZE, TILE_SIZE,
                                   tc->surface->format,
                                   (int *) tc->entries[pos]->data.colori128);
         } else {
            pipe_put_tile_rgba_format(tc->transfer, tc->transfer_map,
                                      tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                      tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                      TILE_SIZE, TILE_SIZE,
                                      tc->surface->format,
                                      (float *) tc->entries[pos]->data.color);
         }
      }
      tc->tile_addrs[pos].bits.invalid = 1;  /* mark as empty */
   }
}

/**
 * Flush the tile cache: write all dirty tiles back to the transfer.
 * any tiles "flagged" as cleared will be "really" cleared.
 */
void
sp_flush_tile_cache(struct softpipe_tile_cache *tc)
{
   struct pipe_transfer *pt = tc->transfer;
   int inuse = 0, pos;

   if (pt) {
      /* caching a drawing transfer */
      for (pos = 0; pos < Elements(tc->entries); pos++) {
         struct softpipe_cached_tile *tile = tc->entries[pos];
         if (!tile)
         {
            assert(tc->tile_addrs[pos].bits.invalid);
            continue;
         }

         sp_flush_tile(tc, pos);
         ++inuse;
      }

      sp_tile_cache_flush_clear(tc);


      tc->last_tile_addr.bits.invalid = 1;
   }

#if 0
   debug_printf("flushed tiles in use: %d\n", inuse);
#endif
}

static struct softpipe_cached_tile *
sp_alloc_tile(struct softpipe_tile_cache *tc)
{
   struct softpipe_cached_tile * tile = MALLOC_STRUCT(softpipe_cached_tile);
   if (!tile)
   {
      /* in this case, steal an existing tile */
      if (!tc->tile)
      {
         unsigned pos;
         for (pos = 0; pos < Elements(tc->entries); ++pos) {
            if (!tc->entries[pos])
               continue;

            sp_flush_tile(tc, pos);
            tc->tile = tc->entries[pos];
            tc->entries[pos] = NULL;
            break;
         }

         /* this should never happen */
         if (!tc->tile)
            abort();
      }

      tile = tc->tile;
      tc->tile = NULL;

      tc->last_tile_addr.bits.invalid = 1;
   }
   return tile;
}

/**
 * Get a tile from the cache.
 * \param x, y  position of tile, in pixels
 */
struct softpipe_cached_tile *
sp_find_cached_tile(struct softpipe_tile_cache *tc, 
                    union tile_address addr )
{
   struct pipe_transfer *pt = tc->transfer;
   /* cache pos/entry: */
   const int pos = CACHE_POS(addr.bits.x,
                             addr.bits.y);
   struct softpipe_cached_tile *tile = tc->entries[pos];

   if (!tile) {
      tile = sp_alloc_tile(tc);
      tc->entries[pos] = tile;
   }

   if (addr.value != tc->tile_addrs[pos].value) {

      assert(pt->resource);
      if (tc->tile_addrs[pos].bits.invalid == 0) {
         /* put dirty tile back in framebuffer */
         if (tc->depth_stencil) {
            pipe_put_tile_raw(pt, tc->transfer_map,
                              tc->tile_addrs[pos].bits.x * TILE_SIZE,
                              tc->tile_addrs[pos].bits.y * TILE_SIZE,
                              TILE_SIZE, TILE_SIZE,
                              tile->data.depth32, 0/*STRIDE*/);
         }
         else {
            if (util_format_is_pure_uint(tc->surface->format)) {
               pipe_put_tile_ui_format(pt, tc->transfer_map,
                                      tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                      tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                      TILE_SIZE, TILE_SIZE,
                                      tc->surface->format,
                                      (unsigned *) tile->data.colorui128);
            } else if (util_format_is_pure_sint(tc->surface->format)) {
               pipe_put_tile_i_format(pt, tc->transfer_map,
                                      tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                      tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                      TILE_SIZE, TILE_SIZE,
                                      tc->surface->format,
                                      (int *) tile->data.colori128);
            } else {
               pipe_put_tile_rgba_format(pt, tc->transfer_map,
                                         tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                         tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                         TILE_SIZE, TILE_SIZE,
                                         tc->surface->format,
                                         (float *) tile->data.color);
            }
         }
      }

      tc->tile_addrs[pos] = addr;

      if (is_clear_flag_set(tc->clear_flags, addr)) {
         /* don't get tile from framebuffer, just clear it */
         if (tc->depth_stencil) {
            clear_tile(tile, pt->resource->format, tc->clear_val);
         }
         else {
            clear_tile_rgba(tile, pt->resource->format, &tc->clear_color);
         }
         clear_clear_flag(tc->clear_flags, addr);
      }
      else {
         /* get new tile data from transfer */
         if (tc->depth_stencil) {
            pipe_get_tile_raw(pt, tc->transfer_map,
                              tc->tile_addrs[pos].bits.x * TILE_SIZE,
                              tc->tile_addrs[pos].bits.y * TILE_SIZE,
                              TILE_SIZE, TILE_SIZE,
                              tile->data.depth32, 0/*STRIDE*/);
         }
         else {
            if (util_format_is_pure_uint(tc->surface->format)) {
               pipe_get_tile_ui_format(pt, tc->transfer_map,
                                         tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                         tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                         TILE_SIZE, TILE_SIZE,
                                         tc->surface->format,
                                         (unsigned *) tile->data.colorui128);
            } else if (util_format_is_pure_sint(tc->surface->format)) {
               pipe_get_tile_i_format(pt, tc->transfer_map,
                                         tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                         tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                         TILE_SIZE, TILE_SIZE,
                                         tc->surface->format,
                                         (int *) tile->data.colori128);
            } else {
               pipe_get_tile_rgba_format(pt, tc->transfer_map,
                                         tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                         tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                         TILE_SIZE, TILE_SIZE,
                                         tc->surface->format,
                                         (float *) tile->data.color);
            }
         }
      }
   }

   tc->last_tile = tile;
   tc->last_tile_addr = addr;
   return tile;
}





/**
 * When a whole surface is being cleared to a value we can avoid
 * fetching tiles above.
 * Save the color and set a 'clearflag' for each tile of the screen.
 */
void
sp_tile_cache_clear(struct softpipe_tile_cache *tc,
                    const union pipe_color_union *color,
                    uint64_t clearValue)
{
   uint pos;

   tc->clear_color = *color;

   tc->clear_val = clearValue;

   /* set flags to indicate all the tiles are cleared */
   memset(tc->clear_flags, 255, sizeof(tc->clear_flags));

   for (pos = 0; pos < Elements(tc->tile_addrs); pos++) {
      tc->tile_addrs[pos].bits.invalid = 1;
   }
   tc->last_tile_addr.bits.invalid = 1;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d51 3
a53 2
#define CACHE_POS(x, y, l)                        \
   (((x) + (y) * 5 + (l) * 10) % NUM_ENTRIES)
a55 8
static INLINE int addr_to_clear_pos(union tile_address addr)
{
   int pos;
   pos = addr.bits.layer * (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE);
   pos += addr.bits.y * (MAX_WIDTH / TILE_SIZE);
   pos += addr.bits.x;
   return pos;
}
d60 1
a60 1
is_clear_flag_set(const uint *bitvec, union tile_address addr, unsigned max)
d63 2
a64 2
   pos = addr_to_clear_pos(addr);
   assert(pos / 32 < max);
d74 1
a74 1
clear_clear_flag(uint *bitvec, union tile_address addr, unsigned max)
d77 2
a78 2
   pos = addr_to_clear_pos(addr);
   assert(pos / 32 < max);
d143 2
a144 9
      if (tc->num_maps) {
         int i;
         for (i = 0; i < tc->num_maps; i++)
            if (tc->transfer[i]) {
               tc->pipe->transfer_unmap(tc->pipe, tc->transfer[i]);
            }
         FREE(tc->transfer);
         FREE(tc->transfer_map);
         FREE(tc->clear_flags);
a159 1
   int i;
d161 1
a161 1
   if (tc->num_maps) {
d165 3
a167 12
      for (i = 0; i < tc->num_maps; i++) {
         pipe->transfer_unmap(pipe, tc->transfer[i]);
         tc->transfer[i] = NULL;
         tc->transfer_map[i] = NULL;
      }
      FREE(tc->transfer);
      FREE(tc->transfer_map);
      tc->num_maps = 0;

      if (tc->clear_flags)
         FREE(tc->clear_flags);
      tc->clear_flags_size = 0;
a172 7
      tc->num_maps = ps->u.tex.last_layer - ps->u.tex.first_layer + 1;
      tc->transfer = CALLOC(tc->num_maps, sizeof(struct pipe_transfer *));
      tc->transfer_map = CALLOC(tc->num_maps, sizeof(void *));

      tc->clear_flags_size = (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE) * tc->num_maps / 32 * sizeof(uint);
      tc->clear_flags = CALLOC(1, tc->clear_flags_size);

d174 6
a179 8
         for (i = 0; i < tc->num_maps; i++) {
            tc->transfer_map[i] = pipe_transfer_map(pipe, ps->texture,
                                                    ps->u.tex.level, ps->u.tex.first_layer + i,
                                                    PIPE_TRANSFER_READ_WRITE |
                                                    PIPE_TRANSFER_UNSYNCHRONIZED,
                                                    0, 0, ps->width, ps->height,
                                                    &tc->transfer[i]);
         }
d310 1
a310 1
sp_tile_cache_flush_clear(struct softpipe_tile_cache *tc, int layer)
d312 3
a314 3
   struct pipe_transfer *pt = tc->transfer[layer];
   const uint w = tc->transfer[layer]->box.width;
   const uint h = tc->transfer[layer]->box.height;
d319 2
d332 1
a332 1
         union tile_address addr = tile_address(x, y, layer);
d334 1
a334 1
         if (is_clear_flag_set(tc->clear_flags, addr, tc->clear_flags_size)) {
d337 1
a337 1
               pipe_put_tile_raw(pt, tc->transfer_map[layer],
d343 1
a343 1
                  pipe_put_tile_ui_format(pt, tc->transfer_map[layer],
d348 1
a348 1
                  pipe_put_tile_i_format(pt, tc->transfer_map[layer],
d353 1
a353 1
                  pipe_put_tile_rgba(pt, tc->transfer_map[layer],
d363 2
a373 1
   int layer = tc->tile_addrs[pos].bits.layer;
d376 1
a376 1
         pipe_put_tile_raw(tc->transfer[layer], tc->transfer_map[layer],
d384 1
a384 1
            pipe_put_tile_ui_format(tc->transfer[layer], tc->transfer_map[layer],
d391 1
a391 1
            pipe_put_tile_i_format(tc->transfer[layer], tc->transfer_map[layer],
d398 1
a398 1
            pipe_put_tile_rgba_format(tc->transfer[layer], tc->transfer_map[layer],
d417 1
d419 2
a420 2
   int i;
   if (tc->num_maps) {
d429 1
d434 1
a434 2
      if (!tc->tile)
         tc->tile = sp_alloc_tile(tc);
a435 4
      for (i = 0; i < tc->num_maps; i++)
         sp_tile_cache_flush_clear(tc, i);
      /* reset all clear flags to zero */
      memset(tc->clear_flags, 0, tc->clear_flags_size);
d486 1
a486 1
   struct pipe_transfer *pt;
d489 1
a489 1
                             addr.bits.y, addr.bits.layer);
d491 1
a491 1
   int layer;
d499 1
a499 1
      layer = tc->tile_addrs[pos].bits.layer;
d503 1
a503 1
            pipe_put_tile_raw(tc->transfer[layer], tc->transfer_map[layer],
d511 1
a511 1
               pipe_put_tile_ui_format(tc->transfer[layer], tc->transfer_map[layer],
d518 1
a518 1
               pipe_put_tile_i_format(tc->transfer[layer], tc->transfer_map[layer],
d525 1
a525 1
               pipe_put_tile_rgba_format(tc->transfer[layer], tc->transfer_map[layer],
d537 1
a537 5
      layer = tc->tile_addrs[pos].bits.layer;
      pt = tc->transfer[layer];
      assert(pt->resource);

      if (is_clear_flag_set(tc->clear_flags, addr, tc->clear_flags_size)) {
d545 1
a545 1
         clear_clear_flag(tc->clear_flags, addr, tc->clear_flags_size);
d550 1
a550 1
            pipe_get_tile_raw(tc->transfer[layer], tc->transfer_map[layer],
d558 1
a558 1
               pipe_get_tile_ui_format(tc->transfer[layer], tc->transfer_map[layer],
d565 1
a565 1
               pipe_get_tile_i_format(tc->transfer[layer], tc->transfer_map[layer],
d572 1
a572 1
               pipe_get_tile_rgba_format(tc->transfer[layer], tc->transfer_map[layer],
d609 1
a609 1
   memset(tc->clear_flags, 255, tc->clear_flags_size);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d51 2
a52 3
#define CACHE_POS(x, y) \
   (((x) + (y) * 5) % NUM_ENTRIES)

d55 8
d67 1
a67 1
is_clear_flag_set(const uint *bitvec, union tile_address addr)
d70 2
a71 2
   pos = addr.bits.y * (MAX_WIDTH / TILE_SIZE) + addr.bits.x;
   assert(pos / 32 < (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE) / 32);
d81 1
a81 1
clear_clear_flag(uint *bitvec, union tile_address addr)
d84 2
a85 2
   pos = addr.bits.y * (MAX_WIDTH / TILE_SIZE) + addr.bits.x;
   assert(pos / 32 < (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE) / 32);
d150 9
a158 2
      if (tc->transfer) {
         tc->pipe->transfer_unmap(tc->pipe, tc->transfer);
d174 1
d176 1
a176 1
   if (tc->transfer_map) {
d180 12
a191 3
      pipe->transfer_unmap(pipe, tc->transfer);
      tc->transfer = NULL;
      tc->transfer_map = NULL;
d197 7
d205 8
a212 6
         tc->transfer_map = pipe_transfer_map(pipe, ps->texture,
                                              ps->u.tex.level, ps->u.tex.first_layer,
                                              PIPE_TRANSFER_READ_WRITE |
                                              PIPE_TRANSFER_UNSYNCHRONIZED,
                                              0, 0, ps->width, ps->height,
                                              &tc->transfer);
d343 1
a343 1
sp_tile_cache_flush_clear(struct softpipe_tile_cache *tc)
d345 3
a347 3
   struct pipe_transfer *pt = tc->transfer;
   const uint w = tc->transfer->box.width;
   const uint h = tc->transfer->box.height;
a351 2
   if (!tc->tile)
      tc->tile = sp_alloc_tile(tc);
d363 1
a363 1
         union tile_address addr = tile_address(x, y);
d365 1
a365 1
         if (is_clear_flag_set(tc->clear_flags, addr)) {
d368 1
a368 1
               pipe_put_tile_raw(pt, tc->transfer_map,
d374 1
a374 1
                  pipe_put_tile_ui_format(pt, tc->transfer_map,
d379 1
a379 1
                  pipe_put_tile_i_format(pt, tc->transfer_map,
d384 1
a384 1
                  pipe_put_tile_rgba(pt, tc->transfer_map,
a393 2
   /* reset all clear flags to zero */
   memset(tc->clear_flags, 0, sizeof(tc->clear_flags));
d403 1
d406 1
a406 1
         pipe_put_tile_raw(tc->transfer, tc->transfer_map,
d414 1
a414 1
            pipe_put_tile_ui_format(tc->transfer, tc->transfer_map,
d421 1
a421 1
            pipe_put_tile_i_format(tc->transfer, tc->transfer_map,
d428 1
a428 1
            pipe_put_tile_rgba_format(tc->transfer, tc->transfer_map,
a446 1
   struct pipe_transfer *pt = tc->transfer;
d448 2
a449 2

   if (pt) {
a457 1

d462 2
a463 1
      sp_tile_cache_flush_clear(tc);
d465 4
d519 1
a519 1
   struct pipe_transfer *pt = tc->transfer;
d522 1
a522 1
                             addr.bits.y);
d524 1
a524 1

d532 1
a532 1
      assert(pt->resource);
d536 1
a536 1
            pipe_put_tile_raw(pt, tc->transfer_map,
d544 1
a544 1
               pipe_put_tile_ui_format(pt, tc->transfer_map,
d551 1
a551 1
               pipe_put_tile_i_format(pt, tc->transfer_map,
d558 1
a558 1
               pipe_put_tile_rgba_format(pt, tc->transfer_map,
d570 5
a574 1
      if (is_clear_flag_set(tc->clear_flags, addr)) {
d582 1
a582 1
         clear_clear_flag(tc->clear_flags, addr);
d587 1
a587 1
            pipe_get_tile_raw(pt, tc->transfer_map,
d595 1
a595 1
               pipe_get_tile_ui_format(pt, tc->transfer_map,
d602 1
a602 1
               pipe_get_tile_i_format(pt, tc->transfer_map,
d609 1
a609 1
               pipe_get_tile_rgba_format(pt, tc->transfer_map,
d646 1
a646 1
   memset(tc->clear_flags, 255, sizeof(tc->clear_flags));
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d102 1
a102 1
      for (pos = 0; pos < NUM_ENTRIES; pos++) {
d137 1
a137 1
      for (pos = 0; pos < NUM_ENTRIES; pos++) {
d144 1
a144 1
         tc->pipe->transfer_destroy(tc->pipe, tc->transfer);
d161 1
a161 1
   if (tc->transfer) {
d165 1
a165 6
      if (tc->transfer_map) {
         pipe->transfer_unmap(pipe, tc->transfer);
         tc->transfer_map = NULL;
      }

      pipe->transfer_destroy(pipe, tc->transfer);
d167 1
d173 14
a186 13
      tc->transfer = pipe_get_transfer(pipe, ps->texture,
                                       ps->u.tex.level, ps->u.tex.first_layer,
                                       PIPE_TRANSFER_READ_WRITE |
                                       PIPE_TRANSFER_UNSYNCHRONIZED,
                                       0, 0, ps->width, ps->height);

      tc->depth_stencil = (ps->format == PIPE_FORMAT_Z24_UNORM_S8_USCALED ||
                           ps->format == PIPE_FORMAT_Z24X8_UNORM ||
                           ps->format == PIPE_FORMAT_S8_USCALED_Z24_UNORM ||
                           ps->format == PIPE_FORMAT_X8Z24_UNORM ||
                           ps->format == PIPE_FORMAT_Z16_UNORM ||
                           ps->format == PIPE_FORMAT_Z32_UNORM ||
                           ps->format == PIPE_FORMAT_S8_USCALED);
a200 18
void
sp_tile_cache_map_transfers(struct softpipe_tile_cache *tc)
{
   if (tc->transfer && !tc->transfer_map)
      tc->transfer_map = tc->pipe->transfer_map(tc->pipe, tc->transfer);
}


void
sp_tile_cache_unmap_transfers(struct softpipe_tile_cache *tc)
{
   if (tc->transfer_map) {
      tc->pipe->transfer_unmap(tc->pipe, tc->transfer);
      tc->transfer_map = NULL;
   }
}


d207 1
a207 1
                const float clear_value[4])
d209 4
a212 4
   if (clear_value[0] == 0.0 &&
       clear_value[1] == 0.0 &&
       clear_value[2] == 0.0 &&
       clear_value[3] == 0.0) {
d217 27
a243 6
      for (i = 0; i < TILE_SIZE; i++) {
         for (j = 0; j < TILE_SIZE; j++) {
            tile->data.color[i][j][0] = clear_value[0];
            tile->data.color[i][j][1] = clear_value[1];
            tile->data.color[i][j][2] = clear_value[2];
            tile->data.color[i][j][3] = clear_value[3];
d256 1
a256 1
           uint clear_value)
d262 1
a262 1
      memset(tile->data.any, clear_value, TILE_SIZE * TILE_SIZE);
d283 13
a295 1
               tile->data.color32[i][j] = clear_value;
d326 1
a326 1
      clear_tile_rgba(tc->tile, pt->resource->format, tc->clear_color);
d337 1
a337 2
               pipe_put_tile_raw(tc->pipe,
                                 pt,
d342 15
a356 3
               pipe_put_tile_rgba(tc->pipe, pt,
                                  x, y, TILE_SIZE, TILE_SIZE,
                                  (float *) tc->tile->data.color);
d376 1
a376 1
         pipe_put_tile_raw(tc->pipe, tc->transfer,
d383 9
a391 1
         pipe_put_tile_rgba_format(tc->pipe, tc->transfer,
d396 9
a404 1
                                   (float *) tc->entries[pos]->data.color);
d422 1
a422 1
      for (pos = 0; pos < NUM_ENTRIES; pos++) {
d455 1
a455 1
         for (pos = 0; pos < NUM_ENTRIES; ++pos) {
a486 1
   
d503 1
a503 1
            pipe_put_tile_raw(tc->pipe, pt,
d510 2
a511 1
            pipe_put_tile_rgba_format(tc->pipe, pt,
d516 16
a531 1
                                      (float *) tile->data.color);
d543 1
a543 1
            clear_tile_rgba(tile, pt->resource->format, tc->clear_color);
d550 1
a550 1
            pipe_get_tile_raw(tc->pipe, pt,
d557 22
a578 5
            pipe_get_tile_rgba(tc->pipe, pt,
                               tc->tile_addrs[pos].bits.x * TILE_SIZE,
                               tc->tile_addrs[pos].bits.y * TILE_SIZE,
                               TILE_SIZE, TILE_SIZE,
                               (float *) tile->data.color);
d598 3
a600 2
sp_tile_cache_clear(struct softpipe_tile_cache *tc, const float *rgba,
                    uint clearValue)
d604 1
a604 4
   tc->clear_color[0] = rgba[0];
   tc->clear_color[1] = rgba[1];
   tc->clear_color[2] = rgba[2];
   tc->clear_color[3] = rgba[3];
d611 1
a611 1
   for (pos = 0; pos < NUM_ENTRIES; pos++) {
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d360 6
a365 5
         pipe_put_tile_rgba(tc->pipe, tc->transfer,
                            tc->tile_addrs[pos].bits.x * TILE_SIZE,
                            tc->tile_addrs[pos].bits.y * TILE_SIZE,
                            TILE_SIZE, TILE_SIZE,
                            (float *) tc->entries[pos]->data.color);
d472 6
a477 5
            pipe_put_tile_rgba(tc->pipe, pt,
                               tc->tile_addrs[pos].bits.x * TILE_SIZE,
                               tc->tile_addrs[pos].bits.y * TILE_SIZE,
                               TILE_SIZE, TILE_SIZE,
                               (float *) tile->data.color);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d41 2
d84 1
a84 1
sp_create_tile_cache( struct pipe_screen *screen )
d91 1
a91 1
   maxLevels = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
d95 4
d101 1
a101 1
      tc->screen = screen;
d103 12
a114 1
         tc->entries[pos].addr.bits.invalid = 1;
a115 1
      tc->last_tile = &tc->entries[0]; /* any tile */
d122 1
a122 1
#if 0 && TILE_CLEAR_OPTIMIZATION
d134 12
a145 2
   struct pipe_screen *screen;
   uint pos;
d147 1
a147 2
   for (pos = 0; pos < NUM_ENTRIES; pos++) {
      /*assert(tc->entries[pos].x < 0);*/
a148 6
   if (tc->transfer) {
      screen = tc->transfer->texture->screen;
      screen->tex_transfer_destroy(tc->transfer);
   }

   FREE( tc );
d159 2
a161 2
      struct pipe_screen *screen = tc->transfer->texture->screen;

d166 1
a166 1
         screen->transfer_unmap(screen, tc->transfer);
d170 1
a170 1
      screen->tex_transfer_destroy(tc->transfer);
d177 5
a181 6
      struct pipe_screen *screen = ps->texture->screen;

      tc->transfer = screen->get_tex_transfer(screen, ps->texture, ps->face,
                                              ps->level, ps->zslice,
                                              PIPE_TRANSFER_READ_WRITE,
                                              0, 0, ps->width, ps->height);
d183 1
a183 1
      tc->depth_stencil = (ps->format == PIPE_FORMAT_Z24S8_UNORM ||
d185 1
a185 1
                           ps->format == PIPE_FORMAT_S8Z24_UNORM ||
d189 1
a189 1
                           ps->format == PIPE_FORMAT_S8_UNORM);
d208 1
a208 1
      tc->transfer_map = tc->screen->transfer_map(tc->screen, tc->transfer);
d216 1
a216 1
      tc->screen->transfer_unmap(tc->screen, tc->transfer);
d301 2
a302 2
   const uint w = tc->transfer->width;
   const uint h = tc->transfer->height;
d306 4
a309 1
   assert(pt->texture);
d311 5
a315 1
   clear_tile(&tc->tile, pt->texture->format, tc->clear_val);
d323 12
a334 4
            pipe_put_tile_raw(pt,
                              x, y, TILE_SIZE, TILE_SIZE,
                              tc->tile.data.color32, 0/*STRIDE*/);

d348 21
d383 5
a387 18
         struct softpipe_cached_tile *tile = tc->entries + pos;
         if (!tile->addr.bits.invalid) {
            if (tc->depth_stencil) {
               pipe_put_tile_raw(pt,
                                 tile->addr.bits.x * TILE_SIZE, 
                                 tile->addr.bits.y * TILE_SIZE, 
                                 TILE_SIZE, TILE_SIZE,
                                 tile->data.depth32, 0/*STRIDE*/);
            }
            else {
               pipe_put_tile_rgba(pt,
                                  tile->addr.bits.x * TILE_SIZE, 
                                  tile->addr.bits.y * TILE_SIZE, 
                                  TILE_SIZE, TILE_SIZE,
                                  (float *) tile->data.color);
            }
            tile->addr.bits.invalid = 1;  /* mark as empty */
            inuse++;
d389 3
a393 1
#if TILE_CLEAR_OPTIMIZATION
d395 3
a397 1
#endif
d405 32
d451 6
a456 1
   struct softpipe_cached_tile *tile = tc->entries + pos;
d458 1
a458 1
   if (addr.value != tile->addr.value) {
d460 2
a461 2
      assert(pt->texture);
      if (tile->addr.bits.invalid == 0) {
d464 3
a466 3
            pipe_put_tile_raw(pt,
                              tile->addr.bits.x * TILE_SIZE,
                              tile->addr.bits.y * TILE_SIZE,
d471 3
a473 3
            pipe_put_tile_rgba(pt,
                               tile->addr.bits.x * TILE_SIZE,
                               tile->addr.bits.y * TILE_SIZE,
d479 1
a479 1
      tile->addr = addr;
d484 1
a484 1
            clear_tile(tile, pt->texture->format, tc->clear_val);
d487 1
a487 1
            clear_tile_rgba(tile, pt->texture->format, tc->clear_color);
d494 3
a496 3
            pipe_get_tile_raw(pt,
                              tile->addr.bits.x * TILE_SIZE, 
                              tile->addr.bits.y * TILE_SIZE, 
d501 3
a503 3
            pipe_get_tile_rgba(pt,
                               tile->addr.bits.x * TILE_SIZE, 
                               tile->addr.bits.y * TILE_SIZE,
d511 1
a536 1
#if TILE_CLEAR_OPTIMIZATION
a538 4
#else
   /* disable the optimization */
   memset(tc->clear_flags, 0, sizeof(tc->clear_flags));
#endif
d541 1
a541 2
      struct softpipe_cached_tile *tile = tc->entries + pos;
      tile->addr.bits.invalid = 1;
d543 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a40 2
static struct softpipe_cached_tile *
sp_alloc_tile(struct softpipe_tile_cache *tc);
d82 1
a82 1
sp_create_tile_cache( struct pipe_context *pipe )
d89 1
a89 1
   maxLevels = pipe->screen->get_param(pipe->screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
a92 4
   assert(sizeof(union tile_address) == 4);

   assert((TILE_SIZE << TILE_ADDR_BITS) >= MAX_WIDTH);

d95 1
a95 1
      tc->pipe = pipe;
d97 1
a97 12
         tc->tile_addrs[pos].bits.invalid = 1;
      }
      tc->last_tile_addr.bits.invalid = 1;

      /* this allocation allows us to guarantee that allocation
       * failures are never fatal later
       */
      tc->tile = MALLOC_STRUCT( softpipe_cached_tile );
      if (!tc->tile)
      {
         FREE(tc);
         return NULL;
d99 1
d106 1
a106 1
#if 0
d118 2
a119 2
   if (tc) {
      uint pos;
d121 7
a127 5
      for (pos = 0; pos < NUM_ENTRIES; pos++) {
         /*assert(tc->entries[pos].x < 0);*/
         FREE( tc->entries[pos] );
      }
      FREE( tc->tile );
d129 1
a129 6
      if (tc->transfer) {
         tc->pipe->transfer_destroy(tc->pipe, tc->transfer);
      }

      FREE( tc );
   }
d140 2
a141 1
   struct pipe_context *pipe = tc->pipe;
a142 1
   if (tc->transfer) {
d147 1
a147 1
         pipe->transfer_unmap(pipe, tc->transfer);
d151 1
a151 1
      pipe->transfer_destroy(pipe, tc->transfer);
d158 6
a163 5
      tc->transfer = pipe_get_transfer(pipe, ps->texture,
                                       ps->u.tex.level, ps->u.tex.first_layer,
                                       PIPE_TRANSFER_READ_WRITE |
                                       PIPE_TRANSFER_UNSYNCHRONIZED,
                                       0, 0, ps->width, ps->height);
d165 1
a165 1
      tc->depth_stencil = (ps->format == PIPE_FORMAT_Z24_UNORM_S8_USCALED ||
d167 1
a167 1
                           ps->format == PIPE_FORMAT_S8_USCALED_Z24_UNORM ||
d171 1
a171 1
                           ps->format == PIPE_FORMAT_S8_USCALED);
d190 1
a190 1
      tc->transfer_map = tc->pipe->transfer_map(tc->pipe, tc->transfer);
d198 1
a198 1
      tc->pipe->transfer_unmap(tc->pipe, tc->transfer);
d283 2
a284 2
   const uint w = tc->transfer->box.width;
   const uint h = tc->transfer->box.height;
d288 1
a288 4
   assert(pt->resource);
   if (!tc->tile)
      tc->tile = sp_alloc_tile(tc);

d290 1
a290 5
   if (tc->depth_stencil) {
      clear_tile(tc->tile, pt->resource->format, tc->clear_val);
   } else {
      clear_tile_rgba(tc->tile, pt->resource->format, tc->clear_color);
   }
d298 4
a301 12
            /* write the scratch tile to the surface */
            if (tc->depth_stencil) {
               pipe_put_tile_raw(tc->pipe,
                                 pt,
                                 x, y, TILE_SIZE, TILE_SIZE,
                                 tc->tile->data.any, 0/*STRIDE*/);
            }
            else {
               pipe_put_tile_rgba(tc->pipe, pt,
                                  x, y, TILE_SIZE, TILE_SIZE,
                                  (float *) tc->tile->data.color);
            }
a314 21
static void
sp_flush_tile(struct softpipe_tile_cache* tc, unsigned pos)
{
   if (!tc->tile_addrs[pos].bits.invalid) {
      if (tc->depth_stencil) {
         pipe_put_tile_raw(tc->pipe, tc->transfer,
                           tc->tile_addrs[pos].bits.x * TILE_SIZE,
                           tc->tile_addrs[pos].bits.y * TILE_SIZE,
                           TILE_SIZE, TILE_SIZE,
                           tc->entries[pos]->data.depth32, 0/*STRIDE*/);
      }
      else {
         pipe_put_tile_rgba(tc->pipe, tc->transfer,
                            tc->tile_addrs[pos].bits.x * TILE_SIZE,
                            tc->tile_addrs[pos].bits.y * TILE_SIZE,
                            TILE_SIZE, TILE_SIZE,
                            (float *) tc->entries[pos]->data.color);
      }
      tc->tile_addrs[pos].bits.invalid = 1;  /* mark as empty */
   }
}
d329 18
a346 5
         struct softpipe_cached_tile *tile = tc->entries[pos];
         if (!tile)
         {
            assert(tc->tile_addrs[pos].bits.invalid);
            continue;
a347 3

         sp_flush_tile(tc, pos);
         ++inuse;
d350 1
d352 1
a352 3


      tc->last_tile_addr.bits.invalid = 1;
a359 32
static struct softpipe_cached_tile *
sp_alloc_tile(struct softpipe_tile_cache *tc)
{
   struct softpipe_cached_tile * tile = MALLOC_STRUCT(softpipe_cached_tile);
   if (!tile)
   {
      /* in this case, steal an existing tile */
      if (!tc->tile)
      {
         unsigned pos;
         for (pos = 0; pos < NUM_ENTRIES; ++pos) {
            if (!tc->entries[pos])
               continue;

            sp_flush_tile(tc, pos);
            tc->tile = tc->entries[pos];
            tc->entries[pos] = NULL;
            break;
         }

         /* this should never happen */
         if (!tc->tile)
            abort();
      }

      tile = tc->tile;
      tc->tile = NULL;

      tc->last_tile_addr.bits.invalid = 1;
   }
   return tile;
}
d374 1
a374 6
   struct softpipe_cached_tile *tile = tc->entries[pos];

   if (!tile) {
      tile = sp_alloc_tile(tc);
      tc->entries[pos] = tile;
   }
d376 1
a376 1
   if (addr.value != tc->tile_addrs[pos].value) {
d378 2
a379 2
      assert(pt->resource);
      if (tc->tile_addrs[pos].bits.invalid == 0) {
d382 3
a384 3
            pipe_put_tile_raw(tc->pipe, pt,
                              tc->tile_addrs[pos].bits.x * TILE_SIZE,
                              tc->tile_addrs[pos].bits.y * TILE_SIZE,
d389 3
a391 3
            pipe_put_tile_rgba(tc->pipe, pt,
                               tc->tile_addrs[pos].bits.x * TILE_SIZE,
                               tc->tile_addrs[pos].bits.y * TILE_SIZE,
d397 1
a397 1
      tc->tile_addrs[pos] = addr;
d402 1
a402 1
            clear_tile(tile, pt->resource->format, tc->clear_val);
d405 1
a405 1
            clear_tile_rgba(tile, pt->resource->format, tc->clear_color);
d412 3
a414 3
            pipe_get_tile_raw(tc->pipe, pt,
                              tc->tile_addrs[pos].bits.x * TILE_SIZE,
                              tc->tile_addrs[pos].bits.y * TILE_SIZE,
d419 3
a421 3
            pipe_get_tile_rgba(tc->pipe, pt,
                               tc->tile_addrs[pos].bits.x * TILE_SIZE,
                               tc->tile_addrs[pos].bits.y * TILE_SIZE,
a428 1
   tc->last_tile_addr = addr;
d454 1
d457 4
d463 2
a464 1
      tc->tile_addrs[pos].bits.invalid = 1;
a465 1
   tc->last_tile_addr.bits.invalid = 1;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d102 1
a102 1
      for (pos = 0; pos < Elements(tc->tile_addrs); pos++) {
d137 1
a137 1
      for (pos = 0; pos < Elements(tc->entries); pos++) {
d144 1
a144 1
         tc->pipe->transfer_unmap(tc->pipe, tc->transfer);
d161 1
a161 1
   if (tc->transfer_map) {
d165 6
a170 1
      pipe->transfer_unmap(pipe, tc->transfer);
a171 1
      tc->transfer_map = NULL;
d177 13
a189 14
      if (ps->texture->target != PIPE_BUFFER) {
         tc->transfer_map = pipe_transfer_map(pipe, ps->texture,
                                              ps->u.tex.level, ps->u.tex.first_layer,
                                              PIPE_TRANSFER_READ_WRITE |
                                              PIPE_TRANSFER_UNSYNCHRONIZED,
                                              0, 0, ps->width, ps->height,
                                              &tc->transfer);
      }
      else {
         /* can't render to buffers */
         assert(0);
      }

      tc->depth_stencil = util_format_is_depth_or_stencil(ps->format);
d204 18
d228 1
a228 1
                const union pipe_color_union *clear_value)
d230 4
a233 4
   if (clear_value->f[0] == 0.0 &&
       clear_value->f[1] == 0.0 &&
       clear_value->f[2] == 0.0 &&
       clear_value->f[3] == 0.0) {
d238 6
a243 27

      if (util_format_is_pure_uint(format)) {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.colorui128[i][j][0] = clear_value->ui[0];
               tile->data.colorui128[i][j][1] = clear_value->ui[1];
               tile->data.colorui128[i][j][2] = clear_value->ui[2];
               tile->data.colorui128[i][j][3] = clear_value->ui[3];
            }
         }
      } else if (util_format_is_pure_sint(format)) {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.colori128[i][j][0] = clear_value->i[0];
               tile->data.colori128[i][j][1] = clear_value->i[1];
               tile->data.colori128[i][j][2] = clear_value->i[2];
               tile->data.colori128[i][j][3] = clear_value->i[3];
            }
         }
      } else {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.color[i][j][0] = clear_value->f[0];
               tile->data.color[i][j][1] = clear_value->f[1];
               tile->data.color[i][j][2] = clear_value->f[2];
               tile->data.color[i][j][3] = clear_value->f[3];
            }
d256 1
a256 1
           uint64_t clear_value)
d262 1
a262 1
      memset(tile->data.any, (int) clear_value, TILE_SIZE * TILE_SIZE);
d283 1
a283 13
               tile->data.depth32[i][j] = (uint) clear_value;
            }
         }
      }
      break;
   case 8:
      if (clear_value == 0) {
         memset(tile->data.any, 0, 8 * TILE_SIZE * TILE_SIZE);
      }
      else {
         for (i = 0; i < TILE_SIZE; i++) {
            for (j = 0; j < TILE_SIZE; j++) {
               tile->data.depth64[i][j] = clear_value;
d314 1
a314 1
      clear_tile_rgba(tc->tile, pt->resource->format, &tc->clear_color);
d325 2
a326 1
               pipe_put_tile_raw(pt, tc->transfer_map,
d331 3
a333 15
               if (util_format_is_pure_uint(tc->surface->format)) {
                  pipe_put_tile_ui_format(pt, tc->transfer_map,
                                          x, y, TILE_SIZE, TILE_SIZE,
                                          pt->resource->format,
                                          (unsigned *) tc->tile->data.colorui128);
               } else if (util_format_is_pure_sint(tc->surface->format)) {
                  pipe_put_tile_i_format(pt, tc->transfer_map,
                                         x, y, TILE_SIZE, TILE_SIZE,
                                         pt->resource->format,
                                         (int *) tc->tile->data.colori128);
               } else {
                  pipe_put_tile_rgba(pt, tc->transfer_map,
                                     x, y, TILE_SIZE, TILE_SIZE,
                                     (float *) tc->tile->data.color);
               }
d353 1
a353 1
         pipe_put_tile_raw(tc->transfer, tc->transfer_map,
d360 5
a364 22
         if (util_format_is_pure_uint(tc->surface->format)) {
            pipe_put_tile_ui_format(tc->transfer, tc->transfer_map,
                                    tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                    tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                    TILE_SIZE, TILE_SIZE,
                                    tc->surface->format,
                                    (unsigned *) tc->entries[pos]->data.colorui128);
         } else if (util_format_is_pure_sint(tc->surface->format)) {
            pipe_put_tile_i_format(tc->transfer, tc->transfer_map,
                                   tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                   tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                   TILE_SIZE, TILE_SIZE,
                                   tc->surface->format,
                                   (int *) tc->entries[pos]->data.colori128);
         } else {
            pipe_put_tile_rgba_format(tc->transfer, tc->transfer_map,
                                      tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                      tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                      TILE_SIZE, TILE_SIZE,
                                      tc->surface->format,
                                      (float *) tc->entries[pos]->data.color);
         }
d382 1
a382 1
      for (pos = 0; pos < Elements(tc->entries); pos++) {
d415 1
a415 1
         for (pos = 0; pos < Elements(tc->entries); ++pos) {
d447 1
d464 1
a464 1
            pipe_put_tile_raw(pt, tc->transfer_map,
d471 5
a475 22
            if (util_format_is_pure_uint(tc->surface->format)) {
               pipe_put_tile_ui_format(pt, tc->transfer_map,
                                      tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                      tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                      TILE_SIZE, TILE_SIZE,
                                      tc->surface->format,
                                      (unsigned *) tile->data.colorui128);
            } else if (util_format_is_pure_sint(tc->surface->format)) {
               pipe_put_tile_i_format(pt, tc->transfer_map,
                                      tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                      tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                      TILE_SIZE, TILE_SIZE,
                                      tc->surface->format,
                                      (int *) tile->data.colori128);
            } else {
               pipe_put_tile_rgba_format(pt, tc->transfer_map,
                                         tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                         tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                         TILE_SIZE, TILE_SIZE,
                                         tc->surface->format,
                                         (float *) tile->data.color);
            }
d487 1
a487 1
            clear_tile_rgba(tile, pt->resource->format, &tc->clear_color);
d494 1
a494 1
            pipe_get_tile_raw(pt, tc->transfer_map,
d501 5
a505 22
            if (util_format_is_pure_uint(tc->surface->format)) {
               pipe_get_tile_ui_format(pt, tc->transfer_map,
                                         tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                         tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                         TILE_SIZE, TILE_SIZE,
                                         tc->surface->format,
                                         (unsigned *) tile->data.colorui128);
            } else if (util_format_is_pure_sint(tc->surface->format)) {
               pipe_get_tile_i_format(pt, tc->transfer_map,
                                         tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                         tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                         TILE_SIZE, TILE_SIZE,
                                         tc->surface->format,
                                         (int *) tile->data.colori128);
            } else {
               pipe_get_tile_rgba_format(pt, tc->transfer_map,
                                         tc->tile_addrs[pos].bits.x * TILE_SIZE,
                                         tc->tile_addrs[pos].bits.y * TILE_SIZE,
                                         TILE_SIZE, TILE_SIZE,
                                         tc->surface->format,
                                         (float *) tile->data.color);
            }
d525 2
a526 3
sp_tile_cache_clear(struct softpipe_tile_cache *tc,
                    const union pipe_color_union *color,
                    uint64_t clearValue)
d530 4
a533 1
   tc->clear_color = *color;
d540 1
a540 1
   for (pos = 0; pos < Elements(tc->tile_addrs); pos++) {
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d51 3
a53 2
#define CACHE_POS(x, y, l)                        \
   (((x) + (y) * 5 + (l) * 10) % NUM_ENTRIES)
a55 8
static INLINE int addr_to_clear_pos(union tile_address addr)
{
   int pos;
   pos = addr.bits.layer * (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE);
   pos += addr.bits.y * (MAX_WIDTH / TILE_SIZE);
   pos += addr.bits.x;
   return pos;
}
d60 1
a60 1
is_clear_flag_set(const uint *bitvec, union tile_address addr, unsigned max)
d63 2
a64 2
   pos = addr_to_clear_pos(addr);
   assert(pos / 32 < max);
d74 1
a74 1
clear_clear_flag(uint *bitvec, union tile_address addr, unsigned max)
d77 2
a78 2
   pos = addr_to_clear_pos(addr);
   assert(pos / 32 < max);
d143 2
a144 9
      if (tc->num_maps) {
         int i;
         for (i = 0; i < tc->num_maps; i++)
            if (tc->transfer[i]) {
               tc->pipe->transfer_unmap(tc->pipe, tc->transfer[i]);
            }
         FREE(tc->transfer);
         FREE(tc->transfer_map);
         FREE(tc->clear_flags);
a159 1
   int i;
d161 1
a161 1
   if (tc->num_maps) {
d165 3
a167 12
      for (i = 0; i < tc->num_maps; i++) {
         pipe->transfer_unmap(pipe, tc->transfer[i]);
         tc->transfer[i] = NULL;
         tc->transfer_map[i] = NULL;
      }
      FREE(tc->transfer);
      FREE(tc->transfer_map);
      tc->num_maps = 0;

      if (tc->clear_flags)
         FREE(tc->clear_flags);
      tc->clear_flags_size = 0;
a172 7
      tc->num_maps = ps->u.tex.last_layer - ps->u.tex.first_layer + 1;
      tc->transfer = CALLOC(tc->num_maps, sizeof(struct pipe_transfer *));
      tc->transfer_map = CALLOC(tc->num_maps, sizeof(void *));

      tc->clear_flags_size = (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE) * tc->num_maps / 32 * sizeof(uint);
      tc->clear_flags = CALLOC(1, tc->clear_flags_size);

d174 6
a179 8
         for (i = 0; i < tc->num_maps; i++) {
            tc->transfer_map[i] = pipe_transfer_map(pipe, ps->texture,
                                                    ps->u.tex.level, ps->u.tex.first_layer + i,
                                                    PIPE_TRANSFER_READ_WRITE |
                                                    PIPE_TRANSFER_UNSYNCHRONIZED,
                                                    0, 0, ps->width, ps->height,
                                                    &tc->transfer[i]);
         }
d310 1
a310 1
sp_tile_cache_flush_clear(struct softpipe_tile_cache *tc, int layer)
d312 3
a314 3
   struct pipe_transfer *pt = tc->transfer[layer];
   const uint w = tc->transfer[layer]->box.width;
   const uint h = tc->transfer[layer]->box.height;
d319 2
d332 1
a332 1
         union tile_address addr = tile_address(x, y, layer);
d334 1
a334 1
         if (is_clear_flag_set(tc->clear_flags, addr, tc->clear_flags_size)) {
d337 1
a337 1
               pipe_put_tile_raw(pt, tc->transfer_map[layer],
d343 1
a343 1
                  pipe_put_tile_ui_format(pt, tc->transfer_map[layer],
d348 1
a348 1
                  pipe_put_tile_i_format(pt, tc->transfer_map[layer],
d353 1
a353 1
                  pipe_put_tile_rgba(pt, tc->transfer_map[layer],
d363 2
a373 1
   int layer = tc->tile_addrs[pos].bits.layer;
d376 1
a376 1
         pipe_put_tile_raw(tc->transfer[layer], tc->transfer_map[layer],
d384 1
a384 1
            pipe_put_tile_ui_format(tc->transfer[layer], tc->transfer_map[layer],
d391 1
a391 1
            pipe_put_tile_i_format(tc->transfer[layer], tc->transfer_map[layer],
d398 1
a398 1
            pipe_put_tile_rgba_format(tc->transfer[layer], tc->transfer_map[layer],
d417 1
d419 2
a420 2
   int i;
   if (tc->num_maps) {
d429 1
d434 1
a434 2
      if (!tc->tile)
         tc->tile = sp_alloc_tile(tc);
a435 4
      for (i = 0; i < tc->num_maps; i++)
         sp_tile_cache_flush_clear(tc, i);
      /* reset all clear flags to zero */
      memset(tc->clear_flags, 0, tc->clear_flags_size);
d486 1
a486 1
   struct pipe_transfer *pt;
d489 1
a489 1
                             addr.bits.y, addr.bits.layer);
d491 1
a491 1
   int layer;
d499 1
a499 1
      layer = tc->tile_addrs[pos].bits.layer;
d503 1
a503 1
            pipe_put_tile_raw(tc->transfer[layer], tc->transfer_map[layer],
d511 1
a511 1
               pipe_put_tile_ui_format(tc->transfer[layer], tc->transfer_map[layer],
d518 1
a518 1
               pipe_put_tile_i_format(tc->transfer[layer], tc->transfer_map[layer],
d525 1
a525 1
               pipe_put_tile_rgba_format(tc->transfer[layer], tc->transfer_map[layer],
d537 1
a537 5
      layer = tc->tile_addrs[pos].bits.layer;
      pt = tc->transfer[layer];
      assert(pt->resource);

      if (is_clear_flag_set(tc->clear_flags, addr, tc->clear_flags_size)) {
d545 1
a545 1
         clear_clear_flag(tc->clear_flags, addr, tc->clear_flags_size);
d550 1
a550 1
            pipe_get_tile_raw(tc->transfer[layer], tc->transfer_map[layer],
d558 1
a558 1
               pipe_get_tile_ui_format(tc->transfer[layer], tc->transfer_map[layer],
d565 1
a565 1
               pipe_get_tile_i_format(tc->transfer[layer], tc->transfer_map[layer],
d572 1
a572 1
               pipe_get_tile_rgba_format(tc->transfer[layer], tc->transfer_map[layer],
d609 1
a609 1
   memset(tc->clear_flags, 255, tc->clear_flags_size);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d51 2
a52 3
#define CACHE_POS(x, y) \
   (((x) + (y) * 5) % NUM_ENTRIES)

d55 8
d67 1
a67 1
is_clear_flag_set(const uint *bitvec, union tile_address addr)
d70 2
a71 2
   pos = addr.bits.y * (MAX_WIDTH / TILE_SIZE) + addr.bits.x;
   assert(pos / 32 < (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE) / 32);
d81 1
a81 1
clear_clear_flag(uint *bitvec, union tile_address addr)
d84 2
a85 2
   pos = addr.bits.y * (MAX_WIDTH / TILE_SIZE) + addr.bits.x;
   assert(pos / 32 < (MAX_WIDTH / TILE_SIZE) * (MAX_HEIGHT / TILE_SIZE) / 32);
d150 9
a158 2
      if (tc->transfer) {
         tc->pipe->transfer_unmap(tc->pipe, tc->transfer);
d174 1
d176 1
a176 1
   if (tc->transfer_map) {
d180 12
a191 3
      pipe->transfer_unmap(pipe, tc->transfer);
      tc->transfer = NULL;
      tc->transfer_map = NULL;
d197 7
d205 8
a212 6
         tc->transfer_map = pipe_transfer_map(pipe, ps->texture,
                                              ps->u.tex.level, ps->u.tex.first_layer,
                                              PIPE_TRANSFER_READ_WRITE |
                                              PIPE_TRANSFER_UNSYNCHRONIZED,
                                              0, 0, ps->width, ps->height,
                                              &tc->transfer);
d343 1
a343 1
sp_tile_cache_flush_clear(struct softpipe_tile_cache *tc)
d345 3
a347 3
   struct pipe_transfer *pt = tc->transfer;
   const uint w = tc->transfer->box.width;
   const uint h = tc->transfer->box.height;
a351 2
   if (!tc->tile)
      tc->tile = sp_alloc_tile(tc);
d363 1
a363 1
         union tile_address addr = tile_address(x, y);
d365 1
a365 1
         if (is_clear_flag_set(tc->clear_flags, addr)) {
d368 1
a368 1
               pipe_put_tile_raw(pt, tc->transfer_map,
d374 1
a374 1
                  pipe_put_tile_ui_format(pt, tc->transfer_map,
d379 1
a379 1
                  pipe_put_tile_i_format(pt, tc->transfer_map,
d384 1
a384 1
                  pipe_put_tile_rgba(pt, tc->transfer_map,
a393 2
   /* reset all clear flags to zero */
   memset(tc->clear_flags, 0, sizeof(tc->clear_flags));
d403 1
d406 1
a406 1
         pipe_put_tile_raw(tc->transfer, tc->transfer_map,
d414 1
a414 1
            pipe_put_tile_ui_format(tc->transfer, tc->transfer_map,
d421 1
a421 1
            pipe_put_tile_i_format(tc->transfer, tc->transfer_map,
d428 1
a428 1
            pipe_put_tile_rgba_format(tc->transfer, tc->transfer_map,
a446 1
   struct pipe_transfer *pt = tc->transfer;
d448 2
a449 2

   if (pt) {
a457 1

d462 2
a463 1
      sp_tile_cache_flush_clear(tc);
d465 4
d519 1
a519 1
   struct pipe_transfer *pt = tc->transfer;
d522 1
a522 1
                             addr.bits.y);
d524 1
a524 1

d532 1
a532 1
      assert(pt->resource);
d536 1
a536 1
            pipe_put_tile_raw(pt, tc->transfer_map,
d544 1
a544 1
               pipe_put_tile_ui_format(pt, tc->transfer_map,
d551 1
a551 1
               pipe_put_tile_i_format(pt, tc->transfer_map,
d558 1
a558 1
               pipe_put_tile_rgba_format(pt, tc->transfer_map,
d570 5
a574 1
      if (is_clear_flag_set(tc->clear_flags, addr)) {
d582 1
a582 1
         clear_clear_flag(tc->clear_flags, addr);
d587 1
a587 1
            pipe_get_tile_raw(pt, tc->transfer_map,
d595 1
a595 1
               pipe_get_tile_ui_format(pt, tc->transfer_map,
d602 1
a602 1
               pipe_get_tile_i_format(pt, tc->transfer_map,
d609 1
a609 1
               pipe_get_tile_rgba_format(pt, tc->transfer_map,
d646 1
a646 1
   memset(tc->clear_flags, 255, sizeof(tc->clear_flags));
@


