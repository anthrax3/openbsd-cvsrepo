head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.05;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.52;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.47;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.01;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * Copyright 2010 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * \brief  Quad depth / stencil testing
 */

#include "pipe/p_defines.h"
#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "tgsi/tgsi_scan.h"
#include "sp_context.h"
#include "sp_quad.h"
#include "sp_quad_pipe.h"
#include "sp_tile_cache.h"
#include "sp_state.h"           /* for sp_fragment_shader */


struct depth_data {
   struct pipe_surface *ps;
   enum pipe_format format;
   unsigned bzzzz[TGSI_QUAD_SIZE];  /**< Z values fetched from depth buffer */
   unsigned qzzzz[TGSI_QUAD_SIZE];  /**< Z values from the quad */
   ubyte stencilVals[TGSI_QUAD_SIZE];
   boolean use_shader_stencil_refs;
   ubyte shader_stencil_refs[TGSI_QUAD_SIZE];
   struct softpipe_cached_tile *tile;
};



static void
get_depth_stencil_values( struct depth_data *data,
                          const struct quad_header *quad )
{
   unsigned j;
   const struct softpipe_cached_tile *tile = data->tile;

   switch (data->format) {
   case PIPE_FORMAT_Z16_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = tile->data.depth16[y][x];
      }
      break;
   case PIPE_FORMAT_Z32_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = tile->data.depth32[y][x];
      }
      break;
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = tile->data.depth32[y][x] & 0xffffff;
         data->stencilVals[j] = tile->data.depth32[y][x] >> 24;
      }
      break;
   case PIPE_FORMAT_X8Z24_UNORM:
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = tile->data.depth32[y][x] >> 8;
         data->stencilVals[j] = tile->data.depth32[y][x] & 0xff;
      }
      break;
   case PIPE_FORMAT_S8_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = 0;
         data->stencilVals[j] = tile->data.stencil8[y][x];
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = tile->data.depth32[y][x];
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = tile->data.depth64[y][x] & 0xffffffff;
         data->stencilVals[j] = (tile->data.depth64[y][x] >> 32) & 0xff;
      }
      break;
   default:
      assert(0);
   }
}


/**
 * If the shader has not been run, interpolate the depth values
 * ourselves.
 */
static void
interpolate_quad_depth( struct quad_header *quad )
{
   const float fx = (float) quad->input.x0;
   const float fy = (float) quad->input.y0;
   const float dzdx = quad->posCoef->dadx[2];
   const float dzdy = quad->posCoef->dady[2];
   const float z0 = quad->posCoef->a0[2] + dzdx * fx + dzdy * fy;

   quad->output.depth[0] = z0;
   quad->output.depth[1] = z0 + dzdx;
   quad->output.depth[2] = z0 + dzdy;
   quad->output.depth[3] = z0 + dzdx + dzdy;
}


/**
 * Compute the depth_data::qzzzz[] values from the float fragment Z values.
 */
static void
convert_quad_depth( struct depth_data *data, 
                    const struct quad_header *quad )
{
   unsigned j;

   /* Convert quad's float depth values to int depth values (qzzzz).
    * If the Z buffer stores integer values, we _have_ to do the depth
    * compares with integers (not floats).  Otherwise, the float->int->float
    * conversion of Z values (which isn't an identity function) will cause
    * Z-fighting errors.
    */
   switch (data->format) {
   case PIPE_FORMAT_Z16_UNORM:
      {
         float scale = 65535.0;

         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
         }
      }
      break;
   case PIPE_FORMAT_Z32_UNORM:
      {
         double scale = (double) (uint) ~0UL;

         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
         }
      }
      break;
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      {
         float scale = (float) ((1 << 24) - 1);

         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
         }
      }
      break;
   case PIPE_FORMAT_X8Z24_UNORM:
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      {
         float scale = (float) ((1 << 24) - 1);

         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
         }
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT:
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      {
         union fi fui;

         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            fui.f = quad->output.depth[j];
            data->qzzzz[j] = fui.ui;
         }
      }
      break;
   default:
      assert(0);
   }
}


/**
 * Compute the depth_data::shader_stencil_refs[] values from the float
 * fragment stencil values.
 */
static void
convert_quad_stencil( struct depth_data *data, 
                      const struct quad_header *quad )
{
   unsigned j;

   data->use_shader_stencil_refs = TRUE;
   /* Copy quads stencil values
    */
   switch (data->format) {
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
   case PIPE_FORMAT_X8Z24_UNORM:
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
   case PIPE_FORMAT_S8_UINT:
   case PIPE_FORMAT_Z32_FLOAT:
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         data->shader_stencil_refs[j] = ((unsigned)(quad->output.stencil[j]));
      }
      break;
   default:
      assert(0);
   }
}


/**
 * Write data->bzzzz[] values and data->stencilVals into the Z/stencil buffer.
 */
static void
write_depth_stencil_values( struct depth_data *data,
                            struct quad_header *quad )
{
   struct softpipe_cached_tile *tile = data->tile;
   unsigned j;

   /* put updated Z values back into cached tile */
   switch (data->format) {
   case PIPE_FORMAT_Z16_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth16[y][x] = (ushort) data->bzzzz[j];
      }
      break;
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z32_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth32[y][x] = data->bzzzz[j];
      }
      break;
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth32[y][x] = (data->stencilVals[j] << 24) | data->bzzzz[j];
      }
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth32[y][x] = (data->bzzzz[j] << 8) | data->stencilVals[j];
      }
      break;
   case PIPE_FORMAT_X8Z24_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth32[y][x] = data->bzzzz[j] << 8;
      }
      break;
   case PIPE_FORMAT_S8_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.stencil8[y][x] = data->stencilVals[j];
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth32[y][x] = data->bzzzz[j];
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth64[y][x] = (uint64_t)data->bzzzz[j] | ((uint64_t)data->stencilVals[j] << 32);
      }
      break;
   default:
      assert(0);
   }
}



/** Only 8-bit stencil supported */
#define STENCIL_MAX 0xff


/**
 * Do the basic stencil test (compare stencil buffer values against the
 * reference value.
 *
 * \param data->stencilVals  the stencil values from the stencil buffer
 * \param func  the stencil func (PIPE_FUNC_x)
 * \param ref  the stencil reference value
 * \param valMask  the stencil value mask indicating which bits of the stencil
 *                 values and ref value are to be used.
 * \return mask indicating which pixels passed the stencil test
 */
static unsigned
do_stencil_test(struct depth_data *data,
                unsigned func,
                unsigned ref, unsigned valMask)
{
   unsigned passMask = 0x0;
   unsigned j;
   ubyte refs[TGSI_QUAD_SIZE];

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      if (data->use_shader_stencil_refs)
         refs[j] = data->shader_stencil_refs[j] & valMask;
      else 
         refs[j] = ref & valMask;
   }

   switch (func) {
   case PIPE_FUNC_NEVER:
      /* passMask = 0x0 */
      break;
   case PIPE_FUNC_LESS:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (refs[j] < (data->stencilVals[j] & valMask)) {
            passMask |= (1 << j);
         }
      }
      break;
   case PIPE_FUNC_EQUAL:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (refs[j] == (data->stencilVals[j] & valMask)) {
            passMask |= (1 << j);
         }
      }
      break;
   case PIPE_FUNC_LEQUAL:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (refs[j] <= (data->stencilVals[j] & valMask)) {
            passMask |= (1 << j);
         }
      }
      break;
   case PIPE_FUNC_GREATER:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (refs[j] > (data->stencilVals[j] & valMask)) {
            passMask |= (1 << j);
         }
      }
      break;
   case PIPE_FUNC_NOTEQUAL:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (refs[j] != (data->stencilVals[j] & valMask)) {
            passMask |= (1 << j);
         }
      }
      break;
   case PIPE_FUNC_GEQUAL:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (refs[j] >= (data->stencilVals[j] & valMask)) {
            passMask |= (1 << j);
         }
      }
      break;
   case PIPE_FUNC_ALWAYS:
      passMask = MASK_ALL;
      break;
   default:
      assert(0);
   }

   return passMask;
}


/**
 * Apply the stencil operator to stencil values.
 *
 * \param data->stencilVals  the stencil buffer values (read and written)
 * \param mask  indicates which pixels to update
 * \param op  the stencil operator (PIPE_STENCIL_OP_x)
 * \param ref  the stencil reference value
 * \param wrtMask  writemask controlling which bits are changed in the
 *                 stencil values
 */
static void
apply_stencil_op(struct depth_data *data,
                 unsigned mask, unsigned op, ubyte ref, ubyte wrtMask)
{
   unsigned j;
   ubyte newstencil[TGSI_QUAD_SIZE];
   ubyte refs[TGSI_QUAD_SIZE];

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      newstencil[j] = data->stencilVals[j];
      if (data->use_shader_stencil_refs)
         refs[j] = data->shader_stencil_refs[j];
      else
         refs[j] = ref;
   }

   switch (op) {
   case PIPE_STENCIL_OP_KEEP:
      /* no-op */
      break;
   case PIPE_STENCIL_OP_ZERO:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (mask & (1 << j)) {
            newstencil[j] = 0;
         }
      }
      break;
   case PIPE_STENCIL_OP_REPLACE:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (mask & (1 << j)) {
            newstencil[j] = refs[j];
         }
      }
      break;
   case PIPE_STENCIL_OP_INCR:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (mask & (1 << j)) {
            if (data->stencilVals[j] < STENCIL_MAX) {
               newstencil[j] = data->stencilVals[j] + 1;
            }
         }
      }
      break;
   case PIPE_STENCIL_OP_DECR:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (mask & (1 << j)) {
            if (data->stencilVals[j] > 0) {
               newstencil[j] = data->stencilVals[j] - 1;
            }
         }
      }
      break;
   case PIPE_STENCIL_OP_INCR_WRAP:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (mask & (1 << j)) {
            newstencil[j] = data->stencilVals[j] + 1;
         }
      }
      break;
   case PIPE_STENCIL_OP_DECR_WRAP:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (mask & (1 << j)) {
            newstencil[j] = data->stencilVals[j] - 1;
         }
      }
      break;
   case PIPE_STENCIL_OP_INVERT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (mask & (1 << j)) {
            newstencil[j] = ~data->stencilVals[j];
         }
      }
      break;
   default:
      assert(0);
   }

   /*
    * update the stencil values
    */
   if (wrtMask != STENCIL_MAX) {
      /* apply bit-wise stencil buffer writemask */
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         data->stencilVals[j] = (wrtMask & newstencil[j]) | (~wrtMask & data->stencilVals[j]);
      }
   }
   else {
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         data->stencilVals[j] = newstencil[j];
      }
   }
}

   

/**
 * To increase efficiency, we should probably have multiple versions
 * of this function that are specifically for Z16, Z32 and FP Z buffers.
 * Try to effectively do that with codegen...
 */
static boolean
depth_test_quad(struct quad_stage *qs, 
                struct depth_data *data,
                struct quad_header *quad)
{
   struct softpipe_context *softpipe = qs->softpipe;
   unsigned zmask = 0;
   unsigned j;

   switch (softpipe->depth_stencil->depth.func) {
   case PIPE_FUNC_NEVER:
      /* zmask = 0 */
      break;
   case PIPE_FUNC_LESS:
      /* Note this is pretty much a single sse or cell instruction.  
       * Like this:  quad->mask &= (quad->outputs.depth < zzzz);
       */
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
	 if (data->qzzzz[j] < data->bzzzz[j]) 
	    zmask |= 1 << j;
      }
      break;
   case PIPE_FUNC_EQUAL:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
	 if (data->qzzzz[j] == data->bzzzz[j]) 
	    zmask |= 1 << j;
      }
      break;
   case PIPE_FUNC_LEQUAL:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
	 if (data->qzzzz[j] <= data->bzzzz[j]) 
	    zmask |= (1 << j);
      }
      break;
   case PIPE_FUNC_GREATER:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
	 if (data->qzzzz[j] > data->bzzzz[j]) 
	    zmask |= (1 << j);
      }
      break;
   case PIPE_FUNC_NOTEQUAL:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
	 if (data->qzzzz[j] != data->bzzzz[j]) 
	    zmask |= (1 << j);
      }
      break;
   case PIPE_FUNC_GEQUAL:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
	 if (data->qzzzz[j] >= data->bzzzz[j]) 
	    zmask |= (1 << j);
      }
      break;
   case PIPE_FUNC_ALWAYS:
      zmask = MASK_ALL;
      break;
   default:
      assert(0);
   }

   quad->inout.mask &= zmask;
   if (quad->inout.mask == 0)
      return FALSE;

   /* Update our internal copy only if writemask set.  Even if
    * depth.writemask is FALSE, may still need to write out buffer
    * data due to stencil changes.
    */
   if (softpipe->depth_stencil->depth.writemask) {
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (quad->inout.mask & (1 << j)) {
            data->bzzzz[j] = data->qzzzz[j];
         }
      }
   }

   return TRUE;
}



/**
 * Do stencil (and depth) testing.  Stenciling depends on the outcome of
 * depth testing.
 */
static void
depth_stencil_test_quad(struct quad_stage *qs, 
                        struct depth_data *data,
                        struct quad_header *quad)
{
   struct softpipe_context *softpipe = qs->softpipe;
   unsigned func, zFailOp, zPassOp, failOp;
   ubyte ref, wrtMask, valMask;
   uint face = quad->input.facing;

   if (!softpipe->depth_stencil->stencil[1].enabled) {
      /* single-sided stencil test, use front (face=0) state */
      face = 0;
   }

   /* 0 = front-face, 1 = back-face */
   assert(face == 0 || face == 1);

   /* choose front or back face function, operator, etc */
   /* XXX we could do these initializations once per primitive */
   func    = softpipe->depth_stencil->stencil[face].func;
   failOp  = softpipe->depth_stencil->stencil[face].fail_op;
   zFailOp = softpipe->depth_stencil->stencil[face].zfail_op;
   zPassOp = softpipe->depth_stencil->stencil[face].zpass_op;
   ref     = softpipe->stencil_ref.ref_value[face];
   wrtMask = softpipe->depth_stencil->stencil[face].writemask;
   valMask = softpipe->depth_stencil->stencil[face].valuemask;

   /* do the stencil test first */
   {
      unsigned passMask, failMask;
      passMask = do_stencil_test(data, func, ref, valMask);
      failMask = quad->inout.mask & ~passMask;
      quad->inout.mask &= passMask;

      if (failOp != PIPE_STENCIL_OP_KEEP) {
         apply_stencil_op(data, failMask, failOp, ref, wrtMask);
      }
   }

   if (quad->inout.mask) {
      /* now the pixels that passed the stencil test are depth tested */
      if (softpipe->depth_stencil->depth.enabled) {
         const unsigned origMask = quad->inout.mask;

         depth_test_quad(qs, data, quad);  /* quad->mask is updated */

         /* update stencil buffer values according to z pass/fail result */
         if (zFailOp != PIPE_STENCIL_OP_KEEP) {
            const unsigned zFailMask = origMask & ~quad->inout.mask;
            apply_stencil_op(data, zFailMask, zFailOp, ref, wrtMask);
         }

         if (zPassOp != PIPE_STENCIL_OP_KEEP) {
            const unsigned zPassMask = origMask & quad->inout.mask;
            apply_stencil_op(data, zPassMask, zPassOp, ref, wrtMask);
         }
      }
      else {
         /* no depth test, apply Zpass operator to stencil buffer values */
         apply_stencil_op(data, quad->inout.mask, zPassOp, ref, wrtMask);
      }
   }
}


#define ALPHATEST( FUNC, COMP )                                         \
   static unsigned                                                      \
   alpha_test_quads_##FUNC( struct quad_stage *qs,                      \
                           struct quad_header *quads[],                 \
                           unsigned nr )                                \
   {                                                                    \
      const float ref = qs->softpipe->depth_stencil->alpha.ref_value;   \
      const uint cbuf = 0; /* only output[0].alpha is tested */         \
      unsigned pass_nr = 0;                                             \
      unsigned i;                                                       \
                                                                        \
      for (i = 0; i < nr; i++) {                                        \
         const float *aaaa = quads[i]->output.color[cbuf][3];           \
         unsigned passMask = 0;                                         \
                                                                        \
         if (aaaa[0] COMP ref) passMask |= (1 << 0);                    \
         if (aaaa[1] COMP ref) passMask |= (1 << 1);                    \
         if (aaaa[2] COMP ref) passMask |= (1 << 2);                    \
         if (aaaa[3] COMP ref) passMask |= (1 << 3);                    \
                                                                        \
         quads[i]->inout.mask &= passMask;                              \
                                                                        \
         if (quads[i]->inout.mask)                                      \
            quads[pass_nr++] = quads[i];                                \
      }                                                                 \
                                                                        \
      return pass_nr;                                                   \
   }


ALPHATEST( LESS,     < )
ALPHATEST( EQUAL,    == )
ALPHATEST( LEQUAL,   <= )
ALPHATEST( GREATER,  > )
ALPHATEST( NOTEQUAL, != )
ALPHATEST( GEQUAL,   >= )


/* XXX: Incorporate into shader using KILL_IF.
 */
static unsigned
alpha_test_quads(struct quad_stage *qs, 
                 struct quad_header *quads[], 
                 unsigned nr)
{
   switch (qs->softpipe->depth_stencil->alpha.func) {
   case PIPE_FUNC_LESS:
      return alpha_test_quads_LESS( qs, quads, nr );
   case PIPE_FUNC_EQUAL:
      return alpha_test_quads_EQUAL( qs, quads, nr );
   case PIPE_FUNC_LEQUAL:
      return alpha_test_quads_LEQUAL( qs, quads, nr );
   case PIPE_FUNC_GREATER:
      return alpha_test_quads_GREATER( qs, quads, nr );
   case PIPE_FUNC_NOTEQUAL:
      return alpha_test_quads_NOTEQUAL( qs, quads, nr );
   case PIPE_FUNC_GEQUAL:
      return alpha_test_quads_GEQUAL( qs, quads, nr );
   case PIPE_FUNC_ALWAYS:
      return nr;
   case PIPE_FUNC_NEVER:
   default:
      return 0;
   }
}


static unsigned mask_count[16] = 
{
   0,                           /* 0x0 */
   1,                           /* 0x1 */
   1,                           /* 0x2 */
   2,                           /* 0x3 */
   1,                           /* 0x4 */
   2,                           /* 0x5 */
   2,                           /* 0x6 */
   3,                           /* 0x7 */
   1,                           /* 0x8 */
   2,                           /* 0x9 */
   2,                           /* 0xa */
   3,                           /* 0xb */
   2,                           /* 0xc */
   3,                           /* 0xd */
   3,                           /* 0xe */
   4,                           /* 0xf */
};



/**
 * General depth/stencil test function.  Used when there's no fast-path.
 */
static void
depth_test_quads_fallback(struct quad_stage *qs, 
                          struct quad_header *quads[],
                          unsigned nr)
{
   unsigned i, pass = 0;
   const struct tgsi_shader_info *fsInfo = &qs->softpipe->fs_variant->info;
   boolean interp_depth = !fsInfo->writes_z;
   boolean shader_stencil_ref = fsInfo->writes_stencil;
   struct depth_data data;

   data.use_shader_stencil_refs = FALSE;

   if (qs->softpipe->depth_stencil->alpha.enabled) {
      nr = alpha_test_quads(qs, quads, nr);
   }

   if (qs->softpipe->framebuffer.zsbuf &&
         (qs->softpipe->depth_stencil->depth.enabled ||
          qs->softpipe->depth_stencil->stencil[0].enabled)) {

      data.ps = qs->softpipe->framebuffer.zsbuf;
      data.format = data.ps->format;
      data.tile = sp_get_cached_tile(qs->softpipe->zsbuf_cache, 
                                     quads[0]->input.x0, 
                                     quads[0]->input.y0);

      for (i = 0; i < nr; i++) {
         get_depth_stencil_values(&data, quads[i]);

         if (qs->softpipe->depth_stencil->depth.enabled) {
            if (interp_depth)
               interpolate_quad_depth(quads[i]);

            convert_quad_depth(&data, quads[i]);
         }

         if (qs->softpipe->depth_stencil->stencil[0].enabled) {
            if (shader_stencil_ref)
               convert_quad_stencil(&data, quads[i]);
            
            depth_stencil_test_quad(qs, &data, quads[i]);
            write_depth_stencil_values(&data, quads[i]);
         }
         else {
            if (!depth_test_quad(qs, &data, quads[i]))
               continue;

            if (qs->softpipe->depth_stencil->depth.writemask)
               write_depth_stencil_values(&data, quads[i]);
         }

         quads[pass++] = quads[i];
      }

      nr = pass;
   }

   if (qs->softpipe->active_query_count) {
      for (i = 0; i < nr; i++) 
         qs->softpipe->occlusion_count += mask_count[quads[i]->inout.mask];
   }

   if (nr)
      qs->next->run(qs->next, quads, nr);
}


/**
 * Special-case Z testing for 16-bit Zbuffer and Z buffer writes enabled.
 */

#define NAME depth_interp_z16_less_write
#define OPERATOR <
#include "sp_quad_depth_test_tmp.h"

#define NAME depth_interp_z16_equal_write
#define OPERATOR ==
#include "sp_quad_depth_test_tmp.h"

#define NAME depth_interp_z16_lequal_write
#define OPERATOR <=
#include "sp_quad_depth_test_tmp.h"

#define NAME depth_interp_z16_greater_write
#define OPERATOR >
#include "sp_quad_depth_test_tmp.h"

#define NAME depth_interp_z16_notequal_write
#define OPERATOR !=
#include "sp_quad_depth_test_tmp.h"

#define NAME depth_interp_z16_gequal_write
#define OPERATOR >=
#include "sp_quad_depth_test_tmp.h"

#define NAME depth_interp_z16_always_write
#define ALWAYS 1
#include "sp_quad_depth_test_tmp.h"



static void
depth_noop(struct quad_stage *qs, 
           struct quad_header *quads[],
           unsigned nr)
{
   qs->next->run(qs->next, quads, nr);
}



static void
choose_depth_test(struct quad_stage *qs, 
                  struct quad_header *quads[],
                  unsigned nr)
{
   const struct tgsi_shader_info *fsInfo = &qs->softpipe->fs_variant->info;

   boolean interp_depth = !fsInfo->writes_z;

   boolean alpha = qs->softpipe->depth_stencil->alpha.enabled;

   boolean depth = qs->softpipe->depth_stencil->depth.enabled;

   unsigned depthfunc = qs->softpipe->depth_stencil->depth.func;

   boolean stencil = qs->softpipe->depth_stencil->stencil[0].enabled;

   boolean depthwrite = qs->softpipe->depth_stencil->depth.writemask;

   boolean occlusion = qs->softpipe->active_query_count;

   if(!qs->softpipe->framebuffer.zsbuf)
      depth = depthwrite = stencil = FALSE;

   /* default */
   qs->run = depth_test_quads_fallback;

   /* look for special cases */
   if (!alpha &&
       !depth &&
       !occlusion &&
       !stencil) {
      qs->run = depth_noop;
   }
   else if (!alpha && 
            interp_depth && 
            depth && 
            depthwrite && 
            !occlusion &&
            !stencil) 
   {
      if (qs->softpipe->framebuffer.zsbuf->format == PIPE_FORMAT_Z16_UNORM) {
         switch (depthfunc) {
         case PIPE_FUNC_NEVER:
            qs->run = depth_test_quads_fallback;
            break;
         case PIPE_FUNC_LESS:
            qs->run = depth_interp_z16_less_write;
            break;
         case PIPE_FUNC_EQUAL:
            qs->run = depth_interp_z16_equal_write;
            break;
         case PIPE_FUNC_LEQUAL:
            qs->run = depth_interp_z16_lequal_write;
            break;
         case PIPE_FUNC_GREATER:
            qs->run = depth_interp_z16_greater_write;
            break;
         case PIPE_FUNC_NOTEQUAL:
            qs->run = depth_interp_z16_notequal_write;
            break;
         case PIPE_FUNC_GEQUAL:
            qs->run = depth_interp_z16_gequal_write;
            break;
         case PIPE_FUNC_ALWAYS:
            qs->run = depth_interp_z16_always_write;
            break;
         default:
            qs->run = depth_test_quads_fallback;
            break;
         }
      }
   }

   /* next quad/fragment stage */
   qs->run( qs, quads, nr );
}



static void
depth_test_begin(struct quad_stage *qs)
{
   qs->run = choose_depth_test;
   qs->next->begin(qs->next);
}


static void
depth_test_destroy(struct quad_stage *qs)
{
   FREE( qs );
}


struct quad_stage *
sp_quad_depth_test_stage(struct softpipe_context *softpipe)
{
   struct quad_stage *stage = CALLOC_STRUCT(quad_stage);

   stage->softpipe = softpipe;
   stage->begin = depth_test_begin;
   stage->run = choose_depth_test;
   stage->destroy = depth_test_destroy;

   return stage;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a53 2
   float minval, maxval;
   bool clamp;
a154 1
   float dvals[TGSI_QUAD_SIZE];
a161 10
   if (data->clamp) {
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         dvals[j] = CLAMP(quad->output.depth[j], data->minval, data->maxval);
      }
   } else {
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         dvals[j] = quad->output.depth[j];
      }
   }

d168 1
a168 1
            data->qzzzz[j] = (unsigned) (dvals[j] * scale);
d177 1
a177 1
            data->qzzzz[j] = (unsigned) (dvals[j] * scale);
d187 1
a187 1
            data->qzzzz[j] = (unsigned) (dvals[j] * scale);
d197 1
a197 1
            data->qzzzz[j] = (unsigned) (dvals[j] * scale);
d207 1
a207 1
            fui.f = dvals[j];
a784 1
      float near_val, far_val;
d790 1
a790 7
                                     quads[0]->input.y0, quads[0]->input.layer);
      data.clamp = !qs->softpipe->rasterizer->depth_clip;

      near_val = qs->softpipe->viewport.translate[2] - qs->softpipe->viewport.scale[2];
      far_val = near_val + (qs->softpipe->viewport.scale[2] * 2.0);
      data.minval = MIN2(near_val, far_val);
      data.maxval = MAX2(near_val, far_val);
a897 2
   boolean clipped = !qs->softpipe->rasterizer->depth_clip;

a907 1
       !clipped &&
a915 1
            !clipped &&
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d54 2
d157 1
d165 10
d181 1
a181 1
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
d190 1
a190 1
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
d200 1
a200 1
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
d210 1
a210 1
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
d220 1
a220 1
            fui.f = quad->output.depth[j];
d798 1
d804 7
a810 1
                                     quads[0]->input.y0);
d918 2
d930 1
d939 1
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d35 1
d48 3
a50 3
   unsigned bzzzz[QUAD_SIZE];  /**< Z values fetched from depth buffer */
   unsigned qzzzz[QUAD_SIZE];  /**< Z values from the quad */
   ubyte stencilVals[QUAD_SIZE];
d52 1
a52 1
   ubyte shader_stencil_refs[QUAD_SIZE];
d67 1
a67 1
      for (j = 0; j < QUAD_SIZE; j++) {
d74 1
a74 1
      for (j = 0; j < QUAD_SIZE; j++) {
d81 2
a82 2
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
      for (j = 0; j < QUAD_SIZE; j++) {
d90 2
a91 2
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
      for (j = 0; j < QUAD_SIZE; j++) {
d98 2
a99 2
   case PIPE_FORMAT_S8_USCALED:
      for (j = 0; j < QUAD_SIZE; j++) {
d106 15
d167 1
a167 1
         for (j = 0; j < QUAD_SIZE; j++) {
d176 1
a176 1
         for (j = 0; j < QUAD_SIZE; j++) {
d182 1
a182 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d186 1
a186 1
         for (j = 0; j < QUAD_SIZE; j++) {
d192 1
a192 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d196 1
a196 1
         for (j = 0; j < QUAD_SIZE; j++) {
d201 11
d219 2
a220 1
 * Compute the depth_data::shader_stencil_refs[] values from the float fragment stencil values.
d233 1
a233 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d235 5
a239 3
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
   case PIPE_FORMAT_S8_USCALED:
      for (j = 0; j < QUAD_SIZE; j++) {
d248 1
d262 1
a262 1
      for (j = 0; j < QUAD_SIZE; j++) {
d270 1
a270 1
      for (j = 0; j < QUAD_SIZE; j++) {
d276 2
a277 2
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
      for (j = 0; j < QUAD_SIZE; j++) {
d283 2
a284 2
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
      for (j = 0; j < QUAD_SIZE; j++) {
d291 1
a291 1
      for (j = 0; j < QUAD_SIZE; j++) {
d297 2
a298 2
   case PIPE_FORMAT_S8_USCALED:
      for (j = 0; j < QUAD_SIZE; j++) {
d304 14
a317 1

d347 1
a347 1
   ubyte refs[QUAD_SIZE];
d349 1
a349 1
   for (j = 0; j < QUAD_SIZE; j++) {
d361 1
a361 1
      for (j = 0; j < QUAD_SIZE; j++) {
d368 1
a368 1
      for (j = 0; j < QUAD_SIZE; j++) {
d375 1
a375 1
      for (j = 0; j < QUAD_SIZE; j++) {
d382 1
a382 1
      for (j = 0; j < QUAD_SIZE; j++) {
d389 1
a389 1
      for (j = 0; j < QUAD_SIZE; j++) {
d396 1
a396 1
      for (j = 0; j < QUAD_SIZE; j++) {
d428 2
a429 2
   ubyte newstencil[QUAD_SIZE];
   ubyte refs[QUAD_SIZE];
d431 1
a431 1
   for (j = 0; j < QUAD_SIZE; j++) {
d444 1
a444 1
      for (j = 0; j < QUAD_SIZE; j++) {
d451 1
a451 1
      for (j = 0; j < QUAD_SIZE; j++) {
d458 1
a458 1
      for (j = 0; j < QUAD_SIZE; j++) {
d467 1
a467 1
      for (j = 0; j < QUAD_SIZE; j++) {
d476 1
a476 1
      for (j = 0; j < QUAD_SIZE; j++) {
d483 1
a483 1
      for (j = 0; j < QUAD_SIZE; j++) {
d490 1
a490 1
      for (j = 0; j < QUAD_SIZE; j++) {
d505 1
a505 1
      for (j = 0; j < QUAD_SIZE; j++) {
d510 1
a510 1
      for (j = 0; j < QUAD_SIZE; j++) {
d540 1
a540 1
      for (j = 0; j < QUAD_SIZE; j++) {
d546 1
a546 1
      for (j = 0; j < QUAD_SIZE; j++) {
d552 1
a552 1
      for (j = 0; j < QUAD_SIZE; j++) {
d558 1
a558 1
      for (j = 0; j < QUAD_SIZE; j++) {
d564 1
a564 1
      for (j = 0; j < QUAD_SIZE; j++) {
d570 1
a570 1
      for (j = 0; j < QUAD_SIZE; j++) {
d591 1
a591 1
      for (j = 0; j < QUAD_SIZE; j++) {
d674 1
a674 1
   static int                                                           \
d711 1
a711 1
/* XXX: Incorporate into shader using KILP.
d713 1
a713 1
static int
a722 1
      break;
d771 3
a773 3
   const struct sp_fragment_shader *fs = qs->softpipe->fs;
   boolean interp_depth = !fs->info.writes_z;
   boolean shader_stencil_ref = fs->info.writes_stencil;
d882 3
a884 1
   boolean interp_depth = !qs->softpipe->fs->info.writes_z;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d208 3
a210 4
      {
         for (j = 0; j < QUAD_SIZE; j++) {
            data->shader_stencil_refs[j] = ((unsigned)(quad->output.stencil[j]));
         }
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d50 2
d80 1
a80 1
   case PIPE_FORMAT_Z24S8_UNORM:
d87 1
a87 1
   break;
d89 1
a89 1
   case PIPE_FORMAT_S8Z24_UNORM:
d97 8
d166 1
a166 1
   case PIPE_FORMAT_Z24S8_UNORM:
d176 1
a176 1
   case PIPE_FORMAT_S8Z24_UNORM:
d191 27
d246 1
a246 1
   case PIPE_FORMAT_Z24S8_UNORM:
d253 1
a253 1
   case PIPE_FORMAT_S8Z24_UNORM:
d267 8
d304 1
d306 6
a311 1
   ref &= valMask;
d319 1
a319 1
         if (ref < (data->stencilVals[j] & valMask)) {
d326 1
a326 1
         if (ref == (data->stencilVals[j] & valMask)) {
d333 1
a333 1
         if (ref <= (data->stencilVals[j] & valMask)) {
d340 1
a340 1
         if (ref > (data->stencilVals[j] & valMask)) {
d347 1
a347 1
         if (ref != (data->stencilVals[j] & valMask)) {
d354 1
a354 1
         if (ref >= (data->stencilVals[j] & valMask)) {
d386 1
d390 4
d410 1
a410 1
            newstencil[j] = ref;
d579 3
a719 14
/** helper to get number of Z buffer bits */
static unsigned
get_depth_bits(struct quad_stage *qs)
{
   struct pipe_surface *zsurf = qs->softpipe->framebuffer.zsbuf;
   if (zsurf)
      return util_format_get_component_bits(zsurf->format,
                                            UTIL_FORMAT_COLORSPACE_ZS, 0);
   else
      return 0;
}



d731 1
d734 1
d740 3
a742 3
   if (get_depth_bits(qs) > 0 &&
       (qs->softpipe->depth_stencil->depth.enabled ||
        qs->softpipe->depth_stencil->stencil[0].enabled)) {
d761 3
d844 1
a844 2
   boolean depth = (get_depth_bits(qs) > 0 &&
                    qs->softpipe->depth_stencil->depth.enabled);
d854 3
d863 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a49 2
   boolean use_shader_stencil_refs;
   ubyte shader_stencil_refs[QUAD_SIZE];
d78 1
a78 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d85 1
a85 1
      break;
d87 1
a87 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
a94 8
   case PIPE_FORMAT_S8_USCALED:
      for (j = 0; j < QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = 0;
         data->stencilVals[j] = tile->data.stencil8[y][x];
      }
      break;
d156 1
a156 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d166 1
a166 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
a180 27
/**
 * Compute the depth_data::shader_stencil_refs[] values from the float fragment stencil values.
 */
static void
convert_quad_stencil( struct depth_data *data, 
                      const struct quad_header *quad )
{
   unsigned j;

   data->use_shader_stencil_refs = TRUE;
   /* Copy quads stencil values
    */
   switch (data->format) {
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
   case PIPE_FORMAT_X8Z24_UNORM:
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
      {
         for (j = 0; j < QUAD_SIZE; j++) {
            data->shader_stencil_refs[j] = ((unsigned)(quad->output.stencil[j]));
         }
      }
      break;
   default:
      assert(0);
   }
}
d209 1
a209 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d216 1
a216 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
a229 8
   case PIPE_FORMAT_S8_USCALED:
      for (j = 0; j < QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.stencil8[y][x] = data->stencilVals[j];
      }
      break;

a258 1
   ubyte refs[QUAD_SIZE];
d260 1
a260 6
   for (j = 0; j < QUAD_SIZE; j++) {
      if (data->use_shader_stencil_refs)
         refs[j] = data->shader_stencil_refs[j] & valMask;
      else 
         refs[j] = ref & valMask;
   }
d268 1
a268 1
         if (refs[j] < (data->stencilVals[j] & valMask)) {
d275 1
a275 1
         if (refs[j] == (data->stencilVals[j] & valMask)) {
d282 1
a282 1
         if (refs[j] <= (data->stencilVals[j] & valMask)) {
d289 1
a289 1
         if (refs[j] > (data->stencilVals[j] & valMask)) {
d296 1
a296 1
         if (refs[j] != (data->stencilVals[j] & valMask)) {
d303 1
a303 1
         if (refs[j] >= (data->stencilVals[j] & valMask)) {
a334 1
   ubyte refs[QUAD_SIZE];
a337 4
      if (data->use_shader_stencil_refs)
         refs[j] = data->shader_stencil_refs[j];
      else
         refs[j] = ref;
d354 1
a354 1
            newstencil[j] = refs[j];
a522 3
   /* 0 = front-face, 1 = back-face */
   assert(face == 0 || face == 1);

d661 14
a685 1
   boolean shader_stencil_ref = fs->info.writes_stencil;
a687 1
   data.use_shader_stencil_refs = FALSE;
d693 3
a695 3
   if (qs->softpipe->framebuffer.zsbuf &&
         (qs->softpipe->depth_stencil->depth.enabled ||
          qs->softpipe->depth_stencil->stencil[0].enabled)) {
a713 3
            if (shader_stencil_ref)
               convert_quad_stencil(&data, quads[i]);
            
d794 2
a795 1
   boolean depth = qs->softpipe->depth_stencil->depth.enabled;
a804 3
   if(!qs->softpipe->framebuffer.zsbuf)
      depth = depthwrite = stencil = FALSE;

a810 1
       !occlusion &&
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a34 1
#include "util/u_math.h"
d47 3
a49 3
   unsigned bzzzz[TGSI_QUAD_SIZE];  /**< Z values fetched from depth buffer */
   unsigned qzzzz[TGSI_QUAD_SIZE];  /**< Z values from the quad */
   ubyte stencilVals[TGSI_QUAD_SIZE];
d51 1
a51 1
   ubyte shader_stencil_refs[TGSI_QUAD_SIZE];
d66 1
a66 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d73 1
a73 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d80 2
a81 2
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d89 2
a90 2
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d97 2
a98 2
   case PIPE_FORMAT_S8_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
a104 15
   case PIPE_FORMAT_Z32_FLOAT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = tile->data.depth32[y][x];
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         data->bzzzz[j] = tile->data.depth64[y][x] & 0xffffffff;
         data->stencilVals[j] = (tile->data.depth64[y][x] >> 32) & 0xff;
      }
      break;
d151 1
a151 1
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d160 1
a160 1
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d166 1
a166 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d170 1
a170 1
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d176 1
a176 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d180 1
a180 1
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
a184 11
   case PIPE_FORMAT_Z32_FLOAT:
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      {
         union fi fui;

         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            fui.f = quad->output.depth[j];
            data->qzzzz[j] = fui.ui;
         }
      }
      break;
d192 1
a192 2
 * Compute the depth_data::shader_stencil_refs[] values from the float
 * fragment stencil values.
d205 1
a205 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d207 5
a211 6
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
   case PIPE_FORMAT_S8_UINT:
   case PIPE_FORMAT_Z32_FLOAT:
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         data->shader_stencil_refs[j] = ((unsigned)(quad->output.stencil[j]));
a218 1

d232 1
a232 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d240 1
a240 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d246 2
a247 2
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d253 2
a254 2
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d261 1
a261 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d267 2
a268 2
   case PIPE_FORMAT_S8_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d274 1
a274 14
   case PIPE_FORMAT_Z32_FLOAT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth32[y][x] = data->bzzzz[j];
      }
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = quad->input.x0 % TILE_SIZE + (j & 1);
         int y = quad->input.y0 % TILE_SIZE + (j >> 1);
         tile->data.depth64[y][x] = (uint64_t)data->bzzzz[j] | ((uint64_t)data->stencilVals[j] << 32);
      }
      break;
d304 1
a304 1
   ubyte refs[TGSI_QUAD_SIZE];
d306 1
a306 1
   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d318 1
a318 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d325 1
a325 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d332 1
a332 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d339 1
a339 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d346 1
a346 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d353 1
a353 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d385 2
a386 2
   ubyte newstencil[TGSI_QUAD_SIZE];
   ubyte refs[TGSI_QUAD_SIZE];
d388 1
a388 1
   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d401 1
a401 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d408 1
a408 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d415 1
a415 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d424 1
a424 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d433 1
a433 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d440 1
a440 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d447 1
a447 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d462 1
a462 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d467 1
a467 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d497 1
a497 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d503 1
a503 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d509 1
a509 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d515 1
a515 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d521 1
a521 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d527 1
a527 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d548 1
a548 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d631 1
a631 1
   static unsigned                                                      \
d668 1
a668 1
/* XXX: Incorporate into shader using KILL_IF.
d670 1
a670 1
static unsigned
d680 1
d729 3
a731 3
   const struct tgsi_shader_info *fsInfo = &qs->softpipe->fs_variant->info;
   boolean interp_depth = !fsInfo->writes_z;
   boolean shader_stencil_ref = fsInfo->writes_stencil;
d840 1
a840 3
   const struct tgsi_shader_info *fsInfo = &qs->softpipe->fs_variant->info;

   boolean interp_depth = !fsInfo->writes_z;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a53 2
   float minval, maxval;
   bool clamp;
a154 1
   float dvals[TGSI_QUAD_SIZE];
a161 10
   if (data->clamp) {
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         dvals[j] = CLAMP(quad->output.depth[j], data->minval, data->maxval);
      }
   } else {
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         dvals[j] = quad->output.depth[j];
      }
   }

d168 1
a168 1
            data->qzzzz[j] = (unsigned) (dvals[j] * scale);
d177 1
a177 1
            data->qzzzz[j] = (unsigned) (dvals[j] * scale);
d187 1
a187 1
            data->qzzzz[j] = (unsigned) (dvals[j] * scale);
d197 1
a197 1
            data->qzzzz[j] = (unsigned) (dvals[j] * scale);
d207 1
a207 1
            fui.f = dvals[j];
a784 1
      float near_val, far_val;
d790 1
a790 7
                                     quads[0]->input.y0, quads[0]->input.layer);
      data.clamp = !qs->softpipe->rasterizer->depth_clip;

      near_val = qs->softpipe->viewport.translate[2] - qs->softpipe->viewport.scale[2];
      far_val = near_val + (qs->softpipe->viewport.scale[2] * 2.0);
      data.minval = MIN2(near_val, far_val);
      data.maxval = MAX2(near_val, far_val);
a897 2
   boolean clipped = !qs->softpipe->rasterizer->depth_clip;

a907 1
       !clipped &&
a915 1
            !clipped &&
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d54 2
d157 1
d165 10
d181 1
a181 1
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
d190 1
a190 1
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
d200 1
a200 1
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
d210 1
a210 1
            data->qzzzz[j] = (unsigned) (quad->output.depth[j] * scale);
d220 1
a220 1
            fui.f = quad->output.depth[j];
d798 1
d804 7
a810 1
                                     quads[0]->input.y0);
d918 2
d930 1
d939 1
@


