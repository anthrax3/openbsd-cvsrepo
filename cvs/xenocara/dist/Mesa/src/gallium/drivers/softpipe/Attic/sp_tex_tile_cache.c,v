head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.07;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * Texture tile caching.
 *
 * Author:
 *    Brian Paul
 */

#include "util/u_inlines.h"
#include "util/u_memory.h"
#include "util/u_tile.h"
#include "util/u_format.h"
#include "util/u_math.h"
#include "sp_context.h"
#include "sp_texture.h"
#include "sp_tex_tile_cache.h"

   

struct softpipe_tex_tile_cache *
sp_create_tex_tile_cache( struct pipe_context *pipe )
{
   struct softpipe_tex_tile_cache *tc;
   uint pos;

   /* make sure max texture size works */
   assert((TEX_TILE_SIZE << TEX_ADDR_BITS) >= (1 << (SP_MAX_TEXTURE_2D_LEVELS-1)));

   tc = CALLOC_STRUCT( softpipe_tex_tile_cache );
   if (tc) {
      tc->pipe = pipe;
      for (pos = 0; pos < Elements(tc->entries); pos++) {
         tc->entries[pos].addr.bits.invalid = 1;
      }
      tc->last_tile = &tc->entries[0]; /* any tile */
   }
   return tc;
}


void
sp_destroy_tex_tile_cache(struct softpipe_tex_tile_cache *tc)
{
   if (tc) {
      uint pos;

      for (pos = 0; pos < Elements(tc->entries); pos++) {
         /*assert(tc->entries[pos].x < 0);*/
      }
      if (tc->transfer) {
         tc->pipe->transfer_unmap(tc->pipe, tc->transfer);
      }
      if (tc->tex_trans) {
         tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
      }

      FREE( tc );
   }
}


/**
 * Invalidate all cached tiles for the cached texture.
 * Should be called when the texture is modified.
 */
void
sp_tex_tile_cache_validate_texture(struct softpipe_tex_tile_cache *tc)
{
   unsigned i;

   assert(tc);
   assert(tc->texture);

   for (i = 0; i < Elements(tc->entries); i++) {
      tc->entries[i].addr.bits.invalid = 1;
   }
}

static boolean
sp_tex_tile_is_compat_view(struct softpipe_tex_tile_cache *tc,
                           struct pipe_sampler_view *view)
{
   if (!view)
      return FALSE;
   return (tc->texture == view->texture &&
           tc->format == view->format &&
           tc->swizzle_r == view->swizzle_r &&
           tc->swizzle_g == view->swizzle_g &&
           tc->swizzle_b == view->swizzle_b &&
           tc->swizzle_a == view->swizzle_a);
}

/**
 * Specify the sampler view to cache.
 */
void
sp_tex_tile_cache_set_sampler_view(struct softpipe_tex_tile_cache *tc,
                                   struct pipe_sampler_view *view)
{
   struct pipe_resource *texture = view ? view->texture : NULL;
   uint i;

   assert(!tc->transfer);

   if (!sp_tex_tile_is_compat_view(tc, view)) {
      pipe_resource_reference(&tc->texture, texture);

      if (tc->tex_trans_map) {
         tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
         tc->tex_trans = NULL;
         tc->tex_trans_map = NULL;
      }

      if (view) {
         tc->swizzle_r = view->swizzle_r;
         tc->swizzle_g = view->swizzle_g;
         tc->swizzle_b = view->swizzle_b;
         tc->swizzle_a = view->swizzle_a;
         tc->format = view->format;
      }

      /* mark as entries as invalid/empty */
      /* XXX we should try to avoid this when the teximage hasn't changed */
      for (i = 0; i < Elements(tc->entries); i++) {
         tc->entries[i].addr.bits.invalid = 1;
      }

      tc->tex_face = -1; /* any invalid value here */
   }
}




/**
 * Flush the tile cache: write all dirty tiles back to the transfer.
 * any tiles "flagged" as cleared will be "really" cleared.
 */
void
sp_flush_tex_tile_cache(struct softpipe_tex_tile_cache *tc)
{
   int pos;

   if (tc->texture) {
      /* caching a texture, mark all entries as empty */
      for (pos = 0; pos < Elements(tc->entries); pos++) {
         tc->entries[pos].addr.bits.invalid = 1;
      }
      tc->tex_face = -1;
   }

}


/**
 * Given the texture face, level, zslice, x and y values, compute
 * the cache entry position/index where we'd hope to find the
 * cached texture tile.
 * This is basically a direct-map cache.
 * XXX There's probably lots of ways in which we can improve this.
 */
static INLINE uint
tex_cache_pos( union tex_tile_address addr )
{
   uint entry = (addr.bits.x + 
                 addr.bits.y * 9 + 
                 addr.bits.z * 3 + 
                 addr.bits.face + 
                 addr.bits.level * 7);

   return entry % NUM_TEX_TILE_ENTRIES;
}

/**
 * Similar to sp_get_cached_tile() but for textures.
 * Tiles are read-only and indexed with more params.
 */
const struct softpipe_tex_cached_tile *
sp_find_cached_tile_tex(struct softpipe_tex_tile_cache *tc, 
                        union tex_tile_address addr )
{
   struct softpipe_tex_cached_tile *tile;
   boolean zs = util_format_is_depth_or_stencil(tc->format);

   tile = tc->entries + tex_cache_pos( addr );

   if (addr.value != tile->addr.value) {

      /* cache miss.  Most misses are because we've invalidated the
       * texture cache previously -- most commonly on binding a new
       * texture.  Currently we effectively flush the cache on texture
       * bind.
       */
#if 0
      _debug_printf("miss at %u:  x=%d y=%d z=%d face=%d level=%d\n"
                    "   tile %u:  x=%d y=%d z=%d face=%d level=%d\n",
                    pos, x/TILE_SIZE, y/TILE_SIZE, z, face, level,
                    pos, tile->addr.bits.x, tile->addr.bits.y, tile->z, tile->face, tile->level);
#endif

      /* check if we need to get a new transfer */
      if (!tc->tex_trans ||
          tc->tex_face != addr.bits.face ||
          tc->tex_level != addr.bits.level ||
          tc->tex_z != addr.bits.z) {
         /* get new transfer (view into texture) */
         unsigned width, height, layer;

         if (tc->tex_trans_map) {
            tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
            tc->tex_trans = NULL;
            tc->tex_trans_map = NULL;
         }

         width = u_minify(tc->texture->width0, addr.bits.level);
         if (tc->texture->target == PIPE_TEXTURE_1D_ARRAY) {
            height = tc->texture->array_size;
            layer = 0;
         }
         else {
            height = u_minify(tc->texture->height0, addr.bits.level);
            layer = addr.bits.face + addr.bits.z;
         }

         tc->tex_trans_map =
            pipe_transfer_map(tc->pipe, tc->texture,
                              addr.bits.level,
                              layer,
                              PIPE_TRANSFER_READ | PIPE_TRANSFER_UNSYNCHRONIZED,
                              0, 0, width, height, &tc->tex_trans);

         tc->tex_face = addr.bits.face;
         tc->tex_level = addr.bits.level;
         tc->tex_z = addr.bits.z;
      }

      /* Get tile from the transfer (view into texture), explicitly passing
       * the image format.
       */
      if (!zs && util_format_is_pure_uint(tc->format)) {
         pipe_get_tile_ui_format(tc->tex_trans, tc->tex_trans_map,
                                 addr.bits.x * TEX_TILE_SIZE,
                                 addr.bits.y * TEX_TILE_SIZE,
                                 TEX_TILE_SIZE,
                                 TEX_TILE_SIZE,
                                 tc->format,
                                 (unsigned *) tile->data.colorui);
      } else if (!zs && util_format_is_pure_sint(tc->format)) {
         pipe_get_tile_i_format(tc->tex_trans, tc->tex_trans_map,
                                addr.bits.x * TEX_TILE_SIZE,
                                addr.bits.y * TEX_TILE_SIZE,
                                TEX_TILE_SIZE,
                                TEX_TILE_SIZE,
                                tc->format,
                                (int *) tile->data.colori);
      } else {
         pipe_get_tile_rgba_format(tc->tex_trans, tc->tex_trans_map,
                                   addr.bits.x * TEX_TILE_SIZE,
                                   addr.bits.y * TEX_TILE_SIZE,
                                   TEX_TILE_SIZE,
                                   TEX_TILE_SIZE,
                                   tc->format,
                                   (float *) tile->data.color);
      }
      tile->addr = addr;
   }

   tc->last_tile = tile;
   return tile;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d38 1
d53 1
a53 1
   assert((TILE_SIZE << TEX_ADDR_BITS) >= (1 << (SP_MAX_TEXTURE_2D_LEVELS-1)));
d58 1
a58 1
      for (pos = 0; pos < NUM_ENTRIES; pos++) {
d73 1
a73 1
      for (pos = 0; pos < NUM_ENTRIES; pos++) {
d77 1
a77 1
         tc->pipe->transfer_destroy(tc->pipe, tc->transfer);
d80 1
a80 1
         tc->pipe->transfer_destroy(tc->pipe, tc->tex_trans);
a87 19


void
sp_tex_tile_cache_map_transfers(struct softpipe_tex_tile_cache *tc)
{
   if (tc->tex_trans && !tc->tex_trans_map)
      tc->tex_trans_map = tc->pipe->transfer_map(tc->pipe, tc->tex_trans);
}


void
sp_tex_tile_cache_unmap_transfers(struct softpipe_tex_tile_cache *tc)
{
   if (tc->tex_trans_map) {
      tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
      tc->tex_trans_map = NULL;
   }
}

d100 1
a100 1
   for (i = 0; i < NUM_ENTRIES; i++) {
d134 2
a135 7
      if (tc->tex_trans) {
         if (tc->tex_trans_map) {
            tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
            tc->tex_trans_map = NULL;
         }

         tc->pipe->transfer_destroy(tc->pipe, tc->tex_trans);
d137 1
d150 1
a150 1
      for (i = 0; i < NUM_ENTRIES; i++) {
d172 1
a172 1
      for (pos = 0; pos < NUM_ENTRIES; pos++) {
d197 1
a197 1
   return entry % NUM_ENTRIES;
d209 2
a210 1
   
d215 1
a215 1
      /* cache miss.  Most misses are because we've invaldiated the
d235 2
a236 7
         if (tc->tex_trans) {
            if (tc->tex_trans_map) {
               tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
               tc->tex_trans_map = NULL;
            }

            tc->pipe->transfer_destroy(tc->pipe, tc->tex_trans);
d238 1
d251 2
a252 2
         tc->tex_trans = 
            pipe_get_transfer(tc->pipe, tc->texture,
d256 1
a256 3
                              0, 0, width, height);

         tc->tex_trans_map = tc->pipe->transfer_map(tc->pipe, tc->tex_trans);
d266 14
a279 6
      pipe_get_tile_rgba_format(tc->pipe,
                                tc->tex_trans,
                                addr.bits.x * TILE_SIZE, 
                                addr.bits.y * TILE_SIZE,
                                TILE_SIZE,
                                TILE_SIZE,
d281 10
a290 2
                                (float *) tile->data.color);

@


1.2
log
@Merge Mesa 7.10.3
@
text
@d254 1
d266 10
d279 1
a279 1
                              addr.bits.face + addr.bits.z,
d281 1
a281 3
                              0, 0,
                              u_minify(tc->texture->width0, addr.bits.level),
                              u_minify(tc->texture->height0, addr.bits.level));
d290 12
a301 13
      /* get tile from the transfer (view into texture) */
      pipe_get_tile_swizzle(tc->pipe,
			    tc->tex_trans,
                            addr.bits.x * TILE_SIZE, 
                            addr.bits.y * TILE_SIZE,
                            TILE_SIZE,
                            TILE_SIZE,
                            tc->swizzle_r,
                            tc->swizzle_g,
                            tc->swizzle_b,
                            tc->swizzle_a,
                            tc->format,
                            (float *) tile->data.color);
a306 23
}



/**
 * Return the swizzled border color.
 */
const float *
sp_tex_tile_cache_border_color(struct softpipe_tex_tile_cache *tc,
                               const float border_color[4])
{
   float rgba01[6];

   COPY_4V(rgba01, border_color);
   rgba01[PIPE_SWIZZLE_ZERO] = 0.0f;
   rgba01[PIPE_SWIZZLE_ONE] = 1.0f;

   tc->swz_border_color[0] = rgba01[tc->swizzle_r];
   tc->swz_border_color[1] = rgba01[tc->swizzle_g];
   tc->swz_border_color[2] = rgba01[tc->swizzle_b];
   tc->swz_border_color[3] = rgba01[tc->swizzle_a];

   return tc->swz_border_color;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d46 1
a46 1
sp_create_tex_tile_cache( struct pipe_screen *screen )
d51 3
d56 1
a56 1
      tc->screen = screen;
d69 12
a80 2
   struct pipe_screen *screen;
   uint pos;
d82 1
a82 2
   for (pos = 0; pos < NUM_ENTRIES; pos++) {
      /*assert(tc->entries[pos].x < 0);*/
a83 10
   if (tc->transfer) {
      screen = tc->transfer->texture->screen;
      screen->tex_transfer_destroy(tc->transfer);
   }
   if (tc->tex_trans) {
      screen = tc->tex_trans->texture->screen;
      screen->tex_transfer_destroy(tc->tex_trans);
   }

   FREE( tc );
d93 1
a93 1
      tc->tex_trans_map = tc->screen->transfer_map(tc->screen, tc->tex_trans);
d101 1
a101 1
      tc->screen->transfer_unmap(tc->screen, tc->tex_trans);
d123 14
d138 1
a138 1
 * Specify the texture to cache.
d141 2
a142 2
sp_tex_tile_cache_set_texture(struct softpipe_tex_tile_cache *tc,
                          struct pipe_texture *texture)
d144 1
d149 2
a150 2
   if (tc->texture != texture) {
      pipe_texture_reference(&tc->texture, texture);
a152 2
         struct pipe_screen *screen = tc->tex_trans->texture->screen;
         
d154 1
a154 1
            screen->transfer_unmap(screen, tc->tex_trans);
d158 1
a158 1
         screen->tex_transfer_destroy(tc->tex_trans);
d162 8
a229 1
   struct pipe_screen *screen = tc->screen;
d257 1
a257 1
               tc->screen->transfer_unmap(tc->screen, tc->tex_trans);
d261 1
a261 1
            screen->tex_transfer_destroy(tc->tex_trans);
d266 9
a274 9
            screen->get_tex_transfer(screen, tc->texture, 
                                     addr.bits.face, 
                                     addr.bits.level, 
                                     addr.bits.z, 
                                     PIPE_TRANSFER_READ, 0, 0,
                                     u_minify(tc->texture->width0, addr.bits.level),
                                     u_minify(tc->texture->height0, addr.bits.level));
         
         tc->tex_trans_map = screen->transfer_map(screen, tc->tex_trans);
d282 12
a293 5
      pipe_get_tile_rgba(tc->tex_trans,
                         addr.bits.x * TILE_SIZE, 
                         addr.bits.y * TILE_SIZE,
                         TILE_SIZE, TILE_SIZE,
                         (float *) tile->data.color);
d303 20
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d46 1
a46 1
sp_create_tex_tile_cache( struct pipe_context *pipe )
a50 3
   /* make sure max texture size works */
   assert((TILE_SIZE << TEX_ADDR_BITS) >= (1 << (SP_MAX_TEXTURE_2D_LEVELS-1)));

d53 1
a53 1
      tc->pipe = pipe;
d66 2
a67 2
   if (tc) {
      uint pos;
d69 11
a79 9
      for (pos = 0; pos < NUM_ENTRIES; pos++) {
         /*assert(tc->entries[pos].x < 0);*/
      }
      if (tc->transfer) {
         tc->pipe->transfer_destroy(tc->pipe, tc->transfer);
      }
      if (tc->tex_trans) {
         tc->pipe->transfer_destroy(tc->pipe, tc->tex_trans);
      }
d81 1
a81 2
      FREE( tc );
   }
d91 1
a91 1
      tc->tex_trans_map = tc->pipe->transfer_map(tc->pipe, tc->tex_trans);
d99 1
a99 1
      tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
a120 14
static boolean
sp_tex_tile_is_compat_view(struct softpipe_tex_tile_cache *tc,
                           struct pipe_sampler_view *view)
{
   if (!view)
      return FALSE;
   return (tc->texture == view->texture &&
           tc->format == view->format &&
           tc->swizzle_r == view->swizzle_r &&
           tc->swizzle_g == view->swizzle_g &&
           tc->swizzle_b == view->swizzle_b &&
           tc->swizzle_a == view->swizzle_a);
}

d122 1
a122 1
 * Specify the sampler view to cache.
d125 2
a126 2
sp_tex_tile_cache_set_sampler_view(struct softpipe_tex_tile_cache *tc,
                                   struct pipe_sampler_view *view)
a127 1
   struct pipe_resource *texture = view ? view->texture : NULL;
d132 2
a133 2
   if (!sp_tex_tile_is_compat_view(tc, view)) {
      pipe_resource_reference(&tc->texture, texture);
d136 2
d139 1
a139 1
            tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
d143 1
a143 1
         tc->pipe->transfer_destroy(tc->pipe, tc->tex_trans);
a146 8
      if (view) {
         tc->swizzle_r = view->swizzle_r;
         tc->swizzle_g = view->swizzle_g;
         tc->swizzle_b = view->swizzle_b;
         tc->swizzle_a = view->swizzle_a;
         tc->format = view->format;
      }

d207 1
d235 1
a235 1
               tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
d239 1
a239 1
            tc->pipe->transfer_destroy(tc->pipe, tc->tex_trans);
d244 9
a252 9
            pipe_get_transfer(tc->pipe, tc->texture,
                              addr.bits.level,
                              addr.bits.face + addr.bits.z,
                              PIPE_TRANSFER_READ | PIPE_TRANSFER_UNSYNCHRONIZED,
                              0, 0,
                              u_minify(tc->texture->width0, addr.bits.level),
                              u_minify(tc->texture->height0, addr.bits.level));

         tc->tex_trans_map = tc->pipe->transfer_map(tc->pipe, tc->tex_trans);
d260 5
a264 12
      pipe_get_tile_swizzle(tc->pipe,
			    tc->tex_trans,
                            addr.bits.x * TILE_SIZE, 
                            addr.bits.y * TILE_SIZE,
                            TILE_SIZE,
                            TILE_SIZE,
                            tc->swizzle_r,
                            tc->swizzle_g,
                            tc->swizzle_b,
                            tc->swizzle_a,
                            tc->format,
                            (float *) tile->data.color);
a273 20
/**
 * Return the swizzled border color.
 */
const float *
sp_tex_tile_cache_border_color(struct softpipe_tex_tile_cache *tc,
                               const float border_color[4])
{
   float rgba01[6];

   COPY_4V(rgba01, border_color);
   rgba01[PIPE_SWIZZLE_ZERO] = 0.0f;
   rgba01[PIPE_SWIZZLE_ONE] = 1.0f;

   tc->swz_border_color[0] = rgba01[tc->swizzle_r];
   tc->swz_border_color[1] = rgba01[tc->swizzle_g];
   tc->swz_border_color[2] = rgba01[tc->swizzle_b];
   tc->swz_border_color[3] = rgba01[tc->swizzle_a];

   return tc->swz_border_color;
}
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a37 1
#include "util/u_format.h"
d52 1
a52 1
   assert((TEX_TILE_SIZE << TEX_ADDR_BITS) >= (1 << (SP_MAX_TEXTURE_2D_LEVELS-1)));
d57 1
a57 1
      for (pos = 0; pos < Elements(tc->entries); pos++) {
d72 1
a72 1
      for (pos = 0; pos < Elements(tc->entries); pos++) {
d76 1
a76 1
         tc->pipe->transfer_unmap(tc->pipe, tc->transfer);
d79 1
a79 1
         tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
d87 19
d118 1
a118 1
   for (i = 0; i < Elements(tc->entries); i++) {
d152 7
a158 2
      if (tc->tex_trans_map) {
         tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
a159 1
         tc->tex_trans_map = NULL;
d172 1
a172 1
      for (i = 0; i < Elements(tc->entries); i++) {
d194 1
a194 1
      for (pos = 0; pos < Elements(tc->entries); pos++) {
d219 1
a219 1
   return entry % NUM_TEX_TILE_ENTRIES;
d231 1
a231 2
   boolean zs = util_format_is_depth_or_stencil(tc->format);

d236 1
a236 1
      /* cache miss.  Most misses are because we've invalidated the
a253 1
         unsigned width, height, layer;
d255 7
a261 2
         if (tc->tex_trans_map) {
            tc->pipe->transfer_unmap(tc->pipe, tc->tex_trans);
a262 11
            tc->tex_trans_map = NULL;
         }

         width = u_minify(tc->texture->width0, addr.bits.level);
         if (tc->texture->target == PIPE_TEXTURE_1D_ARRAY) {
            height = tc->texture->array_size;
            layer = 0;
         }
         else {
            height = u_minify(tc->texture->height0, addr.bits.level);
            layer = addr.bits.face + addr.bits.z;
d265 2
a266 2
         tc->tex_trans_map =
            pipe_transfer_map(tc->pipe, tc->texture,
d268 1
a268 1
                              layer,
d270 5
a274 1
                              0, 0, width, height, &tc->tex_trans);
d281 13
a293 28
      /* Get tile from the transfer (view into texture), explicitly passing
       * the image format.
       */
      if (!zs && util_format_is_pure_uint(tc->format)) {
         pipe_get_tile_ui_format(tc->tex_trans, tc->tex_trans_map,
                                 addr.bits.x * TEX_TILE_SIZE,
                                 addr.bits.y * TEX_TILE_SIZE,
                                 TEX_TILE_SIZE,
                                 TEX_TILE_SIZE,
                                 tc->format,
                                 (unsigned *) tile->data.colorui);
      } else if (!zs && util_format_is_pure_sint(tc->format)) {
         pipe_get_tile_i_format(tc->tex_trans, tc->tex_trans_map,
                                addr.bits.x * TEX_TILE_SIZE,
                                addr.bits.y * TEX_TILE_SIZE,
                                TEX_TILE_SIZE,
                                TEX_TILE_SIZE,
                                tc->format,
                                (int *) tile->data.colori);
      } else {
         pipe_get_tile_rgba_format(tc->tex_trans, tc->tex_trans_map,
                                   addr.bits.x * TEX_TILE_SIZE,
                                   addr.bits.y * TEX_TILE_SIZE,
                                   TEX_TILE_SIZE,
                                   TEX_TILE_SIZE,
                                   tc->format,
                                   (float *) tile->data.color);
      }
d299 23
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


