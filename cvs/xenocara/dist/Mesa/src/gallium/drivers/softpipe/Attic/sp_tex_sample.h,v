head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.07;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * Copyright 2010 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#ifndef SP_TEX_SAMPLE_H
#define SP_TEX_SAMPLE_H


#include "tgsi/tgsi_exec.h"


struct sp_sampler_view;
struct sp_sampler;

typedef void (*wrap_nearest_func)(float s,
                                  unsigned size,
                                  int *icoord);

typedef void (*wrap_linear_func)(float s, 
                                 unsigned size,
                                 int *icoord0,
                                 int *icoord1,
                                 float *w);

typedef float (*compute_lambda_func)(const struct sp_sampler_view *sp_sview,
                                     const float s[TGSI_QUAD_SIZE],
                                     const float t[TGSI_QUAD_SIZE],
                                     const float p[TGSI_QUAD_SIZE]);

typedef void (*img_filter_func)(struct sp_sampler_view *sp_sview,
                                struct sp_sampler *sp_samp,
                                float s,
                                float t,
                                float p,
                                unsigned level,
                                unsigned face_id,
                                float *rgba);

typedef void (*mip_filter_func)(struct sp_sampler_view *sp_sview,
                                struct sp_sampler *sp_samp,
                                img_filter_func min_filter,
                                img_filter_func mag_filter,
                                const float s[TGSI_QUAD_SIZE],
                                const float t[TGSI_QUAD_SIZE],
                                const float p[TGSI_QUAD_SIZE],
                                const float c0[TGSI_QUAD_SIZE],
                                const float lod[TGSI_QUAD_SIZE],
                                enum tgsi_sampler_control control,
                                float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE]);


typedef void (*filter_func)(struct sp_sampler_view *sp_sview,
                            struct sp_sampler *sp_samp,
                            const float s[TGSI_QUAD_SIZE],
                            const float t[TGSI_QUAD_SIZE],
                            const float p[TGSI_QUAD_SIZE],
                            const float c0[TGSI_QUAD_SIZE],
                            const float lod[TGSI_QUAD_SIZE],
                            enum tgsi_sampler_control control,
                            float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE]);


typedef void (*fetch_func)(struct sp_sampler_view *sp_sview,
                           const int i[TGSI_QUAD_SIZE],
                           const int j[TGSI_QUAD_SIZE], const int k[TGSI_QUAD_SIZE],
                           const int lod[TGSI_QUAD_SIZE], const int8_t offset[3],
                           float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE]);


struct sp_sampler_view
{
   struct pipe_sampler_view base;

   /* For sp_get_samples_2d_linear_POT:
    */
   unsigned xpot;
   unsigned ypot;

   boolean need_swizzle;
   boolean pot2d;

   filter_func get_samples;

   /* this is just abusing the sampler_view object as local storage */
   unsigned faces[TGSI_QUAD_SIZE];

   /* these are different per shader type */
   struct softpipe_tex_tile_cache *cache;
   compute_lambda_func compute_lambda;

};


struct sp_sampler {
   struct pipe_sampler_state base;

   boolean min_mag_equal_repeat_linear;
   boolean min_mag_equal;
   unsigned min_img_filter;

   wrap_nearest_func nearest_texcoord_s;
   wrap_nearest_func nearest_texcoord_t;
   wrap_nearest_func nearest_texcoord_p;

   wrap_linear_func linear_texcoord_s;
   wrap_linear_func linear_texcoord_t;
   wrap_linear_func linear_texcoord_p;

   mip_filter_func mip_filter;
};


/**
 * Subclass of tgsi_sampler
 */
struct sp_tgsi_sampler
{
   struct tgsi_sampler base;  /**< base class */
   struct sp_sampler *sp_sampler[PIPE_MAX_SAMPLERS];
   struct sp_sampler_view sp_sview[PIPE_MAX_SHADER_SAMPLER_VIEWS];

};

compute_lambda_func
softpipe_get_lambda_func(const struct pipe_sampler_view *view, unsigned shader);


void *
softpipe_create_sampler_state(struct pipe_context *pipe,
                              const struct pipe_sampler_state *sampler);


struct pipe_sampler_view *
softpipe_create_sampler_view(struct pipe_context *pipe,
                             struct pipe_resource *resource,
                             const struct pipe_sampler_view *templ);


struct sp_tgsi_sampler *
sp_create_tgsi_sampler(void);


#endif /* SP_TEX_SAMPLE_H */
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d22 1
a22 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a34 1
struct sp_sampler_variant;
d36 4
a39 1
typedef void (*wrap_nearest_func)(const float s[4],
d41 1
a41 1
                                  int icoord[4]);
d43 1
a43 1
typedef void (*wrap_linear_func)(const float s[4], 
d45 38
a82 14
                                 int icoord0[4],
                                 int icoord1[4],
                                 float w[4]);

typedef float (*compute_lambda_func)(const struct sp_sampler_variant *sampler,
                                     const float s[QUAD_SIZE],
                                     const float t[QUAD_SIZE],
                                     const float p[QUAD_SIZE]);

typedef void (*filter_func)(struct tgsi_sampler *tgsi_sampler,
                            const float s[QUAD_SIZE],
                            const float t[QUAD_SIZE],
                            const float p[QUAD_SIZE],
                            const float c0[QUAD_SIZE],
d84 2
a85 1
                            float rgba[NUM_CHANNELS][QUAD_SIZE]);
d87 5
a92 14
union sp_sampler_key {
   struct {
      unsigned target:3;
      unsigned is_pot:1;
      unsigned processor:2;
      unsigned unit:4;
      unsigned swizzle_r:3;
      unsigned swizzle_g:3;
      unsigned swizzle_b:3;
      unsigned swizzle_a:3;
      unsigned pad:10;
   } bits;
   unsigned value;
};
d94 1
a94 4
/**
 * Subclass of tgsi_sampler
 */
struct sp_sampler_variant
d96 6
a101 1
   struct tgsi_sampler base;  /**< base class */
d103 2
a104 1
   union sp_sampler_key key;
d106 1
a106 3
   /* The owner of this struct:
    */
   const struct pipe_sampler_state *sampler;
d108 2
d111 1
a111 3
   /* Currently bound texture:
    */
   const struct pipe_sampler_view *view;
d113 3
a116 1
   unsigned processor;
d118 6
a123 5
   /* For sp_get_samples_2d_linear_POT:
    */
   unsigned xpot;
   unsigned ypot;
   unsigned level;
a124 2
   unsigned faces[4];
   
d133 3
a135 2
   filter_func min_img_filter;
   filter_func mag_img_filter;
d137 8
a144 1
   compute_lambda_func compute_lambda;
a145 7
   filter_func mip_filter;
   filter_func compare;
   filter_func sample_target;
   
   /* Linked list:
    */
   struct sp_sampler_variant *next;
d148 2
a149 7
struct sp_sampler;

/* Create a sampler variant for a given set of non-orthogonal state.  Currently the 
 */
struct sp_sampler_variant *
sp_create_sampler_variant( const struct pipe_sampler_state *sampler,
                           const union sp_sampler_key key );
a150 3
void sp_sampler_variant_bind_view( struct sp_sampler_variant *variant,
                                   struct softpipe_tex_tile_cache *tex_cache,
                                   const struct pipe_sampler_view *view );
d152 3
a154 1
void sp_sampler_variant_destroy( struct sp_sampler_variant * );
d157 4
a161 5
static INLINE struct sp_sampler_variant *
sp_sampler_variant(const struct tgsi_sampler *sampler)
{
   return (struct sp_sampler_variant *) sampler;
}
d163 2
a164 7
extern void
sp_get_samples(struct tgsi_sampler *tgsi_sampler,
               const float s[QUAD_SIZE],
               const float t[QUAD_SIZE],
               const float p[QUAD_SIZE],
               float lodbias,
               float rgba[NUM_CHANNELS][QUAD_SIZE]);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d35 1
a35 1
struct sp_sampler_varient;
d47 1
a47 1
typedef float (*compute_lambda_func)(const struct sp_sampler_varient *sampler,
d67 5
a71 1
      unsigned pad:22;
d79 1
a79 1
struct sp_sampler_varient
d92 1
a92 1
   const struct pipe_resource *texture;
d120 1
d124 1
a124 1
   struct sp_sampler_varient *next;
d129 1
a129 1
/* Create a sampler varient for a given set of non-orthogonal state.  Currently the 
d131 2
a132 2
struct sp_sampler_varient *
sp_create_sampler_varient( const struct pipe_sampler_state *sampler,
d135 3
a137 3
void sp_sampler_varient_bind_texture( struct sp_sampler_varient *varient,
                                      struct softpipe_tex_tile_cache *tex_cache,
                                      const struct pipe_resource *tex );
d139 1
a139 1
void sp_sampler_varient_destroy( struct sp_sampler_varient * );
d143 2
a144 2
static INLINE struct sp_sampler_varient *
sp_sampler_varient(const struct tgsi_sampler *sampler)
d146 1
a146 1
   return (struct sp_sampler_varient *) sampler;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d88 1
a88 1
   const struct pipe_texture *texture;
d132 1
a132 1
                                      const struct pipe_texture *tex );
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d88 1
a88 1
   const struct pipe_resource *texture;
d132 1
a132 1
                                      const struct pipe_resource *tex );
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d35 1
d37 1
a37 4
struct sp_sampler_view;
struct sp_sampler;

typedef void (*wrap_nearest_func)(float s,
d39 1
a39 1
                                  int *icoord);
d41 1
a41 1
typedef void (*wrap_linear_func)(float s, 
d43 14
a56 38
                                 int *icoord0,
                                 int *icoord1,
                                 float *w);

typedef float (*compute_lambda_func)(const struct sp_sampler_view *sp_sview,
                                     const float s[TGSI_QUAD_SIZE],
                                     const float t[TGSI_QUAD_SIZE],
                                     const float p[TGSI_QUAD_SIZE]);

typedef void (*img_filter_func)(struct sp_sampler_view *sp_sview,
                                struct sp_sampler *sp_samp,
                                float s,
                                float t,
                                float p,
                                unsigned level,
                                unsigned face_id,
                                float *rgba);

typedef void (*mip_filter_func)(struct sp_sampler_view *sp_sview,
                                struct sp_sampler *sp_samp,
                                img_filter_func min_filter,
                                img_filter_func mag_filter,
                                const float s[TGSI_QUAD_SIZE],
                                const float t[TGSI_QUAD_SIZE],
                                const float p[TGSI_QUAD_SIZE],
                                const float c0[TGSI_QUAD_SIZE],
                                const float lod[TGSI_QUAD_SIZE],
                                enum tgsi_sampler_control control,
                                float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE]);


typedef void (*filter_func)(struct sp_sampler_view *sp_sview,
                            struct sp_sampler *sp_samp,
                            const float s[TGSI_QUAD_SIZE],
                            const float t[TGSI_QUAD_SIZE],
                            const float p[TGSI_QUAD_SIZE],
                            const float c0[TGSI_QUAD_SIZE],
                            const float lod[TGSI_QUAD_SIZE],
d58 1
a58 1
                            float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE]);
d61 10
a70 5
typedef void (*fetch_func)(struct sp_sampler_view *sp_sview,
                           const int i[TGSI_QUAD_SIZE],
                           const int j[TGSI_QUAD_SIZE], const int k[TGSI_QUAD_SIZE],
                           const int lod[TGSI_QUAD_SIZE], const int8_t offset[3],
                           float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE]);
d72 6
d79 1
a79 3
struct sp_sampler_view
{
   struct pipe_sampler_view base;
d81 1
a81 1
   /* For sp_get_samples_2d_linear_POT:
d83 1
a83 2
   unsigned xpot;
   unsigned ypot;
a84 2
   boolean need_swizzle;
   boolean pot2d;
d86 3
a88 6
   filter_func get_samples;

   /* this is just abusing the sampler_view object as local storage */
   unsigned faces[TGSI_QUAD_SIZE];

   /* these are different per shader type */
a89 1
   compute_lambda_func compute_lambda;
d91 1
a91 1
};
d93 5
d99 2
a100 7
struct sp_sampler {
   struct pipe_sampler_state base;

   boolean min_mag_equal_repeat_linear;
   boolean min_mag_equal;
   unsigned min_img_filter;

d109 11
a119 1
   mip_filter_func mip_filter;
d122 1
d124 1
a124 2
/**
 * Subclass of tgsi_sampler
d126 3
a128 5
struct sp_tgsi_sampler
{
   struct tgsi_sampler base;  /**< base class */
   struct sp_sampler *sp_sampler[PIPE_MAX_SAMPLERS];
   struct sp_sampler_view sp_sview[PIPE_MAX_SHADER_SAMPLER_VIEWS];
d130 3
a132 1
};
d134 1
a134 2
compute_lambda_func
softpipe_get_lambda_func(const struct pipe_sampler_view *view, unsigned shader);
a136 9
void *
softpipe_create_sampler_state(struct pipe_context *pipe,
                              const struct pipe_sampler_state *sampler);


struct pipe_sampler_view *
softpipe_create_sampler_view(struct pipe_context *pipe,
                             struct pipe_resource *resource,
                             const struct pipe_sampler_view *templ);
d138 5
d144 7
a150 2
struct sp_tgsi_sampler *
sp_create_tgsi_sampler(void);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


