head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.07;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.49;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.04;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * Copyright 2008-2010 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * Texture sampling
 *
 * Authors:
 *   Brian Paul
 *   Keith Whitwell
 */

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "pipe/p_shader_tokens.h"
#include "util/u_math.h"
#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "sp_quad.h"   /* only for #define QUAD_* tokens */
#include "sp_tex_sample.h"
#include "sp_texture.h"
#include "sp_tex_tile_cache.h"


/** Set to one to help debug texture sampling */
#define DEBUG_TEX 0


/*
 * Return fractional part of 'f'.  Used for computing interpolation weights.
 * Need to be careful with negative values.
 * Note, if this function isn't perfect you'll sometimes see 1-pixel bands
 * of improperly weighted linear-filtered textures.
 * The tests/texwrap.c demo is a good test.
 */
static INLINE float
frac(float f)
{
   return f - floorf(f);
}



/**
 * Linear interpolation macro
 */
static INLINE float
lerp(float a, float v0, float v1)
{
   return v0 + a * (v1 - v0);
}


/**
 * Do 2D/bilinear interpolation of float values.
 * v00, v10, v01 and v11 are typically four texture samples in a square/box.
 * a and b are the horizontal and vertical interpolants.
 * It's important that this function is inlined when compiled with
 * optimization!  If we find that's not true on some systems, convert
 * to a macro.
 */
static INLINE float
lerp_2d(float a, float b,
        float v00, float v10, float v01, float v11)
{
   const float temp0 = lerp(a, v00, v10);
   const float temp1 = lerp(a, v01, v11);
   return lerp(b, temp0, temp1);
}


/**
 * As above, but 3D interpolation of 8 values.
 */
static INLINE float
lerp_3d(float a, float b, float c,
        float v000, float v100, float v010, float v110,
        float v001, float v101, float v011, float v111)
{
   const float temp0 = lerp_2d(a, b, v000, v100, v010, v110);
   const float temp1 = lerp_2d(a, b, v001, v101, v011, v111);
   return lerp(c, temp0, temp1);
}



/**
 * Compute coord % size for repeat wrap modes.
 * Note that if coord is negative, coord % size doesn't give the right
 * value.  To avoid that problem we add a large multiple of the size
 * (rather than using a conditional).
 */
static INLINE int
repeat(int coord, unsigned size)
{
   return (coord + size * 1024) % size;
}


/**
 * Apply texture coord wrapping mode and return integer texture indexes
 * for a vector of four texcoords (S or T or P).
 * \param wrapMode  PIPE_TEX_WRAP_x
 * \param s  the incoming texcoords
 * \param size  the texture image size
 * \param icoord  returns the integer texcoords
 */
static void
wrap_nearest_repeat(float s, unsigned size, int *icoord)
{
   /* s limited to [0,1) */
   /* i limited to [0,size-1] */
   int i = util_ifloor(s * size);
   *icoord = repeat(i, size);
}


static void
wrap_nearest_clamp(float s, unsigned size, int *icoord)
{
   /* s limited to [0,1] */
   /* i limited to [0,size-1] */
   if (s <= 0.0F)
      *icoord = 0;
   else if (s >= 1.0F)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(s * size);
}


static void
wrap_nearest_clamp_to_edge(float s, unsigned size, int *icoord)
{
   /* s limited to [min,max] */
   /* i limited to [0, size-1] */
   const float min = 1.0F / (2.0F * size);
   const float max = 1.0F - min;
   if (s < min)
      *icoord = 0;
   else if (s > max)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(s * size);
}


static void
wrap_nearest_clamp_to_border(float s, unsigned size, int *icoord)
{
   /* s limited to [min,max] */
   /* i limited to [-1, size] */
   const float min = -1.0F / (2.0F * size);
   const float max = 1.0F - min;
   if (s <= min)
      *icoord = -1;
   else if (s >= max)
      *icoord = size;
   else
      *icoord = util_ifloor(s * size);
}


static void
wrap_nearest_mirror_repeat(float s, unsigned size, int *icoord)
{
   const float min = 1.0F / (2.0F * size);
   const float max = 1.0F - min;
   const int flr = util_ifloor(s);
   float u = frac(s);
   if (flr & 1)
      u = 1.0F - u;
   if (u < min)
      *icoord = 0;
   else if (u > max)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(u * size);
}


static void
wrap_nearest_mirror_clamp(float s, unsigned size, int *icoord)
{
   /* s limited to [0,1] */
   /* i limited to [0,size-1] */
   const float u = fabsf(s);
   if (u <= 0.0F)
      *icoord = 0;
   else if (u >= 1.0F)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(u * size);
}


static void
wrap_nearest_mirror_clamp_to_edge(float s, unsigned size, int *icoord)
{
   /* s limited to [min,max] */
   /* i limited to [0, size-1] */
   const float min = 1.0F / (2.0F * size);
   const float max = 1.0F - min;
   const float u = fabsf(s);
   if (u < min)
      *icoord = 0;
   else if (u > max)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(u * size);
}


static void
wrap_nearest_mirror_clamp_to_border(float s, unsigned size, int *icoord)
{
   /* s limited to [min,max] */
   /* i limited to [0, size-1] */
   const float min = -1.0F / (2.0F * size);
   const float max = 1.0F - min;
   const float u = fabsf(s);
   if (u < min)
      *icoord = -1;
   else if (u > max)
      *icoord = size;
   else
      *icoord = util_ifloor(u * size);
}


/**
 * Used to compute texel locations for linear sampling
 * \param wrapMode  PIPE_TEX_WRAP_x
 * \param s  the texcoord
 * \param size  the texture image size
 * \param icoord0  returns first texture index
 * \param icoord1  returns second texture index (usually icoord0 + 1)
 * \param w  returns blend factor/weight between texture indices
 * \param icoord  returns the computed integer texture coord
 */
static void
wrap_linear_repeat(float s, unsigned size,
                   int *icoord0, int *icoord1, float *w)
{
   float u = s * size - 0.5F;
   *icoord0 = repeat(util_ifloor(u), size);
   *icoord1 = repeat(*icoord0 + 1, size);
   *w = frac(u);
}


static void
wrap_linear_clamp(float s, unsigned size,
                  int *icoord0, int *icoord1, float *w)
{
   float u = CLAMP(s, 0.0F, 1.0F);
   u = u * size - 0.5f;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
}


static void
wrap_linear_clamp_to_edge(float s, unsigned size,
                          int *icoord0, int *icoord1, float *w)
{
   float u = CLAMP(s, 0.0F, 1.0F);
   u = u * size - 0.5f;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord0 < 0)
      *icoord0 = 0;
   if (*icoord1 >= (int) size)
      *icoord1 = size - 1;
   *w = frac(u);
}


static void
wrap_linear_clamp_to_border(float s, unsigned size,
                            int *icoord0, int *icoord1, float *w)
{
   const float min = -1.0F / (2.0F * size);
   const float max = 1.0F - min;
   float u = CLAMP(s, min, max);
   u = u * size - 0.5f;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
}


static void
wrap_linear_mirror_repeat(float s, unsigned size,
                          int *icoord0, int *icoord1, float *w)
{
   const int flr = util_ifloor(s);
   float u = frac(s);
   if (flr & 1)
      u = 1.0F - u;
   u = u * size - 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord0 < 0)
      *icoord0 = 0;
   if (*icoord1 >= (int) size)
      *icoord1 = size - 1;
   *w = frac(u);
}


static void
wrap_linear_mirror_clamp(float s, unsigned size,
                         int *icoord0, int *icoord1, float *w)
{
   float u = fabsf(s);
   if (u >= 1.0F)
      u = (float) size;
   else
      u *= size;
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
}


static void
wrap_linear_mirror_clamp_to_edge(float s, unsigned size,
                                 int *icoord0, int *icoord1, float *w)
{
   float u = fabsf(s);
   if (u >= 1.0F)
      u = (float) size;
   else
      u *= size;
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord0 < 0)
      *icoord0 = 0;
   if (*icoord1 >= (int) size)
      *icoord1 = size - 1;
   *w = frac(u);
}


static void
wrap_linear_mirror_clamp_to_border(float s, unsigned size,
                                   int *icoord0, int *icoord1, float *w)
{
   const float min = -1.0F / (2.0F * size);
   const float max = 1.0F - min;
   float u = fabsf(s);
   if (u <= min)
      u = min * size;
   else if (u >= max)
      u = max * size;
   else
      u *= size;
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
}


/**
 * PIPE_TEX_WRAP_CLAMP for nearest sampling, unnormalized coords.
 */
static void
wrap_nearest_unorm_clamp(float s, unsigned size, int *icoord)
{
   int i = util_ifloor(s);
   *icoord = CLAMP(i, 0, (int) size-1);
}


/**
 * PIPE_TEX_WRAP_CLAMP_TO_BORDER for nearest sampling, unnormalized coords.
 */
static void
wrap_nearest_unorm_clamp_to_border(float s, unsigned size, int *icoord)
{
   *icoord = util_ifloor( CLAMP(s, -0.5F, (float) size + 0.5F) );
}


/**
 * PIPE_TEX_WRAP_CLAMP_TO_EDGE for nearest sampling, unnormalized coords.
 */
static void
wrap_nearest_unorm_clamp_to_edge(float s, unsigned size, int *icoord)
{
   *icoord = util_ifloor( CLAMP(s, 0.5F, (float) size - 0.5F) );
}


/**
 * PIPE_TEX_WRAP_CLAMP for linear sampling, unnormalized coords.
 */
static void
wrap_linear_unorm_clamp(float s, unsigned size,
                        int *icoord0, int *icoord1, float *w)
{
   /* Not exactly what the spec says, but it matches NVIDIA output */
   float u = CLAMP(s - 0.5F, 0.0f, (float) size - 1.0f);
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
}


/**
 * PIPE_TEX_WRAP_CLAMP_TO_BORDER for linear sampling, unnormalized coords.
 */
static void
wrap_linear_unorm_clamp_to_border(float s, unsigned size,
                                  int *icoord0, int *icoord1, float *w)
{
   float u = CLAMP(s, -0.5F, (float) size + 0.5F);
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord1 > (int) size - 1)
      *icoord1 = size - 1;
   *w = frac(u);
}


/**
 * PIPE_TEX_WRAP_CLAMP_TO_EDGE for linear sampling, unnormalized coords.
 */
static void
wrap_linear_unorm_clamp_to_edge(float s, unsigned size,
                                int *icoord0, int *icoord1, float *w)
{
   float u = CLAMP(s, +0.5F, (float) size - 0.5F);
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord1 > (int) size - 1)
      *icoord1 = size - 1;
   *w = frac(u);
}


/**
 * Do coordinate to array index conversion.  For array textures.
 */
static INLINE void
wrap_array_layer(float coord, unsigned size, int *layer)
{
   int c = util_ifloor(coord + 0.5F);
   *layer = CLAMP(c, 0, (int) size - 1);
}


/**
 * Examine the quad's texture coordinates to compute the partial
 * derivatives w.r.t X and Y, then compute lambda (level of detail).
 */
static float
compute_lambda_1d(const struct sp_sampler_view *sview,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sview->base.texture;
   float dsdx = fabsf(s[QUAD_BOTTOM_RIGHT] - s[QUAD_BOTTOM_LEFT]);
   float dsdy = fabsf(s[QUAD_TOP_LEFT]     - s[QUAD_BOTTOM_LEFT]);
   float rho = MAX2(dsdx, dsdy) * u_minify(texture->width0, sview->base.u.tex.first_level);

   return util_fast_log2(rho);
}


static float
compute_lambda_2d(const struct sp_sampler_view *sview,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sview->base.texture;
   float dsdx = fabsf(s[QUAD_BOTTOM_RIGHT] - s[QUAD_BOTTOM_LEFT]);
   float dsdy = fabsf(s[QUAD_TOP_LEFT]     - s[QUAD_BOTTOM_LEFT]);
   float dtdx = fabsf(t[QUAD_BOTTOM_RIGHT] - t[QUAD_BOTTOM_LEFT]);
   float dtdy = fabsf(t[QUAD_TOP_LEFT]     - t[QUAD_BOTTOM_LEFT]);
   float maxx = MAX2(dsdx, dsdy) * u_minify(texture->width0, sview->base.u.tex.first_level);
   float maxy = MAX2(dtdx, dtdy) * u_minify(texture->height0, sview->base.u.tex.first_level);
   float rho  = MAX2(maxx, maxy);

   return util_fast_log2(rho);
}


static float
compute_lambda_3d(const struct sp_sampler_view *sview,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sview->base.texture;
   float dsdx = fabsf(s[QUAD_BOTTOM_RIGHT] - s[QUAD_BOTTOM_LEFT]);
   float dsdy = fabsf(s[QUAD_TOP_LEFT]     - s[QUAD_BOTTOM_LEFT]);
   float dtdx = fabsf(t[QUAD_BOTTOM_RIGHT] - t[QUAD_BOTTOM_LEFT]);
   float dtdy = fabsf(t[QUAD_TOP_LEFT]     - t[QUAD_BOTTOM_LEFT]);
   float dpdx = fabsf(p[QUAD_BOTTOM_RIGHT] - p[QUAD_BOTTOM_LEFT]);
   float dpdy = fabsf(p[QUAD_TOP_LEFT]     - p[QUAD_BOTTOM_LEFT]);
   float maxx = MAX2(dsdx, dsdy) * u_minify(texture->width0, sview->base.u.tex.first_level);
   float maxy = MAX2(dtdx, dtdy) * u_minify(texture->height0, sview->base.u.tex.first_level);
   float maxz = MAX2(dpdx, dpdy) * u_minify(texture->depth0, sview->base.u.tex.first_level);
   float rho;

   rho = MAX2(maxx, maxy);
   rho = MAX2(rho, maxz);

   return util_fast_log2(rho);
}


/**
 * Compute lambda for a vertex texture sampler.
 * Since there aren't derivatives to use, just return 0.
 */
static float
compute_lambda_vert(const struct sp_sampler_view *sview,
                    const float s[TGSI_QUAD_SIZE],
                    const float t[TGSI_QUAD_SIZE],
                    const float p[TGSI_QUAD_SIZE])
{
   return 0.0f;
}



/**
 * Get a texel from a texture, using the texture tile cache.
 *
 * \param addr  the template tex address containing cube, z, face info.
 * \param x  the x coord of texel within 2D image
 * \param y  the y coord of texel within 2D image
 * \param rgba  the quad to put the texel/color into
 *
 * XXX maybe move this into sp_tex_tile_cache.c and merge with the
 * sp_get_cached_tile_tex() function.
 */




static INLINE const float *
get_texel_2d_no_border(const struct sp_sampler_view *sp_sview,
                       union tex_tile_address addr, int x, int y)
{
   const struct softpipe_tex_cached_tile *tile;
   addr.bits.x = x / TEX_TILE_SIZE;
   addr.bits.y = y / TEX_TILE_SIZE;
   y %= TEX_TILE_SIZE;
   x %= TEX_TILE_SIZE;

   tile = sp_get_cached_tile_tex(sp_sview->cache, addr);

   return &tile->data.color[y][x][0];
}


static INLINE const float *
get_texel_2d(const struct sp_sampler_view *sp_sview,
             const struct sp_sampler *sp_samp,
             union tex_tile_address addr, int x, int y)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;

   if (x < 0 || x >= (int) u_minify(texture->width0, level) ||
       y < 0 || y >= (int) u_minify(texture->height0, level)) {
      return sp_samp->base.border_color.f;
   }
   else {
      return get_texel_2d_no_border( sp_sview, addr, x, y );
   }
}


/*
 * Here's the complete logic (HOLY CRAP) for finding next face and doing the
 * corresponding coord wrapping, implemented by get_next_face,
 * get_next_xcoord, get_next_ycoord.
 * Read like that (first line):
 * If face is +x and s coord is below zero, then
 * new face is +z, new s is max , new t is old t
 * (max is always cube size - 1).
 *
 * +x s- -> +z: s = max,   t = t
 * +x s+ -> -z: s = 0,     t = t
 * +x t- -> +y: s = max,   t = max-s
 * +x t+ -> -y: s = max,   t = s
 *
 * -x s- -> -z: s = max,   t = t
 * -x s+ -> +z: s = 0,     t = t
 * -x t- -> +y: s = 0,     t = s
 * -x t+ -> -y: s = 0,     t = max-s
 *
 * +y s- -> -x: s = t,     t = 0
 * +y s+ -> +x: s = max-t, t = 0
 * +y t- -> -z: s = max-s, t = 0
 * +y t+ -> +z: s = s,     t = 0
 *
 * -y s- -> -x: s = max-t, t = max
 * -y s+ -> +x: s = t,     t = max
 * -y t- -> +z: s = s,     t = max
 * -y t+ -> -z: s = max-s, t = max

 * +z s- -> -x: s = max,   t = t
 * +z s+ -> +x: s = 0,     t = t
 * +z t- -> +y: s = s,     t = max
 * +z t+ -> -y: s = s,     t = 0

 * -z s- -> +x: s = max,   t = t
 * -z s+ -> -x: s = 0,     t = t
 * -z t- -> +y: s = max-s, t = 0
 * -z t+ -> -y: s = max-s, t = max
 */


/*
 * seamless cubemap neighbour array.
 * this array is used to find the adjacent face in each of 4 directions,
 * left, right, up, down. (or -x, +x, -y, +y).
 */
static const unsigned face_array[PIPE_TEX_FACE_MAX][4] = {
   /* pos X first then neg X is Z different, Y the same */
   /* PIPE_TEX_FACE_POS_X,*/
   { PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z,
     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },
   /* PIPE_TEX_FACE_NEG_X */
   { PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z,
     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },

   /* pos Y first then neg Y is X different, X the same */
   /* PIPE_TEX_FACE_POS_Y */
   { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
     PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z },

   /* PIPE_TEX_FACE_NEG_Y */
   { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
     PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z },

   /* pos Z first then neg Y is X different, X the same */
   /* PIPE_TEX_FACE_POS_Z */
   { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },

   /* PIPE_TEX_FACE_NEG_Z */
   { PIPE_TEX_FACE_POS_X, PIPE_TEX_FACE_NEG_X,
     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y }
};

static INLINE unsigned
get_next_face(unsigned face, int idx)
{
   return face_array[face][idx];
}

/*
 * return a new xcoord based on old face, old coords, cube size
 * and fall_off_index (0 for x-, 1 for x+, 2 for y-, 3 for y+)
 */
static INLINE int
get_next_xcoord(unsigned face, unsigned fall_off_index, int max, int xc, int yc)
{
   if ((face == 0 && fall_off_index != 1) ||
       (face == 1 && fall_off_index == 0) ||
       (face == 4 && fall_off_index == 0) ||
       (face == 5 && fall_off_index == 0)) {
      return max;
   }
   if ((face == 1 && fall_off_index != 0) ||
       (face == 0 && fall_off_index == 1) ||
       (face == 4 && fall_off_index == 1) ||
       (face == 5 && fall_off_index == 1)) {
      return 0;
   }
   if ((face == 4 && fall_off_index >= 2) ||
       (face == 2 && fall_off_index == 3) ||
       (face == 3 && fall_off_index == 2)) {
      return xc;
   }
   if ((face == 5 && fall_off_index >= 2) ||
       (face == 2 && fall_off_index == 2) ||
       (face == 3 && fall_off_index == 3)) {
      return max - xc;
   }
   if ((face == 2 && fall_off_index == 0) ||
       (face == 3 && fall_off_index == 1)) {
      return yc;
   }
   /* (face == 2 && fall_off_index == 1) ||
      (face == 3 && fall_off_index == 0)) */
   return max - yc;
}

/*
 * return a new ycoord based on old face, old coords, cube size
 * and fall_off_index (0 for x-, 1 for x+, 2 for y-, 3 for y+)
 */
static INLINE int
get_next_ycoord(unsigned face, unsigned fall_off_index, int max, int xc, int yc)
{
   if ((fall_off_index <= 1) && (face <= 1 || face >= 4)) {
      return yc;
   }
   if (face == 2 ||
       (face == 4 && fall_off_index == 3) ||
       (face == 5 && fall_off_index == 2)) {
      return 0;
   }
   if (face == 3 ||
       (face == 4 && fall_off_index == 2) ||
       (face == 5 && fall_off_index == 3)) {
      return max;
   }
   if ((face == 0 && fall_off_index == 3) ||
       (face == 1 && fall_off_index == 2)) {
      return xc;
   }
   /* (face == 0 && fall_off_index == 2) ||
      (face == 1 && fall_off_index == 3) */
   return max - xc;
}


static INLINE const float *
get_texel_cube_seamless(const struct sp_sampler_view *sp_sview,
                        union tex_tile_address addr, int x, int y,
                        float *corner)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;
   unsigned face = addr.bits.face;
   int new_x, new_y, max_x;

   max_x = (int) u_minify(texture->width0, level);

   assert(texture->width0 == texture->height0);
   new_x = x;
   new_y = y;

   /* change the face */
   if (x < 0) {
      /*
       * Cheat with corners. They are difficult and I believe because we don't get
       * per-pixel faces we can actually have multiple corner texels per pixel,
       * which screws things up majorly in any case (as the per spec behavior is
       * to average the 3 remaining texels, which we might not have).
       * Hence just make sure that the 2nd coord is clamped, will simply pick the
       * sample which would have fallen off the x coord, but not y coord.
       * So the filter weight of the samples will be wrong, but at least this
       * ensures that only valid texels near the corner are used.
       */
      if (y < 0 || y >= max_x) {
         y = CLAMP(y, 0, max_x - 1);
      }
      new_x = get_next_xcoord(face, 0, max_x -1, x, y);
      new_y = get_next_ycoord(face, 0, max_x -1, x, y);
      face = get_next_face(face, 0);
   } else if (x >= max_x) {
      if (y < 0 || y >= max_x) {
         y = CLAMP(y, 0, max_x - 1);
      }
      new_x = get_next_xcoord(face, 1, max_x -1, x, y);
      new_y = get_next_ycoord(face, 1, max_x -1, x, y);
      face = get_next_face(face, 1);
   } else if (y < 0) {
      new_x = get_next_xcoord(face, 2, max_x -1, x, y);
      new_y = get_next_ycoord(face, 2, max_x -1, x, y);
      face = get_next_face(face, 2);
   } else if (y >= max_x) {
      new_x = get_next_xcoord(face, 3, max_x -1, x, y);
      new_y = get_next_ycoord(face, 3, max_x -1, x, y);
      face = get_next_face(face, 3);
   }

   addr.bits.face = face;
   return get_texel_2d_no_border( sp_sview, addr, new_x, new_y );
}

/* Gather a quad of adjacent texels within a tile:
 */
static INLINE void
get_texel_quad_2d_no_border_single_tile(const struct sp_sampler_view *sp_sview,
                                        union tex_tile_address addr,
                                        unsigned x, unsigned y,
                                        const float *out[4])
{
    const struct softpipe_tex_cached_tile *tile;

   addr.bits.x = x / TEX_TILE_SIZE;
   addr.bits.y = y / TEX_TILE_SIZE;
   y %= TEX_TILE_SIZE;
   x %= TEX_TILE_SIZE;

   tile = sp_get_cached_tile_tex(sp_sview->cache, addr);
      
   out[0] = &tile->data.color[y  ][x  ][0];
   out[1] = &tile->data.color[y  ][x+1][0];
   out[2] = &tile->data.color[y+1][x  ][0];
   out[3] = &tile->data.color[y+1][x+1][0];
}


/* Gather a quad of potentially non-adjacent texels:
 */
static INLINE void
get_texel_quad_2d_no_border(const struct sp_sampler_view *sp_sview,
                            union tex_tile_address addr,
                            int x0, int y0,
                            int x1, int y1,
                            const float *out[4])
{
   out[0] = get_texel_2d_no_border( sp_sview, addr, x0, y0 );
   out[1] = get_texel_2d_no_border( sp_sview, addr, x1, y0 );
   out[2] = get_texel_2d_no_border( sp_sview, addr, x0, y1 );
   out[3] = get_texel_2d_no_border( sp_sview, addr, x1, y1 );
}

/* Can involve a lot of unnecessary checks for border color:
 */
static INLINE void
get_texel_quad_2d(const struct sp_sampler_view *sp_sview,
                  const struct sp_sampler *sp_samp,
                  union tex_tile_address addr,
                  int x0, int y0,
                  int x1, int y1,
                  const float *out[4])
{
   out[0] = get_texel_2d( sp_sview, sp_samp, addr, x0, y0 );
   out[1] = get_texel_2d( sp_sview, sp_samp, addr, x1, y0 );
   out[3] = get_texel_2d( sp_sview, sp_samp, addr, x1, y1 );
   out[2] = get_texel_2d( sp_sview, sp_samp, addr, x0, y1 );
}



/* 3d variants:
 */
static INLINE const float *
get_texel_3d_no_border(const struct sp_sampler_view *sp_sview,
                       union tex_tile_address addr, int x, int y, int z)
{
   const struct softpipe_tex_cached_tile *tile;

   addr.bits.x = x / TEX_TILE_SIZE;
   addr.bits.y = y / TEX_TILE_SIZE;
   addr.bits.z = z;
   y %= TEX_TILE_SIZE;
   x %= TEX_TILE_SIZE;

   tile = sp_get_cached_tile_tex(sp_sview->cache, addr);

   return &tile->data.color[y][x][0];
}


static INLINE const float *
get_texel_3d(const struct sp_sampler_view *sp_sview,
             const struct sp_sampler *sp_samp,
             union tex_tile_address addr, int x, int y, int z)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;

   if (x < 0 || x >= (int) u_minify(texture->width0, level) ||
       y < 0 || y >= (int) u_minify(texture->height0, level) ||
       z < 0 || z >= (int) u_minify(texture->depth0, level)) {
      return sp_samp->base.border_color.f;
   }
   else {
      return get_texel_3d_no_border( sp_sview, addr, x, y, z );
   }
}


/* Get texel pointer for 1D array texture */
static INLINE const float *
get_texel_1d_array(const struct sp_sampler_view *sp_sview,
                   const struct sp_sampler *sp_samp,
                   union tex_tile_address addr, int x, int y)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;

   if (x < 0 || x >= (int) u_minify(texture->width0, level)) {
      return sp_samp->base.border_color.f;
   }
   else {
      return get_texel_2d_no_border(sp_sview, addr, x, y);
   }
}


/* Get texel pointer for 2D array texture */
static INLINE const float *
get_texel_2d_array(const struct sp_sampler_view *sp_sview,
                   const struct sp_sampler *sp_samp,
                   union tex_tile_address addr, int x, int y, int layer)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;

   assert(layer < (int) texture->array_size);
   assert(layer >= 0);

   if (x < 0 || x >= (int) u_minify(texture->width0, level) ||
       y < 0 || y >= (int) u_minify(texture->height0, level)) {
      return sp_samp->base.border_color.f;
   }
   else {
      return get_texel_3d_no_border(sp_sview, addr, x, y, layer);
   }
}


/* Get texel pointer for cube array texture */
static INLINE const float *
get_texel_cube_array(const struct sp_sampler_view *sp_sview,
                     const struct sp_sampler *sp_samp,
                     union tex_tile_address addr, int x, int y, int layer)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;

   assert(layer < (int) texture->array_size);
   assert(layer >= 0);

   if (x < 0 || x >= (int) u_minify(texture->width0, level) ||
       y < 0 || y >= (int) u_minify(texture->height0, level)) {
      return sp_samp->base.border_color.f;
   }
   else {
      return get_texel_3d_no_border(sp_sview, addr, x, y, layer);
   }
}
/**
 * Given the logbase2 of a mipmap's base level size and a mipmap level,
 * return the size (in texels) of that mipmap level.
 * For example, if level[0].width = 256 then base_pot will be 8.
 * If level = 2, then we'll return 64 (the width at level=2).
 * Return 1 if level > base_pot.
 */
static INLINE unsigned
pot_level_size(unsigned base_pot, unsigned level)
{
   return (base_pot >= level) ? (1 << (base_pot - level)) : 1;
}


static void
print_sample(const char *function, const float *rgba)
{
   debug_printf("%s %g %g %g %g\n",
                function,
                rgba[0], rgba[TGSI_NUM_CHANNELS], rgba[2*TGSI_NUM_CHANNELS], rgba[3*TGSI_NUM_CHANNELS]);
}


static void
print_sample_4(const char *function, float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   debug_printf("%s %g %g %g %g, %g %g %g %g, %g %g %g %g, %g %g %g %g\n",
                function,
                rgba[0][0], rgba[1][0], rgba[2][0], rgba[3][0],
                rgba[0][1], rgba[1][1], rgba[2][1], rgba[3][1],
                rgba[0][2], rgba[1][2], rgba[2][2], rgba[3][2],
                rgba[0][3], rgba[1][3], rgba[2][3], rgba[3][3]);
}


/* Some image-filter fastpaths:
 */
static INLINE void
img_filter_2d_linear_repeat_POT(struct sp_sampler_view *sp_sview,
                                struct sp_sampler *sp_samp,
                                float s,
                                float t,
                                float p,
                                unsigned level,
                                unsigned face_id,
                                float *rgba)
{
   unsigned xpot = pot_level_size(sp_sview->xpot, level);
   unsigned ypot = pot_level_size(sp_sview->ypot, level);
   int xmax = (xpot - 1) & (TEX_TILE_SIZE - 1); /* MIN2(TEX_TILE_SIZE, xpot) - 1; */
   int ymax = (ypot - 1) & (TEX_TILE_SIZE - 1); /* MIN2(TEX_TILE_SIZE, ypot) - 1; */
   union tex_tile_address addr;
   int c;

   float u = s * xpot - 0.5F;
   float v = t * ypot - 0.5F;

   int uflr = util_ifloor(u);
   int vflr = util_ifloor(v);

   float xw = u - (float)uflr;
   float yw = v - (float)vflr;

   int x0 = uflr & (xpot - 1);
   int y0 = vflr & (ypot - 1);

   const float *tx[4];
      
   addr.value = 0;
   addr.bits.level = level;

   /* Can we fetch all four at once:
    */
   if (x0 < xmax && y0 < ymax) {
      get_texel_quad_2d_no_border_single_tile(sp_sview, addr, x0, y0, tx);
   }
   else {
      unsigned x1 = (x0 + 1) & (xpot - 1);
      unsigned y1 = (y0 + 1) & (ypot - 1);
      get_texel_quad_2d_no_border(sp_sview, addr, x0, y0, x1, y1, tx);
   }

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++) {
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw, 
                                       tx[0][c], tx[1][c], 
                                       tx[2][c], tx[3][c]);
   }

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}


static INLINE void
img_filter_2d_nearest_repeat_POT(struct sp_sampler_view *sp_sview,
                                 struct sp_sampler *sp_samp,
                                 float s,
                                 float t,
                                 float p,
                                 unsigned level,
                                 unsigned face_id,
                                 float rgba[TGSI_QUAD_SIZE])
{
   unsigned xpot = pot_level_size(sp_sview->xpot, level);
   unsigned ypot = pot_level_size(sp_sview->ypot, level);
   const float *out;
   union tex_tile_address addr;
   int c;

   float u = s * xpot;
   float v = t * ypot;

   int uflr = util_ifloor(u);
   int vflr = util_ifloor(v);

   int x0 = uflr & (xpot - 1);
   int y0 = vflr & (ypot - 1);

   addr.value = 0;
   addr.bits.level = level;

   out = get_texel_2d_no_border(sp_sview, addr, x0, y0);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}


static INLINE void
img_filter_2d_nearest_clamp_POT(struct sp_sampler_view *sp_sview,
                                struct sp_sampler *sp_samp,
                                float s,
                                float t,
                                float p,
                                unsigned level,
                                unsigned face_id,
                                float rgba[TGSI_QUAD_SIZE])
{
   unsigned xpot = pot_level_size(sp_sview->xpot, level);
   unsigned ypot = pot_level_size(sp_sview->ypot, level);
   union tex_tile_address addr;
   int c;

   float u = s * xpot;
   float v = t * ypot;

   int x0, y0;
   const float *out;

   addr.value = 0;
   addr.bits.level = level;

   x0 = util_ifloor(u);
   if (x0 < 0) 
      x0 = 0;
   else if (x0 > (int) xpot - 1)
      x0 = xpot - 1;

   y0 = util_ifloor(v);
   if (y0 < 0) 
      y0 = 0;
   else if (y0 > (int) ypot - 1)
      y0 = ypot - 1;
   
   out = get_texel_2d_no_border(sp_sview, addr, x0, y0);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}


static void
img_filter_1d_nearest(struct sp_sampler_view *sp_sview,
                      struct sp_sampler *sp_samp,
                      float s,
                      float t,
                      float p,
                      unsigned level,
                      unsigned face_id,
                      float rgba[TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width;
   int x;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);

   assert(width > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->nearest_texcoord_s(s, width, &x);

   out = get_texel_2d(sp_sview, sp_samp, addr, x, 0);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}


static void
img_filter_1d_array_nearest(struct sp_sampler_view *sp_sview,
                            struct sp_sampler *sp_samp,
                            float s,
                            float t,
                            float p,
                            unsigned level,
                            unsigned face_id,
                            float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width;
   int x, layer;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);

   assert(width > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->nearest_texcoord_s(s, width, &x);
   wrap_array_layer(t, texture->array_size, &layer);

   out = get_texel_1d_array(sp_sview, sp_samp, addr, x, layer);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}


static void
img_filter_2d_nearest(struct sp_sampler_view *sp_sview,
                      struct sp_sampler *sp_samp,
                      float s,
                      float t,
                      float p,
                      unsigned level,
                      unsigned face_id,
                      float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x, y;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);
 
   addr.value = 0;
   addr.bits.level = level;

   sp_samp->nearest_texcoord_s(s, width, &x);
   sp_samp->nearest_texcoord_t(t, height, &y);

   out = get_texel_2d(sp_sview, sp_samp, addr, x, y);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}


static void
img_filter_2d_array_nearest(struct sp_sampler_view *sp_sview,
                            struct sp_sampler *sp_samp,
                            float s,
                            float t,
                            float p,
                            unsigned level,
                            unsigned face_id,
                            float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x, y, layer;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);
 
   addr.value = 0;
   addr.bits.level = level;

   sp_samp->nearest_texcoord_s(s, width, &x);
   sp_samp->nearest_texcoord_t(t, height, &y);
   wrap_array_layer(p, texture->array_size, &layer);

   out = get_texel_2d_array(sp_sview, sp_samp, addr, x, y, layer);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}


static INLINE union tex_tile_address
face(union tex_tile_address addr, unsigned face )
{
   addr.bits.face = face;
   return addr;
}


static void
img_filter_cube_nearest(struct sp_sampler_view *sp_sview,
                        struct sp_sampler *sp_samp,
                        float s,
                        float t,
                        float p,
                        unsigned level,
                        unsigned face_id,
                        float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x, y;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);
 
   addr.value = 0;
   addr.bits.level = level;

   /*
    * If NEAREST filtering is done within a miplevel, always apply wrap
    * mode CLAMP_TO_EDGE.
    */
   if (sp_samp->base.seamless_cube_map) {
      wrap_nearest_clamp_to_edge(s, width, &x);
      wrap_nearest_clamp_to_edge(t, height, &y);
   } else {
      /* Would probably make sense to ignore mode and just do edge clamp */
      sp_samp->nearest_texcoord_s(s, width, &x);
      sp_samp->nearest_texcoord_t(t, height, &y);
   }

   out = get_texel_2d(sp_sview, sp_samp, face(addr, face_id), x, y);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}

static void
img_filter_cube_array_nearest(struct sp_sampler_view *sp_sview,
                              struct sp_sampler *sp_samp,
                              float s,
                              float t,
                              float p,
                              unsigned level,
                              unsigned face_id,
                              float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x, y, layer;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);
 
   addr.value = 0;
   addr.bits.level = level;

   sp_samp->nearest_texcoord_s(s, width, &x);
   sp_samp->nearest_texcoord_t(t, height, &y);
   wrap_array_layer(p, texture->array_size, &layer);

   out = get_texel_cube_array(sp_sview, sp_samp, addr, x, y, layer * 6 + face_id);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}

static void
img_filter_3d_nearest(struct sp_sampler_view *sp_sview,
                      struct sp_sampler *sp_samp,
                      float s,
                      float t,
                      float p,
                      unsigned level,
                      unsigned face_id,
                      float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height, depth;
   int x, y, z;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);
   depth = u_minify(texture->depth0, level);

   assert(width > 0);
   assert(height > 0);
   assert(depth > 0);

   sp_samp->nearest_texcoord_s(s, width,  &x);
   sp_samp->nearest_texcoord_t(t, height, &y);
   sp_samp->nearest_texcoord_p(p, depth,  &z);

   addr.value = 0;
   addr.bits.level = level;

   out = get_texel_3d(sp_sview, sp_samp, addr, x, y, z);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];
}


static void
img_filter_1d_linear(struct sp_sampler_view *sp_sview,
                     struct sp_sampler *sp_samp,
                     float s,
                     float t,
                     float p,
                     unsigned level,
                     unsigned face_id,
                     float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width;
   int x0, x1;
   float xw; /* weights */
   union tex_tile_address addr;
   const float *tx0, *tx1;
   int c;

   width = u_minify(texture->width0, level);

   assert(width > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->linear_texcoord_s(s, width, &x0, &x1, &xw);

   tx0 = get_texel_2d(sp_sview, sp_samp, addr, x0, 0);
   tx1 = get_texel_2d(sp_sview, sp_samp, addr, x1, 0);

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp(xw, tx0[c], tx1[c]);
}


static void
img_filter_1d_array_linear(struct sp_sampler_view *sp_sview,
                           struct sp_sampler *sp_samp,
                           float s,
                           float t,
                           float p,
                           unsigned level,
                           unsigned face_id,
                           float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width;
   int x0, x1, layer;
   float xw; /* weights */
   union tex_tile_address addr;
   const float *tx0, *tx1;
   int c;

   width = u_minify(texture->width0, level);

   assert(width > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->linear_texcoord_s(s, width, &x0, &x1, &xw);
   wrap_array_layer(t, texture->array_size, &layer);

   tx0 = get_texel_1d_array(sp_sview, sp_samp, addr, x0, layer);
   tx1 = get_texel_1d_array(sp_sview, sp_samp, addr, x1, layer);

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp(xw, tx0[c], tx1[c]);
}


static void
img_filter_2d_linear(struct sp_sampler_view *sp_sview,
                     struct sp_sampler *sp_samp,
                     float s,
                     float t,
                     float p,
                     unsigned level,
                     unsigned face_id,
                     float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x0, y0, x1, y1;
   float xw, yw; /* weights */
   union tex_tile_address addr;
   const float *tx0, *tx1, *tx2, *tx3;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
   sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);

   tx0 = get_texel_2d(sp_sview, sp_samp, addr, x0, y0);
   tx1 = get_texel_2d(sp_sview, sp_samp, addr, x1, y0);
   tx2 = get_texel_2d(sp_sview, sp_samp, addr, x0, y1);
   tx3 = get_texel_2d(sp_sview, sp_samp, addr, x1, y1);

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw,
                                          tx0[c], tx1[c],
                                          tx2[c], tx3[c]);
}


static void
img_filter_2d_array_linear(struct sp_sampler_view *sp_sview,
                           struct sp_sampler *sp_samp,
                           float s,
                           float t,
                           float p,
                           unsigned level,
                           unsigned face_id,
                           float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x0, y0, x1, y1, layer;
   float xw, yw; /* weights */
   union tex_tile_address addr;
   const float *tx0, *tx1, *tx2, *tx3;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
   sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
   wrap_array_layer(p, texture->array_size, &layer);

   tx0 = get_texel_2d_array(sp_sview, sp_samp, addr, x0, y0, layer);
   tx1 = get_texel_2d_array(sp_sview, sp_samp, addr, x1, y0, layer);
   tx2 = get_texel_2d_array(sp_sview, sp_samp, addr, x0, y1, layer);
   tx3 = get_texel_2d_array(sp_sview, sp_samp, addr, x1, y1, layer);

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw,
                                          tx0[c], tx1[c],
                                          tx2[c], tx3[c]);
}


static void
img_filter_cube_linear(struct sp_sampler_view *sp_sview,
                       struct sp_sampler *sp_samp,
                       float s,
                       float t,
                       float p,
                       unsigned level,
                       unsigned face_id,
                       float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x0, y0, x1, y1;
   float xw, yw; /* weights */
   union tex_tile_address addr, addrj;
   const float *tx0, *tx1, *tx2, *tx3;
   float corner0[TGSI_QUAD_SIZE], corner1[TGSI_QUAD_SIZE],
         corner2[TGSI_QUAD_SIZE], corner3[TGSI_QUAD_SIZE];
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);

   addr.value = 0;
   addr.bits.level = level;

   /*
    * For seamless if LINEAR filtering is done within a miplevel,
    * always apply wrap mode CLAMP_TO_BORDER.
    */
   if (sp_samp->base.seamless_cube_map) {
      /* Note this is a bit overkill, actual clamping is not required */
      wrap_linear_clamp_to_border(s, width, &x0, &x1, &xw);
      wrap_linear_clamp_to_border(t, height, &y0, &y1, &yw);
   } else {
      /* Would probably make sense to ignore mode and just do edge clamp */
      sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
      sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
   }

   addrj = face(addr, face_id);

   if (sp_samp->base.seamless_cube_map) {
      tx0 = get_texel_cube_seamless(sp_sview, addrj, x0, y0, corner0);
      tx1 = get_texel_cube_seamless(sp_sview, addrj, x1, y0, corner1);
      tx2 = get_texel_cube_seamless(sp_sview, addrj, x0, y1, corner2);
      tx3 = get_texel_cube_seamless(sp_sview, addrj, x1, y1, corner3);
   } else {
      tx0 = get_texel_2d(sp_sview, sp_samp, addrj, x0, y0);
      tx1 = get_texel_2d(sp_sview, sp_samp, addrj, x1, y0);
      tx2 = get_texel_2d(sp_sview, sp_samp, addrj, x0, y1);
      tx3 = get_texel_2d(sp_sview, sp_samp, addrj, x1, y1);
   }
   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw,
                                          tx0[c], tx1[c],
                                          tx2[c], tx3[c]);
}


static void
img_filter_cube_array_linear(struct sp_sampler_view *sp_sview,
                             struct sp_sampler *sp_samp,
                             float s,
                             float t,
                             float p,
                             unsigned level,
                             unsigned face_id,
                             float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x0, y0, x1, y1, layer;
   float xw, yw; /* weights */
   union tex_tile_address addr;
   const float *tx0, *tx1, *tx2, *tx3;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
   sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
   wrap_array_layer(p, texture->array_size, &layer);

   tx0 = get_texel_cube_array(sp_sview, sp_samp, addr, x0, y0, layer * 6 + face_id);
   tx1 = get_texel_cube_array(sp_sview, sp_samp, addr, x1, y0, layer * 6 + face_id);
   tx2 = get_texel_cube_array(sp_sview, sp_samp, addr, x0, y1, layer * 6 + face_id);
   tx3 = get_texel_cube_array(sp_sview, sp_samp, addr, x1, y1, layer * 6 + face_id);

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw,
                                          tx0[c], tx1[c],
                                          tx2[c], tx3[c]);
}

static void
img_filter_3d_linear(struct sp_sampler_view *sp_sview,
                     struct sp_sampler *sp_samp,
                     float s,
                     float t,
                     float p,
                     unsigned level,
                     unsigned face_id,
                     float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height, depth;
   int x0, x1, y0, y1, z0, z1;
   float xw, yw, zw; /* interpolation weights */
   union tex_tile_address addr;
   const float *tx00, *tx01, *tx02, *tx03, *tx10, *tx11, *tx12, *tx13;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);
   depth = u_minify(texture->depth0, level);

   addr.value = 0;
   addr.bits.level = level;

   assert(width > 0);
   assert(height > 0);
   assert(depth > 0);

   sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
   sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
   sp_samp->linear_texcoord_p(p, depth,  &z0, &z1, &zw);


   tx00 = get_texel_3d(sp_sview, sp_samp, addr, x0, y0, z0);
   tx01 = get_texel_3d(sp_sview, sp_samp, addr, x1, y0, z0);
   tx02 = get_texel_3d(sp_sview, sp_samp, addr, x0, y1, z0);
   tx03 = get_texel_3d(sp_sview, sp_samp, addr, x1, y1, z0);
      
   tx10 = get_texel_3d(sp_sview, sp_samp, addr, x0, y0, z1);
   tx11 = get_texel_3d(sp_sview, sp_samp, addr, x1, y0, z1);
   tx12 = get_texel_3d(sp_sview, sp_samp, addr, x0, y1, z1);
   tx13 = get_texel_3d(sp_sview, sp_samp, addr, x1, y1, z1);
      
      /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] =  lerp_3d(xw, yw, zw,
                                           tx00[c], tx01[c],
                                           tx02[c], tx03[c],
                                           tx10[c], tx11[c],
                                           tx12[c], tx13[c]);
}


/* Calculate level of detail for every fragment,
 * with lambda already computed.
 * Note that lambda has already been biased by global LOD bias.
 * \param biased_lambda per-quad lambda.
 * \param lod_in per-fragment lod_bias or explicit_lod.
 * \param lod returns the per-fragment lod.
 */
static INLINE void
compute_lod(const struct pipe_sampler_state *sampler,
            enum tgsi_sampler_control control,
            const float biased_lambda,
            const float lod_in[TGSI_QUAD_SIZE],
            float lod[TGSI_QUAD_SIZE])
{
   float min_lod = sampler->min_lod;
   float max_lod = sampler->max_lod;
   uint i;

   switch (control) {
   case tgsi_sampler_lod_none:
   case tgsi_sampler_lod_zero:
   /* XXX FIXME */
   case tgsi_sampler_derivs_explicit:
      lod[0] = lod[1] = lod[2] = lod[3] = CLAMP(biased_lambda, min_lod, max_lod);
      break;
   case tgsi_sampler_lod_bias:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         lod[i] = biased_lambda + lod_in[i];
         lod[i] = CLAMP(lod[i], min_lod, max_lod);
      }
      break;
   case tgsi_sampler_lod_explicit:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         lod[i] = CLAMP(lod_in[i], min_lod, max_lod);
      }
      break;
   default:
      assert(0);
      lod[0] = lod[1] = lod[2] = lod[3] = 0.0f;
   }
}


/* Calculate level of detail for every fragment.
 * \param lod_in per-fragment lod_bias or explicit_lod.
 * \param lod results per-fragment lod.
 */
static INLINE void
compute_lambda_lod(struct sp_sampler_view *sp_sview,
                   struct sp_sampler *sp_samp,
                   const float s[TGSI_QUAD_SIZE],
                   const float t[TGSI_QUAD_SIZE],
                   const float p[TGSI_QUAD_SIZE],
                   const float lod_in[TGSI_QUAD_SIZE],
                   enum tgsi_sampler_control control,
                   float lod[TGSI_QUAD_SIZE])
{
   const struct pipe_sampler_state *sampler = &sp_samp->base;
   float lod_bias = sampler->lod_bias;
   float min_lod = sampler->min_lod;
   float max_lod = sampler->max_lod;
   float lambda;
   uint i;

   switch (control) {
   case tgsi_sampler_lod_none:
      /* XXX FIXME */
   case tgsi_sampler_derivs_explicit:
      lambda = sp_sview->compute_lambda(sp_sview, s, t, p) + lod_bias;
      lod[0] = lod[1] = lod[2] = lod[3] = CLAMP(lambda, min_lod, max_lod);
      break;
   case tgsi_sampler_lod_bias:
      lambda = sp_sview->compute_lambda(sp_sview, s, t, p) + lod_bias;
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         lod[i] = lambda + lod_in[i];
         lod[i] = CLAMP(lod[i], min_lod, max_lod);
      }
      break;
   case tgsi_sampler_lod_explicit:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         lod[i] = CLAMP(lod_in[i], min_lod, max_lod);
      }
      break;
   case tgsi_sampler_lod_zero:
      /* this is all static state in the sampler really need clamp here? */
      lod[0] = lod[1] = lod[2] = lod[3] = CLAMP(lod_bias, min_lod, max_lod);
      break;
   default:
      assert(0);
      lod[0] = lod[1] = lod[2] = lod[3] = 0.0f;
   }
}


static void
mip_filter_linear(struct sp_sampler_view *sp_sview,
                  struct sp_sampler *sp_samp,
                  img_filter_func min_filter,
                  img_filter_func mag_filter,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE],
                  const float c0[TGSI_QUAD_SIZE],
                  const float lod_in[TGSI_QUAD_SIZE],
                  enum tgsi_sampler_control control,
                  float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int j;
   float lod[TGSI_QUAD_SIZE];

   compute_lambda_lod(sp_sview, sp_samp, s, t, p, lod_in, control, lod);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      int level0 = sp_sview->base.u.tex.first_level + (int)lod[j];

      if (lod[j] < 0.0)
         mag_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    sp_sview->base.u.tex.first_level,
                    sp_sview->faces[j], &rgba[0][j]);

      else if (level0 >= (int) texture->last_level)
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], texture->last_level,
                    sp_sview->faces[j], &rgba[0][j]);

      else {
         float levelBlend = frac(lod[j]);
         float rgbax[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
         int c;

         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], level0,
                    sp_sview->faces[j], &rgbax[0][0]);
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], level0+1,
                    sp_sview->faces[j], &rgbax[0][1]);

         for (c = 0; c < 4; c++) {
            rgba[c][j] = lerp(levelBlend, rgbax[c][0], rgbax[c][1]);
         }
      }
   }

   if (DEBUG_TEX) {
      print_sample_4(__FUNCTION__, rgba);
   }
}


/**
 * Compute nearest mipmap level from texcoords.
 * Then sample the texture level for four elements of a quad.
 * \param c0  the LOD bias factors, or absolute LODs (depending on control)
 */
static void
mip_filter_nearest(struct sp_sampler_view *sp_sview,
                   struct sp_sampler *sp_samp,
                   img_filter_func min_filter,
                   img_filter_func mag_filter,
                   const float s[TGSI_QUAD_SIZE],
                   const float t[TGSI_QUAD_SIZE],
                   const float p[TGSI_QUAD_SIZE],
                   const float c0[TGSI_QUAD_SIZE],
                   const float lod_in[TGSI_QUAD_SIZE],
                   enum tgsi_sampler_control control,
                   float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   float lod[TGSI_QUAD_SIZE];
   int j;

   compute_lambda_lod(sp_sview, sp_samp, s, t, p, lod_in, control, lod);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      if (lod[j] < 0.0)
         mag_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    sp_sview->base.u.tex.first_level,
                    sp_sview->faces[j], &rgba[0][j]);
      else {
         int level = sp_sview->base.u.tex.first_level + (int)(lod[j] + 0.5F);
         level = MIN2(level, (int)texture->last_level);
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    level, sp_sview->faces[j], &rgba[0][j]);
      }
   }

   if (DEBUG_TEX) {
      print_sample_4(__FUNCTION__, rgba);
   }
}


static void
mip_filter_none(struct sp_sampler_view *sp_sview,
                struct sp_sampler *sp_samp,
                img_filter_func min_filter,
                img_filter_func mag_filter,
                const float s[TGSI_QUAD_SIZE],
                const float t[TGSI_QUAD_SIZE],
                const float p[TGSI_QUAD_SIZE],
                const float c0[TGSI_QUAD_SIZE],
                const float lod_in[TGSI_QUAD_SIZE],
                enum tgsi_sampler_control control,
                float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   float lod[TGSI_QUAD_SIZE];
   int j;

   compute_lambda_lod(sp_sview, sp_samp, s, t, p, lod_in, control, lod);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      if (lod[j] < 0.0) { 
         mag_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    sp_sview->base.u.tex.first_level,
                    sp_sview->faces[j], &rgba[0][j]);
      }
      else {
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    sp_sview->base.u.tex.first_level,
                    sp_sview->faces[j], &rgba[0][j]);
      }
   }
}


static void
mip_filter_none_no_filter_select(struct sp_sampler_view *sp_sview,
                                 struct sp_sampler *sp_samp,
                                 img_filter_func min_filter,
                                 img_filter_func mag_filter,
                                 const float s[TGSI_QUAD_SIZE],
                                 const float t[TGSI_QUAD_SIZE],
                                 const float p[TGSI_QUAD_SIZE],
                                 const float c0[TGSI_QUAD_SIZE],
                                 const float lod_in[TGSI_QUAD_SIZE],
                                 enum tgsi_sampler_control control,
                                 float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   int j;

   for (j = 0; j < TGSI_QUAD_SIZE; j++)
      mag_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                 sp_sview->base.u.tex.first_level,
                 sp_sview->faces[j], &rgba[0][j]);
}


/* For anisotropic filtering */
#define WEIGHT_LUT_SIZE 1024

static float *weightLut = NULL;

/**
 * Creates the look-up table used to speed-up EWA sampling
 */
static void
create_filter_table(void)
{
   unsigned i;
   if (!weightLut) {
      weightLut = (float *) MALLOC(WEIGHT_LUT_SIZE * sizeof(float));

      for (i = 0; i < WEIGHT_LUT_SIZE; ++i) {
         float alpha = 2;
         float r2 = (float) i / (float) (WEIGHT_LUT_SIZE - 1);
         float weight = (float) exp(-alpha * r2);
         weightLut[i] = weight;
      }
   }
}


/**
 * Elliptical weighted average (EWA) filter for producing high quality
 * anisotropic filtered results.
 * Based on the Higher Quality Elliptical Weighted Average Filter
 * published by Paul S. Heckbert in his Master's Thesis
 * "Fundamentals of Texture Mapping and Image Warping" (1989)
 */
static void
img_filter_2d_ewa(struct sp_sampler_view *sp_sview,
                  struct sp_sampler *sp_samp,
                  img_filter_func min_filter,
                  img_filter_func mag_filter,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE],
                  unsigned level,
                  const float dudx, const float dvdx,
                  const float dudy, const float dvdy,
                  float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;

   // ??? Won't the image filters blow up if level is negative?
   unsigned level0 = level > 0 ? level : 0;
   float scaling = 1.0f / (1 << level0);
   int width = u_minify(texture->width0, level0);
   int height = u_minify(texture->height0, level0);

   float ux = dudx * scaling;
   float vx = dvdx * scaling;
   float uy = dudy * scaling;
   float vy = dvdy * scaling;

   /* compute ellipse coefficients to bound the region: 
    * A*x*x + B*x*y + C*y*y = F.
    */
   float A = vx*vx+vy*vy+1;
   float B = -2*(ux*vx+uy*vy);
   float C = ux*ux+uy*uy+1;
   float F = A*C-B*B/4.0f;

   /* check if it is an ellipse */
   /* ASSERT(F > 0.0); */

   /* Compute the ellipse's (u,v) bounding box in texture space */
   float d = -B*B+4.0f*C*A;
   float box_u = 2.0f / d * sqrtf(d*C*F); /* box_u -> half of bbox with   */
   float box_v = 2.0f / d * sqrtf(A*d*F); /* box_v -> half of bbox height */

   float rgba_temp[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
   float s_buffer[TGSI_QUAD_SIZE];
   float t_buffer[TGSI_QUAD_SIZE];
   float weight_buffer[TGSI_QUAD_SIZE];
   unsigned buffer_next;
   int j;
   float den; /* = 0.0F; */
   float ddq;
   float U; /* = u0 - tex_u; */
   int v;

   /* Scale ellipse formula to directly index the Filter Lookup Table.
    * i.e. scale so that F = WEIGHT_LUT_SIZE-1
    */
   double formScale = (double) (WEIGHT_LUT_SIZE - 1) / F;
   A *= formScale;
   B *= formScale;
   C *= formScale;
   /* F *= formScale; */ /* no need to scale F as we don't use it below here */

   /* For each quad, the du and dx values are the same and so the ellipse is
    * also the same. Note that texel/image access can only be performed using
    * a quad, i.e. it is not possible to get the pixel value for a single
    * tex coord. In order to have a better performance, the access is buffered
    * using the s_buffer/t_buffer and weight_buffer. Only when the buffer is
    * full, then the pixel values are read from the image.
    */
   ddq = 2 * A;
   
   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      /* Heckbert MS thesis, p. 59; scan over the bounding box of the ellipse
       * and incrementally update the value of Ax^2+Bxy*Cy^2; when this
       * value, q, is less than F, we're inside the ellipse
       */
      float tex_u = -0.5F + s[j] * texture->width0 * scaling;
      float tex_v = -0.5F + t[j] * texture->height0 * scaling;

      int u0 = (int) floorf(tex_u - box_u);
      int u1 = (int) ceilf(tex_u + box_u);
      int v0 = (int) floorf(tex_v - box_v);
      int v1 = (int) ceilf(tex_v + box_v);

      float num[4] = {0.0F, 0.0F, 0.0F, 0.0F};
      buffer_next = 0;
      den = 0;
      U = u0 - tex_u;
      for (v = v0; v <= v1; ++v) {
         float V = v - tex_v;
         float dq = A * (2 * U + 1) + B * V;
         float q = (C * V + B * U) * V + A * U * U;

         int u;
         for (u = u0; u <= u1; ++u) {
            /* Note that the ellipse has been pre-scaled so F =
             * WEIGHT_LUT_SIZE - 1
             */
            if (q < WEIGHT_LUT_SIZE) {
               /* as a LUT is used, q must never be negative;
                * should not happen, though
                */
               const int qClamped = q >= 0.0F ? q : 0;
               float weight = weightLut[qClamped];

               weight_buffer[buffer_next] = weight;
               s_buffer[buffer_next] = u / ((float) width);
               t_buffer[buffer_next] = v / ((float) height);
            
               buffer_next++;
               if (buffer_next == TGSI_QUAD_SIZE) {
                  /* 4 texel coords are in the buffer -> read it now */
                  unsigned jj;
                  /* it is assumed that samp->min_img_filter is set to
                   * img_filter_2d_nearest or one of the
                   * accelerated img_filter_2d_nearest_XXX functions.
                   */
                  for (jj = 0; jj < buffer_next; jj++) {
                     min_filter(sp_sview, sp_samp, s_buffer[jj], t_buffer[jj], p[jj],
                                level, sp_sview->faces[j], &rgba_temp[0][jj]);
                     num[0] += weight_buffer[jj] * rgba_temp[0][jj];
                     num[1] += weight_buffer[jj] * rgba_temp[1][jj];
                     num[2] += weight_buffer[jj] * rgba_temp[2][jj];
                     num[3] += weight_buffer[jj] * rgba_temp[3][jj];
                  }

                  buffer_next = 0;
               }

               den += weight;
            }
            q += dq;
            dq += ddq;
         }
      }

      /* if the tex coord buffer contains unread values, we will read
       * them now.
       */
      if (buffer_next > 0) {
         unsigned jj;
         /* it is assumed that samp->min_img_filter is set to
          * img_filter_2d_nearest or one of the
          * accelerated img_filter_2d_nearest_XXX functions.
          */
         for (jj = 0; jj < buffer_next; jj++) {
            min_filter(sp_sview, sp_samp, s_buffer[jj], t_buffer[jj], p[jj],
                       level, sp_sview->faces[j], &rgba_temp[0][jj]);
            num[0] += weight_buffer[jj] * rgba_temp[0][jj];
            num[1] += weight_buffer[jj] * rgba_temp[1][jj];
            num[2] += weight_buffer[jj] * rgba_temp[2][jj];
            num[3] += weight_buffer[jj] * rgba_temp[3][jj];
         }
      }

      if (den <= 0.0F) {
         /* Reaching this place would mean that no pixels intersected
          * the ellipse.  This should never happen because the filter
          * we use always intersects at least one pixel.
          */

         /*rgba[0]=0;
         rgba[1]=0;
         rgba[2]=0;
         rgba[3]=0;*/
         /* not enough pixels in resampling, resort to direct interpolation */
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], level,
                    sp_sview->faces[j], &rgba_temp[0][j]);
         den = 1;
         num[0] = rgba_temp[0][j];
         num[1] = rgba_temp[1][j];
         num[2] = rgba_temp[2][j];
         num[3] = rgba_temp[3][j];
      }

      rgba[0][j] = num[0] / den;
      rgba[1][j] = num[1] / den;
      rgba[2][j] = num[2] / den;
      rgba[3][j] = num[3] / den;
   }
}


/**
 * Sample 2D texture using an anisotropic filter.
 */
static void
mip_filter_linear_aniso(struct sp_sampler_view *sp_sview,
                        struct sp_sampler *sp_samp,
                        img_filter_func min_filter,
                        img_filter_func mag_filter,
                        const float s[TGSI_QUAD_SIZE],
                        const float t[TGSI_QUAD_SIZE],
                        const float p[TGSI_QUAD_SIZE],
                        const float c0[TGSI_QUAD_SIZE],
                        const float lod_in[TGSI_QUAD_SIZE],
                        enum tgsi_sampler_control control,
                        float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int level0;
   float lambda;
   float lod[TGSI_QUAD_SIZE];

   float s_to_u = u_minify(texture->width0, sp_sview->base.u.tex.first_level);
   float t_to_v = u_minify(texture->height0, sp_sview->base.u.tex.first_level);
   float dudx = (s[QUAD_BOTTOM_RIGHT] - s[QUAD_BOTTOM_LEFT]) * s_to_u;
   float dudy = (s[QUAD_TOP_LEFT]     - s[QUAD_BOTTOM_LEFT]) * s_to_u;
   float dvdx = (t[QUAD_BOTTOM_RIGHT] - t[QUAD_BOTTOM_LEFT]) * t_to_v;
   float dvdy = (t[QUAD_TOP_LEFT]     - t[QUAD_BOTTOM_LEFT]) * t_to_v;
   
   if (control == tgsi_sampler_lod_bias ||
       control == tgsi_sampler_lod_none ||
       /* XXX FIXME */
       control == tgsi_sampler_derivs_explicit) {
      /* note: instead of working with Px and Py, we will use the 
       * squared length instead, to avoid sqrt.
       */
      float Px2 = dudx * dudx + dvdx * dvdx;
      float Py2 = dudy * dudy + dvdy * dvdy;

      float Pmax2;
      float Pmin2;
      float e;
      const float maxEccentricity = sp_samp->base.max_anisotropy * sp_samp->base.max_anisotropy;
      
      if (Px2 < Py2) {
         Pmax2 = Py2;
         Pmin2 = Px2;
      }
      else {
         Pmax2 = Px2;
         Pmin2 = Py2;
      }
      
      /* if the eccentricity of the ellipse is too big, scale up the shorter
       * of the two vectors to limit the maximum amount of work per pixel
       */
      e = Pmax2 / Pmin2;
      if (e > maxEccentricity) {
         /* float s=e / maxEccentricity;
            minor[0] *= s;
            minor[1] *= s;
            Pmin2 *= s; */
         Pmin2 = Pmax2 / maxEccentricity;
      }
      
      /* note: we need to have Pmin=sqrt(Pmin2) here, but we can avoid
       * this since 0.5*log(x) = log(sqrt(x))
       */
      lambda = 0.5F * util_fast_log2(Pmin2) + sp_samp->base.lod_bias;
      compute_lod(&sp_samp->base, control, lambda, lod_in, lod);
   }
   else {
      assert(control == tgsi_sampler_lod_explicit ||
             control == tgsi_sampler_lod_zero);
      compute_lod(&sp_samp->base, control, sp_samp->base.lod_bias, lod_in, lod);
   }
   
   /* XXX: Take into account all lod values.
    */
   lambda = lod[0];
   level0 = sp_sview->base.u.tex.first_level + (int)lambda;

   /* If the ellipse covers the whole image, we can
    * simply return the average of the whole image.
    */
   if (level0 >= (int) texture->last_level) {
      int j;
      for (j = 0; j < TGSI_QUAD_SIZE; j++)
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], texture->last_level,
                    sp_sview->faces[j], &rgba[0][j]);
   }
   else {
      /* don't bother interpolating between multiple LODs; it doesn't
       * seem to be worth the extra running time.
       */
      img_filter_2d_ewa(sp_sview, sp_samp, min_filter, mag_filter,
                        s, t, p, level0,
                        dudx, dvdx, dudy, dvdy, rgba);
   }

   if (DEBUG_TEX) {
      print_sample_4(__FUNCTION__, rgba);
   }
}


/**
 * Specialized version of mip_filter_linear with hard-wired calls to
 * 2d lambda calculation and 2d_linear_repeat_POT img filters.
 */
static void
mip_filter_linear_2d_linear_repeat_POT(
   struct sp_sampler_view *sp_sview,
   struct sp_sampler *sp_samp,
   img_filter_func min_filter,
   img_filter_func mag_filter,
   const float s[TGSI_QUAD_SIZE],
   const float t[TGSI_QUAD_SIZE],
   const float p[TGSI_QUAD_SIZE],
   const float c0[TGSI_QUAD_SIZE],
   const float lod_in[TGSI_QUAD_SIZE],
   enum tgsi_sampler_control control,
   float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int j;
   float lod[TGSI_QUAD_SIZE];

   compute_lambda_lod(sp_sview, sp_samp, s, t, p, lod_in, control, lod);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      int level0 = sp_sview->base.u.tex.first_level + (int)lod[j];

      /* Catches both negative and large values of level0:
       */
      if ((unsigned)level0 >= texture->last_level) { 
         if (level0 < 0)
            img_filter_2d_linear_repeat_POT(sp_sview, sp_samp, s[j], t[j], p[j],
                                            sp_sview->base.u.tex.first_level,
                                            sp_sview->faces[j], &rgba[0][j]);
         else
            img_filter_2d_linear_repeat_POT(sp_sview, sp_samp, s[j], t[j], p[j],
                                            sp_sview->base.texture->last_level,
                                            sp_sview->faces[j], &rgba[0][j]);

      }
      else {
         float levelBlend = frac(lod[j]);
         float rgbax[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
         int c;

         img_filter_2d_linear_repeat_POT(sp_sview, sp_samp, s[j], t[j], p[j], level0,
                                         sp_sview->faces[j], &rgbax[0][0]);
         img_filter_2d_linear_repeat_POT(sp_sview, sp_samp, s[j], t[j], p[j], level0+1,
                                         sp_sview->faces[j], &rgbax[0][1]);

         for (c = 0; c < TGSI_NUM_CHANNELS; c++)
            rgba[c][j] = lerp(levelBlend, rgbax[c][0], rgbax[c][1]);
      }
   }

   if (DEBUG_TEX) {
      print_sample_4(__FUNCTION__, rgba);
   }
}


/**
 * Do shadow/depth comparisons.
 */
static void
sample_compare(struct sp_sampler_view *sp_sview,
               struct sp_sampler *sp_samp,
               const float s[TGSI_QUAD_SIZE],
               const float t[TGSI_QUAD_SIZE],
               const float p[TGSI_QUAD_SIZE],
               const float c0[TGSI_QUAD_SIZE],
               const float c1[TGSI_QUAD_SIZE],
               enum tgsi_sampler_control control,
               float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_sampler_state *sampler = &sp_samp->base;
   int j;
   int k[4];
   float pc[4];
   const struct util_format_description *format_desc;
   unsigned chan_type;

   /**
    * Compare texcoord 'p' (aka R) against texture value 'rgba[0]'
    * for 2D Array texture we need to use the 'c0' (aka Q).
    * When we sampled the depth texture, the depth value was put into all
    * RGBA channels.  We look at the red channel here.
    */

   if (sp_sview->base.texture->target == PIPE_TEXTURE_2D_ARRAY ||
       sp_sview->base.texture->target == PIPE_TEXTURE_CUBE) {
      pc[0] = c0[0];
      pc[1] = c0[1];
      pc[2] = c0[2];
      pc[3] = c0[3];
   } else if (sp_sview->base.texture->target == PIPE_TEXTURE_CUBE_ARRAY) {
      pc[0] = c1[0];
      pc[1] = c1[1];
      pc[2] = c1[2];
      pc[3] = c1[3];
   } else {
      pc[0] = p[0];
      pc[1] = p[1];
      pc[2] = p[2];
      pc[3] = p[3];
   }

   format_desc = util_format_description(sp_sview->base.format);
   /* not entirely sure we couldn't end up with non-valid swizzle here */
   chan_type = format_desc->swizzle[0] <= UTIL_FORMAT_SWIZZLE_W ?
                  format_desc->channel[format_desc->swizzle[0]].type :
                  UTIL_FORMAT_TYPE_FLOAT;
   if (chan_type != UTIL_FORMAT_TYPE_FLOAT) {
      /*
       * clamping is a result of conversion to texture format, hence
       * doesn't happen with floats. Technically also should do comparison
       * in texture format (quantization!).
       */
      pc[0] = CLAMP(pc[0], 0.0F, 1.0F);
      pc[1] = CLAMP(pc[1], 0.0F, 1.0F);
      pc[2] = CLAMP(pc[2], 0.0F, 1.0F);
      pc[3] = CLAMP(pc[3], 0.0F, 1.0F);
   }

   /* compare four texcoords vs. four texture samples */
   switch (sampler->compare_func) {
   case PIPE_FUNC_LESS:
      k[0] = pc[0] < rgba[0][0];
      k[1] = pc[1] < rgba[0][1];
      k[2] = pc[2] < rgba[0][2];
      k[3] = pc[3] < rgba[0][3];
      break;
   case PIPE_FUNC_LEQUAL:
      k[0] = pc[0] <= rgba[0][0];
      k[1] = pc[1] <= rgba[0][1];
      k[2] = pc[2] <= rgba[0][2];
      k[3] = pc[3] <= rgba[0][3];
      break;
   case PIPE_FUNC_GREATER:
      k[0] = pc[0] > rgba[0][0];
      k[1] = pc[1] > rgba[0][1];
      k[2] = pc[2] > rgba[0][2];
      k[3] = pc[3] > rgba[0][3];
      break;
   case PIPE_FUNC_GEQUAL:
      k[0] = pc[0] >= rgba[0][0];
      k[1] = pc[1] >= rgba[0][1];
      k[2] = pc[2] >= rgba[0][2];
      k[3] = pc[3] >= rgba[0][3];
      break;
   case PIPE_FUNC_EQUAL:
      k[0] = pc[0] == rgba[0][0];
      k[1] = pc[1] == rgba[0][1];
      k[2] = pc[2] == rgba[0][2];
      k[3] = pc[3] == rgba[0][3];
      break;
   case PIPE_FUNC_NOTEQUAL:
      k[0] = pc[0] != rgba[0][0];
      k[1] = pc[1] != rgba[0][1];
      k[2] = pc[2] != rgba[0][2];
      k[3] = pc[3] != rgba[0][3];
      break;
   case PIPE_FUNC_ALWAYS:
      k[0] = k[1] = k[2] = k[3] = 1;
      break;
   case PIPE_FUNC_NEVER:
      k[0] = k[1] = k[2] = k[3] = 0;
      break;
   default:
      k[0] = k[1] = k[2] = k[3] = 0;
      assert(0);
      break;
   }

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      rgba[0][j] = k[j];
      rgba[1][j] = k[j];
      rgba[2][j] = k[j];
      rgba[3][j] = 1.0F;
   }
}


static void
do_swizzling(const struct pipe_sampler_view *sview,
             float in[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE],
             float out[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   int j;
   const unsigned swizzle_r = sview->swizzle_r;
   const unsigned swizzle_g = sview->swizzle_g;
   const unsigned swizzle_b = sview->swizzle_b;
   const unsigned swizzle_a = sview->swizzle_a;

   switch (swizzle_r) {
   case PIPE_SWIZZLE_ZERO:
      for (j = 0; j < 4; j++)
         out[0][j] = 0.0f;
      break;
   case PIPE_SWIZZLE_ONE:
      for (j = 0; j < 4; j++)
         out[0][j] = 1.0f;
      break;
   default:
      assert(swizzle_r < 4);
      for (j = 0; j < 4; j++)
         out[0][j] = in[swizzle_r][j];
   }

   switch (swizzle_g) {
   case PIPE_SWIZZLE_ZERO:
      for (j = 0; j < 4; j++)
         out[1][j] = 0.0f;
      break;
   case PIPE_SWIZZLE_ONE:
      for (j = 0; j < 4; j++)
         out[1][j] = 1.0f;
      break;
   default:
      assert(swizzle_g < 4);
      for (j = 0; j < 4; j++)
         out[1][j] = in[swizzle_g][j];
   }

   switch (swizzle_b) {
   case PIPE_SWIZZLE_ZERO:
      for (j = 0; j < 4; j++)
         out[2][j] = 0.0f;
      break;
   case PIPE_SWIZZLE_ONE:
      for (j = 0; j < 4; j++)
         out[2][j] = 1.0f;
      break;
   default:
      assert(swizzle_b < 4);
      for (j = 0; j < 4; j++)
         out[2][j] = in[swizzle_b][j];
   }

   switch (swizzle_a) {
   case PIPE_SWIZZLE_ZERO:
      for (j = 0; j < 4; j++)
         out[3][j] = 0.0f;
      break;
   case PIPE_SWIZZLE_ONE:
      for (j = 0; j < 4; j++)
         out[3][j] = 1.0f;
      break;
   default:
      assert(swizzle_a < 4);
      for (j = 0; j < 4; j++)
         out[3][j] = in[swizzle_a][j];
   }
}


static wrap_nearest_func
get_nearest_unorm_wrap(unsigned mode)
{
   switch (mode) {
   case PIPE_TEX_WRAP_CLAMP:
      return wrap_nearest_unorm_clamp;
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      return wrap_nearest_unorm_clamp_to_edge;
   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
      return wrap_nearest_unorm_clamp_to_border;
   default:
      assert(0);
      return wrap_nearest_unorm_clamp;
   }
}


static wrap_nearest_func
get_nearest_wrap(unsigned mode)
{
   switch (mode) {
   case PIPE_TEX_WRAP_REPEAT:
      return wrap_nearest_repeat;
   case PIPE_TEX_WRAP_CLAMP:
      return wrap_nearest_clamp;
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      return wrap_nearest_clamp_to_edge;
   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
      return wrap_nearest_clamp_to_border;
   case PIPE_TEX_WRAP_MIRROR_REPEAT:
      return wrap_nearest_mirror_repeat;
   case PIPE_TEX_WRAP_MIRROR_CLAMP:
      return wrap_nearest_mirror_clamp;
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
      return wrap_nearest_mirror_clamp_to_edge;
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER:
      return wrap_nearest_mirror_clamp_to_border;
   default:
      assert(0);
      return wrap_nearest_repeat;
   }
}


static wrap_linear_func
get_linear_unorm_wrap(unsigned mode)
{
   switch (mode) {
   case PIPE_TEX_WRAP_CLAMP:
      return wrap_linear_unorm_clamp;
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      return wrap_linear_unorm_clamp_to_edge;
   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
      return wrap_linear_unorm_clamp_to_border;
   default:
      assert(0);
      return wrap_linear_unorm_clamp;
   }
}


static wrap_linear_func
get_linear_wrap(unsigned mode)
{
   switch (mode) {
   case PIPE_TEX_WRAP_REPEAT:
      return wrap_linear_repeat;
   case PIPE_TEX_WRAP_CLAMP:
      return wrap_linear_clamp;
   case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
      return wrap_linear_clamp_to_edge;
   case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
      return wrap_linear_clamp_to_border;
   case PIPE_TEX_WRAP_MIRROR_REPEAT:
      return wrap_linear_mirror_repeat;
   case PIPE_TEX_WRAP_MIRROR_CLAMP:
      return wrap_linear_mirror_clamp;
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
      return wrap_linear_mirror_clamp_to_edge;
   case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER:
      return wrap_linear_mirror_clamp_to_border;
   default:
      assert(0);
      return wrap_linear_repeat;
   }
}


/**
 * Is swizzling needed for the given state key?
 */
static INLINE bool
any_swizzle(const struct pipe_sampler_view *view)
{
   return (view->swizzle_r != PIPE_SWIZZLE_RED ||
           view->swizzle_g != PIPE_SWIZZLE_GREEN ||
           view->swizzle_b != PIPE_SWIZZLE_BLUE ||
           view->swizzle_a != PIPE_SWIZZLE_ALPHA);
}


static img_filter_func
get_img_filter(const struct sp_sampler_view *sp_sview,
               const struct pipe_sampler_state *sampler,
               unsigned filter)
{
   switch (sp_sview->base.texture->target) {
   case PIPE_BUFFER:
   case PIPE_TEXTURE_1D:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_1d_nearest;
      else
         return img_filter_1d_linear;
      break;
   case PIPE_TEXTURE_1D_ARRAY:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_1d_array_nearest;
      else
         return img_filter_1d_array_linear;
      break;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
      /* Try for fast path:
       */
      if (sp_sview->pot2d &&
          sampler->wrap_s == sampler->wrap_t &&
          sampler->normalized_coords) 
      {
         switch (sampler->wrap_s) {
         case PIPE_TEX_WRAP_REPEAT:
            switch (filter) {
            case PIPE_TEX_FILTER_NEAREST:
               return img_filter_2d_nearest_repeat_POT;
            case PIPE_TEX_FILTER_LINEAR:
               return img_filter_2d_linear_repeat_POT;
            default:
               break;
            }
            break;
         case PIPE_TEX_WRAP_CLAMP:
            switch (filter) {
            case PIPE_TEX_FILTER_NEAREST:
               return img_filter_2d_nearest_clamp_POT;
            default:
               break;
            }
         }
      }
      /* Otherwise use default versions:
       */
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_2d_nearest;
      else
         return img_filter_2d_linear;
      break;
   case PIPE_TEXTURE_2D_ARRAY:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_2d_array_nearest;
      else
         return img_filter_2d_array_linear;
      break;
   case PIPE_TEXTURE_CUBE:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_cube_nearest;
      else
         return img_filter_cube_linear;
      break;
   case PIPE_TEXTURE_CUBE_ARRAY:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_cube_array_nearest;
      else
         return img_filter_cube_array_linear;
      break;
   case PIPE_TEXTURE_3D:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_3d_nearest;
      else
         return img_filter_3d_linear;
      break;
   default:
      assert(0);
      return img_filter_1d_nearest;
   }
}


static void
sample_mip(struct sp_sampler_view *sp_sview,
           struct sp_sampler *sp_samp,
           const float s[TGSI_QUAD_SIZE],
           const float t[TGSI_QUAD_SIZE],
           const float p[TGSI_QUAD_SIZE],
           const float c0[TGSI_QUAD_SIZE],
           const float lod[TGSI_QUAD_SIZE],
           enum tgsi_sampler_control control,
           float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   mip_filter_func mip_filter;
   img_filter_func min_img_filter = NULL;
   img_filter_func mag_img_filter = NULL;

   if (sp_sview->pot2d & sp_samp->min_mag_equal_repeat_linear) {
      mip_filter = mip_filter_linear_2d_linear_repeat_POT;
   }
   else {
      mip_filter = sp_samp->mip_filter;
      min_img_filter = get_img_filter(sp_sview, &sp_samp->base, sp_samp->min_img_filter);
      if (sp_samp->min_mag_equal) {
         mag_img_filter = min_img_filter;
      }
      else {
         mag_img_filter = get_img_filter(sp_sview, &sp_samp->base, sp_samp->base.mag_img_filter);
      }
   }

   mip_filter(sp_sview, sp_samp, min_img_filter, mag_img_filter,
              s, t, p, c0, lod, control, rgba);

   if (sp_samp->base.compare_mode != PIPE_TEX_COMPARE_NONE) {
      sample_compare(sp_sview, sp_samp, s, t, p, c0, lod, control, rgba);
   }

   if (sp_sview->need_swizzle) {
      float rgba_temp[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
      memcpy(rgba_temp, rgba, sizeof(rgba_temp));
      do_swizzling(&sp_sview->base, rgba_temp, rgba);
   }

}


/**
 * Use 3D texcoords to choose a cube face, then sample the 2D cube faces.
 * Put face info into the sampler faces[] array.
 */
static void
sample_cube(struct sp_sampler_view *sp_sview,
            struct sp_sampler *sp_samp,
            const float s[TGSI_QUAD_SIZE],
            const float t[TGSI_QUAD_SIZE],
            const float p[TGSI_QUAD_SIZE],
            const float c0[TGSI_QUAD_SIZE],
            const float c1[TGSI_QUAD_SIZE],
            enum tgsi_sampler_control control,
            float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   unsigned j;
   float ssss[4], tttt[4];

   /* Not actually used, but the intermediate steps that do the
    * dereferencing don't know it.
    */
   static float pppp[4] = { 0, 0, 0, 0 };

   pppp[0] = c0[0];
   pppp[1] = c0[1];
   pppp[2] = c0[2];
   pppp[3] = c0[3];
   /*
     major axis
     direction    target                             sc     tc    ma
     ----------   -------------------------------    ---    ---   ---
     +rx          TEXTURE_CUBE_MAP_POSITIVE_X_EXT    -rz    -ry   rx
     -rx          TEXTURE_CUBE_MAP_NEGATIVE_X_EXT    +rz    -ry   rx
     +ry          TEXTURE_CUBE_MAP_POSITIVE_Y_EXT    +rx    +rz   ry
     -ry          TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT    +rx    -rz   ry
     +rz          TEXTURE_CUBE_MAP_POSITIVE_Z_EXT    +rx    -ry   rz
     -rz          TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT    -rx    -ry   rz
   */

   /* Choose the cube face and compute new s/t coords for the 2D face.
    *
    * Use the same cube face for all four pixels in the quad.
    *
    * This isn't ideal, but if we want to use a different cube face
    * per pixel in the quad, we'd have to also compute the per-face
    * LOD here too.  That's because the four post-face-selection
    * texcoords are no longer related to each other (they're
    * per-face!)  so we can't use subtraction to compute the partial
    * deriviates to compute the LOD.  Doing so (near cube edges
    * anyway) gives us pretty much random values.
    */
   {
      /* use the average of the four pixel's texcoords to choose the face */
      const float rx = 0.25F * (s[0] + s[1] + s[2] + s[3]);
      const float ry = 0.25F * (t[0] + t[1] + t[2] + t[3]);
      const float rz = 0.25F * (p[0] + p[1] + p[2] + p[3]);
      const float arx = fabsf(rx), ary = fabsf(ry), arz = fabsf(rz);

      if (arx >= ary && arx >= arz) {
         float sign = (rx >= 0.0F) ? 1.0F : -1.0F;
         uint face = (rx >= 0.0F) ? PIPE_TEX_FACE_POS_X : PIPE_TEX_FACE_NEG_X;
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(s[j]);
            ssss[j] = sign *  p[j] * ima + 0.5F;
            tttt[j] =         t[j] * ima + 0.5F;
            sp_sview->faces[j] = face;
         }
      }
      else if (ary >= arx && ary >= arz) {
         float sign = (ry >= 0.0F) ? 1.0F : -1.0F;
         uint face = (ry >= 0.0F) ? PIPE_TEX_FACE_POS_Y : PIPE_TEX_FACE_NEG_Y;
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(t[j]);
            ssss[j] =        -s[j] * ima + 0.5F;
            tttt[j] = sign * -p[j] * ima + 0.5F;
            sp_sview->faces[j] = face;
         }
      }
      else {
         float sign = (rz >= 0.0F) ? 1.0F : -1.0F;
         uint face = (rz >= 0.0F) ? PIPE_TEX_FACE_POS_Z : PIPE_TEX_FACE_NEG_Z;
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(p[j]);
            ssss[j] = sign * -s[j] * ima + 0.5F;
            tttt[j] =         t[j] * ima + 0.5F;
            sp_sview->faces[j] = face;
         }
      }
   }

   sample_mip(sp_sview, sp_samp, ssss, tttt, pppp, c0, c1, control, rgba);
}


static void
sp_get_dims(struct sp_sampler_view *sp_sview, int level,
            int dims[4])
{
   const struct pipe_sampler_view *view = &sp_sview->base;
   const struct pipe_resource *texture = view->texture;

   /* undefined according to EXT_gpu_program */
   level += view->u.tex.first_level;
   if (level > view->u.tex.last_level)
      return;

   dims[0] = u_minify(texture->width0, level);

   switch(texture->target) {
   case PIPE_TEXTURE_1D_ARRAY:
      dims[1] = view->u.tex.last_layer - view->u.tex.first_layer + 1;
      /* fallthrough */
   case PIPE_TEXTURE_1D:
      return;
   case PIPE_TEXTURE_2D_ARRAY:
      dims[2] = view->u.tex.last_layer - view->u.tex.first_layer + 1;
      /* fallthrough */
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_CUBE:
   case PIPE_TEXTURE_RECT:
      dims[1] = u_minify(texture->height0, level);
      return;
   case PIPE_TEXTURE_3D:
      dims[1] = u_minify(texture->height0, level);
      dims[2] = u_minify(texture->depth0, level);
      return;
   case PIPE_TEXTURE_CUBE_ARRAY:
      dims[1] = u_minify(texture->height0, level);
      dims[2] = (view->u.tex.last_layer - view->u.tex.first_layer + 1) / 6;
      break;
   case PIPE_BUFFER:
      dims[0] /= util_format_get_blocksize(view->format);
      return;
   default:
      assert(!"unexpected texture target in sp_get_dims()");
      return;
   }
}

/**
 * This function is only used for getting unfiltered texels via the
 * TXF opcode.  The GL spec says that out-of-bounds texel fetches
 * produce undefined results.  Instead of crashing, lets just clamp
 * coords to the texture image size.
 */
static void
sp_get_texels(struct sp_sampler_view *sp_sview,
              const int v_i[TGSI_QUAD_SIZE],
              const int v_j[TGSI_QUAD_SIZE],
              const int v_k[TGSI_QUAD_SIZE],
              const int lod[TGSI_QUAD_SIZE],
              const int8_t offset[3],
              float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   union tex_tile_address addr;
   const struct pipe_resource *texture = sp_sview->base.texture;
   int j, c;
   const float *tx;
   int width, height, depth;

   addr.value = 0;
   /* TODO write a better test for LOD */
   addr.bits.level = lod[0];

   width = u_minify(texture->width0, addr.bits.level);
   height = u_minify(texture->height0, addr.bits.level);
   depth = u_minify(texture->depth0, addr.bits.level);

   switch(texture->target) {
   case PIPE_BUFFER:
   case PIPE_TEXTURE_1D:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         tx = get_texel_2d_no_border(sp_sview, addr, x, 0);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_1D_ARRAY:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         int y = CLAMP(v_j[j], sp_sview->base.u.tex.first_layer, sp_sview->base.u.tex.last_layer);
         tx = get_texel_2d_no_border(sp_sview, addr, x, y);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         int y = CLAMP(v_j[j] + offset[1], 0, height - 1);
         tx = get_texel_2d_no_border(sp_sview, addr, x, y);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_2D_ARRAY:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         int y = CLAMP(v_j[j] + offset[1], 0, height - 1);
         int layer = CLAMP(v_k[j], sp_sview->base.u.tex.first_layer, sp_sview->base.u.tex.last_layer);
         tx = get_texel_3d_no_border(sp_sview, addr, x, y, layer);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_3D:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         int y = CLAMP(v_j[j] + offset[1], 0, height - 1);
         int z = CLAMP(v_k[j] + offset[2], 0, depth - 1);
         tx = get_texel_3d_no_border(sp_sview, addr, x, y, z);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_CUBE: /* TXF can't work on CUBE according to spec */
   default:
      assert(!"Unknown or CUBE texture type in TXF processing\n");
      break;
   }

   if (sp_sview->need_swizzle) {
      float rgba_temp[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
      memcpy(rgba_temp, rgba, sizeof(rgba_temp));
      do_swizzling(&sp_sview->base, rgba_temp, rgba);
   }
}


void *
softpipe_create_sampler_state(struct pipe_context *pipe,
                              const struct pipe_sampler_state *sampler)
{
   struct sp_sampler *samp = CALLOC_STRUCT(sp_sampler);

   samp->base = *sampler;

   /* Note that (for instance) linear_texcoord_s and
    * nearest_texcoord_s may be active at the same time, if the
    * sampler min_img_filter differs from its mag_img_filter.
    */
   if (sampler->normalized_coords) {
      samp->linear_texcoord_s = get_linear_wrap( sampler->wrap_s );
      samp->linear_texcoord_t = get_linear_wrap( sampler->wrap_t );
      samp->linear_texcoord_p = get_linear_wrap( sampler->wrap_r );

      samp->nearest_texcoord_s = get_nearest_wrap( sampler->wrap_s );
      samp->nearest_texcoord_t = get_nearest_wrap( sampler->wrap_t );
      samp->nearest_texcoord_p = get_nearest_wrap( sampler->wrap_r );
   }
   else {
      samp->linear_texcoord_s = get_linear_unorm_wrap( sampler->wrap_s );
      samp->linear_texcoord_t = get_linear_unorm_wrap( sampler->wrap_t );
      samp->linear_texcoord_p = get_linear_unorm_wrap( sampler->wrap_r );

      samp->nearest_texcoord_s = get_nearest_unorm_wrap( sampler->wrap_s );
      samp->nearest_texcoord_t = get_nearest_unorm_wrap( sampler->wrap_t );
      samp->nearest_texcoord_p = get_nearest_unorm_wrap( sampler->wrap_r );
   }

   samp->min_img_filter = sampler->min_img_filter;

   switch (sampler->min_mip_filter) {
   case PIPE_TEX_MIPFILTER_NONE:
      if (sampler->min_img_filter == sampler->mag_img_filter)
         samp->mip_filter = mip_filter_none_no_filter_select;
      else
         samp->mip_filter = mip_filter_none;
      break;

   case PIPE_TEX_MIPFILTER_NEAREST:
      samp->mip_filter = mip_filter_nearest;
      break;

   case PIPE_TEX_MIPFILTER_LINEAR:
      if (sampler->min_img_filter == sampler->mag_img_filter &&
          sampler->normalized_coords &&
          sampler->wrap_s == PIPE_TEX_WRAP_REPEAT &&
          sampler->wrap_t == PIPE_TEX_WRAP_REPEAT &&
          sampler->min_img_filter == PIPE_TEX_FILTER_LINEAR &&
          sampler->max_anisotropy <= 1) {
         samp->min_mag_equal_repeat_linear = TRUE;
      }
      samp->mip_filter = mip_filter_linear;

      /* Anisotropic filtering extension. */
      if (sampler->max_anisotropy > 1) {
         samp->mip_filter = mip_filter_linear_aniso;

         /* Override min_img_filter:
          * min_img_filter needs to be set to NEAREST since we need to access
          * each texture pixel as it is and weight it later; using linear
          * filters will have incorrect results.
          * By setting the filter to NEAREST here, we can avoid calling the
          * generic img_filter_2d_nearest in the anisotropic filter function,
          * making it possible to use one of the accelerated implementations
          */
         samp->min_img_filter = PIPE_TEX_FILTER_NEAREST;

         /* on first access create the lookup table containing the filter weights. */
        if (!weightLut) {
           create_filter_table();
        }
      }
      break;
   }
   if (samp->min_img_filter == sampler->mag_img_filter) {
      samp->min_mag_equal = TRUE;
   }

   return (void *)samp;
}


compute_lambda_func
softpipe_get_lambda_func(const struct pipe_sampler_view *view, unsigned shader)
{
   if (shader != PIPE_SHADER_FRAGMENT)
      return compute_lambda_vert;

   switch (view->texture->target) {
   case PIPE_BUFFER:
   case PIPE_TEXTURE_1D:
   case PIPE_TEXTURE_1D_ARRAY:
      return compute_lambda_1d;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_2D_ARRAY:
   case PIPE_TEXTURE_RECT:
   case PIPE_TEXTURE_CUBE:
   case PIPE_TEXTURE_CUBE_ARRAY:
      return compute_lambda_2d;
   case PIPE_TEXTURE_3D:
      return compute_lambda_3d;
   default:
      assert(0);
      return compute_lambda_1d;
   }
}


struct pipe_sampler_view *
softpipe_create_sampler_view(struct pipe_context *pipe,
                             struct pipe_resource *resource,
                             const struct pipe_sampler_view *templ)
{
   struct sp_sampler_view *sview = CALLOC_STRUCT(sp_sampler_view);
   struct softpipe_resource *spr = (struct softpipe_resource *)resource;

   if (sview) {
      struct pipe_sampler_view *view = &sview->base;
      *view = *templ;
      view->reference.count = 1;
      view->texture = NULL;
      pipe_resource_reference(&view->texture, resource);
      view->context = pipe;

      if (any_swizzle(view)) {
         sview->need_swizzle = TRUE;
      }

      if (resource->target == PIPE_TEXTURE_CUBE ||
          resource->target == PIPE_TEXTURE_CUBE_ARRAY)
         sview->get_samples = sample_cube;
      else {
         sview->get_samples = sample_mip;
      }
      sview->pot2d = spr->pot &&
                     (resource->target == PIPE_TEXTURE_2D ||
                      resource->target == PIPE_TEXTURE_RECT);

      sview->xpot = util_logbase2( resource->width0 );
      sview->ypot = util_logbase2( resource->height0 );
   }

   return (struct pipe_sampler_view *) sview;
}


static void
sp_tgsi_get_dims(struct tgsi_sampler *tgsi_sampler,
                 const unsigned sview_index,
                 int level, int dims[4])
{
   struct sp_tgsi_sampler *sp_samp = (struct sp_tgsi_sampler *)tgsi_sampler;

   assert(sview_index < PIPE_MAX_SHADER_SAMPLER_VIEWS);
   /* always have a view here but texture is NULL if no sampler view was set. */
   if (!sp_samp->sp_sview[sview_index].base.texture) {
      dims[0] = dims[1] = dims[2] = dims[3] = 0;
      return;
   }
   sp_get_dims(&sp_samp->sp_sview[sview_index], level, dims);
}


static void
sp_tgsi_get_samples(struct tgsi_sampler *tgsi_sampler,
                    const unsigned sview_index,
                    const unsigned sampler_index,
                    const float s[TGSI_QUAD_SIZE],
                    const float t[TGSI_QUAD_SIZE],
                    const float p[TGSI_QUAD_SIZE],
                    const float c0[TGSI_QUAD_SIZE],
                    const float lod[TGSI_QUAD_SIZE],
                    float derivs[3][2][TGSI_QUAD_SIZE],
                    const int8_t offset[3],
                    enum tgsi_sampler_control control,
                    float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   struct sp_tgsi_sampler *sp_samp = (struct sp_tgsi_sampler *)tgsi_sampler;

   assert(sview_index < PIPE_MAX_SHADER_SAMPLER_VIEWS);
   assert(sampler_index < PIPE_MAX_SAMPLERS);
   assert(sp_samp->sp_sampler[sampler_index]);
   /* always have a view here but texture is NULL if no sampler view was set. */
   if (!sp_samp->sp_sview[sview_index].base.texture) {
      int i, j;
      for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
            rgba[j][i] = 0.0f;
         }
      }
      return;
   }
   sp_samp->sp_sview[sview_index].get_samples(&sp_samp->sp_sview[sview_index],
                                              sp_samp->sp_sampler[sampler_index],
                                              s, t, p, c0, lod, control, rgba);
}


static void
sp_tgsi_get_texel(struct tgsi_sampler *tgsi_sampler,
                  const unsigned sview_index,
                  const int i[TGSI_QUAD_SIZE],
                  const int j[TGSI_QUAD_SIZE], const int k[TGSI_QUAD_SIZE],
                  const int lod[TGSI_QUAD_SIZE], const int8_t offset[3],
                  float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   struct sp_tgsi_sampler *sp_samp = (struct sp_tgsi_sampler *)tgsi_sampler;

   assert(sview_index < PIPE_MAX_SHADER_SAMPLER_VIEWS);
   /* always have a view here but texture is NULL if no sampler view was set. */
   if (!sp_samp->sp_sview[sview_index].base.texture) {
      int i, j;
      for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
            rgba[j][i] = 0.0f;
         }
      }
      return;
   }
   sp_get_texels(&sp_samp->sp_sview[sview_index], i, j, k, lod, offset, rgba);
}


struct sp_tgsi_sampler *
sp_create_tgsi_sampler(void)
{
   struct sp_tgsi_sampler *samp = CALLOC_STRUCT(sp_tgsi_sampler);
   if (!samp)
      return NULL;

   samp->base.get_dims = sp_tgsi_get_dims;
   samp->base.get_samples = sp_tgsi_get_samples;
   samp->base.get_texel = sp_tgsi_get_texel;

   return samp;
}

@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1863 1
a1863 1
   const struct pipe_sampler_view *psview = &sp_sview->base;
d1870 1
a1870 1
      int level0 = psview->u.tex.first_level + (int)lod[j];
d1874 1
a1874 1
                    psview->u.tex.first_level,
d1877 2
a1878 2
      else if (level0 >= (int) psview->u.tex.last_level)
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], psview->u.tex.last_level,
d1921 1
a1921 1
   const struct pipe_sampler_view *psview = &sp_sview->base;
d1930 1
a1930 1
                    psview->u.tex.first_level,
d1933 2
a1934 2
         int level = psview->u.tex.first_level + (int)(lod[j] + 0.5F);
         level = MIN2(level, (int)psview->u.tex.last_level);
a2232 1
   const struct pipe_sampler_view *psview = &sp_sview->base;
d2237 2
a2238 2
   float s_to_u = u_minify(texture->width0, psview->u.tex.first_level);
   float t_to_v = u_minify(texture->height0, psview->u.tex.first_level);
d2295 1
a2295 1
   level0 = psview->u.tex.first_level + (int)lambda;
d2300 1
a2300 1
   if (level0 >= (int) psview->u.tex.last_level) {
d2303 1
a2303 1
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], psview->u.tex.last_level,
d2339 1
a2339 1
   const struct pipe_sampler_view *psview = &sp_sview->base;
d2346 1
a2346 1
      int level0 = psview->u.tex.first_level + (int)lod[j];
d2350 1
a2350 1
      if ((unsigned)level0 >= psview->u.tex.last_level) {
d2353 1
a2353 1
                                            psview->u.tex.first_level,
d2357 1
a2357 1
                                            psview->u.tex.last_level,
d2588 1
a2588 1
      debug_printf("illegal wrap mode %d with non-normalized coords\n", mode);
d2632 1
a2632 1
      debug_printf("illegal wrap mode %d with non-normalized coords\n", mode);
a2908 9
   if (texture->target == PIPE_BUFFER) {
      dims[0] = (view->u.buf.last_element - view->u.buf.first_element) + 1;
      /* the other values are undefined, but let's avoid potential valgrind
       * warnings.
       */
      dims[1] = dims[2] = dims[3] = 0;
      return;
   }

a2913 1
   dims[3] = view->u.tex.last_level - view->u.tex.first_level + 1;
d2938 3
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1863 1
a1863 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1870 1
a1870 1
      int level0 = sp_sview->base.u.tex.first_level + (int)lod[j];
d1874 1
a1874 1
                    sp_sview->base.u.tex.first_level,
d1877 2
a1878 2
      else if (level0 >= (int) texture->last_level)
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], texture->last_level,
d1921 1
a1921 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1930 1
a1930 1
                    sp_sview->base.u.tex.first_level,
d1933 2
a1934 2
         int level = sp_sview->base.u.tex.first_level + (int)(lod[j] + 0.5F);
         level = MIN2(level, (int)texture->last_level);
d2233 1
d2238 2
a2239 2
   float s_to_u = u_minify(texture->width0, sp_sview->base.u.tex.first_level);
   float t_to_v = u_minify(texture->height0, sp_sview->base.u.tex.first_level);
d2296 1
a2296 1
   level0 = sp_sview->base.u.tex.first_level + (int)lambda;
d2301 1
a2301 1
   if (level0 >= (int) texture->last_level) {
d2304 1
a2304 1
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], texture->last_level,
d2340 1
a2340 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d2347 1
a2347 1
      int level0 = sp_sview->base.u.tex.first_level + (int)lod[j];
d2351 1
a2351 1
      if ((unsigned)level0 >= texture->last_level) { 
d2354 1
a2354 1
                                            sp_sview->base.u.tex.first_level,
d2358 1
a2358 1
                                            sp_sview->base.texture->last_level,
d2589 1
a2589 1
      assert(0);
d2633 1
a2633 1
      assert(0);
d2910 9
d2924 1
a2948 3
   case PIPE_BUFFER:
      dims[0] /= util_format_get_blocksize(view->format);
      return;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d22 1
a22 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d611 42
d662 1
a662 1
     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },
d665 1
a665 1
     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },
d670 1
a670 1
     PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z },
d674 1
a674 1
     PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z },
d679 1
a679 1
     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },
d683 1
a683 1
     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y }
d687 1
a687 1
get_next_face(unsigned face, int x, int y)
d689 2
a690 1
   int idx = 0;
d692 37
a728 10
   if (x == 0 && y == 0)
      return face;
   if (x == -1)
      idx = 0;
   else if (x == 1)
      idx = 1;
   else if (y == -1)
      idx = 2;
   else if (y == 1)
      idx = 3;
d730 27
a756 1
   return face_array[face][idx];
d759 1
d768 1
a768 3
   int new_x, new_y;
   int max_x, max_y;
   int c;
d771 2
a772 1
   max_y = (int) u_minify(texture->height0, level);
a775 16
   /* the corner case */
   if ((x < 0 || x >= max_x) &&
       (y < 0 || y >= max_y)) {
      const float *c1, *c2, *c3;
      int fx = x < 0 ? 0 : max_x - 1;
      int fy = y < 0 ? 0 : max_y - 1;
      c1 = get_texel_2d_no_border( sp_sview, addr, fx, fy);
      addr.bits.face = get_next_face(face, (x < 0) ? -1 : 1, 0);
      c2 = get_texel_2d_no_border( sp_sview, addr, (x < 0) ? max_x - 1 : 0, fy);
      addr.bits.face = get_next_face(face, 0, (y < 0) ? -1 : 1);
      c3 = get_texel_2d_no_border( sp_sview, addr, fx, (y < 0) ?  max_y - 1 : 0);
      for (c = 0; c < TGSI_QUAD_SIZE; c++)
         corner[c] = CLAMP((c1[c] + c2[c] + c3[c]), 0.0F, 1.0F) / 3;

      return corner;
   }
d778 16
a793 2
      new_x = max_x - 1;
      face = get_next_face(face, -1, 0);
d795 6
a800 2
      new_x = 0;
      face = get_next_face(face, 1, 0);
d802 7
a808 5
      new_y = max_y - 1;
      face = get_next_face(face, 0, -1);
   } else if (y >= max_y) {
      new_y = 0;
      face = get_next_face(face, 0, 1);
d1344 1
d1629 1
d1633 1
d2397 5
a2401 3
   int j, k0, k1, k2, k3;
   float val;
   float pc0, pc1, pc2, pc3;
d2412 4
a2415 4
      pc0 = CLAMP(c0[0], 0.0F, 1.0F);
      pc1 = CLAMP(c0[1], 0.0F, 1.0F);
      pc2 = CLAMP(c0[2], 0.0F, 1.0F);
      pc3 = CLAMP(c0[3], 0.0F, 1.0F);
d2417 4
a2420 4
      pc0 = CLAMP(c1[0], 0.0F, 1.0F);
      pc1 = CLAMP(c1[1], 0.0F, 1.0F);
      pc2 = CLAMP(c1[2], 0.0F, 1.0F);
      pc3 = CLAMP(c1[3], 0.0F, 1.0F);
d2422 4
a2425 4
      pc0 = CLAMP(p[0], 0.0F, 1.0F);
      pc1 = CLAMP(p[1], 0.0F, 1.0F);
      pc2 = CLAMP(p[2], 0.0F, 1.0F);
      pc3 = CLAMP(p[3], 0.0F, 1.0F);
d2427 18
d2448 4
a2451 4
      k0 = pc0 < rgba[0][0];
      k1 = pc1 < rgba[0][1];
      k2 = pc2 < rgba[0][2];
      k3 = pc3 < rgba[0][3];
d2454 4
a2457 4
      k0 = pc0 <= rgba[0][0];
      k1 = pc1 <= rgba[0][1];
      k2 = pc2 <= rgba[0][2];
      k3 = pc3 <= rgba[0][3];
d2460 4
a2463 4
      k0 = pc0 > rgba[0][0];
      k1 = pc1 > rgba[0][1];
      k2 = pc2 > rgba[0][2];
      k3 = pc3 > rgba[0][3];
d2466 4
a2469 4
      k0 = pc0 >= rgba[0][0];
      k1 = pc1 >= rgba[0][1];
      k2 = pc2 >= rgba[0][2];
      k3 = pc3 >= rgba[0][3];
d2472 4
a2475 4
      k0 = pc0 == rgba[0][0];
      k1 = pc1 == rgba[0][1];
      k2 = pc2 == rgba[0][2];
      k3 = pc3 == rgba[0][3];
d2478 4
a2481 4
      k0 = pc0 != rgba[0][0];
      k1 = pc1 != rgba[0][1];
      k2 = pc2 != rgba[0][2];
      k3 = pc3 != rgba[0][3];
d2484 1
a2484 1
      k0 = k1 = k2 = k3 = 1;
d2487 1
a2487 1
      k0 = k1 = k2 = k3 = 0;
d2490 1
a2490 1
      k0 = k1 = k2 = k3 = 0;
d2495 5
a2499 22
   if (sampler->mag_img_filter == PIPE_TEX_FILTER_LINEAR) {
      /* convert four pass/fail values to an intensity in [0,1] */
      /*
       * XXX this doesn't actually make much sense.
       * We just average the result of four _pixels_ and output the same
       * value for all of the four pixels of the quad.
       * This really needs to work on the _samples_ i.e. inside the img filter.
       */
      val = 0.25F * (k0 + k1 + k2 + k3);

      /* XXX returning result for default GL_DEPTH_TEXTURE_MODE = GL_LUMINANCE */
      for (j = 0; j < 4; j++) {
         rgba[0][j] = rgba[1][j] = rgba[2][j] = val;
         rgba[3][j] = 1.0F;
      }
   } else {
      for (j = 0; j < 4; j++) {
         rgba[0][j] = k0;
         rgba[1][j] = k1;
         rgba[2][j] = k2;
         rgba[3][j] = 1.0F;
      }
d3201 5
a3205 1
   /* TODO should have defined behavior if no texture is bound. */
d3229 10
a3238 2
   /* FIXME should have defined behavior if no texture is bound. */
   assert(sp_samp->sp_sview[sview_index].get_samples);
d3256 10
a3265 2
   /* FIXME should have defined behavior if no texture is bound. */
   assert(sp_samp->sp_sview[sview_index].base.texture);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d41 1
d43 1
d46 1
a131 1
 * \return  integer texture index
d134 1
a134 1
wrap_nearest_repeat(const float s[4], unsigned size, int icoord[4])
a135 1
   uint ch;
d138 2
a139 4
   for (ch = 0; ch < 4; ch++) {
      int i = util_ifloor(s[ch] * size);
      icoord[ch] = repeat(i, size);
   }
d144 1
a144 1
wrap_nearest_clamp(const float s[4], unsigned size, int icoord[4])
a145 1
   uint ch;
d148 6
a153 8
   for (ch = 0; ch < 4; ch++) {
      if (s[ch] <= 0.0F)
         icoord[ch] = 0;
      else if (s[ch] >= 1.0F)
         icoord[ch] = size - 1;
      else
         icoord[ch] = util_ifloor(s[ch] * size);
   }
d158 1
a158 1
wrap_nearest_clamp_to_edge(const float s[4], unsigned size, int icoord[4])
a159 1
   uint ch;
d164 6
a169 8
   for (ch = 0; ch < 4; ch++) {
      if (s[ch] < min)
         icoord[ch] = 0;
      else if (s[ch] > max)
         icoord[ch] = size - 1;
      else
         icoord[ch] = util_ifloor(s[ch] * size);
   }
d174 1
a174 1
wrap_nearest_clamp_to_border(const float s[4], unsigned size, int icoord[4])
a175 1
   uint ch;
d180 6
a185 8
   for (ch = 0; ch < 4; ch++) {
      if (s[ch] <= min)
         icoord[ch] = -1;
      else if (s[ch] >= max)
         icoord[ch] = size;
      else
         icoord[ch] = util_ifloor(s[ch] * size);
   }
d190 1
a190 1
wrap_nearest_mirror_repeat(const float s[4], unsigned size, int icoord[4])
a191 1
   uint ch;
d194 10
a203 12
   for (ch = 0; ch < 4; ch++) {
      const int flr = util_ifloor(s[ch]);
      float u = frac(s[ch]);
      if (flr & 1)
         u = 1.0F - u;
      if (u < min)
         icoord[ch] = 0;
      else if (u > max)
         icoord[ch] = size - 1;
      else
         icoord[ch] = util_ifloor(u * size);
   }
d208 1
a208 1
wrap_nearest_mirror_clamp(const float s[4], unsigned size, int icoord[4])
d210 9
a218 12
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      /* s limited to [0,1] */
      /* i limited to [0,size-1] */
      const float u = fabsf(s[ch]);
      if (u <= 0.0F)
         icoord[ch] = 0;
      else if (u >= 1.0F)
         icoord[ch] = size - 1;
      else
         icoord[ch] = util_ifloor(u * size);
   }
d223 1
a223 2
wrap_nearest_mirror_clamp_to_edge(const float s[4], unsigned size,
                                  int icoord[4])
a224 1
   uint ch;
d229 7
a235 9
   for (ch = 0; ch < 4; ch++) {
      const float u = fabsf(s[ch]);
      if (u < min)
         icoord[ch] = 0;
      else if (u > max)
         icoord[ch] = size - 1;
      else
         icoord[ch] = util_ifloor(u * size);
   }
d240 1
a240 2
wrap_nearest_mirror_clamp_to_border(const float s[4], unsigned size,
                                    int icoord[4])
a241 1
   uint ch;
d246 7
a252 9
   for (ch = 0; ch < 4; ch++) {
      const float u = fabsf(s[ch]);
      if (u < min)
         icoord[ch] = -1;
      else if (u > max)
         icoord[ch] = size;
      else
         icoord[ch] = util_ifloor(u * size);
   }
d257 1
a257 1
 * Used to compute texel locations for linear sampling for four texcoords.
d259 1
a259 1
 * \param s  the texcoords
d261 4
a264 4
 * \param icoord0  returns first texture indexes
 * \param icoord1  returns second texture indexes (usually icoord0 + 1)
 * \param w  returns blend factor/weight between texture indexes
 * \param icoord  returns the computed integer texture coords
d267 2
a268 2
wrap_linear_repeat(const float s[4], unsigned size,
                   int icoord0[4], int icoord1[4], float w[4])
d270 4
a273 7
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = s[ch] * size - 0.5F;
      icoord0[ch] = repeat(util_ifloor(u), size);
      icoord1[ch] = repeat(icoord0[ch] + 1, size);
      w[ch] = frac(u);
   }
d278 2
a279 2
wrap_linear_clamp(const float s[4], unsigned size,
                  int icoord0[4], int icoord1[4], float w[4])
d281 5
a285 8
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = CLAMP(s[ch], 0.0F, 1.0F);
      u = u * size - 0.5f;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      w[ch] = frac(u);
   }
d290 2
a291 2
wrap_linear_clamp_to_edge(const float s[4], unsigned size,
                          int icoord0[4], int icoord1[4], float w[4])
d293 9
a301 12
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = CLAMP(s[ch], 0.0F, 1.0F);
      u = u * size - 0.5f;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      if (icoord0[ch] < 0)
         icoord0[ch] = 0;
      if (icoord1[ch] >= (int) size)
         icoord1[ch] = size - 1;
      w[ch] = frac(u);
   }
d306 2
a307 2
wrap_linear_clamp_to_border(const float s[4], unsigned size,
                            int icoord0[4], int icoord1[4], float w[4])
d311 5
a315 8
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = CLAMP(s[ch], min, max);
      u = u * size - 0.5f;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      w[ch] = frac(u);
   }
d320 2
a321 2
wrap_linear_mirror_repeat(const float s[4], unsigned size,
                          int icoord0[4], int icoord1[4], float w[4])
d323 12
a334 15
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      const int flr = util_ifloor(s[ch]);
      float u = frac(s[ch]);
      if (flr & 1)
         u = 1.0F - u;
      u = u * size - 0.5F;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      if (icoord0[ch] < 0)
         icoord0[ch] = 0;
      if (icoord1[ch] >= (int) size)
         icoord1[ch] = size - 1;
      w[ch] = frac(u);
   }
d339 2
a340 2
wrap_linear_mirror_clamp(const float s[4], unsigned size,
                         int icoord0[4], int icoord1[4], float w[4])
d342 9
a350 12
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = fabsf(s[ch]);
      if (u >= 1.0F)
         u = (float) size;
      else
         u *= size;
      u -= 0.5F;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      w[ch] = frac(u);
   }
d355 2
a356 2
wrap_linear_mirror_clamp_to_edge(const float s[4], unsigned size,
                                 int icoord0[4], int icoord1[4], float w[4])
d358 13
a370 16
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = fabsf(s[ch]);
      if (u >= 1.0F)
         u = (float) size;
      else
         u *= size;
      u -= 0.5F;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      if (icoord0[ch] < 0)
         icoord0[ch] = 0;
      if (icoord1[ch] >= (int) size)
         icoord1[ch] = size - 1;
      w[ch] = frac(u);
   }
d375 2
a376 2
wrap_linear_mirror_clamp_to_border(const float s[4], unsigned size,
                                   int icoord0[4], int icoord1[4], float w[4])
d380 11
a390 14
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = fabsf(s[ch]);
      if (u <= min)
         u = min * size;
      else if (u >= max)
         u = max * size;
      else
         u *= size;
      u -= 0.5F;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      w[ch] = frac(u);
   }
d398 1
a398 1
wrap_nearest_unorm_clamp(const float s[4], unsigned size, int icoord[4])
d400 2
a401 5
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      int i = util_ifloor(s[ch]);
      icoord[ch]= CLAMP(i, 0, (int) size-1);
   }
d409 1
a409 2
wrap_nearest_unorm_clamp_to_border(const float s[4], unsigned size,
                                   int icoord[4])
d411 1
a411 4
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      icoord[ch]= util_ifloor( CLAMP(s[ch], -0.5F, (float) size + 0.5F) );
   }
d419 1
a419 2
wrap_nearest_unorm_clamp_to_edge(const float s[4], unsigned size,
                                 int icoord[4])
d421 1
a421 4
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      icoord[ch]= util_ifloor( CLAMP(s[ch], 0.5F, (float) size - 0.5F) );
   }
d429 2
a430 2
wrap_linear_unorm_clamp(const float s[4], unsigned size,
                        int icoord0[4], int icoord1[4], float w[4])
d432 5
a436 8
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      /* Not exactly what the spec says, but it matches NVIDIA output */
      float u = CLAMP(s[ch] - 0.5F, 0.0f, (float) size - 1.0f);
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      w[ch] = frac(u);
   }
d444 2
a445 2
wrap_linear_unorm_clamp_to_border(const float s[4], unsigned size,
                                  int icoord0[4], int icoord1[4], float w[4])
d447 7
a453 10
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = CLAMP(s[ch], -0.5F, (float) size + 0.5F);
      u -= 0.5F;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      if (icoord1[ch] > (int) size - 1)
         icoord1[ch] = size - 1;
      w[ch] = frac(u);
   }
d461 2
a462 2
wrap_linear_unorm_clamp_to_edge(const float s[4], unsigned size,
                                int icoord0[4], int icoord1[4], float w[4])
d464 7
a470 10
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      float u = CLAMP(s[ch], +0.5F, (float) size - 0.5F);
      u -= 0.5F;
      icoord0[ch] = util_ifloor(u);
      icoord1[ch] = icoord0[ch] + 1;
      if (icoord1[ch] > (int) size - 1)
         icoord1[ch] = size - 1;
      w[ch] = frac(u);
   }
d478 1
a478 1
wrap_array_layer(const float coord[4], unsigned size, int layer[4])
d480 2
a481 5
   uint ch;
   for (ch = 0; ch < 4; ch++) {
      int c = util_ifloor(coord[ch] + 0.5F);
      layer[ch] = CLAMP(c, 0, size - 1);
   }
d490 4
a493 4
compute_lambda_1d(const struct sp_sampler_variant *samp,
                  const float s[QUAD_SIZE],
                  const float t[QUAD_SIZE],
                  const float p[QUAD_SIZE])
d495 1
a495 1
   const struct pipe_resource *texture = samp->view->texture;
d498 1
a498 1
   float rho = MAX2(dsdx, dsdy) * u_minify(texture->width0, samp->view->u.tex.first_level);
d505 4
a508 4
compute_lambda_2d(const struct sp_sampler_variant *samp,
                  const float s[QUAD_SIZE],
                  const float t[QUAD_SIZE],
                  const float p[QUAD_SIZE])
d510 1
a510 1
   const struct pipe_resource *texture = samp->view->texture;
d515 2
a516 2
   float maxx = MAX2(dsdx, dsdy) * u_minify(texture->width0, samp->view->u.tex.first_level);
   float maxy = MAX2(dtdx, dtdy) * u_minify(texture->height0, samp->view->u.tex.first_level);
d524 4
a527 4
compute_lambda_3d(const struct sp_sampler_variant *samp,
                  const float s[QUAD_SIZE],
                  const float t[QUAD_SIZE],
                  const float p[QUAD_SIZE])
d529 1
a529 1
   const struct pipe_resource *texture = samp->view->texture;
d536 3
a538 3
   float maxx = MAX2(dsdx, dsdy) * u_minify(texture->width0, samp->view->u.tex.first_level);
   float maxy = MAX2(dtdx, dtdy) * u_minify(texture->height0, samp->view->u.tex.first_level);
   float maxz = MAX2(dpdx, dpdy) * u_minify(texture->depth0, samp->view->u.tex.first_level);
d553 4
a556 4
compute_lambda_vert(const struct sp_sampler_variant *samp,
                    const float s[QUAD_SIZE],
                    const float t[QUAD_SIZE],
                    const float p[QUAD_SIZE])
d572 1
a572 1
 * sp_get_cached_tile_tex() function.  Also, get 4 texels instead of 1...
d579 2
a580 2
get_texel_2d_no_border(const struct sp_sampler_variant *samp,
		       union tex_tile_address addr, int x, int y)
d583 4
d588 1
a588 6
   addr.bits.x = x / TILE_SIZE;
   addr.bits.y = y / TILE_SIZE;
   y %= TILE_SIZE;
   x %= TILE_SIZE;

   tile = sp_get_cached_tile_tex(samp->cache, addr);
d595 3
a597 2
get_texel_2d(const struct sp_sampler_variant *samp,
	     union tex_tile_address addr, int x, int y)
d599 1
a599 1
   const struct pipe_resource *texture = samp->view->texture;
d604 1
a604 1
      return samp->sampler->border_color;
d607 1
a607 1
      return get_texel_2d_no_border( samp, addr, x, y );
d611 103
d718 11
a728 11
get_texel_quad_2d_no_border_single_tile(const struct sp_sampler_variant *samp,
					union tex_tile_address addr, 
					unsigned x, unsigned y, 
					const float *out[4])
{
   const struct softpipe_tex_cached_tile *tile;

   addr.bits.x = x / TILE_SIZE;
   addr.bits.y = y / TILE_SIZE;
   y %= TILE_SIZE;
   x %= TILE_SIZE;
d730 1
a730 1
   tile = sp_get_cached_tile_tex(samp->cache, addr);
d742 10
a751 10
get_texel_quad_2d_no_border(const struct sp_sampler_variant *samp,
			    union tex_tile_address addr,
			    int x0, int y0, 
			    int x1, int y1,
			    const float *out[4])
{
   out[0] = get_texel_2d_no_border( samp, addr, x0, y0 );
   out[1] = get_texel_2d_no_border( samp, addr, x1, y0 );
   out[2] = get_texel_2d_no_border( samp, addr, x0, y1 );
   out[3] = get_texel_2d_no_border( samp, addr, x1, y1 );
d757 11
a767 10
get_texel_quad_2d(const struct sp_sampler_variant *samp,
		  union tex_tile_address addr,
		  int x0, int y0, 
		  int x1, int y1,
		  const float *out[4])
{
   out[0] = get_texel_2d( samp, addr, x0, y0 );
   out[1] = get_texel_2d( samp, addr, x1, y0 );
   out[3] = get_texel_2d( samp, addr, x1, y1 );
   out[2] = get_texel_2d( samp, addr, x0, y1 );
d775 1
a775 1
get_texel_3d_no_border(const struct sp_sampler_variant *samp,
d780 2
a781 2
   addr.bits.x = x / TILE_SIZE;
   addr.bits.y = y / TILE_SIZE;
d783 2
a784 2
   y %= TILE_SIZE;
   x %= TILE_SIZE;
d786 1
a786 1
   tile = sp_get_cached_tile_tex(samp->cache, addr);
d793 3
a795 2
get_texel_3d(const struct sp_sampler_variant *samp,
	     union tex_tile_address addr, int x, int y, int z)
d797 1
a797 1
   const struct pipe_resource *texture = samp->view->texture;
d803 1
a803 1
      return samp->sampler->border_color;
d806 1
a806 1
      return get_texel_3d_no_border( samp, addr, x, y, z );
d813 2
a814 1
get_texel_1d_array(const struct sp_sampler_variant *samp,
d817 1
a817 1
   const struct pipe_resource *texture = samp->view->texture;
d821 1
a821 1
      return samp->sampler->border_color;
d824 1
a824 1
      return get_texel_2d_no_border(samp, addr, x, y);
d831 2
a832 1
get_texel_2d_array(const struct sp_sampler_variant *samp,
d835 1
a835 1
   const struct pipe_resource *texture = samp->view->texture;
d838 2
a839 1
   assert(layer < texture->array_size);
d843 1
a843 1
      return samp->sampler->border_color;
d846 1
a846 1
      return get_texel_3d_no_border(samp, addr, x, y, layer);
d851 20
d886 10
a895 1
print_sample(const char *function, float rgba[NUM_CHANNELS][QUAD_SIZE])
d909 13
a921 15
img_filter_2d_linear_repeat_POT(struct tgsi_sampler *tgsi_sampler,
                                const float s[QUAD_SIZE],
                                const float t[QUAD_SIZE],
                                const float p[QUAD_SIZE],
                                const float c0[QUAD_SIZE],
                                enum tgsi_sampler_control control,
                                float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   unsigned  j;
   unsigned level = samp->level;
   unsigned xpot = pot_level_size(samp->xpot, level);
   unsigned ypot = pot_level_size(samp->ypot, level);
   unsigned xmax = (xpot - 1) & (TILE_SIZE - 1); /* MIN2(TILE_SIZE, xpot) - 1; */
   unsigned ymax = (ypot - 1) & (TILE_SIZE - 1); /* MIN2(TILE_SIZE, ypot) - 1; */
d923 1
d925 2
a926 5
   addr.value = 0;
   addr.bits.level = samp->level;

   for (j = 0; j < QUAD_SIZE; j++) {
      int c;
d928 2
a929 2
      float u = s[j] * xpot - 0.5F;
      float v = t[j] * ypot - 0.5F;
d931 2
a932 2
      int uflr = util_ifloor(u);
      int vflr = util_ifloor(v);
d934 2
a935 2
      float xw = u - (float)uflr;
      float yw = v - (float)vflr;
d937 4
a940 2
      int x0 = uflr & (xpot - 1);
      int y0 = vflr & (ypot - 1);
d942 10
a951 12
      const float *tx[4];      
      
      /* Can we fetch all four at once:
       */
      if (x0 < xmax && y0 < ymax) {
         get_texel_quad_2d_no_border_single_tile(samp, addr, x0, y0, tx);
      }
      else {
         unsigned x1 = (x0 + 1) & (xpot - 1);
         unsigned y1 = (y0 + 1) & (ypot - 1);
         get_texel_quad_2d_no_border(samp, addr, x0, y0, x1, y1, tx);
      }
d953 5
a957 6
      /* interpolate R, G, B, A */
      for (c = 0; c < 4; c++) {
         rgba[c][j] = lerp_2d(xw, yw, 
                              tx[0][c], tx[1][c], 
                              tx[2][c], tx[3][c]);
      }
d967 12
a978 13
img_filter_2d_nearest_repeat_POT(struct tgsi_sampler *tgsi_sampler,
                                 const float s[QUAD_SIZE],
                                 const float t[QUAD_SIZE],
                                 const float p[QUAD_SIZE],
                                 const float c0[QUAD_SIZE],
                                 enum tgsi_sampler_control control,
                                 float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   unsigned  j;
   unsigned level = samp->level;
   unsigned xpot = pot_level_size(samp->xpot, level);
   unsigned ypot = pot_level_size(samp->ypot, level);
d980 1
d982 2
a983 2
   addr.value = 0;
   addr.bits.level = samp->level;
d985 2
a986 2
   for (j = 0; j < QUAD_SIZE; j++) {
      int c;
d988 2
a989 2
      float u = s[j] * xpot;
      float v = t[j] * ypot;
d991 2
a992 7
      int uflr = util_ifloor(u);
      int vflr = util_ifloor(v);

      int x0 = uflr & (xpot - 1);
      int y0 = vflr & (ypot - 1);

      const float *out = get_texel_2d_no_border(samp, addr, x0, y0);
d994 3
a996 4
      for (c = 0; c < 4; c++) {
         rgba[c][j] = out[c];
      }
   }
d1005 11
a1015 13
img_filter_2d_nearest_clamp_POT(struct tgsi_sampler *tgsi_sampler,
                                const float s[QUAD_SIZE],
                                const float t[QUAD_SIZE],
                                const float p[QUAD_SIZE],
                                const float c0[QUAD_SIZE],
                                enum tgsi_sampler_control control,
                                float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   unsigned  j;
   unsigned level = samp->level;
   unsigned xpot = pot_level_size(samp->xpot, level);
   unsigned ypot = pot_level_size(samp->ypot, level);
d1017 1
d1019 2
a1020 5
   addr.value = 0;
   addr.bits.level = samp->level;

   for (j = 0; j < QUAD_SIZE; j++) {
      int c;
d1022 2
a1023 2
      float u = s[j] * xpot;
      float v = t[j] * ypot;
d1025 2
a1026 16
      int x0, y0;
      const float *out;

      x0 = util_ifloor(u);
      if (x0 < 0) 
         x0 = 0;
      else if (x0 > xpot - 1)
         x0 = xpot - 1;

      y0 = util_ifloor(v);
      if (y0 < 0) 
         y0 = 0;
      else if (y0 > ypot - 1)
         y0 = ypot - 1;
      
      out = get_texel_2d_no_border(samp, addr, x0, y0);
d1028 15
a1042 4
      for (c = 0; c < 4; c++) {
         rgba[c][j] = out[c];
      }
   }
d1051 8
a1058 7
img_filter_1d_nearest(struct tgsi_sampler *tgsi_sampler,
                        const float s[QUAD_SIZE],
                        const float t[QUAD_SIZE],
                        const float p[QUAD_SIZE],
                        const float c0[QUAD_SIZE],
                        enum tgsi_sampler_control control,
                        float rgba[NUM_CHANNELS][QUAD_SIZE])
d1060 1
a1060 3
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1062 1
a1062 1
   int x[4];
d1064 2
d1067 1
a1067 2
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
d1072 1
a1072 1
   addr.bits.level = samp->level;
d1074 1
a1074 1
   samp->nearest_texcoord_s(s, width, x);
d1076 3
a1078 7
   for (j = 0; j < QUAD_SIZE; j++) {
      const float *out = get_texel_2d(samp, addr, x[j], 0);
      int c;
      for (c = 0; c < 4; c++) {
         rgba[c][j] = out[c];
      }
   }
d1087 10
a1096 11
img_filter_1d_array_nearest(struct tgsi_sampler *tgsi_sampler,
                            const float s[QUAD_SIZE],
                            const float t[QUAD_SIZE],
                            const float p[QUAD_SIZE],
                            const float c0[QUAD_SIZE],
                            enum tgsi_sampler_control control,
                            float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1098 1
a1098 1
   int x[4], layer[4];
d1100 2
d1103 1
a1103 2
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
d1108 1
a1108 1
   addr.bits.level = samp->level;
d1110 2
a1111 2
   samp->nearest_texcoord_s(s, width, x);
   wrap_array_layer(t, texture->array_size, layer);
d1113 3
a1115 7
   for (j = 0; j < QUAD_SIZE; j++) {
      const float *out = get_texel_1d_array(samp, addr, x[j], layer[j]);
      int c;
      for (c = 0; c < 4; c++) {
         rgba[c][j] = out[c];
      }
   }
d1124 10
a1133 11
img_filter_2d_nearest(struct tgsi_sampler *tgsi_sampler,
                      const float s[QUAD_SIZE],
                      const float t[QUAD_SIZE],
                      const float p[QUAD_SIZE],
                      const float c0[QUAD_SIZE],
                      enum tgsi_sampler_control control,
                      float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1135 1
a1135 1
   int x[4], y[4];
d1137 2
d1140 2
a1141 4

   level0 = samp->level;
   width = u_minify(texture->width0, level0);
   height = u_minify(texture->height0, level0);
d1147 1
a1147 1
   addr.bits.level = samp->level;
d1149 2
a1150 2
   samp->nearest_texcoord_s(s, width, x);
   samp->nearest_texcoord_t(t, height, y);
d1152 3
a1154 7
   for (j = 0; j < QUAD_SIZE; j++) {
      const float *out = get_texel_2d(samp, addr, x[j], y[j]);
      int c;
      for (c = 0; c < 4; c++) {
         rgba[c][j] = out[c];
      }
   }
d1163 10
a1172 11
img_filter_2d_array_nearest(struct tgsi_sampler *tgsi_sampler,
                            const float s[QUAD_SIZE],
                            const float t[QUAD_SIZE],
                            const float p[QUAD_SIZE],
                            const float c0[QUAD_SIZE],
                            enum tgsi_sampler_control control,
                            float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1174 1
a1174 1
   int x[4], y[4], layer[4];
d1176 2
d1179 2
a1180 3
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
   height = u_minify(texture->height0, level0);
d1186 1
a1186 1
   addr.bits.level = samp->level;
d1188 7
a1194 11
   samp->nearest_texcoord_s(s, width, x);
   samp->nearest_texcoord_t(t, height, y);
   wrap_array_layer(p, texture->array_size, layer);

   for (j = 0; j < QUAD_SIZE; j++) {
      const float *out = get_texel_2d_array(samp, addr, x[j], y[j], layer[j]);
      int c;
      for (c = 0; c < 4; c++) {
         rgba[c][j] = out[c];
      }
   }
d1211 8
a1218 7
img_filter_cube_nearest(struct tgsi_sampler *tgsi_sampler,
                        const float s[QUAD_SIZE],
                        const float t[QUAD_SIZE],
                        const float p[QUAD_SIZE],
                        const float c0[QUAD_SIZE],
                        enum tgsi_sampler_control control,
                        float rgba[NUM_CHANNELS][QUAD_SIZE])
d1220 1
a1220 4
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   const unsigned *faces = samp->faces; /* zero when not cube-mapping */
   unsigned level0, j;
d1222 1
a1222 1
   int x[4], y[4];
d1224 2
d1227 2
a1228 3
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
   height = u_minify(texture->height0, level0);
d1234 13
a1246 1
   addr.bits.level = samp->level;
d1248 3
a1250 2
   samp->nearest_texcoord_s(s, width, x);
   samp->nearest_texcoord_t(t, height, y);
d1252 2
a1253 6
   for (j = 0; j < QUAD_SIZE; j++) {
      const float *out = get_texel_2d(samp, face(addr, faces[j]), x[j], y[j]);
      int c;
      for (c = 0; c < 4; c++) {
         rgba[c][j] = out[c];
      }
d1255 35
a1295 1

d1297 10
a1306 11
img_filter_3d_nearest(struct tgsi_sampler *tgsi_sampler,
                      const float s[QUAD_SIZE],
                      const float t[QUAD_SIZE],
                      const float p[QUAD_SIZE],
                      const float c0[QUAD_SIZE],
                      enum tgsi_sampler_control control,
                      float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1308 1
a1308 1
   int x[4], y[4], z[4];
d1310 2
d1313 3
a1315 4
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
   height = u_minify(texture->height0, level0);
   depth = u_minify(texture->depth0, level0);
d1321 3
a1323 3
   samp->nearest_texcoord_s(s, width,  x);
   samp->nearest_texcoord_t(t, height, y);
   samp->nearest_texcoord_p(p, depth,  z);
d1326 1
a1326 1
   addr.bits.level = samp->level;
d1328 3
a1330 7
   for (j = 0; j < QUAD_SIZE; j++) {
      const float *out = get_texel_3d(samp, addr, x[j], y[j], z[j]);
      int c;
      for (c = 0; c < 4; c++) {
         rgba[c][j] = out[c];
      }      
   }
d1335 8
a1342 7
img_filter_1d_linear(struct tgsi_sampler *tgsi_sampler,
                     const float s[QUAD_SIZE],
                     const float t[QUAD_SIZE],
                     const float p[QUAD_SIZE],
                     const float c0[QUAD_SIZE],
                     enum tgsi_sampler_control control,
                     float rgba[NUM_CHANNELS][QUAD_SIZE])
d1344 1
a1344 3
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1346 2
a1347 2
   int x0[4], x1[4];
   float xw[4]; /* weights */
d1349 2
d1352 1
a1352 2
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
d1357 1
a1357 1
   addr.bits.level = samp->level;
d1359 1
a1359 1
   samp->linear_texcoord_s(s, width, x0, x1, xw);
d1361 2
a1362 4
   for (j = 0; j < QUAD_SIZE; j++) {
      const float *tx0 = get_texel_2d(samp, addr, x0[j], 0);
      const float *tx1 = get_texel_2d(samp, addr, x1[j], 0);
      int c;
d1364 3
a1366 5
      /* interpolate R, G, B, A */
      for (c = 0; c < 4; c++) {
         rgba[c][j] = lerp(xw[j], tx0[c], tx1[c]);
      }
   }
d1371 8
a1378 7
img_filter_1d_array_linear(struct tgsi_sampler *tgsi_sampler,
                           const float s[QUAD_SIZE],
                           const float t[QUAD_SIZE],
                           const float p[QUAD_SIZE],
                           const float c0[QUAD_SIZE],
                           enum tgsi_sampler_control control,
                           float rgba[NUM_CHANNELS][QUAD_SIZE])
d1380 1
a1380 3
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1382 2
a1383 2
   int x0[4], x1[4], layer[4];
   float xw[4]; /* weights */
d1385 2
d1388 1
a1388 2
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
d1393 1
a1393 1
   addr.bits.level = samp->level;
d1395 2
a1396 2
   samp->linear_texcoord_s(s, width, x0, x1, xw);
   wrap_array_layer(t, texture->array_size, layer);
d1398 2
a1399 4
   for (j = 0; j < QUAD_SIZE; j++) {
      const float *tx0 = get_texel_1d_array(samp, addr, x0[j], layer[j]);
      const float *tx1 = get_texel_1d_array(samp, addr, x1[j], layer[j]);
      int c;
d1401 3
a1403 5
      /* interpolate R, G, B, A */
      for (c = 0; c < 4; c++) {
         rgba[c][j] = lerp(xw[j], tx0[c], tx1[c]);
      }
   }
d1408 8
a1415 7
img_filter_2d_linear(struct tgsi_sampler *tgsi_sampler,
                     const float s[QUAD_SIZE],
                     const float t[QUAD_SIZE],
                     const float p[QUAD_SIZE],
                     const float c0[QUAD_SIZE],
                     enum tgsi_sampler_control control,
                     float rgba[NUM_CHANNELS][QUAD_SIZE])
d1417 1
a1417 3
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1419 2
a1420 2
   int x0[4], y0[4], x1[4], y1[4];
   float xw[4], yw[4]; /* weights */
d1422 2
d1425 2
a1426 3
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
   height = u_minify(texture->height0, level0);
d1432 1
a1432 1
   addr.bits.level = samp->level;
d1434 2
a1435 2
   samp->linear_texcoord_s(s, width,  x0, x1, xw);
   samp->linear_texcoord_t(t, height, y0, y1, yw);
d1437 4
a1440 6
   for (j = 0; j < QUAD_SIZE; j++) {
      const float *tx0 = get_texel_2d(samp, addr, x0[j], y0[j]);
      const float *tx1 = get_texel_2d(samp, addr, x1[j], y0[j]);
      const float *tx2 = get_texel_2d(samp, addr, x0[j], y1[j]);
      const float *tx3 = get_texel_2d(samp, addr, x1[j], y1[j]);
      int c;
d1442 5
a1446 7
      /* interpolate R, G, B, A */
      for (c = 0; c < 4; c++) {
         rgba[c][j] = lerp_2d(xw[j], yw[j],
                              tx0[c], tx1[c],
                              tx2[c], tx3[c]);
      }
   }
d1451 8
a1458 7
img_filter_2d_array_linear(struct tgsi_sampler *tgsi_sampler,
                           const float s[QUAD_SIZE],
                           const float t[QUAD_SIZE],
                           const float p[QUAD_SIZE],
                           const float c0[QUAD_SIZE],
                           enum tgsi_sampler_control control,
                           float rgba[NUM_CHANNELS][QUAD_SIZE])
d1460 1
a1460 3
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1462 2
a1463 2
   int x0[4], y0[4], x1[4], y1[4], layer[4];
   float xw[4], yw[4]; /* weights */
d1465 2
d1468 2
a1469 3
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
   height = u_minify(texture->height0, level0);
d1475 5
a1479 1
   addr.bits.level = samp->level;
d1481 4
a1484 10
   samp->linear_texcoord_s(s, width,  x0, x1, xw);
   samp->linear_texcoord_t(t, height, y0, y1, yw);
   wrap_array_layer(p, texture->array_size, layer);

   for (j = 0; j < QUAD_SIZE; j++) {
      const float *tx0 = get_texel_2d_array(samp, addr, x0[j], y0[j], layer[j]);
      const float *tx1 = get_texel_2d_array(samp, addr, x1[j], y0[j], layer[j]);
      const float *tx2 = get_texel_2d_array(samp, addr, x0[j], y1[j], layer[j]);
      const float *tx3 = get_texel_2d_array(samp, addr, x1[j], y1[j], layer[j]);
      int c;
d1486 5
a1490 7
      /* interpolate R, G, B, A */
      for (c = 0; c < 4; c++) {
         rgba[c][j] = lerp_2d(xw[j], yw[j],
                              tx0[c], tx1[c],
                              tx2[c], tx3[c]);
      }
   }
d1495 8
a1502 7
img_filter_cube_linear(struct tgsi_sampler *tgsi_sampler,
                       const float s[QUAD_SIZE],
                       const float t[QUAD_SIZE],
                       const float p[QUAD_SIZE],
                       const float c0[QUAD_SIZE],
                       enum tgsi_sampler_control control,
                       float rgba[NUM_CHANNELS][QUAD_SIZE])
d1504 1
a1504 4
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   const unsigned *faces = samp->faces; /* zero when not cube-mapping */
   unsigned level0, j;
d1506 7
a1512 3
   int x0[4], y0[4], x1[4], y1[4];
   float xw[4], yw[4]; /* weights */
   union tex_tile_address addr;
d1514 2
a1515 3
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
   height = u_minify(texture->height0, level0);
d1521 1
a1521 1
   addr.bits.level = samp->level;
d1523 11
a1533 2
   samp->linear_texcoord_s(s, width,  x0, x1, xw);
   samp->linear_texcoord_t(t, height, y0, y1, yw);
d1535 1
a1535 7
   for (j = 0; j < QUAD_SIZE; j++) {
      union tex_tile_address addrj = face(addr, faces[j]);
      const float *tx0 = get_texel_2d(samp, addrj, x0[j], y0[j]);
      const float *tx1 = get_texel_2d(samp, addrj, x1[j], y0[j]);
      const float *tx2 = get_texel_2d(samp, addrj, x0[j], y1[j]);
      const float *tx3 = get_texel_2d(samp, addrj, x1[j], y1[j]);
      int c;
d1537 16
a1552 7
      /* interpolate R, G, B, A */
      for (c = 0; c < 4; c++) {
         rgba[c][j] = lerp_2d(xw[j], yw[j],
                              tx0[c], tx1[c],
                              tx2[c], tx3[c]);
      }
   }
d1557 51
a1607 7
img_filter_3d_linear(struct tgsi_sampler *tgsi_sampler,
                     const float s[QUAD_SIZE],
                     const float t[QUAD_SIZE],
                     const float p[QUAD_SIZE],
                     const float c0[QUAD_SIZE],
                     enum tgsi_sampler_control control,
                     float rgba[NUM_CHANNELS][QUAD_SIZE])
d1609 1
a1609 3
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   unsigned level0, j;
d1611 2
a1612 2
   int x0[4], x1[4], y0[4], y1[4], z0[4], z1[4];
   float xw[4], yw[4], zw[4]; /* interpolation weights */
d1614 2
d1617 3
a1619 4
   level0 = samp->level;
   width = u_minify(texture->width0, level0);
   height = u_minify(texture->height0, level0);
   depth = u_minify(texture->depth0, level0);
d1622 1
a1622 1
   addr.bits.level = level0;
d1628 9
a1636 11
   samp->linear_texcoord_s(s, width,  x0, x1, xw);
   samp->linear_texcoord_t(t, height, y0, y1, yw);
   samp->linear_texcoord_p(p, depth,  z0, z1, zw);

   for (j = 0; j < QUAD_SIZE; j++) {
      int c;

      const float *tx00 = get_texel_3d(samp, addr, x0[j], y0[j], z0[j]);
      const float *tx01 = get_texel_3d(samp, addr, x1[j], y0[j], z0[j]);
      const float *tx02 = get_texel_3d(samp, addr, x0[j], y1[j], z0[j]);
      const float *tx03 = get_texel_3d(samp, addr, x1[j], y1[j], z0[j]);
d1638 4
a1641 4
      const float *tx10 = get_texel_3d(samp, addr, x0[j], y0[j], z1[j]);
      const float *tx11 = get_texel_3d(samp, addr, x1[j], y0[j], z1[j]);
      const float *tx12 = get_texel_3d(samp, addr, x0[j], y1[j], z1[j]);
      const float *tx13 = get_texel_3d(samp, addr, x1[j], y1[j], z1[j]);
d1644 43
a1686 6
      for (c = 0; c < 4; c++) {
         rgba[c][j] = lerp_3d(xw[j], yw[j], zw[j],
                              tx00[c], tx01[c],
                              tx02[c], tx03[c],
                              tx10[c], tx11[c],
                              tx12[c], tx13[c]);
d1688 4
d1697 2
a1698 1
 * Note that lambda has already been biased by global LOD bias.
d1701 8
a1708 4
compute_lod(const struct pipe_sampler_state *sampler,
            const float biased_lambda,
            const float lodbias[QUAD_SIZE],
            float lod[QUAD_SIZE])
d1710 5
d1717 26
a1742 3
   for (i = 0; i < QUAD_SIZE; i++) {
      lod[i] = biased_lambda + lodbias[i];
      lod[i] = CLAMP(lod[i], sampler->min_lod, sampler->max_lod);
d1748 9
a1756 5
mip_filter_linear(struct tgsi_sampler *tgsi_sampler,
                  const float s[QUAD_SIZE],
                  const float t[QUAD_SIZE],
                  const float p[QUAD_SIZE],
                  const float c0[QUAD_SIZE],
d1758 1
a1758 1
                  float rgba[NUM_CHANNELS][QUAD_SIZE])
d1760 3
a1762 11
   struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   int level0;
   float lambda;
   float lod[QUAD_SIZE];

   if (control == tgsi_sampler_lod_bias) {
      lambda = samp->compute_lambda(samp, s, t, p) + samp->sampler->lod_bias;
      compute_lod(samp->sampler, lambda, c0, lod);
   } else {
      assert(control == tgsi_sampler_lod_explicit);
d1764 1
a1764 2
      memcpy(lod, c0, sizeof(lod));
   }
d1766 2
a1767 4
   /* XXX: Take into account all lod values.
    */
   lambda = lod[0];
   level0 = samp->view->u.tex.first_level + (int)lambda;
d1769 4
a1772 13
   if (lambda < 0.0) { 
      samp->level = samp->view->u.tex.first_level;
      samp->mag_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba);
   }
   else if (level0 >= texture->last_level) {
      samp->level = texture->last_level;
      samp->min_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba);
   }
   else {
      float levelBlend = frac(lambda);
      float rgba0[4][4];
      float rgba1[4][4];
      int c,j;
d1774 3
a1776 2
      samp->level = level0;
      samp->min_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba0);
d1778 9
a1786 2
      samp->level = level0+1;
      samp->min_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba1);
a1787 1
      for (j = 0; j < QUAD_SIZE; j++) {
d1789 1
a1789 1
            rgba[c][j] = lerp(levelBlend, rgba0[c][j], rgba1[c][j]);
d1795 1
a1795 1
      print_sample(__FUNCTION__, rgba);
d1806 9
a1814 5
mip_filter_nearest(struct tgsi_sampler *tgsi_sampler,
                   const float s[QUAD_SIZE],
                   const float t[QUAD_SIZE],
                   const float p[QUAD_SIZE],
                   const float c0[QUAD_SIZE],
d1816 1
a1816 1
                   float rgba[NUM_CHANNELS][QUAD_SIZE])
d1818 3
a1820 10
   struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   float lambda;
   float lod[QUAD_SIZE];

   if (control == tgsi_sampler_lod_bias) {
      lambda = samp->compute_lambda(samp, s, t, p) + samp->sampler->lod_bias;
      compute_lod(samp->sampler, lambda, c0, lod);
   } else {
      assert(control == tgsi_sampler_lod_explicit);
d1822 1
a1822 2
      memcpy(lod, c0, sizeof(lod));
   }
d1824 11
a1834 12
   /* XXX: Take into account all lod values.
    */
   lambda = lod[0];

   if (lambda < 0.0) { 
      samp->level = samp->view->u.tex.first_level;
      samp->mag_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba);
   }
   else {
      samp->level = samp->view->u.tex.first_level + (int)(lambda + 0.5) ;
      samp->level = MIN2(samp->level, (int)texture->last_level);
      samp->min_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba);
d1838 1
a1838 1
      print_sample(__FUNCTION__, rgba);
d1844 9
a1852 5
mip_filter_none(struct tgsi_sampler *tgsi_sampler,
                const float s[QUAD_SIZE],
                const float t[QUAD_SIZE],
                const float p[QUAD_SIZE],
                const float c0[QUAD_SIZE],
d1854 1
a1854 1
                float rgba[NUM_CHANNELS][QUAD_SIZE])
d1856 2
a1857 3
   struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   float lambda;
   float lod[QUAD_SIZE];
d1859 1
a1859 5
   if (control == tgsi_sampler_lod_bias) {
      lambda = samp->compute_lambda(samp, s, t, p) + samp->sampler->lod_bias;
      compute_lod(samp->sampler, lambda, c0, lod);
   } else {
      assert(control == tgsi_sampler_lod_explicit);
d1861 11
a1871 1
      memcpy(lod, c0, sizeof(lod));
d1873 1
a1874 3
   /* XXX: Take into account all lod values.
    */
   lambda = lod[0];
d1876 19
a1894 7
   samp->level = samp->view->u.tex.first_level;
   if (lambda < 0.0) { 
      samp->mag_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba);
   }
   else {
      samp->min_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba);
   }
d1911 1
a1911 1
      weightLut = (float *) malloc(WEIGHT_LUT_SIZE * sizeof(float));
d1926 1
a1926 1
 * Based on the Higher Quality Elliptical Weighted Avarage Filter
d1931 8
a1938 6
img_filter_2d_ewa(struct tgsi_sampler *tgsi_sampler,
                  const float s[QUAD_SIZE],
                  const float t[QUAD_SIZE],
                  const float p[QUAD_SIZE],
                  const float c0[QUAD_SIZE],
                  enum tgsi_sampler_control control,
d1941 1
a1941 1
                  float rgba[NUM_CHANNELS][QUAD_SIZE])
d1943 1
a1943 2
   const struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
d1945 3
a1947 2
   unsigned level0 = samp->level > 0 ? samp->level : 0;
   float scaling = 1.0 / (1 << level0);
d1962 1
a1962 1
   float F = A*C-B*B/4.0;
d1968 8
a1975 8
   float d = -B*B+4.0*C*A;
   float box_u = 2.0 / d * sqrt(d*C*F); /* box_u -> half of bbox with   */
   float box_v = 2.0 / d * sqrt(A*d*F); /* box_v -> half of bbox height */

   float rgba_temp[NUM_CHANNELS][QUAD_SIZE];
   float s_buffer[QUAD_SIZE];
   float t_buffer[QUAD_SIZE];
   float weight_buffer[QUAD_SIZE];
d1978 1
a1978 1
   float den;// = 0.0F;
d1980 1
a1980 1
   float U;// = u0 - tex_u;
d1996 2
a1997 2
    * using the s_buffer/t_buffer and weight_buffer. Only when the buffer is full,
    * then the pixel values are read from the image.
d2001 1
a2001 1
   for (j = 0; j < QUAD_SIZE; j++) {
d2006 2
a2007 2
      float tex_u=-0.5 + s[j] * texture->width0 * scaling;
      float tex_v=-0.5 + t[j] * texture->height0 * scaling;
d2009 4
a2012 4
      int u0 = floor(tex_u - box_u);
      int u1 = ceil (tex_u + box_u);
      int v0 = floor(tex_v - box_v);
      int v1 = ceil (tex_v + box_v);
d2025 3
a2027 1
            /* Note that the ellipse has been pre-scaled so F = WEIGHT_LUT_SIZE - 1 */
d2040 1
a2040 1
               if (buffer_next == QUAD_SIZE) {
d2042 1
a2042 1
                  int jj;
a2046 2
                  samp->min_img_filter(tgsi_sampler, s_buffer, t_buffer, p, NULL,
                                        tgsi_sampler_lod_bias, rgba_temp);
d2048 2
d2066 2
a2067 4
      /* if the tex coord buffer contains unread values, we will read them now.
       * Note that in most cases we have to read more pixel values than required,
       * however, as the img_filter_2d_nearest function(s) does not have a count
       * parameter, we need to read the whole quad and ignore the unused values
d2070 1
a2070 1
         int jj;
a2074 2
         samp->min_img_filter(tgsi_sampler, s_buffer, t_buffer, p, NULL,
                               tgsi_sampler_lod_bias, rgba_temp);
d2076 2
d2086 3
a2088 5
         /* Reaching this place would mean
          * that no pixels intersected the ellipse.
          * This should never happen because
          * the filter we use always
          * intersects at least one pixel.
d2096 2
a2097 1
         samp->min_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba_temp);
d2117 9
a2125 5
mip_filter_linear_aniso(struct tgsi_sampler *tgsi_sampler,
                        const float s[QUAD_SIZE],
                        const float t[QUAD_SIZE],
                        const float p[QUAD_SIZE],
                        const float c0[QUAD_SIZE],
d2127 1
a2127 1
                        float rgba[NUM_CHANNELS][QUAD_SIZE])
d2129 1
a2129 2
   struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
d2132 1
a2132 1
   float lod[QUAD_SIZE];
d2134 2
a2135 2
   float s_to_u = u_minify(texture->width0, samp->view->u.tex.first_level);
   float t_to_v = u_minify(texture->height0, samp->view->u.tex.first_level);
d2141 4
a2144 1
   if (control == tgsi_sampler_lod_bias) {
d2154 1
a2154 1
      const float maxEccentricity = samp->sampler->max_anisotropy * samp->sampler->max_anisotropy;
d2180 2
a2181 2
      lambda = 0.5 * util_fast_log2(Pmin2)  + samp->sampler->lod_bias;
      compute_lod(samp->sampler, lambda, c0, lod);
d2184 3
a2186 3
      assert(control == tgsi_sampler_lod_explicit);

      memcpy(lod, c0, sizeof(lod));
d2192 1
a2192 1
   level0 = samp->view->u.tex.first_level + (int)lambda;
d2197 5
a2201 3
   if (level0 >= texture->last_level) {
      samp->level = texture->last_level;
      samp->min_img_filter(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba);
d2207 2
a2208 2
      samp->level = level0;
      img_filter_2d_ewa(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias,
d2213 1
a2213 1
      print_sample(__FUNCTION__, rgba);
a2217 1

d2224 9
a2232 5
   struct tgsi_sampler *tgsi_sampler,
   const float s[QUAD_SIZE],
   const float t[QUAD_SIZE],
   const float p[QUAD_SIZE],
   const float c0[QUAD_SIZE],
d2234 1
a2234 1
   float rgba[NUM_CHANNELS][QUAD_SIZE])
d2236 5
a2240 5
   struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_resource *texture = samp->view->texture;
   int level0;
   float lambda;
   float lod[QUAD_SIZE];
d2242 2
a2243 5
   if (control == tgsi_sampler_lod_bias) {
      lambda = samp->compute_lambda(samp, s, t, p) + samp->sampler->lod_bias;
      compute_lod(samp->sampler, lambda, c0, lod);
   } else {
      assert(control == tgsi_sampler_lod_explicit);
d2245 11
a2255 2
      memcpy(lod, c0, sizeof(lod));
   }
d2257 10
a2266 20
   /* XXX: Take into account all lod values.
    */
   lambda = lod[0];
   level0 = samp->view->u.tex.first_level + (int)lambda;

   /* Catches both negative and large values of level0:
    */
   if ((unsigned)level0 >= texture->last_level) { 
      if (level0 < 0)
         samp->level = samp->view->u.tex.first_level;
      else
         samp->level = texture->last_level;

      img_filter_2d_linear_repeat_POT(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba);
   }
   else {
      float levelBlend = frac(lambda);
      float rgba0[4][4];
      float rgba1[4][4];
      int c,j;
d2268 2
a2269 10
      samp->level = level0;
      img_filter_2d_linear_repeat_POT(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba0);

      samp->level = level0+1;
      img_filter_2d_linear_repeat_POT(tgsi_sampler, s, t, p, NULL, tgsi_sampler_lod_bias, rgba1);

      for (j = 0; j < QUAD_SIZE; j++) {
         for (c = 0; c < 4; c++) {
            rgba[c][j] = lerp(levelBlend, rgba0[c][j], rgba1[c][j]);
         }
d2274 1
a2274 1
      print_sample(__FUNCTION__, rgba);
a2278 1

d2283 7
a2289 5
sample_compare(struct tgsi_sampler *tgsi_sampler,
               const float s[QUAD_SIZE],
               const float t[QUAD_SIZE],
               const float p[QUAD_SIZE],
               const float c0[QUAD_SIZE],
d2291 1
a2291 1
               float rgba[NUM_CHANNELS][QUAD_SIZE])
d2293 1
a2293 2
   struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   const struct pipe_sampler_state *sampler = samp->sampler;
a2297 2
   samp->mip_filter(tgsi_sampler, s, t, p, c0, control, rgba);

d2300 1
d2305 17
a2321 5
   pc0 = CLAMP(p[0], 0.0F, 1.0F);
   pc1 = CLAMP(p[1], 0.0F, 1.0F);
   pc2 = CLAMP(p[2], 0.0F, 1.0F);
   pc3 = CLAMP(p[3], 0.0F, 1.0F);

d2372 9
a2380 39
   /* convert four pass/fail values to an intensity in [0,1] */
   val = 0.25F * (k0 + k1 + k2 + k3);

   /* XXX returning result for default GL_DEPTH_TEXTURE_MODE = GL_LUMINANCE */
   for (j = 0; j < 4; j++) {
      rgba[0][j] = rgba[1][j] = rgba[2][j] = val;
      rgba[3][j] = 1.0F;
   }
}


/**
 * Use 3D texcoords to choose a cube face, then sample the 2D cube faces.
 * Put face info into the sampler faces[] array.
 */
static void
sample_cube(struct tgsi_sampler *tgsi_sampler,
            const float s[QUAD_SIZE],
            const float t[QUAD_SIZE],
            const float p[QUAD_SIZE],
            const float c0[QUAD_SIZE],
            enum tgsi_sampler_control control,
            float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   unsigned j;
   float ssss[4], tttt[4];

   /*
     major axis
     direction    target                             sc     tc    ma
     ----------   -------------------------------    ---    ---   ---
     +rx          TEXTURE_CUBE_MAP_POSITIVE_X_EXT    -rz    -ry   rx
     -rx          TEXTURE_CUBE_MAP_NEGATIVE_X_EXT    +rz    -ry   rx
     +ry          TEXTURE_CUBE_MAP_POSITIVE_Y_EXT    +rx    +rz   ry
     -ry          TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT    +rx    -rz   ry
     +rz          TEXTURE_CUBE_MAP_POSITIVE_Z_EXT    +rx    -ry   rz
     -rz          TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT    -rx    -ry   rz
   */
d2382 4
a2385 28
   /* Choose the cube face and compute new s/t coords for the 2D face.
    *
    * Use the same cube face for all four pixels in the quad.
    *
    * This isn't ideal, but if we want to use a different cube face
    * per pixel in the quad, we'd have to also compute the per-face
    * LOD here too.  That's because the four post-face-selection
    * texcoords are no longer related to each other (they're
    * per-face!)  so we can't use subtraction to compute the partial
    * deriviates to compute the LOD.  Doing so (near cube edges
    * anyway) gives us pretty much random values.
    */
   {
      /* use the average of the four pixel's texcoords to choose the face */
      const float rx = 0.25 * (s[0] + s[1] + s[2] + s[3]);
      const float ry = 0.25 * (t[0] + t[1] + t[2] + t[3]);
      const float rz = 0.25 * (p[0] + p[1] + p[2] + p[3]);
      const float arx = fabsf(rx), ary = fabsf(ry), arz = fabsf(rz);

      if (arx >= ary && arx >= arz) {
         float sign = (rx >= 0.0F) ? 1.0F : -1.0F;
         uint face = (rx >= 0.0F) ? PIPE_TEX_FACE_POS_X : PIPE_TEX_FACE_NEG_X;
         for (j = 0; j < QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(s[j]);
            ssss[j] = sign *  p[j] * ima + 0.5F;
            tttt[j] =         t[j] * ima + 0.5F;
            samp->faces[j] = face;
         }
d2387 6
a2392 19
      else if (ary >= arx && ary >= arz) {
         float sign = (ry >= 0.0F) ? 1.0F : -1.0F;
         uint face = (ry >= 0.0F) ? PIPE_TEX_FACE_POS_Y : PIPE_TEX_FACE_NEG_Y;
         for (j = 0; j < QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(t[j]);
            ssss[j] =        -s[j] * ima + 0.5F;
            tttt[j] = sign * -p[j] * ima + 0.5F;
            samp->faces[j] = face;
         }
      }
      else {
         float sign = (rz >= 0.0F) ? 1.0F : -1.0F;
         uint face = (rz >= 0.0F) ? PIPE_TEX_FACE_POS_Z : PIPE_TEX_FACE_NEG_Z;
         for (j = 0; j < QUAD_SIZE; j++) {
            const float ima = -0.5 / fabsf(p[j]);
            ssss[j] = sign * -s[j] * ima + 0.5F;
            tttt[j] =         t[j] * ima + 0.5F;
            samp->faces[j] = face;
         }
a2394 6

   /* In our little pipeline, the compare stage is next.  If compare
    * is not active, this will point somewhere deeper into the
    * pipeline, eg. to mip_filter or even img_filter.
    */
   samp->compare(tgsi_sampler, ssss, tttt, NULL, c0, control, rgba);
d2399 3
a2401 7
sample_swizzle(struct tgsi_sampler *tgsi_sampler,
               const float s[QUAD_SIZE],
               const float t[QUAD_SIZE],
               const float p[QUAD_SIZE],
               const float c0[QUAD_SIZE],
               enum tgsi_sampler_control control,
               float rgba[NUM_CHANNELS][QUAD_SIZE])
d2403 5
a2407 9
   struct sp_sampler_variant *samp = sp_sampler_variant(tgsi_sampler);
   float rgba_temp[NUM_CHANNELS][QUAD_SIZE];
   const unsigned swizzle_r = samp->key.bits.swizzle_r;
   const unsigned swizzle_g = samp->key.bits.swizzle_g;
   const unsigned swizzle_b = samp->key.bits.swizzle_b;
   const unsigned swizzle_a = samp->key.bits.swizzle_a;
   unsigned j;

   samp->sample_target(tgsi_sampler, s, t, p, c0, control, rgba_temp);
d2412 1
a2412 1
         rgba[0][j] = 0.0f;
d2416 1
a2416 1
         rgba[0][j] = 1.0f;
d2421 1
a2421 1
         rgba[0][j] = rgba_temp[swizzle_r][j];
d2427 1
a2427 1
         rgba[1][j] = 0.0f;
d2431 1
a2431 1
         rgba[1][j] = 1.0f;
d2436 1
a2436 1
         rgba[1][j] = rgba_temp[swizzle_g][j];
d2442 1
a2442 1
         rgba[2][j] = 0.0f;
d2446 1
a2446 1
         rgba[2][j] = 1.0f;
d2451 1
a2451 1
         rgba[2][j] = rgba_temp[swizzle_b][j];
d2457 1
a2457 1
         rgba[3][j] = 0.0f;
d2461 1
a2461 1
         rgba[3][j] = 1.0f;
d2466 1
a2466 1
         rgba[3][j] = rgba_temp[swizzle_a][j];
d2559 5
a2563 2
static compute_lambda_func
get_lambda_func(const union sp_sampler_key key)
d2565 4
a2568 18
   if (key.bits.processor == TGSI_PROCESSOR_VERTEX)
      return compute_lambda_vert;
   
   switch (key.bits.target) {
   case PIPE_TEXTURE_1D:
   case PIPE_TEXTURE_1D_ARRAY:
      return compute_lambda_1d;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_2D_ARRAY:
   case PIPE_TEXTURE_RECT:
   case PIPE_TEXTURE_CUBE:
      return compute_lambda_2d;
   case PIPE_TEXTURE_3D:
      return compute_lambda_3d;
   default:
      assert(0);
      return compute_lambda_1d;
   }
d2572 4
a2575 4
static filter_func
get_img_filter(const union sp_sampler_key key,
               unsigned filter,
               const struct pipe_sampler_state *sampler)
d2577 2
a2578 1
   switch (key.bits.target) {
d2595 1
a2595 1
      if (key.bits.is_pot &&
d2638 6
d2657 45
d2703 2
a2704 1
 * Bind the given texture object and texture cache to the sampler variant.
d2706 10
a2715 4
void
sp_sampler_variant_bind_view( struct sp_sampler_variant *samp,
                              struct softpipe_tex_tile_cache *tex_cache,
                              const struct pipe_sampler_view *view )
d2717 74
a2790 1
   const struct pipe_resource *texture = view->texture;
d2792 1
a2792 5
   samp->view = view;
   samp->cache = tex_cache;
   samp->xpot = util_logbase2( texture->width0 );
   samp->ypot = util_logbase2( texture->height0 );
   samp->level = view->u.tex.first_level;
d2796 3
a2798 2
void
sp_sampler_variant_destroy( struct sp_sampler_variant *samp )
d2800 39
a2838 1
   FREE(samp);
a2840 1

d2842 4
a2845 1
 * Create a sampler variant for a given set of non-orthogonal state.
d2847 94
a2940 3
struct sp_sampler_variant *
sp_create_sampler_variant( const struct pipe_sampler_state *sampler,
                           const union sp_sampler_key key )
d2942 1
a2942 3
   struct sp_sampler_variant *samp = CALLOC_STRUCT(sp_sampler_variant);
   if (!samp)
      return NULL;
d2944 1
a2944 2
   samp->sampler = sampler;
   samp->key = key;
d2954 1
a2954 1
      
d2963 1
a2963 1
      
a2967 2
   
   samp->compute_lambda = get_lambda_func( key );
d2969 1
a2969 2
   samp->min_img_filter = get_img_filter(key, sampler->min_img_filter, sampler);
   samp->mag_img_filter = get_img_filter(key, sampler->mag_img_filter, sampler);
d2973 2
a2974 2
      if (sampler->min_img_filter == sampler->mag_img_filter) 
         samp->mip_filter = samp->min_img_filter;         
d2984 1
a2984 2
      if (key.bits.is_pot &&
          sampler->min_img_filter == sampler->mag_img_filter &&
d2988 3
a2990 2
          sampler->min_img_filter == PIPE_TEX_FILTER_LINEAR) {
         samp->mip_filter = mip_filter_linear_2d_linear_repeat_POT;
d2992 2
a2993 4
      else {
         samp->mip_filter = mip_filter_linear;
      }
      
d2996 13
a3008 13
      	samp->mip_filter = mip_filter_linear_aniso;
      	
      	/* Override min_img_filter: 
      	 * min_img_filter needs to be set to NEAREST since we need to access
      	 * each texture pixel as it is and weight it later; using linear
      	 * filters will have incorrect results.
      	 * By setting the filter to NEAREST here, we can avoid calling the
      	 * generic img_filter_2d_nearest in the anisotropic filter function,
      	 * making it possible to use one of the accelerated implementations 
      	 */
      	samp->min_img_filter = get_img_filter(key, PIPE_TEX_FILTER_NEAREST, sampler);
      	
      	/* on first access create the lookup table containing the filter weights. */
a3012 1
      
d3015 3
d3019 26
a3044 2
   if (sampler->compare_mode != PIPE_TEX_COMPARE_NONE) {
      samp->compare = sample_compare;
d3046 35
a3080 5
   else {
      /* Skip compare operation by promoting the mip_filter function
       * pointer:
       */
      samp->compare = samp->mip_filter;
a3081 9
   
   if (key.bits.target == PIPE_TEXTURE_CUBE) {
      samp->sample_target = sample_cube;
   }
   else {
      samp->faces[0] = 0;
      samp->faces[1] = 0;
      samp->faces[2] = 0;
      samp->faces[3] = 0;
d3083 67
a3149 5
      /* Skip cube face determination by promoting the compare
       * function pointer:
       */
      samp->sample_target = samp->compare;
   }
d3151 3
a3153 9
   if (key.bits.swizzle_r != PIPE_SWIZZLE_RED ||
       key.bits.swizzle_g != PIPE_SWIZZLE_GREEN ||
       key.bits.swizzle_b != PIPE_SWIZZLE_BLUE ||
       key.bits.swizzle_a != PIPE_SWIZZLE_ALPHA) {
      samp->base.get_samples = sample_swizzle;
   }
   else {
      samp->base.get_samples = samp->sample_target;
   }
d3157 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d542 13
d561 1
a561 1
compute_lambda_1d(const struct sp_sampler_varient *samp,
d566 1
a566 1
   const struct pipe_resource *texture = samp->texture;
d569 1
a569 1
   float rho = MAX2(dsdx, dsdy) * texture->width0;
d576 1
a576 1
compute_lambda_2d(const struct sp_sampler_varient *samp,
d581 1
a581 1
   const struct pipe_resource *texture = samp->texture;
d586 2
a587 2
   float maxx = MAX2(dsdx, dsdy) * texture->width0;
   float maxy = MAX2(dtdx, dtdy) * texture->height0;
d595 1
a595 1
compute_lambda_3d(const struct sp_sampler_varient *samp,
d600 1
a600 1
   const struct pipe_resource *texture = samp->texture;
d607 3
a609 3
   float maxx = MAX2(dsdx, dsdy) * texture->width0;
   float maxy = MAX2(dtdx, dtdy) * texture->height0;
   float maxz = MAX2(dpdx, dpdy) * texture->depth0;
d624 1
a624 1
compute_lambda_vert(const struct sp_sampler_varient *samp,
d650 1
a650 1
get_texel_2d_no_border(const struct sp_sampler_varient *samp,
d667 1
a667 1
get_texel_2d(const struct sp_sampler_varient *samp,
d670 1
a670 1
   const struct pipe_resource *texture = samp->texture;
d675 1
a675 2
      return sp_tex_tile_cache_border_color(samp->cache,
                                            samp->sampler->border_color);
d686 1
a686 1
get_texel_quad_2d_no_border_single_tile(const struct sp_sampler_varient *samp,
d710 1
a710 1
get_texel_quad_2d_no_border(const struct sp_sampler_varient *samp,
d725 1
a725 1
get_texel_quad_2d(const struct sp_sampler_varient *samp,
d739 1
a739 1
/* 3d varients:
d742 1
a742 1
get_texel_3d_no_border(const struct sp_sampler_varient *samp,
d760 1
a760 1
get_texel_3d(const struct sp_sampler_varient *samp,
d763 1
a763 1
   const struct pipe_resource *texture = samp->texture;
d769 1
a769 2
      return sp_tex_tile_cache_border_color(samp->cache,
                                            samp->sampler->border_color);
d777 37
d851 1
a851 1
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
d914 1
a914 1
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
d958 1
a958 1
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
d1011 2
a1012 2
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1043 41
d1092 2
a1093 2
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1127 44
d1188 2
a1189 2
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1232 2
a1233 2
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1274 2
a1275 2
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1306 41
d1355 2
a1356 2
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1394 48
d1450 2
a1451 2
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1499 2
a1500 2
   const struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1575 2
a1576 2
   struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1593 1
a1593 1
   level0 = (int)lambda;
d1596 1
a1596 1
      samp->level = 0;
d1604 1
a1604 1
      float levelBlend = lambda - level0;
d1642 2
a1643 2
   struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d1661 1
a1661 1
      samp->level = 0;
d1665 1
a1665 1
      samp->level = (int)(lambda + 0.5) ;
d1685 1
a1685 1
   struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
d1702 1
d1712 311
d2038 2
a2039 2
   struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
   const struct pipe_resource *texture = samp->texture;
d2056 1
a2056 1
   level0 = (int)lambda;
d2062 1
a2062 1
         samp->level = 0;
d2069 1
a2069 1
      float levelBlend = lambda - level0;
d2106 1
a2106 1
   struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
d2110 1
d2120 5
d2128 4
a2131 4
      k0 = p[0] < rgba[0][0];
      k1 = p[1] < rgba[0][1];
      k2 = p[2] < rgba[0][2];
      k3 = p[3] < rgba[0][3];
d2134 4
a2137 4
      k0 = p[0] <= rgba[0][0];
      k1 = p[1] <= rgba[0][1];
      k2 = p[2] <= rgba[0][2];
      k3 = p[3] <= rgba[0][3];
d2140 4
a2143 4
      k0 = p[0] > rgba[0][0];
      k1 = p[1] > rgba[0][1];
      k2 = p[2] > rgba[0][2];
      k3 = p[3] > rgba[0][3];
d2146 4
a2149 4
      k0 = p[0] >= rgba[0][0];
      k1 = p[1] >= rgba[0][1];
      k2 = p[2] >= rgba[0][2];
      k3 = p[3] >= rgba[0][3];
d2152 4
a2155 4
      k0 = p[0] == rgba[0][0];
      k1 = p[1] == rgba[0][1];
      k2 = p[2] == rgba[0][2];
      k3 = p[3] == rgba[0][3];
d2158 4
a2161 4
      k0 = p[0] != rgba[0][0];
      k1 = p[1] != rgba[0][1];
      k2 = p[2] != rgba[0][2];
      k3 = p[3] != rgba[0][3];
d2199 1
a2199 1
   struct sp_sampler_varient *samp = sp_sampler_varient(tgsi_sampler);
d2274 80
d2451 1
d2454 1
d2479 6
d2520 6
d2546 1
a2546 1
 * Bind the given texture object and texture cache to the sampler varient.
d2549 3
a2551 3
sp_sampler_varient_bind_texture( struct sp_sampler_varient *samp,
                                 struct softpipe_tex_tile_cache *tex_cache,
                                 const struct pipe_resource *texture )
d2553 1
a2553 1
   const struct pipe_sampler_state *sampler = samp->sampler;
d2555 1
a2555 1
   samp->texture = texture;
d2557 3
a2559 3
   samp->xpot = util_unsigned_logbase2( texture->width0 );
   samp->ypot = util_unsigned_logbase2( texture->height0 );
   samp->level = CLAMP((int) sampler->min_lod, 0, (int) texture->last_level);
d2564 1
a2564 1
sp_sampler_varient_destroy( struct sp_sampler_varient *samp )
d2571 1
a2571 1
 * Create a sampler varient for a given set of non-orthogonal state.
d2573 2
a2574 2
struct sp_sampler_varient *
sp_create_sampler_varient( const struct pipe_sampler_state *sampler,
d2577 1
a2577 1
   struct sp_sampler_varient *samp = CALLOC_STRUCT(sp_sampler_varient);
d2630 1
a2630 2
          sampler->min_img_filter == PIPE_TEX_FILTER_LINEAR)
      {
d2633 1
a2633 2
      else 
      {
d2636 21
d2671 1
a2671 1
      samp->base.get_samples = sample_cube;
d2682 11
a2692 1
      samp->base.get_samples = samp->compare;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d47 3
d77 1
a77 1
 * Do 2D/biliner interpolation of float values.
d111 3
a113 3
 * Note that if coord is a signed integer, coord % size doesn't give
 * the right value for coord < 0 (in terms of texture repeat).  Just
 * casting to unsigned fixes that.
d118 1
a118 1
   return (int) ((unsigned) coord % size);
d553 1
a553 1
   const struct pipe_texture *texture = samp->texture;
d568 1
a568 1
   const struct pipe_texture *texture = samp->texture;
d587 1
a587 1
   const struct pipe_texture *texture = samp->texture;
d657 1
a657 1
   const struct pipe_texture *texture = samp->texture;
d662 2
a663 1
      return samp->sampler->border_color;
d751 1
a751 1
   const struct pipe_texture *texture = samp->texture;
d757 2
a758 1
      return samp->sampler->border_color;
d780 12
d850 4
d894 4
d947 4
d964 1
a964 1
   const struct pipe_texture *texture = samp->texture;
d987 4
d1004 1
a1004 1
   const struct pipe_texture *texture = samp->texture;
d1031 4
d1056 1
a1056 1
   const struct pipe_texture *texture = samp->texture;
d1083 4
d1100 1
a1100 1
   const struct pipe_texture *texture = samp->texture;
d1142 1
a1142 1
   const struct pipe_texture *texture = samp->texture;
d1182 1
a1182 1
   const struct pipe_texture *texture = samp->texture;
d1229 1
a1229 1
   const struct pipe_texture *texture = samp->texture;
d1278 1
a1278 1
   const struct pipe_texture *texture = samp->texture;
d1354 1
a1354 1
   const struct pipe_texture *texture = samp->texture;
d1399 4
d1421 1
a1421 1
   const struct pipe_texture *texture = samp->texture;
d1448 3
a1450 7
#if 0
   printf("RGBA %g %g %g %g, %g %g %g %g, %g %g %g %g, %g %g %g %g\n",
          rgba[0][0], rgba[1][0], rgba[2][0], rgba[3][0],
          rgba[0][1], rgba[1][1], rgba[2][1], rgba[3][1],
          rgba[0][2], rgba[1][2], rgba[2][2], rgba[3][2],
          rgba[0][3], rgba[1][3], rgba[2][3], rgba[3][3]);
#endif
d1505 1
a1505 1
   const struct pipe_texture *texture = samp->texture;
d1552 4
a1661 1
   unsigned face;
d1675 2
a1676 1
   /* First choose the cube face.
d1695 7
a1701 5
         if (rx >= 0.0F) {
            face = PIPE_TEX_FACE_POS_X;
         }
         else {
            face = PIPE_TEX_FACE_NEG_X;
d1705 7
a1711 5
         if (ry >= 0.0F) {
            face = PIPE_TEX_FACE_POS_Y;
         }
         else {
            face = PIPE_TEX_FACE_NEG_Y;
d1715 7
a1721 2
         if (rz > 0.0F) {
            face = PIPE_TEX_FACE_POS_Z;
a1722 57
         else {
            face = PIPE_TEX_FACE_NEG_Z;
         }
      }
   }

   /* Now compute the 2D _face_ texture coords from the
    * 3D _cube_ texture coords.
    */
   for (j = 0; j < QUAD_SIZE; j++) {
      const float rx = s[j], ry = t[j], rz = p[j];
      const float arx = fabsf(rx), ary = fabsf(ry), arz = fabsf(rz);
      float sc, tc, ma;

      switch (face) {
      case PIPE_TEX_FACE_POS_X:
         sc = -rz;
         tc = -ry;
         ma = arx;
         break;
      case PIPE_TEX_FACE_NEG_X:
         sc = rz;
         tc = -ry;
         ma = arx;
         break;
      case PIPE_TEX_FACE_POS_Y:
         sc = rx;
         tc = rz;
         ma = ary;
         break;
      case PIPE_TEX_FACE_NEG_Y:
         sc = rx;
         tc = -rz;
         ma = ary;
         break;
      case PIPE_TEX_FACE_POS_Z:
         sc = rx;
         tc = -ry;
         ma = arz;
         break;
      case PIPE_TEX_FACE_NEG_Z:
         sc = -rx;
         tc = -ry;
         ma = arz;
         break;
      default:
         assert(0 && "bad cube face");
         sc = 0.0F;
         tc = 0.0F;
         ma = 0.0F;
      }

      {
	 const float ima = 1.0 / ma;
	 ssss[j] = ( sc * ima + 1.0F ) * 0.5F;
	 tttt[j] = ( tc * ima + 1.0F ) * 0.5F;
	 samp->faces[j] = face;
d1833 1
d1858 1
d1917 1
a1917 1
                                 const struct pipe_texture *texture )
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a46 3
/** Set to one to help debug texture sampling */
#define DEBUG_TEX 0

d74 1
a74 1
 * Do 2D/bilinear interpolation of float values.
d108 3
a110 3
 * Note that if coord is negative, coord % size doesn't give the right
 * value.  To avoid that problem we add a large multiple of the size
 * (rather than using a conditional).
d115 1
a115 1
   return (coord + size * 1024) % size;
d550 1
a550 1
   const struct pipe_resource *texture = samp->texture;
d565 1
a565 1
   const struct pipe_resource *texture = samp->texture;
d584 1
a584 1
   const struct pipe_resource *texture = samp->texture;
d654 1
a654 1
   const struct pipe_resource *texture = samp->texture;
d659 1
a659 2
      return sp_tex_tile_cache_border_color(samp->cache,
                                            samp->sampler->border_color);
d747 1
a747 1
   const struct pipe_resource *texture = samp->texture;
d753 1
a753 2
      return sp_tex_tile_cache_border_color(samp->cache,
                                            samp->sampler->border_color);
a774 12
static void
print_sample(const char *function, float rgba[NUM_CHANNELS][QUAD_SIZE])
{
   debug_printf("%s %g %g %g %g, %g %g %g %g, %g %g %g %g, %g %g %g %g\n",
                function,
                rgba[0][0], rgba[1][0], rgba[2][0], rgba[3][0],
                rgba[0][1], rgba[1][1], rgba[2][1], rgba[3][1],
                rgba[0][2], rgba[1][2], rgba[2][2], rgba[3][2],
                rgba[0][3], rgba[1][3], rgba[2][3], rgba[3][3]);
}


a832 4

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
a872 4

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
a921 4

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
d935 1
a935 1
   const struct pipe_resource *texture = samp->texture;
a957 4

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
d971 1
a971 1
   const struct pipe_resource *texture = samp->texture;
a997 4

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
d1019 1
a1019 1
   const struct pipe_resource *texture = samp->texture;
a1045 4

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
d1059 1
a1059 1
   const struct pipe_resource *texture = samp->texture;
d1101 1
a1101 1
   const struct pipe_resource *texture = samp->texture;
d1141 1
a1141 1
   const struct pipe_resource *texture = samp->texture;
d1188 1
a1188 1
   const struct pipe_resource *texture = samp->texture;
d1237 1
a1237 1
   const struct pipe_resource *texture = samp->texture;
d1313 1
a1313 1
   const struct pipe_resource *texture = samp->texture;
a1357 4

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
d1376 1
a1376 1
   const struct pipe_resource *texture = samp->texture;
d1403 7
a1409 3
   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
d1464 1
a1464 1
   const struct pipe_resource *texture = samp->texture;
a1510 4

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
d1617 1
d1631 1
a1631 2
   /* Choose the cube face and compute new s/t coords for the 2D face.
    *
d1650 5
a1654 7
         float sign = (rx >= 0.0F) ? 1.0F : -1.0F;
         uint face = (rx >= 0.0F) ? PIPE_TEX_FACE_POS_X : PIPE_TEX_FACE_NEG_X;
         for (j = 0; j < QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(s[j]);
            ssss[j] = sign *  p[j] * ima + 0.5F;
            tttt[j] =         t[j] * ima + 0.5F;
            samp->faces[j] = face;
d1658 5
a1662 7
         float sign = (ry >= 0.0F) ? 1.0F : -1.0F;
         uint face = (ry >= 0.0F) ? PIPE_TEX_FACE_POS_Y : PIPE_TEX_FACE_NEG_Y;
         for (j = 0; j < QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(t[j]);
            ssss[j] =        -s[j] * ima + 0.5F;
            tttt[j] = sign * -p[j] * ima + 0.5F;
            samp->faces[j] = face;
d1666 2
a1667 7
         float sign = (rz >= 0.0F) ? 1.0F : -1.0F;
         uint face = (rz >= 0.0F) ? PIPE_TEX_FACE_POS_Z : PIPE_TEX_FACE_NEG_Z;
         for (j = 0; j < QUAD_SIZE; j++) {
            const float ima = -0.5 / fabsf(p[j]);
            ssss[j] = sign * -s[j] * ima + 0.5F;
            tttt[j] =         t[j] * ima + 0.5F;
            samp->faces[j] = face;
d1669 57
a1835 1
   case PIPE_TEXTURE_RECT:
a1859 1
   case PIPE_TEXTURE_RECT:
d1918 1
a1918 1
                                 const struct pipe_resource *texture )
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a40 1
#include "util/u_format.h"
a41 1
#include "util/u_inlines.h"
a43 1
#include "sp_texture.h"
d129 1
d132 1
a132 1
wrap_nearest_repeat(float s, unsigned size, int *icoord)
d134 1
d137 4
a140 2
   int i = util_ifloor(s * size);
   *icoord = repeat(i, size);
d145 1
a145 1
wrap_nearest_clamp(float s, unsigned size, int *icoord)
d147 1
d150 8
a157 6
   if (s <= 0.0F)
      *icoord = 0;
   else if (s >= 1.0F)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(s * size);
d162 1
a162 1
wrap_nearest_clamp_to_edge(float s, unsigned size, int *icoord)
d164 1
d169 8
a176 6
   if (s < min)
      *icoord = 0;
   else if (s > max)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(s * size);
d181 1
a181 1
wrap_nearest_clamp_to_border(float s, unsigned size, int *icoord)
d183 1
d188 8
a195 6
   if (s <= min)
      *icoord = -1;
   else if (s >= max)
      *icoord = size;
   else
      *icoord = util_ifloor(s * size);
d200 1
a200 1
wrap_nearest_mirror_repeat(float s, unsigned size, int *icoord)
d202 1
d205 12
a216 10
   const int flr = util_ifloor(s);
   float u = frac(s);
   if (flr & 1)
      u = 1.0F - u;
   if (u < min)
      *icoord = 0;
   else if (u > max)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(u * size);
d221 1
a221 1
wrap_nearest_mirror_clamp(float s, unsigned size, int *icoord)
d223 12
a234 9
   /* s limited to [0,1] */
   /* i limited to [0,size-1] */
   const float u = fabsf(s);
   if (u <= 0.0F)
      *icoord = 0;
   else if (u >= 1.0F)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(u * size);
d239 2
a240 1
wrap_nearest_mirror_clamp_to_edge(float s, unsigned size, int *icoord)
d242 1
d247 9
a255 7
   const float u = fabsf(s);
   if (u < min)
      *icoord = 0;
   else if (u > max)
      *icoord = size - 1;
   else
      *icoord = util_ifloor(u * size);
d260 2
a261 1
wrap_nearest_mirror_clamp_to_border(float s, unsigned size, int *icoord)
d263 1
d268 9
a276 7
   const float u = fabsf(s);
   if (u < min)
      *icoord = -1;
   else if (u > max)
      *icoord = size;
   else
      *icoord = util_ifloor(u * size);
d281 1
a281 1
 * Used to compute texel locations for linear sampling
d283 1
a283 1
 * \param s  the texcoord
d285 4
a288 4
 * \param icoord0  returns first texture index
 * \param icoord1  returns second texture index (usually icoord0 + 1)
 * \param w  returns blend factor/weight between texture indices
 * \param icoord  returns the computed integer texture coord
d291 2
a292 2
wrap_linear_repeat(float s, unsigned size,
                   int *icoord0, int *icoord1, float *w)
d294 7
a300 4
   float u = s * size - 0.5F;
   *icoord0 = repeat(util_ifloor(u), size);
   *icoord1 = repeat(*icoord0 + 1, size);
   *w = frac(u);
d305 2
a306 2
wrap_linear_clamp(float s, unsigned size,
                  int *icoord0, int *icoord1, float *w)
d308 8
a315 5
   float u = CLAMP(s, 0.0F, 1.0F);
   u = u * size - 0.5f;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
d320 2
a321 2
wrap_linear_clamp_to_edge(float s, unsigned size,
                          int *icoord0, int *icoord1, float *w)
d323 12
a334 9
   float u = CLAMP(s, 0.0F, 1.0F);
   u = u * size - 0.5f;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord0 < 0)
      *icoord0 = 0;
   if (*icoord1 >= (int) size)
      *icoord1 = size - 1;
   *w = frac(u);
d339 2
a340 2
wrap_linear_clamp_to_border(float s, unsigned size,
                            int *icoord0, int *icoord1, float *w)
d344 8
a351 5
   float u = CLAMP(s, min, max);
   u = u * size - 0.5f;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
d356 2
a357 2
wrap_linear_mirror_repeat(float s, unsigned size,
                          int *icoord0, int *icoord1, float *w)
d359 15
a373 12
   const int flr = util_ifloor(s);
   float u = frac(s);
   if (flr & 1)
      u = 1.0F - u;
   u = u * size - 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord0 < 0)
      *icoord0 = 0;
   if (*icoord1 >= (int) size)
      *icoord1 = size - 1;
   *w = frac(u);
d378 2
a379 2
wrap_linear_mirror_clamp(float s, unsigned size,
                         int *icoord0, int *icoord1, float *w)
d381 12
a392 9
   float u = fabsf(s);
   if (u >= 1.0F)
      u = (float) size;
   else
      u *= size;
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
d397 2
a398 2
wrap_linear_mirror_clamp_to_edge(float s, unsigned size,
                                 int *icoord0, int *icoord1, float *w)
d400 16
a415 13
   float u = fabsf(s);
   if (u >= 1.0F)
      u = (float) size;
   else
      u *= size;
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord0 < 0)
      *icoord0 = 0;
   if (*icoord1 >= (int) size)
      *icoord1 = size - 1;
   *w = frac(u);
d420 2
a421 2
wrap_linear_mirror_clamp_to_border(float s, unsigned size,
                                   int *icoord0, int *icoord1, float *w)
d425 14
a438 11
   float u = fabsf(s);
   if (u <= min)
      u = min * size;
   else if (u >= max)
      u = max * size;
   else
      u *= size;
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
d446 1
a446 1
wrap_nearest_unorm_clamp(float s, unsigned size, int *icoord)
d448 5
a452 2
   int i = util_ifloor(s);
   *icoord = CLAMP(i, 0, (int) size-1);
d460 2
a461 1
wrap_nearest_unorm_clamp_to_border(float s, unsigned size, int *icoord)
d463 4
a466 1
   *icoord = util_ifloor( CLAMP(s, -0.5F, (float) size + 0.5F) );
d474 2
a475 1
wrap_nearest_unorm_clamp_to_edge(float s, unsigned size, int *icoord)
d477 4
a480 1
   *icoord = util_ifloor( CLAMP(s, 0.5F, (float) size - 0.5F) );
d488 2
a489 2
wrap_linear_unorm_clamp(float s, unsigned size,
                        int *icoord0, int *icoord1, float *w)
d491 8
a498 5
   /* Not exactly what the spec says, but it matches NVIDIA output */
   float u = CLAMP(s - 0.5F, 0.0f, (float) size - 1.0f);
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   *w = frac(u);
d506 2
a507 2
wrap_linear_unorm_clamp_to_border(float s, unsigned size,
                                  int *icoord0, int *icoord1, float *w)
d509 10
a518 7
   float u = CLAMP(s, -0.5F, (float) size + 0.5F);
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord1 > (int) size - 1)
      *icoord1 = size - 1;
   *w = frac(u);
d526 2
a527 2
wrap_linear_unorm_clamp_to_edge(float s, unsigned size,
                                int *icoord0, int *icoord1, float *w)
d529 10
a538 7
   float u = CLAMP(s, +0.5F, (float) size - 0.5F);
   u -= 0.5F;
   *icoord0 = util_ifloor(u);
   *icoord1 = *icoord0 + 1;
   if (*icoord1 > (int) size - 1)
      *icoord1 = size - 1;
   *w = frac(u);
a541 10
/**
 * Do coordinate to array index conversion.  For array textures.
 */
static INLINE void
wrap_array_layer(float coord, unsigned size, int *layer)
{
   int c = util_ifloor(coord + 0.5F);
   *layer = CLAMP(c, 0, (int) size - 1);
}

d548 4
a551 4
compute_lambda_1d(const struct sp_sampler_view *sview,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE])
d553 1
a553 1
   const struct pipe_resource *texture = sview->base.texture;
d556 1
a556 1
   float rho = MAX2(dsdx, dsdy) * u_minify(texture->width0, sview->base.u.tex.first_level);
d563 4
a566 4
compute_lambda_2d(const struct sp_sampler_view *sview,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE])
d568 1
a568 1
   const struct pipe_resource *texture = sview->base.texture;
d573 2
a574 2
   float maxx = MAX2(dsdx, dsdy) * u_minify(texture->width0, sview->base.u.tex.first_level);
   float maxy = MAX2(dtdx, dtdy) * u_minify(texture->height0, sview->base.u.tex.first_level);
d582 4
a585 4
compute_lambda_3d(const struct sp_sampler_view *sview,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE])
d587 1
a587 1
   const struct pipe_resource *texture = sview->base.texture;
d594 3
a596 3
   float maxx = MAX2(dsdx, dsdy) * u_minify(texture->width0, sview->base.u.tex.first_level);
   float maxy = MAX2(dtdx, dtdy) * u_minify(texture->height0, sview->base.u.tex.first_level);
   float maxz = MAX2(dpdx, dpdy) * u_minify(texture->depth0, sview->base.u.tex.first_level);
d611 4
a614 4
compute_lambda_vert(const struct sp_sampler_view *sview,
                    const float s[TGSI_QUAD_SIZE],
                    const float t[TGSI_QUAD_SIZE],
                    const float p[TGSI_QUAD_SIZE])
d630 1
a630 1
 * sp_get_cached_tile_tex() function.
d637 2
a638 2
get_texel_2d_no_border(const struct sp_sampler_view *sp_sview,
                       union tex_tile_address addr, int x, int y)
a640 4
   addr.bits.x = x / TEX_TILE_SIZE;
   addr.bits.y = y / TEX_TILE_SIZE;
   y %= TEX_TILE_SIZE;
   x %= TEX_TILE_SIZE;
d642 6
a647 1
   tile = sp_get_cached_tile_tex(sp_sview->cache, addr);
d654 2
a655 3
get_texel_2d(const struct sp_sampler_view *sp_sview,
             const struct sp_sampler *sp_samp,
             union tex_tile_address addr, int x, int y)
d657 1
a657 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d662 2
a663 1
      return sp_samp->base.border_color.f;
d666 1
a666 1
      return get_texel_2d_no_border( sp_sview, addr, x, y );
a669 103
/*
 * seamless cubemap neighbour array.
 * this array is used to find the adjacent face in each of 4 directions,
 * left, right, up, down. (or -x, +x, -y, +y).
 */
static const unsigned face_array[PIPE_TEX_FACE_MAX][4] = {
   /* pos X first then neg X is Z different, Y the same */
   /* PIPE_TEX_FACE_POS_X,*/
   { PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z,
     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },
   /* PIPE_TEX_FACE_NEG_X */
   { PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z,
     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },

   /* pos Y first then neg Y is X different, X the same */
   /* PIPE_TEX_FACE_POS_Y */
   { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
     PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z },

   /* PIPE_TEX_FACE_NEG_Y */
   { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
     PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z },

   /* pos Z first then neg Y is X different, X the same */
   /* PIPE_TEX_FACE_POS_Z */
   { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },

   /* PIPE_TEX_FACE_NEG_Z */
   { PIPE_TEX_FACE_POS_X, PIPE_TEX_FACE_NEG_X,
     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y }
};

static INLINE unsigned
get_next_face(unsigned face, int x, int y)
{
   int idx = 0;

   if (x == 0 && y == 0)
      return face;
   if (x == -1)
      idx = 0;
   else if (x == 1)
      idx = 1;
   else if (y == -1)
      idx = 2;
   else if (y == 1)
      idx = 3;

   return face_array[face][idx];
}

static INLINE const float *
get_texel_cube_seamless(const struct sp_sampler_view *sp_sview,
                        union tex_tile_address addr, int x, int y,
                        float *corner)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;
   unsigned face = addr.bits.face;
   int new_x, new_y;
   int max_x, max_y;
   int c;

   max_x = (int) u_minify(texture->width0, level);
   max_y = (int) u_minify(texture->height0, level);
   new_x = x;
   new_y = y;

   /* the corner case */
   if ((x < 0 || x >= max_x) &&
       (y < 0 || y >= max_y)) {
      const float *c1, *c2, *c3;
      int fx = x < 0 ? 0 : max_x - 1;
      int fy = y < 0 ? 0 : max_y - 1;
      c1 = get_texel_2d_no_border( sp_sview, addr, fx, fy);
      addr.bits.face = get_next_face(face, (x < 0) ? -1 : 1, 0);
      c2 = get_texel_2d_no_border( sp_sview, addr, (x < 0) ? max_x - 1 : 0, fy);
      addr.bits.face = get_next_face(face, 0, (y < 0) ? -1 : 1);
      c3 = get_texel_2d_no_border( sp_sview, addr, fx, (y < 0) ?  max_y - 1 : 0);
      for (c = 0; c < TGSI_QUAD_SIZE; c++)
         corner[c] = CLAMP((c1[c] + c2[c] + c3[c]), 0.0F, 1.0F) / 3;

      return corner;
   }
   /* change the face */
   if (x < 0) {
      new_x = max_x - 1;
      face = get_next_face(face, -1, 0);
   } else if (x >= max_x) {
      new_x = 0;
      face = get_next_face(face, 1, 0);
   } else if (y < 0) {
      new_y = max_y - 1;
      face = get_next_face(face, 0, -1);
   } else if (y >= max_y) {
      new_y = 0;
      face = get_next_face(face, 0, 1);
   }

   addr.bits.face = face;
   return get_texel_2d_no_border( sp_sview, addr, new_x, new_y );
}
d674 6
a679 11
get_texel_quad_2d_no_border_single_tile(const struct sp_sampler_view *sp_sview,
                                        union tex_tile_address addr,
                                        unsigned x, unsigned y,
                                        const float *out[4])
{
    const struct softpipe_tex_cached_tile *tile;

   addr.bits.x = x / TEX_TILE_SIZE;
   addr.bits.y = y / TEX_TILE_SIZE;
   y %= TEX_TILE_SIZE;
   x %= TEX_TILE_SIZE;
d681 6
a686 1
   tile = sp_get_cached_tile_tex(sp_sview->cache, addr);
d698 10
a707 10
get_texel_quad_2d_no_border(const struct sp_sampler_view *sp_sview,
                            union tex_tile_address addr,
                            int x0, int y0,
                            int x1, int y1,
                            const float *out[4])
{
   out[0] = get_texel_2d_no_border( sp_sview, addr, x0, y0 );
   out[1] = get_texel_2d_no_border( sp_sview, addr, x1, y0 );
   out[2] = get_texel_2d_no_border( sp_sview, addr, x0, y1 );
   out[3] = get_texel_2d_no_border( sp_sview, addr, x1, y1 );
d713 5
a717 6
get_texel_quad_2d(const struct sp_sampler_view *sp_sview,
                  const struct sp_sampler *sp_samp,
                  union tex_tile_address addr,
                  int x0, int y0,
                  int x1, int y1,
                  const float *out[4])
d719 4
a722 4
   out[0] = get_texel_2d( sp_sview, sp_samp, addr, x0, y0 );
   out[1] = get_texel_2d( sp_sview, sp_samp, addr, x1, y0 );
   out[3] = get_texel_2d( sp_sview, sp_samp, addr, x1, y1 );
   out[2] = get_texel_2d( sp_sview, sp_samp, addr, x0, y1 );
d727 1
a727 1
/* 3d variants:
d730 1
a730 1
get_texel_3d_no_border(const struct sp_sampler_view *sp_sview,
d735 2
a736 2
   addr.bits.x = x / TEX_TILE_SIZE;
   addr.bits.y = y / TEX_TILE_SIZE;
d738 2
a739 2
   y %= TEX_TILE_SIZE;
   x %= TEX_TILE_SIZE;
d741 1
a741 1
   tile = sp_get_cached_tile_tex(sp_sview->cache, addr);
d748 2
a749 3
get_texel_3d(const struct sp_sampler_view *sp_sview,
             const struct sp_sampler *sp_samp,
             union tex_tile_address addr, int x, int y, int z)
d751 1
a751 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d757 2
a758 41
      return sp_samp->base.border_color.f;
   }
   else {
      return get_texel_3d_no_border( sp_sview, addr, x, y, z );
   }
}


/* Get texel pointer for 1D array texture */
static INLINE const float *
get_texel_1d_array(const struct sp_sampler_view *sp_sview,
                   const struct sp_sampler *sp_samp,
                   union tex_tile_address addr, int x, int y)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;

   if (x < 0 || x >= (int) u_minify(texture->width0, level)) {
      return sp_samp->base.border_color.f;
   }
   else {
      return get_texel_2d_no_border(sp_sview, addr, x, y);
   }
}


/* Get texel pointer for 2D array texture */
static INLINE const float *
get_texel_2d_array(const struct sp_sampler_view *sp_sview,
                   const struct sp_sampler *sp_samp,
                   union tex_tile_address addr, int x, int y, int layer)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;

   assert(layer < (int) texture->array_size);
   assert(layer >= 0);

   if (x < 0 || x >= (int) u_minify(texture->width0, level) ||
       y < 0 || y >= (int) u_minify(texture->height0, level)) {
      return sp_samp->base.border_color.f;
d761 1
a761 1
      return get_texel_3d_no_border(sp_sview, addr, x, y, layer);
a765 20
/* Get texel pointer for cube array texture */
static INLINE const float *
get_texel_cube_array(const struct sp_sampler_view *sp_sview,
                     const struct sp_sampler *sp_samp,
                     union tex_tile_address addr, int x, int y, int layer)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   unsigned level = addr.bits.level;

   assert(layer < (int) texture->array_size);
   assert(layer >= 0);

   if (x < 0 || x >= (int) u_minify(texture->width0, level) ||
       y < 0 || y >= (int) u_minify(texture->height0, level)) {
      return sp_samp->base.border_color.f;
   }
   else {
      return get_texel_3d_no_border(sp_sview, addr, x, y, layer);
   }
}
d781 1
a781 10
print_sample(const char *function, const float *rgba)
{
   debug_printf("%s %g %g %g %g\n",
                function,
                rgba[0], rgba[TGSI_NUM_CHANNELS], rgba[2*TGSI_NUM_CHANNELS], rgba[3*TGSI_NUM_CHANNELS]);
}


static void
print_sample_4(const char *function, float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
d795 15
a809 13
img_filter_2d_linear_repeat_POT(struct sp_sampler_view *sp_sview,
                                struct sp_sampler *sp_samp,
                                float s,
                                float t,
                                float p,
                                unsigned level,
                                unsigned face_id,
                                float *rgba)
{
   unsigned xpot = pot_level_size(sp_sview->xpot, level);
   unsigned ypot = pot_level_size(sp_sview->ypot, level);
   int xmax = (xpot - 1) & (TEX_TILE_SIZE - 1); /* MIN2(TEX_TILE_SIZE, xpot) - 1; */
   int ymax = (ypot - 1) & (TEX_TILE_SIZE - 1); /* MIN2(TEX_TILE_SIZE, ypot) - 1; */
a810 1
   int c;
d812 8
a819 2
   float u = s * xpot - 0.5F;
   float v = t * ypot - 0.5F;
d821 2
a822 2
   int uflr = util_ifloor(u);
   int vflr = util_ifloor(v);
d824 2
a825 2
   float xw = u - (float)uflr;
   float yw = v - (float)vflr;
d827 2
a828 2
   int x0 = uflr & (xpot - 1);
   int y0 = vflr & (ypot - 1);
d830 1
a830 1
   const float *tx[4];
d832 10
a841 2
   addr.value = 0;
   addr.bits.level = level;
d843 6
a848 16
   /* Can we fetch all four at once:
    */
   if (x0 < xmax && y0 < ymax) {
      get_texel_quad_2d_no_border_single_tile(sp_sview, addr, x0, y0, tx);
   }
   else {
      unsigned x1 = (x0 + 1) & (xpot - 1);
      unsigned y1 = (y0 + 1) & (ypot - 1);
      get_texel_quad_2d_no_border(sp_sview, addr, x0, y0, x1, y1, tx);
   }

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++) {
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw, 
                                       tx[0][c], tx[1][c], 
                                       tx[2][c], tx[3][c]);
d858 13
a870 12
img_filter_2d_nearest_repeat_POT(struct sp_sampler_view *sp_sview,
                                 struct sp_sampler *sp_samp,
                                 float s,
                                 float t,
                                 float p,
                                 unsigned level,
                                 unsigned face_id,
                                 float rgba[TGSI_QUAD_SIZE])
{
   unsigned xpot = pot_level_size(sp_sview->xpot, level);
   unsigned ypot = pot_level_size(sp_sview->ypot, level);
   const float *out;
a871 10
   int c;

   float u = s * xpot;
   float v = t * ypot;

   int uflr = util_ifloor(u);
   int vflr = util_ifloor(v);

   int x0 = uflr & (xpot - 1);
   int y0 = vflr & (ypot - 1);
d874 1
a874 1
   addr.bits.level = level;
d876 2
a877 3
   out = get_texel_2d_no_border(sp_sview, addr, x0, y0);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];
d879 2
a880 4
   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}
d882 2
d885 2
a886 14
static INLINE void
img_filter_2d_nearest_clamp_POT(struct sp_sampler_view *sp_sview,
                                struct sp_sampler *sp_samp,
                                float s,
                                float t,
                                float p,
                                unsigned level,
                                unsigned face_id,
                                float rgba[TGSI_QUAD_SIZE])
{
   unsigned xpot = pot_level_size(sp_sview->xpot, level);
   unsigned ypot = pot_level_size(sp_sview->ypot, level);
   union tex_tile_address addr;
   int c;
d888 1
a888 2
   float u = s * xpot;
   float v = t * ypot;
d890 4
a893 21
   int x0, y0;
   const float *out;

   addr.value = 0;
   addr.bits.level = level;

   x0 = util_ifloor(u);
   if (x0 < 0) 
      x0 = 0;
   else if (x0 > (int) xpot - 1)
      x0 = xpot - 1;

   y0 = util_ifloor(v);
   if (y0 < 0) 
      y0 = 0;
   else if (y0 > (int) ypot - 1)
      y0 = ypot - 1;
   
   out = get_texel_2d_no_border(sp_sview, addr, x0, y0);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];
d901 14
a914 13
static void
img_filter_1d_nearest(struct sp_sampler_view *sp_sview,
                      struct sp_sampler *sp_samp,
                      float s,
                      float t,
                      float p,
                      unsigned level,
                      unsigned face_id,
                      float rgba[TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width;
   int x;
a915 2
   const float *out;
   int c;
d917 2
a918 1
   width = u_minify(texture->width0, level);
d920 2
a921 1
   assert(width > 0);
d923 2
a924 2
   addr.value = 0;
   addr.bits.level = level;
d926 16
a941 1
   sp_samp->nearest_texcoord_s(s, width, &x);
d943 4
a946 3
   out = get_texel_2d(sp_sview, sp_samp, addr, x, 0);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];
d955 7
a961 8
img_filter_1d_array_nearest(struct sp_sampler_view *sp_sview,
                            struct sp_sampler *sp_samp,
                            float s,
                            float t,
                            float p,
                            unsigned level,
                            unsigned face_id,
                            float *rgba)
d963 3
a965 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d967 1
a967 1
   int x, layer;
a968 2
   const float *out;
   int c;
d970 2
a971 1
   width = u_minify(texture->width0, level);
d976 1
a976 1
   addr.bits.level = level;
d978 1
a978 2
   sp_samp->nearest_texcoord_s(s, width, &x);
   wrap_array_layer(t, texture->array_size, &layer);
d980 7
a986 3
   out = get_texel_1d_array(sp_sview, sp_samp, addr, x, layer);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];
d995 11
a1005 10
img_filter_2d_nearest(struct sp_sampler_view *sp_sview,
                      struct sp_sampler *sp_samp,
                      float s,
                      float t,
                      float p,
                      unsigned level,
                      unsigned face_id,
                      float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
d1007 1
a1007 1
   int x, y;
a1008 2
   const float *out;
   int c;
d1010 4
a1013 2
   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);
d1019 1
a1019 1
   addr.bits.level = level;
d1021 2
a1022 2
   sp_samp->nearest_texcoord_s(s, width, &x);
   sp_samp->nearest_texcoord_t(t, height, &y);
d1024 6
a1029 6
   out = get_texel_2d(sp_sview, sp_samp, addr, x, y);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
a1030 36
}


static void
img_filter_2d_array_nearest(struct sp_sampler_view *sp_sview,
                            struct sp_sampler *sp_samp,
                            float s,
                            float t,
                            float p,
                            unsigned level,
                            unsigned face_id,
                            float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x, y, layer;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);
 
   addr.value = 0;
   addr.bits.level = level;

   sp_samp->nearest_texcoord_s(s, width, &x);
   sp_samp->nearest_texcoord_t(t, height, &y);
   wrap_array_layer(p, texture->array_size, &layer);

   out = get_texel_2d_array(sp_sview, sp_samp, addr, x, y, layer);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];
d1047 7
a1053 8
img_filter_cube_nearest(struct sp_sampler_view *sp_sview,
                        struct sp_sampler *sp_samp,
                        float s,
                        float t,
                        float p,
                        unsigned level,
                        unsigned face_id,
                        float *rgba)
d1055 4
a1058 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1060 1
a1060 1
   int x, y;
a1061 2
   const float *out;
   int c;
d1063 3
a1065 2
   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);
d1071 1
a1071 1
   addr.bits.level = level;
d1073 9
a1081 10
   /*
    * If NEAREST filtering is done within a miplevel, always apply wrap
    * mode CLAMP_TO_EDGE.
    */
   if (sp_samp->base.seamless_cube_map) {
      wrap_nearest_clamp_to_edge(s, width, &x);
      wrap_nearest_clamp_to_edge(t, height, &y);
   } else {
      sp_samp->nearest_texcoord_s(s, width, &x);
      sp_samp->nearest_texcoord_t(t, height, &y);
a1083 4
   out = get_texel_2d(sp_sview, sp_samp, face(addr, face_id), x, y);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

a1088 38
static void
img_filter_cube_array_nearest(struct sp_sampler_view *sp_sview,
                              struct sp_sampler *sp_samp,
                              float s,
                              float t,
                              float p,
                              unsigned level,
                              unsigned face_id,
                              float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x, y, layer;
   union tex_tile_address addr;
   const float *out;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);
 
   addr.value = 0;
   addr.bits.level = level;

   sp_samp->nearest_texcoord_s(s, width, &x);
   sp_samp->nearest_texcoord_t(t, height, &y);
   wrap_array_layer(p, texture->array_size, &layer);

   out = get_texel_cube_array(sp_sview, sp_samp, addr, x, y, layer * 6 + face_id);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];

   if (DEBUG_TEX) {
      print_sample(__FUNCTION__, rgba);
   }
}
d1091 11
a1101 10
img_filter_3d_nearest(struct sp_sampler_view *sp_sview,
                      struct sp_sampler *sp_samp,
                      float s,
                      float t,
                      float p,
                      unsigned level,
                      unsigned face_id,
                      float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
d1103 1
a1103 1
   int x, y, z;
a1104 2
   const float *out;
   int c;
d1106 4
a1109 3
   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);
   depth = u_minify(texture->depth0, level);
d1115 3
a1117 3
   sp_samp->nearest_texcoord_s(s, width,  &x);
   sp_samp->nearest_texcoord_t(t, height, &y);
   sp_samp->nearest_texcoord_p(p, depth,  &z);
d1120 1
a1120 1
   addr.bits.level = level;
d1122 7
a1128 3
   out = get_texel_3d(sp_sview, sp_samp, addr, x, y, z);
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = out[c];
d1133 7
a1139 8
img_filter_1d_linear(struct sp_sampler_view *sp_sview,
                     struct sp_sampler *sp_samp,
                     float s,
                     float t,
                     float p,
                     unsigned level,
                     unsigned face_id,
                     float *rgba)
d1141 3
a1143 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1145 2
a1146 2
   int x0, x1;
   float xw; /* weights */
a1147 2
   const float *tx0, *tx1;
   int c;
d1149 2
a1150 1
   width = u_minify(texture->width0, level);
d1155 1
a1155 1
   addr.bits.level = level;
d1157 1
a1157 1
   sp_samp->linear_texcoord_s(s, width, &x0, &x1, &xw);
d1159 4
a1162 2
   tx0 = get_texel_2d(sp_sview, sp_samp, addr, x0, 0);
   tx1 = get_texel_2d(sp_sview, sp_samp, addr, x1, 0);
d1164 5
a1168 40
   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp(xw, tx0[c], tx1[c]);
}


static void
img_filter_1d_array_linear(struct sp_sampler_view *sp_sview,
                           struct sp_sampler *sp_samp,
                           float s,
                           float t,
                           float p,
                           unsigned level,
                           unsigned face_id,
                           float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width;
   int x0, x1, layer;
   float xw; /* weights */
   union tex_tile_address addr;
   const float *tx0, *tx1;
   int c;

   width = u_minify(texture->width0, level);

   assert(width > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->linear_texcoord_s(s, width, &x0, &x1, &xw);
   wrap_array_layer(t, texture->array_size, &layer);

   tx0 = get_texel_1d_array(sp_sview, sp_samp, addr, x0, layer);
   tx1 = get_texel_1d_array(sp_sview, sp_samp, addr, x1, layer);

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp(xw, tx0[c], tx1[c]);
d1173 7
a1179 8
img_filter_2d_linear(struct sp_sampler_view *sp_sview,
                     struct sp_sampler *sp_samp,
                     float s,
                     float t,
                     float p,
                     unsigned level,
                     unsigned face_id,
                     float *rgba)
d1181 3
a1183 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1185 2
a1186 2
   int x0, y0, x1, y1;
   float xw, yw; /* weights */
a1187 2
   const float *tx0, *tx1, *tx2, *tx3;
   int c;
d1189 3
a1191 2
   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);
d1197 1
a1197 1
   addr.bits.level = level;
d1199 2
a1200 2
   sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
   sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
d1202 6
a1207 4
   tx0 = get_texel_2d(sp_sview, sp_samp, addr, x0, y0);
   tx1 = get_texel_2d(sp_sview, sp_samp, addr, x1, y0);
   tx2 = get_texel_2d(sp_sview, sp_samp, addr, x0, y1);
   tx3 = get_texel_2d(sp_sview, sp_samp, addr, x1, y1);
d1209 7
a1215 5
   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw,
                                          tx0[c], tx1[c],
                                          tx2[c], tx3[c]);
d1220 7
a1226 8
img_filter_2d_array_linear(struct sp_sampler_view *sp_sview,
                           struct sp_sampler *sp_samp,
                           float s,
                           float t,
                           float p,
                           unsigned level,
                           unsigned face_id,
                           float *rgba)
d1228 4
a1231 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1233 2
a1234 2
   int x0, y0, x1, y1, layer;
   float xw, yw; /* weights */
a1235 2
   const float *tx0, *tx1, *tx2, *tx3;
   int c;
d1237 3
a1239 2
   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);
d1245 1
a1245 1
   addr.bits.level = level;
d1247 2
a1248 3
   sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
   sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
   wrap_array_layer(p, texture->array_size, &layer);
d1250 7
a1256 4
   tx0 = get_texel_2d_array(sp_sview, sp_samp, addr, x0, y0, layer);
   tx1 = get_texel_2d_array(sp_sview, sp_samp, addr, x1, y0, layer);
   tx2 = get_texel_2d_array(sp_sview, sp_samp, addr, x0, y1, layer);
   tx3 = get_texel_2d_array(sp_sview, sp_samp, addr, x1, y1, layer);
d1258 6
a1263 47
   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw,
                                          tx0[c], tx1[c],
                                          tx2[c], tx3[c]);
}


static void
img_filter_cube_linear(struct sp_sampler_view *sp_sview,
                       struct sp_sampler *sp_samp,
                       float s,
                       float t,
                       float p,
                       unsigned level,
                       unsigned face_id,
                       float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x0, y0, x1, y1;
   float xw, yw; /* weights */
   union tex_tile_address addr, addrj;
   const float *tx0, *tx1, *tx2, *tx3;
   float corner0[TGSI_QUAD_SIZE], corner1[TGSI_QUAD_SIZE],
         corner2[TGSI_QUAD_SIZE], corner3[TGSI_QUAD_SIZE];
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);

   addr.value = 0;
   addr.bits.level = level;

   /*
    * For seamless if LINEAR filtering is done within a miplevel,
    * always apply wrap mode CLAMP_TO_BORDER.
    */
   if (sp_samp->base.seamless_cube_map) {
      wrap_linear_clamp_to_border(s, width, &x0, &x1, &xw);
      wrap_linear_clamp_to_border(t, height, &y0, &y1, &yw);
   } else {
      sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
      sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
a1264 19

   addrj = face(addr, face_id);

   if (sp_samp->base.seamless_cube_map) {
      tx0 = get_texel_cube_seamless(sp_sview, addrj, x0, y0, corner0);
      tx1 = get_texel_cube_seamless(sp_sview, addrj, x1, y0, corner1);
      tx2 = get_texel_cube_seamless(sp_sview, addrj, x0, y1, corner2);
      tx3 = get_texel_cube_seamless(sp_sview, addrj, x1, y1, corner3);
   } else {
      tx0 = get_texel_2d(sp_sview, sp_samp, addrj, x0, y0);
      tx1 = get_texel_2d(sp_sview, sp_samp, addrj, x1, y0);
      tx2 = get_texel_2d(sp_sview, sp_samp, addrj, x0, y1);
      tx3 = get_texel_2d(sp_sview, sp_samp, addrj, x1, y1);
   }
   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw,
                                          tx0[c], tx1[c],
                                          tx2[c], tx3[c]);
d1269 7
a1275 51
img_filter_cube_array_linear(struct sp_sampler_view *sp_sview,
                             struct sp_sampler *sp_samp,
                             float s,
                             float t,
                             float p,
                             unsigned level,
                             unsigned face_id,
                             float *rgba)
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int width, height;
   int x0, y0, x1, y1, layer;
   float xw, yw; /* weights */
   union tex_tile_address addr;
   const float *tx0, *tx1, *tx2, *tx3;
   int c;

   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);

   assert(width > 0);
   assert(height > 0);

   addr.value = 0;
   addr.bits.level = level;

   sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
   sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
   wrap_array_layer(p, texture->array_size, &layer);

   tx0 = get_texel_cube_array(sp_sview, sp_samp, addr, x0, y0, layer * 6 + face_id);
   tx1 = get_texel_cube_array(sp_sview, sp_samp, addr, x1, y0, layer * 6 + face_id);
   tx2 = get_texel_cube_array(sp_sview, sp_samp, addr, x0, y1, layer * 6 + face_id);
   tx3 = get_texel_cube_array(sp_sview, sp_samp, addr, x1, y1, layer * 6 + face_id);

   /* interpolate R, G, B, A */
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] = lerp_2d(xw, yw,
                                          tx0[c], tx1[c],
                                          tx2[c], tx3[c]);
}

static void
img_filter_3d_linear(struct sp_sampler_view *sp_sview,
                     struct sp_sampler *sp_samp,
                     float s,
                     float t,
                     float p,
                     unsigned level,
                     unsigned face_id,
                     float *rgba)
d1277 3
a1279 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1281 2
a1282 2
   int x0, x1, y0, y1, z0, z1;
   float xw, yw, zw; /* interpolation weights */
a1283 2
   const float *tx00, *tx01, *tx02, *tx03, *tx10, *tx11, *tx12, *tx13;
   int c;
d1285 4
a1288 3
   width = u_minify(texture->width0, level);
   height = u_minify(texture->height0, level);
   depth = u_minify(texture->depth0, level);
d1291 1
a1291 1
   addr.bits.level = level;
d1297 11
a1307 9
   sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
   sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
   sp_samp->linear_texcoord_p(p, depth,  &z0, &z1, &zw);


   tx00 = get_texel_3d(sp_sview, sp_samp, addr, x0, y0, z0);
   tx01 = get_texel_3d(sp_sview, sp_samp, addr, x1, y0, z0);
   tx02 = get_texel_3d(sp_sview, sp_samp, addr, x0, y1, z0);
   tx03 = get_texel_3d(sp_sview, sp_samp, addr, x1, y1, z0);
d1309 4
a1312 4
   tx10 = get_texel_3d(sp_sview, sp_samp, addr, x0, y0, z1);
   tx11 = get_texel_3d(sp_sview, sp_samp, addr, x1, y0, z1);
   tx12 = get_texel_3d(sp_sview, sp_samp, addr, x0, y1, z1);
   tx13 = get_texel_3d(sp_sview, sp_samp, addr, x1, y1, z1);
d1315 8
a1322 6
   for (c = 0; c < TGSI_QUAD_SIZE; c++)
      rgba[TGSI_NUM_CHANNELS*c] =  lerp_3d(xw, yw, zw,
                                           tx00[c], tx01[c],
                                           tx02[c], tx03[c],
                                           tx10[c], tx11[c],
                                           tx12[c], tx13[c]);
d1326 1
a1326 2
/* Calculate level of detail for every fragment,
 * with lambda already computed.
a1327 3
 * \param biased_lambda per-quad lambda.
 * \param lod_in per-fragment lod_bias or explicit_lod.
 * \param lod returns the per-fragment lod.
a1330 1
            enum tgsi_sampler_control control,
d1332 2
a1333 2
            const float lod_in[TGSI_QUAD_SIZE],
            float lod[TGSI_QUAD_SIZE])
a1334 2
   float min_lod = sampler->min_lod;
   float max_lod = sampler->max_lod;
d1337 15
a1351 38
   switch (control) {
   case tgsi_sampler_lod_none:
   case tgsi_sampler_lod_zero:
   /* XXX FIXME */
   case tgsi_sampler_derivs_explicit:
      lod[0] = lod[1] = lod[2] = lod[3] = CLAMP(biased_lambda, min_lod, max_lod);
      break;
   case tgsi_sampler_lod_bias:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         lod[i] = biased_lambda + lod_in[i];
         lod[i] = CLAMP(lod[i], min_lod, max_lod);
      }
      break;
   case tgsi_sampler_lod_explicit:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         lod[i] = CLAMP(lod_in[i], min_lod, max_lod);
      }
      break;
   default:
      assert(0);
      lod[0] = lod[1] = lod[2] = lod[3] = 0.0f;
   }
}


/* Calculate level of detail for every fragment.
 * \param lod_in per-fragment lod_bias or explicit_lod.
 * \param lod results per-fragment lod.
 */
static INLINE void
compute_lambda_lod(struct sp_sampler_view *sp_sview,
                   struct sp_sampler *sp_samp,
                   const float s[TGSI_QUAD_SIZE],
                   const float t[TGSI_QUAD_SIZE],
                   const float p[TGSI_QUAD_SIZE],
                   const float lod_in[TGSI_QUAD_SIZE],
                   enum tgsi_sampler_control control,
                   float lod[TGSI_QUAD_SIZE])
d1353 3
a1355 4
   const struct pipe_sampler_state *sampler = &sp_samp->base;
   float lod_bias = sampler->lod_bias;
   float min_lod = sampler->min_lod;
   float max_lod = sampler->max_lod;
d1357 7
a1363 1
   uint i;
d1365 1
a1365 26
   switch (control) {
   case tgsi_sampler_lod_none:
      /* XXX FIXME */
   case tgsi_sampler_derivs_explicit:
      lambda = sp_sview->compute_lambda(sp_sview, s, t, p) + lod_bias;
      lod[0] = lod[1] = lod[2] = lod[3] = CLAMP(lambda, min_lod, max_lod);
      break;
   case tgsi_sampler_lod_bias:
      lambda = sp_sview->compute_lambda(sp_sview, s, t, p) + lod_bias;
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         lod[i] = lambda + lod_in[i];
         lod[i] = CLAMP(lod[i], min_lod, max_lod);
      }
      break;
   case tgsi_sampler_lod_explicit:
      for (i = 0; i < TGSI_QUAD_SIZE; i++) {
         lod[i] = CLAMP(lod_in[i], min_lod, max_lod);
      }
      break;
   case tgsi_sampler_lod_zero:
      /* this is all static state in the sampler really need clamp here? */
      lod[0] = lod[1] = lod[2] = lod[3] = CLAMP(lod_bias, min_lod, max_lod);
      break;
   default:
      assert(0);
      lod[0] = lod[1] = lod[2] = lod[3] = 0.0f;
a1366 1
}
d1368 4
d1373 13
a1385 16
static void
mip_filter_linear(struct sp_sampler_view *sp_sview,
                  struct sp_sampler *sp_samp,
                  img_filter_func min_filter,
                  img_filter_func mag_filter,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE],
                  const float c0[TGSI_QUAD_SIZE],
                  const float lod_in[TGSI_QUAD_SIZE],
                  enum tgsi_sampler_control control,
                  float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int j;
   float lod[TGSI_QUAD_SIZE];
d1387 2
a1388 1
   compute_lambda_lod(sp_sview, sp_samp, s, t, p, lod_in, control, lod);
d1390 2
a1391 21
   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      int level0 = sp_sview->base.u.tex.first_level + (int)lod[j];

      if (lod[j] < 0.0)
         mag_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    sp_sview->base.u.tex.first_level,
                    sp_sview->faces[j], &rgba[0][j]);

      else if (level0 >= (int) texture->last_level)
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], texture->last_level,
                    sp_sview->faces[j], &rgba[0][j]);

      else {
         float levelBlend = frac(lod[j]);
         float rgbax[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
         int c;

         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], level0,
                    sp_sview->faces[j], &rgbax[0][0]);
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], level0+1,
                    sp_sview->faces[j], &rgbax[0][1]);
d1393 1
d1395 1
a1395 1
            rgba[c][j] = lerp(levelBlend, rgbax[c][0], rgbax[c][1]);
d1401 1
a1401 1
      print_sample_4(__FUNCTION__, rgba);
d1412 5
a1416 9
mip_filter_nearest(struct sp_sampler_view *sp_sview,
                   struct sp_sampler *sp_samp,
                   img_filter_func min_filter,
                   img_filter_func mag_filter,
                   const float s[TGSI_QUAD_SIZE],
                   const float t[TGSI_QUAD_SIZE],
                   const float p[TGSI_QUAD_SIZE],
                   const float c0[TGSI_QUAD_SIZE],
                   const float lod_in[TGSI_QUAD_SIZE],
d1418 1
a1418 1
                   float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
d1420 10
a1429 18
   const struct pipe_resource *texture = sp_sview->base.texture;
   float lod[TGSI_QUAD_SIZE];
   int j;

   compute_lambda_lod(sp_sview, sp_samp, s, t, p, lod_in, control, lod);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      if (lod[j] < 0.0)
         mag_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    sp_sview->base.u.tex.first_level,
                    sp_sview->faces[j], &rgba[0][j]);
      else {
         int level = sp_sview->base.u.tex.first_level + (int)(lod[j] + 0.5F);
         level = MIN2(level, (int)texture->last_level);
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    level, sp_sview->faces[j], &rgba[0][j]);
      }
   }
d1431 1
a1431 2
   if (DEBUG_TEX) {
      print_sample_4(__FUNCTION__, rgba);
a1432 1
}
d1434 3
d1438 9
a1446 15
static void
mip_filter_none(struct sp_sampler_view *sp_sview,
                struct sp_sampler *sp_samp,
                img_filter_func min_filter,
                img_filter_func mag_filter,
                const float s[TGSI_QUAD_SIZE],
                const float t[TGSI_QUAD_SIZE],
                const float p[TGSI_QUAD_SIZE],
                const float c0[TGSI_QUAD_SIZE],
                const float lod_in[TGSI_QUAD_SIZE],
                enum tgsi_sampler_control control,
                float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   float lod[TGSI_QUAD_SIZE];
   int j;
d1448 2
a1449 13
   compute_lambda_lod(sp_sview, sp_samp, s, t, p, lod_in, control, lod);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      if (lod[j] < 0.0) { 
         mag_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    sp_sview->base.u.tex.first_level,
                    sp_sview->faces[j], &rgba[0][j]);
      }
      else {
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                    sp_sview->base.u.tex.first_level,
                    sp_sview->faces[j], &rgba[0][j]);
      }
d1455 7
a1461 11
mip_filter_none_no_filter_select(struct sp_sampler_view *sp_sview,
                                 struct sp_sampler *sp_samp,
                                 img_filter_func min_filter,
                                 img_filter_func mag_filter,
                                 const float s[TGSI_QUAD_SIZE],
                                 const float t[TGSI_QUAD_SIZE],
                                 const float p[TGSI_QUAD_SIZE],
                                 const float c0[TGSI_QUAD_SIZE],
                                 const float lod_in[TGSI_QUAD_SIZE],
                                 enum tgsi_sampler_control control,
                                 float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
d1463 3
a1465 1
   int j;
d1467 5
a1471 11
   for (j = 0; j < TGSI_QUAD_SIZE; j++)
      mag_filter(sp_sview, sp_samp, s[j], t[j], p[j],
                 sp_sview->base.u.tex.first_level,
                 sp_sview->faces[j], &rgba[0][j]);
}


/* For anisotropic filtering */
#define WEIGHT_LUT_SIZE 1024

static float *weightLut = NULL;
d1473 1
a1473 16
/**
 * Creates the look-up table used to speed-up EWA sampling
 */
static void
create_filter_table(void)
{
   unsigned i;
   if (!weightLut) {
      weightLut = (float *) MALLOC(WEIGHT_LUT_SIZE * sizeof(float));

      for (i = 0; i < WEIGHT_LUT_SIZE; ++i) {
         float alpha = 2;
         float r2 = (float) i / (float) (WEIGHT_LUT_SIZE - 1);
         float weight = (float) exp(-alpha * r2);
         weightLut[i] = weight;
      }
a1474 1
}
d1476 1
a1476 36

/**
 * Elliptical weighted average (EWA) filter for producing high quality
 * anisotropic filtered results.
 * Based on the Higher Quality Elliptical Weighted Average Filter
 * published by Paul S. Heckbert in his Master's Thesis
 * "Fundamentals of Texture Mapping and Image Warping" (1989)
 */
static void
img_filter_2d_ewa(struct sp_sampler_view *sp_sview,
                  struct sp_sampler *sp_samp,
                  img_filter_func min_filter,
                  img_filter_func mag_filter,
                  const float s[TGSI_QUAD_SIZE],
                  const float t[TGSI_QUAD_SIZE],
                  const float p[TGSI_QUAD_SIZE],
                  unsigned level,
                  const float dudx, const float dvdx,
                  const float dudy, const float dvdy,
                  float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;

   // ??? Won't the image filters blow up if level is negative?
   unsigned level0 = level > 0 ? level : 0;
   float scaling = 1.0f / (1 << level0);
   int width = u_minify(texture->width0, level0);
   int height = u_minify(texture->height0, level0);

   float ux = dudx * scaling;
   float vx = dvdx * scaling;
   float uy = dudy * scaling;
   float vy = dvdy * scaling;

   /* compute ellipse coefficients to bound the region: 
    * A*x*x + B*x*y + C*y*y = F.
d1478 1
a1478 23
   float A = vx*vx+vy*vy+1;
   float B = -2*(ux*vx+uy*vy);
   float C = ux*ux+uy*uy+1;
   float F = A*C-B*B/4.0f;

   /* check if it is an ellipse */
   /* ASSERT(F > 0.0); */

   /* Compute the ellipse's (u,v) bounding box in texture space */
   float d = -B*B+4.0f*C*A;
   float box_u = 2.0f / d * sqrtf(d*C*F); /* box_u -> half of bbox with   */
   float box_v = 2.0f / d * sqrtf(A*d*F); /* box_v -> half of bbox height */

   float rgba_temp[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
   float s_buffer[TGSI_QUAD_SIZE];
   float t_buffer[TGSI_QUAD_SIZE];
   float weight_buffer[TGSI_QUAD_SIZE];
   unsigned buffer_next;
   int j;
   float den; /* = 0.0F; */
   float ddq;
   float U; /* = u0 - tex_u; */
   int v;
d1480 5
a1484 126
   /* Scale ellipse formula to directly index the Filter Lookup Table.
    * i.e. scale so that F = WEIGHT_LUT_SIZE-1
    */
   double formScale = (double) (WEIGHT_LUT_SIZE - 1) / F;
   A *= formScale;
   B *= formScale;
   C *= formScale;
   /* F *= formScale; */ /* no need to scale F as we don't use it below here */

   /* For each quad, the du and dx values are the same and so the ellipse is
    * also the same. Note that texel/image access can only be performed using
    * a quad, i.e. it is not possible to get the pixel value for a single
    * tex coord. In order to have a better performance, the access is buffered
    * using the s_buffer/t_buffer and weight_buffer. Only when the buffer is
    * full, then the pixel values are read from the image.
    */
   ddq = 2 * A;
   
   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      /* Heckbert MS thesis, p. 59; scan over the bounding box of the ellipse
       * and incrementally update the value of Ax^2+Bxy*Cy^2; when this
       * value, q, is less than F, we're inside the ellipse
       */
      float tex_u = -0.5F + s[j] * texture->width0 * scaling;
      float tex_v = -0.5F + t[j] * texture->height0 * scaling;

      int u0 = (int) floorf(tex_u - box_u);
      int u1 = (int) ceilf(tex_u + box_u);
      int v0 = (int) floorf(tex_v - box_v);
      int v1 = (int) ceilf(tex_v + box_v);

      float num[4] = {0.0F, 0.0F, 0.0F, 0.0F};
      buffer_next = 0;
      den = 0;
      U = u0 - tex_u;
      for (v = v0; v <= v1; ++v) {
         float V = v - tex_v;
         float dq = A * (2 * U + 1) + B * V;
         float q = (C * V + B * U) * V + A * U * U;

         int u;
         for (u = u0; u <= u1; ++u) {
            /* Note that the ellipse has been pre-scaled so F =
             * WEIGHT_LUT_SIZE - 1
             */
            if (q < WEIGHT_LUT_SIZE) {
               /* as a LUT is used, q must never be negative;
                * should not happen, though
                */
               const int qClamped = q >= 0.0F ? q : 0;
               float weight = weightLut[qClamped];

               weight_buffer[buffer_next] = weight;
               s_buffer[buffer_next] = u / ((float) width);
               t_buffer[buffer_next] = v / ((float) height);
            
               buffer_next++;
               if (buffer_next == TGSI_QUAD_SIZE) {
                  /* 4 texel coords are in the buffer -> read it now */
                  unsigned jj;
                  /* it is assumed that samp->min_img_filter is set to
                   * img_filter_2d_nearest or one of the
                   * accelerated img_filter_2d_nearest_XXX functions.
                   */
                  for (jj = 0; jj < buffer_next; jj++) {
                     min_filter(sp_sview, sp_samp, s_buffer[jj], t_buffer[jj], p[jj],
                                level, sp_sview->faces[j], &rgba_temp[0][jj]);
                     num[0] += weight_buffer[jj] * rgba_temp[0][jj];
                     num[1] += weight_buffer[jj] * rgba_temp[1][jj];
                     num[2] += weight_buffer[jj] * rgba_temp[2][jj];
                     num[3] += weight_buffer[jj] * rgba_temp[3][jj];
                  }

                  buffer_next = 0;
               }

               den += weight;
            }
            q += dq;
            dq += ddq;
         }
      }

      /* if the tex coord buffer contains unread values, we will read
       * them now.
       */
      if (buffer_next > 0) {
         unsigned jj;
         /* it is assumed that samp->min_img_filter is set to
          * img_filter_2d_nearest or one of the
          * accelerated img_filter_2d_nearest_XXX functions.
          */
         for (jj = 0; jj < buffer_next; jj++) {
            min_filter(sp_sview, sp_samp, s_buffer[jj], t_buffer[jj], p[jj],
                       level, sp_sview->faces[j], &rgba_temp[0][jj]);
            num[0] += weight_buffer[jj] * rgba_temp[0][jj];
            num[1] += weight_buffer[jj] * rgba_temp[1][jj];
            num[2] += weight_buffer[jj] * rgba_temp[2][jj];
            num[3] += weight_buffer[jj] * rgba_temp[3][jj];
         }
      }

      if (den <= 0.0F) {
         /* Reaching this place would mean that no pixels intersected
          * the ellipse.  This should never happen because the filter
          * we use always intersects at least one pixel.
          */

         /*rgba[0]=0;
         rgba[1]=0;
         rgba[2]=0;
         rgba[3]=0;*/
         /* not enough pixels in resampling, resort to direct interpolation */
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], level,
                    sp_sview->faces[j], &rgba_temp[0][j]);
         den = 1;
         num[0] = rgba_temp[0][j];
         num[1] = rgba_temp[1][j];
         num[2] = rgba_temp[2][j];
         num[3] = rgba_temp[3][j];
      }

      rgba[0][j] = num[0] / den;
      rgba[1][j] = num[1] / den;
      rgba[2][j] = num[2] / den;
      rgba[3][j] = num[3] / den;
d1489 1
d1491 2
a1492 1
 * Sample 2D texture using an anisotropic filter.
d1495 8
a1502 11
mip_filter_linear_aniso(struct sp_sampler_view *sp_sview,
                        struct sp_sampler *sp_samp,
                        img_filter_func min_filter,
                        img_filter_func mag_filter,
                        const float s[TGSI_QUAD_SIZE],
                        const float t[TGSI_QUAD_SIZE],
                        const float p[TGSI_QUAD_SIZE],
                        const float c0[TGSI_QUAD_SIZE],
                        const float lod_in[TGSI_QUAD_SIZE],
                        enum tgsi_sampler_control control,
                        float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
d1504 2
a1505 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1508 1
a1508 1
   float lod[TGSI_QUAD_SIZE];
d1510 5
a1514 16
   float s_to_u = u_minify(texture->width0, sp_sview->base.u.tex.first_level);
   float t_to_v = u_minify(texture->height0, sp_sview->base.u.tex.first_level);
   float dudx = (s[QUAD_BOTTOM_RIGHT] - s[QUAD_BOTTOM_LEFT]) * s_to_u;
   float dudy = (s[QUAD_TOP_LEFT]     - s[QUAD_BOTTOM_LEFT]) * s_to_u;
   float dvdx = (t[QUAD_BOTTOM_RIGHT] - t[QUAD_BOTTOM_LEFT]) * t_to_v;
   float dvdy = (t[QUAD_TOP_LEFT]     - t[QUAD_BOTTOM_LEFT]) * t_to_v;
   
   if (control == tgsi_sampler_lod_bias ||
       control == tgsi_sampler_lod_none ||
       /* XXX FIXME */
       control == tgsi_sampler_derivs_explicit) {
      /* note: instead of working with Px and Py, we will use the 
       * squared length instead, to avoid sqrt.
       */
      float Px2 = dudx * dudx + dvdx * dvdx;
      float Py2 = dudy * dudy + dvdy * dvdy;
d1516 1
a1516 31
      float Pmax2;
      float Pmin2;
      float e;
      const float maxEccentricity = sp_samp->base.max_anisotropy * sp_samp->base.max_anisotropy;
      
      if (Px2 < Py2) {
         Pmax2 = Py2;
         Pmin2 = Px2;
      }
      else {
         Pmax2 = Px2;
         Pmin2 = Py2;
      }
      
      /* if the eccentricity of the ellipse is too big, scale up the shorter
       * of the two vectors to limit the maximum amount of work per pixel
       */
      e = Pmax2 / Pmin2;
      if (e > maxEccentricity) {
         /* float s=e / maxEccentricity;
            minor[0] *= s;
            minor[1] *= s;
            Pmin2 *= s; */
         Pmin2 = Pmax2 / maxEccentricity;
      }
      
      /* note: we need to have Pmin=sqrt(Pmin2) here, but we can avoid
       * this since 0.5*log(x) = log(sqrt(x))
       */
      lambda = 0.5F * util_fast_log2(Pmin2) + sp_samp->base.lod_bias;
      compute_lod(&sp_samp->base, control, lambda, lod_in, lod);
d1518 1
a1518 6
   else {
      assert(control == tgsi_sampler_lod_explicit ||
             control == tgsi_sampler_lod_zero);
      compute_lod(&sp_samp->base, control, sp_samp->base.lod_bias, lod_in, lod);
   }
   
d1522 1
a1522 1
   level0 = sp_sview->base.u.tex.first_level + (int)lambda;
d1524 1
a1524 2
   /* If the ellipse covers the whole image, we can
    * simply return the average of the whole image.
d1526 7
a1532 5
   if (level0 >= (int) texture->last_level) {
      int j;
      for (j = 0; j < TGSI_QUAD_SIZE; j++)
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], texture->last_level,
                    sp_sview->faces[j], &rgba[0][j]);
d1535 4
a1538 7
      /* don't bother interpolating between multiple LODs; it doesn't
       * seem to be worth the extra running time.
       */
      img_filter_2d_ewa(sp_sview, sp_samp, min_filter, mag_filter,
                        s, t, p, level0,
                        dudx, dvdx, dudy, dvdy, rgba);
   }
d1540 2
a1541 4
   if (DEBUG_TEX) {
      print_sample_4(__FUNCTION__, rgba);
   }
}
d1543 2
d1546 4
a1549 52
/**
 * Specialized version of mip_filter_linear with hard-wired calls to
 * 2d lambda calculation and 2d_linear_repeat_POT img filters.
 */
static void
mip_filter_linear_2d_linear_repeat_POT(
   struct sp_sampler_view *sp_sview,
   struct sp_sampler *sp_samp,
   img_filter_func min_filter,
   img_filter_func mag_filter,
   const float s[TGSI_QUAD_SIZE],
   const float t[TGSI_QUAD_SIZE],
   const float p[TGSI_QUAD_SIZE],
   const float c0[TGSI_QUAD_SIZE],
   const float lod_in[TGSI_QUAD_SIZE],
   enum tgsi_sampler_control control,
   float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   const struct pipe_resource *texture = sp_sview->base.texture;
   int j;
   float lod[TGSI_QUAD_SIZE];

   compute_lambda_lod(sp_sview, sp_samp, s, t, p, lod_in, control, lod);

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      int level0 = sp_sview->base.u.tex.first_level + (int)lod[j];

      /* Catches both negative and large values of level0:
       */
      if ((unsigned)level0 >= texture->last_level) { 
         if (level0 < 0)
            img_filter_2d_linear_repeat_POT(sp_sview, sp_samp, s[j], t[j], p[j],
                                            sp_sview->base.u.tex.first_level,
                                            sp_sview->faces[j], &rgba[0][j]);
         else
            img_filter_2d_linear_repeat_POT(sp_sview, sp_samp, s[j], t[j], p[j],
                                            sp_sview->base.texture->last_level,
                                            sp_sview->faces[j], &rgba[0][j]);

      }
      else {
         float levelBlend = frac(lod[j]);
         float rgbax[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
         int c;

         img_filter_2d_linear_repeat_POT(sp_sview, sp_samp, s[j], t[j], p[j], level0,
                                         sp_sview->faces[j], &rgbax[0][0]);
         img_filter_2d_linear_repeat_POT(sp_sview, sp_samp, s[j], t[j], p[j], level0+1,
                                         sp_sview->faces[j], &rgbax[0][1]);

         for (c = 0; c < TGSI_NUM_CHANNELS; c++)
            rgba[c][j] = lerp(levelBlend, rgbax[c][0], rgbax[c][1]);
d1554 1
a1554 1
      print_sample_4(__FUNCTION__, rgba);
d1559 1
d1564 5
a1568 7
sample_compare(struct sp_sampler_view *sp_sview,
               struct sp_sampler *sp_samp,
               const float s[TGSI_QUAD_SIZE],
               const float t[TGSI_QUAD_SIZE],
               const float p[TGSI_QUAD_SIZE],
               const float c0[TGSI_QUAD_SIZE],
               const float c1[TGSI_QUAD_SIZE],
d1570 1
a1570 1
               float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
d1572 2
a1573 1
   const struct pipe_sampler_state *sampler = &sp_samp->base;
d1576 2
a1577 1
   float pc0, pc1, pc2, pc3;
a1580 1
    * for 2D Array texture we need to use the 'c0' (aka Q).
a1584 17
   if (sp_sview->base.texture->target == PIPE_TEXTURE_2D_ARRAY ||
       sp_sview->base.texture->target == PIPE_TEXTURE_CUBE) {
      pc0 = CLAMP(c0[0], 0.0F, 1.0F);
      pc1 = CLAMP(c0[1], 0.0F, 1.0F);
      pc2 = CLAMP(c0[2], 0.0F, 1.0F);
      pc3 = CLAMP(c0[3], 0.0F, 1.0F);
   } else if (sp_sview->base.texture->target == PIPE_TEXTURE_CUBE_ARRAY) {
      pc0 = CLAMP(c1[0], 0.0F, 1.0F);
      pc1 = CLAMP(c1[1], 0.0F, 1.0F);
      pc2 = CLAMP(c1[2], 0.0F, 1.0F);
      pc3 = CLAMP(c1[3], 0.0F, 1.0F);
   } else {
      pc0 = CLAMP(p[0], 0.0F, 1.0F);
      pc1 = CLAMP(p[1], 0.0F, 1.0F);
      pc2 = CLAMP(p[2], 0.0F, 1.0F);
      pc3 = CLAMP(p[3], 0.0F, 1.0F);
   }
d1588 4
a1591 4
      k0 = pc0 < rgba[0][0];
      k1 = pc1 < rgba[0][1];
      k2 = pc2 < rgba[0][2];
      k3 = pc3 < rgba[0][3];
d1594 4
a1597 4
      k0 = pc0 <= rgba[0][0];
      k1 = pc1 <= rgba[0][1];
      k2 = pc2 <= rgba[0][2];
      k3 = pc3 <= rgba[0][3];
d1600 4
a1603 4
      k0 = pc0 > rgba[0][0];
      k1 = pc1 > rgba[0][1];
      k2 = pc2 > rgba[0][2];
      k3 = pc3 > rgba[0][3];
d1606 4
a1609 4
      k0 = pc0 >= rgba[0][0];
      k1 = pc1 >= rgba[0][1];
      k2 = pc2 >= rgba[0][2];
      k3 = pc3 >= rgba[0][3];
d1612 4
a1615 4
      k0 = pc0 == rgba[0][0];
      k1 = pc1 == rgba[0][1];
      k2 = pc2 == rgba[0][2];
      k3 = pc3 == rgba[0][3];
d1618 4
a1621 4
      k0 = pc0 != rgba[0][0];
      k1 = pc1 != rgba[0][1];
      k2 = pc2 != rgba[0][2];
      k3 = pc3 != rgba[0][3];
d1635 2
a1636 9
   if (sampler->mag_img_filter == PIPE_TEX_FILTER_LINEAR) {
      /* convert four pass/fail values to an intensity in [0,1] */
      /*
       * XXX this doesn't actually make much sense.
       * We just average the result of four _pixels_ and output the same
       * value for all of the four pixels of the quad.
       * This really needs to work on the _samples_ i.e. inside the img filter.
       */
      val = 0.25F * (k0 + k1 + k2 + k3);
d1638 4
a1641 12
      /* XXX returning result for default GL_DEPTH_TEXTURE_MODE = GL_LUMINANCE */
      for (j = 0; j < 4; j++) {
         rgba[0][j] = rgba[1][j] = rgba[2][j] = val;
         rgba[3][j] = 1.0F;
      }
   } else {
      for (j = 0; j < 4; j++) {
         rgba[0][j] = k0;
         rgba[1][j] = k1;
         rgba[2][j] = k2;
         rgba[3][j] = 1.0F;
      }
d1646 4
d1651 23
a1673 24
do_swizzling(const struct pipe_sampler_view *sview,
             float in[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE],
             float out[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   int j;
   const unsigned swizzle_r = sview->swizzle_r;
   const unsigned swizzle_g = sview->swizzle_g;
   const unsigned swizzle_b = sview->swizzle_b;
   const unsigned swizzle_a = sview->swizzle_a;

   switch (swizzle_r) {
   case PIPE_SWIZZLE_ZERO:
      for (j = 0; j < 4; j++)
         out[0][j] = 0.0f;
      break;
   case PIPE_SWIZZLE_ONE:
      for (j = 0; j < 4; j++)
         out[0][j] = 1.0f;
      break;
   default:
      assert(swizzle_r < 4);
      for (j = 0; j < 4; j++)
         out[0][j] = in[swizzle_r][j];
   }
d1675 18
a1692 14
   switch (swizzle_g) {
   case PIPE_SWIZZLE_ZERO:
      for (j = 0; j < 4; j++)
         out[1][j] = 0.0f;
      break;
   case PIPE_SWIZZLE_ONE:
      for (j = 0; j < 4; j++)
         out[1][j] = 1.0f;
      break;
   default:
      assert(swizzle_g < 4);
      for (j = 0; j < 4; j++)
         out[1][j] = in[swizzle_g][j];
   }
d1694 30
a1723 13
   switch (swizzle_b) {
   case PIPE_SWIZZLE_ZERO:
      for (j = 0; j < 4; j++)
         out[2][j] = 0.0f;
      break;
   case PIPE_SWIZZLE_ONE:
      for (j = 0; j < 4; j++)
         out[2][j] = 1.0f;
      break;
   default:
      assert(swizzle_b < 4);
      for (j = 0; j < 4; j++)
         out[2][j] = in[swizzle_b][j];
d1726 5
a1730 14
   switch (swizzle_a) {
   case PIPE_SWIZZLE_ZERO:
      for (j = 0; j < 4; j++)
         out[3][j] = 0.0f;
      break;
   case PIPE_SWIZZLE_ONE:
      for (j = 0; j < 4; j++)
         out[3][j] = 1.0f;
      break;
   default:
      assert(swizzle_a < 4);
      for (j = 0; j < 4; j++)
         out[3][j] = in[swizzle_a][j];
   }
d1734 1
d1823 2
a1824 5
/**
 * Is swizzling needed for the given state key?
 */
static INLINE bool
any_swizzle(const struct pipe_sampler_view *view)
d1826 16
a1841 4
   return (view->swizzle_r != PIPE_SWIZZLE_RED ||
           view->swizzle_g != PIPE_SWIZZLE_GREEN ||
           view->swizzle_b != PIPE_SWIZZLE_BLUE ||
           view->swizzle_a != PIPE_SWIZZLE_ALPHA);
d1845 4
a1848 4
static img_filter_func
get_img_filter(const struct sp_sampler_view *sp_sview,
               const struct pipe_sampler_state *sampler,
               unsigned filter)
d1850 1
a1850 2
   switch (sp_sview->base.texture->target) {
   case PIPE_BUFFER:
a1856 6
   case PIPE_TEXTURE_1D_ARRAY:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_1d_array_nearest;
      else
         return img_filter_1d_array_linear;
      break;
d1861 1
a1861 1
      if (sp_sview->pot2d &&
a1891 6
   case PIPE_TEXTURE_2D_ARRAY:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_2d_array_nearest;
      else
         return img_filter_2d_array_linear;
      break;
a1897 6
   case PIPE_TEXTURE_CUBE_ARRAY:
      if (filter == PIPE_TEX_FILTER_NEAREST) 
         return img_filter_cube_array_nearest;
      else
         return img_filter_cube_array_linear;
      break;
a1910 45
static void
sample_mip(struct sp_sampler_view *sp_sview,
           struct sp_sampler *sp_samp,
           const float s[TGSI_QUAD_SIZE],
           const float t[TGSI_QUAD_SIZE],
           const float p[TGSI_QUAD_SIZE],
           const float c0[TGSI_QUAD_SIZE],
           const float lod[TGSI_QUAD_SIZE],
           enum tgsi_sampler_control control,
           float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   mip_filter_func mip_filter;
   img_filter_func min_img_filter = NULL;
   img_filter_func mag_img_filter = NULL;

   if (sp_sview->pot2d & sp_samp->min_mag_equal_repeat_linear) {
      mip_filter = mip_filter_linear_2d_linear_repeat_POT;
   }
   else {
      mip_filter = sp_samp->mip_filter;
      min_img_filter = get_img_filter(sp_sview, &sp_samp->base, sp_samp->min_img_filter);
      if (sp_samp->min_mag_equal) {
         mag_img_filter = min_img_filter;
      }
      else {
         mag_img_filter = get_img_filter(sp_sview, &sp_samp->base, sp_samp->base.mag_img_filter);
      }
   }

   mip_filter(sp_sview, sp_samp, min_img_filter, mag_img_filter,
              s, t, p, c0, lod, control, rgba);

   if (sp_samp->base.compare_mode != PIPE_TEX_COMPARE_NONE) {
      sample_compare(sp_sview, sp_samp, s, t, p, c0, lod, control, rgba);
   }

   if (sp_sview->need_swizzle) {
      float rgba_temp[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
      memcpy(rgba_temp, rgba, sizeof(rgba_temp));
      do_swizzling(&sp_sview->base, rgba_temp, rgba);
   }

}


d1912 1
a1912 2
 * Use 3D texcoords to choose a cube face, then sample the 2D cube faces.
 * Put face info into the sampler faces[] array.
d1914 4
a1917 10
static void
sample_cube(struct sp_sampler_view *sp_sview,
            struct sp_sampler *sp_samp,
            const float s[TGSI_QUAD_SIZE],
            const float t[TGSI_QUAD_SIZE],
            const float p[TGSI_QUAD_SIZE],
            const float c0[TGSI_QUAD_SIZE],
            const float c1[TGSI_QUAD_SIZE],
            enum tgsi_sampler_control control,
            float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
d1919 1
a1919 7
   unsigned j;
   float ssss[4], tttt[4];

   /* Not actually used, but the intermediate steps that do the
    * dereferencing don't know it.
    */
   static float pppp[4] = { 0, 0, 0, 0 };
d1921 5
a1925 68
   pppp[0] = c0[0];
   pppp[1] = c0[1];
   pppp[2] = c0[2];
   pppp[3] = c0[3];
   /*
     major axis
     direction    target                             sc     tc    ma
     ----------   -------------------------------    ---    ---   ---
     +rx          TEXTURE_CUBE_MAP_POSITIVE_X_EXT    -rz    -ry   rx
     -rx          TEXTURE_CUBE_MAP_NEGATIVE_X_EXT    +rz    -ry   rx
     +ry          TEXTURE_CUBE_MAP_POSITIVE_Y_EXT    +rx    +rz   ry
     -ry          TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT    +rx    -rz   ry
     +rz          TEXTURE_CUBE_MAP_POSITIVE_Z_EXT    +rx    -ry   rz
     -rz          TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT    -rx    -ry   rz
   */

   /* Choose the cube face and compute new s/t coords for the 2D face.
    *
    * Use the same cube face for all four pixels in the quad.
    *
    * This isn't ideal, but if we want to use a different cube face
    * per pixel in the quad, we'd have to also compute the per-face
    * LOD here too.  That's because the four post-face-selection
    * texcoords are no longer related to each other (they're
    * per-face!)  so we can't use subtraction to compute the partial
    * deriviates to compute the LOD.  Doing so (near cube edges
    * anyway) gives us pretty much random values.
    */
   {
      /* use the average of the four pixel's texcoords to choose the face */
      const float rx = 0.25F * (s[0] + s[1] + s[2] + s[3]);
      const float ry = 0.25F * (t[0] + t[1] + t[2] + t[3]);
      const float rz = 0.25F * (p[0] + p[1] + p[2] + p[3]);
      const float arx = fabsf(rx), ary = fabsf(ry), arz = fabsf(rz);

      if (arx >= ary && arx >= arz) {
         float sign = (rx >= 0.0F) ? 1.0F : -1.0F;
         uint face = (rx >= 0.0F) ? PIPE_TEX_FACE_POS_X : PIPE_TEX_FACE_NEG_X;
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(s[j]);
            ssss[j] = sign *  p[j] * ima + 0.5F;
            tttt[j] =         t[j] * ima + 0.5F;
            sp_sview->faces[j] = face;
         }
      }
      else if (ary >= arx && ary >= arz) {
         float sign = (ry >= 0.0F) ? 1.0F : -1.0F;
         uint face = (ry >= 0.0F) ? PIPE_TEX_FACE_POS_Y : PIPE_TEX_FACE_NEG_Y;
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(t[j]);
            ssss[j] =        -s[j] * ima + 0.5F;
            tttt[j] = sign * -p[j] * ima + 0.5F;
            sp_sview->faces[j] = face;
         }
      }
      else {
         float sign = (rz >= 0.0F) ? 1.0F : -1.0F;
         uint face = (rz >= 0.0F) ? PIPE_TEX_FACE_POS_Z : PIPE_TEX_FACE_NEG_Z;
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            const float ima = -0.5F / fabsf(p[j]);
            ssss[j] = sign * -s[j] * ima + 0.5F;
            tttt[j] =         t[j] * ima + 0.5F;
            sp_sview->faces[j] = face;
         }
      }
   }

   sample_mip(sp_sview, sp_samp, ssss, tttt, pppp, c0, c1, control, rgba);
d1929 2
a1930 3
static void
sp_get_dims(struct sp_sampler_view *sp_sview, int level,
            int dims[4])
d1932 2
a1933 7
   const struct pipe_sampler_view *view = &sp_sview->base;
   const struct pipe_resource *texture = view->texture;

   /* undefined according to EXT_gpu_program */
   level += view->u.tex.first_level;
   if (level > view->u.tex.last_level)
      return;
a1934 32
   dims[0] = u_minify(texture->width0, level);

   switch(texture->target) {
   case PIPE_TEXTURE_1D_ARRAY:
      dims[1] = view->u.tex.last_layer - view->u.tex.first_layer + 1;
      /* fallthrough */
   case PIPE_TEXTURE_1D:
      return;
   case PIPE_TEXTURE_2D_ARRAY:
      dims[2] = view->u.tex.last_layer - view->u.tex.first_layer + 1;
      /* fallthrough */
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_CUBE:
   case PIPE_TEXTURE_RECT:
      dims[1] = u_minify(texture->height0, level);
      return;
   case PIPE_TEXTURE_3D:
      dims[1] = u_minify(texture->height0, level);
      dims[2] = u_minify(texture->depth0, level);
      return;
   case PIPE_TEXTURE_CUBE_ARRAY:
      dims[1] = u_minify(texture->height0, level);
      dims[2] = (view->u.tex.last_layer - view->u.tex.first_layer + 1) / 6;
      break;
   case PIPE_BUFFER:
      dims[0] /= util_format_get_blocksize(view->format);
      return;
   default:
      assert(!"unexpected texture target in sp_get_dims()");
      return;
   }
}
d1937 1
a1937 4
 * This function is only used for getting unfiltered texels via the
 * TXF opcode.  The GL spec says that out-of-bounds texel fetches
 * produce undefined results.  Instead of crashing, lets just clamp
 * coords to the texture image size.
d1939 3
a1941 8
static void
sp_get_texels(struct sp_sampler_view *sp_sview,
              const int v_i[TGSI_QUAD_SIZE],
              const int v_j[TGSI_QUAD_SIZE],
              const int v_k[TGSI_QUAD_SIZE],
              const int lod[TGSI_QUAD_SIZE],
              const int8_t offset[3],
              float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
d1943 3
a1945 80
   union tex_tile_address addr;
   const struct pipe_resource *texture = sp_sview->base.texture;
   int j, c;
   const float *tx;
   int width, height, depth;

   addr.value = 0;
   /* TODO write a better test for LOD */
   addr.bits.level = lod[0];

   width = u_minify(texture->width0, addr.bits.level);
   height = u_minify(texture->height0, addr.bits.level);
   depth = u_minify(texture->depth0, addr.bits.level);

   switch(texture->target) {
   case PIPE_BUFFER:
   case PIPE_TEXTURE_1D:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         tx = get_texel_2d_no_border(sp_sview, addr, x, 0);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_1D_ARRAY:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         int y = CLAMP(v_j[j], sp_sview->base.u.tex.first_layer, sp_sview->base.u.tex.last_layer);
         tx = get_texel_2d_no_border(sp_sview, addr, x, y);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         int y = CLAMP(v_j[j] + offset[1], 0, height - 1);
         tx = get_texel_2d_no_border(sp_sview, addr, x, y);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_2D_ARRAY:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         int y = CLAMP(v_j[j] + offset[1], 0, height - 1);
         int layer = CLAMP(v_k[j], sp_sview->base.u.tex.first_layer, sp_sview->base.u.tex.last_layer);
         tx = get_texel_3d_no_border(sp_sview, addr, x, y, layer);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_3D:
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = CLAMP(v_i[j] + offset[0], 0, width - 1);
         int y = CLAMP(v_j[j] + offset[1], 0, height - 1);
         int z = CLAMP(v_k[j] + offset[2], 0, depth - 1);
         tx = get_texel_3d_no_border(sp_sview, addr, x, y, z);
         for (c = 0; c < 4; c++) {
            rgba[c][j] = tx[c];
         }
      }
      break;
   case PIPE_TEXTURE_CUBE: /* TXF can't work on CUBE according to spec */
   default:
      assert(!"Unknown or CUBE texture type in TXF processing\n");
      break;
   }

   if (sp_sview->need_swizzle) {
      float rgba_temp[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE];
      memcpy(rgba_temp, rgba, sizeof(rgba_temp));
      do_swizzling(&sp_sview->base, rgba_temp, rgba);
   }
}
d1947 2
a1948 8

void *
softpipe_create_sampler_state(struct pipe_context *pipe,
                              const struct pipe_sampler_state *sampler)
{
   struct sp_sampler *samp = CALLOC_STRUCT(sp_sampler);

   samp->base = *sampler;
d1958 1
a1958 1

d1967 1
a1967 1

d1972 2
d1975 2
a1976 1
   samp->min_img_filter = sampler->min_img_filter;
d1980 2
a1981 2
      if (sampler->min_img_filter == sampler->mag_img_filter)
         samp->mip_filter = mip_filter_none_no_filter_select;
d1991 2
a1992 1
      if (sampler->min_img_filter == sampler->mag_img_filter &&
d1996 3
a1998 3
          sampler->min_img_filter == PIPE_TEX_FILTER_LINEAR &&
          sampler->max_anisotropy <= 1) {
         samp->min_mag_equal_repeat_linear = TRUE;
d2000 3
a2002 20
      samp->mip_filter = mip_filter_linear;

      /* Anisotropic filtering extension. */
      if (sampler->max_anisotropy > 1) {
         samp->mip_filter = mip_filter_linear_aniso;

         /* Override min_img_filter:
          * min_img_filter needs to be set to NEAREST since we need to access
          * each texture pixel as it is and weight it later; using linear
          * filters will have incorrect results.
          * By setting the filter to NEAREST here, we can avoid calling the
          * generic img_filter_2d_nearest in the anisotropic filter function,
          * making it possible to use one of the accelerated implementations
          */
         samp->min_img_filter = PIPE_TEX_FILTER_NEAREST;

         /* on first access create the lookup table containing the filter weights. */
        if (!weightLut) {
           create_filter_table();
        }
d2006 3
a2008 2
   if (samp->min_img_filter == sampler->mag_img_filter) {
      samp->min_mag_equal = TRUE;
d2010 9
a2018 27

   return (void *)samp;
}


compute_lambda_func
softpipe_get_lambda_func(const struct pipe_sampler_view *view, unsigned shader)
{
   if (shader != PIPE_SHADER_FRAGMENT)
      return compute_lambda_vert;

   switch (view->texture->target) {
   case PIPE_BUFFER:
   case PIPE_TEXTURE_1D:
   case PIPE_TEXTURE_1D_ARRAY:
      return compute_lambda_1d;
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_2D_ARRAY:
   case PIPE_TEXTURE_RECT:
   case PIPE_TEXTURE_CUBE:
   case PIPE_TEXTURE_CUBE_ARRAY:
      return compute_lambda_2d;
   case PIPE_TEXTURE_3D:
      return compute_lambda_3d;
   default:
      assert(0);
      return compute_lambda_1d;
d2020 5
a2024 1
}
d2026 4
a2029 33

struct pipe_sampler_view *
softpipe_create_sampler_view(struct pipe_context *pipe,
                             struct pipe_resource *resource,
                             const struct pipe_sampler_view *templ)
{
   struct sp_sampler_view *sview = CALLOC_STRUCT(sp_sampler_view);
   struct softpipe_resource *spr = (struct softpipe_resource *)resource;

   if (sview) {
      struct pipe_sampler_view *view = &sview->base;
      *view = *templ;
      view->reference.count = 1;
      view->texture = NULL;
      pipe_resource_reference(&view->texture, resource);
      view->context = pipe;

      if (any_swizzle(view)) {
         sview->need_swizzle = TRUE;
      }

      if (resource->target == PIPE_TEXTURE_CUBE ||
          resource->target == PIPE_TEXTURE_CUBE_ARRAY)
         sview->get_samples = sample_cube;
      else {
         sview->get_samples = sample_mip;
      }
      sview->pot2d = spr->pot &&
                     (resource->target == PIPE_TEXTURE_2D ||
                      resource->target == PIPE_TEXTURE_RECT);

      sview->xpot = util_logbase2( resource->width0 );
      sview->ypot = util_logbase2( resource->height0 );
a2031 72
   return (struct pipe_sampler_view *) sview;
}


static void
sp_tgsi_get_dims(struct tgsi_sampler *tgsi_sampler,
                 const unsigned sview_index,
                 int level, int dims[4])
{
   struct sp_tgsi_sampler *sp_samp = (struct sp_tgsi_sampler *)tgsi_sampler;

   assert(sview_index < PIPE_MAX_SHADER_SAMPLER_VIEWS);
   /* TODO should have defined behavior if no texture is bound. */
   sp_get_dims(&sp_samp->sp_sview[sview_index], level, dims);
}


static void
sp_tgsi_get_samples(struct tgsi_sampler *tgsi_sampler,
                    const unsigned sview_index,
                    const unsigned sampler_index,
                    const float s[TGSI_QUAD_SIZE],
                    const float t[TGSI_QUAD_SIZE],
                    const float p[TGSI_QUAD_SIZE],
                    const float c0[TGSI_QUAD_SIZE],
                    const float lod[TGSI_QUAD_SIZE],
                    float derivs[3][2][TGSI_QUAD_SIZE],
                    const int8_t offset[3],
                    enum tgsi_sampler_control control,
                    float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   struct sp_tgsi_sampler *sp_samp = (struct sp_tgsi_sampler *)tgsi_sampler;

   assert(sview_index < PIPE_MAX_SHADER_SAMPLER_VIEWS);
   assert(sampler_index < PIPE_MAX_SAMPLERS);
   assert(sp_samp->sp_sampler[sampler_index]);
   /* FIXME should have defined behavior if no texture is bound. */
   assert(sp_samp->sp_sview[sview_index].get_samples);
   sp_samp->sp_sview[sview_index].get_samples(&sp_samp->sp_sview[sview_index],
                                              sp_samp->sp_sampler[sampler_index],
                                              s, t, p, c0, lod, control, rgba);
}


static void
sp_tgsi_get_texel(struct tgsi_sampler *tgsi_sampler,
                  const unsigned sview_index,
                  const int i[TGSI_QUAD_SIZE],
                  const int j[TGSI_QUAD_SIZE], const int k[TGSI_QUAD_SIZE],
                  const int lod[TGSI_QUAD_SIZE], const int8_t offset[3],
                  float rgba[TGSI_NUM_CHANNELS][TGSI_QUAD_SIZE])
{
   struct sp_tgsi_sampler *sp_samp = (struct sp_tgsi_sampler *)tgsi_sampler;

   assert(sview_index < PIPE_MAX_SHADER_SAMPLER_VIEWS);
   /* FIXME should have defined behavior if no texture is bound. */
   assert(sp_samp->sp_sview[sview_index].base.texture);
   sp_get_texels(&sp_samp->sp_sview[sview_index], i, j, k, lod, offset, rgba);
}


struct sp_tgsi_sampler *
sp_create_tgsi_sampler(void)
{
   struct sp_tgsi_sampler *samp = CALLOC_STRUCT(sp_tgsi_sampler);
   if (!samp)
      return NULL;

   samp->base.get_dims = sp_tgsi_get_dims;
   samp->base.get_samples = sp_tgsi_get_samples;
   samp->base.get_texel = sp_tgsi_get_texel;

a2033 1

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a610 42

/*
 * Here's the complete logic (HOLY CRAP) for finding next face and doing the
 * corresponding coord wrapping, implemented by get_next_face,
 * get_next_xcoord, get_next_ycoord.
 * Read like that (first line):
 * If face is +x and s coord is below zero, then
 * new face is +z, new s is max , new t is old t
 * (max is always cube size - 1).
 *
 * +x s- -> +z: s = max,   t = t
 * +x s+ -> -z: s = 0,     t = t
 * +x t- -> +y: s = max,   t = max-s
 * +x t+ -> -y: s = max,   t = s
 *
 * -x s- -> -z: s = max,   t = t
 * -x s+ -> +z: s = 0,     t = t
 * -x t- -> +y: s = 0,     t = s
 * -x t+ -> -y: s = 0,     t = max-s
 *
 * +y s- -> -x: s = t,     t = 0
 * +y s+ -> +x: s = max-t, t = 0
 * +y t- -> -z: s = max-s, t = 0
 * +y t+ -> +z: s = s,     t = 0
 *
 * -y s- -> -x: s = max-t, t = max
 * -y s+ -> +x: s = t,     t = max
 * -y t- -> +z: s = s,     t = max
 * -y t+ -> -z: s = max-s, t = max

 * +z s- -> -x: s = max,   t = t
 * +z s+ -> +x: s = 0,     t = t
 * +z t- -> +y: s = s,     t = max
 * +z t+ -> -y: s = s,     t = 0

 * -z s- -> +x: s = max,   t = t
 * -z s+ -> -x: s = 0,     t = t
 * -z t- -> +y: s = max-s, t = 0
 * -z t+ -> -y: s = max-s, t = max
 */


d620 1
a620 1
     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },
d623 1
a623 1
     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },
d628 1
a628 1
     PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z },
d632 1
a632 1
     PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z },
d637 1
a637 1
     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },
d641 1
a641 1
     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y }
d645 1
a645 1
get_next_face(unsigned face, int idx)
d647 1
a647 2
   return face_array[face][idx];
}
d649 10
a658 37
/*
 * return a new xcoord based on old face, old coords, cube size
 * and fall_off_index (0 for x-, 1 for x+, 2 for y-, 3 for y+)
 */
static INLINE int
get_next_xcoord(unsigned face, unsigned fall_off_index, int max, int xc, int yc)
{
   if ((face == 0 && fall_off_index != 1) ||
       (face == 1 && fall_off_index == 0) ||
       (face == 4 && fall_off_index == 0) ||
       (face == 5 && fall_off_index == 0)) {
      return max;
   }
   if ((face == 1 && fall_off_index != 0) ||
       (face == 0 && fall_off_index == 1) ||
       (face == 4 && fall_off_index == 1) ||
       (face == 5 && fall_off_index == 1)) {
      return 0;
   }
   if ((face == 4 && fall_off_index >= 2) ||
       (face == 2 && fall_off_index == 3) ||
       (face == 3 && fall_off_index == 2)) {
      return xc;
   }
   if ((face == 5 && fall_off_index >= 2) ||
       (face == 2 && fall_off_index == 2) ||
       (face == 3 && fall_off_index == 3)) {
      return max - xc;
   }
   if ((face == 2 && fall_off_index == 0) ||
       (face == 3 && fall_off_index == 1)) {
      return yc;
   }
   /* (face == 2 && fall_off_index == 1) ||
      (face == 3 && fall_off_index == 0)) */
   return max - yc;
}
d660 1
a660 27
/*
 * return a new ycoord based on old face, old coords, cube size
 * and fall_off_index (0 for x-, 1 for x+, 2 for y-, 3 for y+)
 */
static INLINE int
get_next_ycoord(unsigned face, unsigned fall_off_index, int max, int xc, int yc)
{
   if ((fall_off_index <= 1) && (face <= 1 || face >= 4)) {
      return yc;
   }
   if (face == 2 ||
       (face == 4 && fall_off_index == 3) ||
       (face == 5 && fall_off_index == 2)) {
      return 0;
   }
   if (face == 3 ||
       (face == 4 && fall_off_index == 2) ||
       (face == 5 && fall_off_index == 3)) {
      return max;
   }
   if ((face == 0 && fall_off_index == 3) ||
       (face == 1 && fall_off_index == 2)) {
      return xc;
   }
   /* (face == 0 && fall_off_index == 2) ||
      (face == 1 && fall_off_index == 3) */
   return max - xc;
a662 1

d671 3
a673 1
   int new_x, new_y, max_x;
d676 1
a676 2

   assert(texture->width0 == texture->height0);
d680 16
d698 2
a699 16
      /*
       * Cheat with corners. They are difficult and I believe because we don't get
       * per-pixel faces we can actually have multiple corner texels per pixel,
       * which screws things up majorly in any case (as the per spec behavior is
       * to average the 3 remaining texels, which we might not have).
       * Hence just make sure that the 2nd coord is clamped, will simply pick the
       * sample which would have fallen off the x coord, but not y coord.
       * So the filter weight of the samples will be wrong, but at least this
       * ensures that only valid texels near the corner are used.
       */
      if (y < 0 || y >= max_x) {
         y = CLAMP(y, 0, max_x - 1);
      }
      new_x = get_next_xcoord(face, 0, max_x -1, x, y);
      new_y = get_next_ycoord(face, 0, max_x -1, x, y);
      face = get_next_face(face, 0);
d701 2
a702 6
      if (y < 0 || y >= max_x) {
         y = CLAMP(y, 0, max_x - 1);
      }
      new_x = get_next_xcoord(face, 1, max_x -1, x, y);
      new_y = get_next_ycoord(face, 1, max_x -1, x, y);
      face = get_next_face(face, 1);
d704 5
a708 7
      new_x = get_next_xcoord(face, 2, max_x -1, x, y);
      new_y = get_next_ycoord(face, 2, max_x -1, x, y);
      face = get_next_face(face, 2);
   } else if (y >= max_x) {
      new_x = get_next_xcoord(face, 3, max_x -1, x, y);
      new_y = get_next_ycoord(face, 3, max_x -1, x, y);
      face = get_next_face(face, 3);
a1243 1
      /* Would probably make sense to ignore mode and just do edge clamp */
a1527 1
      /* Note this is a bit overkill, actual clamping is not required */
a1530 1
      /* Would probably make sense to ignore mode and just do edge clamp */
d2294 3
a2296 5
   int j;
   int k[4];
   float pc[4];
   const struct util_format_description *format_desc;
   unsigned chan_type;
d2307 4
a2310 4
      pc[0] = c0[0];
      pc[1] = c0[1];
      pc[2] = c0[2];
      pc[3] = c0[3];
d2312 4
a2315 4
      pc[0] = c1[0];
      pc[1] = c1[1];
      pc[2] = c1[2];
      pc[3] = c1[3];
d2317 4
a2320 4
      pc[0] = p[0];
      pc[1] = p[1];
      pc[2] = p[2];
      pc[3] = p[3];
a2321 18

   format_desc = util_format_description(sp_sview->base.format);
   /* not entirely sure we couldn't end up with non-valid swizzle here */
   chan_type = format_desc->swizzle[0] <= UTIL_FORMAT_SWIZZLE_W ?
                  format_desc->channel[format_desc->swizzle[0]].type :
                  UTIL_FORMAT_TYPE_FLOAT;
   if (chan_type != UTIL_FORMAT_TYPE_FLOAT) {
      /*
       * clamping is a result of conversion to texture format, hence
       * doesn't happen with floats. Technically also should do comparison
       * in texture format (quantization!).
       */
      pc[0] = CLAMP(pc[0], 0.0F, 1.0F);
      pc[1] = CLAMP(pc[1], 0.0F, 1.0F);
      pc[2] = CLAMP(pc[2], 0.0F, 1.0F);
      pc[3] = CLAMP(pc[3], 0.0F, 1.0F);
   }

d2325 4
a2328 4
      k[0] = pc[0] < rgba[0][0];
      k[1] = pc[1] < rgba[0][1];
      k[2] = pc[2] < rgba[0][2];
      k[3] = pc[3] < rgba[0][3];
d2331 4
a2334 4
      k[0] = pc[0] <= rgba[0][0];
      k[1] = pc[1] <= rgba[0][1];
      k[2] = pc[2] <= rgba[0][2];
      k[3] = pc[3] <= rgba[0][3];
d2337 4
a2340 4
      k[0] = pc[0] > rgba[0][0];
      k[1] = pc[1] > rgba[0][1];
      k[2] = pc[2] > rgba[0][2];
      k[3] = pc[3] > rgba[0][3];
d2343 4
a2346 4
      k[0] = pc[0] >= rgba[0][0];
      k[1] = pc[1] >= rgba[0][1];
      k[2] = pc[2] >= rgba[0][2];
      k[3] = pc[3] >= rgba[0][3];
d2349 4
a2352 4
      k[0] = pc[0] == rgba[0][0];
      k[1] = pc[1] == rgba[0][1];
      k[2] = pc[2] == rgba[0][2];
      k[3] = pc[3] == rgba[0][3];
d2355 4
a2358 4
      k[0] = pc[0] != rgba[0][0];
      k[1] = pc[1] != rgba[0][1];
      k[2] = pc[2] != rgba[0][2];
      k[3] = pc[3] != rgba[0][3];
d2361 1
a2361 1
      k[0] = k[1] = k[2] = k[3] = 1;
d2364 1
a2364 1
      k[0] = k[1] = k[2] = k[3] = 0;
d2367 1
a2367 1
      k[0] = k[1] = k[2] = k[3] = 0;
d2372 22
a2393 5
   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      rgba[0][j] = k[j];
      rgba[1][j] = k[j];
      rgba[2][j] = k[j];
      rgba[3][j] = 1.0F;
d3095 1
a3095 5
   /* always have a view here but texture is NULL if no sampler view was set. */
   if (!sp_samp->sp_sview[sview_index].base.texture) {
      dims[0] = dims[1] = dims[2] = dims[3] = 0;
      return;
   }
d3119 2
a3120 10
   /* always have a view here but texture is NULL if no sampler view was set. */
   if (!sp_samp->sp_sview[sview_index].base.texture) {
      int i, j;
      for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
            rgba[j][i] = 0.0f;
         }
      }
      return;
   }
d3138 2
a3139 10
   /* always have a view here but texture is NULL if no sampler view was set. */
   if (!sp_samp->sp_sview[sview_index].base.texture) {
      int i, j;
      for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
         for (i = 0; i < TGSI_QUAD_SIZE; i++) {
            rgba[j][i] = 0.0f;
         }
      }
      return;
   }
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d1863 1
a1863 1
   const struct pipe_sampler_view *psview = &sp_sview->base;
d1870 1
a1870 1
      int level0 = psview->u.tex.first_level + (int)lod[j];
d1874 1
a1874 1
                    psview->u.tex.first_level,
d1877 2
a1878 2
      else if (level0 >= (int) psview->u.tex.last_level)
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], psview->u.tex.last_level,
d1921 1
a1921 1
   const struct pipe_sampler_view *psview = &sp_sview->base;
d1930 1
a1930 1
                    psview->u.tex.first_level,
d1933 2
a1934 2
         int level = psview->u.tex.first_level + (int)(lod[j] + 0.5F);
         level = MIN2(level, (int)psview->u.tex.last_level);
a2232 1
   const struct pipe_sampler_view *psview = &sp_sview->base;
d2237 2
a2238 2
   float s_to_u = u_minify(texture->width0, psview->u.tex.first_level);
   float t_to_v = u_minify(texture->height0, psview->u.tex.first_level);
d2295 1
a2295 1
   level0 = psview->u.tex.first_level + (int)lambda;
d2300 1
a2300 1
   if (level0 >= (int) psview->u.tex.last_level) {
d2303 1
a2303 1
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], psview->u.tex.last_level,
d2339 1
a2339 1
   const struct pipe_sampler_view *psview = &sp_sview->base;
d2346 1
a2346 1
      int level0 = psview->u.tex.first_level + (int)lod[j];
d2350 1
a2350 1
      if ((unsigned)level0 >= psview->u.tex.last_level) {
d2353 1
a2353 1
                                            psview->u.tex.first_level,
d2357 1
a2357 1
                                            psview->u.tex.last_level,
d2588 1
a2588 1
      debug_printf("illegal wrap mode %d with non-normalized coords\n", mode);
d2632 1
a2632 1
      debug_printf("illegal wrap mode %d with non-normalized coords\n", mode);
a2908 9
   if (texture->target == PIPE_BUFFER) {
      dims[0] = (view->u.buf.last_element - view->u.buf.first_element) + 1;
      /* the other values are undefined, but let's avoid potential valgrind
       * warnings.
       */
      dims[1] = dims[2] = dims[3] = 0;
      return;
   }

a2913 1
   dims[3] = view->u.tex.last_level - view->u.tex.first_level + 1;
d2938 3
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d1863 1
a1863 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1870 1
a1870 1
      int level0 = sp_sview->base.u.tex.first_level + (int)lod[j];
d1874 1
a1874 1
                    sp_sview->base.u.tex.first_level,
d1877 2
a1878 2
      else if (level0 >= (int) texture->last_level)
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], texture->last_level,
d1921 1
a1921 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d1930 1
a1930 1
                    sp_sview->base.u.tex.first_level,
d1933 2
a1934 2
         int level = sp_sview->base.u.tex.first_level + (int)(lod[j] + 0.5F);
         level = MIN2(level, (int)texture->last_level);
d2233 1
d2238 2
a2239 2
   float s_to_u = u_minify(texture->width0, sp_sview->base.u.tex.first_level);
   float t_to_v = u_minify(texture->height0, sp_sview->base.u.tex.first_level);
d2296 1
a2296 1
   level0 = sp_sview->base.u.tex.first_level + (int)lambda;
d2301 1
a2301 1
   if (level0 >= (int) texture->last_level) {
d2304 1
a2304 1
         min_filter(sp_sview, sp_samp, s[j], t[j], p[j], texture->last_level,
d2340 1
a2340 1
   const struct pipe_resource *texture = sp_sview->base.texture;
d2347 1
a2347 1
      int level0 = sp_sview->base.u.tex.first_level + (int)lod[j];
d2351 1
a2351 1
      if ((unsigned)level0 >= texture->last_level) { 
d2354 1
a2354 1
                                            sp_sview->base.u.tex.first_level,
d2358 1
a2358 1
                                            sp_sview->base.texture->last_level,
d2589 1
a2589 1
      assert(0);
d2633 1
a2633 1
      assert(0);
d2910 9
d2924 1
a2948 3
   case PIPE_BUFFER:
      dims[0] /= util_format_get_blocksize(view->format);
      return;
@


