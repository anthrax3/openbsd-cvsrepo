head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.05;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.52;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.46;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.01;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * quad blending
 * \author Brian Paul
 */

#include "pipe/p_defines.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_format.h"
#include "util/u_dual_blend.h"
#include "sp_context.h"
#include "sp_state.h"
#include "sp_quad.h"
#include "sp_tile_cache.h"
#include "sp_quad_pipe.h"


enum format
{
   RGBA,
   RGB,
   LUMINANCE,
   LUMINANCE_ALPHA,
   INTENSITY
};


/** Subclass of quad_stage */
struct blend_quad_stage
{
   struct quad_stage base;
   boolean clamp[PIPE_MAX_COLOR_BUFS];  /**< clamp colors to [0,1]? */
   enum format base_format[PIPE_MAX_COLOR_BUFS];
   enum util_format_type format_type[PIPE_MAX_COLOR_BUFS];
};


/** cast wrapper */
static INLINE struct blend_quad_stage *
blend_quad_stage(struct quad_stage *stage)
{
   return (struct blend_quad_stage *) stage;
}


#define VEC4_COPY(DST, SRC) \
do { \
    DST[0] = SRC[0]; \
    DST[1] = SRC[1]; \
    DST[2] = SRC[2]; \
    DST[3] = SRC[3]; \
} while(0)

#define VEC4_SCALAR(DST, SRC) \
do { \
    DST[0] = SRC; \
    DST[1] = SRC; \
    DST[2] = SRC; \
    DST[3] = SRC; \
} while(0)

#define VEC4_ADD(R, A, B) \
do { \
   R[0] = A[0] + B[0]; \
   R[1] = A[1] + B[1]; \
   R[2] = A[2] + B[2]; \
   R[3] = A[3] + B[3]; \
} while (0)

#define VEC4_SUB(R, A, B) \
do { \
   R[0] = A[0] - B[0]; \
   R[1] = A[1] - B[1]; \
   R[2] = A[2] - B[2]; \
   R[3] = A[3] - B[3]; \
} while (0)

/** Add and limit result to ceiling of 1.0 */
#define VEC4_ADD_SAT(R, A, B) \
do { \
   R[0] = A[0] + B[0];  if (R[0] > 1.0f) R[0] = 1.0f; \
   R[1] = A[1] + B[1];  if (R[1] > 1.0f) R[1] = 1.0f; \
   R[2] = A[2] + B[2];  if (R[2] > 1.0f) R[2] = 1.0f; \
   R[3] = A[3] + B[3];  if (R[3] > 1.0f) R[3] = 1.0f; \
} while (0)

/** Subtract and limit result to floor of 0.0 */
#define VEC4_SUB_SAT(R, A, B) \
do { \
   R[0] = A[0] - B[0];  if (R[0] < 0.0f) R[0] = 0.0f; \
   R[1] = A[1] - B[1];  if (R[1] < 0.0f) R[1] = 0.0f; \
   R[2] = A[2] - B[2];  if (R[2] < 0.0f) R[2] = 0.0f; \
   R[3] = A[3] - B[3];  if (R[3] < 0.0f) R[3] = 0.0f; \
} while (0)

#define VEC4_MUL(R, A, B) \
do { \
   R[0] = A[0] * B[0]; \
   R[1] = A[1] * B[1]; \
   R[2] = A[2] * B[2]; \
   R[3] = A[3] * B[3]; \
} while (0)

#define VEC4_MIN(R, A, B) \
do { \
   R[0] = (A[0] < B[0]) ? A[0] : B[0]; \
   R[1] = (A[1] < B[1]) ? A[1] : B[1]; \
   R[2] = (A[2] < B[2]) ? A[2] : B[2]; \
   R[3] = (A[3] < B[3]) ? A[3] : B[3]; \
} while (0)

#define VEC4_MAX(R, A, B) \
do { \
   R[0] = (A[0] > B[0]) ? A[0] : B[0]; \
   R[1] = (A[1] > B[1]) ? A[1] : B[1]; \
   R[2] = (A[2] > B[2]) ? A[2] : B[2]; \
   R[3] = (A[3] > B[3]) ? A[3] : B[3]; \
} while (0)



static void
logicop_quad(struct quad_stage *qs, 
             float (*quadColor)[4],
             float (*dest)[4])
{
   struct softpipe_context *softpipe = qs->softpipe;
   ubyte src[4][4], dst[4][4], res[4][4];
   uint *src4 = (uint *) src;
   uint *dst4 = (uint *) dst;
   uint *res4 = (uint *) res;
   uint j;


   /* convert to ubyte */
   for (j = 0; j < 4; j++) { /* loop over R,G,B,A channels */
      dst[j][0] = float_to_ubyte(dest[j][0]); /* P0 */
      dst[j][1] = float_to_ubyte(dest[j][1]); /* P1 */
      dst[j][2] = float_to_ubyte(dest[j][2]); /* P2 */
      dst[j][3] = float_to_ubyte(dest[j][3]); /* P3 */

      src[j][0] = float_to_ubyte(quadColor[j][0]); /* P0 */
      src[j][1] = float_to_ubyte(quadColor[j][1]); /* P1 */
      src[j][2] = float_to_ubyte(quadColor[j][2]); /* P2 */
      src[j][3] = float_to_ubyte(quadColor[j][3]); /* P3 */
   }

   switch (softpipe->blend->logicop_func) {
   case PIPE_LOGICOP_CLEAR:
      for (j = 0; j < 4; j++)
         res4[j] = 0;
      break;
   case PIPE_LOGICOP_NOR:
      for (j = 0; j < 4; j++)
         res4[j] = ~(src4[j] | dst4[j]);
      break;
   case PIPE_LOGICOP_AND_INVERTED:
      for (j = 0; j < 4; j++)
         res4[j] = ~src4[j] & dst4[j];
      break;
   case PIPE_LOGICOP_COPY_INVERTED:
      for (j = 0; j < 4; j++)
         res4[j] = ~src4[j];
      break;
   case PIPE_LOGICOP_AND_REVERSE:
      for (j = 0; j < 4; j++)
         res4[j] = src4[j] & ~dst4[j];
      break;
   case PIPE_LOGICOP_INVERT:
      for (j = 0; j < 4; j++)
         res4[j] = ~dst4[j];
      break;
   case PIPE_LOGICOP_XOR:
      for (j = 0; j < 4; j++)
         res4[j] = dst4[j] ^ src4[j];
      break;
   case PIPE_LOGICOP_NAND:
      for (j = 0; j < 4; j++)
         res4[j] = ~(src4[j] & dst4[j]);
      break;
   case PIPE_LOGICOP_AND:
      for (j = 0; j < 4; j++)
         res4[j] = src4[j] & dst4[j];
      break;
   case PIPE_LOGICOP_EQUIV:
      for (j = 0; j < 4; j++)
         res4[j] = ~(src4[j] ^ dst4[j]);
      break;
   case PIPE_LOGICOP_NOOP:
      for (j = 0; j < 4; j++)
         res4[j] = dst4[j];
      break;
   case PIPE_LOGICOP_OR_INVERTED:
      for (j = 0; j < 4; j++)
         res4[j] = ~src4[j] | dst4[j];
      break;
   case PIPE_LOGICOP_COPY:
      for (j = 0; j < 4; j++)
         res4[j] = src4[j];
      break;
   case PIPE_LOGICOP_OR_REVERSE:
      for (j = 0; j < 4; j++)
         res4[j] = src4[j] | ~dst4[j];
      break;
   case PIPE_LOGICOP_OR:
      for (j = 0; j < 4; j++)
         res4[j] = src4[j] | dst4[j];
      break;
   case PIPE_LOGICOP_SET:
      for (j = 0; j < 4; j++)
         res4[j] = ~0;
      break;
   default:
      assert(0 && "invalid logicop mode");
   }

   for (j = 0; j < 4; j++) {
      quadColor[j][0] = ubyte_to_float(res[j][0]);
      quadColor[j][1] = ubyte_to_float(res[j][1]);
      quadColor[j][2] = ubyte_to_float(res[j][2]);
      quadColor[j][3] = ubyte_to_float(res[j][3]);
   }
}



/**
 * Do blending for a 2x2 quad for one color buffer.
 * \param quadColor  the incoming quad colors
 * \param dest  the destination/framebuffer quad colors
 * \param const_blend_color  the constant blend color
 * \param blend_index  which set of blending terms to use
 */
static void
blend_quad(struct quad_stage *qs, 
           float (*quadColor)[4],
           float (*quadColor2)[4],
           float (*dest)[4],
           const float const_blend_color[4],
           unsigned blend_index)
{
   static const float zero[4] = { 0, 0, 0, 0 };
   static const float one[4] = { 1, 1, 1, 1 };
   struct softpipe_context *softpipe = qs->softpipe;
   float source[4][TGSI_QUAD_SIZE] = { { 0 } };
   float blend_dest[4][TGSI_QUAD_SIZE];

   /*
    * Compute src/first term RGB
    */
   switch (softpipe->blend->rt[blend_index].rgb_src_factor) {
   case PIPE_BLENDFACTOR_ONE:
      VEC4_COPY(source[0], quadColor[0]); /* R */
      VEC4_COPY(source[1], quadColor[1]); /* G */
      VEC4_COPY(source[2], quadColor[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_SRC_COLOR:
      VEC4_MUL(source[0], quadColor[0], quadColor[0]); /* R */
      VEC4_MUL(source[1], quadColor[1], quadColor[1]); /* G */
      VEC4_MUL(source[2], quadColor[2], quadColor[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA:
      {
         const float *alpha = quadColor[3];
         VEC4_MUL(source[0], quadColor[0], alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_DST_COLOR:
      VEC4_MUL(source[0], quadColor[0], dest[0]); /* R */
      VEC4_MUL(source[1], quadColor[1], dest[1]); /* G */
      VEC4_MUL(source[2], quadColor[2], dest[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_DST_ALPHA:
      {
         const float *alpha = dest[3];
         VEC4_MUL(source[0], quadColor[0], alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      } 
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
      {
         const float *alpha = quadColor[3];
         float diff[4], temp[4];
         VEC4_SUB(diff, one, dest[3]);
         VEC4_MIN(temp, alpha, diff);
         VEC4_MUL(source[0], quadColor[0], temp); /* R */
         VEC4_MUL(source[1], quadColor[1], temp); /* G */
         VEC4_MUL(source[2], quadColor[2], temp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_CONST_COLOR:
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[0]); /* R */
         VEC4_MUL(source[0], quadColor[0], comp); /* R */
         VEC4_SCALAR(comp, const_blend_color[1]); /* G */
         VEC4_MUL(source[1], quadColor[1], comp); /* G */
         VEC4_SCALAR(comp, const_blend_color[2]); /* B */
         VEC4_MUL(source[2], quadColor[2], comp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_CONST_ALPHA:
      {
         float alpha[4];
         VEC4_SCALAR(alpha, const_blend_color[3]);
         VEC4_MUL(source[0], quadColor[0], alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_SRC1_COLOR:
      VEC4_MUL(source[0], quadColor[0], quadColor2[0]); /* R */
      VEC4_MUL(source[1], quadColor[1], quadColor2[1]); /* G */
      VEC4_MUL(source[2], quadColor[2], quadColor2[2]); /* B */	 
      break;
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      {
         const float *alpha = quadColor2[3];
         VEC4_MUL(source[0], quadColor[0], alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_ZERO:
      VEC4_COPY(source[0], zero); /* R */
      VEC4_COPY(source[1], zero); /* G */
      VEC4_COPY(source[2], zero); /* B */
      break;
   case PIPE_BLENDFACTOR_INV_SRC_COLOR:
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, quadColor[0]); /* R */
         VEC4_MUL(source[0], quadColor[0], inv_comp); /* R */
         VEC4_SUB(inv_comp, one, quadColor[1]); /* G */
         VEC4_MUL(source[1], quadColor[1], inv_comp); /* G */
         VEC4_SUB(inv_comp, one, quadColor[2]); /* B */
         VEC4_MUL(source[2], quadColor[2], inv_comp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_SRC_ALPHA:
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, quadColor[3]);
         VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_DST_ALPHA:
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, dest[3]);
         VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_DST_COLOR:
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, dest[0]); /* R */
         VEC4_MUL(source[0], quadColor[0], inv_comp); /* R */
         VEC4_SUB(inv_comp, one, dest[1]); /* G */
         VEC4_MUL(source[1], quadColor[1], inv_comp); /* G */
         VEC4_SUB(inv_comp, one, dest[2]); /* B */
         VEC4_MUL(source[2], quadColor[2], inv_comp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_CONST_COLOR:
      {
         float inv_comp[4];
         /* R */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[0]);
         VEC4_MUL(source[0], quadColor[0], inv_comp);
         /* G */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[1]);
         VEC4_MUL(source[1], quadColor[1], inv_comp);
         /* B */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[2]);
         VEC4_MUL(source[2], quadColor[2], inv_comp);
      }
      break;
   case PIPE_BLENDFACTOR_INV_CONST_ALPHA:
      {
         float inv_alpha[4];
         VEC4_SCALAR(inv_alpha, 1.0f - const_blend_color[3]);
         VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, quadColor2[0]); /* R */
         VEC4_MUL(source[0], quadColor[0], inv_comp); /* R */
         VEC4_SUB(inv_comp, one, quadColor2[1]); /* G */
         VEC4_MUL(source[1], quadColor[1], inv_comp); /* G */
         VEC4_SUB(inv_comp, one, quadColor2[2]); /* B */
         VEC4_MUL(source[2], quadColor[2], inv_comp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, quadColor2[3]);
         VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
      }
      break;
   default:
      assert(0 && "invalid rgb src factor");
   }

   /*
    * Compute src/first term A
    */
   switch (softpipe->blend->rt[blend_index].alpha_src_factor) {
   case PIPE_BLENDFACTOR_ONE:
      VEC4_COPY(source[3], quadColor[3]); /* A */
      break;
   case PIPE_BLENDFACTOR_SRC_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_SRC_ALPHA:
      {
         const float *alpha = quadColor[3];
         VEC4_MUL(source[3], quadColor[3], alpha); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_DST_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_DST_ALPHA:
      VEC4_MUL(source[3], quadColor[3], dest[3]); /* A */
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
      /* multiply alpha by 1.0 */
      VEC4_COPY(source[3], quadColor[3]); /* A */
      break;
   case PIPE_BLENDFACTOR_CONST_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_CONST_ALPHA:
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[3]); /* A */
         VEC4_MUL(source[3], quadColor[3], comp); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_ZERO:
      VEC4_COPY(source[3], zero); /* A */
      break;
   case PIPE_BLENDFACTOR_INV_SRC_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_SRC_ALPHA:
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, quadColor[3]);
         VEC4_MUL(source[3], quadColor[3], inv_alpha); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_INV_DST_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_DST_ALPHA:
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, dest[3]);
         VEC4_MUL(source[3], quadColor[3], inv_alpha); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_INV_CONST_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_CONST_ALPHA:
      {
         float inv_comp[4];
         /* A */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[3]);
         VEC4_MUL(source[3], quadColor[3], inv_comp);
      }
      break;
   case PIPE_BLENDFACTOR_SRC1_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      {
         const float *alpha = quadColor2[3];
         VEC4_MUL(source[3], quadColor[3], alpha); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, quadColor2[3]);
         VEC4_MUL(source[3], quadColor[3], inv_alpha); /* A */
      }
      break;
   default:
      assert(0 && "invalid alpha src factor");
   }

   /* Save the original dest for use in masking */
   VEC4_COPY(blend_dest[0], dest[0]);
   VEC4_COPY(blend_dest[1], dest[1]);
   VEC4_COPY(blend_dest[2], dest[2]);
   VEC4_COPY(blend_dest[3], dest[3]);


   /*
    * Compute blend_dest/second term RGB
    */
   switch (softpipe->blend->rt[blend_index].rgb_dst_factor) {
   case PIPE_BLENDFACTOR_ONE:
      /* blend_dest = blend_dest * 1   NO-OP, leave blend_dest as-is */
      break;
   case PIPE_BLENDFACTOR_SRC_COLOR:
      VEC4_MUL(blend_dest[0], blend_dest[0], quadColor[0]); /* R */
      VEC4_MUL(blend_dest[1], blend_dest[1], quadColor[1]); /* G */
      VEC4_MUL(blend_dest[2], blend_dest[2], quadColor[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA:
      VEC4_MUL(blend_dest[0], blend_dest[0], quadColor[3]); /* R * A */
      VEC4_MUL(blend_dest[1], blend_dest[1], quadColor[3]); /* G * A */
      VEC4_MUL(blend_dest[2], blend_dest[2], quadColor[3]); /* B * A */
      break;
   case PIPE_BLENDFACTOR_DST_ALPHA:
      VEC4_MUL(blend_dest[0], blend_dest[0], blend_dest[3]); /* R * A */
      VEC4_MUL(blend_dest[1], blend_dest[1], blend_dest[3]); /* G * A */
      VEC4_MUL(blend_dest[2], blend_dest[2], blend_dest[3]); /* B * A */
      break;
   case PIPE_BLENDFACTOR_DST_COLOR:
      VEC4_MUL(blend_dest[0], blend_dest[0], blend_dest[0]); /* R */
      VEC4_MUL(blend_dest[1], blend_dest[1], blend_dest[1]); /* G */
      VEC4_MUL(blend_dest[2], blend_dest[2], blend_dest[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
      {
         const float *alpha = quadColor[3];
         float diff[4], temp[4];
         VEC4_SUB(diff, one, blend_dest[3]);
         VEC4_MIN(temp, alpha, diff);
         VEC4_MUL(blend_dest[0], blend_dest[0], temp); /* R */
         VEC4_MUL(blend_dest[1], blend_dest[1], temp); /* G */
         VEC4_MUL(blend_dest[2], blend_dest[2], temp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_CONST_COLOR:
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[0]); /* R */
         VEC4_MUL(blend_dest[0], blend_dest[0], comp); /* R */
         VEC4_SCALAR(comp, const_blend_color[1]); /* G */
         VEC4_MUL(blend_dest[1], blend_dest[1], comp); /* G */
         VEC4_SCALAR(comp, const_blend_color[2]); /* B */
         VEC4_MUL(blend_dest[2], blend_dest[2], comp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_CONST_ALPHA:
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[3]); /* A */
         VEC4_MUL(blend_dest[0], blend_dest[0], comp); /* R */
         VEC4_MUL(blend_dest[1], blend_dest[1], comp); /* G */
         VEC4_MUL(blend_dest[2], blend_dest[2], comp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_ZERO:
      VEC4_COPY(blend_dest[0], zero); /* R */
      VEC4_COPY(blend_dest[1], zero); /* G */
      VEC4_COPY(blend_dest[2], zero); /* B */
      break;
   case PIPE_BLENDFACTOR_SRC1_COLOR:
      VEC4_MUL(blend_dest[0], blend_dest[0], quadColor2[0]); /* R */
      VEC4_MUL(blend_dest[1], blend_dest[1], quadColor2[1]); /* G */
      VEC4_MUL(blend_dest[2], blend_dest[2], quadColor2[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      VEC4_MUL(blend_dest[0], blend_dest[0], quadColor2[3]); /* R * A */
      VEC4_MUL(blend_dest[1], blend_dest[1], quadColor2[3]); /* G * A */
      VEC4_MUL(blend_dest[2], blend_dest[2], quadColor2[3]); /* B * A */
      break;
   case PIPE_BLENDFACTOR_INV_SRC_COLOR:
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, quadColor[0]); /* R */
         VEC4_MUL(blend_dest[0], inv_comp, blend_dest[0]); /* R */
         VEC4_SUB(inv_comp, one, quadColor[1]); /* G */
         VEC4_MUL(blend_dest[1], inv_comp, blend_dest[1]); /* G */
         VEC4_SUB(inv_comp, one, quadColor[2]); /* B */
         VEC4_MUL(blend_dest[2], inv_comp, blend_dest[2]); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_SRC_ALPHA:
      {
         float one_minus_alpha[TGSI_QUAD_SIZE];
         VEC4_SUB(one_minus_alpha, one, quadColor[3]);
         VEC4_MUL(blend_dest[0], blend_dest[0], one_minus_alpha); /* R */
         VEC4_MUL(blend_dest[1], blend_dest[1], one_minus_alpha); /* G */
         VEC4_MUL(blend_dest[2], blend_dest[2], one_minus_alpha); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_DST_ALPHA:
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, blend_dest[3]); /* A */
         VEC4_MUL(blend_dest[0], inv_comp, blend_dest[0]); /* R */
         VEC4_MUL(blend_dest[1], inv_comp, blend_dest[1]); /* G */
         VEC4_MUL(blend_dest[2], inv_comp, blend_dest[2]); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_DST_COLOR:
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, blend_dest[0]); /* R */
         VEC4_MUL(blend_dest[0], blend_dest[0], inv_comp); /* R */
         VEC4_SUB(inv_comp, one, blend_dest[1]); /* G */
         VEC4_MUL(blend_dest[1], blend_dest[1], inv_comp); /* G */
         VEC4_SUB(inv_comp, one, blend_dest[2]); /* B */
         VEC4_MUL(blend_dest[2], blend_dest[2], inv_comp); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_CONST_COLOR:
      {
         float inv_comp[4];
         /* R */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[0]);
         VEC4_MUL(blend_dest[0], blend_dest[0], inv_comp);
         /* G */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[1]);
         VEC4_MUL(blend_dest[1], blend_dest[1], inv_comp);
         /* B */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[2]);
         VEC4_MUL(blend_dest[2], blend_dest[2], inv_comp);
      }
      break;
   case PIPE_BLENDFACTOR_INV_CONST_ALPHA:
      {
         float inv_comp[4];
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[3]);
         VEC4_MUL(blend_dest[0], blend_dest[0], inv_comp);
         VEC4_MUL(blend_dest[1], blend_dest[1], inv_comp);
         VEC4_MUL(blend_dest[2], blend_dest[2], inv_comp);
      }
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, quadColor2[0]); /* R */
         VEC4_MUL(blend_dest[0], inv_comp, blend_dest[0]); /* R */
         VEC4_SUB(inv_comp, one, quadColor2[1]); /* G */
         VEC4_MUL(blend_dest[1], inv_comp, blend_dest[1]); /* G */
         VEC4_SUB(inv_comp, one, quadColor2[2]); /* B */
         VEC4_MUL(blend_dest[2], inv_comp, blend_dest[2]); /* B */
      }
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      {
         float one_minus_alpha[TGSI_QUAD_SIZE];
         VEC4_SUB(one_minus_alpha, one, quadColor2[3]);
         VEC4_MUL(blend_dest[0], blend_dest[0], one_minus_alpha); /* R */
         VEC4_MUL(blend_dest[1], blend_dest[1], one_minus_alpha); /* G */
         VEC4_MUL(blend_dest[2], blend_dest[2], one_minus_alpha); /* B */
      }
      break;
   default:
      assert(0 && "invalid rgb dst factor");
   }

   /*
    * Compute blend_dest/second term A
    */
   switch (softpipe->blend->rt[blend_index].alpha_dst_factor) {
   case PIPE_BLENDFACTOR_ONE:
      /* blend_dest = blend_dest * 1   NO-OP, leave blend_dest as-is */
      break;
   case PIPE_BLENDFACTOR_SRC_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_SRC_ALPHA:
      VEC4_MUL(blend_dest[3], blend_dest[3], quadColor[3]); /* A * A */
      break;
   case PIPE_BLENDFACTOR_DST_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_DST_ALPHA:
      VEC4_MUL(blend_dest[3], blend_dest[3], blend_dest[3]); /* A */
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
      /* blend_dest = blend_dest * 1   NO-OP, leave blend_dest as-is */
      break;
   case PIPE_BLENDFACTOR_CONST_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_CONST_ALPHA:
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[3]); /* A */
         VEC4_MUL(blend_dest[3], blend_dest[3], comp); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_ZERO:
      VEC4_COPY(blend_dest[3], zero); /* A */
      break;
   case PIPE_BLENDFACTOR_INV_SRC_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_SRC_ALPHA:
      {
         float one_minus_alpha[TGSI_QUAD_SIZE];
         VEC4_SUB(one_minus_alpha, one, quadColor[3]);
         VEC4_MUL(blend_dest[3], blend_dest[3], one_minus_alpha); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_INV_DST_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_DST_ALPHA:
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, blend_dest[3]); /* A */
         VEC4_MUL(blend_dest[3], inv_comp, blend_dest[3]); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_INV_CONST_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_CONST_ALPHA:
      {
         float inv_comp[4];
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[3]);
         VEC4_MUL(blend_dest[3], blend_dest[3], inv_comp);
      }
      break;
   case PIPE_BLENDFACTOR_SRC1_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      VEC4_MUL(blend_dest[3], blend_dest[3], quadColor2[3]); /* A * A */
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      {
         float one_minus_alpha[TGSI_QUAD_SIZE];
         VEC4_SUB(one_minus_alpha, one, quadColor2[3]);
         VEC4_MUL(blend_dest[3], blend_dest[3], one_minus_alpha); /* A */
      }
      break;
   default:
      assert(0 && "invalid alpha dst factor");
   }

   /*
    * Combine RGB terms
    */
   switch (softpipe->blend->rt[blend_index].rgb_func) {
   case PIPE_BLEND_ADD:
      VEC4_ADD(quadColor[0], source[0], blend_dest[0]); /* R */
      VEC4_ADD(quadColor[1], source[1], blend_dest[1]); /* G */
      VEC4_ADD(quadColor[2], source[2], blend_dest[2]); /* B */
      break;
   case PIPE_BLEND_SUBTRACT:
      VEC4_SUB(quadColor[0], source[0], blend_dest[0]); /* R */
      VEC4_SUB(quadColor[1], source[1], blend_dest[1]); /* G */
      VEC4_SUB(quadColor[2], source[2], blend_dest[2]); /* B */
      break;
   case PIPE_BLEND_REVERSE_SUBTRACT:
      VEC4_SUB(quadColor[0], blend_dest[0], source[0]); /* R */
      VEC4_SUB(quadColor[1], blend_dest[1], source[1]); /* G */
      VEC4_SUB(quadColor[2], blend_dest[2], source[2]); /* B */
      break;
   case PIPE_BLEND_MIN:
      VEC4_MIN(quadColor[0], source[0], blend_dest[0]); /* R */
      VEC4_MIN(quadColor[1], source[1], blend_dest[1]); /* G */
      VEC4_MIN(quadColor[2], source[2], blend_dest[2]); /* B */
      break;
   case PIPE_BLEND_MAX:
      VEC4_MAX(quadColor[0], source[0], blend_dest[0]); /* R */
      VEC4_MAX(quadColor[1], source[1], blend_dest[1]); /* G */
      VEC4_MAX(quadColor[2], source[2], blend_dest[2]); /* B */
      break;
   default:
      assert(0 && "invalid rgb blend func");
   }

   /*
    * Combine A terms
    */
   switch (softpipe->blend->rt[blend_index].alpha_func) {
   case PIPE_BLEND_ADD:
      VEC4_ADD(quadColor[3], source[3], blend_dest[3]); /* A */
      break;
   case PIPE_BLEND_SUBTRACT:
      VEC4_SUB(quadColor[3], source[3], blend_dest[3]); /* A */
      break;
   case PIPE_BLEND_REVERSE_SUBTRACT:
      VEC4_SUB(quadColor[3], blend_dest[3], source[3]); /* A */
      break;
   case PIPE_BLEND_MIN:
      VEC4_MIN(quadColor[3], source[3], blend_dest[3]); /* A */
      break;
   case PIPE_BLEND_MAX:
      VEC4_MAX(quadColor[3], source[3], blend_dest[3]); /* A */
      break;
   default:
      assert(0 && "invalid alpha blend func");
   }
}

static void
colormask_quad(unsigned colormask,
               float (*quadColor)[4],
               float (*dest)[4])
{
   /* R */
   if (!(colormask & PIPE_MASK_R))
      COPY_4V(quadColor[0], dest[0]);

   /* G */
   if (!(colormask & PIPE_MASK_G))
      COPY_4V(quadColor[1], dest[1]);

   /* B */
   if (!(colormask & PIPE_MASK_B))
      COPY_4V(quadColor[2], dest[2]);

   /* A */
   if (!(colormask & PIPE_MASK_A))
      COPY_4V(quadColor[3], dest[3]);
}


/**
 * Clamp all colors in a quad to [0, 1]
 */
static void
clamp_colors(float (*quadColor)[4])
{
   unsigned i, j;

   for (i = 0; i < 4; i++) {
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         quadColor[i][j] = CLAMP(quadColor[i][j], 0.0F, 1.0F);
      }
   }
}


/**
 * If we're drawing to a luminance, luminance/alpha or intensity surface
 * we have to adjust (rebase) the fragment/quad colors before writing them
 * to the tile cache.  The tile cache always stores RGBA colors but if
 * we're caching a L/A surface (for example) we need to be sure that R=G=B
 * so that subsequent reads from the surface cache appear to return L/A
 * values.
 * The piglit fbo-blending-formats test will exercise this.
 */
static void
rebase_colors(enum format base_format, float (*quadColor)[4])
{
   unsigned i;

   switch (base_format) {
   case RGB:
      for (i = 0; i < 4; i++) {
         /* A = 1 */
         quadColor[3][i] = 1.0F;
      }
      break;
   case LUMINANCE:
      for (i = 0; i < 4; i++) {
         /* B = G = R */
         quadColor[2][i] = quadColor[1][i] = quadColor[0][i];
         /* A = 1 */
         quadColor[3][i] = 1.0F;
      }
      break;
   case LUMINANCE_ALPHA:
      for (i = 0; i < 4; i++) {
         /* B = G = R */
         quadColor[2][i] = quadColor[1][i] = quadColor[0][i];
      }
      break;
   case INTENSITY:
      for (i = 0; i < 4; i++) {
         /* A = B = G = R */
         quadColor[3][i] = quadColor[2][i] = quadColor[1][i] = quadColor[0][i];
      }
      break;
   default:
      ; /* nothing */
   }
}

static void
blend_fallback(struct quad_stage *qs, 
               struct quad_header *quads[],
               unsigned nr)
{
   const struct blend_quad_stage *bqs = blend_quad_stage(qs);
   struct softpipe_context *softpipe = qs->softpipe;
   const struct pipe_blend_state *blend = softpipe->blend;
   unsigned cbuf;
   boolean write_all;

   write_all = softpipe->fs_variant->info.color0_writes_all_cbufs;

   for (cbuf = 0; cbuf < softpipe->framebuffer.nr_cbufs; cbuf++) {
      if (softpipe->framebuffer.cbufs[cbuf]) {
         /* which blend/mask state index to use: */
         const uint blend_buf = blend->independent_blend_enable ? cbuf : 0;
         float dest[4][TGSI_QUAD_SIZE];
         struct softpipe_cached_tile *tile
            = sp_get_cached_tile(softpipe->cbuf_cache[cbuf],
                                 quads[0]->input.x0, 
                                 quads[0]->input.y0);
         const boolean clamp = bqs->clamp[cbuf];
         const float *blend_color;
         const boolean dual_source_blend = util_blend_state_is_dual(blend, cbuf);
         uint q, i, j;

         if (clamp)
            blend_color = softpipe->blend_color_clamped.color;
         else
            blend_color = softpipe->blend_color.color;

         for (q = 0; q < nr; q++) {
            struct quad_header *quad = quads[q];
            float (*quadColor)[4];
            float (*quadColor2)[4] = NULL;
            float temp_quad_color[TGSI_QUAD_SIZE][4];
            const int itx = (quad->input.x0 & (TILE_SIZE-1));
            const int ity = (quad->input.y0 & (TILE_SIZE-1));

            if (write_all) {
               for (j = 0; j < TGSI_QUAD_SIZE; j++) {
                  for (i = 0; i < 4; i++) {
                     temp_quad_color[i][j] = quad->output.color[0][i][j];
                  }
               }
               quadColor = temp_quad_color;
            } else {
               quadColor = quad->output.color[cbuf];
               if (dual_source_blend)
                  quadColor2 = quad->output.color[cbuf + 1];
            }

            /* If fixed-point dest color buffer, need to clamp the incoming
             * fragment colors now.
             */
            if (clamp || softpipe->rasterizer->clamp_fragment_color) {
               clamp_colors(quadColor);
            }

            /* get/swizzle dest colors
             */
            for (j = 0; j < TGSI_QUAD_SIZE; j++) {
               int x = itx + (j & 1);
               int y = ity + (j >> 1);
               for (i = 0; i < 4; i++) {
                  dest[i][j] = tile->data.color[y][x][i];
               }
            }


            if (blend->logicop_enable) {
               if (bqs->format_type[cbuf] != UTIL_FORMAT_TYPE_FLOAT) {
                  logicop_quad( qs, quadColor, dest );
               }
            }
            else if (blend->rt[blend_buf].blend_enable) {
               blend_quad(qs, quadColor, quadColor2, dest, blend_color, blend_buf);

               /* If fixed-point dest color buffer, need to clamp the outgoing
                * fragment colors now.
                */
               if (clamp) {
                  clamp_colors(quadColor);
               }
            }

            rebase_colors(bqs->base_format[cbuf], quadColor);

            if (blend->rt[blend_buf].colormask != 0xf)
               colormask_quad( blend->rt[cbuf].colormask, quadColor, dest);

            /* Output color values
             */
            for (j = 0; j < TGSI_QUAD_SIZE; j++) {
               if (quad->inout.mask & (1 << j)) {
                  int x = itx + (j & 1);
                  int y = ity + (j >> 1);
                  for (i = 0; i < 4; i++) { /* loop over color chans */
                     tile->data.color[y][x][i] = quadColor[i][j];
                  }
               }
            }
         }
      }
   }
}


static void
blend_single_add_src_alpha_inv_src_alpha(struct quad_stage *qs, 
                                         struct quad_header *quads[],
                                         unsigned nr)
{
   const struct blend_quad_stage *bqs = blend_quad_stage(qs);
   static const float one[4] = { 1, 1, 1, 1 };
   float one_minus_alpha[TGSI_QUAD_SIZE];
   float dest[4][TGSI_QUAD_SIZE];
   float source[4][TGSI_QUAD_SIZE];
   uint i, j, q;

   struct softpipe_cached_tile *tile
      = sp_get_cached_tile(qs->softpipe->cbuf_cache[0],
                           quads[0]->input.x0, 
                           quads[0]->input.y0);

   for (q = 0; q < nr; q++) {
      struct quad_header *quad = quads[q];
      float (*quadColor)[4] = quad->output.color[0];
      const float *alpha = quadColor[3];
      const int itx = (quad->input.x0 & (TILE_SIZE-1));
      const int ity = (quad->input.y0 & (TILE_SIZE-1));
      
      /* get/swizzle dest colors */
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = itx + (j & 1);
         int y = ity + (j >> 1);
         for (i = 0; i < 4; i++) {
            dest[i][j] = tile->data.color[y][x][i];
         }
      }

      /* If fixed-point dest color buffer, need to clamp the incoming
       * fragment colors now.
       */
      if (bqs->clamp[0] || qs->softpipe->rasterizer->clamp_fragment_color) {
         clamp_colors(quadColor);
      }

      VEC4_MUL(source[0], quadColor[0], alpha); /* R */
      VEC4_MUL(source[1], quadColor[1], alpha); /* G */
      VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      VEC4_MUL(source[3], quadColor[3], alpha); /* A */

      VEC4_SUB(one_minus_alpha, one, alpha);
      VEC4_MUL(dest[0], dest[0], one_minus_alpha); /* R */
      VEC4_MUL(dest[1], dest[1], one_minus_alpha); /* G */
      VEC4_MUL(dest[2], dest[2], one_minus_alpha); /* B */
      VEC4_MUL(dest[3], dest[3], one_minus_alpha); /* A */

      VEC4_ADD(quadColor[0], source[0], dest[0]); /* R */
      VEC4_ADD(quadColor[1], source[1], dest[1]); /* G */
      VEC4_ADD(quadColor[2], source[2], dest[2]); /* B */
      VEC4_ADD(quadColor[3], source[3], dest[3]); /* A */

      /* If fixed-point dest color buffer, need to clamp the outgoing
       * fragment colors now.
       */
      if (bqs->clamp[0]) {
         clamp_colors(quadColor);
      }

      rebase_colors(bqs->base_format[0], quadColor);

      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (quad->inout.mask & (1 << j)) {
            int x = itx + (j & 1);
            int y = ity + (j >> 1);
            for (i = 0; i < 4; i++) { /* loop over color chans */
               tile->data.color[y][x][i] = quadColor[i][j];
            }
         }
      }
   }
}

static void
blend_single_add_one_one(struct quad_stage *qs, 
                         struct quad_header *quads[],
                         unsigned nr)
{
   const struct blend_quad_stage *bqs = blend_quad_stage(qs);
   float dest[4][TGSI_QUAD_SIZE];
   uint i, j, q;

   struct softpipe_cached_tile *tile
      = sp_get_cached_tile(qs->softpipe->cbuf_cache[0],
                           quads[0]->input.x0, 
                           quads[0]->input.y0);

   for (q = 0; q < nr; q++) {
      struct quad_header *quad = quads[q];
      float (*quadColor)[4] = quad->output.color[0];
      const int itx = (quad->input.x0 & (TILE_SIZE-1));
      const int ity = (quad->input.y0 & (TILE_SIZE-1));
      
      /* get/swizzle dest colors */
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         int x = itx + (j & 1);
         int y = ity + (j >> 1);
         for (i = 0; i < 4; i++) {
            dest[i][j] = tile->data.color[y][x][i];
         }
      }
     
      /* If fixed-point dest color buffer, need to clamp the incoming
       * fragment colors now.
       */
      if (bqs->clamp[0] || qs->softpipe->rasterizer->clamp_fragment_color) {
         clamp_colors(quadColor);
      }

      VEC4_ADD(quadColor[0], quadColor[0], dest[0]); /* R */
      VEC4_ADD(quadColor[1], quadColor[1], dest[1]); /* G */
      VEC4_ADD(quadColor[2], quadColor[2], dest[2]); /* B */
      VEC4_ADD(quadColor[3], quadColor[3], dest[3]); /* A */

      /* If fixed-point dest color buffer, need to clamp the outgoing
       * fragment colors now.
       */
      if (bqs->clamp[0]) {
         clamp_colors(quadColor);
      }

      rebase_colors(bqs->base_format[0], quadColor);

      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (quad->inout.mask & (1 << j)) {
            int x = itx + (j & 1);
            int y = ity + (j >> 1);
            for (i = 0; i < 4; i++) { /* loop over color chans */
               tile->data.color[y][x][i] = quadColor[i][j];
            }
         }
      }
   }
}


/**
 * Just copy the quad color to the framebuffer tile (respecting the writemask),
 * for one color buffer.
 * Clamping will be done, if needed (depending on the color buffer's
 * datatype) when we write/pack the colors later.
 */
static void
single_output_color(struct quad_stage *qs, 
                    struct quad_header *quads[],
                    unsigned nr)
{
   const struct blend_quad_stage *bqs = blend_quad_stage(qs);
   uint i, j, q;

   struct softpipe_cached_tile *tile
      = sp_get_cached_tile(qs->softpipe->cbuf_cache[0],
                           quads[0]->input.x0, 
                           quads[0]->input.y0);

   for (q = 0; q < nr; q++) {
      struct quad_header *quad = quads[q];
      float (*quadColor)[4] = quad->output.color[0];
      const int itx = (quad->input.x0 & (TILE_SIZE-1));
      const int ity = (quad->input.y0 & (TILE_SIZE-1));

      if (qs->softpipe->rasterizer->clamp_fragment_color)
         clamp_colors(quadColor);

      rebase_colors(bqs->base_format[0], quadColor);

      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
         if (quad->inout.mask & (1 << j)) {
            int x = itx + (j & 1);
            int y = ity + (j >> 1);
            for (i = 0; i < 4; i++) { /* loop over color chans */
               tile->data.color[y][x][i] = quadColor[i][j];
            }
         }
      }
   }
}

static void
blend_noop(struct quad_stage *qs, 
           struct quad_header *quads[],
           unsigned nr)
{
}


static void
choose_blend_quad(struct quad_stage *qs, 
                  struct quad_header *quads[],
                  unsigned nr)
{
   struct blend_quad_stage *bqs = blend_quad_stage(qs);
   struct softpipe_context *softpipe = qs->softpipe;
   const struct pipe_blend_state *blend = softpipe->blend;
   unsigned i;

   qs->run = blend_fallback;
   
   if (softpipe->framebuffer.nr_cbufs == 0) {
      qs->run = blend_noop;
   }
   else if (!softpipe->blend->logicop_enable &&
            softpipe->blend->rt[0].colormask == 0xf &&
            softpipe->framebuffer.nr_cbufs == 1)
   {
      if (softpipe->framebuffer.cbufs[0] == NULL) {
         qs->run = blend_noop;
      }
      else if (!blend->rt[0].blend_enable) {
         qs->run = single_output_color;
      }
      else if (blend->rt[0].rgb_src_factor == blend->rt[0].alpha_src_factor &&
               blend->rt[0].rgb_dst_factor == blend->rt[0].alpha_dst_factor &&
               blend->rt[0].rgb_func == blend->rt[0].alpha_func)
      {
         if (blend->rt[0].alpha_func == PIPE_BLEND_ADD) {
            if (blend->rt[0].rgb_src_factor == PIPE_BLENDFACTOR_ONE &&
                blend->rt[0].rgb_dst_factor == PIPE_BLENDFACTOR_ONE) {
               qs->run = blend_single_add_one_one;
            }
            else if (blend->rt[0].rgb_src_factor == PIPE_BLENDFACTOR_SRC_ALPHA &&
                blend->rt[0].rgb_dst_factor == PIPE_BLENDFACTOR_INV_SRC_ALPHA)
               qs->run = blend_single_add_src_alpha_inv_src_alpha;

         }
      }
   }

   /* For each color buffer, determine if the buffer has destination alpha and
    * whether color clamping is needed.
    */
   for (i = 0; i < softpipe->framebuffer.nr_cbufs; i++) {
      if (softpipe->framebuffer.cbufs[i]) {
         const enum pipe_format format = softpipe->framebuffer.cbufs[i]->format;
         const struct util_format_description *desc =
            util_format_description(format);
         /* assuming all or no color channels are normalized: */
         bqs->clamp[i] = desc->channel[0].normalized;
         bqs->format_type[i] = desc->channel[0].type;

         if (util_format_is_intensity(format))
            bqs->base_format[i] = INTENSITY;
         else if (util_format_is_luminance(format))
            bqs->base_format[i] = LUMINANCE;
         else if (util_format_is_luminance_alpha(format))
            bqs->base_format[i] = LUMINANCE_ALPHA;
         else if (!util_format_has_alpha(format))
            bqs->base_format[i] = RGB;
         else
            bqs->base_format[i] = RGBA;
      }
   }

   qs->run(qs, quads, nr);
}


static void blend_begin(struct quad_stage *qs)
{
   qs->run = choose_blend_quad;
}


static void blend_destroy(struct quad_stage *qs)
{
   FREE( qs );
}


struct quad_stage *sp_quad_blend_stage( struct softpipe_context *softpipe )
{
   struct blend_quad_stage *stage = CALLOC_STRUCT(blend_quad_stage);

   if (!stage)
      return NULL;

   stage->base.softpipe = softpipe;
   stage->base.begin = blend_begin;
   stage->base.run = choose_blend_quad;
   stage->base.destroy = blend_destroy;

   return &stage->base;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d926 3
a928 2
   boolean write_all =
      softpipe->fs_variant->info.properties[TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS];
d938 1
a938 1
                                 quads[0]->input.y0, quads[0]->input.layer);
d1041 1
a1041 1
                           quads[0]->input.y0, quads[0]->input.layer);
d1115 1
a1115 1
                           quads[0]->input.y0, quads[0]->input.layer);
d1183 1
a1183 1
                           quads[0]->input.y0, quads[0]->input.layer);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d926 2
a927 3
   boolean write_all;

   write_all = softpipe->fs_variant->info.color0_writes_all_cbufs;
d937 1
a937 1
                                 quads[0]->input.y0);
d1040 1
a1040 1
                           quads[0]->input.y0);
d1114 1
a1114 1
                           quads[0]->input.y0);
d1182 1
a1182 1
                           quads[0]->input.y0);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d863 2
a864 2
   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      for (i = 0; i < 4; i++) {
d930 46
a975 26
   for (cbuf = 0; cbuf < softpipe->framebuffer.nr_cbufs; cbuf++) 
   {
      /* which blend/mask state index to use: */
      const uint blend_buf = blend->independent_blend_enable ? cbuf : 0;
      float dest[4][TGSI_QUAD_SIZE];
      struct softpipe_cached_tile *tile
         = sp_get_cached_tile(softpipe->cbuf_cache[cbuf],
                              quads[0]->input.x0, 
                              quads[0]->input.y0);
      const boolean clamp = bqs->clamp[cbuf];
      const float *blend_color;
      const boolean dual_source_blend = util_blend_state_is_dual(blend, cbuf);
      uint q, i, j;

      if (clamp)
         blend_color = softpipe->blend_color_clamped.color;
      else
         blend_color = softpipe->blend_color.color;

      for (q = 0; q < nr; q++) {
         struct quad_header *quad = quads[q];
         float (*quadColor)[4];
         float (*quadColor2)[4] = NULL;
         float temp_quad_color[TGSI_QUAD_SIZE][4];
         const int itx = (quad->input.x0 & (TILE_SIZE-1));
         const int ity = (quad->input.y0 & (TILE_SIZE-1));
d977 2
a978 1
         if (write_all) {
d980 2
d983 1
a983 1
                  temp_quad_color[i][j] = quad->output.color[0][i][j];
a985 6
            quadColor = temp_quad_color;
         } else {
            quadColor = quad->output.color[cbuf];
	    if (dual_source_blend)
	       quadColor2 = quad->output.color[cbuf + 1];
         }
a986 6
         /* If fixed-point dest color buffer, need to clamp the incoming
          * fragment colors now.
          */
         if (clamp || softpipe->rasterizer->clamp_fragment_color) {
            clamp_colors(quadColor);
         }
d988 4
a991 7
         /* get/swizzle dest colors
          */
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            int x = itx + (j & 1);
            int y = ity + (j >> 1);
            for (i = 0; i < 4; i++) {
               dest[i][j] = tile->data.color[y][x][i];
d993 2
a994 1
         }
d996 6
a1001 4

         if (blend->logicop_enable) {
            if (bqs->format_type[cbuf] != UTIL_FORMAT_TYPE_FLOAT) {
               logicop_quad( qs, quadColor, dest );
a1002 3
         }
         else if (blend->rt[blend_buf].blend_enable) {
            blend_quad(qs, quadColor, quadColor2, dest, blend_color, blend_buf);
d1004 1
a1004 7
            /* If fixed-point dest color buffer, need to clamp the outgoing
             * fragment colors now.
             */
            if (clamp) {
               clamp_colors(quadColor);
            }
         }
d1006 2
a1007 1
         rebase_colors(bqs->base_format[cbuf], quadColor);
d1009 9
a1017 11
         if (blend->rt[blend_buf].colormask != 0xf)
            colormask_quad( blend->rt[cbuf].colormask, quadColor, dest);
   
         /* Output color values
          */
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
            if (quad->inout.mask & (1 << j)) {
               int x = itx + (j & 1);
               int y = ity + (j >> 1);
               for (i = 0; i < 4; i++) { /* loop over color chans */
                  tile->data.color[y][x][i] = quadColor[i][j];
d1235 4
a1238 1
      if (!blend->rt[0].blend_enable) {
d1262 19
a1280 17
      const enum pipe_format format = softpipe->framebuffer.cbufs[i]->format;
      const struct util_format_description *desc =
         util_format_description(format);
      /* assuming all or no color channels are normalized: */
      bqs->clamp[i] = desc->channel[0].normalized;
      bqs->format_type[i] = desc->channel[0].type;

      if (util_format_is_intensity(format))
         bqs->base_format[i] = INTENSITY;
      else if (util_format_is_luminance(format))
         bqs->base_format[i] = LUMINANCE;
      else if (util_format_is_luminance_alpha(format))
         bqs->base_format[i] = LUMINANCE_ALPHA;
      else if (!util_format_has_alpha(format))
         bqs->base_format[i] = RGB;
      else
         bqs->base_format[i] = RGBA;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d37 1
d45 28
d258 1
a259 1
 * \param has_dst_alpha  does the dest color buffer have an alpha channel?
d264 1
d266 2
a267 2
           unsigned blend_index,
           boolean has_dst_alpha)
d272 2
a273 1
   float source[4][QUAD_SIZE] = { { 0 } };
d290 7
a296 7
   {
      const float *alpha = quadColor[3];
      VEC4_MUL(source[0], quadColor[0], alpha); /* R */
      VEC4_MUL(source[1], quadColor[1], alpha); /* G */
      VEC4_MUL(source[2], quadColor[2], alpha); /* B */
   }
   break;
d303 1
a303 1
      if (has_dst_alpha) {
a308 5
      else {
         VEC4_COPY(source[0], quadColor[0]); /* R */
         VEC4_COPY(source[1], quadColor[1]); /* G */
         VEC4_COPY(source[2], quadColor[2]); /* B */
      }
d311 1
a311 1
      if (has_dst_alpha) {
d320 10
a329 4
      else {
         VEC4_COPY(source[0], zero); /* R */
         VEC4_COPY(source[1], zero); /* G */
         VEC4_COPY(source[2], zero); /* B */
a331 11
   case PIPE_BLENDFACTOR_CONST_COLOR:
   {
      float comp[4];
      VEC4_SCALAR(comp, softpipe->blend_color.color[0]); /* R */
      VEC4_MUL(source[0], quadColor[0], comp); /* R */
      VEC4_SCALAR(comp, softpipe->blend_color.color[1]); /* G */
      VEC4_MUL(source[1], quadColor[1], comp); /* G */
      VEC4_SCALAR(comp, softpipe->blend_color.color[2]); /* B */
      VEC4_MUL(source[2], quadColor[2], comp); /* B */
   }
   break;
d333 8
a340 8
   {
      float alpha[4];
      VEC4_SCALAR(alpha, softpipe->blend_color.color[3]);
      VEC4_MUL(source[0], quadColor[0], alpha); /* R */
      VEC4_MUL(source[1], quadColor[1], alpha); /* G */
      VEC4_MUL(source[2], quadColor[2], alpha); /* B */
   }
   break;
d342 3
a344 1
      assert(0); /* to do */
d347 6
a352 1
      assert(0); /* to do */
d360 10
a369 10
   {
      float inv_comp[4];
      VEC4_SUB(inv_comp, one, quadColor[0]); /* R */
      VEC4_MUL(source[0], quadColor[0], inv_comp); /* R */
      VEC4_SUB(inv_comp, one, quadColor[1]); /* G */
      VEC4_MUL(source[1], quadColor[1], inv_comp); /* G */
      VEC4_SUB(inv_comp, one, quadColor[2]); /* B */
      VEC4_MUL(source[2], quadColor[2], inv_comp); /* B */
   }
   break;
d371 8
a378 8
   {
      float inv_alpha[4];
      VEC4_SUB(inv_alpha, one, quadColor[3]);
      VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
      VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
      VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
   }
   break;
d380 1
a380 1
      if (has_dst_alpha) {
d387 10
a396 4
      else {
         VEC4_COPY(source[0], zero); /* R */
         VEC4_COPY(source[1], zero); /* G */
         VEC4_COPY(source[2], zero); /* B */
a398 11
   case PIPE_BLENDFACTOR_INV_DST_COLOR:
   {
      float inv_comp[4];
      VEC4_SUB(inv_comp, one, dest[0]); /* R */
      VEC4_MUL(source[0], quadColor[0], inv_comp); /* R */
      VEC4_SUB(inv_comp, one, dest[1]); /* G */
      VEC4_MUL(source[1], quadColor[1], inv_comp); /* G */
      VEC4_SUB(inv_comp, one, dest[2]); /* B */
      VEC4_MUL(source[2], quadColor[2], inv_comp); /* B */
   }
   break;
d400 13
a412 13
   {
      float inv_comp[4];
      /* R */
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[0]);
      VEC4_MUL(source[0], quadColor[0], inv_comp);
      /* G */
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[1]);
      VEC4_MUL(source[1], quadColor[1], inv_comp);
      /* B */
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[2]);
      VEC4_MUL(source[2], quadColor[2], inv_comp);
   }
   break;
d414 8
a421 8
   {
      float inv_alpha[4];
      VEC4_SCALAR(inv_alpha, 1.0f - softpipe->blend_color.color[3]);
      VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
      VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
      VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
   }
   break;
d423 9
a431 1
      assert(0); /* to do */
d434 7
a440 1
      assert(0); /* to do */
d456 5
a460 5
   {
      const float *alpha = quadColor[3];
      VEC4_MUL(source[3], quadColor[3], alpha); /* A */
   }
   break;
d464 1
a464 4
      if (has_dst_alpha)
         VEC4_MUL(source[3], quadColor[3], dest[3]); /* A */
      else
         VEC4_COPY(source[3], quadColor[3]); /* A */
d473 6
a478 6
   {
      float comp[4];
      VEC4_SCALAR(comp, softpipe->blend_color.color[3]); /* A */
      VEC4_MUL(source[3], quadColor[3], comp); /* A */
   }
   break;
d485 6
a490 6
   {
      float inv_alpha[4];
      VEC4_SUB(inv_alpha, one, quadColor[3]);
      VEC4_MUL(source[3], quadColor[3], inv_alpha); /* A */
   }
   break;
d494 1
a494 1
      if (has_dst_alpha) {
a498 3
      else {
         VEC4_COPY(source[3], zero); /* A */
      }
d503 24
a526 7
   {
      float inv_comp[4];
      /* A */
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[3]);
      VEC4_MUL(source[3], quadColor[3], inv_comp);
   }
   break;
d531 6
d539 1
a539 1
    * Compute dest/second term RGB
d543 1
a543 1
      /* dest = dest * 1   NO-OP, leave dest as-is */
d546 3
a548 3
      VEC4_MUL(dest[0], dest[0], quadColor[0]); /* R */
      VEC4_MUL(dest[1], dest[1], quadColor[1]); /* G */
      VEC4_MUL(dest[2], dest[2], quadColor[2]); /* B */
d551 3
a553 3
      VEC4_MUL(dest[0], dest[0], quadColor[3]); /* R * A */
      VEC4_MUL(dest[1], dest[1], quadColor[3]); /* G * A */
      VEC4_MUL(dest[2], dest[2], quadColor[3]); /* B * A */
d556 3
a558 8
      if (has_dst_alpha) {
         VEC4_MUL(dest[0], dest[0], dest[3]); /* R * A */
         VEC4_MUL(dest[1], dest[1], dest[3]); /* G * A */
         VEC4_MUL(dest[2], dest[2], dest[3]); /* B * A */
      }
      else {
         /* dest = dest * 1   NO-OP, leave dest as-is */
      }
d561 3
a563 3
      VEC4_MUL(dest[0], dest[0], dest[0]); /* R */
      VEC4_MUL(dest[1], dest[1], dest[1]); /* G */
      VEC4_MUL(dest[2], dest[2], dest[2]); /* B */
d566 1
a566 1
      if (has_dst_alpha) {
d569 1
a569 1
         VEC4_SUB(diff, one, dest[3]);
d571 3
a573 8
         VEC4_MUL(dest[0], quadColor[0], temp); /* R */
         VEC4_MUL(dest[1], quadColor[1], temp); /* G */
         VEC4_MUL(dest[2], quadColor[2], temp); /* B */
      }
      else {
         VEC4_COPY(dest[0], zero); /* R */
         VEC4_COPY(dest[1], zero); /* G */
         VEC4_COPY(dest[2], zero); /* B */
d577 10
a586 10
   {
      float comp[4];
      VEC4_SCALAR(comp, softpipe->blend_color.color[0]); /* R */
      VEC4_MUL(dest[0], dest[0], comp); /* R */
      VEC4_SCALAR(comp, softpipe->blend_color.color[1]); /* G */
      VEC4_MUL(dest[1], dest[1], comp); /* G */
      VEC4_SCALAR(comp, softpipe->blend_color.color[2]); /* B */
      VEC4_MUL(dest[2], dest[2], comp); /* B */
   }
   break;
d588 8
a595 8
   {
      float comp[4];
      VEC4_SCALAR(comp, softpipe->blend_color.color[3]); /* A */
      VEC4_MUL(dest[0], dest[0], comp); /* R */
      VEC4_MUL(dest[1], dest[1], comp); /* G */
      VEC4_MUL(dest[2], dest[2], comp); /* B */
   }
   break;
d597 3
a599 3
      VEC4_COPY(dest[0], zero); /* R */
      VEC4_COPY(dest[1], zero); /* G */
      VEC4_COPY(dest[2], zero); /* B */
d602 4
d607 3
a609 2
      /* XXX what are these? */
      assert(0);
d612 10
a621 10
   {
      float inv_comp[4];
      VEC4_SUB(inv_comp, one, quadColor[0]); /* R */
      VEC4_MUL(dest[0], inv_comp, dest[0]); /* R */
      VEC4_SUB(inv_comp, one, quadColor[1]); /* G */
      VEC4_MUL(dest[1], inv_comp, dest[1]); /* G */
      VEC4_SUB(inv_comp, one, quadColor[2]); /* B */
      VEC4_MUL(dest[2], inv_comp, dest[2]); /* B */
   }
   break;
d623 8
a630 8
   {
      float one_minus_alpha[QUAD_SIZE];
      VEC4_SUB(one_minus_alpha, one, quadColor[3]);
      VEC4_MUL(dest[0], dest[0], one_minus_alpha); /* R */
      VEC4_MUL(dest[1], dest[1], one_minus_alpha); /* G */
      VEC4_MUL(dest[2], dest[2], one_minus_alpha); /* B */
   }
   break;
d632 1
a632 1
      if (has_dst_alpha) {
d634 4
a637 9
         VEC4_SUB(inv_comp, one, dest[3]); /* A */
         VEC4_MUL(dest[0], inv_comp, dest[0]); /* R */
         VEC4_MUL(dest[1], inv_comp, dest[1]); /* G */
         VEC4_MUL(dest[2], inv_comp, dest[2]); /* B */
      }
      else {
         VEC4_COPY(dest[0], zero); /* R */
         VEC4_COPY(dest[1], zero); /* G */
         VEC4_COPY(dest[2], zero); /* B */
d639 1
a639 1
   break;
d641 10
a650 10
   {
      float inv_comp[4];
      VEC4_SUB(inv_comp, one, dest[0]); /* R */
      VEC4_MUL(dest[0], dest[0], inv_comp); /* R */
      VEC4_SUB(inv_comp, one, dest[1]); /* G */
      VEC4_MUL(dest[1], dest[1], inv_comp); /* G */
      VEC4_SUB(inv_comp, one, dest[2]); /* B */
      VEC4_MUL(dest[2], dest[2], inv_comp); /* B */
   }
   break;
d652 13
a664 13
   {
      float inv_comp[4];
      /* R */
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[0]);
      VEC4_MUL(dest[0], dest[0], inv_comp);
      /* G */
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[1]);
      VEC4_MUL(dest[1], dest[1], inv_comp);
      /* B */
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[2]);
      VEC4_MUL(dest[2], dest[2], inv_comp);
   }
   break;
d666 8
a673 8
   {
      float inv_comp[4];
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[3]);
      VEC4_MUL(dest[0], dest[0], inv_comp);
      VEC4_MUL(dest[1], dest[1], inv_comp);
      VEC4_MUL(dest[2], dest[2], inv_comp);
   }
   break;
d675 10
d686 7
a692 2
      /* XXX what are these? */
      assert(0);
d699 1
a699 1
    * Compute dest/second term A
d703 1
a703 1
      /* dest = dest * 1   NO-OP, leave dest as-is */
d708 1
a708 1
      VEC4_MUL(dest[3], dest[3], quadColor[3]); /* A * A */
d713 1
a713 6
      if (has_dst_alpha) {
         VEC4_MUL(dest[3], dest[3], dest[3]); /* A */
      }
      else {
         /* dest = dest * 1   NO-OP, leave dest as-is */
      }
d716 1
a716 1
      /* dest = dest * 1   NO-OP, leave dest as-is */
d721 6
a726 6
   {
      float comp[4];
      VEC4_SCALAR(comp, softpipe->blend_color.color[3]); /* A */
      VEC4_MUL(dest[3], dest[3], comp); /* A */
   }
   break;
d728 1
a728 1
      VEC4_COPY(dest[3], zero); /* A */
d733 6
a738 6
   {
      float one_minus_alpha[QUAD_SIZE];
      VEC4_SUB(one_minus_alpha, one, quadColor[3]);
      VEC4_MUL(dest[3], dest[3], one_minus_alpha); /* A */
   }
   break;
d742 1
a742 1
      if (has_dst_alpha) {
d744 2
a745 5
         VEC4_SUB(inv_comp, one, dest[3]); /* A */
         VEC4_MUL(dest[3], inv_comp, dest[3]); /* A */
      }
      else {
         VEC4_COPY(dest[3], zero); /* A */
d751 20
a770 6
   {
      float inv_comp[4];
      VEC4_SCALAR(inv_comp, 1.0f - softpipe->blend_color.color[3]);
      VEC4_MUL(dest[3], dest[3], inv_comp);
   }
   break;
d780 3
a782 3
      VEC4_ADD_SAT(quadColor[0], source[0], dest[0]); /* R */
      VEC4_ADD_SAT(quadColor[1], source[1], dest[1]); /* G */
      VEC4_ADD_SAT(quadColor[2], source[2], dest[2]); /* B */
d785 3
a787 3
      VEC4_SUB_SAT(quadColor[0], source[0], dest[0]); /* R */
      VEC4_SUB_SAT(quadColor[1], source[1], dest[1]); /* G */
      VEC4_SUB_SAT(quadColor[2], source[2], dest[2]); /* B */
d790 3
a792 3
      VEC4_SUB_SAT(quadColor[0], dest[0], source[0]); /* R */
      VEC4_SUB_SAT(quadColor[1], dest[1], source[1]); /* G */
      VEC4_SUB_SAT(quadColor[2], dest[2], source[2]); /* B */
d795 3
a797 3
      VEC4_MIN(quadColor[0], source[0], dest[0]); /* R */
      VEC4_MIN(quadColor[1], source[1], dest[1]); /* G */
      VEC4_MIN(quadColor[2], source[2], dest[2]); /* B */
d800 3
a802 3
      VEC4_MAX(quadColor[0], source[0], dest[0]); /* R */
      VEC4_MAX(quadColor[1], source[1], dest[1]); /* G */
      VEC4_MAX(quadColor[2], source[2], dest[2]); /* B */
d813 1
a813 1
      VEC4_ADD_SAT(quadColor[3], source[3], dest[3]); /* A */
d816 1
a816 1
      VEC4_SUB_SAT(quadColor[3], source[3], dest[3]); /* A */
d819 1
a819 1
      VEC4_SUB_SAT(quadColor[3], dest[3], source[3]); /* A */
d822 1
a822 1
      VEC4_MIN(quadColor[3], source[3], dest[3]); /* A */
d825 1
a825 1
      VEC4_MAX(quadColor[3], source[3], dest[3]); /* A */
d855 62
d922 1
d928 1
a928 1
   write_all = softpipe->fs->color0_writes_all_cbufs;
d934 1
a934 1
      float dest[4][QUAD_SIZE];
d939 4
a942 3
      boolean has_dst_alpha
         = util_format_has_alpha(softpipe->framebuffer.cbufs[cbuf]->format);
      uint q, i, j, qbuf;
d944 4
a947 1
      qbuf = write_all ? 0 : cbuf;
d952 2
d957 19
a975 1
         quadColor = quad->output.color[qbuf];
d979 1
a979 1
         for (j = 0; j < QUAD_SIZE; j++) {
d989 3
a991 1
            logicop_quad( qs, quadColor, dest );
d994 8
a1001 1
            blend_quad( qs, quadColor, dest, blend_buf, has_dst_alpha );
d1004 2
d1011 1
a1011 1
         for (j = 0; j < QUAD_SIZE; j++) {
d1030 1
d1032 3
a1034 3
   float one_minus_alpha[QUAD_SIZE];
   float dest[4][QUAD_SIZE];
   float source[4][QUAD_SIZE];
d1050 1
a1050 1
      for (j = 0; j < QUAD_SIZE; j++) {
d1058 7
d1074 1
a1074 1
      VEC4_MUL(dest[3], dest[3], one_minus_alpha); /* B */
d1076 11
a1086 4
      VEC4_ADD_SAT(quadColor[0], source[0], dest[0]); /* R */
      VEC4_ADD_SAT(quadColor[1], source[1], dest[1]); /* G */
      VEC4_ADD_SAT(quadColor[2], source[2], dest[2]); /* B */
      VEC4_ADD_SAT(quadColor[3], source[3], dest[3]); /* A */
d1088 3
a1090 1
      for (j = 0; j < QUAD_SIZE; j++) {
d1107 2
a1108 1
   float dest[4][QUAD_SIZE];
d1123 1
a1123 1
      for (j = 0; j < QUAD_SIZE; j++) {
d1131 18
a1148 4
      VEC4_ADD_SAT(quadColor[0], quadColor[0], dest[0]); /* R */
      VEC4_ADD_SAT(quadColor[1], quadColor[1], dest[1]); /* G */
      VEC4_ADD_SAT(quadColor[2], quadColor[2], dest[2]); /* B */
      VEC4_ADD_SAT(quadColor[3], quadColor[3], dest[3]); /* A */
d1150 3
a1152 1
      for (j = 0; j < QUAD_SIZE; j++) {
d1165 6
d1176 1
d1189 7
a1195 2
      
      for (j = 0; j < QUAD_SIZE; j++) {
d1220 1
d1223 1
d1254 23
d1295 4
a1298 1
   struct quad_stage *stage = CALLOC_STRUCT(quad_stage);
d1300 4
a1303 4
   stage->softpipe = softpipe;
   stage->begin = blend_begin;
   stage->run = choose_blend_quad;
   stage->destroy = blend_destroy;
d1305 1
a1305 1
   return stage;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d38 1
d798 3
d813 3
a815 1
      uint q, i, j;
d819 1
a819 1
         float (*quadColor)[4] = quad->output.color[cbuf];
d823 3
a825 1
         /* get/swizzle dest colors 
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d36 1
d211 1
a211 1
      assert(0);
d224 7
d235 2
a236 1
           unsigned cbuf)
d246 1
a246 1
   switch (softpipe->blend->rt[cbuf].rgb_src_factor) {
d271 12
a282 7
   {
      const float *alpha = dest[3];
      VEC4_MUL(source[0], quadColor[0], alpha); /* R */
      VEC4_MUL(source[1], quadColor[1], alpha); /* G */
      VEC4_MUL(source[2], quadColor[2], alpha); /* B */
   }
   break;
d284 15
a298 10
   {
      const float *alpha = quadColor[3];
      float diff[4], temp[4];
      VEC4_SUB(diff, one, dest[3]);
      VEC4_MIN(temp, alpha, diff);
      VEC4_MUL(source[0], quadColor[0], temp); /* R */
      VEC4_MUL(source[1], quadColor[1], temp); /* G */
      VEC4_MUL(source[2], quadColor[2], temp); /* B */
   }
   break;
d351 13
a363 8
   {
      float inv_alpha[4];
      VEC4_SUB(inv_alpha, one, dest[3]);
      VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
      VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
      VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
   }
   break;
d405 1
a405 1
      assert(0);
d411 1
a411 1
   switch (softpipe->blend->rt[cbuf].alpha_src_factor) {
d426 4
a429 1
      VEC4_MUL(source[3], quadColor[3], dest[3]); /* A */
d459 9
a467 6
   {
      float inv_alpha[4];
      VEC4_SUB(inv_alpha, one, dest[3]);
      VEC4_MUL(source[3], quadColor[3], inv_alpha); /* A */
   }
   break;
d479 1
a479 1
      assert(0);
d486 1
a486 1
   switch (softpipe->blend->rt[cbuf].rgb_dst_factor) {
d501 8
a508 3
      VEC4_MUL(dest[0], dest[0], dest[3]); /* R * A */
      VEC4_MUL(dest[1], dest[1], dest[3]); /* G * A */
      VEC4_MUL(dest[2], dest[2], dest[3]); /* B * A */
d516 14
a529 9
   {
      const float *alpha = quadColor[3];
      float diff[4], temp[4];
      VEC4_SUB(diff, one, dest[3]);
      VEC4_MIN(temp, alpha, diff);
      VEC4_MUL(dest[0], quadColor[0], temp); /* R */
      VEC4_MUL(dest[1], quadColor[1], temp); /* G */
      VEC4_MUL(dest[2], quadColor[2], temp); /* B */
   }
d582 12
a593 7
   {
      float inv_comp[4];
      VEC4_SUB(inv_comp, one, dest[3]); /* A */
      VEC4_MUL(dest[0], inv_comp, dest[0]); /* R */
      VEC4_MUL(dest[1], inv_comp, dest[1]); /* G */
      VEC4_MUL(dest[2], inv_comp, dest[2]); /* B */
   }
d635 1
a635 1
      assert(0);
d641 1
a641 1
   switch (softpipe->blend->rt[cbuf].alpha_dst_factor) {
d653 6
a658 1
      VEC4_MUL(dest[3], dest[3], dest[3]); /* A */
d687 9
a695 6
   {
      float inv_comp[4];
      VEC4_SUB(inv_comp, one, dest[3]); /* A */
      VEC4_MUL(dest[3], inv_comp, dest[3]); /* A */
   }
   break;
d706 1
a706 1
      assert(0);
d712 1
a712 1
   switch (softpipe->blend->rt[cbuf].rgb_func) {
d739 1
a739 1
      assert(0);
d745 1
a745 1
   switch (softpipe->blend->rt[cbuf].alpha_func) {
d762 1
a762 1
      assert(0);
d807 2
d832 1
a832 1
            blend_quad( qs, quadColor, dest, cbuf );
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a35 1
#include "util/u_format.h"
d210 1
a210 1
      assert(0 && "invalid logicop mode");
a222 7
/**
 * Do blending for a 2x2 quad for one color buffer.
 * \param quadColor  the incoming quad colors
 * \param dest  the destination/framebuffer quad colors
 * \param blend_index  which set of blending terms to use
 * \param has_dst_alpha  does the dest color buffer have an alpha channel?
 */
d227 1
a227 2
           unsigned blend_index,
           boolean has_dst_alpha)
d237 1
a237 1
   switch (softpipe->blend->rt[blend_index].rgb_src_factor) {
d262 7
a268 12
      if (has_dst_alpha) {
         const float *alpha = dest[3];
         VEC4_MUL(source[0], quadColor[0], alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      } 
      else {
         VEC4_COPY(source[0], quadColor[0]); /* R */
         VEC4_COPY(source[1], quadColor[1]); /* G */
         VEC4_COPY(source[2], quadColor[2]); /* B */
      }
      break;
d270 10
a279 15
      if (has_dst_alpha) {
         const float *alpha = quadColor[3];
         float diff[4], temp[4];
         VEC4_SUB(diff, one, dest[3]);
         VEC4_MIN(temp, alpha, diff);
         VEC4_MUL(source[0], quadColor[0], temp); /* R */
         VEC4_MUL(source[1], quadColor[1], temp); /* G */
         VEC4_MUL(source[2], quadColor[2], temp); /* B */
      }
      else {
         VEC4_COPY(source[0], zero); /* R */
         VEC4_COPY(source[1], zero); /* G */
         VEC4_COPY(source[2], zero); /* B */
      }
      break;
d332 8
a339 13
      if (has_dst_alpha) {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, dest[3]);
         VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
      }
      else {
         VEC4_COPY(source[0], zero); /* R */
         VEC4_COPY(source[1], zero); /* G */
         VEC4_COPY(source[2], zero); /* B */
      }
      break;
d381 1
a381 1
      assert(0 && "invalid rgb src factor");
d387 1
a387 1
   switch (softpipe->blend->rt[blend_index].alpha_src_factor) {
d402 1
a402 4
      if (has_dst_alpha)
         VEC4_MUL(source[3], quadColor[3], dest[3]); /* A */
      else
         VEC4_COPY(source[3], quadColor[3]); /* A */
d432 6
a437 9
      if (has_dst_alpha) {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, dest[3]);
         VEC4_MUL(source[3], quadColor[3], inv_alpha); /* A */
      }
      else {
         VEC4_COPY(source[3], zero); /* A */
      }
      break;
d449 1
a449 1
      assert(0 && "invalid alpha src factor");
d456 1
a456 1
   switch (softpipe->blend->rt[blend_index].rgb_dst_factor) {
d471 3
a473 8
      if (has_dst_alpha) {
         VEC4_MUL(dest[0], dest[0], dest[3]); /* R * A */
         VEC4_MUL(dest[1], dest[1], dest[3]); /* G * A */
         VEC4_MUL(dest[2], dest[2], dest[3]); /* B * A */
      }
      else {
         /* dest = dest * 1   NO-OP, leave dest as-is */
      }
d481 9
a489 14
      if (has_dst_alpha) {
         const float *alpha = quadColor[3];
         float diff[4], temp[4];
         VEC4_SUB(diff, one, dest[3]);
         VEC4_MIN(temp, alpha, diff);
         VEC4_MUL(dest[0], quadColor[0], temp); /* R */
         VEC4_MUL(dest[1], quadColor[1], temp); /* G */
         VEC4_MUL(dest[2], quadColor[2], temp); /* B */
      }
      else {
         VEC4_COPY(dest[0], zero); /* R */
         VEC4_COPY(dest[1], zero); /* G */
         VEC4_COPY(dest[2], zero); /* B */
      }
d542 7
a548 12
      if (has_dst_alpha) {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, dest[3]); /* A */
         VEC4_MUL(dest[0], inv_comp, dest[0]); /* R */
         VEC4_MUL(dest[1], inv_comp, dest[1]); /* G */
         VEC4_MUL(dest[2], inv_comp, dest[2]); /* B */
      }
      else {
         VEC4_COPY(dest[0], zero); /* R */
         VEC4_COPY(dest[1], zero); /* G */
         VEC4_COPY(dest[2], zero); /* B */
      }
d590 1
a590 1
      assert(0 && "invalid rgb dst factor");
d596 1
a596 1
   switch (softpipe->blend->rt[blend_index].alpha_dst_factor) {
d608 1
a608 6
      if (has_dst_alpha) {
         VEC4_MUL(dest[3], dest[3], dest[3]); /* A */
      }
      else {
         /* dest = dest * 1   NO-OP, leave dest as-is */
      }
d637 6
a642 9
      if (has_dst_alpha) {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, dest[3]); /* A */
         VEC4_MUL(dest[3], inv_comp, dest[3]); /* A */
      }
      else {
         VEC4_COPY(dest[3], zero); /* A */
      }
      break;
d653 1
a653 1
      assert(0 && "invalid alpha dst factor");
d659 1
a659 1
   switch (softpipe->blend->rt[blend_index].rgb_func) {
d686 1
a686 1
      assert(0 && "invalid rgb blend func");
d692 1
a692 1
   switch (softpipe->blend->rt[blend_index].alpha_func) {
d709 1
a709 1
      assert(0 && "invalid alpha blend func");
a753 2
      boolean has_dst_alpha
         = util_format_has_alpha(softpipe->framebuffer.cbufs[cbuf]->format);
d777 1
a777 1
            blend_quad( qs, quadColor, dest, blend_buf, has_dst_alpha );
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a36 1
#include "util/u_dual_blend.h"
a37 1
#include "sp_state.h"
a42 28
enum format
{
   RGBA,
   RGB,
   LUMINANCE,
   LUMINANCE_ALPHA,
   INTENSITY
};


/** Subclass of quad_stage */
struct blend_quad_stage
{
   struct quad_stage base;
   boolean clamp[PIPE_MAX_COLOR_BUFS];  /**< clamp colors to [0,1]? */
   enum format base_format[PIPE_MAX_COLOR_BUFS];
   enum util_format_type format_type[PIPE_MAX_COLOR_BUFS];
};


/** cast wrapper */
static INLINE struct blend_quad_stage *
blend_quad_stage(struct quad_stage *stage)
{
   return (struct blend_quad_stage *) stage;
}


a227 1
 * \param const_blend_color  the constant blend color
d229 1
a233 1
           float (*quadColor2)[4],
d235 2
a236 2
           const float const_blend_color[4],
           unsigned blend_index)
d241 1
a241 2
   float source[4][TGSI_QUAD_SIZE] = { { 0 } };
   float blend_dest[4][TGSI_QUAD_SIZE];
d258 7
a264 7
      {
         const float *alpha = quadColor[3];
         VEC4_MUL(source[0], quadColor[0], alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      }
      break;
d271 1
a271 1
      {
d277 5
d284 1
a284 1
      {
d293 5
d300 10
a309 10
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[0]); /* R */
         VEC4_MUL(source[0], quadColor[0], comp); /* R */
         VEC4_SCALAR(comp, const_blend_color[1]); /* G */
         VEC4_MUL(source[1], quadColor[1], comp); /* G */
         VEC4_SCALAR(comp, const_blend_color[2]); /* B */
         VEC4_MUL(source[2], quadColor[2], comp); /* B */
      }
      break;
d311 8
a318 8
      {
         float alpha[4];
         VEC4_SCALAR(alpha, const_blend_color[3]);
         VEC4_MUL(source[0], quadColor[0], alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      }
      break;
d320 1
a320 3
      VEC4_MUL(source[0], quadColor[0], quadColor2[0]); /* R */
      VEC4_MUL(source[1], quadColor[1], quadColor2[1]); /* G */
      VEC4_MUL(source[2], quadColor[2], quadColor2[2]); /* B */	 
d323 1
a323 6
      {
         const float *alpha = quadColor2[3];
         VEC4_MUL(source[0], quadColor[0], alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], alpha); /* B */
      }
d331 10
a340 10
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, quadColor[0]); /* R */
         VEC4_MUL(source[0], quadColor[0], inv_comp); /* R */
         VEC4_SUB(inv_comp, one, quadColor[1]); /* G */
         VEC4_MUL(source[1], quadColor[1], inv_comp); /* G */
         VEC4_SUB(inv_comp, one, quadColor[2]); /* B */
         VEC4_MUL(source[2], quadColor[2], inv_comp); /* B */
      }
      break;
d342 8
a349 8
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, quadColor[3]);
         VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
      }
      break;
d351 1
a351 1
      {
d358 5
d365 10
a374 10
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, dest[0]); /* R */
         VEC4_MUL(source[0], quadColor[0], inv_comp); /* R */
         VEC4_SUB(inv_comp, one, dest[1]); /* G */
         VEC4_MUL(source[1], quadColor[1], inv_comp); /* G */
         VEC4_SUB(inv_comp, one, dest[2]); /* B */
         VEC4_MUL(source[2], quadColor[2], inv_comp); /* B */
      }
      break;
d376 13
a388 13
      {
         float inv_comp[4];
         /* R */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[0]);
         VEC4_MUL(source[0], quadColor[0], inv_comp);
         /* G */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[1]);
         VEC4_MUL(source[1], quadColor[1], inv_comp);
         /* B */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[2]);
         VEC4_MUL(source[2], quadColor[2], inv_comp);
      }
      break;
d390 8
a397 8
      {
         float inv_alpha[4];
         VEC4_SCALAR(inv_alpha, 1.0f - const_blend_color[3]);
         VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
      }
      break;
d399 1
a399 9
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, quadColor2[0]); /* R */
         VEC4_MUL(source[0], quadColor[0], inv_comp); /* R */
         VEC4_SUB(inv_comp, one, quadColor2[1]); /* G */
         VEC4_MUL(source[1], quadColor[1], inv_comp); /* G */
         VEC4_SUB(inv_comp, one, quadColor2[2]); /* B */
         VEC4_MUL(source[2], quadColor[2], inv_comp); /* B */
      }
d402 1
a402 7
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, quadColor2[3]);
         VEC4_MUL(source[0], quadColor[0], inv_alpha); /* R */
         VEC4_MUL(source[1], quadColor[1], inv_alpha); /* G */
         VEC4_MUL(source[2], quadColor[2], inv_alpha); /* B */
      }
d418 5
a422 5
      {
         const float *alpha = quadColor[3];
         VEC4_MUL(source[3], quadColor[3], alpha); /* A */
      }
      break;
d426 4
a429 1
      VEC4_MUL(source[3], quadColor[3], dest[3]); /* A */
d438 6
a443 6
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[3]); /* A */
         VEC4_MUL(source[3], quadColor[3], comp); /* A */
      }
      break;
d450 6
a455 6
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, quadColor[3]);
         VEC4_MUL(source[3], quadColor[3], inv_alpha); /* A */
      }
      break;
d459 1
a459 1
      {
d464 3
d471 7
a477 24
      {
         float inv_comp[4];
         /* A */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[3]);
         VEC4_MUL(source[3], quadColor[3], inv_comp);
      }
      break;
   case PIPE_BLENDFACTOR_SRC1_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      {
         const float *alpha = quadColor2[3];
         VEC4_MUL(source[3], quadColor[3], alpha); /* A */
      }
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      {
         float inv_alpha[4];
         VEC4_SUB(inv_alpha, one, quadColor2[3]);
         VEC4_MUL(source[3], quadColor[3], inv_alpha); /* A */
      }
      break;
a481 6
   /* Save the original dest for use in masking */
   VEC4_COPY(blend_dest[0], dest[0]);
   VEC4_COPY(blend_dest[1], dest[1]);
   VEC4_COPY(blend_dest[2], dest[2]);
   VEC4_COPY(blend_dest[3], dest[3]);

d484 1
a484 1
    * Compute blend_dest/second term RGB
d488 1
a488 1
      /* blend_dest = blend_dest * 1   NO-OP, leave blend_dest as-is */
d491 3
a493 3
      VEC4_MUL(blend_dest[0], blend_dest[0], quadColor[0]); /* R */
      VEC4_MUL(blend_dest[1], blend_dest[1], quadColor[1]); /* G */
      VEC4_MUL(blend_dest[2], blend_dest[2], quadColor[2]); /* B */
d496 3
a498 3
      VEC4_MUL(blend_dest[0], blend_dest[0], quadColor[3]); /* R * A */
      VEC4_MUL(blend_dest[1], blend_dest[1], quadColor[3]); /* G * A */
      VEC4_MUL(blend_dest[2], blend_dest[2], quadColor[3]); /* B * A */
d501 8
a508 3
      VEC4_MUL(blend_dest[0], blend_dest[0], blend_dest[3]); /* R * A */
      VEC4_MUL(blend_dest[1], blend_dest[1], blend_dest[3]); /* G * A */
      VEC4_MUL(blend_dest[2], blend_dest[2], blend_dest[3]); /* B * A */
d511 3
a513 3
      VEC4_MUL(blend_dest[0], blend_dest[0], blend_dest[0]); /* R */
      VEC4_MUL(blend_dest[1], blend_dest[1], blend_dest[1]); /* G */
      VEC4_MUL(blend_dest[2], blend_dest[2], blend_dest[2]); /* B */
d516 1
a516 1
      {
d519 1
a519 1
         VEC4_SUB(diff, one, blend_dest[3]);
d521 8
a528 3
         VEC4_MUL(blend_dest[0], blend_dest[0], temp); /* R */
         VEC4_MUL(blend_dest[1], blend_dest[1], temp); /* G */
         VEC4_MUL(blend_dest[2], blend_dest[2], temp); /* B */
d532 10
a541 10
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[0]); /* R */
         VEC4_MUL(blend_dest[0], blend_dest[0], comp); /* R */
         VEC4_SCALAR(comp, const_blend_color[1]); /* G */
         VEC4_MUL(blend_dest[1], blend_dest[1], comp); /* G */
         VEC4_SCALAR(comp, const_blend_color[2]); /* B */
         VEC4_MUL(blend_dest[2], blend_dest[2], comp); /* B */
      }
      break;
d543 8
a550 8
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[3]); /* A */
         VEC4_MUL(blend_dest[0], blend_dest[0], comp); /* R */
         VEC4_MUL(blend_dest[1], blend_dest[1], comp); /* G */
         VEC4_MUL(blend_dest[2], blend_dest[2], comp); /* B */
      }
      break;
d552 3
a554 3
      VEC4_COPY(blend_dest[0], zero); /* R */
      VEC4_COPY(blend_dest[1], zero); /* G */
      VEC4_COPY(blend_dest[2], zero); /* B */
a556 4
      VEC4_MUL(blend_dest[0], blend_dest[0], quadColor2[0]); /* R */
      VEC4_MUL(blend_dest[1], blend_dest[1], quadColor2[1]); /* G */
      VEC4_MUL(blend_dest[2], blend_dest[2], quadColor2[2]); /* B */
      break;
d558 2
a559 3
      VEC4_MUL(blend_dest[0], blend_dest[0], quadColor2[3]); /* R * A */
      VEC4_MUL(blend_dest[1], blend_dest[1], quadColor2[3]); /* G * A */
      VEC4_MUL(blend_dest[2], blend_dest[2], quadColor2[3]); /* B * A */
d562 10
a571 10
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, quadColor[0]); /* R */
         VEC4_MUL(blend_dest[0], inv_comp, blend_dest[0]); /* R */
         VEC4_SUB(inv_comp, one, quadColor[1]); /* G */
         VEC4_MUL(blend_dest[1], inv_comp, blend_dest[1]); /* G */
         VEC4_SUB(inv_comp, one, quadColor[2]); /* B */
         VEC4_MUL(blend_dest[2], inv_comp, blend_dest[2]); /* B */
      }
      break;
d573 8
a580 8
      {
         float one_minus_alpha[TGSI_QUAD_SIZE];
         VEC4_SUB(one_minus_alpha, one, quadColor[3]);
         VEC4_MUL(blend_dest[0], blend_dest[0], one_minus_alpha); /* R */
         VEC4_MUL(blend_dest[1], blend_dest[1], one_minus_alpha); /* G */
         VEC4_MUL(blend_dest[2], blend_dest[2], one_minus_alpha); /* B */
      }
      break;
d582 1
a582 1
      {
d584 9
a592 4
         VEC4_SUB(inv_comp, one, blend_dest[3]); /* A */
         VEC4_MUL(blend_dest[0], inv_comp, blend_dest[0]); /* R */
         VEC4_MUL(blend_dest[1], inv_comp, blend_dest[1]); /* G */
         VEC4_MUL(blend_dest[2], inv_comp, blend_dest[2]); /* B */
d594 1
a594 1
      break;
d596 10
a605 10
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, blend_dest[0]); /* R */
         VEC4_MUL(blend_dest[0], blend_dest[0], inv_comp); /* R */
         VEC4_SUB(inv_comp, one, blend_dest[1]); /* G */
         VEC4_MUL(blend_dest[1], blend_dest[1], inv_comp); /* G */
         VEC4_SUB(inv_comp, one, blend_dest[2]); /* B */
         VEC4_MUL(blend_dest[2], blend_dest[2], inv_comp); /* B */
      }
      break;
d607 13
a619 13
      {
         float inv_comp[4];
         /* R */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[0]);
         VEC4_MUL(blend_dest[0], blend_dest[0], inv_comp);
         /* G */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[1]);
         VEC4_MUL(blend_dest[1], blend_dest[1], inv_comp);
         /* B */
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[2]);
         VEC4_MUL(blend_dest[2], blend_dest[2], inv_comp);
      }
      break;
d621 8
a628 8
      {
         float inv_comp[4];
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[3]);
         VEC4_MUL(blend_dest[0], blend_dest[0], inv_comp);
         VEC4_MUL(blend_dest[1], blend_dest[1], inv_comp);
         VEC4_MUL(blend_dest[2], blend_dest[2], inv_comp);
      }
      break;
a629 10
      {
         float inv_comp[4];
         VEC4_SUB(inv_comp, one, quadColor2[0]); /* R */
         VEC4_MUL(blend_dest[0], inv_comp, blend_dest[0]); /* R */
         VEC4_SUB(inv_comp, one, quadColor2[1]); /* G */
         VEC4_MUL(blend_dest[1], inv_comp, blend_dest[1]); /* G */
         VEC4_SUB(inv_comp, one, quadColor2[2]); /* B */
         VEC4_MUL(blend_dest[2], inv_comp, blend_dest[2]); /* B */
      }
      break;
d631 2
a632 7
      {
         float one_minus_alpha[TGSI_QUAD_SIZE];
         VEC4_SUB(one_minus_alpha, one, quadColor2[3]);
         VEC4_MUL(blend_dest[0], blend_dest[0], one_minus_alpha); /* R */
         VEC4_MUL(blend_dest[1], blend_dest[1], one_minus_alpha); /* G */
         VEC4_MUL(blend_dest[2], blend_dest[2], one_minus_alpha); /* B */
      }
d639 1
a639 1
    * Compute blend_dest/second term A
d643 1
a643 1
      /* blend_dest = blend_dest * 1   NO-OP, leave blend_dest as-is */
d648 1
a648 1
      VEC4_MUL(blend_dest[3], blend_dest[3], quadColor[3]); /* A * A */
d653 6
a658 1
      VEC4_MUL(blend_dest[3], blend_dest[3], blend_dest[3]); /* A */
d661 1
a661 1
      /* blend_dest = blend_dest * 1   NO-OP, leave blend_dest as-is */
d666 6
a671 6
      {
         float comp[4];
         VEC4_SCALAR(comp, const_blend_color[3]); /* A */
         VEC4_MUL(blend_dest[3], blend_dest[3], comp); /* A */
      }
      break;
d673 1
a673 1
      VEC4_COPY(blend_dest[3], zero); /* A */
d678 6
a683 6
      {
         float one_minus_alpha[TGSI_QUAD_SIZE];
         VEC4_SUB(one_minus_alpha, one, quadColor[3]);
         VEC4_MUL(blend_dest[3], blend_dest[3], one_minus_alpha); /* A */
      }
      break;
d687 1
a687 1
      {
d689 5
a693 2
         VEC4_SUB(inv_comp, one, blend_dest[3]); /* A */
         VEC4_MUL(blend_dest[3], inv_comp, blend_dest[3]); /* A */
d699 6
a704 20
      {
         float inv_comp[4];
         VEC4_SCALAR(inv_comp, 1.0f - const_blend_color[3]);
         VEC4_MUL(blend_dest[3], blend_dest[3], inv_comp);
      }
      break;
   case PIPE_BLENDFACTOR_SRC1_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      VEC4_MUL(blend_dest[3], blend_dest[3], quadColor2[3]); /* A * A */
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
      /* fall-through */
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      {
         float one_minus_alpha[TGSI_QUAD_SIZE];
         VEC4_SUB(one_minus_alpha, one, quadColor2[3]);
         VEC4_MUL(blend_dest[3], blend_dest[3], one_minus_alpha); /* A */
      }
      break;
d714 3
a716 3
      VEC4_ADD(quadColor[0], source[0], blend_dest[0]); /* R */
      VEC4_ADD(quadColor[1], source[1], blend_dest[1]); /* G */
      VEC4_ADD(quadColor[2], source[2], blend_dest[2]); /* B */
d719 3
a721 3
      VEC4_SUB(quadColor[0], source[0], blend_dest[0]); /* R */
      VEC4_SUB(quadColor[1], source[1], blend_dest[1]); /* G */
      VEC4_SUB(quadColor[2], source[2], blend_dest[2]); /* B */
d724 3
a726 3
      VEC4_SUB(quadColor[0], blend_dest[0], source[0]); /* R */
      VEC4_SUB(quadColor[1], blend_dest[1], source[1]); /* G */
      VEC4_SUB(quadColor[2], blend_dest[2], source[2]); /* B */
d729 3
a731 3
      VEC4_MIN(quadColor[0], source[0], blend_dest[0]); /* R */
      VEC4_MIN(quadColor[1], source[1], blend_dest[1]); /* G */
      VEC4_MIN(quadColor[2], source[2], blend_dest[2]); /* B */
d734 3
a736 3
      VEC4_MAX(quadColor[0], source[0], blend_dest[0]); /* R */
      VEC4_MAX(quadColor[1], source[1], blend_dest[1]); /* G */
      VEC4_MAX(quadColor[2], source[2], blend_dest[2]); /* B */
d747 1
a747 1
      VEC4_ADD(quadColor[3], source[3], blend_dest[3]); /* A */
d750 1
a750 1
      VEC4_SUB(quadColor[3], source[3], blend_dest[3]); /* A */
d753 1
a753 1
      VEC4_SUB(quadColor[3], blend_dest[3], source[3]); /* A */
d756 1
a756 1
      VEC4_MIN(quadColor[3], source[3], blend_dest[3]); /* A */
d759 1
a759 1
      VEC4_MAX(quadColor[3], source[3], blend_dest[3]); /* A */
a788 62
/**
 * Clamp all colors in a quad to [0, 1]
 */
static void
clamp_colors(float (*quadColor)[4])
{
   unsigned i, j;

   for (j = 0; j < TGSI_QUAD_SIZE; j++) {
      for (i = 0; i < 4; i++) {
         quadColor[i][j] = CLAMP(quadColor[i][j], 0.0F, 1.0F);
      }
   }
}


/**
 * If we're drawing to a luminance, luminance/alpha or intensity surface
 * we have to adjust (rebase) the fragment/quad colors before writing them
 * to the tile cache.  The tile cache always stores RGBA colors but if
 * we're caching a L/A surface (for example) we need to be sure that R=G=B
 * so that subsequent reads from the surface cache appear to return L/A
 * values.
 * The piglit fbo-blending-formats test will exercise this.
 */
static void
rebase_colors(enum format base_format, float (*quadColor)[4])
{
   unsigned i;

   switch (base_format) {
   case RGB:
      for (i = 0; i < 4; i++) {
         /* A = 1 */
         quadColor[3][i] = 1.0F;
      }
      break;
   case LUMINANCE:
      for (i = 0; i < 4; i++) {
         /* B = G = R */
         quadColor[2][i] = quadColor[1][i] = quadColor[0][i];
         /* A = 1 */
         quadColor[3][i] = 1.0F;
      }
      break;
   case LUMINANCE_ALPHA:
      for (i = 0; i < 4; i++) {
         /* B = G = R */
         quadColor[2][i] = quadColor[1][i] = quadColor[0][i];
      }
      break;
   case INTENSITY:
      for (i = 0; i < 4; i++) {
         /* A = B = G = R */
         quadColor[3][i] = quadColor[2][i] = quadColor[1][i] = quadColor[0][i];
      }
      break;
   default:
      ; /* nothing */
   }
}

a793 1
   const struct blend_quad_stage *bqs = blend_quad_stage(qs);
a796 3
   boolean write_all;

   write_all = softpipe->fs_variant->info.color0_writes_all_cbufs;
d802 1
a802 1
      float dest[4][TGSI_QUAD_SIZE];
d807 2
a808 3
      const boolean clamp = bqs->clamp[cbuf];
      const float *blend_color;
      const boolean dual_source_blend = util_blend_state_is_dual(blend, cbuf);
a810 5
      if (clamp)
         blend_color = softpipe->blend_color_clamped.color;
      else
         blend_color = softpipe->blend_color.color;

d813 1
a813 3
         float (*quadColor)[4];
         float (*quadColor2)[4] = NULL;
         float temp_quad_color[TGSI_QUAD_SIZE][4];
d817 1
a817 21
         if (write_all) {
            for (j = 0; j < TGSI_QUAD_SIZE; j++) {
               for (i = 0; i < 4; i++) {
                  temp_quad_color[i][j] = quad->output.color[0][i][j];
               }
            }
            quadColor = temp_quad_color;
         } else {
            quadColor = quad->output.color[cbuf];
	    if (dual_source_blend)
	       quadColor2 = quad->output.color[cbuf + 1];
         }

         /* If fixed-point dest color buffer, need to clamp the incoming
          * fragment colors now.
          */
         if (clamp || softpipe->rasterizer->clamp_fragment_color) {
            clamp_colors(quadColor);
         }

         /* get/swizzle dest colors
d819 1
a819 1
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d829 1
a829 3
            if (bqs->format_type[cbuf] != UTIL_FORMAT_TYPE_FLOAT) {
               logicop_quad( qs, quadColor, dest );
            }
d832 1
a832 8
            blend_quad(qs, quadColor, quadColor2, dest, blend_color, blend_buf);

            /* If fixed-point dest color buffer, need to clamp the outgoing
             * fragment colors now.
             */
            if (clamp) {
               clamp_colors(quadColor);
            }
a834 2
         rebase_colors(bqs->base_format[cbuf], quadColor);

d840 1
a840 1
         for (j = 0; j < TGSI_QUAD_SIZE; j++) {
a858 1
   const struct blend_quad_stage *bqs = blend_quad_stage(qs);
d860 3
a862 3
   float one_minus_alpha[TGSI_QUAD_SIZE];
   float dest[4][TGSI_QUAD_SIZE];
   float source[4][TGSI_QUAD_SIZE];
d878 1
a878 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
a885 7
      /* If fixed-point dest color buffer, need to clamp the incoming
       * fragment colors now.
       */
      if (bqs->clamp[0] || qs->softpipe->rasterizer->clamp_fragment_color) {
         clamp_colors(quadColor);
      }

d895 1
a895 6
      VEC4_MUL(dest[3], dest[3], one_minus_alpha); /* A */

      VEC4_ADD(quadColor[0], source[0], dest[0]); /* R */
      VEC4_ADD(quadColor[1], source[1], dest[1]); /* G */
      VEC4_ADD(quadColor[2], source[2], dest[2]); /* B */
      VEC4_ADD(quadColor[3], source[3], dest[3]); /* A */
d897 4
a900 8
      /* If fixed-point dest color buffer, need to clamp the outgoing
       * fragment colors now.
       */
      if (bqs->clamp[0]) {
         clamp_colors(quadColor);
      }

      rebase_colors(bqs->base_format[0], quadColor);
d902 1
a902 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d919 1
a919 2
   const struct blend_quad_stage *bqs = blend_quad_stage(qs);
   float dest[4][TGSI_QUAD_SIZE];
d934 1
a934 1
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d942 4
a945 6
      /* If fixed-point dest color buffer, need to clamp the incoming
       * fragment colors now.
       */
      if (bqs->clamp[0] || qs->softpipe->rasterizer->clamp_fragment_color) {
         clamp_colors(quadColor);
      }
d947 1
a947 15
      VEC4_ADD(quadColor[0], quadColor[0], dest[0]); /* R */
      VEC4_ADD(quadColor[1], quadColor[1], dest[1]); /* G */
      VEC4_ADD(quadColor[2], quadColor[2], dest[2]); /* B */
      VEC4_ADD(quadColor[3], quadColor[3], dest[3]); /* A */

      /* If fixed-point dest color buffer, need to clamp the outgoing
       * fragment colors now.
       */
      if (bqs->clamp[0]) {
         clamp_colors(quadColor);
      }

      rebase_colors(bqs->base_format[0], quadColor);

      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
a959 6
/**
 * Just copy the quad color to the framebuffer tile (respecting the writemask),
 * for one color buffer.
 * Clamping will be done, if needed (depending on the color buffer's
 * datatype) when we write/pack the colors later.
 */
a964 1
   const struct blend_quad_stage *bqs = blend_quad_stage(qs);
d977 2
a978 7

      if (qs->softpipe->rasterizer->clamp_fragment_color)
         clamp_colors(quadColor);

      rebase_colors(bqs->base_format[0], quadColor);

      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
a1002 1
   struct blend_quad_stage *bqs = blend_quad_stage(qs);
a1004 1
   unsigned i;
a1034 23
   /* For each color buffer, determine if the buffer has destination alpha and
    * whether color clamping is needed.
    */
   for (i = 0; i < softpipe->framebuffer.nr_cbufs; i++) {
      const enum pipe_format format = softpipe->framebuffer.cbufs[i]->format;
      const struct util_format_description *desc =
         util_format_description(format);
      /* assuming all or no color channels are normalized: */
      bqs->clamp[i] = desc->channel[0].normalized;
      bqs->format_type[i] = desc->channel[0].type;

      if (util_format_is_intensity(format))
         bqs->base_format[i] = INTENSITY;
      else if (util_format_is_luminance(format))
         bqs->base_format[i] = LUMINANCE;
      else if (util_format_is_luminance_alpha(format))
         bqs->base_format[i] = LUMINANCE_ALPHA;
      else if (!util_format_has_alpha(format))
         bqs->base_format[i] = RGB;
      else
         bqs->base_format[i] = RGBA;
   }

d1053 1
a1053 4
   struct blend_quad_stage *stage = CALLOC_STRUCT(blend_quad_stage);

   if (!stage)
      return NULL;
d1055 4
a1058 4
   stage->base.softpipe = softpipe;
   stage->base.begin = blend_begin;
   stage->base.run = choose_blend_quad;
   stage->base.destroy = blend_destroy;
d1060 1
a1060 1
   return &stage->base;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d863 2
a864 2
   for (i = 0; i < 4; i++) {
      for (j = 0; j < TGSI_QUAD_SIZE; j++) {
d930 26
a955 39
   for (cbuf = 0; cbuf < softpipe->framebuffer.nr_cbufs; cbuf++) {
      if (softpipe->framebuffer.cbufs[cbuf]) {
         /* which blend/mask state index to use: */
         const uint blend_buf = blend->independent_blend_enable ? cbuf : 0;
         float dest[4][TGSI_QUAD_SIZE];
         struct softpipe_cached_tile *tile
            = sp_get_cached_tile(softpipe->cbuf_cache[cbuf],
                                 quads[0]->input.x0, 
                                 quads[0]->input.y0);
         const boolean clamp = bqs->clamp[cbuf];
         const float *blend_color;
         const boolean dual_source_blend = util_blend_state_is_dual(blend, cbuf);
         uint q, i, j;

         if (clamp)
            blend_color = softpipe->blend_color_clamped.color;
         else
            blend_color = softpipe->blend_color.color;

         for (q = 0; q < nr; q++) {
            struct quad_header *quad = quads[q];
            float (*quadColor)[4];
            float (*quadColor2)[4] = NULL;
            float temp_quad_color[TGSI_QUAD_SIZE][4];
            const int itx = (quad->input.x0 & (TILE_SIZE-1));
            const int ity = (quad->input.y0 & (TILE_SIZE-1));

            if (write_all) {
               for (j = 0; j < TGSI_QUAD_SIZE; j++) {
                  for (i = 0; i < 4; i++) {
                     temp_quad_color[i][j] = quad->output.color[0][i][j];
                  }
               }
               quadColor = temp_quad_color;
            } else {
               quadColor = quad->output.color[cbuf];
               if (dual_source_blend)
                  quadColor2 = quad->output.color[cbuf + 1];
            }
d957 1
a957 9
            /* If fixed-point dest color buffer, need to clamp the incoming
             * fragment colors now.
             */
            if (clamp || softpipe->rasterizer->clamp_fragment_color) {
               clamp_colors(quadColor);
            }

            /* get/swizzle dest colors
             */
a958 2
               int x = itx + (j & 1);
               int y = ity + (j >> 1);
d960 1
a960 1
                  dest[i][j] = tile->data.color[y][x][i];
d963 6
d970 6
d977 7
a983 4
            if (blend->logicop_enable) {
               if (bqs->format_type[cbuf] != UTIL_FORMAT_TYPE_FLOAT) {
                  logicop_quad( qs, quadColor, dest );
               }
d985 2
a986 2
            else if (blend->rt[blend_buf].blend_enable) {
               blend_quad(qs, quadColor, quadColor2, dest, blend_color, blend_buf);
d988 3
a990 6
               /* If fixed-point dest color buffer, need to clamp the outgoing
                * fragment colors now.
                */
               if (clamp) {
                  clamp_colors(quadColor);
               }
d992 3
d996 7
a1002 1
            rebase_colors(bqs->base_format[cbuf], quadColor);
d1004 1
a1004 2
            if (blend->rt[blend_buf].colormask != 0xf)
               colormask_quad( blend->rt[cbuf].colormask, quadColor, dest);
d1006 11
a1016 9
            /* Output color values
             */
            for (j = 0; j < TGSI_QUAD_SIZE; j++) {
               if (quad->inout.mask & (1 << j)) {
                  int x = itx + (j & 1);
                  int y = ity + (j >> 1);
                  for (i = 0; i < 4; i++) { /* loop over color chans */
                     tile->data.color[y][x][i] = quadColor[i][j];
                  }
d1234 1
a1234 4
      if (softpipe->framebuffer.cbufs[0] == NULL) {
         qs->run = blend_noop;
      }
      else if (!blend->rt[0].blend_enable) {
d1258 17
a1274 19
      if (softpipe->framebuffer.cbufs[i]) {
         const enum pipe_format format = softpipe->framebuffer.cbufs[i]->format;
         const struct util_format_description *desc =
            util_format_description(format);
         /* assuming all or no color channels are normalized: */
         bqs->clamp[i] = desc->channel[0].normalized;
         bqs->format_type[i] = desc->channel[0].type;

         if (util_format_is_intensity(format))
            bqs->base_format[i] = INTENSITY;
         else if (util_format_is_luminance(format))
            bqs->base_format[i] = LUMINANCE;
         else if (util_format_is_luminance_alpha(format))
            bqs->base_format[i] = LUMINANCE_ALPHA;
         else if (!util_format_has_alpha(format))
            bqs->base_format[i] = RGB;
         else
            bqs->base_format[i] = RGBA;
      }
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d926 3
a928 2
   boolean write_all =
      softpipe->fs_variant->info.properties[TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS];
d938 1
a938 1
                                 quads[0]->input.y0, quads[0]->input.layer);
d1041 1
a1041 1
                           quads[0]->input.y0, quads[0]->input.layer);
d1115 1
a1115 1
                           quads[0]->input.y0, quads[0]->input.layer);
d1183 1
a1183 1
                           quads[0]->input.y0, quads[0]->input.layer);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d926 2
a927 3
   boolean write_all;

   write_all = softpipe->fs_variant->info.color0_writes_all_cbufs;
d937 1
a937 1
                                 quads[0]->input.y0);
d1040 1
a1040 1
                           quads[0]->input.y0);
d1114 1
a1114 1
                           quads[0]->input.y0);
d1182 1
a1182 1
                           quads[0]->input.y0);
@


