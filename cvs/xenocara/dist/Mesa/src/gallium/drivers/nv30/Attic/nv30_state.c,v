head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.07.09.21.08.53;	author jsg;	state dead;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.40;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.36;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2012 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors: Ben Skeggs
 *
 */

#include "util/u_helpers.h"
#include "util/u_inlines.h"

#include "nouveau/nouveau_gldefs.h"
#include "nouveau/nv_object.xml.h"
#include "nv30-40_3d.xml.h"
#include "nv30_context.h"
#include "nv30_winsys.h"

#define NV40_3D_MRT_BLEND_ENABLE 0x0000036c

static void *
nv30_blend_state_create(struct pipe_context *pipe,
                        const struct pipe_blend_state *cso)
{
   struct nouveau_object *eng3d = nv30_context(pipe)->screen->eng3d;
   struct nv30_blend_stateobj *so;
   uint32_t blend[2], cmask[2];
   int i;

   so = CALLOC_STRUCT(nv30_blend_stateobj);
   if (!so)
      return NULL;
   so->pipe = *cso;

   if (cso->logicop_enable) {
      SB_MTHD30(so, COLOR_LOGIC_OP_ENABLE, 2);
      SB_DATA  (so, 1);
      SB_DATA  (so, nvgl_logicop_func(cso->logicop_func));
   } else {
      SB_MTHD30(so, COLOR_LOGIC_OP_ENABLE, 1);
      SB_DATA  (so, 0);
   }

   SB_MTHD30(so, DITHER_ENABLE, 1);
   SB_DATA  (so, cso->dither);

   blend[0] = cso->rt[0].blend_enable;
   cmask[0] = !!(cso->rt[0].colormask & PIPE_MASK_A) << 24 |
              !!(cso->rt[0].colormask & PIPE_MASK_R) << 16 |
              !!(cso->rt[0].colormask & PIPE_MASK_G) <<  8 |
              !!(cso->rt[0].colormask & PIPE_MASK_B);
   if (cso->independent_blend_enable) {
      blend[1] = 0;
      cmask[1] = 0;
      for (i = 1; i < 4; i++) {
         blend[1] |= cso->rt[i].blend_enable << i;
         cmask[1] |= !!(cso->rt[i].colormask & PIPE_MASK_A) << (0 + (i * 4)) |
                     !!(cso->rt[i].colormask & PIPE_MASK_R) << (1 + (i * 4)) |
                     !!(cso->rt[i].colormask & PIPE_MASK_G) << (2 + (i * 4)) |
                     !!(cso->rt[i].colormask & PIPE_MASK_B) << (3 + (i * 4));
      }
   } else {
      blend[1]  = 0x0000000e *   (blend[0] & 0x00000001);
      cmask[1]  = 0x00001110 * !!(cmask[0] & 0x01000000);
      cmask[1] |= 0x00002220 * !!(cmask[0] & 0x00010000);
      cmask[1] |= 0x00004440 * !!(cmask[0] & 0x00000100);
      cmask[1] |= 0x00008880 * !!(cmask[0] & 0x00000001);
   }

   if (eng3d->oclass >= NV40_3D_CLASS) {
      SB_MTHD40(so, MRT_BLEND_ENABLE, 2);
      SB_DATA  (so, blend[1]);
      SB_DATA  (so, cmask[1]);
   }

   if (blend[0] || blend[1]) {
      SB_MTHD30(so, BLEND_FUNC_ENABLE, 3);
      SB_DATA  (so, blend[0]);
      SB_DATA  (so, (nvgl_blend_func(cso->rt[0].alpha_src_factor) << 16) |
                     nvgl_blend_func(cso->rt[0].rgb_src_factor));
      SB_DATA  (so, (nvgl_blend_func(cso->rt[0].alpha_dst_factor) << 16) |
                     nvgl_blend_func(cso->rt[0].rgb_dst_factor));
      if (eng3d->oclass < NV40_3D_CLASS) {
         SB_MTHD30(so, BLEND_EQUATION, 1);
         SB_DATA  (so, nvgl_blend_eqn(cso->rt[0].rgb_func));
      } else {
         SB_MTHD40(so, BLEND_EQUATION, 1);
         SB_DATA  (so, (nvgl_blend_eqn(cso->rt[0].alpha_func) << 16) |
                        nvgl_blend_eqn(cso->rt[0].rgb_func));
      }
   } else {
      SB_MTHD30(so, BLEND_FUNC_ENABLE, 1);
      SB_DATA  (so, blend[0]);
   }

   SB_MTHD30(so, COLOR_MASK, 1);
   SB_DATA  (so, cmask[0]);
   return so;
}

static void
nv30_blend_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv30_context *nv30 = nv30_context(pipe);

   nv30->blend = hwcso;
   nv30->dirty |= NV30_NEW_BLEND;
}

static void
nv30_blend_state_delete(struct pipe_context *pipe, void *hwcso)
{
   FREE(hwcso);
}

static void *
nv30_rasterizer_state_create(struct pipe_context *pipe,
                             const struct pipe_rasterizer_state *cso)
{
   struct nv30_rasterizer_stateobj *so;

   so = CALLOC_STRUCT(nv30_rasterizer_stateobj);
   if (!so)
      return NULL;
   so->pipe = *cso;

   SB_MTHD30(so, SHADE_MODEL, 1);
   SB_DATA  (so, cso->flatshade ? NV30_3D_SHADE_MODEL_FLAT :
                                  NV30_3D_SHADE_MODEL_SMOOTH);

   SB_MTHD30(so, POLYGON_MODE_FRONT, 6);
   SB_DATA  (so, nvgl_polygon_mode(cso->fill_front));
   SB_DATA  (so, nvgl_polygon_mode(cso->fill_back));
   if (cso->cull_face == PIPE_FACE_FRONT_AND_BACK)
      SB_DATA  (so, NV30_3D_CULL_FACE_FRONT_AND_BACK);
   else
   if (cso->cull_face == PIPE_FACE_FRONT)
      SB_DATA  (so, NV30_3D_CULL_FACE_FRONT);
   else
      SB_DATA  (so, NV30_3D_CULL_FACE_BACK);
   SB_DATA  (so, cso->front_ccw ? NV30_3D_FRONT_FACE_CCW :
                                  NV30_3D_FRONT_FACE_CW);
   SB_DATA  (so, cso->poly_smooth);
   SB_DATA  (so, cso->cull_face != PIPE_FACE_NONE);

   SB_MTHD30(so, POLYGON_OFFSET_POINT_ENABLE, 3);
   SB_DATA  (so, cso->offset_point);
   SB_DATA  (so, cso->offset_line);
   SB_DATA  (so, cso->offset_tri);
   if (cso->offset_point || cso->offset_line || cso->offset_tri) {
      SB_MTHD30(so, POLYGON_OFFSET_FACTOR, 2);
      SB_DATA  (so, fui(cso->offset_scale));
      SB_DATA  (so, fui(cso->offset_units * 2.0));
   }

   SB_MTHD30(so, LINE_WIDTH, 2);
   SB_DATA  (so, (unsigned char)(cso->line_width * 8.0) & 0xff);
   SB_DATA  (so, cso->line_smooth);
   SB_MTHD30(so, LINE_STIPPLE_ENABLE, 2);
   SB_DATA  (so, cso->line_stipple_enable);
   SB_DATA  (so, (cso->line_stipple_pattern << 16) |
                  cso->line_stipple_factor);

   SB_MTHD30(so, VERTEX_TWO_SIDE_ENABLE, 1);
   SB_DATA  (so, cso->light_twoside);
   SB_MTHD30(so, POLYGON_STIPPLE_ENABLE, 1);
   SB_DATA  (so, cso->poly_stipple_enable);
   SB_MTHD30(so, POINT_SIZE, 1);
   SB_DATA  (so, fui(cso->point_size));
   SB_MTHD30(so, FLATSHADE_FIRST, 1);
   SB_DATA  (so, cso->flatshade_first);

   SB_MTHD30(so, DEPTH_CONTROL, 1);
   SB_DATA  (so, cso->depth_clip ? 0x00000001 : 0x00000010);
   return so;
}

static void
nv30_rasterizer_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv30_context *nv30 = nv30_context(pipe);

   nv30->rast = hwcso;
   nv30->dirty |= NV30_NEW_RASTERIZER;
}

static void
nv30_rasterizer_state_delete(struct pipe_context *pipe, void *hwcso)
{
   FREE(hwcso);
}

static void *
nv30_zsa_state_create(struct pipe_context *pipe,
                      const struct pipe_depth_stencil_alpha_state *cso)
{
   struct nv30_zsa_stateobj *so;

   so = CALLOC_STRUCT(nv30_zsa_stateobj);
   if (!so)
      return NULL;
   so->pipe = *cso;

   SB_MTHD30(so, DEPTH_FUNC, 3);
   SB_DATA  (so, nvgl_comparison_op(cso->depth.func));
   SB_DATA  (so, cso->depth.writemask);
   SB_DATA  (so, cso->depth.enabled);

   if (cso->stencil[0].enabled) {
      SB_MTHD30(so, STENCIL_ENABLE(0), 3);
      SB_DATA  (so, 1);
      SB_DATA  (so, cso->stencil[0].writemask);
      SB_DATA  (so, nvgl_comparison_op(cso->stencil[0].func));
      SB_MTHD30(so, STENCIL_FUNC_MASK(0), 4);
      SB_DATA  (so, cso->stencil[0].valuemask);
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[0].fail_op));
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[0].zfail_op));
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[0].zpass_op));
   } else {
      SB_MTHD30(so, STENCIL_ENABLE(0), 2);
      SB_DATA  (so, 0);
      SB_DATA  (so, 0x000000ff);
   }

   if (cso->stencil[1].enabled) {
      SB_MTHD30(so, STENCIL_ENABLE(1), 3);
      SB_DATA  (so, 1);
      SB_DATA  (so, cso->stencil[1].writemask);
      SB_DATA  (so, nvgl_comparison_op(cso->stencil[1].func));
      SB_MTHD30(so, STENCIL_FUNC_MASK(1), 4);
      SB_DATA  (so, cso->stencil[1].valuemask);
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[1].fail_op));
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[1].zfail_op));
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[1].zpass_op));
   } else {
      SB_MTHD30(so, STENCIL_ENABLE(1), 1);
      SB_DATA  (so, 0);
   }

   SB_MTHD30(so, ALPHA_FUNC_ENABLE, 3);
   SB_DATA  (so, cso->alpha.enabled ? 1 : 0);
   SB_DATA  (so, nvgl_comparison_op(cso->alpha.func));
   SB_DATA  (so, float_to_ubyte(cso->alpha.ref_value));

   return so;
}

static void
nv30_zsa_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv30_context *nv30 = nv30_context(pipe);

   nv30->zsa = hwcso;
   nv30->dirty |= NV30_NEW_ZSA;
}

static void
nv30_zsa_state_delete(struct pipe_context *pipe, void *hwcso)
{
   FREE(hwcso);
}

static void
nv30_set_blend_color(struct pipe_context *pipe,
                     const struct pipe_blend_color *bcol)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    nv30->blend_colour = *bcol;
    nv30->dirty |= NV30_NEW_BLEND_COLOUR;
}

static void
nv30_set_stencil_ref(struct pipe_context *pipe,
                     const struct pipe_stencil_ref *sr)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    nv30->stencil_ref = *sr;
    nv30->dirty |= NV30_NEW_STENCIL_REF;
}

static void
nv30_set_clip_state(struct pipe_context *pipe,
                    const struct pipe_clip_state *clip)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    memcpy(nv30->clip.ucp, clip->ucp, sizeof(clip->ucp));

    nv30->dirty |= NV30_NEW_CLIP;
}

static void
nv30_set_sample_mask(struct pipe_context *pipe, unsigned sample_mask)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    nv30->sample_mask = sample_mask;
    nv30->dirty |= NV30_NEW_SAMPLE_MASK;
}

static void
nv30_set_constant_buffer(struct pipe_context *pipe, uint shader, uint index,
                         struct pipe_constant_buffer *cb)
{
   struct nv30_context *nv30 = nv30_context(pipe);
   struct pipe_resource *buf = cb ? cb->buffer : NULL;
   unsigned size;

   if (cb && cb->user_buffer) {
      buf = nouveau_user_buffer_create(pipe->screen, (void*)cb->user_buffer,
                                       cb->buffer_size,
                                       PIPE_BIND_CONSTANT_BUFFER);
   }

   size = 0;
   if (buf)
      size = buf->width0 / (4 * sizeof(float));

   if (shader == PIPE_SHADER_VERTEX) {
      pipe_resource_reference(&nv30->vertprog.constbuf, buf);
      nv30->vertprog.constbuf_nr = size;
      nv30->dirty |= NV30_NEW_VERTCONST;
   } else
   if (shader == PIPE_SHADER_FRAGMENT) {
      pipe_resource_reference(&nv30->fragprog.constbuf, buf);
      nv30->fragprog.constbuf_nr = size;
      nv30->dirty |= NV30_NEW_FRAGCONST;
   }

   if (cb && cb->user_buffer) {
      pipe_resource_reference(&buf, NULL);
   }
}

static void
nv30_set_framebuffer_state(struct pipe_context *pipe,
                           const struct pipe_framebuffer_state *fb)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    nouveau_bufctx_reset(nv30->bufctx, BUFCTX_FB);

    nv30->framebuffer = *fb;
    nv30->dirty |= NV30_NEW_FRAMEBUFFER;
}

static void
nv30_set_polygon_stipple(struct pipe_context *pipe,
                         const struct pipe_poly_stipple *stipple)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    nv30->stipple = *stipple;
    nv30->dirty |= NV30_NEW_STIPPLE;
}

static void
nv30_set_scissor_states(struct pipe_context *pipe,
                        unsigned start_slot,
                        unsigned num_viewports,
                        const struct pipe_scissor_state *scissor)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    nv30->scissor = *scissor;
    nv30->dirty |= NV30_NEW_SCISSOR;
}

static void
nv30_set_viewport_states(struct pipe_context *pipe,
                         unsigned start_slot,
                         unsigned num_viewports,
                         const struct pipe_viewport_state *vpt)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    nv30->viewport = *vpt;
    nv30->dirty |= NV30_NEW_VIEWPORT;
}

static void
nv30_set_vertex_buffers(struct pipe_context *pipe,
                        unsigned start_slot, unsigned count,
                        const struct pipe_vertex_buffer *vb)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    nouveau_bufctx_reset(nv30->bufctx, BUFCTX_VTXBUF);

    util_set_vertex_buffers_count(nv30->vtxbuf, &nv30->num_vtxbufs,
                                  vb, start_slot, count);

    nv30->dirty |= NV30_NEW_ARRAYS;
}

static void
nv30_set_index_buffer(struct pipe_context *pipe,
                      const struct pipe_index_buffer *ib)
{
    struct nv30_context *nv30 = nv30_context(pipe);

    if (ib) {
       pipe_resource_reference(&nv30->idxbuf.buffer, ib->buffer);
       nv30->idxbuf.index_size = ib->index_size;
       nv30->idxbuf.offset = ib->offset;
       nv30->idxbuf.user_buffer = ib->user_buffer;
    } else {
       pipe_resource_reference(&nv30->idxbuf.buffer, NULL);
       nv30->idxbuf.user_buffer = NULL;
    }
}

void
nv30_state_init(struct pipe_context *pipe)
{
   pipe->create_blend_state = nv30_blend_state_create;
   pipe->bind_blend_state = nv30_blend_state_bind;
   pipe->delete_blend_state = nv30_blend_state_delete;

   pipe->create_rasterizer_state = nv30_rasterizer_state_create;
   pipe->bind_rasterizer_state = nv30_rasterizer_state_bind;
   pipe->delete_rasterizer_state = nv30_rasterizer_state_delete;

   pipe->create_depth_stencil_alpha_state = nv30_zsa_state_create;
   pipe->bind_depth_stencil_alpha_state = nv30_zsa_state_bind;
   pipe->delete_depth_stencil_alpha_state = nv30_zsa_state_delete;

   pipe->set_blend_color = nv30_set_blend_color;
   pipe->set_stencil_ref = nv30_set_stencil_ref;
   pipe->set_clip_state = nv30_set_clip_state;
   pipe->set_sample_mask = nv30_set_sample_mask;
   pipe->set_constant_buffer = nv30_set_constant_buffer;
   pipe->set_framebuffer_state = nv30_set_framebuffer_state;
   pipe->set_polygon_stipple = nv30_set_polygon_stipple;
   pipe->set_scissor_states = nv30_set_scissor_states;
   pipe->set_viewport_states = nv30_set_viewport_states;

   pipe->set_vertex_buffers = nv30_set_vertex_buffers;
   pipe->set_index_buffer = nv30_set_index_buffer;
}
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@d1 26
a26 2
#include "pipe/p_state.h"
#include "pipe/p_defines.h"
d29 5
a33 1
#include "tgsi/tgsi_parse.h"
d35 1
a35 2
#include "nv30_context.h"
#include "nv30_state.h"
d39 1
a39 1
			const struct pipe_blend_state *cso)
d41 74
a114 43
	struct nv30_context *nv30 = nv30_context(pipe);
	struct nouveau_grobj *rankine = nv30->screen->rankine;
	struct nv30_blend_state *bso = CALLOC(1, sizeof(*bso));
	struct nouveau_stateobj *so = so_new(5, 8, 0);

	if (cso->rt[0].blend_enable) {
		so_method(so, rankine, NV34TCL_BLEND_FUNC_ENABLE, 3);
		so_data  (so, 1);
		so_data  (so, (nvgl_blend_func(cso->rt[0].alpha_src_factor) << 16) |
			       nvgl_blend_func(cso->rt[0].rgb_src_factor));
		so_data  (so, nvgl_blend_func(cso->rt[0].alpha_dst_factor) << 16 |
			      nvgl_blend_func(cso->rt[0].rgb_dst_factor));
		/* FIXME: Gallium assumes GL_EXT_blend_func_separate.
		   It is not the case for NV30 */
		so_method(so, rankine, NV34TCL_BLEND_EQUATION, 1);
		so_data  (so, nvgl_blend_eqn(cso->rt[0].rgb_func));
	} else {
		so_method(so, rankine, NV34TCL_BLEND_FUNC_ENABLE, 1);
		so_data  (so, 0);
	}

	so_method(so, rankine, NV34TCL_COLOR_MASK, 1);
	so_data  (so, (((cso->rt[0].colormask & PIPE_MASK_A) ? (0x01 << 24) : 0) |
		       ((cso->rt[0].colormask & PIPE_MASK_R) ? (0x01 << 16) : 0) |
		       ((cso->rt[0].colormask & PIPE_MASK_G) ? (0x01 <<  8) : 0) |
		       ((cso->rt[0].colormask & PIPE_MASK_B) ? (0x01 <<  0) : 0)));

	if (cso->logicop_enable) {
		so_method(so, rankine, NV34TCL_COLOR_LOGIC_OP_ENABLE, 2);
		so_data  (so, 1);
		so_data  (so, nvgl_logicop_func(cso->logicop_func));
	} else {
		so_method(so, rankine, NV34TCL_COLOR_LOGIC_OP_ENABLE, 1);
		so_data  (so, 0);
	}

	so_method(so, rankine, NV34TCL_DITHER_ENABLE, 1);
	so_data  (so, cso->dither ? 1 : 0);

	so_ref(so, &bso->so);
	so_ref(NULL, &so);
	bso->pipe = *cso;
	return (void *)bso;
d120 1
a120 1
	struct nv30_context *nv30 = nv30_context(pipe);
d122 2
a123 2
	nv30->blend = hwcso;
	nv30->dirty |= NV30_NEW_BLEND;
d129 1
a129 43
	struct nv30_blend_state *bso = hwcso;

	so_ref(NULL, &bso->so);
	FREE(bso);
}


static INLINE unsigned
wrap_mode(unsigned wrap) {
	unsigned ret;

	switch (wrap) {
	case PIPE_TEX_WRAP_REPEAT:
		ret = NV34TCL_TX_WRAP_S_REPEAT;
		break;
	case PIPE_TEX_WRAP_MIRROR_REPEAT:
		ret = NV34TCL_TX_WRAP_S_MIRRORED_REPEAT;
		break;
	case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
		ret = NV34TCL_TX_WRAP_S_CLAMP_TO_EDGE;
		break;
	case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
		ret = NV34TCL_TX_WRAP_S_CLAMP_TO_BORDER;
		break;
	case PIPE_TEX_WRAP_CLAMP:
		ret = NV34TCL_TX_WRAP_S_CLAMP;
		break;
/*	case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
		ret = NV34TCL_TX_WRAP_S_MIRROR_CLAMP_TO_EDGE;
		break;
	case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER:
		ret = NV34TCL_TX_WRAP_S_MIRROR_CLAMP_TO_BORDER;
		break;
	case PIPE_TEX_WRAP_MIRROR_CLAMP:
		ret = NV34TCL_TX_WRAP_S_MIRROR_CLAMP;
		break;*/
	default:
		NOUVEAU_ERR("unknown wrap mode: %d\n", wrap);
		ret = NV34TCL_TX_WRAP_S_REPEAT;
		break;
	}

	return ret >> NV34TCL_TX_WRAP_S_SHIFT;
d133 2
a134 2
nv30_sampler_state_create(struct pipe_context *pipe,
			  const struct pipe_sampler_state *cso)
d136 1
a136 172
	struct nv30_sampler_state *ps;
	uint32_t filter = 0;

	ps = MALLOC(sizeof(struct nv30_sampler_state));

	ps->fmt = 0;
	/* TODO: Not all RECTs formats have this bit set, bits 15-8 of format
	   are the tx format to use. We should store normalized coord flag
	   in sampler state structure, and set appropriate format in
	   nvxx_fragtex_build()
	 */
	/*NV34TCL_TX_FORMAT_RECT*/
	/*if (!cso->normalized_coords) {
		ps->fmt |= (1<<14) ;
	}*/

	ps->wrap = ((wrap_mode(cso->wrap_s) << NV34TCL_TX_WRAP_S_SHIFT) |
		    (wrap_mode(cso->wrap_t) << NV34TCL_TX_WRAP_T_SHIFT) |
		    (wrap_mode(cso->wrap_r) << NV34TCL_TX_WRAP_R_SHIFT));

	ps->en = 0;

	if (cso->max_anisotropy >= 8) {
		ps->en |= NV34TCL_TX_ENABLE_ANISO_8X;
	} else
	if (cso->max_anisotropy >= 4) {
		ps->en |= NV34TCL_TX_ENABLE_ANISO_4X;
	} else
	if (cso->max_anisotropy >= 2) {
		ps->en |= NV34TCL_TX_ENABLE_ANISO_2X;
	}

	switch (cso->mag_img_filter) {
	case PIPE_TEX_FILTER_LINEAR:
		filter |= NV34TCL_TX_FILTER_MAGNIFY_LINEAR;
		break;
	case PIPE_TEX_FILTER_NEAREST:
	default:
		filter |= NV34TCL_TX_FILTER_MAGNIFY_NEAREST;
		break;
	}

	switch (cso->min_img_filter) {
	case PIPE_TEX_FILTER_LINEAR:
		switch (cso->min_mip_filter) {
		case PIPE_TEX_MIPFILTER_NEAREST:
			filter |= NV34TCL_TX_FILTER_MINIFY_LINEAR_MIPMAP_NEAREST;
			break;
		case PIPE_TEX_MIPFILTER_LINEAR:
			filter |= NV34TCL_TX_FILTER_MINIFY_LINEAR_MIPMAP_LINEAR;
			break;
		case PIPE_TEX_MIPFILTER_NONE:
		default:
			filter |= NV34TCL_TX_FILTER_MINIFY_LINEAR;
			break;
		}
		break;
	case PIPE_TEX_FILTER_NEAREST:
	default:
		switch (cso->min_mip_filter) {
		case PIPE_TEX_MIPFILTER_NEAREST:
			filter |= NV34TCL_TX_FILTER_MINIFY_NEAREST_MIPMAP_NEAREST;
		break;
		case PIPE_TEX_MIPFILTER_LINEAR:
			filter |= NV34TCL_TX_FILTER_MINIFY_NEAREST_MIPMAP_LINEAR;
			break;
		case PIPE_TEX_MIPFILTER_NONE:
		default:
			filter |= NV34TCL_TX_FILTER_MINIFY_NEAREST;
			break;
		}
		break;
	}

	ps->filt = filter;

	{
		float limit;

		limit = CLAMP(cso->lod_bias, -16.0, 15.0);
		ps->filt |= (int)(cso->lod_bias * 256.0) & 0x1fff;

		limit = CLAMP(cso->max_lod, 0.0, 15.0);
		ps->en |= (int)(limit) << 14 /*NV34TCL_TX_ENABLE_MIPMAP_MAX_LOD_SHIFT*/;

		limit = CLAMP(cso->min_lod, 0.0, 15.0);
		ps->en |= (int)(limit) << 26 /*NV34TCL_TX_ENABLE_MIPMAP_MIN_LOD_SHIFT*/;
	}

	if (cso->compare_mode == PIPE_TEX_COMPARE_R_TO_TEXTURE) {
		switch (cso->compare_func) {
		case PIPE_FUNC_NEVER:
			ps->wrap |= NV34TCL_TX_WRAP_RCOMP_NEVER;
			break;
		case PIPE_FUNC_GREATER:
			ps->wrap |= NV34TCL_TX_WRAP_RCOMP_GREATER;
			break;
		case PIPE_FUNC_EQUAL:
			ps->wrap |= NV34TCL_TX_WRAP_RCOMP_EQUAL;
			break;
		case PIPE_FUNC_GEQUAL:
			ps->wrap |= NV34TCL_TX_WRAP_RCOMP_GEQUAL;
			break;
		case PIPE_FUNC_LESS:
			ps->wrap |= NV34TCL_TX_WRAP_RCOMP_LESS;
			break;
		case PIPE_FUNC_NOTEQUAL:
			ps->wrap |= NV34TCL_TX_WRAP_RCOMP_NOTEQUAL;
			break;
		case PIPE_FUNC_LEQUAL:
			ps->wrap |= NV34TCL_TX_WRAP_RCOMP_LEQUAL;
			break;
		case PIPE_FUNC_ALWAYS:
			ps->wrap |= NV34TCL_TX_WRAP_RCOMP_ALWAYS;
			break;
		default:
			break;
		}
	}

	ps->bcol = ((float_to_ubyte(cso->border_color[3]) << 24) |
		    (float_to_ubyte(cso->border_color[0]) << 16) |
		    (float_to_ubyte(cso->border_color[1]) <<  8) |
		    (float_to_ubyte(cso->border_color[2]) <<  0));

	return (void *)ps;
}

static void
nv30_sampler_state_bind(struct pipe_context *pipe, unsigned nr, void **sampler)
{
	struct nv30_context *nv30 = nv30_context(pipe);
	unsigned unit;

	for (unit = 0; unit < nr; unit++) {
		nv30->tex_sampler[unit] = sampler[unit];
		nv30->dirty_samplers |= (1 << unit);
	}

	for (unit = nr; unit < nv30->nr_samplers; unit++) {
		nv30->tex_sampler[unit] = NULL;
		nv30->dirty_samplers |= (1 << unit);
	}

	nv30->nr_samplers = nr;
	nv30->dirty |= NV30_NEW_SAMPLER;
}

static void
nv30_sampler_state_delete(struct pipe_context *pipe, void *hwcso)
{
	FREE(hwcso);
}

static void
nv30_set_sampler_texture(struct pipe_context *pipe, unsigned nr,
			 struct pipe_texture **miptree)
{
	struct nv30_context *nv30 = nv30_context(pipe);
	unsigned unit;

	for (unit = 0; unit < nr; unit++) {
		pipe_texture_reference((struct pipe_texture **)
				       &nv30->tex_miptree[unit], miptree[unit]);
		nv30->dirty_samplers |= (1 << unit);
	}

	for (unit = nr; unit < nv30->nr_textures; unit++) {
		pipe_texture_reference((struct pipe_texture **)
				       &nv30->tex_miptree[unit], NULL);
		nv30->dirty_samplers |= (1 << unit);
	}
d138 54
a191 118
	nv30->nr_textures = nr;
	nv30->dirty |= NV30_NEW_SAMPLER;
}

static void *
nv30_rasterizer_state_create(struct pipe_context *pipe,
			     const struct pipe_rasterizer_state *cso)
{
	struct nv30_context *nv30 = nv30_context(pipe);
	struct nv30_rasterizer_state *rsso = CALLOC(1, sizeof(*rsso));
	struct nouveau_stateobj *so = so_new(9, 19, 0);
	struct nouveau_grobj *rankine = nv30->screen->rankine;

	/*XXX: ignored:
	 * 	light_twoside
	 * 	point_smooth -nohw
	 * 	multisample
	 */

	so_method(so, rankine, NV34TCL_SHADE_MODEL, 1);
	so_data  (so, cso->flatshade ? NV34TCL_SHADE_MODEL_FLAT :
				       NV34TCL_SHADE_MODEL_SMOOTH);

	so_method(so, rankine, NV34TCL_LINE_WIDTH, 2);
	so_data  (so, (unsigned char)(cso->line_width * 8.0) & 0xff);
	so_data  (so, cso->line_smooth ? 1 : 0);
	so_method(so, rankine, NV34TCL_LINE_STIPPLE_ENABLE, 2);
	so_data  (so, cso->line_stipple_enable ? 1 : 0);
	so_data  (so, (cso->line_stipple_pattern << 16) |
		       cso->line_stipple_factor);

	so_method(so, rankine, NV34TCL_POINT_SIZE, 1);
	so_data  (so, fui(cso->point_size));

	so_method(so, rankine, NV34TCL_POLYGON_MODE_FRONT, 6);
	if (cso->front_winding == PIPE_WINDING_CCW) {
		so_data(so, nvgl_polygon_mode(cso->fill_ccw));
		so_data(so, nvgl_polygon_mode(cso->fill_cw));
		switch (cso->cull_mode) {
		case PIPE_WINDING_CCW:
			so_data(so, NV34TCL_CULL_FACE_FRONT);
			break;
		case PIPE_WINDING_CW:
			so_data(so, NV34TCL_CULL_FACE_BACK);
			break;
		case PIPE_WINDING_BOTH:
			so_data(so, NV34TCL_CULL_FACE_FRONT_AND_BACK);
			break;
		default:
			so_data(so, NV34TCL_CULL_FACE_BACK);
			break;
		}
		so_data(so, NV34TCL_FRONT_FACE_CCW);
	} else {
		so_data(so, nvgl_polygon_mode(cso->fill_cw));
		so_data(so, nvgl_polygon_mode(cso->fill_ccw));
		switch (cso->cull_mode) {
		case PIPE_WINDING_CCW:
			so_data(so, NV34TCL_CULL_FACE_BACK);
			break;
		case PIPE_WINDING_CW:
			so_data(so, NV34TCL_CULL_FACE_FRONT);
			break;
		case PIPE_WINDING_BOTH:
			so_data(so, NV34TCL_CULL_FACE_FRONT_AND_BACK);
			break;
		default:
			so_data(so, NV34TCL_CULL_FACE_BACK);
			break;
		}
		so_data(so, NV34TCL_FRONT_FACE_CW);
	}
	so_data(so, cso->poly_smooth ? 1 : 0);
	so_data(so, (cso->cull_mode != PIPE_WINDING_NONE) ? 1 : 0);

	so_method(so, rankine, NV34TCL_POLYGON_STIPPLE_ENABLE, 1);
	so_data  (so, cso->poly_stipple_enable ? 1 : 0);

	so_method(so, rankine, NV34TCL_POLYGON_OFFSET_POINT_ENABLE, 3);
	if ((cso->offset_cw && cso->fill_cw == PIPE_POLYGON_MODE_POINT) ||
	    (cso->offset_ccw && cso->fill_ccw == PIPE_POLYGON_MODE_POINT))
		so_data(so, 1);
	else
		so_data(so, 0);
	if ((cso->offset_cw && cso->fill_cw == PIPE_POLYGON_MODE_LINE) ||
	    (cso->offset_ccw && cso->fill_ccw == PIPE_POLYGON_MODE_LINE))
		so_data(so, 1);
	else
		so_data(so, 0);
	if ((cso->offset_cw && cso->fill_cw == PIPE_POLYGON_MODE_FILL) ||
	    (cso->offset_ccw && cso->fill_ccw == PIPE_POLYGON_MODE_FILL))
		so_data(so, 1);
	else
		so_data(so, 0);
	if (cso->offset_cw || cso->offset_ccw) {
		so_method(so, rankine, NV34TCL_POLYGON_OFFSET_FACTOR, 2);
		so_data  (so, fui(cso->offset_scale));
		so_data  (so, fui(cso->offset_units * 2));
	}

	so_method(so, rankine, NV34TCL_POINT_SPRITE, 1);
	if (cso->point_quad_rasterization) {
		unsigned psctl = (1 << 0), i;

		for (i = 0; i < 8; i++) {
			if ((cso->sprite_coord_enable >> i) & 1)
				psctl |= (1 << (8 + i));
		}

		so_data(so, psctl);
	} else {
		so_data(so, 0);
	}

	so_ref(so, &rsso->so);
	so_ref(NULL, &so);
	rsso->pipe = *cso;
	return (void *)rsso;
d197 1
a197 1
	struct nv30_context *nv30 = nv30_context(pipe);
d199 2
a200 3
	nv30->rasterizer = hwcso;
	nv30->dirty |= NV30_NEW_RAST;
	/*nv30->draw_dirty |= NV30_NEW_RAST;*/
d206 1
a206 4
	struct nv30_rasterizer_state *rsso = hwcso;

	so_ref(NULL, &rsso->so);
	FREE(rsso);
d210 2
a211 2
nv30_depth_stencil_alpha_state_create(struct pipe_context *pipe,
			const struct pipe_depth_stencil_alpha_state *cso)
d213 1
a213 59
	struct nv30_context *nv30 = nv30_context(pipe);
	struct nv30_zsa_state *zsaso = CALLOC(1, sizeof(*zsaso));
	struct nouveau_stateobj *so = so_new(6, 20, 0);
	struct nouveau_grobj *rankine = nv30->screen->rankine;

	so_method(so, rankine, NV34TCL_DEPTH_FUNC, 3);
	so_data  (so, nvgl_comparison_op(cso->depth.func));
	so_data  (so, cso->depth.writemask ? 1 : 0);
	so_data  (so, cso->depth.enabled ? 1 : 0);

	so_method(so, rankine, NV34TCL_ALPHA_FUNC_ENABLE, 3);
	so_data  (so, cso->alpha.enabled ? 1 : 0);
	so_data  (so, nvgl_comparison_op(cso->alpha.func));
	so_data  (so, float_to_ubyte(cso->alpha.ref_value));

	if (cso->stencil[0].enabled) {
		so_method(so, rankine, NV34TCL_STENCIL_FRONT_ENABLE, 3);
		so_data  (so, cso->stencil[0].enabled ? 1 : 0);
		so_data  (so, cso->stencil[0].writemask);
		so_data  (so, nvgl_comparison_op(cso->stencil[0].func));
		so_method(so, rankine, NV34TCL_STENCIL_FRONT_FUNC_MASK, 4);
		so_data  (so, cso->stencil[0].valuemask);
		so_data  (so, nvgl_stencil_op(cso->stencil[0].fail_op));
		so_data  (so, nvgl_stencil_op(cso->stencil[0].zfail_op));
		so_data  (so, nvgl_stencil_op(cso->stencil[0].zpass_op));
	} else {
		so_method(so, rankine, NV34TCL_STENCIL_FRONT_ENABLE, 1);
		so_data  (so, 0);
	}

	if (cso->stencil[1].enabled) {
		so_method(so, rankine, NV34TCL_STENCIL_BACK_ENABLE, 3);
		so_data  (so, cso->stencil[1].enabled ? 1 : 0);
		so_data  (so, cso->stencil[1].writemask);
		so_data  (so, nvgl_comparison_op(cso->stencil[1].func));
		so_method(so, rankine, NV34TCL_STENCIL_BACK_FUNC_MASK, 4);
		so_data  (so, cso->stencil[1].valuemask);
		so_data  (so, nvgl_stencil_op(cso->stencil[1].fail_op));
		so_data  (so, nvgl_stencil_op(cso->stencil[1].zfail_op));
		so_data  (so, nvgl_stencil_op(cso->stencil[1].zpass_op));
	} else {
		so_method(so, rankine, NV34TCL_STENCIL_BACK_ENABLE, 1);
		so_data  (so, 0);
	}

	so_ref(so, &zsaso->so);
	so_ref(NULL, &so);
	zsaso->pipe = *cso;
	return (void *)zsaso;
}

static void
nv30_depth_stencil_alpha_state_bind(struct pipe_context *pipe, void *hwcso)
{
	struct nv30_context *nv30 = nv30_context(pipe);

	nv30->zsa = hwcso;
	nv30->dirty |= NV30_NEW_ZSA;
}
d215 53
a267 4
static void
nv30_depth_stencil_alpha_state_delete(struct pipe_context *pipe, void *hwcso)
{
	struct nv30_zsa_state *zsaso = hwcso;
d269 2
a270 16
	so_ref(NULL, &zsaso->so);
	FREE(zsaso);
}

static void *
nv30_vp_state_create(struct pipe_context *pipe,
		     const struct pipe_shader_state *cso)
{
	/*struct nv30_context *nv30 = nv30_context(pipe);*/
	struct nv30_vertex_program *vp;

	vp = CALLOC(1, sizeof(struct nv30_vertex_program));
	vp->pipe.tokens = tgsi_dup_tokens(cso->tokens);
	/*vp->draw = draw_create_vertex_shader(nv30->draw, &vp->pipe);*/

	return (void *)vp;
d274 1
a274 1
nv30_vp_state_bind(struct pipe_context *pipe, void *hwcso)
d276 1
a276 5
	struct nv30_context *nv30 = nv30_context(pipe);

	nv30->vertprog = hwcso;
	nv30->dirty |= NV30_NEW_VERTPROG;
	/*nv30->draw_dirty |= NV30_NEW_VERTPROG;*/
d280 2
a281 1
nv30_vp_state_delete(struct pipe_context *pipe, void *hwcso)
d283 1
a283 17
	struct nv30_context *nv30 = nv30_context(pipe);
	struct nv30_vertex_program *vp = hwcso;

	/*draw_delete_vertex_shader(nv30->draw, vp->draw);*/
	nv30_vertprog_destroy(nv30, vp);
	FREE((void*)vp->pipe.tokens);
	FREE(vp);
}

static void *
nv30_fp_state_create(struct pipe_context *pipe,
		     const struct pipe_shader_state *cso)
{
	struct nv30_fragment_program *fp;

	fp = CALLOC(1, sizeof(struct nv30_fragment_program));
	fp->pipe.tokens = tgsi_dup_tokens(cso->tokens);
d285 2
a286 3
	tgsi_scan_shader(fp->pipe.tokens, &fp->info);

	return (void *)fp;
d290 2
a291 1
nv30_fp_state_bind(struct pipe_context *pipe, void *hwcso)
d293 1
a293 1
	struct nv30_context *nv30 = nv30_context(pipe);
d295 2
a296 2
	nv30->fragprog = hwcso;
	nv30->dirty |= NV30_NEW_FRAGPROG;
d300 2
a301 1
nv30_fp_state_delete(struct pipe_context *pipe, void *hwcso)
d303 1
a303 2
	struct nv30_context *nv30 = nv30_context(pipe);
	struct nv30_fragment_program *fp = hwcso;
d305 1
a305 4
	nv30_fragprog_destroy(nv30, fp);
	FREE((void*)fp->pipe.tokens);
	FREE(fp);
}
d307 1
a307 8
static void
nv30_set_blend_color(struct pipe_context *pipe,
		     const struct pipe_blend_color *bcol)
{
	struct nv30_context *nv30 = nv30_context(pipe);

	nv30->blend_colour = *bcol;
	nv30->dirty |= NV30_NEW_BCOL;
d311 1
a311 2
nv30_set_stencil_ref(struct pipe_context *pipe,
		     const struct pipe_stencil_ref *sr)
d313 1
a313 5
	struct nv30_context *nv30 = nv30_context(pipe);

	nv30->stencil_ref = *sr;
	nv30->dirty |= NV30_NEW_SR;
}
d315 2
a316 4
static void
nv30_set_clip_state(struct pipe_context *pipe,
		    const struct pipe_clip_state *clip)
{
d321 1
a321 1
			 struct pipe_buffer *buf )
d323 28
a350 11
	struct nv30_context *nv30 = nv30_context(pipe);

	nv30->constbuf[shader] = buf;
	nv30->constbuf_nr[shader] = buf->size / (4 * sizeof(float));

	if (shader == PIPE_SHADER_VERTEX) {
		nv30->dirty |= NV30_NEW_VERTPROG;
	} else
	if (shader == PIPE_SHADER_FRAGMENT) {
		nv30->dirty |= NV30_NEW_FRAGPROG;
	}
d355 1
a355 1
			   const struct pipe_framebuffer_state *fb)
d357 3
a359 1
	struct nv30_context *nv30 = nv30_context(pipe);
d361 2
a362 2
	nv30->framebuffer = *fb;
	nv30->dirty |= NV30_NEW_FB;
d367 1
a367 1
			 const struct pipe_poly_stipple *stipple)
d369 1
a369 1
	struct nv30_context *nv30 = nv30_context(pipe);
d371 2
a372 2
	memcpy(nv30->stipple, stipple->stipple, 4 * 32);
	nv30->dirty |= NV30_NEW_STIPPLE;
d376 4
a379 2
nv30_set_scissor_state(struct pipe_context *pipe,
		       const struct pipe_scissor_state *s)
d381 1
a381 1
	struct nv30_context *nv30 = nv30_context(pipe);
d383 2
a384 2
	nv30->scissor = *s;
	nv30->dirty |= NV30_NEW_SCISSOR;
d388 4
a391 2
nv30_set_viewport_state(struct pipe_context *pipe,
			const struct pipe_viewport_state *vpt)
d393 1
a393 1
	struct nv30_context *nv30 = nv30_context(pipe);
d395 2
a396 3
	nv30->viewport = *vpt;
	nv30->dirty |= NV30_NEW_VIEWPORT;
	/*nv30->draw_dirty |= NV30_NEW_VIEWPORT;*/
d400 3
a402 2
nv30_set_vertex_buffers(struct pipe_context *pipe, unsigned count,
			const struct pipe_vertex_buffer *vb)
d404 1
a404 1
	struct nv30_context *nv30 = nv30_context(pipe);
d406 1
a406 2
	memcpy(nv30->vtxbuf, vb, sizeof(*vb) * count);
	nv30->vtxbuf_nr = count;
d408 4
a411 2
	nv30->dirty |= NV30_NEW_ARRAYS;
	/*nv30->draw_dirty |= NV30_NEW_ARRAYS;*/
d415 2
a416 2
nv30_set_vertex_elements(struct pipe_context *pipe, unsigned count,
			 const struct pipe_vertex_element *ve)
d418 1
a418 4
	struct nv30_context *nv30 = nv30_context(pipe);

	memcpy(nv30->vtxelt, ve, sizeof(*ve) * count);
	nv30->vtxelt_nr = count;
d420 9
a428 2
	nv30->dirty |= NV30_NEW_ARRAYS;
	/*nv30->draw_dirty |= NV30_NEW_ARRAYS;*/
d432 1
a432 1
nv30_init_state_functions(struct nv30_context *nv30)
d434 21
a454 36
	nv30->pipe.create_blend_state = nv30_blend_state_create;
	nv30->pipe.bind_blend_state = nv30_blend_state_bind;
	nv30->pipe.delete_blend_state = nv30_blend_state_delete;

	nv30->pipe.create_sampler_state = nv30_sampler_state_create;
	nv30->pipe.bind_fragment_sampler_states = nv30_sampler_state_bind;
	nv30->pipe.delete_sampler_state = nv30_sampler_state_delete;
	nv30->pipe.set_fragment_sampler_textures = nv30_set_sampler_texture;

	nv30->pipe.create_rasterizer_state = nv30_rasterizer_state_create;
	nv30->pipe.bind_rasterizer_state = nv30_rasterizer_state_bind;
	nv30->pipe.delete_rasterizer_state = nv30_rasterizer_state_delete;

	nv30->pipe.create_depth_stencil_alpha_state =
		nv30_depth_stencil_alpha_state_create;
	nv30->pipe.bind_depth_stencil_alpha_state =
		nv30_depth_stencil_alpha_state_bind;
	nv30->pipe.delete_depth_stencil_alpha_state =
		nv30_depth_stencil_alpha_state_delete;

	nv30->pipe.create_vs_state = nv30_vp_state_create;
	nv30->pipe.bind_vs_state = nv30_vp_state_bind;
	nv30->pipe.delete_vs_state = nv30_vp_state_delete;

	nv30->pipe.create_fs_state = nv30_fp_state_create;
	nv30->pipe.bind_fs_state = nv30_fp_state_bind;
	nv30->pipe.delete_fs_state = nv30_fp_state_delete;

	nv30->pipe.set_blend_color = nv30_set_blend_color;
        nv30->pipe.set_stencil_ref = nv30_set_stencil_ref;
	nv30->pipe.set_clip_state = nv30_set_clip_state;
	nv30->pipe.set_constant_buffer = nv30_set_constant_buffer;
	nv30->pipe.set_framebuffer_state = nv30_set_framebuffer_state;
	nv30->pipe.set_polygon_stipple = nv30_set_polygon_stipple;
	nv30->pipe.set_scissor_state = nv30_set_scissor_state;
	nv30->pipe.set_viewport_state = nv30_set_viewport_state;
d456 2
a457 2
	nv30->pipe.set_vertex_buffers = nv30_set_vertex_buffers;
	nv30->pipe.set_vertex_elements = nv30_set_vertex_elements;
a458 1

@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d1 3
a3 24
/*
 * Copyright 2012 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors: Ben Skeggs
 *
 */
d5 1
a5 2
#include "util/u_helpers.h"
#include "util/u_inlines.h"
a6 3
#include "nouveau/nouveau_gldefs.h"
#include "nouveau/nv_object.xml.h"
#include "nv30-40_3d.xml.h"
d8 1
a8 3
#include "nv30_winsys.h"

#define NV40_3D_MRT_BLEND_ENABLE 0x0000036c
d12 1
a12 1
                        const struct pipe_blend_state *cso)
d14 43
a56 74
   struct nouveau_object *eng3d = nv30_context(pipe)->screen->eng3d;
   struct nv30_blend_stateobj *so;
   uint32_t blend[2], cmask[2];
   int i;

   so = CALLOC_STRUCT(nv30_blend_stateobj);
   if (!so)
      return NULL;
   so->pipe = *cso;

   if (cso->logicop_enable) {
      SB_MTHD30(so, COLOR_LOGIC_OP_ENABLE, 2);
      SB_DATA  (so, 1);
      SB_DATA  (so, nvgl_logicop_func(cso->logicop_func));
   } else {
      SB_MTHD30(so, COLOR_LOGIC_OP_ENABLE, 1);
      SB_DATA  (so, 0);
   }

   SB_MTHD30(so, DITHER_ENABLE, 1);
   SB_DATA  (so, cso->dither);

   blend[0] = cso->rt[0].blend_enable;
   cmask[0] = !!(cso->rt[0].colormask & PIPE_MASK_A) << 24 |
              !!(cso->rt[0].colormask & PIPE_MASK_R) << 16 |
              !!(cso->rt[0].colormask & PIPE_MASK_G) <<  8 |
              !!(cso->rt[0].colormask & PIPE_MASK_B);
   if (cso->independent_blend_enable) {
      blend[1] = 0;
      cmask[1] = 0;
      for (i = 1; i < 4; i++) {
         blend[1] |= cso->rt[i].blend_enable << i;
         cmask[1] |= !!(cso->rt[i].colormask & PIPE_MASK_A) << (0 + (i * 4)) |
                     !!(cso->rt[i].colormask & PIPE_MASK_R) << (1 + (i * 4)) |
                     !!(cso->rt[i].colormask & PIPE_MASK_G) << (2 + (i * 4)) |
                     !!(cso->rt[i].colormask & PIPE_MASK_B) << (3 + (i * 4));
      }
   } else {
      blend[1]  = 0x0000000e *   (blend[0] & 0x00000001);
      cmask[1]  = 0x00001110 * !!(cmask[0] & 0x01000000);
      cmask[1] |= 0x00002220 * !!(cmask[0] & 0x00010000);
      cmask[1] |= 0x00004440 * !!(cmask[0] & 0x00000100);
      cmask[1] |= 0x00008880 * !!(cmask[0] & 0x00000001);
   }

   if (eng3d->oclass >= NV40_3D_CLASS) {
      SB_MTHD40(so, MRT_BLEND_ENABLE, 2);
      SB_DATA  (so, blend[1]);
      SB_DATA  (so, cmask[1]);
   }

   if (blend[0] || blend[1]) {
      SB_MTHD30(so, BLEND_FUNC_ENABLE, 3);
      SB_DATA  (so, blend[0]);
      SB_DATA  (so, (nvgl_blend_func(cso->rt[0].alpha_src_factor) << 16) |
                     nvgl_blend_func(cso->rt[0].rgb_src_factor));
      SB_DATA  (so, (nvgl_blend_func(cso->rt[0].alpha_dst_factor) << 16) |
                     nvgl_blend_func(cso->rt[0].rgb_dst_factor));
      if (eng3d->oclass < NV40_3D_CLASS) {
         SB_MTHD30(so, BLEND_EQUATION, 1);
         SB_DATA  (so, nvgl_blend_eqn(cso->rt[0].rgb_func));
      } else {
         SB_MTHD40(so, BLEND_EQUATION, 1);
         SB_DATA  (so, (nvgl_blend_eqn(cso->rt[0].alpha_func) << 16) |
                        nvgl_blend_eqn(cso->rt[0].rgb_func));
      }
   } else {
      SB_MTHD30(so, BLEND_FUNC_ENABLE, 1);
      SB_DATA  (so, blend[0]);
   }

   SB_MTHD30(so, COLOR_MASK, 1);
   SB_DATA  (so, cmask[0]);
   return so;
d62 1
a62 1
   struct nv30_context *nv30 = nv30_context(pipe);
d64 2
a65 2
   nv30->blend = hwcso;
   nv30->dirty |= NV30_NEW_BLEND;
d71 224
a294 1
   FREE(hwcso);
d299 1
a299 1
                             const struct pipe_rasterizer_state *cso)
d301 110
a410 56
   struct nv30_rasterizer_stateobj *so;

   so = CALLOC_STRUCT(nv30_rasterizer_stateobj);
   if (!so)
      return NULL;
   so->pipe = *cso;

   SB_MTHD30(so, SHADE_MODEL, 1);
   SB_DATA  (so, cso->flatshade ? NV30_3D_SHADE_MODEL_FLAT :
                                  NV30_3D_SHADE_MODEL_SMOOTH);

   SB_MTHD30(so, POLYGON_MODE_FRONT, 6);
   SB_DATA  (so, nvgl_polygon_mode(cso->fill_front));
   SB_DATA  (so, nvgl_polygon_mode(cso->fill_back));
   if (cso->cull_face == PIPE_FACE_FRONT_AND_BACK)
      SB_DATA  (so, NV30_3D_CULL_FACE_FRONT_AND_BACK);
   else
   if (cso->cull_face == PIPE_FACE_FRONT)
      SB_DATA  (so, NV30_3D_CULL_FACE_FRONT);
   else
      SB_DATA  (so, NV30_3D_CULL_FACE_BACK);
   SB_DATA  (so, cso->front_ccw ? NV30_3D_FRONT_FACE_CCW :
                                  NV30_3D_FRONT_FACE_CW);
   SB_DATA  (so, cso->poly_smooth);
   SB_DATA  (so, cso->cull_face != PIPE_FACE_NONE);

   SB_MTHD30(so, POLYGON_OFFSET_POINT_ENABLE, 3);
   SB_DATA  (so, cso->offset_point);
   SB_DATA  (so, cso->offset_line);
   SB_DATA  (so, cso->offset_tri);
   if (cso->offset_point || cso->offset_line || cso->offset_tri) {
      SB_MTHD30(so, POLYGON_OFFSET_FACTOR, 2);
      SB_DATA  (so, fui(cso->offset_scale));
      SB_DATA  (so, fui(cso->offset_units * 2.0));
   }

   SB_MTHD30(so, LINE_WIDTH, 2);
   SB_DATA  (so, (unsigned char)(cso->line_width * 8.0) & 0xff);
   SB_DATA  (so, cso->line_smooth);
   SB_MTHD30(so, LINE_STIPPLE_ENABLE, 2);
   SB_DATA  (so, cso->line_stipple_enable);
   SB_DATA  (so, (cso->line_stipple_pattern << 16) |
                  cso->line_stipple_factor);

   SB_MTHD30(so, VERTEX_TWO_SIDE_ENABLE, 1);
   SB_DATA  (so, cso->light_twoside);
   SB_MTHD30(so, POLYGON_STIPPLE_ENABLE, 1);
   SB_DATA  (so, cso->poly_stipple_enable);
   SB_MTHD30(so, POINT_SIZE, 1);
   SB_DATA  (so, fui(cso->point_size));
   SB_MTHD30(so, FLATSHADE_FIRST, 1);
   SB_DATA  (so, cso->flatshade_first);

   SB_MTHD30(so, DEPTH_CONTROL, 1);
   SB_DATA  (so, cso->depth_clip ? 0x00000001 : 0x00000010);
   return so;
d416 1
a416 1
   struct nv30_context *nv30 = nv30_context(pipe);
d418 3
a420 2
   nv30->rast = hwcso;
   nv30->dirty |= NV30_NEW_RASTERIZER;
d426 4
a429 1
   FREE(hwcso);
d433 2
a434 2
nv30_zsa_state_create(struct pipe_context *pipe,
                      const struct pipe_depth_stencil_alpha_state *cso)
d436 59
a494 1
   struct nv30_zsa_stateobj *so;
d496 4
a499 53
   so = CALLOC_STRUCT(nv30_zsa_stateobj);
   if (!so)
      return NULL;
   so->pipe = *cso;

   SB_MTHD30(so, DEPTH_FUNC, 3);
   SB_DATA  (so, nvgl_comparison_op(cso->depth.func));
   SB_DATA  (so, cso->depth.writemask);
   SB_DATA  (so, cso->depth.enabled);

   if (cso->stencil[0].enabled) {
      SB_MTHD30(so, STENCIL_ENABLE(0), 3);
      SB_DATA  (so, 1);
      SB_DATA  (so, cso->stencil[0].writemask);
      SB_DATA  (so, nvgl_comparison_op(cso->stencil[0].func));
      SB_MTHD30(so, STENCIL_FUNC_MASK(0), 4);
      SB_DATA  (so, cso->stencil[0].valuemask);
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[0].fail_op));
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[0].zfail_op));
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[0].zpass_op));
   } else {
      SB_MTHD30(so, STENCIL_ENABLE(0), 2);
      SB_DATA  (so, 0);
      SB_DATA  (so, 0x000000ff);
   }

   if (cso->stencil[1].enabled) {
      SB_MTHD30(so, STENCIL_ENABLE(1), 3);
      SB_DATA  (so, 1);
      SB_DATA  (so, cso->stencil[1].writemask);
      SB_DATA  (so, nvgl_comparison_op(cso->stencil[1].func));
      SB_MTHD30(so, STENCIL_FUNC_MASK(1), 4);
      SB_DATA  (so, cso->stencil[1].valuemask);
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[1].fail_op));
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[1].zfail_op));
      SB_DATA  (so, nvgl_stencil_op(cso->stencil[1].zpass_op));
   } else {
      SB_MTHD30(so, STENCIL_ENABLE(1), 1);
      SB_DATA  (so, 0);
   }

   SB_MTHD30(so, ALPHA_FUNC_ENABLE, 3);
   SB_DATA  (so, cso->alpha.enabled ? 1 : 0);
   SB_DATA  (so, nvgl_comparison_op(cso->alpha.func));
   SB_DATA  (so, float_to_ubyte(cso->alpha.ref_value));

   return so;
}

static void
nv30_zsa_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv30_context *nv30 = nv30_context(pipe);
d501 16
a516 2
   nv30->zsa = hwcso;
   nv30->dirty |= NV30_NEW_ZSA;
d520 1
a520 1
nv30_zsa_state_delete(struct pipe_context *pipe, void *hwcso)
d522 5
a526 1
   FREE(hwcso);
d530 14
a543 2
nv30_set_blend_color(struct pipe_context *pipe,
                     const struct pipe_blend_color *bcol)
d545 4
a548 1
    struct nv30_context *nv30 = nv30_context(pipe);
d550 3
a552 2
    nv30->blend_colour = *bcol;
    nv30->dirty |= NV30_NEW_BLEND_COLOUR;
d556 1
a556 2
nv30_set_stencil_ref(struct pipe_context *pipe,
                     const struct pipe_stencil_ref *sr)
d558 1
a558 1
    struct nv30_context *nv30 = nv30_context(pipe);
d560 2
a561 2
    nv30->stencil_ref = *sr;
    nv30->dirty |= NV30_NEW_STENCIL_REF;
d565 1
a565 2
nv30_set_clip_state(struct pipe_context *pipe,
                    const struct pipe_clip_state *clip)
d567 2
a568 1
    struct nv30_context *nv30 = nv30_context(pipe);
d570 4
a573 1
    memcpy(nv30->clip.ucp, clip->ucp, sizeof(clip->ucp));
d575 8
a582 1
    nv30->dirty |= NV30_NEW_CLIP;
d586 2
a587 1
nv30_set_sample_mask(struct pipe_context *pipe, unsigned sample_mask)
d589 5
a593 1
    struct nv30_context *nv30 = nv30_context(pipe);
d595 4
a598 2
    nv30->sample_mask = sample_mask;
    nv30->dirty |= NV30_NEW_SAMPLE_MASK;
d603 1
a603 1
                         struct pipe_constant_buffer *cb)
d605 11
a615 28
   struct nv30_context *nv30 = nv30_context(pipe);
   struct pipe_resource *buf = cb ? cb->buffer : NULL;
   unsigned size;

   if (cb && cb->user_buffer) {
      buf = nouveau_user_buffer_create(pipe->screen, (void*)cb->user_buffer,
                                       cb->buffer_size,
                                       PIPE_BIND_CONSTANT_BUFFER);
   }

   size = 0;
   if (buf)
      size = buf->width0 / (4 * sizeof(float));

   if (shader == PIPE_SHADER_VERTEX) {
      pipe_resource_reference(&nv30->vertprog.constbuf, buf);
      nv30->vertprog.constbuf_nr = size;
      nv30->dirty |= NV30_NEW_VERTCONST;
   } else
   if (shader == PIPE_SHADER_FRAGMENT) {
      pipe_resource_reference(&nv30->fragprog.constbuf, buf);
      nv30->fragprog.constbuf_nr = size;
      nv30->dirty |= NV30_NEW_FRAGCONST;
   }

   if (cb && cb->user_buffer) {
      pipe_resource_reference(&buf, NULL);
   }
d620 1
a620 1
                           const struct pipe_framebuffer_state *fb)
d622 1
a622 3
    struct nv30_context *nv30 = nv30_context(pipe);

    nouveau_bufctx_reset(nv30->bufctx, BUFCTX_FB);
d624 2
a625 2
    nv30->framebuffer = *fb;
    nv30->dirty |= NV30_NEW_FRAMEBUFFER;
d630 1
a630 1
                         const struct pipe_poly_stipple *stipple)
d632 1
a632 1
    struct nv30_context *nv30 = nv30_context(pipe);
d634 2
a635 2
    nv30->stipple = *stipple;
    nv30->dirty |= NV30_NEW_STIPPLE;
d639 2
a640 4
nv30_set_scissor_states(struct pipe_context *pipe,
                        unsigned start_slot,
                        unsigned num_viewports,
                        const struct pipe_scissor_state *scissor)
d642 1
a642 1
    struct nv30_context *nv30 = nv30_context(pipe);
d644 2
a645 2
    nv30->scissor = *scissor;
    nv30->dirty |= NV30_NEW_SCISSOR;
d649 2
a650 4
nv30_set_viewport_states(struct pipe_context *pipe,
                         unsigned start_slot,
                         unsigned num_viewports,
                         const struct pipe_viewport_state *vpt)
d652 1
a652 1
    struct nv30_context *nv30 = nv30_context(pipe);
d654 3
a656 2
    nv30->viewport = *vpt;
    nv30->dirty |= NV30_NEW_VIEWPORT;
d660 2
a661 3
nv30_set_vertex_buffers(struct pipe_context *pipe,
                        unsigned start_slot, unsigned count,
                        const struct pipe_vertex_buffer *vb)
d663 1
a663 1
    struct nv30_context *nv30 = nv30_context(pipe);
d665 2
a666 1
    nouveau_bufctx_reset(nv30->bufctx, BUFCTX_VTXBUF);
d668 2
a669 4
    util_set_vertex_buffers_count(nv30->vtxbuf, &nv30->num_vtxbufs,
                                  vb, start_slot, count);

    nv30->dirty |= NV30_NEW_ARRAYS;
d673 2
a674 2
nv30_set_index_buffer(struct pipe_context *pipe,
                      const struct pipe_index_buffer *ib)
d676 4
a679 1
    struct nv30_context *nv30 = nv30_context(pipe);
d681 2
a682 9
    if (ib) {
       pipe_resource_reference(&nv30->idxbuf.buffer, ib->buffer);
       nv30->idxbuf.index_size = ib->index_size;
       nv30->idxbuf.offset = ib->offset;
       nv30->idxbuf.user_buffer = ib->user_buffer;
    } else {
       pipe_resource_reference(&nv30->idxbuf.buffer, NULL);
       nv30->idxbuf.user_buffer = NULL;
    }
d686 1
a686 1
nv30_state_init(struct pipe_context *pipe)
d688 36
a723 21
   pipe->create_blend_state = nv30_blend_state_create;
   pipe->bind_blend_state = nv30_blend_state_bind;
   pipe->delete_blend_state = nv30_blend_state_delete;

   pipe->create_rasterizer_state = nv30_rasterizer_state_create;
   pipe->bind_rasterizer_state = nv30_rasterizer_state_bind;
   pipe->delete_rasterizer_state = nv30_rasterizer_state_delete;

   pipe->create_depth_stencil_alpha_state = nv30_zsa_state_create;
   pipe->bind_depth_stencil_alpha_state = nv30_zsa_state_bind;
   pipe->delete_depth_stencil_alpha_state = nv30_zsa_state_delete;

   pipe->set_blend_color = nv30_set_blend_color;
   pipe->set_stencil_ref = nv30_set_stencil_ref;
   pipe->set_clip_state = nv30_set_clip_state;
   pipe->set_sample_mask = nv30_set_sample_mask;
   pipe->set_constant_buffer = nv30_set_constant_buffer;
   pipe->set_framebuffer_state = nv30_set_framebuffer_state;
   pipe->set_polygon_stipple = nv30_set_polygon_stipple;
   pipe->set_scissor_states = nv30_set_scissor_states;
   pipe->set_viewport_states = nv30_set_viewport_states;
d725 2
a726 2
   pipe->set_vertex_buffers = nv30_set_vertex_buffers;
   pipe->set_index_buffer = nv30_set_index_buffer;
d728 1
@


