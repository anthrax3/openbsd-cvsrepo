head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.07.09.21.08.53;	author jsg;	state dead;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.40;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.35;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2012 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors: Ben Skeggs
 *
 */

#include "nouveau/nv_object.xml.h"
#include "nv30-40_3d.xml.h"
#include "nv30_screen.h"
#include "nv30_context.h"

#define LIST_FIRST_ENTRY(__type, __item, __field) \
   LIST_ENTRY(__type, (__item)->next, __field)

struct nv30_query_object {
   struct list_head list;
   struct nouveau_heap *hw;
};

static volatile void *
nv30_ntfy(struct nv30_screen *screen, struct nv30_query_object *qo)
{
   struct nv04_notify *query = screen->query->data;
   struct nouveau_bo *notify = screen->notify;
   volatile void *ntfy = NULL;

   if (qo && qo->hw)
      ntfy = (char *)notify->map + query->offset + qo->hw->start;

   return ntfy;
}

static void
nv30_query_object_del(struct nv30_screen *screen, struct nv30_query_object **po)
{
   struct nv30_query_object *qo = *po; *po = NULL;
   if (qo) {
      volatile uint32_t *ntfy = nv30_ntfy(screen, qo);
      while (ntfy[3] & 0xff000000) {
      }
      nouveau_heap_free(&qo->hw);
      LIST_DEL(&qo->list);
      FREE(qo);
   }
}

static struct nv30_query_object *
nv30_query_object_new(struct nv30_screen *screen)
{
   struct nv30_query_object *oq, *qo = CALLOC_STRUCT(nv30_query_object);
   volatile uint32_t *ntfy;

   if (!qo)
      return NULL;

   /* allocate a new hw query object, if no hw objects left we need to
    * spin waiting for one to become free
    */
   while (nouveau_heap_alloc(screen->query_heap, 32, NULL, &qo->hw)) {
      oq = LIST_FIRST_ENTRY(struct nv30_query_object, &screen->queries, list);
      nv30_query_object_del(screen, &oq);
   }

   LIST_ADDTAIL(&qo->list, &screen->queries);

   ntfy = nv30_ntfy(screen, qo);
   ntfy[0] = 0x00000000;
   ntfy[1] = 0x00000000;
   ntfy[2] = 0x00000000;
   ntfy[3] = 0x01000000;
   return qo;
}

struct nv30_query {
   struct nv30_query_object *qo[2];
   unsigned type;
   uint32_t report;
   uint32_t enable;
   uint64_t result;
};

static INLINE struct nv30_query *
nv30_query(struct pipe_query *pipe)
{
   return (struct nv30_query *)pipe;
}

static struct pipe_query *
nv30_query_create(struct pipe_context *pipe, unsigned type)
{
   struct nv30_query *q = CALLOC_STRUCT(nv30_query);
   if (!q)
      return NULL;

   q->type = type;

   switch (q->type) {
   case PIPE_QUERY_TIMESTAMP:
   case PIPE_QUERY_TIME_ELAPSED:
      q->enable = 0x0000;
      q->report = 1;
      break;
   case PIPE_QUERY_OCCLUSION_COUNTER:
      q->enable = NV30_3D_QUERY_ENABLE;
      q->report = 1;
      break;
   case NV30_QUERY_ZCULL_0:
   case NV30_QUERY_ZCULL_1:
   case NV30_QUERY_ZCULL_2:
   case NV30_QUERY_ZCULL_3:
      q->enable = 0x1804;
      q->report = 2 + (q->type - NV30_QUERY_ZCULL_0);
      break;
   default:
      FREE(q);
      return NULL;
   }

   return (struct pipe_query *)q;
}

static void
nv30_query_destroy(struct pipe_context *pipe, struct pipe_query *pq)
{
   FREE(pq);
}

static void
nv30_query_begin(struct pipe_context *pipe, struct pipe_query *pq)
{
   struct nv30_context *nv30 = nv30_context(pipe);
   struct nv30_query *q = nv30_query(pq);
   struct nouveau_pushbuf *push = nv30->base.pushbuf;

   switch (q->type) {
   case PIPE_QUERY_TIME_ELAPSED:
      q->qo[0] = nv30_query_object_new(nv30->screen);
      if (q->qo[0]) {
         BEGIN_NV04(push, NV30_3D(QUERY_GET), 1);
         PUSH_DATA (push, (q->report << 24) | q->qo[0]->hw->start);
      }
      break;
   case PIPE_QUERY_TIMESTAMP:
      return;
   default:
      BEGIN_NV04(push, NV30_3D(QUERY_RESET), 1);
      PUSH_DATA (push, q->report);
      break;
   }

   if (q->enable) {
      BEGIN_NV04(push, SUBC_3D(q->enable), 1);
      PUSH_DATA (push, 1);
   }
}

static void
nv30_query_end(struct pipe_context *pipe, struct pipe_query *pq)
{
   struct nv30_context *nv30 = nv30_context(pipe);
   struct nv30_screen *screen = nv30->screen;
   struct nv30_query *q = nv30_query(pq);
   struct nouveau_pushbuf *push = nv30->base.pushbuf;

   q->qo[1] = nv30_query_object_new(screen);
   if (q->qo[1]) {
      BEGIN_NV04(push, NV30_3D(QUERY_GET), 1);
      PUSH_DATA (push, (q->report << 24) | q->qo[1]->hw->start);
   }

   if (q->enable) {
      BEGIN_NV04(push, SUBC_3D(q->enable), 1);
      PUSH_DATA (push, 0);
   }
   PUSH_KICK (push);
}

static boolean
nv30_query_result(struct pipe_context *pipe, struct pipe_query *pq,
                  boolean wait, union pipe_query_result *result)
{
   struct nv30_screen *screen = nv30_screen(pipe->screen);
   struct nv30_query *q = nv30_query(pq);
   volatile uint32_t *ntfy0 = nv30_ntfy(screen, q->qo[0]);
   volatile uint32_t *ntfy1 = nv30_ntfy(screen, q->qo[1]);
   uint64_t *res64 = &result->u64;

   if (ntfy1) {
      while (ntfy1[3] & 0xff000000) {
         if (!wait)
            return FALSE;
      }

      switch (q->type) {
      case PIPE_QUERY_TIMESTAMP:
         q->result = *(uint64_t *)&ntfy1[0];
         break;
      case PIPE_QUERY_TIME_ELAPSED:
         q->result = *(uint64_t *)&ntfy1[0] - *(uint64_t *)&ntfy0[0];
         break;
      default:
         q->result = ntfy1[2];
         break;
      }

      nv30_query_object_del(screen, &q->qo[0]);
      nv30_query_object_del(screen, &q->qo[1]);
   }

   *res64 = q->result;
   return TRUE;
}

static void
nv40_query_render_condition(struct pipe_context *pipe,
                            struct pipe_query *pq,
                            boolean condition, uint mode)
{
   struct nv30_context *nv30 = nv30_context(pipe);
   struct nv30_query *q = nv30_query(pq);
   struct nouveau_pushbuf *push = nv30->base.pushbuf;

   nv30->render_cond_query = pq;
   nv30->render_cond_mode = mode;
   nv30->render_cond_cond = condition;

   if (!pq) {
      BEGIN_NV04(push, SUBC_3D(0x1e98), 1);
      PUSH_DATA (push, 0x01000000);
      return;
   }

   if (mode == PIPE_RENDER_COND_WAIT ||
       mode == PIPE_RENDER_COND_BY_REGION_WAIT) {
      BEGIN_NV04(push, SUBC_3D(0x0110), 1);
      PUSH_DATA (push, 0);
   }

   BEGIN_NV04(push, SUBC_3D(0x1e98), 1);
   PUSH_DATA (push, 0x02000000 | q->qo[1]->hw->start);
}

void
nv30_query_init(struct pipe_context *pipe)
{
   struct nouveau_object *eng3d = nv30_context(pipe)->screen->eng3d;

   pipe->create_query = nv30_query_create;
   pipe->destroy_query = nv30_query_destroy;
   pipe->begin_query = nv30_query_begin;
   pipe->end_query = nv30_query_end;
   pipe->get_query_result = nv30_query_result;
   if (eng3d->oclass >= NV40_3D_CLASS)
      pipe->render_condition = nv40_query_render_condition;
}
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@d1 64
a64 1
#include "pipe/p_context.h"
d66 26
a91 1
#include "nv30_context.h"
d94 5
a98 4
	struct nouveau_resource *object;
	unsigned type;
	boolean ready;
	uint64_t result;
d104 1
a104 1
	return (struct nv30_query *)pipe;
d108 1
a108 1
nv30_query_create(struct pipe_context *pipe, unsigned query_type)
d110 27
a136 4
	struct nv30_query *q;

	q = CALLOC(1, sizeof(struct nv30_query));
	q->type = query_type;
d138 1
a138 1
	return (struct pipe_query *)q;
d144 1
a144 5
	struct nv30_query *q = nv30_query(pq);

	if (q->object)
		nouveau_resource_free(&q->object);
	FREE(q);
d150 24
a173 27
	struct nv30_context *nv30 = nv30_context(pipe);
	struct nv30_query *q = nv30_query(pq);
	struct nv30_screen *screen = nv30->screen;
	struct nouveau_channel *chan = screen->base.channel;
	struct nouveau_grobj *rankine = screen->rankine;

	assert(q->type == PIPE_QUERY_OCCLUSION_COUNTER);

	/* Happens when end_query() is called, then another begin_query()
	 * without querying the result in-between.  For now we'll wait for
	 * the existing query to notify completion, but it could be better.
	 */
	if (q->object) {
		uint64_t tmp;
		pipe->get_query_result(pipe, pq, 1, &tmp);
	}

	if (nouveau_resource_alloc(nv30->screen->query_heap, 1, NULL, &q->object))
		assert(0);
	nouveau_notifier_reset(nv30->screen->query, q->object->start);

	BEGIN_RING(chan, rankine, NV34TCL_QUERY_RESET, 1);
	OUT_RING  (chan, 1);
	BEGIN_RING(chan, rankine, NV34TCL_QUERY_UNK17CC, 1);
	OUT_RING  (chan, 1);

	q->ready = FALSE;
d179 16
a194 10
	struct nv30_context *nv30 = nv30_context(pipe);
	struct nv30_screen *screen = nv30->screen;
	struct nouveau_channel *chan = screen->base.channel;
	struct nouveau_grobj *rankine = screen->rankine;
	struct nv30_query *q = nv30_query(pq);

	BEGIN_RING(chan, rankine, NV34TCL_QUERY_GET, 1);
	OUT_RING  (chan, (0x01 << NV34TCL_QUERY_GET_UNK24_SHIFT) |
		   ((q->object->start * 32) << NV34TCL_QUERY_GET_OFFSET_SHIFT));
	FIRE_RING(chan);
d199 1
a199 1
		  boolean wait, uint64_t *result)
d201 27
a227 2
	struct nv30_context *nv30 = nv30_context(pipe);
	struct nv30_query *q = nv30_query(pq);
d229 3
a231 1
	assert(q->object && q->type == PIPE_QUERY_OCCLUSION_COUNTER);
d233 24
a256 19
	if (!q->ready) {
		unsigned status;

		status = nouveau_notifier_status(nv30->screen->query,
						 q->object->start);
		if (status != NV_NOTIFY_STATE_STATUS_COMPLETED) {
			if (wait == FALSE)
				return FALSE;

			nouveau_notifier_wait_status(nv30->screen->query,
					q->object->start,
					NV_NOTIFY_STATE_STATUS_COMPLETED, 0);
		}

		q->result = nouveau_notifier_return_val(nv30->screen->query,
							q->object->start);
		q->ready = TRUE;
		nouveau_resource_free(&q->object);
	}
d258 2
a259 2
	*result = q->result;
	return TRUE;
d263 1
a263 1
nv30_init_query_functions(struct nv30_context *nv30)
d265 9
a273 5
	nv30->pipe.create_query = nv30_query_create;
	nv30->pipe.destroy_query = nv30_query_destroy;
	nv30->pipe.begin_query = nv30_query_begin;
	nv30->pipe.end_query = nv30_query_end;
	nv30->pipe.get_query_result = nv30_query_result;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d1 2
a2 28
/*
 * Copyright 2012 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors: Ben Skeggs
 *
 */

#include "nouveau/nv_object.xml.h"
#include "nv30-40_3d.xml.h"
#include "nv30_screen.h"
a4 62
#define LIST_FIRST_ENTRY(__type, __item, __field) \
   LIST_ENTRY(__type, (__item)->next, __field)

struct nv30_query_object {
   struct list_head list;
   struct nouveau_heap *hw;
};

static volatile void *
nv30_ntfy(struct nv30_screen *screen, struct nv30_query_object *qo)
{
   struct nv04_notify *query = screen->query->data;
   struct nouveau_bo *notify = screen->notify;
   volatile void *ntfy = NULL;

   if (qo && qo->hw)
      ntfy = (char *)notify->map + query->offset + qo->hw->start;

   return ntfy;
}

static void
nv30_query_object_del(struct nv30_screen *screen, struct nv30_query_object **po)
{
   struct nv30_query_object *qo = *po; *po = NULL;
   if (qo) {
      volatile uint32_t *ntfy = nv30_ntfy(screen, qo);
      while (ntfy[3] & 0xff000000) {
      }
      nouveau_heap_free(&qo->hw);
      LIST_DEL(&qo->list);
      FREE(qo);
   }
}

static struct nv30_query_object *
nv30_query_object_new(struct nv30_screen *screen)
{
   struct nv30_query_object *oq, *qo = CALLOC_STRUCT(nv30_query_object);
   volatile uint32_t *ntfy;

   if (!qo)
      return NULL;

   /* allocate a new hw query object, if no hw objects left we need to
    * spin waiting for one to become free
    */
   while (nouveau_heap_alloc(screen->query_heap, 32, NULL, &qo->hw)) {
      oq = LIST_FIRST_ENTRY(struct nv30_query_object, &screen->queries, list);
      nv30_query_object_del(screen, &oq);
   }

   LIST_ADDTAIL(&qo->list, &screen->queries);

   ntfy = nv30_ntfy(screen, qo);
   ntfy[0] = 0x00000000;
   ntfy[1] = 0x00000000;
   ntfy[2] = 0x00000000;
   ntfy[3] = 0x01000000;
   return qo;
}

d6 4
a9 5
   struct nv30_query_object *qo[2];
   unsigned type;
   uint32_t report;
   uint32_t enable;
   uint64_t result;
d15 1
a15 1
   return (struct nv30_query *)pipe;
d19 1
a19 1
nv30_query_create(struct pipe_context *pipe, unsigned type)
d21 4
a24 27
   struct nv30_query *q = CALLOC_STRUCT(nv30_query);
   if (!q)
      return NULL;

   q->type = type;

   switch (q->type) {
   case PIPE_QUERY_TIMESTAMP:
   case PIPE_QUERY_TIME_ELAPSED:
      q->enable = 0x0000;
      q->report = 1;
      break;
   case PIPE_QUERY_OCCLUSION_COUNTER:
      q->enable = NV30_3D_QUERY_ENABLE;
      q->report = 1;
      break;
   case NV30_QUERY_ZCULL_0:
   case NV30_QUERY_ZCULL_1:
   case NV30_QUERY_ZCULL_2:
   case NV30_QUERY_ZCULL_3:
      q->enable = 0x1804;
      q->report = 2 + (q->type - NV30_QUERY_ZCULL_0);
      break;
   default:
      FREE(q);
      return NULL;
   }
d26 1
a26 1
   return (struct pipe_query *)q;
d32 5
a36 1
   FREE(pq);
d42 27
a68 24
   struct nv30_context *nv30 = nv30_context(pipe);
   struct nv30_query *q = nv30_query(pq);
   struct nouveau_pushbuf *push = nv30->base.pushbuf;

   switch (q->type) {
   case PIPE_QUERY_TIME_ELAPSED:
      q->qo[0] = nv30_query_object_new(nv30->screen);
      if (q->qo[0]) {
         BEGIN_NV04(push, NV30_3D(QUERY_GET), 1);
         PUSH_DATA (push, (q->report << 24) | q->qo[0]->hw->start);
      }
      break;
   case PIPE_QUERY_TIMESTAMP:
      return;
   default:
      BEGIN_NV04(push, NV30_3D(QUERY_RESET), 1);
      PUSH_DATA (push, q->report);
      break;
   }

   if (q->enable) {
      BEGIN_NV04(push, SUBC_3D(q->enable), 1);
      PUSH_DATA (push, 1);
   }
d74 10
a83 16
   struct nv30_context *nv30 = nv30_context(pipe);
   struct nv30_screen *screen = nv30->screen;
   struct nv30_query *q = nv30_query(pq);
   struct nouveau_pushbuf *push = nv30->base.pushbuf;

   q->qo[1] = nv30_query_object_new(screen);
   if (q->qo[1]) {
      BEGIN_NV04(push, NV30_3D(QUERY_GET), 1);
      PUSH_DATA (push, (q->report << 24) | q->qo[1]->hw->start);
   }

   if (q->enable) {
      BEGIN_NV04(push, SUBC_3D(q->enable), 1);
      PUSH_DATA (push, 0);
   }
   PUSH_KICK (push);
d88 1
a88 1
                  boolean wait, union pipe_query_result *result)
d90 2
a91 27
   struct nv30_screen *screen = nv30_screen(pipe->screen);
   struct nv30_query *q = nv30_query(pq);
   volatile uint32_t *ntfy0 = nv30_ntfy(screen, q->qo[0]);
   volatile uint32_t *ntfy1 = nv30_ntfy(screen, q->qo[1]);
   uint64_t *res64 = &result->u64;

   if (ntfy1) {
      while (ntfy1[3] & 0xff000000) {
         if (!wait)
            return FALSE;
      }

      switch (q->type) {
      case PIPE_QUERY_TIMESTAMP:
         q->result = *(uint64_t *)&ntfy1[0];
         break;
      case PIPE_QUERY_TIME_ELAPSED:
         q->result = *(uint64_t *)&ntfy1[0] - *(uint64_t *)&ntfy0[0];
         break;
      default:
         q->result = ntfy1[2];
         break;
      }

      nv30_query_object_del(screen, &q->qo[0]);
      nv30_query_object_del(screen, &q->qo[1]);
   }
d93 1
a93 3
   *res64 = q->result;
   return TRUE;
}
d95 19
a113 24
static void
nv40_query_render_condition(struct pipe_context *pipe,
                            struct pipe_query *pq,
                            boolean condition, uint mode)
{
   struct nv30_context *nv30 = nv30_context(pipe);
   struct nv30_query *q = nv30_query(pq);
   struct nouveau_pushbuf *push = nv30->base.pushbuf;

   nv30->render_cond_query = pq;
   nv30->render_cond_mode = mode;
   nv30->render_cond_cond = condition;

   if (!pq) {
      BEGIN_NV04(push, SUBC_3D(0x1e98), 1);
      PUSH_DATA (push, 0x01000000);
      return;
   }

   if (mode == PIPE_RENDER_COND_WAIT ||
       mode == PIPE_RENDER_COND_BY_REGION_WAIT) {
      BEGIN_NV04(push, SUBC_3D(0x0110), 1);
      PUSH_DATA (push, 0);
   }
d115 2
a116 2
   BEGIN_NV04(push, SUBC_3D(0x1e98), 1);
   PUSH_DATA (push, 0x02000000 | q->qo[1]->hw->start);
d120 1
a120 1
nv30_query_init(struct pipe_context *pipe)
d122 5
a126 9
   struct nouveau_object *eng3d = nv30_context(pipe)->screen->eng3d;

   pipe->create_query = nv30_query_create;
   pipe->destroy_query = nv30_query_destroy;
   pipe->begin_query = nv30_query_begin;
   pipe->end_query = nv30_query_end;
   pipe->get_query_result = nv30_query_result;
   if (eng3d->oclass >= NV40_3D_CLASS)
      pipe->render_condition = nv40_query_render_condition;
@


