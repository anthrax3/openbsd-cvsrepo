head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.34;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.28;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.58;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/*
 * Binning code for triangles
 */

#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_rect.h"
#include "util/u_sse.h"
#include "lp_perf.h"
#include "lp_setup_context.h"
#include "lp_rast.h"
#include "lp_state_fs.h"
#include "lp_state_setup.h"
#include "lp_context.h"

#include <inttypes.h>

#define NUM_CHANNELS 4

#if defined(PIPE_ARCH_SSE)
#include <emmintrin.h>
#endif

static INLINE int
subpixel_snap(float a)
{
   return util_iround(FIXED_ONE * a);
}

static INLINE float
fixed_to_float(int a)
{
   return a * (1.0f / FIXED_ONE);
}


/* Position and area in fixed point coordinates */
struct fixed_position {
   int32_t x[4];
   int32_t y[4];
   int64_t area;
   int32_t dx01;
   int32_t dy01;
   int32_t dx20;
   int32_t dy20;
};


/**
 * Alloc space for a new triangle plus the input.a0/dadx/dady arrays
 * immediately after it.
 * The memory is allocated from the per-scene pool, not per-tile.
 * \param tri_size  returns number of bytes allocated
 * \param num_inputs  number of fragment shader inputs
 * \return pointer to triangle space
 */
struct lp_rast_triangle *
lp_setup_alloc_triangle(struct lp_scene *scene,
                        unsigned nr_inputs,
                        unsigned nr_planes,
                        unsigned *tri_size)
{
   unsigned input_array_sz = NUM_CHANNELS * (nr_inputs + 1) * sizeof(float);
   unsigned plane_sz = nr_planes * sizeof(struct lp_rast_plane);
   struct lp_rast_triangle *tri;

   *tri_size = (sizeof(struct lp_rast_triangle) +
                3 * input_array_sz +
                plane_sz);

   tri = lp_scene_alloc_aligned( scene, *tri_size, 16 );
   if (tri == NULL)
      return NULL;

   tri->inputs.stride = input_array_sz;

   {
      char *a = (char *)tri;
      char *b = (char *)&GET_PLANES(tri)[nr_planes];
      assert(b - a == *tri_size);
   }

   return tri;
}

void
lp_setup_print_vertex(struct lp_setup_context *setup,
                      const char *name,
                      const float (*v)[4])
{
   const struct lp_setup_variant_key *key = &setup->setup.variant->key;
   int i, j;

   debug_printf("   wpos (%s[0]) xyzw %f %f %f %f\n",
                name,
                v[0][0], v[0][1], v[0][2], v[0][3]);

   for (i = 0; i < key->num_inputs; i++) {
      const float *in = v[key->inputs[i].src_index];

      debug_printf("  in[%d] (%s[%d]) %s%s%s%s ",
                   i, 
                   name, key->inputs[i].src_index,
                   (key->inputs[i].usage_mask & 0x1) ? "x" : " ",
                   (key->inputs[i].usage_mask & 0x2) ? "y" : " ",
                   (key->inputs[i].usage_mask & 0x4) ? "z" : " ",
                   (key->inputs[i].usage_mask & 0x8) ? "w" : " ");

      for (j = 0; j < 4; j++)
         if (key->inputs[i].usage_mask & (1<<j))
            debug_printf("%.5f ", in[j]);

      debug_printf("\n");
   }
}


/**
 * Print triangle vertex attribs (for debug).
 */
void
lp_setup_print_triangle(struct lp_setup_context *setup,
                        const float (*v0)[4],
                        const float (*v1)[4],
                        const float (*v2)[4])
{
   debug_printf("triangle\n");

   {
      const float ex = v0[0][0] - v2[0][0];
      const float ey = v0[0][1] - v2[0][1];
      const float fx = v1[0][0] - v2[0][0];
      const float fy = v1[0][1] - v2[0][1];

      /* det = cross(e,f).z */
      const float det = ex * fy - ey * fx;
      if (det < 0.0f) 
         debug_printf("   - ccw\n");
      else if (det > 0.0f)
         debug_printf("   - cw\n");
      else
         debug_printf("   - zero area\n");
   }

   lp_setup_print_vertex(setup, "v0", v0);
   lp_setup_print_vertex(setup, "v1", v1);
   lp_setup_print_vertex(setup, "v2", v2);
}


#define MAX_PLANES 8
static unsigned
lp_rast_tri_tab[MAX_PLANES+1] = {
   0,               /* should be impossible */
   LP_RAST_OP_TRIANGLE_1,
   LP_RAST_OP_TRIANGLE_2,
   LP_RAST_OP_TRIANGLE_3,
   LP_RAST_OP_TRIANGLE_4,
   LP_RAST_OP_TRIANGLE_5,
   LP_RAST_OP_TRIANGLE_6,
   LP_RAST_OP_TRIANGLE_7,
   LP_RAST_OP_TRIANGLE_8
};

static unsigned
lp_rast_32_tri_tab[MAX_PLANES+1] = {
   0,               /* should be impossible */
   LP_RAST_OP_TRIANGLE_32_1,
   LP_RAST_OP_TRIANGLE_32_2,
   LP_RAST_OP_TRIANGLE_32_3,
   LP_RAST_OP_TRIANGLE_32_4,
   LP_RAST_OP_TRIANGLE_32_5,
   LP_RAST_OP_TRIANGLE_32_6,
   LP_RAST_OP_TRIANGLE_32_7,
   LP_RAST_OP_TRIANGLE_32_8
};



/**
 * The primitive covers the whole tile- shade whole tile.
 *
 * \param tx, ty  the tile position in tiles, not pixels
 */
static boolean
lp_setup_whole_tile(struct lp_setup_context *setup,
                    const struct lp_rast_shader_inputs *inputs,
                    int tx, int ty)
{
   struct lp_scene *scene = setup->scene;

   LP_COUNT(nr_fully_covered_64);

   /* if variant is opaque and scissor doesn't effect the tile */
   if (inputs->opaque) {
      /* Several things prevent this optimization from working:
       * - For layered rendering we can't determine if this covers the same layer
       * as previous rendering (or in case of clears those actually always cover
       * all layers so optimization is impossible). Need to use fb_max_layer and
       * not setup->layer_slot to determine this since even if there's currently
       * no slot assigned previous rendering could have used one.
       * - If there were any Begin/End query commands in the scene then those
       * would get removed which would be very wrong. Furthermore, if queries
       * were just active we also can't do the optimization since to get
       * accurate query results we unfortunately need to execute the rendering
       * commands.
       */
      if (!scene->fb.zsbuf && scene->fb_max_layer == 0 && !scene->had_queries) {
         /*
          * All previous rendering will be overwritten so reset the bin.
          */
         lp_scene_bin_reset( scene, tx, ty );
      }

      LP_COUNT(nr_shade_opaque_64);
      return lp_scene_bin_cmd_with_state( scene, tx, ty,
                                          setup->fs.stored,
                                          LP_RAST_OP_SHADE_TILE_OPAQUE,
                                          lp_rast_arg_inputs(inputs) );
   } else {
      LP_COUNT(nr_shade_64);
      return lp_scene_bin_cmd_with_state( scene, tx, ty,
                                          setup->fs.stored, 
                                          LP_RAST_OP_SHADE_TILE,
                                          lp_rast_arg_inputs(inputs) );
   }
}


/**
 * Do basic setup for triangle rasterization and determine which
 * framebuffer tiles are touched.  Put the triangle in the scene's
 * bins for the tiles which we overlap.
 */
static boolean
do_triangle_ccw(struct lp_setup_context *setup,
                struct fixed_position* position,
                const float (*v0)[4],
                const float (*v1)[4],
                const float (*v2)[4],
                boolean frontfacing )
{
   struct lp_scene *scene = setup->scene;
   const struct lp_setup_variant_key *key = &setup->setup.variant->key;
   struct lp_rast_triangle *tri;
   struct lp_rast_plane *plane;
   struct u_rect bbox;
   unsigned tri_bytes;
   int nr_planes = 3;
   unsigned viewport_index = 0;
   unsigned layer = 0;

   /* Area should always be positive here */
   assert(position->area > 0);

   if (0)
      lp_setup_print_triangle(setup, v0, v1, v2);

   if (setup->scissor_test) {
      nr_planes = 7;
      if (setup->viewport_index_slot > 0) {
         unsigned *udata = (unsigned*)v0[setup->viewport_index_slot];
         viewport_index = lp_clamp_viewport_idx(*udata);
      }
   }
   else {
      nr_planes = 3;
   }
   if (setup->layer_slot > 0) {
      layer = *(unsigned*)v1[setup->layer_slot];
      layer = MIN2(layer, scene->fb_max_layer);
   }

   /* Bounding rectangle (in pixels) */
   {
      /* Yes this is necessary to accurately calculate bounding boxes
       * with the two fill-conventions we support.  GL (normally) ends
       * up needing a bottom-left fill convention, which requires
       * slightly different rounding.
       */
      int adj = (setup->bottom_edge_rule != 0) ? 1 : 0;

      /* Inclusive x0, exclusive x1 */
      bbox.x0 =  MIN3(position->x[0], position->x[1], position->x[2]) >> FIXED_ORDER;
      bbox.x1 = (MAX3(position->x[0], position->x[1], position->x[2]) - 1) >> FIXED_ORDER;

      /* Inclusive / exclusive depending upon adj (bottom-left or top-right) */
      bbox.y0 = (MIN3(position->y[0], position->y[1], position->y[2]) + adj) >> FIXED_ORDER;
      bbox.y1 = (MAX3(position->y[0], position->y[1], position->y[2]) - 1 + adj) >> FIXED_ORDER;
   }

   if (bbox.x1 < bbox.x0 ||
       bbox.y1 < bbox.y0) {
      if (0) debug_printf("empty bounding box\n");
      LP_COUNT(nr_culled_tris);
      return TRUE;
   }

   if (!u_rect_test_intersection(&setup->draw_regions[viewport_index], &bbox)) {
      if (0) debug_printf("offscreen\n");
      LP_COUNT(nr_culled_tris);
      return TRUE;
   }

   /* Can safely discard negative regions, but need to keep hold of
    * information about when the triangle extends past screen
    * boundaries.  See trimmed_box in lp_setup_bin_triangle().
    */
   bbox.x0 = MAX2(bbox.x0, 0);
   bbox.y0 = MAX2(bbox.y0, 0);

   tri = lp_setup_alloc_triangle(scene,
                                 key->num_inputs,
                                 nr_planes,
                                 &tri_bytes);
   if (!tri)
      return FALSE;

#if 0
   tri->v[0][0] = v0[0][0];
   tri->v[1][0] = v1[0][0];
   tri->v[2][0] = v2[0][0];
   tri->v[0][1] = v0[0][1];
   tri->v[1][1] = v1[0][1];
   tri->v[2][1] = v2[0][1];
#endif

   LP_COUNT(nr_tris);

   /* Setup parameter interpolants:
    */
   setup->setup.variant->jit_function( v0,
				       v1,
				       v2,
				       frontfacing,
				       GET_A0(&tri->inputs),
				       GET_DADX(&tri->inputs),
				       GET_DADY(&tri->inputs) );

   tri->inputs.frontfacing = frontfacing;
   tri->inputs.disable = FALSE;
   tri->inputs.opaque = setup->fs.current.variant->opaque;
   tri->inputs.layer = layer;
   tri->inputs.viewport_index = viewport_index;

   if (0)
      lp_dump_setup_coef(&setup->setup.variant->key,
			 (const float (*)[4])GET_A0(&tri->inputs),
			 (const float (*)[4])GET_DADX(&tri->inputs),
			 (const float (*)[4])GET_DADY(&tri->inputs));

   plane = GET_PLANES(tri);

#if defined(PIPE_ARCH_SSE)
   if (setup->fb.width <= MAX_FIXED_LENGTH32 &&
       setup->fb.height <= MAX_FIXED_LENGTH32 &&
       (bbox.x1 - bbox.x0) <= MAX_FIXED_LENGTH32 &&
       (bbox.y1 - bbox.y0) <= MAX_FIXED_LENGTH32) {
      __m128i vertx, verty;
      __m128i shufx, shufy;
      __m128i dcdx, dcdy, c;
      __m128i unused;
      __m128i dcdx_neg_mask;
      __m128i dcdy_neg_mask;
      __m128i dcdx_zero_mask;
      __m128i top_left_flag;
      __m128i c_inc_mask, c_inc;
      __m128i eo, p0, p1, p2;
      __m128i zero = _mm_setzero_si128();
      PIPE_ALIGN_VAR(16) int32_t temp_vec[4];

      vertx = _mm_loadu_si128((__m128i *)position->x); /* vertex x coords */
      verty = _mm_loadu_si128((__m128i *)position->y); /* vertex y coords */

      shufx = _mm_shuffle_epi32(vertx, _MM_SHUFFLE(3,0,2,1));
      shufy = _mm_shuffle_epi32(verty, _MM_SHUFFLE(3,0,2,1));

      dcdx = _mm_sub_epi32(verty, shufy);
      dcdy = _mm_sub_epi32(vertx, shufx);

      dcdx_neg_mask = _mm_srai_epi32(dcdx, 31);
      dcdx_zero_mask = _mm_cmpeq_epi32(dcdx, zero);
      dcdy_neg_mask = _mm_srai_epi32(dcdy, 31);

      top_left_flag = _mm_set1_epi32((setup->bottom_edge_rule == 0) ? ~0 : 0);

      c_inc_mask = _mm_or_si128(dcdx_neg_mask,
                                _mm_and_si128(dcdx_zero_mask,
                                              _mm_xor_si128(dcdy_neg_mask,
                                                            top_left_flag)));

      c_inc = _mm_srli_epi32(c_inc_mask, 31);

      c = _mm_sub_epi32(mm_mullo_epi32(dcdx, vertx),
                        mm_mullo_epi32(dcdy, verty));

      c = _mm_add_epi32(c, c_inc);

      /* Scale up to match c:
       */
      dcdx = _mm_slli_epi32(dcdx, FIXED_ORDER);
      dcdy = _mm_slli_epi32(dcdy, FIXED_ORDER);

      /* Calculate trivial reject values:
       */
      eo = _mm_sub_epi32(_mm_andnot_si128(dcdy_neg_mask, dcdy),
                         _mm_and_si128(dcdx_neg_mask, dcdx));

      /* ei = _mm_sub_epi32(_mm_sub_epi32(dcdy, dcdx), eo); */

      /* Pointless transpose which gets undone immediately in
       * rasterization:
       */
      transpose4_epi32(&c, &dcdx, &dcdy, &eo,
                       &p0, &p1, &p2, &unused);

#define STORE_PLANE(plane, vec) do {                 \
         _mm_store_si128((__m128i *)&temp_vec, vec); \
         plane.c    = (int64_t)temp_vec[0];          \
         plane.dcdx = temp_vec[1];                   \
         plane.dcdy = temp_vec[2];                   \
         plane.eo   = temp_vec[3];                   \
      } while(0)

      STORE_PLANE(plane[0], p0);
      STORE_PLANE(plane[1], p1);
      STORE_PLANE(plane[2], p2);
#undef STORE_PLANE
   } else
#endif
   {
      int i;
      plane[0].dcdy = position->dx01;
      plane[1].dcdy = position->x[1] - position->x[2];
      plane[2].dcdy = position->dx20;
      plane[0].dcdx = position->dy01;
      plane[1].dcdx = position->y[1] - position->y[2];
      plane[2].dcdx = position->dy20;
  
      for (i = 0; i < 3; i++) {
         /* half-edge constants, will be interated over the whole render
          * target.
          */
         plane[i].c = IMUL64(plane[i].dcdx, position->x[i]) -
               IMUL64(plane[i].dcdy, position->y[i]);

         /* correct for top-left vs. bottom-left fill convention.
          */         
         if (plane[i].dcdx < 0) {
            /* both fill conventions want this - adjust for left edges */
            plane[i].c++;            
         }
         else if (plane[i].dcdx == 0) {
            if (setup->bottom_edge_rule == 0){
               /* correct for top-left fill convention:
                */
               if (plane[i].dcdy > 0) plane[i].c++;
            }
            else {
               /* correct for bottom-left fill convention:
                */
               if (plane[i].dcdy < 0) plane[i].c++;
            }
         }

         /* Scale up to match c:
          */
         assert((plane[i].dcdx << FIXED_ORDER) >> FIXED_ORDER == plane[i].dcdx);
         assert((plane[i].dcdy << FIXED_ORDER) >> FIXED_ORDER == plane[i].dcdy);
         plane[i].dcdx <<= FIXED_ORDER;
         plane[i].dcdy <<= FIXED_ORDER;

         /* find trivial reject offsets for each edge for a single-pixel
          * sized block.  These will be scaled up at each recursive level to
          * match the active blocksize.  Scaling in this way works best if
          * the blocks are square.
          */
         plane[i].eo = 0;
         if (plane[i].dcdx < 0) plane[i].eo -= plane[i].dcdx;
         if (plane[i].dcdy > 0) plane[i].eo += plane[i].dcdy;
      }
   }

   if (0) {
      debug_printf("p0: %"PRIx64"/%08x/%08x/%"PRIx64"\n",
                   plane[0].c,
                   plane[0].dcdx,
                   plane[0].dcdy,
                   plane[0].eo);
      
      debug_printf("p1: %"PRIx64"/%08x/%08x/%"PRIx64"\n",
                   plane[1].c,
                   plane[1].dcdx,
                   plane[1].dcdy,
                   plane[1].eo);
      
      debug_printf("p2: %"PRIx64"/%08x/%08x/%"PRIx64"\n",
                   plane[2].c,
                   plane[2].dcdx,
                   plane[2].dcdy,
                   plane[2].eo);
   }


   /* 
    * When rasterizing scissored tris, use the intersection of the
    * triangle bounding box and the scissor rect to generate the
    * scissor planes.
    *
    * This permits us to cut off the triangle "tails" that are present
    * in the intermediate recursive levels caused when two of the
    * triangles edges don't diverge quickly enough to trivially reject
    * exterior blocks from the triangle.
    *
    * It's not really clear if it's worth worrying about these tails,
    * but since we generate the planes for each scissored tri, it's
    * free to trim them in this case.
    * 
    * Note that otherwise, the scissor planes only vary in 'C' value,
    * and even then only on state-changes.  Could alternatively store
    * these planes elsewhere.
    */
   if (nr_planes == 7) {
      const struct u_rect *scissor = &setup->scissors[viewport_index];

      plane[3].dcdx = -1;
      plane[3].dcdy = 0;
      plane[3].c = 1-scissor->x0;
      plane[3].eo = 1;

      plane[4].dcdx = 1;
      plane[4].dcdy = 0;
      plane[4].c = scissor->x1+1;
      plane[4].eo = 0;

      plane[5].dcdx = 0;
      plane[5].dcdy = 1;
      plane[5].c = 1-scissor->y0;
      plane[5].eo = 1;

      plane[6].dcdx = 0;
      plane[6].dcdy = -1;
      plane[6].c = scissor->y1+1;
      plane[6].eo = 0;
   }

   return lp_setup_bin_triangle(setup, tri, &bbox, nr_planes, viewport_index);
}

/*
 * Round to nearest less or equal power of two of the input.
 *
 * Undefined if no bit set exists, so code should check against 0 first.
 */
static INLINE uint32_t 
floor_pot(uint32_t n)
{
#if defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86)
   if (n == 0)
      return 0;

   __asm__("bsr %1,%0"
          : "=r" (n)
          : "rm" (n));
   return 1 << n;
#else
   n |= (n >>  1);
   n |= (n >>  2);
   n |= (n >>  4);
   n |= (n >>  8);
   n |= (n >> 16);
   return n - (n >> 1);
#endif
}


boolean
lp_setup_bin_triangle( struct lp_setup_context *setup,
                       struct lp_rast_triangle *tri,
                       const struct u_rect *bbox,
                       int nr_planes,
                       unsigned viewport_index )
{
   struct lp_scene *scene = setup->scene;
   struct u_rect trimmed_box = *bbox;   
   int i;
   /* What is the largest power-of-two boundary this triangle crosses:
    */
   int dx = floor_pot((bbox->x0 ^ bbox->x1) |
		      (bbox->y0 ^ bbox->y1));

   /* The largest dimension of the rasterized area of the triangle
    * (aligned to a 4x4 grid), rounded down to the nearest power of two:
    */
   int max_sz = ((bbox->x1 - (bbox->x0 & ~3)) |
                 (bbox->y1 - (bbox->y0 & ~3)));
   int sz = floor_pot(max_sz);
   boolean use_32bits = max_sz <= MAX_FIXED_LENGTH32;

   /* Now apply scissor, etc to the bounding box.  Could do this
    * earlier, but it confuses the logic for tri-16 and would force
    * the rasterizer to also respect scissor, etc, just for the rare
    * cases where a small triangle extends beyond the scissor.
    */
   u_rect_find_intersection(&setup->draw_regions[viewport_index],
                            &trimmed_box);

   /* Determine which tile(s) intersect the triangle's bounding box
    */
   if (dx < TILE_SIZE)
   {
      int ix0 = bbox->x0 / TILE_SIZE;
      int iy0 = bbox->y0 / TILE_SIZE;
      unsigned px = bbox->x0 & 63 & ~3;
      unsigned py = bbox->y0 & 63 & ~3;

      assert(iy0 == bbox->y1 / TILE_SIZE &&
	     ix0 == bbox->x1 / TILE_SIZE);

      if (nr_planes == 3) {
         if (sz < 4)
         {
            /* Triangle is contained in a single 4x4 stamp:
             */
            assert(px + 4 <= TILE_SIZE);
            assert(py + 4 <= TILE_SIZE);
            return lp_scene_bin_cmd_with_state( scene, ix0, iy0,
                                                setup->fs.stored,
                                                use_32bits ?
                                                LP_RAST_OP_TRIANGLE_32_3_4 :
                                                LP_RAST_OP_TRIANGLE_3_4,
                                                lp_rast_arg_triangle_contained(tri, px, py) );
         }

         if (sz < 16)
         {
            /* Triangle is contained in a single 16x16 block:
             */

            /*
             * The 16x16 block is only 4x4 aligned, and can exceed the tile
             * dimensions if the triangle is 16 pixels in one dimension but 4
             * in the other. So budge the 16x16 back inside the tile.
             */
            px = MIN2(px, TILE_SIZE - 16);
            py = MIN2(py, TILE_SIZE - 16);

            assert(px + 16 <= TILE_SIZE);
            assert(py + 16 <= TILE_SIZE);

            return lp_scene_bin_cmd_with_state( scene, ix0, iy0,
                                                setup->fs.stored,
                                                use_32bits ?
                                                LP_RAST_OP_TRIANGLE_32_3_16 :
                                                LP_RAST_OP_TRIANGLE_3_16,
                                                lp_rast_arg_triangle_contained(tri, px, py) );
         }
      }
      else if (nr_planes == 4 && sz < 16) 
      {
         px = MIN2(px, TILE_SIZE - 16);
         py = MIN2(py, TILE_SIZE - 16);

         assert(px + 16 <= TILE_SIZE);
         assert(py + 16 <= TILE_SIZE);

         return lp_scene_bin_cmd_with_state(scene, ix0, iy0,
                                            setup->fs.stored,
                                            use_32bits ?
                                            LP_RAST_OP_TRIANGLE_32_4_16 :
                                            LP_RAST_OP_TRIANGLE_4_16,
                                            lp_rast_arg_triangle_contained(tri, px, py));
      }


      /* Triangle is contained in a single tile:
       */
      return lp_scene_bin_cmd_with_state(
         scene, ix0, iy0, setup->fs.stored,
         use_32bits ? lp_rast_32_tri_tab[nr_planes] : lp_rast_tri_tab[nr_planes],
         lp_rast_arg_triangle(tri, (1<<nr_planes)-1));
   }
   else
   {
      struct lp_rast_plane *plane = GET_PLANES(tri);
      int64_t c[MAX_PLANES];
      int64_t ei[MAX_PLANES];

      int64_t eo[MAX_PLANES];
      int64_t xstep[MAX_PLANES];
      int64_t ystep[MAX_PLANES];
      int x, y;

      int ix0 = trimmed_box.x0 / TILE_SIZE;
      int iy0 = trimmed_box.y0 / TILE_SIZE;
      int ix1 = trimmed_box.x1 / TILE_SIZE;
      int iy1 = trimmed_box.y1 / TILE_SIZE;
      
      for (i = 0; i < nr_planes; i++) {
         c[i] = (plane[i].c + 
                 IMUL64(plane[i].dcdy, iy0) * TILE_SIZE -
                 IMUL64(plane[i].dcdx, ix0) * TILE_SIZE);

         ei[i] = (plane[i].dcdy - 
                  plane[i].dcdx - 
                  plane[i].eo) << TILE_ORDER;

         eo[i] = plane[i].eo << TILE_ORDER;
         xstep[i] = -(((int64_t)plane[i].dcdx) << TILE_ORDER);
         ystep[i] = ((int64_t)plane[i].dcdy) << TILE_ORDER;
      }



      /* Test tile-sized blocks against the triangle.
       * Discard blocks fully outside the tri.  If the block is fully
       * contained inside the tri, bin an lp_rast_shade_tile command.
       * Else, bin a lp_rast_triangle command.
       */
      for (y = iy0; y <= iy1; y++)
      {
         boolean in = FALSE;  /* are we inside the triangle? */
         int64_t cx[MAX_PLANES];

         for (i = 0; i < nr_planes; i++)
            cx[i] = c[i];

         for (x = ix0; x <= ix1; x++)
         {
            int out = 0;
            int partial = 0;

            for (i = 0; i < nr_planes; i++) {
               int64_t planeout = cx[i] + eo[i];
               int64_t planepartial = cx[i] + ei[i] - 1;
               out |= (planeout >> 63);
               partial |= (planepartial >> 63) & (1<<i);
            }

            if (out) {
               /* do nothing */
               if (in)
                  break;  /* exiting triangle, all done with this row */
               LP_COUNT(nr_empty_64);
            }
            else if (partial) {
               /* Not trivially accepted by at least one plane -
                * rasterize/shade partial tile
                */
               int count = util_bitcount(partial);
               in = TRUE;
               
               if (!lp_scene_bin_cmd_with_state( scene, x, y,
                                                 setup->fs.stored,
                                                 use_32bits ?
                                                 lp_rast_32_tri_tab[count] :
                                                 lp_rast_tri_tab[count],
                                                 lp_rast_arg_triangle(tri, partial) ))
                  goto fail;

               LP_COUNT(nr_partially_covered_64);
            }
            else {
               /* triangle covers the whole tile- shade whole tile */
               LP_COUNT(nr_fully_covered_64);
               in = TRUE;
               if (!lp_setup_whole_tile(setup, &tri->inputs, x, y))
                  goto fail;
            }

            /* Iterate cx values across the region: */
            for (i = 0; i < nr_planes; i++)
               cx[i] += xstep[i];
         }

         /* Iterate c values down the region: */
         for (i = 0; i < nr_planes; i++)
            c[i] += ystep[i];
      }
   }

   return TRUE;

fail:
   /* Need to disable any partially binned triangle.  This is easier
    * than trying to locate all the triangle, shade-tile, etc,
    * commands which may have been binned.
    */
   tri->inputs.disable = TRUE;
   return FALSE;
}


/**
 * Try to draw the triangle, restart the scene on failure.
 */
static void retry_triangle_ccw( struct lp_setup_context *setup,
                                struct fixed_position* position,
                                const float (*v0)[4],
                                const float (*v1)[4],
                                const float (*v2)[4],
                                boolean front)
{
   if (!do_triangle_ccw( setup, position, v0, v1, v2, front ))
   {
      if (!lp_setup_flush_and_restart(setup))
         return;

      if (!do_triangle_ccw( setup, position, v0, v1, v2, front ))
         return;
   }
}

/**
 * Calculate fixed position data for a triangle
 */
static INLINE void
calc_fixed_position( struct lp_setup_context *setup,
                     struct fixed_position* position,
                     const float (*v0)[4],
                     const float (*v1)[4],
                     const float (*v2)[4])
{
   position->x[0] = subpixel_snap(v0[0][0] - setup->pixel_offset);
   position->x[1] = subpixel_snap(v1[0][0] - setup->pixel_offset);
   position->x[2] = subpixel_snap(v2[0][0] - setup->pixel_offset);
   position->x[3] = 0;

   position->y[0] = subpixel_snap(v0[0][1] - setup->pixel_offset);
   position->y[1] = subpixel_snap(v1[0][1] - setup->pixel_offset);
   position->y[2] = subpixel_snap(v2[0][1] - setup->pixel_offset);
   position->y[3] = 0;

   position->dx01 = position->x[0] - position->x[1];
   position->dy01 = position->y[0] - position->y[1];

   position->dx20 = position->x[2] - position->x[0];
   position->dy20 = position->y[2] - position->y[0];

   position->area = IMUL64(position->dx01, position->dy20) -
         IMUL64(position->dx20, position->dy01);
}


/**
 * Rotate a triangle, flipping its clockwise direction,
 * Swaps values for xy[0] and xy[1]
 */
static INLINE void
rotate_fixed_position_01( struct fixed_position* position )
{
   int x, y;

   x = position->x[1];
   y = position->y[1];
   position->x[1] = position->x[0];
   position->y[1] = position->y[0];
   position->x[0] = x;
   position->y[0] = y;

   position->dx01 = -position->dx01;
   position->dy01 = -position->dy01;
   position->dx20 = position->x[2] - position->x[0];
   position->dy20 = position->y[2] - position->y[0];

   position->area = -position->area;
}


/**
 * Rotate a triangle, flipping its clockwise direction,
 * Swaps values for xy[1] and xy[2]
 */
static INLINE void
rotate_fixed_position_12( struct fixed_position* position )
{
   int x, y;

   x = position->x[2];
   y = position->y[2];
   position->x[2] = position->x[1];
   position->y[2] = position->y[1];
   position->x[1] = x;
   position->y[1] = y;

   x = position->dx01;
   y = position->dy01;
   position->dx01 = -position->dx20;
   position->dy01 = -position->dy20;
   position->dx20 = -x;
   position->dy20 = -y;

   position->area = -position->area;
}


/**
 * Draw triangle if it's CW, cull otherwise.
 */
static void triangle_cw( struct lp_setup_context *setup,
			 const float (*v0)[4],
			 const float (*v1)[4],
			 const float (*v2)[4] )
{
   struct fixed_position position;

   calc_fixed_position(setup, &position, v0, v1, v2);

   if (position.area < 0) {
      if (setup->flatshade_first) {
         rotate_fixed_position_12(&position);
         retry_triangle_ccw(setup, &position, v0, v2, v1, !setup->ccw_is_frontface);
      } else {
         rotate_fixed_position_01(&position);
         retry_triangle_ccw(setup, &position, v1, v0, v2, !setup->ccw_is_frontface);
      }
   }
}


static void triangle_ccw( struct lp_setup_context *setup,
                          const float (*v0)[4],
                          const float (*v1)[4],
                          const float (*v2)[4])
{
   struct fixed_position position;

   calc_fixed_position(setup, &position, v0, v1, v2);

   if (position.area > 0)
      retry_triangle_ccw(setup, &position, v0, v1, v2, setup->ccw_is_frontface);
}

/**
 * Draw triangle whether it's CW or CCW.
 */
static void triangle_both( struct lp_setup_context *setup,
			   const float (*v0)[4],
			   const float (*v1)[4],
			   const float (*v2)[4] )
{
   struct fixed_position position;
   struct llvmpipe_context *lp_context = (struct llvmpipe_context *)setup->pipe;

   if (lp_context->active_statistics_queries &&
       !llvmpipe_rasterization_disabled(lp_context)) {
      lp_context->pipeline_statistics.c_primitives++;
   }

   calc_fixed_position(setup, &position, v0, v1, v2);

   if (0) {
      assert(!util_is_inf_or_nan(v0[0][0]));
      assert(!util_is_inf_or_nan(v0[0][1]));
      assert(!util_is_inf_or_nan(v1[0][0]));
      assert(!util_is_inf_or_nan(v1[0][1]));
      assert(!util_is_inf_or_nan(v2[0][0]));
      assert(!util_is_inf_or_nan(v2[0][1]));
   }

   if (position.area > 0)
      retry_triangle_ccw( setup, &position, v0, v1, v2, setup->ccw_is_frontface );
   else if (position.area < 0) {
      if (setup->flatshade_first) {
         rotate_fixed_position_12( &position );
         retry_triangle_ccw( setup, &position, v0, v2, v1, !setup->ccw_is_frontface );
      } else {
         rotate_fixed_position_01( &position );
         retry_triangle_ccw( setup, &position, v1, v0, v2, !setup->ccw_is_frontface );
      }
   }
}


static void triangle_nop( struct lp_setup_context *setup,
			  const float (*v0)[4],
			  const float (*v1)[4],
			  const float (*v2)[4] )
{
}


void 
lp_setup_choose_triangle( struct lp_setup_context *setup )
{
   switch (setup->cullmode) {
   case PIPE_FACE_NONE:
      setup->triangle = triangle_both;
      break;
   case PIPE_FACE_BACK:
      setup->triangle = setup->ccw_is_frontface ? triangle_ccw : triangle_cw;
      break;
   case PIPE_FACE_FRONT:
      setup->triangle = setup->ccw_is_frontface ? triangle_cw : triangle_ccw;
      break;
   default:
      setup->triangle = triangle_nop;
      break;
   }
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d43 2
d50 1
a50 1
   
d66 7
a72 7
   int x[4];
   int y[4];
   int area;
   int dx01;
   int dy01;
   int dx20;
   int dy20;
d192 13
a269 1
   struct llvmpipe_context *lp_context = (struct llvmpipe_context *)setup->pipe;
d277 1
a277 1
   unsigned scissor_index = 0;
d290 1
a290 1
         scissor_index = lp_clamp_scissor_idx(*udata);
d308 1
a308 1
      int adj = (setup->pixel_offset != 0) ? 1 : 0;
d326 1
a326 1
   if (!u_rect_test_intersection(&setup->draw_regions[scissor_index], &bbox)) {
a356 4
   if (lp_context->active_statistics_queries) {
      lp_context->pipeline_statistics.c_primitives++;
   }

d371 1
d382 4
a385 1
   {
d397 1
d444 14
a457 5
      _mm_store_si128((__m128i *)&plane[0], p0);
      _mm_store_si128((__m128i *)&plane[1], p1);
      _mm_store_si128((__m128i *)&plane[2], p2);
   }
#else
d471 2
a472 1
         plane[i].c = plane[i].dcdx * position->x[i] - plane[i].dcdy * position->y[i];
d493 6
a498 2
         plane[i].dcdx *= FIXED_ONE;
         plane[i].dcdy *= FIXED_ONE;
a509 1
#endif
d512 1
a512 1
      debug_printf("p0: %08x/%08x/%08x/%08x\n",
d518 1
a518 1
      debug_printf("p1: %08x/%08x/%08x/%08x\n",
d524 1
a524 1
      debug_printf("p0: %08x/%08x/%08x/%08x\n",
d551 1
a551 1
      const struct u_rect *scissor = &setup->scissors[scissor_index];
d574 1
a574 1
   return lp_setup_bin_triangle(setup, tri, &bbox, nr_planes, scissor_index);
d609 1
a609 1
                       unsigned scissor_index )
a613 1

d622 4
a625 2
   int sz = floor_pot((bbox->x1 - (bbox->x0 & ~3)) |
		      (bbox->y1 - (bbox->y0 & ~3)));
d632 1
a632 1
   u_rect_find_intersection(&setup->draw_regions[scissor_index],
d656 2
d680 2
d696 2
d705 4
a708 3
      return lp_scene_bin_cmd_with_state( scene, ix0, iy0, setup->fs.stored,
                                          lp_rast_tri_tab[nr_planes], 
                                          lp_rast_arg_triangle(tri, (1<<nr_planes)-1) );
d713 2
a714 2
      int c[MAX_PLANES];
      int ei[MAX_PLANES];
d716 3
a718 3
      int eo[MAX_PLANES];
      int xstep[MAX_PLANES];
      int ystep[MAX_PLANES];
d728 2
a729 2
                 plane[i].dcdy * iy0 * TILE_SIZE - 
                 plane[i].dcdx * ix0 * TILE_SIZE);
d736 2
a737 2
         xstep[i] = -(plane[i].dcdx << TILE_ORDER);
         ystep[i] = plane[i].dcdy << TILE_ORDER;
d749 2
a750 2
	 boolean in = FALSE;  /* are we inside the triangle? */
	 int cx[MAX_PLANES];
d755 2
a756 2
	 for (x = ix0; x <= ix1; x++)
	 {
d761 4
a764 4
               int planeout = cx[i] + eo[i];
               int planepartial = cx[i] + ei[i] - 1;
               out |= (planeout >> 31);
               partial |= (planepartial >> 31) & (1<<i);
d774 1
a774 1
               /* Not trivially accepted by at least one plane - 
d782 3
a784 1
                                                 lp_rast_tri_tab[count], 
d798 1
a798 2
	    /* Iterate cx values across the region:
	     */
d801 3
a803 4
	 }
      
	 /* Iterate c values down the region:
	  */
a840 1

d867 2
a868 1
   position->area = position->dx01 * position->dy20 - position->dx20 * position->dy01;
a923 162
typedef void (*triangle_func_t)(struct lp_setup_context *setup,
                                const float (*v0)[4],
                                const float (*v1)[4],
                                const float (*v2)[4]);


/**
 * Subdivide this triangle by bisecting edge (v0, v1).
 * \param pv  the provoking vertex (must = v0 or v1 or v2)
 * TODO: should probably think about non-overflowing arithmetic elsewhere.
 * This will definitely screw with pipeline counters for instance.
 */
static void
subdiv_tri(struct lp_setup_context *setup,
           const float (*v0)[4],
           const float (*v1)[4],
           const float (*v2)[4],
           const float (*pv)[4],
           triangle_func_t tri)
{
   unsigned n = setup->fs.current.variant->shader->info.base.num_inputs + 1;
   const struct lp_shader_input *inputs =
      setup->fs.current.variant->shader->inputs;
   float vmid[PIPE_MAX_ATTRIBS][4];
   const float (*vm)[4] = (const float (*)[4]) vmid;
   unsigned i;
   float w0, w1, wm;
   boolean flatshade = setup->fs.current.variant->key.flatshade;

   /* find position midpoint (attrib[0] = position) */
   vmid[0][0] = 0.5f * (v1[0][0] + v0[0][0]);
   vmid[0][1] = 0.5f * (v1[0][1] + v0[0][1]);
   vmid[0][2] = 0.5f * (v1[0][2] + v0[0][2]);
   vmid[0][3] = 0.5f * (v1[0][3] + v0[0][3]);

   w0 = v0[0][3];
   w1 = v1[0][3];
   wm = vmid[0][3];

   /* interpolate other attributes */
   for (i = 1; i < n; i++) {
      if ((inputs[i - 1].interp == LP_INTERP_COLOR && flatshade) ||
          inputs[i - 1].interp == LP_INTERP_CONSTANT) {
         /* copy the provoking vertex's attribute */
         vmid[i][0] = pv[i][0];
         vmid[i][1] = pv[i][1];
         vmid[i][2] = pv[i][2];
         vmid[i][3] = pv[i][3];
      }
      else {
         /* interpolate with perspective correction (for linear too) */
         vmid[i][0] = 0.5f * (v1[i][0] * w1 + v0[i][0] * w0) / wm;
         vmid[i][1] = 0.5f * (v1[i][1] * w1 + v0[i][1] * w0) / wm;
         vmid[i][2] = 0.5f * (v1[i][2] * w1 + v0[i][2] * w0) / wm;
         vmid[i][3] = 0.5f * (v1[i][3] * w1 + v0[i][3] * w0) / wm;
      }
   }

   /* handling flat shading and first vs. last provoking vertex is a
    * little tricky...
    */
   if (pv == v0) {
      if (setup->flatshade_first) {
         /* first vertex must be v0 or vm */
         tri(setup, v0, vm, v2);
         tri(setup, vm, v1, v2);
      }
      else {
         /* last vertex must be v0 or vm */
         tri(setup, vm, v2, v0);
         tri(setup, v1, v2, vm);
      }
   }
   else if (pv == v1) {
      if (setup->flatshade_first) {
         tri(setup, vm, v2, v0);
         tri(setup, v1, v2, vm);
      }
      else {
         tri(setup, v2, v0, vm);
         tri(setup, v2, vm, v1);
      }
   }
   else {
      if (setup->flatshade_first) {
         tri(setup, v2, v0, vm);
         tri(setup, v2, vm, v1);
      }
      else {
         tri(setup, v0, vm, v2);
         tri(setup, vm, v1, v2);
      }
   }
}


/**
 * Check the lengths of the edges of the triangle.  If any edge is too
 * long, subdivide the longest edge and draw two sub-triangles.
 * Note: this may be called recursively.
 * \return TRUE if triangle was subdivided, FALSE otherwise
 */
static boolean
check_subdivide_triangle(struct lp_setup_context *setup,
                         const float (*v0)[4],
                         const float (*v1)[4],
                         const float (*v2)[4],
                         triangle_func_t tri)
{
   const float maxLen = 2048.0f;  /* longest permissible edge, in pixels */
   float dx10, dy10, len10;
   float dx21, dy21, len21;
   float dx02, dy02, len02;
   const float (*pv)[4] = setup->flatshade_first ? v0 : v2;

   /* compute lengths of triangle edges, squared */
   dx10 = v1[0][0] - v0[0][0];
   dy10 = v1[0][1] - v0[0][1];
   len10 = dx10 * dx10 + dy10 * dy10;

   dx21 = v2[0][0] - v1[0][0];
   dy21 = v2[0][1] - v1[0][1];
   len21 = dx21 * dx21 + dy21 * dy21;

   dx02 = v0[0][0] - v2[0][0];
   dy02 = v0[0][1] - v2[0][1];
   len02 = dx02 * dx02 + dy02 * dy02;

   /* Look for longest the edge that's longer than maxLen.  If we find
    * such an edge, split the triangle using the midpoint of that edge.
    * Note: it's important to split the longest edge, not just any edge
    * that's longer than maxLen.  Otherwise, we can get into a degenerate
    * situation and recurse indefinitely.
    */
   if (len10 > maxLen * maxLen &&
       len10 >= len21 &&
       len10 >= len02) {
      /* subdivide v0, v1 edge */
      subdiv_tri(setup, v0, v1, v2, pv, tri);
      return TRUE;
   }

   if (len21 > maxLen * maxLen &&
       len21 >= len10 &&
       len21 >= len02) {       
      /* subdivide v1, v2 edge */
      subdiv_tri(setup, v1, v2, v0, pv, tri);
      return TRUE;
   }

   if (len02 > maxLen * maxLen &&
       len02 >= len21 &&
       len02 >= len10) {       
      /* subdivide v2, v0 edge */
      subdiv_tri(setup, v2, v0, v1, pv, tri);
      return TRUE;
   }

   return FALSE;
}


a933 4
   if (setup->subdivide_large_triangles &&
       check_subdivide_triangle(setup, v0, v1, v2, triangle_cw))
      return;

a954 4
   if (setup->subdivide_large_triangles &&
       check_subdivide_triangle(setup, v0, v1, v2, triangle_ccw))
      return;

d970 1
d972 4
a975 3
   if (setup->subdivide_large_triangles &&
       check_subdivide_triangle(setup, v0, v1, v2, triangle_both))
      return;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d41 1
d58 1
a58 1
   return a * (1.0 / FIXED_ONE);
d62 10
a71 3



d208 13
a220 1
      if (!scene->fb.zsbuf) {
d249 5
a253 4
		const float (*v0)[4],
		const float (*v1)[4],
		const float (*v2)[4],
		boolean frontfacing )
d255 1
a259 2
   int x[4];
   int y[4];
d263 5
d274 4
d282 4
a285 11

   /* x/y positions in fixed point */
   x[0] = subpixel_snap(v0[0][0] - setup->pixel_offset);
   x[1] = subpixel_snap(v1[0][0] - setup->pixel_offset);
   x[2] = subpixel_snap(v2[0][0] - setup->pixel_offset);
   x[3] = 0;
   y[0] = subpixel_snap(v0[0][1] - setup->pixel_offset);
   y[1] = subpixel_snap(v1[0][1] - setup->pixel_offset);
   y[2] = subpixel_snap(v2[0][1] - setup->pixel_offset);
   y[3] = 0;
   
d296 7
a302 9
      bbox.x0 = (MIN3(x[0], x[1], x[2]) + (FIXED_ONE-1)) >> FIXED_ORDER;
      bbox.x1 = (MAX3(x[0], x[1], x[2]) + (FIXED_ONE-1)) >> FIXED_ORDER;
      bbox.y0 = (MIN3(y[0], y[1], y[2]) + (FIXED_ONE-1) + adj) >> FIXED_ORDER;
      bbox.y1 = (MAX3(y[0], y[1], y[2]) + (FIXED_ONE-1) + adj) >> FIXED_ORDER;

      /* Inclusive coordinates:
       */
      bbox.x1--;
      bbox.y1--;
d312 1
a312 1
   if (!u_rect_test_intersection(&setup->draw_region, &bbox)) {
d343 4
d360 1
d384 2
a385 2
      vertx = _mm_loadu_si128((__m128i *)x); /* vertex x coords */
      verty = _mm_loadu_si128((__m128i *)y); /* vertex y coords */
d397 1
a397 1
      top_left_flag = _mm_set1_epi32((setup->pixel_offset == 0) ? ~0 : 0);
d436 6
a441 6
      plane[0].dcdy = x[0] - x[1];
      plane[1].dcdy = x[1] - x[2];
      plane[2].dcdy = x[2] - x[0];
      plane[0].dcdx = y[0] - y[1];
      plane[1].dcdx = y[1] - y[2];
      plane[2].dcdx = y[2] - y[0];
d447 1
a447 1
         plane[i].c = plane[i].dcdx * x[i] - plane[i].dcdy * y[i];
d449 1
a449 12
         /* correct for top-left vs. bottom-left fill convention.  
          *
          * note that we're overloading gl_rasterization_rules to mean
          * both (0.5,0.5) pixel centers *and* bottom-left filling
          * convention.
          *
          * GL actually has a top-left filling convention, but GL's
          * notion of "top" differs from gallium's...
          *
          * Also, sometimes (in FBO cases) GL will render upside down
          * to its usual method, in which case it will probably want
          * to use the opposite, top-left convention.
d456 1
a456 1
            if (setup->pixel_offset == 0) {
d523 1
a523 1
      const struct u_rect *scissor = &setup->scissor;
d546 1
a546 1
   return lp_setup_bin_triangle( setup, tri, &bbox, nr_planes );
d580 2
a581 1
                       int nr_planes )
d603 2
a604 1
   u_rect_find_intersection(&setup->draw_region, &trimmed_box);
d612 2
a613 3
      int px = bbox->x0 & 63 & ~3;
      int py = bbox->y0 & 63 & ~3;
      int mask = px | (py << 8);
d623 2
d628 1
a628 1
                                                lp_rast_arg_triangle(tri, mask) );
d635 12
d650 1
a650 1
                                                lp_rast_arg_triangle(tri, mask) );
d655 6
d664 1
a664 1
                                            lp_rast_arg_triangle(tri, mask) );
d789 1
d795 1
a795 1
   if (!do_triangle_ccw( setup, v0, v1, v2, front ))
d800 1
a800 1
      if (!do_triangle_ccw( setup, v0, v1, v2, front ))
d805 242
a1046 10
static INLINE float
calc_area(const float (*v0)[4],
          const float (*v1)[4],
          const float (*v2)[4])
{
   float dx01 = v0[0][0] - v1[0][0];
   float dy01 = v0[0][1] - v1[0][1];
   float dx20 = v2[0][0] - v0[0][0];
   float dy20 = v2[0][1] - v0[0][1];
   return dx01 * dy20 - dx20 * dy01;
d1058 1
a1058 1
   float area = calc_area(v0, v1, v2);
d1060 15
a1074 2
   if (area < 0.0f) 
      retry_triangle_ccw(setup, v0, v2, v1, !setup->ccw_is_frontface);
d1083 1
a1083 1
   float area = calc_area(v0, v1, v2);
d1085 8
a1092 2
   if (area > 0.0f) 
      retry_triangle_ccw(setup, v0, v1, v2, setup->ccw_is_frontface);
d1103 7
a1109 1
   float area = calc_area(v0, v1, v2);
a1117 1
      assert(!util_is_inf_or_nan(area));
d1120 11
a1130 4
   if (area > 0.0f) 
      retry_triangle_ccw( setup, v0, v1, v2, setup->ccw_is_frontface );
   else if (area < 0.0f)
      retry_triangle_ccw( setup, v0, v2, v1, !setup->ccw_is_frontface );
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 2
d39 2
d44 8
a51 12

/**
 * Compute a0 for a constant-valued coefficient (GL_FLAT shading).
 */
static void constant_coef( struct lp_rast_triangle *tri,
                           unsigned slot,
			   const float value,
                           unsigned i )
{
   tri->inputs.a0[slot][i] = value;
   tri->inputs.dadx[slot][i] = 0.0f;
   tri->inputs.dady[slot][i] = 0.0f;
d54 4
a57 41

/**
 * Compute a0, dadx and dady for a linearly interpolated coefficient,
 * for a triangle.
 */
static void linear_coef( struct lp_rast_triangle *tri,
                         float oneoverarea,
                         unsigned slot,
                         const float (*v1)[4],
                         const float (*v2)[4],
                         const float (*v3)[4],
                         unsigned vert_attr,
                         unsigned i)
{
   float a1 = v1[vert_attr][i];
   float a2 = v2[vert_attr][i];
   float a3 = v3[vert_attr][i];

   float da12 = a1 - a2;
   float da31 = a3 - a1;
   float dadx = (da12 * tri->dy31 - tri->dy12 * da31) * oneoverarea;
   float dady = (da31 * tri->dx12 - tri->dx31 * da12) * oneoverarea;

   tri->inputs.dadx[slot][i] = dadx;
   tri->inputs.dady[slot][i] = dady;

   /* calculate a0 as the value which would be sampled for the
    * fragment at (0,0), taking into account that we want to sample at
    * pixel centers, in other words (0.5, 0.5).
    *
    * this is neat but unfortunately not a good way to do things for
    * triangles with very large values of dadx or dady as it will
    * result in the subtraction and re-addition from a0 of a very
    * large number, which means we'll end up loosing a lot of the
    * fractional bits and precision from a0.  the way to fix this is
    * to define a0 as the sample at a pixel center somewhere near vmin
    * instead - i'll switch to this later.
    */
   tri->inputs.a0[slot][i] = (a1 -
                              (dadx * (v1[0][0] - 0.5f) +
                               dady * (v1[0][1] - 0.5f)));
a60 33
/**
 * Compute a0, dadx and dady for a perspective-corrected interpolant,
 * for a triangle.
 * We basically multiply the vertex value by 1/w before computing
 * the plane coefficients (a0, dadx, dady).
 * Later, when we compute the value at a particular fragment position we'll
 * divide the interpolated value by the interpolated W at that fragment.
 */
static void perspective_coef( struct lp_rast_triangle *tri,
                              float oneoverarea,
                              unsigned slot,
			      const float (*v1)[4],
			      const float (*v2)[4],
			      const float (*v3)[4],
			      unsigned vert_attr,
                              unsigned i)
{
   /* premultiply by 1/w  (v[0][3] is always 1/w):
    */
   float a1 = v1[vert_attr][i] * v1[0][3];
   float a2 = v2[vert_attr][i] * v2[0][3];
   float a3 = v3[vert_attr][i] * v3[0][3];
   float da12 = a1 - a2;
   float da31 = a3 - a1;
   float dadx = (da12 * tri->dy31 - tri->dy12 * da31) * oneoverarea;
   float dady = (da31 * tri->dx12 - tri->dx31 * da12) * oneoverarea;

   tri->inputs.dadx[slot][i] = dadx;
   tri->inputs.dady[slot][i] = dady;
   tri->inputs.a0[slot][i] = (a1 -
                              (dadx * (v1[0][0] - 0.5f) +
                               dady * (v1[0][1] - 0.5f)));
}
a62 27
/**
 * Special coefficient setup for gl_FragCoord.
 * X and Y are trivial
 * Z and W are copied from position_coef which should have already been computed.
 * We could do a bit less work if we'd examine gl_FragCoord's swizzle mask.
 */
static void
setup_fragcoord_coef(struct lp_rast_triangle *tri,
                     float oneoverarea,
                     unsigned slot,
                     const float (*v1)[4],
                     const float (*v2)[4],
                     const float (*v3)[4])
{
   /*X*/
   tri->inputs.a0[slot][0] = 0.0;
   tri->inputs.dadx[slot][0] = 1.0;
   tri->inputs.dady[slot][0] = 0.0;
   /*Y*/
   tri->inputs.a0[slot][1] = 0.0;
   tri->inputs.dadx[slot][1] = 0.0;
   tri->inputs.dady[slot][1] = 1.0;
   /*Z*/
   linear_coef(tri, oneoverarea, slot, v1, v2, v3, 0, 2);
   /*W*/
   linear_coef(tri, oneoverarea, slot, v1, v2, v3, 0, 3);
}
a64 10
static void setup_facing_coef( struct lp_rast_triangle *tri,
                               unsigned slot,
                               boolean frontface )
{
   constant_coef( tri, slot, 1.0f - frontface, 0 );
   constant_coef( tri, slot, 0.0f, 1 ); /* wasted */
   constant_coef( tri, slot, 0.0f, 2 ); /* wasted */
   constant_coef( tri, slot, 0.0f, 3 ); /* wasted */
}

d67 6
a72 1
 * Compute the tri->coef[] array dadx, dady, a0 values.
d74 5
a78 7
static void setup_tri_coefficients( struct setup_context *setup,
				    struct lp_rast_triangle *tri,
                                    float oneoverarea,
				    const float (*v1)[4],
				    const float (*v2)[4],
				    const float (*v3)[4],
				    boolean frontface)
d80 3
a82 1
   unsigned slot;
d84 7
a90 3
   /* The internal position input is in slot zero:
    */
   setup_fragcoord_coef(tri, oneoverarea, 0, v1, v2, v3);
d92 1
a92 21
   /* setup interpolation for all the remaining attributes:
    */
   for (slot = 0; slot < setup->fs.nr_inputs; slot++) {
      unsigned vert_attr = setup->fs.input[slot].src_index;
      unsigned i;

      switch (setup->fs.input[slot].interp) {
      case LP_INTERP_CONSTANT:
         for (i = 0; i < NUM_CHANNELS; i++)
            constant_coef(tri, slot+1, v3[vert_attr][i], i);
         break;

      case LP_INTERP_LINEAR:
         for (i = 0; i < NUM_CHANNELS; i++)
            linear_coef(tri, oneoverarea, slot+1, v1, v2, v3, vert_attr, i);
         break;

      case LP_INTERP_PERSPECTIVE:
         for (i = 0; i < NUM_CHANNELS; i++)
            perspective_coef(tri, oneoverarea, slot+1, v1, v2, v3, vert_attr, i);
         break;
d94 5
a98 5
      case LP_INTERP_POSITION:
         /* XXX: fix me - duplicates the values in slot zero.
          */
         setup_fragcoord_coef(tri, oneoverarea, slot+1, v1, v2, v3);
         break;
d100 1
a100 8
      case LP_INTERP_FACING:
         setup_facing_coef(tri, slot+1, frontface);
         break;

      default:
         assert(0);
      }
   }
d103 26
d130 2
a131 4

static INLINE int subpixel_snap( float a )
{
   return util_iround(FIXED_ONE * a - (FIXED_ONE / 2));
a134 1

d136 1
a136 6
 * Alloc space for a new triangle plus the input.a0/dadx/dady arrays
 * immediately after it.
 * The memory is allocated from the per-scene pool, not per-tile.
 * \param tri_size  returns number of bytes allocated
 * \param nr_inputs  number of fragment shader inputs
 * \return pointer to triangle space
d138 5
a142 2
static INLINE struct lp_rast_triangle *
alloc_triangle(struct lp_scene *scene, unsigned nr_inputs, unsigned *tri_size)
d144 17
a160 4
   unsigned input_array_sz = NUM_CHANNELS * (nr_inputs + 1) * sizeof(float);
   struct lp_rast_triangle *tri;
   unsigned bytes;
   char *inputs;
d162 4
a165 1
   assert(sizeof(*tri) % 16 == 0);
a166 1
   bytes = sizeof(*tri) + (3 * input_array_sz);
d168 13
a180 1
   tri = lp_scene_alloc_aligned( scene, bytes, 16 );
a181 4
   inputs = (char *) (tri + 1);
   tri->inputs.a0   = (float (*)[4]) inputs;
   tri->inputs.dadx = (float (*)[4]) (inputs + input_array_sz);
   tri->inputs.dady = (float (*)[4]) (inputs + 2 * input_array_sz);
a182 1
   *tri_size = bytes;
d184 35
a218 1
   return tri;
a221 1

d227 3
a229 2
static void 
do_triangle_ccw(struct setup_context *setup,
a231 1
		const float (*v3)[4],
d234 2
a235 9
   /* x/y positions in fixed point */
   const int x1 = subpixel_snap(v1[0][0]);
   const int x2 = subpixel_snap(v2[0][0]);
   const int x3 = subpixel_snap(v3[0][0]);
   const int y1 = subpixel_snap(v1[0][1]);
   const int y2 = subpixel_snap(v2[0][1]);
   const int y3 = subpixel_snap(v3[0][1]);

   struct lp_scene *scene = lp_setup_get_current_scene(setup);
d237 4
a240 3
   int area;
   float oneoverarea;
   int minx, maxx, miny, maxy;
d242 1
d244 2
a245 1
   tri = alloc_triangle(scene, setup->fs.nr_inputs, &tri_bytes);
d247 6
a252 8
#ifdef DEBUG
   tri->v[0][0] = v1[0][0];
   tri->v[1][0] = v2[0][0];
   tri->v[2][0] = v3[0][0];
   tri->v[0][1] = v1[0][1];
   tri->v[1][1] = v2[0][1];
   tri->v[2][1] = v3[0][1];
#endif
d254 10
a263 7
   tri->dx12 = x1 - x2;
   tri->dx23 = x2 - x3;
   tri->dx31 = x3 - x1;

   tri->dy12 = y1 - y2;
   tri->dy23 = y2 - y3;
   tri->dy31 = y3 - y1;
d265 8
a272 1
   area = (tri->dx12 * tri->dy31 - tri->dx31 * tri->dy12);
d274 4
a277 1
   LP_COUNT(nr_tris);
d279 4
a282 8
   /* Cull non-ccw and zero-sized triangles. 
    *
    * XXX: subject to overflow??
    */
   if (area <= 0) {
      lp_scene_putback_data( scene, tri_bytes );
      LP_COUNT(nr_culled_tris);
      return;
d285 5
a289 11
   /* Bounding rectangle (in pixels) */
   minx = (MIN3(x1, x2, x3) + (FIXED_ONE-1)) >> FIXED_ORDER;
   maxx = (MAX3(x1, x2, x3) + (FIXED_ONE-1)) >> FIXED_ORDER;
   miny = (MIN3(y1, y2, y3) + (FIXED_ONE-1)) >> FIXED_ORDER;
   maxy = (MAX3(y1, y2, y3) + (FIXED_ONE-1)) >> FIXED_ORDER;
   
   if (setup->scissor_test) {
      minx = MAX2(minx, setup->scissor.current.minx);
      maxx = MIN2(maxx, setup->scissor.current.maxx);
      miny = MAX2(miny, setup->scissor.current.miny);
      maxy = MIN2(maxy, setup->scissor.current.maxy);
d292 2
a293 3
   if (miny == maxy || 
       minx == maxx) {
      lp_scene_putback_data( scene, tri_bytes );
d295 1
a295 1
      return;
d298 24
a321 3
   /* 
    */
   oneoverarea = ((float)FIXED_ONE) / (float)area;
d325 58
a382 1
   setup_tri_coefficients( setup, tri, oneoverarea, v1, v2, v3, frontfacing );
d384 11
a394 5
   /* half-edge constants, will be interated over the whole render target.
    */
   tri->c1 = tri->dy12 * x1 - tri->dx12 * y1;
   tri->c2 = tri->dy23 * x2 - tri->dx23 * y2;
   tri->c3 = tri->dy31 * x3 - tri->dx31 * y3;
d396 1
a396 30
   /* correct for top-left fill convention:
    */
   if (tri->dy12 < 0 || (tri->dy12 == 0 && tri->dx12 > 0)) tri->c1++;
   if (tri->dy23 < 0 || (tri->dy23 == 0 && tri->dx23 > 0)) tri->c2++;
   if (tri->dy31 < 0 || (tri->dy31 == 0 && tri->dx31 > 0)) tri->c3++;

   tri->dy12 *= FIXED_ONE;
   tri->dy23 *= FIXED_ONE;
   tri->dy31 *= FIXED_ONE;

   tri->dx12 *= FIXED_ONE;
   tri->dx23 *= FIXED_ONE;
   tri->dx31 *= FIXED_ONE;

   /* find trivial reject offsets for each edge for a single-pixel
    * sized block.  These will be scaled up at each recursive level to
    * match the active blocksize.  Scaling in this way works best if
    * the blocks are square.
    */
   tri->eo1 = 0;
   if (tri->dy12 < 0) tri->eo1 -= tri->dy12;
   if (tri->dx12 > 0) tri->eo1 += tri->dx12;

   tri->eo2 = 0;
   if (tri->dy23 < 0) tri->eo2 -= tri->dy23;
   if (tri->dx23 > 0) tri->eo2 += tri->dx23;

   tri->eo3 = 0;
   if (tri->dy31 < 0) tri->eo3 -= tri->dy31;
   if (tri->dx31 > 0) tri->eo3 += tri->dx31;
d398 5
a402 5
   /* Calculate trivial accept offsets from the above.
    */
   tri->ei1 = tri->dx12 - tri->dy12 - tri->eo1;
   tri->ei2 = tri->dx23 - tri->dy23 - tri->eo2;
   tri->ei3 = tri->dx31 - tri->dy31 - tri->eo3;
d404 5
a408 3
   /* Fill in the inputs.step[][] arrays.
    * We've manually unrolled some loops here.
    */
d410 163
a572 39
      const int xstep1 = -tri->dy12;
      const int xstep2 = -tri->dy23;
      const int xstep3 = -tri->dy31;
      const int ystep1 = tri->dx12;
      const int ystep2 = tri->dx23;
      const int ystep3 = tri->dx31;

#define SETUP_STEP(i, x, y)                                \
      do {                                                 \
         tri->inputs.step[0][i] = x * xstep1 + y * ystep1; \
         tri->inputs.step[1][i] = x * xstep2 + y * ystep2; \
         tri->inputs.step[2][i] = x * xstep3 + y * ystep3; \
      } while (0)

      SETUP_STEP(0, 0, 0);
      SETUP_STEP(1, 1, 0);
      SETUP_STEP(2, 0, 1);
      SETUP_STEP(3, 1, 1);

      SETUP_STEP(4, 2, 0);
      SETUP_STEP(5, 3, 0);
      SETUP_STEP(6, 2, 1);
      SETUP_STEP(7, 3, 1);

      SETUP_STEP(8, 0, 2);
      SETUP_STEP(9, 1, 2);
      SETUP_STEP(10, 0, 3);
      SETUP_STEP(11, 1, 3);

      SETUP_STEP(12, 2, 2);
      SETUP_STEP(13, 3, 2);
      SETUP_STEP(14, 2, 3);
      SETUP_STEP(15, 3, 3);
#undef STEP
   }

   /*
    * All fields of 'tri' are now set.  The remaining code here is
    * concerned with binning.
d574 2
d577 2
a578 1
   /* Convert to tile coordinates:
d580 2
a581 4
   minx = minx / TILE_SIZE;
   miny = miny / TILE_SIZE;
   maxx = maxx / TILE_SIZE;
   maxy = maxy / TILE_SIZE;
d583 4
a586 2
   /*
    * Clamp to framebuffer size
d588 1
a588 4
   minx = MAX2(minx, 0);
   miny = MAX2(miny, 0);
   maxx = MIN2(maxx, scene->tiles_x - 1);
   maxy = MIN2(maxy, scene->tiles_y - 1);
d592 1
a592 1
   if (miny == maxy && minx == maxx)
d594 39
d635 3
a637 2
      lp_scene_bin_command( scene, minx, miny, lp_rast_triangle, 
			    lp_rast_arg_triangle(tri) );
d639 1
a639 1
   else 
d641 7
a647 25
      int c1 = (tri->c1 + 
                tri->dx12 * miny * TILE_SIZE - 
                tri->dy12 * minx * TILE_SIZE);
      int c2 = (tri->c2 + 
                tri->dx23 * miny * TILE_SIZE -
                tri->dy23 * minx * TILE_SIZE);
      int c3 = (tri->c3 +
                tri->dx31 * miny * TILE_SIZE -
                tri->dy31 * minx * TILE_SIZE);

      int ei1 = tri->ei1 << TILE_ORDER;
      int ei2 = tri->ei2 << TILE_ORDER;
      int ei3 = tri->ei3 << TILE_ORDER;

      int eo1 = tri->eo1 << TILE_ORDER;
      int eo2 = tri->eo2 << TILE_ORDER;
      int eo3 = tri->eo3 << TILE_ORDER;

      int xstep1 = -(tri->dy12 << TILE_ORDER);
      int xstep2 = -(tri->dy23 << TILE_ORDER);
      int xstep3 = -(tri->dy31 << TILE_ORDER);

      int ystep1 = tri->dx12 << TILE_ORDER;
      int ystep2 = tri->dx23 << TILE_ORDER;
      int ystep3 = tri->dx31 << TILE_ORDER;
d650 20
d676 1
a676 1
      for (y = miny; y <= maxy; y++)
a677 3
	 int cx1 = c1;
	 int cx2 = c2;
	 int cx3 = c3;
d679 1
d681 4
a684 1
	 for (x = minx; x <= maxx; x++)
d686 14
a699 5
	    if (cx1 + eo1 < 0 || 
		cx2 + eo2 < 0 ||
		cx3 + eo3 < 0) 
	    {
	       /* do nothing */
d701 17
a717 7
	       if (in)
		  break;  /* exiting triangle, all done with this row */
	    }
	    else if (cx1 + ei1 > 0 &&
		     cx2 + ei2 > 0 &&
		     cx3 + ei3 > 0) 
	    {
d720 4
a723 20
	       in = TRUE;
	       if(setup->fs.current.opaque) {
	          lp_scene_bin_reset( scene, x, y );
	          lp_scene_bin_command( scene, x, y,
	                                lp_rast_set_state,
	                                lp_rast_arg_state(setup->fs.stored) );
	       }
               lp_scene_bin_command( scene, x, y,
				     lp_rast_shade_tile,
				     lp_rast_arg_inputs(&tri->inputs) );
	    }
	    else 
	    { 
               /* rasterizer/shade partial tile */
               LP_COUNT(nr_partially_covered_64);
	       in = TRUE;
               lp_scene_bin_command( scene, x, y,
				     lp_rast_triangle, 
				     lp_rast_arg_triangle(tri) );
	    }
d727 2
a728 3
	    cx1 += xstep1;
	    cx2 += xstep2;
	    cx3 += xstep3;
d733 2
a734 3
	 c1 += ystep1;
	 c2 += ystep2;
	 c3 += ystep3;    
d737 10
d750 8
a757 4
static void triangle_cw( struct setup_context *setup,
			 const float (*v0)[4],
			 const float (*v1)[4],
			 const float (*v2)[4] )
d759 20
a778 1
   do_triangle_ccw( setup, v1, v0, v2, !setup->ccw_is_frontface );
d782 4
a785 1
static void triangle_ccw( struct setup_context *setup,
d790 4
a793 1
   do_triangle_ccw( setup, v0, v1, v2, setup->ccw_is_frontface );
d797 15
a811 1
static void triangle_both( struct setup_context *setup,
d816 16
a831 11
   /* edge vectors e = v0 - v2, f = v1 - v2 */
   const float ex = v0[0][0] - v2[0][0];
   const float ey = v0[0][1] - v2[0][1];
   const float fx = v1[0][0] - v2[0][0];
   const float fy = v1[0][1] - v2[0][1];

   /* det = cross(e,f).z */
   if (ex * fy - ey * fx < 0.0f) 
      triangle_ccw( setup, v0, v1, v2 );
   else
      triangle_cw( setup, v0, v1, v2 );
d835 1
a835 1
static void triangle_nop( struct setup_context *setup,
d844 1
a844 1
lp_setup_choose_triangle( struct setup_context *setup )
d847 1
a847 1
   case PIPE_WINDING_NONE:
d850 2
a851 2
   case PIPE_WINDING_CCW:
      setup->triangle = triangle_cw;
d853 2
a854 2
   case PIPE_WINDING_CW:
      setup->triangle = triangle_ccw;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a33 2
#include "util/u_rect.h"
#include "util/u_sse.h"
a36 2
#include "lp_state_fs.h"
#include "lp_state_setup.h"
d40 55
a94 8
#if defined(PIPE_ARCH_SSE)
#include <emmintrin.h>
#endif
   
static INLINE int
subpixel_snap(float a)
{
   return util_iround(FIXED_ONE * a);
d97 17
a113 2
static INLINE float
fixed_to_float(int a)
d115 15
a129 1
   return a * (1.0 / FIXED_ONE);
d133 27
d162 9
a170 1

d174 1
a174 6
 * Alloc space for a new triangle plus the input.a0/dadx/dady arrays
 * immediately after it.
 * The memory is allocated from the per-scene pool, not per-tile.
 * \param tri_size  returns number of bytes allocated
 * \param num_inputs  number of fragment shader inputs
 * \return pointer to triangle space
d176 7
a182 5
struct lp_rast_triangle *
lp_setup_alloc_triangle(struct lp_scene *scene,
                        unsigned nr_inputs,
                        unsigned nr_planes,
                        unsigned *tri_size)
d184 5
a188 3
   unsigned input_array_sz = NUM_CHANNELS * (nr_inputs + 1) * sizeof(float);
   unsigned plane_sz = nr_planes * sizeof(struct lp_rast_plane);
   struct lp_rast_triangle *tri;
d190 21
a210 7
   *tri_size = (sizeof(struct lp_rast_triangle) +
                3 * input_array_sz +
                plane_sz);

   tri = lp_scene_alloc_aligned( scene, *tri_size, 16 );
   if (tri == NULL)
      return NULL;
d212 5
a216 1
   tri->inputs.stride = input_array_sz;
d218 7
a224 4
   {
      char *a = (char *)tri;
      char *b = (char *)&GET_PLANES(tri)[nr_planes];
      assert(b - a == *tri_size);
d226 1
a227 2
   return tri;
}
a228 26
void
lp_setup_print_vertex(struct lp_setup_context *setup,
                      const char *name,
                      const float (*v)[4])
{
   const struct lp_setup_variant_key *key = &setup->setup.variant->key;
   int i, j;

   debug_printf("   wpos (%s[0]) xyzw %f %f %f %f\n",
                name,
                v[0][0], v[0][1], v[0][2], v[0][3]);

   for (i = 0; i < key->num_inputs; i++) {
      const float *in = v[key->inputs[i].src_index];

      debug_printf("  in[%d] (%s[%d]) %s%s%s%s ",
                   i, 
                   name, key->inputs[i].src_index,
                   (key->inputs[i].usage_mask & 0x1) ? "x" : " ",
                   (key->inputs[i].usage_mask & 0x2) ? "y" : " ",
                   (key->inputs[i].usage_mask & 0x4) ? "z" : " ",
                   (key->inputs[i].usage_mask & 0x8) ? "w" : " ");

      for (j = 0; j < 4; j++)
         if (key->inputs[i].usage_mask & (1<<j))
            debug_printf("%.5f ", in[j]);
d230 3
a232 2
      debug_printf("\n");
   }
d236 1
d238 6
a243 1
 * Print triangle vertex attribs (for debug).
d245 2
a246 5
void
lp_setup_print_triangle(struct lp_setup_context *setup,
                        const float (*v0)[4],
                        const float (*v1)[4],
                        const float (*v2)[4])
d248 4
a251 1
   debug_printf("triangle\n");
d253 1
a253 15
   {
      const float ex = v0[0][0] - v2[0][0];
      const float ey = v0[0][1] - v2[0][1];
      const float fx = v1[0][0] - v2[0][0];
      const float fy = v1[0][1] - v2[0][1];

      /* det = cross(e,f).z */
      const float det = ex * fy - ey * fx;
      if (det < 0.0f) 
         debug_printf("   - ccw\n");
      else if (det > 0.0f)
         debug_printf("   - cw\n");
      else
         debug_printf("   - zero area\n");
   }
d255 1
a255 4
   lp_setup_print_vertex(setup, "v0", v0);
   lp_setup_print_vertex(setup, "v1", v1);
   lp_setup_print_vertex(setup, "v2", v2);
}
d257 1
d259 4
a262 13
#define MAX_PLANES 8
static unsigned
lp_rast_tri_tab[MAX_PLANES+1] = {
   0,               /* should be impossible */
   LP_RAST_OP_TRIANGLE_1,
   LP_RAST_OP_TRIANGLE_2,
   LP_RAST_OP_TRIANGLE_3,
   LP_RAST_OP_TRIANGLE_4,
   LP_RAST_OP_TRIANGLE_5,
   LP_RAST_OP_TRIANGLE_6,
   LP_RAST_OP_TRIANGLE_7,
   LP_RAST_OP_TRIANGLE_8
};
d264 1
d266 2
a268 36
/**
 * The primitive covers the whole tile- shade whole tile.
 *
 * \param tx, ty  the tile position in tiles, not pixels
 */
static boolean
lp_setup_whole_tile(struct lp_setup_context *setup,
                    const struct lp_rast_shader_inputs *inputs,
                    int tx, int ty)
{
   struct lp_scene *scene = setup->scene;

   LP_COUNT(nr_fully_covered_64);

   /* if variant is opaque and scissor doesn't effect the tile */
   if (inputs->opaque) {
      if (!scene->fb.zsbuf) {
         /*
          * All previous rendering will be overwritten so reset the bin.
          */
         lp_scene_bin_reset( scene, tx, ty );
      }

      LP_COUNT(nr_shade_opaque_64);
      return lp_scene_bin_cmd_with_state( scene, tx, ty,
                                          setup->fs.stored,
                                          LP_RAST_OP_SHADE_TILE_OPAQUE,
                                          lp_rast_arg_inputs(inputs) );
   } else {
      LP_COUNT(nr_shade_64);
      return lp_scene_bin_cmd_with_state( scene, tx, ty,
                                          setup->fs.stored, 
                                          LP_RAST_OP_SHADE_TILE,
                                          lp_rast_arg_inputs(inputs) );
   }
}
d276 2
a277 3
static boolean
do_triangle_ccw(struct lp_setup_context *setup,
		const float (*v0)[4],
d280 1
d283 9
a291 2
   struct lp_scene *scene = setup->scene;
   const struct lp_setup_variant_key *key = &setup->setup.variant->key;
d293 3
a295 4
   struct lp_rast_plane *plane;
   int x[4];
   int y[4];
   struct u_rect bbox;
a296 1
   int nr_planes = 3;
d298 1
a298 2
   if (0)
      lp_setup_print_triangle(setup, v0, v1, v2);
d300 8
a307 6
   if (setup->scissor_test) {
      nr_planes = 7;
   }
   else {
      nr_planes = 3;
   }
d309 7
a315 10
   /* x/y positions in fixed point */
   x[0] = subpixel_snap(v0[0][0] - setup->pixel_offset);
   x[1] = subpixel_snap(v1[0][0] - setup->pixel_offset);
   x[2] = subpixel_snap(v2[0][0] - setup->pixel_offset);
   x[3] = 0;
   y[0] = subpixel_snap(v0[0][1] - setup->pixel_offset);
   y[1] = subpixel_snap(v1[0][1] - setup->pixel_offset);
   y[2] = subpixel_snap(v2[0][1] - setup->pixel_offset);
   y[3] = 0;
   
d317 1
a317 8
   /* Bounding rectangle (in pixels) */
   {
      /* Yes this is necessary to accurately calculate bounding boxes
       * with the two fill-conventions we support.  GL (normally) ends
       * up needing a bottom-left fill convention, which requires
       * slightly different rounding.
       */
      int adj = (setup->pixel_offset != 0) ? 1 : 0;
d319 1
a319 4
      bbox.x0 = (MIN3(x[0], x[1], x[2]) + (FIXED_ONE-1)) >> FIXED_ORDER;
      bbox.x1 = (MAX3(x[0], x[1], x[2]) + (FIXED_ONE-1)) >> FIXED_ORDER;
      bbox.y0 = (MIN3(y[0], y[1], y[2]) + (FIXED_ONE-1) + adj) >> FIXED_ORDER;
      bbox.y1 = (MAX3(y[0], y[1], y[2]) + (FIXED_ONE-1) + adj) >> FIXED_ORDER;
d321 8
a328 4
      /* Inclusive coordinates:
       */
      bbox.x1--;
      bbox.y1--;
d331 11
a341 5
   if (bbox.x1 < bbox.x0 ||
       bbox.y1 < bbox.y0) {
      if (0) debug_printf("empty bounding box\n");
      LP_COUNT(nr_culled_tris);
      return TRUE;
d344 3
a346 2
   if (!u_rect_test_intersection(&setup->draw_region, &bbox)) {
      if (0) debug_printf("offscreen\n");
d348 1
a348 1
      return TRUE;
d351 3
a353 24
   /* Can safely discard negative regions, but need to keep hold of
    * information about when the triangle extends past screen
    * boundaries.  See trimmed_box in lp_setup_bin_triangle().
    */
   bbox.x0 = MAX2(bbox.x0, 0);
   bbox.y0 = MAX2(bbox.y0, 0);

   tri = lp_setup_alloc_triangle(scene,
                                 key->num_inputs,
                                 nr_planes,
                                 &tri_bytes);
   if (!tri)
      return FALSE;

#if 0
   tri->v[0][0] = v0[0][0];
   tri->v[1][0] = v1[0][0];
   tri->v[2][0] = v2[0][0];
   tri->v[0][1] = v0[0][1];
   tri->v[1][1] = v1[0][1];
   tri->v[2][1] = v2[0][1];
#endif

   LP_COUNT(nr_tris);
d357 1
a357 17
   setup->setup.variant->jit_function( v0,
				       v1,
				       v2,
				       frontfacing,
				       GET_A0(&tri->inputs),
				       GET_DADX(&tri->inputs),
				       GET_DADY(&tri->inputs) );

   tri->inputs.frontfacing = frontfacing;
   tri->inputs.disable = FALSE;
   tri->inputs.opaque = setup->fs.current.variant->opaque;

   if (0)
      lp_dump_setup_coef(&setup->setup.variant->key,
			 (const float (*)[4])GET_A0(&tri->inputs),
			 (const float (*)[4])GET_DADX(&tri->inputs),
			 (const float (*)[4])GET_DADY(&tri->inputs));
d359 5
a363 1
   plane = GET_PLANES(tri);
d365 30
a394 33
#if defined(PIPE_ARCH_SSE)
   {
      __m128i vertx, verty;
      __m128i shufx, shufy;
      __m128i dcdx, dcdy, c;
      __m128i unused;
      __m128i dcdx_neg_mask;
      __m128i dcdy_neg_mask;
      __m128i dcdx_zero_mask;
      __m128i top_left_flag;
      __m128i c_inc_mask, c_inc;
      __m128i eo, p0, p1, p2;
      __m128i zero = _mm_setzero_si128();

      vertx = _mm_loadu_si128((__m128i *)x); /* vertex x coords */
      verty = _mm_loadu_si128((__m128i *)y); /* vertex y coords */

      shufx = _mm_shuffle_epi32(vertx, _MM_SHUFFLE(3,0,2,1));
      shufy = _mm_shuffle_epi32(verty, _MM_SHUFFLE(3,0,2,1));

      dcdx = _mm_sub_epi32(verty, shufy);
      dcdy = _mm_sub_epi32(vertx, shufx);

      dcdx_neg_mask = _mm_srai_epi32(dcdx, 31);
      dcdx_zero_mask = _mm_cmpeq_epi32(dcdx, zero);
      dcdy_neg_mask = _mm_srai_epi32(dcdy, 31);

      top_left_flag = _mm_set1_epi32((setup->pixel_offset == 0) ? ~0 : 0);

      c_inc_mask = _mm_or_si128(dcdx_neg_mask,
                                _mm_and_si128(dcdx_zero_mask,
                                              _mm_xor_si128(dcdy_neg_mask,
                                                            top_left_flag)));
d396 5
a400 1
      c_inc = _mm_srli_epi32(c_inc_mask, 31);
d402 3
a404 28
      c = _mm_sub_epi32(mm_mullo_epi32(dcdx, vertx),
                        mm_mullo_epi32(dcdy, verty));

      c = _mm_add_epi32(c, c_inc);

      /* Scale up to match c:
       */
      dcdx = _mm_slli_epi32(dcdx, FIXED_ORDER);
      dcdy = _mm_slli_epi32(dcdy, FIXED_ORDER);

      /* Calculate trivial reject values:
       */
      eo = _mm_sub_epi32(_mm_andnot_si128(dcdy_neg_mask, dcdy),
                         _mm_and_si128(dcdx_neg_mask, dcdx));

      /* ei = _mm_sub_epi32(_mm_sub_epi32(dcdy, dcdx), eo); */

      /* Pointless transpose which gets undone immediately in
       * rasterization:
       */
      transpose4_epi32(&c, &dcdx, &dcdy, &eo,
                       &p0, &p1, &p2, &unused);

      _mm_store_si128((__m128i *)&plane[0], p0);
      _mm_store_si128((__m128i *)&plane[1], p1);
      _mm_store_si128((__m128i *)&plane[2], p2);
   }
#else
d406 39
a444 163
      int i;
      plane[0].dcdy = x[0] - x[1];
      plane[1].dcdy = x[1] - x[2];
      plane[2].dcdy = x[2] - x[0];
      plane[0].dcdx = y[0] - y[1];
      plane[1].dcdx = y[1] - y[2];
      plane[2].dcdx = y[2] - y[0];
  
      for (i = 0; i < 3; i++) {
         /* half-edge constants, will be interated over the whole render
          * target.
          */
         plane[i].c = plane[i].dcdx * x[i] - plane[i].dcdy * y[i];

         /* correct for top-left vs. bottom-left fill convention.  
          *
          * note that we're overloading gl_rasterization_rules to mean
          * both (0.5,0.5) pixel centers *and* bottom-left filling
          * convention.
          *
          * GL actually has a top-left filling convention, but GL's
          * notion of "top" differs from gallium's...
          *
          * Also, sometimes (in FBO cases) GL will render upside down
          * to its usual method, in which case it will probably want
          * to use the opposite, top-left convention.
          */         
         if (plane[i].dcdx < 0) {
            /* both fill conventions want this - adjust for left edges */
            plane[i].c++;            
         }
         else if (plane[i].dcdx == 0) {
            if (setup->pixel_offset == 0) {
               /* correct for top-left fill convention:
                */
               if (plane[i].dcdy > 0) plane[i].c++;
            }
            else {
               /* correct for bottom-left fill convention:
                */
               if (plane[i].dcdy < 0) plane[i].c++;
            }
         }

         plane[i].dcdx *= FIXED_ONE;
         plane[i].dcdy *= FIXED_ONE;

         /* find trivial reject offsets for each edge for a single-pixel
          * sized block.  These will be scaled up at each recursive level to
          * match the active blocksize.  Scaling in this way works best if
          * the blocks are square.
          */
         plane[i].eo = 0;
         if (plane[i].dcdx < 0) plane[i].eo -= plane[i].dcdx;
         if (plane[i].dcdy > 0) plane[i].eo += plane[i].dcdy;
      }
   }
#endif

   if (0) {
      debug_printf("p0: %08x/%08x/%08x/%08x\n",
                   plane[0].c,
                   plane[0].dcdx,
                   plane[0].dcdy,
                   plane[0].eo);
      
      debug_printf("p1: %08x/%08x/%08x/%08x\n",
                   plane[1].c,
                   plane[1].dcdx,
                   plane[1].dcdy,
                   plane[1].eo);
      
      debug_printf("p0: %08x/%08x/%08x/%08x\n",
                   plane[2].c,
                   plane[2].dcdx,
                   plane[2].dcdy,
                   plane[2].eo);
   }


   /* 
    * When rasterizing scissored tris, use the intersection of the
    * triangle bounding box and the scissor rect to generate the
    * scissor planes.
    *
    * This permits us to cut off the triangle "tails" that are present
    * in the intermediate recursive levels caused when two of the
    * triangles edges don't diverge quickly enough to trivially reject
    * exterior blocks from the triangle.
    *
    * It's not really clear if it's worth worrying about these tails,
    * but since we generate the planes for each scissored tri, it's
    * free to trim them in this case.
    * 
    * Note that otherwise, the scissor planes only vary in 'C' value,
    * and even then only on state-changes.  Could alternatively store
    * these planes elsewhere.
    */
   if (nr_planes == 7) {
      const struct u_rect *scissor = &setup->scissor;

      plane[3].dcdx = -1;
      plane[3].dcdy = 0;
      plane[3].c = 1-scissor->x0;
      plane[3].eo = 1;

      plane[4].dcdx = 1;
      plane[4].dcdy = 0;
      plane[4].c = scissor->x1+1;
      plane[4].eo = 0;

      plane[5].dcdx = 0;
      plane[5].dcdy = 1;
      plane[5].c = 1-scissor->y0;
      plane[5].eo = 1;

      plane[6].dcdx = 0;
      plane[6].dcdy = -1;
      plane[6].c = scissor->y1+1;
      plane[6].eo = 0;
   }

   return lp_setup_bin_triangle( setup, tri, &bbox, nr_planes );
}

/*
 * Round to nearest less or equal power of two of the input.
 *
 * Undefined if no bit set exists, so code should check against 0 first.
 */
static INLINE uint32_t 
floor_pot(uint32_t n)
{
#if defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86)
   if (n == 0)
      return 0;

   __asm__("bsr %1,%0"
          : "=r" (n)
          : "rm" (n));
   return 1 << n;
#else
   n |= (n >>  1);
   n |= (n >>  2);
   n |= (n >>  4);
   n |= (n >>  8);
   n |= (n >> 16);
   return n - (n >> 1);
#endif
}


boolean
lp_setup_bin_triangle( struct lp_setup_context *setup,
                       struct lp_rast_triangle *tri,
                       const struct u_rect *bbox,
                       int nr_planes )
{
   struct lp_scene *scene = setup->scene;
   struct u_rect trimmed_box = *bbox;   
   int i;

   /* What is the largest power-of-two boundary this triangle crosses:
a445 2
   int dx = floor_pot((bbox->x0 ^ bbox->x1) |
		      (bbox->y0 ^ bbox->y1));
d447 1
a447 2
   /* The largest dimension of the rasterized area of the triangle
    * (aligned to a 4x4 grid), rounded down to the nearest power of two:
d449 4
a452 2
   int sz = floor_pot((bbox->x1 - (bbox->x0 & ~3)) |
		      (bbox->y1 - (bbox->y0 & ~3)));
d454 2
a455 4
   /* Now apply scissor, etc to the bounding box.  Could do this
    * earlier, but it confuses the logic for tri-16 and would force
    * the rasterizer to also respect scissor, etc, just for the rare
    * cases where a small triangle extends beyond the scissor.
d457 4
a460 1
   u_rect_find_intersection(&setup->draw_region, &trimmed_box);
d464 1
a464 1
   if (dx < TILE_SIZE)
a465 39
      int ix0 = bbox->x0 / TILE_SIZE;
      int iy0 = bbox->y0 / TILE_SIZE;
      int px = bbox->x0 & 63 & ~3;
      int py = bbox->y0 & 63 & ~3;
      int mask = px | (py << 8);

      assert(iy0 == bbox->y1 / TILE_SIZE &&
	     ix0 == bbox->x1 / TILE_SIZE);

      if (nr_planes == 3) {
         if (sz < 4)
         {
            /* Triangle is contained in a single 4x4 stamp:
             */
            return lp_scene_bin_cmd_with_state( scene, ix0, iy0,
                                                setup->fs.stored,
                                                LP_RAST_OP_TRIANGLE_3_4,
                                                lp_rast_arg_triangle(tri, mask) );
         }

         if (sz < 16)
         {
            /* Triangle is contained in a single 16x16 block:
             */
            return lp_scene_bin_cmd_with_state( scene, ix0, iy0,
                                                setup->fs.stored,
                                                LP_RAST_OP_TRIANGLE_3_16,
                                                lp_rast_arg_triangle(tri, mask) );
         }
      }
      else if (nr_planes == 4 && sz < 16) 
      {
         return lp_scene_bin_cmd_with_state(scene, ix0, iy0,
                                            setup->fs.stored,
                                            LP_RAST_OP_TRIANGLE_4_16,
                                            lp_rast_arg_triangle(tri, mask) );
      }


d468 2
a469 3
      return lp_scene_bin_cmd_with_state( scene, ix0, iy0, setup->fs.stored,
                                          lp_rast_tri_tab[nr_planes], 
                                          lp_rast_arg_triangle(tri, (1<<nr_planes)-1) );
d471 1
a471 1
   else
d473 25
a497 7
      struct lp_rast_plane *plane = GET_PLANES(tri);
      int c[MAX_PLANES];
      int ei[MAX_PLANES];

      int eo[MAX_PLANES];
      int xstep[MAX_PLANES];
      int ystep[MAX_PLANES];
a499 20
      int ix0 = trimmed_box.x0 / TILE_SIZE;
      int iy0 = trimmed_box.y0 / TILE_SIZE;
      int ix1 = trimmed_box.x1 / TILE_SIZE;
      int iy1 = trimmed_box.y1 / TILE_SIZE;
      
      for (i = 0; i < nr_planes; i++) {
         c[i] = (plane[i].c + 
                 plane[i].dcdy * iy0 * TILE_SIZE - 
                 plane[i].dcdx * ix0 * TILE_SIZE);

         ei[i] = (plane[i].dcdy - 
                  plane[i].dcdx - 
                  plane[i].eo) << TILE_ORDER;

         eo[i] = plane[i].eo << TILE_ORDER;
         xstep[i] = -(plane[i].dcdx << TILE_ORDER);
         ystep[i] = plane[i].dcdy << TILE_ORDER;
      }


d506 1
a506 1
      for (y = iy0; y <= iy1; y++)
d508 3
a511 1
	 int cx[MAX_PLANES];
d513 1
a513 4
         for (i = 0; i < nr_planes; i++)
            cx[i] = c[i];

	 for (x = ix0; x <= ix1; x++)
d515 5
a519 14
            int out = 0;
            int partial = 0;

            for (i = 0; i < nr_planes; i++) {
               int planeout = cx[i] + eo[i];
               int planepartial = cx[i] + ei[i] - 1;
               out |= (planeout >> 31);
               partial |= (planepartial >> 31) & (1<<i);
            }

            if (out) {
               /* do nothing */
               if (in)
                  break;  /* exiting triangle, all done with this row */
d521 7
a527 17
            }
            else if (partial) {
               /* Not trivially accepted by at least one plane - 
                * rasterize/shade partial tile
                */
               int count = util_bitcount(partial);
               in = TRUE;
               
               if (!lp_scene_bin_cmd_with_state( scene, x, y,
                                                 setup->fs.stored,
                                                 lp_rast_tri_tab[count], 
                                                 lp_rast_arg_triangle(tri, partial) ))
                  goto fail;

               LP_COUNT(nr_partially_covered_64);
            }
            else {
d530 20
a549 4
               in = TRUE;
               if (!lp_setup_whole_tile(setup, &tri->inputs, x, y))
                  goto fail;
            }
d553 3
a555 2
            for (i = 0; i < nr_planes; i++)
               cx[i] += xstep[i];
d560 3
a562 2
         for (i = 0; i < nr_planes; i++)
            c[i] += ystep[i];
a564 10

   return TRUE;

fail:
   /* Need to disable any partially binned triangle.  This is easier
    * than trying to locate all the triangle, shade-tile, etc,
    * commands which may have been binned.
    */
   tri->inputs.disable = TRUE;
   return FALSE;
d568 4
a571 8
/**
 * Try to draw the triangle, restart the scene on failure.
 */
static void retry_triangle_ccw( struct lp_setup_context *setup,
                                const float (*v0)[4],
                                const float (*v1)[4],
                                const float (*v2)[4],
                                boolean front)
d573 1
a573 20
   if (!do_triangle_ccw( setup, v0, v1, v2, front ))
   {
      if (!lp_setup_flush_and_restart(setup))
         return;

      if (!do_triangle_ccw( setup, v0, v1, v2, front ))
         return;
   }
}

static INLINE float
calc_area(const float (*v0)[4],
          const float (*v1)[4],
          const float (*v2)[4])
{
   float dx01 = v0[0][0] - v1[0][0];
   float dy01 = v0[0][1] - v1[0][1];
   float dx20 = v2[0][0] - v0[0][0];
   float dy20 = v2[0][1] - v0[0][1];
   return dx01 * dy20 - dx20 * dy01;
d577 1
a577 4
/**
 * Draw triangle if it's CW, cull otherwise.
 */
static void triangle_cw( struct lp_setup_context *setup,
d582 1
a582 4
   float area = calc_area(v0, v1, v2);

   if (area < 0.0f) 
      retry_triangle_ccw(setup, v0, v2, v1, !setup->ccw_is_frontface);
d586 1
a586 15
static void triangle_ccw( struct lp_setup_context *setup,
                          const float (*v0)[4],
                          const float (*v1)[4],
                          const float (*v2)[4])
{
   float area = calc_area(v0, v1, v2);

   if (area > 0.0f) 
      retry_triangle_ccw(setup, v0, v1, v2, setup->ccw_is_frontface);
}

/**
 * Draw triangle whether it's CW or CCW.
 */
static void triangle_both( struct lp_setup_context *setup,
d591 11
a601 16
   float area = calc_area(v0, v1, v2);

   if (0) {
      assert(!util_is_inf_or_nan(v0[0][0]));
      assert(!util_is_inf_or_nan(v0[0][1]));
      assert(!util_is_inf_or_nan(v1[0][0]));
      assert(!util_is_inf_or_nan(v1[0][1]));
      assert(!util_is_inf_or_nan(v2[0][0]));
      assert(!util_is_inf_or_nan(v2[0][1]));
      assert(!util_is_inf_or_nan(area));
   }

   if (area > 0.0f) 
      retry_triangle_ccw( setup, v0, v1, v2, setup->ccw_is_frontface );
   else if (area < 0.0f)
      retry_triangle_ccw( setup, v0, v2, v1, !setup->ccw_is_frontface );
d605 1
a605 1
static void triangle_nop( struct lp_setup_context *setup,
d614 1
a614 1
lp_setup_choose_triangle( struct lp_setup_context *setup )
d617 1
a617 1
   case PIPE_FACE_NONE:
d620 2
a621 2
   case PIPE_FACE_BACK:
      setup->triangle = setup->ccw_is_frontface ? triangle_ccw : triangle_cw;
d623 2
a624 2
   case PIPE_FACE_FRONT:
      setup->triangle = setup->ccw_is_frontface ? triangle_cw : triangle_ccw;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a40 1
#include "lp_context.h"
d57 1
a57 1
   return a * (1.0f / FIXED_ONE);
d61 3
a63 10
/* Position and area in fixed point coordinates */
struct fixed_position {
   int x[4];
   int y[4];
   int area;
   int dx01;
   int dy01;
   int dx20;
   int dy20;
};
d200 1
a200 13
      /* Several things prevent this optimization from working:
       * - For layered rendering we can't determine if this covers the same layer
       * as previous rendering (or in case of clears those actually always cover
       * all layers so optimization is impossible). Need to use fb_max_layer and
       * not setup->layer_slot to determine this since even if there's currently
       * no slot assigned previous rendering could have used one.
       * - If there were any Begin/End query commands in the scene then those
       * would get removed which would be very wrong. Furthermore, if queries
       * were just active we also can't do the optimization since to get
       * accurate query results we unfortunately need to execute the rendering
       * commands.
       */
      if (!scene->fb.zsbuf && scene->fb_max_layer == 0 && !scene->had_queries) {
d229 4
a232 5
                struct fixed_position* position,
                const float (*v0)[4],
                const float (*v1)[4],
                const float (*v2)[4],
                boolean frontfacing )
a233 1
   struct llvmpipe_context *lp_context = (struct llvmpipe_context *)setup->pipe;
d238 2
a242 5
   unsigned scissor_index = 0;
   unsigned layer = 0;

   /* Area should always be positive here */
   assert(position->area > 0);
a248 4
      if (setup->viewport_index_slot > 0) {
         unsigned *udata = (unsigned*)v0[setup->viewport_index_slot];
         scissor_index = lp_clamp_scissor_idx(*udata);
      }
d253 11
a263 4
   if (setup->layer_slot > 0) {
      layer = *(unsigned*)v1[setup->layer_slot];
      layer = MIN2(layer, scene->fb_max_layer);
   }
d274 9
a282 7
      /* Inclusive x0, exclusive x1 */
      bbox.x0 =  MIN3(position->x[0], position->x[1], position->x[2]) >> FIXED_ORDER;
      bbox.x1 = (MAX3(position->x[0], position->x[1], position->x[2]) - 1) >> FIXED_ORDER;

      /* Inclusive / exclusive depending upon adj (bottom-left or top-right) */
      bbox.y0 = (MIN3(position->y[0], position->y[1], position->y[2]) + adj) >> FIXED_ORDER;
      bbox.y1 = (MAX3(position->y[0], position->y[1], position->y[2]) - 1 + adj) >> FIXED_ORDER;
d292 1
a292 1
   if (!u_rect_test_intersection(&setup->draw_regions[scissor_index], &bbox)) {
a322 4
   if (lp_context->active_statistics_queries) {
      lp_context->pipeline_statistics.c_primitives++;
   }

a335 1
   tri->inputs.layer = layer;
d359 2
a360 2
      vertx = _mm_loadu_si128((__m128i *)position->x); /* vertex x coords */
      verty = _mm_loadu_si128((__m128i *)position->y); /* vertex y coords */
d372 1
a372 1
      top_left_flag = _mm_set1_epi32((setup->bottom_edge_rule == 0) ? ~0 : 0);
d411 6
a416 6
      plane[0].dcdy = position->dx01;
      plane[1].dcdy = position->x[1] - position->x[2];
      plane[2].dcdy = position->dx20;
      plane[0].dcdx = position->dy01;
      plane[1].dcdx = position->y[1] - position->y[2];
      plane[2].dcdx = position->dy20;
d422 1
a422 1
         plane[i].c = plane[i].dcdx * position->x[i] - plane[i].dcdy * position->y[i];
d424 12
a435 1
         /* correct for top-left vs. bottom-left fill convention.
d442 1
a442 1
            if (setup->bottom_edge_rule == 0){
d509 1
a509 1
      const struct u_rect *scissor = &setup->scissors[scissor_index];
d532 1
a532 1
   return lp_setup_bin_triangle(setup, tri, &bbox, nr_planes, scissor_index);
d566 1
a566 2
                       int nr_planes,
                       unsigned scissor_index )
d588 1
a588 2
   u_rect_find_intersection(&setup->draw_regions[scissor_index],
                            &trimmed_box);
d596 3
a598 2
      unsigned px = bbox->x0 & 63 & ~3;
      unsigned py = bbox->y0 & 63 & ~3;
a607 2
            assert(px + 4 <= TILE_SIZE);
            assert(py + 4 <= TILE_SIZE);
d611 1
a611 1
                                                lp_rast_arg_triangle_contained(tri, px, py) );
a617 12

            /*
             * The 16x16 block is only 4x4 aligned, and can exceed the tile
             * dimensions if the triangle is 16 pixels in one dimension but 4
             * in the other. So budge the 16x16 back inside the tile.
             */
            px = MIN2(px, TILE_SIZE - 16);
            py = MIN2(py, TILE_SIZE - 16);

            assert(px + 16 <= TILE_SIZE);
            assert(py + 16 <= TILE_SIZE);

d621 1
a621 1
                                                lp_rast_arg_triangle_contained(tri, px, py) );
a625 6
         px = MIN2(px, TILE_SIZE - 16);
         py = MIN2(py, TILE_SIZE - 16);

         assert(px + 16 <= TILE_SIZE);
         assert(py + 16 <= TILE_SIZE);

d629 1
a629 1
                                            lp_rast_arg_triangle_contained(tri, px, py));
a753 1
                                struct fixed_position* position,
d759 1
a759 1
   if (!do_triangle_ccw( setup, position, v0, v1, v2, front ))
d764 1
a764 1
      if (!do_triangle_ccw( setup, position, v0, v1, v2, front ))
d769 10
a778 242

/**
 * Calculate fixed position data for a triangle
 */
static INLINE void
calc_fixed_position( struct lp_setup_context *setup,
                     struct fixed_position* position,
                     const float (*v0)[4],
                     const float (*v1)[4],
                     const float (*v2)[4])
{
   position->x[0] = subpixel_snap(v0[0][0] - setup->pixel_offset);
   position->x[1] = subpixel_snap(v1[0][0] - setup->pixel_offset);
   position->x[2] = subpixel_snap(v2[0][0] - setup->pixel_offset);
   position->x[3] = 0;

   position->y[0] = subpixel_snap(v0[0][1] - setup->pixel_offset);
   position->y[1] = subpixel_snap(v1[0][1] - setup->pixel_offset);
   position->y[2] = subpixel_snap(v2[0][1] - setup->pixel_offset);
   position->y[3] = 0;

   position->dx01 = position->x[0] - position->x[1];
   position->dy01 = position->y[0] - position->y[1];

   position->dx20 = position->x[2] - position->x[0];
   position->dy20 = position->y[2] - position->y[0];

   position->area = position->dx01 * position->dy20 - position->dx20 * position->dy01;
}


/**
 * Rotate a triangle, flipping its clockwise direction,
 * Swaps values for xy[0] and xy[1]
 */
static INLINE void
rotate_fixed_position_01( struct fixed_position* position )
{
   int x, y;

   x = position->x[1];
   y = position->y[1];
   position->x[1] = position->x[0];
   position->y[1] = position->y[0];
   position->x[0] = x;
   position->y[0] = y;

   position->dx01 = -position->dx01;
   position->dy01 = -position->dy01;
   position->dx20 = position->x[2] - position->x[0];
   position->dy20 = position->y[2] - position->y[0];

   position->area = -position->area;
}


/**
 * Rotate a triangle, flipping its clockwise direction,
 * Swaps values for xy[1] and xy[2]
 */
static INLINE void
rotate_fixed_position_12( struct fixed_position* position )
{
   int x, y;

   x = position->x[2];
   y = position->y[2];
   position->x[2] = position->x[1];
   position->y[2] = position->y[1];
   position->x[1] = x;
   position->y[1] = y;

   x = position->dx01;
   y = position->dy01;
   position->dx01 = -position->dx20;
   position->dy01 = -position->dy20;
   position->dx20 = -x;
   position->dy20 = -y;

   position->area = -position->area;
}


typedef void (*triangle_func_t)(struct lp_setup_context *setup,
                                const float (*v0)[4],
                                const float (*v1)[4],
                                const float (*v2)[4]);


/**
 * Subdivide this triangle by bisecting edge (v0, v1).
 * \param pv  the provoking vertex (must = v0 or v1 or v2)
 * TODO: should probably think about non-overflowing arithmetic elsewhere.
 * This will definitely screw with pipeline counters for instance.
 */
static void
subdiv_tri(struct lp_setup_context *setup,
           const float (*v0)[4],
           const float (*v1)[4],
           const float (*v2)[4],
           const float (*pv)[4],
           triangle_func_t tri)
{
   unsigned n = setup->fs.current.variant->shader->info.base.num_inputs + 1;
   const struct lp_shader_input *inputs =
      setup->fs.current.variant->shader->inputs;
   float vmid[PIPE_MAX_ATTRIBS][4];
   const float (*vm)[4] = (const float (*)[4]) vmid;
   unsigned i;
   float w0, w1, wm;
   boolean flatshade = setup->fs.current.variant->key.flatshade;

   /* find position midpoint (attrib[0] = position) */
   vmid[0][0] = 0.5f * (v1[0][0] + v0[0][0]);
   vmid[0][1] = 0.5f * (v1[0][1] + v0[0][1]);
   vmid[0][2] = 0.5f * (v1[0][2] + v0[0][2]);
   vmid[0][3] = 0.5f * (v1[0][3] + v0[0][3]);

   w0 = v0[0][3];
   w1 = v1[0][3];
   wm = vmid[0][3];

   /* interpolate other attributes */
   for (i = 1; i < n; i++) {
      if ((inputs[i - 1].interp == LP_INTERP_COLOR && flatshade) ||
          inputs[i - 1].interp == LP_INTERP_CONSTANT) {
         /* copy the provoking vertex's attribute */
         vmid[i][0] = pv[i][0];
         vmid[i][1] = pv[i][1];
         vmid[i][2] = pv[i][2];
         vmid[i][3] = pv[i][3];
      }
      else {
         /* interpolate with perspective correction (for linear too) */
         vmid[i][0] = 0.5f * (v1[i][0] * w1 + v0[i][0] * w0) / wm;
         vmid[i][1] = 0.5f * (v1[i][1] * w1 + v0[i][1] * w0) / wm;
         vmid[i][2] = 0.5f * (v1[i][2] * w1 + v0[i][2] * w0) / wm;
         vmid[i][3] = 0.5f * (v1[i][3] * w1 + v0[i][3] * w0) / wm;
      }
   }

   /* handling flat shading and first vs. last provoking vertex is a
    * little tricky...
    */
   if (pv == v0) {
      if (setup->flatshade_first) {
         /* first vertex must be v0 or vm */
         tri(setup, v0, vm, v2);
         tri(setup, vm, v1, v2);
      }
      else {
         /* last vertex must be v0 or vm */
         tri(setup, vm, v2, v0);
         tri(setup, v1, v2, vm);
      }
   }
   else if (pv == v1) {
      if (setup->flatshade_first) {
         tri(setup, vm, v2, v0);
         tri(setup, v1, v2, vm);
      }
      else {
         tri(setup, v2, v0, vm);
         tri(setup, v2, vm, v1);
      }
   }
   else {
      if (setup->flatshade_first) {
         tri(setup, v2, v0, vm);
         tri(setup, v2, vm, v1);
      }
      else {
         tri(setup, v0, vm, v2);
         tri(setup, vm, v1, v2);
      }
   }
}


/**
 * Check the lengths of the edges of the triangle.  If any edge is too
 * long, subdivide the longest edge and draw two sub-triangles.
 * Note: this may be called recursively.
 * \return TRUE if triangle was subdivided, FALSE otherwise
 */
static boolean
check_subdivide_triangle(struct lp_setup_context *setup,
                         const float (*v0)[4],
                         const float (*v1)[4],
                         const float (*v2)[4],
                         triangle_func_t tri)
{
   const float maxLen = 2048.0f;  /* longest permissible edge, in pixels */
   float dx10, dy10, len10;
   float dx21, dy21, len21;
   float dx02, dy02, len02;
   const float (*pv)[4] = setup->flatshade_first ? v0 : v2;

   /* compute lengths of triangle edges, squared */
   dx10 = v1[0][0] - v0[0][0];
   dy10 = v1[0][1] - v0[0][1];
   len10 = dx10 * dx10 + dy10 * dy10;

   dx21 = v2[0][0] - v1[0][0];
   dy21 = v2[0][1] - v1[0][1];
   len21 = dx21 * dx21 + dy21 * dy21;

   dx02 = v0[0][0] - v2[0][0];
   dy02 = v0[0][1] - v2[0][1];
   len02 = dx02 * dx02 + dy02 * dy02;

   /* Look for longest the edge that's longer than maxLen.  If we find
    * such an edge, split the triangle using the midpoint of that edge.
    * Note: it's important to split the longest edge, not just any edge
    * that's longer than maxLen.  Otherwise, we can get into a degenerate
    * situation and recurse indefinitely.
    */
   if (len10 > maxLen * maxLen &&
       len10 >= len21 &&
       len10 >= len02) {
      /* subdivide v0, v1 edge */
      subdiv_tri(setup, v0, v1, v2, pv, tri);
      return TRUE;
   }

   if (len21 > maxLen * maxLen &&
       len21 >= len10 &&
       len21 >= len02) {       
      /* subdivide v1, v2 edge */
      subdiv_tri(setup, v1, v2, v0, pv, tri);
      return TRUE;
   }

   if (len02 > maxLen * maxLen &&
       len02 >= len21 &&
       len02 >= len10) {       
      /* subdivide v2, v0 edge */
      subdiv_tri(setup, v2, v0, v1, pv, tri);
      return TRUE;
   }

   return FALSE;
d790 1
a790 1
   struct fixed_position position;
d792 2
a793 15
   if (setup->subdivide_large_triangles &&
       check_subdivide_triangle(setup, v0, v1, v2, triangle_cw))
      return;

   calc_fixed_position(setup, &position, v0, v1, v2);

   if (position.area < 0) {
      if (setup->flatshade_first) {
         rotate_fixed_position_12(&position);
         retry_triangle_ccw(setup, &position, v0, v2, v1, !setup->ccw_is_frontface);
      } else {
         rotate_fixed_position_01(&position);
         retry_triangle_ccw(setup, &position, v1, v0, v2, !setup->ccw_is_frontface);
      }
   }
d802 1
a802 1
   struct fixed_position position;
d804 2
a805 8
   if (setup->subdivide_large_triangles &&
       check_subdivide_triangle(setup, v0, v1, v2, triangle_ccw))
      return;

   calc_fixed_position(setup, &position, v0, v1, v2);

   if (position.area > 0)
      retry_triangle_ccw(setup, &position, v0, v1, v2, setup->ccw_is_frontface);
d816 1
a816 7
   struct fixed_position position;

   if (setup->subdivide_large_triangles &&
       check_subdivide_triangle(setup, v0, v1, v2, triangle_both))
      return;

   calc_fixed_position(setup, &position, v0, v1, v2);
d825 1
d828 4
a831 11
   if (position.area > 0)
      retry_triangle_ccw( setup, &position, v0, v1, v2, setup->ccw_is_frontface );
   else if (position.area < 0) {
      if (setup->flatshade_first) {
         rotate_fixed_position_12( &position );
         retry_triangle_ccw( setup, &position, v0, v2, v1, !setup->ccw_is_frontface );
      } else {
         rotate_fixed_position_01( &position );
         retry_triangle_ccw( setup, &position, v1, v0, v2, !setup->ccw_is_frontface );
      }
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a42 2
#include <inttypes.h>

d48 1
a48 1

d64 7
a70 7
   int32_t x[4];
   int32_t y[4];
   int64_t area;
   int32_t dx01;
   int32_t dy01;
   int32_t dx20;
   int32_t dy20;
a189 13
static unsigned
lp_rast_32_tri_tab[MAX_PLANES+1] = {
   0,               /* should be impossible */
   LP_RAST_OP_TRIANGLE_32_1,
   LP_RAST_OP_TRIANGLE_32_2,
   LP_RAST_OP_TRIANGLE_32_3,
   LP_RAST_OP_TRIANGLE_32_4,
   LP_RAST_OP_TRIANGLE_32_5,
   LP_RAST_OP_TRIANGLE_32_6,
   LP_RAST_OP_TRIANGLE_32_7,
   LP_RAST_OP_TRIANGLE_32_8
};

d255 1
d263 1
a263 1
   unsigned viewport_index = 0;
d276 1
a276 1
         viewport_index = lp_clamp_viewport_idx(*udata);
d294 1
a294 1
      int adj = (setup->bottom_edge_rule != 0) ? 1 : 0;
d312 1
a312 1
   if (!u_rect_test_intersection(&setup->draw_regions[viewport_index], &bbox)) {
d343 4
a360 1
   tri->inputs.viewport_index = viewport_index;
d371 1
a371 4
   if (setup->fb.width <= MAX_FIXED_LENGTH32 &&
       setup->fb.height <= MAX_FIXED_LENGTH32 &&
       (bbox.x1 - bbox.x0) <= MAX_FIXED_LENGTH32 &&
       (bbox.y1 - bbox.y0) <= MAX_FIXED_LENGTH32) {
a382 1
      PIPE_ALIGN_VAR(16) int32_t temp_vec[4];
d429 5
a433 14
#define STORE_PLANE(plane, vec) do {                 \
         _mm_store_si128((__m128i *)&temp_vec, vec); \
         plane.c    = (int64_t)temp_vec[0];          \
         plane.dcdx = temp_vec[1];                   \
         plane.dcdy = temp_vec[2];                   \
         plane.eo   = temp_vec[3];                   \
      } while(0)

      STORE_PLANE(plane[0], p0);
      STORE_PLANE(plane[1], p1);
      STORE_PLANE(plane[2], p2);
#undef STORE_PLANE
   } else
#endif
d447 1
a447 2
         plane[i].c = IMUL64(plane[i].dcdx, position->x[i]) -
               IMUL64(plane[i].dcdy, position->y[i]);
d468 2
a469 6
         /* Scale up to match c:
          */
         assert((plane[i].dcdx << FIXED_ORDER) >> FIXED_ORDER == plane[i].dcdx);
         assert((plane[i].dcdy << FIXED_ORDER) >> FIXED_ORDER == plane[i].dcdy);
         plane[i].dcdx <<= FIXED_ORDER;
         plane[i].dcdy <<= FIXED_ORDER;
d481 1
d484 1
a484 1
      debug_printf("p0: %"PRIx64"/%08x/%08x/%"PRIx64"\n",
d490 1
a490 1
      debug_printf("p1: %"PRIx64"/%08x/%08x/%"PRIx64"\n",
d496 1
a496 1
      debug_printf("p2: %"PRIx64"/%08x/%08x/%"PRIx64"\n",
d523 1
a523 1
      const struct u_rect *scissor = &setup->scissors[viewport_index];
d546 1
a546 1
   return lp_setup_bin_triangle(setup, tri, &bbox, nr_planes, viewport_index);
d581 1
a581 1
                       unsigned viewport_index )
d586 1
d595 2
a596 4
   int max_sz = ((bbox->x1 - (bbox->x0 & ~3)) |
                 (bbox->y1 - (bbox->y0 & ~3)));
   int sz = floor_pot(max_sz);
   boolean use_32bits = max_sz <= MAX_FIXED_LENGTH32;
d603 1
a603 1
   u_rect_find_intersection(&setup->draw_regions[viewport_index],
a626 2
                                                use_32bits ?
                                                LP_RAST_OP_TRIANGLE_32_3_4 :
a648 2
                                                use_32bits ?
                                                LP_RAST_OP_TRIANGLE_32_3_16 :
a662 2
                                            use_32bits ?
                                            LP_RAST_OP_TRIANGLE_32_4_16 :
d670 3
a672 4
      return lp_scene_bin_cmd_with_state(
         scene, ix0, iy0, setup->fs.stored,
         use_32bits ? lp_rast_32_tri_tab[nr_planes] : lp_rast_tri_tab[nr_planes],
         lp_rast_arg_triangle(tri, (1<<nr_planes)-1));
d677 2
a678 2
      int64_t c[MAX_PLANES];
      int64_t ei[MAX_PLANES];
d680 3
a682 3
      int64_t eo[MAX_PLANES];
      int64_t xstep[MAX_PLANES];
      int64_t ystep[MAX_PLANES];
d692 2
a693 2
                 IMUL64(plane[i].dcdy, iy0) * TILE_SIZE -
                 IMUL64(plane[i].dcdx, ix0) * TILE_SIZE);
d700 2
a701 2
         xstep[i] = -(((int64_t)plane[i].dcdx) << TILE_ORDER);
         ystep[i] = ((int64_t)plane[i].dcdy) << TILE_ORDER;
d713 2
a714 2
         boolean in = FALSE;  /* are we inside the triangle? */
         int64_t cx[MAX_PLANES];
d719 2
a720 2
         for (x = ix0; x <= ix1; x++)
         {
d725 4
a728 4
               int64_t planeout = cx[i] + eo[i];
               int64_t planepartial = cx[i] + ei[i] - 1;
               out |= (planeout >> 63);
               partial |= (planepartial >> 63) & (1<<i);
d738 1
a738 1
               /* Not trivially accepted by at least one plane -
d746 1
a746 3
                                                 use_32bits ?
                                                 lp_rast_32_tri_tab[count] :
                                                 lp_rast_tri_tab[count],
d760 2
a761 1
            /* Iterate cx values across the region: */
d764 4
a767 3
         }

         /* Iterate c values down the region: */
d805 1
d832 1
a832 2
   position->area = IMUL64(position->dx01, position->dy20) -
         IMUL64(position->dx20, position->dy01);
d888 162
d1060 4
d1085 4
a1103 1
   struct llvmpipe_context *lp_context = (struct llvmpipe_context *)setup->pipe;
d1105 3
a1107 4
   if (lp_context->active_statistics_queries &&
       !llvmpipe_rasterization_disabled(lp_context)) {
      lp_context->pipeline_statistics.c_primitives++;
   }
@


