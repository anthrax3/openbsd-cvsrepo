head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.33;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.26;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.57;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.26;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.35;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include <limits.h>
#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_rect.h"
#include "util/u_surface.h"
#include "util/u_pack_color.h"

#include "os/os_time.h"

#include "lp_scene_queue.h"
#include "lp_context.h"
#include "lp_debug.h"
#include "lp_fence.h"
#include "lp_perf.h"
#include "lp_query.h"
#include "lp_rast.h"
#include "lp_rast_priv.h"
#include "gallivm/lp_bld_debug.h"
#include "lp_scene.h"
#include "lp_tex_sample.h"


#ifdef DEBUG
int jit_line = 0;
const struct lp_rast_state *jit_state = NULL;
const struct lp_rasterizer_task *jit_task = NULL;
#endif


/**
 * Begin rasterizing a scene.
 * Called once per scene by one thread.
 */
static void
lp_rast_begin( struct lp_rasterizer *rast,
               struct lp_scene *scene )
{
   rast->curr_scene = scene;

   LP_DBG(DEBUG_RAST, "%s\n", __FUNCTION__);

   lp_scene_begin_rasterization( scene );
   lp_scene_bin_iter_begin( scene );
}


static void
lp_rast_end( struct lp_rasterizer *rast )
{
   lp_scene_end_rasterization( rast->curr_scene );

   rast->curr_scene = NULL;
}


/**
 * Begining rasterization of a tile.
 * \param x  window X position of the tile, in pixels
 * \param y  window Y position of the tile, in pixels
 */
static void
lp_rast_tile_begin(struct lp_rasterizer_task *task,
                   const struct cmd_bin *bin,
                   int x, int y)
{
   LP_DBG(DEBUG_RAST, "%s %d,%d\n", __FUNCTION__, x, y);

   task->bin = bin;
   task->x = x * TILE_SIZE;
   task->y = y * TILE_SIZE;
   task->width = TILE_SIZE + x * TILE_SIZE > task->scene->fb.width ?
                    task->scene->fb.width - x * TILE_SIZE : TILE_SIZE;
   task->height = TILE_SIZE + y * TILE_SIZE > task->scene->fb.height ?
                    task->scene->fb.height - y * TILE_SIZE : TILE_SIZE;

   task->thread_data.vis_counter = 0;
   task->ps_invocations = 0;

   /* reset pointers to color and depth tile(s) */
   memset(task->color_tiles, 0, sizeof(task->color_tiles));
   task->depth_tile = NULL;
}


/**
 * Clear the rasterizer's current color tile.
 * This is a bin command called during bin processing.
 * Clear commands always clear all bound layers.
 */
static void
lp_rast_clear_color(struct lp_rasterizer_task *task,
                    const union lp_rast_cmd_arg arg)
{
   const struct lp_scene *scene = task->scene;
   unsigned cbuf = arg.clear_rb->cbuf;
   union util_color uc;
   enum pipe_format format;

   /* we never bin clear commands for non-existing buffers */
   assert(cbuf < scene->fb.nr_cbufs);
   assert(scene->fb.cbufs[cbuf]);

   format = scene->fb.cbufs[cbuf]->format;
   uc = arg.clear_rb->color_val;

   /*
    * this is pretty rough since we have target format (bunch of bytes...) here.
    * dump it as raw 4 dwords.
    */
   LP_DBG(DEBUG_RAST, "%s clear value (target format %d) raw 0x%x,0x%x,0x%x,0x%x\n",
          __FUNCTION__, format, uc.ui[0], uc.ui[1], uc.ui[2], uc.ui[3]);


   util_fill_box(scene->cbufs[cbuf].map,
                 format,
                 scene->cbufs[cbuf].stride,
                 scene->cbufs[cbuf].layer_stride,
                 task->x,
                 task->y,
                 0,
                 task->width,
                 task->height,
                 scene->fb_max_layer + 1,
                 &uc);

   /* this will increase for each rb which probably doesn't mean much */
   LP_COUNT(nr_color_tile_clear);
}


/**
 * Clear the rasterizer's current z/stencil tile.
 * This is a bin command called during bin processing.
 * Clear commands always clear all bound layers.
 */
static void
lp_rast_clear_zstencil(struct lp_rasterizer_task *task,
                       const union lp_rast_cmd_arg arg)
{
   const struct lp_scene *scene = task->scene;
   uint64_t clear_value64 = arg.clear_zstencil.value;
   uint64_t clear_mask64 = arg.clear_zstencil.mask;
   uint32_t clear_value = (uint32_t) clear_value64;
   uint32_t clear_mask = (uint32_t) clear_mask64;
   const unsigned height = task->height;
   const unsigned width = task->width;
   const unsigned dst_stride = scene->zsbuf.stride;
   uint8_t *dst;
   unsigned i, j;
   unsigned block_size;

   LP_DBG(DEBUG_RAST, "%s: value=0x%08x, mask=0x%08x\n",
           __FUNCTION__, clear_value, clear_mask);

   /*
    * Clear the area of the depth/depth buffer matching this tile.
    */

   if (scene->fb.zsbuf) {
      unsigned layer;
      uint8_t *dst_layer = lp_rast_get_unswizzled_depth_tile_pointer(task, LP_TEX_USAGE_READ_WRITE);
      block_size = util_format_get_blocksize(scene->fb.zsbuf->format);

      clear_value &= clear_mask;

      for (layer = 0; layer <= scene->fb_max_layer; layer++) {
         dst = dst_layer;

         switch (block_size) {
         case 1:
            assert(clear_mask == 0xff);
            memset(dst, (uint8_t) clear_value, height * width);
            break;
         case 2:
            if (clear_mask == 0xffff) {
               for (i = 0; i < height; i++) {
                  uint16_t *row = (uint16_t *)dst;
                  for (j = 0; j < width; j++)
                     *row++ = (uint16_t) clear_value;
                  dst += dst_stride;
               }
            }
            else {
               for (i = 0; i < height; i++) {
                  uint16_t *row = (uint16_t *)dst;
                  for (j = 0; j < width; j++) {
                     uint16_t tmp = ~clear_mask & *row;
                     *row++ = clear_value | tmp;
                  }
                  dst += dst_stride;
               }
            }
            break;
         case 4:
            if (clear_mask == 0xffffffff) {
               for (i = 0; i < height; i++) {
                  uint32_t *row = (uint32_t *)dst;
                  for (j = 0; j < width; j++)
                     *row++ = clear_value;
                  dst += dst_stride;
               }
            }
            else {
               for (i = 0; i < height; i++) {
                  uint32_t *row = (uint32_t *)dst;
                  for (j = 0; j < width; j++) {
                     uint32_t tmp = ~clear_mask & *row;
                     *row++ = clear_value | tmp;
                  }
                  dst += dst_stride;
               }
            }
            break;
         case 8:
            clear_value64 &= clear_mask64;
            if (clear_mask64 == 0xffffffffffULL) {
               for (i = 0; i < height; i++) {
                  uint64_t *row = (uint64_t *)dst;
                  for (j = 0; j < width; j++)
                     *row++ = clear_value64;
                  dst += dst_stride;
               }
            }
            else {
               for (i = 0; i < height; i++) {
                  uint64_t *row = (uint64_t *)dst;
                  for (j = 0; j < width; j++) {
                     uint64_t tmp = ~clear_mask64 & *row;
                     *row++ = clear_value64 | tmp;
                  }
                  dst += dst_stride;
               }
            }
            break;

         default:
            assert(0);
            break;
         }
         dst_layer += scene->zsbuf.layer_stride;
      }
   }
}



/**
 * Run the shader on all blocks in a tile.  This is used when a tile is
 * completely contained inside a triangle.
 * This is a bin command called during bin processing.
 */
static void
lp_rast_shade_tile(struct lp_rasterizer_task *task,
                   const union lp_rast_cmd_arg arg)
{
   const struct lp_scene *scene = task->scene;
   const struct lp_rast_shader_inputs *inputs = arg.shade_tile;
   const struct lp_rast_state *state;
   struct lp_fragment_shader_variant *variant;
   const unsigned tile_x = task->x, tile_y = task->y;
   unsigned x, y;

   if (inputs->disable) {
      /* This command was partially binned and has been disabled */
      return;
   }

   LP_DBG(DEBUG_RAST, "%s\n", __FUNCTION__);

   state = task->state;
   assert(state);
   if (!state) {
      return;
   }
   variant = state->variant;

   /* render the whole 64x64 tile in 4x4 chunks */
   for (y = 0; y < task->height; y += 4){
      for (x = 0; x < task->width; x += 4) {
         uint8_t *color[PIPE_MAX_COLOR_BUFS];
         unsigned stride[PIPE_MAX_COLOR_BUFS];
         uint8_t *depth = NULL;
         unsigned depth_stride = 0;
         unsigned i;

         /* color buffer */
         for (i = 0; i < scene->fb.nr_cbufs; i++){
            if (scene->fb.cbufs[i]) {
               stride[i] = scene->cbufs[i].stride;
               color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, tile_x + x,
                                                                     tile_y + y, inputs->layer);
            }
            else {
               stride[i] = 0;
               color[i] = NULL;
            }
         }

         /* depth buffer */
         if (scene->zsbuf.map) {
            depth = lp_rast_get_unswizzled_depth_block_pointer(task, tile_x + x,
                                                               tile_y + y, inputs->layer);
            depth_stride = scene->zsbuf.stride;
         }

         /* Propagate non-interpolated raster state. */
         task->thread_data.raster_state.viewport_index = inputs->viewport_index;

         /* run shader on 4x4 block */
         BEGIN_JIT_CALL(state, task);
         variant->jit_function[RAST_WHOLE]( &state->jit_context,
                                            tile_x + x, tile_y + y,
                                            inputs->frontfacing,
                                            GET_A0(inputs),
                                            GET_DADX(inputs),
                                            GET_DADY(inputs),
                                            color,
                                            depth,
                                            0xffff,
                                            &task->thread_data,
                                            stride,
                                            depth_stride);
         END_JIT_CALL();
      }
   }
}


/**
 * Run the shader on all blocks in a tile.  This is used when a tile is
 * completely contained inside a triangle, and the shader is opaque.
 * This is a bin command called during bin processing.
 */
static void
lp_rast_shade_tile_opaque(struct lp_rasterizer_task *task,
                          const union lp_rast_cmd_arg arg)
{
   LP_DBG(DEBUG_RAST, "%s\n", __FUNCTION__);

   assert(task->state);
   if (!task->state) {
      return;
   }

   lp_rast_shade_tile(task, arg);
}


/**
 * Compute shading for a 4x4 block of pixels inside a triangle.
 * This is a bin command called during bin processing.
 * \param x  X position of quad in window coords
 * \param y  Y position of quad in window coords
 */
void
lp_rast_shade_quads_mask(struct lp_rasterizer_task *task,
                         const struct lp_rast_shader_inputs *inputs,
                         unsigned x, unsigned y,
                         unsigned mask)
{
   const struct lp_rast_state *state = task->state;
   struct lp_fragment_shader_variant *variant = state->variant;
   const struct lp_scene *scene = task->scene;
   uint8_t *color[PIPE_MAX_COLOR_BUFS];
   unsigned stride[PIPE_MAX_COLOR_BUFS];
   uint8_t *depth = NULL;
   unsigned depth_stride = 0;
   unsigned i;

   assert(state);

   /* Sanity checks */
   assert(x < scene->tiles_x * TILE_SIZE);
   assert(y < scene->tiles_y * TILE_SIZE);
   assert(x % TILE_VECTOR_WIDTH == 0);
   assert(y % TILE_VECTOR_HEIGHT == 0);

   assert((x % 4) == 0);
   assert((y % 4) == 0);

   /* color buffer */
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      if (scene->fb.cbufs[i]) {
         stride[i] = scene->cbufs[i].stride;
         color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, x, y,
                                                               inputs->layer);
      }
      else {
         stride[i] = 0;
         color[i] = NULL;
      }
   }

   /* depth buffer */
   if (scene->zsbuf.map) {
      depth_stride = scene->zsbuf.stride;
      depth = lp_rast_get_unswizzled_depth_block_pointer(task, x, y, inputs->layer);
   }

   assert(lp_check_alignment(state->jit_context.u8_blend_color, 16));

   /*
    * The rasterizer may produce fragments outside our
    * allocated 4x4 blocks hence need to filter them out here.
    */
   if ((x % TILE_SIZE) < task->width && (y % TILE_SIZE) < task->height) {
      /* not very accurate would need a popcount on the mask */
      /* always count this not worth bothering? */
      task->ps_invocations += 1 * variant->ps_inv_multiplier;

      /* Propagate non-interpolated raster state. */
      task->thread_data.raster_state.viewport_index = inputs->viewport_index;

      /* run shader on 4x4 block */
      BEGIN_JIT_CALL(state, task);
      variant->jit_function[RAST_EDGE_TEST](&state->jit_context,
                                            x, y,
                                            inputs->frontfacing,
                                            GET_A0(inputs),
                                            GET_DADX(inputs),
                                            GET_DADY(inputs),
                                            color,
                                            depth,
                                            mask,
                                            &task->thread_data,
                                            stride,
                                            depth_stride);
      END_JIT_CALL();
   }
}



/**
 * Begin a new occlusion query.
 * This is a bin command put in all bins.
 * Called per thread.
 */
static void
lp_rast_begin_query(struct lp_rasterizer_task *task,
                    const union lp_rast_cmd_arg arg)
{
   struct llvmpipe_query *pq = arg.query_obj;

   switch (pq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
   case PIPE_QUERY_OCCLUSION_PREDICATE:
      pq->start[task->thread_index] = task->thread_data.vis_counter;
      break;
   case PIPE_QUERY_PIPELINE_STATISTICS:
      pq->start[task->thread_index] = task->ps_invocations;
      break;
   default:
      assert(0);
      break;
   }
}


/**
 * End the current occlusion query.
 * This is a bin command put in all bins.
 * Called per thread.
 */
static void
lp_rast_end_query(struct lp_rasterizer_task *task,
                  const union lp_rast_cmd_arg arg)
{
   struct llvmpipe_query *pq = arg.query_obj;

   switch (pq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
   case PIPE_QUERY_OCCLUSION_PREDICATE:
      pq->end[task->thread_index] +=
         task->thread_data.vis_counter - pq->start[task->thread_index];
      pq->start[task->thread_index] = 0;
      break;
   case PIPE_QUERY_TIMESTAMP:
      pq->end[task->thread_index] = os_time_get_nano();
      break;
   case PIPE_QUERY_PIPELINE_STATISTICS:
      pq->end[task->thread_index] +=
         task->ps_invocations - pq->start[task->thread_index];
      pq->start[task->thread_index] = 0;
      break;
   default:
      assert(0);
      break;
   }
}


void
lp_rast_set_state(struct lp_rasterizer_task *task,
                  const union lp_rast_cmd_arg arg)
{
   task->state = arg.state;
}



/**
 * Called when we're done writing to a color tile.
 */
static void
lp_rast_tile_end(struct lp_rasterizer_task *task)
{
   unsigned i;

   for (i = 0; i < task->scene->num_active_queries; ++i) {
      lp_rast_end_query(task, lp_rast_arg_query(task->scene->active_queries[i]));
   }

   /* debug */
   memset(task->color_tiles, 0, sizeof(task->color_tiles));
   task->depth_tile = NULL;

   task->bin = NULL;
}

static lp_rast_cmd_func dispatch[LP_RAST_OP_MAX] =
{
   lp_rast_clear_color,
   lp_rast_clear_zstencil,
   lp_rast_triangle_1,
   lp_rast_triangle_2,
   lp_rast_triangle_3,
   lp_rast_triangle_4,
   lp_rast_triangle_5,
   lp_rast_triangle_6,
   lp_rast_triangle_7,
   lp_rast_triangle_8,
   lp_rast_triangle_3_4,
   lp_rast_triangle_3_16,
   lp_rast_triangle_4_16,
   lp_rast_shade_tile,
   lp_rast_shade_tile_opaque,
   lp_rast_begin_query,
   lp_rast_end_query,
   lp_rast_set_state,
   lp_rast_triangle_32_1,
   lp_rast_triangle_32_2,
   lp_rast_triangle_32_3,
   lp_rast_triangle_32_4,
   lp_rast_triangle_32_5,
   lp_rast_triangle_32_6,
   lp_rast_triangle_32_7,
   lp_rast_triangle_32_8,
   lp_rast_triangle_32_3_4,
   lp_rast_triangle_32_3_16,
   lp_rast_triangle_32_4_16
};


static void
do_rasterize_bin(struct lp_rasterizer_task *task,
                 const struct cmd_bin *bin,
                 int x, int y)
{
   const struct cmd_block *block;
   unsigned k;

   if (0)
      lp_debug_bin(bin, x, y);

   for (block = bin->head; block; block = block->next) {
      for (k = 0; k < block->count; k++) {
         dispatch[block->cmd[k]]( task, block->arg[k] );
      }
   }
}



/**
 * Rasterize commands for a single bin.
 * \param x, y  position of the bin's tile in the framebuffer
 * Must be called between lp_rast_begin() and lp_rast_end().
 * Called per thread.
 */
static void
rasterize_bin(struct lp_rasterizer_task *task,
              const struct cmd_bin *bin, int x, int y )
{
   lp_rast_tile_begin( task, bin, x, y );

   do_rasterize_bin(task, bin, x, y);

   lp_rast_tile_end(task);


   /* Debug/Perf flags:
    */
   if (bin->head->count == 1) {
      if (bin->head->cmd[0] == LP_RAST_OP_SHADE_TILE_OPAQUE)
         LP_COUNT(nr_pure_shade_opaque_64);
      else if (bin->head->cmd[0] == LP_RAST_OP_SHADE_TILE)
         LP_COUNT(nr_pure_shade_64);
   }
}


/* An empty bin is one that just loads the contents of the tile and
 * stores them again unchanged.  This typically happens when bins have
 * been flushed for some reason in the middle of a frame, or when
 * incremental updates are being made to a render target.
 * 
 * Try to avoid doing pointless work in this case.
 */
static boolean
is_empty_bin( const struct cmd_bin *bin )
{
   return bin->head == NULL;
}


/**
 * Rasterize/execute all bins within a scene.
 * Called per thread.
 */
static void
rasterize_scene(struct lp_rasterizer_task *task,
                struct lp_scene *scene)
{
   task->scene = scene;

   if (!task->rast->no_rast && !scene->discard) {
      /* loop over scene bins, rasterize each */
      {
         struct cmd_bin *bin;
         int i, j;

         assert(scene);
         while ((bin = lp_scene_bin_iter_next(scene, &i, &j))) {
            if (!is_empty_bin( bin ))
               rasterize_bin(task, bin, i, j);
         }
      }
   }


   if (scene->fence) {
      lp_fence_signal(scene->fence);
   }

   task->scene = NULL;
}


/**
 * Called by setup module when it has something for us to render.
 */
void
lp_rast_queue_scene( struct lp_rasterizer *rast,
                     struct lp_scene *scene)
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   if (rast->num_threads == 0) {
      /* no threading */
      unsigned fpstate = util_fpstate_get();

      /* Make sure that denorms are treated like zeros. This is 
       * the behavior required by D3D10. OpenGL doesn't care.
       */
      util_fpstate_set_denorms_to_zero(fpstate);

      lp_rast_begin( rast, scene );

      rasterize_scene( &rast->tasks[0], scene );

      lp_rast_end( rast );

      util_fpstate_set(fpstate);

      rast->curr_scene = NULL;
   }
   else {
      /* threaded rendering! */
      unsigned i;

      lp_scene_enqueue( rast->full_scenes, scene );

      /* signal the threads that there's work to do */
      for (i = 0; i < rast->num_threads; i++) {
         pipe_semaphore_signal(&rast->tasks[i].work_ready);
      }
   }

   LP_DBG(DEBUG_SETUP, "%s done \n", __FUNCTION__);
}


void
lp_rast_finish( struct lp_rasterizer *rast )
{
   if (rast->num_threads == 0) {
      /* nothing to do */
   }
   else {
      int i;

      /* wait for work to complete */
      for (i = 0; i < rast->num_threads; i++) {
         pipe_semaphore_wait(&rast->tasks[i].work_done);
      }
   }
}


/**
 * This is the thread's main entrypoint.
 * It's a simple loop:
 *   1. wait for work
 *   2. do work
 *   3. signal that we're done
 */
static PIPE_THREAD_ROUTINE( thread_function, init_data )
{
   struct lp_rasterizer_task *task = (struct lp_rasterizer_task *) init_data;
   struct lp_rasterizer *rast = task->rast;
   boolean debug = false;
   unsigned fpstate = util_fpstate_get();

   /* Make sure that denorms are treated like zeros. This is 
    * the behavior required by D3D10. OpenGL doesn't care.
    */
   util_fpstate_set_denorms_to_zero(fpstate);

   while (1) {
      /* wait for work */
      if (debug)
         debug_printf("thread %d waiting for work\n", task->thread_index);
      pipe_semaphore_wait(&task->work_ready);

      if (rast->exit_flag)
         break;

      if (task->thread_index == 0) {
         /* thread[0]:
          *  - get next scene to rasterize
          *  - map the framebuffer surfaces
          */
         lp_rast_begin( rast, 
                        lp_scene_dequeue( rast->full_scenes, TRUE ) );
      }

      /* Wait for all threads to get here so that threads[1+] don't
       * get a null rast->curr_scene pointer.
       */
      pipe_barrier_wait( &rast->barrier );

      /* do work */
      if (debug)
         debug_printf("thread %d doing work\n", task->thread_index);

      rasterize_scene(task,
                      rast->curr_scene);
      
      /* wait for all threads to finish with this scene */
      pipe_barrier_wait( &rast->barrier );

      /* XXX: shouldn't be necessary:
       */
      if (task->thread_index == 0) {
         lp_rast_end( rast );
      }

      /* signal done with work */
      if (debug)
         debug_printf("thread %d done working\n", task->thread_index);

      pipe_semaphore_signal(&task->work_done);
   }

   return 0;
}


/**
 * Initialize semaphores and spawn the threads.
 */
static void
create_rast_threads(struct lp_rasterizer *rast)
{
   unsigned i;

   /* NOTE: if num_threads is zero, we won't use any threads */
   for (i = 0; i < rast->num_threads; i++) {
      pipe_semaphore_init(&rast->tasks[i].work_ready, 0);
      pipe_semaphore_init(&rast->tasks[i].work_done, 0);
      rast->threads[i] = pipe_thread_create(thread_function,
                                            (void *) &rast->tasks[i]);
   }
}



/**
 * Create new lp_rasterizer.  If num_threads is zero, don't create any
 * new threads, do rendering synchronously.
 * \param num_threads  number of rasterizer threads to create
 */
struct lp_rasterizer *
lp_rast_create( unsigned num_threads )
{
   struct lp_rasterizer *rast;
   unsigned i;

   rast = CALLOC_STRUCT(lp_rasterizer);
   if (!rast) {
      goto no_rast;
   }

   rast->full_scenes = lp_scene_queue_create();
   if (!rast->full_scenes) {
      goto no_full_scenes;
   }

   for (i = 0; i < Elements(rast->tasks); i++) {
      struct lp_rasterizer_task *task = &rast->tasks[i];
      task->rast = rast;
      task->thread_index = i;
   }

   rast->num_threads = num_threads;

   rast->no_rast = debug_get_bool_option("LP_NO_RAST", FALSE);

   create_rast_threads(rast);

   /* for synchronizing rasterization threads */
   pipe_barrier_init( &rast->barrier, rast->num_threads );

   memset(lp_dummy_tile, 0, sizeof lp_dummy_tile);

   return rast;

no_full_scenes:
   FREE(rast);
no_rast:
   return NULL;
}


/* Shutdown:
 */
void lp_rast_destroy( struct lp_rasterizer *rast )
{
   unsigned i;

   /* Set exit_flag and signal each thread's work_ready semaphore.
    * Each thread will be woken up, notice that the exit_flag is set and
    * break out of its main loop.  The thread will then exit.
    */
   rast->exit_flag = TRUE;
   for (i = 0; i < rast->num_threads; i++) {
      pipe_semaphore_signal(&rast->tasks[i].work_ready);
   }

   /* Wait for threads to terminate before cleaning up per-thread data */
   for (i = 0; i < rast->num_threads; i++) {
      pipe_thread_wait(rast->threads[i]);
   }

   /* Clean up per-thread data */
   for (i = 0; i < rast->num_threads; i++) {
      pipe_semaphore_destroy(&rast->tasks[i].work_ready);
      pipe_semaphore_destroy(&rast->tasks[i].work_done);
   }

   /* for synchronizing rasterization threads */
   pipe_barrier_destroy( &rast->barrier );

   lp_scene_queue_destroy(rast->full_scenes);

   FREE(rast);
}


@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d188 1
a188 1
      uint8_t *dst_layer = lp_rast_get_depth_tile_pointer(task, LP_TEX_USAGE_READ_WRITE);
d317 2
a318 2
               color[i] = lp_rast_get_color_block_pointer(task, i, tile_x + x,
                                                          tile_y + y, inputs->layer);
d328 2
a329 2
            depth = lp_rast_get_depth_block_pointer(task, tile_x + x,
                                                    tile_y + y, inputs->layer);
d412 2
a413 2
         color[i] = lp_rast_get_color_block_pointer(task, i, x, y,
                                                    inputs->layer);
d424 1
a424 1
      depth = lp_rast_get_depth_block_pointer(task, x, y, inputs->layer);
a802 4
#ifdef _WIN32
   pipe_semaphore_signal(&task->work_done);
#endif

d888 1
a888 3
   /* Wait for threads to terminate before cleaning up per-thread data.
    * We don't actually call pipe_thread_wait to avoid dead lock on Windows
    * per https://bugs.freedesktop.org/show_bug.cgi?id=76252 */
a889 3
#ifdef _WIN32
      pipe_semaphore_wait(&rast->tasks[i].work_done);
#else
a890 1
#endif
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d188 1
a188 1
      uint8_t *dst_layer = lp_rast_get_unswizzled_depth_tile_pointer(task, LP_TEX_USAGE_READ_WRITE);
d317 2
a318 2
               color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, tile_x + x,
                                                                     tile_y + y, inputs->layer);
d328 2
a329 2
            depth = lp_rast_get_unswizzled_depth_block_pointer(task, tile_x + x,
                                                               tile_y + y, inputs->layer);
d412 2
a413 2
         color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, x, y,
                                                               inputs->layer);
d424 1
a424 1
      depth = lp_rast_get_unswizzled_depth_block_pointer(task, x, y, inputs->layer);
d803 4
d892 3
a894 1
   /* Wait for threads to terminate before cleaning up per-thread data */
d896 3
d900 1
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d38 1
d122 7
d130 2
a131 3
   if (scene->fb.nr_cbufs) {
      unsigned i;
      union util_color uc;
d133 6
a138 22
      if (util_format_is_pure_integer(scene->fb.cbufs[0]->format)) {
         /*
          * We expect int/uint clear values here, though some APIs
          * might disagree (but in any case util_pack_color()
          * couldn't handle it)...
          */
         LP_DBG(DEBUG_RAST, "%s pure int 0x%x,0x%x,0x%x,0x%x\n", __FUNCTION__,
                    arg.clear_color.ui[0],
                    arg.clear_color.ui[1],
                    arg.clear_color.ui[2],
                    arg.clear_color.ui[3]);

         for (i = 0; i < scene->fb.nr_cbufs; i++) {
            enum pipe_format format = scene->fb.cbufs[i]->format;

            if (util_format_is_pure_sint(format)) {
               util_format_write_4i(format, arg.clear_color.i, 0, &uc, 0, 0, 0, 1, 1);
            }
            else {
               assert(util_format_is_pure_uint(format));
               util_format_write_4ui(format, arg.clear_color.ui, 0, &uc, 0, 0, 0, 1, 1);
            }
a139 15
            util_fill_box(scene->cbufs[i].map,
                          format,
                          scene->cbufs[i].stride,
                          scene->cbufs[i].layer_stride,
                          task->x,
                          task->y,
                          0,
                          task->width,
                          task->height,
                          scene->fb_max_layer + 1,
                          &uc);
         }
      }
      else {
         uint8_t clear_color[4];
d141 11
a151 28
         for (i = 0; i < 4; ++i) {
            clear_color[i] = float_to_ubyte(arg.clear_color.f[i]);
         }

         LP_DBG(DEBUG_RAST, "%s 0x%x,0x%x,0x%x,0x%x\n", __FUNCTION__,
                    clear_color[0],
                    clear_color[1],
                    clear_color[2],
                    clear_color[3]);

         for (i = 0; i < scene->fb.nr_cbufs; i++) {
            util_pack_color(arg.clear_color.f,
                            scene->fb.cbufs[i]->format, &uc);

            util_fill_box(scene->cbufs[i].map,
                          scene->fb.cbufs[i]->format,
                          scene->cbufs[i].stride,
                          scene->cbufs[i].layer_stride,
                          task->x,
                          task->y,
                          0,
                          task->width,
                          task->height,
                          scene->fb_max_layer + 1,
                          &uc);
         }
      }
   }
d153 1
a157 2


d315 9
a323 3
            stride[i] = scene->cbufs[i].stride;
            color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, tile_x + x,
                                                                  tile_y + y, inputs->layer);
d333 3
d410 9
a418 2
      stride[i] = scene->cbufs[i].stride;
      color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, x, y, inputs->layer);
d436 4
a439 1
      task->ps_invocations++;
d568 11
d688 6
d701 2
d803 1
a803 1
   return NULL;
a904 8
}


/** Return number of rasterization threads */
unsigned
lp_rast_get_num_threads( struct lp_rasterizer *rast )
{
   return rast->num_threads;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d35 2
a43 1
#include "lp_tile_soa.h"
d46 1
a63 1

a78 6

#ifdef DEBUG
   if (0)
      debug_printf("Post render scene: tile unswizzle: %u tile swizzle: %u\n",
                   lp_tile_unswizzle_count, lp_tile_swizzle_count);
#endif
d89 2
a90 1
                   const struct cmd_bin *bin)
d92 1
a92 2
   const struct lp_scene *scene = task->scene;
   enum lp_texture_usage usage;
d94 7
a100 1
   LP_DBG(DEBUG_RAST, "%s %d,%d\n", __FUNCTION__, bin->x, bin->y);
d102 2
a103 3
   task->bin = bin;
   task->x = bin->x * TILE_SIZE;
   task->y = bin->y * TILE_SIZE;
d105 1
a105 1
   /* reset pointers to color tile(s) */
d107 1
a107 34

   /* get pointer to depth/stencil tile */
   {
      struct pipe_surface *zsbuf = task->scene->fb.zsbuf;
      if (zsbuf) {
         struct llvmpipe_resource *lpt = llvmpipe_resource(zsbuf->texture);

         if (scene->has_depthstencil_clear)
            usage = LP_TEX_USAGE_WRITE_ALL;
         else
            usage = LP_TEX_USAGE_READ_WRITE;

         /* "prime" the tile: convert data from linear to tiled if necessary
          * and update the tile's layout info.
          */
         (void) llvmpipe_get_texture_tile(lpt,
                                          zsbuf->u.tex.first_layer,
                                          zsbuf->u.tex.level,
                                          usage,
                                          task->x,
                                          task->y);
         /* Get actual pointer to the tile data.  Note that depth/stencil
          * data is tiled differently than color data.
          */
         task->depth_tile = lp_rast_get_depth_block_pointer(task,
                                                            task->x,
                                                            task->y);

         assert(task->depth_tile);
      }
      else {
         task->depth_tile = NULL;
      }
   }
d114 1
a120 1
   const uint8_t *clear_color = arg.clear_color;
d122 26
a147 1
   unsigned i;
d149 12
a160 14
   LP_DBG(DEBUG_RAST, "%s 0x%x,0x%x,0x%x,0x%x\n", __FUNCTION__, 
              clear_color[0],
              clear_color[1],
              clear_color[2],
              clear_color[3]);

   if (clear_color[0] == clear_color[1] &&
       clear_color[1] == clear_color[2] &&
       clear_color[2] == clear_color[3]) {
      /* clear to grayscale value {x, x, x, x} */
      for (i = 0; i < scene->fb.nr_cbufs; i++) {
         uint8_t *ptr =
            lp_rast_get_color_tile_pointer(task, i, LP_TEX_USAGE_WRITE_ALL);
	 memset(ptr, clear_color[0], TILE_SIZE * TILE_SIZE * 4);
d162 28
a189 22
   }
   else {
      /* Non-gray color.
       * Note: if the swizzled tile layout changes (see TILE_PIXEL) this code
       * will need to change.  It'll be pretty obvious when clearing no longer
       * works.
       */
      const unsigned chunk = TILE_SIZE / 4;
      for (i = 0; i < scene->fb.nr_cbufs; i++) {
         uint8_t *c =
            lp_rast_get_color_tile_pointer(task, i, LP_TEX_USAGE_WRITE_ALL);
         unsigned j;

         for (j = 0; j < 4 * TILE_SIZE; j++) {
            memset(c, clear_color[0], chunk);
            c += chunk;
            memset(c, clear_color[1], chunk);
            c += chunk;
            memset(c, clear_color[2], chunk);
            c += chunk;
            memset(c, clear_color[3], chunk);
            c += chunk;
a199 2


d203 1
d210 7
a216 6
   uint32_t clear_value = arg.clear_zstencil.value;
   uint32_t clear_mask = arg.clear_zstencil.mask;
   const unsigned height = TILE_SIZE / TILE_VECTOR_HEIGHT;
   const unsigned width = TILE_SIZE * TILE_VECTOR_HEIGHT;
   const unsigned block_size = scene->zsbuf.blocksize;
   const unsigned dst_stride = scene->zsbuf.stride * TILE_VECTOR_HEIGHT;
d219 1
d225 1
a225 5
    * Clear the aera of the swizzled depth/depth buffer matching this tile, in
    * stripes of TILE_VECTOR_HEIGHT x TILE_SIZE at a time.
    *
    * The swizzled depth format is such that the depths for
    * TILE_VECTOR_HEIGHT x TILE_VECTOR_WIDTH pixels have consecutive offsets.
d228 64
a291 24
   dst = task->depth_tile;

   clear_value &= clear_mask;

   switch (block_size) {
   case 1:
      assert(clear_mask == 0xff);
      memset(dst, (uint8_t) clear_value, height * width);
      break;
   case 2:
      if (clear_mask == 0xffff) {
         for (i = 0; i < height; i++) {
            uint16_t *row = (uint16_t *)dst;
            for (j = 0; j < width; j++)
               *row++ = (uint16_t) clear_value;
            dst += dst_stride;
         }
      }
      else {
         for (i = 0; i < height; i++) {
            uint16_t *row = (uint16_t *)dst;
            for (j = 0; j < width; j++) {
               uint16_t tmp = ~clear_mask & *row;
               *row++ = clear_value | tmp;
d293 9
a301 19
            dst += dst_stride;
         }
      }
      break;
   case 4:
      if (clear_mask == 0xffffffff) {
         for (i = 0; i < height; i++) {
            uint32_t *row = (uint32_t *)dst;
            for (j = 0; j < width; j++)
               *row++ = clear_value;
            dst += dst_stride;
         }
      }
      else {
         for (i = 0; i < height; i++) {
            uint32_t *row = (uint32_t *)dst;
            for (j = 0; j < width; j++) {
               uint32_t tmp = ~clear_mask & *row;
               *row++ = clear_value | tmp;
d303 5
a307 1
            dst += dst_stride;
d309 1
a310 38
      break;
   default:
      assert(0);
      break;
   }
}



/**
 * Convert the color tile from tiled to linear layout.
 * This is generally only done when we're flushing the scene just prior to
 * SwapBuffers.  If we didn't do this here, we'd have to convert the entire
 * tiled color buffer to linear layout in the llvmpipe_texture_unmap()
 * function.  It's better to do it here to take advantage of
 * threading/parallelism.
 * This is a bin command which is stored in all bins.
 */
static void
lp_rast_store_linear_color( struct lp_rasterizer_task *task )
{
   const struct lp_scene *scene = task->scene;
   unsigned buf;

   for (buf = 0; buf < scene->fb.nr_cbufs; buf++) {
      struct pipe_surface *cbuf = scene->fb.cbufs[buf];
      const unsigned layer = cbuf->u.tex.first_layer;
      const unsigned level = cbuf->u.tex.level;
      struct llvmpipe_resource *lpt = llvmpipe_resource(cbuf->texture);

      if (!task->color_tiles[buf])
         continue;

      llvmpipe_unswizzle_cbuf_tile(lpt,
                                   layer,
                                   level,
                                   task->x, task->y,
                                   task->color_tiles[buf]);
d327 2
a328 2
   const struct lp_rast_state *state = task->state;
   struct lp_fragment_shader_variant *variant = state->variant;
d339 7
d347 2
a348 2
   for (y = 0; y < TILE_SIZE; y += 4){
      for (x = 0; x < TILE_SIZE; x += 4) {
d350 3
a352 1
         uint32_t *depth;
d356 5
a360 3
         for (i = 0; i < scene->fb.nr_cbufs; i++)
            color[i] = lp_rast_get_color_block_pointer(task, i,
                                                       tile_x + x, tile_y + y);
d363 5
a367 1
         depth = lp_rast_get_depth_block_pointer(task, tile_x + x, tile_y + y);
d380 3
a382 1
                                            &task->vis_counter);
a397 3
   const struct lp_scene *scene = task->scene;
   unsigned i;

d400 3
a402 3
   /* this will prevent converting the layout from tiled to linear */
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      (void)lp_rast_get_color_tile_pointer(task, i, LP_TEX_USAGE_WRITE_ALL);
d425 3
a427 1
   void *depth;
d433 2
d443 2
a444 2
      color[i] = lp_rast_get_color_block_pointer(task, i, x, y);
      assert(lp_check_alignment(color[i], 16));
d448 4
a451 1
   depth = lp_rast_get_depth_block_pointer(task, x, y);
d453 1
d455 25
a479 15
   assert(lp_check_alignment(state->jit_context.blend_color, 16));

   /* run shader on 4x4 block */
   BEGIN_JIT_CALL(state, task);
   variant->jit_function[RAST_EDGE_TEST](&state->jit_context,
                                         x, y,
                                         inputs->frontfacing,
                                         GET_A0(inputs),
                                         GET_DADX(inputs),
                                         GET_DADY(inputs),
                                         color,
                                         depth,
                                         mask,
                                         &task->vis_counter);
   END_JIT_CALL();
d495 12
a506 3
   assert(task->query == NULL);
   task->vis_counter = 0;
   task->query = pq;
d519 20
a538 4
   assert(task->query);
   if (task->query) {
      task->query->count[task->thread_index] += task->vis_counter;
      task->query = NULL;
a552 53
 * Set top row and left column of the tile's pixels to white.  For debugging.
 */
static void
outline_tile(uint8_t *tile)
{
   const uint8_t val = 0xff;
   unsigned i;

   for (i = 0; i < TILE_SIZE; i++) {
      TILE_PIXEL(tile, i, 0, 0) = val;
      TILE_PIXEL(tile, i, 0, 1) = val;
      TILE_PIXEL(tile, i, 0, 2) = val;
      TILE_PIXEL(tile, i, 0, 3) = val;

      TILE_PIXEL(tile, 0, i, 0) = val;
      TILE_PIXEL(tile, 0, i, 1) = val;
      TILE_PIXEL(tile, 0, i, 2) = val;
      TILE_PIXEL(tile, 0, i, 3) = val;
   }
}


/**
 * Draw grid of gray lines at 16-pixel intervals across the tile to
 * show the sub-tile boundaries.  For debugging.
 */
static void
outline_subtiles(uint8_t *tile)
{
   const uint8_t val = 0x80;
   const unsigned step = 16;
   unsigned i, j;

   for (i = 0; i < TILE_SIZE; i += step) {
      for (j = 0; j < TILE_SIZE; j++) {
         TILE_PIXEL(tile, i, j, 0) = val;
         TILE_PIXEL(tile, i, j, 1) = val;
         TILE_PIXEL(tile, i, j, 2) = val;
         TILE_PIXEL(tile, i, j, 3) = val;

         TILE_PIXEL(tile, j, i, 0) = val;
         TILE_PIXEL(tile, j, i, 1) = val;
         TILE_PIXEL(tile, j, i, 2) = val;
         TILE_PIXEL(tile, j, i, 3) = val;
      }
   }

   outline_tile(tile);
}



/**
d558 1
a558 20
#ifdef DEBUG
   if (LP_DEBUG & (DEBUG_SHOW_SUBTILES | DEBUG_SHOW_TILES)) {
      const struct lp_scene *scene = task->scene;
      unsigned buf;

      for (buf = 0; buf < scene->fb.nr_cbufs; buf++) {
         uint8_t *color = lp_rast_get_color_block_pointer(task, buf,
                                                          task->x, task->y);

         if (LP_DEBUG & DEBUG_SHOW_SUBTILES)
            outline_subtiles(color);
         else if (LP_DEBUG & DEBUG_SHOW_TILES)
            outline_tile(color);
      }
   }
#else
   (void) outline_subtiles;
#endif

   lp_rast_store_linear_color(task);
d560 2
a561 3
   if (task->query) {
      union lp_rast_cmd_arg dummy = {0};
      lp_rast_end_query(task, dummy);
d596 2
a597 1
                 const struct cmd_bin *bin)
d603 1
a603 1
      lp_debug_bin(bin);
d622 1
a622 1
              const struct cmd_bin *bin )
d624 1
a624 1
   lp_rast_tile_begin( task, bin );
d626 1
a626 1
   do_rasterize_bin(task, bin);
d665 11
a675 8
   /* loop over scene bins, rasterize each */
#if 0
   {
      unsigned i, j;
      for (i = 0; i < scene->tiles_x; i++) {
         for (j = 0; j < scene->tiles_y; j++) {
            struct cmd_bin *bin = lp_scene_get_bin(scene, i, j);
            rasterize_bin(task, bin, i, j);
d679 1
a679 11
#else
   {
      struct cmd_bin *bin;

      assert(scene);
      while ((bin = lp_scene_bin_iter_next(scene))) {
         if (!is_empty_bin( bin ))
            rasterize_bin(task, bin);
      }
   }
#endif
d749 1
a749 1
static PIPE_THREAD_ROUTINE( thread_func, init_data )
d754 6
d823 1
a823 1
      rast->threads[i] = pipe_thread_create(thread_func,
d842 3
a844 2
   if(!rast)
      return NULL;
d847 3
d859 2
a865 2
   memset(lp_swizzled_cbuf, 0, sizeof lp_swizzled_cbuf);

d869 5
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a31 1
#include "util/u_cpu_detect.h"
d33 1
d39 1
d47 10
a56 1
/* Begin rasterizing a scene:
d58 1
a58 1
static boolean
a61 4
   const struct pipe_framebuffer_state *fb = &scene->fb;
   boolean write_color = fb->nr_cbufs != 0;
   boolean write_zstencil = fb->zsbuf != NULL;
   int i;
d67 1
a67 19
   rast->state.nr_cbufs = scene->fb.nr_cbufs;
   rast->state.write_zstencil = write_zstencil;
   rast->state.write_color = write_color;
   
   for (i = 0; i < rast->state.nr_cbufs; i++) {
      rast->cbuf[i].map = scene->cbuf_map[i];
      rast->cbuf[i].format = scene->cbuf_transfer[i]->texture->format;
      rast->cbuf[i].width = scene->cbuf_transfer[i]->width;
      rast->cbuf[i].height = scene->cbuf_transfer[i]->height;
      rast->cbuf[i].stride = scene->cbuf_transfer[i]->stride;
   }

   if (write_zstencil) {
      rast->zsbuf.map = scene->zsbuf_map;
      rast->zsbuf.stride = scene->zsbuf_transfer->stride;
      rast->zsbuf.blocksize = 
         util_format_get_blocksize(scene->zsbuf_transfer->texture->format);
   }

a68 2
   
   return TRUE;
d75 1
a75 1
   int i;
d77 1
a77 1
   lp_scene_reset( rast->curr_scene );
d79 6
a84 2
   for (i = 0; i < rast->state.nr_cbufs; i++)
      rast->cbuf[i].map = NULL;
a85 3
   rast->zsbuf.map = NULL;
   rast->curr_scene = NULL;
}
d93 2
a94 2
lp_rast_start_tile(struct lp_rasterizer_task *task,
                   unsigned x, unsigned y)
d96 22
a117 1
   LP_DBG(DEBUG_RAST, "%s %d,%d\n", __FUNCTION__, x, y);
d119 22
a140 2
   task->x = x;
   task->y = y;
d148 1
a148 1
void
d152 1
a152 1
   struct lp_rasterizer *rast = task->rast;
d154 1
a154 1
   uint8_t **color_tile = task->tile.color;
d167 4
a170 2
      for (i = 0; i < rast->state.nr_cbufs; i++) {
	 memset(color_tile[i], clear_color[0], TILE_SIZE * TILE_SIZE * 4);
d180 3
a182 2
      for (i = 0; i < rast->state.nr_cbufs; i++) {
         uint8_t *c = color_tile[i];
d184 1
a194 1
         assert(c - color_tile[i] == TILE_SIZE * TILE_SIZE * 4);
d202 4
d210 1
a210 1
void
d214 3
a216 3
   struct lp_rasterizer *rast = task->rast;
   const unsigned tile_x = task->x;
   const unsigned tile_y = task->y;
d219 2
a220 1
   unsigned block_size = rast->zsbuf.blocksize;
a221 1
   unsigned dst_stride = rast->zsbuf.stride * TILE_VECTOR_HEIGHT;
d224 2
a225 7
   LP_DBG(DEBUG_RAST, "%s 0x%x\n", __FUNCTION__, arg.clear_zstencil);

   assert(rast->zsbuf.map);
   if (!rast->zsbuf.map)
      return;

   LP_DBG(DEBUG_RAST, "%s\n", __FUNCTION__);
d235 3
a237 1
   dst = lp_rast_depth_pointer(rast, tile_x, tile_y);
d241 2
a242 1
      memset(dst, (uint8_t) arg.clear_zstencil, height * width);
d245 17
a261 5
      for (i = 0; i < height; i++) {
         uint16_t *row = (uint16_t *)dst;
         for (j = 0; j < width; j++)
            *row++ = (uint16_t) arg.clear_zstencil;
         dst += dst_stride;
d265 17
a281 5
      for (i = 0; i < height; i++) {
         uint32_t *row = (uint32_t *)dst;
         for (j = 0; j < width; j++)
            *row++ = arg.clear_zstencil;
         dst += dst_stride;
d291 1
d293 7
a299 2
 * Load tile color from the framebuffer surface.
 * This is a bin command called during bin processing.
d301 2
a302 3
void
lp_rast_load_color(struct lp_rasterizer_task *task,
                   const union lp_rast_cmd_arg arg)
d304 2
a305 5
   struct lp_rasterizer *rast = task->rast;
   const unsigned x = task->x, y = task->y;
   unsigned i;

   LP_DBG(DEBUG_RAST, "%s at %u, %u\n", __FUNCTION__, x, y);
d307 14
a320 12
   for (i = 0; i < rast->state.nr_cbufs; i++) {
      if (x >= rast->cbuf[i].width || y >= rast->cbuf[i].height)
	 continue;

      lp_tile_read_4ub(rast->cbuf[i].format,
		       task->tile.color[i],
		       rast->cbuf[i].map, 
		       rast->cbuf[i].stride,
		       x, y,
		       TILE_SIZE, TILE_SIZE);

      LP_COUNT(nr_color_tile_load);
a324 13
void
lp_rast_set_state(struct lp_rasterizer_task *task,
                  const union lp_rast_cmd_arg arg)
{
   const struct lp_rast_state *state = arg.set_state;

   LP_DBG(DEBUG_RAST, "%s %p\n", __FUNCTION__, (void *) state);

   /* just set the current state pointer for this rasterizer */
   task->current_state = state;
}


d331 1
a331 1
void
d335 1
a335 3
   struct lp_rasterizer *rast = task->rast;
   const struct lp_rast_state *state = task->current_state;
   struct lp_rast_tile *tile = &task->tile;
d337 2
d342 5
d354 1
a354 4
         unsigned block_offset, i;

         /* offset of the 16x16 pixel block within the tile */
         block_offset = ((y / 4) * (16 * 16) + (x / 4) * 16);
d357 3
a359 2
         for (i = 0; i < rast->state.nr_cbufs; i++)
            color[i] = tile->color[i] + 4 * block_offset;
d362 1
a362 1
         depth = lp_rast_depth_pointer(rast, tile_x + x, tile_y + y);
d364 13
a376 10
         /* run shader */
         state->jit_function[0]( &state->jit_context,
                                 tile_x + x, tile_y + y,
                                 inputs->a0,
                                 inputs->dadx,
                                 inputs->dady,
                                 color,
                                 depth,
                                 INT_MIN, INT_MIN, INT_MIN,
                                 NULL, NULL, NULL );
d383 2
a384 1
 * Compute shading for a 4x4 block of pixels.
d387 3
a389 4
void lp_rast_shade_quads( struct lp_rasterizer_task *task,
                          const struct lp_rast_shader_inputs *inputs,
                          unsigned x, unsigned y,
                          int32_t c1, int32_t c2, int32_t c3)
d391 29
a419 3
   const struct lp_rast_state *state = task->current_state;
   struct lp_rasterizer *rast = task->rast;
   struct lp_rast_tile *tile = &task->tile;
a422 2
   unsigned ix, iy;
   int block_offset;
a432 6
   ix = x % TILE_SIZE;
   iy = y % TILE_SIZE;

   /* offset of the 16x16 pixel block within the tile */
   block_offset = ((iy / 4) * (16 * 16) + (ix / 4) * 16);

d434 4
a437 2
   for (i = 0; i < rast->state.nr_cbufs; i++)
      color[i] = tile->color[i] + 4 * block_offset;
d440 1
a440 1
   depth = lp_rast_depth_pointer(rast, x, y);
a442 1
   assert(lp_check_alignment(tile->color[0], 16));
d445 31
a475 14
   assert(lp_check_alignment(inputs->step[0], 16));
   assert(lp_check_alignment(inputs->step[1], 16));
   assert(lp_check_alignment(inputs->step[2], 16));

   /* run shader */
   state->jit_function[1]( &state->jit_context,
                        x, y,
                        inputs->a0,
                        inputs->dadx,
                        inputs->dady,
                        color,
                        depth,
                        c1, c2, c3,
                        inputs->step[0], inputs->step[1], inputs->step[2]);
d480 26
d559 1
a559 1
 * Write the rasterizer's color tile to the framebuffer.
d562 1
a562 1
lp_rast_store_color(struct lp_rasterizer_task *task)
d564 18
a581 3
   struct lp_rasterizer *rast = task->rast;
   const unsigned x = task->x, y = task->y;
   unsigned i;
d583 1
a583 3
   for (i = 0; i < rast->state.nr_cbufs; i++) {
      if (x >= rast->cbuf[i].width)
	 continue;
d585 33
a617 2
      if (y >= rast->cbuf[i].height)
	 continue;
a618 2
      LP_DBG(DEBUG_RAST, "%s [%u] %d,%d\n", __FUNCTION__,
	     task->thread_index, x, y);
d620 6
a625 4
      if (LP_DEBUG & DEBUG_SHOW_SUBTILES)
         outline_subtiles(task->tile.color[i]);
      else if (LP_DEBUG & DEBUG_SHOW_TILES)
         outline_tile(task->tile.color[i]);
d627 2
a628 6
      lp_tile_write_4ub(rast->cbuf[i].format,
			task->tile.color[i],
			rast->cbuf[i].map, 
			rast->cbuf[i].stride,
			x, y,
			TILE_SIZE, TILE_SIZE);
d630 4
a633 1
      LP_COUNT(nr_color_tile_store);
a639 26
 * Signal on a fence.  This is called during bin execution/rasterization.
 * Called per thread.
 */
void
lp_rast_fence(struct lp_rasterizer_task *task,
              const union lp_rast_cmd_arg arg)
{
   struct lp_fence *fence = arg.fence;

   pipe_mutex_lock( fence->mutex );

   fence->count++;
   assert(fence->count <= fence->rank);

   LP_DBG(DEBUG_RAST, "%s count=%u rank=%u\n", __FUNCTION__,
          fence->count, fence->rank);

   pipe_condvar_signal( fence->signalled );

   pipe_mutex_unlock( fence->mutex );
}




/**
d647 1
a647 2
              const struct cmd_bin *bin,
              int x, int y)
d649 1
a649 3
   const struct cmd_block_list *commands = &bin->commands;
   struct cmd_block *block;
   unsigned k;
d651 1
a651 1
   lp_rast_start_tile( task, x * TILE_SIZE, y * TILE_SIZE );
d653 1
a653 6
   /* simply execute each of the commands in the block list */
   for (block = commands->head; block; block = block->next) {
      for (k = 0; k < block->count; k++) {
         block->cmd[k]( task, block->arg[k] );
      }
   }
a654 4
   /* Write the rasterizer's tiles to the framebuffer.
    */
   if (task->rast->state.write_color)
      lp_rast_store_color(task);
d656 1
a656 1
   /* Free data for this bin.
d658 6
a663 1
   lp_scene_bin_reset( task->rast->curr_scene, x, y);
a666 36
#define RAST(x) { lp_rast_##x, #x }

static struct {
   lp_rast_cmd cmd;
   const char *name;
} cmd_names[] = 
{
   RAST(load_color),
   RAST(clear_color),
   RAST(clear_zstencil),
   RAST(triangle),
   RAST(shade_tile),
   RAST(set_state),
   RAST(fence),
};

static void
debug_bin( const struct cmd_bin *bin )
{
   const struct cmd_block *head = bin->commands.head;
   int i, j;

   for (i = 0; i < head->count; i++) {
      debug_printf("%d: ", i);
      for (j = 0; j < Elements(cmd_names); j++) {
         if (head->cmd[i] == cmd_names[j].cmd) {
            debug_printf("%s\n", cmd_names[j].name);
            break;
         }
      }
      if (j == Elements(cmd_names))
         debug_printf("...other\n");
   }

}

d677 1
a677 25
   const struct cmd_block *head = bin->commands.head;
   int i;
   
   if (0)
      debug_bin(bin);
   
   /* We emit at most two load-tile commands at the start of the first
    * command block.  In addition we seem to emit a couple of
    * set-state commands even in empty bins.
    *
    * As a heuristic, if a bin has more than 4 commands, consider it
    * non-empty.
    */
   if (head->next != NULL ||
       head->count > 4) {
      return FALSE;
   }

   for (i = 0; i < head->count; i++)
      if (head->cmd[i] != lp_rast_load_color &&
          head->cmd[i] != lp_rast_set_state) {
         return FALSE;
      }

   return TRUE;
a680 1

d689 1
a703 1
      int x, y;
d706 1
a706 1
      while ((bin = lp_scene_bin_iter_next(scene, &x, &y))) {
d708 1
a708 1
            rasterize_bin(task, bin, x, y);
d712 6
d737 2
a738 1
      lp_scene_reset( scene );
a844 10
#ifdef PIPE_OS_WINDOWS
   /* Multithreading not supported on windows until conditions and barriers are
    * properly implemented. */
   rast->num_threads = 0;
#else
   rast->num_threads = util_cpu_caps.nr_cpus;
   rast->num_threads = debug_get_num_option("LP_NUM_THREADS", rast->num_threads);
   rast->num_threads = MIN2(rast->num_threads, MAX_THREADS);
#endif

d857 3
a859 3
 * Create new lp_rasterizer.
 * \param empty  the queue to put empty scenes on after we've finished
 *               processing them.
d862 1
a862 1
lp_rast_create( void )
d865 1
a865 1
   unsigned i, cbuf;
a874 4

      for (cbuf = 0; cbuf < PIPE_MAX_COLOR_BUFS; cbuf++ )
	 task->tile.color[cbuf] = align_malloc(TILE_SIZE * TILE_SIZE * 4, 16);

d879 2
d886 4
d898 1
a898 6
   unsigned i, cbuf;

   for (i = 0; i < Elements(rast->tasks); i++) {
      for (cbuf = 0; cbuf < PIPE_MAX_COLOR_BUFS; cbuf++ )
	 align_free(rast->tasks[i].tile.color[cbuf]);
   }
d923 2
d935 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d31 1
a31 1
#include "util/u_rect.h"
a32 1
#include "util/u_pack_color.h"
a37 1
#include "lp_query.h"
d45 1
a45 10
#ifdef DEBUG
int jit_line = 0;
const struct lp_rast_state *jit_state = NULL;
const struct lp_rasterizer_task *jit_task = NULL;
#endif


/**
 * Begin rasterizing a scene.
 * Called once per scene by one thread.
d47 1
a47 1
static void
d51 4
d60 19
a78 1
   lp_scene_begin_rasterization( scene );
d80 2
d88 6
a93 1
   lp_scene_end_rasterization( rast->curr_scene );
d95 1
a96 6

#ifdef DEBUG
   if (0)
      debug_printf("Post render scene: tile unswizzle: %u tile swizzle: %u\n",
                   lp_tile_unswizzle_count, lp_tile_swizzle_count);
#endif
a98 1

d105 2
a106 2
lp_rast_tile_begin(struct lp_rasterizer_task *task,
                   const struct cmd_bin *bin)
d108 1
a108 22
   const struct lp_scene *scene = task->scene;
   enum lp_texture_usage usage;

   LP_DBG(DEBUG_RAST, "%s %d,%d\n", __FUNCTION__, bin->x, bin->y);

   task->bin = bin;
   task->x = bin->x * TILE_SIZE;
   task->y = bin->y * TILE_SIZE;

   /* reset pointers to color tile(s) */
   memset(task->color_tiles, 0, sizeof(task->color_tiles));

   /* get pointer to depth/stencil tile */
   {
      struct pipe_surface *zsbuf = task->scene->fb.zsbuf;
      if (zsbuf) {
         struct llvmpipe_resource *lpt = llvmpipe_resource(zsbuf->texture);

         if (scene->has_depthstencil_clear)
            usage = LP_TEX_USAGE_WRITE_ALL;
         else
            usage = LP_TEX_USAGE_READ_WRITE;
d110 2
a111 22
         /* "prime" the tile: convert data from linear to tiled if necessary
          * and update the tile's layout info.
          */
         (void) llvmpipe_get_texture_tile(lpt,
                                          zsbuf->u.tex.first_layer,
                                          zsbuf->u.tex.level,
                                          usage,
                                          task->x,
                                          task->y);
         /* Get actual pointer to the tile data.  Note that depth/stencil
          * data is tiled differently than color data.
          */
         task->depth_tile = lp_rast_get_depth_block_pointer(task,
                                                            task->x,
                                                            task->y);

         assert(task->depth_tile);
      }
      else {
         task->depth_tile = NULL;
      }
   }
d119 1
a119 1
static void
d123 1
a123 1
   const struct lp_scene *scene = task->scene;
d125 1
a125 1

d138 2
a139 4
      for (i = 0; i < scene->fb.nr_cbufs; i++) {
         uint8_t *ptr =
            lp_rast_get_color_tile_pointer(task, i, LP_TEX_USAGE_WRITE_ALL);
	 memset(ptr, clear_color[0], TILE_SIZE * TILE_SIZE * 4);
d149 2
a150 3
      for (i = 0; i < scene->fb.nr_cbufs; i++) {
         uint8_t *c =
            lp_rast_get_color_tile_pointer(task, i, LP_TEX_USAGE_WRITE_ALL);
a151 1

d162 1
a169 4




d174 1
a174 1
static void
d178 3
a180 3
   const struct lp_scene *scene = task->scene;
   uint32_t clear_value = arg.clear_zstencil.value;
   uint32_t clear_mask = arg.clear_zstencil.mask;
d183 1
a183 2
   const unsigned block_size = scene->zsbuf.blocksize;
   const unsigned dst_stride = scene->zsbuf.stride * TILE_VECTOR_HEIGHT;
d185 1
d188 7
a194 2
   LP_DBG(DEBUG_RAST, "%s: value=0x%08x, mask=0x%08x\n",
           __FUNCTION__, clear_value, clear_mask);
d204 1
a204 3
   dst = task->depth_tile;

   clear_value &= clear_mask;
d208 1
a208 2
      assert(clear_mask == 0xff);
      memset(dst, (uint8_t) clear_value, height * width);
d211 5
a215 17
      if (clear_mask == 0xffff) {
         for (i = 0; i < height; i++) {
            uint16_t *row = (uint16_t *)dst;
            for (j = 0; j < width; j++)
               *row++ = (uint16_t) clear_value;
            dst += dst_stride;
         }
      }
      else {
         for (i = 0; i < height; i++) {
            uint16_t *row = (uint16_t *)dst;
            for (j = 0; j < width; j++) {
               uint16_t tmp = ~clear_mask & *row;
               *row++ = clear_value | tmp;
            }
            dst += dst_stride;
         }
d219 5
a223 17
      if (clear_mask == 0xffffffff) {
         for (i = 0; i < height; i++) {
            uint32_t *row = (uint32_t *)dst;
            for (j = 0; j < width; j++)
               *row++ = clear_value;
            dst += dst_stride;
         }
      }
      else {
         for (i = 0; i < height; i++) {
            uint32_t *row = (uint32_t *)dst;
            for (j = 0; j < width; j++) {
               uint32_t tmp = ~clear_mask & *row;
               *row++ = clear_value | tmp;
            }
            dst += dst_stride;
         }
a232 1

d234 2
a235 7
 * Convert the color tile from tiled to linear layout.
 * This is generally only done when we're flushing the scene just prior to
 * SwapBuffers.  If we didn't do this here, we'd have to convert the entire
 * tiled color buffer to linear layout in the llvmpipe_texture_unmap()
 * function.  It's better to do it here to take advantage of
 * threading/parallelism.
 * This is a bin command which is stored in all bins.
d237 3
a239 2
static void
lp_rast_store_linear_color( struct lp_rasterizer_task *task )
d241 5
a245 2
   const struct lp_scene *scene = task->scene;
   unsigned buf;
d247 12
a258 14
   for (buf = 0; buf < scene->fb.nr_cbufs; buf++) {
      struct pipe_surface *cbuf = scene->fb.cbufs[buf];
      const unsigned layer = cbuf->u.tex.first_layer;
      const unsigned level = cbuf->u.tex.level;
      struct llvmpipe_resource *lpt = llvmpipe_resource(cbuf->texture);

      if (!task->color_tiles[buf])
         continue;

      llvmpipe_unswizzle_cbuf_tile(lpt,
                                   layer,
                                   level,
                                   task->x, task->y,
                                   task->color_tiles[buf]);
d263 13
d282 1
a282 1
static void
d286 3
a288 1
   const struct lp_scene *scene = task->scene;
a289 2
   const struct lp_rast_state *state = task->state;
   struct lp_fragment_shader_variant *variant = state->variant;
a292 5
   if (inputs->disable) {
      /* This command was partially binned and has been disabled */
      return;
   }

d300 4
a303 1
         unsigned i;
d306 2
a307 3
         for (i = 0; i < scene->fb.nr_cbufs; i++)
            color[i] = lp_rast_get_color_block_pointer(task, i,
                                                       tile_x + x, tile_y + y);
d310 1
a310 1
         depth = lp_rast_get_depth_block_pointer(task, tile_x + x, tile_y + y);
d312 10
a321 13
         /* run shader on 4x4 block */
         BEGIN_JIT_CALL(state, task);
         variant->jit_function[RAST_WHOLE]( &state->jit_context,
                                            tile_x + x, tile_y + y,
                                            inputs->frontfacing,
                                            GET_A0(inputs),
                                            GET_DADX(inputs),
                                            GET_DADY(inputs),
                                            color,
                                            depth,
                                            0xffff,
                                            &task->vis_counter);
         END_JIT_CALL();
d328 1
a328 2
 * Run the shader on all blocks in a tile.  This is used when a tile is
 * completely contained inside a triangle, and the shader is opaque.
d331 4
a334 3
static void
lp_rast_shade_tile_opaque(struct lp_rasterizer_task *task,
                          const union lp_rast_cmd_arg arg)
d336 3
a338 29
   const struct lp_scene *scene = task->scene;
   unsigned i;

   LP_DBG(DEBUG_RAST, "%s\n", __FUNCTION__);

   /* this will prevent converting the layout from tiled to linear */
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      (void)lp_rast_get_color_tile_pointer(task, i, LP_TEX_USAGE_WRITE_ALL);
   }

   lp_rast_shade_tile(task, arg);
}


/**
 * Compute shading for a 4x4 block of pixels inside a triangle.
 * This is a bin command called during bin processing.
 * \param x  X position of quad in window coords
 * \param y  Y position of quad in window coords
 */
void
lp_rast_shade_quads_mask(struct lp_rasterizer_task *task,
                         const struct lp_rast_shader_inputs *inputs,
                         unsigned x, unsigned y,
                         unsigned mask)
{
   const struct lp_rast_state *state = task->state;
   struct lp_fragment_shader_variant *variant = state->variant;
   const struct lp_scene *scene = task->scene;
d342 2
d354 6
d361 2
a362 4
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      color[i] = lp_rast_get_color_block_pointer(task, i, x, y);
      assert(lp_check_alignment(color[i], 16));
   }
d365 1
a365 1
   depth = lp_rast_get_depth_block_pointer(task, x, y);
d368 1
d371 14
a384 31
   /* run shader on 4x4 block */
   BEGIN_JIT_CALL(state, task);
   variant->jit_function[RAST_EDGE_TEST](&state->jit_context,
                                         x, y,
                                         inputs->frontfacing,
                                         GET_A0(inputs),
                                         GET_DADX(inputs),
                                         GET_DADY(inputs),
                                         color,
                                         depth,
                                         mask,
                                         &task->vis_counter);
   END_JIT_CALL();
}



/**
 * Begin a new occlusion query.
 * This is a bin command put in all bins.
 * Called per thread.
 */
static void
lp_rast_begin_query(struct lp_rasterizer_task *task,
                    const union lp_rast_cmd_arg arg)
{
   struct llvmpipe_query *pq = arg.query_obj;

   assert(task->query == NULL);
   task->vis_counter = 0;
   task->query = pq;
a388 26
 * End the current occlusion query.
 * This is a bin command put in all bins.
 * Called per thread.
 */
static void
lp_rast_end_query(struct lp_rasterizer_task *task,
                  const union lp_rast_cmd_arg arg)
{
   assert(task->query);
   if (task->query) {
      task->query->count[task->thread_index] += task->vis_counter;
      task->query = NULL;
   }
}


void
lp_rast_set_state(struct lp_rasterizer_task *task,
                  const union lp_rast_cmd_arg arg)
{
   task->state = arg.state;
}



/**
d442 1
a442 1
 * Called when we're done writing to a color tile.
d445 1
a445 1
lp_rast_tile_end(struct lp_rasterizer_task *task)
d447 27
a473 14
#ifdef DEBUG
   if (LP_DEBUG & (DEBUG_SHOW_SUBTILES | DEBUG_SHOW_TILES)) {
      const struct lp_scene *scene = task->scene;
      unsigned buf;

      for (buf = 0; buf < scene->fb.nr_cbufs; buf++) {
         uint8_t *color = lp_rast_get_color_block_pointer(task, buf,
                                                          task->x, task->y);

         if (LP_DEBUG & DEBUG_SHOW_SUBTILES)
            outline_subtiles(color);
         else if (LP_DEBUG & DEBUG_SHOW_TILES)
            outline_tile(color);
      }
d475 3
a477 3
#else
   (void) outline_subtiles;
#endif
d479 9
a487 1
   lp_rast_store_linear_color(task);
d489 1
a489 33
   if (task->query) {
      union lp_rast_cmd_arg dummy = {0};
      lp_rast_end_query(task, dummy);
   }

   /* debug */
   memset(task->color_tiles, 0, sizeof(task->color_tiles));
   task->depth_tile = NULL;

   task->bin = NULL;
}

static lp_rast_cmd_func dispatch[LP_RAST_OP_MAX] =
{
   lp_rast_clear_color,
   lp_rast_clear_zstencil,
   lp_rast_triangle_1,
   lp_rast_triangle_2,
   lp_rast_triangle_3,
   lp_rast_triangle_4,
   lp_rast_triangle_5,
   lp_rast_triangle_6,
   lp_rast_triangle_7,
   lp_rast_triangle_8,
   lp_rast_triangle_3_4,
   lp_rast_triangle_3_16,
   lp_rast_triangle_4_16,
   lp_rast_shade_tile,
   lp_rast_shade_tile_opaque,
   lp_rast_begin_query,
   lp_rast_end_query,
   lp_rast_set_state,
};
d491 2
d494 2
a495 6
static void
do_rasterize_bin(struct lp_rasterizer_task *task,
                 const struct cmd_bin *bin)
{
   const struct cmd_block *block;
   unsigned k;
d497 1
a497 2
   if (0)
      lp_debug_bin(bin);
d499 1
a499 5
   for (block = bin->head; block; block = block->next) {
      for (k = 0; k < block->count; k++) {
         dispatch[block->cmd[k]]( task, block->arg[k] );
      }
   }
d504 1
d513 2
a514 1
              const struct cmd_bin *bin )
d516 3
a518 1
   lp_rast_tile_begin( task, bin );
d520 1
a520 1
   do_rasterize_bin(task, bin);
d522 6
a527 1
   lp_rast_tile_end(task);
d529 4
d534 1
a534 1
   /* Debug/Perf flags:
d536 36
a571 5
   if (bin->head->count == 1) {
      if (bin->head->cmd[0] == LP_RAST_OP_SHADE_TILE_OPAQUE)
         LP_COUNT(nr_pure_shade_opaque_64);
      else if (bin->head->cmd[0] == LP_RAST_OP_SHADE_TILE)
         LP_COUNT(nr_pure_shade_64);
d573 1
a575 1

d586 25
a610 1
   return bin->head == NULL;
d614 1
a622 1
   task->scene = scene;
d637 1
d640 1
a640 1
      while ((bin = lp_scene_bin_iter_next(scene))) {
d642 1
a642 1
            rasterize_bin(task, bin);
a645 6

   if (scene->fence) {
      lp_fence_signal(scene->fence);
   }

   task->scene = NULL;
d665 1
a665 2
      lp_rast_end( rast );

d772 10
d794 3
a796 3
 * Create new lp_rasterizer.  If num_threads is zero, don't create any
 * new threads, do rendering synchronously.
 * \param num_threads  number of rasterizer threads to create
d799 1
a799 1
lp_rast_create( unsigned num_threads )
d802 1
a802 1
   unsigned i;
d812 4
a819 2
   rast->num_threads = num_threads;

a824 4
   memset(lp_swizzled_cbuf, 0, sizeof lp_swizzled_cbuf);

   memset(lp_dummy_tile, 0, sizeof lp_dummy_tile);

d833 6
a838 1
   unsigned i;
a862 2
   lp_scene_queue_destroy(rast->full_scenes);

a872 2


@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a34 2
#include "os/os_time.h"

d42 1
a44 1
#include "lp_tex_sample.h"
d62 1
d78 6
d94 1
a94 2
                   const struct cmd_bin *bin,
                   int x, int y)
d96 4
a99 1
   LP_DBG(DEBUG_RAST, "%s %d,%d\n", __FUNCTION__, x, y);
d102 5
a106 6
   task->x = x * TILE_SIZE;
   task->y = y * TILE_SIZE;
   task->width = TILE_SIZE + x * TILE_SIZE > task->scene->fb.width ?
                    task->scene->fb.width - x * TILE_SIZE : TILE_SIZE;
   task->height = TILE_SIZE + y * TILE_SIZE > task->scene->fb.height ?
                    task->scene->fb.height - y * TILE_SIZE : TILE_SIZE;
d108 10
a117 2
   task->thread_data.vis_counter = 0;
   task->ps_invocations = 0;
d119 22
a140 3
   /* reset pointers to color and depth tile(s) */
   memset(task->color_tiles, 0, sizeof(task->color_tiles));
   task->depth_tile = NULL;
a146 1
 * Clear commands always clear all bound layers.
d153 1
d155 1
a155 18
   if (scene->fb.nr_cbufs) {
      unsigned i;
      union util_color uc;

      if (util_format_is_pure_integer(scene->fb.cbufs[0]->format)) {
         /*
          * We expect int/uint clear values here, though some APIs
          * might disagree (but in any case util_pack_color()
          * couldn't handle it)...
          */
         LP_DBG(DEBUG_RAST, "%s pure int 0x%x,0x%x,0x%x,0x%x\n", __FUNCTION__,
                    arg.clear_color.ui[0],
                    arg.clear_color.ui[1],
                    arg.clear_color.ui[2],
                    arg.clear_color.ui[3]);

         for (i = 0; i < scene->fb.nr_cbufs; i++) {
            enum pipe_format format = scene->fb.cbufs[i]->format;
d157 14
a170 20
            if (util_format_is_pure_sint(format)) {
               util_format_write_4i(format, arg.clear_color.i, 0, &uc, 0, 0, 0, 1, 1);
            }
            else {
               assert(util_format_is_pure_uint(format));
               util_format_write_4ui(format, arg.clear_color.ui, 0, &uc, 0, 0, 0, 1, 1);
            }

            util_fill_box(scene->cbufs[i].map,
                          format,
                          scene->cbufs[i].stride,
                          scene->cbufs[i].layer_stride,
                          task->x,
                          task->y,
                          0,
                          task->width,
                          task->height,
                          scene->fb_max_layer + 1,
                          &uc);
         }
d172 22
a193 28
      else {
         uint8_t clear_color[4];

         for (i = 0; i < 4; ++i) {
            clear_color[i] = float_to_ubyte(arg.clear_color.f[i]);
         }

         LP_DBG(DEBUG_RAST, "%s 0x%x,0x%x,0x%x,0x%x\n", __FUNCTION__,
                    clear_color[0],
                    clear_color[1],
                    clear_color[2],
                    clear_color[3]);

         for (i = 0; i < scene->fb.nr_cbufs; i++) {
            util_pack_color(arg.clear_color.f,
                            scene->fb.cbufs[i]->format, &uc);

            util_fill_box(scene->cbufs[i].map,
                          scene->fb.cbufs[i]->format,
                          scene->cbufs[i].stride,
                          scene->cbufs[i].layer_stride,
                          task->x,
                          task->y,
                          0,
                          task->width,
                          task->height,
                          scene->fb_max_layer + 1,
                          &uc);
d204 2
a208 1
 * Clear commands always clear all bound layers.
d215 6
a220 7
   uint64_t clear_value64 = arg.clear_zstencil.value;
   uint64_t clear_mask64 = arg.clear_zstencil.mask;
   uint32_t clear_value = (uint32_t) clear_value64;
   uint32_t clear_mask = (uint32_t) clear_mask64;
   const unsigned height = task->height;
   const unsigned width = task->width;
   const unsigned dst_stride = scene->zsbuf.stride;
a222 1
   unsigned block_size;
d228 5
a232 1
    * Clear the area of the depth/depth buffer matching this tile.
d235 24
a258 23
   if (scene->fb.zsbuf) {
      unsigned layer;
      uint8_t *dst_layer = lp_rast_get_unswizzled_depth_tile_pointer(task, LP_TEX_USAGE_READ_WRITE);
      block_size = util_format_get_blocksize(scene->fb.zsbuf->format);

      clear_value &= clear_mask;

      for (layer = 0; layer <= scene->fb_max_layer; layer++) {
         dst = dst_layer;

         switch (block_size) {
         case 1:
            assert(clear_mask == 0xff);
            memset(dst, (uint8_t) clear_value, height * width);
            break;
         case 2:
            if (clear_mask == 0xffff) {
               for (i = 0; i < height; i++) {
                  uint16_t *row = (uint16_t *)dst;
                  for (j = 0; j < width; j++)
                     *row++ = (uint16_t) clear_value;
                  dst += dst_stride;
               }
d260 19
a278 50
            else {
               for (i = 0; i < height; i++) {
                  uint16_t *row = (uint16_t *)dst;
                  for (j = 0; j < width; j++) {
                     uint16_t tmp = ~clear_mask & *row;
                     *row++ = clear_value | tmp;
                  }
                  dst += dst_stride;
               }
            }
            break;
         case 4:
            if (clear_mask == 0xffffffff) {
               for (i = 0; i < height; i++) {
                  uint32_t *row = (uint32_t *)dst;
                  for (j = 0; j < width; j++)
                     *row++ = clear_value;
                  dst += dst_stride;
               }
            }
            else {
               for (i = 0; i < height; i++) {
                  uint32_t *row = (uint32_t *)dst;
                  for (j = 0; j < width; j++) {
                     uint32_t tmp = ~clear_mask & *row;
                     *row++ = clear_value | tmp;
                  }
                  dst += dst_stride;
               }
            }
            break;
         case 8:
            clear_value64 &= clear_mask64;
            if (clear_mask64 == 0xffffffffffULL) {
               for (i = 0; i < height; i++) {
                  uint64_t *row = (uint64_t *)dst;
                  for (j = 0; j < width; j++)
                     *row++ = clear_value64;
                  dst += dst_stride;
               }
            }
            else {
               for (i = 0; i < height; i++) {
                  uint64_t *row = (uint64_t *)dst;
                  for (j = 0; j < width; j++) {
                     uint64_t tmp = ~clear_mask64 & *row;
                     *row++ = clear_value64 | tmp;
                  }
                  dst += dst_stride;
               }
d280 1
a280 5
            break;

         default:
            assert(0);
            break;
a281 1
         dst_layer += scene->zsbuf.layer_stride;
d283 38
d337 2
a338 2
   const struct lp_rast_state *state;
   struct lp_fragment_shader_variant *variant;
a348 7
   state = task->state;
   assert(state);
   if (!state) {
      return;
   }
   variant = state->variant;

d350 2
a351 2
   for (y = 0; y < task->height; y += 4){
      for (x = 0; x < task->width; x += 4) {
d353 1
a353 3
         unsigned stride[PIPE_MAX_COLOR_BUFS];
         uint8_t *depth = NULL;
         unsigned depth_stride = 0;
d357 3
a359 5
         for (i = 0; i < scene->fb.nr_cbufs; i++){
            stride[i] = scene->cbufs[i].stride;
            color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, tile_x + x,
                                                                  tile_y + y, inputs->layer);
         }
d362 1
a362 5
         if (scene->zsbuf.map) {
            depth = lp_rast_get_unswizzled_depth_block_pointer(task, tile_x + x,
                                                               tile_y + y, inputs->layer);
            depth_stride = scene->zsbuf.stride;
         }
d375 1
a375 3
                                            &task->thread_data,
                                            stride,
                                            depth_stride);
d391 3
d396 3
a398 3
   assert(task->state);
   if (!task->state) {
      return;
d421 1
a421 3
   unsigned stride[PIPE_MAX_COLOR_BUFS];
   uint8_t *depth = NULL;
   unsigned depth_stride = 0;
a426 2
   assert(x < scene->tiles_x * TILE_SIZE);
   assert(y < scene->tiles_y * TILE_SIZE);
d435 2
a436 2
      stride[i] = scene->cbufs[i].stride;
      color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, x, y, inputs->layer);
d440 2
a441 4
   if (scene->zsbuf.map) {
      depth_stride = scene->zsbuf.stride;
      depth = lp_rast_get_unswizzled_depth_block_pointer(task, x, y, inputs->layer);
   }
d443 1
a443 1
   assert(lp_check_alignment(state->jit_context.u8_blend_color, 16));
d445 13
a457 25
   /*
    * The rasterizer may produce fragments outside our
    * allocated 4x4 blocks hence need to filter them out here.
    */
   if ((x % TILE_SIZE) < task->width && (y % TILE_SIZE) < task->height) {
      /* not very accurate would need a popcount on the mask */
      /* always count this not worth bothering? */
      task->ps_invocations++;

      /* run shader on 4x4 block */
      BEGIN_JIT_CALL(state, task);
      variant->jit_function[RAST_EDGE_TEST](&state->jit_context,
                                            x, y,
                                            inputs->frontfacing,
                                            GET_A0(inputs),
                                            GET_DADX(inputs),
                                            GET_DADY(inputs),
                                            color,
                                            depth,
                                            mask,
                                            &task->thread_data,
                                            stride,
                                            depth_stride);
      END_JIT_CALL();
   }
d473 3
a475 12
   switch (pq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
   case PIPE_QUERY_OCCLUSION_PREDICATE:
      pq->start[task->thread_index] = task->thread_data.vis_counter;
      break;
   case PIPE_QUERY_PIPELINE_STATISTICS:
      pq->start[task->thread_index] = task->ps_invocations;
      break;
   default:
      assert(0);
      break;
   }
d488 4
a491 20
   struct llvmpipe_query *pq = arg.query_obj;

   switch (pq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
   case PIPE_QUERY_OCCLUSION_PREDICATE:
      pq->end[task->thread_index] +=
         task->thread_data.vis_counter - pq->start[task->thread_index];
      pq->start[task->thread_index] = 0;
      break;
   case PIPE_QUERY_TIMESTAMP:
      pq->end[task->thread_index] = os_time_get_nano();
      break;
   case PIPE_QUERY_PIPELINE_STATISTICS:
      pq->end[task->thread_index] +=
         task->ps_invocations - pq->start[task->thread_index];
      pq->start[task->thread_index] = 0;
      break;
   default:
      assert(0);
      break;
d506 53
d564 20
a583 1
   unsigned i;
d585 3
a587 2
   for (i = 0; i < task->scene->num_active_queries; ++i) {
      lp_rast_end_query(task, lp_rast_arg_query(task->scene->active_queries[i]));
d622 1
a622 2
                 const struct cmd_bin *bin,
                 int x, int y)
d628 1
a628 1
      lp_debug_bin(bin, x, y);
d647 1
a647 1
              const struct cmd_bin *bin, int x, int y )
d649 1
a649 1
   lp_rast_tile_begin( task, bin, x, y );
d651 1
a651 1
   do_rasterize_bin(task, bin, x, y);
d690 8
a697 11

   if (!task->rast->no_rast && !scene->discard) {
      /* loop over scene bins, rasterize each */
      {
         struct cmd_bin *bin;
         int i, j;

         assert(scene);
         while ((bin = lp_scene_bin_iter_next(scene, &i, &j))) {
            if (!is_empty_bin( bin ))
               rasterize_bin(task, bin, i, j);
d701 11
a711 1

d781 1
a781 1
static PIPE_THREAD_ROUTINE( thread_function, init_data )
a785 6
   unsigned fpstate = util_fpstate_get();

   /* Make sure that denorms are treated like zeros. This is 
    * the behavior required by D3D10. OpenGL doesn't care.
    */
   util_fpstate_set_denorms_to_zero(fpstate);
d849 1
a849 1
      rast->threads[i] = pipe_thread_create(thread_function,
d868 2
a869 3
   if (!rast) {
      goto no_rast;
   }
a871 3
   if (!rast->full_scenes) {
      goto no_full_scenes;
   }
a880 2
   rast->no_rast = debug_get_bool_option("LP_NO_RAST", FALSE);

d886 2
a890 5

no_full_scenes:
   FREE(rast);
no_rast:
   return NULL;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a37 1
#include "lp_context.h"
a120 7
   unsigned cbuf = arg.clear_rb->cbuf;
   union util_color uc;
   enum pipe_format format;

   /* we never bin clear commands for non-existing buffers */
   assert(cbuf < scene->fb.nr_cbufs);
   assert(scene->fb.cbufs[cbuf]);
d122 15
a136 2
   format = scene->fb.cbufs[cbuf]->format;
   uc = arg.clear_rb->color_val;
d138 26
a163 6
   /*
    * this is pretty rough since we have target format (bunch of bytes...) here.
    * dump it as raw 4 dwords.
    */
   LP_DBG(DEBUG_RAST, "%s clear value (target format %d) raw 0x%x,0x%x,0x%x,0x%x\n",
          __FUNCTION__, format, uc.ui[0], uc.ui[1], uc.ui[2], uc.ui[3]);
d165 3
d169 24
a192 11
   util_fill_box(scene->cbufs[cbuf].map,
                 format,
                 scene->cbufs[cbuf].stride,
                 scene->cbufs[cbuf].layer_stride,
                 task->x,
                 task->y,
                 0,
                 task->width,
                 task->height,
                 scene->fb_max_layer + 1,
                 &uc);
a193 1
   /* this will increase for each rb which probably doesn't mean much */
d198 2
d357 3
a359 9
            if (scene->fb.cbufs[i]) {
               stride[i] = scene->cbufs[i].stride;
               color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, tile_x + x,
                                                                     tile_y + y, inputs->layer);
            }
            else {
               stride[i] = 0;
               color[i] = NULL;
            }
a368 3
         /* Propagate non-interpolated raster state. */
         task->thread_data.raster_state.viewport_index = inputs->viewport_index;

d443 2
a444 9
      if (scene->fb.cbufs[i]) {
         stride[i] = scene->cbufs[i].stride;
         color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, x, y,
                                                               inputs->layer);
      }
      else {
         stride[i] = 0;
         color[i] = NULL;
      }
d462 1
a462 4
      task->ps_invocations += 1 * variant->ps_inv_multiplier;

      /* Propagate non-interpolated raster state. */
      task->thread_data.raster_state.viewport_index = inputs->viewport_index;
a590 11
   lp_rast_triangle_32_1,
   lp_rast_triangle_32_2,
   lp_rast_triangle_32_3,
   lp_rast_triangle_32_4,
   lp_rast_triangle_32_5,
   lp_rast_triangle_32_6,
   lp_rast_triangle_32_7,
   lp_rast_triangle_32_8,
   lp_rast_triangle_32_3_4,
   lp_rast_triangle_32_3_16,
   lp_rast_triangle_32_4_16
a699 6
      unsigned fpstate = util_fpstate_get();

      /* Make sure that denorms are treated like zeros. This is 
       * the behavior required by D3D10. OpenGL doesn't care.
       */
      util_fpstate_set_denorms_to_zero(fpstate);
a706 2
      util_fpstate_set(fpstate);

d807 1
a807 1
   return 0;
d909 8
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d188 1
a188 1
      uint8_t *dst_layer = lp_rast_get_depth_tile_pointer(task, LP_TEX_USAGE_READ_WRITE);
d317 2
a318 2
               color[i] = lp_rast_get_color_block_pointer(task, i, tile_x + x,
                                                          tile_y + y, inputs->layer);
d328 2
a329 2
            depth = lp_rast_get_depth_block_pointer(task, tile_x + x,
                                                    tile_y + y, inputs->layer);
d412 2
a413 2
         color[i] = lp_rast_get_color_block_pointer(task, i, x, y,
                                                    inputs->layer);
d424 1
a424 1
      depth = lp_rast_get_depth_block_pointer(task, x, y, inputs->layer);
a802 4
#ifdef _WIN32
   pipe_semaphore_signal(&task->work_done);
#endif

d888 1
a888 3
   /* Wait for threads to terminate before cleaning up per-thread data.
    * We don't actually call pipe_thread_wait to avoid dead lock on Windows
    * per https://bugs.freedesktop.org/show_bug.cgi?id=76252 */
a889 3
#ifdef _WIN32
      pipe_semaphore_wait(&rast->tasks[i].work_done);
#else
a890 1
#endif
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d188 1
a188 1
      uint8_t *dst_layer = lp_rast_get_unswizzled_depth_tile_pointer(task, LP_TEX_USAGE_READ_WRITE);
d317 2
a318 2
               color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, tile_x + x,
                                                                     tile_y + y, inputs->layer);
d328 2
a329 2
            depth = lp_rast_get_unswizzled_depth_block_pointer(task, tile_x + x,
                                                               tile_y + y, inputs->layer);
d412 2
a413 2
         color[i] = lp_rast_get_unswizzled_color_block_pointer(task, i, x, y,
                                                               inputs->layer);
d424 1
a424 1
      depth = lp_rast_get_unswizzled_depth_block_pointer(task, x, y, inputs->layer);
d803 4
d892 3
a894 1
   /* Wait for threads to terminate before cleaning up per-thread data */
d896 3
d900 1
@


