head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.33;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.26;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.57;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * Binner data structures and bin-related functions.
 * Note: the "setup" code is concerned with building scenes while
 * The "rast" code is concerned with consuming/executing scenes.
 */

#ifndef LP_SCENE_H
#define LP_SCENE_H

#include "os/os_thread.h"
#include "lp_rast.h"
#include "lp_debug.h"

struct lp_scene_queue;
struct lp_rast_state;

/* We're limited to 2K by 2K for 32bit fixed point rasterization.
 * Will need a 64-bit version for larger framebuffers.
 */
#define TILES_X (LP_MAX_WIDTH / TILE_SIZE)
#define TILES_Y (LP_MAX_HEIGHT / TILE_SIZE)


/* Commands per command block (ideally so sizeof(cmd_block) is a power of
 * two in size.)
 */
#define CMD_BLOCK_MAX 29

/* Bytes per data block.
 */
#define DATA_BLOCK_SIZE (64 * 1024)

/* Scene temporary storage is clamped to this size:
 */
#define LP_SCENE_MAX_SIZE (9*1024*1024)

/* The maximum amount of texture storage referenced by a scene is
 * clamped ot this size:
 */
#define LP_SCENE_MAX_RESOURCE_SIZE (64*1024*1024)


/* switch to a non-pointer value for this:
 */
typedef void (*lp_rast_cmd_func)( struct lp_rasterizer_task *,
                                  const union lp_rast_cmd_arg );

   
struct cmd_block {
   uint8_t cmd[CMD_BLOCK_MAX];
   union lp_rast_cmd_arg arg[CMD_BLOCK_MAX];
   unsigned count;
   struct cmd_block *next;
};


struct data_block {
   ubyte data[DATA_BLOCK_SIZE];
   unsigned used;
   struct data_block *next;
};



/**
 * For each screen tile we have one of these bins.
 */
struct cmd_bin {
   const struct lp_rast_state *last_state;       /* most recent state set in bin */
   struct cmd_block *head;
   struct cmd_block *tail;
};
   

/**
 * This stores bulk data which is used for all memory allocations
 * within a scene.
 *
 * Examples include triangle data and state data.  The commands in
 * the per-tile bins will point to chunks of data in this structure.
 *
 * Include the first block of data statically to ensure we can always
 * initiate a scene without relying on malloc succeeding.
 */
struct data_block_list {
   struct data_block first;
   struct data_block *head;
};

struct resource_ref;

/**
 * All bins and bin data are contained here.
 * Per-bin data goes into the 'tile' bins.
 * Shared data goes into the 'data' buffer.
 *
 * When there are multiple threads, will want to double-buffer between
 * scenes:
 */
struct lp_scene {
   struct pipe_context *pipe;
   struct lp_fence *fence;

   /* The queries still active at end of scene */
   struct llvmpipe_query *active_queries[LP_MAX_ACTIVE_BINNED_QUERIES];
   unsigned num_active_queries;
   /* If queries were either active or there were begin/end query commands */
   boolean had_queries;

   /* Framebuffer mappings - valid only between begin_rasterization()
    * and end_rasterization().
    */
   struct {
      uint8_t *map;
      unsigned stride;
      unsigned layer_stride;
   } zsbuf, cbufs[PIPE_MAX_COLOR_BUFS];

   /* The amount of layers in the fb (minimum of all attachments) */
   unsigned fb_max_layer;

   /** the framebuffer to render the scene into */
   struct pipe_framebuffer_state fb;

   /** list of resources referenced by the scene commands */
   struct resource_ref *resources;

   /** Total memory used by the scene (in bytes).  This sums all the
    * data blocks and counts all bins, state, resource references and
    * other random allocations within the scene.
    */
   unsigned scene_size;

   /** Sum of sizes of all resources referenced by the scene.  Sums
    * all the textures read by the scene:
    */
   unsigned resource_reference_size;

   boolean alloc_failed;
   boolean discard;
   /**
    * Number of active tiles in each dimension.
    * This basically the framebuffer size divided by tile size
    */
   unsigned tiles_x, tiles_y;

   int curr_x, curr_y;  /**< for iterating over bins */
   pipe_mutex mutex;

   struct cmd_bin tile[TILES_X][TILES_Y];
   struct data_block_list data;
};



struct lp_scene *lp_scene_create(struct pipe_context *pipe);

void lp_scene_destroy(struct lp_scene *scene);

boolean lp_scene_is_empty(struct lp_scene *scene );
boolean lp_scene_is_oom(struct lp_scene *scene );


struct data_block *lp_scene_new_data_block( struct lp_scene *scene );

struct cmd_block *lp_scene_new_cmd_block( struct lp_scene *scene,
                                          struct cmd_bin *bin );

boolean lp_scene_add_resource_reference(struct lp_scene *scene,
                                        struct pipe_resource *resource,
                                        boolean initializing_scene);

boolean lp_scene_is_resource_referenced(const struct lp_scene *scene,
                                        const struct pipe_resource *resource );


/**
 * Allocate space for a command/data in the bin's data buffer.
 * Grow the block list if needed.
 */
static INLINE void *
lp_scene_alloc( struct lp_scene *scene, unsigned size)
{
   struct data_block_list *list = &scene->data;
   struct data_block *block = list->head;

   assert(size <= DATA_BLOCK_SIZE);
   assert(block != NULL);

   if (LP_DEBUG & DEBUG_MEM)
      debug_printf("alloc %u block %u/%u tot %u/%u\n",
		   size, block->used, DATA_BLOCK_SIZE,
		   scene->scene_size, LP_SCENE_MAX_SIZE);

   if (block->used + size > DATA_BLOCK_SIZE) {
      block = lp_scene_new_data_block( scene );
      if (!block) {
         /* out of memory */
         return NULL;
      }
   }

   {
      ubyte *data = block->data + block->used;
      block->used += size;
      return data;
   }
}


/**
 * As above, but with specific alignment.
 */
static INLINE void *
lp_scene_alloc_aligned( struct lp_scene *scene, unsigned size,
			unsigned alignment )
{
   struct data_block_list *list = &scene->data;
   struct data_block *block = list->head;

   assert(block != NULL);

   if (LP_DEBUG & DEBUG_MEM)
      debug_printf("alloc %u block %u/%u tot %u/%u\n",
		   size + alignment - 1,
		   block->used, DATA_BLOCK_SIZE,
		   scene->scene_size, LP_SCENE_MAX_SIZE);
       
   if (block->used + size + alignment - 1 > DATA_BLOCK_SIZE) {
      block = lp_scene_new_data_block( scene );
      if (!block)
         return NULL;
   }

   {
      ubyte *data = block->data + block->used;
      unsigned offset = (((uintptr_t)data + alignment - 1) & ~(alignment - 1)) - (uintptr_t)data;
      block->used += offset + size;
      return data + offset;
   }
}


/* Put back data if we decide not to use it, eg. culled triangles.
 */
static INLINE void
lp_scene_putback_data( struct lp_scene *scene, unsigned size)
{
   struct data_block_list *list = &scene->data;
   assert(list->head && list->head->used >= size);
   list->head->used -= size;
}


/** Return pointer to a particular tile's bin. */
static INLINE struct cmd_bin *
lp_scene_get_bin(struct lp_scene *scene, unsigned x, unsigned y)
{
   return &scene->tile[x][y];
}


/** Remove all commands from a bin */
void
lp_scene_bin_reset(struct lp_scene *scene, unsigned x, unsigned y);


/* Add a command to bin[x][y].
 */
static INLINE boolean
lp_scene_bin_command( struct lp_scene *scene,
                      unsigned x, unsigned y,
                      unsigned cmd,
                      union lp_rast_cmd_arg arg )
{
   struct cmd_bin *bin = lp_scene_get_bin(scene, x, y);
   struct cmd_block *tail = bin->tail;

   assert(x < scene->tiles_x);
   assert(y < scene->tiles_y);
   assert(cmd < LP_RAST_OP_MAX);

   if (tail == NULL || tail->count == CMD_BLOCK_MAX) {
      tail = lp_scene_new_cmd_block( scene, bin );
      if (!tail) {
         return FALSE;
      }
      assert(tail->count == 0);
   }

   {
      unsigned i = tail->count;
      tail->cmd[i] = cmd & LP_RAST_OP_MASK;
      tail->arg[i] = arg;
      tail->count++;
   }
   
   return TRUE;
}


static INLINE boolean
lp_scene_bin_cmd_with_state( struct lp_scene *scene,
                             unsigned x, unsigned y,
                             const struct lp_rast_state *state,
                             unsigned cmd,
                             union lp_rast_cmd_arg arg )
{
   struct cmd_bin *bin = lp_scene_get_bin(scene, x, y);

   if (state != bin->last_state) {
      bin->last_state = state;
      if (!lp_scene_bin_command(scene, x, y,
                                LP_RAST_OP_SET_STATE,
                                lp_rast_arg_state(state)))
         return FALSE;
   }

   if (!lp_scene_bin_command( scene, x, y, cmd, arg ))
      return FALSE;

   return TRUE;
}


/* Add a command to all active bins.
 */
static INLINE boolean
lp_scene_bin_everywhere( struct lp_scene *scene,
			 unsigned cmd,
			 const union lp_rast_cmd_arg arg )
{
   unsigned i, j;
   for (i = 0; i < scene->tiles_x; i++) {
      for (j = 0; j < scene->tiles_y; j++) {
         if (!lp_scene_bin_command( scene, i, j, cmd, arg ))
            return FALSE;
      }
   }

   return TRUE;
}


static INLINE unsigned
lp_scene_get_num_bins( const struct lp_scene *scene )
{
   return scene->tiles_x * scene->tiles_y;
}


void
lp_scene_bin_iter_begin( struct lp_scene *scene );

struct cmd_bin *
lp_scene_bin_iter_next( struct lp_scene *scene, int *x, int *y );



/* Begin/end binning of a scene
 */
void
lp_scene_begin_binning( struct lp_scene *scene,
                        struct pipe_framebuffer_state *fb,
                        boolean discard );

void
lp_scene_end_binning( struct lp_scene *scene );


/* Begin/end rasterization of a scene
 */
void
lp_scene_begin_rasterization(struct lp_scene *scene);

void
lp_scene_end_rasterization(struct lp_scene *scene );





#endif /* LP_BIN_H */
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d147 1
a147 1
   /* OpenGL permits different amount of layers per rt, but rendering limited to minimum */
a167 1
   boolean has_depthstencil_clear;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a38 1
#include "lp_tile_soa.h"
d52 7
a58 1
#define CMD_BLOCK_MAX 128
d63 1
a63 1
#define LP_SCENE_MAX_SIZE (4*1024*1024)
a83 4
struct cmd_block_list {
   struct cmd_block *head;
   struct cmd_block *tail;
};
a96 2
   ushort x;
   ushort y;
d132 6
d144 1
a144 1
      unsigned blocksize;
d146 4
a149 1
   
d169 1
a169 1

d385 1
a385 1
lp_scene_bin_iter_next( struct lp_scene *scene );
d393 2
a394 1
                        struct pipe_framebuffer_state *fb );
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d41 1
d44 1
d49 2
a50 4
#define MAXHEIGHT 2048
#define MAXWIDTH 2048
#define TILES_X (MAXWIDTH / TILE_SIZE)
#define TILES_Y (MAXHEIGHT / TILE_SIZE)
d54 10
a63 2
#define DATA_BLOCK_SIZE (16 * 1024 - sizeof(unsigned) - sizeof(void *))
   
d68 2
a69 2
typedef void (*lp_rast_cmd)( struct lp_rasterizer_task *,
                             const union lp_rast_cmd_arg );
d71 1
d73 1
a73 1
   lp_rast_cmd cmd[CMD_BLOCK_MAX];
d79 5
d90 1
a90 4
struct cmd_block_list {
   struct cmd_block *head;
   struct cmd_block *tail;
};
d96 5
a100 1
   struct cmd_block_list commands;
d105 3
a107 1
 * This stores bulk data which is shared by all bins within a scene.
d110 3
d115 1
a116 8
   struct data_block *tail;
};


/** List of texture references */
struct texture_ref {
   struct pipe_texture *texture;
   struct texture_ref *prev, *next;  /**< linked list w/ u_simple_list.h */
d119 1
d131 1
a131 2
   struct pipe_transfer *cbuf_transfer[PIPE_MAX_COLOR_BUFS];
   struct pipe_transfer *zsbuf_transfer;
d133 2
a134 1
   /* Scene's buffers are mapped at the time the scene is enqueued:
d136 6
a141 3
   void *cbuf_map[PIPE_MAX_COLOR_BUFS];
   uint8_t *zsbuf_map;

d145 2
a146 2
   /** list of textures referenced by the scene commands */
   struct texture_ref textures;
d148 13
a160 1
   boolean write_depth;
a170 4
   /* Where to place this scene once it has been rasterized:
    */
   struct lp_scene_queue *empty_queue;

d177 1
a177 2
struct lp_scene *lp_scene_create(struct pipe_context *pipe,
                                 struct lp_scene_queue *empty_queue);
a180 2


d182 1
a183 4
void lp_scene_reset(struct lp_scene *scene );


void lp_bin_new_data_block( struct data_block_list *list );
d185 1
a185 1
void lp_bin_new_cmd_block( struct cmd_block_list *list );
d187 2
a188 1
unsigned lp_scene_data_size( const struct lp_scene *scene );
d190 3
a192 1
unsigned lp_scene_bin_size( const struct lp_scene *scene, unsigned x, unsigned y );
d194 2
a195 5
void lp_scene_texture_reference( struct lp_scene *scene,
                                 struct pipe_texture *texture );

boolean lp_scene_is_texture_referenced( const struct lp_scene *scene,
                                        const struct pipe_texture *texture );
d206 4
d211 11
a221 2
   if (list->tail->used + size > DATA_BLOCK_SIZE) {
      lp_bin_new_data_block( list );
d225 2
a226 3
      struct data_block *tail = list->tail;
      ubyte *data = tail->data + tail->used;
      tail->used += size;
d240 3
d244 10
a253 2
   if (list->tail->used + size + alignment - 1 > DATA_BLOCK_SIZE) {
      lp_bin_new_data_block( list );
d257 1
a257 2
      struct data_block *tail = list->tail;
      ubyte *data = tail->data + tail->used;
d259 1
a259 1
      tail->used += offset + size;
d271 2
a272 2
   assert(list->tail->used >= size);
   list->tail->used -= size;
d291 1
a291 1
static INLINE void
d293 3
a295 3
                unsigned x, unsigned y,
                lp_rast_cmd cmd,
                union lp_rast_cmd_arg arg )
d298 1
a298 1
   struct cmd_block_list *list = &bin->commands;
d302 1
d304 6
a309 2
   if (list->tail->count == CMD_BLOCK_MAX) {
      lp_bin_new_cmd_block( list );
a312 1
      struct cmd_block *tail = list->tail;
d314 1
a314 1
      tail->cmd[i] = cmd;
d318 26
d349 1
a349 1
static INLINE void
d351 1
a351 1
			 lp_rast_cmd cmd,
d355 8
a362 3
   for (i = 0; i < scene->tiles_x; i++)
      for (j = 0; j < scene->tiles_y; j++)
         lp_scene_bin_command( scene, i, j, cmd, arg );
a365 6
void
lp_scene_bin_state_command( struct lp_scene *scene,
			    lp_rast_cmd cmd,
			    const union lp_rast_cmd_arg arg );


d377 2
a378 1
lp_scene_bin_iter_next( struct lp_scene *scene, int *bin_x, int *bin_y );
a379 4
void
lp_scene_rasterize( struct lp_scene *scene,
                    struct lp_rasterizer *rast,
                    boolean write_depth );
d381 2
d386 16
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a40 1
#include "lp_debug.h"
a42 1
struct lp_rast_state;
d47 4
a50 2
#define TILES_X (LP_MAX_WIDTH / TILE_SIZE)
#define TILES_Y (LP_MAX_HEIGHT / TILE_SIZE)
d54 2
a55 10
#define DATA_BLOCK_SIZE (64 * 1024)

/* Scene temporary storage is clamped to this size:
 */
#define LP_SCENE_MAX_SIZE (4*1024*1024)

/* The maximum amount of texture storage referenced by a scene is
 * clamped ot this size:
 */
#define LP_SCENE_MAX_RESOURCE_SIZE (64*1024*1024)
d60 2
a61 2
typedef void (*lp_rast_cmd_func)( struct lp_rasterizer_task *,
                                  const union lp_rast_cmd_arg );
a62 1
   
d64 1
a64 1
   uint8_t cmd[CMD_BLOCK_MAX];
a69 5
struct cmd_block_list {
   struct cmd_block *head;
   struct cmd_block *tail;
};

d76 4
a79 1

d85 1
a85 5
   ushort x;
   ushort y;
   const struct lp_rast_state *last_state;       /* most recent state set in bin */
   struct cmd_block *head;
   struct cmd_block *tail;
d90 1
a90 3
 * This stores bulk data which is used for all memory allocations
 * within a scene.
 *
a92 3
 *
 * Include the first block of data statically to ensure we can always
 * initiate a scene without relying on malloc succeeding.
a94 1
   struct data_block first;
d96 8
a105 1
struct resource_ref;
d117 2
a118 1
   struct lp_fence *fence;
d120 1
a120 2
   /* Framebuffer mappings - valid only between begin_rasterization()
    * and end_rasterization().
d122 3
a124 6
   struct {
      uint8_t *map;
      unsigned stride;
      unsigned blocksize;
   } zsbuf, cbufs[PIPE_MAX_COLOR_BUFS];
   
d128 2
a129 2
   /** list of resources referenced by the scene commands */
   struct resource_ref *resources;
d131 1
a131 13
   /** Total memory used by the scene (in bytes).  This sums all the
    * data blocks and counts all bins, state, resource references and
    * other random allocations within the scene.
    */
   unsigned scene_size;

   /** Sum of sizes of all resources referenced by the scene.  Sums
    * all the textures read by the scene:
    */
   unsigned resource_reference_size;

   boolean alloc_failed;
   boolean has_depthstencil_clear;
d142 4
d152 2
a153 1
struct lp_scene *lp_scene_create(struct pipe_context *pipe);
d157 2
a159 1
boolean lp_scene_is_oom(struct lp_scene *scene );
d161 4
d166 1
a166 1
struct data_block *lp_scene_new_data_block( struct lp_scene *scene );
d168 1
a168 2
struct cmd_block *lp_scene_new_cmd_block( struct lp_scene *scene,
                                          struct cmd_bin *bin );
d170 1
a170 3
boolean lp_scene_add_resource_reference(struct lp_scene *scene,
                                        struct pipe_resource *resource,
                                        boolean initializing_scene);
d172 5
a176 2
boolean lp_scene_is_resource_referenced(const struct lp_scene *scene,
                                        const struct pipe_resource *resource );
a186 4
   struct data_block *block = list->head;

   assert(size <= DATA_BLOCK_SIZE);
   assert(block != NULL);
d188 2
a189 11
   if (LP_DEBUG & DEBUG_MEM)
      debug_printf("alloc %u block %u/%u tot %u/%u\n",
		   size, block->used, DATA_BLOCK_SIZE,
		   scene->scene_size, LP_SCENE_MAX_SIZE);

   if (block->used + size > DATA_BLOCK_SIZE) {
      block = lp_scene_new_data_block( scene );
      if (!block) {
         /* out of memory */
         return NULL;
      }
d193 3
a195 2
      ubyte *data = block->data + block->used;
      block->used += size;
a208 3
   struct data_block *block = list->head;

   assert(block != NULL);
d210 2
a211 10
   if (LP_DEBUG & DEBUG_MEM)
      debug_printf("alloc %u block %u/%u tot %u/%u\n",
		   size + alignment - 1,
		   block->used, DATA_BLOCK_SIZE,
		   scene->scene_size, LP_SCENE_MAX_SIZE);
       
   if (block->used + size + alignment - 1 > DATA_BLOCK_SIZE) {
      block = lp_scene_new_data_block( scene );
      if (!block)
         return NULL;
d215 2
a216 1
      ubyte *data = block->data + block->used;
d218 1
a218 1
      block->used += offset + size;
d230 2
a231 2
   assert(list->head && list->head->used >= size);
   list->head->used -= size;
d250 1
a250 1
static INLINE boolean
d252 3
a254 3
                      unsigned x, unsigned y,
                      unsigned cmd,
                      union lp_rast_cmd_arg arg )
d257 1
a257 1
   struct cmd_block *tail = bin->tail;
a260 1
   assert(cmd < LP_RAST_OP_MAX);
d262 2
a263 6
   if (tail == NULL || tail->count == CMD_BLOCK_MAX) {
      tail = lp_scene_new_cmd_block( scene, bin );
      if (!tail) {
         return FALSE;
      }
      assert(tail->count == 0);
d267 1
d269 1
a269 1
      tail->cmd[i] = cmd & LP_RAST_OP_MASK;
a272 26
   
   return TRUE;
}


static INLINE boolean
lp_scene_bin_cmd_with_state( struct lp_scene *scene,
                             unsigned x, unsigned y,
                             const struct lp_rast_state *state,
                             unsigned cmd,
                             union lp_rast_cmd_arg arg )
{
   struct cmd_bin *bin = lp_scene_get_bin(scene, x, y);

   if (state != bin->last_state) {
      bin->last_state = state;
      if (!lp_scene_bin_command(scene, x, y,
                                LP_RAST_OP_SET_STATE,
                                lp_rast_arg_state(state)))
         return FALSE;
   }

   if (!lp_scene_bin_command( scene, x, y, cmd, arg ))
      return FALSE;

   return TRUE;
d278 1
a278 1
static INLINE boolean
d280 1
a280 1
			 unsigned cmd,
d284 5
a288 6
   for (i = 0; i < scene->tiles_x; i++) {
      for (j = 0; j < scene->tiles_y; j++) {
         if (!lp_scene_bin_command( scene, i, j, cmd, arg ))
            return FALSE;
      }
   }
d290 4
a293 2
   return TRUE;
}
d307 1
a307 1
lp_scene_bin_iter_next( struct lp_scene *scene );
d309 4
a313 3

/* Begin/end binning of a scene
 */
a316 16

void
lp_scene_end_binning( struct lp_scene *scene );


/* Begin/end rasterization of a scene
 */
void
lp_scene_begin_rasterization(struct lp_scene *scene);

void
lp_scene_end_rasterization(struct lp_scene *scene );




@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d39 1
d53 1
a53 7
/* Commands per command block (ideally so sizeof(cmd_block) is a power of
 * two in size.)
 */
#define CMD_BLOCK_MAX 29

/* Bytes per data block.
 */
d58 1
a58 1
#define LP_SCENE_MAX_SIZE (9*1024*1024)
d79 4
d96 2
a132 6
   /* The queries still active at end of scene */
   struct llvmpipe_query *active_queries[LP_MAX_ACTIVE_BINNED_QUERIES];
   unsigned num_active_queries;
   /* If queries were either active or there were begin/end query commands */
   boolean had_queries;

d139 1
a139 1
      unsigned layer_stride;
d141 1
a141 4

   /* OpenGL permits different amount of layers per rt, but rendering limited to minimum */
   unsigned fb_max_layer;

d161 1
a161 1
   boolean discard;
d377 1
a377 1
lp_scene_bin_iter_next( struct lp_scene *scene, int *x, int *y );
d385 1
a385 2
                        struct pipe_framebuffer_state *fb,
                        boolean discard );
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d147 1
a147 1
   /* The amount of layers in the fb (minimum of all attachments) */
d168 1
@


