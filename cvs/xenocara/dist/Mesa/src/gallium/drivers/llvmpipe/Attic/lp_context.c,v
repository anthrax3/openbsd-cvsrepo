head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.32;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.25;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.57;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.26;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.34;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * Copyright 2008 VMware, Inc.  All rights reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/* Author:
 *    Keith Whitwell <keithw@@vmware.com>
 */

#include "draw/draw_context.h"
#include "draw/draw_vbuf.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_simple_list.h"
#include "lp_clear.h"
#include "lp_context.h"
#include "lp_flush.h"
#include "lp_perf.h"
#include "lp_state.h"
#include "lp_surface.h"
#include "lp_query.h"
#include "lp_setup.h"


/** shared by all contexts */
unsigned llvmpipe_variant_count;


static void llvmpipe_destroy( struct pipe_context *pipe )
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context( pipe );
   uint i, j;

   lp_print_counters();

   if (llvmpipe->blitter) {
      util_blitter_destroy(llvmpipe->blitter);
   }

   /* This will also destroy llvmpipe->setup:
    */
   if (llvmpipe->draw)
      draw_destroy( llvmpipe->draw );

   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
      pipe_surface_reference(&llvmpipe->framebuffer.cbufs[i], NULL);
   }

   pipe_surface_reference(&llvmpipe->framebuffer.zsbuf, NULL);

   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_FRAGMENT][i], NULL);
   }

   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_VERTEX][i], NULL);
   }

   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_GEOMETRY][i], NULL);
   }

   for (i = 0; i < Elements(llvmpipe->constants); i++) {
      for (j = 0; j < Elements(llvmpipe->constants[i]); j++) {
         pipe_resource_reference(&llvmpipe->constants[i][j].buffer, NULL);
      }
   }

   for (i = 0; i < llvmpipe->num_vertex_buffers; i++) {
      pipe_resource_reference(&llvmpipe->vertex_buffer[i].buffer, NULL);
   }

   lp_delete_setup_variants(llvmpipe);

   align_free( llvmpipe );
}

static void
do_flush( struct pipe_context *pipe,
          struct pipe_fence_handle **fence,
          unsigned flags)
{
   llvmpipe_flush(pipe, fence, __FUNCTION__);
}


static void
llvmpipe_render_condition ( struct pipe_context *pipe,
                            struct pipe_query *query,
                            boolean condition,
                            uint mode )
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context( pipe );

   llvmpipe->render_cond_query = query;
   llvmpipe->render_cond_mode = mode;
   llvmpipe->render_cond_cond = condition;
}

struct pipe_context *
llvmpipe_create_context( struct pipe_screen *screen, void *priv )
{
   struct llvmpipe_context *llvmpipe;

   llvmpipe = align_malloc(sizeof(struct llvmpipe_context), 16);
   if (!llvmpipe)
      return NULL;

   util_init_math();

   memset(llvmpipe, 0, sizeof *llvmpipe);

   make_empty_list(&llvmpipe->fs_variants_list);

   make_empty_list(&llvmpipe->setup_variants_list);


   llvmpipe->pipe.screen = screen;
   llvmpipe->pipe.priv = priv;

   /* Init the pipe context methods */
   llvmpipe->pipe.destroy = llvmpipe_destroy;
   llvmpipe->pipe.set_framebuffer_state = llvmpipe_set_framebuffer_state;
   llvmpipe->pipe.clear = llvmpipe_clear;
   llvmpipe->pipe.flush = do_flush;

   llvmpipe->pipe.render_condition = llvmpipe_render_condition;

   llvmpipe_init_blend_funcs(llvmpipe);
   llvmpipe_init_clip_funcs(llvmpipe);
   llvmpipe_init_draw_funcs(llvmpipe);
   llvmpipe_init_sampler_funcs(llvmpipe);
   llvmpipe_init_query_funcs( llvmpipe );
   llvmpipe_init_vertex_funcs(llvmpipe);
   llvmpipe_init_so_funcs(llvmpipe);
   llvmpipe_init_fs_funcs(llvmpipe);
   llvmpipe_init_vs_funcs(llvmpipe);
   llvmpipe_init_gs_funcs(llvmpipe);
   llvmpipe_init_rasterizer_funcs(llvmpipe);
   llvmpipe_init_context_resource_funcs( &llvmpipe->pipe );
   llvmpipe_init_surface_functions(llvmpipe);

   /*
    * Create drawing context and plug our rendering stage into it.
    */
   llvmpipe->draw = draw_create(&llvmpipe->pipe);
   if (!llvmpipe->draw)
      goto fail;

   /* FIXME: devise alternative to draw_texture_samplers */

   llvmpipe->setup = lp_setup_create( &llvmpipe->pipe,
                                      llvmpipe->draw );
   if (!llvmpipe->setup)
      goto fail;

   llvmpipe->blitter = util_blitter_create(&llvmpipe->pipe);
   if (!llvmpipe->blitter) {
      goto fail;
   }

   /* must be done before installing Draw stages */
   util_blitter_cache_all_shaders(llvmpipe->blitter);

   /* plug in AA line/point stages */
   draw_install_aaline_stage(llvmpipe->draw, &llvmpipe->pipe);
   draw_install_aapoint_stage(llvmpipe->draw, &llvmpipe->pipe);
   draw_install_pstipple_stage(llvmpipe->draw, &llvmpipe->pipe);

   /* convert points and lines into triangles: 
    * (otherwise, draw points and lines natively)
    */
   draw_wide_point_sprites(llvmpipe->draw, FALSE);
   draw_enable_point_sprites(llvmpipe->draw, FALSE);
   draw_wide_point_threshold(llvmpipe->draw, 10000.0);
   draw_wide_line_threshold(llvmpipe->draw, 10000.0);

   lp_reset_counters();

   return &llvmpipe->pipe;

 fail:
   llvmpipe_destroy(&llvmpipe->pipe);
   return NULL;
}

@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d50 4
a99 3
   LLVMContextDispose(llvmpipe->context);
   llvmpipe->context = NULL;

a167 4
   llvmpipe->context = LLVMContextCreate();
   if (!llvmpipe->context)
      goto fail;

d171 1
a171 2
   llvmpipe->draw = draw_create_with_llvm_context(&llvmpipe->pipe,
                                                  llvmpipe->context);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a49 4
/** shared by all contexts */
unsigned llvmpipe_variant_count;


d96 3
d167 4
d174 2
a175 1
   llvmpipe->draw = draw_create(&llvmpipe->pipe);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d22 1
a22 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a49 3
DEBUG_GET_ONCE_BOOL_OPTION(lp_no_rast, "LP_NO_RAST", FALSE)


a53 36
/**
 * This function is called by the gallivm "garbage collector" when
 * the LLVM global data structures are freed.  We must free all LLVM-related
 * data.  Specifically, all JIT'd shader variants.
 */
static void
garbage_collect_callback(void *cb_data)
{
   struct llvmpipe_context *lp = (struct llvmpipe_context *) cb_data;
   struct lp_fs_variant_list_item *li;

   /* Free all the context's shader variants */
   li = first_elem(&lp->fs_variants_list);
   while (!at_end(&lp->fs_variants_list, li)) {
      struct lp_fs_variant_list_item *next = next_elem(li);
      llvmpipe_remove_shader_variant(lp, li->base);
      li = next;
   }

   /* Free all the context's primitive setup variants */
   lp_delete_setup_variants(lp);

   /* release references to setup variants, shaders */
   lp_setup_set_setup_variant(lp->setup, NULL);
   lp_setup_set_fs_variant(lp->setup, NULL);
   lp_setup_reset(lp->setup);

   /* This type will be recreated upon demand */
   lp->jit_context_ptr_type = NULL;

   /* mark all state as dirty to ensure new shaders are jit'd, etc. */
   lp->dirty = ~0;
}



d61 3
a63 2
   gallivm_remove_garbage_collector_callback(garbage_collect_callback,
                                             llvmpipe);
d76 2
a77 2
   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
      pipe_sampler_view_reference(&llvmpipe->fragment_sampler_views[i], NULL);
d80 6
a85 2
   for (i = 0; i < PIPE_MAX_VERTEX_SAMPLERS; i++) {
      pipe_sampler_view_reference(&llvmpipe->vertex_sampler_views[i], NULL);
d90 1
a90 1
         pipe_resource_reference(&llvmpipe->constants[i][j], NULL);
d98 1
a98 1
   gallivm_destroy(llvmpipe->gallivm);
d105 2
a106 1
          struct pipe_fence_handle **fence)
d112 13
a142 1
   llvmpipe->pipe.winsys = screen->winsys;
d152 2
a167 2
   llvmpipe->gallivm = gallivm_create();

d171 1
a171 1
   llvmpipe->draw = draw_create_gallivm(&llvmpipe->pipe, llvmpipe->gallivm);
a176 3
   if (debug_get_option_lp_no_rast())
      llvmpipe->no_rast = TRUE;

d182 8
a202 5
#if USE_DRAW_STAGE_PSTIPPLE
   /* Do polygon stipple w/ texture map + frag prog? */
   draw_install_pstipple_stage(llvmpipe->draw, &llvmpipe->pipe);
#endif

a203 3

   gallivm_register_garbage_collector_callback(garbage_collect_callback,
                                               llvmpipe);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d128 4
a138 1
          unsigned flags,
d141 1
a141 1
   llvmpipe_flush(pipe, flags, fence, __FUNCTION__);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 1
d50 40
d96 1
a96 1
   uint i;
d100 3
d115 1
a115 1
      pipe_texture_reference(&llvmpipe->texture[i], NULL);
d119 1
a119 1
      pipe_texture_reference(&llvmpipe->vertex_textures[i], NULL);
d123 2
a124 2
      if (llvmpipe->constants[i]) {
         pipe_buffer_reference(&llvmpipe->constants[i], NULL);
d128 2
d133 4
a136 4
static unsigned int
llvmpipe_is_texture_referenced( struct pipe_context *pipe,
				struct pipe_texture *texture,
				unsigned face, unsigned level)
d138 1
a138 3
   struct llvmpipe_context *llvmpipe = llvmpipe_context( pipe );

   return lp_setup_is_texture_referenced(llvmpipe->setup, texture);
a140 6
static unsigned int
llvmpipe_is_buffer_referenced( struct pipe_context *pipe,
			       struct pipe_buffer *buf)
{
   return PIPE_UNREFERENCED;
}
d155 5
d163 2
a165 31

   /* state setters */
   llvmpipe->pipe.create_blend_state = llvmpipe_create_blend_state;
   llvmpipe->pipe.bind_blend_state   = llvmpipe_bind_blend_state;
   llvmpipe->pipe.delete_blend_state = llvmpipe_delete_blend_state;

   llvmpipe->pipe.create_sampler_state = llvmpipe_create_sampler_state;
   llvmpipe->pipe.bind_fragment_sampler_states  = llvmpipe_bind_sampler_states;
   llvmpipe->pipe.bind_vertex_sampler_states  = llvmpipe_bind_vertex_sampler_states;
   llvmpipe->pipe.delete_sampler_state = llvmpipe_delete_sampler_state;

   llvmpipe->pipe.create_depth_stencil_alpha_state = llvmpipe_create_depth_stencil_state;
   llvmpipe->pipe.bind_depth_stencil_alpha_state   = llvmpipe_bind_depth_stencil_state;
   llvmpipe->pipe.delete_depth_stencil_alpha_state = llvmpipe_delete_depth_stencil_state;

   llvmpipe->pipe.create_rasterizer_state = llvmpipe_create_rasterizer_state;
   llvmpipe->pipe.bind_rasterizer_state   = llvmpipe_bind_rasterizer_state;
   llvmpipe->pipe.delete_rasterizer_state = llvmpipe_delete_rasterizer_state;

   llvmpipe->pipe.create_fs_state = llvmpipe_create_fs_state;
   llvmpipe->pipe.bind_fs_state   = llvmpipe_bind_fs_state;
   llvmpipe->pipe.delete_fs_state = llvmpipe_delete_fs_state;

   llvmpipe->pipe.create_vs_state = llvmpipe_create_vs_state;
   llvmpipe->pipe.bind_vs_state   = llvmpipe_bind_vs_state;
   llvmpipe->pipe.delete_vs_state = llvmpipe_delete_vs_state;

   llvmpipe->pipe.set_blend_color = llvmpipe_set_blend_color;
   llvmpipe->pipe.set_stencil_ref = llvmpipe_set_stencil_ref;
   llvmpipe->pipe.set_clip_state = llvmpipe_set_clip_state;
   llvmpipe->pipe.set_constant_buffer = llvmpipe_set_constant_buffer;
a166 13
   llvmpipe->pipe.set_polygon_stipple = llvmpipe_set_polygon_stipple;
   llvmpipe->pipe.set_scissor_state = llvmpipe_set_scissor_state;
   llvmpipe->pipe.set_fragment_sampler_textures = llvmpipe_set_sampler_textures;
   llvmpipe->pipe.set_vertex_sampler_textures = llvmpipe_set_vertex_sampler_textures;
   llvmpipe->pipe.set_viewport_state = llvmpipe_set_viewport_state;

   llvmpipe->pipe.set_vertex_buffers = llvmpipe_set_vertex_buffers;
   llvmpipe->pipe.set_vertex_elements = llvmpipe_set_vertex_elements;

   llvmpipe->pipe.draw_arrays = llvmpipe_draw_arrays;
   llvmpipe->pipe.draw_elements = llvmpipe_draw_elements;
   llvmpipe->pipe.draw_range_elements = llvmpipe_draw_range_elements;

d168 1
a168 1
   llvmpipe->pipe.flush = llvmpipe_flush;
d170 13
a182 2
   llvmpipe->pipe.is_texture_referenced = llvmpipe_is_texture_referenced;
   llvmpipe->pipe.is_buffer_referenced = llvmpipe_is_buffer_referenced;
d184 1
a184 1
   llvmpipe_init_query_funcs( llvmpipe );
d189 2
a190 2
   llvmpipe->draw = draw_create(&llvmpipe->pipe);
   if (!llvmpipe->draw) 
d195 1
a195 1
   if (debug_get_bool_option( "LP_NO_RAST", FALSE ))
d206 9
d221 1
a221 1
   lp_init_surface_functions(llvmpipe);
d223 2
a224 1
   lp_reset_counters();
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a38 1
#include "util/u_simple_list.h"
a48 40
DEBUG_GET_ONCE_BOOL_OPTION(lp_no_rast, "LP_NO_RAST", FALSE)


/** shared by all contexts */
unsigned llvmpipe_variant_count;


/**
 * This function is called by the gallivm "garbage collector" when
 * the LLVM global data structures are freed.  We must free all LLVM-related
 * data.  Specifically, all JIT'd shader variants.
 */
static void
garbage_collect_callback(void *cb_data)
{
   struct llvmpipe_context *lp = (struct llvmpipe_context *) cb_data;
   struct lp_fs_variant_list_item *li;

   /* Free all the context's shader variants */
   li = first_elem(&lp->fs_variants_list);
   while (!at_end(&lp->fs_variants_list, li)) {
      struct lp_fs_variant_list_item *next = next_elem(li);
      llvmpipe_remove_shader_variant(lp, li->base);
      li = next;
   }

   /* Free all the context's primitive setup variants */
   lp_delete_setup_variants(lp);

   /* release references to setup variants, shaders */
   lp_setup_set_setup_variant(lp->setup, NULL);
   lp_setup_set_fs_variant(lp->setup, NULL);
   lp_setup_reset(lp->setup);

   /* This type will be recreated upon demand */
   lp->jit_context_ptr_type = NULL;

   /* mark all state as dirty to ensure new shaders are jit'd, etc. */
   lp->dirty = ~0;
}
d55 1
a55 1
   uint i, j;
a58 3
   gallivm_remove_garbage_collector_callback(garbage_collect_callback,
                                             llvmpipe);

d71 1
a71 1
      pipe_sampler_view_reference(&llvmpipe->fragment_sampler_views[i], NULL);
d75 1
a75 1
      pipe_sampler_view_reference(&llvmpipe->vertex_sampler_views[i], NULL);
d79 2
a80 2
      for (j = 0; j < Elements(llvmpipe->constants[i]); j++) {
         pipe_resource_reference(&llvmpipe->constants[i][j], NULL);
a83 2
   gallivm_destroy(llvmpipe->gallivm);

d87 4
a90 4
static void
do_flush( struct pipe_context *pipe,
          unsigned flags,
          struct pipe_fence_handle **fence)
d92 3
a94 1
   llvmpipe_flush(pipe, flags, fence, __FUNCTION__);
d97 6
a116 5
   make_empty_list(&llvmpipe->fs_variants_list);

   make_empty_list(&llvmpipe->setup_variants_list);


d120 1
d122 30
a151 2
   /* Init the pipe context methods */
   llvmpipe->pipe.destroy = llvmpipe_destroy;
d153 13
d167 4
a170 1
   llvmpipe->pipe.flush = do_flush;
a171 4
   llvmpipe_init_blend_funcs(llvmpipe);
   llvmpipe_init_clip_funcs(llvmpipe);
   llvmpipe_init_draw_funcs(llvmpipe);
   llvmpipe_init_sampler_funcs(llvmpipe);
a172 10
   llvmpipe_init_vertex_funcs(llvmpipe);
   llvmpipe_init_so_funcs(llvmpipe);
   llvmpipe_init_fs_funcs(llvmpipe);
   llvmpipe_init_vs_funcs(llvmpipe);
   llvmpipe_init_gs_funcs(llvmpipe);
   llvmpipe_init_rasterizer_funcs(llvmpipe);
   llvmpipe_init_context_resource_funcs( &llvmpipe->pipe );
   llvmpipe_init_surface_functions(llvmpipe);

   llvmpipe->gallivm = gallivm_create();
d177 2
a178 2
   llvmpipe->draw = draw_create_gallivm(&llvmpipe->pipe, llvmpipe->gallivm);
   if (!llvmpipe->draw)
d183 1
a183 1
   if (debug_get_option_lp_no_rast())
a193 9
   draw_install_pstipple_stage(llvmpipe->draw, &llvmpipe->pipe);

   /* convert points and lines into triangles: 
    * (otherwise, draw points and lines natively)
    */
   draw_wide_point_sprites(llvmpipe->draw, FALSE);
   draw_enable_point_sprites(llvmpipe->draw, FALSE);
   draw_wide_point_threshold(llvmpipe->draw, 10000.0);
   draw_wide_line_threshold(llvmpipe->draw, 10000.0);
d200 2
a202 3

   gallivm_register_garbage_collector_callback(garbage_collect_callback,
                                               llvmpipe);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d50 3
d57 36
d100 2
a101 3
   if (llvmpipe->blitter) {
      util_blitter_destroy(llvmpipe->blitter);
   }
d114 2
a115 2
   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_FRAGMENT][i], NULL);
d118 2
a119 6
   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_VERTEX][i], NULL);
   }

   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_GEOMETRY][i], NULL);
d124 1
a124 1
         pipe_resource_reference(&llvmpipe->constants[i][j].buffer, NULL);
d128 1
a128 5
   for (i = 0; i < llvmpipe->num_vertex_buffers; i++) {
      pipe_resource_reference(&llvmpipe->vertex_buffer[i].buffer, NULL);
   }

   lp_delete_setup_variants(llvmpipe);
d135 2
a136 2
          struct pipe_fence_handle **fence,
          unsigned flags)
d138 1
a138 1
   llvmpipe_flush(pipe, fence, __FUNCTION__);
a141 13
static void
llvmpipe_render_condition ( struct pipe_context *pipe,
                            struct pipe_query *query,
                            boolean condition,
                            uint mode )
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context( pipe );

   llvmpipe->render_cond_query = query;
   llvmpipe->render_cond_mode = mode;
   llvmpipe->render_cond_cond = condition;
}

d160 1
a169 2
   llvmpipe->pipe.render_condition = llvmpipe_render_condition;

d184 2
d189 1
a189 1
   llvmpipe->draw = draw_create(&llvmpipe->pipe);
d195 3
a202 8
   llvmpipe->blitter = util_blitter_create(&llvmpipe->pipe);
   if (!llvmpipe->blitter) {
      goto fail;
   }

   /* must be done before installing Draw stages */
   util_blitter_cache_all_shaders(llvmpipe->blitter);

d216 5
d222 3
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
 *    Keith Whitwell <keithw@@vmware.com>
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d50 4
a99 3
   LLVMContextDispose(llvmpipe->context);
   llvmpipe->context = NULL;

a167 4
   llvmpipe->context = LLVMContextCreate();
   if (!llvmpipe->context)
      goto fail;

d171 1
a171 2
   llvmpipe->draw = draw_create_with_llvm_context(&llvmpipe->pipe,
                                                  llvmpipe->context);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a49 4
/** shared by all contexts */
unsigned llvmpipe_variant_count;


d96 3
d167 4
d174 2
a175 1
   llvmpipe->draw = draw_create(&llvmpipe->pipe);
@


