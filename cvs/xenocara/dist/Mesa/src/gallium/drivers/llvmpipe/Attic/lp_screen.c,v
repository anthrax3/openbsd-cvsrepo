head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.22.09.30.33;	author jsg;	state Exp;
branches;
next	1.7;
commitid	yhStanAcs6cSYmBc;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.33;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.28;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.36;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


#include "util/u_memory.h"
#include "util/u_math.h"
#include "util/u_cpu_detect.h"
#include "util/u_format.h"
#include "util/u_string.h"
#include "util/u_format_s3tc.h"
#include "pipe/p_defines.h"
#include "pipe/p_screen.h"
#include "draw/draw_context.h"
#include "gallivm/lp_bld_type.h"

#include "os/os_misc.h"
#include "os/os_time.h"
#include "lp_texture.h"
#include "lp_fence.h"
#include "lp_jit.h"
#include "lp_screen.h"
#include "lp_context.h"
#include "lp_debug.h"
#include "lp_public.h"
#include "lp_limits.h"
#include "lp_rast.h"

#include "state_tracker/sw_winsys.h"

#ifdef DEBUG
int LP_DEBUG = 0;

static const struct debug_named_value lp_debug_flags[] = {
   { "pipe",   DEBUG_PIPE, NULL },
   { "tgsi",   DEBUG_TGSI, NULL },
   { "tex",    DEBUG_TEX, NULL },
   { "setup",  DEBUG_SETUP, NULL },
   { "rast",   DEBUG_RAST, NULL },
   { "query",  DEBUG_QUERY, NULL },
   { "screen", DEBUG_SCREEN, NULL },
   { "counters", DEBUG_COUNTERS, NULL },
   { "scene", DEBUG_SCENE, NULL },
   { "fence", DEBUG_FENCE, NULL },
   { "mem", DEBUG_MEM, NULL },
   { "fs", DEBUG_FS, NULL },
   DEBUG_NAMED_VALUE_END
};
#endif

int LP_PERF = 0;
static const struct debug_named_value lp_perf_flags[] = {
   { "texmem",         PERF_TEX_MEM, NULL },
   { "no_mipmap",      PERF_NO_MIPMAPS, NULL },
   { "no_linear",      PERF_NO_LINEAR, NULL },
   { "no_mip_linear",  PERF_NO_MIP_LINEAR, NULL },
   { "no_tex",         PERF_NO_TEX, NULL },
   { "no_blend",       PERF_NO_BLEND, NULL },
   { "no_depth",       PERF_NO_DEPTH, NULL },
   { "no_alphatest",   PERF_NO_ALPHATEST, NULL },
   DEBUG_NAMED_VALUE_END
};


static const char *
llvmpipe_get_vendor(struct pipe_screen *screen)
{
   return "VMware, Inc.";
}


static const char *
llvmpipe_get_name(struct pipe_screen *screen)
{
   static char buf[100];
   util_snprintf(buf, sizeof(buf), "llvmpipe (LLVM %u.%u, %u bits)",
		 HAVE_LLVM >> 8, HAVE_LLVM & 0xff,
		 lp_native_vector_width );
   return buf;
}


static int
llvmpipe_get_param(struct pipe_screen *screen, enum pipe_cap param)
{
   switch (param) {
   case PIPE_CAP_NPOT_TEXTURES:
   case PIPE_CAP_MIXED_FRAMEBUFFER_SIZES:
      return 1;
   case PIPE_CAP_TWO_SIDED_STENCIL:
      return 1;
   case PIPE_CAP_SM3:
      return 1;
   case PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS:
      return 1;
   case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
      return PIPE_MAX_SO_BUFFERS;
   case PIPE_CAP_ANISOTROPIC_FILTER:
      return 0;
   case PIPE_CAP_POINT_SPRITE:
      return 1;
   case PIPE_CAP_MAX_RENDER_TARGETS:
      return PIPE_MAX_COLOR_BUFS;
   case PIPE_CAP_OCCLUSION_QUERY:
      return 1;
   case PIPE_CAP_QUERY_TIME_ELAPSED:
      return 0;
   case PIPE_CAP_QUERY_TIMESTAMP:
      return 1;
   case PIPE_CAP_QUERY_PIPELINE_STATISTICS:
      return 0;
   case PIPE_CAP_TEXTURE_MIRROR_CLAMP:
      return 1;
   case PIPE_CAP_TEXTURE_SHADOW_MAP:
      return 1;
   case PIPE_CAP_TEXTURE_SWIZZLE:
      return 1;
   case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
      return 0;
   case PIPE_CAP_MAX_TEXTURE_2D_LEVELS:
      return LP_MAX_TEXTURE_2D_LEVELS;
   case PIPE_CAP_MAX_TEXTURE_3D_LEVELS:
      return LP_MAX_TEXTURE_3D_LEVELS;
   case PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS:
      return LP_MAX_TEXTURE_CUBE_LEVELS;
   case PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS:
      return LP_MAX_TEXTURE_ARRAY_LAYERS;
   case PIPE_CAP_BLEND_EQUATION_SEPARATE:
      return 1;
   case PIPE_CAP_INDEP_BLEND_ENABLE:
      return 1;
   case PIPE_CAP_INDEP_BLEND_FUNC:
      return 1;
   case PIPE_CAP_TGSI_FS_COORD_ORIGIN_UPPER_LEFT:
   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
      return 1;
   case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
      return 0;
   case PIPE_CAP_PRIMITIVE_RESTART:
      return 1;
   case PIPE_CAP_DEPTH_CLIP_DISABLE:
      return 1;
   case PIPE_CAP_SHADER_STENCIL_EXPORT:
      return 0;
   case PIPE_CAP_TGSI_INSTANCEID:
   case PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR:
      return 1;
   case PIPE_CAP_FRAGMENT_COLOR_CLAMPED:
      return 0;
   case PIPE_CAP_MIXED_COLORBUFFER_FORMATS:
      return 1;
   case PIPE_CAP_SEAMLESS_CUBE_MAP:
   case PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE:
      return 1;
   /* this is a lie could support arbitrary large offsets */
   case PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET:
   case PIPE_CAP_MIN_TEXEL_OFFSET:
      return -8;
   case PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET:
   case PIPE_CAP_MAX_TEXEL_OFFSET:
      return 7;
   case PIPE_CAP_CONDITIONAL_RENDER:
      return 1;
   case PIPE_CAP_TEXTURE_BARRIER:
      return 0;
   case PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS:
   case PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS:
      return 16*4;
   case PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES:
   case PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS:
      return 1024;
   case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
      return 1;
   case PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS:
      return 0;
   case PIPE_CAP_VERTEX_COLOR_UNCLAMPED:
   case PIPE_CAP_VERTEX_COLOR_CLAMPED:
      return 1;
   case PIPE_CAP_GLSL_FEATURE_LEVEL:
      return 330;
   case PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION:
      return 0;
   case PIPE_CAP_COMPUTE:
      return 0;
   case PIPE_CAP_USER_VERTEX_BUFFERS:
   case PIPE_CAP_USER_INDEX_BUFFERS:
      return 1;
   case PIPE_CAP_USER_CONSTANT_BUFFERS:
      return 0;
   case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_TGSI_TEXCOORD:
      return 0;

   case PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT:
      return 16;
   case PIPE_CAP_START_INSTANCE:
   case PIPE_CAP_TEXTURE_MULTISAMPLE:
   case PIPE_CAP_CUBE_MAP_ARRAY:
      return 0;
   case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
      return 64;
   case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
      return 1;
   case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
      return 65536;
   case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
      return 1;
   case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
      return 0;
   case PIPE_CAP_MAX_VIEWPORTS:
      return PIPE_MAX_VIEWPORTS;
   case PIPE_CAP_ENDIANNESS:
      return PIPE_ENDIAN_NATIVE;
   case PIPE_CAP_TGSI_VS_LAYER:
   case PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS:
   case PIPE_CAP_TEXTURE_GATHER_SM5:
   case PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT:
   case PIPE_CAP_TEXTURE_QUERY_LOD:
   case PIPE_CAP_SAMPLE_SHADING:
      return 0;
   case PIPE_CAP_FAKE_SW_MSAA:
	return 1;

   case PIPE_CAP_VENDOR_ID:
      return 0xFFFFFFFF;
   case PIPE_CAP_DEVICE_ID:
      return 0xFFFFFFFF;
   case PIPE_CAP_ACCELERATED:
      return 0;
   case PIPE_CAP_VIDEO_MEMORY: {
      /* XXX: Do we want to return the full amount fo system memory ? */
      uint64_t system_memory;

      if (!os_get_total_physical_memory(&system_memory))
         return 0;

      return (int)(system_memory >> 20);
   }
   case PIPE_CAP_UMA:
      return 0;
   }
   /* should only get here on unhandled cases */
   debug_printf("Unexpected PIPE_CAP %d query\n", param);
   return 0;
}

static int
llvmpipe_get_shader_param(struct pipe_screen *screen, unsigned shader, enum pipe_shader_cap param)
{
   switch(shader)
   {
   case PIPE_SHADER_FRAGMENT:
      switch (param) {
      default:
         return gallivm_get_shader_param(param);
      }
   case PIPE_SHADER_VERTEX:
   case PIPE_SHADER_GEOMETRY:
      switch (param) {
      case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
         /* At this time, the draw module and llvmpipe driver only
          * support vertex shader texture lookups when LLVM is enabled in
          * the draw module.
          */
         if (debug_get_bool_option("DRAW_USE_LLVM", TRUE))
            return PIPE_MAX_SAMPLERS;
         else
            return 0;
      case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
         if (debug_get_bool_option("DRAW_USE_LLVM", TRUE))
            return PIPE_MAX_SHADER_SAMPLER_VIEWS;
         else
            return 0;
      default:
         return draw_get_shader_param(shader, param);
      }
   default:
      return 0;
   }
}

static float
llvmpipe_get_paramf(struct pipe_screen *screen, enum pipe_capf param)
{
   switch (param) {
   case PIPE_CAPF_MAX_LINE_WIDTH:
      /* fall-through */
   case PIPE_CAPF_MAX_LINE_WIDTH_AA:
      return 255.0; /* arbitrary */
   case PIPE_CAPF_MAX_POINT_WIDTH:
      /* fall-through */
   case PIPE_CAPF_MAX_POINT_WIDTH_AA:
      return 255.0; /* arbitrary */
   case PIPE_CAPF_MAX_TEXTURE_ANISOTROPY:
      return 16.0; /* not actually signficant at this time */
   case PIPE_CAPF_MAX_TEXTURE_LOD_BIAS:
      return 16.0; /* arbitrary */
   case PIPE_CAPF_GUARD_BAND_LEFT:
   case PIPE_CAPF_GUARD_BAND_TOP:
   case PIPE_CAPF_GUARD_BAND_RIGHT:
   case PIPE_CAPF_GUARD_BAND_BOTTOM:
      return 0.0;
   }
   /* should only get here on unhandled cases */
   debug_printf("Unexpected PIPE_CAP %d query\n", param);
   return 0.0;
}


/**
 * Query format support for creating a texture, drawing surface, etc.
 * \param format  the format to test
 * \param type  one of PIPE_TEXTURE, PIPE_SURFACE
 */
static boolean
llvmpipe_is_format_supported( struct pipe_screen *_screen,
                              enum pipe_format format,
                              enum pipe_texture_target target,
                              unsigned sample_count,
                              unsigned bind)
{
   struct llvmpipe_screen *screen = llvmpipe_screen(_screen);
   struct sw_winsys *winsys = screen->winsys;
   const struct util_format_description *format_desc;

   format_desc = util_format_description(format);
   if (!format_desc)
      return FALSE;

   assert(target == PIPE_BUFFER ||
          target == PIPE_TEXTURE_1D ||
          target == PIPE_TEXTURE_1D_ARRAY ||
          target == PIPE_TEXTURE_2D ||
          target == PIPE_TEXTURE_2D_ARRAY ||
          target == PIPE_TEXTURE_RECT ||
          target == PIPE_TEXTURE_3D ||
          target == PIPE_TEXTURE_CUBE);

   if (sample_count > 1)
      return FALSE;

   if (bind & PIPE_BIND_RENDER_TARGET) {
      if (format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
         /* this is a lie actually other formats COULD exist where we would fail */
         if (format_desc->nr_channels < 3)
            return FALSE;
      }
      else if (format_desc->colorspace != UTIL_FORMAT_COLORSPACE_RGB)
         return FALSE;

      if (format_desc->layout != UTIL_FORMAT_LAYOUT_PLAIN &&
          format != PIPE_FORMAT_R11G11B10_FLOAT)
         return FALSE;

      assert(format_desc->block.width == 1);
      assert(format_desc->block.height == 1);

      if (format_desc->is_mixed)
         return FALSE;

      if (!format_desc->is_array && !format_desc->is_bitmask &&
          format != PIPE_FORMAT_R11G11B10_FLOAT)
         return FALSE;

      /*
       * XXX refuse formats known to crash in generate_unswizzled_blend().
       * These include all 3-channel 24bit RGB8 variants, plus 48bit
       * (except those using floats) 3-channel RGB16 variants (the latter
       * seems to be more of a llvm bug though).
       * The mesa state tracker only seems to use these for SINT/UINT formats.
       */
      if (format_desc->is_array && format_desc->nr_channels == 3) {
         if (format_desc->block.bits == 24 || (format_desc->block.bits == 48 &&
               !util_format_is_float(format))) {
            return FALSE;
         }
      }
   }

   if (bind & PIPE_BIND_DISPLAY_TARGET) {
      if(!winsys->is_displaytarget_format_supported(winsys, bind, format))
         return FALSE;
   }

   if (bind & PIPE_BIND_DEPTH_STENCIL) {
      if (format_desc->layout != UTIL_FORMAT_LAYOUT_PLAIN)
         return FALSE;

      if (format_desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS)
         return FALSE;

      /* TODO: Support stencil-only formats */
      if (format_desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_NONE) {
         return FALSE;
      }
   }

   if (format_desc->layout == UTIL_FORMAT_LAYOUT_S3TC) {
      return util_format_s3tc_enabled;
   }

   /*
    * Everything can be supported by u_format
    * (those without fetch_rgba_float might be not but shouldn't hit that)
    */

   return TRUE;
}




static void
llvmpipe_flush_frontbuffer(struct pipe_screen *_screen,
                           struct pipe_resource *resource,
                           unsigned level, unsigned layer,
                           void *context_private,
                           struct pipe_box *sub_box)
{
   struct llvmpipe_screen *screen = llvmpipe_screen(_screen);
   struct sw_winsys *winsys = screen->winsys;
   struct llvmpipe_resource *texture = llvmpipe_resource(resource);

   assert(texture->dt);
   if (texture->dt)
      winsys->displaytarget_display(winsys, texture->dt, context_private, sub_box);
}

static void
llvmpipe_destroy_screen( struct pipe_screen *_screen )
{
   struct llvmpipe_screen *screen = llvmpipe_screen(_screen);
   struct sw_winsys *winsys = screen->winsys;

   if (screen->rast)
      lp_rast_destroy(screen->rast);

   lp_jit_screen_cleanup(screen);

   if(winsys->destroy)
      winsys->destroy(winsys);

   pipe_mutex_destroy(screen->rast_mutex);

   FREE(screen);
}




/**
 * Fence reference counting.
 */
static void
llvmpipe_fence_reference(struct pipe_screen *screen,
                         struct pipe_fence_handle **ptr,
                         struct pipe_fence_handle *fence)
{
   struct lp_fence **old = (struct lp_fence **) ptr;
   struct lp_fence *f = (struct lp_fence *) fence;

   lp_fence_reference(old, f);
}


/**
 * Has the fence been executed/finished?
 */
static boolean
llvmpipe_fence_signalled(struct pipe_screen *screen,
                         struct pipe_fence_handle *fence)
{
   struct lp_fence *f = (struct lp_fence *) fence;
   return lp_fence_signalled(f);
}


/**
 * Wait for the fence to finish.
 */
static boolean
llvmpipe_fence_finish(struct pipe_screen *screen,
                      struct pipe_fence_handle *fence_handle,
                      uint64_t timeout)
{
   struct lp_fence *f = (struct lp_fence *) fence_handle;

   lp_fence_wait(f);
   return TRUE;
}

static uint64_t
llvmpipe_get_timestamp(struct pipe_screen *_screen)
{
   return os_time_get_nano();
}

/**
 * Create a new pipe_screen object
 * Note: we're not presently subclassing pipe_screen (no llvmpipe_screen).
 */
struct pipe_screen *
llvmpipe_create_screen(struct sw_winsys *winsys)
{
   struct llvmpipe_screen *screen;

   util_cpu_detect();

#if defined(PIPE_ARCH_X86) && HAVE_LLVM < 0x0302
   /* require SSE2 due to LLVM PR6960. */
   if (!util_cpu_caps.has_sse2)
       return NULL;
#endif

#ifdef DEBUG
   LP_DEBUG = debug_get_flags_option("LP_DEBUG", lp_debug_flags, 0 );
#endif

   LP_PERF = debug_get_flags_option("LP_PERF", lp_perf_flags, 0 );

   screen = CALLOC_STRUCT(llvmpipe_screen);
   if (!screen)
      return NULL;

   screen->winsys = winsys;

   screen->base.destroy = llvmpipe_destroy_screen;

   screen->base.get_name = llvmpipe_get_name;
   screen->base.get_vendor = llvmpipe_get_vendor;
   screen->base.get_param = llvmpipe_get_param;
   screen->base.get_shader_param = llvmpipe_get_shader_param;
   screen->base.get_paramf = llvmpipe_get_paramf;
   screen->base.is_format_supported = llvmpipe_is_format_supported;

   screen->base.context_create = llvmpipe_create_context;
   screen->base.flush_frontbuffer = llvmpipe_flush_frontbuffer;
   screen->base.fence_reference = llvmpipe_fence_reference;
   screen->base.fence_signalled = llvmpipe_fence_signalled;
   screen->base.fence_finish = llvmpipe_fence_finish;

   screen->base.get_timestamp = llvmpipe_get_timestamp;

   llvmpipe_init_screen_resource_funcs(&screen->base);

   lp_jit_screen_init(screen);

   screen->num_threads = util_cpu_caps.nr_cpus > 1 ? util_cpu_caps.nr_cpus : 0;
#ifdef PIPE_SUBSYSTEM_EMBEDDED
   screen->num_threads = 0;
#endif
   screen->num_threads = debug_get_num_option("LP_NUM_THREADS", screen->num_threads);
   screen->num_threads = MIN2(screen->num_threads, LP_MAX_THREADS);

   screen->rast = lp_rast_create(screen->num_threads);
   if (!screen->rast) {
      lp_jit_screen_cleanup(screen);
      FREE(screen);
      return NULL;
   }
   pipe_mutex_init(screen->rast_mutex);

   util_format_s3tc_init();

   return &screen->base;
}
@


1.8
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.7
log
@Merge Mesa 10.2.9
@
text
@d40 1
d249 18
@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a39 1
#include "os/os_misc.h"
a169 1
   case PIPE_CAP_START_INSTANCE:
a194 4
   case PIPE_CAP_MAX_VERTEX_STREAMS:
      return 1;
   case PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE:
      return 2048;
a217 2
   case PIPE_CAP_DRAW_INDIRECT:
      return 1;
a218 2
   case PIPE_CAP_CUBE_MAP_ARRAY:
      return 1;
d221 1
d223 1
d239 1
a239 1
   case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
a244 4
   case PIPE_CAP_TEXTURE_GATHER_OFFSETS:
   case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
   case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
   case PIPE_CAP_SAMPLER_VIEW_TARGET:
d247 1
a247 23
      return 1;
   case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
      return 1;

   case PIPE_CAP_VENDOR_ID:
      return 0xFFFFFFFF;
   case PIPE_CAP_DEVICE_ID:
      return 0xFFFFFFFF;
   case PIPE_CAP_ACCELERATED:
      return 0;
   case PIPE_CAP_VIDEO_MEMORY: {
      /* XXX: Do we want to return the full amount fo system memory ? */
      uint64_t system_memory;

      if (!os_get_total_physical_memory(&system_memory))
         return 0;

      return (int)(system_memory >> 20);
   }
   case PIPE_CAP_UMA:
      return 0;
   case PIPE_CAP_CLIP_HALFZ:
      return 1;
d344 1
a344 2
          target == PIPE_TEXTURE_CUBE ||
          target == PIPE_TEXTURE_CUBE_ARRAY);
a404 5
   if (format_desc->layout == UTIL_FORMAT_LAYOUT_BPTC) {
      /* Software decoding is not hooked up. */
      return FALSE;
   }

d516 6
a531 5
   if (!lp_jit_screen_init(screen)) {
      FREE(screen);
      return NULL;
   }

d552 2
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d40 1
d171 1
d197 4
d224 2
d227 2
a230 1
   case PIPE_CAP_START_INSTANCE:
a231 1
   case PIPE_CAP_CUBE_MAP_ARRAY:
d247 1
a247 1
   case PIPE_CAP_TGSI_VS_LAYER:
d253 4
d259 23
a281 1
	return 1;
d378 2
a379 1
          target == PIPE_TEXTURE_CUBE);
d440 5
a555 6
#if defined(PIPE_ARCH_X86) && HAVE_LLVM < 0x0302
   /* require SSE2 due to LLVM PR6960. */
   if (!util_cpu_caps.has_sse2)
       return NULL;
#endif

d566 5
a590 2

   lp_jit_screen_init(screen);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
a108 2
   case PIPE_CAP_MAX_COMBINED_SAMPLERS:
      return 2 * PIPE_MAX_SAMPLERS;  /* VS + FS samplers */
d110 1
d165 1
a165 1
      return 0;
d177 1
a177 3
      return 0;
   case PIPE_CAP_SCALED_RESOLVE:
      return 0;
d179 1
d182 1
d192 3
d203 1
a203 1
      return 140;
a222 1
   case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
d225 2
d239 9
d276 5
d351 1
d424 2
a425 1
                           void *context_private)
d433 1
a433 1
      winsys->displaytarget_display(winsys, texture->dt, context_private);
a434 1

@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d33 1
d38 1
d40 1
a63 2
   { "show_tiles",    DEBUG_SHOW_TILES, NULL },
   { "show_subtiles", DEBUG_SHOW_SUBTILES, NULL },
d97 5
a101 1
   return "llvmpipe";
a108 11
   case PIPE_CAP_MAX_TEXTURE_IMAGE_UNITS:
      return PIPE_MAX_SAMPLERS;
   case PIPE_CAP_MAX_VERTEX_TEXTURE_UNITS:
      /* At this time, the draw module and llvmpipe driver only
       * support vertex shader texture lookups when LLVM is enabled in
       * the draw module.
       */
      if (debug_get_bool_option("DRAW_USE_LLVM", TRUE))
         return PIPE_MAX_VERTEX_SAMPLERS;
      else
         return 0;
d110 1
a110 1
      return PIPE_MAX_SAMPLERS + PIPE_MAX_VERTEX_SAMPLERS;
d115 1
a115 1
   case PIPE_CAP_GLSL:
d117 1
a117 1
   case PIPE_CAP_SM3:
d119 2
d129 5
a133 1
   case PIPE_CAP_TIMER_QUERY:
a136 2
   case PIPE_CAP_TEXTURE_MIRROR_REPEAT:
      return 1;
d141 2
d148 3
a150 1
      return LP_MAX_TEXTURE_2D_LEVELS;
d159 1
a161 1
   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
d165 3
a167 3
   case PIPE_CAP_DEPTHSTENCIL_CLEAR_SEPARATE:
      return 1;
   case PIPE_CAP_DEPTH_CLAMP:
d171 3
d176 55
a230 1
   default:
d232 4
d237 3
d248 4
a251 1
      return tgsi_exec_get_shader_param(param);
d254 13
a266 1
      return draw_get_shader_param(shader, param);
d273 1
a273 1
llvmpipe_get_paramf(struct pipe_screen *screen, enum pipe_cap param)
d276 1
a276 1
   case PIPE_CAP_MAX_LINE_WIDTH:
d278 1
a278 1
   case PIPE_CAP_MAX_LINE_WIDTH_AA:
d280 1
a280 1
   case PIPE_CAP_MAX_POINT_WIDTH:
d282 1
a282 1
   case PIPE_CAP_MAX_POINT_WIDTH_AA:
d284 1
a284 1
   case PIPE_CAP_MAX_TEXTURE_ANISOTROPY:
d286 1
a286 1
   case PIPE_CAP_MAX_TEXTURE_LOD_BIAS:
d288 4
a291 4
   case PIPE_CAP_GUARD_BAND_LEFT:
   case PIPE_CAP_GUARD_BAND_TOP:
   case PIPE_CAP_GUARD_BAND_RIGHT:
   case PIPE_CAP_GUARD_BAND_BOTTOM:
a292 3
   default:
      assert(0);
      return 0;
d294 3
d322 1
d324 1
d333 5
a337 1
      if (format_desc->colorspace == UTIL_FORMAT_COLORSPACE_ZS)
d340 8
a347 1
      if (format_desc->layout != UTIL_FORMAT_LAYOUT_PLAIN)
d350 2
a351 2
      if (format_desc->block.width != 1 ||
          format_desc->block.height != 1)
d353 14
d381 2
a382 2
      /* FIXME: Temporary restriction. See lp_state_fs.c. */
      if (format_desc->block.bits != 32)
d384 1
a390 5
   /* u_format doesn't support RGTC yet */
   if (format_desc->layout == UTIL_FORMAT_LAYOUT_RGTC) {
      return FALSE;
   }

d392 2
a393 1
    * Everything else should be supported by u_format.
d395 1
d481 5
a485 1

d496 3
a498 1
#ifdef PIPE_ARCH_X86
a499 1
   util_cpu_detect();
a503 2
   screen = CALLOC_STRUCT(llvmpipe_screen);

d510 1
d530 2
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d154 1
a154 1
      return 0;
d167 4
d229 1
a229 2
                              unsigned bind,
                              unsigned geom_flags )
d282 5
d352 1
a352 1
static int
d354 1
a354 2
                         struct pipe_fence_handle *fence,
                         unsigned flag)
d364 1
a364 1
static int
d367 1
a367 1
                      unsigned flag)
d372 1
a372 1
   return 0;
d426 1
a426 1
#ifdef PIPE_OS_EMBEDDED
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d30 2
d33 1
d36 1
a38 1
#include "lp_buffer.h"
a39 1
#include "lp_winsys.h"
d44 5
d54 15
a68 14
   { "pipe",   DEBUG_PIPE },
   { "tgsi",   DEBUG_TGSI },
   { "tex",    DEBUG_TEX },
   { "asm",    DEBUG_ASM },
   { "setup",  DEBUG_SETUP },
   { "rast",   DEBUG_RAST },
   { "query",  DEBUG_QUERY },
   { "screen", DEBUG_SCREEN },
   { "jit",    DEBUG_JIT },
   { "show_tiles",    DEBUG_SHOW_TILES },
   { "show_subtiles", DEBUG_SHOW_SUBTILES },
   { "counters", DEBUG_COUNTERS },
   { "nopt", DEBUG_NO_LLVM_OPT },
   {NULL, 0}
d72 13
d101 1
a101 1
llvmpipe_get_param(struct pipe_screen *screen, int param)
d107 8
a114 1
      return 0;
d123 2
d133 2
d141 2
d144 1
a144 1
      return 13; /* max 4Kx4K */
d146 1
a146 1
      return 9;  /* max 256x256x256 */
d148 1
a148 3
      return 13; /* max 4Kx4K */
   case PIPE_CAP_TGSI_CONT_SUPPORTED:
      return 1;
d152 1
a152 1
      return 0;
d161 6
d172 14
d188 1
a188 1
llvmpipe_get_paramf(struct pipe_screen *screen, int param)
d203 5
d209 1
d222 1
a222 1
                              enum pipe_format format, 
d224 2
a225 1
                              unsigned tex_usage, 
d229 1
a229 1
   struct llvmpipe_winsys *winsys = screen->winsys;
d233 1
a233 1
   if(!format_desc)
d236 2
a237 1
   assert(target == PIPE_TEXTURE_1D ||
d239 1
d243 1
a243 5
   switch(format) {
   case PIPE_FORMAT_DXT1_RGB:
   case PIPE_FORMAT_DXT1_RGBA:
   case PIPE_FORMAT_DXT3_RGBA:
   case PIPE_FORMAT_DXT5_RGBA:
a244 3
   default:
      break;
   }
d246 2
a247 3
   if(tex_usage & PIPE_TEXTURE_USAGE_RENDER_TARGET) {
      if(format_desc->block.width != 1 ||
         format_desc->block.height != 1)
d250 1
a250 1
      if(format_desc->layout != UTIL_FORMAT_LAYOUT_PLAIN)
d253 2
a254 2
      if(format_desc->colorspace != UTIL_FORMAT_COLORSPACE_RGB &&
         format_desc->colorspace != UTIL_FORMAT_COLORSPACE_SRGB)
d258 2
a259 2
   if(tex_usage & PIPE_TEXTURE_USAGE_DISPLAY_TARGET) {
      if(!winsys->is_displaytarget_format_supported(winsys, format))
d263 5
a267 2
   if(tex_usage & PIPE_TEXTURE_USAGE_DEPTH_STENCIL) {
      if(format_desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS)
d271 1
a271 1
      if(format_desc->block.bits != 32)
d275 2
a276 16
   /* FIXME: Temporary restrictions. See lp_bld_sample_soa.c */
   if(tex_usage & PIPE_TEXTURE_USAGE_SAMPLER) {
      if(format_desc->block.width != 1 ||
         format_desc->block.height != 1)
         return FALSE;

      if(format_desc->layout != UTIL_FORMAT_LAYOUT_PLAIN)
         return FALSE;

      if(format_desc->colorspace != UTIL_FORMAT_COLORSPACE_RGB &&
         format_desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS)
         return FALSE;

      /* not supported yet */
      if (format == PIPE_FORMAT_Z16_UNORM)
         return FALSE;
d279 3
a285 12
static struct pipe_buffer *
llvmpipe_surface_buffer_create(struct pipe_screen *screen,
                               unsigned width, unsigned height,
                               enum pipe_format format,
                               unsigned tex_usage,
                               unsigned usage,
                               unsigned *stride)
{
   /* This function should never be used */
   assert(0);
   return NULL;
}
d290 2
a291 1
                           struct pipe_surface *surface,
d295 2
a296 2
   struct llvmpipe_winsys *winsys = screen->winsys;
   struct llvmpipe_texture *texture = llvmpipe_texture(surface->texture);
d308 4
a311 1
   struct llvmpipe_winsys *winsys = screen->winsys;
d318 2
d325 45
d375 1
a375 1
llvmpipe_create_screen(struct llvmpipe_winsys *winsys)
d377 10
a386 1
   struct llvmpipe_screen *screen = CALLOC_STRUCT(llvmpipe_screen);
d392 2
d404 1
a407 1
   screen->base.surface_buffer_create = llvmpipe_surface_buffer_create;
d410 3
d414 1
a414 3
   llvmpipe_init_screen_texture_funcs(&screen->base);
   llvmpipe_init_screen_buffer_funcs(&screen->base);
   llvmpipe_init_screen_fence_funcs(&screen->base);
d417 17
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a29 2
#include "util/u_math.h"
#include "util/u_cpu_detect.h"
a30 1
#include "util/u_format_s3tc.h"
a32 1
#include "draw/draw_context.h"
d35 1
d37 1
a41 5
#include "lp_public.h"
#include "lp_limits.h"
#include "lp_rast.h"

#include "state_tracker/sw_winsys.h"
d47 14
a60 15
   { "pipe",   DEBUG_PIPE, NULL },
   { "tgsi",   DEBUG_TGSI, NULL },
   { "tex",    DEBUG_TEX, NULL },
   { "setup",  DEBUG_SETUP, NULL },
   { "rast",   DEBUG_RAST, NULL },
   { "query",  DEBUG_QUERY, NULL },
   { "screen", DEBUG_SCREEN, NULL },
   { "show_tiles",    DEBUG_SHOW_TILES, NULL },
   { "show_subtiles", DEBUG_SHOW_SUBTILES, NULL },
   { "counters", DEBUG_COUNTERS, NULL },
   { "scene", DEBUG_SCENE, NULL },
   { "fence", DEBUG_FENCE, NULL },
   { "mem", DEBUG_MEM, NULL },
   { "fs", DEBUG_FS, NULL },
   DEBUG_NAMED_VALUE_END
a63 13
int LP_PERF = 0;
static const struct debug_named_value lp_perf_flags[] = {
   { "texmem",         PERF_TEX_MEM, NULL },
   { "no_mipmap",      PERF_NO_MIPMAPS, NULL },
   { "no_linear",      PERF_NO_LINEAR, NULL },
   { "no_mip_linear",  PERF_NO_MIP_LINEAR, NULL },
   { "no_tex",         PERF_NO_TEX, NULL },
   { "no_blend",       PERF_NO_BLEND, NULL },
   { "no_depth",       PERF_NO_DEPTH, NULL },
   { "no_alphatest",   PERF_NO_ALPHATEST, NULL },
   DEBUG_NAMED_VALUE_END
};

d80 1
a80 1
llvmpipe_get_param(struct pipe_screen *screen, enum pipe_cap param)
d86 1
a86 8
      /* At this time, the draw module and llvmpipe driver only
       * support vertex shader texture lookups when LLVM is enabled in
       * the draw module.
       */
      if (debug_get_bool_option("DRAW_USE_LLVM", TRUE))
         return PIPE_MAX_VERTEX_SAMPLERS;
      else
         return 0;
a94 2
   case PIPE_CAP_SM3:
      return 1;
a102 2
   case PIPE_CAP_TIMER_QUERY:
      return 0;
a108 2
   case PIPE_CAP_TEXTURE_SWIZZLE:
      return 1;
d110 1
a110 1
      return LP_MAX_TEXTURE_2D_LEVELS;
d112 1
a112 1
      return LP_MAX_TEXTURE_3D_LEVELS;
d114 3
a116 1
      return LP_MAX_TEXTURE_2D_LEVELS;
d120 1
a120 1
      return 1;
a128 6
   case PIPE_CAP_PRIMITIVE_RESTART:
      return 1;
   case PIPE_CAP_DEPTHSTENCIL_CLEAR_SEPARATE:
      return 1;
   case PIPE_CAP_DEPTH_CLAMP:
      return 0;
a133 14
static int
llvmpipe_get_shader_param(struct pipe_screen *screen, unsigned shader, enum pipe_shader_cap param)
{
   switch(shader)
   {
   case PIPE_SHADER_FRAGMENT:
      return tgsi_exec_get_shader_param(param);
   case PIPE_SHADER_VERTEX:
   case PIPE_SHADER_GEOMETRY:
      return draw_get_shader_param(shader, param);
   default:
      return 0;
   }
}
d136 1
a136 1
llvmpipe_get_paramf(struct pipe_screen *screen, enum pipe_cap param)
a150 5
   case PIPE_CAP_GUARD_BAND_LEFT:
   case PIPE_CAP_GUARD_BAND_TOP:
   case PIPE_CAP_GUARD_BAND_RIGHT:
   case PIPE_CAP_GUARD_BAND_BOTTOM:
      return 0.0;
a151 1
      assert(0);
d164 1
a164 1
                              enum pipe_format format,
d166 1
a166 2
                              unsigned sample_count,
                              unsigned bind,
d170 1
a170 1
   struct sw_winsys *winsys = screen->winsys;
d174 1
a174 1
   if (!format_desc)
d177 1
a177 2
   assert(target == PIPE_BUFFER ||
          target == PIPE_TEXTURE_1D ||
a178 1
          target == PIPE_TEXTURE_RECT ||
d182 5
a186 1
   if (sample_count > 1)
d188 3
d192 3
a194 2
   if (bind & PIPE_BIND_RENDER_TARGET) {
      if (format_desc->colorspace == UTIL_FORMAT_COLORSPACE_ZS)
d197 1
a197 1
      if (format_desc->layout != UTIL_FORMAT_LAYOUT_PLAIN)
d200 2
a201 2
      if (format_desc->block.width != 1 ||
          format_desc->block.height != 1)
d205 2
a206 2
   if (bind & PIPE_BIND_DISPLAY_TARGET) {
      if(!winsys->is_displaytarget_format_supported(winsys, bind, format))
d210 2
a211 2
   if (bind & PIPE_BIND_DEPTH_STENCIL) {
      if (format_desc->layout != UTIL_FORMAT_LAYOUT_PLAIN)
d214 9
a222 1
      if (format_desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS)
d225 5
a229 2
      /* FIXME: Temporary restriction. See lp_state_fs.c. */
      if (format_desc->block.bits != 32)
a230 1
   }
d232 3
a234 2
   if (format_desc->layout == UTIL_FORMAT_LAYOUT_S3TC) {
      return util_format_s3tc_enabled;
a236 3
   /*
    * Everything else should be supported by u_format.
    */
d241 12
d257 1
a257 2
                           struct pipe_resource *resource,
                           unsigned level, unsigned layer,
d261 2
a262 2
   struct sw_winsys *winsys = screen->winsys;
   struct llvmpipe_resource *texture = llvmpipe_resource(resource);
d274 1
a274 4
   struct sw_winsys *winsys = screen->winsys;

   if (screen->rast)
      lp_rast_destroy(screen->rast);
a280 2
   pipe_mutex_destroy(screen->rast_mutex);

a285 45

/**
 * Fence reference counting.
 */
static void
llvmpipe_fence_reference(struct pipe_screen *screen,
                         struct pipe_fence_handle **ptr,
                         struct pipe_fence_handle *fence)
{
   struct lp_fence **old = (struct lp_fence **) ptr;
   struct lp_fence *f = (struct lp_fence *) fence;

   lp_fence_reference(old, f);
}


/**
 * Has the fence been executed/finished?
 */
static int
llvmpipe_fence_signalled(struct pipe_screen *screen,
                         struct pipe_fence_handle *fence,
                         unsigned flag)
{
   struct lp_fence *f = (struct lp_fence *) fence;
   return lp_fence_signalled(f);
}


/**
 * Wait for the fence to finish.
 */
static int
llvmpipe_fence_finish(struct pipe_screen *screen,
                      struct pipe_fence_handle *fence_handle,
                      unsigned flag)
{
   struct lp_fence *f = (struct lp_fence *) fence_handle;

   lp_fence_wait(f);
   return 0;
}



d291 1
a291 1
llvmpipe_create_screen(struct sw_winsys *winsys)
d293 1
a293 10
   struct llvmpipe_screen *screen;

#ifdef PIPE_ARCH_X86
   /* require SSE2 due to LLVM PR6960. */
   util_cpu_detect();
   if (!util_cpu_caps.has_sse2)
       return NULL;
#endif

   screen = CALLOC_STRUCT(llvmpipe_screen);
a298 2
   LP_PERF = debug_get_flags_option("LP_PERF", lp_perf_flags, 0 );

a308 1
   screen->base.get_shader_param = llvmpipe_get_shader_param;
d312 1
a314 3
   screen->base.fence_reference = llvmpipe_fence_reference;
   screen->base.fence_signalled = llvmpipe_fence_signalled;
   screen->base.fence_finish = llvmpipe_fence_finish;
d316 3
a318 1
   llvmpipe_init_screen_resource_funcs(&screen->base);
a320 17

   screen->num_threads = util_cpu_caps.nr_cpus > 1 ? util_cpu_caps.nr_cpus : 0;
#ifdef PIPE_OS_EMBEDDED
   screen->num_threads = 0;
#endif
   screen->num_threads = debug_get_num_option("LP_NUM_THREADS", screen->num_threads);
   screen->num_threads = MIN2(screen->num_threads, LP_MAX_THREADS);

   screen->rast = lp_rast_create(screen->num_threads);
   if (!screen->rast) {
      lp_jit_screen_cleanup(screen);
      FREE(screen);
      return NULL;
   }
   pipe_mutex_init(screen->rast_mutex);

   util_format_s3tc_init();
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a32 1
#include "util/u_string.h"
a36 1
#include "gallivm/lp_bld_type.h"
a37 1
#include "os/os_time.h"
d61 2
d96 1
a96 5
   static char buf[100];
   util_snprintf(buf, sizeof(buf), "llvmpipe (LLVM %u.%u, %u bits)",
		 HAVE_LLVM >> 8, HAVE_LLVM & 0xff,
		 lp_native_vector_width );
   return buf;
d104 11
d116 1
a116 1
      return 2 * PIPE_MAX_SAMPLERS;  /* VS + FS samplers */
d121 2
a124 4
   case PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS:
      return 1;
   case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
      return PIPE_MAX_SO_BUFFERS;
d133 1
a133 1
   case PIPE_CAP_QUERY_TIME_ELAPSED:
d135 1
a135 1
   case PIPE_CAP_QUERY_TIMESTAMP:
d137 1
a137 3
   case PIPE_CAP_QUERY_PIPELINE_STATISTICS:
      return 0;
   case PIPE_CAP_TEXTURE_MIRROR_CLAMP:
a142 2
   case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
      return 0;
d148 1
a148 3
      return LP_MAX_TEXTURE_CUBE_LEVELS;
   case PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS:
      return LP_MAX_TEXTURE_ARRAY_LAYERS;
d154 1
a154 1
      return 1;
a156 1
   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
d159 1
d163 1
a163 6
   case PIPE_CAP_DEPTH_CLIP_DISABLE:
      return 0;
   case PIPE_CAP_SHADER_STENCIL_EXPORT:
      return 0;
   case PIPE_CAP_TGSI_INSTANCEID:
   case PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR:
d165 1
a165 1
   case PIPE_CAP_FRAGMENT_COLOR_CLAMPED:
d167 1
a167 29
   case PIPE_CAP_MIXED_COLORBUFFER_FORMATS:
      return 1;
   case PIPE_CAP_SEAMLESS_CUBE_MAP:
   case PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE:
      return 0;
   case PIPE_CAP_SCALED_RESOLVE:
      return 0;
   /* this is a lie could support arbitrary large offsets */
   case PIPE_CAP_MIN_TEXEL_OFFSET:
      return -8;
   case PIPE_CAP_MAX_TEXEL_OFFSET:
      return 7;
   case PIPE_CAP_CONDITIONAL_RENDER:
      return 1;
   case PIPE_CAP_TEXTURE_BARRIER:
      return 0;
   case PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS:
   case PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS:
      return 16*4;
   case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
      return 1;
   case PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS:
      return 0;
   case PIPE_CAP_VERTEX_COLOR_UNCLAMPED:
   case PIPE_CAP_VERTEX_COLOR_CLAMPED:
      return 1;
   case PIPE_CAP_GLSL_FEATURE_LEVEL:
      return 140;
   case PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION:
a168 32
   case PIPE_CAP_COMPUTE:
      return 0;
   case PIPE_CAP_USER_VERTEX_BUFFERS:
   case PIPE_CAP_USER_INDEX_BUFFERS:
      return 1;
   case PIPE_CAP_USER_CONSTANT_BUFFERS:
      return 0;
   case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_TGSI_TEXCOORD:
      return 0;

   case PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT:
      return 16;
   case PIPE_CAP_START_INSTANCE:
   case PIPE_CAP_TEXTURE_MULTISAMPLE:
   case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
   case PIPE_CAP_CUBE_MAP_ARRAY:
      return 0;
   case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
      return 1;
   case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
      return 65536;
   case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
      return 1;
   case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
      return 0;
   case PIPE_CAP_MAX_VIEWPORTS:
      return PIPE_MAX_VIEWPORTS;
   case PIPE_CAP_ENDIANNESS:
      return PIPE_ENDIAN_NATIVE;
a169 3
   /* should only get here on unhandled cases */
   debug_printf("Unexpected PIPE_CAP %d query\n", param);
   return 0;
d178 1
a178 4
      switch (param) {
      default:
         return gallivm_get_shader_param(param);
      }
d181 1
a181 13
      switch (param) {
      case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
         /* At this time, the draw module and llvmpipe driver only
          * support vertex shader texture lookups when LLVM is enabled in
          * the draw module.
          */
         if (debug_get_bool_option("DRAW_USE_LLVM", TRUE))
            return PIPE_MAX_SAMPLERS;
         else
            return 0;
      default:
         return draw_get_shader_param(shader, param);
      }
d188 1
a188 1
llvmpipe_get_paramf(struct pipe_screen *screen, enum pipe_capf param)
d191 1
a191 1
   case PIPE_CAPF_MAX_LINE_WIDTH:
d193 1
a193 1
   case PIPE_CAPF_MAX_LINE_WIDTH_AA:
d195 1
a195 1
   case PIPE_CAPF_MAX_POINT_WIDTH:
d197 1
a197 1
   case PIPE_CAPF_MAX_POINT_WIDTH_AA:
d199 1
a199 1
   case PIPE_CAPF_MAX_TEXTURE_ANISOTROPY:
d201 1
a201 1
   case PIPE_CAPF_MAX_TEXTURE_LOD_BIAS:
d203 4
a206 4
   case PIPE_CAPF_GUARD_BAND_LEFT:
   case PIPE_CAPF_GUARD_BAND_TOP:
   case PIPE_CAPF_GUARD_BAND_RIGHT:
   case PIPE_CAPF_GUARD_BAND_BOTTOM:
d208 3
a211 3
   /* should only get here on unhandled cases */
   debug_printf("Unexpected PIPE_CAP %d query\n", param);
   return 0.0;
d225 2
a226 1
                              unsigned bind)
a237 1
          target == PIPE_TEXTURE_1D_ARRAY ||
a238 1
          target == PIPE_TEXTURE_2D_ARRAY ||
d247 1
a247 5
      if (format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
         if (format_desc->nr_channels < 3)
            return FALSE;
      }
      else if (format_desc->colorspace != UTIL_FORMAT_COLORSPACE_RGB)
d250 1
a250 2
      if (format_desc->layout != UTIL_FORMAT_LAYOUT_PLAIN &&
          format != PIPE_FORMAT_R11G11B10_FLOAT)
d253 2
a254 4
      assert(format_desc->block.width == 1);
      assert(format_desc->block.height == 1);

      if (format_desc->is_mixed)
a255 18

      if (!format_desc->is_array && !format_desc->is_bitmask &&
          format != PIPE_FORMAT_R11G11B10_FLOAT)
         return FALSE;

      /*
       * XXX refuse formats known to crash in generate_unswizzled_blend().
       * These include all 3-channel 24bit RGB8 variants, plus 48bit
       * (except those using floats) 3-channel RGB16 variants (the latter
       * seems to be more of a llvm bug though).
       * The mesa state tracker only seems to use these for SINT/UINT formats.
       */
      if (format_desc->is_array && format_desc->nr_channels == 3) {
         if (format_desc->block.bits == 24 || (format_desc->block.bits == 48 &&
               !util_format_is_float(format))) {
            return FALSE;
         }
      }
d270 2
a271 2
      /* TODO: Support stencil-only formats */
      if (format_desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_NONE) {
a272 1
      }
d280 1
a280 2
    * Everything can be supported by u_format
    * (those without fetch_rgba_float might be not but shouldn't hit that)
a281 1

d344 1
a344 1
static boolean
d346 2
a347 1
                         struct pipe_fence_handle *fence)
d357 1
a357 1
static boolean
d360 1
a360 1
                      uint64_t timeout)
d365 1
a365 1
   return TRUE;
d368 1
a368 5
static uint64_t
llvmpipe_get_timestamp(struct pipe_screen *_screen)
{
   return os_time_get_nano();
}
d379 2
a381 3

#if defined(PIPE_ARCH_X86) && HAVE_LLVM < 0x0302
   /* require SSE2 due to LLVM PR6960. */
d386 2
a393 1
   screen = CALLOC_STRUCT(llvmpipe_screen);
a413 2
   screen->base.get_timestamp = llvmpipe_get_timestamp;

d419 1
a419 1
#ifdef PIPE_SUBSYSTEM_EMBEDDED
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d109 2
a111 1
   case PIPE_CAP_MIXED_FRAMEBUFFER_SIZES:
d166 1
a166 1
      return 1;
d178 3
a180 1
      return 1;
a181 1
   case PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET:
a183 1
   case PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET:
a192 3
   case PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES:
   case PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS:
      return 1024;
d201 1
a201 1
      return 330;
d221 1
a223 2
   case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
      return 64;
a235 9
   case PIPE_CAP_TGSI_VS_LAYER:
   case PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS:
   case PIPE_CAP_TEXTURE_GATHER_SM5:
   case PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT:
   case PIPE_CAP_TEXTURE_QUERY_LOD:
   case PIPE_CAP_SAMPLE_SHADING:
      return 0;
   case PIPE_CAP_FAKE_SW_MSAA:
	return 1;
a263 5
      case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
         if (debug_get_bool_option("DRAW_USE_LLVM", TRUE))
            return PIPE_MAX_SHADER_SAMPLER_VIEWS;
         else
            return 0;
a333 1
         /* this is a lie actually other formats COULD exist where we would fail */
d406 1
a406 2
                           void *context_private,
                           struct pipe_box *sub_box)
d414 1
a414 1
      winsys->displaytarget_display(winsys, texture->dt, context_private, sub_box);
d416 1
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a39 1
#include "os/os_misc.h"
a169 1
   case PIPE_CAP_START_INSTANCE:
a194 4
   case PIPE_CAP_MAX_VERTEX_STREAMS:
      return 1;
   case PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE:
      return 2048;
a217 2
   case PIPE_CAP_DRAW_INDIRECT:
      return 1;
a218 2
   case PIPE_CAP_CUBE_MAP_ARRAY:
      return 1;
d221 1
d223 1
d239 1
a239 1
   case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
a244 4
   case PIPE_CAP_TEXTURE_GATHER_OFFSETS:
   case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
   case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
   case PIPE_CAP_SAMPLER_VIEW_TARGET:
d247 1
a247 23
      return 1;
   case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
      return 1;

   case PIPE_CAP_VENDOR_ID:
      return 0xFFFFFFFF;
   case PIPE_CAP_DEVICE_ID:
      return 0xFFFFFFFF;
   case PIPE_CAP_ACCELERATED:
      return 0;
   case PIPE_CAP_VIDEO_MEMORY: {
      /* XXX: Do we want to return the full amount fo system memory ? */
      uint64_t system_memory;

      if (!os_get_total_physical_memory(&system_memory))
         return 0;

      return (int)(system_memory >> 20);
   }
   case PIPE_CAP_UMA:
      return 0;
   case PIPE_CAP_CLIP_HALFZ:
      return 1;
d344 1
a344 2
          target == PIPE_TEXTURE_CUBE ||
          target == PIPE_TEXTURE_CUBE_ARRAY);
a404 5
   if (format_desc->layout == UTIL_FORMAT_LAYOUT_BPTC) {
      /* Software decoding is not hooked up. */
      return FALSE;
   }

d516 6
a531 5
   if (!lp_jit_screen_init(screen)) {
      FREE(screen);
      return NULL;
   }

d552 2
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d40 1
d171 1
d197 4
d224 2
d227 2
a230 1
   case PIPE_CAP_START_INSTANCE:
a231 1
   case PIPE_CAP_CUBE_MAP_ARRAY:
d247 1
a247 1
   case PIPE_CAP_TGSI_VS_LAYER:
d253 4
d259 23
a281 1
	return 1;
d378 2
a379 1
          target == PIPE_TEXTURE_CUBE);
d440 5
a555 6
#if defined(PIPE_ARCH_X86) && HAVE_LLVM < 0x0302
   /* require SSE2 due to LLVM PR6960. */
   if (!util_cpu_caps.has_sse2)
       return NULL;
#endif

d566 5
a590 2

   lp_jit_screen_init(screen);
@


