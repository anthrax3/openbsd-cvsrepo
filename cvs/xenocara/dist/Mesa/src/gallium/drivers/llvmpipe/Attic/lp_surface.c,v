head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.35;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.59;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.31;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.39;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "util/u_rect.h"
#include "util/u_surface.h"
#include "lp_context.h"
#include "lp_flush.h"
#include "lp_limits.h"
#include "lp_surface.h"
#include "lp_texture.h"
#include "lp_query.h"


/**
 * Adjust x, y, width, height to lie on tile bounds.
 */
static void
adjust_to_tile_bounds(unsigned x, unsigned y, unsigned width, unsigned height,
                      unsigned *x_tile, unsigned *y_tile,
                      unsigned *w_tile, unsigned *h_tile)
{
   *x_tile = x & ~(TILE_SIZE - 1);
   *y_tile = y & ~(TILE_SIZE - 1);
   *w_tile = ((x + width + TILE_SIZE - 1) & ~(TILE_SIZE - 1)) - *x_tile;
   *h_tile = ((y + height + TILE_SIZE - 1) & ~(TILE_SIZE - 1)) - *y_tile;
}



static void
lp_resource_copy(struct pipe_context *pipe,
                 struct pipe_resource *dst, unsigned dst_level,
                 unsigned dstx, unsigned dsty, unsigned dstz,
                 struct pipe_resource *src, unsigned src_level,
                 const struct pipe_box *src_box)
{
   struct llvmpipe_resource *src_tex = llvmpipe_resource(src);
   struct llvmpipe_resource *dst_tex = llvmpipe_resource(dst);
   const enum pipe_format format = src_tex->base.format;
   unsigned width = src_box->width;
   unsigned height = src_box->height;
   unsigned depth = src_box->depth;
   unsigned z;

   llvmpipe_flush_resource(pipe,
                           dst, dst_level,
                           FALSE, /* read_only */
                           TRUE, /* cpu_access */
                           FALSE, /* do_not_block */
                           "blit dest");

   llvmpipe_flush_resource(pipe,
                           src, src_level,
                           TRUE, /* read_only */
                           TRUE, /* cpu_access */
                           FALSE, /* do_not_block */
                           "blit src");

   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }

   /*
   printf("surface copy from %u lvl %u to %u lvl %u: %u,%u,%u to %u,%u,%u %u x %u x %u\n",
          src_tex->id, src_level, dst_tex->id, dst_level,
          src_box->x, src_box->y, src_box->z, dstx, dsty, dstz,
          src_box->width, src_box->height, src_box->depth);
   */

   for (z = 0; z < src_box->depth; z++){

      /* set src tiles to linear layout */
      {
         unsigned tx, ty, tw, th;
         unsigned x, y;

         adjust_to_tile_bounds(src_box->x, src_box->y, width, height,
                               &tx, &ty, &tw, &th);

         for (y = 0; y < th; y += TILE_SIZE) {
            for (x = 0; x < tw; x += TILE_SIZE) {
               (void) llvmpipe_get_texture_tile_linear(src_tex,
                                                       src_box->z + z, src_level,
                                                       LP_TEX_USAGE_READ,
                                                       tx + x, ty + y);
            }
         }
      }

      /* set dst tiles to linear layout */
      {
         unsigned tx, ty, tw, th;
         unsigned x, y;
         enum lp_texture_usage usage;

         adjust_to_tile_bounds(dstx, dsty, width, height, &tx, &ty, &tw, &th);

         for (y = 0; y < th; y += TILE_SIZE) {
            boolean contained_y = ty + y >= dsty &&
                                  ty + y + TILE_SIZE <= dsty + height ?
                                  TRUE : FALSE;

            for (x = 0; x < tw; x += TILE_SIZE) {
               boolean contained_x = tx + x >= dstx &&
                                     tx + x + TILE_SIZE <= dstx + width ?
                                     TRUE : FALSE;

               /*
                * Set the usage mode to WRITE_ALL for the tiles which are
                * completely contained by the dest rectangle.
                */
               if (contained_y && contained_x)
                  usage = LP_TEX_USAGE_WRITE_ALL;
               else
                  usage = LP_TEX_USAGE_READ_WRITE;

               (void) llvmpipe_get_texture_tile_linear(dst_tex,
                                                       dstz + z, dst_level,
                                                       usage,
                                                       tx + x, ty + y);
            }
         }
      }
   }

   /* copy */
   {
      const ubyte *src_linear_ptr
         = llvmpipe_get_texture_image_address(src_tex, src_box->z,
                                              src_level);
      ubyte *dst_linear_ptr
         = llvmpipe_get_texture_image_address(dst_tex, dstz,
                                              dst_level);

      if (dst_linear_ptr && src_linear_ptr) {
         util_copy_box(dst_linear_ptr, format,
                       llvmpipe_resource_stride(&dst_tex->base, dst_level),
                       dst_tex->img_stride[dst_level],
                       dstx, dsty, 0,
                       width, height, depth,
                       src_linear_ptr,
                       llvmpipe_resource_stride(&src_tex->base, src_level),
                       src_tex->img_stride[src_level],
                       src_box->x, src_box->y, 0);
      }
   }
}


static void lp_blit(struct pipe_context *pipe,
                    const struct pipe_blit_info *blit_info)
{
   struct llvmpipe_context *lp = llvmpipe_context(pipe);
   struct pipe_blit_info info = *blit_info;

   if (info.src.resource->nr_samples > 1 &&
       info.dst.resource->nr_samples <= 1 &&
       !util_format_is_depth_or_stencil(info.src.resource->format) &&
       !util_format_is_pure_integer(info.src.resource->format)) {
      debug_printf("llvmpipe: color resolve unimplemented\n");
      return;
   }

   if (util_try_blit_via_copy_region(pipe, &info)) {
      return; /* done */
   }

   if (info.mask & PIPE_MASK_S) {
      debug_printf("llvmpipe: cannot blit stencil, skipping\n");
      info.mask &= ~PIPE_MASK_S;
   }

   if (!util_blitter_is_blit_supported(lp->blitter, &info)) {
      debug_printf("llvmpipe: blit unsupported %s -> %s\n",
                   util_format_short_name(info.src.resource->format),
                   util_format_short_name(info.dst.resource->format));
      return;
   }

   /* XXX turn off occlusion and streamout queries */

   util_blitter_save_vertex_buffer_slot(lp->blitter, lp->vertex_buffer);
   util_blitter_save_vertex_elements(lp->blitter, (void*)lp->velems);
   util_blitter_save_vertex_shader(lp->blitter, (void*)lp->vs);
   util_blitter_save_geometry_shader(lp->blitter, (void*)lp->gs);
   util_blitter_save_so_targets(lp->blitter, lp->num_so_targets,
                                (struct pipe_stream_output_target**)lp->so_targets);
   util_blitter_save_rasterizer(lp->blitter, (void*)lp->rasterizer);
   util_blitter_save_viewport(lp->blitter, &lp->viewports[0]);
   util_blitter_save_scissor(lp->blitter, &lp->scissors[0]);
   util_blitter_save_fragment_shader(lp->blitter, lp->fs);
   util_blitter_save_blend(lp->blitter, (void*)lp->blend);
   util_blitter_save_depth_stencil_alpha(lp->blitter, (void*)lp->depth_stencil);
   util_blitter_save_stencil_ref(lp->blitter, &lp->stencil_ref);
   /*util_blitter_save_sample_mask(sp->blitter, lp->sample_mask);*/
   util_blitter_save_framebuffer(lp->blitter, &lp->framebuffer);
   util_blitter_save_fragment_sampler_states(lp->blitter,
                     lp->num_samplers[PIPE_SHADER_FRAGMENT],
                     (void**)lp->samplers[PIPE_SHADER_FRAGMENT]);
   util_blitter_save_fragment_sampler_views(lp->blitter,
                     lp->num_sampler_views[PIPE_SHADER_FRAGMENT],
                     lp->sampler_views[PIPE_SHADER_FRAGMENT]);
   util_blitter_save_render_condition(lp->blitter, lp->render_cond_query,
                                      lp->render_cond_cond, lp->render_cond_mode);
   util_blitter_blit(lp->blitter, &info);
}


static void
lp_flush_resource(struct pipe_context *ctx, struct pipe_resource *resource)
{
}


static struct pipe_surface *
llvmpipe_create_surface(struct pipe_context *pipe,
                        struct pipe_resource *pt,
                        const struct pipe_surface *surf_tmpl)
{
   struct pipe_surface *ps;

   if (!(pt->bind & (PIPE_BIND_DEPTH_STENCIL | PIPE_BIND_RENDER_TARGET)))
      debug_printf("Illegal surface creation without bind flag\n");

   ps = CALLOC_STRUCT(pipe_surface);
   if (ps) {
      pipe_reference_init(&ps->reference, 1);
      pipe_resource_reference(&ps->texture, pt);
      ps->context = pipe;
      ps->format = surf_tmpl->format;
      if (llvmpipe_resource_is_texture(pt)) {
         assert(surf_tmpl->u.tex.level <= pt->last_level);
         assert(surf_tmpl->u.tex.first_layer <= surf_tmpl->u.tex.last_layer);
         ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
         ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
         ps->u.tex.level = surf_tmpl->u.tex.level;
         ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
         ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
      }
      else {
         /* setting width as number of elements should get us correct renderbuffer width */
         ps->width = surf_tmpl->u.buf.last_element - surf_tmpl->u.buf.first_element + 1;
         ps->height = pt->height0;
         ps->u.buf.first_element = surf_tmpl->u.buf.first_element;
         ps->u.buf.last_element = surf_tmpl->u.buf.last_element;
         assert(ps->u.buf.first_element <= ps->u.buf.last_element);
         assert(util_format_get_blocksize(surf_tmpl->format) *
                (ps->u.buf.last_element + 1) <= pt->width0);
      }
   }
   return ps;
}


static void
llvmpipe_surface_destroy(struct pipe_context *pipe,
                         struct pipe_surface *surf)
{
   /* Effectively do the texture_update work here - if texture images
    * needed post-processing to put them into hardware layout, this is
    * where it would happen.  For llvmpipe, nothing to do.
    */
   assert(surf->texture);
   pipe_resource_reference(&surf->texture, NULL);
   FREE(surf);
}


static void
llvmpipe_clear_render_target(struct pipe_context *pipe,
                             struct pipe_surface *dst,
                             const union pipe_color_union *color,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);

   if (!llvmpipe_check_render_cond(llvmpipe))
      return;

   util_clear_render_target(pipe, dst, color,
                            dstx, dsty, width, height);
}


static void
llvmpipe_clear_depth_stencil(struct pipe_context *pipe,
                             struct pipe_surface *dst,
                             unsigned clear_flags,
                             double depth,
                             unsigned stencil,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);

   if (!llvmpipe_check_render_cond(llvmpipe))
      return;

   util_clear_depth_stencil(pipe, dst, clear_flags,
                            depth, stencil,
                            dstx, dsty, width, height);
}


void
llvmpipe_init_surface_functions(struct llvmpipe_context *lp)
{
   lp->pipe.clear_render_target = llvmpipe_clear_render_target;
   lp->pipe.clear_depth_stencil = llvmpipe_clear_depth_stencil;
   lp->pipe.create_surface = llvmpipe_create_surface;
   lp->pipe.surface_destroy = llvmpipe_surface_destroy;
   /* These two are not actually functions dealing with surfaces */
   lp->pipe.resource_copy_region = lp_resource_copy;
   lp->pipe.blit = lp_blit;
   lp->pipe.flush_resource = lp_flush_resource;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d38 16
d67 1
d97 19
a115 9
   /* make sure display target resources (which cannot have levels/layers) are mapped */
   if (src_tex->dt)
      (void) llvmpipe_resource_map(src, src_level, 0, LP_TEX_USAGE_READ);
   if (dst_tex->dt)
      /*
       * Could set this to WRITE_ALL if complete dst is covered but it gets
       * ignored anyway.
       */
      (void) llvmpipe_resource_map(dst, dst_level, 0, LP_TEX_USAGE_READ_WRITE);
d117 35
a173 6

   if (src_tex->dt)
      llvmpipe_resource_unmap(src, 0, 0);
   if (dst_tex->dt)
      llvmpipe_resource_unmap(dst, 0, 0);

a181 3

   if (blit_info->render_condition_enable && !llvmpipe_check_render_cond(lp))
      return;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a37 16
/**
 * Adjust x, y, width, height to lie on tile bounds.
 */
static void
adjust_to_tile_bounds(unsigned x, unsigned y, unsigned width, unsigned height,
                      unsigned *x_tile, unsigned *y_tile,
                      unsigned *w_tile, unsigned *h_tile)
{
   *x_tile = x & ~(TILE_SIZE - 1);
   *y_tile = y & ~(TILE_SIZE - 1);
   *w_tile = ((x + width + TILE_SIZE - 1) & ~(TILE_SIZE - 1)) - *x_tile;
   *h_tile = ((y + height + TILE_SIZE - 1) & ~(TILE_SIZE - 1)) - *y_tile;
}



a50 1
   unsigned z;
d80 9
a88 19
   for (z = 0; z < src_box->depth; z++){

      /* set src tiles to linear layout */
      {
         unsigned tx, ty, tw, th;
         unsigned x, y;

         adjust_to_tile_bounds(src_box->x, src_box->y, width, height,
                               &tx, &ty, &tw, &th);

         for (y = 0; y < th; y += TILE_SIZE) {
            for (x = 0; x < tw; x += TILE_SIZE) {
               (void) llvmpipe_get_texture_tile_linear(src_tex,
                                                       src_box->z + z, src_level,
                                                       LP_TEX_USAGE_READ,
                                                       tx + x, ty + y);
            }
         }
      }
a89 35
      /* set dst tiles to linear layout */
      {
         unsigned tx, ty, tw, th;
         unsigned x, y;
         enum lp_texture_usage usage;

         adjust_to_tile_bounds(dstx, dsty, width, height, &tx, &ty, &tw, &th);

         for (y = 0; y < th; y += TILE_SIZE) {
            boolean contained_y = ty + y >= dsty &&
                                  ty + y + TILE_SIZE <= dsty + height ?
                                  TRUE : FALSE;

            for (x = 0; x < tw; x += TILE_SIZE) {
               boolean contained_x = tx + x >= dstx &&
                                     tx + x + TILE_SIZE <= dstx + width ?
                                     TRUE : FALSE;

               /*
                * Set the usage mode to WRITE_ALL for the tiles which are
                * completely contained by the dest rectangle.
                */
               if (contained_y && contained_x)
                  usage = LP_TEX_USAGE_WRITE_ALL;
               else
                  usage = LP_TEX_USAGE_READ_WRITE;

               (void) llvmpipe_get_texture_tile_linear(dst_tex,
                                                       dstz + z, dst_level,
                                                       usage,
                                                       tx + x, ty + y);
            }
         }
      }
   }
d112 6
d126 3
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d236 6
d343 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d35 1
a60 3
   /* XXX this used to ignore srcz/dstz
    * assume it works the same for cube and 3d
    */
d66 2
a67 8
   assert(src_box->depth == 1);

   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }
d70 1
a70 1
                           dst, dst_level, dstz,
d77 1
a77 1
                           src, src_level, src_box->z,
d83 7
d92 1
a92 1
          src_tex->id, src_level, dst_tex->id, dst_level, 
d97 1
a97 7
   /* set src tiles to linear layout */
   {
      unsigned tx, ty, tw, th;
      unsigned x, y;

      adjust_to_tile_bounds(src_box->x, src_box->y, width, height,
                            &tx, &ty, &tw, &th);
d99 15
a113 6
      for (y = 0; y < th; y += TILE_SIZE) {
         for (x = 0; x < tw; x += TILE_SIZE) {
            (void) llvmpipe_get_texture_tile_linear(src_tex,
                                                    src_box->z, src_level,
                                                    LP_TEX_USAGE_READ,
                                                    tx + x, ty + y);
a115 1
   }
d117 11
a127 16
   /* set dst tiles to linear layout */
   {
      unsigned tx, ty, tw, th;
      unsigned x, y;
      enum lp_texture_usage usage;

      adjust_to_tile_bounds(dstx, dsty, width, height, &tx, &ty, &tw, &th);

      for (y = 0; y < th; y += TILE_SIZE) {
         boolean contained_y = ty + y >= dsty &&
                               ty + y + TILE_SIZE <= dsty + height ?
                               TRUE : FALSE;

         for (x = 0; x < tw; x += TILE_SIZE) {
            boolean contained_x = tx + x >= dstx &&
                                  tx + x + TILE_SIZE <= dstx + width ?
d130 19
a148 13
            /*
             * Set the usage mode to WRITE_ALL for the tiles which are
             * completely contained by the dest rectangle.
             */
            if (contained_y && contained_x)
               usage = LP_TEX_USAGE_WRITE_ALL;
            else
               usage = LP_TEX_USAGE_READ_WRITE;

            (void) llvmpipe_get_texture_tile_linear(dst_tex,
                                                    dstz, dst_level,
                                                    usage,
                                                    tx + x, ty + y);
d157 1
a157 2
                                              src_level,
                                              LP_TEX_LAYOUT_LINEAR);
d160 1
a160 2
                                              dst_level,
                                              LP_TEX_LAYOUT_LINEAR);
d163 107
a269 7
         util_copy_rect(dst_linear_ptr, format,
                        llvmpipe_resource_stride(&dst_tex->base, dst_level),
                        dstx, dsty,
                        width, height,
                        src_linear_ptr,
                        llvmpipe_resource_stride(&src_tex->base, src_level),
                        src_box->x, src_box->y);
d272 52
d330 5
d336 1
a336 2
   lp->pipe.clear_render_target = util_clear_render_target;
   lp->pipe.clear_depth_stencil = util_clear_depth_stencil;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d70 7
a78 1
                           0, /* flush_flags */
a85 1
                           0, /* flush_flags */
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d29 1
d31 2
d34 1
d37 3
d41 3
a43 4
lp_surface_copy(struct pipe_context *pipe,
                struct pipe_surface *dest, unsigned destx, unsigned desty,
                struct pipe_surface *src, unsigned srcx, unsigned srcy,
                unsigned width, unsigned height)
d45 4
a48 4
   util_surface_copy(pipe, FALSE,
                     dest, destx, desty,
                     src, srcx, srcy,
                     width, height);
d51 119
d171 1
a171 1
lp_init_surface_functions(struct llvmpipe_context *lp)
d173 3
a175 2
   lp->pipe.surface_copy = lp_surface_copy;
   lp->pipe.surface_fill = util_surface_fill;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a28 1
#include "util/u_surface.h"
a29 2
#include "lp_flush.h"
#include "lp_limits.h"
a30 1
#include "lp_texture.h"
a32 3
/**
 * Adjust x, y, width, height to lie on tile bounds.
 */
d34 4
a37 3
adjust_to_tile_bounds(unsigned x, unsigned y, unsigned width, unsigned height,
                      unsigned *x_tile, unsigned *y_tile,
                      unsigned *w_tile, unsigned *h_tile)
d39 4
a42 4
   *x_tile = x & ~(TILE_SIZE - 1);
   *y_tile = y & ~(TILE_SIZE - 1);
   *w_tile = ((x + width + TILE_SIZE - 1) & ~(TILE_SIZE - 1)) - *x_tile;
   *h_tile = ((y + height + TILE_SIZE - 1) & ~(TILE_SIZE - 1)) - *y_tile;
a44 119


static void
lp_resource_copy(struct pipe_context *pipe,
                 struct pipe_resource *dst, unsigned dst_level,
                 unsigned dstx, unsigned dsty, unsigned dstz,
                 struct pipe_resource *src, unsigned src_level,
                 const struct pipe_box *src_box)
{
   /* XXX this used to ignore srcz/dstz
    * assume it works the same for cube and 3d
    */
   struct llvmpipe_resource *src_tex = llvmpipe_resource(src);
   struct llvmpipe_resource *dst_tex = llvmpipe_resource(dst);
   const enum pipe_format format = src_tex->base.format;
   unsigned width = src_box->width;
   unsigned height = src_box->height;
   assert(src_box->depth == 1);

   llvmpipe_flush_resource(pipe,
                           dst, dst_level, dstz,
                           0, /* flush_flags */
                           FALSE, /* read_only */
                           TRUE, /* cpu_access */
                           FALSE, /* do_not_block */
                           "blit dest");

   llvmpipe_flush_resource(pipe,
                           src, src_level, src_box->z,
                           0, /* flush_flags */
                           TRUE, /* read_only */
                           TRUE, /* cpu_access */
                           FALSE, /* do_not_block */
                           "blit src");

   /*
   printf("surface copy from %u lvl %u to %u lvl %u: %u,%u,%u to %u,%u,%u %u x %u x %u\n",
          src_tex->id, src_level, dst_tex->id, dst_level, 
          src_box->x, src_box->y, src_box->z, dstx, dsty, dstz,
          src_box->width, src_box->height, src_box->depth);
   */

   /* set src tiles to linear layout */
   {
      unsigned tx, ty, tw, th;
      unsigned x, y;

      adjust_to_tile_bounds(src_box->x, src_box->y, width, height,
                            &tx, &ty, &tw, &th);

      for (y = 0; y < th; y += TILE_SIZE) {
         for (x = 0; x < tw; x += TILE_SIZE) {
            (void) llvmpipe_get_texture_tile_linear(src_tex,
                                                    src_box->z, src_level,
                                                    LP_TEX_USAGE_READ,
                                                    tx + x, ty + y);
         }
      }
   }

   /* set dst tiles to linear layout */
   {
      unsigned tx, ty, tw, th;
      unsigned x, y;
      enum lp_texture_usage usage;

      adjust_to_tile_bounds(dstx, dsty, width, height, &tx, &ty, &tw, &th);

      for (y = 0; y < th; y += TILE_SIZE) {
         boolean contained_y = ty + y >= dsty &&
                               ty + y + TILE_SIZE <= dsty + height ?
                               TRUE : FALSE;

         for (x = 0; x < tw; x += TILE_SIZE) {
            boolean contained_x = tx + x >= dstx &&
                                  tx + x + TILE_SIZE <= dstx + width ?
                                  TRUE : FALSE;

            /*
             * Set the usage mode to WRITE_ALL for the tiles which are
             * completely contained by the dest rectangle.
             */
            if (contained_y && contained_x)
               usage = LP_TEX_USAGE_WRITE_ALL;
            else
               usage = LP_TEX_USAGE_READ_WRITE;

            (void) llvmpipe_get_texture_tile_linear(dst_tex,
                                                    dstz, dst_level,
                                                    usage,
                                                    tx + x, ty + y);
         }
      }
   }

   /* copy */
   {
      const ubyte *src_linear_ptr
         = llvmpipe_get_texture_image_address(src_tex, src_box->z,
                                              src_level,
                                              LP_TEX_LAYOUT_LINEAR);
      ubyte *dst_linear_ptr
         = llvmpipe_get_texture_image_address(dst_tex, dstz,
                                              dst_level,
                                              LP_TEX_LAYOUT_LINEAR);

      if (dst_linear_ptr && src_linear_ptr) {
         util_copy_rect(dst_linear_ptr, format,
                        llvmpipe_resource_stride(&dst_tex->base, dst_level),
                        dstx, dsty,
                        width, height,
                        src_linear_ptr,
                        llvmpipe_resource_stride(&src_tex->base, src_level),
                        src_box->x, src_box->y);
      }
   }
}


d46 1
a46 1
llvmpipe_init_surface_functions(struct llvmpipe_context *lp)
d48 2
a49 3
   lp->pipe.resource_copy_region = lp_resource_copy;
   lp->pipe.clear_render_target = util_clear_render_target;
   lp->pipe.clear_depth_stencil = util_clear_depth_stencil;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a34 1
#include "lp_query.h"
d60 3
d68 1
a68 2
   unsigned depth = src_box->depth;
   unsigned z;
d71 2
a72 1
                           dst, dst_level,
d79 2
a80 1
                           src, src_level,
a85 7
   /* Fallback for buffers. */
   if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
      util_resource_copy_region(pipe, dst, dst_level, dstx, dsty, dstz,
                                src, src_level, src_box);
      return;
   }

d88 1
a88 1
          src_tex->id, src_level, dst_tex->id, dst_level,
d93 4
a96 1
   for (z = 0; z < src_box->depth; z++){
d98 9
a106 15
      /* set src tiles to linear layout */
      {
         unsigned tx, ty, tw, th;
         unsigned x, y;

         adjust_to_tile_bounds(src_box->x, src_box->y, width, height,
                               &tx, &ty, &tw, &th);

         for (y = 0; y < th; y += TILE_SIZE) {
            for (x = 0; x < tw; x += TILE_SIZE) {
               (void) llvmpipe_get_texture_tile_linear(src_tex,
                                                       src_box->z + z, src_level,
                                                       LP_TEX_USAGE_READ,
                                                       tx + x, ty + y);
            }
d109 1
d111 16
a126 11
      /* set dst tiles to linear layout */
      {
         unsigned tx, ty, tw, th;
         unsigned x, y;
         enum lp_texture_usage usage;

         adjust_to_tile_bounds(dstx, dsty, width, height, &tx, &ty, &tw, &th);

         for (y = 0; y < th; y += TILE_SIZE) {
            boolean contained_y = ty + y >= dsty &&
                                  ty + y + TILE_SIZE <= dsty + height ?
d129 13
a141 19
            for (x = 0; x < tw; x += TILE_SIZE) {
               boolean contained_x = tx + x >= dstx &&
                                     tx + x + TILE_SIZE <= dstx + width ?
                                     TRUE : FALSE;

               /*
                * Set the usage mode to WRITE_ALL for the tiles which are
                * completely contained by the dest rectangle.
                */
               if (contained_y && contained_x)
                  usage = LP_TEX_USAGE_WRITE_ALL;
               else
                  usage = LP_TEX_USAGE_READ_WRITE;

               (void) llvmpipe_get_texture_tile_linear(dst_tex,
                                                       dstz + z, dst_level,
                                                       usage,
                                                       tx + x, ty + y);
            }
d150 2
a151 1
                                              src_level);
d154 2
a155 1
                                              dst_level);
d158 7
a164 107
         util_copy_box(dst_linear_ptr, format,
                       llvmpipe_resource_stride(&dst_tex->base, dst_level),
                       dst_tex->img_stride[dst_level],
                       dstx, dsty, 0,
                       width, height, depth,
                       src_linear_ptr,
                       llvmpipe_resource_stride(&src_tex->base, src_level),
                       src_tex->img_stride[src_level],
                       src_box->x, src_box->y, 0);
      }
   }
}


static void lp_blit(struct pipe_context *pipe,
                    const struct pipe_blit_info *blit_info)
{
   struct llvmpipe_context *lp = llvmpipe_context(pipe);
   struct pipe_blit_info info = *blit_info;

   if (info.src.resource->nr_samples > 1 &&
       info.dst.resource->nr_samples <= 1 &&
       !util_format_is_depth_or_stencil(info.src.resource->format) &&
       !util_format_is_pure_integer(info.src.resource->format)) {
      debug_printf("llvmpipe: color resolve unimplemented\n");
      return;
   }

   if (util_try_blit_via_copy_region(pipe, &info)) {
      return; /* done */
   }

   if (info.mask & PIPE_MASK_S) {
      debug_printf("llvmpipe: cannot blit stencil, skipping\n");
      info.mask &= ~PIPE_MASK_S;
   }

   if (!util_blitter_is_blit_supported(lp->blitter, &info)) {
      debug_printf("llvmpipe: blit unsupported %s -> %s\n",
                   util_format_short_name(info.src.resource->format),
                   util_format_short_name(info.dst.resource->format));
      return;
   }

   /* XXX turn off occlusion and streamout queries */

   util_blitter_save_vertex_buffer_slot(lp->blitter, lp->vertex_buffer);
   util_blitter_save_vertex_elements(lp->blitter, (void*)lp->velems);
   util_blitter_save_vertex_shader(lp->blitter, (void*)lp->vs);
   util_blitter_save_geometry_shader(lp->blitter, (void*)lp->gs);
   util_blitter_save_so_targets(lp->blitter, lp->num_so_targets,
                                (struct pipe_stream_output_target**)lp->so_targets);
   util_blitter_save_rasterizer(lp->blitter, (void*)lp->rasterizer);
   util_blitter_save_viewport(lp->blitter, &lp->viewports[0]);
   util_blitter_save_scissor(lp->blitter, &lp->scissors[0]);
   util_blitter_save_fragment_shader(lp->blitter, lp->fs);
   util_blitter_save_blend(lp->blitter, (void*)lp->blend);
   util_blitter_save_depth_stencil_alpha(lp->blitter, (void*)lp->depth_stencil);
   util_blitter_save_stencil_ref(lp->blitter, &lp->stencil_ref);
   /*util_blitter_save_sample_mask(sp->blitter, lp->sample_mask);*/
   util_blitter_save_framebuffer(lp->blitter, &lp->framebuffer);
   util_blitter_save_fragment_sampler_states(lp->blitter,
                     lp->num_samplers[PIPE_SHADER_FRAGMENT],
                     (void**)lp->samplers[PIPE_SHADER_FRAGMENT]);
   util_blitter_save_fragment_sampler_views(lp->blitter,
                     lp->num_sampler_views[PIPE_SHADER_FRAGMENT],
                     lp->sampler_views[PIPE_SHADER_FRAGMENT]);
   util_blitter_save_render_condition(lp->blitter, lp->render_cond_query,
                                      lp->render_cond_cond, lp->render_cond_mode);
   util_blitter_blit(lp->blitter, &info);
}


static struct pipe_surface *
llvmpipe_create_surface(struct pipe_context *pipe,
                        struct pipe_resource *pt,
                        const struct pipe_surface *surf_tmpl)
{
   struct pipe_surface *ps;

   if (!(pt->bind & (PIPE_BIND_DEPTH_STENCIL | PIPE_BIND_RENDER_TARGET)))
      debug_printf("Illegal surface creation without bind flag\n");

   ps = CALLOC_STRUCT(pipe_surface);
   if (ps) {
      pipe_reference_init(&ps->reference, 1);
      pipe_resource_reference(&ps->texture, pt);
      ps->context = pipe;
      ps->format = surf_tmpl->format;
      if (llvmpipe_resource_is_texture(pt)) {
         assert(surf_tmpl->u.tex.level <= pt->last_level);
         assert(surf_tmpl->u.tex.first_layer <= surf_tmpl->u.tex.last_layer);
         ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
         ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
         ps->u.tex.level = surf_tmpl->u.tex.level;
         ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
         ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
      }
      else {
         /* setting width as number of elements should get us correct renderbuffer width */
         ps->width = surf_tmpl->u.buf.last_element - surf_tmpl->u.buf.first_element + 1;
         ps->height = pt->height0;
         ps->u.buf.first_element = surf_tmpl->u.buf.first_element;
         ps->u.buf.last_element = surf_tmpl->u.buf.last_element;
         assert(ps->u.buf.first_element <= ps->u.buf.last_element);
         assert(util_format_get_blocksize(surf_tmpl->format) *
                (ps->u.buf.last_element + 1) <= pt->width0);
a166 52
   return ps;
}


static void
llvmpipe_surface_destroy(struct pipe_context *pipe,
                         struct pipe_surface *surf)
{
   /* Effectively do the texture_update work here - if texture images
    * needed post-processing to put them into hardware layout, this is
    * where it would happen.  For llvmpipe, nothing to do.
    */
   assert(surf->texture);
   pipe_resource_reference(&surf->texture, NULL);
   FREE(surf);
}


static void
llvmpipe_clear_render_target(struct pipe_context *pipe,
                             struct pipe_surface *dst,
                             const union pipe_color_union *color,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);

   if (!llvmpipe_check_render_cond(llvmpipe))
      return;

   util_clear_render_target(pipe, dst, color,
                            dstx, dsty, width, height);
}


static void
llvmpipe_clear_depth_stencil(struct pipe_context *pipe,
                             struct pipe_surface *dst,
                             unsigned clear_flags,
                             double depth,
                             unsigned stencil,
                             unsigned dstx, unsigned dsty,
                             unsigned width, unsigned height)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);

   if (!llvmpipe_check_render_cond(llvmpipe))
      return;

   util_clear_depth_stencil(pipe, dst, clear_flags,
                            depth, stencil,
                            dstx, dsty, width, height);
a172 5
   lp->pipe.clear_render_target = llvmpipe_clear_render_target;
   lp->pipe.clear_depth_stencil = llvmpipe_clear_depth_stencil;
   lp->pipe.create_surface = llvmpipe_create_surface;
   lp->pipe.surface_destroy = llvmpipe_surface_destroy;
   /* These two are not actually functions dealing with surfaces */
d174 2
a175 1
   lp->pipe.blit = lp_blit;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a235 6
static void
lp_flush_resource(struct pipe_context *ctx, struct pipe_resource *resource)
{
}


a336 1
   lp->pipe.flush_resource = lp_flush_resource;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d38 16
d67 1
d97 19
a115 9
   /* make sure display target resources (which cannot have levels/layers) are mapped */
   if (src_tex->dt)
      (void) llvmpipe_resource_map(src, src_level, 0, LP_TEX_USAGE_READ);
   if (dst_tex->dt)
      /*
       * Could set this to WRITE_ALL if complete dst is covered but it gets
       * ignored anyway.
       */
      (void) llvmpipe_resource_map(dst, dst_level, 0, LP_TEX_USAGE_READ_WRITE);
d117 35
a173 6

   if (src_tex->dt)
      llvmpipe_resource_unmap(src, 0, 0);
   if (dst_tex->dt)
      llvmpipe_resource_unmap(dst, 0, 0);

a181 3

   if (blit_info->render_condition_enable && !llvmpipe_check_render_cond(lp))
      return;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a37 16
/**
 * Adjust x, y, width, height to lie on tile bounds.
 */
static void
adjust_to_tile_bounds(unsigned x, unsigned y, unsigned width, unsigned height,
                      unsigned *x_tile, unsigned *y_tile,
                      unsigned *w_tile, unsigned *h_tile)
{
   *x_tile = x & ~(TILE_SIZE - 1);
   *y_tile = y & ~(TILE_SIZE - 1);
   *w_tile = ((x + width + TILE_SIZE - 1) & ~(TILE_SIZE - 1)) - *x_tile;
   *h_tile = ((y + height + TILE_SIZE - 1) & ~(TILE_SIZE - 1)) - *y_tile;
}



a50 1
   unsigned z;
d80 9
a88 19
   for (z = 0; z < src_box->depth; z++){

      /* set src tiles to linear layout */
      {
         unsigned tx, ty, tw, th;
         unsigned x, y;

         adjust_to_tile_bounds(src_box->x, src_box->y, width, height,
                               &tx, &ty, &tw, &th);

         for (y = 0; y < th; y += TILE_SIZE) {
            for (x = 0; x < tw; x += TILE_SIZE) {
               (void) llvmpipe_get_texture_tile_linear(src_tex,
                                                       src_box->z + z, src_level,
                                                       LP_TEX_USAGE_READ,
                                                       tx + x, ty + y);
            }
         }
      }
a89 35
      /* set dst tiles to linear layout */
      {
         unsigned tx, ty, tw, th;
         unsigned x, y;
         enum lp_texture_usage usage;

         adjust_to_tile_bounds(dstx, dsty, width, height, &tx, &ty, &tw, &th);

         for (y = 0; y < th; y += TILE_SIZE) {
            boolean contained_y = ty + y >= dsty &&
                                  ty + y + TILE_SIZE <= dsty + height ?
                                  TRUE : FALSE;

            for (x = 0; x < tw; x += TILE_SIZE) {
               boolean contained_x = tx + x >= dstx &&
                                     tx + x + TILE_SIZE <= dstx + width ?
                                     TRUE : FALSE;

               /*
                * Set the usage mode to WRITE_ALL for the tiles which are
                * completely contained by the dest rectangle.
                */
               if (contained_y && contained_x)
                  usage = LP_TEX_USAGE_WRITE_ALL;
               else
                  usage = LP_TEX_USAGE_READ_WRITE;

               (void) llvmpipe_get_texture_tile_linear(dst_tex,
                                                       dstz + z, dst_level,
                                                       usage,
                                                       tx + x, ty + y);
            }
         }
      }
   }
d112 6
d126 3
@


