head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.35;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.59;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.31;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.39;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2010 VMware.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_simple_list.h"
#include "os/os_time.h"
#include "gallivm/lp_bld_arit.h"
#include "gallivm/lp_bld_bitarit.h"
#include "gallivm/lp_bld_const.h"
#include "gallivm/lp_bld_debug.h"
#include "gallivm/lp_bld_init.h"
#include "gallivm/lp_bld_logic.h"
#include "gallivm/lp_bld_intr.h"
#include "gallivm/lp_bld_flow.h"
#include "gallivm/lp_bld_type.h"

#include "lp_perf.h"
#include "lp_debug.h"
#include "lp_flush.h"
#include "lp_screen.h"
#include "lp_context.h"
#include "lp_state.h"
#include "lp_state_fs.h"
#include "lp_state_setup.h"


/* currently organized to interpolate full float[4] attributes even
 * when some elements are unused.  Later, can pack vertex data more
 * closely.
 */


struct lp_setup_args
{
   /* Function arguments:
    */
   LLVMValueRef v0;
   LLVMValueRef v1;
   LLVMValueRef v2;
   LLVMValueRef facing;		/* boolean */
   LLVMValueRef a0;
   LLVMValueRef dadx;
   LLVMValueRef dady;

   /* Derived:
    */
   LLVMValueRef x0_center;
   LLVMValueRef y0_center;
   LLVMValueRef dy20_ooa;
   LLVMValueRef dy01_ooa;
   LLVMValueRef dx20_ooa;
   LLVMValueRef dx01_ooa;
   struct lp_build_context bld;
};


static void
store_coef(struct gallivm_state *gallivm,
	   struct lp_setup_args *args,
	   unsigned slot,
	   LLVMValueRef a0,
	   LLVMValueRef dadx,
	   LLVMValueRef dady)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef idx = lp_build_const_int32(gallivm, slot);

   LLVMBuildStore(builder,
		  a0, 
		  LLVMBuildGEP(builder, args->a0, &idx, 1, ""));

   LLVMBuildStore(builder,
		  dadx, 
		  LLVMBuildGEP(builder, args->dadx, &idx, 1, ""));

   LLVMBuildStore(builder,
		  dady, 
		  LLVMBuildGEP(builder, args->dady, &idx, 1, ""));
}



static void 
emit_constant_coef4(struct gallivm_state *gallivm,
                    struct lp_setup_args *args,
                    unsigned slot,
                    LLVMValueRef vert)
{
   store_coef(gallivm, args, slot, vert, args->bld.zero, args->bld.zero);
}



/**
 * Setup the fragment input attribute with the front-facing value.
 * \param frontface  is the triangle front facing?
 */
static void 
emit_facing_coef(struct gallivm_state *gallivm,
                 struct lp_setup_args *args,
                 unsigned slot )
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
   LLVMValueRef a0_0 = args->facing;
   LLVMValueRef a0_0f = LLVMBuildSIToFP(builder, a0_0, float_type, "");
   LLVMValueRef a0, face_val;
   const unsigned char swizzles[4] = { PIPE_SWIZZLE_RED, PIPE_SWIZZLE_ZERO,
                                       PIPE_SWIZZLE_ZERO, PIPE_SWIZZLE_ZERO };
   /* Our face val is either 1 or 0 so we do
    * face = (val * 2) - 1
    * to make it 1 or -1
    */
   face_val =
      LLVMBuildFAdd(builder,
                    LLVMBuildFMul(builder, a0_0f,
                                  lp_build_const_float(gallivm, 2.0),
                                  ""),
                    lp_build_const_float(gallivm, -1.0),
                    "facing");
   face_val = lp_build_broadcast_scalar(&args->bld, face_val);
   a0 = lp_build_swizzle_aos(&args->bld, face_val, swizzles);

   store_coef(gallivm, args, slot, a0, args->bld.zero, args->bld.zero);
}


static LLVMValueRef
vert_attrib(struct gallivm_state *gallivm,
            LLVMValueRef vert,
            int attr,
            int elem,
            const char *name)
{
   LLVMBuilderRef b = gallivm->builder;
   LLVMValueRef idx[2];
   idx[0] = lp_build_const_int32(gallivm, attr);
   idx[1] = lp_build_const_int32(gallivm, elem);
   return LLVMBuildLoad(b, LLVMBuildGEP(b, vert, idx, 2, ""), name);
}


static void
lp_twoside(struct gallivm_state *gallivm,
           struct lp_setup_args *args,
           const struct lp_setup_variant_key *key,
           int bcolor_slot,
           LLVMValueRef attribv[3])
{
   LLVMBuilderRef b = gallivm->builder;
   LLVMValueRef a0_back, a1_back, a2_back;
   LLVMValueRef idx2 = lp_build_const_int32(gallivm, bcolor_slot);

   LLVMValueRef facing = args->facing;
   LLVMValueRef front_facing = LLVMBuildICmp(b, LLVMIntEQ, facing,
                                             lp_build_const_int32(gallivm, 0), ""); /** need i1 for if condition */

   a0_back = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v0, &idx2, 1, ""), "v0a_back");
   a1_back = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v1, &idx2, 1, ""), "v1a_back");
   a2_back = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v2, &idx2, 1, ""), "v2a_back");

   /* Possibly swap the front and back attrib values,
    *
    * Prefer select to if so we don't have to worry about phis or
    * allocas.
    */
   attribv[0] = LLVMBuildSelect(b, front_facing, a0_back, attribv[0], "");
   attribv[1] = LLVMBuildSelect(b, front_facing, a1_back, attribv[1], "");
   attribv[2] = LLVMBuildSelect(b, front_facing, a2_back, attribv[2], "");

}

static void
lp_do_offset_tri(struct gallivm_state *gallivm,
                 struct lp_setup_args *args,
                 const struct lp_setup_variant_key *key,
                 LLVMValueRef inv_det,
                 LLVMValueRef dxyz01,
                 LLVMValueRef dxyz20,
                 LLVMValueRef attribv[3])
{
   LLVMBuilderRef b = gallivm->builder;
   struct lp_build_context flt_scalar_bld;
   struct lp_build_context int_scalar_bld;
   struct lp_build_context *bld = &args->bld;
   LLVMValueRef zoffset, mult;
   LLVMValueRef z0_new, z1_new, z2_new;
   LLVMValueRef dzdxdzdy, dzdx, dzdy, dzxyz20, dyzzx01, dyzzx01_dzxyz20, dzx01_dyz20;
   LLVMValueRef z0z1, z0z1z2;
   LLVMValueRef max, max_value, res12;
   LLVMValueRef shuffles[4];
   LLVMTypeRef shuf_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMValueRef onei = lp_build_const_int32(gallivm, 1);
   LLVMValueRef zeroi = lp_build_const_int32(gallivm, 0);
   LLVMValueRef twoi = lp_build_const_int32(gallivm, 2);
   LLVMValueRef threei  = lp_build_const_int32(gallivm, 3);

   /* (res12) = cross(e,f).xy */
   shuffles[0] = twoi;
   shuffles[1] = zeroi;
   shuffles[2] = onei;
   shuffles[3] = twoi;
   dzxyz20 = LLVMBuildShuffleVector(b, dxyz20, dxyz20, LLVMConstVector(shuffles, 4), "");

   shuffles[0] = onei;
   shuffles[1] = twoi;
   shuffles[2] = twoi;
   shuffles[3] = zeroi;
   dyzzx01 = LLVMBuildShuffleVector(b, dxyz01, dxyz01, LLVMConstVector(shuffles, 4), "");

   dyzzx01_dzxyz20 = LLVMBuildFMul(b, dzxyz20, dyzzx01, "dyzzx01_dzxyz20");

   shuffles[0] = twoi;
   shuffles[1] = threei;
   shuffles[2] = LLVMGetUndef(shuf_type);
   shuffles[3] = LLVMGetUndef(shuf_type);
   dzx01_dyz20 = LLVMBuildShuffleVector(b, dyzzx01_dzxyz20, dyzzx01_dzxyz20,
                                        LLVMConstVector(shuffles, 4), "");

   res12 = LLVMBuildFSub(b, dyzzx01_dzxyz20, dzx01_dyz20, "res12");

   /* dzdx = fabsf(res1 * inv_det), dydx = fabsf(res2 * inv_det)*/
   dzdxdzdy = LLVMBuildFMul(b, res12, inv_det, "dzdxdzdy");
   dzdxdzdy = lp_build_abs(bld, dzdxdzdy);

   dzdx = LLVMBuildExtractElement(b, dzdxdzdy, zeroi, "");
   dzdy = LLVMBuildExtractElement(b, dzdxdzdy, onei, "");

   /* mult = MAX2(dzdx, dzdy) * pgon_offset_scale */
   max = LLVMBuildFCmp(b, LLVMRealUGT, dzdx, dzdy, "");
   max_value = LLVMBuildSelect(b, max, dzdx, dzdy, "max"); 

   mult = LLVMBuildFMul(b, max_value,
                        lp_build_const_float(gallivm, key->pgon_offset_scale), "");

   lp_build_context_init(&flt_scalar_bld, gallivm, lp_type_float_vec(32, 32));

   if (key->floating_point_depth) {
      /*
       * bias = pgon_offset_units * 2^(exponent(max(z0, z1, z2)) - mantissa_bits) +
       *           MAX2(dzdx, dzdy) * pgon_offset_scale
       *
       * NOTE: Assumes IEEE float32.
       */
      LLVMValueRef c23_shifted, exp_mask, bias, exp;
      LLVMValueRef maxz_value, maxz0z1_value;

      lp_build_context_init(&int_scalar_bld, gallivm, lp_type_int_vec(32, 32));

      c23_shifted = lp_build_const_int32(gallivm, 23 << 23);
      exp_mask = lp_build_const_int32(gallivm, 0xff << 23);

      maxz0z1_value = lp_build_max(&flt_scalar_bld,
                         LLVMBuildExtractElement(b, attribv[0], twoi, ""),
                         LLVMBuildExtractElement(b, attribv[1], twoi, ""));

      maxz_value = lp_build_max(&flt_scalar_bld,
                      LLVMBuildExtractElement(b, attribv[2], twoi, ""),
                      maxz0z1_value);

      exp = LLVMBuildBitCast(b, maxz_value, int_scalar_bld.vec_type, "");
      exp = lp_build_and(&int_scalar_bld, exp, exp_mask);
      exp = lp_build_sub(&int_scalar_bld, exp, c23_shifted);
      /* Clamping to zero means mrd will be zero for very small numbers,
       * but specs do not indicate this should be prevented by clamping
       * mrd to smallest normal number instead. */
      exp = lp_build_max(&int_scalar_bld, exp, int_scalar_bld.zero);
      exp = LLVMBuildBitCast(b, exp, flt_scalar_bld.vec_type, "");

      bias = LLVMBuildFMul(b, exp,
                           lp_build_const_float(gallivm, key->pgon_offset_units),
                           "bias");

      zoffset = LLVMBuildFAdd(b, bias, mult, "zoffset");
   } else {
      /*
       * bias = pgon_offset_units + MAX2(dzdx, dzdy) * pgon_offset_scale
       */
      zoffset = LLVMBuildFAdd(b,
                              lp_build_const_float(gallivm, key->pgon_offset_units),
                              mult, "zoffset");
   }

   if (key->pgon_offset_clamp > 0) {
      zoffset = lp_build_min(&flt_scalar_bld,
                             lp_build_const_float(gallivm, key->pgon_offset_clamp),
                             zoffset);
   }
   else if (key->pgon_offset_clamp < 0) {
      zoffset = lp_build_max(&flt_scalar_bld,
                             lp_build_const_float(gallivm, key->pgon_offset_clamp),
                             zoffset);
   }

   /* yuck */
   shuffles[0] = twoi;
   shuffles[1] = lp_build_const_int32(gallivm, 6);
   shuffles[2] = LLVMGetUndef(shuf_type);
   shuffles[3] = LLVMGetUndef(shuf_type);
   z0z1 = LLVMBuildShuffleVector(b, attribv[0], attribv[1], LLVMConstVector(shuffles, 4), "");
   shuffles[0] = zeroi;
   shuffles[1] = onei;
   shuffles[2] = lp_build_const_int32(gallivm, 6);
   shuffles[3] = LLVMGetUndef(shuf_type);
   z0z1z2 = LLVMBuildShuffleVector(b, z0z1, attribv[2], LLVMConstVector(shuffles, 4), "");
   zoffset = lp_build_broadcast_scalar(bld, zoffset);

   /* clamp and do offset */
   /*
    * FIXME I suspect the clamp (is that even right to always clamp to fixed
    * 0.0/1.0?) should really be per fragment?
    */
   z0z1z2 = lp_build_clamp(bld, LLVMBuildFAdd(b, z0z1z2, zoffset, ""), bld->zero, bld->one);

   /* insert into args->a0.z, a1.z, a2.z:
    */
   z0_new = LLVMBuildExtractElement(b, z0z1z2, zeroi, "");
   z1_new = LLVMBuildExtractElement(b, z0z1z2, onei, "");
   z2_new = LLVMBuildExtractElement(b, z0z1z2, twoi, "");
   attribv[0] = LLVMBuildInsertElement(b, attribv[0], z0_new, twoi, "");
   attribv[1] = LLVMBuildInsertElement(b, attribv[1], z1_new, twoi, "");
   attribv[2] = LLVMBuildInsertElement(b, attribv[2], z2_new, twoi, "");
}

static void
load_attribute(struct gallivm_state *gallivm,
               struct lp_setup_args *args,
               const struct lp_setup_variant_key *key,
               unsigned vert_attr,
               LLVMValueRef attribv[3])
{
   LLVMBuilderRef b = gallivm->builder;
   LLVMValueRef idx = lp_build_const_int32(gallivm, vert_attr);

   /* Load the vertex data
    */
   attribv[0] = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v0, &idx, 1, ""), "v0a");
   attribv[1] = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v1, &idx, 1, ""), "v1a");
   attribv[2] = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v2, &idx, 1, ""), "v2a");


   /* Potentially modify it according to twoside, etc:
    */
   if (key->twoside) {
      if (vert_attr == key->color_slot && key->bcolor_slot >= 0)
         lp_twoside(gallivm, args, key, key->bcolor_slot, attribv);
      else if (vert_attr == key->spec_slot && key->bspec_slot >= 0)
         lp_twoside(gallivm, args, key, key->bspec_slot, attribv);
   }
}

/*
 * FIXME: interpolation is always done wrt fb origin (0/0).
 * However, if some (small) tri is far away from the origin and gradients
 * are large, this can lead to HUGE errors, since the a0 value calculated
 * here can get very large (with the actual values inside the triangle way
 * smaller), leading to complete loss of accuracy. This could be prevented
 * by using some point inside (or at corner) of the tri as interpolation
 * origin, or just use barycentric interpolation (which GL suggests and is
 * what real hw does - you can get the barycentric coordinates from the
 * edge functions in rasterization in principle (though we skip these
 * sometimes completely in case of tris covering a block fully,
 * which obviously wouldn't work)).
 */
static void 
emit_coef4( struct gallivm_state *gallivm,
            struct lp_setup_args *args,
            unsigned slot,
            LLVMValueRef a0,
            LLVMValueRef a1,
            LLVMValueRef a2)
{
   LLVMBuilderRef b = gallivm->builder;
   LLVMValueRef attr_0;
   LLVMValueRef dy20_ooa = args->dy20_ooa;
   LLVMValueRef dy01_ooa = args->dy01_ooa;
   LLVMValueRef dx20_ooa = args->dx20_ooa;
   LLVMValueRef dx01_ooa = args->dx01_ooa;
   LLVMValueRef x0_center = args->x0_center;
   LLVMValueRef y0_center = args->y0_center;
   LLVMValueRef da01 = LLVMBuildFSub(b, a0, a1, "da01");
   LLVMValueRef da20 = LLVMBuildFSub(b, a2, a0, "da20");

   /* Calculate dadx (vec4f)
    */
   LLVMValueRef da01_dy20_ooa = LLVMBuildFMul(b, da01, dy20_ooa, "da01_dy20_ooa");
   LLVMValueRef da20_dy01_ooa = LLVMBuildFMul(b, da20, dy01_ooa, "da20_dy01_ooa");
   LLVMValueRef dadx          = LLVMBuildFSub(b, da01_dy20_ooa, da20_dy01_ooa, "dadx");

   /* Calculate dady (vec4f)
    */
   LLVMValueRef da01_dx20_ooa = LLVMBuildFMul(b, da01, dx20_ooa, "da01_dx20_ooa");
   LLVMValueRef da20_dx01_ooa = LLVMBuildFMul(b, da20, dx01_ooa, "da20_dx01_ooa");
   LLVMValueRef dady          = LLVMBuildFSub(b, da20_dx01_ooa, da01_dx20_ooa, "dady");

   /* Calculate a0 - the attribute value at the origin
    */
   LLVMValueRef dadx_x0    = LLVMBuildFMul(b, dadx, x0_center, "dadx_x0");
   LLVMValueRef dady_y0    = LLVMBuildFMul(b, dady, y0_center, "dady_y0");
   LLVMValueRef attr_v0    = LLVMBuildFAdd(b, dadx_x0, dady_y0, "attr_v0");
   attr_0                  = LLVMBuildFSub(b, a0, attr_v0, "attr_0");

   store_coef(gallivm, args, slot, attr_0, dadx, dady);
}


static void 
emit_linear_coef( struct gallivm_state *gallivm,
                  struct lp_setup_args *args,
                  unsigned slot,
                  LLVMValueRef attribv[3])
{
   /* nothing to do anymore */
   emit_coef4(gallivm,
              args, slot, 
              attribv[0],
              attribv[1],
              attribv[2]);
}


/**
 * Compute a0, dadx and dady for a perspective-corrected interpolant,
 * for a triangle.
 * We basically multiply the vertex value by 1/w before computing
 * the plane coefficients (a0, dadx, dady).
 * Later, when we compute the value at a particular fragment position we'll
 * divide the interpolated value by the interpolated W at that fragment.
 */
static void 
apply_perspective_corr( struct gallivm_state *gallivm,
                        struct lp_setup_args *args,
                        unsigned slot,
                        LLVMValueRef attribv[3])
{
   LLVMBuilderRef b = gallivm->builder;

   /* premultiply by 1/w  (v[0][3] is always 1/w):
    */
   LLVMValueRef v0_oow = lp_build_broadcast_scalar(&args->bld,
                            vert_attrib(gallivm, args->v0, 0, 3, "v0_oow"));
   LLVMValueRef v1_oow = lp_build_broadcast_scalar(&args->bld,
                            vert_attrib(gallivm, args->v1, 0, 3, "v1_oow"));
   LLVMValueRef v2_oow = lp_build_broadcast_scalar(&args->bld,
                            vert_attrib(gallivm, args->v2, 0, 3, "v2_oow"));

   attribv[0] = LLVMBuildFMul(b, attribv[0], v0_oow, "v0_oow_v0a");
   attribv[1] = LLVMBuildFMul(b, attribv[1], v1_oow, "v1_oow_v1a");
   attribv[2] = LLVMBuildFMul(b, attribv[2], v2_oow, "v2_oow_v2a");
}


/**
 * Applys cylindrical wrapping to vertex attributes if enabled.
 * Input coordinates must be in [0, 1] range, otherwise results are undefined.
 *
 * @@param cyl_wrap  TGSI_CYLINDRICAL_WRAP_x flags
 */
static void
emit_apply_cyl_wrap(struct gallivm_state *gallivm,
                    struct lp_setup_args *args,
                    uint cyl_wrap,
                    LLVMValueRef attribv[3])

{
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type type = args->bld.type;
   LLVMTypeRef float_vec_type = args->bld.vec_type;
   LLVMValueRef pos_half;
   LLVMValueRef neg_half;
   LLVMValueRef cyl_mask;
   LLVMValueRef offset;
   LLVMValueRef delta;
   LLVMValueRef one;

   if (!cyl_wrap)
      return;

   /* Constants */
   pos_half = lp_build_const_vec(gallivm, type, +0.5f);
   neg_half = lp_build_const_vec(gallivm, type, -0.5f);
   cyl_mask = lp_build_const_mask_aos(gallivm, type, cyl_wrap, 4);

   one = lp_build_const_vec(gallivm, type, 1.0f);
   one = LLVMBuildBitCast(builder, one, lp_build_int_vec_type(gallivm, type), "");
   one = LLVMBuildAnd(builder, one, cyl_mask, "");

   /* Edge v0 -> v1 */
   delta = LLVMBuildFSub(builder, attribv[1], attribv[0], "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_GREATER, delta, pos_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[0] = LLVMBuildFAdd(builder, attribv[0], offset, "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_LESS, delta, neg_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[1] = LLVMBuildFAdd(builder, attribv[1], offset, "");

   /* Edge v1 -> v2 */
   delta = LLVMBuildFSub(builder, attribv[2], attribv[1], "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_GREATER, delta, pos_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[1] = LLVMBuildFAdd(builder, attribv[1], offset, "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_LESS, delta, neg_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[2] = LLVMBuildFAdd(builder, attribv[2], offset, "");

   /* Edge v2 -> v0 */
   delta = LLVMBuildFSub(builder, attribv[0], attribv[2], "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_GREATER, delta, pos_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[2] = LLVMBuildFAdd(builder, attribv[2], offset, "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_LESS, delta, neg_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[0] = LLVMBuildFAdd(builder, attribv[0], offset, "");
}


/**
 * Compute the inputs-> dadx, dady, a0 values.
 */
static void 
emit_tri_coef( struct gallivm_state *gallivm,
               const struct lp_setup_variant_key *key,
               struct lp_setup_args *args)
{
   unsigned slot;

   LLVMValueRef attribs[3];

  /* setup interpolation for all the remaining attributes:
    */
   for (slot = 0; slot < key->num_inputs; slot++) {
      switch (key->inputs[slot].interp) {
      case LP_INTERP_CONSTANT:
         load_attribute(gallivm, args, key, key->inputs[slot].src_index, attribs);
         if (key->flatshade_first) {
            emit_constant_coef4(gallivm, args, slot+1, attribs[0]);
         }
         else {
            emit_constant_coef4(gallivm, args, slot+1, attribs[2]);
         }
         break;

      case LP_INTERP_LINEAR:
         load_attribute(gallivm, args, key, key->inputs[slot].src_index, attribs);
         emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
         emit_linear_coef(gallivm, args, slot+1, attribs);
         break;

      case LP_INTERP_PERSPECTIVE:
         load_attribute(gallivm, args, key, key->inputs[slot].src_index, attribs);
         emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
         apply_perspective_corr(gallivm, args, slot+1, attribs);
         emit_linear_coef(gallivm, args, slot+1, attribs);
         break;

      case LP_INTERP_POSITION:
         /*
          * The generated pixel interpolators will pick up the coeffs from
          * slot 0.
          */
         break;

      case LP_INTERP_FACING:
         emit_facing_coef(gallivm, args, slot+1);
         break;

      default:
         assert(0);
      }
   }
}


/* XXX: generic code:
 */
static void
set_noalias(LLVMBuilderRef builder,
            LLVMValueRef function,
            const LLVMTypeRef *arg_types,
            int nr_args)
{
   int i;
   for(i = 0; i < nr_args; ++i)
      if(LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
         LLVMAddAttribute(LLVMGetParam(function, i),
            LLVMNoAliasAttribute);
}

static void
init_args(struct gallivm_state *gallivm,
          const struct lp_setup_variant_key *key,
          struct lp_setup_args *args)
{
   LLVMBuilderRef b = gallivm->builder;
   LLVMTypeRef shuf_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMValueRef onef = lp_build_const_float(gallivm, 1.0);
   LLVMValueRef onei = lp_build_const_int32(gallivm, 1);
   LLVMValueRef zeroi = lp_build_const_int32(gallivm, 0);
   LLVMValueRef pixel_center, xy0_center, dxy01, dxy20, dyx20;
   LLVMValueRef e, f, ef, ooa;
   LLVMValueRef shuffles[4], shuf10;
   LLVMValueRef attr_pos[3];
   struct lp_type typef4 = lp_type_float_vec(32, 128);
   struct lp_build_context bld;

   lp_build_context_init(&bld, gallivm, typef4);
   args->bld = bld;

   /* The internal position input is in slot zero:
    */
   load_attribute(gallivm, args, key, 0, attr_pos);

   pixel_center = lp_build_const_vec(gallivm, typef4,
                                     key->pixel_center_half ? 0.5 : 0.0);

   /*
    * xy are first two elems in v0a/v1a/v2a but just use vec4 arit
    * also offset_tri uses actually xyz in them
    */
   xy0_center = LLVMBuildFSub(b, attr_pos[0], pixel_center, "xy0_center" );

   dxy01 = LLVMBuildFSub(b, attr_pos[0], attr_pos[1], "dxy01");
   dxy20 = LLVMBuildFSub(b, attr_pos[2], attr_pos[0], "dxy20");

   shuffles[0] = onei;
   shuffles[1] = zeroi;
   shuffles[2] = LLVMGetUndef(shuf_type);
   shuffles[3] = LLVMGetUndef(shuf_type);
   shuf10 = LLVMConstVector(shuffles, 4);

   dyx20 = LLVMBuildShuffleVector(b, dxy20, dxy20, shuf10, "");

   ef = LLVMBuildFMul(b, dxy01, dyx20, "ef");
   e = LLVMBuildExtractElement(b, ef, zeroi, "");
   f = LLVMBuildExtractElement(b, ef, onei, "");

   ooa  = LLVMBuildFDiv(b, onef, LLVMBuildFSub(b, e, f, ""), "ooa");

   ooa = lp_build_broadcast_scalar(&bld, ooa);

   /* tri offset calc shares a lot of arithmetic, do it here */
   if (key->pgon_offset_scale != 0.0f || key->pgon_offset_units != 0.0f) {
      lp_do_offset_tri(gallivm, args, key, ooa, dxy01, dxy20, attr_pos);
   }

   dxy20 = LLVMBuildFMul(b, dxy20, ooa, "");
   dxy01 = LLVMBuildFMul(b, dxy01, ooa, "");

   args->dy20_ooa  = lp_build_extract_broadcast(gallivm, typef4, typef4, dxy20, onei);
   args->dy01_ooa  = lp_build_extract_broadcast(gallivm, typef4, typef4, dxy01, onei);

   args->dx20_ooa  = lp_build_extract_broadcast(gallivm, typef4, typef4, dxy20, zeroi);
   args->dx01_ooa  = lp_build_extract_broadcast(gallivm, typef4, typef4, dxy01, zeroi);

   args->x0_center = lp_build_extract_broadcast(gallivm, typef4, typef4, xy0_center, zeroi);
   args->y0_center = lp_build_extract_broadcast(gallivm, typef4, typef4, xy0_center, onei);

   emit_linear_coef(gallivm, args, 0, attr_pos);
}

/**
 * Generate the runtime callable function for the coefficient calculation.
 *
 */
static struct lp_setup_variant *
generate_setup_variant(struct lp_setup_variant_key *key,
                       struct llvmpipe_context *lp)
{
   struct lp_setup_variant *variant = NULL;
   struct gallivm_state *gallivm;
   struct lp_setup_args args;
   char func_name[256];
   LLVMTypeRef vec4f_type;
   LLVMTypeRef func_type;
   LLVMTypeRef arg_types[7];
   LLVMBasicBlockRef block;
   LLVMBuilderRef builder;
   int64_t t0 = 0, t1;

   if (0)
      goto fail;

   variant = CALLOC_STRUCT(lp_setup_variant);
   if (variant == NULL)
      goto fail;

   variant->gallivm = gallivm = gallivm_create();
   if (!variant->gallivm) {
      goto fail;
   }

   builder = gallivm->builder;

   if (LP_DEBUG & DEBUG_COUNTERS) {
      t0 = os_time_get();
   }

   memcpy(&variant->key, key, key->size);
   variant->list_item_global.base = variant;

   util_snprintf(func_name, sizeof(func_name), "fs%u_setup%u",
                 0, variant->no);

   /* Currently always deal with full 4-wide vertex attributes from
    * the vertices.
    */

   vec4f_type = LLVMVectorType(LLVMFloatTypeInContext(gallivm->context), 4);

   arg_types[0] = LLVMPointerType(vec4f_type, 0);        /* v0 */
   arg_types[1] = LLVMPointerType(vec4f_type, 0);        /* v1 */
   arg_types[2] = LLVMPointerType(vec4f_type, 0);        /* v2 */
   arg_types[3] = LLVMInt32TypeInContext(gallivm->context); /* facing */
   arg_types[4] = LLVMPointerType(vec4f_type, 0);	/* a0, aligned */
   arg_types[5] = LLVMPointerType(vec4f_type, 0);	/* dadx, aligned */
   arg_types[6] = LLVMPointerType(vec4f_type, 0);	/* dady, aligned */

   func_type = LLVMFunctionType(LLVMVoidTypeInContext(gallivm->context),
                                arg_types, Elements(arg_types), 0);

   variant->function = LLVMAddFunction(gallivm->module, func_name, func_type);
   if (!variant->function)
      goto fail;

   LLVMSetFunctionCallConv(variant->function, LLVMCCallConv);

   args.v0       = LLVMGetParam(variant->function, 0);
   args.v1       = LLVMGetParam(variant->function, 1);
   args.v2       = LLVMGetParam(variant->function, 2);
   args.facing   = LLVMGetParam(variant->function, 3);
   args.a0       = LLVMGetParam(variant->function, 4);
   args.dadx     = LLVMGetParam(variant->function, 5);
   args.dady     = LLVMGetParam(variant->function, 6);

   lp_build_name(args.v0, "in_v0");
   lp_build_name(args.v1, "in_v1");
   lp_build_name(args.v2, "in_v2");
   lp_build_name(args.facing, "in_facing");
   lp_build_name(args.a0, "out_a0");
   lp_build_name(args.dadx, "out_dadx");
   lp_build_name(args.dady, "out_dady");

   /*
    * Function body
    */
   block = LLVMAppendBasicBlockInContext(gallivm->context,
                                         variant->function, "entry");
   LLVMPositionBuilderAtEnd(builder, block);

   set_noalias(builder, variant->function, arg_types, Elements(arg_types));
   init_args(gallivm, &variant->key, &args);
   emit_tri_coef(gallivm, &variant->key, &args);

   LLVMBuildRetVoid(builder);

   gallivm_verify_function(gallivm, variant->function);

   gallivm_compile_module(gallivm);

   variant->jit_function = (lp_jit_setup_triangle)
      gallivm_jit_function(gallivm, variant->function);
   if (!variant->jit_function)
      goto fail;

   /*
    * Update timing information:
    */
   if (LP_DEBUG & DEBUG_COUNTERS) {
      t1 = os_time_get();
      LP_COUNT_ADD(llvm_compile_time, t1 - t0);
      LP_COUNT_ADD(nr_llvm_compiles, 1);
   }
   
   return variant;

fail:
   if (variant) {
      if (variant->function) {
         gallivm_free_function(gallivm,
                               variant->function,
                               variant->jit_function);
      }
      if (variant->gallivm) {
         gallivm_destroy(variant->gallivm);
      }
      FREE(variant);
   }
   
   return NULL;
}



static void
lp_make_setup_variant_key(struct llvmpipe_context *lp,
			  struct lp_setup_variant_key *key)
{
   struct lp_fragment_shader *fs = lp->fs;
   unsigned i;

   assert(sizeof key->inputs[0] == sizeof(uint));
   
   key->num_inputs = fs->info.base.num_inputs;
   key->flatshade_first = lp->rasterizer->flatshade_first;
   key->pixel_center_half = lp->rasterizer->half_pixel_center;
   key->twoside = lp->rasterizer->light_twoside;
   key->size = Offset(struct lp_setup_variant_key,
                      inputs[key->num_inputs]);

   key->color_slot  = lp->color_slot [0];
   key->bcolor_slot = lp->bcolor_slot[0];
   key->spec_slot   = lp->color_slot [1];
   key->bspec_slot  = lp->bcolor_slot[1];
   assert(key->color_slot  == lp->color_slot [0]);
   assert(key->bcolor_slot == lp->bcolor_slot[0]);
   assert(key->spec_slot   == lp->color_slot [1]);
   assert(key->bspec_slot  == lp->bcolor_slot[1]);

   /*
    * If depth is floating point, depth bias is calculated with respect
    * to the primitive's maximum Z value. Retain the original depth bias
    * value until that stage.
    */
   key->floating_point_depth = lp->floating_point_depth;

   if (key->floating_point_depth) {
      key->pgon_offset_units = (float) lp->rasterizer->offset_units;
   } else {
      key->pgon_offset_units =
         (float) (lp->rasterizer->offset_units * lp->mrd);
   }

   key->pgon_offset_scale = lp->rasterizer->offset_scale;
   key->pgon_offset_clamp = lp->rasterizer->offset_clamp;
   key->pad = 0;
   memcpy(key->inputs, fs->inputs, key->num_inputs * sizeof key->inputs[0]);
   for (i = 0; i < key->num_inputs; i++) {
      if (key->inputs[i].interp == LP_INTERP_COLOR) {
         if (lp->rasterizer->flatshade)
	    key->inputs[i].interp = LP_INTERP_CONSTANT;
	 else
	    key->inputs[i].interp = LP_INTERP_PERSPECTIVE;
      }
   }

}


static void
remove_setup_variant(struct llvmpipe_context *lp,
		     struct lp_setup_variant *variant)
{
   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      debug_printf("llvmpipe: del setup_variant #%u total %u\n",
		   variant->no, lp->nr_setup_variants);
   }

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function,
                            variant->jit_function);
   }

   if (variant->gallivm) {
      gallivm_destroy(variant->gallivm);
   }

   remove_from_list(&variant->list_item_global);
   lp->nr_setup_variants--;
   FREE(variant);
}



/* When the number of setup variants exceeds a threshold, cull a
 * fraction (currently a quarter) of them.
 */
static void
cull_setup_variants(struct llvmpipe_context *lp)
{
   struct pipe_context *pipe = &lp->pipe;
   int i;

   /*
    * XXX: we need to flush the context until we have some sort of reference
    * counting in fragment shaders as they may still be binned
    * Flushing alone might not be sufficient we need to wait on it too.
    */
   llvmpipe_finish(pipe, __FUNCTION__);

   for (i = 0; i < LP_MAX_SETUP_VARIANTS / 4; i++) {
      struct lp_setup_variant_list_item *item;
      if (is_empty_list(&lp->setup_variants_list)) {
         break;
      }
      item = last_elem(&lp->setup_variants_list);
      assert(item);
      assert(item->base);
      remove_setup_variant(lp, item->base);
   }
}


/**
 * Update fragment/vertex shader linkage state.  This is called just
 * prior to drawing something when some fragment-related state has
 * changed.
 */
void 
llvmpipe_update_setup(struct llvmpipe_context *lp)
{
   struct lp_setup_variant_key *key = &lp->setup_variant.key;
   struct lp_setup_variant *variant = NULL;
   struct lp_setup_variant_list_item *li;

   lp_make_setup_variant_key(lp, key);

   foreach(li, &lp->setup_variants_list) {
      if(li->base->key.size == key->size &&
	 memcmp(&li->base->key, key, key->size) == 0) {
         variant = li->base;
         break;
      }
   }

   if (variant) {
      move_to_head(&lp->setup_variants_list, &variant->list_item_global);
   }
   else {
      if (lp->nr_setup_variants >= LP_MAX_SETUP_VARIANTS) {
	 cull_setup_variants(lp);
      }

      variant = generate_setup_variant(key, lp);
      if (variant) {
         insert_at_head(&lp->setup_variants_list, &variant->list_item_global);
         lp->nr_setup_variants++;
         llvmpipe_variant_count++;
      }
   }

   lp_setup_set_setup_variant(lp->setup,
			      variant);
}

void
lp_delete_setup_variants(struct llvmpipe_context *lp)
{
   struct lp_setup_variant_list_item *li;
   li = first_elem(&lp->setup_variants_list);
   while(!at_end(&lp->setup_variants_list, li)) {
      struct lp_setup_variant_list_item *next = next_elem(li);
      remove_setup_variant(lp, li->base);
      li = next;
   }
}

void
lp_dump_setup_coef( const struct lp_setup_variant_key *key,
		    const float (*sa0)[4],
		    const float (*sdadx)[4],
		    const float (*sdady)[4])
{
   int i, slot;

   for (i = 0; i < TGSI_NUM_CHANNELS; i++) {
      float a0   = sa0  [0][i];
      float dadx = sdadx[0][i];
      float dady = sdady[0][i];

      debug_printf("POS.%c: a0 = %f, dadx = %f, dady = %f\n",
		   "xyzw"[i],
		   a0, dadx, dady);
   }

   for (slot = 0; slot < key->num_inputs; slot++) {
      unsigned usage_mask = key->inputs[slot].usage_mask;
      for (i = 0; i < TGSI_NUM_CHANNELS; i++) {
	 if (usage_mask & (1 << i)) {
	    float a0   = sa0  [1 + slot][i];
	    float dadx = sdadx[1 + slot][i];
	    float dady = sdady[1 + slot][i];

	    debug_printf("IN[%u].%c: a0 = %f, dadx = %f, dady = %f\n",
			 slot,
			 "xyzw"[i],
			 a0, dadx, dady);
	 }
      }
   }
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a52 4
/** Setup shader number (for debugging) */
static unsigned setup_no = 0;


d85 5
a89 5
           struct lp_setup_args *args,
           unsigned slot,
           LLVMValueRef a0,
           LLVMValueRef dadx,
           LLVMValueRef dady)
d95 2
a96 2
                  a0,
                  LLVMBuildGEP(builder, args->a0, &idx, 1, ""));
d99 2
a100 2
                  dadx,
                  LLVMBuildGEP(builder, args->dadx, &idx, 1, ""));
d103 2
a104 2
                  dady,
                  LLVMBuildGEP(builder, args->dady, &idx, 1, ""));
d710 1
a710 1
   char func_name[64];
d725 1
a725 6
   variant->no = setup_no++;

   util_snprintf(func_name, sizeof(func_name), "setup_variant_%u",
                 variant->no);

   variant->gallivm = gallivm = gallivm_create(func_name, lp->context);
d739 3
a802 2
   gallivm_free_ir(variant->gallivm);

d811 1
a811 1

d816 5
d826 1
a826 1

d834 1
a834 1
                          struct lp_setup_variant_key *key)
d840 1
a840 1

d878 3
a880 3
            key->inputs[i].interp = LP_INTERP_CONSTANT;
         else
            key->inputs[i].interp = LP_INTERP_PERSPECTIVE;
d889 1
a889 1
                     struct lp_setup_variant *variant)
d893 7
a899 1
                   variant->no, lp->nr_setup_variants);
d958 1
a958 1
         memcmp(&li->base->key, key, key->size) == 0) {
d969 1
a969 1
         cull_setup_variants(lp);
d976 1
d980 2
a981 1
   lp_setup_set_setup_variant(lp->setup, variant);
d997 4
a1000 4
lp_dump_setup_coef(const struct lp_setup_variant_key *key,
                   const float (*sa0)[4],
                   const float (*sdadx)[4],
                   const float (*sdady)[4])
d1010 2
a1011 1
                   "xyzw"[i], a0, dadx, dady);
d1017 10
a1026 8
         if (usage_mask & (1 << i)) {
            float a0   = sa0  [1 + slot][i];
            float dadx = sdadx[1 + slot][i];
            float dady = sdady[1 + slot][i];

            debug_printf("IN[%u].%c: a0 = %f, dadx = %f, dady = %f\n",
                         slot, "xyzw"[i], a0, dadx, dady);
         }
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d53 4
d89 5
a93 5
	   struct lp_setup_args *args,
	   unsigned slot,
	   LLVMValueRef a0,
	   LLVMValueRef dadx,
	   LLVMValueRef dady)
d99 2
a100 2
		  a0, 
		  LLVMBuildGEP(builder, args->a0, &idx, 1, ""));
d103 2
a104 2
		  dadx, 
		  LLVMBuildGEP(builder, args->dadx, &idx, 1, ""));
d107 2
a108 2
		  dady, 
		  LLVMBuildGEP(builder, args->dady, &idx, 1, ""));
d714 1
a714 1
   char func_name[256];
d729 6
a734 1
   variant->gallivm = gallivm = gallivm_create();
a747 3
   util_snprintf(func_name, sizeof(func_name), "fs%u_setup%u",
                 0, variant->no);

d809 2
d819 1
a819 1
   
a823 5
      if (variant->function) {
         gallivm_free_function(gallivm,
                               variant->function,
                               variant->jit_function);
      }
d829 1
a829 1
   
d837 1
a837 1
			  struct lp_setup_variant_key *key)
d843 1
a843 1
   
d881 3
a883 3
	    key->inputs[i].interp = LP_INTERP_CONSTANT;
	 else
	    key->inputs[i].interp = LP_INTERP_PERSPECTIVE;
d892 1
a892 1
		     struct lp_setup_variant *variant)
d896 1
a896 7
		   variant->no, lp->nr_setup_variants);
   }

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function,
                            variant->jit_function);
d955 1
a955 1
	 memcmp(&li->base->key, key, key->size) == 0) {
d966 1
a966 1
	 cull_setup_variants(lp);
a972 1
         llvmpipe_variant_count++;
d976 1
a976 2
   lp_setup_set_setup_variant(lp->setup,
			      variant);
d992 4
a995 4
lp_dump_setup_coef( const struct lp_setup_variant_key *key,
		    const float (*sa0)[4],
		    const float (*sdadx)[4],
		    const float (*sdady)[4])
d1005 1
a1005 2
		   "xyzw"[i],
		   a0, dadx, dady);
d1011 8
a1018 10
	 if (usage_mask & (1 << i)) {
	    float a0   = sa0  [1 + slot][i];
	    float dadx = sdadx[1 + slot][i];
	    float dady = sdady[1 + slot][i];

	    debug_printf("IN[%u].%c: a0 = %f, dadx = %f, dady = %f\n",
			 slot,
			 "xyzw"[i],
			 a0, dadx, dady);
	 }
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d34 1
a52 1

d79 1
a82 50

static LLVMTypeRef
type4f(struct gallivm_state *gallivm)
{
   return LLVMVectorType(LLVMFloatTypeInContext(gallivm->context), 4);
}


/* Equivalent of _mm_setr_ps(a,b,c,d)
 */
static LLVMValueRef
vec4f(struct gallivm_state *gallivm,
      LLVMValueRef a, LLVMValueRef b, LLVMValueRef c, LLVMValueRef d,
      const char *name)
{
   LLVMBuilderRef bld = gallivm->builder;
   LLVMValueRef i0 = lp_build_const_int32(gallivm, 0);
   LLVMValueRef i1 = lp_build_const_int32(gallivm, 1);
   LLVMValueRef i2 = lp_build_const_int32(gallivm, 2);
   LLVMValueRef i3 = lp_build_const_int32(gallivm, 3);

   LLVMValueRef res = LLVMGetUndef(type4f(gallivm));

   res = LLVMBuildInsertElement(bld, res, a, i0, "");
   res = LLVMBuildInsertElement(bld, res, b, i1, "");
   res = LLVMBuildInsertElement(bld, res, c, i2, "");
   res = LLVMBuildInsertElement(bld, res, d, i3, name);

   return res;
}

/* Equivalent of _mm_set1_ps(a)
 */
static LLVMValueRef
vec4f_from_scalar(struct gallivm_state *gallivm,
                  LLVMValueRef a,
                  const char *name)
{
   LLVMBuilderRef bld = gallivm->builder;
   LLVMValueRef res = LLVMGetUndef(type4f(gallivm));
   int i;

   for(i = 0; i < 4; ++i) {
      LLVMValueRef index = lp_build_const_int32(gallivm, i);
      res = LLVMBuildInsertElement(bld, res, a, index, i == 3 ? name : "");
   }

   return res;
}

d111 5
a115 7
		     struct lp_setup_args *args,
		     unsigned slot,
		     LLVMValueRef vert)
{
   LLVMValueRef zero      = lp_build_const_float(gallivm, 0.0);
   LLVMValueRef zerovec   = vec4f_from_scalar(gallivm, zero, "zero");
   store_coef(gallivm, args, slot, vert, zerovec, zerovec);
d126 2
a127 2
		  struct lp_setup_args *args,
		  unsigned slot )
d133 16
a148 3
   LLVMValueRef zero = lp_build_const_float(gallivm, 0.0);
   LLVMValueRef a0 = vec4f(gallivm, a0_0f, zero, zero, zero, "facing");
   LLVMValueRef zerovec = vec4f_from_scalar(gallivm, zero, "zero");
d150 1
a150 1
   store_coef(gallivm, args, slot, a0, zerovec, zerovec);
d156 4
a159 4
	    LLVMValueRef vert,
	    int attr,
	    int elem,
	    const char *name)
d181 3
a183 2
   LLVMValueRef front_facing = LLVMBuildICmp(b, LLVMIntEQ, facing, lp_build_const_int32(gallivm, 0), ""); /** need i1 for if condition */
   
a208 1
   struct lp_build_context bld;
d210 2
a248 1
   lp_build_context_init(&bld, gallivm, lp_type_float_vec(32, 128));
d250 1
a250 1
   dzdxdzdy = lp_build_abs(&bld, dzdxdzdy);
d255 1
a255 1
   /* zoffset = pgon_offset_units + MAX2(dzdx, dzdy) * pgon_offset_scale */
d261 36
a296 1
   zoffset = LLVMBuildFAdd(b,
d298 11
a308 1
                           mult, "zoffset");
a309 1
   lp_build_context_init(&flt_scalar_bld, gallivm, lp_type_float_vec(32, 32));
d332 1
a332 1
   zoffset = vec4f_from_scalar(gallivm, zoffset, "");
d339 1
a339 1
   z0z1z2 = lp_build_clamp(&bld, LLVMBuildFAdd(b, z0z1z2, zoffset, ""), bld.zero, bld.one);
d378 13
d393 5
a397 5
	    struct lp_setup_args *args,
	    unsigned slot,
	    LLVMValueRef a0,
	    LLVMValueRef a1,
	    LLVMValueRef a2)
d400 1
a406 1

d424 4
a427 4
   LLVMValueRef dadx_x0       = LLVMBuildFMul(b, dadx, x0_center, "dadx_x0"); 
   LLVMValueRef dady_y0       = LLVMBuildFMul(b, dady, y0_center, "dady_y0"); 
   LLVMValueRef attr_v0       = LLVMBuildFAdd(b, dadx_x0, dady_y0, "attr_v0"); 
   LLVMValueRef attr_0        = LLVMBuildFSub(b, a0, attr_v0, "attr_0"); 
d435 3
a437 3
		  struct lp_setup_args *args,
		  unsigned slot,
		  LLVMValueRef attribv[3])
d466 6
a471 3
   LLVMValueRef v0_oow = vec4f_from_scalar(gallivm, vert_attrib(gallivm, args->v0, 0, 3, ""), "v0_oow");
   LLVMValueRef v1_oow = vec4f_from_scalar(gallivm, vert_attrib(gallivm, args->v1, 0, 3, ""), "v1_oow");
   LLVMValueRef v2_oow = vec4f_from_scalar(gallivm, vert_attrib(gallivm, args->v2, 0, 3, ""), "v2_oow");
a478 10
static void
emit_position_coef( struct gallivm_state *gallivm,
		    struct lp_setup_args *args,
		    int slot,
		    LLVMValueRef attribv[3])
{
   emit_linear_coef(gallivm, args, slot, attribv);
}


d489 1
a489 1
		    LLVMValueRef attribv[3])
d493 2
a494 2
   struct lp_type type = lp_float32_vec4_type();
   LLVMTypeRef float_vec_type = lp_build_vec_type(gallivm, type);
d583 1
a583 1
	 emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
d589 1
a589 1
	 emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
d616 3
a618 3
	    LLVMValueRef function,
	    const LLVMTypeRef *arg_types,
	    int nr_args)
d624 1
a624 1
			  LLVMNoAliasAttribute);
d630 1
a630 1
	  struct lp_setup_args *args)
d639 1
a639 1
   LLVMValueRef shuffles[4];
d642 4
d652 1
a652 1
                                  key->pixel_center_half ? 0.5 : 0.0);
d667 1
d669 1
a669 1
   dyx20 = LLVMBuildShuffleVector(b, dxy20, dxy20, LLVMConstVector(shuffles, 4), "");
d677 1
a677 1
   ooa = vec4f_from_scalar(gallivm, ooa, "");
d696 1
a696 2
   /* might want to merge that with other coef emit in the future */
   emit_position_coef(gallivm, args, 0, attr_pos);
d740 1
a740 2
		 0,
		 variant->no);
d857 14
a870 1
   key->pgon_offset_units = (float) (lp->rasterizer->offset_units * lp->mrd);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d37 1
a40 1
#include <llvm-c/Analysis.h>	/* for LLVMVerifyFunction */
a78 6

   /* Temporary, per-attribute:
    */
   LLVMValueRef v0a;
   LLVMValueRef v1a;
   LLVMValueRef v2a;
d142 1
a142 1
   
a205 15
static LLVMValueRef
vert_clamp(LLVMBuilderRef b,
           LLVMValueRef x,
           LLVMValueRef min,
           LLVMValueRef max)
{
   LLVMValueRef min_result = LLVMBuildFCmp(b, LLVMRealUGT, min, x, "");
   LLVMValueRef max_result = LLVMBuildFCmp(b, LLVMRealUGT, x, max, "");
   LLVMValueRef clamp_value;

   clamp_value = LLVMBuildSelect(b, min_result, min, x, "");
   clamp_value = LLVMBuildSelect(b, max_result, max, x, "");

   return clamp_value;
}
d211 2
a212 1
           int bcolor_slot)
d230 3
a232 3
   args->v0a = LLVMBuildSelect(b, front_facing, a0_back, args->v0a, "");
   args->v1a = LLVMBuildSelect(b, front_facing, a1_back, args->v1a, "");
   args->v2a = LLVMBuildSelect(b, front_facing, a2_back, args->v2a, "");
d239 5
a243 1
                 const struct lp_setup_variant_key *key)
d247 1
d250 31
a280 6
   LLVMValueRef dzdx0, dzdx, dzdy0, dzdy;
   LLVMValueRef max, max_value;
   
   LLVMValueRef one  = lp_build_const_float(gallivm, 1.0);
   LLVMValueRef zero = lp_build_const_float(gallivm, 0.0);
   LLVMValueRef two  = lp_build_const_int32(gallivm, 2);
d282 1
a282 32
   /* edge vectors: e = v0 - v2, f = v1 - v2 */
   LLVMValueRef v0_x = vert_attrib(gallivm, args->v0, 0, 0, "v0_x");
   LLVMValueRef v1_x = vert_attrib(gallivm, args->v1, 0, 0, "v1_x");
   LLVMValueRef v2_x = vert_attrib(gallivm, args->v2, 0, 0, "v2_x");
   LLVMValueRef v0_y = vert_attrib(gallivm, args->v0, 0, 1, "v0_y");
   LLVMValueRef v1_y = vert_attrib(gallivm, args->v1, 0, 1, "v1_y");
   LLVMValueRef v2_y = vert_attrib(gallivm, args->v2, 0, 1, "v2_y");
   LLVMValueRef v0_z = vert_attrib(gallivm, args->v0, 0, 2, "v0_z");
   LLVMValueRef v1_z = vert_attrib(gallivm, args->v1, 0, 2, "v1_z");
   LLVMValueRef v2_z = vert_attrib(gallivm, args->v2, 0, 2, "v2_z");
 
   /* edge vectors: e = v0 - v2, f = v1 - v2 */
   LLVMValueRef dx02 = LLVMBuildFSub(b, v0_x, v2_x, "dx02");
   LLVMValueRef dy02 = LLVMBuildFSub(b, v0_y, v2_y, "dy02");
   LLVMValueRef dz02 = LLVMBuildFSub(b, v0_z, v2_z, "dz02");
   LLVMValueRef dx12 = LLVMBuildFSub(b, v1_x, v2_x, "dx12"); 
   LLVMValueRef dy12 = LLVMBuildFSub(b, v1_y, v2_y, "dy12");
   LLVMValueRef dz12 = LLVMBuildFSub(b, v1_z, v2_z, "dz12");
 
   /* det = cross(e,f).z */
   LLVMValueRef dx02_dy12  = LLVMBuildFMul(b, dx02, dy12, "dx02_dy12");
   LLVMValueRef dy02_dx12  = LLVMBuildFMul(b, dy02, dx12, "dy02_dx12");
   LLVMValueRef det  = LLVMBuildFSub(b, dx02_dy12, dy02_dx12, "det");
   LLVMValueRef inv_det = LLVMBuildFDiv(b, one, det, "inv_det"); 
   
   /* (res1,res2) = cross(e,f).xy */
   LLVMValueRef dy02_dz12    = LLVMBuildFMul(b, dy02, dz12, "dy02_dz12");
   LLVMValueRef dz02_dy12    = LLVMBuildFMul(b, dz02, dy12, "dz02_dy12");
   LLVMValueRef dz02_dx12    = LLVMBuildFMul(b, dz02, dx12, "dz02_dx12");
   LLVMValueRef dx02_dz12    = LLVMBuildFMul(b, dx02, dz12, "dx02_dz12");
   LLVMValueRef res1  = LLVMBuildFSub(b, dy02_dz12, dz02_dy12, "res1");
   LLVMValueRef res2  = LLVMBuildFSub(b, dz02_dx12, dx02_dz12, "res2");
d285 6
a290 5
   lp_build_context_init(&bld, gallivm, lp_type_float(32));
   dzdx0 = LLVMBuildFMul(b, res1, inv_det, "dzdx");
   dzdx  = lp_build_abs(&bld, dzdx0);
   dzdy0 = LLVMBuildFMul(b, res2, inv_det, "dzdy");
   dzdy  = lp_build_abs(&bld, dzdy0);
d292 1
a292 1
   /* zoffset = offset->units + MAX2(dzdx, dzdy) * offset->scale */
d296 30
a325 2
   mult = LLVMBuildFMul(b, max_value, lp_build_const_float(gallivm, key->scale), "");
   zoffset = LLVMBuildFAdd(b, lp_build_const_float(gallivm, key->units), mult, "zoffset");
d328 5
a332 3
   z0_new = vert_clamp(b, LLVMBuildFAdd(b, v0_z, zoffset, ""), zero, one);
   z1_new = vert_clamp(b, LLVMBuildFAdd(b, v1_z, zoffset, ""), zero, one);
   z2_new = vert_clamp(b, LLVMBuildFAdd(b, v2_z, zoffset, ""), zero, one);
d335 7
a341 4
    */   
   args->v0a = LLVMBuildInsertElement(b, args->v0a, z0_new, two, "");
   args->v1a = LLVMBuildInsertElement(b, args->v1a, z1_new, two, "");
   args->v2a = LLVMBuildInsertElement(b, args->v2a, z2_new, two, "");
d348 2
a349 1
               unsigned vert_attr)
d356 3
a358 3
   args->v0a = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v0, &idx, 1, ""), "v0a");
   args->v1a = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v1, &idx, 1, ""), "v1a");
   args->v2a = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v2, &idx, 1, ""), "v2a");
d361 1
a361 1
   /* Potentially modify it according to twoside, offset, etc:
a362 4
   if (vert_attr == 0 && (key->scale != 0.0f || key->units != 0.0f)) {
      lp_do_offset_tri(gallivm, args, key);
   }

d364 4
a367 4
      if (vert_attr == key->color_slot && key->bcolor_slot != ~0)
         lp_twoside(gallivm, args, key, key->bcolor_slot);
      else if (vert_attr == key->spec_slot && key->bspec_slot != ~0)
         lp_twoside(gallivm, args, key, key->bspec_slot);
a386 2
   /* XXX: using fsub, fmul on vector types -- does this work??
    */
d416 2
a417 1
		  unsigned slot)
d422 3
a424 3
              args->v0a,
              args->v1a,
              args->v2a);
d437 4
a440 3
emit_perspective_coef( struct gallivm_state *gallivm,
		       struct lp_setup_args *args,
		       unsigned slot)
d450 3
a452 5
   LLVMValueRef v0_oow_v0a = LLVMBuildFMul(b, args->v0a, v0_oow, "v0_oow_v0a");
   LLVMValueRef v1_oow_v1a = LLVMBuildFMul(b, args->v1a, v1_oow, "v1_oow_v1a");
   LLVMValueRef v2_oow_v2a = LLVMBuildFMul(b, args->v2a, v2_oow, "v2_oow_v2a");

   emit_coef4(gallivm, args, slot, v0_oow_v0a, v1_oow_v1a, v2_oow_v2a);
d459 2
a460 1
		    int slot )
d462 1
a462 1
   emit_linear_coef(gallivm, args, slot);
d466 74
d547 2
a548 2
	       const struct lp_setup_variant_key *key,
	       struct lp_setup_args *args )
d552 1
a552 4
   /* The internal position input is in slot zero:
    */
   load_attribute(gallivm, args, key, 0);
   emit_position_coef(gallivm, args, 0);
d554 1
a554 1
   /* setup interpolation for all the remaining attributes:
a556 6

      if (key->inputs[slot].interp == LP_INTERP_CONSTANT ||
          key->inputs[slot].interp == LP_INTERP_LINEAR ||
          key->inputs[slot].interp == LP_INTERP_PERSPECTIVE)
         load_attribute(gallivm, args, key, key->inputs[slot].src_index);

d559 8
a566 7
	 if (key->flatshade_first) {
	    emit_constant_coef4(gallivm, args, slot+1, args->v0a);
	 }
	 else {
	    emit_constant_coef4(gallivm, args, slot+1, args->v2a);
	 }
	 break;
d569 3
a571 1
	 emit_linear_coef(gallivm, args, slot+1);
d575 4
a578 1
	 emit_perspective_coef(gallivm, args, slot+1);
a598 56
/* XXX: This is generic code, share with fs/vs codegen:
 */
static lp_jit_setup_triangle
finalize_function(struct gallivm_state *gallivm,
		  LLVMBuilderRef builder,
		  LLVMValueRef function)
{
   void *f;

   /* Verify the LLVM IR.  If invalid, dump and abort */
#ifdef DEBUG
   if (LLVMVerifyFunction(function, LLVMPrintMessageAction)) {
      if (1)
         lp_debug_dump_value(function);
      abort();
   }
#endif

   /* Apply optimizations to LLVM IR */
   LLVMRunFunctionPassManager(gallivm->passmgr, function);

   if (gallivm_debug & GALLIVM_DEBUG_IR)
   {
      /* Print the LLVM IR to stderr */
      lp_debug_dump_value(function);
      debug_printf("\n");
   }

   /*
    * Translate the LLVM IR into machine code.
    */
   f = LLVMGetPointerToGlobal(gallivm->engine, function);

   if (gallivm_debug & GALLIVM_DEBUG_ASM)
   {
      lp_disassemble(f);
   }

   lp_func_delete_body(function);

   return f;
}

/* XXX: Generic code:
 */
static void
lp_emit_emms(struct gallivm_state *gallivm)
{
#ifdef PIPE_ARCH_X86
   /* Avoid corrupting the FPU stack on 32bit OSes. */
   lp_build_intrinsic(gallivm->builder, "llvm.x86.mmx.emms",
         LLVMVoidTypeInContext(gallivm->context), NULL, 0);
#endif
}


d608 1
a608 1
   for(i = 0; i < Elements(arg_types); ++i)
d616 2
a617 2
	  struct lp_setup_args *args,
	  const struct lp_setup_variant *variant)
d620 30
d651 1
a651 2
   LLVMValueRef v0_x = vert_attrib(gallivm, args->v0, 0, 0, "v0_x");
   LLVMValueRef v0_y = vert_attrib(gallivm, args->v0, 0, 1, "v0_y");
d653 3
a655 2
   LLVMValueRef v1_x = vert_attrib(gallivm, args->v1, 0, 0, "v1_x");
   LLVMValueRef v1_y = vert_attrib(gallivm, args->v1, 0, 1, "v1_y");
d657 1
a657 2
   LLVMValueRef v2_x = vert_attrib(gallivm, args->v2, 0, 0, "v2_x");
   LLVMValueRef v2_y = vert_attrib(gallivm, args->v2, 0, 1, "v2_y");
d659 1
a659 2
   LLVMValueRef pixel_center = lp_build_const_float(gallivm,
                                   variant->key.pixel_center_half ? 0.5 : 0);
d661 10
a670 17
   LLVMValueRef x0_center = LLVMBuildFSub(b, v0_x, pixel_center, "x0_center" );
   LLVMValueRef y0_center = LLVMBuildFSub(b, v0_y, pixel_center, "y0_center" );
   
   LLVMValueRef dx01 = LLVMBuildFSub(b, v0_x, v1_x, "dx01");
   LLVMValueRef dy01 = LLVMBuildFSub(b, v0_y, v1_y, "dy01");
   LLVMValueRef dx20 = LLVMBuildFSub(b, v2_x, v0_x, "dx20");
   LLVMValueRef dy20 = LLVMBuildFSub(b, v2_y, v0_y, "dy20");

   LLVMValueRef one  = lp_build_const_float(gallivm, 1.0);
   LLVMValueRef e    = LLVMBuildFMul(b, dx01, dy20, "e");
   LLVMValueRef f    = LLVMBuildFMul(b, dx20, dy01, "f");
   LLVMValueRef ooa  = LLVMBuildFDiv(b, one, LLVMBuildFSub(b, e, f, ""), "ooa");

   LLVMValueRef dy20_ooa = LLVMBuildFMul(b, dy20, ooa, "dy20_ooa");
   LLVMValueRef dy01_ooa = LLVMBuildFMul(b, dy01, ooa, "dy01_ooa");
   LLVMValueRef dx20_ooa = LLVMBuildFMul(b, dx20, ooa, "dx20_ooa");
   LLVMValueRef dx01_ooa = LLVMBuildFMul(b, dx01, ooa, "dx01_ooa");
d672 2
a673 2
   args->dy20_ooa  = vec4f_from_scalar(gallivm, dy20_ooa, "dy20_ooa_4f");
   args->dy01_ooa  = vec4f_from_scalar(gallivm, dy01_ooa, "dy01_ooa_4f");
d675 2
a676 2
   args->dx20_ooa  = vec4f_from_scalar(gallivm, dx20_ooa, "dx20_ooa_4f");
   args->dx01_ooa  = vec4f_from_scalar(gallivm, dx01_ooa, "dx01_ooa_4f");
d678 2
a679 2
   args->x0_center = vec4f_from_scalar(gallivm, x0_center, "x0_center_4f");
   args->y0_center = vec4f_from_scalar(gallivm, y0_center, "y0_center_4f");
d687 1
a687 2
generate_setup_variant(struct gallivm_state *gallivm,
		       struct lp_setup_variant_key *key,
d691 1
d698 1
a698 1
   LLVMBuilderRef builder = gallivm->builder;
d708 7
d773 1
a773 1
   init_args(gallivm, &args, variant);
a775 1
   lp_emit_emms(gallivm);
d778 6
a783 2
   variant->jit_function = finalize_function(gallivm, builder,
					     variant->function);
d801 6
a806 4
	 if (variant->jit_function)
	    LLVMFreeMachineCodeForFunction(gallivm->engine,
					   variant->function);
	 LLVMDeleteFunction(variant->function);
d823 1
a823 1
   assert(sizeof key->inputs[0] == sizeof(ushort));
d827 1
a827 1
   key->pixel_center_half = lp->rasterizer->gl_rasterization_rules;
d830 3
a832 2
		      inputs[key->num_inputs]);
   key->color_slot = lp->color_slot[0];
d834 10
a843 4
   key->spec_slot = lp->color_slot[1];
   key->bspec_slot = lp->bcolor_slot[1];
   key->units = (float) (lp->rasterizer->offset_units * lp->mrd);
   key->scale = lp->rasterizer->offset_scale;
d851 1
a851 1
	    key->inputs[i].interp = LP_INTERP_LINEAR;
d868 7
a874 4
      if (variant->jit_function)
	 LLVMFreeMachineCodeForFunction(lp->gallivm->engine,
					variant->function);
      LLVMDeleteFunction(variant->function);
d901 7
a907 1
      struct lp_setup_variant_list_item *item = last_elem(&lp->setup_variants_list);
d943 6
a948 5
      variant = generate_setup_variant(lp->gallivm, key, lp);
      insert_at_head(&lp->setup_variants_list, &variant->list_item_global);
      lp->nr_setup_variants++;

      llvmpipe_variant_count++;
d975 1
a975 1
   for (i = 0; i < NUM_CHANNELS; i++) {
d987 1
a987 1
      for (i = 0; i < NUM_CHANNELS; i++) {
@


1.1
log
@Initial revision
@
text
@d654 1
a654 1
   int64_t t0, t1;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a36 1
#include "gallivm/lp_bld_logic.h"
d40 1
d79 6
d148 1
a148 1

d212 15
d232 1
a232 2
           int bcolor_slot,
           LLVMValueRef attribv[3])
d250 3
a252 3
   attribv[0] = LLVMBuildSelect(b, front_facing, a0_back, attribv[0], "");
   attribv[1] = LLVMBuildSelect(b, front_facing, a1_back, attribv[1], "");
   attribv[2] = LLVMBuildSelect(b, front_facing, a2_back, attribv[2], "");
d259 1
a259 5
                 const struct lp_setup_variant_key *key,
                 LLVMValueRef inv_det,
                 LLVMValueRef dxyz01,
                 LLVMValueRef dxyz20,
                 LLVMValueRef attribv[3])
a262 1
   struct lp_build_context flt_scalar_bld;
d265 6
a270 31
   LLVMValueRef dzdxdzdy, dzdx, dzdy, dzxyz20, dyzzx01, dyzzx01_dzxyz20, dzx01_dyz20;
   LLVMValueRef z0z1, z0z1z2;
   LLVMValueRef max, max_value, res12;
   LLVMValueRef shuffles[4];
   LLVMTypeRef shuf_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMValueRef onei = lp_build_const_int32(gallivm, 1);
   LLVMValueRef zeroi = lp_build_const_int32(gallivm, 0);
   LLVMValueRef twoi = lp_build_const_int32(gallivm, 2);
   LLVMValueRef threei  = lp_build_const_int32(gallivm, 3);

   /* (res12) = cross(e,f).xy */
   shuffles[0] = twoi;
   shuffles[1] = zeroi;
   shuffles[2] = onei;
   shuffles[3] = twoi;
   dzxyz20 = LLVMBuildShuffleVector(b, dxyz20, dxyz20, LLVMConstVector(shuffles, 4), "");

   shuffles[0] = onei;
   shuffles[1] = twoi;
   shuffles[2] = twoi;
   shuffles[3] = zeroi;
   dyzzx01 = LLVMBuildShuffleVector(b, dxyz01, dxyz01, LLVMConstVector(shuffles, 4), "");

   dyzzx01_dzxyz20 = LLVMBuildFMul(b, dzxyz20, dyzzx01, "dyzzx01_dzxyz20");

   shuffles[0] = twoi;
   shuffles[1] = threei;
   shuffles[2] = LLVMGetUndef(shuf_type);
   shuffles[3] = LLVMGetUndef(shuf_type);
   dzx01_dyz20 = LLVMBuildShuffleVector(b, dyzzx01_dzxyz20, dyzzx01_dzxyz20,
                                        LLVMConstVector(shuffles, 4), "");
d272 32
a303 1
   res12 = LLVMBuildFSub(b, dyzzx01_dzxyz20, dzx01_dyz20, "res12");
d306 5
a310 6
   lp_build_context_init(&bld, gallivm, lp_type_float_vec(32, 128));
   dzdxdzdy = LLVMBuildFMul(b, res12, inv_det, "dzdxdzdy");
   dzdxdzdy = lp_build_abs(&bld, dzdxdzdy);

   dzdx = LLVMBuildExtractElement(b, dzdxdzdy, zeroi, "");
   dzdy = LLVMBuildExtractElement(b, dzdxdzdy, onei, "");
d312 1
a312 1
   /* zoffset = pgon_offset_units + MAX2(dzdx, dzdy) * pgon_offset_scale */
d316 2
a317 30
   mult = LLVMBuildFMul(b, max_value,
                        lp_build_const_float(gallivm, key->pgon_offset_scale), "");
   zoffset = LLVMBuildFAdd(b,
                           lp_build_const_float(gallivm, key->pgon_offset_units),
                           mult, "zoffset");

   lp_build_context_init(&flt_scalar_bld, gallivm, lp_type_float_vec(32, 32));
   if (key->pgon_offset_clamp > 0) {
      zoffset = lp_build_min(&flt_scalar_bld,
                             lp_build_const_float(gallivm, key->pgon_offset_clamp),
                             zoffset);
   }
   else if (key->pgon_offset_clamp < 0) {
      zoffset = lp_build_max(&flt_scalar_bld,
                             lp_build_const_float(gallivm, key->pgon_offset_clamp),
                             zoffset);
   }

   /* yuck */
   shuffles[0] = twoi;
   shuffles[1] = lp_build_const_int32(gallivm, 6);
   shuffles[2] = LLVMGetUndef(shuf_type);
   shuffles[3] = LLVMGetUndef(shuf_type);
   z0z1 = LLVMBuildShuffleVector(b, attribv[0], attribv[1], LLVMConstVector(shuffles, 4), "");
   shuffles[0] = zeroi;
   shuffles[1] = onei;
   shuffles[2] = lp_build_const_int32(gallivm, 6);
   shuffles[3] = LLVMGetUndef(shuf_type);
   z0z1z2 = LLVMBuildShuffleVector(b, z0z1, attribv[2], LLVMConstVector(shuffles, 4), "");
   zoffset = vec4f_from_scalar(gallivm, zoffset, "");
d320 3
a322 5
   /*
    * FIXME I suspect the clamp (is that even right to always clamp to fixed
    * 0.0/1.0?) should really be per fragment?
    */
   z0z1z2 = lp_build_clamp(&bld, LLVMBuildFAdd(b, z0z1z2, zoffset, ""), bld.zero, bld.one);
d325 4
a328 7
    */
   z0_new = LLVMBuildExtractElement(b, z0z1z2, zeroi, "");
   z1_new = LLVMBuildExtractElement(b, z0z1z2, onei, "");
   z2_new = LLVMBuildExtractElement(b, z0z1z2, twoi, "");
   attribv[0] = LLVMBuildInsertElement(b, attribv[0], z0_new, twoi, "");
   attribv[1] = LLVMBuildInsertElement(b, attribv[1], z1_new, twoi, "");
   attribv[2] = LLVMBuildInsertElement(b, attribv[2], z2_new, twoi, "");
d335 1
a335 2
               unsigned vert_attr,
               LLVMValueRef attribv[3])
d342 3
a344 3
   attribv[0] = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v0, &idx, 1, ""), "v0a");
   attribv[1] = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v1, &idx, 1, ""), "v1a");
   attribv[2] = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v2, &idx, 1, ""), "v2a");
d347 1
a347 1
   /* Potentially modify it according to twoside, etc:
d349 4
d354 4
a357 4
      if (vert_attr == key->color_slot && key->bcolor_slot >= 0)
         lp_twoside(gallivm, args, key, key->bcolor_slot, attribv);
      else if (vert_attr == key->spec_slot && key->bspec_slot >= 0)
         lp_twoside(gallivm, args, key, key->bspec_slot, attribv);
d377 2
d408 1
a408 2
		  unsigned slot,
		  LLVMValueRef attribv[3])
d413 3
a415 3
              attribv[0],
              attribv[1],
              attribv[2]);
d428 3
a430 4
apply_perspective_corr( struct gallivm_state *gallivm,
                        struct lp_setup_args *args,
                        unsigned slot,
                        LLVMValueRef attribv[3])
d440 5
a444 3
   attribv[0] = LLVMBuildFMul(b, attribv[0], v0_oow, "v0_oow_v0a");
   attribv[1] = LLVMBuildFMul(b, attribv[1], v1_oow, "v1_oow_v1a");
   attribv[2] = LLVMBuildFMul(b, attribv[2], v2_oow, "v2_oow_v2a");
d451 1
a451 2
		    int slot,
		    LLVMValueRef attribv[3])
d453 1
a453 1
   emit_linear_coef(gallivm, args, slot, attribv);
a456 74
/**
 * Applys cylindrical wrapping to vertex attributes if enabled.
 * Input coordinates must be in [0, 1] range, otherwise results are undefined.
 *
 * @@param cyl_wrap  TGSI_CYLINDRICAL_WRAP_x flags
 */
static void
emit_apply_cyl_wrap(struct gallivm_state *gallivm,
                    struct lp_setup_args *args,
                    uint cyl_wrap,
		    LLVMValueRef attribv[3])

{
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type type = lp_float32_vec4_type();
   LLVMTypeRef float_vec_type = lp_build_vec_type(gallivm, type);
   LLVMValueRef pos_half;
   LLVMValueRef neg_half;
   LLVMValueRef cyl_mask;
   LLVMValueRef offset;
   LLVMValueRef delta;
   LLVMValueRef one;

   if (!cyl_wrap)
      return;

   /* Constants */
   pos_half = lp_build_const_vec(gallivm, type, +0.5f);
   neg_half = lp_build_const_vec(gallivm, type, -0.5f);
   cyl_mask = lp_build_const_mask_aos(gallivm, type, cyl_wrap, 4);

   one = lp_build_const_vec(gallivm, type, 1.0f);
   one = LLVMBuildBitCast(builder, one, lp_build_int_vec_type(gallivm, type), "");
   one = LLVMBuildAnd(builder, one, cyl_mask, "");

   /* Edge v0 -> v1 */
   delta = LLVMBuildFSub(builder, attribv[1], attribv[0], "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_GREATER, delta, pos_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[0] = LLVMBuildFAdd(builder, attribv[0], offset, "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_LESS, delta, neg_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[1] = LLVMBuildFAdd(builder, attribv[1], offset, "");

   /* Edge v1 -> v2 */
   delta = LLVMBuildFSub(builder, attribv[2], attribv[1], "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_GREATER, delta, pos_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[1] = LLVMBuildFAdd(builder, attribv[1], offset, "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_LESS, delta, neg_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[2] = LLVMBuildFAdd(builder, attribv[2], offset, "");

   /* Edge v2 -> v0 */
   delta = LLVMBuildFSub(builder, attribv[0], attribv[2], "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_GREATER, delta, pos_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[2] = LLVMBuildFAdd(builder, attribv[2], offset, "");

   offset     = lp_build_compare(gallivm, type, PIPE_FUNC_LESS, delta, neg_half);
   offset     = LLVMBuildAnd(builder, offset, one, "");
   offset     = LLVMBuildBitCast(builder, offset, float_vec_type, "");
   attribv[0] = LLVMBuildFAdd(builder, attribv[0], offset, "");
}
d464 2
a465 2
               const struct lp_setup_variant_key *key,
               struct lp_setup_args *args)
d469 4
a472 1
   LLVMValueRef attribs[3];
d474 1
a474 1
  /* setup interpolation for all the remaining attributes:
d477 6
d485 7
a491 8
         load_attribute(gallivm, args, key, key->inputs[slot].src_index, attribs);
         if (key->flatshade_first) {
            emit_constant_coef4(gallivm, args, slot+1, attribs[0]);
         }
         else {
            emit_constant_coef4(gallivm, args, slot+1, attribs[2]);
         }
         break;
d494 1
a494 3
         load_attribute(gallivm, args, key, key->inputs[slot].src_index, attribs);
	 emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
         emit_linear_coef(gallivm, args, slot+1, attribs);
d498 1
a498 4
         load_attribute(gallivm, args, key, key->inputs[slot].src_index, attribs);
	 emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
         apply_perspective_corr(gallivm, args, slot+1, attribs);
         emit_linear_coef(gallivm, args, slot+1, attribs);
d519 56
d584 1
a584 1
   for(i = 0; i < nr_args; ++i)
d592 2
a593 2
          const struct lp_setup_variant_key *key,
	  struct lp_setup_args *args)
a595 16
   LLVMTypeRef shuf_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMValueRef onef = lp_build_const_float(gallivm, 1.0);
   LLVMValueRef onei = lp_build_const_int32(gallivm, 1);
   LLVMValueRef zeroi = lp_build_const_int32(gallivm, 0);
   LLVMValueRef pixel_center, xy0_center, dxy01, dxy20, dyx20;
   LLVMValueRef e, f, ef, ooa;
   LLVMValueRef shuffles[4];
   LLVMValueRef attr_pos[3];
   struct lp_type typef4 = lp_type_float_vec(32, 128);

   /* The internal position input is in slot zero:
    */
   load_attribute(gallivm, args, key, 0, attr_pos);

   pixel_center = lp_build_const_vec(gallivm, typef4,
                                  key->pixel_center_half ? 0.5 : 0.0);
d597 2
a598 5
   /*
    * xy are first two elems in v0a/v1a/v2a but just use vec4 arit
    * also offset_tri uses actually xyz in them
    */
   xy0_center = LLVMBuildFSub(b, attr_pos[0], pixel_center, "xy0_center" );
d600 2
a601 2
   dxy01 = LLVMBuildFSub(b, attr_pos[0], attr_pos[1], "dxy01");
   dxy20 = LLVMBuildFSub(b, attr_pos[2], attr_pos[0], "dxy20");
d603 2
a604 4
   shuffles[0] = onei;
   shuffles[1] = zeroi;
   shuffles[2] = LLVMGetUndef(shuf_type);
   shuffles[3] = LLVMGetUndef(shuf_type);
d606 2
a607 1
   dyx20 = LLVMBuildShuffleVector(b, dxy20, dxy20, LLVMConstVector(shuffles, 4), "");
d609 17
a625 3
   ef = LLVMBuildFMul(b, dxy01, dyx20, "ef");
   e = LLVMBuildExtractElement(b, ef, zeroi, "");
   f = LLVMBuildExtractElement(b, ef, onei, "");
d627 2
a628 1
   ooa  = LLVMBuildFDiv(b, onef, LLVMBuildFSub(b, e, f, ""), "ooa");
d630 2
a631 6
   ooa = vec4f_from_scalar(gallivm, ooa, "");

   /* tri offset calc shares a lot of arithmetic, do it here */
   if (key->pgon_offset_scale != 0.0f || key->pgon_offset_units != 0.0f) {
      lp_do_offset_tri(gallivm, args, key, ooa, dxy01, dxy20, attr_pos);
   }
d633 2
a634 14
   dxy20 = LLVMBuildFMul(b, dxy20, ooa, "");
   dxy01 = LLVMBuildFMul(b, dxy01, ooa, "");

   args->dy20_ooa  = lp_build_extract_broadcast(gallivm, typef4, typef4, dxy20, onei);
   args->dy01_ooa  = lp_build_extract_broadcast(gallivm, typef4, typef4, dxy01, onei);

   args->dx20_ooa  = lp_build_extract_broadcast(gallivm, typef4, typef4, dxy20, zeroi);
   args->dx01_ooa  = lp_build_extract_broadcast(gallivm, typef4, typef4, dxy01, zeroi);

   args->x0_center = lp_build_extract_broadcast(gallivm, typef4, typef4, xy0_center, zeroi);
   args->y0_center = lp_build_extract_broadcast(gallivm, typef4, typef4, xy0_center, onei);

   /* might want to merge that with other coef emit in the future */
   emit_position_coef(gallivm, args, 0, attr_pos);
d642 2
a643 1
generate_setup_variant(struct lp_setup_variant_key *key,
a646 1
   struct gallivm_state *gallivm;
d653 2
a654 2
   LLVMBuilderRef builder;
   int64_t t0 = 0, t1;
a662 7
   variant->gallivm = gallivm = gallivm_create();
   if (!variant->gallivm) {
      goto fail;
   }

   builder = gallivm->builder;

d721 1
a721 1
   init_args(gallivm, &variant->key, &args);
d724 1
d727 2
a728 6
   gallivm_verify_function(gallivm, variant->function);

   gallivm_compile_module(gallivm);

   variant->jit_function = (lp_jit_setup_triangle)
      gallivm_jit_function(gallivm, variant->function);
d746 4
a749 6
         gallivm_free_function(gallivm,
                               variant->function,
                               variant->jit_function);
      }
      if (variant->gallivm) {
         gallivm_destroy(variant->gallivm);
d766 1
a766 1
   assert(sizeof key->inputs[0] == sizeof(uint));
d770 1
a770 1
   key->pixel_center_half = lp->rasterizer->half_pixel_center;
d773 2
a774 3
                      inputs[key->num_inputs]);

   key->color_slot  = lp->color_slot [0];
d776 4
a779 10
   key->spec_slot   = lp->color_slot [1];
   key->bspec_slot  = lp->bcolor_slot[1];
   assert(key->color_slot  == lp->color_slot [0]);
   assert(key->bcolor_slot == lp->bcolor_slot[0]);
   assert(key->spec_slot   == lp->color_slot [1]);
   assert(key->bspec_slot  == lp->bcolor_slot[1]);

   key->pgon_offset_units = (float) (lp->rasterizer->offset_units * lp->mrd);
   key->pgon_offset_scale = lp->rasterizer->offset_scale;
   key->pgon_offset_clamp = lp->rasterizer->offset_clamp;
d787 1
a787 1
	    key->inputs[i].interp = LP_INTERP_PERSPECTIVE;
d804 4
a807 7
      gallivm_free_function(variant->gallivm,
                            variant->function,
                            variant->jit_function);
   }

   if (variant->gallivm) {
      gallivm_destroy(variant->gallivm);
d834 1
a834 7
      struct lp_setup_variant_list_item *item;
      if (is_empty_list(&lp->setup_variants_list)) {
         break;
      }
      item = last_elem(&lp->setup_variants_list);
      assert(item);
      assert(item->base);
d870 5
a874 6
      variant = generate_setup_variant(key, lp);
      if (variant) {
         insert_at_head(&lp->setup_variants_list, &variant->list_item_global);
         lp->nr_setup_variants++;
         llvmpipe_variant_count++;
      }
d901 1
a901 1
   for (i = 0; i < TGSI_NUM_CHANNELS; i++) {
d913 1
a913 1
      for (i = 0; i < TGSI_NUM_CHANNELS; i++) {
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a33 1
#include "gallivm/lp_bld_bitarit.h"
d52 1
a78 1
   struct lp_build_context bld;
d82 50
d160 7
a166 5
                    struct lp_setup_args *args,
                    unsigned slot,
                    LLVMValueRef vert)
{
   store_coef(gallivm, args, slot, vert, args->bld.zero, args->bld.zero);
d177 2
a178 2
                 struct lp_setup_args *args,
                 unsigned slot )
d184 3
a186 16
   LLVMValueRef a0, face_val;
   const unsigned char swizzles[4] = { PIPE_SWIZZLE_RED, PIPE_SWIZZLE_ZERO,
                                       PIPE_SWIZZLE_ZERO, PIPE_SWIZZLE_ZERO };
   /* Our face val is either 1 or 0 so we do
    * face = (val * 2) - 1
    * to make it 1 or -1
    */
   face_val =
      LLVMBuildFAdd(builder,
                    LLVMBuildFMul(builder, a0_0f,
                                  lp_build_const_float(gallivm, 2.0),
                                  ""),
                    lp_build_const_float(gallivm, -1.0),
                    "facing");
   face_val = lp_build_broadcast_scalar(&args->bld, face_val);
   a0 = lp_build_swizzle_aos(&args->bld, face_val, swizzles);
d188 1
a188 1
   store_coef(gallivm, args, slot, a0, args->bld.zero, args->bld.zero);
d194 4
a197 4
            LLVMValueRef vert,
            int attr,
            int elem,
            const char *name)
d219 2
a220 3
   LLVMValueRef front_facing = LLVMBuildICmp(b, LLVMIntEQ, facing,
                                             lp_build_const_int32(gallivm, 0), ""); /** need i1 for if condition */

d246 1
a247 2
   struct lp_build_context int_scalar_bld;
   struct lp_build_context *bld = &args->bld;
d285 1
d287 1
a287 1
   dzdxdzdy = lp_build_abs(bld, dzdxdzdy);
d292 1
a292 1
   /* mult = MAX2(dzdx, dzdy) * pgon_offset_scale */
d298 3
a302 47

   if (key->floating_point_depth) {
      /*
       * bias = pgon_offset_units * 2^(exponent(max(z0, z1, z2)) - mantissa_bits) +
       *           MAX2(dzdx, dzdy) * pgon_offset_scale
       *
       * NOTE: Assumes IEEE float32.
       */
      LLVMValueRef c23_shifted, exp_mask, bias, exp;
      LLVMValueRef maxz_value, maxz0z1_value;

      lp_build_context_init(&int_scalar_bld, gallivm, lp_type_int_vec(32, 32));

      c23_shifted = lp_build_const_int32(gallivm, 23 << 23);
      exp_mask = lp_build_const_int32(gallivm, 0xff << 23);

      maxz0z1_value = lp_build_max(&flt_scalar_bld,
                         LLVMBuildExtractElement(b, attribv[0], twoi, ""),
                         LLVMBuildExtractElement(b, attribv[1], twoi, ""));

      maxz_value = lp_build_max(&flt_scalar_bld,
                      LLVMBuildExtractElement(b, attribv[2], twoi, ""),
                      maxz0z1_value);

      exp = LLVMBuildBitCast(b, maxz_value, int_scalar_bld.vec_type, "");
      exp = lp_build_and(&int_scalar_bld, exp, exp_mask);
      exp = lp_build_sub(&int_scalar_bld, exp, c23_shifted);
      /* Clamping to zero means mrd will be zero for very small numbers,
       * but specs do not indicate this should be prevented by clamping
       * mrd to smallest normal number instead. */
      exp = lp_build_max(&int_scalar_bld, exp, int_scalar_bld.zero);
      exp = LLVMBuildBitCast(b, exp, flt_scalar_bld.vec_type, "");

      bias = LLVMBuildFMul(b, exp,
                           lp_build_const_float(gallivm, key->pgon_offset_units),
                           "bias");

      zoffset = LLVMBuildFAdd(b, bias, mult, "zoffset");
   } else {
      /*
       * bias = pgon_offset_units + MAX2(dzdx, dzdy) * pgon_offset_scale
       */
      zoffset = LLVMBuildFAdd(b,
                              lp_build_const_float(gallivm, key->pgon_offset_units),
                              mult, "zoffset");
   }

d325 1
a325 1
   zoffset = lp_build_broadcast_scalar(bld, zoffset);
d332 1
a332 1
   z0z1z2 = lp_build_clamp(bld, LLVMBuildFAdd(b, z0z1z2, zoffset, ""), bld->zero, bld->one);
a370 13
/*
 * FIXME: interpolation is always done wrt fb origin (0/0).
 * However, if some (small) tri is far away from the origin and gradients
 * are large, this can lead to HUGE errors, since the a0 value calculated
 * here can get very large (with the actual values inside the triangle way
 * smaller), leading to complete loss of accuracy. This could be prevented
 * by using some point inside (or at corner) of the tri as interpolation
 * origin, or just use barycentric interpolation (which GL suggests and is
 * what real hw does - you can get the barycentric coordinates from the
 * edge functions in rasterization in principle (though we skip these
 * sometimes completely in case of tris covering a block fully,
 * which obviously wouldn't work)).
 */
d373 5
a377 5
            struct lp_setup_args *args,
            unsigned slot,
            LLVMValueRef a0,
            LLVMValueRef a1,
            LLVMValueRef a2)
a379 1
   LLVMValueRef attr_0;
d386 1
d404 4
a407 4
   LLVMValueRef dadx_x0    = LLVMBuildFMul(b, dadx, x0_center, "dadx_x0");
   LLVMValueRef dady_y0    = LLVMBuildFMul(b, dady, y0_center, "dady_y0");
   LLVMValueRef attr_v0    = LLVMBuildFAdd(b, dadx_x0, dady_y0, "attr_v0");
   attr_0                  = LLVMBuildFSub(b, a0, attr_v0, "attr_0");
d415 3
a417 3
                  struct lp_setup_args *args,
                  unsigned slot,
                  LLVMValueRef attribv[3])
d446 3
a448 6
   LLVMValueRef v0_oow = lp_build_broadcast_scalar(&args->bld,
                            vert_attrib(gallivm, args->v0, 0, 3, "v0_oow"));
   LLVMValueRef v1_oow = lp_build_broadcast_scalar(&args->bld,
                            vert_attrib(gallivm, args->v1, 0, 3, "v1_oow"));
   LLVMValueRef v2_oow = lp_build_broadcast_scalar(&args->bld,
                            vert_attrib(gallivm, args->v2, 0, 3, "v2_oow"));
d456 10
d476 1
a476 1
                    LLVMValueRef attribv[3])
d480 2
a481 2
   struct lp_type type = args->bld.type;
   LLVMTypeRef float_vec_type = args->bld.vec_type;
d570 1
a570 1
         emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
d576 1
a576 1
         emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
d603 3
a605 3
            LLVMValueRef function,
            const LLVMTypeRef *arg_types,
            int nr_args)
d611 1
a611 1
            LLVMNoAliasAttribute);
d617 1
a617 1
          struct lp_setup_args *args)
d626 1
a626 1
   LLVMValueRef shuffles[4], shuf10;
a628 4
   struct lp_build_context bld;

   lp_build_context_init(&bld, gallivm, typef4);
   args->bld = bld;
d635 1
a635 1
                                     key->pixel_center_half ? 0.5 : 0.0);
a649 1
   shuf10 = LLVMConstVector(shuffles, 4);
d651 1
a651 1
   dyx20 = LLVMBuildShuffleVector(b, dxy20, dxy20, shuf10, "");
d659 1
a659 1
   ooa = lp_build_broadcast_scalar(&bld, ooa);
d678 2
a679 1
   emit_linear_coef(gallivm, args, 0, attr_pos);
d723 2
a724 1
                 0, variant->no);
d841 1
a841 14
   /*
    * If depth is floating point, depth bias is calculated with respect
    * to the primitive's maximum Z value. Retain the original depth bias
    * value until that stage.
    */
   key->floating_point_depth = lp->floating_point_depth;

   if (key->floating_point_depth) {
      key->pgon_offset_units = (float) lp->rasterizer->offset_units;
   } else {
      key->pgon_offset_units =
         (float) (lp->rasterizer->offset_units * lp->mrd);
   }

@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a52 4
/** Setup shader number (for debugging) */
static unsigned setup_no = 0;


d85 5
a89 5
           struct lp_setup_args *args,
           unsigned slot,
           LLVMValueRef a0,
           LLVMValueRef dadx,
           LLVMValueRef dady)
d95 2
a96 2
                  a0,
                  LLVMBuildGEP(builder, args->a0, &idx, 1, ""));
d99 2
a100 2
                  dadx,
                  LLVMBuildGEP(builder, args->dadx, &idx, 1, ""));
d103 2
a104 2
                  dady,
                  LLVMBuildGEP(builder, args->dady, &idx, 1, ""));
d710 1
a710 1
   char func_name[64];
d725 1
a725 6
   variant->no = setup_no++;

   util_snprintf(func_name, sizeof(func_name), "setup_variant_%u",
                 variant->no);

   variant->gallivm = gallivm = gallivm_create(func_name, lp->context);
d739 3
a802 2
   gallivm_free_ir(variant->gallivm);

d811 1
a811 1

d816 5
d826 1
a826 1

d834 1
a834 1
                          struct lp_setup_variant_key *key)
d840 1
a840 1

d878 3
a880 3
            key->inputs[i].interp = LP_INTERP_CONSTANT;
         else
            key->inputs[i].interp = LP_INTERP_PERSPECTIVE;
d889 1
a889 1
                     struct lp_setup_variant *variant)
d893 7
a899 1
                   variant->no, lp->nr_setup_variants);
d958 1
a958 1
         memcmp(&li->base->key, key, key->size) == 0) {
d969 1
a969 1
         cull_setup_variants(lp);
d976 1
d980 2
a981 1
   lp_setup_set_setup_variant(lp->setup, variant);
d997 4
a1000 4
lp_dump_setup_coef(const struct lp_setup_variant_key *key,
                   const float (*sa0)[4],
                   const float (*sdadx)[4],
                   const float (*sdady)[4])
d1010 2
a1011 1
                   "xyzw"[i], a0, dadx, dady);
d1017 10
a1026 8
         if (usage_mask & (1 << i)) {
            float a0   = sa0  [1 + slot][i];
            float dadx = sdadx[1 + slot][i];
            float dady = sdady[1 + slot][i];

            debug_printf("IN[%u].%c: a0 = %f, dadx = %f, dady = %f\n",
                         slot, "xyzw"[i], a0, dadx, dady);
         }
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d53 4
d89 5
a93 5
	   struct lp_setup_args *args,
	   unsigned slot,
	   LLVMValueRef a0,
	   LLVMValueRef dadx,
	   LLVMValueRef dady)
d99 2
a100 2
		  a0, 
		  LLVMBuildGEP(builder, args->a0, &idx, 1, ""));
d103 2
a104 2
		  dadx, 
		  LLVMBuildGEP(builder, args->dadx, &idx, 1, ""));
d107 2
a108 2
		  dady, 
		  LLVMBuildGEP(builder, args->dady, &idx, 1, ""));
d714 1
a714 1
   char func_name[256];
d729 6
a734 1
   variant->gallivm = gallivm = gallivm_create();
a747 3
   util_snprintf(func_name, sizeof(func_name), "fs%u_setup%u",
                 0, variant->no);

d809 2
d819 1
a819 1
   
a823 5
      if (variant->function) {
         gallivm_free_function(gallivm,
                               variant->function,
                               variant->jit_function);
      }
d829 1
a829 1
   
d837 1
a837 1
			  struct lp_setup_variant_key *key)
d843 1
a843 1
   
d881 3
a883 3
	    key->inputs[i].interp = LP_INTERP_CONSTANT;
	 else
	    key->inputs[i].interp = LP_INTERP_PERSPECTIVE;
d892 1
a892 1
		     struct lp_setup_variant *variant)
d896 1
a896 7
		   variant->no, lp->nr_setup_variants);
   }

   if (variant->function) {
      gallivm_free_function(variant->gallivm,
                            variant->function,
                            variant->jit_function);
d955 1
a955 1
	 memcmp(&li->base->key, key, key->size) == 0) {
d966 1
a966 1
	 cull_setup_variants(lp);
a972 1
         llvmpipe_variant_count++;
d976 1
a976 2
   lp_setup_set_setup_variant(lp->setup,
			      variant);
d992 4
a995 4
lp_dump_setup_coef( const struct lp_setup_variant_key *key,
		    const float (*sa0)[4],
		    const float (*sdadx)[4],
		    const float (*sdady)[4])
d1005 1
a1005 2
		   "xyzw"[i],
		   a0, dadx, dady);
d1011 8
a1018 10
	 if (usage_mask & (1 << i)) {
	    float a0   = sa0  [1 + slot][i];
	    float dadx = sdadx[1 + slot][i];
	    float dady = sdady[1 + slot][i];

	    debug_printf("IN[%u].%c: a0 = %f, dadx = %f, dady = %f\n",
			 slot,
			 "xyzw"[i],
			 a0, dadx, dady);
	 }
@


