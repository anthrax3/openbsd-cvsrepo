head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.34;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.30;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.39;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/* Authors:
 *  Brian Paul
 */

#include "util/u_inlines.h"
#include "util/u_memory.h"

#include "draw/draw_context.h"

#include "lp_context.h"
#include "lp_screen.h"
#include "lp_state.h"
#include "lp_debug.h"
#include "state_tracker/sw_winsys.h"


static void *
llvmpipe_create_sampler_state(struct pipe_context *pipe,
                              const struct pipe_sampler_state *sampler)
{
   struct pipe_sampler_state *state = mem_dup(sampler, sizeof *sampler);

   if (LP_PERF & PERF_NO_MIP_LINEAR) {
      if (state->min_mip_filter == PIPE_TEX_MIPFILTER_LINEAR)
	 state->min_mip_filter = PIPE_TEX_MIPFILTER_NEAREST;
   }

   if (LP_PERF & PERF_NO_MIPMAPS)
      state->min_mip_filter = PIPE_TEX_MIPFILTER_NONE;

   if (LP_PERF & PERF_NO_LINEAR) {
      state->mag_img_filter = PIPE_TEX_FILTER_NEAREST;
      state->min_img_filter = PIPE_TEX_FILTER_NEAREST;
   }

   return state;
}


static void
llvmpipe_bind_sampler_states(struct pipe_context *pipe,
                             unsigned shader,
                             unsigned start,
                             unsigned num,
                             void **samplers)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   unsigned i;

   assert(shader < PIPE_SHADER_TYPES);
   assert(start + num <= Elements(llvmpipe->samplers[shader]));

   draw_flush(llvmpipe->draw);

   /* set the new samplers */
   for (i = 0; i < num; i++) {
      llvmpipe->samplers[shader][start + i] = samplers[i];
   }

   /* find highest non-null samplers[] entry */
   {
      unsigned j = MAX2(llvmpipe->num_samplers[shader], start + num);
      while (j > 0 && llvmpipe->samplers[shader][j - 1] == NULL)
         j--;
      llvmpipe->num_samplers[shader] = j;
   }

   if (shader == PIPE_SHADER_VERTEX || shader == PIPE_SHADER_GEOMETRY) {
      draw_set_samplers(llvmpipe->draw,
                        shader,
                        llvmpipe->samplers[shader],
                        llvmpipe->num_samplers[shader]);
   }

   llvmpipe->dirty |= LP_NEW_SAMPLER;
}


static void
llvmpipe_set_sampler_views(struct pipe_context *pipe,
                           unsigned shader,
                           unsigned start,
                           unsigned num,
                           struct pipe_sampler_view **views)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   uint i;

   assert(num <= PIPE_MAX_SHADER_SAMPLER_VIEWS);

   assert(shader < PIPE_SHADER_TYPES);
   assert(start + num <= Elements(llvmpipe->sampler_views[shader]));

   draw_flush(llvmpipe->draw);

   /* set the new sampler views */
   for (i = 0; i < num; i++) {
      /* Note: we're using pipe_sampler_view_release() here to work around
       * a possible crash when the old view belongs to another context that
       * was already destroyed.
       */
      pipe_sampler_view_release(pipe,
                                &llvmpipe->sampler_views[shader][start + i]);
      pipe_sampler_view_reference(&llvmpipe->sampler_views[shader][start + i],
                                  views[i]);
   }

   /* find highest non-null sampler_views[] entry */
   {
      unsigned j = MAX2(llvmpipe->num_sampler_views[shader], start + num);
      while (j > 0 && llvmpipe->sampler_views[shader][j - 1] == NULL)
         j--;
      llvmpipe->num_sampler_views[shader] = j;
   }

   if (shader == PIPE_SHADER_VERTEX || shader == PIPE_SHADER_GEOMETRY) {
      draw_set_sampler_views(llvmpipe->draw,
                             shader,
                             llvmpipe->sampler_views[shader],
                             llvmpipe->num_sampler_views[shader]);
   }

   llvmpipe->dirty |= LP_NEW_SAMPLER_VIEW;
}


static struct pipe_sampler_view *
llvmpipe_create_sampler_view(struct pipe_context *pipe,
                            struct pipe_resource *texture,
                            const struct pipe_sampler_view *templ)
{
   struct pipe_sampler_view *view = CALLOC_STRUCT(pipe_sampler_view);
   /*
    * XXX we REALLY want to see the correct bind flag here but the OpenGL
    * state tracker can't guarantee that at least for texture buffer objects.
    */
   if (!(texture->bind & PIPE_BIND_SAMPLER_VIEW))
      debug_printf("Illegal sampler view creation without bind flag\n");

   if (view) {
      *view = *templ;
      view->reference.count = 1;
      view->texture = NULL;
      pipe_resource_reference(&view->texture, texture);
      view->context = pipe;
   }

   return view;
}


static void
llvmpipe_sampler_view_destroy(struct pipe_context *pipe,
                              struct pipe_sampler_view *view)
{
   pipe_resource_reference(&view->texture, NULL);
   FREE(view);
}


static void
llvmpipe_delete_sampler_state(struct pipe_context *pipe,
                              void *sampler)
{
   FREE( sampler );
}


static void
prepare_shader_sampling(
   struct llvmpipe_context *lp,
   unsigned num,
   struct pipe_sampler_view **views,
   unsigned shader_type,
   struct pipe_resource *mapped_tex[PIPE_MAX_SHADER_SAMPLER_VIEWS])
{

   unsigned i;
   uint32_t row_stride[PIPE_MAX_TEXTURE_LEVELS];
   uint32_t img_stride[PIPE_MAX_TEXTURE_LEVELS];
   uint32_t mip_offsets[PIPE_MAX_TEXTURE_LEVELS];
   const void *addr;

   assert(num <= PIPE_MAX_SHADER_SAMPLER_VIEWS);
   if (!num)
      return;

   for (i = 0; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; i++) {
      struct pipe_sampler_view *view = i < num ? views[i] : NULL;

      if (view) {
         struct pipe_resource *tex = view->texture;
         struct llvmpipe_resource *lp_tex = llvmpipe_resource(tex);
         unsigned width0 = tex->width0;
         unsigned num_layers = tex->depth0;
         unsigned first_level = 0;
         unsigned last_level = 0;

         /* We're referencing the texture's internal data, so save a
          * reference to it.
          */
         pipe_resource_reference(&mapped_tex[i], tex);

         if (!lp_tex->dt) {
            /* regular texture - setup array of mipmap level offsets */
            struct pipe_resource *res = view->texture;
            int j;
            void *mip_ptr;

            if (llvmpipe_resource_is_texture(res)) {
               first_level = view->u.tex.first_level;
               last_level = view->u.tex.last_level;
               assert(first_level <= last_level);
               assert(last_level <= res->last_level);

               /* must trigger allocation first before we can get base ptr */
               /* XXX this may fail due to OOM ? */
               mip_ptr = llvmpipe_get_texture_image_all(lp_tex, view->u.tex.first_level,
                                                        LP_TEX_USAGE_READ);
               addr = lp_tex->linear_img.data;

               for (j = first_level; j <= last_level; j++) {
                  mip_ptr = llvmpipe_get_texture_image_all(lp_tex, j,
                                                           LP_TEX_USAGE_READ);
                  mip_offsets[j] = (uint8_t *)mip_ptr - (uint8_t *)addr;
                  /*
                   * could get mip offset directly but need call above to
                   * invoke tiled->linear conversion.
                   */
                  assert(lp_tex->linear_mip_offsets[j] == mip_offsets[j]);
                  row_stride[j] = lp_tex->row_stride[j];
                  img_stride[j] = lp_tex->img_stride[j];
               }
               if (res->target == PIPE_TEXTURE_1D_ARRAY ||
                   res->target == PIPE_TEXTURE_2D_ARRAY) {
                  num_layers = view->u.tex.last_layer - view->u.tex.first_layer + 1;
                  for (j = first_level; j <= last_level; j++) {
                     mip_offsets[j] += view->u.tex.first_layer *
                                       lp_tex->img_stride[j];
                  }
                  assert(view->u.tex.first_layer <= view->u.tex.last_layer);
                  assert(view->u.tex.last_layer < res->array_size);
               }
            }
            else {
               unsigned view_blocksize = util_format_get_blocksize(view->format);
               mip_ptr = lp_tex->data;
               addr = mip_ptr;
               /* probably don't really need to fill that out */
               mip_offsets[0] = 0;
               row_stride[0] = 0;
               row_stride[0] = 0;

               /* everything specified in number of elements here. */
               width0 = view->u.buf.last_element - view->u.buf.first_element + 1;
               addr = (uint8_t *)addr + view->u.buf.first_element *
                               view_blocksize;
               assert(view->u.buf.first_element <= view->u.buf.last_element);
               assert(view->u.buf.last_element * view_blocksize < res->width0);
            }
         }
         else {
            /* display target texture/surface */
            /*
             * XXX: Where should this be unmapped?
             */
            struct llvmpipe_screen *screen = llvmpipe_screen(tex->screen);
            struct sw_winsys *winsys = screen->winsys;
            addr = winsys->displaytarget_map(winsys, lp_tex->dt,
                                                PIPE_TRANSFER_READ);
            row_stride[0] = lp_tex->row_stride[0];
            img_stride[0] = lp_tex->img_stride[0];
            mip_offsets[0] = 0;
            assert(addr);
         }
         draw_set_mapped_texture(lp->draw,
                                 shader_type,
                                 i,
                                 width0, tex->height0, num_layers,
                                 first_level, last_level,
                                 addr,
                                 row_stride, img_stride, mip_offsets);
      }
   }
}
                        

/**
 * Called during state validation when LP_NEW_SAMPLER_VIEW is set.
 */
void
llvmpipe_prepare_vertex_sampling(struct llvmpipe_context *lp,
                                 unsigned num,
                                 struct pipe_sampler_view **views)
{
   prepare_shader_sampling(lp, num, views, PIPE_SHADER_VERTEX,
                           lp->mapped_vs_tex);
}

void
llvmpipe_cleanup_vertex_sampling(struct llvmpipe_context *ctx)
{
   unsigned i;
   for (i = 0; i < Elements(ctx->mapped_vs_tex); i++) {
      pipe_resource_reference(&ctx->mapped_vs_tex[i], NULL);
   }
}


/**
 * Called during state validation when LP_NEW_SAMPLER_VIEW is set.
 */
void
llvmpipe_prepare_geometry_sampling(struct llvmpipe_context *lp,
                                   unsigned num,
                                   struct pipe_sampler_view **views)
{
   prepare_shader_sampling(lp, num, views, PIPE_SHADER_GEOMETRY,
                           lp->mapped_gs_tex);
}

void
llvmpipe_cleanup_geometry_sampling(struct llvmpipe_context *ctx)
{
   unsigned i;
   for (i = 0; i < Elements(ctx->mapped_gs_tex); i++) {
      pipe_resource_reference(&ctx->mapped_gs_tex[i], NULL);
   }
}

void
llvmpipe_init_sampler_funcs(struct llvmpipe_context *llvmpipe)
{
   llvmpipe->pipe.create_sampler_state = llvmpipe_create_sampler_state;

   llvmpipe->pipe.bind_sampler_states = llvmpipe_bind_sampler_states;
   llvmpipe->pipe.create_sampler_view = llvmpipe_create_sampler_view;
   llvmpipe->pipe.set_sampler_views = llvmpipe_set_sampler_views;
   llvmpipe->pipe.sampler_view_destroy = llvmpipe_sampler_view_destroy;
   llvmpipe->pipe.delete_sampler_state = llvmpipe_delete_sampler_state;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d235 1
d242 6
a247 1
               addr = lp_tex->tex_data;
d250 8
a257 1
                  mip_offsets[j] = lp_tex->mip_offsets[j];
d262 1
a262 2
                   res->target == PIPE_TEXTURE_2D_ARRAY ||
                   res->target == PIPE_TEXTURE_CUBE_ARRAY) {
a267 3
                  if (res->target == PIPE_TEXTURE_CUBE_ARRAY) {
                     assert(num_layers % 6 == 0);
                  }
d274 2
a275 1
               addr = lp_tex->data;
d279 1
a279 1
               img_stride[0] = 0;
d313 1
a313 1

@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a234 1
            void *mip_ptr;
d241 1
a241 6

               /* must trigger allocation first before we can get base ptr */
               /* XXX this may fail due to OOM ? */
               mip_ptr = llvmpipe_get_texture_image_all(lp_tex, view->u.tex.first_level,
                                                        LP_TEX_USAGE_READ);
               addr = lp_tex->linear_img.data;
d244 1
a244 8
                  mip_ptr = llvmpipe_get_texture_image_all(lp_tex, j,
                                                           LP_TEX_USAGE_READ);
                  mip_offsets[j] = (uint8_t *)mip_ptr - (uint8_t *)addr;
                  /*
                   * could get mip offset directly but need call above to
                   * invoke tiled->linear conversion.
                   */
                  assert(lp_tex->linear_mip_offsets[j] == mip_offsets[j]);
d249 2
a250 1
                   res->target == PIPE_TEXTURE_2D_ARRAY) {
d256 3
d265 1
a265 2
               mip_ptr = lp_tex->data;
               addr = mip_ptr;
d269 1
a269 1
               row_stride[0] = 0;
d303 1
a303 1
                        
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
a79 7
   /* Check for no-op */
   if (start + num <= llvmpipe->num_samplers[shader] &&
       !memcmp(llvmpipe->samplers[shader] + start, samplers,
               num * sizeof(void *))) {
      return;
   }

a106 23
llvmpipe_bind_fragment_sampler_states(struct pipe_context *pipe,
                                      unsigned num, void **samplers)
{
   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0, num, samplers);
}


static void
llvmpipe_bind_vertex_sampler_states(struct pipe_context *pipe,
                                    unsigned num, void **samplers)
{
   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_VERTEX, 0, num, samplers);
}


static void
llvmpipe_bind_geometry_sampler_states(struct pipe_context *pipe,
                                      unsigned num, void **samplers)
{
   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_GEOMETRY, 0, num, samplers);
}

static void
a120 7
   /* Check for no-op */
   if (start + num <= llvmpipe->num_sampler_views[shader] &&
       !memcmp(llvmpipe->sampler_views[shader] + start, views,
               num * sizeof(struct pipe_sampler_view *))) {
      return;
   }

d125 6
a153 26
static void
llvmpipe_set_fragment_sampler_views(struct pipe_context *pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **views)
{
   llvmpipe_set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, num, views);
}


static void
llvmpipe_set_vertex_sampler_views(struct pipe_context *pipe,
                                  unsigned num,
                                  struct pipe_sampler_view **views)
{
   llvmpipe_set_sampler_views(pipe, PIPE_SHADER_VERTEX, 0, num, views);
}


static void
llvmpipe_set_geometry_sampler_views(struct pipe_context *pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **views)
{
   llvmpipe_set_sampler_views(pipe, PIPE_SHADER_GEOMETRY, 0, num, views);
}

d363 1
a363 6
   llvmpipe->pipe.bind_fragment_sampler_states  = llvmpipe_bind_fragment_sampler_states;
   llvmpipe->pipe.bind_vertex_sampler_states  = llvmpipe_bind_vertex_sampler_states;
   llvmpipe->pipe.bind_geometry_sampler_states  = llvmpipe_bind_geometry_sampler_states;
   llvmpipe->pipe.set_fragment_sampler_views = llvmpipe_set_fragment_sampler_views;
   llvmpipe->pipe.set_vertex_sampler_views = llvmpipe_set_vertex_sampler_views;
   llvmpipe->pipe.set_geometry_sampler_views = llvmpipe_set_geometry_sampler_views;
d365 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d69 4
a72 1
                             unsigned num, void **sampler)
d77 2
a78 1
   assert(num <= PIPE_MAX_SAMPLERS);
d81 3
a83 2
   if (num == llvmpipe->num_samplers &&
       !memcmp(llvmpipe->sampler, sampler, num * sizeof(void *)))
d85 1
d89 12
a100 4
   for (i = 0; i < num; ++i)
      llvmpipe->sampler[i] = sampler[i];
   for (i = num; i < PIPE_MAX_SAMPLERS; ++i)
      llvmpipe->sampler[i] = NULL;
d102 6
a107 1
   llvmpipe->num_samplers = num;
d114 2
a115 3
llvmpipe_bind_vertex_sampler_states(struct pipe_context *pipe,
                                    unsigned num_samplers,
                                    void **samplers)
d117 2
a118 2
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   unsigned i;
a119 1
   assert(num_samplers <= PIPE_MAX_VERTEX_SAMPLERS);
d121 5
a125 19
   /* Check for no-op */
   if (num_samplers == llvmpipe->num_vertex_samplers &&
       !memcmp(llvmpipe->vertex_samplers, samplers, num_samplers * sizeof(void *)))
      return;

   draw_flush(llvmpipe->draw);

   for (i = 0; i < num_samplers; ++i)
      llvmpipe->vertex_samplers[i] = samplers[i];
   for (i = num_samplers; i < PIPE_MAX_VERTEX_SAMPLERS; ++i)
      llvmpipe->vertex_samplers[i] = NULL;

   llvmpipe->num_vertex_samplers = num_samplers;

   draw_set_samplers(llvmpipe->draw,
                     llvmpipe->vertex_samplers,
                     llvmpipe->num_vertex_samplers);

   llvmpipe->dirty |= LP_NEW_SAMPLER;
d131 1
a131 1
                                      unsigned num, void **sampler)
d133 1
a133 1
   /* XXX: implementation missing */
d137 5
a141 3
llvmpipe_set_fragment_sampler_views(struct pipe_context *pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **views)
d146 4
a149 1
   assert(num <= PIPE_MAX_SAMPLERS);
d152 3
a154 2
   if (num == llvmpipe->num_fragment_sampler_views &&
       !memcmp(llvmpipe->fragment_sampler_views, views, num * sizeof(struct pipe_sampler_view *)))
d156 1
d160 5
a164 2
   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
      struct pipe_sampler_view *view = i < num ? views[i] : NULL;
d166 6
a171 1
      pipe_sampler_view_reference(&llvmpipe->fragment_sampler_views[i], view);
d174 6
a179 1
   llvmpipe->num_fragment_sampler_views = num;
d186 9
d199 1
a199 26
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   uint i;

   assert(num <= PIPE_MAX_VERTEX_SAMPLERS);

   /* Check for no-op */
   if (num == llvmpipe->num_vertex_sampler_views &&
       !memcmp(llvmpipe->vertex_sampler_views, views, num * sizeof(struct pipe_sampler_view *))) {
      return;
   }

   draw_flush(llvmpipe->draw);

   for (i = 0; i < PIPE_MAX_VERTEX_SAMPLERS; i++) {
      struct pipe_sampler_view *view = i < num ? views[i] : NULL;

      pipe_sampler_view_reference(&llvmpipe->vertex_sampler_views[i], view);
   }

   llvmpipe->num_vertex_sampler_views = num;

   draw_set_sampler_views(llvmpipe->draw,
                          llvmpipe->vertex_sampler_views,
                          llvmpipe->num_vertex_sampler_views);

   llvmpipe->dirty |= LP_NEW_SAMPLER_VIEW;
d208 1
a208 1
   /*XXX: implementation missing */
d217 6
d253 7
a259 7
/**
 * Called during state validation when LP_NEW_SAMPLER_VIEW is set.
 */
void
llvmpipe_prepare_vertex_sampling(struct llvmpipe_context *lp,
                                 unsigned num,
                                 struct pipe_sampler_view **views)
d261 1
d265 2
a266 1
   const void *data[PIPE_MAX_TEXTURE_LEVELS];
d268 1
a268 1
   assert(num <= PIPE_MAX_VERTEX_SAMPLERS);
d272 1
a272 1
   for (i = 0; i < PIPE_MAX_VERTEX_SAMPLERS; i++) {
d278 4
d286 1
a286 1
         pipe_resource_reference(&lp->mapped_vs_tex[i], tex);
d289 2
a290 1
            /* regular texture - setup array of mipmap level pointers */
d292 52
a343 6
            for (j = view->u.tex.first_level; j <= tex->last_level; j++) {
               data[j] =
                  llvmpipe_get_texture_image_all(lp_tex, j, LP_TEX_USAGE_READ,
                                                 LP_TEX_LAYOUT_LINEAR);
               row_stride[j] = lp_tex->row_stride[j];
               img_stride[j] = lp_tex->img_stride[j];
d353 1
a353 1
            data[0] = winsys->displaytarget_map(winsys, lp_tex->dt,
d357 2
a358 1
            assert(data[0]);
d361 1
d363 4
a366 3
                                 tex->width0, tex->height0, tex->depth0,
                                 view->u.tex.first_level, tex->last_level,
                                 row_stride, img_stride, data);
d370 13
d393 22
d420 1
a420 1
   llvmpipe->pipe.bind_fragment_sampler_states  = llvmpipe_bind_sampler_states;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d272 1
a272 1
            for (j = 0; j <= tex->last_level; j++) {
d296 1
a296 1
                                 tex->last_level,
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 1
a38 1
#include "lp_context.h"
d40 2
a41 1
#include "draw/draw_context.h"
d44 1
a44 2

void *
d48 16
a63 1
   return mem_dup(sampler, sizeof(*sampler));
d67 1
a67 1
void
d94 1
a94 1
void
d118 4
d126 11
a136 3
void
llvmpipe_set_sampler_textures(struct pipe_context *pipe,
                              unsigned num, struct pipe_texture **texture)
d144 2
a145 2
   if (num == llvmpipe->num_textures &&
       !memcmp(llvmpipe->texture, texture, num * sizeof(struct pipe_texture *)))
d151 1
a151 1
      struct pipe_texture *tex = i < num ? texture[i] : NULL;
d153 1
a153 1
      pipe_texture_reference(&llvmpipe->texture[i], tex);
d156 1
a156 1
   llvmpipe->num_textures = num;
d158 1
a158 1
   llvmpipe->dirty |= LP_NEW_TEXTURE;
d162 4
a165 4
void
llvmpipe_set_vertex_sampler_textures(struct pipe_context *pipe,
                                     unsigned num_textures,
                                     struct pipe_texture **textures)
d170 1
a170 1
   assert(num_textures <= PIPE_MAX_VERTEX_SAMPLERS);
d173 2
a174 2
   if (num_textures == llvmpipe->num_vertex_textures &&
       !memcmp(llvmpipe->vertex_textures, textures, num_textures * sizeof(struct pipe_texture *))) {
d181 1
a181 1
      struct pipe_texture *tex = i < num_textures ? textures[i] : NULL;
d183 1
a183 1
      pipe_texture_reference(&llvmpipe->vertex_textures[i], tex);
d186 32
a217 1
   llvmpipe->num_vertex_textures = num_textures;
d219 1
a219 1
   llvmpipe->dirty |= LP_NEW_TEXTURE;
d223 10
a232 1
void
d240 16
d257 69
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d38 1
a38 1
#include "lp_screen.h"
d40 1
a40 2
#include "lp_debug.h"
#include "state_tracker/sw_winsys.h"
d43 2
a44 1
static void *
d48 1
a48 16
   struct pipe_sampler_state *state = mem_dup(sampler, sizeof *sampler);

   if (LP_PERF & PERF_NO_MIP_LINEAR) {
      if (state->min_mip_filter == PIPE_TEX_MIPFILTER_LINEAR)
	 state->min_mip_filter = PIPE_TEX_MIPFILTER_NEAREST;
   }

   if (LP_PERF & PERF_NO_MIPMAPS)
      state->min_mip_filter = PIPE_TEX_MIPFILTER_NONE;

   if (LP_PERF & PERF_NO_LINEAR) {
      state->mag_img_filter = PIPE_TEX_FILTER_NEAREST;
      state->min_img_filter = PIPE_TEX_FILTER_NEAREST;
   }

   return state;
d52 1
a52 1
static void
d79 1
a79 1
static void
a102 4
   draw_set_samplers(llvmpipe->draw,
                     llvmpipe->vertex_samplers,
                     llvmpipe->num_vertex_samplers);

d107 3
a109 11
static void
llvmpipe_bind_geometry_sampler_states(struct pipe_context *pipe,
                                      unsigned num, void **sampler)
{
   /* XXX: implementation missing */
}

static void
llvmpipe_set_fragment_sampler_views(struct pipe_context *pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **views)
d117 2
a118 2
   if (num == llvmpipe->num_fragment_sampler_views &&
       !memcmp(llvmpipe->fragment_sampler_views, views, num * sizeof(struct pipe_sampler_view *)))
d124 1
a124 1
      struct pipe_sampler_view *view = i < num ? views[i] : NULL;
d126 1
a126 1
      pipe_sampler_view_reference(&llvmpipe->fragment_sampler_views[i], view);
d129 1
a129 1
   llvmpipe->num_fragment_sampler_views = num;
d131 1
a131 1
   llvmpipe->dirty |= LP_NEW_SAMPLER_VIEW;
d135 4
a138 4
static void
llvmpipe_set_vertex_sampler_views(struct pipe_context *pipe,
                                  unsigned num,
                                  struct pipe_sampler_view **views)
d143 1
a143 1
   assert(num <= PIPE_MAX_VERTEX_SAMPLERS);
d146 2
a147 2
   if (num == llvmpipe->num_vertex_sampler_views &&
       !memcmp(llvmpipe->vertex_sampler_views, views, num * sizeof(struct pipe_sampler_view *))) {
d154 1
a154 1
      struct pipe_sampler_view *view = i < num ? views[i] : NULL;
d156 1
a156 1
      pipe_sampler_view_reference(&llvmpipe->vertex_sampler_views[i], view);
d159 1
a159 1
   llvmpipe->num_vertex_sampler_views = num;
d161 1
a161 5
   draw_set_sampler_views(llvmpipe->draw,
                          llvmpipe->vertex_sampler_views,
                          llvmpipe->num_vertex_sampler_views);

   llvmpipe->dirty |= LP_NEW_SAMPLER_VIEW;
d165 1
a165 37
static void
llvmpipe_set_geometry_sampler_views(struct pipe_context *pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **views)
{
   /*XXX: implementation missing */
}

static struct pipe_sampler_view *
llvmpipe_create_sampler_view(struct pipe_context *pipe,
                            struct pipe_resource *texture,
                            const struct pipe_sampler_view *templ)
{
   struct pipe_sampler_view *view = CALLOC_STRUCT(pipe_sampler_view);

   if (view) {
      *view = *templ;
      view->reference.count = 1;
      view->texture = NULL;
      pipe_resource_reference(&view->texture, texture);
      view->context = pipe;
   }

   return view;
}


static void
llvmpipe_sampler_view_destroy(struct pipe_context *pipe,
                              struct pipe_sampler_view *view)
{
   pipe_resource_reference(&view->texture, NULL);
   FREE(view);
}


static void
a172 16
/**
 * Called during state validation when LP_NEW_SAMPLER_VIEW is set.
 */
void
llvmpipe_prepare_vertex_sampling(struct llvmpipe_context *lp,
                                 unsigned num,
                                 struct pipe_sampler_view **views)
{
   unsigned i;
   uint32_t row_stride[PIPE_MAX_TEXTURE_LEVELS];
   uint32_t img_stride[PIPE_MAX_TEXTURE_LEVELS];
   const void *data[PIPE_MAX_TEXTURE_LEVELS];

   assert(num <= PIPE_MAX_VERTEX_SAMPLERS);
   if (!num)
      return;
a173 69
   for (i = 0; i < PIPE_MAX_VERTEX_SAMPLERS; i++) {
      struct pipe_sampler_view *view = i < num ? views[i] : NULL;

      if (view) {
         struct pipe_resource *tex = view->texture;
         struct llvmpipe_resource *lp_tex = llvmpipe_resource(tex);

         /* We're referencing the texture's internal data, so save a
          * reference to it.
          */
         pipe_resource_reference(&lp->mapped_vs_tex[i], tex);

         if (!lp_tex->dt) {
            /* regular texture - setup array of mipmap level pointers */
            int j;
            for (j = 0; j <= tex->last_level; j++) {
               data[j] =
                  llvmpipe_get_texture_image_all(lp_tex, j, LP_TEX_USAGE_READ,
                                                 LP_TEX_LAYOUT_LINEAR);
               row_stride[j] = lp_tex->row_stride[j];
               img_stride[j] = lp_tex->img_stride[j];
            }
         }
         else {
            /* display target texture/surface */
            /*
             * XXX: Where should this be unmapped?
             */
            struct llvmpipe_screen *screen = llvmpipe_screen(tex->screen);
            struct sw_winsys *winsys = screen->winsys;
            data[0] = winsys->displaytarget_map(winsys, lp_tex->dt,
                                                PIPE_TRANSFER_READ);
            row_stride[0] = lp_tex->row_stride[0];
            img_stride[0] = lp_tex->img_stride[0];
            assert(data[0]);
         }
         draw_set_mapped_texture(lp->draw,
                                 i,
                                 tex->width0, tex->height0, tex->depth0,
                                 tex->last_level,
                                 row_stride, img_stride, data);
      }
   }
}

void
llvmpipe_cleanup_vertex_sampling(struct llvmpipe_context *ctx)
{
   unsigned i;
   for (i = 0; i < Elements(ctx->mapped_vs_tex); i++) {
      pipe_resource_reference(&ctx->mapped_vs_tex[i], NULL);
   }
}

void
llvmpipe_init_sampler_funcs(struct llvmpipe_context *llvmpipe)
{
   llvmpipe->pipe.create_sampler_state = llvmpipe_create_sampler_state;

   llvmpipe->pipe.bind_fragment_sampler_states  = llvmpipe_bind_sampler_states;
   llvmpipe->pipe.bind_vertex_sampler_states  = llvmpipe_bind_vertex_sampler_states;
   llvmpipe->pipe.bind_geometry_sampler_states  = llvmpipe_bind_geometry_sampler_states;
   llvmpipe->pipe.set_fragment_sampler_views = llvmpipe_set_fragment_sampler_views;
   llvmpipe->pipe.set_vertex_sampler_views = llvmpipe_set_vertex_sampler_views;
   llvmpipe->pipe.set_geometry_sampler_views = llvmpipe_set_geometry_sampler_views;
   llvmpipe->pipe.create_sampler_view = llvmpipe_create_sampler_view;
   llvmpipe->pipe.sampler_view_destroy = llvmpipe_sampler_view_destroy;
   llvmpipe->pipe.delete_sampler_state = llvmpipe_delete_sampler_state;
}
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d69 1
a69 4
                             unsigned shader,
                             unsigned start,
                             unsigned num,
                             void **samplers)
d74 1
a74 2
   assert(shader < PIPE_SHADER_TYPES);
   assert(start + num <= Elements(llvmpipe->samplers[shader]));
d77 2
a78 3
   if (start + num <= llvmpipe->num_samplers[shader] &&
       !memcmp(llvmpipe->samplers[shader] + start, samplers,
               num * sizeof(void *))) {
a79 1
   }
d83 4
a86 12
   /* set the new samplers */
   for (i = 0; i < num; i++) {
      llvmpipe->samplers[shader][start + i] = samplers[i];
   }

   /* find highest non-null samplers[] entry */
   {
      unsigned j = MAX2(llvmpipe->num_samplers[shader], start + num);
      while (j > 0 && llvmpipe->samplers[shader][j - 1] == NULL)
         j--;
      llvmpipe->num_samplers[shader] = j;
   }
d88 1
a88 6
   if (shader == PIPE_SHADER_VERTEX || shader == PIPE_SHADER_GEOMETRY) {
      draw_set_samplers(llvmpipe->draw,
                        shader,
                        llvmpipe->samplers[shader],
                        llvmpipe->num_samplers[shader]);
   }
d95 3
a97 2
llvmpipe_bind_fragment_sampler_states(struct pipe_context *pipe,
                                      unsigned num, void **samplers)
d99 11
a109 2
   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0, num, samplers);
}
d111 10
d122 1
a122 5
static void
llvmpipe_bind_vertex_sampler_states(struct pipe_context *pipe,
                                    unsigned num, void **samplers)
{
   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_VERTEX, 0, num, samplers);
d128 1
a128 1
                                      unsigned num, void **samplers)
d130 1
a130 1
   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_GEOMETRY, 0, num, samplers);
d134 3
a136 5
llvmpipe_set_sampler_views(struct pipe_context *pipe,
                           unsigned shader,
                           unsigned start,
                           unsigned num,
                           struct pipe_sampler_view **views)
d141 1
a141 4
   assert(num <= PIPE_MAX_SHADER_SAMPLER_VIEWS);

   assert(shader < PIPE_SHADER_TYPES);
   assert(start + num <= Elements(llvmpipe->sampler_views[shader]));
d144 2
a145 3
   if (start + num <= llvmpipe->num_sampler_views[shader] &&
       !memcmp(llvmpipe->sampler_views[shader] + start, views,
               num * sizeof(struct pipe_sampler_view *))) {
a146 1
   }
d150 2
a151 5
   /* set the new sampler views */
   for (i = 0; i < num; i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[shader][start + i],
                                  views[i]);
   }
d153 1
a153 6
   /* find highest non-null sampler_views[] entry */
   {
      unsigned j = MAX2(llvmpipe->num_sampler_views[shader], start + num);
      while (j > 0 && llvmpipe->sampler_views[shader][j - 1] == NULL)
         j--;
      llvmpipe->num_sampler_views[shader] = j;
d156 1
a156 6
   if (shader == PIPE_SHADER_VERTEX || shader == PIPE_SHADER_GEOMETRY) {
      draw_set_sampler_views(llvmpipe->draw,
                             shader,
                             llvmpipe->sampler_views[shader],
                             llvmpipe->num_sampler_views[shader]);
   }
a162 9
llvmpipe_set_fragment_sampler_views(struct pipe_context *pipe,
                                    unsigned num,
                                    struct pipe_sampler_view **views)
{
   llvmpipe_set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, num, views);
}


static void
d167 26
a192 1
   llvmpipe_set_sampler_views(pipe, PIPE_SHADER_VERTEX, 0, num, views);
d201 1
a201 1
   llvmpipe_set_sampler_views(pipe, PIPE_SHADER_GEOMETRY, 0, num, views);
a209 6
   /*
    * XXX we REALLY want to see the correct bind flag here but the OpenGL
    * state tracker can't guarantee that at least for texture buffer objects.
    */
   if (!(texture->bind & PIPE_BIND_SAMPLER_VIEW))
      debug_printf("Illegal sampler view creation without bind flag\n");
d240 7
a246 7
static void
prepare_shader_sampling(
   struct llvmpipe_context *lp,
   unsigned num,
   struct pipe_sampler_view **views,
   unsigned shader_type,
   struct pipe_resource *mapped_tex[PIPE_MAX_SHADER_SAMPLER_VIEWS])
a247 1

d251 1
a251 2
   uint32_t mip_offsets[PIPE_MAX_TEXTURE_LEVELS];
   const void *addr;
d253 1
a253 1
   assert(num <= PIPE_MAX_SHADER_SAMPLER_VIEWS);
d257 1
a257 1
   for (i = 0; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; i++) {
a262 4
         unsigned width0 = tex->width0;
         unsigned num_layers = tex->depth0;
         unsigned first_level = 0;
         unsigned last_level = 0;
d267 1
a267 1
         pipe_resource_reference(&mapped_tex[i], tex);
d270 1
a270 2
            /* regular texture - setup array of mipmap level offsets */
            struct pipe_resource *res = view->texture;
d272 6
a277 52
            void *mip_ptr;

            if (llvmpipe_resource_is_texture(res)) {
               first_level = view->u.tex.first_level;
               last_level = view->u.tex.last_level;
               assert(first_level <= last_level);
               assert(last_level <= res->last_level);

               /* must trigger allocation first before we can get base ptr */
               /* XXX this may fail due to OOM ? */
               mip_ptr = llvmpipe_get_texture_image_all(lp_tex, view->u.tex.first_level,
                                                        LP_TEX_USAGE_READ);
               addr = lp_tex->linear_img.data;

               for (j = first_level; j <= last_level; j++) {
                  mip_ptr = llvmpipe_get_texture_image_all(lp_tex, j,
                                                           LP_TEX_USAGE_READ);
                  mip_offsets[j] = (uint8_t *)mip_ptr - (uint8_t *)addr;
                  /*
                   * could get mip offset directly but need call above to
                   * invoke tiled->linear conversion.
                   */
                  assert(lp_tex->linear_mip_offsets[j] == mip_offsets[j]);
                  row_stride[j] = lp_tex->row_stride[j];
                  img_stride[j] = lp_tex->img_stride[j];
               }
               if (res->target == PIPE_TEXTURE_1D_ARRAY ||
                   res->target == PIPE_TEXTURE_2D_ARRAY) {
                  num_layers = view->u.tex.last_layer - view->u.tex.first_layer + 1;
                  for (j = first_level; j <= last_level; j++) {
                     mip_offsets[j] += view->u.tex.first_layer *
                                       lp_tex->img_stride[j];
                  }
                  assert(view->u.tex.first_layer <= view->u.tex.last_layer);
                  assert(view->u.tex.last_layer < res->array_size);
               }
            }
            else {
               unsigned view_blocksize = util_format_get_blocksize(view->format);
               mip_ptr = lp_tex->data;
               addr = mip_ptr;
               /* probably don't really need to fill that out */
               mip_offsets[0] = 0;
               row_stride[0] = 0;
               row_stride[0] = 0;

               /* everything specified in number of elements here. */
               width0 = view->u.buf.last_element - view->u.buf.first_element + 1;
               addr = (uint8_t *)addr + view->u.buf.first_element *
                               view_blocksize;
               assert(view->u.buf.first_element <= view->u.buf.last_element);
               assert(view->u.buf.last_element * view_blocksize < res->width0);
d287 1
a287 1
            addr = winsys->displaytarget_map(winsys, lp_tex->dt,
d291 1
a291 2
            mip_offsets[0] = 0;
            assert(addr);
a293 1
                                 shader_type,
d295 3
a297 4
                                 width0, tex->height0, num_layers,
                                 first_level, last_level,
                                 addr,
                                 row_stride, img_stride, mip_offsets);
a300 13
                        

/**
 * Called during state validation when LP_NEW_SAMPLER_VIEW is set.
 */
void
llvmpipe_prepare_vertex_sampling(struct llvmpipe_context *lp,
                                 unsigned num,
                                 struct pipe_sampler_view **views)
{
   prepare_shader_sampling(lp, num, views, PIPE_SHADER_VERTEX,
                           lp->mapped_vs_tex);
}
a310 22

/**
 * Called during state validation when LP_NEW_SAMPLER_VIEW is set.
 */
void
llvmpipe_prepare_geometry_sampling(struct llvmpipe_context *lp,
                                   unsigned num,
                                   struct pipe_sampler_view **views)
{
   prepare_shader_sampling(lp, num, views, PIPE_SHADER_GEOMETRY,
                           lp->mapped_gs_tex);
}

void
llvmpipe_cleanup_geometry_sampling(struct llvmpipe_context *ctx)
{
   unsigned i;
   for (i = 0; i < Elements(ctx->mapped_gs_tex); i++) {
      pipe_resource_reference(&ctx->mapped_gs_tex[i], NULL);
   }
}

d316 1
a316 1
   llvmpipe->pipe.bind_fragment_sampler_states  = llvmpipe_bind_fragment_sampler_states;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d80 7
d114 23
d151 7
a161 6
      /* Note: we're using pipe_sampler_view_release() here to work around
       * a possible crash when the old view belongs to another context that
       * was already destroyed.
       */
      pipe_sampler_view_release(pipe,
                                &llvmpipe->sampler_views[shader][start + i]);
d185 26
d420 6
a425 1
   llvmpipe->pipe.bind_sampler_states = llvmpipe_bind_sampler_states;
a426 1
   llvmpipe->pipe.set_sampler_views = llvmpipe_set_sampler_views;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d235 1
d242 6
a247 1
               addr = lp_tex->tex_data;
d250 8
a257 1
                  mip_offsets[j] = lp_tex->mip_offsets[j];
d262 1
a262 2
                   res->target == PIPE_TEXTURE_2D_ARRAY ||
                   res->target == PIPE_TEXTURE_CUBE_ARRAY) {
a267 3
                  if (res->target == PIPE_TEXTURE_CUBE_ARRAY) {
                     assert(num_layers % 6 == 0);
                  }
d274 2
a275 1
               addr = lp_tex->data;
d279 1
a279 1
               img_stride[0] = 0;
d313 1
a313 1

@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a234 1
            void *mip_ptr;
d241 1
a241 6

               /* must trigger allocation first before we can get base ptr */
               /* XXX this may fail due to OOM ? */
               mip_ptr = llvmpipe_get_texture_image_all(lp_tex, view->u.tex.first_level,
                                                        LP_TEX_USAGE_READ);
               addr = lp_tex->linear_img.data;
d244 1
a244 8
                  mip_ptr = llvmpipe_get_texture_image_all(lp_tex, j,
                                                           LP_TEX_USAGE_READ);
                  mip_offsets[j] = (uint8_t *)mip_ptr - (uint8_t *)addr;
                  /*
                   * could get mip offset directly but need call above to
                   * invoke tiled->linear conversion.
                   */
                  assert(lp_tex->linear_mip_offsets[j] == mip_offsets[j]);
d249 2
a250 1
                   res->target == PIPE_TEXTURE_2D_ARRAY) {
d256 3
d265 1
a265 2
               mip_ptr = lp_tex->data;
               addr = mip_ptr;
d269 1
a269 1
               row_stride[0] = 0;
d303 1
a303 1
                        
@


