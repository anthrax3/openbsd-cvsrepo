head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.34;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.29;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.30;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.38;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2009 VMware, Inc.
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * @@file
 * Code generate the whole fragment pipeline.
 *
 * The fragment pipeline consists of the following stages:
 * - early depth test
 * - fragment shader
 * - alpha test
 * - depth/stencil test
 * - blending
 *
 * This file has only the glue to assemble the fragment pipeline.  The actual
 * plumbing of converting Gallium state into LLVM IR is done elsewhere, in the
 * lp_bld_*.[ch] files, and in a complete generic and reusable way. Here we
 * muster the LLVM JIT execution engine to create a function that follows an
 * established binary interface and that can be called from C directly.
 *
 * A big source of complexity here is that we often want to run different
 * stages with different precisions and data types and precisions. For example,
 * the fragment shader needs typically to be done in floats, but the
 * depth/stencil test and blending is better done in the type that most closely
 * matches the depth/stencil and color buffer respectively.
 *
 * Since the width of a SIMD vector register stays the same regardless of the
 * element type, different types imply different number of elements, so we must
 * code generate more instances of the stages with larger types to be able to
 * feed/consume the stages with smaller types.
 *
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 */

#include <limits.h>
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_memory.h"
#include "util/u_pointer.h"
#include "util/u_format.h"
#include "util/u_dump.h"
#include "util/u_string.h"
#include "util/u_simple_list.h"
#include "util/u_dual_blend.h"
#include "os/os_time.h"
#include "pipe/p_shader_tokens.h"
#include "draw/draw_context.h"
#include "tgsi/tgsi_dump.h"
#include "tgsi/tgsi_scan.h"
#include "tgsi/tgsi_parse.h"
#include "gallivm/lp_bld_type.h"
#include "gallivm/lp_bld_const.h"
#include "gallivm/lp_bld_conv.h"
#include "gallivm/lp_bld_init.h"
#include "gallivm/lp_bld_intr.h"
#include "gallivm/lp_bld_logic.h"
#include "gallivm/lp_bld_tgsi.h"
#include "gallivm/lp_bld_swizzle.h"
#include "gallivm/lp_bld_flow.h"
#include "gallivm/lp_bld_debug.h"
#include "gallivm/lp_bld_arit.h"
#include "gallivm/lp_bld_pack.h"
#include "gallivm/lp_bld_format.h"
#include "gallivm/lp_bld_quad.h"

#include "lp_bld_alpha.h"
#include "lp_bld_blend.h"
#include "lp_bld_depth.h"
#include "lp_bld_interp.h"
#include "lp_context.h"
#include "lp_debug.h"
#include "lp_perf.h"
#include "lp_setup.h"
#include "lp_state.h"
#include "lp_tex_sample.h"
#include "lp_flush.h"
#include "lp_state_fs.h"
#include "lp_rast.h"


/** Fragment shader number (for debugging) */
static unsigned fs_no = 0;


/**
 * Expand the relevant bits of mask_input to a n*4-dword mask for the
 * n*four pixels in n 2x2 quads.  This will set the n*four elements of the
 * quad mask vector to 0 or ~0.
 * Grouping is 01, 23 for 2 quad mode hence only 0 and 2 are valid
 * quad arguments with fs length 8.
 *
 * \param first_quad  which quad(s) of the quad group to test, in [0,3]
 * \param mask_input  bitwise mask for the whole 4x4 stamp
 */
static LLVMValueRef
generate_quad_mask(struct gallivm_state *gallivm,
                   struct lp_type fs_type,
                   unsigned first_quad,
                   LLVMValueRef mask_input) /* int32 */
{
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type mask_type;
   LLVMTypeRef i32t = LLVMInt32TypeInContext(gallivm->context);
   LLVMValueRef bits[16];
   LLVMValueRef mask;
   int shift, i;

   /*
    * XXX: We'll need a different path for 16 x u8
    */
   assert(fs_type.width == 32);
   assert(fs_type.length <= Elements(bits));
   mask_type = lp_int_type(fs_type);

   /*
    * mask_input >>= (quad * 4)
    */
   switch (first_quad) {
   case 0:
      shift = 0;
      break;
   case 1:
      assert(fs_type.length == 4);
      shift = 2;
      break;
   case 2:
      shift = 8;
      break;
   case 3:
      assert(fs_type.length == 4);
      shift = 10;
      break;
   default:
      assert(0);
      shift = 0;
   }

   mask_input = LLVMBuildLShr(builder,
                              mask_input,
                              LLVMConstInt(i32t, shift, 0),
                              "");

   /*
    * mask = { mask_input & (1 << i), for i in [0,3] }
    */
   mask = lp_build_broadcast(gallivm,
                             lp_build_vec_type(gallivm, mask_type),
                             mask_input);

   for (i = 0; i < fs_type.length / 4; i++) {
      unsigned j = 2 * (i % 2) + (i / 2) * 8;
      bits[4*i + 0] = LLVMConstInt(i32t, 1 << (j + 0), 0);
      bits[4*i + 1] = LLVMConstInt(i32t, 1 << (j + 1), 0);
      bits[4*i + 2] = LLVMConstInt(i32t, 1 << (j + 4), 0);
      bits[4*i + 3] = LLVMConstInt(i32t, 1 << (j + 5), 0);
   }
   mask = LLVMBuildAnd(builder, mask, LLVMConstVector(bits, fs_type.length), "");

   /*
    * mask = mask != 0 ? ~0 : 0
    */
   mask = lp_build_compare(gallivm,
                           mask_type, PIPE_FUNC_NOTEQUAL,
                           mask,
                           lp_build_const_int_vec(gallivm, mask_type, 0));

   return mask;
}


#define EARLY_DEPTH_TEST  0x1
#define LATE_DEPTH_TEST   0x2
#define EARLY_DEPTH_WRITE 0x4
#define LATE_DEPTH_WRITE  0x8

static int
find_output_by_semantic( const struct tgsi_shader_info *info,
			 unsigned semantic,
			 unsigned index )
{
   int i;

   for (i = 0; i < info->num_outputs; i++)
      if (info->output_semantic_name[i] == semantic &&
	  info->output_semantic_index[i] == index)
	 return i;

   return -1;
}


/**
 * Fetch the specified lp_jit_viewport structure for a given viewport_index.
 */
static LLVMValueRef
lp_llvm_viewport(LLVMValueRef context_ptr,
                 struct gallivm_state *gallivm,
                 LLVMValueRef viewport_index)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef ptr;
   LLVMValueRef res;
   struct lp_type viewport_type =
      lp_type_float_vec(32, 32 * LP_JIT_VIEWPORT_NUM_FIELDS);

   ptr = lp_jit_context_viewports(gallivm, context_ptr);
   ptr = LLVMBuildPointerCast(builder, ptr,
            LLVMPointerType(lp_build_vec_type(gallivm, viewport_type), 0), "");

   res = lp_build_pointer_get(builder, ptr, viewport_index);

   return res;
}


/**
 * Generate the fragment shader, depth/stencil test, and alpha tests.
 */
static void
generate_fs_loop(struct gallivm_state *gallivm,
                 struct lp_fragment_shader *shader,
                 const struct lp_fragment_shader_variant_key *key,
                 LLVMBuilderRef builder,
                 struct lp_type type,
                 LLVMValueRef context_ptr,
                 LLVMValueRef num_loop,
                 struct lp_build_interp_soa_context *interp,
                 struct lp_build_sampler_soa *sampler,
                 LLVMValueRef mask_store,
                 LLVMValueRef (*out_color)[4],
                 LLVMValueRef depth_ptr,
                 LLVMValueRef depth_stride,
                 LLVMValueRef facing,
                 LLVMValueRef thread_data_ptr)
{
   const struct util_format_description *zs_format_desc = NULL;
   const struct tgsi_token *tokens = shader->base.tokens;
   LLVMTypeRef vec_type;
   LLVMValueRef mask_ptr, mask_val;
   LLVMValueRef consts_ptr, num_consts_ptr;
   LLVMValueRef z;
   LLVMValueRef z_value, s_value;
   LLVMValueRef z_fb, s_fb;
   LLVMValueRef stencil_refs[2];
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][TGSI_NUM_CHANNELS];
   struct lp_build_for_loop_state loop_state;
   struct lp_build_mask_context mask;
   /*
    * TODO: figure out if simple_shader optimization is really worthwile to
    * keep. Disabled because it may hide some real bugs in the (depth/stencil)
    * code since tests tend to take another codepath than real shaders.
    */
   boolean simple_shader = (shader->info.base.file_count[TGSI_FILE_SAMPLER] == 0 &&
                            shader->info.base.num_inputs < 3 &&
                            shader->info.base.num_instructions < 8) && 0;
   const boolean dual_source_blend = key->blend.rt[0].blend_enable &&
                                     util_blend_state_is_dual(&key->blend, 0);
   unsigned attrib;
   unsigned chan;
   unsigned cbuf;
   unsigned depth_mode;

   struct lp_bld_tgsi_system_values system_values;

   memset(&system_values, 0, sizeof(system_values));

   if (key->depth.enabled ||
       key->stencil[0].enabled) {

      zs_format_desc = util_format_description(key->zsbuf_format);
      assert(zs_format_desc);

      if (!shader->info.base.writes_z) {
         if (key->alpha.enabled ||
             key->blend.alpha_to_coverage ||
             shader->info.base.uses_kill) {
            /* With alpha test and kill, can do the depth test early
             * and hopefully eliminate some quads.  But need to do a
             * special deferred depth write once the final mask value
             * is known. This only works though if there's either no
             * stencil test or the stencil value isn't written.
             */
            if (key->stencil[0].enabled && (key->stencil[0].writemask ||
                                            (key->stencil[1].enabled &&
                                             key->stencil[1].writemask)))
               depth_mode = LATE_DEPTH_TEST | LATE_DEPTH_WRITE;
            else
               depth_mode = EARLY_DEPTH_TEST | LATE_DEPTH_WRITE;
         }
         else
            depth_mode = EARLY_DEPTH_TEST | EARLY_DEPTH_WRITE;
      }
      else {
         depth_mode = LATE_DEPTH_TEST | LATE_DEPTH_WRITE;
      }

      if (!(key->depth.enabled && key->depth.writemask) &&
          !(key->stencil[0].enabled && (key->stencil[0].writemask ||
                                        (key->stencil[1].enabled &&
                                         key->stencil[1].writemask))))
         depth_mode &= ~(LATE_DEPTH_WRITE | EARLY_DEPTH_WRITE);
   }
   else {
      depth_mode = 0;
   }


   stencil_refs[0] = lp_jit_context_stencil_ref_front_value(gallivm, context_ptr);
   stencil_refs[1] = lp_jit_context_stencil_ref_back_value(gallivm, context_ptr);

   vec_type = lp_build_vec_type(gallivm, type);

   consts_ptr = lp_jit_context_constants(gallivm, context_ptr);
   num_consts_ptr = lp_jit_context_num_constants(gallivm, context_ptr);

   lp_build_for_loop_begin(&loop_state, gallivm,
                           lp_build_const_int32(gallivm, 0),
                           LLVMIntULT,
                           num_loop,
                           lp_build_const_int32(gallivm, 1));

   mask_ptr = LLVMBuildGEP(builder, mask_store,
                           &loop_state.counter, 1, "mask_ptr");
   mask_val = LLVMBuildLoad(builder, mask_ptr, "");

   memset(outputs, 0, sizeof outputs);

   for(cbuf = 0; cbuf < key->nr_cbufs; cbuf++) {
      for(chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
         out_color[cbuf][chan] = lp_build_array_alloca(gallivm,
                                                       lp_build_vec_type(gallivm,
                                                                         type),
                                                       num_loop, "color");
      }
   }
   if (dual_source_blend) {
      assert(key->nr_cbufs <= 1);
      for(chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
         out_color[1][chan] = lp_build_array_alloca(gallivm,
                                                    lp_build_vec_type(gallivm,
                                                                      type),
                                                    num_loop, "color1");
      }
   }


   /* 'mask' will control execution based on quad's pixel alive/killed state */
   lp_build_mask_begin(&mask, gallivm, type, mask_val);

   if (!(depth_mode & EARLY_DEPTH_TEST) && !simple_shader)
      lp_build_mask_check(&mask);

   lp_build_interp_soa_update_pos_dyn(interp, gallivm, loop_state.counter);
   z = interp->pos[2];

   if (depth_mode & EARLY_DEPTH_TEST) {
      lp_build_depth_stencil_load_swizzled(gallivm, type,
                                           zs_format_desc, key->resource_1d,
                                           depth_ptr, depth_stride,
                                           &z_fb, &s_fb, loop_state.counter);
      lp_build_depth_stencil_test(gallivm,
                                  &key->depth,
                                  key->stencil,
                                  type,
                                  zs_format_desc,
                                  &mask,
                                  stencil_refs,
                                  z, z_fb, s_fb,
                                  facing,
                                  &z_value, &s_value,
                                  !simple_shader);

      if (depth_mode & EARLY_DEPTH_WRITE) {
         lp_build_depth_stencil_write_swizzled(gallivm, type,
                                               zs_format_desc, key->resource_1d,
                                               NULL, NULL, NULL, loop_state.counter,
                                               depth_ptr, depth_stride,
                                               z_value, s_value);
      }
      /*
       * Note mask check if stencil is enabled must be after ds write not after
       * stencil test otherwise new stencil values may not get written if all
       * fragments got killed by depth/stencil test.
       */
      if (!simple_shader && key->stencil[0].enabled)
         lp_build_mask_check(&mask);
   }

   lp_build_interp_soa_update_inputs_dyn(interp, gallivm, loop_state.counter);

   /* Build the actual shader */
   lp_build_tgsi_soa(gallivm, tokens, type, &mask,
                     consts_ptr, num_consts_ptr, &system_values,
                     interp->inputs,
                     outputs, sampler, &shader->info.base, NULL);

   /* Alpha test */
   if (key->alpha.enabled) {
      int color0 = find_output_by_semantic(&shader->info.base,
                                           TGSI_SEMANTIC_COLOR,
                                           0);

      if (color0 != -1 && outputs[color0][3]) {
         const struct util_format_description *cbuf_format_desc;
         LLVMValueRef alpha = LLVMBuildLoad(builder, outputs[color0][3], "alpha");
         LLVMValueRef alpha_ref_value;

         alpha_ref_value = lp_jit_context_alpha_ref_value(gallivm, context_ptr);
         alpha_ref_value = lp_build_broadcast(gallivm, vec_type, alpha_ref_value);

         cbuf_format_desc = util_format_description(key->cbuf_format[0]);

         lp_build_alpha_test(gallivm, key->alpha.func, type, cbuf_format_desc,
                             &mask, alpha, alpha_ref_value,
                             (depth_mode & LATE_DEPTH_TEST) != 0);
      }
   }

   /* Emulate Alpha to Coverage with Alpha test */
   if (key->blend.alpha_to_coverage) {
      int color0 = find_output_by_semantic(&shader->info.base,
                                           TGSI_SEMANTIC_COLOR,
                                           0);

      if (color0 != -1 && outputs[color0][3]) {
         LLVMValueRef alpha = LLVMBuildLoad(builder, outputs[color0][3], "alpha");

         lp_build_alpha_to_coverage(gallivm, type,
                                    &mask, alpha,
                                    (depth_mode & LATE_DEPTH_TEST) != 0);
      }
   }

   /* Late Z test */
   if (depth_mode & LATE_DEPTH_TEST) {
      int pos0 = find_output_by_semantic(&shader->info.base,
                                         TGSI_SEMANTIC_POSITION,
                                         0);

      if (pos0 != -1 && outputs[pos0][2]) {
         z = LLVMBuildLoad(builder, outputs[pos0][2], "output.z");

         /*
          * Clamp according to ARB_depth_clamp semantics.
          */
         if (key->depth_clamp) {
            LLVMValueRef viewport, min_depth, max_depth;
            LLVMValueRef viewport_index;
            struct lp_build_context f32_bld;

            assert(type.floating);
            lp_build_context_init(&f32_bld, gallivm, type);

            /*
             * Assumes clamping of the viewport index will occur in setup/gs. Value
             * is passed through the rasterization stage via lp_rast_shader_inputs.
             *
             * See: draw_clamp_viewport_idx and lp_clamp_viewport_idx for clamping
             *      semantics.
             */
            viewport_index = lp_jit_thread_data_raster_state_viewport_index(gallivm,
                                thread_data_ptr);

            /*
             * Load the min and max depth from the lp_jit_context.viewports
             * array of lp_jit_viewport structures.
             */
            viewport = lp_llvm_viewport(context_ptr, gallivm, viewport_index);

            /* viewports[viewport_index].min_depth */
            min_depth = LLVMBuildExtractElement(builder, viewport,
                           lp_build_const_int32(gallivm, LP_JIT_VIEWPORT_MIN_DEPTH),
                           "");
            min_depth = lp_build_broadcast_scalar(&f32_bld, min_depth);

            /* viewports[viewport_index].max_depth */
            max_depth = LLVMBuildExtractElement(builder, viewport,
                           lp_build_const_int32(gallivm, LP_JIT_VIEWPORT_MAX_DEPTH),
                           "");
            max_depth = lp_build_broadcast_scalar(&f32_bld, max_depth);

            /*
             * Clamp to the min and max depth values for the given viewport.
             */
            z = lp_build_clamp(&f32_bld, z, min_depth, max_depth);
         }
      }

      lp_build_depth_stencil_load_swizzled(gallivm, type,
                                           zs_format_desc, key->resource_1d,
                                           depth_ptr, depth_stride,
                                           &z_fb, &s_fb, loop_state.counter);

      lp_build_depth_stencil_test(gallivm,
                                  &key->depth,
                                  key->stencil,
                                  type,
                                  zs_format_desc,
                                  &mask,
                                  stencil_refs,
                                  z, z_fb, s_fb,
                                  facing,
                                  &z_value, &s_value,
                                  !simple_shader);
      /* Late Z write */
      if (depth_mode & LATE_DEPTH_WRITE) {
         lp_build_depth_stencil_write_swizzled(gallivm, type,
                                               zs_format_desc, key->resource_1d,
                                               NULL, NULL, NULL, loop_state.counter,
                                               depth_ptr, depth_stride,
                                               z_value, s_value);
      }
   }
   else if ((depth_mode & EARLY_DEPTH_TEST) &&
            (depth_mode & LATE_DEPTH_WRITE))
   {
      /* Need to apply a reduced mask to the depth write.  Reload the
       * depth value, update from zs_value with the new mask value and
       * write that out.
       */
      lp_build_depth_stencil_write_swizzled(gallivm, type,
                                            zs_format_desc, key->resource_1d,
                                            &mask, z_fb, s_fb, loop_state.counter,
                                            depth_ptr, depth_stride,
                                            z_value, s_value);
   }


   /* Color write  */
   for (attrib = 0; attrib < shader->info.base.num_outputs; ++attrib)
   {
      unsigned cbuf = shader->info.base.output_semantic_index[attrib];
      if ((shader->info.base.output_semantic_name[attrib] == TGSI_SEMANTIC_COLOR) &&
           ((cbuf < key->nr_cbufs) || (cbuf == 1 && dual_source_blend)))
      {
         for(chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
            if(outputs[attrib][chan]) {
               /* XXX: just initialize outputs to point at colors[] and
                * skip this.
                */
               LLVMValueRef out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
               LLVMValueRef color_ptr;
               color_ptr = LLVMBuildGEP(builder, out_color[cbuf][chan],
                                        &loop_state.counter, 1, "");
               lp_build_name(out, "color%u.%c", attrib, "rgba"[chan]);
               LLVMBuildStore(builder, out, color_ptr);
            }
         }
      }
   }

   if (key->occlusion_count) {
      LLVMValueRef counter = lp_jit_thread_data_counter(gallivm, thread_data_ptr);
      lp_build_name(counter, "counter");
      lp_build_occlusion_count(gallivm, type,
                               lp_build_mask_value(&mask), counter);
   }

   mask_val = lp_build_mask_end(&mask);
   LLVMBuildStore(builder, mask_val, mask_ptr);
   lp_build_for_loop_end(&loop_state);
}


/**
 * This function will reorder pixels from the fragment shader SoA to memory layout AoS
 *
 * Fragment Shader outputs pixels in small 2x2 blocks
 *  e.g. (0, 0), (1, 0), (0, 1), (1, 1) ; (2, 0) ...
 *
 * However in memory pixels are stored in rows
 *  e.g. (0, 0), (1, 0), (2, 0), (3, 0) ; (0, 1) ...
 *
 * @@param type            fragment shader type (4x or 8x float)
 * @@param num_fs          number of fs_src
 * @@param is_1d           whether we're outputting to a 1d resource
 * @@param dst_channels    number of output channels
 * @@param fs_src          output from fragment shader
 * @@param dst             pointer to store result
 * @@param pad_inline      is channel padding inline or at end of row
 * @@return                the number of dsts
 */
static int
generate_fs_twiddle(struct gallivm_state *gallivm,
                    struct lp_type type,
                    unsigned num_fs,
                    unsigned dst_channels,
                    LLVMValueRef fs_src[][4],
                    LLVMValueRef* dst,
                    bool pad_inline)
{
   LLVMValueRef src[16];

   bool swizzle_pad;
   bool twiddle;
   bool split;

   unsigned pixels = type.length / 4;
   unsigned reorder_group;
   unsigned src_channels;
   unsigned src_count;
   unsigned i;

   src_channels = dst_channels < 3 ? dst_channels : 4;
   src_count = num_fs * src_channels;

   assert(pixels == 2 || pixels == 1);
   assert(num_fs * src_channels <= Elements(src));

   /*
    * Transpose from SoA -> AoS
    */
   for (i = 0; i < num_fs; ++i) {
      lp_build_transpose_aos_n(gallivm, type, &fs_src[i][0], src_channels, &src[i * src_channels]);
   }

   /*
    * Pick transformation options
    */
   swizzle_pad = false;
   twiddle = false;
   split = false;
   reorder_group = 0;

   if (dst_channels == 1) {
      twiddle = true;

      if (pixels == 2) {
         split = true;
      }
   } else if (dst_channels == 2) {
      if (pixels == 1) {
         reorder_group = 1;
      }
   } else if (dst_channels > 2) {
      if (pixels == 1) {
         reorder_group = 2;
      } else {
         twiddle = true;
      }

      if (!pad_inline && dst_channels == 3 && pixels > 1) {
         swizzle_pad = true;
      }
   }

   /*
    * Split the src in half
    */
   if (split) {
      for (i = num_fs; i > 0; --i) {
         src[(i - 1)*2 + 1] = lp_build_extract_range(gallivm, src[i - 1], 4, 4);
         src[(i - 1)*2 + 0] = lp_build_extract_range(gallivm, src[i - 1], 0, 4);
      }

      src_count *= 2;
      type.length = 4;
   }

   /*
    * Ensure pixels are in memory order
    */
   if (reorder_group) {
      /* Twiddle pixels by reordering the array, e.g.:
       *
       * src_count =  8 -> 0 2 1 3 4 6 5 7
       * src_count = 16 -> 0 1 4 5 2 3 6 7 8 9 12 13 10 11 14 15
       */
      const unsigned reorder_sw[] = { 0, 2, 1, 3 };

      for (i = 0; i < src_count; ++i) {
         unsigned group = i / reorder_group;
         unsigned block = (group / 4) * 4 * reorder_group;
         unsigned j = block + (reorder_sw[group % 4] * reorder_group) + (i % reorder_group);
         dst[i] = src[j];
      }
   } else if (twiddle) {
      /* Twiddle pixels across elements of array */
      lp_bld_quad_twiddle(gallivm, type, src, src_count, dst);
   } else {
      /* Do nothing */
      memcpy(dst, src, sizeof(LLVMValueRef) * src_count);
   }

   /*
    * Moves any padding between pixels to the end
    * e.g. RGBXRGBX -> RGBRGBXX
    */
   if (swizzle_pad) {
      unsigned char swizzles[16];
      unsigned elems = pixels * dst_channels;

      for (i = 0; i < type.length; ++i) {
         if (i < elems)
            swizzles[i] = i % dst_channels + (i / dst_channels) * 4;
         else
            swizzles[i] = LP_BLD_SWIZZLE_DONTCARE;
      }

      for (i = 0; i < src_count; ++i) {
         dst[i] = lp_build_swizzle_aos_n(gallivm, dst[i], swizzles, type.length, type.length);
      }
   }

   return src_count;
}


/**
 * Load an unswizzled block of pixels from memory
 */
static void
load_unswizzled_block(struct gallivm_state *gallivm,
                      LLVMValueRef base_ptr,
                      LLVMValueRef stride,
                      unsigned block_width,
                      unsigned block_height,
                      LLVMValueRef* dst,
                      struct lp_type dst_type,
                      unsigned dst_count,
                      unsigned dst_alignment)
{
   LLVMBuilderRef builder = gallivm->builder;
   unsigned row_size = dst_count / block_height;
   unsigned i;

   /* Ensure block exactly fits into dst */
   assert((block_width * block_height) % dst_count == 0);

   for (i = 0; i < dst_count; ++i) {
      unsigned x = i % row_size;
      unsigned y = i / row_size;

      LLVMValueRef bx = lp_build_const_int32(gallivm, x * (dst_type.width / 8) * dst_type.length);
      LLVMValueRef by = LLVMBuildMul(builder, lp_build_const_int32(gallivm, y), stride, "");

      LLVMValueRef gep[2];
      LLVMValueRef dst_ptr;

      gep[0] = lp_build_const_int32(gallivm, 0);
      gep[1] = LLVMBuildAdd(builder, bx, by, "");

      dst_ptr = LLVMBuildGEP(builder, base_ptr, gep, 2, "");
      dst_ptr = LLVMBuildBitCast(builder, dst_ptr, LLVMPointerType(lp_build_vec_type(gallivm, dst_type), 0), "");

      dst[i] = LLVMBuildLoad(builder, dst_ptr, "");

      lp_set_load_alignment(dst[i], dst_alignment);
   }
}


/**
 * Store an unswizzled block of pixels to memory
 */
static void
store_unswizzled_block(struct gallivm_state *gallivm,
                       LLVMValueRef base_ptr,
                       LLVMValueRef stride,
                       unsigned block_width,
                       unsigned block_height,
                       LLVMValueRef* src,
                       struct lp_type src_type,
                       unsigned src_count,
                       unsigned src_alignment)
{
   LLVMBuilderRef builder = gallivm->builder;
   unsigned row_size = src_count / block_height;
   unsigned i;

   /* Ensure src exactly fits into block */
   assert((block_width * block_height) % src_count == 0);

   for (i = 0; i < src_count; ++i) {
      unsigned x = i % row_size;
      unsigned y = i / row_size;

      LLVMValueRef bx = lp_build_const_int32(gallivm, x * (src_type.width / 8) * src_type.length);
      LLVMValueRef by = LLVMBuildMul(builder, lp_build_const_int32(gallivm, y), stride, "");

      LLVMValueRef gep[2];
      LLVMValueRef src_ptr;

      gep[0] = lp_build_const_int32(gallivm, 0);
      gep[1] = LLVMBuildAdd(builder, bx, by, "");

      src_ptr = LLVMBuildGEP(builder, base_ptr, gep, 2, "");
      src_ptr = LLVMBuildBitCast(builder, src_ptr, LLVMPointerType(lp_build_vec_type(gallivm, src_type), 0), "");

      src_ptr = LLVMBuildStore(builder, src[i], src_ptr);

      lp_set_store_alignment(src_ptr, src_alignment);
   }
}


/**
 * Checks if a format description is an arithmetic format
 *
 * A format which has irregular channel sizes such as R3_G3_B2 or R5_G6_B5.
 */
static INLINE boolean
is_arithmetic_format(const struct util_format_description *format_desc)
{
   boolean arith = false;
   unsigned i;

   for (i = 0; i < format_desc->nr_channels; ++i) {
      arith |= format_desc->channel[i].size != format_desc->channel[0].size;
      arith |= (format_desc->channel[i].size % 8) != 0;
   }

   return arith;
}


/**
 * Checks if this format requires special handling due to required expansion
 * to floats for blending, and furthermore has "natural" packed AoS -> unpacked
 * SoA conversion.
 */
static INLINE boolean
format_expands_to_float_soa(const struct util_format_description *format_desc)
{
   if (format_desc->format == PIPE_FORMAT_R11G11B10_FLOAT ||
       format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
      return true;
   }
   return false;
}


/**
 * Retrieves the type representing the memory layout for a format
 *
 * e.g. RGBA16F = 4x half-float and R3G3B2 = 1x byte
 */
static INLINE void
lp_mem_type_from_format_desc(const struct util_format_description *format_desc,
                             struct lp_type* type)
{
   unsigned i;
   unsigned chan;

   if (format_expands_to_float_soa(format_desc)) {
      /* just make this a uint with width of block */
      type->floating = false;
      type->fixed = false;
      type->sign = false;
      type->norm = false;
      type->width = format_desc->block.bits;
      type->length = 1;
      return;
   }

   for (i = 0; i < 4; i++)
      if (format_desc->channel[i].type != UTIL_FORMAT_TYPE_VOID)
         break;
   chan = i;

   memset(type, 0, sizeof(struct lp_type));
   type->floating = format_desc->channel[chan].type == UTIL_FORMAT_TYPE_FLOAT;
   type->fixed    = format_desc->channel[chan].type == UTIL_FORMAT_TYPE_FIXED;
   type->sign     = format_desc->channel[chan].type != UTIL_FORMAT_TYPE_UNSIGNED;
   type->norm     = format_desc->channel[chan].normalized;

   if (is_arithmetic_format(format_desc)) {
      type->width = 0;
      type->length = 1;

      for (i = 0; i < format_desc->nr_channels; ++i) {
         type->width += format_desc->channel[i].size;
      }
   } else {
      type->width = format_desc->channel[chan].size;
      type->length = format_desc->nr_channels;
   }
}


/**
 * Retrieves the type for a format which is usable in the blending code.
 *
 * e.g. RGBA16F = 4x float, R3G3B2 = 3x byte
 */
static INLINE void
lp_blend_type_from_format_desc(const struct util_format_description *format_desc,
                               struct lp_type* type)
{
   unsigned i;
   unsigned chan;

   if (format_expands_to_float_soa(format_desc)) {
      /* always use ordinary floats for blending */
      type->floating = true;
      type->fixed = false;
      type->sign = true;
      type->norm = false;
      type->width = 32;
      type->length = 4;
      return;
   }

   for (i = 0; i < 4; i++)
      if (format_desc->channel[i].type != UTIL_FORMAT_TYPE_VOID)
         break;
   chan = i;

   memset(type, 0, sizeof(struct lp_type));
   type->floating = format_desc->channel[chan].type == UTIL_FORMAT_TYPE_FLOAT;
   type->fixed    = format_desc->channel[chan].type == UTIL_FORMAT_TYPE_FIXED;
   type->sign     = format_desc->channel[chan].type != UTIL_FORMAT_TYPE_UNSIGNED;
   type->norm     = format_desc->channel[chan].normalized;
   type->width    = format_desc->channel[chan].size;
   type->length   = format_desc->nr_channels;

   for (i = 1; i < format_desc->nr_channels; ++i) {
      if (format_desc->channel[i].size > type->width)
         type->width = format_desc->channel[i].size;
   }

   if (type->floating) {
      type->width = 32;
   } else {
      if (type->width <= 8) {
         type->width = 8;
      } else if (type->width <= 16) {
         type->width = 16;
      } else {
         type->width = 32;
      }
   }

   if (is_arithmetic_format(format_desc) && type->length == 3) {
      type->length = 4;
   }
}


/**
 * Scale a normalized value from src_bits to dst_bits.
 *
 * The exact calculation is
 *
 *    dst = iround(src * dst_mask / src_mask)
 *
 *  or with integer rounding
 *
 *    dst = src * (2*dst_mask + sign(src)*src_mask) / (2*src_mask)
 *
 *  where
 *
 *    src_mask = (1 << src_bits) - 1
 *    dst_mask = (1 << dst_bits) - 1
 *
 * but we try to avoid division and multiplication through shifts.
 */
static INLINE LLVMValueRef
scale_bits(struct gallivm_state *gallivm,
           int src_bits,
           int dst_bits,
           LLVMValueRef src,
           struct lp_type src_type)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef result = src;

   if (dst_bits < src_bits) {
      int delta_bits = src_bits - dst_bits;

      if (delta_bits <= dst_bits) {
         /*
          * Approximate the rescaling with a single shift.
          *
          * This gives the wrong rounding.
          */

         result = LLVMBuildLShr(builder,
                                src,
                                lp_build_const_int_vec(gallivm, src_type, delta_bits),
                                "");

      } else {
         /*
          * Try more accurate rescaling.
          */

         /*
          * Drop the least significant bits to make space for the multiplication.
          *
          * XXX: A better approach would be to use a wider integer type as intermediate.  But
          * this is enough to convert alpha from 16bits -> 2 when rendering to
          * PIPE_FORMAT_R10G10B10A2_UNORM.
          */
         result = LLVMBuildLShr(builder,
                                src,
                                lp_build_const_int_vec(gallivm, src_type, dst_bits),
                                "");


         result = LLVMBuildMul(builder,
                               result,
                               lp_build_const_int_vec(gallivm, src_type, (1LL << dst_bits) - 1),
                               "");

         /*
          * Add a rounding term before the division.
          *
          * TODO: Handle signed integers too.
          */
         if (!src_type.sign) {
            result = LLVMBuildAdd(builder,
                                  result,
                                  lp_build_const_int_vec(gallivm, src_type, (1LL << (delta_bits - 1))),
                                  "");
         }

         /*
          * Approximate the division by src_mask with a src_bits shift.
          *
          * Given the src has already been shifted by dst_bits, all we need
          * to do is to shift by the difference.
          */

         result = LLVMBuildLShr(builder,
                                result,
                                lp_build_const_int_vec(gallivm, src_type, delta_bits),
                                "");
      }

   } else if (dst_bits > src_bits) {
      /* Scale up bits */
      int db = dst_bits - src_bits;

      /* Shift left by difference in bits */
      result = LLVMBuildShl(builder,
                            src,
                            lp_build_const_int_vec(gallivm, src_type, db),
                            "");

      if (db < src_bits) {
         /* Enough bits in src to fill the remainder */
         LLVMValueRef lower = LLVMBuildLShr(builder,
                                            src,
                                            lp_build_const_int_vec(gallivm, src_type, src_bits - db),
                                            "");

         result = LLVMBuildOr(builder, result, lower, "");
      } else if (db > src_bits) {
         /* Need to repeatedly copy src bits to fill remainder in dst */
         unsigned n;

         for (n = src_bits; n < dst_bits; n *= 2) {
            LLVMValueRef shuv = lp_build_const_int_vec(gallivm, src_type, n);

            result = LLVMBuildOr(builder,
                                 result,
                                 LLVMBuildLShr(builder, result, shuv, ""),
                                 "");
         }
      }
   }

   return result;
}

/**
 * If RT is a smallfloat (needing denorms) format
 */
static INLINE int
have_smallfloat_format(struct lp_type dst_type,
                       enum pipe_format format)
{
   return ((dst_type.floating && dst_type.width != 32) ||
    /* due to format handling hacks this format doesn't have floating set
     * here (and actually has width set to 32 too) so special case this. */
    (format == PIPE_FORMAT_R11G11B10_FLOAT));
}


/**
 * Convert from memory format to blending format
 *
 * e.g. GL_R3G3B2 is 1 byte in memory but 3 bytes for blending
 */
static void
convert_to_blend_type(struct gallivm_state *gallivm,
                      unsigned block_size,
                      const struct util_format_description *src_fmt,
                      struct lp_type src_type,
                      struct lp_type dst_type,
                      LLVMValueRef* src, // and dst
                      unsigned num_srcs)
{
   LLVMValueRef *dst = src;
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type blend_type;
   struct lp_type mem_type;
   unsigned i, j, k;
   unsigned pixels = block_size / num_srcs;
   bool is_arith;

   /*
    * full custom path for packed floats and srgb formats - none of the later
    * functions would do anything useful, and given the lp_type representation they
    * can't be fixed. Should really have some SoA blend path for these kind of
    * formats rather than hacking them in here.
    */
   if (format_expands_to_float_soa(src_fmt)) {
      LLVMValueRef tmpsrc[4];
      /*
       * This is pretty suboptimal for this case blending in SoA would be much
       * better, since conversion gets us SoA values so need to convert back.
       */
      assert(src_type.width == 32 || src_type.width == 16);
      assert(dst_type.floating);
      assert(dst_type.width == 32);
      assert(dst_type.length % 4 == 0);
      assert(num_srcs % 4 == 0);

      if (src_type.width == 16) {
         /* expand 4x16bit values to 4x32bit */
         struct lp_type type32x4 = src_type;
         LLVMTypeRef ltype32x4;
         unsigned num_fetch = dst_type.length == 8 ? num_srcs / 2 : num_srcs / 4;
         type32x4.width = 32;
         ltype32x4 = lp_build_vec_type(gallivm, type32x4);
         for (i = 0; i < num_fetch; i++) {
            src[i] = LLVMBuildZExt(builder, src[i], ltype32x4, "");
         }
         src_type.width = 32;
      }
      for (i = 0; i < 4; i++) {
         tmpsrc[i] = src[i];
      }
      for (i = 0; i < num_srcs / 4; i++) {
         LLVMValueRef tmpsoa[4];
         LLVMValueRef tmps = tmpsrc[i];
         if (dst_type.length == 8) {
            LLVMValueRef shuffles[8];
            unsigned j;
            /* fetch was 4 values but need 8-wide output values */
            tmps = lp_build_concat(gallivm, &tmpsrc[i * 2], src_type, 2);
            /*
             * for 8-wide aos transpose would give us wrong order not matching
             * incoming converted fs values and mask. ARGH.
             */
            for (j = 0; j < 4; j++) {
               shuffles[j] = lp_build_const_int32(gallivm, j * 2);
               shuffles[j + 4] = lp_build_const_int32(gallivm, j * 2 + 1);
            }
            tmps = LLVMBuildShuffleVector(builder, tmps, tmps,
                                          LLVMConstVector(shuffles, 8), "");
         }
         if (src_fmt->format == PIPE_FORMAT_R11G11B10_FLOAT) {
            lp_build_r11g11b10_to_float(gallivm, tmps, tmpsoa);
         }
         else {
            lp_build_unpack_rgba_soa(gallivm, src_fmt, dst_type, tmps, tmpsoa);
         }
         lp_build_transpose_aos(gallivm, dst_type, tmpsoa, &src[i * 4]);
      }
      return;
   }

   lp_mem_type_from_format_desc(src_fmt, &mem_type);
   lp_blend_type_from_format_desc(src_fmt, &blend_type);

   /* Is the format arithmetic */
   is_arith = blend_type.length * blend_type.width != mem_type.width * mem_type.length;
   is_arith &= !(mem_type.width == 16 && mem_type.floating);

   /* Pad if necessary */
   if (!is_arith && src_type.length < dst_type.length) {
      for (i = 0; i < num_srcs; ++i) {
         dst[i] = lp_build_pad_vector(gallivm, src[i], dst_type.length);
      }

      src_type.length = dst_type.length;
   }

   /* Special case for half-floats */
   if (mem_type.width == 16 && mem_type.floating) {
      assert(blend_type.width == 32 && blend_type.floating);
      lp_build_conv_auto(gallivm, src_type, &dst_type, dst, num_srcs, dst);
      is_arith = false;
   }

   if (!is_arith) {
      return;
   }

   src_type.width = blend_type.width * blend_type.length;
   blend_type.length *= pixels;
   src_type.length *= pixels / (src_type.length / mem_type.length);

   for (i = 0; i < num_srcs; ++i) {
      LLVMValueRef chans[4];
      LLVMValueRef res = NULL;

      dst[i] = LLVMBuildZExt(builder, src[i], lp_build_vec_type(gallivm, src_type), "");

      for (j = 0; j < src_fmt->nr_channels; ++j) {
         unsigned mask = 0;
         unsigned sa = src_fmt->channel[j].shift;
#ifdef PIPE_ARCH_LITTLE_ENDIAN
         unsigned from_lsb = j;
#else
         unsigned from_lsb = src_fmt->nr_channels - j - 1;
#endif

         for (k = 0; k < src_fmt->channel[j].size; ++k) {
            mask |= 1 << k;
         }

         /* Extract bits from source */
         chans[j] = LLVMBuildLShr(builder,
                                  dst[i],
                                  lp_build_const_int_vec(gallivm, src_type, sa),
                                  "");

         chans[j] = LLVMBuildAnd(builder,
                                 chans[j],
                                 lp_build_const_int_vec(gallivm, src_type, mask),
                                 "");

         /* Scale bits */
         if (src_type.norm) {
            chans[j] = scale_bits(gallivm, src_fmt->channel[j].size,
                                  blend_type.width, chans[j], src_type);
         }

         /* Insert bits into correct position */
         chans[j] = LLVMBuildShl(builder,
                                 chans[j],
                                 lp_build_const_int_vec(gallivm, src_type, from_lsb * blend_type.width),
                                 "");

         if (j == 0) {
            res = chans[j];
         } else {
            res = LLVMBuildOr(builder, res, chans[j], "");
         }
      }

      dst[i] = LLVMBuildBitCast(builder, res, lp_build_vec_type(gallivm, blend_type), "");
   }
}


/**
 * Convert from blending format to memory format
 *
 * e.g. GL_R3G3B2 is 3 bytes for blending but 1 byte in memory
 */
static void
convert_from_blend_type(struct gallivm_state *gallivm,
                        unsigned block_size,
                        const struct util_format_description *src_fmt,
                        struct lp_type src_type,
                        struct lp_type dst_type,
                        LLVMValueRef* src, // and dst
                        unsigned num_srcs)
{
   LLVMValueRef* dst = src;
   unsigned i, j, k;
   struct lp_type mem_type;
   struct lp_type blend_type;
   LLVMBuilderRef builder = gallivm->builder;
   unsigned pixels = block_size / num_srcs;
   bool is_arith;

   /*
    * full custom path for packed floats and srgb formats - none of the later
    * functions would do anything useful, and given the lp_type representation they
    * can't be fixed. Should really have some SoA blend path for these kind of
    * formats rather than hacking them in here.
    */
   if (format_expands_to_float_soa(src_fmt)) {
      /*
       * This is pretty suboptimal for this case blending in SoA would be much
       * better - we need to transpose the AoS values back to SoA values for
       * conversion/packing.
       */
      assert(src_type.floating);
      assert(src_type.width == 32);
      assert(src_type.length % 4 == 0);
      assert(dst_type.width == 32 || dst_type.width == 16);

      for (i = 0; i < num_srcs / 4; i++) {
         LLVMValueRef tmpsoa[4], tmpdst;
         lp_build_transpose_aos(gallivm, src_type, &src[i * 4], tmpsoa);
         /* really really need SoA here */

         if (src_fmt->format == PIPE_FORMAT_R11G11B10_FLOAT) {
            tmpdst = lp_build_float_to_r11g11b10(gallivm, tmpsoa);
         }
         else {
            tmpdst = lp_build_float_to_srgb_packed(gallivm, src_fmt,
                                                   src_type, tmpsoa);
         }

         if (src_type.length == 8) {
            LLVMValueRef tmpaos, shuffles[8];
            unsigned j;
            /*
             * for 8-wide aos transpose has given us wrong order not matching
             * output order. HMPF. Also need to split the output values manually.
             */
            for (j = 0; j < 4; j++) {
               shuffles[j * 2] = lp_build_const_int32(gallivm, j);
               shuffles[j * 2 + 1] = lp_build_const_int32(gallivm, j + 4);
            }
            tmpaos = LLVMBuildShuffleVector(builder, tmpdst, tmpdst,
                                            LLVMConstVector(shuffles, 8), "");
            src[i * 2] = lp_build_extract_range(gallivm, tmpaos, 0, 4);
            src[i * 2 + 1] = lp_build_extract_range(gallivm, tmpaos, 4, 4);
         }
         else {
            src[i] = tmpdst;
         }
      }
      if (dst_type.width == 16) {
         struct lp_type type16x8 = dst_type;
         struct lp_type type32x4 = dst_type;
         LLVMTypeRef ltype16x4, ltypei64, ltypei128;
         unsigned num_fetch = src_type.length == 8 ? num_srcs / 2 : num_srcs / 4;
         type16x8.length = 8;
         type32x4.width = 32;
         ltypei128 = LLVMIntTypeInContext(gallivm->context, 128);
         ltypei64 = LLVMIntTypeInContext(gallivm->context, 64);
         ltype16x4 = lp_build_vec_type(gallivm, dst_type);
         /* We could do vector truncation but it doesn't generate very good code */
         for (i = 0; i < num_fetch; i++) {
            src[i] = lp_build_pack2(gallivm, type32x4, type16x8,
                                    src[i], lp_build_zero(gallivm, type32x4));
            src[i] = LLVMBuildBitCast(builder, src[i], ltypei128, "");
            src[i] = LLVMBuildTrunc(builder, src[i], ltypei64, "");
            src[i] = LLVMBuildBitCast(builder, src[i], ltype16x4, "");
         }
      }
      return;
   }

   lp_mem_type_from_format_desc(src_fmt, &mem_type);
   lp_blend_type_from_format_desc(src_fmt, &blend_type);

   is_arith = (blend_type.length * blend_type.width != mem_type.width * mem_type.length);

   /* Special case for half-floats */
   if (mem_type.width == 16 && mem_type.floating) {
      int length = dst_type.length;
      assert(blend_type.width == 32 && blend_type.floating);

      dst_type.length = src_type.length;

      lp_build_conv_auto(gallivm, src_type, &dst_type, dst, num_srcs, dst);

      dst_type.length = length;
      is_arith = false;
   }

   /* Remove any padding */
   if (!is_arith && (src_type.length % mem_type.length)) {
      src_type.length -= (src_type.length % mem_type.length);

      for (i = 0; i < num_srcs; ++i) {
         dst[i] = lp_build_extract_range(gallivm, dst[i], 0, src_type.length);
      }
   }

   /* No bit arithmetic to do */
   if (!is_arith) {
      return;
   }

   src_type.length = pixels;
   src_type.width = blend_type.length * blend_type.width;
   dst_type.length = pixels;

   for (i = 0; i < num_srcs; ++i) {
      LLVMValueRef chans[4];
      LLVMValueRef res = NULL;

      dst[i] = LLVMBuildBitCast(builder, src[i], lp_build_vec_type(gallivm, src_type), "");

      for (j = 0; j < src_fmt->nr_channels; ++j) {
         unsigned mask = 0;
         unsigned sa = src_fmt->channel[j].shift;
#ifdef PIPE_ARCH_LITTLE_ENDIAN
         unsigned from_lsb = j;
#else
         unsigned from_lsb = src_fmt->nr_channels - j - 1;
#endif

         assert(blend_type.width > src_fmt->channel[j].size);

         for (k = 0; k < blend_type.width; ++k) {
            mask |= 1 << k;
         }

         /* Extract bits */
         chans[j] = LLVMBuildLShr(builder,
                                  dst[i],
                                  lp_build_const_int_vec(gallivm, src_type, from_lsb * blend_type.width),
                                  "");

         chans[j] = LLVMBuildAnd(builder,
                                 chans[j],
                                 lp_build_const_int_vec(gallivm, src_type, mask),
                                 "");

         /* Scale down bits */
         if (src_type.norm) {
            chans[j] = scale_bits(gallivm, blend_type.width,
                                  src_fmt->channel[j].size, chans[j], src_type);
         }

         /* Insert bits */
         chans[j] = LLVMBuildShl(builder,
                                 chans[j],
                                 lp_build_const_int_vec(gallivm, src_type, sa),
                                 "");

         sa += src_fmt->channel[j].size;

         if (j == 0) {
            res = chans[j];
         } else {
            res = LLVMBuildOr(builder, res, chans[j], "");
         }
      }

      assert (dst_type.width != 24);

      dst[i] = LLVMBuildTrunc(builder, res, lp_build_vec_type(gallivm, dst_type), "");
   }
}


/**
 * Convert alpha to same blend type as src
 */
static void
convert_alpha(struct gallivm_state *gallivm,
              struct lp_type row_type,
              struct lp_type alpha_type,
              const unsigned block_size,
              const unsigned block_height,
              const unsigned src_count,
              const unsigned dst_channels,
              const bool pad_inline,
              LLVMValueRef* src_alpha)
{
   LLVMBuilderRef builder = gallivm->builder;
   unsigned i, j;
   unsigned length = row_type.length;
   row_type.length = alpha_type.length;

   /* Twiddle the alpha to match pixels */
   lp_bld_quad_twiddle(gallivm, alpha_type, src_alpha, block_height, src_alpha);

   /*
    * TODO this should use single lp_build_conv call for
    * src_count == 1 && dst_channels == 1 case (dropping the concat below)
    */
   for (i = 0; i < block_height; ++i) {
      lp_build_conv(gallivm, alpha_type, row_type, &src_alpha[i], 1, &src_alpha[i], 1);
   }

   alpha_type = row_type;
   row_type.length = length;

   /* If only one channel we can only need the single alpha value per pixel */
   if (src_count == 1 && dst_channels == 1) {

      lp_build_concat_n(gallivm, alpha_type, src_alpha, block_height, src_alpha, src_count);
   } else {
      /* If there are more srcs than rows then we need to split alpha up */
      if (src_count > block_height) {
         for (i = src_count; i > 0; --i) {
            unsigned pixels = block_size / src_count;
            unsigned idx = i - 1;

            src_alpha[idx] = lp_build_extract_range(gallivm, src_alpha[(idx * pixels) / 4],
                                                    (idx * pixels) % 4, pixels);
         }
      }

      /* If there is a src for each pixel broadcast the alpha across whole row */
      if (src_count == block_size) {
         for (i = 0; i < src_count; ++i) {
            src_alpha[i] = lp_build_broadcast(gallivm, lp_build_vec_type(gallivm, row_type), src_alpha[i]);
         }
      } else {
         unsigned pixels = block_size / src_count;
         unsigned channels = pad_inline ? TGSI_NUM_CHANNELS : dst_channels;
         unsigned alpha_span = 1;
         LLVMValueRef shuffles[LP_MAX_VECTOR_LENGTH];

         /* Check if we need 2 src_alphas for our shuffles */
         if (pixels > alpha_type.length) {
            alpha_span = 2;
         }

         /* Broadcast alpha across all channels, e.g. a1a2 to a1a1a1a1a2a2a2a2 */
         for (j = 0; j < row_type.length; ++j) {
            if (j < pixels * channels) {
               shuffles[j] = lp_build_const_int32(gallivm, j / channels);
            } else {
               shuffles[j] = LLVMGetUndef(LLVMInt32TypeInContext(gallivm->context));
            }
         }

         for (i = 0; i < src_count; ++i) {
            unsigned idx1 = i, idx2 = i;

            if (alpha_span > 1){
               idx1 *= alpha_span;
               idx2 = idx1 + 1;
            }

            src_alpha[i] = LLVMBuildShuffleVector(builder,
                                                  src_alpha[idx1],
                                                  src_alpha[idx2],
                                                  LLVMConstVector(shuffles, row_type.length),
                                                  "");
         }
      }
   }
}


/**
 * Generates the blend function for unswizzled colour buffers
 * Also generates the read & write from colour buffer
 */
static void
generate_unswizzled_blend(struct gallivm_state *gallivm,
                          unsigned rt,
                          struct lp_fragment_shader_variant *variant,
                          enum pipe_format out_format,
                          unsigned int num_fs,
                          struct lp_type fs_type,
                          LLVMValueRef* fs_mask,
                          LLVMValueRef fs_out_color[PIPE_MAX_COLOR_BUFS][TGSI_NUM_CHANNELS][4],
                          LLVMValueRef context_ptr,
                          LLVMValueRef color_ptr,
                          LLVMValueRef stride,
                          unsigned partial_mask,
                          boolean do_branch)
{
   const unsigned alpha_channel = 3;
   const unsigned block_width = LP_RASTER_BLOCK_SIZE;
   const unsigned block_height = LP_RASTER_BLOCK_SIZE;
   const unsigned block_size = block_width * block_height;
   const unsigned lp_integer_vector_width = 128;

   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef fs_src[4][TGSI_NUM_CHANNELS];
   LLVMValueRef fs_src1[4][TGSI_NUM_CHANNELS];
   LLVMValueRef src_alpha[4 * 4];
   LLVMValueRef src1_alpha[4 * 4];
   LLVMValueRef src_mask[4 * 4];
   LLVMValueRef src[4 * 4];
   LLVMValueRef src1[4 * 4];
   LLVMValueRef dst[4 * 4];
   LLVMValueRef blend_color;
   LLVMValueRef blend_alpha;
   LLVMValueRef i32_zero;
   LLVMValueRef check_mask;
   LLVMValueRef undef_src_val;

   struct lp_build_mask_context mask_ctx;
   struct lp_type mask_type;
   struct lp_type blend_type;
   struct lp_type row_type;
   struct lp_type dst_type;

   unsigned char swizzle[TGSI_NUM_CHANNELS];
   unsigned vector_width;
   unsigned src_channels = TGSI_NUM_CHANNELS;
   unsigned dst_channels;
   unsigned dst_count;
   unsigned src_count;
   unsigned i, j;

   const struct util_format_description* out_format_desc = util_format_description(out_format);

   unsigned dst_alignment;

   bool pad_inline = is_arithmetic_format(out_format_desc);
   bool has_alpha = false;
   const boolean dual_source_blend = variant->key.blend.rt[0].blend_enable &&
                                     util_blend_state_is_dual(&variant->key.blend, 0);

   const boolean is_1d = variant->key.resource_1d;
   unsigned num_fullblock_fs = is_1d ? 2 * num_fs : num_fs;
   LLVMValueRef fpstate = 0;

   /* Get type from output format */
   lp_blend_type_from_format_desc(out_format_desc, &row_type);
   lp_mem_type_from_format_desc(out_format_desc, &dst_type);

   /*
    * Technically this code should go into lp_build_smallfloat_to_float
    * and lp_build_float_to_smallfloat but due to the
    * http://llvm.org/bugs/show_bug.cgi?id=6393
    * llvm reorders the mxcsr intrinsics in a way that breaks the code.
    * So the ordering is important here and there shouldn't be any
    * llvm ir instrunctions in this function before
    * this, otherwise half-float format conversions won't work
    * (again due to llvm bug #6393).
    */
   if (have_smallfloat_format(dst_type, out_format)) {
      /* We need to make sure that denorms are ok for half float
         conversions */
      fpstate = lp_build_fpstate_get(gallivm);
      lp_build_fpstate_set_denorms_zero(gallivm, FALSE);
   }

   mask_type = lp_int32_vec4_type();
   mask_type.length = fs_type.length;

   for (i = num_fs; i < num_fullblock_fs; i++) {
      fs_mask[i] = lp_build_zero(gallivm, mask_type);
   }

   /* Do not bother executing code when mask is empty.. */
   if (do_branch) {
      check_mask = LLVMConstNull(lp_build_int_vec_type(gallivm, mask_type));

      for (i = 0; i < num_fullblock_fs; ++i) {
         check_mask = LLVMBuildOr(builder, check_mask, fs_mask[i], "");
      }

      lp_build_mask_begin(&mask_ctx, gallivm, mask_type, check_mask);
      lp_build_mask_check(&mask_ctx);
   }

   partial_mask |= !variant->opaque;
   i32_zero = lp_build_const_int32(gallivm, 0);

#if HAVE_LLVM < 0x0302
   /*
    * undef triggers a crash in LLVMBuildTrunc in convert_from_blend_type in some
    * cases (seen with r10g10b10a2, 128bit wide vectors) (only used for 1d case).
    */
   undef_src_val = lp_build_zero(gallivm, fs_type);
#else
   undef_src_val = lp_build_undef(gallivm, fs_type);
#endif

   row_type.length = fs_type.length;
   vector_width    = dst_type.floating ? lp_native_vector_width : lp_integer_vector_width;

   /* Compute correct swizzle and count channels */
   memset(swizzle, LP_BLD_SWIZZLE_DONTCARE, TGSI_NUM_CHANNELS);
   dst_channels = 0;

   for (i = 0; i < TGSI_NUM_CHANNELS; ++i) {
      /* Ensure channel is used */
      if (out_format_desc->swizzle[i] >= TGSI_NUM_CHANNELS) {
         continue;
      }

      /* Ensure not already written to (happens in case with GL_ALPHA) */
      if (swizzle[out_format_desc->swizzle[i]] < TGSI_NUM_CHANNELS) {
         continue;
      }

      /* Ensure we havn't already found all channels */
      if (dst_channels >= out_format_desc->nr_channels) {
         continue;
      }

      swizzle[out_format_desc->swizzle[i]] = i;
      ++dst_channels;

      if (i == alpha_channel) {
         has_alpha = true;
      }
   }

   if (format_expands_to_float_soa(out_format_desc)) {
      /*
       * the code above can't work for layout_other
       * for srgb it would sort of work but we short-circuit swizzles, etc.
       * as that is done as part of unpack / pack.
       */
      dst_channels = 4; /* HACK: this is fake 4 really but need it due to transpose stuff later */
      has_alpha = true;
      swizzle[0] = 0;
      swizzle[1] = 1;
      swizzle[2] = 2;
      swizzle[3] = 3;
      pad_inline = true; /* HACK: prevent rgbxrgbx->rgbrgbxx conversion later */
   }

   /* If 3 channels then pad to include alpha for 4 element transpose */
   if (dst_channels == 3 && !has_alpha) {
      for (i = 0; i < TGSI_NUM_CHANNELS; i++) {
         if (swizzle[i] > TGSI_NUM_CHANNELS)
            swizzle[i] = 3;
      }
      if (out_format_desc->nr_channels == 4) {
         dst_channels = 4;
      }
   }

   /*
    * Load shader output
    */
   for (i = 0; i < num_fullblock_fs; ++i) {
      /* Always load alpha for use in blending */
      LLVMValueRef alpha;
      if (i < num_fs) {
         alpha = LLVMBuildLoad(builder, fs_out_color[rt][alpha_channel][i], "");
      }
      else {
         alpha = undef_src_val;
      }

      /* Load each channel */
      for (j = 0; j < dst_channels; ++j) {
         assert(swizzle[j] < 4);
         if (i < num_fs) {
            fs_src[i][j] = LLVMBuildLoad(builder, fs_out_color[rt][swizzle[j]][i], "");
         }
         else {
            fs_src[i][j] = undef_src_val;
         }
      }

      /* If 3 channels then pad to include alpha for 4 element transpose */
      /*
       * XXX If we include that here maybe could actually use it instead of
       * separate alpha for blending?
       */
      if (dst_channels == 3 && !has_alpha) {
         fs_src[i][3] = alpha;
      }

      /* We split the row_mask and row_alpha as we want 128bit interleave */
      if (fs_type.length == 8) {
         src_mask[i*2 + 0]  = lp_build_extract_range(gallivm, fs_mask[i], 0, src_channels);
         src_mask[i*2 + 1]  = lp_build_extract_range(gallivm, fs_mask[i], src_channels, src_channels);

         src_alpha[i*2 + 0] = lp_build_extract_range(gallivm, alpha, 0, src_channels);
         src_alpha[i*2 + 1] = lp_build_extract_range(gallivm, alpha, src_channels, src_channels);
      } else {
         src_mask[i] = fs_mask[i];
         src_alpha[i] = alpha;
      }
   }
   if (dual_source_blend) {
      /* same as above except different src/dst, skip masks and comments... */
      for (i = 0; i < num_fullblock_fs; ++i) {
         LLVMValueRef alpha;
         if (i < num_fs) {
            alpha = LLVMBuildLoad(builder, fs_out_color[1][alpha_channel][i], "");
         }
         else {
            alpha = undef_src_val;
         }

         for (j = 0; j < dst_channels; ++j) {
            assert(swizzle[j] < 4);
            if (i < num_fs) {
               fs_src1[i][j] = LLVMBuildLoad(builder, fs_out_color[1][swizzle[j]][i], "");
            }
            else {
               fs_src1[i][j] = undef_src_val;
            }
         }
         if (dst_channels == 3 && !has_alpha) {
            fs_src1[i][3] = alpha;
         }
         if (fs_type.length == 8) {
            src1_alpha[i*2 + 0] = lp_build_extract_range(gallivm, alpha, 0, src_channels);
            src1_alpha[i*2 + 1] = lp_build_extract_range(gallivm, alpha, src_channels, src_channels);
         } else {
            src1_alpha[i] = alpha;
         }
      }
   }

   if (util_format_is_pure_integer(out_format)) {
      /*
       * In this case fs_type was really ints or uints disguised as floats,
       * fix that up now.
       */
      fs_type.floating = 0;
      fs_type.sign = dst_type.sign;
      for (i = 0; i < num_fullblock_fs; ++i) {
         for (j = 0; j < dst_channels; ++j) {
            fs_src[i][j] = LLVMBuildBitCast(builder, fs_src[i][j],
                                            lp_build_vec_type(gallivm, fs_type), "");
         }
         if (dst_channels == 3 && !has_alpha) {
            fs_src[i][3] = LLVMBuildBitCast(builder, fs_src[i][3],
                                            lp_build_vec_type(gallivm, fs_type), "");
         }
      }
   }

   /*
    * Pixel twiddle from fragment shader order to memory order
    */
   src_count = generate_fs_twiddle(gallivm, fs_type, num_fullblock_fs,
                                   dst_channels, fs_src, src, pad_inline);
   if (dual_source_blend) {
      generate_fs_twiddle(gallivm, fs_type, num_fullblock_fs, dst_channels,
                          fs_src1, src1, pad_inline);
   }

   src_channels = dst_channels < 3 ? dst_channels : 4;
   if (src_count != num_fullblock_fs * src_channels) {
      unsigned ds = src_count / (num_fullblock_fs * src_channels);
      row_type.length /= ds;
      fs_type.length = row_type.length;
   }

   blend_type = row_type;
   mask_type.length = 4;

   /* Convert src to row_type */
   if (dual_source_blend) {
      struct lp_type old_row_type = row_type;
      lp_build_conv_auto(gallivm, fs_type, &row_type, src, src_count, src);
      src_count = lp_build_conv_auto(gallivm, fs_type, &old_row_type, src1, src_count, src1);
   }
   else {
      src_count = lp_build_conv_auto(gallivm, fs_type, &row_type, src, src_count, src);
   }

   /* If the rows are not an SSE vector, combine them to become SSE size! */
   if ((row_type.width * row_type.length) % 128) {
      unsigned bits = row_type.width * row_type.length;
      unsigned combined;

      assert(src_count >= (vector_width / bits));

      dst_count = src_count / (vector_width / bits);

      combined = lp_build_concat_n(gallivm, row_type, src, src_count, src, dst_count);
      if (dual_source_blend) {
         lp_build_concat_n(gallivm, row_type, src1, src_count, src1, dst_count);
      }

      row_type.length *= combined;
      src_count /= combined;

      bits = row_type.width * row_type.length;
      assert(bits == 128 || bits == 256);
   }


   /*
    * Blend Colour conversion
    */
   blend_color = lp_jit_context_f_blend_color(gallivm, context_ptr);
   blend_color = LLVMBuildPointerCast(builder, blend_color, LLVMPointerType(lp_build_vec_type(gallivm, fs_type), 0), "");
   blend_color = LLVMBuildLoad(builder, LLVMBuildGEP(builder, blend_color, &i32_zero, 1, ""), "");

   /* Convert */
   lp_build_conv(gallivm, fs_type, blend_type, &blend_color, 1, &blend_color, 1);

   if (out_format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
      /*
       * since blending is done with floats, there was no conversion.
       * However, the rules according to fixed point renderbuffers still
       * apply, that is we must clamp inputs to 0.0/1.0.
       * (This would apply to separate alpha conversion too but we currently
       * force has_alpha to be true.)
       * TODO: should skip this with "fake" blend, since post-blend conversion
       * will clamp anyway.
       * TODO: could also skip this if fragment color clamping is enabled. We
       * don't support it natively so it gets baked into the shader however, so
       * can't really tell here.
       */
      struct lp_build_context f32_bld;
      assert(row_type.floating);
      lp_build_context_init(&f32_bld, gallivm, row_type);
      for (i = 0; i < src_count; i++) {
         src[i] = lp_build_clamp_zero_one_nanzero(&f32_bld, src[i]);
      }
      if (dual_source_blend) {
         for (i = 0; i < src_count; i++) {
            src1[i] = lp_build_clamp_zero_one_nanzero(&f32_bld, src1[i]);
         }
      }
      /* probably can't be different than row_type but better safe than sorry... */
      lp_build_context_init(&f32_bld, gallivm, blend_type);
      blend_color = lp_build_clamp(&f32_bld, blend_color, f32_bld.zero, f32_bld.one);
   }

   /* Extract alpha */
   blend_alpha = lp_build_extract_broadcast(gallivm, blend_type, row_type, blend_color, lp_build_const_int32(gallivm, 3));

   /* Swizzle to appropriate channels, e.g. from RGBA to BGRA BGRA */
   pad_inline &= (dst_channels * (block_size / src_count) * row_type.width) != vector_width;
   if (pad_inline) {
      /* Use all 4 channels e.g. from RGBA RGBA to RGxx RGxx */
      blend_color = lp_build_swizzle_aos_n(gallivm, blend_color, swizzle, TGSI_NUM_CHANNELS, row_type.length);
   } else {
      /* Only use dst_channels e.g. RGBA RGBA to RG RG xxxx */
      blend_color = lp_build_swizzle_aos_n(gallivm, blend_color, swizzle, dst_channels, row_type.length);
   }

   /*
    * Mask conversion
    */
   lp_bld_quad_twiddle(gallivm, mask_type, &src_mask[0], block_height, &src_mask[0]);

   if (src_count < block_height) {
      lp_build_concat_n(gallivm, mask_type, src_mask, 4, src_mask, src_count);
   } else if (src_count > block_height) {
      for (i = src_count; i > 0; --i) {
         unsigned pixels = block_size / src_count;
         unsigned idx = i - 1;

         src_mask[idx] = lp_build_extract_range(gallivm, src_mask[(idx * pixels) / 4],
                                                (idx * pixels) % 4, pixels);
      }
   }

   assert(mask_type.width == 32);

   for (i = 0; i < src_count; ++i) {
      unsigned pixels = block_size / src_count;
      unsigned pixel_width = row_type.width * dst_channels;

      if (pixel_width == 24) {
         mask_type.width = 8;
         mask_type.length = vector_width / mask_type.width;
      } else {
         mask_type.length = pixels;
         mask_type.width = row_type.width * dst_channels;

         src_mask[i] = LLVMBuildIntCast(builder, src_mask[i], lp_build_int_vec_type(gallivm, mask_type), "");

         mask_type.length *= dst_channels;
         mask_type.width /= dst_channels;
      }

      src_mask[i] = LLVMBuildBitCast(builder, src_mask[i], lp_build_int_vec_type(gallivm, mask_type), "");
      src_mask[i] = lp_build_pad_vector(gallivm, src_mask[i], row_type.length);
   }

   /*
    * Alpha conversion
    */
   if (!has_alpha) {
      struct lp_type alpha_type = fs_type;
      alpha_type.length = 4;
      convert_alpha(gallivm, row_type, alpha_type,
                    block_size, block_height,
                    src_count, dst_channels,
                    pad_inline, src_alpha);
      if (dual_source_blend) {
         convert_alpha(gallivm, row_type, alpha_type,
                       block_size, block_height,
                       src_count, dst_channels,
                       pad_inline, src1_alpha);
      }
   }


   /*
    * Load dst from memory
    */
   if (src_count < block_height) {
      dst_count = block_height;
   } else {
      dst_count = src_count;
   }

   dst_type.length *= block_size / dst_count;

   if (format_expands_to_float_soa(out_format_desc)) {
      /*
       * we need multiple values at once for the conversion, so can as well
       * load them vectorized here too instead of concatenating later.
       * (Still need concatenation later for 8-wide vectors).
       */
      dst_count = block_height;
      dst_type.length = block_width;
   }

   /*
    * Compute the alignment of the destination pointer in bytes
    * We fetch 1-4 pixels, if the format has pot alignment then those fetches
    * are always aligned by MIN2(16, fetch_width) except for buffers (not
    * 1d tex but can't distinguish here) so need to stick with per-pixel
    * alignment in this case.
    */
   if (is_1d) {
      dst_alignment = (out_format_desc->block.bits + 7)/(out_format_desc->block.width * 8);
   }
   else {
      dst_alignment = dst_type.length * dst_type.width / 8;
   }
   /* Force power-of-two alignment by extracting only the least-significant-bit */
   dst_alignment = 1 << (ffs(dst_alignment) - 1);
   /*
    * Resource base and stride pointers are aligned to 16 bytes, so that's
    * the maximum alignment we can guarantee
    */
   dst_alignment = MIN2(16, dst_alignment);

   if (is_1d) {
      load_unswizzled_block(gallivm, color_ptr, stride, block_width, 1,
                            dst, dst_type, dst_count / 4, dst_alignment);
      for (i = dst_count / 4; i < dst_count; i++) {
         dst[i] = lp_build_undef(gallivm, dst_type);
      }

   }
   else {
      load_unswizzled_block(gallivm, color_ptr, stride, block_width, block_height,
                            dst, dst_type, dst_count, dst_alignment);
   }


   /*
    * Convert from dst/output format to src/blending format.
    *
    * This is necessary as we can only read 1 row from memory at a time,
    * so the minimum dst_count will ever be at this point is 4.
    *
    * With, for example, R8 format you can have all 16 pixels in a 128 bit vector,
    * this will take the 4 dsts and combine them into 1 src so we can perform blending
    * on all 16 pixels in that single vector at once.
    */
   if (dst_count > src_count) {
      lp_build_concat_n(gallivm, dst_type, dst, 4, dst, src_count);
   }

   /*
    * Blending
    */
   /* XXX this is broken for RGB8 formats -
    * they get expanded from 12 to 16 elements (to include alpha)
    * by convert_to_blend_type then reduced to 15 instead of 12
    * by convert_from_blend_type (a simple fix though breaks A8...).
    * R16G16B16 also crashes differently however something going wrong
    * inside llvm handling npot vector sizes seemingly.
    * It seems some cleanup could be done here (like skipping conversion/blend
    * when not needed).
    */
   convert_to_blend_type(gallivm, block_size, out_format_desc, dst_type, row_type, dst, src_count);

   /*
    * FIXME: Really should get logic ops / masks out of generic blend / row
    * format. Logic ops will definitely not work on the blend float format
    * used for SRGB here and I think OpenGL expects this to work as expected
    * (that is incoming values converted to srgb then logic op applied).
    */
   for (i = 0; i < src_count; ++i) {
      dst[i] = lp_build_blend_aos(gallivm,
                                  &variant->key.blend,
                                  out_format,
                                  row_type,
                                  rt,
                                  src[i],
                                  has_alpha ? NULL : src_alpha[i],
                                  src1[i],
                                  has_alpha ? NULL : src1_alpha[i],
                                  dst[i],
                                  partial_mask ? src_mask[i] : NULL,
                                  blend_color,
                                  has_alpha ? NULL : blend_alpha,
                                  swizzle,
                                  pad_inline ? 4 : dst_channels);
   }

   convert_from_blend_type(gallivm, block_size, out_format_desc, row_type, dst_type, dst, src_count);

   /* Split the blend rows back to memory rows */
   if (dst_count > src_count) {
      row_type.length = dst_type.length * (dst_count / src_count);

      if (src_count == 1) {
         dst[1] = lp_build_extract_range(gallivm, dst[0], row_type.length / 2, row_type.length / 2);
         dst[0] = lp_build_extract_range(gallivm, dst[0], 0, row_type.length / 2);

         row_type.length /= 2;
         src_count *= 2;
      }

      dst[3] = lp_build_extract_range(gallivm, dst[1], row_type.length / 2, row_type.length / 2);
      dst[2] = lp_build_extract_range(gallivm, dst[1], 0, row_type.length / 2);
      dst[1] = lp_build_extract_range(gallivm, dst[0], row_type.length / 2, row_type.length / 2);
      dst[0] = lp_build_extract_range(gallivm, dst[0], 0, row_type.length / 2);

      row_type.length /= 2;
      src_count *= 2;
   }

   /*
    * Store blend result to memory
    */
   if (is_1d) {
      store_unswizzled_block(gallivm, color_ptr, stride, block_width, 1,
                             dst, dst_type, dst_count / 4, dst_alignment);
   }
   else {
      store_unswizzled_block(gallivm, color_ptr, stride, block_width, block_height,
                             dst, dst_type, dst_count, dst_alignment);
   }

   if (have_smallfloat_format(dst_type, out_format)) {
      lp_build_fpstate_set(gallivm, fpstate);
   }

   if (do_branch) {
      lp_build_mask_end(&mask_ctx);
   }
}


/**
 * Generate the runtime callable function for the whole fragment pipeline.
 * Note that the function which we generate operates on a block of 16
 * pixels at at time.  The block contains 2x2 quads.  Each quad contains
 * 2x2 pixels.
 */
static void
generate_fragment(struct llvmpipe_context *lp,
                  struct lp_fragment_shader *shader,
                  struct lp_fragment_shader_variant *variant,
                  unsigned partial_mask)
{
   struct gallivm_state *gallivm = variant->gallivm;
   const struct lp_fragment_shader_variant_key *key = &variant->key;
   struct lp_shader_input inputs[PIPE_MAX_SHADER_INPUTS];
   char func_name[256];
   struct lp_type fs_type;
   struct lp_type blend_type;
   LLVMTypeRef fs_elem_type;
   LLVMTypeRef blend_vec_type;
   LLVMTypeRef arg_types[13];
   LLVMTypeRef func_type;
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMTypeRef int8_type = LLVMInt8TypeInContext(gallivm->context);
   LLVMValueRef context_ptr;
   LLVMValueRef x;
   LLVMValueRef y;
   LLVMValueRef a0_ptr;
   LLVMValueRef dadx_ptr;
   LLVMValueRef dady_ptr;
   LLVMValueRef color_ptr_ptr;
   LLVMValueRef stride_ptr;
   LLVMValueRef depth_ptr;
   LLVMValueRef depth_stride;
   LLVMValueRef mask_input;
   LLVMValueRef thread_data_ptr;
   LLVMBasicBlockRef block;
   LLVMBuilderRef builder;
   struct lp_build_sampler_soa *sampler;
   struct lp_build_interp_soa_context interp;
   LLVMValueRef fs_mask[16 / 4];
   LLVMValueRef fs_out_color[PIPE_MAX_COLOR_BUFS][TGSI_NUM_CHANNELS][16 / 4];
   LLVMValueRef function;
   LLVMValueRef facing;
   unsigned num_fs;
   unsigned i;
   unsigned chan;
   unsigned cbuf;
   boolean cbuf0_write_all;
   const boolean dual_source_blend = key->blend.rt[0].blend_enable &&
                                     util_blend_state_is_dual(&key->blend, 0);

   assert(lp_native_vector_width / 32 >= 4);

   /* Adjust color input interpolation according to flatshade state:
    */
   memcpy(inputs, shader->inputs, shader->info.base.num_inputs * sizeof inputs[0]);
   for (i = 0; i < shader->info.base.num_inputs; i++) {
      if (inputs[i].interp == LP_INTERP_COLOR) {
	 if (key->flatshade)
	    inputs[i].interp = LP_INTERP_CONSTANT;
	 else
	    inputs[i].interp = LP_INTERP_PERSPECTIVE;
      }
   }

   /* check if writes to cbuf[0] are to be copied to all cbufs */
   cbuf0_write_all = FALSE;
   for (i = 0;i < shader->info.base.num_properties; i++) {
      if (shader->info.base.properties[i].name ==
          TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS) {
         cbuf0_write_all = TRUE;
         break;
      }
   }

   /* TODO: actually pick these based on the fs and color buffer
    * characteristics. */

   memset(&fs_type, 0, sizeof fs_type);
   fs_type.floating = TRUE;      /* floating point values */
   fs_type.sign = TRUE;          /* values are signed */
   fs_type.norm = FALSE;         /* values are not limited to [0,1] or [-1,1] */
   fs_type.width = 32;           /* 32-bit float */
   fs_type.length = MIN2(lp_native_vector_width / 32, 16); /* n*4 elements per vector */

   memset(&blend_type, 0, sizeof blend_type);
   blend_type.floating = FALSE; /* values are integers */
   blend_type.sign = FALSE;     /* values are unsigned */
   blend_type.norm = TRUE;      /* values are in [0,1] or [-1,1] */
   blend_type.width = 8;        /* 8-bit ubyte values */
   blend_type.length = 16;      /* 16 elements per vector */

   /* 
    * Generate the function prototype. Any change here must be reflected in
    * lp_jit.h's lp_jit_frag_func function pointer type, and vice-versa.
    */

   fs_elem_type = lp_build_elem_type(gallivm, fs_type);

   blend_vec_type = lp_build_vec_type(gallivm, blend_type);

   util_snprintf(func_name, sizeof(func_name), "fs%u_variant%u_%s", 
		 shader->no, variant->no, partial_mask ? "partial" : "whole");

   arg_types[0] = variant->jit_context_ptr_type;       /* context */
   arg_types[1] = int32_type;                          /* x */
   arg_types[2] = int32_type;                          /* y */
   arg_types[3] = int32_type;                          /* facing */
   arg_types[4] = LLVMPointerType(fs_elem_type, 0);    /* a0 */
   arg_types[5] = LLVMPointerType(fs_elem_type, 0);    /* dadx */
   arg_types[6] = LLVMPointerType(fs_elem_type, 0);    /* dady */
   arg_types[7] = LLVMPointerType(LLVMPointerType(blend_vec_type, 0), 0);  /* color */
   arg_types[8] = LLVMPointerType(int8_type, 0);       /* depth */
   arg_types[9] = int32_type;                          /* mask_input */
   arg_types[10] = variant->jit_thread_data_ptr_type;  /* per thread data */
   arg_types[11] = LLVMPointerType(int32_type, 0);     /* stride */
   arg_types[12] = int32_type;                         /* depth_stride */

   func_type = LLVMFunctionType(LLVMVoidTypeInContext(gallivm->context),
                                arg_types, Elements(arg_types), 0);

   function = LLVMAddFunction(gallivm->module, func_name, func_type);
   LLVMSetFunctionCallConv(function, LLVMCCallConv);

   variant->function[partial_mask] = function;

   /* XXX: need to propagate noalias down into color param now we are
    * passing a pointer-to-pointer?
    */
   for(i = 0; i < Elements(arg_types); ++i)
      if(LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
         LLVMAddAttribute(LLVMGetParam(function, i), LLVMNoAliasAttribute);

   context_ptr  = LLVMGetParam(function, 0);
   x            = LLVMGetParam(function, 1);
   y            = LLVMGetParam(function, 2);
   facing       = LLVMGetParam(function, 3);
   a0_ptr       = LLVMGetParam(function, 4);
   dadx_ptr     = LLVMGetParam(function, 5);
   dady_ptr     = LLVMGetParam(function, 6);
   color_ptr_ptr = LLVMGetParam(function, 7);
   depth_ptr    = LLVMGetParam(function, 8);
   mask_input   = LLVMGetParam(function, 9);
   thread_data_ptr  = LLVMGetParam(function, 10);
   stride_ptr   = LLVMGetParam(function, 11);
   depth_stride = LLVMGetParam(function, 12);

   lp_build_name(context_ptr, "context");
   lp_build_name(x, "x");
   lp_build_name(y, "y");
   lp_build_name(a0_ptr, "a0");
   lp_build_name(dadx_ptr, "dadx");
   lp_build_name(dady_ptr, "dady");
   lp_build_name(color_ptr_ptr, "color_ptr_ptr");
   lp_build_name(depth_ptr, "depth");
   lp_build_name(thread_data_ptr, "thread_data");
   lp_build_name(mask_input, "mask_input");
   lp_build_name(stride_ptr, "stride_ptr");
   lp_build_name(depth_stride, "depth_stride");

   /*
    * Function body
    */

   block = LLVMAppendBasicBlockInContext(gallivm->context, function, "entry");
   builder = gallivm->builder;
   assert(builder);
   LLVMPositionBuilderAtEnd(builder, block);

   /* code generated texture sampling */
   sampler = lp_llvm_sampler_soa_create(key->state, context_ptr);

   num_fs = 16 / fs_type.length; /* number of loops per 4x4 stamp */
   /* for 1d resources only run "upper half" of stamp */
   if (key->resource_1d)
      num_fs /= 2;

   {
      LLVMValueRef num_loop = lp_build_const_int32(gallivm, num_fs);
      LLVMTypeRef mask_type = lp_build_int_vec_type(gallivm, fs_type);
      LLVMValueRef mask_store = lp_build_array_alloca(gallivm, mask_type,
                                                      num_loop, "mask_store");
      LLVMValueRef color_store[PIPE_MAX_COLOR_BUFS][TGSI_NUM_CHANNELS];

      /*
       * The shader input interpolation info is not explicitely baked in the
       * shader key, but everything it derives from (TGSI, and flatshade) is
       * already included in the shader key.
       */
      lp_build_interp_soa_init(&interp,
                               gallivm,
                               shader->info.base.num_inputs,
                               inputs,
                               shader->info.base.pixel_center_integer,
                               builder, fs_type,
                               a0_ptr, dadx_ptr, dady_ptr,
                               x, y);

      for (i = 0; i < num_fs; i++) {
         LLVMValueRef mask;
         LLVMValueRef indexi = lp_build_const_int32(gallivm, i);
         LLVMValueRef mask_ptr = LLVMBuildGEP(builder, mask_store,
                                              &indexi, 1, "mask_ptr");

         if (partial_mask) {
            mask = generate_quad_mask(gallivm, fs_type,
                                      i*fs_type.length/4, mask_input);
         }
         else {
            mask = lp_build_const_int_vec(gallivm, fs_type, ~0);
         }
         LLVMBuildStore(builder, mask, mask_ptr);
      }

      generate_fs_loop(gallivm,
                       shader, key,
                       builder,
                       fs_type,
                       context_ptr,
                       num_loop,
                       &interp,
                       sampler,
                       mask_store, /* output */
                       color_store,
                       depth_ptr,
                       depth_stride,
                       facing,
                       thread_data_ptr);

      for (i = 0; i < num_fs; i++) {
         LLVMValueRef indexi = lp_build_const_int32(gallivm, i);
         LLVMValueRef ptr = LLVMBuildGEP(builder, mask_store,
                                         &indexi, 1, "");
         fs_mask[i] = LLVMBuildLoad(builder, ptr, "mask");
         /* This is fucked up need to reorganize things */
         for (cbuf = 0; cbuf < key->nr_cbufs; cbuf++) {
            for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
               ptr = LLVMBuildGEP(builder,
                                  color_store[cbuf * !cbuf0_write_all][chan],
                                  &indexi, 1, "");
               fs_out_color[cbuf][chan][i] = ptr;
            }
         }
         if (dual_source_blend) {
            /* only support one dual source blend target hence always use output 1 */
            for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
               ptr = LLVMBuildGEP(builder,
                                  color_store[1][chan],
                                  &indexi, 1, "");
               fs_out_color[1][chan][i] = ptr;
            }
         }
      }
   }

   sampler->destroy(sampler);

   /* Loop over color outputs / color buffers to do blending.
    */
   for(cbuf = 0; cbuf < key->nr_cbufs; cbuf++) {
      if (key->cbuf_format[cbuf] != PIPE_FORMAT_NONE) {
         LLVMValueRef color_ptr;
         LLVMValueRef stride;
         LLVMValueRef index = lp_build_const_int32(gallivm, cbuf);

         boolean do_branch = ((key->depth.enabled
                               || key->stencil[0].enabled
                               || key->alpha.enabled)
                              && !shader->info.base.uses_kill);

         color_ptr = LLVMBuildLoad(builder,
                                   LLVMBuildGEP(builder, color_ptr_ptr,
                                                &index, 1, ""),
                                   "");

         lp_build_name(color_ptr, "color_ptr%d", cbuf);

         stride = LLVMBuildLoad(builder,
                                LLVMBuildGEP(builder, stride_ptr, &index, 1, ""),
                                "");

         generate_unswizzled_blend(gallivm, cbuf, variant,
                                   key->cbuf_format[cbuf],
                                   num_fs, fs_type, fs_mask, fs_out_color,
                                   context_ptr, color_ptr, stride,
                                   partial_mask, do_branch);
      }
   }

   LLVMBuildRetVoid(builder);

   gallivm_verify_function(gallivm, function);

   variant->nr_instrs += lp_build_count_instructions(function);
}


static void
dump_fs_variant_key(const struct lp_fragment_shader_variant_key *key)
{
   unsigned i;

   debug_printf("fs variant %p:\n", (void *) key);

   if (key->flatshade) {
      debug_printf("flatshade = 1\n");
   }
   for (i = 0; i < key->nr_cbufs; ++i) {
      debug_printf("cbuf_format[%u] = %s\n", i, util_format_name(key->cbuf_format[i]));
   }
   if (key->depth.enabled) {
      debug_printf("depth.format = %s\n", util_format_name(key->zsbuf_format));
      debug_printf("depth.func = %s\n", util_dump_func(key->depth.func, TRUE));
      debug_printf("depth.writemask = %u\n", key->depth.writemask);
   }

   for (i = 0; i < 2; ++i) {
      if (key->stencil[i].enabled) {
         debug_printf("stencil[%u].func = %s\n", i, util_dump_func(key->stencil[i].func, TRUE));
         debug_printf("stencil[%u].fail_op = %s\n", i, util_dump_stencil_op(key->stencil[i].fail_op, TRUE));
         debug_printf("stencil[%u].zpass_op = %s\n", i, util_dump_stencil_op(key->stencil[i].zpass_op, TRUE));
         debug_printf("stencil[%u].zfail_op = %s\n", i, util_dump_stencil_op(key->stencil[i].zfail_op, TRUE));
         debug_printf("stencil[%u].valuemask = 0x%x\n", i, key->stencil[i].valuemask);
         debug_printf("stencil[%u].writemask = 0x%x\n", i, key->stencil[i].writemask);
      }
   }

   if (key->alpha.enabled) {
      debug_printf("alpha.func = %s\n", util_dump_func(key->alpha.func, TRUE));
   }

   if (key->occlusion_count) {
      debug_printf("occlusion_count = 1\n");
   }

   if (key->blend.logicop_enable) {
      debug_printf("blend.logicop_func = %s\n", util_dump_logicop(key->blend.logicop_func, TRUE));
   }
   else if (key->blend.rt[0].blend_enable) {
      debug_printf("blend.rgb_func = %s\n",   util_dump_blend_func  (key->blend.rt[0].rgb_func, TRUE));
      debug_printf("blend.rgb_src_factor = %s\n",   util_dump_blend_factor(key->blend.rt[0].rgb_src_factor, TRUE));
      debug_printf("blend.rgb_dst_factor = %s\n",   util_dump_blend_factor(key->blend.rt[0].rgb_dst_factor, TRUE));
      debug_printf("blend.alpha_func = %s\n",       util_dump_blend_func  (key->blend.rt[0].alpha_func, TRUE));
      debug_printf("blend.alpha_src_factor = %s\n", util_dump_blend_factor(key->blend.rt[0].alpha_src_factor, TRUE));
      debug_printf("blend.alpha_dst_factor = %s\n", util_dump_blend_factor(key->blend.rt[0].alpha_dst_factor, TRUE));
   }
   debug_printf("blend.colormask = 0x%x\n", key->blend.rt[0].colormask);
   if (key->blend.alpha_to_coverage) {
      debug_printf("blend.alpha_to_coverage is enabled\n");
   }
   for (i = 0; i < key->nr_samplers; ++i) {
      const struct lp_static_sampler_state *sampler = &key->state[i].sampler_state;
      debug_printf("sampler[%u] = \n", i);
      debug_printf("  .wrap = %s %s %s\n",
                   util_dump_tex_wrap(sampler->wrap_s, TRUE),
                   util_dump_tex_wrap(sampler->wrap_t, TRUE),
                   util_dump_tex_wrap(sampler->wrap_r, TRUE));
      debug_printf("  .min_img_filter = %s\n",
                   util_dump_tex_filter(sampler->min_img_filter, TRUE));
      debug_printf("  .min_mip_filter = %s\n",
                   util_dump_tex_mipfilter(sampler->min_mip_filter, TRUE));
      debug_printf("  .mag_img_filter = %s\n",
                   util_dump_tex_filter(sampler->mag_img_filter, TRUE));
      if (sampler->compare_mode != PIPE_TEX_COMPARE_NONE)
         debug_printf("  .compare_func = %s\n", util_dump_func(sampler->compare_func, TRUE));
      debug_printf("  .normalized_coords = %u\n", sampler->normalized_coords);
      debug_printf("  .min_max_lod_equal = %u\n", sampler->min_max_lod_equal);
      debug_printf("  .lod_bias_non_zero = %u\n", sampler->lod_bias_non_zero);
      debug_printf("  .apply_min_lod = %u\n", sampler->apply_min_lod);
      debug_printf("  .apply_max_lod = %u\n", sampler->apply_max_lod);
   }
   for (i = 0; i < key->nr_sampler_views; ++i) {
      const struct lp_static_texture_state *texture = &key->state[i].texture_state;
      debug_printf("texture[%u] = \n", i);
      debug_printf("  .format = %s\n",
                   util_format_name(texture->format));
      debug_printf("  .target = %s\n",
                   util_dump_tex_target(texture->target, TRUE));
      debug_printf("  .level_zero_only = %u\n",
                   texture->level_zero_only);
      debug_printf("  .pot = %u %u %u\n",
                   texture->pot_width,
                   texture->pot_height,
                   texture->pot_depth);
   }
}


void
lp_debug_fs_variant(const struct lp_fragment_shader_variant *variant)
{
   debug_printf("llvmpipe: Fragment shader #%u variant #%u:\n", 
                variant->shader->no, variant->no);
   tgsi_dump(variant->shader->base.tokens, 0);
   dump_fs_variant_key(&variant->key);
   debug_printf("variant->opaque = %u\n", variant->opaque);
   debug_printf("\n");
}


/**
 * Generate a new fragment shader variant from the shader code and
 * other state indicated by the key.
 */
static struct lp_fragment_shader_variant *
generate_variant(struct llvmpipe_context *lp,
                 struct lp_fragment_shader *shader,
                 const struct lp_fragment_shader_variant_key *key)
{
   struct lp_fragment_shader_variant *variant;
   const struct util_format_description *cbuf0_format_desc;
   boolean fullcolormask;

   variant = CALLOC_STRUCT(lp_fragment_shader_variant);
   if(!variant)
      return NULL;

   variant->gallivm = gallivm_create();
   if (!variant->gallivm) {
      FREE(variant);
      return NULL;
   }

   variant->shader = shader;
   variant->list_item_global.base = variant;
   variant->list_item_local.base = variant;
   variant->no = shader->variants_created++;

   memcpy(&variant->key, key, shader->variant_key_size);

   /*
    * Determine whether we are touching all channels in the color buffer.
    */
   fullcolormask = FALSE;
   if (key->nr_cbufs == 1) {
      cbuf0_format_desc = util_format_description(key->cbuf_format[0]);
      fullcolormask = util_format_colormask_full(cbuf0_format_desc, key->blend.rt[0].colormask);
   }

   variant->opaque =
         !key->blend.logicop_enable &&
         !key->blend.rt[0].blend_enable &&
         fullcolormask &&
         !key->stencil[0].enabled &&
         !key->alpha.enabled &&
         !key->blend.alpha_to_coverage &&
         !key->depth.enabled &&
         !shader->info.base.uses_kill
      ? TRUE : FALSE;

   if ((shader->info.base.num_tokens <= 1) &&
       !key->depth.enabled && !key->stencil[0].enabled) {
      variant->ps_inv_multiplier = 0;
   } else {
      variant->ps_inv_multiplier = 1;
   }

   if ((LP_DEBUG & DEBUG_FS) || (gallivm_debug & GALLIVM_DEBUG_IR)) {
      lp_debug_fs_variant(variant);
   }

   lp_jit_init_types(variant);
   
   if (variant->jit_function[RAST_EDGE_TEST] == NULL)
      generate_fragment(lp, shader, variant, RAST_EDGE_TEST);

   if (variant->jit_function[RAST_WHOLE] == NULL) {
      if (variant->opaque) {
         /* Specialized shader, which doesn't need to read the color buffer. */
         generate_fragment(lp, shader, variant, RAST_WHOLE);
      }
   }

   /*
    * Compile everything
    */

   gallivm_compile_module(variant->gallivm);

   if (variant->function[RAST_EDGE_TEST]) {
      variant->jit_function[RAST_EDGE_TEST] = (lp_jit_frag_func)
            gallivm_jit_function(variant->gallivm,
                                 variant->function[RAST_EDGE_TEST]);
   }

   if (variant->function[RAST_WHOLE]) {
         variant->jit_function[RAST_WHOLE] = (lp_jit_frag_func)
               gallivm_jit_function(variant->gallivm,
                                    variant->function[RAST_WHOLE]);
   } else if (!variant->jit_function[RAST_WHOLE]) {
      variant->jit_function[RAST_WHOLE] = variant->jit_function[RAST_EDGE_TEST];
   }

   return variant;
}


static void *
llvmpipe_create_fs_state(struct pipe_context *pipe,
                         const struct pipe_shader_state *templ)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   struct lp_fragment_shader *shader;
   int nr_samplers;
   int nr_sampler_views;
   int i;

   shader = CALLOC_STRUCT(lp_fragment_shader);
   if (!shader)
      return NULL;

   shader->no = fs_no++;
   make_empty_list(&shader->variants);

   /* get/save the summary info for this shader */
   lp_build_tgsi_info(templ->tokens, &shader->info);

   /* we need to keep a local copy of the tokens */
   shader->base.tokens = tgsi_dup_tokens(templ->tokens);

   shader->draw_data = draw_create_fragment_shader(llvmpipe->draw, templ);
   if (shader->draw_data == NULL) {
      FREE((void *) shader->base.tokens);
      FREE(shader);
      return NULL;
   }

   nr_samplers = shader->info.base.file_max[TGSI_FILE_SAMPLER] + 1;
   nr_sampler_views = shader->info.base.file_max[TGSI_FILE_SAMPLER_VIEW] + 1;

   shader->variant_key_size = Offset(struct lp_fragment_shader_variant_key,
                                     state[MAX2(nr_samplers, nr_sampler_views)]);

   for (i = 0; i < shader->info.base.num_inputs; i++) {
      shader->inputs[i].usage_mask = shader->info.base.input_usage_mask[i];
      shader->inputs[i].cyl_wrap = shader->info.base.input_cylindrical_wrap[i];

      switch (shader->info.base.input_interpolate[i]) {
      case TGSI_INTERPOLATE_CONSTANT:
	 shader->inputs[i].interp = LP_INTERP_CONSTANT;
	 break;
      case TGSI_INTERPOLATE_LINEAR:
	 shader->inputs[i].interp = LP_INTERP_LINEAR;
	 break;
      case TGSI_INTERPOLATE_PERSPECTIVE:
	 shader->inputs[i].interp = LP_INTERP_PERSPECTIVE;
	 break;
      case TGSI_INTERPOLATE_COLOR:
	 shader->inputs[i].interp = LP_INTERP_COLOR;
	 break;
      default:
	 assert(0);
	 break;
      }

      switch (shader->info.base.input_semantic_name[i]) {
      case TGSI_SEMANTIC_FACE:
	 shader->inputs[i].interp = LP_INTERP_FACING;
	 break;
      case TGSI_SEMANTIC_POSITION:
	 /* Position was already emitted above
	  */
	 shader->inputs[i].interp = LP_INTERP_POSITION;
	 shader->inputs[i].src_index = 0;
	 continue;
      }

      shader->inputs[i].src_index = i+1;
   }

   if (LP_DEBUG & DEBUG_TGSI) {
      unsigned attrib;
      debug_printf("llvmpipe: Create fragment shader #%u %p:\n",
                   shader->no, (void *) shader);
      tgsi_dump(templ->tokens, 0);
      debug_printf("usage masks:\n");
      for (attrib = 0; attrib < shader->info.base.num_inputs; ++attrib) {
         unsigned usage_mask = shader->info.base.input_usage_mask[attrib];
         debug_printf("  IN[%u].%s%s%s%s\n",
                      attrib,
                      usage_mask & TGSI_WRITEMASK_X ? "x" : "",
                      usage_mask & TGSI_WRITEMASK_Y ? "y" : "",
                      usage_mask & TGSI_WRITEMASK_Z ? "z" : "",
                      usage_mask & TGSI_WRITEMASK_W ? "w" : "");
      }
      debug_printf("\n");
   }

   return shader;
}


static void
llvmpipe_bind_fs_state(struct pipe_context *pipe, void *fs)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);

   if (llvmpipe->fs == fs)
      return;

   llvmpipe->fs = (struct lp_fragment_shader *) fs;

   draw_bind_fragment_shader(llvmpipe->draw,
                             (llvmpipe->fs ? llvmpipe->fs->draw_data : NULL));

   llvmpipe->dirty |= LP_NEW_FS;
}


/**
 * Remove shader variant from two lists: the shader's variant list
 * and the context's variant list.
 */
void
llvmpipe_remove_shader_variant(struct llvmpipe_context *lp,
                               struct lp_fragment_shader_variant *variant)
{
   unsigned i;

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      debug_printf("llvmpipe: del fs #%u var #%u v created #%u v cached"
                   " #%u v total cached #%u\n",
                   variant->shader->no,
                   variant->no,
                   variant->shader->variants_created,
                   variant->shader->variants_cached,
                   lp->nr_fs_variants);
   }

   /* free all the variant's JIT'd functions */
   for (i = 0; i < Elements(variant->function); i++) {
      if (variant->function[i]) {
         gallivm_free_function(variant->gallivm,
                               variant->function[i],
                               variant->jit_function[i]);
      }
   }

   gallivm_destroy(variant->gallivm);

   /* remove from shader's list */
   remove_from_list(&variant->list_item_local);
   variant->shader->variants_cached--;

   /* remove from context's list */
   remove_from_list(&variant->list_item_global);
   lp->nr_fs_variants--;
   lp->nr_fs_instrs -= variant->nr_instrs;

   FREE(variant);
}


static void
llvmpipe_delete_fs_state(struct pipe_context *pipe, void *fs)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   struct lp_fragment_shader *shader = fs;
   struct lp_fs_variant_list_item *li;

   assert(fs != llvmpipe->fs);

   /*
    * XXX: we need to flush the context until we have some sort of reference
    * counting in fragment shaders as they may still be binned
    * Flushing alone might not sufficient we need to wait on it too.
    */
   llvmpipe_finish(pipe, __FUNCTION__);

   /* Delete all the variants */
   li = first_elem(&shader->variants);
   while(!at_end(&shader->variants, li)) {
      struct lp_fs_variant_list_item *next = next_elem(li);
      llvmpipe_remove_shader_variant(llvmpipe, li->base);
      li = next;
   }

   /* Delete draw module's data */
   draw_delete_fragment_shader(llvmpipe->draw, shader->draw_data);

   assert(shader->variants_cached == 0);
   FREE((void *) shader->base.tokens);
   FREE(shader);
}



static void
llvmpipe_set_constant_buffer(struct pipe_context *pipe,
                             uint shader, uint index,
                             struct pipe_constant_buffer *cb)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   struct pipe_resource *constants = cb ? cb->buffer : NULL;

   assert(shader < PIPE_SHADER_TYPES);
   assert(index < Elements(llvmpipe->constants[shader]));

   /* note: reference counting */
   util_copy_constant_buffer(&llvmpipe->constants[shader][index], cb);

   if (shader == PIPE_SHADER_VERTEX ||
       shader == PIPE_SHADER_GEOMETRY) {
      /* Pass the constants to the 'draw' module */
      const unsigned size = cb ? cb->buffer_size : 0;
      const ubyte *data;

      if (constants) {
         data = (ubyte *) llvmpipe_resource_data(constants);
      }
      else if (cb && cb->user_buffer) {
         data = (ubyte *) cb->user_buffer;
      }
      else {
         data = NULL;
      }

      if (data)
         data += cb->buffer_offset;

      draw_set_mapped_constant_buffer(llvmpipe->draw, shader,
                                      index, data, size);
   }

   llvmpipe->dirty |= LP_NEW_CONSTANTS;

   if (cb && cb->user_buffer) {
      pipe_resource_reference(&constants, NULL);
   }
}


/**
 * Return the blend factor equivalent to a destination alpha of one.
 */
static INLINE unsigned
force_dst_alpha_one(unsigned factor, boolean clamped_zero)
{
   switch(factor) {
   case PIPE_BLENDFACTOR_DST_ALPHA:
      return PIPE_BLENDFACTOR_ONE;
   case PIPE_BLENDFACTOR_INV_DST_ALPHA:
      return PIPE_BLENDFACTOR_ZERO;
   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
      if (clamped_zero)
         return PIPE_BLENDFACTOR_ZERO;
      else
         return PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE;
   }

   return factor;
}


/**
 * We need to generate several variants of the fragment pipeline to match
 * all the combinations of the contributing state atoms.
 *
 * TODO: there is actually no reason to tie this to context state -- the
 * generated code could be cached globally in the screen.
 */
static void
make_variant_key(struct llvmpipe_context *lp,
                 struct lp_fragment_shader *shader,
                 struct lp_fragment_shader_variant_key *key)
{
   unsigned i;

   memset(key, 0, shader->variant_key_size);

   if (lp->framebuffer.zsbuf) {
      enum pipe_format zsbuf_format = lp->framebuffer.zsbuf->format;
      const struct util_format_description *zsbuf_desc =
         util_format_description(zsbuf_format);

      if (lp->depth_stencil->depth.enabled &&
          util_format_has_depth(zsbuf_desc)) {
         key->zsbuf_format = zsbuf_format;
         memcpy(&key->depth, &lp->depth_stencil->depth, sizeof key->depth);
      }
      if (lp->depth_stencil->stencil[0].enabled &&
          util_format_has_stencil(zsbuf_desc)) {
         key->zsbuf_format = zsbuf_format;
         memcpy(&key->stencil, &lp->depth_stencil->stencil, sizeof key->stencil);
      }
      if (llvmpipe_resource_is_1d(lp->framebuffer.zsbuf->texture)) {
         key->resource_1d = TRUE;
      }
   }

   /*
    * Propagate the depth clamp setting from the rasterizer state.
    * depth_clip == 0 implies depth clamping is enabled.
    *
    * When clip_halfz is enabled, then always clamp the depth values.
    */
   if (lp->rasterizer->clip_halfz) {
      key->depth_clamp = 1;
   } else {
      key->depth_clamp = (lp->rasterizer->depth_clip == 0) ? 1 : 0;
   }

   /* alpha test only applies if render buffer 0 is non-integer (or does not exist) */
   if (!lp->framebuffer.nr_cbufs ||
       !lp->framebuffer.cbufs[0] ||
       !util_format_is_pure_integer(lp->framebuffer.cbufs[0]->format)) {
      key->alpha.enabled = lp->depth_stencil->alpha.enabled;
   }
   if(key->alpha.enabled)
      key->alpha.func = lp->depth_stencil->alpha.func;
   /* alpha.ref_value is passed in jit_context */

   key->flatshade = lp->rasterizer->flatshade;
   if (lp->active_occlusion_queries) {
      key->occlusion_count = TRUE;
   }

   if (lp->framebuffer.nr_cbufs) {
      memcpy(&key->blend, lp->blend, sizeof key->blend);
   }

   key->nr_cbufs = lp->framebuffer.nr_cbufs;

   if (!key->blend.independent_blend_enable) {
      /* we always need independent blend otherwise the fixups below won't work */
      for (i = 1; i < key->nr_cbufs; i++) {
         memcpy(&key->blend.rt[i], &key->blend.rt[0], sizeof(key->blend.rt[0]));
      }
      key->blend.independent_blend_enable = 1;
   }

   for (i = 0; i < lp->framebuffer.nr_cbufs; i++) {
      struct pipe_rt_blend_state *blend_rt = &key->blend.rt[i];

      if (lp->framebuffer.cbufs[i]) {
         enum pipe_format format = lp->framebuffer.cbufs[i]->format;
         const struct util_format_description *format_desc;

         key->cbuf_format[i] = format;

         /*
          * Figure out if this is a 1d resource. Note that OpenGL allows crazy
          * mixing of 2d textures with height 1 and 1d textures, so make sure
          * we pick 1d if any cbuf or zsbuf is 1d.
          */
         if (llvmpipe_resource_is_1d(lp->framebuffer.cbufs[i]->texture)) {
            key->resource_1d = TRUE;
         }

         format_desc = util_format_description(format);
         assert(format_desc->colorspace == UTIL_FORMAT_COLORSPACE_RGB ||
                format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB);

         /*
          * Mask out color channels not present in the color buffer.
          */
         blend_rt->colormask &= util_format_colormask(format_desc);

         /*
          * Disable blend for integer formats.
          */
         if (util_format_is_pure_integer(format)) {
            blend_rt->blend_enable = 0;
         }

         /*
          * Our swizzled render tiles always have an alpha channel, but the
          * linear render target format often does not, so force here the dst
          * alpha to be one.
          *
          * This is not a mere optimization. Wrong results will be produced if
          * the dst alpha is used, the dst format does not have alpha, and the
          * previous rendering was not flushed from the swizzled to linear
          * buffer. For example, NonPowTwo DCT.
          *
          * TODO: This should be generalized to all channels for better
          * performance, but only alpha causes correctness issues.
          *
          * Also, force rgb/alpha func/factors match, to make AoS blending
          * easier.
          */
         if (format_desc->swizzle[3] > UTIL_FORMAT_SWIZZLE_W ||
             format_desc->swizzle[3] == format_desc->swizzle[0]) {
            /* Doesn't cover mixed snorm/unorm but can't render to them anyway */
            boolean clamped_zero = !util_format_is_float(format) &&
                                   !util_format_is_snorm(format);
            blend_rt->rgb_src_factor =
               force_dst_alpha_one(blend_rt->rgb_src_factor, clamped_zero);
            blend_rt->rgb_dst_factor =
               force_dst_alpha_one(blend_rt->rgb_dst_factor, clamped_zero);
            blend_rt->alpha_func       = blend_rt->rgb_func;
            blend_rt->alpha_src_factor = blend_rt->rgb_src_factor;
            blend_rt->alpha_dst_factor = blend_rt->rgb_dst_factor;
         }
      }
      else {
         /* no color buffer for this fragment output */
         key->cbuf_format[i] = PIPE_FORMAT_NONE;
         blend_rt->colormask = 0x0;
         blend_rt->blend_enable = 0;
      }
   }

   /* This value will be the same for all the variants of a given shader:
    */
   key->nr_samplers = shader->info.base.file_max[TGSI_FILE_SAMPLER] + 1;

   for(i = 0; i < key->nr_samplers; ++i) {
      if(shader->info.base.file_mask[TGSI_FILE_SAMPLER] & (1 << i)) {
         lp_sampler_static_sampler_state(&key->state[i].sampler_state,
                                         lp->samplers[PIPE_SHADER_FRAGMENT][i]);
      }
   }

   /*
    * XXX If TGSI_FILE_SAMPLER_VIEW exists assume all texture opcodes
    * are dx10-style? Can't really have mixed opcodes, at least not
    * if we want to skip the holes here (without rescanning tgsi).
    */
   if (shader->info.base.file_max[TGSI_FILE_SAMPLER_VIEW] != -1) {
      key->nr_sampler_views = shader->info.base.file_max[TGSI_FILE_SAMPLER_VIEW] + 1;
      for(i = 0; i < key->nr_sampler_views; ++i) {
         if(shader->info.base.file_mask[TGSI_FILE_SAMPLER_VIEW] & (1 << i)) {
            lp_sampler_static_texture_state(&key->state[i].texture_state,
                                            lp->sampler_views[PIPE_SHADER_FRAGMENT][i]);
         }
      }
   }
   else {
      key->nr_sampler_views = key->nr_samplers;
      for(i = 0; i < key->nr_sampler_views; ++i) {
         if(shader->info.base.file_mask[TGSI_FILE_SAMPLER] & (1 << i)) {
            lp_sampler_static_texture_state(&key->state[i].texture_state,
                                            lp->sampler_views[PIPE_SHADER_FRAGMENT][i]);
         }
      }
   }
}



/**
 * Update fragment shader state.  This is called just prior to drawing
 * something when some fragment-related state has changed.
 */
void 
llvmpipe_update_fs(struct llvmpipe_context *lp)
{
   struct lp_fragment_shader *shader = lp->fs;
   struct lp_fragment_shader_variant_key key;
   struct lp_fragment_shader_variant *variant = NULL;
   struct lp_fs_variant_list_item *li;

   make_variant_key(lp, shader, &key);

   /* Search the variants for one which matches the key */
   li = first_elem(&shader->variants);
   while(!at_end(&shader->variants, li)) {
      if(memcmp(&li->base->key, &key, shader->variant_key_size) == 0) {
         variant = li->base;
         break;
      }
      li = next_elem(li);
   }

   if (variant) {
      /* Move this variant to the head of the list to implement LRU
       * deletion of shader's when we have too many.
       */
      move_to_head(&lp->fs_variants_list, &variant->list_item_global);
   }
   else {
      /* variant not found, create it now */
      int64_t t0, t1, dt;
      unsigned i;
      unsigned variants_to_cull;

      if (0) {
         debug_printf("%u variants,\t%u instrs,\t%u instrs/variant\n",
                      lp->nr_fs_variants,
                      lp->nr_fs_instrs,
                      lp->nr_fs_variants ? lp->nr_fs_instrs / lp->nr_fs_variants : 0);
      }

      /* First, check if we've exceeded the max number of shader variants.
       * If so, free 25% of them (the least recently used ones).
       */
      variants_to_cull = lp->nr_fs_variants >= LP_MAX_SHADER_VARIANTS ? LP_MAX_SHADER_VARIANTS / 4 : 0;

      if (variants_to_cull ||
          lp->nr_fs_instrs >= LP_MAX_SHADER_INSTRUCTIONS) {
         struct pipe_context *pipe = &lp->pipe;

         /*
          * XXX: we need to flush the context until we have some sort of
          * reference counting in fragment shaders as they may still be binned
          * Flushing alone might not be sufficient we need to wait on it too.
          */
         llvmpipe_finish(pipe, __FUNCTION__);

         /*
          * We need to re-check lp->nr_fs_variants because an arbitrarliy large
          * number of shader variants (potentially all of them) could be
          * pending for destruction on flush.
          */

         for (i = 0; i < variants_to_cull || lp->nr_fs_instrs >= LP_MAX_SHADER_INSTRUCTIONS; i++) {
            struct lp_fs_variant_list_item *item;
            if (is_empty_list(&lp->fs_variants_list)) {
               break;
            }
            item = last_elem(&lp->fs_variants_list);
            assert(item);
            assert(item->base);
            llvmpipe_remove_shader_variant(lp, item->base);
         }
      }

      /*
       * Generate the new variant.
       */
      t0 = os_time_get();
      variant = generate_variant(lp, shader, &key);
      t1 = os_time_get();
      dt = t1 - t0;
      LP_COUNT_ADD(llvm_compile_time, dt);
      LP_COUNT_ADD(nr_llvm_compiles, 2);  /* emit vs. omit in/out test */

      llvmpipe_variant_count++;

      /* Put the new variant into the list */
      if (variant) {
         insert_at_head(&shader->variants, &variant->list_item_local);
         insert_at_head(&lp->fs_variants_list, &variant->list_item_global);
         lp->nr_fs_variants++;
         lp->nr_fs_instrs += variant->nr_instrs;
         shader->variants_cached++;
      }
   }

   /* Bind this variant */
   lp_setup_set_fs_variant(lp->setup, variant);
}





void
llvmpipe_init_fs_funcs(struct llvmpipe_context *llvmpipe)
{
   llvmpipe->pipe.create_fs_state = llvmpipe_create_fs_state;
   llvmpipe->pipe.bind_fs_state   = llvmpipe_bind_fs_state;
   llvmpipe->pipe.delete_fs_state = llvmpipe_delete_fs_state;

   llvmpipe->pipe.set_constant_buffer = llvmpipe_set_constant_buffer;
}

/*
 * Rasterization is disabled if there is no pixel shader and
 * both depth and stencil testing are disabled:
 * http://msdn.microsoft.com/en-us/library/windows/desktop/bb205125
 */
boolean
llvmpipe_rasterization_disabled(struct llvmpipe_context *lp)
{
   boolean null_fs = !lp->fs || lp->fs->info.base.num_tokens <= 1;

   return (null_fs &&
           !lp->depth_stencil->depth.enabled &&
           !lp->depth_stencil->stencil[0].enabled);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1669 7
d1677 1
d2163 1
a2163 1
   char func_name[64];
d2215 8
a2222 2
   cbuf0_write_all =
     shader->info.base.properties[TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS];
d2250 2
a2251 2
   util_snprintf(func_name, sizeof(func_name), "fs%u_variant%u_%s",
                 shader->no, variant->no, partial_mask ? "partial" : "whole");
a2331 2
      boolean pixel_center_integer =
         shader->info.base.properties[TGSI_PROPERTY_FS_COORD_PIXEL_CENTER];
d2342 1
a2342 1
                               pixel_center_integer,
d2441 2
a2560 1
   char module_name[64];
d2566 1
a2566 4
   util_snprintf(module_name, sizeof(module_name), "fs%u_variant%u",
                 shader->no, shader->variants_created);

   variant->gallivm = gallivm_create(module_name, lp->context);
a2627 2
   variant->nr_instrs += lp_build_count_ir_module(variant->gallivm->module);

a2641 2
   gallivm_free_ir(variant->gallivm);

d2766 2
d2778 9
d3176 2
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a1668 7
#if HAVE_LLVM < 0x0302
   /*
    * undef triggers a crash in LLVMBuildTrunc in convert_from_blend_type in some
    * cases (seen with r10g10b10a2, 128bit wide vectors) (only used for 1d case).
    */
   undef_src_val = lp_build_zero(gallivm, fs_type);
#else
a1669 1
#endif
d2155 1
a2155 1
   char func_name[256];
d2207 2
a2208 8
   cbuf0_write_all = FALSE;
   for (i = 0;i < shader->info.base.num_properties; i++) {
      if (shader->info.base.properties[i].name ==
          TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS) {
         cbuf0_write_all = TRUE;
         break;
      }
   }
d2236 2
a2237 2
   util_snprintf(func_name, sizeof(func_name), "fs%u_variant%u_%s", 
		 shader->no, variant->no, partial_mask ? "partial" : "whole");
d2318 2
d2330 1
a2330 1
                               shader->info.base.pixel_center_integer,
a2428 2

   variant->nr_instrs += lp_build_count_instructions(function);
d2547 1
d2553 4
a2556 1
   variant->gallivm = gallivm_create();
d2618 2
d2634 2
a2759 2
   unsigned i;

a2769 9
   /* free all the variant's JIT'd functions */
   for (i = 0; i < Elements(variant->function); i++) {
      if (variant->function[i]) {
         gallivm_free_function(variant->gallivm,
                               variant->function[i],
                               variant->jit_function[i]);
      }
   }

a3158 2

      llvmpipe_variant_count++;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d4 1
a4 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d22 1
a22 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d218 24
d265 1
a265 1
   LLVMValueRef consts_ptr;
d299 3
a301 1
         if (key->alpha.enabled || shader->info.base.uses_kill) {
d339 1
d418 1
a418 1
                     consts_ptr, &system_values,
d444 15
d467 45
d871 1
a871 1
      /* just make this a 32bit uint */
d876 1
a876 1
      type->width = 32;
d966 16
a981 1
 * Scale a normalized value from src_bits to dst_bits
d994 62
a1055 5
      /* Scale down by LShr */
      result = LLVMBuildLShr(builder,
                             src,
                             lp_build_const_int_vec(gallivm, src_type, src_bits - dst_bits),
                             "");
d1092 13
d1140 1
a1140 1
      assert(src_type.width == 32);
d1146 12
d1313 1
a1313 1
      assert(dst_type.width == 32);
d1348 19
d1624 22
a1678 5

   /* Get type from output format */
   lp_blend_type_from_format_desc(out_format_desc, &row_type);
   lp_mem_type_from_format_desc(out_format_desc, &dst_type);

d1911 1
a1911 1
         src[i] = lp_build_clamp(&f32_bld, src[i], f32_bld.zero, f32_bld.one);
d1915 1
a1915 1
            src1[i] = lp_build_clamp(&f32_bld, src1[i], f32_bld.zero, f32_bld.one);
d2138 4
d2409 16
a2424 8
      LLVMValueRef color_ptr;
      LLVMValueRef stride;
      LLVMValueRef index = lp_build_const_int32(gallivm, cbuf);

      boolean do_branch = ((key->depth.enabled
                            || key->stencil[0].enabled
                            || key->alpha.enabled)
                           && !shader->info.base.uses_kill);
d2426 2
a2427 2
      color_ptr = LLVMBuildLoad(builder,
                                LLVMBuildGEP(builder, color_ptr_ptr, &index, 1, ""),
d2430 6
a2435 9
      lp_build_name(color_ptr, "color_ptr%d", cbuf);

      stride = LLVMBuildLoad(builder,
                             LLVMBuildGEP(builder, stride_ptr, &index, 1, ""),
                             "");

      generate_unswizzled_blend(gallivm, cbuf, variant, key->cbuf_format[cbuf],
                                num_fs, fs_type, fs_mask, fs_out_color,
                                context_ptr, color_ptr, stride, partial_mask, do_branch);
d2496 3
d2594 1
d2597 8
a2604 1
         ? TRUE : FALSE;
d2939 12
d2953 1
a2980 1
      enum pipe_format format = lp->framebuffer.cbufs[i]->format;
a2981 1
      const struct util_format_description *format_desc;
d2983 5
a2987 1
      key->cbuf_format[i] = format;
d2989 12
a3000 8
      /*
       * Figure out if this is a 1d resource. Note that OpenGL allows crazy
       * mixing of 2d textures with height 1 and 1d textures, so make sure
       * we pick 1d if any cbuf or zsbuf is 1d.
       */
      if (llvmpipe_resource_is_1d(lp->framebuffer.cbufs[0]->texture)) {
         key->resource_1d = TRUE;
      }
d3002 4
a3005 3
      format_desc = util_format_description(format);
      assert(format_desc->colorspace == UTIL_FORMAT_COLORSPACE_RGB ||
             format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB);
d3007 6
a3012 4
      /*
       * Mask out color channels not present in the color buffer.
       */
      blend_rt->colormask &= util_format_colormask(format_desc);
d3014 34
a3047 4
      /*
       * Disable blend for integer formats.
       */
      if (util_format_is_pure_integer(format)) {
a3049 29

      /*
       * Our swizzled render tiles always have an alpha channel, but the linear
       * render target format often does not, so force here the dst alpha to be
       * one.
       *
       * This is not a mere optimization. Wrong results will be produced if the
       * dst alpha is used, the dst format does not have alpha, and the previous
       * rendering was not flushed from the swizzled to linear buffer. For
       * example, NonPowTwo DCT.
       *
       * TODO: This should be generalized to all channels for better
       * performance, but only alpha causes correctness issues.
       *
       * Also, force rgb/alpha func/factors match, to make AoS blending easier.
       */
      if (format_desc->swizzle[3] > UTIL_FORMAT_SWIZZLE_W ||
          format_desc->swizzle[3] == format_desc->swizzle[0]) {
         /* Doesn't cover mixed snorm/unorm but can't render to them anyway */
         boolean clamped_zero = !util_format_is_float(format) &&
                                !util_format_is_snorm(format);
         blend_rt->rgb_src_factor   = force_dst_alpha_one(blend_rt->rgb_src_factor,
                                                          clamped_zero);
         blend_rt->rgb_dst_factor   = force_dst_alpha_one(blend_rt->rgb_dst_factor,
                                                          clamped_zero);
         blend_rt->alpha_func       = blend_rt->rgb_func;
         blend_rt->alpha_src_factor = blend_rt->rgb_src_factor;
         blend_rt->alpha_dst_factor = blend_rt->rgb_dst_factor;
      }
d3205 15
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d69 1
d86 4
d103 1
a103 4


#include <llvm-c/Analysis.h>
#include <llvm-c/BitWriter.h>
d111 2
a112 2
 * Expand the relevent bits of mask_input to a 4-dword mask for the 
 * four pixels in a 2x2 quad.  This will set the four elements of the
d114 2
d117 1
a117 1
 * \param quad  which quad of the quad group to test, in [0,3]
d123 1
a123 1
                   unsigned quad,
d129 1
a129 1
   LLVMValueRef bits[4];
d131 1
a131 1
   int shift;
d137 1
a137 1
   assert(fs_type.length == 4);
d143 1
a143 1
   switch (quad) {
d148 1
d155 1
d175 8
a182 6
   bits[0] = LLVMConstInt(i32t, 1 << 0, 0);
   bits[1] = LLVMConstInt(i32t, 1 << 1, 0);
   bits[2] = LLVMConstInt(i32t, 1 << 4, 0);
   bits[3] = LLVMConstInt(i32t, 1 << 5, 0);
   
   mask = LLVMBuildAnd(builder, mask, LLVMConstVector(bits, 4), "");
a218 2
 * \param i  which quad in the tile, in range [0,3]
 * \param partial_mask  if 1, do mask_input testing
d221 15
a235 16
generate_fs(struct gallivm_state *gallivm,
            struct lp_fragment_shader *shader,
            const struct lp_fragment_shader_variant_key *key,
            LLVMBuilderRef builder,
            struct lp_type type,
            LLVMValueRef context_ptr,
            unsigned i,
            struct lp_build_interp_soa_context *interp,
            struct lp_build_sampler_soa *sampler,
            LLVMValueRef *pmask,
            LLVMValueRef (*color)[4],
            LLVMValueRef depth_ptr,
            LLVMValueRef facing,
            unsigned partial_mask,
            LLVMValueRef mask_input,
            LLVMValueRef counter)
d240 1
a241 1
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][NUM_CHANNELS];
d243 2
a244 1
   LLVMValueRef zs_value = NULL;
d246 2
d249 5
d256 3
a258 1
                            shader->info.base.num_instructions < 8);
d264 4
d269 1
a269 2
       key->stencil[0].enabled ||
       key->stencil[1].enabled) {
d275 1
a275 1
         if (key->alpha.enabled || shader->info.base.uses_kill)
d279 2
a280 1
             * is known.
d282 7
a288 1
            depth_mode = EARLY_DEPTH_TEST | LATE_DEPTH_WRITE;
d297 3
a299 1
          !(key->stencil[0].enabled && key->stencil[0].writemask))
d303 1352
a1654 2
      depth_mode = 0;
   }
d1656 2
a1657 1
   assert(i < 4);
d1659 3
a1661 2
   stencil_refs[0] = lp_jit_context_stencil_ref_front_value(gallivm, context_ptr);
   stencil_refs[1] = lp_jit_context_stencil_ref_back_value(gallivm, context_ptr);
a1662 1
   vec_type = lp_build_vec_type(gallivm, type);
d1664 6
a1669 1
   consts_ptr = lp_jit_context_constants(gallivm, context_ptr);
d1671 2
a1672 1
   memset(outputs, 0, sizeof outputs);
d1674 23
a1696 4
   /* Declare the color and z variables */
   for(cbuf = 0; cbuf < key->nr_cbufs; cbuf++) {
      for(chan = 0; chan < NUM_CHANNELS; ++chan) {
	 color[cbuf][chan] = lp_build_alloca(gallivm, vec_type, "color");
d1698 3
d1703 11
a1713 7
   /* do triangle edge testing */
   if (partial_mask) {
      *pmask = generate_quad_mask(gallivm, type,
                                  i, mask_input);
   }
   else {
      *pmask = lp_build_const_int_vec(gallivm, type, ~0);
d1716 4
a1719 8
   /* 'mask' will control execution based on quad's pixel alive/killed state */
   lp_build_mask_begin(&mask, gallivm, type, *pmask);

   if (!(depth_mode & EARLY_DEPTH_TEST) && !simple_shader)
      lp_build_mask_check(&mask);

   lp_build_interp_soa_update_pos(interp, gallivm, i);
   z = interp->pos[2];
d1721 6
a1726 12
   if (depth_mode & EARLY_DEPTH_TEST) {
      lp_build_depth_stencil_test(gallivm,
                                  &key->depth,
                                  key->stencil,
                                  type,
                                  zs_format_desc,
                                  &mask,
                                  stencil_refs,
                                  z,
                                  depth_ptr, facing,
                                  &zs_value,
                                  !simple_shader);
d1728 2
a1729 2
      if (depth_mode & EARLY_DEPTH_WRITE) {
         lp_build_depth_write(builder, zs_format_desc, depth_ptr, zs_value);
d1733 1
a1733 7
   lp_build_interp_soa_update_inputs(interp, gallivm, i);
   
   /* Build the actual shader */
   lp_build_tgsi_soa(gallivm, tokens, type, &mask,
                     consts_ptr, NULL, /* sys values array */
                     interp->pos, interp->inputs,
                     outputs, sampler, &shader->info.base);
d1735 3
a1737 5
   /* Alpha test */
   if (key->alpha.enabled) {
      int color0 = find_output_by_semantic(&shader->info.base,
                                           TGSI_SEMANTIC_COLOR,
                                           0);
d1739 6
a1744 3
      if (color0 != -1 && outputs[color0][3]) {
         LLVMValueRef alpha = LLVMBuildLoad(builder, outputs[color0][3], "alpha");
         LLVMValueRef alpha_ref_value;
d1746 1
a1746 2
         alpha_ref_value = lp_jit_context_alpha_ref_value(gallivm, context_ptr);
         alpha_ref_value = lp_build_broadcast(gallivm, vec_type, alpha_ref_value);
d1748 2
a1749 3
         lp_build_alpha_test(gallivm, key->alpha.func, type,
                             &mask, alpha, alpha_ref_value,
                             (depth_mode & LATE_DEPTH_TEST) != 0);
d1751 3
d1756 15
a1770 24
   /* Late Z test */
   if (depth_mode & LATE_DEPTH_TEST) { 
      int pos0 = find_output_by_semantic(&shader->info.base,
                                         TGSI_SEMANTIC_POSITION,
                                         0);
         
      if (pos0 != -1 && outputs[pos0][2]) {
         z = LLVMBuildLoad(builder, outputs[pos0][2], "output.z");
      }

      lp_build_depth_stencil_test(gallivm,
                                  &key->depth,
                                  key->stencil,
                                  type,
                                  zs_format_desc,
                                  &mask,
                                  stencil_refs,
                                  z,
                                  depth_ptr, facing,
                                  &zs_value,
                                  !simple_shader);
      /* Late Z write */
      if (depth_mode & LATE_DEPTH_WRITE) {
         lp_build_depth_write(builder, zs_format_desc, depth_ptr, zs_value);
a1772 14
   else if ((depth_mode & EARLY_DEPTH_TEST) &&
            (depth_mode & LATE_DEPTH_WRITE))
   {
      /* Need to apply a reduced mask to the depth write.  Reload the
       * depth value, update from zs_value with the new mask value and
       * write that out.
       */
      lp_build_deferred_depth_write(gallivm,
                                    type,
                                    zs_format_desc,
                                    &mask,
                                    depth_ptr,
                                    zs_value);
   }
d1775 7
a1781 18
   /* Color write  */
   for (attrib = 0; attrib < shader->info.base.num_outputs; ++attrib)
   {
      if (shader->info.base.output_semantic_name[attrib] == TGSI_SEMANTIC_COLOR &&
          shader->info.base.output_semantic_index[attrib] < key->nr_cbufs)
      {
         unsigned cbuf = shader->info.base.output_semantic_index[attrib];
         for(chan = 0; chan < NUM_CHANNELS; ++chan) {
            if(outputs[attrib][chan]) {
               /* XXX: just initialize outputs to point at colors[] and
                * skip this.
                */
               LLVMValueRef out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
               lp_build_name(out, "color%u.%u.%c", i, attrib, "rgba"[chan]);
               LLVMBuildStore(builder, out, color[cbuf][chan]);
            }
         }
      }
d1784 1
a1784 3
   if (counter)
      lp_build_occlusion_count(gallivm, type,
                               lp_build_mask_value(&mask), counter);
d1786 9
a1794 2
   *pmask = lp_build_mask_end(&mask);
}
d1796 20
d1817 6
a1822 29
/**
 * Generate color blending and color output.
 * \param rt  the render target index (to index blend, colormask state)
 * \param type  the pixel color type
 * \param context_ptr  pointer to the runtime JIT context
 * \param mask  execution mask (active fragment/pixel mask)
 * \param src  colors from the fragment shader
 * \param dst_ptr  the destination color buffer pointer
 */
static void
generate_blend(struct gallivm_state *gallivm,
               const struct pipe_blend_state *blend,
               unsigned rt,
               LLVMBuilderRef builder,
               struct lp_type type,
               LLVMValueRef context_ptr,
               LLVMValueRef mask,
               LLVMValueRef *src,
               LLVMValueRef dst_ptr,
               boolean do_branch)
{
   struct lp_build_context bld;
   struct lp_build_mask_context mask_ctx;
   LLVMTypeRef vec_type;
   LLVMValueRef const_ptr;
   LLVMValueRef con[4];
   LLVMValueRef dst[4];
   LLVMValueRef res[4];
   unsigned chan;
d1824 5
a1828 1
   lp_build_context_init(&bld, gallivm, type);
a1829 3
   lp_build_mask_begin(&mask_ctx, gallivm, type, mask);
   if (do_branch)
      lp_build_mask_check(&mask_ctx);
d1831 13
a1843 1
   vec_type = lp_build_vec_type(gallivm, type);
d1845 13
a1857 3
   const_ptr = lp_jit_context_blend_color(gallivm, context_ptr);
   const_ptr = LLVMBuildBitCast(builder, const_ptr,
                                LLVMPointerType(vec_type, 0), "");
d1859 42
a1900 4
   /* load constant blend color and colors from the dest color buffer */
   for(chan = 0; chan < 4; ++chan) {
      LLVMValueRef index = lp_build_const_int32(gallivm, chan);
      con[chan] = LLVMBuildLoad(builder, LLVMBuildGEP(builder, const_ptr, &index, 1, ""), "");
d1902 3
a1904 1
      dst[chan] = LLVMBuildLoad(builder, LLVMBuildGEP(builder, dst_ptr, &index, 1, ""), "");
d1906 10
a1915 2
      lp_build_name(con[chan], "con.%c", "rgba"[chan]);
      lp_build_name(dst[chan], "dst.%c", "rgba"[chan]);
d1918 2
a1919 11
   /* do blend */
   lp_build_blend_soa(gallivm, blend, type, rt, src, dst, con, res);

   /* store results to color buffer */
   for(chan = 0; chan < 4; ++chan) {
      if(blend->rt[rt].colormask & (1 << chan)) {
         LLVMValueRef index = lp_build_const_int32(gallivm, chan);
         lp_build_name(res[chan], "res.%c", "rgba"[chan]);
         res[chan] = lp_build_select(&bld, mask, res[chan], dst[chan]);
         LLVMBuildStore(builder, res[chan], LLVMBuildGEP(builder, dst_ptr, &index, 1, ""));
      }
a1920 2

   lp_build_mask_end(&mask_ctx);
d1936 1
a1936 1
   struct gallivm_state *gallivm = lp->gallivm;
a1942 1
   LLVMTypeRef fs_int_vec_type;
d1944 1
a1944 1
   LLVMTypeRef arg_types[11];
d1955 1
d1957 1
d1959 1
a1959 1
   LLVMValueRef counter = NULL;
d1964 2
a1965 3
   LLVMValueRef fs_mask[LP_MAX_VECTOR_LENGTH];
   LLVMValueRef fs_out_color[PIPE_MAX_COLOR_BUFS][NUM_CHANNELS][LP_MAX_VECTOR_LENGTH];
   LLVMValueRef blend_mask;
a1967 1
   const struct util_format_description *zs_format_desc;
d1973 4
d1986 1
a1986 1
	    inputs[i].interp = LP_INTERP_LINEAR;
d2004 5
a2008 6
   fs_type.floating = TRUE; /* floating point values */
   fs_type.sign = TRUE;     /* values are signed */
   fs_type.norm = FALSE;    /* values are not limited to [0,1] or [-1,1] */
   fs_type.width = 32;      /* 32-bit float */
   fs_type.length = 4;      /* 4 elements per vector */
   num_fs = 4;              /* number of quads per block */
a2022 1
   fs_int_vec_type = lp_build_int_vec_type(gallivm, fs_type);
d2029 1
a2029 1
   arg_types[0] = lp_jit_get_context_type(lp);         /* context */
d2039 3
a2041 1
   arg_types[10] = LLVMPointerType(int32_type, 0);     /* counter */
d2068 3
d2080 1
d2082 2
a2083 5

   if (key->occlusion_count) {
      counter = LLVMGetParam(function, 10);
      lp_build_name(counter, "counter");
   }
d2094 7
a2100 12
   /*
    * The shader input interpolation info is not explicitely baked in the
    * shader key, but everything it derives from (TGSI, and flatshade) is
    * already included in the shader key.
    */
   lp_build_interp_soa_init(&interp, 
                            gallivm,
                            shader->info.base.num_inputs,
                            inputs,
                            builder, fs_type,
                            a0_ptr, dadx_ptr, dady_ptr,
                            x, y);
d2102 6
a2107 2
   /* code generated texture sampling */
   sampler = lp_llvm_sampler_soa_create(key->sampler, context_ptr);
d2109 29
a2137 2
   /* loop over quads in the block */
   zs_format_desc = util_format_description(key->zsbuf_format);
d2139 39
a2177 29
   for(i = 0; i < num_fs; ++i) {
      LLVMValueRef depth_offset = LLVMConstInt(int32_type,
                                               i*fs_type.length*zs_format_desc->block.bits/8,
                                               0);
      LLVMValueRef out_color[PIPE_MAX_COLOR_BUFS][NUM_CHANNELS];
      LLVMValueRef depth_ptr_i;

      depth_ptr_i = LLVMBuildGEP(builder, depth_ptr, &depth_offset, 1, "");

      generate_fs(gallivm,
                  shader, key,
                  builder,
                  fs_type,
                  context_ptr,
                  i,
                  &interp,
                  sampler,
                  &fs_mask[i], /* output */
                  out_color,
                  depth_ptr_i,
                  facing,
                  partial_mask,
                  mask_input,
                  counter);

      for (cbuf = 0; cbuf < key->nr_cbufs; cbuf++)
         for (chan = 0; chan < NUM_CHANNELS; ++chan)
            fs_out_color[cbuf][chan][i] =
               out_color[cbuf * !cbuf0_write_all][chan];
d2186 1
a2187 2
      LLVMValueRef blend_in_color[NUM_CHANNELS];
      unsigned rt;
d2189 8
a2196 26
      /* 
       * Convert the fs's output color and mask to fit to the blending type. 
       */
      for(chan = 0; chan < NUM_CHANNELS; ++chan) {
         LLVMValueRef fs_color_vals[LP_MAX_VECTOR_LENGTH];
         
         for (i = 0; i < num_fs; i++) {
            fs_color_vals[i] =
               LLVMBuildLoad(builder, fs_out_color[cbuf][chan][i], "fs_color_vals");
         }

	 lp_build_conv(gallivm, fs_type, blend_type,
                       fs_color_vals,
                       num_fs,
		       &blend_in_color[chan], 1);

	 lp_build_name(blend_in_color[chan], "color%d.%c", cbuf, "rgba"[chan]);
      }

      if (partial_mask || !variant->opaque) {
         lp_build_conv_mask(lp->gallivm, fs_type, blend_type,
                            fs_mask, num_fs,
                            &blend_mask, 1);
      } else {
         blend_mask = lp_build_const_int_vec(lp->gallivm, blend_type, ~0);
      }
a2197 3
      color_ptr = LLVMBuildLoad(builder, 
				LLVMBuildGEP(builder, color_ptr_ptr, &index, 1, ""),
				"");
d2200 7
a2206 24
      /* which blend/colormask state to use */
      rt = key->blend.independent_blend_enable ? cbuf : 0;

      /*
       * Blending.
       */
      {
         /* Could the 4x4 have been killed?
          */
         boolean do_branch = ((key->depth.enabled || key->stencil[0].enabled) &&
                              !key->alpha.enabled &&
                              !shader->info.base.uses_kill);

         generate_blend(lp->gallivm,
                        &key->blend,
                        rt,
                        builder,
                        blend_type,
                        context_ptr,
                        blend_mask,
                        blend_in_color,
                        color_ptr,
                        do_branch);
      }
d2211 1
a2211 30
   /* Verify the LLVM IR.  If invalid, dump and abort */
#ifdef DEBUG
   if(LLVMVerifyFunction(function, LLVMPrintMessageAction)) {
      if (1)
         lp_debug_dump_value(function);
      abort();
   }
#endif

   /* Apply optimizations to LLVM IR */
   LLVMRunFunctionPassManager(gallivm->passmgr, function);

   if ((gallivm_debug & GALLIVM_DEBUG_IR) || (LP_DEBUG & DEBUG_FS)) {
      /* Print the LLVM IR to stderr */
      lp_debug_dump_value(function);
      debug_printf("\n");
   }

   /* Dump byte code to a file */
   if (0) {
      LLVMWriteBitcodeToFile(gallivm->module, "llvmpipe.bc");
   }

   /*
    * Translate the LLVM IR into machine code.
    */
   {
      void *f = LLVMGetPointerToGlobal(gallivm->engine, function);

      variant->jit_function[partial_mask] = (lp_jit_frag_func)pointer_to_func(f);
d2213 1
a2213 5
      if ((gallivm_debug & GALLIVM_DEBUG_ASM) || (LP_DEBUG & DEBUG_FS)) {
         lp_disassemble(f);
      }
      lp_func_delete_body(function);
   }
d2268 1
a2269 8
      debug_printf("  .format = %s\n",
                   util_format_name(key->sampler[i].format));
      debug_printf("  .target = %s\n",
                   util_dump_tex_target(key->sampler[i].target, TRUE));
      debug_printf("  .pot = %u %u %u\n",
                   key->sampler[i].pot_width,
                   key->sampler[i].pot_height,
                   key->sampler[i].pot_depth);
d2271 3
a2273 3
                   util_dump_tex_wrap(key->sampler[i].wrap_s, TRUE),
                   util_dump_tex_wrap(key->sampler[i].wrap_t, TRUE),
                   util_dump_tex_wrap(key->sampler[i].wrap_r, TRUE));
d2275 1
a2275 1
                   util_dump_tex_filter(key->sampler[i].min_img_filter, TRUE));
d2277 1
a2277 1
                   util_dump_tex_mipfilter(key->sampler[i].min_mip_filter, TRUE));
d2279 22
a2300 8
                   util_dump_tex_filter(key->sampler[i].mag_img_filter, TRUE));
      if (key->sampler[i].compare_mode != PIPE_TEX_COMPARE_NONE)
         debug_printf("  .compare_func = %s\n", util_dump_func(key->sampler[i].compare_func, TRUE));
      debug_printf("  .normalized_coords = %u\n", key->sampler[i].normalized_coords);
      debug_printf("  .min_max_lod_equal = %u\n", key->sampler[i].min_max_lod_equal);
      debug_printf("  .lod_bias_non_zero = %u\n", key->sampler[i].lod_bias_non_zero);
      debug_printf("  .apply_min_lod = %u\n", key->sampler[i].apply_min_lod);
      debug_printf("  .apply_max_lod = %u\n", key->sampler[i].apply_max_lod);
d2327 1
d2334 6
d2352 2
a2353 6
      const struct util_format_description *format_desc;
      format_desc = util_format_description(key->cbuf_format[0]);
      if ((~key->blend.rt[0].colormask &
           util_format_colormask(format_desc)) == 0) {
         fullcolormask = TRUE;
      }
a2365 1

d2370 23
a2392 1
   generate_fragment(lp, shader, variant, RAST_EDGE_TEST);
d2394 5
a2398 4
   if (variant->opaque) {
      /* Specialized shader, which doesn't need to read the color buffer. */
      generate_fragment(lp, shader, variant, RAST_WHOLE);
   } else {
d2413 1
d2437 1
d2440 1
a2440 1
				     sampler[nr_samplers]);
d2444 1
d2456 3
a2464 7
      case TGSI_SEMANTIC_COLOR:
         /* Colors may be either linearly or constant interpolated in
	  * the fragment shader, but that information isn't available
	  * here.  Mark color inputs and fix them up later.
          */
	 shader->inputs[i].interp = LP_INTERP_COLOR;
         break;
a2508 2
   draw_flush(llvmpipe->draw);

d2541 3
a2543 4
         if (variant->jit_function[i])
            LLVMFreeMachineCodeForFunction(lp->gallivm->engine,
                                           variant->function[i]);
         LLVMDeleteFunction(variant->function[i]);
d2547 2
d2556 1
d2599 1
a2599 1
                             struct pipe_resource *constants)
d2602 1
a2602 2
   unsigned size = constants ? constants->width0 : 0;
   const void *data = constants ? llvmpipe_resource_data(constants) : NULL;
d2605 4
a2608 1
   assert(index < PIPE_MAX_CONSTANT_BUFFERS);
d2610 5
a2614 2
   if(llvmpipe->constants[shader][index] == constants)
      return;
d2616 9
a2624 1
   draw_flush(llvmpipe->draw);
d2626 2
a2627 2
   /* note: reference counting */
   pipe_resource_reference(&llvmpipe->constants[shader][index], constants);
a2628 2
   if(shader == PIPE_SHADER_VERTEX ||
      shader == PIPE_SHADER_GEOMETRY) {
d2634 4
d2645 1
a2645 1
force_dst_alpha_one(unsigned factor)
d2653 4
a2656 1
      return PIPE_BLENDFACTOR_ZERO;
d2680 7
a2686 2
      if (lp->depth_stencil->depth.enabled) {
         key->zsbuf_format = lp->framebuffer.zsbuf->format;
d2689 3
a2691 2
      if (lp->depth_stencil->stencil[0].enabled) {
         key->zsbuf_format = lp->framebuffer.zsbuf->format;
d2694 3
d2699 5
a2703 1
   key->alpha.enabled = lp->depth_stencil->alpha.enabled;
d2709 1
a2709 1
   if (lp->active_query_count) {
d2718 9
d2734 9
a2746 2
      blend_rt->colormask = lp->blend->rt[i].colormask;

d2753 7
d2774 9
a2782 3
      if (format_desc->swizzle[3] > UTIL_FORMAT_SWIZZLE_W) {
         blend_rt->rgb_src_factor   = force_dst_alpha_one(blend_rt->rgb_src_factor);
         blend_rt->rgb_dst_factor   = force_dst_alpha_one(blend_rt->rgb_dst_factor);
d2795 26
a2820 3
         lp_sampler_static_state(&key->sampler[i],
				 lp->fragment_sampler_views[i],
				 lp->sampler[i]);
d2861 8
d2873 4
a2876 1
      if (lp->nr_fs_variants >= LP_MAX_SHADER_VARIANTS) {
d2886 7
a2892 1
         for (i = 0; i < LP_MAX_SHADER_VARIANTS / 4; i++) {
d2894 3
d2898 2
d2921 1
a2928 2


@


1.2
log
@Merge Mesa 7.10.3
@
text
@a92 1
#include "lp_screen.h"
d337 2
a338 1
                     consts_ptr, interp->pos, interp->inputs,
d549 1
d563 9
d710 4
a713 3
      for(cbuf = 0; cbuf < key->nr_cbufs; cbuf++)
	 for(chan = 0; chan < NUM_CHANNELS; ++chan)
	    fs_out_color[cbuf][chan][i] = out_color[cbuf][chan];
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a33 3
 * - triangle edge in/out testing
 * - scissor test
 * - stipple (TBI)
d37 1
a37 1
 * - depth/stencil test (stencil TBI)
d40 1
a40 1
 * This file has only the glue to assembly the fragment pipeline.  The actual
d64 1
d67 2
d78 1
a80 2
#include "gallivm/lp_bld_depth.h"
#include "gallivm/lp_bld_interp.h"
a81 2
#include "gallivm/lp_bld_alpha.h"
#include "gallivm/lp_bld_blend.h"
d85 5
a89 1
#include "lp_buffer.h"
d97 2
d101 2
a102 2
static const unsigned char quad_offset_x[4] = {0, 1, 0, 1};
static const unsigned char quad_offset_y[4] = {0, 0, 1, 1};
d105 2
a106 33
/*
 * Derive from the quad's upper left scalar coordinates the coordinates for
 * all other quad pixels
 */
static void
generate_pos0(LLVMBuilderRef builder,
              LLVMValueRef x,
              LLVMValueRef y,
              LLVMValueRef *x0,
              LLVMValueRef *y0)
{
   LLVMTypeRef int_elem_type = LLVMInt32Type();
   LLVMTypeRef int_vec_type = LLVMVectorType(int_elem_type, QUAD_SIZE);
   LLVMTypeRef elem_type = LLVMFloatType();
   LLVMTypeRef vec_type = LLVMVectorType(elem_type, QUAD_SIZE);
   LLVMValueRef x_offsets[QUAD_SIZE];
   LLVMValueRef y_offsets[QUAD_SIZE];
   unsigned i;

   x = lp_build_broadcast(builder, int_vec_type, x);
   y = lp_build_broadcast(builder, int_vec_type, y);

   for(i = 0; i < QUAD_SIZE; ++i) {
      x_offsets[i] = LLVMConstInt(int_elem_type, quad_offset_x[i], 0);
      y_offsets[i] = LLVMConstInt(int_elem_type, quad_offset_y[i], 0);
   }

   x = LLVMBuildAdd(builder, x, LLVMConstVector(x_offsets, QUAD_SIZE), "");
   y = LLVMBuildAdd(builder, y, LLVMConstVector(y_offsets, QUAD_SIZE), "");

   *x0 = LLVMBuildSIToFP(builder, x, vec_type, "");
   *y0 = LLVMBuildSIToFP(builder, y, vec_type, "");
}
d110 6
a115 1
 * Generate the depth test.
d117 5
a121 7
static void
generate_depth(LLVMBuilderRef builder,
               const struct lp_fragment_shader_variant_key *key,
               struct lp_type src_type,
               struct lp_build_mask_context *mask,
               LLVMValueRef src,
               LLVMValueRef dst_ptr)
d123 6
a128 2
   const struct util_format_description *format_desc;
   struct lp_type dst_type;
d130 6
a135 2
   if(!key->depth.enabled)
      return;
d137 25
a161 2
   format_desc = util_format_description(key->zsbuf_format);
   assert(format_desc);
d164 1
a164 3
    * Depths are expected to be between 0 and 1, even if they are stored in
    * floats. Setting these bits here will ensure that the lp_build_conv() call
    * below won't try to unnecessarily clamp the incoming values.
d166 8
a173 61
   if(src_type.floating) {
      src_type.sign = FALSE;
      src_type.norm = TRUE;
   }
   else {
      assert(!src_type.sign);
      assert(src_type.norm);
   }

   /* Pick the depth type. */
   dst_type = lp_depth_type(format_desc, src_type.width*src_type.length);

   /* FIXME: Cope with a depth test type with a different bit width. */
   assert(dst_type.width == src_type.width);
   assert(dst_type.length == src_type.length);

   lp_build_conv(builder, src_type, dst_type, &src, 1, &src, 1);

   dst_ptr = LLVMBuildBitCast(builder,
                              dst_ptr,
                              LLVMPointerType(lp_build_vec_type(dst_type), 0), "");

   lp_build_depth_test(builder,
                       &key->depth,
                       dst_type,
                       format_desc,
                       mask,
                       src,
                       dst_ptr);
}


/**
 * Generate the code to do inside/outside triangle testing for the
 * four pixels in a 2x2 quad.  This will set the four elements of the
 * quad mask vector to 0 or ~0.
 * \param i  which quad of the quad group to test, in [0,3]
 */
static void
generate_tri_edge_mask(LLVMBuilderRef builder,
                       unsigned i,
                       LLVMValueRef *mask,      /* ivec4, out */
                       LLVMValueRef c0,         /* int32 */
                       LLVMValueRef c1,         /* int32 */
                       LLVMValueRef c2,         /* int32 */
                       LLVMValueRef step0_ptr,  /* ivec4 */
                       LLVMValueRef step1_ptr,  /* ivec4 */
                       LLVMValueRef step2_ptr)  /* ivec4 */
{
#define OPTIMIZE_IN_OUT_TEST 0
#if OPTIMIZE_IN_OUT_TEST
   struct lp_build_if_state ifctx;
   LLVMValueRef not_draw_all;
#endif
   struct lp_build_flow_context *flow;
   struct lp_type i32_type;
   LLVMTypeRef i32vec4_type, mask_type;
   LLVMValueRef c0_vec, c1_vec, c2_vec;
   LLVMValueRef in_out_mask;

   assert(i < 4);
d175 1
a175 11
   /* int32 vector type */
   memset(&i32_type, 0, sizeof i32_type);
   i32_type.floating = FALSE; /* values are integers */
   i32_type.sign = TRUE;      /* values are signed */
   i32_type.norm = FALSE;     /* values are not normalized */
   i32_type.width = 32;       /* 32-bit int values */
   i32_type.length = 4;       /* 4 elements per vector */

   i32vec4_type = lp_build_int32_vec4_type();

   mask_type = LLVMIntType(32 * 4);
d178 1
a178 2
    * Use a conditional here to do detailed pixel in/out testing.
    * We only have to do this if c0 != INT_MIN.
d180 4
a183 62
   flow = lp_build_flow_create(builder);
   lp_build_flow_scope_begin(flow);

   {
#if OPTIMIZE_IN_OUT_TEST
      /* not_draw_all = (c0 != INT_MIN) */
      not_draw_all = LLVMBuildICmp(builder,
                                   LLVMIntNE,
                                   c0,
                                   LLVMConstInt(LLVMInt32Type(), INT_MIN, 0),
                                   "");

      in_out_mask = lp_build_int_const_scalar(i32_type, ~0);


      lp_build_flow_scope_declare(flow, &in_out_mask);

      /* if (not_draw_all) {... */
      lp_build_if(&ifctx, flow, builder, not_draw_all);
#endif
      {
         LLVMValueRef step0_vec, step1_vec, step2_vec;
         LLVMValueRef m0_vec, m1_vec, m2_vec;
         LLVMValueRef index, m;

         /* c0_vec = {c0, c0, c0, c0}
          * Note that we emit this code four times but LLVM optimizes away
          * three instances of it.
          */
         c0_vec = lp_build_broadcast(builder, i32vec4_type, c0);
         c1_vec = lp_build_broadcast(builder, i32vec4_type, c1);
         c2_vec = lp_build_broadcast(builder, i32vec4_type, c2);
         lp_build_name(c0_vec, "edgeconst0vec");
         lp_build_name(c1_vec, "edgeconst1vec");
         lp_build_name(c2_vec, "edgeconst2vec");

         /* load step0vec, step1, step2 vec from memory */
         index = LLVMConstInt(LLVMInt32Type(), i, 0);
         step0_vec = LLVMBuildLoad(builder, LLVMBuildGEP(builder, step0_ptr, &index, 1, ""), "");
         step1_vec = LLVMBuildLoad(builder, LLVMBuildGEP(builder, step1_ptr, &index, 1, ""), "");
         step2_vec = LLVMBuildLoad(builder, LLVMBuildGEP(builder, step2_ptr, &index, 1, ""), "");
         lp_build_name(step0_vec, "step0vec");
         lp_build_name(step1_vec, "step1vec");
         lp_build_name(step2_vec, "step2vec");

         /* m0_vec = step0_ptr[i] > c0_vec */
         m0_vec = lp_build_compare(builder, i32_type, PIPE_FUNC_GREATER, step0_vec, c0_vec);
         m1_vec = lp_build_compare(builder, i32_type, PIPE_FUNC_GREATER, step1_vec, c1_vec);
         m2_vec = lp_build_compare(builder, i32_type, PIPE_FUNC_GREATER, step2_vec, c2_vec);

         /* in_out_mask = m0_vec & m1_vec & m2_vec */
         m = LLVMBuildAnd(builder, m0_vec, m1_vec, "");
         in_out_mask = LLVMBuildAnd(builder, m, m2_vec, "");
         lp_build_name(in_out_mask, "inoutmaskvec");
      }
#if OPTIMIZE_IN_OUT_TEST
      lp_build_endif(&ifctx);
#endif

   }
   lp_build_flow_scope_end(flow);
   lp_build_flow_destroy(flow);
d185 1
a185 5
   /* This is the initial alive/dead pixel mask for a quad of four pixels.
    * It's an int[4] vector with each word set to 0 or ~0.
    * Words will get cleared when pixels faile the Z test, etc.
    */
   *mask = in_out_mask;
d189 9
a197 5
static LLVMValueRef
generate_scissor_test(LLVMBuilderRef builder,
                      LLVMValueRef context_ptr,
                      const struct lp_build_interp_soa_context *interp,
                      struct lp_type type)
d199 1
a199 38
   LLVMTypeRef vec_type = lp_build_vec_type(type);
   LLVMValueRef xpos = interp->pos[0], ypos = interp->pos[1];
   LLVMValueRef xmin, ymin, xmax, ymax;
   LLVMValueRef m0, m1, m2, m3, m;

   /* xpos, ypos contain the window coords for the four pixels in the quad */
   assert(xpos);
   assert(ypos);

   /* get the current scissor bounds, convert to vectors */
   xmin = lp_jit_context_scissor_xmin_value(builder, context_ptr);
   xmin = lp_build_broadcast(builder, vec_type, xmin);

   ymin = lp_jit_context_scissor_ymin_value(builder, context_ptr);
   ymin = lp_build_broadcast(builder, vec_type, ymin);

   xmax = lp_jit_context_scissor_xmax_value(builder, context_ptr);
   xmax = lp_build_broadcast(builder, vec_type, xmax);

   ymax = lp_jit_context_scissor_ymax_value(builder, context_ptr);
   ymax = lp_build_broadcast(builder, vec_type, ymax);

   /* compare the fragment's position coordinates against the scissor bounds */
   m0 = lp_build_compare(builder, type, PIPE_FUNC_GEQUAL, xpos, xmin);
   m1 = lp_build_compare(builder, type, PIPE_FUNC_GEQUAL, ypos, ymin);
   m2 = lp_build_compare(builder, type, PIPE_FUNC_LESS, xpos, xmax);
   m3 = lp_build_compare(builder, type, PIPE_FUNC_LESS, ypos, ymax);

   /* AND all the masks together */
   m = LLVMBuildAnd(builder, m0, m1, "");
   m = LLVMBuildAnd(builder, m, m2, "");
   m = LLVMBuildAnd(builder, m, m3, "");

   lp_build_name(m, "scissormask");

   return m;
}

d201 4
a204 4
static LLVMValueRef
build_int32_vec_const(int value)
{
   struct lp_type i32_type;
d206 1
a206 7
   memset(&i32_type, 0, sizeof i32_type);
   i32_type.floating = FALSE; /* values are integers */
   i32_type.sign = TRUE;      /* values are signed */
   i32_type.norm = FALSE;     /* values are not normalized */
   i32_type.width = 32;       /* 32-bit int values */
   i32_type.length = 4;       /* 4 elements per vector */
   return lp_build_int_const_scalar(i32_type, value);
a209 1

d213 1
a213 1
 * \param do_tri_test  if 1, do triangle edge in/out testing
d216 1
a216 1
generate_fs(struct llvmpipe_context *lp,
d223 1
a223 1
            const struct lp_build_interp_soa_context *interp,
d228 4
a231 7
            unsigned do_tri_test,
            LLVMValueRef c0,
            LLVMValueRef c1,
            LLVMValueRef c2,
            LLVMValueRef step0_ptr,
            LLVMValueRef step1_ptr,
            LLVMValueRef step2_ptr)
d233 1
a234 1
   LLVMTypeRef elem_type;
a235 1
   LLVMTypeRef int_vec_type;
d238 3
a240 2
   LLVMValueRef z = interp->pos[2];
   struct lp_build_flow_context *flow;
d242 3
a244 1
   boolean early_depth_test;
d248 31
d282 2
a283 3
   elem_type = lp_build_elem_type(type);
   vec_type = lp_build_vec_type(type);
   int_vec_type = lp_build_int_vec_type(type);
d285 1
a285 1
   consts_ptr = lp_jit_context_constants(builder, context_ptr);
d287 1
a287 1
   flow = lp_build_flow_create(builder);
a290 2
   lp_build_flow_scope_begin(flow);

d294 1
a294 2
	 color[cbuf][chan] = LLVMGetUndef(vec_type);
	 lp_build_flow_scope_declare(flow, &color[cbuf][chan]);
a296 1
   lp_build_flow_scope_declare(flow, &z);
d299 3
a301 3
   if (do_tri_test) {
      generate_tri_edge_mask(builder, i, pmask,
                             c0, c1, c2, step0_ptr, step1_ptr, step2_ptr);
d304 1
a304 1
      *pmask = build_int32_vec_const(~0);
d308 1
a308 1
   lp_build_mask_begin(&mask, flow, type, *pmask);
d310 2
a311 16
   if (key->scissor) {
      LLVMValueRef smask =
         generate_scissor_test(builder, context_ptr, interp, type);
      lp_build_mask_update(&mask, smask);
   }

   early_depth_test =
      key->depth.enabled &&
      !key->alpha.enabled &&
      !shader->info.uses_kill &&
      !shader->info.writes_z;

   if(early_depth_test)
      generate_depth(builder, key,
                     type, &mask,
                     z, depth_ptr);
d313 25
a337 1
   lp_build_tgsi_soa(builder, tokens, type, &mask,
d339 1
a339 1
                     outputs, sampler);
d341 16
a356 35
   for (attrib = 0; attrib < shader->info.num_outputs; ++attrib) {
      for(chan = 0; chan < NUM_CHANNELS; ++chan) {
         if(outputs[attrib][chan]) {
            LLVMValueRef out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
            lp_build_name(out, "output%u.%u.%c", i, attrib, "xyzw"[chan]);

            switch (shader->info.output_semantic_name[attrib]) {
            case TGSI_SEMANTIC_COLOR:
               {
                  unsigned cbuf = shader->info.output_semantic_index[attrib];

                  lp_build_name(out, "color%u.%u.%c", i, attrib, "rgba"[chan]);

                  /* Alpha test */
                  /* XXX: should the alpha reference value be passed separately? */
		  /* XXX: should only test the final assignment to alpha */
                  if(cbuf == 0 && chan == 3) {
                     LLVMValueRef alpha = out;
                     LLVMValueRef alpha_ref_value;
                     alpha_ref_value = lp_jit_context_alpha_ref_value(builder, context_ptr);
                     alpha_ref_value = lp_build_broadcast(builder, vec_type, alpha_ref_value);
                     lp_build_alpha_test(builder, &key->alpha, type,
                                         &mask, alpha, alpha_ref_value);
                  }

		  color[cbuf][chan] = out;
                  break;
               }

            case TGSI_SEMANTIC_POSITION:
               if(chan == 2)
                  z = out;
               break;
            }
         }
d360 9
a368 4
   if(!early_depth_test)
      generate_depth(builder, key,
                     type, &mask,
                     z, depth_ptr);
d370 30
a399 1
   lp_build_mask_end(&mask);
a400 1
   lp_build_flow_scope_end(flow);
d402 19
a420 1
   lp_build_flow_destroy(flow);
d422 3
a424 1
   *pmask = mask.value;
d426 1
d432 6
d440 3
a442 1
generate_blend(const struct pipe_blend_state *blend,
d448 2
a449 1
               LLVMValueRef dst_ptr)
a451 1
   struct lp_build_flow_context *flow;
a453 1
   LLVMTypeRef int_vec_type;
d460 1
a460 3
   lp_build_context_init(&bld, builder, type);

   flow = lp_build_flow_create(builder);
d462 3
a464 2
   /* we'll use this mask context to skip blending if all pixels are dead */
   lp_build_mask_begin(&mask_ctx, flow, type, mask);
d466 1
a466 2
   vec_type = lp_build_vec_type(type);
   int_vec_type = lp_build_int_vec_type(type);
d468 1
a468 1
   const_ptr = lp_jit_context_blend_color(builder, context_ptr);
d472 1
d474 1
a474 1
      LLVMValueRef index = LLVMConstInt(LLVMInt32Type(), chan, 0);
d483 2
a484 1
   lp_build_blend_soa(builder, blend, type, src, dst, con, res);
d486 1
d488 2
a489 2
      if(blend->rt[0].colormask & (1 << chan)) {
         LLVMValueRef index = LLVMConstInt(LLVMInt32Type(), chan, 0);
a496 1
   lp_build_flow_destroy(flow);
d510 1
a510 1
                  unsigned do_tri_test)
d512 1
a512 1
   struct llvmpipe_screen *screen = llvmpipe_screen(lp->pipe.screen);
d514 2
a518 1
   LLVMTypeRef fs_vec_type;
d521 1
a521 2
   LLVMTypeRef blend_int_vec_type;
   LLVMTypeRef arg_types[14];
d523 2
a524 1
   LLVMTypeRef int32_vec4_type = lp_build_int32_vec4_type();
d533 2
a534 1
   LLVMValueRef c0, c1, c2, step0_ptr, step1_ptr, step2_ptr;
a536 2
   LLVMValueRef x0;
   LLVMValueRef y0;
a541 1
   LLVMValueRef blend_in_color[NUM_CHANNELS];
d543 2
d550 12
d586 19
a604 24
   fs_elem_type = lp_build_elem_type(fs_type);
   fs_vec_type = lp_build_vec_type(fs_type);
   fs_int_vec_type = lp_build_int_vec_type(fs_type);

   blend_vec_type = lp_build_vec_type(blend_type);
   blend_int_vec_type = lp_build_int_vec_type(blend_type);

   arg_types[0] = screen->context_ptr_type;            /* context */
   arg_types[1] = LLVMInt32Type();                     /* x */
   arg_types[2] = LLVMInt32Type();                     /* y */
   arg_types[3] = LLVMPointerType(fs_elem_type, 0);    /* a0 */
   arg_types[4] = LLVMPointerType(fs_elem_type, 0);    /* dadx */
   arg_types[5] = LLVMPointerType(fs_elem_type, 0);    /* dady */
   arg_types[6] = LLVMPointerType(LLVMPointerType(blend_vec_type, 0), 0);  /* color */
   arg_types[7] = LLVMPointerType(fs_int_vec_type, 0); /* depth */
   arg_types[8] = LLVMInt32Type();                     /* c0 */
   arg_types[9] = LLVMInt32Type();                     /* c1 */
   arg_types[10] = LLVMInt32Type();                    /* c2 */
   /* Note: the step arrays are built as int32[16] but we interpret
    * them here as int32_vec4[4].
    */
   arg_types[11] = LLVMPointerType(int32_vec4_type, 0);/* step0 */
   arg_types[12] = LLVMPointerType(int32_vec4_type, 0);/* step1 */
   arg_types[13] = LLVMPointerType(int32_vec4_type, 0);/* step2 */
d606 2
a607 1
   func_type = LLVMFunctionType(LLVMVoidType(), arg_types, Elements(arg_types), 0);
d609 1
a609 1
   function = LLVMAddFunction(screen->module, "shader", func_type);
d612 1
a612 2
   variant->function[do_tri_test] = function;

d624 7
a630 11
   a0_ptr       = LLVMGetParam(function, 3);
   dadx_ptr     = LLVMGetParam(function, 4);
   dady_ptr     = LLVMGetParam(function, 5);
   color_ptr_ptr = LLVMGetParam(function, 6);
   depth_ptr    = LLVMGetParam(function, 7);
   c0           = LLVMGetParam(function, 8);
   c1           = LLVMGetParam(function, 9);
   c2           = LLVMGetParam(function, 10);
   step0_ptr    = LLVMGetParam(function, 11);
   step1_ptr    = LLVMGetParam(function, 12);
   step2_ptr    = LLVMGetParam(function, 13);
d638 1
a638 1
   lp_build_name(color_ptr_ptr, "color_ptr");
d640 6
a645 6
   lp_build_name(c0, "c0");
   lp_build_name(c1, "c1");
   lp_build_name(c2, "c2");
   lp_build_name(step0_ptr, "step0");
   lp_build_name(step1_ptr, "step1");
   lp_build_name(step2_ptr, "step2");
d651 3
a653 2
   block = LLVMAppendBasicBlock(function, "entry");
   builder = LLVMCreateBuilder();
d656 5
a660 2
   generate_pos0(builder, x, y, &x0, &y0);

d662 3
a664 2
                            shader->base.tokens,
                            key->flatshade,
d667 1
a667 1
                            x0, y0);
d673 2
d676 3
a678 1
      LLVMValueRef index = LLVMConstInt(LLVMInt32Type(), i, 0);
a680 4
      int cbuf;

      if(i != 0)
         lp_build_interp_soa_update(&interp, i);
d682 1
a682 1
      depth_ptr_i = LLVMBuildGEP(builder, depth_ptr, &index, 1, "");
d684 2
a685 1
      generate_fs(lp, shader, key,
d695 4
a698 3
                  do_tri_test,
                  c0, c1, c2,
                  step0_ptr, step1_ptr, step2_ptr);
d711 3
a713 1
      LLVMValueRef index = LLVMConstInt(LLVMInt32Type(), cbuf, 0);
d719 10
a728 2
	 lp_build_conv(builder, fs_type, blend_type,
		       fs_out_color[cbuf][chan], num_fs,
d730 1
d734 7
a740 3
      lp_build_conv_mask(builder, fs_type, blend_type,
			 fs_mask, num_fs,
			 &blend_mask, 1);
d747 3
d753 18
a770 7
      generate_blend(&key->blend,
		     builder,
		     blend_type,
		     context_ptr,
		     blend_mask,
		     blend_in_color,
		     color_ptr);
a774 3
   LLVMDisposeBuilder(builder);


d779 1
a779 1
         LLVMDumpValue(function);
d785 1
a785 2
   if (1)
      LLVMRunFunctionPassManager(screen->pass, function);
d787 1
a787 1
   if (LP_DEBUG & DEBUG_JIT) {
d789 1
a789 1
      LLVMDumpValue(function);
d793 5
d801 46
a846 1
   variant->jit_function[do_tri_test] = (lp_jit_frag_func)LLVMGetPointerToGlobal(screen->engine, function);
d848 56
a903 2
   if (LP_DEBUG & DEBUG_ASM)
      lp_disassemble(variant->jit_function[do_tri_test]);
d907 4
d917 1
a917 53

   if (LP_DEBUG & DEBUG_JIT) {
      unsigned i;

      tgsi_dump(shader->base.tokens, 0);
      if(key->depth.enabled) {
         debug_printf("depth.format = %s\n", util_format_name(key->zsbuf_format));
         debug_printf("depth.func = %s\n", util_dump_func(key->depth.func, TRUE));
         debug_printf("depth.writemask = %u\n", key->depth.writemask);
      }
      if(key->alpha.enabled) {
         debug_printf("alpha.func = %s\n", util_dump_func(key->alpha.func, TRUE));
         debug_printf("alpha.ref_value = %f\n", key->alpha.ref_value);
      }
      if(key->blend.logicop_enable) {
         debug_printf("blend.logicop_func = %u\n", key->blend.logicop_func);
      }
      else if(key->blend.rt[0].blend_enable) {
         debug_printf("blend.rgb_func = %s\n",   util_dump_blend_func  (key->blend.rt[0].rgb_func, TRUE));
         debug_printf("rgb_src_factor = %s\n",   util_dump_blend_factor(key->blend.rt[0].rgb_src_factor, TRUE));
         debug_printf("rgb_dst_factor = %s\n",   util_dump_blend_factor(key->blend.rt[0].rgb_dst_factor, TRUE));
         debug_printf("alpha_func = %s\n",       util_dump_blend_func  (key->blend.rt[0].alpha_func, TRUE));
         debug_printf("alpha_src_factor = %s\n", util_dump_blend_factor(key->blend.rt[0].alpha_src_factor, TRUE));
         debug_printf("alpha_dst_factor = %s\n", util_dump_blend_factor(key->blend.rt[0].alpha_dst_factor, TRUE));
      }
      debug_printf("blend.colormask = 0x%x\n", key->blend.rt[0].colormask);
      for(i = 0; i < PIPE_MAX_SAMPLERS; ++i) {
         if(key->sampler[i].format) {
            debug_printf("sampler[%u] = \n", i);
            debug_printf("  .format = %s\n",
                         util_format_name(key->sampler[i].format));
            debug_printf("  .target = %s\n",
                         util_dump_tex_target(key->sampler[i].target, TRUE));
            debug_printf("  .pot = %u %u %u\n",
                         key->sampler[i].pot_width,
                         key->sampler[i].pot_height,
                         key->sampler[i].pot_depth);
            debug_printf("  .wrap = %s %s %s\n",
                         util_dump_tex_wrap(key->sampler[i].wrap_s, TRUE),
                         util_dump_tex_wrap(key->sampler[i].wrap_t, TRUE),
                         util_dump_tex_wrap(key->sampler[i].wrap_r, TRUE));
            debug_printf("  .min_img_filter = %s\n",
                         util_dump_tex_filter(key->sampler[i].min_img_filter, TRUE));
            debug_printf("  .min_mip_filter = %s\n",
                         util_dump_tex_mipfilter(key->sampler[i].min_mip_filter, TRUE));
            debug_printf("  .mag_img_filter = %s\n",
                         util_dump_tex_filter(key->sampler[i].mag_img_filter, TRUE));
            if(key->sampler[i].compare_mode != PIPE_TEX_COMPARE_NONE)
               debug_printf("  .compare_func = %s\n", util_dump_func(key->sampler[i].compare_func, TRUE));
            debug_printf("  .normalized_coords = %u\n", key->sampler[i].normalized_coords);
         }
      }
   }
d924 3
a926 1
   memcpy(&variant->key, key, sizeof *key);
d928 1
a928 2
   generate_fragment(lp, shader, variant, 0);
   generate_fragment(lp, shader, variant, 1);
d930 36
a965 3
   /* insert new variant into linked list */
   variant->next = shader->variants;
   shader->variants = variant;
d971 1
a971 1
void *
d975 1
d977 2
d984 3
d988 1
a988 1
   tgsi_scan_shader(templ->tokens, &shader->info);
d993 70
d1067 1
a1067 1
void
d1077 4
a1080 1
   llvmpipe->fs = fs;
d1086 4
d1091 38
a1131 1
   struct llvmpipe_screen *screen = llvmpipe_screen(pipe->screen);
d1133 1
a1133 1
   struct lp_fragment_shader_variant *variant;
a1135 1
   (void) llvmpipe;
d1140 1
d1142 1
a1142 2
   draw_flush(llvmpipe->draw);
   lp_setup_flush(llvmpipe->setup, 0);
d1144 7
a1150 4
   variant = shader->variants;
   while(variant) {
      struct lp_fragment_shader_variant *next = variant->next;
      unsigned i;
d1152 2
a1153 13
      for (i = 0; i < Elements(variant->function); i++) {
         if (variant->function[i]) {
            if (variant->jit_function[i])
               LLVMFreeMachineCodeForFunction(screen->engine,
                                              variant->function[i]);
            LLVMDeleteFunction(variant->function[i]);
         }
      }

      FREE(variant);

      variant = next;
   }
d1155 1
d1162 1
a1162 1
void
d1165 1
a1165 1
                             struct pipe_buffer *constants)
d1168 2
a1169 2
   unsigned size = constants ? constants->size : 0;
   const void *data = constants ? llvmpipe_buffer(constants)->data : NULL;
d1172 1
a1172 1
   assert(index == 0);
d1174 1
a1174 1
   if(llvmpipe->constants[shader] == constants)
d1180 1
a1180 1
   pipe_buffer_reference(&llvmpipe->constants[shader], constants);
d1182 4
a1185 3
   if(shader == PIPE_SHADER_VERTEX) {
      draw_set_mapped_constant_buffer(llvmpipe->draw, PIPE_SHADER_VERTEX, 0,
                                      data, size);
d1193 19
d1225 1
a1225 1
   memset(key, 0, sizeof *key);
d1227 9
a1235 4
   if(lp->framebuffer.zsbuf &&
      lp->depth_stencil->depth.enabled) {
      key->zsbuf_format = lp->framebuffer.zsbuf->format;
      memcpy(&key->depth, &lp->depth_stencil->depth, sizeof key->depth);
d1244 3
a1246 1
   key->scissor = lp->rasterizer->scissor;
d1254 2
a1256 1
      unsigned chan;
d1258 1
a1258 3
      format_desc = util_format_description(lp->framebuffer.cbufs[i]->format);
      assert(format_desc->layout == UTIL_FORMAT_COLORSPACE_RGB ||
             format_desc->layout == UTIL_FORMAT_COLORSPACE_SRGB);
d1260 8
a1267 2
      /* mask out color channels not present in the color buffer.
       * Should be simple to incorporate per-cbuf writemasks:
d1269 1
a1269 2
      for(chan = 0; chan < 4; ++chan) {
         enum util_format_swizzle swizzle = format_desc->swizzle[chan];
d1271 21
a1291 2
         if(swizzle <= UTIL_FORMAT_SWIZZLE_W)
            key->blend.rt[0].colormask |= (1 << chan);
d1295 11
a1305 3
   for(i = 0; i < PIPE_MAX_SAMPLERS; ++i)
      if(shader->info.file_mask[TGSI_FILE_SAMPLER] & (1 << i))
         lp_sampler_static_state(&key->sampler[i], lp->texture[i], lp->sampler[i]);
d1309 1
d1311 1
a1311 1
 * Update fragment state.  This is called just prior to drawing
d1319 2
a1320 2
   struct lp_fragment_shader_variant *variant;
   boolean opaque;
d1324 5
a1328 3
   variant = shader->variants;
   while(variant) {
      if(memcmp(&variant->key, &key, sizeof key) == 0)
d1330 3
d1334 5
a1338 1
      variant = variant->next;
d1340 4
d1345 23
a1367 3
   if (!variant) {
      int64_t t0, t1;
      int64_t dt;
a1368 1

a1369 1

d1374 10
d1386 16
a1401 1
   shader->current = variant;
d1403 1
a1403 15
   /* TODO: put this in the variant */
   /* TODO: most of these can be relaxed, in particular the colormask */
   opaque = !key.blend.logicop_enable &&
            !key.blend.rt[0].blend_enable &&
            key.blend.rt[0].colormask == 0xf &&
            !key.alpha.enabled &&
            !key.depth.enabled &&
            !key.scissor &&
            !shader->info.uses_kill
            ? TRUE : FALSE;

   lp_setup_set_fs_functions(lp->setup, 
                             shader->current->jit_function[0],
                             shader->current->jit_function[1],
                             opaque);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 3
d40 1
a40 1
 * - depth/stencil test
d43 1
a43 1
 * This file has only the glue to assemble the fragment pipeline.  The actual
a66 1
#include "util/u_pointer.h"
a68 2
#include "util/u_string.h"
#include "util/u_simple_list.h"
a77 1
#include "gallivm/lp_bld_init.h"
d80 2
d83 2
d88 1
a88 5

#include "lp_bld_alpha.h"
#include "lp_bld_blend.h"
#include "lp_bld_depth.h"
#include "lp_bld_interp.h"
a95 2
#include "lp_flush.h"
#include "lp_state_fs.h"
d98 2
a99 2
#include <llvm-c/Analysis.h>
#include <llvm-c/BitWriter.h>
d102 33
a134 2
/** Fragment shader number (for debugging) */
static unsigned fs_no = 0;
d138 1
a138 6
 * Expand the relevent bits of mask_input to a 4-dword mask for the 
 * four pixels in a 2x2 quad.  This will set the four elements of the
 * quad mask vector to 0 or ~0.
 *
 * \param quad  which quad of the quad group to test, in [0,3]
 * \param mask_input  bitwise mask for the whole 4x4 stamp
d140 7
a146 5
static LLVMValueRef
generate_quad_mask(struct gallivm_state *gallivm,
                   struct lp_type fs_type,
                   unsigned quad,
                   LLVMValueRef mask_input) /* int32 */
d148 8
a155 6
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type mask_type;
   LLVMTypeRef i32t = LLVMInt32TypeInContext(gallivm->context);
   LLVMValueRef bits[4];
   LLVMValueRef mask;
   int shift;
d158 3
a160 1
    * XXX: We'll need a different path for 16 x u8
d162 30
a191 3
   assert(fs_type.width == 32);
   assert(fs_type.length == 4);
   mask_type = lp_int_type(fs_type);
a192 25
   /*
    * mask_input >>= (quad * 4)
    */
   switch (quad) {
   case 0:
      shift = 0;
      break;
   case 1:
      shift = 2;
      break;
   case 2:
      shift = 8;
      break;
   case 3:
      shift = 10;
      break;
   default:
      assert(0);
      shift = 0;
   }

   mask_input = LLVMBuildLShr(builder,
                              mask_input,
                              LLVMConstInt(i32t, shift, 0),
                              "");
d194 29
a222 11
   /*
    * mask = { mask_input & (1 << i), for i in [0,3] }
    */
   mask = lp_build_broadcast(gallivm,
                             lp_build_vec_type(gallivm, mask_type),
                             mask_input);

   bits[0] = LLVMConstInt(i32t, 1 << 0, 0);
   bits[1] = LLVMConstInt(i32t, 1 << 1, 0);
   bits[2] = LLVMConstInt(i32t, 1 << 4, 0);
   bits[3] = LLVMConstInt(i32t, 1 << 5, 0);
d224 11
a234 1
   mask = LLVMBuildAnd(builder, mask, LLVMConstVector(bits, 4), "");
d237 2
a238 1
    * mask = mask != 0 ? ~0 : 0
d240 62
a301 4
   mask = lp_build_compare(gallivm,
                           mask_type, PIPE_FUNC_NOTEQUAL,
                           mask,
                           lp_build_const_int_vec(gallivm, mask_type, 0));
d303 5
a307 1
   return mask;
d311 5
a315 9
#define EARLY_DEPTH_TEST  0x1
#define LATE_DEPTH_TEST   0x2
#define EARLY_DEPTH_WRITE 0x4
#define LATE_DEPTH_WRITE  0x8

static int
find_output_by_semantic( const struct tgsi_shader_info *info,
			 unsigned semantic,
			 unsigned index )
d317 38
a354 1
   int i;
d356 4
a359 4
   for (i = 0; i < info->num_outputs; i++)
      if (info->output_semantic_name[i] == semantic &&
	  info->output_semantic_index[i] == index)
	 return i;
d361 7
a367 1
   return -1;
d371 1
d375 1
a375 1
 * \param partial_mask  if 1, do mask_input testing
d378 1
a378 1
generate_fs(struct gallivm_state *gallivm,
d385 1
a385 1
            struct lp_build_interp_soa_context *interp,
d390 7
a396 4
            LLVMValueRef facing,
            unsigned partial_mask,
            LLVMValueRef mask_input,
            LLVMValueRef counter)
a397 1
   const struct util_format_description *zs_format_desc = NULL;
d399 1
d401 1
d404 2
a405 3
   LLVMValueRef z;
   LLVMValueRef zs_value = NULL;
   LLVMValueRef stencil_refs[2];
d407 1
a407 3
   boolean simple_shader = (shader->info.base.file_count[TGSI_FILE_SAMPLER] == 0 &&
                            shader->info.base.num_inputs < 3 &&
                            shader->info.base.num_instructions < 8);
a410 31
   unsigned depth_mode;

   if (key->depth.enabled ||
       key->stencil[0].enabled ||
       key->stencil[1].enabled) {

      zs_format_desc = util_format_description(key->zsbuf_format);
      assert(zs_format_desc);

      if (!shader->info.base.writes_z) {
         if (key->alpha.enabled || shader->info.base.uses_kill)
            /* With alpha test and kill, can do the depth test early
             * and hopefully eliminate some quads.  But need to do a
             * special deferred depth write once the final mask value
             * is known.
             */
            depth_mode = EARLY_DEPTH_TEST | LATE_DEPTH_WRITE;
         else
            depth_mode = EARLY_DEPTH_TEST | EARLY_DEPTH_WRITE;
      }
      else {
         depth_mode = LATE_DEPTH_TEST | LATE_DEPTH_WRITE;
      }

      if (!(key->depth.enabled && key->depth.writemask) &&
          !(key->stencil[0].enabled && key->stencil[0].writemask))
         depth_mode &= ~(LATE_DEPTH_WRITE | EARLY_DEPTH_WRITE);
   }
   else {
      depth_mode = 0;
   }
d414 3
a416 2
   stencil_refs[0] = lp_jit_context_stencil_ref_front_value(gallivm, context_ptr);
   stencil_refs[1] = lp_jit_context_stencil_ref_back_value(gallivm, context_ptr);
d418 1
a418 1
   vec_type = lp_build_vec_type(gallivm, type);
d420 1
a420 1
   consts_ptr = lp_jit_context_constants(gallivm, context_ptr);
d424 2
d429 2
a430 1
	 color[cbuf][chan] = lp_build_alloca(gallivm, vec_type, "color");
d433 1
d436 3
a438 3
   if (partial_mask) {
      *pmask = generate_quad_mask(gallivm, type,
                                  i, mask_input);
d441 1
a441 1
      *pmask = lp_build_const_int_vec(gallivm, type, ~0);
d445 1
a445 1
   lp_build_mask_begin(&mask, gallivm, type, *pmask);
d447 16
a462 2
   if (!(depth_mode & EARLY_DEPTH_TEST) && !simple_shader)
      lp_build_mask_check(&mask);
d464 1
a464 25
   lp_build_interp_soa_update_pos(interp, gallivm, i);
   z = interp->pos[2];

   if (depth_mode & EARLY_DEPTH_TEST) {
      lp_build_depth_stencil_test(gallivm,
                                  &key->depth,
                                  key->stencil,
                                  type,
                                  zs_format_desc,
                                  &mask,
                                  stencil_refs,
                                  z,
                                  depth_ptr, facing,
                                  &zs_value,
                                  !simple_shader);

      if (depth_mode & EARLY_DEPTH_WRITE) {
         lp_build_depth_write(builder, zs_format_desc, depth_ptr, zs_value);
      }
   }

   lp_build_interp_soa_update_inputs(interp, gallivm, i);
   
   /* Build the actual shader */
   lp_build_tgsi_soa(gallivm, tokens, type, &mask,
d466 1
a466 1
                     outputs, sampler, &shader->info.base);
d468 35
a502 16
   /* Alpha test */
   if (key->alpha.enabled) {
      int color0 = find_output_by_semantic(&shader->info.base,
                                           TGSI_SEMANTIC_COLOR,
                                           0);

      if (color0 != -1 && outputs[color0][3]) {
         LLVMValueRef alpha = LLVMBuildLoad(builder, outputs[color0][3], "alpha");
         LLVMValueRef alpha_ref_value;

         alpha_ref_value = lp_jit_context_alpha_ref_value(gallivm, context_ptr);
         alpha_ref_value = lp_build_broadcast(gallivm, vec_type, alpha_ref_value);

         lp_build_alpha_test(gallivm, key->alpha.func, type,
                             &mask, alpha, alpha_ref_value,
                             (depth_mode & LATE_DEPTH_TEST) != 0);
d506 4
a509 9
   /* Late Z test */
   if (depth_mode & LATE_DEPTH_TEST) { 
      int pos0 = find_output_by_semantic(&shader->info.base,
                                         TGSI_SEMANTIC_POSITION,
                                         0);
         
      if (pos0 != -1 && outputs[pos0][2]) {
         z = LLVMBuildLoad(builder, outputs[pos0][2], "output.z");
      }
d511 1
a511 30
      lp_build_depth_stencil_test(gallivm,
                                  &key->depth,
                                  key->stencil,
                                  type,
                                  zs_format_desc,
                                  &mask,
                                  stencil_refs,
                                  z,
                                  depth_ptr, facing,
                                  &zs_value,
                                  !simple_shader);
      /* Late Z write */
      if (depth_mode & LATE_DEPTH_WRITE) {
         lp_build_depth_write(builder, zs_format_desc, depth_ptr, zs_value);
      }
   }
   else if ((depth_mode & EARLY_DEPTH_TEST) &&
            (depth_mode & LATE_DEPTH_WRITE))
   {
      /* Need to apply a reduced mask to the depth write.  Reload the
       * depth value, update from zs_value with the new mask value and
       * write that out.
       */
      lp_build_deferred_depth_write(gallivm,
                                    type,
                                    zs_format_desc,
                                    &mask,
                                    depth_ptr,
                                    zs_value);
   }
d513 1
d515 1
a515 19
   /* Color write  */
   for (attrib = 0; attrib < shader->info.base.num_outputs; ++attrib)
   {
      if (shader->info.base.output_semantic_name[attrib] == TGSI_SEMANTIC_COLOR &&
          shader->info.base.output_semantic_index[attrib] < key->nr_cbufs)
      {
         unsigned cbuf = shader->info.base.output_semantic_index[attrib];
         for(chan = 0; chan < NUM_CHANNELS; ++chan) {
            if(outputs[attrib][chan]) {
               /* XXX: just initialize outputs to point at colors[] and
                * skip this.
                */
               LLVMValueRef out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
               lp_build_name(out, "color%u.%u.%c", i, attrib, "rgba"[chan]);
               LLVMBuildStore(builder, out, color[cbuf][chan]);
            }
         }
      }
   }
d517 1
a517 3
   if (counter)
      lp_build_occlusion_count(gallivm, type,
                               lp_build_mask_value(&mask), counter);
a518 1
   *pmask = lp_build_mask_end(&mask);
a523 6
 * \param rt  the render target index (to index blend, colormask state)
 * \param type  the pixel color type
 * \param context_ptr  pointer to the runtime JIT context
 * \param mask  execution mask (active fragment/pixel mask)
 * \param src  colors from the fragment shader
 * \param dst_ptr  the destination color buffer pointer
d526 1
a526 3
generate_blend(struct gallivm_state *gallivm,
               const struct pipe_blend_state *blend,
               unsigned rt,
d532 1
a532 2
               LLVMValueRef dst_ptr,
               boolean do_branch)
d535 1
d538 1
d545 3
a547 1
   lp_build_context_init(&bld, gallivm, type);
d549 2
a550 3
   lp_build_mask_begin(&mask_ctx, gallivm, type, mask);
   if (do_branch)
      lp_build_mask_check(&mask_ctx);
d552 2
a553 1
   vec_type = lp_build_vec_type(gallivm, type);
d555 1
a555 1
   const_ptr = lp_jit_context_blend_color(gallivm, context_ptr);
a558 1
   /* load constant blend color and colors from the dest color buffer */
d560 1
a560 1
      LLVMValueRef index = lp_build_const_int32(gallivm, chan);
d569 1
a569 2
   /* do blend */
   lp_build_blend_soa(gallivm, blend, type, rt, src, dst, con, res);
a570 1
   /* store results to color buffer */
d572 2
a573 2
      if(blend->rt[rt].colormask & (1 << chan)) {
         LLVMValueRef index = lp_build_const_int32(gallivm, chan);
d581 1
d595 1
a595 1
                  unsigned partial_mask)
d597 1
a597 1
   struct gallivm_state *gallivm = lp->gallivm;
a598 2
   struct lp_shader_input inputs[PIPE_MAX_SHADER_INPUTS];
   char func_name[256];
d602 1
d605 2
a606 1
   LLVMTypeRef arg_types[11];
d608 1
a608 2
   LLVMTypeRef int32_type = LLVMInt32TypeInContext(gallivm->context);
   LLVMTypeRef int8_type = LLVMInt8TypeInContext(gallivm->context);
d617 1
a617 2
   LLVMValueRef mask_input;
   LLVMValueRef counter = NULL;
d620 2
d627 1
a628 2
   LLVMValueRef facing;
   const struct util_format_description *zs_format_desc;
a633 12
   /* Adjust color input interpolation according to flatshade state:
    */
   memcpy(inputs, shader->inputs, shader->info.base.num_inputs * sizeof inputs[0]);
   for (i = 0; i < shader->info.base.num_inputs; i++) {
      if (inputs[i].interp == LP_INTERP_COLOR) {
	 if (key->flatshade)
	    inputs[i].interp = LP_INTERP_CONSTANT;
	 else
	    inputs[i].interp = LP_INTERP_LINEAR;
      }
   }

d658 24
a681 2
   fs_elem_type = lp_build_elem_type(gallivm, fs_type);
   fs_int_vec_type = lp_build_int_vec_type(gallivm, fs_type);
d683 1
a683 1
   blend_vec_type = lp_build_vec_type(gallivm, blend_type);
d685 2
a686 2
   util_snprintf(func_name, sizeof(func_name), "fs%u_variant%u_%s", 
		 shader->no, variant->no, partial_mask ? "partial" : "whole");
d688 1
a688 11
   arg_types[0] = lp_jit_get_context_type(lp);         /* context */
   arg_types[1] = int32_type;                          /* x */
   arg_types[2] = int32_type;                          /* y */
   arg_types[3] = int32_type;                          /* facing */
   arg_types[4] = LLVMPointerType(fs_elem_type, 0);    /* a0 */
   arg_types[5] = LLVMPointerType(fs_elem_type, 0);    /* dadx */
   arg_types[6] = LLVMPointerType(fs_elem_type, 0);    /* dady */
   arg_types[7] = LLVMPointerType(LLVMPointerType(blend_vec_type, 0), 0);  /* color */
   arg_types[8] = LLVMPointerType(int8_type, 0);       /* depth */
   arg_types[9] = int32_type;                          /* mask_input */
   arg_types[10] = LLVMPointerType(int32_type, 0);     /* counter */
a689 7
   func_type = LLVMFunctionType(LLVMVoidTypeInContext(gallivm->context),
                                arg_types, Elements(arg_types), 0);

   function = LLVMAddFunction(gallivm->module, func_name, func_type);
   LLVMSetFunctionCallConv(function, LLVMCCallConv);

   variant->function[partial_mask] = function;
d701 11
a711 7
   facing       = LLVMGetParam(function, 3);
   a0_ptr       = LLVMGetParam(function, 4);
   dadx_ptr     = LLVMGetParam(function, 5);
   dady_ptr     = LLVMGetParam(function, 6);
   color_ptr_ptr = LLVMGetParam(function, 7);
   depth_ptr    = LLVMGetParam(function, 8);
   mask_input   = LLVMGetParam(function, 9);
d719 1
a719 1
   lp_build_name(color_ptr_ptr, "color_ptr_ptr");
d721 6
a726 6
   lp_build_name(mask_input, "mask_input");

   if (key->occlusion_count) {
      counter = LLVMGetParam(function, 10);
      lp_build_name(counter, "counter");
   }
d732 2
a733 3
   block = LLVMAppendBasicBlockInContext(gallivm->context, function, "entry");
   builder = gallivm->builder;
   assert(builder);
d736 2
a737 5
   /*
    * The shader input interpolation info is not explicitely baked in the
    * shader key, but everything it derives from (TGSI, and flatshade) is
    * already included in the shader key.
    */
d739 2
a740 3
                            gallivm,
                            shader->info.base.num_inputs,
                            inputs,
d743 1
a743 1
                            x, y);
a748 2
   zs_format_desc = util_format_description(key->zsbuf_format);

d750 1
a750 3
      LLVMValueRef depth_offset = LLVMConstInt(int32_type,
                                               i*fs_type.length*zs_format_desc->block.bits/8,
                                               0);
d753 4
d758 1
a758 1
      depth_ptr_i = LLVMBuildGEP(builder, depth_ptr, &depth_offset, 1, "");
d760 1
a760 2
      generate_fs(gallivm,
                  shader, key,
d770 3
a772 4
                  facing,
                  partial_mask,
                  mask_input,
                  counter);
d785 1
a785 3
      LLVMValueRef index = lp_build_const_int32(gallivm, cbuf);
      LLVMValueRef blend_in_color[NUM_CHANNELS];
      unsigned rt;
d791 2
a792 10
         LLVMValueRef fs_color_vals[LP_MAX_VECTOR_LENGTH];
         
         for (i = 0; i < num_fs; i++) {
            fs_color_vals[i] =
               LLVMBuildLoad(builder, fs_out_color[cbuf][chan][i], "fs_color_vals");
         }

	 lp_build_conv(gallivm, fs_type, blend_type,
                       fs_color_vals,
                       num_fs,
a793 1

d797 3
a799 7
      if (partial_mask || !variant->opaque) {
         lp_build_conv_mask(lp->gallivm, fs_type, blend_type,
                            fs_mask, num_fs,
                            &blend_mask, 1);
      } else {
         blend_mask = lp_build_const_int_vec(lp->gallivm, blend_type, ~0);
      }
a805 3
      /* which blend/colormask state to use */
      rt = key->blend.independent_blend_enable ? cbuf : 0;

d809 7
a815 18
      {
         /* Could the 4x4 have been killed?
          */
         boolean do_branch = ((key->depth.enabled || key->stencil[0].enabled) &&
                              !key->alpha.enabled &&
                              !shader->info.base.uses_kill);

         generate_blend(lp->gallivm,
                        &key->blend,
                        rt,
                        builder,
                        blend_type,
                        context_ptr,
                        blend_mask,
                        blend_in_color,
                        color_ptr,
                        do_branch);
      }
d820 3
d827 1
a827 1
         lp_debug_dump_value(function);
d833 2
a834 1
   LLVMRunFunctionPassManager(gallivm->passmgr, function);
d836 1
a836 1
   if ((gallivm_debug & GALLIVM_DEBUG_IR) || (LP_DEBUG & DEBUG_FS)) {
d838 1
a838 1
      lp_debug_dump_value(function);
a841 5
   /* Dump byte code to a file */
   if (0) {
      LLVMWriteBitcodeToFile(gallivm->module, "llvmpipe.bc");
   }

d845 1
a845 46
   {
      void *f = LLVMGetPointerToGlobal(gallivm->engine, function);

      variant->jit_function[partial_mask] = (lp_jit_frag_func)pointer_to_func(f);

      if ((gallivm_debug & GALLIVM_DEBUG_ASM) || (LP_DEBUG & DEBUG_FS)) {
         lp_disassemble(f);
      }
      lp_func_delete_body(function);
   }
}


static void
dump_fs_variant_key(const struct lp_fragment_shader_variant_key *key)
{
   unsigned i;

   debug_printf("fs variant %p:\n", (void *) key);

   if (key->flatshade) {
      debug_printf("flatshade = 1\n");
   }
   for (i = 0; i < key->nr_cbufs; ++i) {
      debug_printf("cbuf_format[%u] = %s\n", i, util_format_name(key->cbuf_format[i]));
   }
   if (key->depth.enabled) {
      debug_printf("depth.format = %s\n", util_format_name(key->zsbuf_format));
      debug_printf("depth.func = %s\n", util_dump_func(key->depth.func, TRUE));
      debug_printf("depth.writemask = %u\n", key->depth.writemask);
   }

   for (i = 0; i < 2; ++i) {
      if (key->stencil[i].enabled) {
         debug_printf("stencil[%u].func = %s\n", i, util_dump_func(key->stencil[i].func, TRUE));
         debug_printf("stencil[%u].fail_op = %s\n", i, util_dump_stencil_op(key->stencil[i].fail_op, TRUE));
         debug_printf("stencil[%u].zpass_op = %s\n", i, util_dump_stencil_op(key->stencil[i].zpass_op, TRUE));
         debug_printf("stencil[%u].zfail_op = %s\n", i, util_dump_stencil_op(key->stencil[i].zfail_op, TRUE));
         debug_printf("stencil[%u].valuemask = 0x%x\n", i, key->stencil[i].valuemask);
         debug_printf("stencil[%u].writemask = 0x%x\n", i, key->stencil[i].writemask);
      }
   }

   if (key->alpha.enabled) {
      debug_printf("alpha.func = %s\n", util_dump_func(key->alpha.func, TRUE));
   }
d847 2
a848 56
   if (key->occlusion_count) {
      debug_printf("occlusion_count = 1\n");
   }

   if (key->blend.logicop_enable) {
      debug_printf("blend.logicop_func = %s\n", util_dump_logicop(key->blend.logicop_func, TRUE));
   }
   else if (key->blend.rt[0].blend_enable) {
      debug_printf("blend.rgb_func = %s\n",   util_dump_blend_func  (key->blend.rt[0].rgb_func, TRUE));
      debug_printf("blend.rgb_src_factor = %s\n",   util_dump_blend_factor(key->blend.rt[0].rgb_src_factor, TRUE));
      debug_printf("blend.rgb_dst_factor = %s\n",   util_dump_blend_factor(key->blend.rt[0].rgb_dst_factor, TRUE));
      debug_printf("blend.alpha_func = %s\n",       util_dump_blend_func  (key->blend.rt[0].alpha_func, TRUE));
      debug_printf("blend.alpha_src_factor = %s\n", util_dump_blend_factor(key->blend.rt[0].alpha_src_factor, TRUE));
      debug_printf("blend.alpha_dst_factor = %s\n", util_dump_blend_factor(key->blend.rt[0].alpha_dst_factor, TRUE));
   }
   debug_printf("blend.colormask = 0x%x\n", key->blend.rt[0].colormask);
   for (i = 0; i < key->nr_samplers; ++i) {
      debug_printf("sampler[%u] = \n", i);
      debug_printf("  .format = %s\n",
                   util_format_name(key->sampler[i].format));
      debug_printf("  .target = %s\n",
                   util_dump_tex_target(key->sampler[i].target, TRUE));
      debug_printf("  .pot = %u %u %u\n",
                   key->sampler[i].pot_width,
                   key->sampler[i].pot_height,
                   key->sampler[i].pot_depth);
      debug_printf("  .wrap = %s %s %s\n",
                   util_dump_tex_wrap(key->sampler[i].wrap_s, TRUE),
                   util_dump_tex_wrap(key->sampler[i].wrap_t, TRUE),
                   util_dump_tex_wrap(key->sampler[i].wrap_r, TRUE));
      debug_printf("  .min_img_filter = %s\n",
                   util_dump_tex_filter(key->sampler[i].min_img_filter, TRUE));
      debug_printf("  .min_mip_filter = %s\n",
                   util_dump_tex_mipfilter(key->sampler[i].min_mip_filter, TRUE));
      debug_printf("  .mag_img_filter = %s\n",
                   util_dump_tex_filter(key->sampler[i].mag_img_filter, TRUE));
      if (key->sampler[i].compare_mode != PIPE_TEX_COMPARE_NONE)
         debug_printf("  .compare_func = %s\n", util_dump_func(key->sampler[i].compare_func, TRUE));
      debug_printf("  .normalized_coords = %u\n", key->sampler[i].normalized_coords);
      debug_printf("  .min_max_lod_equal = %u\n", key->sampler[i].min_max_lod_equal);
      debug_printf("  .lod_bias_non_zero = %u\n", key->sampler[i].lod_bias_non_zero);
      debug_printf("  .apply_min_lod = %u\n", key->sampler[i].apply_min_lod);
      debug_printf("  .apply_max_lod = %u\n", key->sampler[i].apply_max_lod);
   }
}


void
lp_debug_fs_variant(const struct lp_fragment_shader_variant *variant)
{
   debug_printf("llvmpipe: Fragment shader #%u variant #%u:\n", 
                variant->shader->no, variant->no);
   tgsi_dump(variant->shader->base.tokens, 0);
   dump_fs_variant_key(&variant->key);
   debug_printf("variant->opaque = %u\n", variant->opaque);
   debug_printf("\n");
a851 4
/**
 * Generate a new fragment shader variant from the shader code and
 * other state indicated by the key.
 */
d858 53
a910 1
   boolean fullcolormask;
d917 1
a917 3
   variant->list_item_global.base = variant;
   variant->list_item_local.base = variant;
   variant->no = shader->variants_created++;
d919 2
a920 1
   memcpy(&variant->key, key, shader->variant_key_size);
d922 3
a924 36
   /*
    * Determine whether we are touching all channels in the color buffer.
    */
   fullcolormask = FALSE;
   if (key->nr_cbufs == 1) {
      const struct util_format_description *format_desc;
      format_desc = util_format_description(key->cbuf_format[0]);
      if ((~key->blend.rt[0].colormask &
           util_format_colormask(format_desc)) == 0) {
         fullcolormask = TRUE;
      }
   }

   variant->opaque =
         !key->blend.logicop_enable &&
         !key->blend.rt[0].blend_enable &&
         fullcolormask &&
         !key->stencil[0].enabled &&
         !key->alpha.enabled &&
         !key->depth.enabled &&
         !shader->info.base.uses_kill
         ? TRUE : FALSE;


   if ((LP_DEBUG & DEBUG_FS) || (gallivm_debug & GALLIVM_DEBUG_IR)) {
      lp_debug_fs_variant(variant);
   }

   generate_fragment(lp, shader, variant, RAST_EDGE_TEST);

   if (variant->opaque) {
      /* Specialized shader, which doesn't need to read the color buffer. */
      generate_fragment(lp, shader, variant, RAST_WHOLE);
   } else {
      variant->jit_function[RAST_WHOLE] = variant->jit_function[RAST_EDGE_TEST];
   }
d930 1
a930 1
static void *
a933 1
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
a934 2
   int nr_samplers;
   int i;
a939 3
   shader->no = fs_no++;
   make_empty_list(&shader->variants);

d941 1
a941 1
   lp_build_tgsi_info(templ->tokens, &shader->info);
a945 70
   shader->draw_data = draw_create_fragment_shader(llvmpipe->draw, templ);
   if (shader->draw_data == NULL) {
      FREE((void *) shader->base.tokens);
      FREE(shader);
      return NULL;
   }

   nr_samplers = shader->info.base.file_max[TGSI_FILE_SAMPLER] + 1;

   shader->variant_key_size = Offset(struct lp_fragment_shader_variant_key,
				     sampler[nr_samplers]);

   for (i = 0; i < shader->info.base.num_inputs; i++) {
      shader->inputs[i].usage_mask = shader->info.base.input_usage_mask[i];

      switch (shader->info.base.input_interpolate[i]) {
      case TGSI_INTERPOLATE_CONSTANT:
	 shader->inputs[i].interp = LP_INTERP_CONSTANT;
	 break;
      case TGSI_INTERPOLATE_LINEAR:
	 shader->inputs[i].interp = LP_INTERP_LINEAR;
	 break;
      case TGSI_INTERPOLATE_PERSPECTIVE:
	 shader->inputs[i].interp = LP_INTERP_PERSPECTIVE;
	 break;
      default:
	 assert(0);
	 break;
      }

      switch (shader->info.base.input_semantic_name[i]) {
      case TGSI_SEMANTIC_COLOR:
         /* Colors may be either linearly or constant interpolated in
	  * the fragment shader, but that information isn't available
	  * here.  Mark color inputs and fix them up later.
          */
	 shader->inputs[i].interp = LP_INTERP_COLOR;
         break;
      case TGSI_SEMANTIC_FACE:
	 shader->inputs[i].interp = LP_INTERP_FACING;
	 break;
      case TGSI_SEMANTIC_POSITION:
	 /* Position was already emitted above
	  */
	 shader->inputs[i].interp = LP_INTERP_POSITION;
	 shader->inputs[i].src_index = 0;
	 continue;
      }

      shader->inputs[i].src_index = i+1;
   }

   if (LP_DEBUG & DEBUG_TGSI) {
      unsigned attrib;
      debug_printf("llvmpipe: Create fragment shader #%u %p:\n",
                   shader->no, (void *) shader);
      tgsi_dump(templ->tokens, 0);
      debug_printf("usage masks:\n");
      for (attrib = 0; attrib < shader->info.base.num_inputs; ++attrib) {
         unsigned usage_mask = shader->info.base.input_usage_mask[attrib];
         debug_printf("  IN[%u].%s%s%s%s\n",
                      attrib,
                      usage_mask & TGSI_WRITEMASK_X ? "x" : "",
                      usage_mask & TGSI_WRITEMASK_Y ? "y" : "",
                      usage_mask & TGSI_WRITEMASK_Z ? "z" : "",
                      usage_mask & TGSI_WRITEMASK_W ? "w" : "");
      }
      debug_printf("\n");
   }

d950 1
a950 1
static void
d960 1
a960 4
   llvmpipe->fs = (struct lp_fragment_shader *) fs;

   draw_bind_fragment_shader(llvmpipe->draw,
                             (llvmpipe->fs ? llvmpipe->fs->draw_data : NULL));
a965 4
/**
 * Remove shader variant from two lists: the shader's variant list
 * and the context's variant list.
 */
a966 38
llvmpipe_remove_shader_variant(struct llvmpipe_context *lp,
                               struct lp_fragment_shader_variant *variant)
{
   unsigned i;

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      debug_printf("llvmpipe: del fs #%u var #%u v created #%u v cached"
                   " #%u v total cached #%u\n",
                   variant->shader->no,
                   variant->no,
                   variant->shader->variants_created,
                   variant->shader->variants_cached,
                   lp->nr_fs_variants);
   }

   /* free all the variant's JIT'd functions */
   for (i = 0; i < Elements(variant->function); i++) {
      if (variant->function[i]) {
         if (variant->jit_function[i])
            LLVMFreeMachineCodeForFunction(lp->gallivm->engine,
                                           variant->function[i]);
         LLVMDeleteFunction(variant->function[i]);
      }
   }

   /* remove from shader's list */
   remove_from_list(&variant->list_item_local);
   variant->shader->variants_cached--;

   /* remove from context's list */
   remove_from_list(&variant->list_item_global);
   lp->nr_fs_variants--;

   FREE(variant);
}


static void
d970 1
d972 1
a972 1
   struct lp_fs_variant_list_item *li;
d975 1
a979 1
    * Flushing alone might not sufficient we need to wait on it too.
d981 2
a982 1
   llvmpipe_finish(pipe, __FUNCTION__);
d984 17
a1000 6
   /* Delete all the variants */
   li = first_elem(&shader->variants);
   while(!at_end(&shader->variants, li)) {
      struct lp_fs_variant_list_item *next = next_elem(li);
      llvmpipe_remove_shader_variant(llvmpipe, li->base);
      li = next;
a1002 4
   /* Delete draw module's data */
   draw_delete_fragment_shader(llvmpipe->draw, shader->draw_data);

   assert(shader->variants_cached == 0);
d1009 1
a1009 1
static void
d1012 1
a1012 1
                             struct pipe_resource *constants)
d1015 2
a1016 2
   unsigned size = constants ? constants->width0 : 0;
   const void *data = constants ? llvmpipe_resource_data(constants) : NULL;
d1019 1
a1019 1
   assert(index < PIPE_MAX_CONSTANT_BUFFERS);
d1021 1
a1021 1
   if(llvmpipe->constants[shader][index] == constants)
d1027 1
a1027 1
   pipe_resource_reference(&llvmpipe->constants[shader][index], constants);
d1029 3
a1031 4
   if(shader == PIPE_SHADER_VERTEX ||
      shader == PIPE_SHADER_GEOMETRY) {
      draw_set_mapped_constant_buffer(llvmpipe->draw, shader,
                                      index, data, size);
a1038 19
 * Return the blend factor equivalent to a destination alpha of one.
 */
static INLINE unsigned
force_dst_alpha_one(unsigned factor)
{
   switch(factor) {
   case PIPE_BLENDFACTOR_DST_ALPHA:
      return PIPE_BLENDFACTOR_ONE;
   case PIPE_BLENDFACTOR_INV_DST_ALPHA:
      return PIPE_BLENDFACTOR_ZERO;
   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
      return PIPE_BLENDFACTOR_ZERO;
   }

   return factor;
}


/**
d1052 1
a1052 1
   memset(key, 0, shader->variant_key_size);
d1054 4
a1057 9
   if (lp->framebuffer.zsbuf) {
      if (lp->depth_stencil->depth.enabled) {
         key->zsbuf_format = lp->framebuffer.zsbuf->format;
         memcpy(&key->depth, &lp->depth_stencil->depth, sizeof key->depth);
      }
      if (lp->depth_stencil->stencil[0].enabled) {
         key->zsbuf_format = lp->framebuffer.zsbuf->format;
         memcpy(&key->stencil, &lp->depth_stencil->stencil, sizeof key->stencil);
      }
d1066 1
a1066 3
   if (lp->active_query_count) {
      key->occlusion_count = TRUE;
   }
a1073 2
      enum pipe_format format = lp->framebuffer.cbufs[i]->format;
      struct pipe_rt_blend_state *blend_rt = &key->blend.rt[i];
d1075 1
d1077 3
a1079 1
      key->cbuf_format[i] = format;
d1081 2
a1082 8
      format_desc = util_format_description(format);
      assert(format_desc->colorspace == UTIL_FORMAT_COLORSPACE_RGB ||
             format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB);

      blend_rt->colormask = lp->blend->rt[i].colormask;

      /*
       * Mask out color channels not present in the color buffer.
d1084 2
a1085 1
      blend_rt->colormask &= util_format_colormask(format_desc);
d1087 2
a1088 21
      /*
       * Our swizzled render tiles always have an alpha channel, but the linear
       * render target format often does not, so force here the dst alpha to be
       * one.
       *
       * This is not a mere optimization. Wrong results will be produced if the
       * dst alpha is used, the dst format does not have alpha, and the previous
       * rendering was not flushed from the swizzled to linear buffer. For
       * example, NonPowTwo DCT.
       *
       * TODO: This should be generalized to all channels for better
       * performance, but only alpha causes correctness issues.
       *
       * Also, force rgb/alpha func/factors match, to make AoS blending easier.
       */
      if (format_desc->swizzle[3] > UTIL_FORMAT_SWIZZLE_W) {
         blend_rt->rgb_src_factor   = force_dst_alpha_one(blend_rt->rgb_src_factor);
         blend_rt->rgb_dst_factor   = force_dst_alpha_one(blend_rt->rgb_dst_factor);
         blend_rt->alpha_func       = blend_rt->rgb_func;
         blend_rt->alpha_src_factor = blend_rt->rgb_src_factor;
         blend_rt->alpha_dst_factor = blend_rt->rgb_dst_factor;
d1092 3
a1094 11
   /* This value will be the same for all the variants of a given shader:
    */
   key->nr_samplers = shader->info.base.file_max[TGSI_FILE_SAMPLER] + 1;

   for(i = 0; i < key->nr_samplers; ++i) {
      if(shader->info.base.file_mask[TGSI_FILE_SAMPLER] & (1 << i)) {
         lp_sampler_static_state(&key->sampler[i],
				 lp->fragment_sampler_views[i],
				 lp->sampler[i]);
      }
   }
a1097 1

d1099 1
a1099 1
 * Update fragment shader state.  This is called just prior to drawing
d1107 2
a1108 2
   struct lp_fragment_shader_variant *variant = NULL;
   struct lp_fs_variant_list_item *li;
d1112 3
a1114 5
   /* Search the variants for one which matches the key */
   li = first_elem(&shader->variants);
   while(!at_end(&shader->variants, li)) {
      if(memcmp(&li->base->key, &key, shader->variant_key_size) == 0) {
         variant = li->base;
a1115 3
      }
      li = next_elem(li);
   }
d1117 1
a1117 5
   if (variant) {
      /* Move this variant to the head of the list to implement LRU
       * deletion of shader's when we have too many.
       */
      move_to_head(&lp->fs_variants_list, &variant->list_item_global);
a1118 4
   else {
      /* variant not found, create it now */
      int64_t t0, t1, dt;
      unsigned i;
d1120 4
a1123 5
      /* First, check if we've exceeded the max number of shader variants.
       * If so, free 25% of them (the least recently used ones).
       */
      if (lp->nr_fs_variants >= LP_MAX_SHADER_VARIANTS) {
         struct pipe_context *pipe = &lp->pipe;
d1125 1
a1125 6
         /*
          * XXX: we need to flush the context until we have some sort of
          * reference counting in fragment shaders as they may still be binned
          * Flushing alone might not be sufficient we need to wait on it too.
          */
         llvmpipe_finish(pipe, __FUNCTION__);
a1126 12
         for (i = 0; i < LP_MAX_SHADER_VARIANTS / 4; i++) {
            struct lp_fs_variant_list_item *item;
            item = last_elem(&lp->fs_variants_list);
            llvmpipe_remove_shader_variant(lp, item->base);
         }
      }

      /*
       * Generate the new variant.
       */
      t0 = os_time_get();
      variant = generate_variant(lp, shader, &key);
a1130 10

      llvmpipe_variant_count++;

      /* Put the new variant into the list */
      if (variant) {
         insert_at_head(&shader->variants, &variant->list_item_local);
         insert_at_head(&lp->fs_variants_list, &variant->list_item_global);
         lp->nr_fs_variants++;
         shader->variants_cached++;
      }
d1133 1
a1133 16
   /* Bind this variant */
   lp_setup_set_fs_variant(lp->setup, variant);
}







void
llvmpipe_init_fs_funcs(struct llvmpipe_context *llvmpipe)
{
   llvmpipe->pipe.create_fs_state = llvmpipe_create_fs_state;
   llvmpipe->pipe.bind_fs_state   = llvmpipe_bind_fs_state;
   llvmpipe->pipe.delete_fs_state = llvmpipe_delete_fs_state;
d1135 15
a1149 1
   llvmpipe->pipe.set_constant_buffer = llvmpipe_set_constant_buffer;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a68 1
#include "util/u_dual_blend.h"
a84 4
#include "gallivm/lp_bld_arit.h"
#include "gallivm/lp_bld_pack.h"
#include "gallivm/lp_bld_format.h"
#include "gallivm/lp_bld_quad.h"
d93 1
d99 4
a102 1
#include "lp_rast.h"
d110 2
a111 2
 * Expand the relevant bits of mask_input to a n*4-dword mask for the
 * n*four pixels in n 2x2 quads.  This will set the n*four elements of the
a112 2
 * Grouping is 01, 23 for 2 quad mode hence only 0 and 2 are valid
 * quad arguments with fs length 8.
d114 1
a114 1
 * \param first_quad  which quad(s) of the quad group to test, in [0,3]
d120 1
a120 1
                   unsigned first_quad,
d126 1
a126 1
   LLVMValueRef bits[16];
d128 1
a128 1
   int shift, i;
d134 1
a134 1
   assert(fs_type.length <= Elements(bits));
d140 1
a140 1
   switch (first_quad) {
a144 1
      assert(fs_type.length == 4);
a150 1
      assert(fs_type.length == 4);
d170 6
a175 8
   for (i = 0; i < fs_type.length / 4; i++) {
      unsigned j = 2 * (i % 2) + (i / 2) * 8;
      bits[4*i + 0] = LLVMConstInt(i32t, 1 << (j + 0), 0);
      bits[4*i + 1] = LLVMConstInt(i32t, 1 << (j + 1), 0);
      bits[4*i + 2] = LLVMConstInt(i32t, 1 << (j + 4), 0);
      bits[4*i + 3] = LLVMConstInt(i32t, 1 << (j + 5), 0);
   }
   mask = LLVMBuildAnd(builder, mask, LLVMConstVector(bits, fs_type.length), "");
d212 2
d216 16
a231 15
generate_fs_loop(struct gallivm_state *gallivm,
                 struct lp_fragment_shader *shader,
                 const struct lp_fragment_shader_variant_key *key,
                 LLVMBuilderRef builder,
                 struct lp_type type,
                 LLVMValueRef context_ptr,
                 LLVMValueRef num_loop,
                 struct lp_build_interp_soa_context *interp,
                 struct lp_build_sampler_soa *sampler,
                 LLVMValueRef mask_store,
                 LLVMValueRef (*out_color)[4],
                 LLVMValueRef depth_ptr,
                 LLVMValueRef depth_stride,
                 LLVMValueRef facing,
                 LLVMValueRef thread_data_ptr)
a235 1
   LLVMValueRef mask_ptr, mask_val;
d237 1
d239 1
a239 2
   LLVMValueRef z_value, s_value;
   LLVMValueRef z_fb, s_fb;
a240 2
   LLVMValueRef outputs[PIPE_MAX_SHADER_OUTPUTS][TGSI_NUM_CHANNELS];
   struct lp_build_for_loop_state loop_state;
a241 5
   /*
    * TODO: figure out if simple_shader optimization is really worthwile to
    * keep. Disabled because it may hide some real bugs in the (depth/stencil)
    * code since tests tend to take another codepath than real shaders.
    */
d244 1
a244 3
                            shader->info.base.num_instructions < 8) && 0;
   const boolean dual_source_blend = key->blend.rt[0].blend_enable &&
                                     util_blend_state_is_dual(&key->blend, 0);
a249 4
   struct lp_bld_tgsi_system_values system_values;

   memset(&system_values, 0, sizeof(system_values));

d251 2
a252 1
       key->stencil[0].enabled) {
d258 1
a258 1
         if (key->alpha.enabled || shader->info.base.uses_kill) {
d262 1
a262 2
             * is known. This only works though if there's either no
             * stencil test or the stencil value isn't written.
d264 1
a264 7
            if (key->stencil[0].enabled && (key->stencil[0].writemask ||
                                            (key->stencil[1].enabled &&
                                             key->stencil[1].writemask)))
               depth_mode = LATE_DEPTH_TEST | LATE_DEPTH_WRITE;
            else
               depth_mode = EARLY_DEPTH_TEST | LATE_DEPTH_WRITE;
         }
d273 1
a273 3
          !(key->stencil[0].enabled && (key->stencil[0].writemask ||
                                        (key->stencil[1].enabled &&
                                         key->stencil[1].writemask))))
d280 1
d285 1
a285 1352
   vec_type = lp_build_vec_type(gallivm, type);

   consts_ptr = lp_jit_context_constants(gallivm, context_ptr);

   lp_build_for_loop_begin(&loop_state, gallivm,
                           lp_build_const_int32(gallivm, 0),
                           LLVMIntULT,
                           num_loop,
                           lp_build_const_int32(gallivm, 1));

   mask_ptr = LLVMBuildGEP(builder, mask_store,
                           &loop_state.counter, 1, "mask_ptr");
   mask_val = LLVMBuildLoad(builder, mask_ptr, "");

   memset(outputs, 0, sizeof outputs);

   for(cbuf = 0; cbuf < key->nr_cbufs; cbuf++) {
      for(chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
         out_color[cbuf][chan] = lp_build_array_alloca(gallivm,
                                                       lp_build_vec_type(gallivm,
                                                                         type),
                                                       num_loop, "color");
      }
   }
   if (dual_source_blend) {
      assert(key->nr_cbufs <= 1);
      for(chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
         out_color[1][chan] = lp_build_array_alloca(gallivm,
                                                    lp_build_vec_type(gallivm,
                                                                      type),
                                                    num_loop, "color1");
      }
   }


   /* 'mask' will control execution based on quad's pixel alive/killed state */
   lp_build_mask_begin(&mask, gallivm, type, mask_val);

   if (!(depth_mode & EARLY_DEPTH_TEST) && !simple_shader)
      lp_build_mask_check(&mask);

   lp_build_interp_soa_update_pos_dyn(interp, gallivm, loop_state.counter);
   z = interp->pos[2];

   if (depth_mode & EARLY_DEPTH_TEST) {
      lp_build_depth_stencil_load_swizzled(gallivm, type,
                                           zs_format_desc, key->resource_1d,
                                           depth_ptr, depth_stride,
                                           &z_fb, &s_fb, loop_state.counter);
      lp_build_depth_stencil_test(gallivm,
                                  &key->depth,
                                  key->stencil,
                                  type,
                                  zs_format_desc,
                                  &mask,
                                  stencil_refs,
                                  z, z_fb, s_fb,
                                  facing,
                                  &z_value, &s_value,
                                  !simple_shader);

      if (depth_mode & EARLY_DEPTH_WRITE) {
         lp_build_depth_stencil_write_swizzled(gallivm, type,
                                               zs_format_desc, key->resource_1d,
                                               NULL, NULL, NULL, loop_state.counter,
                                               depth_ptr, depth_stride,
                                               z_value, s_value);
      }
      /*
       * Note mask check if stencil is enabled must be after ds write not after
       * stencil test otherwise new stencil values may not get written if all
       * fragments got killed by depth/stencil test.
       */
      if (!simple_shader && key->stencil[0].enabled)
         lp_build_mask_check(&mask);
   }

   lp_build_interp_soa_update_inputs_dyn(interp, gallivm, loop_state.counter);

   /* Build the actual shader */
   lp_build_tgsi_soa(gallivm, tokens, type, &mask,
                     consts_ptr, &system_values,
                     interp->inputs,
                     outputs, sampler, &shader->info.base, NULL);

   /* Alpha test */
   if (key->alpha.enabled) {
      int color0 = find_output_by_semantic(&shader->info.base,
                                           TGSI_SEMANTIC_COLOR,
                                           0);

      if (color0 != -1 && outputs[color0][3]) {
         const struct util_format_description *cbuf_format_desc;
         LLVMValueRef alpha = LLVMBuildLoad(builder, outputs[color0][3], "alpha");
         LLVMValueRef alpha_ref_value;

         alpha_ref_value = lp_jit_context_alpha_ref_value(gallivm, context_ptr);
         alpha_ref_value = lp_build_broadcast(gallivm, vec_type, alpha_ref_value);

         cbuf_format_desc = util_format_description(key->cbuf_format[0]);

         lp_build_alpha_test(gallivm, key->alpha.func, type, cbuf_format_desc,
                             &mask, alpha, alpha_ref_value,
                             (depth_mode & LATE_DEPTH_TEST) != 0);
      }
   }

   /* Late Z test */
   if (depth_mode & LATE_DEPTH_TEST) {
      int pos0 = find_output_by_semantic(&shader->info.base,
                                         TGSI_SEMANTIC_POSITION,
                                         0);

      if (pos0 != -1 && outputs[pos0][2]) {
         z = LLVMBuildLoad(builder, outputs[pos0][2], "output.z");
      }

      lp_build_depth_stencil_load_swizzled(gallivm, type,
                                           zs_format_desc, key->resource_1d,
                                           depth_ptr, depth_stride,
                                           &z_fb, &s_fb, loop_state.counter);

      lp_build_depth_stencil_test(gallivm,
                                  &key->depth,
                                  key->stencil,
                                  type,
                                  zs_format_desc,
                                  &mask,
                                  stencil_refs,
                                  z, z_fb, s_fb,
                                  facing,
                                  &z_value, &s_value,
                                  !simple_shader);
      /* Late Z write */
      if (depth_mode & LATE_DEPTH_WRITE) {
         lp_build_depth_stencil_write_swizzled(gallivm, type,
                                               zs_format_desc, key->resource_1d,
                                               NULL, NULL, NULL, loop_state.counter,
                                               depth_ptr, depth_stride,
                                               z_value, s_value);
      }
   }
   else if ((depth_mode & EARLY_DEPTH_TEST) &&
            (depth_mode & LATE_DEPTH_WRITE))
   {
      /* Need to apply a reduced mask to the depth write.  Reload the
       * depth value, update from zs_value with the new mask value and
       * write that out.
       */
      lp_build_depth_stencil_write_swizzled(gallivm, type,
                                            zs_format_desc, key->resource_1d,
                                            &mask, z_fb, s_fb, loop_state.counter,
                                            depth_ptr, depth_stride,
                                            z_value, s_value);
   }


   /* Color write  */
   for (attrib = 0; attrib < shader->info.base.num_outputs; ++attrib)
   {
      unsigned cbuf = shader->info.base.output_semantic_index[attrib];
      if ((shader->info.base.output_semantic_name[attrib] == TGSI_SEMANTIC_COLOR) &&
           ((cbuf < key->nr_cbufs) || (cbuf == 1 && dual_source_blend)))
      {
         for(chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
            if(outputs[attrib][chan]) {
               /* XXX: just initialize outputs to point at colors[] and
                * skip this.
                */
               LLVMValueRef out = LLVMBuildLoad(builder, outputs[attrib][chan], "");
               LLVMValueRef color_ptr;
               color_ptr = LLVMBuildGEP(builder, out_color[cbuf][chan],
                                        &loop_state.counter, 1, "");
               lp_build_name(out, "color%u.%c", attrib, "rgba"[chan]);
               LLVMBuildStore(builder, out, color_ptr);
            }
         }
      }
   }

   if (key->occlusion_count) {
      LLVMValueRef counter = lp_jit_thread_data_counter(gallivm, thread_data_ptr);
      lp_build_name(counter, "counter");
      lp_build_occlusion_count(gallivm, type,
                               lp_build_mask_value(&mask), counter);
   }

   mask_val = lp_build_mask_end(&mask);
   LLVMBuildStore(builder, mask_val, mask_ptr);
   lp_build_for_loop_end(&loop_state);
}


/**
 * This function will reorder pixels from the fragment shader SoA to memory layout AoS
 *
 * Fragment Shader outputs pixels in small 2x2 blocks
 *  e.g. (0, 0), (1, 0), (0, 1), (1, 1) ; (2, 0) ...
 *
 * However in memory pixels are stored in rows
 *  e.g. (0, 0), (1, 0), (2, 0), (3, 0) ; (0, 1) ...
 *
 * @@param type            fragment shader type (4x or 8x float)
 * @@param num_fs          number of fs_src
 * @@param is_1d           whether we're outputting to a 1d resource
 * @@param dst_channels    number of output channels
 * @@param fs_src          output from fragment shader
 * @@param dst             pointer to store result
 * @@param pad_inline      is channel padding inline or at end of row
 * @@return                the number of dsts
 */
static int
generate_fs_twiddle(struct gallivm_state *gallivm,
                    struct lp_type type,
                    unsigned num_fs,
                    unsigned dst_channels,
                    LLVMValueRef fs_src[][4],
                    LLVMValueRef* dst,
                    bool pad_inline)
{
   LLVMValueRef src[16];

   bool swizzle_pad;
   bool twiddle;
   bool split;

   unsigned pixels = type.length / 4;
   unsigned reorder_group;
   unsigned src_channels;
   unsigned src_count;
   unsigned i;

   src_channels = dst_channels < 3 ? dst_channels : 4;
   src_count = num_fs * src_channels;

   assert(pixels == 2 || pixels == 1);
   assert(num_fs * src_channels <= Elements(src));

   /*
    * Transpose from SoA -> AoS
    */
   for (i = 0; i < num_fs; ++i) {
      lp_build_transpose_aos_n(gallivm, type, &fs_src[i][0], src_channels, &src[i * src_channels]);
   }

   /*
    * Pick transformation options
    */
   swizzle_pad = false;
   twiddle = false;
   split = false;
   reorder_group = 0;

   if (dst_channels == 1) {
      twiddle = true;

      if (pixels == 2) {
         split = true;
      }
   } else if (dst_channels == 2) {
      if (pixels == 1) {
         reorder_group = 1;
      }
   } else if (dst_channels > 2) {
      if (pixels == 1) {
         reorder_group = 2;
      } else {
         twiddle = true;
      }

      if (!pad_inline && dst_channels == 3 && pixels > 1) {
         swizzle_pad = true;
      }
   }

   /*
    * Split the src in half
    */
   if (split) {
      for (i = num_fs; i > 0; --i) {
         src[(i - 1)*2 + 1] = lp_build_extract_range(gallivm, src[i - 1], 4, 4);
         src[(i - 1)*2 + 0] = lp_build_extract_range(gallivm, src[i - 1], 0, 4);
      }

      src_count *= 2;
      type.length = 4;
   }

   /*
    * Ensure pixels are in memory order
    */
   if (reorder_group) {
      /* Twiddle pixels by reordering the array, e.g.:
       *
       * src_count =  8 -> 0 2 1 3 4 6 5 7
       * src_count = 16 -> 0 1 4 5 2 3 6 7 8 9 12 13 10 11 14 15
       */
      const unsigned reorder_sw[] = { 0, 2, 1, 3 };

      for (i = 0; i < src_count; ++i) {
         unsigned group = i / reorder_group;
         unsigned block = (group / 4) * 4 * reorder_group;
         unsigned j = block + (reorder_sw[group % 4] * reorder_group) + (i % reorder_group);
         dst[i] = src[j];
      }
   } else if (twiddle) {
      /* Twiddle pixels across elements of array */
      lp_bld_quad_twiddle(gallivm, type, src, src_count, dst);
   } else {
      /* Do nothing */
      memcpy(dst, src, sizeof(LLVMValueRef) * src_count);
   }

   /*
    * Moves any padding between pixels to the end
    * e.g. RGBXRGBX -> RGBRGBXX
    */
   if (swizzle_pad) {
      unsigned char swizzles[16];
      unsigned elems = pixels * dst_channels;

      for (i = 0; i < type.length; ++i) {
         if (i < elems)
            swizzles[i] = i % dst_channels + (i / dst_channels) * 4;
         else
            swizzles[i] = LP_BLD_SWIZZLE_DONTCARE;
      }

      for (i = 0; i < src_count; ++i) {
         dst[i] = lp_build_swizzle_aos_n(gallivm, dst[i], swizzles, type.length, type.length);
      }
   }

   return src_count;
}


/**
 * Load an unswizzled block of pixels from memory
 */
static void
load_unswizzled_block(struct gallivm_state *gallivm,
                      LLVMValueRef base_ptr,
                      LLVMValueRef stride,
                      unsigned block_width,
                      unsigned block_height,
                      LLVMValueRef* dst,
                      struct lp_type dst_type,
                      unsigned dst_count,
                      unsigned dst_alignment)
{
   LLVMBuilderRef builder = gallivm->builder;
   unsigned row_size = dst_count / block_height;
   unsigned i;

   /* Ensure block exactly fits into dst */
   assert((block_width * block_height) % dst_count == 0);

   for (i = 0; i < dst_count; ++i) {
      unsigned x = i % row_size;
      unsigned y = i / row_size;

      LLVMValueRef bx = lp_build_const_int32(gallivm, x * (dst_type.width / 8) * dst_type.length);
      LLVMValueRef by = LLVMBuildMul(builder, lp_build_const_int32(gallivm, y), stride, "");

      LLVMValueRef gep[2];
      LLVMValueRef dst_ptr;

      gep[0] = lp_build_const_int32(gallivm, 0);
      gep[1] = LLVMBuildAdd(builder, bx, by, "");

      dst_ptr = LLVMBuildGEP(builder, base_ptr, gep, 2, "");
      dst_ptr = LLVMBuildBitCast(builder, dst_ptr, LLVMPointerType(lp_build_vec_type(gallivm, dst_type), 0), "");

      dst[i] = LLVMBuildLoad(builder, dst_ptr, "");

      lp_set_load_alignment(dst[i], dst_alignment);
   }
}


/**
 * Store an unswizzled block of pixels to memory
 */
static void
store_unswizzled_block(struct gallivm_state *gallivm,
                       LLVMValueRef base_ptr,
                       LLVMValueRef stride,
                       unsigned block_width,
                       unsigned block_height,
                       LLVMValueRef* src,
                       struct lp_type src_type,
                       unsigned src_count,
                       unsigned src_alignment)
{
   LLVMBuilderRef builder = gallivm->builder;
   unsigned row_size = src_count / block_height;
   unsigned i;

   /* Ensure src exactly fits into block */
   assert((block_width * block_height) % src_count == 0);

   for (i = 0; i < src_count; ++i) {
      unsigned x = i % row_size;
      unsigned y = i / row_size;

      LLVMValueRef bx = lp_build_const_int32(gallivm, x * (src_type.width / 8) * src_type.length);
      LLVMValueRef by = LLVMBuildMul(builder, lp_build_const_int32(gallivm, y), stride, "");

      LLVMValueRef gep[2];
      LLVMValueRef src_ptr;

      gep[0] = lp_build_const_int32(gallivm, 0);
      gep[1] = LLVMBuildAdd(builder, bx, by, "");

      src_ptr = LLVMBuildGEP(builder, base_ptr, gep, 2, "");
      src_ptr = LLVMBuildBitCast(builder, src_ptr, LLVMPointerType(lp_build_vec_type(gallivm, src_type), 0), "");

      src_ptr = LLVMBuildStore(builder, src[i], src_ptr);

      lp_set_store_alignment(src_ptr, src_alignment);
   }
}


/**
 * Checks if a format description is an arithmetic format
 *
 * A format which has irregular channel sizes such as R3_G3_B2 or R5_G6_B5.
 */
static INLINE boolean
is_arithmetic_format(const struct util_format_description *format_desc)
{
   boolean arith = false;
   unsigned i;

   for (i = 0; i < format_desc->nr_channels; ++i) {
      arith |= format_desc->channel[i].size != format_desc->channel[0].size;
      arith |= (format_desc->channel[i].size % 8) != 0;
   }

   return arith;
}


/**
 * Checks if this format requires special handling due to required expansion
 * to floats for blending, and furthermore has "natural" packed AoS -> unpacked
 * SoA conversion.
 */
static INLINE boolean
format_expands_to_float_soa(const struct util_format_description *format_desc)
{
   if (format_desc->format == PIPE_FORMAT_R11G11B10_FLOAT ||
       format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
      return true;
   }
   return false;
}


/**
 * Retrieves the type representing the memory layout for a format
 *
 * e.g. RGBA16F = 4x half-float and R3G3B2 = 1x byte
 */
static INLINE void
lp_mem_type_from_format_desc(const struct util_format_description *format_desc,
                             struct lp_type* type)
{
   unsigned i;
   unsigned chan;

   if (format_expands_to_float_soa(format_desc)) {
      /* just make this a 32bit uint */
      type->floating = false;
      type->fixed = false;
      type->sign = false;
      type->norm = false;
      type->width = 32;
      type->length = 1;
      return;
   }

   for (i = 0; i < 4; i++)
      if (format_desc->channel[i].type != UTIL_FORMAT_TYPE_VOID)
         break;
   chan = i;

   memset(type, 0, sizeof(struct lp_type));
   type->floating = format_desc->channel[chan].type == UTIL_FORMAT_TYPE_FLOAT;
   type->fixed    = format_desc->channel[chan].type == UTIL_FORMAT_TYPE_FIXED;
   type->sign     = format_desc->channel[chan].type != UTIL_FORMAT_TYPE_UNSIGNED;
   type->norm     = format_desc->channel[chan].normalized;

   if (is_arithmetic_format(format_desc)) {
      type->width = 0;
      type->length = 1;

      for (i = 0; i < format_desc->nr_channels; ++i) {
         type->width += format_desc->channel[i].size;
      }
   } else {
      type->width = format_desc->channel[chan].size;
      type->length = format_desc->nr_channels;
   }
}


/**
 * Retrieves the type for a format which is usable in the blending code.
 *
 * e.g. RGBA16F = 4x float, R3G3B2 = 3x byte
 */
static INLINE void
lp_blend_type_from_format_desc(const struct util_format_description *format_desc,
                               struct lp_type* type)
{
   unsigned i;
   unsigned chan;

   if (format_expands_to_float_soa(format_desc)) {
      /* always use ordinary floats for blending */
      type->floating = true;
      type->fixed = false;
      type->sign = true;
      type->norm = false;
      type->width = 32;
      type->length = 4;
      return;
   }

   for (i = 0; i < 4; i++)
      if (format_desc->channel[i].type != UTIL_FORMAT_TYPE_VOID)
         break;
   chan = i;

   memset(type, 0, sizeof(struct lp_type));
   type->floating = format_desc->channel[chan].type == UTIL_FORMAT_TYPE_FLOAT;
   type->fixed    = format_desc->channel[chan].type == UTIL_FORMAT_TYPE_FIXED;
   type->sign     = format_desc->channel[chan].type != UTIL_FORMAT_TYPE_UNSIGNED;
   type->norm     = format_desc->channel[chan].normalized;
   type->width    = format_desc->channel[chan].size;
   type->length   = format_desc->nr_channels;

   for (i = 1; i < format_desc->nr_channels; ++i) {
      if (format_desc->channel[i].size > type->width)
         type->width = format_desc->channel[i].size;
   }

   if (type->floating) {
      type->width = 32;
   } else {
      if (type->width <= 8) {
         type->width = 8;
      } else if (type->width <= 16) {
         type->width = 16;
      } else {
         type->width = 32;
      }
   }

   if (is_arithmetic_format(format_desc) && type->length == 3) {
      type->length = 4;
   }
}


/**
 * Scale a normalized value from src_bits to dst_bits
 */
static INLINE LLVMValueRef
scale_bits(struct gallivm_state *gallivm,
           int src_bits,
           int dst_bits,
           LLVMValueRef src,
           struct lp_type src_type)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef result = src;

   if (dst_bits < src_bits) {
      /* Scale down by LShr */
      result = LLVMBuildLShr(builder,
                             src,
                             lp_build_const_int_vec(gallivm, src_type, src_bits - dst_bits),
                             "");
   } else if (dst_bits > src_bits) {
      /* Scale up bits */
      int db = dst_bits - src_bits;

      /* Shift left by difference in bits */
      result = LLVMBuildShl(builder,
                            src,
                            lp_build_const_int_vec(gallivm, src_type, db),
                            "");

      if (db < src_bits) {
         /* Enough bits in src to fill the remainder */
         LLVMValueRef lower = LLVMBuildLShr(builder,
                                            src,
                                            lp_build_const_int_vec(gallivm, src_type, src_bits - db),
                                            "");

         result = LLVMBuildOr(builder, result, lower, "");
      } else if (db > src_bits) {
         /* Need to repeatedly copy src bits to fill remainder in dst */
         unsigned n;

         for (n = src_bits; n < dst_bits; n *= 2) {
            LLVMValueRef shuv = lp_build_const_int_vec(gallivm, src_type, n);

            result = LLVMBuildOr(builder,
                                 result,
                                 LLVMBuildLShr(builder, result, shuv, ""),
                                 "");
         }
      }
   }

   return result;
}


/**
 * Convert from memory format to blending format
 *
 * e.g. GL_R3G3B2 is 1 byte in memory but 3 bytes for blending
 */
static void
convert_to_blend_type(struct gallivm_state *gallivm,
                      unsigned block_size,
                      const struct util_format_description *src_fmt,
                      struct lp_type src_type,
                      struct lp_type dst_type,
                      LLVMValueRef* src, // and dst
                      unsigned num_srcs)
{
   LLVMValueRef *dst = src;
   LLVMBuilderRef builder = gallivm->builder;
   struct lp_type blend_type;
   struct lp_type mem_type;
   unsigned i, j, k;
   unsigned pixels = block_size / num_srcs;
   bool is_arith;

   /*
    * full custom path for packed floats and srgb formats - none of the later
    * functions would do anything useful, and given the lp_type representation they
    * can't be fixed. Should really have some SoA blend path for these kind of
    * formats rather than hacking them in here.
    */
   if (format_expands_to_float_soa(src_fmt)) {
      LLVMValueRef tmpsrc[4];
      /*
       * This is pretty suboptimal for this case blending in SoA would be much
       * better, since conversion gets us SoA values so need to convert back.
       */
      assert(src_type.width == 32);
      assert(dst_type.floating);
      assert(dst_type.width == 32);
      assert(dst_type.length % 4 == 0);
      assert(num_srcs % 4 == 0);

      for (i = 0; i < 4; i++) {
         tmpsrc[i] = src[i];
      }
      for (i = 0; i < num_srcs / 4; i++) {
         LLVMValueRef tmpsoa[4];
         LLVMValueRef tmps = tmpsrc[i];
         if (dst_type.length == 8) {
            LLVMValueRef shuffles[8];
            unsigned j;
            /* fetch was 4 values but need 8-wide output values */
            tmps = lp_build_concat(gallivm, &tmpsrc[i * 2], src_type, 2);
            /*
             * for 8-wide aos transpose would give us wrong order not matching
             * incoming converted fs values and mask. ARGH.
             */
            for (j = 0; j < 4; j++) {
               shuffles[j] = lp_build_const_int32(gallivm, j * 2);
               shuffles[j + 4] = lp_build_const_int32(gallivm, j * 2 + 1);
            }
            tmps = LLVMBuildShuffleVector(builder, tmps, tmps,
                                          LLVMConstVector(shuffles, 8), "");
         }
         if (src_fmt->format == PIPE_FORMAT_R11G11B10_FLOAT) {
            lp_build_r11g11b10_to_float(gallivm, tmps, tmpsoa);
         }
         else {
            lp_build_unpack_rgba_soa(gallivm, src_fmt, dst_type, tmps, tmpsoa);
         }
         lp_build_transpose_aos(gallivm, dst_type, tmpsoa, &src[i * 4]);
      }
      return;
   }

   lp_mem_type_from_format_desc(src_fmt, &mem_type);
   lp_blend_type_from_format_desc(src_fmt, &blend_type);

   /* Is the format arithmetic */
   is_arith = blend_type.length * blend_type.width != mem_type.width * mem_type.length;
   is_arith &= !(mem_type.width == 16 && mem_type.floating);

   /* Pad if necessary */
   if (!is_arith && src_type.length < dst_type.length) {
      for (i = 0; i < num_srcs; ++i) {
         dst[i] = lp_build_pad_vector(gallivm, src[i], dst_type.length);
      }

      src_type.length = dst_type.length;
   }

   /* Special case for half-floats */
   if (mem_type.width == 16 && mem_type.floating) {
      assert(blend_type.width == 32 && blend_type.floating);
      lp_build_conv_auto(gallivm, src_type, &dst_type, dst, num_srcs, dst);
      is_arith = false;
   }

   if (!is_arith) {
      return;
   }

   src_type.width = blend_type.width * blend_type.length;
   blend_type.length *= pixels;
   src_type.length *= pixels / (src_type.length / mem_type.length);

   for (i = 0; i < num_srcs; ++i) {
      LLVMValueRef chans[4];
      LLVMValueRef res = NULL;

      dst[i] = LLVMBuildZExt(builder, src[i], lp_build_vec_type(gallivm, src_type), "");

      for (j = 0; j < src_fmt->nr_channels; ++j) {
         unsigned mask = 0;
         unsigned sa = src_fmt->channel[j].shift;
#ifdef PIPE_ARCH_LITTLE_ENDIAN
         unsigned from_lsb = j;
#else
         unsigned from_lsb = src_fmt->nr_channels - j - 1;
#endif

         for (k = 0; k < src_fmt->channel[j].size; ++k) {
            mask |= 1 << k;
         }

         /* Extract bits from source */
         chans[j] = LLVMBuildLShr(builder,
                                  dst[i],
                                  lp_build_const_int_vec(gallivm, src_type, sa),
                                  "");

         chans[j] = LLVMBuildAnd(builder,
                                 chans[j],
                                 lp_build_const_int_vec(gallivm, src_type, mask),
                                 "");

         /* Scale bits */
         if (src_type.norm) {
            chans[j] = scale_bits(gallivm, src_fmt->channel[j].size,
                                  blend_type.width, chans[j], src_type);
         }

         /* Insert bits into correct position */
         chans[j] = LLVMBuildShl(builder,
                                 chans[j],
                                 lp_build_const_int_vec(gallivm, src_type, from_lsb * blend_type.width),
                                 "");

         if (j == 0) {
            res = chans[j];
         } else {
            res = LLVMBuildOr(builder, res, chans[j], "");
         }
      }

      dst[i] = LLVMBuildBitCast(builder, res, lp_build_vec_type(gallivm, blend_type), "");
   }
}


/**
 * Convert from blending format to memory format
 *
 * e.g. GL_R3G3B2 is 3 bytes for blending but 1 byte in memory
 */
static void
convert_from_blend_type(struct gallivm_state *gallivm,
                        unsigned block_size,
                        const struct util_format_description *src_fmt,
                        struct lp_type src_type,
                        struct lp_type dst_type,
                        LLVMValueRef* src, // and dst
                        unsigned num_srcs)
{
   LLVMValueRef* dst = src;
   unsigned i, j, k;
   struct lp_type mem_type;
   struct lp_type blend_type;
   LLVMBuilderRef builder = gallivm->builder;
   unsigned pixels = block_size / num_srcs;
   bool is_arith;

   /*
    * full custom path for packed floats and srgb formats - none of the later
    * functions would do anything useful, and given the lp_type representation they
    * can't be fixed. Should really have some SoA blend path for these kind of
    * formats rather than hacking them in here.
    */
   if (format_expands_to_float_soa(src_fmt)) {
      /*
       * This is pretty suboptimal for this case blending in SoA would be much
       * better - we need to transpose the AoS values back to SoA values for
       * conversion/packing.
       */
      assert(src_type.floating);
      assert(src_type.width == 32);
      assert(src_type.length % 4 == 0);
      assert(dst_type.width == 32);

      for (i = 0; i < num_srcs / 4; i++) {
         LLVMValueRef tmpsoa[4], tmpdst;
         lp_build_transpose_aos(gallivm, src_type, &src[i * 4], tmpsoa);
         /* really really need SoA here */

         if (src_fmt->format == PIPE_FORMAT_R11G11B10_FLOAT) {
            tmpdst = lp_build_float_to_r11g11b10(gallivm, tmpsoa);
         }
         else {
            tmpdst = lp_build_float_to_srgb_packed(gallivm, src_fmt,
                                                   src_type, tmpsoa);
         }

         if (src_type.length == 8) {
            LLVMValueRef tmpaos, shuffles[8];
            unsigned j;
            /*
             * for 8-wide aos transpose has given us wrong order not matching
             * output order. HMPF. Also need to split the output values manually.
             */
            for (j = 0; j < 4; j++) {
               shuffles[j * 2] = lp_build_const_int32(gallivm, j);
               shuffles[j * 2 + 1] = lp_build_const_int32(gallivm, j + 4);
            }
            tmpaos = LLVMBuildShuffleVector(builder, tmpdst, tmpdst,
                                            LLVMConstVector(shuffles, 8), "");
            src[i * 2] = lp_build_extract_range(gallivm, tmpaos, 0, 4);
            src[i * 2 + 1] = lp_build_extract_range(gallivm, tmpaos, 4, 4);
         }
         else {
            src[i] = tmpdst;
         }
      }
      return;
   }

   lp_mem_type_from_format_desc(src_fmt, &mem_type);
   lp_blend_type_from_format_desc(src_fmt, &blend_type);

   is_arith = (blend_type.length * blend_type.width != mem_type.width * mem_type.length);

   /* Special case for half-floats */
   if (mem_type.width == 16 && mem_type.floating) {
      int length = dst_type.length;
      assert(blend_type.width == 32 && blend_type.floating);

      dst_type.length = src_type.length;

      lp_build_conv_auto(gallivm, src_type, &dst_type, dst, num_srcs, dst);

      dst_type.length = length;
      is_arith = false;
   }

   /* Remove any padding */
   if (!is_arith && (src_type.length % mem_type.length)) {
      src_type.length -= (src_type.length % mem_type.length);

      for (i = 0; i < num_srcs; ++i) {
         dst[i] = lp_build_extract_range(gallivm, dst[i], 0, src_type.length);
      }
   }

   /* No bit arithmetic to do */
   if (!is_arith) {
      return;
   }

   src_type.length = pixels;
   src_type.width = blend_type.length * blend_type.width;
   dst_type.length = pixels;

   for (i = 0; i < num_srcs; ++i) {
      LLVMValueRef chans[4];
      LLVMValueRef res = NULL;

      dst[i] = LLVMBuildBitCast(builder, src[i], lp_build_vec_type(gallivm, src_type), "");

      for (j = 0; j < src_fmt->nr_channels; ++j) {
         unsigned mask = 0;
         unsigned sa = src_fmt->channel[j].shift;
#ifdef PIPE_ARCH_LITTLE_ENDIAN
         unsigned from_lsb = j;
#else
         unsigned from_lsb = src_fmt->nr_channels - j - 1;
#endif

         assert(blend_type.width > src_fmt->channel[j].size);

         for (k = 0; k < blend_type.width; ++k) {
            mask |= 1 << k;
         }

         /* Extract bits */
         chans[j] = LLVMBuildLShr(builder,
                                  dst[i],
                                  lp_build_const_int_vec(gallivm, src_type, from_lsb * blend_type.width),
                                  "");

         chans[j] = LLVMBuildAnd(builder,
                                 chans[j],
                                 lp_build_const_int_vec(gallivm, src_type, mask),
                                 "");

         /* Scale down bits */
         if (src_type.norm) {
            chans[j] = scale_bits(gallivm, blend_type.width,
                                  src_fmt->channel[j].size, chans[j], src_type);
         }

         /* Insert bits */
         chans[j] = LLVMBuildShl(builder,
                                 chans[j],
                                 lp_build_const_int_vec(gallivm, src_type, sa),
                                 "");

         sa += src_fmt->channel[j].size;

         if (j == 0) {
            res = chans[j];
         } else {
            res = LLVMBuildOr(builder, res, chans[j], "");
         }
      }

      assert (dst_type.width != 24);

      dst[i] = LLVMBuildTrunc(builder, res, lp_build_vec_type(gallivm, dst_type), "");
   }
}


/**
 * Convert alpha to same blend type as src
 */
static void
convert_alpha(struct gallivm_state *gallivm,
              struct lp_type row_type,
              struct lp_type alpha_type,
              const unsigned block_size,
              const unsigned block_height,
              const unsigned src_count,
              const unsigned dst_channels,
              const bool pad_inline,
              LLVMValueRef* src_alpha)
{
   LLVMBuilderRef builder = gallivm->builder;
   unsigned i, j;
   unsigned length = row_type.length;
   row_type.length = alpha_type.length;

   /* Twiddle the alpha to match pixels */
   lp_bld_quad_twiddle(gallivm, alpha_type, src_alpha, block_height, src_alpha);

   /*
    * TODO this should use single lp_build_conv call for
    * src_count == 1 && dst_channels == 1 case (dropping the concat below)
    */
   for (i = 0; i < block_height; ++i) {
      lp_build_conv(gallivm, alpha_type, row_type, &src_alpha[i], 1, &src_alpha[i], 1);
   }

   alpha_type = row_type;
   row_type.length = length;

   /* If only one channel we can only need the single alpha value per pixel */
   if (src_count == 1 && dst_channels == 1) {

      lp_build_concat_n(gallivm, alpha_type, src_alpha, block_height, src_alpha, src_count);
   } else {
      /* If there are more srcs than rows then we need to split alpha up */
      if (src_count > block_height) {
         for (i = src_count; i > 0; --i) {
            unsigned pixels = block_size / src_count;
            unsigned idx = i - 1;

            src_alpha[idx] = lp_build_extract_range(gallivm, src_alpha[(idx * pixels) / 4],
                                                    (idx * pixels) % 4, pixels);
         }
      }

      /* If there is a src for each pixel broadcast the alpha across whole row */
      if (src_count == block_size) {
         for (i = 0; i < src_count; ++i) {
            src_alpha[i] = lp_build_broadcast(gallivm, lp_build_vec_type(gallivm, row_type), src_alpha[i]);
         }
      } else {
         unsigned pixels = block_size / src_count;
         unsigned channels = pad_inline ? TGSI_NUM_CHANNELS : dst_channels;
         unsigned alpha_span = 1;
         LLVMValueRef shuffles[LP_MAX_VECTOR_LENGTH];

         /* Check if we need 2 src_alphas for our shuffles */
         if (pixels > alpha_type.length) {
            alpha_span = 2;
         }

         /* Broadcast alpha across all channels, e.g. a1a2 to a1a1a1a1a2a2a2a2 */
         for (j = 0; j < row_type.length; ++j) {
            if (j < pixels * channels) {
               shuffles[j] = lp_build_const_int32(gallivm, j / channels);
            } else {
               shuffles[j] = LLVMGetUndef(LLVMInt32TypeInContext(gallivm->context));
            }
         }

         for (i = 0; i < src_count; ++i) {
            unsigned idx1 = i, idx2 = i;

            if (alpha_span > 1){
               idx1 *= alpha_span;
               idx2 = idx1 + 1;
            }

            src_alpha[i] = LLVMBuildShuffleVector(builder,
                                                  src_alpha[idx1],
                                                  src_alpha[idx2],
                                                  LLVMConstVector(shuffles, row_type.length),
                                                  "");
         }
      }
   }
}


/**
 * Generates the blend function for unswizzled colour buffers
 * Also generates the read & write from colour buffer
 */
static void
generate_unswizzled_blend(struct gallivm_state *gallivm,
                          unsigned rt,
                          struct lp_fragment_shader_variant *variant,
                          enum pipe_format out_format,
                          unsigned int num_fs,
                          struct lp_type fs_type,
                          LLVMValueRef* fs_mask,
                          LLVMValueRef fs_out_color[PIPE_MAX_COLOR_BUFS][TGSI_NUM_CHANNELS][4],
                          LLVMValueRef context_ptr,
                          LLVMValueRef color_ptr,
                          LLVMValueRef stride,
                          unsigned partial_mask,
                          boolean do_branch)
{
   const unsigned alpha_channel = 3;
   const unsigned block_width = LP_RASTER_BLOCK_SIZE;
   const unsigned block_height = LP_RASTER_BLOCK_SIZE;
   const unsigned block_size = block_width * block_height;
   const unsigned lp_integer_vector_width = 128;

   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef fs_src[4][TGSI_NUM_CHANNELS];
   LLVMValueRef fs_src1[4][TGSI_NUM_CHANNELS];
   LLVMValueRef src_alpha[4 * 4];
   LLVMValueRef src1_alpha[4 * 4];
   LLVMValueRef src_mask[4 * 4];
   LLVMValueRef src[4 * 4];
   LLVMValueRef src1[4 * 4];
   LLVMValueRef dst[4 * 4];
   LLVMValueRef blend_color;
   LLVMValueRef blend_alpha;
   LLVMValueRef i32_zero;
   LLVMValueRef check_mask;
   LLVMValueRef undef_src_val;

   struct lp_build_mask_context mask_ctx;
   struct lp_type mask_type;
   struct lp_type blend_type;
   struct lp_type row_type;
   struct lp_type dst_type;

   unsigned char swizzle[TGSI_NUM_CHANNELS];
   unsigned vector_width;
   unsigned src_channels = TGSI_NUM_CHANNELS;
   unsigned dst_channels;
   unsigned dst_count;
   unsigned src_count;
   unsigned i, j;

   const struct util_format_description* out_format_desc = util_format_description(out_format);

   unsigned dst_alignment;

   bool pad_inline = is_arithmetic_format(out_format_desc);
   bool has_alpha = false;
   const boolean dual_source_blend = variant->key.blend.rt[0].blend_enable &&
                                     util_blend_state_is_dual(&variant->key.blend, 0);

   const boolean is_1d = variant->key.resource_1d;
   unsigned num_fullblock_fs = is_1d ? 2 * num_fs : num_fs;

   mask_type = lp_int32_vec4_type();
   mask_type.length = fs_type.length;

   for (i = num_fs; i < num_fullblock_fs; i++) {
      fs_mask[i] = lp_build_zero(gallivm, mask_type);
   }

   /* Do not bother executing code when mask is empty.. */
   if (do_branch) {
      check_mask = LLVMConstNull(lp_build_int_vec_type(gallivm, mask_type));

      for (i = 0; i < num_fullblock_fs; ++i) {
         check_mask = LLVMBuildOr(builder, check_mask, fs_mask[i], "");
      }

      lp_build_mask_begin(&mask_ctx, gallivm, mask_type, check_mask);
      lp_build_mask_check(&mask_ctx);
   }

   partial_mask |= !variant->opaque;
   i32_zero = lp_build_const_int32(gallivm, 0);

#if HAVE_LLVM < 0x0302
   /*
    * undef triggers a crash in LLVMBuildTrunc in convert_from_blend_type in some
    * cases (seen with r10g10b10a2, 128bit wide vectors) (only used for 1d case).
    */
   undef_src_val = lp_build_zero(gallivm, fs_type);
#else
   undef_src_val = lp_build_undef(gallivm, fs_type);
#endif


   /* Get type from output format */
   lp_blend_type_from_format_desc(out_format_desc, &row_type);
   lp_mem_type_from_format_desc(out_format_desc, &dst_type);

   row_type.length = fs_type.length;
   vector_width    = dst_type.floating ? lp_native_vector_width : lp_integer_vector_width;

   /* Compute correct swizzle and count channels */
   memset(swizzle, LP_BLD_SWIZZLE_DONTCARE, TGSI_NUM_CHANNELS);
   dst_channels = 0;

   for (i = 0; i < TGSI_NUM_CHANNELS; ++i) {
      /* Ensure channel is used */
      if (out_format_desc->swizzle[i] >= TGSI_NUM_CHANNELS) {
         continue;
      }

      /* Ensure not already written to (happens in case with GL_ALPHA) */
      if (swizzle[out_format_desc->swizzle[i]] < TGSI_NUM_CHANNELS) {
         continue;
      }

      /* Ensure we havn't already found all channels */
      if (dst_channels >= out_format_desc->nr_channels) {
         continue;
      }

      swizzle[out_format_desc->swizzle[i]] = i;
      ++dst_channels;

      if (i == alpha_channel) {
         has_alpha = true;
      }
   }

   if (format_expands_to_float_soa(out_format_desc)) {
      /*
       * the code above can't work for layout_other
       * for srgb it would sort of work but we short-circuit swizzles, etc.
       * as that is done as part of unpack / pack.
       */
      dst_channels = 4; /* HACK: this is fake 4 really but need it due to transpose stuff later */
      has_alpha = true;
      swizzle[0] = 0;
      swizzle[1] = 1;
      swizzle[2] = 2;
      swizzle[3] = 3;
      pad_inline = true; /* HACK: prevent rgbxrgbx->rgbrgbxx conversion later */
   }

   /* If 3 channels then pad to include alpha for 4 element transpose */
   if (dst_channels == 3 && !has_alpha) {
      for (i = 0; i < TGSI_NUM_CHANNELS; i++) {
         if (swizzle[i] > TGSI_NUM_CHANNELS)
            swizzle[i] = 3;
      }
      if (out_format_desc->nr_channels == 4) {
         dst_channels = 4;
      }
   }

   /*
    * Load shader output
    */
   for (i = 0; i < num_fullblock_fs; ++i) {
      /* Always load alpha for use in blending */
      LLVMValueRef alpha;
      if (i < num_fs) {
         alpha = LLVMBuildLoad(builder, fs_out_color[rt][alpha_channel][i], "");
      }
      else {
         alpha = undef_src_val;
      }

      /* Load each channel */
      for (j = 0; j < dst_channels; ++j) {
         assert(swizzle[j] < 4);
         if (i < num_fs) {
            fs_src[i][j] = LLVMBuildLoad(builder, fs_out_color[rt][swizzle[j]][i], "");
         }
         else {
            fs_src[i][j] = undef_src_val;
         }
      }

      /* If 3 channels then pad to include alpha for 4 element transpose */
      /*
       * XXX If we include that here maybe could actually use it instead of
       * separate alpha for blending?
       */
      if (dst_channels == 3 && !has_alpha) {
         fs_src[i][3] = alpha;
      }

      /* We split the row_mask and row_alpha as we want 128bit interleave */
      if (fs_type.length == 8) {
         src_mask[i*2 + 0]  = lp_build_extract_range(gallivm, fs_mask[i], 0, src_channels);
         src_mask[i*2 + 1]  = lp_build_extract_range(gallivm, fs_mask[i], src_channels, src_channels);

         src_alpha[i*2 + 0] = lp_build_extract_range(gallivm, alpha, 0, src_channels);
         src_alpha[i*2 + 1] = lp_build_extract_range(gallivm, alpha, src_channels, src_channels);
      } else {
         src_mask[i] = fs_mask[i];
         src_alpha[i] = alpha;
      }
   }
   if (dual_source_blend) {
      /* same as above except different src/dst, skip masks and comments... */
      for (i = 0; i < num_fullblock_fs; ++i) {
         LLVMValueRef alpha;
         if (i < num_fs) {
            alpha = LLVMBuildLoad(builder, fs_out_color[1][alpha_channel][i], "");
         }
         else {
            alpha = undef_src_val;
         }

         for (j = 0; j < dst_channels; ++j) {
            assert(swizzle[j] < 4);
            if (i < num_fs) {
               fs_src1[i][j] = LLVMBuildLoad(builder, fs_out_color[1][swizzle[j]][i], "");
            }
            else {
               fs_src1[i][j] = undef_src_val;
            }
         }
         if (dst_channels == 3 && !has_alpha) {
            fs_src1[i][3] = alpha;
         }
         if (fs_type.length == 8) {
            src1_alpha[i*2 + 0] = lp_build_extract_range(gallivm, alpha, 0, src_channels);
            src1_alpha[i*2 + 1] = lp_build_extract_range(gallivm, alpha, src_channels, src_channels);
         } else {
            src1_alpha[i] = alpha;
         }
      }
   }

   if (util_format_is_pure_integer(out_format)) {
      /*
       * In this case fs_type was really ints or uints disguised as floats,
       * fix that up now.
       */
      fs_type.floating = 0;
      fs_type.sign = dst_type.sign;
      for (i = 0; i < num_fullblock_fs; ++i) {
         for (j = 0; j < dst_channels; ++j) {
            fs_src[i][j] = LLVMBuildBitCast(builder, fs_src[i][j],
                                            lp_build_vec_type(gallivm, fs_type), "");
         }
         if (dst_channels == 3 && !has_alpha) {
            fs_src[i][3] = LLVMBuildBitCast(builder, fs_src[i][3],
                                            lp_build_vec_type(gallivm, fs_type), "");
         }
      }
   }

   /*
    * Pixel twiddle from fragment shader order to memory order
    */
   src_count = generate_fs_twiddle(gallivm, fs_type, num_fullblock_fs,
                                   dst_channels, fs_src, src, pad_inline);
   if (dual_source_blend) {
      generate_fs_twiddle(gallivm, fs_type, num_fullblock_fs, dst_channels,
                          fs_src1, src1, pad_inline);
   }

   src_channels = dst_channels < 3 ? dst_channels : 4;
   if (src_count != num_fullblock_fs * src_channels) {
      unsigned ds = src_count / (num_fullblock_fs * src_channels);
      row_type.length /= ds;
      fs_type.length = row_type.length;
   }

   blend_type = row_type;
   mask_type.length = 4;

   /* Convert src to row_type */
   if (dual_source_blend) {
      struct lp_type old_row_type = row_type;
      lp_build_conv_auto(gallivm, fs_type, &row_type, src, src_count, src);
      src_count = lp_build_conv_auto(gallivm, fs_type, &old_row_type, src1, src_count, src1);
   }
   else {
      src_count = lp_build_conv_auto(gallivm, fs_type, &row_type, src, src_count, src);
   }

   /* If the rows are not an SSE vector, combine them to become SSE size! */
   if ((row_type.width * row_type.length) % 128) {
      unsigned bits = row_type.width * row_type.length;
      unsigned combined;

      assert(src_count >= (vector_width / bits));

      dst_count = src_count / (vector_width / bits);

      combined = lp_build_concat_n(gallivm, row_type, src, src_count, src, dst_count);
      if (dual_source_blend) {
         lp_build_concat_n(gallivm, row_type, src1, src_count, src1, dst_count);
      }

      row_type.length *= combined;
      src_count /= combined;

      bits = row_type.width * row_type.length;
      assert(bits == 128 || bits == 256);
   }
d287 1
d289 1
a289 6
   /*
    * Blend Colour conversion
    */
   blend_color = lp_jit_context_f_blend_color(gallivm, context_ptr);
   blend_color = LLVMBuildPointerCast(builder, blend_color, LLVMPointerType(lp_build_vec_type(gallivm, fs_type), 0), "");
   blend_color = LLVMBuildLoad(builder, LLVMBuildGEP(builder, blend_color, &i32_zero, 1, ""), "");
d291 4
a294 26
   /* Convert */
   lp_build_conv(gallivm, fs_type, blend_type, &blend_color, 1, &blend_color, 1);

   if (out_format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB) {
      /*
       * since blending is done with floats, there was no conversion.
       * However, the rules according to fixed point renderbuffers still
       * apply, that is we must clamp inputs to 0.0/1.0.
       * (This would apply to separate alpha conversion too but we currently
       * force has_alpha to be true.)
       * TODO: should skip this with "fake" blend, since post-blend conversion
       * will clamp anyway.
       * TODO: could also skip this if fragment color clamping is enabled. We
       * don't support it natively so it gets baked into the shader however, so
       * can't really tell here.
       */
      struct lp_build_context f32_bld;
      assert(row_type.floating);
      lp_build_context_init(&f32_bld, gallivm, row_type);
      for (i = 0; i < src_count; i++) {
         src[i] = lp_build_clamp(&f32_bld, src[i], f32_bld.zero, f32_bld.one);
      }
      if (dual_source_blend) {
         for (i = 0; i < src_count; i++) {
            src1[i] = lp_build_clamp(&f32_bld, src1[i], f32_bld.zero, f32_bld.one);
         }
a295 3
      /* probably can't be different than row_type but better safe than sorry... */
      lp_build_context_init(&f32_bld, gallivm, blend_type);
      blend_color = lp_build_clamp(&f32_bld, blend_color, f32_bld.zero, f32_bld.one);
d298 7
a304 11
   /* Extract alpha */
   blend_alpha = lp_build_extract_broadcast(gallivm, blend_type, row_type, blend_color, lp_build_const_int32(gallivm, 3));

   /* Swizzle to appropriate channels, e.g. from RGBA to BGRA BGRA */
   pad_inline &= (dst_channels * (block_size / src_count) * row_type.width) != vector_width;
   if (pad_inline) {
      /* Use all 4 channels e.g. from RGBA RGBA to RGxx RGxx */
      blend_color = lp_build_swizzle_aos_n(gallivm, blend_color, swizzle, TGSI_NUM_CHANNELS, row_type.length);
   } else {
      /* Only use dst_channels e.g. RGBA RGBA to RG RG xxxx */
      blend_color = lp_build_swizzle_aos_n(gallivm, blend_color, swizzle, dst_channels, row_type.length);
d307 8
a314 4
   /*
    * Mask conversion
    */
   lp_bld_quad_twiddle(gallivm, mask_type, &src_mask[0], block_height, &src_mask[0]);
d316 12
a327 6
   if (src_count < block_height) {
      lp_build_concat_n(gallivm, mask_type, src_mask, 4, src_mask, src_count);
   } else if (src_count > block_height) {
      for (i = src_count; i > 0; --i) {
         unsigned pixels = block_size / src_count;
         unsigned idx = i - 1;
d329 2
a330 2
         src_mask[idx] = lp_build_extract_range(gallivm, src_mask[(idx * pixels) / 4],
                                                (idx * pixels) % 4, pixels);
d334 6
a339 1
   assert(mask_type.width == 32);
d341 5
a345 3
   for (i = 0; i < src_count; ++i) {
      unsigned pixels = block_size / src_count;
      unsigned pixel_width = row_type.width * dst_channels;
d347 3
a349 6
      if (pixel_width == 24) {
         mask_type.width = 8;
         mask_type.length = vector_width / mask_type.width;
      } else {
         mask_type.length = pixels;
         mask_type.width = row_type.width * dst_channels;
d351 2
a352 1
         src_mask[i] = LLVMBuildIntCast(builder, src_mask[i], lp_build_int_vec_type(gallivm, mask_type), "");
d354 3
a356 2
         mask_type.length *= dst_channels;
         mask_type.width /= dst_channels;
d358 1
d360 9
a368 3
      src_mask[i] = LLVMBuildBitCast(builder, src_mask[i], lp_build_int_vec_type(gallivm, mask_type), "");
      src_mask[i] = lp_build_pad_vector(gallivm, src_mask[i], row_type.length);
   }
d370 14
a383 15
   /*
    * Alpha conversion
    */
   if (!has_alpha) {
      struct lp_type alpha_type = fs_type;
      alpha_type.length = 4;
      convert_alpha(gallivm, row_type, alpha_type,
                    block_size, block_height,
                    src_count, dst_channels,
                    pad_inline, src_alpha);
      if (dual_source_blend) {
         convert_alpha(gallivm, row_type, alpha_type,
                       block_size, block_height,
                       src_count, dst_channels,
                       pad_inline, src1_alpha);
d386 14
d402 18
a419 7
   /*
    * Load dst from memory
    */
   if (src_count < block_height) {
      dst_count = block_height;
   } else {
      dst_count = src_count;
d422 6
a427 1
   dst_type.length *= block_size / dst_count;
a428 9
   if (format_expands_to_float_soa(out_format_desc)) {
      /*
       * we need multiple values at once for the conversion, so can as well
       * load them vectorized here too instead of concatenating later.
       * (Still need concatenation later for 8-wide vectors).
       */
      dst_count = block_height;
      dst_type.length = block_width;
   }
d430 29
a458 20
   /*
    * Compute the alignment of the destination pointer in bytes
    * We fetch 1-4 pixels, if the format has pot alignment then those fetches
    * are always aligned by MIN2(16, fetch_width) except for buffers (not
    * 1d tex but can't distinguish here) so need to stick with per-pixel
    * alignment in this case.
    */
   if (is_1d) {
      dst_alignment = (out_format_desc->block.bits + 7)/(out_format_desc->block.width * 8);
   }
   else {
      dst_alignment = dst_type.length * dst_type.width / 8;
   }
   /* Force power-of-two alignment by extracting only the least-significant-bit */
   dst_alignment = 1 << (ffs(dst_alignment) - 1);
   /*
    * Resource base and stride pointers are aligned to 16 bytes, so that's
    * the maximum alignment we can guarantee
    */
   dst_alignment = MIN2(16, dst_alignment);
d460 1
a460 6
   if (is_1d) {
      load_unswizzled_block(gallivm, color_ptr, stride, block_width, 1,
                            dst, dst_type, dst_count / 4, dst_alignment);
      for (i = dst_count / 4; i < dst_count; i++) {
         dst[i] = lp_build_undef(gallivm, dst_type);
      }
d462 3
a464 5
   }
   else {
      load_unswizzled_block(gallivm, color_ptr, stride, block_width, block_height,
                            dst, dst_type, dst_count, dst_alignment);
   }
d466 1
d468 3
a470 13
   /*
    * Convert from dst/output format to src/blending format.
    *
    * This is necessary as we can only read 1 row from memory at a time,
    * so the minimum dst_count will ever be at this point is 4.
    *
    * With, for example, R8 format you can have all 16 pixels in a 128 bit vector,
    * this will take the 4 dsts and combine them into 1 src so we can perform blending
    * on all 16 pixels in that single vector at once.
    */
   if (dst_count > src_count) {
      lp_build_concat_n(gallivm, dst_type, dst, 4, dst, src_count);
   }
d472 4
a475 13
   /*
    * Blending
    */
   /* XXX this is broken for RGB8 formats -
    * they get expanded from 12 to 16 elements (to include alpha)
    * by convert_to_blend_type then reduced to 15 instead of 12
    * by convert_from_blend_type (a simple fix though breaks A8...).
    * R16G16B16 also crashes differently however something going wrong
    * inside llvm handling npot vector sizes seemingly.
    * It seems some cleanup could be done here (like skipping conversion/blend
    * when not needed).
    */
   convert_to_blend_type(gallivm, block_size, out_format_desc, dst_type, row_type, dst, src_count);
d477 1
a477 42
   /*
    * FIXME: Really should get logic ops / masks out of generic blend / row
    * format. Logic ops will definitely not work on the blend float format
    * used for SRGB here and I think OpenGL expects this to work as expected
    * (that is incoming values converted to srgb then logic op applied).
    */
   for (i = 0; i < src_count; ++i) {
      dst[i] = lp_build_blend_aos(gallivm,
                                  &variant->key.blend,
                                  out_format,
                                  row_type,
                                  rt,
                                  src[i],
                                  has_alpha ? NULL : src_alpha[i],
                                  src1[i],
                                  has_alpha ? NULL : src1_alpha[i],
                                  dst[i],
                                  partial_mask ? src_mask[i] : NULL,
                                  blend_color,
                                  has_alpha ? NULL : blend_alpha,
                                  swizzle,
                                  pad_inline ? 4 : dst_channels);
   }

   convert_from_blend_type(gallivm, block_size, out_format_desc, row_type, dst_type, dst, src_count);

   /* Split the blend rows back to memory rows */
   if (dst_count > src_count) {
      row_type.length = dst_type.length * (dst_count / src_count);

      if (src_count == 1) {
         dst[1] = lp_build_extract_range(gallivm, dst[0], row_type.length / 2, row_type.length / 2);
         dst[0] = lp_build_extract_range(gallivm, dst[0], 0, row_type.length / 2);

         row_type.length /= 2;
         src_count *= 2;
      }

      dst[3] = lp_build_extract_range(gallivm, dst[1], row_type.length / 2, row_type.length / 2);
      dst[2] = lp_build_extract_range(gallivm, dst[1], 0, row_type.length / 2);
      dst[1] = lp_build_extract_range(gallivm, dst[0], row_type.length / 2, row_type.length / 2);
      dst[0] = lp_build_extract_range(gallivm, dst[0], 0, row_type.length / 2);
d479 2
a480 2
      row_type.length /= 2;
      src_count *= 2;
d483 11
a493 10
   /*
    * Store blend result to memory
    */
   if (is_1d) {
      store_unswizzled_block(gallivm, color_ptr, stride, block_width, 1,
                             dst, dst_type, dst_count / 4, dst_alignment);
   }
   else {
      store_unswizzled_block(gallivm, color_ptr, stride, block_width, block_height,
                             dst, dst_type, dst_count, dst_alignment);
d496 1
a496 3
   if (do_branch) {
      lp_build_mask_end(&mask_ctx);
   }
d512 1
a512 1
   struct gallivm_state *gallivm = variant->gallivm;
d519 1
d521 1
a521 1
   LLVMTypeRef arg_types[13];
a531 1
   LLVMValueRef stride_ptr;
a532 1
   LLVMValueRef depth_stride;
d534 1
a534 1
   LLVMValueRef thread_data_ptr;
d539 3
a541 2
   LLVMValueRef fs_mask[16 / 4];
   LLVMValueRef fs_out_color[PIPE_MAX_COLOR_BUFS][TGSI_NUM_CHANNELS][16 / 4];
d544 1
a548 5
   boolean cbuf0_write_all;
   const boolean dual_source_blend = key->blend.rt[0].blend_enable &&
                                     util_blend_state_is_dual(&key->blend, 0);

   assert(lp_native_vector_width / 32 >= 4);
d558 1
a558 1
	    inputs[i].interp = LP_INTERP_PERSPECTIVE;
a561 9
   /* check if writes to cbuf[0] are to be copied to all cbufs */
   cbuf0_write_all = FALSE;
   for (i = 0;i < shader->info.base.num_properties; i++) {
      if (shader->info.base.properties[i].name ==
          TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS) {
         cbuf0_write_all = TRUE;
         break;
      }
   }
d567 6
a572 5
   fs_type.floating = TRUE;      /* floating point values */
   fs_type.sign = TRUE;          /* values are signed */
   fs_type.norm = FALSE;         /* values are not limited to [0,1] or [-1,1] */
   fs_type.width = 32;           /* 32-bit float */
   fs_type.length = MIN2(lp_native_vector_width / 32, 16); /* n*4 elements per vector */
d587 1
d594 1
a594 1
   arg_types[0] = variant->jit_context_ptr_type;       /* context */
d604 1
a604 3
   arg_types[10] = variant->jit_thread_data_ptr_type;  /* per thread data */
   arg_types[11] = LLVMPointerType(int32_type, 0);     /* stride */
   arg_types[12] = int32_type;                         /* depth_stride */
a630 3
   thread_data_ptr  = LLVMGetParam(function, 10);
   stride_ptr   = LLVMGetParam(function, 11);
   depth_stride = LLVMGetParam(function, 12);
a639 1
   lp_build_name(thread_data_ptr, "thread_data");
d641 5
a645 2
   lp_build_name(stride_ptr, "stride_ptr");
   lp_build_name(depth_stride, "depth_stride");
d656 13
d670 1
a670 1
   sampler = lp_llvm_sampler_soa_create(key->state, context_ptr);
d672 2
a673 4
   num_fs = 16 / fs_type.length; /* number of loops per 4x4 stamp */
   /* for 1d resources only run "upper half" of stamp */
   if (key->resource_1d)
      num_fs /= 2;
d675 28
a702 76
   {
      LLVMValueRef num_loop = lp_build_const_int32(gallivm, num_fs);
      LLVMTypeRef mask_type = lp_build_int_vec_type(gallivm, fs_type);
      LLVMValueRef mask_store = lp_build_array_alloca(gallivm, mask_type,
                                                      num_loop, "mask_store");
      LLVMValueRef color_store[PIPE_MAX_COLOR_BUFS][TGSI_NUM_CHANNELS];

      /*
       * The shader input interpolation info is not explicitely baked in the
       * shader key, but everything it derives from (TGSI, and flatshade) is
       * already included in the shader key.
       */
      lp_build_interp_soa_init(&interp,
                               gallivm,
                               shader->info.base.num_inputs,
                               inputs,
                               shader->info.base.pixel_center_integer,
                               builder, fs_type,
                               a0_ptr, dadx_ptr, dady_ptr,
                               x, y);

      for (i = 0; i < num_fs; i++) {
         LLVMValueRef mask;
         LLVMValueRef indexi = lp_build_const_int32(gallivm, i);
         LLVMValueRef mask_ptr = LLVMBuildGEP(builder, mask_store,
                                              &indexi, 1, "mask_ptr");

         if (partial_mask) {
            mask = generate_quad_mask(gallivm, fs_type,
                                      i*fs_type.length/4, mask_input);
         }
         else {
            mask = lp_build_const_int_vec(gallivm, fs_type, ~0);
         }
         LLVMBuildStore(builder, mask, mask_ptr);
      }

      generate_fs_loop(gallivm,
                       shader, key,
                       builder,
                       fs_type,
                       context_ptr,
                       num_loop,
                       &interp,
                       sampler,
                       mask_store, /* output */
                       color_store,
                       depth_ptr,
                       depth_stride,
                       facing,
                       thread_data_ptr);

      for (i = 0; i < num_fs; i++) {
         LLVMValueRef indexi = lp_build_const_int32(gallivm, i);
         LLVMValueRef ptr = LLVMBuildGEP(builder, mask_store,
                                         &indexi, 1, "");
         fs_mask[i] = LLVMBuildLoad(builder, ptr, "mask");
         /* This is fucked up need to reorganize things */
         for (cbuf = 0; cbuf < key->nr_cbufs; cbuf++) {
            for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
               ptr = LLVMBuildGEP(builder,
                                  color_store[cbuf * !cbuf0_write_all][chan],
                                  &indexi, 1, "");
               fs_out_color[cbuf][chan][i] = ptr;
            }
         }
         if (dual_source_blend) {
            /* only support one dual source blend target hence always use output 1 */
            for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan) {
               ptr = LLVMBuildGEP(builder,
                                  color_store[1][chan],
                                  &indexi, 1, "");
               fs_out_color[1][chan][i] = ptr;
            }
         }
      }
a710 1
      LLVMValueRef stride;
d712 2
d715 26
a740 8
      boolean do_branch = ((key->depth.enabled
                            || key->stencil[0].enabled
                            || key->alpha.enabled)
                           && !shader->info.base.uses_kill);

      color_ptr = LLVMBuildLoad(builder,
                                LLVMBuildGEP(builder, color_ptr_ptr, &index, 1, ""),
                                "");
d742 3
d747 24
a770 7
      stride = LLVMBuildLoad(builder,
                             LLVMBuildGEP(builder, stride_ptr, &index, 1, ""),
                             "");

      generate_unswizzled_blend(gallivm, cbuf, variant, key->cbuf_format[cbuf],
                                num_fs, fs_type, fs_mask, fs_out_color,
                                context_ptr, color_ptr, stride, partial_mask, do_branch);
d775 30
a804 1
   gallivm_verify_function(gallivm, function);
d806 5
a810 1
   variant->nr_instrs += lp_build_count_instructions(function);
a864 1
      const struct lp_static_sampler_state *sampler = &key->state[i].sampler_state;
d866 8
d875 3
a877 3
                   util_dump_tex_wrap(sampler->wrap_s, TRUE),
                   util_dump_tex_wrap(sampler->wrap_t, TRUE),
                   util_dump_tex_wrap(sampler->wrap_r, TRUE));
d879 1
a879 1
                   util_dump_tex_filter(sampler->min_img_filter, TRUE));
d881 1
a881 1
                   util_dump_tex_mipfilter(sampler->min_mip_filter, TRUE));
d883 8
a890 22
                   util_dump_tex_filter(sampler->mag_img_filter, TRUE));
      if (sampler->compare_mode != PIPE_TEX_COMPARE_NONE)
         debug_printf("  .compare_func = %s\n", util_dump_func(sampler->compare_func, TRUE));
      debug_printf("  .normalized_coords = %u\n", sampler->normalized_coords);
      debug_printf("  .min_max_lod_equal = %u\n", sampler->min_max_lod_equal);
      debug_printf("  .lod_bias_non_zero = %u\n", sampler->lod_bias_non_zero);
      debug_printf("  .apply_min_lod = %u\n", sampler->apply_min_lod);
      debug_printf("  .apply_max_lod = %u\n", sampler->apply_max_lod);
   }
   for (i = 0; i < key->nr_sampler_views; ++i) {
      const struct lp_static_texture_state *texture = &key->state[i].texture_state;
      debug_printf("texture[%u] = \n", i);
      debug_printf("  .format = %s\n",
                   util_format_name(texture->format));
      debug_printf("  .target = %s\n",
                   util_dump_tex_target(texture->target, TRUE));
      debug_printf("  .level_zero_only = %u\n",
                   texture->level_zero_only);
      debug_printf("  .pot = %u %u %u\n",
                   texture->pot_width,
                   texture->pot_height,
                   texture->pot_depth);
a916 1
   const struct util_format_description *cbuf0_format_desc;
a922 6
   variant->gallivm = gallivm_create();
   if (!variant->gallivm) {
      FREE(variant);
      return NULL;
   }

d935 6
a940 2
      cbuf0_format_desc = util_format_description(key->cbuf_format[0]);
      fullcolormask = util_format_colormask_full(cbuf0_format_desc, key->blend.rt[0].colormask);
d953 1
d958 1
a958 4
   lp_jit_init_types(variant);
   
   if (variant->jit_function[RAST_EDGE_TEST] == NULL)
      generate_fragment(lp, shader, variant, RAST_EDGE_TEST);
d960 4
a963 24
   if (variant->jit_function[RAST_WHOLE] == NULL) {
      if (variant->opaque) {
         /* Specialized shader, which doesn't need to read the color buffer. */
         generate_fragment(lp, shader, variant, RAST_WHOLE);
      }
   }

   /*
    * Compile everything
    */

   gallivm_compile_module(variant->gallivm);

   if (variant->function[RAST_EDGE_TEST]) {
      variant->jit_function[RAST_EDGE_TEST] = (lp_jit_frag_func)
            gallivm_jit_function(variant->gallivm,
                                 variant->function[RAST_EDGE_TEST]);
   }

   if (variant->function[RAST_WHOLE]) {
         variant->jit_function[RAST_WHOLE] = (lp_jit_frag_func)
               gallivm_jit_function(variant->gallivm,
                                    variant->function[RAST_WHOLE]);
   } else if (!variant->jit_function[RAST_WHOLE]) {
a977 1
   int nr_sampler_views;
a1000 1
   nr_sampler_views = shader->info.base.file_max[TGSI_FILE_SAMPLER_VIEW] + 1;
d1003 1
a1003 1
                                     state[MAX2(nr_samplers, nr_sampler_views)]);
a1006 1
      shader->inputs[i].cyl_wrap = shader->info.base.input_cylindrical_wrap[i];
a1017 3
      case TGSI_INTERPOLATE_COLOR:
	 shader->inputs[i].interp = LP_INTERP_COLOR;
	 break;
d1024 7
d1075 2
d1109 4
a1112 3
         gallivm_free_function(variant->gallivm,
                               variant->function[i],
                               variant->jit_function[i]);
a1115 2
   gallivm_destroy(variant->gallivm);

a1122 1
   lp->nr_fs_instrs -= variant->nr_instrs;
d1165 1
a1165 1
                             struct pipe_constant_buffer *cb)
d1168 2
a1169 1
   struct pipe_resource *constants = cb ? cb->buffer : NULL;
d1172 1
a1172 1
   assert(index < Elements(llvmpipe->constants[shader]));
d1174 2
a1175 2
   /* note: reference counting */
   util_copy_constant_buffer(&llvmpipe->constants[shader][index], cb);
d1177 1
a1177 5
   if (shader == PIPE_SHADER_VERTEX ||
       shader == PIPE_SHADER_GEOMETRY) {
      /* Pass the constants to the 'draw' module */
      const unsigned size = cb ? cb->buffer_size : 0;
      const ubyte *data;
d1179 2
a1180 12
      if (constants) {
         data = (ubyte *) llvmpipe_resource_data(constants);
      }
      else if (cb && cb->user_buffer) {
         data = (ubyte *) cb->user_buffer;
      }
      else {
         data = NULL;
      }

      if (data)
         data += cb->buffer_offset;
d1182 2
a1188 4

   if (cb && cb->user_buffer) {
      pipe_resource_reference(&constants, NULL);
   }
d1196 1
a1196 1
force_dst_alpha_one(unsigned factor, boolean clamped_zero)
d1204 1
a1204 4
      if (clamped_zero)
         return PIPE_BLENDFACTOR_ZERO;
      else
         return PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE;
d1228 2
a1229 7
      enum pipe_format zsbuf_format = lp->framebuffer.zsbuf->format;
      const struct util_format_description *zsbuf_desc =
         util_format_description(zsbuf_format);

      if (lp->depth_stencil->depth.enabled &&
          util_format_has_depth(zsbuf_desc)) {
         key->zsbuf_format = zsbuf_format;
d1232 2
a1233 3
      if (lp->depth_stencil->stencil[0].enabled &&
          util_format_has_stencil(zsbuf_desc)) {
         key->zsbuf_format = zsbuf_format;
a1235 3
      if (llvmpipe_resource_is_1d(lp->framebuffer.zsbuf->texture)) {
         key->resource_1d = TRUE;
      }
d1238 1
a1238 5
   /* alpha test only applies if render buffer 0 is non-integer (or does not exist) */
   if (!lp->framebuffer.nr_cbufs ||
       !util_format_is_pure_integer(lp->framebuffer.cbufs[0]->format)) {
      key->alpha.enabled = lp->depth_stencil->alpha.enabled;
   }
d1244 1
a1244 1
   if (lp->active_occlusion_queries) {
a1252 9

   if (!key->blend.independent_blend_enable) {
      /* we always need independent blend otherwise the fixups below won't work */
      for (i = 1; i < key->nr_cbufs; i++) {
         memcpy(&key->blend.rt[i], &key->blend.rt[0], sizeof(key->blend.rt[0]));
      }
      key->blend.independent_blend_enable = 1;
   }

a1259 9
      /*
       * Figure out if this is a 1d resource. Note that OpenGL allows crazy
       * mixing of 2d textures with height 1 and 1d textures, so make sure
       * we pick 1d if any cbuf or zsbuf is 1d.
       */
      if (llvmpipe_resource_is_1d(lp->framebuffer.cbufs[0]->texture)) {
         key->resource_1d = TRUE;
      }

d1264 2
a1271 7
       * Disable blend for integer formats.
       */
      if (util_format_is_pure_integer(format)) {
         blend_rt->blend_enable = 0;
      }

      /*
d1286 3
a1288 9
      if (format_desc->swizzle[3] > UTIL_FORMAT_SWIZZLE_W ||
          format_desc->swizzle[3] == format_desc->swizzle[0]) {
         /* Doesn't cover mixed snorm/unorm but can't render to them anyway */
         boolean clamped_zero = !util_format_is_float(format) &&
                                !util_format_is_snorm(format);
         blend_rt->rgb_src_factor   = force_dst_alpha_one(blend_rt->rgb_src_factor,
                                                          clamped_zero);
         blend_rt->rgb_dst_factor   = force_dst_alpha_one(blend_rt->rgb_dst_factor,
                                                          clamped_zero);
d1301 3
a1303 26
         lp_sampler_static_sampler_state(&key->state[i].sampler_state,
                                         lp->samplers[PIPE_SHADER_FRAGMENT][i]);
      }
   }

   /*
    * XXX If TGSI_FILE_SAMPLER_VIEW exists assume all texture opcodes
    * are dx10-style? Can't really have mixed opcodes, at least not
    * if we want to skip the holes here (without rescanning tgsi).
    */
   if (shader->info.base.file_max[TGSI_FILE_SAMPLER_VIEW] != -1) {
      key->nr_sampler_views = shader->info.base.file_max[TGSI_FILE_SAMPLER_VIEW] + 1;
      for(i = 0; i < key->nr_sampler_views; ++i) {
         if(shader->info.base.file_mask[TGSI_FILE_SAMPLER_VIEW] & (1 << i)) {
            lp_sampler_static_texture_state(&key->state[i].texture_state,
                                            lp->sampler_views[PIPE_SHADER_FRAGMENT][i]);
         }
      }
   }
   else {
      key->nr_sampler_views = key->nr_samplers;
      for(i = 0; i < key->nr_sampler_views; ++i) {
         if(shader->info.base.file_mask[TGSI_FILE_SAMPLER] & (1 << i)) {
            lp_sampler_static_texture_state(&key->state[i].texture_state,
                                            lp->sampler_views[PIPE_SHADER_FRAGMENT][i]);
         }
a1343 8
      unsigned variants_to_cull;

      if (0) {
         debug_printf("%u variants,\t%u instrs,\t%u instrs/variant\n",
                      lp->nr_fs_variants,
                      lp->nr_fs_instrs,
                      lp->nr_fs_variants ? lp->nr_fs_instrs / lp->nr_fs_variants : 0);
      }
d1348 1
a1348 4
      variants_to_cull = lp->nr_fs_variants >= LP_MAX_SHADER_VARIANTS ? LP_MAX_SHADER_VARIANTS / 4 : 0;

      if (variants_to_cull ||
          lp->nr_fs_instrs >= LP_MAX_SHADER_INSTRUCTIONS) {
d1358 1
a1358 7
         /*
          * We need to re-check lp->nr_fs_variants because an arbitrarliy large
          * number of shader variants (potentially all of them) could be
          * pending for destruction on flush.
          */

         for (i = 0; i < variants_to_cull || lp->nr_fs_instrs >= LP_MAX_SHADER_INSTRUCTIONS; i++) {
a1359 3
            if (is_empty_list(&lp->fs_variants_list)) {
               break;
            }
a1360 2
            assert(item);
            assert(item->base);
a1381 1
         lp->nr_fs_instrs += variant->nr_instrs;
d1389 2
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d4 1
a4 1
 * Copyright 2007 VMware, Inc.
d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a217 24
 * Fetch the specified lp_jit_viewport structure for a given viewport_index.
 */
static LLVMValueRef
lp_llvm_viewport(LLVMValueRef context_ptr,
                 struct gallivm_state *gallivm,
                 LLVMValueRef viewport_index)
{
   LLVMBuilderRef builder = gallivm->builder;
   LLVMValueRef ptr;
   LLVMValueRef res;
   struct lp_type viewport_type =
      lp_type_float_vec(32, 32 * LP_JIT_VIEWPORT_NUM_FIELDS);

   ptr = lp_jit_context_viewports(gallivm, context_ptr);
   ptr = LLVMBuildPointerCast(builder, ptr,
            LLVMPointerType(lp_build_vec_type(gallivm, viewport_type), 0), "");

   res = lp_build_pointer_get(builder, ptr, viewport_index);

   return res;
}


/**
d241 1
a241 1
   LLVMValueRef consts_ptr, num_consts_ptr;
d275 1
a275 3
         if (key->alpha.enabled ||
             key->blend.alpha_to_coverage ||
             shader->info.base.uses_kill) {
a312 1
   num_consts_ptr = lp_jit_context_num_constants(gallivm, context_ptr);
d391 1
a391 1
                     consts_ptr, num_consts_ptr, &system_values,
a416 15
   /* Emulate Alpha to Coverage with Alpha test */
   if (key->blend.alpha_to_coverage) {
      int color0 = find_output_by_semantic(&shader->info.base,
                                           TGSI_SEMANTIC_COLOR,
                                           0);

      if (color0 != -1 && outputs[color0][3]) {
         LLVMValueRef alpha = LLVMBuildLoad(builder, outputs[color0][3], "alpha");

         lp_build_alpha_to_coverage(gallivm, type,
                                    &mask, alpha,
                                    (depth_mode & LATE_DEPTH_TEST) != 0);
      }
   }

a424 45

         /*
          * Clamp according to ARB_depth_clamp semantics.
          */
         if (key->depth_clamp) {
            LLVMValueRef viewport, min_depth, max_depth;
            LLVMValueRef viewport_index;
            struct lp_build_context f32_bld;

            assert(type.floating);
            lp_build_context_init(&f32_bld, gallivm, type);

            /*
             * Assumes clamping of the viewport index will occur in setup/gs. Value
             * is passed through the rasterization stage via lp_rast_shader_inputs.
             *
             * See: draw_clamp_viewport_idx and lp_clamp_viewport_idx for clamping
             *      semantics.
             */
            viewport_index = lp_jit_thread_data_raster_state_viewport_index(gallivm,
                                thread_data_ptr);

            /*
             * Load the min and max depth from the lp_jit_context.viewports
             * array of lp_jit_viewport structures.
             */
            viewport = lp_llvm_viewport(context_ptr, gallivm, viewport_index);

            /* viewports[viewport_index].min_depth */
            min_depth = LLVMBuildExtractElement(builder, viewport,
                           lp_build_const_int32(gallivm, LP_JIT_VIEWPORT_MIN_DEPTH),
                           "");
            min_depth = lp_build_broadcast_scalar(&f32_bld, min_depth);

            /* viewports[viewport_index].max_depth */
            max_depth = LLVMBuildExtractElement(builder, viewport,
                           lp_build_const_int32(gallivm, LP_JIT_VIEWPORT_MAX_DEPTH),
                           "");
            max_depth = lp_build_broadcast_scalar(&f32_bld, max_depth);

            /*
             * Clamp to the min and max depth values for the given viewport.
             */
            z = lp_build_clamp(&f32_bld, z, min_depth, max_depth);
         }
d784 1
a784 1
      /* just make this a uint with width of block */
d789 1
a789 1
      type->width = format_desc->block.bits;
d879 1
a879 16
 * Scale a normalized value from src_bits to dst_bits.
 *
 * The exact calculation is
 *
 *    dst = iround(src * dst_mask / src_mask)
 *
 *  or with integer rounding
 *
 *    dst = src * (2*dst_mask + sign(src)*src_mask) / (2*src_mask)
 *
 *  where
 *
 *    src_mask = (1 << src_bits) - 1
 *    dst_mask = (1 << dst_bits) - 1
 *
 * but we try to avoid division and multiplication through shifts.
d892 5
a896 62
      int delta_bits = src_bits - dst_bits;

      if (delta_bits <= dst_bits) {
         /*
          * Approximate the rescaling with a single shift.
          *
          * This gives the wrong rounding.
          */

         result = LLVMBuildLShr(builder,
                                src,
                                lp_build_const_int_vec(gallivm, src_type, delta_bits),
                                "");

      } else {
         /*
          * Try more accurate rescaling.
          */

         /*
          * Drop the least significant bits to make space for the multiplication.
          *
          * XXX: A better approach would be to use a wider integer type as intermediate.  But
          * this is enough to convert alpha from 16bits -> 2 when rendering to
          * PIPE_FORMAT_R10G10B10A2_UNORM.
          */
         result = LLVMBuildLShr(builder,
                                src,
                                lp_build_const_int_vec(gallivm, src_type, dst_bits),
                                "");


         result = LLVMBuildMul(builder,
                               result,
                               lp_build_const_int_vec(gallivm, src_type, (1LL << dst_bits) - 1),
                               "");

         /*
          * Add a rounding term before the division.
          *
          * TODO: Handle signed integers too.
          */
         if (!src_type.sign) {
            result = LLVMBuildAdd(builder,
                                  result,
                                  lp_build_const_int_vec(gallivm, src_type, (1LL << (delta_bits - 1))),
                                  "");
         }

         /*
          * Approximate the division by src_mask with a src_bits shift.
          *
          * Given the src has already been shifted by dst_bits, all we need
          * to do is to shift by the difference.
          */

         result = LLVMBuildLShr(builder,
                                result,
                                lp_build_const_int_vec(gallivm, src_type, delta_bits),
                                "");
      }

a932 13
/**
 * If RT is a smallfloat (needing denorms) format
 */
static INLINE int
have_smallfloat_format(struct lp_type dst_type,
                       enum pipe_format format)
{
   return ((dst_type.floating && dst_type.width != 32) ||
    /* due to format handling hacks this format doesn't have floating set
     * here (and actually has width set to 32 too) so special case this. */
    (format == PIPE_FORMAT_R11G11B10_FLOAT));
}

d968 1
a968 1
      assert(src_type.width == 32 || src_type.width == 16);
a973 12
      if (src_type.width == 16) {
         /* expand 4x16bit values to 4x32bit */
         struct lp_type type32x4 = src_type;
         LLVMTypeRef ltype32x4;
         unsigned num_fetch = dst_type.length == 8 ? num_srcs / 2 : num_srcs / 4;
         type32x4.width = 32;
         ltype32x4 = lp_build_vec_type(gallivm, type32x4);
         for (i = 0; i < num_fetch; i++) {
            src[i] = LLVMBuildZExt(builder, src[i], ltype32x4, "");
         }
         src_type.width = 32;
      }
d1129 1
a1129 1
      assert(dst_type.width == 32 || dst_type.width == 16);
a1163 19
      if (dst_type.width == 16) {
         struct lp_type type16x8 = dst_type;
         struct lp_type type32x4 = dst_type;
         LLVMTypeRef ltype16x4, ltypei64, ltypei128;
         unsigned num_fetch = src_type.length == 8 ? num_srcs / 2 : num_srcs / 4;
         type16x8.length = 8;
         type32x4.width = 32;
         ltypei128 = LLVMIntTypeInContext(gallivm->context, 128);
         ltypei64 = LLVMIntTypeInContext(gallivm->context, 64);
         ltype16x4 = lp_build_vec_type(gallivm, dst_type);
         /* We could do vector truncation but it doesn't generate very good code */
         for (i = 0; i < num_fetch; i++) {
            src[i] = lp_build_pack2(gallivm, type32x4, type16x8,
                                    src[i], lp_build_zero(gallivm, type32x4));
            src[i] = LLVMBuildBitCast(builder, src[i], ltypei128, "");
            src[i] = LLVMBuildTrunc(builder, src[i], ltypei64, "");
            src[i] = LLVMBuildBitCast(builder, src[i], ltype16x4, "");
         }
      }
a1420 22
   LLVMValueRef fpstate = 0;

   /* Get type from output format */
   lp_blend_type_from_format_desc(out_format_desc, &row_type);
   lp_mem_type_from_format_desc(out_format_desc, &dst_type);

   /*
    * Technically this code should go into lp_build_smallfloat_to_float
    * and lp_build_float_to_smallfloat but due to the
    * http://llvm.org/bugs/show_bug.cgi?id=6393
    * llvm reorders the mxcsr intrinsics in a way that breaks the code.
    * So the ordering is important here and there shouldn't be any
    * llvm ir instrunctions in this function before
    * this, otherwise half-float format conversions won't work
    * (again due to llvm bug #6393).
    */
   if (have_smallfloat_format(dst_type, out_format)) {
      /* We need to make sure that denorms are ok for half float
         conversions */
      fpstate = lp_build_fpstate_get(gallivm);
      lp_build_fpstate_set_denorms_zero(gallivm, FALSE);
   }
d1454 5
d1691 1
a1691 1
         src[i] = lp_build_clamp_zero_one_nanzero(&f32_bld, src[i]);
d1695 1
a1695 1
            src1[i] = lp_build_clamp_zero_one_nanzero(&f32_bld, src1[i]);
a1917 4
   if (have_smallfloat_format(dst_type, out_format)) {
      lp_build_fpstate_set(gallivm, fpstate);
   }

d2185 8
a2192 14
      if (key->cbuf_format[cbuf] != PIPE_FORMAT_NONE) {
         LLVMValueRef color_ptr;
         LLVMValueRef stride;
         LLVMValueRef index = lp_build_const_int32(gallivm, cbuf);

         boolean do_branch = ((key->depth.enabled
                               || key->stencil[0].enabled
                               || key->alpha.enabled)
                              && !shader->info.base.uses_kill);

         color_ptr = LLVMBuildLoad(builder,
                                   LLVMBuildGEP(builder, color_ptr_ptr,
                                                &index, 1, ""),
                                   "");
d2194 3
a2196 1
         lp_build_name(color_ptr, "color_ptr%d", cbuf);
d2198 1
a2198 3
         stride = LLVMBuildLoad(builder,
                                LLVMBuildGEP(builder, stride_ptr, &index, 1, ""),
                                "");
d2200 7
a2206 6
         generate_unswizzled_blend(gallivm, cbuf, variant,
                                   key->cbuf_format[cbuf],
                                   num_fs, fs_type, fs_mask, fs_out_color,
                                   context_ptr, color_ptr, stride,
                                   partial_mask, do_branch);
      }
a2266 3
   if (key->blend.alpha_to_coverage) {
      debug_printf("blend.alpha_to_coverage is enabled\n");
   }
a2361 1
         !key->blend.alpha_to_coverage &&
d2364 1
a2364 8
      ? TRUE : FALSE;

   if ((shader->info.base.num_tokens <= 1) &&
       !key->depth.enabled && !key->stencil[0].enabled) {
      variant->ps_inv_multiplier = 0;
   } else {
      variant->ps_inv_multiplier = 1;
   }
a2698 12
   /*
    * Propagate the depth clamp setting from the rasterizer state.
    * depth_clip == 0 implies depth clamping is enabled.
    *
    * When clip_halfz is enabled, then always clamp the depth values.
    */
   if (lp->rasterizer->clip_halfz) {
      key->depth_clamp = 1;
   } else {
      key->depth_clamp = (lp->rasterizer->depth_clip == 0) ? 1 : 0;
   }

a2700 1
       !lp->framebuffer.cbufs[0] ||
d2728 1
d2730 1
d2732 1
a2732 3
      if (lp->framebuffer.cbufs[i]) {
         enum pipe_format format = lp->framebuffer.cbufs[i]->format;
         const struct util_format_description *format_desc;
d2734 8
a2741 1
         key->cbuf_format[i] = format;
d2743 3
a2745 8
         /*
          * Figure out if this is a 1d resource. Note that OpenGL allows crazy
          * mixing of 2d textures with height 1 and 1d textures, so make sure
          * we pick 1d if any cbuf or zsbuf is 1d.
          */
         if (llvmpipe_resource_is_1d(lp->framebuffer.cbufs[i]->texture)) {
            key->resource_1d = TRUE;
         }
d2747 4
a2750 3
         format_desc = util_format_description(format);
         assert(format_desc->colorspace == UTIL_FORMAT_COLORSPACE_RGB ||
                format_desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB);
d2752 6
a2757 4
         /*
          * Mask out color channels not present in the color buffer.
          */
         blend_rt->colormask &= util_format_colormask(format_desc);
d2759 27
a2785 42
         /*
          * Disable blend for integer formats.
          */
         if (util_format_is_pure_integer(format)) {
            blend_rt->blend_enable = 0;
         }

         /*
          * Our swizzled render tiles always have an alpha channel, but the
          * linear render target format often does not, so force here the dst
          * alpha to be one.
          *
          * This is not a mere optimization. Wrong results will be produced if
          * the dst alpha is used, the dst format does not have alpha, and the
          * previous rendering was not flushed from the swizzled to linear
          * buffer. For example, NonPowTwo DCT.
          *
          * TODO: This should be generalized to all channels for better
          * performance, but only alpha causes correctness issues.
          *
          * Also, force rgb/alpha func/factors match, to make AoS blending
          * easier.
          */
         if (format_desc->swizzle[3] > UTIL_FORMAT_SWIZZLE_W ||
             format_desc->swizzle[3] == format_desc->swizzle[0]) {
            /* Doesn't cover mixed snorm/unorm but can't render to them anyway */
            boolean clamped_zero = !util_format_is_float(format) &&
                                   !util_format_is_snorm(format);
            blend_rt->rgb_src_factor =
               force_dst_alpha_one(blend_rt->rgb_src_factor, clamped_zero);
            blend_rt->rgb_dst_factor =
               force_dst_alpha_one(blend_rt->rgb_dst_factor, clamped_zero);
            blend_rt->alpha_func       = blend_rt->rgb_func;
            blend_rt->alpha_src_factor = blend_rt->rgb_src_factor;
            blend_rt->alpha_dst_factor = blend_rt->rgb_dst_factor;
         }
      }
      else {
         /* no color buffer for this fragment output */
         key->cbuf_format[i] = PIPE_FORMAT_NONE;
         blend_rt->colormask = 0x0;
         blend_rt->blend_enable = 0;
a2941 15
}

/*
 * Rasterization is disabled if there is no pixel shader and
 * both depth and stencil testing are disabled:
 * http://msdn.microsoft.com/en-us/library/windows/desktop/bb205125
 */
boolean
llvmpipe_rasterization_disabled(struct llvmpipe_context *lp)
{
   boolean null_fs = !lp->fs || lp->fs->info.base.num_tokens <= 1;

   return (null_fs &&
           !lp->depth_stencil->depth.enabled &&
           !lp->depth_stencil->stencil[0].enabled);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d1669 7
d1677 1
d2163 1
a2163 1
   char func_name[64];
d2215 8
a2222 2
   cbuf0_write_all =
     shader->info.base.properties[TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS];
d2250 2
a2251 2
   util_snprintf(func_name, sizeof(func_name), "fs%u_variant%u_%s",
                 shader->no, variant->no, partial_mask ? "partial" : "whole");
a2331 2
      boolean pixel_center_integer =
         shader->info.base.properties[TGSI_PROPERTY_FS_COORD_PIXEL_CENTER];
d2342 1
a2342 1
                               pixel_center_integer,
d2441 2
a2560 1
   char module_name[64];
d2566 1
a2566 4
   util_snprintf(module_name, sizeof(module_name), "fs%u_variant%u",
                 shader->no, shader->variants_created);

   variant->gallivm = gallivm_create(module_name, lp->context);
a2627 2
   variant->nr_instrs += lp_build_count_ir_module(variant->gallivm->module);

a2641 2
   gallivm_free_ir(variant->gallivm);

d2766 2
d2778 9
d3176 2
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a1668 7
#if HAVE_LLVM < 0x0302
   /*
    * undef triggers a crash in LLVMBuildTrunc in convert_from_blend_type in some
    * cases (seen with r10g10b10a2, 128bit wide vectors) (only used for 1d case).
    */
   undef_src_val = lp_build_zero(gallivm, fs_type);
#else
a1669 1
#endif
d2155 1
a2155 1
   char func_name[256];
d2207 2
a2208 8
   cbuf0_write_all = FALSE;
   for (i = 0;i < shader->info.base.num_properties; i++) {
      if (shader->info.base.properties[i].name ==
          TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS) {
         cbuf0_write_all = TRUE;
         break;
      }
   }
d2236 2
a2237 2
   util_snprintf(func_name, sizeof(func_name), "fs%u_variant%u_%s", 
		 shader->no, variant->no, partial_mask ? "partial" : "whole");
d2318 2
d2330 1
a2330 1
                               shader->info.base.pixel_center_integer,
a2428 2

   variant->nr_instrs += lp_build_count_instructions(function);
d2547 1
d2553 4
a2556 1
   variant->gallivm = gallivm_create();
d2618 2
d2634 2
a2759 2
   unsigned i;

a2769 9
   /* free all the variant's JIT'd functions */
   for (i = 0; i < Elements(variant->function); i++) {
      if (variant->function[i]) {
         gallivm_free_function(variant->gallivm,
                               variant->function[i],
                               variant->jit_function[i]);
      }
   }

a3158 2

      llvmpipe_variant_count++;
@


