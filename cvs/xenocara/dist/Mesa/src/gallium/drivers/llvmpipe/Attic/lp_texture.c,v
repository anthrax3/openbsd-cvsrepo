head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.36;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.31;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.59;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.32;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.40;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2006 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  *   Michel DÃ¤nzer <daenzer@@vmware.com>
  */

#include <stdio.h>

#include "pipe/p_context.h"
#include "pipe/p_defines.h"

#include "util/u_inlines.h"
#include "util/u_cpu_detect.h"
#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_simple_list.h"
#include "util/u_transfer.h"

#include "lp_context.h"
#include "lp_flush.h"
#include "lp_screen.h"
#include "lp_texture.h"
#include "lp_setup.h"
#include "lp_state.h"
#include "lp_rast.h"

#include "state_tracker/sw_winsys.h"


#ifdef DEBUG
static struct llvmpipe_resource resource_list;
#endif
static unsigned id_counter = 0;


/**
 * Conventional allocation path for non-display textures:
 * Just compute row strides here.  Storage is allocated on demand later.
 */
static boolean
llvmpipe_texture_layout(struct llvmpipe_screen *screen,
                        struct llvmpipe_resource *lpr)
{
   struct pipe_resource *pt = &lpr->base;
   unsigned level;
   unsigned width = pt->width0;
   unsigned height = pt->height0;
   unsigned depth = pt->depth0;
   uint64_t total_size = 0;
   unsigned layers = pt->array_size;

   assert(LP_MAX_TEXTURE_2D_LEVELS <= LP_MAX_TEXTURE_LEVELS);
   assert(LP_MAX_TEXTURE_3D_LEVELS <= LP_MAX_TEXTURE_LEVELS);

   for (level = 0; level <= pt->last_level; level++) {

      /* Row stride and image stride */
      {
         unsigned align_x, align_y, nblocksx, nblocksy, block_size;

         /* For non-compressed formats we need 4x4 pixel alignment
          * so we can read/write LP_RASTER_BLOCK_SIZE when rendering to them.
          * We also want cache line size in x direction,
          * otherwise same cache line could end up in multiple threads.
          * For explicit 1d resources however we reduce this to 4x1 and
          * handle specially in render output code (as we need to do special
          * handling there for buffers in any case).
          */
         if (util_format_is_compressed(pt->format))
            align_x = align_y = 1;
         else {
            align_x = LP_RASTER_BLOCK_SIZE;
            if (llvmpipe_resource_is_1d(&lpr->base))
               align_y = 1;
            else
               align_y = LP_RASTER_BLOCK_SIZE;
         }

         nblocksx = util_format_get_nblocksx(pt->format,
                                             align(width, align_x));
         nblocksy = util_format_get_nblocksy(pt->format,
                                             align(height, align_y));
         block_size = util_format_get_blocksize(pt->format);

         if (util_format_is_compressed(pt->format))
            lpr->row_stride[level] = nblocksx * block_size;
         else
            lpr->row_stride[level] = align(nblocksx * block_size, util_cpu_caps.cacheline);

         /* if row_stride * height > LP_MAX_TEXTURE_SIZE */
         if ((uint64_t)lpr->row_stride[level] * nblocksy > LP_MAX_TEXTURE_SIZE) {
            /* image too large */
            goto fail;
         }

         lpr->img_stride[level] = lpr->row_stride[level] * nblocksy;
      }

      /* Number of 3D image slices, cube faces or texture array layers */
      {
         unsigned num_slices;

         if (lpr->base.target == PIPE_TEXTURE_CUBE)
            num_slices = 6;
         else if (lpr->base.target == PIPE_TEXTURE_3D)
            num_slices = depth;
         else if (lpr->base.target == PIPE_TEXTURE_1D_ARRAY ||
                  lpr->base.target == PIPE_TEXTURE_2D_ARRAY)
            num_slices = layers;
         else
            num_slices = 1;

         lpr->num_slices_faces[level] = num_slices;
      }

      /* if img_stride * num_slices_faces > LP_MAX_TEXTURE_SIZE */
      if (lpr->img_stride[level] >
          LP_MAX_TEXTURE_SIZE / lpr->num_slices_faces[level]) {
         /* volume too large */
         goto fail;
      }

      total_size += (uint64_t) lpr->num_slices_faces[level]
                  * (uint64_t) lpr->img_stride[level];
      if (total_size > LP_MAX_TEXTURE_SIZE) {
         goto fail;
      }

      /* Compute size of next mipmap level */
      width = u_minify(width, 1);
      height = u_minify(height, 1);
      depth = u_minify(depth, 1);
   }

   return TRUE;

fail:
   return FALSE;
}


/**
 * Check the size of the texture specified by 'res'.
 * \return TRUE if OK, FALSE if too large.
 */
static boolean
llvmpipe_can_create_resource(struct pipe_screen *screen,
                             const struct pipe_resource *res)
{
   struct llvmpipe_resource lpr;
   memset(&lpr, 0, sizeof(lpr));
   lpr.base = *res;
   return llvmpipe_texture_layout(llvmpipe_screen(screen), &lpr);
}


static boolean
llvmpipe_displaytarget_layout(struct llvmpipe_screen *screen,
                              struct llvmpipe_resource *lpr)
{
   struct sw_winsys *winsys = screen->winsys;

   /* Round up the surface size to a multiple of the tile size to
    * avoid tile clipping.
    */
   const unsigned width = MAX2(1, align(lpr->base.width0, TILE_SIZE));
   const unsigned height = MAX2(1, align(lpr->base.height0, TILE_SIZE));

   lpr->num_slices_faces[0] = 1;
   lpr->img_stride[0] = 0;

   lpr->dt = winsys->displaytarget_create(winsys,
                                          lpr->base.bind,
                                          lpr->base.format,
                                          width, height,
                                          64,
                                          &lpr->row_stride[0] );

   if (lpr->dt == NULL)
      return FALSE;

   {
      void *map = winsys->displaytarget_map(winsys, lpr->dt,
                                            PIPE_TRANSFER_WRITE);

      if (map)
         memset(map, 0, height * lpr->row_stride[0]);

      winsys->displaytarget_unmap(winsys, lpr->dt);
   }

   return TRUE;
}


static struct pipe_resource *
llvmpipe_resource_create(struct pipe_screen *_screen,
                         const struct pipe_resource *templat)
{
   struct llvmpipe_screen *screen = llvmpipe_screen(_screen);
   struct llvmpipe_resource *lpr = CALLOC_STRUCT(llvmpipe_resource);
   if (!lpr)
      return NULL;

   lpr->base = *templat;
   pipe_reference_init(&lpr->base.reference, 1);
   lpr->base.screen = &screen->base;

   /* assert(lpr->base.bind); */

   if (llvmpipe_resource_is_texture(&lpr->base)) {
      if (lpr->base.bind & (PIPE_BIND_DISPLAY_TARGET |
                            PIPE_BIND_SCANOUT |
                            PIPE_BIND_SHARED)) {
         /* displayable surface */
         if (!llvmpipe_displaytarget_layout(screen, lpr))
            goto fail;
      }
      else {
         /* texture map */
         if (!llvmpipe_texture_layout(screen, lpr))
            goto fail;
      }
   }
   else {
      /* other data (vertex buffer, const buffer, etc) */
      const uint bytes = templat->width0;
      assert(util_format_get_blocksize(templat->format) == 1);
      assert(templat->height0 == 1);
      assert(templat->depth0 == 1);
      assert(templat->last_level == 0);
      /*
       * Reserve some extra storage since if we'd render to a buffer we
       * read/write always LP_RASTER_BLOCK_SIZE pixels, but the element
       * offset doesn't need to be aligned to LP_RASTER_BLOCK_SIZE.
       */
      lpr->data = align_malloc(bytes + (LP_RASTER_BLOCK_SIZE - 1) * 4 * sizeof(float), 64);
      /*
       * buffers don't really have stride but it's probably safer
       * (for code doing same calculations for buffers and textures)
       * to put something sane in there.
       */
      lpr->row_stride[0] = bytes;
      if (!lpr->data)
         goto fail;
      memset(lpr->data, 0, bytes);
   }

   lpr->id = id_counter++;

#ifdef DEBUG
   insert_at_tail(&resource_list, lpr);
#endif

   return &lpr->base;

 fail:
   FREE(lpr);
   return NULL;
}


static void
llvmpipe_resource_destroy(struct pipe_screen *pscreen,
                          struct pipe_resource *pt)
{
   struct llvmpipe_screen *screen = llvmpipe_screen(pscreen);
   struct llvmpipe_resource *lpr = llvmpipe_resource(pt);

   if (lpr->dt) {
      /* display target */
      struct sw_winsys *winsys = screen->winsys;
      winsys->displaytarget_destroy(winsys, lpr->dt);
   }
   else if (llvmpipe_resource_is_texture(pt)) {
      /* free linear image data */
      if (lpr->linear_img.data) {
         align_free(lpr->linear_img.data);
         lpr->linear_img.data = NULL;
      }
   }
   else if (!lpr->userBuffer) {
      assert(lpr->data);
      align_free(lpr->data);
   }

#ifdef DEBUG
   if (lpr->next)
      remove_from_list(lpr);
#endif

   FREE(lpr);
}


/**
 * Map a resource for read/write.
 */
void *
llvmpipe_resource_map(struct pipe_resource *resource,
                      unsigned level,
                      unsigned layer,
                      enum lp_texture_usage tex_usage)
{
   struct llvmpipe_resource *lpr = llvmpipe_resource(resource);
   uint8_t *map;

   assert(level < LP_MAX_TEXTURE_LEVELS);
   assert(layer < (u_minify(resource->depth0, level) + resource->array_size - 1));

   assert(tex_usage == LP_TEX_USAGE_READ ||
          tex_usage == LP_TEX_USAGE_READ_WRITE ||
          tex_usage == LP_TEX_USAGE_WRITE_ALL);

   if (lpr->dt) {
      /* display target */
      struct llvmpipe_screen *screen = llvmpipe_screen(resource->screen);
      struct sw_winsys *winsys = screen->winsys;
      unsigned dt_usage;

      if (tex_usage == LP_TEX_USAGE_READ) {
         dt_usage = PIPE_TRANSFER_READ;
      }
      else {
         dt_usage = PIPE_TRANSFER_READ_WRITE;
      }

      assert(level == 0);
      assert(layer == 0);

      /* FIXME: keep map count? */
      map = winsys->displaytarget_map(winsys, lpr->dt, dt_usage);

      /* install this linear image in texture data structure */
      lpr->linear_img.data = map;

      return map;
   }
   else if (llvmpipe_resource_is_texture(resource)) {

      map = llvmpipe_get_texture_image(lpr, layer, level, tex_usage);
      return map;
   }
   else {
      return lpr->data;
   }
}


/**
 * Unmap a resource.
 */
void
llvmpipe_resource_unmap(struct pipe_resource *resource,
                       unsigned level,
                       unsigned layer)
{
   struct llvmpipe_resource *lpr = llvmpipe_resource(resource);

   if (lpr->dt) {
      /* display target */
      struct llvmpipe_screen *lp_screen = llvmpipe_screen(resource->screen);
      struct sw_winsys *winsys = lp_screen->winsys;

      assert(level == 0);
      assert(layer == 0);

      winsys->displaytarget_unmap(winsys, lpr->dt);
   }
}


void *
llvmpipe_resource_data(struct pipe_resource *resource)
{
   struct llvmpipe_resource *lpr = llvmpipe_resource(resource);

   assert(!llvmpipe_resource_is_texture(resource));

   return lpr->data;
}


static struct pipe_resource *
llvmpipe_resource_from_handle(struct pipe_screen *screen,
                              const struct pipe_resource *template,
                              struct winsys_handle *whandle)
{
   struct sw_winsys *winsys = llvmpipe_screen(screen)->winsys;
   struct llvmpipe_resource *lpr;

   /* XXX Seems like from_handled depth textures doesn't work that well */

   lpr = CALLOC_STRUCT(llvmpipe_resource);
   if (!lpr) {
      goto no_lpr;
   }

   lpr->base = *template;
   pipe_reference_init(&lpr->base.reference, 1);
   lpr->base.screen = screen;

   /*
    * Looks like unaligned displaytargets work just fine,
    * at least sampler/render ones.
    */
#if 0
   assert(lpr->base.width0 == width);
   assert(lpr->base.height0 == height);
#endif

   lpr->num_slices_faces[0] = 1;
   lpr->img_stride[0] = 0;

   lpr->dt = winsys->displaytarget_from_handle(winsys,
                                               template,
                                               whandle,
                                               &lpr->row_stride[0]);
   if (!lpr->dt) {
      goto no_dt;
   }

   lpr->id = id_counter++;

#ifdef DEBUG
   insert_at_tail(&resource_list, lpr);
#endif

   return &lpr->base;

no_dt:
   FREE(lpr);
no_lpr:
   return NULL;
}


static boolean
llvmpipe_resource_get_handle(struct pipe_screen *screen,
                            struct pipe_resource *pt,
                            struct winsys_handle *whandle)
{
   struct sw_winsys *winsys = llvmpipe_screen(screen)->winsys;
   struct llvmpipe_resource *lpr = llvmpipe_resource(pt);

   assert(lpr->dt);
   if (!lpr->dt)
      return FALSE;

   return winsys->displaytarget_get_handle(winsys, lpr->dt, whandle);
}


static void *
llvmpipe_transfer_map( struct pipe_context *pipe,
                       struct pipe_resource *resource,
                       unsigned level,
                       unsigned usage,
                       const struct pipe_box *box,
                       struct pipe_transfer **transfer )
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   struct llvmpipe_screen *screen = llvmpipe_screen(pipe->screen);
   struct llvmpipe_resource *lpr = llvmpipe_resource(resource);
   struct llvmpipe_transfer *lpt;
   struct pipe_transfer *pt;
   ubyte *map;
   enum pipe_format format;
   enum lp_texture_usage tex_usage;
   const char *mode;

   assert(resource);
   assert(level <= resource->last_level);

   /*
    * Transfers, like other pipe operations, must happen in order, so flush the
    * context if necessary.
    */
   if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED)) {
      boolean read_only = !(usage & PIPE_TRANSFER_WRITE);
      boolean do_not_block = !!(usage & PIPE_TRANSFER_DONTBLOCK);
      if (!llvmpipe_flush_resource(pipe, resource,
                                   level,
                                   read_only,
                                   TRUE, /* cpu_access */
                                   do_not_block,
                                   __FUNCTION__)) {
         /*
          * It would have blocked, but state tracker requested no to.
          */
         assert(do_not_block);
         return NULL;
      }
   }

   /* Check if we're mapping the current constant buffer */
   if ((usage & PIPE_TRANSFER_WRITE) &&
       (resource->bind & PIPE_BIND_CONSTANT_BUFFER)) {
      unsigned i;
      for (i = 0; i < Elements(llvmpipe->constants[PIPE_SHADER_FRAGMENT]); ++i) {
         if (resource == llvmpipe->constants[PIPE_SHADER_FRAGMENT][i].buffer) {
            /* constants may have changed */
            llvmpipe->dirty |= LP_NEW_CONSTANTS;
            break;
         }
      }
   }

   lpt = CALLOC_STRUCT(llvmpipe_transfer);
   if (!lpt)
      return NULL;
   pt = &lpt->base;
   pipe_resource_reference(&pt->resource, resource);
   pt->box = *box;
   pt->level = level;
   pt->stride = lpr->row_stride[level];
   pt->layer_stride = lpr->img_stride[level];
   pt->usage = usage;
   *transfer = pt;

   assert(level < LP_MAX_TEXTURE_LEVELS);

   /*
   printf("tex_transfer_map(%d, %d  %d x %d of %d x %d,  usage %d )\n",
          transfer->x, transfer->y, transfer->width, transfer->height,
          transfer->texture->width0,
          transfer->texture->height0,
          transfer->usage);
   */

   if (usage == PIPE_TRANSFER_READ) {
      tex_usage = LP_TEX_USAGE_READ;
      mode = "read";
   }
   else {
      tex_usage = LP_TEX_USAGE_READ_WRITE;
      mode = "read/write";
   }

   if (0) {
      printf("transfer map tex %u  mode %s\n", lpr->id, mode);
   }

   format = lpr->base.format;

   map = llvmpipe_resource_map(resource,
                               level,
                               box->z,
                               tex_usage);


   /* May want to do different things here depending on read/write nature
    * of the map:
    */
   if (usage & PIPE_TRANSFER_WRITE) {
      /* Do something to notify sharing contexts of a texture change.
       */
      screen->timestamp++;
   }

   map +=
      box->y / util_format_get_blockheight(format) * pt->stride +
      box->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);

   return map;
}


static void
llvmpipe_transfer_unmap(struct pipe_context *pipe,
                        struct pipe_transfer *transfer)
{
   assert(transfer->resource);

   llvmpipe_resource_unmap(transfer->resource,
                           transfer->level,
                           transfer->box.z);

   /* Effectively do the texture_update work here - if texture images
    * needed post-processing to put them into hardware layout, this is
    * where it would happen.  For llvmpipe, nothing to do.
    */
   assert (transfer->resource);
   pipe_resource_reference(&transfer->resource, NULL);
   FREE(transfer);
}

unsigned int
llvmpipe_is_resource_referenced( struct pipe_context *pipe,
                                 struct pipe_resource *presource,
                                 unsigned level)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context( pipe );

   /*
    * XXX checking only resources with the right bind flags
    * is unsafe since with opengl state tracker we can end up
    * with resources bound to places they weren't supposed to be
    * (buffers bound as sampler views is one possibility here).
    */
   if (!(presource->bind & (PIPE_BIND_DEPTH_STENCIL |
                            PIPE_BIND_RENDER_TARGET |
                            PIPE_BIND_SAMPLER_VIEW)))
      return LP_UNREFERENCED;

   return lp_setup_is_resource_referenced(llvmpipe->setup, presource);
}


/**
 * Returns the largest possible alignment for a format in llvmpipe
 */
unsigned
llvmpipe_get_format_alignment( enum pipe_format format )
{
   const struct util_format_description *desc = util_format_description(format);
   unsigned size = 0;
   unsigned bytes;
   unsigned i;

   for (i = 0; i < desc->nr_channels; ++i) {
      size += desc->channel[i].size;
   }

   bytes = size / 8;

   if (!util_is_power_of_two(bytes)) {
      bytes /= desc->nr_channels;
   }

   if (bytes % 2 || bytes < 1) {
      return 1;
   } else {
      return bytes;
   }
}


/**
 * Create buffer which wraps user-space data.
 */
struct pipe_resource *
llvmpipe_user_buffer_create(struct pipe_screen *screen,
                            void *ptr,
                            unsigned bytes,
			    unsigned bind_flags)
{
   struct llvmpipe_resource *buffer;

   buffer = CALLOC_STRUCT(llvmpipe_resource);
   if(!buffer)
      return NULL;

   pipe_reference_init(&buffer->base.reference, 1);
   buffer->base.screen = screen;
   buffer->base.format = PIPE_FORMAT_R8_UNORM; /* ?? */
   buffer->base.bind = bind_flags;
   buffer->base.usage = PIPE_USAGE_IMMUTABLE;
   buffer->base.flags = 0;
   buffer->base.width0 = bytes;
   buffer->base.height0 = 1;
   buffer->base.depth0 = 1;
   buffer->base.array_size = 1;
   buffer->userBuffer = TRUE;
   buffer->data = ptr;

   return &buffer->base;
}


/**
 * Compute size (in bytes) need to store a texture image / mipmap level,
 * for just one cube face, one array layer or one 3D texture slice
 */
static unsigned
tex_image_face_size(const struct llvmpipe_resource *lpr, unsigned level)
{
   return lpr->img_stride[level];
}


/**
 * Compute size (in bytes) need to store a texture image / mipmap level,
 * including all cube faces or 3D image slices
 */
static unsigned
tex_image_size(const struct llvmpipe_resource *lpr, unsigned level)
{
   const unsigned buf_size = tex_image_face_size(lpr, level);
   return buf_size * lpr->num_slices_faces[level];
}


/**
 * Return pointer to a 2D texture image/face/slice.
 * No tiled/linear conversion is done.
 */
ubyte *
llvmpipe_get_texture_image_address(struct llvmpipe_resource *lpr,
                                   unsigned face_slice, unsigned level)
{
   struct llvmpipe_texture_image *img;
   unsigned offset;

   img = &lpr->linear_img;
   offset = lpr->linear_mip_offsets[level];

   if (face_slice > 0)
      offset += face_slice * tex_image_face_size(lpr, level);

   return (ubyte *) img->data + offset;
}


/**
 * Allocate storage for a linear image
 * (all cube faces and all 3D slices, all levels).
 */
static void
alloc_image_data(struct llvmpipe_resource *lpr)
{
   uint alignment = MAX2(64, util_cpu_caps.cacheline);
   uint level;
   uint offset = 0;

   if (lpr->dt) {
      /* we get the linear memory from the winsys, and it has
       * already been zeroed
       */
      struct llvmpipe_screen *screen = llvmpipe_screen(lpr->base.screen);
      struct sw_winsys *winsys = screen->winsys;

      assert(lpr->base.last_level == 0);

      lpr->linear_img.data =
         winsys->displaytarget_map(winsys, lpr->dt,
                                   PIPE_TRANSFER_READ_WRITE);
   }
   else {
      /* not a display target - allocate regular memory */
      /*
       * Offset calculation for start of a specific mip/layer is always
       * offset = lpr->linear_mip_offsets[level] + lpr->img_stride[level] * layer
       */
      for (level = 0; level <= lpr->base.last_level; level++) {
         uint buffer_size = tex_image_size(lpr, level);
         lpr->linear_mip_offsets[level] = offset;
         offset += align(buffer_size, alignment);
      }
      lpr->linear_img.data = align_malloc(offset, alignment);
      if (lpr->linear_img.data) {
         memset(lpr->linear_img.data, 0, offset);
      }
   }
}



/**
 * Return pointer to texture image data
 * for a particular cube face or 3D texture slice.
 *
 * \param face_slice  the cube face or 3D slice of interest
 * \param usage  one of LP_TEX_USAGE_READ/WRITE_ALL/READ_WRITE
 */
void *
llvmpipe_get_texture_image(struct llvmpipe_resource *lpr,
                           unsigned face_slice, unsigned level,
                           enum lp_texture_usage usage)
{
   struct llvmpipe_texture_image *target_img;
   void *target_data;
   unsigned target_offset;
   unsigned *target_off_ptr;

   assert(usage == LP_TEX_USAGE_READ ||
          usage == LP_TEX_USAGE_READ_WRITE ||
          usage == LP_TEX_USAGE_WRITE_ALL);

   if (lpr->dt) {
      assert(lpr->linear_img.data);
   }

   target_img = &lpr->linear_img;
   target_off_ptr = lpr->linear_mip_offsets;
   target_data = target_img->data;

   if (!target_data) {
      /* allocate memory for the target image now */
      alloc_image_data(lpr);
      target_data = target_img->data;
   }

   target_offset = target_off_ptr[level];

   if (face_slice > 0) {
      target_offset += face_slice * tex_image_face_size(lpr, level);
   }

   if (target_data) {
      target_data = (uint8_t *) target_data + target_offset;
   }

   return target_data;
}


/**
 * Return pointer to start of a texture image (1D, 2D, 3D, CUBE).
 * This is typically used when we're about to sample from a texture.
 */
void *
llvmpipe_get_texture_image_all(struct llvmpipe_resource *lpr,
                               unsigned level,
                               enum lp_texture_usage usage)
{
   const int slices = lpr->num_slices_faces[level];
   int slice;
   void *map = NULL;

   assert(slices > 0);

   for (slice = slices - 1; slice >= 0; slice--) {
      map = llvmpipe_get_texture_image(lpr, slice, level, usage);
   }

   return map;
}


/**
 * Get pointer to a linear image (not the tile!) at tile (x,y).
 * \return pointer to start of image/face (not the tile)
 */
ubyte *
llvmpipe_get_texture_tile_linear(struct llvmpipe_resource *lpr,
                                 unsigned face_slice, unsigned level,
                                 enum lp_texture_usage usage,
                                 unsigned x, unsigned y)
{
   struct llvmpipe_texture_image *linear_img = &lpr->linear_img;
   uint8_t *linear_image;

   assert(llvmpipe_resource_is_texture(&lpr->base));
   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   if (!linear_img->data) {
      /* allocate memory for the linear image now */
      /* XXX should probably not do that here? */
      alloc_image_data(lpr);
   }
   assert(linear_img->data);

   /* compute address of the slice/face of the image that contains the tile */
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level);

   return linear_image;
}


/**
 * Return size of resource in bytes
 */
unsigned
llvmpipe_resource_size(const struct pipe_resource *resource)
{
   const struct llvmpipe_resource *lpr = llvmpipe_resource_const(resource);
   unsigned lvl, size = 0;

   if (llvmpipe_resource_is_texture(resource)) {
      for (lvl = 0; lvl <= lpr->base.last_level; lvl++) {
         if (lpr->linear_img.data)
            size += tex_image_size(lpr, lvl);
      }
   }
   else {
      size = resource->width0;
   }

   return size;
}


#ifdef DEBUG
void
llvmpipe_print_resources(void)
{
   struct llvmpipe_resource *lpr;
   unsigned n = 0, total = 0;

   debug_printf("LLVMPIPE: current resources:\n");
   foreach(lpr, &resource_list) {
      unsigned size = llvmpipe_resource_size(&lpr->base);
      debug_printf("resource %u at %p, size %ux%ux%u: %u bytes, refcount %u\n",
                   lpr->id, (void *) lpr,
                   lpr->base.width0, lpr->base.height0, lpr->base.depth0,
                   size, lpr->base.reference.count);
      total += size;
      n++;
   }
   debug_printf("LLVMPIPE: total size of %u resources: %u\n", n, total);
}
#endif


void
llvmpipe_init_screen_resource_funcs(struct pipe_screen *screen)
{
#ifdef DEBUG
   /* init linked list for tracking resources */
   {
      static boolean first_call = TRUE;
      if (first_call) {
         memset(&resource_list, 0, sizeof(resource_list));
         make_empty_list(&resource_list);
         first_call = FALSE;
      }
   }
#endif

   screen->resource_create = llvmpipe_resource_create;
   screen->resource_destroy = llvmpipe_resource_destroy;
   screen->resource_from_handle = llvmpipe_resource_from_handle;
   screen->resource_get_handle = llvmpipe_resource_get_handle;
   screen->can_create_resource = llvmpipe_can_create_resource;
}


void
llvmpipe_init_context_resource_funcs(struct pipe_context *pipe)
{
   pipe->transfer_map = llvmpipe_transfer_map;
   pipe->transfer_unmap = llvmpipe_transfer_unmap;

   pipe->transfer_flush_region = u_default_transfer_flush_region;
   pipe->transfer_inline_write = u_default_transfer_inline_write;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d65 1
a65 1
 * Compute strides and allocate data (unless asked not to).
d69 1
a69 2
                        struct llvmpipe_resource *lpr,
                        boolean allocate)
a77 8
   /* XXX:
    * This alignment here (same for displaytarget) was added for the purpose of
    * ARB_map_buffer_alignment. I am not convinced it's needed for non-buffer
    * resources. Otherwise we'd want the max of cacheline size and 16 (max size
    * of a block for all formats) though this should not be strictly necessary
    * neither. In any case it can only affect compressed or 1d textures.
    */
   unsigned mip_align = MAX2(64, util_cpu_caps.cacheline);
a82 2
      uint64_t mipsize;
      unsigned align_x, align_y, nblocksx, nblocksy, block_size, num_slices;
d85 20
d106 8
a113 14
      /* For non-compressed formats we need 4x4 pixel alignment
       * so we can read/write LP_RASTER_BLOCK_SIZE when rendering to them.
       * We also want cache line size in x direction,
       * otherwise same cache line could end up in multiple threads.
       * For explicit 1d resources however we reduce this to 4x1 and
       * handle specially in render output code (as we need to do special
       * handling there for buffers in any case).
       */
      if (util_format_is_compressed(pt->format))
         align_x = align_y = 1;
      else {
         align_x = LP_RASTER_BLOCK_SIZE;
         if (llvmpipe_resource_is_1d(&lpr->base))
            align_y = 1;
d115 9
a123 1
            align_y = LP_RASTER_BLOCK_SIZE;
d126 3
a128 16
      nblocksx = util_format_get_nblocksx(pt->format,
                                          align(width, align_x));
      nblocksy = util_format_get_nblocksy(pt->format,
                                          align(height, align_y));
      block_size = util_format_get_blocksize(pt->format);

      if (util_format_is_compressed(pt->format))
         lpr->row_stride[level] = nblocksx * block_size;
      else
         lpr->row_stride[level] = align(nblocksx * block_size, util_cpu_caps.cacheline);

      /* if row_stride * height > LP_MAX_TEXTURE_SIZE */
      if ((uint64_t)lpr->row_stride[level] * nblocksy > LP_MAX_TEXTURE_SIZE) {
         /* image too large */
         goto fail;
      }
d130 9
a138 1
      lpr->img_stride[level] = lpr->row_stride[level] * nblocksy;
d140 1
a140 3
      /* Number of 3D image slices, cube faces or texture array layers */
      if (lpr->base.target == PIPE_TEXTURE_CUBE) {
         assert(layers == 6);
a142 10
      if (lpr->base.target == PIPE_TEXTURE_3D)
         num_slices = depth;
      else if (lpr->base.target == PIPE_TEXTURE_1D_ARRAY ||
               lpr->base.target == PIPE_TEXTURE_2D_ARRAY ||
               lpr->base.target == PIPE_TEXTURE_CUBE ||
               lpr->base.target == PIPE_TEXTURE_CUBE_ARRAY)
         num_slices = layers;
      else
         num_slices = 1;

d144 2
a145 2
      mipsize = (uint64_t)lpr->img_stride[level] * num_slices;
      if (mipsize > LP_MAX_TEXTURE_SIZE) {
d150 2
a151 3
      lpr->mip_offsets[level] = total_size;

      total_size += align((unsigned)mipsize, mip_align);
a161 10
   if (allocate) {
      lpr->tex_data = align_malloc(total_size, mip_align);
      if (!lpr->tex_data) {
         return FALSE;
      }
      else {
         memset(lpr->tex_data, 0, total_size);
      }
   }

d180 1
a180 1
   return llvmpipe_texture_layout(llvmpipe_screen(screen), &lpr, false);
d196 3
d248 1
a248 1
         if (!llvmpipe_texture_layout(screen, lpr, true))
a264 1

d304 3
a306 3
      if (lpr->tex_data) {
         align_free(lpr->tex_data);
         lpr->tex_data = NULL;
d362 1
a362 1
      lpr->tex_data = map;
d368 1
a368 1
      map = llvmpipe_get_texture_image_address(lpr, layer, level);
d439 3
d673 1
a673 1
                            unsigned bind_flags)
d710 12
d729 1
d732 139
d872 2
d875 6
a880 1
   offset = lpr->mip_offsets[level];
d882 2
a883 2
   if (face_slice > 0)
      offset += face_slice * tex_image_face_size(lpr, level);
d885 1
a885 1
   return (ubyte *) lpr->tex_data + offset;
d896 1
a896 1
   unsigned size = 0;
d899 4
a902 2
      /* Note this will always return 0 for displaytarget resources */
      size = lpr->total_alloc_size;
d907 1
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d65 1
a65 1
 * Just compute row strides here.  Storage is allocated on demand later.
d69 2
a70 1
                        struct llvmpipe_resource *lpr)
d79 8
d92 2
a95 2
      {
         unsigned align_x, align_y, nblocksx, nblocksy, block_size;
d97 14
a110 26
         /* For non-compressed formats we need 4x4 pixel alignment
          * so we can read/write LP_RASTER_BLOCK_SIZE when rendering to them.
          * We also want cache line size in x direction,
          * otherwise same cache line could end up in multiple threads.
          * For explicit 1d resources however we reduce this to 4x1 and
          * handle specially in render output code (as we need to do special
          * handling there for buffers in any case).
          */
         if (util_format_is_compressed(pt->format))
            align_x = align_y = 1;
         else {
            align_x = LP_RASTER_BLOCK_SIZE;
            if (llvmpipe_resource_is_1d(&lpr->base))
               align_y = 1;
            else
               align_y = LP_RASTER_BLOCK_SIZE;
         }

         nblocksx = util_format_get_nblocksx(pt->format,
                                             align(width, align_x));
         nblocksy = util_format_get_nblocksy(pt->format,
                                             align(height, align_y));
         block_size = util_format_get_blocksize(pt->format);

         if (util_format_is_compressed(pt->format))
            lpr->row_stride[level] = nblocksx * block_size;
d112 2
a113 1
            lpr->row_stride[level] = align(nblocksx * block_size, util_cpu_caps.cacheline);
d115 16
a130 5
         /* if row_stride * height > LP_MAX_TEXTURE_SIZE */
         if ((uint64_t)lpr->row_stride[level] * nblocksy > LP_MAX_TEXTURE_SIZE) {
            /* image too large */
            goto fail;
         }
d132 1
a132 2
         lpr->img_stride[level] = lpr->row_stride[level] * nblocksy;
      }
d135 3
a137 12
      {
         unsigned num_slices;

         if (lpr->base.target == PIPE_TEXTURE_CUBE)
            num_slices = 6;
         else if (lpr->base.target == PIPE_TEXTURE_3D)
            num_slices = depth;
         else if (lpr->base.target == PIPE_TEXTURE_1D_ARRAY ||
                  lpr->base.target == PIPE_TEXTURE_2D_ARRAY)
            num_slices = layers;
         else
            num_slices = 1;
d139 9
a147 2
         lpr->num_slices_faces[level] = num_slices;
      }
d150 2
a151 2
      if (lpr->img_stride[level] >
          LP_MAX_TEXTURE_SIZE / lpr->num_slices_faces[level]) {
d156 3
a158 2
      total_size += (uint64_t) lpr->num_slices_faces[level]
                  * (uint64_t) lpr->img_stride[level];
d169 10
d197 1
a197 1
   return llvmpipe_texture_layout(llvmpipe_screen(screen), &lpr);
a212 3
   lpr->num_slices_faces[0] = 1;
   lpr->img_stride[0] = 0;

d262 1
a262 1
         if (!llvmpipe_texture_layout(screen, lpr))
d279 1
d319 3
a321 3
      if (lpr->linear_img.data) {
         align_free(lpr->linear_img.data);
         lpr->linear_img.data = NULL;
d377 1
a377 1
      lpr->linear_img.data = map;
d383 1
a383 1
      map = llvmpipe_get_texture_image(lpr, layer, level, tex_usage);
a453 3
   lpr->num_slices_faces[0] = 1;
   lpr->img_stride[0] = 0;

d685 1
a685 1
			    unsigned bind_flags)
a721 12
 * Compute size (in bytes) need to store a texture image / mipmap level,
 * including all cube faces or 3D image slices
 */
static unsigned
tex_image_size(const struct llvmpipe_resource *lpr, unsigned level)
{
   const unsigned buf_size = tex_image_face_size(lpr, level);
   return buf_size * lpr->num_slices_faces[level];
}


/**
a728 1
   struct llvmpipe_texture_image *img;
d731 3
a733 2
   img = &lpr->linear_img;
   offset = lpr->linear_mip_offsets[level];
d738 1
a738 148
   return (ubyte *) img->data + offset;
}


/**
 * Allocate storage for a linear image
 * (all cube faces and all 3D slices, all levels).
 */
static void
alloc_image_data(struct llvmpipe_resource *lpr)
{
   uint alignment = MAX2(64, util_cpu_caps.cacheline);
   uint level;
   uint offset = 0;

   if (lpr->dt) {
      /* we get the linear memory from the winsys, and it has
       * already been zeroed
       */
      struct llvmpipe_screen *screen = llvmpipe_screen(lpr->base.screen);
      struct sw_winsys *winsys = screen->winsys;

      assert(lpr->base.last_level == 0);

      lpr->linear_img.data =
         winsys->displaytarget_map(winsys, lpr->dt,
                                   PIPE_TRANSFER_READ_WRITE);
   }
   else {
      /* not a display target - allocate regular memory */
      /*
       * Offset calculation for start of a specific mip/layer is always
       * offset = lpr->linear_mip_offsets[level] + lpr->img_stride[level] * layer
       */
      for (level = 0; level <= lpr->base.last_level; level++) {
         uint buffer_size = tex_image_size(lpr, level);
         lpr->linear_mip_offsets[level] = offset;
         offset += align(buffer_size, alignment);
      }
      lpr->linear_img.data = align_malloc(offset, alignment);
      if (lpr->linear_img.data) {
         memset(lpr->linear_img.data, 0, offset);
      }
   }
}



/**
 * Return pointer to texture image data
 * for a particular cube face or 3D texture slice.
 *
 * \param face_slice  the cube face or 3D slice of interest
 * \param usage  one of LP_TEX_USAGE_READ/WRITE_ALL/READ_WRITE
 */
void *
llvmpipe_get_texture_image(struct llvmpipe_resource *lpr,
                           unsigned face_slice, unsigned level,
                           enum lp_texture_usage usage)
{
   struct llvmpipe_texture_image *target_img;
   void *target_data;
   unsigned target_offset;
   unsigned *target_off_ptr;

   assert(usage == LP_TEX_USAGE_READ ||
          usage == LP_TEX_USAGE_READ_WRITE ||
          usage == LP_TEX_USAGE_WRITE_ALL);

   if (lpr->dt) {
      assert(lpr->linear_img.data);
   }

   target_img = &lpr->linear_img;
   target_off_ptr = lpr->linear_mip_offsets;
   target_data = target_img->data;

   if (!target_data) {
      /* allocate memory for the target image now */
      alloc_image_data(lpr);
      target_data = target_img->data;
   }

   target_offset = target_off_ptr[level];

   if (face_slice > 0) {
      target_offset += face_slice * tex_image_face_size(lpr, level);
   }

   if (target_data) {
      target_data = (uint8_t *) target_data + target_offset;
   }

   return target_data;
}


/**
 * Return pointer to start of a texture image (1D, 2D, 3D, CUBE).
 * This is typically used when we're about to sample from a texture.
 */
void *
llvmpipe_get_texture_image_all(struct llvmpipe_resource *lpr,
                               unsigned level,
                               enum lp_texture_usage usage)
{
   const int slices = lpr->num_slices_faces[level];
   int slice;
   void *map = NULL;

   assert(slices > 0);

   for (slice = slices - 1; slice >= 0; slice--) {
      map = llvmpipe_get_texture_image(lpr, slice, level, usage);
   }

   return map;
}


/**
 * Get pointer to a linear image (not the tile!) at tile (x,y).
 * \return pointer to start of image/face (not the tile)
 */
ubyte *
llvmpipe_get_texture_tile_linear(struct llvmpipe_resource *lpr,
                                 unsigned face_slice, unsigned level,
                                 enum lp_texture_usage usage,
                                 unsigned x, unsigned y)
{
   struct llvmpipe_texture_image *linear_img = &lpr->linear_img;
   uint8_t *linear_image;

   assert(llvmpipe_resource_is_texture(&lpr->base));
   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   if (!linear_img->data) {
      /* allocate memory for the linear image now */
      /* XXX should probably not do that here? */
      alloc_image_data(lpr);
   }
   assert(linear_img->data);

   /* compute address of the slice/face of the image that contains the tile */
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level);

   return linear_image;
d749 1
a749 1
   unsigned lvl, size = 0;
d752 2
a753 4
      for (lvl = 0; lvl <= lpr->base.last_level; lvl++) {
         if (lpr->linear_img.data)
            size += tex_image_size(lpr, lvl);
      }
a757 1

@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d29 2
a30 2
  *   Keith Whitwell <keith@@tungstengraphics.com>
  *   Michel DÃ¤nzer <michel@@tungstengraphics.com>
d118 1
a118 1
         if (lpr->row_stride[level] > LP_MAX_TEXTURE_SIZE / nblocksy) {
d203 1
a203 1
                                          16,
d264 1
a264 1
      lpr->data = align_malloc(bytes + (LP_RASTER_BLOCK_SIZE - 1) * 4 * sizeof(float), 16);
d749 1
a749 1
   uint alignment = MAX2(16, util_cpu_caps.cacheline);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a48 1
#include "lp_tile_image.h"
d52 1
a62 39
static INLINE boolean
resource_is_texture(const struct pipe_resource *resource)
{
   switch (resource->target) {
   case PIPE_BUFFER:
      return FALSE;
   case PIPE_TEXTURE_1D:
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
   case PIPE_TEXTURE_3D:
   case PIPE_TEXTURE_CUBE:
      return TRUE;
   default:
      assert(0);
      return FALSE;
   }
}



/**
 * Allocate storage for llvmpipe_texture::layout array.
 * The number of elements is width_in_tiles * height_in_tiles.
 */
static enum lp_texture_layout *
alloc_layout_array(unsigned num_slices, unsigned width, unsigned height)
{
   const unsigned tx = align(width, TILE_SIZE) / TILE_SIZE;
   const unsigned ty = align(height, TILE_SIZE) / TILE_SIZE;

   assert(num_slices * tx * ty > 0);
   assert(LP_TEX_LAYOUT_NONE == 0); /* calloc'ing LP_TEX_LAYOUT_NONE here */

   return (enum lp_texture_layout *)
      CALLOC(num_slices * tx * ty, sizeof(enum lp_texture_layout));
}



d76 2
d84 1
a84 1
      /* Row stride and image stride (for linear layout) */
d86 1
a86 1
         unsigned alignment, nblocksx, nblocksy, block_size;
d88 7
a94 2
         /* For non-compressed formats we need to align the texture size
          * to the tile size to facilitate render-to-texture.
d97 8
a104 3
            alignment = 1;
         else
            alignment = TILE_SIZE;
d107 1
a107 1
                                             align(width, alignment));
d109 1
a109 1
                                             align(height, alignment));
d112 10
a121 1
         lpr->row_stride[level] = align(nblocksx * block_size, 16);
d126 1
a126 9
      /* Size of the image in tiles (for tiled layout) */
      {
         const unsigned width_t = align(width, TILE_SIZE) / TILE_SIZE;
         const unsigned height_t = align(height, TILE_SIZE) / TILE_SIZE;
         lpr->tiles_per_row[level] = width_t;
         lpr->tiles_per_image[level] = width_t * height_t;
      }

      /* Number of 3D image slices or cube faces */
d134 3
d141 1
d143 11
a153 1
         lpr->layout[level] = alloc_layout_array(num_slices, width, height);
d163 3
d169 14
d193 2
a194 4
   const unsigned width = align(lpr->base.width0, TILE_SIZE);
   const unsigned height = align(lpr->base.height0, TILE_SIZE);
   const unsigned width_t = width / TILE_SIZE;
   const unsigned height_t = height / TILE_SIZE;
a195 2
   lpr->tiles_per_row[0] = width_t;
   lpr->tiles_per_image[0] = width_t * height_t;
a198 3
   lpr->layout[0] = alloc_layout_array(1, width, height);
   //lpr->layout[0][0] = LP_TEX_LAYOUT_LINEAR;

d206 14
a219 1
   return lpr->dt != NULL;
d238 4
a241 2
   if (resource_is_texture(&lpr->base)) {
      if (lpr->base.bind & PIPE_BIND_DISPLAY_TARGET) {
a244 1
         assert(lpr->layout[0][0] == LP_TEX_LAYOUT_NONE);
a249 1
         assert(lpr->layout[0][0] == LP_TEX_LAYOUT_NONE);
a250 1
      assert(lpr->layout[0]);
d254 17
a270 8
      const enum pipe_format format = templat->format;
      const uint w = templat->width0 / util_format_get_blockheight(format);
      /* XXX buffers should only have one dimension, those values should be 1 */
      const uint h = templat->height0 / util_format_get_blockwidth(format);
      const uint d = templat->depth0;
      const uint bpp = util_format_get_blocksize(format);
      const uint bytes = w * h * d * bpp;
      lpr->data = align_malloc(bytes, 16);
d273 1
d292 1
a292 1
			  struct pipe_resource *pt)
a300 7

      if (lpr->tiled[0].data) {
         align_free(lpr->tiled[0].data);
         lpr->tiled[0].data = NULL;
      }

      FREE(lpr->layout[0]);
d302 1
a302 4
   else if (resource_is_texture(pt)) {
      /* regular texture */
      uint level;

d304 3
a306 19
      for (level = 0; level < Elements(lpr->linear); level++) {
         if (lpr->linear[level].data) {
            align_free(lpr->linear[level].data);
            lpr->linear[level].data = NULL;
         }
      }

      /* free tiled image data */
      for (level = 0; level < Elements(lpr->tiled); level++) {
         if (lpr->tiled[level].data) {
            align_free(lpr->tiled[level].data);
            lpr->tiled[level].data = NULL;
         }
      }

      /* free layout flag arrays */
      for (level = 0; level < Elements(lpr->tiled); level++) {
         FREE(lpr->layout[level]);
         lpr->layout[level] = NULL;
d330 1
a330 2
                      enum lp_texture_usage tex_usage,
                      enum lp_texture_layout layout)
a341 4
   assert(layout == LP_TEX_LAYOUT_NONE ||
          layout == LP_TEX_LAYOUT_TILED ||
          layout == LP_TEX_LAYOUT_LINEAR);

a346 1
      uint8_t *map2;
d362 1
a362 1
      lpr->linear[level].data = map;
d364 1
a364 6
      /* make sure tiled data gets converted to linear data */
      map2 = llvmpipe_get_texture_image(lpr, 0, 0, tex_usage, layout);
      if (layout == LP_TEX_LAYOUT_LINEAR)
         assert(map == map2);

      return map2;
d366 1
a366 1
   else if (resource_is_texture(resource)) {
d368 1
a368 2
      map = llvmpipe_get_texture_image(lpr, layer, level,
                                       tex_usage, layout);
a394 5
      /* make sure linear image is up to date */
      (void) llvmpipe_get_texture_image(lpr, layer, level,
                                        LP_TEX_USAGE_READ,
                                        LP_TEX_LAYOUT_LINEAR);

d405 1
a405 1
   assert(!resource_is_texture(resource));
d413 2
a414 2
			      const struct pipe_resource *template,
			      struct winsys_handle *whandle)
d417 1
a417 2
   struct llvmpipe_resource *lpr = CALLOC_STRUCT(llvmpipe_resource);
   unsigned width, height, width_t, height_t;
d421 4
a424 2
   if (!lpr)
      return NULL;
a429 5
   width = align(lpr->base.width0, TILE_SIZE);
   height = align(lpr->base.height0, TILE_SIZE);
   width_t = width / TILE_SIZE;
   height_t = height / TILE_SIZE;

a438 2
   lpr->tiles_per_row[0] = width_t;
   lpr->tiles_per_image[0] = width_t * height_t;
d446 3
a448 7
   if (!lpr->dt)
      goto fail;

   lpr->layout[0] = alloc_layout_array(1, lpr->base.width0, lpr->base.height0);

   assert(lpr->layout[0]);
   assert(lpr->layout[0][0] == LP_TEX_LAYOUT_NONE);
d458 1
a458 1
 fail:
d460 1
d481 7
a487 47
static struct pipe_surface *
llvmpipe_create_surface(struct pipe_context *pipe,
                        struct pipe_resource *pt,
                        const struct pipe_surface *surf_tmpl)
{
   struct pipe_surface *ps;

   assert(surf_tmpl->u.tex.level <= pt->last_level);

   ps = CALLOC_STRUCT(pipe_surface);
   if (ps) {
      pipe_reference_init(&ps->reference, 1);
      pipe_resource_reference(&ps->texture, pt);
      ps->context = pipe;
      ps->format = surf_tmpl->format;
      ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
      ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
      ps->usage = surf_tmpl->usage;

      ps->u.tex.level = surf_tmpl->u.tex.level;
      ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
      ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
   }
   return ps;
}


static void 
llvmpipe_surface_destroy(struct pipe_context *pipe,
                         struct pipe_surface *surf)
{
   /* Effectively do the texture_update work here - if texture images
    * needed post-processing to put them into hardware layout, this is
    * where it would happen.  For llvmpipe, nothing to do.
    */
   assert(surf->texture);
   pipe_resource_reference(&surf->texture, NULL);
   FREE(surf);
}


static struct pipe_transfer *
llvmpipe_get_transfer(struct pipe_context *pipe,
                      struct pipe_resource *resource,
                      unsigned level,
                      unsigned usage,
                      const struct pipe_box *box)
d490 8
a497 2
   struct llvmpipe_resource *lprex = llvmpipe_resource(resource);
   struct llvmpipe_transfer *lpr;
a510 1
                                   box->depth > 1 ? -1 : box->z,
d523 11
a533 14
   if (resource == llvmpipe->constants[PIPE_SHADER_FRAGMENT][0])
      llvmpipe->dirty |= LP_NEW_CONSTANTS;

   lpr = CALLOC_STRUCT(llvmpipe_transfer);
   if (lpr) {
      struct pipe_transfer *pt = &lpr->base;
      pipe_resource_reference(&pt->resource, resource);
      pt->box = *box;
      pt->level = level;
      pt->stride = lprex->row_stride[level];
      pt->layer_stride = lprex->img_stride[level];
      pt->usage = usage;

      return pt;
a534 2
   return NULL;
}
d536 11
d548 1
a548 26
static void 
llvmpipe_transfer_destroy(struct pipe_context *pipe,
                              struct pipe_transfer *transfer)
{
   /* Effectively do the texture_update work here - if texture images
    * needed post-processing to put them into hardware layout, this is
    * where it would happen.  For llvmpipe, nothing to do.
    */
   assert (transfer->resource);
   pipe_resource_reference(&transfer->resource, NULL);
   FREE(transfer);
}


static void *
llvmpipe_transfer_map( struct pipe_context *pipe,
                       struct pipe_transfer *transfer )
{
   struct llvmpipe_screen *screen = llvmpipe_screen(pipe->screen);
   ubyte *map;
   struct llvmpipe_resource *lpr;
   enum pipe_format format;
   enum lp_texture_usage tex_usage;
   const char *mode;

   assert(transfer->level < LP_MAX_TEXTURE_LEVELS);
d558 1
a558 1
   if (transfer->usage == PIPE_TRANSFER_READ) {
a567 1
      struct llvmpipe_resource *lpr = llvmpipe_resource(transfer->resource);
a570 3

   assert(transfer->resource);
   lpr = llvmpipe_resource(transfer->resource);
d573 4
a576 4
   map = llvmpipe_resource_map(transfer->resource,
                               transfer->level,
                               transfer->box.z,
                               tex_usage, LP_TEX_LAYOUT_LINEAR);
d582 1
a582 1
   if (transfer->usage & PIPE_TRANSFER_WRITE) {
d589 2
a590 2
      transfer->box.y / util_format_get_blockheight(format) * transfer->stride +
      transfer->box.x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);
d605 8
d618 1
a618 1
                                 unsigned level, int layer)
d622 9
a630 1
   if (presource->target == PIPE_BUFFER)
d637 28
d669 1
a669 1
static struct pipe_resource *
d700 1
a700 1
 * for just one cube face or one 3D texture slice
d703 1
a703 2
tex_image_face_size(const struct llvmpipe_resource *lpr, unsigned level,
                    enum lp_texture_layout layout)
d705 1
a705 21
   const unsigned width = u_minify(lpr->base.width0, level);
   const unsigned height = u_minify(lpr->base.height0, level);

   assert(layout == LP_TEX_LAYOUT_TILED ||
          layout == LP_TEX_LAYOUT_LINEAR);

   if (layout == LP_TEX_LAYOUT_TILED) {
      /* for tiled layout, force a 32bpp format */
      const enum pipe_format format = PIPE_FORMAT_B8G8R8A8_UNORM;
      const unsigned block_size = util_format_get_blocksize(format);
      const unsigned nblocksy =
         util_format_get_nblocksy(format, align(height, TILE_SIZE));
      const unsigned nblocksx =
         util_format_get_nblocksx(format, align(width, TILE_SIZE));
      const unsigned buffer_size = block_size * nblocksy * nblocksx;
      return buffer_size;
   }
   else {
      /* we already computed this */
      return lpr->img_stride[level];
   }
d714 1
a714 2
tex_image_size(const struct llvmpipe_resource *lpr, unsigned level,
               enum lp_texture_layout layout)
d716 1
a716 1
   const unsigned buf_size = tex_image_face_size(lpr, level, layout);
a721 59
 * This function encapsulates some complicated logic for determining
 * how to convert a tile of image data from linear layout to tiled
 * layout, or vice versa.
 * \param cur_layout  the current tile layout
 * \param target_layout  the desired tile layout
 * \param usage  how the tile will be accessed (R/W vs. read-only, etc)
 * \param new_layout_return  returns the new layout mode
 * \param convert_return  returns TRUE if image conversion is needed
 */
static void
layout_logic(enum lp_texture_layout cur_layout,
             enum lp_texture_layout target_layout,
             enum lp_texture_usage usage,
             enum lp_texture_layout *new_layout_return,
             boolean *convert)
{
   enum lp_texture_layout other_layout, new_layout;

   *convert = FALSE;

   new_layout = 99; /* debug check */

   if (target_layout == LP_TEX_LAYOUT_LINEAR) {
      other_layout = LP_TEX_LAYOUT_TILED;
   }
   else {
      assert(target_layout == LP_TEX_LAYOUT_TILED);
      other_layout = LP_TEX_LAYOUT_LINEAR;
   }

   new_layout = target_layout;  /* may get changed below */

   if (cur_layout == LP_TEX_LAYOUT_BOTH) {
      if (usage == LP_TEX_USAGE_READ) {
         new_layout = LP_TEX_LAYOUT_BOTH;
      }
   }
   else if (cur_layout == other_layout) {
      if (usage != LP_TEX_USAGE_WRITE_ALL) {
         /* need to convert tiled data to linear or vice versa */
         *convert = TRUE;

         if (usage == LP_TEX_USAGE_READ)
            new_layout = LP_TEX_LAYOUT_BOTH;
      }
   }
   else {
      assert(cur_layout == LP_TEX_LAYOUT_NONE ||
             cur_layout == target_layout);
   }

   assert(new_layout == LP_TEX_LAYOUT_BOTH ||
          new_layout == target_layout);

   *new_layout_return = new_layout;
}


/**
d727 1
a727 2
                                   unsigned face_slice, unsigned level,
                                   enum lp_texture_layout layout)
d732 2
a733 7
   if (layout == LP_TEX_LAYOUT_LINEAR) {
      img = &lpr->linear[level];
   }
   else {
      assert (layout == LP_TEX_LAYOUT_TILED);
      img = &lpr->tiled[level];
   }
d736 1
a736 3
      offset = face_slice * tex_image_face_size(lpr, level, layout);
   else
      offset = 0;
a741 29
static INLINE enum lp_texture_layout
llvmpipe_get_texture_tile_layout(const struct llvmpipe_resource *lpr,
                                 unsigned face_slice, unsigned level,
                                 unsigned x, unsigned y)
{
   uint i;
   assert(resource_is_texture(&lpr->base));
   assert(x < lpr->tiles_per_row[level]);
   i = face_slice * lpr->tiles_per_image[level]
      + y * lpr->tiles_per_row[level] + x;
   return lpr->layout[level][i];
}


static INLINE void
llvmpipe_set_texture_tile_layout(struct llvmpipe_resource *lpr,
                                 unsigned face_slice, unsigned level,
                                 unsigned x, unsigned y,
                                 enum lp_texture_layout layout)
{
   uint i;
   assert(resource_is_texture(&lpr->base));
   assert(x < lpr->tiles_per_row[level]);
   i = face_slice * lpr->tiles_per_image[level]
      + y * lpr->tiles_per_row[level] + x;
   lpr->layout[level][i] = layout;
}


d743 2
a744 20
 * Set the layout mode for all tiles in a particular image.
 */
static INLINE void
llvmpipe_set_texture_image_layout(struct llvmpipe_resource *lpr,
                                  unsigned face_slice, unsigned level,
                                  unsigned width_t, unsigned height_t,
                                  enum lp_texture_layout layout)
{
   const unsigned start = face_slice * lpr->tiles_per_image[level];
   unsigned i;

   for (i = 0; i < width_t * height_t; i++) {
      lpr->layout[level][start + i] = layout;
   }
}


/**
 * Allocate storage for a linear or tile texture image (all cube
 * faces and all 3D slices.
d747 1
a747 2
alloc_image_data(struct llvmpipe_resource *lpr, unsigned level,
                 enum lp_texture_layout layout)
d750 9
d760 1
a760 2
   if (lpr->dt)
      assert(level == 0);
d762 3
a764 4
   if (layout == LP_TEX_LAYOUT_TILED) {
      /* tiled data is stored in regular memory */
      uint buffer_size = tex_image_size(lpr, level, layout);
      lpr->tiled[level].data = align_malloc(buffer_size, alignment);
d767 9
a775 9
      assert(layout == LP_TEX_LAYOUT_LINEAR);
      if (lpr->dt) {
         /* we get the linear memory from the winsys */
         struct llvmpipe_screen *screen = llvmpipe_screen(lpr->base.screen);
         struct sw_winsys *winsys = screen->winsys;

         lpr->linear[0].data =
            winsys->displaytarget_map(winsys, lpr->dt,
                                      PIPE_TRANSFER_READ_WRITE);
d777 3
a779 4
      else {
         /* not a display target - allocate regular memory */
         uint buffer_size = tex_image_size(lpr, level, LP_TEX_LAYOUT_LINEAR);
         lpr->linear[level].data = align_malloc(buffer_size, alignment);
d787 1
a787 1
 * Return pointer to texture image data (either linear or tiled layout)
a791 1
 * \param layout  either LP_TEX_LAYOUT_LINEAR or _TILED or _NONE
d796 1
a796 2
                           enum lp_texture_usage usage,
                           enum lp_texture_layout layout)
a797 6
   /*
    * 'target' refers to the image which we're retrieving (either in
    * tiled or linear layout).
    * 'other' refers to the same image but in the other layout. (it may
    *  or may not exist.
    */
a798 1
   struct llvmpipe_texture_image *other_img;
d800 2
a801 11
   void *other_data;
   const unsigned width = u_minify(lpr->base.width0, level);
   const unsigned height = u_minify(lpr->base.height0, level);
   const unsigned width_t = align(width, TILE_SIZE) / TILE_SIZE;
   const unsigned height_t = align(height, TILE_SIZE) / TILE_SIZE;
   enum lp_texture_layout other_layout;
   boolean only_allocate;

   assert(layout == LP_TEX_LAYOUT_NONE ||
          layout == LP_TEX_LAYOUT_TILED ||
          layout == LP_TEX_LAYOUT_LINEAR);
a806 9
   /* check for the special case of layout == LP_TEX_LAYOUT_NONE */
   if (layout == LP_TEX_LAYOUT_NONE) {
      only_allocate = TRUE;
      layout = LP_TEX_LAYOUT_TILED;
   }
   else {
      only_allocate = FALSE;
   }

d808 1
a808 13
      assert(lpr->linear[level].data);
   }

   /* which is target?  which is other? */
   if (layout == LP_TEX_LAYOUT_LINEAR) {
      target_img = &lpr->linear[level];
      other_img = &lpr->tiled[level];
      other_layout = LP_TEX_LAYOUT_TILED;
   }
   else {
      target_img = &lpr->tiled[level];
      other_img = &lpr->linear[level];
      other_layout = LP_TEX_LAYOUT_LINEAR;
d811 2
a813 1
   other_data = other_img->data;
d817 1
a817 1
      alloc_image_data(lpr, level, layout);
d821 2
d824 1
a824 10
      unsigned target_offset, other_offset;

      target_offset = face_slice * tex_image_face_size(lpr, level, layout);
      other_offset = face_slice * tex_image_face_size(lpr, level, other_layout);
      if (target_data) {
         target_data = (uint8_t *) target_data + target_offset;
      }
      if (other_data) {
         other_data = (uint8_t *) other_data + other_offset;
      }
d827 2
a828 51
   if (only_allocate) {
      /* Just allocating tiled memory.  Don't initialize it from the
       * linear data if it exists.
       */
      return target_data;
   }

   if (other_data) {
      /* may need to convert other data to the requested layout */
      enum lp_texture_layout new_layout;
      unsigned x, y;

      /* loop over all image tiles, doing layout conversion where needed */
      for (y = 0; y < height_t; y++) {
         for (x = 0; x < width_t; x++) {
            enum lp_texture_layout cur_layout =
               llvmpipe_get_texture_tile_layout(lpr, face_slice, level, x, y);
            boolean convert;

            layout_logic(cur_layout, layout, usage, &new_layout, &convert);

            if (convert && other_data && target_data) {
               if (layout == LP_TEX_LAYOUT_TILED) {
                  lp_linear_to_tiled(other_data, target_data,
                                     x * TILE_SIZE, y * TILE_SIZE,
                                     TILE_SIZE, TILE_SIZE,
                                     lpr->base.format,
                                     lpr->row_stride[level],
                                     lpr->tiles_per_row[level]);
               }
               else {
                  assert(layout == LP_TEX_LAYOUT_LINEAR);
                  lp_tiled_to_linear(other_data, target_data,
                                     x * TILE_SIZE, y * TILE_SIZE,
                                     TILE_SIZE, TILE_SIZE,
                                     lpr->base.format,
                                     lpr->row_stride[level],
                                     lpr->tiles_per_row[level]);
               }
            }

            if (new_layout != cur_layout)
               llvmpipe_set_texture_tile_layout(lpr, face_slice, level, x, y,
                                                new_layout);
         }
      }
   }
   else {
      /* no other data */
      llvmpipe_set_texture_image_layout(lpr, face_slice, level,
                                        width_t, height_t, layout);
a836 2
 * All cube faces and 3D slices will be converted to the requested
 * layout if needed.
d842 1
a842 2
                               enum lp_texture_usage usage,
                               enum lp_texture_layout layout)
d851 1
a851 1
      map = llvmpipe_get_texture_image(lpr, slice, level, usage, layout);
d859 1
a859 3
 * Get pointer to a linear image (not the tile!) where the tile at (x,y)
 * is known to be in linear layout.
 * Conversion from tiled to linear will be done if necessary.
d868 2
a869 5
   struct llvmpipe_texture_image *linear_img = &lpr->linear[level];
   enum lp_texture_layout cur_layout, new_layout;
   const unsigned tx = x / TILE_SIZE, ty = y / TILE_SIZE;
   boolean convert;
   uint8_t *tiled_image, *linear_image;
d871 1
a871 1
   assert(resource_is_texture(&lpr->base));
d877 2
a878 1
      alloc_image_data(lpr, level, LP_TEX_LAYOUT_LINEAR);
d880 1
d883 1
a883 20
   tiled_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                    LP_TEX_LAYOUT_TILED);
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                     LP_TEX_LAYOUT_LINEAR);

   /* get current tile layout and determine if data conversion is needed */
   cur_layout = llvmpipe_get_texture_tile_layout(lpr, face_slice, level, tx, ty);

   layout_logic(cur_layout, LP_TEX_LAYOUT_LINEAR, usage,
                &new_layout, &convert);

   if (convert && tiled_image && linear_image) {
      lp_tiled_to_linear(tiled_image, linear_image,
                         x, y, TILE_SIZE, TILE_SIZE, lpr->base.format,
                         lpr->row_stride[level],
                         lpr->tiles_per_row[level]);
   }

   if (new_layout != cur_layout)
      llvmpipe_set_texture_tile_layout(lpr, face_slice, level, tx, ty, new_layout);
a889 144
 * Get pointer to tiled data for rendering.
 * \return pointer to the tiled data at the given tile position
 */
ubyte *
llvmpipe_get_texture_tile(struct llvmpipe_resource *lpr,
                          unsigned face_slice, unsigned level,
                          enum lp_texture_usage usage,
                          unsigned x, unsigned y)
{
   struct llvmpipe_texture_image *tiled_img = &lpr->tiled[level];
   enum lp_texture_layout cur_layout, new_layout;
   const unsigned tx = x / TILE_SIZE, ty = y / TILE_SIZE;
   boolean convert;
   uint8_t *tiled_image, *linear_image;
   unsigned tile_offset;

   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   if (!tiled_img->data) {
      /* allocate memory for the tiled image now */
      alloc_image_data(lpr, level, LP_TEX_LAYOUT_TILED);
   }

   /* compute address of the slice/face of the image that contains the tile */
   tiled_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                    LP_TEX_LAYOUT_TILED);
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                     LP_TEX_LAYOUT_LINEAR);

   /* get current tile layout and see if we need to convert the data */
   cur_layout = llvmpipe_get_texture_tile_layout(lpr, face_slice, level, tx, ty);

   layout_logic(cur_layout, LP_TEX_LAYOUT_TILED, usage, &new_layout, &convert);
   if (convert && linear_image && tiled_image) {
      lp_linear_to_tiled(linear_image, tiled_image,
                         x, y, TILE_SIZE, TILE_SIZE, lpr->base.format,
                         lpr->row_stride[level],
                         lpr->tiles_per_row[level]);
   }

   if (!tiled_image)
      return NULL;

   if (new_layout != cur_layout)
      llvmpipe_set_texture_tile_layout(lpr, face_slice, level, tx, ty, new_layout);

   /* compute, return address of the 64x64 tile */
   tile_offset = (ty * lpr->tiles_per_row[level] + tx)
         * TILE_SIZE * TILE_SIZE * 4;

   return (ubyte *) tiled_image + tile_offset;
}


/**
 * Get pointer to tiled data for rendering.
 * \return pointer to the tiled data at the given tile position
 */
void
llvmpipe_unswizzle_cbuf_tile(struct llvmpipe_resource *lpr,
                             unsigned face_slice, unsigned level,
                             unsigned x, unsigned y,
                             uint8_t *tile)
{
   struct llvmpipe_texture_image *linear_img = &lpr->linear[level];
   const unsigned tx = x / TILE_SIZE, ty = y / TILE_SIZE;
   uint8_t *linear_image;

   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   if (!linear_img->data) {
      /* allocate memory for the linear image now */
      alloc_image_data(lpr, level, LP_TEX_LAYOUT_LINEAR);
   }

   /* compute address of the slice/face of the image that contains the tile */
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                     LP_TEX_LAYOUT_LINEAR);

   {
      uint ii = x, jj = y;
      uint tile_offset = jj / TILE_SIZE + ii / TILE_SIZE;
      uint byte_offset = tile_offset * TILE_SIZE * TILE_SIZE * 4;
      
      /* Note that lp_tiled_to_linear expects the tile parameter to
       * point at the first tile in a whole-image sized array.  In
       * this code, we have only a single tile and have to do some
       * pointer arithmetic to figure out where the "image" would have
       * started.
       */
      lp_tiled_to_linear(tile - byte_offset, linear_image,
                         x, y, TILE_SIZE, TILE_SIZE,
                         lpr->base.format,
                         lpr->row_stride[level],
                         1);       /* tiles per row */
   }

   llvmpipe_set_texture_tile_layout(lpr, face_slice, level, tx, ty,
                                    LP_TEX_LAYOUT_LINEAR);
}


/**
 * Get pointer to tiled data for rendering.
 * \return pointer to the tiled data at the given tile position
 */
void
llvmpipe_swizzle_cbuf_tile(struct llvmpipe_resource *lpr,
                           unsigned face_slice, unsigned level,
                           unsigned x, unsigned y,
                           uint8_t *tile)
{
   uint8_t *linear_image;

   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   /* compute address of the slice/face of the image that contains the tile */
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                     LP_TEX_LAYOUT_LINEAR);

   if (linear_image) {
      uint ii = x, jj = y;
      uint tile_offset = jj / TILE_SIZE + ii / TILE_SIZE;
      uint byte_offset = tile_offset * TILE_SIZE * TILE_SIZE * 4;

      /* Note that lp_linear_to_tiled expects the tile parameter to
       * point at the first tile in a whole-image sized array.  In
       * this code, we have only a single tile and have to do some
       * pointer arithmetic to figure out where the "image" would have
       * started.
       */
      lp_linear_to_tiled(linear_image, tile - byte_offset,
                         x, y, TILE_SIZE, TILE_SIZE,
                         lpr->base.format,
                         lpr->row_stride[level],
                         1);       /* tiles per row */
   }
}


/**
d898 8
a905 6
   for (lvl = 0; lvl <= lpr->base.last_level; lvl++) {
      if (lpr->linear[lvl].data)
         size += tex_image_size(lpr, lvl, LP_TEX_LAYOUT_LINEAR);

      if (lpr->tiled[lvl].data)
         size += tex_image_size(lpr, lvl, LP_TEX_LAYOUT_TILED);
d953 1
a953 2
   screen->user_buffer_create = llvmpipe_user_buffer_create;

a959 2
   pipe->get_transfer = llvmpipe_get_transfer;
   pipe->transfer_destroy = llvmpipe_transfer_destroy;
d962 1
a962 1
 
a964 3

   pipe->create_surface = llvmpipe_create_surface;
   pipe->surface_destroy = llvmpipe_surface_destroy;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a577 1
                                   0, /* flush_flags */
d697 1
a697 1
static unsigned int
d705 1
a705 1
      return PIPE_UNREFERENCED;
a1402 1
   pipe->is_resource_referenced = llvmpipe_is_resource_referenced;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d33 2
d37 1
d39 1
a39 1

d43 2
d47 1
d49 1
d51 49
a99 2
#include "lp_tile_size.h"
#include "lp_winsys.h"
d104 1
a104 1
 * Simple, maximally packed layout.
d108 1
a108 1
                        struct llvmpipe_texture *lpt)
d110 1
a110 1
   struct pipe_texture *pt = &lpt->base;
d115 3
a117 1
   unsigned buffer_size = 0;
a119 1
      unsigned nblocksx, nblocksy;
d121 30
a150 5
      /* Allocate storage for whole quads. This is particularly important
       * for depth surfaces, which are currently stored in a swizzled format.
       */
      nblocksx = util_format_get_nblocksx(pt->format, align(width, TILE_SIZE));
      nblocksy = util_format_get_nblocksy(pt->format, align(height, TILE_SIZE));
d152 10
a161 1
      lpt->stride[level] = align(nblocksx * util_format_get_blocksize(pt->format), 16);
d163 1
a163 1
      lpt->level_offset[level] = buffer_size;
d165 2
a166 3
      buffer_size += (nblocksy *
                      ((pt->target == PIPE_TEXTURE_CUBE) ? 6 : depth) *
                      lpt->stride[level]);
d168 1
d174 1
a174 3
   lpt->data = align_malloc(buffer_size, 16);

   return lpt->data != NULL;
d181 1
a181 1
                              struct llvmpipe_texture *lpt)
d183 1
a183 1
   struct llvmpipe_winsys *winsys = screen->winsys;
d188 16
a203 5
   unsigned width = align(lpt->base.width0, TILE_SIZE);
   unsigned height = align(lpt->base.height0, TILE_SIZE);

   lpt->dt = winsys->displaytarget_create(winsys,
                                          lpt->base.format,
d206 1
a206 1
                                          &lpt->stride[0] );
d208 1
a208 1
   return lpt->dt != NULL;
d212 3
a214 3
static struct pipe_texture *
llvmpipe_texture_create(struct pipe_screen *_screen,
                        const struct pipe_texture *templat)
d217 2
a218 2
   struct llvmpipe_texture *lpt = CALLOC_STRUCT(llvmpipe_texture);
   if (!lpt)
d221 20
a240 8
   lpt->base = *templat;
   pipe_reference_init(&lpt->base.reference, 1);
   lpt->base.screen = &screen->base;

   if (lpt->base.tex_usage & (PIPE_TEXTURE_USAGE_DISPLAY_TARGET |
                              PIPE_TEXTURE_USAGE_PRIMARY)) {
      if (!llvmpipe_displaytarget_layout(screen, lpt))
         goto fail;
d243 10
a252 1
      if (!llvmpipe_texture_layout(screen, lpt))
d255 8
a262 2
    
   return &lpt->base;
d265 1
a265 1
   FREE(lpt);
d270 3
a272 5
static struct pipe_texture *
llvmpipe_texture_blanket(struct pipe_screen * screen,
                         const struct pipe_texture *base,
                         const unsigned *stride,
                         struct pipe_buffer *buffer)
d274 12
a285 4
   /* FIXME */
#if 0
   struct llvmpipe_texture *lpt;
   assert(screen);
d287 1
a287 5
   /* Only supports one type */
   if (base->target != PIPE_TEXTURE_2D ||
       base->last_level != 0 ||
       base->depth0 != 1) {
      return NULL;
d289 11
d301 18
a318 3
   lpt = CALLOC_STRUCT(llvmpipe_texture);
   if (!lpt)
      return NULL;
d320 3
a322 11
   lpt->base = *base;
   pipe_reference_init(&lpt->base.reference, 1);
   lpt->base.screen = screen;
   lpt->stride[0] = stride[0];

   pipe_buffer_reference(&lpt->buffer, buffer);

   return &lpt->base;
#else
   debug_printf("llvmpipe_texture_blanket() not implemented!");
   return NULL;
d324 2
d329 9
a337 2
static void
llvmpipe_texture_destroy(struct pipe_texture *pt)
d339 5
a343 2
   struct llvmpipe_screen *screen = llvmpipe_screen(pt->screen);
   struct llvmpipe_texture *lpt = llvmpipe_texture(pt);
d345 9
a353 1
   if (lpt->dt) {
d355 33
a387 2
      struct llvmpipe_winsys *winsys = screen->winsys;
      winsys->displaytarget_destroy(winsys, lpt->dt);
d390 29
a418 2
      /* regular texture */
      align_free(lpt->data);
d420 7
d428 82
a509 1
   FREE(lpt);
d514 3
a516 4
llvmpipe_get_tex_surface(struct pipe_screen *screen,
                         struct pipe_texture *pt,
                         unsigned face, unsigned level, unsigned zslice,
                         unsigned usage)
a517 1
   struct llvmpipe_texture *lpt = llvmpipe_texture(pt);
d520 1
a520 1
   assert(level <= pt->last_level);
d525 10
a534 47
      pipe_texture_reference(&ps->texture, pt);
      ps->format = pt->format;
      ps->width = u_minify(pt->width0, level);
      ps->height = u_minify(pt->height0, level);
      ps->offset = lpt->level_offset[level];
      ps->usage = usage;

      /* Because we are llvmpipe, anything that the state tracker
       * thought was going to be done with the GPU will actually get
       * done with the CPU.  Let's adjust the flags to take that into
       * account.
       */
      if (ps->usage & PIPE_BUFFER_USAGE_GPU_WRITE) {
         /* GPU_WRITE means "render" and that can involve reads (blending) */
         ps->usage |= PIPE_BUFFER_USAGE_CPU_WRITE | PIPE_BUFFER_USAGE_CPU_READ;
      }

      if (ps->usage & PIPE_BUFFER_USAGE_GPU_READ)
         ps->usage |= PIPE_BUFFER_USAGE_CPU_READ;

      if (ps->usage & (PIPE_BUFFER_USAGE_CPU_WRITE |
                       PIPE_BUFFER_USAGE_GPU_WRITE)) {
         /* Mark the surface as dirty. */
         lpt->timestamp++;
         llvmpipe_screen(screen)->timestamp++;
      }

      ps->face = face;
      ps->level = level;
      ps->zslice = zslice;

      /* XXX shouldn't that rather be
         tex_height = align(ps->height, 2);
         to account for alignment done in llvmpipe_texture_layout ?
      */
      if (pt->target == PIPE_TEXTURE_CUBE) {
         unsigned tex_height = ps->height;
         ps->offset += face * util_format_get_nblocksy(pt->format, tex_height) * lpt->stride[level];
      }
      else if (pt->target == PIPE_TEXTURE_3D) {
         unsigned tex_height = ps->height;
         ps->offset += zslice * util_format_get_nblocksy(pt->format, tex_height) * lpt->stride[level];
      }
      else {
         assert(face == 0);
         assert(zslice == 0);
      }
d541 2
a542 1
llvmpipe_tex_surface_destroy(struct pipe_surface *surf)
d549 1
a549 1
   pipe_texture_reference(&surf->texture, NULL);
d555 47
a601 21
llvmpipe_get_tex_transfer(struct pipe_screen *screen,
                          struct pipe_texture *texture,
                          unsigned face, unsigned level, unsigned zslice,
                          enum pipe_transfer_usage usage,
                          unsigned x, unsigned y, unsigned w, unsigned h)
{
   struct llvmpipe_texture *lptex = llvmpipe_texture(texture);
   struct llvmpipe_transfer *lpt;

   assert(texture);
   assert(level <= texture->last_level);

   lpt = CALLOC_STRUCT(llvmpipe_transfer);
   if (lpt) {
      struct pipe_transfer *pt = &lpt->base;
      pipe_texture_reference(&pt->texture, texture);
      pt->x = x;
      pt->y = y;
      pt->width = align(w, TILE_SIZE);
      pt->height = align(h, TILE_SIZE);
      pt->stride = lptex->stride[level];
a602 5
      pt->face = face;
      pt->level = level;
      pt->zslice = zslice;

      lpt->offset = lptex->level_offset[level];
a603 16
      /* XXX shouldn't that rather be
         tex_height = align(u_minify(texture->height0, level), 2)
         to account for alignment done in llvmpipe_texture_layout ?
      */
      if (texture->target == PIPE_TEXTURE_CUBE) {
         unsigned tex_height = u_minify(texture->height0, level);
         lpt->offset += face *  util_format_get_nblocksy(texture->format, tex_height) * pt->stride;
      }
      else if (texture->target == PIPE_TEXTURE_3D) {
         unsigned tex_height = u_minify(texture->height0, level);
         lpt->offset += zslice * util_format_get_nblocksy(texture->format, tex_height) * pt->stride;
      }
      else {
         assert(face == 0);
         assert(zslice == 0);
      }
d611 2
a612 1
llvmpipe_tex_transfer_destroy(struct pipe_transfer *transfer)
d618 2
a619 2
   assert (transfer->texture);
   pipe_texture_reference(&transfer->texture, NULL);
d625 1
a625 1
llvmpipe_transfer_map( struct pipe_screen *_screen,
d628 3
a630 3
   struct llvmpipe_screen *screen = llvmpipe_screen(_screen);
   ubyte *map, *xfer_map;
   struct llvmpipe_texture *lpt;
d632 2
d635 1
a635 3
   assert(transfer->texture);
   lpt = llvmpipe_texture(transfer->texture);
   format = lpt->base.format;
d637 11
a647 8
   if (lpt->dt) {
      /* display target */
      struct llvmpipe_winsys *winsys = screen->winsys;

      map = winsys->displaytarget_map(winsys, lpt->dt,
                                      pipe_transfer_buffer_flags(transfer));
      if (map == NULL)
         return NULL;
d650 7
a656 2
      /* regular texture */
      map = lpt->data;
d659 12
a670 1
   /* May want to different things here depending on read/write nature
d673 1
a673 1
   if (transfer->texture && (transfer->usage & PIPE_TRANSFER_WRITE)) {
d678 6
a683 6
   
   xfer_map = map + llvmpipe_transfer(transfer)->offset +
      transfer->y / util_format_get_blockheight(format) * transfer->stride +
      transfer->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);
   /*printf("map = %p  xfer map = %p\n", map, xfer_map);*/
   return xfer_map;
d688 64
a751 2
llvmpipe_transfer_unmap(struct pipe_screen *screen,
                       struct pipe_transfer *transfer)
d753 35
a787 2
   struct llvmpipe_screen *lp_screen = llvmpipe_screen(screen);
   struct llvmpipe_texture *lpt;
a788 2
   assert(transfer->texture);
   lpt = llvmpipe_texture(transfer->texture);
d790 595
a1384 4
   if (lpt->dt) {
      /* display target */
      struct llvmpipe_winsys *winsys = lp_screen->winsys;
      winsys->displaytarget_unmap(winsys, lpt->dt);
d1386 8
d1398 1
a1398 1
llvmpipe_init_screen_texture_funcs(struct pipe_screen *screen)
d1400 11
a1410 11
   screen->texture_create = llvmpipe_texture_create;
   screen->texture_blanket = llvmpipe_texture_blanket;
   screen->texture_destroy = llvmpipe_texture_destroy;

   screen->get_tex_surface = llvmpipe_get_tex_surface;
   screen->tex_surface_destroy = llvmpipe_tex_surface_destroy;

   screen->get_tex_transfer = llvmpipe_get_tex_transfer;
   screen->tex_transfer_destroy = llvmpipe_tex_transfer_destroy;
   screen->transfer_map = llvmpipe_transfer_map;
   screen->transfer_unmap = llvmpipe_transfer_unmap;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a32 2
#include <stdio.h>

d35 1
a36 2
#include "util/u_inlines.h"
#include "util/u_cpu_detect.h"
a39 2
#include "util/u_simple_list.h"
#include "util/u_transfer.h"
a41 1
#include "lp_flush.h"
a42 1
#include "lp_tile_image.h"
d44 2
a45 49
#include "lp_setup.h"
#include "lp_state.h"

#include "state_tracker/sw_winsys.h"


#ifdef DEBUG
static struct llvmpipe_resource resource_list;
#endif
static unsigned id_counter = 0;


static INLINE boolean
resource_is_texture(const struct pipe_resource *resource)
{
   switch (resource->target) {
   case PIPE_BUFFER:
      return FALSE;
   case PIPE_TEXTURE_1D:
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
   case PIPE_TEXTURE_3D:
   case PIPE_TEXTURE_CUBE:
      return TRUE;
   default:
      assert(0);
      return FALSE;
   }
}



/**
 * Allocate storage for llvmpipe_texture::layout array.
 * The number of elements is width_in_tiles * height_in_tiles.
 */
static enum lp_texture_layout *
alloc_layout_array(unsigned num_slices, unsigned width, unsigned height)
{
   const unsigned tx = align(width, TILE_SIZE) / TILE_SIZE;
   const unsigned ty = align(height, TILE_SIZE) / TILE_SIZE;

   assert(num_slices * tx * ty > 0);
   assert(LP_TEX_LAYOUT_NONE == 0); /* calloc'ing LP_TEX_LAYOUT_NONE here */

   return (enum lp_texture_layout *)
      CALLOC(num_slices * tx * ty, sizeof(enum lp_texture_layout));
}

d50 1
a50 1
 * Just compute row strides here.  Storage is allocated on demand later.
d54 1
a54 1
                        struct llvmpipe_resource *lpr)
d56 1
a56 1
   struct pipe_resource *pt = &lpr->base;
d61 1
a61 3

   assert(LP_MAX_TEXTURE_2D_LEVELS <= LP_MAX_TEXTURE_LEVELS);
   assert(LP_MAX_TEXTURE_3D_LEVELS <= LP_MAX_TEXTURE_LEVELS);
d64 1
d66 5
a70 17
      /* Row stride and image stride (for linear layout) */
      {
         unsigned alignment, nblocksx, nblocksy, block_size;

         /* For non-compressed formats we need to align the texture size
          * to the tile size to facilitate render-to-texture.
          */
         if (util_format_is_compressed(pt->format))
            alignment = 1;
         else
            alignment = TILE_SIZE;

         nblocksx = util_format_get_nblocksx(pt->format,
                                             align(width, alignment));
         nblocksy = util_format_get_nblocksy(pt->format,
                                             align(height, alignment));
         block_size = util_format_get_blocksize(pt->format);
d72 1
a72 1
         lpr->row_stride[level] = align(nblocksx * block_size, 16);
d74 1
a74 10
         lpr->img_stride[level] = lpr->row_stride[level] * nblocksy;
      }

      /* Size of the image in tiles (for tiled layout) */
      {
         const unsigned width_t = align(width, TILE_SIZE) / TILE_SIZE;
         const unsigned height_t = align(height, TILE_SIZE) / TILE_SIZE;
         lpr->tiles_per_row[level] = width_t;
         lpr->tiles_per_image[level] = width_t * height_t;
      }
d76 3
a78 15
      /* Number of 3D image slices or cube faces */
      {
         unsigned num_slices;

         if (lpr->base.target == PIPE_TEXTURE_CUBE)
            num_slices = 6;
         else if (lpr->base.target == PIPE_TEXTURE_3D)
            num_slices = depth;
         else
            num_slices = 1;

         lpr->num_slices_faces[level] = num_slices;

         lpr->layout[level] = alloc_layout_array(num_slices, width, height);
      }
a79 1
      /* Compute size of next mipmap level */
d85 3
a87 1
   return TRUE;
d94 1
a94 1
                              struct llvmpipe_resource *lpr)
d96 1
a96 1
   struct sw_winsys *winsys = screen->winsys;
d101 5
a105 16
   const unsigned width = align(lpr->base.width0, TILE_SIZE);
   const unsigned height = align(lpr->base.height0, TILE_SIZE);
   const unsigned width_t = width / TILE_SIZE;
   const unsigned height_t = height / TILE_SIZE;

   lpr->tiles_per_row[0] = width_t;
   lpr->tiles_per_image[0] = width_t * height_t;
   lpr->num_slices_faces[0] = 1;
   lpr->img_stride[0] = 0;

   lpr->layout[0] = alloc_layout_array(1, width, height);
   //lpr->layout[0][0] = LP_TEX_LAYOUT_LINEAR;

   lpr->dt = winsys->displaytarget_create(winsys,
                                          lpr->base.bind,
                                          lpr->base.format,
d108 1
a108 1
                                          &lpr->row_stride[0] );
d110 1
a110 1
   return lpr->dt != NULL;
d114 3
a116 3
static struct pipe_resource *
llvmpipe_resource_create(struct pipe_screen *_screen,
                         const struct pipe_resource *templat)
d119 2
a120 2
   struct llvmpipe_resource *lpr = CALLOC_STRUCT(llvmpipe_resource);
   if (!lpr)
d123 8
a130 20
   lpr->base = *templat;
   pipe_reference_init(&lpr->base.reference, 1);
   lpr->base.screen = &screen->base;

   /* assert(lpr->base.bind); */

   if (resource_is_texture(&lpr->base)) {
      if (lpr->base.bind & PIPE_BIND_DISPLAY_TARGET) {
         /* displayable surface */
         if (!llvmpipe_displaytarget_layout(screen, lpr))
            goto fail;
         assert(lpr->layout[0][0] == LP_TEX_LAYOUT_NONE);
      }
      else {
         /* texture map */
         if (!llvmpipe_texture_layout(screen, lpr))
            goto fail;
         assert(lpr->layout[0][0] == LP_TEX_LAYOUT_NONE);
      }
      assert(lpr->layout[0]);
d133 1
a133 10
      /* other data (vertex buffer, const buffer, etc) */
      const enum pipe_format format = templat->format;
      const uint w = templat->width0 / util_format_get_blockheight(format);
      /* XXX buffers should only have one dimension, those values should be 1 */
      const uint h = templat->height0 / util_format_get_blockwidth(format);
      const uint d = templat->depth0;
      const uint bpp = util_format_get_blocksize(format);
      const uint bytes = w * h * d * bpp;
      lpr->data = align_malloc(bytes, 16);
      if (!lpr->data)
d136 2
a137 8

   lpr->id = id_counter++;

#ifdef DEBUG
   insert_at_tail(&resource_list, lpr);
#endif

   return &lpr->base;
d140 1
a140 1
   FREE(lpr);
d145 5
a149 3
static void
llvmpipe_resource_destroy(struct pipe_screen *pscreen,
			  struct pipe_resource *pt)
d151 4
a154 2
   struct llvmpipe_screen *screen = llvmpipe_screen(pscreen);
   struct llvmpipe_resource *lpr = llvmpipe_resource(pt);
d156 5
a160 11
   if (lpr->dt) {
      /* display target */
      struct sw_winsys *winsys = screen->winsys;
      winsys->displaytarget_destroy(winsys, lpr->dt);

      if (lpr->tiled[0].data) {
         align_free(lpr->tiled[0].data);
         lpr->tiled[0].data = NULL;
      }

      FREE(lpr->layout[0]);
a161 3
   else if (resource_is_texture(pt)) {
      /* regular texture */
      uint level;
d163 3
a165 7
      /* free linear image data */
      for (level = 0; level < Elements(lpr->linear); level++) {
         if (lpr->linear[level].data) {
            align_free(lpr->linear[level].data);
            lpr->linear[level].data = NULL;
         }
      }
d167 11
a177 22
      /* free tiled image data */
      for (level = 0; level < Elements(lpr->tiled); level++) {
         if (lpr->tiled[level].data) {
            align_free(lpr->tiled[level].data);
            lpr->tiled[level].data = NULL;
         }
      }

      /* free layout flag arrays */
      for (level = 0; level < Elements(lpr->tiled); level++) {
         FREE(lpr->layout[level]);
         lpr->layout[level] = NULL;
      }
   }
   else if (!lpr->userBuffer) {
      assert(lpr->data);
      align_free(lpr->data);
   }

#ifdef DEBUG
   if (lpr->next)
      remove_from_list(lpr);
a178 2

   FREE(lpr);
d182 2
a183 9
/**
 * Map a resource for read/write.
 */
void *
llvmpipe_resource_map(struct pipe_resource *resource,
                      unsigned level,
                      unsigned layer,
                      enum lp_texture_usage tex_usage,
                      enum lp_texture_layout layout)
d185 2
a186 5
   struct llvmpipe_resource *lpr = llvmpipe_resource(resource);
   uint8_t *map;

   assert(level < LP_MAX_TEXTURE_LEVELS);
   assert(layer < (u_minify(resource->depth0, level) + resource->array_size - 1));
d188 1
a188 9
   assert(tex_usage == LP_TEX_USAGE_READ ||
          tex_usage == LP_TEX_USAGE_READ_WRITE ||
          tex_usage == LP_TEX_USAGE_WRITE_ALL);

   assert(layout == LP_TEX_LAYOUT_NONE ||
          layout == LP_TEX_LAYOUT_TILED ||
          layout == LP_TEX_LAYOUT_LINEAR);

   if (lpr->dt) {
d190 2
a191 33
      struct llvmpipe_screen *screen = llvmpipe_screen(resource->screen);
      struct sw_winsys *winsys = screen->winsys;
      unsigned dt_usage;
      uint8_t *map2;

      if (tex_usage == LP_TEX_USAGE_READ) {
         dt_usage = PIPE_TRANSFER_READ;
      }
      else {
         dt_usage = PIPE_TRANSFER_READ_WRITE;
      }

      assert(level == 0);
      assert(layer == 0);

      /* FIXME: keep map count? */
      map = winsys->displaytarget_map(winsys, lpr->dt, dt_usage);

      /* install this linear image in texture data structure */
      lpr->linear[level].data = map;

      /* make sure tiled data gets converted to linear data */
      map2 = llvmpipe_get_texture_image(lpr, 0, 0, tex_usage, layout);
      if (layout == LP_TEX_LAYOUT_LINEAR)
         assert(map == map2);

      return map2;
   }
   else if (resource_is_texture(resource)) {

      map = llvmpipe_get_texture_image(lpr, layer, level,
                                       tex_usage, layout);
      return map;
d194 2
a195 1
      return lpr->data;
a196 35
}


/**
 * Unmap a resource.
 */
void
llvmpipe_resource_unmap(struct pipe_resource *resource,
                       unsigned level,
                       unsigned layer)
{
   struct llvmpipe_resource *lpr = llvmpipe_resource(resource);

   if (lpr->dt) {
      /* display target */
      struct llvmpipe_screen *lp_screen = llvmpipe_screen(resource->screen);
      struct sw_winsys *winsys = lp_screen->winsys;

      assert(level == 0);
      assert(layer == 0);

      /* make sure linear image is up to date */
      (void) llvmpipe_get_texture_image(lpr, layer, level,
                                        LP_TEX_USAGE_READ,
                                        LP_TEX_LAYOUT_LINEAR);

      winsys->displaytarget_unmap(winsys, lpr->dt);
   }
}


void *
llvmpipe_resource_data(struct pipe_resource *resource)
{
   struct llvmpipe_resource *lpr = llvmpipe_resource(resource);
d198 1
a198 82
   assert(!resource_is_texture(resource));

   return lpr->data;
}


static struct pipe_resource *
llvmpipe_resource_from_handle(struct pipe_screen *screen,
			      const struct pipe_resource *template,
			      struct winsys_handle *whandle)
{
   struct sw_winsys *winsys = llvmpipe_screen(screen)->winsys;
   struct llvmpipe_resource *lpr = CALLOC_STRUCT(llvmpipe_resource);
   unsigned width, height, width_t, height_t;

   /* XXX Seems like from_handled depth textures doesn't work that well */

   if (!lpr)
      return NULL;

   lpr->base = *template;
   pipe_reference_init(&lpr->base.reference, 1);
   lpr->base.screen = screen;

   width = align(lpr->base.width0, TILE_SIZE);
   height = align(lpr->base.height0, TILE_SIZE);
   width_t = width / TILE_SIZE;
   height_t = height / TILE_SIZE;

   /*
    * Looks like unaligned displaytargets work just fine,
    * at least sampler/render ones.
    */
#if 0
   assert(lpr->base.width0 == width);
   assert(lpr->base.height0 == height);
#endif

   lpr->tiles_per_row[0] = width_t;
   lpr->tiles_per_image[0] = width_t * height_t;
   lpr->num_slices_faces[0] = 1;
   lpr->img_stride[0] = 0;

   lpr->dt = winsys->displaytarget_from_handle(winsys,
                                               template,
                                               whandle,
                                               &lpr->row_stride[0]);
   if (!lpr->dt)
      goto fail;

   lpr->layout[0] = alloc_layout_array(1, lpr->base.width0, lpr->base.height0);

   assert(lpr->layout[0]);
   assert(lpr->layout[0][0] == LP_TEX_LAYOUT_NONE);

   lpr->id = id_counter++;

#ifdef DEBUG
   insert_at_tail(&resource_list, lpr);
#endif

   return &lpr->base;

 fail:
   FREE(lpr);
   return NULL;
}


static boolean
llvmpipe_resource_get_handle(struct pipe_screen *screen,
                            struct pipe_resource *pt,
                            struct winsys_handle *whandle)
{
   struct sw_winsys *winsys = llvmpipe_screen(screen)->winsys;
   struct llvmpipe_resource *lpr = llvmpipe_resource(pt);

   assert(lpr->dt);
   if (!lpr->dt)
      return FALSE;

   return winsys->displaytarget_get_handle(winsys, lpr->dt, whandle);
d203 4
a206 3
llvmpipe_create_surface(struct pipe_context *pipe,
                        struct pipe_resource *pt,
                        const struct pipe_surface *surf_tmpl)
d208 1
d211 1
a211 1
   assert(surf_tmpl->u.tex.level <= pt->last_level);
d216 47
a262 10
      pipe_resource_reference(&ps->texture, pt);
      ps->context = pipe;
      ps->format = surf_tmpl->format;
      ps->width = u_minify(pt->width0, surf_tmpl->u.tex.level);
      ps->height = u_minify(pt->height0, surf_tmpl->u.tex.level);
      ps->usage = surf_tmpl->usage;

      ps->u.tex.level = surf_tmpl->u.tex.level;
      ps->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
      ps->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
d269 1
a269 2
llvmpipe_surface_destroy(struct pipe_context *pipe,
                         struct pipe_surface *surf)
d276 1
a276 1
   pipe_resource_reference(&surf->texture, NULL);
d282 25
a306 35
llvmpipe_get_transfer(struct pipe_context *pipe,
                      struct pipe_resource *resource,
                      unsigned level,
                      unsigned usage,
                      const struct pipe_box *box)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
   struct llvmpipe_resource *lprex = llvmpipe_resource(resource);
   struct llvmpipe_transfer *lpr;

   assert(resource);
   assert(level <= resource->last_level);

   /*
    * Transfers, like other pipe operations, must happen in order, so flush the
    * context if necessary.
    */
   if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED)) {
      boolean read_only = !(usage & PIPE_TRANSFER_WRITE);
      boolean do_not_block = !!(usage & PIPE_TRANSFER_DONTBLOCK);
      if (!llvmpipe_flush_resource(pipe, resource,
                                   level,
                                   box->depth > 1 ? -1 : box->z,
                                   0, /* flush_flags */
                                   read_only,
                                   TRUE, /* cpu_access */
                                   do_not_block,
                                   __FUNCTION__)) {
         /*
          * It would have blocked, but state tracker requested no to.
          */
         assert(do_not_block);
         return NULL;
      }
   }
d308 1
a308 12
   if (resource == llvmpipe->constants[PIPE_SHADER_FRAGMENT][0])
      llvmpipe->dirty |= LP_NEW_CONSTANTS;

   lpr = CALLOC_STRUCT(llvmpipe_transfer);
   if (lpr) {
      struct pipe_transfer *pt = &lpr->base;
      pipe_resource_reference(&pt->resource, resource);
      pt->box = *box;
      pt->level = level;
      pt->stride = lprex->row_stride[level];
      pt->layer_stride = lprex->img_stride[level];
      pt->usage = usage;
d310 16
d333 1
a333 2
llvmpipe_transfer_destroy(struct pipe_context *pipe,
                              struct pipe_transfer *transfer)
d339 2
a340 2
   assert (transfer->resource);
   pipe_resource_reference(&transfer->resource, NULL);
d346 1
a346 1
llvmpipe_transfer_map( struct pipe_context *pipe,
d349 3
a351 3
   struct llvmpipe_screen *screen = llvmpipe_screen(pipe->screen);
   ubyte *map;
   struct llvmpipe_resource *lpr;
a352 2
   enum lp_texture_usage tex_usage;
   const char *mode;
d354 3
a356 1
   assert(transfer->level < LP_MAX_TEXTURE_LEVELS);
d358 8
a365 11
   /*
   printf("tex_transfer_map(%d, %d  %d x %d of %d x %d,  usage %d )\n",
          transfer->x, transfer->y, transfer->width, transfer->height,
          transfer->texture->width0,
          transfer->texture->height0,
          transfer->usage);
   */

   if (transfer->usage == PIPE_TRANSFER_READ) {
      tex_usage = LP_TEX_USAGE_READ;
      mode = "read";
d368 2
a369 2
      tex_usage = LP_TEX_USAGE_READ_WRITE;
      mode = "read/write";
d372 1
a372 17
   if (0) {
      struct llvmpipe_resource *lpr = llvmpipe_resource(transfer->resource);
      printf("transfer map tex %u  mode %s\n", lpr->id, mode);
   }


   assert(transfer->resource);
   lpr = llvmpipe_resource(transfer->resource);
   format = lpr->base.format;

   map = llvmpipe_resource_map(transfer->resource,
                               transfer->level,
                               transfer->box.z,
                               tex_usage, LP_TEX_LAYOUT_LINEAR);


   /* May want to do different things here depending on read/write nature
d375 1
a375 1
   if (transfer->usage & PIPE_TRANSFER_WRITE) {
d380 6
a385 6

   map +=
      transfer->box.y / util_format_get_blockheight(format) * transfer->stride +
      transfer->box.x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);

   return map;
d390 2
a391 2
llvmpipe_transfer_unmap(struct pipe_context *pipe,
                        struct pipe_transfer *transfer)
d393 2
a394 1
   assert(transfer->resource);
d396 2
a397 4
   llvmpipe_resource_unmap(transfer->resource,
                           transfer->level,
                           transfer->box.z);
}
d399 4
a402 75
static unsigned int
llvmpipe_is_resource_referenced( struct pipe_context *pipe,
                                 struct pipe_resource *presource,
                                 unsigned level, int layer)
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context( pipe );

   if (presource->target == PIPE_BUFFER)
      return PIPE_UNREFERENCED;

   return lp_setup_is_resource_referenced(llvmpipe->setup, presource);
}



/**
 * Create buffer which wraps user-space data.
 */
static struct pipe_resource *
llvmpipe_user_buffer_create(struct pipe_screen *screen,
                            void *ptr,
                            unsigned bytes,
			    unsigned bind_flags)
{
   struct llvmpipe_resource *buffer;

   buffer = CALLOC_STRUCT(llvmpipe_resource);
   if(!buffer)
      return NULL;

   pipe_reference_init(&buffer->base.reference, 1);
   buffer->base.screen = screen;
   buffer->base.format = PIPE_FORMAT_R8_UNORM; /* ?? */
   buffer->base.bind = bind_flags;
   buffer->base.usage = PIPE_USAGE_IMMUTABLE;
   buffer->base.flags = 0;
   buffer->base.width0 = bytes;
   buffer->base.height0 = 1;
   buffer->base.depth0 = 1;
   buffer->base.array_size = 1;
   buffer->userBuffer = TRUE;
   buffer->data = ptr;

   return &buffer->base;
}


/**
 * Compute size (in bytes) need to store a texture image / mipmap level,
 * for just one cube face or one 3D texture slice
 */
static unsigned
tex_image_face_size(const struct llvmpipe_resource *lpr, unsigned level,
                    enum lp_texture_layout layout)
{
   const unsigned width = u_minify(lpr->base.width0, level);
   const unsigned height = u_minify(lpr->base.height0, level);

   assert(layout == LP_TEX_LAYOUT_TILED ||
          layout == LP_TEX_LAYOUT_LINEAR);

   if (layout == LP_TEX_LAYOUT_TILED) {
      /* for tiled layout, force a 32bpp format */
      const enum pipe_format format = PIPE_FORMAT_B8G8R8A8_UNORM;
      const unsigned block_size = util_format_get_blocksize(format);
      const unsigned nblocksy =
         util_format_get_nblocksy(format, align(height, TILE_SIZE));
      const unsigned nblocksx =
         util_format_get_nblocksx(format, align(width, TILE_SIZE));
      const unsigned buffer_size = block_size * nblocksy * nblocksx;
      return buffer_size;
   }
   else {
      /* we already computed this */
      return lpr->img_stride[level];
a406 596
/**
 * Compute size (in bytes) need to store a texture image / mipmap level,
 * including all cube faces or 3D image slices
 */
static unsigned
tex_image_size(const struct llvmpipe_resource *lpr, unsigned level,
               enum lp_texture_layout layout)
{
   const unsigned buf_size = tex_image_face_size(lpr, level, layout);
   return buf_size * lpr->num_slices_faces[level];
}


/**
 * This function encapsulates some complicated logic for determining
 * how to convert a tile of image data from linear layout to tiled
 * layout, or vice versa.
 * \param cur_layout  the current tile layout
 * \param target_layout  the desired tile layout
 * \param usage  how the tile will be accessed (R/W vs. read-only, etc)
 * \param new_layout_return  returns the new layout mode
 * \param convert_return  returns TRUE if image conversion is needed
 */
static void
layout_logic(enum lp_texture_layout cur_layout,
             enum lp_texture_layout target_layout,
             enum lp_texture_usage usage,
             enum lp_texture_layout *new_layout_return,
             boolean *convert)
{
   enum lp_texture_layout other_layout, new_layout;

   *convert = FALSE;

   new_layout = 99; /* debug check */

   if (target_layout == LP_TEX_LAYOUT_LINEAR) {
      other_layout = LP_TEX_LAYOUT_TILED;
   }
   else {
      assert(target_layout == LP_TEX_LAYOUT_TILED);
      other_layout = LP_TEX_LAYOUT_LINEAR;
   }

   new_layout = target_layout;  /* may get changed below */

   if (cur_layout == LP_TEX_LAYOUT_BOTH) {
      if (usage == LP_TEX_USAGE_READ) {
         new_layout = LP_TEX_LAYOUT_BOTH;
      }
   }
   else if (cur_layout == other_layout) {
      if (usage != LP_TEX_USAGE_WRITE_ALL) {
         /* need to convert tiled data to linear or vice versa */
         *convert = TRUE;

         if (usage == LP_TEX_USAGE_READ)
            new_layout = LP_TEX_LAYOUT_BOTH;
      }
   }
   else {
      assert(cur_layout == LP_TEX_LAYOUT_NONE ||
             cur_layout == target_layout);
   }

   assert(new_layout == LP_TEX_LAYOUT_BOTH ||
          new_layout == target_layout);

   *new_layout_return = new_layout;
}


/**
 * Return pointer to a 2D texture image/face/slice.
 * No tiled/linear conversion is done.
 */
ubyte *
llvmpipe_get_texture_image_address(struct llvmpipe_resource *lpr,
                                   unsigned face_slice, unsigned level,
                                   enum lp_texture_layout layout)
{
   struct llvmpipe_texture_image *img;
   unsigned offset;

   if (layout == LP_TEX_LAYOUT_LINEAR) {
      img = &lpr->linear[level];
   }
   else {
      assert (layout == LP_TEX_LAYOUT_TILED);
      img = &lpr->tiled[level];
   }

   if (face_slice > 0)
      offset = face_slice * tex_image_face_size(lpr, level, layout);
   else
      offset = 0;

   return (ubyte *) img->data + offset;
}


static INLINE enum lp_texture_layout
llvmpipe_get_texture_tile_layout(const struct llvmpipe_resource *lpr,
                                 unsigned face_slice, unsigned level,
                                 unsigned x, unsigned y)
{
   uint i;
   assert(resource_is_texture(&lpr->base));
   assert(x < lpr->tiles_per_row[level]);
   i = face_slice * lpr->tiles_per_image[level]
      + y * lpr->tiles_per_row[level] + x;
   return lpr->layout[level][i];
}


static INLINE void
llvmpipe_set_texture_tile_layout(struct llvmpipe_resource *lpr,
                                 unsigned face_slice, unsigned level,
                                 unsigned x, unsigned y,
                                 enum lp_texture_layout layout)
{
   uint i;
   assert(resource_is_texture(&lpr->base));
   assert(x < lpr->tiles_per_row[level]);
   i = face_slice * lpr->tiles_per_image[level]
      + y * lpr->tiles_per_row[level] + x;
   lpr->layout[level][i] = layout;
}


/**
 * Set the layout mode for all tiles in a particular image.
 */
static INLINE void
llvmpipe_set_texture_image_layout(struct llvmpipe_resource *lpr,
                                  unsigned face_slice, unsigned level,
                                  unsigned width_t, unsigned height_t,
                                  enum lp_texture_layout layout)
{
   const unsigned start = face_slice * lpr->tiles_per_image[level];
   unsigned i;

   for (i = 0; i < width_t * height_t; i++) {
      lpr->layout[level][start + i] = layout;
   }
}


/**
 * Allocate storage for a linear or tile texture image (all cube
 * faces and all 3D slices.
 */
static void
alloc_image_data(struct llvmpipe_resource *lpr, unsigned level,
                 enum lp_texture_layout layout)
{
   uint alignment = MAX2(16, util_cpu_caps.cacheline);

   if (lpr->dt)
      assert(level == 0);

   if (layout == LP_TEX_LAYOUT_TILED) {
      /* tiled data is stored in regular memory */
      uint buffer_size = tex_image_size(lpr, level, layout);
      lpr->tiled[level].data = align_malloc(buffer_size, alignment);
   }
   else {
      assert(layout == LP_TEX_LAYOUT_LINEAR);
      if (lpr->dt) {
         /* we get the linear memory from the winsys */
         struct llvmpipe_screen *screen = llvmpipe_screen(lpr->base.screen);
         struct sw_winsys *winsys = screen->winsys;

         lpr->linear[0].data =
            winsys->displaytarget_map(winsys, lpr->dt,
                                      PIPE_TRANSFER_READ_WRITE);
      }
      else {
         /* not a display target - allocate regular memory */
         uint buffer_size = tex_image_size(lpr, level, LP_TEX_LAYOUT_LINEAR);
         lpr->linear[level].data = align_malloc(buffer_size, alignment);
      }
   }
}



/**
 * Return pointer to texture image data (either linear or tiled layout)
 * for a particular cube face or 3D texture slice.
 *
 * \param face_slice  the cube face or 3D slice of interest
 * \param usage  one of LP_TEX_USAGE_READ/WRITE_ALL/READ_WRITE
 * \param layout  either LP_TEX_LAYOUT_LINEAR or _TILED or _NONE
 */
void *
llvmpipe_get_texture_image(struct llvmpipe_resource *lpr,
                           unsigned face_slice, unsigned level,
                           enum lp_texture_usage usage,
                           enum lp_texture_layout layout)
{
   /*
    * 'target' refers to the image which we're retrieving (either in
    * tiled or linear layout).
    * 'other' refers to the same image but in the other layout. (it may
    *  or may not exist.
    */
   struct llvmpipe_texture_image *target_img;
   struct llvmpipe_texture_image *other_img;
   void *target_data;
   void *other_data;
   const unsigned width = u_minify(lpr->base.width0, level);
   const unsigned height = u_minify(lpr->base.height0, level);
   const unsigned width_t = align(width, TILE_SIZE) / TILE_SIZE;
   const unsigned height_t = align(height, TILE_SIZE) / TILE_SIZE;
   enum lp_texture_layout other_layout;
   boolean only_allocate;

   assert(layout == LP_TEX_LAYOUT_NONE ||
          layout == LP_TEX_LAYOUT_TILED ||
          layout == LP_TEX_LAYOUT_LINEAR);

   assert(usage == LP_TEX_USAGE_READ ||
          usage == LP_TEX_USAGE_READ_WRITE ||
          usage == LP_TEX_USAGE_WRITE_ALL);

   /* check for the special case of layout == LP_TEX_LAYOUT_NONE */
   if (layout == LP_TEX_LAYOUT_NONE) {
      only_allocate = TRUE;
      layout = LP_TEX_LAYOUT_TILED;
   }
   else {
      only_allocate = FALSE;
   }

   if (lpr->dt) {
      assert(lpr->linear[level].data);
   }

   /* which is target?  which is other? */
   if (layout == LP_TEX_LAYOUT_LINEAR) {
      target_img = &lpr->linear[level];
      other_img = &lpr->tiled[level];
      other_layout = LP_TEX_LAYOUT_TILED;
   }
   else {
      target_img = &lpr->tiled[level];
      other_img = &lpr->linear[level];
      other_layout = LP_TEX_LAYOUT_LINEAR;
   }

   target_data = target_img->data;
   other_data = other_img->data;

   if (!target_data) {
      /* allocate memory for the target image now */
      alloc_image_data(lpr, level, layout);
      target_data = target_img->data;
   }

   if (face_slice > 0) {
      unsigned target_offset, other_offset;

      target_offset = face_slice * tex_image_face_size(lpr, level, layout);
      other_offset = face_slice * tex_image_face_size(lpr, level, other_layout);
      if (target_data) {
         target_data = (uint8_t *) target_data + target_offset;
      }
      if (other_data) {
         other_data = (uint8_t *) other_data + other_offset;
      }
   }

   if (only_allocate) {
      /* Just allocating tiled memory.  Don't initialize it from the
       * linear data if it exists.
       */
      return target_data;
   }

   if (other_data) {
      /* may need to convert other data to the requested layout */
      enum lp_texture_layout new_layout;
      unsigned x, y;

      /* loop over all image tiles, doing layout conversion where needed */
      for (y = 0; y < height_t; y++) {
         for (x = 0; x < width_t; x++) {
            enum lp_texture_layout cur_layout =
               llvmpipe_get_texture_tile_layout(lpr, face_slice, level, x, y);
            boolean convert;

            layout_logic(cur_layout, layout, usage, &new_layout, &convert);

            if (convert && other_data && target_data) {
               if (layout == LP_TEX_LAYOUT_TILED) {
                  lp_linear_to_tiled(other_data, target_data,
                                     x * TILE_SIZE, y * TILE_SIZE,
                                     TILE_SIZE, TILE_SIZE,
                                     lpr->base.format,
                                     lpr->row_stride[level],
                                     lpr->tiles_per_row[level]);
               }
               else {
                  assert(layout == LP_TEX_LAYOUT_LINEAR);
                  lp_tiled_to_linear(other_data, target_data,
                                     x * TILE_SIZE, y * TILE_SIZE,
                                     TILE_SIZE, TILE_SIZE,
                                     lpr->base.format,
                                     lpr->row_stride[level],
                                     lpr->tiles_per_row[level]);
               }
            }

            if (new_layout != cur_layout)
               llvmpipe_set_texture_tile_layout(lpr, face_slice, level, x, y,
                                                new_layout);
         }
      }
   }
   else {
      /* no other data */
      llvmpipe_set_texture_image_layout(lpr, face_slice, level,
                                        width_t, height_t, layout);
   }

   return target_data;
}


/**
 * Return pointer to start of a texture image (1D, 2D, 3D, CUBE).
 * All cube faces and 3D slices will be converted to the requested
 * layout if needed.
 * This is typically used when we're about to sample from a texture.
 */
void *
llvmpipe_get_texture_image_all(struct llvmpipe_resource *lpr,
                               unsigned level,
                               enum lp_texture_usage usage,
                               enum lp_texture_layout layout)
{
   const int slices = lpr->num_slices_faces[level];
   int slice;
   void *map = NULL;

   assert(slices > 0);

   for (slice = slices - 1; slice >= 0; slice--) {
      map = llvmpipe_get_texture_image(lpr, slice, level, usage, layout);
   }

   return map;
}


/**
 * Get pointer to a linear image (not the tile!) where the tile at (x,y)
 * is known to be in linear layout.
 * Conversion from tiled to linear will be done if necessary.
 * \return pointer to start of image/face (not the tile)
 */
ubyte *
llvmpipe_get_texture_tile_linear(struct llvmpipe_resource *lpr,
                                 unsigned face_slice, unsigned level,
                                 enum lp_texture_usage usage,
                                 unsigned x, unsigned y)
{
   struct llvmpipe_texture_image *linear_img = &lpr->linear[level];
   enum lp_texture_layout cur_layout, new_layout;
   const unsigned tx = x / TILE_SIZE, ty = y / TILE_SIZE;
   boolean convert;
   uint8_t *tiled_image, *linear_image;

   assert(resource_is_texture(&lpr->base));
   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   if (!linear_img->data) {
      /* allocate memory for the linear image now */
      alloc_image_data(lpr, level, LP_TEX_LAYOUT_LINEAR);
   }

   /* compute address of the slice/face of the image that contains the tile */
   tiled_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                    LP_TEX_LAYOUT_TILED);
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                     LP_TEX_LAYOUT_LINEAR);

   /* get current tile layout and determine if data conversion is needed */
   cur_layout = llvmpipe_get_texture_tile_layout(lpr, face_slice, level, tx, ty);

   layout_logic(cur_layout, LP_TEX_LAYOUT_LINEAR, usage,
                &new_layout, &convert);

   if (convert && tiled_image && linear_image) {
      lp_tiled_to_linear(tiled_image, linear_image,
                         x, y, TILE_SIZE, TILE_SIZE, lpr->base.format,
                         lpr->row_stride[level],
                         lpr->tiles_per_row[level]);
   }

   if (new_layout != cur_layout)
      llvmpipe_set_texture_tile_layout(lpr, face_slice, level, tx, ty, new_layout);

   return linear_image;
}


/**
 * Get pointer to tiled data for rendering.
 * \return pointer to the tiled data at the given tile position
 */
ubyte *
llvmpipe_get_texture_tile(struct llvmpipe_resource *lpr,
                          unsigned face_slice, unsigned level,
                          enum lp_texture_usage usage,
                          unsigned x, unsigned y)
{
   struct llvmpipe_texture_image *tiled_img = &lpr->tiled[level];
   enum lp_texture_layout cur_layout, new_layout;
   const unsigned tx = x / TILE_SIZE, ty = y / TILE_SIZE;
   boolean convert;
   uint8_t *tiled_image, *linear_image;
   unsigned tile_offset;

   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   if (!tiled_img->data) {
      /* allocate memory for the tiled image now */
      alloc_image_data(lpr, level, LP_TEX_LAYOUT_TILED);
   }

   /* compute address of the slice/face of the image that contains the tile */
   tiled_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                    LP_TEX_LAYOUT_TILED);
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                     LP_TEX_LAYOUT_LINEAR);

   /* get current tile layout and see if we need to convert the data */
   cur_layout = llvmpipe_get_texture_tile_layout(lpr, face_slice, level, tx, ty);

   layout_logic(cur_layout, LP_TEX_LAYOUT_TILED, usage, &new_layout, &convert);
   if (convert && linear_image && tiled_image) {
      lp_linear_to_tiled(linear_image, tiled_image,
                         x, y, TILE_SIZE, TILE_SIZE, lpr->base.format,
                         lpr->row_stride[level],
                         lpr->tiles_per_row[level]);
   }

   if (!tiled_image)
      return NULL;

   if (new_layout != cur_layout)
      llvmpipe_set_texture_tile_layout(lpr, face_slice, level, tx, ty, new_layout);

   /* compute, return address of the 64x64 tile */
   tile_offset = (ty * lpr->tiles_per_row[level] + tx)
         * TILE_SIZE * TILE_SIZE * 4;

   return (ubyte *) tiled_image + tile_offset;
}


/**
 * Get pointer to tiled data for rendering.
 * \return pointer to the tiled data at the given tile position
 */
void
llvmpipe_unswizzle_cbuf_tile(struct llvmpipe_resource *lpr,
                             unsigned face_slice, unsigned level,
                             unsigned x, unsigned y,
                             uint8_t *tile)
{
   struct llvmpipe_texture_image *linear_img = &lpr->linear[level];
   const unsigned tx = x / TILE_SIZE, ty = y / TILE_SIZE;
   uint8_t *linear_image;

   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   if (!linear_img->data) {
      /* allocate memory for the linear image now */
      alloc_image_data(lpr, level, LP_TEX_LAYOUT_LINEAR);
   }

   /* compute address of the slice/face of the image that contains the tile */
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                     LP_TEX_LAYOUT_LINEAR);

   {
      uint ii = x, jj = y;
      uint tile_offset = jj / TILE_SIZE + ii / TILE_SIZE;
      uint byte_offset = tile_offset * TILE_SIZE * TILE_SIZE * 4;
      
      /* Note that lp_tiled_to_linear expects the tile parameter to
       * point at the first tile in a whole-image sized array.  In
       * this code, we have only a single tile and have to do some
       * pointer arithmetic to figure out where the "image" would have
       * started.
       */
      lp_tiled_to_linear(tile - byte_offset, linear_image,
                         x, y, TILE_SIZE, TILE_SIZE,
                         lpr->base.format,
                         lpr->row_stride[level],
                         1);       /* tiles per row */
   }

   llvmpipe_set_texture_tile_layout(lpr, face_slice, level, tx, ty,
                                    LP_TEX_LAYOUT_LINEAR);
}


/**
 * Get pointer to tiled data for rendering.
 * \return pointer to the tiled data at the given tile position
 */
void
llvmpipe_swizzle_cbuf_tile(struct llvmpipe_resource *lpr,
                           unsigned face_slice, unsigned level,
                           unsigned x, unsigned y,
                           uint8_t *tile)
{
   uint8_t *linear_image;

   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   /* compute address of the slice/face of the image that contains the tile */
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level,
                                                     LP_TEX_LAYOUT_LINEAR);

   if (linear_image) {
      uint ii = x, jj = y;
      uint tile_offset = jj / TILE_SIZE + ii / TILE_SIZE;
      uint byte_offset = tile_offset * TILE_SIZE * TILE_SIZE * 4;

      /* Note that lp_linear_to_tiled expects the tile parameter to
       * point at the first tile in a whole-image sized array.  In
       * this code, we have only a single tile and have to do some
       * pointer arithmetic to figure out where the "image" would have
       * started.
       */
      lp_linear_to_tiled(linear_image, tile - byte_offset,
                         x, y, TILE_SIZE, TILE_SIZE,
                         lpr->base.format,
                         lpr->row_stride[level],
                         1);       /* tiles per row */
   }
}


/**
 * Return size of resource in bytes
 */
unsigned
llvmpipe_resource_size(const struct pipe_resource *resource)
{
   const struct llvmpipe_resource *lpr = llvmpipe_resource_const(resource);
   unsigned lvl, size = 0;

   for (lvl = 0; lvl <= lpr->base.last_level; lvl++) {
      if (lpr->linear[lvl].data)
         size += tex_image_size(lpr, lvl, LP_TEX_LAYOUT_LINEAR);

      if (lpr->tiled[lvl].data)
         size += tex_image_size(lpr, lvl, LP_TEX_LAYOUT_TILED);
   }

   return size;
}


#ifdef DEBUG
void
llvmpipe_print_resources(void)
{
   struct llvmpipe_resource *lpr;
   unsigned n = 0, total = 0;

   debug_printf("LLVMPIPE: current resources:\n");
   foreach(lpr, &resource_list) {
      unsigned size = llvmpipe_resource_size(&lpr->base);
      debug_printf("resource %u at %p, size %ux%ux%u: %u bytes, refcount %u\n",
                   lpr->id, (void *) lpr,
                   lpr->base.width0, lpr->base.height0, lpr->base.depth0,
                   size, lpr->base.reference.count);
      total += size;
      n++;
   }
   debug_printf("LLVMPIPE: total size of %u resources: %u\n", n, total);
}
#endif


d408 1
a408 1
llvmpipe_init_screen_resource_funcs(struct pipe_screen *screen)
d410 11
a420 35
#ifdef DEBUG
   /* init linked list for tracking resources */
   {
      static boolean first_call = TRUE;
      if (first_call) {
         memset(&resource_list, 0, sizeof(resource_list));
         make_empty_list(&resource_list);
         first_call = FALSE;
      }
   }
#endif

   screen->resource_create = llvmpipe_resource_create;
   screen->resource_destroy = llvmpipe_resource_destroy;
   screen->resource_from_handle = llvmpipe_resource_from_handle;
   screen->resource_get_handle = llvmpipe_resource_get_handle;
   screen->user_buffer_create = llvmpipe_user_buffer_create;

}


void
llvmpipe_init_context_resource_funcs(struct pipe_context *pipe)
{
   pipe->get_transfer = llvmpipe_get_transfer;
   pipe->transfer_destroy = llvmpipe_transfer_destroy;
   pipe->transfer_map = llvmpipe_transfer_map;
   pipe->transfer_unmap = llvmpipe_transfer_unmap;
   pipe->is_resource_referenced = llvmpipe_is_resource_referenced;
 
   pipe->transfer_flush_region = u_default_transfer_flush_region;
   pipe->transfer_inline_write = u_default_transfer_inline_write;

   pipe->create_surface = llvmpipe_create_surface;
   pipe->surface_destroy = llvmpipe_surface_destroy;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d49 1
a52 1
#include "lp_rast.h"
d63 39
a114 2
   uint64_t total_size = 0;
   unsigned layers = pt->array_size;
d121 1
a121 1
      /* Row stride and image stride */
d123 1
a123 1
         unsigned align_x, align_y, nblocksx, nblocksy, block_size;
d125 2
a126 7
         /* For non-compressed formats we need 4x4 pixel alignment
          * so we can read/write LP_RASTER_BLOCK_SIZE when rendering to them.
          * We also want cache line size in x direction,
          * otherwise same cache line could end up in multiple threads.
          * For explicit 1d resources however we reduce this to 4x1 and
          * handle specially in render output code (as we need to do special
          * handling there for buffers in any case).
d129 3
a131 8
            align_x = align_y = 1;
         else {
            align_x = LP_RASTER_BLOCK_SIZE;
            if (llvmpipe_resource_is_1d(&lpr->base))
               align_y = 1;
            else
               align_y = LP_RASTER_BLOCK_SIZE;
         }
d134 1
a134 1
                                             align(width, align_x));
d136 1
a136 1
                                             align(height, align_y));
d139 1
a139 4
         if (util_format_is_compressed(pt->format))
            lpr->row_stride[level] = nblocksx * block_size;
         else
            lpr->row_stride[level] = align(nblocksx * block_size, util_cpu_caps.cacheline);
d141 2
a142 5
         /* if row_stride * height > LP_MAX_TEXTURE_SIZE */
         if (lpr->row_stride[level] > LP_MAX_TEXTURE_SIZE / nblocksy) {
            /* image too large */
            goto fail;
         }
d144 6
a149 1
         lpr->img_stride[level] = lpr->row_stride[level] * nblocksy;
d152 1
a152 1
      /* Number of 3D image slices, cube faces or texture array layers */
a159 3
         else if (lpr->base.target == PIPE_TEXTURE_1D_ARRAY ||
                  lpr->base.target == PIPE_TEXTURE_2D_ARRAY)
            num_slices = layers;
a163 1
      }
d165 1
a165 11
      /* if img_stride * num_slices_faces > LP_MAX_TEXTURE_SIZE */
      if (lpr->img_stride[level] >
          LP_MAX_TEXTURE_SIZE / lpr->num_slices_faces[level]) {
         /* volume too large */
         goto fail;
      }

      total_size += (uint64_t) lpr->num_slices_faces[level]
                  * (uint64_t) lpr->img_stride[level];
      if (total_size > LP_MAX_TEXTURE_SIZE) {
         goto fail;
a174 3

fail:
   return FALSE;
a177 14
/**
 * Check the size of the texture specified by 'res'.
 * \return TRUE if OK, FALSE if too large.
 */
static boolean
llvmpipe_can_create_resource(struct pipe_screen *screen,
                             const struct pipe_resource *res)
{
   struct llvmpipe_resource lpr;
   memset(&lpr, 0, sizeof(lpr));
   lpr.base = *res;
   return llvmpipe_texture_layout(llvmpipe_screen(screen), &lpr);
}

d188 4
a191 2
   const unsigned width = MAX2(1, align(lpr->base.width0, TILE_SIZE));
   const unsigned height = MAX2(1, align(lpr->base.height0, TILE_SIZE));
d193 2
d198 3
d208 1
a208 14
   if (lpr->dt == NULL)
      return FALSE;

   {
      void *map = winsys->displaytarget_map(winsys, lpr->dt,
                                            PIPE_TRANSFER_WRITE);

      if (map)
         memset(map, 0, height * lpr->row_stride[0]);

      winsys->displaytarget_unmap(winsys, lpr->dt);
   }

   return TRUE;
d227 2
a228 4
   if (llvmpipe_resource_is_texture(&lpr->base)) {
      if (lpr->base.bind & (PIPE_BIND_DISPLAY_TARGET |
                            PIPE_BIND_SCANOUT |
                            PIPE_BIND_SHARED)) {
d232 1
d238 1
d240 1
d244 8
a251 17
      const uint bytes = templat->width0;
      assert(util_format_get_blocksize(templat->format) == 1);
      assert(templat->height0 == 1);
      assert(templat->depth0 == 1);
      assert(templat->last_level == 0);
      /*
       * Reserve some extra storage since if we'd render to a buffer we
       * read/write always LP_RASTER_BLOCK_SIZE pixels, but the element
       * offset doesn't need to be aligned to LP_RASTER_BLOCK_SIZE.
       */
      lpr->data = align_malloc(bytes + (LP_RASTER_BLOCK_SIZE - 1) * 4 * sizeof(float), 16);
      /*
       * buffers don't really have stride but it's probably safer
       * (for code doing same calculations for buffers and textures)
       * to put something sane in there.
       */
      lpr->row_stride[0] = bytes;
a253 1
      memset(lpr->data, 0, bytes);
d272 1
a272 1
                          struct pipe_resource *pt)
d281 7
d289 4
a292 1
   else if (llvmpipe_resource_is_texture(pt)) {
d294 19
a312 3
      if (lpr->linear_img.data) {
         align_free(lpr->linear_img.data);
         lpr->linear_img.data = NULL;
d336 2
a337 1
                      enum lp_texture_usage tex_usage)
d349 4
d358 1
d374 6
a379 1
      lpr->linear_img.data = map;
d381 1
a381 1
      return map;
d383 1
a383 1
   else if (llvmpipe_resource_is_texture(resource)) {
d385 2
a386 1
      map = llvmpipe_get_texture_image(lpr, layer, level, tex_usage);
d413 5
d428 1
a428 1
   assert(!llvmpipe_resource_is_texture(resource));
d436 2
a437 2
                              const struct pipe_resource *template,
                              struct winsys_handle *whandle)
d440 2
a441 1
   struct llvmpipe_resource *lpr;
d445 2
a446 4
   lpr = CALLOC_STRUCT(llvmpipe_resource);
   if (!lpr) {
      goto no_lpr;
   }
d452 5
d466 2
d475 7
a481 3
   if (!lpr->dt) {
      goto no_dt;
   }
d491 1
a491 1
no_dt:
a492 1
no_lpr:
d513 47
a559 7
static void *
llvmpipe_transfer_map( struct pipe_context *pipe,
                       struct pipe_resource *resource,
                       unsigned level,
                       unsigned usage,
                       const struct pipe_box *box,
                       struct pipe_transfer **transfer )
d562 2
a563 8
   struct llvmpipe_screen *screen = llvmpipe_screen(pipe->screen);
   struct llvmpipe_resource *lpr = llvmpipe_resource(resource);
   struct llvmpipe_transfer *lpt;
   struct pipe_transfer *pt;
   ubyte *map;
   enum pipe_format format;
   enum lp_texture_usage tex_usage;
   const char *mode;
d577 2
d591 14
a604 11
   /* Check if we're mapping the current constant buffer */
   if ((usage & PIPE_TRANSFER_WRITE) &&
       (resource->bind & PIPE_BIND_CONSTANT_BUFFER)) {
      unsigned i;
      for (i = 0; i < Elements(llvmpipe->constants[PIPE_SHADER_FRAGMENT]); ++i) {
         if (resource == llvmpipe->constants[PIPE_SHADER_FRAGMENT][i].buffer) {
            /* constants may have changed */
            llvmpipe->dirty |= LP_NEW_CONSTANTS;
            break;
         }
      }
d606 17
d624 10
a633 11
   lpt = CALLOC_STRUCT(llvmpipe_transfer);
   if (!lpt)
      return NULL;
   pt = &lpt->base;
   pipe_resource_reference(&pt->resource, resource);
   pt->box = *box;
   pt->level = level;
   pt->stride = lpr->row_stride[level];
   pt->layer_stride = lpr->img_stride[level];
   pt->usage = usage;
   *transfer = pt;
d635 1
a635 1
   assert(level < LP_MAX_TEXTURE_LEVELS);
d645 1
a645 1
   if (usage == PIPE_TRANSFER_READ) {
d655 1
d659 3
d664 4
a667 4
   map = llvmpipe_resource_map(resource,
                               level,
                               box->z,
                               tex_usage);
d673 1
a673 1
   if (usage & PIPE_TRANSFER_WRITE) {
d680 2
a681 2
      box->y / util_format_get_blockheight(format) * pt->stride +
      box->x / util_format_get_blockwidth(format) * util_format_get_blocksize(format);
a695 8

   /* Effectively do the texture_update work here - if texture images
    * needed post-processing to put them into hardware layout, this is
    * where it would happen.  For llvmpipe, nothing to do.
    */
   assert (transfer->resource);
   pipe_resource_reference(&transfer->resource, NULL);
   FREE(transfer);
d698 1
a698 1
unsigned int
d701 1
a701 1
                                 unsigned level)
d705 2
a706 10
   /*
    * XXX checking only resources with the right bind flags
    * is unsafe since with opengl state tracker we can end up
    * with resources bound to places they weren't supposed to be
    * (buffers bound as sampler views is one possibility here).
    */
   if (!(presource->bind & (PIPE_BIND_DEPTH_STENCIL |
                            PIPE_BIND_RENDER_TARGET |
                            PIPE_BIND_SAMPLER_VIEW)))
      return LP_UNREFERENCED;
a711 28
/**
 * Returns the largest possible alignment for a format in llvmpipe
 */
unsigned
llvmpipe_get_format_alignment( enum pipe_format format )
{
   const struct util_format_description *desc = util_format_description(format);
   unsigned size = 0;
   unsigned bytes;
   unsigned i;

   for (i = 0; i < desc->nr_channels; ++i) {
      size += desc->channel[i].size;
   }

   bytes = size / 8;

   if (!util_is_power_of_two(bytes)) {
      bytes /= desc->nr_channels;
   }

   if (bytes % 2 || bytes < 1) {
      return 1;
   } else {
      return bytes;
   }
}

d716 1
a716 1
struct pipe_resource *
d747 1
a747 1
 * for just one cube face, one array layer or one 3D texture slice
d750 2
a751 1
tex_image_face_size(const struct llvmpipe_resource *lpr, unsigned level)
d753 21
a773 1
   return lpr->img_stride[level];
d782 2
a783 1
tex_image_size(const struct llvmpipe_resource *lpr, unsigned level)
d785 1
a785 1
   const unsigned buf_size = tex_image_face_size(lpr, level);
d791 59
d855 2
a856 1
                                   unsigned face_slice, unsigned level)
d861 7
a867 2
   img = &lpr->linear_img;
   offset = lpr->linear_mip_offsets[level];
d870 3
a872 1
      offset += face_slice * tex_image_face_size(lpr, level);
d878 29
d908 20
a927 2
 * Allocate storage for a linear image
 * (all cube faces and all 3D slices, all levels).
d930 2
a931 1
alloc_image_data(struct llvmpipe_resource *lpr)
a933 2
   uint level;
   uint offset = 0;
d935 2
a936 6
   if (lpr->dt) {
      /* we get the linear memory from the winsys, and it has
       * already been zeroed
       */
      struct llvmpipe_screen *screen = llvmpipe_screen(lpr->base.screen);
      struct sw_winsys *winsys = screen->winsys;
d938 4
a941 5
      assert(lpr->base.last_level == 0);

      lpr->linear_img.data =
         winsys->displaytarget_map(winsys, lpr->dt,
                                   PIPE_TRANSFER_READ_WRITE);
d944 9
a952 9
      /* not a display target - allocate regular memory */
      /*
       * Offset calculation for start of a specific mip/layer is always
       * offset = lpr->linear_mip_offsets[level] + lpr->img_stride[level] * layer
       */
      for (level = 0; level <= lpr->base.last_level; level++) {
         uint buffer_size = tex_image_size(lpr, level);
         lpr->linear_mip_offsets[level] = offset;
         offset += align(buffer_size, alignment);
d954 4
a957 3
      lpr->linear_img.data = align_malloc(offset, alignment);
      if (lpr->linear_img.data) {
         memset(lpr->linear_img.data, 0, offset);
d965 1
a965 1
 * Return pointer to texture image data
d970 1
d975 2
a976 1
                           enum lp_texture_usage usage)
d978 6
d985 1
d987 11
a997 2
   unsigned target_offset;
   unsigned *target_off_ptr;
d1003 9
d1013 13
a1025 1
      assert(lpr->linear_img.data);
a1027 2
   target_img = &lpr->linear_img;
   target_off_ptr = lpr->linear_mip_offsets;
d1029 1
d1033 1
a1033 1
      alloc_image_data(lpr);
d1037 2
a1038 1
   target_offset = target_off_ptr[level];
d1040 15
a1054 2
   if (face_slice > 0) {
      target_offset += face_slice * tex_image_face_size(lpr, level);
d1057 44
a1100 2
   if (target_data) {
      target_data = (uint8_t *) target_data + target_offset;
d1109 2
d1116 2
a1117 1
                               enum lp_texture_usage usage)
d1126 1
a1126 1
      map = llvmpipe_get_texture_image(lpr, slice, level, usage);
d1134 3
a1136 1
 * Get pointer to a linear image (not the tile!) at tile (x,y).
d1145 109
a1253 1
   struct llvmpipe_texture_image *linear_img = &lpr->linear_img;
a1255 1
   assert(llvmpipe_resource_is_texture(&lpr->base));
d1261 1
a1261 2
      /* XXX should probably not do that here? */
      alloc_image_data(lpr);
a1262 1
   assert(linear_img->data);
d1265 44
a1308 1
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level);
d1310 17
a1326 1
   return linear_image;
d1339 6
a1344 8
   if (llvmpipe_resource_is_texture(resource)) {
      for (lvl = 0; lvl <= lpr->base.last_level; lvl++) {
         if (lpr->linear_img.data)
            size += tex_image_size(lpr, lvl);
      }
   }
   else {
      size = resource->width0;
d1392 2
a1393 1
   screen->can_create_resource = llvmpipe_can_create_resource;
d1400 2
d1404 2
a1405 1

d1408 3
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2006 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d29 2
a30 2
  *   Keith Whitwell <keithw@@vmware.com>
  *   Michel DÃ¤nzer <daenzer@@vmware.com>
d118 1
a118 1
         if ((uint64_t)lpr->row_stride[level] * nblocksy > LP_MAX_TEXTURE_SIZE) {
d203 1
a203 1
                                          64,
d264 1
a264 1
      lpr->data = align_malloc(bytes + (LP_RASTER_BLOCK_SIZE - 1) * 4 * sizeof(float), 64);
d749 1
a749 1
   uint alignment = MAX2(64, util_cpu_caps.cacheline);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d65 1
a65 1
 * Compute strides and allocate data (unless asked not to).
d69 1
a69 2
                        struct llvmpipe_resource *lpr,
                        boolean allocate)
a77 8
   /* XXX:
    * This alignment here (same for displaytarget) was added for the purpose of
    * ARB_map_buffer_alignment. I am not convinced it's needed for non-buffer
    * resources. Otherwise we'd want the max of cacheline size and 16 (max size
    * of a block for all formats) though this should not be strictly necessary
    * neither. In any case it can only affect compressed or 1d textures.
    */
   unsigned mip_align = MAX2(64, util_cpu_caps.cacheline);
a82 2
      uint64_t mipsize;
      unsigned align_x, align_y, nblocksx, nblocksy, block_size, num_slices;
d85 20
d106 8
a113 14
      /* For non-compressed formats we need 4x4 pixel alignment
       * so we can read/write LP_RASTER_BLOCK_SIZE when rendering to them.
       * We also want cache line size in x direction,
       * otherwise same cache line could end up in multiple threads.
       * For explicit 1d resources however we reduce this to 4x1 and
       * handle specially in render output code (as we need to do special
       * handling there for buffers in any case).
       */
      if (util_format_is_compressed(pt->format))
         align_x = align_y = 1;
      else {
         align_x = LP_RASTER_BLOCK_SIZE;
         if (llvmpipe_resource_is_1d(&lpr->base))
            align_y = 1;
d115 9
a123 1
            align_y = LP_RASTER_BLOCK_SIZE;
d126 3
a128 16
      nblocksx = util_format_get_nblocksx(pt->format,
                                          align(width, align_x));
      nblocksy = util_format_get_nblocksy(pt->format,
                                          align(height, align_y));
      block_size = util_format_get_blocksize(pt->format);

      if (util_format_is_compressed(pt->format))
         lpr->row_stride[level] = nblocksx * block_size;
      else
         lpr->row_stride[level] = align(nblocksx * block_size, util_cpu_caps.cacheline);

      /* if row_stride * height > LP_MAX_TEXTURE_SIZE */
      if ((uint64_t)lpr->row_stride[level] * nblocksy > LP_MAX_TEXTURE_SIZE) {
         /* image too large */
         goto fail;
      }
d130 9
a138 1
      lpr->img_stride[level] = lpr->row_stride[level] * nblocksy;
d140 1
a140 3
      /* Number of 3D image slices, cube faces or texture array layers */
      if (lpr->base.target == PIPE_TEXTURE_CUBE) {
         assert(layers == 6);
a142 10
      if (lpr->base.target == PIPE_TEXTURE_3D)
         num_slices = depth;
      else if (lpr->base.target == PIPE_TEXTURE_1D_ARRAY ||
               lpr->base.target == PIPE_TEXTURE_2D_ARRAY ||
               lpr->base.target == PIPE_TEXTURE_CUBE ||
               lpr->base.target == PIPE_TEXTURE_CUBE_ARRAY)
         num_slices = layers;
      else
         num_slices = 1;

d144 2
a145 2
      mipsize = (uint64_t)lpr->img_stride[level] * num_slices;
      if (mipsize > LP_MAX_TEXTURE_SIZE) {
d150 2
a151 3
      lpr->mip_offsets[level] = total_size;

      total_size += align((unsigned)mipsize, mip_align);
a161 10
   if (allocate) {
      lpr->tex_data = align_malloc(total_size, mip_align);
      if (!lpr->tex_data) {
         return FALSE;
      }
      else {
         memset(lpr->tex_data, 0, total_size);
      }
   }

d180 1
a180 1
   return llvmpipe_texture_layout(llvmpipe_screen(screen), &lpr, false);
d196 3
d248 1
a248 1
         if (!llvmpipe_texture_layout(screen, lpr, true))
a264 1

d304 3
a306 3
      if (lpr->tex_data) {
         align_free(lpr->tex_data);
         lpr->tex_data = NULL;
d362 1
a362 1
      lpr->tex_data = map;
d368 1
a368 1
      map = llvmpipe_get_texture_image_address(lpr, layer, level);
d439 3
d673 1
a673 1
                            unsigned bind_flags)
d710 12
d729 1
d732 139
d872 2
d875 6
a880 1
   offset = lpr->mip_offsets[level];
d882 2
a883 2
   if (face_slice > 0)
      offset += face_slice * tex_image_face_size(lpr, level);
d885 1
a885 1
   return (ubyte *) lpr->tex_data + offset;
d896 1
a896 1
   unsigned size = 0;
d899 4
a902 2
      /* Note this will always return 0 for displaytarget resources */
      size = lpr->total_alloc_size;
d907 1
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d65 1
a65 1
 * Just compute row strides here.  Storage is allocated on demand later.
d69 2
a70 1
                        struct llvmpipe_resource *lpr)
d79 8
d92 2
a95 2
      {
         unsigned align_x, align_y, nblocksx, nblocksy, block_size;
d97 14
a110 26
         /* For non-compressed formats we need 4x4 pixel alignment
          * so we can read/write LP_RASTER_BLOCK_SIZE when rendering to them.
          * We also want cache line size in x direction,
          * otherwise same cache line could end up in multiple threads.
          * For explicit 1d resources however we reduce this to 4x1 and
          * handle specially in render output code (as we need to do special
          * handling there for buffers in any case).
          */
         if (util_format_is_compressed(pt->format))
            align_x = align_y = 1;
         else {
            align_x = LP_RASTER_BLOCK_SIZE;
            if (llvmpipe_resource_is_1d(&lpr->base))
               align_y = 1;
            else
               align_y = LP_RASTER_BLOCK_SIZE;
         }

         nblocksx = util_format_get_nblocksx(pt->format,
                                             align(width, align_x));
         nblocksy = util_format_get_nblocksy(pt->format,
                                             align(height, align_y));
         block_size = util_format_get_blocksize(pt->format);

         if (util_format_is_compressed(pt->format))
            lpr->row_stride[level] = nblocksx * block_size;
d112 2
a113 1
            lpr->row_stride[level] = align(nblocksx * block_size, util_cpu_caps.cacheline);
d115 16
a130 5
         /* if row_stride * height > LP_MAX_TEXTURE_SIZE */
         if ((uint64_t)lpr->row_stride[level] * nblocksy > LP_MAX_TEXTURE_SIZE) {
            /* image too large */
            goto fail;
         }
d132 1
a132 2
         lpr->img_stride[level] = lpr->row_stride[level] * nblocksy;
      }
d135 3
a137 12
      {
         unsigned num_slices;

         if (lpr->base.target == PIPE_TEXTURE_CUBE)
            num_slices = 6;
         else if (lpr->base.target == PIPE_TEXTURE_3D)
            num_slices = depth;
         else if (lpr->base.target == PIPE_TEXTURE_1D_ARRAY ||
                  lpr->base.target == PIPE_TEXTURE_2D_ARRAY)
            num_slices = layers;
         else
            num_slices = 1;
d139 9
a147 2
         lpr->num_slices_faces[level] = num_slices;
      }
d150 2
a151 2
      if (lpr->img_stride[level] >
          LP_MAX_TEXTURE_SIZE / lpr->num_slices_faces[level]) {
d156 3
a158 2
      total_size += (uint64_t) lpr->num_slices_faces[level]
                  * (uint64_t) lpr->img_stride[level];
d169 10
d197 1
a197 1
   return llvmpipe_texture_layout(llvmpipe_screen(screen), &lpr);
a212 3
   lpr->num_slices_faces[0] = 1;
   lpr->img_stride[0] = 0;

d262 1
a262 1
         if (!llvmpipe_texture_layout(screen, lpr))
d279 1
d319 3
a321 3
      if (lpr->linear_img.data) {
         align_free(lpr->linear_img.data);
         lpr->linear_img.data = NULL;
d377 1
a377 1
      lpr->linear_img.data = map;
d383 1
a383 1
      map = llvmpipe_get_texture_image(lpr, layer, level, tex_usage);
a453 3
   lpr->num_slices_faces[0] = 1;
   lpr->img_stride[0] = 0;

d685 1
a685 1
			    unsigned bind_flags)
a721 12
 * Compute size (in bytes) need to store a texture image / mipmap level,
 * including all cube faces or 3D image slices
 */
static unsigned
tex_image_size(const struct llvmpipe_resource *lpr, unsigned level)
{
   const unsigned buf_size = tex_image_face_size(lpr, level);
   return buf_size * lpr->num_slices_faces[level];
}


/**
a728 1
   struct llvmpipe_texture_image *img;
d731 3
a733 2
   img = &lpr->linear_img;
   offset = lpr->linear_mip_offsets[level];
d738 1
a738 148
   return (ubyte *) img->data + offset;
}


/**
 * Allocate storage for a linear image
 * (all cube faces and all 3D slices, all levels).
 */
static void
alloc_image_data(struct llvmpipe_resource *lpr)
{
   uint alignment = MAX2(64, util_cpu_caps.cacheline);
   uint level;
   uint offset = 0;

   if (lpr->dt) {
      /* we get the linear memory from the winsys, and it has
       * already been zeroed
       */
      struct llvmpipe_screen *screen = llvmpipe_screen(lpr->base.screen);
      struct sw_winsys *winsys = screen->winsys;

      assert(lpr->base.last_level == 0);

      lpr->linear_img.data =
         winsys->displaytarget_map(winsys, lpr->dt,
                                   PIPE_TRANSFER_READ_WRITE);
   }
   else {
      /* not a display target - allocate regular memory */
      /*
       * Offset calculation for start of a specific mip/layer is always
       * offset = lpr->linear_mip_offsets[level] + lpr->img_stride[level] * layer
       */
      for (level = 0; level <= lpr->base.last_level; level++) {
         uint buffer_size = tex_image_size(lpr, level);
         lpr->linear_mip_offsets[level] = offset;
         offset += align(buffer_size, alignment);
      }
      lpr->linear_img.data = align_malloc(offset, alignment);
      if (lpr->linear_img.data) {
         memset(lpr->linear_img.data, 0, offset);
      }
   }
}



/**
 * Return pointer to texture image data
 * for a particular cube face or 3D texture slice.
 *
 * \param face_slice  the cube face or 3D slice of interest
 * \param usage  one of LP_TEX_USAGE_READ/WRITE_ALL/READ_WRITE
 */
void *
llvmpipe_get_texture_image(struct llvmpipe_resource *lpr,
                           unsigned face_slice, unsigned level,
                           enum lp_texture_usage usage)
{
   struct llvmpipe_texture_image *target_img;
   void *target_data;
   unsigned target_offset;
   unsigned *target_off_ptr;

   assert(usage == LP_TEX_USAGE_READ ||
          usage == LP_TEX_USAGE_READ_WRITE ||
          usage == LP_TEX_USAGE_WRITE_ALL);

   if (lpr->dt) {
      assert(lpr->linear_img.data);
   }

   target_img = &lpr->linear_img;
   target_off_ptr = lpr->linear_mip_offsets;
   target_data = target_img->data;

   if (!target_data) {
      /* allocate memory for the target image now */
      alloc_image_data(lpr);
      target_data = target_img->data;
   }

   target_offset = target_off_ptr[level];

   if (face_slice > 0) {
      target_offset += face_slice * tex_image_face_size(lpr, level);
   }

   if (target_data) {
      target_data = (uint8_t *) target_data + target_offset;
   }

   return target_data;
}


/**
 * Return pointer to start of a texture image (1D, 2D, 3D, CUBE).
 * This is typically used when we're about to sample from a texture.
 */
void *
llvmpipe_get_texture_image_all(struct llvmpipe_resource *lpr,
                               unsigned level,
                               enum lp_texture_usage usage)
{
   const int slices = lpr->num_slices_faces[level];
   int slice;
   void *map = NULL;

   assert(slices > 0);

   for (slice = slices - 1; slice >= 0; slice--) {
      map = llvmpipe_get_texture_image(lpr, slice, level, usage);
   }

   return map;
}


/**
 * Get pointer to a linear image (not the tile!) at tile (x,y).
 * \return pointer to start of image/face (not the tile)
 */
ubyte *
llvmpipe_get_texture_tile_linear(struct llvmpipe_resource *lpr,
                                 unsigned face_slice, unsigned level,
                                 enum lp_texture_usage usage,
                                 unsigned x, unsigned y)
{
   struct llvmpipe_texture_image *linear_img = &lpr->linear_img;
   uint8_t *linear_image;

   assert(llvmpipe_resource_is_texture(&lpr->base));
   assert(x % TILE_SIZE == 0);
   assert(y % TILE_SIZE == 0);

   if (!linear_img->data) {
      /* allocate memory for the linear image now */
      /* XXX should probably not do that here? */
      alloc_image_data(lpr);
   }
   assert(linear_img->data);

   /* compute address of the slice/face of the image that contains the tile */
   linear_image = llvmpipe_get_texture_image_address(lpr, face_slice, level);

   return linear_image;
d749 1
a749 1
   unsigned lvl, size = 0;
d752 2
a753 4
      for (lvl = 0; lvl <= lpr->base.last_level; lvl++) {
         if (lpr->linear_img.data)
            size += tex_image_size(lpr, lvl);
      }
a757 1

@


