head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.34;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.28;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.58;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * Interface between 'draw' module's output and the llvmpipe rasterizer/setup
 * code.  When the 'draw' module has finished filling a vertex buffer, the
 * draw_arrays() functions below will be called.  Loop over the vertices and
 * call the point/line/tri setup functions.
 *
 * Authors
 *  Brian Paul
 */


#include "lp_setup_context.h"
#include "lp_context.h"
#include "draw/draw_vbuf.h"
#include "draw/draw_vertex.h"
#include "util/u_memory.h"


#define LP_MAX_VBUF_INDEXES 1024
#define LP_MAX_VBUF_SIZE    4096

  

/** cast wrapper */
static struct lp_setup_context *
lp_setup_context(struct vbuf_render *vbr)
{
   return (struct lp_setup_context *) vbr;
}



static const struct vertex_info *
lp_setup_get_vertex_info(struct vbuf_render *vbr)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);

   /* Vertex size/info depends on the latest state.
    * The draw module may have issued additional state-change commands.
    */
   lp_setup_update_state(setup, FALSE);

   return setup->vertex_info;
}


static boolean
lp_setup_allocate_vertices(struct vbuf_render *vbr,
                          ushort vertex_size, ushort nr_vertices)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   unsigned size = vertex_size * nr_vertices;

   if (setup->vertex_buffer_size < size) {
      align_free(setup->vertex_buffer);
      setup->vertex_buffer = align_malloc(size, 16);
      setup->vertex_buffer_size = size;
   }

   setup->vertex_size = vertex_size;
   setup->nr_vertices = nr_vertices;
   
   return setup->vertex_buffer != NULL;
}

static void
lp_setup_release_vertices(struct vbuf_render *vbr)
{
   /* keep the old allocation for next time */
}

static void *
lp_setup_map_vertices(struct vbuf_render *vbr)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   return setup->vertex_buffer;
}

static void 
lp_setup_unmap_vertices(struct vbuf_render *vbr, 
                       ushort min_index,
                       ushort max_index )
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   assert( setup->vertex_buffer_size >= (max_index+1) * setup->vertex_size );
   /* do nothing */
}


static void
lp_setup_set_primitive(struct vbuf_render *vbr, unsigned prim)
{
   lp_setup_context(vbr)->prim = prim;
}

typedef const float (*const_float4_ptr)[4];

static INLINE const_float4_ptr get_vert( const void *vertex_buffer,
                                         int index,
                                         int stride )
{
   return (const_float4_ptr)((char *)vertex_buffer + index * stride);
}

/**
 * draw elements / indexed primitives
 */
static void
lp_setup_draw_elements(struct vbuf_render *vbr, const ushort *indices, uint nr)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   const unsigned stride = setup->vertex_info->size * sizeof(float);
   const void *vertex_buffer = setup->vertex_buffer;
   const boolean flatshade_first = setup->flatshade_first;
   unsigned i;

   assert(setup->setup.variant);

   if (!lp_setup_update_state(setup, TRUE))
      return;

   switch (setup->prim) {
   case PIPE_PRIM_POINTS:
      for (i = 0; i < nr; i++) {
         setup->point( setup,
                       get_vert(vertex_buffer, indices[i-0], stride) );
      }
      break;

   case PIPE_PRIM_LINES:
      for (i = 1; i < nr; i += 2) {
         setup->line( setup,
                      get_vert(vertex_buffer, indices[i-1], stride),
                      get_vert(vertex_buffer, indices[i-0], stride) );
      }
      break;

   case PIPE_PRIM_LINE_STRIP:
      for (i = 1; i < nr; i ++) {
         setup->line( setup,
                      get_vert(vertex_buffer, indices[i-1], stride),
                      get_vert(vertex_buffer, indices[i-0], stride) );
      }
      break;

   case PIPE_PRIM_LINE_LOOP:
      for (i = 1; i < nr; i ++) {
         setup->line( setup,
                      get_vert(vertex_buffer, indices[i-1], stride),
                      get_vert(vertex_buffer, indices[i-0], stride) );
      }
      if (nr) {
         setup->line( setup,
                      get_vert(vertex_buffer, indices[nr-1], stride),
                      get_vert(vertex_buffer, indices[0], stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLES:
      for (i = 2; i < nr; i += 3) {
         setup->triangle( setup,
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLE_STRIP:
      if (flatshade_first) {
         for (i = 2; i < nr; i += 1) {
            /* emit first triangle vertex as first triangle vertex */
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-2], stride),
                             get_vert(vertex_buffer, indices[i+(i&1)-1], stride),
                             get_vert(vertex_buffer, indices[i-(i&1)], stride) );

         }
      }
      else {
         for (i = 2; i < nr; i += 1) {
            /* emit last triangle vertex as last triangle vertex */
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i+(i&1)-2], stride),
                             get_vert(vertex_buffer, indices[i-(i&1)-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      break;

   case PIPE_PRIM_TRIANGLE_FAN:
      if (flatshade_first) {
         for (i = 2; i < nr; i += 1) {
            /* emit first non-spoke vertex as first vertex */
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[0], stride) );
         }
      }
      else {
         for (i = 2; i < nr; i += 1) {
            /* emit last non-spoke vertex as last vertex */
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[0], stride),
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      break;

   case PIPE_PRIM_QUADS:
      /* GL quads don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
         for (i = 3; i < nr; i += 4) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[i-3], stride),
                             get_vert(vertex_buffer, indices[i-2], stride) );

            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[i-2], stride),
                             get_vert(vertex_buffer, indices[i-1], stride) );
         }
      }
      else {
         /* emit last quad vertex as last triangle vertex */
         for (i = 3; i < nr; i += 4) {
            setup->triangle( setup,
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );

            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-2], stride),
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      break;

   case PIPE_PRIM_QUAD_STRIP:
      /* GL quad strips don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
         for (i = 3; i < nr; i += 2) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[i-3], stride),
                             get_vert(vertex_buffer, indices[i-2], stride) );
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-3], stride) );
         }
      }
      else {
         /* emit last quad vertex as last triangle vertex */
         for (i = 3; i < nr; i += 2) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-3], stride),
                             get_vert(vertex_buffer, indices[i-2], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-3], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      break;

   case PIPE_PRIM_POLYGON:
      /* Almost same as tri fan but the _first_ vertex specifies the flat
       * shading color.
       */
      if (flatshade_first) { 
         /* emit first polygon  vertex as first triangle vertex */
         for (i = 2; i < nr; i += 1) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[0], stride),
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      else {
         /* emit first polygon  vertex as last triangle vertex */
         for (i = 2; i < nr; i += 1) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[0], stride) );
         }
      }
      break;

   default:
      assert(0);
   }
}


/**
 * This function is hit when the draw module is working in pass-through mode.
 * It's up to us to convert the vertex array into point/line/tri prims.
 */
static void
lp_setup_draw_arrays(struct vbuf_render *vbr, uint start, uint nr)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   const unsigned stride = setup->vertex_info->size * sizeof(float);
   const void *vertex_buffer =
      (void *) get_vert(setup->vertex_buffer, start, stride);
   const boolean flatshade_first = setup->flatshade_first;
   unsigned i;

   if (!lp_setup_update_state(setup, TRUE))
      return;

   switch (setup->prim) {
   case PIPE_PRIM_POINTS:
      for (i = 0; i < nr; i++) {
         setup->point( setup,
                       get_vert(vertex_buffer, i-0, stride) );
      }
      break;

   case PIPE_PRIM_LINES:
      for (i = 1; i < nr; i += 2) {
         setup->line( setup,
                      get_vert(vertex_buffer, i-1, stride),
                      get_vert(vertex_buffer, i-0, stride) );
      }
      break;

   case PIPE_PRIM_LINE_STRIP:
      for (i = 1; i < nr; i ++) {
         setup->line( setup,
                      get_vert(vertex_buffer, i-1, stride),
                      get_vert(vertex_buffer, i-0, stride) );
      }
      break;

   case PIPE_PRIM_LINE_LOOP:
      for (i = 1; i < nr; i ++) {
         setup->line( setup,
                      get_vert(vertex_buffer, i-1, stride),
                      get_vert(vertex_buffer, i-0, stride) );
      }
      if (nr) {
         setup->line( setup,
                      get_vert(vertex_buffer, nr-1, stride),
                      get_vert(vertex_buffer, 0, stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLES:
      for (i = 2; i < nr; i += 3) {
         setup->triangle( setup,
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
      }
      break;

   case PIPE_PRIM_TRIANGLE_STRIP:
      if (flatshade_first) {
         for (i = 2; i < nr; i++) {
            /* emit first triangle vertex as first triangle vertex */
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-2, stride),
                             get_vert(vertex_buffer, i+(i&1)-1, stride),
                             get_vert(vertex_buffer, i-(i&1), stride) );
         }
      }
      else {
         for (i = 2; i < nr; i++) {
            /* emit last triangle vertex as last triangle vertex */
            setup->triangle( setup,
                             get_vert(vertex_buffer, i+(i&1)-2, stride),
                             get_vert(vertex_buffer, i-(i&1)-1, stride),
                             get_vert(vertex_buffer, i-0, stride) );
         }
      }
      break;

   case PIPE_PRIM_TRIANGLE_FAN:
      if (flatshade_first) {
         for (i = 2; i < nr; i += 1) {
            /* emit first non-spoke vertex as first vertex */
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, 0, stride)  );
         }
      }
      else {
         for (i = 2; i < nr; i += 1) {
            /* emit last non-spoke vertex as last vertex */
            setup->triangle( setup,
                             get_vert(vertex_buffer, 0, stride),
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride) );
         }
      }
      break;

   case PIPE_PRIM_QUADS:
      /* GL quads don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
         for (i = 3; i < nr; i += 4) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, i-3, stride),
                             get_vert(vertex_buffer, i-2, stride) );
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, i-2, stride),
                             get_vert(vertex_buffer, i-1, stride) );
         }
      }
      else {
         /* emit last quad vertex as last triangle vertex */
         for (i = 3; i < nr; i += 4) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-3, stride),
                             get_vert(vertex_buffer, i-2, stride),
                             get_vert(vertex_buffer, i-0, stride) );
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-2, stride),
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride) );
         }
      }
      break;

   case PIPE_PRIM_QUAD_STRIP:
      /* GL quad strips don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
         for (i = 3; i < nr; i += 2) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, i-3, stride),
                             get_vert(vertex_buffer, i-2, stride) );
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-3, stride) );
         }
      }
      else {
         /* emit last quad vertex as last triangle vertex */
         for (i = 3; i < nr; i += 2) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-3, stride),
                             get_vert(vertex_buffer, i-2, stride),
                             get_vert(vertex_buffer, i-0, stride) );
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-3, stride),
                             get_vert(vertex_buffer, i-0, stride) );
         }
      }
      break;

   case PIPE_PRIM_POLYGON:
      /* Almost same as tri fan but the _first_ vertex specifies the flat
       * shading color.
       */
      if (flatshade_first) { 
         /* emit first polygon  vertex as first triangle vertex */
         for (i = 2; i < nr; i += 1) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, 0, stride),
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride) );
         }
      }
      else {
         /* emit first polygon  vertex as last triangle vertex */
         for (i = 2; i < nr; i += 1) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, 0, stride) );
         }
      }
      break;

   default:
      assert(0);
   }
}



static void
lp_setup_vbuf_destroy(struct vbuf_render *vbr)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   if (setup->vertex_buffer) {
      align_free(setup->vertex_buffer);
      setup->vertex_buffer = NULL;
   }
   lp_setup_destroy(setup);
}

/*
 * FIXME: it is unclear if primitives_storage_needed (which is generally
 * the same as pipe query num_primitives_generated) should increase
 * if SO is disabled for d3d10, but for GL we definitely need to
 * increase num_primitives_generated and this is only called for active
 * SO. If it must not increase for d3d10 need to disambiguate the counters
 * in the driver and do some work for getting correct values, if it should
 * increase too should call this from outside streamout code.
 */
static void
lp_setup_so_info(struct vbuf_render *vbr, uint primitives, uint prim_generated)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   struct llvmpipe_context *lp = llvmpipe_context(setup->pipe);

   lp->so_stats.num_primitives_written += primitives;
   lp->so_stats.primitives_storage_needed += prim_generated;
}

static void
lp_setup_pipeline_statistics(
   struct vbuf_render *vbr,
   const struct pipe_query_data_pipeline_statistics *stats)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   struct llvmpipe_context *llvmpipe = llvmpipe_context(setup->pipe);

   llvmpipe->pipeline_statistics.ia_vertices +=
      stats->ia_vertices;
   llvmpipe->pipeline_statistics.ia_primitives +=
      stats->ia_primitives;
   llvmpipe->pipeline_statistics.vs_invocations +=
      stats->vs_invocations;
   llvmpipe->pipeline_statistics.gs_invocations +=
      stats->gs_invocations;
   llvmpipe->pipeline_statistics.gs_primitives +=
      stats->gs_primitives;
   if (!llvmpipe_rasterization_disabled(llvmpipe)) {
      llvmpipe->pipeline_statistics.c_invocations +=
         stats->c_invocations;
   } else {
      llvmpipe->pipeline_statistics.c_invocations = 0;
   }
}

/**
 * Create the post-transform vertex handler for the given context.
 */
void
lp_setup_init_vbuf(struct lp_setup_context *setup)
{
   setup->base.max_indices = LP_MAX_VBUF_INDEXES;
   setup->base.max_vertex_buffer_bytes = LP_MAX_VBUF_SIZE;

   setup->base.get_vertex_info = lp_setup_get_vertex_info;
   setup->base.allocate_vertices = lp_setup_allocate_vertices;
   setup->base.map_vertices = lp_setup_map_vertices;
   setup->base.unmap_vertices = lp_setup_unmap_vertices;
   setup->base.set_primitive = lp_setup_set_primitive;
   setup->base.draw_elements = lp_setup_draw_elements;
   setup->base.draw_arrays = lp_setup_draw_arrays;
   setup->base.release_vertices = lp_setup_release_vertices;
   setup->base.destroy = lp_setup_vbuf_destroy;
   setup->base.set_stream_output_info = lp_setup_so_info;
   setup->base.pipeline_statistics = lp_setup_pipeline_statistics;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d537 9
d547 1
a547 2
lp_setup_so_info(struct vbuf_render *vbr, uint primitives, uint vertices,
                uint prim_generated)
d553 1
a553 3
   lp->so_stats.primitives_storage_needed =
      vertices * 4 /*sizeof(float|int32)*/ * 4 /*x,y,z,w*/;
   lp->num_primitives_generated += prim_generated;
d574 6
a579 2
   llvmpipe->pipeline_statistics.c_invocations +=
      stats->c_invocations;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d40 1
d117 1
a117 1
static boolean
a120 1
   return TRUE;
d537 34
d590 2
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d51 2
a52 2
static struct setup_context *
setup_context(struct vbuf_render *vbr)
d54 1
a54 1
   return (struct setup_context *) vbr;
d62 7
a68 1
   struct setup_context *setup = setup_context(vbr);
d77 1
a77 1
   struct setup_context *setup = setup_context(vbr);
d101 1
a101 1
   struct setup_context *setup = setup_context(vbr);
d110 1
a110 1
   struct setup_context *setup = setup_context(vbr);
d119 1
a119 1
   setup_context(vbr)->prim = prim;
d136 1
a136 1
lp_setup_draw(struct vbuf_render *vbr, const ushort *indices, uint nr)
d138 1
a138 1
   struct setup_context *setup = setup_context(vbr);
d141 1
d144 4
a147 1
   lp_setup_update_state(setup);
d187 5
a191 15
      if (setup->flatshade_first) {
         for (i = 2; i < nr; i += 3) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[i-2], stride) );
         }
      }
      else {
         for (i = 2; i < nr; i += 3) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-2], stride),
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
         }
d196 1
a196 1
      if (setup->flatshade_first) {
d198 1
d200 1
d202 2
a203 2
                             get_vert(vertex_buffer, indices[i-(i&1)], stride),
                             get_vert(vertex_buffer, indices[i-2], stride) );
d208 1
d218 1
a218 1
      if (setup->flatshade_first) {
d220 1
d222 1
d224 1
a224 2
                             get_vert(vertex_buffer, indices[0], stride),
                             get_vert(vertex_buffer, indices[i-1], stride) );
d229 1
d239 3
a241 1
      if (setup->flatshade_first) {
d244 4
a247 3
                             get_vert(vertex_buffer, indices[i-2], stride),
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-3], stride) );
a248 1
                             get_vert(vertex_buffer, indices[i-1], stride),
d250 2
a251 1
                             get_vert(vertex_buffer, indices[i-3], stride) );
d255 1
d258 3
a260 3
                             get_vert(vertex_buffer, indices[i-3], stride),
                             get_vert(vertex_buffer, indices[i-2], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
d271 3
a273 1
      if (setup->flatshade_first) {
d277 2
a278 2
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-3], stride));
a279 1
                             get_vert(vertex_buffer, indices[i-2], stride),
d281 1
d286 1
d302 1
a302 3
       * shading color.  Note that the first polygon vertex is passed as
       * the last triangle vertex here.
       * flatshade_first state makes no difference.
d304 17
a320 5
      for (i = 2; i < nr; i += 1) {
         setup->triangle( setup,
                          get_vert(vertex_buffer, indices[i-0], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[0], stride) );
d337 1
a337 1
   struct setup_context *setup = setup_context(vbr);
d341 1
d344 2
a345 1
   lp_setup_update_state(setup);
d385 5
a389 15
      if (setup->flatshade_first) {
         for (i = 2; i < nr; i += 3) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, i-2, stride) );
         }
      }
      else {
         for (i = 2; i < nr; i += 3) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-2, stride),
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride) );
         }
d394 1
a394 1
      if (setup->flatshade_first) {
d396 1
d398 1
d400 1
a400 2
                             get_vert(vertex_buffer, i-(i&1), stride),
                             get_vert(vertex_buffer, i-2, stride) );
d405 1
d415 1
a415 1
      if (setup->flatshade_first) {
d417 1
d419 1
d421 1
a421 2
                             get_vert(vertex_buffer, 0, stride),
                             get_vert(vertex_buffer, i-1, stride) );
d426 1
d436 3
a438 1
      if (setup->flatshade_first) {
d441 3
a443 3
                             get_vert(vertex_buffer, i-2, stride),
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-3, stride) );
a444 1
                             get_vert(vertex_buffer, i-1, stride),
d446 2
a447 1
                             get_vert(vertex_buffer, i-3, stride) );
d451 1
d466 3
a468 1
      if (setup->flatshade_first) {
d472 2
a473 2
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-3, stride) );
a474 2

                             get_vert(vertex_buffer, i-2, stride),
d476 1
d481 1
d497 1
a497 3
       * shading color.  Note that the first polygon vertex is passed as
       * the last triangle vertex here.
       * flatshade_first state makes no difference.
d499 17
a515 5
      for (i = 2; i < nr; i += 1) {
         setup->triangle( setup,
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride),
                          get_vert(vertex_buffer, 0, stride) );
d529 6
a534 1
   lp_setup_destroy(setup_context(vbr));
d542 1
a542 1
lp_setup_init_vbuf(struct setup_context *setup)
d552 1
a552 1
   setup->base.draw = lp_setup_draw;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d51 2
a52 2
static struct lp_setup_context *
lp_setup_context(struct vbuf_render *vbr)
d54 1
a54 1
   return (struct lp_setup_context *) vbr;
d62 1
a62 7
   struct lp_setup_context *setup = lp_setup_context(vbr);

   /* Vertex size/info depends on the latest state.
    * The draw module may have issued additional state-change commands.
    */
   lp_setup_update_state(setup, FALSE);

d71 1
a71 1
   struct lp_setup_context *setup = lp_setup_context(vbr);
d95 1
a95 1
   struct lp_setup_context *setup = lp_setup_context(vbr);
d104 1
a104 1
   struct lp_setup_context *setup = lp_setup_context(vbr);
d113 1
a113 1
   lp_setup_context(vbr)->prim = prim;
d130 1
a130 1
lp_setup_draw_elements(struct vbuf_render *vbr, const ushort *indices, uint nr)
d132 1
a132 1
   struct lp_setup_context *setup = lp_setup_context(vbr);
a134 1
   const boolean flatshade_first = setup->flatshade_first;
d137 1
a137 4
   assert(setup->setup.variant);

   if (!lp_setup_update_state(setup, TRUE))
      return;
d177 15
a191 5
      for (i = 2; i < nr; i += 3) {
         setup->triangle( setup,
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-1], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
d196 1
a196 1
      if (flatshade_first) {
a197 1
            /* emit first triangle vertex as first triangle vertex */
a198 1
                             get_vert(vertex_buffer, indices[i-2], stride),
d200 2
a201 2
                             get_vert(vertex_buffer, indices[i-(i&1)], stride) );

a205 1
            /* emit last triangle vertex as last triangle vertex */
d215 1
a215 1
      if (flatshade_first) {
a216 1
            /* emit first non-spoke vertex as first vertex */
a217 1
                             get_vert(vertex_buffer, indices[i-1], stride),
d219 2
a220 1
                             get_vert(vertex_buffer, indices[0], stride) );
a224 1
            /* emit last non-spoke vertex as last vertex */
d234 1
a234 3
      /* GL quads don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
d237 3
a239 4
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[i-3], stride),
                             get_vert(vertex_buffer, indices[i-2], stride) );

d241 1
d243 1
a243 2
                             get_vert(vertex_buffer, indices[i-2], stride),
                             get_vert(vertex_buffer, indices[i-1], stride) );
a246 1
         /* emit last quad vertex as last triangle vertex */
d249 3
a251 3
                          get_vert(vertex_buffer, indices[i-3], stride),
                          get_vert(vertex_buffer, indices[i-2], stride),
                          get_vert(vertex_buffer, indices[i-0], stride) );
d262 1
a262 3
      /* GL quad strips don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
d266 2
a267 2
                             get_vert(vertex_buffer, indices[i-3], stride),
                             get_vert(vertex_buffer, indices[i-2], stride) );
d269 1
a270 1
                             get_vert(vertex_buffer, indices[i-1], stride),
a274 1
         /* emit last quad vertex as last triangle vertex */
d290 3
a292 1
       * shading color.
d294 5
a298 17
      if (flatshade_first) { 
         /* emit first polygon  vertex as first triangle vertex */
         for (i = 2; i < nr; i += 1) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[0], stride),
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride) );
         }
      }
      else {
         /* emit first polygon  vertex as last triangle vertex */
         for (i = 2; i < nr; i += 1) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, indices[i-1], stride),
                             get_vert(vertex_buffer, indices[i-0], stride),
                             get_vert(vertex_buffer, indices[0], stride) );
         }
d315 1
a315 1
   struct lp_setup_context *setup = lp_setup_context(vbr);
a318 1
   const boolean flatshade_first = setup->flatshade_first;
d321 1
a321 2
   if (!lp_setup_update_state(setup, TRUE))
      return;
d361 15
a375 5
      for (i = 2; i < nr; i += 3) {
         setup->triangle( setup,
                          get_vert(vertex_buffer, i-2, stride),
                          get_vert(vertex_buffer, i-1, stride),
                          get_vert(vertex_buffer, i-0, stride) );
d380 1
a380 1
      if (flatshade_first) {
a381 1
            /* emit first triangle vertex as first triangle vertex */
a382 1
                             get_vert(vertex_buffer, i-2, stride),
d384 2
a385 1
                             get_vert(vertex_buffer, i-(i&1), stride) );
a389 1
            /* emit last triangle vertex as last triangle vertex */
d399 1
a399 1
      if (flatshade_first) {
a400 1
            /* emit first non-spoke vertex as first vertex */
a401 1
                             get_vert(vertex_buffer, i-1, stride),
d403 2
a404 1
                             get_vert(vertex_buffer, 0, stride)  );
a408 1
            /* emit last non-spoke vertex as last vertex */
d418 1
a418 3
      /* GL quads don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
d421 3
a423 3
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, i-3, stride),
                             get_vert(vertex_buffer, i-2, stride) );
d425 1
d427 1
a427 2
                             get_vert(vertex_buffer, i-2, stride),
                             get_vert(vertex_buffer, i-1, stride) );
a430 1
         /* emit last quad vertex as last triangle vertex */
d445 1
a445 3
      /* GL quad strips don't follow provoking vertex convention */
      if (flatshade_first) { 
         /* emit last quad vertex as first triangle vertex */
d449 2
a450 2
                             get_vert(vertex_buffer, i-3, stride),
                             get_vert(vertex_buffer, i-2, stride) );
d452 2
a454 1
                             get_vert(vertex_buffer, i-1, stride),
a458 1
         /* emit last quad vertex as last triangle vertex */
d474 3
a476 1
       * shading color.
d478 5
a482 17
      if (flatshade_first) { 
         /* emit first polygon  vertex as first triangle vertex */
         for (i = 2; i < nr; i += 1) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, 0, stride),
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride) );
         }
      }
      else {
         /* emit first polygon  vertex as last triangle vertex */
         for (i = 2; i < nr; i += 1) {
            setup->triangle( setup,
                             get_vert(vertex_buffer, i-1, stride),
                             get_vert(vertex_buffer, i-0, stride),
                             get_vert(vertex_buffer, 0, stride) );
         }
d496 1
a496 6
   struct lp_setup_context *setup = lp_setup_context(vbr);
   if (setup->vertex_buffer) {
      align_free(setup->vertex_buffer);
      setup->vertex_buffer = NULL;
   }
   lp_setup_destroy(setup);
d504 1
a504 1
lp_setup_init_vbuf(struct lp_setup_context *setup)
d514 1
a514 1
   setup->base.draw_elements = lp_setup_draw_elements;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a39 1
#include "lp_context.h"
d116 1
a116 1
static void
d120 1
a536 34
static void
lp_setup_so_info(struct vbuf_render *vbr, uint primitives, uint vertices,
                uint prim_generated)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   struct llvmpipe_context *lp = llvmpipe_context(setup->pipe);

   lp->so_stats.num_primitives_written += primitives;
   lp->so_stats.primitives_storage_needed =
      vertices * 4 /*sizeof(float|int32)*/ * 4 /*x,y,z,w*/;
   lp->num_primitives_generated += prim_generated;
}

static void
lp_setup_pipeline_statistics(
   struct vbuf_render *vbr,
   const struct pipe_query_data_pipeline_statistics *stats)
{
   struct lp_setup_context *setup = lp_setup_context(vbr);
   struct llvmpipe_context *llvmpipe = llvmpipe_context(setup->pipe);

   llvmpipe->pipeline_statistics.ia_vertices +=
      stats->ia_vertices;
   llvmpipe->pipeline_statistics.ia_primitives +=
      stats->ia_primitives;
   llvmpipe->pipeline_statistics.vs_invocations +=
      stats->vs_invocations;
   llvmpipe->pipeline_statistics.gs_invocations +=
      stats->gs_invocations;
   llvmpipe->pipeline_statistics.gs_primitives +=
      stats->gs_primitives;
   llvmpipe->pipeline_statistics.c_invocations +=
      stats->c_invocations;
}
a555 2
   setup->base.set_stream_output_info = lp_setup_so_info;
   setup->base.pipeline_statistics = lp_setup_pipeline_statistics;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a536 9
/*
 * FIXME: it is unclear if primitives_storage_needed (which is generally
 * the same as pipe query num_primitives_generated) should increase
 * if SO is disabled for d3d10, but for GL we definitely need to
 * increase num_primitives_generated and this is only called for active
 * SO. If it must not increase for d3d10 need to disambiguate the counters
 * in the driver and do some work for getting correct values, if it should
 * increase too should call this from outside streamout code.
 */
d538 2
a539 1
lp_setup_so_info(struct vbuf_render *vbr, uint primitives, uint prim_generated)
d545 3
a547 1
   lp->so_stats.primitives_storage_needed += prim_generated;
d568 2
a569 6
   if (!llvmpipe_rasterization_disabled(llvmpipe)) {
      llvmpipe->pipeline_statistics.c_invocations +=
         stats->c_invocations;
   } else {
      llvmpipe->pipeline_statistics.c_invocations = 0;
   }
@


