head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.33;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.26;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.57;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "util/u_framebuffer.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_simple_list.h"
#include "util/u_format.h"
#include "lp_scene.h"
#include "lp_fence.h"
#include "lp_debug.h"


#define RESOURCE_REF_SZ 32

/** List of resource references */
struct resource_ref {
   struct pipe_resource *resource[RESOURCE_REF_SZ];
   int count;
   struct resource_ref *next;
};


/**
 * Create a new scene object.
 * \param queue  the queue to put newly rendered/emptied scenes into
 */
struct lp_scene *
lp_scene_create( struct pipe_context *pipe )
{
   struct lp_scene *scene = CALLOC_STRUCT(lp_scene);
   if (!scene)
      return NULL;

   scene->pipe = pipe;

   scene->data.head =
      CALLOC_STRUCT(data_block);

   pipe_mutex_init(scene->mutex);

#ifdef DEBUG
   /* Do some scene limit sanity checks here */
   {
      size_t maxBins = TILES_X * TILES_Y;
      size_t maxCommandBytes = sizeof(struct cmd_block) * maxBins;
      size_t maxCommandPlusData = maxCommandBytes + DATA_BLOCK_SIZE;
      /* We'll need at least one command block per bin.  Make sure that's
       * less than the max allowed scene size.
       */
      assert(maxCommandBytes < LP_SCENE_MAX_SIZE);
      /* We'll also need space for at least one other data block */
      assert(maxCommandPlusData <= LP_SCENE_MAX_SIZE);
   }
#endif

   return scene;
}


/**
 * Free all data associated with the given scene, and the scene itself.
 */
void
lp_scene_destroy(struct lp_scene *scene)
{
   lp_fence_reference(&scene->fence, NULL);
   pipe_mutex_destroy(scene->mutex);
   assert(scene->data.head->next == NULL);
   FREE(scene->data.head);
   FREE(scene);
}


/**
 * Check if the scene's bins are all empty.
 * For debugging purposes.
 */
boolean
lp_scene_is_empty(struct lp_scene *scene )
{
   unsigned x, y;

   for (y = 0; y < TILES_Y; y++) {
      for (x = 0; x < TILES_X; x++) {
         const struct cmd_bin *bin = lp_scene_get_bin(scene, x, y);
         if (bin->head) {
            return FALSE;
         }
      }
   }
   return TRUE;
}


/* Returns true if there has ever been a failed allocation attempt in
 * this scene.  Used in triangle emit to avoid having to check success
 * at each bin.
 */
boolean
lp_scene_is_oom(struct lp_scene *scene)
{
   return scene->alloc_failed;
}


/* Remove all commands from a bin.  Tries to reuse some of the memory
 * allocated to the bin, however.
 */
void
lp_scene_bin_reset(struct lp_scene *scene, unsigned x, unsigned y)
{
   struct cmd_bin *bin = lp_scene_get_bin(scene, x, y);

   bin->last_state = NULL;
   bin->head = bin->tail;
   if (bin->tail) {
      bin->tail->next = NULL;
      bin->tail->count = 0;
   }
}


void
lp_scene_begin_rasterization(struct lp_scene *scene)
{
   const struct pipe_framebuffer_state *fb = &scene->fb;
   int i;

   //LP_DBG(DEBUG_RAST, "%s\n", __FUNCTION__);

   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      struct pipe_surface *cbuf = scene->fb.cbufs[i];

      if (!cbuf) {
         scene->cbufs[i].stride = 0;
         scene->cbufs[i].layer_stride = 0;
         scene->cbufs[i].map = NULL;
         continue;
      }

      if (llvmpipe_resource_is_texture(cbuf->texture)) {
         scene->cbufs[i].stride = llvmpipe_resource_stride(cbuf->texture,
                                                           cbuf->u.tex.level);
         scene->cbufs[i].layer_stride = llvmpipe_layer_stride(cbuf->texture,
                                                              cbuf->u.tex.level);

         scene->cbufs[i].map = llvmpipe_resource_map(cbuf->texture,
                                                     cbuf->u.tex.level,
                                                     cbuf->u.tex.first_layer,
                                                     LP_TEX_USAGE_READ_WRITE);
      }
      else {
         struct llvmpipe_resource *lpr = llvmpipe_resource(cbuf->texture);
         unsigned pixstride = util_format_get_blocksize(cbuf->format);
         scene->cbufs[i].stride = cbuf->texture->width0;
         scene->cbufs[i].layer_stride = 0;
         scene->cbufs[i].map = lpr->data;
         scene->cbufs[i].map += cbuf->u.buf.first_element * pixstride;
      }
   }

   if (fb->zsbuf) {
      struct pipe_surface *zsbuf = scene->fb.zsbuf;
      scene->zsbuf.stride = llvmpipe_resource_stride(zsbuf->texture, zsbuf->u.tex.level);
      scene->zsbuf.layer_stride = llvmpipe_layer_stride(zsbuf->texture, zsbuf->u.tex.level);

      scene->zsbuf.map = llvmpipe_resource_map(zsbuf->texture,
                                               zsbuf->u.tex.level,
                                               zsbuf->u.tex.first_layer,
                                               LP_TEX_USAGE_READ_WRITE);
   }
}




/**
 * Free all the temporary data in a scene.
 */
void
lp_scene_end_rasterization(struct lp_scene *scene )
{
   int i, j;

   /* Unmap color buffers */
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      if (scene->cbufs[i].map) {
         struct pipe_surface *cbuf = scene->fb.cbufs[i];
         if (llvmpipe_resource_is_texture(cbuf->texture)) {
            llvmpipe_resource_unmap(cbuf->texture,
                                    cbuf->u.tex.level,
                                    cbuf->u.tex.first_layer);
         }
         scene->cbufs[i].map = NULL;
      }
   }

   /* Unmap z/stencil buffer */
   if (scene->zsbuf.map) {
      struct pipe_surface *zsbuf = scene->fb.zsbuf;
      llvmpipe_resource_unmap(zsbuf->texture,
                              zsbuf->u.tex.level,
                              zsbuf->u.tex.first_layer);
      scene->zsbuf.map = NULL;
   }

   /* Reset all command lists:
    */
   for (i = 0; i < scene->tiles_x; i++) {
      for (j = 0; j < scene->tiles_y; j++) {
         struct cmd_bin *bin = lp_scene_get_bin(scene, i, j);
         bin->head = NULL;
         bin->tail = NULL;
         bin->last_state = NULL;
      }
   }

   /* If there are any bins which weren't cleared by the loop above,
    * they will be caught (on debug builds at least) by this assert:
    */
   assert(lp_scene_is_empty(scene));

   /* Decrement texture ref counts
    */
   {
      struct resource_ref *ref;
      int i, j = 0;

      for (ref = scene->resources; ref; ref = ref->next) {
         for (i = 0; i < ref->count; i++) {
            if (LP_DEBUG & DEBUG_SETUP)
               debug_printf("resource %d: %p %dx%d sz %d\n",
                            j,
                            (void *) ref->resource[i],
                            ref->resource[i]->width0,
                            ref->resource[i]->height0,
                            llvmpipe_resource_size(ref->resource[i]));
            j++;
            pipe_resource_reference(&ref->resource[i], NULL);
         }
      }

      if (LP_DEBUG & DEBUG_SETUP)
         debug_printf("scene %d resources, sz %d\n",
                      j, scene->resource_reference_size);
   }

   /* Free all scene data blocks:
    */
   {
      struct data_block_list *list = &scene->data;
      struct data_block *block, *tmp;

      for (block = list->head->next; block; block = tmp) {
         tmp = block->next;
	 FREE(block);
      }

      list->head->next = NULL;
      list->head->used = 0;
   }

   lp_fence_reference(&scene->fence, NULL);

   scene->resources = NULL;
   scene->scene_size = 0;
   scene->resource_reference_size = 0;

   scene->alloc_failed = FALSE;

   util_unreference_framebuffer_state( &scene->fb );
}






struct cmd_block *
lp_scene_new_cmd_block( struct lp_scene *scene,
                        struct cmd_bin *bin )
{
   struct cmd_block *block = lp_scene_alloc(scene, sizeof(struct cmd_block));
   if (block) {
      if (bin->tail) {
         bin->tail->next = block;
         bin->tail = block;
      }
      else {
         bin->head = block;
         bin->tail = block;
      }
      //memset(block, 0, sizeof *block);
      block->next = NULL;
      block->count = 0;
   }
   return block;
}


struct data_block *
lp_scene_new_data_block( struct lp_scene *scene )
{
   if (scene->scene_size + DATA_BLOCK_SIZE > LP_SCENE_MAX_SIZE) {
      if (0) debug_printf("%s: failed\n", __FUNCTION__);
      scene->alloc_failed = TRUE;
      return NULL;
   }
   else {
      struct data_block *block = MALLOC_STRUCT(data_block);
      if (block == NULL)
         return NULL;
      
      scene->scene_size += sizeof *block;

      block->used = 0;
      block->next = scene->data.head;
      scene->data.head = block;

      return block;
   }
}


/**
 * Return number of bytes used for all bin data within a scene.
 * This does not include resources (textures) referenced by the scene.
 */
static unsigned
lp_scene_data_size( const struct lp_scene *scene )
{
   unsigned size = 0;
   const struct data_block *block;
   for (block = scene->data.head; block; block = block->next) {
      size += block->used;
   }
   return size;
}



/**
 * Add a reference to a resource by the scene.
 */
boolean
lp_scene_add_resource_reference(struct lp_scene *scene,
                                struct pipe_resource *resource,
                                boolean initializing_scene)
{
   struct resource_ref *ref, **last = &scene->resources;
   int i;

   /* Look at existing resource blocks:
    */
   for (ref = scene->resources; ref; ref = ref->next) {
      last = &ref->next;

      /* Search for this resource:
       */
      for (i = 0; i < ref->count; i++)
         if (ref->resource[i] == resource)
            return TRUE;

      if (ref->count < RESOURCE_REF_SZ) {
         /* If the block is half-empty, then append the reference here.
          */
         break;
      }
   }

   /* Create a new block if no half-empty block was found.
    */
   if (!ref) {
      assert(*last == NULL);
      *last = lp_scene_alloc(scene, sizeof *ref);
      if (*last == NULL)
          return FALSE;

      ref = *last;
      memset(ref, 0, sizeof *ref);
   }

   /* Append the reference to the reference block.
    */
   pipe_resource_reference(&ref->resource[ref->count++], resource);
   scene->resource_reference_size += llvmpipe_resource_size(resource);

   /* Heuristic to advise scene flushes.  This isn't helpful in the
    * initial setup of the scene, but after that point flush on the
    * next resource added which exceeds 64MB in referenced texture
    * data.
    */
   if (!initializing_scene &&
       scene->resource_reference_size >= LP_SCENE_MAX_RESOURCE_SIZE)
      return FALSE;

   return TRUE;
}


/**
 * Does this scene have a reference to the given resource?
 */
boolean
lp_scene_is_resource_referenced(const struct lp_scene *scene,
                                const struct pipe_resource *resource)
{
   const struct resource_ref *ref;
   int i;

   for (ref = scene->resources; ref; ref = ref->next) {
      for (i = 0; i < ref->count; i++)
         if (ref->resource[i] == resource)
            return TRUE;
   }

   return FALSE;
}




/** advance curr_x,y to the next bin */
static boolean
next_bin(struct lp_scene *scene)
{
   scene->curr_x++;
   if (scene->curr_x >= scene->tiles_x) {
      scene->curr_x = 0;
      scene->curr_y++;
   }
   if (scene->curr_y >= scene->tiles_y) {
      /* no more bins */
      return FALSE;
   }
   return TRUE;
}


void
lp_scene_bin_iter_begin( struct lp_scene *scene )
{
   scene->curr_x = scene->curr_y = -1;
}


/**
 * Return pointer to next bin to be rendered.
 * The lp_scene::curr_x and ::curr_y fields will be advanced.
 * Multiple rendering threads will call this function to get a chunk
 * of work (a bin) to work on.
 */
struct cmd_bin *
lp_scene_bin_iter_next( struct lp_scene *scene , int *x, int *y)
{
   struct cmd_bin *bin = NULL;

   pipe_mutex_lock(scene->mutex);

   if (scene->curr_x < 0) {
      /* first bin */
      scene->curr_x = 0;
      scene->curr_y = 0;
   }
   else if (!next_bin(scene)) {
      /* no more bins left */
      goto end;
   }

   bin = lp_scene_get_bin(scene, scene->curr_x, scene->curr_y);
   *x = scene->curr_x;
   *y = scene->curr_y;

end:
   /*printf("return bin %p at %d, %d\n", (void *) bin, *bin_x, *bin_y);*/
   pipe_mutex_unlock(scene->mutex);
   return bin;
}


void lp_scene_begin_binning( struct lp_scene *scene,
                             struct pipe_framebuffer_state *fb, boolean discard )
{
   int i;
   unsigned max_layer = ~0;

   assert(lp_scene_is_empty(scene));

   scene->discard = discard;
   util_copy_framebuffer_state(&scene->fb, fb);

   scene->tiles_x = align(fb->width, TILE_SIZE) / TILE_SIZE;
   scene->tiles_y = align(fb->height, TILE_SIZE) / TILE_SIZE;
   assert(scene->tiles_x <= TILES_X);
   assert(scene->tiles_y <= TILES_Y);

   /*
    * Determine how many layers the fb has (used for clamping layer value).
    * OpenGL (but not d3d10) permits different amount of layers per rt, however
    * results are undefined if layer exceeds the amount of layers of ANY
    * attachment hence don't need separate per cbuf and zsbuf max.
    */
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      struct pipe_surface *cbuf = scene->fb.cbufs[i];
      if (cbuf) {
         if (llvmpipe_resource_is_texture(cbuf->texture)) {
            max_layer = MIN2(max_layer,
                             cbuf->u.tex.last_layer - cbuf->u.tex.first_layer);
         }
         else {
            max_layer = 0;
         }
      }
   }
   if (fb->zsbuf) {
      struct pipe_surface *zsbuf = scene->fb.zsbuf;
      max_layer = MIN2(max_layer, zsbuf->u.tex.last_layer - zsbuf->u.tex.first_layer);
   }
   scene->fb_max_layer = max_layer;
}


void lp_scene_end_binning( struct lp_scene *scene )
{
   if (LP_DEBUG & DEBUG_SCENE) {
      debug_printf("rasterize scene:\n");
      debug_printf("  scene_size: %u\n",
                   scene->scene_size);
      debug_printf("  data size: %u\n",
                   lp_scene_data_size(scene));

      if (0)
         lp_debug_bins( scene );
   }
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@a153 1
   unsigned max_layer = ~0;
d159 8
a171 1
         max_layer = MIN2(max_layer, cbuf->u.tex.last_layer - cbuf->u.tex.first_layer);
d182 1
a182 2
         max_layer = 0;

a191 1
      max_layer = MIN2(max_layer, zsbuf->u.tex.last_layer - zsbuf->u.tex.first_layer);
a197 2

   scene->fb_max_layer = max_layer;
a294 1
   scene->has_depthstencil_clear = FALSE;
d510 3
a519 1

d522 24
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d67 15
d140 1
d154 1
d160 21
a180 9
      assert(cbuf->u.tex.first_layer == cbuf->u.tex.last_layer);
      scene->cbufs[i].stride = llvmpipe_resource_stride(cbuf->texture,
                                                        cbuf->u.tex.level);

      scene->cbufs[i].map = llvmpipe_resource_map(cbuf->texture,
                                                  cbuf->u.tex.level,
                                                  cbuf->u.tex.first_layer,
                                                  LP_TEX_USAGE_READ_WRITE,
                                                  LP_TEX_LAYOUT_LINEAR);
a184 1
      assert(zsbuf->u.tex.first_layer == zsbuf->u.tex.last_layer);
d186 2
a187 2
      scene->zsbuf.blocksize = 
         util_format_get_blocksize(zsbuf->texture->format);
d192 1
a192 2
                                               LP_TEX_USAGE_READ_WRITE,
                                               LP_TEX_LAYOUT_NONE);
d194 2
d213 5
a217 3
         llvmpipe_resource_unmap(cbuf->texture,
                                 cbuf->u.tex.level,
                                 cbuf->u.tex.first_layer);
d479 1
a479 1
lp_scene_bin_iter_next( struct lp_scene *scene )
d496 2
d507 1
a507 1
                             struct pipe_framebuffer_state *fb )
d511 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d28 1
d33 1
a33 1
#include "util/u_surface.h"
d35 1
a35 1
#include "lp_scene_queue.h"
d39 14
d54 1
a54 2
lp_scene_create( struct pipe_context *pipe,
                 struct lp_scene_queue *queue )
a55 1
   unsigned i, j;
a60 8
   scene->empty_queue = queue;

   for (i = 0; i < TILES_X; i++) {
      for (j = 0; j < TILES_Y; j++) {
         struct cmd_bin *bin = lp_scene_get_bin(scene, i, j);
         bin->commands.head = bin->commands.tail = CALLOC_STRUCT(cmd_block);
      }
   }
d63 1
a63 3
      scene->data.tail = CALLOC_STRUCT(data_block);

   make_empty_list(&scene->textures);
d72 1
a72 1
 * Free all data associated with the given scene, and free(scene).
d77 3
a79 13
   unsigned i, j;

   lp_scene_reset(scene);

   for (i = 0; i < TILES_X; i++)
      for (j = 0; j < TILES_Y; j++) {
         struct cmd_bin *bin = lp_scene_get_bin(scene, i, j);
         assert(bin->commands.head == bin->commands.tail);
         FREE(bin->commands.head);
         bin->commands.head = NULL;
         bin->commands.tail = NULL;
      }

a80 4
   scene->data.head = NULL;

   pipe_mutex_destroy(scene->mutex);

d97 1
a97 2
         const struct cmd_block_list *list = &bin->commands;
         if (list->head != list->tail || list->head->count > 0) {
d106 13
a118 2
/* Free data for one particular bin.  May be called from the
 * rasterizer thread(s).
a123 3
   struct cmd_block_list *list = &bin->commands;
   struct cmd_block *block;
   struct cmd_block *tmp;
d125 15
a139 2
   assert(x < TILES_X);
   assert(y < TILES_Y);
d141 11
a151 3
   for (block = list->head; block != list->tail; block = tmp) {
      tmp = block->next;
      FREE(block);
d154 13
a166 3
   assert(list->tail->next == NULL);
   list->head = list->tail;
   list->head->count = 0;
d170 2
d173 1
a173 2
 * Free all the temporary data in a scene.  May be called from the
 * rasterizer thread(s).
d176 1
a176 1
lp_scene_reset(struct lp_scene *scene )
d178 21
a198 1
   unsigned i, j;
d200 1
a200 1
   /* Free all but last binner command lists:
d204 4
a207 1
         lp_scene_bin_reset(scene, i, j);
d211 3
d216 26
a241 1
   /* Free all but last binned data block:
d247 1
a247 1
      for (block = list->head; block != list->tail; block = tmp) {
d249 1
a249 1
         FREE(block);
d251 2
a252 3
         
      assert(list->tail->next == NULL);
      list->head = list->tail;
d256 10
a265 11
   /* Release texture refs
    */
   {
      struct texture_ref *ref, *next, *ref_list = &scene->textures;
      for (ref = ref_list->next; ref != ref_list; ref = next) {
         next = next_elem(ref);
         pipe_texture_reference(&ref->texture, NULL);
         FREE(ref);
      }
      make_empty_list(ref_list);
   }
d273 19
a291 8
void
lp_bin_new_cmd_block( struct cmd_block_list *list )
{
   struct cmd_block *block = MALLOC_STRUCT(cmd_block);
   list->tail->next = block;
   list->tail = block;
   block->next = NULL;
   block->count = 0;
d295 2
a296 2
void
lp_bin_new_data_block( struct data_block_list *list )
d298 18
a315 5
   struct data_block *block = MALLOC_STRUCT(data_block);
   list->tail->next = block;
   list->tail = block;
   block->next = NULL;
   block->used = 0;
d319 5
a323 2
/** Return number of bytes used for all bin data within a scene */
unsigned
a334 14
/** Return number of bytes used for a single bin */
unsigned
lp_scene_bin_size( const struct lp_scene *scene, unsigned x, unsigned y )
{
   struct cmd_bin *bin = lp_scene_get_bin((struct lp_scene *) scene, x, y);
   const struct cmd_block *cmd;
   unsigned size = 0;
   for (cmd = bin->commands.head; cmd; cmd = cmd->next) {
      size += (cmd->count *
               (sizeof(lp_rast_cmd) + sizeof(union lp_rast_cmd_arg)));
   }
   return size;
}

d337 1
a337 1
 * Add a reference to a texture by the scene.
d339 4
a342 3
void
lp_scene_texture_reference( struct lp_scene *scene,
                            struct pipe_texture *texture )
d344 19
a362 5
   struct texture_ref *ref = CALLOC_STRUCT(texture_ref);
   if (ref) {
      struct texture_ref *ref_list = &scene->textures;
      pipe_texture_reference(&ref->texture, texture);
      insert_at_tail(ref_list, ref);
a363 1
}
d365 7
d373 2
a374 12
/**
 * Does this scene have a reference to the given texture?
 */
boolean
lp_scene_is_texture_referenced( const struct lp_scene *scene,
                                const struct pipe_texture *texture )
{
   const struct texture_ref *ref_list = &scene->textures;
   const struct texture_ref *ref;
   foreach (ref, ref_list) {
      if (ref->texture == texture)
         return TRUE;
d376 16
a391 1
   return FALSE;
d396 1
a396 1
 * Return last command in the bin
d398 3
a400 2
static lp_rast_cmd
lp_get_last_command( const struct cmd_bin *bin )
d402 2
a403 7
   const struct cmd_block *tail = bin->commands.tail;
   const unsigned i = tail->count;
   if (i > 0)
      return tail->cmd[i - 1];
   else
      return NULL;
}
d405 5
d411 1
a411 11
/**
 * Replace the arg of the last command in the bin.
 */
static void
lp_replace_last_command_arg( struct cmd_bin *bin,
                             const union lp_rast_cmd_arg arg )
{
   struct cmd_block *tail = bin->commands.tail;
   const unsigned i = tail->count;
   assert(i > 0);
   tail->arg[i - 1] = arg;
a415 25
/**
 * Put a state-change command into all bins.
 * If we find that the last command in a bin was also a state-change
 * command, we can simply replace that one with the new one.
 */
void
lp_scene_bin_state_command( struct lp_scene *scene,
                            lp_rast_cmd cmd,
                            const union lp_rast_cmd_arg arg )
{
   unsigned i, j;
   for (i = 0; i < scene->tiles_x; i++) {
      for (j = 0; j < scene->tiles_y; j++) {
         struct cmd_bin *bin = lp_scene_get_bin(scene, i, j);
         lp_rast_cmd last_cmd = lp_get_last_command(bin);
         if (last_cmd == cmd) {
            lp_replace_last_command_arg(bin, arg);
         }
         else {
            lp_scene_bin_command( scene, i, j, cmd, arg );
         }
      }
   }
}

d448 1
a448 1
lp_scene_bin_iter_next( struct lp_scene *scene, int *bin_x, int *bin_y )
a464 2
   *bin_x = scene->curr_x;
   *bin_y = scene->curr_y;
a472 106
/**
 * Prepare this scene for the rasterizer.
 * Map the framebuffer surfaces.  Initialize the 'rast' state.
 */
static boolean
lp_scene_map_buffers( struct lp_scene *scene )
{
   struct pipe_screen *screen = scene->pipe->screen;
   struct pipe_surface *cbuf, *zsbuf;
   int i;

   LP_DBG(DEBUG_RAST, "%s\n", __FUNCTION__);


   /* Map all color buffers 
    */
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      cbuf = scene->fb.cbufs[i];
      if (cbuf) {
	 scene->cbuf_transfer[i] = screen->get_tex_transfer(screen,
                                                          cbuf->texture,
                                                          cbuf->face,
                                                          cbuf->level,
                                                          cbuf->zslice,
                                                          PIPE_TRANSFER_READ_WRITE,
                                                          0, 0,
                                                          cbuf->width, 
                                                          cbuf->height);
	 if (!scene->cbuf_transfer[i])
	    goto fail;

	 scene->cbuf_map[i] = screen->transfer_map(screen, 
                                                 scene->cbuf_transfer[i]);
	 if (!scene->cbuf_map[i])
	    goto fail;
      }
   }

   /* Map the zsbuffer
    */
   zsbuf = scene->fb.zsbuf;
   if (zsbuf) {
      scene->zsbuf_transfer = screen->get_tex_transfer(screen,
                                                       zsbuf->texture,
                                                       zsbuf->face,
                                                       zsbuf->level,
                                                       zsbuf->zslice,
                                                       PIPE_TRANSFER_READ_WRITE,
                                                       0, 0,
                                                       zsbuf->width,
                                                       zsbuf->height);
      if (!scene->zsbuf_transfer)
         goto fail;

      scene->zsbuf_map = screen->transfer_map(screen, 
                                              scene->zsbuf_transfer);
      if (!scene->zsbuf_map)
	 goto fail;
   }

   return TRUE;

fail:
   /* Unmap and release transfers?
    */
   return FALSE;
}



/**
 * Called after rasterizer as finished rasterizing a scene. 
 * 
 * We want to call this from the pipe_context's current thread to
 * avoid having to have mutexes on the transfer functions.
 */
static void
lp_scene_unmap_buffers( struct lp_scene *scene )
{
   struct pipe_screen *screen = scene->pipe->screen;
   unsigned i;

   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      if (scene->cbuf_map[i]) 
	 screen->transfer_unmap(screen, scene->cbuf_transfer[i]);

      if (scene->cbuf_transfer[i])
	 screen->tex_transfer_destroy(scene->cbuf_transfer[i]);

      scene->cbuf_transfer[i] = NULL;
      scene->cbuf_map[i] = NULL;
   }

   if (scene->zsbuf_map) 
      screen->transfer_unmap(screen, scene->zsbuf_transfer);

   if (scene->zsbuf_transfer)
      screen->tex_transfer_destroy(scene->zsbuf_transfer);

   scene->zsbuf_transfer = NULL;
   scene->zsbuf_map = NULL;

   util_unreference_framebuffer_state( &scene->fb );
}


d482 3
d488 1
a488 3
void lp_scene_rasterize( struct lp_scene *scene,
                         struct lp_rasterizer *rast,
                         boolean write_depth )
d490 1
a490 2
   if (0) {
      unsigned x, y;
d492 7
a498 7
      debug_printf("  data size: %u\n", lp_scene_data_size(scene));
      for (y = 0; y < scene->tiles_y; y++) {
         for (x = 0; x < scene->tiles_x; x++) {
            debug_printf("  bin %u, %u size: %u\n", x, y,
                         lp_scene_bin_size(scene, x, y));
         }
      }
a499 19


   scene->write_depth = (scene->fb.zsbuf != NULL &&
                         write_depth);

   lp_scene_map_buffers( scene );

   /* Enqueue the scene for rasterization, then immediately wait for
    * it to finish.
    */
   lp_rast_queue_scene( rast, scene );

   /* Currently just wait for the rasterizer to finish.  Some
    * threading interactions need to be worked out, particularly once
    * transfers become per-context:
    */
   lp_rast_finish( rast );
   lp_scene_unmap_buffers( scene );
   lp_scene_enqueue( scene->empty_queue, scene );
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a27 1
#include "util/u_framebuffer.h"
d32 1
a32 1
#include "util/u_format.h"
d34 1
a34 1
#include "lp_fence.h"
a37 14
#define RESOURCE_REF_SZ 32

/** List of resource references */
struct resource_ref {
   struct pipe_resource *resource[RESOURCE_REF_SZ];
   int count;
   struct resource_ref *next;
};


/**
 * Create a new scene object.
 * \param queue  the queue to put newly rendered/emptied scenes into
 */
d39 2
a40 1
lp_scene_create( struct pipe_context *pipe )
d42 1
d48 8
d58 3
a60 1
      CALLOC_STRUCT(data_block);
d69 1
a69 1
 * Free all data associated with the given scene, and the scene itself.
d74 16
a89 1
   lp_fence_reference(&scene->fence, NULL);
d91 1
a91 2
   assert(scene->data.head->next == NULL);
   FREE(scene->data.head);
d108 2
a109 1
         if (bin->head) {
d118 2
a119 13
/* Returns true if there has ever been a failed allocation attempt in
 * this scene.  Used in triangle emit to avoid having to check success
 * at each bin.
 */
boolean
lp_scene_is_oom(struct lp_scene *scene)
{
   return scene->alloc_failed;
}


/* Remove all commands from a bin.  Tries to reuse some of the memory
 * allocated to the bin, however.
d125 3
d129 2
a130 15
   bin->head = bin->tail;
   if (bin->tail) {
      bin->tail->next = NULL;
      bin->tail->count = 0;
   }
}


void
lp_scene_begin_rasterization(struct lp_scene *scene)
{
   const struct pipe_framebuffer_state *fb = &scene->fb;
   int i;

   //LP_DBG(DEBUG_RAST, "%s\n", __FUNCTION__);
d132 3
a134 11
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      struct pipe_surface *cbuf = scene->fb.cbufs[i];
      assert(cbuf->u.tex.first_layer == cbuf->u.tex.last_layer);
      scene->cbufs[i].stride = llvmpipe_resource_stride(cbuf->texture,
                                                        cbuf->u.tex.level);

      scene->cbufs[i].map = llvmpipe_resource_map(cbuf->texture,
                                                  cbuf->u.tex.level,
                                                  cbuf->u.tex.first_layer,
                                                  LP_TEX_USAGE_READ_WRITE,
                                                  LP_TEX_LAYOUT_LINEAR);
d137 3
a139 13
   if (fb->zsbuf) {
      struct pipe_surface *zsbuf = scene->fb.zsbuf;
      assert(zsbuf->u.tex.first_layer == zsbuf->u.tex.last_layer);
      scene->zsbuf.stride = llvmpipe_resource_stride(zsbuf->texture, zsbuf->u.tex.level);
      scene->zsbuf.blocksize = 
         util_format_get_blocksize(zsbuf->texture->format);

      scene->zsbuf.map = llvmpipe_resource_map(zsbuf->texture,
                                               zsbuf->u.tex.level,
                                               zsbuf->u.tex.first_layer,
                                               LP_TEX_USAGE_READ_WRITE,
                                               LP_TEX_LAYOUT_NONE);
   }
a142 2


d144 2
a145 1
 * Free all the temporary data in a scene.
d148 1
a148 1
lp_scene_end_rasterization(struct lp_scene *scene )
d150 1
a150 21
   int i, j;

   /* Unmap color buffers */
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      if (scene->cbufs[i].map) {
         struct pipe_surface *cbuf = scene->fb.cbufs[i];
         llvmpipe_resource_unmap(cbuf->texture,
                                 cbuf->u.tex.level,
                                 cbuf->u.tex.first_layer);
         scene->cbufs[i].map = NULL;
      }
   }

   /* Unmap z/stencil buffer */
   if (scene->zsbuf.map) {
      struct pipe_surface *zsbuf = scene->fb.zsbuf;
      llvmpipe_resource_unmap(zsbuf->texture,
                              zsbuf->u.tex.level,
                              zsbuf->u.tex.first_layer);
      scene->zsbuf.map = NULL;
   }
d152 1
a152 1
   /* Reset all command lists:
d156 1
a156 4
         struct cmd_bin *bin = lp_scene_get_bin(scene, i, j);
         bin->head = NULL;
         bin->tail = NULL;
         bin->last_state = NULL;
a159 3
   /* If there are any bins which weren't cleared by the loop above,
    * they will be caught (on debug builds at least) by this assert:
    */
d162 1
a162 1
   /* Decrement texture ref counts
d165 2
a166 2
      struct resource_ref *ref;
      int i, j = 0;
d168 3
a170 12
      for (ref = scene->resources; ref; ref = ref->next) {
         for (i = 0; i < ref->count; i++) {
            if (LP_DEBUG & DEBUG_SETUP)
               debug_printf("resource %d: %p %dx%d sz %d\n",
                            j,
                            (void *) ref->resource[i],
                            ref->resource[i]->width0,
                            ref->resource[i]->height0,
                            llvmpipe_resource_size(ref->resource[i]));
            j++;
            pipe_resource_reference(&ref->resource[i], NULL);
         }
d172 4
a175 4

      if (LP_DEBUG & DEBUG_SETUP)
         debug_printf("scene %d resources, sz %d\n",
                      j, scene->resource_reference_size);
d178 1
a178 1
   /* Free all scene data blocks:
d181 5
a185 6
      struct data_block_list *list = &scene->data;
      struct data_block *block, *tmp;

      for (block = list->head->next; block; block = tmp) {
         tmp = block->next;
	 FREE(block);
d187 1
a187 3

      list->head->next = NULL;
      list->head->used = 0;
a188 11

   lp_fence_reference(&scene->fence, NULL);

   scene->resources = NULL;
   scene->scene_size = 0;
   scene->resource_reference_size = 0;

   scene->has_depthstencil_clear = FALSE;
   scene->alloc_failed = FALSE;

   util_unreference_framebuffer_state( &scene->fb );
d196 8
a203 19
struct cmd_block *
lp_scene_new_cmd_block( struct lp_scene *scene,
                        struct cmd_bin *bin )
{
   struct cmd_block *block = lp_scene_alloc(scene, sizeof(struct cmd_block));
   if (block) {
      if (bin->tail) {
         bin->tail->next = block;
         bin->tail = block;
      }
      else {
         bin->head = block;
         bin->tail = block;
      }
      //memset(block, 0, sizeof *block);
      block->next = NULL;
      block->count = 0;
   }
   return block;
d207 2
a208 2
struct data_block *
lp_scene_new_data_block( struct lp_scene *scene )
d210 5
a214 18
   if (scene->scene_size + DATA_BLOCK_SIZE > LP_SCENE_MAX_SIZE) {
      if (0) debug_printf("%s: failed\n", __FUNCTION__);
      scene->alloc_failed = TRUE;
      return NULL;
   }
   else {
      struct data_block *block = MALLOC_STRUCT(data_block);
      if (block == NULL)
         return NULL;
      
      scene->scene_size += sizeof *block;

      block->used = 0;
      block->next = scene->data.head;
      scene->data.head = block;

      return block;
   }
d218 2
a219 5
/**
 * Return number of bytes used for all bin data within a scene.
 * This does not include resources (textures) referenced by the scene.
 */
static unsigned
d231 14
d247 1
a247 1
 * Add a reference to a resource by the scene.
d249 3
a251 4
boolean
lp_scene_add_resource_reference(struct lp_scene *scene,
                                struct pipe_resource *resource,
                                boolean initializing_scene)
d253 7
a259 2
   struct resource_ref *ref, **last = &scene->resources;
   int i;
a260 4
   /* Look at existing resource blocks:
    */
   for (ref = scene->resources; ref; ref = ref->next) {
      last = &ref->next;
d262 12
a273 11
      /* Search for this resource:
       */
      for (i = 0; i < ref->count; i++)
         if (ref->resource[i] == resource)
            return TRUE;

      if (ref->count < RESOURCE_REF_SZ) {
         /* If the block is half-empty, then append the reference here.
          */
         break;
      }
d275 2
a277 7
   /* Create a new block if no half-empty block was found.
    */
   if (!ref) {
      assert(*last == NULL);
      *last = lp_scene_alloc(scene, sizeof *ref);
      if (*last == NULL)
          return FALSE;
d279 13
a291 3
      ref = *last;
      memset(ref, 0, sizeof *ref);
   }
a292 4
   /* Append the reference to the reference block.
    */
   pipe_resource_reference(&ref->resource[ref->count++], resource);
   scene->resource_reference_size += llvmpipe_resource_size(resource);
d294 12
a305 8
   /* Heuristic to advise scene flushes.  This isn't helpful in the
    * initial setup of the scene, but after that point flush on the
    * next resource added which exceeds 64MB in referenced texture
    * data.
    */
   if (!initializing_scene &&
       scene->resource_reference_size >= LP_SCENE_MAX_RESOURCE_SIZE)
      return FALSE;
a306 2
   return TRUE;
}
d310 3
a312 1
 * Does this scene have a reference to the given resource?
d314 4
a317 3
boolean
lp_scene_is_resource_referenced(const struct lp_scene *scene,
                                const struct pipe_resource *resource)
d319 12
a330 7
   const struct resource_ref *ref;
   int i;

   for (ref = scene->resources; ref; ref = ref->next) {
      for (i = 0; i < ref->count; i++)
         if (ref->resource[i] == resource)
            return TRUE;
a331 2

   return FALSE;
a334 2


d366 1
a366 1
lp_scene_bin_iter_next( struct lp_scene *scene )
d383 2
d393 106
a507 3

   assert(scene->tiles_x <= TILES_X);
   assert(scene->tiles_y <= TILES_Y);
d511 3
a513 1
void lp_scene_end_binning( struct lp_scene *scene )
d515 2
a516 1
   if (LP_DEBUG & DEBUG_SCENE) {
d518 12
a529 4
      debug_printf("  scene_size: %u\n",
                   scene->scene_size);
      debug_printf("  data size: %u\n",
                   lp_scene_data_size(scene));
d531 14
a544 3
      if (0)
         lp_debug_bins( scene );
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a66 15
#ifdef DEBUG
   /* Do some scene limit sanity checks here */
   {
      size_t maxBins = TILES_X * TILES_Y;
      size_t maxCommandBytes = sizeof(struct cmd_block) * maxBins;
      size_t maxCommandPlusData = maxCommandBytes + DATA_BLOCK_SIZE;
      /* We'll need at least one command block per bin.  Make sure that's
       * less than the max allowed scene size.
       */
      assert(maxCommandBytes < LP_SCENE_MAX_SIZE);
      /* We'll also need space for at least one other data block */
      assert(maxCommandPlusData <= LP_SCENE_MAX_SIZE);
   }
#endif

a124 1
   bin->last_state = NULL;
a137 1
   unsigned max_layer = ~0;
d143 9
a151 21
      if (llvmpipe_resource_is_texture(cbuf->texture)) {
         scene->cbufs[i].stride = llvmpipe_resource_stride(cbuf->texture,
                                                           cbuf->u.tex.level);
         scene->cbufs[i].layer_stride = llvmpipe_layer_stride(cbuf->texture,
                                                              cbuf->u.tex.level);
         max_layer = MIN2(max_layer, cbuf->u.tex.last_layer - cbuf->u.tex.first_layer);

         scene->cbufs[i].map = llvmpipe_resource_map(cbuf->texture,
                                                     cbuf->u.tex.level,
                                                     cbuf->u.tex.first_layer,
                                                     LP_TEX_USAGE_READ_WRITE);
      }
      else {
         struct llvmpipe_resource *lpr = llvmpipe_resource(cbuf->texture);
         unsigned pixstride = util_format_get_blocksize(cbuf->format);
         scene->cbufs[i].stride = cbuf->texture->width0;
         max_layer = 0;

         scene->cbufs[i].map = lpr->data;
         scene->cbufs[i].map += cbuf->u.buf.first_element * pixstride;
      }
d156 1
d158 2
a159 2
      scene->zsbuf.layer_stride = llvmpipe_layer_stride(zsbuf->texture, zsbuf->u.tex.level);
      max_layer = MIN2(max_layer, zsbuf->u.tex.last_layer - zsbuf->u.tex.first_layer);
d164 2
a165 1
                                               LP_TEX_USAGE_READ_WRITE);
a166 2

   scene->fb_max_layer = max_layer;
d184 3
a186 5
         if (llvmpipe_resource_is_texture(cbuf->texture)) {
            llvmpipe_resource_unmap(cbuf->texture,
                                    cbuf->u.tex.level,
                                    cbuf->u.tex.first_layer);
         }
d448 1
a448 1
lp_scene_bin_iter_next( struct lp_scene *scene , int *x, int *y)
a464 2
   *x = scene->curr_x;
   *y = scene->curr_y;
d474 1
a474 1
                             struct pipe_framebuffer_state *fb, boolean discard )
a477 1
   scene->discard = discard;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d154 1
a159 8

      if (!cbuf) {
         scene->cbufs[i].stride = 0;
         scene->cbufs[i].layer_stride = 0;
         scene->cbufs[i].map = NULL;
         continue;
      }

d165 1
d176 2
a177 1
         scene->cbufs[i].layer_stride = 0;
d187 1
d194 2
d293 1
a508 3
   int i;
   unsigned max_layer = ~0;

d516 1
a518 24

   /*
    * Determine how many layers the fb has (used for clamping layer value).
    * OpenGL (but not d3d10) permits different amount of layers per rt, however
    * results are undefined if layer exceeds the amount of layers of ANY
    * attachment hence don't need separate per cbuf and zsbuf max.
    */
   for (i = 0; i < scene->fb.nr_cbufs; i++) {
      struct pipe_surface *cbuf = scene->fb.cbufs[i];
      if (cbuf) {
         if (llvmpipe_resource_is_texture(cbuf->texture)) {
            max_layer = MIN2(max_layer,
                             cbuf->u.tex.last_layer - cbuf->u.tex.first_layer);
         }
         else {
            max_layer = 0;
         }
      }
   }
   if (fb->zsbuf) {
      struct pipe_surface *zsbuf = scene->fb.zsbuf;
      max_layer = MIN2(max_layer, zsbuf->u.tex.last_layer - zsbuf->u.tex.first_layer);
   }
   scene->fb_max_layer = max_layer;
@


