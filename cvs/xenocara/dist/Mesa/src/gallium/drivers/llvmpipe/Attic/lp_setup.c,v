head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.33;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.28;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.36;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * Tiling engine.
 *
 * Builds per-tile display lists and executes them on calls to
 * lp_setup_flush().
 */

#include <limits.h>

#include "pipe/p_defines.h"
#include "util/u_framebuffer.h"
#include "util/u_inlines.h"
#include "util/u_memory.h"
#include "util/u_pack_color.h"
#include "draw/draw_pipe.h"
#include "os/os_time.h"
#include "lp_context.h"
#include "lp_memory.h"
#include "lp_scene.h"
#include "lp_texture.h"
#include "lp_debug.h"
#include "lp_fence.h"
#include "lp_query.h"
#include "lp_rast.h"
#include "lp_setup_context.h"
#include "lp_screen.h"
#include "lp_state.h"
#include "state_tracker/sw_winsys.h"

#include "draw/draw_context.h"
#include "draw/draw_vbuf.h"


static boolean set_scene_state( struct lp_setup_context *, enum setup_state,
                             const char *reason);
static boolean try_update_scene_state( struct lp_setup_context *setup );


static void
lp_setup_get_empty_scene(struct lp_setup_context *setup)
{
   assert(setup->scene == NULL);

   setup->scene_idx++;
   setup->scene_idx %= Elements(setup->scenes);

   setup->scene = setup->scenes[setup->scene_idx];

   if (setup->scene->fence) {
      if (LP_DEBUG & DEBUG_SETUP)
         debug_printf("%s: wait for scene %d\n",
                      __FUNCTION__, setup->scene->fence->id);

      lp_fence_wait(setup->scene->fence);
   }

   lp_scene_begin_binning(setup->scene, &setup->fb, setup->rasterizer_discard);

}


static void
first_triangle( struct lp_setup_context *setup,
                const float (*v0)[4],
                const float (*v1)[4],
                const float (*v2)[4])
{
   assert(setup->state == SETUP_ACTIVE);
   lp_setup_choose_triangle( setup );
   setup->triangle( setup, v0, v1, v2 );
}

static void
first_line( struct lp_setup_context *setup,
	    const float (*v0)[4],
	    const float (*v1)[4])
{
   assert(setup->state == SETUP_ACTIVE);
   lp_setup_choose_line( setup );
   setup->line( setup, v0, v1 );
}

static void
first_point( struct lp_setup_context *setup,
	     const float (*v0)[4])
{
   assert(setup->state == SETUP_ACTIVE);
   lp_setup_choose_point( setup );
   setup->point( setup, v0 );
}

void lp_setup_reset( struct lp_setup_context *setup )
{
   unsigned i;

   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   /* Reset derived state */
   for (i = 0; i < Elements(setup->constants); ++i) {
      setup->constants[i].stored_size = 0;
      setup->constants[i].stored_data = NULL;
   }
   setup->fs.stored = NULL;
   setup->dirty = ~0;

   /* no current bin */
   setup->scene = NULL;

   /* Reset some state:
    */
   memset(&setup->clear, 0, sizeof setup->clear);

   /* Have an explicit "start-binning" call and get rid of this
    * pointer twiddling?
    */
   setup->line = first_line;
   setup->point = first_point;
   setup->triangle = first_triangle;
}


/** Rasterize all scene's bins */
static void
lp_setup_rasterize_scene( struct lp_setup_context *setup )
{
   struct lp_scene *scene = setup->scene;
   struct llvmpipe_screen *screen = llvmpipe_screen(scene->pipe->screen);

   scene->num_active_queries = setup->active_binned_queries;
   memcpy(scene->active_queries, setup->active_queries,
          scene->num_active_queries * sizeof(scene->active_queries[0]));

   lp_scene_end_binning(scene);

   lp_fence_reference(&setup->last_fence, scene->fence);

   if (setup->last_fence)
      setup->last_fence->issued = TRUE;

   pipe_mutex_lock(screen->rast_mutex);
   lp_rast_queue_scene(screen->rast, scene);
   lp_rast_finish(screen->rast);
   pipe_mutex_unlock(screen->rast_mutex);

   lp_scene_end_rasterization(setup->scene);
   lp_setup_reset( setup );

   LP_DBG(DEBUG_SETUP, "%s done \n", __FUNCTION__);
}



static boolean
begin_binning( struct lp_setup_context *setup )
{
   struct lp_scene *scene = setup->scene;
   boolean need_zsload = FALSE;
   boolean ok;

   assert(scene);
   assert(scene->fence == NULL);

   /* Always create a fence:
    */
   scene->fence = lp_fence_create(MAX2(1, setup->num_threads));
   if (!scene->fence)
      return FALSE;

   ok = try_update_scene_state(setup);
   if (!ok)
      return FALSE;

   if (setup->fb.zsbuf &&
       ((setup->clear.flags & PIPE_CLEAR_DEPTHSTENCIL) != PIPE_CLEAR_DEPTHSTENCIL) &&
        util_format_is_depth_and_stencil(setup->fb.zsbuf->format))
      need_zsload = TRUE;

   LP_DBG(DEBUG_SETUP, "%s color clear bufs: %x depth: %s\n", __FUNCTION__,
          setup->clear.flags >> 2,
          need_zsload ? "clear": "load");

   if (setup->clear.flags & PIPE_CLEAR_COLOR) {
      unsigned cbuf;
      for (cbuf = 0; cbuf < setup->fb.nr_cbufs; cbuf++) {
         assert(PIPE_CLEAR_COLOR0 == 1 << 2);
         if (setup->clear.flags & (1 << (2 + cbuf))) {
            union lp_rast_cmd_arg clearrb_arg;
            struct lp_rast_clear_rb *cc_scene =
               (struct lp_rast_clear_rb *)
                  lp_scene_alloc(scene, sizeof(struct lp_rast_clear_rb));

            if (!cc_scene) {
               return FALSE;
            }

            cc_scene->cbuf = cbuf;
            cc_scene->color_val = setup->clear.color_val[cbuf];
            clearrb_arg.clear_rb = cc_scene;

            if (!lp_scene_bin_everywhere(scene,
                                         LP_RAST_OP_CLEAR_COLOR,
                                         clearrb_arg))
               return FALSE;
         }
      }
   }

   if (setup->fb.zsbuf) {
      if (setup->clear.flags & PIPE_CLEAR_DEPTHSTENCIL) {
         ok = lp_scene_bin_everywhere( scene,
                                       LP_RAST_OP_CLEAR_ZSTENCIL,
                                       lp_rast_arg_clearzs(
                                          setup->clear.zsvalue,
                                          setup->clear.zsmask));
         if (!ok)
            return FALSE;
      }
   }

   setup->clear.flags = 0;
   setup->clear.zsmask = 0;
   setup->clear.zsvalue = 0;

   scene->had_queries = !!setup->active_binned_queries;

   LP_DBG(DEBUG_SETUP, "%s done\n", __FUNCTION__);
   return TRUE;
}


/* This basically bins and then flushes any outstanding full-screen
 * clears.  
 *
 * TODO: fast path for fullscreen clears and no triangles.
 */
static boolean
execute_clears( struct lp_setup_context *setup )
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   return begin_binning( setup );
}

const char *states[] = {
   "FLUSHED",
   "CLEARED",
   "ACTIVE "
};


static boolean
set_scene_state( struct lp_setup_context *setup,
                 enum setup_state new_state,
                 const char *reason)
{
   unsigned old_state = setup->state;

   if (old_state == new_state)
      return TRUE;
   
   if (LP_DEBUG & DEBUG_SCENE) {
      debug_printf("%s old %s new %s%s%s\n",
                   __FUNCTION__,
                   states[old_state],
                   states[new_state],
                   (new_state == SETUP_FLUSHED) ? ": " : "",
                   (new_state == SETUP_FLUSHED) ? reason : "");

      if (new_state == SETUP_FLUSHED && setup->scene)
         lp_debug_draw_bins_by_cmd_length(setup->scene);
   }

   /* wait for a free/empty scene
    */
   if (old_state == SETUP_FLUSHED) 
      lp_setup_get_empty_scene(setup);

   switch (new_state) {
   case SETUP_CLEARED:
      break;

   case SETUP_ACTIVE:
      if (!begin_binning( setup ))
         goto fail;
      break;

   case SETUP_FLUSHED:
      if (old_state == SETUP_CLEARED)
         if (!execute_clears( setup ))
            goto fail;

      lp_setup_rasterize_scene( setup );
      assert(setup->scene == NULL);
      break;

   default:
      assert(0 && "invalid setup state mode");
      goto fail;
   }

   setup->state = new_state;
   return TRUE;

fail:
   if (setup->scene) {
      lp_scene_end_rasterization(setup->scene);
      setup->scene = NULL;
   }

   setup->state = SETUP_FLUSHED;
   lp_setup_reset( setup );
   return FALSE;
}


void
lp_setup_flush( struct lp_setup_context *setup,
                struct pipe_fence_handle **fence,
                const char *reason)
{
   set_scene_state( setup, SETUP_FLUSHED, reason );

   if (fence) {
      lp_fence_reference((struct lp_fence **)fence, setup->last_fence);
   }
}


void
lp_setup_bind_framebuffer( struct lp_setup_context *setup,
                           const struct pipe_framebuffer_state *fb )
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   /* Flush any old scene.
    */
   set_scene_state( setup, SETUP_FLUSHED, __FUNCTION__ );

   /*
    * Ensure the old scene is not reused.
    */
   assert(!setup->scene);

   /* Set new state.  This will be picked up later when we next need a
    * scene.
    */
   util_copy_framebuffer_state(&setup->fb, fb);
   setup->framebuffer.x0 = 0;
   setup->framebuffer.y0 = 0;
   setup->framebuffer.x1 = fb->width-1;
   setup->framebuffer.y1 = fb->height-1;
   setup->dirty |= LP_SETUP_NEW_SCISSOR;
}


/*
 * Try to clear one color buffer of the attached fb, either by binning a clear
 * command or queuing up the clear for later (when binning is started).
 */
static boolean
lp_setup_try_clear_color_buffer(struct lp_setup_context *setup,
                                const union pipe_color_union *color,
                                unsigned cbuf)
{
   union lp_rast_cmd_arg clearrb_arg;
   union util_color uc;
   enum pipe_format format = setup->fb.cbufs[cbuf]->format;

   LP_DBG(DEBUG_SETUP, "%s state %d\n", __FUNCTION__, setup->state);

   if (util_format_is_pure_integer(format)) {
      /*
       * We expect int/uint clear values here, though some APIs
       * might disagree (but in any case util_pack_color()
       * couldn't handle it)...
       */
      if (util_format_is_pure_sint(format)) {
         util_format_write_4i(format, color->i, 0, &uc, 0, 0, 0, 1, 1);
      }
      else {
         assert(util_format_is_pure_uint(format));
         util_format_write_4ui(format, color->ui, 0, &uc, 0, 0, 0, 1, 1);
      }
   }
   else {
      util_pack_color(color->f, format, &uc);
   }

   if (setup->state == SETUP_ACTIVE) {
      struct lp_scene *scene = setup->scene;

      /* Add the clear to existing scene.  In the unusual case where
       * both color and depth-stencil are being cleared when there's
       * already been some rendering, we could discard the currently
       * binned scene and start again, but I don't see that as being
       * a common usage.
       */
      struct lp_rast_clear_rb *cc_scene =
         (struct lp_rast_clear_rb *)
            lp_scene_alloc_aligned(scene, sizeof(struct lp_rast_clear_rb), 8);

      if (!cc_scene) {
         return FALSE;
      }

      cc_scene->cbuf = cbuf;
      cc_scene->color_val = uc;
      clearrb_arg.clear_rb = cc_scene;

      if (!lp_scene_bin_everywhere(scene,
                                   LP_RAST_OP_CLEAR_COLOR,
                                   clearrb_arg))
         return FALSE;
   }
   else {
      /* Put ourselves into the 'pre-clear' state, specifically to try
       * and accumulate multiple clears to color and depth_stencil
       * buffers which the app or state-tracker might issue
       * separately.
       */
      set_scene_state( setup, SETUP_CLEARED, __FUNCTION__ );

      assert(PIPE_CLEAR_COLOR0 == (1 << 2));
      setup->clear.flags |= 1 << (cbuf + 2);
      setup->clear.color_val[cbuf] = uc;
   }

   return TRUE;
}

static boolean
lp_setup_try_clear_zs(struct lp_setup_context *setup,
                      double depth,
                      unsigned stencil,
                      unsigned flags)
{
   uint64_t zsmask = 0;
   uint64_t zsvalue = 0;
   uint32_t zmask32;
   uint8_t smask8;

   LP_DBG(DEBUG_SETUP, "%s state %d\n", __FUNCTION__, setup->state);

   zmask32 = (flags & PIPE_CLEAR_DEPTH) ? ~0 : 0;
   smask8 = (flags & PIPE_CLEAR_STENCIL) ? ~0 : 0;

   zsvalue = util_pack64_z_stencil(setup->fb.zsbuf->format,
                                   depth,
                                   stencil);

   zsmask = util_pack64_mask_z_stencil(setup->fb.zsbuf->format,
                                       zmask32,
                                       smask8);

   zsvalue &= zsmask;

   if (setup->state == SETUP_ACTIVE) {
      struct lp_scene *scene = setup->scene;

      /* Add the clear to existing scene.  In the unusual case where
       * both color and depth-stencil are being cleared when there's
       * already been some rendering, we could discard the currently
       * binned scene and start again, but I don't see that as being
       * a common usage.
       */
      if (!lp_scene_bin_everywhere(scene,
                                   LP_RAST_OP_CLEAR_ZSTENCIL,
                                   lp_rast_arg_clearzs(zsvalue, zsmask)))
         return FALSE;
   }
   else {
      /* Put ourselves into the 'pre-clear' state, specifically to try
       * and accumulate multiple clears to color and depth_stencil
       * buffers which the app or state-tracker might issue
       * separately.
       */
      set_scene_state( setup, SETUP_CLEARED, __FUNCTION__ );

      setup->clear.flags |= flags;

      setup->clear.zsmask |= zsmask;
      setup->clear.zsvalue =
         (setup->clear.zsvalue & ~zsmask) | (zsvalue & zsmask);
   }

   return TRUE;
}

void
lp_setup_clear( struct lp_setup_context *setup,
                const union pipe_color_union *color,
                double depth,
                unsigned stencil,
                unsigned flags )
{
   unsigned i;

   /*
    * Note any of these (max 9) clears could fail (but at most there should
    * be just one failure!). This avoids doing the previous succeeded
    * clears again (we still clear tiles twice if a clear command succeeded
    * partially for one buffer).
    */
   if (flags & PIPE_CLEAR_DEPTHSTENCIL) {
      unsigned flagszs = flags & PIPE_CLEAR_DEPTHSTENCIL;
      if (!lp_setup_try_clear_zs(setup, depth, stencil, flagszs)) {
         lp_setup_flush(setup, NULL, __FUNCTION__);

         if (!lp_setup_try_clear_zs(setup, depth, stencil, flagszs))
            assert(0);
      }
   }

   if (flags & PIPE_CLEAR_COLOR) {
      assert(PIPE_CLEAR_COLOR0 == (1 << 2));
      for (i = 0; i < setup->fb.nr_cbufs; i++) {
         if ((flags & (1 << (2 + i))) && setup->fb.cbufs[i]) {
            if (!lp_setup_try_clear_color_buffer(setup, color, i)) {
               lp_setup_flush(setup, NULL, __FUNCTION__);

               if (!lp_setup_try_clear_color_buffer(setup, color, i))
                  assert(0);
            }
         }
      }
   }
}



void 
lp_setup_set_triangle_state( struct lp_setup_context *setup,
                             unsigned cull_mode,
                             boolean ccw_is_frontface,
                             boolean scissor,
                             boolean half_pixel_center,
                             boolean bottom_edge_rule)
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   setup->ccw_is_frontface = ccw_is_frontface;
   setup->cullmode = cull_mode;
   setup->triangle = first_triangle;
   setup->pixel_offset = half_pixel_center ? 0.5f : 0.0f;
   setup->bottom_edge_rule = bottom_edge_rule;

   if (setup->scissor_test != scissor) {
      setup->dirty |= LP_SETUP_NEW_SCISSOR;
      setup->scissor_test = scissor;
   }
}

void 
lp_setup_set_line_state( struct lp_setup_context *setup,
			 float line_width)
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   setup->line_width = line_width;
}

void 
lp_setup_set_point_state( struct lp_setup_context *setup,
                          float point_size,
                          boolean point_size_per_vertex,
                          uint sprite_coord_enable,
                          uint sprite_coord_origin)
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   setup->point_size = point_size;
   setup->sprite_coord_enable = sprite_coord_enable;
   setup->sprite_coord_origin = sprite_coord_origin;
   setup->point_size_per_vertex = point_size_per_vertex;
}

void
lp_setup_set_setup_variant( struct lp_setup_context *setup,
			    const struct lp_setup_variant *variant)
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);
   
   setup->setup.variant = variant;
}

void
lp_setup_set_fs_variant( struct lp_setup_context *setup,
                         struct lp_fragment_shader_variant *variant)
{
   LP_DBG(DEBUG_SETUP, "%s %p\n", __FUNCTION__,
          variant);
   /* FIXME: reference count */

   setup->fs.current.variant = variant;
   setup->dirty |= LP_SETUP_NEW_FS;
}

void
lp_setup_set_fs_constants(struct lp_setup_context *setup,
                          unsigned num,
                          struct pipe_constant_buffer *buffers)
{
   unsigned i;

   LP_DBG(DEBUG_SETUP, "%s %p\n", __FUNCTION__, (void *) buffers);

   assert(num <= Elements(setup->constants));

   for (i = 0; i < num; ++i) {
      util_copy_constant_buffer(&setup->constants[i].current, &buffers[i]);
   }
   for (; i < Elements(setup->constants); i++) {
      util_copy_constant_buffer(&setup->constants[i].current, NULL);
   }
   setup->dirty |= LP_SETUP_NEW_CONSTANTS;
}


void
lp_setup_set_alpha_ref_value( struct lp_setup_context *setup,
                              float alpha_ref_value )
{
   LP_DBG(DEBUG_SETUP, "%s %f\n", __FUNCTION__, alpha_ref_value);

   if(setup->fs.current.jit_context.alpha_ref_value != alpha_ref_value) {
      setup->fs.current.jit_context.alpha_ref_value = alpha_ref_value;
      setup->dirty |= LP_SETUP_NEW_FS;
   }
}

void
lp_setup_set_stencil_ref_values( struct lp_setup_context *setup,
                                 const ubyte refs[2] )
{
   LP_DBG(DEBUG_SETUP, "%s %d %d\n", __FUNCTION__, refs[0], refs[1]);

   if (setup->fs.current.jit_context.stencil_ref_front != refs[0] ||
       setup->fs.current.jit_context.stencil_ref_back != refs[1]) {
      setup->fs.current.jit_context.stencil_ref_front = refs[0];
      setup->fs.current.jit_context.stencil_ref_back = refs[1];
      setup->dirty |= LP_SETUP_NEW_FS;
   }
}

void
lp_setup_set_blend_color( struct lp_setup_context *setup,
                          const struct pipe_blend_color *blend_color )
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   assert(blend_color);

   if(memcmp(&setup->blend_color.current, blend_color, sizeof *blend_color) != 0) {
      memcpy(&setup->blend_color.current, blend_color, sizeof *blend_color);
      setup->dirty |= LP_SETUP_NEW_BLEND_COLOR;
   }
}


void
lp_setup_set_scissors( struct lp_setup_context *setup,
                       const struct pipe_scissor_state *scissors )
{
   unsigned i;
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   assert(scissors);

   for (i = 0; i < PIPE_MAX_VIEWPORTS; ++i) {
      setup->scissors[i].x0 = scissors[i].minx;
      setup->scissors[i].x1 = scissors[i].maxx-1;
      setup->scissors[i].y0 = scissors[i].miny;
      setup->scissors[i].y1 = scissors[i].maxy-1;
   }
   setup->dirty |= LP_SETUP_NEW_SCISSOR;
}


void 
lp_setup_set_flatshade_first( struct lp_setup_context *setup,
                              boolean flatshade_first )
{
   setup->flatshade_first = flatshade_first;
}

void
lp_setup_set_rasterizer_discard( struct lp_setup_context *setup,
                                 boolean rasterizer_discard )
{
   if (setup->rasterizer_discard != rasterizer_discard) {
      setup->rasterizer_discard = rasterizer_discard;
      set_scene_state( setup, SETUP_FLUSHED, __FUNCTION__ );
   }
}

void 
lp_setup_set_vertex_info( struct lp_setup_context *setup,
                          struct vertex_info *vertex_info )
{
   /* XXX: just silently holding onto the pointer:
    */
   setup->vertex_info = vertex_info;
}


/**
 * Called during state validation when LP_NEW_VIEWPORT is set.
 */
void
lp_setup_set_viewports(struct lp_setup_context *setup,
                       unsigned num_viewports,
                       const struct pipe_viewport_state *viewports)
{
   struct llvmpipe_context *lp = llvmpipe_context(setup->pipe);
   unsigned i;

   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   assert(num_viewports <= PIPE_MAX_VIEWPORTS);
   assert(viewports);

   /*
    * For use in lp_state_fs.c, propagate the viewport values for all viewports.
    */
   for (i = 0; i < num_viewports; i++) {
      float min_depth;
      float max_depth;

      if (lp->rasterizer->clip_halfz == 0) {
         float half_depth = viewports[i].scale[2];
         min_depth = viewports[i].translate[2] - half_depth;
         max_depth = min_depth + half_depth * 2.0f;
      } else {
         min_depth = viewports[i].translate[2];
         max_depth = min_depth + viewports[i].scale[2];
      }

      if (setup->viewports[i].min_depth != min_depth ||
          setup->viewports[i].max_depth != max_depth) {
          setup->viewports[i].min_depth = min_depth;
          setup->viewports[i].max_depth = max_depth;
          setup->dirty |= LP_SETUP_NEW_VIEWPORTS;
      }
   }
}


/**
 * Called during state validation when LP_NEW_SAMPLER_VIEW is set.
 */
void
lp_setup_set_fragment_sampler_views(struct lp_setup_context *setup,
                                    unsigned num,
                                    struct pipe_sampler_view **views)
{
   unsigned i;

   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   assert(num <= PIPE_MAX_SHADER_SAMPLER_VIEWS);

   for (i = 0; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; i++) {
      struct pipe_sampler_view *view = i < num ? views[i] : NULL;

      if (view) {
         struct pipe_resource *res = view->texture;
         struct llvmpipe_resource *lp_tex = llvmpipe_resource(res);
         struct lp_jit_texture *jit_tex;
         jit_tex = &setup->fs.current.jit_context.textures[i];

         /* We're referencing the texture's internal data, so save a
          * reference to it.
          */
         pipe_resource_reference(&setup->fs.current_tex[i], res);

         if (!lp_tex->dt) {
            /* regular texture - setup array of mipmap level offsets */
            void *mip_ptr;
            int j;
            unsigned first_level = 0;
            unsigned last_level = 0;

            if (llvmpipe_resource_is_texture(res)) {
               first_level = view->u.tex.first_level;
               last_level = view->u.tex.last_level;
               assert(first_level <= last_level);
               assert(last_level <= res->last_level);

               /*
                * The complexity here should no longer be necessary.
                */
               mip_ptr = llvmpipe_get_texture_image_all(lp_tex, first_level,
                                                        LP_TEX_USAGE_READ);
               jit_tex->base = lp_tex->linear_img.data;
            }
            else {
               mip_ptr = lp_tex->data;
               jit_tex->base = mip_ptr;
            }

            if ((LP_PERF & PERF_TEX_MEM) || !mip_ptr) {
               /* out of memory - use dummy tile memory */
               /* Note if using PERF_TEX_MEM will also skip tile conversion */
               jit_tex->base = lp_dummy_tile;
               jit_tex->width = TILE_SIZE/8;
               jit_tex->height = TILE_SIZE/8;
               jit_tex->depth = 1;
               jit_tex->first_level = 0;
               jit_tex->last_level = 0;
               jit_tex->mip_offsets[0] = 0;
               jit_tex->row_stride[0] = 0;
               jit_tex->img_stride[0] = 0;
            }
            else {
               jit_tex->width = res->width0;
               jit_tex->height = res->height0;
               jit_tex->depth = res->depth0;
               jit_tex->first_level = first_level;
               jit_tex->last_level = last_level;

               if (llvmpipe_resource_is_texture(res)) {
                  for (j = first_level; j <= last_level; j++) {
                     mip_ptr = llvmpipe_get_texture_image_all(lp_tex, j,
                                                              LP_TEX_USAGE_READ);
                     jit_tex->mip_offsets[j] = (uint8_t *)mip_ptr - (uint8_t *)jit_tex->base;
                     /*
                      * could get mip offset directly but need call above to
                      * invoke tiled->linear conversion.
                      */
                     assert(lp_tex->linear_mip_offsets[j] == jit_tex->mip_offsets[j]);
                     jit_tex->row_stride[j] = lp_tex->row_stride[j];
                     jit_tex->img_stride[j] = lp_tex->img_stride[j];
                  }

                  if (res->target == PIPE_TEXTURE_1D_ARRAY ||
                      res->target == PIPE_TEXTURE_2D_ARRAY) {
                     /*
                      * For array textures, we don't have first_layer, instead
                      * adjust last_layer (stored as depth) plus the mip level offsets
                      * (as we have mip-first layout can't just adjust base ptr).
                      * XXX For mip levels, could do something similar.
                      */
                     jit_tex->depth = view->u.tex.last_layer - view->u.tex.first_layer + 1;
                     for (j = first_level; j <= last_level; j++) {
                        jit_tex->mip_offsets[j] += view->u.tex.first_layer *
                                                   lp_tex->img_stride[j];
                     }
                     assert(view->u.tex.first_layer <= view->u.tex.last_layer);
                     assert(view->u.tex.last_layer < res->array_size);
                  }
               }
               else {
                  /*
                   * For buffers, we don't have first_element, instead adjust
                   * last_element (stored as width) plus the base pointer.
                   */
                  unsigned view_blocksize = util_format_get_blocksize(view->format);
                  /* probably don't really need to fill that out */
                  jit_tex->mip_offsets[0] = 0;
                  jit_tex->row_stride[0] = 0;
                  jit_tex->row_stride[0] = 0;

                  /* everything specified in number of elements here. */
                  jit_tex->width = view->u.buf.last_element - view->u.buf.first_element + 1;
                  jit_tex->base = (uint8_t *)jit_tex->base + view->u.buf.first_element *
                                  view_blocksize;
                  /* XXX Unsure if we need to sanitize parameters? */
                  assert(view->u.buf.first_element <= view->u.buf.last_element);
                  assert(view->u.buf.last_element * view_blocksize < res->width0);
               }
            }
         }
         else {
            /* display target texture/surface */
            /*
             * XXX: Where should this be unmapped?
             */
            struct llvmpipe_screen *screen = llvmpipe_screen(res->screen);
            struct sw_winsys *winsys = screen->winsys;
            jit_tex->base = winsys->displaytarget_map(winsys, lp_tex->dt,
                                                         PIPE_TRANSFER_READ);
            jit_tex->row_stride[0] = lp_tex->row_stride[0];
            jit_tex->img_stride[0] = lp_tex->img_stride[0];
            jit_tex->mip_offsets[0] = 0;
            jit_tex->width = res->width0;
            jit_tex->height = res->height0;
            jit_tex->depth = res->depth0;
            jit_tex->first_level = jit_tex->last_level = 0;
            assert(jit_tex->base);
         }
      }
   }

   setup->dirty |= LP_SETUP_NEW_FS;
}


/**
 * Called during state validation when LP_NEW_SAMPLER is set.
 */
void
lp_setup_set_fragment_sampler_state(struct lp_setup_context *setup,
                                    unsigned num,
                                    struct pipe_sampler_state **samplers)
{
   unsigned i;

   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   assert(num <= PIPE_MAX_SAMPLERS);

   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
      const struct pipe_sampler_state *sampler = i < num ? samplers[i] : NULL;

      if (sampler) {
         struct lp_jit_sampler *jit_sam;
         jit_sam = &setup->fs.current.jit_context.samplers[i];

         jit_sam->min_lod = sampler->min_lod;
         jit_sam->max_lod = sampler->max_lod;
         jit_sam->lod_bias = sampler->lod_bias;
         COPY_4V(jit_sam->border_color, sampler->border_color.f);
      }
   }

   setup->dirty |= LP_SETUP_NEW_FS;
}


/**
 * Is the given texture referenced by any scene?
 * Note: we have to check all scenes including any scenes currently
 * being rendered and the current scene being built.
 */
unsigned
lp_setup_is_resource_referenced( const struct lp_setup_context *setup,
                                const struct pipe_resource *texture )
{
   unsigned i;

   /* check the render targets */
   for (i = 0; i < setup->fb.nr_cbufs; i++) {
      if (setup->fb.cbufs[i] && setup->fb.cbufs[i]->texture == texture)
         return LP_REFERENCED_FOR_READ | LP_REFERENCED_FOR_WRITE;
   }
   if (setup->fb.zsbuf && setup->fb.zsbuf->texture == texture) {
      return LP_REFERENCED_FOR_READ | LP_REFERENCED_FOR_WRITE;
   }

   /* check textures referenced by the scene */
   for (i = 0; i < Elements(setup->scenes); i++) {
      if (lp_scene_is_resource_referenced(setup->scenes[i], texture)) {
         return LP_REFERENCED_FOR_READ;
      }
   }

   return LP_UNREFERENCED;
}


/**
 * Called by vbuf code when we're about to draw something.
 *
 * This function stores all dirty state in the current scene's display list
 * memory, via lp_scene_alloc().  We can not pass pointers of mutable state to
 * the JIT functions, as the JIT functions will be called later on, most likely
 * on a different thread.
 *
 * When processing dirty state it is imperative that we don't refer to any
 * pointers previously allocated with lp_scene_alloc() in this function (or any
 * function) as they may belong to a scene freed since then.
 */
static boolean
try_update_scene_state( struct lp_setup_context *setup )
{
   boolean new_scene = (setup->fs.stored == NULL);
   struct lp_scene *scene = setup->scene;
   unsigned i;

   assert(scene);

   if (setup->dirty & LP_SETUP_NEW_VIEWPORTS) {
      /*
       * Record new depth range state for changes due to viewport updates.
       *
       * TODO: Collapse the existing viewport and depth range information
       *       into one structure, for access by JIT.
       */
      struct lp_jit_viewport *stored;

      stored = (struct lp_jit_viewport *)
         lp_scene_alloc(scene, sizeof setup->viewports);

      if (!stored) {
         assert(!new_scene);
         return FALSE;
      }

      memcpy(stored, setup->viewports, sizeof setup->viewports);

      setup->fs.current.jit_context.viewports = stored;
      setup->dirty |= LP_SETUP_NEW_FS;
   }

   if(setup->dirty & LP_SETUP_NEW_BLEND_COLOR) {
      uint8_t *stored;
      float* fstored;
      unsigned i, j;
      unsigned size;

      /* Alloc u8_blend_color (16 x i8) and f_blend_color (4 or 8 x f32) */
      size  = 4 * 16 * sizeof(uint8_t);
      size += (LP_MAX_VECTOR_LENGTH / 4) * sizeof(float);
      stored = lp_scene_alloc_aligned(scene, size, LP_MIN_VECTOR_ALIGN);

      if (!stored) {
         assert(!new_scene);
         return FALSE;
      }

      /* Store floating point colour */
      fstored = (float*)(stored + 4*16);
      for (i = 0; i < (LP_MAX_VECTOR_LENGTH / 4); ++i) {
         fstored[i] = setup->blend_color.current.color[i % 4];
      }

      /* smear each blend color component across 16 ubyte elements */
      for (i = 0; i < 4; ++i) {
         uint8_t c = float_to_ubyte(setup->blend_color.current.color[i]);
         for (j = 0; j < 16; ++j)
            stored[i*16 + j] = c;
      }

      setup->blend_color.stored = stored;
      setup->fs.current.jit_context.u8_blend_color = stored;
      setup->fs.current.jit_context.f_blend_color = fstored;
      setup->dirty |= LP_SETUP_NEW_FS;
   }

   if (setup->dirty & LP_SETUP_NEW_CONSTANTS) {
      for (i = 0; i < Elements(setup->constants); ++i) {
         struct pipe_resource *buffer = setup->constants[i].current.buffer;
         const unsigned current_size = setup->constants[i].current.buffer_size;
         const ubyte *current_data = NULL;
         int num_constants;

         if (buffer) {
            /* resource buffer */
            current_data = (ubyte *) llvmpipe_resource_data(buffer);
         }
         else if (setup->constants[i].current.user_buffer) {
            /* user-space buffer */
            current_data = (ubyte *) setup->constants[i].current.user_buffer;
         }

         if (current_data) {
            current_data += setup->constants[i].current.buffer_offset;

            /* TODO: copy only the actually used constants? */

            if (setup->constants[i].stored_size != current_size ||
               !setup->constants[i].stored_data ||
               memcmp(setup->constants[i].stored_data,
                      current_data,
                      current_size) != 0) {
               void *stored;

               stored = lp_scene_alloc(scene, current_size);
               if (!stored) {
                  assert(!new_scene);
                  return FALSE;
               }

               memcpy(stored,
                      current_data,
                      current_size);
               setup->constants[i].stored_size = current_size;
               setup->constants[i].stored_data = stored;
            }
         }
         else {
            setup->constants[i].stored_size = 0;
            setup->constants[i].stored_data = NULL;
         }

         setup->fs.current.jit_context.constants[i] =
            setup->constants[i].stored_data;
         num_constants =
            setup->constants[i].stored_size / (sizeof(float) * 4);
         setup->fs.current.jit_context.num_constants[i] = num_constants;
         setup->dirty |= LP_SETUP_NEW_FS;
      }
   }


   if (setup->dirty & LP_SETUP_NEW_FS) {
      if (!setup->fs.stored ||
          memcmp(setup->fs.stored,
                 &setup->fs.current,
                 sizeof setup->fs.current) != 0)
      {
         struct lp_rast_state *stored;
         
         /* The fs state that's been stored in the scene is different from
          * the new, current state.  So allocate a new lp_rast_state object
          * and append it to the bin's setup data buffer.
          */
         stored = (struct lp_rast_state *) lp_scene_alloc(scene, sizeof *stored);
         if (!stored) {
            assert(!new_scene);
            return FALSE;
         }

         memcpy(stored,
                &setup->fs.current,
                sizeof setup->fs.current);
         setup->fs.stored = stored;
         
         /* The scene now references the textures in the rasterization
          * state record.  Note that now.
          */
         for (i = 0; i < Elements(setup->fs.current_tex); i++) {
            if (setup->fs.current_tex[i]) {
               if (!lp_scene_add_resource_reference(scene,
                                                    setup->fs.current_tex[i],
                                                    new_scene)) {
                  assert(!new_scene);
                  return FALSE;
               }
            }
         }
      }
   }

   if (setup->dirty & LP_SETUP_NEW_SCISSOR) {
      unsigned i;
      for (i = 0; i < PIPE_MAX_VIEWPORTS; ++i) {
         setup->draw_regions[i] = setup->framebuffer;
         if (setup->scissor_test) {
            u_rect_possible_intersection(&setup->scissors[i],
                                         &setup->draw_regions[i]);
         }
      }
   }

   setup->dirty = 0;

   assert(setup->fs.stored);
   return TRUE;
}

boolean
lp_setup_update_state( struct lp_setup_context *setup,
                       boolean update_scene )
{
   /* Some of the 'draw' pipeline stages may have changed some driver state.
    * Make sure we've processed those state changes before anything else.
    *
    * XXX this is the only place where llvmpipe_context is used in the
    * setup code.  This may get refactored/changed...
    */
   {
      struct llvmpipe_context *lp = llvmpipe_context(setup->pipe);
      if (lp->dirty) {
         llvmpipe_update_derived(lp);
      }

      if (lp->setup->dirty) {
         llvmpipe_update_setup(lp);
      }

      assert(setup->setup.variant);

      /* Will probably need to move this somewhere else, just need  
       * to know about vertex shader point size attribute.
       */
      setup->psize = lp->psize_slot;
      setup->viewport_index_slot = lp->viewport_index_slot;
      setup->layer_slot = lp->layer_slot;
      setup->face_slot = lp->face_slot;

      assert(lp->dirty == 0);

      assert(lp->setup_variant.key.size == 
	     setup->setup.variant->key.size);

      assert(memcmp(&lp->setup_variant.key,
		    &setup->setup.variant->key,
		    setup->setup.variant->key.size) == 0);
   }

   if (update_scene && setup->state != SETUP_ACTIVE) {
      if (!set_scene_state( setup, SETUP_ACTIVE, __FUNCTION__ ))
         return FALSE;
   }

   /* Only call into update_scene_state() if we already have a
    * scene:
    */
   if (update_scene && setup->scene) {
      assert(setup->state == SETUP_ACTIVE);

      if (try_update_scene_state(setup))
         return TRUE;

      /* Update failed, try to restart the scene.
       *
       * Cannot call lp_setup_flush_and_restart() directly here
       * because of potential recursion.
       */
      if (!set_scene_state(setup, SETUP_FLUSHED, __FUNCTION__))
         return FALSE;

      if (!set_scene_state(setup, SETUP_ACTIVE, __FUNCTION__))
         return FALSE;

      if (!setup->scene)
         return FALSE;

      return try_update_scene_state(setup);
   }

   return TRUE;
}



/* Only caller is lp_setup_vbuf_destroy()
 */
void 
lp_setup_destroy( struct lp_setup_context *setup )
{
   uint i;

   lp_setup_reset( setup );

   util_unreference_framebuffer_state(&setup->fb);

   for (i = 0; i < Elements(setup->fs.current_tex); i++) {
      pipe_resource_reference(&setup->fs.current_tex[i], NULL);
   }

   for (i = 0; i < Elements(setup->constants); i++) {
      pipe_resource_reference(&setup->constants[i].current.buffer, NULL);
   }

   /* free the scenes in the 'empty' queue */
   for (i = 0; i < Elements(setup->scenes); i++) {
      struct lp_scene *scene = setup->scenes[i];

      if (scene->fence)
         lp_fence_wait(scene->fence);

      lp_scene_destroy(scene);
   }

   lp_fence_reference(&setup->last_fence, NULL);

   FREE( setup );
}


/**
 * Create a new primitive tiling engine.  Plug it into the backend of
 * the draw module.  Currently also creates a rasterizer to use with
 * it.
 */
struct lp_setup_context *
lp_setup_create( struct pipe_context *pipe,
                 struct draw_context *draw )
{
   struct llvmpipe_screen *screen = llvmpipe_screen(pipe->screen);
   struct lp_setup_context *setup;
   unsigned i;

   setup = CALLOC_STRUCT(lp_setup_context);
   if (!setup) {
      goto no_setup;
   }

   lp_setup_init_vbuf(setup);
   
   /* Used only in update_state():
    */
   setup->pipe = pipe;


   setup->num_threads = screen->num_threads;
   setup->vbuf = draw_vbuf_stage(draw, &setup->base);
   if (!setup->vbuf) {
      goto no_vbuf;
   }

   draw_set_rasterize_stage(draw, setup->vbuf);
   draw_set_render(draw, &setup->base);

   /* create some empty scenes */
   for (i = 0; i < MAX_SCENES; i++) {
      setup->scenes[i] = lp_scene_create( pipe );
      if (!setup->scenes[i]) {
         goto no_scenes;
      }
   }

   setup->triangle = first_triangle;
   setup->line     = first_line;
   setup->point    = first_point;
   
   setup->dirty = ~0;

   return setup;

no_scenes:
   for (i = 0; i < MAX_SCENES; i++) {
      if (setup->scenes[i]) {
         lp_scene_destroy(setup->scenes[i]);
      }
   }

   setup->vbuf->destroy(setup->vbuf);
no_vbuf:
   FREE(setup);
no_setup:
   return NULL;
}


/**
 * Put a BeginQuery command into all bins.
 */
void
lp_setup_begin_query(struct lp_setup_context *setup,
                     struct llvmpipe_query *pq)
{

   set_scene_state(setup, SETUP_ACTIVE, "begin_query");

   if (!(pq->type == PIPE_QUERY_OCCLUSION_COUNTER ||
         pq->type == PIPE_QUERY_OCCLUSION_PREDICATE ||
         pq->type == PIPE_QUERY_PIPELINE_STATISTICS))
      return;

   /* init the query to its beginning state */
   assert(setup->active_binned_queries < LP_MAX_ACTIVE_BINNED_QUERIES);
   /* exceeding list size so just ignore the query */
   if (setup->active_binned_queries >= LP_MAX_ACTIVE_BINNED_QUERIES) {
      return;
   }
   assert(setup->active_queries[setup->active_binned_queries] == NULL);
   setup->active_queries[setup->active_binned_queries] = pq;
   setup->active_binned_queries++;

   assert(setup->scene);
   if (setup->scene) {
      if (!lp_scene_bin_everywhere(setup->scene,
                                   LP_RAST_OP_BEGIN_QUERY,
                                   lp_rast_arg_query(pq))) {

         if (!lp_setup_flush_and_restart(setup))
            return;

         if (!lp_scene_bin_everywhere(setup->scene,
                                      LP_RAST_OP_BEGIN_QUERY,
                                      lp_rast_arg_query(pq))) {
            return;
         }
      }
      setup->scene->had_queries |= TRUE;
   }
}


/**
 * Put an EndQuery command into all bins.
 */
void
lp_setup_end_query(struct lp_setup_context *setup, struct llvmpipe_query *pq)
{
   set_scene_state(setup, SETUP_ACTIVE, "end_query");

   assert(setup->scene);
   if (setup->scene) {
      /* pq->fence should be the fence of the *last* scene which
       * contributed to the query result.
       */
      lp_fence_reference(&pq->fence, setup->scene->fence);

      if (pq->type == PIPE_QUERY_OCCLUSION_COUNTER ||
          pq->type == PIPE_QUERY_OCCLUSION_PREDICATE ||
          pq->type == PIPE_QUERY_PIPELINE_STATISTICS ||
          pq->type == PIPE_QUERY_TIMESTAMP) {
         if (pq->type == PIPE_QUERY_TIMESTAMP &&
               !(setup->scene->tiles_x | setup->scene->tiles_y)) {
            /*
             * If there's a zero width/height framebuffer, there's no bins and
             * hence no rast task is ever run. So fill in something here instead.
             */
            pq->end[0] = os_time_get_nano();
         }

         if (!lp_scene_bin_everywhere(setup->scene,
                                      LP_RAST_OP_END_QUERY,
                                      lp_rast_arg_query(pq))) {
            if (!lp_setup_flush_and_restart(setup))
               goto fail;

            if (!lp_scene_bin_everywhere(setup->scene,
                                         LP_RAST_OP_END_QUERY,
                                         lp_rast_arg_query(pq))) {
               goto fail;
            }
         }
         setup->scene->had_queries |= TRUE;
      }
   }
   else {
      lp_fence_reference(&pq->fence, setup->last_fence);
   }

fail:
   /* Need to do this now not earlier since it still needs to be marked as
    * active when binning it would cause a flush.
    */
   if (pq->type == PIPE_QUERY_OCCLUSION_COUNTER ||
      pq->type == PIPE_QUERY_OCCLUSION_PREDICATE ||
      pq->type == PIPE_QUERY_PIPELINE_STATISTICS) {
      unsigned i;

      /* remove from active binned query list */
      for (i = 0; i < setup->active_binned_queries; i++) {
         if (setup->active_queries[i] == pq)
            break;
      }
      assert(i < setup->active_binned_queries);
      if (i == setup->active_binned_queries)
         return;
      setup->active_binned_queries--;
      setup->active_queries[i] = setup->active_queries[setup->active_binned_queries];
      setup->active_queries[setup->active_binned_queries] = NULL;
   }
}


boolean
lp_setup_flush_and_restart(struct lp_setup_context *setup)
{
   if (0) debug_printf("%s\n", __FUNCTION__);

   assert(setup->state == SETUP_ACTIVE);

   if (!set_scene_state(setup, SETUP_FLUSHED, __FUNCTION__))
      return FALSE;
   
   if (!lp_setup_update_state(setup, TRUE))
      return FALSE;

   return TRUE;
}


@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d805 1
d815 7
a821 1
               jit_tex->base = lp_tex->tex_data;
d824 2
a825 1
              jit_tex->base = lp_tex->data;
d828 3
a830 2
            if (LP_PERF & PERF_TEX_MEM) {
               /* use dummy tile memory */
d850 8
a857 1
                     jit_tex->mip_offsets[j] = lp_tex->mip_offsets[j];
d863 1
a863 2
                      res->target == PIPE_TEXTURE_2D_ARRAY ||
                      res->target == PIPE_TEXTURE_CUBE_ARRAY) {
a874 3
                     if (res->target == PIPE_TEXTURE_CUBE_ARRAY) {
                        assert(jit_tex->depth % 6 == 0);
                     }
d888 1
a888 1
                  jit_tex->img_stride[0] = 0;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a804 1
            void *mip_ptr;
d814 1
a814 7

               /*
                * The complexity here should no longer be necessary.
                */
               mip_ptr = llvmpipe_get_texture_image_all(lp_tex, first_level,
                                                        LP_TEX_USAGE_READ);
               jit_tex->base = lp_tex->linear_img.data;
d817 1
a817 2
               mip_ptr = lp_tex->data;
               jit_tex->base = mip_ptr;
d820 2
a821 3
            if ((LP_PERF & PERF_TEX_MEM) || !mip_ptr) {
               /* out of memory - use dummy tile memory */
               /* Note if using PERF_TEX_MEM will also skip tile conversion */
d841 1
a841 8
                     mip_ptr = llvmpipe_get_texture_image_all(lp_tex, j,
                                                              LP_TEX_USAGE_READ);
                     jit_tex->mip_offsets[j] = (uint8_t *)mip_ptr - (uint8_t *)jit_tex->base;
                     /*
                      * could get mip offset directly but need call above to
                      * invoke tiled->linear conversion.
                      */
                     assert(lp_tex->linear_mip_offsets[j] == jit_tex->mip_offsets[j]);
d847 2
a848 1
                      res->target == PIPE_TEXTURE_2D_ARRAY) {
d860 3
d876 1
a876 1
                  jit_tex->row_stride[0] = 0;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
a68 3
   struct llvmpipe_context *lp = llvmpipe_context(setup->pipe);
   boolean discard = lp->rasterizer ? lp->rasterizer->rasterizer_discard : FALSE;

d84 2
a85 2
   lp_scene_begin_binning(setup->scene, &setup->fb, discard);
   
d205 2
a206 2
   LP_DBG(DEBUG_SETUP, "%s color: %s depth: %s\n", __FUNCTION__,
          (setup->clear.flags & PIPE_CLEAR_COLOR) ? "clear": "load",
d209 23
a231 7
   if (setup->fb.nr_cbufs) {
      if (setup->clear.flags & PIPE_CLEAR_COLOR) {
         ok = lp_scene_bin_everywhere( scene, 
                                       LP_RAST_OP_CLEAR_COLOR, 
                                       setup->clear.color );
         if (!ok)
            return FALSE;
a236 3
         if (!need_zsload)
            scene->has_depthstencil_clear = TRUE;

d383 4
d388 7
a394 10
lp_setup_try_clear( struct lp_setup_context *setup,
                    const union pipe_color_union *color,
                    double depth,
                    unsigned stencil,
                    unsigned flags )
{
   uint64_t zsmask = 0;
   uint64_t zsvalue = 0;
   union lp_rast_cmd_arg color_arg;
   unsigned i;
d398 16
a413 3
   if (flags & PIPE_CLEAR_COLOR) {
      for (i = 0; i < 4; i++)
         color_arg.clear_color.i[i] = color->i[i];
d416 2
a417 3
   if (flags & PIPE_CLEAR_DEPTHSTENCIL) {
      uint32_t zmask = (flags & PIPE_CLEAR_DEPTH) ? ~0 : 0;
      uint8_t smask = (flags & PIPE_CLEAR_STENCIL) ? ~0 : 0;
d419 9
a427 3
      zsvalue = util_pack64_z_stencil(setup->fb.zsbuf->format,
                                      depth,
                                      stencil);
d429 3
d433 16
a448 3
      zsmask = util_pack64_mask_z_stencil(setup->fb.zsbuf->format,
                                          zmask,
                                          smask);
d450 3
a452 1
      zsvalue &= zsmask;
d455 29
d493 4
a496 13
      if (flags & PIPE_CLEAR_COLOR) {
         if (!lp_scene_bin_everywhere( scene, 
                                       LP_RAST_OP_CLEAR_COLOR,
                                       color_arg ))
            return FALSE;
      }

      if (flags & PIPE_CLEAR_DEPTHSTENCIL) {
         if (!lp_scene_bin_everywhere( scene,
                                       LP_RAST_OP_CLEAR_ZSTENCIL,
                                       lp_rast_arg_clearzs(zsvalue, zsmask) ))
            return FALSE;
      }
d508 4
a511 5
      if (flags & PIPE_CLEAR_DEPTHSTENCIL) {
         setup->clear.zsmask |= zsmask;
         setup->clear.zsvalue =
            (setup->clear.zsvalue & ~zsmask) | (zsvalue & zsmask);
      }
a512 7
      if (flags & PIPE_CLEAR_COLOR) {
         memcpy(&setup->clear.color.clear_color,
                &color_arg,
                sizeof setup->clear.color.clear_color);
      }
   }
   
d523 1
a523 2
   if (!lp_setup_try_clear( setup, color, depth, stencil, flags )) {
      lp_setup_flush(setup, NULL, __FUNCTION__);
d525 14
a538 2
      if (!lp_setup_try_clear( setup, color, depth, stencil, flags ))
         assert(0);
a539 1
}
d541 6
d548 7
d591 1
a591 1
                          float point_size,                          
d734 42
d970 1
a970 1
      if (setup->fb.cbufs[i]->texture == texture)
d990 9
d1009 23
d1041 1
a1041 1
      stored = lp_scene_alloc_aligned(scene, size, LP_MAX_VECTOR_LENGTH);
d1072 1
d1113 5
a1117 1
         setup->fs.current.jit_context.constants[i] = setup->constants[i].stored_data;
a1170 10
      /* If the framebuffer is large we have to think about fixed-point
       * integer overflow.  For 2K by 2K images, coordinates need 15 bits
       * (2^11 + 4 subpixel bits).  The product of two such numbers would
       * use 30 bits.  Any larger and we could overflow a 32-bit int.
       *
       * To cope with this problem we check if triangles are large and
       * subdivide them if needed.
       */
      setup->subdivide_large_triangles = (setup->fb.width > 2048 &&
                                          setup->fb.height > 2048);
d1172 1
a1172 1
                                      
d1207 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d42 2
d69 3
d87 1
a87 1
   lp_scene_begin_binning(setup->scene, &setup->fb);
d124 2
d129 4
a132 2
   setup->constants.stored_size = 0;
   setup->constants.stored_data = NULL;
d159 4
a188 1
   unsigned i, j;
a198 9
   /* Initialize the bin flags and x/y coords:
    */
   for (i = 0; i < scene->tiles_x; i++) {
      for (j = 0; j < scene->tiles_y; j++) {
         scene->tile[i][j].x = i;
         scene->tile[i][j].y = j;
      }
   }

a236 8
   if (setup->active_query) {
      ok = lp_scene_bin_everywhere( scene,
                                    LP_RAST_OP_BEGIN_QUERY,
                                    lp_rast_arg_query(setup->active_query) );
      if (!ok)
         return FALSE;
   }

d241 2
d375 1
a375 1
                    const float *color,
d380 2
a381 2
   uint32_t zsmask = 0;
   uint32_t zsvalue = 0;
d389 1
a389 1
         color_arg.clear_color[i] = float_to_ubyte(color[i]);
d394 1
a394 1
      uint32_t smask = (flags & PIPE_CLEAR_STENCIL) ? ~0 : 0;
d396 3
a398 3
      zsvalue = util_pack_z_stencil(setup->fb.zsbuf->format,
                                    depth,
                                    stencil);
d401 3
a403 3
      zsmask = util_pack_mask_z_stencil(setup->fb.zsbuf->format,
                                        zmask,
                                        smask);
d448 1
a448 1
         memcpy(setup->clear.color.clear_color,
d459 1
a459 1
                const float *color,
d481 2
a482 1
                             boolean gl_rasterization_rules)
d489 2
a490 1
   setup->pixel_offset = gl_rasterization_rules ? 0.5f : 0.0f;
d545 2
a546 1
                          struct pipe_resource *buffer)
d548 1
a548 1
   LP_DBG(DEBUG_SETUP, "%s %p\n", __FUNCTION__, (void *) buffer);
d550 1
a550 1
   pipe_resource_reference(&setup->constants.current, buffer);
d552 8
d606 2
a607 2
lp_setup_set_scissor( struct lp_setup_context *setup,
                      const struct pipe_scissor_state *scissor )
d609 1
d612 1
a612 1
   assert(scissor);
d614 6
a619 4
   setup->scissor.x0 = scissor->minx;
   setup->scissor.x1 = scissor->maxx-1;
   setup->scissor.y0 = scissor->miny;
   setup->scissor.y1 = scissor->maxy-1;
d631 9
d663 1
a663 1
   assert(num <= PIPE_MAX_SAMPLERS);
d665 1
a665 1
   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
d669 2
a670 2
         struct pipe_resource *tex = view->texture;
         struct llvmpipe_resource *lp_tex = llvmpipe_resource(tex);
a672 5
         jit_tex->width = tex->width0;
         jit_tex->height = tex->height0;
         jit_tex->depth = tex->depth0;
         jit_tex->first_level = view->u.tex.first_level;
         jit_tex->last_level = tex->last_level;
d677 1
a677 1
         pipe_resource_reference(&setup->fs.current_tex[i], tex);
d680 2
a681 1
            /* regular texture - setup array of mipmap level pointers */
d683 90
a772 18
            for (j = view->u.tex.first_level; j <= tex->last_level; j++) {
               jit_tex->data[j] =
                  llvmpipe_get_texture_image_all(lp_tex, j, LP_TEX_USAGE_READ,
                                                 LP_TEX_LAYOUT_LINEAR);
               jit_tex->row_stride[j] = lp_tex->row_stride[j];
               jit_tex->img_stride[j] = lp_tex->img_stride[j];

               if ((LP_PERF & PERF_TEX_MEM) ||
		   !jit_tex->data[j]) {
                  /* out of memory - use dummy tile memory */
                  jit_tex->data[j] = lp_dummy_tile;
                  jit_tex->width = TILE_SIZE/8;
                  jit_tex->height = TILE_SIZE/8;
                  jit_tex->depth = 1;
                  jit_tex->first_level = 0;
                  jit_tex->last_level = 0;
                  jit_tex->row_stride[j] = 0;
                  jit_tex->img_stride[j] = 0;
d781 1
a781 1
            struct llvmpipe_screen *screen = llvmpipe_screen(tex->screen);
d783 2
a784 2
            jit_tex->data[0] = winsys->displaytarget_map(winsys, lp_tex->dt,
							 PIPE_TRANSFER_READ);
d787 6
a792 1
            assert(jit_tex->data[0]);
d807 1
a807 1
                                    const struct pipe_sampler_state **samplers)
d819 2
a820 2
         struct lp_jit_texture *jit_tex;
         jit_tex = &setup->fs.current.jit_context.textures[i];
d822 4
a825 4
         jit_tex->min_lod = sampler->min_lod;
         jit_tex->max_lod = sampler->max_lod;
         jit_tex->lod_bias = sampler->lod_bias;
         COPY_4V(jit_tex->border_color, sampler->border_color);
d872 1
d878 1
d880 6
a886 1
      stored = lp_scene_alloc_aligned(scene, 4 * 16, 16);
d892 6
d906 2
a907 1
      setup->fs.current.jit_context.blend_color = setup->blend_color.stored;
d911 32
a942 2
   if(setup->dirty & LP_SETUP_NEW_CONSTANTS) {
      struct pipe_resource *buffer = setup->constants.current;
d944 5
a948 17
      if(buffer) {
         unsigned current_size = buffer->width0;
         const void *current_data = llvmpipe_resource_data(buffer);

         /* TODO: copy only the actually used constants? */

         if(setup->constants.stored_size != current_size ||
            !setup->constants.stored_data ||
            memcmp(setup->constants.stored_data,
                   current_data,
                   current_size) != 0) {
            void *stored;

            stored = lp_scene_alloc(scene, current_size);
            if (!stored) {
               assert(!new_scene);
               return FALSE;
d950 5
d956 2
a957 6
            memcpy(stored,
                   current_data,
                   current_size);
            setup->constants.stored_size = current_size;
            setup->constants.stored_data = stored;
         }
a958 7
      else {
         setup->constants.stored_size = 0;
         setup->constants.stored_data = NULL;
      }

      setup->fs.current.jit_context.constants = setup->constants.stored_data;
      setup->dirty |= LP_SETUP_NEW_FS;
a968 1
         uint i;
d1002 7
a1008 4
      setup->draw_region = setup->framebuffer;
      if (setup->scissor_test) {
         u_rect_possible_intersection(&setup->scissor,
                                      &setup->draw_region);
d1010 10
d1054 2
d1118 3
a1120 1
   pipe_resource_reference(&setup->constants.current, NULL);
d1148 1
a1148 1
   struct lp_setup_context *setup = CALLOC_STRUCT(lp_setup_context);
d1151 4
a1154 2
   if (!setup)
      return NULL;
d1165 3
a1167 2
   if (!setup->vbuf)
      goto fail;
d1175 3
d1188 6
a1193 3
fail:
   if (setup->vbuf)
      ;
d1195 2
d1198 1
a1209 2
   /* init the query to its beginning state */
   assert(setup->active_query == NULL);
a1211 2
   
   setup->active_query = pq;
d1213 16
d1243 1
a1253 2
   union lp_rast_cmd_arg dummy = { 0 };

d1256 1
a1256 8
   assert(setup->active_query == pq);
   setup->active_query = NULL;

   /* Setup will automatically re-issue any query which carried over a
    * scene boundary, and the rasterizer automatically "ends" queries
    * which are active at the end of a scene, so there is no need to
    * retry this commands on failure.
    */
d1263 26
a1288 4
      if (!lp_scene_bin_everywhere(setup->scene,
                                   LP_RAST_OP_END_QUERY,
                                   dummy)) {
         lp_setup_flush(setup, NULL, __FUNCTION__);
d1293 22
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a335 3
/**
 * \param flags  bitmask of PIPE_FLUSH_x flags
 */
a337 1
                unsigned flags,
d468 1
a468 1
      lp_setup_flush(setup, 0, NULL, __FUNCTION__);
d656 1
d667 1
a667 1
            for (j = 0; j <= tex->last_level; j++) {
d681 1
d754 1
a754 1
         return PIPE_REFERENCED_FOR_READ | PIPE_REFERENCED_FOR_WRITE;
d757 1
a757 1
      return PIPE_REFERENCED_FOR_READ | PIPE_REFERENCED_FOR_WRITE;
d763 1
a763 1
         return PIPE_REFERENCED_FOR_READ;
d767 1
a767 1
   return PIPE_UNREFERENCED;
d1068 2
a1084 2

   setup->active_query = pq;
d1115 1
a1115 1
         lp_setup_flush(setup, 0, NULL, __FUNCTION__);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d35 2
d38 1
d42 2
a43 1
#include "util/u_surface.h"
a44 2
#include "lp_scene_queue.h"
#include "lp_buffer.h"
d48 1
d52 2
a53 1
#include "lp_winsys.h"
d59 3
a61 1
static void set_scene_state( struct setup_context *, unsigned );
d64 2
a65 2
struct lp_scene *
lp_setup_get_current_scene(struct setup_context *setup)
d67 1
a67 1
   if (!setup->scene) {
d69 4
a72 3
      /* wait for a free/empty scene
       */
      setup->scene = lp_scene_dequeue(setup->empty_scenes, TRUE);
d74 4
a77 1
      assert(lp_scene_is_empty(setup->scene));
d79 1
a79 2
      lp_scene_begin_binning(setup->scene,
                             &setup->fb );
d81 3
a83 1
   return setup->scene;
d88 1
a88 1
first_triangle( struct setup_context *setup,
d93 1
a93 1
   set_scene_state( setup, SETUP_ACTIVE );
d99 1
a99 1
first_line( struct setup_context *setup,
d103 1
a103 1
   set_scene_state( setup, SETUP_ACTIVE );
d109 1
a109 1
first_point( struct setup_context *setup,
d112 1
a112 1
   set_scene_state( setup, SETUP_ACTIVE );
d117 1
a117 1
static void reset_context( struct setup_context *setup )
d132 1
a132 1
   setup->clear.flags = 0;
d145 1
a145 2
lp_setup_rasterize_scene( struct setup_context *setup,
                          boolean write_depth )
d147 4
a150 1
   struct lp_scene *scene = lp_setup_get_current_scene(setup);
d152 1
a152 3
   lp_scene_rasterize(scene,
                      setup->rast,
                      write_depth);
d154 10
a163 1
   reset_context( setup );
d170 2
a171 2
static void
begin_binning( struct setup_context *setup )
d173 31
a203 1
   struct lp_scene *scene = lp_setup_get_current_scene(setup);
d207 1
a207 1
          (setup->clear.flags & PIPE_CLEAR_DEPTHSTENCIL) ? "clear": "load");
d210 7
a216 8
      if (setup->clear.flags & PIPE_CLEAR_COLOR)
         lp_scene_bin_everywhere( scene, 
				  lp_rast_clear_color, 
				  setup->clear.color );
      else
         lp_scene_bin_everywhere( scene,
				  lp_rast_load_color,
				  lp_rast_arg_null() );
d220 20
a239 4
      if (setup->clear.flags & PIPE_CLEAR_DEPTHSTENCIL)
         lp_scene_bin_everywhere( scene, 
				  lp_rast_clear_zstencil, 
				  setup->clear.zstencil );
d242 4
d247 1
d256 2
a257 2
static void
execute_clears( struct setup_context *setup )
d261 1
a261 2
   begin_binning( setup );
   lp_setup_rasterize_scene( setup, TRUE );
d264 5
d270 5
a274 3
static void
set_scene_state( struct setup_context *setup,
           unsigned new_state )
d279 18
a296 3
      return;
       
   LP_DBG(DEBUG_SETUP, "%s old %d new %d\n", __FUNCTION__, old_state, new_state);
d299 3
d303 2
a304 1
      begin_binning( setup );
a306 7
   case SETUP_CLEARED:
      if (old_state == SETUP_ACTIVE) {
         assert(0);
         return;
      }
      break;
      
d309 5
a313 3
         execute_clears( setup );
      else
         lp_setup_rasterize_scene( setup, TRUE );
d315 4
d322 11
d336 3
d340 4
a343 2
lp_setup_flush( struct setup_context *setup,
                unsigned flags )
d345 1
a345 1
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);
d347 3
a349 1
   set_scene_state( setup, SETUP_FLUSHED );
d354 1
a354 1
lp_setup_bind_framebuffer( struct setup_context *setup,
d361 6
a366 1
   set_scene_state( setup, SETUP_FLUSHED );
d372 5
d380 10
a389 8
void
lp_setup_clear( struct setup_context *setup,
                const float *color,
                double depth,
                unsigned stencil,
                unsigned flags )
{
   struct lp_scene *scene = lp_setup_get_current_scene(setup);
a393 1

d395 2
a396 2
      for (i = 0; i < 4; ++i)
         setup->clear.color.clear_color[i] = float_to_ubyte(color[i]);
d400 13
a412 4
      setup->clear.zstencil.clear_zstencil = 
         util_pack_z_stencil(setup->fb.zsbuf->format, 
                             depth,
                             stencil);
d416 2
d424 13
a436 9
      if (flags & PIPE_CLEAR_COLOR)
         lp_scene_bin_everywhere( scene, 
                                  lp_rast_clear_color,
                                  setup->clear.color );

      if (setup->clear.flags & PIPE_CLEAR_DEPTHSTENCIL)
         lp_scene_bin_everywhere( scene, 
                                  lp_rast_clear_zstencil,
                                  setup->clear.zstencil );
d444 1
a444 1
      set_scene_state( setup, SETUP_CLEARED );
d447 12
d460 2
d464 6
a469 6

/**
 * Emit a fence.
 */
struct pipe_fence_handle *
lp_setup_fence( struct setup_context *setup )
d471 2
a472 3
   struct lp_scene *scene = lp_setup_get_current_scene(setup);
   const unsigned rank = lp_scene_get_num_bins( scene ); /* xxx */
   struct lp_fence *fence = lp_fence_create(rank);
d474 4
a477 1
   LP_DBG(DEBUG_SETUP, "%s rank %u\n", __FUNCTION__, rank);
a478 1
   set_scene_state( setup, SETUP_ACTIVE );
a479 4
   /* insert the fence into all command bins */
   lp_scene_bin_everywhere( scene,
			    lp_rast_fence,
			    lp_rast_arg_fence(fence) );
a480 2
   return (struct pipe_fence_handle *) fence;
}
d484 1
a484 1
lp_setup_set_triangle_state( struct setup_context *setup,
d487 2
a488 1
                             boolean scissor )
d495 6
a500 1
   setup->scissor_test = scissor;
d503 5
d509 17
d528 2
a529 3
lp_setup_set_fs_inputs( struct setup_context *setup,
                        const struct lp_shader_input *input,
                        unsigned nr )
d531 3
a533 4
   LP_DBG(DEBUG_SETUP, "%s %p %u\n", __FUNCTION__, (void *) input, nr);

   memcpy( setup->fs.input, input, nr * sizeof input[0] );
   setup->fs.nr_inputs = nr;
d537 2
a538 4
lp_setup_set_fs_functions( struct setup_context *setup,
                           lp_jit_frag_func jit_function0,
                           lp_jit_frag_func jit_function1,
                           boolean opaque )
d540 2
a541 1
   LP_DBG(DEBUG_SETUP, "%s %p\n", __FUNCTION__, (void *) jit_function0);
d544 1
a544 3
   setup->fs.current.jit_function[0] = jit_function0;
   setup->fs.current.jit_function[1] = jit_function1;
   setup->fs.current.opaque = opaque;
d549 2
a550 2
lp_setup_set_fs_constants(struct setup_context *setup,
                          struct pipe_buffer *buffer)
d554 1
a554 1
   pipe_buffer_reference(&setup->constants.current, buffer);
d561 1
a561 1
lp_setup_set_alpha_ref_value( struct setup_context *setup,
d573 15
a587 1
lp_setup_set_blend_color( struct setup_context *setup,
d602 1
a602 1
lp_setup_set_scissor( struct setup_context *setup,
d609 5
a613 4
   if (memcmp(&setup->scissor.current, scissor, sizeof(*scissor)) != 0) {
      setup->scissor.current = *scissor; /* struct copy */
      setup->dirty |= LP_SETUP_NEW_SCISSOR;
   }
d618 1
a618 1
lp_setup_set_flatshade_first( struct setup_context *setup,
d626 1
a626 1
lp_setup_set_vertex_info( struct setup_context *setup,
d636 1
a636 1
 * Called during state validation when LP_NEW_TEXTURE is set.
d639 3
a641 2
lp_setup_set_sampler_textures( struct setup_context *setup,
                               unsigned num, struct pipe_texture **texture)
d650 1
a650 1
      struct pipe_texture *tex = i < num ? texture[i] : NULL;
d652 3
a654 2
      if(tex) {
         struct llvmpipe_texture *lp_tex = llvmpipe_texture(tex);
d661 28
a688 3
         jit_tex->stride = lp_tex->stride[0];
         if(!lp_tex->dt) {
            jit_tex->data = lp_tex->data;
d691 1
a694 1

d696 6
a701 4
            struct llvmpipe_winsys *winsys = screen->winsys;
            jit_tex->data = winsys->displaytarget_map(winsys, lp_tex->dt,
                                                      PIPE_BUFFER_USAGE_CPU_READ);
            assert(jit_tex->data);
d703 2
d706 29
a734 5
         /* the scene references this texture */
         {
            struct lp_scene *scene = lp_setup_get_current_scene(setup);
            lp_scene_texture_reference(scene, tex);
         }
d748 2
a749 2
lp_setup_is_texture_referenced( const struct setup_context *setup,
                                const struct pipe_texture *texture )
d764 1
a764 1
      if (lp_scene_is_texture_referenced(setup->scenes[i], texture)) {
d776 2
a777 2
void
lp_setup_update_state( struct setup_context *setup )
d779 2
a780 1
   struct lp_scene *scene = lp_setup_get_current_scene(setup);
d782 1
a782 3
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   assert(setup->fs.current.jit_function);
d789 4
a801 1

a805 20
   if (setup->dirty & LP_SETUP_NEW_SCISSOR) {
      float *stored;

      stored = lp_scene_alloc_aligned(scene, 4 * sizeof(int32_t), 16);

      stored[0] = (float) setup->scissor.current.minx;
      stored[1] = (float) setup->scissor.current.miny;
      stored[2] = (float) setup->scissor.current.maxx;
      stored[3] = (float) setup->scissor.current.maxy;

      setup->scissor.stored = stored;

      setup->fs.current.jit_context.scissor_xmin = stored[0];
      setup->fs.current.jit_context.scissor_ymin = stored[1];
      setup->fs.current.jit_context.scissor_xmax = stored[2];
      setup->fs.current.jit_context.scissor_ymax = stored[3];

      setup->dirty |= LP_SETUP_NEW_FS;
   }

d807 1
a807 1
      struct pipe_buffer *buffer = setup->constants.current;
d810 2
a811 2
         unsigned current_size = buffer->size;
         const void *current_data = llvmpipe_buffer(buffer)->data;
d823 3
a825 6
            if(stored) {
               memcpy(stored,
                      current_data,
                      current_size);
               setup->constants.stored_size = current_size;
               setup->constants.stored_data = stored;
d827 6
d845 9
a853 5
   if(setup->dirty & LP_SETUP_NEW_FS) {
      if(!setup->fs.stored ||
         memcmp(setup->fs.stored,
                &setup->fs.current,
                sizeof setup->fs.current) != 0) {
d858 23
a880 12
         struct lp_rast_state *stored =
            (struct lp_rast_state *) lp_scene_alloc(scene, sizeof *stored);
         if(stored) {
            memcpy(stored,
                   &setup->fs.current,
                   sizeof setup->fs.current);
            setup->fs.stored = stored;

            /* put the state-set command into all bins */
            lp_scene_bin_state_command( scene,
					lp_rast_set_state, 
					lp_rast_arg_state(setup->fs.stored) );
d885 8
d896 72
d975 1
a975 1
lp_setup_destroy( struct setup_context *setup )
d977 5
a981 1
   reset_context( setup );
d983 5
a987 1
   pipe_buffer_reference(&setup->constants.current, NULL);
d990 6
a995 4
   while (1) {
      struct lp_scene *scene = lp_scene_dequeue(setup->empty_scenes, FALSE);
      if (!scene)
         break;
d999 1
a999 1
   lp_rast_destroy( setup->rast );
d1010 1
a1010 1
struct setup_context *
d1014 2
a1016 1
   struct setup_context *setup = CALLOC_STRUCT(setup_context);
d1022 4
a1026 9
   setup->empty_scenes = lp_scene_queue_create();
   if (!setup->empty_scenes)
      goto fail;

   /* XXX: move this to the screen and share between contexts:
    */
   setup->rast = lp_rast_create();
   if (!setup->rast) 
      goto fail;
d1028 1
d1038 1
a1038 3
      setup->scenes[i] = lp_scene_create( pipe, setup->empty_scenes );

      lp_scene_enqueue(setup->empty_scenes, setup->scenes[i]);
a1049 3
   if (setup->rast)
      lp_rast_destroy( setup->rast );
   
a1052 3
   if (setup->empty_scenes)
      lp_scene_queue_destroy(setup->empty_scenes);

d1056 86
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a34 2
#include <limits.h>

a35 1
#include "util/u_framebuffer.h"
d39 1
a39 2
#include "lp_context.h"
#include "lp_memory.h"
d41 2
a45 1
#include "lp_query.h"
d49 1
a49 2
#include "lp_state.h"
#include "state_tracker/sw_winsys.h"
d55 1
a55 3
static boolean set_scene_state( struct lp_setup_context *, enum setup_state,
                             const char *reason);
static boolean try_update_scene_state( struct lp_setup_context *setup );
d58 2
a59 2
static void
lp_setup_get_empty_scene(struct lp_setup_context *setup)
d61 1
a61 1
   assert(setup->scene == NULL);
d63 3
a65 4
   setup->scene_idx++;
   setup->scene_idx %= Elements(setup->scenes);

   setup->scene = setup->scenes[setup->scene_idx];
d67 1
a67 4
   if (setup->scene->fence) {
      if (LP_DEBUG & DEBUG_SETUP)
         debug_printf("%s: wait for scene %d\n",
                      __FUNCTION__, setup->scene->fence->id);
d69 2
a70 1
      lp_fence_wait(setup->scene->fence);
d72 1
a72 3

   lp_scene_begin_binning(setup->scene, &setup->fb);
   
d77 1
a77 1
first_triangle( struct lp_setup_context *setup,
d82 1
a82 1
   assert(setup->state == SETUP_ACTIVE);
d88 1
a88 1
first_line( struct lp_setup_context *setup,
d92 1
a92 1
   assert(setup->state == SETUP_ACTIVE);
d98 1
a98 1
first_point( struct lp_setup_context *setup,
d101 1
a101 1
   assert(setup->state == SETUP_ACTIVE);
d106 1
a106 1
void lp_setup_reset( struct lp_setup_context *setup )
d121 1
a121 1
   memset(&setup->clear, 0, sizeof setup->clear);
d134 2
a135 1
lp_setup_rasterize_scene( struct lp_setup_context *setup )
d137 1
a137 4
   struct lp_scene *scene = setup->scene;
   struct llvmpipe_screen *screen = llvmpipe_screen(scene->pipe->screen);

   lp_scene_end_binning(scene);
d139 3
a141 1
   lp_fence_reference(&setup->last_fence, scene->fence);
d143 1
a143 10
   if (setup->last_fence)
      setup->last_fence->issued = TRUE;

   pipe_mutex_lock(screen->rast_mutex);
   lp_rast_queue_scene(screen->rast, scene);
   lp_rast_finish(screen->rast);
   pipe_mutex_unlock(screen->rast_mutex);

   lp_scene_end_rasterization(setup->scene);
   lp_setup_reset( setup );
d150 2
a151 2
static boolean
begin_binning( struct lp_setup_context *setup )
d153 1
a153 31
   struct lp_scene *scene = setup->scene;
   boolean need_zsload = FALSE;
   boolean ok;
   unsigned i, j;

   assert(scene);
   assert(scene->fence == NULL);

   /* Always create a fence:
    */
   scene->fence = lp_fence_create(MAX2(1, setup->num_threads));
   if (!scene->fence)
      return FALSE;

   /* Initialize the bin flags and x/y coords:
    */
   for (i = 0; i < scene->tiles_x; i++) {
      for (j = 0; j < scene->tiles_y; j++) {
         scene->tile[i][j].x = i;
         scene->tile[i][j].y = j;
      }
   }

   ok = try_update_scene_state(setup);
   if (!ok)
      return FALSE;

   if (setup->fb.zsbuf &&
       ((setup->clear.flags & PIPE_CLEAR_DEPTHSTENCIL) != PIPE_CLEAR_DEPTHSTENCIL) &&
        util_format_is_depth_and_stencil(setup->fb.zsbuf->format))
      need_zsload = TRUE;
d157 1
a157 1
          need_zsload ? "clear": "load");
d160 8
a167 7
      if (setup->clear.flags & PIPE_CLEAR_COLOR) {
         ok = lp_scene_bin_everywhere( scene, 
                                       LP_RAST_OP_CLEAR_COLOR, 
                                       setup->clear.color );
         if (!ok)
            return FALSE;
      }
d171 4
a174 20
      if (setup->clear.flags & PIPE_CLEAR_DEPTHSTENCIL) {
         if (!need_zsload)
            scene->has_depthstencil_clear = TRUE;

         ok = lp_scene_bin_everywhere( scene,
                                       LP_RAST_OP_CLEAR_ZSTENCIL,
                                       lp_rast_arg_clearzs(
                                          setup->clear.zsvalue,
                                          setup->clear.zsmask));
         if (!ok)
            return FALSE;
      }
   }

   if (setup->active_query) {
      ok = lp_scene_bin_everywhere( scene,
                                    LP_RAST_OP_BEGIN_QUERY,
                                    lp_rast_arg_query(setup->active_query) );
      if (!ok)
         return FALSE;
a176 4
   setup->clear.flags = 0;
   setup->clear.zsmask = 0;
   setup->clear.zsvalue = 0;

a177 1
   return TRUE;
d186 2
a187 2
static boolean
execute_clears( struct lp_setup_context *setup )
d191 2
a192 1
   return begin_binning( setup );
a194 5
const char *states[] = {
   "FLUSHED",
   "CLEARED",
   "ACTIVE "
};
d196 3
a198 5

static boolean
set_scene_state( struct lp_setup_context *setup,
                 enum setup_state new_state,
                 const char *reason)
d203 3
a205 18
      return TRUE;
   
   if (LP_DEBUG & DEBUG_SCENE) {
      debug_printf("%s old %s new %s%s%s\n",
                   __FUNCTION__,
                   states[old_state],
                   states[new_state],
                   (new_state == SETUP_FLUSHED) ? ": " : "",
                   (new_state == SETUP_FLUSHED) ? reason : "");

      if (new_state == SETUP_FLUSHED && setup->scene)
         lp_debug_draw_bins_by_cmd_length(setup->scene);
   }

   /* wait for a free/empty scene
    */
   if (old_state == SETUP_FLUSHED) 
      lp_setup_get_empty_scene(setup);
d208 2
a209 1
   case SETUP_CLEARED:
d212 5
a216 3
   case SETUP_ACTIVE:
      if (!begin_binning( setup ))
         goto fail;
d218 1
a218 1

d221 3
a223 5
         if (!execute_clears( setup ))
            goto fail;

      lp_setup_rasterize_scene( setup );
      assert(setup->scene == NULL);
a224 4

   default:
      assert(0 && "invalid setup state mode");
      goto fail;
a227 11
   return TRUE;

fail:
   if (setup->scene) {
      lp_scene_end_rasterization(setup->scene);
      setup->scene = NULL;
   }

   setup->state = SETUP_FLUSHED;
   lp_setup_reset( setup );
   return FALSE;
a230 3
/**
 * \param flags  bitmask of PIPE_FLUSH_x flags
 */
d232 2
a233 4
lp_setup_flush( struct lp_setup_context *setup,
                unsigned flags,
                struct pipe_fence_handle **fence,
                const char *reason)
d235 1
a235 1
   set_scene_state( setup, SETUP_FLUSHED, reason );
d237 1
a237 3
   if (fence) {
      lp_fence_reference((struct lp_fence **)fence, setup->last_fence);
   }
d242 1
a242 1
lp_setup_bind_framebuffer( struct lp_setup_context *setup,
d249 1
a249 6
   set_scene_state( setup, SETUP_FLUSHED, __FUNCTION__ );

   /*
    * Ensure the old scene is not reused.
    */
   assert(!setup->scene);
a254 5
   setup->framebuffer.x0 = 0;
   setup->framebuffer.y0 = 0;
   setup->framebuffer.x1 = fb->width-1;
   setup->framebuffer.y1 = fb->height-1;
   setup->dirty |= LP_SETUP_NEW_SCISSOR;
d258 8
a265 10
static boolean
lp_setup_try_clear( struct lp_setup_context *setup,
                    const float *color,
                    double depth,
                    unsigned stencil,
                    unsigned flags )
{
   uint32_t zsmask = 0;
   uint32_t zsvalue = 0;
   union lp_rast_cmd_arg color_arg;
d270 1
d272 2
a273 2
      for (i = 0; i < 4; i++)
         color_arg.clear_color[i] = float_to_ubyte(color[i]);
d277 4
a280 13
      uint32_t zmask = (flags & PIPE_CLEAR_DEPTH) ? ~0 : 0;
      uint32_t smask = (flags & PIPE_CLEAR_STENCIL) ? ~0 : 0;

      zsvalue = util_pack_z_stencil(setup->fb.zsbuf->format,
                                    depth,
                                    stencil);


      zsmask = util_pack_mask_z_stencil(setup->fb.zsbuf->format,
                                        zmask,
                                        smask);

      zsvalue &= zsmask;
a283 2
      struct lp_scene *scene = setup->scene;

d290 9
a298 13
      if (flags & PIPE_CLEAR_COLOR) {
         if (!lp_scene_bin_everywhere( scene, 
                                       LP_RAST_OP_CLEAR_COLOR,
                                       color_arg ))
            return FALSE;
      }

      if (flags & PIPE_CLEAR_DEPTHSTENCIL) {
         if (!lp_scene_bin_everywhere( scene,
                                       LP_RAST_OP_CLEAR_ZSTENCIL,
                                       lp_rast_arg_clearzs(zsvalue, zsmask) ))
            return FALSE;
      }
d306 1
a306 1
      set_scene_state( setup, SETUP_CLEARED, __FUNCTION__ );
a308 12

      if (flags & PIPE_CLEAR_DEPTHSTENCIL) {
         setup->clear.zsmask |= zsmask;
         setup->clear.zsvalue =
            (setup->clear.zsvalue & ~zsmask) | (zsvalue & zsmask);
      }

      if (flags & PIPE_CLEAR_COLOR) {
         memcpy(setup->clear.color.clear_color,
                &color_arg,
                sizeof setup->clear.color.clear_color);
      }
a309 2
   
   return TRUE;
d312 6
a317 6
void
lp_setup_clear( struct lp_setup_context *setup,
                const float *color,
                double depth,
                unsigned stencil,
                unsigned flags )
d319 3
a321 2
   if (!lp_setup_try_clear( setup, color, depth, stencil, flags )) {
      lp_setup_flush(setup, 0, NULL, __FUNCTION__);
d323 1
a323 4
      if (!lp_setup_try_clear( setup, color, depth, stencil, flags ))
         assert(0);
   }
}
d325 1
d327 4
d332 2
d337 1
a337 1
lp_setup_set_triangle_state( struct lp_setup_context *setup,
d340 1
a340 2
                             boolean scissor,
                             boolean gl_rasterization_rules)
d347 1
a347 6
   setup->pixel_offset = gl_rasterization_rules ? 0.5f : 0.0f;

   if (setup->scissor_test != scissor) {
      setup->dirty |= LP_SETUP_NEW_SCISSOR;
      setup->scissor_test = scissor;
   }
a349 5
void 
lp_setup_set_line_state( struct lp_setup_context *setup,
			 float line_width)
{
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);
a350 2
   setup->line_width = line_width;
}
d352 4
a355 6
void 
lp_setup_set_point_state( struct lp_setup_context *setup,
                          float point_size,                          
                          boolean point_size_per_vertex,
                          uint sprite_coord_enable,
                          uint sprite_coord_origin)
d357 1
a357 1
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);
d359 2
a360 4
   setup->point_size = point_size;
   setup->sprite_coord_enable = sprite_coord_enable;
   setup->sprite_coord_origin = sprite_coord_origin;
   setup->point_size_per_vertex = point_size_per_vertex;
d364 4
a367 2
lp_setup_set_setup_variant( struct lp_setup_context *setup,
			    const struct lp_setup_variant *variant)
d369 1
a369 11
   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);
   
   setup->setup.variant = variant;
}

void
lp_setup_set_fs_variant( struct lp_setup_context *setup,
                         struct lp_fragment_shader_variant *variant)
{
   LP_DBG(DEBUG_SETUP, "%s %p\n", __FUNCTION__,
          variant);
d372 3
a374 1
   setup->fs.current.variant = variant;
d379 2
a380 2
lp_setup_set_fs_constants(struct lp_setup_context *setup,
                          struct pipe_resource *buffer)
d384 1
a384 1
   pipe_resource_reference(&setup->constants.current, buffer);
d391 1
a391 1
lp_setup_set_alpha_ref_value( struct lp_setup_context *setup,
d403 1
a403 15
lp_setup_set_stencil_ref_values( struct lp_setup_context *setup,
                                 const ubyte refs[2] )
{
   LP_DBG(DEBUG_SETUP, "%s %d %d\n", __FUNCTION__, refs[0], refs[1]);

   if (setup->fs.current.jit_context.stencil_ref_front != refs[0] ||
       setup->fs.current.jit_context.stencil_ref_back != refs[1]) {
      setup->fs.current.jit_context.stencil_ref_front = refs[0];
      setup->fs.current.jit_context.stencil_ref_back = refs[1];
      setup->dirty |= LP_SETUP_NEW_FS;
   }
}

void
lp_setup_set_blend_color( struct lp_setup_context *setup,
d418 1
a418 1
lp_setup_set_scissor( struct lp_setup_context *setup,
d425 4
a428 5
   setup->scissor.x0 = scissor->minx;
   setup->scissor.x1 = scissor->maxx-1;
   setup->scissor.y0 = scissor->miny;
   setup->scissor.y1 = scissor->maxy-1;
   setup->dirty |= LP_SETUP_NEW_SCISSOR;
d433 1
a433 1
lp_setup_set_flatshade_first( struct lp_setup_context *setup,
d441 1
a441 1
lp_setup_set_vertex_info( struct lp_setup_context *setup,
d451 1
a451 1
 * Called during state validation when LP_NEW_SAMPLER_VIEW is set.
d454 2
a455 3
lp_setup_set_fragment_sampler_views(struct lp_setup_context *setup,
                                    unsigned num,
                                    struct pipe_sampler_view **views)
d464 1
a464 1
      struct pipe_sampler_view *view = i < num ? views[i] : NULL;
d466 2
a467 3
      if (view) {
         struct pipe_resource *tex = view->texture;
         struct llvmpipe_resource *lp_tex = llvmpipe_resource(tex);
d474 3
a476 28

         /* We're referencing the texture's internal data, so save a
          * reference to it.
          */
         pipe_resource_reference(&setup->fs.current_tex[i], tex);

         if (!lp_tex->dt) {
            /* regular texture - setup array of mipmap level pointers */
            int j;
            for (j = 0; j <= tex->last_level; j++) {
               jit_tex->data[j] =
                  llvmpipe_get_texture_image_all(lp_tex, j, LP_TEX_USAGE_READ,
                                                 LP_TEX_LAYOUT_LINEAR);
               jit_tex->row_stride[j] = lp_tex->row_stride[j];
               jit_tex->img_stride[j] = lp_tex->img_stride[j];

               if ((LP_PERF & PERF_TEX_MEM) ||
		   !jit_tex->data[j]) {
                  /* out of memory - use dummy tile memory */
                  jit_tex->data[j] = lp_dummy_tile;
                  jit_tex->width = TILE_SIZE/8;
                  jit_tex->height = TILE_SIZE/8;
                  jit_tex->depth = 1;
                  jit_tex->last_level = 0;
                  jit_tex->row_stride[j] = 0;
                  jit_tex->img_stride[j] = 0;
               }
            }
a478 1
            /* display target texture/surface */
d482 1
d484 4
a487 6
            struct sw_winsys *winsys = screen->winsys;
            jit_tex->data[0] = winsys->displaytarget_map(winsys, lp_tex->dt,
							 PIPE_TRANSFER_READ);
            jit_tex->row_stride[0] = lp_tex->row_stride[0];
            jit_tex->img_stride[0] = lp_tex->img_stride[0];
            assert(jit_tex->data[0]);
a488 2
      }
   }
d490 5
a494 29
   setup->dirty |= LP_SETUP_NEW_FS;
}


/**
 * Called during state validation when LP_NEW_SAMPLER is set.
 */
void
lp_setup_set_fragment_sampler_state(struct lp_setup_context *setup,
                                    unsigned num,
                                    const struct pipe_sampler_state **samplers)
{
   unsigned i;

   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   assert(num <= PIPE_MAX_SAMPLERS);

   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
      const struct pipe_sampler_state *sampler = i < num ? samplers[i] : NULL;

      if (sampler) {
         struct lp_jit_texture *jit_tex;
         jit_tex = &setup->fs.current.jit_context.textures[i];

         jit_tex->min_lod = sampler->min_lod;
         jit_tex->max_lod = sampler->max_lod;
         jit_tex->lod_bias = sampler->lod_bias;
         COPY_4V(jit_tex->border_color, sampler->border_color);
d508 2
a509 2
lp_setup_is_resource_referenced( const struct lp_setup_context *setup,
                                const struct pipe_resource *texture )
d524 1
a524 1
      if (lp_scene_is_resource_referenced(setup->scenes[i], texture)) {
d536 2
a537 2
static boolean
try_update_scene_state( struct lp_setup_context *setup )
d539 1
a539 2
   boolean new_scene = (setup->fs.stored == NULL);
   struct lp_scene *scene = setup->scene;
d541 3
a543 1
   assert(scene);
a549 4
      if (!stored) {
         assert(!new_scene);
         return FALSE;
      }
d559 1
d564 20
d585 1
a585 1
      struct pipe_resource *buffer = setup->constants.current;
d588 2
a589 2
         unsigned current_size = buffer->width0;
         const void *current_data = llvmpipe_resource_data(buffer);
d601 6
a606 3
            if (!stored) {
               assert(!new_scene);
               return FALSE;
a607 6

            memcpy(stored,
                   current_data,
                   current_size);
            setup->constants.stored_size = current_size;
            setup->constants.stored_data = stored;
d620 5
a624 9
   if (setup->dirty & LP_SETUP_NEW_FS) {
      if (!setup->fs.stored ||
          memcmp(setup->fs.stored,
                 &setup->fs.current,
                 sizeof setup->fs.current) != 0)
      {
         struct lp_rast_state *stored;
         uint i;
         
d629 12
a640 23
         stored = (struct lp_rast_state *) lp_scene_alloc(scene, sizeof *stored);
         if (!stored) {
            assert(!new_scene);
            return FALSE;
         }

         memcpy(stored,
                &setup->fs.current,
                sizeof setup->fs.current);
         setup->fs.stored = stored;
         
         /* The scene now references the textures in the rasterization
          * state record.  Note that now.
          */
         for (i = 0; i < Elements(setup->fs.current_tex); i++) {
            if (setup->fs.current_tex[i]) {
               if (!lp_scene_add_resource_reference(scene,
                                                    setup->fs.current_tex[i],
                                                    new_scene)) {
                  assert(!new_scene);
                  return FALSE;
               }
            }
a644 8
   if (setup->dirty & LP_SETUP_NEW_SCISSOR) {
      setup->draw_region = setup->framebuffer;
      if (setup->scissor_test) {
         u_rect_possible_intersection(&setup->scissor,
                                      &setup->draw_region);
      }
   }
                                      
a647 72
   return TRUE;
}

boolean
lp_setup_update_state( struct lp_setup_context *setup,
                       boolean update_scene )
{
   /* Some of the 'draw' pipeline stages may have changed some driver state.
    * Make sure we've processed those state changes before anything else.
    *
    * XXX this is the only place where llvmpipe_context is used in the
    * setup code.  This may get refactored/changed...
    */
   {
      struct llvmpipe_context *lp = llvmpipe_context(setup->pipe);
      if (lp->dirty) {
         llvmpipe_update_derived(lp);
      }

      if (lp->setup->dirty) {
         llvmpipe_update_setup(lp);
      }

      assert(setup->setup.variant);

      /* Will probably need to move this somewhere else, just need  
       * to know about vertex shader point size attribute.
       */
      setup->psize = lp->psize_slot;

      assert(lp->dirty == 0);

      assert(lp->setup_variant.key.size == 
	     setup->setup.variant->key.size);

      assert(memcmp(&lp->setup_variant.key,
		    &setup->setup.variant->key,
		    setup->setup.variant->key.size) == 0);
   }

   if (update_scene && setup->state != SETUP_ACTIVE) {
      if (!set_scene_state( setup, SETUP_ACTIVE, __FUNCTION__ ))
         return FALSE;
   }

   /* Only call into update_scene_state() if we already have a
    * scene:
    */
   if (update_scene && setup->scene) {
      assert(setup->state == SETUP_ACTIVE);

      if (try_update_scene_state(setup))
         return TRUE;

      /* Update failed, try to restart the scene.
       *
       * Cannot call lp_setup_flush_and_restart() directly here
       * because of potential recursion.
       */
      if (!set_scene_state(setup, SETUP_FLUSHED, __FUNCTION__))
         return FALSE;

      if (!set_scene_state(setup, SETUP_ACTIVE, __FUNCTION__))
         return FALSE;

      if (!setup->scene)
         return FALSE;

      return try_update_scene_state(setup);
   }

   return TRUE;
d655 1
a655 1
lp_setup_destroy( struct lp_setup_context *setup )
d657 1
a657 5
   uint i;

   lp_setup_reset( setup );

   util_unreference_framebuffer_state(&setup->fb);
d659 1
a659 5
   for (i = 0; i < Elements(setup->fs.current_tex); i++) {
      pipe_resource_reference(&setup->fs.current_tex[i], NULL);
   }

   pipe_resource_reference(&setup->constants.current, NULL);
d662 4
a665 6
   for (i = 0; i < Elements(setup->scenes); i++) {
      struct lp_scene *scene = setup->scenes[i];

      if (scene->fence)
         lp_fence_wait(scene->fence);

d669 1
a669 1
   lp_fence_reference(&setup->last_fence, NULL);
d680 1
a680 1
struct lp_setup_context *
a683 2
   struct llvmpipe_screen *screen = llvmpipe_screen(pipe->screen);
   struct lp_setup_context *setup = CALLOC_STRUCT(lp_setup_context);
d685 1
d691 6
a696 2
   
   /* Used only in update_state():
d698 3
a700 1
   setup->pipe = pipe;
a701 2

   setup->num_threads = screen->num_threads;
d711 3
a713 1
      setup->scenes[i] = lp_scene_create( pipe );
d725 3
d731 3
a736 86


/**
 * Put a BeginQuery command into all bins.
 */
void
lp_setup_begin_query(struct lp_setup_context *setup,
                     struct llvmpipe_query *pq)
{
   /* init the query to its beginning state */
   assert(setup->active_query == NULL);

   set_scene_state(setup, SETUP_ACTIVE, "begin_query");
   
   if (setup->scene) {
      if (!lp_scene_bin_everywhere(setup->scene,
                                   LP_RAST_OP_BEGIN_QUERY,
                                   lp_rast_arg_query(pq))) {

         if (!lp_setup_flush_and_restart(setup))
            return;

         if (!lp_scene_bin_everywhere(setup->scene,
                                      LP_RAST_OP_BEGIN_QUERY,
                                      lp_rast_arg_query(pq))) {
            return;
         }
      }
   }

   setup->active_query = pq;
}


/**
 * Put an EndQuery command into all bins.
 */
void
lp_setup_end_query(struct lp_setup_context *setup, struct llvmpipe_query *pq)
{
   union lp_rast_cmd_arg dummy = { 0 };

   set_scene_state(setup, SETUP_ACTIVE, "end_query");

   assert(setup->active_query == pq);
   setup->active_query = NULL;

   /* Setup will automatically re-issue any query which carried over a
    * scene boundary, and the rasterizer automatically "ends" queries
    * which are active at the end of a scene, so there is no need to
    * retry this commands on failure.
    */
   if (setup->scene) {
      /* pq->fence should be the fence of the *last* scene which
       * contributed to the query result.
       */
      lp_fence_reference(&pq->fence, setup->scene->fence);

      if (!lp_scene_bin_everywhere(setup->scene,
                                   LP_RAST_OP_END_QUERY,
                                   dummy)) {
         lp_setup_flush(setup, 0, NULL, __FUNCTION__);
      }
   }
   else {
      lp_fence_reference(&pq->fence, setup->last_fence);
   }
}


boolean
lp_setup_flush_and_restart(struct lp_setup_context *setup)
{
   if (0) debug_printf("%s\n", __FUNCTION__);

   assert(setup->state == SETUP_ACTIVE);

   if (!set_scene_state(setup, SETUP_FLUSHED, __FUNCTION__))
      return FALSE;
   
   if (!lp_setup_update_state(setup, TRUE))
      return FALSE;

   return TRUE;
}

@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a41 2
#include "draw/draw_pipe.h"
#include "os/os_time.h"
a66 3
   struct llvmpipe_context *lp = llvmpipe_context(setup->pipe);
   boolean discard = lp->rasterizer ? lp->rasterizer->rasterizer_discard : FALSE;

d82 1
a82 1
   lp_scene_begin_binning(setup->scene, &setup->fb, discard);
a118 2
   unsigned i;

d122 2
a123 4
   for (i = 0; i < Elements(setup->constants); ++i) {
      setup->constants[i].stored_size = 0;
      setup->constants[i].stored_data = NULL;
   }
a149 4
   scene->num_active_queries = setup->active_binned_queries;
   memcpy(scene->active_queries, setup->active_queries,
          scene->num_active_queries * sizeof(scene->active_queries[0]));

d176 1
d187 9
d234 8
a245 2
   scene->had_queries = !!setup->active_binned_queries;

d336 3
d341 1
d382 1
a382 1
                    const union pipe_color_union *color,
d387 2
a388 2
   uint64_t zsmask = 0;
   uint64_t zsvalue = 0;
d396 1
a396 1
         color_arg.clear_color.i[i] = color->i[i];
d401 1
a401 1
      uint8_t smask = (flags & PIPE_CLEAR_STENCIL) ? ~0 : 0;
d403 3
a405 3
      zsvalue = util_pack64_z_stencil(setup->fb.zsbuf->format,
                                      depth,
                                      stencil);
d408 3
a410 3
      zsmask = util_pack64_mask_z_stencil(setup->fb.zsbuf->format,
                                          zmask,
                                          smask);
d455 1
a455 1
         memcpy(&setup->clear.color.clear_color,
d466 1
a466 1
                const union pipe_color_union *color,
d472 1
a472 1
      lp_setup_flush(setup, NULL, __FUNCTION__);
d488 1
a488 2
                             boolean half_pixel_center,
                             boolean bottom_edge_rule)
d495 1
a495 2
   setup->pixel_offset = half_pixel_center ? 0.5f : 0.0f;
   setup->bottom_edge_rule = bottom_edge_rule;
d550 1
a550 2
                          unsigned num,
                          struct pipe_constant_buffer *buffers)
d552 1
a552 3
   unsigned i;

   LP_DBG(DEBUG_SETUP, "%s %p\n", __FUNCTION__, (void *) buffers);
d554 1
a554 1
   assert(num <= Elements(setup->constants));
a555 6
   for (i = 0; i < num; ++i) {
      util_copy_constant_buffer(&setup->constants[i].current, &buffers[i]);
   }
   for (; i < Elements(setup->constants); i++) {
      util_copy_constant_buffer(&setup->constants[i].current, NULL);
   }
d602 2
a603 2
lp_setup_set_scissors( struct lp_setup_context *setup,
                       const struct pipe_scissor_state *scissors )
a604 1
   unsigned i;
d607 1
a607 1
   assert(scissors);
d609 4
a612 6
   for (i = 0; i < PIPE_MAX_VIEWPORTS; ++i) {
      setup->scissors[i].x0 = scissors[i].minx;
      setup->scissors[i].x1 = scissors[i].maxx-1;
      setup->scissors[i].y0 = scissors[i].miny;
      setup->scissors[i].y1 = scissors[i].maxy-1;
   }
a623 9
void
lp_setup_set_rasterizer_discard( struct lp_setup_context *setup,
                                 boolean rasterizer_discard )
{
   if (setup->rasterizer_discard != rasterizer_discard) {
      setup->rasterizer_discard = rasterizer_discard;
      set_scene_state( setup, SETUP_FLUSHED, __FUNCTION__ );
   }
}
d647 1
a647 1
   assert(num <= PIPE_MAX_SHADER_SAMPLER_VIEWS);
d649 1
a649 1
   for (i = 0; i < PIPE_MAX_SHADER_SAMPLER_VIEWS; i++) {
d653 2
a654 2
         struct pipe_resource *res = view->texture;
         struct llvmpipe_resource *lp_tex = llvmpipe_resource(res);
d657 4
d665 1
a665 1
         pipe_resource_reference(&setup->fs.current_tex[i], res);
d668 1
a668 2
            /* regular texture - setup array of mipmap level offsets */
            void *mip_ptr;
d670 17
a686 90
            unsigned first_level = 0;
            unsigned last_level = 0;

            if (llvmpipe_resource_is_texture(res)) {
               first_level = view->u.tex.first_level;
               last_level = view->u.tex.last_level;
               assert(first_level <= last_level);
               assert(last_level <= res->last_level);

               /*
                * The complexity here should no longer be necessary.
                */
               mip_ptr = llvmpipe_get_texture_image_all(lp_tex, first_level,
                                                        LP_TEX_USAGE_READ);
               jit_tex->base = lp_tex->linear_img.data;
            }
            else {
               mip_ptr = lp_tex->data;
               jit_tex->base = mip_ptr;
            }

            if ((LP_PERF & PERF_TEX_MEM) || !mip_ptr) {
               /* out of memory - use dummy tile memory */
               /* Note if using PERF_TEX_MEM will also skip tile conversion */
               jit_tex->base = lp_dummy_tile;
               jit_tex->width = TILE_SIZE/8;
               jit_tex->height = TILE_SIZE/8;
               jit_tex->depth = 1;
               jit_tex->first_level = 0;
               jit_tex->last_level = 0;
               jit_tex->mip_offsets[0] = 0;
               jit_tex->row_stride[0] = 0;
               jit_tex->img_stride[0] = 0;
            }
            else {
               jit_tex->width = res->width0;
               jit_tex->height = res->height0;
               jit_tex->depth = res->depth0;
               jit_tex->first_level = first_level;
               jit_tex->last_level = last_level;

               if (llvmpipe_resource_is_texture(res)) {
                  for (j = first_level; j <= last_level; j++) {
                     mip_ptr = llvmpipe_get_texture_image_all(lp_tex, j,
                                                              LP_TEX_USAGE_READ);
                     jit_tex->mip_offsets[j] = (uint8_t *)mip_ptr - (uint8_t *)jit_tex->base;
                     /*
                      * could get mip offset directly but need call above to
                      * invoke tiled->linear conversion.
                      */
                     assert(lp_tex->linear_mip_offsets[j] == jit_tex->mip_offsets[j]);
                     jit_tex->row_stride[j] = lp_tex->row_stride[j];
                     jit_tex->img_stride[j] = lp_tex->img_stride[j];
                  }

                  if (res->target == PIPE_TEXTURE_1D_ARRAY ||
                      res->target == PIPE_TEXTURE_2D_ARRAY) {
                     /*
                      * For array textures, we don't have first_layer, instead
                      * adjust last_layer (stored as depth) plus the mip level offsets
                      * (as we have mip-first layout can't just adjust base ptr).
                      * XXX For mip levels, could do something similar.
                      */
                     jit_tex->depth = view->u.tex.last_layer - view->u.tex.first_layer + 1;
                     for (j = first_level; j <= last_level; j++) {
                        jit_tex->mip_offsets[j] += view->u.tex.first_layer *
                                                   lp_tex->img_stride[j];
                     }
                     assert(view->u.tex.first_layer <= view->u.tex.last_layer);
                     assert(view->u.tex.last_layer < res->array_size);
                  }
               }
               else {
                  /*
                   * For buffers, we don't have first_element, instead adjust
                   * last_element (stored as width) plus the base pointer.
                   */
                  unsigned view_blocksize = util_format_get_blocksize(view->format);
                  /* probably don't really need to fill that out */
                  jit_tex->mip_offsets[0] = 0;
                  jit_tex->row_stride[0] = 0;
                  jit_tex->row_stride[0] = 0;

                  /* everything specified in number of elements here. */
                  jit_tex->width = view->u.buf.last_element - view->u.buf.first_element + 1;
                  jit_tex->base = (uint8_t *)jit_tex->base + view->u.buf.first_element *
                                  view_blocksize;
                  /* XXX Unsure if we need to sanitize parameters? */
                  assert(view->u.buf.first_element <= view->u.buf.last_element);
                  assert(view->u.buf.last_element * view_blocksize < res->width0);
d695 1
a695 1
            struct llvmpipe_screen *screen = llvmpipe_screen(res->screen);
d697 2
a698 2
            jit_tex->base = winsys->displaytarget_map(winsys, lp_tex->dt,
                                                         PIPE_TRANSFER_READ);
d701 1
a701 6
            jit_tex->mip_offsets[0] = 0;
            jit_tex->width = res->width0;
            jit_tex->height = res->height0;
            jit_tex->depth = res->depth0;
            jit_tex->first_level = jit_tex->last_level = 0;
            assert(jit_tex->base);
d716 1
a716 1
                                    struct pipe_sampler_state **samplers)
d728 2
a729 2
         struct lp_jit_sampler *jit_sam;
         jit_sam = &setup->fs.current.jit_context.samplers[i];
d731 4
a734 4
         jit_sam->min_lod = sampler->min_lod;
         jit_sam->max_lod = sampler->max_lod;
         jit_sam->lod_bias = sampler->lod_bias;
         COPY_4V(jit_sam->border_color, sampler->border_color.f);
d756 1
a756 1
         return LP_REFERENCED_FOR_READ | LP_REFERENCED_FOR_WRITE;
d759 1
a759 1
      return LP_REFERENCED_FOR_READ | LP_REFERENCED_FOR_WRITE;
d765 1
a765 1
         return LP_REFERENCED_FOR_READ;
d769 1
a769 1
   return LP_UNREFERENCED;
a780 1
   unsigned i;
a785 1
      float* fstored;
a786 6
      unsigned size;

      /* Alloc u8_blend_color (16 x i8) and f_blend_color (4 or 8 x f32) */
      size  = 4 * 16 * sizeof(uint8_t);
      size += (LP_MAX_VECTOR_LENGTH / 4) * sizeof(float);
      stored = lp_scene_alloc_aligned(scene, size, LP_MAX_VECTOR_LENGTH);
d788 1
a793 6
      /* Store floating point colour */
      fstored = (float*)(stored + 4*16);
      for (i = 0; i < (LP_MAX_VECTOR_LENGTH / 4); ++i) {
         fstored[i] = setup->blend_color.current.color[i % 4];
      }

d802 1
a802 2
      setup->fs.current.jit_context.u8_blend_color = stored;
      setup->fs.current.jit_context.f_blend_color = fstored;
d806 2
a807 14
   if (setup->dirty & LP_SETUP_NEW_CONSTANTS) {
      for (i = 0; i < Elements(setup->constants); ++i) {
         struct pipe_resource *buffer = setup->constants[i].current.buffer;
         const unsigned current_size = setup->constants[i].current.buffer_size;
         const ubyte *current_data = NULL;

         if (buffer) {
            /* resource buffer */
            current_data = (ubyte *) llvmpipe_resource_data(buffer);
         }
         else if (setup->constants[i].current.user_buffer) {
            /* user-space buffer */
            current_data = (ubyte *) setup->constants[i].current.user_buffer;
         }
d809 18
a826 17
         if (current_data) {
            current_data += setup->constants[i].current.buffer_offset;

            /* TODO: copy only the actually used constants? */

            if (setup->constants[i].stored_size != current_size ||
               !setup->constants[i].stored_data ||
               memcmp(setup->constants[i].stored_data,
                      current_data,
                      current_size) != 0) {
               void *stored;

               stored = lp_scene_alloc(scene, current_size);
               if (!stored) {
                  assert(!new_scene);
                  return FALSE;
               }
d828 5
a832 10
               memcpy(stored,
                      current_data,
                      current_size);
               setup->constants[i].stored_size = current_size;
               setup->constants[i].stored_data = stored;
            }
         }
         else {
            setup->constants[i].stored_size = 0;
            setup->constants[i].stored_data = NULL;
d834 5
d840 2
a841 3
         setup->fs.current.jit_context.constants[i] = setup->constants[i].stored_data;
         setup->dirty |= LP_SETUP_NEW_FS;
      }
d852 1
d886 4
a889 7
      unsigned i;
      for (i = 0; i < PIPE_MAX_VIEWPORTS; ++i) {
         setup->draw_regions[i] = setup->framebuffer;
         if (setup->scissor_test) {
            u_rect_possible_intersection(&setup->scissors[i],
                                         &setup->draw_regions[i]);
         }
a890 10
      /* If the framebuffer is large we have to think about fixed-point
       * integer overflow.  For 2K by 2K images, coordinates need 15 bits
       * (2^11 + 4 subpixel bits).  The product of two such numbers would
       * use 30 bits.  Any larger and we could overflow a 32-bit int.
       *
       * To cope with this problem we check if triangles are large and
       * subdivide them if needed.
       */
      setup->subdivide_large_triangles = (setup->fb.width > 2048 &&
                                          setup->fb.height > 2048);
a924 2
      setup->viewport_index_slot = lp->viewport_index_slot;
      setup->layer_slot = lp->layer_slot;
d987 1
a987 3
   for (i = 0; i < Elements(setup->constants); i++) {
      pipe_resource_reference(&setup->constants[i].current.buffer, NULL);
   }
d1015 1
a1015 1
   struct lp_setup_context *setup;
d1018 2
a1019 4
   setup = CALLOC_STRUCT(lp_setup_context);
   if (!setup) {
      goto no_setup;
   }
d1030 2
a1031 3
   if (!setup->vbuf) {
      goto no_vbuf;
   }
a1038 3
      if (!setup->scenes[i]) {
         goto no_scenes;
      }
d1049 3
a1051 6
no_scenes:
   for (i = 0; i < MAX_SCENES; i++) {
      if (setup->scenes[i]) {
         lp_scene_destroy(setup->scenes[i]);
      }
   }
a1052 2
   setup->vbuf->destroy(setup->vbuf);
no_vbuf:
a1053 1
no_setup:
d1065 2
d1069 1
a1069 17

   if (!(pq->type == PIPE_QUERY_OCCLUSION_COUNTER ||
         pq->type == PIPE_QUERY_OCCLUSION_PREDICATE ||
         pq->type == PIPE_QUERY_PIPELINE_STATISTICS))
      return;

   /* init the query to its beginning state */
   assert(setup->active_binned_queries < LP_MAX_ACTIVE_BINNED_QUERIES);
   /* exceeding list size so just ignore the query */
   if (setup->active_binned_queries >= LP_MAX_ACTIVE_BINNED_QUERIES) {
      return;
   }
   assert(setup->active_queries[setup->active_binned_queries] == NULL);
   setup->active_queries[setup->active_binned_queries] = pq;
   setup->active_binned_queries++;

   assert(setup->scene);
a1083 1
      setup->scene->had_queries |= TRUE;
d1085 2
d1096 2
d1100 8
a1107 1
   assert(setup->scene);
d1114 4
a1117 26
      if (pq->type == PIPE_QUERY_OCCLUSION_COUNTER ||
          pq->type == PIPE_QUERY_OCCLUSION_PREDICATE ||
          pq->type == PIPE_QUERY_PIPELINE_STATISTICS ||
          pq->type == PIPE_QUERY_TIMESTAMP) {
         if (pq->type == PIPE_QUERY_TIMESTAMP &&
               !(setup->scene->tiles_x | setup->scene->tiles_y)) {
            /*
             * If there's a zero width/height framebuffer, there's no bins and
             * hence no rast task is ever run. So fill in something here instead.
             */
            pq->end[0] = os_time_get_nano();
         }

         if (!lp_scene_bin_everywhere(setup->scene,
                                      LP_RAST_OP_END_QUERY,
                                      lp_rast_arg_query(pq))) {
            if (!lp_setup_flush_and_restart(setup))
               goto fail;

            if (!lp_scene_bin_everywhere(setup->scene,
                                         LP_RAST_OP_END_QUERY,
                                         lp_rast_arg_query(pq))) {
               goto fail;
            }
         }
         setup->scene->had_queries |= TRUE;
a1121 22
   }

fail:
   /* Need to do this now not earlier since it still needs to be marked as
    * active when binning it would cause a flush.
    */
   if (pq->type == PIPE_QUERY_OCCLUSION_COUNTER ||
      pq->type == PIPE_QUERY_OCCLUSION_PREDICATE ||
      pq->type == PIPE_QUERY_PIPELINE_STATISTICS) {
      unsigned i;

      /* remove from active binned query list */
      for (i = 0; i < setup->active_binned_queries; i++) {
         if (setup->active_queries[i] == pq)
            break;
      }
      assert(i < setup->active_binned_queries);
      if (i == setup->active_binned_queries)
         return;
      setup->active_binned_queries--;
      setup->active_queries[i] = setup->active_queries[setup->active_binned_queries];
      setup->active_queries[setup->active_binned_queries] = NULL;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d69 3
d87 2
a88 2
   lp_scene_begin_binning(setup->scene, &setup->fb, setup->rasterizer_discard);

d208 2
a209 2
   LP_DBG(DEBUG_SETUP, "%s color clear bufs: %x depth: %s\n", __FUNCTION__,
          setup->clear.flags >> 2,
d212 7
a218 23
   if (setup->clear.flags & PIPE_CLEAR_COLOR) {
      unsigned cbuf;
      for (cbuf = 0; cbuf < setup->fb.nr_cbufs; cbuf++) {
         assert(PIPE_CLEAR_COLOR0 == 1 << 2);
         if (setup->clear.flags & (1 << (2 + cbuf))) {
            union lp_rast_cmd_arg clearrb_arg;
            struct lp_rast_clear_rb *cc_scene =
               (struct lp_rast_clear_rb *)
                  lp_scene_alloc(scene, sizeof(struct lp_rast_clear_rb));

            if (!cc_scene) {
               return FALSE;
            }

            cc_scene->cbuf = cbuf;
            cc_scene->color_val = setup->clear.color_val[cbuf];
            clearrb_arg.clear_rb = cc_scene;

            if (!lp_scene_bin_everywhere(scene,
                                         LP_RAST_OP_CLEAR_COLOR,
                                         clearrb_arg))
               return FALSE;
         }
d224 3
a372 4
/*
 * Try to clear one color buffer of the attached fb, either by binning a clear
 * command or queuing up the clear for later (when binning is started).
 */
d374 10
a383 7
lp_setup_try_clear_color_buffer(struct lp_setup_context *setup,
                                const union pipe_color_union *color,
                                unsigned cbuf)
{
   union lp_rast_cmd_arg clearrb_arg;
   union util_color uc;
   enum pipe_format format = setup->fb.cbufs[cbuf]->format;
d387 3
a389 16
   if (util_format_is_pure_integer(format)) {
      /*
       * We expect int/uint clear values here, though some APIs
       * might disagree (but in any case util_pack_color()
       * couldn't handle it)...
       */
      if (util_format_is_pure_sint(format)) {
         util_format_write_4i(format, color->i, 0, &uc, 0, 0, 0, 1, 1);
      }
      else {
         assert(util_format_is_pure_uint(format));
         util_format_write_4ui(format, color->ui, 0, &uc, 0, 0, 0, 1, 1);
      }
   }
   else {
      util_pack_color(color->f, format, &uc);
d392 3
a394 2
   if (setup->state == SETUP_ACTIVE) {
      struct lp_scene *scene = setup->scene;
d396 3
a398 9
      /* Add the clear to existing scene.  In the unusual case where
       * both color and depth-stencil are being cleared when there's
       * already been some rendering, we could discard the currently
       * binned scene and start again, but I don't see that as being
       * a common usage.
       */
      struct lp_rast_clear_rb *cc_scene =
         (struct lp_rast_clear_rb *)
            lp_scene_alloc_aligned(scene, sizeof(struct lp_rast_clear_rb), 8);
a399 3
      if (!cc_scene) {
         return FALSE;
      }
d401 3
a403 16
      cc_scene->cbuf = cbuf;
      cc_scene->color_val = uc;
      clearrb_arg.clear_rb = cc_scene;

      if (!lp_scene_bin_everywhere(scene,
                                   LP_RAST_OP_CLEAR_COLOR,
                                   clearrb_arg))
         return FALSE;
   }
   else {
      /* Put ourselves into the 'pre-clear' state, specifically to try
       * and accumulate multiple clears to color and depth_stencil
       * buffers which the app or state-tracker might issue
       * separately.
       */
      set_scene_state( setup, SETUP_CLEARED, __FUNCTION__ );
d405 1
a405 3
      assert(PIPE_CLEAR_COLOR0 == (1 << 2));
      setup->clear.flags |= 1 << (cbuf + 2);
      setup->clear.color_val[cbuf] = uc;
a407 29
   return TRUE;
}

static boolean
lp_setup_try_clear_zs(struct lp_setup_context *setup,
                      double depth,
                      unsigned stencil,
                      unsigned flags)
{
   uint64_t zsmask = 0;
   uint64_t zsvalue = 0;
   uint32_t zmask32;
   uint8_t smask8;

   LP_DBG(DEBUG_SETUP, "%s state %d\n", __FUNCTION__, setup->state);

   zmask32 = (flags & PIPE_CLEAR_DEPTH) ? ~0 : 0;
   smask8 = (flags & PIPE_CLEAR_STENCIL) ? ~0 : 0;

   zsvalue = util_pack64_z_stencil(setup->fb.zsbuf->format,
                                   depth,
                                   stencil);

   zsmask = util_pack64_mask_z_stencil(setup->fb.zsbuf->format,
                                       zmask32,
                                       smask8);

   zsvalue &= zsmask;

d417 13
a429 4
      if (!lp_scene_bin_everywhere(scene,
                                   LP_RAST_OP_CLEAR_ZSTENCIL,
                                   lp_rast_arg_clearzs(zsvalue, zsmask)))
         return FALSE;
d441 11
a451 3
      setup->clear.zsmask |= zsmask;
      setup->clear.zsvalue =
         (setup->clear.zsvalue & ~zsmask) | (zsvalue & zsmask);
d453 1
a453 1

d464 2
a465 1
   unsigned i;
d467 2
a468 14
   /*
    * Note any of these (max 9) clears could fail (but at most there should
    * be just one failure!). This avoids doing the previous succeeded
    * clears again (we still clear tiles twice if a clear command succeeded
    * partially for one buffer).
    */
   if (flags & PIPE_CLEAR_DEPTHSTENCIL) {
      unsigned flagszs = flags & PIPE_CLEAR_DEPTHSTENCIL;
      if (!lp_setup_try_clear_zs(setup, depth, stencil, flagszs)) {
         lp_setup_flush(setup, NULL, __FUNCTION__);

         if (!lp_setup_try_clear_zs(setup, depth, stencil, flagszs))
            assert(0);
      }
d470 1
a471 6
   if (flags & PIPE_CLEAR_COLOR) {
      assert(PIPE_CLEAR_COLOR0 == (1 << 2));
      for (i = 0; i < setup->fb.nr_cbufs; i++) {
         if ((flags & (1 << (2 + i))) && setup->fb.cbufs[i]) {
            if (!lp_setup_try_clear_color_buffer(setup, color, i)) {
               lp_setup_flush(setup, NULL, __FUNCTION__);
a472 7
               if (!lp_setup_try_clear_color_buffer(setup, color, i))
                  assert(0);
            }
         }
      }
   }
}
d509 1
a509 1
                          float point_size,
a651 42
 * Called during state validation when LP_NEW_VIEWPORT is set.
 */
void
lp_setup_set_viewports(struct lp_setup_context *setup,
                       unsigned num_viewports,
                       const struct pipe_viewport_state *viewports)
{
   struct llvmpipe_context *lp = llvmpipe_context(setup->pipe);
   unsigned i;

   LP_DBG(DEBUG_SETUP, "%s\n", __FUNCTION__);

   assert(num_viewports <= PIPE_MAX_VIEWPORTS);
   assert(viewports);

   /*
    * For use in lp_state_fs.c, propagate the viewport values for all viewports.
    */
   for (i = 0; i < num_viewports; i++) {
      float min_depth;
      float max_depth;

      if (lp->rasterizer->clip_halfz == 0) {
         float half_depth = viewports[i].scale[2];
         min_depth = viewports[i].translate[2] - half_depth;
         max_depth = min_depth + half_depth * 2.0f;
      } else {
         min_depth = viewports[i].translate[2];
         max_depth = min_depth + viewports[i].scale[2];
      }

      if (setup->viewports[i].min_depth != min_depth ||
          setup->viewports[i].max_depth != max_depth) {
          setup->viewports[i].min_depth = min_depth;
          setup->viewports[i].max_depth = max_depth;
          setup->dirty |= LP_SETUP_NEW_VIEWPORTS;
      }
   }
}


/**
d846 1
a846 1
      if (setup->fb.cbufs[i] && setup->fb.cbufs[i]->texture == texture)
a865 9
 *
 * This function stores all dirty state in the current scene's display list
 * memory, via lp_scene_alloc().  We can not pass pointers of mutable state to
 * the JIT functions, as the JIT functions will be called later on, most likely
 * on a different thread.
 *
 * When processing dirty state it is imperative that we don't refer to any
 * pointers previously allocated with lp_scene_alloc() in this function (or any
 * function) as they may belong to a scene freed since then.
a875 23
   if (setup->dirty & LP_SETUP_NEW_VIEWPORTS) {
      /*
       * Record new depth range state for changes due to viewport updates.
       *
       * TODO: Collapse the existing viewport and depth range information
       *       into one structure, for access by JIT.
       */
      struct lp_jit_viewport *stored;

      stored = (struct lp_jit_viewport *)
         lp_scene_alloc(scene, sizeof setup->viewports);

      if (!stored) {
         assert(!new_scene);
         return FALSE;
      }

      memcpy(stored, setup->viewports, sizeof setup->viewports);

      setup->fs.current.jit_context.viewports = stored;
      setup->dirty |= LP_SETUP_NEW_FS;
   }

d885 1
a885 1
      stored = lp_scene_alloc_aligned(scene, size, LP_MIN_VECTOR_ALIGN);
a915 1
         int num_constants;
d956 1
a956 5
         setup->fs.current.jit_context.constants[i] =
            setup->constants[i].stored_data;
         num_constants =
            setup->constants[i].stored_size / (sizeof(float) * 4);
         setup->fs.current.jit_context.num_constants[i] = num_constants;
d1010 10
d1021 1
a1021 1

a1055 1
      setup->face_slot = lp->face_slot;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d805 1
d815 7
a821 1
               jit_tex->base = lp_tex->tex_data;
d824 2
a825 1
              jit_tex->base = lp_tex->data;
d828 3
a830 2
            if (LP_PERF & PERF_TEX_MEM) {
               /* use dummy tile memory */
d850 8
a857 1
                     jit_tex->mip_offsets[j] = lp_tex->mip_offsets[j];
d863 1
a863 2
                      res->target == PIPE_TEXTURE_2D_ARRAY ||
                      res->target == PIPE_TEXTURE_CUBE_ARRAY) {
a874 3
                     if (res->target == PIPE_TEXTURE_CUBE_ARRAY) {
                        assert(jit_tex->depth % 6 == 0);
                     }
d888 1
a888 1
                  jit_tex->img_stride[0] = 0;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a804 1
            void *mip_ptr;
d814 1
a814 7

               /*
                * The complexity here should no longer be necessary.
                */
               mip_ptr = llvmpipe_get_texture_image_all(lp_tex, first_level,
                                                        LP_TEX_USAGE_READ);
               jit_tex->base = lp_tex->linear_img.data;
d817 1
a817 2
               mip_ptr = lp_tex->data;
               jit_tex->base = mip_ptr;
d820 2
a821 3
            if ((LP_PERF & PERF_TEX_MEM) || !mip_ptr) {
               /* out of memory - use dummy tile memory */
               /* Note if using PERF_TEX_MEM will also skip tile conversion */
d841 1
a841 8
                     mip_ptr = llvmpipe_get_texture_image_all(lp_tex, j,
                                                              LP_TEX_USAGE_READ);
                     jit_tex->mip_offsets[j] = (uint8_t *)mip_ptr - (uint8_t *)jit_tex->base;
                     /*
                      * could get mip offset directly but need call above to
                      * invoke tiled->linear conversion.
                      */
                     assert(lp_tex->linear_mip_offsets[j] == jit_tex->mip_offsets[j]);
d847 2
a848 1
                      res->target == PIPE_TEXTURE_2D_ARRAY) {
d860 3
d876 1
a876 1
                  jit_tex->row_stride[0] = 0;
@


