head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.08.53;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.00.32;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.13.13.00.28;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.25;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.57;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.07.26;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.44.34;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/**
 * @@file
 * C - JIT interfaces
 *
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 */


#include "util/u_memory.h"
#include "gallivm/lp_bld_init.h"
#include "gallivm/lp_bld_debug.h"
#include "lp_context.h"
#include "lp_jit.h"


static void
lp_jit_create_types(struct lp_fragment_shader_variant *lp)
{
   struct gallivm_state *gallivm = lp->gallivm;
   LLVMContextRef lc = gallivm->context;
   LLVMTypeRef viewport_type, texture_type, sampler_type;

   /* struct lp_jit_viewport */
   {
      LLVMTypeRef elem_types[LP_JIT_VIEWPORT_NUM_FIELDS];

      elem_types[LP_JIT_VIEWPORT_MIN_DEPTH] =
      elem_types[LP_JIT_VIEWPORT_MAX_DEPTH] = LLVMFloatTypeInContext(lc);

      viewport_type = LLVMStructTypeInContext(lc, elem_types,
                                              Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "viewport", viewport_type);

      LLVMInvalidateStructLayout(gallivm->target, viewport_type);
#endif

      LP_CHECK_MEMBER_OFFSET(struct lp_jit_viewport, min_depth,
                             gallivm->target, viewport_type,
                             LP_JIT_VIEWPORT_MIN_DEPTH);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_viewport, max_depth,
                             gallivm->target, viewport_type,
                             LP_JIT_VIEWPORT_MAX_DEPTH);
      LP_CHECK_STRUCT_SIZE(struct lp_jit_viewport,
                           gallivm->target, viewport_type);
   }

   /* struct lp_jit_texture */
   {
      LLVMTypeRef elem_types[LP_JIT_TEXTURE_NUM_FIELDS];

      elem_types[LP_JIT_TEXTURE_WIDTH]  =
      elem_types[LP_JIT_TEXTURE_HEIGHT] =
      elem_types[LP_JIT_TEXTURE_DEPTH] =
      elem_types[LP_JIT_TEXTURE_FIRST_LEVEL] =
      elem_types[LP_JIT_TEXTURE_LAST_LEVEL] = LLVMInt32TypeInContext(lc);
      elem_types[LP_JIT_TEXTURE_BASE] = LLVMPointerType(LLVMInt8TypeInContext(lc), 0);
      elem_types[LP_JIT_TEXTURE_ROW_STRIDE] =
      elem_types[LP_JIT_TEXTURE_IMG_STRIDE] =
      elem_types[LP_JIT_TEXTURE_MIP_OFFSETS] =
         LLVMArrayType(LLVMInt32TypeInContext(lc), LP_MAX_TEXTURE_LEVELS);

      texture_type = LLVMStructTypeInContext(lc, elem_types,
                                             Elements(elem_types), 0);
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "texture", texture_type);

      LLVMInvalidateStructLayout(gallivm->target, texture_type);
#endif

      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, width,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_WIDTH);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, height,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_HEIGHT);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, depth,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_DEPTH);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, first_level,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_FIRST_LEVEL);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, last_level,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_LAST_LEVEL);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, base,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_BASE);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, row_stride,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_ROW_STRIDE);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, img_stride,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_IMG_STRIDE);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, mip_offsets,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_MIP_OFFSETS);
      LP_CHECK_STRUCT_SIZE(struct lp_jit_texture,
                           gallivm->target, texture_type);
   }

   /* struct lp_jit_sampler */
   {
      LLVMTypeRef elem_types[LP_JIT_SAMPLER_NUM_FIELDS];
      elem_types[LP_JIT_SAMPLER_MIN_LOD] =
      elem_types[LP_JIT_SAMPLER_MAX_LOD] =
      elem_types[LP_JIT_SAMPLER_LOD_BIAS] = LLVMFloatTypeInContext(lc);
      elem_types[LP_JIT_SAMPLER_BORDER_COLOR] =
         LLVMArrayType(LLVMFloatTypeInContext(lc), 4);

      sampler_type = LLVMStructTypeInContext(lc, elem_types,
                                             Elements(elem_types), 0);
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "sampler", sampler_type);

      LLVMInvalidateStructLayout(gallivm->target, sampler_type);
#endif

      LP_CHECK_MEMBER_OFFSET(struct lp_jit_sampler, min_lod,
                             gallivm->target, sampler_type,
                             LP_JIT_SAMPLER_MIN_LOD);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_sampler, max_lod,
                             gallivm->target, sampler_type,
                             LP_JIT_SAMPLER_MAX_LOD);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_sampler, lod_bias,
                             gallivm->target, sampler_type,
                             LP_JIT_SAMPLER_LOD_BIAS);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_sampler, border_color,
                             gallivm->target, sampler_type,
                             LP_JIT_SAMPLER_BORDER_COLOR);
      LP_CHECK_STRUCT_SIZE(struct lp_jit_sampler,
                           gallivm->target, sampler_type);
   }

   /* struct lp_jit_context */
   {
      LLVMTypeRef elem_types[LP_JIT_CTX_COUNT];
      LLVMTypeRef context_type;

      elem_types[LP_JIT_CTX_CONSTANTS] =
         LLVMArrayType(LLVMPointerType(LLVMFloatTypeInContext(lc), 0), LP_MAX_TGSI_CONST_BUFFERS);
      elem_types[LP_JIT_CTX_NUM_CONSTANTS] =
            LLVMArrayType(LLVMInt32TypeInContext(lc), LP_MAX_TGSI_CONST_BUFFERS);
      elem_types[LP_JIT_CTX_ALPHA_REF] = LLVMFloatTypeInContext(lc);
      elem_types[LP_JIT_CTX_STENCIL_REF_FRONT] =
      elem_types[LP_JIT_CTX_STENCIL_REF_BACK] = LLVMInt32TypeInContext(lc);
      elem_types[LP_JIT_CTX_U8_BLEND_COLOR] = LLVMPointerType(LLVMInt8TypeInContext(lc), 0);
      elem_types[LP_JIT_CTX_F_BLEND_COLOR] = LLVMPointerType(LLVMFloatTypeInContext(lc), 0);
      elem_types[LP_JIT_CTX_VIEWPORTS] = LLVMPointerType(viewport_type, 0);
      elem_types[LP_JIT_CTX_TEXTURES] = LLVMArrayType(texture_type,
                                                      PIPE_MAX_SHADER_SAMPLER_VIEWS);
      elem_types[LP_JIT_CTX_SAMPLERS] = LLVMArrayType(sampler_type,
                                                      PIPE_MAX_SAMPLERS);

      context_type = LLVMStructTypeInContext(lc, elem_types,
                                             Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
      LLVMInvalidateStructLayout(gallivm->target, context_type);

      LLVMAddTypeName(gallivm->module, "context", context_type);
#endif

      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, constants,
                             gallivm->target, context_type,
                             LP_JIT_CTX_CONSTANTS);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, num_constants,
                             gallivm->target, context_type,
                             LP_JIT_CTX_NUM_CONSTANTS);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, alpha_ref_value,
                             gallivm->target, context_type,
                             LP_JIT_CTX_ALPHA_REF);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, stencil_ref_front,
                             gallivm->target, context_type,
                             LP_JIT_CTX_STENCIL_REF_FRONT);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, stencil_ref_back,
                             gallivm->target, context_type,
                             LP_JIT_CTX_STENCIL_REF_BACK);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, u8_blend_color,
                             gallivm->target, context_type,
                             LP_JIT_CTX_U8_BLEND_COLOR);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, f_blend_color,
                             gallivm->target, context_type,
                             LP_JIT_CTX_F_BLEND_COLOR);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, viewports,
                             gallivm->target, context_type,
                             LP_JIT_CTX_VIEWPORTS);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, textures,
                             gallivm->target, context_type,
                             LP_JIT_CTX_TEXTURES);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, samplers,
                             gallivm->target, context_type,
                             LP_JIT_CTX_SAMPLERS);
      LP_CHECK_STRUCT_SIZE(struct lp_jit_context,
                           gallivm->target, context_type);

      lp->jit_context_ptr_type = LLVMPointerType(context_type, 0);
   }

   /* struct lp_jit_thread_data */
   {
      LLVMTypeRef elem_types[LP_JIT_THREAD_DATA_COUNT];
      LLVMTypeRef thread_data_type;

      elem_types[LP_JIT_THREAD_DATA_COUNTER] = LLVMInt64TypeInContext(lc);
      elem_types[LP_JIT_THREAD_DATA_RASTER_STATE_VIEWPORT_INDEX] =
            LLVMInt32TypeInContext(lc);

      thread_data_type = LLVMStructTypeInContext(lc, elem_types,
                                                 Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
      LLVMInvalidateStructLayout(gallivm->target, thread_data_type);

      LLVMAddTypeName(gallivm->module, "thread_data", thread_data_type);
#endif

      lp->jit_thread_data_ptr_type = LLVMPointerType(thread_data_type, 0);
   }

   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      LLVMDumpModule(gallivm->module);
   }
}


void
lp_jit_screen_cleanup(struct llvmpipe_screen *screen)
{
   /* nothing */
}


void
lp_jit_screen_init(struct llvmpipe_screen *screen)
{
   lp_build_init();
}


void
lp_jit_init_types(struct lp_fragment_shader_variant *lp)
{
   if (!lp->jit_context_ptr_type)
      lp_jit_create_types(lp);
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d60 6
d93 5
d141 5
d186 6
d240 6
d262 1
a262 1
boolean
d265 1
a265 1
   return lp_build_init();
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a59 6
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "viewport", viewport_type);

      LLVMInvalidateStructLayout(gallivm->target, viewport_type);
#endif

a86 5
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "texture", texture_type);

      LLVMInvalidateStructLayout(gallivm->target, texture_type);
#endif
a129 5
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "sampler", sampler_type);

      LLVMInvalidateStructLayout(gallivm->target, sampler_type);
#endif
a169 6
#if HAVE_LLVM < 0x0300
      LLVMInvalidateStructLayout(gallivm->target, context_type);

      LLVMAddTypeName(gallivm->module, "context", context_type);
#endif

a217 6
#if HAVE_LLVM < 0x0300
      LLVMInvalidateStructLayout(gallivm->target, thread_data_type);

      LLVMAddTypeName(gallivm->module, "thread_data", thread_data_type);
#endif

d234 1
a234 1
void
d237 1
a237 1
   lp_build_init();
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d48 27
a74 1
   LLVMTypeRef texture_type, sampler_type;
d130 1
a131 1
   /* struct lp_jit_sampler */
d142 1
a142 1
      LLVMAddTypeName(gallivm->module, "texture", texture_type);
d144 1
a144 1
      LLVMInvalidateStructLayout(gallivm->target, texture_type);
d148 1
a148 1
                             gallivm->target, texture_type,
d151 1
a151 1
                             gallivm->target, texture_type,
d154 1
a154 1
                             gallivm->target, texture_type,
d157 1
a157 1
                             gallivm->target, texture_type,
d169 3
a171 1
            LLVMArrayType(LLVMPointerType(LLVMFloatTypeInContext(lc), 0), LP_MAX_TGSI_CONST_BUFFERS);
d177 1
d195 3
d213 3
d234 2
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d44 1
a44 1
lp_jit_create_types(struct llvmpipe_context *lp)
d48 1
a48 1
   LLVMTypeRef texture_type;
d58 2
a59 1
      elem_types[LP_JIT_TEXTURE_LAST_LEVEL] =  LLVMInt32TypeInContext(lc);
d62 1
a63 8
      elem_types[LP_JIT_TEXTURE_DATA] =
         LLVMArrayType(LLVMPointerType(LLVMInt8TypeInContext(lc), 0),
                       LP_MAX_TEXTURE_LEVELS);
      elem_types[LP_JIT_TEXTURE_MIN_LOD] =
      elem_types[LP_JIT_TEXTURE_MAX_LOD] =
      elem_types[LP_JIT_TEXTURE_LOD_BIAS] = LLVMFloatTypeInContext(lc);
      elem_types[LP_JIT_TEXTURE_BORDER_COLOR] = 
         LLVMArrayType(LLVMFloatTypeInContext(lc), 4);
a64 5
#if HAVE_LLVM >= 0x0300
   texture_type = LLVMStructCreateNamed(gallivm->context, "texture");
   LLVMStructSetBody(texture_type, elem_types,
                     Elements(elem_types), 0);
#else
d67 1
d88 3
d97 1
a97 1
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, data,
d99 23
a121 2
                             LP_JIT_TEXTURE_DATA);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, min_lod,
d123 2
a124 2
                             LP_JIT_TEXTURE_MIN_LOD);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, max_lod,
d126 2
a127 2
                             LP_JIT_TEXTURE_MAX_LOD);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, lod_bias,
d129 2
a130 2
                             LP_JIT_TEXTURE_LOD_BIAS);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, border_color,
d132 3
a134 4
                             LP_JIT_TEXTURE_BORDER_COLOR);

      LP_CHECK_STRUCT_SIZE(struct lp_jit_texture,
                           gallivm->target, texture_type);
d142 2
a143 1
      elem_types[LP_JIT_CTX_CONSTANTS] = LLVMPointerType(LLVMFloatTypeInContext(lc), 0);
d147 2
a148 1
      elem_types[LP_JIT_CTX_BLEND_COLOR] = LLVMPointerType(LLVMInt8TypeInContext(lc), 0);
d150 2
a153 5
#if HAVE_LLVM >= 0x0300
   context_type = LLVMStructCreateNamed(gallivm->context, "context");
   LLVMStructSetBody(context_type, elem_types,
                     Elements(elem_types), 0);
#else
d157 1
d175 1
a175 1
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, blend_color,
d177 4
a180 1
                             LP_JIT_CTX_BLEND_COLOR);
d184 3
d193 19
d232 2
a233 2
LLVMTypeRef
lp_jit_get_context_type(struct llvmpipe_context *lp)
a236 2

   return lp->jit_context_ptr_type;
@


1.3
log
@Lets gallium a chance to build with our llvm port
@
text
@a38 1
#include "gallivm/lp_bld_intr.h"
a39 1
#include "lp_screen.h"
d57 1
d92 3
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d72 5
d79 1
d82 1
a119 2

      LLVMAddTypeName(gallivm->module, "texture", texture_type);
d135 5
d145 3
a167 2

      LLVMAddTypeName(gallivm->module, "context", context_type);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a35 2
#include <llvm-c/Transforms/Scalar.h>

a36 1
#include "util/u_cpu_detect.h"
d38 3
a40 1
#include "lp_debug.h"
a41 1
#include "gallivm/lp_bld_intr.h"
d46 1
a46 1
lp_jit_init_globals(struct llvmpipe_screen *screen)
d48 2
d54 1
a54 1
      LLVMTypeRef elem_types[6];
d56 15
a70 6
      elem_types[LP_JIT_TEXTURE_WIDTH]  = LLVMInt32Type();
      elem_types[LP_JIT_TEXTURE_HEIGHT] = LLVMInt32Type();
      elem_types[LP_JIT_TEXTURE_DEPTH] = LLVMInt32Type();
      elem_types[LP_JIT_TEXTURE_LAST_LEVEL] = LLVMInt32Type();
      elem_types[LP_JIT_TEXTURE_STRIDE] = LLVMInt32Type();
      elem_types[LP_JIT_TEXTURE_DATA]   = LLVMPointerType(LLVMInt8Type(), 0);
d72 4
a75 1
      texture_type = LLVMStructType(elem_types, Elements(elem_types), 0);
d78 1
a78 1
                             screen->target, texture_type,
d81 1
a81 1
                             screen->target, texture_type,
d84 1
a84 1
                             screen->target, texture_type,
d87 1
a87 1
                             screen->target, texture_type,
d89 6
a94 3
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, stride,
                             screen->target, texture_type,
                             LP_JIT_TEXTURE_STRIDE);
d96 1
a96 1
                             screen->target, texture_type,
d98 13
d112 1
a112 1
                           screen->target, texture_type);
d114 1
a114 1
      LLVMAddTypeName(screen->module, "texture", texture_type);
d119 1
a119 1
      LLVMTypeRef elem_types[8];
d122 7
a128 7
      elem_types[0] = LLVMPointerType(LLVMFloatType(), 0); /* constants */
      elem_types[1] = LLVMFloatType();                     /* alpha_ref_value */      elem_types[2] = LLVMFloatType();                     /* scissor_xmin */
      elem_types[3] = LLVMFloatType();                     /* scissor_ymin */
      elem_types[4] = LLVMFloatType();                     /* scissor_xmax */
      elem_types[5] = LLVMFloatType();                     /* scissor_ymax */
      elem_types[6] = LLVMPointerType(LLVMInt8Type(), 0);  /* blend_color */
      elem_types[7] = LLVMArrayType(texture_type, PIPE_MAX_SAMPLERS); /* textures */
d130 4
a133 1
      context_type = LLVMStructType(elem_types, Elements(elem_types), 0);
d136 2
a137 1
                             screen->target, context_type, 0);
d139 8
a146 9
                             screen->target, context_type, 1);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, scissor_xmin,
                             screen->target, context_type, 2);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, scissor_ymin,
                             screen->target, context_type, 3);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, scissor_xmax,
                             screen->target, context_type, 4);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, scissor_ymax,
                             screen->target, context_type, 5);
d148 2
a149 1
                             screen->target, context_type, 6);
d151 2
a152 2
                             screen->target, context_type,
                             LP_JIT_CONTEXT_TEXTURES_INDEX);
d154 1
a154 1
                           screen->target, context_type);
d156 1
a156 1
      LLVMAddTypeName(screen->module, "context", context_type);
d158 1
a158 1
      screen->context_ptr_type = LLVMPointerType(context_type, 0);
d161 3
a163 3
#ifdef DEBUG
   LLVMDumpModule(screen->module);
#endif
d170 1
a170 5
   if(screen->engine)
      LLVMDisposeExecutionEngine(screen->engine);

   if(screen->pass)
      LLVMDisposePassManager(screen->pass);
a176 11
   char *error = NULL;

   util_cpu_detect();

#if 0
   /* For simulating less capable machines */
   util_cpu_caps.has_sse3 = 0;
   util_cpu_caps.has_ssse3 = 0;
   util_cpu_caps.has_sse4_1 = 0;
#endif

d178 1
a179 1
   screen->module = LLVMModuleCreateWithName("llvmpipe");
d181 5
a185 29
   screen->provider = LLVMCreateModuleProviderForExistingModule(screen->module);

   if (LLVMCreateJITCompiler(&screen->engine, screen->provider, 1, &error)) {
      _debug_printf("%s\n", error);
      LLVMDisposeMessage(error);
      assert(0);
   }

   screen->target = LLVMGetExecutionEngineTargetData(screen->engine);

   screen->pass = LLVMCreateFunctionPassManager(screen->provider);
   LLVMAddTargetData(screen->target, screen->pass);

   if ((LP_DEBUG & DEBUG_NO_LLVM_OPT) == 0) {
      /* These are the passes currently listed in llvm-c/Transforms/Scalar.h,
       * but there are more on SVN. */
      /* TODO: Add more passes */
      LLVMAddConstantPropagationPass(screen->pass);
      if(util_cpu_caps.has_sse4_1) {
         /* FIXME: There is a bug in this pass, whereby the combination of fptosi
          * and sitofp (necessary for trunc/floor/ceil/round implementation)
          * somehow becomes invalid code.
          */
         LLVMAddInstructionCombiningPass(screen->pass);
      }
      LLVMAddPromoteMemoryToRegisterPass(screen->pass);
      LLVMAddGVNPass(screen->pass);
      LLVMAddCFGSimplificationPass(screen->pass);
   }
d187 1
a187 1
   lp_jit_init_globals(screen);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d36 2
d39 1
d41 2
a42 1
#include "gallivm/lp_bld_debug.h"
a43 2
#include "lp_context.h"
#include "lp_screen.h"
d48 1
a48 1
lp_jit_create_types(struct llvmpipe_context *lp)
a49 2
   struct gallivm_state *gallivm = lp->gallivm;
   LLVMContextRef lc = gallivm->context;
d54 1
a54 1
      LLVMTypeRef elem_types[LP_JIT_TEXTURE_NUM_FIELDS];
d56 6
a61 15
      elem_types[LP_JIT_TEXTURE_WIDTH]  =
      elem_types[LP_JIT_TEXTURE_HEIGHT] =
      elem_types[LP_JIT_TEXTURE_DEPTH] =
      elem_types[LP_JIT_TEXTURE_LAST_LEVEL] =  LLVMInt32TypeInContext(lc);
      elem_types[LP_JIT_TEXTURE_ROW_STRIDE] =
      elem_types[LP_JIT_TEXTURE_IMG_STRIDE] =
         LLVMArrayType(LLVMInt32TypeInContext(lc), LP_MAX_TEXTURE_LEVELS);
      elem_types[LP_JIT_TEXTURE_DATA] =
         LLVMArrayType(LLVMPointerType(LLVMInt8TypeInContext(lc), 0),
                       LP_MAX_TEXTURE_LEVELS);
      elem_types[LP_JIT_TEXTURE_MIN_LOD] =
      elem_types[LP_JIT_TEXTURE_MAX_LOD] =
      elem_types[LP_JIT_TEXTURE_LOD_BIAS] = LLVMFloatTypeInContext(lc);
      elem_types[LP_JIT_TEXTURE_BORDER_COLOR] = 
         LLVMArrayType(LLVMFloatTypeInContext(lc), 4);
d63 1
a63 4
      texture_type = LLVMStructTypeInContext(lc, elem_types,
                                             Elements(elem_types), 0);

      LLVMInvalidateStructLayout(gallivm->target, texture_type);
d66 1
a66 1
                             gallivm->target, texture_type,
d69 1
a69 1
                             gallivm->target, texture_type,
d72 1
a72 1
                             gallivm->target, texture_type,
d75 1
a75 1
                             gallivm->target, texture_type,
d77 3
a79 6
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, row_stride,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_ROW_STRIDE);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, img_stride,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_IMG_STRIDE);
d81 1
a81 1
                             gallivm->target, texture_type,
a82 13
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, min_lod,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_MIN_LOD);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, max_lod,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_MAX_LOD);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, lod_bias,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_LOD_BIAS);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, border_color,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_BORDER_COLOR);

d84 1
a84 1
                           gallivm->target, texture_type);
d86 1
a86 1
      LLVMAddTypeName(gallivm->module, "texture", texture_type);
d91 1
a91 1
      LLVMTypeRef elem_types[LP_JIT_CTX_COUNT];
d94 7
a100 7
      elem_types[LP_JIT_CTX_CONSTANTS] = LLVMPointerType(LLVMFloatTypeInContext(lc), 0);
      elem_types[LP_JIT_CTX_ALPHA_REF] = LLVMFloatTypeInContext(lc);
      elem_types[LP_JIT_CTX_STENCIL_REF_FRONT] =
      elem_types[LP_JIT_CTX_STENCIL_REF_BACK] = LLVMInt32TypeInContext(lc);
      elem_types[LP_JIT_CTX_BLEND_COLOR] = LLVMPointerType(LLVMInt8TypeInContext(lc), 0);
      elem_types[LP_JIT_CTX_TEXTURES] = LLVMArrayType(texture_type,
                                                      PIPE_MAX_SAMPLERS);
d102 1
a102 4
      context_type = LLVMStructTypeInContext(lc, elem_types,
                                             Elements(elem_types), 0);

      LLVMInvalidateStructLayout(gallivm->target, context_type);
d105 1
a105 2
                             gallivm->target, context_type,
                             LP_JIT_CTX_CONSTANTS);
d107 9
a115 8
                             gallivm->target, context_type,
                             LP_JIT_CTX_ALPHA_REF);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, stencil_ref_front,
                             gallivm->target, context_type,
                             LP_JIT_CTX_STENCIL_REF_FRONT);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, stencil_ref_back,
                             gallivm->target, context_type,
                             LP_JIT_CTX_STENCIL_REF_BACK);
d117 1
a117 2
                             gallivm->target, context_type,
                             LP_JIT_CTX_BLEND_COLOR);
d119 2
a120 2
                             gallivm->target, context_type,
                             LP_JIT_CTX_TEXTURES);
d122 1
a122 1
                           gallivm->target, context_type);
d124 1
a124 1
      LLVMAddTypeName(gallivm->module, "context", context_type);
d126 1
a126 1
      lp->jit_context_ptr_type = LLVMPointerType(context_type, 0);
d129 3
a131 3
   if (gallivm_debug & GALLIVM_DEBUG_IR) {
      LLVMDumpModule(gallivm->module);
   }
d138 5
a142 1
   /* nothing */
d149 11
a160 1
}
d162 14
d177 16
a192 5
LLVMTypeRef
lp_jit_get_context_type(struct llvmpipe_context *lp)
{
   if (!lp->jit_context_ptr_type)
      lp_jit_create_types(lp);
d194 1
a194 1
   return lp->jit_context_ptr_type;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d39 1
d41 1
d46 1
a46 1
lp_jit_create_types(struct lp_fragment_shader_variant *lp)
d50 1
a50 1
   LLVMTypeRef texture_type, sampler_type;
d59 1
a59 3
      elem_types[LP_JIT_TEXTURE_FIRST_LEVEL] =
      elem_types[LP_JIT_TEXTURE_LAST_LEVEL] = LLVMInt32TypeInContext(lc);
      elem_types[LP_JIT_TEXTURE_BASE] = LLVMPointerType(LLVMInt8TypeInContext(lc), 0);
a61 1
      elem_types[LP_JIT_TEXTURE_MIP_OFFSETS] =
d63 8
a73 2
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "texture", texture_type);
a75 1
#endif
a85 3
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, first_level,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_FIRST_LEVEL);
a88 3
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, base,
                             gallivm->target, texture_type,
                             LP_JIT_TEXTURE_BASE);
d95 4
a98 1
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, mip_offsets,
d100 11
a110 1
                             LP_JIT_TEXTURE_MIP_OFFSETS);
a112 1
   }
a113 12
   {
   /* struct lp_jit_sampler */
      LLVMTypeRef elem_types[LP_JIT_SAMPLER_NUM_FIELDS];
      elem_types[LP_JIT_SAMPLER_MIN_LOD] =
      elem_types[LP_JIT_SAMPLER_MAX_LOD] =
      elem_types[LP_JIT_SAMPLER_LOD_BIAS] = LLVMFloatTypeInContext(lc);
      elem_types[LP_JIT_SAMPLER_BORDER_COLOR] =
         LLVMArrayType(LLVMFloatTypeInContext(lc), 4);

      sampler_type = LLVMStructTypeInContext(lc, elem_types,
                                             Elements(elem_types), 0);
#if HAVE_LLVM < 0x0300
a114 18

      LLVMInvalidateStructLayout(gallivm->target, texture_type);
#endif

      LP_CHECK_MEMBER_OFFSET(struct lp_jit_sampler, min_lod,
                             gallivm->target, texture_type,
                             LP_JIT_SAMPLER_MIN_LOD);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_sampler, max_lod,
                             gallivm->target, texture_type,
                             LP_JIT_SAMPLER_MAX_LOD);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_sampler, lod_bias,
                             gallivm->target, texture_type,
                             LP_JIT_SAMPLER_LOD_BIAS);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_sampler, border_color,
                             gallivm->target, texture_type,
                             LP_JIT_SAMPLER_BORDER_COLOR);
      LP_CHECK_STRUCT_SIZE(struct lp_jit_sampler,
                           gallivm->target, sampler_type);
d122 1
a122 2
      elem_types[LP_JIT_CTX_CONSTANTS] =
            LLVMArrayType(LLVMPointerType(LLVMFloatTypeInContext(lc), 0), LP_MAX_TGSI_CONST_BUFFERS);
d126 1
a126 2
      elem_types[LP_JIT_CTX_U8_BLEND_COLOR] = LLVMPointerType(LLVMInt8TypeInContext(lc), 0);
      elem_types[LP_JIT_CTX_F_BLEND_COLOR] = LLVMPointerType(LLVMFloatTypeInContext(lc), 0);
a127 2
                                                      PIPE_MAX_SHADER_SAMPLER_VIEWS);
      elem_types[LP_JIT_CTX_SAMPLERS] = LLVMArrayType(sampler_type,
a132 1
#if HAVE_LLVM < 0x0300
a134 3
      LLVMAddTypeName(gallivm->module, "context", context_type);
#endif

d147 1
a147 4
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, u8_blend_color,
                             gallivm->target, context_type,
                             LP_JIT_CTX_U8_BLEND_COLOR);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, f_blend_color,
d149 1
a149 1
                             LP_JIT_CTX_F_BLEND_COLOR);
a152 3
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, samplers,
                             gallivm->target, context_type,
                             LP_JIT_CTX_SAMPLERS);
d156 2
a160 19
   /* struct lp_jit_thread_data */
   {
      LLVMTypeRef elem_types[LP_JIT_THREAD_DATA_COUNT];
      LLVMTypeRef thread_data_type;

      elem_types[LP_JIT_THREAD_DATA_COUNTER] = LLVMInt64TypeInContext(lc);

      thread_data_type = LLVMStructTypeInContext(lc, elem_types,
                                                 Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
      LLVMInvalidateStructLayout(gallivm->target, thread_data_type);

      LLVMAddTypeName(gallivm->module, "thread_data", thread_data_type);
#endif

      lp->jit_thread_data_ptr_type = LLVMPointerType(thread_data_type, 0);
   }

d181 2
a182 2
void
lp_jit_init_types(struct lp_fragment_shader_variant *lp)
d186 2
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d48 1
a48 27
   LLVMTypeRef viewport_type, texture_type, sampler_type;

   /* struct lp_jit_viewport */
   {
      LLVMTypeRef elem_types[LP_JIT_VIEWPORT_NUM_FIELDS];

      elem_types[LP_JIT_VIEWPORT_MIN_DEPTH] =
      elem_types[LP_JIT_VIEWPORT_MAX_DEPTH] = LLVMFloatTypeInContext(lc);

      viewport_type = LLVMStructTypeInContext(lc, elem_types,
                                              Elements(elem_types), 0);

#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "viewport", viewport_type);

      LLVMInvalidateStructLayout(gallivm->target, viewport_type);
#endif

      LP_CHECK_MEMBER_OFFSET(struct lp_jit_viewport, min_depth,
                             gallivm->target, viewport_type,
                             LP_JIT_VIEWPORT_MIN_DEPTH);
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_viewport, max_depth,
                             gallivm->target, viewport_type,
                             LP_JIT_VIEWPORT_MAX_DEPTH);
      LP_CHECK_STRUCT_SIZE(struct lp_jit_viewport,
                           gallivm->target, viewport_type);
   }
d104 1
a105 1
   {
d116 1
a116 1
      LLVMAddTypeName(gallivm->module, "sampler", sampler_type);
d118 1
a118 1
      LLVMInvalidateStructLayout(gallivm->target, sampler_type);
d122 1
a122 1
                             gallivm->target, sampler_type,
d125 1
a125 1
                             gallivm->target, sampler_type,
d128 1
a128 1
                             gallivm->target, sampler_type,
d131 1
a131 1
                             gallivm->target, sampler_type,
d143 1
a143 3
         LLVMArrayType(LLVMPointerType(LLVMFloatTypeInContext(lc), 0), LP_MAX_TGSI_CONST_BUFFERS);
      elem_types[LP_JIT_CTX_NUM_CONSTANTS] =
            LLVMArrayType(LLVMInt32TypeInContext(lc), LP_MAX_TGSI_CONST_BUFFERS);
a148 1
      elem_types[LP_JIT_CTX_VIEWPORTS] = LLVMPointerType(viewport_type, 0);
a165 3
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, num_constants,
                             gallivm->target, context_type,
                             LP_JIT_CTX_NUM_CONSTANTS);
a180 3
      LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, viewports,
                             gallivm->target, context_type,
                             LP_JIT_CTX_VIEWPORTS);
a198 2
      elem_types[LP_JIT_THREAD_DATA_RASTER_STATE_VIEWPORT_INDEX] =
            LLVMInt32TypeInContext(lc);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d60 6
d93 5
d141 5
d186 6
d240 6
d262 1
a262 1
boolean
d265 1
a265 1
   return lp_build_init();
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a59 6
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "viewport", viewport_type);

      LLVMInvalidateStructLayout(gallivm->target, viewport_type);
#endif

a86 5
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "texture", texture_type);

      LLVMInvalidateStructLayout(gallivm->target, texture_type);
#endif
a129 5
#if HAVE_LLVM < 0x0300
      LLVMAddTypeName(gallivm->module, "sampler", sampler_type);

      LLVMInvalidateStructLayout(gallivm->target, sampler_type);
#endif
a169 6
#if HAVE_LLVM < 0x0300
      LLVMInvalidateStructLayout(gallivm->target, context_type);

      LLVMAddTypeName(gallivm->module, "context", context_type);
#endif

a217 6
#if HAVE_LLVM < 0x0300
      LLVMInvalidateStructLayout(gallivm->target, thread_data_type);

      LLVMAddTypeName(gallivm->module, "thread_data", thread_data_type);
#endif

d234 1
a234 1
void
d237 1
a237 1
   lp_build_init();
@


