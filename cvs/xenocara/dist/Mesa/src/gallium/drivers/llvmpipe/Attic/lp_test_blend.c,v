head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.31;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.52;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2013.09.05.14.00.35;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.07.31;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.44.40;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * @@file
 * Unit tests for blend LLVM IR generation
 *
 * @@author Jose Fonseca <jfonseca@@vmware.com>
 *
 * Blend computation code derived from code written by
 * @@author Brian Paul <brian@@vmware.com>
 */

#include "util/u_memory.h"

#include "gallivm/lp_bld_init.h"
#include "gallivm/lp_bld_type.h"
#include "gallivm/lp_bld_debug.h"
#include "lp_bld_blend.h"
#include "lp_test.h"


typedef void (*blend_test_ptr_t)(const void *src, const void *src1,
                                 const void *dst, const void *con, void *res);


void
write_tsv_header(FILE *fp)
{
   fprintf(fp,
           "result\t"
           "cycles_per_channel\t"
           "type\t"
           "sep_func\t"
           "sep_src_factor\t"
           "sep_dst_factor\t"
           "rgb_func\t"
           "rgb_src_factor\t"
           "rgb_dst_factor\t"
           "alpha_func\t"
           "alpha_src_factor\t"
           "alpha_dst_factor\n");

   fflush(fp);
}


static void
write_tsv_row(FILE *fp,
              const struct pipe_blend_state *blend,
              struct lp_type type,
              double cycles,
              boolean success)
{
   fprintf(fp, "%s\t", success ? "pass" : "fail");

   fprintf(fp, "%.1f\t", cycles / type.length);

   fprintf(fp, "%s%u%sx%u\t",
           type.floating ? "f" : (type.fixed ? "h" : (type.sign ? "s" : "u")),
           type.width,
           type.norm ? "n" : "",
           type.length);

   fprintf(fp,
           "%s\t%s\t%s\t",
           blend->rt[0].rgb_func != blend->rt[0].alpha_func ? "true" : "false",
           blend->rt[0].rgb_src_factor != blend->rt[0].alpha_src_factor ? "true" : "false",
           blend->rt[0].rgb_dst_factor != blend->rt[0].alpha_dst_factor ? "true" : "false");

   fprintf(fp,
           "%s\t%s\t%s\t%s\t%s\t%s\n",
           util_dump_blend_func(blend->rt[0].rgb_func, TRUE),
           util_dump_blend_factor(blend->rt[0].rgb_src_factor, TRUE),
           util_dump_blend_factor(blend->rt[0].rgb_dst_factor, TRUE),
           util_dump_blend_func(blend->rt[0].alpha_func, TRUE),
           util_dump_blend_factor(blend->rt[0].alpha_src_factor, TRUE),
           util_dump_blend_factor(blend->rt[0].alpha_dst_factor, TRUE));

   fflush(fp);
}


static void
dump_blend_type(FILE *fp,
                const struct pipe_blend_state *blend,
                struct lp_type type)
{
   fprintf(fp, " type=%s%u%sx%u",
           type.floating ? "f" : (type.fixed ? "h" : (type.sign ? "s" : "u")),
           type.width,
           type.norm ? "n" : "",
           type.length);

   fprintf(fp,
           " %s=%s %s=%s %s=%s %s=%s %s=%s %s=%s",
           "rgb_func",         util_dump_blend_func(blend->rt[0].rgb_func, TRUE),
           "rgb_src_factor",   util_dump_blend_factor(blend->rt[0].rgb_src_factor, TRUE),
           "rgb_dst_factor",   util_dump_blend_factor(blend->rt[0].rgb_dst_factor, TRUE),
           "alpha_func",       util_dump_blend_func(blend->rt[0].alpha_func, TRUE),
           "alpha_src_factor", util_dump_blend_factor(blend->rt[0].alpha_src_factor, TRUE),
           "alpha_dst_factor", util_dump_blend_factor(blend->rt[0].alpha_dst_factor, TRUE));

   fprintf(fp, " ...\n");
   fflush(fp);
}


static LLVMValueRef
add_blend_test(struct gallivm_state *gallivm,
               const struct pipe_blend_state *blend,
               struct lp_type type)
{
   LLVMModuleRef module = gallivm->module;
   LLVMContextRef context = gallivm->context;
   LLVMTypeRef vec_type;
   LLVMTypeRef args[5];
   LLVMValueRef func;
   LLVMValueRef src_ptr;
   LLVMValueRef src1_ptr;
   LLVMValueRef dst_ptr;
   LLVMValueRef const_ptr;
   LLVMValueRef res_ptr;
   LLVMBasicBlockRef block;
   LLVMBuilderRef builder;
   const enum pipe_format format = PIPE_FORMAT_R8G8B8A8_UNORM;
   const unsigned rt = 0;
   const unsigned char swizzle[4] = { 0, 1, 2, 3 };
   LLVMValueRef src;
   LLVMValueRef src1;
   LLVMValueRef dst;
   LLVMValueRef con;
   LLVMValueRef res;

   vec_type = lp_build_vec_type(gallivm, type);

   args[4] = args[3] = args[2] = args[1] = args[0] = LLVMPointerType(vec_type, 0);
   func = LLVMAddFunction(module, "test", LLVMFunctionType(LLVMVoidTypeInContext(context), args, 5, 0));
   LLVMSetFunctionCallConv(func, LLVMCCallConv);
   src_ptr = LLVMGetParam(func, 0);
   src1_ptr = LLVMGetParam(func, 1);
   dst_ptr = LLVMGetParam(func, 2);
   const_ptr = LLVMGetParam(func, 3);
   res_ptr = LLVMGetParam(func, 4);

   block = LLVMAppendBasicBlockInContext(context, func, "entry");
   builder = gallivm->builder;
   LLVMPositionBuilderAtEnd(builder, block);

   src = LLVMBuildLoad(builder, src_ptr, "src");
   src1 = LLVMBuildLoad(builder, src1_ptr, "src1");
   dst = LLVMBuildLoad(builder, dst_ptr, "dst");
   con = LLVMBuildLoad(builder, const_ptr, "const");

   res = lp_build_blend_aos(gallivm, blend, format, type, rt, src, NULL,
                            src1, NULL, dst, NULL, con, NULL, swizzle, 4);

   lp_build_name(res, "res");

   LLVMBuildStore(builder, res, res_ptr);

   LLVMBuildRetVoid(builder);;

   gallivm_verify_function(gallivm, func);

   return func;
}


static void
compute_blend_ref_term(unsigned rgb_factor,
                       unsigned alpha_factor,
                       const double *factor,
                       const double *src,
                       const double *src1,
                       const double *dst,
                       const double *con,
                       double *term)
{
   double temp;

   switch (rgb_factor) {
   case PIPE_BLENDFACTOR_ONE:
      term[0] = factor[0]; /* R */
      term[1] = factor[1]; /* G */
      term[2] = factor[2]; /* B */
      break;
   case PIPE_BLENDFACTOR_SRC_COLOR:
      term[0] = factor[0] * src[0]; /* R */
      term[1] = factor[1] * src[1]; /* G */
      term[2] = factor[2] * src[2]; /* B */
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA:
      term[0] = factor[0] * src[3]; /* R */
      term[1] = factor[1] * src[3]; /* G */
      term[2] = factor[2] * src[3]; /* B */
      break;
   case PIPE_BLENDFACTOR_DST_COLOR:
      term[0] = factor[0] * dst[0]; /* R */
      term[1] = factor[1] * dst[1]; /* G */
      term[2] = factor[2] * dst[2]; /* B */
      break;
   case PIPE_BLENDFACTOR_DST_ALPHA:
      term[0] = factor[0] * dst[3]; /* R */
      term[1] = factor[1] * dst[3]; /* G */
      term[2] = factor[2] * dst[3]; /* B */
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
      temp = MIN2(src[3], 1.0f - dst[3]);
      term[0] = factor[0] * temp; /* R */
      term[1] = factor[1] * temp; /* G */
      term[2] = factor[2] * temp; /* B */
      break;
   case PIPE_BLENDFACTOR_CONST_COLOR:
      term[0] = factor[0] * con[0]; /* R */
      term[1] = factor[1] * con[1]; /* G */
      term[2] = factor[2] * con[2]; /* B */
      break;
   case PIPE_BLENDFACTOR_CONST_ALPHA:
      term[0] = factor[0] * con[3]; /* R */
      term[1] = factor[1] * con[3]; /* G */
      term[2] = factor[2] * con[3]; /* B */
      break;
   case PIPE_BLENDFACTOR_SRC1_COLOR:
      term[0] = factor[0] * src1[0]; /* R */
      term[1] = factor[1] * src1[1]; /* G */
      term[2] = factor[2] * src1[2]; /* B */
      break;
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      term[0] = factor[0] * src1[3]; /* R */
      term[1] = factor[1] * src1[3]; /* G */
      term[2] = factor[2] * src1[3]; /* B */
      break;
   case PIPE_BLENDFACTOR_ZERO:
      term[0] = 0.0f; /* R */
      term[1] = 0.0f; /* G */
      term[2] = 0.0f; /* B */
      break;
   case PIPE_BLENDFACTOR_INV_SRC_COLOR:
      term[0] = factor[0] * (1.0f - src[0]); /* R */
      term[1] = factor[1] * (1.0f - src[1]); /* G */
      term[2] = factor[2] * (1.0f - src[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_INV_SRC_ALPHA:
      term[0] = factor[0] * (1.0f - src[3]); /* R */
      term[1] = factor[1] * (1.0f - src[3]); /* G */
      term[2] = factor[2] * (1.0f - src[3]); /* B */
      break;
   case PIPE_BLENDFACTOR_INV_DST_ALPHA:
      term[0] = factor[0] * (1.0f - dst[3]); /* R */
      term[1] = factor[1] * (1.0f - dst[3]); /* G */
      term[2] = factor[2] * (1.0f - dst[3]); /* B */
      break;
   case PIPE_BLENDFACTOR_INV_DST_COLOR:
      term[0] = factor[0] * (1.0f - dst[0]); /* R */
      term[1] = factor[1] * (1.0f - dst[1]); /* G */
      term[2] = factor[2] * (1.0f - dst[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_INV_CONST_COLOR:
      term[0] = factor[0] * (1.0f - con[0]); /* R */
      term[1] = factor[1] * (1.0f - con[1]); /* G */
      term[2] = factor[2] * (1.0f - con[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_INV_CONST_ALPHA:
      term[0] = factor[0] * (1.0f - con[3]); /* R */
      term[1] = factor[1] * (1.0f - con[3]); /* G */
      term[2] = factor[2] * (1.0f - con[3]); /* B */
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
      term[0] = factor[0] * (1.0f - src1[0]); /* R */
      term[1] = factor[1] * (1.0f - src1[1]); /* G */
      term[2] = factor[2] * (1.0f - src1[2]); /* B */
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      term[0] = factor[0] * (1.0f - src1[3]); /* R */
      term[1] = factor[1] * (1.0f - src1[3]); /* G */
      term[2] = factor[2] * (1.0f - src1[3]); /* B */
      break;
   default:
      assert(0);
   }

   /*
    * Compute src/first term A
    */
   switch (alpha_factor) {
   case PIPE_BLENDFACTOR_ONE:
      term[3] = factor[3]; /* A */
      break;
   case PIPE_BLENDFACTOR_SRC_COLOR:
   case PIPE_BLENDFACTOR_SRC_ALPHA:
      term[3] = factor[3] * src[3]; /* A */
      break;
   case PIPE_BLENDFACTOR_DST_COLOR:
   case PIPE_BLENDFACTOR_DST_ALPHA:
      term[3] = factor[3] * dst[3]; /* A */
      break;
   case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
      term[3] = src[3]; /* A */
      break;
   case PIPE_BLENDFACTOR_CONST_COLOR:
   case PIPE_BLENDFACTOR_CONST_ALPHA:
      term[3] = factor[3] * con[3]; /* A */
      break;
   case PIPE_BLENDFACTOR_SRC1_COLOR:
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      term[3] = factor[3] * src1[3]; /* A */
      break;
   case PIPE_BLENDFACTOR_ZERO:
      term[3] = 0.0f; /* A */
      break;
   case PIPE_BLENDFACTOR_INV_SRC_COLOR:
   case PIPE_BLENDFACTOR_INV_SRC_ALPHA:
      term[3] = factor[3] * (1.0f - src[3]); /* A */
      break;
   case PIPE_BLENDFACTOR_INV_DST_COLOR:
   case PIPE_BLENDFACTOR_INV_DST_ALPHA:
      term[3] = factor[3] * (1.0f - dst[3]); /* A */
      break;
   case PIPE_BLENDFACTOR_INV_CONST_COLOR:
   case PIPE_BLENDFACTOR_INV_CONST_ALPHA:
      term[3] = factor[3] * (1.0f - con[3]);
      break;
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      term[3] = factor[3] * (1.0f - src1[3]); /* A */
      break;
   default:
      assert(0);
   }
}


static void
compute_blend_ref(const struct pipe_blend_state *blend,
                  const double *src,
                  const double *src1,
                  const double *dst,
                  const double *con,
                  double *res)
{
   double src_term[4];
   double dst_term[4];

   compute_blend_ref_term(blend->rt[0].rgb_src_factor, blend->rt[0].alpha_src_factor,
                          src, src, src1, dst, con, src_term);
   compute_blend_ref_term(blend->rt[0].rgb_dst_factor, blend->rt[0].alpha_dst_factor,
                          dst, src, src1, dst, con, dst_term);

   /*
    * Combine RGB terms
    */
   switch (blend->rt[0].rgb_func) {
   case PIPE_BLEND_ADD:
      res[0] = src_term[0] + dst_term[0]; /* R */
      res[1] = src_term[1] + dst_term[1]; /* G */
      res[2] = src_term[2] + dst_term[2]; /* B */
      break;
   case PIPE_BLEND_SUBTRACT:
      res[0] = src_term[0] - dst_term[0]; /* R */
      res[1] = src_term[1] - dst_term[1]; /* G */
      res[2] = src_term[2] - dst_term[2]; /* B */
      break;
   case PIPE_BLEND_REVERSE_SUBTRACT:
      res[0] = dst_term[0] - src_term[0]; /* R */
      res[1] = dst_term[1] - src_term[1]; /* G */
      res[2] = dst_term[2] - src_term[2]; /* B */
      break;
   case PIPE_BLEND_MIN:
      res[0] = MIN2(src_term[0], dst_term[0]); /* R */
      res[1] = MIN2(src_term[1], dst_term[1]); /* G */
      res[2] = MIN2(src_term[2], dst_term[2]); /* B */
      break;
   case PIPE_BLEND_MAX:
      res[0] = MAX2(src_term[0], dst_term[0]); /* R */
      res[1] = MAX2(src_term[1], dst_term[1]); /* G */
      res[2] = MAX2(src_term[2], dst_term[2]); /* B */
      break;
   default:
      assert(0);
   }

   /*
    * Combine A terms
    */
   switch (blend->rt[0].alpha_func) {
   case PIPE_BLEND_ADD:
      res[3] = src_term[3] + dst_term[3]; /* A */
      break;
   case PIPE_BLEND_SUBTRACT:
      res[3] = src_term[3] - dst_term[3]; /* A */
      break;
   case PIPE_BLEND_REVERSE_SUBTRACT:
      res[3] = dst_term[3] - src_term[3]; /* A */
      break;
   case PIPE_BLEND_MIN:
      res[3] = MIN2(src_term[3], dst_term[3]); /* A */
      break;
   case PIPE_BLEND_MAX:
      res[3] = MAX2(src_term[3], dst_term[3]); /* A */
      break;
   default:
      assert(0);
   }
}


PIPE_ALIGN_STACK
static boolean
test_one(unsigned verbose,
         FILE *fp,
         const struct pipe_blend_state *blend,
         struct lp_type type)
{
   struct gallivm_state *gallivm;
   LLVMValueRef func = NULL;
   blend_test_ptr_t blend_test_ptr;
   boolean success;
   const unsigned n = LP_TEST_NUM_SAMPLES;
   int64_t cycles[LP_TEST_NUM_SAMPLES];
   double cycles_avg = 0.0;
   unsigned i, j;
   const unsigned stride = lp_type_width(type)/8;

   if(verbose >= 1)
      dump_blend_type(stdout, blend, type);

   gallivm = gallivm_create();

   func = add_blend_test(gallivm, blend, type);

   gallivm_compile_module(gallivm);

   blend_test_ptr = (blend_test_ptr_t)gallivm_jit_function(gallivm, func);

   success = TRUE;

   {
      uint8_t *src, *src1, *dst, *con, *res, *ref;
      src = align_malloc(stride, stride);
      src1 = align_malloc(stride, stride);
      dst = align_malloc(stride, stride);
      con = align_malloc(stride, stride);
      res = align_malloc(stride, stride);
      ref = align_malloc(stride, stride);

      for(i = 0; i < n && success; ++i) {
         int64_t start_counter = 0;
         int64_t end_counter = 0;

         random_vec(type, src);
         random_vec(type, src1);
         random_vec(type, dst);
         random_vec(type, con);

         {
            double fsrc[LP_MAX_VECTOR_LENGTH];
            double fsrc1[LP_MAX_VECTOR_LENGTH];
            double fdst[LP_MAX_VECTOR_LENGTH];
            double fcon[LP_MAX_VECTOR_LENGTH];
            double fref[LP_MAX_VECTOR_LENGTH];

            read_vec(type, src, fsrc);
            read_vec(type, src1, fsrc1);
            read_vec(type, dst, fdst);
            read_vec(type, con, fcon);

            for(j = 0; j < type.length; j += 4)
               compute_blend_ref(blend, fsrc + j, fsrc1 + j, fdst + j, fcon + j, fref + j);

            write_vec(type, ref, fref);
         }

         start_counter = rdtsc();
         blend_test_ptr(src, src1, dst, con, res);
         end_counter = rdtsc();

         cycles[i] = end_counter - start_counter;

         if(!compare_vec(type, res, ref)) {
            success = FALSE;

            if(verbose < 1)
               dump_blend_type(stderr, blend, type);
            fprintf(stderr, "MISMATCH\n");

            fprintf(stderr, "  Src: ");
            dump_vec(stderr, type, src);
            fprintf(stderr, "\n");

            fprintf(stderr, "  Src1: ");
            dump_vec(stderr, type, src1);
            fprintf(stderr, "\n");

            fprintf(stderr, "  Dst: ");
            dump_vec(stderr, type, dst);
            fprintf(stderr, "\n");

            fprintf(stderr, "  Con: ");
            dump_vec(stderr, type, con);
            fprintf(stderr, "\n");

            fprintf(stderr, "  Res: ");
            dump_vec(stderr, type, res);
            fprintf(stderr, "\n");

            fprintf(stderr, "  Ref: ");
            dump_vec(stderr, type, ref);
            fprintf(stderr, "\n");
         }
      }
      align_free(src);
      align_free(src1);
      align_free(dst);
      align_free(con);
      align_free(res);
      align_free(ref);
   }

   /*
    * Unfortunately the output of cycle counter is not very reliable as it comes
    * -- sometimes we get outliers (due IRQs perhaps?) which are
    * better removed to avoid random or biased data.
    */
   {
      double sum = 0.0, sum2 = 0.0;
      double avg, std;
      unsigned m;

      for(i = 0; i < n; ++i) {
         sum += cycles[i];
         sum2 += cycles[i]*cycles[i];
      }

      avg = sum/n;
      std = sqrtf((sum2 - n*avg*avg)/n);

      m = 0;
      sum = 0.0;
      for(i = 0; i < n; ++i) {
         if(fabs(cycles[i] - avg) <= 4.0*std) {
            sum += cycles[i];
            ++m;
         }
      }

      cycles_avg = sum/m;

   }

   if(fp)
      write_tsv_row(fp, blend, type, cycles_avg, success);

   gallivm_free_function(gallivm, func, blend_test_ptr);

   gallivm_destroy(gallivm);

   return success;
}


const unsigned
blend_factors[] = {
   PIPE_BLENDFACTOR_ZERO,
   PIPE_BLENDFACTOR_ONE,
   PIPE_BLENDFACTOR_SRC_COLOR,
   PIPE_BLENDFACTOR_SRC_ALPHA,
   PIPE_BLENDFACTOR_DST_COLOR,
   PIPE_BLENDFACTOR_DST_ALPHA,
   PIPE_BLENDFACTOR_CONST_COLOR,
   PIPE_BLENDFACTOR_CONST_ALPHA,
   PIPE_BLENDFACTOR_SRC1_COLOR,
   PIPE_BLENDFACTOR_SRC1_ALPHA,
   PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE,
   PIPE_BLENDFACTOR_INV_SRC_COLOR,
   PIPE_BLENDFACTOR_INV_SRC_ALPHA,
   PIPE_BLENDFACTOR_INV_DST_COLOR,
   PIPE_BLENDFACTOR_INV_DST_ALPHA,
   PIPE_BLENDFACTOR_INV_CONST_COLOR,
   PIPE_BLENDFACTOR_INV_CONST_ALPHA,
   PIPE_BLENDFACTOR_INV_SRC1_COLOR,
   PIPE_BLENDFACTOR_INV_SRC1_ALPHA,
};


const unsigned
blend_funcs[] = {
   PIPE_BLEND_ADD,
   PIPE_BLEND_SUBTRACT,
   PIPE_BLEND_REVERSE_SUBTRACT,
   PIPE_BLEND_MIN,
   PIPE_BLEND_MAX
};


const struct lp_type blend_types[] = {
   /* float, fixed,  sign,  norm, width, len */
   {   TRUE, FALSE,  TRUE, FALSE,    32,   4 }, /* f32 x 4 */
   {  FALSE, FALSE, FALSE,  TRUE,     8,  16 }, /* u8n x 16 */
};


const unsigned num_funcs = sizeof(blend_funcs)/sizeof(blend_funcs[0]);
const unsigned num_factors = sizeof(blend_factors)/sizeof(blend_factors[0]);
const unsigned num_types = sizeof(blend_types)/sizeof(blend_types[0]);


boolean
test_all(unsigned verbose, FILE *fp)
{
   const unsigned *rgb_func;
   const unsigned *rgb_src_factor;
   const unsigned *rgb_dst_factor;
   const unsigned *alpha_func;
   const unsigned *alpha_src_factor;
   const unsigned *alpha_dst_factor;
   struct pipe_blend_state blend;
   const struct lp_type *type;
   boolean success = TRUE;

   for(rgb_func = blend_funcs; rgb_func < &blend_funcs[num_funcs]; ++rgb_func) {
      for(alpha_func = blend_funcs; alpha_func < &blend_funcs[num_funcs]; ++alpha_func) {
         for(rgb_src_factor = blend_factors; rgb_src_factor < &blend_factors[num_factors]; ++rgb_src_factor) {
            for(rgb_dst_factor = blend_factors; rgb_dst_factor <= rgb_src_factor; ++rgb_dst_factor) {
               for(alpha_src_factor = blend_factors; alpha_src_factor < &blend_factors[num_factors]; ++alpha_src_factor) {
                  for(alpha_dst_factor = blend_factors; alpha_dst_factor <= alpha_src_factor; ++alpha_dst_factor) {
                     for(type = blend_types; type < &blend_types[num_types]; ++type) {

                        if(*rgb_dst_factor == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE ||
                           *alpha_dst_factor == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE)
                           continue;

                        memset(&blend, 0, sizeof blend);
                        blend.rt[0].blend_enable      = 1;
                        blend.rt[0].rgb_func          = *rgb_func;
                        blend.rt[0].rgb_src_factor    = *rgb_src_factor;
                        blend.rt[0].rgb_dst_factor    = *rgb_dst_factor;
                        blend.rt[0].alpha_func        = *alpha_func;
                        blend.rt[0].alpha_src_factor  = *alpha_src_factor;
                        blend.rt[0].alpha_dst_factor  = *alpha_dst_factor;
                        blend.rt[0].colormask         = PIPE_MASK_RGBA;

                        if(!test_one(verbose, fp, &blend, *type))
                          success = FALSE;

                     }
                  }
               }
            }
         }
      }
   }

   return success;
}


boolean
test_some(unsigned verbose, FILE *fp,
          unsigned long n)
{
   const unsigned *rgb_func;
   const unsigned *rgb_src_factor;
   const unsigned *rgb_dst_factor;
   const unsigned *alpha_func;
   const unsigned *alpha_src_factor;
   const unsigned *alpha_dst_factor;
   struct pipe_blend_state blend;
   const struct lp_type *type;
   unsigned long i;
   boolean success = TRUE;

   for(i = 0; i < n; ++i) {
      rgb_func = &blend_funcs[rand() % num_funcs];
      alpha_func = &blend_funcs[rand() % num_funcs];
      rgb_src_factor = &blend_factors[rand() % num_factors];
      alpha_src_factor = &blend_factors[rand() % num_factors];
      
      do {
         rgb_dst_factor = &blend_factors[rand() % num_factors];
      } while(*rgb_dst_factor == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE);

      do {
         alpha_dst_factor = &blend_factors[rand() % num_factors];
      } while(*alpha_dst_factor == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE);

      type = &blend_types[rand() % num_types];

      memset(&blend, 0, sizeof blend);
      blend.rt[0].blend_enable      = 1;
      blend.rt[0].rgb_func          = *rgb_func;
      blend.rt[0].rgb_src_factor    = *rgb_src_factor;
      blend.rt[0].rgb_dst_factor    = *rgb_dst_factor;
      blend.rt[0].alpha_func        = *alpha_func;
      blend.rt[0].alpha_src_factor  = *alpha_src_factor;
      blend.rt[0].alpha_dst_factor  = *alpha_dst_factor;
      blend.rt[0].colormask         = PIPE_MASK_RGBA;

      if(!test_one(verbose, fp, &blend, *type))
        success = FALSE;
   }

   return success;
}


boolean
test_single(unsigned verbose, FILE *fp)
{
   printf("no test_single()");
   return TRUE;
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d453 1
a453 1
   gallivm = gallivm_create("test_module", LLVMGetGlobalContext());
a460 2
   gallivm_free_ir(gallivm);

d578 2
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d453 1
a453 1
   gallivm = gallivm_create();
d461 2
a579 2

   gallivm_free_function(gallivm, func, blend_test_ptr);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d39 1
d48 2
a49 21
enum vector_mode
{
   AoS = 0,
   SoA = 1
};


typedef void (*blend_test_ptr_t)(const void *src, const void *dst, const void *con, void *res);

/** cast wrapper */
static blend_test_ptr_t
voidptr_to_blend_test_ptr_t(void *p)
{
   union {
      void *v;
      blend_test_ptr_t f;
   } u;
   u.v = p;
   return u.f;
}

a57 1
           "mode\t"
a75 1
              enum vector_mode mode,
d82 1
a82 9
   if (mode == AoS) {
      fprintf(fp, "%.1f\t", cycles / type.length);
      fprintf(fp, "aos\t");
   }

   if (mode == SoA) {
      fprintf(fp, "%.1f\t", cycles / (4 * type.length));
      fprintf(fp, "soa\t");
   }
a111 1
                enum vector_mode mode,
a113 2
   fprintf(fp, "%s", mode ? "soa" : "aos");

a136 1
               enum vector_mode mode,
d142 1
a142 1
   LLVMTypeRef args[4];
d145 1
d151 1
d153 6
d162 2
a163 2
   args[3] = args[2] = args[1] = args[0] = LLVMPointerType(vec_type, 0);
   func = LLVMAddFunction(module, "test", LLVMFunctionType(LLVMVoidTypeInContext(context), args, 4, 0));
d166 4
a169 3
   dst_ptr = LLVMGetParam(func, 1);
   const_ptr = LLVMGetParam(func, 2);
   res_ptr = LLVMGetParam(func, 3);
d175 4
a178 5
   if (mode == AoS) {
      LLVMValueRef src;
      LLVMValueRef dst;
      LLVMValueRef con;
      LLVMValueRef res;
d180 2
a181 3
      src = LLVMBuildLoad(builder, src_ptr, "src");
      dst = LLVMBuildLoad(builder, dst_ptr, "dst");
      con = LLVMBuildLoad(builder, const_ptr, "const");
d183 1
a183 1
      res = lp_build_blend_aos(gallivm, blend, type, rt, src, dst, con, 3);
d185 1
a185 1
      lp_build_name(res, "res");
d187 1
a187 19
      LLVMBuildStore(builder, res, res_ptr);
   }

   if (mode == SoA) {
      LLVMValueRef src[4];
      LLVMValueRef dst[4];
      LLVMValueRef con[4];
      LLVMValueRef res[4];
      unsigned i;

      for(i = 0; i < 4; ++i) {
         LLVMValueRef index = LLVMConstInt(LLVMInt32TypeInContext(context), i, 0);
         src[i] = LLVMBuildLoad(builder, LLVMBuildGEP(builder, src_ptr, &index, 1, ""), "");
         dst[i] = LLVMBuildLoad(builder, LLVMBuildGEP(builder, dst_ptr, &index, 1, ""), "");
         con[i] = LLVMBuildLoad(builder, LLVMBuildGEP(builder, const_ptr, &index, 1, ""), "");
         lp_build_name(src[i], "src.%c", "rgba"[i]);
         lp_build_name(con[i], "con.%c", "rgba"[i]);
         lp_build_name(dst[i], "dst.%c", "rgba"[i]);
      }
d189 1
a189 10
      lp_build_blend_soa(gallivm, blend, type, rt, src, dst, con, res);

      for(i = 0; i < 4; ++i) {
         LLVMValueRef index = LLVMConstInt(LLVMInt32TypeInContext(context), i, 0);
         lp_build_name(res[i], "res.%c", "rgba"[i]);
         LLVMBuildStore(builder, res[i], LLVMBuildGEP(builder, res_ptr, &index, 1, ""));
      }
   }

   LLVMBuildRetVoid(builder);;
d200 1
d250 3
a252 1
      assert(0); /* to do */
d255 3
a257 1
      assert(0); /* to do */
d295 3
a297 1
      assert(0); /* to do */
d300 3
a302 1
      assert(0); /* to do */
d330 4
d349 4
d362 1
d371 1
a371 1
                          src, src, dst, con, src_term);
d373 1
a373 1
                          dst, src, dst, con, dst_term);
d435 1
a435 2
test_one(struct gallivm_state *gallivm,
         unsigned verbose,
a437 1
         enum vector_mode mode,
d440 1
a440 1
   LLVMModuleRef module = gallivm->module;
a441 2
   LLVMExecutionEngineRef engine = gallivm->engine;
   char *error = NULL;
d448 1
a448 1
   void *code;
d451 1
a451 1
      dump_blend_type(stdout, blend, mode, type);
d453 1
a453 1
   func = add_blend_test(gallivm, blend, mode, type);
d455 1
a455 5
   if(LLVMVerifyModule(module, LLVMPrintMessageAction, &error)) {
      LLVMDumpModule(module);
      abort();
   }
   LLVMDisposeMessage(error);
d457 1
a457 2
   code = LLVMGetPointerToGlobal(engine, func);
   blend_test_ptr = voidptr_to_blend_test_ptr_t(code);
d459 1
a459 2
   if(verbose >= 2)
      lp_disassemble(code);
d462 11
a472 7
   for(i = 0; i < n && success; ++i) {
      if(mode == AoS) {
         PIPE_ALIGN_VAR(16) uint8_t src[LP_NATIVE_VECTOR_WIDTH/8];
         PIPE_ALIGN_VAR(16) uint8_t dst[LP_NATIVE_VECTOR_WIDTH/8];
         PIPE_ALIGN_VAR(16) uint8_t con[LP_NATIVE_VECTOR_WIDTH/8];
         PIPE_ALIGN_VAR(16) uint8_t res[LP_NATIVE_VECTOR_WIDTH/8];
         PIPE_ALIGN_VAR(16) uint8_t ref[LP_NATIVE_VECTOR_WIDTH/8];
d477 1
d483 1
d489 1
d494 1
a494 1
               compute_blend_ref(blend, fsrc + j, fdst + j, fcon + j, fref + j);
d500 1
a500 1
         blend_test_ptr(src, dst, con, res);
d509 1
a509 1
               dump_blend_type(stderr, blend, mode, type);
d516 4
d537 6
a542 82

      if(mode == SoA) {
         const unsigned stride = type.length*type.width/8;
         PIPE_ALIGN_VAR(16) uint8_t src[4*LP_NATIVE_VECTOR_WIDTH/8];
         PIPE_ALIGN_VAR(16) uint8_t dst[4*LP_NATIVE_VECTOR_WIDTH/8];
         PIPE_ALIGN_VAR(16) uint8_t con[4*LP_NATIVE_VECTOR_WIDTH/8];
         PIPE_ALIGN_VAR(16) uint8_t res[4*LP_NATIVE_VECTOR_WIDTH/8];
         PIPE_ALIGN_VAR(16) uint8_t ref[4*LP_NATIVE_VECTOR_WIDTH/8];
         int64_t start_counter = 0;
         int64_t end_counter = 0;
         boolean mismatch;

         for(j = 0; j < 4; ++j) {
            random_vec(type, src + j*stride);
            random_vec(type, dst + j*stride);
            random_vec(type, con + j*stride);
         }

         {
            double fsrc[4];
            double fdst[4];
            double fcon[4];
            double fref[4];
            unsigned k;

            for(k = 0; k < type.length; ++k) {
               for(j = 0; j < 4; ++j) {
                  fsrc[j] = read_elem(type, src + j*stride, k);
                  fdst[j] = read_elem(type, dst + j*stride, k);
                  fcon[j] = read_elem(type, con + j*stride, k);
               }

               compute_blend_ref(blend, fsrc, fdst, fcon, fref);

               for(j = 0; j < 4; ++j)
                  write_elem(type, ref + j*stride, k, fref[j]);
            }
         }

         start_counter = rdtsc();
         blend_test_ptr(src, dst, con, res);
         end_counter = rdtsc();

         cycles[i] = end_counter - start_counter;

         mismatch = FALSE;
         for (j = 0; j < 4; ++j)
            if(!compare_vec(type, res + j*stride, ref + j*stride))
               mismatch = TRUE;

         if (mismatch) {
            success = FALSE;

            if(verbose < 1)
               dump_blend_type(stderr, blend, mode, type);
            fprintf(stderr, "MISMATCH\n");
            for(j = 0; j < 4; ++j) {
               char channel = "RGBA"[j];
               fprintf(stderr, "  Src%c: ", channel);
               dump_vec(stderr, type, src + j*stride);
               fprintf(stderr, "\n");

               fprintf(stderr, "  Dst%c: ", channel);
               dump_vec(stderr, type, dst + j*stride);
               fprintf(stderr, "\n");

               fprintf(stderr, "  Con%c: ", channel);
               dump_vec(stderr, type, con + j*stride);
               fprintf(stderr, "\n");

               fprintf(stderr, "  Res%c: ", channel);
               dump_vec(stderr, type, res + j*stride);
               fprintf(stderr, "\n");

               fprintf(stderr, "  Ref%c: ", channel);
               dump_vec(stderr, type, ref + j*stride);
               fprintf(stderr, "\n");

               fprintf(stderr, "\n");
            }
         }
      }
d577 1
a577 1
      write_tsv_row(fp, blend, mode, type, cycles_avg, success);
d579 1
a579 8
   if (!success) {
      if(verbose < 2)
         LLVMDumpModule(module);
      LLVMWriteBitcodeToFile(module, "blend.bc");
      fprintf(stderr, "blend.bc written\n");
      fprintf(stderr, "Invoke as \"llc -o - blend.bc\"\n");
      abort();
   }
d581 1
a581 1
   LLVMFreeMachineCodeForFunction(engine, func);
a596 1
#if 0
a598 1
#endif
a605 1
#if 0
a607 1
#endif
d634 1
a634 1
test_all(struct gallivm_state *gallivm, unsigned verbose, FILE *fp)
a642 1
   enum vector_mode mode;
d652 1
a652 2
                     for(mode = 0; mode < 2; ++mode) {
                        for(type = blend_types; type < &blend_types[num_types]; ++type) {
d654 13
a666 13
                           if(*rgb_dst_factor == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE ||
                              *alpha_dst_factor == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE)
                              continue;

                           memset(&blend, 0, sizeof blend);
                           blend.rt[0].blend_enable      = 1;
                           blend.rt[0].rgb_func          = *rgb_func;
                           blend.rt[0].rgb_src_factor    = *rgb_src_factor;
                           blend.rt[0].rgb_dst_factor    = *rgb_dst_factor;
                           blend.rt[0].alpha_func        = *alpha_func;
                           blend.rt[0].alpha_src_factor  = *alpha_src_factor;
                           blend.rt[0].alpha_dst_factor  = *alpha_dst_factor;
                           blend.rt[0].colormask         = PIPE_MASK_RGBA;
d668 2
a669 2
                           if(!test_one(gallivm, verbose, fp, &blend, mode, *type))
                             success = FALSE;
a670 1
                        }
d684 1
a684 1
test_some(struct gallivm_state *gallivm, unsigned verbose, FILE *fp,
a693 1
   enum vector_mode mode;
a711 2
      mode = rand() & 1;

d724 1
a724 1
      if(!test_one(gallivm, verbose, fp, &blend, mode, *type))
d733 1
a733 1
test_single(struct gallivm_state *gallivm, unsigned verbose, FILE *fp)
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d40 1
a41 1
#include "gallivm/lp_bld_blend.h"
d43 1
d56 13
d166 1
a166 1
add_blend_test(LLVMModuleRef module,
d171 2
a172 1
   LLVMTypeRef ret_type;
d182 1
d184 1
a184 2
   ret_type = LLVMInt64Type();
   vec_type = lp_build_vec_type(type);
d187 1
a187 1
   func = LLVMAddFunction(module, "test", LLVMFunctionType(LLVMVoidType(), args, 4, 0));
d194 2
a195 2
   block = LLVMAppendBasicBlock(func, "entry");
   builder = LLVMCreateBuilder();
d208 1
a208 1
      res = lp_build_blend_aos(builder, blend, type, src, dst, con, 3);
d223 1
a223 1
         LLVMValueRef index = LLVMConstInt(LLVMInt32Type(), i, 0);
d232 1
a232 1
      lp_build_blend_soa(builder, blend, type, src, dst, con, res);
d235 1
a235 1
         LLVMValueRef index = LLVMConstInt(LLVMInt32Type(), i, 0);
a242 1
   LLVMDisposeBuilder(builder);
a246 13
/** Add and limit result to ceiling of 1.0 */
#define ADD_SAT(R, A, B) \
do { \
   R = (A) + (B);  if (R > 1.0f) R = 1.0f; \
} while (0)

/** Subtract and limit result to floor of 0.0 */
#define SUB_SAT(R, A, B) \
do { \
   R = (A) - (B);  if (R < 0.0f) R = 0.0f; \
} while (0)


d414 3
a416 3
      ADD_SAT(res[0], src_term[0], dst_term[0]); /* R */
      ADD_SAT(res[1], src_term[1], dst_term[1]); /* G */
      ADD_SAT(res[2], src_term[2], dst_term[2]); /* B */
d419 3
a421 3
      SUB_SAT(res[0], src_term[0], dst_term[0]); /* R */
      SUB_SAT(res[1], src_term[1], dst_term[1]); /* G */
      SUB_SAT(res[2], src_term[2], dst_term[2]); /* B */
d424 3
a426 3
      SUB_SAT(res[0], dst_term[0], src_term[0]); /* R */
      SUB_SAT(res[1], dst_term[1], src_term[1]); /* G */
      SUB_SAT(res[2], dst_term[2], src_term[2]); /* B */
d447 1
a447 1
      ADD_SAT(res[3], src_term[3], dst_term[3]); /* A */
d450 1
a450 1
      SUB_SAT(res[3], src_term[3], dst_term[3]); /* A */
d453 1
a453 1
      SUB_SAT(res[3], dst_term[3], src_term[3]); /* A */
d469 2
a470 1
test_one(unsigned verbose,
d476 1
a476 1
   LLVMModuleRef module = NULL;
d478 1
a478 3
   LLVMExecutionEngineRef engine = NULL;
   LLVMModuleProviderRef provider = NULL;
   LLVMPassManagerRef pass = NULL;
d486 1
d491 1
a491 3
   module = LLVMModuleCreateWithName("test");

   func = add_blend_test(module, blend, mode, type);
d499 2
a500 28
   provider = LLVMCreateModuleProviderForExistingModule(module);
   if (LLVMCreateJITCompiler(&engine, provider, 1, &error)) {
      if(verbose < 1)
         dump_blend_type(stderr, blend, mode, type);
      fprintf(stderr, "%s\n", error);
      LLVMDisposeMessage(error);
      abort();
   }

#if 0
   pass = LLVMCreatePassManager();
   LLVMAddTargetData(LLVMGetExecutionEngineTargetData(engine), pass);
   /* These are the passes currently listed in llvm-c/Transforms/Scalar.h,
    * but there are more on SVN. */
   LLVMAddConstantPropagationPass(pass);
   LLVMAddInstructionCombiningPass(pass);
   LLVMAddPromoteMemoryToRegisterPass(pass);
   LLVMAddGVNPass(pass);
   LLVMAddCFGSimplificationPass(pass);
   LLVMRunPassManager(pass, module);
#else
   (void)pass;
#endif

   if(verbose >= 2)
      LLVMDumpModule(module);

   blend_test_ptr = (blend_test_ptr_t)LLVMGetPointerToGlobal(engine, func);
d503 1
a503 1
      lp_disassemble(blend_test_ptr);
d647 2
a698 4
   LLVMDisposeExecutionEngine(engine);
   if(pass)
      LLVMDisposePassManager(pass);

d743 1
a743 1
   {   TRUE, FALSE, FALSE,  TRUE,    32,   4 }, /* f32 x 4 */
d754 1
a754 1
test_all(unsigned verbose, FILE *fp)
d765 1
a765 1
   bool success = TRUE;
d790 1
a790 1
                           if(!test_one(verbose, fp, &blend, mode, *type))
d807 2
a808 1
test_some(unsigned verbose, FILE *fp, unsigned long n)
d820 1
a820 1
   bool success = TRUE;
d850 1
a850 1
      if(!test_one(verbose, fp, &blend, mode, *type))
d855 8
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a39 1
#include "gallivm/lp_bld_init.h"
d41 1
a42 1
#include "lp_bld_blend.h"
a54 13
/** cast wrapper */
static blend_test_ptr_t
voidptr_to_blend_test_ptr_t(void *p)
{
   union {
      void *v;
      blend_test_ptr_t f;
   } u;
   u.v = p;
   return u.f;
}


d152 1
a152 1
add_blend_test(struct gallivm_state *gallivm,
d157 1
a157 2
   LLVMModuleRef module = gallivm->module;
   LLVMContextRef context = gallivm->context;
a166 1
   const unsigned rt = 0;
d168 2
a169 1
   vec_type = lp_build_vec_type(gallivm, type);
d172 1
a172 1
   func = LLVMAddFunction(module, "test", LLVMFunctionType(LLVMVoidTypeInContext(context), args, 4, 0));
d179 2
a180 2
   block = LLVMAppendBasicBlockInContext(context, func, "entry");
   builder = gallivm->builder;
d193 1
a193 1
      res = lp_build_blend_aos(gallivm, blend, type, rt, src, dst, con, 3);
d208 1
a208 1
         LLVMValueRef index = LLVMConstInt(LLVMInt32TypeInContext(context), i, 0);
d217 1
a217 1
      lp_build_blend_soa(gallivm, blend, type, rt, src, dst, con, res);
d220 1
a220 1
         LLVMValueRef index = LLVMConstInt(LLVMInt32TypeInContext(context), i, 0);
d228 1
d233 13
d413 3
a415 3
      res[0] = src_term[0] + dst_term[0]; /* R */
      res[1] = src_term[1] + dst_term[1]; /* G */
      res[2] = src_term[2] + dst_term[2]; /* B */
d418 3
a420 3
      res[0] = src_term[0] - dst_term[0]; /* R */
      res[1] = src_term[1] - dst_term[1]; /* G */
      res[2] = src_term[2] - dst_term[2]; /* B */
d423 3
a425 3
      res[0] = dst_term[0] - src_term[0]; /* R */
      res[1] = dst_term[1] - src_term[1]; /* G */
      res[2] = dst_term[2] - src_term[2]; /* B */
d446 1
a446 1
      res[3] = src_term[3] + dst_term[3]; /* A */
d449 1
a449 1
      res[3] = src_term[3] - dst_term[3]; /* A */
d452 1
a452 1
      res[3] = dst_term[3] - src_term[3]; /* A */
d468 1
a468 2
test_one(struct gallivm_state *gallivm,
         unsigned verbose,
d474 1
a474 1
   LLVMModuleRef module = gallivm->module;
d476 3
a478 1
   LLVMExecutionEngineRef engine = gallivm->engine;
a485 1
   void *code;
d490 3
a492 1
   func = add_blend_test(gallivm, blend, mode, type);
d500 28
a527 2
   code = LLVMGetPointerToGlobal(engine, func);
   blend_test_ptr = voidptr_to_blend_test_ptr_t(code);
d530 1
a530 1
      lp_disassemble(code);
a673 2

               fprintf(stderr, "\n");
d724 4
d772 1
a772 1
   {   TRUE, FALSE,  TRUE, FALSE,    32,   4 }, /* f32 x 4 */
d783 1
a783 1
test_all(struct gallivm_state *gallivm, unsigned verbose, FILE *fp)
d794 1
a794 1
   boolean success = TRUE;
d819 1
a819 1
                           if(!test_one(gallivm, verbose, fp, &blend, mode, *type))
d836 1
a836 2
test_some(struct gallivm_state *gallivm, unsigned verbose, FILE *fp,
          unsigned long n)
d848 1
a848 1
   boolean success = TRUE;
d878 1
a878 1
      if(!test_one(gallivm, verbose, fp, &blend, mode, *type))
a882 8
}


boolean
test_single(struct gallivm_state *gallivm, unsigned verbose, FILE *fp)
{
   printf("no test_single()");
   return TRUE;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a38 1
#include "util/u_memory.h"
d47 21
a67 2
typedef void (*blend_test_ptr_t)(const void *src, const void *src1,
                                 const void *dst, const void *con, void *res);
d76 1
d95 1
d102 9
a110 1
   fprintf(fp, "%.1f\t", cycles / type.length);
d140 1
d143 2
d168 1
d174 1
a174 1
   LLVMTypeRef args[5];
a176 1
   LLVMValueRef src1_ptr;
a181 1
   const enum pipe_format format = PIPE_FORMAT_R8G8B8A8_UNORM;
a182 6
   const unsigned char swizzle[4] = { 0, 1, 2, 3 };
   LLVMValueRef src;
   LLVMValueRef src1;
   LLVMValueRef dst;
   LLVMValueRef con;
   LLVMValueRef res;
d186 2
a187 2
   args[4] = args[3] = args[2] = args[1] = args[0] = LLVMPointerType(vec_type, 0);
   func = LLVMAddFunction(module, "test", LLVMFunctionType(LLVMVoidTypeInContext(context), args, 5, 0));
d190 3
a192 4
   src1_ptr = LLVMGetParam(func, 1);
   dst_ptr = LLVMGetParam(func, 2);
   const_ptr = LLVMGetParam(func, 3);
   res_ptr = LLVMGetParam(func, 4);
d198 16
a213 4
   src = LLVMBuildLoad(builder, src_ptr, "src");
   src1 = LLVMBuildLoad(builder, src1_ptr, "src1");
   dst = LLVMBuildLoad(builder, dst_ptr, "dst");
   con = LLVMBuildLoad(builder, const_ptr, "const");
d215 16
a230 2
   res = lp_build_blend_aos(gallivm, blend, format, type, rt, src, NULL,
                            src1, NULL, dst, NULL, con, NULL, swizzle, 4);
d232 1
a232 1
   lp_build_name(res, "res");
d234 6
a239 1
   LLVMBuildStore(builder, res, res_ptr);
a242 2
   gallivm_verify_function(gallivm, func);

a251 1
                       const double *src1,
d301 1
a301 3
      term[0] = factor[0] * src1[0]; /* R */
      term[1] = factor[1] * src1[1]; /* G */
      term[2] = factor[2] * src1[2]; /* B */
d304 1
a304 3
      term[0] = factor[0] * src1[3]; /* R */
      term[1] = factor[1] * src1[3]; /* G */
      term[2] = factor[2] * src1[3]; /* B */
d342 1
a342 3
      term[0] = factor[0] * (1.0f - src1[0]); /* R */
      term[1] = factor[1] * (1.0f - src1[1]); /* G */
      term[2] = factor[2] * (1.0f - src1[2]); /* B */
d345 1
a345 3
      term[0] = factor[0] * (1.0f - src1[3]); /* R */
      term[1] = factor[1] * (1.0f - src1[3]); /* G */
      term[2] = factor[2] * (1.0f - src1[3]); /* B */
a372 4
   case PIPE_BLENDFACTOR_SRC1_COLOR:
   case PIPE_BLENDFACTOR_SRC1_ALPHA:
      term[3] = factor[3] * src1[3]; /* A */
      break;
a387 4
   case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
   case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
      term[3] = factor[3] * (1.0f - src1[3]); /* A */
      break;
a396 1
                  const double *src1,
d405 1
a405 1
                          src, src, src1, dst, con, src_term);
d407 1
a407 1
                          dst, src, src1, dst, con, dst_term);
d469 2
a470 1
test_one(unsigned verbose,
d473 1
d476 1
a476 1
   struct gallivm_state *gallivm;
d478 2
d486 1
a486 1
   const unsigned stride = lp_type_width(type)/8;
d489 1
a489 1
      dump_blend_type(stdout, blend, type);
d491 1
a491 1
   gallivm = gallivm_create();
d493 5
a497 1
   func = add_blend_test(gallivm, blend, type);
d499 2
a500 1
   gallivm_compile_module(gallivm);
d502 2
a503 1
   blend_test_ptr = (blend_test_ptr_t)gallivm_jit_function(gallivm, func);
d506 7
a512 11

   {
      uint8_t *src, *src1, *dst, *con, *res, *ref;
      src = align_malloc(stride, stride);
      src1 = align_malloc(stride, stride);
      dst = align_malloc(stride, stride);
      con = align_malloc(stride, stride);
      res = align_malloc(stride, stride);
      ref = align_malloc(stride, stride);

      for(i = 0; i < n && success; ++i) {
a516 1
         random_vec(type, src1);
a521 1
            double fsrc1[LP_MAX_VECTOR_LENGTH];
a526 1
            read_vec(type, src1, fsrc1);
d531 1
a531 1
               compute_blend_ref(blend, fsrc + j, fsrc1 + j, fdst + j, fcon + j, fref + j);
d537 1
a537 1
         blend_test_ptr(src, src1, dst, con, res);
d546 1
a546 1
               dump_blend_type(stderr, blend, type);
a552 4
            fprintf(stderr, "  Src1: ");
            dump_vec(stderr, type, src1);
            fprintf(stderr, "\n");

d570 82
a651 6
      align_free(src);
      align_free(src1);
      align_free(dst);
      align_free(con);
      align_free(res);
      align_free(ref);
d686 1
a686 1
      write_tsv_row(fp, blend, type, cycles_avg, success);
d688 8
a695 1
   gallivm_free_function(gallivm, func, blend_test_ptr);
d697 1
a697 1
   gallivm_destroy(gallivm);
d713 1
d716 1
d724 1
d727 1
d754 1
a754 1
test_all(unsigned verbose, FILE *fp)
d763 1
d773 2
a774 1
                     for(type = blend_types; type < &blend_types[num_types]; ++type) {
d776 13
a788 13
                        if(*rgb_dst_factor == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE ||
                           *alpha_dst_factor == PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE)
                           continue;

                        memset(&blend, 0, sizeof blend);
                        blend.rt[0].blend_enable      = 1;
                        blend.rt[0].rgb_func          = *rgb_func;
                        blend.rt[0].rgb_src_factor    = *rgb_src_factor;
                        blend.rt[0].rgb_dst_factor    = *rgb_dst_factor;
                        blend.rt[0].alpha_func        = *alpha_func;
                        blend.rt[0].alpha_src_factor  = *alpha_src_factor;
                        blend.rt[0].alpha_dst_factor  = *alpha_dst_factor;
                        blend.rt[0].colormask         = PIPE_MASK_RGBA;
d790 2
a791 2
                        if(!test_one(verbose, fp, &blend, *type))
                          success = FALSE;
d793 1
d807 1
a807 1
test_some(unsigned verbose, FILE *fp,
d817 1
d836 2
d850 1
a850 1
      if(!test_one(verbose, fp, &blend, *type))
d859 1
a859 1
test_single(unsigned verbose, FILE *fp)
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d453 1
a453 1
   gallivm = gallivm_create("test_module", LLVMGetGlobalContext());
a460 2
   gallivm_free_ir(gallivm);

d578 2
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d453 1
a453 1
   gallivm = gallivm_create();
d461 2
a579 2

   gallivm_free_function(gallivm, func, blend_test_ptr);
@


