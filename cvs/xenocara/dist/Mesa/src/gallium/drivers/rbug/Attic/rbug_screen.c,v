head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.01.04;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.50;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "pipe/p_screen.h"
#include "pipe/p_state.h"
#include "util/u_memory.h"
#include "util/u_debug.h"
#include "util/u_simple_list.h"

#include "rbug_public.h"
#include "rbug_screen.h"
#include "rbug_context.h"
#include "rbug_objects.h"

DEBUG_GET_ONCE_BOOL_OPTION(rbug, "GALLIUM_RBUG", FALSE)

static void
rbug_screen_destroy(struct pipe_screen *_screen)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   screen->destroy(screen);

   FREE(rb_screen);
}

static const char *
rbug_screen_get_name(struct pipe_screen *_screen)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   return screen->get_name(screen);
}

static const char *
rbug_screen_get_vendor(struct pipe_screen *_screen)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   return screen->get_vendor(screen);
}

static int
rbug_screen_get_param(struct pipe_screen *_screen,
                      enum pipe_cap param)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   return screen->get_param(screen,
                            param);
}

static int
rbug_screen_get_shader_param(struct pipe_screen *_screen,
                      unsigned shader, enum pipe_shader_cap param)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   return screen->get_shader_param(screen, shader,
                            param);
}

static float
rbug_screen_get_paramf(struct pipe_screen *_screen,
                       enum pipe_capf param)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   return screen->get_paramf(screen,
                             param);
}

static boolean
rbug_screen_is_format_supported(struct pipe_screen *_screen,
                                enum pipe_format format,
                                enum pipe_texture_target target,
                                unsigned sample_count,
                                unsigned tex_usage)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   return screen->is_format_supported(screen,
                                      format,
                                      target,
                                      sample_count,
                                      tex_usage);
}

static struct pipe_context *
rbug_screen_context_create(struct pipe_screen *_screen,
                           void *priv)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;
   struct pipe_context *result;

   result = screen->context_create(screen, priv);
   if (result)
      return rbug_context_create(_screen, result);
   return NULL;
}

static struct pipe_resource *
rbug_screen_resource_create(struct pipe_screen *_screen,
                            const struct pipe_resource *templat)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;
   struct pipe_resource *result;

   result = screen->resource_create(screen,
                                    templat);

   if (result)
      return rbug_resource_create(rb_screen, result);
   return NULL;
}

static struct pipe_resource *
rbug_screen_resource_from_handle(struct pipe_screen *_screen,
                                 const struct pipe_resource *templ,
                                 struct winsys_handle *handle)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;
   struct pipe_resource *result;

   result = screen->resource_from_handle(screen, templ, handle);

   result = rbug_resource_create(rbug_screen(_screen), result);

   return result;
}

static boolean
rbug_screen_resource_get_handle(struct pipe_screen *_screen,
                                struct pipe_resource *_resource,
                                struct winsys_handle *handle)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct rbug_resource *rb_resource = rbug_resource(_resource);
   struct pipe_screen *screen = rb_screen->screen;
   struct pipe_resource *resource = rb_resource->resource;

   return screen->resource_get_handle(screen, resource, handle);
}



static void
rbug_screen_resource_destroy(struct pipe_screen *screen,
                             struct pipe_resource *_resource)
{
   rbug_resource_destroy(rbug_resource(_resource));
}

static void
rbug_screen_flush_frontbuffer(struct pipe_screen *_screen,
                              struct pipe_resource *_resource,
                              unsigned level, unsigned layer,
                              void *context_private, struct pipe_box *sub_box)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct rbug_resource *rb_resource = rbug_resource(_resource);
   struct pipe_screen *screen = rb_screen->screen;
   struct pipe_resource *resource = rb_resource->resource;

   screen->flush_frontbuffer(screen,
                             resource,
                             level, layer,
                             context_private, sub_box);
}

static void
rbug_screen_fence_reference(struct pipe_screen *_screen,
                            struct pipe_fence_handle **ptr,
                            struct pipe_fence_handle *fence)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   screen->fence_reference(screen,
                           ptr,
                           fence);
}

static boolean
rbug_screen_fence_signalled(struct pipe_screen *_screen,
                            struct pipe_fence_handle *fence)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   return screen->fence_signalled(screen,
                                  fence);
}

static boolean
rbug_screen_fence_finish(struct pipe_screen *_screen,
                         struct pipe_fence_handle *fence,
                         uint64_t timeout)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;

   return screen->fence_finish(screen,
                               fence,
                               timeout);
}

boolean
rbug_enabled()
{
   return debug_get_option_rbug();
}

struct pipe_screen *
rbug_screen_create(struct pipe_screen *screen)
{
   struct rbug_screen *rb_screen;

   if (!debug_get_option_rbug())
      return screen;

   rb_screen = CALLOC_STRUCT(rbug_screen);
   if (!rb_screen)
      return screen;

   pipe_mutex_init(rb_screen->list_mutex);
   make_empty_list(&rb_screen->contexts);
   make_empty_list(&rb_screen->resources);
   make_empty_list(&rb_screen->surfaces);
   make_empty_list(&rb_screen->transfers);

   rb_screen->base.destroy = rbug_screen_destroy;
   rb_screen->base.get_name = rbug_screen_get_name;
   rb_screen->base.get_vendor = rbug_screen_get_vendor;
   rb_screen->base.get_param = rbug_screen_get_param;
   rb_screen->base.get_shader_param = rbug_screen_get_shader_param;
   rb_screen->base.get_paramf = rbug_screen_get_paramf;
   rb_screen->base.is_format_supported = rbug_screen_is_format_supported;
   rb_screen->base.context_create = rbug_screen_context_create;
   rb_screen->base.resource_create = rbug_screen_resource_create;
   rb_screen->base.resource_from_handle = rbug_screen_resource_from_handle;
   rb_screen->base.resource_get_handle = rbug_screen_resource_get_handle;
   rb_screen->base.resource_destroy = rbug_screen_resource_destroy;
   rb_screen->base.flush_frontbuffer = rbug_screen_flush_frontbuffer;
   rb_screen->base.fence_reference = rbug_screen_fence_reference;
   rb_screen->base.fence_signalled = rbug_screen_fence_signalled;
   rb_screen->base.fence_finish = rbug_screen_fence_finish;

   rb_screen->screen = screen;

   rb_screen->private_context = screen->context_create(screen, NULL);
   if (!rb_screen->private_context)
      goto err_free;

   rb_screen->rbug = rbug_start(rb_screen);

   if (!rb_screen->rbug)
      goto err_context;

   return &rb_screen->base;

err_context:
   rb_screen->private_context->destroy(rb_screen->private_context);
err_free:
   FREE(rb_screen);
   return screen;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d193 1
a193 1
                              void *context_private)
d203 1
a203 1
                             context_private);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d95 1
a95 1
                       enum pipe_cap param)
a188 22
static struct pipe_resource *
rbug_screen_user_buffer_create(struct pipe_screen *_screen,
                               void *ptr,
                               unsigned bytes,
                               unsigned usage)
{
   struct rbug_screen *rb_screen = rbug_screen(_screen);
   struct pipe_screen *screen = rb_screen->screen;
   struct pipe_resource *result;

   result = screen->user_buffer_create(screen,
                                       ptr,
                                       bytes,
                                       usage);

   if (result)
      return rbug_resource_create(rb_screen, result);
   return NULL;
}



a266 2
   rb_screen->base.winsys = NULL;

a278 1
   rb_screen->base.user_buffer_create = rbug_screen_user_buffer_create;
@


1.1
log
@Initial revision
@
text
@d109 1
a109 2
                                unsigned tex_usage,
                                unsigned geom_flags)
d118 1
a118 2
                                      tex_usage,
                                      geom_flags);
d241 1
a241 1
static int
d243 1
a243 2
                            struct pipe_fence_handle *fence,
                            unsigned flags)
d249 1
a249 2
                                  fence,
                                  flags);
d252 1
a252 1
static int
d255 1
a255 1
                         unsigned flags)
d262 1
a262 1
                               flags);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d95 1
a95 1
                       enum pipe_capf param)
d109 2
a110 1
                                unsigned tex_usage)
d119 2
a120 1
                                      tex_usage);
d191 22
d243 1
a243 1
static boolean
d245 2
a246 1
                            struct pipe_fence_handle *fence)
d252 2
a253 1
                                  fence);
d256 1
a256 1
static boolean
d259 1
a259 1
                         uint64_t timeout)
d266 1
a266 1
                               timeout);
d293 2
d307 1
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d193 1
a193 1
                              void *context_private, struct pipe_box *sub_box)
d203 1
a203 1
                             context_private, sub_box);
@


