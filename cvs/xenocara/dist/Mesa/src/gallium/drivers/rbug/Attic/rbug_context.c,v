head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.01.03;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.50;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.44;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.45.59;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2010 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include "pipe/p_context.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_simple_list.h"

#include "rbug/rbug_context.h"

#include "rbug_context.h"
#include "rbug_objects.h"


static void
rbug_destroy(struct pipe_context *_pipe)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   remove_from_list(&rb_pipe->list);
   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->destroy(pipe);
   rb_pipe->pipe = NULL;
   pipe_mutex_unlock(rb_pipe->call_mutex);

   FREE(rb_pipe);
}

static void
rbug_draw_block_locked(struct rbug_context *rb_pipe, int flag)
{

   if (rb_pipe->draw_blocker & flag) {
      rb_pipe->draw_blocked |= flag;
   } else if ((rb_pipe->draw_rule.blocker & flag) &&
              (rb_pipe->draw_blocker & RBUG_BLOCK_RULE)) {
      unsigned k;
      boolean block = FALSE;
      unsigned sh;

      debug_printf("%s (%p %p) (%p %p) (%p %u) (%p %u)\n", __FUNCTION__,
                   (void *) rb_pipe->draw_rule.shader[PIPE_SHADER_FRAGMENT],
                   (void *) rb_pipe->curr.shader[PIPE_SHADER_FRAGMENT],
                   (void *) rb_pipe->draw_rule.shader[PIPE_SHADER_VERTEX],
                   (void *) rb_pipe->curr.shader[PIPE_SHADER_VERTEX],
                   (void *) rb_pipe->draw_rule.surf, 0,
                   (void *) rb_pipe->draw_rule.texture, 0);
      for (sh = 0; sh < PIPE_SHADER_TYPES; sh++) {
         if (rb_pipe->draw_rule.shader[sh] &&
             rb_pipe->draw_rule.shader[sh] == rb_pipe->curr.shader[sh])
            block = TRUE;
      }

      if (rb_pipe->draw_rule.surf &&
          rb_pipe->draw_rule.surf == rb_pipe->curr.zsbuf)
            block = TRUE;
      if (rb_pipe->draw_rule.surf)
         for (k = 0; k < rb_pipe->curr.nr_cbufs; k++)
            if (rb_pipe->draw_rule.surf == rb_pipe->curr.cbufs[k])
               block = TRUE;
      if (rb_pipe->draw_rule.texture) {
         for (sh = 0; sh < Elements(rb_pipe->curr.num_views); sh++) {
            for (k = 0; k < rb_pipe->curr.num_views[sh]; k++) {
               if (rb_pipe->draw_rule.texture == rb_pipe->curr.texs[sh][k]) {
                  block = TRUE;
                  sh = PIPE_SHADER_TYPES; /* to break out of both loops */
                  break;
               }
            }
         }
      }

      if (block)
         rb_pipe->draw_blocked |= (flag | RBUG_BLOCK_RULE);
   }

   if (rb_pipe->draw_blocked)
      rbug_notify_draw_blocked(rb_pipe);

   /* wait for rbug to clear the blocked flag */
   while (rb_pipe->draw_blocked & flag) {
      rb_pipe->draw_blocked |= flag;
      pipe_condvar_wait(rb_pipe->draw_cond, rb_pipe->draw_mutex);
   }

}

static void
rbug_draw_vbo(struct pipe_context *_pipe, const struct pipe_draw_info *info)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->draw_mutex);
   rbug_draw_block_locked(rb_pipe, RBUG_BLOCK_BEFORE);

   pipe_mutex_lock(rb_pipe->call_mutex);
   /* XXX loop over PIPE_SHADER_x here */
   if (!(rb_pipe->curr.shader[PIPE_SHADER_FRAGMENT] && rb_pipe->curr.shader[PIPE_SHADER_FRAGMENT]->disabled) &&
       !(rb_pipe->curr.shader[PIPE_SHADER_GEOMETRY] && rb_pipe->curr.shader[PIPE_SHADER_GEOMETRY]->disabled) &&
       !(rb_pipe->curr.shader[PIPE_SHADER_VERTEX] && rb_pipe->curr.shader[PIPE_SHADER_VERTEX]->disabled))
      pipe->draw_vbo(pipe, info);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   rbug_draw_block_locked(rb_pipe, RBUG_BLOCK_AFTER);
   pipe_mutex_unlock(rb_pipe->draw_mutex);
}

static struct pipe_query *
rbug_create_query(struct pipe_context *_pipe,
                  unsigned query_type)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   return pipe->create_query(pipe,
                             query_type);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_destroy_query(struct pipe_context *_pipe,
                   struct pipe_query *query)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->destroy_query(pipe,
                       query);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_begin_query(struct pipe_context *_pipe,
                 struct pipe_query *query)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->begin_query(pipe,
                     query);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_end_query(struct pipe_context *_pipe,
               struct pipe_query *query)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->end_query(pipe,
                   query);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static boolean
rbug_get_query_result(struct pipe_context *_pipe,
                      struct pipe_query *query,
                      boolean wait,
                      union pipe_query_result *result)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   boolean ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->get_query_result(pipe,
                                query,
                                wait,
                                result);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
}

static void *
rbug_create_blend_state(struct pipe_context *_pipe,
                        const struct pipe_blend_state *blend)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_blend_state(pipe,
                                  blend);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
}

static void
rbug_bind_blend_state(struct pipe_context *_pipe,
                      void *blend)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->bind_blend_state(pipe,
                          blend);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_delete_blend_state(struct pipe_context *_pipe,
                        void *blend)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->delete_blend_state(pipe,
                            blend);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void *
rbug_create_sampler_state(struct pipe_context *_pipe,
                          const struct pipe_sampler_state *sampler)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_sampler_state(pipe,
                                    sampler);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
}

static void
rbug_bind_sampler_states(struct pipe_context *_pipe, unsigned shader,
                         unsigned start, unsigned count,
                         void **samplers)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->bind_sampler_states(pipe, shader, start, count, samplers);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_delete_sampler_state(struct pipe_context *_pipe,
                          void *sampler)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->delete_sampler_state(pipe,
                              sampler);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void *
rbug_create_rasterizer_state(struct pipe_context *_pipe,
                             const struct pipe_rasterizer_state *rasterizer)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_rasterizer_state(pipe,
                                       rasterizer);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
}

static void
rbug_bind_rasterizer_state(struct pipe_context *_pipe,
                           void *rasterizer)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->bind_rasterizer_state(pipe,
                               rasterizer);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_delete_rasterizer_state(struct pipe_context *_pipe,
                             void *rasterizer)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->delete_rasterizer_state(pipe,
                                 rasterizer);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void *
rbug_create_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                      const struct pipe_depth_stencil_alpha_state *depth_stencil_alpha)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_depth_stencil_alpha_state(pipe,
                                                depth_stencil_alpha);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
}

static void
rbug_bind_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                    void *depth_stencil_alpha)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->bind_depth_stencil_alpha_state(pipe,
                                        depth_stencil_alpha);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_delete_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                      void *depth_stencil_alpha)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->delete_depth_stencil_alpha_state(pipe,
                                          depth_stencil_alpha);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void *
rbug_create_fs_state(struct pipe_context *_pipe,
                     const struct pipe_shader_state *state)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *result;

   pipe_mutex_lock(rb_pipe->call_mutex);
   result = pipe->create_fs_state(pipe, state);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   if (!result)
      return NULL;

   return rbug_shader_create(rb_pipe, state, result, RBUG_SHADER_FRAGMENT);
}

static void
rbug_bind_fs_state(struct pipe_context *_pipe,
                   void *_fs)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *fs;

   pipe_mutex_lock(rb_pipe->call_mutex);

   fs = rbug_shader_unwrap(_fs);
   rb_pipe->curr.shader[PIPE_SHADER_FRAGMENT] = rbug_shader(_fs);
   pipe->bind_fs_state(pipe,
                       fs);

   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_delete_fs_state(struct pipe_context *_pipe,
                     void *_fs)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_shader *rb_shader = rbug_shader(_fs);

   pipe_mutex_lock(rb_pipe->call_mutex);
   rbug_shader_destroy(rb_pipe, rb_shader);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void *
rbug_create_vs_state(struct pipe_context *_pipe,
                     const struct pipe_shader_state *state)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *result;

   pipe_mutex_lock(rb_pipe->call_mutex);
   result = pipe->create_vs_state(pipe, state);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   if (!result)
      return NULL;

   return rbug_shader_create(rb_pipe, state, result, RBUG_SHADER_VERTEX);
}

static void
rbug_bind_vs_state(struct pipe_context *_pipe,
                   void *_vs)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *vs;

   pipe_mutex_lock(rb_pipe->call_mutex);

   vs = rbug_shader_unwrap(_vs);
   rb_pipe->curr.shader[PIPE_SHADER_VERTEX] = rbug_shader(_vs);
   pipe->bind_vs_state(pipe,
                       vs);

   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_delete_vs_state(struct pipe_context *_pipe,
                     void *_vs)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_shader *rb_shader = rbug_shader(_vs);

   pipe_mutex_unlock(rb_pipe->call_mutex);
   rbug_shader_destroy(rb_pipe, rb_shader);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void *
rbug_create_gs_state(struct pipe_context *_pipe,
                     const struct pipe_shader_state *state)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *result;

   pipe_mutex_lock(rb_pipe->call_mutex);
   result = pipe->create_gs_state(pipe, state);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   if (!result)
      return NULL;

   return rbug_shader_create(rb_pipe, state, result, RBUG_SHADER_GEOM);
}

static void
rbug_bind_gs_state(struct pipe_context *_pipe,
                   void *_gs)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *gs;

   pipe_mutex_lock(rb_pipe->call_mutex);

   gs = rbug_shader_unwrap(_gs);
   rb_pipe->curr.shader[PIPE_SHADER_GEOMETRY] = rbug_shader(_gs);
   pipe->bind_gs_state(pipe,
                       gs);

   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_delete_gs_state(struct pipe_context *_pipe,
                     void *_gs)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_shader *rb_shader = rbug_shader(_gs);

   pipe_mutex_lock(rb_pipe->call_mutex);
   rbug_shader_destroy(rb_pipe, rb_shader);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void *
rbug_create_vertex_elements_state(struct pipe_context *_pipe,
                                  unsigned num_elements,
                                  const struct pipe_vertex_element *vertex_elements)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_vertex_elements_state(pipe,
                                             num_elements,
                                             vertex_elements);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
}

static void
rbug_bind_vertex_elements_state(struct pipe_context *_pipe,
                                void *velems)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->bind_vertex_elements_state(pipe,
                                    velems);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_delete_vertex_elements_state(struct pipe_context *_pipe,
                                  void *velems)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->delete_vertex_elements_state(pipe,
                                      velems);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_blend_color(struct pipe_context *_pipe,
                     const struct pipe_blend_color *blend_color)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_blend_color(pipe,
                         blend_color);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_stencil_ref(struct pipe_context *_pipe,
                     const struct pipe_stencil_ref *stencil_ref)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_stencil_ref(pipe,
                         stencil_ref);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_clip_state(struct pipe_context *_pipe,
                    const struct pipe_clip_state *clip)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_clip_state(pipe,
                        clip);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_constant_buffer(struct pipe_context *_pipe,
                         uint shader,
                         uint index,
                         struct pipe_constant_buffer *_cb)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_constant_buffer cb;

   /* XXX hmm? unwrap the input state */
   if (_cb) {
      cb = *_cb;
      cb.buffer = rbug_resource_unwrap(_cb->buffer);
   }

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_constant_buffer(pipe,
                             shader,
                             index,
                             _cb ? &cb : NULL);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_framebuffer_state(struct pipe_context *_pipe,
                           const struct pipe_framebuffer_state *_state)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_framebuffer_state unwrapped_state;
   struct pipe_framebuffer_state *state = NULL;
   unsigned i;

   /* must protect curr status */
   pipe_mutex_lock(rb_pipe->call_mutex);

   rb_pipe->curr.nr_cbufs = 0;
   memset(rb_pipe->curr.cbufs, 0, sizeof(rb_pipe->curr.cbufs));
   rb_pipe->curr.zsbuf = NULL;

   /* unwrap the input state */
   if (_state) {
      memcpy(&unwrapped_state, _state, sizeof(unwrapped_state));

      rb_pipe->curr.nr_cbufs = _state->nr_cbufs;
      for(i = 0; i < _state->nr_cbufs; i++) {
         unwrapped_state.cbufs[i] = rbug_surface_unwrap(_state->cbufs[i]);
         if (_state->cbufs[i])
            rb_pipe->curr.cbufs[i] = rbug_resource(_state->cbufs[i]->texture);
      }
      unwrapped_state.zsbuf = rbug_surface_unwrap(_state->zsbuf);
      if (_state->zsbuf)
         rb_pipe->curr.zsbuf = rbug_resource(_state->zsbuf->texture);
      state = &unwrapped_state;
   }

   pipe->set_framebuffer_state(pipe,
                               state);

   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_polygon_stipple(struct pipe_context *_pipe,
                         const struct pipe_poly_stipple *poly_stipple)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_polygon_stipple(pipe,
                             poly_stipple);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_scissor_states(struct pipe_context *_pipe,
                        unsigned start_slot,
                        unsigned num_scissors,
                        const struct pipe_scissor_state *scissor)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_scissor_states(pipe, start_slot, num_scissors, scissor);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_viewport_states(struct pipe_context *_pipe,
                         unsigned start_slot,
                         unsigned num_viewports,
                         const struct pipe_viewport_state *viewport)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_viewport_states(pipe, start_slot, num_viewports, viewport);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_sampler_views(struct pipe_context *_pipe,
                       unsigned shader,
                       unsigned start,
                       unsigned num,
                       struct pipe_sampler_view **_views)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
   struct pipe_sampler_view **views = NULL;
   unsigned i;

   assert(start == 0); /* XXX fix */

   /* must protect curr status */
   pipe_mutex_lock(rb_pipe->call_mutex);

   rb_pipe->curr.num_views[shader] = 0;
   memset(rb_pipe->curr.views[shader], 0, sizeof(rb_pipe->curr.views[shader]));
   memset(rb_pipe->curr.texs[shader], 0, sizeof(rb_pipe->curr.texs[shader]));
   memset(unwrapped_views, 0, sizeof(unwrapped_views));

   if (_views) {
      rb_pipe->curr.num_views[shader] = num;
      for (i = 0; i < num; i++) {
         rb_pipe->curr.views[shader][i] = rbug_sampler_view(_views[i]);
         rb_pipe->curr.texs[shader][i] = rbug_resource(_views[i] ? _views[i]->texture : NULL);
         unwrapped_views[i] = rbug_sampler_view_unwrap(_views[i]);
      }
      views = unwrapped_views;
   }

   pipe->set_sampler_views(pipe, shader, start, num, views);

   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_vertex_buffers(struct pipe_context *_pipe,
                        unsigned start_slot, unsigned num_buffers,
                        const struct pipe_vertex_buffer *_buffers)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_vertex_buffer unwrapped_buffers[PIPE_MAX_SHADER_INPUTS];
   struct pipe_vertex_buffer *buffers = NULL;
   unsigned i;

   pipe_mutex_lock(rb_pipe->call_mutex);

   if (num_buffers) {
      memcpy(unwrapped_buffers, _buffers, num_buffers * sizeof(*_buffers));
      for (i = 0; i < num_buffers; i++)
         unwrapped_buffers[i].buffer = rbug_resource_unwrap(_buffers[i].buffer);
      buffers = unwrapped_buffers;
   }

   pipe->set_vertex_buffers(pipe, start_slot,
                            num_buffers,
                            buffers);

   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_index_buffer(struct pipe_context *_pipe,
                      const struct pipe_index_buffer *_ib)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_index_buffer unwrapped_ib, *ib = NULL;

   if (_ib) {
      unwrapped_ib = *_ib;
      unwrapped_ib.buffer = rbug_resource_unwrap(_ib->buffer);
      ib = &unwrapped_ib;
   }

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_index_buffer(pipe, ib);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_sample_mask(struct pipe_context *_pipe,
                     unsigned sample_mask)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_sample_mask(pipe, sample_mask);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_resource_copy_region(struct pipe_context *_pipe,
                          struct pipe_resource *_dst,
                          unsigned dst_level,
                          unsigned dstx,
                          unsigned dsty,
                          unsigned dstz,
                          struct pipe_resource *_src,
                          unsigned src_level,
                          const struct pipe_box *src_box)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_resource *rb_resource_dst = rbug_resource(_dst);
   struct rbug_resource *rb_resource_src = rbug_resource(_src);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *dst = rb_resource_dst->resource;
   struct pipe_resource *src = rb_resource_src->resource;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->resource_copy_region(pipe,
                              dst,
                              dst_level,
                              dstx,
                              dsty,
                              dstz,
                              src,
                              src_level,
                              src_box);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_flush_resource(struct pipe_context *_pipe,
                    struct pipe_resource *_res)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_resource *rb_resource_res = rbug_resource(_res);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *res = rb_resource_res->resource;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->flush_resource(pipe, res);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_clear(struct pipe_context *_pipe,
           unsigned buffers,
           const union pipe_color_union *color,
           double depth,
           unsigned stencil)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->clear(pipe,
               buffers,
               color,
               depth,
               stencil);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_clear_render_target(struct pipe_context *_pipe,
                         struct pipe_surface *_dst,
                         const union pipe_color_union *color,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_surface *rb_surface_dst = rbug_surface(_dst);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_surface *dst = rb_surface_dst->surface;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->clear_render_target(pipe,
                             dst,
                             color,
                             dstx,
                             dsty,
                             width,
                             height);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_clear_depth_stencil(struct pipe_context *_pipe,
                         struct pipe_surface *_dst,
                         unsigned clear_flags,
                         double depth,
                         unsigned stencil,
                         unsigned dstx, unsigned dsty,
                         unsigned width, unsigned height)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_surface *rb_surface_dst = rbug_surface(_dst);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_surface *dst = rb_surface_dst->surface;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->clear_depth_stencil(pipe,
                             dst,
                             clear_flags,
                             depth,
                             stencil,
                             dstx,
                             dsty,
                             width,
                             height);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_flush(struct pipe_context *_pipe,
           struct pipe_fence_handle **fence,
           unsigned flags)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->flush(pipe, fence, flags);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static struct pipe_sampler_view *
rbug_context_create_sampler_view(struct pipe_context *_pipe,
                                 struct pipe_resource *_resource,
                                 const struct pipe_sampler_view *templ)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_resource *rb_resource = rbug_resource(_resource);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *resource = rb_resource->resource;
   struct pipe_sampler_view *result;

   pipe_mutex_lock(rb_pipe->call_mutex);
   result = pipe->create_sampler_view(pipe,
                                      resource,
                                      templ);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   if (result)
      return rbug_sampler_view_create(rb_pipe, rb_resource, result);
   return NULL;
}

static void
rbug_context_sampler_view_destroy(struct pipe_context *_pipe,
                                  struct pipe_sampler_view *_view)
{
   rbug_sampler_view_destroy(rbug_context(_pipe),
                             rbug_sampler_view(_view));
}

static struct pipe_surface *
rbug_context_create_surface(struct pipe_context *_pipe,
                            struct pipe_resource *_resource,
                            const struct pipe_surface *surf_tmpl)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_resource *rb_resource = rbug_resource(_resource);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *resource = rb_resource->resource;
   struct pipe_surface *result;

   pipe_mutex_lock(rb_pipe->call_mutex);
   result = pipe->create_surface(pipe,
                                 resource,
                                 surf_tmpl);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   if (result)
      return rbug_surface_create(rb_pipe, rb_resource, result);
   return NULL;
}

static void
rbug_context_surface_destroy(struct pipe_context *_pipe,
                             struct pipe_surface *_surface)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_surface *rb_surface = rbug_surface(_surface);

   pipe_mutex_lock(rb_pipe->call_mutex);
   rbug_surface_destroy(rb_pipe,
                        rb_surface);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}



static void *
rbug_context_transfer_map(struct pipe_context *_context,
                          struct pipe_resource *_resource,
                          unsigned level,
                          unsigned usage,
                          const struct pipe_box *box,
                          struct pipe_transfer **transfer)
{
   struct rbug_context *rb_pipe = rbug_context(_context);
   struct rbug_resource *rb_resource = rbug_resource(_resource);
   struct pipe_context *context = rb_pipe->pipe;
   struct pipe_resource *resource = rb_resource->resource;
   struct pipe_transfer *result;
   void *map;

   pipe_mutex_lock(rb_pipe->call_mutex);
   map = context->transfer_map(context,
                               resource,
                               level,
                               usage,
                               box, &result);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   *transfer = rbug_transfer_create(rb_pipe, rb_resource, result);
   return *transfer ? map : NULL;
}

static void
rbug_context_transfer_flush_region(struct pipe_context *_context,
                                   struct pipe_transfer *_transfer,
                                   const struct pipe_box *box)
{
   struct rbug_context *rb_pipe = rbug_context(_context);
   struct rbug_transfer *rb_transfer = rbug_transfer(_transfer);
   struct pipe_context *context = rb_pipe->pipe;
   struct pipe_transfer *transfer = rb_transfer->transfer;

   pipe_mutex_lock(rb_pipe->call_mutex);
   context->transfer_flush_region(context,
                                  transfer,
                                  box);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}


static void
rbug_context_transfer_unmap(struct pipe_context *_context,
                            struct pipe_transfer *_transfer)
{
   struct rbug_context *rb_pipe = rbug_context(_context);
   struct rbug_transfer *rb_transfer = rbug_transfer(_transfer);
   struct pipe_context *context = rb_pipe->pipe;
   struct pipe_transfer *transfer = rb_transfer->transfer;

   pipe_mutex_lock(rb_pipe->call_mutex);
   context->transfer_unmap(context,
                           transfer);
   rbug_transfer_destroy(rb_pipe,
                         rb_transfer);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}


static void
rbug_context_transfer_inline_write(struct pipe_context *_context,
                                   struct pipe_resource *_resource,
                                   unsigned level,
                                   unsigned usage,
                                   const struct pipe_box *box,
                                   const void *data,
                                   unsigned stride,
                                   unsigned layer_stride)
{
   struct rbug_context *rb_pipe = rbug_context(_context);
   struct rbug_resource *rb_resource = rbug_resource(_resource);
   struct pipe_context *context = rb_pipe->pipe;
   struct pipe_resource *resource = rb_resource->resource;

   pipe_mutex_lock(rb_pipe->call_mutex);
   context->transfer_inline_write(context,
                                  resource,
                                  level,
                                  usage,
                                  box,
                                  data,
                                  stride,
                                  layer_stride);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}


struct pipe_context *
rbug_context_create(struct pipe_screen *_screen, struct pipe_context *pipe)
{
   struct rbug_context *rb_pipe;
   struct rbug_screen *rb_screen = rbug_screen(_screen);

   if (!rb_screen)
      return NULL;

   rb_pipe = CALLOC_STRUCT(rbug_context);
   if (!rb_pipe)
      return NULL;

   pipe_mutex_init(rb_pipe->draw_mutex);
   pipe_condvar_init(rb_pipe->draw_cond);
   pipe_mutex_init(rb_pipe->call_mutex);
   pipe_mutex_init(rb_pipe->list_mutex);
   make_empty_list(&rb_pipe->shaders);

   rb_pipe->base.screen = _screen;
   rb_pipe->base.priv = pipe->priv; /* expose wrapped data */
   rb_pipe->base.draw = NULL;

   rb_pipe->base.destroy = rbug_destroy;
   rb_pipe->base.draw_vbo = rbug_draw_vbo;
   rb_pipe->base.create_query = rbug_create_query;
   rb_pipe->base.destroy_query = rbug_destroy_query;
   rb_pipe->base.begin_query = rbug_begin_query;
   rb_pipe->base.end_query = rbug_end_query;
   rb_pipe->base.get_query_result = rbug_get_query_result;
   rb_pipe->base.create_blend_state = rbug_create_blend_state;
   rb_pipe->base.bind_blend_state = rbug_bind_blend_state;
   rb_pipe->base.delete_blend_state = rbug_delete_blend_state;
   rb_pipe->base.create_sampler_state = rbug_create_sampler_state;
   rb_pipe->base.bind_sampler_states = rbug_bind_sampler_states;
   rb_pipe->base.delete_sampler_state = rbug_delete_sampler_state;
   rb_pipe->base.create_rasterizer_state = rbug_create_rasterizer_state;
   rb_pipe->base.bind_rasterizer_state = rbug_bind_rasterizer_state;
   rb_pipe->base.delete_rasterizer_state = rbug_delete_rasterizer_state;
   rb_pipe->base.create_depth_stencil_alpha_state = rbug_create_depth_stencil_alpha_state;
   rb_pipe->base.bind_depth_stencil_alpha_state = rbug_bind_depth_stencil_alpha_state;
   rb_pipe->base.delete_depth_stencil_alpha_state = rbug_delete_depth_stencil_alpha_state;
   rb_pipe->base.create_fs_state = rbug_create_fs_state;
   rb_pipe->base.bind_fs_state = rbug_bind_fs_state;
   rb_pipe->base.delete_fs_state = rbug_delete_fs_state;
   rb_pipe->base.create_vs_state = rbug_create_vs_state;
   rb_pipe->base.bind_vs_state = rbug_bind_vs_state;
   rb_pipe->base.delete_vs_state = rbug_delete_vs_state;
   rb_pipe->base.create_gs_state = rbug_create_gs_state;
   rb_pipe->base.bind_gs_state = rbug_bind_gs_state;
   rb_pipe->base.delete_gs_state = rbug_delete_gs_state;
   rb_pipe->base.create_vertex_elements_state = rbug_create_vertex_elements_state;
   rb_pipe->base.bind_vertex_elements_state = rbug_bind_vertex_elements_state;
   rb_pipe->base.delete_vertex_elements_state = rbug_delete_vertex_elements_state;
   rb_pipe->base.set_blend_color = rbug_set_blend_color;
   rb_pipe->base.set_stencil_ref = rbug_set_stencil_ref;
   rb_pipe->base.set_clip_state = rbug_set_clip_state;
   rb_pipe->base.set_constant_buffer = rbug_set_constant_buffer;
   rb_pipe->base.set_framebuffer_state = rbug_set_framebuffer_state;
   rb_pipe->base.set_polygon_stipple = rbug_set_polygon_stipple;
   rb_pipe->base.set_scissor_states = rbug_set_scissor_states;
   rb_pipe->base.set_viewport_states = rbug_set_viewport_states;
   rb_pipe->base.set_sampler_views = rbug_set_sampler_views;
   rb_pipe->base.set_vertex_buffers = rbug_set_vertex_buffers;
   rb_pipe->base.set_index_buffer = rbug_set_index_buffer;
   rb_pipe->base.set_sample_mask = rbug_set_sample_mask;
   rb_pipe->base.resource_copy_region = rbug_resource_copy_region;
   rb_pipe->base.flush_resource = rbug_flush_resource;
   rb_pipe->base.clear = rbug_clear;
   rb_pipe->base.clear_render_target = rbug_clear_render_target;
   rb_pipe->base.clear_depth_stencil = rbug_clear_depth_stencil;
   rb_pipe->base.flush = rbug_flush;
   rb_pipe->base.create_sampler_view = rbug_context_create_sampler_view;
   rb_pipe->base.sampler_view_destroy = rbug_context_sampler_view_destroy;
   rb_pipe->base.create_surface = rbug_context_create_surface;
   rb_pipe->base.surface_destroy = rbug_context_surface_destroy;
   rb_pipe->base.transfer_map = rbug_context_transfer_map;
   rb_pipe->base.transfer_unmap = rbug_context_transfer_unmap;
   rb_pipe->base.transfer_flush_region = rbug_context_transfer_flush_region;
   rb_pipe->base.transfer_inline_write = rbug_context_transfer_inline_write;

   rb_pipe->pipe = pipe;

   rbug_screen_add_to_list(rb_screen, contexts, rb_pipe);

   if (debug_get_bool_option("GALLIUM_RBUG_START_BLOCKED", FALSE)) {
      rb_pipe->draw_blocked = RBUG_BLOCK_BEFORE;
   }

   return &rb_pipe->base;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a42 1
   struct rbug_screen *rb_screen = rbug_screen(_pipe->screen);
d46 1
a46 2
   rbug_screen_remove_from_list(rb_screen, contexts, rb_pipe);

d137 1
a137 2
                  unsigned query_type,
                  unsigned index)
a140 1
   struct pipe_query *query;
d143 2
a144 3
   query = pipe->create_query(pipe,
                              query_type,
                              index);
a145 1
   return query;
d757 1
a757 1
   if (num_buffers && _buffers) {
a801 43
static struct pipe_stream_output_target *
rbug_create_stream_output_target(struct pipe_context *_pipe,
                                 struct pipe_resource *_res,
                                 unsigned buffer_offset, unsigned buffer_size)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *res = rbug_resource_unwrap(_res);
   struct pipe_stream_output_target *target;

   pipe_mutex_lock(rb_pipe->call_mutex);
   target = pipe->create_stream_output_target(pipe, res, buffer_offset,
                                              buffer_size);
   pipe_mutex_unlock(rb_pipe->call_mutex);
   return target;
}

static void
rbug_stream_output_target_destroy(struct pipe_context *_pipe,
                                  struct pipe_stream_output_target *target)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->stream_output_target_destroy(pipe, target);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_stream_output_targets(struct pipe_context *_pipe,
                               unsigned num_targets,
                               struct pipe_stream_output_target **targets,
                               const unsigned *offsets)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_stream_output_targets(pipe, num_targets, targets, offsets);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

a833 20
rbug_blit(struct pipe_context *_pipe, const struct pipe_blit_info *_blit_info)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_resource *rb_resource_dst = rbug_resource(_blit_info->dst.resource);
   struct rbug_resource *rb_resource_src = rbug_resource(_blit_info->src.resource);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *dst = rb_resource_dst->resource;
   struct pipe_resource *src = rb_resource_src->resource;
   struct pipe_blit_info blit_info;

   blit_info = *_blit_info;
   blit_info.dst.resource = dst;
   blit_info.src.resource = src;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->blit(pipe, &blit_info);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
a1152 3
   rb_pipe->base.create_stream_output_target = rbug_create_stream_output_target;
   rb_pipe->base.stream_output_target_destroy = rbug_stream_output_target_destroy;
   rb_pipe->base.set_stream_output_targets = rbug_set_stream_output_targets;
a1153 1
   rb_pipe->base.blit = rbug_blit;
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d43 1
d47 2
a48 1
   remove_from_list(&rb_pipe->list);
d139 2
a140 1
                  unsigned query_type)
d144 1
d147 3
a149 2
   return pipe->create_query(pipe,
                             query_type);
d151 1
d763 1
a763 1
   if (num_buffers) {
d808 43
d883 20
d1222 3
d1226 1
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d266 3
a268 3
rbug_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                  unsigned num_samplers,
                                  void **samplers)
d274 1
a274 18
   pipe->bind_fragment_sampler_states(pipe,
                                      num_samplers,
                                      samplers);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_bind_vertex_sampler_states(struct pipe_context *_pipe,
                                unsigned num_samplers,
                                void **samplers)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->bind_vertex_sampler_states(pipe,
                                    num_samplers,
                                    samplers);
d715 1
a715 1
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SAMPLERS];
d739 1
a739 10
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->set_vertex_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->set_fragment_sampler_views(pipe, num, views);
      break;
   default:
      assert(0);
   }
a744 16
rbug_set_vertex_sampler_views(struct pipe_context *_pipe,
                              unsigned num,
                              struct pipe_sampler_view **_views)
{
   rbug_set_sampler_views(_pipe, PIPE_SHADER_VERTEX, 0, num, _views);
}

static void
rbug_set_fragment_sampler_views(struct pipe_context *_pipe,
                                unsigned num,
                                struct pipe_sampler_view **_views)
{
   rbug_set_sampler_views(_pipe, PIPE_SHADER_FRAGMENT, 0, num, _views);
}

static void
d834 14
d1121 1
a1121 2
   rb_pipe->base.bind_fragment_sampler_states = rbug_bind_fragment_sampler_states;
   rb_pipe->base.bind_vertex_sampler_states = rbug_bind_vertex_sampler_states;
d1149 1
a1149 2
   rb_pipe->base.set_fragment_sampler_views = rbug_set_fragment_sampler_views;
   rb_pipe->base.set_vertex_sampler_views = rbug_set_vertex_sampler_views;
d1154 1
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d63 1
a63 1
      int k;
d65 2
d68 4
a71 2
                   (void *) rb_pipe->draw_rule.fs, (void *) rb_pipe->curr.fs,
                   (void *) rb_pipe->draw_rule.vs, (void *) rb_pipe->curr.vs,
d74 6
a79 6
      if (rb_pipe->draw_rule.fs &&
          rb_pipe->draw_rule.fs == rb_pipe->curr.fs)
         block = TRUE;
      if (rb_pipe->draw_rule.vs &&
          rb_pipe->draw_rule.vs == rb_pipe->curr.vs)
         block = TRUE;
d88 7
a94 6
         for (k = 0; k < rb_pipe->curr.num_fs_views; k++)
            if (rb_pipe->draw_rule.texture == rb_pipe->curr.fs_texs[k])
               block = TRUE;
         for (k = 0; k < rb_pipe->curr.num_vs_views; k++) {
            if (rb_pipe->draw_rule.texture == rb_pipe->curr.vs_texs[k]) {
               block = TRUE;
d124 4
a127 3
   if (!(rb_pipe->curr.fs && rb_pipe->curr.fs->disabled) &&
       !(rb_pipe->curr.gs && rb_pipe->curr.gs->disabled) &&
       !(rb_pipe->curr.vs && rb_pipe->curr.vs->disabled))
d191 1
a191 1
                      void *result)
d421 1
a421 1
   rb_pipe->curr.fs = rbug_shader(_fs);
d469 1
a469 1
   rb_pipe->curr.vs = rbug_shader(_vs);
d517 1
a517 1
   rb_pipe->curr.gs = rbug_shader(_gs);
d623 1
a623 1
                         struct pipe_resource *_resource)
d627 1
a627 2
   struct pipe_resource *unwrapped_resource;
   struct pipe_resource *resource = NULL;
d630 3
a632 3
   if (_resource) {
      unwrapped_resource = rbug_resource_unwrap(_resource);
      resource = unwrapped_resource;
d639 1
a639 1
                             resource);
d696 4
a699 2
rbug_set_scissor_state(struct pipe_context *_pipe,
                       const struct pipe_scissor_state *scissor)
d705 1
a705 2
   pipe->set_scissor_state(pipe,
                           scissor);
d710 4
a713 2
rbug_set_viewport_state(struct pipe_context *_pipe,
                        const struct pipe_viewport_state *viewport)
d719 1
a719 2
   pipe->set_viewport_state(pipe,
                            viewport);
d724 5
a728 3
rbug_set_fragment_sampler_views(struct pipe_context *_pipe,
                                unsigned num,
                                struct pipe_sampler_view **_views)
d736 2
d741 3
a743 3
   rb_pipe->curr.num_fs_views = 0;
   memset(rb_pipe->curr.fs_views, 0, sizeof(rb_pipe->curr.fs_views));
   memset(rb_pipe->curr.fs_texs, 0, sizeof(rb_pipe->curr.fs_texs));
d747 1
a747 1
      rb_pipe->curr.num_fs_views = num;
d749 2
a750 2
         rb_pipe->curr.fs_views[i] = rbug_sampler_view(_views[i]);
         rb_pipe->curr.fs_texs[i] = rbug_resource(_views[i] ? _views[i]->texture : NULL);
d756 10
a765 1
   pipe->set_fragment_sampler_views(pipe, num, views);
d775 2
a776 5
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_VERTEX_SAMPLERS];
   struct pipe_sampler_view **views = NULL;
   unsigned i;
d778 6
a783 21
   /* must protect curr status */
   pipe_mutex_lock(rb_pipe->call_mutex);

   rb_pipe->curr.num_vs_views = 0;
   memset(rb_pipe->curr.vs_views, 0, sizeof(rb_pipe->curr.vs_views));
   memset(rb_pipe->curr.vs_texs, 0, sizeof(rb_pipe->curr.vs_texs));
   memset(unwrapped_views, 0, sizeof(unwrapped_views));

   if (_views) {
      rb_pipe->curr.num_vs_views = num;
      for (i = 0; i < num; i++) {
         rb_pipe->curr.vs_views[i] = rbug_sampler_view(_views[i]);
         rb_pipe->curr.vs_texs[i] = rbug_resource(_views[i]->texture);
         unwrapped_views[i] = rbug_sampler_view_unwrap(_views[i]);
      }
      views = unwrapped_views;
   }

   pipe->set_vertex_sampler_views(pipe, num, views);

   pipe_mutex_unlock(rb_pipe->call_mutex);
d788 1
a788 1
                        unsigned num_buffers,
d806 1
a806 1
   pipe->set_vertex_buffers(pipe,
d878 1
a878 1
           const float *rgba,
d888 1
a888 1
               rgba,
d897 1
a897 1
                         const float *rgba,
d909 1
a909 1
                             rgba,
d946 2
a947 1
           struct pipe_fence_handle **fence)
d953 1
a953 2
   pipe->flush(pipe,
               fence);
d1024 2
a1025 2
static struct pipe_transfer *
rbug_context_get_transfer(struct pipe_context *_context,
d1029 2
a1030 1
                          const struct pipe_box *box)
d1037 1
d1040 5
a1044 5
   result = context->get_transfer(context,
                                  resource,
                                  level,
                                  usage,
                                  box);
d1047 2
a1048 3
   if (result)
      return rbug_transfer_create(rb_pipe, rb_resource, result);
   return NULL;
a1051 33
rbug_context_transfer_destroy(struct pipe_context *_pipe,
                              struct pipe_transfer *_transfer)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_transfer *rb_transfer =rbug_transfer(_transfer);

   pipe_mutex_lock(rb_pipe->call_mutex);
   rbug_transfer_destroy(rb_pipe,
                         rb_transfer);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void *
rbug_context_transfer_map(struct pipe_context *_context,
                          struct pipe_transfer *_transfer)
{
   struct rbug_context *rb_pipe = rbug_context(_context);
   struct rbug_transfer *rb_transfer = rbug_transfer(_transfer);
   struct pipe_context *context = rb_pipe->pipe;
   struct pipe_transfer *transfer = rb_transfer->transfer;
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = context->transfer_map(context,
                                transfer);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
}



static void
d1081 2
a1114 15
static void rbug_redefine_user_buffer(struct pipe_context *_context,
                                      struct pipe_resource *_resource,
                                      unsigned offset, unsigned size)
{
   struct rbug_context *rb_pipe = rbug_context(_context);
   struct rbug_resource *rb_resource = rbug_resource(_resource);
   struct pipe_context *context = rb_pipe->pipe;
   struct pipe_resource *resource = rb_resource->resource;

   pipe_mutex_lock(rb_pipe->call_mutex);
   context->redefine_user_buffer(context, resource, offset, size);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}


a1133 1
   rb_pipe->base.winsys = NULL;
d1176 2
a1177 2
   rb_pipe->base.set_scissor_state = rbug_set_scissor_state;
   rb_pipe->base.set_viewport_state = rbug_set_viewport_state;
a1191 2
   rb_pipe->base.get_transfer = rbug_context_get_transfer;
   rb_pipe->base.transfer_destroy = rbug_context_transfer_destroy;
a1195 1
   rb_pipe->base.redefine_user_buffer = rbug_redefine_user_buffer;
d1200 4
@


1.1
log
@Initial revision
@
text
@d47 1
d49 2
d118 6
a123 1
   pipe->draw_vbo(pipe, info);
d136 1
d139 1
d149 1
d152 1
d162 1
d165 1
d175 1
d178 1
d189 1
d191 8
a198 4
   return pipe->get_query_result(pipe,
                                 query,
                                 wait,
                                 result);
d207 6
d214 1
a214 2
   return pipe->create_blend_state(pipe,
                                   blend);
d224 1
d226 2
a227 1
                              blend);
d237 1
d240 1
d249 6
d256 1
a256 2
   return pipe->create_sampler_state(pipe,
                                     sampler);
d267 1
d271 1
d282 1
d286 1
d296 1
d299 1
d308 1
d310 6
a315 2
   return pipe->create_rasterizer_state(pipe,
                                        rasterizer);
d325 1
d328 1
d338 1
d341 1
d350 6
d357 1
a357 2
   return pipe->create_depth_stencil_alpha_state(pipe,
                                                 depth_stencil_alpha);
d367 1
d370 1
d380 1
d383 1
d394 1
d396 2
d412 2
d418 2
d429 1
d431 1
d442 1
d444 2
d460 2
d466 2
d477 1
d479 1
d490 1
d492 2
d508 2
d514 2
d525 1
d527 1
d537 1
d539 2
a540 1
   return pipe->create_vertex_elements_state(pipe,
d543 3
d555 1
d558 1
d568 1
d571 1
d581 1
d584 1
d594 1
d597 1
d607 1
d610 1
d630 1
d635 1
d648 3
d653 1
d666 2
d673 2
d684 1
d687 1
d697 1
d700 1
d710 1
d713 1
d727 3
d746 2
d761 3
d780 2
d795 2
d807 2
d825 1
d827 1
d837 1
d839 1
d860 1
d870 1
d883 1
d889 1
d904 1
d912 1
d929 1
d939 1
a943 1
           unsigned flags,
d949 1
a950 1
               flags,
d952 1
a952 17
}

static unsigned int
rbug_is_resource_referenced(struct pipe_context *_pipe,
                            struct pipe_resource *_resource,
                            unsigned level,
                            int layer)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_resource *rb_resource = rbug_resource(_resource);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *resource = rb_resource->resource;

   return pipe->is_resource_referenced(pipe,
                                       resource,
                                       level,
                                       layer);
d966 1
d970 1
d996 1
d1000 1
d1011 7
a1017 2
   rbug_surface_destroy(rbug_context(_pipe),
                        rbug_surface(_surface));
d1035 1
d1041 1
d1052 7
a1058 2
   rbug_transfer_destroy(rbug_context(_pipe),
                             rbug_transfer(_transfer));
d1069 1
d1071 2
a1072 1
   return context->transfer_map(context,
d1074 3
d1091 1
d1095 1
d1108 1
d1111 1
d1130 1
d1139 16
a1231 1
   rb_pipe->base.is_resource_referenced = rbug_is_resource_referenced;
d1242 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a46 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a47 2
   rb_pipe->pipe = NULL;
   pipe_mutex_unlock(rb_pipe->call_mutex);
d60 1
a60 1
      unsigned k;
a61 2
      unsigned sh;

d63 2
a64 4
                   (void *) rb_pipe->draw_rule.shader[PIPE_SHADER_FRAGMENT],
                   (void *) rb_pipe->curr.shader[PIPE_SHADER_FRAGMENT],
                   (void *) rb_pipe->draw_rule.shader[PIPE_SHADER_VERTEX],
                   (void *) rb_pipe->curr.shader[PIPE_SHADER_VERTEX],
d67 6
a72 6
      for (sh = 0; sh < PIPE_SHADER_TYPES; sh++) {
         if (rb_pipe->draw_rule.shader[sh] &&
             rb_pipe->draw_rule.shader[sh] == rb_pipe->curr.shader[sh])
            block = TRUE;
      }

d81 6
a86 7
         for (sh = 0; sh < Elements(rb_pipe->curr.num_views); sh++) {
            for (k = 0; k < rb_pipe->curr.num_views[sh]; k++) {
               if (rb_pipe->draw_rule.texture == rb_pipe->curr.texs[sh][k]) {
                  block = TRUE;
                  sh = PIPE_SHADER_TYPES; /* to break out of both loops */
                  break;
               }
d115 1
a115 7
   pipe_mutex_lock(rb_pipe->call_mutex);
   /* XXX loop over PIPE_SHADER_x here */
   if (!(rb_pipe->curr.shader[PIPE_SHADER_FRAGMENT] && rb_pipe->curr.shader[PIPE_SHADER_FRAGMENT]->disabled) &&
       !(rb_pipe->curr.shader[PIPE_SHADER_GEOMETRY] && rb_pipe->curr.shader[PIPE_SHADER_GEOMETRY]->disabled) &&
       !(rb_pipe->curr.shader[PIPE_SHADER_VERTEX] && rb_pipe->curr.shader[PIPE_SHADER_VERTEX]->disabled))
      pipe->draw_vbo(pipe, info);
   pipe_mutex_unlock(rb_pipe->call_mutex);
a127 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a129 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a138 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a140 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a149 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a151 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a160 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a162 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
d169 1
a169 1
                      union pipe_query_result *result)
a172 1
   boolean ret;
d174 4
a177 8
   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->get_query_result(pipe,
                                query,
                                wait,
                                result);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
a185 6
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_blend_state(pipe,
                                  blend);
   pipe_mutex_unlock(rb_pipe->call_mutex);
d187 2
a188 1
   return ret;
a197 1
   pipe_mutex_lock(rb_pipe->call_mutex);
d199 1
a199 2
                          blend);
   pipe_mutex_unlock(rb_pipe->call_mutex);
a208 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a210 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a218 6
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_sampler_state(pipe,
                                    sampler);
   pipe_mutex_unlock(rb_pipe->call_mutex);
d220 2
a221 1
   return ret;
a231 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a234 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a244 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a247 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a256 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a258 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a266 1
   void *ret;
d268 2
a269 6
   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_rasterizer_state(pipe,
                                       rasterizer);
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
a278 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a280 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a289 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a291 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a299 6
   void *ret;

   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_depth_stencil_alpha_state(pipe,
                                                depth_stencil_alpha);
   pipe_mutex_unlock(rb_pipe->call_mutex);
d301 2
a302 1
   return ret;
a311 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a313 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a322 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a324 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a334 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a335 2
   pipe_mutex_unlock(rb_pipe->call_mutex);

a349 2
   pipe_mutex_lock(rb_pipe->call_mutex);

d351 1
a351 1
   rb_pipe->curr.shader[PIPE_SHADER_FRAGMENT] = rbug_shader(_fs);
a353 2

   pipe_mutex_unlock(rb_pipe->call_mutex);
a362 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a363 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a373 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a374 2
   pipe_mutex_unlock(rb_pipe->call_mutex);

a388 2
   pipe_mutex_lock(rb_pipe->call_mutex);

d390 1
a390 1
   rb_pipe->curr.shader[PIPE_SHADER_VERTEX] = rbug_shader(_vs);
a392 2

   pipe_mutex_unlock(rb_pipe->call_mutex);
a401 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a402 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a412 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a413 2
   pipe_mutex_unlock(rb_pipe->call_mutex);

a427 2
   pipe_mutex_lock(rb_pipe->call_mutex);

d429 1
a429 1
   rb_pipe->curr.shader[PIPE_SHADER_GEOMETRY] = rbug_shader(_gs);
a431 2

   pipe_mutex_unlock(rb_pipe->call_mutex);
a440 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a441 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a450 1
   void *ret;
d452 1
a452 2
   pipe_mutex_lock(rb_pipe->call_mutex);
   ret = pipe->create_vertex_elements_state(pipe,
a454 3
   pipe_mutex_unlock(rb_pipe->call_mutex);

   return ret;
a463 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a465 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a474 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a476 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a485 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a487 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a496 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a498 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a507 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a509 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
d516 1
a516 1
                         struct pipe_constant_buffer *_cb)
d520 2
a521 1
   struct pipe_constant_buffer cb;
d524 3
a526 3
   if (_cb) {
      cb = *_cb;
      cb.buffer = rbug_resource_unwrap(_cb->buffer);
a528 1
   pipe_mutex_lock(rb_pipe->call_mutex);
d532 1
a532 2
                             _cb ? &cb : NULL);
   pipe_mutex_unlock(rb_pipe->call_mutex);
a544 3
   /* must protect curr status */
   pipe_mutex_lock(rb_pipe->call_mutex);

a546 1
   rb_pipe->curr.zsbuf = NULL;
a558 2
      if (_state->zsbuf)
         rb_pipe->curr.zsbuf = rbug_resource(_state->zsbuf->texture);
a563 2

   pipe_mutex_unlock(rb_pipe->call_mutex);
a572 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a574 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
d578 2
a579 4
rbug_set_scissor_states(struct pipe_context *_pipe,
                        unsigned start_slot,
                        unsigned num_scissors,
                        const struct pipe_scissor_state *scissor)
d584 2
a585 3
   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_scissor_states(pipe, start_slot, num_scissors, scissor);
   pipe_mutex_unlock(rb_pipe->call_mutex);
d589 2
a590 4
rbug_set_viewport_states(struct pipe_context *_pipe,
                         unsigned start_slot,
                         unsigned num_viewports,
                         const struct pipe_viewport_state *viewport)
d595 2
a596 3
   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_viewport_states(pipe, start_slot, num_viewports, viewport);
   pipe_mutex_unlock(rb_pipe->call_mutex);
d600 3
a602 5
rbug_set_sampler_views(struct pipe_context *_pipe,
                       unsigned shader,
                       unsigned start,
                       unsigned num,
                       struct pipe_sampler_view **_views)
d610 3
a612 8
   assert(start == 0); /* XXX fix */

   /* must protect curr status */
   pipe_mutex_lock(rb_pipe->call_mutex);

   rb_pipe->curr.num_views[shader] = 0;
   memset(rb_pipe->curr.views[shader], 0, sizeof(rb_pipe->curr.views[shader]));
   memset(rb_pipe->curr.texs[shader], 0, sizeof(rb_pipe->curr.texs[shader]));
d616 1
a616 1
      rb_pipe->curr.num_views[shader] = num;
d618 2
a619 2
         rb_pipe->curr.views[shader][i] = rbug_sampler_view(_views[i]);
         rb_pipe->curr.texs[shader][i] = rbug_resource(_views[i] ? _views[i]->texture : NULL);
d625 1
a625 12
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->set_vertex_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->set_fragment_sampler_views(pipe, num, views);
      break;
   default:
      assert(0);
   }

   pipe_mutex_unlock(rb_pipe->call_mutex);
d633 20
a652 2
   rbug_set_sampler_views(_pipe, PIPE_SHADER_VERTEX, 0, num, _views);
}
d654 1
a654 6
static void
rbug_set_fragment_sampler_views(struct pipe_context *_pipe,
                                unsigned num,
                                struct pipe_sampler_view **_views)
{
   rbug_set_sampler_views(_pipe, PIPE_SHADER_FRAGMENT, 0, num, _views);
d659 1
a659 1
                        unsigned start_slot, unsigned num_buffers,
a667 2
   pipe_mutex_lock(rb_pipe->call_mutex);

d675 1
a675 1
   pipe->set_vertex_buffers(pipe, start_slot,
a677 2

   pipe_mutex_unlock(rb_pipe->call_mutex);
a693 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a694 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a703 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a704 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a724 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a733 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
d739 1
a739 1
           const union pipe_color_union *color,
a745 1
   pipe_mutex_lock(rb_pipe->call_mutex);
d748 1
a748 1
               color,
a750 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
d756 1
a756 1
                         const union pipe_color_union *color,
a764 1
   pipe_mutex_lock(rb_pipe->call_mutex);
d767 1
a767 1
                             color,
a771 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a787 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a796 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
d801 16
a816 2
           struct pipe_fence_handle **fence,
           unsigned flags)
d819 1
d821 1
d823 4
a826 3
   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->flush(pipe, fence, flags);
   pipe_mutex_unlock(rb_pipe->call_mutex);
a839 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a842 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a867 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a870 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
d881 2
a882 7
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_surface *rb_surface = rbug_surface(_surface);

   pipe_mutex_lock(rb_pipe->call_mutex);
   rbug_surface_destroy(rb_pipe,
                        rb_surface);
   pipe_mutex_unlock(rb_pipe->call_mutex);
d887 2
a888 2
static void *
rbug_context_transfer_map(struct pipe_context *_context,
d892 1
a892 2
                          const struct pipe_box *box,
                          struct pipe_transfer **transfer)
a898 1
   void *map;
d900 27
a926 7
   pipe_mutex_lock(rb_pipe->call_mutex);
   map = context->transfer_map(context,
                               resource,
                               level,
                               usage,
                               box, &result);
   pipe_mutex_unlock(rb_pipe->call_mutex);
d928 2
a929 2
   *transfer = rbug_transfer_create(rb_pipe, rb_resource, result);
   return *transfer ? map : NULL;
d932 2
a943 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a946 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
a958 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a960 3
   rbug_transfer_destroy(rb_pipe,
                         rb_transfer);
   pipe_mutex_unlock(rb_pipe->call_mutex);
a978 1
   pipe_mutex_lock(rb_pipe->call_mutex);
a986 1
   pipe_mutex_unlock(rb_pipe->call_mutex);
d1009 1
d1052 2
a1053 2
   rb_pipe->base.set_scissor_states = rbug_set_scissor_states;
   rb_pipe->base.set_viewport_states = rbug_set_viewport_states;
d1064 1
d1069 2
a1078 4

   if (debug_get_bool_option("GALLIUM_RBUG_START_BLOCKED", FALSE)) {
      rb_pipe->draw_blocked = RBUG_BLOCK_BEFORE;
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d266 3
a268 3
rbug_bind_sampler_states(struct pipe_context *_pipe, unsigned shader,
                         unsigned start, unsigned count,
                         void **samplers)
d274 18
a291 1
   pipe->bind_sampler_states(pipe, shader, start, count, samplers);
d732 1
a732 1
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
d756 10
a765 1
   pipe->set_sampler_views(pipe, shader, start, num, views);
d771 16
a875 14
rbug_flush_resource(struct pipe_context *_pipe,
                    struct pipe_resource *_res)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_resource *rb_resource_res = rbug_resource(_res);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *res = rb_resource_res->resource;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->flush_resource(pipe, res);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
d1149 2
a1150 1
   rb_pipe->base.bind_sampler_states = rbug_bind_sampler_states;
d1178 2
a1179 1
   rb_pipe->base.set_sampler_views = rbug_set_sampler_views;
a1183 1
   rb_pipe->base.flush_resource = rbug_flush_resource;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a42 1
   struct rbug_screen *rb_screen = rbug_screen(_pipe->screen);
d46 1
a46 2
   rbug_screen_remove_from_list(rb_screen, contexts, rb_pipe);

d137 1
a137 2
                  unsigned query_type,
                  unsigned index)
a140 1
   struct pipe_query *query;
d143 2
a144 3
   query = pipe->create_query(pipe,
                              query_type,
                              index);
a145 1
   return query;
d757 1
a757 1
   if (num_buffers && _buffers) {
a801 43
static struct pipe_stream_output_target *
rbug_create_stream_output_target(struct pipe_context *_pipe,
                                 struct pipe_resource *_res,
                                 unsigned buffer_offset, unsigned buffer_size)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *res = rbug_resource_unwrap(_res);
   struct pipe_stream_output_target *target;

   pipe_mutex_lock(rb_pipe->call_mutex);
   target = pipe->create_stream_output_target(pipe, res, buffer_offset,
                                              buffer_size);
   pipe_mutex_unlock(rb_pipe->call_mutex);
   return target;
}

static void
rbug_stream_output_target_destroy(struct pipe_context *_pipe,
                                  struct pipe_stream_output_target *target)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->stream_output_target_destroy(pipe, target);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
rbug_set_stream_output_targets(struct pipe_context *_pipe,
                               unsigned num_targets,
                               struct pipe_stream_output_target **targets,
                               const unsigned *offsets)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct pipe_context *pipe = rb_pipe->pipe;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->set_stream_output_targets(pipe, num_targets, targets, offsets);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

a833 20
rbug_blit(struct pipe_context *_pipe, const struct pipe_blit_info *_blit_info)
{
   struct rbug_context *rb_pipe = rbug_context(_pipe);
   struct rbug_resource *rb_resource_dst = rbug_resource(_blit_info->dst.resource);
   struct rbug_resource *rb_resource_src = rbug_resource(_blit_info->src.resource);
   struct pipe_context *pipe = rb_pipe->pipe;
   struct pipe_resource *dst = rb_resource_dst->resource;
   struct pipe_resource *src = rb_resource_src->resource;
   struct pipe_blit_info blit_info;

   blit_info = *_blit_info;
   blit_info.dst.resource = dst;
   blit_info.src.resource = src;

   pipe_mutex_lock(rb_pipe->call_mutex);
   pipe->blit(pipe, &blit_info);
   pipe_mutex_unlock(rb_pipe->call_mutex);
}

static void
a1152 3
   rb_pipe->base.create_stream_output_target = rbug_create_stream_output_target;
   rb_pipe->base.stream_output_target_destroy = rbug_stream_output_target_destroy;
   rb_pipe->base.set_stream_output_targets = rbug_set_stream_output_targets;
a1153 1
   rb_pipe->base.blit = rbug_blit;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d43 1
d47 2
a48 1
   remove_from_list(&rb_pipe->list);
d139 2
a140 1
                  unsigned query_type)
d144 1
d147 3
a149 2
   return pipe->create_query(pipe,
                             query_type);
d151 1
d763 1
a763 1
   if (num_buffers) {
d808 43
d883 20
d1222 3
d1226 1
@


