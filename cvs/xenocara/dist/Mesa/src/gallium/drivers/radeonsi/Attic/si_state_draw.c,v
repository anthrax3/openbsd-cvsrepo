head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.12.41;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.12.41;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.13;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2014.09.07.15.03.12;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	dm8VnQHhowGHmemJ;

1.1.1.4
date	2015.01.25.14.08.37;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.45.52;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2012 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *      Christian KÃ¶nig <christian.koenig@@amd.com>
 */

#include "util/u_memory.h"
#include "util/u_framebuffer.h"
#include "util/u_blitter.h"
#include "tgsi/tgsi_parse.h"
#include "radeonsi_pipe.h"
#include "radeonsi_shader.h"
#include "si_state.h"
#include "sid.h"

/*
 * Shaders
 */

static void si_pipe_shader_vs(struct pipe_context *ctx, struct si_pipe_shader *shader)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct si_pm4_state *pm4;
	unsigned num_sgprs, num_user_sgprs;
	unsigned nparams, i, vgpr_comp_cnt;
	uint64_t va;

	si_pm4_delete_state(rctx, vs, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(rctx);

	if (pm4 == NULL)
		return;

	si_pm4_inval_shader_cache(pm4);

	/* Certain attributes (position, psize, etc.) don't count as params.
	 * VS is required to export at least one param and r600_shader_from_tgsi()
	 * takes care of adding a dummy export.
	 */
	for (nparams = 0, i = 0 ; i < shader->shader.noutput; i++) {
		switch (shader->shader.output[i].name) {
		case TGSI_SEMANTIC_POSITION:
		case TGSI_SEMANTIC_PSIZE:
			break;
		default:
			nparams++;
		}
	}
	if (nparams < 1)
		nparams = 1;

	si_pm4_set_reg(pm4, R_0286C4_SPI_VS_OUT_CONFIG,
		       S_0286C4_VS_EXPORT_COUNT(nparams - 1));

	si_pm4_set_reg(pm4, R_02870C_SPI_SHADER_POS_FORMAT,
		       S_02870C_POS0_EXPORT_FORMAT(V_02870C_SPI_SHADER_4COMP) |
		       S_02870C_POS1_EXPORT_FORMAT(shader->shader.nr_pos_exports > 1 ?
						   V_02870C_SPI_SHADER_4COMP :
						   V_02870C_SPI_SHADER_NONE) |
		       S_02870C_POS2_EXPORT_FORMAT(shader->shader.nr_pos_exports > 2 ?
						   V_02870C_SPI_SHADER_4COMP :
						   V_02870C_SPI_SHADER_NONE) |
		       S_02870C_POS3_EXPORT_FORMAT(shader->shader.nr_pos_exports > 3 ?
						   V_02870C_SPI_SHADER_4COMP :
						   V_02870C_SPI_SHADER_NONE));

	va = r600_resource_va(ctx->screen, (void *)shader->bo);
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ);
	si_pm4_set_reg(pm4, R_00B120_SPI_SHADER_PGM_LO_VS, va >> 8);
	si_pm4_set_reg(pm4, R_00B124_SPI_SHADER_PGM_HI_VS, va >> 40);

	num_user_sgprs = SI_VS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	if (num_user_sgprs > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 2;
	}
	assert(num_sgprs <= 104);

	vgpr_comp_cnt = shader->shader.uses_instanceid ? 3 : 0;

	si_pm4_set_reg(pm4, R_00B128_SPI_SHADER_PGM_RSRC1_VS,
		       S_00B128_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B128_SGPRS((num_sgprs - 1) / 8) |
		       S_00B128_VGPR_COMP_CNT(vgpr_comp_cnt));
	si_pm4_set_reg(pm4, R_00B12C_SPI_SHADER_PGM_RSRC2_VS,
		       S_00B12C_USER_SGPR(num_user_sgprs));

	if (rctx->chip_class >= CIK) {
		si_pm4_set_reg(pm4, R_00B118_SPI_SHADER_PGM_RSRC3_VS,
			       S_00B118_CU_EN(0xffff));
		si_pm4_set_reg(pm4, R_00B11C_SPI_SHADER_LATE_ALLOC_VS,
			       S_00B11C_LIMIT(0));
	}

	si_pm4_bind_state(rctx, vs, shader->pm4);
}

static void si_pipe_shader_ps(struct pipe_context *ctx, struct si_pipe_shader *shader)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct si_pm4_state *pm4;
	unsigned i, exports_ps, num_cout, spi_ps_in_control, db_shader_control;
	unsigned num_sgprs, num_user_sgprs;
	boolean have_linear = FALSE, have_centroid = FALSE, have_perspective = FALSE;
	unsigned fragcoord_interp_mode = 0;
	unsigned spi_baryc_cntl, spi_ps_input_ena, spi_shader_z_format;
	uint64_t va;

	si_pm4_delete_state(rctx, ps, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(rctx);

	if (pm4 == NULL)
		return;

	si_pm4_inval_shader_cache(pm4);

	db_shader_control = S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z);
	for (i = 0; i < shader->shader.ninput; i++) {
		switch (shader->shader.input[i].name) {
		case TGSI_SEMANTIC_POSITION:
			if (shader->shader.input[i].centroid) {
				/* fragcoord_interp_mode will be written to
				 * SPI_BARYC_CNTL.POS_FLOAT_LOCATION
				 * Possible vaules:
				 * 0 -> Position = pixel center (default)
				 * 1 -> Position = pixel centroid
				 * 2 -> Position = iterated sample number XXX:
				 *                        What does this mean?
			 	 */
				fragcoord_interp_mode = 1;
			}
			/* Fall through */
		case TGSI_SEMANTIC_FACE:
			continue;
		}

		if (shader->shader.input[i].interpolate == TGSI_INTERPOLATE_LINEAR)
			have_linear = TRUE;
		if (shader->shader.input[i].interpolate == TGSI_INTERPOLATE_PERSPECTIVE)
			have_perspective = TRUE;
		if (shader->shader.input[i].centroid)
			have_centroid = TRUE;
	}

	for (i = 0; i < shader->shader.noutput; i++) {
		if (shader->shader.output[i].name == TGSI_SEMANTIC_POSITION)
			db_shader_control |= S_02880C_Z_EXPORT_ENABLE(1);
		if (shader->shader.output[i].name == TGSI_SEMANTIC_STENCIL)
			db_shader_control |= S_02880C_STENCIL_TEST_VAL_EXPORT_ENABLE(1);
	}
	if (shader->shader.uses_kill || shader->key.ps.alpha_func != PIPE_FUNC_ALWAYS)
		db_shader_control |= S_02880C_KILL_ENABLE(1);

	exports_ps = 0;
	num_cout = 0;
	for (i = 0; i < shader->shader.noutput; i++) {
		if (shader->shader.output[i].name == TGSI_SEMANTIC_POSITION ||
		    shader->shader.output[i].name == TGSI_SEMANTIC_STENCIL)
			exports_ps |= 1;
		else if (shader->shader.output[i].name == TGSI_SEMANTIC_COLOR) {
			if (shader->shader.fs_write_all)
				num_cout = shader->shader.nr_cbufs;
			else
				num_cout++;
		}
	}
	if (!exports_ps) {
		/* always at least export 1 component per pixel */
		exports_ps = 2;
	}

	spi_ps_in_control = S_0286D8_NUM_INTERP(shader->shader.ninterp) |
		S_0286D8_BC_OPTIMIZE_DISABLE(1);

	spi_baryc_cntl = 0;
	if (have_perspective)
		spi_baryc_cntl |= have_centroid ?
			S_0286E0_PERSP_CENTROID_CNTL(1) : S_0286E0_PERSP_CENTER_CNTL(1);
	if (have_linear)
		spi_baryc_cntl |= have_centroid ?
			S_0286E0_LINEAR_CENTROID_CNTL(1) : S_0286E0_LINEAR_CENTER_CNTL(1);
	spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(fragcoord_interp_mode);

	si_pm4_set_reg(pm4, R_0286E0_SPI_BARYC_CNTL, spi_baryc_cntl);
	spi_ps_input_ena = shader->spi_ps_input_ena;
	/* we need to enable at least one of them, otherwise we hang the GPU */
	assert(G_0286CC_PERSP_SAMPLE_ENA(spi_ps_input_ena) ||
	    G_0286CC_PERSP_CENTER_ENA(spi_ps_input_ena) ||
	    G_0286CC_PERSP_CENTROID_ENA(spi_ps_input_ena) ||
	    G_0286CC_PERSP_PULL_MODEL_ENA(spi_ps_input_ena) ||
	    G_0286CC_LINEAR_SAMPLE_ENA(spi_ps_input_ena) ||
	    G_0286CC_LINEAR_CENTER_ENA(spi_ps_input_ena) ||
	    G_0286CC_LINEAR_CENTROID_ENA(spi_ps_input_ena) ||
	    G_0286CC_LINE_STIPPLE_TEX_ENA(spi_ps_input_ena));

	si_pm4_set_reg(pm4, R_0286CC_SPI_PS_INPUT_ENA, spi_ps_input_ena);
	si_pm4_set_reg(pm4, R_0286D0_SPI_PS_INPUT_ADDR, spi_ps_input_ena);
	si_pm4_set_reg(pm4, R_0286D8_SPI_PS_IN_CONTROL, spi_ps_in_control);

	if (G_02880C_STENCIL_TEST_VAL_EXPORT_ENABLE(db_shader_control))
		spi_shader_z_format = V_028710_SPI_SHADER_32_GR;
	else if (G_02880C_Z_EXPORT_ENABLE(db_shader_control))
		spi_shader_z_format = V_028710_SPI_SHADER_32_R;
	else
		spi_shader_z_format = 0;
	si_pm4_set_reg(pm4, R_028710_SPI_SHADER_Z_FORMAT, spi_shader_z_format);
	si_pm4_set_reg(pm4, R_028714_SPI_SHADER_COL_FORMAT,
		       shader->spi_shader_col_format);
	si_pm4_set_reg(pm4, R_02823C_CB_SHADER_MASK, shader->cb_shader_mask);

	va = r600_resource_va(ctx->screen, (void *)shader->bo);
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ);
	si_pm4_set_reg(pm4, R_00B020_SPI_SHADER_PGM_LO_PS, va >> 8);
	si_pm4_set_reg(pm4, R_00B024_SPI_SHADER_PGM_HI_PS, va >> 40);

	num_user_sgprs = SI_PS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	if (num_user_sgprs > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 2;
	}
	assert(num_sgprs <= 104);

	si_pm4_set_reg(pm4, R_00B028_SPI_SHADER_PGM_RSRC1_PS,
		       S_00B028_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B028_SGPRS((num_sgprs - 1) / 8));
	si_pm4_set_reg(pm4, R_00B02C_SPI_SHADER_PGM_RSRC2_PS,
		       S_00B02C_EXTRA_LDS_SIZE(shader->lds_size) |
		       S_00B02C_USER_SGPR(num_user_sgprs));
	if (rctx->chip_class >= CIK) {
		si_pm4_set_reg(pm4, R_00B01C_SPI_SHADER_PGM_RSRC3_PS,
			       S_00B01C_CU_EN(0xffff));
	}

	si_pm4_set_reg(pm4, R_02880C_DB_SHADER_CONTROL, db_shader_control);

	shader->sprite_coord_enable = rctx->sprite_coord_enable;
	si_pm4_bind_state(rctx, ps, shader->pm4);
}

/*
 * Drawing
 */

static unsigned si_conv_pipe_prim(unsigned pprim)
{
        static const unsigned prim_conv[] = {
		[PIPE_PRIM_POINTS]			= V_008958_DI_PT_POINTLIST,
		[PIPE_PRIM_LINES]			= V_008958_DI_PT_LINELIST,
		[PIPE_PRIM_LINE_LOOP]			= V_008958_DI_PT_LINELOOP,
		[PIPE_PRIM_LINE_STRIP]			= V_008958_DI_PT_LINESTRIP,
		[PIPE_PRIM_TRIANGLES]			= V_008958_DI_PT_TRILIST,
		[PIPE_PRIM_TRIANGLE_STRIP]		= V_008958_DI_PT_TRISTRIP,
		[PIPE_PRIM_TRIANGLE_FAN]		= V_008958_DI_PT_TRIFAN,
		[PIPE_PRIM_QUADS]			= V_008958_DI_PT_QUADLIST,
		[PIPE_PRIM_QUAD_STRIP]			= V_008958_DI_PT_QUADSTRIP,
		[PIPE_PRIM_POLYGON]			= V_008958_DI_PT_POLYGON,
		[PIPE_PRIM_LINES_ADJACENCY]		= ~0,
		[PIPE_PRIM_LINE_STRIP_ADJACENCY]	= ~0,
		[PIPE_PRIM_TRIANGLES_ADJACENCY]		= ~0,
		[PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY]	= ~0
        };
	unsigned result = prim_conv[pprim];
        if (result == ~0) {
		R600_ERR("unsupported primitive type %d\n", pprim);
        }
	return result;
}

static bool si_update_draw_info_state(struct r600_context *rctx,
			       const struct pipe_draw_info *info)
{
	struct si_pm4_state *pm4 = si_pm4_alloc_state(rctx);
	struct si_shader *vs = &rctx->vs_shader->current->shader;
	unsigned prim = si_conv_pipe_prim(info->mode);
	unsigned ls_mask = 0;

	if (pm4 == NULL)
		return false;

	if (prim == ~0) {
		FREE(pm4);
		return false;
	}

	if (rctx->chip_class >= CIK)
		si_pm4_set_reg(pm4, R_030908_VGT_PRIMITIVE_TYPE, prim);
	else
		si_pm4_set_reg(pm4, R_008958_VGT_PRIMITIVE_TYPE, prim);
	si_pm4_set_reg(pm4, R_028400_VGT_MAX_VTX_INDX, ~0);
	si_pm4_set_reg(pm4, R_028404_VGT_MIN_VTX_INDX, 0);
	si_pm4_set_reg(pm4, R_028408_VGT_INDX_OFFSET,
		       info->indexed ? info->index_bias : info->start);
	si_pm4_set_reg(pm4, R_02840C_VGT_MULTI_PRIM_IB_RESET_INDX, info->restart_index);
	si_pm4_set_reg(pm4, R_028A94_VGT_MULTI_PRIM_IB_RESET_EN, info->primitive_restart);
	si_pm4_set_reg(pm4, R_00B130_SPI_SHADER_USER_DATA_VS_0 + SI_SGPR_START_INSTANCE * 4,
		       info->start_instance);

        if (prim == V_008958_DI_PT_LINELIST)
                ls_mask = 1;
        else if (prim == V_008958_DI_PT_LINESTRIP)
                ls_mask = 2;
	si_pm4_set_reg(pm4, R_028A0C_PA_SC_LINE_STIPPLE,
		       S_028A0C_AUTO_RESET_CNTL(ls_mask) |
		       rctx->pa_sc_line_stipple);

        if (info->mode == PIPE_PRIM_QUADS || info->mode == PIPE_PRIM_QUAD_STRIP || info->mode == PIPE_PRIM_POLYGON) {
		si_pm4_set_reg(pm4, R_028814_PA_SU_SC_MODE_CNTL,
			       S_028814_PROVOKING_VTX_LAST(1) | rctx->pa_su_sc_mode_cntl);
        } else {
		si_pm4_set_reg(pm4, R_028814_PA_SU_SC_MODE_CNTL, rctx->pa_su_sc_mode_cntl);
        }
	si_pm4_set_reg(pm4, R_02881C_PA_CL_VS_OUT_CNTL,
		       S_02881C_USE_VTX_POINT_SIZE(vs->vs_out_point_size) |
		       S_02881C_VS_OUT_CCDIST0_VEC_ENA((vs->clip_dist_write & 0x0F) != 0) |
		       S_02881C_VS_OUT_CCDIST1_VEC_ENA((vs->clip_dist_write & 0xF0) != 0) |
		       S_02881C_VS_OUT_MISC_VEC_ENA(vs->vs_out_misc_write) |
		       (rctx->queued.named.rasterizer->clip_plane_enable &
			vs->clip_dist_write));
	si_pm4_set_reg(pm4, R_028810_PA_CL_CLIP_CNTL,
		       rctx->queued.named.rasterizer->pa_cl_clip_cntl |
		       (vs->clip_dist_write ? 0 :
			rctx->queued.named.rasterizer->clip_plane_enable & 0x3F));

	si_pm4_set_state(rctx, draw_info, pm4);
	return true;
}

static void si_update_spi_map(struct r600_context *rctx)
{
	struct si_shader *ps = &rctx->ps_shader->current->shader;
	struct si_shader *vs = &rctx->vs_shader->current->shader;
	struct si_pm4_state *pm4 = si_pm4_alloc_state(rctx);
	unsigned i, j, tmp;

	for (i = 0; i < ps->ninput; i++) {
		unsigned name = ps->input[i].name;
		unsigned param_offset = ps->input[i].param_offset;

		if (name == TGSI_SEMANTIC_POSITION)
			/* Read from preloaded VGPRs, not parameters */
			continue;

bcolor:
		tmp = 0;

		if (ps->input[i].interpolate == TGSI_INTERPOLATE_CONSTANT ||
		    (ps->input[i].interpolate == TGSI_INTERPOLATE_COLOR &&
		     rctx->ps_shader->current->key.ps.flatshade)) {
			tmp |= S_028644_FLAT_SHADE(1);
		}

		if (name == TGSI_SEMANTIC_GENERIC &&
		    rctx->sprite_coord_enable & (1 << ps->input[i].sid)) {
			tmp |= S_028644_PT_SPRITE_TEX(1);
		}

		for (j = 0; j < vs->noutput; j++) {
			if (name == vs->output[j].name &&
			    ps->input[i].sid == vs->output[j].sid) {
				tmp |= S_028644_OFFSET(vs->output[j].param_offset);
				break;
			}
		}

		if (j == vs->noutput) {
			/* No corresponding output found, load defaults into input */
			tmp |= S_028644_OFFSET(0x20);
		}

		si_pm4_set_reg(pm4,
			       R_028644_SPI_PS_INPUT_CNTL_0 + param_offset * 4,
			       tmp);

		if (name == TGSI_SEMANTIC_COLOR &&
		    rctx->ps_shader->current->key.ps.color_two_side) {
			name = TGSI_SEMANTIC_BCOLOR;
			param_offset++;
			goto bcolor;
		}
	}

	si_pm4_set_state(rctx, spi, pm4);
}

static void si_update_derived_state(struct r600_context *rctx)
{
	struct pipe_context * ctx = (struct pipe_context*)rctx;
	unsigned vs_dirty = 0, ps_dirty = 0;

	if (!rctx->blitter->running) {
		/* Flush depth textures which need to be flushed. */
		if (rctx->vs_samplers.depth_texture_mask) {
			si_flush_depth_textures(rctx, &rctx->vs_samplers);
		}
		if (rctx->ps_samplers.depth_texture_mask) {
			si_flush_depth_textures(rctx, &rctx->ps_samplers);
		}
	}

	si_shader_select(ctx, rctx->vs_shader, &vs_dirty);

	if (!rctx->vs_shader->current->pm4) {
		si_pipe_shader_vs(ctx, rctx->vs_shader->current);
		vs_dirty = 0;
	}

	if (vs_dirty) {
		si_pm4_bind_state(rctx, vs, rctx->vs_shader->current->pm4);
	}


	si_shader_select(ctx, rctx->ps_shader, &ps_dirty);

	if (!rctx->ps_shader->current->pm4) {
		si_pipe_shader_ps(ctx, rctx->ps_shader->current);
		ps_dirty = 0;
	}
	if (!rctx->ps_shader->current->bo) {
		if (!rctx->dummy_pixel_shader->pm4)
			si_pipe_shader_ps(ctx, rctx->dummy_pixel_shader);
		else
			si_pm4_bind_state(rctx, vs, rctx->dummy_pixel_shader->pm4);

		ps_dirty = 0;
	}

	if (ps_dirty) {
		si_pm4_bind_state(rctx, ps, rctx->ps_shader->current->pm4);
	}

	if (si_pm4_state_changed(rctx, ps) || si_pm4_state_changed(rctx, vs)) {
		/* XXX: Emitting the PS state even when only the VS changed
		 * fixes random failures with piglit glsl-max-varyings.
		 * Not sure why...
		 */
		rctx->emitted.named.ps = NULL;
		si_update_spi_map(rctx);
	}
}

static void si_constant_buffer_update(struct r600_context *rctx)
{
	struct pipe_context *ctx = &rctx->context;
	struct si_pm4_state *pm4;
	unsigned shader, i;
	uint64_t va;

	if (!rctx->constbuf_state[PIPE_SHADER_VERTEX].dirty_mask &&
	    !rctx->constbuf_state[PIPE_SHADER_FRAGMENT].dirty_mask)
		return;

	for (shader = PIPE_SHADER_VERTEX ; shader <= PIPE_SHADER_FRAGMENT; shader++) {
		struct r600_constbuf_state *state = &rctx->constbuf_state[shader];

		pm4 = CALLOC_STRUCT(si_pm4_state);
		if (!pm4)
			continue;

		si_pm4_inval_shader_cache(pm4);
		si_pm4_sh_data_begin(pm4);

		for (i = 0; i < 2; i++) {
			if (state->enabled_mask & (1 << i)) {
				struct pipe_constant_buffer *cb = &state->cb[i];
				struct si_resource *rbuffer = si_resource(cb->buffer);

				va = r600_resource_va(ctx->screen, (void*)rbuffer);
				va += cb->buffer_offset;

				si_pm4_add_bo(pm4, rbuffer, RADEON_USAGE_READ);

				/* Fill in a T# buffer resource description */
				si_pm4_sh_data_add(pm4, va);
				si_pm4_sh_data_add(pm4, (S_008F04_BASE_ADDRESS_HI(va >> 32) |
							 S_008F04_STRIDE(0)));
				si_pm4_sh_data_add(pm4, cb->buffer_size);
				si_pm4_sh_data_add(pm4, S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) |
						   S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
						   S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) |
						   S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W) |
						   S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) |
						   S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32));
			} else {
				/* Fill in an empty T# buffer resource description */
				si_pm4_sh_data_add(pm4, 0);
				si_pm4_sh_data_add(pm4, 0);
				si_pm4_sh_data_add(pm4, 0);
				si_pm4_sh_data_add(pm4, 0);
			}
		}

		switch (shader) {
		case PIPE_SHADER_VERTEX:
			si_pm4_sh_data_end(pm4, R_00B130_SPI_SHADER_USER_DATA_VS_0, SI_SGPR_CONST);
			si_pm4_set_state(rctx, vs_const, pm4);
			break;

		case PIPE_SHADER_FRAGMENT:
			si_pm4_sh_data_end(pm4, R_00B030_SPI_SHADER_USER_DATA_PS_0, SI_SGPR_CONST);
			si_pm4_set_state(rctx, ps_const, pm4);
			break;

		default:
			R600_ERR("unsupported %d\n", shader);
			FREE(pm4);
			return;
		}

		state->dirty_mask = 0;
	}
}

static void si_vertex_buffer_update(struct r600_context *rctx)
{
	struct pipe_context *ctx = &rctx->context;
	struct si_pm4_state *pm4 = si_pm4_alloc_state(rctx);
	bool bound[PIPE_MAX_ATTRIBS] = {};
	unsigned i, count;
	uint64_t va;

	si_pm4_inval_texture_cache(pm4);

	/* bind vertex buffer once */
	count = rctx->vertex_elements->count;
	assert(count <= 256 / 4);

	si_pm4_sh_data_begin(pm4);
	for (i = 0 ; i < count; i++) {
		struct pipe_vertex_element *ve = &rctx->vertex_elements->elements[i];
		struct pipe_vertex_buffer *vb;
		struct si_resource *rbuffer;
		unsigned offset;

		if (ve->vertex_buffer_index >= rctx->nr_vertex_buffers)
			continue;

		vb = &rctx->vertex_buffer[ve->vertex_buffer_index];
		rbuffer = (struct si_resource*)vb->buffer;
		if (rbuffer == NULL)
			continue;

		offset = 0;
		offset += vb->buffer_offset;
		offset += ve->src_offset;

		va = r600_resource_va(ctx->screen, (void*)rbuffer);
		va += offset;

		/* Fill in T# buffer resource description */
		si_pm4_sh_data_add(pm4, va & 0xFFFFFFFF);
		si_pm4_sh_data_add(pm4, (S_008F04_BASE_ADDRESS_HI(va >> 32) |
					 S_008F04_STRIDE(vb->stride)));
		if (vb->stride)
			/* Round up by rounding down and adding 1 */
			si_pm4_sh_data_add(pm4,
					   (vb->buffer->width0 - offset -
					    util_format_get_blocksize(ve->src_format)) /
					   vb->stride + 1);
		else
			si_pm4_sh_data_add(pm4, vb->buffer->width0 - offset);
		si_pm4_sh_data_add(pm4, rctx->vertex_elements->rsrc_word3[i]);

		if (!bound[ve->vertex_buffer_index]) {
			si_pm4_add_bo(pm4, rbuffer, RADEON_USAGE_READ);
			bound[ve->vertex_buffer_index] = true;
		}
	}
	si_pm4_sh_data_end(pm4, R_00B130_SPI_SHADER_USER_DATA_VS_0, SI_SGPR_VERTEX_BUFFER);
	si_pm4_set_state(rctx, vertex_buffers, pm4);
}

static void si_state_draw(struct r600_context *rctx,
			  const struct pipe_draw_info *info,
			  const struct pipe_index_buffer *ib)
{
	struct si_pm4_state *pm4 = si_pm4_alloc_state(rctx);

	if (pm4 == NULL)
		return;

	/* queries need some special values
	 * (this is non-zero if any query is active) */
	if (rctx->num_cs_dw_queries_suspend) {
		struct si_state_dsa *dsa = rctx->queued.named.dsa;

		si_pm4_set_reg(pm4, R_028004_DB_COUNT_CONTROL,
			       S_028004_PERFECT_ZPASS_COUNTS(1));
		si_pm4_set_reg(pm4, R_02800C_DB_RENDER_OVERRIDE,
			       dsa->db_render_override |
			       S_02800C_NOOP_CULL_DISABLE(1));
	}

	/* draw packet */
	si_pm4_cmd_begin(pm4, PKT3_INDEX_TYPE);
	if (ib->index_size == 4) {
		si_pm4_cmd_add(pm4, V_028A7C_VGT_INDEX_32 | (R600_BIG_ENDIAN ?
				V_028A7C_VGT_DMA_SWAP_32_BIT : 0));
	} else {
		si_pm4_cmd_add(pm4, V_028A7C_VGT_INDEX_16 | (R600_BIG_ENDIAN ?
				V_028A7C_VGT_DMA_SWAP_16_BIT : 0));
	}
	si_pm4_cmd_end(pm4, rctx->predicate_drawing);

	si_pm4_cmd_begin(pm4, PKT3_NUM_INSTANCES);
	si_pm4_cmd_add(pm4, info->instance_count);
	si_pm4_cmd_end(pm4, rctx->predicate_drawing);

	if (info->indexed) {
		uint32_t max_size = (ib->buffer->width0 - ib->offset) /
				 rctx->index_buffer.index_size;
		uint64_t va;
		va = r600_resource_va(&rctx->screen->screen, ib->buffer);
		va += ib->offset;

		si_pm4_add_bo(pm4, (struct si_resource *)ib->buffer, RADEON_USAGE_READ);
		si_cmd_draw_index_2(pm4, max_size, va, info->count,
				    V_0287F0_DI_SRC_SEL_DMA,
				    rctx->predicate_drawing);
	} else {
		uint32_t initiator = V_0287F0_DI_SRC_SEL_AUTO_INDEX;
		initiator |= S_0287F0_USE_OPAQUE(!!info->count_from_stream_output);
		si_cmd_draw_index_auto(pm4, info->count, initiator, rctx->predicate_drawing);
	}
	si_pm4_set_state(rctx, draw, pm4);
}

void si_draw_vbo(struct pipe_context *ctx, const struct pipe_draw_info *info)
{
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct pipe_index_buffer ib = {};
	uint32_t cp_coher_cntl;

	if (!info->count && (info->indexed || !info->count_from_stream_output))
		return;

	if (!rctx->ps_shader || !rctx->vs_shader)
		return;

	si_update_derived_state(rctx);
	si_constant_buffer_update(rctx);
	si_vertex_buffer_update(rctx);

	if (info->indexed) {
		/* Initialize the index buffer struct. */
		pipe_resource_reference(&ib.buffer, rctx->index_buffer.buffer);
		ib.user_buffer = rctx->index_buffer.user_buffer;
		ib.index_size = rctx->index_buffer.index_size;
		ib.offset = rctx->index_buffer.offset + info->start * ib.index_size;

		/* Translate or upload, if needed. */
		r600_translate_index_buffer(rctx, &ib, info->count);

		if (ib.user_buffer && !ib.buffer) {
			r600_upload_index_buffer(rctx, &ib, info->count);
		}

	} else if (info->count_from_stream_output) {
		r600_context_draw_opaque_count(rctx, (struct r600_so_target*)info->count_from_stream_output);
	}

	rctx->vs_shader_so_strides = rctx->vs_shader->current->so_strides;

	if (!si_update_draw_info_state(rctx, info))
		return;

	si_state_draw(rctx, info, &ib);

	cp_coher_cntl = si_pm4_sync_flags(rctx);
	if (cp_coher_cntl) {
		struct si_pm4_state *pm4 = si_pm4_alloc_state(rctx);

		if (pm4 == NULL)
			return;

		si_cmd_surface_sync(pm4, cp_coher_cntl);
		si_pm4_set_state(rctx, sync, pm4);
	}

	/* Emit states. */
	rctx->pm4_dirty_cdwords += si_pm4_dirty_dw(rctx);

	si_need_cs_space(rctx, 0, TRUE);

	si_pm4_emit_dirty(rctx);
	rctx->pm4_dirty_cdwords = 0;

#if R600_TRACE_CS
	if (rctx->screen->trace_bo) {
		r600_trace_emit(rctx);
	}
#endif

#if 0
	/* Enable stream out if needed. */
	if (rctx->streamout_start) {
		r600_context_streamout_begin(rctx);
		rctx->streamout_start = FALSE;
	}
#endif

	rctx->flags |= R600_CONTEXT_DST_CACHES_DIRTY;

	/* Set the depth buffer as dirty. */
	if (rctx->framebuffer.zsbuf) {
		struct pipe_surface *surf = rctx->framebuffer.zsbuf;
		struct r600_resource_texture *rtex = (struct r600_resource_texture *)surf->texture;

		rtex->dirty_db_mask |= 1 << surf->u.tex.level;
	}

	pipe_resource_reference(&ib.buffer, NULL);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d27 7
a33 3
#include "si_pipe.h"
#include "si_shader.h"
#include "../radeon/r600_cs.h"
a35 6
#include "util/u_blitter.h"
#include "util/u_format.h"
#include "util/u_index_modify.h"
#include "util/u_memory.h"
#include "util/u_upload_mgr.h"

a39 112
static void si_pipe_shader_es(struct pipe_context *ctx, struct si_pipe_shader *shader)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_pm4_state *pm4;
	unsigned num_sgprs, num_user_sgprs;
	unsigned vgpr_comp_cnt;
	uint64_t va;

	si_pm4_delete_state(sctx, es, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(sctx);

	if (pm4 == NULL)
		return;

	va = r600_resource_va(ctx->screen, (void *)shader->bo);
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);

	vgpr_comp_cnt = shader->shader.uses_instanceid ? 3 : 0;

	num_user_sgprs = SI_VS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	/* One SGPR after user SGPRs is pre-loaded with es2gs_offset */
	if ((num_user_sgprs + 1) > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 1 + 2;
	}
	assert(num_sgprs <= 104);

	si_pm4_set_reg(pm4, R_00B320_SPI_SHADER_PGM_LO_ES, va >> 8);
	si_pm4_set_reg(pm4, R_00B324_SPI_SHADER_PGM_HI_ES, va >> 40);
	si_pm4_set_reg(pm4, R_00B328_SPI_SHADER_PGM_RSRC1_ES,
		       S_00B328_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B328_SGPRS((num_sgprs - 1) / 8) |
		       S_00B328_VGPR_COMP_CNT(vgpr_comp_cnt));
	si_pm4_set_reg(pm4, R_00B32C_SPI_SHADER_PGM_RSRC2_ES,
		       S_00B32C_USER_SGPR(num_user_sgprs));

	sctx->b.flags |= R600_CONTEXT_INV_SHADER_CACHE;
}

static void si_pipe_shader_gs(struct pipe_context *ctx, struct si_pipe_shader *shader)
{
	struct si_context *sctx = (struct si_context *)ctx;
	unsigned gs_vert_itemsize = shader->shader.noutput * (16 >> 2);
	unsigned gs_max_vert_out = shader->shader.gs_max_out_vertices;
	unsigned gsvs_itemsize = gs_vert_itemsize * gs_max_vert_out;
	unsigned cut_mode;
	struct si_pm4_state *pm4;
	unsigned num_sgprs, num_user_sgprs;
	uint64_t va;

	/* The GSVS_RING_ITEMSIZE register takes 15 bits */
	assert(gsvs_itemsize < (1 << 15));

	si_pm4_delete_state(sctx, gs, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(sctx);

	if (pm4 == NULL)
		return;

	if (gs_max_vert_out <= 128) {
		cut_mode = V_028A40_GS_CUT_128;
	} else if (gs_max_vert_out <= 256) {
		cut_mode = V_028A40_GS_CUT_256;
	} else if (gs_max_vert_out <= 512) {
		cut_mode = V_028A40_GS_CUT_512;
	} else {
		assert(gs_max_vert_out <= 1024);
		cut_mode = V_028A40_GS_CUT_1024;
	}

	si_pm4_set_reg(pm4, R_028A40_VGT_GS_MODE,
		       S_028A40_MODE(V_028A40_GS_SCENARIO_G) |
		       S_028A40_CUT_MODE(cut_mode)|
		       S_028A40_ES_WRITE_OPTIMIZE(1) |
		       S_028A40_GS_WRITE_OPTIMIZE(1));

	si_pm4_set_reg(pm4, R_028A60_VGT_GSVS_RING_OFFSET_1, gsvs_itemsize);
	si_pm4_set_reg(pm4, R_028A64_VGT_GSVS_RING_OFFSET_2, gsvs_itemsize);
	si_pm4_set_reg(pm4, R_028A68_VGT_GSVS_RING_OFFSET_3, gsvs_itemsize);

	si_pm4_set_reg(pm4, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
		       shader->shader.nparam * (16 >> 2));
	si_pm4_set_reg(pm4, R_028AB0_VGT_GSVS_RING_ITEMSIZE, gsvs_itemsize);

	si_pm4_set_reg(pm4, R_028B38_VGT_GS_MAX_VERT_OUT, gs_max_vert_out);

	si_pm4_set_reg(pm4, R_028B5C_VGT_GS_VERT_ITEMSIZE, gs_vert_itemsize);

	va = r600_resource_va(ctx->screen, (void *)shader->bo);
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);
	si_pm4_set_reg(pm4, R_00B220_SPI_SHADER_PGM_LO_GS, va >> 8);
	si_pm4_set_reg(pm4, R_00B224_SPI_SHADER_PGM_HI_GS, va >> 40);

	num_user_sgprs = SI_GS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	/* Two SGPRs after user SGPRs are pre-loaded with gs2vs_offset, gs_wave_id */
	if ((num_user_sgprs + 2) > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 2 + 2;
	}
	assert(num_sgprs <= 104);

	si_pm4_set_reg(pm4, R_00B228_SPI_SHADER_PGM_RSRC1_GS,
		       S_00B228_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B228_SGPRS((num_sgprs - 1) / 8));
	si_pm4_set_reg(pm4, R_00B22C_SPI_SHADER_PGM_RSRC2_GS,
		       S_00B22C_USER_SGPR(num_user_sgprs));

	sctx->b.flags |= R600_CONTEXT_INV_SHADER_CACHE;
}

d42 1
a42 1
	struct si_context *sctx = (struct si_context *)ctx;
d48 2
a49 2
	si_pm4_delete_state(sctx, vs, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(sctx);
d54 1
a54 12
	va = r600_resource_va(ctx->screen, (void *)shader->bo);
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);

	vgpr_comp_cnt = shader->shader.uses_instanceid ? 3 : 0;

	num_user_sgprs = SI_VS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	if (num_user_sgprs > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 2;
	}
	assert(num_sgprs <= 104);
a61 1
		case TGSI_SEMANTIC_CLIPVERTEX:
d87 2
d91 11
d107 1
a107 6
		       S_00B12C_USER_SGPR(num_user_sgprs) |
		       S_00B12C_SO_BASE0_EN(!!shader->selector->so.stride[0]) |
		       S_00B12C_SO_BASE1_EN(!!shader->selector->so.stride[1]) |
		       S_00B12C_SO_BASE2_EN(!!shader->selector->so.stride[2]) |
		       S_00B12C_SO_BASE3_EN(!!shader->selector->so.stride[3]) |
		       S_00B12C_SO_EN(!!shader->selector->so.num_outputs));
d109 8
a116 1
	sctx->b.flags |= R600_CONTEXT_INV_SHADER_CACHE;
d121 1
a121 1
	struct si_context *sctx = (struct si_context *)ctx;
d123 1
a123 1
	unsigned i, exports_ps, spi_ps_in_control, db_shader_control;
d125 3
a127 1
	unsigned spi_baryc_cntl = 0, spi_ps_input_ena, spi_shader_z_format;
d130 2
a131 2
	si_pm4_delete_state(sctx, ps, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(sctx);
d136 1
a136 2
	db_shader_control = S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z) |
			    S_02880C_ALPHA_TO_MASK_DISABLE(sctx->framebuffer.cb0_is_integer);
d138 1
d143 2
a144 1
				/* SPI_BARYC_CNTL.POS_FLOAT_LOCATION
d151 1
a151 1
				spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(1);
d157 7
d176 1
d181 6
d193 1
a193 1
	spi_ps_in_control = S_0286D8_NUM_INTERP(shader->shader.nparam) |
d196 9
d233 1
a233 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);
d239 1
a239 2
	/* One SGPR after user SGPRs is pre-loaded with {prim_mask, lds_offset} */
	if ((num_user_sgprs + 1) > num_sgprs) {
d241 1
a241 1
		num_sgprs = num_user_sgprs + 1 + 2;
d251 4
d258 2
a259 3
	shader->cb0_is_integer = sctx->framebuffer.cb0_is_integer;
	shader->sprite_coord_enable = sctx->sprite_coord_enable;
	sctx->b.flags |= R600_CONTEXT_INV_SHADER_CACHE;
d279 4
a282 4
		[PIPE_PRIM_LINES_ADJACENCY]		= V_008958_DI_PT_LINELIST_ADJ,
		[PIPE_PRIM_LINE_STRIP_ADJACENCY]	= V_008958_DI_PT_LINESTRIP_ADJ,
		[PIPE_PRIM_TRIANGLES_ADJACENCY]		= V_008958_DI_PT_TRILIST_ADJ,
		[PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY]	= V_008958_DI_PT_TRISTRIP_ADJ
d291 2
a292 1
static unsigned si_conv_prim_to_gs_out(unsigned mode)
d294 2
a295 27
	static const int prim_conv[] = {
		[PIPE_PRIM_POINTS]			= V_028A6C_OUTPRIM_TYPE_POINTLIST,
		[PIPE_PRIM_LINES]			= V_028A6C_OUTPRIM_TYPE_LINESTRIP,
		[PIPE_PRIM_LINE_LOOP]			= V_028A6C_OUTPRIM_TYPE_LINESTRIP,
		[PIPE_PRIM_LINE_STRIP]			= V_028A6C_OUTPRIM_TYPE_LINESTRIP,
		[PIPE_PRIM_TRIANGLES]			= V_028A6C_OUTPRIM_TYPE_TRISTRIP,
		[PIPE_PRIM_TRIANGLE_STRIP]		= V_028A6C_OUTPRIM_TYPE_TRISTRIP,
		[PIPE_PRIM_TRIANGLE_FAN]		= V_028A6C_OUTPRIM_TYPE_TRISTRIP,
		[PIPE_PRIM_QUADS]			= V_028A6C_OUTPRIM_TYPE_TRISTRIP,
		[PIPE_PRIM_QUAD_STRIP]			= V_028A6C_OUTPRIM_TYPE_TRISTRIP,
		[PIPE_PRIM_POLYGON]			= V_028A6C_OUTPRIM_TYPE_TRISTRIP,
		[PIPE_PRIM_LINES_ADJACENCY]		= V_028A6C_OUTPRIM_TYPE_LINESTRIP,
		[PIPE_PRIM_LINE_STRIP_ADJACENCY]	= V_028A6C_OUTPRIM_TYPE_LINESTRIP,
		[PIPE_PRIM_TRIANGLES_ADJACENCY]		= V_028A6C_OUTPRIM_TYPE_TRISTRIP,
		[PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY]	= V_028A6C_OUTPRIM_TYPE_TRISTRIP
	};
	assert(mode < Elements(prim_conv));

	return prim_conv[mode];
}

static bool si_update_draw_info_state(struct si_context *sctx,
				      const struct pipe_draw_info *info,
				      const struct pipe_index_buffer *ib)
{
	struct si_pm4_state *pm4 = si_pm4_alloc_state(sctx);
	struct si_shader *vs = si_get_vs_state(sctx);
a296 4
	unsigned gs_out_prim =
		si_conv_prim_to_gs_out(sctx->gs_shader ?
				       sctx->gs_shader->current->shader.gs_output_prim :
				       info->mode);
d307 1
a307 19
	if (sctx->b.chip_class >= CIK) {
		struct si_state_rasterizer *rs = sctx->queued.named.rasterizer;
		bool wd_switch_on_eop = prim == V_008958_DI_PT_POLYGON ||
					prim == V_008958_DI_PT_LINELOOP ||
					prim == V_008958_DI_PT_TRIFAN ||
					prim == V_008958_DI_PT_TRISTRIP_ADJ ||
					info->primitive_restart ||
					(rs ? rs->line_stipple_enable : false);
		/* If the WD switch is false, the IA switch must be false too. */
		bool ia_switch_on_eop = wd_switch_on_eop;

		si_pm4_set_reg(pm4, R_028AA8_IA_MULTI_VGT_PARAM,
			       S_028AA8_SWITCH_ON_EOP(ia_switch_on_eop) |
			       S_028AA8_PARTIAL_VS_WAVE_ON(1) |
			       S_028AA8_PRIMGROUP_SIZE(63) |
			       S_028AA8_WD_SWITCH_ON_EOP(wd_switch_on_eop));
		si_pm4_set_reg(pm4, R_028B74_VGT_DISPATCH_DRAW_INDEX,
			       ib->index_size == 4 ? 0xFC000000 : 0xFC00);

d309 1
a309 1
	} else {
d311 2
a312 3
	}

	si_pm4_set_reg(pm4, R_028A6C_VGT_GS_OUT_PRIM_TYPE, gs_out_prim);
d317 1
a317 3
	si_pm4_set_reg(pm4, SI_SGPR_START_INSTANCE * 4 +
		       (sctx->gs_shader ? R_00B330_SPI_SHADER_USER_DATA_ES_0 :
			R_00B130_SPI_SHADER_USER_DATA_VS_0),
d326 1
a326 1
		       sctx->pa_sc_line_stipple);
d330 1
a330 1
			       S_028814_PROVOKING_VTX_LAST(1) | sctx->pa_su_sc_mode_cntl);
d332 1
a332 1
		si_pm4_set_reg(pm4, R_028814_PA_SU_SC_MODE_CNTL, sctx->pa_su_sc_mode_cntl);
a335 2
		       S_02881C_USE_VTX_EDGE_FLAG(vs->vs_out_edgeflag) |
		       S_02881C_USE_VTX_RENDER_TARGET_INDX(vs->vs_out_layer) |
d339 1
a339 1
		       (sctx->queued.named.rasterizer->clip_plane_enable &
d342 1
a342 1
		       sctx->queued.named.rasterizer->pa_cl_clip_cntl |
d344 1
a344 1
			sctx->queued.named.rasterizer->clip_plane_enable & 0x3F));
d346 1
a346 1
	si_pm4_set_state(sctx, draw_info, pm4);
d350 1
a350 1
static void si_update_spi_map(struct si_context *sctx)
d352 3
a354 3
	struct si_shader *ps = &sctx->ps_shader->current->shader;
	struct si_shader *vs = si_get_vs_state(sctx);
	struct si_pm4_state *pm4 = si_pm4_alloc_state(sctx);
d370 1
a370 1
		     sctx->ps_shader->current->key.ps.flatshade)) {
d375 1
a375 1
		    sctx->sprite_coord_enable & (1 << ps->input[i].sid)) {
d397 1
a397 1
		    sctx->ps_shader->current->key.ps.color_two_side) {
d404 1
a404 43
	si_pm4_set_state(sctx, spi, pm4);
}

/* Initialize state related to ESGS / GSVS ring buffers */
static void si_init_gs_rings(struct si_context *sctx)
{
	unsigned size = 128 * 1024;

	assert(!sctx->gs_rings);
	sctx->gs_rings = si_pm4_alloc_state(sctx);

	sctx->esgs_ring.buffer =
		pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
				   PIPE_USAGE_DEFAULT, size);
	sctx->esgs_ring.buffer_size = size;

	size = 64 * 1024 * 1024;
	sctx->gsvs_ring.buffer =
		pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
				   PIPE_USAGE_DEFAULT, size);
	sctx->gsvs_ring.buffer_size = size;

	if (sctx->b.chip_class >= CIK) {
		si_pm4_set_reg(sctx->gs_rings, R_030900_VGT_ESGS_RING_SIZE,
			       sctx->esgs_ring.buffer_size / 256);
		si_pm4_set_reg(sctx->gs_rings, R_030904_VGT_GSVS_RING_SIZE,
			       sctx->gsvs_ring.buffer_size / 256);
	} else {
		si_pm4_set_reg(sctx->gs_rings, R_0088C8_VGT_ESGS_RING_SIZE,
			       sctx->esgs_ring.buffer_size / 256);
		si_pm4_set_reg(sctx->gs_rings, R_0088CC_VGT_GSVS_RING_SIZE,
			       sctx->gsvs_ring.buffer_size / 256);
	}

	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_VERTEX, SI_RING_ESGS,
			   &sctx->esgs_ring, 0, sctx->esgs_ring.buffer_size,
			   true, true, 4, 64);
	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_GEOMETRY, SI_RING_ESGS,
			   &sctx->esgs_ring, 0, sctx->esgs_ring.buffer_size,
			   false, false, 0, 0);
	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_VERTEX, SI_RING_GSVS,
			   &sctx->gsvs_ring, 0, sctx->gsvs_ring.buffer_size,
			   false, false, 0, 0);
d407 1
a407 1
static void si_update_derived_state(struct si_context *sctx)
d409 2
a410 1
	struct pipe_context * ctx = (struct pipe_context*)sctx;
d412 1
a412 1
	if (!sctx->blitter->running) {
d414 5
a418 7
		for (int i = 0; i < SI_NUM_SHADERS; i++) {
			if (sctx->samplers[i].depth_texture_mask) {
				si_flush_depth_textures(sctx, &sctx->samplers[i]);
			}
			if (sctx->samplers[i].compressed_colortex_mask) {
				si_decompress_color_textures(sctx, &sctx->samplers[i]);
			}
d422 1
a422 2
	if (sctx->gs_shader) {
		si_shader_select(ctx, sctx->gs_shader);
d424 4
a427 5
		if (!sctx->gs_shader->current->pm4) {
			si_pipe_shader_gs(ctx, sctx->gs_shader->current);
			si_pipe_shader_vs(ctx,
					  sctx->gs_shader->current->gs_copy_shader);
		}
d429 3
a431 2
		si_pm4_bind_state(sctx, gs, sctx->gs_shader->current->pm4);
		si_pm4_bind_state(sctx, vs, sctx->gs_shader->current->gs_copy_shader->pm4);
a432 1
		sctx->b.streamout.stride_in_dw = sctx->gs_shader->so.stride;
d434 1
a434 1
		si_shader_select(ctx, sctx->vs_shader);
d436 9
a444 2
		if (!sctx->vs_shader->current->pm4)
			si_pipe_shader_es(ctx, sctx->vs_shader->current);
d446 2
a447 1
		si_pm4_bind_state(sctx, es, sctx->vs_shader->current->pm4);
d449 3
a451 5
		if (!sctx->gs_rings)
			si_init_gs_rings(sctx);
		if (sctx->emitted.named.gs_rings != sctx->gs_rings)
			sctx->b.flags |= R600_CONTEXT_VGT_FLUSH;
		si_pm4_bind_state(sctx, gs_rings, sctx->gs_rings);
d453 9
a461 5
		si_set_ring_buffer(ctx, PIPE_SHADER_GEOMETRY, SI_RING_GSVS,
				   &sctx->gsvs_ring,
				   sctx->gs_shader->current->shader.gs_max_out_vertices *
				   sctx->gs_shader->current->shader.noutput * 16,
				   64, true, true, 4, 16);
d463 6
a468 2
		if (!sctx->gs_on) {
			sctx->gs_on = si_pm4_alloc_state(sctx);
d470 3
a472 8
			si_pm4_set_reg(sctx->gs_on, R_028B54_VGT_SHADER_STAGES_EN,
				       S_028B54_ES_EN(V_028B54_ES_STAGE_REAL) |
				       S_028B54_GS_EN(1) |
				       S_028B54_VS_EN(V_028B54_VS_STAGE_COPY_SHADER));
		}
		si_pm4_bind_state(sctx, gs_onoff, sctx->gs_on);
	} else {
		si_shader_select(ctx, sctx->vs_shader);
d474 2
a475 2
		if (!sctx->vs_shader->current->pm4)
			si_pipe_shader_vs(ctx, sctx->vs_shader->current);
d477 3
a479 1
		si_pm4_bind_state(sctx, vs, sctx->vs_shader->current->pm4);
d481 2
a482 1
		sctx->b.streamout.stride_in_dw = sctx->vs_shader->so.stride;
d484 28
a511 5
		if (!sctx->gs_off) {
			sctx->gs_off = si_pm4_alloc_state(sctx);

			si_pm4_set_reg(sctx->gs_off, R_028A40_VGT_GS_MODE, 0);
			si_pm4_set_reg(sctx->gs_off, R_028B54_VGT_SHADER_STAGES_EN, 0);
a512 5
		si_pm4_bind_state(sctx, gs_onoff, sctx->gs_off);
		si_pm4_bind_state(sctx, gs_rings, NULL);
		si_pm4_bind_state(sctx, gs, NULL);
		si_pm4_bind_state(sctx, es, NULL);
	}
d514 5
a518 1
	si_shader_select(ctx, sctx->ps_shader);
d520 4
a523 3
	if (!sctx->ps_shader->current->pm4 ||
	    sctx->ps_shader->current->cb0_is_integer != sctx->framebuffer.cb0_is_integer)
		si_pipe_shader_ps(ctx, sctx->ps_shader->current);
d525 5
a529 1
	si_pm4_bind_state(sctx, ps, sctx->ps_shader->current->pm4);
d531 1
a531 7
	if (si_pm4_state_changed(sctx, ps) || si_pm4_state_changed(sctx, vs)) {
		/* XXX: Emitting the PS state even when only the VS changed
		 * fixes random failures with piglit glsl-max-varyings.
		 * Not sure why...
		 */
		sctx->emitted.named.ps = NULL;
		si_update_spi_map(sctx);
d535 1
a535 1
static void si_vertex_buffer_update(struct si_context *sctx)
d537 2
a538 2
	struct pipe_context *ctx = &sctx->b.b;
	struct si_pm4_state *pm4 = si_pm4_alloc_state(sctx);
d543 1
a543 1
	sctx->b.flags |= R600_CONTEXT_INV_TEX_CACHE;
d545 2
a546 1
	count = sctx->vertex_elements->count;
d551 1
a551 1
		struct pipe_vertex_element *ve = &sctx->vertex_elements->elements[i];
d553 1
a553 1
		struct r600_resource *rbuffer;
d556 1
a556 1
		if (ve->vertex_buffer_index >= sctx->nr_vertex_buffers)
d559 2
a560 2
		vb = &sctx->vertex_buffer[ve->vertex_buffer_index];
		rbuffer = (struct r600_resource*)vb->buffer;
d583 1
a583 1
		si_pm4_sh_data_add(pm4, sctx->vertex_elements->rsrc_word3[i]);
d586 1
a586 2
			si_pm4_add_bo(pm4, rbuffer, RADEON_USAGE_READ,
				      RADEON_PRIO_SHADER_BUFFER_RO);
d590 2
a591 5
	si_pm4_sh_data_end(pm4, sctx->gs_shader ?
			   R_00B330_SPI_SHADER_USER_DATA_ES_0 :
			   R_00B130_SPI_SHADER_USER_DATA_VS_0,
			   SI_SGPR_VERTEX_BUFFER);
	si_pm4_set_state(sctx, vertex_buffers, pm4);
d594 1
a594 1
static void si_state_draw(struct si_context *sctx,
d598 1
a598 1
	struct si_pm4_state *pm4 = si_pm4_alloc_state(sctx);
d605 2
a606 14
	if (sctx->b.num_occlusion_queries > 0) {
		if (sctx->b.chip_class >= CIK) {
			si_pm4_set_reg(pm4, R_028004_DB_COUNT_CONTROL,
				       S_028004_PERFECT_ZPASS_COUNTS(1) |
				       S_028004_SAMPLE_RATE(sctx->framebuffer.log_samples) |
				       S_028004_ZPASS_ENABLE(1) |
				       S_028004_SLICE_EVEN_ENABLE(1) |
				       S_028004_SLICE_ODD_ENABLE(1));
		} else {
			si_pm4_set_reg(pm4, R_028004_DB_COUNT_CONTROL,
				       S_028004_PERFECT_ZPASS_COUNTS(1) |
				       S_028004_SAMPLE_RATE(sctx->framebuffer.log_samples));
		}
	}
d608 5
a612 22
	if (info->count_from_stream_output) {
		struct r600_so_target *t =
			(struct r600_so_target*)info->count_from_stream_output;
		uint64_t va = r600_resource_va(&sctx->screen->b.b,
					       &t->buf_filled_size->b.b);
		va += t->buf_filled_size_offset;

		si_pm4_set_reg(pm4, R_028B30_VGT_STRMOUT_DRAW_OPAQUE_VERTEX_STRIDE,
			       t->stride_in_dw);

		si_pm4_cmd_begin(pm4, PKT3_COPY_DATA);
		si_pm4_cmd_add(pm4,
			       COPY_DATA_SRC_SEL(COPY_DATA_MEM) |
			       COPY_DATA_DST_SEL(COPY_DATA_REG) |
			       COPY_DATA_WR_CONFIRM);
		si_pm4_cmd_add(pm4, va);     /* src address lo */
		si_pm4_cmd_add(pm4, va >> 32UL); /* src address hi */
		si_pm4_cmd_add(pm4, R_028B2C_VGT_STRMOUT_DRAW_OPAQUE_BUFFER_FILLED_SIZE >> 2);
		si_pm4_cmd_add(pm4, 0); /* unused */
		si_pm4_add_bo(pm4, t->buf_filled_size, RADEON_USAGE_READ,
			      RADEON_PRIO_MIN);
		si_pm4_cmd_end(pm4, true);
d618 1
a618 1
		si_pm4_cmd_add(pm4, V_028A7C_VGT_INDEX_32 | (SI_BIG_ENDIAN ?
d621 1
a621 1
		si_pm4_cmd_add(pm4, V_028A7C_VGT_INDEX_16 | (SI_BIG_ENDIAN ?
d624 1
a624 1
	si_pm4_cmd_end(pm4, sctx->b.predicate_drawing);
d628 1
a628 1
	si_pm4_cmd_end(pm4, sctx->b.predicate_drawing);
d632 1
a632 1
				 sctx->index_buffer.index_size;
d634 1
a634 1
		va = r600_resource_va(&sctx->screen->b.b, ib->buffer);
d637 1
a637 2
		si_pm4_add_bo(pm4, (struct r600_resource *)ib->buffer, RADEON_USAGE_READ,
			      RADEON_PRIO_MIN);
d640 1
a640 1
				    sctx->b.predicate_drawing);
d644 1
a644 1
		si_cmd_draw_index_auto(pm4, info->count, initiator, sctx->b.predicate_drawing);
d646 1
a646 2

	si_pm4_set_state(sctx, draw, pm4);
a648 82
void si_emit_cache_flush(struct r600_common_context *sctx, struct r600_atom *atom)
{
	struct radeon_winsys_cs *cs = sctx->rings.gfx.cs;
	uint32_t cp_coher_cntl = 0;

	/* XXX SI flushes both ICACHE and KCACHE if either flag is set.
	 * XXX CIK shouldn't have this issue. Test CIK before separating the flags
	 * XXX to ensure there is no regression. Also find out if there is another
	 * XXX way to flush either ICACHE or KCACHE but not both for SI. */
	if (sctx->flags & (R600_CONTEXT_INV_SHADER_CACHE |
			   R600_CONTEXT_INV_CONST_CACHE)) {
		cp_coher_cntl |= S_0085F0_SH_ICACHE_ACTION_ENA(1) |
				 S_0085F0_SH_KCACHE_ACTION_ENA(1);
	}
	if (sctx->flags & (R600_CONTEXT_INV_TEX_CACHE |
			   R600_CONTEXT_STREAMOUT_FLUSH)) {
		cp_coher_cntl |= S_0085F0_TC_ACTION_ENA(1) |
				 S_0085F0_TCL1_ACTION_ENA(1);
	}
	if (sctx->flags & R600_CONTEXT_FLUSH_AND_INV_CB) {
		cp_coher_cntl |= S_0085F0_CB_ACTION_ENA(1) |
				 S_0085F0_CB0_DEST_BASE_ENA(1) |
			         S_0085F0_CB1_DEST_BASE_ENA(1) |
			         S_0085F0_CB2_DEST_BASE_ENA(1) |
			         S_0085F0_CB3_DEST_BASE_ENA(1) |
			         S_0085F0_CB4_DEST_BASE_ENA(1) |
			         S_0085F0_CB5_DEST_BASE_ENA(1) |
			         S_0085F0_CB6_DEST_BASE_ENA(1) |
			         S_0085F0_CB7_DEST_BASE_ENA(1);
	}
	if (sctx->flags & R600_CONTEXT_FLUSH_AND_INV_DB) {
		cp_coher_cntl |= S_0085F0_DB_ACTION_ENA(1) |
				 S_0085F0_DB_DEST_BASE_ENA(1);
	}

	if (cp_coher_cntl) {
		if (sctx->chip_class >= CIK) {
			radeon_emit(cs, PKT3(PKT3_ACQUIRE_MEM, 5, 0));
			radeon_emit(cs, cp_coher_cntl);   /* CP_COHER_CNTL */
			radeon_emit(cs, 0xffffffff);      /* CP_COHER_SIZE */
			radeon_emit(cs, 0xff);            /* CP_COHER_SIZE_HI */
			radeon_emit(cs, 0);               /* CP_COHER_BASE */
			radeon_emit(cs, 0);               /* CP_COHER_BASE_HI */
			radeon_emit(cs, 0x0000000A);      /* POLL_INTERVAL */
		} else {
			radeon_emit(cs, PKT3(PKT3_SURFACE_SYNC, 3, 0));
			radeon_emit(cs, cp_coher_cntl);   /* CP_COHER_CNTL */
			radeon_emit(cs, 0xffffffff);      /* CP_COHER_SIZE */
			radeon_emit(cs, 0);               /* CP_COHER_BASE */
			radeon_emit(cs, 0x0000000A);      /* POLL_INTERVAL */
		}
	}

	if (sctx->flags & R600_CONTEXT_FLUSH_AND_INV_CB_META) {
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
		radeon_emit(cs, EVENT_TYPE(V_028A90_FLUSH_AND_INV_CB_META) | EVENT_INDEX(0));
	}
	if (sctx->flags & R600_CONTEXT_FLUSH_AND_INV_DB_META) {
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
		radeon_emit(cs, EVENT_TYPE(V_028A90_FLUSH_AND_INV_DB_META) | EVENT_INDEX(0));
	}

	if (sctx->flags & (R600_CONTEXT_WAIT_3D_IDLE |
			   R600_CONTEXT_PS_PARTIAL_FLUSH)) {
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
		radeon_emit(cs, EVENT_TYPE(V_028A90_PS_PARTIAL_FLUSH) | EVENT_INDEX(4));
	} else if (sctx->flags & R600_CONTEXT_STREAMOUT_FLUSH) {
		/* Needed if streamout buffers are going to be used as a source. */
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
		radeon_emit(cs, EVENT_TYPE(V_028A90_VS_PARTIAL_FLUSH) | EVENT_INDEX(4));
	}

	if (sctx->flags & R600_CONTEXT_VGT_FLUSH) {
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
		radeon_emit(cs, EVENT_TYPE(V_028A90_VGT_FLUSH) | EVENT_INDEX(0));
	}

	sctx->flags = 0;
}

const struct r600_atom si_atom_cache_flush = { si_emit_cache_flush, 13 }; /* number of CS dwords */

d651 1
a651 1
	struct si_context *sctx = (struct si_context *)ctx;
d653 1
a653 1
	uint32_t i;
d658 1
a658 1
	if (!sctx->ps_shader || !sctx->vs_shader)
d661 3
a663 2
	si_update_derived_state(sctx);
	si_vertex_buffer_update(sctx);
d667 4
a670 4
		pipe_resource_reference(&ib.buffer, sctx->index_buffer.buffer);
		ib.user_buffer = sctx->index_buffer.user_buffer;
		ib.index_size = sctx->index_buffer.index_size;
		ib.offset = sctx->index_buffer.offset + info->start * ib.index_size;
d673 1
a673 17
		if (ib.index_size == 1) {
			struct pipe_resource *out_buffer = NULL;
			unsigned out_offset;
			void *ptr;

			u_upload_alloc(sctx->b.uploader, 0, info->count * 2,
				       &out_offset, &out_buffer, &ptr);

			util_shorten_ubyte_elts_to_userptr(
						&sctx->b.b, &ib, 0, ib.offset, info->count, ptr);

			pipe_resource_reference(&ib.buffer, NULL);
			ib.user_buffer = NULL;
			ib.buffer = out_buffer;
			ib.offset = out_offset;
			ib.index_size = 2;
		}
d676 1
a676 2
			u_upload_data(sctx->b.uploader, 0, info->count * ib.index_size,
				      ib.user_buffer, &ib.offset, &ib.buffer);
d678 3
d683 3
a685 1
	if (!si_update_draw_info_state(sctx, info, &ib))
d688 1
a688 1
	si_state_draw(sctx, info, &ib);
d690 3
a692 1
	sctx->pm4_dirty_cdwords += si_pm4_dirty_dw(sctx);
d694 2
a695 3
	/* Check flush flags. */
	if (sctx->b.flags)
		sctx->atoms.cache_flush->dirty = true;
d697 3
a699 1
	si_need_cs_space(sctx, 0, TRUE);
d702 10
a711 5
	for (i = 0; i < SI_NUM_ATOMS(sctx); i++) {
		if (sctx->atoms.array[i]->dirty) {
			sctx->atoms.array[i]->emit(&sctx->b, sctx->atoms.array[i]);
			sctx->atoms.array[i]->dirty = false;
		}
d713 1
d715 5
a719 6
	si_pm4_emit_dirty(sctx);
	sctx->pm4_dirty_cdwords = 0;

#if SI_TRACE_CS
	if (sctx->screen->b.trace_bo) {
		si_trace_emit(sctx);
d723 2
d726 3
a728 15
	if (sctx->framebuffer.state.zsbuf) {
		struct pipe_surface *surf = sctx->framebuffer.state.zsbuf;
		struct r600_texture *rtex = (struct r600_texture *)surf->texture;

		rtex->dirty_level_mask |= 1 << surf->u.tex.level;
	}
	if (sctx->framebuffer.compressed_cb_mask) {
		struct pipe_surface *surf;
		struct r600_texture *rtex;
		unsigned mask = sctx->framebuffer.compressed_cb_mask;

		do {
			unsigned i = u_bit_scan(&mask);
			surf = sctx->framebuffer.state.cbufs[i];
			rtex = (struct r600_texture*)surf->texture;
d730 1
a730 2
			rtex->dirty_level_mask |= 1 << surf->u.tex.level;
		} while (mask);
a733 1
	sctx->b.num_draw_calls++;
@


1.1.1.3
log
@Import Mesa 10.2.7
@
text
@a35 1
#include "util/u_prim.h"
a427 9
		unsigned primgroup_size = 64;

		/* Hawaii hangs if instancing is enabled and WD_SWITCH_ON_EOP is 0.
		 * We don't know that for indirect drawing, so treat it as
		 * always problematic. */
		if (sctx->b.family == CHIP_HAWAII && info->instance_count > 1) {
			wd_switch_on_eop = true;
			ia_switch_on_eop = true;
		}
d429 5
d437 1
a437 9
		si_pm4_cmd_begin(pm4, PKT3_DRAW_PREAMBLE);
		si_pm4_cmd_add(pm4, prim); /* VGT_PRIMITIVE_TYPE */
		si_pm4_cmd_add(pm4, /* IA_MULTI_VGT_PARAM */
			       S_028AA8_SWITCH_ON_EOP(ia_switch_on_eop) |
			       S_028AA8_PARTIAL_VS_WAVE_ON(1) |
			       S_028AA8_PRIMGROUP_SIZE(primgroup_size - 1) |
			       S_028AA8_WD_SWITCH_ON_EOP(wd_switch_on_eop));
		si_pm4_cmd_add(pm4, 0); /* VGT_LS_HS_CONFIG */
		si_pm4_cmd_end(pm4, false);
a904 4
	if (sctx->flags & R600_CONTEXT_VGT_STREAMOUT_SYNC) {
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
		radeon_emit(cs, EVENT_TYPE(V_028A90_VGT_STREAMOUT_SYNC) | EVENT_INDEX(0));
	}
d909 1
a909 1
const struct r600_atom si_atom_cache_flush = { si_emit_cache_flush, 17 }; /* number of CS dwords */
d967 1
a967 1
		sctx->atoms.s.cache_flush->dirty = true;
a986 8

	/* Workaround for a VGT hang when streamout is enabled.
	 * It must be done after drawing. */
	if (sctx->b.family == CHIP_HAWAII &&
	    (sctx->b.streamout.streamout_enabled ||
	     sctx->b.streamout.prims_gen_query_enabled)) {
		sctx->b.flags |= R600_CONTEXT_VGT_STREAMOUT_SYNC;
	}
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d29 1
a29 1
#include "radeon/r600_cs.h"
d32 1
d43 1
a43 1
static void si_shader_es(struct si_shader *shader)
d45 1
d51 2
a52 1
	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);
d57 1
a57 1
	va = shader->bo->gpu_address;
d60 1
a60 1
	vgpr_comp_cnt = shader->uses_instanceid ? 3 : 0;
d79 2
d83 1
a83 1
static void si_shader_gs(struct si_shader *shader)
d85 3
a87 2
	unsigned gs_vert_itemsize = shader->selector->info.num_outputs * (16 >> 2);
	unsigned gs_max_vert_out = shader->selector->gs_max_out_vertices;
d97 2
a98 1
	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);
d125 1
a125 1
		       util_bitcount64(shader->selector->gs_used_inputs) * (16 >> 2));
d132 1
a132 1
	va = shader->bo->gpu_address;
d151 2
d155 1
a155 1
static void si_shader_vs(struct si_shader *shader)
d157 1
a157 1
	struct tgsi_shader_info *info = &shader->selector->info;
d163 2
a164 1
	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);
d169 1
a169 1
	va = shader->bo->gpu_address;
d172 1
a172 6
	vgpr_comp_cnt = shader->uses_instanceid ? 3 : 0;

	if (shader->is_gs_copy_shader)
		num_user_sgprs = SI_GSCOPY_NUM_USER_SGPR;
	else
		num_user_sgprs = SI_VS_NUM_USER_SGPR;
d174 1
d186 2
a187 2
	for (nparams = 0, i = 0 ; i < info->num_outputs; i++) {
		switch (info->output_semantic_name[i]) {
d204 1
a204 1
		       S_02870C_POS1_EXPORT_FORMAT(shader->nr_pos_exports > 1 ?
d207 1
a207 1
		       S_02870C_POS2_EXPORT_FORMAT(shader->nr_pos_exports > 2 ?
d210 1
a210 1
		       S_02870C_POS3_EXPORT_FORMAT(shader->nr_pos_exports > 3 ?
d227 2
d231 1
a231 1
static void si_shader_ps(struct si_shader *shader)
d233 1
a233 1
	struct tgsi_shader_info *info = &shader->selector->info;
d235 1
a235 1
	unsigned i, spi_ps_in_control;
d237 1
a237 1
	unsigned spi_baryc_cntl = 0, spi_ps_input_ena;
d240 2
a241 1
	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);
d246 5
a250 2
	for (i = 0; i < info->num_inputs; i++) {
		switch (info->input_semantic_name[i]) {
d252 8
a259 8
			/* SPI_BARYC_CNTL.POS_FLOAT_LOCATION
			 * Possible vaules:
			 * 0 -> Position = pixel center (default)
			 * 1 -> Position = pixel centroid
			 * 2 -> Position = at sample position
			 */
			switch (info->input_interpolate_loc[i]) {
			case TGSI_INTERPOLATE_LOC_CENTROID:
a260 4
				break;
			case TGSI_INTERPOLATE_LOC_SAMPLE:
				spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(2);
				break;
d262 3
a264 1
			break;
d268 21
a288 1
	spi_ps_in_control = S_0286D8_NUM_INTERP(shader->nparam) |
d307 7
a313 1
	si_pm4_set_reg(pm4, R_028710_SPI_SHADER_Z_FORMAT, shader->spi_shader_z_format);
d318 1
a318 1
	va = shader->bo->gpu_address;
a337 1
}
d339 5
a343 19
void si_shader_init_pm4_state(struct si_shader *shader)
{
	switch (shader->selector->type) {
	case PIPE_SHADER_VERTEX:
		if (shader->key.vs.as_es)
			si_shader_es(shader);
		else
			si_shader_vs(shader);
		break;
	case PIPE_SHADER_GEOMETRY:
		si_shader_gs(shader);
		si_shader_vs(shader->gs_copy_shader);
		break;
	case PIPE_SHADER_FRAGMENT:
		si_shader_ps(shader);
		break;
	default:
		assert(0);
	}
d366 1
a366 2
		[PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY]	= V_008958_DI_PT_TRISTRIP_ADJ,
		[R600_PRIM_RECTANGLE_LIST]		= V_008958_DI_PT_RECTLIST
d391 1
a391 2
		[PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY]	= V_028A6C_OUTPRIM_TYPE_TRISTRIP,
		[R600_PRIM_RECTANGLE_LIST]		= V_028A6C_OUTPRIM_TYPE_TRISTRIP
a397 55
static unsigned si_get_ia_multi_vgt_param(struct si_context *sctx,
					  const struct pipe_draw_info *info)
{
	struct si_state_rasterizer *rs = sctx->queued.named.rasterizer;
	unsigned prim = info->mode;
	unsigned primgroup_size = 128; /* recommended without a GS */

	/* SWITCH_ON_EOP(0) is always preferable. */
	bool wd_switch_on_eop = false;
	bool ia_switch_on_eop = false;
	bool partial_vs_wave = false;

	if (sctx->gs_shader)
		primgroup_size = 64; /* recommended with a GS */

	/* This is a hardware requirement. */
	if ((rs && rs->line_stipple_enable) ||
	    (sctx->b.screen->debug_flags & DBG_SWITCH_ON_EOP)) {
		ia_switch_on_eop = true;
		wd_switch_on_eop = true;
	}

	if (sctx->b.streamout.streamout_enabled ||
	    sctx->b.streamout.prims_gen_query_enabled)
		partial_vs_wave = true;

	if (sctx->b.chip_class >= CIK) {
		/* WD_SWITCH_ON_EOP has no effect on GPUs with less than
		 * 4 shader engines. Set 1 to pass the assertion below.
		 * The other cases are hardware requirements. */
		if (sctx->b.screen->info.max_se < 4 ||
		    prim == PIPE_PRIM_POLYGON ||
		    prim == PIPE_PRIM_LINE_LOOP ||
		    prim == PIPE_PRIM_TRIANGLE_FAN ||
		    prim == PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY ||
		    info->primitive_restart)
			wd_switch_on_eop = true;

		/* Hawaii hangs if instancing is enabled and WD_SWITCH_ON_EOP is 0.
		 * We don't know that for indirect drawing, so treat it as
		 * always problematic. */
		if (sctx->b.family == CHIP_HAWAII &&
		    (info->indirect || info->instance_count > 1))
			wd_switch_on_eop = true;

		/* If the WD switch is false, the IA switch must be false too. */
		assert(wd_switch_on_eop || !ia_switch_on_eop);
	}

	return S_028AA8_SWITCH_ON_EOP(ia_switch_on_eop) |
		S_028AA8_PARTIAL_VS_WAVE_ON(partial_vs_wave) |
		S_028AA8_PRIMGROUP_SIZE(primgroup_size - 1) |
		S_028AA8_WD_SWITCH_ON_EOP(sctx->b.chip_class >= CIK ? wd_switch_on_eop : 0);
}

d402 1
a402 1
	struct si_pm4_state *pm4 = CALLOC_STRUCT(si_pm4_state);
d407 1
a407 1
				       sctx->gs_shader->gs_output_prim :
a409 1
	unsigned ia_multi_vgt_param = si_get_ia_multi_vgt_param(sctx, info);
d420 19
d444 5
a448 1
		si_pm4_cmd_add(pm4, ia_multi_vgt_param); /* IA_MULTI_VGT_PARAM */
a452 1
		si_pm4_set_reg(pm4, R_028AA8_IA_MULTI_VGT_PARAM, ia_multi_vgt_param);
d456 2
d460 4
d499 1
a499 1
	struct si_shader *ps = sctx->ps_shader->current;
d501 1
a501 3
	struct tgsi_shader_info *psinfo = &ps->selector->info;
	struct tgsi_shader_info *vsinfo = &vs->selector->info;
	struct si_pm4_state *pm4 = CALLOC_STRUCT(si_pm4_state);
d504 3
a506 5
	for (i = 0; i < psinfo->num_inputs; i++) {
		unsigned name = psinfo->input_semantic_name[i];
		unsigned index = psinfo->input_semantic_index[i];
		unsigned interpolate = psinfo->input_interpolate[i];
		unsigned param_offset = ps->ps_input_param_offset[i];
d515 3
a517 3
		if (interpolate == TGSI_INTERPOLATE_CONSTANT ||
		    (interpolate == TGSI_INTERPOLATE_COLOR &&
		     ps->key.ps.flatshade)) {
d522 1
a522 1
		    sctx->sprite_coord_enable & (1 << index)) {
d526 4
a529 4
		for (j = 0; j < vsinfo->num_outputs; j++) {
			if (name == vsinfo->output_semantic_name[j] &&
			    index == vsinfo->output_semantic_index[j]) {
				tmp |= S_028644_OFFSET(vs->vs_output_param_offset[j]);
d534 1
a534 1
		if (j == vsinfo->num_outputs) {
d544 1
a544 1
		    ps->key.ps.color_two_side) {
d557 1
a557 2
	unsigned esgs_ring_size = 128 * 1024;
	unsigned gsvs_ring_size = 64 * 1024 * 1024;
d560 1
a560 1
	sctx->gs_rings = CALLOC_STRUCT(si_pm4_state);
d562 10
a571 5
	sctx->esgs_ring = pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
				       PIPE_USAGE_DEFAULT, esgs_ring_size);

	sctx->gsvs_ring = pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
					     PIPE_USAGE_DEFAULT, gsvs_ring_size);
d575 1
a575 1
			       esgs_ring_size / 256);
d577 1
a577 1
			       gsvs_ring_size / 256);
d580 1
a580 1
			       esgs_ring_size / 256);
d582 1
a582 1
			       gsvs_ring_size / 256);
d586 1
a586 1
			   sctx->esgs_ring, 0, esgs_ring_size,
d589 1
a589 1
			   sctx->esgs_ring, 0, esgs_ring_size,
d592 1
a592 1
			   sctx->gsvs_ring, 0, gsvs_ring_size,
d614 7
d627 4
d640 3
a642 3
				   sctx->gsvs_ring,
				   sctx->gs_shader->gs_max_out_vertices *
				   sctx->gs_shader->info.num_outputs * 16,
d646 1
a646 1
			sctx->gs_on = CALLOC_STRUCT(si_pm4_state);
d656 4
d665 1
a665 1
			sctx->gs_off = CALLOC_STRUCT(si_pm4_state);
d678 5
a682 2
	if (!sctx->ps_shader->current) {
		struct si_shader_selector *sel;
d684 7
a690 5
		/* use a dummy shader if compiling the shader (variant) failed */
		si_make_dummy_ps(sctx);
		sel = sctx->dummy_pixel_shader;
		si_shader_select(ctx, sel);
		sctx->ps_shader->current = sel->current;
d692 24
d717 4
a720 1
	si_pm4_bind_state(sctx, ps, sctx->ps_shader->current->pm4);
d722 20
a741 2
	if (si_pm4_state_changed(sctx, ps) || si_pm4_state_changed(sctx, vs))
		si_update_spi_map(sctx);
d743 5
a747 3
	if (sctx->ps_db_shader_control != sctx->ps_shader->current->db_shader_control) {
		sctx->ps_db_shader_control = sctx->ps_shader->current->db_shader_control;
		sctx->db_render_state.dirty = true;
d749 5
d760 1
a760 3
	unsigned sh_base_reg = (sctx->gs_shader ? R_00B330_SPI_SHADER_USER_DATA_ES_0 :
						  R_00B130_SPI_SHADER_USER_DATA_VS_0);
	struct si_pm4_state *pm4 = CALLOC_STRUCT(si_pm4_state);
d765 17
d785 3
a787 2
		uint64_t va = t->buf_filled_size->gpu_address +
			      t->buf_filled_size_offset;
d817 3
a819 13
	if (!info->indirect) {
		si_pm4_cmd_begin(pm4, PKT3_NUM_INSTANCES);
		si_pm4_cmd_add(pm4, info->instance_count);
		si_pm4_cmd_end(pm4, sctx->b.predicate_drawing);

		si_pm4_set_reg(pm4, sh_base_reg + SI_SGPR_BASE_VERTEX * 4,
			       info->indexed ? info->index_bias : info->start);
		si_pm4_set_reg(pm4, sh_base_reg + SI_SGPR_START_INSTANCE * 4,
			       info->start_instance);
	} else {
		si_pm4_add_bo(pm4, (struct r600_resource *)info->indirect,
			      RADEON_USAGE_READ, RADEON_PRIO_MIN);
	}
d823 4
a826 2
				    ib->index_size;
		uint64_t va = r600_resource(ib->buffer)->gpu_address + ib->offset;
d830 3
a832 14

		if (info->indirect) {
			uint64_t indirect_va = r600_resource(info->indirect)->gpu_address;
			si_cmd_draw_index_indirect(pm4, indirect_va, va, max_size,
						   info->indirect_offset,
						   sh_base_reg + SI_SGPR_BASE_VERTEX * 4,
						   sh_base_reg + SI_SGPR_START_INSTANCE * 4,
						   sctx->b.predicate_drawing);
		} else {
			va += info->start * ib->index_size;
			si_cmd_draw_index_2(pm4, max_size, va, info->count,
					    V_0287F0_DI_SRC_SEL_DMA,
					    sctx->b.predicate_drawing);
		}
d834 3
a836 12
		if (info->indirect) {
			uint64_t indirect_va = r600_resource(info->indirect)->gpu_address;
			si_cmd_draw_indirect(pm4, indirect_va, info->indirect_offset,
					     sh_base_reg + SI_SGPR_BASE_VERTEX * 4,
					     sh_base_reg + SI_SGPR_START_INSTANCE * 4,
					     sctx->b.predicate_drawing);
		} else {
			si_cmd_draw_index_auto(pm4, info->count,
					       V_0287F0_DI_SRC_SEL_AUTO_INDEX |
					       S_0287F0_USE_OPAQUE(!!info->count_from_stream_output),
					       sctx->b.predicate_drawing);
		}
a845 2
	uint32_t compute =
		PKT3_SHADER_TYPE_S(!!(sctx->flags & R600_CONTEXT_FLAG_COMPUTE));
d879 1
a879 1
			radeon_emit(cs, PKT3(PKT3_ACQUIRE_MEM, 5, 0) | compute);
d887 1
a887 1
			radeon_emit(cs, PKT3(PKT3_SURFACE_SYNC, 3, 0) | compute);
d896 1
a896 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0) | compute);
d900 1
a900 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0) | compute);
a902 5
	if (sctx->flags & R600_CONTEXT_FLUSH_WITH_INV_L2) {
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0) | compute);
		radeon_emit(cs, EVENT_TYPE(EVENT_TYPE_CACHE_FLUSH) | EVENT_INDEX(7) |
				EVENT_WRITE_INV_L2);
        }
d906 1
a906 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0) | compute);
d910 1
a910 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0) | compute);
a913 5
	if (sctx->flags & R600_CONTEXT_CS_PARTIAL_FLUSH) {
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0) | compute);
		radeon_emit(cs, EVENT_TYPE(V_028A90_CS_PARTIAL_FLUSH | EVENT_INDEX(4)));
	}

d915 1
a915 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0) | compute);
d919 1
a919 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0) | compute);
d926 1
a926 19
const struct r600_atom si_atom_cache_flush = { si_emit_cache_flush, 21 }; /* number of CS dwords */

static void si_get_draw_start_count(struct si_context *sctx,
				    const struct pipe_draw_info *info,
				    unsigned *start, unsigned *count)
{
	if (info->indirect) {
		struct r600_resource *indirect =
			(struct r600_resource*)info->indirect;
		int *data = r600_buffer_map_sync_with_rings(&sctx->b,
					indirect, PIPE_TRANSFER_READ);
                data += info->indirect_offset/sizeof(int);
		*start = data[2];
		*count = data[0];
	} else {
		*start = info->start;
		*count = info->count;
	}
}
d934 1
a934 2
	if (!info->count && !info->indirect &&
	    (info->indexed || !info->count_from_stream_output))
d941 1
a941 5

	if (sctx->vertex_buffers_dirty) {
		si_update_vertex_buffers(sctx);
		sctx->vertex_buffers_dirty = false;
	}
d948 1
a948 1
		ib.offset = sctx->index_buffer.offset;
d953 1
a953 1
			unsigned out_offset, start, count, start_offset;
d956 1
a956 4
			si_get_draw_start_count(sctx, info, &start, &count);
			start_offset = start * ib.index_size;

			u_upload_alloc(sctx->b.uploader, start_offset, count * 2,
d959 2
a960 3
			util_shorten_ubyte_elts_to_userptr(&sctx->b.b, &ib, 0,
							   ib.offset + start_offset,
							   count, ptr);
d965 1
a965 2
			/* info->start will be added by the drawing code */
			ib.offset = out_offset - start_offset;
d967 1
a967 5
		} else if (ib.user_buffer && !ib.buffer) {
			unsigned start, count, start_offset;

			si_get_draw_start_count(sctx, info, &start, &count);
			start_offset = start * ib.index_size;
d969 3
a971 5
			u_upload_data(sctx->b.uploader, start_offset, count * ib.index_size,
				      (char*)ib.user_buffer + start_offset,
				      &ib.offset, &ib.buffer);
			/* info->start will be added by the drawing code */
			ib.offset -= start_offset;
a1036 21

#if SI_TRACE_CS
void si_trace_emit(struct si_context *sctx)
{
	struct si_screen *sscreen = sctx->screen;
	struct radeon_winsys_cs *cs = sctx->b.rings.gfx.cs;
	uint64_t va;

	va = sscreen->b.trace_bo->gpu_address;
	r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx, sscreen->b.trace_bo,
			      RADEON_USAGE_READWRITE, RADEON_PRIO_MIN);
	radeon_emit(cs, PKT3(PKT3_WRITE_DATA, 4, 0));
	radeon_emit(cs, PKT3_WRITE_DATA_DST_SEL(PKT3_WRITE_DATA_DST_SEL_MEM_SYNC) |
				PKT3_WRITE_DATA_WR_CONFIRM |
				PKT3_WRITE_DATA_ENGINE_SEL(PKT3_WRITE_DATA_ENGINE_SEL_ME));
	radeon_emit(cs, va & 0xFFFFFFFFUL);
	radeon_emit(cs, (va >> 32UL) & 0xFFFFFFFFUL);
	radeon_emit(cs, cs->cdw);
	radeon_emit(cs, sscreen->b.cs_count);
}
#endif
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d29 1
a29 1
#include "../radeon/r600_cs.h"
a31 1
#include "util/u_blitter.h"
d42 1
a42 1
static void si_pipe_shader_es(struct pipe_context *ctx, struct si_pipe_shader *shader)
a43 1
	struct si_context *sctx = (struct si_context *)ctx;
d49 1
a49 2
	si_pm4_delete_state(sctx, es, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(sctx);
d54 1
a54 1
	va = r600_resource_va(ctx->screen, (void *)shader->bo);
d57 1
a57 1
	vgpr_comp_cnt = shader->shader.uses_instanceid ? 3 : 0;
a75 2

	sctx->b.flags |= R600_CONTEXT_INV_SHADER_CACHE;
d78 1
a78 1
static void si_pipe_shader_gs(struct pipe_context *ctx, struct si_pipe_shader *shader)
d80 2
a81 3
	struct si_context *sctx = (struct si_context *)ctx;
	unsigned gs_vert_itemsize = shader->shader.noutput * (16 >> 2);
	unsigned gs_max_vert_out = shader->shader.gs_max_out_vertices;
d91 1
a91 2
	si_pm4_delete_state(sctx, gs, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(sctx);
d118 1
a118 1
		       shader->shader.nparam * (16 >> 2));
d125 1
a125 1
	va = r600_resource_va(ctx->screen, (void *)shader->bo);
a143 2

	sctx->b.flags |= R600_CONTEXT_INV_SHADER_CACHE;
d146 1
a146 1
static void si_pipe_shader_vs(struct pipe_context *ctx, struct si_pipe_shader *shader)
d148 1
a148 1
	struct si_context *sctx = (struct si_context *)ctx;
d154 1
a154 2
	si_pm4_delete_state(sctx, vs, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(sctx);
d159 1
a159 1
	va = r600_resource_va(ctx->screen, (void *)shader->bo);
d162 6
a167 1
	vgpr_comp_cnt = shader->shader.uses_instanceid ? 3 : 0;
a168 1
	num_user_sgprs = SI_VS_NUM_USER_SGPR;
d180 2
a181 2
	for (nparams = 0, i = 0 ; i < shader->shader.noutput; i++) {
		switch (shader->shader.output[i].name) {
d198 1
a198 1
		       S_02870C_POS1_EXPORT_FORMAT(shader->shader.nr_pos_exports > 1 ?
d201 1
a201 1
		       S_02870C_POS2_EXPORT_FORMAT(shader->shader.nr_pos_exports > 2 ?
d204 1
a204 1
		       S_02870C_POS3_EXPORT_FORMAT(shader->shader.nr_pos_exports > 3 ?
a220 2

	sctx->b.flags |= R600_CONTEXT_INV_SHADER_CACHE;
d223 1
a223 1
static void si_pipe_shader_ps(struct pipe_context *ctx, struct si_pipe_shader *shader)
d225 1
a225 1
	struct si_context *sctx = (struct si_context *)ctx;
d227 1
a227 1
	unsigned i, exports_ps, spi_ps_in_control, db_shader_control;
d229 1
a229 1
	unsigned spi_baryc_cntl = 0, spi_ps_input_ena, spi_shader_z_format;
d232 1
a232 2
	si_pm4_delete_state(sctx, ps, shader->pm4);
	pm4 = shader->pm4 = si_pm4_alloc_state(sctx);
d237 2
a238 5
	db_shader_control = S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z) |
			    S_02880C_ALPHA_TO_MASK_DISABLE(sctx->framebuffer.cb0_is_integer);

	for (i = 0; i < shader->shader.ninput; i++) {
		switch (shader->shader.input[i].name) {
d240 8
a247 8
			if (shader->shader.input[i].centroid) {
				/* SPI_BARYC_CNTL.POS_FLOAT_LOCATION
				 * Possible vaules:
				 * 0 -> Position = pixel center (default)
				 * 1 -> Position = pixel centroid
				 * 2 -> Position = iterated sample number XXX:
				 *                        What does this mean?
			 	 */
d249 4
d254 1
a254 3
			/* Fall through */
		case TGSI_SEMANTIC_FACE:
			continue;
d258 1
a258 21
	for (i = 0; i < shader->shader.noutput; i++) {
		if (shader->shader.output[i].name == TGSI_SEMANTIC_POSITION)
			db_shader_control |= S_02880C_Z_EXPORT_ENABLE(1);
		if (shader->shader.output[i].name == TGSI_SEMANTIC_STENCIL)
			db_shader_control |= S_02880C_STENCIL_TEST_VAL_EXPORT_ENABLE(1);
	}
	if (shader->shader.uses_kill || shader->key.ps.alpha_func != PIPE_FUNC_ALWAYS)
		db_shader_control |= S_02880C_KILL_ENABLE(1);

	exports_ps = 0;
	for (i = 0; i < shader->shader.noutput; i++) {
		if (shader->shader.output[i].name == TGSI_SEMANTIC_POSITION ||
		    shader->shader.output[i].name == TGSI_SEMANTIC_STENCIL)
			exports_ps |= 1;
	}
	if (!exports_ps) {
		/* always at least export 1 component per pixel */
		exports_ps = 2;
	}

	spi_ps_in_control = S_0286D8_NUM_INTERP(shader->shader.nparam) |
d277 1
a277 7
	if (G_02880C_STENCIL_TEST_VAL_EXPORT_ENABLE(db_shader_control))
		spi_shader_z_format = V_028710_SPI_SHADER_32_GR;
	else if (G_02880C_Z_EXPORT_ENABLE(db_shader_control))
		spi_shader_z_format = V_028710_SPI_SHADER_32_R;
	else
		spi_shader_z_format = 0;
	si_pm4_set_reg(pm4, R_028710_SPI_SHADER_Z_FORMAT, spi_shader_z_format);
d282 1
a282 1
	va = r600_resource_va(ctx->screen, (void *)shader->bo);
d302 1
d304 19
a322 5
	si_pm4_set_reg(pm4, R_02880C_DB_SHADER_CONTROL, db_shader_control);

	shader->cb0_is_integer = sctx->framebuffer.cb0_is_integer;
	shader->sprite_coord_enable = sctx->sprite_coord_enable;
	sctx->b.flags |= R600_CONTEXT_INV_SHADER_CACHE;
d345 2
a346 1
		[PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY]	= V_008958_DI_PT_TRISTRIP_ADJ
d371 2
a372 1
		[PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY]	= V_028A6C_OUTPRIM_TYPE_TRISTRIP
d379 55
d438 1
a438 1
	struct si_pm4_state *pm4 = si_pm4_alloc_state(sctx);
d443 1
a443 1
				       sctx->gs_shader->current->shader.gs_output_prim :
d446 1
a456 19
		struct si_state_rasterizer *rs = sctx->queued.named.rasterizer;
		bool wd_switch_on_eop = prim == V_008958_DI_PT_POLYGON ||
					prim == V_008958_DI_PT_LINELOOP ||
					prim == V_008958_DI_PT_TRIFAN ||
					prim == V_008958_DI_PT_TRISTRIP_ADJ ||
					info->primitive_restart ||
					(rs ? rs->line_stipple_enable : false);
		/* If the WD switch is false, the IA switch must be false too. */
		bool ia_switch_on_eop = wd_switch_on_eop;
		unsigned primgroup_size = 64;

		/* Hawaii hangs if instancing is enabled and WD_SWITCH_ON_EOP is 0.
		 * We don't know that for indirect drawing, so treat it as
		 * always problematic. */
		if (sctx->b.family == CHIP_HAWAII && info->instance_count > 1) {
			wd_switch_on_eop = true;
			ia_switch_on_eop = true;
		}

d462 1
a462 5
		si_pm4_cmd_add(pm4, /* IA_MULTI_VGT_PARAM */
			       S_028AA8_SWITCH_ON_EOP(ia_switch_on_eop) |
			       S_028AA8_PARTIAL_VS_WAVE_ON(1) |
			       S_028AA8_PRIMGROUP_SIZE(primgroup_size - 1) |
			       S_028AA8_WD_SWITCH_ON_EOP(wd_switch_on_eop));
d467 1
a470 2
	si_pm4_set_reg(pm4, R_028408_VGT_INDX_OFFSET,
		       info->indexed ? info->index_bias : info->start);
a472 4
	si_pm4_set_reg(pm4, SI_SGPR_START_INSTANCE * 4 +
		       (sctx->gs_shader ? R_00B330_SPI_SHADER_USER_DATA_ES_0 :
			R_00B130_SPI_SHADER_USER_DATA_VS_0),
		       info->start_instance);
d508 1
a508 1
	struct si_shader *ps = &sctx->ps_shader->current->shader;
d510 3
a512 1
	struct si_pm4_state *pm4 = si_pm4_alloc_state(sctx);
d515 5
a519 3
	for (i = 0; i < ps->ninput; i++) {
		unsigned name = ps->input[i].name;
		unsigned param_offset = ps->input[i].param_offset;
d528 3
a530 3
		if (ps->input[i].interpolate == TGSI_INTERPOLATE_CONSTANT ||
		    (ps->input[i].interpolate == TGSI_INTERPOLATE_COLOR &&
		     sctx->ps_shader->current->key.ps.flatshade)) {
d535 1
a535 1
		    sctx->sprite_coord_enable & (1 << ps->input[i].sid)) {
d539 4
a542 4
		for (j = 0; j < vs->noutput; j++) {
			if (name == vs->output[j].name &&
			    ps->input[i].sid == vs->output[j].sid) {
				tmp |= S_028644_OFFSET(vs->output[j].param_offset);
d547 1
a547 1
		if (j == vs->noutput) {
d557 1
a557 1
		    sctx->ps_shader->current->key.ps.color_two_side) {
d570 2
a571 1
	unsigned size = 128 * 1024;
d574 1
a574 1
	sctx->gs_rings = si_pm4_alloc_state(sctx);
d576 5
a580 10
	sctx->esgs_ring.buffer =
		pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
				   PIPE_USAGE_DEFAULT, size);
	sctx->esgs_ring.buffer_size = size;

	size = 64 * 1024 * 1024;
	sctx->gsvs_ring.buffer =
		pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
				   PIPE_USAGE_DEFAULT, size);
	sctx->gsvs_ring.buffer_size = size;
d584 1
a584 1
			       sctx->esgs_ring.buffer_size / 256);
d586 1
a586 1
			       sctx->gsvs_ring.buffer_size / 256);
d589 1
a589 1
			       sctx->esgs_ring.buffer_size / 256);
d591 1
a591 1
			       sctx->gsvs_ring.buffer_size / 256);
d595 1
a595 1
			   &sctx->esgs_ring, 0, sctx->esgs_ring.buffer_size,
d598 1
a598 1
			   &sctx->esgs_ring, 0, sctx->esgs_ring.buffer_size,
d601 1
a601 1
			   &sctx->gsvs_ring, 0, sctx->gsvs_ring.buffer_size,
a622 7

		if (!sctx->gs_shader->current->pm4) {
			si_pipe_shader_gs(ctx, sctx->gs_shader->current);
			si_pipe_shader_vs(ctx,
					  sctx->gs_shader->current->gs_copy_shader);
		}

a628 4

		if (!sctx->vs_shader->current->pm4)
			si_pipe_shader_es(ctx, sctx->vs_shader->current);

d638 3
a640 3
				   &sctx->gsvs_ring,
				   sctx->gs_shader->current->shader.gs_max_out_vertices *
				   sctx->gs_shader->current->shader.noutput * 16,
d644 1
a644 1
			sctx->gs_on = si_pm4_alloc_state(sctx);
a653 4

		if (!sctx->vs_shader->current->pm4)
			si_pipe_shader_vs(ctx, sctx->vs_shader->current);

d659 1
a659 1
			sctx->gs_off = si_pm4_alloc_state(sctx);
d672 9
a680 3
	if (!sctx->ps_shader->current->pm4 ||
	    sctx->ps_shader->current->cb0_is_integer != sctx->framebuffer.cb0_is_integer)
		si_pipe_shader_ps(ctx, sctx->ps_shader->current);
d684 1
a684 6
	if (si_pm4_state_changed(sctx, ps) || si_pm4_state_changed(sctx, vs)) {
		/* XXX: Emitting the PS state even when only the VS changed
		 * fixes random failures with piglit glsl-max-varyings.
		 * Not sure why...
		 */
		sctx->emitted.named.ps = NULL;
a685 30
	}
}

static void si_vertex_buffer_update(struct si_context *sctx)
{
	struct pipe_context *ctx = &sctx->b.b;
	struct si_pm4_state *pm4 = si_pm4_alloc_state(sctx);
	bool bound[PIPE_MAX_ATTRIBS] = {};
	unsigned i, count;
	uint64_t va;

	sctx->b.flags |= R600_CONTEXT_INV_TEX_CACHE;

	count = sctx->vertex_elements->count;
	assert(count <= 256 / 4);

	si_pm4_sh_data_begin(pm4);
	for (i = 0 ; i < count; i++) {
		struct pipe_vertex_element *ve = &sctx->vertex_elements->elements[i];
		struct pipe_vertex_buffer *vb;
		struct r600_resource *rbuffer;
		unsigned offset;

		if (ve->vertex_buffer_index >= sctx->nr_vertex_buffers)
			continue;

		vb = &sctx->vertex_buffer[ve->vertex_buffer_index];
		rbuffer = (struct r600_resource*)vb->buffer;
		if (rbuffer == NULL)
			continue;
d687 3
a689 26
		offset = 0;
		offset += vb->buffer_offset;
		offset += ve->src_offset;

		va = r600_resource_va(ctx->screen, (void*)rbuffer);
		va += offset;

		/* Fill in T# buffer resource description */
		si_pm4_sh_data_add(pm4, va & 0xFFFFFFFF);
		si_pm4_sh_data_add(pm4, (S_008F04_BASE_ADDRESS_HI(va >> 32) |
					 S_008F04_STRIDE(vb->stride)));
		if (vb->stride)
			/* Round up by rounding down and adding 1 */
			si_pm4_sh_data_add(pm4,
					   (vb->buffer->width0 - offset -
					    util_format_get_blocksize(ve->src_format)) /
					   vb->stride + 1);
		else
			si_pm4_sh_data_add(pm4, vb->buffer->width0 - offset);
		si_pm4_sh_data_add(pm4, sctx->vertex_elements->rsrc_word3[i]);

		if (!bound[ve->vertex_buffer_index]) {
			si_pm4_add_bo(pm4, rbuffer, RADEON_USAGE_READ,
				      RADEON_PRIO_SHADER_BUFFER_RO);
			bound[ve->vertex_buffer_index] = true;
		}
a690 5
	si_pm4_sh_data_end(pm4, sctx->gs_shader ?
			   R_00B330_SPI_SHADER_USER_DATA_ES_0 :
			   R_00B130_SPI_SHADER_USER_DATA_VS_0,
			   SI_SGPR_VERTEX_BUFFER);
	si_pm4_set_state(sctx, vertex_buffers, pm4);
d697 3
a699 1
	struct si_pm4_state *pm4 = si_pm4_alloc_state(sctx);
a703 17
	/* queries need some special values
	 * (this is non-zero if any query is active) */
	if (sctx->b.num_occlusion_queries > 0) {
		if (sctx->b.chip_class >= CIK) {
			si_pm4_set_reg(pm4, R_028004_DB_COUNT_CONTROL,
				       S_028004_PERFECT_ZPASS_COUNTS(1) |
				       S_028004_SAMPLE_RATE(sctx->framebuffer.log_samples) |
				       S_028004_ZPASS_ENABLE(1) |
				       S_028004_SLICE_EVEN_ENABLE(1) |
				       S_028004_SLICE_ODD_ENABLE(1));
		} else {
			si_pm4_set_reg(pm4, R_028004_DB_COUNT_CONTROL,
				       S_028004_PERFECT_ZPASS_COUNTS(1) |
				       S_028004_SAMPLE_RATE(sctx->framebuffer.log_samples));
		}
	}

d707 2
a708 3
		uint64_t va = r600_resource_va(&sctx->screen->b.b,
					       &t->buf_filled_size->b.b);
		va += t->buf_filled_size_offset;
d738 13
a750 3
	si_pm4_cmd_begin(pm4, PKT3_NUM_INSTANCES);
	si_pm4_cmd_add(pm4, info->instance_count);
	si_pm4_cmd_end(pm4, sctx->b.predicate_drawing);
d754 2
a755 4
				 sctx->index_buffer.index_size;
		uint64_t va;
		va = r600_resource_va(&sctx->screen->b.b, ib->buffer);
		va += ib->offset;
d759 14
a772 3
		si_cmd_draw_index_2(pm4, max_size, va, info->count,
				    V_0287F0_DI_SRC_SEL_DMA,
				    sctx->b.predicate_drawing);
d774 12
a785 3
		uint32_t initiator = V_0287F0_DI_SRC_SEL_AUTO_INDEX;
		initiator |= S_0287F0_USE_OPAQUE(!!info->count_from_stream_output);
		si_cmd_draw_index_auto(pm4, info->count, initiator, sctx->b.predicate_drawing);
d795 2
d830 1
a830 1
			radeon_emit(cs, PKT3(PKT3_ACQUIRE_MEM, 5, 0));
d838 1
a838 1
			radeon_emit(cs, PKT3(PKT3_SURFACE_SYNC, 3, 0));
d847 1
a847 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
d851 1
a851 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
d854 5
d862 1
a862 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
d866 1
a866 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
d870 5
d876 1
a876 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
d880 1
a880 1
		radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
d887 19
a905 1
const struct r600_atom si_atom_cache_flush = { si_emit_cache_flush, 17 }; /* number of CS dwords */
d913 2
a914 1
	if (!info->count && (info->indexed || !info->count_from_stream_output))
d921 5
a925 1
	si_vertex_buffer_update(sctx);
d932 1
a932 1
		ib.offset = sctx->index_buffer.offset + info->start * ib.index_size;
d937 1
a937 1
			unsigned out_offset;
d940 4
a943 1
			u_upload_alloc(sctx->b.uploader, 0, info->count * 2,
d946 3
a948 2
			util_shorten_ubyte_elts_to_userptr(
						&sctx->b.b, &ib, 0, ib.offset, info->count, ptr);
d953 2
a954 1
			ib.offset = out_offset;
d956 5
a960 1
		}
d962 5
a966 3
		if (ib.user_buffer && !ib.buffer) {
			u_upload_data(sctx->b.uploader, 0, info->count * ib.index_size,
				      ib.user_buffer, &ib.offset, &ib.buffer);
d1032 21
@


