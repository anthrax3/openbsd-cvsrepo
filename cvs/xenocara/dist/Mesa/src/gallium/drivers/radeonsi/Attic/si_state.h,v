head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.12.41;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.12.41;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.13;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2014.09.07.15.03.12;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	dm8VnQHhowGHmemJ;

1.1.1.4
date	2015.01.25.14.08.37;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.45.51;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2012 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *      Christian KÃ¶nig <christian.koenig@@amd.com>
 */

#ifndef SI_STATE_H
#define SI_STATE_H

#include "radeonsi_pm4.h"

struct si_state_blend {
	struct si_pm4_state	pm4;
	uint32_t		cb_target_mask;
	uint32_t		cb_color_control;
};

struct si_state_viewport {
	struct si_pm4_state		pm4;
	struct pipe_viewport_state	viewport;
};

struct si_state_rasterizer {
	struct si_pm4_state	pm4;
	bool			flatshade;
	bool			two_side;
	unsigned		sprite_coord_enable;
	unsigned		pa_sc_line_stipple;
	unsigned		pa_su_sc_mode_cntl;
	unsigned		pa_cl_clip_cntl;
	unsigned		pa_cl_vs_out_cntl;
	unsigned		clip_plane_enable;
	float			offset_units;
	float			offset_scale;
};

struct si_state_dsa {
	struct si_pm4_state	pm4;
	float			alpha_ref;
	unsigned		alpha_func;
	unsigned		db_render_override;
	unsigned		db_render_control;
	uint8_t			valuemask[2];
	uint8_t			writemask[2];
};

struct si_vertex_element
{
	unsigned			count;
	uint32_t			rsrc_word3[PIPE_MAX_ATTRIBS];
	struct pipe_vertex_element	elements[PIPE_MAX_ATTRIBS];
};

union si_state {
	struct {
		struct si_pm4_state		*sync;
		struct si_pm4_state		*init;
		struct si_state_blend		*blend;
		struct si_pm4_state		*blend_color;
		struct si_pm4_state		*clip;
		struct si_pm4_state		*scissor;
		struct si_state_viewport	*viewport;
		struct si_pm4_state		*framebuffer;
		struct si_state_rasterizer	*rasterizer;
		struct si_state_dsa		*dsa;
		struct si_pm4_state		*fb_rs;
		struct si_pm4_state		*fb_blend;
		struct si_pm4_state		*dsa_stencil_ref;
		struct si_pm4_state		*vs;
		struct si_pm4_state		*vs_sampler_views;
		struct si_pm4_state		*vs_sampler;
		struct si_pm4_state		*vs_const;
		struct si_pm4_state		*ps;
		struct si_pm4_state		*ps_sampler_views;
		struct si_pm4_state		*ps_sampler;
		struct si_pm4_state		*ps_const;
		struct si_pm4_state		*spi;
		struct si_pm4_state		*vertex_buffers;
		struct si_pm4_state		*texture_barrier;
		struct si_pm4_state		*draw_info;
		struct si_pm4_state		*draw;
	} named;
	struct si_pm4_state	*array[0];
};

#define si_pm4_block_idx(member) \
	(offsetof(union si_state, named.member) / sizeof(struct si_pm4_state *))

#define si_pm4_state_changed(rctx, member) \
	((rctx)->queued.named.member != (rctx)->emitted.named.member)

#define si_pm4_bind_state(rctx, member, value) \
	do { \
		(rctx)->queued.named.member = (value); \
	} while(0)

#define si_pm4_delete_state(rctx, member, value) \
	do { \
		if ((rctx)->queued.named.member == (value)) { \
			(rctx)->queued.named.member = NULL; \
		} \
		si_pm4_free_state(rctx, (struct si_pm4_state *)(value), \
				  si_pm4_block_idx(member)); \
	} while(0)

#define si_pm4_set_state(rctx, member, value) \
	do { \
		if ((rctx)->queued.named.member != (value)) { \
			si_pm4_free_state(rctx, \
				(struct si_pm4_state *)(rctx)->queued.named.member, \
				si_pm4_block_idx(member)); \
			(rctx)->queued.named.member = (value); \
		} \
	} while(0)

/* si_state.c */
struct si_pipe_shader_selector;

boolean si_is_format_supported(struct pipe_screen *screen,
                               enum pipe_format format,
                               enum pipe_texture_target target,
                               unsigned sample_count,
                               unsigned usage);
int si_shader_select(struct pipe_context *ctx,
		     struct si_pipe_shader_selector *sel,
		     unsigned *dirty);
void si_init_state_functions(struct r600_context *rctx);
void si_init_config(struct r600_context *rctx);

/* si_state_streamout.c */
struct pipe_stream_output_target *
si_create_so_target(struct pipe_context *ctx,
		    struct pipe_resource *buffer,
		    unsigned buffer_offset,
		    unsigned buffer_size);
void si_so_target_destroy(struct pipe_context *ctx,
			  struct pipe_stream_output_target *target);
void si_set_so_targets(struct pipe_context *ctx,
		       unsigned num_targets,
		       struct pipe_stream_output_target **targets,
		       unsigned append_bitmask);

/* si_state_draw.c */
void si_draw_vbo(struct pipe_context *ctx, const struct pipe_draw_info *dinfo);

/* si_commands.c */
void si_cmd_context_control(struct si_pm4_state *pm4);
void si_cmd_draw_index_2(struct si_pm4_state *pm4, uint32_t max_size,
			 uint64_t index_base, uint32_t index_count,
			 uint32_t initiator, bool predicate);
void si_cmd_draw_index_auto(struct si_pm4_state *pm4, uint32_t count,
			    uint32_t initiator, bool predicate);
void si_cmd_surface_sync(struct si_pm4_state *pm4, uint32_t cp_coher_cntl);

#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d30 1
a30 4
#include "si_pm4.h"
#include "../radeon/r600_pipe_common.h"

struct si_screen;
d35 1
a35 1
	bool			alpha_to_one;
a46 2
	bool			multisample_enable;
	bool			line_stipple_enable;
d61 1
d76 1
a80 1
		struct si_pm4_state		*sample_mask;
d83 1
a88 5
		struct si_pm4_state		*es;
		struct si_pm4_state		*gs;
		struct si_pm4_state		*gs_rings;
		struct si_pm4_state		*gs_sampler;
		struct si_pm4_state		*gs_onoff;
d90 1
d92 1
d94 1
d96 1
d99 1
a105 63
#define NUM_TEX_UNITS 16

/* User sampler views:   0..15
 * FMASK sampler views: 16..31 (no sampler states)
 */
#define FMASK_TEX_OFFSET	NUM_TEX_UNITS
#define NUM_SAMPLER_VIEWS	(FMASK_TEX_OFFSET+NUM_TEX_UNITS)
#define NUM_SAMPLER_STATES	NUM_TEX_UNITS

#define NUM_PIPE_CONST_BUFFERS	16
#define NUM_CONST_BUFFERS	(NUM_PIPE_CONST_BUFFERS + 1)

#define SI_RING_ESGS		0
#define SI_RING_GSVS		1

/* This represents resource descriptors in memory, such as buffer resources,
 * image resources, and sampler states.
 */
struct si_descriptors {
	struct r600_atom atom;

	/* The size of one resource descriptor. */
	unsigned element_dw_size;
	/* The maximum number of resource descriptors. */
	unsigned num_elements;

	/* The buffer where resource descriptors are stored. */
	struct r600_resource *buffer;

	/* The i-th bit is set if that element is dirty (changed but not emitted). */
	unsigned dirty_mask;
	/* The i-th bit is set if that element is enabled (non-NULL resource). */
	unsigned enabled_mask;

	/* We can't update descriptors directly because the GPU might be
	 * reading them at the same time, so we have to update them
	 * in a copy-on-write manner. Each such copy is called a context,
	 * which is just another array descriptors in the same buffer. */
	unsigned current_context_id;
	/* The size of a context, should be equal to 4*element_dw_size*num_elements. */
	unsigned context_size;

	/* The shader userdata register where the 64-bit pointer to the descriptor
	 * array will be stored. */
	unsigned shader_userdata_reg;
};

struct si_sampler_views {
	struct si_descriptors		desc;
	struct pipe_sampler_view	*views[NUM_SAMPLER_VIEWS];
	uint32_t			*desc_data[NUM_SAMPLER_VIEWS];
};

struct si_buffer_resources {
	struct si_descriptors		desc;
	unsigned			num_buffers;
	enum radeon_bo_usage		shader_usage; /* READ, WRITE, or READWRITE */
	enum radeon_bo_priority		priority;
	struct pipe_resource		**buffers; /* this has num_buffers elements */
	uint32_t			*desc_storage; /* this has num_buffers*4 elements */
	uint32_t			**desc_data; /* an array of pointers pointing to desc_storage */
};

d109 2
a110 2
#define si_pm4_state_changed(sctx, member) \
	((sctx)->queued.named.member != (sctx)->emitted.named.member)
d112 1
a112 1
#define si_pm4_bind_state(sctx, member, value) \
d114 1
a114 1
		(sctx)->queued.named.member = (value); \
d117 1
a117 1
#define si_pm4_delete_state(sctx, member, value) \
d119 2
a120 2
		if ((sctx)->queued.named.member == (value)) { \
			(sctx)->queued.named.member = NULL; \
d122 1
a122 1
		si_pm4_free_state(sctx, (struct si_pm4_state *)(value), \
d126 1
a126 1
#define si_pm4_set_state(sctx, member, value) \
d128 3
a130 3
		if ((sctx)->queued.named.member != (value)) { \
			si_pm4_free_state(sctx, \
				(struct si_pm4_state *)(sctx)->queued.named.member, \
d132 1
a132 1
			(sctx)->queued.named.member = (value); \
a135 18
/* si_descriptors.c */
void si_set_sampler_view(struct si_context *sctx, unsigned shader,
			 unsigned slot, struct pipe_sampler_view *view,
			 unsigned *view_desc);
void si_set_ring_buffer(struct pipe_context *ctx, uint shader, uint slot,
			struct pipe_constant_buffer *input,
			unsigned stride, unsigned num_records,
			bool add_tid, bool swizzle,
			unsigned element_size, unsigned index_stride);
void si_init_all_descriptors(struct si_context *sctx);
void si_release_all_descriptors(struct si_context *sctx);
void si_all_descriptors_begin_new_cs(struct si_context *sctx);
void si_copy_buffer(struct si_context *sctx,
		    struct pipe_resource *dst, struct pipe_resource *src,
		    uint64_t dst_offset, uint64_t src_offset, unsigned size);
void si_upload_const_buffer(struct si_context *sctx, struct r600_resource **rbuffer,
			    const uint8_t *ptr, unsigned size, uint32_t *const_offset);

d145 17
a161 10
		     struct si_pipe_shader_selector *sel);
void si_init_state_functions(struct si_context *sctx);
void si_init_config(struct si_context *sctx);
unsigned cik_bank_wh(unsigned bankwh);
unsigned cik_db_pipe_config(struct si_screen *sscreen, unsigned tile_mode);
unsigned cik_macro_tile_aspect(unsigned macro_tile_aspect);
unsigned cik_tile_split(unsigned tile_split);
uint32_t si_num_banks(struct si_screen *sscreen, unsigned bpe, unsigned tile_split,
		      unsigned tile_mode_index);
unsigned si_tile_mode_index(struct r600_texture *rtex, unsigned level, bool stencil);
a163 2
extern const struct r600_atom si_atom_cache_flush;
void si_emit_cache_flush(struct r600_common_context *sctx, struct r600_atom *atom);
@


1.1.1.3
log
@Import Mesa 10.2.7
@
text
@a40 10
struct si_state_sample_mask {
	struct si_pm4_state	pm4;
	uint16_t		sample_mask;
};

struct si_state_scissor {
	struct si_pm4_state		pm4;
	struct pipe_scissor_state	scissor;
};

d84 2
a85 2
		struct si_state_sample_mask	*sample_mask;
		struct si_state_scissor		*scissor;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d31 1
a31 1
#include "radeon/r600_pipe_common.h"
a33 1
struct si_shader;
a84 1
	uint32_t			format_size[PIPE_MAX_ATTRIBS];
a101 1
		struct si_pm4_state		*ta_bordercolor_base;
d105 1
d108 1
d110 1
d112 1
d119 1
a119 1
#define SI_NUM_USER_SAMPLERS 16 /* AKA OpenGL textures units per shader */
d124 6
a129 3
#define SI_FMASK_TEX_OFFSET		SI_NUM_USER_SAMPLERS
#define SI_NUM_SAMPLER_VIEWS		(SI_FMASK_TEX_OFFSET + SI_NUM_USER_SAMPLERS)
#define SI_NUM_SAMPLER_STATES		SI_NUM_USER_SAMPLERS
a130 12
/* User constant buffers:   0..15
 * Driver state constants:  16
 */
#define SI_NUM_USER_CONST_BUFFERS	16
#define SI_DRIVER_STATE_CONST_BUF	SI_NUM_USER_CONST_BUFFERS
#define SI_NUM_CONST_BUFFERS		(SI_DRIVER_STATE_CONST_BUF + 1)

/* Read-write buffer slots.
 *
 * Ring buffers:        0..1
 * Streamout buffers:   2..5
 */
a132 6
#define SI_NUM_RING_BUFFERS	2
#define SI_SO_BUF_OFFSET	SI_NUM_RING_BUFFERS
#define SI_NUM_RW_BUFFERS	(SI_SO_BUF_OFFSET + 4)

#define SI_NUM_VERTEX_BUFFERS	16

a146 1
	unsigned buffer_offset;
d168 2
a169 8
	struct pipe_sampler_view	*views[SI_NUM_SAMPLER_VIEWS];
	uint32_t			*desc_data[SI_NUM_SAMPLER_VIEWS];
};

struct si_sampler_states {
	struct si_descriptors		desc;
	uint32_t			*desc_data[SI_NUM_SAMPLER_STATES];
	void				*saved_states[2]; /* saved for u_blitter */
d213 3
a215 3
void si_set_sampler_descriptors(struct si_context *sctx, unsigned shader,
				unsigned start, unsigned count, void **states);
void si_update_vertex_buffers(struct si_context *sctx);
d217 1
a217 1
			struct pipe_resource *buffer,
d231 1
a231 1
struct si_shader_selector;
d239 1
a239 2
		     struct si_shader_selector *sel);
void si_make_dummy_ps(struct si_context *sctx);
d246 2
a247 1
uint32_t si_num_banks(struct si_screen *sscreen, struct r600_texture *tex);
a251 2
extern const struct r600_atom si_atom_msaa_config;
void si_shader_init_pm4_state(struct si_shader *shader);
d262 1
a262 7
void si_cmd_draw_indirect(struct si_pm4_state *pm4, uint64_t indirect_va,
			  uint32_t indirect_offset, uint32_t base_vtx_loc,
			  uint32_t start_inst_loc, bool predicate);
void si_cmd_draw_index_indirect(struct si_pm4_state *pm4, uint64_t indirect_va,
				uint64_t index_va, uint32_t index_max_size,
				uint32_t indirect_offset, uint32_t base_vtx_loc,
				uint32_t start_inst_loc, bool predicate);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d31 1
a31 1
#include "../radeon/r600_pipe_common.h"
d34 1
d86 1
d104 1
a107 1
		struct si_pm4_state		*gs_sampler;
a109 1
		struct si_pm4_state		*vs_sampler;
a110 1
		struct si_pm4_state		*ps_sampler;
a111 1
		struct si_pm4_state		*vertex_buffers;
d118 1
a118 1
#define NUM_TEX_UNITS 16
d123 3
a125 6
#define FMASK_TEX_OFFSET	NUM_TEX_UNITS
#define NUM_SAMPLER_VIEWS	(FMASK_TEX_OFFSET+NUM_TEX_UNITS)
#define NUM_SAMPLER_STATES	NUM_TEX_UNITS

#define NUM_PIPE_CONST_BUFFERS	16
#define NUM_CONST_BUFFERS	(NUM_PIPE_CONST_BUFFERS + 1)
d127 12
d141 6
d161 1
d183 8
a190 2
	struct pipe_sampler_view	*views[NUM_SAMPLER_VIEWS];
	uint32_t			*desc_data[NUM_SAMPLER_VIEWS];
d234 3
a236 3
void si_set_sampler_view(struct si_context *sctx, unsigned shader,
			 unsigned slot, struct pipe_sampler_view *view,
			 unsigned *view_desc);
d238 1
a238 1
			struct pipe_constant_buffer *input,
d252 1
a252 1
struct si_pipe_shader_selector;
d260 2
a261 1
		     struct si_pipe_shader_selector *sel);
d268 1
a268 2
uint32_t si_num_banks(struct si_screen *sscreen, unsigned bpe, unsigned tile_split,
		      unsigned tile_mode_index);
d273 2
d285 7
a291 1
void si_cmd_surface_sync(struct si_pm4_state *pm4, uint32_t cp_coher_cntl);
@


