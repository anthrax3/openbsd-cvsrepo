head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.2.0.2
	OPENBSD_5_6_BASE:1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.3;
commitid	4ry2gvZGMXkCUD2n;

1.3
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.2;
commitid	mcxB0JvoI9gTDYXU;

1.2
date	2014.07.09.21.08.54;	author jsg;	state Exp;
branches;
next	1.1;
commitid	WPD6rgPryPkvXOr9;

1.1
date	2013.09.05.13.12.36;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.12.36;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.13;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.08.32;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.45.45;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2011 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors: Tom Stellard <thomas.stellard@@amd.com>
 *
 */
#include "radeon_llvm_emit.h"
#include "radeon_elf_util.h"
#include "util/u_memory.h"

#include <llvm-c/Target.h>
#include <llvm-c/TargetMachine.h>
#include <llvm-c/Core.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define CPU_STRING_LEN 30
#define FS_STRING_LEN 30
#define TRIPLE_STRING_LEN 7

/**
 * Set the shader type we want to compile
 *
 * @@param type shader type to set
 */
void radeon_llvm_shader_type(LLVMValueRef F, unsigned type)
{
  char Str[2];
  sprintf(Str, "%1d", type);

  LLVMAddTargetDependentFunctionAttr(F, "ShaderType", Str);
}

static void init_r600_target() {
	static unsigned initialized = 0;
	if (!initialized) {
		LLVMInitializeR600TargetInfo();
		LLVMInitializeR600Target();
		LLVMInitializeR600TargetMC();
		LLVMInitializeR600AsmPrinter();
		initialized = 1;
	}
}

static LLVMTargetRef get_r600_target() {
	LLVMTargetRef target = NULL;

	for (target = LLVMGetFirstTarget(); target;
					target = LLVMGetNextTarget(target)) {
		if (!strncmp(LLVMGetTargetName(target), "r600", 4)) {
			break;
		}
	}

	if (!target) {
		fprintf(stderr, "Can't find target r600\n");
		return NULL;
	}
	return target;
}

#if HAVE_LLVM >= 0x0305 && !defined(__OpenBSD__)

static void radeonDiagnosticHandler(LLVMDiagnosticInfoRef di, void *context) {
	unsigned int *diagnosticflag;
	char *diaginfo_message;

	diaginfo_message = LLVMGetDiagInfoDescription(di);
	fprintf(stderr,"LLVM triggered Diagnostic Handler: %s\n", diaginfo_message);
	LLVMDisposeMessage(diaginfo_message);

	diagnosticflag = (unsigned int *)context;
	*diagnosticflag = ((LLVMDSError == LLVMGetDiagInfoSeverity(di)) ? 1 : 0);
}

#endif

/**
 * Compile an LLVM module to machine code.
 *
 * @@returns 0 for success, 1 for failure
 */
unsigned radeon_llvm_compile(LLVMModuleRef M, struct radeon_shader_binary *binary,
					  const char * gpu_family, unsigned dump) {

	LLVMTargetRef target;
	LLVMTargetMachineRef tm;
	char cpu[CPU_STRING_LEN];
	char fs[FS_STRING_LEN];
	char *err;
	LLVMContextRef llvm_ctx;
	unsigned rval = 0;
	LLVMMemoryBufferRef out_buffer;
	unsigned buffer_size;
	const char *buffer_data;
	char triple[TRIPLE_STRING_LEN];
	LLVMBool mem_err;

	/* initialise */
	init_r600_target();

	target = get_r600_target();
	if (!target) {
		return 1;
	}

	strncpy(cpu, gpu_family, CPU_STRING_LEN);
	memset(fs, 0, sizeof(fs));
	if (dump) {
		LLVMDumpModule(M);
		strncpy(fs, "+DumpCode", FS_STRING_LEN);
	}
	strncpy(triple, "r600--", TRIPLE_STRING_LEN);

	/* Setup Diagnostic Handler*/
	llvm_ctx = LLVMGetModuleContext(M);

#if HAVE_LLVM >= 0x0305 && !defined(__OpenBSD__)
	LLVMContextSetDiagnosticHandler(llvm_ctx, radeonDiagnosticHandler, &rval);
#endif
	rval = 0;

	/* Compile IR*/
	tm = LLVMCreateTargetMachine(target, triple, cpu, fs,
				  LLVMCodeGenLevelDefault, LLVMRelocDefault,
						  LLVMCodeModelDefault);
	mem_err = LLVMTargetMachineEmitToMemoryBuffer(tm, M, LLVMObjectFile, &err,
								 &out_buffer);

	/* Process Errors/Warnings */
	if (mem_err) {
		fprintf(stderr, "%s: %s", __FUNCTION__, err);
		FREE(err);
		LLVMDisposeTargetMachine(tm);
		return 1;
	}

	if (0 != rval) {
		fprintf(stderr, "%s: Processing Diag Flag\n", __FUNCTION__);
	}

	/* Extract Shader Code*/
	buffer_size = LLVMGetBufferSize(out_buffer);
	buffer_data = LLVMGetBufferStart(out_buffer);

	radeon_elf_read(buffer_data, buffer_size, binary, dump);

	/* Clean up */
	LLVMDisposeMemoryBuffer(out_buffer);
	LLVMDisposeTargetMachine(tm);
	return rval;
}
@


1.4
log
@Merge Mesa 10.2.9
@
text
@@


1.3
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a28 1
#include "pipe/p_shader_tokens.h"
a42 10
 * Shader types for the LLVM backend.
 */
enum radeon_llvm_shader_type {
	RADEON_LLVM_SHADER_PS = 0,
	RADEON_LLVM_SHADER_VS = 1,
	RADEON_LLVM_SHADER_GS = 2,
	RADEON_LLVM_SHADER_CS = 3,
};

/**
d49 2
a50 23
	char Str[2];
	enum radeon_llvm_shader_type llvm_type;

	switch (type) {
	case TGSI_PROCESSOR_VERTEX:
		llvm_type = RADEON_LLVM_SHADER_VS;
		break;
	case TGSI_PROCESSOR_GEOMETRY:
		llvm_type = RADEON_LLVM_SHADER_GS;
		break;
	case TGSI_PROCESSOR_FRAGMENT:
		llvm_type = RADEON_LLVM_SHADER_PS;
		break;
	case TGSI_PROCESSOR_COMPUTE:
		llvm_type = RADEON_LLVM_SHADER_CS;
		break;
	default:
		assert(0);
	}

	sprintf(Str, "%1d", llvm_type);

	LLVMAddTargetDependentFunctionAttr(F, "ShaderType", Str);
d52 1
a52 3
	if (type != TGSI_PROCESSOR_COMPUTE) {
		LLVMAddTargetDependentFunctionAttr(F, "unsafe-fp-math", "true");
	}
d55 1
a55 2
static void init_r600_target()
{
d66 1
a66 2
static LLVMTargetRef get_r600_target()
{
d85 10
a94 10
static void radeonDiagnosticHandler(LLVMDiagnosticInfoRef di, void *context)
{
	if (LLVMGetDiagInfoSeverity(di) == LLVMDSError) {
		unsigned int *diagnosticflag = (unsigned int *)context;
		char *diaginfo_message = LLVMGetDiagInfoDescription(di);

		*diagnosticflag = 1;
		fprintf(stderr,"LLVM triggered Diagnostic Handler: %s\n", diaginfo_message);
		LLVMDisposeMessage(diaginfo_message);
	}
d105 1
a105 2
					  const char *gpu_family, unsigned dump)
{
@


1.2
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d29 1
d44 10
d60 23
a82 2
  char Str[2];
  sprintf(Str, "%1d", type);
d84 3
a86 1
  LLVMAddTargetDependentFunctionAttr(F, "ShaderType", Str);
d89 2
a90 1
static void init_r600_target() {
d101 2
a102 1
static LLVMTargetRef get_r600_target() {
d121 10
a130 10
static void radeonDiagnosticHandler(LLVMDiagnosticInfoRef di, void *context) {
	unsigned int *diagnosticflag;
	char *diaginfo_message;

	diaginfo_message = LLVMGetDiagInfoDescription(di);
	fprintf(stderr,"LLVM triggered Diagnostic Handler: %s\n", diaginfo_message);
	LLVMDisposeMessage(diaginfo_message);

	diagnosticflag = (unsigned int *)context;
	*diagnosticflag = ((LLVMDSError == LLVMGetDiagInfoSeverity(di)) ? 1 : 0);
d141 2
a142 1
					  const char * gpu_family, unsigned dump) {
@


1.1
log
@Initial revision
@
text
@d27 1
d32 1
a36 2
#include <libelf.h>
#include <gelf.h>
d83 16
d104 1
a104 1
unsigned radeon_llvm_compile(LLVMModuleRef M, struct radeon_llvm_binary *binary,
d112 2
d118 1
a118 5
	char *elf_buffer;
	Elf *elf;
	Elf_Scn *section = NULL;
	size_t section_str_index;
	LLVMBool r;
d120 1
d135 10
d148 2
d151 3
a153 4
	r = LLVMTargetMachineEmitToMemoryBuffer(tm, M, LLVMObjectFile, &err,
								 &out_buffer);
	if (r) {
		fprintf(stderr, "%s", err);
d155 1
d159 5
d167 1
a167 33
	/* One of the libelf implementations
	 * (http://www.mr511.de/software/english.htm) requires calling
	 * elf_version() before elf_memory().
	 */
	elf_version(EV_CURRENT);
	elf_buffer = MALLOC(buffer_size);
	memcpy(elf_buffer, buffer_data, buffer_size);

	elf = elf_memory(elf_buffer, buffer_size);

	elf_getshdrstrndx(elf, &section_str_index);

	while ((section = elf_nextscn(elf, section))) {
		const char *name;
		Elf_Data *section_data = NULL;
		GElf_Shdr section_header;
		if (gelf_getshdr(section, &section_header) != &section_header) {
			fprintf(stderr, "Failed to read ELF section header\n");
			return 1;
		}
		name = elf_strptr(elf, section_str_index, section_header.sh_name);
		if (!strcmp(name, ".text")) {
			section_data = elf_getdata(section, section_data);
			binary->code_size = section_data->d_size;
			binary->code = MALLOC(binary->code_size * sizeof(unsigned char));
			memcpy(binary->code, section_data->d_buf, binary->code_size);
		} else if (!strcmp(name, ".AMDGPU.config")) {
			section_data = elf_getdata(section, section_data);
			binary->config_size = section_data->d_size;
			binary->config = MALLOC(binary->config_size * sizeof(unsigned char));
			memcpy(binary->config, section_data->d_buf, binary->config_size);
		}
	}
d169 1
d172 1
a172 1
	return 0;
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a26 1
#include "radeon_elf_util.h"
a30 1
#include <llvm-c/Core.h>
d35 2
a82 16
#if HAVE_LLVM >= 0x0305

static void radeonDiagnosticHandler(LLVMDiagnosticInfoRef di, void *context) {
	unsigned int *diagnosticflag;
	char *diaginfo_message;

	diaginfo_message = LLVMGetDiagInfoDescription(di);
	fprintf(stderr,"LLVM triggered Diagnostic Handler: %s\n", diaginfo_message);
	LLVMDisposeMessage(diaginfo_message);

	diagnosticflag = (unsigned int *)context;
	*diagnosticflag = ((LLVMDSError == LLVMGetDiagInfoSeverity(di)) ? 1 : 0);
}

#endif

d88 1
a88 1
unsigned radeon_llvm_compile(LLVMModuleRef M, struct radeon_shader_binary *binary,
a95 2
	LLVMContextRef llvm_ctx;
	unsigned rval = 0;
d100 5
a104 1
	LLVMBool mem_err;
a105 1
	/* initialise */
a119 10

	/* Setup Diagnostic Handler*/
	llvm_ctx = LLVMGetModuleContext(M);

#if HAVE_LLVM >= 0x0305
	LLVMContextSetDiagnosticHandler(llvm_ctx, radeonDiagnosticHandler, &rval);
#endif
	rval = 0;

	/* Compile IR*/
d123 2
a124 1
	mem_err = LLVMTargetMachineEmitToMemoryBuffer(tm, M, LLVMObjectFile, &err,
d126 2
a127 4

	/* Process Errors/Warnings */
	if (mem_err) {
		fprintf(stderr, "%s: %s", __FUNCTION__, err);
a128 1
		LLVMDisposeTargetMachine(tm);
a131 5
	if (0 != rval) {
		fprintf(stderr, "%s: Processing Diag Flag\n", __FUNCTION__);
	}

	/* Extract Shader Code*/
d135 33
a167 1
	radeon_elf_read(buffer_data, buffer_size, binary, dump);
a168 1
	/* Clean up */
d171 1
a171 1
	return rval;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a28 1
#include "pipe/p_shader_tokens.h"
a42 10
 * Shader types for the LLVM backend.
 */
enum radeon_llvm_shader_type {
	RADEON_LLVM_SHADER_PS = 0,
	RADEON_LLVM_SHADER_VS = 1,
	RADEON_LLVM_SHADER_GS = 2,
	RADEON_LLVM_SHADER_CS = 3,
};

/**
d49 2
a50 23
	char Str[2];
	enum radeon_llvm_shader_type llvm_type;

	switch (type) {
	case TGSI_PROCESSOR_VERTEX:
		llvm_type = RADEON_LLVM_SHADER_VS;
		break;
	case TGSI_PROCESSOR_GEOMETRY:
		llvm_type = RADEON_LLVM_SHADER_GS;
		break;
	case TGSI_PROCESSOR_FRAGMENT:
		llvm_type = RADEON_LLVM_SHADER_PS;
		break;
	case TGSI_PROCESSOR_COMPUTE:
		llvm_type = RADEON_LLVM_SHADER_CS;
		break;
	default:
		assert(0);
	}

	sprintf(Str, "%1d", llvm_type);

	LLVMAddTargetDependentFunctionAttr(F, "ShaderType", Str);
d52 1
a52 3
	if (type != TGSI_PROCESSOR_COMPUTE) {
		LLVMAddTargetDependentFunctionAttr(F, "unsafe-fp-math", "true");
	}
d55 1
a55 2
static void init_r600_target()
{
d66 1
a66 2
static LLVMTargetRef get_r600_target()
{
d85 10
a94 10
static void radeonDiagnosticHandler(LLVMDiagnosticInfoRef di, void *context)
{
	if (LLVMGetDiagInfoSeverity(di) == LLVMDSError) {
		unsigned int *diagnosticflag = (unsigned int *)context;
		char *diaginfo_message = LLVMGetDiagInfoDescription(di);

		*diagnosticflag = 1;
		fprintf(stderr,"LLVM triggered Diagnostic Handler: %s\n", diaginfo_message);
		LLVMDisposeMessage(diaginfo_message);
	}
d105 1
a105 2
					  const char *gpu_family, unsigned dump)
{
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d29 1
d44 10
d60 23
a82 2
  char Str[2];
  sprintf(Str, "%1d", type);
d84 3
a86 1
  LLVMAddTargetDependentFunctionAttr(F, "ShaderType", Str);
d89 2
a90 1
static void init_r600_target() {
d101 2
a102 1
static LLVMTargetRef get_r600_target() {
d121 10
a130 10
static void radeonDiagnosticHandler(LLVMDiagnosticInfoRef di, void *context) {
	unsigned int *diagnosticflag;
	char *diaginfo_message;

	diaginfo_message = LLVMGetDiagInfoDescription(di);
	fprintf(stderr,"LLVM triggered Diagnostic Handler: %s\n", diaginfo_message);
	LLVMDisposeMessage(diaginfo_message);

	diagnosticflag = (unsigned int *)context;
	*diagnosticflag = ((LLVMDSError == LLVMGetDiagInfoSeverity(di)) ? 1 : 0);
d141 2
a142 1
					  const char * gpu_family, unsigned dump) {
@


