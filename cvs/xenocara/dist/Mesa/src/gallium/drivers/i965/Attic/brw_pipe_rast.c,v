head	1.4;
access;
symbols
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.09.05.14.00.20;	author jsg;	state dead;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.04;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@
#include "util/u_memory.h"
#include "pipe/p_defines.h"
#include "brw_context.h"
#include "brw_defines.h"
#include "brw_pipe_rast.h"
#include "brw_wm.h"


static unsigned translate_fill( unsigned fill )
{
   switch (fill) {
   case PIPE_POLYGON_MODE_FILL:
      return CLIP_FILL;
   case PIPE_POLYGON_MODE_LINE:
      return CLIP_LINE;
   case PIPE_POLYGON_MODE_POINT:
      return CLIP_POINT;
   default:
      assert(0);
      return CLIP_FILL;
   }
}


/* Calculates the key for triangle-mode clipping.  Non-triangle
 * clipping keys use much less information and are computed on the
 * fly.
 */
static void
calculate_clip_key_rast( const struct brw_context *brw,
			 const struct pipe_rasterizer_state *templ,
			 const struct brw_rasterizer_state *rast,
			 struct brw_clip_prog_key *key)
{
   memset(key, 0, sizeof *key);

   if (brw->gen == 5)
       key->clip_mode = BRW_CLIPMODE_KERNEL_CLIP;
   else
       key->clip_mode = BRW_CLIPMODE_NORMAL;

   key->do_flat_shading = templ->flatshade;

   if (templ->cull_face == PIPE_FACE_FRONT_AND_BACK) {
      key->clip_mode = BRW_CLIPMODE_REJECT_ALL;
      return;
   }

   key->fill_ccw = CLIP_CULL;
   key->fill_cw = CLIP_CULL;

   if (!(templ->cull_face & PIPE_FACE_FRONT)) {
      if (templ->front_ccw)
         key->fill_ccw = translate_fill(templ->fill_front);
      else 
         key->fill_cw = translate_fill(templ->fill_front);
   }

   if (!(templ->cull_face & PIPE_FACE_BACK)) {
      if (templ->front_ccw)
         key->fill_cw = translate_fill(templ->fill_back);
      else 
         key->fill_ccw = translate_fill(templ->fill_back);
   }

   if (key->fill_cw == CLIP_LINE ||
       key->fill_ccw == CLIP_LINE ||
       key->fill_cw == CLIP_POINT ||
       key->fill_ccw == CLIP_POINT) {
      key->do_unfilled = 1;
      key->clip_mode = BRW_CLIPMODE_CLIP_NON_REJECTED;
   }

   switch (key->fill_cw) {
   case CLIP_POINT:
      key->offset_cw = templ->offset_point;
      break;
   case CLIP_LINE:
      key->offset_cw = templ->offset_line;
      break;
   case CLIP_FILL:
      key->offset_cw = templ->offset_tri;
      break;
   }

   switch (key->fill_ccw) {
   case CLIP_POINT:
      key->offset_ccw = templ->offset_point;
      break;
   case CLIP_LINE:
      key->offset_ccw = templ->offset_line;
      break;
   case CLIP_FILL:
      key->offset_ccw = templ->offset_tri;
      break;
   }

   if (templ->light_twoside && key->fill_cw != CLIP_CULL) 
      key->copy_bfc_cw = 1;
   
   if (templ->light_twoside && key->fill_ccw != CLIP_CULL) 
      key->copy_bfc_ccw = 1;
}


static void
calculate_line_stipple_rast( const struct pipe_rasterizer_state *templ,
			     struct brw_line_stipple *bls )
{
   GLfloat tmp = 1.0f / (templ->line_stipple_factor + 1);
   GLint tmpi = tmp * (1<<13);

   bls->header.opcode = CMD_LINE_STIPPLE_PATTERN;
   bls->header.length = sizeof(*bls)/4 - 2;
   bls->bits0.pattern = templ->line_stipple_pattern;
   bls->bits1.repeat_count = templ->line_stipple_factor + 1;
   bls->bits1.inverse_repeat_count = tmpi;
}

static void *brw_create_rasterizer_state( struct pipe_context *pipe,
					  const struct pipe_rasterizer_state *templ )
{
   struct brw_context *brw = brw_context(pipe);
   struct brw_rasterizer_state *rast;

   rast = CALLOC_STRUCT(brw_rasterizer_state);
   if (rast == NULL)
      return NULL;

   rast->templ = *templ;

   calculate_clip_key_rast( brw, templ, rast, &rast->clip_key );
   
   if (templ->line_stipple_enable)
      calculate_line_stipple_rast( templ, &rast->bls );

   /* Caclculate lookup value for WM IZ table.
    */
   if (templ->line_smooth) {
      if (templ->fill_front == PIPE_POLYGON_MODE_LINE &&
	  templ->fill_back == PIPE_POLYGON_MODE_LINE) {
	 rast->unfilled_aa_line = AA_ALWAYS;
      }
      else if (templ->fill_front == PIPE_POLYGON_MODE_LINE ||
	       templ->fill_back == PIPE_POLYGON_MODE_LINE) {
	 rast->unfilled_aa_line = AA_SOMETIMES;
      }
      else {
	 rast->unfilled_aa_line = AA_NEVER;
      }
   }
   else {
      rast->unfilled_aa_line = AA_NEVER;
   }

   return (void *)rast;
}


static void brw_bind_rasterizer_state(struct pipe_context *pipe,
				 void *cso)
{
   struct brw_context *brw = brw_context(pipe);
   brw->curr.rast = (const struct brw_rasterizer_state *)cso;
   brw->state.dirty.mesa |= PIPE_NEW_RAST;
}

static void brw_delete_rasterizer_state(struct pipe_context *pipe,
				  void *cso)
{
   struct brw_context *brw = brw_context(pipe);
   assert((const void *)cso != (const void *)brw->curr.rast);
   FREE(cso);
}



void brw_pipe_rast_init( struct brw_context *brw )
{
   brw->base.create_rasterizer_state = brw_create_rasterizer_state;
   brw->base.bind_rasterizer_state = brw_bind_rasterizer_state;
   brw->base.delete_rasterizer_state = brw_delete_rasterizer_state;
}

void brw_pipe_rast_cleanup( struct brw_context *brw )
{
}
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@d38 1
a38 1
   if (brw->chipset.is_igdng)
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d45 1
a45 1
   if (templ->cull_mode == PIPE_WINDING_BOTH) {
d53 5
a57 2
   if (!(templ->cull_mode & PIPE_WINDING_CCW)) {
      key->fill_ccw = translate_fill(templ->fill_ccw);
d60 5
a64 2
   if (!(templ->cull_mode & PIPE_WINDING_CW)) {
      key->fill_cw = translate_fill(templ->fill_cw);
d75 23
a97 2
   key->offset_ccw = templ->offset_ccw;
   key->offset_cw = templ->offset_cw;
d141 2
a142 2
      if (templ->fill_cw == PIPE_POLYGON_MODE_LINE &&
	  templ->fill_ccw == PIPE_POLYGON_MODE_LINE) {
d145 2
a146 2
      else if (templ->fill_cw == PIPE_POLYGON_MODE_LINE ||
	       templ->fill_ccw == PIPE_POLYGON_MODE_LINE) {
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d45 1
a45 1
   if (templ->cull_face == PIPE_FACE_FRONT_AND_BACK) {
d53 2
a54 5
   if (!(templ->cull_face & PIPE_FACE_FRONT)) {
      if (templ->front_ccw)
         key->fill_ccw = translate_fill(templ->fill_front);
      else 
         key->fill_cw = translate_fill(templ->fill_front);
d57 2
a58 5
   if (!(templ->cull_face & PIPE_FACE_BACK)) {
      if (templ->front_ccw)
         key->fill_cw = translate_fill(templ->fill_back);
      else 
         key->fill_ccw = translate_fill(templ->fill_back);
d69 2
a70 23
   switch (key->fill_cw) {
   case CLIP_POINT:
      key->offset_cw = templ->offset_point;
      break;
   case CLIP_LINE:
      key->offset_cw = templ->offset_line;
      break;
   case CLIP_FILL:
      key->offset_cw = templ->offset_tri;
      break;
   }

   switch (key->fill_ccw) {
   case CLIP_POINT:
      key->offset_ccw = templ->offset_point;
      break;
   case CLIP_LINE:
      key->offset_ccw = templ->offset_line;
      break;
   case CLIP_FILL:
      key->offset_ccw = templ->offset_tri;
      break;
   }
d114 2
a115 2
      if (templ->fill_front == PIPE_POLYGON_MODE_LINE &&
	  templ->fill_back == PIPE_POLYGON_MODE_LINE) {
d118 2
a119 2
      else if (templ->fill_front == PIPE_POLYGON_MODE_LINE ||
	       templ->fill_back == PIPE_POLYGON_MODE_LINE) {
@

