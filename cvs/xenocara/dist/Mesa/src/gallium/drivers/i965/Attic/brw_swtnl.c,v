head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.0.14
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.12
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.10
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.09.05.14.00.25;	author jsg;	state dead;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.27;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge Mesa 9.2.0
@
text
@
#include "brw_context.h"
#include "brw_pipe_rast.h"


#if 0

static GLboolean need_swtnl( struct brw_context *brw )
{
   const struct pipe_rasterizer_state *rast = &brw->curr.rast->templ;

   /* If we don't require strict OpenGL conformance, never 
    * use fallbacks.  If we're forcing fallbacks, always
    * use fallfacks.
    */
   if (brw->flags.no_swtnl)
      return FALSE;

   if (brw->flags.force_swtnl)
      return TRUE;

   /* Exceeding hw limits on number of VS inputs?
    */
   if (brw->curr.num_vertex_elements == 0 ||
       brw->curr.num_vertex_elements >= BRW_VEP_MAX) {
      return TRUE;
   }

   /* Position array with zero stride?
    *
    * XXX: position isn't always at zero...
    * XXX: eliminate zero-stride arrays
    */
   {
      int ve0_vb = brw->curr.vertex_element[0].vertex_buffer_index;
      
      if (brw->curr.vertex_buffer[ve0_vb].stride == 0)
	 return TRUE;
   }

   /* XXX: short-circuit
    */
   return FALSE;

   if (brw->reduced_primitive == PIPE_PRIM_TRIANGLES) {
      if (rast->poly_smooth)
	 return TRUE;

   }
   
   if (brw->reduced_primitive == PIPE_PRIM_LINES ||
       (brw->reduced_primitive == PIPE_PRIM_TRIANGLES &&
	(rast->fill_cw == PIPE_POLYGON_MODE_LINE ||
	 rast->fill_ccw == PIPE_POLYGON_MODE_LINE)))
   {
      /* BRW hardware will do AA lines, but they are non-conformant it
       * seems.  TBD whether we keep this fallback:
       */
      if (rast->line_smooth)
	 return TRUE;

      /* XXX: was a fallback in mesa (gs doesn't get enough
       * information to know when to reset stipple counter), but there
       * must be a way around it.
       */
      if (rast->line_stipple_enable &&
	  (brw->reduced_primitive == PIPE_PRIM_TRIANGLES ||
	   brw->primitive == PIPE_PRIM_LINE_LOOP || 
	   brw->primitive == PIPE_PRIM_LINE_STRIP))
	 return TRUE;
   }

   
   if (brw->reduced_primitive == PIPE_PRIM_POINTS ||
       (brw->reduced_primitive == PIPE_PRIM_TRIANGLES &&
	(rast->fill_cw == PIPE_POLYGON_MODE_POINT ||
	 rast->fill_ccw == PIPE_POLYGON_MODE_POINT)))
   {
      if (rast->point_smooth)
	 return TRUE;
   }

   /* BRW hardware doesn't handle CLAMP texturing correctly;
    * brw_wm_sampler_state:translate_wrap_mode() treats CLAMP
    * as CLAMP_TO_EDGE instead.  If we're using CLAMP, and
    * we want strict conformance, force the fallback.
    *
    * XXX: need a workaround for this.
    */
      
   /* Nothing stopping us from the fast path now */
   return FALSE;
}

#endif
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@

