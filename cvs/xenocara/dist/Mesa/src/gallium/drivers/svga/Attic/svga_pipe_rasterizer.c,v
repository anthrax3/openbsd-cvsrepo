head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.09;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "draw/draw_context.h"
#include "util/u_inlines.h"
#include "pipe/p_defines.h"
#include "util/u_math.h"
#include "util/u_memory.h"

#include "svga_context.h"
#include "svga_screen.h"

#include "svga_hw_reg.h"

/* Hardware frontwinding is always set up as SVGA3D_FRONTWINDING_CW.
 */
static SVGA3dFace svga_translate_cullmode( unsigned mode,
                                           unsigned front_ccw )
{
   const int hw_front_ccw = 0;  /* hardware is always CW */
   switch (mode) {
   case PIPE_FACE_NONE:
      return SVGA3D_FACE_NONE;
   case PIPE_FACE_FRONT:
      return front_ccw == hw_front_ccw ? SVGA3D_FACE_FRONT : SVGA3D_FACE_BACK;
   case PIPE_FACE_BACK:
      return front_ccw == hw_front_ccw ? SVGA3D_FACE_BACK : SVGA3D_FACE_FRONT;
   case PIPE_FACE_FRONT_AND_BACK:
      return SVGA3D_FACE_FRONT_BACK;
   default:
      assert(0);
      return SVGA3D_FACE_NONE;
   }
}

static SVGA3dShadeMode svga_translate_flatshade( unsigned mode )
{
   return mode ? SVGA3D_SHADEMODE_FLAT : SVGA3D_SHADEMODE_SMOOTH;
}


static void *
svga_create_rasterizer_state(struct pipe_context *pipe,
                             const struct pipe_rasterizer_state *templ)
{
   struct svga_context *svga = svga_context(pipe);
   struct svga_rasterizer_state *rast = CALLOC_STRUCT( svga_rasterizer_state );
   struct svga_screen *screen = svga_screen(pipe->screen);

   /* need this for draw module. */
   rast->templ = *templ;

   /* light_twoside          - XXX: need fragment shader variant */
   /* poly_smooth            - XXX: no fallback available */
   /* poly_stipple_enable    - draw module */
   /* sprite_coord_enable    - ? */
   /* point_quad_rasterization - ? */
   /* point_size_per_vertex  - ? */
   /* sprite_coord_mode      - ??? */
   /* flatshade_first        - handled by index translation */
   /* half_pixel_center      - XXX - viewport code */
   /* line_width             - draw module */
   /* fill_cw, fill_ccw      - draw module or index translation */

   rast->shademode = svga_translate_flatshade( templ->flatshade );
   rast->cullmode = svga_translate_cullmode( templ->cull_face, 
                                             templ->front_ccw );
   rast->scissortestenable = templ->scissor;
   rast->multisampleantialias = templ->multisample;
   rast->antialiasedlineenable = templ->line_smooth;
   rast->lastpixel = templ->line_last_pixel;
   rast->pointsprite = templ->sprite_coord_enable != 0x0;
   rast->pointsize = templ->point_size;
   rast->hw_unfilled = PIPE_POLYGON_MODE_FILL;

   /* Use swtnl + decomposition implement these:
    */
   if (templ->poly_stipple_enable) {
      rast->need_pipeline |= SVGA_PIPELINE_FLAG_TRIS;
      rast->need_pipeline_tris_str = "poly stipple";
   }

   if (screen->maxLineWidth > 1.0F) {
      /* pass line width to device */
      rast->linewidth = MAX2(1.0F, templ->line_width);
   }
   else if (svga->debug.no_line_width) {
      /* nothing */
   }
   else {
      /* use 'draw' pipeline for wide line */
      rast->need_pipeline |= SVGA_PIPELINE_FLAG_LINES;
      rast->need_pipeline_lines_str = "line width";
   }

   if (templ->line_stipple_enable) {
      if (screen->haveLineStipple || svga->debug.force_hw_line_stipple) {
         SVGA3dLinePattern lp;
         lp.repeat = templ->line_stipple_factor + 1;
         lp.pattern = templ->line_stipple_pattern;
         rast->linepattern = lp.uintValue;
      }
      else {
         /* use 'draw' module to decompose into short line segments */
         rast->need_pipeline |= SVGA_PIPELINE_FLAG_LINES;
         rast->need_pipeline_lines_str = "line stipple";
      }
   } 

   if (templ->point_smooth) {
      rast->need_pipeline |= SVGA_PIPELINE_FLAG_POINTS;
      rast->need_pipeline_points_str = "smooth points";
   }

   if (templ->line_smooth && !screen->haveLineSmooth) {
      /*
       * XXX: Enabling the pipeline slows down performance immensely, so ignore
       * line smooth state, where there is very little visual improvement.
       * Smooth lines will still be drawn for wide lines.
       */
#if 0
      rast->need_pipeline |= SVGA_PIPELINE_FLAG_LINES;
      rast->need_pipeline_lines_str = "smooth lines";
#endif
   }

   {
      int fill_front = templ->fill_front;
      int fill_back = templ->fill_back;
      int fill = PIPE_POLYGON_MODE_FILL;
      boolean offset_front = util_get_offset(templ, fill_front);
      boolean offset_back = util_get_offset(templ, fill_back);
      boolean offset = FALSE;

      switch (templ->cull_face) {
      case PIPE_FACE_FRONT_AND_BACK:
         offset = FALSE;
         fill = PIPE_POLYGON_MODE_FILL;
         break;

      case PIPE_FACE_FRONT:
         offset = offset_front;
         fill = fill_front;
         break;

      case PIPE_FACE_BACK:
         offset = offset_back;
         fill = fill_back;
         break;

      case PIPE_FACE_NONE:
         if (fill_front != fill_back || offset_front != offset_back) 
         {
            /* Always need the draw module to work out different
             * front/back fill modes:
             */
            rast->need_pipeline |= SVGA_PIPELINE_FLAG_TRIS;
            rast->need_pipeline_tris_str = "different front/back fillmodes";
         }
         else {
            offset = offset_front;
            fill = fill_front;
         }
         break;

      default:
         assert(0);
         break;
      }

      /* Unfilled primitive modes aren't implemented on all virtual
       * hardware.  We can do some unfilled processing with index
       * translation, but otherwise need the draw module:
       */
      if (fill != PIPE_POLYGON_MODE_FILL &&
          (templ->flatshade ||
           templ->light_twoside ||
           offset ||
           templ->cull_face != PIPE_FACE_NONE)) 
      {
         fill = PIPE_POLYGON_MODE_FILL;
         rast->need_pipeline |= SVGA_PIPELINE_FLAG_TRIS;
         rast->need_pipeline_tris_str = "unfilled primitives with no index manipulation";
      }

      /* If we are decomposing to lines, and lines need the pipeline,
       * then we also need the pipeline for tris.
       */
      if (fill == PIPE_POLYGON_MODE_LINE &&
          (rast->need_pipeline & SVGA_PIPELINE_FLAG_LINES))
      {
         fill = PIPE_POLYGON_MODE_FILL;
         rast->need_pipeline |= SVGA_PIPELINE_FLAG_TRIS;
         rast->need_pipeline_tris_str = "decomposing lines";
      }

      /* Similarly for points:
       */
      if (fill == PIPE_POLYGON_MODE_POINT &&
          (rast->need_pipeline & SVGA_PIPELINE_FLAG_POINTS))
      {
         fill = PIPE_POLYGON_MODE_FILL;
         rast->need_pipeline |= SVGA_PIPELINE_FLAG_TRIS;
         rast->need_pipeline_tris_str = "decomposing points";
      }

      if (offset) {
         rast->slopescaledepthbias = templ->offset_scale;
         rast->depthbias = templ->offset_units;
      }

      rast->hw_unfilled = fill;
   }

   if (rast->need_pipeline & SVGA_PIPELINE_FLAG_TRIS) {
      /* Turn off stuff which will get done in the draw module:
       */
      rast->hw_unfilled = PIPE_POLYGON_MODE_FILL;
      rast->slopescaledepthbias = 0;
      rast->depthbias = 0;
   }

   if (0 && rast->need_pipeline) {
      debug_printf("svga: rast need_pipeline = 0x%x\n", rast->need_pipeline);
      debug_printf(" pnts: %s \n", rast->need_pipeline_points_str);
      debug_printf(" lins: %s \n", rast->need_pipeline_lines_str);
      debug_printf(" tris: %s \n", rast->need_pipeline_tris_str);
   }

   return rast;
}

static void svga_bind_rasterizer_state( struct pipe_context *pipe,
                                        void *state )
{
   struct svga_context *svga = svga_context(pipe);
   struct svga_rasterizer_state *raster = (struct svga_rasterizer_state *)state;


   draw_set_rasterizer_state(svga->swtnl.draw, raster ? &raster->templ : NULL,
                             state);
   svga->curr.rast = raster;

   svga->dirty |= SVGA_NEW_RAST;
}

static void svga_delete_rasterizer_state(struct pipe_context *pipe,
                                         void *raster)
{
   FREE(raster);
}


void svga_init_rasterizer_functions( struct svga_context *svga )
{
   svga->pipe.create_rasterizer_state = svga_create_rasterizer_state;
   svga->pipe.bind_rasterizer_state = svga_bind_rasterizer_state;
   svga->pipe.delete_rasterizer_state = svga_delete_rasterizer_state;
}


/***********************************************************************
 * Hardware state update
 */

@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d33 1
d70 1
d105 9
a113 2
   if (templ->line_width >= 1.5f &&
       !svga->debug.no_line_width) {
d119 1
a119 4
      /* XXX: LinePattern not implemented on all backends, and there is no
       * mechanism to query it.
       */
      if (!svga->debug.force_hw_line_stipple) {
d126 1
d137 7
a143 1
   if (templ->line_smooth) {
d146 1
d155 1
a155 1
      boolean offset  = 0;
d159 1
a159 1
         offset = 0;
d243 7
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d81 1
a81 1
   /* gl_rasterization_rules - XXX - viewport code */
d92 1
a239 1
   svga->curr.rast = raster;
d243 2
a244 1
   
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d67 1
d69 1
d73 1
a73 1
   /* light_twoside          - XXX: need fragment shader varient */
a79 1
   /* bypass_vs_viewport_and_clip        - handled by viewport setup */
d97 1
a97 1
   if (templ->poly_stipple_enable)
d99 2
d102 2
a103 2
   if (templ->line_width != 1.0 &&
       templ->line_width != 0.0)
d105 2
d109 2
a110 1
      /* LinePattern not implemented on all backends. 
d112 1
a112 1
      if (0) {
d120 1
d124 1
a124 1
   if (templ->point_smooth)
d126 7
d165 1
d190 1
d201 1
d211 1
a220 3



@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 1
a39 1
                                           unsigned front_winding )
d41 1
d43 1
a43 1
   case PIPE_WINDING_NONE:
d45 5
a49 5
   case PIPE_WINDING_CCW:
      return SVGA3D_FACE_BACK;
   case PIPE_WINDING_CW:
      return SVGA3D_FACE_FRONT;
   case PIPE_WINDING_BOTH:
d85 2
a86 2
   rast->cullmode = svga_translate_cullmode( templ->cull_mode, 
                                             templ->front_winding );
d121 5
a125 2
      boolean offset_cw = templ->offset_cw;
      boolean offset_ccw = templ->offset_ccw;
a126 3
      int fill_cw = templ->fill_cw;
      int fill_ccw = templ->fill_ccw;
      int fill = PIPE_POLYGON_MODE_FILL;
d128 2
a129 2
      switch (templ->cull_mode) {
      case PIPE_WINDING_BOTH:
d134 3
a136 3
      case PIPE_WINDING_CW:
         offset = offset_ccw;
         fill = fill_ccw;
d139 3
a141 3
      case PIPE_WINDING_CCW:
         offset = offset_cw;
         fill = fill_cw;
d144 2
a145 2
      case PIPE_WINDING_NONE:
         if (fill_cw != fill_ccw || offset_cw != offset_ccw) 
d153 2
a154 2
            offset = offset_ccw;
            fill = fill_ccw;
d171 1
a171 1
           templ->cull_mode != PIPE_WINDING_NONE)) 
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d39 1
a39 1
                                           unsigned front_ccw )
a40 1
   const int hw_front_ccw = 0;  /* hardware is always CW */
d42 1
a42 1
   case PIPE_FACE_NONE:
d44 5
a48 5
   case PIPE_FACE_FRONT:
      return front_ccw == hw_front_ccw ? SVGA3D_FACE_FRONT : SVGA3D_FACE_BACK;
   case PIPE_FACE_BACK:
      return front_ccw == hw_front_ccw ? SVGA3D_FACE_BACK : SVGA3D_FACE_FRONT;
   case PIPE_FACE_FRONT_AND_BACK:
d84 2
a85 2
   rast->cullmode = svga_translate_cullmode( templ->cull_face, 
                                             templ->front_ccw );
d120 5
a124 2
      int fill_front = templ->fill_front;
      int fill_back = templ->fill_back;
a125 3
      boolean offset_front = util_get_offset(templ, fill_front);
      boolean offset_back = util_get_offset(templ, fill_back);
      boolean offset  = 0;
d127 2
a128 2
      switch (templ->cull_face) {
      case PIPE_FACE_FRONT_AND_BACK:
d133 3
a135 3
      case PIPE_FACE_FRONT:
         offset = offset_front;
         fill = fill_front;
d138 3
a140 3
      case PIPE_FACE_BACK:
         offset = offset_back;
         fill = fill_back;
d143 2
a144 2
      case PIPE_FACE_NONE:
         if (fill_front != fill_back || offset_front != offset_back) 
d152 2
a153 2
            offset = offset_front;
            fill = fill_front;
d170 1
a170 1
           templ->cull_face != PIPE_FACE_NONE)) 
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a66 1
   struct svga_context *svga = svga_context(pipe);
a67 1

d71 1
a71 1
   /* light_twoside          - XXX: need fragment shader variant */
d78 1
d80 1
a80 1
   /* half_pixel_center      - XXX - viewport code */
a90 1
   rast->pointsprite = templ->sprite_coord_enable != 0x0;
d96 1
a96 1
   if (templ->poly_stipple_enable) {
a97 2
      rast->need_pipeline_tris_str = "poly stipple";
   }
d99 2
a100 2
   if (templ->line_width >= 1.5f &&
       !svga->debug.no_line_width) {
a101 2
      rast->need_pipeline_lines_str = "line width";
   }
d104 1
a104 2
      /* XXX: LinePattern not implemented on all backends, and there is no
       * mechanism to query it.
d106 1
a106 1
      if (!svga->debug.force_hw_line_stipple) {
a113 1
         rast->need_pipeline_lines_str = "line stipple";
d117 1
a117 1
   if (templ->point_smooth) {
a118 7
      rast->need_pipeline_points_str = "smooth points";
   }

   if (templ->line_smooth) {
      rast->need_pipeline |= SVGA_PIPELINE_FLAG_LINES;
      rast->need_pipeline_lines_str = "smooth lines";
   }
a150 1
            rast->need_pipeline_tris_str = "different front/back fillmodes";
a174 1
         rast->need_pipeline_tris_str = "unfilled primitives with no index manipulation";
a184 1
         rast->need_pipeline_tris_str = "decomposing lines";
a193 1
         rast->need_pipeline_tris_str = "decomposing points";
d204 3
d224 1
d228 1
a228 2
   svga->curr.rast = raster;

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a32 1
#include "svga_screen.h"
a68 1
   struct svga_screen *screen = svga_screen(pipe->screen);
d103 2
a104 9
   if (screen->maxLineWidth > 1.0F) {
      /* pass line width to device */
      rast->linewidth = MAX2(1.0F, templ->line_width);
   }
   else if (svga->debug.no_line_width) {
      /* nothing */
   }
   else {
      /* use 'draw' pipeline for wide line */
d110 4
a113 1
      if (screen->haveLineStipple || svga->debug.force_hw_line_stipple) {
a119 1
         /* use 'draw' module to decompose into short line segments */
d130 1
a130 7
   if (templ->line_smooth && !screen->haveLineSmooth) {
      /*
       * XXX: Enabling the pipeline slows down performance immensely, so ignore
       * line smooth state, where there is very little visual improvement.
       * Smooth lines will still be drawn for wide lines.
       */
#if 0
a132 1
#endif
d141 1
a141 1
      boolean offset = FALSE;
d145 1
a145 1
         offset = FALSE;
a228 7
   }

   if (0 && rast->need_pipeline) {
      debug_printf("svga: rast need_pipeline = 0x%x\n", rast->need_pipeline);
      debug_printf(" pnts: %s \n", rast->need_pipeline_points_str);
      debug_printf(" lins: %s \n", rast->need_pipeline_lines_str);
      debug_printf(" tris: %s \n", rast->need_pipeline_tris_str);
@


