head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.08;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.57;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "svga_cmd.h"

#include "util/u_inlines.h"
#include "indices/u_indices.h"

#include "svga_hw_reg.h"
#include "svga_draw.h"
#include "svga_draw_private.h"
#include "svga_context.h"


#define DBG 0


static enum pipe_error
generate_indices(struct svga_hwtnl *hwtnl,
                 unsigned nr,
                 unsigned index_size,
                 u_generate_func generate, struct pipe_resource **out_buf)
{
   struct pipe_context *pipe = &hwtnl->svga->pipe;
   struct pipe_transfer *transfer;
   unsigned size = index_size * nr;
   struct pipe_resource *dst = NULL;
   void *dst_map = NULL;

   dst = pipe_buffer_create(pipe->screen,
                            PIPE_BIND_INDEX_BUFFER, PIPE_USAGE_DEFAULT, size);
   if (dst == NULL)
      goto fail;

   dst_map = pipe_buffer_map(pipe, dst, PIPE_TRANSFER_WRITE, &transfer);
   if (dst_map == NULL)
      goto fail;

   generate(0, nr, dst_map);

   pipe_buffer_unmap(pipe, transfer);

   *out_buf = dst;
   return PIPE_OK;

fail:
   if (dst_map)
      pipe_buffer_unmap(pipe, transfer);

   if (dst)
      pipe->screen->resource_destroy(pipe->screen, dst);

   return PIPE_ERROR_OUT_OF_MEMORY;
}


static boolean
compare(unsigned cached_nr, unsigned nr, unsigned type)
{
   if (type == U_GENERATE_REUSABLE)
      return cached_nr >= nr;
   else
      return cached_nr == nr;
}


static enum pipe_error
retrieve_or_generate_indices(struct svga_hwtnl *hwtnl,
                             unsigned prim,
                             unsigned gen_type,
                             unsigned gen_nr,
                             unsigned gen_size,
                             u_generate_func generate,
                             struct pipe_resource **out_buf)
{
   enum pipe_error ret = PIPE_OK;
   int i;

   for (i = 0; i < IDX_CACHE_MAX; i++) {
      if (hwtnl->index_cache[prim][i].buffer != NULL &&
          hwtnl->index_cache[prim][i].generate == generate) {
         if (compare(hwtnl->index_cache[prim][i].gen_nr, gen_nr, gen_type)) {
            pipe_resource_reference(out_buf,
                                    hwtnl->index_cache[prim][i].buffer);

            if (DBG)
               debug_printf("%s retrieve %d/%d\n", __FUNCTION__, i, gen_nr);

            return PIPE_OK;
         }
         else if (gen_type == U_GENERATE_REUSABLE) {
            pipe_resource_reference(&hwtnl->index_cache[prim][i].buffer,
                                    NULL);

            if (DBG)
               debug_printf("%s discard %d/%d\n", __FUNCTION__,
                            i, hwtnl->index_cache[prim][i].gen_nr);

            break;
         }
      }
   }

   if (i == IDX_CACHE_MAX) {
      unsigned smallest = 0;
      unsigned smallest_size = ~0;

      for (i = 0; i < IDX_CACHE_MAX && smallest_size; i++) {
         if (hwtnl->index_cache[prim][i].buffer == NULL) {
            smallest = i;
            smallest_size = 0;
         }
         else if (hwtnl->index_cache[prim][i].gen_nr < smallest) {
            smallest = i;
            smallest_size = hwtnl->index_cache[prim][i].gen_nr;
         }
      }

      assert(smallest != IDX_CACHE_MAX);

      pipe_resource_reference(&hwtnl->index_cache[prim][smallest].buffer,
                              NULL);

      if (DBG)
         debug_printf("%s discard smallest %d/%d\n", __FUNCTION__,
                      smallest, smallest_size);

      i = smallest;
   }

   ret = generate_indices(hwtnl, gen_nr, gen_size, generate, out_buf);
   if (ret != PIPE_OK)
      return ret;

   hwtnl->index_cache[prim][i].generate = generate;
   hwtnl->index_cache[prim][i].gen_nr = gen_nr;
   pipe_resource_reference(&hwtnl->index_cache[prim][i].buffer, *out_buf);

   if (DBG)
      debug_printf("%s cache %d/%d\n", __FUNCTION__,
                   i, hwtnl->index_cache[prim][i].gen_nr);

   return PIPE_OK;
}


static enum pipe_error
simple_draw_arrays(struct svga_hwtnl *hwtnl,
                   unsigned prim, unsigned start, unsigned count)
{
   SVGA3dPrimitiveRange range;
   unsigned hw_prim;
   unsigned hw_count;

   hw_prim = svga_translate_prim(prim, count, &hw_count);
   if (hw_count == 0)
      return PIPE_ERROR_BAD_INPUT;

   range.primType = hw_prim;
   range.primitiveCount = hw_count;
   range.indexArray.surfaceId = SVGA3D_INVALID_ID;
   range.indexArray.offset = 0;
   range.indexArray.stride = 0;
   range.indexWidth = 0;
   range.indexBias = start;

   /* Min/max index should be calculated prior to applying bias, so we
    * end up with min_index = 0, max_index = count - 1 and everybody
    * looking at those numbers knows to adjust them by
    * range.indexBias.
    */
   return svga_hwtnl_prim(hwtnl, &range, 0, count - 1, NULL);
}


enum pipe_error
svga_hwtnl_draw_arrays(struct svga_hwtnl *hwtnl,
                       unsigned prim, unsigned start, unsigned count)
{
   unsigned gen_prim, gen_size, gen_nr, gen_type;
   u_generate_func gen_func;
   enum pipe_error ret = PIPE_OK;

   if (hwtnl->api_fillmode != PIPE_POLYGON_MODE_FILL &&
       prim >= PIPE_PRIM_TRIANGLES) {
      /* Convert unfilled polygons into points, lines, triangles */
      gen_type = u_unfilled_generator(prim,
                                      start,
                                      count,
                                      hwtnl->api_fillmode,
                                      &gen_prim,
                                      &gen_size, &gen_nr, &gen_func);
   }
   else {
      /* Convert PIPE_PRIM_LINE_LOOP to PIPE_PRIM_LINESTRIP,
       * convert PIPE_PRIM_POLYGON to PIPE_PRIM_TRIANGLE_FAN,
       * etc, if needed (as determined by svga_hw_prims mask).
       */
      gen_type = u_index_generator(svga_hw_prims,
                                   prim,
                                   start,
                                   count,
                                   hwtnl->api_pv,
                                   hwtnl->hw_pv,
                                   &gen_prim, &gen_size, &gen_nr, &gen_func);
   }

   if (gen_type == U_GENERATE_LINEAR) {
      return simple_draw_arrays(hwtnl, gen_prim, start, count);
   }
   else {
      struct pipe_resource *gen_buf = NULL;

      /* Need to draw as indexed primitive.
       * Potentially need to run the gen func to build an index buffer.
       */
      ret = retrieve_or_generate_indices(hwtnl,
                                         prim,
                                         gen_type,
                                         gen_nr,
                                         gen_size, gen_func, &gen_buf);
      if (ret != PIPE_OK)
         goto done;

      ret = svga_hwtnl_simple_draw_range_elements(hwtnl,
                                                  gen_buf,
                                                  gen_size,
                                                  start,
                                                  0,
                                                  count - 1,
                                                  gen_prim, 0, gen_nr);

      if (ret != PIPE_OK)
         goto done;

done:
      if (gen_buf)
         pipe_resource_reference(&gen_buf, NULL);

      return ret;
   }
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d40 5
a44 5
static enum pipe_error generate_indices( struct svga_hwtnl *hwtnl,
                                         unsigned nr,
                                         unsigned index_size,
                                         u_generate_func generate,
                                         struct pipe_resource **out_buf )
d52 2
a53 4
   dst = pipe_buffer_create( pipe->screen,
			     PIPE_BIND_INDEX_BUFFER,
			     PIPE_USAGE_STATIC,
			     size );
d57 1
a57 2
   dst_map = pipe_buffer_map( pipe, dst, PIPE_TRANSFER_WRITE,
			      &transfer);
d61 1
a61 2
   generate( nr,
             dst_map );
d63 1
a63 1
   pipe_buffer_unmap( pipe, transfer );
d70 1
a70 1
      pipe_buffer_unmap( pipe, transfer );
d73 1
a73 1
      pipe->screen->resource_destroy( pipe->screen, dst );
d79 2
a80 3
static boolean compare( unsigned cached_nr,
                        unsigned nr,
                        unsigned type )
d89 8
a96 7
static enum pipe_error retrieve_or_generate_indices( struct svga_hwtnl *hwtnl,
                                                     unsigned prim,
                                                     unsigned gen_type,
                                                     unsigned gen_nr,
                                                     unsigned gen_size,
                                                     u_generate_func generate,
                                                     struct pipe_resource **out_buf )
d103 4
a106 6
          hwtnl->index_cache[prim][i].generate == generate)
      {
         if (compare(hwtnl->index_cache[prim][i].gen_nr, gen_nr, gen_type))
         {
            pipe_resource_reference( out_buf,
                                   hwtnl->index_cache[prim][i].buffer );
d113 3
a115 4
         else if (gen_type == U_GENERATE_REUSABLE)
         {
            pipe_resource_reference( &hwtnl->index_cache[prim][i].buffer,
                                   NULL );
d126 1
a126 2
   if (i == IDX_CACHE_MAX)
   {
d131 1
a131 2
         if (hwtnl->index_cache[prim][i].buffer == NULL)
         {
d135 1
a135 2
         else if (hwtnl->index_cache[prim][i].gen_nr < smallest)
         {
d141 1
a141 1
      assert (smallest != IDX_CACHE_MAX);
d143 2
a144 2
      pipe_resource_reference( &hwtnl->index_cache[prim][smallest].buffer,
                             NULL );
d153 1
a153 5
   ret = generate_indices( hwtnl,
                           gen_nr,
                           gen_size,
                           generate,
                           out_buf );
a156 1

d159 1
a159 2
   pipe_resource_reference( &hwtnl->index_cache[prim][i].buffer,
                          *out_buf );
a168 1

d170 2
a171 2
simple_draw_arrays( struct svga_hwtnl *hwtnl,
                    unsigned prim, unsigned start, unsigned count )
d194 1
a194 1
   return svga_hwtnl_prim( hwtnl, &range, 0, count - 1, NULL );
d199 2
a200 4
svga_hwtnl_draw_arrays( struct svga_hwtnl *hwtnl,
                        unsigned prim,
                        unsigned start,
                        unsigned count)
d207 1
a207 2
       prim >= PIPE_PRIM_TRIANGLES)
   {
d209 6
a214 8
      gen_type = u_unfilled_generator( prim,
                                       start,
                                       count,
                                       hwtnl->api_fillmode,
                                       &gen_prim,
                                       &gen_size,
                                       &gen_nr,
                                       &gen_func );
d221 7
a227 10
      gen_type = u_index_generator( svga_hw_prims,
                                    prim,
                                    start,
                                    count,
                                    hwtnl->api_pv,
                                    hwtnl->hw_pv,
                                    &gen_prim,
                                    &gen_size,
                                    &gen_nr,
                                    &gen_func );
d231 1
a231 1
      return simple_draw_arrays( hwtnl, gen_prim, start, count );
d239 5
a243 7
      ret = retrieve_or_generate_indices( hwtnl,
                                          prim,
                                          gen_type,
                                          gen_nr,
                                          gen_size,
                                          gen_func,
                                          &gen_buf );
d247 7
a253 9
      ret = svga_hwtnl_simple_draw_range_elements( hwtnl,
                                                   gen_buf,
                                                   gen_size,
                                                   start,
                                                   0,
                                                   count - 1,
                                                   gen_prim,
                                                   0,
                                                   gen_nr );
d258 1
a258 1
   done:
d260 1
a260 1
         pipe_resource_reference( &gen_buf, NULL );
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a39 2


d52 2
a53 2
   dst = pipe_buffer_create( pipe->screen, 
			     PIPE_BIND_INDEX_BUFFER, 
d78 1
a78 1
   
d82 1
d93 1
d114 1
a114 1
            if (DBG) 
d119 1
a119 1
         else if (gen_type == U_GENERATE_REUSABLE) 
d124 2
a125 2
            if (DBG) 
               debug_printf("%s discard %d/%d\n", __FUNCTION__, 
d137 1
a137 1
      
d157 1
a157 1
         debug_printf("%s discard smallest %d/%d\n", __FUNCTION__, 
d159 1
a159 1
      
d162 2
a163 3
      
      
   ret = generate_indices( hwtnl, 
d178 1
a178 1
      debug_printf("%s cache %d/%d\n", __FUNCTION__, 
d197 1
a197 1
      
d215 1
a215 9








enum pipe_error 
d217 2
a218 2
                        unsigned prim, 
                        unsigned start, 
d225 2
a226 2
   if (hwtnl->api_fillmode != PIPE_POLYGON_MODE_FILL && 
       prim >= PIPE_PRIM_TRIANGLES) 
d228 1
d239 4
d261 1
a261 1
      /* Need to draw as indexed primitive. 
d271 1
a271 1
      if (ret)
d284 1
a284 1
      if (ret)
a293 1

@


1.2
log
@Merge Mesa 7.10.3
@
text
@d56 1
d69 1
a69 1
   pipe_buffer_unmap( pipe, dst, transfer );
d76 1
a76 1
      pipe_buffer_unmap( pipe, dst, transfer );
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d46 1
a46 1
                                         struct pipe_buffer **out_buf )
d48 2
a49 1
   struct pipe_screen *screen = hwtnl->svga->pipe.screen;
d51 1
a51 1
   struct pipe_buffer *dst = NULL;
d54 3
a56 5
   dst = screen->buffer_create( screen, 32, 
                                PIPE_BUFFER_USAGE_INDEX |
                                PIPE_BUFFER_USAGE_CPU_WRITE |
                                PIPE_BUFFER_USAGE_GPU_READ, 
                                size );
d60 2
a61 1
   dst_map = pipe_buffer_map( screen, dst, PIPE_BUFFER_USAGE_CPU_WRITE );
d68 1
a68 1
   pipe_buffer_unmap( screen, dst );
d75 1
a75 1
      screen->buffer_unmap( screen, dst );
d78 2
a79 2
      screen->buffer_destroy( dst );

d99 1
a99 1
                                                     struct pipe_buffer **out_buf )
d110 1
a110 1
            pipe_buffer_reference( out_buf,
d120 1
a120 1
            pipe_buffer_reference( &hwtnl->index_cache[prim][i].buffer,
d152 1
a152 1
      pipe_buffer_reference( &hwtnl->index_cache[prim][smallest].buffer,
d174 1
a174 1
   pipe_buffer_reference( &hwtnl->index_cache[prim][i].buffer,
d262 1
a262 1
      struct pipe_buffer *gen_buf = NULL;
d280 1
d285 2
a286 2
                                                   gen_nr,
                                                   start );
d292 1
a292 1
         pipe_buffer_reference( &gen_buf, NULL );
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d46 1
a46 1
                                         struct pipe_resource **out_buf )
d48 1
a48 2
   struct pipe_context *pipe = &hwtnl->svga->pipe;
   struct pipe_transfer *transfer;
d50 1
a50 1
   struct pipe_resource *dst = NULL;
d53 5
a57 3
   dst = pipe_buffer_create( pipe->screen, 
			     PIPE_BIND_INDEX_BUFFER, 
			     size );
d61 1
a61 2
   dst_map = pipe_buffer_map( pipe, dst, PIPE_TRANSFER_WRITE,
			      &transfer);
d68 1
a68 1
   pipe_buffer_unmap( pipe, dst, transfer );
d75 1
a75 1
      pipe_buffer_unmap( pipe, dst, transfer );
d78 2
a79 2
      pipe->screen->resource_destroy( pipe->screen, dst );
   
d99 1
a99 1
                                                     struct pipe_resource **out_buf )
d110 1
a110 1
            pipe_resource_reference( out_buf,
d120 1
a120 1
            pipe_resource_reference( &hwtnl->index_cache[prim][i].buffer,
d152 1
a152 1
      pipe_resource_reference( &hwtnl->index_cache[prim][smallest].buffer,
d174 1
a174 1
   pipe_resource_reference( &hwtnl->index_cache[prim][i].buffer,
d262 1
a262 1
      struct pipe_resource *gen_buf = NULL;
a279 1
                                                   start,
d284 2
a285 2
                                                   gen_nr );

d291 1
a291 1
         pipe_resource_reference( &gen_buf, NULL );
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d40 2
d54 2
a55 3
   dst = pipe_buffer_create( pipe->screen,
			     PIPE_BIND_INDEX_BUFFER,
			     PIPE_USAGE_STATIC,
d68 1
a68 1
   pipe_buffer_unmap( pipe, transfer );
d75 1
a75 1
      pipe_buffer_unmap( pipe, transfer );
d79 1
a79 1

a82 1

a92 1

d113 1
a113 1
            if (DBG)
d118 1
a118 1
         else if (gen_type == U_GENERATE_REUSABLE)
d123 2
a124 2
            if (DBG)
               debug_printf("%s discard %d/%d\n", __FUNCTION__,
d136 1
a136 1

d156 1
a156 1
         debug_printf("%s discard smallest %d/%d\n", __FUNCTION__,
d158 1
a158 1

d161 3
a163 2

   ret = generate_indices( hwtnl,
d178 1
a178 1
      debug_printf("%s cache %d/%d\n", __FUNCTION__,
d197 1
a197 1

d215 9
a223 1
enum pipe_error
d225 2
a226 2
                        unsigned prim,
                        unsigned start,
d233 2
a234 2
   if (hwtnl->api_fillmode != PIPE_POLYGON_MODE_FILL &&
       prim >= PIPE_PRIM_TRIANGLES)
a235 1
      /* Convert unfilled polygons into points, lines, triangles */
a245 4
      /* Convert PIPE_PRIM_LINE_LOOP to PIPE_PRIM_LINESTRIP,
       * convert PIPE_PRIM_POLYGON to PIPE_PRIM_TRIANGLE_FAN,
       * etc, if needed (as determined by svga_hw_prims mask).
       */
d264 1
a264 1
      /* Need to draw as indexed primitive.
d274 1
a274 1
      if (ret != PIPE_OK)
d287 1
a287 1
      if (ret != PIPE_OK)
d297 1
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d40 5
a44 5
static enum pipe_error
generate_indices(struct svga_hwtnl *hwtnl,
                 unsigned nr,
                 unsigned index_size,
                 u_generate_func generate, struct pipe_resource **out_buf)
d52 4
a55 2
   dst = pipe_buffer_create(pipe->screen,
                            PIPE_BIND_INDEX_BUFFER, PIPE_USAGE_DEFAULT, size);
d59 2
a60 1
   dst_map = pipe_buffer_map(pipe, dst, PIPE_TRANSFER_WRITE, &transfer);
d64 2
a65 1
   generate(0, nr, dst_map);
d67 1
a67 1
   pipe_buffer_unmap(pipe, transfer);
d74 1
a74 1
      pipe_buffer_unmap(pipe, transfer);
d77 1
a77 1
      pipe->screen->resource_destroy(pipe->screen, dst);
d83 3
a85 2
static boolean
compare(unsigned cached_nr, unsigned nr, unsigned type)
d94 7
a100 8
static enum pipe_error
retrieve_or_generate_indices(struct svga_hwtnl *hwtnl,
                             unsigned prim,
                             unsigned gen_type,
                             unsigned gen_nr,
                             unsigned gen_size,
                             u_generate_func generate,
                             struct pipe_resource **out_buf)
d107 6
a112 4
          hwtnl->index_cache[prim][i].generate == generate) {
         if (compare(hwtnl->index_cache[prim][i].gen_nr, gen_nr, gen_type)) {
            pipe_resource_reference(out_buf,
                                    hwtnl->index_cache[prim][i].buffer);
d119 4
a122 3
         else if (gen_type == U_GENERATE_REUSABLE) {
            pipe_resource_reference(&hwtnl->index_cache[prim][i].buffer,
                                    NULL);
d133 2
a134 1
   if (i == IDX_CACHE_MAX) {
d139 2
a140 1
         if (hwtnl->index_cache[prim][i].buffer == NULL) {
d144 2
a145 1
         else if (hwtnl->index_cache[prim][i].gen_nr < smallest) {
d151 1
a151 1
      assert(smallest != IDX_CACHE_MAX);
d153 2
a154 2
      pipe_resource_reference(&hwtnl->index_cache[prim][smallest].buffer,
                              NULL);
d163 5
a167 1
   ret = generate_indices(hwtnl, gen_nr, gen_size, generate, out_buf);
d171 1
d174 2
a175 1
   pipe_resource_reference(&hwtnl->index_cache[prim][i].buffer, *out_buf);
d185 1
d187 2
a188 2
simple_draw_arrays(struct svga_hwtnl *hwtnl,
                   unsigned prim, unsigned start, unsigned count)
d211 1
a211 1
   return svga_hwtnl_prim(hwtnl, &range, 0, count - 1, NULL);
d216 4
a219 2
svga_hwtnl_draw_arrays(struct svga_hwtnl *hwtnl,
                       unsigned prim, unsigned start, unsigned count)
d226 2
a227 1
       prim >= PIPE_PRIM_TRIANGLES) {
d229 8
a236 6
      gen_type = u_unfilled_generator(prim,
                                      start,
                                      count,
                                      hwtnl->api_fillmode,
                                      &gen_prim,
                                      &gen_size, &gen_nr, &gen_func);
d243 10
a252 7
      gen_type = u_index_generator(svga_hw_prims,
                                   prim,
                                   start,
                                   count,
                                   hwtnl->api_pv,
                                   hwtnl->hw_pv,
                                   &gen_prim, &gen_size, &gen_nr, &gen_func);
d256 1
a256 1
      return simple_draw_arrays(hwtnl, gen_prim, start, count);
d264 7
a270 5
      ret = retrieve_or_generate_indices(hwtnl,
                                         prim,
                                         gen_type,
                                         gen_nr,
                                         gen_size, gen_func, &gen_buf);
d274 9
a282 7
      ret = svga_hwtnl_simple_draw_range_elements(hwtnl,
                                                  gen_buf,
                                                  gen_size,
                                                  start,
                                                  0,
                                                  count - 1,
                                                  gen_prim, 0, gen_nr);
d287 1
a287 1
done:
d289 1
a289 1
         pipe_resource_reference(&gen_buf, NULL);
@


