head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.11;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.01;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "util/u_inlines.h"
#include "util/u_memory.h"
#include "pipe/p_defines.h"
#include "util/u_math.h"

#include "svga_sampler_view.h"
#include "svga_winsys.h"
#include "svga_context.h"
#include "svga_state.h"
#include "svga_cmd.h"


void svga_cleanup_tss_binding(struct svga_context *svga)
{
   unsigned i;
   unsigned count = MAX2( svga->curr.num_sampler_views,
                          svga->state.hw_draw.num_views );

   for (i = 0; i < count; i++) {
      struct svga_hw_view_state *view = &svga->state.hw_draw.views[i];

      svga_sampler_view_reference(&view->v, NULL);
      pipe_sampler_view_release(&svga->pipe, &svga->curr.sampler_views[i]);
      pipe_resource_reference( &view->texture, NULL );

      view->dirty = 1;
   }
}


struct bind_queue {
   struct {
      unsigned unit;
      struct svga_hw_view_state *view;
   } bind[PIPE_MAX_SAMPLERS];

   unsigned bind_count;
};


static enum pipe_error
update_tss_binding(struct svga_context *svga, 
                   unsigned dirty )
{
   boolean reemit = svga->rebind.texture_samplers;
   unsigned i;
   unsigned count = MAX2( svga->curr.num_sampler_views,
                          svga->state.hw_draw.num_views );
   unsigned min_lod;
   unsigned max_lod;

   struct bind_queue queue;

   queue.bind_count = 0;
   
   for (i = 0; i < count; i++) {
      const struct svga_sampler_state *s = svga->curr.sampler[i];
      struct svga_hw_view_state *view = &svga->state.hw_draw.views[i];
      struct pipe_resource *texture = NULL;
      struct pipe_sampler_view *sv = svga->curr.sampler_views[i];

      /* get min max lod */
      if (sv && s) {
         min_lod = MAX2(0, (s->view_min_lod + sv->u.tex.first_level));
         max_lod = MIN2(s->view_max_lod + sv->u.tex.first_level,
                        sv->texture->last_level);
         texture = sv->texture;
      } else {
         min_lod = 0;
         max_lod = 0;
      }

      if (view->texture != texture ||
          view->min_lod != min_lod ||
          view->max_lod != max_lod) {

         svga_sampler_view_reference(&view->v, NULL);
         pipe_resource_reference( &view->texture, texture );

         view->dirty = TRUE;
         view->min_lod = min_lod;
         view->max_lod = max_lod;

         if (texture)
            view->v = svga_get_tex_sampler_view(&svga->pipe, 
                                                texture, 
                                                min_lod,
                                                max_lod);
      }

      /*
       * We need to reemit non-null texture bindings, even when they are not
       * dirty, to ensure that the resources are paged in.
       */

      if (view->dirty ||
          (reemit && view->v)) {
         queue.bind[queue.bind_count].unit = i;
         queue.bind[queue.bind_count].view = view;
         queue.bind_count++;
      } 
      if (!view->dirty && view->v) {
         svga_validate_sampler_view(svga, view->v);
      }
   }

   svga->state.hw_draw.num_views = svga->curr.num_sampler_views;

   if (queue.bind_count) {
      SVGA3dTextureState *ts;

      if (SVGA3D_BeginSetTextureState( svga->swc,
                                       &ts,
                                       queue.bind_count ) != PIPE_OK)
         goto fail;

      for (i = 0; i < queue.bind_count; i++) {
         struct svga_winsys_surface *handle;

         ts[i].stage = queue.bind[i].unit;
         ts[i].name = SVGA3D_TS_BIND_TEXTURE;

         if (queue.bind[i].view->v) {
            handle = queue.bind[i].view->v->handle;
         }
         else {
            handle = NULL;
         }
         svga->swc->surface_relocation(svga->swc,
                                       &ts[i].value,
                                       NULL,
                                       handle,
                                       SVGA_RELOC_READ);
         
         queue.bind[i].view->dirty = FALSE;
      }

      SVGA_FIFOCommitAll( svga->swc );
   }

   svga->rebind.texture_samplers = FALSE;

   return PIPE_OK;

fail:
   return PIPE_ERROR_OUT_OF_MEMORY;
}


/*
 * Rebind textures.
 *
 * Similar to update_tss_binding, but without any state checking/update.
 *
 * Called at the beginning of every new command buffer to ensure that
 * non-dirty textures are properly paged-in.
 */
enum pipe_error
svga_reemit_tss_bindings(struct svga_context *svga)
{
   unsigned i;
   enum pipe_error ret;
   struct bind_queue queue;

   assert(svga->rebind.texture_samplers);

   queue.bind_count = 0;

   for (i = 0; i < svga->state.hw_draw.num_views; i++) {
      struct svga_hw_view_state *view = &svga->state.hw_draw.views[i];

      if (view->v) {
         queue.bind[queue.bind_count].unit = i;
         queue.bind[queue.bind_count].view = view;
         queue.bind_count++;
      }
   }

   if (queue.bind_count) {
      SVGA3dTextureState *ts;

      ret = SVGA3D_BeginSetTextureState(svga->swc,
                                        &ts,
                                        queue.bind_count);
      if (ret != PIPE_OK) {
         return ret;
      }

      for (i = 0; i < queue.bind_count; i++) {
         struct svga_winsys_surface *handle;

         ts[i].stage = queue.bind[i].unit;
         ts[i].name = SVGA3D_TS_BIND_TEXTURE;

         assert(queue.bind[i].view->v);
         handle = queue.bind[i].view->v->handle;
         svga->swc->surface_relocation(svga->swc,
                                       &ts[i].value,
                                       NULL,
                                       handle,
                                       SVGA_RELOC_READ);
      }

      SVGA_FIFOCommitAll(svga->swc);
   }

   svga->rebind.texture_samplers = FALSE;

   return PIPE_OK;
}


struct svga_tracked_state svga_hw_tss_binding = {
   "texture binding emit",
   SVGA_NEW_TEXTURE_BINDING |
   SVGA_NEW_SAMPLER,
   update_tss_binding
};


/***********************************************************************
 */

struct ts_queue {
   unsigned ts_count;
   SVGA3dTextureState ts[PIPE_MAX_SAMPLERS*SVGA3D_TS_MAX];
};


#define EMIT_TS(svga, unit, val, token, fail)                           \
do {                                                                    \
   assert(unit < Elements(svga->state.hw_draw.ts));                     \
   assert(SVGA3D_TS_##token < Elements(svga->state.hw_draw.ts[unit]));  \
   if (svga->state.hw_draw.ts[unit][SVGA3D_TS_##token] != val) {        \
      svga_queue_tss( &queue, unit, SVGA3D_TS_##token, val );           \
      svga->state.hw_draw.ts[unit][SVGA3D_TS_##token] = val;            \
   }                                                                    \
} while (0)

#define EMIT_TS_FLOAT(svga, unit, fvalue, token, fail)                  \
do {                                                                    \
   unsigned val = fui(fvalue);                                          \
   assert(unit < Elements(svga->state.hw_draw.ts));                     \
   assert(SVGA3D_TS_##token < Elements(svga->state.hw_draw.ts[unit]));  \
   if (svga->state.hw_draw.ts[unit][SVGA3D_TS_##token] != val) {        \
      svga_queue_tss( &queue, unit, SVGA3D_TS_##token, val );           \
      svga->state.hw_draw.ts[unit][SVGA3D_TS_##token] = val;            \
   }                                                                    \
} while (0)


static INLINE void 
svga_queue_tss( struct ts_queue *q,
                unsigned unit,
                unsigned tss,
                unsigned value )
{
   assert(q->ts_count < sizeof(q->ts)/sizeof(q->ts[0]));
   q->ts[q->ts_count].stage = unit;
   q->ts[q->ts_count].name = tss;
   q->ts[q->ts_count].value = value;
   q->ts_count++;
}


static enum pipe_error
update_tss(struct svga_context *svga, 
           unsigned dirty )
{
   unsigned i;
   struct ts_queue queue;

   queue.ts_count = 0;
   for (i = 0; i < svga->curr.num_samplers; i++) {
      if (svga->curr.sampler[i]) {
         const struct svga_sampler_state *curr = svga->curr.sampler[i];

         EMIT_TS(svga, i, curr->mipfilter, MIPFILTER, fail);
         EMIT_TS(svga, i, curr->min_lod, TEXTURE_MIPMAP_LEVEL, fail);
         EMIT_TS(svga, i, curr->magfilter, MAGFILTER, fail);
         EMIT_TS(svga, i, curr->minfilter, MINFILTER, fail);
         EMIT_TS(svga, i, curr->aniso_level, TEXTURE_ANISOTROPIC_LEVEL, fail);
         EMIT_TS_FLOAT(svga, i, curr->lod_bias, TEXTURE_LOD_BIAS, fail);
         EMIT_TS(svga, i, curr->addressu, ADDRESSU, fail);
         EMIT_TS(svga, i, curr->addressw, ADDRESSW, fail);
         EMIT_TS(svga, i, curr->bordercolor, BORDERCOLOR, fail);
         // TEXCOORDINDEX -- hopefully not needed

         if (svga->curr.tex_flags.flag_1d & (1 << i)) {
            EMIT_TS(svga, i, SVGA3D_TEX_ADDRESS_WRAP, ADDRESSV, fail);
         }
         else
            EMIT_TS(svga, i, curr->addressv, ADDRESSV, fail);

         if (svga->curr.tex_flags.flag_srgb & (1 << i))
            EMIT_TS_FLOAT(svga, i, 2.2f, GAMMA, fail);
         else
            EMIT_TS_FLOAT(svga, i, 1.0f, GAMMA, fail);

      }
   }
 
   if (queue.ts_count) {
      SVGA3dTextureState *ts;

      if (SVGA3D_BeginSetTextureState( svga->swc,
                                       &ts,
                                       queue.ts_count ) != PIPE_OK)
         goto fail;

      memcpy( ts,
              queue.ts,
              queue.ts_count * sizeof queue.ts[0]);
      
      SVGA_FIFOCommitAll( svga->swc );
   }

   return PIPE_OK;

fail:
   /* XXX: need to poison cached hardware state on failure to ensure
    * dirty state gets re-emitted.  Fix this by re-instating partial
    * FIFOCommit command and only updating cached hw state once the
    * initial allocation has succeeded.
    */
   memset(svga->state.hw_draw.ts, 0xcd, sizeof(svga->state.hw_draw.ts));

   return PIPE_ERROR_OUT_OF_MEMORY;
}


struct svga_tracked_state svga_hw_tss = {
   "texture state emit",
   (SVGA_NEW_SAMPLER |
    SVGA_NEW_TEXTURE_FLAGS),
   update_tss
};

@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d88 1
a88 1
      if (sv) {
d156 1
d168 1
a168 1
   return 0;
d224 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d27 1
d40 1
a40 1
   int i;
d48 1
a48 1
      pipe_sampler_view_reference( &svga->curr.sampler_views[i], NULL );
d66 1
a66 1
static int
d85 1
d88 5
a92 4
      if (svga->curr.sampler_views[i]) {
         min_lod = MAX2(s->view_min_lod, 0);
         max_lod = MIN2(s->view_max_lod, svga->curr.sampler_views[i]->texture->last_level);
         texture = svga->curr.sampler_views[i]->texture;
d255 2
d266 2
d289 1
a289 1
static int
d341 1
a341 1
   return 0;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d55 10
d69 1
a69 1
   boolean reemit = !!(dirty & SVGA_NEW_COMMAND_BUFFER);
d76 1
a76 9

   struct {
      struct {
         unsigned unit;
         struct svga_hw_view_state *view;
      } bind[PIPE_MAX_SAMPLERS];

      unsigned bind_count;
   } queue;
d162 2
d171 62
d236 1
a236 2
   SVGA_NEW_SAMPLER |
   SVGA_NEW_COMMAND_BUFFER,
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d30 1
a30 1
#include "svga_screen_texture.h"
d40 1
a40 1
   unsigned count = MAX2( svga->curr.num_textures,
d47 2
a48 2
      pipe_texture_reference( &svga->curr.texture[i], NULL );
      pipe_texture_reference( &view->texture, NULL );
d59 1
d61 1
a61 1
   unsigned count = MAX2( svga->curr.num_textures,
d81 1
d84 1
a84 1
      if (svga->curr.texture[i]) {
d86 2
a87 1
         max_lod = MIN2(s->view_max_lod, svga->curr.texture[i]->last_level);
d93 1
a93 1
      if (view->texture != svga->curr.texture[i] ||
d98 1
a98 1
         pipe_texture_reference( &view->texture, svga->curr.texture[i] );
d104 1
a104 1
         if (svga->curr.texture[i])
d106 1
a106 1
                                                svga->curr.texture[i], 
d111 7
a117 1
      if (view->dirty) {
d122 1
a122 1
      else if (view->v) {
d127 1
a127 1
   svga->state.hw_draw.num_views = svga->curr.num_textures;
d138 2
d144 1
a144 4
            svga->swc->surface_relocation(svga->swc,
                                          &ts[i].value,
                                          queue.bind[i].view->v->handle,
                                          PIPE_BUFFER_USAGE_GPU_READ);
d147 1
a147 1
            ts[i].value = SVGA3D_INVALID_ID;
d149 4
d170 2
a171 1
   SVGA_NEW_SAMPLER,
a240 1
            debug_printf("wrap 1d tex %d\n", i);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d30 1
a30 1
#include "svga_sampler_view.h"
d40 1
a40 1
   unsigned count = MAX2( svga->curr.num_sampler_views,
d47 2
a48 2
      pipe_sampler_view_reference( &svga->curr.sampler_views[i], NULL );
      pipe_resource_reference( &view->texture, NULL );
a58 1
   boolean reemit = !!(dirty & SVGA_NEW_COMMAND_BUFFER);
d60 1
a60 1
   unsigned count = MAX2( svga->curr.num_sampler_views,
a79 1
      struct pipe_resource *texture = NULL;
d82 1
a82 1
      if (svga->curr.sampler_views[i]) {
d84 1
a84 2
         max_lod = MIN2(s->view_max_lod, svga->curr.sampler_views[i]->texture->last_level);
         texture = svga->curr.sampler_views[i]->texture;
d90 1
a90 1
      if (view->texture != texture ||
d95 1
a95 1
         pipe_resource_reference( &view->texture, texture );
d101 1
a101 1
         if (texture)
d103 1
a103 1
                                                texture, 
d108 1
a108 7
      /*
       * We need to reemit non-null texture bindings, even when they are not
       * dirty, to ensure that the resources are paged in.
       */

      if (view->dirty ||
          (reemit && view->v)) {
d113 1
a113 1
      if (!view->dirty && view->v) {
d118 1
a118 1
   svga->state.hw_draw.num_views = svga->curr.num_sampler_views;
a128 2
         struct svga_winsys_surface *handle;

d133 4
a136 1
            handle = queue.bind[i].view->v->handle;
d139 1
a139 1
            handle = NULL;
a140 4
         svga->swc->surface_relocation(svga->swc,
                                       &ts[i].value,
                                       handle,
                                       SVGA_RELOC_READ);
d158 1
a158 2
   SVGA_NEW_SAMPLER |
   SVGA_NEW_COMMAND_BUFFER,
d228 1
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a26 1
#include "util/u_memory.h"
d39 1
a39 1
   unsigned i;
d47 1
a47 1
      pipe_sampler_view_release(&svga->pipe, &svga->curr.sampler_views[i]);
d55 1
a55 11
struct bind_queue {
   struct {
      unsigned unit;
      struct svga_hw_view_state *view;
   } bind[PIPE_MAX_SAMPLERS];

   unsigned bind_count;
};


static enum pipe_error
d59 1
a59 1
   boolean reemit = svga->rebind.texture_samplers;
d66 9
a74 1
   struct bind_queue queue;
a81 1
      struct pipe_sampler_view *sv = svga->curr.sampler_views[i];
d84 4
a87 5
      if (sv) {
         min_lod = MAX2(0, (s->view_min_lod + sv->u.tex.first_level));
         max_lod = MIN2(s->view_max_lod + sv->u.tex.first_level,
                        sv->texture->last_level);
         texture = sv->texture;
a159 2
   svga->rebind.texture_samplers = FALSE;

a166 62
/*
 * Rebind textures.
 *
 * Similar to update_tss_binding, but without any state checking/update.
 *
 * Called at the beginning of every new command buffer to ensure that
 * non-dirty textures are properly paged-in.
 */
enum pipe_error
svga_reemit_tss_bindings(struct svga_context *svga)
{
   unsigned i;
   enum pipe_error ret;
   struct bind_queue queue;

   assert(svga->rebind.texture_samplers);

   queue.bind_count = 0;

   for (i = 0; i < svga->state.hw_draw.num_views; i++) {
      struct svga_hw_view_state *view = &svga->state.hw_draw.views[i];

      if (view->v) {
         queue.bind[queue.bind_count].unit = i;
         queue.bind[queue.bind_count].view = view;
         queue.bind_count++;
      }
   }

   if (queue.bind_count) {
      SVGA3dTextureState *ts;

      ret = SVGA3D_BeginSetTextureState(svga->swc,
                                        &ts,
                                        queue.bind_count);
      if (ret != PIPE_OK) {
         return ret;
      }

      for (i = 0; i < queue.bind_count; i++) {
         struct svga_winsys_surface *handle;

         ts[i].stage = queue.bind[i].unit;
         ts[i].name = SVGA3D_TS_BIND_TEXTURE;

         assert(queue.bind[i].view->v);
         handle = queue.bind[i].view->v->handle;
         svga->swc->surface_relocation(svga->swc,
                                       &ts[i].value,
                                       handle,
                                       SVGA_RELOC_READ);
      }

      SVGA_FIFOCommitAll(svga->swc);
   }

   svga->rebind.texture_samplers = FALSE;

   return PIPE_OK;
}


d170 2
a171 1
   SVGA_NEW_SAMPLER,
a186 2
   assert(unit < Elements(svga->state.hw_draw.ts));                     \
   assert(SVGA3D_TS_##token < Elements(svga->state.hw_draw.ts[unit]));  \
a195 2
   assert(unit < Elements(svga->state.hw_draw.ts));                     \
   assert(SVGA3D_TS_##token < Elements(svga->state.hw_draw.ts[unit]));  \
d217 1
a217 1
static enum pipe_error
d269 1
a269 1
   return PIPE_OK;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d88 1
a88 1
      if (sv && s) {
a155 1
                                       NULL,
d167 1
a167 1
   return PIPE_OK;
a222 1
                                       NULL,
@


