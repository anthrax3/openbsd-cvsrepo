head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.10;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.00;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "util/u_inlines.h"
#include "pipe/p_defines.h"
#include "util/u_math.h"

#include "svga_context.h"
#include "svga_state.h"
#include "svga_cmd.h"
#include "svga_debug.h"
#include "svga_screen.h"


/*
 * flush our command buffer after the 8th distinct render target
 *
 * This helps improve the surface cache behaviour in the face of the
 * large number of single-use render targets generated by EXA and the xorg
 * state tracker.  Without this we can reference hundreds of individual
 * render targets from a command buffer, which leaves little scope for
 * sharing or reuse of those targets.
 */
#define MAX_RT_PER_BATCH 8


/***********************************************************************
 * Hardware state update
 */


static enum pipe_error
emit_framebuffer( struct svga_context *svga,
                  unsigned dirty )
{
   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
   const struct pipe_framebuffer_state *curr = &svga->curr.framebuffer;
   struct pipe_framebuffer_state *hw = &svga->state.hw_clear.framebuffer;
   boolean reemit = svga->rebind.rendertargets;
   unsigned i;
   enum pipe_error ret;

   /*
    * We need to reemit non-null surface bindings, even when they are not
    * dirty, to ensure that the resources are paged in.
    */

   for (i = 0; i < svgascreen->max_color_buffers; i++) {
      if (curr->cbufs[i] != hw->cbufs[i] ||
          (reemit && hw->cbufs[i])) {
         if (svga->curr.nr_fbs++ > MAX_RT_PER_BATCH)
            return PIPE_ERROR_OUT_OF_MEMORY;

         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i,
                                      curr->cbufs[i]);
         if (ret != PIPE_OK)
            return ret;

         pipe_surface_reference(&hw->cbufs[i], curr->cbufs[i]);
      }
   }

   if (curr->zsbuf != hw->zsbuf ||
       (reemit && hw->zsbuf)) {
      ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_DEPTH, curr->zsbuf);
      if (ret != PIPE_OK)
         return ret;

      if (curr->zsbuf &&
          curr->zsbuf->format == PIPE_FORMAT_S8_UINT_Z24_UNORM) {
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_STENCIL,
                                      curr->zsbuf);
         if (ret != PIPE_OK)
            return ret;
      }
      else {
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_STENCIL, NULL);
         if (ret != PIPE_OK)
            return ret;
      }

      pipe_surface_reference(&hw->zsbuf, curr->zsbuf);
   }

   svga->rebind.rendertargets = FALSE;

   return PIPE_OK;
}


/*
 * Rebind rendertargets.
 *
 * Similar to emit_framebuffer, but without any state checking/update.
 *
 * Called at the beginning of every new command buffer to ensure that
 * non-dirty rendertargets are properly paged-in.
 */
enum pipe_error
svga_reemit_framebuffer_bindings(struct svga_context *svga)
{
   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
   struct pipe_framebuffer_state *hw = &svga->state.hw_clear.framebuffer;
   unsigned i;
   enum pipe_error ret;

   assert(svga->rebind.rendertargets);

   for (i = 0; i < svgascreen->max_color_buffers; i++) {
      if (hw->cbufs[i]) {
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i,
                                      hw->cbufs[i]);
         if (ret != PIPE_OK) {
            return ret;
         }
      }
   }

   if (hw->zsbuf) {
      ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_DEPTH, hw->zsbuf);
      if (ret != PIPE_OK) {
         return ret;
      }

      if (hw->zsbuf &&
          hw->zsbuf->format == PIPE_FORMAT_S8_UINT_Z24_UNORM) {
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_STENCIL, hw->zsbuf);
         if (ret != PIPE_OK) {
            return ret;
         }
      }
      else {
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_STENCIL, NULL);
         if (ret != PIPE_OK) {
            return ret;
         }
      }
   }

   svga->rebind.rendertargets = FALSE;

   return PIPE_OK;
}


struct svga_tracked_state svga_hw_framebuffer =
{
   "hw framebuffer state",
   SVGA_NEW_FRAME_BUFFER,
   emit_framebuffer
};




/***********************************************************************
 */

static enum pipe_error
emit_viewport( struct svga_context *svga,
               unsigned dirty )
{
   const struct pipe_viewport_state *viewport = &svga->curr.viewport;
   struct svga_prescale prescale;
   SVGA3dRect rect;
   /* Not sure if this state is relevant with POSITIONT.  Probably
    * not, but setting to 0,1 avoids some state pingponging.
    */
   float range_min = 0.0;
   float range_max = 1.0;
   float flip = -1.0;
   boolean degenerate = FALSE;
   boolean invertY = FALSE;
   enum pipe_error ret;

   float fb_width = (float) svga->curr.framebuffer.width;
   float fb_height = (float) svga->curr.framebuffer.height;

   float fx =        viewport->scale[0] * -1.0f + viewport->translate[0];
   float fy = flip * viewport->scale[1] * -1.0f + viewport->translate[1];
   float fw =        viewport->scale[0] * 2.0f;
   float fh = flip * viewport->scale[1] * 2.0f;

   memset( &prescale, 0, sizeof(prescale) );

   /* Examine gallium viewport transformation and produce a screen
    * rectangle and possibly vertex shader pre-transformation to
    * get the same results.
    */

   SVGA_DBG(DEBUG_VIEWPORT,
            "\ninitial %f,%f %fx%f\n",
            fx,
            fy,
            fw,
            fh);

   prescale.scale[0] = 1.0;
   prescale.scale[1] = 1.0;
   prescale.scale[2] = 1.0;
   prescale.scale[3] = 1.0;
   prescale.translate[0] = 0;
   prescale.translate[1] = 0;
   prescale.translate[2] = 0;
   prescale.translate[3] = 0;
   prescale.enabled = TRUE;

   if (fw < 0) {
      prescale.scale[0] *= -1.0f;
      prescale.translate[0] += -fw;
      fw = -fw;
      fx = viewport->scale[0] * 1.0f + viewport->translate[0];
   }

   if (fh < 0.0) {
      prescale.translate[1] = fh - 1.0f + fy * 2.0f;
      fh = -fh;
      fy -= fh;
      prescale.scale[1] = -1.0f;
      invertY = TRUE;
   }

   if (fx < 0) {
      prescale.translate[0] += fx;
      prescale.scale[0] *= fw / (fw + fx);
      fw += fx;
      fx = 0.0f;
   }

   if (fy < 0) {
      if (invertY) {
         prescale.translate[1] -= fy;
      }
      else {
         prescale.translate[1] += fy;
      }
      prescale.scale[1] *= fh / (fh + fy);
      fh += fy;
      fy = 0.0f;
   }

   if (fx + fw > fb_width) {
      prescale.scale[0] *= fw / (fb_width - fx);
      prescale.translate[0] -= fx * (fw / (fb_width - fx));
      prescale.translate[0] += fx;
      fw = fb_width - fx;
   }

   if (fy + fh > fb_height) {
      prescale.scale[1] *= fh / (fb_height - fy);
      if (invertY) {
         float in = fb_height - fy;       /* number of vp pixels inside view */
         float out = fy + fh - fb_height; /* number of vp pixels out of view */
         prescale.translate[1] += fy * out / in;
      }
      else {
         prescale.translate[1] -= fy * (fh / (fb_height - fy));
         prescale.translate[1] += fy;
      }
      fh = fb_height - fy;
   }

   if (fw < 0 || fh < 0) {
      fw = fh = fx = fy = 0;
      degenerate = TRUE;
      goto out;
   }

   /* D3D viewport is integer space.  Convert fx,fy,etc. to
    * integers.
    *
    * TODO: adjust pretranslate correct for any subpixel error
    * introduced converting to integers.
    */
   rect.x = (uint32) fx;
   rect.y = (uint32) fy;
   rect.w = (uint32) fw;
   rect.h = (uint32) fh;

   SVGA_DBG(DEBUG_VIEWPORT,
            "viewport error %f,%f %fx%f\n",
            fabs((float)rect.x - fx),
            fabs((float)rect.y - fy),
            fabs((float)rect.w - fw),
            fabs((float)rect.h - fh));

   SVGA_DBG(DEBUG_VIEWPORT,
            "viewport %d,%d %dx%d\n",
            rect.x,
            rect.y,
            rect.w,
            rect.h);

   /* Finally, to get GL rasterization rules, need to tweak the
    * screen-space coordinates slightly relative to D3D which is
    * what hardware implements natively.
    */
   if (svga->curr.rast->templ.half_pixel_center) {
      float adjust_x = 0.0;
      float adjust_y = 0.0;

      switch (svga->curr.reduced_prim) {
      case PIPE_PRIM_POINTS:
         adjust_x = -0.375;
         adjust_y = -0.75;
         break;
      case PIPE_PRIM_LINES:
         adjust_x = -0.5;
         adjust_y = 0;
         break;
      case PIPE_PRIM_TRIANGLES:
         adjust_x = -0.5;
         adjust_y = -0.5;
         break;
      }

      if (invertY)
         adjust_y = -adjust_y;

      prescale.translate[0] += adjust_x;
      prescale.translate[1] += adjust_y;
      prescale.translate[2] = 0.5; /* D3D clip space */
      prescale.scale[2]     = 0.5; /* D3D clip space */
   }

   range_min = viewport->scale[2] * -1.0f + viewport->translate[2];
   range_max = viewport->scale[2] *  1.0f + viewport->translate[2];

   /* D3D (and by implication SVGA) doesn't like dealing with zmax
    * less than zmin.  Detect that case, flip the depth range and
    * invert our z-scale factor to achieve the same effect.
    */
   if (range_min > range_max) {
      float range_tmp;
      range_tmp = range_min;
      range_min = range_max;
      range_max = range_tmp;
      prescale.scale[2] = -prescale.scale[2];
   }

   if (prescale.enabled) {
      float H[2];
      float J[2];
      int i;

      SVGA_DBG(DEBUG_VIEWPORT,
               "prescale %f,%f %fx%f\n",
               prescale.translate[0],
               prescale.translate[1],
               prescale.scale[0],
               prescale.scale[1]);

      H[0] = (float)rect.w / 2.0f;
      H[1] = -(float)rect.h / 2.0f;
      J[0] = (float)rect.x + (float)rect.w / 2.0f;
      J[1] = (float)rect.y + (float)rect.h / 2.0f;

      SVGA_DBG(DEBUG_VIEWPORT,
               "H %f,%f\n"
               "J %fx%f\n",
               H[0],
               H[1],
               J[0],
               J[1]);

      /* Adjust prescale to take into account the fact that it is
       * going to be applied prior to the perspective divide and
       * viewport transformation.
       *
       * Vwin = H(Vc/Vc.w) + J
       *
       * We want to tweak Vwin with scale and translation from above,
       * as in:
       *
       * Vwin' = S Vwin + T
       *
       * But we can only modify the values at Vc.  Plugging all the
       * above together, and rearranging, eventually we get:
       *
       *   Vwin' = H(Vc'/Vc'.w) + J
       * where:
       *   Vc' = SVc + KVc.w
       *   K = (T + (S-1)J) / H
       *
       * Overwrite prescale.translate with values for K:
       */
      for (i = 0; i < 2; i++) {
         prescale.translate[i] = ((prescale.translate[i] +
                                   (prescale.scale[i] - 1.0f) * J[i]) / H[i]);
      }

      SVGA_DBG(DEBUG_VIEWPORT,
               "clipspace %f,%f %fx%f\n",
               prescale.translate[0],
               prescale.translate[1],
               prescale.scale[0],
               prescale.scale[1]);
   }

out:
   if (degenerate) {
      rect.x = 0;
      rect.y = 0;
      rect.w = 1;
      rect.h = 1;
      prescale.enabled = FALSE;
   }

   if (memcmp(&rect, &svga->state.hw_clear.viewport, sizeof(rect)) != 0) {
      ret = SVGA3D_SetViewport(svga->swc, &rect);
      if(ret != PIPE_OK)
         return ret;

      memcpy(&svga->state.hw_clear.viewport, &rect, sizeof(rect));
      assert(sizeof(rect) == sizeof(svga->state.hw_clear.viewport));
   }

   if (svga->state.hw_clear.depthrange.zmin != range_min ||
       svga->state.hw_clear.depthrange.zmax != range_max) {
      ret = SVGA3D_SetZRange(svga->swc, range_min, range_max );
      if(ret != PIPE_OK)
         return ret;

      svga->state.hw_clear.depthrange.zmin = range_min;
      svga->state.hw_clear.depthrange.zmax = range_max;
   }

   if (memcmp(&prescale, &svga->state.hw_clear.prescale, sizeof prescale) != 0) {
      svga->dirty |= SVGA_NEW_PRESCALE;
      svga->state.hw_clear.prescale = prescale;
   }

   return PIPE_OK;
}


struct svga_tracked_state svga_hw_viewport =
{
   "hw viewport state",
   ( SVGA_NEW_FRAME_BUFFER |
     SVGA_NEW_VIEWPORT |
     SVGA_NEW_RAST |
     SVGA_NEW_REDUCED_PRIMITIVE ),
   emit_viewport
};


/***********************************************************************
 * Scissor state
 */
static enum pipe_error
emit_scissor_rect( struct svga_context *svga,
                   unsigned dirty )
{
   const struct pipe_scissor_state *scissor = &svga->curr.scissor;
   SVGA3dRect rect;

   rect.x = scissor->minx;
   rect.y = scissor->miny;
   rect.w = scissor->maxx - scissor->minx; /* + 1 ?? */
   rect.h = scissor->maxy - scissor->miny; /* + 1 ?? */

   return SVGA3D_SetScissorRect(svga->swc, &rect);
}


struct svga_tracked_state svga_hw_scissor =
{
   "hw scissor state",
   SVGA_NEW_SCISSOR,
   emit_scissor_rect
};


/***********************************************************************
 * Userclip state
 */

static enum pipe_error
emit_clip_planes( struct svga_context *svga,
                  unsigned dirty )
{
   unsigned i;
   enum pipe_error ret;

   /* TODO: just emit directly from svga_set_clip_state()?
    */
   for (i = 0; i < SVGA3D_MAX_CLIP_PLANES; i++) {
      /* need to express the plane in D3D-style coordinate space.
       * GL coords get converted to D3D coords with the matrix:
       * [ 1  0  0  0 ]
       * [ 0 -1  0  0 ]
       * [ 0  0  2  0 ]
       * [ 0  0 -1  1 ]
       * Apply that matrix to our plane equation, and invert Y.
       */
      float a = svga->curr.clip.ucp[i][0];
      float b = svga->curr.clip.ucp[i][1];
      float c = svga->curr.clip.ucp[i][2];
      float d = svga->curr.clip.ucp[i][3];
      float plane[4];

      plane[0] = a;
      plane[1] = b;
      plane[2] = 2.0f * c;
      plane[3] = d - c;

      ret = SVGA3D_SetClipPlane(svga->swc, i, plane);
      if(ret != PIPE_OK)
         return ret;
   }

   return PIPE_OK;
}


struct svga_tracked_state svga_hw_clip_planes =
{
   "hw viewport state",
   SVGA_NEW_CLIP,
   emit_clip_planes
};
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d34 13
d58 1
d69 2
a70 2
   
   for(i = 0; i < PIPE_MAX_COLOR_BUFS; ++i) {
d73 1
a73 1
         if (svga->curr.nr_fbs++ > 8)
d76 2
a77 1
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i, curr->cbufs[i]);
d80 1
a80 1
         
a84 1
   
d93 2
a94 1
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_STENCIL, curr->zsbuf);
d103 1
a103 1
      
d124 1
d131 1
a131 1
   for (i = 0; i < MIN2(PIPE_MAX_COLOR_BUFS, 8); ++i) {
d133 2
a134 1
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i, hw->cbufs[i]);
d168 1
a168 1
struct svga_tracked_state svga_hw_framebuffer = 
d178 1
a178 1
/*********************************************************************** 
d203 2
a204 2
   float fw =        viewport->scale[0] * 2.0f; 
   float fh = flip * viewport->scale[1] * 2.0f; 
a229 2


d234 1
a234 1
      fx =        viewport->scale[0] * 1.0f + viewport->translate[0];
d247 1
a247 1
      prescale.scale[0] *= fw / (fw + fx); 
d259 1
a259 1
      prescale.scale[1] *= fh / (fh + fy); 
d265 1
a265 1
      prescale.scale[0] *= fw / (fb_width - fx); 
a268 1
      
a290 1

a315 1

d325 4
a332 1
      case PIPE_PRIM_POINTS:
a347 1

d357 2
a358 2
      range_tmp = range_min; 
      range_min = range_max; 
d360 1
a360 1
      prescale.scale[2]     = -prescale.scale[2];
d391 1
a391 1
       * 
d441 1
a441 2
       svga->state.hw_clear.depthrange.zmax != range_max) 
   {
d459 1
a459 1
struct svga_tracked_state svga_hw_viewport = 
d484 1
a484 1
   
d489 1
a489 1
struct svga_tracked_state svga_hw_scissor = 
d539 1
a539 1
struct svga_tracked_state svga_hw_clip_planes = 
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d41 3
a43 2
static int emit_framebuffer( struct svga_context *svga,
                             unsigned dirty )
d78 1
a78 1
          curr->zsbuf->format == PIPE_FORMAT_S8_USCALED_Z24_UNORM) {
d94 1
a94 1
   return 0;
d131 1
a131 1
          hw->zsbuf->format == PIPE_FORMAT_S8_USCALED_Z24_UNORM) {
d164 3
a166 2
static int emit_viewport( struct svga_context *svga,
                          unsigned dirty )
d178 1
d181 2
a182 2
   float fb_width = svga->curr.framebuffer.width;
   float fb_height = svga->curr.framebuffer.height;
d184 4
a187 4
   float fx =        viewport->scale[0] * -1.0 + viewport->translate[0];
   float fy = flip * viewport->scale[1] * -1.0 + viewport->translate[1];
   float fw =        viewport->scale[0] * 2; 
   float fh = flip * viewport->scale[1] * 2; 
d216 1
a216 1
      prescale.scale[0] *= -1.0;
d219 1
a219 1
      fx =        viewport->scale[0] * 1.0 + viewport->translate[0];
d222 2
a223 3
   if (fh < 0) {
      prescale.scale[1] *= -1.0;
      prescale.translate[1] += -fh;
d225 3
a227 1
      fy = flip * viewport->scale[1] * 1.0 + viewport->translate[1];
d234 1
a234 1
      fx = 0;
d238 6
a243 1
      prescale.translate[1] += fy;
d246 1
a246 1
      fy = 0;
d259 9
a267 2
      prescale.translate[1] -= fy * (fh / (fb_height - fy));
      prescale.translate[1] += fy;
d284 4
a287 4
   rect.x = fx;
   rect.y = fy;
   rect.w = fw;
   rect.h = fh;
d308 1
a308 1
   if (svga->curr.rast->templ.gl_rasterization_rules) {
d324 3
d334 2
a335 2
   range_min = viewport->scale[2] * -1.0 + viewport->translate[2];
   range_max = viewport->scale[2] *  1.0 + viewport->translate[2];
d361 4
a364 4
      H[0] = (float)rect.w / 2.0;
      H[1] = -(float)rect.h / 2.0;
      J[0] = (float)rect.x + (float)rect.w / 2.0;
      J[1] = (float)rect.y + (float)rect.h / 2.0;
d397 1
a397 1
                                   (prescale.scale[i] - 1.0) * J[i]) / H[i]);
d442 1
a442 1
   return 0;
d460 3
a462 2
static int emit_scissor_rect( struct svga_context *svga,
                              unsigned dirty )
d488 3
a490 2
static int emit_clip_planes( struct svga_context *svga,
                             unsigned dirty )
d497 1
a497 1
   for (i = 0; i < svga->curr.clip.nr; i++) {
d522 1
a522 1
   return 0;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d46 1
a46 1
   boolean reemit = !!(dirty & SVGA_NEW_COMMAND_BUFFER);
d91 1
d97 53
d153 1
a153 2
   SVGA_NEW_FRAME_BUFFER |
   SVGA_NEW_COMMAND_BUFFER,
d303 1
a303 1
         adjust_x = -0.375;
d477 20
a496 3
      ret = SVGA3D_SetClipPlane( svga->swc,
                                 i,
                                 svga->curr.clip.ucp[i] );
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d46 1
d50 3
a52 2
   /* XXX: Need shadow state in svga->hw to eliminate redundant
    * uploads, especially of NULL buffers.
d56 2
a57 1
      if (curr->cbufs[i] != hw->cbufs[i]) {
d70 2
a71 1
   if (curr->zsbuf != hw->zsbuf) {
d77 1
a77 1
          curr->zsbuf->format == PIPE_FORMAT_S8Z24_UNORM) {
d99 2
a100 1
   SVGA_NEW_FRAME_BUFFER,
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a45 1
   boolean reemit = !!(dirty & SVGA_NEW_COMMAND_BUFFER);
d49 2
a50 3
   /*
    * We need to reemit non-null surface bindings, even when they are not
    * dirty, to ensure that the resources are paged in.
d54 1
a54 2
      if (curr->cbufs[i] != hw->cbufs[i] ||
          (reemit && hw->cbufs[i])) {
d67 1
a67 2
   if (curr->zsbuf != hw->zsbuf ||
       (reemit && hw->zsbuf)) {
d73 1
a73 1
          curr->zsbuf->format == PIPE_FORMAT_S8_USCALED_Z24_UNORM) {
d95 1
a95 2
   SVGA_NEW_FRAME_BUFFER |
   SVGA_NEW_COMMAND_BUFFER,
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d41 2
a42 3
static enum pipe_error
emit_framebuffer( struct svga_context *svga,
                  unsigned dirty )
d46 1
a46 1
   boolean reemit = svga->rebind.rendertargets;
d77 1
a77 1
          curr->zsbuf->format == PIPE_FORMAT_S8_UINT_Z24_UNORM) {
a90 1
   svga->rebind.rendertargets = FALSE;
d92 1
a92 54
   return PIPE_OK;
}


/*
 * Rebind rendertargets.
 *
 * Similar to emit_framebuffer, but without any state checking/update.
 *
 * Called at the beginning of every new command buffer to ensure that
 * non-dirty rendertargets are properly paged-in.
 */
enum pipe_error
svga_reemit_framebuffer_bindings(struct svga_context *svga)
{
   struct pipe_framebuffer_state *hw = &svga->state.hw_clear.framebuffer;
   unsigned i;
   enum pipe_error ret;

   assert(svga->rebind.rendertargets);

   for (i = 0; i < MIN2(PIPE_MAX_COLOR_BUFS, 8); ++i) {
      if (hw->cbufs[i]) {
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i, hw->cbufs[i]);
         if (ret != PIPE_OK) {
            return ret;
         }
      }
   }

   if (hw->zsbuf) {
      ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_DEPTH, hw->zsbuf);
      if (ret != PIPE_OK) {
         return ret;
      }

      if (hw->zsbuf &&
          hw->zsbuf->format == PIPE_FORMAT_S8_UINT_Z24_UNORM) {
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_STENCIL, hw->zsbuf);
         if (ret != PIPE_OK) {
            return ret;
         }
      }
      else {
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_STENCIL, NULL);
         if (ret != PIPE_OK) {
            return ret;
         }
      }
   }

   svga->rebind.rendertargets = FALSE;

   return PIPE_OK;
d99 2
a100 1
   SVGA_NEW_FRAME_BUFFER,
d110 2
a111 3
static enum pipe_error
emit_viewport( struct svga_context *svga,
               unsigned dirty )
a122 1
   boolean invertY = FALSE;
d125 2
a126 2
   float fb_width = (float) svga->curr.framebuffer.width;
   float fb_height = (float) svga->curr.framebuffer.height;
d128 4
a131 4
   float fx =        viewport->scale[0] * -1.0f + viewport->translate[0];
   float fy = flip * viewport->scale[1] * -1.0f + viewport->translate[1];
   float fw =        viewport->scale[0] * 2.0f; 
   float fh = flip * viewport->scale[1] * 2.0f; 
d160 1
a160 1
      prescale.scale[0] *= -1.0f;
d163 1
a163 1
      fx =        viewport->scale[0] * 1.0f + viewport->translate[0];
d166 3
a168 2
   if (fh < 0.0) {
      prescale.translate[1] = fh - 1.0f + fy * 2.0f;
d170 1
a170 3
      fy -= fh;
      prescale.scale[1] = -1.0f;
      invertY = TRUE;
d177 1
a177 1
      fx = 0.0f;
d181 1
a181 6
      if (invertY) {
         prescale.translate[1] -= fy;
      }
      else {
         prescale.translate[1] += fy;
      }
d184 1
a184 1
      fy = 0.0f;
d197 2
a198 9
      if (invertY) {
         float in = fb_height - fy;       /* number of vp pixels inside view */
         float out = fy + fh - fb_height; /* number of vp pixels out of view */
         prescale.translate[1] += fy * out / in;
      }
      else {
         prescale.translate[1] -= fy * (fh / (fb_height - fy));
         prescale.translate[1] += fy;
      }
d215 4
a218 4
   rect.x = (uint32) fx;
   rect.y = (uint32) fy;
   rect.w = (uint32) fw;
   rect.h = (uint32) fh;
d239 1
a239 1
   if (svga->curr.rast->templ.half_pixel_center) {
d250 1
a250 1
         adjust_x = -0.5;
a254 3
      if (invertY)
         adjust_y = -adjust_y;

d262 2
a263 2
   range_min = viewport->scale[2] * -1.0f + viewport->translate[2];
   range_max = viewport->scale[2] *  1.0f + viewport->translate[2];
d289 4
a292 4
      H[0] = (float)rect.w / 2.0f;
      H[1] = -(float)rect.h / 2.0f;
      J[0] = (float)rect.x + (float)rect.w / 2.0f;
      J[1] = (float)rect.y + (float)rect.h / 2.0f;
d325 1
a325 1
                                   (prescale.scale[i] - 1.0f) * J[i]) / H[i]);
d370 1
a370 1
   return PIPE_OK;
d388 2
a389 3
static enum pipe_error
emit_scissor_rect( struct svga_context *svga,
                   unsigned dirty )
d415 2
a416 3
static enum pipe_error
emit_clip_planes( struct svga_context *svga,
                  unsigned dirty )
d423 4
a426 21
   for (i = 0; i < SVGA3D_MAX_CLIP_PLANES; i++) {
      /* need to express the plane in D3D-style coordinate space.
       * GL coords get converted to D3D coords with the matrix:
       * [ 1  0  0  0 ]
       * [ 0 -1  0  0 ]
       * [ 0  0  2  0 ]
       * [ 0  0 -1  1 ]
       * Apply that matrix to our plane equation, and invert Y.
       */
      float a = svga->curr.clip.ucp[i][0];
      float b = svga->curr.clip.ucp[i][1];
      float c = svga->curr.clip.ucp[i][2];
      float d = svga->curr.clip.ucp[i][3];
      float plane[4];

      plane[0] = a;
      plane[1] = b;
      plane[2] = 2.0f * c;
      plane[3] = d - c;

      ret = SVGA3D_SetClipPlane(svga->swc, i, plane);
d431 1
a431 1
   return PIPE_OK;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a33 13
#include "svga_screen.h"


/*
 * flush our command buffer after the 8th distinct render target
 *
 * This helps improve the surface cache behaviour in the face of the
 * large number of single-use render targets generated by EXA and the xorg
 * state tracker.  Without this we can reference hundreds of individual
 * render targets from a command buffer, which leaves little scope for
 * sharing or reuse of those targets.
 */
#define MAX_RT_PER_BATCH 8
a44 1
   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
d55 2
a56 2

   for (i = 0; i < svgascreen->max_color_buffers; i++) {
d59 1
a59 1
         if (svga->curr.nr_fbs++ > MAX_RT_PER_BATCH)
d62 1
a62 2
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i,
                                      curr->cbufs[i]);
d65 1
a65 1

d70 1
d79 1
a79 2
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_STENCIL,
                                      curr->zsbuf);
d88 1
a88 1

a108 1
   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
d115 1
a115 1
   for (i = 0; i < svgascreen->max_color_buffers; i++) {
d117 1
a117 2
         ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i,
                                      hw->cbufs[i]);
d151 1
a151 1
struct svga_tracked_state svga_hw_framebuffer =
d161 1
a161 1
/***********************************************************************
d186 2
a187 2
   float fw =        viewport->scale[0] * 2.0f;
   float fh = flip * viewport->scale[1] * 2.0f;
d213 2
d219 1
a219 1
      fx = viewport->scale[0] * 1.0f + viewport->translate[0];
d232 1
a232 1
      prescale.scale[0] *= fw / (fw + fx);
d244 1
a244 1
      prescale.scale[1] *= fh / (fh + fy);
d250 1
a250 1
      prescale.scale[0] *= fw / (fb_width - fx);
d254 1
d277 1
d303 1
a312 4
      case PIPE_PRIM_POINTS:
         adjust_x = -0.375;
         adjust_y = -0.75;
         break;
d317 1
d333 1
d343 2
a344 2
      range_tmp = range_min;
      range_min = range_max;
d346 1
a346 1
      prescale.scale[2] = -prescale.scale[2];
d377 1
a377 1
       *
d427 2
a428 1
       svga->state.hw_clear.depthrange.zmax != range_max) {
d446 1
a446 1
struct svga_tracked_state svga_hw_viewport =
d471 1
a471 1

d476 1
a476 1
struct svga_tracked_state svga_hw_scissor =
d526 1
a526 1
struct svga_tracked_state svga_hw_clip_planes =
@


