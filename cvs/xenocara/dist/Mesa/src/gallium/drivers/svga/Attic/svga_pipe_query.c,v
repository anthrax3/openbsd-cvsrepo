head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.01.09;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.52;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.07;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "pipe/p_state.h"
#include "pipe/p_context.h"
#include "util/u_memory.h"

#include "svga_cmd.h"
#include "svga_context.h"
#include "svga_screen.h"
#include "svga_resource_buffer.h"
#include "svga_winsys.h"
#include "svga_debug.h"


/* Fixme: want a public base class for all pipe structs, even if there
 * isn't much in them.
 */
struct pipe_query {
   int dummy;
};


struct svga_query {
   struct pipe_query base;
   unsigned type;                  /**< PIPE_QUERY_x or SVGA_QUERY_x */
   SVGA3dQueryType svga_type;      /**< SVGA3D_QUERYTYPE_x or unused */

   /** For PIPE_QUERY_OCCLUSION_COUNTER / SVGA3D_QUERYTYPE_OCCLUSION */
   struct svga_winsys_buffer *hwbuf;
   volatile SVGA3dQueryResult *queryResult;
   struct pipe_fence_handle *fence;

   /** For non-GPU SVGA_QUERY_x queries */
   uint64_t begin_count, end_count;
};


/** cast wrapper */
static INLINE struct svga_query *
svga_query( struct pipe_query *q )
{
   return (struct svga_query *)q;
}


static boolean
svga_get_query_result(struct pipe_context *pipe,
                      struct pipe_query *q,
                      boolean wait,
                      union pipe_query_result *result);


static struct pipe_query *
svga_create_query( struct pipe_context *pipe, unsigned query_type )
{
   struct svga_context *svga = svga_context( pipe );
   struct svga_screen *svgascreen = svga_screen(pipe->screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   struct svga_query *sq;

   SVGA_DBG(DEBUG_QUERY, "%s\n", __FUNCTION__);

   sq = CALLOC_STRUCT(svga_query);
   if (!sq)
      goto no_sq;

   switch (query_type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      sq->svga_type = SVGA3D_QUERYTYPE_OCCLUSION;

      sq->hwbuf = svga_winsys_buffer_create(svga, 1,
                                            SVGA_BUFFER_USAGE_PINNED,
                                            sizeof *sq->queryResult);
      if (!sq->hwbuf) {
         debug_printf("svga: failed to alloc query object!\n");
         goto no_hwbuf;
      }

      sq->queryResult = (SVGA3dQueryResult *)
         sws->buffer_map(sws, sq->hwbuf, PIPE_TRANSFER_WRITE);
      if (!sq->queryResult) {
         debug_printf("svga: failed to map query object!\n");
         goto no_query_result;
      }

      sq->queryResult->totalSize = sizeof *sq->queryResult;
      sq->queryResult->state = SVGA3D_QUERYSTATE_NEW;

      /* We request the buffer to be pinned and assume it is always mapped.
       * The reason is that we don't want to wait for fences when checking the
       * query status.
       */
      sws->buffer_unmap(sws, sq->hwbuf);
      break;
   case SVGA_QUERY_DRAW_CALLS:
   case SVGA_QUERY_FALLBACKS:
   case SVGA_QUERY_MEMORY_USED:
      break;
   default:
      assert(!"unexpected query type in svga_create_query()");
   }

   sq->type = query_type;

   return &sq->base;

no_query_result:
   sws->buffer_destroy(sws, sq->hwbuf);
no_hwbuf:
   FREE(sq);
no_sq:
   return NULL;
}


static void
svga_destroy_query(struct pipe_context *pipe, struct pipe_query *q)
{
   struct svga_screen *svgascreen = svga_screen(pipe->screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   struct svga_query *sq = svga_query( q );

   SVGA_DBG(DEBUG_QUERY, "%s\n", __FUNCTION__);

   switch (sq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      sws->buffer_destroy(sws, sq->hwbuf);
      sq->hwbuf = NULL;
      sws->fence_reference(sws, &sq->fence, NULL);
      break;
   case SVGA_QUERY_DRAW_CALLS:
   case SVGA_QUERY_FALLBACKS:
   case SVGA_QUERY_MEMORY_USED:
      /* nothing */
      break;
   default:
      assert(!"svga: unexpected query type in svga_destroy_query()");
   }

   FREE(sq);
}


static void
svga_begin_query(struct pipe_context *pipe, struct pipe_query *q)
{
   struct svga_screen *svgascreen = svga_screen(pipe->screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   struct svga_context *svga = svga_context( pipe );
   struct svga_query *sq = svga_query( q );
   enum pipe_error ret;

   SVGA_DBG(DEBUG_QUERY, "%s\n", __FUNCTION__);

   /* Need to flush out buffered drawing commands so that they don't
    * get counted in the query results.
    */
   svga_hwtnl_flush_retry(svga);

   switch (sq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      assert(!svga->sq);
      if (sq->queryResult->state == SVGA3D_QUERYSTATE_PENDING) {
         /* The application doesn't care for the pending query result.
          * We cannot let go of the existing buffer and just get a new one
          * because its storage may be reused for other purposes and clobbered
          * by the host when it determines the query result.  So the only
          * option here is to wait for the existing query's result -- not a
          * big deal, given that no sane application would do this.
          */
         uint64_t result;
         svga_get_query_result(pipe, q, TRUE, (void*)&result);
         assert(sq->queryResult->state != SVGA3D_QUERYSTATE_PENDING);
      }

      sq->queryResult->state = SVGA3D_QUERYSTATE_NEW;
      sws->fence_reference(sws, &sq->fence, NULL);

      ret = SVGA3D_BeginQuery(svga->swc, sq->svga_type);
      if (ret != PIPE_OK) {
         svga_context_flush(svga, NULL);
         ret = SVGA3D_BeginQuery(svga->swc, sq->svga_type);
         assert(ret == PIPE_OK);
      }

      svga->sq = sq;
      break;
   case SVGA_QUERY_DRAW_CALLS:
      sq->begin_count = svga->num_draw_calls;
      break;
   case SVGA_QUERY_FALLBACKS:
      sq->begin_count = svga->num_fallbacks;
      break;
   case SVGA_QUERY_MEMORY_USED:
      /* nothing */
      break;
   default:
      assert(!"unexpected query type in svga_begin_query()");
   }
}


static void
svga_end_query(struct pipe_context *pipe, struct pipe_query *q)
{
   struct svga_context *svga = svga_context( pipe );
   struct svga_query *sq = svga_query( q );
   enum pipe_error ret;

   SVGA_DBG(DEBUG_QUERY, "%s\n", __FUNCTION__);

   svga_hwtnl_flush_retry(svga);

   switch (sq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      assert(svga->sq == sq);

      /* Set to PENDING before sending EndQuery. */
      sq->queryResult->state = SVGA3D_QUERYSTATE_PENDING;

      ret = SVGA3D_EndQuery( svga->swc, sq->svga_type, sq->hwbuf);
      if (ret != PIPE_OK) {
         svga_context_flush(svga, NULL);
         ret = SVGA3D_EndQuery( svga->swc, sq->svga_type, sq->hwbuf);
         assert(ret == PIPE_OK);
      }

      /* TODO: Delay flushing. We don't really need to flush here, just ensure
       * that there is one flush before svga_get_query_result attempts to get
       * the result.
       */
      svga_context_flush(svga, NULL);

      svga->sq = NULL;
      break;
   case SVGA_QUERY_DRAW_CALLS:
      sq->end_count = svga->num_draw_calls;
      break;
   case SVGA_QUERY_FALLBACKS:
      sq->end_count = svga->num_fallbacks;
      break;
   case SVGA_QUERY_MEMORY_USED:
      /* nothing */
      break;
   default:
      assert(!"unexpected query type in svga_end_query()");
   }
}


static boolean
svga_get_query_result(struct pipe_context *pipe,
                      struct pipe_query *q,
                      boolean wait,
                      union pipe_query_result *vresult)
{
   struct svga_context *svga = svga_context( pipe );
   struct svga_screen *svgascreen = svga_screen( pipe->screen );
   struct svga_winsys_screen *sws = svgascreen->sws;
   struct svga_query *sq = svga_query( q );
   SVGA3dQueryState state;
   uint64_t *result = (uint64_t *) vresult;

   SVGA_DBG(DEBUG_QUERY, "%s wait: %d\n", __FUNCTION__);

   switch (sq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      /* The query status won't be updated by the host unless
       * SVGA_3D_CMD_WAIT_FOR_QUERY is emitted. Unfortunately this will cause
       * a synchronous wait on the host.
       */
      if (!sq->fence) {
         enum pipe_error ret;

         ret = SVGA3D_WaitForQuery( svga->swc, sq->svga_type, sq->hwbuf);
         if (ret != PIPE_OK) {
            svga_context_flush(svga, NULL);
            ret = SVGA3D_WaitForQuery( svga->swc, sq->svga_type, sq->hwbuf);
            assert(ret == PIPE_OK);
         }

         svga_context_flush(svga, &sq->fence);

         assert(sq->fence);
      }

      state = sq->queryResult->state;
      if (state == SVGA3D_QUERYSTATE_PENDING) {
         if (!wait)
            return FALSE;
         sws->fence_finish(sws, sq->fence, SVGA_FENCE_FLAG_QUERY);
         state = sq->queryResult->state;
      }

      assert(state == SVGA3D_QUERYSTATE_SUCCEEDED ||
             state == SVGA3D_QUERYSTATE_FAILED);

      *result = (uint64_t) sq->queryResult->result32;
      break;
   case SVGA_QUERY_DRAW_CALLS:
      /* fall-through */
   case SVGA_QUERY_FALLBACKS:
      vresult->u64 = sq->end_count - sq->begin_count;
      break;
   case SVGA_QUERY_MEMORY_USED:
      vresult->u64 = svgascreen->total_resource_bytes;
      break;
   default:
      assert(!"unexpected query type in svga_get_query_result");
   }

   SVGA_DBG(DEBUG_QUERY, "%s result %d\n", __FUNCTION__, (unsigned)*result);

   return TRUE;
}


void
svga_init_query_functions(struct svga_context *svga)
{
   svga->pipe.create_query = svga_create_query;
   svga->pipe.destroy_query = svga_destroy_query;
   svga->pipe.begin_query = svga_begin_query;
   svga->pipe.end_query = svga_end_query;
   svga->pipe.get_query_result = svga_get_query_result;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d77 1
a77 3
svga_create_query(struct pipe_context *pipe,
                  unsigned query_type,
                  unsigned index)
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d77 3
a79 1
svga_create_query( struct pipe_context *pipe, unsigned query_type )
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d97 2
a98 1
      if (!sq->hwbuf)
d100 1
d104 2
a105 1
      if (!sq->queryResult)
d107 1
d151 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d45 1
d48 4
a51 1
   SVGA3dQueryType type;
d55 3
d60 2
a61 4
/***********************************************************************
 * Inline conversion functions.  These are better-typed than the
 * macros used previously:
 */
a67 4
static boolean svga_get_query_result(struct pipe_context *pipe, 
                                     struct pipe_query *q,
                                     boolean wait,
                                     void *result);
d69 9
a77 2
static struct pipe_query *svga_create_query( struct pipe_context *pipe,
                                             unsigned query_type )
d90 31
a120 1
   sq->type = SVGA3D_QUERYTYPE_OCCLUSION;
d122 1
a122 23
   sq->hwbuf = svga_winsys_buffer_create(svga,
                                         1,
                                         SVGA_BUFFER_USAGE_PINNED,
                                         sizeof *sq->queryResult);
   if(!sq->hwbuf)
      goto no_hwbuf;
    
   sq->queryResult = (SVGA3dQueryResult *)sws->buffer_map(sws, 
                                                          sq->hwbuf, 
                                                          PIPE_TRANSFER_WRITE);
   if(!sq->queryResult)
      goto no_query_result;

   sq->queryResult->totalSize = sizeof *sq->queryResult;
   sq->queryResult->state = SVGA3D_QUERYSTATE_NEW;

   /*
    * We request the buffer to be pinned and assume it is always mapped.
    * 
    * The reason is that we don't want to wait for fences when checking the
    * query status.
    */
   sws->buffer_unmap(sws, sq->hwbuf);
d134 3
a136 2
static void svga_destroy_query(struct pipe_context *pipe,
                               struct pipe_query *q)
d143 15
a157 2
   sws->buffer_destroy(sws, sq->hwbuf);
   sws->fence_reference(sws, &sq->fence, NULL);
d161 3
a163 2
static void svga_begin_query(struct pipe_context *pipe, 
                             struct pipe_query *q)
a171 2
   
   assert(!svga->sq);
a176 10
   
   if(sq->queryResult->state == SVGA3D_QUERYSTATE_PENDING) {
      /* The application doesn't care for the pending query result. We cannot
       * let go the existing buffer and just get a new one because its storage
       * may be reused for other purposes and clobbered by the host when it
       * determines the query result. So the only option here is to wait for
       * the existing query's result -- not a big deal, given that no sane
       * application would do this.
       */
      uint64_t result;
d178 25
a202 7
      svga_get_query_result(pipe, q, TRUE, &result);
      
      assert(sq->queryResult->state != SVGA3D_QUERYSTATE_PENDING);
   }
   
   sq->queryResult->state = SVGA3D_QUERYSTATE_NEW;
   sws->fence_reference(sws, &sq->fence, NULL);
d204 13
a216 5
   ret = SVGA3D_BeginQuery(svga->swc, sq->type);
   if(ret != PIPE_OK) {
      svga_context_flush(svga, NULL);
      ret = SVGA3D_BeginQuery(svga->swc, sq->type);
      assert(ret == PIPE_OK);
d218 1
a219 2
   svga->sq = sq;
}
d221 2
a222 2
static void svga_end_query(struct pipe_context *pipe, 
                           struct pipe_query *q)
a228 1
   assert(svga->sq == sq);
a230 3
   
   /* Set to PENDING before sending EndQuery. */
   sq->queryResult->state = SVGA3D_QUERYSTATE_PENDING;
d232 18
a249 2
   ret = SVGA3D_EndQuery( svga->swc, sq->type, sq->hwbuf);
   if(ret != PIPE_OK) {
d251 14
a264 2
      ret = SVGA3D_EndQuery( svga->swc, sq->type, sq->hwbuf);
      assert(ret == PIPE_OK);
a265 7
   
   /* TODO: Delay flushing. We don't really need to flush here, just ensure 
    * that there is one flush before svga_get_query_result attempts to get the
    * result */
   svga_context_flush(svga, NULL);

   svga->sq = NULL;
d268 6
a273 4
static boolean svga_get_query_result(struct pipe_context *pipe, 
                                     struct pipe_query *q,
                                     boolean wait,
                                     void *vresult)
d280 2
a281 2
   uint64_t *result = (uint64_t*)vresult;
   
d284 17
a300 5
   /* The query status won't be updated by the host unless 
    * SVGA_3D_CMD_WAIT_FOR_QUERY is emitted. Unfortunately this will cause a 
    * synchronous wait on the host */
   if(!sq->fence) {
      enum pipe_error ret;
d302 1
a302 5
      ret = SVGA3D_WaitForQuery( svga->swc, sq->type, sq->hwbuf);
      if(ret != PIPE_OK) {
         svga_context_flush(svga, NULL);
         ret = SVGA3D_WaitForQuery( svga->swc, sq->type, sq->hwbuf);
         assert(ret == PIPE_OK);
a303 5
   
      svga_context_flush(svga, &sq->fence);
      
      assert(sq->fence);
   }
a304 7
   state = sq->queryResult->state;
   if(state == SVGA3D_QUERYSTATE_PENDING) {
      if(!wait)
         return FALSE;
   
      sws->fence_finish(sws, sq->fence, 0);
      
d306 22
a329 5
   assert(state == SVGA3D_QUERYSTATE_SUCCEEDED || 
          state == SVGA3D_QUERYSTATE_FAILED);
   
   *result = (uint64_t)sq->queryResult->result32;

d336 2
a337 2

void svga_init_query_functions( struct svga_context *svga )
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d33 1
a33 1
#include "svga_screen_buffer.h"
d66 1
a66 1
                                     uint64_t *result);
d71 1
d84 1
a84 1
   sq->hwbuf = svga_winsys_buffer_create(svgascreen, 
d93 1
a93 1
                                                          PIPE_BUFFER_USAGE_CPU_WRITE);
d210 1
a210 1
                                     uint64_t *result)
d217 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d33 1
a33 1
#include "svga_resource_buffer.h"
d66 1
a66 1
                                     void *result);
a70 1
   struct svga_context *svga = svga_context( pipe );
d83 1
a83 1
   sq->hwbuf = svga_winsys_buffer_create(svga,
d92 1
a92 1
                                                          PIPE_TRANSFER_WRITE);
d209 1
a209 1
                                     void *vresult)
a215 1
   uint64_t *result = (uint64_t*)vresult;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a44 1

d47 1
a47 4
   unsigned type;                  /**< PIPE_QUERY_x or SVGA_QUERY_x */
   SVGA3dQueryType svga_type;      /**< SVGA3D_QUERYTYPE_x or unused */

   /** For PIPE_QUERY_OCCLUSION_COUNTER / SVGA3D_QUERYTYPE_OCCLUSION */
a50 3

   /** For non-GPU SVGA_QUERY_x queries */
   uint64_t begin_count, end_count;
d53 4
a56 2

/** cast wrapper */
d63 4
d68 2
a69 9
static boolean
svga_get_query_result(struct pipe_context *pipe,
                      struct pipe_query *q,
                      boolean wait,
                      union pipe_query_result *result);


static struct pipe_query *
svga_create_query( struct pipe_context *pipe, unsigned query_type )
d82 1
a82 31
   switch (query_type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      sq->svga_type = SVGA3D_QUERYTYPE_OCCLUSION;

      sq->hwbuf = svga_winsys_buffer_create(svga, 1,
                                            SVGA_BUFFER_USAGE_PINNED,
                                            sizeof *sq->queryResult);
      if (!sq->hwbuf)
         goto no_hwbuf;

      sq->queryResult = (SVGA3dQueryResult *)
         sws->buffer_map(sws, sq->hwbuf, PIPE_TRANSFER_WRITE);
      if (!sq->queryResult)
         goto no_query_result;

      sq->queryResult->totalSize = sizeof *sq->queryResult;
      sq->queryResult->state = SVGA3D_QUERYSTATE_NEW;

      /* We request the buffer to be pinned and assume it is always mapped.
       * The reason is that we don't want to wait for fences when checking the
       * query status.
       */
      sws->buffer_unmap(sws, sq->hwbuf);
      break;
   case SVGA_QUERY_DRAW_CALLS:
   case SVGA_QUERY_FALLBACKS:
   case SVGA_QUERY_MEMORY_USED:
      break;
   default:
      assert(!"unexpected query type in svga_create_query()");
   }
d84 23
a106 1
   sq->type = query_type;
d118 2
a119 3

static void
svga_destroy_query(struct pipe_context *pipe, struct pipe_query *q)
d126 2
a127 15

   switch (sq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      sws->buffer_destroy(sws, sq->hwbuf);
      sws->fence_reference(sws, &sq->fence, NULL);
      break;
   case SVGA_QUERY_DRAW_CALLS:
   case SVGA_QUERY_FALLBACKS:
   case SVGA_QUERY_MEMORY_USED:
      /* nothing */
      break;
   default:
      assert(!"svga: unexpected query type in svga_destroy_query()");
   }

d131 2
a132 3

static void
svga_begin_query(struct pipe_context *pipe, struct pipe_query *q)
d141 2
d148 10
d159 7
a165 15
   switch (sq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      assert(!svga->sq);
      if (sq->queryResult->state == SVGA3D_QUERYSTATE_PENDING) {
         /* The application doesn't care for the pending query result.
          * We cannot let go of the existing buffer and just get a new one
          * because its storage may be reused for other purposes and clobbered
          * by the host when it determines the query result.  So the only
          * option here is to wait for the existing query's result -- not a
          * big deal, given that no sane application would do this.
          */
         uint64_t result;
         svga_get_query_result(pipe, q, TRUE, (void*)&result);
         assert(sq->queryResult->state != SVGA3D_QUERYSTATE_PENDING);
      }
d167 6
a172 9
      sq->queryResult->state = SVGA3D_QUERYSTATE_NEW;
      sws->fence_reference(sws, &sq->fence, NULL);

      ret = SVGA3D_BeginQuery(svga->swc, sq->svga_type);
      if (ret != PIPE_OK) {
         svga_context_flush(svga, NULL);
         ret = SVGA3D_BeginQuery(svga->swc, sq->svga_type);
         assert(ret == PIPE_OK);
      }
d174 1
a174 14
      svga->sq = sq;
      break;
   case SVGA_QUERY_DRAW_CALLS:
      sq->begin_count = svga->num_draw_calls;
      break;
   case SVGA_QUERY_FALLBACKS:
      sq->begin_count = svga->num_fallbacks;
      break;
   case SVGA_QUERY_MEMORY_USED:
      /* nothing */
      break;
   default:
      assert(!"unexpected query type in svga_begin_query()");
   }
d177 2
a178 3

static void
svga_end_query(struct pipe_context *pipe, struct pipe_query *q)
d185 1
d188 3
d192 2
a193 18
   switch (sq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      assert(svga->sq == sq);

      /* Set to PENDING before sending EndQuery. */
      sq->queryResult->state = SVGA3D_QUERYSTATE_PENDING;

      ret = SVGA3D_EndQuery( svga->swc, sq->svga_type, sq->hwbuf);
      if (ret != PIPE_OK) {
         svga_context_flush(svga, NULL);
         ret = SVGA3D_EndQuery( svga->swc, sq->svga_type, sq->hwbuf);
         assert(ret == PIPE_OK);
      }

      /* TODO: Delay flushing. We don't really need to flush here, just ensure
       * that there is one flush before svga_get_query_result attempts to get
       * the result.
       */
d195 2
a196 14

      svga->sq = NULL;
      break;
   case SVGA_QUERY_DRAW_CALLS:
      sq->end_count = svga->num_draw_calls;
      break;
   case SVGA_QUERY_FALLBACKS:
      sq->end_count = svga->num_fallbacks;
      break;
   case SVGA_QUERY_MEMORY_USED:
      /* nothing */
      break;
   default:
      assert(!"unexpected query type in svga_end_query()");
d198 7
d207 4
a210 6

static boolean
svga_get_query_result(struct pipe_context *pipe,
                      struct pipe_query *q,
                      boolean wait,
                      union pipe_query_result *vresult)
d217 2
a218 2
   uint64_t *result = (uint64_t *) vresult;

d221 5
a225 8
   switch (sq->type) {
   case PIPE_QUERY_OCCLUSION_COUNTER:
      /* The query status won't be updated by the host unless
       * SVGA_3D_CMD_WAIT_FOR_QUERY is emitted. Unfortunately this will cause
       * a synchronous wait on the host.
       */
      if (!sq->fence) {
         enum pipe_error ret;
d227 5
a231 10
         ret = SVGA3D_WaitForQuery( svga->swc, sq->svga_type, sq->hwbuf);
         if (ret != PIPE_OK) {
            svga_context_flush(svga, NULL);
            ret = SVGA3D_WaitForQuery( svga->swc, sq->svga_type, sq->hwbuf);
            assert(ret == PIPE_OK);
         }

         svga_context_flush(svga, &sq->fence);

         assert(sq->fence);
d233 5
d239 7
d247 1
a247 6
      if (state == SVGA3D_QUERYSTATE_PENDING) {
         if (!wait)
            return FALSE;
         sws->fence_finish(sws, sq->fence, SVGA_FENCE_FLAG_QUERY);
         state = sq->queryResult->state;
      }
d249 4
a252 16
      assert(state == SVGA3D_QUERYSTATE_SUCCEEDED ||
             state == SVGA3D_QUERYSTATE_FAILED);

      *result = (uint64_t) sq->queryResult->result32;
      break;
   case SVGA_QUERY_DRAW_CALLS:
      /* fall-through */
   case SVGA_QUERY_FALLBACKS:
      vresult->u64 = sq->end_count - sq->begin_count;
      break;
   case SVGA_QUERY_MEMORY_USED:
      vresult->u64 = svgascreen->total_resource_bytes;
      break;
   default:
      assert(!"unexpected query type in svga_get_query_result");
   }
d260 2
a261 2
void
svga_init_query_functions(struct svga_context *svga)
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d97 1
a97 2
      if (!sq->hwbuf) {
         debug_printf("svga: failed to alloc query object!\n");
a98 1
      }
d102 1
a102 2
      if (!sq->queryResult) {
         debug_printf("svga: failed to map query object!\n");
a103 1
      }
a146 1
      sq->hwbuf = NULL;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d77 1
a77 3
svga_create_query(struct pipe_context *pipe,
                  unsigned query_type,
                  unsigned index)
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d77 3
a79 1
svga_create_query( struct pipe_context *pipe, unsigned query_type )
@


