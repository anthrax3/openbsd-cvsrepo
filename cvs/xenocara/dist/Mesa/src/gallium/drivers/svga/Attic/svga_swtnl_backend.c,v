head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.14.01.11;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.01;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "draw/draw_vbuf.h"
#include "draw/draw_context.h"
#include "draw/draw_vertex.h"

#include "util/u_debug.h"
#include "util/u_inlines.h"
#include "util/u_math.h"
#include "util/u_memory.h"

#include "svga_context.h"
#include "svga_state.h"
#include "svga_swtnl.h"

#include "svga_types.h"
#include "svga_reg.h"
#include "svga3d_reg.h"
#include "svga_draw.h"
#include "svga_swtnl_private.h"


static const struct vertex_info *
svga_vbuf_render_get_vertex_info( struct vbuf_render *render )
{
   struct svga_vbuf_render *svga_render = svga_vbuf_render(render);
   struct svga_context *svga = svga_render->svga;

   svga_swtnl_update_vdecl(svga);

   return &svga_render->vertex_info;
}


static boolean
svga_vbuf_render_allocate_vertices( struct vbuf_render *render,
                                    ushort vertex_size,
                                    ushort nr_vertices )
{
   struct svga_vbuf_render *svga_render = svga_vbuf_render(render);
   struct svga_context *svga = svga_render->svga;
   struct pipe_screen *screen = svga->pipe.screen;
   size_t size = (size_t)nr_vertices * (size_t)vertex_size;
   boolean new_vbuf = FALSE;
   boolean new_ibuf = FALSE;

   if (svga_render->vertex_size != vertex_size)
      svga->swtnl.new_vdecl = TRUE;
   svga_render->vertex_size = (size_t)vertex_size;

   if (svga->swtnl.new_vbuf)
      new_ibuf = new_vbuf = TRUE;
   svga->swtnl.new_vbuf = FALSE;

   if (svga_render->vbuf_size < svga_render->vbuf_offset + svga_render->vbuf_used + size)
      new_vbuf = TRUE;

   if (new_vbuf)
      pipe_resource_reference(&svga_render->vbuf, NULL);
   if (new_ibuf)
      pipe_resource_reference(&svga_render->ibuf, NULL);

   if (!svga_render->vbuf) {
      svga_render->vbuf_size = MAX2(size, svga_render->vbuf_alloc_size);
      svga_render->vbuf = pipe_buffer_create(screen,
                                             PIPE_BIND_VERTEX_BUFFER,
                                             PIPE_USAGE_STREAM,
                                             svga_render->vbuf_size);
      if(!svga_render->vbuf) {
         svga_context_flush(svga, NULL);
         assert(!svga_render->vbuf);
         svga_render->vbuf = pipe_buffer_create(screen,
                                                PIPE_BIND_VERTEX_BUFFER,
                                                PIPE_USAGE_STREAM,
                                                svga_render->vbuf_size);
         /* The buffer allocation may fail if we run out of memory.
          * The draw module's vbuf code should handle that without crashing.
          */
      }

      svga->swtnl.new_vdecl = TRUE;
      svga_render->vbuf_offset = 0;
   } else {
      svga_render->vbuf_offset += svga_render->vbuf_used;
   }

   svga_render->vbuf_used = 0;

   if (svga->swtnl.new_vdecl)
      svga_render->vdecl_offset = svga_render->vbuf_offset;

   return TRUE;
}

static void *
svga_vbuf_render_map_vertices( struct vbuf_render *render )
{
   struct svga_vbuf_render *svga_render = svga_vbuf_render(render);
   struct svga_context *svga = svga_render->svga;

   if (svga_render->vbuf) {
      char *ptr = (char*)pipe_buffer_map(&svga->pipe,
                                         svga_render->vbuf,
                                         PIPE_TRANSFER_WRITE |
                                         PIPE_TRANSFER_FLUSH_EXPLICIT |
                                         PIPE_TRANSFER_DISCARD_RANGE |
                                         PIPE_TRANSFER_UNSYNCHRONIZED,
                                         &svga_render->vbuf_transfer);
      if (ptr)
         return ptr + svga_render->vbuf_offset;
      else {
         svga_render->vbuf_transfer = NULL;
         return NULL;
      }
   }
   else {
      /* we probably ran out of memory when allocating the vertex buffer */
      return NULL;
   }
}

static void
svga_vbuf_render_unmap_vertices( struct vbuf_render *render,
                                 ushort min_index,
                                 ushort max_index )
{
   struct svga_vbuf_render *svga_render = svga_vbuf_render(render);
   struct svga_context *svga = svga_render->svga;
   unsigned offset, length;
   size_t used = svga_render->vertex_size * ((size_t)max_index + 1);

   offset = svga_render->vbuf_offset + svga_render->vertex_size * min_index;
   length = svga_render->vertex_size * (max_index + 1 - min_index);
   pipe_buffer_flush_mapped_range(&svga->pipe,
				  svga_render->vbuf_transfer,
				  offset, length);
   pipe_buffer_unmap(&svga->pipe, svga_render->vbuf_transfer);
   svga_render->min_index = min_index;
   svga_render->max_index = max_index;
   svga_render->vbuf_used = MAX2(svga_render->vbuf_used, used);
}

static void
svga_vbuf_render_set_primitive( struct vbuf_render *render,
                                unsigned prim )
{
   struct svga_vbuf_render *svga_render = svga_vbuf_render(render);
   svga_render->prim = prim;
}

static void
svga_vbuf_submit_state( struct svga_vbuf_render *svga_render )
{
   struct svga_context *svga = svga_render->svga;
   SVGA3dVertexDecl vdecl[PIPE_MAX_ATTRIBS];
   enum pipe_error ret;
   unsigned i;

   /* if the vdecl or vbuf hasn't changed do nothing */
   if (!svga->swtnl.new_vdecl)
      return;

   memcpy(vdecl, svga_render->vdecl, sizeof(vdecl));

   /* flush the hw state */
   ret = svga_hwtnl_flush(svga->hwtnl);
   if (ret != PIPE_OK) {
      svga_context_flush(svga, NULL);
      ret = svga_hwtnl_flush(svga->hwtnl);
      /* if we hit this path we might become synced with hw */
      svga->swtnl.new_vbuf = TRUE;
      assert(ret == 0);
   }

   svga_hwtnl_reset_vdecl(svga->hwtnl, svga_render->vdecl_count);

   for (i = 0; i < svga_render->vdecl_count; i++) {
      vdecl[i].array.offset += svga_render->vdecl_offset;

      svga_hwtnl_vdecl( svga->hwtnl,
                        i,
                        &vdecl[i],
                        svga_render->vbuf );
   }

   /* We have already taken care of flatshading, so let the hwtnl
    * module use whatever is most convenient:
    */
   if (svga->state.sw.need_pipeline) {
      svga_hwtnl_set_flatshade(svga->hwtnl, FALSE, FALSE);
      svga_hwtnl_set_unfilled(svga->hwtnl, PIPE_POLYGON_MODE_FILL);
   }
   else {
      svga_hwtnl_set_flatshade( svga->hwtnl,
                                svga->curr.rast->templ.flatshade,
                                svga->curr.rast->templ.flatshade_first );

      svga_hwtnl_set_unfilled( svga->hwtnl,
                               svga->curr.rast->hw_unfilled );
   }

   svga->swtnl.new_vdecl = FALSE;
}

static void
svga_vbuf_render_draw_arrays( struct vbuf_render *render,
                              unsigned start,
                              uint nr )
{
   struct svga_vbuf_render *svga_render = svga_vbuf_render(render);
   struct svga_context *svga = svga_render->svga;
   unsigned bias = (svga_render->vbuf_offset - svga_render->vdecl_offset) / svga_render->vertex_size;
   enum pipe_error ret = PIPE_OK;

   /* off to hardware */
   svga_vbuf_submit_state(svga_render);

   /* Need to call update_state() again as the draw module may have
    * altered some of our state behind our backs.  Testcase:
    * redbook/polys.c
    */
   svga_update_state_retry( svga, SVGA_STATE_HW_DRAW );

   ret = svga_hwtnl_draw_arrays(svga->hwtnl, svga_render->prim, start + bias, nr);
   if (ret != PIPE_OK) {
      svga_context_flush(svga, NULL);
      ret = svga_hwtnl_draw_arrays(svga->hwtnl, svga_render->prim, start + bias, nr);
      svga->swtnl.new_vbuf = TRUE;
      assert(ret == PIPE_OK);
   }
}


static void
svga_vbuf_render_draw_elements( struct vbuf_render *render,
                                const ushort *indices,
                                uint nr_indices)
{
   struct svga_vbuf_render *svga_render = svga_vbuf_render(render);
   struct svga_context *svga = svga_render->svga;
   struct pipe_screen *screen = svga->pipe.screen;
   int bias = (svga_render->vbuf_offset - svga_render->vdecl_offset) / svga_render->vertex_size;
   boolean ret;
   size_t size = 2 * nr_indices;

   assert(( svga_render->vbuf_offset - svga_render->vdecl_offset) % svga_render->vertex_size == 0);
   
   if (svga_render->ibuf_size < svga_render->ibuf_offset + size)
      pipe_resource_reference(&svga_render->ibuf, NULL);

   if (!svga_render->ibuf) {
      svga_render->ibuf_size = MAX2(size, svga_render->ibuf_alloc_size);
      svga_render->ibuf = pipe_buffer_create(screen,
                                             PIPE_BIND_INDEX_BUFFER,
                                             PIPE_USAGE_STREAM,
                                             svga_render->ibuf_size);
      svga_render->ibuf_offset = 0;
   }

   pipe_buffer_write_nooverlap(&svga->pipe, svga_render->ibuf,
			       svga_render->ibuf_offset, 2 * nr_indices, indices);

   /* off to hardware */
   svga_vbuf_submit_state(svga_render);

   /* Need to call update_state() again as the draw module may have
    * altered some of our state behind our backs.  Testcase:
    * redbook/polys.c
    */
   svga_update_state_retry( svga, SVGA_STATE_HW_DRAW );

   ret = svga_hwtnl_draw_range_elements(svga->hwtnl,
                                        svga_render->ibuf,
                                        2,
                                        bias,
                                        svga_render->min_index,
                                        svga_render->max_index,
                                        svga_render->prim,
                                        svga_render->ibuf_offset / 2, nr_indices);
   if(ret != PIPE_OK) {
      svga_context_flush(svga, NULL);
      ret = svga_hwtnl_draw_range_elements(svga->hwtnl,
                                           svga_render->ibuf,
                                           2,
                                           bias,
                                           svga_render->min_index,
                                           svga_render->max_index,
                                           svga_render->prim,
                                           svga_render->ibuf_offset / 2, nr_indices);
      svga->swtnl.new_vbuf = TRUE;
      assert(ret == PIPE_OK);
   }

   svga_render->ibuf_offset += size;
}


static void
svga_vbuf_render_release_vertices( struct vbuf_render *render )
{

}


static void
svga_vbuf_render_destroy( struct vbuf_render *render )
{
   struct svga_vbuf_render *svga_render = svga_vbuf_render(render);

   pipe_resource_reference(&svga_render->vbuf, NULL);
   pipe_resource_reference(&svga_render->ibuf, NULL);
   FREE(svga_render);
}


/**
 * Create a new primitive render.
 */
struct vbuf_render *
svga_vbuf_render_create( struct svga_context *svga )
{
   struct svga_vbuf_render *svga_render = CALLOC_STRUCT(svga_vbuf_render);

   svga_render->svga = svga;
   svga_render->ibuf_size = 0;
   svga_render->vbuf_size = 0;
   svga_render->ibuf_alloc_size = 4*1024;
   svga_render->vbuf_alloc_size = 64*1024;
   svga_render->base.max_vertex_buffer_bytes = 64*1024/10;
   svga_render->base.max_indices = 65536;
   svga_render->base.get_vertex_info = svga_vbuf_render_get_vertex_info;
   svga_render->base.allocate_vertices = svga_vbuf_render_allocate_vertices;
   svga_render->base.map_vertices = svga_vbuf_render_map_vertices;
   svga_render->base.unmap_vertices = svga_vbuf_render_unmap_vertices;
   svga_render->base.set_primitive = svga_vbuf_render_set_primitive;
   svga_render->base.draw_elements = svga_vbuf_render_draw_elements;
   svga_render->base.draw_arrays = svga_vbuf_render_draw_arrays;
   svga_render->base.release_vertices = svga_vbuf_render_release_vertices;
   svga_render->base.destroy = svga_vbuf_render_destroy;

   return &svga_render->base;
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d99 3
a101 1
         assert(svga_render->vbuf);
d124 19
a142 8
   char *ptr = (char*)pipe_buffer_map(&svga->pipe,
                                      svga_render->vbuf,
                                      PIPE_TRANSFER_WRITE | 
                                      PIPE_TRANSFER_FLUSH_EXPLICIT |
                                      PIPE_TRANSFER_DISCARD |
                                      PIPE_TRANSFER_UNSYNCHRONIZED,
				      &svga_render->vbuf_transfer);
   return ptr + svga_render->vbuf_offset;
d166 1
a166 1
static boolean
a171 2

   return TRUE;
d180 1
a180 1
   int i;
d190 1
a190 1
   if (ret) {
d236 1
a236 1
   enum pipe_error ret = 0;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d90 1
d94 1
d97 1
d147 1
a147 1
   pipe_buffer_unmap(&svga->pipe, svga_render->vbuf, svga_render->vbuf_transfer);
d164 1
a164 1
svga_vbuf_sumbit_state( struct svga_vbuf_render *svga_render )
d227 2
a228 1
   svga_vbuf_sumbit_state(svga_render);
d267 1
a274 1

d276 1
a276 1
   svga_vbuf_sumbit_state(svga_render);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d82 1
a82 1
      pipe_buffer_reference(&svga_render->vbuf, NULL);
d84 1
a84 1
      pipe_buffer_reference(&svga_render->ibuf, NULL);
d89 1
a89 2
                                             16,
                                             PIPE_BUFFER_USAGE_VERTEX,
d94 1
a94 2
                                                16,
                                                PIPE_BUFFER_USAGE_VERTEX,
a117 1
   struct pipe_screen *screen = svga->pipe.screen;
d119 1
a119 1
   char *ptr = (char*)pipe_buffer_map(screen,
d121 5
a125 4
                                      PIPE_BUFFER_USAGE_CPU_WRITE | 
                                      PIPE_BUFFER_USAGE_FLUSH_EXPLICIT |
                                      PIPE_BUFFER_USAGE_DISCARD |
                                      PIPE_BUFFER_USAGE_UNSYNCHRONIZED);
a135 1
   struct pipe_screen *screen = svga->pipe.screen;
d141 4
a144 2
   pipe_buffer_flush_mapped_range(screen, svga_render->vbuf, offset, length);
   pipe_buffer_unmap(screen, svga_render->vbuf);
d243 3
a245 3
svga_vbuf_render_draw( struct vbuf_render *render,
                       const ushort *indices,
                       uint nr_indices)
d250 1
a250 1
   unsigned bias = (svga_render->vbuf_offset - svga_render->vdecl_offset) / svga_render->vertex_size;
d257 1
a257 1
      pipe_buffer_reference(&svga_render->ibuf, NULL);
d262 1
a262 2
                                             2,
                                             PIPE_BUFFER_USAGE_VERTEX,
d267 2
a268 2
   pipe_buffer_write_nooverlap(screen, svga_render->ibuf,
                                 svga_render->ibuf_offset, 2 * nr_indices, indices);
d283 1
d287 1
a287 1
                                        svga_render->ibuf_offset / 2, nr_indices, bias);
d293 1
d297 1
a297 1
                                           svga_render->ibuf_offset / 2, nr_indices, bias);
d318 2
a319 2
   pipe_buffer_reference(&svga_render->vbuf, NULL);
   pipe_buffer_reference(&svga_render->ibuf, NULL);
d344 1
a344 1
   svga_render->base.draw = svga_vbuf_render_draw;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d82 1
a82 1
      pipe_resource_reference(&svga_render->vbuf, NULL);
d84 1
a84 1
      pipe_resource_reference(&svga_render->ibuf, NULL);
d89 2
a90 1
                                             PIPE_BIND_VERTEX_BUFFER,
d95 2
a96 1
                                                PIPE_BIND_VERTEX_BUFFER,
d120 1
d122 1
a122 1
   char *ptr = (char*)pipe_buffer_map(&svga->pipe,
d124 4
a127 5
                                      PIPE_TRANSFER_WRITE | 
                                      PIPE_TRANSFER_FLUSH_EXPLICIT |
                                      PIPE_TRANSFER_DISCARD |
                                      PIPE_TRANSFER_UNSYNCHRONIZED,
				      &svga_render->vbuf_transfer);
d138 1
d144 2
a145 4
   pipe_buffer_flush_mapped_range(&svga->pipe,
				  svga_render->vbuf_transfer,
				  offset, length);
   pipe_buffer_unmap(&svga->pipe, svga_render->vbuf, svga_render->vbuf_transfer);
d244 3
a246 3
svga_vbuf_render_draw_elements( struct vbuf_render *render,
                                const ushort *indices,
                                uint nr_indices)
d251 1
a251 1
   int bias = (svga_render->vbuf_offset - svga_render->vdecl_offset) / svga_render->vertex_size;
d258 1
a258 1
      pipe_resource_reference(&svga_render->ibuf, NULL);
d263 2
a264 1
                                             PIPE_BIND_INDEX_BUFFER,
d269 2
a270 2
   pipe_buffer_write_nooverlap(&svga->pipe, svga_render->ibuf,
			       svga_render->ibuf_offset, 2 * nr_indices, indices);
a284 1
                                        bias,
d288 1
a288 1
                                        svga_render->ibuf_offset / 2, nr_indices);
a293 1
                                           bias,
d297 1
a297 1
                                           svga_render->ibuf_offset / 2, nr_indices);
d318 2
a319 2
   pipe_resource_reference(&svga_render->vbuf, NULL);
   pipe_resource_reference(&svga_render->ibuf, NULL);
d344 1
a344 1
   svga_render->base.draw_elements = svga_vbuf_render_draw_elements;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a89 1
                                             PIPE_USAGE_STREAM,
a92 1
         assert(!svga_render->vbuf);
a94 1
                                                PIPE_USAGE_STREAM,
d96 1
a96 3
         /* The buffer allocation may fail if we run out of memory.
          * The draw module's vbuf code should handle that without crashing.
          */
d119 8
a126 19
   if (svga_render->vbuf) {
      char *ptr = (char*)pipe_buffer_map(&svga->pipe,
                                         svga_render->vbuf,
                                         PIPE_TRANSFER_WRITE |
                                         PIPE_TRANSFER_FLUSH_EXPLICIT |
                                         PIPE_TRANSFER_DISCARD_RANGE |
                                         PIPE_TRANSFER_UNSYNCHRONIZED,
                                         &svga_render->vbuf_transfer);
      if (ptr)
         return ptr + svga_render->vbuf_offset;
      else {
         svga_render->vbuf_transfer = NULL;
         return NULL;
      }
   }
   else {
      /* we probably ran out of memory when allocating the vertex buffer */
      return NULL;
   }
d144 1
a144 1
   pipe_buffer_unmap(&svga->pipe, svga_render->vbuf_transfer);
d150 1
a150 1
static void
d156 2
d161 1
a161 1
svga_vbuf_submit_state( struct svga_vbuf_render *svga_render )
d166 1
a166 1
   unsigned i;
d176 1
a176 1
   if (ret != PIPE_OK) {
d222 1
a222 1
   enum pipe_error ret = PIPE_OK;
d224 1
a224 2
   /* off to hardware */
   svga_vbuf_submit_state(svga_render);
a262 1
                                             PIPE_USAGE_STREAM,
d270 1
d272 1
a272 1
   svga_vbuf_submit_state(svga_render);
@


