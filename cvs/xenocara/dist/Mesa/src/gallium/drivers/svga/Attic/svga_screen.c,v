head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.10;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.53;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.08;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_string.h"
#include "util/u_math.h"

#include "svga_winsys.h"
#include "svga_public.h"
#include "svga_context.h"
#include "svga_format.h"
#include "svga_screen.h"
#include "svga_resource_texture.h"
#include "svga_resource.h"
#include "svga_debug.h"

#include "svga3d_shaderdefs.h"


#ifdef DEBUG
int SVGA_DEBUG = 0;

static const struct debug_named_value svga_debug_flags[] = {
   { "dma",      DEBUG_DMA, NULL },
   { "tgsi",     DEBUG_TGSI, NULL },
   { "pipe",     DEBUG_PIPE, NULL },
   { "state",    DEBUG_STATE, NULL },
   { "screen",   DEBUG_SCREEN, NULL },
   { "tex",      DEBUG_TEX, NULL },
   { "swtnl",    DEBUG_SWTNL, NULL },
   { "const",    DEBUG_CONSTS, NULL },
   { "viewport", DEBUG_VIEWPORT, NULL },
   { "views",    DEBUG_VIEWS, NULL },
   { "perf",     DEBUG_PERF, NULL },
   { "flush",    DEBUG_FLUSH, NULL },
   { "sync",     DEBUG_SYNC, NULL },
   { "cache",    DEBUG_CACHE, NULL },
   DEBUG_NAMED_VALUE_END
};
#endif

static const char *
svga_get_vendor( struct pipe_screen *pscreen )
{
   return "VMware, Inc.";
}


static const char *
svga_get_name( struct pipe_screen *pscreen )
{
   const char *build = "", *llvm = "", *mutex = "";
   static char name[100];
#ifdef DEBUG
   /* Only return internal details in the DEBUG version:
    */
   build = "build: DEBUG;";
   mutex = "mutex: " PIPE_ATOMIC ";";
#ifdef HAVE_LLVM
   llvm = "LLVM;";
#endif
#else
   build = "build: RELEASE;";
#endif

   util_snprintf(name, sizeof(name), "SVGA3D; %s %s %s", build, mutex, llvm);
   return name;
}




static float
svga_get_paramf(struct pipe_screen *screen, enum pipe_capf param)
{
   struct svga_screen *svgascreen = svga_screen(screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   SVGA3dDevCapResult result;

   switch (param) {
   case PIPE_CAPF_MAX_LINE_WIDTH:
      return svgascreen->maxLineWidth;
   case PIPE_CAPF_MAX_LINE_WIDTH_AA:
      return svgascreen->maxLineWidthAA;

   case PIPE_CAPF_MAX_POINT_WIDTH:
      /* fall-through */
   case PIPE_CAPF_MAX_POINT_WIDTH_AA:
      return svgascreen->maxPointSize;

   case PIPE_CAPF_MAX_TEXTURE_ANISOTROPY:
      if(!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_TEXTURE_ANISOTROPY, &result))
         return 4.0f;
      return (float) result.u;

   case PIPE_CAPF_MAX_TEXTURE_LOD_BIAS:
      return 15.0;
   case PIPE_CAPF_GUARD_BAND_LEFT:
   case PIPE_CAPF_GUARD_BAND_TOP:
   case PIPE_CAPF_GUARD_BAND_RIGHT:
   case PIPE_CAPF_GUARD_BAND_BOTTOM:
      return 0.0;
   }

   debug_printf("Unexpected PIPE_CAPF_ query %u\n", param);
   return 0;
}


static int
svga_get_param(struct pipe_screen *screen, enum pipe_cap param)
{
   struct svga_screen *svgascreen = svga_screen(screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   SVGA3dDevCapResult result;

   switch (param) {
   case PIPE_CAP_NPOT_TEXTURES:
   case PIPE_CAP_MIXED_FRAMEBUFFER_SIZES:
      return 1;
   case PIPE_CAP_TWO_SIDED_STENCIL:
      return 1;
   case PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS:
      return 0;
   case PIPE_CAP_ANISOTROPIC_FILTER:
      return 1;
   case PIPE_CAP_POINT_SPRITE:
      return 1;
   case PIPE_CAP_TGSI_TEXCOORD:
      return 0;
   case PIPE_CAP_MAX_RENDER_TARGETS:
      return svgascreen->max_color_buffers;
   case PIPE_CAP_OCCLUSION_QUERY:
      return 1;
   case PIPE_CAP_QUERY_TIME_ELAPSED:
      return 0;
   case PIPE_CAP_TEXTURE_SHADOW_MAP:
      return 1;
   case PIPE_CAP_TEXTURE_SWIZZLE:
      return 1;
   case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
      return 0;
   case PIPE_CAP_USER_VERTEX_BUFFERS:
   case PIPE_CAP_USER_INDEX_BUFFERS:
      return 0;
   case PIPE_CAP_USER_CONSTANT_BUFFERS:
      return 1;
   case PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT:
      return 16;

   case PIPE_CAP_MAX_TEXTURE_2D_LEVELS:
      {
         unsigned levels = SVGA_MAX_TEXTURE_LEVELS;
         if (sws->get_cap(sws, SVGA3D_DEVCAP_MAX_TEXTURE_WIDTH, &result))
            levels = MIN2(util_logbase2(result.u) + 1, levels);
         else
            levels = 12 /* 2048x2048 */;
         if (sws->get_cap(sws, SVGA3D_DEVCAP_MAX_TEXTURE_HEIGHT, &result))
            levels = MIN2(util_logbase2(result.u) + 1, levels);
         else
            levels = 12 /* 2048x2048 */;
         return levels;
      }

   case PIPE_CAP_MAX_TEXTURE_3D_LEVELS:
      if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_VOLUME_EXTENT, &result))
         return 8;  /* max 128x128x128 */
      return MIN2(util_logbase2(result.u) + 1, SVGA_MAX_TEXTURE_LEVELS);

   case PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS:
      /*
       * No mechanism to query the host, and at least limited to 2048x2048 on
       * certain hardware.
       */
      return MIN2(screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS),
                  12 /* 2048x2048 */);

   case PIPE_CAP_BLEND_EQUATION_SEPARATE: /* req. for GL 1.5 */
      return 1;

   case PIPE_CAP_TGSI_FS_COORD_ORIGIN_UPPER_LEFT:
      return 1;
   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
      return 0;
   case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
      return 0;
   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
      return 1;

   case PIPE_CAP_VERTEX_COLOR_UNCLAMPED:
      return 1; /* The color outputs of vertex shaders are not clamped */
   case PIPE_CAP_VERTEX_COLOR_CLAMPED:
      return 0; /* The driver can't clamp vertex colors */
   case PIPE_CAP_FRAGMENT_COLOR_CLAMPED:
      return 0; /* The driver can't clamp fragment colors */

   case PIPE_CAP_MIXED_COLORBUFFER_FORMATS:
      return 1; /* expected for GL_ARB_framebuffer_object */

   case PIPE_CAP_GLSL_FEATURE_LEVEL:
      return 120;

   case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
      return 0;

   case PIPE_CAP_SM3:
      return 1;

   /* Unsupported features */
   case PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION:
   case PIPE_CAP_TEXTURE_MIRROR_CLAMP:
   case PIPE_CAP_SHADER_STENCIL_EXPORT:
   case PIPE_CAP_DEPTH_CLIP_DISABLE:
   case PIPE_CAP_SEAMLESS_CUBE_MAP:
   case PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE:
   case PIPE_CAP_INDEP_BLEND_ENABLE:
   case PIPE_CAP_INDEP_BLEND_FUNC:
   case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
   case PIPE_CAP_PRIMITIVE_RESTART:
   case PIPE_CAP_TGSI_INSTANCEID:
   case PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR:
   case PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS:
   case PIPE_CAP_MIN_TEXEL_OFFSET:
   case PIPE_CAP_MAX_TEXEL_OFFSET:
   case PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET:
   case PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET:
   case PIPE_CAP_CONDITIONAL_RENDER:
   case PIPE_CAP_TEXTURE_BARRIER:
   case PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS:
   case PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS:
   case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
   case PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES:
   case PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS:
   case PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS:
   case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_COMPUTE:
   case PIPE_CAP_START_INSTANCE:
   case PIPE_CAP_QUERY_TIMESTAMP:
   case PIPE_CAP_TEXTURE_MULTISAMPLE:
   case PIPE_CAP_CUBE_MAP_ARRAY:
   case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
   case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
   case PIPE_CAP_QUERY_PIPELINE_STATISTICS:
   case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
   case PIPE_CAP_TGSI_VS_LAYER:
   case PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS:
   case PIPE_CAP_TEXTURE_GATHER_SM5:
   case PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT:
   case PIPE_CAP_FAKE_SW_MSAA:
   case PIPE_CAP_TEXTURE_QUERY_LOD:
   case PIPE_CAP_SAMPLE_SHADING:
      return 0;
   case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
      return 64;
   case PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY:
      return 1;
   case PIPE_CAP_MAX_VIEWPORTS:
      return 1;
   case PIPE_CAP_ENDIANNESS:
      return PIPE_ENDIAN_LITTLE;
   }

   debug_printf("Unexpected PIPE_CAP_ query %u\n", param);
   return 0;
}

static int svga_get_shader_param(struct pipe_screen *screen, unsigned shader, enum pipe_shader_cap param)
{
   struct svga_screen *svgascreen = svga_screen(screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   SVGA3dDevCapResult result;

   switch (shader)
   {
   case PIPE_SHADER_FRAGMENT:
      switch (param)
      {
      case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
         return 512;
      case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
         return SVGA3D_MAX_NESTING_LEVEL;
      case PIPE_SHADER_CAP_MAX_INPUTS:
         return 10;
      case PIPE_SHADER_CAP_MAX_CONSTS:
         return 224;
      case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
         return 1;
      case PIPE_SHADER_CAP_MAX_TEMPS:
         if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_FRAGMENT_SHADER_TEMPS, &result))
            return 32;
         return MIN2(result.u, SVGA3D_TEMPREG_MAX);
      case PIPE_SHADER_CAP_MAX_ADDRS:
      case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
	 /* 
	  * Although PS 3.0 has some addressing abilities it can only represent
	  * loops that can be statically determined and unrolled. Given we can
	  * only handle a subset of the cases that the state tracker already
	  * does it is better to defer loop unrolling to the state tracker.
	  */
         return 0;
      case PIPE_SHADER_CAP_MAX_PREDS:
         return 1;
      case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
         return 0;
      case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
         return 0;
      case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
      case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
      case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
         return 0;
      case PIPE_SHADER_CAP_SUBROUTINES:
         return 0;
      case PIPE_SHADER_CAP_INTEGERS:
         return 0;
      case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
      case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
         return 16;
      default:
         debug_printf("Unexpected fragment shader query %u\n", param);
         return 0;
      }
      break;
   case PIPE_SHADER_VERTEX:
      switch (param)
      {
      case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
         if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_VERTEX_SHADER_INSTRUCTIONS, &result))
            return 512;
         return result.u;
      case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
         /* XXX: until we have vertex texture support */
         return 0;
      case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
         return SVGA3D_MAX_NESTING_LEVEL;
      case PIPE_SHADER_CAP_MAX_INPUTS:
         return 16;
      case PIPE_SHADER_CAP_MAX_CONSTS:
         return 256;
      case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
         return 1;
      case PIPE_SHADER_CAP_MAX_TEMPS:
         if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_VERTEX_SHADER_TEMPS, &result))
            return 32;
         return MIN2(result.u, SVGA3D_TEMPREG_MAX);
      case PIPE_SHADER_CAP_MAX_ADDRS:
         return 1;
      case PIPE_SHADER_CAP_MAX_PREDS:
         return 1;
      case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
         return 0;
      case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
         return 0;
      case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
      case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
         return 1;
      case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
         return 0;
      case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
         return 1;
      case PIPE_SHADER_CAP_SUBROUTINES:
         return 0;
      case PIPE_SHADER_CAP_INTEGERS:
         return 0;
      case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
      case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
         return 0;
      default:
         debug_printf("Unexpected vertex shader query %u\n", param);
         return 0;
      }
      break;
   case PIPE_SHADER_GEOMETRY:
   case PIPE_SHADER_COMPUTE:
      /* no support for geometry or compute shaders at this time */
      return 0;
   default:
      debug_printf("Unexpected shader type (%u) query\n", shader);
      return 0;
   }
   return 0;
}


/**
 * Implemnt pipe_screen::is_format_supported().
 * \param bindings  bitmask of PIPE_BIND_x flags
 */
static boolean
svga_is_format_supported( struct pipe_screen *screen,
                          enum pipe_format format,
                          enum pipe_texture_target target,
                          unsigned sample_count,
                          unsigned bindings)
{
   struct svga_screen *ss = svga_screen(screen);
   SVGA3dSurfaceFormat svga_format;
   SVGA3dSurfaceFormatCaps caps;
   SVGA3dSurfaceFormatCaps mask;

   assert(bindings);

   if (sample_count > 1) {
      return FALSE;
   }

   svga_format = svga_translate_format(ss, format, bindings);
   if (svga_format == SVGA3D_FORMAT_INVALID) {
      return FALSE;
   }

   /*
    * Override host capabilities, so that we end up with the same
    * visuals for all virtual hardware implementations.
    */

   if (bindings & PIPE_BIND_DISPLAY_TARGET) {
      switch (svga_format) {
      case SVGA3D_A8R8G8B8:
      case SVGA3D_X8R8G8B8:
      case SVGA3D_R5G6B5:
         break;

      /* Often unsupported/problematic. This means we end up with the same
       * visuals for all virtual hardware implementations.
       */
      case SVGA3D_A4R4G4B4:
      case SVGA3D_A1R5G5B5:
         return FALSE;
         
      default:
         return FALSE;
      }
   }
   
   /*
    * Query the host capabilities.
    */

   svga_get_format_cap(ss, svga_format, &caps);

   mask.value = 0;
   if (bindings & PIPE_BIND_RENDER_TARGET) {
      mask.offscreenRenderTarget = 1;
   }
   if (bindings & PIPE_BIND_DEPTH_STENCIL) {
      mask.zStencil = 1;
   }
   if (bindings & PIPE_BIND_SAMPLER_VIEW) {
      mask.texture = 1;
   }

   if (target == PIPE_TEXTURE_CUBE) {
      mask.cubeTexture = 1;
   }
   if (target == PIPE_TEXTURE_3D) {
      mask.volumeTexture = 1;
   }

   return (caps.value & mask.value) == mask.value;
}


static void
svga_fence_reference(struct pipe_screen *screen,
                     struct pipe_fence_handle **ptr,
                     struct pipe_fence_handle *fence)
{
   struct svga_winsys_screen *sws = svga_screen(screen)->sws;
   sws->fence_reference(sws, ptr, fence);
}


static boolean
svga_fence_signalled(struct pipe_screen *screen,
                     struct pipe_fence_handle *fence)
{
   struct svga_winsys_screen *sws = svga_screen(screen)->sws;
   return sws->fence_signalled(sws, fence, 0) == 0;
}


static boolean
svga_fence_finish(struct pipe_screen *screen,
                  struct pipe_fence_handle *fence,
                  uint64_t timeout)
{
   struct svga_winsys_screen *sws = svga_screen(screen)->sws;

   SVGA_DBG(DEBUG_DMA|DEBUG_PERF, "%s fence_ptr %p\n",
            __FUNCTION__, fence);

   return sws->fence_finish(sws, fence, 0) == 0;
}


static int
svga_get_driver_query_info(struct pipe_screen *screen,
                           unsigned index,
                           struct pipe_driver_query_info *info)
{
   static const struct pipe_driver_query_info queries[] = {
      {"draw-calls", SVGA_QUERY_DRAW_CALLS, 0, FALSE},
      {"fallbacks", SVGA_QUERY_FALLBACKS, 0, FALSE},
      {"memory-used", SVGA_QUERY_MEMORY_USED, 0, TRUE}
   };

   if (!info)
      return Elements(queries);

   if (index >= Elements(queries))
      return 0;

   *info = queries[index];
   return 1;
}


static void
svga_destroy_screen( struct pipe_screen *screen )
{
   struct svga_screen *svgascreen = svga_screen(screen);
   
   svga_screen_cache_cleanup(svgascreen);

   pipe_mutex_destroy(svgascreen->swc_mutex);
   pipe_mutex_destroy(svgascreen->tex_mutex);

   svgascreen->sws->destroy(svgascreen->sws);
   
   FREE(svgascreen);
}


/**
 * Create a new svga_screen object
 */
struct pipe_screen *
svga_screen_create(struct svga_winsys_screen *sws)
{
   struct svga_screen *svgascreen;
   struct pipe_screen *screen;
   SVGA3dDevCapResult result;
   boolean use_vs30, use_ps30;

#ifdef DEBUG
   SVGA_DEBUG = debug_get_flags_option("SVGA_DEBUG", svga_debug_flags, 0 );
#endif

   svgascreen = CALLOC_STRUCT(svga_screen);
   if (!svgascreen)
      goto error1;

   svgascreen->debug.force_level_surface_view =
      debug_get_bool_option("SVGA_FORCE_LEVEL_SURFACE_VIEW", FALSE);
   svgascreen->debug.force_surface_view =
      debug_get_bool_option("SVGA_FORCE_SURFACE_VIEW", FALSE);
   svgascreen->debug.force_sampler_view =
      debug_get_bool_option("SVGA_FORCE_SAMPLER_VIEW", FALSE);
   svgascreen->debug.no_surface_view =
      debug_get_bool_option("SVGA_NO_SURFACE_VIEW", FALSE);
   svgascreen->debug.no_sampler_view =
      debug_get_bool_option("SVGA_NO_SAMPLER_VIEW", FALSE);

   screen = &svgascreen->screen;

   screen->destroy = svga_destroy_screen;
   screen->get_name = svga_get_name;
   screen->get_vendor = svga_get_vendor;
   screen->get_param = svga_get_param;
   screen->get_shader_param = svga_get_shader_param;
   screen->get_paramf = svga_get_paramf;
   screen->is_format_supported = svga_is_format_supported;
   screen->context_create = svga_context_create;
   screen->fence_reference = svga_fence_reference;
   screen->fence_signalled = svga_fence_signalled;
   screen->fence_finish = svga_fence_finish;
   screen->get_driver_query_info = svga_get_driver_query_info;
   svgascreen->sws = sws;

   svga_init_screen_resource_functions(svgascreen);

   if (sws->get_hw_version) {
      svgascreen->hw_version = sws->get_hw_version(sws);
   } else {
      svgascreen->hw_version = SVGA3D_HWVERSION_WS65_B1;
   }

   use_ps30 =
      sws->get_cap(sws, SVGA3D_DEVCAP_FRAGMENT_SHADER_VERSION, &result) &&
      result.u >= SVGA3DPSVERSION_30 ? TRUE : FALSE;

   use_vs30 =
      sws->get_cap(sws, SVGA3D_DEVCAP_VERTEX_SHADER_VERSION, &result) &&
      result.u >= SVGA3DVSVERSION_30 ? TRUE : FALSE;

   /* we require Shader model 3.0 or later */
   if (!use_ps30 || !use_vs30)
      goto error2;

   /*
    * The D16, D24X8, and D24S8 formats always do an implicit shadow compare
    * when sampled from, where as the DF16, DF24, and D24S8_INT do not.  So
    * we prefer the later when available.
    *
    * This mimics hardware vendors extensions for D3D depth sampling. See also
    * http://aras-p.info/texts/D3D9GPUHacks.html
    */

   {
      boolean has_df16, has_df24, has_d24s8_int;
      SVGA3dSurfaceFormatCaps caps;
      SVGA3dSurfaceFormatCaps mask;
      mask.value = 0;
      mask.zStencil = 1;
      mask.texture = 1;

      svgascreen->depth.z16 = SVGA3D_Z_D16;
      svgascreen->depth.x8z24 = SVGA3D_Z_D24X8;
      svgascreen->depth.s8z24 = SVGA3D_Z_D24S8;

      svga_get_format_cap(svgascreen, SVGA3D_Z_DF16, &caps);
      has_df16 = (caps.value & mask.value) == mask.value;

      svga_get_format_cap(svgascreen, SVGA3D_Z_DF24, &caps);
      has_df24 = (caps.value & mask.value) == mask.value;

      svga_get_format_cap(svgascreen, SVGA3D_Z_D24S8_INT, &caps);
      has_d24s8_int = (caps.value & mask.value) == mask.value;

      /* XXX: We might want some other logic here.
       * Like if we only have d24s8_int we should
       * emulate the other formats with that.
       */
      if (has_df16) {
         svgascreen->depth.z16 = SVGA3D_Z_DF16;
      }
      if (has_df24) {
         svgascreen->depth.x8z24 = SVGA3D_Z_DF24;
      }
      if (has_d24s8_int) {
         svgascreen->depth.s8z24 = SVGA3D_Z_D24S8_INT;
      }
   }

   /* Query device caps
    */
   if (!sws->get_cap(sws, SVGA3D_DEVCAP_LINE_STIPPLE, &result))
      svgascreen->haveLineStipple = FALSE;
   else
      svgascreen->haveLineStipple = result.u;

   if (!sws->get_cap(sws, SVGA3D_DEVCAP_LINE_AA, &result))
      svgascreen->haveLineSmooth = FALSE;
   else
      svgascreen->haveLineSmooth = result.u;

   if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_LINE_WIDTH, &result))
      svgascreen->maxLineWidth = 1.0F;
   else
      svgascreen->maxLineWidth = result.f;

   if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_AA_LINE_WIDTH, &result))
      svgascreen->maxLineWidthAA = 1.0F;
   else
      svgascreen->maxLineWidthAA = result.f;

   if (0)
      debug_printf("svga: haveLineStip %u  "
                   "haveLineSmooth %u  maxLineWidth %f\n",
                   svgascreen->haveLineStipple, svgascreen->haveLineSmooth,
                   svgascreen->maxLineWidth);

   if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_POINT_SIZE, &result)) {
      svgascreen->maxPointSize = 1.0F;
   } else {
      /* Keep this to a reasonable size to avoid failures in
       * conform/pntaa.c:
       */
      svgascreen->maxPointSize = MIN2(result.f, 80.0f);
   }

   /* The SVGA3D device always supports 4 targets at this time, regardless
    * of what querying SVGA3D_DEVCAP_MAX_RENDER_TARGETS might return.
    */
   svgascreen->max_color_buffers = 4;

   pipe_mutex_init(svgascreen->tex_mutex);
   pipe_mutex_init(svgascreen->swc_mutex);

   svga_screen_cache_init(svgascreen);

   return screen;
error2:
   FREE(svgascreen);
error1:
   return NULL;
}

struct svga_winsys_screen *
svga_winsys_screen(struct pipe_screen *screen)
{
   return svga_screen(screen)->sws;
}

#ifdef DEBUG
struct svga_screen *
svga_screen(struct pipe_screen *screen)
{
   assert(screen);
   assert(screen->destroy == svga_destroy_screen);
   return (struct svga_screen *)screen;
}
#endif
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a257 1
   case PIPE_CAP_MAX_VERTEX_STREAMS:
d270 1
a270 1
   case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
a276 7
   case PIPE_CAP_TEXTURE_GATHER_OFFSETS:
   case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
   case PIPE_CAP_DRAW_INDIRECT:
   case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
   case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
   case PIPE_CAP_SAMPLER_VIEW_TARGET:
   case PIPE_CAP_CLIP_HALFZ:
a281 2
   case PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE:
      return 2048;
a285 12

   case PIPE_CAP_VENDOR_ID:
      return 0x15ad; /* VMware Inc. */
   case PIPE_CAP_DEVICE_ID:
      return 0x0405; /* assume SVGA II */
   case PIPE_CAP_ACCELERATED:
      return 0; /* XXX: */
   case PIPE_CAP_VIDEO_MEMORY:
      /* XXX: Query the host ? */
      return 1;
   case PIPE_CAP_UMA:
      return 0;
d312 2
a313 4
      case PIPE_SHADER_CAP_MAX_OUTPUTS:
         return svgascreen->max_color_buffers;
      case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
         return 224 * sizeof(float[4]);
d320 1
d346 2
a347 3
      case PIPE_SHADER_CAP_PREFERRED_IR:
         return PIPE_SHADER_IR_TGSI;
      case PIPE_SHADER_CAP_DOUBLES:
d350 1
a350 3
      /* If we get here, we failed to handle a cap above */
      debug_printf("Unexpected fragment shader query %u\n", param);
      return 0;
d367 2
a368 4
      case PIPE_SHADER_CAP_MAX_OUTPUTS:
         return 10;
      case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
         return 256 * sizeof(float[4]);
d375 2
d397 2
a398 3
      case PIPE_SHADER_CAP_PREFERRED_IR:
         return PIPE_SHADER_IR_TGSI;
      case PIPE_SHADER_CAP_DOUBLES:
d401 1
a401 3
      /* If we get here, we failed to handle a cap above */
      debug_printf("Unexpected vertex shader query %u\n", param);
      return 0;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d258 1
d271 1
a271 1
   case PIPE_CAP_TGSI_VS_LAYER:
d278 7
d290 2
d296 12
d334 4
a337 2
      case PIPE_SHADER_CAP_MAX_CONSTS:
         return 224;
a343 1
      case PIPE_SHADER_CAP_MAX_ADDRS:
d369 3
a371 2
      default:
         debug_printf("Unexpected fragment shader query %u\n", param);
d374 3
a376 1
      break;
d393 4
a396 2
      case PIPE_SHADER_CAP_MAX_CONSTS:
         return 256;
a402 2
      case PIPE_SHADER_CAP_MAX_ADDRS:
         return 1;
d423 3
a425 2
      default:
         debug_printf("Unexpected vertex shader query %u\n", param);
d428 3
a430 1
      break;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d26 1
d106 1
a106 1
      /* fall-through */
d108 1
a108 1
      return 7.0;
a141 2
   case PIPE_CAP_MAX_COMBINED_SAMPLERS:
      return 16;
d143 1
d156 1
a156 5
      if(!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_RENDER_TARGETS, &result))
         return 1;
      if(!result.u)
         return 1;
      return MIN2(result.u, PIPE_MAX_COLOR_BUFS);
d206 1
d208 1
a208 1
      return 1;
d210 1
d212 1
a212 1
      return 0;
d228 3
a235 1
   case PIPE_CAP_SM3:
a246 1
   case PIPE_CAP_SCALED_RESOLVE:
d249 2
d256 2
a264 1
   case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
d270 7
d278 2
d332 1
a332 1
         return 1;
d344 1
d347 1
a347 1
         debug_printf("Unexpected vertex shader query %u\n", param);
d380 1
a380 1
         return 1;
d395 1
d403 2
a404 1
      /* no support for geometry shaders at this time */
d414 4
d423 1
a423 1
                          unsigned tex_usage)
d430 1
a430 1
   assert(tex_usage);
d436 1
a436 1
   svga_format = svga_translate_format(ss, format, tex_usage);
d446 1
a446 1
   if (tex_usage & PIPE_BIND_DISPLAY_TARGET) {
d472 1
a472 1
   if (tex_usage & PIPE_BIND_RENDER_TARGET) {
d475 1
a475 1
   if (tex_usage & PIPE_BIND_DEPTH_STENCIL) {
d478 1
a478 1
   if (tex_usage & PIPE_BIND_SAMPLER_VIEW) {
d482 7
d675 28
d711 5
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d34 1
d75 2
d80 5
a84 1
   return "SVGA3D; build: DEBUG; mutex: " PIPE_ATOMIC;
d86 1
a86 1
   return "SVGA3D; build: RELEASE; ";
d88 3
d97 1
a97 1
svga_get_paramf(struct pipe_screen *screen, enum pipe_cap param)
d104 1
a104 1
   case PIPE_CAP_MAX_LINE_WIDTH:
d106 1
a106 1
   case PIPE_CAP_MAX_LINE_WIDTH_AA:
d109 1
a109 1
   case PIPE_CAP_MAX_POINT_WIDTH:
d111 2
a112 5
   case PIPE_CAP_MAX_POINT_WIDTH_AA:
      /* Keep this to a reasonable size to avoid failures in
       * conform/pntaa.c:
       */
      return SVGA_MAX_POINTSIZE;
d114 1
a114 1
   case PIPE_CAP_MAX_TEXTURE_ANISOTROPY:
d116 15
a130 2
         return 4.0;
      return result.u;
a131 2
   case PIPE_CAP_MAX_TEXTURE_LOD_BIAS:
      return 16.0;
d133 8
a140 2
   case PIPE_CAP_MAX_TEXTURE_IMAGE_UNITS:
      return 16;
d147 2
a148 2
   case PIPE_CAP_GLSL:
      return svgascreen->use_ps30 && svgascreen->use_vs30;
d153 2
d163 1
a163 1
   case PIPE_CAP_TIMER_QUERY:
d167 11
d203 2
a204 5
      return MIN2(screen->get_paramf(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS),
                  12.0 /* 2048x2048 */);

   case PIPE_CAP_TEXTURE_MIRROR_REPEAT: /* req. for GL 1.4 */
      return 1;
d216 14
a229 1
   case PIPE_CAP_DEPTHSTENCIL_CLEAR_SEPARATE:
a230 2
   case PIPE_CAP_MIXED_COLORBUFFER_FORMATS:
      return 0;
d232 36
a267 1
   default:
d269 6
a275 1
}
d277 2
a278 7

/* This is a fairly pointless interface
 */
static int
svga_get_param(struct pipe_screen *screen, enum pipe_cap param)
{
   return (int) svga_get_paramf( screen, param );
d296 1
a296 1
         return svgascreen->use_ps30 ? 512 : 96;
d302 1
a302 1
         return svgascreen->use_ps30 ? 224 : 16;
d307 2
a308 2
            return svgascreen->use_ps30 ? 32 : 12;
         return result.u;
d319 1
a319 1
         return svgascreen->use_ps30 ? 1 : 0;
d322 2
d330 7
d345 1
a345 1
            return svgascreen->use_vs30 ? 512 : 256;
d361 2
a362 2
            return svgascreen->use_vs30 ? 32 : 12;
         return result.u;
d364 1
a364 1
         return svgascreen->use_vs30 ? 1 : 0;
d366 1
a366 1
         return svgascreen->use_vs30 ? 1 : 0;
d369 2
d373 1
a373 1
         return svgascreen->use_vs30 ? 1 : 0;
d380 4
d385 2
a386 1
         break;
d389 3
d393 2
a394 1
      break;
a398 42
static INLINE SVGA3dDevCapIndex
svga_translate_format_cap(enum pipe_format format)
{
   switch(format) {
   
   case PIPE_FORMAT_B8G8R8A8_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_A8R8G8B8;
   case PIPE_FORMAT_B8G8R8X8_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_X8R8G8B8;

   case PIPE_FORMAT_B5G6R5_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_R5G6B5;
   case PIPE_FORMAT_B5G5R5A1_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_A1R5G5B5;
   case PIPE_FORMAT_B4G4R4A4_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_A4R4G4B4;

   case PIPE_FORMAT_Z16_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_Z_D16;
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_Z_D24S8;
   case PIPE_FORMAT_X8Z24_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_Z_D24X8;

   case PIPE_FORMAT_A8_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_ALPHA8;
   case PIPE_FORMAT_L8_UNORM:
      return SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE8;

   case PIPE_FORMAT_DXT1_RGB:
   case PIPE_FORMAT_DXT1_RGBA:
      return SVGA3D_DEVCAP_SURFACEFMT_DXT1;
   case PIPE_FORMAT_DXT3_RGBA:
      return SVGA3D_DEVCAP_SURFACEFMT_DXT3;
   case PIPE_FORMAT_DXT5_RGBA:
      return SVGA3D_DEVCAP_SURFACEFMT_DXT5;

   default:
      return SVGA3D_DEVCAP_MAX;
   }
}

d407 4
a410 3
   struct svga_winsys_screen *sws = svga_screen(screen)->sws;
   SVGA3dDevCapIndex index;
   SVGA3dDevCapResult result;
d414 6
a419 1
   if (sample_count > 1)
d421 6
d428 6
a433 3
   /* Override host capabilities */
   if (tex_usage & PIPE_BIND_RENDER_TARGET) {
      switch(format) { 
d438 2
a439 2
      case PIPE_FORMAT_B4G4R4A4_UNORM:
      case PIPE_FORMAT_B5G5R5A1_UNORM:
d443 1
a443 1
         break;
d447 15
a461 19
   /* Try to query the host */
   index = svga_translate_format_cap(format);
   if( index < SVGA3D_DEVCAP_MAX && 
       sws->get_cap(sws, index, &result) )
   {
      SVGA3dSurfaceFormatCaps mask;
      
      mask.value = 0;
      if (tex_usage & PIPE_BIND_RENDER_TARGET)
         mask.offscreenRenderTarget = 1;
      if (tex_usage & PIPE_BIND_DEPTH_STENCIL)
         mask.zStencil = 1;
      if (tex_usage & PIPE_BIND_SAMPLER_VIEW)
         mask.texture = 1;

      if ((result.u & mask.value) == mask.value)
         return TRUE;
      else
         return FALSE;
d464 1
a464 8
   /* Use our translate functions directly rather than relying on a
    * duplicated list of supported formats which is prone to getting
    * out of sync:
    */
   if(tex_usage & (PIPE_BIND_RENDER_TARGET | PIPE_BIND_DEPTH_STENCIL))
      return svga_translate_format_render(format) != SVGA3D_FORMAT_INVALID;
   else
      return svga_translate_format(format) != SVGA3D_FORMAT_INVALID;
d501 22
d548 1
d582 1
d593 1
a593 1
   svgascreen->use_ps30 =
d597 1
a597 1
   svgascreen->use_vs30 =
d601 2
a602 3
#if 1
   /* Shader model 2.0 is unsupported at the moment. */
   if(!svgascreen->use_ps30 || !svgascreen->use_vs30)
d604 54
a657 4
#else
   if(debug_get_bool_option("SVGA_NO_SM30", FALSE))
      svgascreen->use_vs30 = svgascreen->use_ps30 = FALSE;
#endif
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a37 1
#include "svga_surface.h"
d184 2
d230 8
a237 1
         return svgascreen->use_ps30 ? 1 : 0;
a241 2
      case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
         return svgascreen->use_ps30 ? 1 : 0;
d347 1
a347 2
                          unsigned tex_usage,
                          unsigned geom_flags )
a368 7
      /* Simulate ability to render into compressed textures */
      case PIPE_FORMAT_DXT1_RGB:
      case PIPE_FORMAT_DXT1_RGBA:
      case PIPE_FORMAT_DXT3_RGBA:
      case PIPE_FORMAT_DXT5_RGBA:
         return TRUE;

d416 1
a416 1
static int
d418 1
a418 2
                     struct pipe_fence_handle *fence,
                     unsigned flag)
d421 1
a421 1
   return sws->fence_signalled(sws, fence, flag);
d425 1
a425 1
static int
d428 1
a428 1
                  unsigned flag)
d435 1
a435 1
   return sws->fence_finish(sws, fence, flag);
d500 6
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d32 1
d35 2
a36 2
#include "svga_screen_texture.h"
#include "svga_screen_buffer.h"
d38 1
d47 15
a61 15
   { "dma",      DEBUG_DMA },
   { "tgsi",     DEBUG_TGSI },
   { "pipe",     DEBUG_PIPE },
   { "state",    DEBUG_STATE },
   { "screen",   DEBUG_SCREEN },
   { "tex",      DEBUG_TEX },
   { "swtnl",    DEBUG_SWTNL },
   { "const",    DEBUG_CONSTS },
   { "viewport", DEBUG_VIEWPORT },
   { "views",    DEBUG_VIEWS },
   { "perf",     DEBUG_PERF },
   { "flush",    DEBUG_FLUSH },
   { "sync",     DEBUG_SYNC },
   { "cache",    DEBUG_CACHE },
   {NULL, 0}
d88 1
a88 1
svga_get_paramf(struct pipe_screen *screen, int param)
d138 2
d183 3
d195 1
a195 1
svga_get_param(struct pipe_screen *screen, int param)
d200 92
d312 1
a312 1
   case PIPE_FORMAT_S8Z24_UNORM:
d338 1
a338 1
                          enum pipe_format format, 
d340 2
a341 1
                          unsigned tex_usage, 
d347 1
a347 1
   
d350 3
d354 1
a354 1
   if (tex_usage & PIPE_TEXTURE_USAGE_RENDER_TARGET) {
d384 1
a384 1
      if (tex_usage & PIPE_TEXTURE_USAGE_RENDER_TARGET)
d386 1
a386 1
      if (tex_usage & PIPE_TEXTURE_USAGE_DEPTH_STENCIL)
d388 1
a388 1
      if (tex_usage & PIPE_TEXTURE_USAGE_SAMPLER)
d401 1
a401 1
   if(tex_usage & (PIPE_TEXTURE_USAGE_RENDER_TARGET | PIPE_TEXTURE_USAGE_DEPTH_STENCIL))
a451 2
   svgascreen->swc->destroy(svgascreen->swc);
   
d493 1
d502 1
a502 2
   svga_screen_init_texture_functions(screen);
   svga_screen_init_buffer_functions(screen);
a520 4
   svgascreen->swc = sws->context_create(sws);
   if(!svgascreen->swc)
      goto error2;

a530 19
}

void svga_screen_flush( struct svga_screen *svgascreen, 
                        struct pipe_fence_handle **pfence )
{
   struct pipe_fence_handle *fence = NULL;

   SVGA_DBG(DEBUG_PERF, "%s\n", __FUNCTION__);
   
   pipe_mutex_lock(svgascreen->swc_mutex);
   svgascreen->swc->flush(svgascreen->swc, &fence);
   pipe_mutex_unlock(svgascreen->swc_mutex);
   
   svga_screen_cache_flush(svgascreen, fence);
   
   if(pfence)
      *pfence = fence;
   else
      svgascreen->sws->fence_reference(svgascreen->sws, &fence, NULL);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a31 1
#include "svga_public.h"
d34 2
a35 2
#include "svga_resource_texture.h"
#include "svga_resource.h"
a36 1
#include "svga_surface.h"
d45 15
a59 15
   { "dma",      DEBUG_DMA, NULL },
   { "tgsi",     DEBUG_TGSI, NULL },
   { "pipe",     DEBUG_PIPE, NULL },
   { "state",    DEBUG_STATE, NULL },
   { "screen",   DEBUG_SCREEN, NULL },
   { "tex",      DEBUG_TEX, NULL },
   { "swtnl",    DEBUG_SWTNL, NULL },
   { "const",    DEBUG_CONSTS, NULL },
   { "viewport", DEBUG_VIEWPORT, NULL },
   { "views",    DEBUG_VIEWS, NULL },
   { "perf",     DEBUG_PERF, NULL },
   { "flush",    DEBUG_FLUSH, NULL },
   { "sync",     DEBUG_SYNC, NULL },
   { "cache",    DEBUG_CACHE, NULL },
   DEBUG_NAMED_VALUE_END
d86 1
a86 1
svga_get_paramf(struct pipe_screen *screen, enum pipe_cap param)
a135 2
   case PIPE_CAP_TIMER_QUERY:
      return 0;
a178 3
   case PIPE_CAP_DEPTHSTENCIL_CLEAR_SEPARATE:
      return 1;

d188 1
a188 1
svga_get_param(struct pipe_screen *screen, enum pipe_cap param)
a192 92
static int svga_get_shader_param(struct pipe_screen *screen, unsigned shader, enum pipe_shader_cap param)
{
   struct svga_screen *svgascreen = svga_screen(screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   SVGA3dDevCapResult result;

   switch (shader)
   {
   case PIPE_SHADER_FRAGMENT:
      switch (param)
      {
      case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
         return svgascreen->use_ps30 ? 512 : 96;
      case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
         return SVGA3D_MAX_NESTING_LEVEL;
      case PIPE_SHADER_CAP_MAX_INPUTS:
         return 10;
      case PIPE_SHADER_CAP_MAX_CONSTS:
         return svgascreen->use_ps30 ? 224 : 16;
      case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
         return 1;
      case PIPE_SHADER_CAP_MAX_TEMPS:
         if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_FRAGMENT_SHADER_TEMPS, &result))
            return svgascreen->use_ps30 ? 32 : 12;
         return result.u;
      case PIPE_SHADER_CAP_MAX_ADDRS:
         return svgascreen->use_ps30 ? 1 : 0;
      case PIPE_SHADER_CAP_MAX_PREDS:
         return svgascreen->use_ps30 ? 1 : 0;
      case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
         return 1;
      case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
         return svgascreen->use_ps30 ? 1 : 0;
      case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
      case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
      case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
         return 0;
      case PIPE_SHADER_CAP_SUBROUTINES:
         return 0;
      }
      break;
   case PIPE_SHADER_VERTEX:
      switch (param)
      {
      case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
         if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_VERTEX_SHADER_INSTRUCTIONS, &result))
            return svgascreen->use_vs30 ? 512 : 256;
         return result.u;
      case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
      case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
         /* XXX: until we have vertex texture support */
         return 0;
      case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
         return SVGA3D_MAX_NESTING_LEVEL;
      case PIPE_SHADER_CAP_MAX_INPUTS:
         return 16;
      case PIPE_SHADER_CAP_MAX_CONSTS:
         return 256;
      case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
         return 1;
      case PIPE_SHADER_CAP_MAX_TEMPS:
         if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_VERTEX_SHADER_TEMPS, &result))
            return svgascreen->use_vs30 ? 32 : 12;
         return result.u;
      case PIPE_SHADER_CAP_MAX_ADDRS:
         return svgascreen->use_vs30 ? 1 : 0;
      case PIPE_SHADER_CAP_MAX_PREDS:
         return svgascreen->use_vs30 ? 1 : 0;
      case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
         return 1;
      case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
      case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
         return svgascreen->use_vs30 ? 1 : 0;
      case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
         return 0;
      case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
         return 1;
      case PIPE_SHADER_CAP_SUBROUTINES:
         return 0;
      default:
         break;
      }
      break;
   default:
      break;
   }
   return 0;
}
d213 1
a213 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d239 1
a239 1
                          enum pipe_format format,
d241 1
a241 2
                          unsigned sample_count,
                          unsigned tex_usage,
d247 1
a247 1

a249 3
   if (sample_count > 1)
      return FALSE;

d251 1
a251 1
   if (tex_usage & PIPE_BIND_RENDER_TARGET) {
d281 1
a281 1
      if (tex_usage & PIPE_BIND_RENDER_TARGET)
d283 1
a283 1
      if (tex_usage & PIPE_BIND_DEPTH_STENCIL)
d285 1
a285 1
      if (tex_usage & PIPE_BIND_SAMPLER_VIEW)
d298 1
a298 1
   if(tex_usage & (PIPE_BIND_RENDER_TARGET | PIPE_BIND_DEPTH_STENCIL))
d349 2
a391 1
   screen->get_shader_param = svga_get_shader_param;
d400 2
a401 1
   svga_init_screen_resource_functions(svgascreen);
d420 4
d434 19
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a33 1
#include "svga_format.h"
d38 1
a74 2
   const char *build = "", *llvm = "", *mutex = "";
   static char name[100];
d78 1
a78 5
   build = "build: DEBUG;";
   mutex = "mutex: " PIPE_ATOMIC ";";
#ifdef HAVE_LLVM
   llvm = "LLVM;";
#endif
d80 1
a80 1
   build = "build: RELEASE;";
a81 3

   util_snprintf(name, sizeof(name), "SVGA3D; %s %s %s", build, mutex, llvm);
   return name;
d88 1
a88 1
svga_get_paramf(struct pipe_screen *screen, enum pipe_capf param)
d95 1
a95 1
   case PIPE_CAPF_MAX_LINE_WIDTH:
d97 1
a97 1
   case PIPE_CAPF_MAX_LINE_WIDTH_AA:
d100 1
a100 1
   case PIPE_CAPF_MAX_POINT_WIDTH:
d102 5
a106 2
   case PIPE_CAPF_MAX_POINT_WIDTH_AA:
      return svgascreen->maxPointSize;
d108 1
a108 1
   case PIPE_CAPF_MAX_TEXTURE_ANISOTROPY:
d110 2
a111 2
         return 4.0f;
      return (float) result.u;
d113 2
a114 8
   case PIPE_CAPF_MAX_TEXTURE_LOD_BIAS:
      return 15.0;
   case PIPE_CAPF_GUARD_BAND_LEFT:
   case PIPE_CAPF_GUARD_BAND_TOP:
   case PIPE_CAPF_GUARD_BAND_RIGHT:
   case PIPE_CAPF_GUARD_BAND_BOTTOM:
      return 0.0;
   }
d116 2
a117 13
   debug_printf("Unexpected PIPE_CAPF_ query %u\n", param);
   return 0;
}


static int
svga_get_param(struct pipe_screen *screen, enum pipe_cap param)
{
   struct svga_screen *svgascreen = svga_screen(screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   SVGA3dDevCapResult result;

   switch (param) {
d124 2
a125 2
   case PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS:
      return 0;
a129 2
   case PIPE_CAP_TGSI_TEXCOORD:
      return 0;
d138 1
a138 1
   case PIPE_CAP_QUERY_TIME_ELAPSED:
a141 11
   case PIPE_CAP_TEXTURE_SWIZZLE:
      return 1;
   case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
      return 0;
   case PIPE_CAP_USER_VERTEX_BUFFERS:
   case PIPE_CAP_USER_INDEX_BUFFERS:
      return 0;
   case PIPE_CAP_USER_CONSTANT_BUFFERS:
      return 1;
   case PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT:
      return 16;
d167 5
a171 2
      return MIN2(screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS),
                  12 /* 2048x2048 */);
d183 1
a183 14
   case PIPE_CAP_VERTEX_COLOR_UNCLAMPED:
      return 1; /* The color outputs of vertex shaders are not clamped */
   case PIPE_CAP_VERTEX_COLOR_CLAMPED:
      return 0; /* The driver can't clamp vertex colors */
   case PIPE_CAP_FRAGMENT_COLOR_CLAMPED:
      return 0; /* The driver can't clamp fragment colors */

   case PIPE_CAP_MIXED_COLORBUFFER_FORMATS:
      return 1; /* expected for GL_ARB_framebuffer_object */

   case PIPE_CAP_GLSL_FEATURE_LEVEL:
      return 120;

   case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
d186 1
a186 36
   /* Unsupported features */
   case PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION:
   case PIPE_CAP_TEXTURE_MIRROR_CLAMP:
   case PIPE_CAP_SM3:
   case PIPE_CAP_SHADER_STENCIL_EXPORT:
   case PIPE_CAP_DEPTH_CLIP_DISABLE:
   case PIPE_CAP_SEAMLESS_CUBE_MAP:
   case PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE:
   case PIPE_CAP_INDEP_BLEND_ENABLE:
   case PIPE_CAP_INDEP_BLEND_FUNC:
   case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
   case PIPE_CAP_PRIMITIVE_RESTART:
   case PIPE_CAP_TGSI_INSTANCEID:
   case PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR:
   case PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS:
   case PIPE_CAP_SCALED_RESOLVE:
   case PIPE_CAP_MIN_TEXEL_OFFSET:
   case PIPE_CAP_MAX_TEXEL_OFFSET:
   case PIPE_CAP_CONDITIONAL_RENDER:
   case PIPE_CAP_TEXTURE_BARRIER:
   case PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS:
   case PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS:
   case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
   case PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS:
   case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
   case PIPE_CAP_COMPUTE:
   case PIPE_CAP_START_INSTANCE:
   case PIPE_CAP_QUERY_TIMESTAMP:
   case PIPE_CAP_TEXTURE_MULTISAMPLE:
   case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
   case PIPE_CAP_CUBE_MAP_ARRAY:
   case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
   case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
   case PIPE_CAP_QUERY_PIPELINE_STATISTICS:
   case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
a187 6
   case PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY:
      return 1;
   case PIPE_CAP_MAX_VIEWPORTS:
      return 1;
   case PIPE_CAP_ENDIANNESS:
      return PIPE_ENDIAN_LITTLE;
d189 2
d192 6
a197 2
   debug_printf("Unexpected PIPE_CAP_ query %u\n", param);
   return 0;
d215 1
a215 1
         return 512;
d221 1
a221 1
         return 224;
d226 2
a227 2
            return 32;
         return MIN2(result.u, SVGA3D_TEMPREG_MAX);
d229 1
a229 8
      case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
	 /* 
	  * Although PS 3.0 has some addressing abilities it can only represent
	  * loops that can be statically determined and unrolled. Given we can
	  * only handle a subset of the cases that the state tracker already
	  * does it is better to defer loop unrolling to the state tracker.
	  */
         return 0;
d231 1
a231 1
         return 1;
d234 2
a235 2
      case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
         return 0;
a241 7
      case PIPE_SHADER_CAP_INTEGERS:
         return 0;
      case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
         return 16;
      default:
         debug_printf("Unexpected vertex shader query %u\n", param);
         return 0;
d250 1
a250 1
            return 512;
d266 2
a267 2
            return 32;
         return MIN2(result.u, SVGA3D_TEMPREG_MAX);
d269 1
a269 1
         return 1;
d271 1
a271 1
         return 1;
a273 2
      case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
         return 0;
d276 1
a276 1
         return 1;
a282 4
      case PIPE_SHADER_CAP_INTEGERS:
         return 0;
      case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
         return 0;
d284 1
a284 2
         debug_printf("Unexpected vertex shader query %u\n", param);
         return 0;
a286 3
   case PIPE_SHADER_GEOMETRY:
      /* no support for geometry shaders at this time */
      return 0;
d288 1
a288 2
      debug_printf("Unexpected shader type (%u) query\n", shader);
      return 0;
d293 42
d341 2
a342 1
                          unsigned tex_usage)
d344 3
a346 4
   struct svga_screen *ss = svga_screen(screen);
   SVGA3dSurfaceFormat svga_format;
   SVGA3dSurfaceFormatCaps caps;
   SVGA3dSurfaceFormatCaps mask;
d350 1
a350 1
   if (sample_count > 1) {
a351 1
   }
d353 3
a355 16
   svga_format = svga_translate_format(ss, format, tex_usage);
   if (svga_format == SVGA3D_FORMAT_INVALID) {
      return FALSE;
   }

   /*
    * Override host capabilities, so that we end up with the same
    * visuals for all virtual hardware implementations.
    */

   if (tex_usage & PIPE_BIND_DISPLAY_TARGET) {
      switch (svga_format) {
      case SVGA3D_A8R8G8B8:
      case SVGA3D_X8R8G8B8:
      case SVGA3D_R5G6B5:
         break;
d360 2
a361 2
      case SVGA3D_A4R4G4B4:
      case SVGA3D_A1R5G5B5:
d364 7
d372 1
a372 1
         return FALSE;
d376 19
a394 15
   /*
    * Query the host capabilities.
    */

   svga_get_format_cap(ss, svga_format, &caps);

   mask.value = 0;
   if (tex_usage & PIPE_BIND_RENDER_TARGET) {
      mask.offscreenRenderTarget = 1;
   }
   if (tex_usage & PIPE_BIND_DEPTH_STENCIL) {
      mask.zStencil = 1;
   }
   if (tex_usage & PIPE_BIND_SAMPLER_VIEW) {
      mask.texture = 1;
d397 8
a404 1
   return (caps.value & mask.value) == mask.value;
d418 1
a418 1
static boolean
d420 2
a421 1
                     struct pipe_fence_handle *fence)
d424 1
a424 1
   return sws->fence_signalled(sws, fence, 0) == 0;
d428 1
a428 1
static boolean
d431 1
a431 1
                  uint64_t timeout)
d438 1
a438 23
   return sws->fence_finish(sws, fence, 0) == 0;
}


static int
svga_get_driver_query_info(struct pipe_screen *screen,
                           unsigned index,
                           struct pipe_driver_query_info *info)
{
   static const struct pipe_driver_query_info queries[] = {
      {"draw-calls", SVGA_QUERY_DRAW_CALLS, 0, FALSE},
      {"fallbacks", SVGA_QUERY_FALLBACKS, 0, FALSE},
      {"memory-used", SVGA_QUERY_MEMORY_USED, 0, TRUE}
   };

   if (!info)
      return Elements(queries);

   if (index >= Elements(queries))
      return 0;

   *info = queries[index];
   return 1;
a466 1
   boolean use_vs30, use_ps30;
a499 1
   screen->get_driver_query_info = svga_get_driver_query_info;
d504 1
a504 7
   if (sws->get_hw_version) {
      svgascreen->hw_version = sws->get_hw_version(sws);
   } else {
      svgascreen->hw_version = SVGA3D_HWVERSION_WS65_B1;
   }

   use_ps30 =
d508 1
a508 1
   use_vs30 =
d512 3
a514 2
   /* we require Shader model 3.0 or later */
   if (!use_ps30 || !use_vs30)
d516 4
a519 54

   /*
    * The D16, D24X8, and D24S8 formats always do an implicit shadow compare
    * when sampled from, where as the DF16, DF24, and D24S8_INT do not.  So
    * we prefer the later when available.
    *
    * This mimics hardware vendors extensions for D3D depth sampling. See also
    * http://aras-p.info/texts/D3D9GPUHacks.html
    */

   {
      boolean has_df16, has_df24, has_d24s8_int;
      SVGA3dSurfaceFormatCaps caps;
      SVGA3dSurfaceFormatCaps mask;
      mask.value = 0;
      mask.zStencil = 1;
      mask.texture = 1;

      svgascreen->depth.z16 = SVGA3D_Z_D16;
      svgascreen->depth.x8z24 = SVGA3D_Z_D24X8;
      svgascreen->depth.s8z24 = SVGA3D_Z_D24S8;

      svga_get_format_cap(svgascreen, SVGA3D_Z_DF16, &caps);
      has_df16 = (caps.value & mask.value) == mask.value;

      svga_get_format_cap(svgascreen, SVGA3D_Z_DF24, &caps);
      has_df24 = (caps.value & mask.value) == mask.value;

      svga_get_format_cap(svgascreen, SVGA3D_Z_D24S8_INT, &caps);
      has_d24s8_int = (caps.value & mask.value) == mask.value;

      /* XXX: We might want some other logic here.
       * Like if we only have d24s8_int we should
       * emulate the other formats with that.
       */
      if (has_df16) {
         svgascreen->depth.z16 = SVGA3D_Z_DF16;
      }
      if (has_df24) {
         svgascreen->depth.x8z24 = SVGA3D_Z_DF24;
      }
      if (has_d24s8_int) {
         svgascreen->depth.s8z24 = SVGA3D_Z_D24S8_INT;
      }
   }

   if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_POINT_SIZE, &result)) {
      svgascreen->maxPointSize = 1.0F;
   } else {
      /* Keep this to a reasonable size to avoid failures in
       * conform/pntaa.c:
       */
      svgascreen->maxPointSize = MIN2(result.f, 80.0f);
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a25 1
#include "util/u_format.h"
d105 1
a105 1
      return svgascreen->maxLineWidth;
d107 1
a107 1
      return svgascreen->maxLineWidthAA;
d141 2
a143 1
   case PIPE_CAP_MIXED_FRAMEBUFFER_SIZES:
d156 5
a160 1
      return svgascreen->max_color_buffers;
d210 1
a211 2
   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
      return 0;
d213 1
a214 2
   case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
      return 1;
a229 3
      return 0;

   case PIPE_CAP_SM3:
d235 1
d247 1
a249 2
   case PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET:
   case PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET:
a254 2
   case PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES:
   case PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS:
d262 1
a267 7
   case PIPE_CAP_TGSI_VS_LAYER:
   case PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS:
   case PIPE_CAP_TEXTURE_GATHER_SM5:
   case PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT:
   case PIPE_CAP_FAKE_SW_MSAA:
   case PIPE_CAP_TEXTURE_QUERY_LOD:
   case PIPE_CAP_SAMPLE_SHADING:
a268 2
   case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
      return 64;
d321 1
a321 1
         return 0;
a332 1
      case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
d335 1
a335 1
         debug_printf("Unexpected fragment shader query %u\n", param);
d368 1
a368 1
         return 0;
a382 1
      case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
d390 1
a390 2
   case PIPE_SHADER_COMPUTE:
      /* no support for geometry or compute shaders at this time */
a399 4
/**
 * Implemnt pipe_screen::is_format_supported().
 * \param bindings  bitmask of PIPE_BIND_x flags
 */
d405 1
a405 1
                          unsigned bindings)
d412 1
a412 1
   assert(bindings);
d418 1
a418 1
   svga_format = svga_translate_format(ss, format, bindings);
d428 1
a428 1
   if (bindings & PIPE_BIND_DISPLAY_TARGET) {
d454 1
a454 1
   if (bindings & PIPE_BIND_RENDER_TARGET) {
d457 1
a457 1
   if (bindings & PIPE_BIND_DEPTH_STENCIL) {
d460 1
a460 1
   if (bindings & PIPE_BIND_SAMPLER_VIEW) {
a463 7
   if (target == PIPE_TEXTURE_CUBE) {
      mask.cubeTexture = 1;
   }
   if (target == PIPE_TEXTURE_3D) {
      mask.volumeTexture = 1;
   }

a649 28
   /* Query device caps
    */
   if (!sws->get_cap(sws, SVGA3D_DEVCAP_LINE_STIPPLE, &result))
      svgascreen->haveLineStipple = FALSE;
   else
      svgascreen->haveLineStipple = result.u;

   if (!sws->get_cap(sws, SVGA3D_DEVCAP_LINE_AA, &result))
      svgascreen->haveLineSmooth = FALSE;
   else
      svgascreen->haveLineSmooth = result.u;

   if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_LINE_WIDTH, &result))
      svgascreen->maxLineWidth = 1.0F;
   else
      svgascreen->maxLineWidth = result.f;

   if (!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_AA_LINE_WIDTH, &result))
      svgascreen->maxLineWidthAA = 1.0F;
   else
      svgascreen->maxLineWidthAA = result.f;

   if (0)
      debug_printf("svga: haveLineStip %u  "
                   "haveLineSmooth %u  maxLineWidth %f\n",
                   svgascreen->haveLineStipple, svgascreen->haveLineSmooth,
                   svgascreen->maxLineWidth);

a657 5

   /* The SVGA3D device always supports 4 targets at this time, regardless
    * of what querying SVGA3D_DEVCAP_MAX_RENDER_TARGETS might return.
    */
   svgascreen->max_color_buffers = 4;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a257 1
   case PIPE_CAP_MAX_VERTEX_STREAMS:
d270 1
a270 1
   case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
a276 7
   case PIPE_CAP_TEXTURE_GATHER_OFFSETS:
   case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
   case PIPE_CAP_DRAW_INDIRECT:
   case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
   case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
   case PIPE_CAP_SAMPLER_VIEW_TARGET:
   case PIPE_CAP_CLIP_HALFZ:
a281 2
   case PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE:
      return 2048;
a285 12

   case PIPE_CAP_VENDOR_ID:
      return 0x15ad; /* VMware Inc. */
   case PIPE_CAP_DEVICE_ID:
      return 0x0405; /* assume SVGA II */
   case PIPE_CAP_ACCELERATED:
      return 0; /* XXX: */
   case PIPE_CAP_VIDEO_MEMORY:
      /* XXX: Query the host ? */
      return 1;
   case PIPE_CAP_UMA:
      return 0;
d312 2
a313 4
      case PIPE_SHADER_CAP_MAX_OUTPUTS:
         return svgascreen->max_color_buffers;
      case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
         return 224 * sizeof(float[4]);
d320 1
d346 2
a347 3
      case PIPE_SHADER_CAP_PREFERRED_IR:
         return PIPE_SHADER_IR_TGSI;
      case PIPE_SHADER_CAP_DOUBLES:
d350 1
a350 3
      /* If we get here, we failed to handle a cap above */
      debug_printf("Unexpected fragment shader query %u\n", param);
      return 0;
d367 2
a368 4
      case PIPE_SHADER_CAP_MAX_OUTPUTS:
         return 10;
      case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
         return 256 * sizeof(float[4]);
d375 2
d397 2
a398 3
      case PIPE_SHADER_CAP_PREFERRED_IR:
         return PIPE_SHADER_IR_TGSI;
      case PIPE_SHADER_CAP_DOUBLES:
d401 1
a401 3
      /* If we get here, we failed to handle a cap above */
      debug_printf("Unexpected vertex shader query %u\n", param);
      return 0;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d258 1
d271 1
a271 1
   case PIPE_CAP_TGSI_VS_LAYER:
d278 7
d290 2
d296 12
d334 4
a337 2
      case PIPE_SHADER_CAP_MAX_CONSTS:
         return 224;
a343 1
      case PIPE_SHADER_CAP_MAX_ADDRS:
d369 3
a371 2
      default:
         debug_printf("Unexpected fragment shader query %u\n", param);
d374 3
a376 1
      break;
d393 4
a396 2
      case PIPE_SHADER_CAP_MAX_CONSTS:
         return 256;
a402 2
      case PIPE_SHADER_CAP_MAX_ADDRS:
         return 1;
d423 3
a425 2
      default:
         debug_printf("Unexpected vertex shader query %u\n", param);
d428 3
a430 1
      break;
@


