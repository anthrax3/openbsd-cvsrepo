head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.11.09.02.46.54;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.05.14.01.10;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.11.09.02.31.36;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/


#include "os/os_thread.h"
#include "pipe/p_state.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_double_list.h"

#include "svga_cmd.h"
#include "svga_context.h"
#include "svga_debug.h"
#include "svga_resource_buffer.h"
#include "svga_resource_buffer_upload.h"
#include "svga_screen.h"
#include "svga_winsys.h"

/**
 * Describes a complete SVGA_3D_CMD_UPDATE_GB_IMAGE command
 *
 */
struct svga_3d_update_gb_image {
   SVGA3dCmdHeader header;
   SVGA3dCmdUpdateGBImage body;
};

struct svga_3d_invalidate_gb_image {
   SVGA3dCmdHeader header;
   SVGA3dCmdInvalidateGBImage body;
};


/**
 * Allocate a winsys_buffer (ie. DMA, aka GMR memory).
 *
 * It will flush and retry in case the first attempt to create a DMA buffer
 * fails, so it should not be called from any function involved in flushing
 * to avoid recursion.
 */
struct svga_winsys_buffer *
svga_winsys_buffer_create( struct svga_context *svga,
                           unsigned alignment,
                           unsigned usage,
                           unsigned size )
{
   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
   struct svga_winsys_screen *sws = svgascreen->sws;
   struct svga_winsys_buffer *buf;

   /* Just try */
   buf = sws->buffer_create(sws, alignment, usage, size);
   if (!buf) {
      SVGA_DBG(DEBUG_DMA|DEBUG_PERF, "flushing context to find %d bytes GMR\n",
               size);

      /* Try flushing all pending DMAs */
      svga_context_flush(svga, NULL);
      buf = sws->buffer_create(sws, alignment, usage, size);
   }

   return buf;
}


/**
 * Destroy HW storage if separate from the host surface.
 * In the GB case, the HW storage is associated with the host surface
 * and is therefore a No-op.
 */
void
svga_buffer_destroy_hw_storage(struct svga_screen *ss, struct svga_buffer *sbuf)
{
   struct svga_winsys_screen *sws = ss->sws;

   assert(!sbuf->map.count);
   assert(sbuf->hwbuf);
   if (sbuf->hwbuf) {
      sws->buffer_destroy(sws, sbuf->hwbuf);
      sbuf->hwbuf = NULL;
   }
}



/**
 * Allocate DMA'ble or Updatable storage for the buffer.
 *
 * Called before mapping a buffer.
 */
enum pipe_error
svga_buffer_create_hw_storage(struct svga_screen *ss,
                              struct svga_buffer *sbuf)
{
   assert(!sbuf->user);

   if (ss->sws->have_gb_objects) {
      assert(sbuf->handle || !sbuf->dma.pending);
      return svga_buffer_create_host_surface(ss, sbuf);
   }
   if (!sbuf->hwbuf) {
      struct svga_winsys_screen *sws = ss->sws;
      unsigned alignment = 16;
      unsigned usage = 0;
      unsigned size = sbuf->b.b.width0;

      sbuf->hwbuf = sws->buffer_create(sws, alignment, usage, size);
      if (!sbuf->hwbuf)
         return PIPE_ERROR_OUT_OF_MEMORY;

      assert(!sbuf->dma.pending);
   }

   return PIPE_OK;
}



enum pipe_error
svga_buffer_create_host_surface(struct svga_screen *ss,
                                struct svga_buffer *sbuf)
{
   assert(!sbuf->user);

   if (!sbuf->handle) {
      sbuf->key.flags = 0;

      sbuf->key.format = SVGA3D_BUFFER;
      if (sbuf->b.b.bind & PIPE_BIND_VERTEX_BUFFER)
         sbuf->key.flags |= SVGA3D_SURFACE_HINT_VERTEXBUFFER;
      if (sbuf->b.b.bind & PIPE_BIND_INDEX_BUFFER)
         sbuf->key.flags |= SVGA3D_SURFACE_HINT_INDEXBUFFER;

      sbuf->key.size.width = sbuf->b.b.width0;
      sbuf->key.size.height = 1;
      sbuf->key.size.depth = 1;

      sbuf->key.numFaces = 1;
      sbuf->key.numMipLevels = 1;
      sbuf->key.cachable = 1;

      SVGA_DBG(DEBUG_DMA, "surface_create for buffer sz %d\n", sbuf->b.b.width0);

      sbuf->handle = svga_screen_surface_create(ss, &sbuf->key);
      if (!sbuf->handle)
         return PIPE_ERROR_OUT_OF_MEMORY;

      /* Always set the discard flag on the first time the buffer is written
       * as svga_screen_surface_create might have passed a recycled host
       * buffer.
       */
      sbuf->dma.flags.discard = TRUE;

      SVGA_DBG(DEBUG_DMA, "   --> got sid %p sz %d (buffer)\n", sbuf->handle, sbuf->b.b.width0);
   }

   return PIPE_OK;
}


void
svga_buffer_destroy_host_surface(struct svga_screen *ss,
                                 struct svga_buffer *sbuf)
{
   if (sbuf->handle) {
      SVGA_DBG(DEBUG_DMA, " ungrab sid %p sz %d\n", sbuf->handle, sbuf->b.b.width0);
      svga_screen_surface_destroy(ss, &sbuf->key, &sbuf->handle);
   }
}


/**
 * Insert a number of preliminary UPDATE_GB_IMAGE commands in the
 * command buffer, equal to the current number of mapped ranges.
 * The UPDATE_GB_IMAGE commands will be patched with the
 * actual ranges just before flush.
 */
static enum pipe_error
svga_buffer_upload_gb_command(struct svga_context *svga,
			      struct svga_buffer *sbuf)
{
   struct svga_winsys_context *swc = svga->swc;
   SVGA3dCmdUpdateGBImage *cmd;
   struct svga_3d_update_gb_image *ccmd = NULL;
   uint32 numBoxes = sbuf->map.num_ranges;
   struct pipe_resource *dummy;
   unsigned int i;

   assert(numBoxes);
   assert(sbuf->dma.updates == NULL);

   if (sbuf->dma.flags.discard) {
      struct svga_3d_invalidate_gb_image *cicmd = NULL;
      SVGA3dCmdInvalidateGBImage *icmd;

      /* Allocate FIFO space for one INVALIDATE_GB_IMAGE command followed by
       * 'numBoxes' UPDATE_GB_IMAGE commands.  Allocate all at once rather
       * than with separate commands because we need to properly deal with
       * filling the command buffer.
       */
      icmd = SVGA3D_FIFOReserve(swc,
				SVGA_3D_CMD_INVALIDATE_GB_IMAGE,
				sizeof *icmd + numBoxes * sizeof *ccmd,
				2);
      if (!icmd)
	 return PIPE_ERROR_OUT_OF_MEMORY;

      cicmd = container_of(icmd, cicmd, body);
      cicmd->header.size = sizeof *icmd;
      swc->surface_relocation(swc, &icmd->image.sid, NULL, sbuf->handle,
                              (SVGA_RELOC_WRITE |
                               SVGA_RELOC_INTERNAL |
                               SVGA_RELOC_DMA));
      icmd->image.face = 0;
      icmd->image.mipmap = 0;

      /* initialize the first UPDATE_GB_IMAGE command */
      ccmd = (struct svga_3d_update_gb_image *) &icmd[1];
      ccmd->header.id = SVGA_3D_CMD_UPDATE_GB_IMAGE;
      cmd = &ccmd->body;

   } else {
      /* Allocate FIFO space for 'numBoxes' UPDATE_GB_IMAGE commands */
      cmd = SVGA3D_FIFOReserve(swc,
			       SVGA_3D_CMD_UPDATE_GB_IMAGE,
			       sizeof *cmd + (numBoxes - 1) * sizeof *ccmd,
			       1);
      if (!cmd)
	 return PIPE_ERROR_OUT_OF_MEMORY;

      ccmd = container_of(cmd, ccmd, body);
   }

   /* Init the first UPDATE_GB_IMAGE command */
   ccmd->header.size = sizeof *cmd;
   swc->surface_relocation(swc, &cmd->image.sid, NULL, sbuf->handle,
			   SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);
   cmd->image.face = 0;
   cmd->image.mipmap = 0;

   /* Save pointer to the first UPDATE_GB_IMAGE command so that we can
    * fill in the box info below.
    */
   sbuf->dma.updates = ccmd;

   /*
    * Copy the relocation info, face and mipmap to all
    * subsequent commands. NOTE: For winsyses that actually
    * patch the image.sid member at flush time, this will fail
    * miserably. For those we need to add as many relocations
    * as there are copy boxes.
    */

   for (i = 1; i < numBoxes; ++i) {
      memcpy(++ccmd, sbuf->dma.updates, sizeof *ccmd);
   }

   /* Increment reference count */
   sbuf->dma.svga = svga;
   dummy = NULL;
   pipe_resource_reference(&dummy, &sbuf->b.b);
   SVGA_FIFOCommitAll(swc);

   sbuf->dma.flags.discard = FALSE;

   return PIPE_OK;
}


/**
 * Variant of SVGA3D_BufferDMA which leaves the copy box temporarily in blank.
 */
static enum pipe_error
svga_buffer_upload_command(struct svga_context *svga,
                           struct svga_buffer *sbuf)
{
   struct svga_winsys_context *swc = svga->swc;
   struct svga_winsys_buffer *guest = sbuf->hwbuf;
   struct svga_winsys_surface *host = sbuf->handle;
   SVGA3dTransferType transfer = SVGA3D_WRITE_HOST_VRAM;
   SVGA3dCmdSurfaceDMA *cmd;
   uint32 numBoxes = sbuf->map.num_ranges;
   SVGA3dCopyBox *boxes;
   SVGA3dCmdSurfaceDMASuffix *pSuffix;
   unsigned region_flags;
   unsigned surface_flags;
   struct pipe_resource *dummy;

   if (svga_have_gb_objects(svga))
      return svga_buffer_upload_gb_command(svga, sbuf);

   if (transfer == SVGA3D_WRITE_HOST_VRAM) {
      region_flags = SVGA_RELOC_READ;
      surface_flags = SVGA_RELOC_WRITE;
   }
   else if (transfer == SVGA3D_READ_HOST_VRAM) {
      region_flags = SVGA_RELOC_WRITE;
      surface_flags = SVGA_RELOC_READ;
   }
   else {
      assert(0);
      return PIPE_ERROR_BAD_INPUT;
   }

   assert(numBoxes);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SURFACE_DMA,
                            sizeof *cmd + numBoxes * sizeof *boxes + sizeof *pSuffix,
                            2);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->region_relocation(swc, &cmd->guest.ptr, guest, 0, region_flags);
   cmd->guest.pitch = 0;

   swc->surface_relocation(swc, &cmd->host.sid, NULL, host, surface_flags);
   cmd->host.face = 0;
   cmd->host.mipmap = 0;

   cmd->transfer = transfer;

   sbuf->dma.boxes = (SVGA3dCopyBox *)&cmd[1];
   sbuf->dma.svga = svga;

   /* Increment reference count */
   dummy = NULL;
   pipe_resource_reference(&dummy, &sbuf->b.b);

   pSuffix = (SVGA3dCmdSurfaceDMASuffix *)((uint8_t*)cmd + sizeof *cmd + numBoxes * sizeof *boxes);
   pSuffix->suffixSize = sizeof *pSuffix;
   pSuffix->maximumOffset = sbuf->b.b.width0;
   pSuffix->flags = sbuf->dma.flags;

   SVGA_FIFOCommitAll(swc);

   sbuf->dma.flags.discard = FALSE;

   return PIPE_OK;
}


/**
 * Patch up the upload DMA command reserved by svga_buffer_upload_command
 * with the final ranges.
 */
void
svga_buffer_upload_flush(struct svga_context *svga,
			 struct svga_buffer *sbuf)
{
   unsigned i;
   struct pipe_resource *dummy;

   if (!sbuf->dma.pending) {
      //debug_printf("no dma pending on buffer\n");
      return;
   }

   assert(sbuf->handle);
   assert(sbuf->map.num_ranges);
   assert(sbuf->dma.svga == svga);

   /*
    * Patch the DMA/update command with the final copy box.
    */
   if (svga_have_gb_objects(svga)) {
      struct svga_3d_update_gb_image *update = sbuf->dma.updates;
      assert(update);

      for (i = 0; i < sbuf->map.num_ranges; ++i, ++update) {
         SVGA3dBox *box = &update->body.box;

         SVGA_DBG(DEBUG_DMA, "  bytes %u - %u\n",
                  sbuf->map.ranges[i].start, sbuf->map.ranges[i].end);

         box->x = sbuf->map.ranges[i].start;
         box->y = 0;
         box->z = 0;
         box->w = sbuf->map.ranges[i].end - sbuf->map.ranges[i].start;
         box->h = 1;
         box->d = 1;

         assert(box->x <= sbuf->b.b.width0);
         assert(box->x + box->w <= sbuf->b.b.width0);
      }
   }
   else {
      assert(sbuf->hwbuf);
      assert(sbuf->dma.boxes);
      SVGA_DBG(DEBUG_DMA, "dma to sid %p\n", sbuf->handle);

      for (i = 0; i < sbuf->map.num_ranges; ++i) {
         SVGA3dCopyBox *box = sbuf->dma.boxes + i;

         SVGA_DBG(DEBUG_DMA, "  bytes %u - %u\n",
               sbuf->map.ranges[i].start, sbuf->map.ranges[i].end);

         box->x = sbuf->map.ranges[i].start;
         box->y = 0;
         box->z = 0;
         box->w = sbuf->map.ranges[i].end - sbuf->map.ranges[i].start;
         box->h = 1;
         box->d = 1;
         box->srcx = sbuf->map.ranges[i].start;
         box->srcy = 0;
         box->srcz = 0;

         assert(box->x <= sbuf->b.b.width0);
         assert(box->x + box->w <= sbuf->b.b.width0);
      }
   }

   /* Reset sbuf for next use/upload */

   sbuf->map.num_ranges = 0;

   assert(sbuf->head.prev && sbuf->head.next);
   LIST_DEL(&sbuf->head);  /* remove from svga->dirty_buffers list */
#ifdef DEBUG
   sbuf->head.next = sbuf->head.prev = NULL;
#endif
   sbuf->dma.pending = FALSE;
   sbuf->dma.flags.discard = FALSE;
   sbuf->dma.flags.unsynchronized = FALSE;

   sbuf->dma.svga = NULL;
   sbuf->dma.boxes = NULL;
   sbuf->dma.updates = NULL;

   /* Decrement reference count (and potentially destroy) */
   dummy = &sbuf->b.b;
   pipe_resource_reference(&dummy, NULL);
}


/**
 * Note a dirty range.
 *
 * This function only notes the range down. It doesn't actually emit a DMA
 * upload command. That only happens when a context tries to refer to this
 * buffer, and the DMA upload command is added to that context's command
 * buffer.
 *
 * We try to lump as many contiguous DMA transfers together as possible.
 */
void
svga_buffer_add_range(struct svga_buffer *sbuf,
                      unsigned start,
                      unsigned end)
{
   unsigned i;
   unsigned nearest_range;
   unsigned nearest_dist;

   assert(end > start);

   if (sbuf->map.num_ranges < SVGA_BUFFER_MAX_RANGES) {
      nearest_range = sbuf->map.num_ranges;
      nearest_dist = ~0;
   } else {
      nearest_range = SVGA_BUFFER_MAX_RANGES - 1;
      nearest_dist = 0;
   }

   /*
    * Try to grow one of the ranges.
    */

   for (i = 0; i < sbuf->map.num_ranges; ++i) {
      int left_dist;
      int right_dist;
      int dist;

      left_dist = start - sbuf->map.ranges[i].end;
      right_dist = sbuf->map.ranges[i].start - end;
      dist = MAX2(left_dist, right_dist);

      if (dist <= 0) {
         /*
          * Ranges are contiguous or overlapping -- extend this one and return.
          *
          * Note that it is not this function's task to prevent overlapping
          * ranges, as the GMR was already given so it is too late to do
          * anything.  If the ranges overlap here it must surely be because
          * PIPE_TRANSFER_UNSYNCHRONIZED was set.
          */

         sbuf->map.ranges[i].start = MIN2(sbuf->map.ranges[i].start, start);
         sbuf->map.ranges[i].end   = MAX2(sbuf->map.ranges[i].end,   end);
         return;
      }
      else {
         /*
          * Discontiguous ranges -- keep track of the nearest range.
          */

         if (dist < nearest_dist) {
            nearest_range = i;
            nearest_dist = dist;
         }
      }
   }

   /*
    * We cannot add a new range to an existing DMA command, so patch-up the
    * pending DMA upload and start clean.
    */

   svga_buffer_upload_flush(sbuf->dma.svga, sbuf);

   assert(!sbuf->dma.pending);
   assert(!sbuf->dma.svga);
   assert(!sbuf->dma.boxes);

   if (sbuf->map.num_ranges < SVGA_BUFFER_MAX_RANGES) {
      /*
       * Add a new range.
       */

      sbuf->map.ranges[sbuf->map.num_ranges].start = start;
      sbuf->map.ranges[sbuf->map.num_ranges].end = end;
      ++sbuf->map.num_ranges;
   } else {
      /*
       * Everything else failed, so just extend the nearest range.
       *
       * It is OK to do this because we always keep a local copy of the
       * host buffer data, for SW TNL, and the host never modifies the buffer.
       */

      assert(nearest_range < SVGA_BUFFER_MAX_RANGES);
      assert(nearest_range < sbuf->map.num_ranges);
      sbuf->map.ranges[nearest_range].start = MIN2(sbuf->map.ranges[nearest_range].start, start);
      sbuf->map.ranges[nearest_range].end   = MAX2(sbuf->map.ranges[nearest_range].end,   end);
   }
}



/**
 * Copy the contents of the malloc buffer to a hardware buffer.
 */
static enum pipe_error
svga_buffer_update_hw(struct svga_context *svga, struct svga_buffer *sbuf)
{
   assert(!sbuf->user);
   if (!svga_buffer_has_hw_storage(sbuf)) {
      struct svga_screen *ss = svga_screen(sbuf->b.b.screen);
      enum pipe_error ret;
      boolean retry;
      void *map;

      assert(sbuf->swbuf);
      if (!sbuf->swbuf)
         return PIPE_ERROR;

      ret = svga_buffer_create_hw_storage(svga_screen(sbuf->b.b.screen),
					  sbuf);
      if (ret != PIPE_OK)
         return ret;

      pipe_mutex_lock(ss->swc_mutex);
      map = svga_buffer_hw_storage_map(svga, sbuf, PIPE_TRANSFER_WRITE, &retry);
      assert(map);
      assert(!retry);
      if (!map) {
	 pipe_mutex_unlock(ss->swc_mutex);
         svga_buffer_destroy_hw_storage(ss, sbuf);
         return PIPE_ERROR;
      }

      memcpy(map, sbuf->swbuf, sbuf->b.b.width0);
      svga_buffer_hw_storage_unmap(svga, sbuf);

      /* This user/malloc buffer is now indistinguishable from a gpu buffer */
      assert(!sbuf->map.count);
      if (!sbuf->map.count) {
         if (sbuf->user)
            sbuf->user = FALSE;
         else
            align_free(sbuf->swbuf);
         sbuf->swbuf = NULL;
      }

      pipe_mutex_unlock(ss->swc_mutex);
   }

   return PIPE_OK;
}


/**
 * Upload the buffer to the host in a piecewise fashion.
 *
 * Used when the buffer is too big to fit in the GMR aperture.
 * This function should never get called in the guest-backed case
 * since we always have a full-sized hardware storage backing the
 * host surface.
 */
static enum pipe_error
svga_buffer_upload_piecewise(struct svga_screen *ss,
                             struct svga_context *svga,
                             struct svga_buffer *sbuf)
{
   struct svga_winsys_screen *sws = ss->sws;
   const unsigned alignment = sizeof(void *);
   const unsigned usage = 0;
   unsigned i;

   assert(sbuf->map.num_ranges);
   assert(!sbuf->dma.pending);
   assert(!svga_have_gb_objects(svga));

   SVGA_DBG(DEBUG_DMA, "dma to sid %p\n", sbuf->handle);

   for (i = 0; i < sbuf->map.num_ranges; ++i) {
      struct svga_buffer_range *range = &sbuf->map.ranges[i];
      unsigned offset = range->start;
      unsigned size = range->end - range->start;

      while (offset < range->end) {
         struct svga_winsys_buffer *hwbuf;
         uint8_t *map;
         enum pipe_error ret;

         if (offset + size > range->end)
            size = range->end - offset;

         hwbuf = sws->buffer_create(sws, alignment, usage, size);
         while (!hwbuf) {
            size /= 2;
            if (!size)
               return PIPE_ERROR_OUT_OF_MEMORY;
            hwbuf = sws->buffer_create(sws, alignment, usage, size);
         }

         SVGA_DBG(DEBUG_DMA, "  bytes %u - %u\n",
                  offset, offset + size);

         map = sws->buffer_map(sws, hwbuf,
                               PIPE_TRANSFER_WRITE |
                               PIPE_TRANSFER_DISCARD_RANGE);
         assert(map);
         if (map) {
            memcpy(map, (const char *) sbuf->swbuf + offset, size);
            sws->buffer_unmap(sws, hwbuf);
         }

         ret = SVGA3D_BufferDMA(svga->swc,
                                hwbuf, sbuf->handle,
                                SVGA3D_WRITE_HOST_VRAM,
                                size, 0, offset, sbuf->dma.flags);
         if (ret != PIPE_OK) {
            svga_context_flush(svga, NULL);
            ret =  SVGA3D_BufferDMA(svga->swc,
                                    hwbuf, sbuf->handle,
                                    SVGA3D_WRITE_HOST_VRAM,
                                    size, 0, offset, sbuf->dma.flags);
            assert(ret == PIPE_OK);
         }

         sbuf->dma.flags.discard = FALSE;

         sws->buffer_destroy(sws, hwbuf);

         offset += size;
      }
   }

   sbuf->map.num_ranges = 0;

   return PIPE_OK;
}


/**
 * Get (or create/upload) the winsys surface handle so that we can
 * refer to this buffer in fifo commands.
 * This function will create the host surface, and in the GB case also the
 * hardware storage. In the non-GB case, the hardware storage will be created
 * if there are mapped ranges and the data is currently in a malloc'ed buffer.
 */
struct svga_winsys_surface *
svga_buffer_handle(struct svga_context *svga,
                   struct pipe_resource *buf)
{
   struct pipe_screen *screen = svga->pipe.screen;
   struct svga_screen *ss = svga_screen(screen);
   struct svga_buffer *sbuf;
   enum pipe_error ret;

   if (!buf)
      return NULL;

   sbuf = svga_buffer(buf);

   assert(!sbuf->user);

   if (!sbuf->handle) {
      /* This call will set sbuf->handle */
      if (svga_have_gb_objects(svga)) {
	 ret = svga_buffer_update_hw(svga, sbuf);
      } else {
	 ret = svga_buffer_create_host_surface(ss, sbuf);
      }
      if (ret != PIPE_OK)
	 return NULL;
   }

   assert(sbuf->handle);

   if (sbuf->map.num_ranges) {
      if (!sbuf->dma.pending) {
         /*
          * No pending DMA upload yet, so insert a DMA upload command now.
          */

         /*
          * Migrate the data from swbuf -> hwbuf if necessary.
          */
         ret = svga_buffer_update_hw(svga, sbuf);
         if (ret == PIPE_OK) {
            /*
             * Queue a dma command.
             */

            ret = svga_buffer_upload_command(svga, sbuf);
            if (ret == PIPE_ERROR_OUT_OF_MEMORY) {
               svga_context_flush(svga, NULL);
               ret = svga_buffer_upload_command(svga, sbuf);
               assert(ret == PIPE_OK);
            }
            if (ret == PIPE_OK) {
               sbuf->dma.pending = TRUE;
               assert(!sbuf->head.prev && !sbuf->head.next);
               LIST_ADDTAIL(&sbuf->head, &svga->dirty_buffers);
            }
         }
         else if (ret == PIPE_ERROR_OUT_OF_MEMORY) {
            /*
             * The buffer is too big to fit in the GMR aperture, so break it in
             * smaller pieces.
             */
            ret = svga_buffer_upload_piecewise(ss, svga, sbuf);
         }

         if (ret != PIPE_OK) {
            /*
             * Something unexpected happened above. There is very little that
             * we can do other than proceeding while ignoring the dirty ranges.
             */
            assert(0);
            sbuf->map.num_ranges = 0;
         }
      }
      else {
         /*
          * There a pending dma already. Make sure it is from this context.
          */
         assert(sbuf->dma.svga == svga);
      }
   }

   assert(!sbuf->map.num_ranges || sbuf->dma.pending);

   return sbuf->handle;
}



void
svga_context_flush_buffers(struct svga_context *svga)
{
   struct list_head *curr, *next;
   struct svga_buffer *sbuf;

   curr = svga->dirty_buffers.next;
   next = curr->next;
   while(curr != &svga->dirty_buffers) {
      sbuf = LIST_ENTRY(struct svga_buffer, curr, head);

      assert(p_atomic_read(&sbuf->b.b.reference.count) != 0);
      assert(sbuf->dma.pending);

      svga_buffer_upload_flush(svga, sbuf);

      curr = next;
      next = curr->next;
   }
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.2
@
text
@d33 1
d43 14
d90 5
d111 1
a111 1
 * Allocate DMA'ble storage for the buffer.
d121 4
d197 98
d313 3
d341 1
a341 1
   swc->surface_relocation(swc, &cmd->host.sid, host, surface_flags);
d373 1
a373 1
                         struct svga_buffer *sbuf)
a374 1
   SVGA3dCopyBox *boxes;
d379 1
a383 1
   assert(sbuf->hwbuf);
a385 1
   assert(sbuf->dma.boxes);
d388 1
a388 1
    * Patch the DMA command with the final copy box.
d390 25
d416 2
a417 1
   SVGA_DBG(DEBUG_DMA, "dma to sid %p\n", sbuf->handle);
d419 1
a419 3
   boxes = sbuf->dma.boxes;
   for (i = 0; i < sbuf->map.num_ranges; ++i) {
      SVGA_DBG(DEBUG_DMA, "  bytes %u - %u\n",
d422 13
a434 9
      boxes[i].x = sbuf->map.ranges[i].start;
      boxes[i].y = 0;
      boxes[i].z = 0;
      boxes[i].w = sbuf->map.ranges[i].end - sbuf->map.ranges[i].start;
      boxes[i].h = 1;
      boxes[i].d = 1;
      boxes[i].srcx = sbuf->map.ranges[i].start;
      boxes[i].srcy = 0;
      boxes[i].srcz = 0;
d437 2
d442 4
a445 2
   LIST_DEL(&sbuf->head);

d452 1
d568 1
a568 1
svga_buffer_update_hw(struct svga_screen *ss, struct svga_buffer *sbuf)
d571 2
a572 1
   if (!sbuf->hwbuf) {
d574 1
d581 2
a582 1
      ret = svga_buffer_create_hw_storage(ss, sbuf);
d587 1
a587 1
      map = ss->sws->buffer_map(ss->sws, sbuf->hwbuf, PIPE_TRANSFER_WRITE);
d589 1
d597 1
a597 1
      ss->sws->buffer_unmap(ss->sws, sbuf->hwbuf);
d620 3
d636 1
d700 2
a701 3


/* Get (or create/upload) the winsys surface handle so that we can
d703 3
a720 1
   assert(!sbuf->map.count);
d724 6
a729 1
      ret = svga_buffer_create_host_surface(ss, sbuf);
d745 1
a745 1
         ret = svga_buffer_update_hw(ss, sbuf);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d505 1
a505 1
            memcpy(map, sbuf->swbuf, size);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a25 1
#include "svga_cmd.h"
d27 1
a30 1
#include "os/os_thread.h"
d34 1
d36 1
a36 1
#include "svga_screen.h"
d39 1
a40 1
#include "svga_debug.h"
d52 1
a52 1
                           unsigned alignment, 
d59 1
a59 1
   
d64 2
a65 2
               size); 
      
d70 1
a70 1
   
d82 1
a82 1
   if(sbuf->hwbuf) {
d91 2
a92 2
 * Allocate DMA'ble storage for the buffer. 
 * 
d101 1
a101 1
   if(!sbuf->hwbuf) {
d106 1
a106 1
      
d108 1
a108 1
      if(!sbuf->hwbuf)
d110 1
a110 1
      
d113 1
a113 1
   
d125 1
a125 1
   if(!sbuf->handle) {
d127 1
a127 1
      
d129 1
a129 1
      if(sbuf->b.b.bind & PIPE_BIND_VERTEX_BUFFER)
d131 1
a131 1
      if(sbuf->b.b.bind & PIPE_BIND_INDEX_BUFFER)
d133 1
a133 1
      
d137 1
a137 1
      
d141 1
a141 1
      
d145 1
a145 1
      if(!sbuf->handle)
d147 1
a147 1
   
d156 1
a156 1
   
d158 1
a158 1
}   
d165 1
a165 1
   if(sbuf->handle) {
d169 1
a169 1
}   
d191 1
a191 1
   if(transfer == SVGA3D_WRITE_HOST_VRAM) {
d195 1
a195 1
   else if(transfer == SVGA3D_READ_HOST_VRAM) {
d210 1
a210 1
   if(!cmd)
d258 1
a258 1
   assert(sbuf->handle); 
d263 1
a263 1
   
d271 1
a271 1
   for(i = 0; i < sbuf->map.num_ranges; ++i) {
d290 1
a290 3
#ifdef DEBUG
   sbuf->head.next = sbuf->head.prev = NULL; 
#endif
d309 3
a311 2
 * buffer, and the DMA upload command is added to that context's command buffer.
 * 
d324 1
a324 1
   
d337 1
a337 1
   for(i = 0; i < sbuf->map.num_ranges; ++i) {
d411 1
a411 1
static INLINE enum pipe_error
d415 1
a415 1
   if(!sbuf->hwbuf) {
d418 1
a418 1
      
d420 1
a420 1
      if(!sbuf->swbuf)
d422 1
a422 1
      
d424 1
a424 1
      if(ret != PIPE_OK)
d430 1
a430 1
      if(!map) {
d441 2
a442 2
      if(!sbuf->map.count) {
         if(sbuf->user)
d448 1
a448 1
      
d451 1
a451 1
   
d461 1
a461 1
static INLINE enum pipe_error
d502 1
a502 1
                               PIPE_TRANSFER_DISCARD);
d513 1
a513 1
         if(ret != PIPE_OK) {
d550 1
a550 1
   if(!buf)
d554 1
a554 1
   
d557 2
a558 2
   
   if(!sbuf->handle) {
d560 1
a560 1
      if(ret != PIPE_OK)
d638 1
a638 1
      
d641 1
a641 1
      curr = next; 
a643 34
}


void
svga_redefine_user_buffer(struct pipe_context *pipe,
                          struct pipe_resource *resource,
                          unsigned offset,
                          unsigned size)
{
   struct svga_screen *ss = svga_screen(pipe->screen);
   struct svga_context *svga = svga_context(pipe);
   struct svga_buffer *sbuf = svga_buffer(resource);

   assert(sbuf->user);
   assert(!sbuf->dma.pending);
   assert(!sbuf->handle);
   assert(!sbuf->hwbuf);

   /*
    * Release any uploaded user buffer.
    *
    * TODO: As an optimization, we could try to update the uploaded buffer
    * instead.
    */

   pipe_resource_reference(&sbuf->uploaded.buffer, NULL);

   pipe_mutex_lock(ss->swc_mutex);

   sbuf->key.size.width = sbuf->b.b.width0 = offset + size;

   pipe_mutex_unlock(ss->swc_mutex);

   svga->dirty |= SVGA_NEW_VBUFFER | SVGA_NEW_VELEMENT;
@


1.1
log
@Initial revision
@
text
@d62 2
a63 3
   if(!buf) {

      SVGA_DBG(DEBUG_DMA|DEBUG_PERF, "flushing screen to find %d bytes GMR\n", 
d123 2
d246 1
a246 1
static void
d252 5
d294 2
d300 3
a302 3
   /* Decrement reference count */
   pipe_reference(&(sbuf->b.b.reference), NULL);
   sbuf = NULL;
a305 1

a335 6
    *
    * Note that it is not this function task to care about overlapping ranges,
    * as the GMR was already given so it is too late to do anything. Situations
    * where overlapping ranges may pose a problem should be detected via
    * pipe_context::is_resource_referenced and the context that refers to the
    * buffer should be flushed.
d350 5
d378 1
a378 2
   if(sbuf->dma.pending)
      svga_buffer_upload_flush(sbuf->dma.svga, sbuf);
d645 34
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d26 1
a27 1
#include "os/os_thread.h"
d31 1
a34 1
#include "svga_cmd.h"
d36 1
a36 1
#include "svga_debug.h"
a38 1
#include "svga_screen.h"
d40 1
d52 1
a52 1
                           unsigned alignment,
d59 1
a59 1

d62 1
a62 3
   if (!buf) {
      SVGA_DBG(DEBUG_DMA|DEBUG_PERF, "flushing context to find %d bytes GMR\n",
               size);
d64 3
d71 1
a71 1

d83 1
a83 1
   if (sbuf->hwbuf) {
d92 2
a93 2
 * Allocate DMA'ble storage for the buffer.
 *
d102 1
a102 1
   if (!sbuf->hwbuf) {
d107 1
a107 1

d109 1
a109 1
      if (!sbuf->hwbuf)
d111 1
a111 1

d114 1
a114 1

d124 1
a124 3
   assert(!sbuf->user);

   if (!sbuf->handle) {
d126 1
a126 1

d128 1
a128 1
      if (sbuf->b.b.bind & PIPE_BIND_VERTEX_BUFFER)
d130 1
a130 1
      if (sbuf->b.b.bind & PIPE_BIND_INDEX_BUFFER)
d132 1
a132 1

d136 1
a136 1

d140 1
a140 1

d144 1
a144 1
      if (!sbuf->handle)
d146 1
a146 1

d155 1
a155 1

d157 1
a157 1
}
d164 1
a164 1
   if (sbuf->handle) {
d168 1
a168 1
}
d190 1
a190 1
   if (transfer == SVGA3D_WRITE_HOST_VRAM) {
d194 1
a194 1
   else if (transfer == SVGA3D_READ_HOST_VRAM) {
d209 1
a209 1
   if (!cmd)
d245 1
a245 1
void
a250 5
   struct pipe_resource *dummy;

   if (!sbuf->dma.pending) {
      return;
   }
d252 1
a252 1
   assert(sbuf->handle);
d257 1
a257 1

d265 1
a265 1
   for (i = 0; i < sbuf->map.num_ranges; ++i) {
d284 3
a286 1

a287 2
   sbuf->dma.flags.discard = FALSE;
   sbuf->dma.flags.unsynchronized = FALSE;
d292 3
a294 3
   /* Decrement reference count (and potentially destroy) */
   dummy = &sbuf->b.b;
   pipe_resource_reference(&dummy, NULL);
d298 1
d304 2
a305 3
 * buffer, and the DMA upload command is added to that context's command
 * buffer.
 *
d318 1
a318 1

d329 6
d337 1
a337 1
   for (i = 0; i < sbuf->map.num_ranges; ++i) {
a348 5
          *
          * Note that it is not this function's task to prevent overlapping
          * ranges, as the GMR was already given so it is too late to do
          * anything.  If the ranges overlap here it must surely be because
          * PIPE_TRANSFER_UNSYNCHRONIZED was set.
d372 2
a373 1
   svga_buffer_upload_flush(sbuf->dma.svga, sbuf);
d407 1
a407 1
static enum pipe_error
d411 1
a411 1
   if (!sbuf->hwbuf) {
d414 1
a414 1

d416 1
a416 1
      if (!sbuf->swbuf)
d418 1
a418 1

d420 1
a420 1
      if (ret != PIPE_OK)
d426 1
a426 1
      if (!map) {
d437 2
a438 2
      if (!sbuf->map.count) {
         if (sbuf->user)
d444 1
a444 1

d447 1
a447 1

d457 1
a457 1
static enum pipe_error
d498 1
a498 1
                               PIPE_TRANSFER_DISCARD_RANGE);
d509 1
a509 1
         if (ret != PIPE_OK) {
d546 1
a546 1
   if (!buf)
d550 1
a550 1

d553 2
a554 2

   if (!sbuf->handle) {
d556 1
a556 1
      if (ret != PIPE_OK)
d634 1
a634 1

d637 1
a637 1
      curr = next;
@


1.1.1.3
log
@Import Mesa 9.2.2
@
text
@d505 1
a505 1
            memcpy(map, (const char *) sbuf->swbuf + offset, size);
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a32 1
#include "util/u_double_list.h"
a41 14
/**
 * Describes a complete SVGA_3D_CMD_UPDATE_GB_IMAGE command
 *
 */
struct svga_3d_update_gb_image {
   SVGA3dCmdHeader header;
   SVGA3dCmdUpdateGBImage body;
};

struct svga_3d_invalidate_gb_image {
   SVGA3dCmdHeader header;
   SVGA3dCmdInvalidateGBImage body;
};

a74 5
/**
 * Destroy HW storage if separate from the host surface.
 * In the GB case, the HW storage is associated with the host surface
 * and is therefore a No-op.
 */
d91 1
a91 1
 * Allocate DMA'ble or Updatable storage for the buffer.
a100 4
   if (ss->sws->have_gb_objects) {
      assert(sbuf->handle || !sbuf->dma.pending);
      return svga_buffer_create_host_surface(ss, sbuf);
   }
a172 98
 * Insert a number of preliminary UPDATE_GB_IMAGE commands in the
 * command buffer, equal to the current number of mapped ranges.
 * The UPDATE_GB_IMAGE commands will be patched with the
 * actual ranges just before flush.
 */
static enum pipe_error
svga_buffer_upload_gb_command(struct svga_context *svga,
			      struct svga_buffer *sbuf)
{
   struct svga_winsys_context *swc = svga->swc;
   SVGA3dCmdUpdateGBImage *cmd;
   struct svga_3d_update_gb_image *ccmd = NULL;
   uint32 numBoxes = sbuf->map.num_ranges;
   struct pipe_resource *dummy;
   unsigned int i;

   assert(numBoxes);
   assert(sbuf->dma.updates == NULL);

   if (sbuf->dma.flags.discard) {
      struct svga_3d_invalidate_gb_image *cicmd = NULL;
      SVGA3dCmdInvalidateGBImage *icmd;

      /* Allocate FIFO space for one INVALIDATE_GB_IMAGE command followed by
       * 'numBoxes' UPDATE_GB_IMAGE commands.  Allocate all at once rather
       * than with separate commands because we need to properly deal with
       * filling the command buffer.
       */
      icmd = SVGA3D_FIFOReserve(swc,
				SVGA_3D_CMD_INVALIDATE_GB_IMAGE,
				sizeof *icmd + numBoxes * sizeof *ccmd,
				2);
      if (!icmd)
	 return PIPE_ERROR_OUT_OF_MEMORY;

      cicmd = container_of(icmd, cicmd, body);
      cicmd->header.size = sizeof *icmd;
      swc->surface_relocation(swc, &icmd->image.sid, NULL, sbuf->handle,
                              (SVGA_RELOC_WRITE |
                               SVGA_RELOC_INTERNAL |
                               SVGA_RELOC_DMA));
      icmd->image.face = 0;
      icmd->image.mipmap = 0;

      /* initialize the first UPDATE_GB_IMAGE command */
      ccmd = (struct svga_3d_update_gb_image *) &icmd[1];
      ccmd->header.id = SVGA_3D_CMD_UPDATE_GB_IMAGE;
      cmd = &ccmd->body;

   } else {
      /* Allocate FIFO space for 'numBoxes' UPDATE_GB_IMAGE commands */
      cmd = SVGA3D_FIFOReserve(swc,
			       SVGA_3D_CMD_UPDATE_GB_IMAGE,
			       sizeof *cmd + (numBoxes - 1) * sizeof *ccmd,
			       1);
      if (!cmd)
	 return PIPE_ERROR_OUT_OF_MEMORY;

      ccmd = container_of(cmd, ccmd, body);
   }

   /* Init the first UPDATE_GB_IMAGE command */
   ccmd->header.size = sizeof *cmd;
   swc->surface_relocation(swc, &cmd->image.sid, NULL, sbuf->handle,
			   SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);
   cmd->image.face = 0;
   cmd->image.mipmap = 0;

   /* Save pointer to the first UPDATE_GB_IMAGE command so that we can
    * fill in the box info below.
    */
   sbuf->dma.updates = ccmd;

   /*
    * Copy the relocation info, face and mipmap to all
    * subsequent commands. NOTE: For winsyses that actually
    * patch the image.sid member at flush time, this will fail
    * miserably. For those we need to add as many relocations
    * as there are copy boxes.
    */

   for (i = 1; i < numBoxes; ++i) {
      memcpy(++ccmd, sbuf->dma.updates, sizeof *ccmd);
   }

   /* Increment reference count */
   sbuf->dma.svga = svga;
   dummy = NULL;
   pipe_resource_reference(&dummy, &sbuf->b.b);
   SVGA_FIFOCommitAll(swc);

   sbuf->dma.flags.discard = FALSE;

   return PIPE_OK;
}


/**
a190 3
   if (svga_have_gb_objects(svga))
      return svga_buffer_upload_gb_command(svga, sbuf);

d216 1
a216 1
   swc->surface_relocation(swc, &cmd->host.sid, NULL, host, surface_flags);
d248 1
a248 1
			 struct svga_buffer *sbuf)
d250 1
a254 1
      //debug_printf("no dma pending on buffer\n");
d259 1
d262 1
d265 1
a265 1
    * Patch the DMA/update command with the final copy box.
a266 3
   if (svga_have_gb_objects(svga)) {
      struct svga_3d_update_gb_image *update = sbuf->dma.updates;
      assert(update);
d268 1
a268 2
      for (i = 0; i < sbuf->map.num_ranges; ++i, ++update) {
         SVGA3dBox *box = &update->body.box;
d270 3
a272 23
         SVGA_DBG(DEBUG_DMA, "  bytes %u - %u\n",
                  sbuf->map.ranges[i].start, sbuf->map.ranges[i].end);

         box->x = sbuf->map.ranges[i].start;
         box->y = 0;
         box->z = 0;
         box->w = sbuf->map.ranges[i].end - sbuf->map.ranges[i].start;
         box->h = 1;
         box->d = 1;

         assert(box->x <= sbuf->b.b.width0);
         assert(box->x + box->w <= sbuf->b.b.width0);
      }
   }
   else {
      assert(sbuf->hwbuf);
      assert(sbuf->dma.boxes);
      SVGA_DBG(DEBUG_DMA, "dma to sid %p\n", sbuf->handle);

      for (i = 0; i < sbuf->map.num_ranges; ++i) {
         SVGA3dCopyBox *box = sbuf->dma.boxes + i;

         SVGA_DBG(DEBUG_DMA, "  bytes %u - %u\n",
d275 9
a283 13
         box->x = sbuf->map.ranges[i].start;
         box->y = 0;
         box->z = 0;
         box->w = sbuf->map.ranges[i].end - sbuf->map.ranges[i].start;
         box->h = 1;
         box->d = 1;
         box->srcx = sbuf->map.ranges[i].start;
         box->srcy = 0;
         box->srcz = 0;

         assert(box->x <= sbuf->b.b.width0);
         assert(box->x + box->w <= sbuf->b.b.width0);
      }
a285 2
   /* Reset sbuf for next use/upload */

d289 2
a290 4
   LIST_DEL(&sbuf->head);  /* remove from svga->dirty_buffers list */
#ifdef DEBUG
   sbuf->head.next = sbuf->head.prev = NULL;
#endif
a296 1
   sbuf->dma.updates = NULL;
d412 1
a412 1
svga_buffer_update_hw(struct svga_context *svga, struct svga_buffer *sbuf)
d415 1
a415 2
   if (!svga_buffer_has_hw_storage(sbuf)) {
      struct svga_screen *ss = svga_screen(sbuf->b.b.screen);
a416 1
      boolean retry;
d423 1
a423 2
      ret = svga_buffer_create_hw_storage(svga_screen(sbuf->b.b.screen),
					  sbuf);
d428 1
a428 1
      map = svga_buffer_hw_storage_map(svga, sbuf, PIPE_TRANSFER_WRITE, &retry);
a429 1
      assert(!retry);
d437 1
a437 1
      svga_buffer_hw_storage_unmap(svga, sbuf);
a459 3
 * This function should never get called in the guest-backed case
 * since we always have a full-sized hardware storage backing the
 * host surface.
a472 1
   assert(!svga_have_gb_objects(svga));
d536 3
a538 2
/**
 * Get (or create/upload) the winsys surface handle so that we can
a539 3
 * This function will create the host surface, and in the GB case also the
 * hardware storage. In the non-GB case, the hardware storage will be created
 * if there are mapped ranges and the data is currently in a malloc'ed buffer.
d555 1
d559 1
a559 6
      /* This call will set sbuf->handle */
      if (svga_have_gb_objects(svga)) {
	 ret = svga_buffer_update_hw(svga, sbuf);
      } else {
	 ret = svga_buffer_create_host_surface(ss, sbuf);
      }
d575 1
a575 1
         ret = svga_buffer_update_hw(svga, sbuf);
@


