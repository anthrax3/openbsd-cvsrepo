head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.11;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.01;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "util/u_inlines.h"
#include "pipe/p_defines.h"
#include "util/u_math.h"
#include "util/u_upload_mgr.h"

#include "svga_context.h"
#include "svga_state.h"
#include "svga_draw.h"
#include "svga_tgsi.h"
#include "svga_screen.h"
#include "svga_resource_buffer.h"
#include "svga_hw_reg.h"



static enum pipe_error
emit_hw_vs_vdecl(struct svga_context *svga, unsigned dirty)
{
   const struct pipe_vertex_element *ve = svga->curr.velems->velem;
   unsigned i;
   unsigned neg_bias = 0;

   assert(svga->curr.velems->count >=
          svga->curr.vs->base.info.file_count[TGSI_FILE_INPUT]);

   /* specify number of vertex element declarations to come */
   svga_hwtnl_reset_vdecl( svga->hwtnl,
                           svga->curr.velems->count );

   /**
    * We can't set the VDECL offset to something negative, so we
    * must calculate a common negative additional index bias, and modify
    * the VDECL offsets accordingly so they *all* end up positive.
    *
    * Note that the exact value of the negative index bias is not that
    * important, since we compensate for it when we calculate the vertex
    * buffer offset below. The important thing is that all vertex buffer
    * offsets remain positive.
    *
    * Note that we use a negative bias variable in order to make the
    * rounding maths more easy to follow, and to avoid int / unsigned
    * confusion.
    */

   for (i = 0; i < svga->curr.velems->count; i++) {
      const struct pipe_vertex_buffer *vb =
         &svga->curr.vb[ve[i].vertex_buffer_index];
      const struct svga_buffer *buffer;
      unsigned int offset = vb->buffer_offset + ve[i].src_offset;

      if (!vb->buffer)
         continue;

      buffer = svga_buffer(vb->buffer);
      if (buffer->uploaded.start > offset) {
         unsigned tmp_neg_bias = buffer->uploaded.start - offset;
         if (vb->stride)
            tmp_neg_bias = (tmp_neg_bias + vb->stride - 1) / vb->stride;
         neg_bias = MAX2(neg_bias, tmp_neg_bias);
      }
   }

   for (i = 0; i < svga->curr.velems->count; i++) {
      const struct pipe_vertex_buffer *vb =
         &svga->curr.vb[ve[i].vertex_buffer_index];
      unsigned usage, index;
      const struct svga_buffer *buffer;
      SVGA3dVertexDecl decl;

      if (!vb->buffer)
         continue;

      buffer = svga_buffer(vb->buffer);
      svga_generate_vdecl_semantics( i, &usage, &index );

      /* SVGA_NEW_VELEMENT
       */
      decl.identity.type = svga->curr.velems->decl_type[i];
      decl.identity.method = SVGA3D_DECLMETHOD_DEFAULT;
      decl.identity.usage = usage;
      decl.identity.usageIndex = index;
      decl.array.stride = vb->stride;

      /* Compensate for partially uploaded vbo, and
       * for the negative index bias.
       */
      decl.array.offset = (vb->buffer_offset
                           + ve[i].src_offset
			   + neg_bias * vb->stride
			   - buffer->uploaded.start);

      assert(decl.array.offset >= 0);

      svga_hwtnl_vdecl( svga->hwtnl,
                        i,
                        &decl,
                        buffer->uploaded.buffer ? buffer->uploaded.buffer :
                        vb->buffer );
   }

   svga_hwtnl_set_index_bias( svga->hwtnl, -(int) neg_bias );
   return PIPE_OK;
}


static enum pipe_error
emit_hw_vdecl(struct svga_context *svga, unsigned dirty)
{
   /* SVGA_NEW_NEED_SWTNL
    */
   if (svga->state.sw.need_swtnl)
      return PIPE_OK; /* Do not emit during swtnl */

   return emit_hw_vs_vdecl( svga, dirty );
}


struct svga_tracked_state svga_hw_vdecl =
{
   "hw vertex decl state (hwtnl version)",
   ( SVGA_NEW_NEED_SWTNL |
     SVGA_NEW_VELEMENT |
     SVGA_NEW_VBUFFER |
     SVGA_NEW_RAST |
     SVGA_NEW_FS |
     SVGA_NEW_VS ),
   emit_hw_vdecl
};
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@a44 1
   SVGA3dVertexDecl decl;
d51 1
d73 1
a73 1
      struct svga_buffer *buffer;
a74 1
      unsigned tmp_neg_bias = 0;
d81 1
a81 1
         tmp_neg_bias = buffer->uploaded.start - offset;
d92 2
a93 1
      struct svga_buffer *buffer;
d98 1
a98 1
      buffer= svga_buffer(vb->buffer);
d103 1
a103 1
      decl.identity.type = svga->state.sw.ve_format[i];
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a36 1

a39 49
static int
upload_user_buffers( struct svga_context *svga )
{
   enum pipe_error ret = PIPE_OK;
   int i;
   int nr;

   if (0) 
      debug_printf("%s: %d\n", __FUNCTION__, svga->curr.num_vertex_buffers);

   nr = svga->curr.num_vertex_buffers;

   for (i = 0; i < nr; i++) 
   {
      if (svga_buffer_is_user_buffer(svga->curr.vb[i].buffer))
      {
         struct svga_buffer *buffer = svga_buffer(svga->curr.vb[i].buffer);

         if (!buffer->uploaded.buffer) {
            boolean flushed;
            ret = u_upload_buffer( svga->upload_vb,
                                   0, 0,
                                   buffer->b.b.width0,
                                   &buffer->b.b,
                                   &buffer->uploaded.offset,
                                   &buffer->uploaded.buffer,
                                   &flushed);
            if (ret)
               return ret;

            if (0)
               debug_printf("%s: %d: orig buf %p upl buf %p ofs %d sz %d\n",
                            __FUNCTION__,
                            i,
                            buffer,
                            buffer->uploaded.buffer,
                            buffer->uploaded.offset,
                            buffer->b.b.width0);
         }

         svga->curr.vb[i].buffer_offset = buffer->uploaded.offset;
      }
   }

   if (0)
      debug_printf("%s: DONE\n", __FUNCTION__);

   return ret;
}
d41 2
a42 7

/***********************************************************************
 */


static int emit_hw_vs_vdecl( struct svga_context *svga,
                             unsigned dirty )
d47 1
d52 1
a52 1
   svga_hwtnl_reset_vdecl( svga->hwtnl, 
d55 34
d90 2
a91 1
      const struct pipe_vertex_buffer *vb = &svga->curr.vb[ve[i].vertex_buffer_index];
d93 1
a93 1
      struct svga_buffer *buffer = svga_buffer(vb->buffer);
d95 2
d98 1
d108 10
a117 2
      decl.array.offset = (vb->buffer_offset +
                           ve[i].src_offset);
d126 2
a127 1
   return 0;
d131 2
a132 2
static int emit_hw_vdecl( struct svga_context *svga,
                          unsigned dirty )
a133 2
   int ret = 0;

d137 1
a137 11
      return 0; /* Do not emit during swtnl */

   /* If we get to here, we know that we're going to draw.  Upload
    * userbuffers now and try to combine multiple userbuffers from
    * multiple draw calls into a single host buffer for performance.
    */
   if (svga->curr.any_user_vertex_buffers) {
      ret = upload_user_buffers( svga );
      if (ret)
         return ret;
   }
d143 1
a143 1
struct svga_tracked_state svga_hw_vdecl = 
a153 6






@


1.2
log
@Merge Mesa 7.10.3
@
text
@d60 1
d62 1
a62 1
                                   0,
d66 2
a67 1
                                   &buffer->uploaded.buffer );
a80 1
         pipe_resource_reference( &svga->curr.vb[i].buffer, buffer->uploaded.buffer );
d112 1
d130 1
d152 1
a152 3
   if (svga->curr.any_user_vertex_buffers &&
       SVGA_COMBINE_USERBUFFERS)
   {
a155 2

      svga->curr.any_user_vertex_buffers = FALSE;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d36 1
a36 1
#include "svga_screen_buffer.h"
d62 2
a63 2
                                   buffer->base.size,
                                   &buffer->base,
d76 1
a76 1
                            buffer->base.size);
d79 1
a79 1
         pipe_buffer_reference( &svga->curr.vb[i].buffer, buffer->uploaded.buffer );
d98 1
a98 1
   const struct pipe_vertex_element *ve = svga->curr.ve;
d102 1
a102 1
   assert(svga->curr.num_vertex_elements >=
d106 1
a106 1
                           svga->curr.num_vertex_elements );
d108 1
a108 1
   for (i = 0; i < svga->curr.num_vertex_elements; i++) {
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d36 1
a36 1
#include "svga_resource_buffer.h"
d62 2
a63 2
                                   buffer->b.b.width0,
                                   &buffer->b.b,
d76 1
a76 1
                            buffer->b.b.width0);
d79 1
a79 1
         pipe_resource_reference( &svga->curr.vb[i].buffer, buffer->uploaded.buffer );
d98 1
a98 1
   const struct pipe_vertex_element *ve = svga->curr.velems->velem;
d102 1
a102 1
   assert(svga->curr.velems->count >=
d106 1
a106 1
                           svga->curr.velems->count );
d108 1
a108 1
   for (i = 0; i < svga->curr.velems->count; i++) {
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d37 1
d41 52
d94 3
a96 2
static enum pipe_error
emit_hw_vs_vdecl(struct svga_context *svga, unsigned dirty)
a100 1
   unsigned neg_bias = 0;
d105 1
a105 1
   svga_hwtnl_reset_vdecl( svga->hwtnl,
a107 15
   /**
    * We can't set the VDECL offset to something negative, so we
    * must calculate a common negative additional index bias, and modify
    * the VDECL offsets accordingly so they *all* end up positive.
    *
    * Note that the exact value of the negative index bias is not that
    * important, since we compensate for it when we calculate the vertex
    * buffer offset below. The important thing is that all vertex buffer
    * offsets remain positive.
    *
    * Note that we use a negative bias variable in order to make the
    * rounding maths more easy to follow, and to avoid int / unsigned
    * confusion.
    */

d109 1
a109 21
      const struct pipe_vertex_buffer *vb =
         &svga->curr.vb[ve[i].vertex_buffer_index];
      struct svga_buffer *buffer;
      unsigned int offset = vb->buffer_offset + ve[i].src_offset;
      unsigned tmp_neg_bias = 0;

      if (!vb->buffer)
         continue;

      buffer = svga_buffer(vb->buffer);
      if (buffer->uploaded.start > offset) {
         tmp_neg_bias = buffer->uploaded.start - offset;
         if (vb->stride)
            tmp_neg_bias = (tmp_neg_bias + vb->stride - 1) / vb->stride;
         neg_bias = MAX2(neg_bias, tmp_neg_bias);
      }
   }

   for (i = 0; i < svga->curr.velems->count; i++) {
      const struct pipe_vertex_buffer *vb =
         &svga->curr.vb[ve[i].vertex_buffer_index];
a110 1
      struct svga_buffer *buffer;
a111 2
      if (!vb->buffer)
         continue;
a112 1
      buffer= svga_buffer(vb->buffer);
d122 2
a123 10

      /* Compensate for partially uploaded vbo, and
       * for the negative index bias.
       */
      decl.array.offset = (vb->buffer_offset
                           + ve[i].src_offset
			   + neg_bias * vb->stride
			   - buffer->uploaded.start);

      assert(decl.array.offset >= 0);
a127 1
                        buffer->uploaded.buffer ? buffer->uploaded.buffer :
d131 1
a131 2
   svga_hwtnl_set_index_bias( svga->hwtnl, -(int) neg_bias );
   return PIPE_OK;
d135 2
a136 2
static enum pipe_error
emit_hw_vdecl(struct svga_context *svga, unsigned dirty)
d138 2
d143 15
a157 1
      return PIPE_OK; /* Do not emit during swtnl */
d163 1
a163 1
struct svga_tracked_state svga_hw_vdecl =
d174 6
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d45 1
a51 1
   /* specify number of vertex element declarations to come */
d73 1
a73 1
      const struct svga_buffer *buffer;
d75 1
d82 1
a82 1
         unsigned tmp_neg_bias = buffer->uploaded.start - offset;
d93 1
a93 2
      const struct svga_buffer *buffer;
      SVGA3dVertexDecl decl;
d98 1
a98 1
      buffer = svga_buffer(vb->buffer);
d103 1
a103 1
      decl.identity.type = svga->curr.velems->decl_type[i];
@


