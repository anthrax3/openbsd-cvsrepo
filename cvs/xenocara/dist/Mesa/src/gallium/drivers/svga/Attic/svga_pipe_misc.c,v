head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.09;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "svga_cmd.h"

#include "util/u_framebuffer.h"
#include "util/u_inlines.h"

#include "svga_context.h"
#include "svga_screen.h"
#include "svga_surface.h"
#include "svga_resource_texture.h"


static void svga_set_scissor_states( struct pipe_context *pipe,
                                     unsigned start_slot,
                                     unsigned num_scissors,
                                     const struct pipe_scissor_state *scissors )
{
   struct svga_context *svga = svga_context(pipe);

   memcpy( &svga->curr.scissor, scissors, sizeof(*scissors) );
   svga->dirty |= SVGA_NEW_SCISSOR;
}


static void svga_set_polygon_stipple( struct pipe_context *pipe,
                                      const struct pipe_poly_stipple *stipple )
{
   /* overridden by the draw module */
}


void svga_cleanup_framebuffer(struct svga_context *svga)
{
   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
   struct pipe_framebuffer_state *curr = &svga->curr.framebuffer;
   struct pipe_framebuffer_state *hw = &svga->state.hw_clear.framebuffer;
   unsigned i;

   for (i = 0; i < svgascreen->max_color_buffers; i++) {
      pipe_surface_reference(&curr->cbufs[i], NULL);
      pipe_surface_reference(&hw->cbufs[i], NULL);
   }

   pipe_surface_reference(&curr->zsbuf, NULL);
   pipe_surface_reference(&hw->zsbuf, NULL);
}


#define DEPTH_BIAS_SCALE_FACTOR_D16    ((float)(1<<15))
#define DEPTH_BIAS_SCALE_FACTOR_D24S8  ((float)(1<<23))
#define DEPTH_BIAS_SCALE_FACTOR_D32    ((float)(1<<31))


static void svga_set_framebuffer_state(struct pipe_context *pipe,
				       const struct pipe_framebuffer_state *fb)
{
   struct svga_context *svga = svga_context(pipe);
   struct pipe_framebuffer_state *dst = &svga->curr.framebuffer;
   boolean propagate = FALSE;
   unsigned i;

   dst->width = fb->width;
   dst->height = fb->height;
   dst->nr_cbufs = fb->nr_cbufs;

   /* check if we need to propagate any of the target surfaces */
   for (i = 0; i < dst->nr_cbufs; i++) {
      struct pipe_surface *s = i < fb->nr_cbufs ? fb->cbufs[i] : NULL;
      if (dst->cbufs[i] && dst->cbufs[i] != s) {
         if (svga_surface_needs_propagation(dst->cbufs[i])) {
            propagate = TRUE;
            break;
         }
      }
   }

   if (propagate) {
      /* make sure that drawing calls comes before propagation calls */
      svga_hwtnl_flush_retry( svga );
   
      for (i = 0; i < dst->nr_cbufs; i++) {
         struct pipe_surface *s = i < fb->nr_cbufs ? fb->cbufs[i] : NULL;
         if (dst->cbufs[i] && dst->cbufs[i] != s)
            svga_propagate_surface(svga, dst->cbufs[i]);
      }
   }

   /* XXX: Actually the virtual hardware may support rendertargets with
    * different size, depending on the host API and driver, but since we cannot
    * know that make no such assumption here. */
   for(i = 0; i < fb->nr_cbufs; ++i) {
      if (fb->zsbuf && fb->cbufs[i]) {
         assert(fb->zsbuf->width == fb->cbufs[i]->width); 
         assert(fb->zsbuf->height == fb->cbufs[i]->height); 
      }
   }

   util_copy_framebuffer_state(dst, fb);

   /* Set the rendered-to flags */
   for (i = 0; i < dst->nr_cbufs; i++) {
      struct pipe_surface *s = dst->cbufs[i];
      if (s) {
         struct svga_texture *t = svga_texture(s->texture);
         svga_set_texture_rendered_to(t, s->u.tex.first_layer, s->u.tex.level);
      }
   }

   if (svga->curr.framebuffer.zsbuf)
   {
      switch (svga->curr.framebuffer.zsbuf->format) {
      case PIPE_FORMAT_Z16_UNORM:
         svga->curr.depthscale = 1.0f / DEPTH_BIAS_SCALE_FACTOR_D16;
         break;
      case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      case PIPE_FORMAT_Z24X8_UNORM:
      case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      case PIPE_FORMAT_X8Z24_UNORM:
         svga->curr.depthscale = 1.0f / DEPTH_BIAS_SCALE_FACTOR_D24S8;
         break;
      case PIPE_FORMAT_Z32_UNORM:
         svga->curr.depthscale = 1.0f / DEPTH_BIAS_SCALE_FACTOR_D32;
         break;
      case PIPE_FORMAT_Z32_FLOAT:
         svga->curr.depthscale = 1.0f / ((float)(1<<23));
         break;
      default:
         svga->curr.depthscale = 0.0f;
         break;
      }

      /* Set rendered-to flag */
      {
         struct pipe_surface *s = dst->zsbuf;
         struct svga_texture *t = svga_texture(s->texture);
         svga_set_texture_rendered_to(t, s->u.tex.first_layer, s->u.tex.level);
      }
   }
   else {
      svga->curr.depthscale = 0.0f;
   }

   svga->dirty |= SVGA_NEW_FRAME_BUFFER;
}



static void svga_set_clip_state( struct pipe_context *pipe,
                                 const struct pipe_clip_state *clip )
{
   struct svga_context *svga = svga_context(pipe);

   svga->curr.clip = *clip; /* struct copy */

   svga->dirty |= SVGA_NEW_CLIP;
}



/* Called when driver state tracker notices changes to the viewport
 * matrix:
 */
static void svga_set_viewport_states( struct pipe_context *pipe,
                                      unsigned start_slot,
                                      unsigned num_viewports,
                                      const struct pipe_viewport_state *viewports )
{
   struct svga_context *svga = svga_context(pipe);

   svga->curr.viewport = *viewports; /* struct copy */

   svga->dirty |= SVGA_NEW_VIEWPORT;
}



void svga_init_misc_functions( struct svga_context *svga )
{
   svga->pipe.set_scissor_states = svga_set_scissor_states;
   svga->pipe.set_polygon_stipple = svga_set_polygon_stipple;
   svga->pipe.set_framebuffer_state = svga_set_framebuffer_state;
   svga->pipe.set_clip_state = svga_set_clip_state;
   svga->pipe.set_viewport_states = svga_set_viewport_states;
}


@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d28 1
d32 1
d34 1
d58 1
d61 1
a61 1
   int i;
d63 1
a63 1
   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
d91 4
a94 3
   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
      if (dst->cbufs[i] && dst->cbufs[i] != fb->cbufs[i])
         if (svga_surface_needs_propagation(dst->cbufs[i]))
d96 3
d105 3
a107 2
      for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++)
         if (dst->cbufs[i] && dst->cbufs[i] != fb->cbufs[i])
d109 1
d122 9
a130 3
   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
      pipe_surface_reference(&dst->cbufs[i],
                             (i < fb->nr_cbufs) ? fb->cbufs[i] : NULL);
a131 2
   pipe_surface_reference(&dst->zsbuf, fb->zsbuf);

d154 7
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d34 4
a37 2
static void svga_set_scissor_state( struct pipe_context *pipe,
                                 const struct pipe_scissor_state *scissor )
d41 1
a41 1
   memcpy( &svga->curr.scissor, scissor, sizeof(*scissor) );
d80 1
a80 1
   int i;
d86 1
a86 1
   /* check if we need to propaget any of the target surfaces */
d112 4
a115 2
   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++)
      pipe_surface_reference(&dst->cbufs[i], fb->cbufs[i]);
d125 1
a125 1
      case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d127 1
a127 1
      case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d166 4
a169 2
static void svga_set_viewport_state( struct pipe_context *pipe,
				     const struct pipe_viewport_state *viewport )
d173 1
a173 1
   svga->curr.viewport = *viewport; /* struct copy */
d182 1
a182 1
   svga->pipe.set_scissor_state = svga_set_scissor_state;
d186 1
a186 1
   svga->pipe.set_viewport_state = svga_set_viewport_state;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d97 1
a97 1
            svga_propagate_surface(pipe, dst->cbufs[i]);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a31 1
#include "svga_screen_texture.h"
d121 1
a121 1
      case PIPE_FORMAT_Z24S8_UNORM:
d123 1
a123 1
      case PIPE_FORMAT_S8Z24_UNORM:
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d31 1
a31 1
#include "svga_surface.h"
d121 1
a121 1
      case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d123 1
a123 1
      case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d34 2
a35 4
static void svga_set_scissor_states( struct pipe_context *pipe,
                                     unsigned start_slot,
                                     unsigned num_scissors,
                                     const struct pipe_scissor_state *scissors )
d39 1
a39 1
   memcpy( &svga->curr.scissor, scissors, sizeof(*scissors) );
d78 1
a78 1
   unsigned i;
d84 1
a84 1
   /* check if we need to propagate any of the target surfaces */
d97 1
a97 1
            svga_propagate_surface(svga, dst->cbufs[i]);
d110 2
a111 4
   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
      pipe_surface_reference(&dst->cbufs[i],
                             (i < fb->nr_cbufs) ? fb->cbufs[i] : NULL);
   }
d121 1
a121 1
      case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d123 1
a123 1
      case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d162 2
a163 4
static void svga_set_viewport_states( struct pipe_context *pipe,
                                      unsigned start_slot,
                                      unsigned num_viewports,
                                      const struct pipe_viewport_state *viewports )
d167 1
a167 1
   svga->curr.viewport = *viewports; /* struct copy */
d176 1
a176 1
   svga->pipe.set_scissor_states = svga_set_scissor_states;
d180 1
a180 1
   svga->pipe.set_viewport_states = svga_set_viewport_states;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a27 1
#include "util/u_framebuffer.h"
a30 1
#include "svga_screen.h"
a31 1
#include "svga_resource_texture.h"
a54 1
   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
d57 1
a57 1
   unsigned i;
d59 1
a59 1
   for (i = 0; i < svgascreen->max_color_buffers; i++) {
d87 3
a89 4
   for (i = 0; i < dst->nr_cbufs; i++) {
      struct pipe_surface *s = i < fb->nr_cbufs ? fb->cbufs[i] : NULL;
      if (dst->cbufs[i] && dst->cbufs[i] != s) {
         if (svga_surface_needs_propagation(dst->cbufs[i])) {
a90 3
            break;
         }
      }
d97 2
a98 3
      for (i = 0; i < dst->nr_cbufs; i++) {
         struct pipe_surface *s = i < fb->nr_cbufs ? fb->cbufs[i] : NULL;
         if (dst->cbufs[i] && dst->cbufs[i] != s)
a99 1
      }
d112 5
a116 1
   util_copy_framebuffer_state(dst, fb);
a117 8
   /* Set the rendered-to flags */
   for (i = 0; i < dst->nr_cbufs; i++) {
      struct pipe_surface *s = dst->cbufs[i];
      if (s) {
         struct svga_texture *t = svga_texture(s->texture);
         svga_set_texture_rendered_to(t, s->u.tex.first_layer, s->u.tex.level);
      }
   }
a139 7
      }

      /* Set rendered-to flag */
      {
         struct pipe_surface *s = dst->zsbuf;
         struct svga_texture *t = svga_texture(s->texture);
         svga_set_texture_rendered_to(t, s->u.tex.first_layer, s->u.tex.level);
@


