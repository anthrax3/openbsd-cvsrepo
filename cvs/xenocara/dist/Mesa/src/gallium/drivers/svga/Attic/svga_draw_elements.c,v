head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.08;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.57;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "util/u_inlines.h"
#include "util/u_prim.h"
#include "indices/u_indices.h"

#include "svga_cmd.h"
#include "svga_draw.h"
#include "svga_draw_private.h"
#include "svga_resource_buffer.h"
#include "svga_winsys.h"
#include "svga_context.h"
#include "svga_hw_reg.h"


static enum pipe_error
translate_indices(struct svga_hwtnl *hwtnl, struct pipe_resource *src,
                  unsigned offset, unsigned prim, unsigned nr,
                  unsigned index_size,
                  u_translate_func translate, struct pipe_resource **out_buf)
{
   struct pipe_context *pipe = &hwtnl->svga->pipe;
   struct pipe_transfer *src_transfer = NULL;
   struct pipe_transfer *dst_transfer = NULL;
   unsigned size;
   const void *src_map = NULL;
   struct pipe_resource *dst = NULL;
   void *dst_map = NULL;

   /* Need to trim vertex count to make sure we don't write too much data
    * to the dst buffer in the translate() call.
    */
   u_trim_pipe_prim(prim, &nr);

   size = index_size * nr;

   dst = pipe_buffer_create(pipe->screen,
                            PIPE_BIND_INDEX_BUFFER, PIPE_USAGE_DEFAULT, size);
   if (dst == NULL)
      goto fail;

   src_map = pipe_buffer_map(pipe, src, PIPE_TRANSFER_READ, &src_transfer);
   if (src_map == NULL)
      goto fail;

   dst_map = pipe_buffer_map(pipe, dst, PIPE_TRANSFER_WRITE, &dst_transfer);
   if (dst_map == NULL)
      goto fail;

   translate((const char *) src_map + offset, 0, nr, dst_map);

   pipe_buffer_unmap(pipe, src_transfer);
   pipe_buffer_unmap(pipe, dst_transfer);

   *out_buf = dst;
   return PIPE_OK;

 fail:
   if (src_map)
      pipe_buffer_unmap(pipe, src_transfer);

   if (dst_map)
      pipe_buffer_unmap(pipe, dst_transfer);

   if (dst)
      pipe->screen->resource_destroy(pipe->screen, dst);

   return PIPE_ERROR_OUT_OF_MEMORY;
}


enum pipe_error
svga_hwtnl_simple_draw_range_elements(struct svga_hwtnl *hwtnl,
                                      struct pipe_resource *index_buffer,
                                      unsigned index_size, int index_bias,
                                      unsigned min_index, unsigned max_index,
                                      unsigned prim, unsigned start,
                                      unsigned count)
{
   SVGA3dPrimitiveRange range;
   unsigned hw_prim;
   unsigned hw_count;
   unsigned index_offset = start * index_size;

   hw_prim = svga_translate_prim(prim, count, &hw_count);
   if (hw_count == 0)
      return PIPE_OK; /* nothing to draw */

   /* We should never see user-space buffers in the driver.  The vbuf
    * module should have converted them into real buffers.
    */
   if (index_buffer)
      assert(!svga_buffer_is_user_buffer(index_buffer));

   range.primType = hw_prim;
   range.primitiveCount = hw_count;
   range.indexArray.offset = index_offset;
   range.indexArray.stride = index_size;
   range.indexWidth = index_size;
   range.indexBias = index_bias;

   return svga_hwtnl_prim(hwtnl, &range, min_index, max_index, index_buffer);
}


enum pipe_error
svga_hwtnl_draw_range_elements(struct svga_hwtnl *hwtnl,
                               struct pipe_resource *index_buffer,
                               unsigned index_size, int index_bias,
                               unsigned min_index, unsigned max_index,
                               unsigned prim, unsigned start, unsigned count)
{
   unsigned gen_prim, gen_size, gen_nr, gen_type;
   u_translate_func gen_func;
   enum pipe_error ret = PIPE_OK;

   if (hwtnl->api_fillmode != PIPE_POLYGON_MODE_FILL &&
       prim >= PIPE_PRIM_TRIANGLES) {
      gen_type = u_unfilled_translator(prim,
                                       index_size,
                                       count,
                                       hwtnl->api_fillmode,
                                       &gen_prim,
                                       &gen_size, &gen_nr, &gen_func);
   }
   else {
      gen_type = u_index_translator(svga_hw_prims,
                                    prim,
                                    index_size,
                                    count,
                                    hwtnl->api_pv,
                                    hwtnl->hw_pv,
                                    &gen_prim, &gen_size, &gen_nr, &gen_func);
   }

   if (gen_type == U_TRANSLATE_MEMCPY) {
      /* No need for translation, just pass through to hardware:
       */
      return svga_hwtnl_simple_draw_range_elements(hwtnl, index_buffer,
                                                   index_size,
                                                   index_bias,
                                                   min_index,
                                                   max_index,
                                                   gen_prim, start, count);
   }
   else {
      struct pipe_resource *gen_buf = NULL;

      /* Need to allocate a new index buffer and run the translate
       * func to populate it.  Could potentially cache this translated
       * index buffer with the original to avoid future
       * re-translations.  Not much point if we're just accelerating
       * GL though, as index buffers are typically used only once
       * there.
       */
      ret = translate_indices(hwtnl,
                              index_buffer,
                              start * index_size,
                              gen_prim, gen_nr, gen_size, gen_func, &gen_buf);
      if (ret != PIPE_OK)
         goto done;

      ret = svga_hwtnl_simple_draw_range_elements(hwtnl,
                                                  gen_buf,
                                                  gen_size,
                                                  index_bias,
                                                  min_index,
                                                  max_index,
                                                  gen_prim, 0, gen_nr);
      if (ret != PIPE_OK)
         goto done;

done:
      if (gen_buf)
         pipe_resource_reference(&gen_buf, NULL);

      return ret;
   }
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d27 1
a27 1
#include "util/u_upload_mgr.h"
d40 4
a43 7
translate_indices( struct svga_hwtnl *hwtnl,
                   struct pipe_resource *src,
                   unsigned offset,
                   unsigned nr,
                   unsigned index_size,
                   u_translate_func translate,
                   struct pipe_resource **out_buf )
d48 1
a48 1
   unsigned size = index_size * nr;
d53 9
a61 4
   dst = pipe_buffer_create( pipe->screen,
			     PIPE_BIND_INDEX_BUFFER,
			     PIPE_USAGE_STATIC,
			     size );
d65 1
a65 1
   src_map = pipe_buffer_map( pipe, src, PIPE_TRANSFER_READ, &src_transfer );
d69 1
a69 1
   dst_map = pipe_buffer_map( pipe, dst, PIPE_TRANSFER_WRITE, &dst_transfer );
d73 1
a73 3
   translate( (const char *)src_map + offset,
              nr,
              dst_map );
d75 2
a76 2
   pipe_buffer_unmap( pipe, src_transfer );
   pipe_buffer_unmap( pipe, dst_transfer );
d81 1
a81 1
fail:
d83 1
a83 1
      pipe_buffer_unmap( pipe, src_transfer );
d86 1
a86 1
      pipe_buffer_unmap( pipe, dst_transfer );
d89 1
a89 1
      pipe->screen->resource_destroy( pipe->screen, dst );
a94 3



d96 6
a101 9
svga_hwtnl_simple_draw_range_elements( struct svga_hwtnl *hwtnl,
                                       struct pipe_resource *index_buffer,
                                       unsigned index_size,
                                       int index_bias,
                                       unsigned min_index,
                                       unsigned max_index,
                                       unsigned prim,
                                       unsigned start,
                                       unsigned count )
a102 1
   struct pipe_resource *upload_buffer = NULL;
a106 1
   enum pipe_error ret = PIPE_OK;
d110 1
a110 1
      goto done;
d112 5
a116 21
   if (index_buffer &&
       svga_buffer_is_user_buffer(index_buffer))
   {
      assert( index_buffer->width0 >= index_offset + count * index_size );

      ret = u_upload_buffer( hwtnl->upload_ib,
                             0,
                             index_offset,
                             count * index_size,
                             index_buffer,
                             &index_offset,
                             &upload_buffer);
      if (ret != PIPE_OK)
         goto done;

      /* Don't need to worry about refcounting index_buffer as this is
       * just a stack variable without a counted reference of its own.
       * The caller holds the reference.
       */
      index_buffer = upload_buffer;
   }
d125 1
a125 9
   ret = svga_hwtnl_prim( hwtnl, &range, min_index, max_index, index_buffer );
   if (ret != PIPE_OK)
      goto done;

done:
   if (upload_buffer)
      pipe_resource_reference( &upload_buffer, NULL );

   return ret;
a128 2


d130 5
a134 7
svga_hwtnl_draw_range_elements( struct svga_hwtnl *hwtnl,
                                struct pipe_resource *index_buffer,
                                unsigned index_size,
                                int index_bias,
                                unsigned min_index,
                                unsigned max_index,
                                unsigned prim, unsigned start, unsigned count)
d141 7
a147 10
       prim >= PIPE_PRIM_TRIANGLES)
   {
      gen_type = u_unfilled_translator( prim,
                                        index_size,
                                        count,
                                        hwtnl->api_fillmode,
                                        &gen_prim,
                                        &gen_size,
                                        &gen_nr,
                                        &gen_func );
d149 8
a156 12
   else
   {
      gen_type = u_index_translator( svga_hw_prims,
                                     prim,
                                     index_size,
                                     count,
                                     hwtnl->api_pv,
                                     hwtnl->hw_pv,
                                     &gen_prim,
                                     &gen_size,
                                     &gen_nr,
                                     &gen_func );
d162 6
a167 6
      return svga_hwtnl_simple_draw_range_elements( hwtnl, index_buffer,
                                                    index_size,
                                                    index_bias,
                                                    min_index,
                                                    max_index,
                                                    gen_prim, start, count );
d179 4
a182 7
      ret = translate_indices( hwtnl,
                               index_buffer,
                               start * index_size,
                               gen_nr,
                               gen_size,
                               gen_func,
                               &gen_buf );
d186 7
a192 9
      ret = svga_hwtnl_simple_draw_range_elements( hwtnl,
                                                   gen_buf,
                                                   gen_size,
                                                   index_bias,
                                                   min_index,
                                                   max_index,
                                                   gen_prim,
                                                   0,
                                                   gen_nr );
d196 1
a196 1
   done:
d198 1
a198 1
         pipe_resource_reference( &gen_buf, NULL );
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a35 1

d56 2
a57 2
   dst = pipe_buffer_create( pipe->screen, 
			     PIPE_BIND_INDEX_BUFFER, 
d105 1
a105 1
                                       unsigned prim, 
d114 1
a114 1
   int ret = PIPE_OK;
d120 2
a121 2
   if (index_buffer && 
       svga_buffer_is_user_buffer(index_buffer)) 
a122 1
      boolean flushed;
d131 2
a132 3
                             &upload_buffer,
                             &flushed );
      if (ret)
d148 1
a148 1
      
d150 1
a150 1
   if (ret)
d176 2
a177 2
   if (hwtnl->api_fillmode != PIPE_POLYGON_MODE_FILL && 
       prim >= PIPE_PRIM_TRIANGLES) 
a201 1
   
d203 1
a203 1
      /* No need for translation, just pass through to hardware: 
d229 1
a229 1
      if (ret)
d241 1
a241 1
      if (ret)
a250 5





@


1.2
log
@Merge Mesa 7.10.3
@
text
@d59 1
d76 2
a77 2
   pipe_buffer_unmap( pipe, src, src_transfer );
   pipe_buffer_unmap( pipe, dst, dst_transfer );
d84 1
a84 1
      pipe_buffer_unmap( pipe, src, src_transfer );
d87 1
a87 1
      pipe_buffer_unmap( pipe, dst, dst_transfer );
d124 1
d128 1
d133 2
a134 1
                             &upload_buffer );
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d33 1
a33 1
#include "svga_screen_buffer.h"
d42 1
a42 1
                   struct pipe_buffer *src,
d47 1
a47 1
                   struct pipe_buffer **out_buf )
d49 3
a51 1
   struct pipe_screen *screen = hwtnl->svga->pipe.screen;
d54 1
a54 1
   struct pipe_buffer *dst = NULL;
d57 3
a59 5
   dst = screen->buffer_create( screen, 32, 
                                PIPE_BUFFER_USAGE_INDEX |
                                PIPE_BUFFER_USAGE_CPU_WRITE |
                                PIPE_BUFFER_USAGE_GPU_READ, 
                                size );
d63 1
a63 1
   src_map = pipe_buffer_map( screen, src, PIPE_BUFFER_USAGE_CPU_READ );
d67 1
a67 1
   dst_map = pipe_buffer_map( screen, dst, PIPE_BUFFER_USAGE_CPU_WRITE );
d75 2
a76 2
   pipe_buffer_unmap( screen, src );
   pipe_buffer_unmap( screen, dst );
d83 1
a83 1
      screen->buffer_unmap( screen, src );
d86 1
a86 1
      screen->buffer_unmap( screen, dst );
d89 1
a89 1
      screen->buffer_destroy( dst );
d100 1
a100 1
                                       struct pipe_buffer *index_buffer,
d102 1
d107 1
a107 2
                                       unsigned count,
                                       unsigned bias )
d109 1
a109 1
   struct pipe_buffer *upload_buffer = NULL;
d123 1
a123 1
      assert( index_buffer->size >= index_offset + count * index_size );
d146 1
a146 1
   range.indexBias = bias;
d154 1
a154 1
      pipe_buffer_reference( &upload_buffer, NULL );
d164 1
a164 1
                                struct pipe_buffer *index_buffer,
d166 1
d169 1
a169 2
                                unsigned prim, unsigned start, unsigned count,
                                unsigned bias)
d207 1
d210 1
a210 1
                                                    gen_prim, start, count, bias );
d213 1
a213 1
      struct pipe_buffer *gen_buf = NULL;
d235 1
d240 1
a240 2
                                                   gen_nr,
                                                   bias );
d246 1
a246 1
         pipe_buffer_reference( &gen_buf, NULL );
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d33 1
a33 1
#include "svga_resource_buffer.h"
d42 1
a42 1
                   struct pipe_resource *src,
d47 1
a47 1
                   struct pipe_resource **out_buf )
d49 1
a49 3
   struct pipe_context *pipe = &hwtnl->svga->pipe;
   struct pipe_transfer *src_transfer = NULL;
   struct pipe_transfer *dst_transfer = NULL;
d52 1
a52 1
   struct pipe_resource *dst = NULL;
d55 5
a59 3
   dst = pipe_buffer_create( pipe->screen, 
			     PIPE_BIND_INDEX_BUFFER, 
			     size );
d63 1
a63 1
   src_map = pipe_buffer_map( pipe, src, PIPE_TRANSFER_READ, &src_transfer );
d67 1
a67 1
   dst_map = pipe_buffer_map( pipe, dst, PIPE_TRANSFER_WRITE, &dst_transfer );
d75 2
a76 2
   pipe_buffer_unmap( pipe, src, src_transfer );
   pipe_buffer_unmap( pipe, dst, dst_transfer );
d83 1
a83 1
      pipe_buffer_unmap( pipe, src, src_transfer );
d86 1
a86 1
      pipe_buffer_unmap( pipe, dst, dst_transfer );
d89 1
a89 1
      pipe->screen->resource_destroy( pipe->screen, dst );
d100 1
a100 1
                                       struct pipe_resource *index_buffer,
a101 1
                                       int index_bias,
d106 2
a107 1
                                       unsigned count )
d109 1
a109 1
   struct pipe_resource *upload_buffer = NULL;
d123 1
a123 1
      assert( index_buffer->width0 >= index_offset + count * index_size );
d146 1
a146 1
   range.indexBias = index_bias;
d154 1
a154 1
      pipe_resource_reference( &upload_buffer, NULL );
d164 1
a164 1
                                struct pipe_resource *index_buffer,
a165 1
                                int index_bias,
d168 2
a169 1
                                unsigned prim, unsigned start, unsigned count)
a206 1
                                                    index_bias,
d209 1
a209 1
                                                    gen_prim, start, count );
d212 1
a212 1
      struct pipe_resource *gen_buf = NULL;
a233 1
                                                   index_bias,
d238 2
a239 1
                                                   gen_nr );
d245 1
a245 1
         pipe_resource_reference( &gen_buf, NULL );
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d36 1
d57 2
a58 3
   dst = pipe_buffer_create( pipe->screen,
			     PIPE_BIND_INDEX_BUFFER,
			     PIPE_USAGE_STATIC,
d75 2
a76 2
   pipe_buffer_unmap( pipe, src_transfer );
   pipe_buffer_unmap( pipe, dst_transfer );
d83 1
a83 1
      pipe_buffer_unmap( pipe, src_transfer );
d86 1
a86 1
      pipe_buffer_unmap( pipe, dst_transfer );
d105 1
a105 1
                                       unsigned prim,
d114 1
a114 1
   enum pipe_error ret = PIPE_OK;
d120 2
a121 2
   if (index_buffer &&
       svga_buffer_is_user_buffer(index_buffer))
a125 1
                             0,
d130 2
a131 2
                             &upload_buffer);
      if (ret != PIPE_OK)
d147 1
a147 1

d149 1
a149 1
   if (ret != PIPE_OK)
d175 2
a176 2
   if (hwtnl->api_fillmode != PIPE_POLYGON_MODE_FILL &&
       prim >= PIPE_PRIM_TRIANGLES)
d201 1
d203 1
a203 1
      /* No need for translation, just pass through to hardware:
d229 1
a229 1
      if (ret != PIPE_OK)
d241 1
a241 1
      if (ret != PIPE_OK)
d251 5
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d27 1
a27 1
#include "util/u_prim.h"
d40 7
a46 4
translate_indices(struct svga_hwtnl *hwtnl, struct pipe_resource *src,
                  unsigned offset, unsigned prim, unsigned nr,
                  unsigned index_size,
                  u_translate_func translate, struct pipe_resource **out_buf)
d51 1
a51 1
   unsigned size;
d56 4
a59 9
   /* Need to trim vertex count to make sure we don't write too much data
    * to the dst buffer in the translate() call.
    */
   u_trim_pipe_prim(prim, &nr);

   size = index_size * nr;

   dst = pipe_buffer_create(pipe->screen,
                            PIPE_BIND_INDEX_BUFFER, PIPE_USAGE_DEFAULT, size);
d63 1
a63 1
   src_map = pipe_buffer_map(pipe, src, PIPE_TRANSFER_READ, &src_transfer);
d67 1
a67 1
   dst_map = pipe_buffer_map(pipe, dst, PIPE_TRANSFER_WRITE, &dst_transfer);
d71 3
a73 1
   translate((const char *) src_map + offset, 0, nr, dst_map);
d75 2
a76 2
   pipe_buffer_unmap(pipe, src_transfer);
   pipe_buffer_unmap(pipe, dst_transfer);
d81 1
a81 1
 fail:
d83 1
a83 1
      pipe_buffer_unmap(pipe, src_transfer);
d86 1
a86 1
      pipe_buffer_unmap(pipe, dst_transfer);
d89 1
a89 1
      pipe->screen->resource_destroy(pipe->screen, dst);
d95 3
d99 9
a107 6
svga_hwtnl_simple_draw_range_elements(struct svga_hwtnl *hwtnl,
                                      struct pipe_resource *index_buffer,
                                      unsigned index_size, int index_bias,
                                      unsigned min_index, unsigned max_index,
                                      unsigned prim, unsigned start,
                                      unsigned count)
d109 1
d114 1
d118 1
a118 1
      return PIPE_OK; /* nothing to draw */
d120 21
a140 5
   /* We should never see user-space buffers in the driver.  The vbuf
    * module should have converted them into real buffers.
    */
   if (index_buffer)
      assert(!svga_buffer_is_user_buffer(index_buffer));
d149 9
a157 1
   return svga_hwtnl_prim(hwtnl, &range, min_index, max_index, index_buffer);
d161 2
d164 7
a170 5
svga_hwtnl_draw_range_elements(struct svga_hwtnl *hwtnl,
                               struct pipe_resource *index_buffer,
                               unsigned index_size, int index_bias,
                               unsigned min_index, unsigned max_index,
                               unsigned prim, unsigned start, unsigned count)
d177 10
a186 7
       prim >= PIPE_PRIM_TRIANGLES) {
      gen_type = u_unfilled_translator(prim,
                                       index_size,
                                       count,
                                       hwtnl->api_fillmode,
                                       &gen_prim,
                                       &gen_size, &gen_nr, &gen_func);
d188 12
a199 8
   else {
      gen_type = u_index_translator(svga_hw_prims,
                                    prim,
                                    index_size,
                                    count,
                                    hwtnl->api_pv,
                                    hwtnl->hw_pv,
                                    &gen_prim, &gen_size, &gen_nr, &gen_func);
d205 6
a210 6
      return svga_hwtnl_simple_draw_range_elements(hwtnl, index_buffer,
                                                   index_size,
                                                   index_bias,
                                                   min_index,
                                                   max_index,
                                                   gen_prim, start, count);
d222 7
a228 4
      ret = translate_indices(hwtnl,
                              index_buffer,
                              start * index_size,
                              gen_prim, gen_nr, gen_size, gen_func, &gen_buf);
d232 9
a240 7
      ret = svga_hwtnl_simple_draw_range_elements(hwtnl,
                                                  gen_buf,
                                                  gen_size,
                                                  index_bias,
                                                  min_index,
                                                  max_index,
                                                  gen_prim, 0, gen_nr);
d244 1
a244 1
done:
d246 1
a246 1
         pipe_resource_reference(&gen_buf, NULL);
@


