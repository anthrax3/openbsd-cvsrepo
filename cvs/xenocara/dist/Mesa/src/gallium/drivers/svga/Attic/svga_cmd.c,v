head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.34;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.08;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.56;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.08.50;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.05;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

/**
 * svga_cmd.c --
 *
 *      Command construction utility for the SVGA3D protocol used by
 *      the VMware SVGA device, based on the svgautil library.
 */

#include "svga_winsys.h"
#include "svga_resource_buffer.h"
#include "svga_resource_texture.h"
#include "svga_surface.h"
#include "svga_cmd.h"

/*
 *----------------------------------------------------------------------
 *
 * surface_to_surfaceid --
 *
 *      Utility function for surface ids.
 *      Can handle null surface. Does a surface_reallocation so you need
 *      to have allocated the fifo space before converting.
 *
 *
 * param flags  mask of SVGA_RELOC_READ / _WRITE
 *
 * Results:
 *      id is filled out.
 *
 * Side effects:
 *      One surface relocation is performed for texture handle.
 *
 *----------------------------------------------------------------------
 */

static INLINE void
surface_to_surfaceid(struct svga_winsys_context *swc, // IN
                     struct pipe_surface *surface,    // IN
                     SVGA3dSurfaceImageId *id,        // OUT
                     unsigned flags)                  // IN
{
   if (surface) {
      struct svga_surface *s = svga_surface(surface);
      swc->surface_relocation(swc, &id->sid, NULL, s->handle, flags);
      id->face = s->real_face; /* faces have the same order */
      id->mipmap = s->real_level;
   }
   else {
      swc->surface_relocation(swc, &id->sid, NULL, NULL, flags);
      id->face = 0;
      id->mipmap = 0;
   }
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_FIFOReserve --
 *
 *      Reserve space for an SVGA3D FIFO command.
 *
 *      The 2D SVGA commands have been around for a while, so they
 *      have a rather asymmetric structure. The SVGA3D protocol is
 *      more uniform: each command begins with a header containing the
 *      command number and the full size.
 *
 *      This is a convenience wrapper around SVGA_FIFOReserve. We
 *      reserve space for the whole command, and write the header.
 *
 *      This function must be paired with SVGA_FIFOCommitAll().
 *
 * Results:
 *      Returns a pointer to the space reserved for command-specific
 *      data. It must be 'cmdSize' bytes long.
 *
 * Side effects:
 *      Begins a FIFO reservation.
 *
 *----------------------------------------------------------------------
 */

void *
SVGA3D_FIFOReserve(struct svga_winsys_context *swc,
                   uint32 cmd,       // IN
                   uint32 cmdSize,   // IN
                   uint32 nr_relocs) // IN
{
   SVGA3dCmdHeader *header;

   header = swc->reserve(swc, sizeof *header + cmdSize, nr_relocs);
   if (!header)
      return NULL;

   header->id = cmd;
   header->size = cmdSize;

   return &header[1];
}


void
SVGA_FIFOCommitAll(struct svga_winsys_context *swc)
{
   swc->commit(swc);
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_DefineContext --
 *
 *      Create a new context, to be referred to with the provided ID.
 *
 *      Context objects encapsulate all render state, and shader
 *      objects are per-context.
 *
 *      Surfaces are not per-context. The same surface can be shared
 *      between multiple contexts, and surface operations can occur
 *      without a context.
 *
 *      If the provided context ID already existed, it is redefined.
 *
 *      Context IDs are arbitrary small non-negative integers,
 *      global to the entire SVGA device.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_DefineContext(struct svga_winsys_context *swc)  // IN
{
   SVGA3dCmdDefineContext *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_CONTEXT_DEFINE, sizeof *cmd, 0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_DestroyContext --
 *
 *      Delete a context created with SVGA3D_DefineContext.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_DestroyContext(struct svga_winsys_context *swc)  // IN
{
   SVGA3dCmdDestroyContext *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_CONTEXT_DESTROY, sizeof *cmd, 0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_BeginDefineSurface --
 *
 *      Begin a SURFACE_DEFINE command. This reserves space for it in
 *      the FIFO, and returns pointers to the command's faces and
 *      mipsizes arrays.
 *
 *      This function must be paired with SVGA_FIFOCommitAll().
 *      The faces and mipSizes arrays are initialized to zero.
 *
 *      This creates a "surface" object in the SVGA3D device,
 *      with the provided surface ID (sid). Surfaces are generic
 *      containers for host VRAM objects like textures, vertex
 *      buffers, and depth/stencil buffers.
 *
 *      Surfaces are hierarchical:
 *
 *        - Surface may have multiple faces (for cube maps)
 *
 *          - Each face has a list of mipmap levels
 *
 *             - Each mipmap image may have multiple volume
 *               slices, if the image is three dimensional.
 *
 *                - Each slice is a 2D array of 'blocks'
 *
 *                   - Each block may be one or more pixels.
 *                     (Usually 1, more for DXT or YUV formats.)
 *
 *      Surfaces are generic host VRAM objects. The SVGA3D device
 *      may optimize surfaces according to the format they were
 *      created with, but this format does not limit the ways in
 *      which the surface may be used. For example, a depth surface
 *      can be used as a texture, or a floating point image may
 *      be used as a vertex buffer. Some surface usages may be
 *      lower performance, due to software emulation, but any
 *      usage should work with any surface.
 *
 *      If 'sid' is already defined, the old surface is deleted
 *      and this new surface replaces it.
 *
 *      Surface IDs are arbitrary small non-negative integers,
 *      global to the entire SVGA device.
 *
 * Results:
 *      Returns pointers to arrays allocated in the FIFO for 'faces'
 *      and 'mipSizes'.
 *
 * Side effects:
 *      Begins a FIFO reservation.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_BeginDefineSurface(struct svga_winsys_context *swc,
                          struct svga_winsys_surface *sid, // IN
                          SVGA3dSurfaceFlags flags,    // IN
                          SVGA3dSurfaceFormat format,  // IN
                          SVGA3dSurfaceFace **faces,   // OUT
                          SVGA3dSize **mipSizes,       // OUT
                          uint32 numMipSizes)          // IN
{
   SVGA3dCmdDefineSurface *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SURFACE_DEFINE, sizeof *cmd +
                            sizeof **mipSizes * numMipSizes, 1);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->sid, NULL, sid,
                           SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);
   cmd->surfaceFlags = flags;
   cmd->format = format;

   *faces = &cmd->face[0];
   *mipSizes = (SVGA3dSize*) &cmd[1];

   memset(*faces, 0, sizeof **faces * SVGA3D_MAX_SURFACE_FACES);
   memset(*mipSizes, 0, sizeof **mipSizes * numMipSizes);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_DefineSurface2D --
 *
 *      This is a simplified version of SVGA3D_BeginDefineSurface(),
 *      which does not support cube maps, mipmaps, or volume textures.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_DefineSurface2D(struct svga_winsys_context *swc,    // IN
                       struct svga_winsys_surface *sid, // IN
                       uint32 width,                // IN
                       uint32 height,               // IN
                       SVGA3dSurfaceFormat format)  // IN
{
   SVGA3dSize *mipSizes;
   SVGA3dSurfaceFace *faces;
   enum pipe_error ret;

   ret = SVGA3D_BeginDefineSurface(swc,
                                   sid, 0, format, &faces, &mipSizes, 1);
   if (ret != PIPE_OK)
      return ret;

   faces[0].numMipLevels = 1;

   mipSizes[0].width = width;
   mipSizes[0].height = height;
   mipSizes[0].depth = 1;

   swc->commit(swc);;

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_DestroySurface --
 *
 *      Release the host VRAM encapsulated by a particular surface ID.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_DestroySurface(struct svga_winsys_context *swc,
                      struct svga_winsys_surface *sid)  // IN
{
   SVGA3dCmdDestroySurface *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SURFACE_DESTROY, sizeof *cmd, 1);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;
   
   swc->surface_relocation(swc, &cmd->sid, NULL, sid,
                           SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);
   swc->commit(swc);;

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SurfaceDMA--
 *
 *      Emit a SURFACE_DMA command.
 *
 *      When the SVGA3D device asynchronously processes this FIFO
 *      command, a DMA operation is performed between host VRAM and
 *      a generic SVGAGuestPtr. The guest pointer may refer to guest
 *      VRAM (provided by the SVGA PCI device) or to guest system
 *      memory that has been set up as a Guest Memory Region (GMR)
 *      by the SVGA device.
 *
 *      The guest's DMA buffer must remain valid (not freed, paged out,
 *      or overwritten) until the host has finished processing this
 *      command. The guest can determine that the host has finished
 *      by using the SVGA device's FIFO Fence mechanism.
 *
 *      The guest's image buffer can be an arbitrary size and shape.
 *      Guest image data is interpreted according to the SVGA3D surface
 *      format specified when the surface was defined.
 *
 *      The caller may optionally define the guest image's pitch.
 *      guestImage->pitch can either be zero (assume image is tightly
 *      packed) or it must be the number of bytes between vertically
 *      adjacent image blocks.
 *
 *      The provided copybox list specifies which regions of the source
 *      image are to be copied, and where they appear on the destination.
 *
 *      NOTE: srcx/srcy are always on the guest image and x/y are
 *      always on the host image, regardless of the actual transfer
 *      direction!
 *
 *      For efficiency, the SVGA3D device is free to copy more data
 *      than specified. For example, it may round copy boxes outwards
 *      such that they lie on particular alignment boundaries.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SurfaceDMA(struct svga_winsys_context *swc,
                  struct svga_transfer *st,         // IN
                  SVGA3dTransferType transfer,      // IN
                  const SVGA3dCopyBox *boxes,       // IN
                  uint32 numBoxes,                  // IN
                  SVGA3dSurfaceDMAFlags flags)      // IN
{
   struct svga_texture *texture = svga_texture(st->base.resource);
   SVGA3dCmdSurfaceDMA *cmd;
   SVGA3dCmdSurfaceDMASuffix *pSuffix;
   uint32 boxesSize = sizeof *boxes * numBoxes;
   unsigned region_flags;
   unsigned surface_flags;

   if (transfer == SVGA3D_WRITE_HOST_VRAM) {
      region_flags = SVGA_RELOC_READ;
      surface_flags = SVGA_RELOC_WRITE;
   }
   else if (transfer == SVGA3D_READ_HOST_VRAM) {
      region_flags = SVGA_RELOC_WRITE;
      surface_flags = SVGA_RELOC_READ;
   }
   else {
      assert(0);
      return PIPE_ERROR_BAD_INPUT;
   }

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SURFACE_DMA,
                            sizeof *cmd + boxesSize + sizeof *pSuffix,
                            2);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->region_relocation(swc, &cmd->guest.ptr, st->hwbuf, 0, region_flags);
   cmd->guest.pitch = st->base.stride;

   swc->surface_relocation(swc, &cmd->host.sid, NULL,
                           texture->handle, surface_flags);
   cmd->host.face = st->face; /* PIPE_TEX_FACE_* and SVGA3D_CUBEFACE_* match */
   cmd->host.mipmap = st->base.level;

   cmd->transfer = transfer;

   memcpy(&cmd[1], boxes, boxesSize);

   pSuffix = (SVGA3dCmdSurfaceDMASuffix *)((uint8_t*)cmd + sizeof *cmd + boxesSize);
   pSuffix->suffixSize = sizeof *pSuffix;
   pSuffix->maximumOffset = st->hw_nblocksy*st->base.stride;
   pSuffix->flags = flags;

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_BufferDMA(struct svga_winsys_context *swc,
                 struct svga_winsys_buffer *guest,
                 struct svga_winsys_surface *host,
                 SVGA3dTransferType transfer,      // IN
                 uint32 size,                      // IN
                 uint32 guest_offset,              // IN
                 uint32 host_offset,               // IN
                 SVGA3dSurfaceDMAFlags flags)      // IN
{
   SVGA3dCmdSurfaceDMA *cmd;
   SVGA3dCopyBox *box;
   SVGA3dCmdSurfaceDMASuffix *pSuffix;
   unsigned region_flags;
   unsigned surface_flags;
   
   assert(!swc->have_gb_objects);

   if (transfer == SVGA3D_WRITE_HOST_VRAM) {
      region_flags = SVGA_RELOC_READ;
      surface_flags = SVGA_RELOC_WRITE;
   }
   else if (transfer == SVGA3D_READ_HOST_VRAM) {
      region_flags = SVGA_RELOC_WRITE;
      surface_flags = SVGA_RELOC_READ;
   }
   else {
      assert(0);
      return PIPE_ERROR_BAD_INPUT;
   }

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SURFACE_DMA,
                            sizeof *cmd + sizeof *box + sizeof *pSuffix,
                            2);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->region_relocation(swc, &cmd->guest.ptr, guest, 0, region_flags);
   cmd->guest.pitch = 0;

   swc->surface_relocation(swc, &cmd->host.sid,
                           NULL, host, surface_flags);
   cmd->host.face = 0;
   cmd->host.mipmap = 0;

   cmd->transfer = transfer;

   box = (SVGA3dCopyBox *)&cmd[1];
   box->x = host_offset;
   box->y = 0;
   box->z = 0;
   box->w = size;
   box->h = 1;
   box->d = 1;
   box->srcx = guest_offset;
   box->srcy = 0;
   box->srcz = 0;

   pSuffix = (SVGA3dCmdSurfaceDMASuffix *)((uint8_t*)cmd + sizeof *cmd + sizeof *box);
   pSuffix->suffixSize = sizeof *pSuffix;
   pSuffix->maximumOffset = guest_offset + size;
   pSuffix->flags = flags;

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetRenderTarget --
 *
 *      Bind a surface object to a particular render target attachment
 *      point on the current context. Render target attachment points
 *      exist for color buffers, a depth buffer, and a stencil buffer.
 *
 *      The SVGA3D device is quite lenient about the types of surfaces
 *      that may be used as render targets. The color buffers must
 *      all be the same size, but the depth and stencil buffers do not
 *      have to be the same size as the color buffer. All attachments
 *      are optional.
 *
 *      Some combinations of render target formats may require software
 *      emulation, depending on the capabilities of the host graphics
 *      API and graphics hardware.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetRenderTarget(struct svga_winsys_context *swc,
                       SVGA3dRenderTargetType type,   // IN
                       struct pipe_surface *surface)  // IN
{
   SVGA3dCmdSetRenderTarget *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SETRENDERTARGET, sizeof *cmd, 1);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->type = type;
   surface_to_surfaceid(swc, surface, &cmd->target, SVGA_RELOC_WRITE);
   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_DefineShader --
 *
 *      Upload the bytecode for a new shader. The bytecode is "SVGA3D
 *      format", which is theoretically a binary-compatible superset
 *      of Microsoft's DirectX shader bytecode. In practice, the
 *      SVGA3D bytecode doesn't yet have any extensions to DirectX's
 *      bytecode format.
 *
 *      The SVGA3D device supports shader models 1.1 through 2.0.
 *
 *      The caller chooses a shader ID (small positive integer) by
 *      which this shader will be identified in future commands. This
 *      ID is in a namespace which is per-context and per-shader-type.
 *
 *      'bytecodeLen' is specified in bytes. It must be a multiple of 4.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_DefineShader(struct svga_winsys_context *swc,
                    uint32 shid,                  // IN
                    SVGA3dShaderType type,        // IN
                    const uint32 *bytecode,       // IN
                    uint32 bytecodeLen)           // IN
{
   SVGA3dCmdDefineShader *cmd;

   assert(bytecodeLen % 4 == 0);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SHADER_DEFINE, sizeof *cmd + bytecodeLen,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->shid = shid;
   cmd->type = type;
   memcpy(&cmd[1], bytecode, bytecodeLen);
   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_DestroyShader --
 *
 *      Delete a shader that was created by SVGA3D_DefineShader. If
 *      the shader was the current vertex or pixel shader for its
 *      context, rendering results are undefined until a new shader is
 *      bound.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_DestroyShader(struct svga_winsys_context *swc,
                     uint32 shid,            // IN
                     SVGA3dShaderType type)  // IN
{
   SVGA3dCmdDestroyShader *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SHADER_DESTROY, sizeof *cmd,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->shid = shid;
   cmd->type = type;
   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetShaderConst --
 *
 *      Set the value of a shader constant.
 *
 *      Shader constants are analogous to uniform variables in GLSL,
 *      except that they belong to the render context rather than to
 *      an individual shader.
 *
 *      Constants may have one of three types: A 4-vector of floats,
 *      a 4-vector of integers, or a single boolean flag.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetShaderConst(struct svga_winsys_context *swc,
                      uint32 reg,                   // IN
                      SVGA3dShaderType type,        // IN
                      SVGA3dShaderConstType ctype,  // IN
                      const void *value)            // IN
{
   SVGA3dCmdSetShaderConst *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SET_SHADER_CONST, sizeof *cmd,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->reg = reg;
   cmd->type = type;
   cmd->ctype = ctype;

   switch (ctype) {

   case SVGA3D_CONST_TYPE_FLOAT:
   case SVGA3D_CONST_TYPE_INT:
      memcpy(&cmd->values, value, sizeof cmd->values);
      break;

   case SVGA3D_CONST_TYPE_BOOL:
      memset(&cmd->values, 0, sizeof cmd->values);
      cmd->values[0] = *(uint32*)value;
      break;

   default:
      assert(0);
      break;

   }
   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetShaderConsts --
 *
 *      Set the value of successive shader constants.
 *
 *      Shader constants are analogous to uniform variables in GLSL,
 *      except that they belong to the render context rather than to
 *      an individual shader.
 *
 *      Constants may have one of three types: A 4-vector of floats,
 *      a 4-vector of integers, or a single boolean flag.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetShaderConsts(struct svga_winsys_context *swc,
                        uint32 reg,                   // IN
                        uint32 numRegs,               // IN
                        SVGA3dShaderType type,        // IN
                        SVGA3dShaderConstType ctype,  // IN
                        const void *values)           // IN
{
   SVGA3dCmdSetShaderConst *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SET_SHADER_CONST,
                            sizeof *cmd + (numRegs - 1) * sizeof cmd->values,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->reg = reg;
   cmd->type = type;
   cmd->ctype = ctype;

   memcpy(&cmd->values, values, numRegs * sizeof cmd->values);

   swc->commit(swc);

   return PIPE_OK;
}





/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetShader --
 *
 *      Switch active shaders. This binds a new vertex or pixel shader
 *      to the specified context.
 *
 *      A shader ID of SVGA3D_INVALID_ID unbinds any shader, switching
 *      back to the fixed function vertex or pixel pipeline.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetShader(struct svga_winsys_context *swc,
                 SVGA3dShaderType type,  // IN
                 uint32 shid)            // IN
{
   SVGA3dCmdSetShader *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SET_SHADER, sizeof *cmd,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->type = type;
   cmd->shid = shid;
   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_BeginClear --
 *
 *      Begin a CLEAR command. This reserves space for it in the FIFO,
 *      and returns a pointer to the command's rectangle array.  This
 *      function must be paired with SVGA_FIFOCommitAll().
 *
 *      Clear is a rendering operation which fills a list of
 *      rectangles with constant values on all render target types
 *      indicated by 'flags'.
 *
 *      Clear is not affected by clipping, depth test, or other
 *      render state which affects the fragment pipeline.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      May write to attached render target surfaces.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_BeginClear(struct svga_winsys_context *swc,
                  SVGA3dClearFlag flags,  // IN
                  uint32 color,           // IN
                  float depth,            // IN
                  uint32 stencil,         // IN
                  SVGA3dRect **rects,     // OUT
                  uint32 numRects)        // IN
{
   SVGA3dCmdClear *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_CLEAR,
                            sizeof *cmd + sizeof **rects * numRects,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->clearFlag = flags;
   cmd->color = color;
   cmd->depth = depth;
   cmd->stencil = stencil;
   *rects = (SVGA3dRect*) &cmd[1];

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_ClearRect --
 *
 *      This is a simplified version of SVGA3D_BeginClear().
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_ClearRect(struct svga_winsys_context *swc,
                 SVGA3dClearFlag flags,  // IN
                 uint32 color,           // IN
                 float depth,            // IN
                 uint32 stencil,         // IN
                 uint32 x,               // IN
                 uint32 y,               // IN
                 uint32 w,               // IN
                 uint32 h)               // IN
{
   SVGA3dRect *rect;
   enum pipe_error ret;

   ret = SVGA3D_BeginClear(swc, flags, color, depth, stencil, &rect, 1);
   if (ret != PIPE_OK)
      return PIPE_ERROR_OUT_OF_MEMORY;

   memset(rect, 0, sizeof *rect);
   rect->x = x;
   rect->y = y;
   rect->w = w;
   rect->h = h;
   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_BeginDrawPrimitives --
 *
 *      Begin a DRAW_PRIMITIVES command. This reserves space for it in
 *      the FIFO, and returns a pointer to the command's arrays.
 *      This function must be paired with SVGA_FIFOCommitAll().
 *
 *      Drawing commands consist of two variable-length arrays:
 *      SVGA3dVertexDecl elements declare a set of vertex buffers to
 *      use while rendering, and SVGA3dPrimitiveRange elements specify
 *      groups of primitives each with an optional index buffer.
 *
 *      The decls and ranges arrays are initialized to zero.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      May write to attached render target surfaces.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_BeginDrawPrimitives(struct svga_winsys_context *swc,
                           SVGA3dVertexDecl **decls,      // OUT
                           uint32 numVertexDecls,         // IN
                           SVGA3dPrimitiveRange **ranges, // OUT
                           uint32 numRanges)              // IN
{
   SVGA3dCmdDrawPrimitives *cmd;
   SVGA3dVertexDecl *declArray;
   SVGA3dPrimitiveRange *rangeArray;
   uint32 declSize = sizeof **decls * numVertexDecls;
   uint32 rangeSize = sizeof **ranges * numRanges;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_DRAW_PRIMITIVES,
                            sizeof *cmd + declSize + rangeSize,
                            numVertexDecls + numRanges);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->numVertexDecls = numVertexDecls;
   cmd->numRanges = numRanges;

   declArray = (SVGA3dVertexDecl*) &cmd[1];
   rangeArray = (SVGA3dPrimitiveRange*) &declArray[numVertexDecls];

   memset(declArray, 0, declSize);
   memset(rangeArray, 0, rangeSize);

   *decls = declArray;
   *ranges = rangeArray;

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_BeginSurfaceCopy --
 *
 *      Begin a SURFACE_COPY command. This reserves space for it in
 *      the FIFO, and returns a pointer to the command's arrays.  This
 *      function must be paired with SVGA_FIFOCommitAll().
 *
 *      The box array is initialized with zeroes.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Asynchronously copies a list of boxes from surface to surface.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_BeginSurfaceCopy(struct svga_winsys_context *swc,
                        struct pipe_surface *src,    // IN
                        struct pipe_surface *dest,   // IN
                        SVGA3dCopyBox **boxes,       // OUT
                        uint32 numBoxes)             // IN
{
   SVGA3dCmdSurfaceCopy *cmd;
   uint32 boxesSize = sizeof **boxes * numBoxes;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SURFACE_COPY, sizeof *cmd + boxesSize,
                            2);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   surface_to_surfaceid(swc, src, &cmd->src, SVGA_RELOC_READ);
   surface_to_surfaceid(swc, dest, &cmd->dest, SVGA_RELOC_WRITE);
   *boxes = (SVGA3dCopyBox*) &cmd[1];

   memset(*boxes, 0, boxesSize);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SurfaceStretchBlt --
 *
 *      Issue a SURFACE_STRETCHBLT command: an asynchronous
 *      surface-to-surface blit, with scaling.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Asynchronously copies one box from surface to surface.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SurfaceStretchBlt(struct svga_winsys_context *swc,
                         struct pipe_surface *src,    // IN
                         struct pipe_surface *dest,   // IN
                         SVGA3dBox *boxSrc,           // IN
                         SVGA3dBox *boxDest,          // IN
                         SVGA3dStretchBltMode mode)   // IN
{
   SVGA3dCmdSurfaceStretchBlt *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SURFACE_STRETCHBLT, sizeof *cmd,
                            2);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   surface_to_surfaceid(swc, src, &cmd->src, SVGA_RELOC_READ);
   surface_to_surfaceid(swc, dest, &cmd->dest, SVGA_RELOC_WRITE);
   cmd->boxSrc = *boxSrc;
   cmd->boxDest = *boxDest;
   cmd->mode = mode;
   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetViewport --
 *
 *      Set the current context's viewport rectangle. The viewport
 *      is clipped to the dimensions of the current render target,
 *      then all rendering is clipped to the viewport.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetViewport(struct svga_winsys_context *swc,
                   SVGA3dRect *rect)  // IN
{
   SVGA3dCmdSetViewport *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SETVIEWPORT, sizeof *cmd,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->rect = *rect;
   swc->commit(swc);

   return PIPE_OK;
}




/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetScissorRect --
 *
 *      Set the current context's scissor rectangle. If scissoring
 *      is enabled then all rendering is clipped to the scissor bounds.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetScissorRect(struct svga_winsys_context *swc,
                      SVGA3dRect *rect)  // IN
{
   SVGA3dCmdSetScissorRect *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SETSCISSORRECT, sizeof *cmd,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->rect = *rect;
   swc->commit(swc);

   return PIPE_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetClipPlane --
 *
 *      Set one of the current context's clip planes. If the clip
 *      plane is enabled then all 3d rendering is clipped against
 *      the plane.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetClipPlane(struct svga_winsys_context *swc,
                    uint32 index, const float *plane)
{
   SVGA3dCmdSetClipPlane *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SETCLIPPLANE, sizeof *cmd,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->index = index;
   cmd->plane[0] = plane[0];
   cmd->plane[1] = plane[1];
   cmd->plane[2] = plane[2];
   cmd->plane[3] = plane[3];
   swc->commit(swc);

   return PIPE_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetZRange --
 *
 *      Set the range of the depth buffer to use. 'min' and 'max'
 *      are values between 0.0 and 1.0.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetZRange(struct svga_winsys_context *swc,
                 float zMin,  // IN
                 float zMax)  // IN
{
   SVGA3dCmdSetZRange *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SETZRANGE, sizeof *cmd,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->zRange.min = zMin;
   cmd->zRange.max = zMax;
   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_BeginSetTextureState --
 *
 *      Begin a SETTEXTURESTATE command. This reserves space for it in
 *      the FIFO, and returns a pointer to the command's texture state
 *      array.  This function must be paired with SVGA_FIFOCommitAll().
 *
 *      This command sets rendering state which is per-texture-unit.
 *
 *      XXX: Individual texture states need documentation. However,
 *           they are very similar to the texture states defined by
 *           Direct3D. The D3D documentation is a good starting point
 *           for understanding SVGA3D texture states.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_BeginSetTextureState(struct svga_winsys_context *swc,
                            SVGA3dTextureState **states,  // OUT
                            uint32 numStates)             // IN
{
   SVGA3dCmdSetTextureState *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SETTEXTURESTATE,
                            sizeof *cmd + sizeof **states * numStates,
                            numStates);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   *states = (SVGA3dTextureState*) &cmd[1];

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_BeginSetRenderState --
 *
 *      Begin a SETRENDERSTATE command. This reserves space for it in
 *      the FIFO, and returns a pointer to the command's texture state
 *      array.  This function must be paired with SVGA_FIFOCommitAll().
 *
 *      This command sets rendering state which is global to the context.
 *
 *      XXX: Individual render states need documentation. However,
 *           they are very similar to the render states defined by
 *           Direct3D. The D3D documentation is a good starting point
 *           for understanding SVGA3D render states.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_BeginSetRenderState(struct svga_winsys_context *swc,
                           SVGA3dRenderState **states,  // OUT
                           uint32 numStates)            // IN
{
   SVGA3dCmdSetRenderState *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SETRENDERSTATE,
                            sizeof *cmd + sizeof **states * numStates,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   *states = (SVGA3dRenderState*) &cmd[1];

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_BeginGBQuery--
 *
 *      GB resource version of SVGA3D_BeginQuery.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

static enum pipe_error
SVGA3D_BeginGBQuery(struct svga_winsys_context *swc,
		    SVGA3dQueryType type) // IN
{
   SVGA3dCmdBeginGBQuery *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_BEGIN_GB_QUERY,
                            sizeof *cmd,
                            1);
   if(!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);
   cmd->type = type;

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_BeginQuery--
 *
 *      Issues a SVGA_3D_CMD_BEGIN_QUERY command.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_BeginQuery(struct svga_winsys_context *swc,
                  SVGA3dQueryType type) // IN
{
   SVGA3dCmdBeginQuery *cmd;

   if (swc->have_gb_objects)
      return SVGA3D_BeginGBQuery(swc, type);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_BEGIN_QUERY,
                            sizeof *cmd,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->type = type;

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_EndGBQuery--
 *
 *      GB resource version of SVGA3D_EndQuery.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

static enum pipe_error
SVGA3D_EndGBQuery(struct svga_winsys_context *swc,
		  SVGA3dQueryType type,              // IN
		  struct svga_winsys_buffer *buffer) // IN/OUT
{
   SVGA3dCmdEndGBQuery *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_END_GB_QUERY,
                            sizeof *cmd,
                            2);
   if(!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);
   cmd->type = type;

   swc->mob_relocation(swc, &cmd->mobid, &cmd->offset, buffer,
		       0, SVGA_RELOC_READ | SVGA_RELOC_WRITE);

   swc->commit(swc);
   
   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_EndQuery--
 *
 *      Issues a SVGA_3D_CMD_END_QUERY command.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_EndQuery(struct svga_winsys_context *swc,
                SVGA3dQueryType type,              // IN
                struct svga_winsys_buffer *buffer) // IN/OUT
{
   SVGA3dCmdEndQuery *cmd;

   if (swc->have_gb_objects)
      return SVGA3D_EndGBQuery(swc, type, buffer);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_END_QUERY,
                            sizeof *cmd,
                            1);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->type = type;

   swc->region_relocation(swc, &cmd->guestResult, buffer, 0,
                          SVGA_RELOC_READ | SVGA_RELOC_WRITE);

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_WaitForGBQuery--
 *
 *      GB resource version of SVGA3D_WaitForQuery.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

static enum pipe_error
SVGA3D_WaitForGBQuery(struct svga_winsys_context *swc,
		      SVGA3dQueryType type,              // IN
		      struct svga_winsys_buffer *buffer) // IN/OUT
{
   SVGA3dCmdWaitForGBQuery *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_WAIT_FOR_GB_QUERY,
                            sizeof *cmd,
                            2);
   if(!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);
   cmd->type = type;

   swc->mob_relocation(swc, &cmd->mobid, &cmd->offset, buffer,
		       0, SVGA_RELOC_READ | SVGA_RELOC_WRITE);

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_WaitForQuery--
 *
 *      Issues a SVGA_3D_CMD_WAIT_FOR_QUERY command.  This reserves space
 *      for it in the FIFO.  This doesn't actually wait for the query to
 *      finish but instead tells the host to start a wait at the driver
 *      level.  The caller can wait on the status variable in the
 *      guestPtr memory or send an insert fence instruction after this
 *      command and wait on the fence.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_WaitForQuery(struct svga_winsys_context *swc,
                    SVGA3dQueryType type,              // IN
                    struct svga_winsys_buffer *buffer) // IN/OUT
{
   SVGA3dCmdWaitForQuery *cmd;

   if (swc->have_gb_objects)
      return SVGA3D_WaitForGBQuery(swc, type, buffer);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_WAIT_FOR_QUERY,
                            sizeof *cmd,
                            1);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->type = type;

   swc->region_relocation(swc, &cmd->guestResult, buffer, 0,
                          SVGA_RELOC_READ | SVGA_RELOC_WRITE);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_DefineGBShader(struct svga_winsys_context *swc,
                      struct svga_winsys_gb_shader *gbshader,
                      SVGA3dShaderType type,
                      uint32 sizeInBytes)
{
   SVGA3dCmdDefineGBShader *cmd;

   assert(sizeInBytes % 4 == 0);
   assert(type == SVGA3D_SHADERTYPE_VS ||
          type == SVGA3D_SHADERTYPE_PS);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_DEFINE_GB_SHADER,
                            sizeof *cmd,
                            1); /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->shader_relocation(swc, &cmd->shid, NULL, NULL, gbshader);
   cmd->type = type;
   cmd->sizeInBytes = sizeInBytes;

   swc->commit(swc);
   
   return PIPE_OK;
}


enum pipe_error
SVGA3D_BindGBShader(struct svga_winsys_context *swc,
                    struct svga_winsys_gb_shader *gbshader)
{
   SVGA3dCmdBindGBShader *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_BIND_GB_SHADER,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->shader_relocation(swc, &cmd->shid, &cmd->mobid,
			  &cmd->offsetInBytes, gbshader);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_SetGBShader(struct svga_winsys_context *swc,
                   SVGA3dShaderType type,  // IN
                   struct svga_winsys_gb_shader *gbshader)
{
   SVGA3dCmdSetShader *cmd;
   
   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SET_SHADER,
                            sizeof *cmd,
                            2);  /* two relocations */
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;
   
   swc->context_relocation(swc, &cmd->cid);
   cmd->type = type;
   if (gbshader)
      swc->shader_relocation(swc, &cmd->shid, NULL, NULL, gbshader);
   else
      cmd->shid = SVGA_ID_INVALID;
   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_DestroyGBShader(struct svga_winsys_context *swc,
                       struct svga_winsys_gb_shader *gbshader)
{
   SVGA3dCmdDestroyGBShader *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_DESTROY_GB_SHADER,
                         sizeof *cmd,
                         1); /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->shader_relocation(swc, &cmd->shid, NULL, NULL, gbshader);

   swc->commit(swc);

   return PIPE_OK;
}


/**
 * \param flags  mask of SVGA_RELOC_READ / _WRITE
 */
enum pipe_error
SVGA3D_BindGBSurface(struct svga_winsys_context *swc,
                     struct svga_winsys_surface *surface)
{
   SVGA3dCmdBindGBSurface *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_BIND_GB_SURFACE,
                         sizeof *cmd,
                         2);  /* two relocations */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->sid, &cmd->mobid, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_DefineGBContext(struct svga_winsys_context *swc)
{
   SVGA3dCmdDefineGBContext *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_DEFINE_GB_CONTEXT,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_DestroyGBContext(struct svga_winsys_context *swc)
{
   SVGA3dCmdDestroyGBContext *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_DESTROY_GB_CONTEXT,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_BindGBContext(struct svga_winsys_context *swc)
{
   SVGA3dCmdBindGBContext *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_BIND_GB_CONTEXT,
                         sizeof *cmd,
                         2);  /* two relocations */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);
   swc->context_relocation(swc, &cmd->mobid);
   cmd->validContents = 0;  /* XXX pass as a parameter? */

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_InvalidateGBContext(struct svga_winsys_context *swc)
{
   SVGA3dCmdInvalidateGBContext *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_INVALIDATE_GB_CONTEXT,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);

   swc->commit(swc);

   return PIPE_OK;
}



/**
 * Update an image in a guest-backed surface.
 * (Inform the device that the guest-contents have been updated.)
 */
enum pipe_error
SVGA3D_UpdateGBImage(struct svga_winsys_context *swc,
                     struct svga_winsys_surface *surface,
                     const SVGA3dBox *box,
                     unsigned face, unsigned mipLevel)

{
   SVGA3dCmdUpdateGBImage *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_UPDATE_GB_IMAGE,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->image.sid, NULL, surface,
                           SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);
   cmd->image.face = face;
   cmd->image.mipmap = mipLevel;
   cmd->box = *box;

   swc->commit(swc);

   return PIPE_OK;
}


/**
 * Update an entire guest-backed surface.
 * (Inform the device that the guest-contents have been updated.)
 */
enum pipe_error
SVGA3D_UpdateGBSurface(struct svga_winsys_context *swc,
                       struct svga_winsys_surface *surface)
{
   SVGA3dCmdUpdateGBSurface *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_UPDATE_GB_SURFACE,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->sid, NULL, surface,
                           SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);

   swc->commit(swc);

   return PIPE_OK;
}


/**
 * Readback an image in a guest-backed surface.
 * (Request the device to flush the dirty contents into the guest.)
 */
enum pipe_error
SVGA3D_ReadbackGBImage(struct svga_winsys_context *swc,
                       struct svga_winsys_surface *surface,
                       unsigned face, unsigned mipLevel)
{
   SVGA3dCmdReadbackGBImage *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_READBACK_GB_IMAGE,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->image.sid, NULL, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);
   cmd->image.face = face;
   cmd->image.mipmap = mipLevel;

   swc->commit(swc);

   return PIPE_OK;
}


/**
 * Readback an entire guest-backed surface.
 * (Request the device to flush the dirty contents into the guest.)
 */
enum pipe_error
SVGA3D_ReadbackGBSurface(struct svga_winsys_context *swc,
                         struct svga_winsys_surface *surface)
{
   SVGA3dCmdReadbackGBSurface *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_READBACK_GB_SURFACE,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->sid, NULL, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_ReadbackGBImagePartial(struct svga_winsys_context *swc,
                              struct svga_winsys_surface *surface,
                              unsigned face, unsigned mipLevel,
                              const SVGA3dBox *box,
                              bool invertBox)
{
   SVGA3dCmdReadbackGBImagePartial *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_READBACK_GB_IMAGE_PARTIAL,
                         sizeof *cmd,
                         1);  /* one relocation */
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->image.sid, NULL, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);
   cmd->image.face = face;
   cmd->image.mipmap = mipLevel;
   cmd->box = *box;
   cmd->invertBox = invertBox;

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_InvalidateGBImagePartial(struct svga_winsys_context *swc,
                                struct svga_winsys_surface *surface,
                                unsigned face, unsigned mipLevel,
                                const SVGA3dBox *box,
                                bool invertBox)
{
   SVGA3dCmdInvalidateGBImagePartial *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_INVALIDATE_GB_IMAGE_PARTIAL,
                         sizeof *cmd,
                         1);  /* one relocation */
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->image.sid, NULL, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);
   cmd->image.face = face;
   cmd->image.mipmap = mipLevel;
   cmd->box = *box;
   cmd->invertBox = invertBox;

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_SetGBShaderConstsInline(struct svga_winsys_context *swc,
                              unsigned regStart,
                              unsigned numRegs,
                              SVGA3dShaderType shaderType,
                              SVGA3dShaderConstType constType,
                              const void *values)
{
   SVGA3dCmdSetGBShaderConstInline *cmd;

   assert(numRegs > 0);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SET_GB_SHADERCONSTS_INLINE,
                            sizeof *cmd + numRegs * sizeof(float[4]),
                            0); /* no relocations */
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->regStart = regStart;
   cmd->shaderType = shaderType;
   cmd->constType = constType;

   memcpy(&cmd[1], values, numRegs * sizeof(float[4]));

   swc->commit(swc);

   return PIPE_OK;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1655 1
a1655 1
                         2);  /* two relocations */
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1655 1
a1655 1
                         1);  /* one relocation */
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d48 3
d68 1
a68 1
      swc->surface_relocation(swc, &id->sid, s->handle, flags);
d73 1
a73 1
      swc->surface_relocation(swc, &id->sid, NULL, flags);
d286 2
a287 1
   swc->surface_relocation(swc, &cmd->sid, sid, SVGA_RELOC_WRITE);
d372 3
a374 2

   swc->surface_relocation(swc, &cmd->sid, sid, SVGA_RELOC_READ);
d461 2
a462 1
   swc->surface_relocation(swc, &cmd->host.sid, texture->handle, surface_flags);
d496 2
d522 2
a523 1
   swc->surface_relocation(swc, &cmd->host.sid, host, surface_flags);
d1362 38
d1419 3
d1441 42
d1503 3
d1517 43
a1559 1
                          SVGA_RELOC_WRITE);
d1595 3
d1609 409
a2017 1
                          SVGA_RELOC_WRITE);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d57 5
a61 5
static INLINE
void surface_to_surfaceid(struct svga_winsys_context *swc, // IN
                          struct pipe_surface *surface,    // IN
                          SVGA3dSurfaceImageId *id,        // OUT
                          unsigned flags)                  // IN
d63 1
a63 1
   if(surface) {
d113 1
a113 1
   if(!header)
d165 1
a165 1
   if(!cmd)
d171 1
a171 1
   
d196 1
a196 1
   
d199 1
a199 1
   if(!cmd)
d201 1
a201 1
   
d203 1
a203 1
   
d205 1
a205 1
   
d280 1
a280 1
   if(!cmd)
d292 1
a292 1
   
d327 1
a327 1
   if(ret != PIPE_OK)
d335 1
a335 1
 
d337 1
a337 1
   
d363 1
a363 1
   
d366 1
a366 1
   if(!cmd)
d368 1
a368 1
   
d371 1
a371 1
   
d426 1
a426 1
   struct svga_texture *texture = svga_texture(st->base.resource); 
d432 2
a433 2
   
   if(transfer == SVGA3D_WRITE_HOST_VRAM) {
d437 1
a437 1
   else if(transfer == SVGA3D_READ_HOST_VRAM) {
d445 1
a445 1
   
d450 1
a450 1
   if(!cmd)
d463 1
a463 1
   
d490 2
a491 2
   
   if(transfer == SVGA3D_WRITE_HOST_VRAM) {
d495 1
a495 1
   else if(transfer == SVGA3D_READ_HOST_VRAM) {
d503 1
a503 1
   
d508 1
a508 1
   if(!cmd)
d530 1
a530 1
   
d576 1
a576 1
   
d579 1
a579 1
   if(!cmd)
a581 1

a582 1

a583 1

a584 1

a590 4




d633 1
a633 1
   if(!cmd)
d671 1
a671 1
   
d675 1
a675 1
   if(!cmd)
d718 1
a718 1
   
d722 1
a722 1
   if(!cmd)
d753 53
d835 1
a835 1
   
d839 1
a839 1
   if(!cmd)
d841 1
a841 1
   
d886 1
a886 1
   
d888 1
a888 1
                            SVGA_3D_CMD_CLEAR, 
d891 1
a891 1
   if(!cmd)
d936 1
a936 1
   if(ret != PIPE_OK)
d989 1
a989 1
                            SVGA_3D_CMD_DRAW_PRIMITIVES, 
d992 1
a992 1
   if(!cmd)
d1045 1
a1045 1
   if(!cmd)
d1084 1
a1084 1
   
d1088 1
a1088 1
   if(!cmd)
d1125 1
a1125 1
   
d1129 1
a1129 1
   if(!cmd)
d1147 2
a1148 2
 *      Set the current context's scissor rectangle. If scissor
 *      is enabled then all rendering is clipped to the scissor.
d1164 1
a1164 1
   
d1168 1
a1168 1
   if(!cmd)
d1184 1
a1184 1
 *      plane is enabled then all 3d rendering is clipped to against
d1196 3
a1198 2
enum pipe_error SVGA3D_SetClipPlane(struct svga_winsys_context *swc,
                         uint32 index, const float *plane)
d1201 1
a1201 1
   
d1205 1
a1205 1
   if(!cmd)
d1242 1
a1242 1
   
d1246 1
a1246 1
   if(!cmd)
d1289 1
a1289 1
   
d1291 1
a1291 1
                            SVGA_3D_CMD_SETTEXTURESTATE, 
d1294 1
a1294 1
   if(!cmd)
d1335 1
a1335 1
   
d1337 1
a1337 1
                            SVGA_3D_CMD_SETRENDERSTATE, 
d1340 1
a1340 1
   if(!cmd)
d1376 1
a1376 1
   if(!cmd)
d1383 1
a1383 1
   
d1412 1
a1412 1
                            SVGA_3D_CMD_END_QUERY, 
d1415 1
a1415 1
   if(!cmd)
d1425 1
a1425 1
   
d1459 1
a1459 1
                            SVGA_3D_CMD_WAIT_FOR_QUERY, 
d1462 1
a1462 1
   if(!cmd)
d1467 1
a1467 1
   
d1472 1
a1472 1
   
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d49 1
a49 1
 *      id is filld out.
d52 1
a52 1
 *      One surface relocation is preformed for texture handle.
d227 1
a227 1
 *      Surfaces are hierarchial:
d379 1
a379 1
 * SVGA3D_BeginSurfaceDMA--
d381 1
a381 3
 *      Begin a SURFACE_DMA command. This reserves space for it in
 *      the FIFO, and returns a pointer to the command's box array.
 *      This function must be paired with SVGA_FIFOCommitAll().
d423 2
a424 1
                  uint32 numBoxes)                  // IN
d467 1
a467 1
   memset(&pSuffix->flags, 0, sizeof pSuffix->flags);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 3
a36 2
#include "svga_screen_buffer.h"
#include "svga_screen_texture.h"
d70 1
a70 1
      id->sid = SVGA3D_INVALID_ID;
d283 1
a283 1
   swc->surface_relocation(swc, &cmd->sid, sid, PIPE_BUFFER_USAGE_GPU_WRITE);
d369 1
a369 1
   swc->surface_relocation(swc, &cmd->sid, sid, PIPE_BUFFER_USAGE_GPU_READ);
d427 1
a427 1
   struct svga_texture *texture = svga_texture(st->base.texture); 
d435 2
a436 2
      region_flags = PIPE_BUFFER_USAGE_GPU_READ;
      surface_flags = PIPE_BUFFER_USAGE_GPU_WRITE;
d439 2
a440 2
      region_flags = PIPE_BUFFER_USAGE_GPU_WRITE;
      surface_flags = PIPE_BUFFER_USAGE_GPU_READ;
d458 1
a458 1
   cmd->host.face = st->base.face; /* PIPE_TEX_FACE_* and SVGA3D_CUBEFACE_* match */
d493 2
a494 2
      region_flags = PIPE_BUFFER_USAGE_GPU_READ;
      surface_flags = PIPE_BUFFER_USAGE_GPU_WRITE;
d497 2
a498 2
      region_flags = PIPE_BUFFER_USAGE_GPU_WRITE;
      surface_flags = PIPE_BUFFER_USAGE_GPU_READ;
d588 1
a588 1
   surface_to_surfaceid(swc, surface, &cmd->target, PIPE_BUFFER_USAGE_GPU_WRITE);
d1004 2
a1005 2
   surface_to_surfaceid(swc, src, &cmd->src, PIPE_BUFFER_USAGE_GPU_READ);
   surface_to_surfaceid(swc, dest, &cmd->dest, PIPE_BUFFER_USAGE_GPU_WRITE);
d1047 2
a1048 2
   surface_to_surfaceid(swc, src, &cmd->src, PIPE_BUFFER_USAGE_GPU_READ);
   surface_to_surfaceid(swc, dest, &cmd->dest, PIPE_BUFFER_USAGE_GPU_WRITE);
d1377 1
a1377 1
                          PIPE_BUFFER_USAGE_GPU_WRITE);
d1424 1
a1424 1
                          PIPE_BUFFER_USAGE_GPU_WRITE);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 2
a35 3
#include "svga_resource_buffer.h"
#include "svga_resource_texture.h"
#include "svga_surface.h"
d69 1
a69 1
      swc->surface_relocation(swc, &id->sid, NULL, flags);
d282 1
a282 1
   swc->surface_relocation(swc, &cmd->sid, sid, SVGA_RELOC_WRITE);
d368 1
a368 1
   swc->surface_relocation(swc, &cmd->sid, sid, SVGA_RELOC_READ);
d426 1
a426 1
   struct svga_texture *texture = svga_texture(st->base.resource); 
d434 2
a435 2
      region_flags = SVGA_RELOC_READ;
      surface_flags = SVGA_RELOC_WRITE;
d438 2
a439 2
      region_flags = SVGA_RELOC_WRITE;
      surface_flags = SVGA_RELOC_READ;
d457 1
a457 1
   cmd->host.face = st->face; /* PIPE_TEX_FACE_* and SVGA3D_CUBEFACE_* match */
d492 2
a493 2
      region_flags = SVGA_RELOC_READ;
      surface_flags = SVGA_RELOC_WRITE;
d496 2
a497 2
      region_flags = SVGA_RELOC_WRITE;
      surface_flags = SVGA_RELOC_READ;
d587 1
a587 1
   surface_to_surfaceid(swc, surface, &cmd->target, SVGA_RELOC_WRITE);
d1003 2
a1004 2
   surface_to_surfaceid(swc, src, &cmd->src, SVGA_RELOC_READ);
   surface_to_surfaceid(swc, dest, &cmd->dest, SVGA_RELOC_WRITE);
d1046 2
a1047 2
   surface_to_surfaceid(swc, src, &cmd->src, SVGA_RELOC_READ);
   surface_to_surfaceid(swc, dest, &cmd->dest, SVGA_RELOC_WRITE);
d1376 1
a1376 1
                          SVGA_RELOC_WRITE);
d1423 1
a1423 1
                          SVGA_RELOC_WRITE);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d49 1
a49 1
 *      id is filled out.
d52 1
a52 1
 *      One surface relocation is performed for texture handle.
d57 5
a61 5
static INLINE void
surface_to_surfaceid(struct svga_winsys_context *swc, // IN
                     struct pipe_surface *surface,    // IN
                     SVGA3dSurfaceImageId *id,        // OUT
                     unsigned flags)                  // IN
d63 1
a63 1
   if (surface) {
d113 1
a113 1
   if (!header)
d165 1
a165 1
   if (!cmd)
d171 1
a171 1

d196 1
a196 1

d199 1
a199 1
   if (!cmd)
d201 1
a201 1

d203 1
a203 1

d205 1
a205 1

d227 1
a227 1
 *      Surfaces are hierarchical:
d280 1
a280 1
   if (!cmd)
d292 1
a292 1

d327 1
a327 1
   if (ret != PIPE_OK)
d335 1
a335 1

d337 1
a337 1

d363 1
a363 1

d366 1
a366 1
   if (!cmd)
d368 1
a368 1

d371 1
a371 1

d379 1
a379 1
 * SVGA3D_SurfaceDMA--
d381 3
a383 1
 *      Emit a SURFACE_DMA command.
d425 1
a425 2
                  uint32 numBoxes,                  // IN
                  SVGA3dSurfaceDMAFlags flags)      // IN
d427 1
a427 1
   struct svga_texture *texture = svga_texture(st->base.resource);
d433 2
a434 2

   if (transfer == SVGA3D_WRITE_HOST_VRAM) {
d438 1
a438 1
   else if (transfer == SVGA3D_READ_HOST_VRAM) {
d446 1
a446 1

d451 1
a451 1
   if (!cmd)
d464 1
a464 1

d468 1
a468 1
   pSuffix->flags = flags;
d491 2
a492 2

   if (transfer == SVGA3D_WRITE_HOST_VRAM) {
d496 1
a496 1
   else if (transfer == SVGA3D_READ_HOST_VRAM) {
d504 1
a504 1

d509 1
a509 1
   if (!cmd)
d531 1
a531 1

d577 1
a577 1

d580 1
a580 1
   if (!cmd)
d583 1
d585 1
d587 1
d589 1
d596 4
d642 1
a642 1
   if (!cmd)
d680 1
a680 1

d684 1
a684 1
   if (!cmd)
d727 1
a727 1

d731 1
a731 1
   if (!cmd)
a761 53
/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_SetShaderConsts --
 *
 *      Set the value of successive shader constants.
 *
 *      Shader constants are analogous to uniform variables in GLSL,
 *      except that they belong to the render context rather than to
 *      an individual shader.
 *
 *      Constants may have one of three types: A 4-vector of floats,
 *      a 4-vector of integers, or a single boolean flag.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

enum pipe_error
SVGA3D_SetShaderConsts(struct svga_winsys_context *swc,
                        uint32 reg,                   // IN
                        uint32 numRegs,               // IN
                        SVGA3dShaderType type,        // IN
                        SVGA3dShaderConstType ctype,  // IN
                        const void *values)           // IN
{
   SVGA3dCmdSetShaderConst *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SET_SHADER_CONST,
                            sizeof *cmd + (numRegs - 1) * sizeof cmd->values,
                            0);
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->reg = reg;
   cmd->type = type;
   cmd->ctype = ctype;

   memcpy(&cmd->values, values, numRegs * sizeof cmd->values);

   swc->commit(swc);

   return PIPE_OK;
}


d791 1
a791 1

d795 1
a795 1
   if (!cmd)
d797 1
a797 1

d842 1
a842 1

d844 1
a844 1
                            SVGA_3D_CMD_CLEAR,
d847 1
a847 1
   if (!cmd)
d892 1
a892 1
   if (ret != PIPE_OK)
d945 1
a945 1
                            SVGA_3D_CMD_DRAW_PRIMITIVES,
d948 1
a948 1
   if (!cmd)
d1001 1
a1001 1
   if (!cmd)
d1040 1
a1040 1

d1044 1
a1044 1
   if (!cmd)
d1081 1
a1081 1

d1085 1
a1085 1
   if (!cmd)
d1103 2
a1104 2
 *      Set the current context's scissor rectangle. If scissoring
 *      is enabled then all rendering is clipped to the scissor bounds.
d1120 1
a1120 1

d1124 1
a1124 1
   if (!cmd)
d1140 1
a1140 1
 *      plane is enabled then all 3d rendering is clipped against
d1152 2
a1153 3
enum pipe_error
SVGA3D_SetClipPlane(struct svga_winsys_context *swc,
                    uint32 index, const float *plane)
d1156 1
a1156 1

d1160 1
a1160 1
   if (!cmd)
d1197 1
a1197 1

d1201 1
a1201 1
   if (!cmd)
d1244 1
a1244 1

d1246 1
a1246 1
                            SVGA_3D_CMD_SETTEXTURESTATE,
d1249 1
a1249 1
   if (!cmd)
d1290 1
a1290 1

d1292 1
a1292 1
                            SVGA_3D_CMD_SETRENDERSTATE,
d1295 1
a1295 1
   if (!cmd)
d1331 1
a1331 1
   if (!cmd)
d1338 1
a1338 1

d1367 1
a1367 1
                            SVGA_3D_CMD_END_QUERY,
d1370 1
a1370 1
   if (!cmd)
d1380 1
a1380 1

d1414 1
a1414 1
                            SVGA_3D_CMD_WAIT_FOR_QUERY,
d1417 1
a1417 1
   if (!cmd)
d1422 1
a1422 1

d1427 1
a1427 1

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a47 3
 *
 * param flags  mask of SVGA_RELOC_READ / _WRITE
 *
d65 1
a65 1
      swc->surface_relocation(swc, &id->sid, NULL, s->handle, flags);
d70 1
a70 1
      swc->surface_relocation(swc, &id->sid, NULL, NULL, flags);
d283 1
a283 2
   swc->surface_relocation(swc, &cmd->sid, NULL, sid,
                           SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);
d368 2
a369 3
   
   swc->surface_relocation(swc, &cmd->sid, NULL, sid,
                           SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);
d456 1
a456 2
   swc->surface_relocation(swc, &cmd->host.sid, NULL,
                           texture->handle, surface_flags);
a489 2
   
   assert(!swc->have_gb_objects);
d514 1
a514 2
   swc->surface_relocation(swc, &cmd->host.sid,
                           NULL, host, surface_flags);
a1352 38
 * SVGA3D_BeginGBQuery--
 *
 *      GB resource version of SVGA3D_BeginQuery.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

static enum pipe_error
SVGA3D_BeginGBQuery(struct svga_winsys_context *swc,
		    SVGA3dQueryType type) // IN
{
   SVGA3dCmdBeginGBQuery *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_BEGIN_GB_QUERY,
                            sizeof *cmd,
                            1);
   if(!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);
   cmd->type = type;

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
a1371 3
   if (swc->have_gb_objects)
      return SVGA3D_BeginGBQuery(swc, type);

a1390 42
 * SVGA3D_EndGBQuery--
 *
 *      GB resource version of SVGA3D_EndQuery.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

static enum pipe_error
SVGA3D_EndGBQuery(struct svga_winsys_context *swc,
		  SVGA3dQueryType type,              // IN
		  struct svga_winsys_buffer *buffer) // IN/OUT
{
   SVGA3dCmdEndGBQuery *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_END_GB_QUERY,
                            sizeof *cmd,
                            2);
   if(!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);
   cmd->type = type;

   swc->mob_relocation(swc, &cmd->mobid, &cmd->offset, buffer,
		       0, SVGA_RELOC_READ | SVGA_RELOC_WRITE);

   swc->commit(swc);
   
   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
a1410 3
   if (swc->have_gb_objects)
      return SVGA3D_EndGBQuery(swc, type, buffer);

d1422 1
a1422 43
                          SVGA_RELOC_READ | SVGA_RELOC_WRITE);

   swc->commit(swc);

   return PIPE_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * SVGA3D_WaitForGBQuery--
 *
 *      GB resource version of SVGA3D_WaitForQuery.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Commits space in the FIFO memory.
 *
 *----------------------------------------------------------------------
 */

static enum pipe_error
SVGA3D_WaitForGBQuery(struct svga_winsys_context *swc,
		      SVGA3dQueryType type,              // IN
		      struct svga_winsys_buffer *buffer) // IN/OUT
{
   SVGA3dCmdWaitForGBQuery *cmd;

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_WAIT_FOR_GB_QUERY,
                            sizeof *cmd,
                            2);
   if(!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);
   cmd->type = type;

   swc->mob_relocation(swc, &cmd->mobid, &cmd->offset, buffer,
		       0, SVGA_RELOC_READ | SVGA_RELOC_WRITE);
a1457 3
   if (swc->have_gb_objects)
      return SVGA3D_WaitForGBQuery(swc, type, buffer);

d1469 1
a1469 409
                          SVGA_RELOC_READ | SVGA_RELOC_WRITE);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_DefineGBShader(struct svga_winsys_context *swc,
                      struct svga_winsys_gb_shader *gbshader,
                      SVGA3dShaderType type,
                      uint32 sizeInBytes)
{
   SVGA3dCmdDefineGBShader *cmd;

   assert(sizeInBytes % 4 == 0);
   assert(type == SVGA3D_SHADERTYPE_VS ||
          type == SVGA3D_SHADERTYPE_PS);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_DEFINE_GB_SHADER,
                            sizeof *cmd,
                            1); /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->shader_relocation(swc, &cmd->shid, NULL, NULL, gbshader);
   cmd->type = type;
   cmd->sizeInBytes = sizeInBytes;

   swc->commit(swc);
   
   return PIPE_OK;
}


enum pipe_error
SVGA3D_BindGBShader(struct svga_winsys_context *swc,
                    struct svga_winsys_gb_shader *gbshader)
{
   SVGA3dCmdBindGBShader *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_BIND_GB_SHADER,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->shader_relocation(swc, &cmd->shid, &cmd->mobid,
			  &cmd->offsetInBytes, gbshader);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_SetGBShader(struct svga_winsys_context *swc,
                   SVGA3dShaderType type,  // IN
                   struct svga_winsys_gb_shader *gbshader)
{
   SVGA3dCmdSetShader *cmd;
   
   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SET_SHADER,
                            sizeof *cmd,
                            2);  /* two relocations */
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;
   
   swc->context_relocation(swc, &cmd->cid);
   cmd->type = type;
   if (gbshader)
      swc->shader_relocation(swc, &cmd->shid, NULL, NULL, gbshader);
   else
      cmd->shid = SVGA_ID_INVALID;
   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_DestroyGBShader(struct svga_winsys_context *swc,
                       struct svga_winsys_gb_shader *gbshader)
{
   SVGA3dCmdDestroyGBShader *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_DESTROY_GB_SHADER,
                         sizeof *cmd,
                         1); /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->shader_relocation(swc, &cmd->shid, NULL, NULL, gbshader);

   swc->commit(swc);

   return PIPE_OK;
}


/**
 * \param flags  mask of SVGA_RELOC_READ / _WRITE
 */
enum pipe_error
SVGA3D_BindGBSurface(struct svga_winsys_context *swc,
                     struct svga_winsys_surface *surface)
{
   SVGA3dCmdBindGBSurface *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_BIND_GB_SURFACE,
                         sizeof *cmd,
                         2);  /* two relocations */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->sid, &cmd->mobid, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_DefineGBContext(struct svga_winsys_context *swc)
{
   SVGA3dCmdDefineGBContext *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_DEFINE_GB_CONTEXT,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_DestroyGBContext(struct svga_winsys_context *swc)
{
   SVGA3dCmdDestroyGBContext *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_DESTROY_GB_CONTEXT,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_BindGBContext(struct svga_winsys_context *swc)
{
   SVGA3dCmdBindGBContext *cmd = 
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_BIND_GB_CONTEXT,
                         sizeof *cmd,
                         2);  /* two relocations */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);
   swc->context_relocation(swc, &cmd->mobid);
   cmd->validContents = 0;  /* XXX pass as a parameter? */

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_InvalidateGBContext(struct svga_winsys_context *swc)
{
   SVGA3dCmdInvalidateGBContext *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_INVALIDATE_GB_CONTEXT,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->context_relocation(swc, &cmd->cid);

   swc->commit(swc);

   return PIPE_OK;
}



/**
 * Update an image in a guest-backed surface.
 * (Inform the device that the guest-contents have been updated.)
 */
enum pipe_error
SVGA3D_UpdateGBImage(struct svga_winsys_context *swc,
                     struct svga_winsys_surface *surface,
                     const SVGA3dBox *box,
                     unsigned face, unsigned mipLevel)

{
   SVGA3dCmdUpdateGBImage *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_UPDATE_GB_IMAGE,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->image.sid, NULL, surface,
                           SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);
   cmd->image.face = face;
   cmd->image.mipmap = mipLevel;
   cmd->box = *box;

   swc->commit(swc);

   return PIPE_OK;
}


/**
 * Update an entire guest-backed surface.
 * (Inform the device that the guest-contents have been updated.)
 */
enum pipe_error
SVGA3D_UpdateGBSurface(struct svga_winsys_context *swc,
                       struct svga_winsys_surface *surface)
{
   SVGA3dCmdUpdateGBSurface *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_UPDATE_GB_SURFACE,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->sid, NULL, surface,
                           SVGA_RELOC_WRITE | SVGA_RELOC_INTERNAL);

   swc->commit(swc);

   return PIPE_OK;
}


/**
 * Readback an image in a guest-backed surface.
 * (Request the device to flush the dirty contents into the guest.)
 */
enum pipe_error
SVGA3D_ReadbackGBImage(struct svga_winsys_context *swc,
                       struct svga_winsys_surface *surface,
                       unsigned face, unsigned mipLevel)
{
   SVGA3dCmdReadbackGBImage *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_READBACK_GB_IMAGE,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->image.sid, NULL, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);
   cmd->image.face = face;
   cmd->image.mipmap = mipLevel;

   swc->commit(swc);

   return PIPE_OK;
}


/**
 * Readback an entire guest-backed surface.
 * (Request the device to flush the dirty contents into the guest.)
 */
enum pipe_error
SVGA3D_ReadbackGBSurface(struct svga_winsys_context *swc,
                         struct svga_winsys_surface *surface)
{
   SVGA3dCmdReadbackGBSurface *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_READBACK_GB_SURFACE,
                         sizeof *cmd,
                         1);  /* one relocation */

   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->sid, NULL, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_ReadbackGBImagePartial(struct svga_winsys_context *swc,
                              struct svga_winsys_surface *surface,
                              unsigned face, unsigned mipLevel,
                              const SVGA3dBox *box,
                              bool invertBox)
{
   SVGA3dCmdReadbackGBImagePartial *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_READBACK_GB_IMAGE_PARTIAL,
                         sizeof *cmd,
                         1);  /* one relocation */
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->image.sid, NULL, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);
   cmd->image.face = face;
   cmd->image.mipmap = mipLevel;
   cmd->box = *box;
   cmd->invertBox = invertBox;

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_InvalidateGBImagePartial(struct svga_winsys_context *swc,
                                struct svga_winsys_surface *surface,
                                unsigned face, unsigned mipLevel,
                                const SVGA3dBox *box,
                                bool invertBox)
{
   SVGA3dCmdInvalidateGBImagePartial *cmd =
      SVGA3D_FIFOReserve(swc,
                         SVGA_3D_CMD_INVALIDATE_GB_IMAGE_PARTIAL,
                         sizeof *cmd,
                         1);  /* one relocation */
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   swc->surface_relocation(swc, &cmd->image.sid, NULL, surface,
                           SVGA_RELOC_READ | SVGA_RELOC_INTERNAL);
   cmd->image.face = face;
   cmd->image.mipmap = mipLevel;
   cmd->box = *box;
   cmd->invertBox = invertBox;

   swc->commit(swc);

   return PIPE_OK;
}


enum pipe_error
SVGA3D_SetGBShaderConstsInline(struct svga_winsys_context *swc,
                              unsigned regStart,
                              unsigned numRegs,
                              SVGA3dShaderType shaderType,
                              SVGA3dShaderConstType constType,
                              const void *values)
{
   SVGA3dCmdSetGBShaderConstInline *cmd;

   assert(numRegs > 0);

   cmd = SVGA3D_FIFOReserve(swc,
                            SVGA_3D_CMD_SET_GB_SHADERCONSTS_INLINE,
                            sizeof *cmd + numRegs * sizeof(float[4]),
                            0); /* no relocations */
   if (!cmd)
      return PIPE_ERROR_OUT_OF_MEMORY;

   cmd->cid = swc->cid;
   cmd->regStart = regStart;
   cmd->shaderType = shaderType;
   cmd->constType = constType;

   memcpy(&cmd[1], values, numRegs * sizeof(float[4]));
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d1655 1
a1655 1
                         2);  /* two relocations */
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d1655 1
a1655 1
                         1);  /* one relocation */
@


