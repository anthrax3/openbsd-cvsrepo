head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.01.09;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.12.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.16;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "svga_cmd.h"

#include "pipe/p_state.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "os/os_thread.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_resource.h"

#include "svga_context.h"
#include "svga_screen.h"
#include "svga_resource_buffer.h"
#include "svga_resource_buffer_upload.h"
#include "svga_winsys.h"
#include "svga_debug.h"


/**
 * Vertex and index buffers need hardware backing.  Constant buffers
 * do not.  No other types of buffers currently supported.
 */
static INLINE boolean
svga_buffer_needs_hw_storage(unsigned usage)
{
   return usage & (PIPE_BIND_VERTEX_BUFFER | PIPE_BIND_INDEX_BUFFER);
}


/**
 * Create a buffer transfer.
 *
 * Unlike texture DMAs (which are written immediately to the command buffer and
 * therefore inherently serialized with other context operations), for buffers
 * we try to coalesce multiple range mappings (i.e, multiple calls to this
 * function) into a single DMA command, for better efficiency in command
 * processing.  This means we need to exercise extra care here to ensure that
 * the end result is exactly the same as if one DMA was used for every mapped
 * range.
 */
static void *
svga_buffer_transfer_map(struct pipe_context *pipe,
                         struct pipe_resource *resource,
                         unsigned level,
                         unsigned usage,
                         const struct pipe_box *box,
                         struct pipe_transfer **ptransfer)
{
   struct svga_context *svga = svga_context(pipe);
   struct svga_screen *ss = svga_screen(pipe->screen);
   struct svga_buffer *sbuf = svga_buffer(resource);
   struct pipe_transfer *transfer;
   uint8_t *map;

   transfer = CALLOC_STRUCT(pipe_transfer);
   if (transfer == NULL) {
      return NULL;
   }

   transfer->resource = resource;
   transfer->level = level;
   transfer->usage = usage;
   transfer->box = *box;

   if (usage & PIPE_TRANSFER_WRITE) {
      if (usage & PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE) {
         /*
          * Flush any pending primitives, finish writing any pending DMA
          * commands, and tell the host to discard the buffer contents on
          * the next DMA operation.
          */

         svga_hwtnl_flush_buffer(svga, resource);

         if (sbuf->dma.pending) {
            svga_buffer_upload_flush(svga, sbuf);

            /*
             * Instead of flushing the context command buffer, simply discard
             * the current hwbuf, and start a new one.
             * With GB objects, the map operation takes care of this
             * if passed the PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE flag,
             * and the old backing store is busy.
             */

            if (!svga_have_gb_objects(svga))
               svga_buffer_destroy_hw_storage(ss, sbuf);
         }

         sbuf->map.num_ranges = 0;
         sbuf->dma.flags.discard = TRUE;
      }

      if (usage & PIPE_TRANSFER_UNSYNCHRONIZED) {
         if (!sbuf->map.num_ranges) {
            /*
             * No pending ranges to upload so far, so we can tell the host to
             * not synchronize on the next DMA command.
             */

            sbuf->dma.flags.unsynchronized = TRUE;
         }
      } else {
         /*
          * Synchronizing, so flush any pending primitives, finish writing any
          * pending DMA command, and ensure the next DMA will be done in order.
          */

         svga_hwtnl_flush_buffer(svga, resource);

         if (sbuf->dma.pending) {
            svga_buffer_upload_flush(svga, sbuf);

            if (svga_buffer_has_hw_storage(sbuf)) {
               /*
                * We have a pending DMA upload from a hardware buffer, therefore
                * we need to ensure that the host finishes processing that DMA
                * command before the state tracker can start overwriting the
                * hardware buffer.
                *
                * XXX: This could be avoided by tying the hardware buffer to
                * the transfer (just as done with textures), which would allow
                * overlapping DMAs commands to be queued on the same context
                * buffer. However, due to the likelihood of software vertex
                * processing, it is more convenient to hold on to the hardware
                * buffer, allowing to quickly access the contents from the CPU
                * without having to do a DMA download from the host.
                */

               if (usage & PIPE_TRANSFER_DONTBLOCK) {
                  /*
                   * Flushing the command buffer here will most likely cause
                   * the map of the hwbuf below to block, so preemptively
                   * return NULL here if DONTBLOCK is set to prevent unnecessary
                   * command buffer flushes.
                   */

                  FREE(transfer);
                  return NULL;
               }

               svga_context_flush(svga, NULL);
            }
         }

         sbuf->dma.flags.unsynchronized = FALSE;
      }
   }

   if (!sbuf->swbuf && !svga_buffer_has_hw_storage(sbuf)) {
      if (svga_buffer_create_hw_storage(ss, sbuf) != PIPE_OK) {
         /*
          * We can't create a hardware buffer big enough, so create a malloc
          * buffer instead.
          */
         if (0) {
            debug_printf("%s: failed to allocate %u KB of DMA, "
                         "splitting DMA transfers\n",
                         __FUNCTION__,
                         (sbuf->b.b.width0 + 1023)/1024);
         }

         sbuf->swbuf = align_malloc(sbuf->b.b.width0, 16);
         if (!sbuf->swbuf) {
            FREE(transfer);
            return NULL;
         }
      }
   }

   if (sbuf->swbuf) {
      /* User/malloc buffer */
      map = sbuf->swbuf;
   }
   else if (svga_buffer_has_hw_storage(sbuf)) {
      boolean retry;

      map = svga_buffer_hw_storage_map(svga, sbuf, transfer->usage, &retry);
      if (map == NULL && retry) {
         /*
          * At this point, svga_buffer_get_transfer() has already
          * hit the DISCARD_WHOLE_RESOURCE path and flushed HWTNL
          * for this buffer.
          */
         svga_context_flush(svga, NULL);
         map = svga_buffer_hw_storage_map(svga, sbuf, transfer->usage, &retry);
      }
   }
   else {
      map = NULL;
   }

   if (map) {
      ++sbuf->map.count;
      map += transfer->box.x;
      *ptransfer = transfer;
   } else {
      FREE(transfer);
   }
   
   return map;
}


static void
svga_buffer_transfer_flush_region( struct pipe_context *pipe,
                                   struct pipe_transfer *transfer,
                                   const struct pipe_box *box)
{
   struct svga_screen *ss = svga_screen(pipe->screen);
   struct svga_buffer *sbuf = svga_buffer(transfer->resource);

   unsigned offset = transfer->box.x + box->x;
   unsigned length = box->width;

   assert(transfer->usage & PIPE_TRANSFER_WRITE);
   assert(transfer->usage & PIPE_TRANSFER_FLUSH_EXPLICIT);

   pipe_mutex_lock(ss->swc_mutex);
   svga_buffer_add_range(sbuf, offset, offset + length);
   pipe_mutex_unlock(ss->swc_mutex);
}


static void
svga_buffer_transfer_unmap( struct pipe_context *pipe,
                            struct pipe_transfer *transfer )
{
   struct svga_screen *ss = svga_screen(pipe->screen);
   struct svga_context *svga = svga_context(pipe);
   struct svga_buffer *sbuf = svga_buffer(transfer->resource);
   
   pipe_mutex_lock(ss->swc_mutex);
   
   assert(sbuf->map.count);
   if (sbuf->map.count) {
      --sbuf->map.count;
   }

   if (svga_buffer_has_hw_storage(sbuf)) {
      svga_buffer_hw_storage_unmap(svga, sbuf);
   }

   if (transfer->usage & PIPE_TRANSFER_WRITE) {
      if (!(transfer->usage & PIPE_TRANSFER_FLUSH_EXPLICIT)) {
         /*
          * Mapped range not flushed explicitly, so flush the whole buffer,
          * and tell the host to discard the contents when processing the DMA
          * command.
          */

         SVGA_DBG(DEBUG_DMA, "flushing the whole buffer\n");
   
         sbuf->dma.flags.discard = TRUE;

         svga_buffer_add_range(sbuf, 0, sbuf->b.b.width0);
      }
   }

   pipe_mutex_unlock(ss->swc_mutex);
   FREE(transfer);
}


static void
svga_buffer_destroy( struct pipe_screen *screen,
		     struct pipe_resource *buf )
{
   struct svga_screen *ss = svga_screen(screen); 
   struct svga_buffer *sbuf = svga_buffer( buf );

   assert(!p_atomic_read(&buf->reference.count));
   
   assert(!sbuf->dma.pending);

   if(sbuf->handle)
      svga_buffer_destroy_host_surface(ss, sbuf);
   
   if(sbuf->uploaded.buffer)
      pipe_resource_reference(&sbuf->uploaded.buffer, NULL);

   if(sbuf->hwbuf)
      svga_buffer_destroy_hw_storage(ss, sbuf);
   
   if(sbuf->swbuf && !sbuf->user)
      align_free(sbuf->swbuf);
   
   ss->total_resource_bytes -= sbuf->size;

   FREE(sbuf);
}


struct u_resource_vtbl svga_buffer_vtbl = 
{
   u_default_resource_get_handle,      /* get_handle */
   svga_buffer_destroy,		     /* resource_destroy */
   svga_buffer_transfer_map,	     /* transfer_map */
   svga_buffer_transfer_flush_region,  /* transfer_flush_region */
   svga_buffer_transfer_unmap,	     /* transfer_unmap */
   u_default_transfer_inline_write   /* transfer_inline_write */
};



struct pipe_resource *
svga_buffer_create(struct pipe_screen *screen,
		   const struct pipe_resource *template)
{
   struct svga_screen *ss = svga_screen(screen);
   struct svga_buffer *sbuf;
   
   sbuf = CALLOC_STRUCT(svga_buffer);
   if(!sbuf)
      goto error1;
   
   sbuf->b.b = *template;
   sbuf->b.vtbl = &svga_buffer_vtbl;
   pipe_reference_init(&sbuf->b.b.reference, 1);
   sbuf->b.b.screen = screen;

   if(svga_buffer_needs_hw_storage(template->bind)) {
      if(svga_buffer_create_host_surface(ss, sbuf) != PIPE_OK)
         goto error2;
   }
   else {
      sbuf->swbuf = align_malloc(template->width0, 64);
      if(!sbuf->swbuf)
         goto error2;
   }
      
   debug_reference(&sbuf->b.b.reference,
                   (debug_reference_descriptor)debug_describe_resource, 0);

   sbuf->size = util_resource_size(template);
   ss->total_resource_bytes += sbuf->size;

   return &sbuf->b.b; 

error2:
   FREE(sbuf);
error1:
   return NULL;
}

struct pipe_resource *
svga_user_buffer_create(struct pipe_screen *screen,
                        void *ptr,
                        unsigned bytes,
			unsigned bind)
{
   struct svga_buffer *sbuf;
   
   sbuf = CALLOC_STRUCT(svga_buffer);
   if(!sbuf)
      goto no_sbuf;
      
   pipe_reference_init(&sbuf->b.b.reference, 1);
   sbuf->b.vtbl = &svga_buffer_vtbl;
   sbuf->b.b.screen = screen;
   sbuf->b.b.format = PIPE_FORMAT_R8_UNORM; /* ?? */
   sbuf->b.b.usage = PIPE_USAGE_IMMUTABLE;
   sbuf->b.b.bind = bind;
   sbuf->b.b.width0 = bytes;
   sbuf->b.b.height0 = 1;
   sbuf->b.b.depth0 = 1;
   sbuf->b.b.array_size = 1;

   sbuf->swbuf = ptr;
   sbuf->user = TRUE;

   debug_reference(&sbuf->b.b.reference,
                   (debug_reference_descriptor)debug_describe_resource, 0);
   
   return &sbuf->b.b; 

no_sbuf:
   return NULL;
}



@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d106 3
d111 2
a112 1
            svga_buffer_destroy_hw_storage(ss, sbuf);
d139 1
a139 1
            if (sbuf->hwbuf) {
d175 1
a175 1
   if (!sbuf->swbuf && !sbuf->hwbuf) {
d200 2
a201 3
   else if (sbuf->hwbuf) {
      struct svga_screen *ss = svga_screen(pipe->screen);
      struct svga_winsys_screen *sws = ss->sws;
d203 10
a212 1
      map = sws->buffer_map(sws, sbuf->hwbuf, transfer->usage);
d255 1
a255 1
   struct svga_winsys_screen *sws = ss->sws;
d265 2
a266 2
   if (sbuf->hwbuf) {
      sws->buffer_unmap(sws, sbuf->hwbuf);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d34 1
d66 2
a67 2
static struct pipe_transfer *
svga_buffer_get_transfer(struct pipe_context *pipe,
d71 2
a72 1
                         const struct pipe_box *box)
d78 1
d93 3
a95 2
          * Finish writing any pending DMA commands, and tell the host to discard
          * the buffer contents on the next DMA operation.
d98 2
d126 2
a127 2
          * Synchronizing, so finish writing any pending DMA command, and
          * ensure the next DMA will be done in order.
d130 2
a191 15
   return transfer;
}


/**
 * Map a range of a buffer.
 */
static void *
svga_buffer_transfer_map( struct pipe_context *pipe,
                          struct pipe_transfer *transfer )
{
   struct svga_buffer *sbuf = svga_buffer(transfer->resource);

   uint8_t *map;

d209 3
a273 10
}


/**
 * Destroy transfer
 */
static void
svga_buffer_transfer_destroy(struct pipe_context *pipe,
                             struct pipe_transfer *transfer)
{
d301 2
a310 2
   svga_buffer_get_transfer,	     /* get_transfer */
   svga_buffer_transfer_destroy,     /* transfer_destroy */
d347 3
@


1.1
log
@Initial revision
@
text
@d54 17
a70 4
static unsigned int
svga_buffer_is_referenced( struct pipe_context *pipe,
                           struct pipe_resource *buf,
                           unsigned level, int layer)
d72 1
d74 7
a80 1
   struct svga_buffer *sbuf = svga_buffer(buf);
d82 4
a85 16
   /**
    * XXX: Check this.
    * The screen may cache buffer writes, but when we map, we map out
    * of those cached writes, so we don't need to set a
    * PIPE_REFERENCED_FOR_WRITE flag for cached buffers.
    */

   if (!sbuf->handle || ss->sws->surface_is_flushed(ss->sws, sbuf->handle))
     return PIPE_UNREFERENCED;

   /**
    * sws->surface_is_flushed() does not distinguish between read references
    * and write references. So assume a reference is both,
    * however, we make an exception for index- and vertex buffers, to avoid
    * a flush in st_bufferobj_get_subdata, during display list replay.
    */
d87 6
a92 2
   if (sbuf->b.b.bind & (PIPE_BIND_VERTEX_BUFFER | PIPE_BIND_INDEX_BUFFER))
      return PIPE_REFERENCED_FOR_READ;
d94 7
a100 2
   return PIPE_REFERENCED_FOR_READ | PIPE_REFERENCED_FOR_WRITE;
}
d102 2
d105 3
d109 14
d124 2
d127 31
d159 3
a161 11
static void *
svga_buffer_map_range( struct pipe_screen *screen,
                       struct pipe_resource *buf,
                       unsigned offset,
		       unsigned length,
                       unsigned usage )
{
   struct svga_screen *ss = svga_screen(screen); 
   struct svga_winsys_screen *sws = ss->sws;
   struct svga_buffer *sbuf = svga_buffer( buf );
   void *map;
d169 6
a174 3
         debug_printf("%s: failed to allocate %u KB of DMA, splitting DMA transfers\n",
                      __FUNCTION__,
                      (sbuf->b.b.width0 + 1023)/1024);
d177 4
d184 15
d204 4
a207 1
      map = sws->buffer_map(sws, sbuf->hwbuf, usage);
d213 1
a213 1
   if(map) {
d215 1
a215 7

      if (usage & PIPE_TRANSFER_WRITE) {
         assert(sbuf->map.count <= 1);
         sbuf->map.writing = TRUE;
         if (usage & PIPE_TRANSFER_FLUSH_EXPLICIT)
            sbuf->map.flush_explicit = TRUE;
      }
d222 13
a235 8
static void 
svga_buffer_flush_mapped_range( struct pipe_screen *screen,
                                struct pipe_resource *buf,
                                unsigned offset, unsigned length)
{
   struct svga_buffer *sbuf = svga_buffer( buf );
   struct svga_screen *ss = svga_screen(screen);
   
d237 1
a237 5
   assert(sbuf->map.writing);
   if(sbuf->map.writing) {
      assert(sbuf->map.flush_explicit);
      svga_buffer_add_range(sbuf, offset, offset + length);
   }
d241 4
a244 3
static void 
svga_buffer_unmap( struct pipe_screen *screen,
                   struct pipe_resource *buf)
d246 1
a246 1
   struct svga_screen *ss = svga_screen(screen); 
d248 1
a248 1
   struct svga_buffer *sbuf = svga_buffer( buf );
d253 1
a253 1
   if(sbuf->map.count)
d255 1
d257 1
a257 1
   if(sbuf->hwbuf)
d259 9
a268 3
   if(sbuf->map.writing) {
      if(!sbuf->map.flush_explicit) {
         /* No mapped range was flushed -- flush the whole buffer */
d271 2
a274 3
      
      sbuf->map.writing = FALSE;
      sbuf->map.flush_explicit = FALSE;
d281 10
a318 49
/* Keep the original code more or less intact, implement transfers in
 * terms of the old functions.
 */
static void *
svga_buffer_transfer_map( struct pipe_context *pipe,
			  struct pipe_transfer *transfer )
{
   uint8_t *map = svga_buffer_map_range( pipe->screen,
					 transfer->resource,
					 transfer->box.x,
					 transfer->box.width,
					 transfer->usage );
   if (map == NULL)
      return NULL;

   /* map_buffer() returned a pointer to the beginning of the buffer,
    * but transfers are expected to return a pointer to just the
    * region specified in the box.
    */
   return map + transfer->box.x;
}



static void svga_buffer_transfer_flush_region( struct pipe_context *pipe,
					       struct pipe_transfer *transfer,
					       const struct pipe_box *box)
{
   assert(box->x + box->width <= transfer->box.width);

   svga_buffer_flush_mapped_range(pipe->screen,
				  transfer->resource,
				  transfer->box.x + box->x,
				  box->width);
}

static void svga_buffer_transfer_unmap( struct pipe_context *pipe,
			    struct pipe_transfer *transfer )
{
   svga_buffer_unmap(pipe->screen,
		     transfer->resource);
}







d323 2
a324 3
   svga_buffer_is_referenced,	     /* is_resource_referenced */
   u_default_get_transfer,	     /* get_transfer */
   u_default_transfer_destroy,	     /* transfer_destroy */
d359 3
d395 3
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a33 1
#include "util/u_resource.h"
d54 4
a57 18
/**
 * Create a buffer transfer.
 *
 * Unlike texture DMAs (which are written immediately to the command buffer and
 * therefore inherently serialized with other context operations), for buffers
 * we try to coalesce multiple range mappings (i.e, multiple calls to this
 * function) into a single DMA command, for better efficiency in command
 * processing.  This means we need to exercise extra care here to ensure that
 * the end result is exactly the same as if one DMA was used for every mapped
 * range.
 */
static void *
svga_buffer_transfer_map(struct pipe_context *pipe,
                         struct pipe_resource *resource,
                         unsigned level,
                         unsigned usage,
                         const struct pipe_box *box,
                         struct pipe_transfer **ptransfer)
a58 1
   struct svga_context *svga = svga_context(pipe);
d60 1
a60 3
   struct svga_buffer *sbuf = svga_buffer(resource);
   struct pipe_transfer *transfer;
   uint8_t *map;
d62 16
a77 4
   transfer = CALLOC_STRUCT(pipe_transfer);
   if (transfer == NULL) {
      return NULL;
   }
d79 2
a80 4
   transfer->resource = resource;
   transfer->level = level;
   transfer->usage = usage;
   transfer->box = *box;
d82 2
a83 7
   if (usage & PIPE_TRANSFER_WRITE) {
      if (usage & PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE) {
         /*
          * Flush any pending primitives, finish writing any pending DMA
          * commands, and tell the host to discard the buffer contents on
          * the next DMA operation.
          */
a84 1
         svga_hwtnl_flush_buffer(svga, resource);
a85 2
         if (sbuf->dma.pending) {
            svga_buffer_upload_flush(svga, sbuf);
a86 4
            /*
             * Instead of flushing the context command buffer, simply discard
             * the current hwbuf, and start a new one.
             */
a87 2
            svga_buffer_destroy_hw_storage(ss, sbuf);
         }
a88 3
         sbuf->map.num_ranges = 0;
         sbuf->dma.flags.discard = TRUE;
      }
d90 11
a100 55
      if (usage & PIPE_TRANSFER_UNSYNCHRONIZED) {
         if (!sbuf->map.num_ranges) {
            /*
             * No pending ranges to upload so far, so we can tell the host to
             * not synchronize on the next DMA command.
             */

            sbuf->dma.flags.unsynchronized = TRUE;
         }
      } else {
         /*
          * Synchronizing, so flush any pending primitives, finish writing any
          * pending DMA command, and ensure the next DMA will be done in order.
          */

         svga_hwtnl_flush_buffer(svga, resource);

         if (sbuf->dma.pending) {
            svga_buffer_upload_flush(svga, sbuf);

            if (sbuf->hwbuf) {
               /*
                * We have a pending DMA upload from a hardware buffer, therefore
                * we need to ensure that the host finishes processing that DMA
                * command before the state tracker can start overwriting the
                * hardware buffer.
                *
                * XXX: This could be avoided by tying the hardware buffer to
                * the transfer (just as done with textures), which would allow
                * overlapping DMAs commands to be queued on the same context
                * buffer. However, due to the likelihood of software vertex
                * processing, it is more convenient to hold on to the hardware
                * buffer, allowing to quickly access the contents from the CPU
                * without having to do a DMA download from the host.
                */

               if (usage & PIPE_TRANSFER_DONTBLOCK) {
                  /*
                   * Flushing the command buffer here will most likely cause
                   * the map of the hwbuf below to block, so preemptively
                   * return NULL here if DONTBLOCK is set to prevent unnecessary
                   * command buffer flushes.
                   */

                  FREE(transfer);
                  return NULL;
               }

               svga_context_flush(svga, NULL);
            }
         }

         sbuf->dma.flags.unsynchronized = FALSE;
      }
   }
d108 3
a110 6
         if (0) {
            debug_printf("%s: failed to allocate %u KB of DMA, "
                         "splitting DMA transfers\n",
                         __FUNCTION__,
                         (sbuf->b.b.width0 + 1023)/1024);
         }
a112 4
         if (!sbuf->swbuf) {
            FREE(transfer);
            return NULL;
         }
d121 1
a121 4
      struct svga_screen *ss = svga_screen(pipe->screen);
      struct svga_winsys_screen *sws = ss->sws;

      map = sws->buffer_map(sws, sbuf->hwbuf, transfer->usage);
d127 1
a127 1
   if (map) {
d129 7
a135 4
      map += transfer->box.x;
      *ptransfer = transfer;
   } else {
      FREE(transfer);
d142 5
a146 4
static void
svga_buffer_transfer_flush_region( struct pipe_context *pipe,
                                   struct pipe_transfer *transfer,
                                   const struct pipe_box *box)
d148 3
a150 9
   struct svga_screen *ss = svga_screen(pipe->screen);
   struct svga_buffer *sbuf = svga_buffer(transfer->resource);

   unsigned offset = transfer->box.x + box->x;
   unsigned length = box->width;

   assert(transfer->usage & PIPE_TRANSFER_WRITE);
   assert(transfer->usage & PIPE_TRANSFER_FLUSH_EXPLICIT);

d152 5
a156 1
   svga_buffer_add_range(sbuf, offset, offset + length);
d160 3
a162 4

static void
svga_buffer_transfer_unmap( struct pipe_context *pipe,
                            struct pipe_transfer *transfer )
d164 1
a164 1
   struct svga_screen *ss = svga_screen(pipe->screen);
d166 1
a166 1
   struct svga_buffer *sbuf = svga_buffer(transfer->resource);
d171 1
a171 1
   if (sbuf->map.count) {
a172 1
   }
d174 1
a174 1
   if (sbuf->hwbuf) {
a175 9
   }

   if (transfer->usage & PIPE_TRANSFER_WRITE) {
      if (!(transfer->usage & PIPE_TRANSFER_FLUSH_EXPLICIT)) {
         /*
          * Mapped range not flushed explicitly, so flush the whole buffer,
          * and tell the host to discard the contents when processing the DMA
          * command.
          */
d177 3
a181 2
         sbuf->dma.flags.discard = TRUE;

d184 3
a189 1
   FREE(transfer);
d193 1
d217 18
a234 1
   ss->total_resource_bytes -= sbuf->size;
d236 26
a261 1
   FREE(sbuf);
d265 5
d274 3
a310 6
   debug_reference(&sbuf->b.b.reference,
                   (debug_reference_descriptor)debug_describe_resource, 0);

   sbuf->size = util_resource_size(template);
   ss->total_resource_bytes += sbuf->size;

a343 3

   debug_reference(&sbuf->b.b.reference,
                   (debug_reference_descriptor)debug_describe_resource, 0);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a105 3
             * With GB objects, the map operation takes care of this
             * if passed the PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE flag,
             * and the old backing store is busy.
d108 1
a108 2
            if (!svga_have_gb_objects(svga))
               svga_buffer_destroy_hw_storage(ss, sbuf);
d135 1
a135 1
            if (svga_buffer_has_hw_storage(sbuf)) {
d171 1
a171 1
   if (!sbuf->swbuf && !svga_buffer_has_hw_storage(sbuf)) {
d196 3
a198 2
   else if (svga_buffer_has_hw_storage(sbuf)) {
      boolean retry;
d200 1
a200 10
      map = svga_buffer_hw_storage_map(svga, sbuf, transfer->usage, &retry);
      if (map == NULL && retry) {
         /*
          * At this point, svga_buffer_get_transfer() has already
          * hit the DISCARD_WHOLE_RESOURCE path and flushed HWTNL
          * for this buffer.
          */
         svga_context_flush(svga, NULL);
         map = svga_buffer_hw_storage_map(svga, sbuf, transfer->usage, &retry);
      }
d243 1
a243 1
   struct svga_context *svga = svga_context(pipe);
d253 2
a254 2
   if (svga_buffer_has_hw_storage(sbuf)) {
      svga_buffer_hw_storage_unmap(svga, sbuf);
@


